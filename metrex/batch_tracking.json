{
  "batch_ids": [
    "batch_6913ad89adfc81908ea972a8a1ab16b4",
    "batch_6913ad8c9d348190ab0240cf02dbdc84",
    "batch_6913ad8ecee48190bc8ce7ebcefce6d4",
    "batch_6913ad90f2d48190888153d96e63434c",
    "batch_6913ad9230688190a8064d1d7c44c54d"
  ],
  "metadata": {
    "batch_6913ad89adfc81908ea972a8a1ab16b4": {
      "v053dc2 #_475a83ed": {
        "rtl_code": "\nmodule v053dc2 #(\n parameter v71e305 = 0\n) (\n input vf54559,\n input va4102a,\n output ve8318d\n);\n assign ve8318d = vf54559 & va4102a;\nendmodule\nmodule vd0c4e5 (\n input v030ad0,\n input v27dec4,\n input v2d3366,\n output vb192d0\n);\n assign vb192d0 = v27dec4 ? v030ad0 : v2d3366;\nendmodule\nmodule vfebcfe (\n input v9fb85f,\n output v9fb85f_out\n);\n assign v9fb85f_out = v9fb85f;\nendmodule\nmodule vd30ca9 (\n input v9fb85f,\n output v9fb85f_out\n);\n assign v9fb85f_out = ~v9fb85f;\nendmodule\nmodule v144728 #(\n parameter v573b2a = 0\n) (\n input v6dda25,\n input v27dec4,\n input v92a149,\n output v4642b6\n);\n localparam p0 = v573b2a;\n wire w1;\n wire w3;\n wire w6;\n wire w7;\n assign w1 = v6dda25;\n v053dc2 #(\n  .v71e305(p0)\n ) v24b497 (\n  .vf54559(w1),\n  .va4102a(w1),\n  .ve8318d(w6)\n );\n vd0c4e5 vda4b54 (\n  .v030ad0(w1),\n  .v27dec4(v27dec4),\n  .vb192d0(w3),\n  .v2d3366(v27dec4)\n );\n vfebcfe v2141a0 (\n  .v9fb85f(w3)\n );\n vd0c4e5 v75d8ff (\n  .v030ad0(w3),\n  .v27dec4(v92a149),\n  .vb192d0(w7),\n  .v2d3366(v92a149)\n );\n vd30ca9 va595cf (\n  .v9fb85f(w7)\n );\n assign v4642b6 = w7;\nendmodule",
        "module_name": "v053dc2 #",
        "module_hash": "475a83ed0562398166bba3dab84caafc",
        "dataset_index": 6884
      },
      "async_transmitter_5688b22a": {
        "rtl_code": "module async_transmitter(\n\tinput clk,\n\tinput TxD_start,\n\tinput [7:0] TxD_data,\n\toutput TxD,\n\toutput TxD_busy\n);\n\nparameter ClkFrequency = 50000000;\tparameter Baud = 9600;\n\ngenerate\n\tif(ClkFrequency<Baud*8 && (ClkFrequency % Baud!=0)) ASSERTION_ERROR PARAMETER_OUT_OF_RANGE(\"Frequency incompatible with requested Baud rate\");\nendgenerate\n\n`ifdef SIMULATION\nwire BitTick = 1'b1;  `else\nwire BitTick;\nBaudTickGen #(ClkFrequency, Baud) tickgen(.clk(clk), .enable(TxD_busy), .tick(BitTick));\n`endif\n\nreg [3:0] TxD_state = 0;\nwire TxD_ready = (TxD_state==0);\nassign TxD_busy = ~TxD_ready;\n\nreg [7:0] TxD_shift = 0;\nalways @(posedge clk)\nbegin\n\tif(TxD_ready & TxD_start)\n\t\tTxD_shift <= TxD_data;\n\telse\n\tif(TxD_state[3] & BitTick)\n\t\tTxD_shift <= (TxD_shift >> 1);\n\n\tcase(TxD_state)\n\t\t4'b0000: if(TxD_start) TxD_state <= 4'b0100;\n\t\t4'b0100: if(BitTick) TxD_state <= 4'b1000;  4'b1000: if(BitTick) TxD_state <= 4'b1001;  4'b1001: if(BitTick) TxD_state <= 4'b1010;  4'b1010: if(BitTick) TxD_state <= 4'b1011;  4'b1011: if(BitTick) TxD_state <= 4'b1100;  4'b1100: if(BitTick) TxD_state <= 4'b1101;  4'b1101: if(BitTick) TxD_state <= 4'b1110;  4'b1110: if(BitTick) TxD_state <= 4'b1111;  4'b1111: if(BitTick) TxD_state <= 4'b0010;  4'b0010: if(BitTick) TxD_state <= 4'b0011;  4'b0011: if(BitTick) TxD_state <= 4'b0000;  default: if(BitTick) TxD_state <= 4'b0000;\n\tendcase\nend\n\nassign TxD = (TxD_state<4) | (TxD_state[3] & TxD_shift[0]);  endmodule\n\n\nmodule async_receiver(\n\tinput clk,\n\tinput RxD,\n\toutput reg RxD_data_ready = 0,\n\toutput reg [7:0] RxD_data = 0,  output RxD_idle,  output reg RxD_endofpacket = 0  );\n\nparameter ClkFrequency = 25000000; parameter Baud = 115200;\n\nparameter Oversampling = 8;  generate\n\tif(ClkFrequency<Baud*Oversampling) ASSERTION_ERROR PARAMETER_OUT_OF_RANGE(\"Frequency too low for current Baud rate and oversampling\");\n\tif(Oversampling<8 || ((Oversampling & (Oversampling-1))!=0)) ASSERTION_ERROR PARAMETER_OUT_OF_RANGE(\"Invalid oversampling value\");\nendgenerate\n\nreg [3:0] RxD_state = 0;\n\n`ifdef SIMULATION\nwire RxD_bit = RxD;\nwire sampleNow = 1'b1;  `else\nwire OversamplingTick;\nBaudTickGen #(ClkFrequency, Baud, Oversampling) tickgen(.clk(clk), .enable(1'b1), .tick(OversamplingTick));\n\nreg [1:0] RxD_sync = 2'b11;\nalways @(posedge clk) if(OversamplingTick) RxD_sync <= {RxD_sync[0], RxD};\n\nreg [1:0] Filter_cnt = 2'b11;\nreg RxD_bit = 1'b1;\n\nalways @(posedge clk)\nif(OversamplingTick)\nbegin\n\tif(RxD_sync[1]==1'b1 && Filter_cnt!=2'b11) Filter_cnt <= Filter_cnt + 1'd1;\n\telse\n\tif(RxD_sync[1]==1'b0 && Filter_cnt!=2'b00) Filter_cnt <= Filter_cnt - 1'd1;\n\n\tif(Filter_cnt==2'b11) RxD_bit <= 1'b1;\n\telse\n\tif(Filter_cnt==2'b00) RxD_bit <= 1'b0;\nend\n\nfunction integer log2(input integer v); begin log2=0; while(v>>log2) log2=log2+1; end endfunction\nlocalparam l2o = log2(Oversampling);\nreg [l2o-2:0] OversamplingCnt = 0;\nalways @(posedge clk) if(OversamplingTick) OversamplingCnt <= (RxD_state==0) ? 1'd0 : OversamplingCnt + 1'd1;\nwire sampleNow = OversamplingTick && (OversamplingCnt==Oversampling/2-1);\n`endif\n\nalways @(posedge clk)\ncase(RxD_state)\n\t4'b0000: if(~RxD_bit) RxD_state <= `ifdef SIMULATION 4'b1000 `else 4'b0001 `endif;  4'b0001: if(sampleNow) RxD_state <= 4'b1000;  4'b1000: if(sampleNow) RxD_state <= 4'b1001;  4'b1001: if(sampleNow) RxD_state <= 4'b1010;  4'b1010: if(sampleNow) RxD_state <= 4'b1011;  4'b1011: if(sampleNow) RxD_state <= 4'b1100;  4'b1100: if(sampleNow) RxD_state <= 4'b1101;  4'b1101: if(sampleNow) RxD_state <= 4'b1110;  4'b1110: if(sampleNow) RxD_state <= 4'b1111;  4'b1111: if(sampleNow) RxD_state <= 4'b0010;  4'b0010: if(sampleNow) RxD_state <= 4'b0000;  default: RxD_state <= 4'b0000;\nendcase\n\nalways @(posedge clk)\nif(sampleNow && RxD_state[3]) RxD_data <= {RxD_bit, RxD_data[7:1]};\n\nalways @(posedge clk)\nbegin\n\tRxD_data_ready <= (sampleNow && RxD_state==4'b0010 && RxD_bit);  end\n\n`ifdef SIMULATION\nassign RxD_idle = 0;\n`else\nreg [l2o+1:0] GapCnt = 0;\nalways @(posedge clk) if (RxD_state!=0) GapCnt<=0; else if(OversamplingTick & ~GapCnt[log2(Oversampling)+1]) GapCnt <= GapCnt + 1'h1;\nassign RxD_idle = GapCnt[l2o+1];\nalways @(posedge clk) RxD_endofpacket <= OversamplingTick & ~GapCnt[l2o+1] & &GapCnt[l2o:0];\n`endif\n\nendmodule\n\n\nmodule ASSERTION_ERROR();\nendmodule\n\n\nmodule BaudTickGen(\n\tinput clk, enable,\n\toutput tick  );\nparameter ClkFrequency = 25000000;\nparameter Baud = 115200;\nparameter Oversampling = 1;\n\nfunction integer log2(input integer v); begin log2=0; while(v>>log2) log2=log2+1; end endfunction\nlocalparam AccWidth = log2(ClkFrequency/Baud)+8;  reg [AccWidth:0] Acc = 0;\nlocalparam ShiftLimiter = log2(Baud*Oversampling >> (31-AccWidth));  localparam Inc = ((Baud*Oversampling << (AccWidth-ShiftLimiter))+(ClkFrequency>>(ShiftLimiter+1)))/(ClkFrequency>>ShiftLimiter);\nalways @(posedge clk) if(enable) Acc <= Acc[AccWidth-1:0] + Inc[AccWidth:0]; else Acc <= Inc[AccWidth:0];\nassign tick = Acc[AccWidth];\nendmodule\n\n\n",
        "module_name": "async_transmitter",
        "module_hash": "5688b22ab3a1190a4a2bfcc0b6a1b937",
        "dataset_index": 22872
      },
      "moore_machine_b7d9ceee": {
        "rtl_code": "\nmodule moore_machine (\n  input clk,\n  input reset,\n  input x,\n  input y,\n  output reg [1:0] z\n);\n\n  // Define the states using one-hot encoding\n  parameter A = 2'b00;\n  parameter B = 2'b01;\n  parameter C = 2'b10;\n\n  // Define the state register and initialize to state A\n  reg [1:0] state = A;\n\n  // Define the state transition logic\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= A;\n    end else begin\n      case (state)\n        A: begin\n          if (x == 1 && y == 0) begin\n            state <= B;\n          end else if (x == 1 && y == 1) begin\n            state <= C;\n          end else begin\n            state <= A;\n          end\n        end\n        B: begin\n          if (x == 1) begin\n            state <= B;\n          end else begin\n            state <= A;\n          end\n        end\n        C: begin\n          if (x == 1) begin\n            state <= C;\n          end else begin\n            state <= A;\n          end\n        end\n      endcase\n    end\n  end\n\n  // Define the output logic\n  always @(state) begin\n    case (state)\n      A: z <= 2'b00;\n      B: z <= 2'b01;\n      C: z <= 2'b10;\n    endcase\n  end\n\nendmodule",
        "module_name": "moore_machine",
        "module_hash": "b7d9ceee124a28d93907b627a5d986c7",
        "dataset_index": 5229
      },
      "softusb_filter_bcf31754": {
        "rtl_code": "\n\nmodule softusb_filter(\n\tinput usb_clk,\n\n\tinput rcv,\n\tinput vp,\n\tinput vm,\n\n\toutput reg rcv_s,\n\toutput reg vp_s,\n\toutput reg vm_s\n);\n\nreg rcv_s0;\nreg vp_s0;\nreg vm_s0;\nreg rcv_s1;\nreg vp_s1;\nreg vm_s1;\n\n\nalways @(posedge usb_clk) begin\n\trcv_s0 <= rcv;\n\tvp_s0 <= vp;\n\tvm_s0 <= vm;\n\trcv_s <= rcv_s0;\n\tvp_s <= vp_s0;\n\tvm_s <= vm_s0;\nend\n\n\n\n\nendmodule\n",
        "module_name": "softusb_filter",
        "module_hash": "bcf317548842b93fbfd035e4f200dfe7",
        "dataset_index": 23306
      },
      "fifo_buffer_9bf3ed9f": {
        "rtl_code": "module fifo_buffer (\n  input clk,\n  input fifo_rd,\n  input rst_n,\n  output fifo_EF,\n  output reg [7:0] fifo_rdata,\n  output rfifo_full,\n  output reg [5:0] rfifo_used\n);\n\n  // Define FIFO buffer parameters\n  parameter DEPTH = 64;\n  parameter WIDTH = 8;\n\n  // Define FIFO buffer memory\n  reg [WIDTH-1:0] fifo_mem [0:DEPTH-1];\n  reg [6:0] write_ptr;\n  reg [6:0] read_ptr;\n  reg [6:0] used_entries;\n  wire fifo_empty = (used_entries == 0);\n  wire fifo_full = (used_entries == DEPTH);\n\n  // Define FIFO buffer read logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      read_ptr <= 7'b0;\n      fifo_rdata <= 8'b0;\n      rfifo_used <= 6'b0;\n    end\n    else if (fifo_rd && !fifo_empty) begin\n      fifo_rdata <= fifo_mem[read_ptr];\n      read_ptr <= read_ptr + 1;\n      rfifo_used <= used_entries - 1;\n    end\n  end\n\n  // Define FIFO buffer write logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      write_ptr <= 7'b0;\n      used_entries <= 6'b0;\n    end\n    else if (!fifo_full) begin\n      fifo_mem[write_ptr] <= fifo_rdata;\n      write_ptr <= write_ptr + 1;\n      used_entries <= used_entries + 1;\n    end\n  end\n\n  // Define FIFO buffer status outputs\n  assign fifo_EF = fifo_empty;\n  assign rfifo_full = fifo_full;\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "9bf3ed9f7a2f6f2f88629b754e740038",
        "dataset_index": 3672
      },
      "comparator_1981d791": {
        "rtl_code": "\nmodule comparator (\n    input [3:0] in1,\n    input [3:0] in2,\n    output reg out\n);\n\nalways @(*) begin\n    out = (in1 == in2);\nend\n\nendmodule\n\nmodule shift_reg_comp (\n    input clk,\n    input reset,\n    input load,\n    input enable,\n    input [3:0] data_in,\n    output reg [3:0] out\n);\n\nwire comp_out;\n\ncomparator compare_unit (\n    .in1(data_in),\n    .in2(out),\n    .out(comp_out)\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 4'b0;\n    end else if (load) begin\n        out <= data_in;\n    end else if (enable) begin\n        out <= data_in;\n    end\nend\n\nendmodule\n",
        "module_name": "comparator",
        "module_hash": "1981d791e755d7ad734467cdcc867ed1",
        "dataset_index": 21302
      },
      "TLATNTSCAX2TS_207b6266": {
        "rtl_code": "\nmodule TLATNTSCAX2TS (E, SE, CK, ECK);\n  input E, SE, CK;\n  output ECK;\n\n  assign ECK = E & SE & CK;\nendmodule\n\nmodule SNPS_CLOCK_GATE_HIGH_RegisterAdd_W24 ( CLK, EN, TE, ENCLK );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .ECK(ENCLK) );\n  \nendmodule\n",
        "module_name": "TLATNTSCAX2TS",
        "module_hash": "207b6266d4d6de2ce8df3bbc01094385",
        "dataset_index": 21090
      },
      "bw_clk_cclk_inv_128x_3f74e948": {
        "rtl_code": "module bw_clk_cclk_inv_128x (\n    clkout,\n    clkin );\n\n    output clkout;\n    input  clkin;\n \n    assign clkout = ~( clkin );\n\nendmodule\n\n",
        "module_name": "bw_clk_cclk_inv_128x",
        "module_hash": "3f74e948870347f5cf97233f61e17491",
        "dataset_index": 23724
      },
      "full_adder_d1702508": {
        "rtl_code": "\nmodule full_adder (\n    input  wire [7:0] A,\n    input  wire [7:0] B,\n    output wire [8:0] S\n);\n\n    wire [8:0] C;\n\n    // First adder\n    assign {C[1], S[0]} = A[0] + B[0];\n\n    // Middle adders\n    genvar i;\n    generate\n        for (i = 1; i <= 6; i = i + 1) begin : adder_loop\n            assign {C[i+1], S[i]} = A[i] + B[i] + C[i];\n        end\n    endgenerate\n\n    // Last adder\n    assign {C[8], S[7]} = A[7] + B[7] + C[7];\n    assign S[8] = C[8];\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "d17025088a7c6d26f057ff208f3c06cc",
        "dataset_index": 5674
      },
      "counter_abda173a": {
        "rtl_code": "module counter(\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 0;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "abda173a8a5e981a93b9163cd831328d",
        "dataset_index": 20594
      },
      "full_adder_1bit_074c9cc0": {
        "rtl_code": "module full_adder_1bit (\n    output sum,\n    output carry,\n    input a,\n    input b,\n    input c\n);\n\n    wire w1, w2, w3;\n\n    nand n1 (w1, a, b, c);\n    nand n2 (w2, w1, c, b);\n    nand n3 (w3, w1, c, a);\n    nand n4 (sum, w2, w3, c);\n    nand n5 (carry, w1, c, a);\n\nendmodule\n\nmodule nand_adder_4bit (\n    output [3:0] S,\n    output C_out,\n    input [3:0] A,\n    input [3:0] B,\n    input C_in\n);\n\n    wire c0, c1, c2, c3, s0, s1, s2, s3;\n\n    full_adder_1bit fa0 (s0, c0, A[0], B[0], C_in);\n    full_adder_1bit fa1 (s1, c1, A[1], B[1], c0);\n    full_adder_1bit fa2 (s2, c2, A[2], B[2], c1);\n    full_adder_1bit fa3 (s3, c3, A[3], B[3], c2);\n\n    assign S = {s3, s2, s1, s0};\n    assign C_out = c3;\n\nendmodule",
        "module_name": "full_adder_1bit",
        "module_hash": "074c9cc0466cf0210625c5030ea8b252",
        "dataset_index": 7397
      },
      "myDFF_b1a906c7": {
        "rtl_code": "module myDFF (CK, D, RN, SN, Q, QN);\ninput  CK ;\ninput  D ;\ninput  RN ;\ninput  SN ;\noutput Q ;\noutput QN ;\nreg Q;\n\nalways @ (posedge CK) begin\n    if (RN) begin\n        Q <= 1'b0;\n    end else if (SN) begin\n        Q <= 1'b1;\n    end else begin\n        Q <= D;\n    end\nend\n\nassign QN = ~Q;\n\nendmodule",
        "module_name": "myDFF",
        "module_hash": "b1a906c78ed83b6626aad4ebc2708e6f",
        "dataset_index": 13482
      },
      "fixed_point_multiplier_adder_f2a3bf81": {
        "rtl_code": "\nmodule fixed_point_multiplier_adder (\n    input wire CLK,\n    input wire [15:0] A, B, C, D,\n    output wire [31:0] O\n);\n\n    parameter [0:0] A_REG = 0;\n    parameter [0:0] B_REG = 0;\n    parameter [0:0] C_REG = 0;\n    parameter [0:0] D_REG = 0;\n    parameter [0:0] ENABLE_DSP = 0;\n    parameter [0:0] A_SIGNED = 0;\n    parameter [0:0] B_SIGNED = 0;\n\n    wire [15:0] iA, iB, iC, iD;\n    wire [31:0] iF, iJ, iK, iG;\n\n    // Regs C and A, currently unused\n    reg [15:0] rC, rA;\n\n    assign iC = C_REG ? rC : C;\n    assign iA = A_REG ? rA : A;\n\n    // Regs B and D, currently unused\n    reg [15:0] rB, rD;\n\n    assign iB = B_REG ? rB : B;\n    assign iD = D_REG ? rD : D;\n\n    // Multiplier Stage\n    wire [31:0] p_Ah_Bh, p_Al_Bh, p_Ah_Bl, p_Al_Bl;\n    wire [31:0] Ah, Al, Bh, Bl;\n    assign Ah = {A_SIGNED ? {16{iA[15]}} : 16'b0, iA[15: 0]};\n    assign Al = {16'b0, iA[ 7: 0]};\n    assign Bh = {B_SIGNED ? {16{iB[15]}} : 16'b0, iB[15: 0]};\n    assign Bl = {16'b0, iB[ 7: 0]};\n    assign p_Ah_Bh = Ah * Bh; // F\n    assign p_Al_Bh = {16'b0, Al[7:0]} * Bh; // J\n    assign p_Ah_Bl = Ah * {16'b0, Bl[7:0]}; // K\n    assign p_Al_Bl = Al * Bl; // G\n\n    assign iF = p_Ah_Bh;\n    assign iJ = p_Al_Bh;\n\n    assign iK = p_Ah_Bl;\n    assign iG = p_Al_Bl;\n\n    // Adder Stage\n    wire [39:0] iK_e = {A_SIGNED ? {16{iK[31]}} : 16'b0, iK};\n    wire [39:0] iJ_e = {B_SIGNED ? {16{iJ[31]}} : 16'b0, iJ};\n    assign O = ENABLE_DSP ? iG + (iK_e << 16) + (iJ_e << 16) + (iF << 32) : iA + iC;\n\nendmodule",
        "module_name": "fixed_point_multiplier_adder",
        "module_hash": "f2a3bf81ab24d2addacc3368a7e66e14",
        "dataset_index": 19237
      },
      "and_gate_42974b54": {
        "rtl_code": "module and_gate(\n    input a,\n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = a & b & c & d;\nendmodule\n\nmodule or_gate(\n    input a,\n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = a | b | c | d;\nendmodule\n\nmodule xor_gate(\n    input a,\n    input b,\n    output out\n);\n    assign out = a ^ b;\nendmodule\n\nmodule combined_module(\n    input [3:0] in,\n    output out\n);\n    wire and_out;\n    wire or_out;\n    and_gate and_inst(\n        .a(in[0]),\n        .b(in[1]),\n        .c(in[2]),\n        .d(in[3]),\n        .out(and_out)\n    );\n    or_gate or_inst(\n        .a(in[0]),\n        .b(in[1]),\n        .c(in[2]),\n        .d(in[3]),\n        .out(or_out)\n    );\n    xor_gate xor_inst(\n        .a(and_out),\n        .b(or_out),\n        .out(out)\n    );\nendmodule\n\nmodule top_module( \n    input [3:0] in,\n    output out\n);\n    combined_module combined_inst(\n        .in(in),\n        .out(out)\n    );\nendmodule",
        "module_name": "and_gate",
        "module_hash": "42974b544f9c4d201bd39cf02cc66648",
        "dataset_index": 15334
      },
      "decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_rd_status_flags_ss_805f017a": {
        "rtl_code": "module decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_rd_status_flags_ss\n    (AR, E, clk, empty, out, ram_full_fb_i_reg, ram_full_fb_i_reg_0, rd_en, rsts);\n\n    input [0:0] AR;\n    input clk, empty, ram_full_fb_i_reg_0, rd_en;\n    input ram_full_fb_i_reg;\n    input [1:0] E;\n    output rsts;\n    output out;\n\n    wire [0:0] AR;\n    wire [1:0] E;\n    wire clk, empty, ram_full_fb_i_reg, ram_full_fb_i_reg_0, rd_en;\n    reg rsts, out;\n\n    always @(posedge clk) begin\n        if (rd_en && !empty) begin\n            rsts <= 1'b0;\n        end else if (ram_full_fb_i_reg && !ram_full_fb_i_reg_0) begin\n            rsts <= 1'b1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rd_en && !empty) begin\n            out <= 1'b1;\n        end else begin\n            out <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_rd_bin_cntr\n    (AR, ram, E, clk, count, ram_empty_i_reg, rd_en, Q);\n\n    input [0:0] AR;\n    input [7:0] ram;\n    input clk, E, ram_empty_i_reg, rd_en;\n    input [1:0] count;\n    output [5:0] Q;\n\n    wire [0:0] AR;\n    wire [7:0] ram;\n    wire [1:0] count;\n    wire clk, E, ram_empty_i_reg, rd_en;\n    reg [5:0] Q;\n\n    always @(posedge clk) begin\n        if (rd_en && !ram_empty_i_reg) begin\n            Q <= ram[count + AR];\n        end\n    end\n\nendmodule",
        "module_name": "decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_rd_status_flags_ss",
        "module_hash": "805f017a5bb22e45395a0bc69b94ac06",
        "dataset_index": 8456
      },
      "binary_counter_94ca9398": {
        "rtl_code": "module binary_counter (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    output reg [3:0] count  // 4-bit binary counter output\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\nmodule register (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [7:0] d,          // 8-bit input\n    output reg [7:0] q      // 8-bit output\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n\nmodule control_logic (\n    input select,           // Select input to choose between register and counter\n    input [7:0] reg_out,    // Output from the register module\n    input [3:0] counter_out,// Output from the binary_counter module\n    output [7:0] out        // Output of the selected module\n);\n\nassign out = select ? reg_out : counter_out;\n\nendmodule\n\nmodule top_module (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [7:0] d,          // 8-bit input for the register\n    input select,           // Select input to choose between register and counter\n    output [7:0] q          // 8-bit output from the active module\n);\n\nwire [3:0] counter_out;\nwire [7:0] reg_out;\n\nbinary_counter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .count(counter_out)\n);\n\nregister reg_inst (\n    .clk(clk),\n    .reset(reset),\n    .d(d),\n    .q(reg_out)\n);\n\ncontrol_logic control_inst (\n    .select(select),\n    .reg_out(reg_out),\n    .counter_out(counter_out),\n    .out(q)\n);\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "94ca93987e63da77f4f8fa24c8add706",
        "dataset_index": 14772
      },
      "credit_manager #_98235e7f": {
        "rtl_code": "\n\n\n\n\n\n\n\n\n`define RCB_128_SIZE  (128 / 4)\n`define RCB_64_SIZE   ( 64 / 4)\n\nmodule credit_manager #(\n  parameter                 MAX_PKTS = 0\n)(\n  input                     clk,\n  input                     rst,\n\n\n  output        [2:0]       o_fc_sel,             input                     i_rcb_sel,\n  input         [7:0]       i_fc_cplh,            input         [11:0]      i_fc_cpld,            output                    o_ready,              input         [9:0]       i_dword_req_count,\n  input                     i_cmt_stb,            input         [9:0]       i_dword_rcv_count,\n  input                     i_rcv_stb\n);\n\nreg             [7:0]       r_hdr_in_flt;\nreg             [11:0]      r_dat_in_flt;\n\nwire                        w_hdr_rdy;\nwire                        w_dat_rdy;\nreg             [7:0]       r_max_hdr_req;\n\nwire            [7:0]       w_hdr_avail;\nwire            [11:0]      w_dat_avail;\nwire            [15:0]      w_dword_avail;\n\n\nreg             [7:0]       r_hdr_rcv_size;\nreg                         r_delay_rcv_stb;\n\nwire            [11:0]      w_data_credit_req_size;\nwire            [11:0]      w_data_credit_rcv_size;\n\n\nalways @ (*) begin\n  r_max_hdr_req = 0;\n  if (i_rcb_sel) begin\n    if (i_dword_req_count < `RCB_128_SIZE) begin\n      r_max_hdr_req             =  1;\n    end\n    else begin\n      r_max_hdr_req             =  i_dword_req_count[9:5];\n    end\n  end\n  else begin\n    if (i_dword_req_count < `RCB_64_SIZE) begin\n      r_max_hdr_req             = 1;\n    end\n    else begin\n      r_max_hdr_req             = i_dword_req_count[9:4];\n    end\n  end\nend\n\n\nalways @ (*) begin\n  r_hdr_rcv_size  = 0;\n  if (i_rcb_sel) begin\n    if (i_dword_rcv_count < `RCB_128_SIZE) begin\n      r_hdr_rcv_size            = 1;\n    end\n    else begin\n      r_hdr_rcv_size            =  i_dword_rcv_count[9:5];\n    end\n  end\n  else begin\n    if (i_dword_rcv_count < `RCB_64_SIZE) begin\n      r_hdr_rcv_size            = 1;\n    end\n    else begin\n      r_hdr_rcv_size            =  i_dword_rcv_count[9:4];\n    end\n  end\nend\n\nassign  w_data_credit_req_size  = (i_dword_req_count[9:2] == 0) ? 10'h1  : i_dword_req_count[9:2];\nassign  w_data_credit_rcv_size  = (i_dword_rcv_count[9:2] == 0) ? 10'h1  : i_dword_rcv_count[9:2];\n\nassign  w_hdr_avail             = (i_fc_cplh - r_hdr_in_flt);\nassign  w_dat_avail             = (i_fc_cpld - r_dat_in_flt);\nassign  w_dword_avail           = {w_dat_avail, 2'b00};\n\nassign  w_hdr_rdy               = (w_hdr_avail > r_max_hdr_req);\nassign  w_dat_rdy               = (w_dat_avail > w_data_credit_req_size);\n\nassign  o_fc_sel                = 3'h0;\n\nassign  o_ready                 = (MAX_PKTS == 0) ?\n                                     (w_hdr_rdy & w_dat_rdy) :\n                                    ((w_hdr_rdy & w_dat_rdy) && ((r_hdr_in_flt >> 3) <= MAX_PKTS));\n\nalways  @ (posedge clk) begin\n  if (rst) begin\n    r_hdr_in_flt                <=  0;\n    r_dat_in_flt                <=  0;\n    r_delay_rcv_stb             <=  0;\n  end\n  else begin\n    if (i_cmt_stb) begin\n      r_hdr_in_flt              <=  r_hdr_in_flt + r_max_hdr_req;\n      r_dat_in_flt              <=  r_dat_in_flt + w_data_credit_req_size;\n      if (i_rcv_stb) begin\n        r_delay_rcv_stb         <=  1;\n      end\n    end\n    else if (i_rcv_stb || r_delay_rcv_stb) begin\n      r_delay_rcv_stb           <=  0;\n      r_hdr_in_flt              <=  r_hdr_in_flt - r_hdr_rcv_size;\n      r_dat_in_flt              <=  r_dat_in_flt - w_data_credit_rcv_size;\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "credit_manager #",
        "module_hash": "98235e7f5827a272c1036475dc19f7c0",
        "dataset_index": 24742
      },
      "counter_4bit_ae682286": {
        "rtl_code": "module counter_4bit(\n    input clk,\n    input rst,\n    output reg [3:0] count\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'b0;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n",
        "module_name": "counter_4bit",
        "module_hash": "ae68228662c0347ac2199098ef8fec8e",
        "dataset_index": 6290
      },
      "accu_955995b5": {
        "rtl_code": "\nmodule accu(\n    input               clk         ,\n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n\n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [9:0]   data_out\n);\n\nreg [1:0] count;\nreg [9:0] acc;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        count <= 2'b0;\n        acc <= 10'b0;\n        valid_b <= 1'b0;\n    end else begin\n        if (valid_a) begin\n            case (count)\n                2'b00: begin\n                    acc <= acc + data_in;\n                    count <= 2'b01;\n                end\n                2'b01: begin\n                    acc <= acc + data_in;\n                    count <= 2'b10;\n                end\n                2'b10: begin\n                    acc <= acc + data_in;\n                    count <= 2'b11;\n                end\n                2'b11: begin\n                    acc <= acc + data_in;\n                    count <= 2'b00;\n                    valid_b <= 1'b1;\n                    data_out = acc;\n                end\n            endcase\n        end else\n            valid_b <= 1'b0;\n    end\nend\n\nassign ready_a = ~valid_b & ready_b;\n\nendmodule",
        "module_name": "accu",
        "module_hash": "955995b5b1441e20440c720b0f405f70",
        "dataset_index": 285
      },
      "bitwise_op_fe1e824f": {
        "rtl_code": "module bitwise_op(\n    input [99:0] in,\n    input op,\n    output [99:0] out\n);\n\n    assign out = (op == 2'b00) ? (in & in) : \n                 (op == 2'b01) ? (in | in) : \n                 (op == 2'b10) ? (in ^ in) : \n                                 100'b0;\n\nendmodule\n\nmodule mux_256_to_1(\n    input [1023:0] in,\n    input [2:0] sel,\n    output [3:0] out\n);\n\n    wire [7:0] mux_out [0:255];\n\n    genvar i;\n    generate\n        for (i = 0; i < 256; i = i + 1) begin : mux_block\n            assign mux_out[i] = in[(i*4)+:4];\n        end\n    endgenerate\n\n    assign out = mux_out[sel];\n\nendmodule\n\nmodule functional_module(\n    input [99:0] bitwise_out,\n    input [3:0] mux_out,\n    output [3:0] out\n);\n\n    assign out = bitwise_out ^ mux_out;\n\nendmodule\n\nmodule top_module( \n    input clk,\n    input reset, // Synchronous active-high reset\n    input [99:0] in, // Input for the bitwise operation module\n    input [1023:0] mux_in, // Input vector for the multiplexer\n    input [2:0] sel, // Select input for the multiplexer\n    output [3:0] out // Final 4-bit output\n);\n\n    wire [99:0] bitwise_out;\n    wire [3:0] mux_out;\n\n    bitwise_op bitwise_op_inst (\n        .in(in),\n        .op(3'b000),\n        .out(bitwise_out)\n    );\n\n    mux_256_to_1 mux_inst (\n        .in(mux_in),\n        .sel(sel),\n        .out(mux_out)\n    );\n\n    functional_module functional_inst (\n        .bitwise_out(bitwise_out),\n        .mux_out(mux_out),\n        .out(out)\n    );\n\nendmodule",
        "module_name": "bitwise_op",
        "module_hash": "fe1e824fd093931067b3c20c4098d4ed",
        "dataset_index": 12272
      },
      "bluetooth_010fe37f": {
        "rtl_code": "\nmodule bluetooth (\n  input [n-1:0] in,\n  input clk,\n  input rst,\n  output bt_out,\n  input bt_in,\n  output [n-1:0] out\n);\n\nparameter n = 8; // number of input/output signals\n\n// additional parameters for configuring the transmitter and receiver blocks\nparameter MODULATION_SCHEME = \"GFSK\";\nparameter FHSS_ENABLED = 1;\nparameter FHSS_PATTERN = \"10101010\";\nparameter DFE_ENABLED = 1;\nparameter [3:0] DFE_COEFFICIENTS = {3'b010, 3'b100, 3'b010, 3'b000}; // fixed the width\n\n// transmitter block\nreg [n-1:0] data;\nreg [7:0] bt_out_reg;\ninteger i, j;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    bt_out_reg <= 8'b0;\n  end else begin\n    data <= in;\n    case (MODULATION_SCHEME)\n      \"GFSK\": begin\n        // implement GFSK modulation scheme\n        for (i = 0; i < n; i = i + 2) begin\n          for (j = 0; j < 8; j = j + 2) begin\n            bt_out_reg[j] <= data[i] ^ data[i+1];\n            bt_out_reg[j+1] <= data[i+1];\n          end\n        end\n      end\n      // add support for other modulation schemes here\n    endcase\n    if (FHSS_ENABLED) begin\n      // implement FHSS technique\n      for (i = 0; i < 8; i = i + 1) begin\n        if (FHSS_PATTERN[i]) begin\n          bt_out_reg <= {bt_out_reg[6:0], bt_out_reg[7]};\n        end\n      end\n    end\n  end\nend\n\nassign bt_out = bt_out_reg;\n\n// receiver block\nreg [7:0] bt_in_reg;\nreg [n-1:0] out_reg;\ninteger k;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    bt_in_reg <= 8'b0;\n    out_reg <= {n{1'b0}};\n  end else begin\n    bt_in_reg <= bt_in;\n    if (FHSS_ENABLED) begin\n      // implement FHSS technique\n      for (k = 0; k < 8; k = k + 1) begin\n        if (FHSS_PATTERN[k]) begin\n          bt_in_reg <= {bt_in_reg[6:0], bt_in_reg[7]};\n        end\n      end\n    end\n    case (MODULATION_SCHEME)\n      \"GFSK\": begin\n        // implement GFSK demodulation scheme\n        for (i = 0; i < n; i = i + 2) begin\n          for (j = 0; j < 8; j = j + 2) begin\n            out_reg[i] <= bt_in_reg[j] ^ bt_in_reg[j+1];\n            out_reg[i+1] <= bt_in_reg[j+1];\n          end\n        end\n      end\n      // add support for other modulation schemes here\n    endcase\n    if (DFE_ENABLED) begin\n      // implement DFE technique\n      for (i = 0; i < n; i = i + 1) begin\n        if (i == 0) begin\n          out_reg[i] <= out_reg[i] - DFE_COEFFICIENTS[1] * bt_in_reg[7] - DFE_COEFFICIENTS[2] * bt_in_reg[0];\n        end else if (i == n-1) begin\n          out_reg[i] <= out_reg[i] - DFE_COEFFICIENTS[1] * bt_in_reg[6] - DFE_COEFFICIENTS[2] * bt_in_reg[0];\n        end else begin\n          out_reg[i] <= out_reg[i] - DFE_COEFFICIENTS[0] * bt_in_reg[6] - DFE_COEFFICIENTS[1] * bt_in_reg[7] - DFE_COEFFICIENTS[2] * bt_in_reg[0];\n        end\n      end\n    end\n  end\nend\n\nassign out = out_reg;\n\nendmodule",
        "module_name": "bluetooth",
        "module_hash": "010fe37f35add2c685046ba867547675",
        "dataset_index": 14843
      },
      "binary_adder_11770842": {
        "rtl_code": "\nmodule binary_adder (\n    output COUT,\n    output SUM,\n    input A,\n    input B,\n    input CI,\n    input VPWR,\n    input VGND\n);\n\nassign SUM = A ^ B ^ CI;\nassign COUT = (A & B) | (CI & (A ^ B));\n\nendmodule\nmodule fah (\n    output COUT,\n    output SUM,\n    input A,\n    input B,\n    input CI,\n    input VPWR,\n    input VGND\n);\n\nassign SUM = A ^ B ^ CI;\nassign COUT = (A & B) | (CI & (A ^ B));\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "11770842f945f048f0b6f7b83f197059",
        "dataset_index": 3553
      },
      "lcd_driver_d6047d03": {
        "rtl_code": "module lcd_driver (\n  input [3:0] data,\n  input [1:0] ctrl,\n  output [6:0] seg\n);\n\n  // Define the 7-bit segment signal as a Boolean function of the 4-bit data signal and the 2-bit control signal\n  assign seg[0] = (data[0] & ctrl[0]) | (~data[0] & ctrl[1]);\n  assign seg[1] = (data[1] & ctrl[0]) | (~data[1] & ctrl[1]);\n  assign seg[2] = (data[2] & ctrl[0]) | (~data[2] & ctrl[1]);\n  assign seg[3] = (data[3] & ctrl[0]) | (~data[3] & ctrl[1]);\n  assign seg[4] = ctrl[0];\n  assign seg[5] = ctrl[1];\n  assign seg[6] = 0;\n\nendmodule",
        "module_name": "lcd_driver",
        "module_hash": "d6047d03357561cd9db39f7668a68a3e",
        "dataset_index": 16742
      },
      "top__3c620f07": {
        "rtl_code": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output z\n);\n\n    wire mux_out;\n    wire xor_in1, xor_in2;\n    \n    // 2-to-1 multiplexer\n    mux_2to1 mux_inst (\n        .a(a),\n        .b(b),\n        .sel(sel),\n        .mux_out(mux_out)\n    );\n    \n    // XOR gate\n    xor_gate xor_inst (\n        .xor_in1(mux_out),\n        .xor_in2(sel),\n        .xor_out(z)\n    );\n    \nendmodule\n\nmodule mux_2to1 (\n    input a,\n    input b,\n    input sel,\n    output mux_out\n);\n\n    assign mux_out = (sel == 1'b0) ? a : b;\n    \nendmodule\n\nmodule xor_gate (\n    input xor_in1,\n    input xor_in2,\n    output xor_out\n);\n\n    assign xor_out = xor_in1 ^ xor_in2;\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "3c620f076f6577600fc08b8ece3f5e44",
        "dataset_index": 14637
      },
      "pipelined_booth_multiplier_392ceaa3": {
        "rtl_code": "module pipelined_booth_multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    input clk,\n    output [31:0] result\n);\n\nreg [7:0] reg_file [0:7]; // register file of size 8x16\nreg [15:0] a_reg, b_reg, shift_reg; // registers for inputs and shift register\nreg [31:0] product_reg; // register for product\nreg [3:0] state; // state register for pipeline stages\nreg [1:0] count; // count register for booth algorithm\nwire [15:0] adder_input; // input to the 16-bit adder\n\nassign adder_input = (state == 0) ? {a_reg[15], a_reg} - (b_reg << 1) :\n                    (state == 1) ? {a_reg[15], a_reg} + (b_reg << 1) :\n                    (state == 2) ? {a_reg[15], a_reg} : 16'b0;\n\nalways @(posedge clk) begin\n    if (state == 0) begin // Booth algorithm stage 1\n        a_reg <= a;\n        b_reg <= b;\n        shift_reg <= b;\n        count <= 2'b01;\n        state <= 1;\n    end\n    else if (state == 1) begin // Booth algorithm stage 2\n        shift_reg <= {shift_reg[14], shift_reg};\n        count <= (shift_reg[15:14] == 2'b01 || shift_reg[15:14] == 2'b10) ? 2'b10 : 2'b01;\n        state <= 2;\n    end\n    else if (state == 2) begin // Booth algorithm stage 3\n        product_reg <= {16'b0, adder_input} + product_reg;\n        state <= 3;\n    end\n    else begin // Booth algorithm stage 4\n        reg_file[count] <= product_reg[15:0];\n        product_reg <= {product_reg[31], product_reg[31:16]};\n        count <= count + 2'b01;\n        state <= (count == 2'b11) ? 0 : 1;\n    end\nend\n\nassign result = {reg_file[7], reg_file[6], reg_file[5], reg_file[4], reg_file[3], reg_file[2], reg_file[1], reg_file[0]};\n\nendmodule",
        "module_name": "pipelined_booth_multiplier",
        "module_hash": "392ceaa35c9b28677384e941a43bb9e3",
        "dataset_index": 4890
      },
      "fifo_generator_rx_inst_blk_mem_gen_prim_wrapper__parameterized0_7ca999a4": {
        "rtl_code": "module fifo_generator_rx_inst_blk_mem_gen_prim_wrapper__parameterized0\n  (Q,\n   clk,\n   din,\n   dout,\n   count_d1_reg,\n   out,\n   ram_full_fb_i_reg,\n   tmp_ram_rd_en);\n\n  input [11:0] Q;\n  input clk;\n  input [8:0] din;\n  output [8:0] dout;\n  input [11:0] count_d1_reg;\n  input [0:0] out;\n  input ram_full_fb_i_reg;\n  input tmp_ram_rd_en;\n\n  reg [11:0] count_reg;\n  reg [8:0] mem [0:15];\n  reg [3:0] write_ptr;\n  reg [3:0] read_ptr;\n  reg [3:0] count;\n  wire full = (count == 16);\n  wire empty = (count == 0);\n  wire rd_en = (tmp_ram_rd_en && !empty);\n  wire wr_en = (!full);\n\n  assign dout = mem[read_ptr];\n  assign Q = count_reg;\n\n  always @(posedge clk) begin\n    if (wr_en) begin\n      mem[write_ptr] <= din;\n      write_ptr <= write_ptr + 1;\n      count <= count + 1;\n    end\n    if (rd_en) begin\n      read_ptr <= read_ptr + 1;\n      count <= count - 1;\n    end\n    if (ram_full_fb_i_reg) begin\n      count_reg <= count_d1_reg;\n    end\n    else begin\n      count_reg <= count;\n    end\n  end\n\nendmodule",
        "module_name": "fifo_generator_rx_inst_blk_mem_gen_prim_wrapper__parameterized0",
        "module_hash": "7ca999a409110cf13e71b4a6c7e921c4",
        "dataset_index": 5130
      },
      "mux4x1_348f34dd": {
        "rtl_code": "module mux4x1 (\n    input [1:0] sel,\n    input [3:0] din,\n    output reg dout\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: dout = din[0];\n        2'b01: dout = din[1];\n        2'b10: dout = din[2];\n        2'b11: dout = din[3];\n    endcase\nend\n\nendmodule",
        "module_name": "mux4x1",
        "module_hash": "348f34dd19b77abeb828e787d0492ce0",
        "dataset_index": 3735
      },
      "top__bdf60764": {
        "rtl_code": "module top_module (\n    input [3:0] in,\n    input a,\n    input b,\n    input clk,\n    input reset,\n    output reg final_out\n);\n\n    // First given module\n    wire [1:0] and1, and2, or1, or2, xor1, xor2;\n    assign and1 = in[0] & in[1];\n    assign and2 = in[2] & in[3];\n    assign or1 = in[0] | in[1];\n    assign or2 = in[2] | in[3];\n    assign xor1 = in[0] ^ in[1];\n    assign xor2 = in[2] ^ in[3];\n    wire out_and, out_or, out_xor;\n    assign out_and = and1 & and2;\n    assign out_or = or1 | or2;\n    assign out_xor = xor1 ^ xor2;\n\n    // Second given module\n    reg xor_gate_out;\n    always @ (a or b) begin\n        case ({a,b})\n            2'b00: xor_gate_out = 1'b0;\n            2'b01: xor_gate_out = 1'b1;\n            2'b10: xor_gate_out = 1'b1;\n            2'b11: xor_gate_out = 1'b0;\n        endcase\n    end\n\n    // Functional module\n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            final_out <= 1'b0;\n        end else begin\n            final_out <= (out_and & out_or) ^ (out_xor ^ xor_gate_out);\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "bdf60764e637cc81d48e060408c31ca4",
        "dataset_index": 12099
      },
      "unsigned_multiplier_7cfe225c": {
        "rtl_code": "\nmodule unsigned_multiplier (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] p\n);\n\nreg [7:0] shift_reg;\nreg [3:0] count;\n\nalways @(a, b) begin\n    p = 0;\n    shift_reg = b;\n    count = 8;\n\n    for (count = 8; count > 0; count = count - 1) begin\n        if (shift_reg[0] == 1) begin\n            p = p + (a << (8 - count));\n        end\n        shift_reg = shift_reg >> 1;\n    end\nend\n\nendmodule",
        "module_name": "unsigned_multiplier",
        "module_hash": "7cfe225cc7b44f1179e293a506097831",
        "dataset_index": 15389
      },
      "sky130_fd_sc_ms__o31a_2c926011": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__o31a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1, A3     );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__o31a",
        "module_hash": "2c9260118a0952193c5362c252131777",
        "dataset_index": 23507
      },
      "shift_register_c2a84922": {
        "rtl_code": "module shift_register (\n    input [3:0] data_in,\n    input shift_left,\n    input clock,\n    input reset,\n    output [3:0] data_out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clock) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            if (shift_left) begin\n                shift_reg <= {shift_reg[2:0], data_in};\n            end else begin\n                shift_reg <= {data_in, shift_reg[3:1]};\n            end\n        end\n    end\n\n    assign data_out = shift_reg;\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "c2a8492256c4ef695a1c847bb2490c13",
        "dataset_index": 7360
      },
      "binary_adder_349cb5a0": {
        "rtl_code": "\nmodule binary_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [4:0] temp;\n  wire carry;\n\n  assign temp = A + B + Cin;\n  assign Cout = temp[4];\n  assign S = temp[3:0];\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "349cb5a079e721c040193b24d2ea46a1",
        "dataset_index": 14579
      },
      "sky130_fd_sc_ms__nor2b_7be9cae0": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__nor2b (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    wire not0_out  ;\n    wire and0_out_Y;\n\n    not not0 (not0_out  , A              );\n    and and0 (and0_out_Y, not0_out, B_N  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__nor2b",
        "module_hash": "7be9cae0160651d307b3909e5a1cd479",
        "dataset_index": 13011
      },
      "_T_146_ext_39171621": {
        "rtl_code": "\nmodule _T_146_ext(\n  input W0_clk,\n  input [5:0] W0_addr,\n  input W0_en,\n  input [87:0] W0_data,\n  input [3:0] W0_mask,\n  input R0_clk,\n  input [5:0] R0_addr,\n  input R0_en,\n  output [87:0] R0_data\n);\n\n  reg [5:0] reg_R0_addr;\n  reg [87:0] ram [63:0];\n  `ifdef RANDOMIZE\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 64; initvar = initvar+1)\n        ram[initvar] = {3 {$random}};\n      reg_R0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge R0_clk)\n    if (R0_en) reg_R0_addr <= R0_addr;\n  always @(posedge W0_clk)\n    if (W0_en) begin\n      if (W0_mask[0]) ram[W0_addr][21:0] <= W0_data[21:0];\n      if (W0_mask[1]) ram[W0_addr][43:22] <= W0_data[43:22];\n      if (W0_mask[2]) ram[W0_addr][65:44] <= W0_data[65:44];\n      if (W0_mask[3]) ram[W0_addr][87:66] <= W0_data[87:66];\n    end\n  assign R0_data = ram[reg_R0_addr];\n\nendmodule\n\nmodule _T_80_ext(\n  input W0_clk,\n  input [8:0] W0_addr,\n  input W0_en,\n  input [63:0] W0_data,\n  input [0:0] W0_mask,\n  input R0_clk,\n  input [8:0] R0_addr,\n  input R0_en,\n  output [63:0] R0_data\n);\n\n  reg [8:0] reg_R0_addr;\n  reg [63:0] ram [511:0];\n  `ifdef RANDOMIZE\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 512; initvar = initvar+1)\n        ram[initvar] = {2 {$random}};\n      reg_R0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge R0_clk)\n    if (R0_en) reg_R0_addr <= R0_addr;\n  always @(posedge W0_clk)\n    if (W0_en) begin\n      if (W0_mask[0]) ram[W0_addr][63:0] <= W0_data[63:0];\n    end\n  assign R0_data = ram[reg_R0_addr];\n\nendmodule\n\nmodule tag_array_ext(\n  input RW0_clk,\n  input [5:0] RW0_addr,\n  input RW0_en,\n  input RW0_wmode,\n  input [3:0] RW0_wmask,\n  input [79:0] RW0_wdata,\n  output [79:0] RW0_rdata\n);\n\n  reg [5:0] reg_RW0_addr;\n  reg [79:0] ram [63:0];\n  `ifdef RANDOMIZE\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 64; initvar = initvar+1)\n        ram[initvar] = {3 {$random}};\n      reg_RW0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge RW0_clk)\n    if (RW0_en && !RW0_wmode) reg_RW0_addr <= RW0_addr;\n  always @(posedge RW0_clk)\n    if (RW0_en && RW0_wmode) begin\n      if (RW0_wmask[0]) ram[RW0_addr][19:0] <= RW0_wdata[19:0];\n      if (RW0_wmask[1]) ram[RW0_addr][39:20] <= RW0_wdata[39:20];\n      if (RW0_wmask[2]) ram[RW0_addr][59:40] <= RW0_wdata[59:40];\n      if (RW0_wmask[3]) ram[RW0_addr][79:60] <= RW0_wdata[79:60];\n    end\n  assign RW0_rdata = ram[reg_RW0_addr];\n\nendmodule\n\nmodule _T_850_ext(\n  input RW0_clk,\n  input [8:0] RW0_addr,\n  input RW0_en,\n  input RW0_wmode,\n  input [63:0] RW0_wdata,\n  output [63:0] RW0_rdata\n);\n\n  reg [8:0] reg_RW0_addr;\n  reg [63:0] ram [511:0];\n  `ifdef RANDOMIZE\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 512; initvar = initvar+1)\n        ram[initvar] = {2 {$random}};\n      reg_RW0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge RW0_clk)\n    if (RW0_en && !RW0_wmode) reg_RW0_addr <= RW0_addr;\n  always @(posedge RW0_clk)\n    if (RW0_en && RW0_wmode) begin\n      ram[RW0_addr][63:0] <= RW0_wdata[63:0];\n    end\n  assign RW0_rdata = ram[reg_RW0_addr];\n\nendmodule\n\nmodule mem_ext(\n  input W0_clk,\n  input [24:0] W0_addr,\n  input W0_en,\n  input [63:0] W0_data,\n  input [7:0] W0_mask,\n  input R0_clk,\n  input [24:0] R0_addr,\n  input R0_en,\n  output [63:0] R0_data\n);\n\n  reg [24:0] reg_R0_addr;\n  reg [63:0] ram [33554431:0];\n  `ifdef RANDOMIZE\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 33554432; initvar = initvar+1)\n        ram[initvar] = {2 {$random}};\n      reg_R0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge R0_clk)\n    if (R0_en) reg_R0_addr <= R0_addr;\n  always @(posedge W0_clk)\n    if (W0_en) begin\n      if (W0_mask[0]) ram[W0_addr][7:0] <= W0_data[7:0];\n      if (W0_mask[1]) ram[W0_addr][15:8] <= W0_data[15:8];\n      if (W0_mask[2]) ram[W0_addr][23:16] <= W0_data[23:16];\n      if (W0_mask[3]) ram[W0_addr][31:24] <= W0_data[31:24];\n      if (W0_mask[4]) ram[W0_addr][39:32] <= W0_data[39:32];\n      if (W0_mask[5]) ram[W0_addr][47:40] <= W0_data[47:40];\n      if (W0_mask[6]) ram[W0_addr][55:48] <= W0_data[55:48];\n      if (W0_mask[7]) ram[W0_addr][63:56] <= W0_data[63:56];\n    end\n  assign R0_data = ram[reg_R0_addr];\n\nendmodule\n\nmodule mem_0_ext(\n  input W0_clk,\n  input [8:0] W0_addr,\n  input W0_en,\n  input [63:0] W0_data,\n  input [7:0] W0_mask,\n  input R0_clk,\n  input [8:0] R0_addr,\n  input R0_en,\n  output [63:0] R0_data\n);\n\n  reg [8:0] reg_R0_addr;\n  reg [63:0] ram [511:0];\n  `ifdef RANDOMIZE\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 512; initvar = initvar+1)\n        ram[initvar] = {2 {$random}};\n      reg_R0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge R0_clk)\n    if (R0_en) reg_R0_addr <= R0_addr;\n  always @(posedge W0_clk)\n    if (W0_en) begin\n      if (W0_mask[0]) ram[W0_addr][7:0] <= W0_data[7:0];\n      if (W0_mask[1]) ram[W0_addr][15:8] <= W0_data[15:8];\n      if (W0_mask[2]) ram[W0_addr][23:16] <= W0_data[23:16];\n      if (W0_mask[3]) ram[W0_addr][31:24] <= W0_data[31:24];\n      if (W0_mask[4]) ram[W0_addr][39:32] <= W0_data[39:32];\n      if (W0_mask[5]) ram[W0_addr][47:40] <= W0_data[47:40];\n      if (W0_mask[6]) ram[W0_addr][55:48] <= W0_data[55:48];\n      if (W0_mask[7]) ram[W0_addr][63:56] <= W0_data[63:56];\n    end\n  assign R0_data = ram[reg_R0_addr];\n\nendmodule\n",
        "module_name": "_T_146_ext",
        "module_hash": "39171621b6978d8f492856c1c0f56049",
        "dataset_index": 21581
      },
      "mux4x1_f6e4871f": {
        "rtl_code": "module mux4x1(data0, data1, data2, data3, selectInput, out);\n    \n    output reg [7:0] out;\n    input [7:0] data0, data1, data2, data3;\n    input [1:0] selectInput;\n\n    always @(*) begin\n        case (selectInput)\n            2'b00: out = data0;\n            2'b01: out = data1;\n            2'b10: out = data2;\n            2'b11: out = data3;\n        endcase\n    end\n\nendmodule",
        "module_name": "mux4x1",
        "module_hash": "f6e4871f6962ce7bc16d16dd8bf32212",
        "dataset_index": 14463
      },
      "mux2to1_28d64ba4": {
        "rtl_code": "\nmodule mux2to1(\n    input [3:0] in0, in1,\n    input sel,\n    output [3:0] out\n);\n\n    assign out = sel ? in1 : in0; // 2-to-1 multiplexer logic\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "28d64ba473a10f3b3a787eb0df539c24",
        "dataset_index": 12145
      },
      "BIN_DEC2_91514f0a": {
        "rtl_code": "\nmodule BIN_DEC2(\n\n\tinput [15:0] B2,\n\toutput reg [19:0] bcdout2\n\t);\n\t\n\treg [35:0] z;\n\tinteger i;\n\nalways @(*)\n  begin\n    for(i = 0; i <= 35; i = i+1)\n\tz[i] = 0;\n    z[18:3] = B2; repeat(13)\n\t begin\n\tif(z[19:16] > 4)\t\n\t\tz[19:16] = z[19:16] + 3;\n\tif(z[23:20] > 4) \t\n\t\tz[23:20] = z[23:20] + 3;\n\tif(z[27:24] > 4) \t\n\t\tz[27:24] = z[27:24] + 3;\n\tif(z[31:28] > 4) \t\n\t\tz[31:28] = z[31:28] + 3;\n\tif(z[35:32] > 4) \t\n\t\tz[35:32] = z[35:32] + 3;\n\n\tz[35:1] = z[34:0];\n\t\n\tend      \n    bcdout2 = z[35:16];end         \n  \nendmodule",
        "module_name": "BIN_DEC2",
        "module_hash": "91514f0a8be81ae9aae961e205d6c4c6",
        "dataset_index": 23216
      },
      "sky130_fd_sc_lp__nor3_62f7bd9b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__nor3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, C, A, B        );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__nor3",
        "module_hash": "62f7bd9b474e52b8138538fe0fe6854b",
        "dataset_index": 20224
      },
      "adder_bf51e574": {
        "rtl_code": "module adder(\n    input [31:0] A,\n    input [31:0] B,\n    output reg [31:0] sum\n);\n\n   parameter INITVAL = 0;\n   integer globali;\n\n   initial globali = INITVAL;\n\n   always @(*) begin\n      sum = A + B;\n   end\n   \n   function [31:0] getName;  \n      input fake;  \n      getName = \"gmod\"; \n   endfunction\n   \n   function [31:0] getGlob;  \n      input fake;  \n      getGlob = globali;  \n   endfunction\n   \nendmodule",
        "module_name": "adder",
        "module_hash": "bf51e57491e55530bd460c1b1fd3e4c2",
        "dataset_index": 2242
      },
      "planeB_95cd4d4c": {
        "rtl_code": "\nmodule planeB(\n\tinput clk,\n\tinput rst,\n\tinput [10:0] x,\n\tinput [10:0] y,\n\tinput [10:0] poX,\n\tinput [10:0] poY,\n\toutput reg wing,\n\toutput reg body\n    );\n\t\nparameter pL = 40;\nparameter pW = 10;\nparameter wL = 15;\nparameter wW = 15;\nparameter wP = 10;\n\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) body <= 0;\n\telse begin\n\t\tif(x < poX+pL && x > poX && y < poY+wL+pW && y >poY+wL) body <= 1;\n\t\telse body <= 0;\n\tend\nend\n\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) wing <= 0;\n\telse begin\n\t\tif(x < poX+wP+wW && x > poX+wP && y < poY+wL && y > poY && x-poX+y-poY >wW+wP) wing <= 1;\n\t\telse if(x < poX+wP+wW && x > poX+wP && y > poY+wL+pW && y < poY+wL+wL+pW && x-poX-y+poY >wP-wL-pW) wing <= 1;\n\t\telse wing <= 0;\n\tend\nend\n\n\n\nendmodule\n",
        "module_name": "planeB",
        "module_hash": "95cd4d4c87582bc705c1de2c799f88da",
        "dataset_index": 14603
      },
      "up_down_counter_2da92c1d": {
        "rtl_code": "module up_down_counter (\n  input clk,\n  input reset,\n  input up_down,\n  output reg [2:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 3'b0;\n    end else if (up_down) begin\n      if (count == 3'b111) begin\n        count <= 3'b0;\n      end else begin\n        count <= count + 1;\n      end\n    end else begin\n      if (count == 3'b000) begin\n        count <= 3'b111;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "up_down_counter",
        "module_hash": "2da92c1d3844318c628d90a2de0ee6ec",
        "dataset_index": 4226
      },
      "INBUF_LVDS_MCCC_ff72910c": {
        "rtl_code": "module INBUF_LVDS_MCCC( \n    PADP, \n    PADN, \n    Y );\n\n\n\n\n    input  PADP;\n    input  PADN;\n    output Y;\n\nparameter ACT_PIN    = \"\";\n\n    assign Y = PADP ^ PADN;\n\nendmodule",
        "module_name": "INBUF_LVDS_MCCC",
        "module_hash": "ff72910cae1d3b240ff95f6793f94c2d",
        "dataset_index": 6308
      },
      "binary_counter_e77f9c90": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input reset,\n    output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "e77f9c90c392e1418265054c85354fd8",
        "dataset_index": 12764
      },
      "priority_encoder_4f6f2bf2": {
        "rtl_code": "\nmodule priority_encoder (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nwire [3:0] in_inv;\nassign in_inv = ~in;\n\nwire [1:0] sel;\nassign sel = (in_inv[3:2] == 2'b00) ? 2'b00 :\n             (in_inv[3:2] == 2'b01) ? 2'b01 :\n             (in_inv[3:2] == 2'b10) ? 2'b10 :\n             (in_inv[3:2] == 2'b11) ? 2'b11 : 2'b00;\n\nalways @(*) begin\n    case (sel)\n        2'b00: pos = 2'b00;\n        2'b01: pos = 2'b01;\n        2'b10: pos = 2'b10;\n        2'b11: pos = 2'b11;\n    endcase\nend\n\nendmodule\n",
        "module_name": "priority_encoder",
        "module_hash": "4f6f2bf2138f72d21290badbd6c4c019",
        "dataset_index": 17199
      },
      "bulletPosition_bb7440cb": {
        "rtl_code": "\nmodule bulletPosition(\n\tinput clk,\n\tinput frameClk,\n\tinput wire [9:0] drawingPositionX,\n\tinput wire [8:0] drawingPositionY,\t\n\tinput wire [9:0] characterPositionX,\n\tinput wire [8:0] characterPositionY,\n\tinput wire [1:0] characterDirection,\n\tinput _isBulletFire,\n\tinput isHitEnemy,\n\tinput wire [4:0] bulletID,\n\tinput wire [4:0] shootingBulletID,\n\tinput reset,\n\toutput reg isBulletShooting,\n\toutput reg isBulletExistInScreen,\n\toutput reg [9:0] bulletPositionX,\n\toutput reg [8:0] bulletPositionY\n);\n\t\n\treg [1:0] bulletDirection;\n\treg [9:0] diffPositionX;\n\treg [8:0] diffPositionY; \n\treg recentBulletFire;\n\tinitial begin\n\t\tbulletPositionX   =  'd0;\n\t\tbulletPositionY   =  'd0;\n\t\tbulletDirection   = 2'b00;\n\t\tisBulletShooting  = 1'b0;\n\t\tdiffPositionX     =  'd0;\n\t\tdiffPositionY     =  'd0;\n\t\trecentBulletFire  = 1'b0;\n\tend\n\n\talways @(posedge frameClk) begin\n\t\tif (reset == 1'b1) begin\n\t\t\tbulletPositionX   <=  'd0;\n\t\t\tbulletPositionY   <=  'd0;\n\t\t\tisBulletShooting  <= 1'b0;\n\t\t\trecentBulletFire  <= 1'b0;\n\t\tend else begin\n\t\t\tif (recentBulletFire == 0 && _isBulletFire == 0) begin if (bulletID == shootingBulletID) begin\n\t\t\t\t\tbulletPositionX  <= characterPositionX;\n\t\t\t\t\tbulletPositionY  <= characterPositionY;\n\t\t\t\t\tbulletDirection  <= characterDirection;\n\t\t\t\t\trecentBulletFire <= 1'b1;\n\t\t\t\t\tisBulletShooting <= 1'b1;\t\t\t\t\n\t\t\t\tend\n\t\t\tend else if(\n\t\t\t\tisBulletShooting == 1'b1 &&\n\t\t\t\tisHitEnemy       == 1'b0 && \n\t\t\t\tbulletPositionX > 0 && bulletPositionX < 600 && bulletPositionY > 0 && bulletPositionY < 440\n\t\t\t) begin\n\t\t\t\tcase(bulletDirection)\n\t\t\t\t\t2'b00: begin bulletPositionY <= bulletPositionY - 1;\n\t\t\t\t\tend\n\t\t\t\t\t2'b01: begin bulletPositionY <= bulletPositionY + 1;\n\t\t\t\t\tend\n\t\t\t\t\t2'b10: begin bulletPositionX <= bulletPositionX - 1;\n\t\t\t\t\tend\n\t\t\t\t\t2'b11: begin bulletPositionX <= bulletPositionX + 1;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend else begin\n\t\t\t\tbulletPositionX   <=  'd0;\n\t\t\t\tbulletPositionY   <=  'd0;\n\t\t\t\tisBulletShooting  <= 1'b0;\n\t\t\t\trecentBulletFire  <= 1'b0;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tdiffPositionX <= bulletPositionX + 3 + 1 - drawingPositionX;\n\t\tdiffPositionY <= bulletPositionY + 3 + 1 - drawingPositionY;\n\t\tif (reset == 1'b1) begin\n\t\t \tisBulletExistInScreen <= 1'b0;\n\t\tend else if (diffPositionX > 0 && diffPositionX < 7 && diffPositionY > 0 && diffPositionY < 7) begin\n\t\t\tisBulletExistInScreen <= 1'b1;\n\t\tend else begin\n\t\t\tisBulletExistInScreen <= 1'b0;\n\t\tend\n\tend\nendmodule\n",
        "module_name": "bulletPosition",
        "module_hash": "bb7440cb702544304757a57610c7babd",
        "dataset_index": 20923
      },
      "I2C_WRITE_WDATA_831fa443": {
        "rtl_code": "module I2C_WRITE_WDATA  (\n   input  \t\t\t\tRESET_N ,\n\tinput      \t\t  \tPT_CK,\n\tinput      \t\t  \tGO,\n\tinput      [15:0] REG_DATA,\n\tinput      [7:0] \tSLAVE_ADDRESS,\t\n\tinput            \tSDAI,\n\toutput reg       \tSDAO,\n\toutput reg       \tSCLO,\n\toutput reg       \tEND_OK,\n\t\n\toutput reg [7:0] \tST ,\n\toutput reg [7:0] \tCNT,\n\toutput reg [7:0] \tBYTE,\n\toutput reg       \tACK_OK,\n   input      [7:0]  BYTE_NUM  );\n\nreg   [8:0]A ;\nreg   [7:0]DELY ;\n\nalways @( negedge RESET_N or posedge  PT_CK )begin\nif (!RESET_N  ) ST <=0;\nelse \n\t  case (ST)\n\t    0: begin  SDAO   <=1; \n\t         SCLO   <=1;\n\t         ACK_OK <=0;\n\t         CNT    <=0;\n\t         END_OK <=1;\n\t         BYTE   <=0;\t\n\t         if (GO) ST  <=30 ; end\t  \n\t    1: begin  ST <=2 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n\t\t\t\tA <= {SLAVE_ADDRESS ,1'b1 };end\n\t    2: begin  ST <=3 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n\t\t    end\n\t\t\t \n\t    3: begin  \n\t\t      ST <=4 ; \n\t\t\t   { SDAO, A } <= { A ,1'b0 }; \n\t\t    end\n\t    4: begin  \n\t\t      ST <=5 ; \n\t\t\t   SCLO <= 1'b1 ; \n\t\t\t\tCNT <= CNT +1 ;\n\t\t    end\n\t\t\t \n\t    5: begin  \n\t\t\t   SCLO <= 1'b0 ; \n\t\t\t   if (CNT==9) begin\n\t\t\t\t     if ( BYTE == BYTE_NUM )  ST <= 6 ; \n\t\t\t\t\t  else  begin \n\t\t\t\t\t           CNT <=0 ; \n\t\t\t\t\t           ST <= 2 ;\n\t\t\t\t\t                if ( BYTE ==0 ) begin BYTE <=1  ; A <= {REG_DATA[15:8] ,1'b1 }; end \n\t\t\t\t\t           else if ( BYTE ==1 ) begin BYTE <=2  ; A <= {REG_DATA[7:0] ,1'b1 }; end \n\t\t\t\t\t\t\t  end\n\t\t\t\t\t  if (SDAI ) ACK_OK <=1 ; \n\t\t\t\t end\n\t\t\t\t else ST <= 2;\n\t\t    end\n\n\t    6: begin          ST <=7 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b00; \n         end\n\n\t    7: begin          ST <=8 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b01; \n         end\n\t    8: begin          ST <=9 ; \n\t\t\t   { SDAO,  SCLO } <= 2'b11; \n\t\t\t\t\t\t\n         end \n\t\t9:\tbegin\n\t\t      ST     <= 30; \n\t\t\t\tSDAO   <=1; \n\t         SCLO   <=1;\n\t         CNT    <=0;\n\t         END_OK <=1;\n\t         BYTE   <=0;\n\t\t     end\n\t\t30: begin\n            if (!GO) ST  <=31;\n          end\t\t\t\n\t\t   31: begin  END_OK<=0;\n\t\t\t\tACK_OK<=0;\n\t\t\t\tST    <=1;\t\n\t\t\tend\t\n\t  endcase \n end\n \nendmodule\n",
        "module_name": "I2C_WRITE_WDATA",
        "module_hash": "831fa443a96ad1f728099a5d1c2a8513",
        "dataset_index": 16771
      },
      "temp_calculation_9d31f407": {
        "rtl_code": "module temp_calculation(\n  input [2:0] state,\n  input [11:0] value,\n  input [4:0] index,\n  output reg [31:0] temp\n);\n\nalways @(*) begin\n  case(state)\n    3'd1, 3'd2: temp = {8'h8, 24'h1};\n    default: temp = {12'h3F, value, 8'h0};\n  endcase\nend\n\nendmodule",
        "module_name": "temp_calculation",
        "module_hash": "9d31f407ab0a2e91a6f6bb86cd82c282",
        "dataset_index": 15516
      },
      "UART_Tx #_39e28449": {
        "rtl_code": "module UART_Tx #(\n parameter N    = 5,\n parameter Full = 5'd29 )(\n input Reset,\n input Clk,\n\n input [7:0]Data,\n input      Send,\n output reg Busy,\n\n output reg Tx\t);\nreg        tSend;\nreg [  7:0]Temp;\nreg [N-1:0]Count;\nreg [  2:0]BitCount;\nreg   [1:0]State;\nlocalparam Idle    = 2'b00;\nlocalparam Sending = 2'b01;\nlocalparam StopBit = 2'b11;\nlocalparam Done    = 2'b10;\nreg tReset;\n\nalways @(posedge Clk) begin\n tReset <= Reset;\n\n if(tReset) begin\n  Busy <= 1'b0;\n  Tx   <= 1'b1;\n\n  tSend    <= 0;\n  Count    <= 0;\n  BitCount <= 0;\n  State    <= Idle;\nend else begin\n  tSend <= Send;\n\n  if(~|Count) begin\n   case(State)\n    Idle: begin\n     if(tSend) begin\n      Count      <= Full;\n      BitCount   <= 3'd7;\n      {Temp, Tx} <= {Data, 1'b0};\n      Busy       <= 1'b1;\n      State      <= Sending;\n     end\n    end\nSending: begin\n     Count           <= Full;\n     {Temp[6:0], Tx} <= Temp;\n      \n     if(~|BitCount) State <= StopBit;\n     BitCount <= BitCount - 1'b1;\n    end\nStopBit: begin\n     Tx    <= 1'b1;\n     Count <= Full;\n     State <= Done;\n    end\nDone: begin\n     if(~tSend) begin\n      Busy  <= 1'b0;\n      State <= Idle;\n     end\n    end\ndefault:;\n   endcase\n  end else begin\n   Count <= Count - 1'b1;\n  end\n end\nend\nendmodule\n",
        "module_name": "UART_Tx #",
        "module_hash": "39e284492dbe8eba84f297dca77931be",
        "dataset_index": 11795
      },
      "sky130_fd_sc_lp__nor3b_5273c55c": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__nor3b (\n    Y  ,\n    A  ,\n    B  ,\n    C_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out  ;\n    wire and0_out_Y;\n\n    nor nor0 (nor0_out  , A, B           );\n    and and0 (and0_out_Y, C_N, nor0_out  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__nor3b",
        "module_hash": "5273c55cd89b40f7b38806eeb2bd7271",
        "dataset_index": 11487
      },
      "shift_register_counter_c181dbe2": {
        "rtl_code": "module shift_register_counter (\n  input clk,\n  input reset,\n  input d,\n  input select,\n  output reg q\n);\n\n  reg [2:0] shift_reg;\n  reg [1:0] counter;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shift_reg <= 3'b000;\n      counter <= 2'b00;\n    end else begin\n      if (select) begin\n        // Shift register is active\n        shift_reg <= {shift_reg[1:0], d};\n        q <= shift_reg[2];\n      end else begin\n        // Counter is active\n        counter <= counter + 1;\n        q <= counter;\n      end\n    end\n  end\n\nendmodule\n\nmodule top_module (\n  input clk,\n  input reset,\n  input d,\n  input select,\n  output q\n);\n\n  shift_register_counter src (\n    .clk(clk),\n    .reset(reset),\n    .d(d),\n    .select(select),\n    .q(q)\n  );\n\nendmodule",
        "module_name": "shift_register_counter",
        "module_hash": "c181dbe28b7d531d36510cb233ad02d9",
        "dataset_index": 13849
      },
      "barrel_shifter_4bit_babef8b8": {
        "rtl_code": "module barrel_shifter_4bit (\n    input [3:0] DATA_IN,\n    input [1:0] SHIFT,\n    output reg [3:0] DATA_OUT\n);\n\n    always @(*) begin\n        case(SHIFT)\n            2'b00: DATA_OUT = DATA_IN;\n            2'b01: DATA_OUT = {DATA_IN[3], DATA_IN[2:0]};\n            2'b10: DATA_OUT = {DATA_IN[2:0], DATA_IN[3]};\n            2'b11: DATA_OUT = {DATA_IN[1:0], DATA_IN[3:2]};\n        endcase\n    end\n\nendmodule",
        "module_name": "barrel_shifter_4bit",
        "module_hash": "babef8b84e4cda8093be624fc11e64d8",
        "dataset_index": 2552
      },
      "sky130_fd_sc_lp__fah_b619252a": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__fah (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CI\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CI  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xor0_out_SUM;\n    wire a_b         ;\n    wire a_ci        ;\n    wire b_ci        ;\n    wire or0_out_COUT;\n\n    xor xor0 (xor0_out_SUM, A, B, CI       );\n    buf buf0 (SUM         , xor0_out_SUM   );\n    and and0 (a_b         , A, B           );\n    and and1 (a_ci        , A, CI          );\n    and and2 (b_ci        , B, CI          );\n    or  or0  (or0_out_COUT, a_b, a_ci, b_ci);\n    buf buf1 (COUT        , or0_out_COUT   );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__fah",
        "module_hash": "b619252a45bd9ee13d667a4466e536e5",
        "dataset_index": 7782
      },
      "rw_manager_ram_319665cc": {
        "rtl_code": "\n\nmodule rw_manager_ram\n\n(\n\n data,\n rdaddress, \n wraddress,\n wren, clock,\n q\n\n);\n\nparameter DATA_WIDTH=36;\nparameter ADDR_WIDTH=8;\n\ninput [(DATA_WIDTH-1):0] data;\ninput [(ADDR_WIDTH-1):0] rdaddress, wraddress;\ninput wren, clock;\noutput reg [(DATA_WIDTH-1):0] q;\n\n\treg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];\n\n\n\talways @ (posedge clock)\n\n\tbegin\n\n\t\tif (wren)\n\n\t\tram[wraddress] <= data[DATA_WIDTH-1:0];\n\n\t\tq <= ram[rdaddress];\n\n\tend\n\n\n\nendmodule\n\n\n",
        "module_name": "rw_manager_ram",
        "module_hash": "319665cc69f16895f170196aac1b648d",
        "dataset_index": 25267
      },
      "des_smline_3d_15f3c92c": {
        "rtl_code": "\n\nmodule des_smline_3d\n\t(\n\tinput\t\tde_clk,\n\tinput\t\tde_rstn,\n\tinput\t\tload_actv_3d,\n\tinput \t\tline_actv_3d,\n\tinput \t\tnlst_2,\n\tinput [15:0]\tcpx0,\n\tinput [15:0]\tcpy0,\n\tinput [15:0]\tcpx1,\n\tinput [15:0]\tcpy1,\n\tinput \t\tpipe_busy,\n\n\toutput reg\t\t\tl_pixreq,\n\toutput reg\t\t\tl_last_pixel,\n\toutput reg\t\t\tl_pc_msk_last,\n\toutput reg\t\t\tl_incpat,\toutput reg signed\t[15:0]\tcpx,\t\toutput reg signed\t[15:0]\tcpy,\t\toutput reg\t\t\tl_active\t);\n\n\nwire \t\teol;\nwire [2:0]\tdir;\nwire\t\teneg;\nwire\t\teeqz;\n\n\nreg\t\tdir_maj;\nreg [1:0]\tdir_min;\nreg\t\tl_delta_x;\nreg\t\tl_delta_y;\n\nreg signed [15:0] pline_x;\nreg signed [15:0] pline_y;\nreg signed [15:0] delta_x;\nreg signed [15:0] delta_y;\nreg signed [15:0] out_x;\nreg signed [15:0] out_y;\nreg signed [15:0] error_reg;\nreg signed [15:0] einc_x;\nreg signed [15:0] einc_y;\n\nreg\tld_error;\nreg\tl_einc_x;\nreg\tl_einc_y;\nreg\tinc_err;\nreg\trst_err;\nreg\tl_chgx;\nreg\tl_chgy;\nwire\tl_rht;\nwire\tl_dwn;\n\nreg\tl_ldmaj;\nreg\tl_ldmin;\n\nreg\t\tld_itr;\nreg\t\tdec_itr;\nreg [15:0]\titr_count;\nreg\t\tl_active_a;\nreg\t\tgo_line_1;\nreg\t\tgo_line;\n\nalways @(posedge de_clk, negedge de_rstn) begin\n\tif(!de_rstn) begin\n\t\tgo_line   <= 1'b0;\n\t\tgo_line_1 <= 1'b0;\n\t\tl_active <= 1'b0;\n\t\tpline_x <= 16'h0;\n\t\tpline_y <= 16'h0;\n\n\t\tcpx \t<= 16'h0;\n\t\tcpy \t<= 16'h0;\n\t\tdelta_x <= 16'h0;\n\t\tdelta_y <= 16'h0;\n\t\tdir_maj <= 1'b0;\n\t\tdir_min <= 2'b00;\n\t\terror_reg <= 16'h0;\n\t\teinc_x    <= 16'h0;\n\t\teinc_y    <= 16'h0;\n\n\t\titr_count <= 16'h0;\n\tend \n\telse begin\n\t\tgo_line   <= (line_actv_3d & go_line_1);\n\t\tgo_line_1 <= load_actv_3d;\n\n\t\tl_active <= l_active_a;\n\n\t\tpline_x <= out_x;\n\t\tpline_y <= out_y;\n\n\t\tif(l_delta_x) delta_x <= out_x;\n\t\tif(l_delta_y) delta_y <= out_y;\n\n      \t\tif(go_line) cpx <= cpx0;\n\t\telse if(l_rht & l_chgx) cpx <= cpx + 16'h1;\n\t\telse if(l_chgx)  cpx <= cpx - 16'h1;\n\n      \t\tif(go_line) cpy <= cpy0;\n\t\telse if(l_dwn & l_chgy) cpy <= cpy + 16'h1;\n\t\telse if(l_chgy)  cpy <= cpy - 16'h1;\n\n\t\tif(l_ldmin)    dir_min <= {out_y[15], out_x[15]};\n\t\tif(l_ldmaj)    dir_maj <= out_x[15];\n\t\tif(l_einc_x)   einc_x <= out_x;\n\t\tif(l_einc_y)   einc_y <= out_y;\n\n\t\tif(ld_error)   error_reg <= out_x;\n\t\telse if(inc_err)   error_reg <= error_reg + einc_y;\n\t\telse if(rst_err)   error_reg <= error_reg - einc_x;\n\n\t\tif(ld_itr)   \t itr_count <= delta_x;\n\t\telse if(dec_itr) itr_count <= itr_count - 16'h1;\n\n\tend\nend\n\nassign eneg = error_reg[15];\nassign eeqz = ~|error_reg;\n\nassign eol = ~|itr_count;\n\nassign dir = {dir_maj, dir_min};\n\n\n\n\n\n\nparameter\n        LWAIT\t\t= 4'h0,\n\tL1\t\t= 4'h1,\n\tL2\t\t= 4'h2,\n\tL3\t\t= 4'h3,\n\tL4\t\t= 4'h4,\n\tL5\t\t= 4'h5,\n\tL6\t\t= 4'h6,\n        L7\t\t= 4'h7,\n\tL8\t\t= 4'h8,\n\tL9\t\t= 4'h9,\n\tLIDLE1\t\t= 4'hA;\nreg [3:0]\tl_cs, l_ns;\n\nparameter\n\t\t                \n\t\t                \n\t\t                \n\t\t  o0=3'b000,\t\n\t\t  o1=3'b001,\t\n\t\t  o2=3'b010,\t\n\t\t  o3=3'b011,\t\n\t\t  o4=3'b100,\t\n\t\t  o5=3'b101,\t\n\t\t  o6=3'b110,\t\n\t\t  o7=3'b111;\t\n\nalways @(posedge de_clk, negedge de_rstn)\n\tif(!de_rstn) l_cs\t<= LWAIT;\n\telse \t     l_cs\t<= l_ns;\n\n  assign l_rht = ((dir==o0) || (dir==o2) || (dir==o4) || (dir==o6));\n  assign l_dwn = ((dir==o0) || (dir==o1) || (dir==o4) || (dir==o5));\n  \n  always @* begin\n\t\tl_active_a \t= 1'b1;\n    \t\tl_ldmaj      \t= 1'b0;\n    \t\tl_ldmin      \t= 1'b0;\n    \t\tl_delta_x \t= 1'b0;\n    \t\tl_delta_y \t= 1'b0;\n    \t\tl_incpat     \t= 1'b0;\n    \t\tinc_err      \t= 1'b0;\n    \t\trst_err      \t= 1'b0;\n    \t\tl_einc_x \t= 1'b0;\n    \t\tl_einc_y \t= 1'b0;\n    \t\tld_error     \t= 1'b0;\n    \t\tout_x \t \t= 16'h0;\n    \t\tout_y \t \t= 16'h0;\n    \t\tld_itr     \t= 1'b0;\n    \t\tdec_itr     \t= 1'b0;\n\n    \t\tl_pc_msk_last \t= 1'b0;\n    \t\tl_last_pixel  \t= 1'b0;\n    \t\tl_chgx        \t= 1'b0;\n    \t\tl_chgy        \t= 1'b0;\n    \t\tl_pixreq      \t= 1'b0;\n    \n    case(l_cs)\n      LWAIT: if(go_line) begin\t\n\t      \t\tout_x   = cpx1 - cpx0;\n\t\t\tout_y   = cpy1 - cpy0;\n\t\t\tl_ldmin = 1'b1;\n\t\t\tl_ns\t= L1;\n\t\t\tend\n\telse begin\n\t\tl_ns= LWAIT;\n\t\tl_active_a = 1'b0;\n\tend\n\n      L1:\tbegin\tout_x = (pline_x[15]) ? ~pline_x + 16'h1 : pline_x;\n\t\t\tout_y = (pline_y[15]) ? ~pline_y + 16'h1 : pline_y;\n\t\t\tl_delta_x = 1'b1;\n\t\t\tl_delta_y = 1'b1;\n\t\t\tl_ns = L2;\n\t\t\tend\n\n      L2:\tbegin\n\t\t\tl_ns     = L3;\n\t\t\tl_ldmaj  = 1'b1;\n\t\t\tout_x = pline_x - pline_y; \tend\n\n      L3:\tl_ns = L4;\n      L4:\tbegin\n\t\t\tl_ns = L5;\n\t\t\tif(dir[2]) begin\n\t\t\t\tout_x = delta_y;\n\t\t\t\tout_y = delta_x;\n\t\t\t\tl_delta_x = 1'b1;\n\t\t\t\tl_delta_y = 1'b1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tout_x = delta_x;\n\t\t\t\tout_y = delta_y;\n\t\t\tend\n      end\n      \n      L5:\tbegin\n\t\t\tl_ns =L6;\n\t\t\tout_x = (pline_x << 1) - (pline_y << 1);\n\t\t\tout_y = (pline_y << 1);\n\t\t\tl_einc_x = 1'b1;\n\t\t\tl_einc_y = 1'b1;\n    \t\t\tld_itr   = 1'b1;\n      \t\tend\n      \n      L6:\tbegin\n\t\t\tl_ns=L7;\n\t\t\tld_error = 1'b1;\n\t\t\tout_x = (~delta_x + 16'h1) + (delta_y << 1);\n\t\t\tend\n      \n      L7:\tbegin\n\tif(!pipe_busy) begin\n\t\t\tout_x = pline_x;\n\t  \t\tout_y = pline_y;\n\t  \t\tl_ns = L9;\n\t\tend\n\telse begin\n\t\tl_ns = L8;\n\t\tend\n      end\n\n      L8:\tbegin\n\tif(eol && nlst_2) begin\n\t  \t\tl_ns = LIDLE1;\n\t  \t\tl_pixreq = 1'b1;\n\t  \t\tl_last_pixel  =  1'b1;\n\t  \t\tl_pc_msk_last = 1'b1;\n\t  \t\tend\n\telse if(!pipe_busy && eol && !nlst_2) begin\n\t  \t\tl_ns = LIDLE1;\n\t  \t\tl_incpat = 1'b1;\n\t  \t\tend\n\telse if(!pipe_busy && !eol) begin\n    \t\t\tdec_itr  = 1'b1;\n\t  \t\tl_incpat = 1'b1;\n\t  \t\tl_ns = L8;\n\t    \t\tif(!pipe_busy && (dir==o1 || dir==o3 || dir==o5 || dir==o7) && !eneg && !eeqz)\trst_err = 1;\n\t    \t\telse if(!pipe_busy && (dir==o0 || dir==o2 || dir==o4 || dir==o6) && !eneg)\trst_err = 1;\n\t\t\telse if(!pipe_busy) begin\n\t\t\t\tinc_err = 1;\tend\n\tend\n\telse \tbegin\n\n\t  \t\tl_ns = L8;\n\tend\n\n\tif(!pipe_busy) begin\t\n        \tif(eol && !nlst_2) begin\n\t  \t\tl_pixreq = 1'b1;\n\t  \t\tl_last_pixel  =  1'b1;\n        \tend \n        \telse if(!eol)l_pixreq = 1'b1;\n\t\t\n        \tif(!eol && (dir==o1 || dir==o3 || dir==o5 || dir==o7) && !eneg && !eeqz)l_chgx = 1'b1;\n        \telse if(!eol && (dir==o0 || dir==o2 || dir==o4 || dir==o6) && !eneg)       l_chgx = 1'b1;\n        \telse if(!eol && (dir==o0 || dir==o1 || dir==o2 || dir==o3))\n          \t\tl_chgx = 1'b1;\n\t\t\n        \tif(!eol && (dir==o1 || dir==o3 || dir==o5 || dir==o7) && !eneg && !eeqz)l_chgy = 1'b1;\n        \telse if(!eol && (dir==o0 || dir==o2 || dir==o4 || dir==o6) && !eneg)         l_chgy = 1'b1;\n        \telse if(!eol && (dir==o4 || dir==o5 || dir==o6 || dir==o7))\n          \t\tl_chgy = 1'b1;\n\tend\n      end\n\n      L9:\tbegin\n\tl_ns=L8;\n\tout_x = pline_x;\n\tout_y = pline_y;\n      end\n      LIDLE1:\tbegin \n\tl_ns = LWAIT;\n      end\n    endcase\n    \n  end\n\nendmodule\n",
        "module_name": "des_smline_3d",
        "module_hash": "15f3c92ce5ba69e519ce875071dc7538",
        "dataset_index": 6236
      },
      "four_or_gate_d94fe741": {
        "rtl_code": "module four_or_gate (\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    output out\n);\n\n    assign out = in1 | in2 | in3 | in4;\n\nendmodule",
        "module_name": "four_or_gate",
        "module_hash": "d94fe741fc6dbbd0521b7d54e08d5cea",
        "dataset_index": 3999
      },
      "bram_controller_a52b2f32": {
        "rtl_code": "\nmodule bram_controller(clk, reset, btn, wea, addra);\n\n  input wire clk, reset, btn;\n  output reg wea;\n  output reg [3:0] addra;\n\n  localparam [1:0]\n  idle = 2'b00,\n  leer = 2'b01,\n  fin  = 2'b10;\n\n  reg [1:0] state_reg;\n  reg [3:0] counter;\n  \n  always@(posedge clk, posedge reset)\n    if(reset)\n      begin\n        addra<=0;\n        counter<=0;\t\n        state_reg<=idle;\n        wea<=0;\n      end\n  else begin\n\n    case(state_reg)\n\n      idle:\n        if(btn==1'b1)begin\n          state_reg<=leer;\n        end\n\n      leer:\n        begin\n          wea<=0;\n          counter<=counter+1'b1;\n          state_reg<=fin;\n        end\n\n      fin:begin\n\n        addra<=addra+1'b1;\n        if(counter==4'b1111)begin\n          counter<=0;\n        end\n        state_reg<=idle;\n      end\t\n\n    endcase\n  end\n  \nendmodule\n",
        "module_name": "bram_controller",
        "module_hash": "a52b2f32feae9ba48e1365847dabcab5",
        "dataset_index": 13305
      },
      "ExShad64_6bb3599f": {
        "rtl_code": "\n\nmodule ExShad64(\n\t\n\tclock, reset,\n\tvalRs, valRt,\n\tvalRn, shOp\n\t);\n\ninput\tclock;\ninput\treset;\n\n\n\ninput[63:0]\t\tvalRs;\ninput[ 7:0]\t\tvalRt;\ninput[ 2:0]\t\tshOp;\noutput[63:0]\tvalRn;\n\nreg[63:0]\t\ttValRn;\nassign\t\t\tvalRn = tValRn;\n\n\nreg[63:0]\t\ttValRol;\nreg[63:0]\t\ttValRor;\nreg[ 7:0]\t\ttValSh;\n\nalways @*\nbegin\n\n\ttValRol=0;\n\ttValRor=0;\n\ttValRn = 0;\n\ttValSh = 0;\n\n\tcase(shOp)\n\t3'h0: begin\n\tend\n\n\t3'h1: begin\t\ttValRol=0;\n\t\ttValRor=0;\n\t\ttValSh = valRt;\n\tend\n\n\t3'h2: begin\t\ttValRol=0;\n\t\ttValRor=valRs[63] ? 64'hFFFFFFFF : 64'h00000000;\n\t\ttValSh = valRt;\n\tend\n\n\t3'h3: begin\t\ttValRol=0;\n\t\ttValRor=0;\n\t\ttValSh = -valRt;\n\tend\n\n\t3'h4: begin\t\ttValRol=0;\n\t\ttValRor=valRs[63] ? 64'hFFFFFFFF : 64'h00000000;\n\t\ttValSh = -valRt;\n\tend\n\n\tdefault:\n\tbegin\n\tend\n\n\tendcase\n\n\tcasez(tValSh)\n\t8'b0z000000: tValRn = valRs;\n\t8'b0z000001: tValRn = { valRs[62:0], tValRol[63   ] };\n\t8'b0z000010: tValRn = { valRs[61:0], tValRol[63:62] };\n\t8'b0z000011: tValRn = { valRs[60:0], tValRol[63:61] };\n\t8'b0z000100: tValRn = { valRs[59:0], tValRol[63:60] };\n\t8'b0z000101: tValRn = { valRs[58:0], tValRol[63:59] };\n\t8'b0z000110: tValRn = { valRs[57:0], tValRol[63:58] };\n\t8'b0z000111: tValRn = { valRs[56:0], tValRol[63:57] };\n\t8'b0z001000: tValRn = { valRs[55:0], tValRol[63:56] };\n\t8'b0z001001: tValRn = { valRs[54:0], tValRol[63:55] };\n\t8'b0z001010: tValRn = { valRs[53:0], tValRol[63:54] };\n\t8'b0z001011: tValRn = { valRs[52:0], tValRol[63:53] };\n\t8'b0z001100: tValRn = { valRs[51:0], tValRol[63:52] };\n\t8'b0z001101: tValRn = { valRs[50:0], tValRol[63:51] };\n\t8'b0z001110: tValRn = { valRs[49:0], tValRol[63:50] };\n\t8'b0z001111: tValRn = { valRs[48:0], tValRol[63:49] };\n\t8'b0z010000: tValRn = { valRs[47:0], tValRol[63:48] };\n\t8'b0z010001: tValRn = { valRs[46:0], tValRol[63:47] };\n\t8'b0z010010: tValRn = { valRs[45:0], tValRol[63:46] };\n\t8'b0z010011: tValRn = { valRs[44:0], tValRol[63:45] };\n\t8'b0z010100: tValRn = { valRs[43:0], tValRol[63:44] };\n\t8'b0z010101: tValRn = { valRs[42:0], tValRol[63:43] };\n\t8'b0z010110: tValRn = { valRs[41:0], tValRol[63:42] };\n\t8'b0z010111: tValRn = { valRs[40:0], tValRol[63:41] };\n\t8'b0z011000: tValRn = { valRs[39:0], tValRol[63:40] };\n\t8'b0z011001: tValRn = { valRs[38:0], tValRol[63:39] };\n\t8'b0z011010: tValRn = { valRs[37:0], tValRol[63:38] };\n\t8'b0z011011: tValRn = { valRs[36:0], tValRol[63:37] };\n\t8'b0z011100: tValRn = { valRs[35:0], tValRol[63:36] };\n\t8'b0z011101: tValRn = { valRs[34:0], tValRol[63:35] };\n\t8'b0z011110: tValRn = { valRs[33:0], tValRol[63:34] };\n\t8'b0z011111: tValRn = { valRs[32:0], tValRol[63:33] };\n\t8'b0z100000: tValRn = { valRs[31:0], tValRol[63:32] };\n\t8'b0z100001: tValRn = { valRs[30:0], tValRol[63:31] };\n\t8'b0z100010: tValRn = { valRs[29:0], tValRol[63:30] };\n\t8'b0z100011: tValRn = { valRs[28:0], tValRol[63:29] };\n\t8'b0z100100: tValRn = { valRs[27:0], tValRol[63:28] };\n\t8'b0z100101: tValRn = { valRs[26:0], tValRol[63:27] };\n\t8'b0z100110: tValRn = { valRs[25:0], tValRol[63:26] };\n\t8'b0z100111: tValRn = { valRs[24:0], tValRol[63:25] };\n\t8'b0z101000: tValRn = { valRs[23:0], tValRol[63:24] };\n\t8'b0z101001: tValRn = { valRs[22:0], tValRol[63:23] };\n\t8'b0z101010: tValRn = { valRs[21:0], tValRol[63:22] };\n\t8'b0z101011: tValRn = { valRs[20:0], tValRol[63:21] };\n\t8'b0z101100: tValRn = { valRs[19:0], tValRol[63:20] };\n\t8'b0z101101: tValRn = { valRs[18:0], tValRol[63:19] };\n\t8'b0z101110: tValRn = { valRs[17:0], tValRol[63:18] };\n\t8'b0z101111: tValRn = { valRs[16:0], tValRol[63:17] };\n\t8'b0z110000: tValRn = { valRs[15:0], tValRol[63:16] };\n\t8'b0z110001: tValRn = { valRs[14:0], tValRol[63:15] };\n\t8'b0z110010: tValRn = { valRs[13:0], tValRol[63:14] };\n\t8'b0z110011: tValRn = { valRs[12:0], tValRol[63:13] };\n\t8'b0z110100: tValRn = { valRs[11:0], tValRol[63:12] };\n\t8'b0z110101: tValRn = { valRs[10:0], tValRol[63:11] };\n\t8'b0z110110: tValRn = { valRs[ 9:0], tValRol[63:10] };\n\t8'b0z110111: tValRn = { valRs[ 8:0], tValRol[63: 9] };\n\t8'b0z111000: tValRn = { valRs[ 7:0], tValRol[63: 8] };\n\t8'b0z111001: tValRn = { valRs[ 6:0], tValRol[63: 7] };\n\t8'b0z111010: tValRn = { valRs[ 5:0], tValRol[63: 6] };\n\t8'b0z111011: tValRn = { valRs[ 4:0], tValRol[63: 5] };\n\t8'b0z111100: tValRn = { valRs[ 3:0], tValRol[63: 4] };\n\t8'b0z111101: tValRn = { valRs[ 2:0], tValRol[63: 3] };\n\t8'b0z111110: tValRn = { valRs[ 1:0], tValRol[63: 2] };\n\t8'b0z111111: tValRn = { valRs[   0], tValRol[63: 1] };\n\n\t8'b1z111111: tValRn = { tValRor[ 0  ], valRs[63: 1] };\n\t8'b1z111110: tValRn = { tValRor[ 1:0], valRs[63: 2] };\n\t8'b1z111101: tValRn = { tValRor[ 2:0], valRs[63: 3] };\n\t8'b1z111100: tValRn = { tValRor[ 3:0], valRs[63: 4] };\n\t8'b1z111011: tValRn = { tValRor[ 4:0], valRs[63: 5] };\n\t8'b1z111010: tValRn = { tValRor[ 5:0], valRs[63: 6] };\n\t8'b1z111001: tValRn = { tValRor[ 6:0], valRs[63: 7] };\n\t8'b1z111000: tValRn = { tValRor[ 7:0], valRs[63: 8] };\n\t8'b1z110111: tValRn = { tValRor[ 8:0], valRs[63: 9] };\n\t8'b1z110110: tValRn = { tValRor[ 9:0], valRs[63:10] };\n\t8'b1z110101: tValRn = { tValRor[10:0], valRs[63:11] };\n\t8'b1z110100: tValRn = { tValRor[11:0], valRs[63:12] };\n\t8'b1z110011: tValRn = { tValRor[12:0], valRs[63:13] };\n\t8'b1z110010: tValRn = { tValRor[13:0], valRs[63:14] };\n\t8'b1z110001: tValRn = { tValRor[14:0], valRs[63:15] };\n\t8'b1z110000: tValRn = { tValRor[15:0], valRs[63:16] };\n\t8'b1z101111: tValRn = { tValRor[16:0], valRs[63:17] };\n\t8'b1z101110: tValRn = { tValRor[17:0], valRs[63:18] };\n\t8'b1z101101: tValRn = { tValRor[18:0], valRs[63:19] };\n\t8'b1z101100: tValRn = { tValRor[19:0], valRs[63:20] };\n\t8'b1z101011: tValRn = { tValRor[20:0], valRs[63:21] };\n\t8'b1z101010: tValRn = { tValRor[21:0], valRs[63:22] };\n\t8'b1z101001: tValRn = { tValRor[22:0], valRs[63:23] };\n\t8'b1z101000: tValRn = { tValRor[23:0], valRs[63:24] };\n\t8'b1z100111: tValRn = { tValRor[24:0], valRs[63:25] };\n\t8'b1z100110: tValRn = { tValRor[25:0], valRs[63:26] };\n\t8'b1z100101: tValRn = { tValRor[26:0], valRs[63:27] };\n\t8'b1z100100: tValRn = { tValRor[27:0], valRs[63:28] };\n\t8'b1z100011: tValRn = { tValRor[28:0], valRs[63:29] };\n\t8'b1z100010: tValRn = { tValRor[29:0], valRs[63:30] };\n\t8'b1z100001: tValRn = { tValRor[30:0], valRs[63:31] };\n\t8'b1z100000: tValRn = { tValRor[31:0], valRs[63:32] };\n\t8'b1z011111: tValRn = { tValRor[32:0], valRs[63:33] };\n\t8'b1z011110: tValRn = { tValRor[33:0], valRs[63:34] };\n\t8'b1z011101: tValRn = { tValRor[34:0], valRs[63:35] };\n\t8'b1z011100: tValRn = { tValRor[35:0], valRs[63:36] };\n\t8'b1z011011: tValRn = { tValRor[36:0], valRs[63:37] };\n\t8'b1z011010: tValRn = { tValRor[37:0], valRs[63:38] };\n\t8'b1z011001: tValRn = { tValRor[38:0], valRs[63:39] };\n\t8'b1z011000: tValRn = { tValRor[39:0], valRs[63:40] };\n\t8'b1z010111: tValRn = { tValRor[40:0], valRs[63:41] };\n\t8'b1z010110: tValRn = { tValRor[41:0], valRs[63:42] };\n\t8'b1z010101: tValRn = { tValRor[42:0], valRs[63:43] };\n\t8'b1z010100: tValRn = { tValRor[43:0], valRs[63:44] };\n\t8'b1z010011: tValRn = { tValRor[44:0], valRs[63:45] };\n\t8'b1z010010: tValRn = { tValRor[45:0], valRs[63:46] };\n\t8'b1z010001: tValRn = { tValRor[46:0], valRs[63:47] };\n\t8'b1z010000: tValRn = { tValRor[47:0], valRs[63:48] };\n\t8'b1z001111: tValRn = { tValRor[48:0], valRs[63:49] };\n\t8'b1z001110: tValRn = { tValRor[49:0], valRs[63:50] };\n\t8'b1z001101: tValRn = { tValRor[50:0], valRs[63:51] };\n\t8'b1z001100: tValRn = { tValRor[51:0], valRs[63:52] };\n\t8'b1z001011: tValRn = { tValRor[52:0], valRs[63:53] };\n\t8'b1z001010: tValRn = { tValRor[53:0], valRs[63:54] };\n\t8'b1z001001: tValRn = { tValRor[54:0], valRs[63:55] };\n\t8'b1z001000: tValRn = { tValRor[55:0], valRs[63:56] };\n\t8'b1z000111: tValRn = { tValRor[56:0], valRs[63:57] };\n\t8'b1z000110: tValRn = { tValRor[57:0], valRs[63:58] };\n\t8'b1z000101: tValRn = { tValRor[58:0], valRs[63:59] };\n\t8'b1z000100: tValRn = { tValRor[59:0], valRs[63:60] };\n\t8'b1z000011: tValRn = { tValRor[60:0], valRs[63:61] };\n\t8'b1z000010: tValRn = { tValRor[61:0], valRs[63:62] };\n\t8'b1z000001: tValRn = { tValRor[62:0], valRs[63   ] };\n\t8'b1z000000: tValRn = tValRor;\n\n\tendcase\n\nend\n\nendmodule\n",
        "module_name": "ExShad64",
        "module_hash": "6bb3599f90bbdf5582251417b0080e2a",
        "dataset_index": 19573
      },
      "Multiplexer_1bit_c0e12411": {
        "rtl_code": "module Multiplexer_1bit\n    (ctrl,\n     D0,\n     D1,\n     S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  output [0:0]S;\n\n  wire [0:0]S;\n\n  assign S = (ctrl == 1'b0) ? D0 : D1;\nendmodule",
        "module_name": "Multiplexer_1bit",
        "module_hash": "c0e124113f0b7e144d9e0bf9e87bbb89",
        "dataset_index": 14760
      },
      "ones_complement_324e5c12": {
        "rtl_code": "module ones_complement (\n    input [3:0] binary,\n    output reg [3:0] ones_comp\n);\n\n    always @ (binary) begin\n        ones_comp <= ~binary;\n    end\n\nendmodule",
        "module_name": "ones_complement",
        "module_hash": "324e5c12da3c51ac4e5a433a0d5683c4",
        "dataset_index": 13442
      },
      "shift_register_with_difference_555ab3aa": {
        "rtl_code": "module shift_register_with_difference (\n  input clk,\n  input data,\n  output reg [3:0] q,\n  output reg [3:0] difference\n);\n\n  reg [3:0] q_temp;\n\n  always @(posedge clk) begin\n    q_temp <= {q[2:0], data};\n    q <= q_temp;\n  end\n\n  always @(posedge clk) begin\n    difference <= q[1] - q[0];\n  end\n\nendmodule",
        "module_name": "shift_register_with_difference",
        "module_hash": "555ab3aae6758af87930860cfae0f83a",
        "dataset_index": 4358
      },
      "diff_d2e_c6065231": {
        "rtl_code": "\nmodule diff_d2e(\n    clk, clrn,  \n    wreg, m2reg, shift, aluimm, wmem, wzero, aluc, rd, qa, qb, eximme,\n    ewreg, em2reg, eshift, ealuimm, ewmem, ewzero, ealuc, erd, esa, eqa, eqb, eeximme\n);\n    input clk, clrn;\n    input wreg, m2reg, shift, aluimm, wmem, wzero;\n    input [3:0] aluc;\n    input [4:0] rd;\n    input [31:0] qa, qb, eximme;\n    \n    output ewreg, em2reg, eshift, ealuimm, ewmem, ewzero;\n    output [3:0] ealuc;\n    output [4:0] erd, esa;\n    output [31:0] eqa, eqb, eeximme;\n    \n    reg [31:0] ewreg_d, em2reg_d, eshift_d, ealuimm_d, ewmem_d, ewzero_d;\n    reg [3:0] ealuc_d;\n    reg [4:0] erd_d, esa_d;\n    reg [31:0] eqa_d, eqb_d, eeximme_d;\n    \n    always @(posedge clk or negedge clrn) begin\n        if (~clrn) begin\n            ewreg_d <= 0;\n            em2reg_d <= 0;\n            eshift_d <= 0;\n            ealuimm_d <= 0;\n            ewmem_d <= 0;\n            ewzero_d <= 0;\n            ealuc_d <= 0;\n            erd_d <= 0;\n            esa_d <= 0;\n            eqa_d <= 0;\n            eqb_d <= 0;\n            eeximme_d <= 0;\n        end else begin\n            ewreg_d <= wreg;\n            em2reg_d <= m2reg;\n            eshift_d <= shift;\n            ealuimm_d <= aluimm;\n            ewmem_d <= wmem;\n            ewzero_d <= wzero;\n            ealuc_d <= aluc;\n            erd_d <= rd;\n            esa_d <= 5'b0;\n            eqa_d <= qa;\n            eqb_d <= qb;\n            eeximme_d <= eximme;\n        end\n    end\n    \n    assign ewreg = ewreg_d;\n    assign em2reg = em2reg_d;\n    assign eshift = eshift_d;\n    assign ealuimm = ealuimm_d;\n    assign ewmem = ewmem_d;\n    assign ewzero = ewzero_d;\n    assign ealuc = ealuc_d;\n    assign erd = erd_d;\n    assign esa = esa_d;\n    assign eqa = eqa_d;\n    assign eqb = eqb_d;\n    assign eeximme = eeximme_d;\n    \nendmodule",
        "module_name": "diff_d2e",
        "module_hash": "c60652318df84d2d7c639f73a6df2948",
        "dataset_index": 5164
      },
      "my__00645347": {
        "rtl_code": "module my_module (\n    X,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n\n    assign X = ((A1 & ~A2) | (A2 & ~A1 & A3 & ~B1) | (~A1 & ~A2 & ~A3 & B1)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "006453470462859ca8d14a51f017685b",
        "dataset_index": 19201
      },
      "clock_gate__dc0d558d": {
        "rtl_code": "module clock_gate_module (\n  input CLK,\n  input EN,\n  input TE,\n  input RESET,\n  output reg ENCLK\n);\n\n  always @(posedge CLK or posedge RESET) begin\n    if (RESET) begin\n      ENCLK <= 1'b0;\n    end else if (TE) begin\n      ENCLK <= 1'b1;\n    end else if (EN) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "clock_gate_",
        "module_hash": "dc0d558d6161bddd14eba6f5a32dede5",
        "dataset_index": 10471
      },
      "binary_counter_7941bcf6": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        count <= 4'b0000;\n    end else if (en) begin\n        if (count == 4'b1111) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "7941bcf630f5359858a9e0a9a6f32584",
        "dataset_index": 9083
      },
      "ctrl_reg_readback #_b4f4dbb0": {
        "rtl_code": "\n\nmodule ctrl_reg_readback #(parameter CR_WIDTH=6, N_CTRL_REGS=64) (\t\n\tinput\t\t\t\t\tclk,\n\tinput\t\t\t\t\trst,\n\tinput\t\t\t\t\ttx_en,\n\tinput\t\t\t\t\ttx_data_loaded,\n\toutput reg\t\t\ttx_data_ready,\n\toutput reg\t\t\ttx_complete,\n\toutput reg [CR_WIDTH-1:0]  tx_cnt\n);\n\nalways @(posedge clk) begin\n\tif (rst) begin\n\t\ttx_cnt <= 0;\n\t\ttx_data_ready <= 0;\n\t\ttx_complete <= 0;\n\tend else begin\n\t\tif (!tx_complete && tx_en) begin if (tx_data_ready && tx_data_loaded) begin tx_data_ready <= 0;\n\t\t\t\tif (tx_cnt == N_CTRL_REGS-1) begin tx_complete <= 1; \n\t\t\t\t\ttx_cnt <= tx_cnt;\n\t\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\ttx_complete <= tx_complete;\n\t\t\t\t\ttx_cnt <= tx_cnt + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse begin\n\t\t\t\ttx_complete <= tx_complete;\n\t\t\t\ttx_cnt <= tx_cnt;\n\t\t\t\ttx_data_ready <= (!tx_data_ready && !tx_data_loaded) ? 1 : tx_data_ready; end\n\t\tend else if (tx_complete && !tx_en) begin tx_cnt <= 0;\n\t\t\ttx_data_ready <= 0;\n\t\t\ttx_complete <= 0;\n\t\tend else begin\n\t\t\ttx_data_ready <= tx_data_ready;\n\t\t\ttx_complete <= tx_complete;\n\t\t\ttx_cnt <= tx_cnt;\n\t\tend\n\tend end endmodule\n",
        "module_name": "ctrl_reg_readback #",
        "module_hash": "b4f4dbb039609f2465c8683d83623dbc",
        "dataset_index": 5693
      },
      "video_palframe_920e1d50": {
        "rtl_code": "\nmodule video_palframe(\n\n    input  wire        clk, // 28MHz clock\n\n\n    input  wire        hpix,\n    input  wire        vpix,\n\n    input  wire        hblank,\n    input  wire        vblank,\n\n    input  wire        hsync_start,\n    input  wire        vsync,\n\n    input  wire [ 3:0] pixels,\n    input  wire [ 3:0] border,\n\n    input  wire        border_sync,\n    input  wire        border_sync_ena,\n\n    // ulaplus related\n    input  wire [ 1:0] up_palsel,\n    input  wire [ 2:0] up_paper,\n    input  wire [ 2:0] up_ink,\n    input  wire        up_pixel,\n\n    input  wire        up_ena,\n    input  wire        up_palwr,\n    input  wire [ 5:0] up_paladdr,\n    input  wire [ 7:0] up_paldata,\n\n    input  wire        atm_palwr,\n    input  wire [ 5:0] atm_paldata,\n\n\n    output wire [ 5:0] palcolor, // just for palette readback\n\n    output wire [ 5:0] color\n);\n    reg [7:0] palette_read;    \n\n    wire [ 3:0] zxcolor;\n    wire [ 5:0] up_color;\n    wire [ 8:0] palette_color;\n\n    reg [3:0] synced_border;\n\n    reg vsync_r;\n    reg [1:0] ctr_14;\n    reg ctr_h;\n    reg ctr_v;\n\n\n    always @(posedge clk)\n    if( border_sync )\n        synced_border <= border;\n\n    assign zxcolor = (hpix&vpix) ? pixels : (border_sync_ena ? synced_border : border);\n\n    assign up_color = (hpix&vpix) ? {up_palsel,~up_pixel,up_pixel?up_ink:up_paper} : {3'd0,border[2:0]};\n\n    assign palette_color = up_ena ? {3'b100,up_color} : {5'd0,zxcolor};\n\n\n    // palette\n    reg [7:0] palette [0:511]; // let quartus instantiate it as RAM\n\n    always @(posedge clk)\n    begin\n        if( atm_palwr || up_palwr )\n        begin : palette_write\n            reg [8:0] pal_addr;\n            pal_addr = atm_palwr ? { 5'd0, zxcolor } : { 3'b100, up_paladdr };\n\n            palette[pal_addr] <= atm_palwr ? {atm_paldata[3:2],1'b0,atm_paldata[5:4],1'b0,atm_paldata[1:0]} : up_paldata;\n        end\n\n        palette_read <= palette[palette_color];\n    end\n\n\n    assign palcolor = {palette_read[4:3],palette_read[7:6], palette_read[1:0]};\n\n\n\n\n    // make 3bit palette\n    always @(posedge clk)\n        vsync_r <= vsync;\n    //\n    wire vsync_start = vsync && !vsync_r;\n    //\n    initial ctr_14 = 2'b00;\n    always @(posedge clk)\n        ctr_14 <= ctr_14+2'b01;\n    //\n    initial ctr_h = 1'b0;\n    always @(posedge clk) if( hsync_start )\n        ctr_h <= ~ctr_h;\n    //\n    initial ctr_v = 1'b0;\n    always @(posedge clk) if( vsync_start )\n        ctr_v <= ~ctr_v;\n\n\n    wire plus1 = ctr_14[1] ^ ctr_h ^ ctr_v;\n\n\n    reg [1:0] red;\n    reg [1:0] grn;\n    reg [1:0] blu;\n\n    always @(*)\n    begin\n        case(palette_read[7:5])\n            3'b000 : red = 2'b00;\n            3'b001 : red = 2'b01;\n            3'b010 : red = 2'b11;\n            3'b011 : red = 2'b10;\n            3'b100 : red = 2'b00;\n            3'b101 : red = 2'b10;\n            3'b110 : red = 2'b11;\n            3'b111 : red = 2'b01;\n        endcase\n    end\n\n\n    always @(*)\n    begin\n        case(palette_read[4:2])\n            3'b000 : grn = 2'b00;\n            3'b001 : grn = 2'b01;\n            3'b010 : grn = 2'b11;\n            3'b011 : grn = 2'b10;\n            3'b100 : grn = 2'b00;\n            3'b101 : grn = 2'b10;\n            3'b110 : grn = 2'b11;\n            3'b111 : grn = 2'b01;\n        endcase\n    end\n\n\n    always @(*)\n    begin\n        case(palette_read[1:0])\n            3'b000 : blu = 2'b00;\n            3'b001 : blu = 2'b01;\n            3'b010 : blu = 2'b11;\n            3'b011 : blu = 2'b10;\n            3'b100 : blu = 2'b00;\n            3'b101 : blu = 2'b10;\n            3'b110 : blu = 2'b11;\n            3'b111 : blu = 2'b01;\n        endcase\n    end\n\n\n\n    assign color = (hblank | vblank) ? 6'd0 : {grn,red,blu};\n\n\nendmodule\n",
        "module_name": "video_palframe",
        "module_hash": "920e1d5073a4faa554cbaff54b98acb8",
        "dataset_index": 19407
      },
      "teclado_84b1c7c7": {
        "rtl_code": "\nmodule teclado(\n    input      [7:0] ps2_data,\n    output reg [4:0] val,\n    output reg [2:0] control,\noutput [7:0] leds\n  );\n    \n    \n    localparam CTRL_NUMERO    = 3'd1;\n    localparam CTRL_ENTER     = 3'd2;\n    localparam CTRL_FLECHA    = 3'd3;\n    localparam CTRL_OPERACION = 3'd4;\n    \n    localparam CERO   = 8'h45;\n    localparam UNO    = 8'h16;\n    localparam DOS    = 8'h1E;\n    localparam TRES   = 8'h26;\n    localparam CUATRO = 8'h25;\n    localparam CINCO  = 8'h2E;\n    localparam SEIS   = 8'h36;\n    localparam SIETE  = 8'h3D;\n    localparam OCHO   = 8'h3E;\n    localparam NUEVE  = 8'h46;\n    localparam A      = 8'h1C;\n    localparam B      = 8'h32;\n    localparam C      = 8'h21;\n    localparam D      = 8'h23;\n    localparam E      = 8'h24;\n    localparam F      = 8'h2B;\n    localparam O      = 8'h44;\n    localparam Y      = 8'h35;\n    localparam SUMA   = 8'h1B;\n    localparam RESTA  = 8'h2D;\n    localparam MUL    = 8'h3A;\n    localparam ENTER  = 8'h5A;\n    localparam ARRIBA    =8'h75;\n    localparam ABAJO     =8'h72;\n    localparam IZQUIERDA =8'h6B;\n    localparam DERECHA   =8'h74;\n     \n    wire reloj_lento;\n    \n    \n    assign leds[4:0]= val;\n    assign leds[7:5]= control;   \n    \n\n   \n    \n    \n    always @(*) begin\n        case(ps2_data)\n           CERO: begin\n                    val=5'd0;        \n                    control=CTRL_NUMERO;\n            end\n            UNO: begin\n                    val=5'd1;\n                    control=CTRL_NUMERO;\n            end\n            DOS:begin\n                    val=5'd2;    \n                    control=CTRL_NUMERO;\n            end\n            TRES:begin\n                    val=5'd3;    \n                    control=CTRL_NUMERO;\n            end\n            CUATRO:begin\n                    val=5'd4;    \n                    control=CTRL_NUMERO;\n            end\n            CINCO:begin\n                    val=5'd5;    \n                    control=CTRL_NUMERO;\n            end\n            SEIS:begin\n                    val=5'd6;    \n                    control=CTRL_NUMERO;\n            end\n            SIETE:begin\n                    val=5'd7;    \n                    control=CTRL_NUMERO;\n            end\n            OCHO:begin\n                    val=5'd8;    \n                    control=CTRL_NUMERO;\n            end\n            NUEVE:begin\n                    val=5'd9;    \n                    control=CTRL_NUMERO;\n            end\n            A:begin\n                    val=5'd10;    \n                    control=CTRL_NUMERO;\n            end\n            B:begin\n                    val=5'd11;    \n                    control=CTRL_NUMERO;\n            end\n            C:begin\n                    val=5'd12;    \n                    control=CTRL_NUMERO;\n            end\n            D:begin\n                    val=5'd13;    \n                    control=CTRL_NUMERO;\n            end\n            E:begin\n                    val=5'd14;    \n                    control=CTRL_NUMERO;\n            end\n            F:begin\n                    val=5'd15;    \n                    control=CTRL_NUMERO;\n            end\n            SUMA:begin\n                    val=5'd21;    \n                    control=CTRL_OPERACION;\n            end\n            RESTA:begin\n                    val=5'd22;    \n                    control=CTRL_OPERACION;\n            end\n            MUL:begin\n                    val=5'd23;    \n                    control=CTRL_OPERACION;\n            end\n            Y:begin\n                    val=5'd24;    \n                    control=CTRL_OPERACION;\n            end\n            O:begin\n                    val=5'd25;    \n                    control=CTRL_OPERACION;\n            end\n            ENTER:begin\n                    val     =5'd16;    \n                    control =CTRL_ENTER;\n            end\n            ARRIBA:begin\n                    val=5'd19;    \n                    control=CTRL_FLECHA;\n            end\n            ABAJO:begin\n                    val=5'd20;    \n                    control=CTRL_FLECHA;\n            end\n            IZQUIERDA:begin\n                    val=5'd17;    \n                    control=CTRL_FLECHA;\n            end\n            DERECHA:begin\n                    val=5'd18;    \n                    control=CTRL_FLECHA;\n            end\n            default: begin\n                    val=5'd0;    \n                    control=3'd0;\n            end\n            endcase\n    end\n    \nendmodule\n",
        "module_name": "teclado",
        "module_hash": "84b1c7c7a7f0ccbea3fc4e150483b98f",
        "dataset_index": 23610
      },
      "pass_through_fd2158f0": {
        "rtl_code": "module pass_through(in, out, vdd18);\n  input vdd18;\n  input [7:0] in;\n  output [7:0] out;\n\n  assign out = vdd18 ? in : 8'b0;\nendmodule",
        "module_name": "pass_through",
        "module_hash": "fd2158f0530a50b31168c1378f96ec53",
        "dataset_index": 4603
      },
      "byte_reverse_9134c410": {
        "rtl_code": "module byte_reverse (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n\nmodule decade_counter (\n    input clk,\n    input reset,\n    input slowena,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            count <= 4'b0;\n        end else if (!slowena) begin\n            count <= count;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule adder (\n    input [31:0] in1,\n    input [3:0] in2,\n    output [31:0] out\n);\n    assign out = in1 + in2;\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input slowena,\n    input [31:0] in,\n    output [31:0] out\n);\n    wire [31:0] byte_reversed;\n    wire [3:0] counter;\n    byte_reverse byte_reverse_inst (\n        .in(in),\n        .out(byte_reversed)\n    );\n    decade_counter decade_counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .slowena(slowena),\n        .count(counter)\n    );\n    adder adder_inst (\n        .in1(byte_reversed),\n        .in2(counter),\n        .out(out)\n    );\nendmodule",
        "module_name": "byte_reverse",
        "module_hash": "9134c410256c35af013d45084c50d39e",
        "dataset_index": 11598
      },
      "sky130_fd_sc_lp__nand2_4_5d742b81": {
        "rtl_code": "\nmodule sky130_fd_sc_lp__nand2_4 (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire A3, A4;\n\n    sky130_fd_sc_lp__inv_2 U1 (\n        .Y(A3),\n        .A(A1)\n    );\n\n    sky130_fd_sc_lp__inv_2 U2 (\n        .Y(A4),\n        .A(A2)\n    );\n\n    sky130_fd_sc_lp__nand2_1 U3 (\n        .X(X),\n        .A1(A3),\n        .A2(A4),\n        .B1(B1)\n    );\n\nendmodule\n\nmodule sky130_fd_sc_lp__o41a_m (\n    X ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire X_tmp;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_lp__nand2_4 base (\n        .X(X_tmp),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1)\n    );\n\n    assign X = ~X_tmp;\n\nendmodule\n\nmodule sky130_fd_sc_lp__inv_2 (\n    Y ,\n    A\n);\n\n    output Y ;\n    input  A;\n\n    wire A_temp;\n\n    assign A_temp = ~A;\n\n    assign Y = A_temp;\n\nendmodule\n\nmodule sky130_fd_sc_lp__nand2_1 (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire A1_temp, A2_temp, B1_temp;\n\n    assign A1_temp = ~A1;\n    assign A2_temp = ~A2;\n    assign B1_temp = ~B1;\n\n    assign X = (A1_temp & A2_temp) | B1_temp;\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__nand2_4",
        "module_hash": "5d742b819481938f6959c5063bfa418a",
        "dataset_index": 6125
      },
      "mux4to1_471fc984": {
        "rtl_code": "module mux4to1 (\n    input  [3:0] data_in,\n    input  [1:0] sel,\n    output reg     data_out\n);\n\n    wire [3:0] sel_inv;\n    assign sel_inv = ~sel;\n\n    always @ (*) begin\n        if (sel == 2'b00) begin\n            data_out = data_in[0];\n        end else if (sel == 2'b01) begin\n            data_out = data_in[1];\n        end else if (sel == 2'b10) begin\n            data_out = data_in[2];\n        end else if (sel == 2'b11) begin\n            data_out = data_in[3];\n        end\n    end\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "471fc984f1c406894565889524b49ee2",
        "dataset_index": 7204
      },
      "xor_flipflop_609e68f0": {
        "rtl_code": "module xor_flipflop (\n    input clk,\n    input a,\n    input b,\n    output reg q\n);\n\nreg xor_out;\n\nalways @ (a or b) begin\n    xor_out = a ^ b;\nend\n\nalways @(posedge clk) begin\n    q <= xor_out;\nend\n\nendmodule\n\n\nmodule dual_edge_ff (\n    input clk,\n    input d,\n    output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= q1;\nend\n\nalways @(posedge clk) begin\n    q <= q2;\nend\n\nendmodule\n\n\nmodule combined_module (\n    input clk,\n    input a,\n    input b,\n    output q\n);\n\nwire xor_out;\nwire dual_edge_out;\n\nxor_flipflop xor_inst (\n    .clk(clk),\n    .a(a),\n    .b(b),\n    .q(xor_out)\n);\n\ndual_edge_ff dual_edge_inst (\n    .clk(clk),\n    .d(xor_out),\n    .q(dual_edge_out)\n);\n\nassign q = dual_edge_out;\n\nendmodule\n\n\nmodule top_module (\n    input clk,\n    input a,\n    input b,\n    output q\n);\n\ncombined_module combined_inst (\n    .clk(clk),\n    .a(a),\n    .b(b),\n    .q(q)\n);\n\nendmodule",
        "module_name": "xor_flipflop",
        "module_hash": "609e68f0a71b386830b6d3953451f41e",
        "dataset_index": 13789
      },
      "Divider #_cc1dc0f1": {
        "rtl_code": "module Divider #(\n  parameter n = 8\n)(\n  input signed [n-1:0] div,\n  input signed [n-1:0] dvsr,\n  output reg signed [n-1:0] quot,\n  output reg signed [n-1:0] rem\n);\n\n\nalways @(*) begin\n  if (dvsr == 0) begin\n    quot = 'bx;\n    rem = 'bx;\n  end\n  else if (div >= 0 && dvsr >= 0) begin // unsigned division\n    quot = div / dvsr;\n    rem = div % dvsr;\n  end\n  else if (div < 0 && dvsr < 0) begin // signed division\n    quot = $signed($unsigned(div) / $unsigned(dvsr));\n    rem = $signed($unsigned(div) % $unsigned(dvsr));\n  end\n  else if (div < 0 && dvsr >= 0) begin // signed dividend, unsigned divisor\n    quot = -(-div / dvsr);\n    rem = -(-div % dvsr);\n  end\n  else begin // unsigned dividend, signed divisor\n    quot = div / $signed(dvsr);\n    rem = div % $signed(dvsr);\n  end\nend\n\nendmodule",
        "module_name": "Divider #",
        "module_hash": "cc1dc0f18da6aca18530785dc91140ef",
        "dataset_index": 1219
      },
      "serial_rx #_6aec6120": {
        "rtl_code": "module serial_rx #(\n        parameter CLK_PER_BIT = 50\n    )(\n        input clk,\n        input rst,\n        input rx,\n        output [7:0] data,\n        output new_data\n    );\n\n    parameter CTR_SIZE = $clog2(CLK_PER_BIT);\n\n    localparam STATE_SIZE = 2;\n    localparam IDLE = 2'd0,\n    WAIT_HALF = 2'd1,\n    WAIT_FULL = 2'd2,\n    WAIT_HIGH = 2'd3;\n\n    reg [CTR_SIZE-1:0] ctr_d, ctr_q;\n    reg [2:0] bit_ctr_d, bit_ctr_q;\n    reg [7:0] data_d, data_q;\n    reg new_data_d, new_data_q;\n    reg [STATE_SIZE-1:0] state_d, state_q = IDLE;\n    reg rx_d, rx_q;\n\n    assign new_data = new_data_q;\n    assign data = data_q;\n\n    always @(*) begin\n        rx_d = rx;\n        state_d = state_q;\n        ctr_d = ctr_q;\n        bit_ctr_d = bit_ctr_q;\n        data_d = data_q;\n        new_data_d = 1'b0;\n\n        case (state_q)\n            IDLE: begin\n                bit_ctr_d = 3'b0;\n                ctr_d = 1'b0;\n                if (rx_q == 1'b0) begin\n                    state_d = WAIT_HALF;\n                end\n            end\n            WAIT_HALF: begin\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == (CLK_PER_BIT >> 1)) begin\n                    ctr_d = 1'b0;\n                    state_d = WAIT_FULL;\n                end\n            end\n            WAIT_FULL: begin\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    data_d = {rx_q, data_q[7:1]};\n                    bit_ctr_d = bit_ctr_q + 1'b1;\n                    ctr_d = 1'b0;\n                    if (bit_ctr_q == 3'd7) begin\n                        state_d = WAIT_HIGH;\n                        new_data_d = 1'b1;\n                    end\n                end\n            end\n            WAIT_HIGH: begin\n                if (rx_q == 1'b1) begin\n                    state_d = IDLE;\n                end\n            end\n            default: begin\n                state_d = IDLE;\n            end\n        endcase\n\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            ctr_q <= 1'b0;\n            bit_ctr_q <= 3'b0;\n            new_data_q <= 1'b0;\n            state_q <= IDLE;\n        end else begin\n            ctr_q <= ctr_d;\n            bit_ctr_q <= bit_ctr_d;\n            new_data_q <= new_data_d;\n            state_q <= state_d;\n        end\n\n        rx_q <= rx_d;\n        data_q <= data_d;\n    end\n\nendmodule",
        "module_name": "serial_rx #",
        "module_hash": "6aec6120498f29e7716f0e07c862a8af",
        "dataset_index": 25775
      },
      "OSERDESE2_e9c3ad45": {
        "rtl_code": "module OSERDESE2 ( \n   OFB, OQ, SHIFTOUT1, SHIFTOUT2, TBYTEOUT, TFB, TQ,\n   CLK, CLKDIV, D1, D2, D3, D4, D5, D6, D7, D8, OCE, RST, SHIFTIN1,\n   SHIFTIN2, T1, T2, T3, T4, TBYTEIN, TCE\n   );\n\n   parameter DATA_RATE_OQ=0;\n   parameter DATA_RATE_TQ=0;\n   parameter DATA_WIDTH=0;\n   parameter INIT_OQ=0;\n   parameter INIT_TQ=0;\n   parameter SERDES_MODE=0;\n   parameter SRVAL_OQ=0;\n   parameter SRVAL_TQ=0;\n   parameter TBYTE_CTL=0;\n   parameter TBYTE_SRC=0;\n   parameter TRISTATE_WIDTH=0;\n\n     \n   output OFB;                    output OQ;                     output SHIFTOUT1;              output SHIFTOUT2;              output TBYTEOUT;               output TFB;                    output TQ;                     input  CLK;                    input  CLKDIV;                 input  D1;                     input  D2;                     input  D3;                     input  D4;                     input  D5;                     input  D6;                     input  D7;                     input  D8;                     input  OCE;                    input  RST;                    input  SHIFTIN1;               input  SHIFTIN2;               input  T1;                     input  T2;                     input  T3;                     input  T4;                     input  TBYTEIN;                input  TCE;                    reg [2:0] state;\n\n\n   reg [7:0] buffer;\n   reg [1:0] clkdiv_sample;\n   reg [3:0] even;\n   reg [3:0] odd;\n   \n   always @ (posedge CLKDIV)\n     buffer[7:0]<={D8,D7,D6,D5,D4,D3,D2,D1};\n   \n   always @ (negedge CLK)\n     clkdiv_sample[1:0] <= {clkdiv_sample[0],CLKDIV};\n\n   wire      load_parallel = (clkdiv_sample[1:0]==2'b00);\n\n   always @ (negedge CLK)\n     if(load_parallel)\n       even[3:0]<={buffer[6],buffer[4],buffer[2],buffer[0]};\n     else\n       even[3:0]<={1'b0,even[3:1]};\n\n   always @ (negedge CLK)\n     if(load_parallel)\n       odd[3:0]<={buffer[7],buffer[5],buffer[3],buffer[1]};\n     else\n       odd[3:0]<={1'b0,odd[3:1]};\n     \n   assign OQ = CLK ? even[0] : odd[0];\n   \n   assign OFB       = 1'b0;\n   assign TQ        = 1'b0;\n   assign TBYTEOUT  = 1'b0;\n   assign SHIFTOUT1 = 1'b0;   \t\t      \n   assign SHIFTOUT2 = 1'b0;   \n   assign TFB       = 1'b0;\n   \nendmodule ",
        "module_name": "OSERDESE2",
        "module_hash": "e9c3ad453cb04df60ee9ea69853c4837",
        "dataset_index": 10517
      },
      "Adder_90bf60d4": {
        "rtl_code": "\nmodule Adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n\n    wire [7:0] carry;\n    wire [7:0] half_sum;\n\n    // Generate the carry bit for each bit of the sum\n    assign carry[0] = 1'b0;\n    genvar i;\n    for (i = 1; i < 8; i = i + 1) begin\n        assign carry[i] = (a[i-1] & b[i-1]) | (a[i-1] & carry[i-1]) | (b[i-1] & carry[i-1]);\n    end\n\n    // Generate the half-sum for each bit of the sum\n    assign half_sum[0] = a[0] ^ b[0];\n    for (i = 1; i < 8; i = i + 1) begin\n        assign half_sum[i] = a[i] ^ b[i] ^ carry[i-1];\n    end\n\n    // Combine the carry and half-sum to form the final sum\n    assign sum[8] = carry[7]; //MSB\n    assign sum[7:0] = {half_sum, 1'b0}; //LSB\nendmodule\n",
        "module_name": "Adder",
        "module_hash": "90bf60d4f96a9049f63e3865aae00ad0",
        "dataset_index": 16194
      },
      "add8_71689beb": {
        "rtl_code": "\nmodule add8(X, Y, S, Cout);\n  input [7:0] X, Y;\n  output [7:0] S;\n  output Cout;\n\n  wire [3:0] A, B, C;\n\n  adder_4bit inst1(.A(X[3:0]), .B(Y[3:0]), .S(S[3:0]), .Cout(C[0]));\n  adder_4bit inst2(.A(X[7:4]), .B(Y[7:4]), .S(S[7:4]), .Cin(C[0]), .Cout(Cout));\n\nendmodule\n\nmodule adder_4bit(A, B, S, Cin, Cout);\n  input [3:0] A, B;\n  output [3:0] S;\n  input Cin;\n  output Cout;\n\n  wire [2:0] C;\n\n  full_adder inst1(.A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(C[0]));\n  full_adder inst2(.A(A[1]), .B(B[1]), .Cin(C[0]), .S(S[1]), .Cout(C[1]));\n  full_adder inst3(.A(A[2]), .B(B[2]), .Cin(C[1]), .S(S[2]), .Cout(C[2]));\n  full_adder inst4(.A(A[3]), .B(B[3]), .Cin(C[2]), .S(S[3]), .Cout(Cout));\n\nendmodule\n\nmodule full_adder(A, B, Cin, S, Cout);\n  input A, B, Cin;\n  output S, Cout;\n\n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (B & Cin) | (A & Cin);\n\nendmodule\n",
        "module_name": "add8",
        "module_hash": "71689beb4151e8f607cbc07dd609140c",
        "dataset_index": 17068
      },
      "bitwise_or_8bab9e5e": {
        "rtl_code": "\nmodule bitwise_or (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Stage 1\nwire [3:0] stage1_out;\nassign stage1_out = a | b;\n\n// Stage 2\nalways @(*) begin\n    out <= stage1_out;\nend\n\nendmodule",
        "module_name": "bitwise_or",
        "module_hash": "8bab9e5e99c61f843eee60766654efbf",
        "dataset_index": 19969
      },
      "input_interface_b573b7a6": {
        "rtl_code": "module input_interface (\n    input A,\n    input SLEEP,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    wire VPWR_inverted;\n    wire VPB_inverted;\n    wire VNB_inverted;\n\n    assign VPWR_inverted = (A == 1'b1) ? ~VPWR : VPWR;\n    assign VPB_inverted = (SLEEP == 1'b1) ? ~VPB : VPB;\n    assign VNB_inverted = (VGND == 1'b1) ? ~VNB : VNB;\n\n    assign X = {VPWR_inverted, VPB_inverted, VNB_inverted};\n\nendmodule",
        "module_name": "input_interface",
        "module_hash": "b573b7a69810a7b595c1651148695909",
        "dataset_index": 10705
      },
      "ClkDiv_20Hz_52c1e37f": {
        "rtl_code": "\nmodule ClkDiv_20Hz(\n    CLK,\t\t\t\t\t\t\t\t\t\tRST,\t\t\t\t\t\t\t\t\t\tCLKOUT,\t\t\t\t\t\t\t\t\tCLKOUTn\n    );\n\ninput CLK;\n\tinput RST;\n\toutput CLKOUT;\n\toutput CLKOUTn;\n\nreg CLKOUT = 1'b1;\n\n\tparameter cntEndVal = 19'h493E0;\n\treg [18:0] clkCount = 19'h00000;\n\nassign CLKOUTn = ~CLKOUT;\n    \n\talways @(posedge CLK) begin\n\n\t\t\tif(RST == 1'b1) begin\n\t\t\t\t\tCLKOUT <= 1'b0;\n\t\t\t\t\tclkCount <= 0;\n\t\t\tend\n\t\t\telse begin\n\n\t\t\t\t\tif(clkCount == cntEndVal) begin\n\t\t\t\t\t\t\tCLKOUT <= ~CLKOUT;\n\t\t\t\t\t\t\tclkCount <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t\tclkCount <= clkCount + 1'b1;\n\t\t\t\t\tend\n\n\t\t\tend\n\n\tend\n\nendmodule\n",
        "module_name": "ClkDiv_20Hz",
        "module_hash": "52c1e37f4b7120ddcb8f164fdd08185c",
        "dataset_index": 622
      },
      "debug_lsa_5f0c0374": {
        "rtl_code": "\n\n\n\n\nmodule debug_lsa\n(\n    input av_clk,\n    input av_rst,\n\n    input [9:0] av_address,\n    input av_write,\n    input av_read,\n    input [31:0] av_writedata,\n    output reg [31:0] av_readdata,\n    output reg av_readdatavalid,\n\n    output reg [7:0] lsa_mode,\n    input lsa_clk,\n    input lsa_trigger,\n    input [31:0] lsa_data\n);\n    parameter INIT_ARMED = 1;\n    parameter INIT_FORCED = 0;\n    parameter INIT_MODE = 8'd0;\n\n    reg [1:0] sync_av;\n    reg [1:0] sync_lsa;\n    reg [1:0] sync_lsa_av;\n\n    reg ctrl_arm;\n    reg av_arm;\n    reg lsa_arm;\n\n    reg ctrl_force;\n    reg av_force;\n    reg lsa_force;\n\n    reg [7:0] ctrl_mode;\n    reg [7:0] av_mode;\n    reg sample_done;\n    reg av_done;\n    reg lsa_done;\n\n    wire sample_running;\n    reg av_running;\n    reg lsa_running;\n\n    wire [31:0] sample_live = lsa_data;\n    reg [31:0] av_live;\n    reg [31:0] lsa_live;\n\n    always @ (posedge av_clk or posedge av_rst)\n        if (av_rst)\n        begin\n            sync_lsa_av <= 2'd0;\n            sync_av <= 2'd0;\n        end\n        else\n        begin\n            sync_lsa_av <= sync_lsa;\n            sync_av <= (sync_lsa_av == sync_av) ? sync_av + 2'd1 : sync_av;\n        end\n\n    always @ (posedge lsa_clk)\n        sync_lsa <= sync_av;\n\n    always @ (posedge av_clk)\n        if (sync_av == 2'b01)\n            {av_live, av_running, av_done, av_mode, av_force, av_arm} <=\n                            {lsa_live, lsa_running, lsa_done, ctrl_mode, ctrl_force, ctrl_arm};\n\n    always @ (posedge lsa_clk)\n        if (sync_lsa == 2'b10)\n            {lsa_live, lsa_running, lsa_done, lsa_mode, lsa_force, lsa_arm} <=\n                            {sample_live, sample_running, sample_done, av_mode, av_force, av_arm};\n\n    reg [10:0] sample_waddr;\n    assign sample_running = sample_waddr[10];\n    reg [31:0] sample_data[1023:0];\n\n    always @ (posedge lsa_clk)\n        sample_done <= lsa_arm && (sample_waddr == 11'h000);\n\n    always @ (posedge lsa_clk)\n        if (!lsa_arm)\n            sample_waddr <= 11'h001;\n        else if (!sample_waddr[10] && |sample_waddr[9:0])\n            sample_waddr <= sample_waddr + 11'd1;\n        else if (sample_waddr == 11'h400)\n            sample_waddr <= (lsa_force || lsa_trigger) ? 11'h401 : 11'h400;\n        else if (sample_waddr != 11'h000)\n            sample_waddr <= sample_waddr + 10'd1;\n\n    always @ (posedge lsa_clk)\n        if (lsa_arm)\n            sample_data[sample_waddr[9:0]] <= (sample_waddr[10]) ? lsa_data : 32'd0;\n\n    reg init_cycle;\n\n    always @ (posedge av_clk or posedge av_rst)\n        if (av_rst)\n        begin\n            ctrl_arm <= 1'b0;\n            ctrl_force <= 1'b0;\n            ctrl_mode <= 8'd0;\n            init_cycle <= 1'b0;\n        end\n        else if (!init_cycle)\n        begin\n            ctrl_arm <= (INIT_ARMED != 0);\n            ctrl_force <= (INIT_FORCED != 0);\n            ctrl_mode <= INIT_MODE;\n            init_cycle <= 1'b1;\n        end\n        else if (av_write && (av_address == 10'd0))\n        begin\n            ctrl_arm <= av_writedata[0];\n            ctrl_force <= av_writedata[1];\n            ctrl_mode <= av_writedata[15:8];\n        end\n\n    always @ (posedge av_clk)\n        av_readdatavalid <= av_read;\n\n    always @ (posedge av_clk)\n        if (av_address == 10'd0)\n            av_readdata <= {16'd0, ctrl_mode, 4'd0, av_running, av_done, ctrl_force, ctrl_arm};\n        else if (av_address == 10'd1)\n            av_readdata <= av_live;\n        else\n            av_readdata <= sample_data[av_address];\n\nendmodule\n",
        "module_name": "debug_lsa",
        "module_hash": "5f0c0374d8f49270b0e99163c4937a42",
        "dataset_index": 3135
      },
      "sky130_fd_sc_hd__a31oi_eaff0165": {
        "rtl_code": "module sky130_fd_sc_hd__a31oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    // Module ports\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    //  Name  Output      Other arguments\n    and and0 (and0_out  , A3, A1, A2     );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__a31oi",
        "module_hash": "eaff016508c94f7f3cd877ef1f3eb29b",
        "dataset_index": 15245
      },
      "FIFO_WxD #_0e99e7f5": {
        "rtl_code": "module FIFO_WxD #(\n\tparameter U_FIFO_WIDTH = 24, \t// word width of FIFO\n\tparameter U_FIFO_SQ_DEPTH = 10 // 2^n depth of the FIFO (3k byte - 1 FIFO by default)\n\t)(\n\tinput wire rst,\n\tinput wire [U_FIFO_WIDTH - 1:0] dataIn,\n\tinput wire wr_en,\n\tinput wire rd_en,\n\toutput wire [U_FIFO_WIDTH - 1:0] dataOut,\n\toutput wire full_flg,\n\toutput wire empty_flg\n\t);\n\n\t// FIFO buffer instance\n\treg [U_FIFO_WIDTH - 1:0] fifo [(2**U_FIFO_SQ_DEPTH) - 1:0];\n\t\n\t// pointer counters (set to 0 initially)\n\treg [U_FIFO_SQ_DEPTH - 1:0] wr_ptr = 0;\n\treg [U_FIFO_SQ_DEPTH - 1:0] rd_ptr = 0;\n\t\n\t// write block\n\talways@(posedge wr_en or negedge rst)\n\tbegin\n\t\t\n\t\tif(!rst)\t// async reset\n\t\t\twr_ptr <= 0;\n\t\telse if(!full_flg) // write data to the buffer and inc the write pointer\n\t\tbegin\n\t\t\tfifo[wr_ptr] <= dataIn;\n\t\t\twr_ptr <= wr_ptr + 1'b1;\n\t\tend\n\tend // write block\n\n\t// read block\n\talways@(posedge rd_en or negedge rst)\n\tbegin\n\t\t\n\t\tif(!rst)\n\t\t\trd_ptr <= 0;\n\t\telse if(!empty_flg)\n\t\tbegin\n\t\t\trd_ptr <= rd_ptr + 1'b1;\n\t\tend\n\tend // read block\n\n\t// assign the outputs continously (pointers determine flags and data)\n\tassign empty_flg = (wr_ptr == rd_ptr)? 1'b1 : 1'b0; \n\tassign full_flg = ((wr_ptr + {{U_FIFO_SQ_DEPTH-1{1'b0}}, 1'b1}) == rd_ptr)? 1'b1 : 1'b0; // because of the full flg decision the fifo depth is 2^n - 1\n\tassign dataOut = (empty_flg)? {U_FIFO_WIDTH{1'b0}} : fifo[rd_ptr]; // 0 if empty\n\t\nendmodule",
        "module_name": "FIFO_WxD #",
        "module_hash": "0e99e7f5f28f1beb1b88482b895190dc",
        "dataset_index": 1895
      },
      "digital_delay_line_ddba9b0c": {
        "rtl_code": "\nmodule digital_delay_line (\n  input clk,\n  input in,\n  output reg out\n);\n\nparameter delay = 10; // number of clock cycles to delay the input signal\n\nreg [7:0] register; // register with the width of the input signal\ninteger count; // counter for clock cycles\n\nalways @(posedge clk) begin\n  if (count < delay) begin\n    count = count + 1;\n  end else begin\n    count = 0;\n    register <= in;\n    out <= register; // Fix the error by moving the output assignment to within the clock edge.\n  end\nend\n\nendmodule",
        "module_name": "digital_delay_line",
        "module_hash": "ddba9b0c717d2844bb945031d6c9c5d3",
        "dataset_index": 17171
      },
      "FIFO_image_filter_gray_data_stream_0_V_shiftReg #_d3e3560f": {
        "rtl_code": "module FIFO_image_filter_gray_data_stream_0_V_shiftReg #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 1\n)(\n    input clk,\n    input [DATA_WIDTH-1:0] data,\n    input ce,\n    input [ADDR_WIDTH-1:0] a,\n    output reg [DATA_WIDTH-1:0] q\n);\n\n\nparameter DEPTH = 2;\n\nreg [DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\nbegin\n    if (ce)\n    begin\n        for (i=0; i<DEPTH-1; i=i+1)\n            SRL_SIG[i+1] <= SRL_SIG[i];\n        SRL_SIG[0] <= data;\n    end\nend\n\nalways @*\nbegin\n    q <= SRL_SIG[a];\nend\n\nendmodule",
        "module_name": "FIFO_image_filter_gray_data_stream_0_V_shiftReg #",
        "module_hash": "d3e3560f1b40b93279416a7a5b3f9e5d",
        "dataset_index": 7059
      },
      "NAND8_reducer_27eebcb1": {
        "rtl_code": "module NAND8_reducer(\n\tInY,\n\tReduced_NAND\n);\n\n\ninput wire\t[7:0] InY;\noutput wire\tReduced_NAND;\n\nwire\tSYNTHESIZED_WIRE_0;\nwire\tSYNTHESIZED_WIRE_1;\nwire\tSYNTHESIZED_WIRE_2;\nwire\tSYNTHESIZED_WIRE_3;\nwire\tSYNTHESIZED_WIRE_4;\nwire\tSYNTHESIZED_WIRE_5;\nwire\tSYNTHESIZED_WIRE_6;\n\n\n\n\nassign\tSYNTHESIZED_WIRE_5 = ~(InY[4] | InY[5]);\n\nassign\tSYNTHESIZED_WIRE_4 = ~(InY[2] | InY[3]);\n\nassign\tSYNTHESIZED_WIRE_2 =  ~InY[7];\n\nassign\tSYNTHESIZED_WIRE_3 = ~(InY[0] | InY[1]);\n\nassign\tReduced_NAND = ~(SYNTHESIZED_WIRE_0 | SYNTHESIZED_WIRE_1);\n\nassign\tSYNTHESIZED_WIRE_6 = ~(InY[6] | SYNTHESIZED_WIRE_2);\n\nassign\tSYNTHESIZED_WIRE_0 = ~(SYNTHESIZED_WIRE_3 & SYNTHESIZED_WIRE_4);\n\nassign\tSYNTHESIZED_WIRE_1 = ~(SYNTHESIZED_WIRE_5 & SYNTHESIZED_WIRE_6);\n\n\nendmodule\n",
        "module_name": "NAND8_reducer",
        "module_hash": "27eebcb151ad7aef0fe891db4949ff9b",
        "dataset_index": 23846
      },
      "sampler #_6b2ee9fa": {
        "rtl_code": "\n\nmodule sampler #(\n  parameter integer DW = 32,  parameter integer CW = 24   )(\n  input  wire          clk, \t\tinput  wire          rst, \t\tinput  wire          extClock_mode,\tinput  wire          wrDivider, \tinput  wire [CW-1:0] config_data, \tinput  wire          sti_valid,\tinput  wire [DW-1:0] sti_data, \toutput reg           sto_valid, \toutput reg  [DW-1:0] sto_data, \toutput reg           ready50\n);\n\nreg next_sto_valid;\nreg [DW-1:0] next_sto_data;\n\nreg [CW-1:0] divider, next_divider; \nreg [CW-1:0] counter, next_counter;\twire counter_zero = ~|counter;\n\n\ninitial\nbegin\n  divider = 0;\n  counter = 0;\n  sto_valid = 0;\n  sto_data = 0;\nend\nalways @ (posedge clk) \nbegin\n  divider   <= next_divider;\n  counter   <= next_counter;\n  sto_valid <= next_sto_valid;\n  sto_data  <= next_sto_data;\nend\n\nalways @*\nbegin\n  next_divider = divider;\n  next_counter = counter;\n  next_sto_valid = 1'b0;\n  next_sto_data = sto_data;\n\n  if (extClock_mode)\n    begin\n      next_sto_valid = sti_valid;\n      next_sto_data = sti_data;\n    end\n  else if (sti_valid && counter_zero)\n    begin\n      next_sto_valid = 1'b1;\n      next_sto_data = sti_data;\n    end\n\n  if (wrDivider)\n    begin\n      next_divider = config_data[CW-1:0];\n      next_counter = next_divider;\n      next_sto_valid = 1'b0; end\n  else if (sti_valid) \n    if (counter_zero)\n      next_counter = divider;\n    else next_counter = counter-1'b1;\nend\n\n\nalways @(posedge clk) \nbegin\n  if (wrDivider)\n    ready50 <= 1'b0; else if (counter_zero)\n    ready50 <= 1'b1;\n  else if (counter == divider[CW-1:1])\n    ready50 <= 1'b0;\nend\n\nendmodule\n",
        "module_name": "sampler #",
        "module_hash": "6b2ee9fa05ecfe5b9a91b26dc2c5daa3",
        "dataset_index": 14611
      },
      "clock_gate_7c4d3e36": {
        "rtl_code": "module clock_gate (CLK, EN, TE, ENCLK);\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg gated_clk;\n\n  always @ (posedge CLK) begin\n    if (EN && !TE) begin\n      gated_clk <= 1;\n    end else begin\n      gated_clk <= 0;\n    end\n  end\n\n  assign ENCLK = gated_clk & CLK;\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "7c4d3e362200eeff4d562140aa7343ee",
        "dataset_index": 4978
      },
      "counter_5c49117c": {
        "rtl_code": "\nmodule counter (\n    input clk,\n    input rst,\n    input en,\n    input up,\n    output reg [3:0] count\n);\n\nreg [3:0] count_reg1, count_reg2;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count_reg1 <= 4'b0;\n        count_reg2 <= 4'b0;\n    end\n    else begin\n        if (en) begin\n            if (up) begin\n                count_reg1 <= count_reg2 + 4'b1;\n            end\n            else begin\n                count_reg1 <= count_reg2 - 4'b1;\n            end\n        end\n        count_reg2 <= count_reg1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0;\n    end\n    else begin\n        count <= count_reg2;\n    end\nend\n\nendmodule\n",
        "module_name": "counter",
        "module_hash": "5c49117c9d8d8d80e336ae7a9d00c9e7",
        "dataset_index": 17754
      },
      "UART_TX_e2c2afd8": {
        "rtl_code": "\n\nmodule UART_TX(\n    input rst, clk, baud_edge, data_ready,\n    input [7:0] data,\n    output reg tx, data_accepted\n);\n    localparam START = (1 << 0), DATA = (1 << 1), END = (1 << 2);\n\n    reg [7:0] data_reg;\n    reg [2:0] data_counter;\n    reg [3:0] state;\n\n    initial begin\n        tx <= 1;\n        data_accepted <= 0;\n    end\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state <= END;\n            tx <= 1;\n            data_accepted <= 0;\n        end else if(baud_edge) begin\n            case(state)\n            START: begin\n                tx <= 0;\n                data_counter <= 0;\n                state <= DATA;\n            end\n            DATA: begin\n                tx <= data_reg[data_counter];\n                if(data_counter != 7) begin\n                    data_counter <= data_counter + 1;\n                end else begin\n                    state <= END;\n                    data_counter <= 0;\n                end\n            end\n            END: begin\n                tx <= 1;\n                if(data_ready) begin\n                    data_accepted <= 1;\n                    data_reg <= data;\n                    state <= START;\n                end\n            end\n            default: begin\n                tx <= 1;\n                state <= END;\n            end\n            endcase\n        end else begin\n            data_accepted <= 0;\n        end\n    end\nendmodule\n",
        "module_name": "UART_TX",
        "module_hash": "e2c2afd8195060dea0a50dbb8b87bb52",
        "dataset_index": 15482
      },
      "fifo_buffer_06e64ec2": {
        "rtl_code": "\nmodule fifo_buffer (\n  input in0, \n  input rd_clk, \n  input [2:0] g7serrst, \n  output reg out\n);\n\n  reg Q_reg;\n  wire in0_sync;\n  reg rd_rst_asreg_reg;\n\n  fifo_bt_txd_synchronizer_ff sync (\n    .in0(in0),\n    .rd_clk(rd_clk),\n    .out(in0_sync),\n    .rd_rst_asreg_reg(rd_rst_asreg_reg)\n  );\n\n  always @ (posedge rd_clk or negedge g7serrst[0]) begin\n    if (~g7serrst[0]) begin\n      Q_reg <= 1'b0;\n      rd_rst_asreg_reg <= 1'b0;\n    end else begin\n      Q_reg <= in0_sync;\n      rd_rst_asreg_reg <= ~Q_reg & in0_sync;\n    end\n  end\n\n  always @ (posedge rd_clk) begin\n    out <= Q_reg;\n  end\n\nendmodule\nmodule fifo_bt_txd_synchronizer_ff (\n  input in0, \n  input rd_clk, \n  output reg out, \n  input rd_rst_asreg_reg\n);\n\n  reg Q_reg;\n  reg [0:0] in0_sync;\n\n  always @ (posedge rd_clk) begin\n    in0_sync <= in0;\n  end\n\n  always @ (posedge rd_clk or negedge rd_rst_asreg_reg) begin\n    if (~rd_rst_asreg_reg) begin\n      Q_reg <= 1'b0;\n    end else begin\n      Q_reg <= in0_sync;\n    end\n  end\n\n  always @ (posedge rd_clk) begin\n    out <= Q_reg;\n  end\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "06e64ec2173487b48fbe934eca6fe292",
        "dataset_index": 9882
      },
      "sky130_fd_sc_hd__a21oi_32c9f27f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a21oi",
        "module_hash": "32c9f27f14e0e52899db85f13a51d227",
        "dataset_index": 12624
      },
      "LowPassFilter_06ddfb7e": {
        "rtl_code": "module LowPassFilter(\n\tinput clk,\n\tinput filter_onoff,\n\tinput signed [15:0] audio_in,\n\toutput signed [15:0] audio_out\n);\n\n\twire [15:0] filter_out;\n\t\n\t// Instantiate SystolicFilter module\n\tSystolicFilter SystolicFilter_inst(\n\t\t.clk(clk),\n\t\t.filter_onoff(filter_onoff),\n\t\t.audio_in(audio_in),\n\t\t.filter_out(filter_out)\n\t);\n\n\tassign audio_out = filter_onoff ? filter_out : audio_in;\n\nendmodule\n\nmodule SystolicFilter(\n\tinput clk,\n\tinput filter_onoff,\n\tinput signed [15:0] audio_in,\n\toutput reg [15:0] filter_out\n);\n\n\talways @(posedge clk) begin\n\t\tif (filter_onoff) begin\n\t\t\t// Implement your filter logic here\n\t\t\tfilter_out <= audio_in;\n\t\tend\n\tend\n\nendmodule",
        "module_name": "LowPassFilter",
        "module_hash": "06ddfb7e9ae0039fa7cc316ebddc0624",
        "dataset_index": 2844
      },
      "logic_operation_11f08ff2": {
        "rtl_code": "module logic_operation (\n    output Y,\n    input  A,\n    input  B,\n    input  C,\n    input  D\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Implement AND gates\n    wire AB;\n    wire CD;\n    and (AB, A, B);\n    and (CD, C, D);\n\n    // Implement OR gate\n    or (Y, AB, CD);\n\nendmodule",
        "module_name": "logic_operation",
        "module_hash": "11f08ff2b7f9a062dd92e875c8f4e00d",
        "dataset_index": 458
      },
      "johnson_counter #_c6ee969e": {
        "rtl_code": "module johnson_counter #(\n  parameter m = 4 // number of output signals\n)(\n  input clk,\n  output [m-1:0] out\n);\n\n\nreg [m-1:0] shift_reg;\nassign out = shift_reg;\n\nalways @(posedge clk) begin\n  shift_reg <= {shift_reg[m-2:0], shift_reg[m-1]};\nend\n\nendmodule",
        "module_name": "johnson_counter #",
        "module_hash": "c6ee969eaefe3d3b7267fb3e38821fd3",
        "dataset_index": 21251
      },
      "my_logic_ea22bdb9": {
        "rtl_code": "\nmodule my_logic (\n    output Y,\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input C1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    // Local signals\n    wire or_out;\n    wire nand_out_Y;\n\n    // OR gate\n    assign or_out = A1 | A2 | A3;\n\n    // NAND gate\n    assign nand_out_Y = ~(C1 & or_out & B1);\n\n    // Assign output\n    assign Y = nand_out_Y;\n\nendmodule",
        "module_name": "my_logic",
        "module_hash": "ea22bdb9c2e06c6a6da6f87e5caa0f5a",
        "dataset_index": 5179
      },
      "memory_controller_0035105a": {
        "rtl_code": "module memory_controller\n  (\n   clock,\n   reset_b,\n\n   ext_cs_b,\n   cpu_rnw,\n   cpu_clken,\n   cpu_addr,\n   cpu_dout,\n   ext_dout,\n\n   ram_cs_b,\n   ram_oe_b,\n   ram_we_b,\n   ram_data_in,\n   ram_data_out,\n   ram_data_oe,\n   ram_addr\n   );\n\n   parameter DSIZE        = 32;\n   parameter ASIZE        = 20;\n\n   input                 clock;\n   input                 reset_b;\n\n   input                 ext_cs_b;\n   input                 cpu_rnw;\n   output                cpu_clken;\n   input [ASIZE-1:0]     cpu_addr;\n   input [DSIZE-1:0]     cpu_dout;\n   output [DSIZE-1:0]    ext_dout;\n\n   output                ram_cs_b;\n   output                ram_oe_b;\n   output                ram_we_b;\n   output [17:0]         ram_addr;\n\n   input  [15:0]         ram_data_in;\n   output [15:0]         ram_data_out;\n   output                ram_data_oe;\n\n   wire                  ext_a_lsb;\n   reg [15:0]            ram_data_last;\n   reg                   count;\n\n   always @(posedge clock)\n     count <= !ext_cs_b;\n\n   assign cpu_clken = !(!ext_cs_b && !count);\n\n   assign ext_a_lsb = count;\n   \n   always @(posedge clock)\n     ram_data_last <= ram_data_in;\n\n   assign ext_dout = { ram_data_in, ram_data_last };\n\n   assign ram_addr = {cpu_addr[16:0], ext_a_lsb};\n   assign ram_cs_b = ext_cs_b;\n   assign ram_oe_b = !cpu_rnw;\n   assign ram_we_b = ext_cs_b | cpu_rnw | (!clock);\n\n   assign ram_data_oe = !cpu_rnw;\n   assign ram_data_out  = ext_a_lsb == 1 ? cpu_dout[31:16]  :\n                                           cpu_dout[15:0]   ;\n\nendmodule\n",
        "module_name": "memory_controller",
        "module_hash": "0035105abb383c6fbc6dda14c8313258",
        "dataset_index": 24016
      },
      "and_gate_mux_not_7b4ea39e": {
        "rtl_code": "\nmodule and_gate_mux_not (\n    input a,\n    input b,\n    input in,\n    output out\n);\n\n    wire not_in;\n\n    // NOT gate implementation\n    assign not_in = ~in;\n\n    // Multiplexer implementation\n    assign out = a ? in: not_in;\n\nendmodule\nmodule priority_encoder (\n    input [7:0] in,\n    output [2:0] pos\n);\n\n    wire [7:0] inv_in;\n    wire [7:0] and_out;\n\n    // Inverter implementation\n    assign inv_in = ~in;\n\n    // AND gate implementation\n    and_gate_mux_not and_gate_0 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[0]),\n        .out(and_out[0])\n    );\n\n    and_gate_mux_not and_gate_1 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[1]),\n        .out(and_out[1])\n    );\n    \n    and_gate_mux_not and_gate_2 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[2]),\n        .out(and_out[2])\n    );\n\n    and_gate_mux_not and_gate_3 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[3]),\n        .out(and_out[3])\n    );\n    \n    and_gate_mux_not and_gate_4 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[4]),\n        .out(and_out[4])\n    );\n\n    and_gate_mux_not and_gate_5 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[5]),\n        .out(and_out[5])\n    );\n    \n    and_gate_mux_not and_gate_6 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[6]),\n        .out(and_out[6])\n    );\n\n    and_gate_mux_not and_gate_7 (\n        .a(1'b1),\n        .b(1'b1),\n        .in(in[7]),\n        .out(and_out[7])\n    );\n\n    // Priority encoder implementation\n    assign pos = {2'b0, and_out[7:6]};\n\nendmodule\nmodule final_module (\n    input a,\n    input b,\n    input [7:0] in,\n    output [2:0] pos\n);\n\n    wire and_out;\n    wire [2:0] priority_pos;\n\n    // AND gate and NOT gate implementation\n    and_gate_mux_not and_gate (\n        .a(a),\n        .b(b),\n        .in(in[0]),\n        .out(and_out)\n    );\n\n    // Priority encoder implementation\n    priority_encoder priority_enc (\n        .in(in[7:0]),\n        .pos(priority_pos)\n    );\n\n    // Output assignment\n    assign pos = and_out ? priority_pos: 3'b0;\n\nendmodule",
        "module_name": "and_gate_mux_not",
        "module_hash": "7b4ea39e1b748cac15b37bdfbc2a52ff",
        "dataset_index": 21282
      },
      "counter_d11548c4": {
        "rtl_code": "module counter\n(\n    input wire clk,\n    input wire rst,\n    input wire load,\n    input wire [3:0] init,\n    output reg [3:0] out\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            out <= 4'b0;\n        end\n        else if (load) begin\n            out <= init;\n        end\n        else begin\n            out <= (out == 4'b1111) ? 4'b0 : out + 1;\n        end\n    end\n    \nendmodule",
        "module_name": "counter",
        "module_hash": "d11548c4d86dc64ee1f14a9306b7e954",
        "dataset_index": 9583
      },
      "RegistroWithMuxInput#_0087cfb1": {
        "rtl_code": "\nmodule RegistroWithMuxInput#(parameter Width = 4)\n(CLK,EnableRegisterIn,reset,SELCoeffX,SELCoeffY,Coeff00,Coeff01,Coeff02,Coeff03,Coeff04,Coeff05,Coeff06,Coeff07,Coeff08,Coeff09,\nCoeff10,Coeff11,Coeff12,Coeff13,Coeff14,Coeff15,Coeff16,Coeff17,Coeff18,Coeff19,OffsetIn,OutCoeffX,OutCoeffY,OffsetOut);\n\n\tinput signed [Width-1:0] Coeff00,Coeff01,Coeff02,Coeff03,Coeff04,Coeff05,Coeff06,Coeff07,Coeff08,\n\tCoeff09,Coeff10,Coeff11,Coeff12,Coeff13,Coeff14,Coeff15,Coeff16,Coeff17,Coeff18,Coeff19,OffsetIn;\n\t\n\tinput CLK,EnableRegisterIn,reset;\n\tinput [3:0] SELCoeffX,SELCoeffY;\n\t\n\toutput reg signed [Width-1:0] OutCoeffX = 0;\n\toutput reg signed [Width-1:0] OutCoeffY = 0;  output signed [Width-1:0] OffsetOut;\n\t\n\treg signed [Width-1:0] AuxCoeff00,AuxCoeff01,AuxCoeff02,AuxCoeff03,AuxCoeff04,AuxCoeff05,AuxCoeff06,\n\tAuxCoeff07,AuxCoeff08,AuxCoeff09,AuxCoeff10,AuxCoeff11,AuxCoeff12,AuxCoeff13,AuxCoeff14,AuxCoeff15,AuxCoeff16,\n\tAuxCoeff17,AuxCoeff18,AuxCoeff19,AuxCoeff20;\n\t\n\talways @(posedge CLK)\n\t  if (reset) begin\n\t\t  AuxCoeff00 <= 0;\n\t\t  AuxCoeff01 <= 0;\n\t\t  AuxCoeff02 <= 0;\n\t\t  AuxCoeff03 <= 0;\n\t\t  AuxCoeff04 <= 0;\n\t\t  AuxCoeff05 <= 0;\n\t\t  AuxCoeff06 <= 0;\n\t\t  AuxCoeff07 <= 0;\n\t\t  AuxCoeff08 <= 0;\n\t\t  AuxCoeff09 <= 0;\n\t\t  AuxCoeff10 <= 0;\n\t\t  AuxCoeff11 <= 0;\n\t\t  AuxCoeff12 <= 0;\n\t\t  AuxCoeff13 <= 0;\n\t\t  AuxCoeff14 <= 0;\n\t\t  AuxCoeff15 <= 0;\n\t\t  AuxCoeff16 <= 0;\n\t\t  AuxCoeff17 <= 0;\n\t\t  AuxCoeff18 <= 0;\n\t\t  AuxCoeff19 <= 0;\n\t\t  AuxCoeff20 <= 0;\n\t  end else if (EnableRegisterIn) begin\n\t\t  AuxCoeff00 <= Coeff00;\n\t\t  AuxCoeff01 <= Coeff01;\n\t\t  AuxCoeff02 <= Coeff02;\n\t\t  AuxCoeff03 <= Coeff03;\n\t\t  AuxCoeff04 <= Coeff04;\n\t\t  AuxCoeff05 <= Coeff05;\n\t\t  AuxCoeff06 <= Coeff06;\n\t\t  AuxCoeff07 <= Coeff07;\n\t\t  AuxCoeff08 <= Coeff08;\n\t\t  AuxCoeff09 <= Coeff09;\n\t\t  AuxCoeff10 <= Coeff10;\n\t\t  AuxCoeff11 <= Coeff11;\n\t\t  AuxCoeff12 <= Coeff12;\n\t\t  AuxCoeff13 <= Coeff13;\n\t\t  AuxCoeff14 <= Coeff14;\n\t\t  AuxCoeff15 <= Coeff15;\n\t\t  AuxCoeff16 <= Coeff16;\n\t\t  AuxCoeff17 <= Coeff17;\n\t\t  AuxCoeff18 <= Coeff18;\n\t\t  AuxCoeff19 <= Coeff19;\n\t\t  AuxCoeff20 <= OffsetIn;\n\t  end\n\t  \n\t  assign OffsetOut = AuxCoeff20;\n\t  \n\t  always @(SELCoeffX, AuxCoeff00,AuxCoeff01,AuxCoeff02,AuxCoeff03,AuxCoeff04,AuxCoeff05,AuxCoeff06,\n\t\tAuxCoeff07,AuxCoeff08,AuxCoeff09)\n      case (SELCoeffX)\n         5'd00: OutCoeffX <= AuxCoeff00;\n         5'd01: OutCoeffX <= AuxCoeff01;\n         5'd02: OutCoeffX <= AuxCoeff02;\n         5'd03: OutCoeffX <= AuxCoeff03;\n         5'd04: OutCoeffX <= AuxCoeff04;\n         5'd05: OutCoeffX <= AuxCoeff05;\n         5'd06: OutCoeffX <= AuxCoeff06;\n         5'd07: OutCoeffX <= AuxCoeff07;\n\t\t\t5'd08: OutCoeffX <= AuxCoeff08;\n         5'd09: OutCoeffX <= AuxCoeff09;\t\n\t\t\tdefault : OutCoeffX <= 0;\n      endcase\n\t\t\n\t\talways @(SELCoeffY,AuxCoeff10,AuxCoeff11,AuxCoeff12,AuxCoeff13,AuxCoeff14,AuxCoeff15,AuxCoeff16,\n\t\tAuxCoeff17,AuxCoeff18,AuxCoeff19)\n      case (SELCoeffY)\n         5'd00: OutCoeffY <= AuxCoeff10;\n         5'd01: OutCoeffY <= AuxCoeff11;\n         5'd02: OutCoeffY <= AuxCoeff12;\n         5'd03: OutCoeffY <= AuxCoeff13;\n         5'd04: OutCoeffY <= AuxCoeff14;\n         5'd05: OutCoeffY <= AuxCoeff15;\n         5'd06: OutCoeffY <= AuxCoeff16;\n         5'd07: OutCoeffY <= AuxCoeff17;\n\t\t\t5'd08: OutCoeffY <= AuxCoeff18;\n         5'd09: OutCoeffY <= AuxCoeff19;\t\n\t\t\tdefault : OutCoeffY <= 0;\n      endcase\n\n\nendmodule\n\n",
        "module_name": "RegistroWithMuxInput#",
        "module_hash": "0087cfb1be3d84d1419b20eba03915a3",
        "dataset_index": 6388
      },
      "counter_15e55898": {
        "rtl_code": "module counter (\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n        end else if (count == 9) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "15e558987cb28611c1da6ab5a4bc7439",
        "dataset_index": 13046
      },
      "reg_module_5933a3a5": {
        "rtl_code": "module reg_module(\n    input clk,\n    input reset,\n    input wenb,\n    input [7:0] in_data,\n    output reg [7:0] reg_out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            reg_out <= 8'h00;\n        end else if (wenb) begin\n            reg_out <= in_data;\n        end\n    end\n\nendmodule",
        "module_name": "reg_module",
        "module_hash": "5933a3a550343bdec115a90483f912e7",
        "dataset_index": 20179
      },
      "reverse_mux_and_82a0eb51": {
        "rtl_code": "module reverse_mux_and(\n    input [7:0] in,\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\n    // Reverse the input binary number\n    wire [7:0] reversed_in;\n    assign reversed_in = {in[7], in[6], in[5], in[4], in[3], in[2], in[1], in[0]};\n    \n    // Select one of the four 4-bit inputs using the 4-to-1 multiplexer\n    wire [3:0] selected_input;\n    assign selected_input = (sel == 2'b00) ? in0 :\n                            (sel == 2'b01) ? in1 :\n                            (sel == 2'b10) ? in2 :\n                                             in3;\n    \n    // Perform bitwise AND of the reversed binary number and the selected input\n    wire [3:0] and_output;\n    assign and_output = reversed_in[7:4] & selected_input;\n    \n    // Output the result of the AND operation\n    assign out = and_output;\n    \nendmodule",
        "module_name": "reverse_mux_and",
        "module_hash": "82a0eb51f36104a5006ddcd1608ee383",
        "dataset_index": 6821
      },
      "SPI_sender_323f0a35": {
        "rtl_code": "\nmodule SPI_sender(\n    input CLK,\n    input RST,\n    input [7:0] DATA,\n    input [31:0] T_DIV,\n    input ST,\n    output SCK,\n    output MOSI,\n    output reg SS,\n    output reg DONE\n);\n\nreg [31:0] counter;\nreg [7:0] shift_register;\nreg [7:0] data_out;\nreg [3:0] bit_counter;\nreg ss_done;\n\nassign MOSI = shift_register[7-bit_counter];\nassign SCK = counter < (T_DIV/2);\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        counter <= 0;\n        shift_register <= 0;\n        data_out <= 0;\n        bit_counter <= 0;\n        ss_done <= 0;\n        DONE <= 0;\n    end else if (ST) begin\n        if (counter < T_DIV) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n            if (!ss_done) begin\n                SS <= 0;\n                ss_done <= 1;\n            end else begin\n                if (bit_counter < 7) begin\n                    shift_register <= {DATA[bit_counter], shift_register[7:1]};\n                    bit_counter <= bit_counter + 1;\n                end else begin\n                    data_out <= shift_register;\n                    bit_counter <= 0;\n                    if (ss_done) begin\n                        SS <= 1;\n                        DONE <= 1;\n                    end\n                end\n            end\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "SPI_sender",
        "module_hash": "323f0a35cd070b818acd6a2f1ae4445b",
        "dataset_index": 15513
      },
      "shift_reg_32804eb1": {
        "rtl_code": "\nmodule shift_reg(\n    input clk,\n    input [2:0] select,\n    input [7:0] in,\n    output [7:0] out\n);\n\nreg [7:0] out_reg;\n\nalways @(posedge clk) begin\n    case(select)\n        3'b000: out_reg <= in;\n        3'b001: out_reg <= {in[7], out_reg[6:0]};\n        3'b010: out_reg <= {in[7:1], out_reg[0]};\n        3'b011: out_reg <= {in, out_reg[7:1]};\n        3'b100: out_reg <= {in, out_reg[7:2]};\n        3'b101: out_reg <= {in, out_reg[7:3]};\n        3'b110: out_reg <= {in, out_reg[7:4]};\n        3'b111: out_reg <= {in, out_reg[7:5]};\n    endcase\nend\n\nassign out = out_reg;\n\nendmodule\n\nmodule reg_module(\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [7:0] out\n);\n\nreg [7:0] out_reg;\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        out_reg <= 8'b0;\n    end else begin\n        out_reg <= in;\n    end\nend\n\nassign out = out_reg;\n\nendmodule\n\nmodule concat_module(\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output [31:0] out\n);\n\nassign out = {a, b, c, d};\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nwire [7:0] byte1, byte2, byte3, byte4;\nwire [7:0] reg_out;\n\nshift_reg shift_reg1(.clk(clk), .select(3'b001), .in(in[23:16]), .out(byte2));\nreg_module reg_module1(.clk(clk), .reset(reset), .in(byte2), .out(reg_out));\nshift_reg shift_reg2(.clk(clk), .select(3'b010), .in(in[15:8]), .out(byte3));\nshift_reg shift_reg3(.clk(clk), .select(3'b111), .in(in[31:24]), .out(byte4));\nconcat_module concat_module1(.a(byte4), .b(reg_out), .c(byte3), .d(in[7:0]), .out(out));\n\nendmodule\n",
        "module_name": "shift_reg",
        "module_hash": "32804eb1617f8a5525403b9e91a819e0",
        "dataset_index": 6793
      },
      "barrel_shifter_b805761d": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [7:0] A,\n    input signed [2:0] B,\n    output reg [7:0] Y\n);\n\nreg [7:0] stage1_out;\nreg [7:0] stage2_out;\nreg [7:0] stage3_out;\n\nalways @(*) begin\n    stage1_out = (B[0] == 1'b1) ? {A[6:0], 1'b0} : {1'b0, A[7:1]};\nend\n\nalways @(*) begin\n    stage2_out = (B[1] == 1'b1) ? {stage1_out[5:0], 2'b00} : {2'b00, stage1_out[7:2]};\nend\n\nalways @(*) begin\n    stage3_out = (B[2] == 1'b1) ? {stage2_out[3:0], 4'b0000} : {4'b0000, stage2_out[7:4]};\nend\n\nalways @(*) begin\n    case (B)\n        3'b000 : Y = A;\n        3'b001 : Y = stage1_out;\n        3'b010 : Y = {A[1:0], A[7:2]};\n        3'b011 : Y = {A[2:0], A[7:3]};\n        3'b111 : Y = stage3_out;\n        3'b110 : Y = {A[4:0], A[7:5]};\n        3'b101 : Y = {A[5:0], A[7:6]};\n        default: Y = 8'b0;\n    endcase\nend\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "b805761dcc6cf9d29521e76d610d8931",
        "dataset_index": 9022
      },
      "twos_complement_sum_d84812e6": {
        "rtl_code": "\nmodule twos_complement_sum (\n  input [31:0] input_data,\n  output reg [15:0] output_sum\n);\n\n  reg [15:0] lower_bits_twos_comp;\n  reg [15:0] upper_bits_twos_comp;\n  reg [15:0] sum;\n\n  always @(*) begin\n    lower_bits_twos_comp = ~input_data[15:0] + 1;\n    upper_bits_twos_comp = ~input_data[31:16] + 1;\n  end\n\n  always @(*) begin\n    sum = lower_bits_twos_comp + upper_bits_twos_comp;\n    if (sum > 32767) begin\n      output_sum = 32767;\n    end else begin\n      output_sum = sum;\n    end\n  end\n\nendmodule\n",
        "module_name": "twos_complement_sum",
        "module_hash": "d84812e6641a5157a64d530012d73897",
        "dataset_index": 18530
      },
      "five_input_gate_5d5293d9": {
        "rtl_code": "module five_input_gate (in1, in2, in3, in4, in5, out);\n\ninput in1, in2, in3, in4, in5;\noutput out;\n\nwire temp1, temp2;\n\n// AND the first two inputs\nand and1(temp1, in1, in2);\n\n// AND the third and fourth inputs\nand and2(temp2, in3, in4);\n\n// OR the two temporary outputs and the fifth input\nor or1(out, temp1, temp2, in5);\n\nendmodule",
        "module_name": "five_input_gate",
        "module_hash": "5d5293d93f2685bdf1926ae5acea3c68",
        "dataset_index": 8268
      },
      "sky130_fd_sc_lp__a22o_5d9acf26": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a22o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2            );\n    and and1 (and1_out , A1, A2            );\n    or  or0  (or0_out_X, and1_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a22o",
        "module_hash": "5d9acf263cecce621c8f79cc7f81dad2",
        "dataset_index": 21605
      },
      "Keyboard_efe1a0cd": {
        "rtl_code": "module Keyboard\n(\n\tinput Clock,\n\tinput [3:0]C,\t\t\t\t\t\toutput reg press,\n\toutput reg[3:0]CodeOut,\tR  \t);\t\n\nreg [2:0]state, flag;\nparameter\t\t\t\t\t\tKeyNo  = 3'b000,\n\tState1 = 3'b001,\n\tState2 = 3'b010,\n\tState3 = 3'b011,\n\tState4 = 3'b100,\n\tKeyYes = 3'b101;\n\t\n\t\nalways @(posedge Clock)\n\tcase(state)\n\t\tKeyNo:\n\t\t\tif(C == 4'b1111)\n\t\t\t\tbegin state <= KeyNo; R <= 4'b0000; end\n\t\t\telse\n\t\t\t\tbegin state <= State1; R <= 4'b0111; end\n\t\tState1:\n\t\t\tif(C == 4'b1111)\n\t\t\t\tbegin state <= State2; R <= 4'b1011; end\n\t\t\telse\n\t\t\t\tstate <= KeyYes;\n\t\tState2:\n\t\t\tif(C == 4'b1111)\n\t\t\t\tbegin\tstate <= State3; R <= 4'b1101; end\n\t\t\telse\n\t\t\t\tstate <= KeyYes;\n\t\tState3:\n\t\t\tif(C == 4'b1111)\n\t\t\t\tbegin state <= State4; R <= 4'b1110; end\n\t\t\telse\n\t\t\t\tstate <= KeyYes;\n\t\tState4:\n\t\t\tif(C == 4'b1111)\n\t\t\t\tbegin state <= KeyNo; R <= 4'b0000;\tend\n\t\t\telse\n\t\t\t\tstate <= KeyYes;\n\t\tKeyYes:\n\t\t\tif(C == 4'b1111)\n\t\t\t\tbegin \n\t\t\t\t\tstate <= KeyNo; \n\t\t\t\t\tR <= 4'b0000; \t\t\n\t\t\t\t\tpress <= 0;\t\t\tflag <= 0;\t\t\tend\n\t\t\telse if(flag < 7)\t\t\tflag <= flag+1;\n\t\t\telse\n\t\t\t\tpress <= 1;\t\t\t\tendcase\n\nalways @({C,R})\n\tcase({C,R})\n\t\t8'b01110111: CodeOut <= 4'h1;\n\t\t8'b01111011: CodeOut <= 4'h4;\n\t\t8'b01111101: CodeOut <= 4'h7;\n\t\t8'b01111110: CodeOut <= 4'ha;\t\t\t\n\t\t\t\t\n\t\t8'b10110111: CodeOut <= 4'h2;\n\t\t8'b10111011: CodeOut <= 4'h5;\n\t\t8'b10111101: CodeOut <= 4'h8;\n\t\t8'b10111110: CodeOut <= 4'h0;\n\t\t\t\t\t\n\t\t8'b11010111: CodeOut <= 4'h3;\n\t\t8'b11011011: CodeOut <= 4'h6;\n\t\t8'b11011101: CodeOut <= 4'h9;\n\t\t8'b11011110: CodeOut <= 4'hb;\n\t\t\n\t\t8'b11100111: CodeOut <= 4'hc;\n\t\t8'b11101011: CodeOut <= 4'hd;\n\t\t8'b11101101: CodeOut <= 4'he;\n\t\tdefault: CodeOut <= 4'hf;\t\t\t\n\tendcase\nendmodule",
        "module_name": "Keyboard",
        "module_hash": "efe1a0cd896017e28de88173717b7f2a",
        "dataset_index": 23431
      },
      "sky130_fd_sc_ls__nor4_b0877e00": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__nor4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B, C, D     );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__nor4",
        "module_hash": "b0877e00c025516e4df40f146c163207",
        "dataset_index": 22278
      },
      "xor_gate_d36b7a01": {
        "rtl_code": "\nmodule xor_gate(input a, b, output out);\n\n  // Structural Verilog module\n  wire xored;\n  xor m_xor_gate(xored, a, b);\n  buf m_buf(out, xored);\n\nendmodule\n\nmodule m_xor_gate(input a, b, output out);\n  assign out = a ^ b;\nendmodule\n",
        "module_name": "xor_gate",
        "module_hash": "d36b7a013096aefedc18905678e1a9fc",
        "dataset_index": 1357
      },
      "wallace_14c49799": {
        "rtl_code": "module wallace(x,y,p);\ninput [7:0] x,y;\noutput [15:0] p;\nwire [6:0] ip1;\nwire [7:0] ip2,ip3,ip4,ip5,ip6,ip7,ip8,si,iip;\nwire [6:0] s1,s2,s3,s4,s5,s6;\nwire [7:0] c1,c2,c3,c4,c5,c6,c7;\nwire c;\nand fi1(p[0],y[0],x[0]);\nand fi2(ip1[0],y[0],x[1]);\nand fi3(ip1[1],y[0],x[2]);\nand fi4(ip1[2],y[0],x[3]);\nand fi5(ip1[3],y[0],x[4]);\nand fi6(ip1[4],y[0],x[5]);\nand fi7(ip1[5],y[0],x[6]);\nand fi8(ip1[6],y[0],x[7]);\nnot n1(si[0],ip1[6]);\n\nand se1(ip2[0],y[1],x[0]);\nand se2(ip2[1],y[1],x[1]);\nand se3(ip2[2],y[1],x[2]);\nand se4(ip2[3],y[1],x[3]);\nand se5(ip2[4],y[1],x[4]);\nand se6(ip2[5],y[1],x[5]);\nand se7(ip2[6],y[1],x[6]);\nand se8(ip2[7],y[1],x[7]);\nnot n2(si[1],ip2[7]);\n\nand th1(ip3[0],y[2],x[0]);\nand th2(ip3[1],y[2],x[1]);\nand th3(ip3[2],y[2],x[2]);\nand th4(ip3[3],y[2],x[3]);\nand th5(ip3[4],y[2],x[4]);\nand th6(ip3[5],y[2],x[5]);\nand th7(ip3[6],y[2],x[6]);\nand th8(ip3[7],y[2],x[7]);\nnot n3(si[2],ip3[7]);\n\nand fo1(ip4[0],y[3],x[0]);\nand fo2(ip4[1],y[3],x[1]);\nand fo3(ip4[2],y[3],x[2]);\nand fo4(ip4[3],y[3],x[3]);\nand fo5(ip4[4],y[3],x[4]);\nand fo6(ip4[5],y[3],x[5]);\nand fo7(ip4[6],y[3],x[6]);\nand fo8(ip4[7],y[3],x[7]);\nnot n4(si[3],ip4[7]);\n\nand fif1(ip5[0],y[4],x[0]);\nand fif2(ip5[1],y[4],x[1]);\nand fif3(ip5[2],y[4],x[2]);\nand fif4(ip5[3],y[4],x[3]);\nand fif5(ip5[4],y[4],x[4]);\nand fif6(ip5[5],y[4],x[5]);\nand fif7(ip5[6],y[4],x[6]);\nand fif8(ip5[7],y[4],x[7]);\nnot n5(si[4],ip5[7]);\n\nand si1(ip6[0],y[5],x[0]);\nand si2(ip6[1],y[5],x[1]);\nand si3(ip6[2],y[5],x[2]);\nand si4(ip6[3],y[5],x[3]);\nand si5(ip6[4],y[5],x[4]);\nand si6(ip6[5],y[5],x[5]);\nand si7(ip6[6],y[5],x[6]);\nand si8(ip6[7],y[5],x[7]);\nnot n6(si[5],ip6[7]);\n\nand sev1(ip7[0],y[6],x[0]);\nand sev2(ip7[1],y[6],x[1]);\nand sev3(ip7[2],y[6],x[2]);\nand sev4(ip7[3],y[6],x[3]);\nand sev5(ip7[4],y[6],x[4]);\nand sev6(ip7[5],y[6],x[5]);\nand sev7(ip7[6],y[6],x[6]);\nand sev8(ip7[7],y[6],x[7]);\nnot n7(si[6],ip7[7]);\n\nand eii1(iip[0],y[7],x[0]);\nand eii2(iip[1],y[7],x[1]);\nand eii3(iip[2],y[7],x[2]);\nand eii4(iip[3],y[7],x[3]);\nand eii5(iip[4],y[7],x[4]);\nand eii6(iip[5],y[7],x[5]);\nand eii7(iip[6],y[7],x[6]);\nand eii8(iip[7],y[7],x[7]);\n\nxor ei1(ip8[0],y[7],iip[0]);\nxor ei2(ip8[1],y[7],iip[1]);\nxor ei3(ip8[2],y[7],iip[2]);\nxor ei4(ip8[3],y[7],iip[3]);\nxor ei5(ip8[4],y[7],iip[4]);\nxor ei6(ip8[5],y[7],iip[5]);\nxor ei7(ip8[6],y[7],iip[6]);\nxor ei8(ip8[7],y[7],iip[7]);\nnot n8(si[7],ip8[7]);\n\n\nHA ha1(ip1[0],ip2[0],c1[0],p[1]);\nFA fa1(ip1[1],ip2[1],ip3[0],c1[1],s1[0]);\nFA fa2(ip1[2],ip2[2],ip3[1],c1[2],s1[1]);\nFA fa3(ip1[3],ip2[3],ip3[2],c1[3],s1[2]);\nFA fa4(ip1[4],ip2[4],ip3[3],c1[4],s1[3]);\nFA fa5(ip1[5],ip2[5],ip3[4],c1[5],s1[4]);\nFA fa6(ip1[6],ip2[6],ip3[5],c1[6],s1[5]);\nFA fa7(si[0],si[1],ip3[6],c1[7],s1[6]);\n\nHA ha2(s1[0],c1[0],c2[0],p[2]);\nFA sa1(s1[1],c1[1],ip4[0],c2[1],s2[0]);\nFA sa2(s1[2],c1[2],ip4[1],c2[2],s2[1]);\nFA sa3(s1[3],c1[3],ip4[2],c2[3],s2[2]);\nFA sa4(s1[4],c1[4],ip4[3],c2[4],s2[3]);\nFA sa5(s1[5],c1[5],ip4[4],c2[5],s2[4]);\nFA sa6(s1[6],c1[6],ip4[5],c2[6],s2[5]);\nFA sa7(si[2],c1[7],ip4[6],c2[7],s2[6]);\n\nHA ha3(s2[0],c2[0],c3[0],p[3]);\nFA ta1(s2[1],ip5[0],c2[1],c3[1],s3[0]);\nFA ta2(s2[2],ip5[1],c2[2],c3[2],s3[1]);\nFA ta3(s2[3],ip5[2],c2[3],c3[3],s3[2]);\nFA ta4(s2[4],ip5[3],c2[4],c3[4],s3[3]);\nFA ta5(s2[5],ip5[4],c2[5],c3[5],s3[4]);\nFA ta6(s2[6],ip5[5],c2[6],c3[6],s3[5]);\nFA ta7(si[3],ip5[6],c2[7],c3[7],s3[6]);\n\nHA ha4(s3[0],c3[0],c4[0],p[4]);\nFA foa1(s3[1],ip6[0],c3[1],c4[1],s4[0]);\nFA foa2(s3[2],ip6[1],c3[2],c4[2],s4[1]);\nFA foa3(s3[3],ip6[2],c3[3],c4[3],s4[2]);\nFA foa4(s3[4],ip6[3],c3[4],c4[4],s4[3]);\nFA foa5(s3[5],ip6[4],c3[5],c4[5],s4[4]);\nFA foa6(s3[6],ip6[5],c3[6],c4[6],s4[5]);\nFA foa7(si[4],ip6[6],c3[7],c4[7],s4[6]);\n\nHA ha5(s4[0],c4[0],c5[0],p[5]);\nFA fia1(s4[1],ip7[0],c4[1],c5[1],s5[0]);\nFA fia2(s4[2],ip7[1],c4[2],c5[2],s5[1]);\nFA fia3(s4[3],ip7[2],c4[3],c5[3],s5[2]);\nFA fia4(s4[4],ip7[3],c4[4],c5[4],s5[3]);\nFA fia5(s4[5],ip7[4],c4[5],c5[5],s5[4]);\nFA fia6(s4[6],ip7[5],c4[6],c5[6],s5[5]);\nFA fia7(si[5],ip7[6],c4[7],c5[7],s5[6]);\n\nHA ha6(s5[0],c5[0],c6[0],p[6]);\nFA sia1(s5[1],ip8[0],c5[1],c6[1],s6[0]);\nFA sia2(s5[2],ip8[1],c5[2],c6[2],s6[1]);\nFA sia3(s5[3],ip8[2],c5[3],c6[3],s6[2]);\nFA sia4(s5[4],ip8[3],c5[4],c6[4],s6[3]);\nFA sia5(s5[5],ip8[4],c5[5],c6[5],s6[4]);\nFA sia6(s5[6],ip8[5],c5[6],c6[6],s6[5]);\nFA sia7(si[6],ip8[6],c5[7],c6[7],s6[6]);\n\nFAd sea0(s6[0],c6[0],y[7],c7[0],p[7]);\nFAd sea1(s6[1],c6[1],c7[0],c7[1],p[8]);\nFAd sea2(s6[2],c6[2],c7[1],c7[2],p[9]);\nFAd sea3(s6[3],c6[3],c7[2],c7[3],p[10]);\nFAd sea4(s6[4],c6[4],c7[3],c7[4],p[11]);\nFAd sea5(s6[5],c6[5],c7[4],c7[5],p[12]);\nFAd sea6(s6[6],c6[6],c7[5],c7[6],p[13]);\nFAd sea7(si[7],c6[7],c7[6],c7[7],p[14]);\nHA ha8(c7[7],1'b1,c,p[15]);\n\n\nendmodule\n\nmodule HA(a,b,c,s);\ninput a,b;\noutput c,s;\nxor x1(s,a,b);\nand a1(c,a,b);\nendmodule\n\nmodule FA(a,b,c,cy,sm);\ninput a,b,c;\noutput cy,sm;\nwire x,y;\nxor x1(x,a,b);\nxnor x2(y,a,b);\nMUX m1(x,y,c,sm);\nMUX m2(a,c,x,cy);\n\nendmodule\n\nmodule MUX(i0,i1,s,o);\ninput i0,i1,s;\noutput o;\nwire t,p,q;\nand a1(t,s,i1);\nnot n0(p,s);\nand a2(q,p,i0);\nor a3(o,t,q);\nendmodule\n\nmodule FAd(a,b,c,cy,sm);\ninput a,b,c;\noutput cy,sm;\nwire x,y,z;\nxor x1(x,a,b);\nxor x2(sm,x,c);\nand a1(y,a,b);\nand a2(z,x,c);\nor o1(cy,y,z);\nendmodule\n\n",
        "module_name": "wallace",
        "module_hash": "14c49799a328874b09b67e37e9124ec2",
        "dataset_index": 5319
      },
      "bin_to_seven_seg_5dd99f79": {
        "rtl_code": "\nmodule bin_to_seven_seg(\n\t output [6:0] S,\n\t input [3:0] D\n    );\n\t\t\n\t reg [6:0] S2;\n\t always @(D) begin\n\t\t\tS2 = 7'b0000000;\n\t\t case(D)\n\t\t\t4'h0: S2 = 7'b1111110;\t4'h1: S2 = 7'b0110000;\t4'h2: S2 = 7'b1101101;\t4'h3: S2 = 7'b1111001;\t4'h4: S2 = 7'b0110011;\t4'h5: S2 = 7'b1011011;\t4'h6: S2 = 7'b1011111;\t4'h7: S2 = 7'b1110000;\t4'h8: S2 = 7'b1111111;\t4'h9: S2 = 7'b1111011;\t4'hA: S2 = 7'b1110111;\t4'hB: S2 = 7'b0011111;\t4'hC: S2 = 7'b1001110;\t4'hD: S2 = 7'b0111101;\t4'hE: S2 = 7'b1001111;\t4'hF: S2 = 7'b1000111;\tdefault: S2 = 7'b0000000;\n\t\t endcase\n\t end\n\t \n\t assign S = ~S2;\n\nendmodule\n",
        "module_name": "bin_to_seven_seg",
        "module_hash": "5dd99f796c6fd63eca2c64d80325c389",
        "dataset_index": 24021
      },
      "DALU_ba2e8ca2": {
        "rtl_code": "\nmodule DALU(\n    clk,\n\trst,\n\tin_valid,\n\tinstruction,\n  out_valid,\n  out\n    );\n\ninput clk;\ninput rst;\ninput in_valid;\ninput [18:0] instruction;\n\noutput reg out_valid;\noutput reg signed [15:0] out;\n\nparameter IDLE=0, INPUT=1, OUTPUT=2, OP=3;\n\nreg [1:0] cState, nState;\nwire [2:0] L;\nwire signed [5:0] s, t;\nwire signed [3:0] l;\nwire signed [9:0] i;\n\nassign L = instruction[18:16];\nassign s = instruction[15:10];\nassign t = instruction[9:4];\nassign l = instruction[3:0];\nassign i = instruction[9:0];\n\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) cState <= IDLE;\n\telse cState <= nState;\nend\n\nalways@(*)\nbegin\n\tcase(cState)\n\t\tIDLE: if(in_valid) nState = INPUT;\n\t\tINPUT: if(!in_valid) nState = OUTPUT;\n\t\tOUTPUT: nState = IDLE;\n\t\tdefault: nState = IDLE;\n\tendcase\nend\n\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) out_valid <= 0;\n\telse begin\n\t\tcase(cState)\n\t\t\tIDLE: out_valid <= 0;\n\t\t\tINPUT: out_valid <= 0;\n\t\t\tOUTPUT: out_valid <= 1;\n\t\t\tdefault: out_valid <= out_valid;\n\t\tendcase\n\tend\nend\n\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) out <= 0;\n\telse begin\n\t\tcase(cState)\n\t\t\tIDLE: begin\n\t\t\t\tif(nState == INPUT) begin\n\t\t\t\t\tcase(L)\n\t\t\t\t\t\t0: begin\n\t\t\t\t\t\t\tcase(l)\n\t\t\t\t\t\t\t\t0: out <= s & t;\n\t\t\t\t\t\t\t\t1: out <= s | t;\n\t\t\t\t\t\t\t\t2: out <= s ^ t;\n\t\t\t\t\t\t\t\t3: out <= s + t;\n\t\t\t\t\t\t\t\t4: out <= s - t;\n\t\t\t\t\t\t\t\tdefault: out <= out;\n\t\t\t\t\t\t\tendcase\n\t\t\t\t\t\tend\n\t\t\t\t\t\t1: out <= s * t * l;\n\t\t\t\t\t\t2: out <= (s+t+l) * (s+t+l);\n\t\t\t\t\t\t3: out <= s + i;\n\t\t\t\t\t\t4: out <= s - i;\n\t\t\t\t\t\tdefault: out <= out;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\tend\n\t\t\tINPUT: out <= out;\n\t\t\tOUTPUT: out <= out;\n\t\t\tdefault: out <= out;\n\t\tendcase\n\tend\nend\n\nendmodule\n",
        "module_name": "DALU",
        "module_hash": "ba2e8ca2ba603f8fa52de5d5556c6868",
        "dataset_index": 23560
      },
      "binary_counter_04d58575": {
        "rtl_code": "\nmodule binary_counter (\n  input clk,\n  input rst,\n  input en,\n  input load,\n  output reg [3:0] q,\n  output [3:0] q_bar\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      q <= 4'b0000;\n    end else if (en) begin\n      q <= q + 1;\n    end else if (load) begin\n      q <= {q_bar[3], q_bar[2], q_bar[1], q_bar[0]};\n    end\n  end\n\n  assign q_bar = ~q;\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "04d58575425f28e46650641c8eaa2769",
        "dataset_index": 1180
      },
      "signed_barrel_shifter_447127f2": {
        "rtl_code": "module signed_barrel_shifter (\n    input clk,\n    input rst,\n    input signed [3:0] data_in,\n    input [1:0] shift_amount,\n    output reg signed [3:0] data_out\n);\n\nreg signed [3:0] stage1_out;\nreg signed [3:0] stage2_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out <= 4'b0;\n        stage1_out <= 4'b0;\n        stage2_out <= 4'b0;\n    end else begin\n        stage1_out <= data_in << shift_amount;\n        stage2_out <= (shift_amount[1]) ? {2{stage1_out[3]}} : {2'b0, stage1_out[3:2]};\n        data_out <= (shift_amount[0]) ? stage2_out >> 1 : stage2_out;\n    end\nend\n\nendmodule",
        "module_name": "signed_barrel_shifter",
        "module_hash": "447127f248a32c4f83131267054c0a8d",
        "dataset_index": 8875
      },
      "lo_adc_3b7c0121": {
        "rtl_code": "module lo_adc(\n    pck0,\n    pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4,\n    adc_d, adc_clk,\n    ssp_frame, ssp_din, ssp_dout, ssp_clk,\n    dbg, divisor,\n    lf_field\n);\n    input pck0;\n    output pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4;\n    input [7:0] adc_d;\n    output adc_clk;\n    input ssp_dout;\n    output ssp_frame, ssp_din, ssp_clk;\n    output dbg;\n    input [7:0] divisor;\n    input lf_field;\n\n    reg [7:0] to_arm_shiftreg;\n    reg [7:0] pck_divider;\n    reg clk_state;\n\n    // Antenna logic, depending on \"lf_field\" (in arm defined as FPGA_LF_READER_FIELD)\n    wire tag_modulation = ssp_dout & !lf_field;\n    wire reader_modulation = !ssp_dout & lf_field & clk_state;\n\n    // always on (High Frequency outputs, unused)\n    assign pwr_oe1 = 1'b0;\n    assign pwr_hi = 1'b0;\n\n    // low frequency outputs\n    assign pwr_lo = reader_modulation;\n    assign pwr_oe2 = 1'b0;  // 33 Ohms\n    assign pwr_oe3 = tag_modulation; // base antenna load = 33 Ohms\n    assign pwr_oe4 = 1'b0;  // 10k Ohms\n\n    // Debug Output ADC clock\n    assign dbg = adc_clk;\n\n    // ADC clock out of phase with antenna driver\n    assign adc_clk = ~clk_state;\n\n    // serialized SSP data is gated by clk_state to suppress unwanted signal\n    assign ssp_din = to_arm_shiftreg[7] && !clk_state;\n\n    // SSP clock always runs at 24MHz\n    assign ssp_clk = pck0;\n\n    // SSP frame is gated by clk_state and goes high when pck_divider=8..15\n    assign ssp_frame = (pck_divider[7:3] == 5'd1) && !clk_state;\n\n    // divide 24mhz down to 3mhz\n    always @(posedge pck0)\n    begin\n        if (pck_divider == divisor[7:0])\n        begin\n            pck_divider <= 8'd0;\n            clk_state = !clk_state;\n        end\n        else\n        begin\n            pck_divider <= pck_divider + 1;\n        end\n    end\n\n    // this task also runs at pck0 frequency (24Mhz) and is used to serialize\n    // the ADC output which is then clocked into the ARM SSP.\n    always @(posedge pck0)\n    begin\n        if ((pck_divider == 8'd7) && !clk_state)\n            to_arm_shiftreg <= adc_d;\n        else begin\n            to_arm_shiftreg[7:1] <= to_arm_shiftreg[6:0];\n            // simulation showed a glitch occuring due to the LSB of the shifter\n            // not being set as we shift bits out\n            // this ensures the ssp_din remains low after a transfer and suppresses\n            // the glitch that would occur when the last data shifted out ended in\n            // a 1 bit and the next data shifted out started with a 0 bit\n            to_arm_shiftreg[0] <= 1'b0;\n        end\n    end\n\nendmodule",
        "module_name": "lo_adc",
        "module_hash": "3b7c012166c45cb006c3c5d53ce8ddbd",
        "dataset_index": 5673
      },
      "parallel_port_0245a8ed": {
        "rtl_code": "\nmodule parallel_port(\n  input clk_i, rst_i, readstrobe_i, writestrobe_i,\n  input [1:0] address_i,\n  input [7:0] data_i,\n  input [31:0] parport_i,\n  output [31:0] parport_o,\n  output [7:0] data_o,\n  output parport_readstrobe_o,\n  output parport_writestrobe_o\n);\n\n  reg [23:0] inputreg_r;\n  reg [23:0] outputreg_r;\n  reg [7:0] data_o;\n  reg parport_readstrobe_o;\n  reg parport_writestrobe_o;\n\n  assign parport_o = parport_i;\n\n  always @(*) begin\n    data_o = parport_i[7:0];\n    case(address_i)\n      2'b01: data_o = inputreg_r[7:0];\n      2'b10: data_o = inputreg_r[15:8];\n      2'b11: data_o = inputreg_r[23:16];\n    endcase\n\n    parport_readstrobe_o = 0;\n    if((address_i == 2'b00) && readstrobe_i) begin\n      parport_readstrobe_o = 1;\n    end\n  end\n\n  always @(posedge clk_i) begin\n    parport_writestrobe_o <= 0;\n    if(rst_i) begin\n      outputreg_r <= 0;\n    end else if(writestrobe_i) begin\n      case(address_i)\n        2'b00: outputreg_r[7:0] <= data_i;\n        2'b01: outputreg_r[15:8] <= data_i;\n        2'b10: outputreg_r[23:16] <= data_i;\n        2'b11: begin\n          parport_writestrobe_o <= 1;\n        end\n      endcase\n    end else if(readstrobe_i) begin\n      if(address_i == 2'b00) begin\n        inputreg_r <= parport_i[31:8];\n      end\n    end\n  end\n\nendmodule",
        "module_name": "parallel_port",
        "module_hash": "0245a8edd681fc6acf38e61316fd46c6",
        "dataset_index": 8460
      },
      "Reset_Synchronizer_6d5e1d50": {
        "rtl_code": "module Reset_Synchronizer (\n  input rst,\n  input clk,\n  output rst_sync\n);\n\n  reg rst_sync_ff1, rst_sync_ff2;\n\n  always @(posedge clk) begin\n    rst_sync_ff1 <= rst;\n    rst_sync_ff2 <= rst_sync_ff1;\n  end\n\n  assign rst_sync = ~rst_sync_ff2;\n\nendmodule",
        "module_name": "Reset_Synchronizer",
        "module_hash": "6d5e1d501def1b196d8fafec68b95861",
        "dataset_index": 7382
      },
      "sky130_fd_sc_ls__o22ai_e3027578": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o22ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out ;\n    wire nor1_out ;\n    wire or0_out_Y;\n\n    nor nor0 (nor0_out , B1, B2            );\n    nor nor1 (nor1_out , A1, A2            );\n    or  or0  (or0_out_Y, nor1_out, nor0_out);\n    buf buf0 (Y        , or0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o22ai",
        "module_hash": "e302757881ca4761cf8bdb3d15f6d2af",
        "dataset_index": 21838
      },
      "arbiter_for_OUT_rep_87dad47c": {
        "rtl_code": "module    arbiter_for_OUT_rep(clk,\n                               rst,\n                               OUT_rep_rdy,\n                               v_dc_rep,\n                               v_mem_rep,\n                               dc_rep_flit,\n                               mem_rep_flit,\n                               dc_rep_ctrl,\n                               mem_rep_ctrl,\n                               ack_OUT_rep,\n                               ack_dc_rep,\n                               ack_mem_rep,\n                               select  );\ninput                               clk;\ninput                               rst;\ninput                               OUT_rep_rdy;\ninput                               v_dc_rep;\ninput                               v_mem_rep;\ninput     [15:0]                    dc_rep_flit;\ninput     [15:0]                    mem_rep_flit;\ninput     [1:0]                     dc_rep_ctrl;\ninput     [1:0]                     mem_rep_ctrl;\n                               output                               ack_OUT_rep;\noutput                               ack_dc_rep;\noutput                               ack_mem_rep;\noutput    [1:0]                      select; parameter               arbiter_idle=3'b001;\nparameter               dc_uploading=3'b010;\nparameter               mem_uploading=3'b100;\nparameter        nackrep_cmd=5'b10101;\nparameter        SCflurep_cmd=5'b11100;\nreg  [2:0]  nstate;\nreg  [2:0]  state;\nreg         priority1;\nreg         ack_OUT_rep;\nreg         ack_dc_rep;\nreg         ack_mem_rep;\nreg         update_priority;\nreg [1:0]   select;\nalways@(*)\nbegin\n  nstate=state;\n  ack_OUT_rep=1'b0;\n  ack_dc_rep=1'b0;\n  ack_mem_rep=1'b0;\n  update_priority=1'b0;\n  select=2'b00;\n  case(state)\n    arbiter_idle:\n      begin\n        if({v_dc_rep,v_mem_rep}==2'b11)\n          begin\n            update_priority=1'b1;\n            if(priority1)\n              begin\n                nstate=dc_uploading;\n              end\n          else\n              begin\n                nstate=mem_uploading;\n              end\n          end\n      else if({v_dc_rep,v_mem_rep}==2'b01)\n          begin\n            nstate=mem_uploading;\n          end\n      else if({v_dc_rep,v_mem_rep}==2'b10)\n          begin\n            nstate=dc_uploading;\n          end\n      end\n    dc_uploading:\n      begin\n        if(OUT_rep_rdy)\n          begin\n            ack_OUT_rep=1'b1;\n            ack_dc_rep=1'b1;\n\t\t\t\tselect=2'b01;\n            if(dc_rep_ctrl==2'b11||dc_rep_ctrl==2'b01&&(dc_rep_flit[9:5]==SCflurep_cmd||dc_rep_flit[9:5]==nackrep_cmd))\n              begin\n                nstate=arbiter_idle;\n              end\n          end\n      end\n    mem_uploading:\n      begin\n        if(OUT_rep_rdy)\n          begin\n            ack_OUT_rep=1'b1;\n            ack_mem_rep=1'b1;\n\t\t\t\tselect=2'b10;\n            if(mem_rep_ctrl==2'b11||mem_rep_ctrl==2'b01&&(mem_rep_flit[9:5]==SCflurep_cmd||mem_rep_flit[9:5]==nackrep_cmd))\n              begin\n                nstate=arbiter_idle;\n              end\n          end\n      end\n  endcase\nend\n\nalways@(posedge clk)\nbegin\n  if(rst)\n    state<=3'b001;\n  else\n    state<=nstate;\nend\n\nalways@(posedge clk)\nbegin\n  if(rst)\n    priority1<=1'b0;\n  else if(update_priority)\n    priority1<=~priority1;\nend\nendmodule           \n",
        "module_name": "arbiter_for_OUT_rep",
        "module_hash": "87dad47c624e8edfdde273e3fac2c7f4",
        "dataset_index": 23141
      },
      "xor_gate_24febd72": {
        "rtl_code": "module xor_gate(input a, b, output out_assign);\n    assign out_assign = a ^ b;\nendmodule",
        "module_name": "xor_gate",
        "module_hash": "24febd729e67cec89d96fb97c181329c",
        "dataset_index": 17985
      },
      "dual_edge_ff_and_or_barrelshifter_e83ce3f1": {
        "rtl_code": "\nmodule dual_edge_ff_and_or_barrelshifter (\n  input clk,\n  input d,\n  output reg q,\n  input [7:0] in,\n  output [7:0] out,\n  input select\n);\n\n  reg [7:0] constant = 8'b10101010; // Define constant vector\n  reg d_reg;\n  reg [7:0] and_result; // Declare AND result register\n  reg [7:0] or_result; // Declare OR result register\n\n  always @(posedge clk) begin\n    if (d) begin\n      q <= d;\n    end\n  end\n\n  always @(*) begin\n    d_reg = d;\n  end\n\n  always @(*) begin // AND operation\n    and_result = select ? in & constant : in;\n  end\n\n  always @(*) begin // OR operation\n    or_result = select ? in : in | constant;\n  end\n\n  assign out = select ? {and_result[7], and_result[6], and_result[5], and_result[4], and_result[3], and_result[2], and_result[1], and_result[0]} : {or_result[7], or_result[6], or_result[5], or_result[4], or_result[3], or_result[2], or_result[1], or_result[0]};\n  // Barrel shifter\n\nendmodule\nmodule top_module (\n  input clk,\n  input d,\n  output q,\n  input [7:0] in,\n  output [7:0] out,\n  input select\n);\n\n  dual_edge_ff_and_or_barrelshifter module_inst (\n    .clk(clk),\n    .d(d),\n    .q(q),\n    .in(in),\n    .out(out),\n    .select(select)\n  );\n\nendmodule",
        "module_name": "dual_edge_ff_and_or_barrelshifter",
        "module_hash": "e83ce3f1e9ea552d86bbf54238d6303e",
        "dataset_index": 5475
      },
      "multiplier_16bit_94369c31": {
        "rtl_code": "\nmodule multiplier_16bit (\n    input clk,\n    input reset,\n    input [15:0] data_in1,\n    input [15:0] data_in2,\n    input enable_pipeline,\n    output reg [31:0] product_out\n);\n\nreg [15:0] partial_product1;\nreg [15:0] partial_product2;\nreg [31:0] partial_product3;\nreg [31:0] partial_product4;\nreg [31:0] accumulator;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        partial_product1 <= 0;\n        partial_product2 <= 0;\n        partial_product3 <= 0;\n        partial_product4 <= 0;\n        accumulator <= 0;\n        product_out <= 0;\n    end else begin\n        if (enable_pipeline) begin\n            // Pipeline stage 1: Fetch inputs\n            partial_product1 <= data_in1;\n            partial_product2 <= data_in2;\n            \n            // Pipeline stage 2: Partial product generation\n            partial_product3 <= partial_product1 * partial_product2;\n            \n            // Pipeline stage 3: Addition of partial products\n            partial_product4 <= partial_product3 + {16'b0, partial_product3[15:0]};\n            \n            // Pipeline stage 4: Accumulation of partial products\n            accumulator <= accumulator + partial_product4;\n            \n            // Pipeline stage 5: Output\n            product_out <= accumulator;\n        end else begin\n            product_out <= data_in1 * data_in2;\n        end\n    end\nend\n\nendmodule",
        "module_name": "multiplier_16bit",
        "module_hash": "94369c31f4f6ae7742b27dd3ea8dcd22",
        "dataset_index": 17110
      },
      "carry_select_adder #_a3ab73a7": {
        "rtl_code": "\nmodule carry_select_adder #(\n    parameter WIDTH = 100\n) (\n    input [WIDTH-1:0] a, b,\n    input cin,\n    output [WIDTH-1:0] sum,\n    output cout\n);\n    wire [WIDTH-1:0] sum0, sum1;\n    wire cout0, cout1;\n\n    adder adder0(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum0),\n        .cout(cout0)\n    );\n\n    adder adder1(\n        .a(a),\n        .b(b),\n        .cin(1'b1),\n        .sum(sum1),\n        .cout(cout1)\n    );\n\n    assign sum = cin ? sum1 : sum0;\n    assign cout = cin ? cout1 : cout0;\nendmodule\nmodule adder #(\n    parameter WIDTH = 100\n) (\n    input [WIDTH-1:0] a, b,\n    input cin,\n    output [WIDTH-1:0] sum,\n    output cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\nmodule barrel_shifter #(\n    parameter WIDTH = 100\n) (\n    input [WIDTH-1:0] in,\n    input load,\n    input [1:0] ena,\n    output reg [WIDTH-1:0] out\n);\n    always @(*) begin\n        if (load) begin\n            out <= in;\n        end else begin\n            case (ena)\n                2'b00: out <= in;\n                2'b01: out <= {in[WIDTH-2:0], in[WIDTH-1]};\n                2'b10: out <= {in[WIDTH-3:0], in[WIDTH-2:WIDTH-1]};\n                2'b11: out <= {in[WIDTH-4:0], in[WIDTH-3:WIDTH-1]};\n            endcase\n        end\n    end\nendmodule\nmodule top_module (\n    input [99:0] a, b, // 100-bit inputs for the adder\n    input cin, // Carry-in for the adder\n    input load, // Load input for the rotator\n    input [1:0] ena, // Enable input for the rotator\n    output [99:0] sum, // 100-bit sum from the adder\n    output [99:0] q // Rotated output from the rotator\n);\n\n    // Instantiate the adder and rotator modules\n    carry_select_adder adder_inst(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum)\n    );\n\n    barrel_shifter rotator_inst(\n        .in(sum),\n        .load(load),\n        .ena(ena),\n        .out(q)\n    );\nendmodule",
        "module_name": "carry_select_adder #",
        "module_hash": "a3ab73a75c35dadba7661bda122b9811",
        "dataset_index": 10346
      },
      "simple_calculator_9bff420c": {
        "rtl_code": "module simple_calculator(\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput op,\n\toutput reg [3:0] Z\n);\n\n\talways @(*) begin\n\t\tif (op == 0) begin\n\t\t\tZ <= A + B;\n\t\tend else begin\n\t\t\tZ <= A - B;\n\t\tend\n\tend\n\t\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "9bff420c9da3fe0e31c5d1701db7a409",
        "dataset_index": 10429
      },
      "output_select_51eff02b": {
        "rtl_code": "module output_select(\n    input sel,\n    input [7:0] out1,\n    input [7:0] out2,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    if(sel == 0)\n        out = out1;\n    else\n        out = out2;\nend\n\nendmodule",
        "module_name": "output_select",
        "module_hash": "51eff02b81ac43e706091c8020574eed",
        "dataset_index": 1307
      },
      "wasca_nios2_gen2_0_cpu_nios2_oci_td_mode_4588bb8e": {
        "rtl_code": "\nmodule wasca_nios2_gen2_0_cpu_nios2_oci_td_mode (\n    input [8:0] ctrl,\n    output reg [3:0] td_mode\n);\n\n    always @(*) begin\n        case (ctrl)\n            9'b000000000: td_mode = 4'b0000; // No Trace\n            9'b000000001: td_mode = 4'b0001; // Record Load Address\n            9'b000000010: td_mode = 4'b0010; // Record Store Address\n            9'b000000011: td_mode = 4'b0011; // Record Load Data\n            9'b000000100: td_mode = 4'b0100; // Record Store Data\n            default:       td_mode = 4'b0000; // No Trace\n        endcase\n    end\n\nendmodule\n",
        "module_name": "wasca_nios2_gen2_0_cpu_nios2_oci_td_mode",
        "module_hash": "4588bb8e6bab61de806d1f70f4e42da7",
        "dataset_index": 18143
      },
      "hls_macc_HLS_MACC_PERIPH_BUS_s_axi_019baf69": {
        "rtl_code": "\nmodule hls_macc_HLS_MACC_PERIPH_BUS_s_axi\n#(parameter\n    C_S_AXI_ADDR_WIDTH = 6,\n    C_S_AXI_DATA_WIDTH = 32\n)(\n    input  wire                          ACLK,\n    input  wire                          ARESET,\n    input  wire                          ACLK_EN,\n    input  wire [C_S_AXI_ADDR_WIDTH-1:0] AWADDR,\n    input  wire                          AWVALID,\n    output wire                          AWREADY,\n    input  wire [C_S_AXI_DATA_WIDTH-1:0] WDATA,\n    input  wire [C_S_AXI_DATA_WIDTH/8-1:0] WSTRB,\n    input  wire                          WVALID,\n    output wire                          WREADY,\n    output wire [1:0]                    BRESP,\n    output wire                          BVALID,\n    input  wire                          BREADY,\n    input  wire [C_S_AXI_ADDR_WIDTH-1:0] ARADDR,\n    input  wire                          ARVALID,\n    output wire                          ARREADY,\n    output wire [C_S_AXI_DATA_WIDTH-1:0] RDATA,\n    output wire [1:0]                    RRESP,\n    output wire                          RVALID,\n    input  wire                          RREADY,\n    output wire                          interrupt,\n    output wire                          ap_start,\n    input  wire                          ap_done,\n    input  wire                          ap_ready,\n    input  wire                          ap_idle,\n    output wire [31:0]                   a,\n    output wire [31:0]                   b,\n    input  wire [31:0]                   accum,\n    input  wire                          accum_ap_vld,\n    output wire [0:0]                    accum_clr\n);\nlocalparam\n    ADDR_AP_CTRL          = 6'h00,\n    ADDR_GIE              = 6'h04,\n    ADDR_IER              = 6'h08,\n    ADDR_ISR              = 6'h0c,\n    ADDR_A_DATA_0         = 6'h10,\n    ADDR_A_CTRL           = 6'h14,\n    ADDR_B_DATA_0         = 6'h18,\n    ADDR_B_CTRL           = 6'h1c,\n    ADDR_ACCUM_DATA_0     = 6'h20,\n    ADDR_ACCUM_CTRL       = 6'h24,\n    ADDR_ACCUM_CLR_DATA_0 = 6'h28,\n    ADDR_ACCUM_CLR_CTRL   = 6'h2c,\n    WRIDLE                = 2'd0,\n    WRDATA                = 2'd1,\n    WRRESP                = 2'd2,\n    WRRESET               = 2'd3,\n    RDIDLE                = 2'd0,\n    RDDATA                = 2'd1,\n    RDRESET               = 2'd2,\n    ADDR_BITS         = 6;\n\nreg  [1:0]                    wstate = WRRESET;\n    reg  [1:0]                    wnext;\n    reg  [ADDR_BITS-1:0]          waddr;\n    wire [31:0]                   wmask;\n    wire                          aw_hs;\n    wire                          w_hs;\n    reg  [1:0]                    rstate = RDRESET;\n    reg  [1:0]                    rnext;\n    reg  [31:0]                   rdata;\n    wire                          ar_hs;\n    wire [ADDR_BITS-1:0]          raddr;\n    reg                           int_ap_idle;\n    reg                           int_ap_ready;\n    reg                           int_ap_done = 1'b0;\n    reg                           int_ap_start = 1'b0;\n    reg                           int_auto_restart = 1'b0;\n    reg                           int_gie = 1'b0;\n    reg  [1:0]                    int_ier = 2'b0;\n    reg  [1:0]                    int_isr = 2'b0;\n    reg  [31:0]                   int_a = 'b0;\n    reg  [31:0]                   int_b = 'b0;\n    reg  [31:0]                   int_accum = 'b0;\n    reg                           int_accum_ap_vld;\n    reg  [0:0]                    int_accum_clr = 'b0;\n\nassign AWREADY = (wstate == WRIDLE);\nassign WREADY  = (wstate == WRDATA);\nassign BRESP   = 2'b00;  assign BVALID  = (wstate == WRRESP);\nassign wmask   = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} };\nassign aw_hs   = AWVALID & AWREADY;\nassign w_hs    = WVALID & WREADY;\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        wstate <= WRRESET;\n    else if (ACLK_EN)\n        wstate <= wnext;\nend\n\nalways @(*) begin\n    case (wstate)\n        WRIDLE:\n            if (AWVALID)\n                wnext = WRDATA;\n            else\n                wnext = WRIDLE;\n        WRDATA:\n            if (WVALID)\n                wnext = WRRESP;\n            else\n                wnext = WRDATA;\n        WRRESP:\n            if (BREADY)\n                wnext = WRIDLE;\n            else\n                wnext = WRRESP;\n        default:\n            wnext = WRIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (aw_hs)\n            waddr <= AWADDR[ADDR_BITS-1:0];\n    end\nend\n\nassign ARREADY = (rstate == RDIDLE);\nassign RDATA   = rdata;\nassign RRESP   = 2'b00;  assign RVALID  = (rstate == RDDATA);\nassign ar_hs   = ARVALID & ARREADY;\nassign raddr   = ARADDR[ADDR_BITS-1:0];\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        rstate <= RDRESET;\n    else if (ACLK_EN)\n        rstate <= rnext;\nend\n\nalways @(*) begin\n    case (rstate)\n        RDIDLE:\n            if (ARVALID)\n                rnext = RDDATA;\n            else\n                rnext = RDIDLE;\n        RDDATA:\n            if (RREADY & RVALID)\n                rnext = RDIDLE;\n            else\n                rnext = RDDATA;\n        default:\n            rnext = RDIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ar_hs) begin\n            rdata <= 1'b0;\n            case (raddr)\n                ADDR_AP_CTRL: begin\n                    rdata[0] <= int_ap_start;\n                    rdata[1] <= int_ap_done;\n                    rdata[2] <= int_ap_idle;\n                    rdata[3] <= int_ap_ready;\n                    rdata[7] <= int_auto_restart;\n                end\n                ADDR_GIE: begin\n                    rdata <= int_gie;\n                end\n                ADDR_IER: begin\n                    rdata <= int_ier;\n                end\n                ADDR_ISR: begin\n                    rdata <= int_isr;\n                end\n                ADDR_A_DATA_0: begin\n                    rdata <= int_a[31:0];\n                end\n                ADDR_B_DATA_0: begin\n                    rdata <= int_b[31:0];\n                end\n                ADDR_ACCUM_DATA_0: begin\n                    rdata <= int_accum[31:0];\n                end\n                ADDR_ACCUM_CTRL: begin\n                    rdata[0] <= int_accum_ap_vld;\n                end\n                ADDR_ACCUM_CLR_DATA_0: begin\n                    rdata <= int_accum_clr[0:0];\n                end\n            endcase\n        end\n    end\nend\n\n\nassign interrupt = int_gie & (|int_isr);\nassign ap_start  = int_ap_start;\nassign a         = int_a;\nassign b         = int_b;\nassign accum_clr = int_accum_clr;\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_start <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0])\n            int_ap_start <= 1'b1;\n        else if (ap_ready)\n            int_ap_start <= int_auto_restart; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_done <= 1'b0;\n    else if (ACLK_EN) begin\n        if (ap_done)\n            int_ap_done <= 1'b1;\n        else if (ar_hs && raddr == ADDR_AP_CTRL)\n            int_ap_done <= 1'b0; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_idle <= 1'b0;\n    else if (ACLK_EN) begin\n            int_ap_idle <= ap_idle;\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_ready <= 1'b0;\n    else if (ACLK_EN) begin\n            int_ap_ready <= ap_ready;\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_auto_restart <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0])\n            int_auto_restart <=  WDATA[7];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_gie <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_GIE && WSTRB[0])\n            int_gie <= WDATA[0];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ier <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_IER && WSTRB[0])\n            int_ier <= WDATA[1:0];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_isr[0] <= 1'b0;\n    else if (ACLK_EN) begin\n        if (int_ier[0] & ap_done)\n            int_isr[0] <= 1'b1;\n        else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n            int_isr[0] <= int_isr[0] ^ WDATA[0]; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_isr[1] <= 1'b0;\n    else if (ACLK_EN) begin\n        if (int_ier[1] & ap_ready)\n            int_isr[1] <= 1'b1;\n        else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n            int_isr[1] <= int_isr[1] ^ WDATA[1]; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_a[31:0] <= 0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_A_DATA_0)\n            int_a[31:0] <= (WDATA[31:0] & wmask) | (int_a[31:0] & ~wmask);\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_b[31:0] <= 0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_B_DATA_0)\n            int_b[31:0] <= (WDATA[31:0] & wmask) | (int_b[31:0] & ~wmask);\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_accum <= 0;\n    else if (ACLK_EN) begin\n        if (accum_ap_vld)\n            int_accum <= accum;\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_accum_ap_vld <= 1'b0;\n    else if (ACLK_EN) begin\n        if (accum_ap_vld)\n            int_accum_ap_vld <= 1'b1;\n        else if (ar_hs && raddr == ADDR_ACCUM_CTRL)\n            int_accum_ap_vld <= 1'b0; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_accum_clr[0:0] <= 0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_ACCUM_CLR_DATA_0)\n            int_accum_clr[0:0] <= (WDATA[31:0] & wmask) | (int_accum_clr[0:0] & ~wmask);\n    end\nend\n\n\nendmodule\n",
        "module_name": "hls_macc_HLS_MACC_PERIPH_BUS_s_axi",
        "module_hash": "019baf69d56dba4f3e470deb9a91eb36",
        "dataset_index": 25176
      },
      "shifter_adder_10824282": {
        "rtl_code": "module shifter_adder (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input load,\n    input [1:0] ena,\n    input [15:0] in,\n    input select,\n    output [15:0] q\n);\n\n    reg [99:0] shift_reg;\n    reg [15:0] adder_out;\n    reg [15:0] shift_out;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 100'b0;\n            adder_out <= 16'b0;\n            shift_out <= 16'b0;\n        end else begin\n            if (load) begin\n                shift_reg <= in;\n            end else begin\n                if (ena == 2'b00) begin\n                    shift_reg <= {shift_reg[98:0], shift_reg[99]};\n                end else if (ena == 2'b01) begin\n                    shift_reg <= {shift_reg[0], shift_reg[99:1]};\n                end\n            end\n            if (select) begin\n                adder_out <= in + 16'b0000000000010000;\n            end else begin\n                shift_out <= shift_reg[99:84];\n            end\n        end\n    end\n\n    assign q = select ? adder_out : shift_out;\n\nendmodule",
        "module_name": "shifter_adder",
        "module_hash": "10824282ca206168ad85ea75394f3659",
        "dataset_index": 12126
      },
      "nios_system_switches_dfc385ce": {
        "rtl_code": "module nios_system_switches (\n  input [1:0] address,\n  input clk,\n  input [7:0] in_port,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  wire [7:0] data_in;\n  wire [7:0] read_mux_out;\n  wire clk_en;\n\n  assign data_in = in_port;\n\n  assign read_mux_out = {8 {(address == 2'b00)}} & data_in | \n                       {8 {(address == 2'b01)}} & {1'b0, data_in[7:1]} | \n                       {8 {(address == 2'b10)}} & {2'b00, data_in[7:2]} | \n                       {8 {(address == 2'b11)}} & data_in;\n\n  assign clk_en = 1;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      readdata <= 0;\n    end else if (clk_en) begin\n      readdata <= {32'b0, read_mux_out};\n    end\n  end\n\nendmodule",
        "module_name": "nios_system_switches",
        "module_hash": "dfc385ced723f56b8eb96597a332afe4",
        "dataset_index": 4807
      },
      "Control_bc113979": {
        "rtl_code": "\nmodule Control(\n   \n\tinput wire clk,rst,\n\tinput [7:0] in3,in2,in1,in0,\n\toutput reg [3:0] anodo,\n\toutput reg [7:0] catodo\n    );\n\t \n\tlocalparam N = 18;\n\treg [N-1:0] q_reg;\n\twire [N-1:0] q_next;\n\t\n\talways @(posedge clk, posedge rst)\n\t   if (rst)\n\t    q_reg  <= 0;\n\t   else \n\t    q_reg <= q_next;\n\tassign q_next = q_reg + 1;\n\t\t\n\talways @(*)\n\tcase (q_reg[N-1:N-2])\n\t   2'b00: \n\t\t   begin\n\t\t\t  anodo <= 4'b1110;\n\t\t\t  catodo <= in0;\n\t\t\tend \n\t   2'b01: \n\t\t   begin\n\t\t\t  anodo <= 4'b1101;\n\t\t\t  catodo <= in1;\n\t\t\tend \n\t\t2'b10: \n\t\t   begin\n\t\t\t  anodo <= 4'b1011;\n\t\t\t  catodo <= in2;\n\t\t\tend \n\t\tdefault: \n\t\t   begin\n\t\t\t  anodo <= 4'b0111;\n\t\t\t  catodo <= in3;\n\t\t\tend \n\tendcase\n\n\n\nendmodule\n",
        "module_name": "Control",
        "module_hash": "bc1139793d7519f5f2f2eaa9c4830c26",
        "dataset_index": 22194
      },
      "mux2to1_083ecbb5": {
        "rtl_code": "module mux2to1(input a, input b, input s, output reg out);\n\nalways @(*) begin\n    if (s == 0) begin\n        out = a;\n    end else begin\n        out = b;\n    end\nend\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "083ecbb5e64f988fe3e2f19135a31bcd",
        "dataset_index": 8944
      },
      "carry_lookahead_gen_69932ac3": {
        "rtl_code": "module carry_lookahead_gen \n    (\n        input   wire[3:0]   g,\n        input   wire[3:0]   p,\n        input   wire        cin,\n        output  wire[3:0]   cout\n        );\n\n    wire    and_out_1;\n    wire    and_out_2;\n    wire    and_out_3;\n    wire    and_out_4;\n    wire    and_out_5;\n    wire    and_out_6;\n    wire    or_out_1;\n    wire    or_out_2;\n    wire    or_out_3;\n    assign  cout = {or_out_3, or_out_2, or_out_1, cin};\n    and     A1 (and_out_1, p[0], cin);\n    or      O1 (or_out_1, g[0], and_out_1);\n\n    and     A2 (and_out_2, p[1], g[0]);\n    and     A3 (and_out_3, p[1], p[0], cin);\n    or      O2 (or_out_2, g[1], and_out_3, and_out_2);\n\n    and     A4 (and_out_4, p[2], g[1]);\n    and     A5 (and_out_5, p[2], p[1], g[0]);\n    and     A6 (and_out_6, p[2], p[1], p[0], cin);\n    or      O3 (or_out_3, g[2], and_out_6, and_out_5, and_out_4);\n\n    endmodule\n",
        "module_name": "carry_lookahead_gen",
        "module_hash": "69932ac3aef88edb65d33dfdcafd2fa2",
        "dataset_index": 24687
      },
      "Multiplexer #_e9a6180e": {
        "rtl_code": "module Multiplexer #(parameter WIDTH = 1)\n  (input ctrl,\n   input [WIDTH-1:0] D0,\n   input [WIDTH-1:0] D1,\n   output [WIDTH-1:0] S);\n\n  assign S = (ctrl == 1'b0) ? D0 : D1;\n\nendmodule",
        "module_name": "Multiplexer #",
        "module_hash": "e9a6180e146310cd50e36c2cd8c26491",
        "dataset_index": 775
      },
      "bit_capture_data_aa49d3ed": {
        "rtl_code": "module bit_capture_data(\n\t\t\tinput negedge_clk,\n\t\t\tinput posedge_clk,\n\t\t\tinput rx_resetn,\n\t\t\t\n\t\t\tinput rx_din,\n\t\t\t\n\t\t\toutput reg bit_d_0,//N\n\t\t\toutput reg bit_d_1,//P\n\t\t\toutput reg bit_d_2,//N\n\t\t\toutput reg bit_d_3,//P\n\t\t\toutput reg bit_d_4,//N\n\t\t\toutput reg bit_d_5,//P\n\t\t\toutput reg bit_d_6,//N\n\t\t\toutput reg bit_d_7,//P\n\t\t\toutput reg bit_d_8,//N\n\t\t\toutput reg bit_d_9//P\n\t\t  );\n\n\nalways@(posedge posedge_clk or negedge rx_resetn)\nbegin\n\n\tif(!rx_resetn)\n\tbegin\n\t\tbit_d_1  <= 1'b0;\n\t\tbit_d_3  <= 1'b0;\n\t\tbit_d_5  <= 1'b0;\n\t\tbit_d_7  <= 1'b0;\n\t\tbit_d_9  <= 1'b0;\n\tend\n\telse\n\tbegin\n\t\tbit_d_1  <= rx_din;\n\t\tbit_d_3  <= bit_d_1;\n\t\tbit_d_5  <= bit_d_3;\n\t\tbit_d_7  <= bit_d_5;\n\t\tbit_d_9  <= bit_d_7;\n\tend\n\nend\n\nalways@(posedge negedge_clk or negedge rx_resetn)\nbegin\n\n\tif(!rx_resetn)\n\tbegin\n\t\tbit_d_0 <= 1'b0;\n\t\tbit_d_2 <= 1'b0;\n\t\tbit_d_4 <= 1'b0;\n\t\tbit_d_6 <= 1'b0;\n\t\tbit_d_8 <= 1'b0;\n\n\tend\n\telse\n\tbegin\n\t\tbit_d_0 <= rx_din;\n\t\tbit_d_2 <= bit_d_0;\n\t\tbit_d_4 <= bit_d_2;\n\t\tbit_d_6 <= bit_d_4;\n\t\tbit_d_8 <= bit_d_6;\n\tend\nend\n\nendmodule",
        "module_name": "bit_capture_data",
        "module_hash": "aa49d3ed3edb120e2b90a0ab3d9919a9",
        "dataset_index": 5084
      },
      "simple_arithmetic_4567f647": {
        "rtl_code": "module simple_arithmetic (\n    input [7:0] A,\n    input [7:0] B,\n    input [1:0] op,\n    output [7:0] out\n);\n\n    wire [7:0] add_out = A + B;\n    wire [7:0] sub_out = A - B;\n    wire [7:0] and_out = A & B;\n    wire [7:0] or_out = A | B;\n\n    assign out = (op == 2'b00) ? add_out :\n                 (op == 2'b01) ? sub_out :\n                 (op == 2'b10) ? and_out :\n                                 or_out;\n\nendmodule",
        "module_name": "simple_arithmetic",
        "module_hash": "4567f647902e960dcd203e03d47bf094",
        "dataset_index": 10041
      },
      "lcd_driver #_9cba8971": {
        "rtl_code": "module lcd_driver #(\n  parameter n = 8, // number of data signals\n  parameter m = 16 // number of output signals (for a 16x2 LCD display)\n) (\n  input [n-1:0] data,\n  input clk,\n  input rst,\n  output reg [m-1:0] out\n);\n\n\n// Define ASCII code for characters and numbers\nparameter ASCII_A = 8'h41;\nparameter ASCII_0 = 8'h30;\n\n// Define commands for the LCD panel\nparameter CMD_CLEAR_DISPLAY = 4'b0001;\nparameter CMD_RETURN_HOME = 4'b0010;\nparameter CMD_ENTRY_MODE_SET = 4'b0110;\nparameter CMD_DISPLAY_ON_OFF_CONTROL = 4'b1000;\nparameter CMD_FUNCTION_SET = 4'b0010;\n\n// Define internal signals\nreg [3:0] data_bus;\nreg [3:0] cmd_bus;\nreg [3:0] lcd_state;\nreg [3:0] lcd_row;\nreg [3:0] lcd_col;\n\n// Define state machine states\nparameter STATE_INIT = 4'b0000;\nparameter STATE_CLEAR_DISPLAY = 4'b0001;\nparameter STATE_RETURN_HOME = 4'b0010;\nparameter STATE_ENTRY_MODE_SET = 4'b0011;\nparameter STATE_DISPLAY_ON_OFF_CONTROL = 4'b0100;\nparameter STATE_FUNCTION_SET = 4'b0101;\nparameter STATE_WRITE_DATA = 4'b0110;\nparameter STATE_WRITE_COMMAND = 4'b0111;\n\n// Define state machine transitions\nalways @(posedge clk) begin\n  if (rst) begin\n    lcd_state <= STATE_INIT;\n    lcd_row <= 4'b0000;\n    lcd_col <= 4'b0000;\n  end else begin\n    case (lcd_state)\n      STATE_INIT: begin\n        cmd_bus <= CMD_FUNCTION_SET;\n        lcd_state <= STATE_FUNCTION_SET;\n      end\n      STATE_CLEAR_DISPLAY: begin\n        cmd_bus <= CMD_CLEAR_DISPLAY;\n        lcd_state <= STATE_FUNCTION_SET;\n      end\n      STATE_RETURN_HOME: begin\n        cmd_bus <= CMD_RETURN_HOME;\n        lcd_state <= STATE_FUNCTION_SET;\n      end\n      STATE_ENTRY_MODE_SET: begin\n        cmd_bus <= CMD_ENTRY_MODE_SET;\n        lcd_state <= STATE_FUNCTION_SET;\n      end\n      STATE_DISPLAY_ON_OFF_CONTROL: begin\n        cmd_bus <= CMD_DISPLAY_ON_OFF_CONTROL;\n        lcd_state <= STATE_FUNCTION_SET;\n      end\n      STATE_FUNCTION_SET: begin\n        cmd_bus <= CMD_FUNCTION_SET;\n        lcd_state <= STATE_WRITE_COMMAND;\n      end\n      STATE_WRITE_DATA: begin\n        data_bus <= data[7:4];\n        lcd_state <= STATE_WRITE_COMMAND;\n      end\n      STATE_WRITE_COMMAND: begin\n        out <= {cmd_bus, data_bus}; // Fix the syntax error here\n        lcd_col <= lcd_col + 1;\n        if (lcd_col == 4'b0100) begin\n          lcd_col <= 4'b0000;\n          lcd_row <= lcd_row + 1;\n          if (lcd_row == 4'b0010) begin\n            lcd_row <= 4'b0000;\n          end\n        end\n        if (lcd_row == 4'b0000 && lcd_col == 4'b0000) begin\n          lcd_state <= STATE_CLEAR_DISPLAY;\n        end else begin\n          lcd_state <= STATE_WRITE_DATA;\n        end\n      end\n    endcase\n  end\nend\n\nendmodule",
        "module_name": "lcd_driver #",
        "module_hash": "9cba8971e3ab77560a4a910d986a1bf4",
        "dataset_index": 3075
      },
      "twos_complement_fdb63d63": {
        "rtl_code": "\nmodule twos_complement (\n    input [3:0] in,\n    output reg [4:0] out\n);\n\nreg [3:0] in_reg;\nreg [3:0] neg_in_reg;\n\nalways @(in) begin\n    in_reg = in;\n    neg_in_reg = ~in_reg + 1'b1;\nend\n\nalways @(*) begin\n    if (in_reg[3]) begin\n        out = {1'b1, ~in_reg + 1'b1};\n    end else begin\n        out = {1'b0, in_reg};\n    end\nend\n\nendmodule\n",
        "module_name": "twos_complement",
        "module_hash": "fdb63d63ce4656d9c02305979f6de479",
        "dataset_index": 19651
      },
      "lo_reg_18ef3e62": {
        "rtl_code": "module lo_reg(clk,resetn,d,en,q);\n\ninput clk;          // clock input\ninput resetn;       // reset input\ninput en;           // enable input\ninput [31:0] d;     // data input\noutput [31:0] q;    // output\n\nreg [31:0] q;       // register to store output\n\nalways @(posedge clk) begin\n    if (resetn == 0) begin\n        q <= 0;        // clear output if reset is low\n    end\n    else if (en == 1) begin\n        q <= d;        // update output if enable is high\n    end\nend\n\nendmodule",
        "module_name": "lo_reg",
        "module_hash": "18ef3e62dd05be85719baeb0f60519f9",
        "dataset_index": 4717
      },
      "dff_sr_f8b88607": {
        "rtl_code": "module dff_sr (\n    Q,\n    Q_N,\n    D,\n    CLK,\n    SET_B,\n    RESET_B\n);\n\n    output Q;\n    output Q_N;\n    input  D;\n    input  CLK;\n    input  SET_B;\n    input  RESET_B;\n\n    reg Q;\n\n    assign Q_N = ~Q;\n\n    always @ (posedge CLK) begin\n        if (!SET_B && !RESET_B) begin\n            Q <= D;\n        end else if (!SET_B) begin\n            Q <= 1'b1;\n        end else if (!RESET_B) begin\n            Q <= 1'b0;\n        end\n    end\n\nendmodule",
        "module_name": "dff_sr",
        "module_hash": "f8b88607b3198d24c6e113874c670877",
        "dataset_index": 2694
      },
      "FpuFp64FromInt_afe99bbc": {
        "rtl_code": "module FpuFp64FromInt(\n\tclk,\n\tenable,\n\tis32,\n\tsrc,\n\tdst\n);\n\ninput\t\t\tclk;\ninput\t\t\tenable;\ninput\t\t\tis32;\n\ninput[63:0]\t\tsrc;\noutput[63:0]\tdst;\n\nreg\t\tsgn;\nreg\t\tsgnc;\n\nreg[12:0] exa;\nreg[12:0] exb;\nreg[12:0] exc;\nreg[12:0] exm;\n\nreg[63:0] tFracA;\nreg[63:0] tFracB;\nreg[63:0] tFracC;\nreg[63:0] tFracA1;\nreg[63:0] tFracB1;\nreg[63:0] tFracC1;\n\nreg[63:0] tFracC2;\n\nreg[63:0] tFracC2_A;\treg[63:0] tFracC2_B;\treg[63:0] tFracC2_C;\treg[63:0] tFracC2_D;\treg[63:0] tFracC2_E;\treg[12:0] tExc_A;\nreg[12:0] tExc_B;\nreg[12:0] tExc_C;\nreg[12:0] tExc_D;\nreg[12:0] tExc_E;\n\nreg[63:0] tDst;\n\nassign dst = tDst;\n\nalways @ (clk && enable)\nbegin\n\tsgnc = 0;\n\n\tif(is32)\n\tbegin\n\t\tif(src[31])\n\t\tbegin\n\t\t\tsgn = 1;\n\t\t\ttFracC2[63:32] = 0;\n\t\t\ttFracC2[31:0] = ~(src[31:0]);\n\t\t\texm = 1023 + 52;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tsgn = 0;\n\t\t\ttFracC2[63:32] = 0;\n\t\t\ttFracC2[31:0] = src[31:0];\n\t\t\texm = 1023 + 52;\n\t\tend\n\tend\n\telse\n\tbegin\n\t\tif(src[63])\n\t\tbegin\n\t\t\tsgn = 1;\n\t\t\ttFracC2[63:0] = ~(src[63:0]);\n\t\t\texm = 1023 + 52;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tsgn = 0;\n\t\t\ttFracC2[63:0] = src[63:0];\n\t\t\texm = 1023 + 52;\n\t\tend\n\tend\n\n\tif(tFracC2[52:0]==0)\n\tbegin\n\t\tsgnc=0;\n\t\ttFracC=0;\n\t\texc=0;\n\tend\n\telse\n\t\tif(tFracC2[63:52]==0)\n\tbegin\n\n\t\tif(tFracC2[52:21]==0)\n\t\tbegin\n\t\t\ttFracC2_A=tFracC2<<32;\n\t\t\ttExc_A=exm-32;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_A=tFracC2;\n\t\t\ttExc_A=exm;\n\t\tend\n\n\t\tif(tFracC2_A[52:37]==0)\n\t\tbegin\n\t\t\ttFracC2_B=tFracC2_A<<16;\n\t\t\ttExc_B=tExc_A-16;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_B=tFracC2_A;\n\t\t\ttExc_B=tExc_A;\n\t\tend\n\n\t\tif(tFracC2_B[52:45]==0)\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B<<8;\n\t\t\ttExc_C=tExc_B-8;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B;\n\t\t\ttExc_C=tExc_B;\n\t\tend\n\t\t\n\t\tif(tFracC2_C[52:49]==0)\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C<<4;\n\t\t\ttExc_D=tExc_C-4;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C;\n\t\t\ttExc_D=tExc_C;\n\t\tend\n\t\t\n\t\tif(tFracC2_D[52:51]==0)\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D<<2;\n\t\t\ttExc_E=tExc_D-2;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D;\n\t\t\ttExc_E=tExc_D;\n\t\tend\n\n\t\tif(tFracC2_E[52]==0)\n\t\tbegin\n\t\t\ttFracC=tFracC2_E<<1;\n\t\t\texc=tExc_E-1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC=tFracC2_E;\n\t\t\texc=tExc_E;\n\t\tend\n\tend\n\telse\n\tbegin\n\t\ttFracC2_B=tFracC2;\n\t\ttExc_B=exm;\n\n\t\tif(tFracC2_B[63:60]!=0)\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B>>8;\n\t\t\ttExc_C=tExc_B+8;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B;\n\t\t\ttExc_C=tExc_B;\n\t\tend\n\t\t\n\t\tif(tFracC2_C[59:56]!=0)\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C>>4;\n\t\t\ttExc_D=tExc_C+4;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C;\n\t\t\ttExc_D=tExc_C;\n\t\tend\n\t\t\n\t\tif(tFracC2_D[55:54]==0)\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D>>2;\n\t\t\ttExc_E=tExc_D+2;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D;\n\t\t\ttExc_E=tExc_D;\n\t\tend\n\n\t\tif(tFracC2_E[53])\n\t\tbegin\n\t\t\ttFracC=tFracC2_E>>1;\n\t\t\texc=tExc_E+1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC=tFracC2_E;\n\t\t\texc=tExc_E;\n\t\tend\n\tend\n\t\n\tif(exc[12])\n\tbegin\n\t\ttDst[63:0]=64'h0;\n\tend\n\telse if(exc[11])\n\tbegin\n\t\ttDst[63]=sgnc;\n\t\ttDst[62:0]=63'h7FF0_0000_0000_0000;\n\tend\n\telse\n\tbegin\n\t\ttDst[63]=sgnc;\n\t\ttDst[62:52]=exc[10:0];\n\t\ttDst[51:0]=tFracC[51:0];\n\tend\n\t\nend\n\nalways @ (posedge clk)\nbegin\nend\n\nendmodule\n",
        "module_name": "FpuFp64FromInt",
        "module_hash": "afe99bbced5b863b24e8f1078cc10b75",
        "dataset_index": 25273
      },
      "dm_bcb190d4": {
        "rtl_code": "\n\n`ifndef _dm\n `define _dm\n\nmodule dm(\n          input wire \t     clk,\n\t  input wire \t     rst,\n          input wire [6:0]   waddr,\n\t  input wire [6:0]   raddr,\n          input wire \t     wr,\n          input wire [31:0]  wdata,\n          output wire [31:0] rdata);\n   \n   reg [31:0] \t\t     mem [0:127];  integer \t\t     i;\n   \n   \n   always @(posedge clk, negedge rst) begin\n      if (!rst) begin\n\t for (i = 0; i < 128; i=i+1) begin\n\t    mem[i] <= 32'h0000;\n\t end\n\t #1 mem[20] <= 32'd10;\n\t mem[21] <= 32'h3;\n      end\n      else if (wr) begin\n         mem[waddr] <= wdata;\n      end\n   end\n\n   assign rdata = mem[raddr][31:0];\n   endmodule\n\n`endif\n",
        "module_name": "dm",
        "module_hash": "bcb190d4e371ce28c0ea94d226c89be9",
        "dataset_index": 23300
      },
      "mux_2to1_aa542977": {
        "rtl_code": "module mux_2to1 (MO, A, B, S);\n   input [15:0] A, B;\n   input \tS;\n   output [15:0] MO; \n   \n   assign MO = (S == 1) ? B : A; \n   \nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "aa5429776777d134b8d41c1c220028b7",
        "dataset_index": 10022
      },
      "dff_with_reset_f73dd42e": {
        "rtl_code": "module dff_with_reset (\n    input D,\n    input CLK,\n    input RST,\n    output reg Q\n);\n\n    always @(posedge CLK, posedge RST)\n    begin\n        if (RST) // asynchronous reset\n            Q <= 0;\n        else // clocked behavior\n            Q <= D;\n    end\n\nendmodule",
        "module_name": "dff_with_reset",
        "module_hash": "f73dd42ed6a5833b608f8bc08a419857",
        "dataset_index": 3234
      },
      "four_bit_adder_c738f225": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] temp_sum;\n    wire [3:0] temp_carry;\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[2:0];\n    assign Cout = temp_sum[3] | (temp_sum[2] & (temp_sum[1] | temp_sum[0]));\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "c738f2257f841793177762b8caf89907",
        "dataset_index": 18625
      },
      "glitch_filter_3806be45": {
        "rtl_code": "\nmodule glitch_filter (\n  input in,\n  input clk, // clock signal\n  output out\n);\n\nparameter n = 4; // number of clock cycles to filter out glitches\n\nreg [n-1:0] shift_reg; // shift register with n stages\nreg temp_out;\n\nalways @(posedge clk) begin\n  // shift the values in the shift register\n  shift_reg <= {shift_reg[n-2:0], in};\n  \n  // compare the values in the shift register\n  if (shift_reg[0] != shift_reg[n-1] || shift_reg[0] != shift_reg[n-2] || shift_reg[0] != shift_reg[n-3]) begin\n    // ignore the glitch\n    temp_out <= 0;\n  end else begin\n    // output the filtered signal\n    temp_out <= shift_reg[n-1];\n  end\nend\n\nassign out = temp_out; \n\nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "3806be45c64c370f2da041e894afeeb2",
        "dataset_index": 13743
      },
      "full_adder_2bit_0202592c": {
        "rtl_code": "\nmodule full_adder_2bit(\n    input [1:0] A,\n    input [1:0] B,\n    input Cin,\n    output [1:0] S,\n    output Cout\n);\n\nwire CO1, CO2;\n\nHAHD2X HA1(A[0], B[0], CO1, S[0]);\nHAHD2X HA2(A[1], B[1], CO2, S[1]);\n\nassign Cout = CO1 | CO2 | Cin; // Fix: Assign Cout directly\n\nendmodule\nmodule HAHD2X(\n    input A,\n    input B,\n    output CO,\n    output S\n);\n\nxor gate1(S, A, B);\nand gate2(CO, A, B);\n\nendmodule\nmodule or_gate(\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\nassign Y = A | B | C;\n\nendmodule",
        "module_name": "full_adder_2bit",
        "module_hash": "0202592cf0e05a0cc5a0829ac2eb6d61",
        "dataset_index": 2388
      },
      "mux_2to1_281950e6": {
        "rtl_code": "module mux_2to1(\n    input a,\n    input b,\n    input sel,\n    output y\n    );\n    \n    assign y = (!sel & a) | (sel & b);\n    \nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "281950e6b1abadfd8b5dffac80fc1ba7",
        "dataset_index": 3954
      },
      "time_compare_a0a5f614": {
        "rtl_code": "module time_compare\n  (input [63:0] time_now,\n   input [63:0] trigger_time,\n   output now,\n   output early,\n   output late,\n   output too_early);\n\n    assign now = time_now == trigger_time;\n    assign late = time_now > trigger_time;\n    assign early = ~now & ~late;\n    assign too_early = 0; endmodule ",
        "module_name": "time_compare",
        "module_hash": "a0a5f61492102ca4791b9972f8401c1c",
        "dataset_index": 24190
      },
      "and_using_nand_04cceeba": {
        "rtl_code": "\nmodule and_using_nand (\ninput [1:0] a_b,\noutput wire out\n);\n\nnand n1 (out, ~a_b[0], ~a_b[1]);\n\nendmodule\nmodule dff_with_reset (\ninput clk,\ninput reset,\ninput d,\noutput reg q\n);\nalways @(posedge clk) begin\nif (reset) begin\nq <= 1'b0;\nend else begin\nq <= d;\nend\nend\nendmodule\nmodule functional_module (\ninput and_out,\ninput dff_out,\noutput reg q\n);\nalways @(posedge and_out) begin\nif (and_out && (dff_out == 1'b1)) begin\nq <= 1'b1;\nend else begin\nq <= 1'b0;\nend\nend\nendmodule\nmodule top_module (\ninput clk,\ninput reset,\ninput [1:0] a_b,\ninput d,\noutput q\n);\nwire and_out;\nwire dff_out;\n\nand_using_nand and_gate (\n.a_b(a_b),\n.out(and_out)\n);\n\ndff_with_reset dff (\n.clk(clk),\n.reset(reset),\n.d(d),\n.q(dff_out)\n);\n\nfunctional_module func_mod (\n.and_out(and_out),\n.dff_out(dff_out),\n.q(q)\n);\n\nendmodule",
        "module_name": "and_using_nand",
        "module_hash": "04cceebacd290fef233cfc4f67cdb719",
        "dataset_index": 14803
      },
      "decoder_5bit_16cb2a1b": {
        "rtl_code": "module decoder_5bit(\n    input [4:0] in, // 5-bit input\n    output reg [31:0] out // 32-bit output\n);\n\nalways @(*) begin\n    case (in)\n        5'b00000: out = 32'b00000000000000000000000000000001;\n        5'b00001: out = 32'b00000000000000000000000000000010;\n        5'b00010: out = 32'b00000000000000000000000000000100;\n        5'b00011: out = 32'b00000000000000000000000000001000;\n        5'b00100: out = 32'b00000000000000000000000000010000;\n        5'b00101: out = 32'b00000000000000000000000000100000;\n        5'b00110: out = 32'b00000000000000000000000001000000;\n        5'b00111: out = 32'b00000000000000000000000010000000;\n        5'b01000: out = 32'b00000000000000000000000100000000;\n        5'b01001: out = 32'b00000000000000000000001000000000;\n        5'b01010: out = 32'b00000000000000000000010000000000;\n        5'b01011: out = 32'b00000000000000000000100000000000;\n        5'b01100: out = 32'b00000000000000000001000000000000;\n        5'b01101: out = 32'b00000000000000000010000000000000;\n        5'b01110: out = 32'b00000000000000000100000000000000;\n        5'b01111: out = 32'b00000000000000001000000000000000;\n        5'b10000: out = 32'b00000000000000010000000000000000;\n        5'b10001: out = 32'b00000000000000100000000000000000;\n        5'b10010: out = 32'b00000000000001000000000000000000;\n        5'b10011: out = 32'b00000000000010000000000000000000;\n        5'b10100: out = 32'b00000000000100000000000000000000;\n        5'b10101: out = 32'b00000000001000000000000000000000;\n        5'b10110: out = 32'b00000000010000000000000000000000;\n        5'b10111: out = 32'b00000000100000000000000000000000;\n        5'b11000: out = 32'b00000001000000000000000000000000;\n        5'b11001: out = 32'b00000010000000000000000000000000;\n        5'b11010: out = 32'b00000100000000000000000000000000;\n        5'b11011: out = 32'b00001000000000000000000000000000;\n        5'b11100: out = 32'b00010000000000000000000000000000;\n        5'b11101: out = 32'b00100000000000000000000000000000;\n        5'b11110: out = 32'b01000000000000000000000000000000;\n        5'b11111: out = 32'b10000000000000000000000000000000;\n    endcase\nend\n\nendmodule",
        "module_name": "decoder_5bit",
        "module_hash": "16cb2a1bb81af5244798bf76d53f5b69",
        "dataset_index": 429
      },
      "d_ff_async_reset_a766b766": {
        "rtl_code": "module d_ff_async_reset (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            q <= 0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule",
        "module_name": "d_ff_async_reset",
        "module_hash": "a766b7660537ef0fe4e84a22d545ae3a",
        "dataset_index": 8322
      },
      "memory_109294f3": {
        "rtl_code": "module memory(clk, we, addr, din, dout);\n\n  parameter MEM_SIZE = 4096;\n  parameter ADDR_WIDTH = 12;\n  parameter DATA_WIDTH = 12;\n\n  input clk;\n  input we;\n  input [ADDR_WIDTH-1:0] addr;\n  input [DATA_WIDTH-1:0] din;\n  output reg [DATA_WIDTH-1:0] dout;\n\n  reg [DATA_WIDTH-1:0] mem [0:MEM_SIZE-1];\n\n  always @(posedge clk) begin\n    if (we) begin\n      mem[addr] <= din;\n    end else begin\n      dout <= mem[addr];\n    end\n  end\n\nendmodule",
        "module_name": "memory",
        "module_hash": "109294f33376259ab5e75d26807f4d82",
        "dataset_index": 17547
      },
      "mig_7series_v4_0_axi_mc_wrap_cmd #_4733b3b5": {
        "rtl_code": "\n\n\nmodule mig_7series_v4_0_axi_mc_wrap_cmd #\n(\nparameter integer C_AXI_ADDR_WIDTH            = 32, \n                    parameter integer C_MC_ADDR_WIDTH             = 30,\n                    parameter integer C_MC_BURST_LEN              = 1,\n                    parameter integer C_DATA_WIDTH                = 32,\n                    parameter integer C_AXSIZE                    = 2,\n                    parameter integer C_MC_RD_INST                = 0\n)\n(\ninput  wire                                 clk           , \n  input  wire                                 reset         , \n  input  wire [C_AXI_ADDR_WIDTH-1:0]          axaddr        , \n  input  wire [7:0]                           axlen         , \n  input  wire [2:0]                           axsize        , input  wire                                 axhandshake   , \n  output wire [C_AXI_ADDR_WIDTH-1:0]          cmd_byte_addr ,\n  output wire                                 ignore_begin  ,\n  output wire                                 ignore_end    ,\n  input  wire                                 next          , \n  output wire                                 next_pending \n\n);\nlocalparam P_AXLEN_WIDTH = 4;\nreg                         sel_first_r;\nreg  [3:0]                  axlen_cnt;\nreg  [3:0]                  int_addr;\nreg                         int_next_pending_r;\n\nwire                        sel_first;\nwire [3:0]                  axlen_i;\nwire [3:0]                  axlen_cnt_i;\nwire [3:0]                  axlen_cnt_t;\nwire [3:0]                  axlen_cnt_p;\n\nwire                        addr_offset;\nwire  [C_AXI_ADDR_WIDTH-1:0] axaddr_wrap;\nwire [3:0]                  int_addr_t;\nwire [3:0]                  int_addr_p;\nwire [3:0]                  int_addr_t_inc;\nwire                        int_next_pending;\nwire                        extra_cmd;\n\nassign cmd_byte_addr = axaddr_wrap;\nassign axlen_i = axlen[3:0];\n\nassign axaddr_wrap = {axaddr[C_AXI_ADDR_WIDTH-1:C_AXSIZE+4], int_addr_t[3:0], axaddr[C_AXSIZE-1:0]};\n\ngenerate\n  if(C_MC_BURST_LEN == 1) begin\n    assign addr_offset = 1'b0;\n    assign int_addr_t = axhandshake ? (axaddr[C_AXSIZE+: 4]) : int_addr;\n\n  end else begin\n    assign addr_offset = axaddr[C_AXSIZE];\n\n    if(C_MC_RD_INST == 0) assign int_addr_t = int_addr;\n    else\n      assign int_addr_t = axhandshake ? (axaddr[C_AXSIZE+: 4]) : int_addr;\n  end\nendgenerate\n\nassign int_addr_t_inc = int_addr_t + C_MC_BURST_LEN;\n\nassign int_addr_p = ((int_addr_t & ~axlen_i) | (int_addr_t_inc & axlen_i));\n\nalways @(posedge clk) begin\n  if(reset)\n    int_addr <= 4'h0;\n  else if (axhandshake & ~next)\n    int_addr <= (axaddr[C_AXSIZE+: 4]);\n  else if(next)\n    int_addr <= int_addr_p;\nend\n\nassign axlen_cnt_i = (C_MC_BURST_LEN == 1) ? axlen_i : (axlen_i >> 1);\n\nassign axlen_cnt_t = axhandshake ? axlen_cnt_i : axlen_cnt;\n\nassign axlen_cnt_p = (axlen_cnt_t - 1'b1);\n\nalways @(posedge clk) begin\n  if(reset)\n    axlen_cnt <= 4'hf;\n  else if (axhandshake & ~next)\n    axlen_cnt <= axlen_cnt_i;\n  else if(next)\n    axlen_cnt <= axlen_cnt_p;\nend  \n\nassign extra_cmd = addr_offset;\n\nassign next_pending = extra_cmd ? int_next_pending_r : int_next_pending;\n\nassign int_next_pending = |axlen_cnt_t;\n\nalways @(posedge clk) begin\n  if(reset)\n    int_next_pending_r <= 1'b1;\n  else if(extra_cmd & next)\n    int_next_pending_r <= int_next_pending;\nend\n\nassign ignore_begin = sel_first ? addr_offset : 1'b0;\n\nassign ignore_end = next_pending ? 1'b0 : addr_offset;\n\nassign sel_first = (axhandshake | sel_first_r);\n\nalways @(posedge clk) begin\n  if (reset)\n    sel_first_r <= 1'b0;\n  else if(axhandshake & ~next)\n    sel_first_r <= 1'b1;\n  else if(next)\n    sel_first_r <= 1'b0;\nend\n\nendmodule\n\n",
        "module_name": "mig_7series_v4_0_axi_mc_wrap_cmd #",
        "module_hash": "4733b3b56c9faca6b30eedb2d904337a",
        "dataset_index": 25189
      },
      "up_down_counter_0196692a": {
        "rtl_code": "module up_down_counter (\n  input clk,\n  input reset,\n  input load,\n  input direction,\n  input [7:0] data_in,\n  output reg [7:0] count,\n  output reg carry\n);\n\n  reg [7:0] count_reg;\n  reg [7:0] count_next;\n  reg carry_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_reg <= 8'b0;\n      carry_reg <= 1'b0;\n    end\n    else if (load) begin\n      count_reg <= data_in;\n      carry_reg <= (data_in == 8'hFF) ? 1'b1 : 1'b0;\n    end\n    else begin\n      count_reg <= count_next;\n      carry_reg <= (count_next == 8'hFF) ? 1'b1 : 1'b0;\n    end\n  end\n\n  always @(*) begin\n    if (direction) begin\n      count_next = count_reg + 1;\n    end\n    else begin\n      count_next = count_reg - 1;\n    end\n  end\n\n  always @(posedge clk) begin\n    count <= count_reg;\n    carry <= carry_reg;\n  end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "0196692aba99942a2f2d35f6c5e84abb",
        "dataset_index": 9229
      },
      "quadrature_decoder_f1e9207e": {
        "rtl_code": "\nmodule quadrature_decoder(\n    CLOCK, \n    RESET, \n    A, \n    B, \n    COUNT_ENABLE, \n    DIRECTION, \n    SPEED\n);\n\n    input CLOCK, RESET, A, B;\n    output COUNT_ENABLE;\n    output DIRECTION;\n    output [3:0] SPEED;\n    reg COUNT_ENABLE;\n    reg DIRECTION;\n    reg [3:0] SPEED;\n\n    reg [2:0] A_delayed;\n    reg [2:0] B_delayed;\n    reg [31:0] total;\n    wire count_enable;\n    wire count_direction;\n    \n    always @(posedge CLOCK or posedge RESET) begin \n        if (RESET) begin \n            A_delayed <= 0;\n            B_delayed <= 0;\n        end else begin\n            A_delayed <= {A_delayed[1:0], A};\n            B_delayed <= {B_delayed[1:0], B};\n        end\n    end\n    \n    assign count_enable = A_delayed[1] ^ A_delayed[2] ^ B_delayed[1] ^ B_delayed[2];\n    assign count_direction = A_delayed[1] ^ B_delayed[2];\n    \n    always @(posedge CLOCK or posedge RESET) begin\n        if (RESET) begin \n            total <= 0;\n        end \n        else if (count_enable) begin\n            // only want a final count between 0 & 27 (x4 for the clicks)\n            if (count_direction) begin \n                if (total < 109) begin \n                    total <= total+1; \n                end\n            end\n            else begin \n                if (total > 0) begin \n                    total <= total-1;\n                end\n            end\n        end\n    end\n    \n    always @(posedge CLOCK or posedge RESET) begin\n        if (RESET) begin\n            COUNT_ENABLE <= 0;\n            DIRECTION <= 0;\n            SPEED <= 0;\n        end\n        else begin\n            COUNT_ENABLE <= count_enable & ~COUNT_ENABLE;\n            DIRECTION <= count_direction & ~DIRECTION;\n            SPEED <= total[5:2];\n        end\n    end\nendmodule",
        "module_name": "quadrature_decoder",
        "module_hash": "f1e9207e1a22f01005b4baea5b7102e6",
        "dataset_index": 1514
      },
      "note_mono_b838a73e": {
        "rtl_code": "module note_mono(clk, rst, note_on, note_off, note, out_note, out_gate);\nparameter MAX_NOTES = 32;\nparameter MNOTES = MAX_NOTES - 1;\nparameter BIT_WIDTH  = (MAX_NOTES[7:7]==1'b1) ? 8 : \n\t\t\t\t\t   (MAX_NOTES[6:6]==1'b1) ? 7 :\n\t\t\t\t\t   (MAX_NOTES[5:5]==1'b1) ? 6 :\n\t\t\t\t\t   (MAX_NOTES[4:4]==1'b1) ? 5 :\n\t\t\t\t\t   (MAX_NOTES[3:3]==1'b1) ? 4 :\n\t\t\t\t\t   (MAX_NOTES[2:2]==1'b1) ? 3 :\n\t\t\t\t\t   (MAX_NOTES[1:1]==1'b1) ? 2 :\n\t\t\t\t\t   (MAX_NOTES[0:0]==1'b1) ? 1 : 0;\n\t\t\t\t\t   \t\t\t\t   \n\ninput wire clk, rst, note_on, note_off;\ninput wire [6:0] note;\noutput wire [6:0] out_note;\noutput reg out_gate;\n\ninitial out_gate <= 0;\n\nreg [(BIT_WIDTH-1):0] addr;\ninitial addr <= 0;\n\nreg [BIT_WIDTH:0] top_ptr;\ninitial top_ptr <= 0;\n\nreg [6:0] list [0:MNOTES];\n\nreg [6:0] t_note;\nreg [6:0] t_out_note;\nreg [6:0] max_note;\n\nassign out_note = (out_gate) ? t_out_note : 7'd0;\n\nparameter INITIAL  = 2'd0;\nparameter NOTE_ON  = 2'd1;\nparameter NOTE_OFF = 2'd2;\nparameter READY    = 2'd3;\nreg [1:0] state;\ninitial state <= INITIAL;\n\nparameter ST_SEARCH  = 2'd0; parameter IN_SEARCH  = 2'd1; parameter END_SEARCH = 2'd2; parameter GETMAX   = 2'd3; reg [1:0] note_on_state;\ninitial note_on_state <= 0;\nreg searched;\n\nreg [1:0] note_off_state;\ninitial note_off_state <= 0;\n\n\nalways @(posedge clk) begin\n\tif (note_on||note_off) begin\n\t\tt_note <= note;\n\tend\nend\n\nalways @(posedge clk) begin\n\tif (rst) begin\n\t\tstate<=INITIAL;\n\tend else\n\tif (state==INITIAL) begin\n\t\taddr <= 0;\n\t\ttop_ptr <= 0;\n\t\tout_gate <= 0;\n\t\tstate <= READY;\n\tend else if (state==READY) begin\n\t\tif (note_on) begin\n\t\t\tstate <= NOTE_ON;\n\t\t\taddr <= 0;\n\t\t\tsearched <= 0;\n\t\t\tnote_on_state <= 0;\n\t\tend else if (note_off) begin\n\t\t\tstate <= NOTE_OFF;\n\t\t\taddr <= 0;\n\t\t\tsearched <= 0;\n\t\t\tnote_off_state <= 0;\n\t\tend\n\tend else if (state==NOTE_ON) begin\n\t\tif (note_on_state == ST_SEARCH) begin\n\t\t\tif (top_ptr==0) begin out_gate <= 1;\n\t\t\t\tt_out_note <= t_note;\n\t\t\t\tlist[addr] <= t_note;\n\t\t\t\ttop_ptr <= top_ptr + 1'b1;\n\t\t\t\tstate <= READY;\n\t\t\tend else begin\n\t\t\t\tmax_note <= 0; note_on_state <= IN_SEARCH;\n\t\t\tend\n\t\tend else if (note_on_state == IN_SEARCH) begin\n\t\t\tif (addr==top_ptr) begin note_on_state <= END_SEARCH;\n\t\t\tend else begin\n\t\t\t\tif (list[addr] > max_note) max_note <= list[addr];\n\t\t\t\tif (list[addr]==t_note) searched <= 1;\n\t\t\t\taddr <= addr + 1'b1;\n\t\t\tend\n\t\tend else if (note_on_state == END_SEARCH) begin\n\t\t\tif (searched) begin state <= READY;\n\t\t\tend else begin list[top_ptr] <= t_note;\n\t\t\t\tt_out_note <= (t_note > max_note) ? t_note : max_note;\n\t\t\t\tout_gate <= 1;\n\t\t\t\ttop_ptr <= top_ptr + 1'b1;\n\t\t\t\tnote_on_state <= GETMAX;\n\t\t\tend\n\t\tend else if (note_on_state == GETMAX) begin\n\t\t\tstate <= READY;\n\t\tend\n\tend else if (state==NOTE_OFF) begin\n\t\tif (note_off_state == ST_SEARCH) begin\n\t\t\tif (top_ptr==0) begin state <= READY;\n\t\t\tend else begin\n\t\t\t\taddr <= 0; max_note <= 0; \n\t\t\t\tnote_off_state <= IN_SEARCH;\n\t\t\tend\n\t\tend else if (note_off_state == IN_SEARCH) begin\n\t\t\tif (addr==top_ptr) begin\n\t\t\t\tnote_off_state <= END_SEARCH;\n\t\t\t\tif (searched) top_ptr <= top_ptr - 1'b1;\n\t\t\tend else begin\n\t\t\t\tif (list[addr]==t_note) begin list[addr] <= list[top_ptr-1'b1];\n\t\t\t\t\tsearched <= 1; end\n\t\t\t\t\n\t\t\t\tif ((list[addr] > max_note)&&(list[addr]!=t_note)) max_note <= list[addr];\n\t\t\t\t\t\n\t\t\t\taddr <= addr + 1'b1;\n\t\t\tend\n\t\tend else if (note_off_state == END_SEARCH) begin\n\t\t\tt_out_note <= max_note;\n\t\t\tout_gate <= (top_ptr > 0);\n\t\t\tstate <= READY;\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "note_mono",
        "module_hash": "b838a73e7e97665eef6fb38e42fcbdf6",
        "dataset_index": 20257
      },
      "adbg_crc32_04d74d1d": {
        "rtl_code": "module adbg_crc32 (clk, data, enable, shift, clr, rst, crc_out, serial_out);\n\ninput         clk;\ninput         data;\ninput         enable;\ninput         shift;\ninput         clr;\ninput         rst;\noutput [31:0] crc_out;\noutput        serial_out;\n\n\nreg    [31:0] crc;\nwire   [31:0] new_crc;\n\n\nassign new_crc[0] = crc[1];\nassign new_crc[1] = crc[2];\nassign new_crc[2] = crc[3];\nassign new_crc[3] = crc[4];\nassign new_crc[4] = crc[5];\nassign new_crc[5] = crc[6] ^ data ^ crc[0];\nassign new_crc[6] = crc[7];\nassign new_crc[7] = crc[8];\nassign new_crc[8] = crc[9] ^ data ^ crc[0];\nassign new_crc[9] = crc[10] ^ data ^ crc[0];\nassign new_crc[10] = crc[11];\nassign new_crc[11] = crc[12];\nassign new_crc[12] = crc[13];\nassign new_crc[13] = crc[14];\nassign new_crc[14] = crc[15];\nassign new_crc[15] = crc[16] ^ data ^ crc[0];\nassign new_crc[16] = crc[17];\nassign new_crc[17] = crc[18];\nassign new_crc[18] = crc[19];\nassign new_crc[19] = crc[20] ^ data ^ crc[0];\nassign new_crc[20] = crc[21] ^ data ^ crc[0];\nassign new_crc[21] = crc[22] ^ data ^ crc[0];\nassign new_crc[22] = crc[23];\nassign new_crc[23] = crc[24] ^ data ^ crc[0];\nassign new_crc[24] = crc[25] ^ data ^ crc[0];\nassign new_crc[25] = crc[26];\nassign new_crc[26] = crc[27] ^ data ^ crc[0];\nassign new_crc[27] = crc[28] ^ data ^ crc[0];\nassign new_crc[28] = crc[29];\nassign new_crc[29] = crc[30] ^ data ^ crc[0];\nassign new_crc[30] = crc[31] ^ data ^ crc[0];\nassign new_crc[31] =           data ^ crc[0];\n\nalways @ (posedge clk or posedge rst)\nbegin\n  if(rst)\n    crc[31:0] <= 32'hffffffff;\n  else if(clr)\n    crc[31:0] <= 32'hffffffff;\n  else if(enable)\n    crc[31:0] <= new_crc;\n  else if (shift)\n    crc[31:0] <= {1'b0, crc[31:1]};\nend\n\n\nassign crc_out = crc; assign serial_out = crc[0];\n\nendmodule\n",
        "module_name": "adbg_crc32",
        "module_hash": "04d74d1de972840fc316115bcc63cb2c",
        "dataset_index": 24277
      },
      "sky130_fd_sc_lp__a32oi_2ef050b1": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a32oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    wire nand0_out ;\n    wire nand1_out ;\n    wire and0_out_Y;\n\n    nand nand0 (nand0_out , A2, A1, A3          );\n    nand nand1 (nand1_out , B2, B1              );\n    and  and0  (and0_out_Y, nand0_out, nand1_out);\n    buf  buf0  (Y         , and0_out_Y          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a32oi",
        "module_hash": "2ef050b18a8f33e9b5f9fed92782c46b",
        "dataset_index": 22719
      },
      "calculator_90efe337": {
        "rtl_code": "module calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input [3:0] num1,\n    input [3:0] num2,\n    output reg [3:0] result,\n    output reg overflow\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = num1 + num2; // addition\n        2'b01: result = num1 - num2; // subtraction\n        2'b10: result = num1 * num2; // multiplication\n        2'b11: result = num1 / num2; // division\n    endcase\n    \n    if(result > 15) // check for overflow\n        overflow = 1;\n    else\n        overflow = 0;\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "90efe337fd2507fbf1bcca8265f3a8c4",
        "dataset_index": 9574
      },
      "top__8b465f19": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // 8-bit input for the shift register\n    output [7:0] q,   // 8-bit output from the shift register\n    output [3:0] add_out, // 4-bit output from the adder\n    output [7:0] final_out // 8-bit final output from the functional module\n);\n\n    reg [7:0] shift_reg;\n    reg [3:0] counter;\n\n    // Shift register with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'h34;\n        end else begin\n            shift_reg <= {shift_reg[6:0], d};\n        end\n    end\n\n    // 4-bit binary counter with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'h0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    // 4-bit adder\n    assign add_out = shift_reg[3:0] + counter;\n\n    // Functional module to get final output\n    reg [7:0] final_out; // Changed 'wire' to 'reg' here\n    always @(posedge clk) begin\n        final_out <= shift_reg + add_out;\n    end\n\n    // Output the shift register\n    assign q = shift_reg;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "8b465f19dc74e49ce27e39c239d4e812",
        "dataset_index": 20728
      },
      "myModule_83298c19": {
        "rtl_code": "module myModule (\n    input CLK,\n    input ready_downstream,\n    output reg ready,\n    input reset,\n    input [64:0] process_input,\n    output reg [64:0] process_output\n);\n\nreg too_soon = process_input[64];\nreg [31:0] output_count = 0;\n\nalways @(posedge CLK) begin\n    if (reset) begin\n        ready <= 1'b0;\n        output_count <= 0;\n        process_output <= 0;\n    end else if (too_soon) begin\n        ready <= 1'b0;\n    end else if (ready_downstream && output_count < 76800) begin\n        ready <= 1'b1;\n        output_count <= output_count + 1;\n        process_output <= ~reset;\n    end else begin\n        ready <= 1'b1;\n        output_count <= output_count + 1;\n        process_output <= {1'b1, process_input[63:0]};\n    end\nend\n\nendmodule",
        "module_name": "myModule",
        "module_hash": "83298c19afeef02564cbdf57c2e3437d",
        "dataset_index": 8023
      },
      "mux4to1_374d465d": {
        "rtl_code": "\nmodule mux4to1 (\n    in0,\n    in1,\n    in2,\n    in3,\n    sel0,\n    sel1,\n    out\n);\n\n    input [3:0] in0, in1, in2, in3;\n    input sel0, sel1;\n    output [3:0] out;\n\n    wire [3:0] sel;\n\n    assign sel = {sel1, sel0};\n\n    assign out = (sel == 2'b00) ? in0 :\n                 (sel == 2'b01) ? in1 :\n                 (sel == 2'b10) ? in2 :\n                 in3;\n\nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "374d465d437f747a0f139d8a2c65bfa9",
        "dataset_index": 18295
      },
      "four_bit_adder_25eb20c9": {
        "rtl_code": "module four_bit_adder (\n    a,\n    b,\n    cin,\n    sum,\n    cout\n);\n\n    input [3:0] a, b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [3:0] temp_sum;\n    wire [4:0] temp_cout;\n\n    assign temp_sum = a + b + cin;\n    assign temp_cout = {1'b0, temp_sum} + {1'b0, ~a, 1'b1} + {1'b0, ~b, 1'b1} + {1'b0, ~cin, 1'b1};\n\n    assign sum = temp_sum;\n    assign cout = temp_cout[4];\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "25eb20c9ec8825984405665884ea5f8f",
        "dataset_index": 20350
      },
      "rotator_25b942ef": {
        "rtl_code": "\nmodule rotator(\n    input clk,\n    input reset,\n    input select,\n    input [3:0] data_in,\n    output [3:0] data_out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 4'b0000;\n    end else if (select) begin\n        shift_reg <= {shift_reg[2:0], shift_reg[3]};\n    end else begin\n        shift_reg[3:1] <= shift_reg[2:0];\n        shift_reg[0] <= shift_reg[3];\n    end\nend\n\nassign data_out = shift_reg;\n\nendmodule\n\nmodule splitter(\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    output [3:0] data_out_lo,\n    output [3:0] data_out_hi\n);\n\nreg [3:0] data_out_lo_reg;\nreg [3:0] data_out_hi_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out_lo_reg <= 4'b0000;\n        data_out_hi_reg <= 4'b0000;\n    end else begin\n        data_out_lo_reg <= data_in[3:0];\n        data_out_hi_reg <= data_in[7:4];\n    end\nend\n\nassign data_out_lo = data_out_lo_reg;\nassign data_out_hi = data_out_hi_reg;\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input reset,\n    input select,\n    input [7:0] data_in,\n    output [3:0] data_out_lo,\n    output [3:0] data_out_hi\n);\n\nwire [3:0] rotator_out;\nwire [3:0] splitter_out_lo;\nwire [3:0] splitter_out_hi;\n\nrotator rotator_inst(\n    .clk(clk),\n    .reset(reset),\n    .select(select),\n    .data_in(data_in[3:0]),\n    .data_out(rotator_out)\n);\n\nsplitter splitter_inst(\n    .clk(clk),\n    .reset(reset),\n    .data_in(data_in),\n    .data_out_lo(splitter_out_lo),\n    .data_out_hi(splitter_out_hi)\n);\n\nreg [3:0] data_out_lo_reg;\nreg [3:0] data_out_hi_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out_lo_reg <= 4'b0000;\n        data_out_hi_reg <= 4'b0000;\n    end else if (select) begin\n        data_out_lo_reg <= rotator_out;\n        data_out_hi_reg <= rotator_out;\n    end else begin\n        data_out_lo_reg <= splitter_out_lo;\n        data_out_hi_reg <= splitter_out_hi;\n    end\nend\n\nassign data_out_lo = data_out_lo_reg;\nassign data_out_hi = data_out_hi_reg;\n\nendmodule\n",
        "module_name": "rotator",
        "module_hash": "25b942ef74f76c9bafedba6178cd7cc1",
        "dataset_index": 7677
      },
      "top_module_00a68050": {
        "rtl_code": "\nmodule top_module( \n    input wire clk,\n    input wire reset,\n    input wire [15:0] in,\n    input wire select,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    output wire [1023:0] out_demux );\n    \n    // Demultiplexer\n    wire [255:0] demux_out;\n    wire [3:0] demux_sel = in[3:0];\n    demux_256to1 demux(\n        .in(select ? 4'b0 : demux_sel),\n        .out(demux_out)\n    );\n    \n    // Multiplexer\n    wire [7:0] mux_out;\n    wire [1:0] mux_sel = in[11:10];\n    mux_2to1 mux(\n        .in0(in[7:0]),\n        .in1(in[15:8]),\n        .sel(select ? mux_sel : 2'b0),\n        .out(mux_out)\n    );\n    \n    // Control Logic\n    wire demux_enable = select ? 0 : 1;\n    wire mux_enable = select ? 1 : 0;\n    \n    // Output\n    assign out_demux = {demux_enable ? demux_out : 256'b0};\n    assign out_hi = {mux_enable ? mux_out : 8'b0};\n    assign out_lo = {demux_enable ? 256'b0 : 8'b0};\n    \nendmodule\nmodule demux_256to1(\n    input wire [3:0] in,\n    output wire [255:0] out\n);\n    genvar i;\n    generate\n        for (i = 0; i < 256; i = i + 1) begin : demux_gen\n            assign out[i] = (in == i);\n        end\n    endgenerate\nendmodule\nmodule mux_2to1(\n    input wire [7:0] in0,\n    input wire [7:0] in1,\n    input wire [1:0] sel,\n    output wire [7:0] out\n);\n    assign out = (sel == 2'b0) ? in0 : in1;\nendmodule",
        "module_name": "top_module",
        "module_hash": "00a68050bf9c88a7e18bb7bbd021a851",
        "dataset_index": 15166
      },
      "adder_4bit_8afdd997": {
        "rtl_code": "module adder_4bit(cin, a, b, cout, sum);\n\n  input cin;\n  input [3:0] a, b;\n  output cout;\n  output [3:0] sum;\n\n  wire [4:0] temp_sum;\n\n  assign temp_sum = a + b + cin;\n\n  assign sum = temp_sum[3:0];\n  assign cout = temp_sum[4];\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "8afdd9978eba7d230d60659ea769e604",
        "dataset_index": 17338
      },
      "dff_5_d498c5da": {
        "rtl_code": "module dff_5 (clk, d, rstn, prsn, q, qn);\n    input clk, rstn, prsn;\n    input [4:0] d;\n    output [4:0] q, qn;\n    reg [4:0] q, qn;\n    \n    always @(posedge clk) begin\n        if (!rstn) begin\n            q <= 5'b0;\n            qn <= 5'b1;\n        end else if (!prsn) begin\n            q <= 5'b1;\n            qn <= 5'b0;\n        end else begin\n            q <= d;\n            qn <= ~d;\n        end\n    end\nendmodule",
        "module_name": "dff_5",
        "module_hash": "d498c5da8d2b06f95e7a636f9ad43775",
        "dataset_index": 4554
      },
      "four_bit_subtractor_26e7b078": {
        "rtl_code": "\nmodule four_bit_subtractor(\n input [3:0] A,\n input [3:0] B,\n output [3:0] C,\n output Borrow\n);\n\n  wire [3:0] diff;\n  wire borrow1, borrow2;\n\n one_bit_subtractor obs1(\n .A(A[0]),\n .B(B[0]),\n .Bin(1'b0),\n .Diff(diff[0]),\n .BorrowOut(borrow1)\n );\n\n one_bit_subtractor obs2(\n .A(A[1]),\n .B(B[1]),\n .Bin(borrow1),\n .Diff(diff[1]),\n .BorrowOut(borrow2)\n );\n\n one_bit_subtractor obs3(\n .A(A[2]),\n .B(B[2]),\n .Bin(borrow2),\n .Diff(diff[2]),\n .BorrowOut(Borrow)\n );\n\n  assign diff[3] = A[3] ^ B[3] ^ Borrow;\n  assign C = diff;\n\nendmodule\nmodule one_bit_subtractor(\n input A,\n input B,\n input Bin,\n output Diff, \n output BorrowOut\n );\n\n  assign Diff = A ^ B ^ Bin;\n  assign BorrowOut = (~A & B) | (~A & Bin) | (B & Bin);\n\nendmodule",
        "module_name": "four_bit_subtractor",
        "module_hash": "26e7b078a264176ef28d3c71481cc9b6",
        "dataset_index": 20165
      },
      "parity_generator_9005d349": {
        "rtl_code": "module parity_generator (\n    input [7:0] in,\n    output parity);\n    \n    assign parity = ((^in) & 1'b1);\n    \nendmodule",
        "module_name": "parity_generator",
        "module_hash": "9005d349b7e108fda8dda84156c0f3f2",
        "dataset_index": 21373
      },
      "converter_c116a696": {
        "rtl_code": "\nmodule converter(\n    input [3:0] in,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\n\nalways @* begin\n    case (in)\n        4'b0000: out_reg = 4'b0000;\n        4'b0001, 4'b0010: out_reg = 4'b0001;\n        4'b0011, 4'b0100: out_reg = 4'b0010;\n        4'b0101, 4'b0110: out_reg = 4'b0011;\n        4'b0111, 4'b1000: out_reg = 4'b0100;\n        4'b1001, 4'b1010: out_reg = 4'b0101;\n        4'b1011, 4'b1100: out_reg = 4'b0110;\n        4'b1101, 4'b1110: out_reg = 4'b0111;\n        4'b1111: out_reg = 4'b1000;\n    endcase\nend\n\nassign out = out_reg;\n\nendmodule\n",
        "module_name": "converter",
        "module_hash": "c116a6965478f49357eeb2480b8303da",
        "dataset_index": 18164
      },
      "priority_encoder_47a952da": {
        "rtl_code": "module priority_encoder (\n    input [15:0] I,\n    input EN,\n    output reg [3:0] O\n);\n\nreg [3:0] temp;\n\nalways @ (posedge EN) begin\n    temp <= (I[15:12] > I[11:8]) > (I[7:4] > I[3:0]);\nend\n\nalways @* begin\n    case(temp)\n        4'b0001: O = 4'b0001;\n        4'b0010: O = 4'b0010;\n        4'b0100: O = 4'b0100;\n        4'b1000: O = 4'b1000;\n        default: O = 4'b0000;\n    endcase\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "47a952da98464b87c7bc3f99039df8c9",
        "dataset_index": 8444
      },
      "module_name_d281e7da": {
        "rtl_code": "module module_name (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  B1,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = ((A1 & A2 & A3 & ~B1) | (~A1 & ~A2 & ~A3 & B1)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "module_name",
        "module_hash": "d281e7da020716cf22f6d00bca3c64ec",
        "dataset_index": 12614
      },
      "top__9a572002": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] inputs, // 4-to-2 priority encoder inputs\n    input up_down, // Up/Down input for the counter\n    input load, // Load input for the counter\n    input [3:0] D, // Input data for the counter\n    output [3:0] Q // Output from the counter\n);\n\nwire [1:0] priority_encoder_output; // Output from the priority encoder\n\n// Instantiate the 4-to-2 priority encoder module\npriority_encoder priority_encoder_inst (\n    .I(inputs),\n    .O(priority_encoder_output)\n);\n\n// Instantiate the up/down counter module\nup_down_counter up_down_counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .load(load),\n    .D(D), // Connect the input data to the input of the counter\n    .Q(Q)\n);\n\nendmodule\nmodule priority_encoder (\n    input [3:0] I,\n    output reg [1:0] O\n);\n\n    always @(*) begin\n        case (I)\n            4'b0001: O = 2'b01;\n            4'b0010: O = 2'b10;\n            4'b0100: O = 2'b11;\n            default: O = 2'b00;\n        endcase\n    end\n\nendmodule\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input up_down,\n    input load,\n    input [3:0] D,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else if (load) begin\n            Q <= D;\n        end else if (up_down) begin\n            Q <= Q + 4'b0001;\n        end else begin\n            Q <= Q - 4'b0001;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "9a572002435b524191a65be4e247ccb5",
        "dataset_index": 19587
      },
      "delay_800ns_4d15f263": {
        "rtl_code": "module delay_800ns(input clk, input reset, input in, output reg p);\n\treg [31:0] count;\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t\tcount <= 0;\n\t\t\tp <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif(in && !p) begin\n\t\t\t\tcount <= 0;\n\t\t\t\tp <= 1;\n\t\t\tend\n\t\t\telse if(count < 200) begin\n\t\t\t\tcount <= count + 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tcount <= 0;\n\t\t\t\tp <= 0;\n\t\t\tend\n\t\tend\n\tend\nendmodule",
        "module_name": "delay_800ns",
        "module_hash": "4d15f263d6d29dc66c77eac129dc6ec9",
        "dataset_index": 11094
      },
      "wb_bridge_16_32_3b7fd990": {
        "rtl_code": "module wb_bridge_16_32\n  #(parameter AWIDTH=16)\n    (input wb_clk, input wb_rst,\n     input A_cyc_i, input A_stb_i, input A_we_i, input [3:0] A_sel_i,\n     input [AWIDTH-1:0] A_adr_i, input [31:0] A_dat_i, output [31:0] A_dat_o, output A_ack_o,\n     output B_cyc_o, output B_stb_o, output B_we_o, output [1:0] B_sel_o,\n     output [AWIDTH-1:0] B_adr_o, output [15:0] B_dat_o, input [15:0] B_dat_i, input B_ack_i\n     );\n\n   reg [15:0] \t\t holding;\n   reg \t\t\t phase;\n   \n   assign \t\t B_adr_o = {A_adr_i[AWIDTH-1:2],phase,1'b0};\n   assign \t\t B_cyc_o = A_cyc_i;\n   assign \t\t B_stb_o = A_stb_i;\n   assign \t\t B_we_o = A_we_i;\n\n   assign \t\t B_dat_o = ~phase ? A_dat_i[15:0] : A_dat_i[31:16];\n   assign \t\t B_sel_o = ~phase ? A_sel_i[1:0] : A_sel_i[3:2];\n\n   assign \t\t A_dat_o = {B_dat_i,holding};\n   assign \t\t A_ack_o = phase & B_ack_i;\n\n   always @(posedge wb_clk)\n     if(wb_rst)\n       phase <= 0;\n     else if(B_ack_i)\n       phase <= ~phase;\n\n   always @(posedge wb_clk)\n     if(~phase & B_ack_i)\n       holding <= B_dat_i;\n   \nendmodule",
        "module_name": "wb_bridge_16_32",
        "module_hash": "3b7fd990722d0a02211046c50bd52013",
        "dataset_index": 12344
      },
      "dual_edge_triggered_ff_5f36a5dd": {
        "rtl_code": "module dual_edge_triggered_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg d1, d2, q1, q2;\n\nalways @(posedge clk) begin\n    d1 <= d;\n    q1 <= d1;\nend\n\nalways @(negedge clk) begin\n    d2 <= q1;\n    q2 <= d2;\nend\n\nassign q = q2;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\nwire q_ff;\n\ndual_edge_triggered_ff ff1 (\n    .clk(clk),\n    .d(d),\n    .q(q_ff)\n);\n\ndual_edge_triggered_ff ff2 (\n    .clk(clk),\n    .d(q_ff),\n    .q(q)\n);\n\nendmodule",
        "module_name": "dual_edge_triggered_ff",
        "module_hash": "5f36a5ddfddf4ebd71f99f46e998f418",
        "dataset_index": 14555
      },
      "state_machine_9b9ab1ce": {
        "rtl_code": "module state_machine(\n    input wire reset,\n    input wire [8:0] in_state,\n    output reg out1,\n    output reg out2,\n    input wire clk\n);\n\nalways @ (posedge reset or posedge clk) begin\n    if (reset) begin\n        out1 <= 0;\n        out2 <= 0;\n    end else begin\n        case(in_state)\n            9'd0: begin\n                out1 <= 0;\n                out2 <= 0;\n            end\n            9'd1: begin\n                out1 <= 1;\n                out2 <= 0;\n            end\n            9'd2: begin\n                out1 <= 0;\n                out2 <= 1;\n            end\n            default: begin\n                out1 <= 0;\n                out2 <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "state_machine",
        "module_hash": "9b9ab1ce3e5b6d97a5fcaaf4acf9bd84",
        "dataset_index": 2006
      },
      "mig_7series_v1_9_ecc_merge_enc_82f3a402": {
        "rtl_code": "\n\nmodule mig_7series_v1_9_ecc_merge_enc\n  #(\n    parameter TCQ = 100,\n    parameter PAYLOAD_WIDTH         = 64,\n    parameter CODE_WIDTH            = 72,\n    parameter DATA_BUF_ADDR_WIDTH   = 4,\n    parameter DATA_BUF_OFFSET_WIDTH = 1,\n    parameter DATA_WIDTH            = 64,\n    parameter DQ_WIDTH              = 72,\n    parameter ECC_WIDTH             = 8,\n    parameter nCK_PER_CLK           = 4\n   )\n   (\n    \n  mc_wrdata, mc_wrdata_mask,\n  clk, rst, wr_data, wr_data_mask, rd_merge_data, h_rows, raw_not_ecc\n  );\n\n  input clk;\n  input rst;\n\n  input [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data;\n  input [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask;\n  input [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data;\n  \n  reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data_r;\n  reg [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask_r;\n  reg [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data_r;\n\n  always @(posedge clk) wr_data_r <= #TCQ wr_data;\n  always @(posedge clk) wr_data_mask_r <= #TCQ wr_data_mask;\n  always @(posedge clk) rd_merge_data_r <= #TCQ rd_merge_data;\n  \n  wire [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] merged_data;\n  genvar h;\n  genvar i;\n  generate\n    for (h=0; h<2*nCK_PER_CLK; h=h+1) begin : merge_data_outer\n      for (i=0; i<DATA_WIDTH/8; i=i+1) begin : merge_data_inner\n        assign merged_data[h*PAYLOAD_WIDTH+i*8+:8] =  \n                wr_data_mask[h*DATA_WIDTH/8+i]\n                  ? rd_merge_data[h*DATA_WIDTH+i*8+:8]               \n                  : wr_data[h*PAYLOAD_WIDTH+i*8+:8];\n      end\n      if (PAYLOAD_WIDTH > DATA_WIDTH)\n        assign merged_data[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH]=\n                      wr_data[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH];\n                                                                   \n    end\n  endgenerate\n\n  input [CODE_WIDTH*ECC_WIDTH-1:0] h_rows;\n  input [2*nCK_PER_CLK-1:0] raw_not_ecc;\n  reg [2*nCK_PER_CLK-1:0] raw_not_ecc_r;\n  always @(posedge clk) raw_not_ecc_r <= #TCQ raw_not_ecc;\n  output reg [2*nCK_PER_CLK*DQ_WIDTH-1:0] mc_wrdata;\n  reg [2*nCK_PER_CLK*DQ_WIDTH-1:0] mc_wrdata_c;\n  genvar j;\n  integer k;\n  generate\n    for (j=0; j<2*nCK_PER_CLK; j=j+1) begin : ecc_word\n      always @(h_rows or merged_data or raw_not_ecc_r) begin\n        mc_wrdata_c[j*DQ_WIDTH+:DQ_WIDTH] =\n          {{DQ_WIDTH-PAYLOAD_WIDTH{1'b0}},\n           merged_data[j*PAYLOAD_WIDTH+:PAYLOAD_WIDTH]};\n        for (k=0; k<ECC_WIDTH; k=k+1)\n          if (~raw_not_ecc_r[j])\n            mc_wrdata_c[j*DQ_WIDTH+CODE_WIDTH-k-1] =\n              ^(merged_data[j*PAYLOAD_WIDTH+:DATA_WIDTH] & \n                h_rows[k*CODE_WIDTH+:DATA_WIDTH]);\n      end\n    end\n  endgenerate\nalways @(posedge clk) mc_wrdata <= mc_wrdata_c;\n\n  output wire[2*nCK_PER_CLK*DQ_WIDTH/8-1:0] mc_wrdata_mask;\n  assign mc_wrdata_mask = {2*nCK_PER_CLK*DQ_WIDTH/8{1'b0}};\n\nendmodule\n",
        "module_name": "mig_7series_v1_9_ecc_merge_enc",
        "module_hash": "82f3a402b181e55b13d4fd43741f3f9e",
        "dataset_index": 25805
      },
      "identificador_teclas_ad21a3f8": {
        "rtl_code": "\nmodule identificador_teclas\n(\ninput wire clk, reset,\ninput wire rx_done_tick,\ninput wire [7:0] dout,output reg gotten_code_flag );\n\nlocalparam break_code = 8'hF0;\n\nlocalparam wait_break_code = 1'b0;\nlocalparam get_code = 1'b1;\n\nreg state_next, state_reg;\n\nalways @(posedge clk, posedge reset)\n\tif (reset)\n\t\tstate_reg <= wait_break_code;\n\telse\n\t\tstate_reg <= state_next;\n\t\t\nalways @*\nbegin\n\tgotten_code_flag = 1'b0;\n\tstate_next = state_reg;\n\tcase (state_reg)\n\t\twait_break_code:  if (rx_done_tick == 1'b1 && dout == break_code)\n\t\t\t\tstate_next = get_code;\n\t\tget_code:  if (rx_done_tick)\n\t\t\t\tbegin\n\t\t\t\t\tgotten_code_flag =1'b1;\n\t\t\t\t\tstate_next = wait_break_code;\n\t\t\t\tend\n\tendcase\nend\n\t\t\nendmodule\n",
        "module_name": "identificador_teclas",
        "module_hash": "ad21a3f8f6603512c5f301e2e068fc38",
        "dataset_index": 8391
      },
      "barrel_shifter_65a80155": {
        "rtl_code": "module barrel_shifter (\n    input [31:0] data,\n    input [4:0] shift_amount,\n    input shift_direction,\n    output [31:0] shifted_output\n);\n\n    assign shifted_output = (shift_direction == 0) ? (data << shift_amount) : (data >> shift_amount);\n\nendmodule\n\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input load,\n    input up_down,\n    input [31:0] data, // Added missing input data\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (load) begin\n            count <= data[3:0];\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule\n\nmodule bitwise_and (\n    input [31:0] shifted_output,\n    input [3:0] count,\n    output [31:0] final_output\n);\n\n    assign final_output = shifted_output & {{4{count}}}; // Added extra curly braces for concatenation\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] data,\n    input [4:0] shift_amount,\n    input shift_direction,\n    input load,\n    input up_down,\n    output [3:0] count,\n    output [31:0] shifted_output,\n    output [31:0] final_output\n);\n\n    barrel_shifter barrel_shifter_inst (\n        .data(data),\n        .shift_amount(shift_amount),\n        .shift_direction(shift_direction),\n        .shifted_output(shifted_output)\n    );\n\n    up_down_counter up_down_counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .up_down(up_down),\n        .data(data), // Added missing data binding\n        .count(count)\n    );\n\n    bitwise_and bitwise_and_inst (\n        .shifted_output(shifted_output),\n        .count(count),\n        .final_output(final_output)\n    );\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "65a80155c272c0ec124e64f0ec6d510c",
        "dataset_index": 12116
      },
      "edge_detect_d61bed31": {
        "rtl_code": "module edge_detect (\n    input rst,\n    input clk, \n    input sig,\n    output rise,\n    output fall\n);\n\nreg [1:0] sig_reg;\n\nalways @(posedge clk or posedge rst)\n    if (rst == 1'b1)\n        sig_reg <= 2'b00;\n    else\n        sig_reg <= {sig_reg[0], sig};\n\nassign rise = sig_reg[0] == 1'b1 && sig_reg[1] == 1'b0 ? 1'b1 : 1'b0;\nassign fall = sig_reg[0] == 1'b0 && sig_reg[1] == 1'b1 ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "edge_detect",
        "module_hash": "d61bed314994ea678469d10bcc66328a",
        "dataset_index": 24265
      },
      "sky130_fd_sc_ms__and3_7189a2e2": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__and3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, C, A, B        );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__and3",
        "module_hash": "7189a2e2ad1f0942e1aaba55e4e9f8db",
        "dataset_index": 23729
      },
      "shift_reg #_3513a12b": {
        "rtl_code": "\n\n\nmodule shift_reg #(\n    parameter REG_SZ = 93,\n    parameter FEED_FWD_IDX = 65,\n    parameter FEED_BKWD_IDX = 68\n) \n(\n    \n    input   wire            clk_i,      \n    input   wire            n_rst_i,    \n    input   wire            ce_i,       \n      \n   \n    input   wire    [2:0]   ld_i,       \n    input   wire    [31:0]  ld_dat_i,   \n    input   wire            dat_i,      \n    output  wire            dat_o,      \n    output  wire            z_o         \n);\n\nreg     [(REG_SZ - 1):0]    dat_r;      \nwire                        reg_in_s;   \n\nassign reg_in_s = dat_i ^ dat_r[FEED_BKWD_IDX];\n\nalways @(posedge clk_i or negedge n_rst_i) begin\n    if (!n_rst_i)\n        dat_r <= 0;\n    else begin\n        if (ce_i) begin\n            \n            dat_r <= {dat_r[(REG_SZ - 2):0], reg_in_s};\n        end\n        else if (ld_i != 3'b000) begin \n            if (ld_i[0])\n                dat_r[31:0] <= ld_dat_i;\n            else if (ld_i[1])\n                dat_r[63:32] <= ld_dat_i;\n            else if (ld_i[2])\n                dat_r[79:64] <= ld_dat_i[15:0];\n         \n               \n            dat_r[(REG_SZ - 1):80] <= 0;\n            if (REG_SZ == 111)\n                dat_r[(REG_SZ - 1)-:3] <= 3'b111;\n        end\n    end\nend\n\nassign z_o = (dat_r[REG_SZ - 1] ^ dat_r[FEED_FWD_IDX]);\nassign dat_o = z_o ^ (dat_r[REG_SZ - 2] & dat_r[REG_SZ - 3]); \n\nendmodule\n",
        "module_name": "shift_reg #",
        "module_hash": "3513a12b58f54e7f5d1875bddca9d587",
        "dataset_index": 21582
      },
      "mux_2to1_enable_c2aa3c1f": {
        "rtl_code": "module mux_2to1_enable (\n  input enable,\n  input [7:0] in1,\n  input [7:0] in2,\n  output reg [7:0] out\n);\n\n  always @(*) begin\n    if (enable == 1'b0) begin\n      out = in1;\n    end else begin\n      out = in2;\n    end\n  end\n\nendmodule\n",
        "module_name": "mux_2to1_enable",
        "module_hash": "c2aa3c1fc880be43c337f1d3570f2987",
        "dataset_index": 3087
      },
      "wifi_tx_900eb3d7": {
        "rtl_code": "module wifi_tx (\n  input [7:0] data_in,\n  input clk,\n  output reg [15:0] mod_signal_out\n);\n\n  reg [3:0] I, Q;\n  reg [1:0] phase;\n  \n  always @(*) begin\n    case(data_in)\n      8'b00000000: begin I = 4'b0000; Q = 4'b0000; end\n      8'b00000001: begin I = 4'b0000; Q = 4'b0001; end\n      8'b00000010: begin I = 4'b0000; Q = 4'b0010; end\n      8'b00000011: begin I = 4'b0000; Q = 4'b0011; end\n      8'b00000100: begin I = 4'b0000; Q = 4'b0100; end\n      8'b00000101: begin I = 4'b0000; Q = 4'b0101; end\n      8'b00000110: begin I = 4'b0000; Q = 4'b0110; end\n      8'b00000111: begin I = 4'b0000; Q = 4'b0111; end\n      8'b00001000: begin I = 4'b0001; Q = 4'b0000; end\n      8'b00001001: begin I = 4'b0001; Q = 4'b0001; end\n      8'b00001010: begin I = 4'b0001; Q = 4'b0010; end\n      8'b00001011: begin I = 4'b0001; Q = 4'b0011; end\n      8'b00001100: begin I = 4'b0001; Q = 4'b0100; end\n      8'b00001101: begin I = 4'b0001; Q = 4'b0101; end\n      8'b00001110: begin I = 4'b0001; Q = 4'b0110; end\n      8'b00001111: begin I = 4'b0001; Q = 4'b0111; end\n      8'b00010000: begin I = 4'b0010; Q = 4'b0000; end\n      8'b00010001: begin I = 4'b0010; Q = 4'b0001; end\n      8'b00010010: begin I = 4'b0010; Q = 4'b0010; end\n      8'b00010011: begin I = 4'b0010; Q = 4'b0011; end\n      8'b00010100: begin I = 4'b0010; Q = 4'b0100; end\n      8'b00010101: begin I = 4'b0010; Q = 4'b0101; end\n      8'b00010110: begin I = 4'b0010; Q = 4'b0110; end\n      8'b00010111: begin I = 4'b0010; Q = 4'b0111; end\n      8'b00011000: begin I = 4'b0011; Q = 4'b0000; end\n      8'b00011001: begin I = 4'b0011; Q = 4'b0001; end\n      8'b00011010: begin I = 4'b0011; Q = 4'b0010; end\n      8'b00011011: begin I = 4'b0011; Q = 4'b0011; end\n      8'b00011100: begin I = 4'b0011; Q = 4'b0100; end\n      8'b00011101: begin I = 4'b0011; Q = 4'b0101; end\n      8'b00011110: begin I = 4'b0011; Q = 4'b0110; end\n      8'b00011111: begin I = 4'b0011; Q = 4'b0111; end\n      8'b00100000: begin I = 4'b0100; Q = 4'b0000; end\n      8'b00100001: begin I = 4'b0100; Q = 4'b0001; end\n      8'b00100010: begin I = 4'b0100; Q = 4'b0010; end\n      8'b00100011: begin I = 4'b0100; Q = 4'b0011; end\n      8'b00100100: begin I = 4'b0100; Q = 4'b0100; end\n      8'b00100101: begin I = 4'b0100; Q = 4'b0101; end\n      8'b00100110: begin I = 4'b0100; Q = 4'b0110; end\n      8'b00100111: begin I = 4'b0100; Q = 4'b0111; end\n      8'b00101000: begin I = 4'b0101; Q = 4'b0000; end\n      8'b00101001: begin I = 4'b0101; Q = 4'b0001; end\n      8'b00101010: begin I = 4'b0101; Q = 4'b0010; end\n      8'b00101011: begin I = 4'b0101; Q = 4'b0011; end\n      8'b00101100: begin I = 4'b0101; Q = 4'b0100; end\n      8'b00101101: begin I = 4'b0101; Q = 4'b0101; end\n      8'b00101110: begin I = 4'b0101; Q = 4'b0110; end\n      8'b00101111: begin I = 4'b0101; Q = 4'b0111; end\n      8'b00110000: begin I = 4'b0110; Q = 4'b0000; end\n      8'b00110001: begin I = 4'b0110; Q = 4'b0001; end\n      8'b00110010: begin I = 4'b0110; Q = 4'b0010; end\n      8'b00110011: begin I = 4'b0110; Q = 4'b0011; end\n      8'b00110100: begin I = 4'b0110; Q = 4'b0100; end\n      8'b00110101: begin I = 4'b0110; Q = 4'b0101; end\n      8'b00110110: begin I = 4'b0110; Q = 4'b0110; end\n      8'b00110111: begin I = 4'b0110; Q = 4'b0111; end\n      8'b00111000: begin I = 4'b0111; Q = 4'b0000; end\n      8'b00111001: begin I = 4'b0111; Q = 4'b0001; end\n      8'b00111010: begin I = 4'b0111; Q = 4'b0010; end\n      8'b00111011: begin I = 4'b0111; Q = 4'b0011; end\n      8'b00111100: begin I = 4'b0111; Q = 4'b0100; end\n      8'b00111101: begin I = 4'b0111; Q = 4'b0101; end\n      8'b00111110: begin I = 4'b0111; Q = 4'b0110; end\n      8'b00111111: begin I = 4'b0111; Q = 4'b0111; end\n      default: begin I = 4'b0000; Q = 4'b0000; end\n    endcase\n  end\n  \n  always @(posedge clk) begin\n    case(phase)\n      2'b00: begin mod_signal_out = {I, Q}; phase <= 2'b01; end\n      2'b01: begin mod_signal_out = {I, -Q}; phase <= 2'b10; end\n      2'b10: begin mod_signal_out = {-I, -Q}; phase <= 2'b11; end\n      2'b11: begin mod_signal_out = {-I, Q}; phase <= 2'b00; end\n    endcase\n  end\n  \nendmodule",
        "module_name": "wifi_tx",
        "module_hash": "900eb3d7b75d97fbdeb9a89f720d38a1",
        "dataset_index": 4215
      },
      "Bus_Arbiter_f783618a": {
        "rtl_code": "\nmodule Bus_Arbiter(\n    input Clock_in,\n    input Reset_in,\n    input Inst_Read_in,\n    input Inst_Write_in,\n    input [29:0] Inst_Address_in,\n    input [4095:0] Inst_Data_in,\n    output reg Inst_Ready_out,\n    output reg [4095:0] Inst_Data_out,\n    input Data_Read_in,\n    input Data_Write_in,\n    input [29:0] Data_Address_in,\n    input [4095:0] Data_Data_in,\n    output reg Data_Ready_out,\n    output reg[4095:0] Data_Data_out,\n    output reg SD_Read_in,\n    output reg SD_Write_in,\n    output reg [29:0] SD_Address_in,\n    output reg [4095:0] SD_Data_in,\n    input SD_Ready_out,\n    input [4095:0] SD_Data_out\n    );\n\n    reg [1:0] Bus_Locked;\n    reg Bus_Select;\n    \n    \n    \n    always@(posedge Clock_in)\n        begin\n            if (Reset_in)\n                Bus_Locked = 2'b00;\n            else begin\n                if (Bus_Locked == 2'b00) begin\n                    if ((Inst_Read_in | Inst_Write_in) && !SD_Ready_out)\n                       Bus_Locked = 2'b10;\n                    if ((Data_Read_in | Data_Write_in) && !SD_Ready_out)\n                       Bus_Locked = 2'b01; \n                end\n                if (Bus_Locked == 2'b01) begin\n                    if (~(Data_Read_in | Data_Write_in) && !SD_Ready_out && (Inst_Read_in | Inst_Write_in))\n                       Bus_Locked = 2'b10;\n                    if (~(Data_Read_in | Data_Write_in) && !SD_Ready_out && ~(Inst_Read_in | Inst_Write_in))\n                       Bus_Locked = 2'b00;\n                end\n                if (Bus_Locked == 2'b10) begin\n                    if ((Data_Read_in | Data_Write_in) && !SD_Ready_out && ~(Inst_Read_in | Inst_Write_in))\n                       Bus_Locked = 2'b01;\n                    if (~(Data_Read_in | Data_Write_in) && !SD_Ready_out && ~(Inst_Read_in | Inst_Write_in))\n                       Bus_Locked = 2'b00;\n                end\n            end\n            Bus_Select = (!Reset_in) ? (Bus_Locked == 2'b10) ? 1'b0 : (Bus_Locked == 2'b01) ? 1'b1 : Bus_Select : 1'b0;\n            Inst_Ready_out = (!Reset_in) ? (!Bus_Select) ? SD_Ready_out : 1'b0 : 1'b0;\n            Inst_Data_out = (!Reset_in) ? SD_Data_out : 4096'd0;\n            Data_Ready_out = (!Reset_in) ? (Bus_Select) ? SD_Ready_out : 1'b0 : 1'b0;\n            Data_Data_out = (!Reset_in) ? SD_Data_out :4096'd0;\n            SD_Read_in = (!Reset_in) ? (Bus_Select) ? Data_Read_in : Inst_Read_in : 1'b0;\n            SD_Write_in = (!Reset_in) ? (Bus_Select) ? Data_Write_in : Inst_Write_in : 1'b0;\n            SD_Address_in = (!Reset_in) ? (Bus_Select) ? Data_Address_in : Inst_Address_in : 30'd0;\n            SD_Data_in = (!Reset_in) ? (Bus_Select) ? Data_Data_in : Inst_Data_in : 4096'd0;\n        end\n        \n\n                     \nendmodule\n",
        "module_name": "Bus_Arbiter",
        "module_hash": "f783618af2f10d71feea4479cee85bd7",
        "dataset_index": 23561
      },
      "timer_a2abca19": {
        "rtl_code": "\n\nmodule timer (\n  input  wire        clk,\n  input  wire        reset,\n  input  wire        wrenb,\n  input  wire        wraddr,\n  input  wire [31:0] config_data,\n  input  wire        update_timers,\n  input  wire        fsm_start_timer,\n  input  wire        fsm_clear_timer,\n  input  wire        fsm_stop_timer,\n  output reg         timer_elapsed\n);\n\nreg [35:0] timer, next_timer;\nreg [35:0] timer_limit, next_timer_limit; reg timer_active, next_timer_active;\nreg next_timer_elapsed;\n\ninitial \nbegin \n  timer = 36'h0;\n  timer_active = 1'b0;\n  timer_elapsed = 1'b0;\n  timer_limit = 36'h0;\nend\n\nalways @ (posedge clk)\nbegin\n  timer         <= next_timer;\n  timer_active  <= next_timer_active;\n  timer_elapsed <= next_timer_elapsed;\n  timer_limit   <= next_timer_limit;\nend\n\nalways @*\nbegin\n  next_timer = (timer_elapsed) ? 36'h0 : timer;\n  next_timer_active = timer_active;\n  next_timer_elapsed = timer_elapsed;\n  next_timer_limit = timer_limit;\n\n  if (timer_active) \n    begin\n      next_timer = timer+1'b1;\n      if (timer >= timer_limit) \n\tbegin\n\t  next_timer_elapsed = 1'b1;\n\t  next_timer_active = 1'b0;\n\tend\n    end\n\n  if (update_timers) \n    begin\n      if (fsm_start_timer) next_timer_active=1'b1;\n      if (fsm_clear_timer) begin next_timer=0; next_timer_elapsed=1'b0; end\n      if (fsm_stop_timer) next_timer_active=1'b0;\n    end\n\n  if (wrenb)\n    case (wraddr)\n      1'b0 : next_timer_limit[31:0] = config_data;\n      1'b1 : next_timer_limit[35:32] = config_data[3:0];\n    endcase\n\n  if (reset)\n    begin\n      next_timer = 0;\n      next_timer_active = 0;\n      next_timer_elapsed = 0;\n    end\nend\n\nendmodule\n",
        "module_name": "timer",
        "module_hash": "a2abca19fcddcab9e135afdaf56cfe8f",
        "dataset_index": 22434
      },
      "LSHIFTER_32bit_12603159": {
        "rtl_code": "module LSHIFTER_32bit(S, D, C);\n\n// I/O port declaration\ninput [31:0] D;\ninput C;\noutput [31:0] S;\n\n//internal nets\nwire C1;\nwire [30:0] shifted;\n\n//Instantiate logic gate primitives\nnot not1(C1,C);\nassign shifted = {D[29:0], 1'b0};\n\nassign S = (C1 == 1'b1) ? shifted : D;\n\nendmodule",
        "module_name": "LSHIFTER_32bit",
        "module_hash": "12603159a4835c4d51aaf440a0ac2ee7",
        "dataset_index": 3919
      },
      "top_module_86b58270": {
        "rtl_code": "module top_module(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] mux_out;\nwire [3:0] adder_out;\n\nmux_4to1 mux(\n    .in0(in0),\n    .in1(in1),\n    .in2(in2),\n    .in3(in3),\n    .sel(sel),\n    .out(mux_out)\n);\n\nbinary_adder adder(\n    .a(mux_out),\n    .b(4'b0011),\n    .sum(adder_out)\n);\n\nassign out = adder_out;\n\nendmodule\n\nmodule mux_4to1(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\nwire [3:0] and0_out;\nwire [3:0] and1_out;\nwire [3:0] and2_out;\nwire [3:0] and3_out;\nwire [3:0] or0_out;\nwire [3:0] or1_out;\n\nassign and0_out = sel[1] & sel[0] ? in3 : 4'b0000;\nassign and1_out = sel[1] & ~sel[0] ? in2 : 4'b0000;\nassign and2_out = ~sel[1] & sel[0] ? in1 : 4'b0000;\nassign and3_out = ~sel[1] & ~sel[0] ? in0 : 4'b0000;\n\nassign or0_out = and0_out | and1_out;\nassign or1_out = and2_out | and3_out;\n\nassign out = or0_out | or1_out;\n\nendmodule\n\nmodule binary_adder(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n\nalways @* begin\n    sum = a + b;\nend\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "86b5827067c0db9f967d501b63cb5dad",
        "dataset_index": 14580
      },
      "sky130_fd_sc_hdll__a222oi_9ab370d1": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__a222oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1,\n    C2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n    input  C2;\n\n    wire nand0_out ;\n    wire nand1_out ;\n    wire nand2_out ;\n    wire and0_out_Y;\n\n    nand nand0 (nand0_out , A2, A1                         );\n    nand nand1 (nand1_out , B2, B1                         );\n    nand nand2 (nand2_out , C2, C1                         );\n    and  and0  (and0_out_Y, nand0_out, nand1_out, nand2_out);\n    buf  buf0  (Y         , and0_out_Y                     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__a222oi",
        "module_hash": "9ab370d1efd48384d4b0513e7368043a",
        "dataset_index": 20418
      },
      "SYM_GEN_4BYTE_8f208df7": {
        "rtl_code": "\n\nmodule SYM_GEN_4BYTE\n(\n    GEN_SCP,\n    GEN_ECP,\n    GEN_PAD,\n    TX_PE_DATA,\n    TX_PE_DATA_V,\n    GEN_CC,\n\n\n    GEN_A,\n    GEN_K,\n    GEN_R,\n    GEN_V,\n\n\n    GEN_SP,\n    GEN_SPA,\n\n\n    TX_CHAR_IS_K,\n    TX_DATA,\n\n\n    USER_CLK\n);\n`define DLY #1\n\ninput   [0:1]   GEN_SCP;        input   [0:1]   GEN_ECP;        input   [0:1]   GEN_PAD;        input   [0:31]  TX_PE_DATA;     input   [0:1]   TX_PE_DATA_V;   input           GEN_CC;         input           GEN_A;          input   [0:3]   GEN_K;          input   [0:3]   GEN_R;          input   [0:3]   GEN_V;          input           GEN_SP;         input           GEN_SPA;        output  [3:0]   TX_CHAR_IS_K;   output  [31:0]  TX_DATA;        input           USER_CLK;       reg     [31:0]  TX_DATA;\n    reg     [3:0]   TX_CHAR_IS_K;\n\n\nreg     [0:1]   gen_scp_r;\n    reg     [0:1]   gen_ecp_r;\n    reg     [0:1]   gen_pad_r;\n    reg     [0:31]  tx_pe_data_r;\n    reg     [0:1]   tx_pe_data_v_r;\n    reg             gen_cc_r;\n    reg             gen_a_r;\n    reg     [0:3]   gen_k_r;\n    reg     [0:3]   gen_r_r;\n    reg     [0:3]   gen_v_r;\n    reg             gen_sp_r;\n    reg             gen_spa_r;\n\n\nwire    [0:3]   idle_c;\n\nalways @(posedge USER_CLK)\n    begin\n        gen_scp_r       <=  `DLY    GEN_SCP;\n        gen_ecp_r       <=  `DLY    GEN_ECP;\n        gen_pad_r       <=  `DLY    GEN_PAD;\n        tx_pe_data_r    <=  `DLY    TX_PE_DATA;\n        tx_pe_data_v_r  <=  `DLY    TX_PE_DATA_V;\n        gen_cc_r        <=  `DLY    GEN_CC;\n        gen_a_r         <=  `DLY    GEN_A;\n        gen_k_r         <=  `DLY    GEN_K;\n        gen_r_r         <=  `DLY    GEN_R;\n        gen_v_r         <=  `DLY    GEN_V;\n        gen_sp_r        <=  `DLY    GEN_SP;\n        gen_spa_r       <=  `DLY    GEN_SPA;\n    end\n\n\n\n    assign  idle_c[0]   =   !(gen_scp_r[0]      |\n                              gen_ecp_r[0]      |\n                              tx_pe_data_v_r[0] |\n                              gen_cc_r          |\n                              gen_sp_r          |\n                              gen_spa_r         |\n                              gen_v_r[0]);\n\n\n\n    always @ (posedge USER_CLK)\n    begin\n        if(gen_scp_r[0])            TX_DATA[31:24] <= `DLY  8'h5c;             if(gen_ecp_r[0])            TX_DATA[31:24] <= `DLY  8'hfd;             if(tx_pe_data_v_r[0])       TX_DATA[31:24] <= `DLY  tx_pe_data_r[0:7]; if(gen_cc_r)                TX_DATA[31:24] <= `DLY  8'hf7;             if(idle_c[0] & gen_a_r)     TX_DATA[31:24] <= `DLY  8'h7c;             if(idle_c[0] & gen_k_r[0])  TX_DATA[31:24] <= `DLY  8'hbc;             if(idle_c[0] & gen_r_r[0])  TX_DATA[31:24] <= `DLY  8'h1c;             if(gen_sp_r)                TX_DATA[31:24] <= `DLY  8'hbc;             if(gen_spa_r   )            TX_DATA[31:24] <= `DLY  8'hbc;             if(gen_v_r[0])              TX_DATA[31:24] <= `DLY  8'he8;             end\n\n\n\n    always @(posedge USER_CLK)\n        TX_CHAR_IS_K[3] <=  `DLY    !(tx_pe_data_v_r[0] |\n                                      gen_v_r[0]);\n\n\n    assign  idle_c[1]   =   !(gen_scp_r[0]      |\n                              gen_ecp_r[0]      |\n                              tx_pe_data_v_r[0] |\n                              gen_cc_r          |\n                              gen_sp_r          |\n                              gen_spa_r         |\n                              gen_v_r[1]);\n\n\n    always @ (posedge USER_CLK)\n    begin\n        if(gen_scp_r[0])                      TX_DATA[23:16] <= `DLY 8'hfb;               if(gen_ecp_r[0])                      TX_DATA[23:16] <= `DLY 8'hfe;               if(tx_pe_data_v_r[0] & gen_pad_r[0])  TX_DATA[23:16] <= `DLY 8'h9c;               if(tx_pe_data_v_r[0] & !gen_pad_r[0]) TX_DATA[23:16] <= `DLY tx_pe_data_r[8:15];  if(gen_cc_r)                          TX_DATA[23:16] <= `DLY 8'hf7;               if(idle_c[1] & gen_k_r[1])            TX_DATA[23:16] <= `DLY 8'hbc;               if(idle_c[1] & gen_r_r[1])            TX_DATA[23:16] <= `DLY 8'h1c;               if(gen_sp_r)                          TX_DATA[23:16] <= `DLY 8'h4a;               if(gen_spa_r)                         TX_DATA[23:16] <= `DLY 8'h2c;               if(gen_v_r[1])                        TX_DATA[23:16] <= `DLY 8'he8;               end\n\n\n    always @(posedge USER_CLK)\n        TX_CHAR_IS_K[2] <= `DLY !((tx_pe_data_v_r[0] && !gen_pad_r[0]) |\n                                  gen_sp_r          |\n                                  gen_spa_r         |\n                                  gen_v_r[1]);\n\n\n    assign  idle_c[2]   =   !(gen_scp_r[1]      |\n                              gen_ecp_r[1]      |\n                              tx_pe_data_v_r[1] |\n                              gen_cc_r          |\n                              gen_sp_r          |\n                              gen_spa_r         |\n                              gen_v_r[2]);\n\n\n\n    always @ (posedge USER_CLK)\n    begin\n        if(gen_scp_r[1])                TX_DATA[15:8] <= `DLY  8'h5c;             if(gen_ecp_r[1])                TX_DATA[15:8] <= `DLY  8'hfd;             if(tx_pe_data_v_r[1])           TX_DATA[15:8] <= `DLY  tx_pe_data_r[16:23]; if(gen_cc_r)                    TX_DATA[15:8] <= `DLY  8'hf7;             if(idle_c[2] & gen_k_r[2])      TX_DATA[15:8] <= `DLY  8'hbc;             if(idle_c[2] & gen_r_r[2])      TX_DATA[15:8] <= `DLY  8'h1c;             if(gen_sp_r)                    TX_DATA[15:8] <= `DLY  8'h4a;             if(gen_spa_r)                   TX_DATA[15:8] <= `DLY  8'h2c;             if(gen_v_r[2])                  TX_DATA[15:8] <= `DLY  8'he8;             end\n\n\n\n    always @(posedge USER_CLK)\n        TX_CHAR_IS_K[1] <=  `DLY    !(tx_pe_data_v_r[1] |\n                                      gen_sp_r          |\n                                      gen_spa_r         |\n                                      gen_v_r[2]);\n\n\n    assign  idle_c[3]   =   !(gen_scp_r[1]      |\n                              gen_ecp_r[1]      |\n                              tx_pe_data_v_r[1] |\n                              gen_cc_r          |\n                              gen_sp_r          |\n                              gen_spa_r         |\n                              gen_v_r[3]);\n\n\n\n    always @ (posedge USER_CLK)\n    begin\n        if(gen_scp_r[1])                      TX_DATA[7:0]  <= `DLY 8'hfb;               if(gen_ecp_r[1])                      TX_DATA[7:0]  <= `DLY 8'hfe;               if(tx_pe_data_v_r[1] & gen_pad_r[1])  TX_DATA[7:0]  <= `DLY 8'h9c;               if(tx_pe_data_v_r[1] & !gen_pad_r[1]) TX_DATA[7:0]  <= `DLY tx_pe_data_r[24:31]; if(gen_cc_r)                          TX_DATA[7:0]  <= `DLY 8'hf7;               if(idle_c[3] & gen_k_r[3])            TX_DATA[7:0]  <= `DLY 8'hbc;               if(idle_c[3] & gen_r_r[3])            TX_DATA[7:0]  <= `DLY 8'h1c;               if(gen_sp_r)                          TX_DATA[7:0]  <= `DLY 8'h4a;               if(gen_spa_r)                         TX_DATA[7:0]  <= `DLY 8'h2c;               if(gen_v_r[3])                        TX_DATA[7:0]  <= `DLY 8'he8;               end\n\n\n\n    always @(posedge USER_CLK)\n        TX_CHAR_IS_K[0] <= `DLY !((tx_pe_data_v_r[1] && !gen_pad_r[1]) |\n                                   gen_sp_r          |\n                                   gen_spa_r         |\n                                   gen_v_r[3]);\n\nendmodule\n",
        "module_name": "SYM_GEN_4BYTE",
        "module_hash": "8f208df7c4fd6e9d0745d6b543ec6e3b",
        "dataset_index": 24567
      },
      "greater_than_cc9a2cb3": {
        "rtl_code": "module greater_than (\n    input [7:0] A,\n    input [7:0] B,\n    input [7:0] C,\n    output Y\n);\n\n    assign Y = (A >= B) && (C < B);\n\nendmodule",
        "module_name": "greater_than",
        "module_hash": "cc9a2cb34130e491cd284d0cb3f989a2",
        "dataset_index": 20349
      },
      "binary_counter_e9281520": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst,\n    input en,\n    input ctrl,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0;\n    end else if (en) begin\n        if (ctrl) begin\n            count <= count - 1;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "e9281520802c7ada7e22caa7e8a07a0b",
        "dataset_index": 11230
      },
      "magnitude_comparator_754a5ecf": {
        "rtl_code": "module magnitude_comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output reg out\n);\n\n    always @(*) begin\n        if (|A > |B)  // check if magnitude of A is greater than magnitude of B\n            out = 1;\n        else\n            out = 0;\n    end\n\nendmodule",
        "module_name": "magnitude_comparator",
        "module_hash": "754a5ecfbecec97e26355f9aa7ee6656",
        "dataset_index": 16928
      },
      "ripple_carry_adder_395a57c5": {
        "rtl_code": "module ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] C;\n\n// Full adder for the least significant bit\nfull_adder FA0(\n    .A(A[0]),\n    .B(B[0]),\n    .Cin(Cin),\n    .S(S[0]),\n    .C(C[0])\n);\n\n// Full adder for the second least significant bit\nfull_adder FA1(\n    .A(A[1]),\n    .B(B[1]),\n    .Cin(C[0]),\n    .S(S[1]),\n    .C(C[1])\n);\n\n// Full adder for the second most significant bit\nfull_adder FA2(\n    .A(A[2]),\n    .B(B[2]),\n    .Cin(C[1]),\n    .S(S[2]),\n    .C(C[2])\n);\n\n// Full adder for the most significant bit\nfull_adder FA3(\n    .A(A[3]),\n    .B(B[3]),\n    .Cin(C[2]),\n    .S(S[3]),\n    .C(Cout)\n);\n\nendmodule\n\n\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output C\n);\n\nassign S = A ^ B ^ Cin;\nassign C = (A & B) | (A & Cin) | (B & Cin);\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "395a57c5c5ca9293840125428ba1098f",
        "dataset_index": 9720
      },
      "sync__2330cb4b": {
        "rtl_code": "module sync_module (in1, in2, clk, out1, out2);\n\n  input in1;\n  input in2;\n  input clk;\n  output out1;\n  output out2;\n\n  reg in1_reg;\n  reg in2_reg;\n  reg out1_reg;\n  reg out2_reg;\n\n  always @(posedge clk) begin\n    in1_reg <= in1;\n    in2_reg <= in2;\n    out1_reg <= in2_reg;\n    out2_reg <= in1_reg;\n  end\n\n  assign out1 = out1_reg;\n  assign out2 = out2_reg;\n\nendmodule",
        "module_name": "sync_",
        "module_hash": "2330cb4b0d090d8ae2d975e36208da74",
        "dataset_index": 4093
      },
      "dual_port_RAM_6d7a7ddc": {
        "rtl_code": "module dual_port_RAM (\n    input clk,\n    input rst_n,\n    input write_en,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    output reg [3:0] read_data\n);\n\nreg [3:0] mem [0:7];\nreg [3:0] read_data_reg;\nreg [7:0] write_addr_reg;\nreg [3:0] write_data_reg;\nreg [1:0] state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        state <= 2'b00;\n        read_data_reg <= 4'b0;\n        write_addr_reg <= 8'b0;\n        write_data_reg <= 4'b0;\n    end else begin\n        case (state)\n            2'b00: begin\n                if (write_en) begin\n                    write_addr_reg <= write_addr;\n                    write_data_reg <= write_data;\n                    state <= 2'b01;\n                end else if (read_en) begin\n                    read_data_reg <= mem[read_addr];\n                    state <= 2'b10;\n                end\n            end\n            2'b01: begin\n                mem[write_addr_reg] <= write_data_reg;\n                state <= 2'b00;\n            end\n            2'b10: begin\n                read_data <= read_data_reg;\n                state <= 2'b00;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "dual_port_RAM",
        "module_hash": "6d7a7ddc9c1e9c40f56a33980f68d0f5",
        "dataset_index": 6033
      },
      "altera_up_av_config_auto_init_ltm_920cfe4e": {
        "rtl_code": "\n\n\n\nmodule altera_up_av_config_auto_init_ltm (\n\trom_address,\n\n\trom_data\n);\n\n\n\n\n\ninput\t\t\t[ 4: 0]\trom_address;\n\noutput\t\t[23: 0]\trom_data;\n\n\n\n\nreg\t\t\t[23: 0]\tdata;\n\n\n\n\n\n\n\n\nassign rom_data = {data[13: 8], 2'h0, \n\t\t\t\t\t\tdata[ 7: 0]};\n\nalways @(*)\nbegin\n\tcase (rom_address)\n\t0\t\t:\tdata\t<=\t{6'h02, 8'h07};\n\t1\t\t:\tdata\t<=\t{6'h03, 8'hDF};\n\t2\t\t:\tdata\t<=\t{6'h04, 8'h17};\n\t3\t\t:\tdata\t<=\t{6'h11, 8'h00};\n\t4\t\t:\tdata\t<=\t{6'h12, 8'h5B};\n\t5\t\t:\tdata\t<=\t{6'h13, 8'hFF};\n\t6\t\t:\tdata\t<=\t{6'h14, 8'h00};\n\t7\t\t:\tdata\t<=\t{6'h15, 8'h20};\n\t8\t\t:\tdata\t<=\t{6'h16, 8'h40};\n\t9\t\t:\tdata\t<=\t{6'h17, 8'h80};\n\t10\t\t:\tdata\t<=\t{6'h18, 8'h00};\n\t11\t\t:\tdata\t<=\t{6'h19, 8'h80};\n\t12\t\t:\tdata\t<=\t{6'h1A, 8'h00};\n\t13\t\t:\tdata\t<=\t{6'h1B, 8'h00};\n\t14\t\t:\tdata\t<=\t{6'h1C, 8'h80};\n\t15\t\t:\tdata\t<=\t{6'h1D, 8'hC0};\n\t16\t\t:\tdata\t<=\t{6'h1E, 8'hE0};\n\t17\t\t:\tdata\t<=\t{6'h1F, 8'hFF};\n\t18\t\t:\tdata\t<=\t{6'h20, 8'hD2};\n\t19\t\t:\tdata\t<=\t{6'h21, 8'hD2};\n\tdefault\t:\tdata\t<=\t14'h0000;\n\tendcase\nend\n\n\n\n\nendmodule\n\n",
        "module_name": "altera_up_av_config_auto_init_ltm",
        "module_hash": "920cfe4e1ec1d57848a82c4719d3e0c3",
        "dataset_index": 22263
      },
      "fifo_dfb8abc6": {
        "rtl_code": "module fifo(datain, rd, wr, rst, clk, full, empty,led_n,wei);\n\ninput [3:0] datain;\ninput rd, wr, rst, clk;\n\noutput [6:0] led_n;\noutput full, empty, wei;\n\nreg [3:0] dataout;\nreg full_in, empty_in,wei_in,div;\nreg [3:0] mem [15:0];\nreg [23:0]cnt;\nreg [3:0] rp, wp;\nreg [6:0] led_n;\n\nassign full = full_in;\nassign empty = empty_in;\nassign wei=wei_in;\n\nparameter \n    reg0=7'b0000001,\n    reg1=7'b1001111,\n    reg2=7'b0010010,\n    reg3=7'b0000110,\n    reg4=7'b1001100,\n    reg5=7'b0100100,\n    reg6=7'b0100000,\n    reg7=7'b0001101,\n    reg8=7'b0000000,\n    reg9=7'b0000100,\n    rega=7'b0001000,\n    regb=7'b1100000,\n    regc=7'b0110001,\n    regd=7'b1000010,\n    rege=7'b0110000,\n    regf=7'b0111000;\n\nalways@(posedge clk) \nbegin\n    if(cnt==24'b111111111111111111111111)\n\t    begin\n\t    div=~div;\n\t    cnt<=0;\n\t    end\n    else\n\t    begin\n\t    cnt<=cnt+1;\n\t    end\nend\n\nalways@(posedge clk) \nbegin\n    wei_in<=1'b0;\nend\n\nalways@(posedge div) \nbegin\n    if(~wr && ~full_in) \n\t    mem[wp]<=datain;\nend\n\nalways@(posedge div) \nbegin\n    if(!rst) \n\t    wp<=0;\n    else \n    begin\n        if(~wr && ~full_in)    \n        wp<= wp+1'b1;\n    end\nend\n\nalways@(posedge div)\nbegin\n    if(!rst) \n        rp <= 0;\n    else \n    begin\n        if(~rd && ~empty_in) \n        rp <= rp + 1'b1;\n    end\nend\n\nalways@(posedge div) \nbegin\n    if(!rst) \n        full_in <= 1'b0;\n    else \n    begin\n        if(rd && ~wr)\n            begin\n            if((wp==rp-1)||(rp==4'h0&&wp==4'hf))\n\t\t        full_in <= 1'b1;\n\t\t    end\n        else if(full_in && ~rd) \n\t\t    full_in <= 1'b0;\n    end\nend\n\nalways@(posedge div ) \nbegin\n    if(!rst) \n        empty_in <= 1'b1;\n\telse \n\t    begin\n        if(~rd&&wr)\n\t\t    begin  \n                if(rp==wp-1 || (rp==4'hf&&wp==4'h0))\n                    empty_in<=1'b1;\n            end\n        else if(empty_in && ~wr) \n            empty_in<=1'b0;\n        end\nend\n\nalways@(posedge div) \nbegin\n    if(~rd && ~empty_in) \n\t\tdataout<=mem[rp];\n\t\t case(dataout) \n            4'h0: led_n<=reg0;\n            4'h1: led_n<=reg1;\n            4'h2: led_n<=reg2;\n            4'h3: led_n<=reg3;\n            4'h4: led_n<=reg4;\n            4'h5: led_n<=reg5;\n            4'h6: led_n<=reg6;\n            4'h7: led_n<=reg7;\n            4'h8: led_n<=reg8;\n            4'h9: led_n<=reg9;\n            4'ha: led_n<=rega;\n            4'hb: led_n<=regb;\n            4'hc: led_n<=regc;\n            4'hd: led_n<=regd;\n            4'he: led_n<=rege;\n            4'hf: led_n<=regf;\n        default:;\n        endcase\t\t\t\t\t\t\t\t\nend\nendmodule\n\n\n\n\n",
        "module_name": "fifo",
        "module_hash": "dfb8abc6ba2e2ba4da7fd606b527519f",
        "dataset_index": 1922
      },
      "XOR_GATE_43a8d1df": {
        "rtl_code": "module XOR_GATE (\n    input A,\n    input B,\n    output C\n);\n    wire w1, w2, w3;\n    \n    assign w1 = A & ~B;\n    assign w2 = ~A & B;\n    assign w3 = w1 | w2;\n    \n    assign C = w3;\nendmodule",
        "module_name": "XOR_GATE",
        "module_hash": "43a8d1df97bbec3489d890a757a1ce00",
        "dataset_index": 16274
      },
      "binary_adder_db289966": {
        "rtl_code": "module binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output reg [3:0] S,\n    output reg COUT\n);\n\n    reg CARRY;\n    \n    always @(*) begin\n        S[0] = A[0] ^ B[0] ^ CIN;\n        CARRY = (A[0] & B[0]) | (A[0] & CIN) | (B[0] & CIN);\n        S[1] = A[1] ^ B[1] ^ CARRY;\n        CARRY = (A[1] & B[1]) | (A[1] & CARRY) | (B[1] & CARRY);\n        S[2] = A[2] ^ B[2] ^ CARRY;\n        CARRY = (A[2] & B[2]) | (A[2] & CARRY) | (B[2] & CARRY);\n        S[3] = A[3] ^ B[3] ^ CARRY;\n        COUT = (A[3] & B[3]) | (A[3] & CARRY) | (B[3] & CARRY);\n    end\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "db2899662ed65495106c572c00119cbb",
        "dataset_index": 868
      },
      "top__92bb390c": {
        "rtl_code": "module top_module (\n    input clk,        // System clock\n    input reset,      // Asynchronous active-high reset\n    output reg out    // Output of the functional module\n);\n\nreg clk_divided;\nreg [3:0] count;\n\n// Edge detection module\nalways @(posedge clk) begin\n    clk_divided <= ~clk_divided;\nend\n\n// 4-bit binary counter module\nalways @(posedge clk_divided or posedge reset) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        count <= count + 1;\n        if (count == 4'b1111) begin\n            count <= 4'b0000;\n        end\n    end\nend\n\n// Functional module to generate square wave with 50% duty cycle\nalways @(posedge clk_divided or posedge reset) begin\n    if (reset) begin\n        out <= 1'b0;\n    end else begin\n        if (count < 4'b1000) begin\n            out <= 1'b0;\n        end else begin\n            out <= 1'b1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "92bb390c0fc90c4b67f98ad65108d8d2",
        "dataset_index": 10987
      },
      "wishbone_mem_interconnect_89f39aec": {
        "rtl_code": "\n\n\n\n\nmodule wishbone_mem_interconnect (\n  input               clk,\n  input               rst,\n\n  input               i_m_we,\n  input               i_m_stb,\n  input               i_m_cyc,\n  input       [3:0]   i_m_sel,\n  input       [31:0]  i_m_adr,\n  input       [31:0]  i_m_dat,\n  output reg  [31:0]  o_m_dat,\n  output reg          o_m_ack,\n  output reg          o_m_int,\n\n  output              o_s0_we,\n  output              o_s0_cyc,\n  output              o_s0_stb,\n  output    [3:0]     o_s0_sel,\n  input               i_s0_ack,\n  output    [31:0]    o_s0_dat,\n  input     [31:0]    i_s0_dat,\n  output    [31:0]    o_s0_adr,\n  input               i_s0_int\n\n);\n\n\nparameter MEM_SEL_0 = 0;\nparameter MEM_OFFSET_0  =  32'h00000000;\nparameter MEM_SIZE_0  =  32'h800000;\n\n\nreg [31:0] mem_select;\n\nalways @(rst or i_m_adr or mem_select) begin\n  if (rst) begin\n    mem_select <= 32'hFFFFFFFF;\n  end\n  else begin\n    if ((i_m_adr >= MEM_OFFSET_0) && (i_m_adr < (MEM_OFFSET_0 + MEM_SIZE_0))) begin\n      mem_select <= MEM_SEL_0;\n    end\n    else begin\n      mem_select <= 32'hFFFFFFFF;\n    end\n  end\nend\n\n\nalways @ (mem_select or i_s0_dat) begin\n  case (mem_select)\n    MEM_SEL_0: begin\n      o_m_dat <= i_s0_dat;\n    end\n    default: begin\n      o_m_dat <= 32'h0000;\n    end\n  endcase\nend\n\n\n\nalways @ (mem_select or i_s0_ack) begin\n  case (mem_select)\n    MEM_SEL_0: begin\n      o_m_ack <= i_s0_ack;\n    end\n    default: begin\n      o_m_ack <= 1'h0;\n    end\n  endcase\nend\n\n\n\nalways @ (mem_select or i_s0_int) begin\n  case (mem_select)\n    MEM_SEL_0: begin\n      o_m_int <= i_s0_int;\n    end\n    default: begin\n      o_m_int <= 1'h0;\n    end\n  endcase\nend\n\n\n\nassign o_s0_we   =  (mem_select == MEM_SEL_0) ? i_m_we: 1'b0;\nassign o_s0_stb  =  (mem_select == MEM_SEL_0) ? i_m_stb: 1'b0;\nassign o_s0_sel  =  (mem_select == MEM_SEL_0) ? i_m_sel: 4'b0;\nassign o_s0_cyc  =  (mem_select == MEM_SEL_0) ? i_m_cyc: 1'b0;\nassign o_s0_adr  =  (mem_select == MEM_SEL_0) ? i_m_adr: 32'h0;\nassign o_s0_dat  =  (mem_select == MEM_SEL_0) ? i_m_dat: 32'h0;\n\n\n\nendmodule\n",
        "module_name": "wishbone_mem_interconnect",
        "module_hash": "89f39aecd2fdda2105519b6a806d5b9b",
        "dataset_index": 4595
      },
      "adder_4bit_with_cin_0a0df15a": {
        "rtl_code": "module adder_4bit_with_cin (\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output reg [3:0] out,\n  output reg cout\n);\n\n  always @(*) begin\n    out[0] = a[0] ^ b[0] ^ cin;\n    out[1] = a[1] ^ b[1] ^ (a[0] & b[0]) | (a[0] ^ b[0]) & cin;\n    out[2] = a[2] ^ b[2] ^ (a[1] & b[1]) | (a[1] ^ b[1]) & (a[0] | b[0]) | (a[0] & b[0] & cin);\n    out[3] = a[3] ^ b[3] ^ (a[2] & b[2]) | (a[2] ^ b[2]) & (a[1] | b[1]) | (a[1] & b[1] & (a[0] | b[0])) | (a[0] & b[0] & cin);\n    if (out > 4'b1111) begin\n      out = out[3:0];\n      cout = 1;\n    end\n    else begin\n      cout = 0;\n    end\n  end\n  \nendmodule\n",
        "module_name": "adder_4bit_with_cin",
        "module_hash": "0a0df15a0074f464339da4ad4bce675c",
        "dataset_index": 20279
      },
      "LCDCONTROL_52423019": {
        "rtl_code": "module LCDCONTROL (\n\t\t\t\t   input \t   CLK, RST,\n\t\t\t\t   input \t   WRITE,\n\t\t\t\t   input [8:0] WRDATA,\n\t\t\t\t   output reg  STATUS,\n\t\t\t\t   output \t   LCD_BLON, output \t   LCD_RW, output \t   LCD_EN, output \t   LCD_RS, inout [7:0] LCD_DATA\t\t\t\t\t\t\t);\n\n   reg [8:0] \t\t\t\t\t cmd;\n   reg [4:0] \t\t\t\t\t en_cnt;\n   reg [17:0] \t\t\t\t\t wait_cnt;\n   wire \t\t\t\t\t\t st;\n   wire \t\t\t\t\t\t busy;\n   reg \t\t\t\t\t\t\t rst_dly;\n   reg [19:0] \t\t\t\t\t dly_cnt;\n\n   assign LCD_RW = 1'b0; assign LCD_BLON = 1'b1; assign LCD_RS = cmd[8];\n   assign LCD_DATA = cmd[7:0];\n   assign LCD_EN = (en_cnt!=0) ? 1'b1 : 1'b0;\n\n   assign st = (WRITE==1 && busy==0) ? 1'b1 : 1'b0;\n\n   always @(posedge CLK or posedge RST)\n\t begin\n\t\tif (RST) begin\n\t\t  dly_cnt <= 20'h0;\n\t\t   rst_dly <= 1'b1;\n\t\tend \n\t\telse if (dly_cnt!=20'hFFFFF)\n\t\t  begin\n\t\t\t dly_cnt <= dly_cnt + 20'h1;\n\t\t\t rst_dly <= 1'b1;\n\t\t  end\n\t\telse\n\t\t  begin\n\t\t\t rst_dly <= 1'b0;\n\t\t  end\n\t end\n\n   always @(posedge CLK or posedge RST)\n\t begin\n\t\tif (RST)\n\t\t  cmd <= 9'h0;\n\t\telse if (rst_dly)\n\t\t  cmd <= 9'h0;\n\t\telse if (st)\n\t\t  cmd <= WRDATA[8:0];\n\t end\n\n   always @(posedge CLK or posedge RST)\n\t begin\n\t\tif (RST)\n\t\t  en_cnt <= 5'h0;\n\t\telse if (rst_dly)\n\t\t  en_cnt <= 5'h0;\n\t\telse if (st)\n\t\t  en_cnt <= 5'h10;\n\t\telse if (en_cnt!=5'h0)\n\t\t  en_cnt <= en_cnt - 5'h1;\n\t end\n\n   always @(posedge CLK or posedge RST)\n\t begin\n\t\tif (RST)\n\t\t  wait_cnt <= 18'h00000;\n\t\telse if (rst_dly)\n\t\t  wait_cnt <= 18'h00000;\n\t\telse if (en_cnt == 5'h1)\n\t\t  wait_cnt <= 18'h3FFFF; else if (wait_cnt!=18'h0)\n\t\t  wait_cnt <= wait_cnt - 18'h1;\n\t end\n\n   assign busy = (en_cnt==5'h0 && wait_cnt==18'h0) ? 1'b0 : 1'b1;\n\n   always @(posedge CLK or posedge RST)\n\t begin\n\t\tif (RST)\n\t\t  STATUS <= 1'b1;\n\t\telse if (rst_dly)\n\t\t  STATUS <= 1'b1;\n\t\telse\n\t\t  STATUS <= st | busy;\n\t end\n\nendmodule\n\n\n",
        "module_name": "LCDCONTROL",
        "module_hash": "52423019c796a5a7c8ee07462ebe6832",
        "dataset_index": 12323
      },
      "uart_transmitter_9eec2f04": {
        "rtl_code": "module uart_transmitter (\n  input clk,\n  input rst,\n  input [7:0] data_in,\n  input start,\n  output reg tx,\n  output reg done\n);\n\n  reg [3:0] counter;\n  reg [9:0] shift_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      counter <= 4'b0;\n      tx <= 1'b1;\n      done <= 1'b0;\n    end else begin\n      if (start && counter == 4'b0) begin\n        shift_reg <= {1'b1, data_in, 1'b0};\n        counter <= 4'b0001;\n        done <= 1'b0;\n      end else if (counter != 4'b0) begin\n        tx <= shift_reg[0];\n        shift_reg <= {1'b1, shift_reg[9:1]};\n        counter <= counter + 4'b0001;\n        if (counter == 4'b1010) begin\n          counter <= 4'b0;\n          done <= 1'b1;\n        end\n      end\n    end\n  end\nendmodule\n\nmodule uart_receiver (\n  input clk,\n  input rst,\n  input rx,\n  output reg [7:0] data_out,\n  output reg valid\n);\n\n  reg [3:0] counter;\n  reg [9:0] shift_reg;\n  reg waiting_for_start;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      counter <= 4'b0;\n      waiting_for_start <= 1'b1;\n      valid <= 1'b0;\n    end else begin\n      if (waiting_for_start) begin\n        if (!rx) begin\n          counter <= 4'b0001;\n          waiting_for_start <= 1'b0;\n        end\n      end else begin\n        counter <= counter + 4'b0001;\n        if (counter == 4'b1010) begin\n          shift_reg <= {rx, shift_reg[9:1]};\n          data_out <= shift_reg[8:1];\n          valid <= shift_reg[9];\n          waiting_for_start <= 1'b1;\n          counter <= 4'b0;\n        end else begin\n          shift_reg <= {rx, shift_reg[9:1]};\n          valid <= 1'b0;\n        end\n      end\n    end\n  end\nendmodule",
        "module_name": "uart_transmitter",
        "module_hash": "9eec2f0454b20afad47eb5d93b27a8bf",
        "dataset_index": 11064
      },
      "sevensegdecoder_d40bbd99": {
        "rtl_code": "\nmodule sevensegdecoder(\n\n\tinput [4:0] nIn,\n\toutput reg [6:0] ssOut  \n);\n\nalways @(nIn)\n    case (nIn)\n      5'h0: ssOut = 7'b1000000;\n      5'h1: ssOut = 7'b1111001;\n      5'h2: ssOut = 7'b0100100;\n      5'h3: ssOut = 7'b0110000;\n      5'h4: ssOut = 7'b0011001;\n      5'h5: ssOut = 7'b0010010;\n      5'h6: ssOut = 7'b0000010;\n      5'h7: ssOut = 7'b1111000;\n      5'h8: ssOut = 7'b0000000;\n      5'h9: ssOut = 7'b0011000;\n      5'hA: ssOut = 7'b0001000;\n      5'hB: ssOut = 7'b0000011;\n      5'hC: ssOut = 7'b1000110;\n      5'hD: ssOut = 7'b0100001;\n      5'hE: ssOut = 7'b0000110;\n      5'hF: ssOut = 7'b0001110;\n      5'h10: ssOut = 7'b0101111;\n      5'h11: ssOut = 7'b0001100;\n      5'h12: ssOut = 7'b0000110;\n      5'h13: ssOut = 7'b1111111;\n      default: ssOut = 7'b1001001;\n    endcase\n\nendmodule\n",
        "module_name": "sevensegdecoder",
        "module_hash": "d40bbd998ee22e4b4327c43a52716e90",
        "dataset_index": 11650
      },
      "OSERDESE2_939602bd": {
        "rtl_code": "\n\nmodule OSERDESE2 ( \n   OFB, OQ, SHIFTOUT1, SHIFTOUT2, TBYTEOUT, TFB, TQ,\n   CLK, CLKDIV, D1, D2, D3, D4, D5, D6, D7, D8, OCE, RST, SHIFTIN1,\n   SHIFTIN2, T1, T2, T3, T4, TBYTEIN, TCE\n   );\n\n   parameter DATA_RATE_OQ=0;\n   parameter DATA_RATE_TQ=0;\n   parameter DATA_WIDTH=0;\n   parameter INIT_OQ=0;\n   parameter INIT_TQ=0;\n   parameter SERDES_MODE=0;\n   parameter SRVAL_OQ=0;\n   parameter SRVAL_TQ=0;\n   parameter TBYTE_CTL=0;\n   parameter TBYTE_SRC=0;\n   parameter TRISTATE_WIDTH=0;\n\n     \n   output OFB;                    output OQ;                     output SHIFTOUT1;              output SHIFTOUT2;              output TBYTEOUT;               output TFB;                    output TQ;                     input  CLK;                    input  CLKDIV;                 input  D1;                     input  D2;                     input  D3;                     input  D4;                     input  D5;                     input  D6;                     input  D7;                     input  D8;                     input  OCE;                    input  RST;                    input  SHIFTIN1;               input  SHIFTIN2;               input  T1;                     input  T2;                     input  T3;                     input  T4;                     input  TBYTEIN;                input  TCE;                    reg [2:0] state;\n\n\n   reg [7:0] buffer;\n   reg [1:0] clkdiv_sample;\n   reg [3:0] even;\n   reg [3:0] odd;\n   \n   always @ (posedge CLKDIV)\n     buffer[7:0]<={D8,D7,D6,D5,D4,D3,D2,D1};\n   \n   always @ (negedge CLK)\n     clkdiv_sample[1:0] <= {clkdiv_sample[0],CLKDIV};\n\n   wire      load_parallel = (clkdiv_sample[1:0]==2'b00);\n\n   always @ (posedge CLK)\n     if(load_parallel)\n       even[3:0]<={buffer[6],buffer[4],buffer[2],buffer[0]};\n     else\n       even[3:0]<={1'b0,even[3:1]};\n\n   always @ (posedge CLK)\n     if(load_parallel)\n       odd[3:0]<={buffer[7],buffer[5],buffer[3],buffer[1]};\n     else\n       odd[3:0]<={1'b0,odd[3:1]};\n     \n   assign OQ = CLK ? even[0] : odd[0];\n   \n   assign OFB       = 1'b0;\n   assign TQ        = 1'b0;\n   assign TBYTEOUT  = 1'b0;\n   assign SHIFTOUT1 = 1'b0;   \t\t      \n   assign SHIFTOUT2 = 1'b0;   \n   assign TFB       = 1'b0;\n   \nendmodule ",
        "module_name": "OSERDESE2",
        "module_hash": "939602bd292aff7a25c0bcb629113517",
        "dataset_index": 25282
      },
      "oh_memory_ram  #_48e7f197": {
        "rtl_code": "module oh_memory_ram  # (parameter DW    = 104,           parameter DEPTH = 32,            parameter AW    = $clog2(DEPTH)  ) \n   (input \t\trd_clk,input \t\trd_en, input [AW-1:0] \trd_addr, output reg [DW-1:0] rd_dout, input \t\twr_clk,input \t\twr_en, input [AW-1:0] \twr_addr, input [DW-1:0] \twr_wem, input [DW-1:0] \twr_din );\n   \n   reg [DW-1:0]        ram    [DEPTH-1:0];  \n   integer \t       i;\n      \n   always @ (posedge rd_clk)\n     if(rd_en)       \n       rd_dout[DW-1:0] <= ram[rd_addr[AW-1:0]];\n   \n   always @(posedge wr_clk)    \n     for (i=0;i<DW;i=i+1)\n       if (wr_en & wr_wem[i]) \n         ram[wr_addr[AW-1:0]][i] <= wr_din[i];\n  \nendmodule ",
        "module_name": "oh_memory_ram  #",
        "module_hash": "48e7f197126f165682f2d53cd8735e7b",
        "dataset_index": 5991
      },
      "top__8ead3e6b": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input A_input,\n    input B_input,\n    input EN,\n    output reg signed [7:0] P_output\n);\n\n    wire [3:0] decoder_out;\n    wire [7:0] multiplier_out;\n    \n    decoder_2to4_with_enable decoder_2to4_with_enable_inst (\n        .A(A_input),\n        .B(B_input),\n        .EN(EN),\n        .Y(decoder_out)\n    );\n    \n    booth_multiplier booth_multiplier_inst (\n        .clk(clk),\n        .reset(reset),\n        .A(A),\n        .B(B),\n        .P(multiplier_out)\n    );\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            P_output <= 0;\n        end else begin\n            if (EN) begin\n                P_output <= multiplier_out;\n            end else begin\n                P_output <= 0;\n            end\n        end\n    end\n    \nendmodule\n\nmodule decoder_2to4_with_enable (\n    input A,\n    input B,\n    input EN,\n    output reg [3:0] Y\n);\n    \n    always @* begin\n        case ({A,B,EN})\n            3'b000: Y = 4'b0001;\n            3'b001: Y = 4'b0010;\n            3'b010: Y = 4'b0100;\n            3'b011: Y = 4'b1000;\n            3'b1xx: Y = 4'b0000;\n        endcase\n    end\n    \nendmodule\n\nmodule booth_multiplier (\n    input clk,\n    input reset,\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output reg signed [7:0] P\n);\n    \n    reg signed [7:0] P_reg;\n    reg signed [3:0] A_reg;\n    reg signed [3:0] B_reg;\n    reg [2:0] state;\n    \n    always @* begin\n        P = P_reg;\n    end\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            P_reg <= 0;\n            A_reg <= 0;\n            B_reg <= 0;\n            state <= 3'b000;\n        end else begin\n            case (state)\n                3'b000: begin\n                    if (B[0] == 1) begin\n                        P_reg <= -A;\n                    end else begin\n                        P_reg <= A;\n                    end\n                    A_reg <= A;\n                    B_reg <= B;\n                    state <= 3'b001;\n                end\n                3'b001: begin\n                    if (B[0] == 1 && B[1] == 0) begin\n                        P_reg <= P_reg - (A_reg << 1);\n                    end else if (B[0] == 0 && B[1] == 1) begin\n                        P_reg <= P_reg + (A_reg << 1);\n                    end\n                    A_reg <= A_reg << 1;\n                    B_reg <= B >> 1;\n                    state <= 3'b010;\n                end\n                3'b010: begin\n                    if (B[0] == 1) begin\n                        P_reg <= P_reg - B_reg;\n                    end else if (B[0] == 0) begin\n                        P_reg <= P_reg + B_reg;\n                    end\n                    A_reg <= A_reg;\n                    B_reg <= B_reg >> 1;\n                    state <= 3'b011;\n                end\n                3'b011: begin\n                    state <= 3'b000;\n                end\n            endcase\n        end\n    end\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "8ead3e6bf2a0b65bec293a75b014e3b3",
        "dataset_index": 10745
      },
      "top__6b8a0673": {
        "rtl_code": "\nmodule top_module (\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input [3:0] d,\n    input [1:0] sel,\n    output [3:0] out_mux\n);\n\nwire [3:0] mux1_out;\nwire [3:0] mux2_out;\n\n// 2-to-1 multiplexer instances\nmux2to1 mux1({a[3], a[2], a[1], a[0]}, {b[3], b[2], b[1], b[0]}, sel[0], mux1_out);\nmux2to1 mux2({c[3], c[2], c[1], c[0]}, {d[3], d[2], d[1], d[0]}, sel[0], mux2_out);\n\n\n// 2-to-1 multiplexer for final output\nmux2to1 mux3(mux1_out, mux2_out, sel[1], out_mux);\n\nendmodule\n\nmodule mux2to1 (\n    input [3:0] a,\n    input [3:0] b,\n    input sel,\n    output [3:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "6b8a0673aa7ac339e4745624004db25c",
        "dataset_index": 2514
      },
      "sffsrce_fdre_cbbc0b83": {
        "rtl_code": "\nmodule sffsrce_fdre (\n  output Q,\n  input C,\n  input CE,\n  input D,\n  input R,\n  input SET,\n  input RESET\n);\n\n  reg Q_int;\n\n  always @(posedge C) begin\n    if (CE) begin\n      if (SET)\n        Q_int <= 1'b1;\n      else if (RESET)\n        Q_int <= 1'b0;\n      else if (R)\n        Q_int <= D;\n    end\n  end\n\n  assign Q = Q_int;\n\nendmodule\n\nmodule FFAR (\n  output Q,\n  input C,\n  input CE,\n  input D,\n  input R\n);\n\n  wire S;\n  wire Rn;\n  wire Dn;\n\n  assign S = 1'b0;\n  assign Rn = R;\n  assign Dn = D;\n\n  sffsrce_fdre sffsrce (\n    .Q(Q),\n    .C(C),\n    .CE(CE),\n    .D(Dn),\n    .R(Rn),\n    .SET(S),\n    .RESET(S)\n  );\n\nendmodule\n",
        "module_name": "sffsrce_fdre",
        "module_hash": "cbbc0b8312c6a2f650b7677b02d5e35c",
        "dataset_index": 15394
      },
      "dyn_pll_ctrl #_2ca54cb1": {
        "rtl_code": "module dyn_pll_ctrl # (parameter SPEED_MHZ = 25, parameter SPEED_LIMIT = 100, parameter SPEED_MIN = 25, parameter OSC_MHZ = 100)\n\t(clk,\n\tclk_valid,\n\tspeed_in,\n\tstart,\n\tprogclk,\n\tprogdata,\n\tprogen,\n\treset,\n\tlocked,\n\tstatus);\n\n\tinput clk;\t\t\t\tinput clk_valid;\t\tinput [7:0] speed_in;\n\tinput start;\n\toutput reg progclk = 0;\n\toutput reg progdata = 0;\n\toutput reg progen = 0;\n\toutput reg reset = 0;\n\tinput locked;\n\tinput [2:1] status;\n\n\treg [23:0] watchdog = 0;\n\treg [7:0] state = 0;\n\treg [7:0] dval = OSC_MHZ;\treg [7:0] mval = SPEED_MHZ;\n\treg start_d1 = 0;\n\t\n\talways @ (posedge clk)\n\tbegin\n\t\tprogclk <= ~progclk;\n\t\tstart_d1 <= start;\n\t\treset <= 1'b0;\n\t\t\n\t\tif (locked)\n\t\t\twatchdog <= 0;\n\t\telse\n\t\t\twatchdog <= watchdog + 1'b1;\n\t\t\n\t\tif (watchdog[23])\t\tbegin\t\t\t\t\twatchdog <= 0;\n\t\t\treset <= 1'b1;\t\tend\n\t\t\n\t\tif (~clk_valid)\t\t\tbegin\n\t\t\tprogen <= 0;\n\t\t\tprogdata <= 0;\n\t\t\tstate <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\n\t\t\tif ((start || start_d1) && state==0 && speed_in >= SPEED_MIN && speed_in <= SPEED_LIMIT && progclk==1)\tbegin\n\t\t\t\tprogen <= 0;\n\t\t\t\tprogdata <= 0;\n\t\t\t\tmval <= speed_in;\n\t\t\t\tdval <= OSC_MHZ;\n\t\t\t\tstate <= 1;\n\t\t\tend\n\t\t\tif (state != 0)\n\t\t\t\tstate <= state + 1'd1;\n\t\t\tcase (state)\t\t2: begin\n\t\t\t\t\tprogen <= 1;\n\t\t\t\t\tprogdata <= 1;\n\t\t\t\tend\n\t\t\t\t4: begin\n\t\t\t\t\tprogdata <= 0;\n\t\t\t\tend\n\t\t\t\t6,8,10,12,14,16,18,20: begin\n\t\t\t\t\tprogdata <= dval[0];\n\t\t\t\t\tdval[6:0] <= dval[7:1];\n\t\t\t\tend\n\t\t\t\t22: begin\n\t\t\t\t\tprogen <= 0;\n\t\t\t\t\tprogdata <= 0;\n\t\t\t\tend\n\t\t\t\t32: begin\n\t\t\t\t\tprogen <= 1;\n\t\t\t\t\tprogdata <= 1;\n\t\t\t\tend\n\t\t\t\t36,38,40,42,44,46,48,50: begin\n\t\t\t\t\tprogdata <= mval[0];\n\t\t\t\t\tmval[6:0] <= mval[7:1];\n\t\t\t\tend\n\t\t\t\t52: begin\n\t\t\t\t\tprogen <= 0;\n\t\t\t\t\tprogdata <= 0;\n\t\t\t\tend\n\t\t\t\t62: begin\n\t\t\t\t\tprogen <= 1;\n\t\t\t\tend\n\t\t\t\t64: begin\n\t\t\t\t\tprogen <= 0;\n\t\t\t\tend\n\t\t\t\t254: begin\n\t\t\t\t\tstate <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n",
        "module_name": "dyn_pll_ctrl #",
        "module_hash": "2ca54cb1e312698a1584c378947f710b",
        "dataset_index": 4108
      },
      "top_module_85835a2f": {
        "rtl_code": "\nmodule top_module(\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    output wire [15:0] final_out\n);\n\nwire [15:0] mux_out;\nwire [7:0] sel;\n\n// Combinational Circuit from Problem 2\ncomb_circuit cc (\n    .in(in),\n    .out_hi(out_hi),\n    .out_lo(out_lo)\n);\n\n// 256-to-1 Multiplexer from Problem 1\nmux_256to1 mux (\n    .in(in),\n    .sel(sel),\n    .out(mux_out)\n);\n\n// Additional Functional Module\nadder add (\n    .in1(out_hi),\n    .in2(out_lo),\n    .out(final_out)\n);\n\nendmodule\nmodule comb_circuit (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule\nmodule mux_256to1 (\n    input wire [15:0] in,\n    input wire [7:0] sel,\n    output wire [15:0] out\n);\n    assign out = in << (sel * 8);\nendmodule\nmodule adder (\n    input wire [7:0] in1,\n    input wire [7:0] in2,\n    output wire [15:0] out\n);\n    assign out = in1 + in2;\nendmodule",
        "module_name": "top_module",
        "module_hash": "85835a2f24c191e9d4f3b2e6d5999916",
        "dataset_index": 3270
      },
      "mux2_99a374dc": {
        "rtl_code": "module mux2 (\n    X ,\n    A0,\n    A1,\n    S\n);\n\n    output X ;\n    input  A0;\n    input  A1;\n    input  S ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign X = (S == 1'b1) ? A1 : A0;\n\nendmodule",
        "module_name": "mux2",
        "module_hash": "99a374dc64b63c80324bbe5b3f92a3f3",
        "dataset_index": 19008
      },
      "XOR2_abc49bf5": {
        "rtl_code": "module XOR2(\n    input a,\n    input b,\n    output c\n);\n\n    assign c = a ^ b;\n\nendmodule\n\nmodule XOR3(\n    input i0,\n    input i1,\n    input i2,\n    output o\n);\n\n    wire w1, w2;\n\n    XOR2 x1(\n        .a(i0),\n        .b(i1),\n        .c(w1)\n    );\n\n    XOR2 x2(\n        .a(w1),\n        .b(i2),\n        .c(o)\n    );\n\nendmodule",
        "module_name": "XOR2",
        "module_hash": "abc49bf58493b4951c54181a80c2a352",
        "dataset_index": 5611
      },
      "multiplier_c3783560": {
        "rtl_code": "\nmodule multiplier (\n  input [n-1:0] A,\n  input [n-1:0] B,\n  input ctrl,\n  output [2*n-1:0] P\n);\n\nparameter n = 8; // number of bits in the input numbers\n\ninteger i;\n\nreg [2*n-1:0] temp;\n\nassign P = temp;\n\nalways @(*) begin\n  if (ctrl == 0) begin // unsigned multiplication\n    temp = 0; // initialize P to 0\n    for (i = 0; i < n; i = i + 1) begin\n      if (B[i] == 1) begin\n        temp = temp + (A << i);\n      end\n    end\n  end\n  else begin // signed multiplication\n    temp = 0; // initialize P to 0\n    if (A[n-1] == 1) begin // sign extend A\n      temp = {{(n){1'b1}}, A};\n    end\n    else begin\n      temp = A;\n    end\n    if (B[n-1] == 1) begin // sign extend B\n      temp = temp + ({{(n){1'b1}}, B} << n);\n    end\n    else begin\n      temp = temp + (B << n);\n    end\n    // Booth's algorithm for signed multiplication\n    for (i = 0; i < n-1; i = i + 1) begin\n      if (B[i] == 1 && B[i+1] == 0) begin // 01 pattern\n        temp = temp - (A << (i+1));\n      end\n      else if (B[i] == 0 && B[i+1] == 1) begin // 10 pattern\n        temp = temp + (A << (i+1));\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "c37835602476e2b0594b8b54f4dc3363",
        "dataset_index": 13138
      },
      "ethtx_realign_d4d586c7": {
        "rtl_code": "module ethtx_realign\n   (input clk, input reset, input clear,\n    input [35:0] datain, input src_rdy_i, output dst_rdy_o,\n    output [35:0] dataout, output src_rdy_o, input dst_rdy_i);\n\n   reg [1:0] \t  state;\n   reg [15:0] \t  held;\n   reg [1:0] \t  held_occ;\n   reg \t\t  held_sof;\n   \n   wire \t  xfer_in = src_rdy_i & dst_rdy_o;\n   wire \t  xfer_out = src_rdy_o & dst_rdy_i;\n\n   wire \t  sof_in = datain[32];\n   wire \t  eof_in = datain[33];\n   wire [1:0] \t  occ_in = datain[35:34];\n   wire \t  occ_low = occ_in[1] ^ occ_in[0]; always @(posedge clk)\n     if(reset | clear)\n       begin\n\t  held <= 0;\n\t  held_occ <= 0;\n\t  held_sof <= 0;\n       end\n     else if(xfer_in)\n       begin\n\t  held <= datain[15:0];\n\t  held_occ <= occ_in;\n\t  held_sof <= sof_in;\n       end\n   \n   localparam RE_IDLE = 0;\n   localparam RE_HELD = 1;\n   localparam RE_DONE = 2;\n\n   always @(posedge clk)\n     if(reset | clear)\n       state <= RE_IDLE;\n     else\n       case(state)\n\t RE_IDLE :\n\t   if(xfer_in & eof_in)\n\t     state <= RE_DONE;\n\t   else if(xfer_in & sof_in)\n\t     state <= RE_HELD;\n\n\t RE_HELD :\n\t   if(xfer_in & xfer_out & eof_in)\n\t     if(occ_low)\n\t       state <= RE_IDLE;\n\t     else\n\t       state <= RE_DONE;\n\n\t RE_DONE :\n\t   if(xfer_out)\n\t     state <= RE_IDLE;\n\t \n       endcase wire sof_out = held_sof;\n   wire eof_out = (state == RE_HELD)? (eof_in & occ_low) : (state == RE_DONE);\n   wire [1:0] occ_out = ((state == RE_DONE)? held_occ : occ_in) ^ 2'b10; assign dataout = {occ_out,eof_out,sof_out,held,datain[31:16]};\n   assign src_rdy_o = (state == RE_HELD)? src_rdy_i : (state == RE_DONE);\n   assign dst_rdy_o = (state == RE_HELD)? dst_rdy_i : (state == RE_IDLE);\n\nendmodule ",
        "module_name": "ethtx_realign",
        "module_hash": "d4d586c76b69ad3ec8cee3ba5ad4919c",
        "dataset_index": 24353
      },
      "mux16x8_859e7ab6": {
        "rtl_code": "`ifndef _MUX\n`define _MUX\n\nmodule mux16x8(data0, data1, data2, data3, data4, data5, data6, data7, selectInput, out);  output reg [15:0] out;\n\tinput  [15:0] data0, data1, data2, data3, data4, data5, data6, data7;\n\tinput  [2:0] selectInput;\n\t\n\talways@(data0 or data1 or data2 or data3 or data4 or data5 or data6 or data7 or selectInput) begin\n\t\tcase(selectInput)\n\t\t\t0: out = data0;\n\t\t\t1: out = data1;\n\t\t\t2: out = data2;\n\t\t\t3: out = data3;\n\t\t\t4: out = data4;\n\t\t\t5: out = data5;\n\t\t\t6: out = data6;\n\t\t\t7: out = data7;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule mux16x4(data0, data1, data2, data3, selectInput, out);  output reg [15:0] out;\n\tinput  [15:0] data0, data1, data2, data3;\n\tinput  [1:0] selectInput;\n\t\n\talways@(data0 or data1 or data2 or data3 or selectInput) begin\n\t\tcase(selectInput)\n\t\t\t0: out = data0;\n\t\t\t1: out = data1;\n\t\t\t2: out = data2;\n\t\t\t3: out = data3;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule mux16x2(data0, data1, selectInput, out);  output reg [15:0] out;\n\tinput  [15:0] data0, data1;\n\tinput  selectInput;\n\t\n\talways@(data0 or data1 or selectInput) begin\n\t\tcase(selectInput)\n\t\t\t0: out = data0;\n\t\t\t1: out = data1;\n\t\tendcase\n\tend\n\t\nendmodule\n\n`endif\n",
        "module_name": "mux16x8",
        "module_hash": "859e7ab611f644a1f567bbc804109f22",
        "dataset_index": 22480
      },
      "emesh_if_2b2eb211": {
        "rtl_code": "module emesh_if (\n   cmesh_wait_out, cmesh_access_out, cmesh_packet_out, rmesh_wait_out,\n   rmesh_access_out, rmesh_packet_out, xmesh_wait_out,\n   xmesh_access_out, xmesh_packet_out, emesh_wait_out,\n   emesh_access_out, emesh_packet_out,\n   cmesh_access_in, cmesh_packet_in, cmesh_wait_in, rmesh_access_in,\n   rmesh_packet_in, rmesh_wait_in, xmesh_access_in, xmesh_packet_in,\n   xmesh_wait_in, emesh_access_in, emesh_packet_in, emesh_wait_in\n   );\n\n   parameter AW   = 32;   \n   parameter PW   = 2*AW+40; \n\n   input \t   cmesh_access_in;\n   input [PW-1:0]  cmesh_packet_in;\n   output \t   cmesh_wait_out;\n   output \t   cmesh_access_out;\n   output [PW-1:0] cmesh_packet_out;\n   input \t   cmesh_wait_in;\n      \n   input \t   rmesh_access_in;\n   input [PW-1:0]  rmesh_packet_in;\n   output \t   rmesh_wait_out;\n   output \t   rmesh_access_out;\n   output [PW-1:0] rmesh_packet_out;\n   input \t   rmesh_wait_in;\n   \n   input \t   xmesh_access_in;\n   input [PW-1:0]  xmesh_packet_in;\n   output \t   xmesh_wait_out;  \n   output \t   xmesh_access_out;\n   output [PW-1:0] xmesh_packet_out;\n   input \t   xmesh_wait_in;\n   \n   input \t   emesh_access_in;\n   input [PW-1:0]  emesh_packet_in;\n   output \t   emesh_wait_out;\n   \n   output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n   input \t   emesh_wait_in;\n      \n   assign cmesh_access_out = emesh_access_in & emesh_packet_in[0];\n\n   assign rmesh_access_out = emesh_access_in & ~emesh_packet_in[0];\n\n   assign xmesh_access_out = 1'b0;\n      \n   assign cmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\t \n   assign rmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\t \n   assign xmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\n\n\n   assign emesh_wait_out = cmesh_wait_in |\n\t\t\t   rmesh_wait_in |\n\t\t\t   xmesh_wait_in;\n  \t \t \n   assign emesh_access_out = cmesh_access_in |\n\t\t\t     rmesh_access_in |\n\t\t\t     xmesh_access_in;\n   \n\n   assign emesh_packet_out[PW-1:0] = cmesh_access_in ? cmesh_packet_in[PW-1:0] :\n\t\t\t\t     rmesh_access_in ? rmesh_packet_in[PW-1:0] :\n\t\t\t\t                       xmesh_packet_in[PW-1:0];\n   \n   assign cmesh_wait_out = (cmesh_access_in & emesh_wait_in);\n   \n\n   assign rmesh_wait_out = rmesh_access_in & \n\t\t\t   (emesh_wait_in | cmesh_access_in);\n\t\t\t\t\n\n   assign xmesh_wait_out = xmesh_access_in & \n\t\t\t   (emesh_wait_in | cmesh_access_in | rmesh_access_in);\n   \n\t\t\t\t     \nendmodule ",
        "module_name": "emesh_if",
        "module_hash": "2b2eb21199bb90517e7690a32c0f2c2b",
        "dataset_index": 24882
      },
      "HammingDecoder_df672b20": {
        "rtl_code": "module HammingDecoder(H, D);\n\tinput [6:0] H;\n\toutput [3:0] D;\n\t\n\tassign D[3] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0])  ? ~H[6] : H[6];\n\tassign D[2] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&!(H[6]^H[4]^H[3]^H[0]) ? ~H[5] : H[5];\n\tassign D[1] = (H[6]^H[5]^H[4]^H[2])&!(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[4] : H[4];\n\tassign D[0] = !(H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[3] : H[3];\n\nendmodule",
        "module_name": "HammingDecoder",
        "module_hash": "df672b20cacbcaf9ba4bdee84bb44624",
        "dataset_index": 18550
      },
      "five_bit_module_f37c8e66": {
        "rtl_code": "module five_bit_module(\n    input clk,\n    input reset,\n    input [4:0] input_signal,\n    output reg [4:0] output_signal\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        output_signal <= 0;\n    end else begin\n        if (input_signal == 0) begin\n            output_signal <= 0;\n        end else if (input_signal % 2 == 0) begin\n            output_signal <= input_signal + 1;\n        end else begin\n            output_signal <= input_signal - 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "five_bit_module",
        "module_hash": "f37c8e661ed805abc507375cec55ca28",
        "dataset_index": 11222
      },
      "bitwise_or_multiplier_b759e5b1": {
        "rtl_code": "\nmodule bitwise_or_multiplier(\n    input wire [7:0] byte1,\n    input wire [7:0] byte2,\n    output wire [15:0] result\n);\n\n    // Perform the bitwise OR operation on the two input bytes\n    wire [7:0] or_result;\n    assign or_result = byte1 | byte2;\n\n    // Multiply the OR result by a constant value\n    parameter constant_value = 42;\n    assign result = or_result * constant_value;\n\nendmodule\n\nmodule top_module( \n    input wire [7:0] byte1,\n    input wire [7:0] byte2,\n    output wire [15:0] result );\n\n    // Instantiate the bitwise OR multiplier module\n    bitwise_or_multiplier or_multiplier(\n        .byte1(byte1),\n        .byte2(byte2),\n        .result(result)\n    );\n\nendmodule\n",
        "module_name": "bitwise_or_multiplier",
        "module_hash": "b759e5b1cf94077b461dbdfbf71718cf",
        "dataset_index": 19965
      },
      "FSM #_f44cfede": {
        "rtl_code": "module FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n) (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\n\nparameter s = 4; // number of states\nparameter t = 8; // number of transitions\n\nreg [s-1:0] state;\nreg [n-1:0] input_reg;\nwire [m-1:0] output_wire;\n\n// Define the states\nparameter STATE_0 = 2'b00;\nparameter STATE_1 = 2'b01;\nparameter STATE_2 = 2'b10;\nparameter STATE_3 = 2'b11;\n\n// Define the transitions\nparameter TRANSITION_0 = 3'b000;\nparameter TRANSITION_1 = 3'b001;\nparameter TRANSITION_2 = 3'b010;\nparameter TRANSITION_3 = 3'b011;\nparameter TRANSITION_4 = 3'b100;\nparameter TRANSITION_5 = 3'b101;\nparameter TRANSITION_6 = 3'b110;\nparameter TRANSITION_7 = 3'b111;\n\n// Define the output functions\nassign output_wire[0] = (state == STATE_0) ? (input_reg[0] & input_reg[1]) : (input_reg[2] | input_reg[3]);\nassign output_wire[1] = (state == STATE_2) ? (input_reg[0] ^ input_reg[1]) : (input_reg[2] & input_reg[3]);\n\n// Define the state transitions\nalways @ (input_reg or state) begin\n  case ({state, input_reg})\n    TRANSITION_0: state <= STATE_0;\n    TRANSITION_1: state <= STATE_1;\n    TRANSITION_2: state <= STATE_2;\n    TRANSITION_3: state <= STATE_3;\n    TRANSITION_4: state <= STATE_0;\n    TRANSITION_5: state <= STATE_1;\n    TRANSITION_6: state <= STATE_2;\n    TRANSITION_7: state <= STATE_3;\n    default: state <= state;\n  endcase\nend\n\n// Assign the input signals to the input register\nalways @ (in) begin\n  input_reg <= in;\nend\n\n// Assign the output wire to the output signals\nassign out = output_wire;\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "f44cfedefcfa182a7375560483456ee2",
        "dataset_index": 1656
      },
      "NormaliseProdMultDescale_88732770": {
        "rtl_code": "\nmodule NormaliseProdMultDescale(\n\tinput [32:0] zout_Multiply,\n\tinput [49:0] productout_Multiply,\n   input [7:0] InsTagMultiply,\n\tinput ScaleValidMultiply,\n\tinput [31:0] z_Multiply,\n\tinput clock,\n\tinput idle_Multiply,\n\toutput reg idle_NormaliseProd,\n\toutput reg [32:0] zout_NormaliseProd,\n\toutput reg [49:0] productout_NormaliseProd,\n\toutput reg [7:0] InsTagNormaliseProd,\n\toutput reg ScaleValidNormaliseProd,\n\toutput reg [31:0] z_NormaliseProd\n   );\n\nparameter no_idle = 1'b0,\n\t\t\t put_idle = 1'b1;\n\nwire z_sign;\nwire [7:0] z_exponent;\nwire [26:0] z_mantissa;\n\nassign z_sign = zout_Multiply[32];\nassign z_exponent = zout_Multiply[31:24];\nassign z_mantissa = {zout_Multiply[23:0]};\n\nalways @ (posedge clock) begin\n\t\n\tz_NormaliseProd <= z_Multiply;\n\tScaleValidNormaliseProd <= ScaleValidMultiply;\n\tInsTagNormaliseProd <= InsTagMultiply;\n\tidle_NormaliseProd <= idle_Multiply;\n\t\n\tif (idle_Multiply == no_idle) begin\n\t\n\t\tif ($signed(z_exponent) < -126) begin\n\t\t\tzout_NormaliseProd[32] <= z_sign;\n         zout_NormaliseProd[31:24] <= z_exponent + 1;\n\t\t\tzout_NormaliseProd[23:0]  <= z_mantissa;\n         productout_NormaliseProd <= productout_Multiply >> 1;\n\t\tend\n\t\t\t\n\t\telse if (productout_Multiply[49] == 0) begin\n\t\t\tzout_NormaliseProd[32] <= z_sign;\n\t\t\tzout_NormaliseProd[31:24] <= z_exponent - 1;\n\t\t\tzout_NormaliseProd[23:0] <= {productout_Multiply[48:25]};\n\t\t\tproductout_NormaliseProd <= productout_Multiply << 1;\n\t\tend\n\t\t\n\t\telse begin\n\t\t\tzout_NormaliseProd[32] <= z_sign;\n\t\t\tzout_NormaliseProd[31:24] <= z_exponent;\n\t\t\tzout_NormaliseProd[23:0] <= {productout_Multiply[49:26]};\n\t\t\tproductout_NormaliseProd <= productout_Multiply;\n\t\tend\t\n\tend\n\t\n\telse begin\n\t\tzout_NormaliseProd <= zout_Multiply;\n\tend\n\t\nend\n\nendmodule\n",
        "module_name": "NormaliseProdMultDescale",
        "module_hash": "88732770eb438ca66efb83755807bfd8",
        "dataset_index": 23238
      },
      "delay__a761ca0d": {
        "rtl_code": "\nmodule delay_module (\n    input clk,\n    input A,\n    input [3:0] delay_val,\n    output reg X\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (counter == delay_val) begin\n        X <= A;\n    end else begin\n        X <= X;\n    end\n    counter <= counter + 1;\nend\n\nendmodule\n",
        "module_name": "delay_",
        "module_hash": "a761ca0d40de312dd794fbef3c0fdf03",
        "dataset_index": 17817
      },
      "eim_burstcnt_547920c6": {
        "rtl_code": "module eim_burstcnt(\n\t\t    input wire bclk,\n\n\t\t    input wire [15:0] bus_ad, input wire [2:0] bus_a, input wire adv, input wire rw,  input wire cs,  output reg [15:0] measured_burst\n\t\t    );\n\n   reg \t\t\t\t activated;\n   reg [15:0] \t\t\t bus_ad_r;\n   reg \t\t\t\t cs_r;\n   reg [2:0] \t\t\t bus_a_r;\n   reg \t\t\t\t rw_r;\n   reg \t\t\t\t adv_r;\n\n   reg [15:0] \t\t\t burstcnt;\n   reg [15:0] \t\t\t finalcnt;\n\n   reg \t\t\t\t activated_d;\n   \n   always @(posedge bclk) begin\n      bus_ad_r <= bus_ad;\n      bus_a_r <= bus_a;\n      cs_r <= cs;\n      rw_r <= rw;\n      adv_r <= adv;\n      \n      if( cs_r && adv_r && ({bus_a_r, bus_ad_r[15:12]} == 7'h4_F) ) begin activated <= 1'b1;\n      end else if( !cs_r ) begin\n\t activated <= 1'b0;\n      end else begin\n\t activated <= activated;\n      end if( !activated ) begin\n\t finalcnt <= burstcnt;\n\t burstcnt <= 16'h0;\n      end else begin\n\t burstcnt <= burstcnt + 16'h1;\n\t finalcnt <= finalcnt;\n      end\n\n      activated_d <= activated;\n      if( activated_d & !activated ) begin measured_burst <= finalcnt + 1'b1; end else begin\n\t measured_burst <= measured_burst;\n      end\n   end endmodule ",
        "module_name": "eim_burstcnt",
        "module_hash": "547920c6cb2b5be0c7405b6489b7f4cc",
        "dataset_index": 13644
      },
      "ps2_rx_5ca2b415": {
        "rtl_code": "module ps2_rx\n   (\n    input wire clk, reset,\n    input wire ps2d, ps2c, rx_en,\n    output reg rx_done_tick,\n    output wire [7:0] dout\n   );\n\n   localparam [1:0]\n      idle = 2'b00,\n      dps  = 2'b01,\n      load = 2'b10;\n\n   reg [1:0] state_reg, state_next;\n   reg [7:0] filter_reg;\n   wire [7:0] filter_next;\n   reg f_ps2c_reg;\n   wire f_ps2c_next;\n   reg [3:0] n_reg, n_next;\n   reg [10:0] b_reg, b_next;\n   wire fall_edge;\n\n   always @(posedge clk, posedge reset)\n   if (reset)\n      begin\n         filter_reg <= 0;\n         f_ps2c_reg <= 0;\n      end\n   else\n      begin\n         filter_reg <= filter_next;\n         f_ps2c_reg <= f_ps2c_next;\n      end\n\n   assign filter_next = {ps2c, filter_reg[7:1]};\n   assign f_ps2c_next = (filter_reg==8'b11111111) ? 1'b1 :\n                        (filter_reg==8'b00000000) ? 1'b0 :\n                         f_ps2c_reg;\n   assign fall_edge = f_ps2c_reg & ~f_ps2c_next;\n\n   always @(posedge clk, posedge reset)\n      if (reset)\n         begin\n            state_reg <= idle;\n            n_reg <= 0;\n            b_reg <= 0;\n         end\n      else\n         begin\n            state_reg <= state_next;\n            n_reg <= n_next;\n            b_reg <= b_next;\n         end\n   always @*\n   begin\n      state_next = state_reg;\n      rx_done_tick = 1'b0;\n      n_next = n_reg;\n      b_next = b_reg;\n      case (state_reg)\n         idle:\n            if (fall_edge & rx_en)\n               begin\n                  b_next = {ps2d, b_reg[10:1]};\n                  n_next = 4'b1001;\n                  state_next = dps;\n               end\n         dps: if (fall_edge)\n               begin\n                  b_next = {ps2d, b_reg[10:1]};\n                  if (n_reg==0)\n                     state_next = load;\n                  else\n                     n_next = n_reg - 1;\n               end\n         load: begin\n               state_next = idle;\n               rx_done_tick = 1'b1;\n            end\n      endcase\n   end\n   assign dout = b_reg[8:1]; endmodule",
        "module_name": "ps2_rx",
        "module_hash": "5ca2b4150d5e042d20246ab04bc11659",
        "dataset_index": 4778
      },
      "alu_634589d3": {
        "rtl_code": "\nmodule alu (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] OP,\n    output reg [3:0] Y,\n    input clk\n);\n\nreg [3:0] A_reg, B_reg, Y_reg;\nreg [1:0] stage;\n\nalways @(posedge clk) begin\n    case (stage)\n        0: begin\n            A_reg <= A;\n            B_reg <= B;\n            case (OP)\n                3'b000: Y_reg <= A_reg + B_reg;\n                3'b001: Y_reg <= A_reg - B_reg;\n                3'b010: Y_reg <= A_reg & B_reg;\n                3'b011: Y_reg <= A_reg | B_reg;\n                3'b100: Y_reg <= A_reg ^ B_reg;\n            endcase\n            stage <= 1;\n        end\n        1: begin\n            Y <= Y_reg;\n            stage <= 0;\n        end\n    endcase\nend\n\nendmodule\n",
        "module_name": "alu",
        "module_hash": "634589d34bd48f7b1d8f1e1f5c78079b",
        "dataset_index": 20000
      },
      "Vector_0e116037": {
        "rtl_code": "module Vector(a, b, c);\n\n\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// I/O declarations\n\n\t\n\tinput wire[1:0] a;\n\n\t\n\tinput wire[1:0] b;\n\n\t\n\toutput wire[1:0] c;\n\n\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// The actual logic\n\n\tassign c = a & b;\n\nendmodule",
        "module_name": "Vector",
        "module_hash": "0e11603787718a34be0e42a35fedde81",
        "dataset_index": 4304
      },
      "non_posted_pkt_builder_277c80d1": {
        "rtl_code": "\n\nmodule non_posted_pkt_builder(\n    input clk,\n    input rst,\n    input [15:0] req_id, input go,\n    output reg ack,\n    input [63:0] dmaras,\n    input [31:0] dmarad,\n    input [9:0] length,\n\t input isDes,\n    input [7:0] tag_value,\n    input tag_gnt,\n    output reg tag_inc,\n    output reg [63:0] header_data_out,\n    output reg header_data_wren,\n    output reg [4:0] tx_waddr,\n    output reg [31:0] tx_wdata,\n    output reg tx_we\n);\n\nlocalparam IDLE = 4'h0; \nlocalparam HEAD1 = 4'h1; \nlocalparam HEAD2 = 4'h2;    \nlocalparam WAIT_FOR_GO_DEASSERT = 4'h3;\n\nlocalparam rsvd = 1'b0; localparam MRd = 5'b00000; localparam TC = 3'b000;    localparam TD = 1'b0;      localparam EP = 1'b0;      localparam ATTR = 2'b00;     localparam LastBE = 4'b1111; localparam FirstBE = 4'b1111;wire [1:0] fmt;\nreg [3:0] state;\nreg [63:0] dmaras_reg;\nreg [31:0] dmarad_reg;\n\n\nreg   rst_reg;\nalways@(posedge clk) rst_reg <= rst;\n\n\nassign fmt[1:0] = (dmaras_reg[63:32] == 0) ? 2'b00 : 2'b01;\n\nalways@(posedge clk)begin\n  if(rst_reg)begin\n    dmaras_reg[63:0] <= 0;\n  end else if(go)begin\n    dmaras_reg <= dmaras;\n  end\nend\n\nalways@(posedge clk)begin\n  if(rst_reg)begin\n    dmarad_reg[31:0] <= 0;\n  end else if(go)begin\n    dmarad_reg <= dmarad;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (rst_reg) begin\n      header_data_out <= 0;\n      header_data_wren <= 1'b0;\n      ack <= 1'b0;\n      tag_inc <=1'b0;   \n      tx_waddr[4:0] <= 0;\n      tx_wdata[31:0] <= 0;\n      tx_we <= 1'b0;\n      state <= IDLE;\n  end else begin\n      case (state)\n        IDLE : begin\n           header_data_out <= 0;\n           header_data_wren <= 1'b0;\n           ack <= 1'b0;\n           tag_inc <=1'b0;   \n           tx_waddr[4:0] <= 0;\n           tx_wdata[31:0] <= 0;\n           tx_we <= 1'b0;\n           if(go)\n             state<= HEAD1;\n           else\n             state<= IDLE;\n         end\n         HEAD1 : begin\n           header_data_out <= {rsvd,fmt[1:0],MRd,rsvd,TC,rsvd,rsvd,rsvd,rsvd,\n                               TD,EP,ATTR,rsvd,rsvd,length[9:0],req_id[15:0],\n                               tag_value[7:0],LastBE,FirstBE};\n           ack <= 0;\n           tag_inc <=1'b0;   \n           tx_waddr[4:0] <= 0;\n           tx_wdata[31:0] <= 0;\n           tx_we <= 1'b0;\n           if(tag_gnt == 1'b0)begin\n             state <= HEAD1;\n             header_data_wren <= 1'b0;\n           end else begin\n             header_data_wren <= 1'b1;\n             state <= HEAD2;\n           end\n         end\n         HEAD2 : begin\n             header_data_out <= (fmt[0]==1'b1) \n                                ? {dmaras_reg[63:2],2'b00} \n                                : {dmaras_reg[31:2], 2'b00, dmaras_reg[63:32]};\n             header_data_wren <= 1'b1;\n             tx_waddr[4:0] <= tag_value[4:0];\ntx_wdata[31:0] <= {isDes,9'b0_0000_0000,dmarad_reg[27:6]};\n             tx_we <= 1'b1;\n             ack <= 1'b1; tag_inc <=1'b1;state <= WAIT_FOR_GO_DEASSERT;\n         end\n         WAIT_FOR_GO_DEASSERT : begin\n             header_data_wren <= 1'b0;\n             tx_we <= 1'b0;\n             tag_inc <=1'b0; \n             ack <= 1'b0;                \n             state <= IDLE;\n         end\n         default : begin\n             header_data_out <= 0;\n             header_data_wren <= 1'b0;\n             ack <= 1'b0;\n             tag_inc <=1'b0;  \n             tx_waddr[4:0] <= 0;\n             tx_wdata[31:0] <= 0;\n             tx_we <= 1'b0;\n             state <= IDLE;\n         end\n      endcase\n   end\n end\nendmodule\n",
        "module_name": "non_posted_pkt_builder",
        "module_hash": "277c80d10474ce47059a66db806de097",
        "dataset_index": 25824
      },
      "eb_fifo_ctrl #_e7669798": {
        "rtl_code": "module eb_fifo_ctrl #(\n    parameter DEPTHMO = 4'd15,\n    parameter DEPTHLOG2MO = 3\n) (\n    input               t_0_req,\n    output              t_0_ack,\n    output reg          i_0_req,\n    input               i_0_ack,\n    output reg  [DEPTHLOG2MO : 0] wr_ptr,\n    output wire [DEPTHLOG2MO : 0] rd_ptr,\n    output  wen, ren,\n    input   clk, reset_n\n);\n\nreg [DEPTHLOG2MO : 0] status_cnt;\nreg [DEPTHLOG2MO : 0] q_rd_ptr;\n\nassign t_0_ack = !(status_cnt == DEPTHMO);\nassign ren = 1;\nassign wen = t_0_req && t_0_ack;\n\nalways @(posedge clk or negedge reset_n)\n    if (~reset_n) i_0_req <= 1'b0;\n    else if (status_cnt == 0 && !(t_0_req && t_0_ack)) i_0_req <= 0;\n    else if ((i_0_req && i_0_ack)  && !(t_0_req && t_0_ack) && (status_cnt == 1)) i_0_req <= 0;\n    else i_0_req <= 1;\n\nalways @(posedge clk or negedge reset_n)\n    if (~reset_n) wr_ptr <= 0;\n    else if (t_0_req && t_0_ack) wr_ptr <= (wr_ptr == DEPTHMO) ? 0 : (wr_ptr + 1);\n\n   assign rd_ptr=(i_0_req & i_0_ack)?(((q_rd_ptr == DEPTHMO) && (status_cnt != 0)) ? 0 : q_rd_ptr + 1):q_rd_ptr;\n   \nalways @(posedge clk or negedge reset_n)\n    if (~reset_n) begin\n       q_rd_ptr <= 0;\n    end else begin\n       if (i_0_req && i_0_ack) q_rd_ptr <= (((q_rd_ptr == DEPTHMO) && (status_cnt != 0)) ? 0 : (q_rd_ptr + 1));\n    end\n\nalways @(posedge clk or negedge reset_n)\n    if (~reset_n) status_cnt <= 0;\n    else if ((i_0_req && i_0_ack) && (t_0_req && t_0_ack)) status_cnt <= status_cnt;\n    else if (i_0_req && i_0_ack && (status_cnt != 0)) status_cnt <= status_cnt - 1;\n    else if (t_0_req && t_0_ack) status_cnt <= status_cnt + 1;\n\nendmodule\n",
        "module_name": "eb_fifo_ctrl #",
        "module_hash": "e7669798e82ccba57586fd4cc9bb2d90",
        "dataset_index": 21769
      },
      "barrel_shifter_bd246077": {
        "rtl_code": "\nmodule barrel_shifter(\n    input clk,\n    input reset,\n    input [15:0] data_in,\n    input [4:0] shift_amt,\n    input left_enable,\n    input right_enable,\n    output reg [15:0] data_out\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out <= 16'b0;\n    end else begin\n        if (left_enable) begin\n            data_out <= data_in << shift_amt;\n        end else if (right_enable) begin\n            data_out <= data_in >> shift_amt;\n        end else begin\n            data_out <= data_in;\n        end\n    end\nend\n\nendmodule\n\nmodule splitter(\n    input [15:0] data_in,\n    output reg [7:0] lower_nibble,\n    output reg [7:0] upper_nibble\n);\n\nalways @(*) begin\n    lower_nibble <= data_in[7:0];\n    upper_nibble <= data_in[15:8];\nend\n\nendmodule\n\nmodule xor_module(\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    out = in1 ^ in2;\nend\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input reset,\n    input [15:0] data,\n    input [4:0] shift_amt,\n    input [1:0] select,\n    output [7:0] q\n);\n\nwire [15:0] shifted_data;\nwire [7:0] lower_nibble;\nwire [7:0] upper_nibble;\nwire [7:0] xor_output;\n\nbarrel_shifter barrel_shifter_inst(.clk(clk), .reset(reset), .data_in(data), .shift_amt(shift_amt), .left_enable(select == 2'b01), .right_enable(select == 2'b10), .data_out(shifted_data));\nsplitter splitter_inst(.data_in(shifted_data), .lower_nibble(lower_nibble), .upper_nibble(upper_nibble));\nxor_module xor_module_inst(.in1(lower_nibble), .in2(upper_nibble), .out(xor_output));\n\nassign q = (select == 2'b00) ? xor_output : ((select == 2'b01) ? lower_nibble : upper_nibble);\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "bd2460777e600de32b2e741c1b4154f0",
        "dataset_index": 2783
      },
      "four_input_OR_0c10b504": {
        "rtl_code": "\nmodule four_input_OR (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire AB, CD, ABCD;\n\n    // Implement OR operation using combinational logic\n    assign AB = A | B;\n    assign CD = C | D;\n    assign ABCD = AB | CD;\n    assign X = ABCD;\n\nendmodule\n",
        "module_name": "four_input_OR",
        "module_hash": "0c10b50405637f3ab3a651407ed67c6f",
        "dataset_index": 16639
      },
      "DDC_8c29e150": {
        "rtl_code": "\nmodule DDC (\n  input clk,\n  input reset,\n  input [15:0] data_in,\n  input [31:0] freq,\n  input [7:0] dec_factor,\n  output reg [15:0] data_out,\n  output [31:0] out_freq\n);\n\n  // Internal signals\n  reg [15:0] filtered_data;\n  reg [31:0] counter;\n\n  // Low-pass filter\n  always @(posedge clk) begin\n    if (reset) begin\n      filtered_data <= 16'h0;\n    end else begin\n      filtered_data <= (data_in + filtered_data) >> 1;\n    end\n  end\n\n  // Down-sampling\n  always @(posedge clk) begin\n    if (reset) begin\n      counter <= 32'h0;\n      data_out <= 16'h0;\n    end else begin\n      counter <= counter + 1;\n      if (counter == dec_factor - 1) begin\n        counter <= 32'h0;\n        data_out <= filtered_data;\n      end\n    end\n  end\n\n  // Output frequency\n  assign out_freq = freq / dec_factor;\n\nendmodule\nmodule DUC (\n  input clk,\n  input reset,\n  input [15:0] data_in,\n  input [31:0] freq,\n  input [7:0] interp_factor,\n  output reg [15:0] data_out,\n  output [31:0] out_freq\n);\n\n  // Internal signals\n  reg [15:0] upsampled_data;\n  reg [31:0] counter;\n\n  // Up-sampling\n  always @(posedge clk) begin\n    if (reset) begin\n      counter <= 32'h0;\n      upsampled_data <= 16'h0;\n    end else begin\n      counter <= counter + 1;\n      if (counter == interp_factor - 1) begin\n        counter <= 32'h0;\n        upsampled_data <= data_in;\n      end else begin\n        upsampled_data <= 16'h0;\n      end\n    end\n  end\n\n  // Digital filter\n  always @(posedge clk) begin\n    if (reset) begin\n      data_out <= 16'h0;\n    end else begin\n      data_out <= (upsampled_data + data_out) >> 1;\n    end\n  end\n\n  // Output frequency\n  assign out_freq = freq * interp_factor;\n\nendmodule",
        "module_name": "DDC",
        "module_hash": "8c29e1502d266334073832dcdf546826",
        "dataset_index": 10854
      },
      "counter_c7045828": {
        "rtl_code": "module counter(\n  input rst,\n  input clk,\n  output reg [2:0] count\n);\n\n  always @(posedge clk) begin\n    if(rst) begin\n      count <= 3'd0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "c704582875b59aaa4017b24221e6ec2e",
        "dataset_index": 12633
      },
      "my__75ae71ce": {
        "rtl_code": "module my_module (\n    Y,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    // Module ports\n    output Y;\n    input A1;\n    input A2;\n    input B1;\n    input B2;\n    input C1;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire or0_out;\n    wire or1_out;\n    wire nand0_out_Y;\n\n    // Gates\n    or or0   (or0_out    , B2, B1  );\n    or or1   (or1_out    , A2, A1  );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf buf0  (Y          , nand0_out_Y);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "75ae71ceb85a5fffa525620973700a17",
        "dataset_index": 2109
      },
      "up_counter_0b81dc9c": {
        "rtl_code": "module up_counter (\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'b0000;\n        end else if (en) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "0b81dc9c08778387f4c34faf1c54c6e6",
        "dataset_index": 5331
      },
      "ad_datafmt #_26c04e23": {
        "rtl_code": "module ad_datafmt #(\n  parameter DATA_WIDTH = 16,\n  parameter DISABLE = 0\n) (\n  input clk,\n  input valid,\n  input [(DATA_WIDTH-1):0] data,\n  output valid_out,\n  output [15:0] data_out,\n  input dfmt_enable,\n  input dfmt_type,\n  input dfmt_se\n);\n\n  reg valid_int = 'd0;\n  reg [15:0] data_int = 'd0;\n\n  wire type_s;\n  wire [15:0] data_out_s;\n\n  generate\n    if (DISABLE == 1) begin\n      assign valid_out = valid;\n      assign data_out = data;\n    end else begin\n      assign valid_out = valid_int;\n      assign data_out = data_int;\n    end\n  endgenerate\n\n  generate\n    if (DATA_WIDTH < 16) begin\n      wire signext_s;\n      wire sign_s;\n\n      assign signext_s = dfmt_enable & dfmt_se;\n      assign sign_s = signext_s & (type_s ^ data[(DATA_WIDTH-1)]);\n      assign data_out_s[15:DATA_WIDTH] = {(16-DATA_WIDTH){sign_s}};\n    end\n  endgenerate\n\n  assign type_s = dfmt_enable & dfmt_type;\n  assign data_out_s[(DATA_WIDTH-1)] = type_s ^ data[(DATA_WIDTH-1)];\n  assign data_out_s[(DATA_WIDTH-2):0] = data[(DATA_WIDTH-2):0];\n\n  always @(posedge clk) begin\n    valid_int <= valid;\n    data_int <= data_out_s[15:0];\n  end\n\nendmodule",
        "module_name": "ad_datafmt #",
        "module_hash": "26c04e23068a71512d77ead2da9c8af1",
        "dataset_index": 17504
      },
      "bcd_counter_49eb42ec": {
        "rtl_code": "module bcd_counter (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output reg [2:0] ena,\n    output [15:0] q\n);\n\nreg [3:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 0;\n        ena <= 3'b000;\n    end else begin\n        count <= count + 1;\n        ena <= {ena[1:0], 1'b1};\n    end\nend\n\nassign q[3:0] = count % 10;\nassign q[7:4] = (count / 10) % 10;\nassign q[11:8] = (count / 100) % 10;\nassign q[15:12] = (count / 1000) % 10;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output [2:0] ena,\n    output [15:0] q\n);\n\nbcd_counter counter (\n    .clk(clk),\n    .reset(reset),\n    .ena(ena),\n    .q(q)\n);\n\nendmodule",
        "module_name": "bcd_counter",
        "module_hash": "49eb42ec70b0a517acb17fa851aa21a1",
        "dataset_index": 132
      },
      "ripple_adder #_6fc00d86": {
        "rtl_code": "module ripple_adder #(parameter DW = 4)\n    (\n        input [DW-1:0] A,\n        input [DW-1:0] B,\n        input Cin,\n        output [DW-1:0] S,\n        output Cout\n    );\n    \n    wire [DW:0] carry;\n    \n    assign carry[0] = Cin;\n    \n    genvar i;\n    generate\n        for (i = 0; i < DW; i = i + 1) begin\n            full_adder #(DW) fa(A[i], B[i], carry[i], S[i], carry[i+1]);\n        end\n    endgenerate\n    \n    assign Cout = carry[DW];\n    \nendmodule\n\nmodule full_adder #(parameter DW = 4)\n    (\n        input A,\n        input B,\n        input Cin,\n        output S,\n        output Cout\n    );\n    \n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n    \nendmodule",
        "module_name": "ripple_adder #",
        "module_hash": "6fc00d86c6cbb022c3095af694684f01",
        "dataset_index": 5763
      },
      "counter_b089ca7f": {
        "rtl_code": "\nmodule counter (\n    input clk,\n    input reset,\n    input direction,\n    output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'b000;\n    end else if (direction) begin\n        count <= count + 1;\n    end else if (!direction) begin\n        count <= count - 1;\n    end\nend\n\nendmodule\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output wire equal\n);\n\nassign equal = (a == b);\n\nendmodule\nmodule final_output (\n    input [2:0] count,\n    input equal,\n    output reg [2:0] out_final\n);\n\nalways @(*) begin\n    if (equal) begin\n        out_final = count;\n    end else begin\n        out_final = 3'b000;\n    end\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input direction,\n    input [3:0] a,\n    input [3:0] b,\n    output [2:0] count,\n    output wire equal,\n    output [2:0] out_final\n);\n\ncounter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .direction(direction),\n    .count(count)\n);\n\ncomparator comparator_inst (\n    .a(a),\n    .b(b),\n    .equal(equal)\n);\n\nfinal_output final_output_inst (\n    .count(count),\n    .equal(equal),\n    .out_final(out_final)\n);\n\nendmodule",
        "module_name": "counter",
        "module_hash": "b089ca7fa5ef79700afa71556394b8c2",
        "dataset_index": 9450
      },
      "adder_fa1181da": {
        "rtl_code": "module adder(\n    input [7:0] A,\n    input [7:0] B,\n    output [8:0] sum\n);\n\n    assign sum = {1'b0, A} + {1'b0, B};\n\nendmodule\n\n",
        "module_name": "adder",
        "module_hash": "fa1181da3c82883d533658ee47efd441",
        "dataset_index": 21489
      },
      "Conversor_BCD_7seg_62ed6d9f": {
        "rtl_code": "\nmodule Conversor_BCD_7seg\n(\ninput wire [3:0] Valor_Decimal,\noutput reg [7:0] Code_7seg    \n);\n\nalways @*\n\nbegin\n\ncase(Valor_Decimal)\n\n4'h0: Code_7seg = 8'b00000011; 4'h1: Code_7seg = 8'b10011111; 4'h2: Code_7seg = 8'b00100101; 4'h3: Code_7seg = 8'b00001101; 4'h4: Code_7seg = 8'b10011001; 4'h5: Code_7seg = 8'b01001001; 4'h6: Code_7seg = 8'b01000001; 4'h7: Code_7seg = 8'b00011111; 4'h8: Code_7seg = 8'b00000001; 4'h9: Code_7seg = 8'b00001001; default: Code_7seg = 8'b11111111; \n\nendcase\n\nend\n\nendmodule\n",
        "module_name": "Conversor_BCD_7seg",
        "module_hash": "62ed6d9fd00132da15e3f8d63e1a743c",
        "dataset_index": 21552
      },
      "wire_connection_fa53d030": {
        "rtl_code": "module wire_connection (\n    input a, b, c, select,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [7:0] out\n);\n\n    reg [7:0] b_input;\n\n    always @* begin\n        b_input = (select == 1) ? x : y;\n        out = (a & b_input) | (~a & c);\n    end\n\nendmodule\n\nmodule anyedge (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    reg [7:0] prev_value;\n\n    always @(posedge clk) begin\n        out <= in & (~prev_value);\n        prev_value <= in;\n    end\n\nendmodule\n\nmodule combined_system (\n    input clk,\n    input reset,\n    input a, b, c, select,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    wire [7:0] wire_conn_out;\n    wire [7:0] anyedge_out;\n\n    wire_connection wire_conn (\n        .a(a),\n        .b(b),\n        .c(c),\n        .select(select),\n        .x(in),\n        .y(anyedge_out),\n        .out(wire_conn_out)\n    );\n\n    anyedge anyedge_inst (\n        .clk(clk),\n        .in(in),\n        .out(anyedge_out)\n    );\n\n    always @* begin\n        out = wire_conn_out & anyedge_out;\n    end\n\nendmodule",
        "module_name": "wire_connection",
        "module_hash": "fa53d030299e3572644be43f1fdfc8ef",
        "dataset_index": 1143
      },
      "axi_bram_reader #_64810b23": {
        "rtl_code": "\n\nmodule axi_bram_reader #\n(\n  parameter integer AXI_DATA_WIDTH = 32,\n  parameter integer AXI_ADDR_WIDTH = 16,\n  parameter integer BRAM_DATA_WIDTH = 32,\n  parameter integer BRAM_ADDR_WIDTH = 10\n)\n(\n  input  wire                       aclk,\n  input  wire                       aresetn,\n\n  input  wire [AXI_ADDR_WIDTH-1:0]  s_axi_awaddr,  input  wire                       s_axi_awvalid, output wire                       s_axi_awready, input  wire [AXI_DATA_WIDTH-1:0]  s_axi_wdata,   input  wire                       s_axi_wvalid,  output wire                       s_axi_wready,  output wire [1:0]                 s_axi_bresp,   output wire                       s_axi_bvalid,  input  wire                       s_axi_bready,  input  wire [AXI_ADDR_WIDTH-1:0]  s_axi_araddr,  input  wire                       s_axi_arvalid, output wire                       s_axi_arready, output wire [AXI_DATA_WIDTH-1:0]  s_axi_rdata,   output wire [1:0]                 s_axi_rresp,   output wire                       s_axi_rvalid,  input  wire                       s_axi_rready,  output wire                       bram_porta_clk,\n  output wire                       bram_porta_rst,\n  output wire [BRAM_ADDR_WIDTH-1:0] bram_porta_addr,\n  input  wire [BRAM_DATA_WIDTH-1:0] bram_porta_rddata\n);\n\n  function integer clogb2 (input integer value);\n    for(clogb2 = 0; value > 0; clogb2 = clogb2 + 1) value = value >> 1;\n  endfunction\n\n  localparam integer ADDR_LSB = clogb2(AXI_DATA_WIDTH/8 - 1);\n\n  reg [AXI_ADDR_WIDTH-1:0] int_araddr_reg, int_araddr_next;\n  reg int_arready_reg, int_arready_next;\n  reg [AXI_ADDR_WIDTH-1:0] int_addr_reg, int_addr_next;\n  reg int_rvalid_reg, int_rvalid_next;\n\n  wire int_ardone_wire, int_rdone_wire;\n  wire [AXI_ADDR_WIDTH-1:0] int_araddr_wire;\n  wire [AXI_ADDR_WIDTH-1:0] int_addr_wire;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_araddr_reg <= {(AXI_ADDR_WIDTH){1'b0}};\n      int_arready_reg <= 1'b1;\n      int_addr_reg <= {(AXI_ADDR_WIDTH){1'b0}};\n      int_rvalid_reg <= 1'b0;\n    end\n    else\n    begin\n      int_araddr_reg <= int_araddr_next;\n      int_arready_reg <= int_arready_next;\n      int_addr_reg <= int_addr_next;\n      int_rvalid_reg <= int_rvalid_next;\n    end\n  end\n\n  assign int_ardone_wire = ~int_arready_reg | s_axi_arvalid;\n  assign int_rdone_wire = ~int_rvalid_reg | s_axi_rready;\n\n  assign int_araddr_wire = int_arready_reg ? s_axi_araddr : int_araddr_reg;\n  assign int_addr_wire = (int_ardone_wire & int_rdone_wire) ? int_araddr_wire : int_addr_reg;\n\n  always @*\n  begin\n    int_araddr_next = int_araddr_reg;\n    int_arready_next = ~int_ardone_wire | int_rdone_wire;\n    int_addr_next = int_addr_reg;\n    int_rvalid_next = ~int_rdone_wire | int_ardone_wire;\n\n    if(int_arready_reg)\n    begin\n      int_araddr_next = s_axi_araddr;\n    end\n\n    if(int_ardone_wire & int_rdone_wire)\n    begin\n      int_addr_next = int_araddr_wire;\n    end\n  end\n\n  assign s_axi_awready = 1'b0;\n  assign s_axi_wready = 1'b0;\n  assign s_axi_bresp = 2'd0;\n  assign s_axi_bvalid = 1'b0;\n  assign s_axi_arready = int_arready_reg;\n  assign s_axi_rdata = bram_porta_rddata;\n  assign s_axi_rresp = 2'd0;\n  assign s_axi_rvalid = int_rvalid_reg;\n\n  assign bram_porta_clk = aclk;\n  assign bram_porta_rst = ~aresetn;\n  assign bram_porta_addr = int_addr_wire[ADDR_LSB+BRAM_ADDR_WIDTH-1:ADDR_LSB];\n\nendmodule\n",
        "module_name": "axi_bram_reader #",
        "module_hash": "64810b23fd9e13067afb81f34b2c8b80",
        "dataset_index": 24128
      },
      "mux2x1_cbd8aa0b": {
        "rtl_code": "module mux2x1 (a, b, s, y);\n  input a, b, s;\n  output y;\n\n  assign y = (!s & a) | (s & b);\nendmodule\n\nmodule mux4x1 (a, b, c, d, sel0, sel1, y);\n  input a, b, c, d, sel0, sel1;\n  output y;\n\n  wire w1, w2;\n\n  mux2x1 m1(a, b, sel0, w1);\n  mux2x1 m2(c, d, sel0, w2);\n  mux2x1 m3(w1, w2, sel1, y);\nendmodule",
        "module_name": "mux2x1",
        "module_hash": "cbd8aa0bb82be75ed7a67f1e18537c75",
        "dataset_index": 3542
      },
      "bitwise_operators #_a56226bf": {
        "rtl_code": "\nmodule bitwise_operators #(\n    parameter n = 8 // length of binary numbers\n)(\n    input [n-1:0] num1,\n    input [n-1:0] num2,\n    output reg [n-1:0] result\n);\n\n// Bitwise AND, OR, XOR, and NOT operations\nalways @* begin\n    result = num1 & num2; // AND\n    result = num1 | num2; // OR\n    result = num1 ^ num2; // XOR\n    result = ~num1; // NOT\nend\n\nendmodule",
        "module_name": "bitwise_operators #",
        "module_hash": "a56226bffc8df18f8619ab1739648c80",
        "dataset_index": 8153
      },
      "full_adder_b85ec03d": {
        "rtl_code": "module full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule add4 (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output reg [3:0] sum,\n    output cout\n);\n\n    wire [3:0] s;\n    wire c1, c2, c3;\n\n    full_adder fa1 (.a(a[0]), .b(b[0]), .cin(cin), .sum(s[0]), .cout(c1));\n    full_adder fa2 (.a(a[1]), .b(b[1]), .cin(c1), .sum(s[1]), .cout(c2));\n    full_adder fa3 (.a(a[2]), .b(b[2]), .cin(c2), .sum(s[2]), .cout(c3));\n    full_adder fa4 (.a(a[3]), .b(b[3]), .cin(c3), .sum(s[3]), .cout(cout));\n\n    always @(*) begin\n        sum = s;\n    end\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "b85ec03dd9cb0f9949b119b338015814",
        "dataset_index": 3871
      },
      "d_ff_async_set_reset_3d575bc4": {
        "rtl_code": "module d_ff_async_set_reset(clk, rst, set, d, q, q_bar);\n\n  input clk, rst, set, d;\n  output reg q, q_bar;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      q <= 1'b0;\n      q_bar <= 1'b1;\n    end else if (set) begin\n      q <= 1'b1;\n      q_bar <= 1'b0;\n    end else begin\n      q <= d;\n      q_bar <= ~q;\n    end\n  end\n\nendmodule",
        "module_name": "d_ff_async_set_reset",
        "module_hash": "3d575bc449f0a5631abca9c6c84cda6e",
        "dataset_index": 9890
      },
      "EdgeDelay_cf6df4aa": {
        "rtl_code": "module EdgeDelay(clk, sigIn, waitCnt, sigOut, diagOut);\n\n\nparameter WAIT_CNT_SIZE=11;\nparameter INVERT_FLAG=1'b0; parameter MIN_WAIT=3'b10; input clk, sigIn;\ninput [WAIT_CNT_SIZE-1:0] waitCnt;\noutput sigOut;\noutput diagOut; reg [WAIT_CNT_SIZE-1:0] posEdgeDelayTimer;\nreg [WAIT_CNT_SIZE-1:0] negEdgeDelayTimer;\n\nreg sigOutReg;\nreg sigLast;\nreg sigReg;\n\nreg resetFlag; initial begin\n\t#0\n\tsigOutReg=1'b0;\n\tposEdgeDelayTimer=1'b0;\n\tnegEdgeDelayTimer=1'b0;\n\tsigLast=1'b0;\nend\n\nreg posEdgeReg, posEdgeRegLast, negEdgeReg, negEdgeRegLast;\n\nalways @(posedge sigIn) begin\n\tposEdgeReg=~posEdgeReg;\nend\n\nalways @(negedge sigIn) begin\n\tnegEdgeReg=~negEdgeReg;\nend\n\nalways @(posedge clk) begin\n\tsigReg=sigIn;\n\t\n\tif(posEdgeRegLast!=posEdgeReg && posEdgeDelayTimer>MIN_WAIT) begin\n\t\tposEdgeDelayTimer=1'b0; posEdgeRegLast=posEdgeReg;\n\tend else\tif(negEdgeRegLast!=negEdgeReg && negEdgeDelayTimer>MIN_WAIT) begin\n\t\tnegEdgeDelayTimer=1'b0; negEdgeRegLast=negEdgeReg;\n\t\tresetFlag=~resetFlag;\n\tend\n\t\n\t\n\t\n\t\n\tif(posEdgeDelayTimer<waitCnt) begin\n\t\tposEdgeDelayTimer=posEdgeDelayTimer+1'b1;\n\tend else if(posEdgeDelayTimer==waitCnt) begin posEdgeDelayTimer=posEdgeDelayTimer+1'b1;\n\t\tsigOutReg=1'b1; end else\n\n\tif(negEdgeDelayTimer<waitCnt) begin\n\t\tnegEdgeDelayTimer=negEdgeDelayTimer+1'b1;\n\tend else if(negEdgeDelayTimer==waitCnt) begin negEdgeDelayTimer=negEdgeDelayTimer+1'b1;\n\t\tsigOutReg=1'b0; end end\n\nassign sigOut=sigOutReg; assign diagOut=negEdgeReg;\n\nendmodule\n\n\n\n\n",
        "module_name": "EdgeDelay",
        "module_hash": "cf6df4aa548fe3f5da58c5d4bfe83555",
        "dataset_index": 22754
      },
      "POR_22e01e4d": {
        "rtl_code": "module POR (\n    input VDD,\n    input CLK,\n    input reset, \n    output reg RESET\n);\n\nparameter t = 10; // Number of clock cycles for the reset signal delay\nparameter IDLE = 2'b00, DELAY = 2'b01, NORMAL = 2'b10, DEFAULT = 2'b11;\n\nreg [1:0] state; // Removed the initialization from here\nreg [31:0] counter; // Counter for delay\n\nalways @(posedge CLK or posedge reset) begin\n    if (reset) begin\n        state <= IDLE; // Set the state to IDLE on reset\n        RESET <= 1'b1; // Assert the RESET signal initially\n        counter <= 0; // Initialize the counter\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                RESET <= 1'b1; // Assert reset signal\n                state <= DELAY; // Transition to the DELAY state\n                counter <= 0;\n            end\n            DELAY: begin\n                if (counter < t) begin\n                    counter <= counter + 1;\n                end else begin\n                    RESET <= 1'b0; // De-assert reset signal after delay\n                    state <= NORMAL; // Transition to the NORMAL state\n                end\n            end\n            NORMAL: begin\n                RESET <= 1'b0;\n            end\n            DEFAULT: begin\n                state <= IDLE; // Transition back to the IDLE state for recovery\n            end\n            default: begin\n                state <= DEFAULT; // Handle any undefined states\n            end\n        endcase\n    end\nend\n\nendmodule\n",
        "module_name": "POR",
        "module_hash": "22e01e4d05de8261540daca10ec0bda1",
        "dataset_index": 7267
      },
      "sky130_fd_sc_lp__a311oi_cfa335e4": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a311oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2      );\n    nor nor0 (nor0_out_Y, and0_out, B1, C1);\n    buf buf0 (Y         , nor0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a311oi",
        "module_hash": "cfa335e4a5a43cbf6e388aac561f7139",
        "dataset_index": 6710
      },
      "DSP_PREADD_5db1cbff": {
        "rtl_code": "\nmodule DSP_PREADD (\n  output [26:0] AD,\n  input ADDSUB,\n  input [26:0] D_DATA,\n  input INMODE2,\n  input [26:0] PREADD_AB\n);\n\nreg [26:0] D_DATA_mux;\nwire [26:0] preadd_out;\n\nalways @* D_DATA_mux = INMODE2 ? D_DATA : 27'b0;\n\n// pre-addition operation\nassign preadd_out = ADDSUB ? (D_DATA_mux - PREADD_AB) : (D_DATA_mux + PREADD_AB);\n\n// final output\nassign AD = preadd_out;\n\nendmodule",
        "module_name": "DSP_PREADD",
        "module_hash": "5db1cbff9be1cf782cb6eb815a6e1171",
        "dataset_index": 10990
      },
      "FSM_Ctrol_f063a549": {
        "rtl_code": "module FSM_Ctrol (\n\tinput\t\t\t\tRST,\tinput\t\t\t\tCLK,\tinput\t\t\t\tSTM,\toutput reg[7:0]\t\tENa,\toutput reg[7:0]\t\tENb,\toutput reg[7:0]\t\tENc,\toutput reg[7:0]\t\tSEL,\toutput reg\t\t\tEOM\t\t);\t \n\t\n\treg[2:0]\tQp,Qn;\n\t\n\talways @ *\n\tbegin : Combinacional\n\t\tcase (Qp)\n\t\t\t3'b000 : begin\tif (STM)\n\t\t\t\t\tQn = 3'b001;\n\t\t\t\telse\n\t\t\t\t\tQn = Qp;\n\t\t\t\tENa = 8'b00001111;\n\t\t\t\tENb = 8'b00001111;\n\t\t\t\tENc = 8'b00000000; \n\t\t\t\tSEL = 8'b00000000;\n\t\t\t\tEOM = 1'b1;\n\t\t\tend\n\t\t\t3'b001 : begin \n\t\t\t\tQn  = 3'b010;\n\t\t\t\tENa = 8'b11110000;\n\t\t\t\tENb = 8'b11110000;\n\t\t\t\tENc = 8'b00000000; \n\t\t\t\tSEL = 8'b00000000; \n\t\t\t\tEOM = 1'b0;\n\t\t\tend\n\t\t\t3'b010 : begin \n\t\t\t\tQn  = 3'b011;\n\t\t\t\tENa = 8'b01011010;\n\t\t\t\tENb = 8'b00000000;\n\t\t\t\tENc = 8'b00000000;  \n\t\t\t\tSEL = 8'b10010101;\n\t\t\t\tEOM = 1'b0;\n\t\t\tend\n\t\t\t3'b011 : begin \n\t\t\t\tQn  = 3'b100;\n\t\t\t\tENa = 8'b00000000;\n\t\t\t\tENb = 8'b00111100;\n\t\t\t\tENc = 8'b00000000; \n\t\t\t\tSEL = 8'b01101010;\n\t\t\t\tEOM = 1'b0;\n\t\t\tend\t \n\t\t\t3'b100 : begin \n\t\t\t\tQn  = 3'b000;\n\t\t\t\tENa = 8'b00000000;\n\t\t\t\tENb = 8'b00000000;\n\t\t\t\tENc = 8'b11111111; \t  \n\t\t\t\tSEL = 8'b01101010;\n\t\t\t\tEOM = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @ (posedge RST or posedge CLK)\n\tbegin : Secuencial\n\t\tif (RST)\n\t\t\tQp <= 0;\n\t\telse\n\t\t\tQp <= Qn;\n\tend\n\t\nendmodule\n",
        "module_name": "FSM_Ctrol",
        "module_hash": "f063a5496a5ba8c9d54c2eefd6cb405e",
        "dataset_index": 22638
      },
      "and_nand_e1546799": {
        "rtl_code": "module and_nand (\n    input A,\n    input B,\n    output Y\n);\n\n    wire nand1;\n    wire nand2;\n    wire nand3;\n\n    nand nand_gate1(nand1, A, B);\n    nand nand_gate2(nand2, nand1, nand1);\n    nand nand_gate3(nand3, nand2, nand2);\n    nand nand_gate4(Y, nand3, nand3);\n\nendmodule",
        "module_name": "and_nand",
        "module_hash": "e1546799c757d1fb1c85a96f28094c27",
        "dataset_index": 215
      },
      "reg3_sync_reset_65f8ecee": {
        "rtl_code": "module reg3_sync_reset (\n    input CLK,\n    input RST,\n    input [2:0] D,\n    output reg [2:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n    \nendmodule",
        "module_name": "reg3_sync_reset",
        "module_hash": "65f8eceee261819730b75813cc4072f6",
        "dataset_index": 9400
      },
      "adaptive_filter_304d90cc": {
        "rtl_code": "\nmodule adaptive_filter (\n  input  [n-1:0] in,\n  input  [m-1:0] d,\n  output [m-1:0] y,\n  output [n-1:0] w,\n  input         clk,\n  input         reset\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter L = 4'd10; // step size for LMS algorithm (optional)\nparameter lambda = 32'd32628; // forgetting factor for RLS algorithm (optional)\n\n// Internal signals\nreg [n-1:0] x;\nwire [m-1:0] e;\nreg  [n-1:0] w_reg;\n\n// Filter output calculation\nassign y = x * w_reg;\n\n// Error calculation\nassign e = d - y;\n\n// LMS algorithm for updating filter coefficients\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    w_reg <= 0;\n  end else begin\n    w_reg <= w_reg + L * x * e;\n  end\nend\n\n// Assign output filter coefficients\nassign w = w_reg;\n\n// Register the input data\nalways @(posedge clk) begin\n  x <= in;\nend\n\nendmodule",
        "module_name": "adaptive_filter",
        "module_hash": "304d90ccac7417020b6fbb90c69e850b",
        "dataset_index": 10864
      },
      "fanout_splitter_stall_free_ab1b3a35": {
        "rtl_code": "module fanout_splitter_stall_free(clock, resetn, i_datain, i_datain_valid, o_datain_stall, o_dataout, i_dataout_stall, o_dataout_valid);\n\nparameter DATA_WIDTH = 32;\nparameter NUM_FANOUTS = 2;\nparameter INSERT_AND = 0;\nparameter INSERT_REGISTER = 0;\n\n input clock, resetn;\n input [DATA_WIDTH-1:0] i_datain;\n input i_datain_valid;\n output reg o_datain_stall;\n output reg [DATA_WIDTH-1:0] o_dataout;\n input [NUM_FANOUTS-1:0] i_dataout_stall;\n output reg [NUM_FANOUTS-1:0] o_dataout_valid;\n\ngenerate\nif (INSERT_REGISTER)\nbegin\n  always @ (negedge resetn or posedge clock)\n  begin\n    if (~resetn)\n    begin\n      o_datain_stall <= 1'b0;\n      o_dataout_valid <= {NUM_FANOUTS{1'b0}};\n      o_dataout <= 'x;\n    end\n    else\n    begin\n      o_datain_stall <= |i_dataout_stall;\n      o_dataout_valid <= (INSERT_AND==1) ? {NUM_FANOUTS{i_datain_valid & ~o_datain_stall}} : {NUM_FANOUTS{i_datain_valid}};\n      o_dataout <= i_datain;\n    end\n  end\nend\nelse\nbegin always @ (*)\n  begin\n    o_datain_stall <= |i_dataout_stall;\n    o_dataout_valid <= (INSERT_AND==1) ? {NUM_FANOUTS{i_datain_valid & ~o_datain_stall}} : {NUM_FANOUTS{i_datain_valid}};\n    o_dataout <= i_datain;\n  end\nend\nendgenerate\n\nendmodule\n",
        "module_name": "fanout_splitter_stall_free",
        "module_hash": "ab1b3a3519683e804e9ea72c6319a70d",
        "dataset_index": 25677
      },
      "priority_encoder_12735e17": {
        "rtl_code": "\nmodule priority_encoder (\n    input [3:0] in,\n    input clk,\n    output [1:0] out\n);\n\nreg [1:0] stage1_out;\nreg [1:0] stage2_out;\n\n// Stage 1\nalways @(*) begin\n    if (in[0]) stage1_out = 2'b00;\n    else if (in[1]) stage1_out = 2'b01;\n    else if (in[2]) stage1_out = 2'b10;\n    else if (in[3]) stage1_out = 2'b11;\nend\n\n// Stage 2\nalways @(posedge clk) begin\n    if (clk == 1'b1) begin\n        stage2_out <= stage1_out;\n    end\nend\n\n// Output\nassign out = stage2_out;\n\nendmodule\n",
        "module_name": "priority_encoder",
        "module_hash": "12735e17b4a41672805a75a2a1edd7e4",
        "dataset_index": 17493
      },
      "SEG7_COUNTER_5d6ae456": {
        "rtl_code": "module SEG7_COUNTER (\n    input iCLK,\n    input iRST,\n    output reg [6:0] oSEG\n);\n    reg [3:0] count;\n\n    always @(posedge iCLK)\n    begin\n        if (iRST) // reset counter to 0 when iRST is high\n            count <= 0;\n        else if (count == 4'd9) // reset counter to 0 when it reaches 9\n            count <= 0;\n        else // increment counter by 1\n            count <= count + 4'd1;\n    end\n\n    always @(*)\n    begin\n        case(count)\n            4'd0: oSEG = 7'b1000000; // 0\n            4'd1: oSEG = 7'b1111001; // 1\n            4'd2: oSEG = 7'b0100100; // 2\n            4'd3: oSEG = 7'b0110000; // 3\n            4'd4: oSEG = 7'b0011001; // 4\n            4'd5: oSEG = 7'b0010010; // 5\n            4'd6: oSEG = 7'b0000010; // 6\n            4'd7: oSEG = 7'b1111000; // 7\n            4'd8: oSEG = 7'b0000000; // 8\n            4'd9: oSEG = 7'b0010000; // 9\n            default: oSEG = 7'b1111111; // display nothing\n        endcase\n    end\nendmodule",
        "module_name": "SEG7_COUNTER",
        "module_hash": "5d6ae45699bc57e5b0ee8da1b643cd84",
        "dataset_index": 1440
      },
      "binary_gray_updown_1bda26fa": {
        "rtl_code": "module binary_gray_updown (\n    input clk,\n    input rst,\n    input en,\n    input up,\n    input select,\n    input [2:0] BIN,\n    output reg [2:0] GRAY,\n    output reg [3:0] count\n);\n\n    wire [2:0] gray_out;\n    binary_to_gray_converter gray_converter(.bin(BIN), .gray(gray_out));\n    always @ (posedge clk) begin\n        if (rst) begin\n            count <= 0;\n        end else if (en) begin\n            if (select) begin\n                // Binary-to-Gray conversion mode\n                GRAY <= gray_out;\n            end else begin\n                // Counter mode\n                if (up) begin\n                    count <= count + 1;\n                end else begin\n                    count <= count - 1;\n                end\n                GRAY <= 3'b000;\n            end\n        end\n    end\n\nendmodule\n\nmodule binary_to_gray_converter (\n    input [2:0] bin,\n    output reg [2:0] gray\n);\n\n    always @* begin\n        gray[0] = bin[0] ^ bin[1];\n        gray[1] = bin[1] ^ bin[2];\n        gray[2] = bin[2];\n    end\n\nendmodule",
        "module_name": "binary_gray_updown",
        "module_hash": "1bda26fa5cb51a51f84de763bab52ccc",
        "dataset_index": 7877
      },
      "DFF_with_CLR_E_e4af5736": {
        "rtl_code": "module DFF_with_CLR_E(input D, C, E, CLR, output Q);\n    wire CLR_bar;\n    assign CLR_bar = ~CLR;\n    DFFNE _TECHMAP_REPLACE_ (.D(D), .Q(Q), .CLK(C), .CE(~E), .CLR(CLR_bar));\nendmodule\n\nmodule DFFNE(D, Q, CLK, CE, CLR);\n    input D, CLK, CE, CLR;\n    output reg Q;\n\n    always @(posedge CLK or negedge CLR)\n    begin\n        if (~CLR)\n            Q <= 1'b0;\n        else if (CE)\n            Q <= D;\n    end\nendmodule",
        "module_name": "DFF_with_CLR_E",
        "module_hash": "e4af5736aced677532a17ffad1586b2f",
        "dataset_index": 5867
      },
      "RGB1_RGB2_fd5b556f": {
        "rtl_code": "module RGB1_RGB2(\n    input clk,\n    input Btn_R,\n    input Btn_L,\n      \n    output reg [2:0] RGB1 = 0,\n    output reg [2:0] RGB2 = 0\n    );\n    \n    \n    reg [1:0]state = 0; \n    reg [1:0]nextState = 0;\n\n    \n    always @ (posedge clk)\n    begin\n        state <= nextState;\n           \n        case(state)\n        0:  begin\n                RGB1[0] <= 1;  \n                RGB1[1] <= 0; \n                RGB1[2] <= 0; \n                RGB2[0] <= 1;\n                RGB2[1] <= 0;\n                RGB2[2] <= 0;\n               \n                if (Btn_R == 1) \n                nextState <= 1;\n                if (Btn_L == 1)\n                nextState <= 2;\n            end\n        1: begin\n               RGB1[0] <= 0;  \n               RGB1[1] <= 1; \n               RGB1[2] <= 0; \n               RGB2[0] <= 0;\n               RGB2[1] <= 1;\n               RGB2[2] <= 0;\n               if (Btn_R == 1)\n               nextState <= 2;\n               if (Btn_L == 1)\n               nextState <= 0;\n           end\n        2: begin\n               RGB1[0] <= 0;  \n               RGB1[1] <= 0; \n               RGB1[2] <= 1; \n               RGB2[0] <= 0;\n               RGB2[1] <= 0; \n               RGB2[2] <= 1;  \n               if (Btn_R == 1) \n               nextState <= 0;\n               if (Btn_L == 1)\n               nextState <= 1;\n           end \n           endcase\n     end   \nendmodule\n",
        "module_name": "RGB1_RGB2",
        "module_hash": "fd5b556f4850fbb309528d290e97f47c",
        "dataset_index": 3924
      },
      "xor4_41ef189d": {
        "rtl_code": "\nmodule xor4 (\n    out,\n    a,\n    b,\n    c,\n    d\n);\n\n    // Module ports\n    output out;\n    input a;\n    input b;\n    input c;\n    input d;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire xor1_out;\n    wire xor2_out;\n\n    // 2-input XOR gate\n    xor xor1 (xor1_out, a, b);\n\n    // 3-input XOR gate\n    xor xor2 (xor2_out, c, d, xor1_out);\n\n    // Output assignment\n    assign out = xor2_out;\n\nendmodule",
        "module_name": "xor4",
        "module_hash": "41ef189dac54d94e4c23efc05fc39e40",
        "dataset_index": 8532
      },
      "bcd_counter_7ce695bd": {
        "rtl_code": "module bcd_counter (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output [3:1] ena,\n    output [15:0] q);\n\n    // Define states\n    parameter IDLE = 2'b00;\n    parameter INC_D1 = 2'b01;\n    parameter INC_D2 = 2'b10;\n    parameter INC_D3 = 2'b11;\n\n    // Define internal signals\n    reg [15:0] count;\n    reg [1:0] state;\n\n    // Output enable signals for upper three digits\n    assign ena = {state[1], state[0], 1'b1};\n\n    // State machine\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 16'd0;\n            state <= IDLE;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    count <= 16'd0;\n                    state <= INC_D1;\n                end\n                INC_D1: begin\n                    count <= count + 4'd1;\n                    if (count[3:0] == 4'd10) begin\n                        state <= INC_D2;\n                    end\n                end\n                INC_D2: begin\n                    count <= count + 4'd1;\n                    if (count[7:4] == 4'd10) begin\n                        state <= INC_D3;\n                    end\n                end\n                INC_D3: begin\n                    count <= count + 4'd1;\n                    if (count[11:8] == 4'd10) begin\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output BCD counter\n    assign q = {count[15:12], count[11:8], count[7:4], count[3:0]};\n\nendmodule",
        "module_name": "bcd_counter",
        "module_hash": "7ce695bd6998635cdbe6b39d50f8ba5c",
        "dataset_index": 20378
      },
      "Dec_4b_seg_a30d2c6d": {
        "rtl_code": "\nmodule Dec_4b_seg(\n    input [3:0] NUM,\n    output reg [7:0] CATODOS\n\n    );\n    \n    always @(*) begin\n        case(NUM)\n                        4'd0: CATODOS=8'b00000011;\n                        4'd1: CATODOS=8'b10011111;\n                        4'd2: CATODOS=8'b00100101;\n                        4'd3: CATODOS=8'b00001101;\n                        4'd4: CATODOS=8'b10011001;\n                        4'd5: CATODOS=8'b01001001;\n                        4'd6: CATODOS=8'b01000001;\n                        4'd7: CATODOS=8'b00011111;\n                        4'd8: CATODOS=8'b00000001;\n                        4'd9: CATODOS=8'b00011001;\n                        4'd10: CATODOS=8'b00010001;\n                        4'd11: CATODOS=8'b11000001;\n                        4'd12: CATODOS=8'b01100011;\n                        4'd13: CATODOS=8'b10000101;\n                        4'd14: CATODOS=8'b01100001;\n                        4'd15: CATODOS=8'b01110001;\n                        default CATODOS=8'b11111101;\n        endcase\n    end        \nendmodule\n",
        "module_name": "Dec_4b_seg",
        "module_hash": "a30d2c6daffb9531d48d0890114d09be",
        "dataset_index": 7686
      },
      "RippleCarryAdder_d782fdf9": {
        "rtl_code": "\nmodule RippleCarryAdder(S, Cout, A, B, Cin);\n  input [3:0] A;\n  input [3:0] B;\n  input Cin;\n  output [3:0] S;\n  output Cout;\n\n  wire [3:0] w1;\n  wire [3:0] w2;\n  wire [3:0] w3;\n\n  FA FA0(w1[0], w2[0], A[0], B[0], Cin);\n  FA FA1(w1[1], w2[1], A[1], B[1], w2[0]);\n  FA FA2(w1[2], w2[2], A[2], B[2], w2[1]);\n  FA FA3(Cout, w1[3], A[3], B[3], w2[2]);\n\n  assign S = w1;\nendmodule\nmodule FA(S, Cout, A, B, Cin);\n  input A, B, Cin;\n  output S, Cout;\n\n  assign {Cout, S} = A + B + Cin;\nendmodule",
        "module_name": "RippleCarryAdder",
        "module_hash": "d782fdf9235c5c74c05809c2bda8b368",
        "dataset_index": 5764
      },
      "fifo_async_aa83177f": {
        "rtl_code": "\nmodule fifo_async \n   (\n   // Outputs\n   output full, prog_full, dout, empty, valid,\n   // Inputs\n   input wr_en, din, rd_en\n   );\n   \n   parameter DW    = 104;        //FIFO width\n   parameter DEPTH = 16;          //FIFO depth\n   \n   reg [DW-1:0] fifo [DEPTH-1:0];\n   reg [4:0] wr_ptr;\n   reg [4:0] rd_ptr;\n   wire [4:0] fifo_count;\n   \n   assign full = (fifo_count == DEPTH);\n   assign prog_full = (fifo_count >= DEPTH-4);\n   assign empty = (fifo_count == 0);\n   assign valid = (fifo_count > 0);\n   assign dout = fifo[rd_ptr];\n   \n   always @(posedge wr_en) begin\n      if(!full) begin\n         fifo[wr_ptr] <= din;\n         wr_ptr <= wr_ptr + 1;\n      end\n   end\n   \n   always @(posedge rd_en) begin\n      if(!empty) begin\n         rd_ptr <= rd_ptr + 1;\n      end\n   end\n   \n   assign fifo_count = wr_ptr - rd_ptr;\n   \nendmodule",
        "module_name": "fifo_async",
        "module_hash": "aa83177f6f6ea8a8281e78e162f2ef17",
        "dataset_index": 13918
      },
      "register_0fd33d87": {
        "rtl_code": "module register(clk, Reset, R_Addr_A, R_Addr_B, W_Addr, W_Data, Write_Reg, R_Data_A, R_Data_B);\n    input clk;\n    input Reset;\n    input Write_Reg;\n    input [4:0] R_Addr_A, R_Addr_B, W_Addr;\n    input [31:0] W_Data;\n    output [31:0] R_Data_A;\n    output [31:0] R_Data_B;\n    reg [31:0] REGISTERS[0:31];\n    integer i;\n    assign R_Data_A = REGISTERS[R_Addr_A];\n    assign R_Data_B = REGISTERS[R_Addr_B];\n    always @(posedge clk or posedge Reset) begin\n        if(Reset) begin\n            for(i=0; i<=31; i=i+1) begin\n                REGISTERS[i] <= 32'h0000_0000;\n            end\n        end else begin\n            if(Write_Reg) begin\n                REGISTERS[W_Addr] <= W_Data;\n            end\n        end\n    end\nendmodule",
        "module_name": "register",
        "module_hash": "0fd33d87afe76977003189240b9ea3da",
        "dataset_index": 3683
      },
      "Datapath_RegisterFile_4f66d0c2": {
        "rtl_code": "module Datapath_RegisterFile(\n\toutput reg [WORD_WIDTH-1:0] A_data, B_data,\n\tinput [WORD_WIDTH-1:0] D_data,\n\tinput [2:0] AA, BA, DA,\n\tinput RW, CLK\n\t);\n\nparameter WORD_WIDTH = 16;\n\nreg [WORD_WIDTH-1:0] REGS[7:0];\n\nalways@(posedge CLK)\n\tif(RW)\n\t\tcase(DA)\n\t\t\t3'b 000 : REGS[0] = D_data;\n\t\t\t3'b 001 : REGS[1] = D_data;\n\t\t\t3'b 010 : REGS[2] = D_data;\n\t\t\t3'b 011 : REGS[3] = D_data;\n\t\t\t3'b 100 : REGS[4] = D_data;\n\t\t\t3'b 101 : REGS[5] = D_data;\n\t\t\t3'b 110 : REGS[6] = D_data;\n\t\t\t3'b 111 : REGS[7] = D_data;\n\t\tendcase\n\t\t\nalways@(*)\n\tbegin\n\t\tcase(AA)\n\t\t\t3'b 000 : A_data = REGS[0];\n\t\t\t3'b 001 : A_data = REGS[1];\n\t\t\t3'b 010 : A_data = REGS[2];\n\t\t\t3'b 011 : A_data = REGS[3];\n\t\t\t3'b 100 : A_data = REGS[4];\n\t\t\t3'b 101 : A_data = REGS[5];\n\t\t\t3'b 110 : A_data = REGS[6];\n\t\t\t3'b 111 : A_data = REGS[7];\n\t\tendcase\n\t\t\n\t\tcase(BA)\n\t\t\t3'b 000 : B_data = REGS[0];\n\t\t\t3'b 001 : B_data = REGS[1];\n\t\t\t3'b 010 : B_data = REGS[2];\n\t\t\t3'b 011 : B_data = REGS[3];\n\t\t\t3'b 100 : B_data = REGS[4];\n\t\t\t3'b 101 : B_data = REGS[5];\n\t\t\t3'b 110 : B_data = REGS[6];\n\t\t\t3'b 111 : B_data = REGS[7];\n\t\tendcase\n\tend\n\t\nendmodule\t\n",
        "module_name": "Datapath_RegisterFile",
        "module_hash": "4f66d0c26b3f64d3d1689084901900e8",
        "dataset_index": 21211
      },
      "pwm #_72940554": {
        "rtl_code": "module pwm #(parameter MAX_WAVE = 24) (\n  input clk,\n  input rst,\n  input [MAX_WAVE-1:0] period,\n  input [MAX_WAVE-1:0] compare,\n  output pwm\n  );\n\n  reg pwm_d, pwm_q;\n  reg [MAX_WAVE-1:0] ctr_d, ctr_q;\n\n  assign pwm = pwm_q;\n\n  always@(ctr_q) begin\n      // reset ctr when we get to period, else increment\n      if (ctr_q >= period) begin\n          ctr_d = 1'b0;\n      end else begin\n          ctr_d = ctr_q + 1'b1;\n      end\n\n      // set pwm based on ctr and compare threshold\n      if (compare > ctr_d) begin\n          pwm_d = 1'b1;\n      end else begin\n          pwm_d = 1'b0;\n      end\n  end\n\n  always@(posedge clk) begin\n      if (rst) begin\n          ctr_q <= 1'b0;\n          pwm_q <= 1'b0;\n      end else begin\n          ctr_q <= ctr_d;\n          pwm_q <= pwm_d;\n      end\n  end\n\nendmodule",
        "module_name": "pwm #",
        "module_hash": "72940554f4d6684061f1568bded22909",
        "dataset_index": 17420
      },
      "mux4to1_0cc99b08": {
        "rtl_code": "module mux4to1 (\n    A,\n    B,\n    C,\n    D,\n    S0,\n    S1,\n    Y\n);\n\n    // Module ports\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n    input  S0;\n    input  S1;\n    output Y;\n\n    // Local signals\n    wire not_S0;\n    wire not_S1;\n    wire and0_out;\n    wire and1_out;\n    wire and2_out;\n    wire and3_out;\n    wire or0_out;\n    wire or1_out;\n\n    //  Name   Output      Other arguments\n    not not0 (not_S0     , S0           );\n    not not1 (not_S1     , S1           );\n    and and0 (and0_out   , A, not_S0    );\n    and and1 (and1_out   , B, S0        );\n    and and2 (and2_out   , C, not_S1    );\n    and and3 (and3_out   , D, S1        );\n    or  or0  (or0_out    , and0_out, and1_out);\n    or  or1  (or1_out    , and2_out, and3_out);\n    or  or2  (Y          , or0_out, or1_out);\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "0cc99b08a251a480c4e90164bdd05de8",
        "dataset_index": 4203
      },
      "axis_frame_length_adjust #_9afe0d0e": {
        "rtl_code": "module axis_frame_length_adjust #(\n    parameter DATA_WIDTH = 8,\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    parameter KEEP_WIDTH = (DATA_WIDTH/8),\n    parameter ID_ENABLE = 1,\n    parameter ID_WIDTH = 8,\n    parameter DEST_ENABLE = 1,\n    parameter DEST_WIDTH = 8,\n    parameter USER_ENABLE = 1,\n    parameter USER_WIDTH = 1\n)\n(\n    input clk,\n    input rst,\n    input [DATA_WIDTH-1:0] s_axis_tdata,\n    input [KEEP_WIDTH-1:0] s_axis_tkeep,\n    input s_axis_tvalid,\n    output reg s_axis_tready,\n    input s_axis_tlast,\n    input [ID_WIDTH-1:0] s_axis_tid,\n    input [DEST_WIDTH-1:0] s_axis_tdest,\n    input [USER_WIDTH-1:0] s_axis_tuser,\n    output reg [DATA_WIDTH-1:0] m_axis_tdata,\n    output reg [KEEP_WIDTH-1:0] m_axis_tkeep,\n    output reg m_axis_tvalid,\n    input m_axis_tready,\n    output reg m_axis_tlast,\n    output reg [ID_WIDTH-1:0] m_axis_tid,\n    output reg [DEST_WIDTH-1:0] m_axis_tdest,\n    output reg [USER_WIDTH-1:0] m_axis_tuser,\n    output reg status_valid,\n    input status_ready,\n    output reg status_frame_pad,\n    output reg status_frame_truncate,\n    output reg [15:0] status_frame_length,\n    output reg [15:0] status_frame_original_length,\n    input [15:0] length_min,\n    input [15:0] length_max\n);\n\nlocalparam IDLE = 2'b00;\nlocalparam READ_HEADER = 2'b01;\nlocalparam READ_DATA = 2'b10;\nlocalparam WRITE_DATA = 2'b11;\n\nreg [1:0] state = IDLE;\nreg [15:0] frame_length = 0;\nreg [15:0] frame_original_length = 0;\nreg [15:0] frame_counter = 0;\nreg [15:0] pad_counter = 0;\nreg [15:0] truncate_counter = 0;\nreg [DATA_WIDTH-1:0] data_reg = 0;\nreg [KEEP_WIDTH-1:0] keep_reg = 0;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        frame_length <= 0;\n        frame_original_length <= 0;\n        frame_counter <= 0;\n        pad_counter <= 0;\n        truncate_counter <= 0;\n        m_axis_tvalid <= 0;\n        m_axis_tlast <= 0;\n        status_valid <= 0;\n        status_frame_pad <= 0;\n        status_frame_truncate <= 0;\n        status_frame_length <= 0;\n        status_frame_original_length <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (s_axis_tvalid && m_axis_tready) begin\n                    state <= READ_HEADER;\n                    frame_length <= 0;\n                    frame_original_length <= 0;\n                    frame_counter <= 0;\n                    pad_counter <= 0;\n                    truncate_counter <= 0;\n                    m_axis_tvalid <= 1;\n                    m_axis_tlast <= 0;\n                    m_axis_tid <= s_axis_tid;\n                    m_axis_tdest <= s_axis_tdest;\n                    m_axis_tuser <= s_axis_tuser;\n                    data_reg <= s_axis_tdata;\n                    keep_reg <= s_axis_tkeep;\n                end else begin\n                    m_axis_tvalid <= 0;\n                    s_axis_tready <= 1;\n                end\n            end\n            READ_HEADER: begin\n                if (s_axis_tvalid && m_axis_tready) begin\n                    frame_length <= {s_axis_tdata, 16'b0};\n                    frame_original_length <= frame_length;\n                    if (frame_length < length_min) begin\n                        pad_counter <= length_min - frame_length;\n                        frame_length <= length_min;\n                        status_frame_pad <= 1;\n                    end else if (frame_length > length_max) begin\n                        truncate_counter <= frame_length - length_max;\n                        frame_length <= length_max;\n                        status_frame_truncate <= 1;\n                    end\n                    status_frame_length <= frame_length;\n                    status_frame_original_length <= frame_original_length;\n                    m_axis_tdata <= s_axis_tdata;\n                    m_axis_tkeep <= s_axis_tkeep;\n                    m_axis_tlast <= s_axis_tlast;\n                    frame_counter <= 0;\n                    state <= READ_DATA;\n                end else begin\n                    m_axis_tvalid <= 0;\n                    s_axis_tready <= 1;\n                end\n            end\n            READ_DATA: begin\n                if (s_axis_tvalid && m_axis_tready) begin\n                    m_axis_tdata <= s_axis_tdata;\n                    m_axis_tkeep <= s_axis_tkeep;\n                    m_axis_tlast <= s_axis_tlast;\n                    frame_counter <= frame_counter + 1;\n                    if (frame_counter == frame_length - 1) begin\n                        m_axis_tlast <= 1;\n                        state <= WRITE_DATA;\n                    end\n                end else begin\n                    m_axis_tvalid <= 0;\n                    s_axis_tready <= 1;\n                end\n            end\n            WRITE_DATA: begin\n                if (m_axis_tready && status_ready) begin\n                    if (pad_counter > 0) begin\n                        m_axis_tdata <= 0;\n                        m_axis_tkeep <= {keep_reg, 8'b0};\n                        pad_counter <= pad_counter - 1;\n                    end else if (truncate_counter > 0) begin\n                        truncate_counter <= truncate_counter - 1;\n                    end else begin\n                        state <= IDLE;\n                    end\n                    status_valid <= 1;\n                end else begin\n                    m_axis_tvalid <= 0;\n                    s_axis_tready <= 1;\n                    status_valid <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "axis_frame_length_adjust #",
        "module_hash": "9afe0d0e5ea098c2bbe26163647cd7f1",
        "dataset_index": 5718
      },
      "LIFO #_dfa71228": {
        "rtl_code": "module LIFO #(\n  parameter data_width = 8,\n  parameter depth = 16\n)(\n  input clk,\n  input rst,\n  input [data_width-1:0] din,\n  input wr_en,\n  input rd_en,\n  output reg [data_width-1:0] dout\n);\n\n\n  reg [data_width-1:0] memory [0:depth-1];\n  reg [4:0] top = 0;\n  reg [4:0] bottom = 0;\n  reg [4:0] count = 0;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      top <= 0;\n      bottom <= 0;\n      count <= 0;\n    end else begin\n      if (wr_en && count < depth) begin\n        memory[top] <= din;\n        top <= top + 1;\n        count <= count + 1;\n      end\n      if (rd_en && count > 0) begin\n        dout <= memory[bottom];\n        bottom <= bottom + 1;\n        count <= count - 1;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "LIFO #",
        "module_hash": "dfa7122806d2bb428a96dd7a3d8a5f78",
        "dataset_index": 6065
      },
      "mc_ctrl_e6888511": {
        "rtl_code": "module mc_ctrl (\n\tclk\t\t,\n\trstn\t\t,\n\tmc_start_i\t\t,\n\tmc_done_o\t\t,\n  mvd_access_o    ,\n\tchroma_start_o\t\t,\n\tchroma_sel_o\t\t,\n\tchroma_done_i\t\t,\n\ttq_start_o\t\t,\n\ttq_sel_o\t\t,\n\ttq_done_i\t\t\n);\n\n\ninput \t [1-1:0] \t clk \t         ; // clk signal \ninput \t [1-1:0] \t rstn \t         ; // asynchronous reset\ninput \t [1-1:0] \t mc_start_i \t ; // mc start \noutput \t [1-1:0] \t mc_done_o \t ; // mc done \noutput             mvd_access_o ;\noutput \t [1-1:0] \t chroma_start_o  ; // chroma interpolation start \noutput \t [1-1:0] \t chroma_sel_o \t ; // chroma interpolation select: 0:cb, 1:cr\ninput \t [1-1:0] \t chroma_done_i \t ; // chroma interpolation done \noutput \t [1-1:0] \t tq_start_o \t ; // tq start \noutput \t [2-1:0] \t tq_sel_o \t ; // tq sel: 00:luma, 10:cb, 11:cr\ninput \t [1-1:0] \t tq_done_i \t ; // tq done \n\n\nparameter IDLE         = 3'd0;\nparameter TQ_LUMA      = 3'd1;\nparameter MC_CB        = 3'd2;\nparameter TQ_CB        = 3'd3;\nparameter MC_CR        = 3'd4;\nparameter TQ_CR        = 3'd5;\nparameter DONE         = 3'd6;\n\nreg      [3-1:0]        current_state, next_state;\n\nalways @(*) begin\n                next_state = IDLE;\n    case(current_state) \n        IDLE : begin\n            if ( mc_start_i)\n                next_state = TQ_LUMA;\n            else\n                next_state = IDLE;\n        end\n        TQ_LUMA: begin\n            if ( tq_done_i)\n                next_state = MC_CB;\n            else\n                next_state = TQ_LUMA;\n        end\n        MC_CB: begin\n            if ( chroma_done_i)\n                next_state = TQ_CB;\n            else\n                next_state = MC_CB;\n        end\n        TQ_CB: begin\n            if ( tq_done_i)\n                next_state = MC_CR;\n            else\n                next_state = TQ_CB;\n        end\n        MC_CR: begin\n            if ( chroma_done_i)\n                next_state = TQ_CR;\n            else\n                next_state = MC_CR;\n        end\n        TQ_CR: begin\n            if ( tq_done_i)\n                next_state = DONE;\n            else\n                next_state = TQ_CR;\n        end\n        DONE: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n\nassign \t mc_done_o \t = (current_state == DONE); \nassign \t chroma_start_o  = (current_state == TQ_LUMA && next_state == MC_CB)  ||\n                           (current_state == TQ_CB   && next_state == MC_CR)  ; \nassign \t chroma_sel_o \t = (current_state == MC_CR) ? 1'b1 : 1'b0; \nassign \t tq_start_o \t = (current_state == IDLE    && next_state == TQ_LUMA)||\n                           (current_state == MC_CB   && next_state == TQ_CB)  || \n                           (current_state == MC_CR   && next_state == TQ_CR)  ; \nassign \t tq_sel_o \t = (current_state == TQ_LUMA) ? 2'b00 :\n                           (current_state == TQ_CB  ) ? 2'b10 :\n                           (current_state == TQ_CR  ) ? 2'b11 : 2'b00;\n\nassign mvd_access_o = ( current_state == TQ_LUMA );\n\n\nalways @ (posedge clk or negedge rstn) begin\n    if(~rstn) begin\n        current_state <= IDLE;\n    end\n    else begin\n        current_state <= next_state;\n    end\nend\n\n\nendmodule",
        "module_name": "mc_ctrl",
        "module_hash": "e6888511339e5e5ec8010bedb6b048d5",
        "dataset_index": 7414
      },
      "xor_shift_register_60dbd53a": {
        "rtl_code": "\nmodule xor_shift_register (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q,\n    output out_if_else\n);\n\nreg [99:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n    end else begin // Fixed the if-else condition here\n        if (ena != 2'b00) begin\n            shift_reg <= {shift_reg[98-2'd1 : 0], shift_reg[99 : 98+2'd0]};\n        end\n    end\nend\n\nassign out_if_else = (shift_reg ^ data) ? 1'b1 : 1'b0;\nassign q = shift_reg;\n\nendmodule\n",
        "module_name": "xor_shift_register",
        "module_hash": "60dbd53a85a0f9258e41525e7f9a92a9",
        "dataset_index": 19469
      },
      "interrupt_controller_6e91ec0a": {
        "rtl_code": "module interrupt_controller (\n  input [n-1:0] irq,\n  output [m-1:0] iak\n);\n\nparameter n = 4; // number of IRQ signals\nparameter m = 2; // number of IAK signals\nparameter p = 3; // number of priority levels\n\nreg [n-1:0] irq_priority; // priority level for each IRQ signal\nreg [n-1:0] irq_active; // active status for each IRQ signal\nreg [p-1:0] highest_priority; // highest priority level\nreg [m-1:0] iak_active; // active status for each IAK signal\ninteger i;\n\n// assign priority levels to each IRQ signal\ninitial begin\n  irq_priority[0] = 2;\n  irq_priority[1] = 1;\n  irq_priority[2] = 0;\n  irq_priority[3] = 1;\nend\n\n// detect active IRQ signals\nalways @ (irq) begin\n  for (i = 0; i < n; i = i + 1) begin\n    if (irq[i] == 1) begin\n      irq_active[i] = 1;\n    end else begin\n      irq_active[i] = 0;\n    end\n  end\nend\n\n// detect highest priority IRQ signal\nalways @ (irq_active) begin\n  highest_priority = p;\n  for (i = 0; i < n; i = i + 1) begin\n    if (irq_active[i] == 1 && irq_priority[i] < highest_priority) begin\n      highest_priority = irq_priority[i];\n    end\n  end\nend\n\n// generate IAK signals for highest priority IRQ signal\nalways @ (highest_priority) begin\n  for (i = 0; i < m; i = i + 1) begin\n    if (i == highest_priority) begin\n      iak_active[i] = 1;\n    end else begin\n      iak_active[i] = 0;\n    end\n  end\nend\n\n// assign IAK signals to output\nassign iak = iak_active;\n\nendmodule",
        "module_name": "interrupt_controller",
        "module_hash": "6e91ec0af14c034430c001b6184fe67b",
        "dataset_index": 11525
      },
      "DrawMarioScore_e50025cb": {
        "rtl_code": "\nmodule DrawMarioScore(\n    input wire clk,\n    input wire rst,\n    input wire [9:0] hcount_in,\n    input wire hsync_in,\n    input wire [9:0] vcount_in,\n    input wire vsync_in,\n    input wire [23:0] rgb_in,\n    input wire blnk_in,\n    input wire [7:0] char_pixels,\n    \n    output reg [9:0] hcount_out,\n    output reg hsync_out,\n    output reg [9:0] vcount_out,\n    output reg vsync_out,\n    output reg [23:0] rgb_out,\n    output reg blnk_out,\n    output reg [7:0] char_xy,\n    output reg [3:0] char_line\n    );\n    \n    reg [23:0] rgb_nxt;\n        \n    localparam XPOS     = 40;\n    localparam YPOS     = 50;\n    localparam WIDTH    = 552;\n    localparam HEIGHT   = 16;\n        \n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            hcount_out  <= #1 0;\n            vcount_out  <= #1 0;\n            hsync_out   <= #1 0;\n            vsync_out   <= #1 0;\n            rgb_out     <= #1 0;\n            blnk_out    <= #1 0;\n        end\n        else begin\n            hcount_out  <= #1 hcount_in;\n            vcount_out  <= #1 vcount_in;\n            hsync_out   <= #1 hsync_in;\n            vsync_out   <= #1 vsync_in;\n            rgb_out     <= #1 rgb_nxt;\n            blnk_out    <= #1 blnk_in;\n        end\n    end\n\n    always @* begin\n        if ((hcount_in >= XPOS) && (hcount_in < XPOS + WIDTH) && (vcount_in >= YPOS) && (vcount_in < YPOS + HEIGHT) && (char_pixels[(XPOS - hcount_in)])) \n        begin\n            if(char_xy == 8'h20)\n                rgb_nxt = 24'hff_ff_00;\n            else\n                rgb_nxt = 24'hff_ff_ff;\n        end\n        else begin\n            rgb_nxt = rgb_in; end\n    end\n\n\n    always @* begin\n        char_xy = (hcount_in - XPOS - 1)>>3;\n    end\n    \n    always @* begin\n        char_line = vcount_in - YPOS;\n    end\n        \nendmodule\n",
        "module_name": "DrawMarioScore",
        "module_hash": "e50025cb2e92c49ce9ad0257bae29c7b",
        "dataset_index": 15262
      },
      "var6_multi_6dee92fd": {
        "rtl_code": "\n\n\n\nmodule var6_multi(A, B, C, D, E, F, valid);\n  wire _00_;\n  wire _01_;\n  wire _02_;\n  wire _03_;\n  wire _04_;\n  wire _05_;\n  wire _06_;\n  wire _07_;\n  wire _08_;\n  wire _09_;\n  wire _10_;\n  wire _11_;\n  wire _12_;\n  wire _13_;\n  wire _14_;\n  wire _15_;\n  wire _16_;\n  wire _17_;\n  wire _18_;\n  wire _19_;\n  wire _20_;\n  wire _21_;\n  wire _22_;\n  wire _23_;\n  wire _24_;\n  wire _25_;\n  wire _26_;\n  wire _27_;\n  wire _28_;\n  wire _29_;\n  wire _30_;\n  wire _31_;\n  wire _32_;\n  wire _33_;\n  wire _34_;\n  wire _35_;\n  wire _36_;\n  wire _37_;\n  wire _38_;\n  wire _39_;\n  wire _40_;\n  wire _41_;\n  wire _42_;\n  wire _43_;\n  wire _44_;\n  \n  input A;\n  \n  input B;\n  \n  input C;\n  \n  input D;\n  \n  input E;\n  \n  input F;\n  \n  wire [7:0] total_value;\n  \n  output valid;\n  assign _43_ = C & D;\n  assign _44_ = _43_ ^ A;\n  assign _00_ = ~E;\n  assign _01_ = ~(C | D);\n  assign _02_ = ~(_01_ | _00_);\n  assign _03_ = ~(_02_ & _44_);\n  assign _04_ = ~(A ^ B);\n  assign _05_ = ~(A & D);\n  assign _06_ = _05_ & C;\n  assign _07_ = _06_ ^ _04_;\n  assign _08_ = _07_ | _00_;\n  assign _09_ = _08_ & _03_;\n  assign _10_ = ~D;\n  assign _11_ = ~B;\n  assign _12_ = A | _11_;\n  assign _13_ = A & _11_;\n  assign _14_ = ~((_13_ | C) & _12_);\n  assign _15_ = _14_ & _10_;\n  assign _16_ = ~(_14_ | _10_);\n  assign _17_ = A & B;\n  assign _18_ = ~(_17_ & C);\n  assign _19_ = ~((_18_ & _16_) | _15_);\n  assign _20_ = _19_ ^ _00_;\n  assign _21_ = _20_ ^ _09_;\n  assign _22_ = ~F;\n  assign _23_ = _03_ & E;\n  assign _24_ = _23_ ^ _07_;\n  assign _25_ = E ? _43_ : _01_;\n  assign _26_ = ~(_02_ | _44_);\n  assign _27_ = _26_ & _25_;\n  assign _28_ = ~((_27_ & _24_) | _22_);\n  assign _29_ = _28_ | _21_;\n  assign _30_ = _14_ | _10_;\n  assign _31_ = A | B;\n  assign _32_ = ~((_17_ | C) & _31_);\n  assign _33_ = ~((_32_ & _30_) | (_43_ & A));\n  assign _34_ = ~((_19_ & E) | _33_);\n  assign _35_ = ~((_20_ | _09_) & _34_);\n  assign _36_ = _26_ | _25_;\n  assign _37_ = ~((_36_ | _24_) & _22_);\n  assign _38_ = _37_ & _35_;\n  assign _39_ = A | _10_;\n  assign _40_ = _39_ | _22_;\n  assign _41_ = E ? C : _11_;\n  assign _42_ = _41_ | _40_;\n  assign valid = ~((_38_ & _29_) | _42_);\n  assign total_value[1:0] = { E, 1'b0 };\nendmodule\n",
        "module_name": "var6_multi",
        "module_hash": "6dee92fd74b2c0266c407527dd7a3f97",
        "dataset_index": 21643
      },
      "four_bit_comparator_3a4eba4c": {
        "rtl_code": "module four_bit_comparator (\n  input [3:0] A,\n  input [3:0] B,\n  output reg out\n);\n\n  always @(*) begin\n    if (A > B) begin\n      out = 1;\n    end else begin\n      out = 0;\n    end\n  end\n\nendmodule\n",
        "module_name": "four_bit_comparator",
        "module_hash": "3a4eba4ceac0cac0702b53b8250667a5",
        "dataset_index": 15305
      },
      "multiplier #_9571e51e": {
        "rtl_code": "\nmodule multiplier #(\n  parameter n = 4 // number of bits\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  input ctrl,\n  output reg [2*n-1:0] P\n);\n\n\nreg [2*n-1:0] product;\nreg signed [n-1:0] signed_A;\nreg signed [n-1:0] signed_B;\nreg signed [2*n-1:0] signed_product;\n\ninteger i; // Declare loop variable\n\nalways @(*) begin\n  if (ctrl == 0) begin // unsigned multiplication\n    product = {n{1'b0}}; // initialize product to 0\n    for (i = 0; i < n; i = i + 1) begin\n      if (B[i] == 1'b1) begin\n        product = product + (A << i);\n      end\n    end\n    P = product;\n  end\n  else begin // signed multiplication\n    signed_A = $signed(A);\n    signed_B = $signed(B);\n    signed_product = signed_A * signed_B;\n    P = {signed_product[n-1], signed_product};\n  end\nend\n\nendmodule\n",
        "module_name": "multiplier #",
        "module_hash": "9571e51e69152dffed5372ba6c5ccac5",
        "dataset_index": 4265
      },
      "up_down_counter_6bf25207": {
        "rtl_code": "module up_down_counter (\n   // Outputs\n   count,\n   // Inputs\n   clk, reset, load, up_down,\n   load_val\n   );\n   \n   input clk, reset, load, up_down;\n   input [2:0] load_val;\n   \n   output reg [2:0] count;\n   \n   always @(posedge clk) begin\n      if (reset) begin\n         count <= 3'b0;\n      end\n      else if (load) begin\n         count <= load_val;\n      end\n      else begin\n         if (up_down) begin\n            count <= count + 1;\n         end\n         else begin\n            count <= count - 1;\n         end\n      end\n   end\n   \nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "6bf25207634cef3d6e20e3e46a9a4091",
        "dataset_index": 12963
      },
      "sky130_fd_sc_hvl__inv_36bc7b61": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__inv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__inv",
        "module_hash": "36bc7b618b43d30c020aab0281e7db99",
        "dataset_index": 21848
      },
      "tmu2_decay #_737c89d5": {
        "rtl_code": "\n\nmodule tmu2_decay #(\n\tparameter fml_depth = 26\n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\toutput busy,\n\t\n\tinput [5:0] brightness,\n\tinput chroma_key_en,\n\tinput [15:0] chroma_key,\n\t\n\tinput pipe_stb_i,\n\toutput pipe_ack_o,\n\tinput [15:0] color,\n\tinput [fml_depth-1-1:0] dadr,\n\t\n\toutput pipe_stb_o,\n\tinput pipe_ack_i,\n\toutput [15:0] color_d,\n\toutput reg [fml_depth-1-1:0] dadr_f\n);\n\nwire en;\nreg valid_1;\nreg valid_2;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tvalid_1 <= 1'b0;\n\t\tvalid_2 <= 1'b0;\n\tend else if(en) begin\n\t\tvalid_1 <= pipe_stb_i & ((color != chroma_key) | ~chroma_key_en);\n\t\tvalid_2 <= valid_1;\n\tend\nend\n\n\n\nreg [fml_depth-1-1:0] dadr_1;\n\nwire [4:0] r = color[15:11];\nwire [5:0] g = color[10:5];\nwire [4:0] b = color[4:0];\n\nreg [10:0] r_1;\nreg [11:0] g_1;\nreg [10:0] b_1;\n\nreg [10:0] r_2;\nreg [11:0] g_2;\nreg [10:0] b_2;\n\nalways @(posedge sys_clk) begin\n\tif(en) begin\n\t\tdadr_1 <= dadr;\n\t\tdadr_f <= dadr_1;\n\n\t\tr_1 <= ({1'b0, brightness} + 7'd1)*r;\n\t\tg_1 <= ({1'b0, brightness} + 7'd1)*g;\n\t\tb_1 <= ({1'b0, brightness} + 7'd1)*b;\n\t\t\n\t\tr_2 <= r_1;\n\t\tg_2 <= g_1;\n\t\tb_2 <= b_1;\n\tend\nend\n\nassign color_d = {r_2[10:6], g_2[11:6], b_2[10:6]};\n\n\n\nassign busy = valid_1 | valid_2;\n\nassign pipe_ack_o = ~valid_2 | pipe_ack_i;\nassign en = ~valid_2 | pipe_ack_i;\n\nassign pipe_stb_o = valid_2;\n\nendmodule\n",
        "module_name": "tmu2_decay #",
        "module_hash": "737c89d5555eab198ff94f242efe79fc",
        "dataset_index": 23177
      },
      "MemoryCtrl_b98ba2d9": {
        "rtl_code": "\nmodule MemoryCtrl(Clk, Reset, MemAdr, MemOE, MemWR,\n\t\tRamCS, RamUB, RamLB, RamAdv, RamCRE, writeData, AddressIn,\n\t\tBtnU_Pulse, BtnD_Pulse\n    );\n\n\tinput Clk, Reset, BtnU_Pulse, BtnD_Pulse;\n\tinput [22:0] AddressIn;\n\toutput MemOE, MemWR, RamCS, RamUB, RamLB, RamAdv, RamCRE;\n\toutput [26:1] MemAdr;\n\toutput writeData;\n\n\n\treg _MemOE, _MemWR, _RamCS, _RamUB, _RamLB, _RamAdv, _RamCRE;\n\treg [22:0] address = 23'b000_10_00_0_1_011_1_0_0_0_0_01_1_111;\n\treg [7:0] state;\n\treg [6:0] clock_counter;\n\treg writeData;\n\t\n\tassign MemAdr = {4'b0, address};\n\tassign MemOE = _MemOE;\n\tassign MemWR = _MemWR;\n\tassign RamCS = _RamCS;\n\tassign RamUB = _RamUB;\n\tassign RamLB = _RamLB;\n\tassign RamAdv = _RamAdv;\n\tassign RamCRE = _RamCRE;\n\t\nlocalparam\n\tINITIAL_CONFIG =  8'b00000001,\n\tCONFIGMEM = \t\t8'b00000010,\n\tCONFIGMEM2 = \t\t8'b00000100,\n\tINIT = \t\t\t\t8'b00001000,\n\tPREPARE_READ = \t8'b00010000,\n\tWAIT = \t\t\t\t8'b00100000,\n\tREAD_DATA =\t\t\t8'b01000000,\n\tIDLE =\t\t\t\t8'b10000000;\n\t\n\nalways @ (posedge Clk, posedge Reset)\n\tbegin : State_Machine\n\t\tif (Reset)\n\t\t   begin\n\t\t\t\tstate <= CONFIGMEM;\n\t\t\t\twriteData <= 0;\n\t\t   end\n\n\t\telse \n\t\t   begin\t\t\t   \n\t\t\t\tcase (state)\n\t\t\t\t\tINITIAL_CONFIG:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tstate <= CONFIGMEM;\n\t\t\t\t\t\t\t_MemOE <= 1;\n\t\t\t\t\t\t\t_RamCS <= 0;\n\t\t\t\t\t\t\t_MemWR <= 1;\n\t\t\t\t\t\t\t_RamAdv <= 0;\n\t\t\t\t\t\t\t_RamCRE <= 1;\n\t\t\t\t\t\tend\n\t\t\n\t\t\t\t\tCONFIGMEM:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taddress <= 23'b000_10_00_0_1_011_1_0_0_0_0_01_1_111;\n\t\t\t\t\t\t\t_RamCRE <= 1;\n\t\t\t\t\t\t\t_RamAdv <= 0;\n\t\t\t\t\t\t\t_RamCS <= 0;\n\t\t\t\t\t\t\t_MemWR <= 0;\n\t\t\t\t\t\t\t_MemOE <= 1;\n\t\t\t\t\t\t\t_RamUB <= 1;\n\t\t\t\t\t\t\t_RamLB <= 1;\n\t\t\t\t\t\t\tclock_counter <= 0;\n\t\t\t\t\t\t\tstate <= CONFIGMEM2;\n\t\t\t\t\t\tend\n\t\t\t\t\tCONFIGMEM2:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t_RamCRE <= 1;\n\t\t\t\t\t\t\t_RamAdv <= 1;\n\t\t\t\t\t\t\t_RamCS <= 0;\n\t\t\t\t\t\t\t_MemWR <= 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(clock_counter == 7'b0000010)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tstate <= INIT;\n\t\t\t\t\t\t\t\t\t_RamCS <= 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tclock_counter <= clock_counter + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tINIT:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taddress <= AddressIn;\n\t\t\t\t\t\t\tstate <= PREPARE_READ;\n\t\t\t\t\t\tend\n\t\t\t\t\tPREPARE_READ:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t_RamCRE <= 0;\n\t\t\t\t\t\t\t_RamAdv <= 0;\n\t\t\t\t\t\t\t_RamCS <= 0;\n\t\t\t\t\t\t\t_MemWR <= 1;\n\t\t\t\t\t\t\t_MemOE <= 1;\n\t\t\t\t\t\t\t_RamUB <= 0;\n\t\t\t\t\t\t\t_RamLB <= 0;\n\t\t\t\t\t\t\tstate <= WAIT;\n\t\t\t\t\t\t\tclock_counter <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\tWAIT:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t_RamAdv <= 1;\n\n\t\t\t\t\t\t\tif(clock_counter == 7'b0000011)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\twriteData <= 1;\n\t\t\t\t\t\t\t\t\t_MemOE <= 0;\n\t\t\t\t\t\t\t\t\tstate <= READ_DATA;\n\t\t\t\t\t\t\t\t\tclock_counter <= 0;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tclock_counter <= clock_counter + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tREAD_DATA:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tclock_counter <= clock_counter + 1;\n\n\t\t\t\t\t\t\tif(clock_counter == 7'b1111111)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\t\t\t\twriteData <= 0;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tIDLE:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif(BtnU_Pulse || BtnD_Pulse)\n\t\t\t\t\t\t\t\tstate <= CONFIGMEM;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t_RamCRE <= 0;\n\t\t\t\t\t\t\t_RamAdv <= 1;\n\t\t\t\t\t\t\t_RamCS <= 1;\n\t\t\t\t\t\t\t_MemWR <= 1;\n\t\t\t\t\t\t\t_MemOE <= 1;\n\t\t\t\t\t\t\t_RamUB <= 1;\n\t\t\t\t\t\t\t_RamLB <= 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate <= 8'bXXXXXXXX;\n\t\t\t\tendcase\n\t\t\tend\n\t\tend\nendmodule",
        "module_name": "MemoryCtrl",
        "module_hash": "b98ba2d94e9696bb8d0b890a0ef4f864",
        "dataset_index": 20738
      },
      "bin2gray_652b52ac": {
        "rtl_code": "module bin2gray(\n    input wire [3:0] bin,\n    output reg [3:0] gray\n);\n\n    always @(*) begin\n        gray[3] = bin[3];\n        gray[2] = bin[3] ^ bin[2];\n        gray[1] = bin[2] ^ bin[1];\n        gray[0] = bin[1] ^ bin[0];\n    end\n\nendmodule",
        "module_name": "bin2gray",
        "module_hash": "652b52acce7dd3ba2afad9f043d09b9f",
        "dataset_index": 12702
      },
      "multiplier_0b6a319e": {
        "rtl_code": "module multiplier(\n    input [7:0] A,\n    input [7:0] B,\n    input [7:0] C,\n    input [7:0] D,\n    input [7:0] E,\n    output reg [15:0] Y\n);\n\n    always @(*) begin\n        Y = (A * B) + (C * D * E);\n    end\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "0b6a319e23dd08027907dbb8cadb1fa2",
        "dataset_index": 15959
      },
      "top__ce7352b9": {
        "rtl_code": "\nmodule top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] shift,\n    input select,\n    output [15:0] out\n);\n\n    // 16-bit adder\n    wire [15:0] adder_out;\n    assign adder_out = a + b;\n\n    // 4-bit shifter\n    wire [15:0] shifter_out;\n    assign shifter_out = (shift == 4'd0) ? adder_out : (shift == 4'd1) ? {adder_out[14:0], 1'b0} :\n                         (shift == 4'd2) ? {adder_out[13:0], 2'b00} : (shift == 4'd3) ? {adder_out[12:0], 3'b000} :\n                         (shift == 4'd4) ? {adder_out[11:0], 4'b0000} : (shift == 4'd5) ? {adder_out[10:0], 5'b00000} :\n                         (shift == 4'd6) ? {adder_out[9:0], 6'b000000} : (shift == 4'd7) ? {adder_out[8:0], 7'b0000000} :\n                         (shift == 4'd8) ? {adder_out[7:0], 8'b00000000} : (shift == 4'd9) ? {adder_out[6:0], 9'b000000000} :\n                         (shift == 4'd10) ? {adder_out[5:0], 10'b0000000000} : (shift == 4'd11) ? {adder_out[4:0], 11'b00000000000} :\n                         (shift == 4'd12) ? {adder_out[3:0], 12'b000000000000} : (shift == 4'd13) ? {adder_out[2:0], 13'b0000000000000} :\n                         (shift == 4'd14) ? {adder_out[1:0], 14'b00000000000000} : (shift == 4'd15) ? {adder_out[0], 15'b000000000000000} : 16'b0;\n\n    // Functional module for bitwise OR\n    wire [15:0] or_out;\n    assign or_out = adder_out | shifter_out;\n\n    // Output selection\n    assign out = (select) ? shifter_out | or_out : adder_out | or_out;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "ce7352b91d8c192f1f5dd97fcfe6075c",
        "dataset_index": 12855
      },
      "bin_to_gray_114e9d47": {
        "rtl_code": "module bin_to_gray(\n\tinput clk,\n\tinput rst,\n\tinput [3:0] BIN,\n\toutput reg[3:0] GRAY\n\t);\n\t\n\talways @ (posedge clk)\n\t\tbegin\n\t\t\tif (rst)\n\t\t\t\tGRAY <= 4'b0000;\n\t\t\telse\n\t\t\t\tGRAY <= BIN ^ (BIN >> 1);\n\t\tend\n\nendmodule",
        "module_name": "bin_to_gray",
        "module_hash": "114e9d4733bff516c915642104bd9c12",
        "dataset_index": 18766
      },
      "sky130_fd_sc_ls__a21boi_cabde6ae": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a21boi (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    wire b         ;\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    not not0 (b         , B1_N           );\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, b, and0_out    );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a21boi",
        "module_hash": "cabde6aed9d1da387e6cee3de581701e",
        "dataset_index": 20674
      },
      "transition_counter_f7a6bafd": {
        "rtl_code": "module transition_counter (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [3:0] count\n);\n    \n    reg [31:0] prev_in;\n    reg [3:0] transition_count;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            prev_in <= 0;\n            transition_count <= 0;\n        end else begin\n            if (in[0] && !prev_in[0]) begin\n                transition_count <= transition_count + 1;\n            end\n            prev_in <= in;\n            count <= transition_count;\n        end\n    end\n    \nendmodule",
        "module_name": "transition_counter",
        "module_hash": "f7a6bafd2aa23329daa680345da7c543",
        "dataset_index": 21179
      },
      "nios_system_switches_aed0a894": {
        "rtl_code": "module nios_system_switches (\n  // inputs:\n  address,\n  clk,\n  in_port,\n  reset_n,\n\n  // outputs:\n  readdata\n);\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  9: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  9: 0] data_in;\n  wire    [  9: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  \n  // Select the data to be read from the input port\n  assign read_mux_out = {10 {(address == 2'b00)}} & in_port;\n  \n  // Enable the clock signal\n  assign clk_en = 1;\n  \n  // Assign the selected data to the data_in signal\n  assign data_in = read_mux_out;\n  \n  // Update the readdata signal on the rising edge of the clock signal\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      readdata <= 0;\n    end else if (clk_en) begin\n      readdata <= {32'b0 | data_in};\n    end\n  end\n\nendmodule",
        "module_name": "nios_system_switches",
        "module_hash": "aed0a894de41c2e9ac567c6e851e5542",
        "dataset_index": 3800
      },
      "execute_load_data_0cdf4553": {
        "rtl_code": "\n\nmodule execute_load_data(\n\t\tinput wire [3:0] iMASK,\n\t\tinput wire [1:0] iSHIFT,\n\t\tinput wire [31:0] iDATA,\n\t\toutput wire [31:0] oDATA\n\t);\n\n\tassign oDATA = func_load_fairing(\n\t\tiMASK,\n\t\tiSHIFT,\n\t\tiDATA\n\t);\n\n\n\tfunction [31:0] func_load_fairing;\t\n\t\tinput [3:0] func_mask;\n\t\tinput [1:0] func_shift;\n\t\tinput [31:0] func_data;\n\t\treg [7:0] func_tmp0, func_tmp1, func_tmp2, func_tmp3;\n\t\tbegin\n\t\t\tif(func_mask == 4'hf)begin\n\t\t\t\tfunc_load_fairing = func_data;\n\t\t\tend\n\t\t\telse if(func_mask == 4'b0001)begin\n\t\t\t\tfunc_load_fairing = {24'h0, func_data[31:24]};\n\t\t\tend\n\t\t\telse if(func_mask == 4'b0010)begin\n\t\t\t\tfunc_load_fairing = {24'h0, func_data[23:16]};\n\t\t\tend\n\t\t\telse if(func_mask == 4'b0100)begin\n\t\t\t\tfunc_load_fairing = {24'h0, func_data[15:8]};\n\t\t\tend\n\t\t\telse if(func_mask == 4'b1000)begin\n\t\t\t\tfunc_load_fairing = {24'h0, func_data[7:0]};\n\t\t\tend\n\t\t\telse if(func_mask == 4'b0011)begin\n\t\t\t\tfunc_load_fairing = {24'h0, func_data[31:16]};\n\t\t\tend\n\t\t\telse begin\n\t\t\tfunc_load_fairing = {24'h0, func_data[15:0]};\n\t\t\tend\n\t\tend\n\tendfunction\n\t\n\n\nendmodule\n\n\n\n",
        "module_name": "execute_load_data",
        "module_hash": "0cdf4553676b64cc4bafcc0bbc6c9613",
        "dataset_index": 24444
      },
      "chatgpt_generate_edge_detect_a21cce1f": {
        "rtl_code": "module chatgpt_generate_edge_detect(\n  input               clk,\n  input               rst_n,\n  input               A,\n  output reg          rise,\n  output reg          down\n);\n\n  reg prev_A;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      prev_A <= 1'b0;\n      rise <= 1'b0;\n      down <= 1'b0;\n    end\n    else begin\n      if (A != prev_A) begin\n        if (A == 1'b1) begin\n          rise <= 1'b1;\n          down <= 1'b0;\n        end\n        else begin\n          rise <= 1'b0;\n          down <= 1'b1;\n        end\n      end\n      else begin\n        rise <= 1'b0;\n        down <= 1'b0;\n      end\n      prev_A <= A;\n    end\n  end\n\nendmodule",
        "module_name": "chatgpt_generate_edge_detect",
        "module_hash": "a21cce1f09a51050fd9d9c9381c5a841",
        "dataset_index": 7523
      },
      "TLATNTSCAX2TS_54215f2a": {
        "rtl_code": "\nmodule TLATNTSCAX2TS (\n  input E,\n  input SE,\n  input CK,\n  output ECK\n);\n\n  assign ECK = E & SE;\n\nendmodule\nmodule clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n \n  assign ENCLK = EN & TE;\n\nendmodule",
        "module_name": "TLATNTSCAX2TS",
        "module_hash": "54215f2a5db8d495e6861e0ea3c43e86",
        "dataset_index": 8688
      },
      "oh_par2ser #_fde4bc9c": {
        "rtl_code": "module oh_par2ser #(parameter PW = 64, parameter SW = 1,  parameter CW = $clog2(PW/SW)  )\n   (\n    input \t    clk, input \t    nreset, input [PW-1:0]  din, output [SW-1:0] dout, output \t    access_out,input \t    load, input \t    shift, input [7:0]     datasize, input \t    lsbfirst, input \t    fill, input \t    wait_in, output \t    wait_out );\n \n   reg [PW-1:0]    shiftreg;\n   reg [CW-1:0]    count;\n   wire \t   start_transfer;\n   wire \t   busy;\n   \n   assign start_transfer = load &  ~wait_in & ~busy;\n\n   always @ (posedge clk or negedge nreset)\n     if(!nreset)\n       count[CW-1:0] <= 'b0;   \n     else if(start_transfer)\n       count[CW-1:0] <= datasize[CW-1:0];  else if(shift & busy)\n       count[CW-1:0] <= count[CW-1:0] - 1'b1;\n   \n   assign busy = |count[CW-1:0];\n   \n   assign access_out = busy;\n      \n   assign wait_out  = wait_in | busy;\n   \n   always @ (posedge clk)\n     if(start_transfer)\n       shiftreg[PW-1:0] = din[PW-1:0];\n     else if(shift & lsbfirst)\t\t \n       shiftreg[PW-1:0] = {{(SW){fill}}, shiftreg[PW-1:SW]};\n     else if(shift)\n       shiftreg[PW-1:0] = {shiftreg[PW-SW-1:0],{(SW){fill}}};\n   \n\n   assign dout[SW-1:0] = lsbfirst ? shiftreg[SW-1:0] : \n\t\t\t            shiftreg[PW-1:PW-SW];\t\n\nendmodule ",
        "module_name": "oh_par2ser #",
        "module_hash": "fde4bc9c113fd3083fec37adf6ada740",
        "dataset_index": 8372
      },
      "subtractor_67bd2e66": {
        "rtl_code": "module subtractor (\n  input clk,\n  input [7:0] A,\n  input [7:0] B,\n  output reg [7:0] Y\n);\n\n  always @(posedge clk) begin\n    if (A < B) begin\n      Y <= 8'b0;\n    end else begin\n      Y <= A - B;\n    end\n  end\n  \nendmodule",
        "module_name": "subtractor",
        "module_hash": "67bd2e6684a9f53025928cf66052f570",
        "dataset_index": 4074
      },
      "max_finder_e69874e0": {
        "rtl_code": "\nmodule max_finder (\n    input [15:0] D,\n    output reg [15:0] max\n);\n\nreg [15:0] shifted_D;\nreg [3:0] highest_bit;\n\nalways @ (D) begin\n    highest_bit = D >> 12;\n    shifted_D = D >> highest_bit;\n    max = shifted_D;\nend\n\nendmodule",
        "module_name": "max_finder",
        "module_hash": "e69874e03453c4eeb2c0c9c1ee9f5ff7",
        "dataset_index": 17265
      },
      "counter_04c9f573": {
        "rtl_code": "module counter(input clk, input reset, input in, output p);\n\treg [2:0] count;\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset)\n\t\t\tcount <= 0;\n\t\telse begin\n\t\t\tif(in)\n\t\t\t\tcount <= count + 1;\n\t\t\telse\n\t\t\t\tcount <= 0;\n\t\tend\n\tend\n\tassign p = (count == 5);\nendmodule",
        "module_name": "counter",
        "module_hash": "04c9f5739bf02a446e16924f20f077ad",
        "dataset_index": 17825
      },
      "DisplayCtrl_35745523": {
        "rtl_code": "\n\nmodule DisplayCtrl(Clk, reset, memoryData,\n\t\tAn0, An1, An2, An3, Ca, Cb, Cc, Cd, Ce, Cf, Cg, Dp\n   );\n\t\n\tinput [26:0] Clk;\n\tinput reset;\n\tinput [15:0] memoryData;\n\toutput An0, An1, An2, An3, Ca, Cb, Cc, Cd, Ce, Cf, Cg, Dp;\n\n\treg [6:0] SSD_CATHODES;\n\twire [26:0] DIV_CLK;\n\treg [3:0] SSD;\n\twire [3:0] SSD0, SSD1, SSD2, SSD3;\n\twire [1:0] ssdscan_clk;\n\t\n\tassign {Ca, Cb, Cc, Cd, Ce, Cf, Cg, Dp} = {SSD_CATHODES, 1'b1};\n\tassign DIV_CLK = Clk;\n\n\tassign SSD3 = memoryData[15:12];\n\tassign SSD2 = memoryData[11:8];\n\tassign SSD1 = memoryData[7:4];\n\tassign SSD0 = memoryData[3:0];\n\n\tassign ssdscan_clk = DIV_CLK[19:18];\t\n\tassign An0 = !(~(ssdscan_clk[1]) && ~(ssdscan_clk[0]));  assign An1 = !(~(ssdscan_clk[1]) &&  (ssdscan_clk[0]));  assign An2 = !( (ssdscan_clk[1]) && ~(ssdscan_clk[0]));  assign An3 = !( (ssdscan_clk[1]) &&  (ssdscan_clk[0]));  always @ (ssdscan_clk, SSD0, SSD1, SSD2, SSD3)\n\tbegin : SSD_SCAN_OUT\n\t\tcase (ssdscan_clk) \n\t\t\t2'b00: \n\t\t\t\tSSD = SSD0;\n\t\t\t2'b01: \n\t\t\t\tSSD = SSD1;\n\t\t\t2'b10: \n\t\t\t\tSSD = SSD2;\n\t\t\t2'b11: \n\t\t\t\tSSD = SSD3;\t\t\t\t\n\t\tendcase \n\tend\t\n\n\talways @ (SSD) \n\tbegin : HEX_TO_SSD\n\t\tcase (SSD)\n\t\t\t4'b0000: SSD_CATHODES = 7'b0000001 ; 4'b0001: SSD_CATHODES = 7'b1001111 ; 4'b0010: SSD_CATHODES = 7'b0010010 ; 4'b0011: SSD_CATHODES = 7'b0000110 ; 4'b0100: SSD_CATHODES = 7'b1001100 ; 4'b0101: SSD_CATHODES = 7'b0100100 ; 4'b0110: SSD_CATHODES = 7'b0100000 ; 4'b0111: SSD_CATHODES = 7'b0001111 ; 4'b1000: SSD_CATHODES = 7'b0000000 ; 4'b1001: SSD_CATHODES = 7'b0000100 ; 4'b1010: SSD_CATHODES = 7'b0001000 ; 4'b1011: SSD_CATHODES = 7'b1100000 ; 4'b1100: SSD_CATHODES = 7'b0110001 ; 4'b1101: SSD_CATHODES = 7'b1000010 ; 4'b1110: SSD_CATHODES = 7'b0110000 ; 4'b1111: SSD_CATHODES = 7'b0111000 ; endcase\n\tend\t\nendmodule\n",
        "module_name": "DisplayCtrl",
        "module_hash": "357455238b0a44e454615e31377f0486",
        "dataset_index": 22608
      },
      "calculator_f2e1e42d": {
        "rtl_code": "module calculator(\n    input clk,\n    input reset_n,\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] control,\n    input start,\n    output [31:0] C,\n    output error\n);\n\nreg [31:0] C_reg;\nreg [31:0] A_reg;\nreg [31:0] B_reg;\nreg [1:0] control_reg;\nreg start_reg;\nreg [31:0] result_reg;\nreg error_reg;\n\nalways @(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        C_reg <= 32'h0;\n        A_reg <= 32'h0;\n        B_reg <= 32'h0;\n        control_reg <= 2'h0;\n        start_reg <= 1'b0;\n        error_reg <= 1'b0;\n    end else begin\n        C_reg <= result_reg;\n        A_reg <= A;\n        B_reg <= B;\n        control_reg <= control;\n        start_reg <= start;\n        error_reg <= 1'b0;\n        case(control_reg)\n            2'h0: result_reg <= A_reg + B_reg;\n            2'h1: result_reg <= A_reg - B_reg;\n            2'h2: result_reg <= A_reg * B_reg;\n            2'h3: begin\n                    if(B_reg == 0) begin\n                        error_reg <= 1'b1;\n                        result_reg <= 32'h0;\n                    end else begin\n                        result_reg <= A_reg / B_reg;\n                    end\n                 end\n        endcase\n    end\nend\n\nassign C = C_reg;\nassign error = error_reg;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "f2e1e42d21ec540ff2f08bfb52c8ce54",
        "dataset_index": 4197
      },
      "sequential_logic_block_0408a88c": {
        "rtl_code": "module sequential_logic_block (\n  input clk,\n  input reset,\n  input [2:0] x,\n  output reg f\n);\n\n  parameter state0 = 3'b000;\n  parameter state1 = 3'b001;\n  parameter state2 = 3'b010;\n  parameter state3 = 3'b011;\n  parameter state4 = 3'b100;\n  parameter state5 = 3'b101;\n  parameter state6 = 3'b110;\n  parameter state7 = 3'b111;\n\n  reg [2:0] state;\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= state0;\n      f <= 1'b0;\n    end else begin\n      case (state)\n        state0: begin\n          f <= 1'b0;\n          state <= state0;\n        end\n        state1: begin\n          if (x == 3'b001) begin\n            f <= 1'b1;\n            state <= state2;\n          end else begin\n            f <= 1'b0;\n            state <= state0;\n          end\n        end\n        state2: begin\n          if (x == 3'b010) begin\n            f <= 1'b1;\n            state <= state3;\n          end else begin\n            f <= 1'b0;\n            state <= state0;\n          end\n        end\n        state3: begin\n          if (x == 3'b011) begin\n            f <= 1'b1;\n            state <= state4;\n          end else begin\n            f <= 1'b0;\n            state <= state0;\n          end\n        end\n        state4: begin\n          f <= 1'b0;\n          state <= state0;\n        end\n        state5: begin\n          if (x == 3'b001) begin\n            f <= 1'b1;\n            state <= state6;\n          end else begin\n            f <= 1'b0;\n            state <= state0;\n          end\n        end\n        state6: begin\n          if (x == 3'b010) begin\n            f <= 1'b1;\n            state <= state7;\n          end else begin\n            f <= 1'b0;\n            state <= state0;\n          end\n        end\n        state7: begin\n          if (x == 3'b011) begin\n            f <= 1'b1;\n            state <= state0;\n          end else begin\n            f <= 1'b0;\n            state <= state0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "sequential_logic_block",
        "module_hash": "0408a88cf583798fded154c1375f7cd0",
        "dataset_index": 18140
      },
      "calculator_0371ac90": {
        "rtl_code": "module calculator(\n    input clk,\n    input [7:0] A,\n    input [7:0] B,\n    input [1:0] op,\n    output reg [7:0] result,\n    output reg overflow,\n    output reg underflow\n);\n\n    // Temporary variable for multiplication to check for overflow\n    reg [15:0] temp_mul;\n\n    always @(posedge clk) begin\n        overflow <= 0; // Default to no overflow\n        underflow <= 0; // Default to no underflow\n\n        case(op)\n            2'b00: begin // Addition\n                result <= A + B;\n                overflow <= ((A[7] == B[7]) && (result[7] != A[7]));\n            end\n            2'b01: begin // Subtraction\n                result <= A - B;\n                overflow <= ((A[7] != B[7]) && (result[7] != A[7]));\n                underflow <= ((A < B) && (A[7] == 0) && (B[7] == 0));\n            end\n            2'b10: begin // Multiplication\n                temp_mul <= A * B; \n                result <= temp_mul[7:0];\n                overflow <= (temp_mul[15:8] != 0); \n            end\n            2'b11: begin // Division\n                if (B == 8'b0) begin\n                    result <= 8'b0; \n                    underflow <= 1; \n                end else begin\n                    result <= A / B;\n                end\n            end\n            default: begin\n                result <= 8'b0;\n            end\n        endcase\n    end\nendmodule\n",
        "module_name": "calculator",
        "module_hash": "0371ac90746a5c7269ffd58279174670",
        "dataset_index": 10133
      },
      "scheduler1_commit_entry #_3bb4accf": {
        "rtl_code": "\n\nmodule scheduler1_commit_entry #(\n\t\tparameter ENTRY_ID = 6'h00\n\t)(\n\t\tinput wire iCLOCK,\n\t\tinput wire inRESET,\t\n\t\tinput wire iLOCK,\n\t\tinput wire iRESTART_VALID,\n\t\tinput wire [5:0] iREGIST_POINTER,\n\t\tinput wire iREGIST_0_VALID,\n\t\tinput wire iREGIST_0_MAKE_FLAGS,\t\t\n\t\tinput wire iREGIST_0_WRITEBACK,\t\n\t\tinput wire [3:0] iREGIST_0_FLAGS_PREG_POINTER,\t\n\t\tinput wire [5:0] iREGIST_0_DEST_PREG_POINTER,\n\t\tinput wire [4:0] iREGIST_0_DEST_LREG_POINTER,\t\n\t\tinput wire iREGIST_0_DEST_SYSREG,\t\t\t\n\t\tinput wire iREGIST_0_EX_BRANCH,\n\t\tinput wire iREGIST_1_VALID,\n\t\tinput wire iREGIST_1_MAKE_FLAGS,\t\t\t\n\t\tinput wire iREGIST_1_WRITEBACK,\t\t\t\n\t\tinput wire [3:0] iREGIST_1_FLAGS_PREG_POINTER,\t\n\t\tinput wire [5:0] iREGIST_1_DEST_PREG_POINTER,\n\t\tinput wire [4:0] iREGIST_1_DEST_LREG_POINTER,\t\n\t\tinput wire iREGIST_1_DEST_SYSREG,\t\t\t\n\t\tinput wire iREGIST_1_EX_BRANCH,\n\t\tinput wire [31:0] iREGIST_PC,\n\t\tinput wire iCOMMIT_VALID,\n\t\tinput wire iEXEND_ALU0_VALID,\n\t\tinput wire [5:0] iEXEND_ALU0_COMMIT_TAG,\n\t\tinput wire iEXEND_ALU1_VALID,\n\t\tinput wire [5:0] iEXEND_ALU1_COMMIT_TAG,\n\t\tinput wire iEXEND_ALU2_VALID,\n\t\tinput wire [5:0] iEXEND_ALU2_COMMIT_TAG,\n\t\tinput wire iEXEND_ALU3_VALID,\n\t\tinput wire [5:0] iEXEND_ALU3_COMMIT_TAG,\n\t\toutput wire oINFO_VALID,\n\t\toutput wire oINFO_MAKE_FLAGS_VALID,\t\t\t\n\t\toutput wire oINFO_WRITEBACK_VALID,\t\n\t\toutput wire [31:0] oINFO_PC,\n\t\toutput wire [3:0] oINFO_FLAGS_PREG_POINTER,\t\n\t\toutput wire [5:0] oINFO_DEST_PREG_POINTER,\n\t\toutput wire [4:0] oINFO_DEST_LREG_POINTER,\t\n\t\toutput wire oINFO_DEST_SYSREG,\t\t\t\n\t\toutput wire oINFO_EX_BRANCH,\n\t\toutput wire oINFO_EX_END,\n\t\toutput wire oINFO_FREE\n\t);\n\t\n\t\n\t\n\t\n\treg [1:0] b_state;\n\treg [31:0] b_pc;\n\treg b_make_flags_validl;\n\treg b_writeback;\n\treg [3:0] b_flags_preg_pointer;\n\treg [5:0] b_destination_regname;\n\treg [4:0] b_logic_destination;\n\treg b_dest_sysreg;\n\treg b_ex_branch;\n\t\n\twire [5:0] w_regist_pointer0;\n\twire [5:0] w_regist_pointer1;\n\t\n\tassign w_regist_pointer0 = iREGIST_POINTER;\n\tassign w_regist_pointer1 = iREGIST_POINTER + 6'h1;\n\t\n\talways@(posedge iCLOCK or negedge inRESET)begin\n\t\tif(!inRESET)begin\n\t\t\tb_state <= 2'h0;\n\t\t\tb_pc <= {32{1'b0}};\n\t\t\tb_make_flags_validl <= 1'b0;\n\t\t\tb_writeback <= 1'b0;\n\t\t\tb_flags_preg_pointer <= 4'h0;\n\t\t\tb_destination_regname <= {6{1'b0}};\n\t\t\tb_logic_destination <= {5{1'b0}};\n\t\t\tb_dest_sysreg <= 1'b0;\n\t\t\tb_ex_branch <= 1'b0;\n\t\tend\n\t\telse if(b_state == 2'h3 || iRESTART_VALID)begin\n\t\t\tb_state <= 2'h0;\n\t\t\tb_pc <= {32{1'b0}};\n\t\t\tb_make_flags_validl <= 1'b0;\n\t\t\tb_writeback <= 1'b0;\n\t\t\tb_flags_preg_pointer <= 4'h0;\n\t\t\tb_destination_regname <= {6{1'b0}};\n\t\t\tb_logic_destination <= {5{1'b0}};\n\t\t\tb_dest_sysreg <= 1'b0;\n\t\t\tb_ex_branch <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\t\tcase(b_state)\n\t\t\t\t\t2'h0 :\t\t\tbegin\n\t\t\t\t\t\t\tif(!iLOCK)begin\n\t\t\t\t\t\t\t\tif(iREGIST_0_VALID && ENTRY_ID[5:0] == w_regist_pointer0)begin\n\t\t\t\t\t\t\t\t\tb_state <= 2'h1;\n\t\t\t\t\t\t\t\t\tb_pc <= iREGIST_PC;\n\t\t\t\t\t\t\t\t\tb_make_flags_validl <= iREGIST_0_MAKE_FLAGS;\n\t\t\t\t\t\t\t\t\tb_writeback <= iREGIST_0_WRITEBACK;\n\t\t\t\t\t\t\t\t\tb_flags_preg_pointer <= iREGIST_0_FLAGS_PREG_POINTER;\n\t\t\t\t\t\t\t\t\tb_destination_regname <= iREGIST_0_DEST_PREG_POINTER;\n\t\t\t\t\t\t\t\t\tb_logic_destination <= iREGIST_0_DEST_LREG_POINTER;\n\t\t\t\t\t\t\t\t\tb_dest_sysreg <= iREGIST_0_DEST_SYSREG;\n\t\t\t\t\t\t\t\t\tb_ex_branch <= iREGIST_0_EX_BRANCH;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse if(iREGIST_1_VALID && ENTRY_ID[5:0] == w_regist_pointer1)begin\n\t\t\t\t\t\t\t\t\tb_state <= 2'h1;\n\t\t\t\t\t\t\t\t\tb_pc <= iREGIST_PC + 32'h4;\n\t\t\t\t\t\t\t\t\tb_make_flags_validl <= iREGIST_1_MAKE_FLAGS;\n\t\t\t\t\t\t\t\t\tb_writeback <= iREGIST_1_WRITEBACK;\n\t\t\t\t\t\t\t\t\tb_flags_preg_pointer <= iREGIST_1_FLAGS_PREG_POINTER;\n\t\t\t\t\t\t\t\t\tb_destination_regname <= iREGIST_1_DEST_PREG_POINTER;\n\t\t\t\t\t\t\t\t\tb_logic_destination <= iREGIST_1_DEST_LREG_POINTER;\n\t\t\t\t\t\t\t\t\tb_dest_sysreg <= iREGIST_1_DEST_SYSREG;\n\t\t\t\t\t\t\t\t\tb_ex_branch <= iREGIST_1_EX_BRANCH;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t2'h1 :\t\t\tbegin\n\t\t\t\t\t\t\tif(iEXEND_ALU0_VALID && iEXEND_ALU0_COMMIT_TAG == ENTRY_ID[5:0])begin\n\t\t\t\t\t\t\t\tb_state <= 2'h2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if(iEXEND_ALU1_VALID && iEXEND_ALU1_COMMIT_TAG == ENTRY_ID[5:0])begin\t\n\t\t\t\t\t\t\t\tb_state <= 2'h2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if(iEXEND_ALU2_VALID && iEXEND_ALU2_COMMIT_TAG == ENTRY_ID[5:0])begin\n\t\t\t\t\t\t\t\tb_state <= 2'h2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if(iEXEND_ALU3_VALID && iEXEND_ALU3_COMMIT_TAG == ENTRY_ID[5:0])begin\n\t\t\t\t\t\t\t\tb_state <= 2'h2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif(iCOMMIT_VALID)begin\n\t\t\t\t\t\t\t\tb_state [1:0] <= 2'h0;\n\t\t\t\t\t\t\t\tb_make_flags_validl <= 1'b0;\n\t\t\t\t\t\t\t\tb_writeback <= 1'b0;\n\t\t\t\t\t\t\t\tb_flags_preg_pointer <= 4'h0;\n\t\t\t\t\t\t\t\tb_destination_regname <= {6{1'b0}};\n\t\t\t\t\t\t\t\tb_logic_destination <= {5{1'b0}};\n\t\t\t\t\t\t\t\tb_dest_sysreg <= 1'b0;\n\t\t\t\t\t\t\t\tb_ex_branch <= b_ex_branch;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\tend assign oINFO_VALID = (b_state == 2'h1 || b_state == 2'h2)? 1'b1 : 1'b0;\n\tassign oINFO_MAKE_FLAGS_VALID = b_make_flags_validl;\n\tassign oINFO_WRITEBACK_VALID = b_writeback;\n\tassign oINFO_PC = b_pc;\n\tassign oINFO_FLAGS_PREG_POINTER = b_flags_preg_pointer;\n\tassign oINFO_DEST_PREG_POINTER = b_destination_regname;\n\tassign oINFO_DEST_LREG_POINTER = b_logic_destination;\n\tassign oINFO_DEST_SYSREG = b_dest_sysreg;\n\tassign oINFO_EX_BRANCH = b_ex_branch;\n\tassign oINFO_EX_END = (b_state == 2'h2)? 1'b1 : 1'b0; \n\tassign oINFO_FREE = (iRESTART_VALID && ((b_state == 2'h1) || (b_state == 2'h2)))? 1'b1 : 1'b0;\n\t\n\t\nendmodule\n\n\n",
        "module_name": "scheduler1_commit_entry #",
        "module_hash": "3bb4accf80da7d7d6c08508fff928eb2",
        "dataset_index": 6521
      },
      "decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_blk_mem_gen_v8_3_4_8ed5831f": {
        "rtl_code": "module decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_blk_mem_gen_v8_3_4\n  (dout,\n   clk,\n   tmp_ram_rd_en,\n   E,\n   out,\n   \\gc0.count_d1_reg[7] ,\n   Q,\n   din);\n  output [63:0]dout;\n  input clk;\n  input tmp_ram_rd_en;\n  input [0:0]E;\n  input [0:0]out;\n  input [7:0]\\gc0.count_d1_reg[7] ;\n  input [7:0]Q;\n  input [63:0]din;\n\n  wire [0:0]E;\n  wire [7:0]Q;\n  wire clk;\n  wire [63:0]din;\n  wire [63:0]dout;\n  wire [7:0]\\gc0.count_d1_reg[7] ;\n  wire [0:0]out;\n  wire tmp_ram_rd_en;\n\n  // Create a tmp_ram block with a capacity of 256 bytes\n  reg [63:0] tmp_ram [0:255];\n\n  // Write data to tmp_ram block\n  always @(posedge clk) begin\n    if (tmp_ram_rd_en == 1'b0) begin\n      tmp_ram[Q] <= din;\n    end\n  end\n\n  // Read data from tmp_ram block\n  assign dout = tmp_ram[out];\n\nendmodule",
        "module_name": "decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_blk_mem_gen_v8_3_4",
        "module_hash": "8ed5831ffd3e1305daab584e9989649d",
        "dataset_index": 965
      },
      "functionGen #_e62bef60": {
        "rtl_code": "\n\n\nmodule functionGen #(\n    parameter ARCH                = \"GENERIC\", parameter BIT_COMPRESS_PHASE  = 1,         parameter BIT_COMPRESS_OUTPUT = 1,         parameter OUT_WIDTH           = 16,        parameter FREQ_WIDTH          = 16,        parameter INCLUDE_CLAMP       = 1          )\n(\n    input clk,                          input rst,                          input en,                           input [1:0] waveType,               input [FREQ_WIDTH-1:0] freq,        input [FREQ_WIDTH-1:0] phaseOffset, input [OUT_WIDTH-1:0] offset,       input [OUT_WIDTH-1:0] amplitude,    output signed [OUT_WIDTH-1:0] outSignal\n);\n\ninitial begin\n    if (ARCH != \"GENERIC\" && ARCH != \"XIL_7SERIES\" && ARCH != \"XIL_SPARTAN6\") begin\n        $display(\"Attribute ARCH on functionGen instance %m is set to %s. Valid values are GENERIC, XIL_7SERIES, and XIL_SPARTAN6.\", ARCH);\n        #1 $finish;\n    end\n    if (BIT_COMPRESS_PHASE != 0 && BIT_COMPRESS_PHASE != 1) begin\n        $display(\"Attribute BIT_COMPRESS_PHASE on functionGen instance %m is set to %d. Valid values are 0 and 1.\", BIT_COMPRESS_PHASE);\n        #1 $finish;\n    end\n    if (BIT_COMPRESS_OUTPUT != 0 && BIT_COMPRESS_OUTPUT != 1) begin\n        $display(\"Attribute BIT_COMPRESS_OUTPUT on functionGen instance %m is set to %d. Valid values are 0 and 1.\", BIT_COMPRESS_OUTPUT);\n        #1 $finish;\n    end\n    if (OUT_WIDTH < 3) begin\n        $display(\"Attribute OUT_WIDTH on functionGen instance %m is set to %d. Must be at least 3.\", OUT_WIDTH);\n        #1 $finish;\n    end\n    if (FREQ_WIDTH < 4) begin\n        $display(\"Attribute FREQ_WIDTH on functionGen instance %m is set to %d. Must be at least 4.\", FREQ_WIDTH);\n        #1 $finish;\n    end\n    if (INCLUDE_CLAMP != 0 && INCLUDE_CLAMP != 1) begin\n        $display(\"Attribute INCLUDE_CLAMP on functionGen instance %m is set to %d. Valid values are 0 and 1.\", INCLUDE_CLAMP);\n        #1 $finish;\n    end\nend\n\nlocalparam WAVE_SINE     = 0;\nlocalparam WAVE_TRIANGLE = 1;\nlocalparam WAVE_SQUARE   = 2;\nlocalparam WAVE_SAWTOOTH = 3;\n\nlocalparam LOCAL_WIDTH = 18; localparam ANGLE_WIDTH = 10;\nlocalparam SINE_WIDTH = 18;\n\nlocalparam TABLE_LEN = 2**(ANGLE_WIDTH);\nlocalparam WIDE_WIDTH = OUT_WIDTH+LOCAL_WIDTH;\n\nwire [FREQ_WIDTH-3:0] xorPhase;\nwire [ANGLE_WIDTH-1:0] xorSdPhase;\n\nreg signed [LOCAL_WIDTH-1:0] sineOrTriangle;\nreg signed [WIDE_WIDTH+1:0] wideSignalWord;\nreg signed [LOCAL_WIDTH-1:0] unscaledSignal;\nreg signed [OUT_WIDTH-1:0] clampedSignal;\n\nreg [ANGLE_WIDTH+1:0] sdPhase;\nreg [FREQ_WIDTH-1:0] phaseAcc;\nreg [FREQ_WIDTH-1:0] phase;\nreg [SINE_WIDTH-1:0] sineTable [TABLE_LEN-1:0];\nreg [SINE_WIDTH-1:0] halfSine;\nreg [LOCAL_WIDTH-2:0] halfSineOrTriangle;\nreg signBit;\nreg signBitD1;\n\ninteger i;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        phase          <= 'd0;\n        phaseAcc       <= 'd0;\n        wideSignalWord <= 'd0;\n        unscaledSignal <= 'd0;\n    end\n    else if (en) begin\n        phaseAcc       <= phaseAcc + freq;\n        phase          <= phaseAcc + phaseOffset;\n\n        case (waveType)\n            WAVE_SINE     : unscaledSignal <= sineOrTriangle;\n            WAVE_TRIANGLE : unscaledSignal <= sineOrTriangle;\n            WAVE_SQUARE   : unscaledSignal <= {phase[FREQ_WIDTH-1], {(LOCAL_WIDTH-2){~phase[FREQ_WIDTH-1]}}, 1'b1};\n            WAVE_SAWTOOTH : begin\n                if (FREQ_WIDTH >= LOCAL_WIDTH) begin\n                    unscaledSignal <= $signed(phase) >>> (FREQ_WIDTH-LOCAL_WIDTH);\n                end\n                else begin\n                    unscaledSignal <= $signed(phase) <<< (LOCAL_WIDTH-FREQ_WIDTH);\n                end\n            end\n        endcase\n\n        if (BIT_COMPRESS_OUTPUT) begin\n            wideSignalWord <= unscaledSignal * $signed({1'b0, amplitude}) \n                            + $signed({offset, wideSignalWord[LOCAL_WIDTH-1:0]});\n        end\n        else begin\n            wideSignalWord <= unscaledSignal * $signed({1'b0, amplitude}) \n                            + $signed({offset, {LOCAL_WIDTH{1'b0}}});\n        end\n\n        clampedSignal  <= !(&wideSignalWord[WIDE_WIDTH+1-:3] | ~|wideSignalWord[WIDE_WIDTH+1-:3])\n                        ? {wideSignalWord[WIDE_WIDTH+1], {(OUT_WIDTH-1){~wideSignalWord[WIDE_WIDTH+1]}}}\n                        :  wideSignalWord[WIDE_WIDTH-1-:OUT_WIDTH];\n\n    end\nend\n\nif (INCLUDE_CLAMP) begin\n    assign outSignal = clampedSignal;\nend\nelse begin\n    assign outSignal = wideSignalWord[WIDE_WIDTH-1-:OUT_WIDTH];\nend\n\nif (ANGLE_WIDTH+2 >= FREQ_WIDTH) begin\n    always @(phase) begin\n        sdPhase = phase << (ANGLE_WIDTH+2-FREQ_WIDTH);\n    end\nend\nelse if (BIT_COMPRESS_PHASE) begin\n    reg [(FREQ_WIDTH-ANGLE_WIDTH-3):0] sdPhaseAcc;\n    always @(posedge clk) begin\n        if (rst) begin\n            sdPhase <= 'd0;\n            sdPhaseAcc <= 'd0;\n        end\n        else begin\n            {sdPhase,sdPhaseAcc} <= phase + sdPhaseAcc;\n        end\n    end\nend\nelse begin\n    always @(phase) begin\n        sdPhase = phase >> (FREQ_WIDTH-ANGLE_WIDTH-2);\n    end\nend\n\n\nassign xorPhase = (phase[FREQ_WIDTH-2]) ? ~phase[FREQ_WIDTH-3:0] : phase[FREQ_WIDTH-3:0];\n\nif (BIT_COMPRESS_PHASE) begin\n    assign xorSdPhase = (sdPhase[ANGLE_WIDTH]) ? ~sdPhase[ANGLE_WIDTH-1:0] : sdPhase[ANGLE_WIDTH-1:0];\nend\nelse begin\n    if (ANGLE_WIDTH+2 >= FREQ_WIDTH) begin\n        assign xorSdPhase = xorPhase << (ANGLE_WIDTH+2-FREQ_WIDTH);\n    end\n    else begin\n        assign xorSdPhase = xorPhase >> (FREQ_WIDTH-ANGLE_WIDTH-2);\n    end\nend\n\ninitial begin\n    signBit            = 1'b0;\n    signBitD1          = 1'b0;\n    halfSine           = 'd0;\n    halfSineOrTriangle = 'd0;\n    sineOrTriangle     = 'd0;\n    for(i=0; i<TABLE_LEN; i=i+1) begin\n        sineTable[i] = $rtoi($floor($sin((i+0.5)*3.14159265358979/(TABLE_LEN*2))*(2**SINE_WIDTH-1)+0.5));\n    end\nend\n\nalways @(posedge clk) begin\n    if (en) begin\n        signBit    <= sdPhase[ANGLE_WIDTH+1];\n        signBitD1  <= signBit;\n        halfSine <= sineTable[xorSdPhase];\n        if ((SINE_WIDTH > LOCAL_WIDTH-1) && (FREQ_WIDTH > LOCAL_WIDTH)) begin\n            halfSineOrTriangle <= (waveType[0]) ? {xorPhase,1'b1} >> (FREQ_WIDTH-LOCAL_WIDTH) : halfSine >> (SINE_WIDTH-LOCAL_WIDTH+1);\n        end \n        else if ((SINE_WIDTH > LOCAL_WIDTH-1) && (FREQ_WIDTH <= LOCAL_WIDTH)) begin\n            halfSineOrTriangle <= (waveType[0]) ? {xorPhase,1'b1} << (LOCAL_WIDTH-FREQ_WIDTH) : halfSine >> (SINE_WIDTH-LOCAL_WIDTH+1);\n        end \n        else if ((SINE_WIDTH <= LOCAL_WIDTH-1) && (FREQ_WIDTH > LOCAL_WIDTH)) begin\n            halfSineOrTriangle <= (waveType[0]) ? {xorPhase,1'b1} >> (FREQ_WIDTH-LOCAL_WIDTH) : halfSine << (LOCAL_WIDTH-1-SINE_WIDTH);\n        end \n        else begin\n            halfSineOrTriangle <= (waveType[0]) ? {xorPhase,1'b1} << (LOCAL_WIDTH-FREQ_WIDTH) : halfSine << (LOCAL_WIDTH-1-SINE_WIDTH);\n        end \n        sineOrTriangle <= $signed({LOCAL_WIDTH{signBitD1}} ^ {1'b0, halfSineOrTriangle}) + $signed({1'b0, signBitD1});\n    end\nend\nendmodule\n",
        "module_name": "functionGen #",
        "module_hash": "e62bef60c188cab72f77cc87758a8917",
        "dataset_index": 21648
      },
      "mux_594c0dbf": {
        "rtl_code": "\nmodule mux (\n  input ctrl,\n  input D0,\n  input D1,\n  output S\n);\n\n  assign S = ctrl ? D1 : D0;\n\nendmodule",
        "module_name": "mux",
        "module_hash": "594c0dbfef297920edfbc5bbd49c70cc",
        "dataset_index": 1019
      },
      "IrDA_transmitter_62951da2": {
        "rtl_code": "\nmodule IrDA_transmitter (\n  input clk,\n  input rst,\n  input [7:0] data_in,\n  output ir_out\n);\n  reg [7:0] data_reg;\n  reg [3:0] pwm_counter;\n  reg pwm_out;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      data_reg <= 8'h0;\n      pwm_counter <= 4'h0;\n      pwm_out <= 1'b0;\n    end else begin\n      data_reg <= data_in;\n      pwm_counter <= pwm_counter + 1;\n      pwm_out <= (pwm_counter < data_reg[3:0]) ? 1'b1 : 1'b0;\n    end\n  end\n\n  assign ir_out = pwm_out;\nendmodule\nmodule IrDA_receiver (\n  input clk,\n  input rst,\n  input ir_in,\n  output [7:0] data_out\n);\n  reg [3:0] pwm_counter;\n  reg [7:0] data_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      data_reg <= 8'h0;\n      pwm_counter <= 4'h0;\n    end else begin\n      if (ir_in) begin\n        pwm_counter <= pwm_counter + 1;\n      end else begin\n        if (pwm_counter != 4'h0) begin\n          data_reg <= {data_reg[6:0], pwm_counter[3]};\n          pwm_counter <= 4'h0;\n        end\n      end\n    end\n  end\n\n  assign data_out = data_reg;\nendmodule",
        "module_name": "IrDA_transmitter",
        "module_hash": "62951da2d4ed9200d521fbe219e33c4a",
        "dataset_index": 11585
      },
      "top__d508f861": {
        "rtl_code": "module top_module (\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    input [1:0] sel,\n    output [15:0] out_not,\n    output [7:0] out_and_bitwise,\n    output [7:0] out_xor_bitwise,\n    output [7:0] out_nor_bitwise\n);\n\n    // 4-to-1 Multiplexer\n    wire [7:0] mux_out;\n    assign mux_out = (sel == 2'b00) ? in0 :\n                     (sel == 2'b01) ? in1 :\n                     (sel == 2'b10) ? in2 :\n                                      in3;\n\n    // Bitwise Operations\n    wire [7:0] and_out;\n    wire [7:0] xor_out;\n    wire [7:0] nor_out;\n    assign and_out = in0 & in1;\n    assign xor_out = in2 ^ in3;\n    assign nor_out = ~(in0 | in1);\n\n    // NOT Inverse\n    wire [7:0] inv1;\n    wire [7:0] inv2;\n    assign inv1 = ~mux_out;\n    assign inv2 = ~{in3, in2};\n\n    // Output\n    assign out_not = {inv2, inv1};\n    assign out_and_bitwise = and_out;\n    assign out_xor_bitwise = xor_out;\n    assign out_nor_bitwise = nor_out;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "d508f86114c41956546d9d0ee6a69cf1",
        "dataset_index": 3546
      },
      "value_converter_4a8de49b": {
        "rtl_code": "module value_converter(\n  input [3:0] input_val,\n  output reg [2:0] output_val\n);\n\nalways @(*) begin\n  case(input_val)\n    4'd5, 4'd6: output_val = 3'd7;\n    default: output_val = input_val[2:0];\n  endcase\nend\n\nendmodule",
        "module_name": "value_converter",
        "module_hash": "4a8de49b615ec1bdbadcab33527a6511",
        "dataset_index": 16786
      },
      "ddr3_int_ex_lfsr8_e31cfeea": {
        "rtl_code": "module ddr3_int_ex_lfsr8 (\nclk, reset_n, enable, pause, load, data, ldata);\n\n   parameter seed  = 32;\n   input clk;\n   input reset_n;\n   input enable;\n   input pause;\n   input load;\n   output[8 - 1:0] data;\n   wire[8 - 1:0] data;\n   input[8 - 1:0] ldata;\n\n   reg[8 - 1:0] lfsr_data;\n\n   assign data = lfsr_data ;\n\n   always @(posedge clk or negedge reset_n)\n   begin\n      if (!reset_n)\n      begin\n         lfsr_data <= seed[7:0] ;\n      end\n      else\n      begin\n         if (!enable)\n         begin\n            lfsr_data <= seed[7:0];\n         end\n         else\n         begin\n            if (load)\n            begin\n               lfsr_data <= ldata ;\n            end\n            else\n            begin\n               if (!pause)\n               begin\n                  lfsr_data[0] <= lfsr_data[7] ;\n                  lfsr_data[1] <= lfsr_data[0] ;\n                  lfsr_data[2] <= lfsr_data[1] ^ lfsr_data[7] ;\n                  lfsr_data[3] <= lfsr_data[2] ^ lfsr_data[7] ;\n                  lfsr_data[4] <= lfsr_data[3] ^ lfsr_data[7] ;\n                  lfsr_data[5] <= lfsr_data[4] ;\n                  lfsr_data[6] <= lfsr_data[5] ;\n                  lfsr_data[7] <= lfsr_data[6] ;\n               end\n            end\n         end\n      end\n   end\nendmodule\n",
        "module_name": "ddr3_int_ex_lfsr8",
        "module_hash": "e31cfeeaf63dfa602cd84821426fa33b",
        "dataset_index": 24592
      },
      "my_nand4_6835fddf": {
        "rtl_code": "\nmodule my_nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input A;\n    input B;\n    input C;\n    input D;\n\n    wire Y1, Y2, Y3;\n\n    nand (Y1, A, B, C, D);\n\n    nand (Y2, Y1, 1'b1, 1'b1, 1'b1);\n\n    nand (Y3, Y2, 1'b1, 1'b1, 1'b1);\n\n    nand (Y, Y3, 1'b1, 1'b1, 1'b1);\n\nendmodule",
        "module_name": "my_nand4",
        "module_hash": "6835fddfed55d7b27ca21ebf1e9efb10",
        "dataset_index": 13562
      },
      "glitch_filter_acbc5b64": {
        "rtl_code": "\nmodule glitch_filter (\n  input clk,\n  input in,\n  output reg out\n);\n\nparameter p = 5; // number of clock cycles for the delay line\nparameter q = 2; // number of clock cycles for the glitch filter\n\nreg [p-1:0] delay_line; // shift register for delay line\n\nalways @(posedge clk) begin\n  delay_line <= {delay_line[p-2:0], in}; // shift input into delay line\n  if (in != delay_line[p-1]) begin\n    out <= delay_line[p-1]; // output delayed input signal\n  end\n  if (in != delay_line[p-1] && in == delay_line[p-q-1]) begin\n    out <= delay_line[p-2]; // remove glitch by setting output to previous value\n  end\nend\n\nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "acbc5b649fec68e7f070347c5884e416",
        "dataset_index": 14415
      },
      "oh_iddr #_7ce5daf2": {
        "rtl_code": "module oh_iddr #(parameter DW      = 1 )\n   (\n    input \t\tclk, input \t\tce, input [DW-1:0] \tdin, output reg [DW-1:0] q1, output reg [DW-1:0] q2   );\n   \n   reg [DW-1:0]     q1_sl;\n   reg [DW-1:0]     q2_sh;\n   \n   always @ (posedge clk)\n     if(ce)\n       q1_sl[DW-1:0] <= din[DW-1:0];\n   \n   always @ (negedge clk)\n     q2_sh[DW-1:0] <= din[DW-1:0];\n   \n   always @ (posedge clk)\n     begin\n\tq1[DW-1:0] <= q1_sl[DW-1:0];\n\tq2[DW-1:0] <= q2_sh[DW-1:0];\n     end\n            \nendmodule ",
        "module_name": "oh_iddr #",
        "module_hash": "7ce5daf2084a933d0269d591bcbc7e6f",
        "dataset_index": 3398
      },
      "four_to_one_b496d77f": {
        "rtl_code": "module four_to_one(\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    output out\n);\n\n    assign out = (in1 || in2 || in3) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "four_to_one",
        "module_hash": "b496d77f05968b8b18bbfaba35be3cf9",
        "dataset_index": 2313
      },
      "ddr_clkout_a0829920": {
        "rtl_code": "\nmodule ddr_clkout (pad, clk);\ninput clk;\noutput pad;\n\nreg sync_clk;\nwire clk_out;\nreg [7:0] count;\ninteger temp,flag1,flag2;\n\n// First stage of synchronizer\nreg sync_d1;\nalways @(posedge clk)\n    sync_d1 <= clk;\n\n// Second stage of synchronizer\nreg sync_d2;\nalways @(posedge sync_clk)\n    sync_d2 <= sync_d1;\n\n// Counter to generate clock signal\nalways @(posedge sync_clk) begin\n    if (count == 8'hFF)\n        count <= 0;\n    else\n        count <= count + 1;\nend\n\n// Output clock signal\nassign clk_out = count[6];\n\n// D flip-flop to generate 50% duty cycle\nreg d, d_temp;\nalways @(posedge clk_out)\n    d <= ~d;\n\n// Output to pad\nassign pad = d;\n\n// Synchronize input clock signal\nalways @(posedge clk)\n    sync_clk <= ~sync_clk;\n\nendmodule",
        "module_name": "ddr_clkout",
        "module_hash": "a0829920d5581952cf39c8f83dd140ab",
        "dataset_index": 14847
      },
      "bmu_6d2375d6": {
        "rtl_code": "\nmodule bmu ( cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7 );\n  input cx0, cx1;\n  output [1:0] bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;\n\n  assign bm0 = cx0 ? 2'b00 : 2'b11;\n  assign bm1 = cx0 ? 2'b01 : 2'b10;\n  assign bm2 = cx1 ? 2'b00 : 2'b11;\n  assign bm3 = cx1 ? 2'b01 : 2'b10;\n  assign bm4 = cx1 ? 2'b00 : 2'b11;\n  assign bm5 = cx1 ? 2'b01 : 2'b10;\n  assign bm6 = cx1 ? 2'b00 : 2'b11;\n  assign bm7 = cx1 ? 2'b10 : 2'b01;\nendmodule\nmodule add_compare_select_3 ( npm, d, pm1, bm1, pm2, bm2 );\n  input [3:0] npm;\n  output d;\n  input [3:0] pm1, pm2;\n  input [1:0] bm1, bm2;\n\n  assign d = ( npm[3] == bm1[1] & npm[2:0] == bm1[0] ) ? pm1[3:0] : pm2[3:0];\nendmodule\nmodule add_compare_select_2 ( npm, d, pm1, bm1, pm2, bm2 );\n  input [3:0] npm;\n  output d;\n  input [3:0] pm1, pm2;\n  input [1:0] bm1, bm2;\n\n  assign d = ( npm[3:1] == {bm1[1], bm1[0]} ) ? pm1[3:0] : pm2[3:0];\nendmodule\nmodule add_compare_select_1 ( npm, d, pm1, bm1, pm2, bm2 );\n  input [3:0] npm;\n  output d;\n  input [3:0] pm1, pm2;\n  input [1:0] bm1, bm2;\n\n  assign d = ( npm[3] == bm1[1] ) ? pm1[3:0] : pm2[3:0];\nendmodule\nmodule add_compare_select_0 ( npm, d, pm1, bm1, pm2, bm2 );\n  input [3:0] npm;\n  output d;\n  input [3:0] pm1, pm2;\n  input [1:0] bm1, bm2;\n\n  assign d = pm1[3:0];\nendmodule\nmodule pmsm ( npm0, npm1, npm2, npm3, pm0, pm1, pm2, pm3, clk, reset );\n  input [3:0] npm0, npm1, npm2, npm3;\n  output [3:0] pm0, pm1, pm2, pm3;\n  input clk, reset;\n\n  reg [3:0] pm0_reg, pm1_reg, pm2_reg, pm3_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      pm0_reg <= 4'b0;\n      pm1_reg <= 4'b0;\n      pm2_reg <= 4'b0;\n      pm3_reg <= 4'b0;\n    end else begin\n      pm0_reg <= npm0;\n      pm1_reg <= npm1;\n      pm2_reg <= npm2;\n      pm3_reg <= npm3;\n    end\n  end\n\n  assign pm0 = pm0_reg;\n  assign pm1 = pm1_reg;\n  assign pm2 = pm2_reg;\n  assign pm3 = pm3_reg;\nendmodule\nmodule spd ( d0, d1, d2, d3, pm0, pm1, pm2, pm3, out, clk, reset );\n  input d0, d1, d2, d3;\n  input [3:0] pm0, pm1, pm2, pm3;\n  output out;\n  input clk, reset;\n\n  reg [3:0] pm_reg;\n  reg out_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      pm_reg <= 4'b0;\n      out_reg <= 0;\n    end else begin\n      pm_reg <= {pm_reg[2:0], out_reg};\n      out_reg <= (pm_reg == pm0);\n    end\n  end\n\n  assign out = out_reg;\nendmodule\nmodule viterbi_decoder ( d, cx, clk, reset );\n  input [1:0] cx;\n  input clk, reset;\n  output d;\n\n  wire d0, d1, d2, d3;\n  wire [1:0] brch_met0, brch_met1, brch_met2, brch_met3;\n  wire [3:0] p_m0, p_m1, p_m2, p_m3;\n\n  bmu brch_met ( .cx0(cx[0]), .cx1(cx[1]), .bm0(brch_met0), .bm1(brch_met1),\n        .bm2(brch_met2), .bm3(brch_met3) );\n\n  add_compare_select_3 acs0 ( .npm(p_m0), .d(d0), .pm1(p_m0), .bm1(brch_met0),\n        .pm2(p_m1), .bm2(brch_met2) );\n\n  add_compare_select_2 acs1 ( .npm(p_m1), .d(d1), .pm1(p_m2), .bm1(brch_met0),\n        .pm2(p_m3), .bm2(brch_met1) );\n\n  add_compare_select_1 acs2 ( .npm(p_m2), .d(d2), .pm1(p_m0), .bm1(brch_met3),\n        .pm2(p_m1), .bm2(brch_met1) );\n\n  add_compare_select_0 acs3 ( .npm(p_m3), .d(d3), .pm1(p_m2), .bm1(brch_met3),\n        .pm2(p_m3), .bm2(brch_met2) );\n\n  pmsm path_metric_sm ( .npm0(p_m0), .npm1(p_m1), .npm2(p_m2), .npm3(p_m3),\n        .pm0(p_m0), .pm1(p_m1), .pm2(p_m2), .pm3(p_m3), .clk(clk), .reset(\n        reset) );\n\n  spd survivor_path_dec ( .d0(d0), .d1(d1), .d2(d2), .d3(d3), .pm0(p_m0),\n        .pm1(p_m1), .pm2(p_m2), .pm3(p_m3), .out(d), .clk(clk), .reset(reset)\n         );\n\nendmodule",
        "module_name": "bmu",
        "module_hash": "6d2375d657ab5cda2fab8299f9ce10f7",
        "dataset_index": 15035
      },
      "binary_to_gray_c9711612": {
        "rtl_code": "module binary_to_gray (\n    input  [7:0] binary_in,\n    output [7:0] gray_out\n);\n    assign gray_out = binary_in ^ ({1'b0, binary_in[7:1]});\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "c971161254794463c7b3b61393ea42f4",
        "dataset_index": 200
      },
      "crc__df1eb75e": {
        "rtl_code": "\nmodule crc_module (\n  input clk,\n  input [63:0] data_in,\n  output reg [63:0] checksum\n);\n\n  integer cyc = 0;\n  reg [63:0] crc;\n  wire [1:0] o[3:0]; // declare o as a 4-element array of 2-bit wires\n\n  assign o[0] = {crc[1], crc[0]};\n  assign o[1] = {crc[3], crc[2]};\n  assign o[2] = {crc[5], crc[4]};\n  assign o[3] = {crc[7], crc[6]};\n\n  always @ (posedge clk) begin\n    cyc <= cyc + 1;\n    crc <= {crc[62:0], crc[63] ^ crc[2] ^ crc[0]};\n    if (cyc == 0) begin\n      crc <= 64'h5aef0c8d_d70a4497;\n    end\n    else if (cyc >= 90) begin\n      checksum <= {32'h0, 6'h0, o[3], 6'h0, o[2], 6'h0, o[1], 6'h0, o[0]};\n    end\n  end\n\nendmodule\n\nmodule Test (\n  input [1:0] i,\n  output [1:0] o\n);\n\n  assign o = (i == 2'b00) ? 2'b00 :\n             (i == 2'b01) ? 2'b11 :\n             (i == 2'b10) ? 2'b01 :\n             (i == 2'b11) ? 2'b10 :\n             2'bx;\n\nendmodule\n",
        "module_name": "crc_",
        "module_hash": "df1eb75edfc6d69afa21131cbdaf4448",
        "dataset_index": 3841
      },
      "objPixelOn_d07a7247": {
        "rtl_code": "module objPixelOn (\n  input [7:0] pixelNum,\n  input [7:0] objPos,\n  input [7:0] objMask,\n  input [2:0] objSize,\n  output      pixelOn\n);\n\n  wire [7:0]  objIndex;\n  wire [8:0]  objByteIndex;\n  wire        objMaskOn, objPosOn;\n  reg         objSizeOn;\n  reg [2:0]   objMaskSel;\n\n  assign objIndex = pixelNum - objPos - 8'd1;\n  assign objByteIndex = 9'b1 << (objIndex[7:3]);\n\n  always @* begin\n    case (objSize)\n      3'd0: objSizeOn = (objByteIndex & 9'b00000001) != 0;\n      3'd1: objSizeOn = (objByteIndex & 9'b00000101) != 0;\n      3'd2: objSizeOn = (objByteIndex & 9'b00010001) != 0;\n      3'd3: objSizeOn = (objByteIndex & 9'b00010101) != 0;\n      3'd4: objSizeOn = (objByteIndex & 9'b10000001) != 0;\n      3'd5: objSizeOn = (objByteIndex & 9'b00000011) != 0;\n      3'd6: objSizeOn = (objByteIndex & 9'b10010001) != 0;\n      3'd7: objSizeOn = (objByteIndex & 9'b00001111) != 0;\n    endcase\n  end\n\n  always @* begin\n    case (objSize)\n      3'd5: objMaskSel = objIndex[3:1];\n      3'd7: objMaskSel = objIndex[4:2];\n      default: objMaskSel = objIndex[2:0];\n    endcase\n  end\n\n  assign objMaskOn = objMask[objMaskSel];\n\n  assign objPosOn = (pixelNum > objPos) && ({1'b0, pixelNum} <= {1'b0, objPos} + 9'd72);\n\n  assign pixelOn = objSizeOn && objMaskOn && objPosOn;\n\nendmodule",
        "module_name": "objPixelOn",
        "module_hash": "d07a724714aebf4e914b1700bfe8abae",
        "dataset_index": 9812
      },
      "binary_counter_1c8455dd": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 4'b0;\n    end else if (count == 4'b1111) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "1c8455dd66c573a21402af49c659473c",
        "dataset_index": 3797
      },
      "memory_interface #_427a1fc3": {
        "rtl_code": "\nmodule memory_interface #(\n  parameter AW = 12,\n  parameter DW = 32,\n  parameter DP = 1024\n)(\n  input clk,\n  input rst_n,\n  input icb_cmd_valid,\n  output icb_cmd_ready,\n  input [AW-1:0] icb_cmd_addr,\n  input icb_cmd_read,\n  output icb_rsp_valid,\n  input icb_rsp_ready,\n  output icb_rsp_err,\n  output [DW-1:0] icb_rsp_rdata\n);\n\n  wire [DW-1:0] mem_dout;\n  wire [AW-1:0] mem_addr;\n  wire [DW-1:0] mem_din;\n  wire mem_we = ~icb_cmd_read;\n\n  assign mem_addr = icb_cmd_addr[AW-1:2];\n  assign icb_cmd_ready = 1'b1;\n\n  memory #(\n    .AW(AW),\n    .DW(DW),\n    .DP(DP)\n  ) mem (\n    .clk(clk),\n    .rst_n(rst_n),\n    .addr(mem_addr),\n    .din(mem_din),\n    .dout(mem_dout),\n    .we(mem_we)\n  );\n\n  assign icb_rsp_rdata = mem_dout;\n  assign icb_rsp_valid = (icb_cmd_valid && icb_cmd_ready) ? 1'b1 : 1'b0;\n  assign icb_rsp_err = 1'b0;\n  assign mem_din = (icb_cmd_read) ? 0 : icb_rsp_rdata;\n\nendmodule\nmodule memory #(\n  parameter AW = 12,\n  parameter DW = 32,\n  parameter DP = 1024\n)(\n  input clk,\n  input rst_n,\n  input [AW-1:0] addr,\n  input [DW-1:0] din,\n  output reg [DW-1:0] dout,\n  input we\n);\n\n  reg [DW-1:0] mem [DP-1:0];\n\n  always @(posedge clk) begin\n    if (!rst_n) begin\n      dout <= 0;\n    end else begin\n      if (we) begin\n        mem[addr] <= din;\n      end else begin\n        dout <= mem[addr];\n      end\n    end\n  end\n\nendmodule",
        "module_name": "memory_interface #",
        "module_hash": "427a1fc36c9d03f7a72b68f315f8b0d2",
        "dataset_index": 19055
      },
      "timer_1092f5f3": {
        "rtl_code": "module timer(\n    input CLK_I,\n    input RST_I,\n    \n    input [31:2] ADR_I,\n    input CYC_I,\n    input STB_I,\n    input WE_I,\n    \n    output reg RTY_O,\n    output reg interrupt_o\n);\n\n    reg [27:0] counter;\n\n    always @(posedge CLK_I) begin\n        if(RST_I == 1'b1) begin\n            RTY_O <= 1'b0;\n            interrupt_o <= 1'b0;\n            counter <= 28'd0;\n        end\n        else if(counter == 28'h00FFFFF) begin\n            if(ADR_I == { 27'b1111_1111_1111_1111_1111_1111_111, 3'b001 } && CYC_I == 1'b1 && STB_I == 1'b1 && WE_I == 1'b0 && interrupt_o == 1'b1) begin\n                RTY_O <= 1'b1;\n                interrupt_o <= 1'b0;\n                counter <= 28'd0;\n            end\n            else begin\n                interrupt_o <= 1'b1;\n            end\n        end\n        else begin\n            RTY_O <= 1'b0;\n            counter <= counter + 28'd1;\n        end\n    end\n\nendmodule",
        "module_name": "timer",
        "module_hash": "1092f5f3942a798bfac0b0b1cb0be671",
        "dataset_index": 602
      },
      "sky130_fd_sc_hdll__a32o_e9c2e3f7": {
        "rtl_code": "module sky130_fd_sc_hdll__a32o (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    // Module ports\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , A3, A1, A2        );\n    and and1 (and1_out , B1, B2            );\n    or  or0  (or0_out_X, and1_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule",
        "module_name": "sky130_fd_sc_hdll__a32o",
        "module_hash": "e9c2e3f7319e9d0eb488134c6ae2acc7",
        "dataset_index": 2074
      },
      "boolean_func_4db9e93e": {
        "rtl_code": "module boolean_func(\n    input wire A1,\n    input wire A2,\n    input wire B1,\n    input wire B2,\n    input wire VPWR,\n    input wire VGND,\n    input wire VPB,\n    input wire VNB,\n    output wire X\n);\n\n    assign X = (A1 & A2) | (B1 & B2 & VPWR & VGND & VPB & VNB);\n\nendmodule",
        "module_name": "boolean_func",
        "module_hash": "4db9e93e23b839bbe20b0e94a6601319",
        "dataset_index": 16308
      },
      "DLL_6c410206": {
        "rtl_code": "module DLL (\n  input ref_clk,\n  input feedback_clk,\n  input [7:0] delay,\n  output out_clk\n);\n\n  reg [7:0] delay_reg;\n  reg [7:0] delay_next;\n  reg [7:0] error;\n  reg [7:0] error_filtered;\n  reg [7:0] error_integrated;\n  reg [7:0] error_integrated_next;\n  reg [7:0] error_filtered_next;\n  reg [7:0] phase_detector_out;\n  reg [7:0] delay_line_out;\n  reg [7:0] out_clk_reg;\n  reg [7:0] out_clk_next;\n\n  always @(posedge ref_clk) begin\n    delay_reg <= delay;\n    delay_next <= delay_reg;\n    error <= phase_detector_out;\n    error_filtered <= error_filtered_next;\n    error_integrated <= error_integrated_next;\n    out_clk_reg <= out_clk_next;\n  end\n\n  always @(posedge feedback_clk) begin\n    delay_line_out <= delay_reg[7] ? feedback_clk : delay_line_out;\n    delay_line_out <= delay_reg[6] ? delay_line_out : feedback_clk;\n    delay_line_out <= delay_reg[5] ? delay_line_out : feedback_clk;\n    delay_line_out <= delay_reg[4] ? delay_line_out : feedback_clk;\n    delay_line_out <= delay_reg[3] ? delay_line_out : feedback_clk;\n    delay_line_out <= delay_reg[2] ? delay_line_out : feedback_clk;\n    delay_line_out <= delay_reg[1] ? delay_line_out : feedback_clk;\n    delay_line_out <= delay_reg[0] ? delay_line_out : feedback_clk;\n\n    phase_detector_out <= delay_line_out ^ feedback_clk;\n\n    error_filtered_next <= (error_filtered + error) >> 1;\n    error_integrated_next <= error_integrated + error_filtered_next;\n\n    delay_next <= delay_reg + error_integrated_next;\n\n    out_clk_next <= delay_reg[7] ? delay_line_out : out_clk_reg;\n    out_clk_next <= delay_reg[6] ? out_clk_reg : delay_line_out;\n    out_clk_next <= delay_reg[5] ? out_clk_reg : delay_line_out;\n    out_clk_next <= delay_reg[4] ? out_clk_reg : delay_line_out;\n    out_clk_next <= delay_reg[3] ? out_clk_reg : delay_line_out;\n    out_clk_next <= delay_reg[2] ? out_clk_reg : delay_line_out;\n    out_clk_next <= delay_reg[1] ? out_clk_reg : delay_line_out;\n    out_clk_next <= delay_reg[0] ? out_clk_reg : delay_line_out;\n  end\n\n  assign out_clk = out_clk_reg;\n\nendmodule",
        "module_name": "DLL",
        "module_hash": "6c410206dcf3caa5f4a4f034baa5a7aa",
        "dataset_index": 15385
      },
      "four_input_one_output_b69eb929": {
        "rtl_code": "module four_input_one_output (\n    input a,\n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    if (a) begin\n        out = 1;\n    end else if (b) begin\n        out = 1;\n    end else if (c) begin\n        out = 1;\n    end else if (d) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule",
        "module_name": "four_input_one_output",
        "module_hash": "b69eb9298d14586fb23c6b11268af042",
        "dataset_index": 15324
      },
      "my_fpga_adcc8781": {
        "rtl_code": "\nmodule my_fpga(\n    input wire clk,\n    input wire n_rst,\n    input wire up,\n    input wire dn,\n    output reg [31:0] cnt,\n    output reg [3:0] cnt_1k,\n    input wire in1,\n    input wire in2,\n    output reg out1,\n    output reg out2\n);\n\n    reg [31:0] cnt_reg;\n    reg [3:0] cnt_1k_reg;\n    reg [31:0] cnt_1k_divider;\n    reg [31:0] cnt_1k_divider_reg;\n    reg cnt_1k_enable;\n\n    always @(posedge clk or negedge n_rst) begin\n        if (~n_rst) begin\n            cnt_reg <= 0;\n            cnt_1k_reg <= 0;\n            cnt_1k_divider <= 0;\n            cnt_1k_divider_reg <= 0;\n            cnt_1k_enable <= 0;\n        end else begin\n            if (up && ~dn) begin\n                cnt_reg <= cnt_reg + 1;\n            end else if (~up && dn) begin\n                cnt_reg <= cnt_reg - 1;\n            end\n            cnt <= cnt_reg;\n\n            cnt_1k_enable <= 1;\n            if (cnt_1k_divider_reg == 0) begin\n                cnt_1k_divider_reg <= 100000;\n                if (cnt_1k_reg == 4'hf) begin\n                    cnt_1k_reg <= 0;\n                end else begin\n                    cnt_1k_reg <= cnt_1k_reg + 1;\n                end\n            end else begin\n                cnt_1k_divider_reg <= cnt_1k_divider_reg - 1;\n            end\n\n            if (cnt_1k_divider_reg == 1) begin\n                cnt_1k_divider_reg <= 0;\n            end\n            cnt_1k_divider <= cnt_1k_divider_reg;\n            cnt_1k <= cnt_1k_reg;\n\n            out1 <= in1;\n            out2 <= in2;\n        end\n    end\n\nendmodule",
        "module_name": "my_fpga",
        "module_hash": "adcc878101d0902617889e7e1904f814",
        "dataset_index": 18431
      },
      "sirv_gnrl_cdc_rx_b9a51b3b": {
        "rtl_code": "\nmodule sirv_gnrl_cdc_rx\n# (\n  parameter DW = 32,\n  parameter SYNC_DP = 2\n) (\n  // The 4-phases handshake interface at in-side\n  //     There are 4 steps required for a full transaction. \n  //         (1) The i_vld is asserted high \n  //         (2) The i_rdy is asserted high\n  //         (3) The i_vld is asserted low \n  //         (4) The i_rdy is asserted low\n  input  i_vld_a, \n  output i_rdy, \n  input  [DW-1:0] i_dat,\n  // The regular handshake interface at out-side\n  //         Just the regular handshake o_vld & o_rdy like AXI\n  output o_vld, \n  input  o_rdy, \n  output [DW-1:0] o_dat,\n\n  input  clk,\n  input  rst_n \n);\n\n// Synchronize the asynchronous input signal\nwire i_vld_sync;\nsirv_gnrl_sync #(.DP(SYNC_DP), .DW(1)) u_i_vld_sync (\n     .clk   (clk),\n     .rst_n (rst_n),\n     .din_a (i_vld_a),\n     .dout  (i_vld_sync)\n);\n\n// D-type flip-flop to capture the synchronized input signal\nreg i_vld_sync_r = 1'b0;\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        i_vld_sync_r <= 1'b0;\n    end else begin\n        i_vld_sync_r <= i_vld_sync;\n    end\nend\n\n// Set or clear the input ready signal based on the synchronized input signal\nwire buf_rdy;\nreg i_rdy_r = 1'b0;\nwire i_rdy_set = buf_rdy & i_vld_sync & (~i_rdy_r);\nwire i_rdy_clr = ~i_vld_sync & i_vld_sync_r;\nwire i_rdy_ena = i_rdy_set | i_rdy_clr;\nwire i_rdy_nxt = i_rdy_set | (~i_rdy_clr);\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        i_rdy_r <= 1'b0;\n    end else if (i_rdy_ena) begin\n        i_rdy_r <= i_rdy_nxt;\n    end\nend\nassign i_rdy = i_rdy_r;\n\n// D-type flip-flop to capture the input data\nreg [DW-1:0] buf_dat_r = {DW{1'b0}};\nwire buf_dat_ena = i_rdy_set;\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        buf_dat_r <= {DW{1'b0}};\n    end else if (buf_dat_ena) begin\n        buf_dat_r <= i_dat;\n    end\nend\n\n// Set or clear the buffer valid signal based on the output ready signal\nreg buf_vld_r = 1'b0;\nwire buf_vld_set = buf_dat_ena;\nwire buf_vld_clr = o_vld & o_rdy;\nwire buf_vld_ena = buf_vld_set | buf_vld_clr;\nwire buf_vld_nxt = buf_vld_set | (~buf_vld_clr);\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        buf_vld_r <= 1'b0;\n    end else if (buf_vld_ena) begin\n        buf_vld_r <= buf_vld_nxt;\n    end\nend\nassign buf_rdy = ~buf_vld_r;\n\n// Output the buffer data\nassign o_vld = buf_vld_r;\nassign o_dat = buf_dat_r;\n\nendmodule\nmodule sirv_gnrl_sync\n# (\n  parameter DP = 1,\n  parameter DW = 1\n) (\n  input  clk,\n  input  rst_n,\n  input  din_a,\n  output dout\n);\n\nreg [DP*DW-1:0] sync_r = {DP*DW{1'b0}};\n\nwire [DP*DW-1:0] sync_nxt;\ngenvar i;\nfor (i = 0; i < DP*DW; i = i + 1) begin\n    if (i == 0)\n        assign sync_nxt[i] = din_a;\n    else\n        assign sync_nxt[i] = sync_r[i-1] | (din_a & ~sync_r[i]);\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        sync_r <= {DP*DW{1'b0}};\n    end else begin\n        sync_r <= sync_nxt;\n    end\nend\n\nassign dout = sync_nxt[DP*DW-1];\n\nendmodule",
        "module_name": "sirv_gnrl_cdc_rx",
        "module_hash": "b9a51b3bee9331237276f825ebd45b0e",
        "dataset_index": 4348
      },
      "lcd_controller_4840c19b": {
        "rtl_code": "\nmodule lcd_controller(\n  input clk,\n  input rst,\n  input i_enable,\n  input i_cmd_mode,\n  input i_cmd_write_stb,\n  input i_cmd_read_stb,\n  input [7:0] i_cmd_data,\n  input [7:0] i_data,\n  output reg [7:0] o_cmd_data,\n  output reg [7:0] o_data,\n  output reg o_cmd_finished,\n  output reg o_write_n,\n  output reg o_read_n,\n  output reg o_cs_n,\n  output reg o_reset_n,\n  output reg o_data_out_en,\n  output reg o_register_data_sel\n);\n\n  reg [7:0] cmd_reg;\n  reg [7:0] data_reg;\n  reg cmd_finished;\n  reg write_n;\n  reg read_n;\n  reg cs_n;\n  reg reset_n;\n  reg data_out_en;\n  reg register_data_sel;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      cmd_reg <= 8'h00;\n      data_reg <= 8'h00;\n      cmd_finished <= 1'b0;\n      write_n <= 1'b0;\n      read_n <= 1'b0;\n      cs_n <= 1'b0;\n      reset_n <= 1'b0;\n      data_out_en <= 1'b0;\n      register_data_sel <= 1'b0;\n    end else begin\n      if (i_enable) begin\n        if (i_cmd_mode) begin\n          if (i_cmd_write_stb) begin\n            cmd_reg <= i_cmd_data;\n            cmd_finished <= 1'b1;\n          end else if (i_cmd_read_stb) begin\n            case (i_cmd_data)\n              8'h00: o_cmd_data <= 8'h00;\n              8'h01: o_cmd_data <= 8'h01;\n              8'h02: o_cmd_data <= 8'h02;\n              8'h03: o_cmd_data <= 8'h03;\n              8'h04: o_cmd_data <= 8'h04;\n              8'h05: o_cmd_data <= 8'h05;\n              8'h06: o_cmd_data <= 8'h06;\n              8'h07: o_cmd_data <= 8'h07;\n              8'h08: o_cmd_data <= 8'h08;\n              8'h09: o_cmd_data <= 8'h09;\n              8'h0A: o_cmd_data <= 8'h0A;\n              8'h0B: o_cmd_data <= 8'h0B;\n              8'h0C: o_cmd_data <= 8'h0C;\n              8'h0D: o_cmd_data <= 8'h0D;\n              8'h0E: o_cmd_data <= 8'h0E;\n              8'h0F: o_cmd_data <= 8'h0F;\n              default: o_cmd_data <= 8'h00;\n            endcase\n            cmd_finished <= 1'b1;\n          end\n        end else begin\n          if (write_n) begin\n            data_reg <= i_data;\n            write_n <= 1'b0;\n          end else if (read_n) begin\n            o_data <= data_reg;\n            read_n <= 1'b0;\n          end\n        end\n      end\n    end\n\n    if (i_cmd_mode) begin\n      write_n <= ~i_cmd_write_stb;\n      read_n <= ~i_cmd_read_stb;\n    end else begin\n      write_n <= ~i_cmd_write_stb;\n      read_n <= ~i_cmd_read_stb;\n    end\n\n    cs_n <= 1'b1;\n    reset_n <= 1'b1;\n    data_out_en <= 1'b1;\n    register_data_sel <= i_cmd_mode;\n\n    o_cmd_finished <= cmd_finished;\n    o_write_n <= write_n;\n    o_read_n <= read_n;\n    o_cs_n <= cs_n;\n    o_reset_n <= reset_n;\n    o_data_out_en <= data_out_en;\n    o_register_data_sel <= register_data_sel;\n  end\n\nendmodule",
        "module_name": "lcd_controller",
        "module_hash": "4840c19bee42541437e6c811401a1a40",
        "dataset_index": 17150
      },
      "vga_palette_regs_fml_19a63345": {
        "rtl_code": "\n\nmodule vga_palette_regs_fml (\n    input clk,\n\n    input      [3:0] attr,\n    output reg [7:0] index,\n\n    input      [3:0] address,\n    input            write,\n    output reg [7:0] read_data,\n    input      [7:0] write_data\n  );\n\n  reg [7:0] palette [0:15];\n\n  always @(posedge clk) index <= palette[attr];\n\n  always @(posedge clk) read_data <= palette[address];\n\n  always @(posedge clk)\n    if (write) palette[address] <= write_data;\n\nendmodule\n",
        "module_name": "vga_palette_regs_fml",
        "module_hash": "19a63345cf1681bd82f009e015f8ed53",
        "dataset_index": 24771
      },
      "vending_machine_5805ee71": {
        "rtl_code": "\nmodule vending_machine(\n    input clk,\n    input reset,\n    input button_A,\n    input button_B,\n    input button_C,\n    input dispense,\n    output product_X_selected,\n    output product_Y_selected,\n    output product_Z_selected,\n    output dispensed\n);\n\n    // Define the states\n    parameter IDLE = 2'b00;\n    parameter PRODUCT_X_SELECTED = 2'b01;\n    parameter PRODUCT_Y_SELECTED = 2'b10;\n    parameter PRODUCT_Z_SELECTED = 2'b11;\n    \n    // Define the current state and next state\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n    \n    // Define the outputs\n    reg product_X_selected_reg;\n    reg product_Y_selected_reg;\n    reg product_Z_selected_reg;\n    reg dispensed_reg;\n    \n    assign product_X_selected = product_X_selected_reg;\n    assign product_Y_selected = product_Y_selected_reg;\n    assign product_Z_selected = product_Z_selected_reg;\n    assign dispensed = dispensed_reg;\n    \n    // Define the state transition logic\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Define the next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (button_A) begin\n                    next_state = PRODUCT_X_SELECTED;\n                end else if (button_B) begin\n                    next_state = PRODUCT_Y_SELECTED;\n                end else if (button_C) begin\n                    next_state = PRODUCT_Z_SELECTED;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            PRODUCT_X_SELECTED: begin\n                if (button_A) begin\n                    next_state = PRODUCT_X_SELECTED;\n                end else if (button_B) begin\n                    next_state = PRODUCT_Y_SELECTED;\n                end else if (button_C) begin\n                    next_state = PRODUCT_Z_SELECTED;\n                end else if (dispense) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = PRODUCT_X_SELECTED;\n                end\n            end\n            PRODUCT_Y_SELECTED: begin\n                if (button_A) begin\n                    next_state = PRODUCT_X_SELECTED;\n                end else if (button_B) begin\n                    next_state = PRODUCT_Y_SELECTED;\n                end else if (button_C) begin\n                    next_state = PRODUCT_Z_SELECTED;\n                end else if (dispense) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = PRODUCT_Y_SELECTED;\n                end\n            end\n            PRODUCT_Z_SELECTED: begin\n                if (button_A) begin\n                    next_state = PRODUCT_X_SELECTED;\n                end else if (button_B) begin\n                    next_state = PRODUCT_Y_SELECTED;\n                end else if (button_C) begin\n                    next_state = PRODUCT_Z_SELECTED;\n                end else if (dispense) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = PRODUCT_Z_SELECTED;\n                end\n            end\n        endcase\n    end\n    \n    // Define the output logic\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            product_X_selected_reg <= 0;\n            product_Y_selected_reg <= 0;\n            product_Z_selected_reg <= 0;\n            dispensed_reg <= 0;\n        end else begin\n            case (next_state)\n                PRODUCT_X_SELECTED: begin\n                    product_X_selected_reg <= 1;\n                    product_Y_selected_reg <= 0;\n                    product_Z_selected_reg <= 0;\n                end\n                PRODUCT_Y_SELECTED: begin\n                    product_X_selected_reg <= 0;\n                    product_Y_selected_reg <= 1;\n                    product_Z_selected_reg <= 0;\n                end\n                PRODUCT_Z_SELECTED: begin\n                    product_X_selected_reg <= 0;\n                    product_Y_selected_reg <= 0;\n                    product_Z_selected_reg <= 1;\n                end\n                IDLE: begin\n                    product_X_selected_reg <= 0;\n                    product_Y_selected_reg <= 0;\n                    product_Z_selected_reg <= 0;\n                    dispensed_reg <= 0;\n                end\n            endcase\n        end\n    end\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "5805ee71364bd2bb857d192ce2d13e6c",
        "dataset_index": 18926
      },
      "up_down_counter_b72a7cd3": {
        "rtl_code": "\nmodule up_down_counter (\n    input  wire        clk,\n    input  wire        up_down,\n    input  wire        load,\n    input  wire        reset,\n    input  wire [3:0]    data_in,\n    output wire [3:0]    count\n);\n\n    reg [3:0] count_reg;\n    assign count = count_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 4'b0000;\n        end else if (load) begin\n            count_reg <= data_in;\n        end else if (up_down) begin\n            count_reg <= count_reg + 4'b0001;\n        end else begin\n            count_reg <= count_reg - 4'b0001;\n        end\n    end\nendmodule\n\nmodule magnitude_comparator (\n    input  wire [2:0]    a,\n    input  wire [2:0]    b,\n    input  wire        select,\n    output wire [2:0]    comparison_result,\n    output wire [1:0]    input_selected\n);\n\n    reg [2:0] comparison_result_reg;\n    reg [1:0] input_selected_reg;\n    assign comparison_result = comparison_result_reg;\n    assign input_selected = input_selected_reg;\n\n    always @(*) begin\n        if (select == 1'b0) begin\n            if (a > b) begin\n                comparison_result_reg = 3'b001;\n            end else if (a == b) begin\n                comparison_result_reg = 3'b010;\n            end else begin\n                comparison_result_reg = 3'b100;\n            end\n            input_selected_reg = 2'b00;\n        end else if (select == 1'b1) begin\n            if (b > a) begin\n                comparison_result_reg = 3'b001;\n            end else if (a == b) begin\n                comparison_result_reg = 3'b010;\n            end else begin\n                comparison_result_reg = 3'b100;\n            end\n            input_selected_reg = 2'b01;\n        end else begin\n            comparison_result_reg = 3'b000;\n            input_selected_reg = 2'b00;\n        end\n    end\nendmodule\n\nmodule top_module (\n    input  wire clk,\n    input  wire up_down,\n    input  wire load,\n    input  wire reset,\n    input  wire [2:0] a,\n    input  wire [2:0] b,\n    input  wire select,\n    output wire [3:0] count,\n    output wire [2:0] comparison_result,\n    output wire [1:0] input_selected\n);\n\n    wire [3:0] count_wire;\n    wire [2:0] comparison_result_wire;\n    wire [1:0] input_selected_wire;\n\n    up_down_counter counter (\n        .clk(clk),\n        .up_down(up_down),\n        .load(load),\n        .reset(reset),\n        .data_in({a, 1'b0}),\n        .count(count_wire)\n    );\n\n    magnitude_comparator comp (\n        .a(a),\n        .b(b),\n        .select(select),\n        .comparison_result(comparison_result_wire),\n        .input_selected(input_selected_wire)\n    );\n\n    assign count = count_wire;\n    assign comparison_result = comparison_result_wire;\n    assign input_selected = input_selected_wire;\nendmodule\n",
        "module_name": "up_down_counter",
        "module_hash": "b72a7cd3c01856b718a43f5612f2a322",
        "dataset_index": 18215
      },
      "binary_to_bcd_6584fb96": {
        "rtl_code": "module binary_to_bcd(\n    input [7:0] binary,\n    output [11:0] bcd\n);\n\nreg [3:0] digit1;\nreg [3:0] digit2;\nreg [3:0] digit3;\n\nalways @ (binary) begin\n    if (binary >= 100) begin\n        digit1 = binary / 100;\n        digit2 = (binary % 100) / 10;\n        digit3 = binary % 10;\n    end else if (binary >= 10) begin\n        digit1 = 0;\n        digit2 = binary / 10;\n        digit3 = binary % 10;\n    end else begin\n        digit1 = 0;\n        digit2 = 0;\n        digit3 = binary;\n    end\nend\n\nassign bcd = {digit1, digit2, digit3};\n\nendmodule",
        "module_name": "binary_to_bcd",
        "module_hash": "6584fb96be2c2bdcdf4481fba0c3d667",
        "dataset_index": 1591
      },
      "pcie_7x_v1_3_rxeq_scan_c0ebc8cc": {
        "rtl_code": "\n\n\n\nmodule pcie_7x_v1_3_rxeq_scan\n(\n\n    input               RXEQSCAN_CLK,\n    input               RXEQSCAN_RST_N,\n\n    input       [ 2:0]  RXEQSCAN_PRESET,\n    input               RXEQSCAN_PRESET_VALID,\n    input       [ 3:0]  RXEQSCAN_TXPRESET,\n    input       [17:0]  RXEQSCAN_TXCOEFF,\n    input               RXEQSCAN_NEW_TXCOEFF_REQ,\n    input       [ 5:0]  RXEQSCAN_FS,\n    input       [ 5:0]  RXEQSCAN_LF,\n\n\n    output              RXEQSCAN_PRESET_DONE,\n    output      [17:0]  RXEQSCAN_NEW_TXCOEFF,\n    output              RXEQSCAN_NEW_TXCOEFF_DONE,\n    output              RXEQSCAN_LFFS_SEL,\n    output              RXEQSCAN_ADAPT_DONE\n\n);\n\n    reg         [ 2:0]  preset_reg1;\n    reg                 preset_valid_reg1;\n    reg         [ 3:0]  txpreset_reg1;\n    reg         [17:0]  txcoeff_reg1;\n    reg                 new_txcoeff_req_reg1;\n    reg         [ 5:0]  fs_reg1;\n    reg         [ 5:0]  lf_reg1;\n\n    reg         [ 2:0]  preset_reg2;\n    reg                 preset_valid_reg2;\n    reg         [ 3:0]  txpreset_reg2;\n    reg         [17:0]  txcoeff_reg2;\n    reg                 new_txcoeff_req_reg2;\n    reg         [ 5:0]  fs_reg2;\n    reg         [ 5:0]  lf_reg2;\n\n    reg         [ 1:0]  lffs_sel_cnt   = 2'd0;\n    reg         [ 2:0]  adapt_done_cnt = 3'd0;\n\n    reg                 preset_done      =  1'd0;\n    reg         [17:0]  new_txcoeff      = 18'd0;\n    reg                 new_txcoeff_done =  1'd0;\n    reg                 lffs_sel         =  1'd0;\n    reg                 adapt_done       =  1'd0;\n    reg         [ 2:0]  fsm              =  3'd0;\n\n    localparam          FSM_IDLE            = 3'b001;\n    localparam          FSM_PRESET          = 3'b010;\n    localparam          FSM_NEW_TXCOEFF_REQ = 3'b100;\n\n\n\nalways @ (posedge RXEQSCAN_CLK)\nbegin\n\n    if (!RXEQSCAN_RST_N)\n        begin\n        preset_reg1          <=  3'd0;\n        preset_valid_reg1    <=  1'd0;\n        txpreset_reg1        <=  4'd0;\n        txcoeff_reg1         <= 18'd0;\n        new_txcoeff_req_reg1 <=  1'd0;\n        fs_reg1              <=  6'd0;\n        lf_reg1              <=  6'd0;\n        preset_reg2          <=  3'd0;\n        preset_valid_reg2    <=  1'd0;\n        txpreset_reg2        <=  4'd0;\n        txcoeff_reg2         <= 18'd0;\n        new_txcoeff_req_reg2 <=  1'd0;\n        fs_reg2              <=  6'd0;\n        lf_reg2              <=  6'd0;\n        end\n    else\n        begin\n        preset_reg1          <= RXEQSCAN_PRESET;\n        preset_valid_reg1    <= RXEQSCAN_PRESET_VALID;\n        txpreset_reg1        <= RXEQSCAN_TXPRESET;\n        txcoeff_reg1         <= RXEQSCAN_TXCOEFF;\n        new_txcoeff_req_reg1 <= RXEQSCAN_NEW_TXCOEFF_REQ;\n        fs_reg1              <= RXEQSCAN_FS;\n        lf_reg1              <= RXEQSCAN_LF;\n        preset_reg2          <= preset_reg1;\n        preset_valid_reg2    <= preset_valid_reg1;\n        txpreset_reg2        <= txpreset_reg1;\n        txcoeff_reg2         <= txcoeff_reg1;\n        new_txcoeff_req_reg2 <= new_txcoeff_req_reg1;\n        fs_reg2              <= fs_reg1;\n        lf_reg2              <= lf_reg1;\n        end\n\nend\n\n\n\nalways @ (posedge RXEQSCAN_CLK)\nbegin\n\n    if (!RXEQSCAN_RST_N)\n        begin\n        fsm              <=  FSM_IDLE;\n        preset_done      <=  1'd0;\n        new_txcoeff      <= 18'd0;\n        new_txcoeff_done <=  1'd0;\n        lffs_sel         <=  1'd0;\n        lffs_sel_cnt     <=  2'd0;\n        adapt_done       <=  1'd0;\n        adapt_done_cnt   <=  3'd0;\n        end\n    else\n\n        begin\n\n        case (fsm)\n\n        FSM_IDLE :\n\n            begin\n\n            if (preset_valid_reg2)\n                begin\n                fsm              <=  FSM_PRESET;\n                preset_done      <=  1'd1;\n                new_txcoeff      <=  new_txcoeff;\n                new_txcoeff_done <=  1'd0;\n                lffs_sel         <=  1'd0;\n                lffs_sel_cnt     <=  lffs_sel_cnt;\n                adapt_done       <=  1'd0;\n                adapt_done_cnt   <=  adapt_done_cnt;\n                end\n            else if (new_txcoeff_req_reg2)\n                begin\n                fsm              <=  FSM_NEW_TXCOEFF_REQ;\n                preset_done      <=  1'd0;\n                new_txcoeff      <=  txcoeff_reg2;\n                new_txcoeff_done <=  1'd1;\n                lffs_sel         <= (lffs_sel_cnt   == 2'd1);\n                lffs_sel_cnt     <= (lffs_sel_cnt   +  2'd1);\n                adapt_done       <= (adapt_done_cnt == 3'd1);\n                adapt_done_cnt   <= (adapt_done_cnt +  3'd1);\n                end\n            else\n                begin\n                fsm              <=  FSM_IDLE;\n                preset_done      <=  1'd0;\n                new_txcoeff      <=  new_txcoeff;\n                new_txcoeff_done <=  1'd0;\n                lffs_sel         <=  1'd0;\n                lffs_sel_cnt     <=  lffs_sel_cnt;\n                adapt_done       <=  1'd0;\n                adapt_done_cnt   <=  adapt_done_cnt;\n                end\n\n            end\n\n        FSM_PRESET :\n\n            begin\n            fsm              <= (!preset_valid_reg2) ? FSM_IDLE : FSM_PRESET;\n            preset_done      <=  1'd1;\n            new_txcoeff      <=  new_txcoeff;\n            new_txcoeff_done <=  1'd0;\n            lffs_sel         <=  1'd0;\n            lffs_sel_cnt     <=  lffs_sel_cnt;\n            adapt_done       <=  1'd0;\n            adapt_done_cnt   <=  adapt_done_cnt;\n            end\n\n        FSM_NEW_TXCOEFF_REQ :\n\n            begin\n            fsm              <= (!new_txcoeff_req_reg2) ? FSM_IDLE : FSM_NEW_TXCOEFF_REQ;\n            preset_done      <=  1'd0;\n            new_txcoeff      <=  new_txcoeff;\n            new_txcoeff_done <=  1'd1;\n            lffs_sel         <=  lffs_sel;\n            lffs_sel_cnt     <=  lffs_sel_cnt;\n            adapt_done       <=  adapt_done;\n            adapt_done_cnt   <=  adapt_done_cnt;\n            end\n\n        default :\n\n            begin\n            fsm              <=  FSM_IDLE;\n            preset_done      <=  1'd0;\n            new_txcoeff      <= 18'd0;\n            new_txcoeff_done <=  1'd0;\n            lffs_sel         <=  1'd0;\n            lffs_sel_cnt     <=  2'd0;\n            adapt_done       <=  1'd0;\n            adapt_done_cnt   <=  3'd0;\n            end\n\n        endcase\n\n        end\n\nend\n\n\n\nassign RXEQSCAN_PRESET_DONE      = preset_done;\nassign RXEQSCAN_NEW_TXCOEFF      = new_txcoeff;\nassign RXEQSCAN_NEW_TXCOEFF_DONE = new_txcoeff_done;\nassign RXEQSCAN_LFFS_SEL         = lffs_sel;\nassign RXEQSCAN_ADAPT_DONE       = adapt_done;\n\n\n\nendmodule\n",
        "module_name": "pcie_7x_v1_3_rxeq_scan",
        "module_hash": "c0ebc8cc4ecf0d06f9d14dae92755d2a",
        "dataset_index": 24884
      },
      "logic__9164431a": {
        "rtl_code": "module logic_module (\n    input A1,\n    input A2,\n    input B1,\n    input C1,\n    output reg X\n);\n\n    // Local signals\n    wire or0_out;\n    wire and0_out_X;\n\n    // Instantiation of gates\n    or or0 (or0_out, A2, A1);\n    and and0 (and0_out_X, or0_out, B1, C1);\n\n    always @* begin\n        X = and0_out_X;\n    end\n\nendmodule",
        "module_name": "logic_",
        "module_hash": "9164431a4d7e0e5a88ab862378d3d2bf",
        "dataset_index": 5878
      },
      "double_divider_f100e5d6": {
        "rtl_code": "module double_divider(\n        input_a,\n        input_b,\n        input_a_stb,\n        input_b_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack,\n        input_b_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [63:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  input     [63:0] input_b;\n  input     input_b_stb;\n  output    input_b_ack;\n\n  output    [63:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [63:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [3:0] state;\n  parameter get_a         = 4'd0,\n            get_b         = 4'd1,\n            unpack        = 4'd2,\n            special_cases = 4'd3,\n            normalise_a   = 4'd4,\n            normalise_b   = 4'd5,\n            divide_0      = 4'd6,\n            divide_1      = 4'd7,\n            divide_2      = 4'd8,\n            divide_3      = 4'd9,\n            normalise_1   = 4'd10,\n            normalise_2   = 4'd11,\n            round         = 4'd12,\n            pack          = 4'd13,\n            put_z         = 4'd14;\n\n  reg       [63:0] a, b, z;\n  reg       [52:0] a_m, b_m, z_m;\n  reg       [12:0] a_e, b_e, z_e;\n  reg       a_s, b_s, z_s;\n  reg       guard, round_bit, sticky;\n  reg       [108:0] quotient, divisor, dividend, remainder;\n  reg       [6:0] count;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= get_b;\n        end\n      end\n\n      get_b:\n      begin\n        s_input_b_ack <= 1;\n        if (s_input_b_ack && input_b_stb) begin\n          b <= input_b;\n          s_input_b_ack <= 0;\n          state <= unpack;\n        end\n      end\n\n      unpack:\n      begin\n        a_m <= a[51 : 0];\n        b_m <= b[51 : 0];\n        a_e <= a[62 : 52] - 1023;\n        b_e <= b[62 : 52] - 1023;\n        a_s <= a[63];\n        b_s <= b[63];\n        state <= special_cases;\n      end\n\n      special_cases:\n      begin\n        if ((a_e == 1024 && a_m != 0) || (b_e == 1024 && b_m != 0)) begin\n          z[63] <= 1;\n          z[62:52] <= 2047;\n          z[51] <= 1;\n          z[50:0] <= 0;\n          state <= put_z;\n          end else if ((a_e == 1024) && (b_e == 1024)) begin\n          z[63] <= 1;\n          z[62:52] <= 2047;\n          z[51] <= 1;\n          z[50:0] <= 0;\n          state <= put_z;\n        end else if (a_e == 1024) begin\n          z[63] <= a_s ^ b_s;\n          z[62:52] <= 2047;\n          z[51:0] <= 0;\n          state <= put_z;\n           if ($signed(b_e == -1023) && (b_m == 0)) begin\n            z[63] <= 1;\n            z[62:52] <= 2047;\n            z[51] <= 1;\n            z[50:0] <= 0;\n            state <= put_z;\n          end\n        end else if (b_e == 1024) begin\n          z[63] <= a_s ^ b_s;\n          z[62:52] <= 0;\n          z[51:0] <= 0;\n          state <= put_z;\n        end else if (($signed(a_e) == -1023) && (a_m == 0)) begin\n          z[63] <= a_s ^ b_s;\n          z[62:52] <= 0;\n          z[51:0] <= 0;\n          state <= put_z;\n           if (($signed(b_e) == -1023) && (b_m == 0)) begin\n            z[63] <= 1;\n            z[62:52] <= 2047;\n            z[51] <= 1;\n            z[50:0] <= 0;\n            state <= put_z;\n          end\n        end else if (($signed(b_e) == -1023) && (b_m == 0)) begin\n          z[63] <= a_s ^ b_s;\n          z[62:52] <= 2047;\n          z[51:0] <= 0;\n          state <= put_z;\n        end else begin\n          if ($signed(a_e) == -1023) begin\n            a_e <= -1022;\n          end else begin\n            a_m[52] <= 1;\n          end\n          if ($signed(b_e) == -1023) begin\n            b_e <= -1022;\n          end else begin\n            b_m[52] <= 1;\n          end\n          state <= normalise_a;\n        end\n      end\n\n      normalise_a:\n      begin\n        if (a_m[52]) begin\n          state <= normalise_b;\n        end else begin\n          a_m <= a_m << 1;\n          a_e <= a_e - 1;\n        end\n      end\n\n      normalise_b:\n      begin\n        if (b_m[52]) begin\n          state <= divide_0;\n        end else begin\n          b_m <= b_m << 1;\n          b_e <= b_e - 1;\n        end\n      end\n\n      divide_0:\n      begin\n        z_s <= a_s ^ b_s;\n        z_e <= a_e - b_e;\n        quotient <= 0;\n        remainder <= 0;\n        count <= 0;\n        dividend <= a_m << 56;\n        divisor <= b_m;\n        state <= divide_1;\n      end\n\n      divide_1:\n      begin\n        quotient <= quotient << 1;\n        remainder <= remainder << 1;\n        remainder[0] <= dividend[108];\n        dividend <= dividend << 1;\n        state <= divide_2;\n      end\n\n      divide_2:\n      begin\n        if (remainder >= divisor) begin\n          quotient[0] <= 1;\n          remainder <= remainder - divisor;\n        end\n        if (count == 107) begin\n          state <= divide_3;\n        end else begin\n          count <= count + 1;\n          state <= divide_1;\n        end\n      end\n\n      divide_3:\n      begin\n        z_m <= quotient[55:3];\n        guard <= quotient[2];\n        round_bit <= quotient[1];\n        sticky <= quotient[0] | (remainder != 0);\n        state <= normalise_1;\n      end\n\n      normalise_1:\n      begin\n        if (z_m[52] == 0 && $signed(z_e) > -1022) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= guard;\n          guard <= round_bit;\n          round_bit <= 0;\n        end else begin\n          state <= normalise_2;\n        end\n      end\n\n      normalise_2:\n      begin\n        if ($signed(z_e) < -1022) begin\n          z_e <= z_e + 1;\n          z_m <= z_m >> 1;\n          guard <= z_m[0];\n          round_bit <= guard;\n          sticky <= sticky | round_bit;\n        end else begin\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit | sticky | z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 53'hffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[51 : 0] <= z_m[51:0];\n        z[62 : 52] <= z_e[10:0] + 1023;\n        z[63] <= z_s;\n        if ($signed(z_e) == -1022 && z_m[52] == 0) begin\n          z[62 : 52] <= 0;\n        end\n        if ($signed(z_e) > 1023) begin\n          z[51 : 0] <= 0;\n          z[62 : 52] <= 2047;\n          z[63] <= z_s;\n        end\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_input_b_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign input_b_ack = s_input_b_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n",
        "module_name": "double_divider",
        "module_hash": "f100e5d69e3a05c052edb0fcfeecbb66",
        "dataset_index": 20469
      },
      "vga_controller_ddc374d4": {
        "rtl_code": "\nmodule vga_controller \n  (\n    input wire pclk,reset,\n    output wire hsync,vsync,valid,\n    output wire [9:0]h_cnt,\n    output wire [9:0]v_cnt\n    );\n    \n    reg [9:0]pixel_cnt;\n    reg [9:0]line_cnt;\n    reg hsync_i,vsync_i;\n    wire hsync_default, vsync_default;\n    wire [9:0] HD, HF, HS, HB, HT, VD, VF, VS, VB, VT;\n\n   \n    assign HD = 640;\n    assign HF = 16;\n    assign HS = 96;\n    assign HB = 48;\n    assign HT = 800; \n    assign VD = 480;\n    assign VF = 10;\n    assign VS = 2;\n    assign VB = 33;\n    assign VT = 525;\n    assign hsync_default = 1'b1;\n    assign vsync_default = 1'b1;\n     \n    always@(posedge pclk)\n        if(reset)\n            pixel_cnt <= 0;\n        else if(pixel_cnt < (HT - 1))\n                pixel_cnt <= pixel_cnt + 1;\n             else\n                pixel_cnt <= 0;\n\n    always@(posedge pclk)\n        if(reset)\n            hsync_i <= hsync_default;\n        else if((pixel_cnt >= (HD + HF - 1))&&(pixel_cnt < (HD + HF + HS - 1)))\n                hsync_i <= ~hsync_default;\n            else\n                hsync_i <= hsync_default; \n    \n    always@(posedge pclk)\n        if(reset)\n            line_cnt <= 0;\n        else if(pixel_cnt == (HT -1))\n                if(line_cnt < (VT - 1))\n                    line_cnt <= line_cnt + 1;\n                else\n                    line_cnt <= 0;\n                    \n    always@(posedge pclk)\n        if(reset)\n            vsync_i <= vsync_default; \n        else if((line_cnt >= (VD + VF - 1))&&(line_cnt < (VD + VF + VS - 1)))\n            vsync_i <= ~vsync_default; \n        else\n            vsync_i <= vsync_default; \n                    \n    assign hsync = hsync_i;\n    assign vsync = vsync_i;\n    assign valid = ((pixel_cnt < HD) && (line_cnt < VD));\n    \n    assign h_cnt = (pixel_cnt < HD) ? pixel_cnt:10'd0;\n    assign v_cnt = (line_cnt < VD) ? line_cnt:10'd0;\n           \nendmodule\n",
        "module_name": "vga_controller",
        "module_hash": "ddc374d43454714a0fbccb0dc5be29e8",
        "dataset_index": 15040
      },
      "PCIeGen2x8If128_gtp_pipe_drp #_7fe06874": {
        "rtl_code": "\n\n\n\n\nmodule PCIeGen2x8If128_gtp_pipe_drp #\n(\n\n    parameter LOAD_CNT_MAX     = 2'd1,                      parameter INDEX_MAX        = 1'd0                       )\n\n(\n    \n    input               DRP_CLK,\n    input               DRP_RST_N,\n    input               DRP_X16,\n    input               DRP_START,\n    input       [15:0]  DRP_DO,\n    input               DRP_RDY,\n    \n    output      [ 8:0]  DRP_ADDR,\n    output              DRP_EN,  \n    output      [15:0]  DRP_DI,   \n    output              DRP_WE,\n    output              DRP_DONE,\n    output      [ 2:0]  DRP_FSM\n    \n);\n\n        reg                 x16_reg1;\n    reg                 start_reg1;\n    reg         [15:0]  do_reg1;\n    reg                 rdy_reg1;\n    \n    reg                 x16_reg2;\n    reg                 start_reg2;\n    reg         [15:0]  do_reg2;\n    reg                 rdy_reg2;\n    \n    reg         [ 1:0]  load_cnt =  2'd0;\n    reg         [ 4:0]  index    =  5'd0;\n    reg         [ 8:0]  addr_reg =  9'd0;\n    reg         [15:0]  di_reg   = 16'd0;\n    \n    reg                 done     =  1'd0;\n    reg         [ 2:0]  fsm      =  0;      \n                        \n    localparam          ADDR_RX_DATAWIDTH  = 9'h011;              \n    \n    localparam          MASK_RX_DATAWIDTH  = 16'b1111011111111111;  localparam          X16_RX_DATAWIDTH   = 16'b0000000000000000;  localparam          X20_RX_DATAWIDTH   = 16'b0000100000000000;  wire        [15:0]  data_rx_datawidth;                 \n           \n    localparam          FSM_IDLE  = 0;  \n    localparam          FSM_LOAD  = 1;                           \n    localparam          FSM_READ  = 2;\n    localparam          FSM_RRDY  = 3;\n    localparam          FSM_WRITE = 4;\n    localparam          FSM_WRDY  = 5;    \n    localparam          FSM_DONE  = 6;   \n\n    \n    \nalways @ (posedge DRP_CLK)\nbegin\n\n    if (!DRP_RST_N)\n        begin\n        x16_reg1   <=  1'd0;\n        do_reg1    <= 16'd0;\n        rdy_reg1   <=  1'd0;\n        start_reg1 <=  1'd0;\n        x16_reg2   <=  1'd0;\n        do_reg2    <= 16'd0;\n        rdy_reg2   <=  1'd0;\n        start_reg2 <=  1'd0;\n        end\n        \n    else\n        begin\n        x16_reg1   <= DRP_X16;\n        do_reg1    <= DRP_DO;\n        rdy_reg1   <= DRP_RDY;\n        start_reg1 <= DRP_START;\n        x16_reg2   <= x16_reg1;\n        do_reg2    <= do_reg1;\n        rdy_reg2   <= rdy_reg1;\n        start_reg2 <= start_reg1;\n        end\n    \nend  \n\n\n\nassign data_rx_datawidth = x16_reg2 ? X16_RX_DATAWIDTH : X20_RX_DATAWIDTH;\n\n\n\nalways @ (posedge DRP_CLK)\nbegin\n\n    if (!DRP_RST_N)\n        load_cnt <= 2'd0;\n    else\n    \n        if ((fsm == FSM_LOAD) && (load_cnt < LOAD_CNT_MAX))\n            load_cnt <= load_cnt + 2'd1;\n            \n        else if ((fsm == FSM_LOAD) && (load_cnt == LOAD_CNT_MAX))\n            load_cnt <= load_cnt;\n            \n        else\n            load_cnt <= 2'd0;\n        \nend \n\n\n\nalways @ (posedge DRP_CLK)\nbegin\n\n    if (!DRP_RST_N)\n        begin\n        addr_reg <=  9'd0;\n        di_reg   <= 16'd0;\n        end\n    else\n        begin\n        \n        case (index)\n        \n        1'd0 :\n            begin        \n            addr_reg <= ADDR_RX_DATAWIDTH;\n            di_reg   <= (do_reg2 & MASK_RX_DATAWIDTH) | data_rx_datawidth;\n            end              \n            \n        default : \n            begin\n            addr_reg <=  9'd0;\n            di_reg   <= 16'd0;\n            end\n            \n        endcase\n        \n        end\n        \nend  \n\n\n\nalways @ (posedge DRP_CLK)\nbegin\n\n    if (!DRP_RST_N)\n        begin\n        fsm   <= FSM_IDLE;\n        index <= 5'd0;\n        done  <= 1'd1; end\n    else\n        begin\n        \n        case (fsm)\n\n        FSM_IDLE :  \n          \n            begin\n            if (start_reg2)\n                begin\n                fsm   <= FSM_LOAD;\n                index <= 5'd0;\n                done  <= 1'd0; \n                end\n            else       \n                begin\n                fsm   <= FSM_IDLE;\n                index <= 5'd0;\n                done  <= 1'd1;\n                end \n            end    \n            \n        FSM_LOAD :\n        \n            begin\n            fsm   <= (load_cnt == LOAD_CNT_MAX) ? FSM_READ : FSM_LOAD;\n            index <= index;\n\n            done  <= 1'd0;\n            end  \n            \n        FSM_READ :\n        \n            begin\n            fsm   <= FSM_RRDY;\n            index <= index;\n            done  <= 1'd0;\n            end\n            \n        FSM_RRDY :    \n        \n            begin\n            fsm   <= rdy_reg2 ? FSM_WRITE : FSM_RRDY;\n            index <= index;\n            done  <= 1'd0;\n            end\n  \n            \n        FSM_WRITE :    \n        \n            begin\n            fsm   <= FSM_WRDY;\n            index <= index;\n            done  <= 1'd0;\n            end       \n            \n        FSM_WRDY :    \n        \n            begin\n            fsm   <= rdy_reg2 ? FSM_DONE : FSM_WRDY;\n            index <= index;\n            done  <= 1'd0;\n            end        \n             \n        FSM_DONE :\n        \n            begin\n            if (index == INDEX_MAX)\n                begin\n                fsm   <= FSM_IDLE;\n                index <= 5'd0;\n                done  <= 1'd1;\tend\n            else       \n                begin\n                fsm   <= FSM_LOAD;\n                index <= index + 5'd1;\n                done  <= 1'd0;\n                end\n            end     \n              \n        default :\n        \n            begin      \n            fsm   <= FSM_IDLE;\n            index <= 5'd0;\n            done  <= 1'd1; end\n            \n        endcase\n        \n        end\n        \nend \n\n\n\nassign DRP_ADDR = addr_reg;\nassign DRP_EN   = (fsm == FSM_READ) || (fsm == FSM_WRITE);\nassign DRP_DI   = di_reg;\nassign DRP_WE   = (fsm == FSM_WRITE);\nassign DRP_DONE = done;\nassign DRP_FSM  = fsm;\n\n\n\nendmodule\n",
        "module_name": "PCIeGen2x8If128_gtp_pipe_drp #",
        "module_hash": "7fe068747cd1af90b668a40f00f2d02c",
        "dataset_index": 25617
      },
      "top__f6542f2c": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [31:0] A,\n    input [31:0] B,\n    output [7:0] result\n);\n\n    // Reverse byte ordering circuit\n    wire [31:0] A_reversed;\n    wire [31:0] B_reversed;\n    assign A_reversed = {A[7:0], A[15:8], A[23:16], A[31:24]};\n    assign B_reversed = {B[7:0], B[15:8], B[23:16], B[31:24]};\n    \n    // Carry-select adder (CSA)\n    wire [31:0] sum;\n    wire carry_out;\n    wire [31:0] A_xor_B;\n    wire [31:0] A_and_B;\n    wire [31:0] A_and_B_shifted;\n    wire [31:0] A_xor_B_shifted;\n    wire [31:0] A_xor_B_shifted_and_carry_out;\n    \n    assign A_xor_B = A ^ B;\n    assign A_and_B = A & B;\n    assign A_and_B_shifted = A_and_B << 1;\n    assign A_xor_B_shifted = A_xor_B << 1;\n    \n    ripple_carry_adder rca1(\n        .clk(clk),\n        .reset(reset),\n        .A(A_xor_B),\n        .B(A_and_B_shifted),\n        .sum(A_xor_B_shifted_and_carry_out),\n        .carry_out()\n    );\n    \n    ripple_carry_adder rca2(\n        .clk(clk),\n        .reset(reset),\n        .A(A_xor_B_shifted),\n        .B(A_and_B_shifted),\n        .sum(sum),\n        .carry_out()\n    );\n    \n    assign carry_out = A_xor_B_shifted_and_carry_out[31];\n    \n    // 8-bit multiplier\n    wire [15:0] product;\n    wire [7:0] result_shifted;\n    \n    assign product = sum[7:0] * A_reversed[7:0];\n    assign result_shifted = {product[15:8], product[7:0]} << 1;\n    assign result = result_shifted[7:0] ^ B_reversed[7:0];\n    \nendmodule\n\nmodule ripple_carry_adder (\n    input clk,\n    input reset,\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sum,\n    output carry_out\n);\n    \n    wire [31:0] carry;\n    \n    assign carry[0] = 1'b0;\n    generate\n        genvar i;\n        for (i = 0; i < 31; i = i + 1) begin : gen\n            assign carry[i+1] = (A[i] & B[i]) | (A[i] & carry[i]) | (B[i] & carry[i]);\n        end\n    endgenerate\n    \n    assign sum = A + B + carry;\n    assign carry_out = carry[31];\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "f6542f2c9da372a168929ad95bc14814",
        "dataset_index": 14691
      },
      "barrel_shifter_df46d470": {
        "rtl_code": "\nmodule barrel_shifter (\n  input [bus_size-1:0] input_bus,\n  input [shift_amount_size-1:0] shift_amount,\n  input shift_direction,\n  output [bus_size-1:0] output_bus\n);\n\nparameter bus_size = 8; // size of input and output bus\nparameter shift_amount_size = 3; // number of bits needed to represent shift_amount\nparameter width = bus_size - shift_amount_size; // width of the shift register\n\n// Declare temporary register to store shifted bus\nreg [bus_size-1:0] shifted_bus; \n\n// RTL code for barrel shifter\nalways @(*) begin\n  if (shift_direction) begin // left shift\n    shifted_bus = input_bus << shift_amount;\n  end else begin // right shift\n    shifted_bus = input_bus >> shift_amount;\n  end\nend\n\n// Assign output bus to the shifted bus\nassign output_bus = shifted_bus;\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "df46d4706861ad3cad75e8c2f67641ea",
        "dataset_index": 14941
      },
      "sky130_fd_sc_hdll__a21boi_fdb87573": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__a21boi (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire b         ;\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    not not0 (b         , B1_N           );\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, b, and0_out    );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__a21boi",
        "module_hash": "fdb8757352ac31e49439384fda76f08f",
        "dataset_index": 22424
      },
      "counter__b822168a": {
        "rtl_code": "module counter_module (\n    input clk, // Clock input\n    input reset, // Reset signal input\n    output reg [3:0] counter // 4-bit counter output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\nmodule final_output_module (\n    input [3:0] counter, // 4-bit counter output\n    input select, // Select input to choose between counter value and its complement\n    output reg final_output // Final output based on select input\n);\n\n    always @(*) begin\n        if (select) begin\n            final_output <= ~counter;\n        end else begin\n            final_output <= counter;\n        end\n    end\n\nendmodule\n\nmodule top_module (\n    input clk, // Clock input\n    input reset, // Reset signal input\n    input select, // Select input to choose between counter value and its complement\n    output reg [3:0] counter, // 4-bit counter output\n    output reg final_output // Final output based on select input\n);\n\n    counter_module counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .counter(counter)\n    );\n\n    final_output_module final_output_inst (\n        .counter(counter),\n        .select(select),\n        .final_output(final_output)\n    );\n\nendmodule",
        "module_name": "counter_",
        "module_hash": "b822168ae8b6bd49a80c7e3dc44cedcc",
        "dataset_index": 1274
      },
      "four_input__04fb5a22": {
        "rtl_code": "module four_input_module (\n    input A1,\n    input A2,\n    input B1,\n    input C1,\n    output reg X\n);\n\n    always @(*) begin\n        if (A1 && A2) begin\n            X <= 1;\n        end else if (!A1 && B1) begin\n            X <= 0;\n        end else if (!A1 && !B1 && C1) begin\n            X <= 1;\n        end else begin\n            X <= 0;\n        end\n    end\n\nendmodule",
        "module_name": "four_input_",
        "module_hash": "04fb5a22b9604f0c805b64a9a163d075",
        "dataset_index": 15637
      },
      "top__ca1e4c09": {
        "rtl_code": "module top_module (\n    input clk,\n    input rst_n,\n    input [3:0] in,\n    output reg [1:0] pos,\n    input write_en,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    output reg [3:0] read_data,\n    output reg [5:0] final_output\n);\n\n// Binary to Gray code converter\nwire [1:0] gray_code;\nassign gray_code = (pos >> 1) ^ pos;\n\n// 4-bit priority encoder\nreg [1:0] priority_encoder;\nalways @(in) begin\n    if (in[3]) priority_encoder = 2'b11;\n    else if (in[2]) priority_encoder = 2'b10;\n    else if (in[1]) priority_encoder = 2'b01;\n    else if (in[0]) priority_encoder = 2'b00;\n    else priority_encoder = 2'b00;\nend\n\n// True dual-port RAM\nreg [3:0] ram [0:7];\ninteger i;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for (i = 0; i < 8; i = i + 1) begin\n            ram[i] <= 4'b0000;\n        end\n    end else begin\n        if (write_en) begin\n            ram[write_addr] <= write_data;\n        end\n        if (read_en) begin\n            read_data <= ram[read_addr];\n        end\n    end\nend\n\n// Additional functional module\nalways @(posedge clk) begin\n    pos <= priority_encoder;\n    final_output <= {gray_code, read_data};\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "ca1e4c09626cbaebd48a81186bda34de",
        "dataset_index": 12122
      },
      "calculator_e4fb2f8f": {
        "rtl_code": "module calculator(input wire [3:0] a, input wire [3:0] b, input wire [1:0] op, output reg [3:0] result);\n\nalways @ (a, b, op)\nbegin\n    case(op)\n        2'b00: result <= a + b; // Addition\n        2'b01: result <= a - b; // Subtraction\n        default: result <= 4'b0000; // Default to 0\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "e4fb2f8f8ea43d27a551153f86b9b704",
        "dataset_index": 7814
      },
      "bitwise_and_func_6bdd6633": {
        "rtl_code": "\nmodule bitwise_and_func (\n    input wire [7:0] vec1,\n    input wire [7:0] vec2,\n    input wire select,\n    output wire [7:0] and_out,\n    output wire [15:0] sum_out\n);\n\n    // Bitwise AND module\n    assign and_out = (select) ? 8'b0 : vec1 & vec2;\n\n    // Functional module\n    assign sum_out = vec1 + vec2;\n\nendmodule\nmodule top_module ( \n    input wire [7:0] vec1,\n    input wire [7:0] vec2,\n    output wire [7:0] outv,\n    output wire [15:0] sum\n);\n\n    bitwise_and_func baf (\n        .vec1(vec1),\n        .vec2(vec2),\n        .select(1'b0),\n        .and_out(outv),\n        .sum_out(sum)\n    );\n\nendmodule",
        "module_name": "bitwise_and_func",
        "module_hash": "6bdd6633dc3fcf1074611b569557964e",
        "dataset_index": 15484
      },
      "counter_4bit_async_a382b861": {
        "rtl_code": "module counter_4bit_async (\n  input clk,\n  input rst,\n  input en,\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      out <= 4'b0;\n    end else if (en) begin\n      out <= out + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter_4bit_async",
        "module_hash": "a382b8619227e6a8a6fbb5c92a68e64b",
        "dataset_index": 10091
      },
      "magnitude_comparator_52681b0c": {
        "rtl_code": "\nmodule magnitude_comparator (\n    input [3:0] in_1,\n    input [3:0] in_0,\n    output greater_than_or_equal\n);\n\n    assign greater_than_or_equal = (in_1 == in_0) ? 1'b1 :\n                                   (in_1[3] != in_0[3]) ? (in_1[3] == 1'b0) :\n                                   (in_1 > in_0);\n\nendmodule\n",
        "module_name": "magnitude_comparator",
        "module_hash": "52681b0c74f0cfed0bdfe5b555ad440e",
        "dataset_index": 5391
      },
      "four_bit_adder_2ed2755c": {
        "rtl_code": "module four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] C,\n  output overflow\n);\n\n  wire [3:0] sum;\n  wire [3:0] carry;\n  \n  full_adder adder0 (A[0], B[0], 1'b0, sum[0], carry[0]);\n  full_adder adder1 (A[1], B[1], carry[0], sum[1], carry[1]);\n  full_adder adder2 (A[2], B[2], carry[1], sum[2], carry[2]);\n  full_adder adder3 (A[3], B[3], carry[2], sum[3], overflow);\n  \n  assign C = sum;\n  \nendmodule\n\nmodule full_adder (\n  input A,\n  input B,\n  input Cin,\n  output S,\n  output Cout\n);\n\n  wire s1;\n  wire c1;\n  wire c2;\n  \n  xor (s1, A, B);\n  xor (S, s1, Cin);\n  and (c1, s1, Cin);\n  and (c2, A, B);\n  or (Cout, c1, c2);\n  \nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "2ed2755c0ee4e9f0ceaf4d7f4e180f47",
        "dataset_index": 14083
      },
      "unknown_module_0fb2aa96": {
        "rtl_code": "\n\n\n\n\nmodule\n    sameRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (\n        input [(expWidth + sigWidth):0] a,\n        input [(expWidth + sigWidth):0] b,\n        output out\n    );\n\n    wire [3:0] top4A = a[(expWidth + sigWidth):(expWidth + sigWidth - 3)];\n    wire [3:0] top4B = b[(expWidth + sigWidth):(expWidth + sigWidth - 3)];\n    assign out =\n        (top4A[2:0] == 'b000) || (top4A[2:0] == 'b111)\n            ? (top4A == top4B) && (a[(sigWidth - 2):0] == b[(sigWidth - 2):0])\n            : (top4A[2:0] == 'b110) ? (top4A == top4B) : (a == b);\n\nendmodule\n\n",
        "module_name": "unknown_module",
        "module_hash": "0fb2aa9698660c3974e46365595ee27a",
        "dataset_index": 23936
      },
      "mem_test_bac0fe70": {
        "rtl_code": "\nmodule mem_test (\n  input clk,\n  input rst,\n  input [7:0] addr,\n  input [7:0] din,\n  input mem_en,\n  output [7:0] dout,\n  output error\n);\n\n  // Define RAM module\n  reg [7:0] mem [0:255];\n\n  // Define internal signals\n  reg [7:0] read_data;\n  reg write_en;\n  reg read_en;\n  reg [7:0] error_addr;\n  wire [7:0] mem_addr;\n\n  // Assign memory address\n  assign mem_addr = addr;\n\n  // Write operation\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      write_en <= 0;\n      error_addr <= 0;\n    end else begin\n      if (mem_en) begin\n        write_en <= 1;\n        mem[addr] <= din;\n      end else begin\n        write_en <= 0;\n      end\n    end\n  end\n\n  // Read operation\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      read_en <= 0;\n      read_data <= 0;\n    end else begin\n      if (mem_en) begin\n        read_en <= 1;\n        read_data <= mem[addr];\n      end else begin\n        read_en <= 0;\n      end\n    end\n  end\n\n  // Error detection\n  wire error_wire;\n  assign error_wire = (write_en && read_en && (din != read_data));\n  reg error_reg;\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      error_reg <= 0;\n    end else begin\n      if (mem_en) begin\n        if (error_wire) begin\n          error_reg <= 1;\n          error_addr <= addr;\n        end else begin\n          error_reg <= 0;\n        end\n      end else begin\n        error_reg <= 0;\n      end\n    end\n  end\n\n  // Assign outputs\n  assign dout = read_data;\n  assign error = error_reg;\n\nendmodule\n",
        "module_name": "mem_test",
        "module_hash": "bac0fe7005059cbaafab792ae4fced3f",
        "dataset_index": 14184
      },
      "counter_3bit_b3636a1e": {
        "rtl_code": "module counter_3bit (\n  input clk,\n  input reset,\n  output reg [2:0] out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      out <= 3'b0;\n    end else begin\n      out <= out + 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "counter_3bit",
        "module_hash": "b3636a1ea34743a4cf2140e46687a7ad",
        "dataset_index": 17938
      },
      "counter_8c5b7edf": {
        "rtl_code": "module counter(\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "8c5b7edf9027a17a861f9aac4e7e3514",
        "dataset_index": 13842
      },
      "booth_multiplier_47caf01d": {
        "rtl_code": "\nmodule booth_multiplier (\n  input clk,\n  input reset,\n  input [3:0] A,\n  input [3:0] B,\n  output reg [7:0] P\n);\n\n  reg [4:0] m;\n  reg [4:0] ac;\n  reg [2:0] state;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      m <= 5'b0;\n      ac <= 5'b0;\n      state <= 3'b000;\n      P <= 8'b0;\n    end\n    else begin\n      case (state)\n        3'b000: begin // State 0\n          if (B[0]) begin\n            ac <= {4'b0, A};\n            P <= {4'b0, A};\n          end\n          else begin\n            P <= 8'b0;\n          end\n          m <= {B[3:1], 2'b01};\n          state <= 3'b001;\n        end\n        3'b001: begin // State 1\n          if (m[0] && !m[1]) begin\n            ac <= ac + {4'b0, A};\n          end\n          else if (!m[0] && m[1]) begin\n            ac <= ac - {4'b0, A};\n          end\n          m <= {m[3:1], m[0]};\n          state <= 3'b010;\n        end\n        3'b010: begin // State 2\n          if (m[0] && !m[1]) begin\n            ac <= ac + {4'b0, A};\n          end\n          else if (!m[0] && m[1]) begin\n            ac <= ac - {4'b0, A};\n          end\n          m <= {m[3:1], m[0]};\n          state <= 3'b011;\n        end\n        3'b011: begin // State 3\n          P <= {ac[4:0], P[3:0]}; // Fix the range issue\n          m <= {m[3:1], m[0]};\n          if (m == 5'b00001 || m == 5'b11111) begin\n            state <= 3'b100;\n          end\n          else begin\n            state <= 3'b001;\n          end\n        end\n        3'b100: begin // State 4\n          P <= {ac[4:0], P[3:0]}; // Fix the range issue\n          state <= 3'b101;\n        end\n        3'b101: begin // State 5\n          state <= 3'b000;\n        end\n      endcase\n    end\n  end\n  \nendmodule",
        "module_name": "booth_multiplier",
        "module_hash": "47caf01d2c156969beebdba9229fc772",
        "dataset_index": 13073
      },
      "clock_reset_gen_6b7e3a0b": {
        "rtl_code": "module clock_reset_gen (\n  input clk_in,\n  input rst_in,\n  output reg clk_out,\n  output reg rst_out\n);\n\n  reg [31:0] counter = 0;\n\n  always @(posedge clk_in) begin\n    counter <= counter + 1;\n    if (counter == 1) begin\n      clk_out <= 1;\n    end else if (counter == 2) begin\n      clk_out <= 0;\n      counter <= 0;\n    end\n  end\n\n  always @(posedge clk_out) begin\n    if (rst_in) begin\n      rst_out <= 1;\n    end else begin\n      rst_out <= 0;\n    end\n  end\n\nendmodule",
        "module_name": "clock_reset_gen",
        "module_hash": "6b7e3a0bffa688fe521c00cce983562e",
        "dataset_index": 20311
      },
      "shift_register_edfe6362": {
        "rtl_code": "module shift_register(\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    reg [3:0] counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            counter <= 4'b0;\n            q <= 4'b0;\n        end\n        else begin\n            if (load) begin\n                counter <= 4'b0;\n                q <= data;\n            end\n            else if (ena) begin\n                counter <= counter + 1;\n                q <= {q[2:0], q[3]};\n            end\n        end\n    end\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    wire [3:0] shift_reg_out;\n\n    shift_register shift_reg(\n        .clk(clk),\n        .areset(areset),\n        .load(load),\n        .ena(ena),\n        .data(data),\n        .q(shift_reg_out)\n    );\n\n    always @(*) begin\n        if (load) begin\n            q <= data;\n        end\n        else if (ena) begin\n            q <= shift_reg_out;\n        end\n    end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "edfe636280183b0f275e1e706fbda2fd",
        "dataset_index": 594
      },
      "three_input_three_output_84e3d733": {
        "rtl_code": "\nmodule three_input_three_output(i_0r, i_0a, o_0r, o_0a, o_1r, o_1a, reset);\n  input i_0r;\n  output i_0a;\n  output o_0r;\n  input o_0a;\n  output o_1r;\n  input o_1a;\n  input reset;\n\n  reg i_0a_reg;\n  reg o_0r_reg;\n  reg o_1r_reg;\n\n  assign i_0a = i_0a_reg;\n  assign o_0r = o_0r_reg;\n  assign o_1r = o_1r_reg;\n\n  always @(posedge i_0r or posedge reset) begin\n    if (reset) begin\n      i_0a_reg <= 0;\n      o_0r_reg <= 0;\n      o_1r_reg <= 0;\n    end else begin\n      i_0a_reg <= o_0a && o_1a;\n      o_0r_reg <= i_0r;\n      o_1r_reg <= i_0r;\n    end\n  end\nendmodule\n",
        "module_name": "three_input_three_output",
        "module_hash": "84e3d73386ed0c3112f1fcb93123b47c",
        "dataset_index": 14829
      },
      "shift_addsub_580b9803": {
        "rtl_code": "\nmodule shift_addsub (\n    input clk,\n    input reset,\n    input SER,\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] result\n);\n\n    reg [3:0] Q;\n    wire [3:0] shifted_Q;\n    wire [3:0] added_A;\n    wire [3:0] subbed_A;\n\n    shift_register shift_reg (\n        .clk(clk),\n        .reset(reset),\n        .SER(SER),\n        .SHIFT(shifted_Q),\n        .LOAD(Q)\n    );\n\n    adder_subtractor addsub (\n        .A(A),\n        .B(shifted_Q),\n        .sub(sub),\n        .result(added_A),\n        .sub_result(subbed_A)\n    );\n\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset)\n            Q <= 4'b0;\n        else\n            Q <= subbed_A;\n    end\n\n    assign result = (sub) ? subbed_A : added_A;\n\nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input SER,\n    output reg [3:0] SHIFT,\n    input [3:0] LOAD\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            SHIFT <= 4'b0;\n        end else begin\n            SHIFT <= LOAD;\n        end\n    end\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] result,\n    output [3:0] sub_result\n);\n\n    wire [3:0] subbed_A;\n    wire [3:0] subtracted_result;\n\n    assign subbed_A = (~A) + 1;\n    assign subtracted_result = subbed_A + B;\n\n    assign sub_result = subtracted_result[3:0];\n    assign result = sub ? subtracted_result[3:0] : A + B;\nendmodule",
        "module_name": "shift_addsub",
        "module_hash": "580b9803460d2322d062e9fa49fc04a4",
        "dataset_index": 492
      },
      "seg7_9c1b6e95": {
        "rtl_code": "\nmodule seg7 (\n    input  wire         clk,\n    input  wire         reset,\n    input  wire  [15:0] value,\n    output reg   [6:0]  seg,\n    output reg          dp,\n    output reg   [3:0]  an\n);\n\n\n    localparam COUNTER_WIDTH = 18;\n\n    reg [COUNTER_WIDTH-1:0] counter;\n    reg counter_msb_d1;\n    wire counter_edge;\n    reg [1:0] digit;\n    wire [6:0] seg0, seg1, seg2, seg3;\n\n    always @(posedge clk) begin\n        if (reset == 1'b1) begin\n            counter <= {COUNTER_WIDTH{1'b0}};\n            counter_msb_d1 <= 1'b0;\n        end else begin\n            counter <= counter + 1'b1;\n            counter_msb_d1 <= counter[COUNTER_WIDTH-1];\n        end\n    end\n\n    assign counter_edge = ~counter_msb_d1 & counter[COUNTER_WIDTH-1];\n\n    always @(posedge clk) begin\n        if (reset == 1'b1) begin\n            seg <= 7'b1111111;\n            dp  <= 1'b1;\n            an  <= 4'b1111;\n            digit <= 2'b0;\n        end else begin\n            if (counter_edge == 1'b1) begin\n                digit <= digit + 1'b1;\n                case (digit)\n                2'b00: begin\n                    an  <= 4'b1110;\n                    seg <= seg0;\n                end\n                2'b01: begin\n                    an  <= 4'b1101;\n                    seg <= seg1;\n                end\n                2'b10: begin\n                    an  <= 4'b1011;\n                    seg <= seg2;\n                end\n                2'b11: begin\n                    an  <= 4'b0111;\n                    seg <= seg3;\n                end\n                endcase\n            end\n        end\n    end\n\n    val2seg u_val2seg0 (.value(value[3:0]),   .seg(seg0));\n    val2seg u_val2seg1 (.value(value[7:4]),   .seg(seg1));\n    val2seg u_val2seg2 (.value(value[11:8]),  .seg(seg2));\n    val2seg u_val2seg3 (.value(value[15:12]), .seg(seg3));\n\nendmodule\n\n\nmodule val2seg (\n    input  wire  [3:0] value,\n    output reg   [6:0] seg\n);\n\n    localparam CHAR_N        = 7'b1111111;\n    localparam CHAR_0        = 7'b1000000;\n    localparam CHAR_1        = 7'b1111001;\n    localparam CHAR_2        = 7'b0100100;\n    localparam CHAR_3        = 7'b0110000;\n    localparam CHAR_4        = 7'b0011001;\n    localparam CHAR_5        = 7'b0010010;\n    localparam CHAR_6        = 7'b0000010;\n    localparam CHAR_7        = 7'b1111000;\n    localparam CHAR_8        = 7'b0000000;\n    localparam CHAR_9        = 7'b0010000;\n    localparam CHAR_A        = 7'b0001000;\n    localparam CHAR_B        = 7'b0000011;\n    localparam CHAR_C        = 7'b1000110;\n    localparam CHAR_D        = 7'b0100001;\n    localparam CHAR_E        = 7'b0000110;\n    localparam CHAR_F        = 7'b0001110;\n\n    always @(*) begin\n        case (value)\n        4'h0: seg <= CHAR_0;\n        4'h1: seg <= CHAR_1;\n        4'h2: seg <= CHAR_2;\n        4'h3: seg <= CHAR_3;\n        4'h4: seg <= CHAR_4;\n        4'h5: seg <= CHAR_5;\n        4'h6: seg <= CHAR_6;\n        4'h7: seg <= CHAR_7;\n        4'h8: seg <= CHAR_8;\n        4'h9: seg <= CHAR_9;\n        4'hA: seg <= CHAR_A;\n        4'hB: seg <= CHAR_B;\n        4'hC: seg <= CHAR_C;\n        4'hD: seg <= CHAR_D;\n        4'hE: seg <= CHAR_E;\n        4'hF: seg <= CHAR_F;\n        default: seg <= CHAR_N;\n        endcase\n    end\n\nendmodule\n\n\n",
        "module_name": "seg7",
        "module_hash": "9c1b6e95e5ca6314caf425662245b262",
        "dataset_index": 17906
      },
      "ad_ss_422to444_7680d8b9": {
        "rtl_code": "module ad_ss_422to444 (\n  // 422 inputs\n  clk,\n  s422_de,\n  s422_sync,\n  s422_data,\n  // 444 outputs\n  s444_sync,\n  s444_data);\n  // parameters\n  parameter   Cr_Cb_N = 0;\n  parameter   DELAY_DATA_WIDTH = 16;\n  localparam  DW = DELAY_DATA_WIDTH - 1;\n  // 422 inputs\n  input           clk;\n  input           s422_de;\n  input   [DW:0]  s422_sync;\n  input   [15:0]  s422_data;\n  // 444 inputs\n  output  [DW:0]  s444_sync;\n  output  [23:0]  s444_data;\n  // internal registers\n  reg             cr_cb_sel = 'd0;\n  reg             s422_de_d = 'd0;\n  reg     [DW:0]  s422_sync_d = 'd0;\n  reg             s422_de_2d = 'd0;\n  reg      [7:0]  s422_Y_d;\n  reg      [7:0]  s422_CbCr_d;\n  reg      [7:0]  s422_CbCr_2d;\n  reg     [DW:0]  s444_sync = 'd0;\n  reg     [23:0]  s444_data = 'd0;\n  reg     [ 8:0]  s422_CbCr_avg;\n  // internal wires\n  wire    [ 7:0]  s422_Y;\n  wire    [ 7:0]  s422_CbCr;\n  // Input format is \n  // [15:8] Cb/Cr\n  // [ 7:0] Y\n  //\n  // Output format is\n  // [23:15] Cr\n  // [16: 8] Y\n  // [ 7: 0] Cb\n  assign s422_Y = s422_data[7:0];\n  assign s422_CbCr = s422_data[15:8];\n  // first data on de assertion is cb (0x0), then cr (0x1).\n  // previous data is held when not current\n  always @(posedge clk) begin\n    if (s422_de_d == 1'b1) begin\n      cr_cb_sel <= ~cr_cb_sel;\n    end else begin\n      cr_cb_sel <= Cr_Cb_N;\n    end\n  end\n  // pipe line stages\n  always @(posedge clk) begin\n    s422_de_d <= s422_de;\n    s422_sync_d <= s422_sync;\n    s422_de_2d <= s422_de_d;\n\ts422_Y_d <= s422_Y;\n\ts422_CbCr_d <= s422_CbCr;\n\ts422_CbCr_2d <= s422_CbCr_d;\n  end\n  // If both the left and the right sample are valid do the average, otherwise\n  // use the only valid.\n  always @(s422_de_2d, s422_de, s422_CbCr, s422_CbCr_2d)\n  begin\n\t\tif (s422_de == 1'b1 && s422_de_2d)\n\t\t\ts422_CbCr_avg <= s422_CbCr + s422_CbCr_2d;\n\t\telse if (s422_de == 1'b1)\n\t\t\ts422_CbCr_avg <= {s422_CbCr, 1'b0};\n\t\telse\n\t\t\ts422_CbCr_avg <= {s422_CbCr_2d, 1'b0};\n  end\n  // 444 outputs\n  always @(posedge clk) begin\n    s444_sync <= s422_sync_d;\n    s444_data[15:8] <= s422_Y_d;\n\tif (cr_cb_sel) begin\n\t\ts444_data[23:16] <= s422_CbCr_d;\n\t\ts444_data[ 7: 0] <= s422_CbCr_avg[8:1];\n\tend else begin\n\t\ts444_data[23:16] <= s422_CbCr_avg[8:1];\n\t\ts444_data[ 7: 0] <= s422_CbCr_d;\n\tend\n  end\nendmodule",
        "module_name": "ad_ss_422to444",
        "module_hash": "7680d8b939bc3812e62cda3780a23e2c",
        "dataset_index": 18362
      },
      "minimac2_tx_f9047673": {
        "rtl_code": "\n\nmodule minimac2_tx(\n\tinput phy_tx_clk,\n\n\tinput tx_start,\n\toutput reg tx_done,\n\tinput [10:0] tx_count,\n\tinput [7:0] txb_dat,\n\toutput [10:0] txb_adr,\n\t\n\toutput reg phy_tx_en,\n\toutput reg [3:0] phy_tx_data\n);\n\nreg phy_tx_en_r;\nreg phy_tx_data_sel;\nwire [3:0] phy_tx_data_r = phy_tx_data_sel ? txb_dat[7:4] : txb_dat[3:0];\nalways @(posedge phy_tx_clk) begin\n\tphy_tx_en <= phy_tx_en_r;\n\tphy_tx_data <= phy_tx_data_r;\nend\n\nreg [10:0] byte_count;\nreg byte_count_reset;\nreg byte_count_inc;\nalways @(posedge phy_tx_clk) begin\n\tif(byte_count_reset)\n\t\tbyte_count <= 11'd0;\n\telse if(byte_count_inc)\n\t\tbyte_count <= byte_count + 11'd1;\nend\nassign txb_adr = byte_count;\nwire byte_count_max = byte_count == tx_count;\n\nparameter IDLE\t\t= 2'd0;\nparameter SEND_LO\t= 2'd1;\nparameter SEND_HI\t= 2'd2;\nparameter TERMINATE\t= 2'd3;\n\nreg [1:0] state;\nreg [1:0] next_state;\n\ninitial state <= IDLE;\nalways @(posedge phy_tx_clk)\n\tstate <= next_state;\n\nalways @(*) begin\n\tphy_tx_en_r = 1'b0;\n\tphy_tx_data_sel = 1'b0;\n\tbyte_count_reset = 1'b0;\n\tbyte_count_inc = 1'b0;\n\ttx_done = 1'b0;\n\t\n\tnext_state = state;\n\t\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tbyte_count_reset = 1'b1;\n\t\t\tif(tx_start)\n\t\t\t\tnext_state = SEND_LO;\n\t\tend\n\t\tSEND_LO: begin\n\t\t\tbyte_count_inc = 1'b1;\n\t\t\tphy_tx_en_r = 1'b1;\n\t\t\tphy_tx_data_sel = 1'b0;\n\t\t\tnext_state = SEND_HI;\n\t\tend\n\t\tSEND_HI: begin\n\t\t\tphy_tx_en_r = 1'b1;\n\t\t\tphy_tx_data_sel = 1'b1;\n\t\t\tif(byte_count_max)\n\t\t\t\tnext_state = TERMINATE;\n\t\t\telse\n\t\t\t\tnext_state = SEND_LO;\n\t\tend\n\t\tTERMINATE: begin\n\t\t\tbyte_count_reset = 1'b1;\n\t\t\ttx_done = 1'b1;\n\t\t\tnext_state = IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "minimac2_tx",
        "module_hash": "f90476739d006752faa5359d4ad56f2d",
        "dataset_index": 23997
      },
      "fifo_91a7f598": {
        "rtl_code": "\nmodule fifo(\n    input clk,\n    input wr,\n    input [7:0] din,\n    output reg rd,\n    output reg [7:0] dout\n);\n\nreg [7:0] mem [0:7]; // Memory for storing FIFO elements\nreg [2:0] wr_ptr = 3'b000; // Write pointer\nreg [2:0] rd_ptr = 3'b000; // Read pointer\n\n// Write logic\nalways @(posedge clk) begin\n    if (wr) begin // Write only if wr=1\n        mem[wr_ptr] <= din;\n        wr_ptr <= wr_ptr + 3'b001;\n        if (wr_ptr == 3'b100) begin\n            wr_ptr <= 3'b000;\n        end\n    end\nend\n\n// Read logic\nalways @(posedge clk) begin\n    if (rd) begin // Read only if rd=1\n        dout <= mem[rd_ptr];\n        rd_ptr <= rd_ptr + 3'b001;\n        if (rd_ptr == 3'b100) begin\n            rd_ptr <= 3'b000;\n        end\n    end\nend\n\n// Output logic\nalways @(*) begin\n    rd = (rd_ptr != wr_ptr);\nend\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "91a7f5980543f639f4e6ffe631828728",
        "dataset_index": 5137
      },
      "scrambler #_622e553f": {
        "rtl_code": "module scrambler # (\n\tparameter WIDTH = 512\n)(\n\tinput clk, arst, ena,\n\tinput [WIDTH-1:0] din,\t\t// bit 0 is to be sent first\n\toutput reg [WIDTH-1:0] dout\n);\n\nlocalparam SCRAM_INIT = 58'h3ff_ffff_ffff_ffff;\n\nreg [57:0] scram_state = SCRAM_INIT;\n\nwire [WIDTH+58-1:0] history;\nassign history [57:0] = scram_state;\n\ngenvar i;\ngenerate\n\tfor (i=58; i<WIDTH+58; i=i+1) begin : lp\n\t\tassign history[i] = history[i-58] ^ history[i-39] ^ din[i-58];\t\t\n\tend\nendgenerate\n\t\nalways @(posedge clk or posedge arst) begin\n\tif (arst) begin\n\t\tdout <= 0;\n\t\tscram_state <= SCRAM_INIT;\n\tend\n\telse if (ena) begin\n\t\tdout <= history[WIDTH+58-1:58];\n\t\tscram_state <= history[WIDTH+58-1:WIDTH];\n\tend\nend\n\nendmodule",
        "module_name": "scrambler #",
        "module_hash": "622e553f74b1a48cf7c048de22cc9f4d",
        "dataset_index": 10557
      },
      "core_pc_6d537995": {
        "rtl_code": "module core_pc(clk,\n               rst,\n               btb_target,\n               ras_target,\n               pc_go,\n               stall,\n               good_target, id_pc_src,  btb_v,\n               btb_type,\n               pc_out,\n               v_pc_out,\n               pc_plus4\n               );\nparameter  initial_addr=32'h00040000;\nparameter  br_type=2'b00;\nparameter  j_type=2'b01;\nparameter  jal_type=2'b10;\nparameter  jr_type=2'b11;\ninput           clk;\ninput           rst; \ninput  [31:0]   btb_target;\ninput  [31:0]   ras_target;\ninput           id_pc_src;\ninput           stall;\ninput           pc_go;\ninput  [31:0]   good_target;\ninput  [1:0]    btb_type;\ninput           btb_v;\n\n\noutput  [31:0]    pc_out;\noutput            v_pc_out;\noutput  [31:0]    pc_plus4;\n\n\nwire     [1:0]   pc_src;\nwire     [1:0]   pc_src1;\n\nassign    pc_src1=(btb_v&&(btb_type==br_type||btb_type==j_type||btb_type==jal_type))?2'b11:(btb_v&&btb_type==jr_type)?2'b10:2'b01;\nassign    pc_src=(id_pc_src==1'b1)?2'b00:pc_src1;\n\nreg  [31:0]     pc_temp;\nalways@(*)\nbegin\n   case(pc_src)\n\t2'b00:pc_temp=good_target;\n\t2'b01:pc_temp=pc_plus4;\n\t2'b10:pc_temp=ras_target;\n\t2'b11:pc_temp=btb_target;\n\tdefault:pc_temp=pc_plus4;\n\tendcase\nend\nreg  [31:0]     pc;\nalways@(posedge clk)\nbegin\n  if(rst)\n    pc<=32'h00040000;\n  else if(pc_go&&!stall)\n    begin\n      pc<=pc_temp;\n     end\nend\nassign  pc_plus4=pc+4;\nassign  v_pc_out=(pc_go&&!stall);assign  pc_out=pc;\nendmodule",
        "module_name": "core_pc",
        "module_hash": "6d537995f9f013677979a017059312fd",
        "dataset_index": 14401
      },
      "QPSK_Demodulator_Baseband_73b68563": {
        "rtl_code": "\n\nmodule QPSK_Demodulator_Baseband\n          (\n           in0_re,\n           in0_im,\n           out0\n          );\n\n\n  input   signed [15:0] in0_re;  input   signed [15:0] in0_im;  output  [1:0] out0;  wire inphase_lt_zero;\n  wire inphase_eq_zero;\n  wire quadrature_lt_zero;\n  wire quadrature_eq_zero;\n  wire [3:0] decisionLUTaddr;  wire [1:0] DirectLookupTable_1 [0:15];  wire [1:0] hardDecision;  assign inphase_lt_zero = (in0_re < 16'sb0000000000000000 ? 1'b1 :\n              1'b0);\n\n\n\n  assign inphase_eq_zero = (in0_re == 16'sb0000000000000000 ? 1'b1 :\n              1'b0);\n\n\n\n  assign quadrature_lt_zero = (in0_im < 16'sb0000000000000000 ? 1'b1 :\n              1'b0);\n\n\n\n  assign quadrature_eq_zero = (in0_im == 16'sb0000000000000000 ? 1'b1 :\n              1'b0);\n\n\n\n  assign decisionLUTaddr = {inphase_lt_zero, inphase_eq_zero, quadrature_lt_zero, quadrature_eq_zero};\n\n\n\n  assign DirectLookupTable_1[0] = 2'b00;\n  assign DirectLookupTable_1[1] = 2'b00;\n  assign DirectLookupTable_1[2] = 2'b10;\n  assign DirectLookupTable_1[3] = 2'b00;\n  assign DirectLookupTable_1[4] = 2'b01;\n  assign DirectLookupTable_1[5] = 2'b00;\n  assign DirectLookupTable_1[6] = 2'b10;\n  assign DirectLookupTable_1[7] = 2'b00;\n  assign DirectLookupTable_1[8] = 2'b01;\n  assign DirectLookupTable_1[9] = 2'b11;\n  assign DirectLookupTable_1[10] = 2'b11;\n  assign DirectLookupTable_1[11] = 2'b00;\n  assign DirectLookupTable_1[12] = 2'b00;\n  assign DirectLookupTable_1[13] = 2'b00;\n  assign DirectLookupTable_1[14] = 2'b00;\n  assign DirectLookupTable_1[15] = 2'b00;\n  assign hardDecision = DirectLookupTable_1[decisionLUTaddr];\n\n\n\n  assign out0 = hardDecision;\n\nendmodule  ",
        "module_name": "QPSK_Demodulator_Baseband",
        "module_hash": "73b685639003a1d1edbf4e73f7057db5",
        "dataset_index": 24122
      },
      "shift_register_9f4be7b6": {
        "rtl_code": "module shift_register (\n    in,\n    shift,\n    reset,\n    clk,\n    out\n);\n\ninput [7:0] in;\ninput shift, reset, clk;\noutput [7:0] out;\n\nreg [7:0] shift_reg;\n\nalways @ (posedge clk or posedge reset) begin\n    if (reset) begin\n        shift_reg <= 8'b0;\n    end else if (shift) begin\n        shift_reg <= {shift_reg[6:0], in};\n    end\nend\n\nassign out = shift_reg;\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "9f4be7b683aa1fd45de03a1a4b0c66b1",
        "dataset_index": 5177
      },
      "sky130_fd_sc_hdll__nor2b_bb238ab9": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__nor2b (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    wire not0_out  ;\n    wire and0_out_Y;\n\n    not not0 (not0_out  , A              );\n    and and0 (and0_out_Y, not0_out, B_N  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__nor2b",
        "module_hash": "bb238ab944ebe7d27511c81400a6a4b5",
        "dataset_index": 12699
      },
      "sky130_fd_sc_lp__o32a_e20cd338": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o32a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1, A3      );\n    or  or1  (or1_out   , B2, B1          );\n    and and0 (and0_out_X, or0_out, or1_out);\n    buf buf0 (X         , and0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o32a",
        "module_hash": "e20cd338495f2b4d72982093934b6355",
        "dataset_index": 17679
      },
      "uniphy_status_3ae4e0df": {
        "rtl_code": "module uniphy_status\n#( \n  parameter WIDTH=32,\n  parameter NUM_UNIPHYS=2\n)\n(\n   input clk,\n   input resetn,\n\n   input slave_read,\n   output [WIDTH-1:0] slave_readdata,\n\n   input  mem0_local_cal_success,\n   input  mem0_local_cal_fail,\n   input  mem0_local_init_done,\n\n   input  mem1_local_cal_success,\n   input  mem1_local_cal_fail,\n   input  mem1_local_init_done,\n\n   input  mem2_local_cal_success,\n   input  mem2_local_cal_fail,\n   input  mem2_local_init_done,\n\n   input  mem3_local_cal_success,\n   input  mem3_local_cal_fail,\n   input  mem3_local_init_done,\n\n   input  mem4_local_cal_success,\n   input  mem4_local_cal_fail,\n   input  mem4_local_init_done,\n\n   input  mem5_local_cal_success,\n   input  mem5_local_cal_fail,\n   input  mem5_local_init_done,\n\n   input  mem6_local_cal_success,\n   input  mem6_local_cal_fail,\n   input  mem6_local_init_done,\n\n   input  mem7_local_cal_success,\n   input  mem7_local_cal_fail,\n   input  mem7_local_init_done,\n\n   output  export_local_cal_success,\n   output  export_local_cal_fail,\n   output  export_local_init_done\n);\n\nreg [WIDTH-1:0] aggregate_uniphy_status;\nwire  local_cal_success;\nwire  local_cal_fail;\nwire  local_init_done;\nwire [NUM_UNIPHYS-1:0] not_init_done;\nwire [7:0] mask;\n\nassign mask = (NUM_UNIPHYS < 1) ? 0 : ~(8'hff << NUM_UNIPHYS);\n\nassign local_cal_success = &( ~mask | {mem7_local_cal_success,\n                                       mem6_local_cal_success,\n                                       mem5_local_cal_success,\n                                       mem4_local_cal_success,\n                                       mem3_local_cal_success,\n                                       mem2_local_cal_success,\n                                       mem1_local_cal_success,\n                                       mem0_local_cal_success});\n\nassign local_cal_fail    = mem0_local_cal_fail |\n                           mem1_local_cal_fail |\n                           mem2_local_cal_fail |\n                           mem3_local_cal_fail |\n                           mem4_local_cal_fail |\n                           mem5_local_cal_fail |\n                           mem6_local_cal_fail |\n                           mem7_local_cal_fail;\n\nassign local_init_done =  &( ~mask |{mem7_local_init_done,\n                                     mem6_local_init_done,\n                                     mem5_local_init_done,\n                                     mem4_local_init_done,\n                                     mem3_local_init_done,\n                                     mem2_local_init_done,\n                                     mem1_local_init_done,\n                                     mem0_local_init_done});\n\nassign not_init_done = mask & ~{ mem7_local_init_done,\n                           mem6_local_init_done,\n                           mem5_local_init_done,\n                           mem4_local_init_done,\n                           mem3_local_init_done,\n                           mem2_local_init_done,\n                           mem1_local_init_done,\n                           mem0_local_init_done};\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    aggregate_uniphy_status <= {WIDTH{1'b0}};\n  else\n    aggregate_uniphy_status <= { not_init_done, 1'b0,\n                                  {~local_cal_success,local_cal_fail,~local_init_done}\n                                };\n\nassign slave_readdata = aggregate_uniphy_status;\nassign export_local_cal_success = local_cal_success;\nassign export_local_cal_fail = local_cal_fail;\nassign export_local_init_done = local_init_done;\n\nendmodule\n\n",
        "module_name": "uniphy_status",
        "module_hash": "3ae4e0df16ea015449788aaf4e02ea31",
        "dataset_index": 25863
      },
      "sky130_fd_sc_ls__a221oi_fba739b2": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a221oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire and0_out  ;\n    wire and1_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , B1, B2                );\n    and and1 (and1_out  , A1, A2                );\n    nor nor0 (nor0_out_Y, and0_out, C1, and1_out);\n    buf buf0 (Y         , nor0_out_Y            );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a221oi",
        "module_hash": "fba739b2cd28bbdec9244ab796f80e15",
        "dataset_index": 13844
      },
      "sky130_fd_sc_lp__a21oi_e67edd80": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a21oi",
        "module_hash": "e67edd80014a136d34adfc11385a0cc1",
        "dataset_index": 21680
      },
      "GrayCodeStateMachine #_f8528d73": {
        "rtl_code": "\nmodule GrayCodeStateMachine #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input clk,\n  input rst,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\n// Define internal signals\nreg [n-1:0] state_reg;\nreg [n-1:0] state_next;\nwire [m-1:0] out_logic;\n\n// Gray code encoding\nfunction [n-1:0] gray_encode;\n  input [n-1:0] binary;\n  begin\n    gray_encode = binary ^ (binary >> 1);\n  end\nendfunction\n\n// State register\nalways @(posedge clk, posedge rst) begin\n  if (rst) begin\n    state_reg <= 0;\n  end else begin\n    state_reg <= state_next;\n  end\nend\n\n// Next-state logic\nalways @(*) begin\n  case (state_reg)\n    // Define state transitions using Gray code\n    4'b0000: state_next = gray_encode({in[0], in[1], in[2], in[3]});\n    4'b0001: state_next = gray_encode({in[0], in[1], in[2], ~in[3]});\n    4'b0011: state_next = gray_encode({in[0], in[1], ~in[2], in[3]});\n    4'b0010: state_next = gray_encode({in[0], in[1], ~in[2], ~in[3]});\n    4'b0110: state_next = gray_encode({in[0], ~in[1], in[2], in[3]});\n    4'b0111: state_next = gray_encode({in[0], ~in[1], in[2], ~in[3]});\n    4'b0101: state_next = gray_encode({in[0], ~in[1], ~in[2], in[3]});\n    4'b0100: state_next = gray_encode({in[0], ~in[1], ~in[2], ~in[3]});\n    4'b1100: state_next = gray_encode({~in[0], in[1], in[2], in[3]});\n    4'b1101: state_next = gray_encode({~in[0], in[1], in[2], ~in[3]});\n    4'b1111: state_next = gray_encode({~in[0], in[1], ~in[2], in[3]});\n    4'b1110: state_next = gray_encode({~in[0], in[1], ~in[2], ~in[3]});\n    4'b1010: state_next = gray_encode({~in[0], ~in[1], in[2], in[3]});\n    4'b1011: state_next = gray_encode({~in[0], ~in[1], in[2], ~in[3]});\n    4'b1001: state_next = gray_encode({~in[0], ~in[1], ~in[2], in[3]});\n    4'b1000: state_next = gray_encode({~in[0], ~in[1], ~in[2], ~in[3]});\n    default: state_next = 0;\n  endcase\nend\n\n// Output logic\nassign out_logic = (state_reg == {~in[0], ~in[1], ~in[2], ~in[3]}) ? {1'b0, 1'b0} :\n                  (state_reg == {~in[0], ~in[1], ~in[2], in[3]}) ? {1'b0, 1'b1} :\n                  (state_reg == {~in[0], ~in[1], in[2], ~in[3]}) ? {1'b1, 1'b0} :\n                  (state_reg == {~in[0], ~in[1], in[2], in[3]}) ? {1'b1, 1'b1} :\n                  (state_reg == {~in[0], in[1], ~in[2], ~in[3]}) ? {1'b0, 1'b1} :\n                  (state_reg == {~in[0], in[1], ~in[2], in[3]}) ? {1'b0, 1'b0} :\n                  (state_reg == {~in[0], in[1], in[2], ~in[3]}) ? {1'b1, 1'b1} :\n                  (state_reg == {~in[0], in[1], in[2], in[3]}) ? {1'b1, 1'b0} :\n                  (state_reg == {in[0], ~in[1], ~in[2], ~in[3]}) ? {1'b1, 1'b1} :\n                  (state_reg == {in[0], ~in[1], ~in[2], in[3]}) ? {1'b1, 1'b0} :\n                  (state_reg == {in[0], ~in[1], in[2], ~in[3]}) ? {1'b0, 1'b1} :\n                  (state_reg == {in[0], ~in[1], in[2], in[3]}) ? {1'b0, 1'b0} :\n                  (state_reg == {in[0], in[1], ~in[2], ~in[3]}) ? {1'b1, 1'b0} :\n                  (state_reg == {in[0], in[1], ~in[2], in[3]}) ? {1'b1, 1'b1} :\n                  (state_reg == {in[0], in[1], in[2], ~in[3]}) ? {1'b0, 1'b0} :\n                  (state_reg == {in[0], in[1], in[2], in[3]}) ? {1'b0, 1'b1} : 2'bxx;\n\n// Assign output signals\nassign out = out_logic;\n\nendmodule\n",
        "module_name": "GrayCodeStateMachine #",
        "module_hash": "f8528d73d81b3b25ebdb9f9dd206d809",
        "dataset_index": 19970
      },
      "sky130_fd_sc_lp__xnor2_f66b3e97": {
        "rtl_code": "module sky130_fd_sc_lp__xnor2 (\n    input  A,\n    input  B,\n    output Y\n);\n\n    wire n1, n2, n3, n4;\n\n    assign n1 = ~(A & B);\n    assign n2 = ~(A | B);\n    assign n3 = ~(n1 | n2);\n    assign n4 = ~(n3);\n\n    assign Y = n4;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__xnor2",
        "module_hash": "f66b3e975e49d9a2f6ab0031cfddf537",
        "dataset_index": 21338
      },
      "d_ff_sr_9e4e62c6": {
        "rtl_code": "module d_ff_sr(\n    output reg Q,\n    input D,\n    input clk,\n    input sr\n);\n\n    always @(posedge clk) begin\n        if (sr) begin\n            Q <= 1'b0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "d_ff_sr",
        "module_hash": "9e4e62c69014343b561c9072a7667154",
        "dataset_index": 231
      },
      "shift_reg_mux_fd4dc24a": {
        "rtl_code": "module shift_reg_mux(\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    input sel_b1,\n    input sel_b2,\n    output reg [3:0] q\n);\n\nreg [3:0] shift_reg;\nwire mux_out;\n\n// 4-bit shift register with synchronous reset, synchronous load, and enable\nalways @(posedge clk, posedge areset) begin\n    if (areset) begin\n        shift_reg <= 4'b0;\n    end else if (load) begin\n        shift_reg <= data;\n    end else if (ena) begin\n        shift_reg <= {shift_reg[2:0], data[0]};\n    end\nend\n\n// 2-to-1 multiplexer with constant value of 0x0F\nassign mux_out = (sel_b1 & sel_b2) ? 4'hF : shift_reg;\n\n// output of the multiplexer\nalways @(posedge clk, posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else begin\n        q <= mux_out;\n    end\nend\n\nendmodule",
        "module_name": "shift_reg_mux",
        "module_hash": "fd4dc24ad198dd788e76d62da54b3f48",
        "dataset_index": 13279
      },
      "PS3spiControl_8e5f0370": {
        "rtl_code": "\nmodule PS3spiControl(\n    input clk,\n    input extdata,\n    input extclk,\n    input extcs,\n    output reg [7:0] keys1,\n    output reg [7:0] keys2\n    );\n    \n    reg [7:0] inputbyte;\n    reg [3:0] bytestate;\n    reg [2:0] bitcounter;\n    reg byte_rec;\n    \n    reg [2:0] extclk_r;\n    reg [2:0] extcs_r;\n    reg [1:0] extdata_r;\n    always@ (posedge clk) begin\n        extclk_r <= {extclk_r[1:0], extclk};\n        extcs_r <= {extcs_r[1:0], extcs};\n        extdata_r <= {extdata_r[0], extdata};\n    end\n    wire extclk_rising = (extclk_r[2:1] == 2'b01);\n    wire cs_active = ~extcs_r[1];\n    wire extdata_in = extdata_r[1];\n    \n    initial begin;\n        inputbyte = 8'b00000000;\n        bytestate = 4'b0000;\n        bitcounter = 3'b000;\n        byte_rec = 0;\n        keys1 = 0;\n        keys2 = 0;\n    end\n    \n    always@ (posedge clk) begin\n        if (~cs_active)\n            bitcounter <= 0;\n        else\n        if (extclk_rising) begin\n            inputbyte <= {inputbyte[6:0], extdata_in};\n            bitcounter <= bitcounter + 1;\n        end\n    end\n    \n    always@ (posedge clk) begin\n        byte_rec <= extclk_rising && bitcounter == 3'b111;\n    end\n    always@ (posedge clk) begin\n        if (byte_rec) begin\n            if (inputbyte[7]) begin\n                bytestate = 4'b0000;\n            end\n            case (bytestate)\n            \n                4'b0000: begin keys1[7] = inputbyte[1]; keys1[6] = inputbyte[2]; keys1[5] = inputbyte[0]; keys1[4] = inputbyte[3]; keys1[3] = inputbyte[4]; bytestate = 4'b0001;\n                end\n                \n                4'b0001: begin keys1[1] = inputbyte[2]; keys1[0] = inputbyte[1]; bytestate = 4'b0010;\n                end\n                \n                4'b0010: begin keys1[2] = inputbyte[0] | inputbyte[2]; bytestate = 4'b0000; end\n                \n            endcase\n        end\n    end \n    \nendmodule\n",
        "module_name": "PS3spiControl",
        "module_hash": "8e5f0370386faf2c8b7d5a0eed1b5c6a",
        "dataset_index": 22284
      },
      "system_auto_cc_0_synchronizer_ff__parameterized2_38c9c0a7": {
        "rtl_code": "module system_auto_cc_0_synchronizer_ff__parameterized2 (\n  output [3:0] D,\n  input [3:0] Q_reg_reg_0,\n  input s_aclk,\n  input [0:0] ngwrdrst_grst_g7serrst_rd_rst_reg_reg_1\n);\n\n  wire [3:0] Q_reg;\n  \n  assign D = Q_reg;\n  \n  // Instantiate the four FDCE flip-flops\n  FDCE  flipflop0 (\n        .C(s_aclk),\n        .CE(1'b1),\n        .CLR(ngwrdrst_grst_g7serrst_rd_rst_reg_reg_1),\n        .D(Q_reg_reg_0[0]),\n        .Q(Q_reg[0])\n  );\n  \n  FDCE flipflop1 (\n        .C(s_aclk),\n        .CE(1'b1),\n        .CLR(ngwrdrst_grst_g7serrst_rd_rst_reg_reg_1),\n        .D(Q_reg_reg_0[1]),\n        .Q(Q_reg[1])\n  );\n  \n  FDCE flipflop2 (\n        .C(s_aclk),\n        .CE(1'b1),\n        .CLR(ngwrdrst_grst_g7serrst_rd_rst_reg_reg_1),\n        .D(Q_reg_reg_0[2]),\n        .Q(Q_reg[2])\n  );\n  \n  FDCE flipflop3 (\n        .C(s_aclk),\n        .CE(1'b1),\n        .CLR(ngwrdrst_grst_g7serrst_rd_rst_reg_reg_1),\n        .D(Q_reg_reg_0[3]),\n        .Q(Q_reg[3])\n  );\n\nendmodule\n\nmodule FDCE (\n  input C,\n  input CE,\n  input CLR,\n  input D,\n  output reg Q\n);\n\n  always @(posedge C or posedge CLR)\n    if (CLR)\n      Q <= 1'b0;\n    else if (CE)\n      Q <= D;\n\nendmodule",
        "module_name": "system_auto_cc_0_synchronizer_ff__parameterized2",
        "module_hash": "38c9c0a7d68608148013108800fed609",
        "dataset_index": 6467
      },
      "sqrt_pipelined_65c1197a": {
        "rtl_code": "\nmodule sqrt_pipelined\n  (\n   input                        clk,        input                        reset_n,    input                        start,      input [INPUT_BITS-1:0]       radicand,   output reg                   data_valid, output reg [OUTPUT_BITS-1:0] root        );\n\n  parameter\n    INPUT_BITS   = 16; localparam\n    OUTPUT_BITS  = INPUT_BITS / 2 + INPUT_BITS % 2; reg [OUTPUT_BITS-1:0]         start_gen; reg [OUTPUT_BITS*INPUT_BITS-1:0] root_gen; reg [OUTPUT_BITS*INPUT_BITS-1:0] radicand_gen; wire [OUTPUT_BITS*INPUT_BITS-1:0] mask_gen; always @ (posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      start_gen[0]                 <= 0;\n      radicand_gen[INPUT_BITS-1:0] <= 0;\n      root_gen[INPUT_BITS-1:0]     <= 0;\n    end\n    else begin\n      start_gen[0] <= start;\n      if ( mask_gen[INPUT_BITS-1:0] <= radicand ) begin\n        radicand_gen[INPUT_BITS-1:0] <= radicand - mask_gen[INPUT_BITS-1:0];\n        root_gen[INPUT_BITS-1:0] <= mask_gen[INPUT_BITS-1:0];\n      end\n      else begin\n        radicand_gen[INPUT_BITS-1:0] <= radicand;\n        root_gen[INPUT_BITS-1:0] <= 0;\n      end\n    end\n  end\n\n  generate\n    genvar i;\n    for (i = 0; i < OUTPUT_BITS; i = i + 1) begin: mask_4\n      if (i % 2) assign mask_gen[INPUT_BITS*(OUTPUT_BITS-i)-1:INPUT_BITS*(OUTPUT_BITS-i-1)]  = 4 << 4 * (i/2);\n      else assign mask_gen[INPUT_BITS*(OUTPUT_BITS-i)-1:INPUT_BITS*(OUTPUT_BITS-i-1)]  = 1 << 4 * (i/2);\n    end\n    for (i = 0; i < OUTPUT_BITS - 1; i = i + 1) begin: pipeline\n      always @ (posedge clk or negedge reset_n) begin : pipeline_stage\n        if (!reset_n) begin\n          start_gen[i+1]                                    <= 0;\n          radicand_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= 0;\n          root_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)]     <= 0;\n        end\n        else begin\n          start_gen[i+1] <= start_gen[i];\n          if ((root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] + \n               mask_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)]) <= radicand_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i]) begin\n\t    radicand_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= radicand_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] - \n                                                                 mask_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] - \n                                                                 root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i];\n\t    root_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= (root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] >> 1) + \n                                                             mask_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)];\n          end\n          else begin\n\t    radicand_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= radicand_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i];\n\t    root_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)]     <= root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] >> 1;\n          end\n        end\n      end\n    end\n  endgenerate\n\n  always @ (posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      data_valid <= 0;\n      root       <= 0;\n    end\n    else begin\n      data_valid <= start_gen[OUTPUT_BITS-1];\n      if (root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS] > root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS])\n        root <= root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS] + 1;\n      else\n        root  <= root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS];\n    end\n  end\n\nendmodule\n",
        "module_name": "sqrt_pipelined",
        "module_hash": "65c1197a90fc8bd3f134da724fb1d8c9",
        "dataset_index": 4156
      },
      "bin2gray_aef02e06": {
        "rtl_code": "module bin2gray(\n    input [3:0] bin,\n    output [3:0] gray\n);\n\nwire w1, w2, w3;\n\nassign w1 = bin[0] ^ bin[1];\nassign w2 = bin[1] ^ bin[2];\nassign w3 = bin[2] ^ bin[3];\n\nassign gray[0] = bin[0];\nassign gray[1] = w1;\nassign gray[2] = w2 ^ w1;\nassign gray[3] = w3 ^ w2 ^ bin[3];\n\nendmodule",
        "module_name": "bin2gray",
        "module_hash": "aef02e063b463cf52f12e337d5dd410d",
        "dataset_index": 852
      },
      "johnson_counter_2b0cc687": {
        "rtl_code": "\nmodule johnson_counter(\n  input clk,\n  input reset,\n  output [2:0] out\n);\n\n  reg [2:0] q;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      q <= 3'b000;\n    end else begin\n      q <= {q[1:0], q[2]};\n    end\n  end\n\n  assign out = q;\n\nendmodule",
        "module_name": "johnson_counter",
        "module_hash": "2b0cc6872230dc6912b5fa21e18d717b",
        "dataset_index": 1009
      },
      "mig_7series_v2_3_bank_compare #_04835df8": {
        "rtl_code": "\n\nmodule mig_7series_v2_3_bank_compare #\n  (parameter BANK_WIDTH               = 3,\n   parameter TCQ = 100,\n   parameter BURST_MODE               = \"8\",\n   parameter COL_WIDTH                = 12,\n   parameter DATA_BUF_ADDR_WIDTH      = 8,\n   parameter ECC                      = \"OFF\",\n   parameter RANK_WIDTH               = 2,\n   parameter RANKS                    = 4,\n   parameter ROW_WIDTH                = 16)\n  (\n  req_data_buf_addr_r, req_periodic_rd_r, req_size_r, rd_wr_r,\n  req_rank_r, req_bank_r, req_row_r, req_wr_r, req_priority_r,\n  rb_hit_busy_r, rb_hit_busy_ns, row_hit_r, maint_hit, col_addr,\n  req_ras, req_cas, row_cmd_wr, row_addr, rank_busy_r,\n  clk, idle_ns, idle_r, data_buf_addr, periodic_rd_insert, size, cmd,\n  sending_col, rank, periodic_rd_rank_r, bank, row, col, hi_priority,\n  maint_rank_r, maint_zq_r, maint_sre_r, auto_pre_r, rd_half_rmw, act_wait_r\n  );\n\n  input clk;\n\n  input idle_ns;\n  input idle_r;\n\n  input [DATA_BUF_ADDR_WIDTH-1:0]data_buf_addr;\n  output reg [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_r;\n  wire [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_ns =\n                                   idle_r\n                                     ? data_buf_addr\n                                     : req_data_buf_addr_r;\n  always @(posedge clk) req_data_buf_addr_r <= #TCQ req_data_buf_addr_ns;\n\n  input periodic_rd_insert;\n\n  reg req_periodic_rd_r_lcl;\n  wire req_periodic_rd_ns = idle_ns\n                             ? periodic_rd_insert\n                             : req_periodic_rd_r_lcl;\n  always @(posedge clk) req_periodic_rd_r_lcl <= #TCQ req_periodic_rd_ns;\n  output wire req_periodic_rd_r;\n  assign req_periodic_rd_r = req_periodic_rd_r_lcl;\n\n  input size;\n  wire req_size_r_lcl;\n  generate\n    if (BURST_MODE == \"4\") begin : burst_mode_4\n      assign req_size_r_lcl = 1'b0;\n    end\n    else\n      if (BURST_MODE == \"8\") begin : burst_mode_8\n        assign req_size_r_lcl = 1'b1;\n      end\n      else\n        if (BURST_MODE == \"OTF\") begin : burst_mode_otf\n          reg req_size;\n          wire req_size_ns = idle_ns\n                                 ? (periodic_rd_insert || size)\n                                 : req_size;\n          always @(posedge clk) req_size <= #TCQ req_size_ns;\n          assign req_size_r_lcl = req_size;\n        end\n  endgenerate\n  output wire req_size_r;\n  assign req_size_r = req_size_r_lcl;\n\n\n\n  input [2:0] cmd;\n  reg [2:0] req_cmd_r;\n  wire [2:0] req_cmd_ns = idle_ns\n                            ? (periodic_rd_insert ? 3'b001 : cmd)\n                            : req_cmd_r;\n   \n  always @(posedge clk) req_cmd_r <= #TCQ req_cmd_ns;\n\n`ifdef MC_SVA\n  rd_wr_only_wo_ecc: assert property\n    (@(posedge clk) ((ECC != \"OFF\") || idle_ns || ~|req_cmd_ns[2:1]));\n`endif\n  \n  input sending_col;\n  reg rd_wr_r_lcl;\n  wire rd_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || req_cmd_ns[0])\n                    : ~sending_col && rd_wr_r_lcl;\n  always @(posedge clk) rd_wr_r_lcl <= #TCQ rd_wr_ns;\n  output wire rd_wr_r;\n  assign rd_wr_r = rd_wr_r_lcl;\n\n  input [RANK_WIDTH-1:0] rank;\n  input [RANK_WIDTH-1:0] periodic_rd_rank_r;\n  reg [RANK_WIDTH-1:0] req_rank_r_lcl = {RANK_WIDTH{1'b0}};\n  reg [RANK_WIDTH-1:0] req_rank_ns = {RANK_WIDTH{1'b0}};\n  generate\n    if (RANKS != 1) begin\n      always @(idle_ns or periodic_rd_insert\n               or periodic_rd_rank_r or rank or req_rank_r_lcl) req_rank_ns = idle_ns\n                                  ? periodic_rd_insert\n                                      ? periodic_rd_rank_r\n                                      : rank\n                                  : req_rank_r_lcl;\n      always @(posedge clk) req_rank_r_lcl <= #TCQ req_rank_ns;\n    end\n  endgenerate\n  output wire [RANK_WIDTH-1:0] req_rank_r;\n  assign req_rank_r = req_rank_r_lcl;\n\n  input [BANK_WIDTH-1:0] bank;\n  reg [BANK_WIDTH-1:0] req_bank_r_lcl;\n  wire [BANK_WIDTH-1:0] req_bank_ns = idle_ns ? bank : req_bank_r_lcl;\n  always @(posedge clk) req_bank_r_lcl <= #TCQ req_bank_ns;\n  output wire[BANK_WIDTH-1:0] req_bank_r;\n  assign req_bank_r = req_bank_r_lcl;\n\n  input [ROW_WIDTH-1:0] row;\n  reg [ROW_WIDTH-1:0] req_row_r_lcl;\n  wire [ROW_WIDTH-1:0] req_row_ns = idle_ns ? row : req_row_r_lcl;\n  always @(posedge clk) req_row_r_lcl <= #TCQ req_row_ns;\n  output wire [ROW_WIDTH-1:0] req_row_r;\n  assign req_row_r = req_row_r_lcl;\n\n  input [COL_WIDTH-1:0] col;\n  reg [15:0] req_col_r = 16'b0;\n  wire [COL_WIDTH-1:0] req_col_ns = idle_ns ? col : req_col_r[COL_WIDTH-1:0];\n  always @(posedge clk) req_col_r[COL_WIDTH-1:0] <= #TCQ req_col_ns;\n\n  reg req_wr_r_lcl;\n  wire req_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || ~req_cmd_ns[0])\n                    : req_wr_r_lcl;\n  always @(posedge clk) req_wr_r_lcl <= #TCQ req_wr_ns;\n  output wire req_wr_r;\n  assign req_wr_r = req_wr_r_lcl;\n\n  input hi_priority;\n  output reg req_priority_r;\n  wire req_priority_ns = idle_ns ? hi_priority : req_priority_r;\n  always @(posedge clk) req_priority_r <= #TCQ req_priority_ns;\n\n  wire rank_hit = (req_rank_r_lcl == (periodic_rd_insert\n                                       ? periodic_rd_rank_r\n                                       : rank));\n  wire bank_hit = (req_bank_r_lcl == bank);\n  wire rank_bank_hit = rank_hit && bank_hit;\n\n  output reg rb_hit_busy_r;       wire  rb_hit_busy_ns_lcl;\n  assign rb_hit_busy_ns_lcl = rank_bank_hit && ~idle_ns;\n  output wire  rb_hit_busy_ns;\n  assign rb_hit_busy_ns = rb_hit_busy_ns_lcl;\n\n  wire row_hit_ns = (req_row_r_lcl == row);\n  output reg row_hit_r;\n\n  always @(posedge clk) rb_hit_busy_r <= #TCQ rb_hit_busy_ns_lcl;\n  always @(posedge clk) row_hit_r <= #TCQ row_hit_ns;\n\n  input [RANK_WIDTH-1:0] maint_rank_r;\n  input maint_zq_r;\n  input maint_sre_r;\n  output wire maint_hit;\n  assign maint_hit = (req_rank_r_lcl == maint_rank_r) || maint_zq_r || maint_sre_r;\n\ninput auto_pre_r;\n  input rd_half_rmw;\n  reg [15:0] col_addr_template = 16'b0;\n  always @(auto_pre_r or rd_half_rmw or req_col_r\n           or req_size_r_lcl) begin\n    col_addr_template = req_col_r;\n    col_addr_template[10] = auto_pre_r && ~rd_half_rmw;\n    col_addr_template[11] = req_col_r[10];\n    col_addr_template[12] = req_size_r_lcl;\n    col_addr_template[13] = req_col_r[11];\n  end\n  output wire [ROW_WIDTH-1:0] col_addr;\n  assign col_addr = col_addr_template[ROW_WIDTH-1:0];\n\n  output wire req_ras;\n  output wire req_cas;\n  output wire row_cmd_wr;\n  input act_wait_r;\n  assign req_ras = 1'b0;\n  assign req_cas = 1'b1;\n  assign row_cmd_wr = act_wait_r;\n\n  output reg [ROW_WIDTH-1:0] row_addr;\n  always @(act_wait_r or req_row_r_lcl) begin\n    row_addr = req_row_r_lcl;\nif (~act_wait_r) row_addr[10] = 1'b0;\n  end\n\nlocalparam ONE = 1;\n  output reg [RANKS-1:0] rank_busy_r;\n  wire [RANKS-1:0] rank_busy_ns = {RANKS{~idle_ns}} & (ONE[RANKS-1:0] << req_rank_ns);\n  always @(posedge clk) rank_busy_r <= #TCQ rank_busy_ns;\n\nendmodule ",
        "module_name": "mig_7series_v2_3_bank_compare #",
        "module_hash": "04835df85267b5297edcfe7852e5788d",
        "dataset_index": 25860
      },
      "mux_256to1 #_9d397678": {
        "rtl_code": "\nmodule mux_256to1 #(parameter DATA_WIDTH = 3) (\n    input [DATA_WIDTH*256-1:0] data_in,\n    input [8:0] sel,\n    output reg [DATA_WIDTH-1:0] out\n);\n\nalways @(*) begin\n    out <= data_in[(sel+1)*DATA_WIDTH-1 : sel*DATA_WIDTH];\nend\n\nendmodule",
        "module_name": "mux_256to1 #",
        "module_hash": "9d397678ab7d1ee43818b37bbff42458",
        "dataset_index": 5583
      },
      "Control_Unit_6931141a": {
        "rtl_code": "\nmodule Control_Unit(\n    output reg Load_NPC,\n    output reg Load_PC,\n    output reg Load_IR,\n    output reg Load_RegA,\n    output reg Load_RegB,\n    output reg Load_Imm,\n    output reg WT_Reg,\n\t output reg [3 : 0] Addr_Reg,\n    output reg [2 : 0] Extend,\n    output reg [7 : 0] Send_Reg,\n    output reg Load_LMD,\n    output reg Cond_Kind,\n\t output reg [1 : 0] Jump_Kind,\n    output reg Sel_Mux1,\n    output reg Sel_Mux2,\n    output reg [1 : 0] Sel_Mux4,\n    output reg [4 : 0] Cal_ALU,\n    output reg Write,\n    output reg Load_ALU,\n    input clk,\n    input [15 : 0] IR_in,\n    input rst,\n\t output reg [2 : 0] state,\n\t output reg [5 : 0] cur_ins\n    );\n\t \n\treg [2 : 0] next_state;\n\n\tparameter\n\t\tADDIU = 1,\n\t\tADDIU3 = 2,\n\t\tADDSP3 = 3,\n\t\tADDSP = 4,\n\t\tADDU = 5,\n\t\tAND = 6,\n\t\tB = 7,\n\t\tBEQZ = 8,\n\t\tBNEZ = 9,\n\t\tBTEQZ = 10,\n\t\tBTNEZ = 11,\n\t\tCMP = 12,\n\t\tCMPI = 13,\n\t\tINT = 14,\n\t\tJALR = 15,\n\t\tJR = 16,\n\t\tJRRA = 17,\n\t\tLI = 18,\n\t\tLW = 19,\n\t\tLW_SP = 20,\n\t\tMFIH = 21,\n\t\tMFPC = 22,\n\t\tMOVE = 23,\n\t\tMTIH = 24,\n\t\tMTSP = 25,\n\t\tNEG = 26,\n\t\tNOT = 27,\n\t\tNOP = 28,\n\t\tOR = 29,\n\t\tSLL = 30,\n\t\tSLLV = 31,\n\t\tSLT = 32,\n\t\tSLTI = 33,\n\t\tSLTU = 34,\n\t\tSLTUI = 35,\n\t\tSRA = 36,\n\t\tSRAV = 37,\n\t\tSRL = 38,\n\t\tSRLV = 39,\n\t\tSUBU = 40,\n\t\tSW = 41,\n\t\tSW_RS = 42,\n\t\tSW_SP = 43,\n\t\tXOR = 44,\n\t\tHLT = 45;\n\n\tparameter\n\t\t_Idle = 0,\n\t\t_IFetch = 1,\n\t\t_IDec = 2,\n\t\t_Exec = 3,\n\t\t_Mem = 4,\n\t\t_WB = 5,\n\t\t_Halt = 6;\n\t\t\n\talways @(IR_in or rst)\t\tbegin\n\t\tif (rst == 0)\n\t\tbegin\n\t\t\tcur_ins = 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tcase (IR_in[15 : 11])\n\t\t\t\t5'b01001:\tcur_ins = ADDIU;\n\t\t\t\t5'b01000:\tcur_ins = ADDIU3;\n\t\t\t\t5'b00000:\tcur_ins = ADDSP3;\n\t\t\t\t5'b00010:\tcur_ins = B;\n\t\t\t\t5'b00100:\tcur_ins = BEQZ;\n\t\t\t\t5'b00101:\tcur_ins = BNEZ;\n\t\t\t\t5'b01110:\tcur_ins = CMPI;\n\t\t\t\t5'b11111:\tcur_ins = INT;\n\t\t\t\t5'b01101:\tcur_ins = LI;\n\t\t\t\t5'b10011:\tcur_ins = LW;\n\t\t\t\t5'b10010:\tcur_ins = LW_SP;\n\t\t\t\t5'b01111:\tcur_ins = MOVE;\n\t\t\t\t5'b00001:\tcur_ins = NOP;\n\t\t\t\t5'b01010:\tcur_ins = SLTI;\n\t\t\t\t5'b01011:\tcur_ins = SLTUI;\n\t\t\t\t5'b11011:\tcur_ins = SW;\n\t\t\t\t5'b11010:\tcur_ins = SW_SP;\n\t\t\t\t5'b10000:\tcur_ins = HLT;\n\t\t\t\t5'b00110:\tcase (IR_in[1 : 0])\n\t\t\t\t\t\t\t\t\t2'b00:\tcur_ins = SLL;\n\t\t\t\t\t\t\t\t\t2'b11:\tcur_ins = SRA;\n\t\t\t\t\t\t\t\t\t2'b10:\tcur_ins = SRL;\n\t\t\t\t\t\t\t\tendcase\n\t\t\t\t5'b01100:\tcase (IR_in[10 : 8])\n\t\t\t\t\t\t\t\t\t3'b011:\tcur_ins = ADDSP;\n\t\t\t\t\t\t\t\t\t3'b000:\tcur_ins = BTEQZ;\n\t\t\t\t\t\t\t\t\t3'b001:\tcur_ins = BTNEZ;\n\t\t\t\t\t\t\t\t\t3'b100:\tcur_ins = MTSP;\n\t\t\t\t\t\t\t\t\t3'b010:\tcur_ins = SW_RS;\n\t\t\t\t\t\t\t\tendcase\n\t\t\t\t5'b11100:\tcase (IR_in[1 : 0])\n\t\t\t\t\t\t\t\t\t2'b01:\tcur_ins = ADDU;\n\t\t\t\t\t\t\t\t\t2'b11:\tcur_ins = SUBU;\n\t\t\t\t\t\t\t\tendcase\n\t\t\t\t5'b11101:\tcase (IR_in[4 : 0])\n\t\t\t\t\t\t\t\t\t5'b01100:\tcur_ins = AND;\n\t\t\t\t\t\t\t\t\t5'b01010:\tcur_ins = CMP;\n\t\t\t\t\t\t\t\t\t5'b01011:\tcur_ins = NEG;\n\t\t\t\t\t\t\t\t\t5'b01111:\tcur_ins = NOT;\n\t\t\t\t\t\t\t\t\t5'b01101:\tcur_ins = OR;\n\t\t\t\t\t\t\t\t\t5'b00100:\tcur_ins = SLLV;\n\t\t\t\t\t\t\t\t\t5'b00010:\tcur_ins = SLT;\n\t\t\t\t\t\t\t\t\t5'b00011:\tcur_ins = SLTU;\n\t\t\t\t\t\t\t\t\t5'b00111:\tcur_ins = SRAV;\n\t\t\t\t\t\t\t\t\t5'b00110:\tcur_ins = SRLV;\n\t\t\t\t\t\t\t\t\t5'b01110:\tcur_ins = XOR;\n\t\t\t\t\t\t\t\t\t5'b00000:\tcase (IR_in[7 : 5])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t3'b110:\tcur_ins = JALR;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t3'b000:\tcur_ins = JR;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t3'b001:\tcur_ins = JRRA;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t3'b010:\tcur_ins = MFPC;\n\t\t\t\t\t\t\t\t\t\t\t\t\tendcase\n\t\t\t\t\t\t\t\tendcase\n\t\t\t\t5'b11110:\tcase (IR_in[7 : 0])\n\t\t\t\t\t\t\t\t\t8'b00000000:\tcur_ins = MFIH;\n\t\t\t\t\t\t\t\t\t8'b00000001:\tcur_ins = MTIH;\n\t\t\t\t\t\t\t\tendcase\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(posedge clk or negedge rst)\n\tbegin\n\t\tif (rst == 0)\n\t\tbegin\n\t\t\tstate <= _Idle;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\talways @(state)\n\tbegin\n\t\tcase (state)\n\t\t\t_Idle:\n\t\t\t\tbegin\n\t\t\t\t\tLoad_NPC = 0;\n\t\t\t\t\tLoad_PC = 0;\n\t\t\t\t\tLoad_IR = 0;\n\t\t\t\t\tLoad_RegA = 0;\n\t\t\t\t\tLoad_RegB = 0;\n\t\t\t\t\tLoad_Imm = 0;\n\t\t\t\t\tWT_Reg = 0;\n\t\t\t\t\tAddr_Reg = 4'b0;\n\t\t\t\t\tExtend = 3'b0;\n\t\t\t\t\tSend_Reg = 8'b0;\n\t\t\t\t\tLoad_LMD = 0;\n\t\t\t\t\tCond_Kind = 0;\n\t\t\t\t\tJump_Kind = 2'b0;\n\t\t\t\t\tSel_Mux1 = 0;\n\t\t\t\t\tSel_Mux2 = 0;\n\t\t\t\t\tSel_Mux4 = 2'b0;\n\t\t\t\t\tCal_ALU = 5'b0;\n\t\t\t\t\tWrite = 0;\n\t\t\t\t\tLoad_ALU = 0;\n\t\t\t\t\tnext_state = _IFetch;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t_IFetch:\n\t\t\t\tbegin\n\t\t\t\t\tWrite = 0;\n\t\t\t\t\tLoad_LMD = 0;\n\t\t\t\t\tWT_Reg = 0;\n\t\t\t\t\tLoad_PC = 0;\n\t\t\t\t\t\n\t\t\t\t\tnext_state = _IDec;\n\t\t\t\t\tLoad_IR = 1;\n\t\t\t\t\tLoad_NPC = 1;\n\t\t\t\tend\n\t\t\t\n\t\t\t_IDec:\n\t\t\t\tbegin\n\t\t\t\t\tLoad_IR = 0;\n\t\t\t\t\tLoad_NPC = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (cur_ins == HLT)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state = _Halt;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tnext_state = _Exec;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tADDIU,\n\t\t\t\t\t\tADDIU3,\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tCMPI,\n\t\t\t\t\t\tJALR,\n\t\t\t\t\t\tJR,\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tMTIH,\n\t\t\t\t\t\tSLTI,\n\t\t\t\t\t\tSLTUI:\tSend_Reg = {1'b0, IR_in[10 : 8], 4'b0};\n\t\t\t\t\t\t\n\t\t\t\t\t\tMOVE,\n\t\t\t\t\t\tMTSP,\n\t\t\t\t\t\tNOT,\n\t\t\t\t\t\tSLL,\n\t\t\t\t\t\tSRA,\n\t\t\t\t\t\tSRL:\t\tSend_Reg = {1'b0, IR_in[7 : 5], 4'b0};\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tADDSP3,\n\t\t\t\t\t\tADDSP,\n\t\t\t\t\t\tLW_SP:\tSend_Reg = 8'b11110000;\n\t\t\t\t\t\t\n\t\t\t\t\t\tADDU,\n\t\t\t\t\t\tAND,\n\t\t\t\t\t\tCMP,\n\t\t\t\t\t\tOR,\n\t\t\t\t\t\tSLLV,\n\t\t\t\t\t\tSLT,\n\t\t\t\t\t\tSLTU,\n\t\t\t\t\t\tSRAV,\n\t\t\t\t\t\tSRLV,\n\t\t\t\t\t\tSUBU,\n\t\t\t\t\t\tSW,\n\t\t\t\t\t\tXOR:\t\tSend_Reg = {1'b0, IR_in[10 : 8], 1'b0, IR_in[7 : 5]};\n\t\t\t\t\t\t\n\t\t\t\t\t\tB,\n\t\t\t\t\t\tINT,\n\t\t\t\t\t\tLI,\n\t\t\t\t\t\tMFPC,\n\t\t\t\t\t\tNOP:\t\tSend_Reg = 8'b00000000;\n\t\t\t\t\t\t\n\t\t\t\t\t\tJRRA:\t\tSend_Reg = 8'b00100000;\n\t\t\t\t\t\t\n\t\t\t\t\t\tMFIH:\t\tSend_Reg = 8'b11010000;\n\t\t\t\t\t\t\n\t\t\t\t\t\tNEG:\t\tSend_Reg = {4'b0000, 1'b0, IR_in[7 : 5]};\n\t\t\t\t\t\t\n\t\t\t\t\t\tSW_RS:\tSend_Reg = 8'b11110010;\n\t\t\t\t\t\t\n\t\t\t\t\t\tSW_SP:\tSend_Reg = {4'b1111, 1'b0, IR_in[7 : 5]};\n\t\t\t\t\t\t\n\t\t\t\t\t\tBTEQZ,\n\t\t\t\t\t\tBTNEZ:\tSend_Reg = 8'b11100000;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tADDIU,\n\t\t\t\t\t\tADDSP3,\n\t\t\t\t\t\tADDSP,\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tBTEQZ,\n\t\t\t\t\t\tBTNEZ,\n\t\t\t\t\t\tCMPI,\n\t\t\t\t\t\tLW_SP,\n\t\t\t\t\t\tSLTI,\n\t\t\t\t\t\tSLTUI,\n\t\t\t\t\t\tSW_RS,\n\t\t\t\t\t\tSW_SP:\tExtend = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tADDIU3:\tExtend = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tB:\t\t\tExtend = 2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tINT:\t\tExtend = 3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tLI:\t\tExtend = 4;\n\t\t\t\t\t\t\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tSW:\t\tExtend = 5;\n\t\t\t\t\t\t\n\t\t\t\t\t\tSLL,\n\t\t\t\t\t\tSRA,\n\t\t\t\t\t\tSRL:\t\tExtend = 6;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tADDIU,\n\t\t\t\t\t\tADDIU3,\n\t\t\t\t\t\tADDSP3,\n\t\t\t\t\t\tADDSP,\n\t\t\t\t\t\tADDU,\n\t\t\t\t\t\tAND,\n\t\t\t\t\t\tCMP,\n\t\t\t\t\t\tCMPI,\n\t\t\t\t\t\tJALR,\n\t\t\t\t\t\tJR,\n\t\t\t\t\t\tJRRA,\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tLW_SP,\n\t\t\t\t\t\tMFIH,\n\t\t\t\t\t\tMOVE,\n\t\t\t\t\t\tMTIH,\n\t\t\t\t\t\tMTSP,\n\t\t\t\t\t\tNEG,\n\t\t\t\t\t\tNOT,\n\t\t\t\t\t\tOR,\n\t\t\t\t\t\tSLL,\n\t\t\t\t\t\tSLLV,\n\t\t\t\t\t\tSLT,\n\t\t\t\t\t\tSLTI,\n\t\t\t\t\t\tSLTU,\n\t\t\t\t\t\tSLTUI,\n\t\t\t\t\t\tSRA,\n\t\t\t\t\t\tSRAV,\n\t\t\t\t\t\tSRL,\n\t\t\t\t\t\tSRLV,\n\t\t\t\t\t\tSUBU,\n\t\t\t\t\t\tSW,\n\t\t\t\t\t\tSW_RS,\n\t\t\t\t\t\tSW_SP,\n\t\t\t\t\t\tXOR:\t\tSel_Mux1 = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tB,\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tBTEQZ,\n\t\t\t\t\t\tBTNEZ,\n\t\t\t\t\t\tMFPC:\t\tSel_Mux1 = 1;\n\t\t\t\t\tendcase\n\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tADDU,\n\t\t\t\t\t\tAND,\n\t\t\t\t\t\tCMP,\n\t\t\t\t\t\tNEG,\n\t\t\t\t\t\tOR,\n\t\t\t\t\t\tSLLV,\n\t\t\t\t\t\tSLT,\n\t\t\t\t\t\tSLTU,\n\t\t\t\t\t\tSRAV,\n\t\t\t\t\t\tSRLV,\n\t\t\t\t\t\tSUBU,\n\t\t\t\t\t\tXOR:\t\tSel_Mux2 = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tADDIU,\n\t\t\t\t\t\tADDIU3,\n\t\t\t\t\t\tADDSP3,\n\t\t\t\t\t\tADDSP,\n\t\t\t\t\t\tB,\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tBTEQZ,\n\t\t\t\t\t\tBTNEZ,\n\t\t\t\t\t\tCMPI,\n\t\t\t\t\t\tINT,\n\t\t\t\t\t\tLI,\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tLW_SP,\n\t\t\t\t\t\tSLL,\n\t\t\t\t\t\tSLTI,\n\t\t\t\t\t\tSLTUI,\n\t\t\t\t\t\tSRA,\n\t\t\t\t\t\tSRL,\n\t\t\t\t\t\tSW,\n\t\t\t\t\t\tSW_RS,\n\t\t\t\t\t\tSW_SP:\tSel_Mux2 = 1;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tJALR,\n\t\t\t\t\t\tJR,\n\t\t\t\t\t\tJRRA,\n\t\t\t\t\t\tMFIH,\n\t\t\t\t\t\tMFPC,\n\t\t\t\t\t\tMOVE,\n\t\t\t\t\t\tMTIH,\n\t\t\t\t\t\tMTSP:\t\tCal_ALU = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tINT,\n\t\t\t\t\t\tLI:\t\tCal_ALU = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tADDIU,\n\t\t\t\t\t\tADDIU3,\n\t\t\t\t\t\tADDSP3,\n\t\t\t\t\t\tADDSP,\n\t\t\t\t\t\tADDU,\n\t\t\t\t\t\tB,\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tBTEQZ,\n\t\t\t\t\t\tBTNEZ,\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tLW_SP,\n\t\t\t\t\t\tSW,\n\t\t\t\t\t\tSW_RS,\n\t\t\t\t\t\tSW_SP:\tCal_ALU = 2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tNEG,\n\t\t\t\t\t\tSUBU:\t\tCal_ALU = 3;\n\n\t\t\t\t\t\tAND:\t\tCal_ALU = 4;\n\n\t\t\t\t\t\tOR:\t\tCal_ALU = 5;\n\n\t\t\t\t\t\tNOT:\t\tCal_ALU = 6;\n\n\t\t\t\t\t\tXOR:\t\tCal_ALU = 7;\n\n\t\t\t\t\t\tCMP,\n\t\t\t\t\t\tCMPI:\t\tCal_ALU = 8;\n\n\t\t\t\t\t\tSLLV:\t\tCal_ALU = 9;\n\n\t\t\t\t\t\tSRLV:\t\tCal_ALU = 10;\n\n\t\t\t\t\t\tSLL:\t\tCal_ALU = 11;\n\n\t\t\t\t\t\tSLTU,\n\t\t\t\t\t\tSLTUI:\tCal_ALU = 12;\n\n\t\t\t\t\t\tSRAV:\t\tCal_ALU = 13;\n\n\t\t\t\t\t\tSRL:\t\tCal_ALU = 14;\n\n\t\t\t\t\t\tSRA:\t\tCal_ALU = 15;\n\n\t\t\t\t\t\tSLT,\n\t\t\t\t\t\tSLTI:\t\tCal_ALU = 16;\n\t\t\t\t\tendcase\n\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBTEQZ:\tCond_Kind = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tBTNEZ:\tCond_Kind = 1;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tBTEQZ,\n\t\t\t\t\t\tBTNEZ:\tJump_Kind = 2'b10;\n\t\t\t\t\t\t\n\t\t\t\t\t\tB,\n\t\t\t\t\t\tINT,\n\t\t\t\t\t\tJALR,\n\t\t\t\t\t\tJR,\n\t\t\t\t\t\tJRRA:\t\tJump_Kind = 2'b11;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdefault:\tJump_Kind = 2'b00;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tLoad_RegA = 1;\n\t\t\t\t\tLoad_RegB = 1;\n\t\t\t\t\tLoad_Imm = 1;\n\t\t\t\tend\n\t\t\t\n\t\t\t_Exec:\n\t\t\t\tbegin\n\t\t\t\t\tLoad_RegA = 0;\n\t\t\t\t\tLoad_RegB = 0;\n\t\t\t\t\tLoad_Imm = 0;\n\t\t\t\t\t\n\t\t\t\t\tnext_state = _Mem;\n\t\t\t\t\t\n\t\t\t\t\tLoad_ALU = 1;\n\t\t\t\tend\n\t\t\t\n\t\t\t_Mem:\n\t\t\t\tbegin\n\t\t\t\t\tLoad_ALU = 0;\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tB,\n\t\t\t\t\t\tBEQZ,\n\t\t\t\t\t\tBNEZ,\n\t\t\t\t\t\tBTEQZ,\n\t\t\t\t\t\tBTNEZ,\n\t\t\t\t\t\tSW,\n\t\t\t\t\t\tSW_RS,\n\t\t\t\t\t\tSW_SP,\n\t\t\t\t\t\tJR,\n\t\t\t\t\t\tJRRA:\tnext_state = _IFetch;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdefault:\tnext_state = _WB;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tSW,\n\t\t\t\t\t\tSW_RS,\n\t\t\t\t\t\tSW_SP:\tWrite = 1;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tLW_SP:\tLoad_LMD = 1;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tLoad_PC = 1;\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tLW_SP:\tSel_Mux4 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tINT,\n\t\t\t\t\t\tJALR:\t\tSel_Mux4 = 2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdefault:\tSel_Mux4 = 0;\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tADDIU,\n\t\t\t\t\t\tADDSP3,\n\t\t\t\t\t\tAND,\n\t\t\t\t\t\tLI,\n\t\t\t\t\t\tLW_SP,\n\t\t\t\t\t\tMFIH,\n\t\t\t\t\t\tMFPC,\n\t\t\t\t\t\tMOVE,\n\t\t\t\t\t\tNEG,\n\t\t\t\t\t\tNOT,\n\t\t\t\t\t\tOR,\n\t\t\t\t\t\tSLL,\n\t\t\t\t\t\tSRA,\n\t\t\t\t\t\tSRL,\n\t\t\t\t\t\tXOR:\t\tAddr_Reg = {1'b0, IR_in[10 : 8]};\n\n\t\t\t\t\t\tADDIU3,\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tSLLV,\n\t\t\t\t\t\tSRAV,\n\t\t\t\t\t\tSRLV:\t\tAddr_Reg = {1'b0, IR_in[7 : 5]};\n\n\t\t\t\t\t\tADDSP,\n\t\t\t\t\t\tMTSP:\t\tAddr_Reg = 4'b1111;\n\n\t\t\t\t\t\tADDU,\n\t\t\t\t\t\tSUBU:\t\tAddr_Reg = {1'b0, IR_in[4 : 2]};\n\n\t\t\t\t\t\tCMP,\n\t\t\t\t\t\tCMPI,\n\t\t\t\t\t\tSLT,\n\t\t\t\t\t\tSLTI,\n\t\t\t\t\t\tSLTU,\n\t\t\t\t\t\tSLTUI:\tAddr_Reg = 4'b1110;\n\n\t\t\t\t\t\tINT,\n\t\t\t\t\t\tJALR:\t\tAddr_Reg = 4'b0010;\n\n\t\t\t\t\t\tMTIH:\t\tAddr_Reg = 4'b1101;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\n\t\t\t_WB:\t\tbegin\n\t\t\t\t\tWrite = 0;\n\t\t\t\t\tLoad_LMD = 0;\n\t\t\t\t\tLoad_PC = 0;\n\t\t\t\t\t\n\t\t\t\t\tnext_state = _IFetch;\n\t\t\t\t\t\n\t\t\t\t\tcase (cur_ins)\n\t\t\t\t\t\tADDIU,\n\t\t\t\t\t\tADDSP3,\n\t\t\t\t\t\tAND,\n\t\t\t\t\t\tLI,\n\t\t\t\t\t\tLW_SP,\n\t\t\t\t\t\tMFIH,\n\t\t\t\t\t\tMFPC,\n\t\t\t\t\t\tMOVE,\n\t\t\t\t\t\tNEG,\n\t\t\t\t\t\tNOT,\n\t\t\t\t\t\tOR,\n\t\t\t\t\t\tSLL,\n\t\t\t\t\t\tSRA,\n\t\t\t\t\t\tSRL,\n\t\t\t\t\t\tXOR,\n\t\t\t\t\t\tADDIU3,\n\t\t\t\t\t\tLW,\n\t\t\t\t\t\tSLLV,\n\t\t\t\t\t\tSRAV,\n\t\t\t\t\t\tSRLV,\n\t\t\t\t\t\tADDSP,\n\t\t\t\t\t\tMTSP,\n\t\t\t\t\t\tADDU,\n\t\t\t\t\t\tSUBU,\n\t\t\t\t\t\tCMP,\n\t\t\t\t\t\tCMPI,\n\t\t\t\t\t\tSLT,\n\t\t\t\t\t\tSLTI,\n\t\t\t\t\t\tSLTU,\n\t\t\t\t\t\tSLTUI,\n\t\t\t\t\t\tINT,\n\t\t\t\t\t\tJALR,\n\t\t\t\t\t\tMTIH:\t\tWT_Reg = 1;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\t\n\t\t\t_Halt:\n\t\t\t\tbegin\n\t\t\t\t\tnext_state = _Halt;\n\t\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n",
        "module_name": "Control_Unit",
        "module_hash": "6931141aae580038cb5a1cd523f09c80",
        "dataset_index": 22130
      },
      "sky130_fd_sc_ls__nand2_5e5cb2d1": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__nand2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A           );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__nand2",
        "module_hash": "5e5cb2d12b5684b37db29db79909805e",
        "dataset_index": 23067
      },
      "Distributed_RAM_d7c3fd4e": {
        "rtl_code": "\nmodule Distributed_RAM(\n\t Clock_in,\n\t Write_Enable_in,\n\t Address_in,\n\t Data_in,\n\t Data_out\n    );\n\t \nparameter AddressWidth = 8;\nparameter DataWidth = 8;\nparameter Depth = 256;\t \n\t \ninput\tClock_in;\ninput\tWrite_Enable_in;\ninput [AddressWidth-1:0]Address_in;\ninput [DataWidth-1:0]Data_in;\noutput [DataWidth-1:0]Data_out;\n\n\nreg [DataWidth-1:0] RAM [Depth-1:0];\n\ninteger i;\ninitial begin\n    for (i = 0; i < Depth; i = i + 1) begin\n        RAM[i] = {DataWidth{1'b0}};\n    end\nend\n\nalways @ (posedge Clock_in) begin\n\tif (Write_Enable_in) begin\n\t\tRAM[Address_in]<=Data_in;\n\tend\nend\n\nassign Data_out = RAM[Address_in];\n\nendmodule\n",
        "module_name": "Distributed_RAM",
        "module_hash": "d7c3fd4e5b572d29bb7838c256a6d561",
        "dataset_index": 23274
      },
      "controlunit_856e696e": {
        "rtl_code": "module controlunit(input [5:0] imemout, output reg brnch, output reg memorywrite, output reg memoryread, output reg alusrc, output reg regw, output reg regdst, output reg aluop, output reg memtoreg);\n\nalways @ ( imemout )\nbegin\n\tif(imemout == 6'b000000)\n\tbegin\n\t\tbrnch = 1'b0;\n\t\tmemorywrite = 1'b0;\n\t\tmemoryread = 1'b0;\n\t\talusrc = 1'b0;\n\t\tregw = 1'b1;\n\t\tregdst = 1'b1;\n\t\taluop = 1'b1;\n\t\tmemtoreg = 1'b1;\n\tend\n\telse if(imemout == 6'b100011)\n\tbegin\n\t\tbrnch = 1'b0;\n\t\tmemorywrite = 1'b0;\n\t\tmemoryread = 1'b1;\n\t\talusrc = 1'b1;\n\t\tregw = 1'b1;\n\t\tregdst = 1'b0;\n\t\taluop = 1'b0;\n\t\tmemtoreg = 1'b0;\n\tend\n\telse if(imemout == 6'b101011)\n\tbegin\n\t\tbrnch = 1'b0;\n\t\tmemorywrite = 1'b1;\n\t\tmemoryread = 1'b0;\n\t\talusrc = 1'b1;\n\t\tregw = 1'b0;\n\t\tregdst = 1'b0;\n\t\taluop = 1'b0;\n\t\tmemtoreg = 1'b0;\n\tend\n\telse if(imemout == 6'b000100)\n\tbegin\n\t\tbrnch = 1'b1;\n\t\tmemorywrite = 1'b0;\n\t\tmemoryread = 1'b0;\n\t\talusrc = 1'b0;\n\t\tregw = 1'b0;\n\t\tregdst = 1'b0;\n\t\taluop = 1'b0;\n\t\tmemtoreg = 1'b0;\n\tend\n\telse\n\tbegin\n\t\tbrnch = 1'b0;\n\t\tmemorywrite = 1'b0;\n\t\tmemoryread = 1'b0;\n\t\talusrc = 1'b0;\n\t\tregw = 1'b0;\n\t\tregdst = 1'b0;\n\t\taluop = 1'b0;\n\t\tmemtoreg = 1'b0;\n\tend\nend\n\nendmodule",
        "module_name": "controlunit",
        "module_hash": "856e696e29f43c9f1cb7408aee9dcb43",
        "dataset_index": 7653
      },
      "sub_mult_32bit_46be6fd5": {
        "rtl_code": "module sub_mult_32bit (\n    input [31:0] A,\n    input [31:0] B,\n    output reg [31:0] D,\n    output reg [63:0] P\n);\n\nreg [31:0] B_inv;\nreg [63:0] P_temp;\nwire [31:0] D_temp;\ninteger i;\n\nassign D_temp = A + (~B) + 1;\n\nalways @ (A or B) begin\n    B_inv = ~B;\nend\n\nalways @* begin\n    P_temp = 0;\n    for (i = 0; i < 32; i = i + 1) begin\n        if (B[i] == 1) begin\n            P_temp = P_temp + (A << i);\n        end\n    end\n    P = P_temp;\nend\n\nalways @* begin\n    D = D_temp;\nend\n\nendmodule",
        "module_name": "sub_mult_32bit",
        "module_hash": "46be6fd557929671ec689ccb1ceb8852",
        "dataset_index": 13021
      },
      "top__0c87ca86": {
        "rtl_code": "module top_module (\n    input clk,\n    input rst,\n    input up_down,\n    input [7:0] data_in,\n    output [7:0] output_sum\n);\n\n    wire [7:0] shift_reg_out;\n    wire [3:0] counter_out;\n    wire [7:0] shift_reg_counter_sum;\n\n    shift_register shift_reg (\n        .clk(clk),\n        .rst(rst),\n        .load(data_in),\n        .shift_en(!up_down),\n        .data_out(shift_reg_out)\n    );\n\n    up_down_counter counter (\n        .clk(clk),\n        .rst(rst),\n        .up_down(up_down),\n        .data_out(counter_out)\n    );\n\n    assign shift_reg_counter_sum = shift_reg_out + counter_out;\n\n    assign output_sum = shift_reg_counter_sum;\n\nendmodule\n\nmodule shift_register (\n    input clk,\n    input rst,\n    input [7:0] load,\n    input shift_en,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 8'b0;\n        end else if (shift_en) begin\n            data_out <= {data_out[6:0], 1'b0};\n        end else begin\n            data_out <= load;\n        end\n    end\n\nendmodule\n\nmodule up_down_counter (\n    input clk,\n    input rst,\n    input up_down,\n    output reg [3:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 4'b0;\n        end else if (up_down) begin\n            data_out <= data_out + 1;\n        end else begin\n            data_out <= data_out - 1;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "0c87ca863c855158dc66964c11dd8994",
        "dataset_index": 15477
      },
      "nfc_transmitter_634ad796": {
        "rtl_code": "module nfc_transmitter (\n  input clk,\n  input data_in,\n  output reg en,\n  output reg carrier_out\n);\n\nreg [31:0] counter;\nreg carrier_gen;\n\nalways @(posedge clk) begin\n  counter <= counter + 1;\n  carrier_gen <= ~carrier_gen;\n  en <= data_in;\n  if (en) begin\n    carrier_out <= carrier_gen;\n  end else begin\n    carrier_out <= 1'b0;\n  end\nend\n\nendmodule\n\nmodule nfc_receiver (\n  input clk,\n  input carrier_in,\n  output reg data_out,\n  output reg valid_out\n);\n\nreg [31:0] counter;\nreg carrier_gen;\nreg prev_carrier_in;\n\nalways @(posedge clk) begin\n  counter <= counter + 1;\n  carrier_gen <= ~carrier_gen;\n  prev_carrier_in <= carrier_in;\n\n  if (carrier_in != prev_carrier_in) begin\n    valid_out <= 1'b1;\n    data_out <= carrier_gen;\n  end else begin\n    valid_out <= 1'b0;\n    data_out <= 1'b0;\n  end\nend\n\nendmodule",
        "module_name": "nfc_transmitter",
        "module_hash": "634ad7961fa08c0ba223603aefde7dc4",
        "dataset_index": 4759
      },
      "ctrl_module_8df9f402": {
        "rtl_code": "\nmodule ctrl_module(\n  input [3:0] in,\n  input [1:0] ctrl,\n  output reg [3:0] out\n);\n\n  reg [2:0] index;\n  always @* begin\n    index = {ctrl, in[1:0]};\n  end\n\n  // Implement the output using a case statement\n  always @* begin\n    case (index)\n      3'b000: out = 4'b0000;\n      3'b001: out = 4'b1010;\n      3'b010: out = 4'b0101;\n      3'b011: out = 4'b1111;\n      3'b100: out = 4'b1110;\n      3'b101: out = 4'b0101;\n      3'b110: out = 4'b1010;\n      3'b111: out = 4'b0000;\n    endcase\n  end\n\nendmodule",
        "module_name": "ctrl_module",
        "module_hash": "8df9f402fe82c0dba85cfcb0668c72e4",
        "dataset_index": 3680
      },
      "fifo_85c9187b": {
        "rtl_code": "module fifo\n(\n\tinput wire          clk,\n\tinput wire          reset,\n\tinput wire          rd,\n\tinput wire          wr,\n\tinput wire [B-1:0]  w_data,\n\toutput wire         empty,\n\toutput wire         full,\n\toutput wire [B-1:0] r_data\n);\n\tparameter B = 8; parameter W = 4; reg [B-1:0]  array_reg[2**W-1:0];\n\treg [W-1:0]  w_ptr_reg, w_ptr_next;\n\treg [W-1:0]  r_ptr_reg, r_ptr_next;\n\treg          full_reg, empty_reg, full_next, empty_next;\n\twire [W-1:0] w_ptr_succ, r_ptr_succ;\n\twire [1:0]   wr_op;\n\twire         wr_en;\n\tinteger      i;\n\t\n\talways @ (posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tfor (i = 0; i <= 2**W-1; i = i+1)\n\t\t\t\tarray_reg[i] <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (wr_en)\n\t\t\t\tarray_reg[w_ptr_reg] <= w_data;\n\t\tend\n\tend\n\t\n\tassign r_data = array_reg[r_ptr_reg];\n\tassign wr_en = wr && !full_reg;\n\t\n\talways @ (posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tw_ptr_reg <= 0;\n\t\t\tr_ptr_reg <= 0;\n\t\t\tfull_reg <= 0;\n\t\t\tempty_reg <= 1;\n\t\tend\n\t\telse begin\n\t\t\tw_ptr_reg <= w_ptr_next;\n\t\t\tr_ptr_reg <= r_ptr_next;\n\t\t\tfull_reg <= full_next;\n\t\t\tempty_reg <= empty_next;\n\t\tend\n\tend\n\t\n\tassign w_ptr_succ = w_ptr_reg + 1;\n\tassign r_ptr_succ = r_ptr_reg + 1;\n\t\n\tassign wr_op = {wr, rd};\n\talways @ (w_ptr_reg, w_ptr_succ, r_ptr_reg, r_ptr_succ, wr_op, empty_reg, full_reg) begin\n\t\tw_ptr_next <= w_ptr_reg;\n\t\tr_ptr_next <= r_ptr_reg;\n\t\tfull_next <= full_reg;\n\t\tempty_next <= empty_reg;\n\t\t\t\n\t\tcase (wr_op)\n\t\t\t2'b00: begin\n\t\t\tend\n\n\t\t\t2'b01: begin\n\t\t\t\tif (!empty_reg) begin\n\t\t\t\t\tr_ptr_next <= r_ptr_succ;\n\t\t\t\t\tfull_next <= 0;\n\t\t\t\t\tif (r_ptr_succ == w_ptr_reg)\n\t\t\t\t\t\tempty_next <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\t2'b10: begin\n\t\t\t\tif (!full_reg) begin\n\t\t\t\t\tw_ptr_next <= w_ptr_succ;\n\t\t\t\t\tempty_next <= 0;\n\t\t\t\t\tif (w_ptr_succ == r_ptr_reg)\n\t\t\t\t\t\tfull_next <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\tw_ptr_next <= w_ptr_succ;\n\t\t\t\tw_ptr_next <= r_ptr_succ;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\tassign full = full_reg;\n\tassign empty = empty_reg;\n\t\nendmodule\n",
        "module_name": "fifo",
        "module_hash": "85c9187bfd1244ae601df59b5b84e320",
        "dataset_index": 4736
      },
      "top__a4c21d9e": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input rst,\n    input ena,\n    input [1:0] shift_dir,\n    output wire [3:0] sum\n);\n\n    wire [3:0] count;\n    wire [3:0] shifted_count;\n\n    binary_counter counter_inst (\n        .clk(clk),\n        .rst(rst),\n        .ena(ena),\n        .count(count)\n    );\n\n    barrel_shifter shifter_inst (\n        .D(count),\n        .S(shift_dir),\n        .Q(shifted_count)\n    );\n\n    assign sum = (shift_dir == 2'b00) ? shifted_count + count :\n                (shift_dir == 2'b01) ? shifted_count << 1 :\n                (shift_dir == 2'b10) ? shifted_count >> 1 :\n                {shifted_count[2:0], shifted_count[3]};\n\nendmodule\n\nmodule binary_counter (\n    input clk,\n    input rst,\n    input ena,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            count <= 4'b0;\n        end else if (ena) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule barrel_shifter (\n    input [3:0] D,\n    input [1:0] S,\n    output reg [3:0] Q\n);\n\n    always @ (D, S) begin\n        case (S)\n            2'b00: Q <= D;\n            2'b01: Q <= {D[2:0], 1'b0};\n            2'b10: Q <= {1'b0, D[3:1]};\n            2'b11: Q <= {D[2:0], D[3]};\n        endcase\n    end\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "a4c21d9e1cab713f0eaf713863781330",
        "dataset_index": 20478
      },
      "four_to_one_1ca5f70a": {
        "rtl_code": "module four_to_one (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = ((A1 & A2 & B1 & B2) | (A1 & A2 & !B1 & !B2) | (A1 & !A2 & B1 & !B2) | (!A1 & A2 & !B1 & B2));\n\nendmodule",
        "module_name": "four_to_one",
        "module_hash": "1ca5f70a5ee6746bd331d5e54d989033",
        "dataset_index": 360
      },
      "magnitude_comparator_572e09a0": {
        "rtl_code": "\nmodule magnitude_comparator (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    output reg out\n);\n\nreg [3:0] A_reg, B_reg;\nreg [1:0] stage;\n\nalways @(posedge clk) begin\n    case(stage)\n        0: begin\n            A_reg <= A;\n            B_reg <= B;\n            stage <= 1;\n        end\n        1: begin\n            if (|A_reg > |B_reg) begin\n                out <= 1;\n            end else begin\n                out <= 0;\n            end\n            stage <= 0;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "magnitude_comparator",
        "module_hash": "572e09a0b8645a79b600b9ce9d1ad548",
        "dataset_index": 17640
      },
      "binary_addition_a0923142": {
        "rtl_code": "module binary_addition (\n    input [3:0] A,\n    input [3:0] B,\n    input C,\n    output [3:0] S,\n    output OV,\n    output UF\n);\n\n    wire [4:0] temp;\n    assign temp = (C == 0) ? ({1'b0, A} + {1'b0, B}) : ({1'b0, A} - {1'b0, B});\n\n    assign OV = (temp[4] == 1) ? 1 : 0;\n    assign UF = (temp[3:0] < 4'b0000) ? 1 : 0;\n    assign S = (OV || UF) ? 4'b0000 : temp[3:0];\n\nendmodule",
        "module_name": "binary_addition",
        "module_hash": "a09231421d6e93b7104ca14d51631d3d",
        "dataset_index": 6965
      },
      "division__9ab8f21b": {
        "rtl_code": "module division_module (\n    input clk,\n    input rst_n,\n    input [7:0] A,\n    input [7:0] B,\n    input ready,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder,\n    output reg valid\n);\n\nreg [7:0] dividend_reg;\nreg [7:0] divisor_reg;\nreg [7:0] quotient_reg;\nreg [7:0] remainder_reg;\nreg [2:0] state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dividend_reg <= 8'b0;\n        divisor_reg <= 8'b0;\n        quotient_reg <= 8'b0;\n        remainder_reg <= 8'b0;\n        state <= 3'b000;\n        valid <= 1'b0;\n    end else begin\n        case (state)\n            3'b000: begin\n                dividend_reg <= A;\n                divisor_reg <= B;\n                state <= 3'b001;\n            end\n            3'b001: begin\n                if (divisor_reg == 8'b0) begin\n                    quotient_reg <= 8'b0;\n                    remainder_reg <= 8'b0;\n                    state <= 3'b000;\n                    valid <= 1'b1;\n                end else begin\n                    quotient_reg <= dividend_reg / divisor_reg;\n                    remainder_reg <= dividend_reg % divisor_reg;\n                    state <= 3'b010;\n                end\n            end\n            3'b010: begin\n                if (ready) begin\n                    state <= 3'b011;\n                end\n            end\n            3'b011: begin\n                quotient <= quotient_reg;\n                remainder <= remainder_reg;\n                valid <= 1'b1;\n                state <= 3'b000;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "division_",
        "module_hash": "9ab8f21b4aad648589d51f93669afc33",
        "dataset_index": 15781
      },
      "decoder_bcd_1075bf09": {
        "rtl_code": "\nmodule decoder_bcd (\n    input [3:0] binary_in,\n    output reg [3:0] out_high,\n    output reg [3:0] out_low\n);\n\n    wire [15:0] decoder_out;\n    wire [3:0] bcd_out;\n    \n    decoder_4to16 decoder_inst (\n        .in(binary_in),\n        .out(decoder_out)\n    );\n    \n    bcd_encoder bcd_inst (\n        .in(decoder_out),\n        .out(bcd_out)\n    );\n    \n    always @(*) begin\n        out_high = bcd_out[3:0];\n        out_low = bcd_out[3:0];\n    end\n\nendmodule\nmodule decoder_4to16 (\n    input [3:0] in,\n    output reg [15:0] out\n);\n\n    always @* begin\n        case (in)\n            4'b0000: out = 16'b0000000000000001;\n            4'b0001: out = 16'b0000000000000010;\n            4'b0010: out = 16'b0000000000000100;\n            4'b0011: out = 16'b0000000000001000;\n            4'b0100: out = 16'b0000000000010000;\n            4'b0101: out = 16'b0000000000100000;\n            4'b0110: out = 16'b0000000001000000;\n            4'b0111: out = 16'b0000000010000000;\n            4'b1000: out = 16'b0000000100000000;\n            4'b1001: out = 16'b0000001000000000;\n            4'b1010: out = 16'b0000010000000000;\n            4'b1011: out = 16'b0000100000000000;\n            4'b1100: out = 16'b0001000000000000;\n            4'b1101: out = 16'b0010000000000000;\n            4'b1110: out = 16'b0100000000000000;\n            4'b1111: out = 16'b1000000000000000;\n            default: out = 16'b0000000000000000;\n        endcase\n    end\n\nendmodule\nmodule bcd_encoder (\n    input [15:0] in,\n    output reg [3:0] out\n);\n\n    always @* begin\n        case (in)\n            16'b0000000000000001: out = 4'b0001;\n            16'b0000000000000010: out = 4'b0010;\n            16'b0000000000000100: out = 4'b0011;\n            16'b0000000000001000: out = 4'b0100;\n            16'b0000000000010000: out = 4'b0101;\n            16'b0000000000100000: out = 4'b0110;\n            16'b0000000001000000: out = 4'b0111;\n            16'b0000000010000000: out = 4'b1000;\n            16'b0000000100000000: out = 4'b1001;\n            16'b0000001000000000: out = 4'b0001;\n            16'b0000010000000000: out = 4'b0010;\n            16'b0000100000000000: out = 4'b0011;\n            16'b0001000000000000: out = 4'b0100;\n            16'b0010000000000000: out = 4'b0101;\n            16'b0100000000000000: out = 4'b0110;\n            16'b1000000000000000: out = 4'b0111;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule\nmodule top_module (\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg [3:0] out_high,\n    output reg [3:0] out_low\n);\n\n    decoder_bcd decoder_inst (\n        .binary_in({A, B, C, D}),\n        .out_high(out_high),\n        .out_low(out_low)\n    );\n\nendmodule",
        "module_name": "decoder_bcd",
        "module_hash": "1075bf098b72fd54f0fcef53d6370647",
        "dataset_index": 8817
      },
      "ALU #_65186be5": {
        "rtl_code": "\nmodule ALU #(parameter N=32)(\n    input [3:0] op_code,\n\t input signed [N-1:0] operand1,\n    input signed [N-1:0] operand2,\n\t output reg signed [N-1:0] result,\n\t output reg zero,\n\t output reg overflow\n    );\n\t \n    always @(*) begin\n\t \n\t\tcase(op_code)\n\t\t\t0: {overflow,result} = operand2 <<  operand1[4:0];\t\t\t\t\t\t\t1: {overflow,result} = operand2 >>  operand1[4:0];\t\t\t\t\t\t\t2: {overflow,result} = operand2 >>> operand1[4:0];\t\t\t\t\t\t\t3: {overflow,result} = operand1 + operand2 ;\t\t\t\t\t\t\t\t\t4: {overflow,result} = operand1 - operand2;\t\t\t\t\t\t\t\t\t5: {overflow,result} = operand1 & operand2;\t\t\t\t\t\t\t\t\t6: {overflow,result} = operand1 | operand2;\t\t\t\t\t\t\t\t\t7: {overflow,result} = operand1 ^ operand2;\t\t\t\t\t\t\t\t\t8: {overflow,result} = ~(operand1 | operand2);\t\t\t\t\t\t\t\t9: {overflow,result} = (operand1 < operand2);\t\t\t\t\t\t\t\tdefault: {overflow,result} = 0;\n\t\tendcase\t\n\t\tzero= (result==0)? 1'b1:1'b0;\n\tend\n\nendmodule\n",
        "module_name": "ALU #",
        "module_hash": "65186be5ff70bb7b4f89687f33cf18b1",
        "dataset_index": 24321
      },
      "Span12Mux_s5_h_db1fa222": {
        "rtl_code": "module Span12Mux_s5_h(I, A, B, C, D, E, O);\n  input [3:0] I;\n  input [11:0] A, B, C, D, E;\n  output reg [11:0] O;\n  \n  always @(*) begin\n    case (I)\n      4'b0000: O = A;\n      4'b0001: O = B;\n      4'b0010: O = C;\n      4'b0011: O = D;\n      4'b0100: O = E;\n      default: O = 12'b0;\n    endcase\n  end\nendmodule",
        "module_name": "Span12Mux_s5_h",
        "module_hash": "db1fa22278fcedbf911e6df26d21c723",
        "dataset_index": 4062
      },
      "ac97_sout_3d234d71": {
        "rtl_code": "\n`include \"ac97_defines.v\"\n\nmodule ac97_sout(clk, rst,\n\n\tso_ld, slt0, slt1, slt2, slt3, slt4,\n\tslt6, slt7, slt8, slt9,\n\n\tsdata_out\n\t);\n\ninput\t\tclk, rst;\n\ninput\t\tso_ld;\ninput\t[15:0]\tslt0;\ninput\t[19:0]\tslt1;\ninput\t[19:0]\tslt2;\ninput\t[19:0]\tslt3;\ninput\t[19:0]\tslt4;\ninput\t[19:0]\tslt6;\ninput\t[19:0]\tslt7;\ninput\t[19:0]\tslt8;\ninput\t[19:0]\tslt9;\n\noutput\t\tsdata_out;\n\n\nwire\t\tsdata_out;\n\nreg\t[15:0]\tslt0_r;\nreg\t[19:0]\tslt1_r;\nreg\t[19:0]\tslt2_r;\nreg\t[19:0]\tslt3_r;\nreg\t[19:0]\tslt4_r;\nreg\t[19:0]\tslt5_r;\nreg\t[19:0]\tslt6_r;\nreg\t[19:0]\tslt7_r;\nreg\t[19:0]\tslt8_r;\nreg\t[19:0]\tslt9_r;\nreg\t[19:0]\tslt10_r;\nreg\t[19:0]\tslt11_r;\nreg\t[19:0]\tslt12_r;\n\n\n\nassign\tsdata_out = slt0_r[15];\n\nalways @(posedge clk)\n\tif(so_ld)\tslt0_r <= #1 slt0;\n\telse\t\tslt0_r <= #1 {slt0_r[14:0], slt1_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt1_r <= #1 slt1;\n\telse\t\tslt1_r <= #1 {slt1_r[18:0], slt2_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt2_r <= #1 slt2;\n\telse\t\tslt2_r <= #1 {slt2_r[18:0], slt3_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt3_r <= #1 slt3;\n\telse\t\tslt3_r <= #1 {slt3_r[18:0], slt4_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt4_r <= #1 slt4;\n\telse\t\tslt4_r <= #1 {slt4_r[18:0], slt5_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt5_r <= #1 20'h0;\n\telse\t\tslt5_r <= #1 {slt5_r[18:0], slt6_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt6_r <= #1 slt6;\n\telse\t\tslt6_r <= #1 {slt6_r[18:0], slt7_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt7_r <= #1 slt7;\n\telse\t\tslt7_r <= #1 {slt7_r[18:0], slt8_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt8_r <= #1 slt8;\n\telse\t\tslt8_r <= #1 {slt8_r[18:0], slt9_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt9_r <= #1 slt9;\n\telse\t\tslt9_r <= #1 {slt9_r[18:0], slt10_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt10_r <= #1 20'h0;\n\telse\t\tslt10_r <= #1 {slt10_r[18:0], slt11_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt11_r <= #1 20'h0;\n\telse\t\tslt11_r <= #1 {slt11_r[18:0], slt12_r[19]};\n\nalways @(posedge clk)\n\tif(so_ld)\tslt12_r <= #1 20'h0;\n\telse\t\tslt12_r <= #1 {slt12_r[18:0], 1'b0 };\n\nendmodule\n\n",
        "module_name": "ac97_sout",
        "module_hash": "3d234d718831fd22b900d0459a99f142",
        "dataset_index": 208
      },
      "MAIN_7dc08f9c": {
        "rtl_code": "\nmodule MAIN(\n\t\tinput clk,\n\t\tinput wire [4:0] R_Addr_A,\n\t\tinput wire [4:0] R_Addr_B,\n\t\tinput wire [4:0] W_Addr,\n\t\tinput Reset,\n\t\tinput Write_Reg,\n\t\tinput [2:0] ALU_OP,\n\t\toutput wire [31:0] A,B,\n\t\toutput wire [31:0] LED,\n\t\toutput OF, ZF\n    );\n\t\n\twire [31:0] F;\n\tregister REG (\n    .clk(clk), \n    .Reset(Reset), \n    .R_Addr_A(R_Addr_A), \n    .R_Addr_B(R_Addr_B), \n    .W_Addr(W_Addr), \n    .W_Data(LED), \n    .Write_Reg(Write_Reg), \n    .R_Data_A(A), \n    .R_Data_B(B)\n    );\n\t \n\tALU ALUP (\n    .A(A), \n    .B(B), \n    .ZF(ZF), \n    .OF(OF), \n    .F(LED), \n    .ALU_OP(ALU_OP)\n    );\n\t\n\t\nendmodule\n\n\nmodule register(clk, Reset, R_Addr_A, R_Addr_B, W_Addr, W_Data, Write_Reg, R_Data_A, R_Data_B\n\t );\n\t input clk;\n\t input Reset;\n\t input Write_Reg;\n\t input [4:0] R_Addr_A, R_Addr_B, W_Addr;\n\t input [31:0] W_Data;\n\t \n\t output [31:0] R_Data_A;\n\t output [31:0] R_Data_B;\n\t \n\t reg [31:0] REGISTERS[31:0];\n\t \n\t integer i;\n\t assign R_Data_A = REGISTERS[R_Addr_A];\n\t assign R_Data_B = REGISTERS[R_Addr_B];\n\t always @(posedge clk)\n\t begin\n\t\tif(Reset)\n\t\t\tbegin\n\t\t\t\tfor(i=0; i<=31; i=i+1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tREGISTERS[i]<=32'h0000_0000;\n\t\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif(Write_Reg)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tREGISTERS[W_Addr]<=W_Data;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tREGISTERS[W_Addr]<=REGISTERS[W_Addr];\n\t\t\t\t\tend\n\t\t\tend\n\t end\nendmodule\n\nmodule ALU(A, B, ZF, OF, F, ALU_OP);\n    input [2:0] ALU_OP;\n    input [31:0] A, B;\n    output reg [31:0] F;\n    output reg ZF, OF;\n    reg C32;\n    always @(*)\n    begin\n        case(ALU_OP)\n            3'd0:begin F = A&B;\n                OF = 0;\n            end\n            3'd1:begin F = A|B;\n                OF = 0;\n            end\n            3'd2:begin F = A^B;\n                OF = 0;\n            end\n            3'd3:begin {C32, F} = A + 1'b1;\n\t\t\t\t\tOF = A[31]^B[31]^F[31]^C32;\n            end\n            3'd4:begin {C32, F} = A + B;\n                OF = A[31]^B[31]^F[31]^C32;\n            end\n            3'd5:begin {C32, F} = A - B;\n                OF = A[31]^B[31]^F[31]^C32;\n            end\n            3'd6:begin if (A<B)\n                    begin\n                        F = 32'd1;\n                    end\n                else \n                    begin\n                        F = 32'd0;\n                    end\n                OF = 0;\n            end\n            3'd7:begin F=B<<A;\n              OF=0;\n            end\n            default:begin\n              F=A;\n              OF = 0;\n            end\n            \n        endcase\n        if (F == 32'd0)\n            begin\n                ZF = 1;\n            end\n        else \n            begin\n                ZF = 0;\n            end\n    end\n    \nendmodule\n",
        "module_name": "MAIN",
        "module_hash": "7dc08f9c6ada097588962ed6ac5eea0a",
        "dataset_index": 21882
      },
      "counter_2bit_da49986d": {
        "rtl_code": "module counter_2bit (\n    Q      ,\n    CLK    ,\n    RESET_B\n);\n\n    // Module ports\n    output reg [1:0] Q      ;\n    input  CLK            ;\n    input  RESET_B        ;\n\n    // Local signals\n    reg [1:0] next_Q;\n\n    // Counter logic\n    always @(posedge CLK, negedge RESET_B) begin\n        if (~RESET_B) begin\n            Q <= 2'b00;\n        end else begin\n            next_Q <= Q + 1;\n            if (next_Q == 2'b11) begin\n                Q <= 2'b00;\n            end else begin\n                Q <= next_Q;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "counter_2bit",
        "module_hash": "da49986daf7074e857491a4ba118103a",
        "dataset_index": 563
      },
      "bin_to_bcd_0687885a": {
        "rtl_code": "module bin_to_bcd(\n    input [3:0] bin_in,\n    output [3:0] bcd_out_hi,\n    output [3:0] bcd_out_lo\n);\n\n    wire [3:0] bin_out;\n    assign bin_out = (bin_in >= 5) ? bin_in - 5 : bin_in;\n\n    assign bcd_out_hi = (bin_in >= 5) ? 1'b1 : 1'b0;\n\n    assign bcd_out_lo = (bin_out >= 5) ? bin_out - 4'b0101 : bin_out;\n\nendmodule",
        "module_name": "bin_to_bcd",
        "module_hash": "0687885a34209011f82e282d34b26e7f",
        "dataset_index": 3427
      },
      "acl_fp_convert_to_half_d34657f3": {
        "rtl_code": "module acl_fp_convert_to_half(clock, resetn, dataa, result, valid_in, valid_out, stall_in, stall_out, enable);\n  parameter HIGH_CAPACITY = 1;\n  parameter ROUNDING_MODE = 0;\n    input clock, resetn;\n  input [31:0] dataa;\n  output [15:0] result;\n  input valid_in, stall_in, enable;\n  output valid_out, stall_out;\n    \n  wire c1_enable;\n  reg c1_valid;\n  wire c1_stall;\n  wire c2_enable;\n  reg c2_valid;\n  wire c2_stall;  \n  \n  reg [4:0] c1_exponent;\n  reg [13:0] c1_mantissa;\n  reg c1_sign;\n  \n  assign c1_enable = (HIGH_CAPACITY == 1) ? (~c1_valid | ~c1_stall) : enable;\n  assign stall_out = c1_valid & c1_stall;\n  \n  always@(posedge clock or negedge resetn)\n  begin\n    if(~resetn)\n    begin\n      c1_valid <= 1'b0;\n      c1_exponent <= 5'dx;\n      c1_mantissa <= 14'dx;\n      c1_sign <= 1'bx;\n    end\n    else if (c1_enable)\n    begin\n      c1_valid <= valid_in;\n      c1_sign <= dataa[31];\n      if ({1'b0, dataa[30:23]} <= 9'd112)\n      begin\n        case(dataa[30:23])\n          8'h70 : c1_mantissa <= {2'd1, dataa[22:12],|dataa[11:0]}; 8'h6F : c1_mantissa <= {3'd1, dataa[22:13],|dataa[12:0]};\n          8'h6E : c1_mantissa <= {4'd1, dataa[22:14],|dataa[13:0]};\n          8'h6D : c1_mantissa <= {5'd1, dataa[22:15],|dataa[14:0]};\n          8'h6C : c1_mantissa <= {6'd1, dataa[22:16],|dataa[15:0]};\n          8'h6B : c1_mantissa <= {7'd1, dataa[22:17],|dataa[16:0]};\n          8'h6A : c1_mantissa <= {8'd1, dataa[22:18],|dataa[17:0]};\n          8'h69 : c1_mantissa <= {9'd1, dataa[22:19],|dataa[18:0]};\n          8'h68 : c1_mantissa <= {10'd1, dataa[22:20],|dataa[19:0]};\n          8'h67 : c1_mantissa <= {11'd1, dataa[22:21],|dataa[20:0]};\n          8'h66 : c1_mantissa <= {12'd1, dataa[22],|dataa[21:0]}; default : c1_mantissa <= 14'd0;\n        endcase\n        c1_exponent <= 5'd0;\n      end\n      else if (&dataa[30:23])\n      begin\n        c1_exponent <= 5'h1f;\n        c1_mantissa <= {1'b1, |dataa[22:0], 12'd0};\n      end\n      else if ({1'b0, dataa[30:23]} > 9'h08e)\n      begin\n        if ((ROUNDING_MODE == 0) || (ROUNDING_MODE == 1))\n        begin\n          c1_exponent <= 5'h1f;\n          c1_mantissa <= 14'd0;\n        end\n        else if (ROUNDING_MODE == 2)\n        begin\n          c1_exponent <= 5'h1e;\n          c1_mantissa <= 14'h3ff8;\n        end\n        else if (ROUNDING_MODE == 3)\n        begin\n          c1_exponent <= dataa[31] ? (5'h1e) : (5'h1f);\n          c1_mantissa <= dataa[31] ? 14'h3ff8 : 14'd0;\n        end\n        else if (ROUNDING_MODE == 4)\n        begin\n          c1_exponent <= (~dataa[31]) ? (5'h1e) : (5'h1f);\n          c1_mantissa <= (~dataa[31]) ? 14'h3ff8 : 14'd0;\n        end\n      end\n      else\n      begin\n        c1_exponent <= dataa[30:23] - 8'h70;\n        c1_mantissa <= {1'b1, dataa[22:11],|dataa[10:0]};\n      end\n    end\n  end\n  \n  reg [4:0] c2_exponent;\n  reg [9:0] c2_mantissa;\n  reg c2_sign;\n  reg [11:0] c2_temp_mantissa;\n  \n  assign c2_enable = (HIGH_CAPACITY == 1) ? (~c2_valid | ~c2_stall) : enable;\n  assign c1_stall = c2_valid & c2_stall;\n  \n  always@(*)\n  begin\n    case (ROUNDING_MODE)\n    4: begin\n      if ((|c1_mantissa[2:0]) & c1_sign)\n        c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]} + 1'b1;\n      else\n        c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]};\n    end\n    3: begin\n      if ((|c1_mantissa[2:0]) & ~c1_sign)\n        c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]} + 1'b1;\n      else\n        c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]};\n    end\n    2: begin\n      c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]};\n    end\n    1: begin\n      c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]} + {1'b0, c1_mantissa[2]};\n    end\n    \n    default: begin\n      if ((c1_mantissa[3:0] == 4'b1100) || ({1'b0, c1_mantissa[2:0]} > 4'h4))\n        c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]} + 1'b1;\n      else\n        c2_temp_mantissa <= {1'b0, c1_mantissa[13:3]};\n    end\n    endcase  \n  end\n  \n  always@(posedge clock or negedge resetn)\n  begin\n    if(~resetn)\n    begin\n      c2_valid <= 1'b0;\n      c2_exponent <= 5'dx;\n      c2_mantissa <= 10'dx;\n      c2_sign <= 1'bx;\n    end\n    else if (c2_enable)\n    begin\n      c2_valid <= c1_valid;\n      c2_sign <= c1_sign;\n      if (c2_temp_mantissa[11])\n      begin\n        c2_exponent <= c1_exponent + 1'b1;\n        c2_mantissa <= c2_temp_mantissa[10:1];\n      end\n      else\n      begin\n        c2_exponent <= c1_exponent + {1'b0, (c2_temp_mantissa[10] & (~|c1_exponent))};\n        c2_mantissa <= c2_temp_mantissa[9:0];\n      end\n    end\n  end  \n  \n  assign result = {c2_sign, c2_exponent, c2_mantissa};\n  assign valid_out = c2_valid;\n  assign c2_stall = stall_in;\n  \n endmodule\n \n  \n",
        "module_name": "acl_fp_convert_to_half",
        "module_hash": "d34657f32bd2ccdf5e91c97166b70117",
        "dataset_index": 25670
      },
      "four_bit_adder_8102d8f9": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire C1, C2, C3;\n\n    full_adder adder1 (\n        .a(A[0]),\n        .b(B[0]),\n        .cin(Cin),\n        .sum(sum[0]),\n        .cout(C1)\n    );\n\n    full_adder adder2 (\n        .a(A[1]),\n        .b(B[1]),\n        .cin(C1),\n        .sum(sum[1]),\n        .cout(C2)\n    );\n\n    full_adder adder3 (\n        .a(A[2]),\n        .b(B[2]),\n        .cin(C2),\n        .sum(sum[2]),\n        .cout(C3)\n    );\n\n    full_adder adder4 (\n        .a(A[3]),\n        .b(B[3]),\n        .cin(C3),\n        .sum(sum[3]),\n        .cout(Cout)\n    );\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n",
        "module_name": "four_bit_adder",
        "module_hash": "8102d8f997a18a4c9d0b7c4ca4d87076",
        "dataset_index": 18858
      },
      "binary_counter_ae65b558": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "ae65b55817a3468e38beed55f08c480e",
        "dataset_index": 4631
      },
      "d_ff_async_reset_6cd6a3f9": {
        "rtl_code": "module d_ff_async_reset(clk, reset, d, q);\n  input clk, reset, d;\n  output q;\n\n  reg q;\n\n  always @(posedge clk, negedge reset) begin\n    if (!reset) begin\n      q <= 1'b0;\n    end else begin\n      q <= d;\n    end\n  end\n\nendmodule",
        "module_name": "d_ff_async_reset",
        "module_hash": "6cd6a3f9a7ecc1ebceda7bf2a7f43cae",
        "dataset_index": 6637
      },
      "sky130_fd_sc_hd__o221a_357bc7db": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__o221a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , B2, B1              );\n    or  or1  (or1_out   , A2, A1              );\n    and and0 (and0_out_X, or0_out, or1_out, C1);\n    buf buf0 (X         , and0_out_X          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__o221a",
        "module_hash": "357bc7db22acdca73febfc81cddbee7d",
        "dataset_index": 18765
      },
      "add_sub_50498860": {
        "rtl_code": "module add_sub (\n    input [3:0] A,\n    input [3:0] B,\n    input C,\n    output reg [3:0] Q\n);\n\nreg [3:0] sum_reg;\nreg [3:0] sub_reg;\n\nalways @ (posedge C) begin // Fixed the clock signal\n    if (C == 1'b1) begin // Addition\n        sum_reg <= A + B;\n    end else begin // Subtraction\n        sub_reg <= A - B;\n    end\nend\n\nalways @ (posedge C) begin // Fixed the clock signal\n    if (C == 1'b1) begin // Addition\n        Q <= sum_reg;\n    end else begin // Subtraction\n        Q <= sub_reg;\n    end\nend\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "5049886031187d52a2e13705339f43e7",
        "dataset_index": 1767
      },
      "accu_3f14b10e": {
        "rtl_code": "\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n\n    output              ready_a     ,\n    // Fix: Declare valid_b as a reg type\n    output reg          valid_b     ,\n    output reg [9:0]   data_out\n);\n\nreg [9:0] acc;  // Accumulator register\nreg [2:0] stage;  // Pipeline stage register\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        acc <= 10'd0;\n        stage <= 3'd0;\n        // Fix: Initialize valid_b to 1'b0\n        valid_b <= 1'b0;\n        data_out <= 10'd0;\n    end else begin\n        case (stage)\n            3'd0: begin  // Stage 0: Idle\n                if (valid_a) begin\n                    acc <= data_in;\n                    stage <= 3'd1;\n                end\n            end\n            3'd1: begin  // Stage 1: Accumulate\n                if (valid_a) begin\n                    acc <= acc + data_in;\n                    stage <= 3'd2;\n                end\n            end\n            3'd2: begin  // Stage 2: Accumulate\n                if (valid_a) begin\n                    acc <= acc + data_in;\n                    stage <= 3'd3;\n                end\n            end\n            3'd3: begin  // Stage 3: Output\n                // Fix: Set valid_b after assigning data_out\n                data_out <= acc;\n                valid_b <= 1'b1;\n                stage <= 3'd0;\n            end\n        endcase\n    end\nend\n\n// Fix: Assign ready_a correctly based on the stage\nassign ready_a = (stage == 3'd0) ? 1'b1 : 1'b0;\nendmodule\n",
        "module_name": "accu",
        "module_hash": "3f14b10e7714ce4aa803f51247191953",
        "dataset_index": 16018
      },
      "accu_794defb0": {
        "rtl_code": "module accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n \n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [7:0]   data_out\n);\n\n    // Pipeline registers for adder and multiplier outputs\n    reg [7:0] adder_out_reg;\n    reg [7:0] mult_out_reg;\n    \n    // Counter to keep track of input data\n    reg [2:0] count = 0;\n    \n    // Instantiate adder and multiplier modules\n    adder_module adder_inst(.a(adder_out_reg), .b(data_in), .sum(adder_out_reg));\n    multiplier_module mult_inst(.a(mult_out_reg), .b(data_in), .product(mult_out_reg));\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            valid_b <= 0;\n            data_out <= 0;\n            count <= 0;\n        end\n        else begin\n            // Check if downstream module is ready\n            if (ready_b && valid_a) begin\n                // Increment counter\n                count <= count + 1;\n                \n                // Accumulate data every 6 input data\n                if (count == 6) begin\n                    // Calculate final output using adder and multiplier outputs\n                    data_out <= (adder_out_reg + mult_out_reg) / 2;\n                    valid_b <= 1;\n                    count <= 0;\n                end\n                else begin\n                    valid_b <= 0;\n                end\n            end\n        end\n    end\n    \n    // Handshake signals\n    assign ready_a = ~valid_b;\n    \nendmodule\n\nmodule adder_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule multiplier_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] product\n);\n    assign product = a * b;\nendmodule",
        "module_name": "accu",
        "module_hash": "794defb0e45d5f85632dccaf7320d3c6",
        "dataset_index": 16805
      },
      "left_shift_register_9ff16969": {
        "rtl_code": "module left_shift_register (\n  input clk,\n  input reset,\n  input [31:0] data,\n  input [4:0] shift_amount,\n  output reg [31:0] shifted_data\n);\n\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      shifted_data <= 0;\n    end else if (shift_amount >= 32) begin\n      shifted_data <= 0;\n    end else begin\n      shifted_data <= data << shift_amount;\n    end\n  end\n\nendmodule\n",
        "module_name": "left_shift_register",
        "module_hash": "9ff169692c40864fc7a6b44806414897",
        "dataset_index": 5882
      },
      "sha1_w_mem_78104c3f": {
        "rtl_code": "\n\nmodule sha1_w_mem(\n                  input wire           clk,\n                  input wire           reset_n,\n\n                  input wire [511 : 0] block,\n\n                  input wire           init,\n                  input wire           next,\n\n                  output wire [31 : 0] w\n                 );\n\n\n  reg [31 : 0] w_mem [0 : 15];\n  reg [31 : 0] w_mem00_new;\n  reg [31 : 0] w_mem01_new;\n  reg [31 : 0] w_mem02_new;\n  reg [31 : 0] w_mem03_new;\n  reg [31 : 0] w_mem04_new;\n  reg [31 : 0] w_mem05_new;\n  reg [31 : 0] w_mem06_new;\n  reg [31 : 0] w_mem07_new;\n  reg [31 : 0] w_mem08_new;\n  reg [31 : 0] w_mem09_new;\n  reg [31 : 0] w_mem10_new;\n  reg [31 : 0] w_mem11_new;\n  reg [31 : 0] w_mem12_new;\n  reg [31 : 0] w_mem13_new;\n  reg [31 : 0] w_mem14_new;\n  reg [31 : 0] w_mem15_new;\n  reg          w_mem_we;\n\n  reg [6 : 0] w_ctr_reg;\n  reg [6 : 0] w_ctr_new;\n  reg         w_ctr_we;\n\n\n  reg [31 : 0] w_tmp;\n  reg [31 : 0] w_new;\n\n\n  assign w = w_tmp;\n\n\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            w_mem[i] <= 32'h0;\n\n          w_ctr_reg <= 7'h0;\n        end\n      else\n        begin\n          if (w_mem_we)\n            begin\n              w_mem[00] <= w_mem00_new;\n              w_mem[01] <= w_mem01_new;\n              w_mem[02] <= w_mem02_new;\n              w_mem[03] <= w_mem03_new;\n              w_mem[04] <= w_mem04_new;\n              w_mem[05] <= w_mem05_new;\n              w_mem[06] <= w_mem06_new;\n              w_mem[07] <= w_mem07_new;\n              w_mem[08] <= w_mem08_new;\n              w_mem[09] <= w_mem09_new;\n              w_mem[10] <= w_mem10_new;\n              w_mem[11] <= w_mem11_new;\n              w_mem[12] <= w_mem12_new;\n              w_mem[13] <= w_mem13_new;\n              w_mem[14] <= w_mem14_new;\n              w_mem[15] <= w_mem15_new;\n            end\n\n          if (w_ctr_we)\n            w_ctr_reg <= w_ctr_new;\n        end\n    end always @*\n    begin : select_w\n      if (w_ctr_reg < 16)\n        w_tmp = w_mem[w_ctr_reg[3 : 0]];\n      else\n        w_tmp = w_new;\n    end always @*\n    begin : w_mem_update_logic\n      reg [31 : 0] w_0;\n      reg [31 : 0] w_2;\n      reg [31 : 0] w_8;\n      reg [31 : 0] w_13;\n      reg [31 : 0] w_16;\n\n      w_mem00_new = 32'h0;\n      w_mem01_new = 32'h0;\n      w_mem02_new = 32'h0;\n      w_mem03_new = 32'h0;\n      w_mem04_new = 32'h0;\n      w_mem05_new = 32'h0;\n      w_mem06_new = 32'h0;\n      w_mem07_new = 32'h0;\n      w_mem08_new = 32'h0;\n      w_mem09_new = 32'h0;\n      w_mem10_new = 32'h0;\n      w_mem11_new = 32'h0;\n      w_mem12_new = 32'h0;\n      w_mem13_new = 32'h0;\n      w_mem14_new = 32'h0;\n      w_mem15_new = 32'h0;\n      w_mem_we    = 1'h0;\n\n      w_0   = w_mem[0];\n      w_2   = w_mem[2];\n      w_8   = w_mem[8];\n      w_13  = w_mem[13];\n      w_16  = w_13 ^ w_8 ^ w_2 ^ w_0;\n      w_new = {w_16[30 : 0], w_16[31]};\n\n      if (init)\n        begin\n          w_mem00_new = block[511 : 480];\n          w_mem01_new = block[479 : 448];\n          w_mem02_new = block[447 : 416];\n          w_mem03_new = block[415 : 384];\n          w_mem04_new = block[383 : 352];\n          w_mem05_new = block[351 : 320];\n          w_mem06_new = block[319 : 288];\n          w_mem07_new = block[287 : 256];\n          w_mem08_new = block[255 : 224];\n          w_mem09_new = block[223 : 192];\n          w_mem10_new = block[191 : 160];\n          w_mem11_new = block[159 : 128];\n          w_mem12_new = block[127 :  96];\n          w_mem13_new = block[95  :  64];\n          w_mem14_new = block[63  :  32];\n          w_mem15_new = block[31  :   0];\n          w_mem_we    = 1'h1;\n        end\n\n      if (next && (w_ctr_reg > 15))\n        begin\n          w_mem00_new = w_mem[01];\n          w_mem01_new = w_mem[02];\n          w_mem02_new = w_mem[03];\n          w_mem03_new = w_mem[04];\n          w_mem04_new = w_mem[05];\n          w_mem05_new = w_mem[06];\n          w_mem06_new = w_mem[07];\n          w_mem07_new = w_mem[08];\n          w_mem08_new = w_mem[09];\n          w_mem09_new = w_mem[10];\n          w_mem10_new = w_mem[11];\n          w_mem11_new = w_mem[12];\n          w_mem12_new = w_mem[13];\n          w_mem13_new = w_mem[14];\n          w_mem14_new = w_mem[15];\n          w_mem15_new = w_new;\n          w_mem_we    = 1'h1;\n        end\n    end always @*\n    begin : w_ctr\n      w_ctr_new = 7'h0;\n      w_ctr_we  = 1'h0;\n\n      if (init)\n        begin\n          w_ctr_new = 7'h0;\n          w_ctr_we  = 1'h1;\n        end\n\n      if (next)\n        begin\n          w_ctr_new = w_ctr_reg + 7'h01;\n          w_ctr_we  = 1'h1;\n        end\n    end endmodule ",
        "module_name": "sha1_w_mem",
        "module_hash": "78104c3f5d3fe3db5a98fe7574e13cf2",
        "dataset_index": 23642
      },
      "altera_tse_xcvr_resync #_37b40a3a": {
        "rtl_code": "module altera_tse_xcvr_resync #(\n    parameter SYNC_CHAIN_LENGTH = 2,  parameter WIDTH             = 1,  parameter SLOW_CLOCK        = 0   ) (\n  input   wire              clk,\n  input   wire  [WIDTH-1:0] d,\n  output  wire  [WIDTH-1:0] q\n  );\n\nlocalparam  INT_LEN   = (SYNC_CHAIN_LENGTH > 0) ? SYNC_CHAIN_LENGTH : 1;\n\ngenvar ig;\n\ngenerate begin\n  for(ig=0;ig<WIDTH;ig=ig+1) begin : resync_chains\n    wire                d_in;   reg   [INT_LEN-1:0] r = {INT_LEN{1'b0}};\n    wire  [INT_LEN  :0] next_r; assign  q[ig]   = r[INT_LEN-1]; assign  next_r  = {r,d_in};\n\n    always @(posedge clk)\n      r <= next_r[INT_LEN-1:0];\n\n    if(SLOW_CLOCK == 0) begin\n      assign  d_in = d[ig];\n    end else begin\n      wire  d_clk;\n      reg   d_r;\n      wire  clr_n;\n\n      assign  d_clk = d[ig];\n      assign  d_in  = d_r;\n      assign  clr_n = ~q[ig] | d_clk; always @(posedge d_clk or negedge clr_n)\n        if(!clr_n)      d_r <= 1'b0;\n        else if(d_clk)  d_r <= 1'b1;\n    end end end endgenerate\n\nendmodule\n",
        "module_name": "altera_tse_xcvr_resync #",
        "module_hash": "37b40a3a6620cf88a62d6749e716d42c",
        "dataset_index": 8961
      },
      "mux_2to1_e5136474": {
        "rtl_code": "module mux_2to1(\n    input A,\n    input B,\n    input SEL,\n    output Y\n);\n\n    assign Y = SEL ? B : A;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "e513647438f7cf92e6a4f081f57b4a1b",
        "dataset_index": 9435
      },
      "watchdog_timer_75c06233": {
        "rtl_code": "\nmodule watchdog_timer (\n  input clk,\n  input rst,\n  output reg wdt // Changed from wire to reg\n);\n\n  parameter timeout = 100; // timeout value in clock cycles\n  \n  reg [7:0] counter; // 8-bit counter to count clock cycles\n  \n  always @(posedge clk) begin\n    if (rst == 1) begin\n      counter <= 0;\n      wdt <= 0;\n    end\n    else begin\n      counter <= counter + 1;\n      if (counter == timeout) begin\n        wdt <= 1;\n      end\n    end\n  end\n  \nendmodule\n",
        "module_name": "watchdog_timer",
        "module_hash": "75c06233154c7a17bc775fe521e334c2",
        "dataset_index": 21065
      },
      "stratixv_output_alignment_2eae73a0": {
        "rtl_code": "\nmodule stratixv_output_alignment(\n    input datain,\n    input clk,\n    input areset,\n    input sreset,\n    input [2:0] enaoutputcycledelay,\n    input enaphasetransferreg,\n    output dataout,\n    output dffin,\n    output dff1t,\n    output dff2t,\n    output dffphasetransfer\n);\n\n    parameter power_up = \"low\";\n    parameter async_mode = \"none\";\n    parameter sync_mode = \"none\";\n    parameter add_output_cycle_delay = 0;\n    parameter add_phase_transfer_reg = 0;\n\n    reg [2:0] delay_counter;\n    reg [2:0] phase_transfer_counter;\n    reg delayed_data;\n    reg dff1t_reg;\n    reg dff2t_reg1;\n    reg dff2t_reg2;\n    reg dffphasetransfer_reg;\n\n    always @(posedge clk or negedge areset) begin\n        if(!areset) begin\n            delay_counter <= 0;\n            phase_transfer_counter <= 0;\n            delayed_data <= 0;\n            dff1t_reg <= 0;\n            dff2t_reg1 <= 0;\n            dff2t_reg2 <= 0;\n            dffphasetransfer_reg <= 0;\n        end else begin\n            if(add_output_cycle_delay) begin\n                if(delay_counter == enaoutputcycledelay) begin\n                    delayed_data <= dffphasetransfer_reg;\n                end else begin\n                    delayed_data <= delayed_data;\n                end\n                delay_counter <= (delay_counter == enaoutputcycledelay) ? 0 : delay_counter + 1;\n            end else begin\n                delayed_data <= dffphasetransfer_reg;\n            end\n\n            if(add_phase_transfer_reg) begin\n                if(phase_transfer_counter == 0) begin\n                    dffphasetransfer_reg <= datain;\n                end else begin\n                    dffphasetransfer_reg <= dffphasetransfer_reg;\n                end\n                phase_transfer_counter <= (phase_transfer_counter == 7) ? 0 : phase_transfer_counter + 1;\n            end else begin\n                dffphasetransfer_reg <= datain;\n            end\n\n            dff1t_reg <= datain;\n            dff2t_reg1 <= dff1t_reg;\n            dff2t_reg2 <= dff1t_reg;\n        end\n    end\n\n    assign dataout = delayed_data;\n    assign dffin = datain;\n    assign dff1t = dff1t_reg;\n    assign dff2t = dff2t_reg1 & dff2t_reg2;\n    assign dffphasetransfer = dffphasetransfer_reg;\n\nendmodule",
        "module_name": "stratixv_output_alignment",
        "module_hash": "2eae73a0cfd38ec27e498c297fdc4b31",
        "dataset_index": 19750
      },
      "oh_dsync  #_53847427": {
        "rtl_code": "module oh_dsync  #(parameter PS    = 2,        parameter DELAY = 0         )\n   (\n    input  clk, input  nreset, input  din, output dout    );\n   \n`ifdef CFG_ASIC\n   asic_dsync asic_dsync (.clk(clk),\n\t\t\t  .nreset(nreset),\n\t\t\t  .din(din),\n\t\t\t  .dout(dout));\n`else\n   reg [PS:0] sync_pipe; \n   always @ (posedge clk or negedge nreset)\t\t \n     if(!nreset)\n       sync_pipe[PS:0] <= 'b0;\n     else\n       sync_pipe[PS:0] <= {sync_pipe[PS-1:0],din};\t      \t      \n   assign dout = (DELAY & sync_pipe[PS]) |  (~DELAY & sync_pipe[PS-1]); `endif endmodule ",
        "module_name": "oh_dsync  #",
        "module_hash": "538474279819e6f4256c324e34ea5f77",
        "dataset_index": 20805
      },
      "sync_gray_48d4674d": {
        "rtl_code": "\nmodule sync_gray (\n\tinput in_clk,\n\tinput in_resetn,\n\tinput [DATA_WIDTH-1:0] in_count,\n\tinput out_resetn,\n\tinput out_clk,\n\toutput [DATA_WIDTH-1:0] out_count\n);\n\nparameter DATA_WIDTH = 1;\nparameter CLK_ASYNC = 1;\n\nreg [DATA_WIDTH-1:0] in_count_gray = 'h0;\nreg [DATA_WIDTH-1:0] out_count_gray_m1 = 'h0;\nreg [DATA_WIDTH-1:0] out_count_gray_m2 = 'h0;\nreg [DATA_WIDTH-1:0] out_count_m = 'h0;\n\nfunction [DATA_WIDTH-1:0] g2b;\n\tinput [DATA_WIDTH-1:0] g;\n\treg   [DATA_WIDTH-1:0] b;\n\tinteger i;\n\tbegin\n\t\tb[DATA_WIDTH-1] = g[DATA_WIDTH-1];\n\t\tfor (i = DATA_WIDTH - 2; i >= 0; i =  i - 1)\n\t\t\tb[i] = b[i + 1] ^ g[i];\n\t\tg2b = b;\n\tend\nendfunction\n\nfunction [DATA_WIDTH-1:0] b2g;\n\tinput [DATA_WIDTH-1:0] b;\n\treg [DATA_WIDTH-1:0] g;\n\tinteger i;\n\tbegin\n\t\tg[DATA_WIDTH-1] = b[DATA_WIDTH-1];\n\t\tfor (i = DATA_WIDTH - 2; i >= 0; i = i -1)\n\t\t\t\tg[i] = b[i + 1] ^ b[i];\n\t\tb2g = g;\n\tend\nendfunction\n\nalways @(posedge in_clk) begin\n\tif (in_resetn == 1'b0) begin\n\t\tin_count_gray <= 'h00;\n\tend else begin\n\t\tin_count_gray <= b2g(in_count);\n\tend\nend\n\nalways @(posedge out_clk) begin\n\tif (out_resetn == 1'b0) begin\n\t\tout_count_gray_m1 <= 'h00;\n\t\tout_count_gray_m2 <= 'h00;\n\t\tout_count_m <= 'h00;\n\tend else begin\n\t\tout_count_gray_m1 <= in_count_gray;\n\t\tout_count_gray_m2 <= out_count_gray_m1;\n\t\tout_count_m <= g2b(out_count_gray_m2);\n\tend\nend\n\nassign out_count = CLK_ASYNC ? out_count_m : in_count;\n\nendmodule\n",
        "module_name": "sync_gray",
        "module_hash": "48d4674de0369583fac0b0173c604181",
        "dataset_index": 21948
      },
      "priority_encoder_mux_45018a99": {
        "rtl_code": "module priority_encoder_mux (\n    input [7:0] in,\n    input a,\n    input b,\n    input clk,\n    output reg out_always,\n    output reg [2:0] pos\n);\n\nreg [7:0] in_reg;\nreg [2:0] pos_reg;\nwire [2:0] pos_wire;\nwire sel;\n\npriority_encoder pe(\n    .in(in_reg),\n    .out(pos_wire)\n);\n\nassign sel = (pos_wire != 3'b0);\n\nalways @(posedge clk) begin\n    if (sel) begin\n        out_always <= b;\n    end else begin\n        out_always <= a;\n    end\nend\n\nalways @(posedge clk) begin\n    if (sel) begin\n        pos_reg <= pos_wire;\n    end else begin\n        pos_reg <= 3'b0;\n    end\nend\n\nalways @(posedge clk) begin\n    in_reg <= in;\nend\n\nalways @* begin\n    pos = pos_reg;\nend\n\nendmodule\n\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] out\n);\n\nalways @* begin\n    casez(in)\n        8'b1xxxxxxx: out = 2;\n        8'b01xxxxxx: out = 1;\n        8'b001xxxxx: out = 0;\n        default: out = 3'b0;\n    endcase\nend\n\nendmodule",
        "module_name": "priority_encoder_mux",
        "module_hash": "45018a99676c36133437e03ba5f09920",
        "dataset_index": 10808
      },
      "shift_register_8297a361": {
        "rtl_code": "module shift_register (\n  input clk,\n  input reset,\n  input load,\n  input shift,\n  input [7:0] data_in,\n  input [7:0] parallel_in,\n  output [7:0] data_out\n);\n\n  reg [7:0] shift_reg;\n  wire [7:0] shifted_data;\n\n  assign shifted_data = {shift_reg[6:0], 1'b0};\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shift_reg <= 8'b0;\n    end else if (load) begin\n      shift_reg <= parallel_in;\n    end else if (shift) begin\n      shift_reg <= shifted_data;\n    end else begin\n      shift_reg <= data_in;\n    end\n  end\n\n  assign data_out = shift_reg;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "8297a361fba77141b61a91b4a7c43a66",
        "dataset_index": 20643
      },
      "compute_tm_count_539f7281": {
        "rtl_code": "module compute_tm_count (\n  input atm_valid,\n  input dtm_valid,\n  input itm_valid,\n  output reg [1:0] compute_tm_count\n);\n\n  always @(*) begin\n    case ({itm_valid, atm_valid, dtm_valid})\n      3'b000: compute_tm_count = 2'b00;\n      3'b001: compute_tm_count = 2'b01;\n      3'b010: compute_tm_count = 2'b01;\n      3'b011: compute_tm_count = 2'b10;\n      3'b100: compute_tm_count = 2'b01;\n      3'b101: compute_tm_count = 2'b10;\n      3'b110: compute_tm_count = 2'b10;\n      3'b111: compute_tm_count = 2'b11;\n    endcase\n  end\n\nendmodule",
        "module_name": "compute_tm_count",
        "module_hash": "539f72812fc0f43ca8fbee2ec69699ec",
        "dataset_index": 20087
      },
      "negate_2704b772": {
        "rtl_code": "module negate (A, B, S, MO);\n   input A, B, S; \n   output MO; \n   \n   assign MO = (S == 1) ? ~B : ~A; \n   \nendmodule",
        "module_name": "negate",
        "module_hash": "2704b772945144eb2f74dff7948609af",
        "dataset_index": 16527
      },
      "DelayBlock_6dd87e5b": {
        "rtl_code": "module DelayBlock (\n  input in,\n  input clk,\n  output reg out\n);\n\nparameter delay = 5; // number of clock cycles\n\nreg [delay-1:0] shift_reg = 0; // shift register to store input signal\n\nalways @(posedge clk) begin\n  shift_reg <= {shift_reg[delay-2:0], in}; // shift input signal into shift register\nend\n\nalways @* begin\n  out <= shift_reg[0]; // output delayed signal\nend\n\nendmodule",
        "module_name": "DelayBlock",
        "module_hash": "6dd87e5bd06f8bc70b1d37aa597cafa4",
        "dataset_index": 13087
      },
      "NOR4X0_8df7bf1e": {
        "rtl_code": "module NOR4X0 (input IN1, IN2, IN3, IN4, output QN, input VDD, VSS);\n\n  wire n1, n2, n3;\n\n  assign n1 = ~(IN1 | IN2);\n  assign n2 = ~(IN3 | IN4);\n  assign n3 = ~(n1 | n2);\n\n  assign QN = n3;\n\nendmodule",
        "module_name": "NOR4X0",
        "module_hash": "8df7bf1e8bf3df0ebd6dda923c7db89e",
        "dataset_index": 4954
      },
      "top__efc7fd8c": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [3:0] write_data, // 4-bit input for the RAM module\n    input [2:0] write_addr, // Address input for the RAM module\n    input write_en, // Write enable input for the RAM module\n    input [3:0] in, // Input signal for the input signal detection module\n    input select, // Select input to choose between RAM module and functional module\n    input [2:0] read_addr, // Address input for the functional module\n    input read_en, // Read enable input for the functional module\n    output [3:0] read_data // 4-bit output from the active module\n);\n\nwire [3:0] ram_data;\nwire [3:0] func_data;\nwire [3:0] in_detect;\n\ndual_port_ram dp_ram (\n    .clk(clk),\n    .reset(reset),\n    .write_data(write_data),\n    .write_addr(write_addr),\n    .write_en(write_en),\n    .read_data(ram_data),\n    .read_addr(read_addr),\n    .read_en(read_en)\n);\n\ninput_signal_detection isd (\n    .clk(clk),\n    .in(in),\n    .out(in_detect)\n);\n\nfunctional_module fm (\n    .ram_data(ram_data),\n    .in_detect(in_detect),\n    .out(func_data)\n);\n\nassign read_data = select ? func_data : ram_data;\n\nendmodule\nmodule dual_port_ram (\n    input clk,\n    input reset,\n    input [3:0] write_data,\n    input [2:0] write_addr,\n    input write_en,\n    output [3:0] read_data,\n    input [2:0] read_addr,\n    input read_en\n);\n\nreg [3:0] memory [7:0];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        memory[write_addr] <= 4'b1111;\n    end else if (write_en) begin\n        memory[write_addr] <= write_data;\n    end\nend\n\nassign read_data = memory[read_addr];\n\nendmodule\nmodule input_signal_detection (\n    input clk,\n    input [3:0] in,\n    output [3:0] out\n);\n\nreg [3:0] prev_in;\n\nalways @(posedge clk) begin\n    prev_in <= in;\nend\n\nassign out = (prev_in == 4'b0001) & (in == 4'b0000) ? 4'b1111 : 4'b0000;\n\nendmodule\nmodule functional_module (\n    input [3:0] ram_data,\n    input [3:0] in_detect,\n    output [3:0] out\n);\n\nassign out = in_detect ? ram_data : 4'b0000;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "efc7fd8c525692d1ae111c5c3e318de6",
        "dataset_index": 2897
      },
      "sky130_fd_sc_ls__and2b_f826846e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__and2b (\n    X  ,\n    A_N,\n    B\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N            );\n    and and0 (and0_out_X, not0_out, B    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__and2b",
        "module_hash": "f826846e452f3dcbdeadc6474fb17a5f",
        "dataset_index": 22465
      },
      "OAI22X1_c009dfd4": {
        "rtl_code": "module OAI22X1 (\n\tA, \n\tB, \n\tC,\n\tY\n);\n   input A;\n   input B;\n   input C;\n   output Y;\n   wire X1;\n   wire X2;\n   wire X3;\n   wire X4;\n   wire X5;\n   wire X6;\n   wire X7;\n   wire X8;\n   wire X9;\n   wire X10;\n   wire X11;\n   wire X12;\n   wire X13;\n   wire X14;\n   wire X15;\n   wire X16;\n\n   assign X1 = ~A & ~B;\n   assign X2 = C;\n   assign X3 = X1 & X2;\n   assign X4 = ~A;\n   assign X5 = ~B;\n   assign X6 = X4 & X5;\n   assign X7 = C;\n   assign X8 = X6 & X7;\n   assign X9 = ~A;\n   assign X10 = B;\n   assign X11 = X9 & X10;\n   assign X12 = C;\n   assign X13 = X11 & X12;\n   assign X14 = A;\n   assign X15 = ~B;\n   assign X16 = X14 & X15 & C;\n   \n   assign Y = X3 | X8 | X13 | X16;\nendmodule",
        "module_name": "OAI22X1",
        "module_hash": "c009dfd4c9a5a0318e53e2b2f07d440b",
        "dataset_index": 2840
      },
      "top_module_da41b73d": {
        "rtl_code": "\nmodule top_module(\n    input wire [7:0] in1,\n    input wire [7:0] in2,\n    output wire [7:0] out\n);\n\n    // Splitting inputs into 4-bit values\n    wire [3:0] in1_hi, in1_lo;\n    wire [3:0] in2_hi, in2_lo;\n    assign in1_hi = in1[7:4];\n    assign in1_lo = in1[3:0];\n    assign in2_hi = in2[7:4];\n    assign in2_lo = in2[3:0];\n\n    // Adding corresponding 4-bit values\n    wire [3:0] sum1, sum2;\n    adder_4bit add1(.in1(in1_hi), .in2(in2_hi), .sum(sum1));\n    adder_4bit add2(.in1(in1_lo), .in2(in2_lo), .sum(sum2));\n\n    // Adding the total sum\n    wire [7:0] out_sum;\n    adder_8bit add3(.in1({4'b0, sum1}), .in2({4'b0, sum2}), .sum(out_sum));\n\n    // Dividing by 4 to get the average\n    assign out = {out_sum[7], out_sum[7:0] >> 2};\n\nendmodule\nmodule split_1_4bit(\n    input wire [7:0] in,\n    output wire [3:0] hi,\n    output wire [3:0] lo\n);\n\n    assign hi = in[7:4];\n    assign lo = in[3:0];\n\nendmodule\nmodule adder_4bit(\n    input wire [3:0] in1,\n    input wire [3:0] in2,\n    output wire [3:0] sum\n);\n\n    assign sum = in1 + in2;\n\nendmodule\nmodule adder_8bit(\n    input wire [7:0] in1,\n    input wire [7:0] in2,\n    output wire [7:0] sum\n);\n\n    assign sum = in1 + in2;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "da41b73de330eda075c46259b482bb9b",
        "dataset_index": 12719
      },
      "add_sub_4bit_0f395607": {
        "rtl_code": "module add_sub_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  input mode,\n  output [3:0] sum,\n  output carry_borrow\n);\n\n  wire [4:0] temp_sum;\n  wire temp_carry_borrow;\n  \n  assign temp_sum = mode ? A - B : A + B;\n  assign carry_borrow = (temp_sum > 4'b1111) ? 1'b1 : 1'b0;\n  assign sum = temp_sum[3:0];\n  \nendmodule\n",
        "module_name": "add_sub_4bit",
        "module_hash": "0f395607110ddb06ac02d7a80475f6e3",
        "dataset_index": 11524
      },
      "FourBitFA_cd11e3ef": {
        "rtl_code": "\nmodule FourBitFA(FA,FB,FCin,FSum,FCout);\n\nparameter SIZE=4;\n\ninput [SIZE-1:0]FA,FB;\noutput [SIZE-1:0]FSum;\ninput FCin;\noutput FCout;\n\nwire [SIZE-1:0] FTemp;\n\nFA FA1(.A(FA[0]),.B(FB[0]),.Cin(FCin),.Sum(FSum[0]),.Cout(FTemp[0])),\nFA2(.A(FA[1]),.B(FB[1]),.Cin(FTemp[0]),.Sum(FSum[1]),.Cout(FTemp[1])),\nFA3(.A(FA[2]),.B(FB[2]),.Cin(FTemp[1]),.Sum(FSum[2]),.Cout(FTemp[2])),\nFA4(.A(FA[3]),.B(FB[3]),.Cin(FTemp[2]),.Sum(FSum[3]),.Cout(FCout));\n\nendmodule\n\nmodule FA(A,B,Cin,Sum,Cout);\n\ninput A,B,Cin;\noutput Sum,Cout;\n\nassign Sum = (A^B)^Cin;\nassign Cout = (A&B)|(A&Cin)|(B&Cin);\n                                                                         \nendmodule\n",
        "module_name": "FourBitFA",
        "module_hash": "cd11e3eff1435545d8584023a2ef2cb4",
        "dataset_index": 16978
      },
      "mux_2to1_e0d249a0": {
        "rtl_code": "module mux_2to1 (\n    input A,\n    input B,\n    input SEL,\n    output Y\n);\n\n    assign Y = SEL ? B : A;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "e0d249a0e479b1416a5920a0b00b72f8",
        "dataset_index": 7240
      },
      "bmu_c84c6fb2": {
        "rtl_code": "\nmodule bmu(input cx0, cx1, output reg [1:0] bm);\n    always @(cx0, cx1) begin\n        case ({cx1,cx0})\n            2'b00: bm=2'b00;\n            2'b01: bm=2'b01;\n            2'b10: bm=2'b10;\n            2'b11: bm=2'b11;\n        endcase\n    end\nendmodule\n",
        "module_name": "bmu",
        "module_hash": "c84c6fb2deba5771a7f549446dcea971",
        "dataset_index": 8117
      },
      "uart_4a5d0c79": {
        "rtl_code": "module uart\n(\n    clk_i,\n    rst_i,\n    tx_busy_o,\n    rx_ready_o,\n    break_o,\n    data_i,\n    wr_i,\n    data_o,\n    rd_i,\n    rxd_i,\n    txd_o\n);\nparameter  [31:0]    UART_DIVISOR = 278;\n\ninput               clk_i ;\ninput               rst_i ;\ninput [7:0]         data_i ;\noutput [7:0]        data_o ;\ninput               wr_i ;\ninput               rd_i ;\noutput              tx_busy_o ;\noutput              rx_ready_o ;\noutput              break_o ;\ninput               rxd_i ;\noutput              txd_o ;\n\nparameter           FULL_BIT = UART_DIVISOR;\nparameter           HALF_BIT = (FULL_BIT / 2);\n\nreg [7:0]           tx_buf;\nreg                 tx_buf_full;\nreg                 tx_busy;\nreg [3:0]           tx_bits;\ninteger             tx_count;\nreg [7:0]           tx_shift_reg;\nreg                 txd_o;\n\nreg                 i_rxd;\nreg [7:0]           data_o;\nreg [3:0]           rx_bits;\ninteger             rx_count;\nreg [7:0]           rx_shift_reg;\nreg                 rx_ready_o;\nreg                 break_o;\n\nalways @ (posedge rst_i or posedge clk_i )\nbegin\n   if (rst_i == 1'b1)\n       i_rxd <= 1'b1;\n   else\n       i_rxd <= rxd_i;\nend\n\nalways @ (posedge clk_i or posedge rst_i )\nbegin\n   if (rst_i == 1'b1)\n   begin\n       rx_bits      <= 0;\n       rx_count     <= 0;\n       rx_ready_o   <= 1'b0;\n       rx_shift_reg <= 8'h00;\n       data_o       <= 8'h00;\n       break_o      <= 1'b0;\n   end\n   else\n   begin\n\n       if (rd_i == 1'b1)\n           rx_ready_o <= 1'b0;\n\n       if (rx_count != 0)\n           rx_count    <= (rx_count - 1);\n       else\n       begin\n           if (rx_bits == 0)\n           begin\n               break_o  <= 1'b0;\n\n               if (i_rxd == 1'b0)\n               begin\n                   rx_count <= HALF_BIT;\n                   rx_bits  <= 1;\n               end\n           end\n           else if (rx_bits == 1)\n           begin\n               if (i_rxd == 1'b0)\n               begin\n                   rx_count     <= FULL_BIT;\n                   rx_bits      <= rx_bits + 1'b1;\n                   rx_shift_reg <= 8'h00;\n               end\n               else\n               begin\n                   rx_bits      <= 0;\n               end\n           end\n           else if (rx_bits == 10)\n           begin\n               if (i_rxd == 1'b1)\n               begin\n                   rx_count     <= 0;\n                   rx_bits      <= 0;\n                   data_o       <= rx_shift_reg;\n                   rx_ready_o   <= 1'b1;\n               end\n               else\n               begin\n                   rx_count     <= FULL_BIT;\n                   rx_bits      <= 0;\n\n                   break_o      <= 1'b1;\n               end\n           end\n           else\n           begin\n               rx_shift_reg[7]  <= i_rxd;\n               rx_shift_reg[6:0]<= rx_shift_reg[7:1];\n               rx_count         <= FULL_BIT;\n               rx_bits          <= rx_bits + 1'b1;\n           end\n       end\n   end\nend\n\nalways @ (posedge clk_i or posedge rst_i )\nbegin\n   if (rst_i == 1'b1)\n   begin\n       tx_count     <= 0;\n       tx_bits      <= 0;\n       tx_busy      <= 1'b0;\n       txd_o        <= 1'b1;\n       tx_shift_reg <= 8'h00;\n       tx_buf       <= 8'h00;\n       tx_buf_full  <= 1'b0;\n   end\n   else\n   begin\n\n       if (wr_i == 1'b1)\n       begin\n           tx_buf       <= data_i;\n           tx_buf_full  <= 1'b1;\n       end\n\n       if (tx_count != 0)\n           tx_count     <= (tx_count - 1);\n       else\n       begin\n\n           if (tx_bits == 0)\n           begin\n\n               tx_busy <= 1'b0;\n\n               if (tx_buf_full == 1'b1)\n               begin\n                   tx_shift_reg <= tx_buf;\n                   tx_busy      <= 1'b1;\n                   txd_o        <= 1'b0;\n                   tx_buf_full  <= 1'b0;\n                   tx_bits      <= 1;\n                   tx_count     <= FULL_BIT;\n               end\n           end\n           else if (tx_bits == 9)\n           begin\n               txd_o    <= 1'b1;\n               tx_bits  <= 0;\n               tx_count <= FULL_BIT;\n           end\n           else\n           begin\n               txd_o            <= tx_shift_reg[0];\n               tx_shift_reg[6:0]<= tx_shift_reg[7:1];\n               tx_bits          <= tx_bits + 1'b1;\n               tx_count         <= FULL_BIT;\n           end\n        end\n    end\nend\n\nassign tx_busy_o = (tx_busy | tx_buf_full | wr_i);\n\nendmodule\n",
        "module_name": "uart",
        "module_hash": "4a5d0c79f5b611f2d394ee1839727771",
        "dataset_index": 21640
      },
      "four_to_two_12fc26f1": {
        "rtl_code": "module four_to_two(\n    input [3:0] in_data,\n    output reg [1:0] out_data\n);\n\nalways @(*) begin\n    case(in_data)\n        4'b0000: out_data = 2'b00;\n        4'b0001: out_data = 2'b01;\n        4'b0010: out_data = 2'b10;\n        4'b0011: out_data = 2'b11;\n        default: out_data = 2'b00;\n    endcase\nend\n\nendmodule",
        "module_name": "four_to_two",
        "module_hash": "12fc26f1a02ca6b7ca5484adf78fa811",
        "dataset_index": 17650
      },
      "diode__9fa2f090": {
        "rtl_code": "module diode_module (\n    DIODE,\n    VPWR ,\n    VGND ,\n    VPB  ,\n    VNB,\n    VOUT\n);\n\n    input DIODE;\n    input signed [4:0] VPWR ;\n    input signed [4:0] VGND ;\n    input signed [4:0] VPB  ;\n    input signed [4:0] VNB  ;\n    output signed [4:0] VOUT;\n\n    assign VOUT = (DIODE == 1) ? (VPB - VNB) : 0;\n\nendmodule",
        "module_name": "diode_",
        "module_hash": "9fa2f090b708d7abac85d2bab637d332",
        "dataset_index": 18960
      },
      "tmu2_split #_eb1d8f5a": {
        "rtl_code": "\n\nmodule tmu2_split #(\n\tparameter cache_depth = 13,\n\tparameter fml_depth = 26\n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\n\toutput busy,\n\n\tinput pipe_stb_i,\n\toutput pipe_ack_o,\n\tinput [fml_depth-1-1:0] dadr,\n\tinput [fml_depth-1:0] tadra,\n\tinput [fml_depth-1:0] tadrb,\n\tinput [fml_depth-1:0] tadrc,\n\tinput [fml_depth-1:0] tadrd,\n\tinput [5:0] x_frac,\n\tinput [5:0] y_frac,\n\tinput miss_a,\n\tinput miss_b,\n\tinput miss_c,\n\tinput miss_d,\n\t\n\t\n\toutput reg frag_pipe_stb_o,\n\tinput frag_pipe_ack_i,\n\toutput reg [fml_depth-1-1:0] frag_dadr,\n\toutput [cache_depth-1:0] frag_tadra, \n\toutput [cache_depth-1:0] frag_tadrb,\n\toutput [cache_depth-1:0] frag_tadrc,\n\toutput [cache_depth-1:0] frag_tadrd,\n\toutput reg [5:0] frag_x_frac,\n\toutput reg [5:0] frag_y_frac,\n\toutput frag_miss_a,\n\toutput frag_miss_b,\n\toutput frag_miss_c,\n\toutput frag_miss_d,\n\n\t\n\toutput reg fetch_pipe_stb_o,\n\tinput fetch_pipe_ack_i,\n\toutput [fml_depth-5-1:0] fetch_tadra, \n\toutput [fml_depth-5-1:0] fetch_tadrb,\n\toutput [fml_depth-5-1:0] fetch_tadrc,\n\toutput [fml_depth-5-1:0] fetch_tadrd,\n\toutput fetch_miss_a,\n\toutput fetch_miss_b,\n\toutput fetch_miss_c,\n\toutput fetch_miss_d\n);\n\n\nreg [fml_depth-1:0] r_tadra;\nreg [fml_depth-1:0] r_tadrb;\nreg [fml_depth-1:0] r_tadrc;\nreg [fml_depth-1:0] r_tadrd;\nreg r_miss_a;\nreg r_miss_b;\nreg r_miss_c;\nreg r_miss_d;\n\nassign frag_tadra = r_tadra[cache_depth-1:0];\nassign frag_tadrb = r_tadrb[cache_depth-1:0];\nassign frag_tadrc = r_tadrc[cache_depth-1:0];\nassign frag_tadrd = r_tadrd[cache_depth-1:0];\nassign frag_miss_a = r_miss_a;\nassign frag_miss_b = r_miss_b;\nassign frag_miss_c = r_miss_c;\nassign frag_miss_d = r_miss_d;\n\nassign fetch_tadra = r_tadra[fml_depth-1:5];\nassign fetch_tadrb = r_tadrb[fml_depth-1:5];\nassign fetch_tadrc = r_tadrc[fml_depth-1:5];\nassign fetch_tadrd = r_tadrd[fml_depth-1:5];\nassign fetch_miss_a = r_miss_a;\nassign fetch_miss_b = r_miss_b;\nassign fetch_miss_c = r_miss_c;\nassign fetch_miss_d = r_miss_d;\n\nreg data_valid;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tfrag_pipe_stb_o <= 1'b0;\n\t\tfetch_pipe_stb_o <= 1'b0;\n\tend else begin\n\t\tif(frag_pipe_ack_i)\n\t\t\tfrag_pipe_stb_o <= 1'b0;\n\t\tif(fetch_pipe_ack_i)\n\t\t\tfetch_pipe_stb_o <= 1'b0;\n\t\tif(pipe_ack_o) begin\n\t\t\tfrag_pipe_stb_o <= pipe_stb_i;\n\t\t\tfetch_pipe_stb_o <= pipe_stb_i & (miss_a | miss_b | miss_c | miss_d);\n\t\t\tfrag_dadr <= dadr;\n\t\t\tr_tadra <= tadra;\n\t\t\tr_tadrb <= tadrb;\n\t\t\tr_tadrc <= tadrc;\n\t\t\tr_tadrd <= tadrd;\n\t\t\tfrag_x_frac <= x_frac;\n\t\t\tfrag_y_frac <= y_frac;\n\t\t\tr_miss_a <= miss_a;\n\t\t\tr_miss_b <= miss_b;\n\t\t\tr_miss_c <= miss_c;\n\t\t\tr_miss_d <= miss_d;\n\t\tend\n\tend\nend\n\nassign busy = frag_pipe_stb_o | fetch_pipe_stb_o;\nassign pipe_ack_o = (~frag_pipe_stb_o & ~fetch_pipe_stb_o) | (frag_pipe_ack_i & fetch_pipe_ack_i);\n\nendmodule\n",
        "module_name": "tmu2_split #",
        "module_hash": "eb1d8f5a38b7639a5eacf04cd0c1d4f7",
        "dataset_index": 23978
      },
      "flt_fx_cd9bced9": {
        "rtl_code": "\n\nmodule flt_fx\n\t(\n\tinput\t[31:0]\tfp_in,         output reg [31:0] int_out      );\nwire    [7:0]   bias_exp;       \nwire    [7:0]   bias_exp2;      \nwire    [39:0]  fixed_out2;     \nwire    [47:0]  bias_mant;      \nreg     [38:0]  int_fixed_out;\n\nreg    [31:0]  fixed_out;\n\nassign bias_mant = {25'h0001, fp_in[22:0]};\nassign bias_exp = fp_in[30:23] - 8'd127;\nassign bias_exp2 = ~bias_exp + 8'h1;\n\nalways @* begin\n\tif (fp_in[30:0] == 31'b0) int_fixed_out = 0;\n  \telse if (bias_exp[7]) int_fixed_out = bias_mant[38:0] >> bias_exp2;\n  \telse int_fixed_out = bias_mant[38:0] << bias_exp;\n\n\tfixed_out = int_fixed_out[38:7] + int_fixed_out[6];\n\tint_out = (fp_in[31]) ? ~fixed_out + 1 : fixed_out;\nend\n\nendmodule\n\n\n\n",
        "module_name": "flt_fx",
        "module_hash": "cd9bced982cb70607614d105f1c29bc9",
        "dataset_index": 22808
      },
      "up_counter_4bit_a4f57298": {
        "rtl_code": "module up_counter_4bit (\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "up_counter_4bit",
        "module_hash": "a4f57298ccaffd6e4b0a7a3b9f6bb5c6",
        "dataset_index": 4424
      },
      "clock_gate_bde67c05": {
        "rtl_code": "module clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output wire ECK\n);\n\n  TLATNTSCAX2TS latch (\n    .E(EN),\n    .SE(TE),\n    .CK(CLK),\n    .ECK(ECK)\n  );\n\n\nendmodule\n\nmodule TLATNTSCAX2TS (\n  input E,\n  input SE,\n  input CK,\n  output reg ECK\n);\n\n  always @* begin\n    ECK <= E & SE & CK;\n  end\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "bde67c0525ab5b762178fd288fcf0eab",
        "dataset_index": 2955
      },
      "full_adder_5d8c0e2f": {
        "rtl_code": "module full_adder(\n    input a,\n    input b,\n    input cin,  \n    output sum,\n    output carry\n);\n    // Intermediate wires\n    wire w1, w2, w3;\n\n    assign w1 = a ^ b;      // XOR for sum calculation\n    assign w2 = a & b;      // AND for direct carry\n    assign w3 = w1 & cin;   // AND for carry from lower bits\n\n    assign sum = w1 ^ cin;  // Final sum with carry-in\n    assign carry = w2 | w3; // Carry is the OR of direct carry and propagated carry\nendmodule\n",
        "module_name": "full_adder",
        "module_hash": "5d8c0e2f65d196f12c067faae4e3e98d",
        "dataset_index": 182
      },
      "ripple_carry_adder_6b4329b4": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] sum,\n    output reg carry_out\n);\n\n    reg [3:0] carry;\n    \n    always @(*) begin\n        {carry_out, sum} = A + B + carry;\n    end\n    \n    always @(posedge carry_out) begin\n        carry <= carry_out;\n    end\n    \nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "6b4329b4184ac7f130e47a212eff9f40",
        "dataset_index": 9700
      },
      "full_adder_c53a77af": {
        "rtl_code": "module full_adder (\n    input a, b, cin,\n    output cout, sum\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule bit_reversal (\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign out = {in[7], in[6], in[5], in[4], in[3], in[2], in[1], in[0]};\n\nendmodule\n\nmodule final_module (\n    input [7:0] in,\n    input a, b, cin,\n    output cout, sum,\n    output [7:0] out\n);\n\n    wire [7:0] reversed_in;\n    bit_reversal br(\n        .in(in),\n        .out(reversed_in)\n    );\n\n    wire cout_fa;\n    wire sum_fa;\n    full_adder fa(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum_fa),\n        .cout(cout_fa)\n    );\n\n    assign sum = sum_fa;\n    assign cout = cout_fa;\n\n    assign out = sum | reversed_in;\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    input a, b, cin,\n    output cout, sum,\n    output [7:0] out\n);\n\n    final_module fm(\n        .in(in),\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(cout),\n        .out(out)\n    );\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "c53a77af266f6e17a38bf77011c55b2a",
        "dataset_index": 19778
      },
      "calculator_a2c2402a": {
        "rtl_code": "module calculator(\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op,\n    output reg [31:0] c\n);\n\nalways @*\nbegin\n    case(op)\n        2'b00: c = a + b; // addition\n        2'b01: c = a - b; // subtraction\n        2'b10: c = a * b; // multiplication\n        2'b11: c = a / b; // division\n        default: c = 0;   // default to 0 if op is invalid\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "a2c2402a483f4f84371d0671db2c9877",
        "dataset_index": 5112
      },
      "pwm_generator_54f644a5": {
        "rtl_code": "module pwm_generator(\n    input Clk,\n    input Reset,\n    input [3:0] DutyCycle,\n    output reg PWM\n);\n\nreg [15:0] counter;\n\nalways @(posedge Clk) begin\n    if (Reset) begin\n        counter <= 0;\n        PWM <= 0;\n    end else begin\n        counter <= counter + 1;\n        if (counter == 16000) begin\n            counter <= 0;\n            PWM <= (counter < DutyCycle);\n        end\n    end\nend\n\nendmodule",
        "module_name": "pwm_generator",
        "module_hash": "54f644a5a17dd10e8a20c2ca9d9d8f3a",
        "dataset_index": 20255
      },
      "top__ab4a563c": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output reg [7:0] q,\n    input [7:0] in,\n    output [2:0] pos\n);\n\nwire [7:0] counter_out;\nwire [7:0] register_out;\nwire [2:0] priority_encoder_out;\n\ncounter my_counter (\n    .clk(clk),\n    .reset(reset),\n    .out(counter_out)\n);\n\nregister my_register (\n    .clk(clk),\n    .reset(reset),\n    .d(d),\n    .q(register_out)\n);\n\npriority_encoder my_priority_encoder (\n    .in(in),\n    .pos(priority_encoder_out)\n);\n\nassign pos = priority_encoder_out;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        case (priority_encoder_out)\n            3'b000: q <= register_out;\n            3'b001: q <= counter_out;\n            default: q <= 8'b0;\n        endcase\n    end\nend\n\nendmodule\nmodule counter (\n    input clk,\n    input reset,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 8'b0;\n    end else begin\n        out <= out + 1;\n    end\nend\n\nendmodule\nmodule register (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @(*) begin\n    if (in[7]) pos <= 3'b111;\n    else if (in[6]) pos <= 3'b110;\n    else if (in[5]) pos <= 3'b101;\n    else if (in[4]) pos <= 3'b100;\n    else if (in[3]) pos <= 3'b011;\n    else if (in[2]) pos <= 3'b010;\n    else if (in[1]) pos <= 3'b001;\n    else if (in[0]) pos <= 3'b000;\n    else pos <= 3'b000;\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "ab4a563ca9def8123ea662448a320690",
        "dataset_index": 1859
      },
      "can_transmitter_d8a09cd7": {
        "rtl_code": "\nmodule can_transmitter (\n  input clk,\n  input rst,\n  input [7:0] data,\n  input [10:0] id,\n  input [3:0] dlc,\n  output tx_en,\n  output [7:0] tx_data,\n  output [10:0] tx_id,\n  output [3:0] tx_dlc\n);\n\n  // Define the CAN message format\n  parameter SOF = 1'b0; // Start of Frame bit\n  parameter RTR = 1'b0; // Remote Transmission Request bit\n  parameter IDE = 1'b1; // Identifier Extension bit\n  parameter SRR = 1'b1; // Substitute Remote Request bit\n  parameter EOF = 7'b1111111; // End of Frame bits\n  \n  // Define the bit timing parameters\n  parameter TQ = 8; // Time Quanta\n  parameter BRP = 4; // Baud Rate Prescaler\n  parameter SJW = 1; // Synchronization Jump Width\n  parameter PROP = 2; // Propagation Segment\n  parameter PHASE1 = 3; // Phase Segment 1\n  parameter PHASE2 = 2; // Phase Segment 2\n  \n  // Define the internal signals\n  reg [15:0] bit_counter;\n  reg [3:0] state;\n  reg [7:0] tx_data_reg;\n  reg [10:0] tx_id_reg;\n  reg [3:0] tx_dlc_reg;\n  reg tx_en_reg;\n  \n  // Initialize the internal signals\n  initial begin\n    tx_data_reg <= 8'h00;\n    tx_id_reg <= 11'h000;\n    tx_dlc_reg <= 4'h0;\n    bit_counter <= 16'h0000;\n    state <= 4'h0;\n  end\n  \n  // Define the state machine\n  always @(posedge clk) begin\n    if (rst) begin\n      tx_data_reg <= 8'h00;\n      tx_id_reg <= 11'h000;\n      tx_dlc_reg <= 4'h0;\n      bit_counter <= 0;\n      state <= 4'h0;\n    end\n    else begin\n      case (state)\n        4'h0: begin // Idle state\n          if (id != 11'h000) begin\n            tx_id_reg <= id;\n            tx_dlc_reg <= dlc;\n            tx_data_reg <= data;\n            state <= 4'h1;\n          end\n        end\n        4'h1: begin // Arbitration state\n          tx_en_reg <= 1'b1;\n            tx_id_reg <= {SOF, RTR, IDE, SRR, tx_id_reg};\n            tx_dlc_reg <= tx_dlc_reg;\n            tx_data_reg <= tx_data_reg;\n            bit_counter <= TQ * (BRP + 1) * (PROP + PHASE1 + PHASE2);\n          state <= 4'h2;\n        end\n        4'h2: begin // Data state\n          if (bit_counter == 0) begin\n            state <= 4'h3;\n          end\n          else begin\n            bit_counter <= bit_counter - 1;\n          end\n        end\n        4'h3: begin // CRC state\n          if (bit_counter == 0) begin\n            state <= 4'h4;\n          end\n          else begin\n            bit_counter <= bit_counter - 1;\n          end\n        end\n        4'h4: begin // ACK state\n          if (bit_counter == 0) begin\n            state <= 4'h5;\n          end\n          else begin\n            bit_counter <= bit_counter - 1;\n          end\n        end\n        4'h5: begin // End of Frame state\n          if (bit_counter == 0) begin\n            tx_en_reg <= 0;\n            state <= 4'h0;\n          end\n          else begin\n            bit_counter <= bit_counter - 1;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // Assign the outputs\n  assign tx_en = tx_en_reg;\n  assign tx_data = tx_data_reg;\n  assign tx_id = tx_id_reg;\n  assign tx_dlc = tx_dlc_reg;\n\nendmodule\n",
        "module_name": "can_transmitter",
        "module_hash": "d8a09cd78536a772b2c2846713971b19",
        "dataset_index": 7869
      },
      "and_async_reset_47201cfb": {
        "rtl_code": "module and_async_reset (\n    input a,\n    input b,\n    input reset,\n    output reg out\n);\n\nalways @(a, b, reset) begin\n    if (reset == 1'b0) begin\n        out <= 1'b0; // reset signal is asserted, output is 0\n    end\n    else begin\n        out <= a & b; // reset signal is de-asserted, output is AND of a and b\n    end\nend\n\nendmodule",
        "module_name": "and_async_reset",
        "module_hash": "47201cfbd2bf50ecfff60b63682a8a8c",
        "dataset_index": 10861
      },
      "sequential_circuit_d7878243": {
        "rtl_code": "module sequential_circuit (\n  input clk,\n  input a,\n  output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n  q1 <= a;\n  q2 <= q1;\n  q <= q2;\nend\n\nendmodule\n",
        "module_name": "sequential_circuit",
        "module_hash": "d7878243fd8d4b9501e46e94c07b3d4e",
        "dataset_index": 10729
      },
      "cog_vid_95066eae": {
        "rtl_code": "module cog_vid\n(\n    input clk_cog,\n    input clk_vid,\n    input ena,\n    input setvid,\n    input setscl,\n    input [31:0] data,\n    input [31:0] pixel,\n    input [31:0] color,\n    input [7:0] aural,\n    input carrier,\n    output ack,\n    output [31:0] pin_out\n);\n\nreg [31:0] vid;\nreg [31:0] scl;\n\nalways @(posedge clk_cog or negedge ena) begin\n    if (!ena)\n        vid <= 32'b0;\n    else if (setvid)\n        vid <= data;\nend\n\nalways @(posedge clk_cog) begin\n    if (setscl)\n        scl <= data;\nend\n\nreg [7:0] cnts;\nreg [7:0] cnt;\nreg [11:0] set;\nreg [31:0] pixels;\nreg [31:0] colors;\n\nwire enable = |vid[30:29];\n\nwire vclk;\nassign vclk = clk_vid & enable;\n\nwire new_set = (set == 12'b1);\nwire new_cnt = (cnt == 8'b1);\n\nalways @(posedge vclk) begin\n    if (new_set)\n        cnts <= scl[19:12];\nend\n\nalways @(posedge vclk) begin\n    if (new_set)\n        cnt <= scl[19:12];\n    else if (new_cnt)\n        cnt <= cnts;\n    else\n        cnt <= cnt - 1'b1;\nend\n\nalways @(posedge vclk) begin\n    if (new_set)\n        set <= scl[11:0];\n    else\n        set <= set - 1'b1;\nend\n\nalways @(posedge vclk) begin\n    if (new_set || new_cnt)\n        pixels <= new_set ? pixel : (vid[28] ? {pixels[31:30], pixels[31:2]} : {pixels[31], pixels[31:1]});\nend\n\nalways @(posedge vclk) begin\n    if (new_set)\n        colors <= color;\nend\n\nreg cap;\nreg [1:0] snc;\n\nalways @(posedge vclk or posedge snc[1]) begin\n    if (snc[1])\n        cap <= 1'b0;\n    else if (new_set)\n        cap <= 1'b1;\nend\n\nalways @(posedge clk_cog) begin\n    if (enable)\n        snc <= {snc[0], cap};\nend\n\nassign ack = snc[0];\n\nreg [7:0] discrete;\n\nwire [31:0] colorx = colors >> {vid[28] && pixels[1], pixels[0], 3'b000};\n\nalways @(posedge vclk) begin\n    discrete <= colorx[7:0];\nend\n\nreg [3:0] phase;\nreg [3:0] baseband;\n\nalways @(posedge vclk) begin\n    phase <= phase + 1'b1;\nend\n\nwire [3:0] colorphs = discrete[7:4] + phase;\n\nwire [2:0] colormod = discrete[2:0] + {discrete[3] && colorphs[3], discrete[3] && colorphs[3], discrete[3]};\n\nalways @(posedge vclk) begin\n    baseband <= {discrete[3] && colorphs[3], vid[26] ? colormod : discrete[2:0]};\nend\n\nreg [2:0] composite;\n\nalways @(posedge vclk) begin\n    composite <= vid[27] ? colormod : discrete[2:0];\nend\n\nwire [63:0] level = 64'b0011_0100_0100_0101_0101_0110_0110_0111_0011_0011_0010_0010_0001_0001_0000_0000;\n\nwire [3:0] broadcast = {carrier ^ aural[vid[25:23]], level[{carrier, composite}*4 +: 3]};\n\nwire [7:0] outp = vid[30] ? vid[29] ? {baseband, broadcast} : {broadcast, baseband} : discrete;\n\nassign pin_out = enable ? {24'b0, outp & vid[7:0]} << {vid[10:9], 3'b000} : 32'b0;\n\nendmodule",
        "module_name": "cog_vid",
        "module_hash": "95066eae46cd5314e8825e1d9e3d27bd",
        "dataset_index": 5347
      },
      "AR_TXD_5051c6e4": {
        "rtl_code": "\nmodule AR_TXD (\n\tinput clk, output wire ce, input [1:0] Nvel, output wire TXD1, input [7:0] ADR, output wire TXD0, input [22:0]DAT, output wire SLP, input st, output reg en_tx = 0, output wire T_cp, output reg FT_cp = 0, output wire SDAT, output reg QM = 0, output reg[5:0]cb_bit = 0, output reg en_tx_word = 0, input wire reset); \n\nparameter Fclk = 50000000 ; parameter V1Mb = 1000000 ; parameter V100kb = 100000 ; parameter V50kb = 50000 ; parameter V12_5kb = 12500 ; wire [10:0]AR_Nt = (Nvel [1:0] == 3)? (Fclk / (2 * V1Mb)) : (Nvel [1:0] == 2)? (Fclk / (2 * V100kb)) : (Nvel [1:0] == 1)? (Fclk / (2 * V50kb)) : (Fclk / (2 * V12_5kb)); reg [10:0]cb_tce = 0; reg [ 7:0]sr_adr = 0; reg [22:0]sr_dat = 0; wire ce_tact = (cb_tce == AR_Nt); assign ce = ce_tact & QM; assign T_cp = (cb_bit == 31); wire T_adr_dat = en_tx & !T_cp; wire ce_end_word = (cb_bit == 35) & ce; assign SDAT = sr_adr[7] | (T_cp & FT_cp); assign TXD1 = en_tx & QM & SDAT; assign TXD0 = en_tx & QM & !SDAT; assign SLP = (Nvel ==0); wire start = st & !en_tx_word; always @ (posedge clk) begin\n\tif (cb_bit == 32 || reset) \n\tbegin\n\t\ten_tx <= 0;\n\t\tFT_cp <= 0;\n\t\tQM <= 0;\n\t\tcb_bit <= 0;\n\t\ten_tx_word <= 0;\n\t\tcb_tce <= 0;\n\t\tsr_adr <= 0;\n\t\tsr_dat <= 0;\n\tend\n\telse\n\tbegin\n\t\tcb_tce <= (start | ce_tact) ? 1 : cb_tce + 1;\n\t\tQM <= start ? 0 : (en_tx & ce_tact) ? !QM : QM; cb_bit <= start ? 0 : (en_tx_word & ce) ? cb_bit+1 : cb_bit; en_tx_word <= start ? 1 : ce_end_word ? 0 : en_tx_word; \n\t\ten_tx <= start ? 1 : (T_cp & ce) ? 0 : en_tx; FT_cp <= (start | (T_cp & ce)) ? 1 : (sr_adr[7] & ce & T_adr_dat) ? !FT_cp : FT_cp; \n\t\tsr_adr <= start ? ADR : (ce & en_tx) ? sr_adr << 1 | sr_dat[0] : sr_adr; \n\t\tsr_dat <= start ? DAT : (ce & en_tx) ? sr_dat >> 1 : sr_dat; \n\tend\nend\n\nendmodule",
        "module_name": "AR_TXD",
        "module_hash": "5051c6e40b9b1c4ed6f346eccbb51b01",
        "dataset_index": 23502
      },
      "sky130_fd_sc_lp__a41oi_a499ddba": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a41oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2, A3, A4 );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a41oi",
        "module_hash": "a499ddba9a6f55b3bbdb6fff6ce6122e",
        "dataset_index": 23227
      },
      "circl_s_5642cbb3": {
        "rtl_code": "module circl_s(\n    input wire [4:0] in_addr,\n    output reg [4:0] out_word\n);\n\nalways @*\n    case(in_addr)\n        5'h00: out_word = 5'h00;\n        5'h01: out_word = 5'h05;\n        5'h02: out_word = 5'h09;\n        5'h03: out_word = 5'h0B;\n        5'h04: out_word = 5'h0D;\n        5'h05: out_word = 5'h0F;\n        5'h06: out_word = 5'h10;\n        5'h07: out_word = 5'h12;\n        5'h08: out_word = 5'h13;\n        5'h09: out_word = 5'h14;\n        5'h0A: out_word = 5'h15;\n        5'h0B: out_word = 5'h16;\n        5'h0C: out_word = 5'h17;\n        5'h0D: out_word = 5'h17;\n        5'h0E: out_word = 5'h18;\n        5'h0F: out_word = 5'h19;\n        5'h10: out_word = 5'h19;\n        5'h11: out_word = 5'h1A;\n        5'h12: out_word = 5'h1A;\n        5'h13: out_word = 5'h1B;\n        5'h14: out_word = 5'h1B;\n        5'h15: out_word = 5'h1C;\n        5'h16: out_word = 5'h1C;\n        5'h17: out_word = 5'h1C;\n        5'h18: out_word = 5'h1C;\n        5'h19: out_word = 5'h1D;\n        5'h1A: out_word = 5'h1D;\n        5'h1B: out_word = 5'h1D;\n        5'h1C: out_word = 5'h1D;\n        5'h1D: out_word = 5'h1D;\n        5'h1E: out_word = 5'h1D;\n        5'h1F: out_word = 5'h00;\n    endcase\n\nendmodule",
        "module_name": "circl_s",
        "module_hash": "5642cbb3f5b21a3d4754a5512626b9f9",
        "dataset_index": 3561
      },
      "mux4to1_afbe31b6": {
        "rtl_code": "\nmodule mux4to1(D0, D1, D2, D3, S0, S1, Y);\n   input D0, D1, D2, D3, S0, S1;\n   output Y;\n   \n   wire notS0, notS1, notS0andS1, S0andnotS1, notS0andnotS1, S0andS1;\n   \n   //inverting select signals\n   assign notS0 = ~S0;\n   assign notS1 = ~S1;\n   \n   //creating intermediate signals for output\n   assign notS0andS1 = notS0 & S1;\n   assign S0andnotS1 = S0 & notS1;\n   assign notS0andnotS1 = notS0 & notS1;\n   assign S0andS1 = S0 & S1;\n   \n   //multiplexer output\n   assign Y = (D0 & notS0andnotS1) |\n               (D1 & S0andnotS1) |\n               (D2 & notS0andS1) |\n               (D3 & S0andS1);\nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "afbe31b60e2e0bf9faa182da4c00f8d9",
        "dataset_index": 19447
      },
      "counter_7a466912": {
        "rtl_code": "module counter (\n  input clk,\n  input rst,\n  output reg [1:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 2'b0;\n    end else if (count == 2'b11) begin\n      count <= 2'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "7a46691283f0c2261cbb2cb3a9e8c324",
        "dataset_index": 9197
      },
      "note2dds_f1af6c0d": {
        "rtl_code": "module note2dds(clk, note, adder);\n\ninput wire clk;\ninput wire [8:0] note; output [31:0] adder;\n\nreg [31:0] adder_tbl [15:0];\nreg [3:0] addr;\nreg [3:0] divider;\n\ninitial begin\n   addr <= 4'd0;\n\tdivider <= 4'd0;\n\tadder_tbl[ 4'd0] <= 32'd01438301;\n\tadder_tbl[ 4'd1] <= 32'd01523827;\n\tadder_tbl[ 4'd2] <= 32'd01614439;\n\tadder_tbl[ 4'd3] <= 32'd01710438;\n\tadder_tbl[ 4'd4] <= 32'd01812146;\n\tadder_tbl[ 4'd5] <= 32'd01919902;\n\tadder_tbl[ 4'd6] <= 32'd02034065;\n\tadder_tbl[ 4'd7] <= 32'd02155017;\n\tadder_tbl[ 4'd8] <= 32'd02283161;\n\tadder_tbl[ 4'd9] <= 32'd02418925;\n\tadder_tbl[4'd10] <= 32'd02562762;\n\tadder_tbl[4'd11] <= 32'd02715152;\n\tadder_tbl[4'd12] <= 32'd0;\n\tadder_tbl[4'd13] <= 32'd0;\n\tadder_tbl[4'd14] <= 32'd0;\n\tadder_tbl[4'd15] <= 32'd0;\nend\n\nassign adder = adder_tbl[addr] >> divider;\n\nwire [5:0] diap   = (note <  12) ? 6'd00 :\n\t\t\t\t\t     (note <  24) ? 6'd01 :\n\t\t\t\t\t     (note <  36) ? 6'd02 :\n\t\t\t\t\t     (note <  48) ? 6'd03 :\n\t\t\t\t\t     (note <  60) ? 6'd04 :\n\t\t\t\t\t     (note <  72) ? 6'd05 :\n\t\t\t\t\t     (note <  84) ? 6'd06 :\n\t\t\t\t\t     (note <  96) ? 6'd07 :\n\t\t\t\t\t     (note < 108) ? 6'd08 :\n\t\t\t\t\t     (note < 120) ? 6'd09 : \n\t\t\t\t\t     (note < 132) ? 6'd10 : \n\t\t\t\t\t     (note < 144) ? 6'd11 : \n\t\t\t\t\t     (note < 156) ? 6'd12 : \n\t\t\t\t\t     (note < 168) ? 6'd13 : \n\t\t\t\t\t     (note < 180) ? 6'd14 : \n\t\t\t\t\t     (note < 192) ? 6'd15 : \n\t\t\t\t\t     (note < 204) ? 6'd16 : \n\t\t\t\t\t     (note < 216) ? 6'd17 : \n\t\t\t\t\t     (note < 228) ? 6'd18 : \n\t\t\t\t\t     (note < 240) ? 6'd19 : \n\t\t\t\t\t     (note < 252) ? 6'd20 : \n\t\t\t\t\t     (note < 264) ? 6'd21 : \n\t\t\t\t\t     (note < 276) ? 6'd22 : \n\t\t\t\t\t     (note < 288) ? 6'd23 : \n\t\t\t\t\t     (note < 300) ? 6'd24 : \n\t\t\t\t\t     (note < 312) ? 6'd25 : \n\t\t\t\t\t     (note < 324) ? 6'd26 : \n\t\t\t\t\t     (note < 336) ? 6'd27 : \n\t\t\t\t\t     (note < 348) ? 6'd28 : \n\t\t\t\t\t     (note < 360) ? 6'd29 : \n\t\t\t\t\t     (note < 372) ? 6'd30 : \n\t\t\t\t\t     (note < 384) ? 6'd31 : \n\t\t\t\t\t     (note < 396) ? 6'd32 : \n\t\t\t\t\t     (note < 408) ? 6'd33 : \n\t\t\t\t\t     (note < 420) ? 6'd34 : \n\t\t\t\t\t     (note < 432) ? 6'd35 : \n\t\t\t\t\t     (note < 444) ? 6'd36 : \n\t\t\t\t\t     (note < 456) ? 6'd37 : \n\t\t\t\t\t     (note < 468) ? 6'd38 : \n\t\t\t\t\t     (note < 480) ? 6'd39 : \n\t\t\t\t\t     (note < 492) ? 6'd40 : \n\t\t\t\t\t     (note < 504) ? 6'd41 : 6'd042 ;\n\nwire [6:0] c_addr = note - (diap * 4'd012); \n\t\t\t\t\t\t \nalways @ (posedge clk) begin\n\taddr    <= c_addr[3:0];\n\tdivider <= 6'd042 - diap;\nend\n\nendmodule\n",
        "module_name": "note2dds",
        "module_hash": "f1af6c0d1cc884cd49082f901af6f961",
        "dataset_index": 24012
      },
      "binary_adder_eedf4a3c": {
        "rtl_code": "module binary_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] xor_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n\n    // Calculate the XOR of A and B\n    assign xor_result = A ^ B;\n\n    // Calculate the AND of A and B\n    assign and_result = A & B;\n\n    // Calculate the OR of the AND result and the carry-in signal\n    assign or_result = and_result | (Cin << 1);\n\n    // Calculate the sum\n    assign Sum = xor_result ^ or_result;\n\n    // Calculate the carry-out signal\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "eedf4a3cee80a7f74f33b722ec98e0b6",
        "dataset_index": 15393
      },
      "barrel_shifter_78c4aae1": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] A,\n    input [1:0] shift_amount,\n    input shift_dir,\n    output [3:0] Y\n);\n\n    reg [3:0] shifted;\n\n    always @(*) begin\n        if (shift_dir) // left shift\n            shifted = {A[shift_amount[1:0]-1:0], 4'b0};\n        else // right shift\n            shifted = {4'b0, A[3:shift_amount]};\n    end\n\n    assign Y = shifted;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "78c4aae18b16fc253d1203424cf92812",
        "dataset_index": 1028
      },
      "fifo #_b66280e3": {
        "rtl_code": "module fifo #(\n\nparameter WIDTH = 8,\nparameter DEPTH = 12\n\n)(\n    input clk,\n    input reset,\n    input [WIDTH-1:0] data_in,\n    input data_in_start,\n    input data_in_end,\n    output reg [WIDTH-1:0] data_out,\n    output reg data_out_start,\n    output reg data_out_end\n);\n\nreg [WIDTH-1:0] buffer [0:DEPTH-1];\nreg [DEPTH-1:0] read_ptr;\nreg [DEPTH-1:0] write_ptr;\nreg [WIDTH-1:0] tempdata;\nreg tempstart;\nreg tempend;\nreg [DEPTH-1:0] count;\n\nalways @(posedge clk)\nbegin\n    if (reset)\n    begin\n        read_ptr <= 0;\n        write_ptr <= 0;\n        count <= 0;\n    end\n    else\n    begin\n        if (data_in_start)\n        begin\n            buffer[write_ptr] <= data_in;\n            write_ptr <= write_ptr + 1;\n            count <= count + 1;\n        end\n\n        if (data_out_end && count > 0)\n        begin\n            data_out <= buffer[read_ptr];\n            read_ptr <= read_ptr + 1;\n            count <= count - 1;\n        end\n    end\n\n    if (count == 0)\n    begin\n        data_out_start <= 0;\n        data_out_end <= 1;\n    end\n    else if (count == DEPTH)\n    begin\n        data_out_start <= 1;\n        data_out_end <= 0;\n    end\n    else\n    begin\n        data_out_start <= (read_ptr == 0);\n        data_out_end <= (write_ptr == DEPTH-1);\n    end\nend\n\nendmodule",
        "module_name": "fifo #",
        "module_hash": "b66280e38f5536a4635f32344e6a7d18",
        "dataset_index": 3498
      },
      "bw_r_irf_register_56cf34f4": {
        "rtl_code": "`ifdef FPGA_SYN_1THREAD\n\n`ifdef FPGA_SYN_SAVE_BRAM\n\n\nmodule bw_r_irf_register(clk, wren, save, save_addr, restore, restore_addr, wr_data, rd_data);\n\tinput\t\tclk;\n\tinput\t\twren;\n\tinput\t\tsave;\n\tinput\t[2:0]\tsave_addr;\n\tinput\t\trestore;\n\tinput\t[2:0]\trestore_addr;\n\tinput\t[71:0]\twr_data;\n\toutput\t[71:0]\trd_data;\n`ifdef FPGA_SYN_ALTERA\n    reg\t[35:0]\twindow[15:0]; `else\n    reg\t[35:0]\twindow[15:0];\n`endif    \nreg\t[71:0]\tonereg;\n\n  initial onereg = 72'h0;\n\n  assign rd_data = onereg;\n\n  reg [71:0] restore_data;\n  wire [71:0] wrdata = restore ? restore_data : wr_data;\n\n  wire wr_en = wren | restore;\n\n  always @(posedge clk) begin\n    if(wr_en) onereg <= wrdata;\n  end\n\n  wire [2:0] addr = save ? save_addr : restore_addr;\n\n  wire [3:0] addr1 = {1'b1, addr};\n  wire [3:0] addr0 = {1'b0, addr};\n\n  always @(negedge clk) begin\n    if(save) window[addr1] <= wren ? wr_data[71:36] : rd_data[71:36];\n    else restore_data[71:36] <= window[addr1];\n  end\n\n  always @(negedge clk) begin\n    if(save) window[addr0] <= wren ? wr_data[35:0] : rd_data[35:0];\n    else restore_data[35:0] <= window[addr0];\n  end\n\n\nendmodule\n\n\n`else\n\n\nmodule bw_r_irf_register(clk, wren, save, save_addr, restore, restore_addr, wr_data, rd_data);\n\tinput\t\tclk;\n\tinput\t\twren;\n\tinput\t\tsave;\n\tinput\t[2:0]\tsave_addr;\n\tinput\t\trestore;\n\tinput\t[2:0]\trestore_addr;\n\tinput\t[71:0]\twr_data;\n\toutput\t[71:0]\trd_data;\n`ifdef FPGA_SYN_ALTERA\n    reg\t[71:0]\twindow[7:0]; `else\nreg\t[71:0]\twindow[7:0];\n`endif\nreg\t[71:0]\tonereg;\n\nreg\t[2:0]\trd_addr;\nreg\t[2:0]\twr_addr;\nreg\t\tsave_d;\n`ifdef FPGA_SYN_ALTERA\n    integer k;\n\n    initial\n    begin\n        for (k = 0; k < 8 ; k = k + 1)\n        begin\n            window[k] = 72'h0;\t\n        end\n    end\n`endif\n\n  initial \n      begin\n          onereg = 72'b0;\n          wr_addr = 3'h0;\n          rd_addr = 3'h0;\n      end\n  \n  always @(negedge clk) begin\n    rd_addr = restore_addr;\n  end\n\n  always @(posedge clk) begin\n    wr_addr <= save_addr;\n  end\n  always @(posedge clk) begin\n    save_d <= save;\n  end\n\n  assign rd_data = onereg;\n\n  wire [71:0] restore_data = window[rd_addr];\n  wire [71:0] wrdata = restore ? restore_data : wr_data;\n\n  wire wr_en = wren | (restore & (wr_addr != rd_addr));\n\n  always @(posedge clk) begin\n    if(wr_en) onereg <= wrdata;\n  end\n    \n  always @(negedge clk) begin\n    if(save_d) window[wr_addr] <= rd_data;\n  end\n\nendmodule\n\n`endif\n\n`else\n\n\nmodule bw_r_irf_register(clk, wrens, save, save_addr, restore, restore_addr, wr_data0, wr_data1, wr_data2, wr_data3, rd_thread, rd_data);\n\tinput\t\tclk;\n\tinput\t[3:0]\twrens;\n\tinput\t\tsave;\n\tinput\t[4:0]\tsave_addr;\n\tinput\t\trestore;\n\tinput\t[4:0]\trestore_addr;\n\tinput\t[71:0]\twr_data0;\n\tinput\t[71:0]\twr_data1;\n\tinput\t[71:0]\twr_data2;\n\tinput\t[71:0]\twr_data3;\n\tinput\t[1:0]\trd_thread;\n\toutput\t[71:0]\trd_data;\n`ifdef FPGA_SYN_ALTERA\n    reg\t[71:0]\twindow[31:0]; `else\n    reg\t[71:0]\twindow[31:0];\n`endif\nreg\t[71:0]\treg_th0, reg_th1, reg_th2, reg_th3;\n\nreg\t[4:0]\trd_addr;\nreg\t[4:0]\twr_addr;\nreg\t\tsave_d;\n\ninitial begin\n  reg_th0 = 72'b0;\n  reg_th1 = 72'b0;\n  reg_th2 = 72'b0;\n  reg_th3 = 72'b0;\nend\n\nbw_r_irf_72_4x1_mux mux4_1(\n\t.sel(rd_thread),\n\t.x0(reg_th0),\n\t.x1(reg_th1),\n\t.x2(reg_th2),\n\t.x3(reg_th3),\n\t.y(rd_data)\n\t);\n\n  always @(negedge clk) begin\n    rd_addr = restore_addr;\n  end\n\n  wire [71:0] restore_data = window[rd_addr];\n\n  always @(posedge clk) begin\n    wr_addr <= save_addr;\n  end\n  always @(posedge clk) begin\n    save_d <= save;\n  end\n\n  wire [71:0] save_data;\n\n  bw_r_irf_72_4x1_mux mux4_2(\n        .sel(wr_addr[4:3]),\n        .x0(reg_th0),\n        .x1(reg_th1),\n        .x2(reg_th2),\n        .x3(reg_th3),\n        .y(save_data)\n        );\n\n  always @(negedge clk) begin\n    if(save_d) window[wr_addr] <= save_data;\n  end\n\nwire [3:0] restores = (1'b1 << rd_addr[4:3]) & {4{restore}};\n  wire [71:0] wrdata0, wrdata1, wrdata2, wrdata3;\n\n  bw_r_irf_72_2x1_mux mux2_5(\n        .sel(restores[0]),\n        .x0(wr_data0),\n        .x1(restore_data),\n        .y(wrdata0)\n        );\n\n  bw_r_irf_72_2x1_mux mux2_6(\n        .sel(restores[1]),\n        .x0(wr_data1),\n        .x1(restore_data),\n        .y(wrdata1)\n        );\n\n  bw_r_irf_72_2x1_mux mux2_7(\n        .sel(restores[2]),\n        .x0(wr_data2),\n        .x1(restore_data),\n        .y(wrdata2)\n        );\n\n  bw_r_irf_72_2x1_mux mux2_8(\n        .sel(restores[3]),\n        .x0(wr_data3),\n        .x1(restore_data),\n        .y(wrdata3)\n        );\n\n  wire [3:0] wr_en = wrens | (restores & {4{(wr_addr[4:0] != rd_addr[4:0])}});\n\n  always @(posedge clk) begin\n    if(wr_en[0]) reg_th0 <= wrdata0;\n    if(wr_en[1]) reg_th1 <= wrdata1;\n    if(wr_en[2]) reg_th2 <= wrdata2;\n    if(wr_en[3]) reg_th3 <= wrdata3;\n  end\n    \nendmodule\n\n\nmodule bw_r_irf_72_4x1_mux(sel, y, x0, x1, x2, x3);\n\tinput\t[1:0]\tsel;\n\tinput\t[71:0]\tx0;\n\tinput\t[71:0]\tx1;\n\tinput\t[71:0]\tx2;\n\tinput\t[71:0]\tx3;\n\toutput\t[71:0] y;\n\treg\t[71:0] y;\n\n\talways @(sel or x0 or x1 or x2 or x3)\n\t\tcase(sel)\n\t\t  2'b00: y = x0;\n\t\t  2'b01: y = x1;\n\t\t  2'b10: y = x2;\n\t\t  2'b11: y = x3;\n\t\tendcase\n\nendmodule\n\t\n\nmodule bw_r_irf_72_2x1_mux(sel, y, x0, x1);\n\tinput\t\tsel;\n\tinput\t[71:0]\tx0;\n\tinput\t[71:0]\tx1;\n\toutput\t[71:0] y;\n\treg\t[71:0] y;\n\n\talways @(sel or x0 or x1)\n\t\tcase(sel)\n\t\t  1'b0: y = x0;\n\t\t  1'b1: y = x1;\n\t\tendcase\n\nendmodule\n\t\n`endif\n\n\n",
        "module_name": "bw_r_irf_register",
        "module_hash": "56cf34f45e39d7e451730435dc836d0e",
        "dataset_index": 20022
      },
      "aurora_64b66b_25p4G_RX_LL_DATAPATH_87ecaf56": {
        "rtl_code": "\n \n\n module aurora_64b66b_25p4G_RX_LL_DATAPATH\n (\n \n     RX_PE_DATA,\n     RX_PE_DATA_V,\n \n     RX_SEP,\n     RX_SEP7,\n     RX_SEP_NB,\n \n     RX_CC,           \n     RXDATAVALID_TO_LL,           \n     RX_IDLE,           \n \n \n     CHANNEL_UP,\n \n     m_axi_rx_tdata,\n     m_axi_rx_tvalid,\n     m_axi_rx_tkeep,\n     m_axi_rx_tlast,\n     \n     USER_CLK,\n     RESET\n );\n \n `define DLY #1\n  parameter            STRB_WIDTH         = 8; parameter            REM_WIDTH          = 3; input     [0:63]     RX_PE_DATA;  \n       input                RX_PE_DATA_V; \n       input                RX_SEP; \n       input                RX_SEP7; \n       input     [0:2]      RX_SEP_NB;         \n        \n     output [0:63]     m_axi_rx_tdata; \n       output            m_axi_rx_tvalid;\n       output [0:7]      m_axi_rx_tkeep; \n       output            m_axi_rx_tlast; \n     \n     \n       input                RX_CC;           \n       input                RXDATAVALID_TO_LL;           \n       input                RX_IDLE;           \n \n \n     input                CHANNEL_UP; \n     \n     input                USER_CLK; \n       input                RESET; \n \n \n     \n parameter REM_BITS  =  3;\n \n reg       [0:63]     m_axi_rx_tdata; \n       reg                  m_axi_rx_tvalid;\n       reg       [0:7]      m_axi_rx_tkeep; \n       reg                  m_axi_rx_tlast; \n \n reg                  rx_pdu_ok; \n       reg                  rx_pe_data_v_r;     \n       reg                  rx_pe_data_v_r2;     \n       reg       [73:0]     raw_data_r;        \n       reg       [73:0]     raw_data_r2;\n       reg                  rx_ll_dv_r1;     \n       reg                  rx_ll_dv_r2;     \n       reg                  rx_cc_r1;     \n       reg                  rx_cc_r2;     \n       reg                  rx_sep_r; \n       reg                  hold_valid;\n       reg                  hold_valid_r;\n       reg       [0:7]      rx_keep_dec_lane_0;         \n \n wire                 rx_sep_comb; \n       wire                 pipe1_rx_pdu_in_progress_c; \n \n       wire      [0:7]      rx_txkeep_c;\n       wire      [0:7]      rx_txkeep_c_1;\n       wire      [0:7]      rx_keep;         \n       wire      [0:7]      pipe1_rx_keep;         \n       wire      [0:7]      pipe2_rx_keep;         \n       wire                 sep_detect;\n       wire                 sep0_detect;\n    \n     wire      [63:0]     pipe1_rx_pe_data_r;     \n       wire                 rx_pe_data_v_c;     \n       wire                 pipe1_rx_sep_r;      \n       wire                 pipe1_rx_sep7_r;\n     wire      [63:0]     pipe2_rx_pe_data_r;     \n       wire                 pipe2_rx_sep_r;      \n       wire                 pipe2_rx_sep7_r;      \n       wire                 rx_cc_c;        \n       wire                 rx_sep_c; \n       wire                 rx_sep7_c; \n       wire                 rx_idle_c;        \n       wire                 dv_conic_sep;        \n       wire                 sep_conic_dv;        \n       wire                 rx_tvalid_c;        \n       wire      [73:0]     raw_data_c;        \n       wire      [73:0]     raw_data_c2;    \n \n \n     genvar    i;\n always @ (*)\n     begin\n       if (RX_SEP | RX_SEP7) begin\n \n         case(RX_SEP_NB[0 : 2]) \n           3'd0     : begin\n              if(!(|RX_SEP_NB[0 : 2]))\n                      rx_keep_dec_lane_0 = 8'b11111111;\n              else \n                      rx_keep_dec_lane_0 = 8'b00000000;\n           end \n \n \n           3'd1     : rx_keep_dec_lane_0 = 8'b10000000;\n           3'd2     : rx_keep_dec_lane_0 = 8'b11000000;\n           3'd3     : rx_keep_dec_lane_0 = 8'b11100000;\n           3'd4     : rx_keep_dec_lane_0 = 8'b11110000;\n           3'd5     : rx_keep_dec_lane_0 = 8'b11111000;\n           3'd6     : rx_keep_dec_lane_0 = 8'b11111100;\n           3'd7     : rx_keep_dec_lane_0 = 8'b11111110;\n \n           default  : rx_keep_dec_lane_0 = 8'b00000000;\n         endcase\n       end \n       else if (RX_PE_DATA_V) \n \n         rx_keep_dec_lane_0 = 8'b11111111;\n       else \n         rx_keep_dec_lane_0 = 8'b00000000;\n     end \n \n\n     assign rx_keep = rx_keep_dec_lane_0;\n\n \n     assign rx_pe_data_v_c = |RX_PE_DATA_V  & CHANNEL_UP;\n     assign rx_sep_c       = |RX_SEP & CHANNEL_UP;\n     assign rx_sep7_c      = |RX_SEP7 & CHANNEL_UP;\n     assign raw_data_c     = {RX_PE_DATA, rx_keep, rx_sep_c, rx_sep7_c};\n \n     always @ (posedge USER_CLK) \n     begin\n       if (pipe1_rx_pdu_in_progress_c) \n         raw_data_r <= `DLY raw_data_c;\n     end\n\n\n     always @ (posedge USER_CLK) \n     begin\n       raw_data_r2         <= `DLY raw_data_c2;\n       rx_pe_data_v_r      <= `DLY rx_pe_data_v_c;\n       rx_pe_data_v_r2     <= `DLY rx_pe_data_v_r;\n       rx_ll_dv_r1         <= `DLY RXDATAVALID_TO_LL;\n       rx_ll_dv_r2         <= `DLY rx_ll_dv_r1;\n       rx_cc_r1            <= `DLY rx_cc_c;\n       rx_cc_r2            <= `DLY rx_cc_r1;\n       rx_sep_r            <= `DLY rx_sep_c;\n     end\n \n     assign pipe1_rx_pe_data_r = raw_data_r[73:2+STRB_WIDTH];\n     assign pipe1_rx_keep      = raw_data_r[2+STRB_WIDTH-1:2];\n     assign pipe1_rx_sep_r     = raw_data_r[1];\n     assign pipe1_rx_sep7_r    = raw_data_r[0];\n \n     assign   rx_cc_c          =  RX_CC;         \n     assign   rx_idle_c        =  &RX_IDLE;\n     assign   raw_data_c2      =  raw_data_r;\n \n \n     assign pipe2_rx_pe_data_r = raw_data_r2[73:2+STRB_WIDTH];\n     assign pipe2_rx_keep      = raw_data_r2[2+STRB_WIDTH-1:2];\n     assign pipe2_rx_sep_r     = raw_data_r2[1];\n     assign pipe2_rx_sep7_r    = raw_data_r2[0];\n \n \n     always @ (posedge USER_CLK) \n     begin\n         rx_pdu_ok <= `DLY ((rx_pe_data_v_r  | (rx_pe_data_v_r & ((pipe1_rx_sep_r  & !pipe1_rx_keep[STRB_WIDTH-1]) | pipe1_rx_sep7_r)))  );\n     end\n\n     assign sep_conic_dv = (hold_valid & (rx_pe_data_v_r2 & !(pipe2_rx_sep_r | pipe2_rx_sep7_r)));\n\n     assign dv_conic_sep = hold_valid & rx_ll_dv_r1 & !rx_cc_r1  & rx_pe_data_v_r  & !(pipe2_rx_sep_r | pipe2_rx_sep7_r);\n\n     always @(*)\n     begin\n       if (rx_pdu_ok & (rx_cc_r1 | !rx_ll_dv_r1  | (!rx_pe_data_v_r & !sep0_detect)))\n         hold_valid = 1'b1;\n       else if (hold_valid_r & (rx_cc_r2 | !rx_ll_dv_r2  | !rx_pe_data_v_r2))\n         hold_valid = 1'b1;\n       else \n         hold_valid = 1'b0;\n     end \n\n     always @ (posedge USER_CLK) \n     begin\n       if(!CHANNEL_UP)\n         hold_valid_r <= `DLY 1'b0;\n       else \n         hold_valid_r <= `DLY hold_valid;\n     end\n\n     assign rx_tvalid_c  = (rx_pdu_ok | dv_conic_sep | sep0_detect);\n \n\n \n     assign pipe1_rx_pdu_in_progress_c = ((rx_pe_data_v_c  | ( rx_sep_c | rx_sep7_c)  ) & (!rx_cc_c)) ;\n \n \n \n     always @(posedge USER_CLK)\n     begin\n         if (rx_tvalid_c)\n           m_axi_rx_tdata  <=  `DLY pipe2_rx_pe_data_r;\n     end\n \n     always @(posedge USER_CLK)\n     begin\n         if(!CHANNEL_UP)\n            m_axi_rx_tvalid   <=  `DLY 1'b0;\n         else if (sep_conic_dv)\n            m_axi_rx_tvalid   <=  `DLY 1'b0;\n         else \n            m_axi_rx_tvalid   <=  `DLY rx_tvalid_c;\n     end\n\n     assign sep_detect  = ((pipe2_rx_sep_r & !pipe2_rx_keep[STRB_WIDTH-1]) | pipe2_rx_sep7_r );\n     assign sep0_detect = (rx_sep_r & pipe1_rx_keep[STRB_WIDTH-1]);\n     always @(posedge USER_CLK)\n     begin\n       if(!CHANNEL_UP)\n         m_axi_rx_tlast  <=  `DLY 1'b0;\n       else if (rx_tvalid_c)\n         m_axi_rx_tlast  <=  `DLY sep_detect | sep0_detect;\n       else \n         m_axi_rx_tlast  <=  `DLY 1'b0;\n     end\n\n    assign rx_txkeep_c    = pipe1_rx_keep;\n    assign rx_txkeep_c_1  = pipe2_rx_keep;\n\n     always @(posedge USER_CLK)\n     begin\n         if (sep_detect) \n            m_axi_rx_tkeep  <=  `DLY    rx_txkeep_c_1;\n         else if (sep0_detect) \n            m_axi_rx_tkeep  <=  `DLY    rx_txkeep_c;\n         else \n            m_axi_rx_tkeep  <=  `DLY    {8{1'b1}};\n     end\n\n\n \n endmodule\n \n \n",
        "module_name": "aurora_64b66b_25p4G_RX_LL_DATAPATH",
        "module_hash": "87ecaf5670c019bacdbe0870d36723f2",
        "dataset_index": 19018
      },
      "counter_4bit_d33c74d8": {
        "rtl_code": "module counter_4bit (\n    input clk,\n    input rst,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "d33c74d80c217072822a024cb08f6126",
        "dataset_index": 5405
      },
      "clock_gate_d_ff_1c09765f": {
        "rtl_code": "module clock_gate_d_ff (\n    input clk,\n    input en,\n    input en_ff,\n    input [31:0] data,\n    output reg q\n);\n\n    wire gated_clk = clk & en; // create a gated clock signal\n    \n    always @(posedge gated_clk) begin // use the gated clock for the flip-flop\n        if (en_ff) begin // only update the output when enabled\n            q <= data;\n        end\n    end\n    \nendmodule",
        "module_name": "clock_gate_d_ff",
        "module_hash": "1c09765f72594ae0f7905b3321735ff2",
        "dataset_index": 13993
      },
      "raycast_stack_17f3962e": {
        "rtl_code": "\nmodule raycast_stack\n\t(\n\t\tclk,\n\t\tpush, pop,\n\t\tdata_i, data_o\n\n\t);\n\n\tparameter dw = 32;\n\tparameter depth = 8;\n\tparameter depth_log2 = 3;\n\tinput clk;\n\n\tinput push;\n\tinput pop;\n\n\tinput [dw-1:0] data_i;\n\toutput [dw-1:0] data_o;\n\n\n\treg [dw-1:0] stack_data[0:depth-1];\n\treg [depth_log2-1:0] stack_ptr = 0;\n\twire [depth_log2-1:0] stack_ptr_inc = stack_ptr + 1;\n\twire [depth_log2-1:0] stack_ptr_dec = stack_ptr - 1;\n\tassign data_o = stack_data[stack_ptr];\n\talways @(posedge clk)\n\tbegin\n\t\tif (push) begin\n\t\t\tstack_data[stack_ptr_inc] <= data_i;\n\t\t\tstack_ptr <= stack_ptr_inc;\n\t\tend\n\t\telse if (pop) begin\n\t\t\tstack_ptr <= stack_ptr_dec;\n\t\tend\n\tend\n\n\n\nendmodule",
        "module_name": "raycast_stack",
        "module_hash": "17f3962ecc0daeaa37f5158069d2a326",
        "dataset_index": 24031
      },
      "up_down_counter_eeef3e9f": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input rst,\n    input up_down,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'b0000;\n        end\n        else begin\n            if (up_down) begin\n                count <= count + 1;\n            end\n            else begin\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "eeef3e9f44fccdb86a0cf875b15df875",
        "dataset_index": 9517
      },
      "priority_encoder_91d3f81e": {
        "rtl_code": "module priority_encoder (\n    input in7,\n    input in6,\n    input in5,\n    input in4,\n    input in3,\n    input in2,\n    input in1,\n    input in0,\n    output reg out2,\n    output reg out1,\n    output reg out0\n);\n\nalways @* begin\n    case ({in7, in6, in5, in4, in3, in2, in1, in0})\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000: begin out2 = 1; out1 = 0; out0 = 0; end\n        8'b00000011, 8'b00000101, 8'b00001001, 8'b00010001, 8'b00100001, 8'b01000001, 8'b10000001: begin out2 = 0; out1 = 1; out0 = 0; end\n        8'b00000110, 8'b00001010, 8'b00010010, 8'b00100010, 8'b01000010, 8'b10000010: begin out2 = 0; out1 = 0; out0 = 1; end\n        default: begin out2 = 0; out1 = 0; out0 = 0; end\n    endcase\nend\n\nendmodule\n\nmodule barrel_shifter (\n    input [3:0] data,\n    input [1:0] shift_amount,\n    input mode,\n    output reg [3:0] out\n);\n\nalways @* begin\n    case (mode)\n        2'b00: out = data << shift_amount;\n        2'b01: out = data >> shift_amount;\n        default: out = data;\n    endcase\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] in,\n    input [1:0] shift_amount,\n    input mode,\n    output reg [7:0] out\n);\n\nwire [2:0] priority_encoder_out;\nwire [3:0] barrel_shifter_out;\nwire [7:0] or_out;\n\npriority_encoder pe(\n    .in7(in[7]),\n    .in6(in[6]),\n    .in5(in[5]),\n    .in4(in[4]),\n    .in3(in[3]),\n    .in2(in[2]),\n    .in1(in[1]),\n    .in0(in[0]),\n    .out2(priority_encoder_out[2]),\n    .out1(priority_encoder_out[1]),\n    .out0(priority_encoder_out[0])\n);\n\nbarrel_shifter bs(\n    .data(in[3:0]),\n    .shift_amount(shift_amount),\n    .mode(mode),\n    .out(barrel_shifter_out)\n);\n\nassign or_out = {priority_encoder_out[2], priority_encoder_out[1], priority_encoder_out[0], barrel_shifter_out};\n\nalways @* begin\n    out = or_out;\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "91d3f81e6080a10ff795521df0d77580",
        "dataset_index": 6497
      },
      "add_sub_7a1c2533": {
        "rtl_code": "\nmodule add_sub (\n    input [3:0] A,\n    input [3:0] B,\n    input S,   // 0: addition, 1: subtraction\n    output [3:0] R,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire [4:0] C;  // 4-bit wire for carry\n\n    assign Cout = S ? (~A[0] & B[0]) : (A[0] & B[0]);\n    assign C[0] = S ? (A[0] & B[0]) : (~A[0] & B[0]);\n\n    full_adder FA0(A[0], B[0], C[0], R[0], C[1]);\n    full_adder FA1(A[1], B[1], C[1], R[1], C[2]);\n    full_adder FA2(A[2], B[2], C[2], R[2], C[3]);\n    full_adder FA3(A[3], B[3], C[3], R[3], C[4]);\n\nendmodule\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "7a1c25339a2df73cc7eb9f8f78b21097",
        "dataset_index": 7601
      },
      "flash_ADC_1017175b": {
        "rtl_code": "\nmodule flash_ADC (\n  input [9:0] Vin, // analog input voltage\n  input clk, // clock signal\n  output reg [7:0] Dout // digital output\n);\n\n  reg [7:0] ref_voltages; // reference voltages\n  reg [7:0] comparator_outputs; // comparator outputs\n  \n  always @(*) begin\n    ref_voltages = {8{Vin[9:2]}} + {8{1'b0}}; // evenly spaced reference voltages\n    comparator_outputs = {Vin[1:0], Vin[1:0], Vin[1:0], Vin[1:0], Vin[1:0], Vin[1:0], Vin[1:0], Vin[1:0]} > ref_voltages; // comparator outputs\n  end\n  \n  always @(posedge clk) begin\n    Dout <= comparator_outputs; // sample input voltage on rising edge of clock signal\n  end\n  \nendmodule",
        "module_name": "flash_ADC",
        "module_hash": "1017175b0966012c3023f5681d35a921",
        "dataset_index": 20560
      },
      "calculator_c124945c": {
        "rtl_code": "module calculator(\n    input [1:0] op,\n    input [7:0] a,\n    input [7:0] b,\n    input clk,\n    input rst,\n    output [7:0] result,\n    output valid\n);\n\nreg [7:0] result_reg;\nreg valid_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result_reg <= 0;\n        valid_reg <= 0;\n    end else begin\n        case (op)\n            2'b00: result_reg <= a + b; // Addition\n            2'b01: result_reg <= a - b; // Subtraction\n            2'b10: result_reg <= a * b; // Multiplication\n            2'b11: result_reg <= a / b; // Division\n        endcase\n        valid_reg <= 1;\n    end\nend\n\nassign result = result_reg;\nassign valid = valid_reg;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "c124945c932735abf5367ca2e77ee1c6",
        "dataset_index": 3209
      },
      "mux2to1_b4bdc901": {
        "rtl_code": "module mux2to1 (\n    in1 ,\n    in2 ,\n    sel ,\n    out ,\n    vpwr,\n    vgnd\n);\n\n    output out ;\n    input  in1 ;\n    input  in2 ;\n    input  sel ;\n    input  vpwr;\n    input  vgnd;\n\n    assign out = sel ? in2 : in1;\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "b4bdc90196022e850b4916087a51fc62",
        "dataset_index": 20719
      },
      "dual_port_memory_a1af8cb8": {
        "rtl_code": "\nmodule dual_port_memory (\n    input wire clk,  // 28MHz\n    input wire [20:0] a1,\n    input wire [20:0] a2,\n    input wire oe1_n,\n    input wire oe2_n,\n    input wire we1_n,\n    input wire we2_n,\n    input wire [7:0] din1,\n    input wire [7:0] din2,\n    output wire [7:0] dout1,\n    output wire [7:0] dout2\n    );\n\n   parameter\n\t\tACCESO_M1 = 1,\n\t\tREAD_M1   = 2,\n\t\tWRITE_M1  = 3,\n\t\tACCESO_M2 = 4,\n\t\tREAD_M2   = 5,\n\t\tWRITE_M2  = 6;\t\t\n\n   reg [7:0] data_to_write;\n\treg enable_input_to_sram;\n\treg write_in_dout1;\n\treg write_in_dout2;\n\n\treg [7:0] doutput1;\n\treg [7:0] doutput2;\n\n\treg [2:0] state = ACCESO_M1;\n\treg [2:0] next_state;\n\t\n\talways @(posedge clk) begin\n\t\tstate <= next_state;\n\tend\n\n\talways @* begin\n\t\tnext_state = ACCESO_M1;\n\t\tdata_to_write = 8'h00;\n\t\twrite_in_dout1 = 0;\n\t\twrite_in_dout2 = 0;\n\n\t\tcase (state)\n\t\t\tACCESO_M1: begin\n\t\t\t\t\t \t\t if (we1_n == 1) begin\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t next_state = READ_M1;\n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t\t else begin\n\t\t\t\t\t\t\t\t next_state = WRITE_M1;\n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\tREAD_M1:   begin\n\t\t\t             if (we1_n == 1) begin\n                        write_in_dout1 = 1;\n                      end\n\t\t\t\t\t\t\t next_state = ACCESO_M2;\n\t\t\t\t\t\t end\n\t\t\tWRITE_M1:  begin\n                      if (we1_n == 0) begin\n                        enable_input_to_sram = 1;\n                        data_to_write = din1;\n                        next_state = ACCESO_M2;\n                      end\n\t\t\t\t\t\t end\n\t\t\tACCESO_M2: begin\n\t\t\t\t\t\t\t if (we2_n == 1) begin\n\t\t\t\t\t\t\t    next_state = READ_M2;\n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t\t else begin\n\t\t\t\t\t\t\t\t next_state = WRITE_M2;\n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\tREAD_M2:   begin\n                      if (we2_n == 1) begin\n                        write_in_dout2 = 1;\n                      end\n                      next_state = ACCESO_M1;\n\t\t\t\t\t\t end\n\t\t\tWRITE_M2:  begin\n                      if (we2_n == 0) begin\n                        enable_input_to_sram = 1;\n                        data_to_write = din2;\n                        next_state = ACCESO_M1;\n                      end\n\t\t\t\t\t\t end\n       endcase\n\t end\n\n\t// assign doutput1 = oe1_n ? 8'hZZ : doutput1;\n\t// assign doutput2 = oe2_n ? 8'hZZ : doutput2;\n\tassign dout1 = doutput1;\n\tassign dout2 = doutput2;\n\t \n\t always @(posedge clk) begin\n\t\tif (write_in_dout1)\n\t\t\tdoutput1 <= data_to_write;\n\t\tif (write_in_dout2)\n\t\t\tdoutput2 <= data_to_write;\n\t end\n\nendmodule",
        "module_name": "dual_port_memory",
        "module_hash": "a1af8cb8fea99da913599322006dce64",
        "dataset_index": 15008
      },
      "fifo_address_sync_a6f9784a": {
        "rtl_code": "module fifo_address_sync (\n\tinput clk,\n\tinput resetn,\n\n\tinput m_axis_ready,\n\toutput reg m_axis_valid,\n\toutput reg  [C_ADDRESS_WIDTH-1:0] m_axis_raddr,\n\toutput reg [C_ADDRESS_WIDTH-1:0] m_axis_raddr_next,\n\toutput [C_ADDRESS_WIDTH:0] m_axis_level,\n\n\toutput reg s_axis_ready,\n\tinput s_axis_valid,\n\toutput reg s_axis_empty,\n\toutput reg [C_ADDRESS_WIDTH-1:0] s_axis_waddr,\n\toutput [C_ADDRESS_WIDTH:0] s_axis_room\n);\n\nparameter C_ADDRESS_WIDTH = 4;\n\nreg [C_ADDRESS_WIDTH:0] room = 2**C_ADDRESS_WIDTH;\nreg [C_ADDRESS_WIDTH:0] level = 'h00;\nreg [C_ADDRESS_WIDTH:0] level_next;\n\nassign s_axis_room = room;\nassign m_axis_level = level;\n\nwire read = m_axis_ready & m_axis_valid;\nwire write = s_axis_ready & s_axis_valid;\n\nalways @(*)\nbegin\n\tif (read)\n\t\tm_axis_raddr_next <= m_axis_raddr + 1'b1;\n\telse\n\t\tm_axis_raddr_next <= m_axis_raddr;\nend\n\nalways @(posedge clk)\nbegin\n\tif (resetn == 1'b0) begin\n\t\ts_axis_waddr <= 'h00;\n\t\tm_axis_raddr <= 'h00;\n\tend else begin\n\t\tif (write)\n\t\t\ts_axis_waddr <= s_axis_waddr + 1'b1;\n\t\tm_axis_raddr <= m_axis_raddr_next;\n\tend\nend\n\nalways @(*)\nbegin\n\tif (read & ~write)\n\t\tlevel_next <= level - 1'b1;\n\telse if (~read & write)\n\t\tlevel_next <= level + 1'b1;\n\telse\n\t\tlevel_next <= level;\nend\n\nalways @(posedge clk)\nbegin\n\tif (resetn == 1'b0) begin\n\t\tm_axis_valid <= 1'b0;\n\t\ts_axis_ready <= 1'b0;\n\t\tlevel <= 'h00;\n\t\troom <= 2**C_ADDRESS_WIDTH;\n\t\ts_axis_empty <= 'h00;\n\tend else begin\n\t\tlevel <= level_next;\n\t\troom <= 2**C_ADDRESS_WIDTH - level_next;\n\t\tm_axis_valid <= level_next != 0;\n\t\ts_axis_ready <= level_next != 2**C_ADDRESS_WIDTH;\n\t\ts_axis_empty <= level_next == 0;\n\tend\nend\n\nendmodule\n\n",
        "module_name": "fifo_address_sync",
        "module_hash": "a6f9784aa8cbb864088b382b66e969fd",
        "dataset_index": 21651
      },
      "mux_4to1_enable_c27a0925": {
        "rtl_code": "module mux_4to1_enable (\n  input [3:0] in,\n  input [1:0] sel,\n  input enable,\n  output reg out\n);\n\nalways @ (sel or in or enable) begin\n  if (enable == 1'b1) begin\n    case (sel)\n      2'b00: out = in[0];\n      2'b01: out = in[1];\n      2'b10: out = in[2];\n      2'b11: out = in[3];\n      default: out = 1'b0;\n    endcase\n  end else begin\n    out = 1'b0;\n  end\nend\n\nendmodule\n",
        "module_name": "mux_4to1_enable",
        "module_hash": "c27a092587adb5bdc3331a0337dc786a",
        "dataset_index": 5368
      },
      "axis_counter #_486545bf": {
        "rtl_code": "\n\nmodule axis_counter #\n(\n  parameter integer AXIS_TDATA_WIDTH = 32,\n  parameter integer CNTR_WIDTH = 32\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n\n  input  wire [CNTR_WIDTH-1:0]       cfg_data,\n\n  output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,\n  output wire                        m_axis_tvalid\n);\n\n  reg [CNTR_WIDTH-1:0] int_cntr_reg, int_cntr_next;\n  reg int_enbl_reg, int_enbl_next;\n\n  wire int_comp_wire;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_cntr_reg <= {(CNTR_WIDTH){1'b0}};\n      int_enbl_reg <= 1'b0;\n    end\n    else\n    begin\n      int_cntr_reg <= int_cntr_next;\n      int_enbl_reg <= int_enbl_next;\n    end\n  end\n\n  assign int_comp_wire = int_cntr_reg < cfg_data;\n\n  always @*\n  begin\n    int_cntr_next = int_cntr_reg;\n    int_enbl_next = int_enbl_reg;\n\n    if(~int_enbl_reg & int_comp_wire)\n    begin\n      int_enbl_next = 1'b1;\n    end\n\n    if(int_enbl_reg & int_comp_wire)\n    begin\n      int_cntr_next = int_cntr_reg + 1'b1;\n    end\n\n    if(int_enbl_reg & ~int_comp_wire)\n    begin\n      int_enbl_next = 1'b0;\n    end\n  end\n\n  assign m_axis_tdata = {{(AXIS_TDATA_WIDTH-CNTR_WIDTH){1'b0}}, int_cntr_reg};\n  assign m_axis_tvalid = int_enbl_reg;\n\nendmodule\n",
        "module_name": "axis_counter #",
        "module_hash": "486545bfbc8752a4c0481ffeafc623fe",
        "dataset_index": 25137
      },
      "sky130_fd_sc_ms__clkinv_cfe4c42a": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__clkinv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__clkinv",
        "module_hash": "cfe4c42a949db7a3cfee5d26a9c255c5",
        "dataset_index": 16279
      },
      "piso_shift_register_7732df1e": {
        "rtl_code": "module piso_shift_register (\n    input [3:0] parallel_in,\n    input clk,\n    input shift_enable,\n    input reset,\n    output serial_out\n);\n\n    reg [3:0] shift_reg;\n    reg serial_out_reg;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n            serial_out_reg <= 1'b0;\n        end else if (shift_enable) begin\n            shift_reg <= {shift_reg[2:0], parallel_in[0]};\n            serial_out_reg <= shift_reg[3];\n        end else begin\n            shift_reg <= shift_reg;\n            serial_out_reg <= shift_reg[3];\n        end\n    end\n    \n    assign serial_out = serial_out_reg;\n    \nendmodule",
        "module_name": "piso_shift_register",
        "module_hash": "7732df1e0a8d20f2e3737274ff6b3196",
        "dataset_index": 18002
      },
      "Multiplier_42f3861f": {
        "rtl_code": "module Multiplier(\n    input wire clk,\n    input wire rst,\n    input wire load_i,\n    input wire [31:0] Data_A_i,\n    input wire [31:0] Data_B_i,\n    output wire [63:0] sgf_result_o\n);\n\n    // Booth's multiplication algorithm\n    // Split input data streams into 16-bit chunks\n    wire [15:0] A0 = Data_A_i[15:0];\n    wire [15:0] A1 = Data_A_i[31:16];\n    wire [15:0] B0 = Data_B_i[15:0];\n    wire [15:0] B1 = Data_B_i[31:16];\n    \n    // Compute partial products\n    wire [31:0] P0 = A0 * B0;\n    wire [31:0] P1 = A1 * B0;\n    wire [31:0] P2 = A0 * B1;\n    wire [31:0] P3 = A1 * B1;\n    \n    // Add partial products\n    wire [63:0] sum = {P0, 32'b0} + {P1, 16'b0} + {P2, 16'b0} + {P3, 48'b0};\n    \n    // Output result\n    reg [63:0] sgf_result;\n    always @ (posedge clk) begin\n        if (rst) begin\n            sgf_result <= 0;\n        end else if (load_i) begin\n            sgf_result <= sum;\n        end\n    end\n    \n    assign sgf_result_o = sgf_result;\n\nendmodule",
        "module_name": "Multiplier",
        "module_hash": "42f3861f197d01c292fc3bf2129e99f6",
        "dataset_index": 12974
      },
      "autoasciienum_onehot_d01c3ec6": {
        "rtl_code": "module autoasciienum_onehot (\n                             input  clk,\n                             input  rst_n,\n                             output ack\n                             );\n   \n   localparam IDLE = 0,\n     S1   = 1,\n     S2   = 2,\n     S3   = 3,\n     DONE = 4;\n   \n   reg [4:0] cur_state, nxt_state;\n   \n   always @ (*) begin\n      nxt_state = 5'h0;\n      \n      case (1'b1)\n        cur_state[IDLE] : nxt_state[S1]   = 1'b1;\n        cur_state[S1]   : nxt_state[S2]   = 1'b1;\n        cur_state[S2]   : nxt_state[S3]   = 1'b1;\n        cur_state[S3]   : nxt_state[DONE] = 1'b1;\n        cur_state[DONE] : nxt_state[DONE] = 1'b1;\n      endcase\n   end\n   \n   always @ (posedge clk or negedge rst_n)\n     if (rst_n == 1'b0) begin\n        cur_state <= 'h1;\n     end\n     else begin\n        cur_state <= nxt_state;\n     end\n   \n   assign ack = cur_state[DONE];\n   \n   \n   reg [31:0] cur_state_ascii;  always @(cur_state) begin\n      case ({cur_state})\n        (5'b1<<IDLE):     cur_state_ascii = \"idle\";\n        (5'b1<<S1):       cur_state_ascii = \"s1  \";\n        (5'b1<<S2):       cur_state_ascii = \"s2  \";\n        (5'b1<<S3):       cur_state_ascii = \"s3  \";\n        (5'b1<<DONE):     cur_state_ascii = \"done\";\n        default:          cur_state_ascii = \"%Err\";\n      endcase\n   end\n   endmodule\n",
        "module_name": "autoasciienum_onehot",
        "module_hash": "d01c3ec6751cf24da4a1c9360aa94cb1",
        "dataset_index": 23703
      },
      "four_input_and_gate_ab93c264": {
        "rtl_code": "module four_input_and_gate (\n    output X,\n    input A1,\n    input A2,\n    input B1,\n    input C1\n);\n\n    wire W1, W2, W3;\n\n    and and1 (\n        W1,\n        A1,\n        A2\n    );\n\n    and and2 (\n        W2,\n        W1,\n        W1\n    );\n\n    and and3 (\n        W3,\n        W2,\n        W2\n    );\n\n    assign X = W3;\n\nendmodule",
        "module_name": "four_input_and_gate",
        "module_hash": "ab93c26447b0891e3b76345f9e9d6ba3",
        "dataset_index": 5022
      },
      "decoder_f067dcea": {
        "rtl_code": "module decoder (\n    input [2:0] in,\n    output reg [7:0] out\n);\n\n    always @* begin\n        case (in)\n            3'b000: out = 8'b00000001;\n            3'b001: out = 8'b00000010;\n            3'b010: out = 8'b00000100;\n            3'b011: out = 8'b00001000;\n            3'b100: out = 8'b00010000;\n            3'b101: out = 8'b00100000;\n            3'b110: out = 8'b01000000;\n            3'b111: out = 8'b10000000;\n            default: out = 8'b00000000;\n        endcase\n    end\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "f067dcea1cab91b9642f4cbdd1294e62",
        "dataset_index": 14506
      },
      "rising_edge_detection_f3d72029": {
        "rtl_code": "module rising_edge_detection (\n  input clk,\n  input reset,\n  input [7:0] data,\n  output reg match\n);\n\nreg [7:0] prev_data;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    match <= 0;\n    prev_data <= 0;\n  end else begin\n    if (data > prev_data) begin\n      match <= 1;\n    end else begin\n      match <= 0;\n    end\n    prev_data <= data;\n  end\nend\n\nendmodule\n",
        "module_name": "rising_edge_detection",
        "module_hash": "f3d72029690cc9299ea79d448a8ccf60",
        "dataset_index": 20883
      },
      "wb_pipe_reg_3916f601": {
        "rtl_code": "module wb_pipe_reg\n    (\n        input   wire        clk,\n        input   wire        reset,\n        input   wire        valid_wb_pipe_reg_i,\n        input   wire        rf_en_wb_pipe_reg_i,\n        input   wire[1:0]   wb_sel_wb_pipe_reg_i,\n        input   wire[4:0]   rd_wb_pipe_reg_i,\n        input   wire[31:0]  alu_res_wb_pipe_reg_i,\n        input   wire[31:0]  read_data_wb_pipe_reg_i,\n        input   wire[31:0]  next_seq_pc_wb_pipe_reg_i,\n        output  wire        instr_retired_wb_pipe_reg_o,\n        output  wire        rf_en_wb_pipe_reg_o,\n        output  wire[1:0]   wb_sel_wb_pipe_reg_o,\n        output  wire[4:0]   rd_wb_pipe_reg_o,\n        output  wire[31:0]  alu_res_wb_pipe_reg_o,\n        output  wire[31:0]  read_data_wb_pipe_reg_o,\n        output  wire[31:0]  next_seq_pc_wb_pipe_reg_o\n    );\n\n    reg        rf_en_wb_pipe_reg;\n    reg[1:0]   wb_sel_wb_pipe_reg;\n    reg        instr_retired_wb_pipe_reg;\n    reg[4:0]   rd_wb_pipe_reg;\n    reg[31:0]  alu_res_wb_pipe_reg;\n    reg[31:0]  read_data_wb_pipe_reg;\n    reg[31:0]  next_seq_pc_wb_pipe_reg;\n\n    assign rf_en_wb_pipe_reg_o          =  rf_en_wb_pipe_reg;\n    assign wb_sel_wb_pipe_reg_o         =  wb_sel_wb_pipe_reg;\n    assign instr_retired_wb_pipe_reg_o  =  instr_retired_wb_pipe_reg;\n    assign rd_wb_pipe_reg_o             =  rd_wb_pipe_reg;\n    assign alu_res_wb_pipe_reg_o        =  alu_res_wb_pipe_reg;\n    assign read_data_wb_pipe_reg_o      =  read_data_wb_pipe_reg;\n    assign next_seq_pc_wb_pipe_reg_o    =  next_seq_pc_wb_pipe_reg;\n\n    always @(posedge clk or posedge reset)\n    if (reset)\n    begin\n        rf_en_wb_pipe_reg          <=  0;\n        wb_sel_wb_pipe_reg         <=  0;\n        rd_wb_pipe_reg             <=  0;\n        alu_res_wb_pipe_reg        <=  0;\n        read_data_wb_pipe_reg      <=  0;\n        instr_retired_wb_pipe_reg  <=  0;\n        next_seq_pc_wb_pipe_reg    <=  0;\n    end\n    else\n    begin\n        rf_en_wb_pipe_reg          <=  rf_en_wb_pipe_reg_i;\n        wb_sel_wb_pipe_reg         <=  wb_sel_wb_pipe_reg_i;\n        rd_wb_pipe_reg             <=  rd_wb_pipe_reg_i;\n        alu_res_wb_pipe_reg        <=  alu_res_wb_pipe_reg_i;\n        read_data_wb_pipe_reg      <=  read_data_wb_pipe_reg_i;\n        instr_retired_wb_pipe_reg  <=  valid_wb_pipe_reg_i;\n        next_seq_pc_wb_pipe_reg    <=  next_seq_pc_wb_pipe_reg_i;\n    end\n\nendmodule\n",
        "module_name": "wb_pipe_reg",
        "module_hash": "3916f60167db223ae4a77d7cec8a802c",
        "dataset_index": 22748
      },
      "top__22e051f7": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [3:0] in1, // 4-bit input for the first port of the multiplexer\n    input [3:0] in2, // 4-bit input for the second port of the multiplexer\n    input select, // Select input to choose between the inputs of the multiplexer\n    input [3:0] add1, // 4-bit input for the first port of the adder\n    input [3:0] add2, // 4-bit input for the second port of the adder\n    output [3:0] mux_out, // 4-bit output from the selected input of the multiplexer\n    output [3:0] add_out, // 4-bit output from the sum of the inputs of the adder\n    output [3:0] final_out // 4-bit output from the bitwise XOR operation of the multiplexer and adder outputs\n);\n\nwire [3:0] mux_sel;\nwire [3:0] add_sum;\n\nmux2to1 mux_inst (\n    .in1(in1),\n    .in2(in2),\n    .select(select),\n    .out(mux_sel)\n);\n\nadder4bit add_inst (\n    .in1(add1),\n    .in2(add2),\n    .out(add_sum)\n);\n\n// Corrected code\nreg [3:0] mux_out;\nreg [3:0] add_out;\nreg [3:0] final_out;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        mux_out <= 4'b0;\n        add_out <= 4'b0;\n        final_out <= 4'b0;\n    end else begin\n        mux_out <= mux_sel;\n        add_out <= add_sum;\n        final_out <= mux_sel ^ add_sum;\n    end\nend\n\nendmodule\nmodule mux2to1 (\n    input [3:0] in1,\n    input [3:0] in2,\n    input select,\n    output [3:0] out\n);\n\nassign out = (select == 1) ? in2 : in1;\n\nendmodule\nmodule adder4bit (\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out\n);\n\nassign out = in1 + in2;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "22e051f7860113d9f4b778e67b90c153",
        "dataset_index": 19120
      },
      "sky130_fd_sc_hd__nor4_ab9ad0cb": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nor4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B, C, D     );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nor4",
        "module_hash": "ab9ad0cb79a2ef4adfd6f2c824d3a180",
        "dataset_index": 1510
      },
      "adder_7a3a772b": {
        "rtl_code": "module adder(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Z\n);\n\n    always @(*) begin\n        if((A+B) > 9) begin\n            Z = (A+B) % 10;\n        end\n        else begin\n            Z = A+B;\n        end\n    end\n\nendmodule",
        "module_name": "adder",
        "module_hash": "7a3a772bb2b73d60d9763cd22b06e4ba",
        "dataset_index": 13545
      },
      "mux4_f9019734": {
        "rtl_code": "module mux4(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    input en,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    if (en == 0) begin\n        out = 4'b0;\n    end else begin\n        case (sel)\n            2'b00: out = in0;\n            2'b01: out = in1;\n            2'b10: out = in2;\n            2'b11: out = in3;\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "f901973429331d4e6cb0c235519e50d4",
        "dataset_index": 8841
      },
      "sky130_fd_sc_ls__nand4bb_483260fb": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__nand4bb (\n    Y  ,\n    A_N,\n    B_N,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B_N;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out;\n    wire or0_out_Y;\n\n    nand nand0 (nand0_out, D, C               );\n    or   or0   (or0_out_Y, B_N, A_N, nand0_out);\n    buf  buf0  (Y        , or0_out_Y          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__nand4bb",
        "module_hash": "483260fb29eb06c3d7547d1d6a239a37",
        "dataset_index": 8793
      },
      "fifo_memory #_4d79464e": {
        "rtl_code": "\nmodule fifo_memory #\n  (\n    parameter DW       = 8,         \n    parameter DEPTH    = 8,         \n    parameter REG      = 0,         \n    parameter AW       = $clog2(DEPTH),\n    parameter PROGFULL = DEPTH-1\n  ) \n  (\n    input        clk,      \n    input        nreset,   \n    input        clear,    \n    input [DW-1:0]  din,   \n    input        wr_en,    \n    output       full,     \n    output       almost_full, \n    input        rd_en,    \n    output [DW-1:0] dout,  \n    output       empty,    \n    output reg [AW-1:0] rd_count \n  );\n\n  reg [AW-1:0]          wr_addr;\n  reg [AW-1:0]          rd_addr;\n  wire                fifo_read;\n  wire                fifo_write;\n  wire                ptr_match;\n  wire                fifo_empty;\n\n  assign fifo_read   = rd_en & ~empty;\n  assign fifo_write  = wr_en & ~full;\n  assign almost_full = (rd_count == PROGFULL);\n  assign ptr_match   = (wr_addr == rd_addr);\n  assign full        = ptr_match & (wr_addr[AW-1]!=rd_addr[AW-1]);\n  assign fifo_empty  = ptr_match & (wr_addr[AW-1]==rd_addr[AW-1]);\n\n  always @ (posedge clk or negedge nreset) begin\n    if(~nreset) begin\t   \n      wr_addr <= 0;\n      rd_addr <= 0;\n      rd_count <= 0;\n    end else if(clear) begin\t   \n      wr_addr <= 0;\n      rd_addr <= 0;\n      rd_count <= 0;\n    end else if(fifo_write & fifo_read) begin\n      wr_addr <= wr_addr + 1;\n      rd_addr <= rd_addr + 1;\t      \n    end else if(fifo_write) begin\n      wr_addr <= wr_addr + 1;\n      rd_count <= rd_count + 1;\t\n    end else if(fifo_read) begin\t      \n      rd_addr <= rd_addr + 1;\n      rd_count <= rd_count - 1;\n    end\n  end\n\n  reg empty_reg;\t   \n  always @ (posedge clk) begin\n    empty_reg <= fifo_empty;\n  end\n\n  assign empty = (REG==1) ? empty_reg : fifo_empty;\n\n  dual_port_ram #(\n    .DATA_WIDTH(DW),\n    .ADDR_WIDTH(AW)\n  ) ram(\n        .we(fifo_write),\n        .clk(clk),\n        .addr1(wr_addr),\n        .addr2(rd_addr),\n        .din(din),\n        .dout(dout)\n    );\n\nendmodule\nmodule dual_port_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n  ) (\n    input        clk,\n    input        we,\n    input [ADDR_WIDTH-1:0]  addr1,\n    input [ADDR_WIDTH-1:0]  addr2,\n    input [DATA_WIDTH-1:0]  din,\n    output [DATA_WIDTH-1:0]  dout\n  );\n   reg [DATA_WIDTH-1:0] ram [0:2**ADDR_WIDTH-1];\n   \n   assign dout = (addr2 == addr1) ? din : ram[addr2];\n   \n   always @(posedge clk)\n     if (we)\n       ram[addr1] <= din;\nendmodule",
        "module_name": "fifo_memory #",
        "module_hash": "4d79464e2cde17f5f98eb83094357852",
        "dataset_index": 3332
      },
      "FSM_000c2031": {
        "rtl_code": "module FSM(\n    input clk,\n    input reset,\n    input [8:0] rom_addr,\n    input [25:0] rom_q,\n    output reg [5:0] ram_a_addr,\n    output reg [5:0] ram_b_addr,\n    output reg ram_b_w,\n    output reg [10:0] pe,\n    output reg done\n);\n\n    // Internal registers\n    reg [5:0] dest;\n    reg [1:0] op;\n    reg [5:0] times;\n    reg [5:0] src1;\n    reg [5:0] src2;\n    reg [10:0] result;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            // Reset all registers\n            dest <= 0;\n            op <= 0;\n            times <= 0;\n            src1 <= 0;\n            src2 <= 0;\n            result <= 0;\n            ram_a_addr <= 0;\n            ram_b_addr <= 0;\n            ram_b_w <= 0;\n            pe <= 0;\n            done <= 0;\n        end else begin\n            // Read instruction from rom_q\n            {dest, src1, op, times, src2} <= rom_q;\n\n            // Set RAM addresses\n            ram_a_addr <= src1;\n            ram_b_addr <= src2;\n\n            // Perform operation\n            case(op)\n                2'b00: begin // ADD\n                    result <= src1 + src2;\n                end\n                2'b01: begin // SUB\n                    result <= src1 - src2;\n                end\n                2'b10: begin // CUBIC\n                    result <= src1 * src1 * src1 * times;\n                end\n                2'b11: begin // MULT\n                    result <= src1 * src2;\n                end\n                default: begin\n                    result <= 0;\n                end\n            endcase\n\n            // Write result to RAM B\n            ram_b_w <= 1;\n            pe <= result;\n            done <= 1;\n        end\n    end\nendmodule",
        "module_name": "FSM",
        "module_hash": "000c20316c66f9bafb12f82f8d92dd59",
        "dataset_index": 2690
      },
      "sky130_fd_sc_hd__nor4bb_f57d0a6d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nor4bb (\n    Y  ,\n    A  ,\n    B  ,\n    C_N,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n    input  D_N;\n\n    wire nor0_out  ;\n    wire and0_out_Y;\n\n    nor nor0 (nor0_out  , A, B              );\n    and and0 (and0_out_Y, nor0_out, C_N, D_N);\n    buf buf0 (Y         , and0_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nor4bb",
        "module_hash": "f57d0a6d2b7c01f63ec89e377b925535",
        "dataset_index": 16141
      },
      "SingleCounter_f5079f4f": {
        "rtl_code": "\nmodule SingleCounter(\n  input   clock,\n  input   reset,\n  input   io_input_reset,\n  output  io_output_done\n);\n  reg [5:0] count;\n  wire _toggle;\n\n  assign _toggle = (count == 6'd63);\n  assign io_output_done = _toggle;\n\n  always @(posedge clock) begin\n    if (reset || io_input_reset) begin\n      count <= 6'b0;\n    end else if (_toggle) begin\n      count <= 6'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\nendmodule\n",
        "module_name": "SingleCounter",
        "module_hash": "f5079f4f39efa198487474db91f326f4",
        "dataset_index": 15431
      },
      "sequence_detector_1337e4bb": {
        "rtl_code": "module sequence_detector(\n    input clear, switch, clock,\n    output reg request\n);\n\n    reg [1:0] state;\n    parameter state_a = 2'b00, state_b = 2'b01, state_c = 2'b10;\n\n    always @(posedge clock) begin\n        if (clear) begin\n            state <= state_a;\n            request <= 0;\n        end\n        else begin\n            case (state)\n                state_a:\n                    if (switch) begin\n                        state <= state_b;\n                    end\n                state_b:\n                    if (!switch) begin\n                        state <= state_c;\n                    end\n                state_c:\n                    if (switch) begin\n                        state <= state_a;\n                        request <= 1;\n                    end\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "sequence_detector",
        "module_hash": "1337e4bbf336a4f2a1dfab68aa4b498d",
        "dataset_index": 15128
      },
      "multiplier_block_b7e2e023": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n  wire [31:0]\n    w1,\n    w16,\n    w17,\n    w4,\n    w13,\n    w6656,\n    w6643,\n    w16384,\n    w23027;\n\n  assign w1 = i_data0;\n  assign w4 = w1 << 2; // missing multiplier\n  assign w16 = w1 << 4;\n  assign w16384 = w1 << 14;\n  assign w17 = w1 + w16;\n  assign w13 = w17 - w4; // missing multiplier\n  assign w6656 = w13 << 9;\n  assign w6643 = w6656 - w13;\n  assign w23027 = w6643 + w16384;\n  \n  assign o_data0 = w23027;\n\n  //multiplier_block area estimate = 5791.26237074559;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "b7e2e02328e2abbda79e3f68ea18b6a6",
        "dataset_index": 7356
      },
      "bitwise_and_1265ba66": {
        "rtl_code": "module bitwise_and(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] Z\n);\n\n    assign Z = A & B;\n\nendmodule",
        "module_name": "bitwise_and",
        "module_hash": "1265ba66ae2f6d3c4f60ede90108c1e4",
        "dataset_index": 881
      },
      "top__363aa7b6": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input ena,     // Synchronous active-high enable\n    input [1023:0] in,\n    input [7:0] sel,\n    output [7:0] out);\n\n    reg [15:0] counter;\n    reg [7:0] mux_output;\n    wire [3:0] select_input;\n    wire [11:0] add_output;\n\n    // 4-digit binary up-counter\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 0;\n        end else if (ena) begin\n            counter <= counter + 1;\n        end\n    end\n\n    // 256-to-1 multiplexer with priority encoder\n    assign select_input = 1 <<< sel[2:0];\n\n    always @(*) begin\n        mux_output = in[select_input * 4 +: 4];\n    end\n\n    // Additive functional module\n    assign add_output = counter + mux_output;\n\n    assign out = add_output[11:4];\n\nendmodule",
        "module_name": "top_",
        "module_hash": "363aa7b669de596fe0b9f3781d316066",
        "dataset_index": 19639
      }
    },
    "batch_6913ad8c9d348190ab0240cf02dbdc84": {
      "sky130_fd_sc_lp__nand4_928e1161": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, D, C, B, A     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__nand4",
        "module_hash": "928e1161fdd642a276d7e4be7714fe41",
        "dataset_index": 17298
      },
      "watchdog_timer_886119c9": {
        "rtl_code": "module watchdog_timer (\n  input clk,\n  input reset,\n  input [31:0] timeout,\n  output wd_reset\n);\n\n  reg [31:0] counter;\n  reg wd_reset_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      counter <= 0;\n      wd_reset_reg <= 0;\n    end\n    else begin\n      counter <= counter + 1;\n      if (counter == timeout) begin\n        wd_reset_reg <= 1;\n      end\n      else begin\n        wd_reset_reg <= 0;\n      end\n    end\n  end\n\n  assign wd_reset = wd_reset_reg;\n\nendmodule",
        "module_name": "watchdog_timer",
        "module_hash": "886119c974345a6dcbfe9ee85c19ff6a",
        "dataset_index": 16752
      },
      "sky130_fd_sc_hs__dfsbp_cbed1f89": {
        "rtl_code": "\nmodule sky130_fd_sc_hs__dfsbp (\n    VPWR ,\n    VGND ,\n    Q    ,\n    Q_N  ,\n    CLK  ,\n    D    ,\n    SET_B\n);\n\n    // Module ports\n    input  VPWR ;\n    input  VGND ;\n    output Q    ;\n    output Q_N  ;\n    input  CLK  ;\n    input  D    ;\n    input  SET_B;\n\n    // Local signals\n    reg    buf_Q        ;\n    wire   SET          ;\n    reg    notifier     ;\n    wire   D_delayed    ;\n    wire   SET_B_delayed;\n    wire   CLK_delayed  ;\n    wire   awake        ;\n    wire   cond0        ;\n    wire   cond1        ;\n\n    // Additions\n    assign D_delayed = D;\n    assign SET_B_delayed = SET_B;\n    assign CLK_delayed = CLK;\n    assign SET = ~SET_B_delayed;\n    assign awake = (VPWR === 1'b1 );\n    assign cond0 = (SET_B_delayed === 1'b1 );\n    assign cond1 = (SET_B === 1'b1 );\n\n    always @(posedge CLK_delayed or negedge awake) begin\n        if (!awake) begin\n            buf_Q <= 1'b0;\n            notifier <= 1'b0;\n        end else if (!cond0 || !cond1) begin\n            buf_Q <= 1'b1;\n            notifier <= 1'b1;\n        end else if (notifier) begin\n            buf_Q <= D_delayed;\n            notifier <= 1'b0;\n        end\n    end\n\n    buf buf0 (Q     , buf_Q                                            );\n    not not1 (Q_N   , buf_Q                                            );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hs__dfsbp",
        "module_hash": "cbed1f896e5db344520da713b7029a67",
        "dataset_index": 14026
      },
      "circuit_design_ff2b1696": {
        "rtl_code": "module circuit_design (\n    X   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign X = (A1) ? 1'b0 :\n               (A2) ? 1'b1 :\n               (A3) ? 1'b1 :\n                      1'b0 ;\n\nendmodule",
        "module_name": "circuit_design",
        "module_hash": "ff2b1696f3fbe6f5eb933a6448b2e7fa",
        "dataset_index": 2235
      },
      "mux_2_1_0a74ee02": {
        "rtl_code": "module mux_2_1(\n    input wire a,\n    input wire b,\n    input wire en,\n    output reg y\n);\n\n  always @*\n    begin\n      if (en)\n        begin\n          y <= b;\n        end\n      else\n        begin\n          y <= a;\n        end\n    end\n\nendmodule",
        "module_name": "mux_2_1",
        "module_hash": "0a74ee026414678a9d4d393a95dc6dc1",
        "dataset_index": 12847
      },
      "top__d2db80be": {
        "rtl_code": "module top_module (\n    input clk,\n    input [7:0] in,\n    output [3:0] q\n);\n\n    reg [7:0] prev_in;\n    reg edge_detect;\n    reg pulse;\n    reg [3:0] counter;\n\n    always @(posedge clk) begin\n        prev_in <= in;\n        edge_detect <= (prev_in[0] == 1) && (in[0] == 0);\n        pulse <= (edge_detect == 1) ? 1 : 0;\n        if (pulse == 1) begin\n            if (counter == 15) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign q = counter;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "d2db80be2d7ec70d83cd0689a8b293d0",
        "dataset_index": 19113
      },
      "ALU_ff149c46": {
        "rtl_code": "\n\n\nmodule ALU( clk, op, right, AI, BI, CI, CO, BCD, OUT, V, Z, N, HC, RDY );\n\tinput clk;\n\tinput right;\n\tinput [3:0] op;\t\tinput [7:0] AI;\n\tinput [7:0] BI;\n\tinput CI;\n\tinput BCD;\t\toutput [7:0] OUT;\n\toutput CO;\n\toutput V;\n\toutput Z;\n\toutput N;\n\toutput HC;\n\tinput RDY;\n\nreg [7:0] OUT;\nreg CO;\nwire V;\nwire Z;\nreg N;\nreg HC;\n\nreg AI7;\nreg BI7;\nreg [8:0] temp_logic;\nreg [7:0] temp_BI;\nreg [4:0] temp_l;\nreg [4:0] temp_h;\nwire [8:0] temp = { temp_h, temp_l[3:0] };\nwire adder_CI = (right | (op[3:2] == 2'b11)) ? 0 : CI;\n\nalways @*  begin\n\tcase( op[1:0] )\n\t    2'b00: temp_logic = AI | BI;\n\t    2'b01: temp_logic = AI & BI;\n\t    2'b10: temp_logic = AI ^ BI;\n\t    2'b11: temp_logic = AI;\n\tendcase\n\n\tif( right )\n\t    temp_logic = { AI[0], CI, AI[7:1] };\nend\n\nalways @* begin\n\tcase( op[3:2] )\n\t    2'b00: temp_BI = BI;\t2'b01: temp_BI = ~BI;\t2'b10: temp_BI = temp_logic;\t2'b11: temp_BI = 0;\t\tendcase\t\nend\n\nwire HC9 = BCD & (temp_l[3:1] >= 3'd5);\n\nwire CO9 = BCD & (temp_h[3:1] >= 3'd5);\n\nwire temp_HC = temp_l[4] | HC9;\n\nalways @* begin\n\ttemp_l = temp_logic[3:0] + temp_BI[3:0] + adder_CI;\n\ttemp_h = temp_logic[8:4] + temp_BI[7:4] + temp_HC;\nend\n\nalways @(posedge clk)\n    if( RDY ) begin\n\tAI7 <= AI[7];\n\tBI7 <= temp_BI[7];\n\tOUT <= temp[7:0];\n\tCO  <= temp[8] | CO9;\n\tN   <= temp[7];\n\tHC  <= temp_HC;\n    end\n\nassign V = AI7 ^ BI7 ^ CO ^ N;\nassign Z = ~|OUT;\n\nendmodule\n",
        "module_name": "ALU",
        "module_hash": "ff149c46f34b021afbaefc62160b7119",
        "dataset_index": 25513
      },
      "bin2gray_eaf51166": {
        "rtl_code": "\nmodule bin2gray(\n    input [2:0] bin,\n    input reset,\n    output reg [2:0] gray\n);\n\n\nalways @(*) begin\n    if (reset) begin\n        gray <= 3'b0;\n    end\n    else begin\n        gray[2] = bin[2];\n        gray[1] = gray[2] ^ bin[1];\n        gray[0] = gray[1] ^ bin[0];\n    end\nend\n\nendmodule",
        "module_name": "bin2gray",
        "module_hash": "eaf511661aa26e32f626b33ca83543b6",
        "dataset_index": 20962
      },
      "fifo #_1125f601": {
        "rtl_code": "module fifo #(\n  parameter WIDTH = 8\n)\n(\n  input clk,\n  input reset,\n  input wr_en,\n  input rd_en,\n  input [WIDTH-1:0] din,\n  output reg [WIDTH-1:0] dout,\n  output reg full,\n  output reg empty\n);\n\n  reg [WIDTH-1:0] buffer [0:15];\n  reg [4:0] head;\n  reg [4:0] tail;\n  wire [4:0] count = head - tail;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      head <= 0;\n      tail <= 0;\n    end else begin\n      if (wr_en && !full) begin\n        buffer[head] <= din;\n        head <= head + 1;\n      end\n      if (rd_en && !empty) begin\n        dout <= buffer[tail];\n        tail <= tail + 1;\n      end\n    end\n  end\n\n  always @* begin\n    full = (count == 16);\n    empty = (count == 0);\n  end\n\nendmodule",
        "module_name": "fifo #",
        "module_hash": "1125f601df0e9db8672578310deee2f0",
        "dataset_index": 6831
      },
      "fifo_a64cf8f6": {
        "rtl_code": "module fifo\n#(\n    parameter WIDTH = 8,\n    parameter DEPTH = 4,\n    parameter ADDR_W = 2\n)\n(\n    input clk_i,\n    input rst_i,\n    input [WIDTH-1:0] data_in_i,\n    input push_i,\n    input pop_i,\n    output [WIDTH-1:0] data_out_o,\n    output accept_o,\n    output valid_o\n);\n\nlocalparam COUNT_W = ADDR_W + 1;\n\nreg [WIDTH-1:0] ram_q[DEPTH-1:0];\nreg [ADDR_W-1:0] rd_ptr_q;\nreg [ADDR_W-1:0] wr_ptr_q;\nreg [COUNT_W-1:0] count_q;\n\ninteger i;\n\nalways @ (posedge clk_i or posedge rst_i)\nbegin\n    if (rst_i)\n    begin\n        count_q   <= {(COUNT_W) {1'b0}};\n        rd_ptr_q  <= {(ADDR_W) {1'b0}};\n        wr_ptr_q  <= {(ADDR_W) {1'b0}};\n        for (i=0;i<DEPTH;i=i+1)\n        begin\n            ram_q[i] <= {(WIDTH) {1'b0}};\n        end\n    end\n    else\n    begin\n        // Push\n        if (push_i & accept_o)\n        begin\n            ram_q[wr_ptr_q] <= data_in_i;\n            wr_ptr_q        <= wr_ptr_q + 1;\n        end\n\n        // Pop\n        if (pop_i & valid_o)\n        begin\n            rd_ptr_q <= rd_ptr_q + 1;\n        end\n\n        // Count up\n        if ((push_i & accept_o) & ~(pop_i & valid_o))\n        begin\n            count_q <= count_q + 1;\n        end\n        // Count down\n        else if (~(push_i & accept_o) & (pop_i & valid_o))\n        begin\n            count_q <= count_q - 1;\n        end\n    end\nend\n\nassign valid_o = (count_q != 0);\nassign accept_o = (count_q != DEPTH);\nassign data_out_o = ram_q[rd_ptr_q];\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "a64cf8f6b4ab4e6fabd348226632d122",
        "dataset_index": 7935
      },
      "top__c5cf9817": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset, // synchronous active-high reset\n    output reg [15:0] out,\n    output [1:0] count\n);\n\n    // 2-bit synchronous up-counter\n    reg [1:0] counter;\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 2'b00;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n    assign count = counter;\n\n    // 3-to-8 decoder\n    wire [2:0] decoder_in;\n    assign decoder_in = counter;\n    wire [7:0] decoder_out;\n    decoder_3to8 decoder_inst (\n        .in(decoder_in),\n        .out(decoder_out)\n    );\n\n    // additional logic gates to implement 4-to-16 decoder\n    wire [15:0] decoder_out_16;\n    assign decoder_out_16 = {decoder_out[0], decoder_out[0], decoder_out[0], decoder_out[0], decoder_out[1], decoder_out[1], decoder_out[1], decoder_out[1], decoder_out[2], decoder_out[2], decoder_out[2], decoder_out[2], decoder_out[3], decoder_out[3], decoder_out[3], decoder_out[3]};\n\n    // final output module\n    reg [15:0] out_reg = decoder_out_16;\n    always @(posedge clk) out <= out_reg;\n\nendmodule\nmodule decoder_3to8 (\n    input [2:0] in,\n    output reg [7:0] out\n);\n    always @(*) begin\n        case (in)\n            3'b000: out = 8'b00000001;\n            3'b001: out = 8'b00000010;\n            3'b010: out = 8'b00000100;\n            3'b011: out = 8'b00001000;\n            3'b100: out = 8'b00010000;\n            3'b101: out = 8'b00100000;\n            3'b110: out = 8'b01000000;\n            3'b111: out = 8'b10000000;\n            default: out = 8'b00000000;\n        endcase\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "c5cf98175396a4b0fe257db503492b1d",
        "dataset_index": 10828
      },
      "regfile_5f49c11c": {
        "rtl_code": "module regfile(data_out, data_in, wraddr, rdaddr, wren, clk);\n\n  // Define constants for the register file\n  parameter DEPTH = 8;\n  parameter WIDTH = 8;\n  \n  // Declare input/output signals\n  input [WIDTH-1:0] data_in;\n  input [DEPTH-1:0] wraddr, rdaddr;\n  input wren, clk;\n  output reg [WIDTH-1:0] data_out;\n  \n  // Declare the register file as a multi-dimensional array of registers\n  reg [WIDTH-1:0] reg_file [DEPTH-1:0];\n  \n  // Write and read operations for the register file\n  always @(posedge clk) begin\n    if (wren) begin\n      reg_file[wraddr] <= data_in;\n    end\n    else begin\n      data_out <= reg_file[rdaddr];\n    end\n  end\n  \nendmodule",
        "module_name": "regfile",
        "module_hash": "5f49c11c84d13311fa76341b896237e0",
        "dataset_index": 19782
      },
      "vending_machine_controller_c1bc519f": {
        "rtl_code": "\nmodule vending_machine_controller(\n    input [1:0] product_sel,\n    input [7:0] money_in, // Fix: Increased the width of money_in to accommodate all values\n    output reg dispense,\n    output reg [5:0] change\n);\n\n    // Define the prices of the products\n    parameter PRICE_1 = 6'd10; // 50 cents\n    parameter PRICE_2 = 6'd15; // 75 cents\n    parameter PRICE_3 = 6'd20; // 1 dollar\n    parameter PRICE_4 = 6'd25; // 1 dollar 25 cents\n    \n    // Define the total cost of the selected product\n    reg [5:0] total_cost;\n    always @(*) begin\n        case (product_sel)\n            2'b00: total_cost = PRICE_1;\n            2'b01: total_cost = PRICE_2;\n            2'b10: total_cost = PRICE_3;\n            2'b11: total_cost = PRICE_4;\n        endcase\n    end\n    \n    // Define the remaining amount of money needed to dispense the product\n    reg [6:0] remaining_cost; // Fix: Increased the width of remaining_cost to accommodate all values\n    always @(*) begin\n        if (money_in < total_cost)\n            remaining_cost = total_cost - money_in;\n        else\n            remaining_cost = 0;\n    end\n    \n    // Define the amount of change to be returned to the user\n    reg [5:0] change_due;\n    always @(*) begin\n        change_due = money_in - total_cost;\n    end\n    \n    // Define the dispense signal\n    always @(*) begin\n        if (remaining_cost == 0)\n            dispense = 1'b1;\n        else\n            dispense = 1'b0;\n    end\n    \n    // Define the change signal\n    always @(*) begin\n        if (remaining_cost == 0)\n            change = change_due;\n        else\n            change = 6'b000000;\n    end\n\nendmodule",
        "module_name": "vending_machine_controller",
        "module_hash": "c1bc519f70754e46ddbd7f5c8cf76211",
        "dataset_index": 11638
      },
      "xor_module_a00dfec9": {
        "rtl_code": "\nmodule xor_module(\n    input [2:0] in_data,\n    output [2:0] out_xor,\n    output [2:0] out_inv\n);\n    assign out_xor = in_data ^ 3'b111;\n    assign out_inv = ~in_data;\nendmodule\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    input valid_a,\n    input ready_b,\n    output reg valid_b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output reg [5:0] out_not\n);\n\n    wire [2:0] out_xor_a;\n    wire [2:0] out_xor_b;\n    wire [2:0] inv_a;\n    wire [2:0] inv_b;\n    wire not_ready_b;\n\n    xor_module xor_a(.in_data(a), .out_xor(out_xor_a), .out_inv(inv_a));\n    xor_module xor_b(.in_data(b), .out_xor(out_xor_b), .out_inv(inv_b));\n\n    assign out_or_bitwise = out_xor_a | out_xor_b;\n\n    assign out_or_logical = (|out_or_bitwise);\n\n    always @(posedge valid_a) begin\n        if (ready_b) begin\n            valid_b <= 1;\n            out_not <= {inv_a, inv_b};\n        end\n        else\n            valid_b <= 0;\n    end\n\n    assign not_ready_b = ~ready_b;\n    assign ready_b = not_ready_b;\n\nendmodule",
        "module_name": "xor_module",
        "module_hash": "a00dfec9f100a0086fb6bc0011156bc4",
        "dataset_index": 18691
      },
      "calculator_19efb10a": {
        "rtl_code": "module calculator (\n    A,\n    B,\n    OPCODE,\n    RESET,\n    RESULT\n);\n\n    input [31:0] A;\n    input [31:0] B;\n    input [1:0] OPCODE;\n    input RESET;\n    output [31:0] RESULT;\n\n    reg [31:0] result;\n\n    always @(*) begin\n        case(OPCODE)\n            2'b00: result = A + B; // addition\n            2'b01: result = A - B; // subtraction\n            2'b10: result = A * B; // multiplication\n            2'b11: result = A / B; // division\n            default: result = 0; // default case\n        endcase\n\n        if(RESET) begin\n            result = 0; // reset result to 0\n        end\n    end\n\n    assign RESULT = result;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "19efb10a94532e44cc087bccc5833e5b",
        "dataset_index": 18836
      },
      "softusb_tx_9aab684b": {
        "rtl_code": "\n\nmodule softusb_tx(\n\tinput usb_clk,\n\tinput usb_rst,\n\n\tinput [7:0] tx_data,\n\tinput tx_valid,\n\toutput reg tx_ready,\n\n\toutput reg txp,\n\toutput reg txm,\n\toutput reg txoe,\n\n\tinput low_speed,\n\tinput generate_eop\n);\n\n\nreg txp_r;\nreg txm_r;\nreg txoe_r;\nalways @(posedge usb_clk) begin\n\ttxp <= txp_r;\n\ttxm <= txm_r;\n\ttxoe <= txoe_r;\nend\n\n\nreg gce; \nreg [5:0] gce_counter;\nalways @(posedge usb_clk) begin\n\tif(usb_rst) begin\n\t\tgce <= 1'b0;\n\t\tgce_counter <= 6'd0;\n\tend else begin\n\t\tgce <= 1'b0;\n\t\tgce_counter <= gce_counter + 6'd1;\n\t\tif((low_speed & gce_counter == 6'd47) | (~low_speed & gce_counter == 6'd5)) begin\n\t\t\tgce <= 1'b1;\n\t\t\tgce_counter <= 6'd0;\n\t\tend\n\tend\nend\n\n\nreg sr_rst;\nreg sr_load;\nreg sr_done;\nreg sr_out;\nreg [2:0] bitcount;\nreg [2:0] onecount;\nreg [6:0] sr;\nalways @(posedge usb_clk) begin\n\tif(sr_rst) begin\n\t\tsr_done <= 1'b1;\n\t\tonecount <= 3'd0;\n\t\tsr_out <= 1'b1;\n\tend else if(gce) begin\n\t\tif(sr_load) begin\n\t\t\tsr_done <= 1'b0;\n\t\t\tsr_out <= tx_data[0];\n\t\t\tbitcount <= 3'd0;\n\t\t\tif(tx_data[0])\n\t\t\t\tonecount <= onecount + 3'd1;\n\t\t\telse\n\t\t\t\tonecount <= 3'd0;\n\t\t\tsr <= tx_data[7:1];\n\t\tend else if(~sr_done) begin\n\t\t\tif(onecount == 3'd6) begin\n\t\t\t\tonecount <= 3'd0;\n\t\t\t\tsr_out <= 1'b0;\n\t\t\t\tif(bitcount == 3'd7)\n\t\t\t\t\tsr_done <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tsr_out <= sr[0];\n\t\t\t\tif(sr[0])\n\t\t\t\t\tonecount <= onecount + 3'd1;\n\t\t\t\telse\n\t\t\t\t\tonecount <= 3'd0;\n\t\t\t\tbitcount <= bitcount + 3'd1;\n\t\t\t\tif((bitcount == 3'd6) & (~sr[0] | (onecount != 3'd5)))\n\t\t\t\t\tsr_done <= 1'b1;\n\t\t\t\tsr <= {1'b0, sr[6:1]};\n\t\t\tend\n\t\tend\n\tend\nend\n\n\nreg txoe_ctl;\nreg generate_se0;\nreg generate_j;\n\nalways @(posedge usb_clk) begin\n\tif(usb_rst) begin\n\t\ttxoe_r <= 1'b0;\n\t\ttxp_r <= ~low_speed;\n\t\ttxm_r <= low_speed;\n\tend else if(gce) begin\n\t\tif(~txoe_ctl) begin\n\t\t\ttxp_r <= ~low_speed; \n\t\t\ttxm_r <= low_speed;\n\t\tend else begin\n\t\t\tcase({generate_se0, generate_j})\n\t\t\t\t2'b00: begin\n\t\t\t\t\tif(~sr_out) begin\n\t\t\t\t\t\ttxp_r <= ~txp_r;\n\t\t\t\t\t\ttxm_r <= ~txm_r;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b10: begin\n\t\t\t\t\ttxp_r <= 1'b0;\n\t\t\t\t\ttxm_r <= 1'b0;\n\t\t\t\tend\n\t\t\t\t2'b01: begin\n\t\t\t\t\ttxp_r <= ~low_speed;\n\t\t\t\t\ttxm_r <= low_speed;\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\ttxp_r <= 1'bx;\n\t\t\t\t\ttxm_r <= 1'bx;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\ttxoe_r <= txoe_ctl;\n\tend\nend\n\n\n\nparameter IDLE\t\t= 3'd0;\nparameter DATA\t\t= 3'd1;\nparameter EOP1\t\t= 3'd2;\nparameter EOP2\t\t= 3'd3;\nparameter J\t\t= 3'd4;\nparameter GEOP1\t\t= 3'd5;\nparameter GEOP2\t\t= 3'd6;\nparameter GJ\t\t= 3'd7;\n\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge usb_clk) begin\n\tif(usb_rst)\n\t\tstate <= IDLE;\n\telse if(gce)\n\t\tstate <= next_state;\nend\n\nreg tx_ready0;\nalways @(posedge usb_clk)\n\ttx_ready <= tx_ready0 & gce;\n\nreg tx_valid_r;\nreg transmission_continue;\nreg transmission_end_ack;\nalways @(posedge usb_clk) begin\n\tif(usb_rst) begin\n\t\ttx_valid_r <= 1'b0;\n\t\ttransmission_continue <= 1'b1;\n\tend else begin\n\t\ttx_valid_r <= tx_valid;\n\t\tif(tx_valid_r & ~tx_valid)\n\t\t\ttransmission_continue <= 1'b0;\n\t\tif(transmission_end_ack)\n\t\t\ttransmission_continue <= 1'b1;\n\tend\nend\n\nreg generate_eop_pending;\nreg generate_eop_clear;\nalways @(posedge usb_clk) begin\n\tif(usb_rst)\n\t\tgenerate_eop_pending <= 1'b0;\n\telse begin\n\t\tif(generate_eop)\n\t\t\tgenerate_eop_pending <= 1'b1;\n\t\tif(generate_eop_clear)\n\t\t\tgenerate_eop_pending <= 1'b0;\n\tend\nend\n\nalways @(*) begin\n\ttxoe_ctl = 1'b0;\n\tsr_rst = 1'b0;\n\tsr_load = 1'b0;\n\tgenerate_se0 = 1'b0;\n\tgenerate_j = 1'b0;\n\ttx_ready0 = 1'b0;\n\ttransmission_end_ack = 1'b0;\n\tgenerate_eop_clear = 1'b0;\n\n\tnext_state = state;\n\n\tcase(state)\n\t\tIDLE: begin\n\t\t\ttxoe_ctl = 1'b0;\n\t\t\tif(generate_eop_pending)\n\t\t\t\tnext_state = GEOP1;\n\t\t\telse begin\n\t\t\t\tif(tx_valid) begin\n\t\t\t\t\tsr_load = 1'b1;\n\t\t\t\t\ttx_ready0 = 1'b1;\n\t\t\t\t\tnext_state = DATA;\n\t\t\t\tend else\n\t\t\t\t\tsr_rst = 1'b1;\n\t\t\tend\n\t\tend\n\t\tDATA: begin\n\t\t\ttxoe_ctl = 1'b1;\n\t\t\tif(sr_done) begin\n\t\t\t\tif(transmission_continue) begin\n\t\t\t\t\tsr_load = 1'b1;\n\t\t\t\t\ttx_ready0 = 1'b1;\n\t\t\t\tend else\n\t\t\t\t\tnext_state = EOP1;\n\t\t\tend\n\t\tend\n\t\tEOP1: begin\n\t\t\ttransmission_end_ack = 1'b1;\n\t\t\tsr_rst = 1'b1;\n\t\t\ttxoe_ctl = 1'b1;\n\t\t\tgenerate_se0 = 1'b1;\n\t\t\tnext_state = EOP2;\n\t\tend\n\t\tEOP2: begin\n\t\t\tsr_rst = 1'b1;\n\t\t\ttxoe_ctl = 1'b1;\n\t\t\tgenerate_se0 = 1'b1;\n\t\t\tnext_state = J;\n\t\tend\n\t\tJ: begin\n\t\t\tsr_rst = 1'b1;\n\t\t\ttxoe_ctl = 1'b1;\n\t\t\tgenerate_j = 1'b1;\n\t\t\tnext_state = IDLE;\n\t\tend\n\t\tGEOP1: begin\n\t\t\tsr_rst = 1'b1;\n\t\t\ttxoe_ctl = 1'b1;\n\t\t\tgenerate_se0 = 1'b1;\n\t\t\tnext_state = GEOP2;\n\t\tend\n\t\tGEOP2: begin\n\t\t\tsr_rst = 1'b1;\n\t\t\ttxoe_ctl = 1'b1;\n\t\t\tgenerate_se0 = 1'b1;\n\t\t\tnext_state = GJ;\n\t\tend\n\t\tGJ: begin\n\t\t\tgenerate_eop_clear = 1'b1;\n\t\t\tsr_rst = 1'b1;\n\t\t\ttxoe_ctl = 1'b1;\n\t\t\tgenerate_j = 1'b1;\n\t\t\tnext_state = IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "softusb_tx",
        "module_hash": "9aab684b43b8be9d9699f43f12b1d037",
        "dataset_index": 24791
      },
      "bitwise_operations_563938b1": {
        "rtl_code": "module bitwise_operations(\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] OP,\n    output reg [7:0] AND_out,\n    output reg [7:0] OR_out,\n    output reg [7:0] XOR_out,\n    output reg [7:0] NOT_out\n);\n\nalways @(*) begin\n    case (OP)\n        3'b000: begin // AND\n            AND_out = A & B;\n            OR_out = 8'b0;\n            XOR_out = 8'b0;\n            NOT_out = 8'b0;\n        end\n        3'b001: begin // OR\n            AND_out = 8'b0;\n            OR_out = A | B;\n            XOR_out = 8'b0;\n            NOT_out = 8'b0;\n        end\n        3'b010: begin // XOR\n            AND_out = 8'b0;\n            OR_out = 8'b0;\n            XOR_out = A ^ B;\n            NOT_out = 8'b0;\n        end\n        3'b011: begin // NOT\n            AND_out = 8'b0;\n            OR_out = 8'b0;\n            XOR_out = 8'b0;\n            NOT_out = ~A;\n        end\n        default: begin // Invalid operation\n            AND_out = 8'b0;\n            OR_out = 8'b0;\n            XOR_out = 8'b0;\n            NOT_out = 8'b0;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "bitwise_operations",
        "module_hash": "563938b197f8fadfae514fbb3f5c331c",
        "dataset_index": 18961
      },
      "CIC #_501e5b09": {
        "rtl_code": "module CIC #(\n  parameter n = 2, // number of input signals\n  parameter m = 2, // number of output signals\n  parameter r = 2, // decimation rate\n  parameter N = 2 // filter order\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk // Clock signal\n);\n\n\n// Decimation Stage\nreg [n-1:0] decimated_input;\nreg [7:0] counter; // counter for decimation\nalways @(posedge clk) begin\n  if (counter == r-1) begin\n    decimated_input <= in;\n    counter <= 0;\n  end else begin\n    counter <= counter + 1;\n  end\nend\n\n// Integrator Stage\nreg [n-1:0] integrator_input;\nreg [n-1:0] integrator_output;\nalways @(posedge clk) begin\n  integrator_input <= decimated_input;\n  integrator_output <= integrator_output + integrator_input;\nend\n\n// Comb Stage\nreg [n-1:0] comb_input;\nreg [n-1:0] comb_output;\nalways @(posedge clk) begin\n  comb_input <= integrator_output;\n  comb_output <= comb_input - comb_output;\nend\n\n// Output\nassign out = comb_output;\n\nendmodule",
        "module_name": "CIC #",
        "module_hash": "501e5b094e534a208dcaeeb16e140a77",
        "dataset_index": 1483
      },
      "adder4_e25d2f55": {
        "rtl_code": "module adder4 (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [3:1] carry; // Internal carries between stages\n\n// Stage 1\nassign sum[0] = a[0] ^ b[0] ^ cin;\nassign carry[1] = (a[0] & b[0]) | (cin & (a[0] ^ b[0]));\n\n// Stage 2\nassign sum[1] = a[1] ^ b[1] ^ carry[1];\nassign carry[2] = (a[1] & b[1]) | (carry[1] & (a[1] ^ b[1]));\n\n// Stage 3\nassign sum[2] = a[2] ^ b[2] ^ carry[2];\nassign carry[3] = (a[2] & b[2]) | (carry[2] & (a[2] ^ b[2]));\n\n// Stage 4\nassign sum[3] = a[3] ^ b[3] ^ carry[3];\nassign cout = (a[3] & b[3]) | (carry[3] & (a[3] ^ b[3]));\n\nendmodule\n",
        "module_name": "adder4",
        "module_hash": "e25d2f5595f5a8d2a5cc2f9c24cd3127",
        "dataset_index": 310
      },
      "RAM_65ebb8f1": {
        "rtl_code": "module RAM(\n    input wire clka,\n    input wire wea,\n    input wire [6:0] addra,\n    input wire [31:0] dina,\n    output reg [31:0] douta\n);\n\nreg [31:0] memory[0:127];\n\nalways @(posedge clka) begin\n    if(wea) begin\n        memory[addra] <= dina;\n    end\n    douta <= memory[addra];\nend\n\nendmodule",
        "module_name": "RAM",
        "module_hash": "65ebb8f1fdd68f040bb14c7adeedb2db",
        "dataset_index": 1474
      },
      "register #_2536435b": {
        "rtl_code": "\nmodule register #(parameter WIDTH = 8, parameter RESET_VALUE = 0)\n  (input [WIDTH-1:0] DataIn,\n   input Write,\n   input Clk,\n   input Reset,\n   input SyncReset,\n   output [WIDTH-1:0] DataOut);\n\n  reg [WIDTH-1:0] DataOut;\n\n  always @(posedge Clk or posedge Reset or posedge SyncReset) begin\n    if (Reset) begin\n      DataOut <= RESET_VALUE;\n    end else if (SyncReset) begin\n      DataOut <= RESET_VALUE;\n    end else if (Write) begin\n      DataOut <= DataIn;\n    end\n  end\n\nendmodule",
        "module_name": "register #",
        "module_hash": "2536435b1857d4e4d9c531848a7bdfd6",
        "dataset_index": 3726
      },
      "counter_035871e2": {
        "rtl_code": "module counter(\n   input clk,\n   output reg [3:0] out\n);\n\nalways @(posedge clk) begin\n   if (out == 4'b1111) begin\n      out <= 4'b0000;\n   end\n   else begin\n      out <= out + 1;\n   end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "035871e24b167abc1573ec77712d303a",
        "dataset_index": 20556
      },
      "bitwise_and_1f0e92b7": {
        "rtl_code": "module bitwise_and (\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out,\n    input VPWR, VGND, VPB, VNB\n);\n\nwire [3:0] not_in1;\nwire [3:0] not_in2;\nwire [3:0] not_out;\n\n// invert the inputs\nassign not_in1 = ~in1;\nassign not_in2 = ~in2;\n\n// perform the OR operation on the inverted inputs\nassign not_out[0] = not_in1[0] | not_in2[0];\nassign not_out[1] = not_in1[1] | not_in2[1];\nassign not_out[2] = not_in1[2] | not_in2[2];\nassign not_out[3] = not_in1[3] | not_in2[3];\n\n// invert the output of the OR gate to get the AND result\nassign out = ~not_out;\n\nendmodule",
        "module_name": "bitwise_and",
        "module_hash": "1f0e92b7a75fd1ecbe38e35ef39c56c5",
        "dataset_index": 2411
      },
      "top__fa3441a9": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [2:0] sel,  // Select input to choose between multiplexer and logical operations modes\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out,   // Output data\n    output reg out_and,     // Output of NAND gate for logical operations\n    output reg out_or,      // Output of NAND gate for logical operations\n    output reg out_xor      // Output of NAND gate for logical operations\n);\n\nreg [3:0] mux_out;\nreg [3:0] nand_in;\nreg [3:0] nand_in_neg;\nreg [3:0] nand_out;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        out <= 4'b0;\n        out_and <= 1'b0;\n        out_or <= 1'b0;\n        out_xor <= 1'b0;\n    end else begin\n        case (sel)\n            3'b000: begin\n                mux_out <= data0;\n            end\n            3'b001: begin\n                mux_out <= data1;\n            end\n            3'b010: begin\n                mux_out <= data2;\n            end\n            3'b011: begin\n                mux_out <= data3;\n            end\n            3'b100: begin\n                mux_out <= data4;\n            end\n            3'b101: begin\n                mux_out <= data5;\n            end\n            default: begin\n                mux_out <= mux_out;\n            end\n        endcase\n        \n        nand_in[0] <= mux_out[0];\n        nand_in[1] <= mux_out[1];\n        nand_in[2] <= mux_out[2];\n        nand_in[3] <= mux_out[3];\n        \n        nand_in_neg[0] <= ~mux_out[0];\n        nand_in_neg[1] <= ~mux_out[1];\n        nand_in_neg[2] <= ~mux_out[2];\n        nand_in_neg[3] <= ~mux_out[3];\n        \n        nand_out[0] <= ~(nand_in[0] & nand_in[1] & nand_in[2] & nand_in[3]);\n        nand_out[1] <= ~(nand_in_neg[0] & nand_in_neg[1] & nand_in_neg[2] & nand_in_neg[3]);\n        nand_out[2] <= ~(nand_in[0] & nand_in_neg[1] & nand_in_neg[2] & nand_in[3] | nand_in_neg[0] & nand_in[1] & nand_in[2] & nand_in_neg[3]);\n        \n        out <= mux_out;\n        out_and <= nand_out[0];\n        out_or <= nand_out[1];\n        out_xor <= nand_out[2];\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "fa3441a90f965d489d509c7873e2ba60",
        "dataset_index": 14242
      },
      "mig_7series_v2_0_fi_xor #_6f8d81e0": {
        "rtl_code": "\n\n\nmodule mig_7series_v2_0_fi_xor #\n(\nparameter integer DQ_WIDTH               = 72,\n  parameter integer DQS_WIDTH              = 9,\n  parameter integer nCK_PER_CLK            = 4\n)\n(\ninput  wire                              clk           , \n  input  wire [2*nCK_PER_CLK*DQ_WIDTH-1:0] wrdata_in     , \n  output wire [2*nCK_PER_CLK*DQ_WIDTH-1:0] wrdata_out    , \n  input  wire                              wrdata_en     , \n  input  wire [DQS_WIDTH-1:0]              fi_xor_we     ,\n  input  wire [DQ_WIDTH-1:0]               fi_xor_wrdata\n);\n\nlocalparam DQ_PER_DQS = DQ_WIDTH / DQS_WIDTH;\n\nreg [DQ_WIDTH-1:0]              fi_xor_data = {DQ_WIDTH{1'b0}};\n\ngenerate\nbegin\n  genvar i;\n  for (i = 0; i < DQS_WIDTH; i = i + 1) begin : assign_fi_xor_data\n    always @(posedge clk) begin\n      if (wrdata_en) begin\n        fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS] <= {DQ_PER_DQS{1'b0}};\n      end\n      else if (fi_xor_we[i]) begin\n        fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS] <= fi_xor_wrdata[i*DQ_PER_DQS+:DQ_PER_DQS];\n      end \n      else begin\n        fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS] <= fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS];\n      end\n    end\n  end\n  \nend\nendgenerate\n\nassign wrdata_out[0+:DQ_WIDTH] = wrdata_in[0+:DQ_WIDTH] ^ fi_xor_data[0+:DQ_WIDTH];\n \n assign wrdata_out[DQ_WIDTH+:(2*nCK_PER_CLK-1)*DQ_WIDTH] = wrdata_in[DQ_WIDTH+:(2*nCK_PER_CLK-1)*DQ_WIDTH];\n\nendmodule\n\n",
        "module_name": "mig_7series_v2_0_fi_xor #",
        "module_hash": "6f8d81e03d8cf84f50d55ffe8a82e498",
        "dataset_index": 21571
      },
      "decoder_9979b6fb": {
        "rtl_code": "module decoder (\n    input [2:0] in,\n    input enable,\n    output reg [7:0] out\n);\n    \n    always @ (in or enable) begin\n        if (enable == 1'b0) begin\n            out <= 8'b0;\n        end else begin\n            case (in)\n                3'b000: out <= 8'b00000001;\n                3'b001: out <= 8'b00000010;\n                3'b010: out <= 8'b00000100;\n                3'b011: out <= 8'b00001000;\n                3'b100: out <= 8'b00010000;\n                3'b101: out <= 8'b00100000;\n                3'b110: out <= 8'b01000000;\n                3'b111: out <= 8'b10000000;\n                default: out <= 8'b0;\n            endcase\n        end\n    end\n    \nendmodule",
        "module_name": "decoder",
        "module_hash": "9979b6fbd9262b84b8b3ae04b15864a7",
        "dataset_index": 3258
      },
      "mux4to1_dff67e12": {
        "rtl_code": "module mux4to1 (\n    input  A0,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  S0,\n    input  S1,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire w0, w1, w2;\n\n    assign w0 = S1 & S0;\n    assign w1 = S1 & ~S0;\n    assign w2 = ~S1 & S0;\n\n    assign Y = A0 & ~w0 & ~w2 | A1 & ~w1 & ~w2 | A2 & w0 & ~w1 | A3 & w1 & w2;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "dff67e120bd75c9fc083bafb99fc9a8c",
        "dataset_index": 20106
      },
      "cf_jesd_align_2_2e9cc0d5": {
        "rtl_code": "module cf_jesd_align_2 (\n  // jesd interface\n  rx_clk,\n  rx_sof,\n  rx_eof,\n  rx_ferr,\n  rx_fdata,\n\n  // aligned data\n  rx_err,\n  rx_data\n);\n\n  // jesd interface\n  input           rx_clk;\n  input   [ 3:0]  rx_sof;\n  input   [ 3:0]  rx_eof;\n  input   [ 3:0]  rx_ferr;\n  input   [31:0]  rx_fdata;\n\n  // aligned data\n  output          rx_err;\n  output  [31:0]  rx_data;\n\n  reg     [ 7:0]  rx_fdata_d = 'd0;\n  reg             rx_err = 'd0;\n  reg     [31:0]  rx_data = 'd0;\n \n  wire    [ 3:0]  rx_eof_s;\n  wire            rx_err_s;\n\n  // error conditions- sof & eof are mutually exclusive - xor should always be 4'b1111.\n  // if there are frame errors - the xor will result in values other than 4'hf.\n  assign rx_eof_s = ~rx_eof;\n  assign rx_err_s = ((rx_sof == rx_eof_s) && (rx_ferr == 4'd0)) ? 1'b0 : 1'b1;\n\n  // 2 bytes per frame - so only 2 combinations\n  always @(posedge rx_clk) begin\n    rx_fdata_d <= rx_fdata[31:24];\n    case (rx_sof)\n      4'b0101: begin\n        rx_err <= rx_err_s;\n        rx_data <= rx_fdata;\n      end\n      4'b1010: begin\n        rx_err <= rx_err_s;\n        rx_data <= {rx_fdata[23:0], rx_fdata_d};\n      end\n      default: begin\n        rx_err <= 1'b1;\n        rx_data <= 32'hffff;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "cf_jesd_align_2",
        "module_hash": "2e9cc0d5b60ee16489d24b887dbd85e3",
        "dataset_index": 10812
      },
      "top_module_11f52d32": {
        "rtl_code": "\nmodule top_module(\n    input clk,\n    input async_reset,      // Asynchronous active-high reset\n    input [1:0] ena,\n    input [99:0] data,\n    output [3:0] q,\n    output [99:0] q_out);\n\n    // Counter module\n    reg [2:0] counter;\n    always @(posedge clk or posedge async_reset) begin\n        if (async_reset) begin\n            counter <= 0;\n        end else if (ena[0]) begin\n            counter <= counter + 1;\n        end\n    end\n    \n    assign q = counter;\n\n    // Functional module\n    reg [99:0] sum;\n    always @(negedge clk) begin\n        if (ena[1]) begin\n            sum <= data[49:0] + data[99:50];\n        end\n    end\n    \n    assign q_out = sum;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "11f52d3225799bbfd0bdbc7adc43aa07",
        "dataset_index": 11168
      },
      "HallwayRight_a13ac5b2": {
        "rtl_code": "\nmodule HallwayRight(clk_vga, CurrentX, CurrentY, mapData, wall);\n\n\tinput clk_vga;\n\tinput [9:0]CurrentX;\n\tinput [8:0]CurrentY;\n\tinput [7:0]wall;\n\t\n\toutput [7:0]mapData;\n\t\n\treg [7:0]mColor;\n\t\n\talways @(posedge clk_vga) begin\n\t\tif((CurrentY < 40) && ~(CurrentX < 0)) begin\n\t\t\tmColor[7:0] <= wall;\n\t\tend \n\t\telse if(~(CurrentX < 600)) begin\n\t\t\tmColor[7:0] <= wall;\n\t\tend\n\t\telse if((~(CurrentY < 440) && (CurrentX < 260)) || (~(CurrentY < 440) && ~(CurrentX < 380))) begin\n\t\t\tmColor[7:0] <= wall;\n\t\tend else\n\t\t\tmColor[7:0] <= 8'b10110110;\n\t\t\t\n\tend\n\t\n\t\n\tassign mapData = mColor;\n\n\nendmodule\n\n",
        "module_name": "HallwayRight",
        "module_hash": "a13ac5b24e9ca6c44cffe7a6caab1ae3",
        "dataset_index": 2385
      },
      "xnor_nand_7f15c7e8": {
        "rtl_code": "\nmodule xnor_nand( \n    input a, \n    input b, \n    output out );\n\n    wire nand1, nand2, nand3;\n\n    nand n1(nand1, a, b);\n    nand n2(nand2, a, nand1);\n    nand n3(nand3, b, nand1);\n    nand n4(out, nand2, nand3);\n\nendmodule",
        "module_name": "xnor_nand",
        "module_hash": "7f15c7e8bb3608408647c49a0366d307",
        "dataset_index": 19101
      },
      "d_flip_flop_nand_a1f2b05f": {
        "rtl_code": "module d_flip_flop_nand (\n    input clk,\n    input d,\n    output q\n);\n\n    wire n_clk;\n    wire n_d;\n    wire n_q;\n\n    assign n_clk = ~clk;\n    assign n_d = ~d;\n\n    nand gate1 (n_q, n_d, n_clk);\n    nand gate2 (q, n_q, n_clk);\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\n    wire [7:0] q_temp;\n\n    d_flip_flop_nand ff0 (clk, d[0], q_temp[0]);\n    d_flip_flop_nand ff1 (clk, d[1], q_temp[1]);\n    d_flip_flop_nand ff2 (clk, d[2], q_temp[2]);\n    d_flip_flop_nand ff3 (clk, d[3], q_temp[3]);\n    d_flip_flop_nand ff4 (clk, d[4], q_temp[4]);\n    d_flip_flop_nand ff5 (clk, d[5], q_temp[5]);\n    d_flip_flop_nand ff6 (clk, d[6], q_temp[6]);\n    d_flip_flop_nand ff7 (clk, d[7], q_temp[7]);\n\n    assign q = q_temp;\n\nendmodule",
        "module_name": "d_flip_flop_nand",
        "module_hash": "a1f2b05ffdfa4c055fad0c8d48bdff97",
        "dataset_index": 20614
      },
      "sonar_driver #_e5acc057": {
        "rtl_code": "module sonar_driver #(parameter freq = 50_000_000) (\n        input  wire      clk,\n        input  wire      rst_n,\n        input  wire      measure,\n        output reg       ready      = 1,\n        output wire[7:0] distance,\n\n        input  wire      echo,\n        output reg       trig       = 0\n    );\n\n    parameter CYCLES_10_US = freq / 100_000;\n    parameter CYCLE_PERIOD = 1_000_000_000 / freq;              parameter SOUND_SPEED  = 343210;                            parameter NM_PER_CYCLE = SOUND_SPEED * CYCLE_PERIOD / 1000; parameter ECHO_TIMEOUT = freq / 100;                        parameter TIMEOUT      = freq;\n\n    reg[31:0] counter = 0;\n    reg[31:0] timeout = 0;\n    reg[31:0] i_dist  = 0;\n\n    reg[2:0]    state      = 0;\n    reg[2:0]    next_state = 0;\n    parameter   IDLE       = 3'h0;\n    parameter   TRIG       = 3'h1;\n    parameter   WAIT_ECHO  = 3'h2;\n    parameter   MEASURING  = 3'h3;\n    parameter   READY      = 3'h4;\n\n    assign distance = i_dist[31:24];\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state = IDLE;\n        end else begin\n            state = next_state;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            next_state = IDLE;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (measure == 1) begin\n                        next_state  = TRIG;\n                    end\n                end\n                TRIG: begin\n                    if (counter == 0) begin\n                        next_state = WAIT_ECHO;\n                    end\n                end\n                WAIT_ECHO: begin\n                    if (echo == 1) begin\n                        next_state = MEASURING;\n                    end else if (timeout == 0) begin\n                        next_state = READY;\n                    end\n                end\n                MEASURING: begin\n                    if (echo == 0) begin\n                        next_state = READY;\n                    end else if (timeout == 0) begin\n                        next_state = READY;\n                    end\n                end\n                READY: begin\n                    next_state = IDLE;\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            trig    = 0;\n            i_dist  = 0;\n            ready   = 1;\n            counter = 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (measure == 1) begin\n                        ready   = 0;\n                        counter = CYCLES_10_US;\n                        timeout = ECHO_TIMEOUT;\n                    end\n                end\n                TRIG: begin\n                    i_dist  = 0;\n                    trig    = 1;\n                    counter = counter - 1;\n                end\n                WAIT_ECHO: begin\n                    timeout = timeout - 1;\n                    trig    = 0;\n                end\n                MEASURING: begin\n                    timeout = timeout - 1;\n                    i_dist = i_dist + NM_PER_CYCLE;\n                end\n                READY: begin\n                    ready = 1;\n                end\n            endcase\n        end\n    end\nendmodule\n",
        "module_name": "sonar_driver #",
        "module_hash": "e5acc0571f10d2a12a37ef81d668675f",
        "dataset_index": 22452
      },
      "logic_function_9c72fe5a": {
        "rtl_code": "module logic_function (\n  input x,\n  input y,\n  input z,\n  output reg out1,\n  output reg out2\n);\n\n  always @(*) begin\n    if (x & y | !z) begin\n      out1 = 1;\n    end\n    else begin\n      out1 = 0;\n    end\n    \n    if (!x & y | z) begin\n      out2 = 1;\n    end\n    else begin\n      out2 = 0;\n    end\n  end\n  \nendmodule\n",
        "module_name": "logic_function",
        "module_hash": "9c72fe5a961d1156799c93041429ff19",
        "dataset_index": 16100
      },
      "adder4_2adada02": {
        "rtl_code": "module adder4 (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] c, s;\n\n    // Full adder implementation\n    assign c[0] = A[0] & B[0];\n    assign s[0] = A[0] ^ B[0] ^ Cin;\n    assign c[1] = (A[0] & B[0]) | (A[1] & B[0]) | (A[0] & B[1]);\n    assign s[1] = A[1] ^ B[1] ^ c[0];\n    assign c[2] = (A[0] & B[1]) | (A[1] & B[0]) | (A[2] & B[0]) | (A[1] & B[1]) | (A[0] & B[2]);\n    assign s[2] = A[2] ^ B[2] ^ c[1];\n    assign c[3] = (A[0] & B[2]) | (A[1] & B[1]) | (A[2] & B[0]) | (A[3] & B[0]) | (A[2] & B[1]) | (A[1] & B[2]) | (A[0] & B[3]);\n    assign s[3] = A[3] ^ B[3] ^ c[2];\n\n    // Assign outputs\n    assign S = s;\n    assign Cout = c[3];\n\nendmodule",
        "module_name": "adder4",
        "module_hash": "2adada029e3ad5b36062c59021f16f5f",
        "dataset_index": 14813
      },
      "sky130_fd_sc_ls__a2bb2oi_5bbd7deb": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a2bb2oi (\n    Y   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    wire and0_out  ;\n    wire nor0_out  ;\n    wire nor1_out_Y;\n\n    and and0 (and0_out  , B1, B2            );\n    nor nor0 (nor0_out  , A1_N, A2_N        );\n    nor nor1 (nor1_out_Y, nor0_out, and0_out);\n    buf buf0 (Y         , nor1_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a2bb2oi",
        "module_hash": "5bbd7deb6eb9dbba197484e046d5d77d",
        "dataset_index": 21818
      },
      "manufacturing_process_controller_6d6bfaab": {
        "rtl_code": "module manufacturing_process_controller(\n\n    input wire clk,\n\n    //input events\n    input wire InjectorArmFinishMovement_eI,\n    input wire EmergencyStopChanged_eI,\n    input wire CanisterPressureChanged_eI,\n    input wire FillContentsAvailableChanged_eI,\n    input wire LasersChanged_eI,\n    input wire DoorOverride_eI,\n    input wire VacuumTimerElapsed_eI,\n\n    //output events\n    output wire DoorReleaseCanister_eO,\n    output wire ConveyorChanged_eO,\n    output wire InjectorPositionChanged_eO,\n    output wire InjectorControlsChanged_eO,\n    output wire FillContentsChanged_eO,\n    output wire StartVacuumTimer_eO,\n    output wire GoRejectArm_eO,\n    output wire CanisterCountChanged_eO,\n    output wire InjectDone_eO,\n\n    //input variables\n    input wire EmergencyStop_I,\n    input wire [7:0] CanisterPressure_I,\n    input wire [7:0] FillContentsAvailable_I,\n    input wire DoorSiteLaser_I,\n    input wire InjectSiteLaser_I,\n    input wire RejectSiteLaser_I,\n    input wire RejectBinLaser_I,\n    input wire AcceptBinLaser_I,\n\n    //output variables\n    output wire [7:0] ConveyorSpeed_O ,\n    output wire [7:0] InjectorPosition_O ,\n    output wire InjectorContentsValveOpen_O ,\n    output wire InjectorVacuumRun_O ,\n    output wire InjectorPressurePumpRun_O ,\n    output wire [7:0] FillContents_O ,\n    output wire [7:0] CanisterCount_O ,\n\n    input reset\n);\n\n    // Declare internal variables\n    reg [7:0] conveyor_speed;\n    reg [7:0] injector_position;\n    reg injector_contents_valve_open;\n    reg injector_vacuum_run;\n    reg injector_pressure_pump_run;\n    reg [7:0] fill_contents;\n    reg [7:0] canister_count;\n    reg inject_done;\n    reg door_release_canister;\n    reg conveyor_changed;\n    reg injector_position_changed;\n    reg injector_controls_changed;\n    reg fill_contents_changed;\n    reg start_vacuum_timer;\n    reg go_reject_arm;\n    reg canister_count_changed;\n\n    // Process input events and variables\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            conveyor_speed <= 0;\n            injector_position <= 0;\n            injector_contents_valve_open <= 0;\n            injector_vacuum_run <= 0;\n            injector_pressure_pump_run <= 0;\n            fill_contents <= 0;\n            canister_count <= 0;\n            inject_done <= 0;\n            door_release_canister <= 0;\n            conveyor_changed <= 0;\n            injector_position_changed <= 0;\n            injector_controls_changed <= 0;\n            fill_contents_changed <= 0;\n            start_vacuum_timer <= 0;\n            go_reject_arm <= 0;\n            canister_count_changed <= 0;\n        end else begin\n            if (EmergencyStopChanged_eI) begin\n                if (EmergencyStop_I) begin\n                    conveyor_speed <= 0;\n                    injector_vacuum_run <= 0;\n                    injector_pressure_pump_run <= 0;\n                end\n            end\n            if (CanisterPressureChanged_eI) begin\n                if (CanisterPressure_I > 200) begin\n                    conveyor_speed <= conveyor_speed + 1;\n                    conveyor_changed <= 1;\n                end\n            end\n            if (FillContentsAvailableChanged_eI) begin\n                fill_contents <= FillContentsAvailable_I;\n                fill_contents_changed <= 1;\n            end\n            if (LasersChanged_eI) begin\n                if (DoorSiteLaser_I == 1 && RejectSiteLaser_I == 1) begin\n                    door_release_canister <= 1;\n                end\n                if (InjectSiteLaser_I == 1) begin\n                    injector_position <= 255;\n                    injector_position_changed <= 1;\n                end\n                if (RejectBinLaser_I == 1) begin\n                    go_reject_arm <= 1;\n                end\n                if (AcceptBinLaser_I == 1) begin\n                    canister_count <= canister_count + 1;\n                    canister_count_changed <= 1;\n                end\n            end\n            if (VacuumTimerElapsed_eI) begin\n                start_vacuum_timer <= 0;\n                injector_contents_valve_open <= 0;\n                injector_vacuum_run <= 0;\n                inject_done <= 1;\n                injector_controls_changed <= 1;\n            end\n            if (InjectorArmFinishMovement_eI) begin\n                injector_contents_valve_open <= 1;\n                injector_vacuum_run <= 1;\n                injector_pressure_pump_run <= 1;\n                start_vacuum_timer <= 1;\n                injector_controls_changed <= 1;\n            end\n            if (DoorOverride_eI) begin\n                door_release_canister <= 1;\n            end\n        end\n    end\n\n    // Assign output events and variables\n    assign ConveyorSpeed_O = conveyor_speed;\n    assign InjectorPosition_O = injector_position;\n    assign InjectorContentsValveOpen_O = injector_contents_valve_open;\n    assign InjectorVacuumRun_O = injector_vacuum_run;\n    assign InjectorPressurePumpRun_O = injector_pressure_pump_run;\n    assign FillContents_O = fill_contents;\n    assign CanisterCount_O = canister_count;\n    assign InjectDone_eO = inject_done;\n    assign DoorReleaseCanister_eO = door_release_canister;\n    assign ConveyorChanged_eO = conveyor_changed;\n    assign InjectorPositionChanged_eO = injector_position_changed;\n    assign InjectorControlsChanged_eO = injector_controls_changed;\n    assign FillContentsChanged_eO = fill_contents_changed;\n    assign StartVacuumTimer_eO = start_vacuum_timer;\n    assign GoRejectArm_eO = go_reject_arm;\n    assign CanisterCountChanged_eO = canister_count_changed;\n\nendmodule",
        "module_name": "manufacturing_process_controller",
        "module_hash": "6d6bfaab181f8d8418386e5123987d47",
        "dataset_index": 19669
      },
      "sram_ctrl_84fec09d": {
        "rtl_code": "module sram_ctrl (\n    \n    input clk,\n    input rst_n,\n    input clk_proc,\n    \n    input wr_en,\n    input rd_en,\n    input [31:0] wr_data,\n    input [20:0] addr,\n    output reg [31:0] rd_data,\n\n    output sram_ub_n,\n    output sram_lb_n,\n    output reg sram_ce_n,\n    output reg sram_we_n,\n    output reg sram_oe_n,\n    output reg [19:0] sram_addr,\n    output reg [15:0] sram_wr_data,\n    input [15:0] sram_rd_data\n  );\n\nparameter ST_IDLE    = 0;\nparameter ST_WRITE_0 = 1;\nparameter ST_WRITE_1 = 2;\nparameter ST_READ_0  = 3;\nparameter ST_READ_1  = 4;\nparameter ST_READ_2  = 5;\n\nreg [2:0] state;\nreg [2:0] next_state;\n\nreg [2:0]  counter;\n\nreg [31:0] rd_data_reg;\nwire [20:0] addr_plus2;\n\nreg wr_data_dly;\nreg rd_data_dly;\nreg wr_detc;\n//wire rd_detc;\nreg clk_proc_pulse;\nreg clk_proc_dly;\n\n//wire [31:0] rd_data_concat;\n\nassign sram_ub_n = 1'b0;\nassign sram_lb_n = 1'b0;\n\nassign addr_plus2 = addr+2;\n\n//assign rd_data_concat = {sram_rd_data,rd_data_reg[15:0]};\n\nalways@(posedge clk, negedge rst_n)begin\n  if(!rst_n)begin\n    rd_data <= 0;\n  end\n  else begin\n    if(state == ST_IDLE)begin\n      rd_data <= rd_data_reg;\n    end\n  end\nend\n\nalways@(posedge clk, negedge rst_n)begin\n   if(!rst_n)begin\n      wr_data_dly <= 1'b0;\n      clk_proc_dly <= 1'b0;\n      wr_detc <= 1'b0;\n      clk_proc_pulse <= 1'b0;\n   end\n   else begin\n      wr_data_dly <= wr_en;\n      wr_detc <= wr_en & !wr_data_dly;\n      clk_proc_dly <= clk_proc;\n      clk_proc_pulse <= clk_proc & !clk_proc_dly;\n   end\nend\n\nalways@(posedge clk, negedge rst_n)begin\n   if(!rst_n)begin\n      rd_data_reg <= 32'd0;\n      sram_ce_n <= 1'b0;\n      sram_we_n <= 1'b0;\n      sram_oe_n <= 1'b1;\n      sram_wr_data <= 0;\n      sram_addr <= 0;\n   end\n   else begin\n      case(state)\n\t ST_IDLE: begin\n            if(wr_detc)begin //write\n               sram_ce_n <= 1'b0;\n               sram_we_n <= 1'b0;\n               sram_oe_n <= 1'b1;\n               sram_wr_data <= wr_data[15:0];\n               sram_addr <= addr[20:1];\n            end\n            else if (rd_en && clk_proc_pulse) begin//read\n               sram_ce_n <= 1'b0;\n               sram_we_n <= 1'b1;\n               sram_oe_n <= 1'b0;\n               sram_addr <= addr[20:1];\n            end\n            else begin\n               sram_ce_n <= 1'b1;\n               sram_we_n <= 1'b1;\n               sram_oe_n <= 1'b1;\n               sram_addr <= 20'd0;\n               sram_wr_data <= 16'd0;\n            end\n\t end\n         ST_WRITE_0: begin\n            sram_ce_n <= 1'b1;\n            sram_we_n <= 1'b1;\n            sram_oe_n <= 1'b1;\n\t    sram_wr_data <= 0;\n            sram_addr <= 0;\n\t end\n         ST_WRITE_1: begin\n            sram_ce_n <= 1'b0;\n            sram_we_n <= 1'b0;\n            sram_oe_n <= 1'b1;\n\t    sram_wr_data <= wr_data[31:16];\n            sram_addr <= addr_plus2[20:1];\n\t end\n         ST_READ_0: begin\n            sram_ce_n <= 1'b1;\n            sram_we_n <= 1'b1;\n            sram_oe_n <= 1'b0;\n            sram_addr <= 0;\n         end\n         ST_READ_1: begin\n            sram_ce_n <= 1'b0;\n            sram_we_n <= 1'b1;\n            sram_oe_n <= 1'b0;\n            sram_addr <= addr_plus2[20:1];\n            rd_data_reg[15:0] <= sram_rd_data;\n         end\n         ST_READ_2: begin\n            sram_ce_n <= 1'b1;\n            sram_we_n <= 1'b1;\n            sram_oe_n <= 1'b0;\n            sram_addr <= addr_plus2[20:1];\n            rd_data_reg[31:16] <= sram_rd_data;\n\t end\n         default: begin\n            sram_ce_n <= 1'b1;\n            sram_we_n <= 1'b1;\n            sram_oe_n <= 1'b1;\n            rd_data_reg <= rd_data_reg;\n         end\n      endcase\n   end\nend\n\nalways@(posedge clk, negedge rst_n)begin\n   if(!rst_n)begin\n      state <= ST_IDLE;\n   end\n   else begin\n      state <= next_state;\n   end\nend\n\n\nalways@(*)begin\n   case (state)\n      ST_IDLE: begin\n       if(wr_detc)\n          next_state = ST_WRITE_0;\n       else if(rd_en && clk_proc_pulse)\n          next_state = ST_READ_0;\n       else\n          next_state = ST_IDLE;\n      end\n      ST_WRITE_0: begin\n         next_state = ST_WRITE_1;\n      end\n      ST_WRITE_1: begin\n         next_state = ST_IDLE;\n      end\n      ST_READ_0: begin\n         next_state = ST_READ_1;\n      end\n      ST_READ_1: begin\n         next_state = ST_READ_2;\n      end\n      ST_READ_2: begin\n        next_state = ST_IDLE;\n      end\n      default:begin\n         next_state = ST_IDLE;\n      end\n   endcase\nend\n\nendmodule",
        "module_name": "sram_ctrl",
        "module_hash": "84fec09d1c852e553c86210b6f9de1cb",
        "dataset_index": 7562
      },
      "fsm2_7508af78": {
        "rtl_code": "\nmodule fsm2(\n\tinput clk,\n\tinput rst,\n\tinput rxd,\n\t\n\toutput [7:0] data,\n\toutput received\n    );\n\nlocalparam STATE1 = 2'b00;\nlocalparam STATE2 = 2'b01;\nlocalparam STATE3 = 2'b10;\n\nreg [1:0] state = STATE1;\nreg [7:0] tmp_data = 8'b00000000;\nreg tmp_received = 1'b0;\nreg [2:0] index;\nreg [1:0] rxd_hist = 2'b11;\n\nalways @(posedge clk)\nbegin\n\tif(rst)\n\tbegin\n\t\ttmp_data = 0;\n\t\ttmp_received = 0;\n\t\trxd_hist = 2'b11; state = STATE1;\n\tend\n\t\n\tcase(state)\n\tSTATE1:\n\tbegin\n\t\tif(rxd_hist == 2'b00 && rxd == 1) begin\n\t\t\trxd_hist = 2'b11;\n\t\t\ttmp_data = 8'b00000000;\n\t\t\tindex = 3'b000;\n\t\t\tstate = STATE2;\n\t\tend\n\tend\n\tSTATE2:\n\tbegin\n\t\ttmp_data[index] = rxd;\n\t\tindex = index + 1;\n\t\t\n\t\tif(index == 3'b000) begin\n\t\t\ttmp_received = 1'b1;\n\t\t\tstate = STATE3;\n\t\t\tindex = 3'b000;\n\t\tend\n\tend\n\tSTATE3:\n\tbegin\n\t\ttmp_received = 1'b0;\n\t\ttmp_data = 8'b00000000;\n\t\tstate = STATE1;\n\tend\n\tendcase\n\t\n\tif(state == STATE1) rxd_hist = { rxd_hist[0], rxd };\t\nend\n\nassign data = tmp_data;\nassign received = tmp_received;\n\nendmodule\n",
        "module_name": "fsm2",
        "module_hash": "7508af7805b885432089e5195802376f",
        "dataset_index": 23929
      },
      "ay_note_ram_f102ec42": {
        "rtl_code": "module ay_note_ram(addr, data);\ninput wire [6:0] addr;\noutput wire [11:0] data; reg [11:0] note_ram [0:127];\ninitial begin\n  note_ram[0] <= 12'd03977;\n  note_ram[1] <= 12'd03977;\n  note_ram[2] <= 12'd03977;\n  note_ram[3] <= 12'd03977;\n  note_ram[4] <= 12'd03977;\n  note_ram[5] <= 12'd03977;\n  note_ram[6] <= 12'd03977;\n  note_ram[7] <= 12'd03977;\n  note_ram[8] <= 12'd03977;\n  note_ram[9] <= 12'd03977;\n  note_ram[10] <= 12'd03977;\n  note_ram[11] <= 12'd03977;\n  note_ram[12] <= 12'd03977;\n  note_ram[13] <= 12'd03977;\n  note_ram[14] <= 12'd03977;\n  note_ram[15] <= 12'd03977;\n  note_ram[16] <= 12'd03977;\n  note_ram[17] <= 12'd03977;\n  note_ram[18] <= 12'd03977;\n  note_ram[19] <= 12'd03977;\n  note_ram[20] <= 12'd03977;\n  note_ram[21] <= 12'd03977;\n  note_ram[22] <= 12'd03754;\n  note_ram[23] <= 12'd03543;\n  note_ram[24] <= 12'd03344;\n  note_ram[25] <= 12'd03157;\n  note_ram[26] <= 12'd02980;\n  note_ram[27] <= 12'd02812;\n  note_ram[28] <= 12'd02655;\n  note_ram[29] <= 12'd02506;\n  note_ram[30] <= 12'd02365;\n  note_ram[31] <= 12'd02232;\n  note_ram[32] <= 12'd02107;\n  note_ram[33] <= 12'd01989;\n  note_ram[34] <= 12'd01877;\n  note_ram[35] <= 12'd01772;\n  note_ram[36] <= 12'd01672;\n  note_ram[37] <= 12'd01578;\n  note_ram[38] <= 12'd01490;\n  note_ram[39] <= 12'd01406;\n  note_ram[40] <= 12'd01327;\n  note_ram[41] <= 12'd01253;\n  note_ram[42] <= 12'd01182;\n  note_ram[43] <= 12'd01116;\n  note_ram[44] <= 12'd01053;\n  note_ram[45] <= 12'd0994;\n  note_ram[46] <= 12'd0939;\n  note_ram[47] <= 12'd0886;\n  note_ram[48] <= 12'd0836;\n  note_ram[49] <= 12'd0789;\n  note_ram[50] <= 12'd0745;\n  note_ram[51] <= 12'd0703;\n  note_ram[52] <= 12'd0664;\n  note_ram[53] <= 12'd0626;\n  note_ram[54] <= 12'd0591;\n  note_ram[55] <= 12'd0558;\n  note_ram[56] <= 12'd0527;\n  note_ram[57] <= 12'd0497;\n  note_ram[58] <= 12'd0469;\n  note_ram[59] <= 12'd0443;\n  note_ram[60] <= 12'd0418;\n  note_ram[61] <= 12'd0395;\n  note_ram[62] <= 12'd0372;\n  note_ram[63] <= 12'd0352;\n  note_ram[64] <= 12'd0332;\n  note_ram[65] <= 12'd0313;\n  note_ram[66] <= 12'd0296;\n  note_ram[67] <= 12'd0279;\n  note_ram[68] <= 12'd0263;\n  note_ram[69] <= 12'd0249;\n  note_ram[70] <= 12'd0235;\n  note_ram[71] <= 12'd0221;\n  note_ram[72] <= 12'd0209;\n  note_ram[73] <= 12'd0197;\n  note_ram[74] <= 12'd0186;\n  note_ram[75] <= 12'd0176;\n  note_ram[76] <= 12'd0166;\n  note_ram[77] <= 12'd0157;\n  note_ram[78] <= 12'd0148;\n  note_ram[79] <= 12'd0140;\n  note_ram[80] <= 12'd0132;\n  note_ram[81] <= 12'd0124;\n  note_ram[82] <= 12'd0117;\n  note_ram[83] <= 12'd0111;\n  note_ram[84] <= 12'd0105;\n  note_ram[85] <= 12'd099;\n  note_ram[86] <= 12'd093;\n  note_ram[87] <= 12'd088;\n  note_ram[88] <= 12'd083;\n  note_ram[89] <= 12'd078;\n  note_ram[90] <= 12'd074;\n  note_ram[91] <= 12'd070;\n  note_ram[92] <= 12'd066;\n  note_ram[93] <= 12'd062;\n  note_ram[94] <= 12'd059;\n  note_ram[95] <= 12'd055;\n  note_ram[96] <= 12'd052;\n  note_ram[97] <= 12'd049;\n  note_ram[98] <= 12'd047;\n  note_ram[99] <= 12'd044;\n  note_ram[100] <= 12'd041;\n  note_ram[101] <= 12'd039;\n  note_ram[102] <= 12'd037;\n  note_ram[103] <= 12'd035;\n  note_ram[104] <= 12'd033;\n  note_ram[105] <= 12'd031;\n  note_ram[106] <= 12'd029;\n  note_ram[107] <= 12'd028;\n  note_ram[108] <= 12'd026;\n  note_ram[109] <= 12'd025;\n  note_ram[110] <= 12'd023;\n  note_ram[111] <= 12'd022;\n  note_ram[112] <= 12'd021;\n  note_ram[113] <= 12'd020;\n  note_ram[114] <= 12'd018;\n  note_ram[115] <= 12'd017;\n  note_ram[116] <= 12'd016;\n  note_ram[117] <= 12'd016;\n  note_ram[118] <= 12'd015;\n  note_ram[119] <= 12'd014;\n  note_ram[120] <= 12'd013;\n  note_ram[121] <= 12'd012;\n  note_ram[122] <= 12'd012;\n  note_ram[123] <= 12'd011;\n  note_ram[124] <= 12'd010;\n  note_ram[125] <= 12'd010;\n  note_ram[126] <= 12'd09;\n  note_ram[127] <= 12'd09;\nend\n\nassign data = note_ram[addr];\n\nendmodule\n",
        "module_name": "ay_note_ram",
        "module_hash": "f102ec42a3319051f688e278d4cfc94f",
        "dataset_index": 974
      },
      "sky130_fd_sc_ms__a22o_1add1662": {
        "rtl_code": "module sky130_fd_sc_ms__a22o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n    \n    assign X = ((A1 & ~A2) | (B1 & ~B2) | (~A1 & ~A2 & ~B1 & ~B2)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__a22o",
        "module_hash": "1add16621dc5331176ee7d1ea28022b5",
        "dataset_index": 2405
      },
      "sky130_fd_sc_hvl__o22ai_a0a84e50": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__o22ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    wire nor0_out ;\n    wire nor1_out ;\n    wire or0_out_Y;\n\n    nor nor0 (nor0_out , B1, B2            );\n    nor nor1 (nor1_out , A1, A2            );\n    or  or0  (or0_out_Y, nor1_out, nor0_out);\n    buf buf0 (Y        , or0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__o22ai",
        "module_hash": "a0a84e50c12adb0f5813cc8b950b79e6",
        "dataset_index": 19879
      },
      "fifo_reg #_e613e5e0": {
        "rtl_code": "module fifo_reg #\n(\n    parameter WIDTH = 8,\n    parameter DEPTH = 4\n)\n(\n    input  wire                       clk,\n    input  wire                       rst,\n\n    input  wire                       write_en, // input valid\n    input  wire [WIDTH-1:0]           write_data,\n    input  wire                       read_en, // output ready\n    output wire [WIDTH-1:0]           read_data,\n    output wire                       full, // input not ready\n    output wire                       empty // output not valid\n);\n\nreg [WIDTH-1:0] data_reg[DEPTH-1:0];\nreg valid_reg[DEPTH-1:0];\nreg ptr_write_reg = 0;\nreg ptr_read_reg = 0;\nreg full_reg = 0;\n\nassign read_data = data_reg[ptr_read_reg];\nassign full = full_reg;\nassign empty = ~valid_reg[ptr_read_reg];\n\nwire [WIDTH-1:0] data_reg_0 = data_reg[0];\nwire [WIDTH-1:0] data_reg_1 = data_reg[1];\nwire [WIDTH-1:0] data_reg_2 = data_reg[2];\nwire [WIDTH-1:0] data_reg_3 = data_reg[3];\nwire valid_reg_0 = valid_reg[0];\nwire valid_reg_1 = valid_reg[1];\nwire valid_reg_2 = valid_reg[2];\nwire valid_reg_3 = valid_reg[3];\n\nreg shift;\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < DEPTH; i = i + 1) begin\n        data_reg[i] <= 0;\n        valid_reg[i] <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        ptr_write_reg <= 0;\n        ptr_read_reg <= 0;\n        full_reg <= 0;\n        for (i = 0; i < DEPTH; i = i + 1) begin\n            data_reg[i] <= 0;\n            valid_reg[i] <= 0;\n        end\n    end else begin\n        // transfer empty to full\n        full_reg <= ~read_en & ~empty & write_en & (ptr_write_reg == ptr_read_reg);\n\n        // transfer in if not full\n        if (~full_reg & write_en) begin\n            data_reg[ptr_write_reg] <= write_data;\n            valid_reg[ptr_write_reg] <= 1;\n            ptr_write_reg <= ptr_write_reg + 1;\n            if (ptr_write_reg == DEPTH) begin\n                ptr_write_reg <= 0;\n            end\n        end\n\n        if (read_en & ~empty) begin\n            ptr_read_reg <= ptr_read_reg + 1;\n            if (ptr_read_reg == DEPTH) begin\n                ptr_read_reg <= 0;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "fifo_reg #",
        "module_hash": "e613e5e0d62cd760e8e4d1f9aba207ab",
        "dataset_index": 5356
      },
      "NPCG_Toggle_BNC_P_program_f300c12f": {
        "rtl_code": "\n\nmodule NPCG_Toggle_BNC_P_program\n#\n(\n    parameter NumberOfWays    =   4\n)\n(\n    iSystemClock        ,\n    iReset              ,\n    iOpcode             ,\n    iTargetID           ,\n    iSourceID           ,\n    iLength             ,\n    iCMDValid           ,\n    oCMDReady           ,\n    iWriteData          ,\n    iWriteLast          ,\n    iWriteValid         ,\n    oWriteReady         ,\n    iWaySelect          ,\n    iColAddress         ,\n    iRowAddress         ,\n    oStart              ,\n    oLastStep           ,\n    iPM_Ready           ,\n    iPM_LastStep        ,\n    oPM_PCommand        ,\n    oPM_PCommandOption  ,\n    oPM_TargetWay       ,\n    oPM_NumOfData       ,\n    oPM_CASelect        ,\n    oPM_CAData          ,\n    oPM_WriteData       ,\n    oPM_WriteLast       ,\n    oPM_WriteValid      ,\n    iPM_WriteReady\n);\n    input                           iSystemClock            ;\n    input                           iReset                  ;\n    input   [5:0]                   iOpcode                 ;\n    input   [4:0]                   iTargetID               ;\n    input   [4:0]                   iSourceID               ;\n    input   [15:0]                  iLength                 ;\n    input                           iCMDValid               ;\n    output                          oCMDReady               ;\n    input   [31:0]                  iWriteData              ;\n    input                           iWriteLast              ;\n    input                           iWriteValid             ;\n    output                          oWriteReady             ;\n    input   [NumberOfWays - 1:0]    iWaySelect              ;\n    input   [15:0]                  iColAddress             ;\n    input   [23:0]                  iRowAddress             ;\n    output                          oStart                  ;\n    output                          oLastStep               ;\n    input   [7:0]                   iPM_Ready               ;\n    input   [7:0]                   iPM_LastStep            ;\n    output  [7:0]                   oPM_PCommand            ;\n    output  [2:0]                   oPM_PCommandOption      ;\n    output  [NumberOfWays - 1:0]    oPM_TargetWay           ;\n    output  [15:0]                  oPM_NumOfData           ;\n    output                          oPM_CASelect            ;\n    output  [7:0]                   oPM_CAData              ;\n    output  [31:0]                  oPM_WriteData           ;\n    output                          oPM_WriteLast           ;\n    output                          oPM_WriteValid          ;\n    input                           iPM_WriteReady          ;\n\n    reg [NumberOfWays - 1:0]    rTargetWay  ;\n    reg [15:0]                  rColAddress ;\n    reg [23:0]                  rRowAddress ;\n    wire                        wModuleTriggered;\n    \n    reg [7:0]                   rPMTrigger  ;\n    reg [2:0]                   rPCommandOption ;\n    reg [15:0]                  rPMLength   ;\n    reg [15:0]                  rTrfLength  ;\n    \n    reg [7:0]                   rCAData     ;\n    reg                         rPMCommandOrAddress ;\n\n    localparam  State_Idle          = 4'b0000   ;\n    localparam  State_NCALIssue0    = 4'b0001   ;\n    localparam  State_NCmdWrite0    = 4'b0011   ;\n    localparam  State_NAddrWrite0   = 4'b0010   ;\n    localparam  State_NAddrWrite1   = 4'b0110   ;\n    localparam  State_NAddrWrite2   = 4'b0111   ;\n    localparam  State_NAddrWrite3   = 4'b0101   ;\n    localparam  State_NAddrWrite4   = 4'b0100   ;\n    localparam  State_WaitTADL      = 4'b1100   ;\n    localparam  State_DOIssue       = 4'b1101   ;\n    localparam  State_NCALIssue1    = 4'b1111   ;\n    localparam  State_NCmdWrite1    = 4'b1110   ;\n    localparam  State_NTimerIssue   = 4'b1010   ;\n    localparam  State_WaitDone      = 4'b1011   ;\n    \n    reg [3:0]   rCurState   ;\n    reg [3:0]   rNextState  ;\n\n    always @ (posedge iSystemClock)\n        if (iReset)\n            rCurState <= State_Idle;\n        else\n            rCurState <= rNextState;\n\n    always @ (*)\n        case (rCurState)\n        State_Idle:\n            rNextState <= (wModuleTriggered)?State_NCALIssue0:State_Idle;\n        State_NCALIssue0:\n            rNextState <= (iPM_Ready)?State_NCmdWrite0:State_NCALIssue0;\n        State_NCmdWrite0:\n            rNextState <= State_NAddrWrite0;\n        State_NAddrWrite0:\n            rNextState <= State_NAddrWrite1;\n        State_NAddrWrite1:\n            rNextState <= State_NAddrWrite2;\n        State_NAddrWrite2:\n            rNextState <= State_NAddrWrite3;\n        State_NAddrWrite3:\n            rNextState <= State_NAddrWrite4;\n        State_NAddrWrite4:\n            rNextState <= State_WaitTADL;\n        State_WaitTADL:\n            rNextState <= (iPM_LastStep[3])?State_DOIssue:State_WaitTADL;\n        State_DOIssue:\n            rNextState <= (iPM_LastStep[0])? State_NCALIssue1:State_DOIssue;\n        State_NCALIssue1:\n            rNextState <= (iPM_LastStep[2])? State_NCmdWrite1:State_NCALIssue1;\n        State_NCmdWrite1:\n            rNextState <= State_NTimerIssue;\n        State_NTimerIssue:\n            rNextState <= (iPM_LastStep[3])? State_WaitDone:State_NTimerIssue;\n        State_WaitDone:\n            rNextState <= (iPM_LastStep[0])?State_Idle:State_WaitDone;\n        default:\n            rNextState <= State_Idle;\n        endcase\n    \n    assign wModuleTriggered = (iCMDValid && iTargetID == 5'b00101 && iOpcode == 6'b000100);\n    assign oCMDReady = (rCurState == State_Idle);\n    \n    always @ (posedge iSystemClock)\n        if (iReset)\n        begin\n            rTargetWay  <= {(NumberOfWays){1'b0}};\n            rColAddress <= 16'b0;\n            rRowAddress <= 24'b0;\n            rTrfLength  <= 16'b0;\n        end\n        else\n            if (wModuleTriggered && (rCurState == State_Idle))\n            begin\n                rTargetWay  <= iWaySelect   ;\n                rColAddress <= iColAddress  ;\n                rRowAddress <= iRowAddress  ;\n                rTrfLength  <= iLength;\n            end\n    \n    always @ (*)\n        case (rCurState)\n        State_NCALIssue0:\n            rPMTrigger <= 8'b0000_1000;\n        State_DOIssue:\n            rPMTrigger <= 8'b0000_0100;\n        State_NCALIssue1:\n            rPMTrigger <= 8'b0000_1000;\n        State_WaitTADL:\n            rPMTrigger <= 8'b0000_0001;\n        State_NTimerIssue:\n            rPMTrigger <= 8'b0000_0001;\n        default:\n            rPMTrigger <= 0;\n        endcase\n    \n    always @ (*)\n        case (rCurState)\n        State_DOIssue:\n            rPCommandOption[2:0] <= 3'b001; State_WaitTADL:\n            rPCommandOption[2:0] <= 3'b111;\n        State_NTimerIssue:\n            rPCommandOption[2:0] <= 3'b110;\n        default:\n            rPCommandOption[2:0] <= 0;\n        endcase\n    \n    always @ (*)\n        case (rCurState)\n        State_NCALIssue0:\n            rPMLength <= 16'd5; State_DOIssue:\n            rPMLength <= rTrfLength;\n        State_NCALIssue1:\n            rPMLength <= 16'd0; State_WaitTADL:\n            rPMLength <= 16'd31; State_NTimerIssue:\n            rPMLength <= 16'd3; default:\n            rPMLength <= 0;\n        endcase\n        \n    always @ (*)\n        case (rCurState)\n        State_NCmdWrite0:\n            rPMCommandOrAddress <= 1'b0;\n        State_NCmdWrite1:\n            rPMCommandOrAddress <= 1'b0;\n        State_NAddrWrite0:\n            rPMCommandOrAddress <= 1'b1;\n        State_NAddrWrite1:\n            rPMCommandOrAddress <= 1'b1;\n        State_NAddrWrite2:\n            rPMCommandOrAddress <= 1'b1;\n        State_NAddrWrite3:\n            rPMCommandOrAddress <= 1'b1;\n        State_NAddrWrite4:\n            rPMCommandOrAddress <= 1'b1;\n        default:\n            rPMCommandOrAddress <= 0;\n        endcase\n    \n    always @ (*)\n        if (iReset)\n            rCAData <= 8'b0;\n        else\n            case (rCurState)\n            State_NCmdWrite0:\n                rCAData <= 8'h80;\n            State_NAddrWrite0:\n                rCAData <= rColAddress[7:0];\n            State_NAddrWrite1:\n                rCAData <= rColAddress[15:8];\n            State_NAddrWrite2:\n                rCAData <= rRowAddress[7:0];\n            State_NAddrWrite3:\n                rCAData <= rRowAddress[15:8];\n            State_NAddrWrite4:\n                rCAData <= rRowAddress[23:16];\n            State_NCmdWrite1:\n                rCAData <= 8'h10;\n            default:\n                rCAData <= 0;\n            endcase\n    \n    assign oStart = wModuleTriggered;\n    assign oLastStep    = iPM_LastStep[0] & (rCurState == State_WaitDone);\n    \n    assign oPM_PCommand         = rPMTrigger;\n    assign oPM_PCommandOption   = rPCommandOption;assign oPM_TargetWay        = rTargetWay;\n    assign oPM_NumOfData        = rPMLength ;\n    assign oPM_CASelect         = rPMCommandOrAddress;\n    assign oPM_CAData           = rCAData;\n    assign oPM_WriteData        = iWriteData;\n    assign oPM_WriteLast        = iWriteLast;\n    assign oPM_WriteValid       = iWriteValid;\n    assign oWriteReady          = iPM_WriteReady;\n    \nendmodule\n",
        "module_name": "NPCG_Toggle_BNC_P_program",
        "module_hash": "f300c12fa9e4de11d1ab1d40ca14969c",
        "dataset_index": 25553
      },
      "mux4to1_enable_bb754788": {
        "rtl_code": "module mux4to1_enable(\n    input wire [3:0] in,\n    input wire [1:0] sel,\n    input wire ena,\n    output reg out\n);\n\n// The most significant bit is used as output\nwire [3:0] selected_input;\nassign selected_input = in[sel];\n\nalways @(posedge ena) begin\n    if (ena) begin\n        out <= selected_input;\n    end else begin\n        out <= 4'b0;\n    end\nend\n\nendmodule",
        "module_name": "mux4to1_enable",
        "module_hash": "bb7547887910e967e257da7aa3d2630b",
        "dataset_index": 11608
      },
      "float_mult_382a8c36": {
        "rtl_code": "\nmodule float_mult (\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] product\n);\n\nreg [31:0] mantissa_a, mantissa_b, mantissa_product;\nreg [7:0] exponent_a, exponent_b, exponent_product;\nreg sign_a, sign_b, sign_product;\nreg [8:0] guard_bits, round_bit, sticky_bit;\n\nalways @(*) begin\n    sign_a = a[31];\n    sign_b = b[31];\n    mantissa_a = {1'b1, a[22:0]};\n    mantissa_b = {1'b1, b[22:0]};\n    exponent_a = a[30:23];\n    exponent_b = b[30:23];\n    mantissa_product = mantissa_a * mantissa_b;\n    guard_bits = mantissa_product[25:23];\n    round_bit = mantissa_product[22];\n    sticky_bit = |mantissa_product[21:0];\n    exponent_product = exponent_a + exponent_b - 127;\n    if (mantissa_product[26]) begin\n        mantissa_product = mantissa_product >> 1;\n        exponent_product = exponent_product + 1;\n    end\n    if (guard_bits == 3'b111 || (guard_bits == 3'b110 && (round_bit || sticky_bit))) begin\n        mantissa_product = mantissa_product + 1;\n        if (mantissa_product[26]) begin\n            mantissa_product = mantissa_product >> 1;\n            exponent_product = exponent_product + 1;\n        end\n    end\n    sign_product = sign_a ^ sign_b;\n    product[31] = sign_product;\n    product[30:23] = exponent_product;\n    product[22:0] = mantissa_product[22:0];\nend\nendmodule",
        "module_name": "float_mult",
        "module_hash": "382a8c3673aed0eb0c93450cf1ca0f43",
        "dataset_index": 9956
      },
      "d_ff_en_parameterized #_c7c75baf": {
        "rtl_code": "module d_ff_en_parameterized #\n  (\n    parameter WIDTH = 1,\n    parameter INIT = 0\n  )\n  (\n    input wire CLK,\n    input wire E,\n    input wire [WIDTH-1:0] D,\n    output reg [WIDTH-1:0] Q\n  );\n\n  always @(posedge CLK) begin\n    if (E) begin\n      Q <= D;\n    end\n  end\n\n  initial begin\n    Q <= INIT;\n  end\n\nendmodule",
        "module_name": "d_ff_en_parameterized #",
        "module_hash": "c7c75bafad66e63df4c2f865bf48b295",
        "dataset_index": 9305
      },
      "segDisplayDriver_d11a0a44": {
        "rtl_code": "\nmodule segDisplayDriver(clk,data,out_dig,out_seg);\n\ninput clk;\ninput [15:0] data;\noutput [3:0] out_dig;\noutput [7:0] out_seg;\n\nreg [31:0] clk_cnt;\nreg clk_500Hz;\n\nalways @ (posedge clk)\n    if(clk_cnt == 32'd200_000) begin\n        clk_cnt <= 1'b0;\n        clk_500Hz <= ~clk_500Hz;\n    end\n    else\n        clk_cnt <= clk_cnt + 1'b1;\n\nreg [3:0] dig_ctrl = 4'b1110;\nalways @(posedge clk_500Hz)\ndig_ctrl <= { dig_ctrl[2:0], dig_ctrl[3] };\n\nreg [4:0] seg_ctrl;\nalways @ (dig_ctrl)\n    case(dig_ctrl)\n        4'b1110:    seg_ctrl={1'b0,data[3:0]};\n        4'b1101:    seg_ctrl={1'b0,data[7:4]};\n        4'b1011:    seg_ctrl={1'b0,data[11:8]};\n        4'b0111:    seg_ctrl={1'b0,data[15:12]};\n        default:      seg_ctrl=5'h1f;\n    endcase\nreg [7:0] seg_reg;\nalways @( seg_ctrl )\n    case( seg_ctrl )\n        5'h00:  seg_reg = 8'b1100_0000;5'h01:  seg_reg = 8'b1111_1001;5'h02:  seg_reg = 8'b1010_0100;5'h03:  seg_reg = 8'b1011_0000;5'h04:  seg_reg = 8'b1001_1001;5'h05:  seg_reg = 8'b1001_0010;5'h06:  seg_reg = 8'b1000_0010;5'h07:  seg_reg = 8'b1111_1000;5'h08:  seg_reg = 8'b1000_0000;5'h09:  seg_reg = 8'b1001_0000;5'h0a:  seg_reg = 8'b1000_1000;5'h0b:  seg_reg = 8'b1000_0011;5'h0c:  seg_reg = 8'b1100_0110;5'h0d:  seg_reg = 8'b1010_0001;5'h0e:  seg_reg = 8'b1000_0110;5'h0f:  seg_reg = 8'b1000_1110;5'h10:  seg_reg = 8'b1111_1111;5'h11:  seg_reg = 8'b1100_0111;5'h12:  seg_reg = 8'b1010_1111;5'h13:  seg_reg = 8'b1010_0001;5'h14:  seg_reg = 8'b1010_0011;5'h15:  seg_reg = 8'b1010_1011;5'h16:  seg_reg = 8'b1000_0110;default:seg_reg = 8'b1111_1111;endcase\nassign out_dig = dig_ctrl;\nassign out_seg = seg_reg;\n\nendmodule\n",
        "module_name": "segDisplayDriver",
        "module_hash": "d11a0a44b74f448200c929929ada4f53",
        "dataset_index": 22857
      },
      "interrupt_controller_6e91ec0a": {
        "rtl_code": "module interrupt_controller (\n  input [n-1:0] irq,\n  output [m-1:0] iak\n);\n\nparameter n = 4; // number of IRQ signals\nparameter m = 2; // number of IAK signals\nparameter p = 3; // number of priority levels\n\nreg [n-1:0] irq_priority; // priority level for each IRQ signal\nreg [n-1:0] irq_active; // active status for each IRQ signal\nreg [p-1:0] highest_priority; // highest priority level\nreg [m-1:0] iak_active; // active status for each IAK signal\ninteger i;\n\n// assign priority levels to each IRQ signal\ninitial begin\n  irq_priority[0] = 2;\n  irq_priority[1] = 1;\n  irq_priority[2] = 0;\n  irq_priority[3] = 1;\nend\n\n// detect active IRQ signals\nalways @ (irq) begin\n  for (i = 0; i < n; i = i + 1) begin\n    if (irq[i] == 1) begin\n      irq_active[i] = 1;\n    end else begin\n      irq_active[i] = 0;\n    end\n  end\nend\n\n// detect highest priority IRQ signal\nalways @ (irq_active) begin\n  highest_priority = p;\n  for (i = 0; i < n; i = i + 1) begin\n    if (irq_active[i] == 1 && irq_priority[i] < highest_priority) begin\n      highest_priority = irq_priority[i];\n    end\n  end\nend\n\n// generate IAK signals for highest priority IRQ signal\nalways @ (highest_priority) begin\n  for (i = 0; i < m; i = i + 1) begin\n    if (i == highest_priority) begin\n      iak_active[i] = 1;\n    end else begin\n      iak_active[i] = 0;\n    end\n  end\nend\n\n// assign IAK signals to output\nassign iak = iak_active;\n\nendmodule",
        "module_name": "interrupt_controller",
        "module_hash": "6e91ec0af14c034430c001b6184fe67b",
        "dataset_index": 11525
      },
      "d_flip_flop_7c645a11": {
        "rtl_code": "module d_flip_flop (\n    input D,\n    input CLK,\n    input SET,\n    input RESET,\n    input CE,\n    output reg Q,\n    output reg Q_N\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Flip-flop implementation\n    always @(posedge CLK or negedge CE) begin\n        if (CE == 0) begin\n            Q <= Q;\n            Q_N <= Q_N;\n        end else if (SET == 0) begin\n            Q <= 1'b1;\n            Q_N <= 1'b0;\n        end else if (RESET == 0) begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule",
        "module_name": "d_flip_flop",
        "module_hash": "7c645a119c39124cb809da8156126578",
        "dataset_index": 10698
      },
      "BRAM1_ba2f84e4": {
        "rtl_code": "module BRAM1(\n    input CLK,\n    input EN,\n    input WE,\n    input [ADDR_WIDTH-1:0] ADDR,\n    input [DATA_WIDTH-1:0] DI,\n    output [DATA_WIDTH-1:0] DO\n);\n\nparameter PIPELINED = 0;\nparameter ADDR_WIDTH = 1;\nparameter DATA_WIDTH = 1;\nparameter MEMSIZE = 1;\n\nreg [DATA_WIDTH-1:0] RAM [0:MEMSIZE-1];\nreg [DATA_WIDTH-1:0] DO_R;\nreg [DATA_WIDTH-1:0] DO_R2;\n\nalways @(posedge CLK) begin\n    if (EN) begin\n        if (WE) begin\n            RAM[ADDR] <= DI;\n            DO_R <= DI;\n        end else begin\n            DO_R <= RAM[ADDR];\n        end\n    end\n    DO_R2 <= DO_R;\nend\n\nassign DO = (PIPELINED) ? DO_R2 : DO_R;\n\nendmodule",
        "module_name": "BRAM1",
        "module_hash": "ba2f84e43bc2d0b9ef67b3d5c7733a85",
        "dataset_index": 5310
      },
      "RotaryInterface_6515e162": {
        "rtl_code": "module RotaryInterface(clock,reset,rotary,rotary_left,rotary_right);\n   input wire       clock;\n   input wire       reset;\n   \n   input wire [1:0] rotary;\n\n   output wire      rotary_left;\n   output wire      rotary_right;\n\n   reg              s_Filter1;\n   reg              s_Filter2;\n   reg              s_Filter1Delay;\n   reg              s_RotaryLeft;\n   reg              s_DoneRotaryLeft;\n   reg              s_RotaryRight;\n   reg              s_DoneRotaryRight;\n\n   assign rotary_left = s_RotaryLeft;\n   assign rotary_right = s_RotaryRight;\n\n   always @ (posedge clock) begin\n      if (reset) begin\n         s_Filter1 <= 0;\n         s_Filter2 <= 0;\n      end\n      else begin\n         case (rotary)\n           2'b00: begin\n              s_Filter1 <= 0;\n              s_Filter2 <= s_Filter2;\n           end\n\n           2'b01: begin\n              s_Filter1 <= s_Filter1;\n              s_Filter2 <= 0;\n           end\n\n           2'b10: begin\n              s_Filter1 <= s_Filter1;\n              s_Filter2 <= 1;\n           end\n\n           2'b11: begin\n              s_Filter1 <= 1;\n              s_Filter2 <= s_Filter2;\n           end\n\n           default: begin\n              s_Filter1 <= s_Filter1;\n              s_Filter2 <= s_Filter2;\n           end\n         endcase end\n   end always @ (posedge clock) begin\n      if (reset) begin\n         s_Filter1Delay    <= 0;\n         s_RotaryLeft      <= 0;\n         s_DoneRotaryLeft  <= 0;\n         s_RotaryRight     <= 0;\n         s_DoneRotaryRight <= 0;\n      end\n      else begin\n         if (s_Filter1 && !s_Filter1Delay) begin\n            if (s_Filter2) begin\n               if (!s_DoneRotaryRight) begin\n                  s_Filter1Delay    <= s_Filter1;\n                  s_RotaryLeft      <= 0;\n                  s_DoneRotaryLeft  <= 0;\n                  s_RotaryRight     <= 1;\n                  s_DoneRotaryRight <= 1;\n               end\n               else begin\n                  s_Filter1Delay    <= s_Filter1;\n                  s_RotaryLeft      <= 0;\n                  s_DoneRotaryLeft  <= 0;\n                  s_RotaryRight     <= 0;\n                  s_DoneRotaryRight <= 1;\n               end end else begin\n               if (!s_DoneRotaryLeft) begin\n                  s_Filter1Delay    <= s_Filter1;\n                  s_RotaryLeft      <= 1;\n                  s_DoneRotaryLeft  <= 1;\n                  s_RotaryRight     <= 0;\n                  s_DoneRotaryRight <= 0;\n               end\n               else begin\n                  s_Filter1Delay    <= s_Filter1;\n                  s_RotaryLeft      <= 0;\n                  s_DoneRotaryLeft  <= 1;\n                  s_RotaryRight     <= 0;\n                  s_DoneRotaryRight <= 0;\n               end end end else begin\n            s_Filter1Delay    <= s_Filter1;\n            s_RotaryLeft      <= 0;\n            s_DoneRotaryLeft  <= 0;\n            s_RotaryRight     <= 0;\n            s_DoneRotaryRight <= 0;\n         end end end endmodule ",
        "module_name": "RotaryInterface",
        "module_hash": "6515e1621ec66f387b737b23f60523da",
        "dataset_index": 22469
      },
      "twobitmux_949549dd": {
        "rtl_code": "module twobitmux(in, s, out);\n\tinput wire[1: 0] in;\n\tinput wire s;\n\toutput wire out;\n\tassign out = (s == 1'b0) ? in[0] : in[1];\nendmodule\n\nmodule eightbitmux(in, s, out);\n\tinput wire[7: 0] in;\n\tinput wire[2: 0] s;\n\toutput wire out;\n\twire[5: 0] _out;\n\ttwobitmux m1({in[0], in[1]}, s[0], _out[0]);\n\ttwobitmux m2({in[2], in[3]}, s[0], _out[1]);\n\ttwobitmux m3({in[4], in[5]}, s[0], _out[2]);\n\ttwobitmux m4({in[6], in[7]}, s[0], _out[3]);\n\ttwobitmux m5({_out[0], _out[1]}, s[1], _out[4]);\n\ttwobitmux m6({_out[2], _out[3]}, s[1], _out[5]);\n\ttwobitmux m7({_out[4], _out[5]}, s[2], out);\nendmodule",
        "module_name": "twobitmux",
        "module_hash": "949549ddab6307d197480015fe10de88",
        "dataset_index": 21016
      },
      "register_ctrl_top_4f7af6e6": {
        "rtl_code": "module register_ctrl_top(\n    input                             I_sys_clk           , \n    input                             I_sys_rst           ,\n    //=====================System usb_uart_if=========================== \n    output                            O_usb_uart_tx_req   ,\n    output   [7 : 0]                  O_usb_uart_tx_data  ,\n    input                             I_usb_uart_tx_full  ,\n    \n    output                            O_usb_uart_rx_req   ,\n    input    [7 : 0]                  I_usb_uart_rx_data  ,\n    input                             I_usb_uart_rx_empty ,    \n    //==================================================================\n    output                            O_usb_dir           ,\n\t \n    output                            O_motor_start       ,\n    \n    output                            tp                  ,\n\t \n    input                             I_key_start\n);\n//=======================================================================\nreg                                   R_usb_uart_rx_req     ;\nreg                                   R_usb_uart_rx_req_d1  ;\n\nreg                                   R_tx_en       ;\nreg          [7 : 0]                  R_tx_data     ;\n\nreg                                   R_rx_en       ;\nreg          [7 : 0]                  R_rx_data     ;\n\nreg                                   R_usb_dir     ;\n\nreg                                   R_motor_start ;\n\n//=======================================================================\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_usb_uart_rx_req     <= 1'd0     ;\n        end\n    else if(I_usb_uart_rx_empty == 1'b0)       //   if  has data .then  read \n        begin\n            R_usb_uart_rx_req     <= 1'd1     ;\n        end\n    else\n        begin\n            R_usb_uart_rx_req     <= 1'd0     ;\n        end\n        \n    //\n    R_usb_uart_rx_req_d1          <= R_usb_uart_rx_req;\nend\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_rx_en       <= 1'd0   ;\n            R_rx_data     <= 8'd0  ;\n        end\n    else if(R_usb_uart_rx_req_d1 == 1'b1)\n        begin\n            R_rx_en       <= 1'd1   ;\n            R_rx_data     <= I_usb_uart_rx_data  ;\n        end\n    else\n        begin\n            R_rx_en       <= 1'd0   ;\n        end\nend\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_tx_en       <= 1'd0   ;\n            R_tx_data     <= 8'd0  ;\n        end\n    else if(I_usb_uart_tx_full==1'b0)           // not  full \n        begin\n            if(I_key_start==1'b1)\n                begin\n                    R_tx_en       <= 1'b1  ;//R_rx_en;\n                    R_tx_data     <= 8'h55 ;//R_rx_data;\n                end\n            else\n                begin\n                    R_tx_en       <= 1'b0  ;//R_rx_en;\n                end\n        end\n    else\n        begin\n            R_tx_en       <= 1'b0  ;\n        end\nend \n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_usb_dir       <= 1'd0;                    //\u76ee\u524d\u91c7\u7528\u4e86\u9ed8\u8ba4\u503c\n            R_motor_start   <= 1'b0;\n        end\n    else if(R_rx_en)\n        begin\n            case(R_rx_data)\n                8'h00:\n                    begin\n                        R_usb_dir       <= 1'b0;      //wr TO USB \n                    end\n                8'hff:\n                    begin\n                        R_usb_dir       <= 1'b1;     // rd  FROM  USB \n                    end\n                8'h02:\n                    begin\n                        R_motor_start   <= 1'b1;    //  motor  \n                    end\n            endcase\n        end\n    else\n        begin\n            R_motor_start   <= 1'b0;\n        end\n        \nend\n\nassign O_usb_uart_rx_req   = R_usb_uart_rx_req;\n\nassign O_usb_uart_tx_req   = R_tx_en  ;\n\nassign O_usb_uart_tx_data  = R_tx_data;\n\nassign O_usb_dir           = R_usb_dir  ;\n\nassign O_motor_start       = R_motor_start;\n\nassign  tp                 = R_rx_en & (~(&R_rx_data)) & O_motor_start & O_usb_dir;\n\nendmodule",
        "module_name": "register_ctrl_top",
        "module_hash": "4f7af6e68579ce62c436a6bc53b4976c",
        "dataset_index": 20889
      },
      "calculator_effa20fe": {
        "rtl_code": "module calculator(\n    input signed [15:0] A,\n    input signed [15:0] B,\n    input [1:0] op,\n    output reg signed [15:0] result\n);\n\nalways @(*)\nbegin\n    case(op)\n        2'b00: result = A + B; // Addition\n        2'b01: result = A - B; // Subtraction\n        2'b10: result = A * B; // Multiplication\n        2'b11: begin // Division\n            if(B == 0) // Division by zero\n                result = 16'hFFFF; // Maximum possible 16-bit number\n            else\n                result = A / B;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "effa20fe8d5170851c3e7c2e33002d3d",
        "dataset_index": 18945
      },
      "vga512x256_d845e6e7": {
        "rtl_code": "module vga512x256 (\n\tinput wire clk,\n\tinput wire rst,\n\toutput wire [12:0] maddr,\tinput wire [15:0] mdata,\toutput wire red,\n\toutput wire green,\n\toutput wire blue,\n\toutput wire hsync,\n\toutput wire vsync);\n\n\tparameter B = 50;\tparameter C = 92;\tparameter D = 512;\tparameter E = 36;\tparameter P = 4;\tparameter Q = 61;\tparameter R = 512;\tparameter S = 31;\treg [9:0] cnt_x;\n\treg [9:0] cnt_y;\n\n\treg [15:0] word;\n\n\tassign red = word[0];\n\tassign green = word[0];\n\tassign blue = word[0];\n\n\tassign maddr = { cnt_y[8:1], cnt_x[8:4] };\n\n\tassign hsync = ~(cnt_x > (D + E) && cnt_x <= (D + E + B));\n\tassign vsync = ~(cnt_y >= (R + S) && cnt_y < (R + S + P));\n\n\talways @(posedge clk) begin\n\t\tif (rst || cnt_x == (B + C + D + E - 1))\n\t\t\tcnt_x <= 0;\n\t\telse\n\t\t\tcnt_x <= cnt_x + 1;\n\n\t\tif (rst)\n\t\t\tcnt_y <= 0;\n\t\telse if (cnt_x == (B + C + D + E - 1)) begin\n\t\t\tif (cnt_y == (P + Q + R + S - 1))\n\t\t\t\tcnt_y <= 0;\n\t\t\telse\n\t\t\t\tcnt_y <= cnt_y + 1;\n\t\tend\n\n\t\tif (cnt_x[3:0] == 1) begin\n\t\t\tif (cnt_x <= D && cnt_y < R)\n\t\t\t\tword <= mdata;\n\t\t\telse\n\t\t\t\tword <= 0;\n\t\tend else\n\t\t\tword <= { 1'b0, word[15:1] };\n\tend\nendmodule\n",
        "module_name": "vga512x256",
        "module_hash": "d845e6e74d3207df706046e9aa61bec0",
        "dataset_index": 2767
      },
      "add_sub_module_f450a337": {
        "rtl_code": "\nmodule add_sub_module(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\nwire [31:0] carry;\nwire [31:0] diff;\n\nassign carry[0] = sub ? ~b[0] : b[0];\n\nassign diff[0] = sub ? b[0] : ~b[0];\n\ngenvar i;\nfor (i = 1; i < 32; i = i + 1) begin : gen_full_adder\n    full_adder fa(\n        .a(a[i]),\n        .b(b[i]),\n        .cin(carry[i-1]),\n        .sum(sum[i]),\n        .cout(carry[i])\n    );\nend\n\nassign sum[0] = sub ? a[0] ^ diff[0] : a[0] ^ carry[0];\n\nendmodule\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output wire sum,\n    output wire cout\n);\n\nassign {cout, sum} = a + b + cin;\n\nendmodule\nmodule full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output wire diff,\n    output wire bout\n);\n\nassign {bout, diff} = a - b - bin;\n\nendmodule",
        "module_name": "add_sub_module",
        "module_hash": "f450a337a536f81e8f0ff32bb6aac12a",
        "dataset_index": 3357
      },
      "DFF_EN_CLK_GATE_9d17bd2c": {
        "rtl_code": "module DFF_EN_CLK_GATE (\n  input clk,\n  input en,\n  input te,\n  input [31:0] d,\n  output reg [31:0] q\n);\n\n  wire gated_clk;\n  assign gated_clk = (en & te) ? clk : 1'b0;\n  \n  always @(posedge gated_clk) begin\n    q <= d;\n  end\n\nendmodule",
        "module_name": "DFF_EN_CLK_GATE",
        "module_hash": "9d17bd2cca0176cf8cdc1c553818df1f",
        "dataset_index": 11706
      },
      "sky130_fd_sc_ms__o211ai_f841fc6c": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__o211ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1         );\n    nand nand0 (nand0_out_Y, C1, or0_out, B1);\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__o211ai",
        "module_hash": "f841fc6c006eb0e6be0c374f5c530c5d",
        "dataset_index": 22685
      },
      "regfile_29b45960": {
        "rtl_code": "\nmodule regfile(\n  input [2:0] addr1,\n  input [2:0] addr2,\n  input [7:0] data_in,\n  output reg [7:0] data_out1,\n  output reg [7:0] data_out2,\n  input wire write_en\n);\n\n  reg [7:0] regs [0:7];\n  \n  always @(*) begin\n    // Read operations\n    data_out1 = regs[addr1];\n    data_out2 = regs[addr2];\n    \n    // Write operation\n    if (write_en) begin\n      regs[addr1] = data_in;\n    end\n  end\n  \nendmodule",
        "module_name": "regfile",
        "module_hash": "29b459606c378b21655a7261a13aa3ab",
        "dataset_index": 7941
      },
      "xor_adder_70b74317": {
        "rtl_code": "module xor_adder (\n    input [7:0] in,\n    output reg [3:0] out,\n    input clk,\n    input reset\n);\n\nreg [7:0] constant = 8'b10101010;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        out <= 4'b0;\n    end else begin\n        out <= {in ^ constant} + 4'b1;\n    end\nend\n\nendmodule",
        "module_name": "xor_adder",
        "module_hash": "70b74317288cdbac20a8a2ac52e77166",
        "dataset_index": 15199
      },
      "shift_register_16743d60": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input [3:0] in,\n    input load,\n    output [3:0] out,\n    output reg valid\n);\n\nreg [3:0] reg1, reg2, reg3, reg4;\n\nalways @(posedge clk) begin\n    if (load) begin\n        reg1 <= in;\n        reg2 <= reg1;\n        reg3 <= reg2;\n        reg4 <= reg3;\n        valid <= 1;\n    end else begin\n        reg1 <= reg2;\n        reg2 <= reg3;\n        reg3 <= reg4;\n        reg4 <= 0;\n        valid <= 0;\n    end\nend\n\nassign out = reg4;\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "16743d607eaed4d0a93cbb1b4a186c9b",
        "dataset_index": 685
      },
      "serial_fifo_buffer_0bce924d": {
        "rtl_code": "\nmodule serial_fifo_buffer (\n  input wire s_axi_aclk,\n  input wire s_axi_aresetn,\n  input wire fifo_wr,\n  input wire tx_Start,\n  input wire tx_Data_Enable_reg,\n  input wire [7:0] tx_DataBits,\n  input wire [7:0] s_axi_wdata,\n  input wire p_4_in,\n  input wire fifo_Read,\n  input wire reset_TX_FIFO_reg,\n  input wire mux_sel_reg_0,\n  input wire mux_sel_reg_2,\n  output wire tx_Buffer_Empty,\n  output wire mux_Out,\n  output reg [7:0] Q, // Changed to reg from wire\n  output wire tx_Start0\n);\n\n  reg [3:0] write_ptr;\n  reg [3:0] read_ptr;\n  reg [7:0] fifo [15:0];\n  reg tx_Buffer_Full;\n\n  always @(posedge s_axi_aclk) begin\n    if (~s_axi_aresetn) begin\n      write_ptr <= 0;\n      read_ptr <= 0;\n      tx_Buffer_Full <= 0;\n    end else begin\n      if (fifo_wr && !tx_Buffer_Full) begin\n        fifo[write_ptr] <= s_axi_wdata;\n        write_ptr <= write_ptr + 1;\n        if (write_ptr == 15) begin\n          write_ptr <= 0;\n        end\n        if (write_ptr == read_ptr) begin\n          tx_Buffer_Full <= 1;\n        end\n      end\n      if (fifo_Read) begin\n        Q <= fifo[read_ptr]; // Changed to <= from =\n        read_ptr <= read_ptr + 1;\n        if (read_ptr == 15) begin\n          read_ptr <= 0;\n        end\n        tx_Buffer_Full <= 0;\n      end\n    end\n  end\n\n  assign tx_Buffer_Empty = ~tx_Buffer_Full;\n  assign mux_Out = mux_sel_reg_0 ? tx_DataBits : p_4_in;\n  assign tx_Start0 = tx_Start && tx_Data_Enable_reg;\n\nendmodule\n",
        "module_name": "serial_fifo_buffer",
        "module_hash": "0bce924df1948a878ce735165ab6fcc5",
        "dataset_index": 16174
      },
      "top_module_6d575997": {
        "rtl_code": "\nmodule top_module(\n    input [7:0] a,\n    input [7:0] b,\n    input select, // Select input to choose between addition and subtraction\n    output [7:0] out // 8-bit output from the functional module\n);\n\n// Instantiate the priority encoder module\nwire [2:0] pos;\npriority_encoder pe(\n    .in(a + b), // Input to the priority encoder is the sum of a and b\n    .out(pos) // Output of the priority encoder is the position of the first high bit in the sum\n);\n\n// Instantiate the adder-subtractor module\nwire [7:0] sum;\nadder_subtractor as(\n    .a(a),\n    .b(b),\n    .select(select),\n    .out(sum) // Output of the adder-subtractor is the sum or difference of a and b\n);\n\n// Instantiate the functional module\nfunctional_module fm(\n    .pe_out(pos),\n    .as_out(sum),\n    .out(out)\n);\n\nendmodule\n\nmodule priority_encoder(\n    input [7:0] in,\n    output [2:0] out\n);\n\nassign out = (in[7] ? 7 :\n             (in[6] ? 6 :\n             (in[5] ? 5 :\n             (in[4] ? 4 :\n             (in[3] ? 3 :\n             (in[2] ? 2 :\n             (in[1] ? 1 :\n             (in[0] ? 0 : 0))))))));\n\nendmodule\n\nmodule adder_subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    input select,\n    output [7:0] out\n);\n\nassign out = select ? a - b : a + b;\n\nendmodule\n\nmodule functional_module(\n    input [2:0] pe_out,\n    input [7:0] as_out,\n    output [7:0] out\n);\n\nassign out = (as_out == 0) ? 0 : pe_out;\n\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "6d57599724c56c8812574d03580e57fa",
        "dataset_index": 4682
      },
      "csconvert_mono_9333ccb4": {
        "rtl_code": "\nmodule csconvert_mono (en,\n                       clk,\n                       din,\n                       pre_first_in,\n                       y_out,\n                       yaddr,\n                       ywe,\n                       pre_first_out);\n\n    input        en;\n    input        clk;\t\t\tinput  [7:0] din; input        pre_first_in;      output [7:0] y_out;  output [7:0] yaddr; output       ywe;\t output       pre_first_out;\n\n    wire         pre_first_out= pre_first_in;\nwire   [7:0] y_out=         {~din[7],din[6:0]};\n    reg    [7:0] yaddr;\n    reg          ywe;\n\n    always @ (posedge clk) begin\n      ywe <= en & (pre_first_in || (ywe && (yaddr[7:0] !=8'hff)));\n      if (!en || pre_first_in) yaddr[7:0] <= 8'h0;\n      else if (ywe)            yaddr[7:0] <= yaddr[7:0] + 1;\n    end\n\nendmodule\n\nmodule csconvert_jp4  (en,\n                       clk,\n                       din,\n                       pre_first_in,\n                       y_out,\n                       yaddr,\n                       ywe,\n                       pre_first_out);\n\n    input        en;\n    input        clk;         input  [7:0] din; input        pre_first_in;      output [7:0] y_out;  output [7:0] yaddr; output       ywe;    output       pre_first_out;\n\n    wire         pre_first_out= pre_first_in;\nwire   [7:0] y_out=         {~din[7],din[6:0]};\n    reg    [7:0] yaddr_cntr;\n    reg          ywe;\n    wire   [7:0] yaddr= {yaddr_cntr[4],yaddr_cntr[7:5],yaddr_cntr[0],yaddr_cntr[3:1]};\n    always @ (posedge clk) begin\n      ywe <= en & (pre_first_in || (ywe && (yaddr[7:0] !=8'hff)));\n      if (!en || pre_first_in) yaddr_cntr[7:0] <= 8'h0;\n      else if (ywe)            yaddr_cntr[7:0] <= yaddr_cntr[7:0] + 1;\n    end\n\nendmodule\n\nmodule csconvert_jp4diff  (en,\n                           clk,\n                           scale_diff,     hdr,            din,\n                           pre_first_in,\n                           y_out,\n                           yaddr,\n                           ywe,\n                           pre_first_out,\n                           bayer_phase);\ninput        en;\n    input        clk;         input        scale_diff;\n    input        hdr;\n    input  [7:0] din; input        pre_first_in;      output [8:0] y_out;  output [7:0] yaddr; output       ywe;    output       pre_first_out;\n    input  [1:0] bayer_phase; reg          pre_first_out;\n    reg    [2:0] pre2_first_out;\n    reg    [8:0] y_out;\n    reg    [8:0] pre_y_out;\n    reg    [7:0] yaddr_cntr;\n    reg    [7:0] pre_yaddr_cntr;\n    reg    [7:0] pre2_yaddr_cntr;\nreg          ywe;\n    reg    [2:0] pre_ywe;\n    reg    [7:0] yaddr;\nreg          dly_1;\n    reg   [14:0] dly_16;\n    reg          dly_17;\nwire         start_out=bayer_phase[1]?(bayer_phase[0]?dly_17: dly_16[14]):(bayer_phase[0]?dly_1:pre_first_in);\n    reg    [7:0] iadr;\n    reg          iadr_run;\n    reg    [1:0] mux_plus_sel;\n    reg    [2:0] mux_minus_sel;\n    reg          hdr_bit;\n    reg    [1:0] scale_color;\n    reg    [1:0] is_color;\n \n    reg    [7:0] mux_plus;\n    reg    [7:0] mux_minus;\n    reg    [7:0] dd0;\n    reg    [7:0] dd1;\n    wire   [7:0] dd16;\n    reg    [7:0] dd17;\n    reg   [14:0] ddsr0,ddsr1,ddsr2,ddsr3,ddsr4,ddsr5,ddsr6,ddsr7; \n    wire   [8:0] scaled_pre_y_out= (scale_color[1])? +{pre_y_out[8],pre_y_out[8:1]}: pre_y_out[8:0];\n    assign dd16[7:0]={ddsr7[14],ddsr6[14],ddsr5[14],ddsr4[14],ddsr3[14],ddsr2[14],ddsr1[14],ddsr0[14]};\n    always @ (posedge clk) begin\n      dly_1  <= pre_first_in;\n      dly_17 <= dly_16[14];\n      dly_16[14:0] <= {dly_16[13:0],dly_1};\n\n      pre2_first_out[2:0]<= {pre2_first_out[1:0], start_out};\n      pre_first_out<= pre2_first_out[2];\n\n      iadr_run <= en & (start_out || (iadr_run && (iadr[7:0]!=8'hff)));\n      pre_ywe[2:0] <= {pre_ywe[1:0],iadr_run};\n      ywe <= pre_ywe[2];\n\n      if      (!en || start_out)  iadr[7:0] <= 8'h0;\n      else if (iadr_run)          iadr[7:0] <= iadr[7:0] + 1;\n      pre2_yaddr_cntr[7:0] <= iadr[7:0];\n      pre_yaddr_cntr [7:0] <= pre2_yaddr_cntr[7:0];\n      yaddr_cntr[7:0]           <= pre_yaddr_cntr[7:0];\n      yaddr[7:0] <= {yaddr_cntr[4],yaddr_cntr[7:5],yaddr_cntr[0],yaddr_cntr[3:1]};\n\n\n      case ({bayer_phase[1:0],iadr[4],iadr[0]} )\n       4'b0000: begin mux_plus_sel <= 2'h0; mux_minus_sel <= 3'h4; hdr_bit <=1'h0; end\n       4'b0001: begin mux_plus_sel <= 2'h0; mux_minus_sel <= 3'h1; hdr_bit <=1'h0; end\n       4'b0010: begin mux_plus_sel <= 2'h0; mux_minus_sel <= 3'h2; hdr_bit <=1'h0; end\n       4'b0011: begin mux_plus_sel <= 2'h0; mux_minus_sel <= 3'h3; hdr_bit <=1'h1; end\n       4'b0100: begin mux_plus_sel <= 2'h1; mux_minus_sel <= 3'h0; hdr_bit <=1'h0; end\n       4'b0101: begin mux_plus_sel <= 2'h1; mux_minus_sel <= 3'h4; hdr_bit <=1'h0; end\n       4'b0110: begin mux_plus_sel <= 2'h1; mux_minus_sel <= 3'h2; hdr_bit <=1'h1; end\n       4'b0111: begin mux_plus_sel <= 2'h1; mux_minus_sel <= 3'h3; hdr_bit <=1'h0; end\n       4'b1000: begin mux_plus_sel <= 2'h2; mux_minus_sel <= 3'h0; hdr_bit <=1'h0; end\n       4'b1001: begin mux_plus_sel <= 2'h2; mux_minus_sel <= 3'h1; hdr_bit <=1'h1; end\n       4'b1010: begin mux_plus_sel <= 2'h2; mux_minus_sel <= 3'h4; hdr_bit <=1'h0; end\n       4'b1011: begin mux_plus_sel <= 2'h2; mux_minus_sel <= 3'h3; hdr_bit <=1'h0; end\n       4'b1100: begin mux_plus_sel <= 2'h3; mux_minus_sel <= 3'h0; hdr_bit <=1'h1; end\n       4'b1101: begin mux_plus_sel <= 2'h3; mux_minus_sel <= 3'h1; hdr_bit <=1'h0; end\n       4'b1110: begin mux_plus_sel <= 2'h3; mux_minus_sel <= 3'h2; hdr_bit <=1'h0; end\n       4'b1111: begin mux_plus_sel <= 2'h3; mux_minus_sel <= 3'h4; hdr_bit <=1'h0; end\n      endcase\n\n      if (pre_ywe[0]) case (mux_plus_sel[1:0]) \n       2'h0:   mux_plus[7:0] <= dd0 [7:0];\n       2'h1:   mux_plus[7:0] <= dd1 [7:0];\n       2'h2:   mux_plus[7:0] <= dd16[7:0];\n       2'h3:   mux_plus[7:0] <= dd17[7:0];\n      endcase\n      if (pre_ywe[0]) casex ({mux_minus_sel[2] | (hdr_bit & hdr), mux_minus_sel[1:0]}) \n       3'h0:   mux_minus[7:0] <= dd0 [7:0];\n       3'h1:   mux_minus[7:0] <= dd1 [7:0];\n       3'h2:   mux_minus[7:0] <= dd16[7:0];\n       3'h3:   mux_minus[7:0] <= dd17[7:0];\n       3'b1xx: mux_minus[7:0] <= 8'h0;\n      endcase\n\n      is_color[1:0] <= {is_color[0], ~(mux_minus_sel[2] | (hdr_bit & hdr))}; scale_color[1:0] <= {scale_color[0], ~(mux_minus_sel[2] | (hdr_bit & hdr)) & scale_diff}; if (pre_ywe[1]) pre_y_out[8:0] <= {1'b0,mux_plus[7:0]} - {1'b0,mux_minus[7:0]};\ny_out[8:0] <=  scaled_pre_y_out[8:0] - {1'h0, ~is_color[1],7'h0}; dd0[7:0] <= din [7:0];\n      dd1[7:0] <= dd0 [7:0];\n      ddsr0[14:0] <= {ddsr0[13:0],dd1[0]};\n      ddsr1[14:0] <= {ddsr1[13:0],dd1[1]};\n      ddsr2[14:0] <= {ddsr2[13:0],dd1[2]};\n      ddsr3[14:0] <= {ddsr3[13:0],dd1[3]};\n      ddsr4[14:0] <= {ddsr4[13:0],dd1[4]};\n      ddsr5[14:0] <= {ddsr5[13:0],dd1[5]};\n      ddsr6[14:0] <= {ddsr6[13:0],dd1[6]};\n      ddsr7[14:0] <= {ddsr7[13:0],dd1[7]};\n      dd17[7:0] <= dd16 [7:0];\n    end\nendmodule\n\n",
        "module_name": "csconvert_mono",
        "module_hash": "9333ccb441172b224c12d274770215b7",
        "dataset_index": 10600
      },
      "adder_4bit_carry_133841d1": {
        "rtl_code": "module adder_4bit_carry (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [4:0] sum_wire;\nwire cout_wire;\n\nassign sum_wire = a + b + cin;\nassign sum = sum_wire[3:0];\nassign cout = sum_wire[4];\n\nendmodule",
        "module_name": "adder_4bit_carry",
        "module_hash": "133841d1ec48a29665f1d6b0f4e6805c",
        "dataset_index": 21104
      },
      "four_bit_arithmetic_2bb3b1ae": {
        "rtl_code": "\nmodule four_bit_arithmetic (\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] opcode,\n    output reg [3:0] result\n);\n\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n    \n    assign add_result = A + B;\n    assign sub_result = A - B;\n    assign and_result = A & B;\n    assign or_result = A | B;\n    \n    always @(*) begin\n        case (opcode)\n            2'b00: result = add_result;\n            2'b01: result = sub_result;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'bxxxx;\n        endcase\n    end\n\nendmodule\n",
        "module_name": "four_bit_arithmetic",
        "module_hash": "2bb3b1ae650286fc3f907dc4c1c75fa0",
        "dataset_index": 14273
      },
      "up_axi_db19b869": {
        "rtl_code": "\n\nmodule up_axi (\n\n  up_rstn,\n  up_clk,\n\n  up_axi_awvalid,\n  up_axi_awaddr,\n  up_axi_awready,\n  up_axi_wvalid,\n  up_axi_wdata,\n  up_axi_wstrb,\n  up_axi_wready,\n  up_axi_bvalid,\n  up_axi_bresp,\n  up_axi_bready,\n  up_axi_arvalid,\n  up_axi_araddr,\n  up_axi_arready,\n  up_axi_rvalid,\n  up_axi_rresp,\n  up_axi_rdata,\n  up_axi_rready,\n\n  up_wreq,\n  up_waddr,\n  up_wdata,\n  up_wack,\n  up_rreq,\n  up_raddr,\n  up_rdata,\n  up_rack);\n\n  parameter   PCORE_ADDR_WIDTH = 14;\n  localparam  AW = PCORE_ADDR_WIDTH - 1;\n\n  input           up_rstn;\n  input           up_clk;\n\n  input           up_axi_awvalid;\n  input   [31:0]  up_axi_awaddr;\n  output          up_axi_awready;\n  input           up_axi_wvalid;\n  input   [31:0]  up_axi_wdata;\n  input   [ 3:0]  up_axi_wstrb;\n  output          up_axi_wready;\n  output          up_axi_bvalid;\n  output  [ 1:0]  up_axi_bresp;\n  input           up_axi_bready;\n  input           up_axi_arvalid;\n  input   [31:0]  up_axi_araddr;\n  output          up_axi_arready;\n  output          up_axi_rvalid;\n  output  [ 1:0]  up_axi_rresp;\n  output  [31:0]  up_axi_rdata;\n  input           up_axi_rready;\n\n  output          up_wreq;\n  output  [AW:0]  up_waddr;\n  output  [31:0]  up_wdata;\n  input           up_wack;\n  output          up_rreq;\n  output  [AW:0]  up_raddr;\n  input   [31:0]  up_rdata;\n  input           up_rack;\n\n  reg             up_axi_awready = 'd0;\n  reg             up_axi_wready = 'd0;\n  reg             up_axi_bvalid = 'd0;\n  reg             up_wsel = 'd0;\n  reg             up_wreq = 'd0;\n  reg     [AW:0]  up_waddr = 'd0;\n  reg     [31:0]  up_wdata = 'd0;\n  reg     [ 2:0]  up_wcount = 'd0;\n  reg             up_wack_int = 'd0;\n  reg             up_axi_arready = 'd0;\n  reg             up_axi_rvalid = 'd0;\n  reg     [31:0]  up_axi_rdata = 'd0;\n  reg             up_rsel = 'd0;\n  reg             up_rreq = 'd0;\n  reg     [AW:0]  up_raddr = 'd0;\n  reg     [ 3:0]  up_rcount = 'd0;\n  reg             up_rack_int = 'd0;\n  reg     [31:0]  up_rdata_int = 'd0;\n  reg             up_rack_int_d = 'd0;\n  reg     [31:0]  up_rdata_int_d = 'd0;\n\n  assign up_axi_bresp = 2'd0;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_axi_awready <= 'd0;\n      up_axi_wready <= 'd0;\n      up_axi_bvalid <= 'd0;\n    end else begin\n      if (up_axi_awready == 1'b1) begin\n        up_axi_awready <= 1'b0;\n      end else if (up_wack_int == 1'b1) begin\n        up_axi_awready <= 1'b1;\n      end\n      if (up_axi_wready == 1'b1) begin\n        up_axi_wready <= 1'b0;\n      end else if (up_wack_int == 1'b1) begin\n        up_axi_wready <= 1'b1;\n      end\n      if ((up_axi_bready == 1'b1) && (up_axi_bvalid == 1'b1)) begin\n        up_axi_bvalid <= 1'b0;\n      end else if (up_wack_int == 1'b1) begin\n        up_axi_bvalid <= 1'b1;\n      end\n    end\n  end       \n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_wsel <= 'd0;\n      up_wreq <= 'd0;\n      up_waddr <= 'd0;\n      up_wdata <= 'd0;\n      up_wcount <= 'd0;\n    end else begin\n      if (up_wsel == 1'b1) begin\n        if ((up_axi_bready == 1'b1) && (up_axi_bvalid == 1'b1)) begin\n          up_wsel <= 1'b0;\n        end\n        up_wreq <= 1'b0;\n        up_waddr <= up_waddr;\n        up_wdata <= up_wdata;\n        up_wcount <= up_wcount + 1'b1;\n      end else begin\n        up_wsel <= up_axi_awvalid & up_axi_wvalid;\n        up_wreq <= up_axi_awvalid & up_axi_wvalid;\n        up_waddr <= up_axi_awaddr[AW+2:2];\n        up_wdata <= up_axi_wdata;\n        up_wcount <= 3'd0;\n      end\n    end\n  end\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      up_wack_int <= 'd0;\n    end else begin\n      if ((up_wcount == 3'h7) && (up_wack == 1'b0)) begin\n        up_wack_int <= 1'b1;\n      end else if (up_wsel == 1'b1) begin\n        up_wack_int <= up_wack;\n      end\n    end\n  end\n\n  assign up_axi_rresp = 2'd0;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_axi_arready <= 'd0;\n      up_axi_rvalid <= 'd0;\n      up_axi_rdata <= 'd0;\n    end else begin\n      if (up_axi_arready == 1'b1) begin\n        up_axi_arready <= 1'b0;\n      end else if (up_rack_int == 1'b1) begin\n        up_axi_arready <= 1'b1;\n      end\n      if ((up_axi_rready == 1'b1) && (up_axi_rvalid == 1'b1)) begin\n        up_axi_rvalid <= 1'b0;\n        up_axi_rdata <= 32'd0;\n      end else if (up_rack_int_d == 1'b1) begin\n        up_axi_rvalid <= 1'b1;\n        up_axi_rdata <= up_rdata_int_d;\n      end\n    end\n  end       \n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_rsel <= 'd0;\n      up_rreq <= 'd0;\n      up_raddr <= 'd0;\n      up_rcount <= 'd0;\n    end else begin\n      if (up_rsel == 1'b1) begin\n        if ((up_axi_rready == 1'b1) && (up_axi_rvalid == 1'b1)) begin\n          up_rsel <= 1'b0;\n        end\n        up_rreq <= 1'b0;\n        up_raddr <= up_raddr;\n      end else begin\n        up_rsel <= up_axi_arvalid;\n        up_rreq <= up_axi_arvalid;\n        up_raddr <= up_axi_araddr[AW+2:2];\n      end\n      if (up_rack_int == 1'b1) begin\n        up_rcount <= 4'd0;\n      end else if (up_rcount[3] == 1'b1) begin\n        up_rcount <= up_rcount + 1'b1;\n      end else if (up_rreq == 1'b1) begin\n        up_rcount <= 4'd8;\n      end\n    end\n  end\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      up_rack_int <= 'd0;\n      up_rdata_int <= 'd0;\n      up_rack_int_d <= 'd0;\n      up_rdata_int_d <= 'd0;\n    end else begin\n      if ((up_rcount == 4'hf) && (up_rack == 1'b0)) begin\n        up_rack_int <= 1'b1;\n        up_rdata_int <= {2{16'hdead}};\n      end else begin\n        up_rack_int <= up_rack;\n        up_rdata_int <= up_rdata;\n      end\n      up_rack_int_d <= up_rack_int;\n      up_rdata_int_d <= up_rdata_int;\n    end\n  end\n\nendmodule\n\n",
        "module_name": "up_axi",
        "module_hash": "db19b86933b5e540cde25d44e9902914",
        "dataset_index": 22732
      },
      "binary_to_gray_113aaf1a": {
        "rtl_code": "module binary_to_gray (\n    input [3:0] binary,\n    output reg [3:0] gray\n);\n\nalways @ (binary) begin\n    gray[3] = binary[3];\n    gray[2] = binary[3] ^ binary[2];\n    gray[1] = binary[2] ^ binary[1];\n    gray[0] = binary[1] ^ binary[0];\nend\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "113aaf1afe01155835ccc819f478a58c",
        "dataset_index": 3796
      },
      "ssio_sdr_in #_c9e92adc": {
        "rtl_code": "\n\n`resetall\n\n\n\n\nmodule ssio_sdr_in #\n(\n    parameter TARGET = \"GENERIC\",\n    parameter CLOCK_INPUT_STYLE = \"BUFIO2\",\n    parameter WIDTH = 1\n)\n(\n    input  wire             input_clk,\n\n    input  wire [WIDTH-1:0] input_d,\n\n    output wire             output_clk,\n\n    output wire [WIDTH-1:0] output_q\n);\n\nwire clk_int;\nwire clk_io;\n\ngenerate\n\nif (TARGET == \"XILINX\") begin\n\n    if (CLOCK_INPUT_STYLE == \"BUFG\") begin\n\n        BUFG\n        clk_bufg (\n            .I(input_clk),\n            .O(clk_int)\n        );\n\n        assign clk_io = clk_int;\n        assign output_clk = clk_int;\n\n    end else if (CLOCK_INPUT_STYLE == \"BUFR\") begin\n\n        assign clk_int = input_clk;\n\n        BUFIO\n        clk_bufio (\n            .I(clk_int),\n            .O(clk_io)\n        );\n\n        BUFR #(\n            .BUFR_DIVIDE(\"BYPASS\")\n        )\n        clk_bufr (\n            .I(clk_int),\n            .O(output_clk),\n            .CE(1'b1),\n            .CLR(1'b0)\n        );\n        \n    end else if (CLOCK_INPUT_STYLE == \"BUFIO\") begin\n\n        assign clk_int = input_clk;\n\n        BUFIO\n        clk_bufio (\n            .I(clk_int),\n            .O(clk_io)\n        );\n\n        BUFG\n        clk_bufg (\n            .I(clk_int),\n            .O(output_clk)\n        );\n\n    end else if (CLOCK_INPUT_STYLE == \"BUFIO2\") begin\n\n        BUFIO2 #(\n            .DIVIDE(1),\n            .DIVIDE_BYPASS(\"TRUE\"),\n            .I_INVERT(\"FALSE\"),\n            .USE_DOUBLER(\"FALSE\")\n        )\n        clk_bufio (\n            .I(input_clk),\n            .DIVCLK(clk_int),\n            .IOCLK(clk_io),\n            .SERDESSTROBE()\n        );\n\n        BUFG\n        clk_bufg (\n            .I(clk_int),\n            .O(output_clk)\n        );\n\n    end\n\nend else begin\n\n    assign clk_io = input_clk;\n\n    assign clk_int = input_clk;\n    assign output_clk = clk_int;\n\nend\n\nendgenerate\n\n\nreg [WIDTH-1:0] output_q_reg = {WIDTH{1'b0}};\n\nassign output_q = output_q_reg;\n\nalways @(posedge clk_io) begin\n    output_q_reg <= input_d;\nend\n\nendmodule\n\n`resetall\n",
        "module_name": "ssio_sdr_in #",
        "module_hash": "c9e92adc13d8680a07b516e937f98ac6",
        "dataset_index": 23565
      },
      "adder_4bit_6aeaa239": {
        "rtl_code": "module adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C_out\n);\n\n    wire [3:0] C;\n\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(1'b0),\n        .S(S[0]),\n        .C_out(C[0])\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C[0]),\n        .S(S[1]),\n        .C_out(C[1])\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(C[1]),\n        .S(S[2]),\n        .C_out(C[2])\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(C[2]),\n        .S(S[3]),\n        .C_out(C_out)\n    );\n\nendmodule\n\nmodule full_adder(\n    input A,\n    input B,\n    input C_in,\n    output S,\n    output C_out\n);\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "6aeaa239f764d14cd8798d1645eb1257",
        "dataset_index": 1417
      },
      "des_sbox3_a5e63ce0": {
        "rtl_code": "\n\n\n\n\nmodule des_sbox3\n\t(\n\tinput  wire [0:5] right_xor_key_segment_din,\n\toutput reg  [0:3] sbox_dout\n\t);\n\n\n\talways @(*)\n\t\tcase ({right_xor_key_segment_din[0], right_xor_key_segment_din[5]})\n\t\t\t2'b00:\t\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd1;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd12;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd7;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd11;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd2;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd8;\n\t\t\t\t\tendcase\n\n\t\t\t2'b01:\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd7;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd2;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd8;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd12;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd11;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd1;\n\t\t\t\t\tendcase\n\n\t\t\t2'b10:\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd8;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd11;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd1;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd2;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd12;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd7;\n\t\t\t\t\tendcase\n\n\t\t\t2'b11:\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd1;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd8;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd7;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd11;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd2;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd12;\n\t\t\t\t\tendcase\n\t\tendcase endmodule\n\n",
        "module_name": "des_sbox3",
        "module_hash": "a5e63ce043f4be0f6abeb2b1d09d1d09",
        "dataset_index": 22247
      },
      "sky130_fd_sc_hd__o31a_6d38034e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__o31a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1, A3     );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__o31a",
        "module_hash": "6d38034e8686155ae0330dbc52bc8b54",
        "dataset_index": 8224
      },
      "boolean_func_4db9e93e": {
        "rtl_code": "module boolean_func(\n    input wire A1,\n    input wire A2,\n    input wire B1,\n    input wire B2,\n    input wire VPWR,\n    input wire VGND,\n    input wire VPB,\n    input wire VNB,\n    output wire X\n);\n\n    assign X = (A1 & A2) | (B1 & B2 & VPWR & VGND & VPB & VNB);\n\nendmodule",
        "module_name": "boolean_func",
        "module_hash": "4db9e93e23b839bbe20b0e94a6601319",
        "dataset_index": 16308
      },
      "Broadcast_filter_ea5c06d9": {
        "rtl_code": "module Broadcast_filter (    \nReset                   ,\nClk                     ,\nbroadcast_ptr           ,\nbroadcast_drop          ,\nbroadcast_filter_en     ,\nbroadcast_bucket_depth    ,\nbroadcast_bucket_interval \n);\ninput           Reset                       ;\ninput           Clk                         ;\n                input           broadcast_ptr               ;\noutput          broadcast_drop              ;\n                input           broadcast_filter_en         ;\ninput   [15:0]  broadcast_bucket_depth      ;\ninput   [15:0]  broadcast_bucket_interval   ;\n\nreg     [15:0]  time_counter            ;\nreg     [15:0]  broadcast_counter        ;\nreg             broadcast_drop          ;\nalways @ (posedge Clk or posedge Reset)\n    if (Reset)\n        time_counter    <=0;\n    else if (time_counter==broadcast_bucket_interval)\n        time_counter    <=0;\n    else\n        time_counter    <=time_counter+1;\n\nalways @ (posedge Clk or posedge Reset)\n    if (Reset)\n        broadcast_counter   <=0;\n    else if (time_counter==broadcast_bucket_interval)\n        broadcast_counter   <=0;\n    else if (broadcast_ptr&&broadcast_counter!=broadcast_bucket_depth)\n        broadcast_counter   <=broadcast_counter+1;\n                \nalways @ (posedge Clk or posedge Reset)\n    if (Reset)\n        broadcast_drop      <=0;\n    else if(broadcast_filter_en&&broadcast_counter==broadcast_bucket_depth)\n        broadcast_drop      <=1;\n    else\n        broadcast_drop      <=0;\n\nendmodule",
        "module_name": "Broadcast_filter",
        "module_hash": "ea5c06d9e026d8a1c4c1b189ceb82dcc",
        "dataset_index": 22781
      },
      "latch_MEM_WB_6dd42ef4": {
        "rtl_code": "\nmodule latch_MEM_WB\n\t#(\n\tparameter B=32, W=5\n\t)\n\t(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire ena,\n\t\n\tinput wire [B-1:0] read_data_in,\n\tinput wire [B-1:0] alu_result_in,\n\tinput wire [W-1:0] mux_RegDst_in,\n\t\n\toutput wire [B-1:0] read_data_out,\n\toutput wire [B-1:0] alu_result_out,\n\toutput wire [W-1:0] mux_RegDst_out,\n\t\n\tinput wire wb_RegWrite_in,\n\tinput wire wb_MemtoReg_in,\n\t\n\toutput wire wb_RegWrite_out,\n\toutput wire wb_MemtoReg_out\n\n   );\n\t\n\treg [B-1:0]read_data_reg;\n\treg [B-1:0]alu_result_reg;\n\treg [W-1:0]mux_RegDst_reg;\n\t\n\treg wb_RegWrite_reg;\n\treg wb_MemtoReg_reg;\n\n\talways @(posedge clk)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tread_data_reg <= 0;\n\t\t\talu_result_reg <= 0;\n\t\t\tmux_RegDst_reg <= 0;\n\t\t\twb_RegWrite_reg <= 0;\n\t\t\twb_MemtoReg_reg <= 0;\n\t\tend\n\t\telse\n\t\t\tif(ena==1'b1)\n\t\t\tbegin\n\t\t\t\t\n\t\t\t\tread_data_reg <= read_data_in;\n\t\t\t\talu_result_reg <= alu_result_in;\n\t\t\t\tmux_RegDst_reg <= mux_RegDst_in;\n\t\t\t\t\n\t\t\t\twb_RegWrite_reg <= wb_RegWrite_in;\n\t\t\t\twb_MemtoReg_reg <= wb_MemtoReg_in;\n\t\t\tend\n\tend\n\t\t\n\tassign read_data_out = read_data_reg;\n\tassign alu_result_out = alu_result_reg;\n\tassign mux_RegDst_out = mux_RegDst_reg;\n\t\n\tassign wb_RegWrite_out = wb_RegWrite_reg;\n\tassign wb_MemtoReg_out = wb_MemtoReg_reg;\nendmodule\n",
        "module_name": "latch_MEM_WB",
        "module_hash": "6dd42ef45476c138e54f599c46e763a2",
        "dataset_index": 20474
      },
      "seven_to_one_178162d7": {
        "rtl_code": "module seven_to_one (\n    in0,\n    in1,\n    in2,\n    in3,\n    in4,\n    in5,\n    in6,\n    out\n);\n\n    // Module ports\n    input  in0;\n    input  in1;\n    input  in2;\n    input  in3;\n    input  in4;\n    input  in5;\n    input  in6;\n    output out;\n\n    // Local signals\n    wire or0_out;\n    wire or1_out;\n    wire or2_out;\n    wire or3_out;\n    wire or4_out;\n    wire or5_out;\n\n    //                           Name          Output              Other arguments\n    or                           or0          (or0_out           , in0, in1                 );\n    or                           or1          (or1_out           , or0_out, in2            );\n    or                           or2          (or2_out           , or1_out, in3            );\n    or                           or3          (or3_out           , or2_out, in4            );\n    or                           or4          (or4_out           , or3_out, in5            );\n    or                           or5          (or5_out           , or4_out, in6            );\n    buf                          buf0         (out               , or5_out                 );\n\nendmodule",
        "module_name": "seven_to_one",
        "module_hash": "178162d7d2329b4f6b241a3438ca18c6",
        "dataset_index": 21433
      },
      "top__8d22aa83": {
        "rtl_code": "module top_module (\n    input [3:0] in0,\n    input [3:0] in1,\n    input enable,\n    output reg [7:0] out\n);\n\n    wire [3:0] cmp_out;\n    wire [7:0] dec_out;\n    \n    comparator cmp(.in0(in0), .in1(in1), .out(cmp_out));\n    decoder dec(.in(cmp_out), .enable(enable), .out(dec_out));\n    \n    always @(*) begin\n        if (cmp_out == 4'b0000) // in0 = in1\n            out = dec_out[0];\n        else if (cmp_out > 4'b0000) // in0 > in1\n            out = dec_out[1];\n        else // in0 < in1\n            out = dec_out[2];\n    end\n    \nendmodule\n\nmodule comparator (\n    input [3:0] in0,\n    input [3:0] in1,\n    output reg [3:0] out\n);\n    \n    always @(*) begin\n        if (in0 == in1)\n            out = 4'b0000;\n        else if (in0 > in1)\n            out = 4'b0001;\n        else\n            out = 4'b0010;\n    end\n    \nendmodule\n\nmodule decoder (\n    input [3:0] in,\n    input enable,\n    output reg [7:0] out\n);\n    \n    always @(*) begin\n        case (in)\n            4'b0000: out = 8'b00000001;\n            4'b0001: out = 8'b00000010;\n            4'b0010: out = 8'b00000100;\n            4'b0011: out = 8'b00001000;\n            4'b0100: out = 8'b00010000;\n            4'b0101: out = 8'b00100000;\n            4'b0110: out = 8'b01000000;\n            4'b0111: out = 8'b10000000;\n            default: out = 8'b00000000;\n        endcase\n        \n        if (!enable)\n            out = 8'b00000000;\n    end\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "8d22aa83eb8dd70f65e55e00b647b411",
        "dataset_index": 7431
      },
      "dffrl_7459c7cf": {
        "rtl_code": "module dffrl (din, clk, rst_l, q, se, si, so);\n\nparameter SIZE = 1;\n\ninput\t[SIZE-1:0]\tdin ;\t// data in\ninput\t\t\tclk ;\t// clk or scan clk\ninput\t\t\trst_l ;\t// reset\n\noutput\t[SIZE-1:0]\tq ;\t// output\n\ninput\t\t\tse ;\t// scan-enable\ninput\t[SIZE-1:0]\tsi ;\t// scan-input\noutput\t[SIZE-1:0]\tso ;\t// scan-output\n\nreg \t[SIZE-1:0]\tq ;\n\nalways @ (posedge clk) begin\n    if (rst_l == 1'b0) begin\n        q <= {SIZE{1'b0}};\n    end else begin\n        q <= (se == 1'b1) ? si : din;\n    end\nend\n\nassign so = q;\n\nendmodule",
        "module_name": "dffrl",
        "module_hash": "7459c7cfbb30710153f454c29d4d5ab1",
        "dataset_index": 1116
      },
      "speaker_iface_4f23fe02": {
        "rtl_code": "\n\n\nmodule speaker_iface\n  (\n    input                     clk_i, \n    input                     rst_i, \n    input      signed [15:0]  datal_i,\n    input      signed [15:0]  datar_i,\n    output reg signed [15:0]  datal_o,\n    output reg signed [15:0]  datar_o,\n\n    output reg                ready_o,\ninput                     aud_bclk_i,\n    input                     aud_daclrck_i,\n    output reg                aud_dacdat_o,\n    input                     aud_adcdat_i\n  );\n\n  reg fBCLK_HL;\nreg bCurrentClk;\n  reg bFilterClk1;\n  reg bFilterClk2;\n\n  reg bDACLRCK_old;\n  reg bDACLRCK;\n\n  reg [15:0] rDAC;\n  reg [15:0] rADC;\n\n  reg fADCReady;\n\n  always @(posedge clk_i or posedge rst_i)\n  begin\n    if (rst_i)\n    begin\n      fBCLK_HL <= 1'b0;\nbCurrentClk <= 1'b0;\n      bFilterClk1 <= 1'b0;\n      bFilterClk2 <= 1'b0;\n    end\n    else\n    begin\n      bFilterClk1 <= aud_bclk_i;\n      bFilterClk2 <= bFilterClk1;\n      if ((bFilterClk1 == bFilterClk2) && (bCurrentClk != bFilterClk2))\n      begin\n        bCurrentClk <= bFilterClk2;\n        if (bCurrentClk == 1'b1)\n          fBCLK_HL <= 1'b1;  end\n      if (fBCLK_HL)\n        fBCLK_HL <= 1'b0; end\n  end  \n\n  always @(posedge clk_i)\n    bDACLRCK <= aud_daclrck_i;\n\n  always @(posedge clk_i)\n  begin\n    if (fBCLK_HL)\n    begin\n      bDACLRCK_old <= bDACLRCK;\n      if (bDACLRCK != bDACLRCK_old)\n      begin\n        rDAC <= (bDACLRCK) ? datar_i : datal_i;\n        aud_dacdat_o <= 1'b0;\n        if (bDACLRCK)\n          datal_o <= rADC;\n        else\n          datar_o <= rADC;\n        rADC <= 16'h0001;\n        fADCReady <= 1'b0;\n        ready_o <= ~bDACLRCK;\n      end\n      else\n      begin\n        { aud_dacdat_o, rDAC } <= { rDAC, 1'b0 };\n        if (!fADCReady)\n          { fADCReady, rADC} <= { rADC, aud_adcdat_i };\n      end\n    end\n    else if (ready_o)\n      ready_o <= 1'b0; end\n\nendmodule",
        "module_name": "speaker_iface",
        "module_hash": "4f23fe027ab6f9d11dde617cb1102212",
        "dataset_index": 25249
      },
      "binary_counter #_cb51d5c0": {
        "rtl_code": "module binary_counter #(\n    parameter n = 4 // Change to desired number of bits\n)(\n    input clk,\n    input reset,\n    input enable,\n    output reg [n-1:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 0;\n    end else if (enable) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter #",
        "module_hash": "cb51d5c07b4a28747a7876cab2a58658",
        "dataset_index": 12336
      },
      "binary_adder_516c769c": {
        "rtl_code": "module binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input carry_in,\n    output [3:0] S,\n    output carry_out\n);\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    // Full adder for each bit position\n    full_adder fa0(\n        .a(A[0]),\n        .b(B[0]),\n        .carry_in(carry_in),\n        .sum(sum[0]),\n        .carry_out(carry[0])\n    );\n    full_adder fa1(\n        .a(A[1]),\n        .b(B[1]),\n        .carry_in(carry[0]),\n        .sum(sum[1]),\n        .carry_out(carry[1])\n    );\n    full_adder fa2(\n        .a(A[2]),\n        .b(B[2]),\n        .carry_in(carry[1]),\n        .sum(sum[2]),\n        .carry_out(carry[2])\n    );\n    full_adder fa3(\n        .a(A[3]),\n        .b(B[3]),\n        .carry_in(carry[2]),\n        .sum(sum[3]),\n        .carry_out(carry_out)\n    );\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input carry_in,\n    output sum,\n    output carry_out\n);\n\n    assign {carry_out, sum} = a + b + carry_in;\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "516c769cbf084e11ea6b58409b72fe31",
        "dataset_index": 15549
      },
      "decoder_4_to_16_5e09e683": {
        "rtl_code": "module decoder_4_to_16 (\n    input [1:0] AB,\n    output reg [15:0] Y\n);\n\n    always @(*) begin\n        case (AB)\n            2'b00: Y = 16'b0000000000000001;\n            2'b01: Y = 16'b0000000000000010;\n            2'b10: Y = 16'b0000000000000100;\n            2'b11: Y = 16'b0000000000001000;\n        endcase\n    end\n\nendmodule",
        "module_name": "decoder_4_to_16",
        "module_hash": "5e09e6831ad47caae1519fa0409bec0e",
        "dataset_index": 3033
      },
      "DEMUX #_0c39a7b6": {
        "rtl_code": "\nmodule DEMUX #(\n  parameter n = 2\n)(\n  input in,\n  input [n-1:0] ctrl,\n  output reg [2**n-1:0] out\n);\n\nwire [2**n-1:0] mux_out;\n\nassign mux_out[0] = in; // default output\n\n// decode control signal and route input signal to appropriate output\ngenvar i;\ngenerate\n  for (i = 0; i < 2**n; i = i + 1) begin : mux_gen\n    always @(*) begin\n      if (ctrl == i) out[i] <= in;\n      else out[i] <= 1'b0;\n    end\n  end\nendgenerate\n\nendmodule",
        "module_name": "DEMUX #",
        "module_hash": "0c39a7b68391512a42a51388c4ca3c16",
        "dataset_index": 16576
      },
      "mux4to1_bc6e2342": {
        "rtl_code": "module mux4to1 (\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\nalways @*\nbegin\n    case(sel)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = in2;\n        2'b11: out = in3;\n    endcase\nend\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "bc6e23423ebf0fe4840eb1f75306a729",
        "dataset_index": 6977
      },
      "timer_module_536b55ae": {
        "rtl_code": "module timer_module\n(\n  input   clk,            // clock\n  input   wr,            // write enable\n  input   reset,           // reset\n  input   tlo,          // timer low byte select\n  input   thi,           // timer high byte select\n  input   tcr,          // timer control register\n  input   [7:0] data_in,      // bus data in\n  input   count_en,        // enable or disable the timer count\n  input   [15:0] load_val,    // initial value of the timer counter\n  output  [7:0] data_out,      // bus data out\n  output  tmra_ovf,        // timer A underflow\n  output  spmode,          // serial port mode\n  output  irq,            // interrupt out\n  output  [15:0] count_val    // current count value\n);\n\nreg    [15:0] tmr;        // timer\nreg    [7:0] tmlh;        // timer latch high byte\nreg    [7:0] tmll;        // timer latch low byte\nreg    [6:0] tmcr;        // timer control register\nreg    forceload;        // force load strobe\nwire   oneshot;        // oneshot mode\nwire   start;          // timer start (enable)\nreg    thi_load;          // load tmr after writing thi in one-shot mode\nwire   reload;          // reload timer counter\nwire   zero;          // timer counter is zero\nwire   underflow;        // timer is going to underflow\nwire   count;          // count enable signal\n\n// count enable signal\nassign count = count_en;\n\n// writing timer control register\nalways @(posedge clk)\n  if (reset)  // synchronous reset\n    tmcr[6:0] <= 7'd0;\n  else if (tcr && wr)  // load control register, bit 4(strobe) is always 0\n    tmcr[6:0] <= {data_in[6:5],1'b0,data_in[3:0]};\n  else if (thi_load && oneshot)  // start timer if thi is written in one-shot mode\n    tmcr[0] <= 1'd1;\n  else if (underflow && oneshot) // stop timer in one-shot mode\n    tmcr[0] <= 1'd0;\n\nalways @(posedge clk)\n  forceload <= tcr & wr & data_in[4];  // force load strobe\n\nassign oneshot = tmcr[3];    // oneshot alias\nassign start = tmcr[0];      // start alias\nassign spmode = tmcr[6];    // serial port mode (0-input, 1-output)\n\n// timer A latches for high and low byte\nalways @(posedge clk)\n  if (reset)\n    tmll[7:0] <= 8'b1111_1111;\n  else if (tlo && wr)\n    tmll[7:0] <= data_in[7:0];\n\nalways @(posedge clk)\n  if (reset)\n    tmlh[7:0] <= 8'b1111_1111;\n  else if (thi && wr)\n    tmlh[7:0] <= data_in[7:0];\n\n// thi is written in one-shot mode so tmr must be reloaded\nalways @(posedge clk)\n  thi_load <= thi & wr & (~start | oneshot);\n\n// timer counter reload signal\nassign reload = thi_load | forceload | underflow;\n\n// timer counter\nalways @(posedge clk)\n  if (reset)\n    tmr[15:0] <= 16'hFF_FF;\n  else if (reload)\n    tmr[15:0] <= load_val[15:0];\n  else if (start && count)\n    tmr[15:0] <= tmr[15:0] - 16'd1;\n\n// timer counter equals zero\nassign zero = ~|tmr;\n\n// timer counter is going to underflow\nassign underflow = zero & start & count;\n\n// Timer A underflow signal for Timer B\nassign tmra_ovf = underflow;\n\n// timer underflow interrupt request\nassign irq = underflow;\n\n// data output\nassign data_out[7:0] = ({8{~wr&tlo}} & tmr[7:0])\n          | ({8{~wr&thi}} & tmr[15:8])\n          | ({8{~wr&tcr}} & {1'b0,tmcr[6:0]});\n\n// current count value\nassign count_val = tmr;\n\nendmodule",
        "module_name": "timer_module",
        "module_hash": "536b55ae047acccf2c619bbb64b5488d",
        "dataset_index": 1122
      },
      "sky130_fd_sc_hs__o22ai_90646150": {
        "rtl_code": "module sky130_fd_sc_hs__o22ai (\n    input  A1,\n    input  A2,\n    input  B1,\n    input  B2,\n    output Y\n);\n\n    wire and1_out, and2_out, or_out;\n\n    // AND gate for A1 and A2 are high\n    assign and1_out = A1 & A2;\n\n    // AND gate for A1 and A2 are low\n    assign and2_out = ~A1 & ~A2;\n\n    // OR gate for the output of the two AND gates\n    assign or_out = and1_out | and2_out;\n\n    // Multiplexer to select between B1 and B2 based on the output of the OR gate\n    assign Y = or_out ? B1 : B2;\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__o22ai",
        "module_hash": "906461502ae23a5528f896a80bf72f5e",
        "dataset_index": 12594
      },
      "binary_up_counter_afa979bc": {
        "rtl_code": "module binary_up_counter (\n  input clk,\n  output reg [3:0] out\n);\n\nparameter n = 4; // number of bits in the counter\n\nreg [3:0] count;\n\nalways @(posedge clk) begin\n  if (count == (2**n)-1) begin\n    count <= 0;\n  end else begin\n    count <= count + 1;\n  end\nend\n\nalways @* begin\n  out = count;\nend\n\nendmodule",
        "module_name": "binary_up_counter",
        "module_hash": "afa979bc11d436d1e2b74efd155b5d0a",
        "dataset_index": 12587
      },
      "adder_tree_top_c29e9e1c": {
        "rtl_code": "`define ADDER_WIDTH 014\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "c29e9e1c618bcb3417c72bc0f33c3d3c",
        "dataset_index": 24599
      },
      "asynch_reset_set_reg_81e1d894": {
        "rtl_code": "\nmodule asynch_reset_set_reg (\n  input D,\n  input S,\n  input R,\n  input CLK,\n  output Q,\n  output QN\n);\n\nreg Q;\n\nalways @(posedge CLK) begin\n  if (!R) begin\n    Q <= 1'b0;\n  end else if (!S) begin\n    Q <= 1'b1;\n  end else begin\n    Q <= D;\n  end\nend\n\nassign QN = ~Q;\n\nendmodule",
        "module_name": "asynch_reset_set_reg",
        "module_hash": "81e1d89455cec293a701e84082cfe8f8",
        "dataset_index": 474
      },
      "and4_dac4429b": {
        "rtl_code": "module and4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign X = A & B & C & D;\n\nendmodule",
        "module_name": "and4",
        "module_hash": "dac4429b1e7527c3c99ba8cc82df6af0",
        "dataset_index": 7671
      },
      "add_sub_shift_1116b51b": {
        "rtl_code": "\nmodule add_sub_shift (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [15:0] A,         // 16-bit input A\n    input [15:0] B,         // 16-bit input B\n    input C,                // Control input for add/subtract operation\n    output [15:0] Q,        // 16-bit output Q\n    input shift,            // Shift input of the shift register\n    input load,             // Load input of the shift register\n    input [3:0] data_in,    // Data input of the shift register\n    output [3:0] out        // Output of the shift register\n);\n\n// Adder/Subtractor module\nreg [15:0] sum;\nalways @(posedge clk) begin\n    if (reset) begin\n        sum <= 0;\n    end else begin\n        if (C) begin\n            sum <= A - B;\n        end else begin\n            sum <= A + B;\n        end\n    end\nend\nassign Q = sum;\n\n// Shift register module\nreg [3:0] shift_reg;\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 0;\n    end else begin\n        if (load) begin\n            shift_reg <= data_in;\n        end else if (shift) begin\n            shift_reg <= {shift_reg[2:0], 1'b0};\n        end\n    end\nend\nassign out = shift_reg;\n\n// Functional module\nreg [3:0] and_result;\nalways @(posedge clk) begin\n    if (reset) begin\n        and_result <= 0;\n    end else begin\n        and_result <= sum[3:0] & out;\n    end\nend\n\nendmodule\n\nmodule top (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [15:0] A,         // 16-bit input A\n    input [15:0] B,         // 16-bit input B\n    input C,                // Control input for add/subtract operation\n    output [15:0] Q,        // 16-bit output Q\n    input shift,            // Shift input of the shift register\n    input load,             // Load input of the shift register\n    input [3:0] data_in,    // Data input of the shift register\n    output [3:0] out        // Output of the shift register\n);\n\n// Instantiate the add_sub_shift module\nadd_sub_shift add_sub_shift_inst (\n    .clk(clk),\n    .reset(reset),\n    .A(A),\n    .B(B),\n    .C(C),\n    .Q(Q),\n    .shift(shift),\n    .load(load),\n    .data_in(data_in),\n    .out(out)\n);\n\nendmodule\n",
        "module_name": "add_sub_shift",
        "module_hash": "1116b51b78e3cd204368a720fdb8b39e",
        "dataset_index": 7853
      },
      "GrayCounter_3d9b6b05": {
        "rtl_code": "\n\nmodule GrayCounter\n   #(parameter   COUNTER_WIDTH = 4)\n   \n    (output reg  [COUNTER_WIDTH-1:0]    gray_count_out,  input wire                         en,  input wire                         rst,   input wire                         clk);\n\n    reg    [COUNTER_WIDTH-1:0]         binary_count;\n\n    always @ (posedge clk)\n        if (rst) begin\n            binary_count   <= {COUNTER_WIDTH{1'b 0}} + 1;  gray_count_out <= {COUNTER_WIDTH{1'b 0}};      end\n        else if (en) begin\n            binary_count   <= binary_count + 1;\n            gray_count_out <= {binary_count[COUNTER_WIDTH-1],\n                              binary_count[COUNTER_WIDTH-2:0] ^ binary_count[COUNTER_WIDTH-1:1]};\n        end\n    \nendmodule\n",
        "module_name": "GrayCounter",
        "module_hash": "3d9b6b058fdf735e5d89dc38da85c19f",
        "dataset_index": 20789
      },
      "arbiter_2_masters_fc0b0fe4": {
        "rtl_code": "module arbiter_2_masters (\n  input           clk,\n  input           rst,\n\n  input           i_m0_we,\n  input           i_m0_cyc,\n  input           i_m0_stb,\n  input   [3:0]   i_m0_sel,\n  output          o_m0_ack,\n  input   [31:0]  i_m0_dat,\n  output  [31:0]  o_m0_dat,\n  input   [31:0]  i_m0_adr,\n  output          o_m0_int,\n\n  input           i_m1_we,\n  input           i_m1_cyc,\n  input           i_m1_stb,\n  input   [3:0]   i_m1_sel,\n  output          o_m1_ack,\n  input   [31:0]  i_m1_dat,\n  output  [31:0]  o_m1_dat,\n  input   [31:0]  i_m1_adr,\n  output          o_m1_int,\n\n\n  output          o_s_we,\n  output          o_s_stb,\n  output          o_s_cyc,\n  output  [3:0]   o_s_sel,\n  output  [31:0]  o_s_adr,\n  output  [31:0]  o_s_dat,\n  input   [31:0]  i_s_dat,\n  input           i_s_ack,\n  input           i_s_int\n);\n\nlocalparam        MASTER_COUNT = 2;\n\nreg [7:0]         master_select;\nreg [7:0]         priority_select;\n\n\nwire              o_master_we  [MASTER_COUNT - 1:0];\nwire              o_master_stb [MASTER_COUNT - 1:0];\nwire              o_master_cyc [MASTER_COUNT - 1:0];\nwire  [3:0]       o_master_sel [MASTER_COUNT - 1:0];\nwire  [31:0]      o_master_adr [MASTER_COUNT - 1:0];\nwire  [31:0]      o_master_dat [MASTER_COUNT - 1:0];\n\n\nlocalparam        MASTER_NO_SEL   = 8'hFF;\nlocalparam        MASTER_0     = 0;\nlocalparam        MASTER_1     = 1;\n\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    master_select <= MASTER_NO_SEL;\n  end\n  else begin\n    case (master_select)\n      MASTER_0: begin\n        if (!i_m0_cyc && !i_s_ack) begin\n          master_select <= MASTER_NO_SEL;\n        end\n      end\n      MASTER_1: begin\n        if (!i_m1_cyc && !i_s_ack) begin\n          master_select <= MASTER_NO_SEL;\n        end\n      end\n      default: begin\n        if (i_m0_cyc) begin\n          master_select <= MASTER_0;\n        end\n        else if (i_m1_cyc) begin\n          master_select <= MASTER_1;\n        end\n      end\n    endcase\n    if ((master_select != MASTER_NO_SEL) && (priority_select < master_select) && (!o_s_stb && !i_s_ack))begin\n      master_select  <=  MASTER_NO_SEL;\n    end\n  end\nend\n\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    priority_select <= MASTER_NO_SEL;\n  end\n  else begin\n    if (i_m0_cyc) begin\n      priority_select  <= MASTER_0;\n    end\n    else if (i_m1_cyc) begin\n      priority_select  <= MASTER_1;\n    end\n    else begin\n      priority_select  <= MASTER_NO_SEL;\n    end\n  end\nend\n\nassign  o_s_we  = (master_select != MASTER_NO_SEL) ? o_master_we[master_select]  : 0;\nassign  o_s_stb = (master_select != MASTER_NO_SEL) ? o_master_stb[master_select] : 0;\nassign  o_s_cyc = (master_select != MASTER_NO_SEL) ? o_master_cyc[master_select] : 0;\nassign  o_s_sel = (master_select != MASTER_NO_SEL) ? o_master_sel[master_select] : 0;\nassign  o_s_adr = (master_select != MASTER_NO_SEL) ? o_master_adr[master_select] : 0;\nassign  o_s_dat = (master_select != MASTER_NO_SEL) ? o_master_dat[master_select] : 0;\n\nassign o_master_we[MASTER_0] = i_m0_we;\nassign o_master_we[MASTER_1] = i_m1_we;\n\nassign o_master_stb[MASTER_0] = i_m0_stb;\nassign o_master_stb[MASTER_1] = i_m1_stb;\n\nassign o_master_cyc[MASTER_0] = i_m0_cyc;\nassign o_master_cyc[MASTER_1] = i_m1_cyc;\n\nassign o_master_sel[MASTER_0] = i_m0_sel;\nassign o_master_sel[MASTER_1] = i_m1_sel;\n\nassign o_master_adr[MASTER_0] = i_m0_adr;\nassign o_master_adr[MASTER_1] = i_m1_adr;\n\nassign o_master_dat[MASTER_0] = i_m0_dat;\nassign o_master_dat[MASTER_1] = i_m1_dat;\n\n\nassign o_m0_ack = (master_select == MASTER_0) ? i_s_ack : 0;\nassign o_m0_dat = i_s_dat;\nassign o_m0_int = (master_select == MASTER_0) ? i_s_int : 0;\n\nassign o_m1_ack = (master_select == MASTER_1) ? i_s_ack : 0;\nassign o_m1_dat = i_s_dat;\nassign o_m1_int = (master_select == MASTER_1) ? i_s_int : 0;\n\n\n\nendmodule\n",
        "module_name": "arbiter_2_masters",
        "module_hash": "fc0b0fe4efb34cad72547fd8c16b3ece",
        "dataset_index": 25822
      },
      "bitwise_and_3c5a5d01": {
        "rtl_code": "module bitwise_and (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] Y\n);\n\n    // Declare Y as a register\n    reg [3:0] Y;\n\n    // Perform bitwise AND operation using for loop\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 4; i = i + 1) begin\n            Y[i] = A[i] & B[i];\n        end\n    end\n\nendmodule",
        "module_name": "bitwise_and",
        "module_hash": "3c5a5d01a2ca4bf0add59b073cc5b898",
        "dataset_index": 840
      },
      "output_generator_8b24106f": {
        "rtl_code": "\nmodule output_generator(\n  input [3:0] num1,\n  input [3:0] num2,\n  input [1:0] operation,\n  output [3:0] result\n);\n\n  reg [3:0] result_reg; // declare result as a register\n\n  always @(*) begin\n    case(operation)\n      2'b00: result_reg = num1 + num2; // addition\n      2'b01: result_reg = num1 - num2; // subtraction\n      2'b10: result_reg = num1 * num2; // multiplication\n      2'b11: result_reg = num1 / num2; // division\n      default: result_reg = 4'b0000; // default case\n    endcase\n  end\n\n  assign result = result_reg; // assign result to the output port\n\nendmodule\n",
        "module_name": "output_generator",
        "module_hash": "8b24106f1265fd2be07c6eb675db40d1",
        "dataset_index": 13981
      },
      "touch_sensor #_6e6daffc": {
        "rtl_code": "module touch_sensor #(\n  parameter n = 4, // number of touch sensor signals\n  parameter m = 2 // number of digital output signals\n) (\n  input [n-1:0] touch_sensors,\n  input clk,\n  output reg [m-1:0] digital_outputs\n);\n\n// Capacitive touch technology implementation\nreg [n-1:0] touch_sensors_prev;\nreg [m-1:0] digital_outputs_prev;\nreg [m-1:0] digital_outputs_curr;\n\nalways @(*) begin\n  digital_outputs_curr = {touch_sensors} ^ {touch_sensors_prev};\nend\n\nalways @(posedge clk) begin\n  touch_sensors_prev <= touch_sensors;\n  digital_outputs_prev <= digital_outputs_curr;\n  digital_outputs <= digital_outputs_curr;\nend\n\nendmodule",
        "module_name": "touch_sensor #",
        "module_hash": "6e6daffc9dcf9ed8d06abb0d6c8b4abe",
        "dataset_index": 6395
      },
      "sky130_fd_sc_ls__a2111o_6345ed9b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a2111o (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A1, A2              );\n    or  or0  (or0_out_X, C1, B1, and0_out, D1);\n    buf buf0 (X        , or0_out_X           );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a2111o",
        "module_hash": "6345ed9b49f948dab6c3e4408f0ee0fc",
        "dataset_index": 4703
      },
      "xor_gate_79e0cafd": {
        "rtl_code": "module xor_gate (\n    A,\n    B,\n    X\n);\n\n    // Module ports\n    input  A;\n    input  B;\n    output X;\n\n    // Local signals\n    wire xor_out;\n\n    //  Name  Output      Other arguments\n    xor xor0 (xor_out, A, B);\n\n    //  Name  Output      Other arguments\n    buf buf0 (X, xor_out);\n\nendmodule",
        "module_name": "xor_gate",
        "module_hash": "79e0cafd819b74fc4a440dfd61c4d157",
        "dataset_index": 9307
      },
      "synchronizer_ff #_b9362601": {
        "rtl_code": "\nmodule synchronizer_ff #(parameter N = 4)\n   (input [N-1:0] D,\n    output [N-1:0] Q,\n    input s_aclk,\n    input rd_rst_reg_reg);\n\n  wire [N-1:0] Q_reg;\n\n     reg [N-1:0] Q_reg_reg;\n\n  \n  assign Q = Q_reg_reg;\n\n  always@(posedge s_aclk ) begin\n    if(!rd_rst_reg_reg) begin\n       Q_reg_reg <= 'b0;\n    end\n    else begin\n       Q_reg_reg <= D;\n    end\n  end\nendmodule",
        "module_name": "synchronizer_ff #",
        "module_hash": "b936260144786db6f477d5ccb5f37eb9",
        "dataset_index": 2161
      },
      "sky130_fd_sc_lp__and3b_060de9d5": {
        "rtl_code": "module sky130_fd_sc_lp__and3b (\n    input  wire        A_N,\n    input  wire        B,\n    input  wire        C,\n    input  wire        VPWR,\n    input  wire        VGND,\n    input  wire        VPB,\n    input  wire        VNB,\n    output reg         X\n);\n\n    // AND gate implementation\n    always @(*) begin\n        if (A_N == 1'b1 && B == 1'b1 && C == 1'b1) begin\n            X <= 1'b1;\n        end\n        else begin\n            X <= 1'b0;\n        end\n    end\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__and3b",
        "module_hash": "060de9d5582dfd3de236d3653dc663a4",
        "dataset_index": 18826
      },
      "sky130_fd_sc_ms__a21boi_4_563d08bb": {
        "rtl_code": "\nmodule sky130_fd_sc_ms__a21boi_4 (\n    Y,\n    A1,\n    A2,\n    B1_N\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input B1_N;\n\n    assign Y = (A1 & A2) | (~B1_N);\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__a21boi_4",
        "module_hash": "563d08bb72f56eb9a270b2e5585138dd",
        "dataset_index": 20571
      },
      "dectohexstr8_8a97258b": {
        "rtl_code": "module dectohexstr8(\n    input [7:0] in,\n    output [15:0] out\n    );\n    wire[3:0] inlo;\n    wire[7:4] inhi;\n    assign inlo = in[3:0];\n    assign inhi = in[7:4];\n    \n    assign out[7:0] = (inlo == 4'd0) ? \"0\" :\n                      (inlo == 4'd1) ? \"1\" :\n                      (inlo == 4'd2) ? \"2\" :\n                      (inlo == 4'd3) ? \"3\" :\n                      (inlo == 4'd4) ? \"4\" :\n                      (inlo == 4'd5) ? \"5\" :\n                      (inlo == 4'd6) ? \"6\" :\n                      (inlo == 4'd7) ? \"7\" :\n                      (inlo == 4'd8) ? \"8\" :\n                      (inlo == 4'd9) ? \"9\" :\n                      (inlo == 4'd10) ? \"A\" :\n                      (inlo == 4'd11) ? \"B\" :\n                      (inlo == 4'd12) ? \"C\" :\n                      (inlo == 4'd13) ? \"D\" :\n                      (inlo == 4'd14) ? \"E\" : \"F\";\n\n    assign out[15:8]= (inhi == 4'd0) ? \"0\" :\n                      (inhi == 4'd1) ? \"1\" :\n                      (inhi == 4'd2) ? \"2\" :\n                      (inhi == 4'd3) ? \"3\" :\n                      (inhi == 4'd4) ? \"4\" :\n                      (inhi == 4'd5) ? \"5\" :\n                      (inhi == 4'd6) ? \"6\" :\n                      (inhi == 4'd7) ? \"7\" :\n                      (inhi == 4'd8) ? \"8\" :\n                      (inhi == 4'd9) ? \"9\" :\n                      (inhi == 4'd10) ? \"A\" :\n                      (inhi == 4'd11) ? \"B\" :\n                      (inhi == 4'd12) ? \"C\" :\n                      (inhi == 4'd13) ? \"D\" :\n                      (inhi == 4'd14) ? \"E\" : \"F\";\nendmodule",
        "module_name": "dectohexstr8",
        "module_hash": "8a97258b37f2ec7b2c7abf19b8e67d6e",
        "dataset_index": 6522
      },
      "RegisterAdd_4_b07ea74e": {
        "rtl_code": "module RegisterAdd_4(\n    input CLK,\n    input reset,\n    input [3:0] in1,\n    input [3:0] in2,\n    output reg [3:0] out\n);\n\n    always @(posedge CLK) begin\n        if (reset) begin\n            out <= 4'd0;\n        end else begin\n            out <= in1 + in2;\n        end\n    end\n\nendmodule",
        "module_name": "RegisterAdd_4",
        "module_hash": "b07ea74ed81c6291c3d437fc3d648deb",
        "dataset_index": 15548
      },
      "pipelined_edge_detect_cdcb1be3": {
        "rtl_code": "module pipelined_edge_detect(\n  input               clk,\n  input               rst_n,\n  input               a,\n  input               delay,\n  output reg          rise,\n  output reg          fall\n);\n\n  reg [1:0]           state;\n  reg                 a_delayed;\n  reg                 a_delayed2;\n\n  parameter           IDLE = 2'b00;\n  parameter           RISE_DETECT = 2'b01;\n  parameter           FALL_DETECT = 2'b10;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      state <= IDLE;\n      a_delayed <= 1'b0;\n      a_delayed2 <= 1'b0;\n      rise <= 1'b0;\n      fall <= 1'b0;\n    end\n    else begin\n      case (state)\n        IDLE: begin\n          a_delayed <= a;\n          a_delayed2 <= a_delayed;\n          if (a_delayed2 == 1'b0 && a_delayed == 1'b1) begin\n            rise <= 1'b1;\n            fall <= 1'b0;\n            state <= RISE_DETECT;\n          end\n          else if (a_delayed2 == 1'b1 && a_delayed == 1'b0) begin\n            rise <= 1'b0;\n            fall <= 1'b1;\n            state <= FALL_DETECT;\n          end\n          else begin\n            rise <= 1'b0;\n            fall <= 1'b0;\n            state <= IDLE;\n          end\n        end\n        RISE_DETECT: begin\n          a_delayed <= a;\n          a_delayed2 <= a_delayed;\n          if (a_delayed2 == 1'b1 && a_delayed == 1'b1) begin\n            rise <= 1'b0;\n            fall <= 1'b0;\n            state <= IDLE;\n          end\n          else if (a_delayed2 == 1'b0 && a_delayed == 1'b1) begin\n            rise <= 1'b1;\n            fall <= 1'b0;\n            state <= RISE_DETECT;\n          end\n          else begin\n            rise <= 1'b0;\n            fall <= 1'b0;\n            state <= IDLE;\n          end\n        end\n        FALL_DETECT: begin\n          a_delayed <= a;\n          a_delayed2 <= a_delayed;\n          if (a_delayed2 == 1'b0 && a_delayed == 1'b0) begin\n            rise <= 1'b0;\n            fall <= 1'b0;\n            state <= IDLE;\n          end\n          else if (a_delayed2 == 1'b1 && a_delayed == 1'b0) begin\n            rise <= 1'b0;\n            fall <= 1'b1;\n            state <= FALL_DETECT;\n          end\n          else begin\n            rise <= 1'b0;\n            fall <= 1'b0;\n            state <= IDLE;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "pipelined_edge_detect",
        "module_hash": "cdcb1be3256550743b41f0747e2ef170",
        "dataset_index": 12518
      },
      "complement_70064b5a": {
        "rtl_code": "module complement (\n    input D,\n    output reg Q,\n    input CLK\n);\n\n    reg reg1 = 0;\n    reg reg2 = 1;\n\n    always @(posedge CLK) begin\n        reg1 <= D;\n    end\n\n    always @(posedge CLK) begin\n        reg2 <= reg1;\n    end\n\n    always @(posedge CLK) begin\n        Q <= reg1;\n        reg2 <= ~reg2;\n    end\n\nendmodule",
        "module_name": "complement",
        "module_hash": "70064b5abfaea9b02d392b513633bd0b",
        "dataset_index": 9004
      },
      "accumulator #_4335ae5e": {
        "rtl_code": "module accumulator #(\n  parameter n = 4 // number of input signals\n)(\n  input [n-1:0] in,\n  output reg [n:0] out\n);\n\ninteger i;\n\nalways @(*) begin\n  out = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    out = out + in[i];\n  end\nend\n\nendmodule",
        "module_name": "accumulator #",
        "module_hash": "4335ae5e6b7dd32eb7ad3033898c6ccd",
        "dataset_index": 10721
      },
      "up_down_counter_3221362b": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input up_down,\n    input load_up,\n    input load_down,\n    input reset,\n    output reg [7:0] count\n);\n\nreg [3:0] up_count;\nreg [3:0] down_count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        up_count <= 4'b0000;\n        down_count <= 4'b1111;\n        count <= 8'b00000000;\n    end else begin\n        if (load_up) begin\n            up_count <= count[3:0];\n        end\n        if (load_down) begin\n            down_count <= count[3:0];\n        end\n        if (up_down) begin\n            if (up_count == 4'b1111) begin\n                up_count <= 4'b0000;\n            end else begin\n                up_count <= up_count + 1;\n            end\n        end else begin\n            if (down_count == 4'b0000) begin\n                down_count <= 4'b1111;\n            end else begin\n                down_count <= down_count - 1;\n            end\n        end\n        count <= up_count + down_count;\n    end\nend\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "3221362b221a31924a66bc386f325637",
        "dataset_index": 11146
      },
      "gen_test3_090887f4": {
        "rtl_code": "\nmodule gen_test3(a, b, sel, y, z);\n\ninput [3:0] a, b;\ninput sel;\noutput [3:0] y, z;\n\nassign y[1:0] = sel ? a[1:0] : b[1:0]; // Fix the part select indices\nassign z[1:0] = sel ? b[1:0] : a[1:0]; // Fix the part select indices\nassign y[2] = sel ? a[2] : b[2];\nassign z[2] = sel ? b[2] : a[2];\nassign y[3] = sel ? a[3] : b[3];\nassign z[3] = sel ? b[3] : a[3];\n\nendmodule\n",
        "module_name": "gen_test3",
        "module_hash": "090887f484d1f0f4852954d4b8ed06fe",
        "dataset_index": 20060
      },
      "full_adder_94ec17e7": {
        "rtl_code": "module full_adder(\n    input a,\n    input b,\n    input carry_in,\n    output sum,\n    output carry_out\n);\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (a & carry_in) | (b & carry_in);\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output [4:0] C\n);\n\n    wire [3:0] sum;\n    wire [4:0] carry;\n\n    full_adder fa0(\n        .a(A[0]),\n        .b(B[0]),\n        .carry_in(1'b0),\n        .sum(sum[0]),\n        .carry_out(carry[1])\n    );\n\n    full_adder fa1(\n        .a(A[1]),\n        .b(B[1]),\n        .carry_in(carry[1]),\n        .sum(sum[1]),\n        .carry_out(carry[2])\n    );\n\n    full_adder fa2(\n        .a(A[2]),\n        .b(B[2]),\n        .carry_in(carry[2]),\n        .sum(sum[2]),\n        .carry_out(carry[3])\n    );\n\n    full_adder fa3(\n        .a(A[3]),\n        .b(B[3]),\n        .carry_in(carry[3]),\n        .sum(sum[3]),\n        .carry_out(carry[4])\n    );\n\n    assign C = {carry[4], sum};\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "94ec17e7f3fdd9d76c06eea622c6151f",
        "dataset_index": 8738
      },
      "top__24d81c59": {
        "rtl_code": "module top_module (\n    input [15:0] A,\n    input [15:0] B,\n    input EN,\n    output reg [15:0] Y,\n    output overflow,\n    output reg [15:0] sum,\n    output [15:0] decoder_output\n);\n\n    wire [15:0] adder_out;\n    wire [3:0] decoder_sel;\n    wire decoder_en;\n\n    // Instantiate the 16-bit ripple carry adder module\n    ripple_carry_adder adder(\n        .A(A),\n        .B(B),\n        .Cin(1'b0),\n        .Sum(adder_out),\n        .Cout(overflow)\n    );\n\n    // Instantiate the 4-to-16 decoder module\n    decoder_4to16 decoder(\n        .A(decoder_sel),\n        .Y(decoder_output),\n        .EN(decoder_en)\n    );\n\n    // Assign decoder enable signal\n    assign decoder_en = EN;\n\n    // Assign decoder select signal based on adder output\n    assign decoder_sel = adder_out[15:12];\n\n    // Assign sum output\n    always @(*) begin\n        sum = adder_out;\n    end\n\n    // Assign Y output\n    always @(*) begin\n        Y = decoder_output;\n    end\n\nendmodule\n\n// 16-bit ripple carry adder module\nmodule ripple_carry_adder (\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output reg [15:0] Sum,\n    output reg Cout\n);\n\n    reg [16:0] temp;\n\n    always @(A or B or Cin) begin\n        temp = A + B + Cin;\n        Sum = temp[15:0];\n        Cout = temp[16];\n    end\n\nendmodule\n\n// 4-to-16 decoder module\nmodule decoder_4to16 (\n    input [3:0] A,\n    output reg [15:0] Y,\n    input EN\n);\n\n    always @(A or EN) begin\n        if (EN) begin\n            case (A)\n                4'b0000: Y = 16'b0000000000000001;\n                4'b0001: Y = 16'b0000000000000010;\n                4'b0010: Y = 16'b0000000000000100;\n                4'b0011: Y = 16'b0000000000001000;\n                4'b0100: Y = 16'b0000000000010000;\n                4'b0101: Y = 16'b0000000000100000;\n                4'b0110: Y = 16'b0000000001000000;\n                4'b0111: Y = 16'b0000000010000000;\n                4'b1000: Y = 16'b0000000100000000;\n                4'b1001: Y = 16'b0000001000000000;\n                4'b1010: Y = 16'b0000010000000000;\n                4'b1011: Y = 16'b0000100000000000;\n                4'b1100: Y = 16'b0001000000000000;\n                4'b1101: Y = 16'b0010000000000000;\n                4'b1110: Y = 16'b0100000000000000;\n                4'b1111: Y = 16'b1000000000000000;\n            endcase\n        end else begin\n            Y = 16'b0000000000000000;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "24d81c59c0ad955a0bea8c9f731b21f7",
        "dataset_index": 439
      },
      "sky130_fd_sc_lp__o41ai_1f5b887e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o41ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A4, A3, A2, A1 );\n    nand nand0 (nand0_out_Y, B1, or0_out    );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o41ai",
        "module_hash": "1f5b887eb8e2e8bd3661327c035af6af",
        "dataset_index": 23155
      },
      "nor4_gate_0280d592": {
        "rtl_code": "\nmodule nor4_gate(\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\n    nor (Y, A, B, C, D);\n\nendmodule\n",
        "module_name": "nor4_gate",
        "module_hash": "0280d592b73f906a75ba0bf2a3e5a2ef",
        "dataset_index": 15296
      },
      "fg_packet_gen #_e196f28a": {
        "rtl_code": "\n\n\nmodule fg_packet_gen #(\n    parameter DEST_WIDTH = 8,\n    parameter DATA_WIDTH = 64,\n    parameter KEEP_WIDTH = (DATA_WIDTH/8)\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    \n    input  wire                   input_bd_valid,\n    output wire                   input_bd_ready,\n    input  wire [DEST_WIDTH-1:0]  input_bd_dest,\n    input  wire [31:0]            input_bd_burst_len,\n\n    \n    output wire                   output_hdr_valid,\n    input  wire                   output_hdr_ready,\n    output wire [DEST_WIDTH-1:0]  output_hdr_dest,\n    output wire [15:0]            output_hdr_len,\n    output wire [DATA_WIDTH-1:0]  output_payload_tdata,\n    output wire [KEEP_WIDTH-1:0]  output_payload_tkeep,\n    output wire                   output_payload_tvalid,\n    input  wire                   output_payload_tready,\n    output wire                   output_payload_tlast,\n    output wire                   output_payload_tuser,\n\n    \n    output wire busy,\n\n    \n    input  wire [15:0] payload_mtu\n);\n\nlocalparam [1:0]\n    STATE_IDLE = 2'd0,\n    STATE_BURST = 2'd1,\n    STATE_FRAME = 2'd2;\n\nreg [1:0] state_reg = STATE_IDLE, state_next;\n\nreg [31:0] burst_len_reg = 0, burst_len_next;\nreg [15:0] frame_len_reg = 0, frame_len_next;\n\nreg input_bd_ready_reg = 0, input_bd_ready_next;\n\nreg output_hdr_valid_reg = 0, output_hdr_valid_next;\nreg [DEST_WIDTH-1:0] output_hdr_dest_reg = 0, output_hdr_dest_next;\nreg [15:0] output_hdr_len_reg = 0, output_hdr_len_next;\n\nreg busy_reg = 0;\n\nreg [DATA_WIDTH-1:0] output_payload_tdata_int;\nreg [KEEP_WIDTH-1:0] output_payload_tkeep_int;\nreg                  output_payload_tvalid_int;\nreg                  output_payload_tready_int = 0;\nreg                  output_payload_tlast_int;\nreg                  output_payload_tuser_int;\nwire                 output_payload_tready_int_early;\n\nassign input_bd_ready = input_bd_ready_reg;\n\nassign output_hdr_valid = output_hdr_valid_reg;\nassign output_hdr_dest = output_hdr_dest_reg;\nassign output_hdr_len = output_hdr_len_reg;\n\nassign busy = busy_reg;\n\nalways @* begin\n    state_next = 0;\n\n    burst_len_next = burst_len_reg;\n    frame_len_next = frame_len_reg;\n\n    input_bd_ready_next = 0;\n\n    output_hdr_valid_next = output_hdr_valid_reg & ~output_hdr_ready;\n    output_hdr_dest_next = output_hdr_dest_reg;\n    output_hdr_len_next = output_hdr_len_reg;\n\n    output_payload_tdata_int = 0;\n    output_payload_tkeep_int = 0;\n    output_payload_tvalid_int = 0;\n    output_payload_tlast_int = 0;\n    output_payload_tuser_int = 0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            input_bd_ready_next = 1;\n\n            if (input_bd_ready & input_bd_valid) begin\n                output_hdr_dest_next = input_bd_dest;\n                burst_len_next = input_bd_burst_len;\n\n                state_next = STATE_BURST;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_BURST: begin\n            if (~output_hdr_valid_reg) begin\n                if (burst_len_reg > payload_mtu) begin\n                    frame_len_next = payload_mtu;\n                    burst_len_next = burst_len_reg - payload_mtu;\n                    output_hdr_valid_next = 1;\n                    output_hdr_len_next = payload_mtu;\n                end else begin\n                    frame_len_next = burst_len_reg;\n                    burst_len_next = 0;\n                    output_hdr_valid_next = 1;\n                    output_hdr_len_next = burst_len_reg;\n                end\n\n                state_next = STATE_FRAME;\n            end else begin\n                state_next = STATE_BURST;\n            end\n        end\n        STATE_FRAME: begin\n            if (output_payload_tready_int) begin\n                if (frame_len_reg > KEEP_WIDTH) begin\n                    frame_len_next = frame_len_reg - KEEP_WIDTH;\n                    output_payload_tkeep_int = {KEEP_WIDTH{1'b1}};\n                    output_payload_tvalid_int = 1;\n                    state_next = STATE_FRAME;\n                end else begin\n                    frame_len_next = 0;\n                    output_payload_tkeep_int = {KEEP_WIDTH{1'b1}} >> (KEEP_WIDTH - frame_len_reg);\n                    output_payload_tvalid_int = 1;\n                    output_payload_tlast_int = 1;\n                    if (burst_len_reg > 0) begin\n                        state_next = STATE_BURST;\n                    end else begin\n                        state_next = STATE_IDLE;\n                    end\n                end\n            end else begin\n                state_next = STATE_FRAME;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        burst_len_reg <= 0;\n        frame_len_reg <= 0;\n        input_bd_ready_reg <= 0;\n        output_hdr_valid_reg <= 0;\n        output_hdr_dest_reg <= 0;\n        output_hdr_len_reg <= 0;\n        busy_reg <= 0;\n    end else begin\n        state_reg <= state_next;\n        burst_len_reg <= burst_len_next;\n        frame_len_reg <= frame_len_next;\n        input_bd_ready_reg <= input_bd_ready_next;\n        output_hdr_valid_reg <= output_hdr_valid_next;\n        output_hdr_dest_reg <= output_hdr_dest_next;\n        output_hdr_len_reg <= output_hdr_len_next;\n        busy_reg <= state_next != STATE_IDLE;\n    end\nend\n\nreg [DATA_WIDTH-1:0] output_payload_tdata_reg = 0;\nreg [KEEP_WIDTH-1:0] output_payload_tkeep_reg = 0;\nreg                  output_payload_tvalid_reg = 0;\nreg                  output_payload_tlast_reg = 0;\nreg                  output_payload_tuser_reg = 0;\n\nreg [DATA_WIDTH-1:0] temp_payload_tdata_reg = 0;\nreg [KEEP_WIDTH-1:0] temp_payload_tkeep_reg = 0;\nreg                  temp_payload_tvalid_reg = 0;\nreg                  temp_payload_tlast_reg = 0;\nreg                  temp_payload_tuser_reg = 0;\n\nassign output_payload_tdata = output_payload_tdata_reg;\nassign output_payload_tkeep = output_payload_tkeep_reg;\nassign output_payload_tvalid = output_payload_tvalid_reg;\nassign output_payload_tlast = output_payload_tlast_reg;\nassign output_payload_tuser = output_payload_tuser_reg;\n\nassign output_payload_tready_int_early = output_payload_tready | (~temp_payload_tvalid_reg & ~output_payload_tvalid_reg) | (~temp_payload_tvalid_reg & ~output_payload_tvalid_int);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        output_payload_tdata_reg <= 0;\n        output_payload_tkeep_reg <= 0;\n        output_payload_tvalid_reg <= 0;\n        output_payload_tlast_reg <= 0;\n        output_payload_tuser_reg <= 0;\n        output_payload_tready_int <= 0;\n        temp_payload_tdata_reg <= 0;\n        temp_payload_tkeep_reg <= 0;\n        temp_payload_tvalid_reg <= 0;\n        temp_payload_tlast_reg <= 0;\n        temp_payload_tuser_reg <= 0;\n    end else begin\n        output_payload_tready_int <= output_payload_tready_int_early;\n\n        if (output_payload_tready_int) begin\n            if (output_payload_tready | ~output_payload_tvalid_reg) begin\n                output_payload_tdata_reg <= output_payload_tdata_int;\n                output_payload_tkeep_reg <= output_payload_tkeep_int;\n                output_payload_tvalid_reg <= output_payload_tvalid_int;\n                output_payload_tlast_reg <= output_payload_tlast_int;\n                output_payload_tuser_reg <= output_payload_tuser_int;\n            end else begin\n                temp_payload_tdata_reg <= output_payload_tdata_int;\n                temp_payload_tkeep_reg <= output_payload_tkeep_int;\n                temp_payload_tvalid_reg <= output_payload_tvalid_int;\n                temp_payload_tlast_reg <= output_payload_tlast_int;\n                temp_payload_tuser_reg <= output_payload_tuser_int;\n            end\n        end else if (output_payload_tready) begin\n            output_payload_tdata_reg <= temp_payload_tdata_reg;\n            output_payload_tkeep_reg <= temp_payload_tkeep_reg;\n            output_payload_tvalid_reg <= temp_payload_tvalid_reg;\n            output_payload_tlast_reg <= temp_payload_tlast_reg;\n            output_payload_tuser_reg <= temp_payload_tuser_reg;\n            temp_payload_tdata_reg <= 0;\n            temp_payload_tkeep_reg <= 0;\n            temp_payload_tvalid_reg <= 0;\n            temp_payload_tlast_reg <= 0;\n            temp_payload_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "fg_packet_gen #",
        "module_hash": "e196f28a36585027aa3d38bfb53a9a51",
        "dataset_index": 14435
      },
      "MAIN_e6d04a1d": {
        "rtl_code": "\nmodule MAIN(Address, RW, CS, clk, Reset, AB, LED\n    );\n\tparameter SIZE = 5;\n\tparameter LEDSIZE = 8;\n\tinput clk, Reset;\n\tinput [SIZE-1:0] Address;\n\tinput RW, AB;\n\tinput [1:0] CS;\n\t\n\toutput reg [LEDSIZE-1:0] LED;\n\t\n\treg [31:0] W_Data;\n\twire [31:0] R_Data_A, R_Data_B, LED_Data; \n\n\tregister instance_name (\n    .clk(clk), \n    .Reset(Reset), \n    .R_Addr_A(Address), \n    .R_Addr_B(Address), \n    .W_Addr(Address), \n    .W_Data(W_Data), \n    .Write_Reg(RW), \n    .R_Data_A(R_Data_A), \n    .R_Data_B(R_Data_B)\n    );\n\t \n\tassign LED_Data = AB ? R_Data_A : R_Data_B;\n\talways @(*) \n\tbegin \n\t\tW_Data=32'h0000_0000;   \n\t\tLED=8'b0000_0000;   \n\t\tif(RW)    \n\t\tbegin  \n\t\t\tcase(CS) \n\t\t\t\t2'b00: W_Data= 32'h1234_5678; \n\t\t\t\t2'b01: W_Data= 32'h89AB_CDEF; \n\t\t\t\t2'b10: W_Data= 32'h7FFF_FFFF;  \n\t\t\t\t2'b11: W_Data= 32'hFFFF_FFFF;  \n\t\t\tendcase   \n\t\tend \n\t\telse    \n\t\tbegin  \n\t\t\tcase(CS) \n\t\t\t\t2'b00: LED=LED_Data[7:0];   \n\t\t\t\t2'b01: LED=LED_Data[15:8];    \n\t\t\t\t2'b10: LED=LED_Data[23:16]; \n\t\t\t\t2'b11: LED=LED_Data[31:24];   \n\t\t\tendcase \n\t\tend\n\tend\n\nendmodule\n\nmodule register(clk, Reset, R_Addr_A, R_Addr_B, W_Addr, W_Data, Write_Reg, R_Data_A, R_Data_B\n\t );\n\t input clk;\n\t input Reset;\n\t input Write_Reg;\n\t input [4:0] R_Addr_A, R_Addr_B, W_Addr;\n\t input [31:0] W_Data;\n\t \n\t output [31:0] R_Data_A;\n\t output [31:0] R_Data_B;\n\t \n\t reg [31:0] REGISTERS[31:0];\n\t \n\t integer i;\n\t assign R_Data_A = REGISTERS[R_Addr_A];\n\t assign R_Data_B = REGISTERS[R_Addr_B];\n\t always @(posedge clk)\n\t begin\n\t\tif(Reset)\n\t\t\tbegin\n\t\t\t\tfor(i=0; i<=31; i=i+1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tREGISTERS[i]<=32'h0000_0000;\n\t\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif(Write_Reg)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tREGISTERS[W_Addr]<=W_Data;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tREGISTERS[W_Addr]<=REGISTERS[W_Addr];\n\t\t\t\t\tend\n\t\t\tend\n\t end\nendmodule\n",
        "module_name": "MAIN",
        "module_hash": "e6d04a1d2d842f74cde98b6b3987fc17",
        "dataset_index": 22176
      },
      "hyperbolic_487b57a4": {
        "rtl_code": "\nmodule hyperbolic (\n  input x,\n  output sineh_out,\n  output cosh_out,\n  output tanh_out\n);\n\n  wire signed [31:0] exp_x;\n  wire signed [31:0] exp_neg_x;\n  wire signed [31:0] exp_x_plus_exp_neg_x;\n  wire signed [31:0] sineh;\n  wire signed [31:0] cosh;\n\n  assign exp_x = $signed({{20{1'b0}}, x});\n  assign exp_neg_x = $signed({{20{1'b0}}, -x});\n  assign exp_x_plus_exp_neg_x = exp_x + exp_neg_x;\n\n  assign sineh = exp_x - exp_neg_x;\n  assign cosh = exp_x_plus_exp_neg_x >> 1;\n\n  assign sineh_out = sineh >> 1;\n  assign cosh_out = cosh >> 1;\n  assign tanh_out = sineh / cosh;\n\nendmodule\n",
        "module_name": "hyperbolic",
        "module_hash": "487b57a49585012f3f95d2ef717346c8",
        "dataset_index": 14687
      },
      "adder_4bit_ad85d24a": {
        "rtl_code": "\nmodule adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [2:0] carry;\n\n    // First bit\n    assign sum[0] = a[0] ^ b[0];\n    assign carry[0] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n\n    // Second bit\n    assign sum[1] = a[1] ^ b[1] ^ carry[0];\n    assign carry[1] = (a[1] & b[1]) | ((a[1] | b[1]) & carry[0]);\n\n    // Third bit\n    assign sum[2] = a[2] ^ b[2] ^ carry[1];\n    assign carry[2] = (a[2] & b[2]) | ((a[2] | b[2]) & carry[1]);\n\n    // Fourth bit\n    assign sum[3] = a[3] ^ b[3] ^ carry[2];\n    assign cout = carry[2];\n\nendmodule\n",
        "module_name": "adder_4bit",
        "module_hash": "ad85d24aff5bec657eeeeca41043bcff",
        "dataset_index": 20278
      },
      "axi_basic_rx_null_gen #_df00fe1c": {
        "rtl_code": "\n\nmodule axi_basic_rx_null_gen # (\n  parameter C_DATA_WIDTH = 128,           parameter TCQ = 1,                      parameter KEEP_WIDTH = C_DATA_WIDTH / 8            ) (\n\n  input      [C_DATA_WIDTH-1:0] m_axis_rx_tdata,     input                         m_axis_rx_tvalid,    input                         m_axis_rx_tready,    input                         m_axis_rx_tlast,     input                  [21:0] m_axis_rx_tuser,     output                        null_rx_tvalid,      output                        null_rx_tlast,       output       [KEEP_WIDTH-1:0] null_rx_tkeep,       output                        null_rdst_rdy,       output reg              [4:0] null_is_eof,         input                         user_clk,            input                         user_rst             );\n\n\nlocalparam INTERFACE_WIDTH_DWORDS = (C_DATA_WIDTH == 128) ? 11'd4 :\n                                           (C_DATA_WIDTH == 64) ? 11'd2 : 11'd1;\n\nlocalparam            IDLE      = 0;\nlocalparam            IN_PACKET = 1;\nreg                   cur_state;\nreg                   next_state;\n\nreg            [11:0] reg_pkt_len_counter;\nreg            [11:0] pkt_len_counter;\nwire           [11:0] pkt_len_counter_dec;\nwire                  pkt_done;\n\nwire           [11:0] new_pkt_len;\nwire            [9:0] payload_len;\nwire            [1:0] packet_fmt;\nwire                  packet_td;\nreg             [3:0] packet_overhead;\n\nwire [KEEP_WIDTH-1:0] eof_tkeep;\nwire                  straddle_sof;\nwire                  eof;\n\n\nassign eof = m_axis_rx_tuser[21];\ngenerate\n  if(C_DATA_WIDTH == 128) begin : sof_eof_128\n    assign straddle_sof = (m_axis_rx_tuser[14:13] == 2'b11);\n  end\n  else begin : sof_eof_64_32\n    assign straddle_sof = 1'b0;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : len_calc_128\n    assign packet_fmt  = straddle_sof ?\n                                m_axis_rx_tdata[94:93] : m_axis_rx_tdata[30:29];\n    assign packet_td   = straddle_sof ?\n                                      m_axis_rx_tdata[79] : m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ?\n         (straddle_sof ? m_axis_rx_tdata[73:64] : m_axis_rx_tdata[9:0]) : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td, straddle_sof})\n        3'b0_0_0: packet_overhead = 4'd3 + 4'd0 - 4'd4;\n        3'b0_0_1: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        3'b0_1_0: packet_overhead = 4'd3 + 4'd1 - 4'd4;\n        3'b0_1_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        3'b1_0_0: packet_overhead = 4'd4 + 4'd0 - 4'd4;\n        3'b1_0_1: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        3'b1_1_0: packet_overhead = 4'd4 + 4'd1 - 4'd4;\n        3'b1_1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else if(C_DATA_WIDTH == 64) begin : len_calc_64\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else begin : len_calc_32\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd1;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd1;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd1;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd1;\n      endcase\n    end\n  end\nendgenerate\n\nassign new_pkt_len =\n         {{9{packet_overhead[3]}}, packet_overhead[2:0]} + {2'b0, payload_len};\n\n\nassign pkt_len_counter_dec = reg_pkt_len_counter - INTERFACE_WIDTH_DWORDS;\nassign pkt_done = (reg_pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\n\nalways @(*) begin\n  case (cur_state)\n\n    IDLE: begin\n      if(m_axis_rx_tvalid && m_axis_rx_tready && !eof) begin\n        next_state = IN_PACKET;\n      end\n      else begin\n        next_state = IDLE;\n      end\n\n      pkt_len_counter = new_pkt_len;\n    end\n\n    IN_PACKET: begin\n      if((C_DATA_WIDTH == 128) && straddle_sof && m_axis_rx_tvalid) begin\n        pkt_len_counter = new_pkt_len;\n        next_state = IN_PACKET;\n      end\n\n      else if(m_axis_rx_tready && pkt_done)\n      begin\n        pkt_len_counter = new_pkt_len;\n        next_state      = IDLE;\n      end\n\n      else begin\n        if(m_axis_rx_tready) begin\n          pkt_len_counter = pkt_len_counter_dec;\n        end\n        else begin\n          pkt_len_counter = reg_pkt_len_counter;\n        end\n\n        next_state = IN_PACKET;\n      end\n    end\n\n    default: begin\n      pkt_len_counter = reg_pkt_len_counter;\n      next_state      = IDLE;\n    end\n  endcase\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    cur_state           <= #TCQ IDLE;\n    reg_pkt_len_counter <= #TCQ 12'h0;\n  end\n  else begin\n    cur_state           <= #TCQ next_state;\n    reg_pkt_len_counter <= #TCQ pkt_len_counter;\n  end\nend\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : strb_calc_128\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        10'd3:   null_is_eof = 5'b11011;\n        10'd4:   null_is_eof = 5'b11111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = {KEEP_WIDTH{1'b0}};\n  end\n  else if(C_DATA_WIDTH == 64) begin : strb_calc_64\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = { ((pkt_len_counter == 12'd2) ? 4'hF:4'h0), 4'hF };\n  end\n  else begin : strb_calc_32\n    always @(*) begin\n      if(pkt_len_counter == 12'd1) begin\n        null_is_eof = 5'b10011;\n      end\n      else begin\n        null_is_eof = 5'b00011;\n      end\n    end\n\n    assign eof_tkeep = 4'hF;\n  end\nendgenerate\n\n\nassign null_rx_tvalid = 1'b1;\nassign null_rx_tlast  = (pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\nassign null_rx_tkeep  = null_rx_tlast ? eof_tkeep : {KEEP_WIDTH{1'b1}};\nassign null_rdst_rdy  = null_rx_tlast;\n\nendmodule\n",
        "module_name": "axi_basic_rx_null_gen #",
        "module_hash": "df00fe1cd45b9a612a76e06d42cb7ed5",
        "dataset_index": 25110
      },
      "shift_register_ddc1d939": {
        "rtl_code": "\nmodule shift_register(\n    input clk,\n    input areset, // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q,\n    output [3:0] q_next);\n\n    reg [3:0] reg1, reg2, reg3, reg4;\n\n    always @(posedge clk or negedge areset) begin\n        if (areset == 0) begin\n            reg1 <= 4'b0;\n            reg2 <= 4'b0;\n            reg3 <= 4'b0;\n            reg4 <= 4'b0;\n        end else begin\n            if (ena == 1) begin\n                if (load == 1) begin\n                    reg1 <= data;\n                    reg2 <= 4'b0;\n                    reg3 <= 4'b0;\n                    reg4 <= 4'b0;\n                end else begin\n                    reg1 <= reg2;\n                    reg2 <= reg3;\n                    reg3 <= reg4;\n                    reg4 <= 4'b0;\n                end\n            end\n        end\n    end\n\n    assign q_next = {reg4, reg3, reg2, reg1};\n\n    always @(posedge clk or negedge areset) begin\n        if (areset == 0) begin\n            q <= 4'b0;\n        end else begin\n            if (ena == 1) begin\n                if (load == 1) begin\n                    q <= data;\n                end else begin\n                    q <= q_next;\n                end\n            end\n        end\n    end\n\nendmodule\nmodule top_module(\n    input clk,\n    input areset, // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output [3:0] q);\n\n    wire [3:0] q_next;\n\n    shift_register sr(clk, areset, load, ena, data, q, q_next);\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "ddc1d9392c066034927aff0fd2c78bd5",
        "dataset_index": 13101
      },
      "urn_gen_c48e5bea": {
        "rtl_code": "\nmodule urn_gen(\n    input clk,\n    input rst,\n    output [63:0] urn\n    );\n    reg [63:0] s1 = 64'd1234;\n    reg [63:0] s2 = 64'd5678;\n    reg [63:0] s3 = 64'd9012;\n    reg [63:0] urn_reg = 64'd0;\n    wire [63:0] b1,b2,b3;\n    wire [63:0] new_s1,new_s2,new_s3;\n    \n    assign urn = urn_reg;\n    \n    assign b1      = (((s1 << 13) ^ s1) >> 19);\n    assign new_s1  = (((s1 & 64'hfffffffffffffffe) << 12) ^ b1);\n    assign b2      = (((s2 << 2 ) ^ s2) >> 25);\n    assign new_s2  = (((s2 & 64'hfffffffffffffff8) << 4 ) ^ b2);\n    assign b3      = (((s3 << 3 ) ^ s3) >> 11);\n    assign new_s3  = (((s3 & 64'hfffffffffffffff0) << 17) ^ b3);    \n    \n    always @(posedge clk)\n    begin\n        if (rst)\n        begin\n            s1 <= 64'd1234;\n            s2 <= 64'd5678;\n            s3 <= 64'd9012;\n            urn_reg <= 64'd0;\n        end\n        else\n        begin\n            urn_reg <= new_s1 ^ new_s2 ^ new_s3;\n            s1 <= new_s1;\n            s2 <= new_s2;\n            s3 <= new_s3;\n        end\n    end\n    \nendmodule\n",
        "module_name": "urn_gen",
        "module_hash": "c48e5bea367d5970630579b09e9e57bc",
        "dataset_index": 17168
      },
      "priority_encoder_c048371a": {
        "rtl_code": "module priority_encoder (\n    input [3:0] binary_in, // 4-bit binary input\n    output reg [1:0] priority_out // 2-bit priority output\n);\n\nalways @* begin\n    casez(binary_in)\n        4'b0001: priority_out = 2'b00;\n        4'b0010: priority_out = 2'b01;\n        4'b0100: priority_out = 2'b10;\n        4'b1000: priority_out = 2'b11;\n        default: priority_out = 2'b00;\n    endcase\nend\n\nendmodule\n\nmodule gray_code_generator (\n    input [3:0] priority_in, // 4-bit input for priority encoder\n    output [3:0] gray_code // 4-bit Gray code sequence output\n);\n\nwire [1:0] priority_out;\npriority_encoder pe(priority_in, priority_out);\n\nassign gray_code[0] = priority_out[0] ^ priority_out[1];\nassign gray_code[1] = priority_out[0];\nassign gray_code[2] = priority_out[1];\nassign gray_code[3] = gray_code[2] ^ gray_code[1];\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "c048371abb9e8fadaea82c1e85c234ac",
        "dataset_index": 3985
      },
      "top__cba8c938": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d1,   // 8-bit input for the first register\n    input [7:0] d2,   // 8-bit input for the second register\n    output [7:0] q    // 8-bit output from the multiplication module\n);\n\n    reg [7:0] reg1, reg2;   // Two 8-bit registers\n    wire [7:0] add_result;  // Output from the adder module\n    wire [7:0] mul_result;  // Output from the multiplication module\n\n    // Instantiate the adder module\n    adder_module adder(\n        .a(reg1),\n        .b(reg2),\n        .sum(add_result)\n    );\n\n    // Instantiate the multiplication module\n    multiplication_module multiplier(\n        .a(add_result),\n        .b(5),\n        .product(mul_result)\n    );\n\n    // Register logic with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            reg1 <= 0;\n            reg2 <= 0;\n        end else begin\n            reg1 <= d1;\n            reg2 <= d2;\n        end\n    end\n\n    assign q = mul_result;  // Assign output to the multiplication result\n\nendmodule\n\n// Adder module\nmodule adder_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n\n    always @(a, b) begin\n        sum <= a + b;\n    end\n\nendmodule\n\n// Multiplication module\nmodule multiplication_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] product\n);\n\n    always @(a, b) begin\n        product <= a * b;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "cba8c938a13066308029eb705d3af37e",
        "dataset_index": 20149
      },
      "spi_master #_8f29dd2c": {
        "rtl_code": "module spi_master #(\n    parameter CLK_DIVIDE=3 // divide clk by 2^CLK_DIVIDE to get spi_sclk\n) (\n    input clk, // 50 MHz system clk\n    input reset,\n\n    input spi_start,\n    input [7:0] spi_data,\n    output spi_fin,\n\n    output spi_csn,\n    output spi_sdo,\n    output spi_sclk // max 10 MHz clk\n);\n\n`define SPI_MASTER_SM_W 2\n\nlocalparam STATE_IDLE = `SPI_MASTER_SM_W'h0;\nlocalparam STATE_SEND = `SPI_MASTER_SM_W'h1;\nlocalparam STATE_HOLD = `SPI_MASTER_SM_W'h2;\nlocalparam STATE_DONE = `SPI_MASTER_SM_W'h3;\n\nreg [`SPI_MASTER_SM_W-1:0] spi_sm_state;\nreg [CLK_DIVIDE-1:0] clk_divider;\nreg [7:0] spi_data_shift;\nreg [2:0] shift_counter;\n\nassign spi_csn = ((spi_sm_state==STATE_IDLE) && (spi_start==1'b0)) ? 1'b1 : 1'b0;\nassign spi_sdo = spi_data_shift[7];\nassign spi_sclk = ((spi_sm_state==STATE_SEND) && (clk_divider[CLK_DIVIDE-1]==1'b1)) ? 1'b1 : 1'b0;\n\nassign spi_fin = (spi_sm_state==STATE_DONE) ? 1'b1 : 1'b0;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        spi_sm_state <= STATE_IDLE;  \n        spi_data_shift <= 'b0;\n        clk_divider <= 'b0;\n        shift_counter <= 'b0;\n    end else begin\n        case (spi_sm_state)\n            STATE_IDLE: begin\n                if (spi_start==1'b1) begin\n                    spi_sm_state <= STATE_SEND;\n                    spi_data_shift <= spi_data;\n                    clk_divider <= 'b0;\n                    shift_counter <= 'b0;\n                end\n            end\n            STATE_SEND: begin\n                clk_divider <= clk_divider + 1;\n                if (clk_divider == {CLK_DIVIDE{1'b1}}) begin\n                    shift_counter <= shift_counter + 1;\n                    spi_data_shift <= {spi_data_shift[6:0], 1'b0};\n                    if (shift_counter==3'b111) begin\n                        spi_sm_state <= STATE_HOLD;\n                    end\n                end\n            end\n            STATE_HOLD: begin\n                clk_divider <= clk_divider + 1;\n                if (clk_divider == {CLK_DIVIDE{1'b1}}) begin\n                    spi_sm_state <= STATE_DONE;\n                end\n            end\n            STATE_DONE: begin\n                if (spi_start==1'b0) begin\n                    spi_sm_state <= STATE_IDLE;\n                end\n            end\n            default:\n                spi_sm_state <= STATE_IDLE;\n\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "spi_master #",
        "module_hash": "8f29dd2c433857c7ad9d3808848f5c65",
        "dataset_index": 9143
      },
      "teclado_ac0150e8": {
        "rtl_code": "\nmodule teclado(\n    input      [7:0] ps2_data,\n    output reg [4:0] val,\n    output reg [2:0] control,\noutput [7:0] leds\n  );\n    \n    \n    localparam CTRL_NUMERO    = 3'd1;\n    localparam CTRL_ENTER     = 3'd2;\n    localparam CTRL_FLECHA    = 3'd3;\n    localparam CTRL_OPERACION = 3'd4;\n    \n    localparam CERO   = 8'h45;\n    localparam UNO    = 8'h16;\n    localparam DOS    = 8'h1E;\n    localparam TRES   = 8'h26;\n    localparam CUATRO = 8'h25;\n    localparam CINCO  = 8'h2E;\n    localparam SEIS   = 8'h36;\n    localparam SIETE  = 8'h3D;\n    localparam OCHO   = 8'h3E;\n    localparam NUEVE  = 8'h46;\n    localparam A      = 8'h1C;\n    localparam B      = 8'h32;\n    localparam C      = 8'h21;\n    localparam D      = 8'h23;\n    localparam E      = 8'h24;\n    localparam F      = 8'h2B;\n    localparam O      = 8'h44;\n    localparam Y      = 8'h35;\n    localparam SUMA   = 8'h1B;\n    localparam RESTA  = 8'h2D;\n    localparam MUL    = 8'h3A;\n    localparam ENTER  = 8'h5A;\n    localparam ARRIBA    =8'h75;\n    localparam ABAJO     =8'h72;\n    localparam IZQUIERDA =8'h6B;\n    localparam DERECHA   =8'h74;\n     \n    wire reloj_lento;\n    \n    \n    assign leds[4:0]= val;\n    assign leds[7:5]= control;   \n    \n\n   \n    \n    \n    always @(*) begin\n        case(ps2_data)\n           CERO: begin\n                    val=5'd0;        \n                    control=CTRL_NUMERO;\n            end\n            UNO: begin\n                    val=5'd1;\n                    control=CTRL_NUMERO;\n            end\n            DOS:begin\n                    val=5'd2;    \n                    control=CTRL_NUMERO;\n            end\n            TRES:begin\n                    val=5'd3;    \n                    control=CTRL_NUMERO;\n            end\n            CUATRO:begin\n                    val=5'd4;    \n                    control=CTRL_NUMERO;\n            end\n            CINCO:begin\n                    val=5'd5;    \n                    control=CTRL_NUMERO;\n            end\n            SEIS:begin\n                    val=5'd6;    \n                    control=CTRL_NUMERO;\n            end\n            SIETE:begin\n                    val=5'd7;    \n                    control=CTRL_NUMERO;\n            end\n            OCHO:begin\n                    val=5'd8;    \n                    control=CTRL_NUMERO;\n            end\n            NUEVE:begin\n                    val=5'd9;    \n                    control=CTRL_NUMERO;\n            end\n            A:begin\n                    val=5'd10;    \n                    control=CTRL_NUMERO;\n            end\n            B:begin\n                    val=5'd11;    \n                    control=CTRL_NUMERO;\n            end\n            C:begin\n                    val=5'd12;    \n                    control=CTRL_NUMERO;\n            end\n            D:begin\n                    val=5'd13;    \n                    control=CTRL_NUMERO;\n            end\n            E:begin\n                    val=5'd14;    \n                    control=CTRL_NUMERO;\n            end\n            F:begin\n                    val=5'd15;    \n                    control=CTRL_NUMERO;\n            end\n            SUMA:begin\n                    val=5'd21;    \n                    control=CTRL_OPERACION;\n            end\n            RESTA:begin\n                    val=5'd22;    \n                    control=CTRL_OPERACION;\n            end\n            MUL:begin\n                    val=5'd23;    \n                    control=CTRL_OPERACION;\n            end\n            Y:begin\n                    val=5'd24;    \n                    control=CTRL_OPERACION;\n            end\n            O:begin\n                    val=5'd25;    \n                    control=CTRL_OPERACION;\n            end\n            ENTER:begin\n                    val     =5'd16;    \n                    control =CTRL_ENTER;\n            end\n            ARRIBA:begin\n                    val=5'd19;    \n                    control=CTRL_FLECHA;\n            end\n            ABAJO:begin\n                    val=5'd20;    \n                    control=CTRL_FLECHA;\n            end\n            IZQUIERDA:begin\n                    val=5'd17;    \n                    control=CTRL_FLECHA;\n            end\n            DERECHA:begin\n                    val=5'd18;    \n                    control=CTRL_FLECHA;\n            end\n            default: begin\n                    val=5'd0;    \n                    control=3'd0;\n            end\n            endcase\n    end\n    \nendmodule\n    \n",
        "module_name": "teclado",
        "module_hash": "ac0150e856dcdf16c95701646baa5c03",
        "dataset_index": 24113
      },
      "bit_converter_9d2dbde2": {
        "rtl_code": "\nmodule bit_converter(\n    input bit_in,\n    input strobe,\n    input clk,\n    output bit_out\n);\n\nreg bit_in_sync;\n\nalways @(posedge clk)\nbegin\n    if (strobe)\n        bit_in_sync <= bit_in;\nend\n\nassign bit_out = bit_in_sync;\n\nendmodule\nmodule byte_to_bit_converter(\n    input [7:0] byte_in,\n    input strobe,\n    input clk,\n    output [7:0] bit_out\n);\n\nwire bit0_out, bit1_out, bit2_out, bit3_out, bit4_out, bit5_out, bit6_out, bit7_out;\n\nbit_converter bit0(\n    .bit_in(byte_in[0]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit0_out)\n);\n\nbit_converter bit1(\n    .bit_in(byte_in[1]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit1_out)\n);\n\nbit_converter bit2(\n    .bit_in(byte_in[2]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit2_out)\n);\n\nbit_converter bit3(\n    .bit_in(byte_in[3]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit3_out)\n);\n\nbit_converter bit4(\n    .bit_in(byte_in[4]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit4_out)\n);\n\nbit_converter bit5(\n    .bit_in(byte_in[5]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit5_out)\n);\n\nbit_converter bit6(\n    .bit_in(byte_in[6]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit6_out)\n);\n\nbit_converter bit7(\n    .bit_in(byte_in[7]),\n    .strobe(strobe),\n    .clk(clk),\n    .bit_out(bit7_out)\n);\n\nassign bit_out = {bit7_out, bit6_out, bit5_out, bit4_out, bit3_out, bit2_out, bit1_out, bit0_out};\n\nendmodule",
        "module_name": "bit_converter",
        "module_hash": "9d2dbde20305876f7783df36f6e6c93a",
        "dataset_index": 12198
      },
      "binary_counter_b3cf98b3": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst,\n    output reg [3:0] count,\n    output reg max_count_reached\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0000;\n        max_count_reached <= 1'b0;\n    end else if (count == 4'b1111) begin\n        count <= 4'b0000;\n        max_count_reached <= 1'b1;\n    end else begin\n        count <= count + 1;\n        max_count_reached <= 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "b3cf98b3dabc52be928b2068a16e14e9",
        "dataset_index": 9825
      },
      "gray_to_binary_99036093": {
        "rtl_code": "module gray_to_binary (\n    input [3:0] gray,\n    output reg [3:0] binary\n);\n\nalways @ (gray) begin\n    binary[3] = gray[3];\n    binary[2] = binary[3] ^ gray[2];\n    binary[1] = binary[2] ^ gray[1];\n    binary[0] = binary[1] ^ gray[0];\nend\n\nendmodule",
        "module_name": "gray_to_binary",
        "module_hash": "990360937651b24ffd46ea2a95e007c5",
        "dataset_index": 884
      },
      "traffic_light_22283d3c": {
        "rtl_code": "\nmodule traffic_light(\n    input clk,\n    input reset,\n    input pedestrian_button,\n    output reg red_light,\n    output reg yellow_light,\n    output reg green_light,\n    output reg pedestrian_light\n);\n\n    // define state variables\n    parameter IDLE = 2'b00;\n    parameter TRAFFIC_LIGHT = 2'b01;\n    parameter PEDESTRIAN_LIGHT = 2'b10;\n    reg [1:0] state = IDLE;\n\n    // define counters for each state\n    reg [3:0] red_counter = 0;\n    reg [2:0] yellow_counter = 0;\n    reg [4:0] green_counter = 0;\n    reg [3:0] pedestrian_counter = 0;\n\n    always @(posedge clk) begin\n\n        if(reset) begin\n            // reset all counters and set state to idle\n            red_counter <= 0;\n            yellow_counter <= 0;\n            green_counter <= 0;\n            pedestrian_counter <= 0;\n            state <= IDLE;\n        end\n\n        else begin\n            case(state)\n\n                IDLE: begin\n                    // set traffic light to red and wait for 5 seconds\n                    red_light <= 1;\n                    yellow_light <= 0;\n                    green_light <= 0;\n                    pedestrian_light <= 0;\n                    red_counter <= red_counter + 1;\n\n                    if(red_counter == 5) begin\n                        red_counter <= 0;\n                        state <= TRAFFIC_LIGHT;\n                    end\n                end\n\n                TRAFFIC_LIGHT: begin\n                    // set traffic light to yellow and wait for 2 seconds\n                    red_light <= 0;\n                    yellow_light <= 1;\n                    green_light <= 0;\n                    pedestrian_light <= 0;\n                    yellow_counter <= yellow_counter + 1;\n\n                    if(yellow_counter == 2) begin\n                        yellow_counter <= 0;\n                        state <= PEDESTRIAN_LIGHT;\n                    end\n                end\n\n                PEDESTRIAN_LIGHT: begin\n                    // set pedestrian light to red and wait for 5 seconds\n                    red_light <= 1;\n                    yellow_light <= 0;\n                    green_light <= 0;\n                    pedestrian_light <= 1;\n                    pedestrian_counter <= pedestrian_counter + 1;\n\n                    if(pedestrian_counter == 5) begin\n                        pedestrian_counter <= 0;\n                        state <= IDLE;\n                    end\n                end\n\n            endcase\n        end\n        // check for pedestrian button press\n        if(pedestrian_button && state == IDLE) begin\n            state <= PEDESTRIAN_LIGHT;\n        end\n    end\nendmodule\n",
        "module_name": "traffic_light",
        "module_hash": "22283d3c42c6c563a95823a1e51e46e5",
        "dataset_index": 21360
      },
      "red_pitaya_lpf_block_b4ae6652": {
        "rtl_code": "module red_pitaya_lpf_block\n#(\n    parameter     SHIFTBITS =     4,\n    parameter     SIGNALBITS   = 14,\n    parameter     MINBW        = 10\n    )\n(\n    input clk_i,\n    input rstn_i  ,\n    input [SHIFTBITS:0] shift, \n    input filter_on,\n    input highpass,\n    input signed  [SIGNALBITS-1:0] signal_i,\n    output signed [SIGNALBITS-1:0] signal_o\n);\n\nlocalparam MAXSHIFT = $clog2(125000000/MINBW);\n\nreg signed [SIGNALBITS+MAXSHIFT-1:0] y;\nreg signed [SIGNALBITS+MAXSHIFT-1:0] delta;\nwire signed [SIGNALBITS+MAXSHIFT-1:0] shifted_delta;\nwire signed [SIGNALBITS-1:0] y_out;\nwire filter_off;\n\nassign y_out = y[MAXSHIFT+SIGNALBITS-1:MAXSHIFT];\nassign shifted_delta = delta<<((shift<MAXSHIFT) ? shift : MAXSHIFT);\n\nalways @(posedge clk_i) begin\n    if (rstn_i == 1'b0) begin\n        y <= {MAXSHIFT+SIGNALBITS{1'b0}};\n        delta <= {MAXSHIFT+SIGNALBITS{1'b0}};\n    end\n    else begin\n        delta <= signal_i - y_out;\n        y <= y + shifted_delta;\n    end\nend\n  \nassign signal_o = (filter_on == 1'b0) ? signal_i : ((highpass==1'b0) ? y_out : delta);\n\nendmodule",
        "module_name": "red_pitaya_lpf_block",
        "module_hash": "b4ae6652392f38a2d43215cd4512ea21",
        "dataset_index": 21210
      },
      "four_input_or_150da93c": {
        "rtl_code": "\nmodule four_input_or (\n    input A,\n    input B,\n    input C,\n    input D,\n    output X\n);\n\n    wire or1_out;\n\n    or (or1_out, A, B, C, D);\n\n    assign X = or1_out;\n\nendmodule\n",
        "module_name": "four_input_or",
        "module_hash": "150da93c0f3873d28828c7bf7072a3be",
        "dataset_index": 17589
      },
      "DrawMarioScore_e50025cb": {
        "rtl_code": "\nmodule DrawMarioScore(\n    input wire clk,\n    input wire rst,\n    input wire [9:0] hcount_in,\n    input wire hsync_in,\n    input wire [9:0] vcount_in,\n    input wire vsync_in,\n    input wire [23:0] rgb_in,\n    input wire blnk_in,\n    input wire [7:0] char_pixels,\n    \n    output reg [9:0] hcount_out,\n    output reg hsync_out,\n    output reg [9:0] vcount_out,\n    output reg vsync_out,\n    output reg [23:0] rgb_out,\n    output reg blnk_out,\n    output reg [7:0] char_xy,\n    output reg [3:0] char_line\n    );\n    \n    reg [23:0] rgb_nxt;\n        \n    localparam XPOS     = 40;\n    localparam YPOS     = 50;\n    localparam WIDTH    = 552;\n    localparam HEIGHT   = 16;\n        \n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            hcount_out  <= #1 0;\n            vcount_out  <= #1 0;\n            hsync_out   <= #1 0;\n            vsync_out   <= #1 0;\n            rgb_out     <= #1 0;\n            blnk_out    <= #1 0;\n        end\n        else begin\n            hcount_out  <= #1 hcount_in;\n            vcount_out  <= #1 vcount_in;\n            hsync_out   <= #1 hsync_in;\n            vsync_out   <= #1 vsync_in;\n            rgb_out     <= #1 rgb_nxt;\n            blnk_out    <= #1 blnk_in;\n        end\n    end\n\n    always @* begin\n        if ((hcount_in >= XPOS) && (hcount_in < XPOS + WIDTH) && (vcount_in >= YPOS) && (vcount_in < YPOS + HEIGHT) && (char_pixels[(XPOS - hcount_in)])) \n        begin\n            if(char_xy == 8'h20)\n                rgb_nxt = 24'hff_ff_00;\n            else\n                rgb_nxt = 24'hff_ff_ff;\n        end\n        else begin\n            rgb_nxt = rgb_in; end\n    end\n\n\n    always @* begin\n        char_xy = (hcount_in - XPOS - 1)>>3;\n    end\n    \n    always @* begin\n        char_line = vcount_in - YPOS;\n    end\n        \nendmodule\n",
        "module_name": "DrawMarioScore",
        "module_hash": "e50025cb2e92c49ce9ad0257bae29c7b",
        "dataset_index": 15262
      },
      "top_module_82273001": {
        "rtl_code": "module top_module( \n    input wire [15:0] in,\n    output wire [3:0] in1_hi, in1_lo,\n    output wire [3:0] in2_hi, in2_lo,\n    output wire [7:0] out );\n\n  wire [7:0] in1, in2;\n\n  // Split the 16-bit input into two 8-bit outputs\n  assign in1 = in[15:8];\n  assign in2 = in[7:0];\n\n  // Split each 8-bit input into two 4-bit inputs\n  assign in1_hi = in1[7:4];\n  assign in1_lo = in1[3:0];\n  assign in2_hi = in2[7:4];\n  assign in2_lo = in2[3:0];\n\n  // Compute the absolute difference between each pair of corresponding 4-bit inputs\n  wire [3:0] abs_diff_hi, abs_diff_lo;\n  assign abs_diff_hi = (in1_hi >= in2_hi) ? (in1_hi - in2_hi) : (in2_hi - in1_hi);\n  assign abs_diff_lo = (in1_lo >= in2_lo) ? (in1_lo - in2_lo) : (in2_lo - in1_lo);\n\n  // Output the sum of the absolute differences\n  assign out = abs_diff_hi + abs_diff_lo;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "82273001a924341c3592b480cac1c736",
        "dataset_index": 4591
      },
      "PLL_f6246b59": {
        "rtl_code": "\nmodule PLL (\n  input  ref_clk,\n  input  ctrl,\n  output synth_clk\n);\n\nparameter m = 10; // multiplication factor\nparameter f_ref = 100000; // reference clock frequency\nparameter f_out = 1000000; // output frequency\n\nreg [31:0] phase_accumulator;\nreg [31:0] feedback_clk_counter;\nreg [31:0] reference_clk_counter;\n\nwire feedback_clk;\nwire phase_difference;\nwire loop_filter_output;\n\n// Divide the reference clock frequency by multiplication factor 'm' to get the frequency of the feedback signal.\nassign feedback_clk = feedback_clk_counter == (f_ref / m - 1);\nalways @(posedge ref_clk) begin\n  if (feedback_clk) begin\n    feedback_clk_counter <= 0;\n  end else begin\n    feedback_clk_counter <= feedback_clk_counter + 1;\n  end\nend\n\n// Compare the phase of the reference and feedback signals using a phase detector.\nphase_detector pd(\n  .ref_clk(ref_clk),\n  .feedback_clk(feedback_clk),\n  .phase_difference(phase_difference)\n);\n\n// Adjust the frequency of the controlled oscillator based on the phase difference using a loop filter.\nloop_filter lf(\n  .ctrl(ctrl),\n  .phase_difference(phase_difference),\n  .loop_filter_output(loop_filter_output)\n);\n\n// Multiply the frequency of the controlled oscillator by multiplication factor 'm' to get the frequency of the synthesized clock signal.\nreg synth_clk_reg;\nalways @(negedge ref_clk) begin\n  if (phase_accumulator < m) begin\n    phase_accumulator <= phase_accumulator + (f_out * m) / f_ref;\n    synth_clk_reg <= ~synth_clk_reg;\n  end else begin\n    phase_accumulator <= 0;\n  end\nend\n\nassign synth_clk = synth_clk_reg;\n\nendmodule\nmodule phase_detector (\n  input ref_clk,\n  input feedback_clk,\n  output phase_difference\n);\n\nreg ref_clk_last;\nreg feedback_clk_last;\n\nalways @(negedge ref_clk) begin\n  ref_clk_last <= ref_clk;\nend\n\nalways @(negedge feedback_clk) begin\n  feedback_clk_last <= feedback_clk;\nend\n\nassign phase_difference = feedback_clk_last ^ ref_clk_last;\n\nendmodule\nmodule loop_filter (\n  input ctrl,\n  input phase_difference,\n  output loop_filter_output\n);\n\nreg [31:0] integrator;\n\nparameter kp = 1;\nparameter ki = 1;\n\nalways @(negedge ctrl) begin\n  integrator <= integrator + phase_difference;\nend\n\nassign loop_filter_output = integrator * ki;\n\nendmodule",
        "module_name": "PLL",
        "module_hash": "f6246b59f8a09383baf8573ef930df36",
        "dataset_index": 14655
      },
      "priority_encoder_901ab36b": {
        "rtl_code": "module priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    // Binary-to-Gray code converter\n    wire [7:0] gray_in;\n    assign gray_in[0] = in[0];\n    assign gray_in[1] = in[0] ^ in[1];\n    assign gray_in[2] = in[1] ^ in[2];\n    assign gray_in[3] = in[2] ^ in[3];\n    assign gray_in[4] = in[3] ^ in[4];\n    assign gray_in[5] = in[4] ^ in[5];\n    assign gray_in[6] = in[5] ^ in[6];\n    assign gray_in[7] = in[6] ^ in[7];\n\n    // Gray-to-binary code converter\n    wire [7:0] gray_out;\n    assign gray_out[7] = gray_in[7];\n    assign gray_out[6] = gray_in[7] ^ gray_in[6];\n    assign gray_out[5] = gray_in[6] ^ gray_in[5];\n    assign gray_out[4] = gray_in[5] ^ gray_in[4];\n    assign gray_out[3] = gray_in[4] ^ gray_in[3];\n    assign gray_out[2] = gray_in[3] ^ gray_in[2];\n    assign gray_out[1] = gray_in[2] ^ gray_in[1];\n    assign gray_out[0] = gray_in[1] ^ gray_in[0];\n\n    // Priority encoder\n    always @* begin\n        if (in == 0) begin\n            pos = 0;\n        end else if (gray_out[7] == 1) begin\n            pos = 7;\n        end else if (gray_out[6] == 1) begin\n            pos = 6;\n        end else if (gray_out[5] == 1) begin\n            pos = 5;\n        end else if (gray_out[4] == 1) begin\n            pos = 4;\n        end else if (gray_out[3] == 1) begin\n            pos = 3;\n        end else if (gray_out[2] == 1) begin\n            pos = 2;\n        end else if (gray_out[1] == 1) begin\n            pos = 1;\n        end else if (gray_out[0] == 1) begin\n            pos = 0;\n        end\n    end\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "901ab36b83b2bcdfbc98e41ee082526b",
        "dataset_index": 17693
      },
      "four_bit_counter_0f850bb5": {
        "rtl_code": "module four_bit_counter (\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0000;\n    end else if (en) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "four_bit_counter",
        "module_hash": "0f850bb5feedd837720f6bdaf142e3fb",
        "dataset_index": 15352
      },
      "user_design_fa5930fc": {
        "rtl_code": "module user_design\n   (IN1_STB,\n    OUT1_ACK,\n    output_rs232_tx,\n    OUT1_STB,\n    INTERNAL_RST_reg,\n    OUT1,\n    IN1_ACK,\n    ETH_CLK_OBUF);\n  output IN1_STB;\n  output OUT1_ACK;\n  output [7:0]output_rs232_tx;\n  input OUT1_STB;\n  input INTERNAL_RST_reg;\n  input [7:0]OUT1;\n  input IN1_ACK;\n  input ETH_CLK_OBUF;\n\n  wire ETH_CLK_OBUF;\n  wire IN1_ACK;\n  wire IN1_STB;\n  wire INTERNAL_RST_reg;\n  wire [7:0]OUT1;\n  wire OUT1_ACK;\n  wire OUT1_STB;\n  wire [7:0]output_rs232_tx;\n\n  reg [7:0] output_rs232_tx_reg;\n  reg IN1_STB_reg;\n  reg OUT1_ACK_reg;\n\n  always @(*) begin\n    output_rs232_tx_reg = OUT1;\n    IN1_STB_reg = OUT1_STB;\n    if (INTERNAL_RST_reg) begin\n      OUT1_ACK_reg = 0;\n      IN1_STB_reg = 0;\n    end else if (IN1_ACK) begin\n      OUT1_ACK_reg = 1;\n    end\n  end\n\n  assign output_rs232_tx = output_rs232_tx_reg;\n  assign IN1_STB = IN1_STB_reg;\n  assign OUT1_ACK = OUT1_ACK_reg;\n\nendmodule",
        "module_name": "user_design",
        "module_hash": "fa5930fc389ab8cc544bedcc253bec0a",
        "dataset_index": 7408
      },
      "prometheus_fx3_partial_718499a2": {
        "rtl_code": "module prometheus_fx3_partial(\n\tinput  rst_n,\n        input  clk_100,\n        input  partial_mode_selected,\n        input  i_gpif_in_ch0_rdy_d,\n        input  i_gpif_out_ch0_rdy_d,\n        output o_gpif_we_n_partial_,\n\toutput o_gpif_pkt_end_n_partial_,\n        output [31:0] data_out_partial\n);\n\nreg [2:0]current_partial_state;\nreg [2:0]next_partial_state;\nparameter [2:0] partial_idle                      = 3'd0;\nparameter [2:0] partial_wait_flagb                = 3'd1;\nparameter [2:0] partial_write                     = 3'd2;\nparameter [2:0] partial_write_wr_delay            = 3'd3;\nparameter [2:0] partial_wait\t\t          = 3'd4;\n\n\nreg [3:0] strob_cnt;\nreg       strob; \nreg [3:0] short_pkt_cnt;\nreg [31:0]data_gen_partial;\nreg o_gpif_pkt_end_n_prtl_;\n\nassign o_gpif_we_n_partial_ = ((current_partial_state == partial_write) && (i_gpif_out_ch0_rdy_d == 1'b1)) ? 1'b0 : 1'b1;\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tshort_pkt_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_idle)begin\n\t\tshort_pkt_cnt <= 4'd0;\n\tend else if((current_partial_state == partial_write))begin\n\t\tshort_pkt_cnt <= short_pkt_cnt + 1'b1;\n\tend\t\nend\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tstrob_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_idle)begin\n\t\tstrob_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_wait)begin\n\t\tstrob_cnt <= strob_cnt + 1'b1;\n\tend\t\nend\n\nalways@(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin\n\t\tstrob <= 1'b0;\n\tend else if((current_partial_state == partial_wait) && (strob_cnt == 4'b0111)) begin\n\t\tstrob <= !strob;\n\tend\nend\n\nalways@(*)begin\n\tif((partial_mode_selected) & (strob == 1'b1) & (short_pkt_cnt == 4'b1111))begin\n\t\to_gpif_pkt_end_n_prtl_ = 1'b0;\n\tend else begin\n\t\to_gpif_pkt_end_n_prtl_ = 1'b1;\n\tend\nend\t\n\nassign o_gpif_pkt_end_n_partial_ = o_gpif_pkt_end_n_prtl_;\n\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tcurrent_partial_state <= partial_idle;\n\tend else begin\n\t\tcurrent_partial_state <= next_partial_state;\n\tend\t\nend\n\nalways @(*)begin\n\tnext_partial_state = current_partial_state;\n\tcase(current_partial_state)\n\tpartial_idle:begin\n\t\tif((partial_mode_selected) & (i_gpif_in_ch0_rdy_d == 1'b1))begin\n\t\t\tnext_partial_state = partial_wait_flagb; \n\t\tend else begin\n\t\t\tnext_partial_state = partial_idle;\n\t\tend\t\n\tend\n\tpartial_wait_flagb :begin\n\t\tif (i_gpif_out_ch0_rdy_d == 1'b1)begin\n\t\t\tnext_partial_state = partial_write; \n\t\tend else begin\n\t\t\tnext_partial_state = partial_wait_flagb; \n\t\tend\n\tend\n\tpartial_write:begin\n\t\tif((i_gpif_out_ch0_rdy_d == 1'b0) | ((strob == 1'b1) & (short_pkt_cnt == 4'b1111)))begin\n\t\t\tnext_partial_state = partial_write_wr_delay;\n\t\tend else begin\n\t\t \tnext_partial_state = partial_write;\n\t\tend\n\tend\n        partial_write_wr_delay:begin\n\t\tnext_partial_state = partial_wait;\n\tend\n\tpartial_wait:begin\n\t\tif(strob_cnt == 4'b0111)begin\n\t\t\tnext_partial_state = partial_idle;\n\t\tend else begin\n\t\t\tnext_partial_state = partial_wait;\n\t\tend\n\tend\t\n\tendcase\nend\n\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tdata_gen_partial <= 32'd0;\n\tend else if((o_gpif_we_n_partial_ == 1'b0) & (partial_mode_selected)) begin\n\t\tdata_gen_partial <= data_gen_partial + 1;\n\tend else if (!partial_mode_selected) begin\n\t\tdata_gen_partial <= 32'd0;\n\tend\t\nend\n\nassign data_out_partial = data_gen_partial;\n\nendmodule\n\n",
        "module_name": "prometheus_fx3_partial",
        "module_hash": "718499a25974b46a4e9afea28e465417",
        "dataset_index": 17205
      },
      "FpuFp32_fc63c546": {
        "rtl_code": "\nmodule FpuFp32(\n    input clk,\n    input [3:0] opMode,\n    input [31:0] srca,\n    input [31:0] srcb,\n    output [31:0] dst\n);\n\n// Parameter definitions\nparameter [3:0] OP_NONE = 4'h00;\nparameter [3:0] OP_ADD = 4'h01;\nparameter [3:0] OP_SUB = 4'h02;\nparameter [3:0] OP_MUL = 4'h03;\nparameter [3:0] OP_DIV = 4'h04;\nparameter [3:0] OP_ABS = 4'h05;\nparameter [3:0] OP_NEG = 4'h06;\nparameter [3:0] OP_RCP = 4'h07;\nparameter [3:0] OP_SQRT = 4'h08;\n\n// Internal signals\nwire fpaIsSub;\nwire [31:0] fpaDst;\nwire [31:0] fpmSrcB;\nwire [31:0] fpmDst;\nwire [31:0] fpRcpDst;\n\n// Instantiate submodules\nFpuFp32Add fpadd(clk, fpaIsSub, srca, srcb, fpaDst);\nFpuFp32Mul fpmul(clk, srca, fpmSrcB, fpmDst);\nFpuFp32Rcp fprcp(clk, srcb, fpRcpDst);\n\n// Assign inputs to submodules\nassign fpaIsSub = (opMode == OP_SUB);\nassign fpmSrcB = (opMode == OP_DIV) ? fpRcpDst : srcb;\n\n// Output selection logic\nassign dst = (opMode == OP_ADD) ? fpaDst :\n             (opMode == OP_SUB) ? fpaDst :\n             (opMode == OP_MUL) ? fpmDst :\n             (opMode == OP_DIV) ? fpmDst :\n             (opMode == OP_ABS) ? ((srcb[31] == 1) ? -srcb : srcb) :\n             (opMode == OP_NEG) ? -srcb :\n             (opMode == OP_RCP) ? fpRcpDst :\n             (opMode == OP_SQRT) ? ((srcb - 32'h3F80_0000) >>> 1) + 32'h3F80_0000 :\n             srcb;\n\nendmodule\n\nmodule FpuFp32Add(clk, isSub, srca, srcb, dst);\n\ninput clk;\ninput isSub;\ninput [31:0] srca;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    if (isSub) begin\n        dst_reg = srca - srcb;\n    end else begin\n        dst_reg = srca + srcb;\n    end\nend\n\nassign dst = dst_reg;\n\nendmodule\n\nmodule FpuFp32Mul(clk, srca, srcb, dst);\n\ninput clk;\ninput [31:0] srca;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    dst_reg = srca * srcb;\nend\n\nassign dst = dst_reg;\n\nendmodule\n\nmodule FpuFp32Rcp(clk, srcb, dst);\n\ninput clk;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    dst_reg = 32'h3F80_0000 / srcb;\nend\n\nassign dst = dst_reg;\n\nendmodule\n",
        "module_name": "FpuFp32",
        "module_hash": "fc63c546b72ba254f19e482c55bde72d",
        "dataset_index": 21337
      },
      "dff#_71fe3337": {
        "rtl_code": "\n\n`ifndef LIB_DFF_V_\n`define LIB_DFF_V_\n\n\nmodule dff#(\n    parameter WIDTH = 1\n  ) (\n    input wire clk,\n    input wire rst,\n\n    input wire [WIDTH-1:0] inp,\n    output reg [WIDTH-1:0] outp\n  );\n\n  always @(posedge clk) begin\n    outp <= rst ? 0 : inp;\n  end\n\nendmodule\n\n`endif ",
        "module_name": "dff#",
        "module_hash": "71fe333749864216ebbc4773aa6fc210",
        "dataset_index": 3937
      },
      "MIPS_CPU_CONTROL_UNIT_0_1_2d5dc98f": {
        "rtl_code": "module MIPS_CPU_CONTROL_UNIT_0_1 (\n    input wire [5:0] op,\n    input wire [5:0] func,\n    input wire z,\n    output wire wreg,\n    output wire regrt,\n    output wire jal,\n    output wire m2reg,\n    output wire shfit,\n    output wire aluimm,\n    output wire sext,\n    output wire wmem,\n    output wire [3:0] aluc,\n    output wire [1:0] pcsource\n);\n\n    // Instantiate the CONTROL_UNIT without parameter passing since the commands are hardcoded\n    CONTROL_UNIT control_unit_inst (\n        .op(op),\n        .func(func),\n        .z(z),\n        .wreg(wreg),\n        .regrt(regrt),\n        .jal(jal),\n        .m2reg(m2reg),\n        .shfit(shfit),\n        .aluimm(aluimm),\n        .sext(sext),\n        .wmem(wmem),\n        .aluc(aluc),\n        .pcsource(pcsource)\n    );\nendmodule\n\n\nmodule CONTROL_UNIT (\n    input wire [5:0] op,\n    input wire [5:0] func,\n    input wire z,\n    output wire wreg,\n    output wire regrt,\n    output wire jal,\n    output wire m2reg,\n    output wire shfit,\n    output wire aluimm,\n    output wire sext,\n    output wire wmem,\n    output wire [3:0] aluc,\n    output wire [1:0] pcsource\n);\n\n    // Corrected control logic implementation based on MIPS instruction formats\n    assign wreg = ~op[5] | (op == 6'b100011); // R-type or lw\n    assign regrt = op[5] & ~op[2]; // I-type instructions\n    assign jal = (op == 6'b000011); // jal\n    assign m2reg = (op == 6'b100011); // lw\n    assign shfit = (func == 6'b000000) & ~op[5]; // sll, srl, sra for R-type\n    assign aluimm = op[5] & ~op[3]; // I-type ALU instructions\n    assign sext = ~(op[5] & op[3]); // Sign extend except for lui\n    assign wmem = (op == 6'b101011); // sw\n    assign aluc[3] = (func == 6'b000011) & ~op[5]; // sra for R-type\n    assign aluc[2] = ((op == 6'b000100) & z) | ((op == 6'b000101) & ~z); // beq, bne\n    assign aluc[1:0] = (op[5:3] == 3'b000) ? func[1:0] : op[1:0]; // Least significant bits of func or op\n    assign pcsource[1] = (op == 6'b000010) | (op == 6'b000011); // j, jal\n    assign pcsource[0] = (op == 6'b000100) & z | (op == 6'b000101) & ~z; // beq, bne\n\nendmodule\n",
        "module_name": "MIPS_CPU_CONTROL_UNIT_0_1",
        "module_hash": "2d5dc98f9f3ccddcd04f54bc7ae714b8",
        "dataset_index": 16842
      },
      "twos_complement_c494d179": {
        "rtl_code": "module twos_complement (\n    input [3:0] binary,\n    output reg [3:0] twos_comp\n);\n\nalways @* begin\n    twos_comp = (~binary) + 1;\nend\n\nendmodule",
        "module_name": "twos_complement",
        "module_hash": "c494d1793ed7e6a2460ec74c50fbf0e9",
        "dataset_index": 8437
      },
      "fp_convert_altpriority_encoder_3v7_e9aef605": {
        "rtl_code": "\nmodule fp_convert_altpriority_encoder_3v7 (\n    input [2:0] data,\n    output reg [1:0] q\n);\n\n    wire q0;\n    wire q1;\n    wire q2;\n    wire q3;\n\n    assign q0 = ~|data;\n    assign q1 = ~|data[2:1];\n    assign q2 = ~|data[2:0];\n    assign q3 = ~|data[2:1];\n\n    always @* begin\n        q[0] <= (~q0 & ~q1 & q2) | (~q0 & q1 & q3) | (q0 & ~q1 & q3) | (q0 & q1 & q2);\n        q[1] <= (~q0 & q1 & q2) | (q0 & ~q1 & q2) | (q0 & q1 & q3) | (q0 & ~q1 & q3);\n    end\n\nendmodule\nmodule fp_convert_altpriority_encoder_3e8 (\n    input [2:0] data,\n    output reg [1:0] q,\n    output reg zero\n);\n\n    wire [1:0] q0;\n    wire [1:0] q1;\n    wire [1:0] q2;\n    wire [1:0] q3;\n\n    fp_convert_altpriority_encoder_3v7 encoder0(\n        .data(data),\n        .q(q0)\n    );\n\n    fp_convert_altpriority_encoder_3v7 encoder1(\n        .data({data[1:0], data[2]}),\n        .q(q1)\n    );\n\n    fp_convert_altpriority_encoder_3v7 encoder2(\n        .data({data[0], data[2:1]}),\n        .q(q2)\n    );\n\n    fp_convert_altpriority_encoder_3v7 encoder3(\n        .data(data[2:0]),\n        .q(q3)\n    );\n\n    always @* begin\n        zero <= ~(|data);\n        q[0] <= (~zero & q2[1]) | (zero & q0[1]);\n        q[1] <= (~zero & q1[1]) | (zero & q3[1]);\n    end\n\nendmodule\nmodule fp_convert_altpriority_encoder_6v7 (\n    input [3:0] data,\n    output reg [2:0] q\n);\n\n    wire [1:0] wire_altpriority_encoder21_q;\n    wire [1:0] wire_altpriority_encoder22_q;\n\n    fp_convert_altpriority_encoder_3v7 altpriority_encoder21(\n        .data({data[2:1], data[0]}),\n        .q(wire_altpriority_encoder21_q)\n    );\n\n    fp_convert_altpriority_encoder_3e8 altpriority_encoder22(\n        .data(data[3:1]),\n        .q(wire_altpriority_encoder22_q),\n        .zero()\n    );\n\n    always @* begin\n        q <= {(~wire_altpriority_encoder22_q[1]), (wire_altpriority_encoder22_q[1] & wire_altpriority_encoder21_q[1]) | (~wire_altpriority_encoder22_q[1] & wire_altpriority_encoder22_q[0])};\n    end\n\nendmodule",
        "module_name": "fp_convert_altpriority_encoder_3v7",
        "module_hash": "e9aef605f86b0a242e97a87b2ce9dc2a",
        "dataset_index": 4466
      },
      "shift_register_control_8d8a5651": {
        "rtl_code": "module shift_register_control (\n  input clk,\n  input reset,\n  input [3:0] input_value,\n  output reg [15:0] output_value\n);\n\n  // Define states\n  parameter IDLE = 2'b00;\n  parameter WAIT_PATTERN = 2'b01;\n  parameter OUTPUT_ENABLED = 2'b10;\n\n  reg [1:0] state = IDLE;\n  reg [3:0] shift_reg = 4'b0000;\n  reg [3:0] pattern = 4'b0101;\n  reg [3:0] count = 4'b0000;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      shift_reg <= 4'b0000;\n      count <= 4'b0000;\n      output_value <= 16'b0000000000000000;\n    end\n    else begin\n      case (state)\n        IDLE: begin\n          if (input_value == pattern) begin\n            state <= WAIT_PATTERN;\n          end\n        end\n        WAIT_PATTERN: begin\n          if (input_value != pattern) begin\n            state <= IDLE;\n            shift_reg <= 4'b0000;\n            count <= 4'b0000;\n          end\n          else if (count == 4'b0011) begin\n            state <= OUTPUT_ENABLED;\n            count <= 4'b0000;\n          end\n          else begin\n            count <= count + 4'b0001;\n          end\n        end\n        OUTPUT_ENABLED: begin\n          if (count == 4'b0011) begin\n            state <= IDLE;\n            shift_reg <= 4'b0000;\n            count <= 4'b0000;\n          end\n          else begin\n            shift_reg <= {shift_reg[2:0], input_value};\n            count <= count + 4'b0001;\n          end\n        end\n        default: state <= IDLE;\n      endcase\n\n      if (state == OUTPUT_ENABLED) begin\n        output_value <= {shift_reg, 12'b000000000000};\n      end\n      else begin\n        output_value <= 16'b0000000000000000;\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "shift_register_control",
        "module_hash": "8d8a565156f933b9b8281800af913fd7",
        "dataset_index": 9631
      },
      "Test_01a457dc": {
        "rtl_code": "module Test (\n   input clk,\n   input [63:0] rc,\n   output reg o\n);\n\n   reg [63:0] rc_next;\n\n   // Calculate rc_next\n   always @ (posedge clk) begin\n      rc_next <= {rc[62:0], rc[63] ^ rc[2] ^ rc[0]};\n   end\n\n   // Calculate o\n   always @ (posedge clk) begin\n      o <= (rc[0] ^ rc[1]) & (rc[62] ^ rc[63]);\n   end\n\nendmodule",
        "module_name": "Test",
        "module_hash": "01a457dc8a9db39f50a99a8e6b6d2f4e",
        "dataset_index": 10739
      },
      "RIPPLEADD_64_b1b69b0c": {
        "rtl_code": "\nmodule RIPPLEADD_64 (A, B, Cin, S, Cout);\ninput [63:0] A, B;\ninput Cin;\noutput [63:0] S;\noutput Cout;\n\nwire [63:0] C;\nassign C[0] = Cin;\ngenvar i;\ngenerate\n    for (i = 0; i < 63; i = i + 1) begin : full_adder\n        FULLADDER_1BIT FA(\n            .A(A[i]),\n            .B(B[i]),\n            .Cin(C[i]),\n            .S(S[i]),\n            .Cout(C[i+1])\n        );\n    end\nendgenerate\n\nassign Cout = C[63];\nassign S[63] = C[63]; // Fixing the issue of undriven wire\n\nendmodule\nmodule FULLADDER_1BIT (A, B, Cin, S, Cout);\ninput A, B, Cin;\noutput S, Cout;\n\nassign S = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule",
        "module_name": "RIPPLEADD_64",
        "module_hash": "b1b69b0c2891324c5cc6620f187239f4",
        "dataset_index": 18778
      },
      "mux_2to1_bdb92054": {
        "rtl_code": "module mux_2to1 (\n    input A,\n    input B,\n    input S,\n    output reg Y\n);\n\nalways @(A, B, S) begin\n    if (S == 0) begin\n        Y <= A;\n    end else if (S == 1) begin\n        Y <= B;\n    end else begin\n        Y <= 0;\n    end\nend\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "bdb92054e1f14aaba95bb58ca5460e03",
        "dataset_index": 7015
      },
      "UART_Sender #_9b92f333": {
        "rtl_code": "module UART_Sender #(\n\tparameter N    = 5,\n\tparameter Full = 5'd29 )(\n\tinput Clk,\n\tinput Reset,\n\t\n\tinput [7:0]Data,\n\tinput      Send,\n\toutput reg Busy,\n\n\toutput reg Tx\t);\nreg        tSend;\nreg [  7:0]Temp;\nreg [N-1:0]Count;\nreg [  2:0]BitCount;\nreg   [1:0]State;\nlocalparam Idle    = 2'b00;\nlocalparam Sending = 2'b01;\nlocalparam StopBit = 2'b11;\nlocalparam Done    = 2'b10;\nreg tReset;\n\nalways @(posedge Clk) begin\n\ttReset <= Reset;\n\n\tif(tReset) begin\n\t\tBusy <= 1'b0;\n\t\tTx   <= 1'b1;\n\n\t\ttSend    <= 0;\n\t\tCount    <= 0;\n\t\tBitCount <= 0;\n\t\tState    <= Idle;\nend else begin\n\t\ttSend <= Send;\n\n\t\tif(~|Count) begin\n\t\t\tcase(State)\n\t\t\t\tIdle: begin\n\t\t\t\t\tif(tSend) begin\n\t\t\t\t\t\tCount      <= Full;\n\t\t\t\t\t\tBitCount   <= 3'd7;\n\t\t\t\t\t\t{Temp, Tx} <= {Data, 1'b0};\n\t\t\t\t\t\tBusy       <= 1'b1;\n\t\t\t\t\t\tState      <= Sending;\n\t\t\t\t\tend\n\t\t\t\tend\nSending: begin\n\t\t\t\t\tCount           <= Full;\n\t\t\t\t\t{Temp[6:0], Tx} <= Temp;\n\n\t\t\t\t\tif(~|BitCount) State <= StopBit;\n\t\t\t\t\tBitCount <= BitCount - 1'b1;\n\t\t\t\tend\nStopBit: begin\n\t\t\t\t\tTx    <= 1'b1;\n\t\t\t\t\tCount <= Full;\n\t\t\t\t\tState <= Done;\n\t\t\t\tend\nDone: begin\n\t\t\t\t\tif(~tSend) begin\n\t\t\t\t\t\tBusy  <= 1'b0;\n\t\t\t\t\t\tCount <= 0;\n\t\t\t\t\t\tState <= Idle;\n\t\t\t\t\tend\n\t\t\t\tend\ndefault:;\n\t\t\tendcase\n\t\tend else begin\n\t\t\tCount <= Count - 1'b1;\n\t\tend\n\tend\nend\nendmodule\n",
        "module_name": "UART_Sender #",
        "module_hash": "9b92f3335e520c9a3917c4db478ef1c2",
        "dataset_index": 11903
      },
      "vending_machine_a1e7df99": {
        "rtl_code": "module vending_machine (\n  input clk,\n  input reset,\n  input coin,\n  input button,\n  output reg dispense\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter WAITING = 2'b01;\n  parameter DISPENSING = 2'b10;\n\n  // Define the drinks\n  parameter COKE = 2'b00;\n  parameter SPRITE = 2'b01;\n  parameter FANTA = 2'b10;\n\n  // Define the state and drink variables\n  reg [1:0] state, next_state;\n  reg [1:0] drink, next_drink;\n\n  // Define the counter variables\n  reg [3:0] press_count;\n  reg [3:0] coin_count;\n\n  // Initialize the variables\n  initial begin\n    state = IDLE;\n    drink = COKE;\n    press_count = 0;\n    coin_count = 0;\n    dispense = 0;\n  end\n\n  // Define the state transition and output logic\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      drink <= COKE;\n      press_count <= 0;\n      coin_count <= 0;\n      dispense <= 0;\n    end else begin\n      // Update the state and drink variables\n      state <= next_state;\n      drink <= next_drink;\n\n      // Update the counter variables\n      press_count <= (state == WAITING) ? (press_count + 1) : 0;\n      coin_count <= (state == WAITING) ? (coin_count + 1) : 0;\n\n      // Update the output variable\n      dispense <= (state == DISPENSING);\n\n      // Define the next state and drink based on the current state and inputs\n      case (state)\n        IDLE: begin\n          next_state = coin ? WAITING : IDLE;\n          next_drink = COKE;\n        end\n        WAITING: begin\n          next_state = (press_count >= 5) ? DISPENSING : (coin_count >= 10) ? IDLE : WAITING;\n          next_drink = (button) ? ((coin) ? FANTA : SPRITE) : drink;\n        end\n        DISPENSING: begin\n          next_state = IDLE;\n          next_drink = COKE;\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "a1e7df997350c26de2ff06c424e4af5b",
        "dataset_index": 7784
      },
      "signal_gen_64cb94e5": {
        "rtl_code": "\n\nmodule signal_gen(clk, rst, req, stm_value, rsb, gnt);\n\n\tparameter INPUT_PORTS = 3;\n\tparameter RESET_PORT = 1; parameter RESET_SENS = 0; parameter integer CNT_MAX =  \t(INPUT_PORTS == 1) ? 2 :\n\t\t\t\t\t\t\t\t\t((INPUT_PORTS == 2) ? 4 :\n\t\t\t\t\t\t\t\t\t((INPUT_PORTS == 3) ? 8 :\n\t\t\t\t\t\t\t\t\t((INPUT_PORTS == 4) ? 16 :\n\t\t\t\t\t\t\t\t\t((INPUT_PORTS == 5) ? 32 :\n\t\t\t\t\t\t\t\t\t0))));\n\n\tinput clk;\n\tinput rst;\n\tinput req;\n\t\n\toutput [INPUT_PORTS-1: 0] stm_value; \n\toutput rsb;\n\toutput gnt;\n\n\tparameter PREV_HALF = 1;\n\tparameter PREV_MAX = 2;\n\t\n\tparameter SIZE = 4;\n\tparameter IDLE = 4'b0001;\n\tparameter PREV = 4'b0010;\n\tparameter CURR = 4'b0100;\n\tparameter NEXT = 4'b1000;\n\n\twire [INPUT_PORTS-1: 0] stm_value; \n\twire rsb;\n\treg [INPUT_PORTS-1: 0] symb_value;\n\treg rsb_int;\n\treg gnt;\n\treg\t[SIZE-1:0] state;\n\t\n\tinteger prev_cnt;\n\tinteger curr_cnt;\n\tinteger next_cnt;\n\treg rst_invert;\n\t\n\tassign stm_value = symb_value;\n\tassign rsb = rsb_int;\n\n\talways@(posedge clk)\n\tbegin: FSM\n\t\tif(rst) begin\n\t\t\tstate <= #1 IDLE;\n\t\t\tprev_cnt <= 0;\n\t\t\tcurr_cnt <= 0;\n\t\t\tnext_cnt <= 0;\n\t\t\tsymb_value <= 0;\n\t\t\tgnt <= 1'b0;\n\t\t\tif((RESET_PORT == 1) && (RESET_SENS == 0)) begin\n\t\t\t\trsb_int <= 1'b0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\trsb_int <= 1'b1;\n\t\t\tend\n\t\t\trst_invert <= 1'b0;\n\t\tend \n\t\telse begin\n\t\t\tcase(state)\n\t\t\t\tIDLE : \n\t\t\t\tbegin\n\t\t\t\t\trst_invert <= 1'b0;\n\t\t\t\t\tif (req == 1'b1) begin\n\t\t\t\t\t\tif((RESET_PORT == 1) && (RESET_SENS == 0)) begin\n\t\t\t\t\t\t\trsb_int <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\trsb_int <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\tstate <= #1 PREV;\n\t\t\t\t\tend \n\t\t\t\t\telse begin\n\t\t\t\t\t\tgnt <= 1'b0;\n\t\t\t\t\t\tstate <= #1 IDLE;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tPREV : \n\t\t\t\t\tif (prev_cnt < (PREV_HALF)) begin\n\t\t\t\t\t\tsymb_value <= {INPUT_PORTS{1'b0}}; state <= #1 CURR;\n\t\t\t\t\tend \n\t\t\t\t\telse if((prev_cnt >= (PREV_HALF)) && (prev_cnt < PREV_MAX)) begin\n\t\t\t\t\t\tsymb_value <= {INPUT_PORTS{1'b1}}; state <= #1 CURR;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tsymb_value <= {INPUT_PORTS{1'b0}};\n\t\t\t\t\t\tif((RESET_PORT == 1) && (RESET_SENS == 0)) begin\n\t\t\t\t\t\t\tif(rst_invert == 1'b0) begin\n\t\t\t\t\t\t\t\trsb_int <= 1'b1;\n\t\t\t\t\t\t\t\trst_invert <= 1'b1;\n\t\t\t\t\t\t\t\tprev_cnt <= 0; state <= #1 CURR;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\trsb_int <= 1'b0;\n\t\t\t\t\t\t\t\trst_invert <= 1'b0;\n\t\t\t\t\t\t\t\tgnt <= 1'b1;\n\t\t\t\t\t\t\t\tstate <= #1 IDLE;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if((RESET_PORT == 1) && (RESET_SENS == 1)) begin\n\t\t\t\t\t\t\tif(rst_invert == 1'b0) begin\n\t\t\t\t\t\t\t\trsb_int <= 1'b0;\n\t\t\t\t\t\t\t\trst_invert <= 1'b1;\n\t\t\t\t\t\t\t\tprev_cnt <= 0; state <= #1 CURR;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\trsb_int <= 1'b1;\n\t\t\t\t\t\t\t\trst_invert <= 1'b0;\n\t\t\t\t\t\t\t\tgnt <= 1'b1;\n\t\t\t\t\t\t\t\tstate <= #1 IDLE;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\trsb_int <= 1'b0;\n\t\t\t\t\t\t\tgnt <= 1'b1;\n\t\t\t\t\t\t\tstate <= #1 IDLE; end\n\t\t\t\t\tend\n\t\t\t\tCURR : \n\t\t\t\t\tif (curr_cnt < (CNT_MAX-1)) begin\n\t\t\t\t\t\tsymb_value <= curr_cnt;\n\t\t\t\t\t\tstate <= #1 NEXT;\n\t\t\t\t\tend \n\t\t\t\t\telse begin\n\t\t\t\t\t\tsymb_value <= curr_cnt;\n\t\t\t\t\t\tstate <= #1 NEXT;\n\t\t\t\t\tend\n\t\t\t\tNEXT : \n\t\t\t\t\tif (next_cnt < (CNT_MAX-1)) begin\n\t\t\t\t\t\tsymb_value <= next_cnt;\n\t\t\t\t\t\tnext_cnt <= next_cnt + 1;\n\t\t\t\t\t\tstate <= #1 PREV;\n\t\t\t\t\tend \n\t\t\t\t\telse begin\n\t\t\t\t\t\tsymb_value <= next_cnt;\n\t\t\t\t\t\tnext_cnt <= 0; if (curr_cnt < (CNT_MAX-1)) begin\n\t\t\t\t\t\t\tcurr_cnt <= curr_cnt + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tcurr_cnt <= 0; if(prev_cnt < PREV_MAX) begin\n\t\t\t\t\t\t\t\tprev_cnt <= prev_cnt + 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\tprev_cnt <= 0; end\n\t\t\t\t\t\tend\n\t\t\t\t\t\tstate <= #1 PREV;\n\t\t\t\t\tend\n\t\t\t\tdefault : state <= #1 IDLE;\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n\n",
        "module_name": "signal_gen",
        "module_hash": "64cb94e5583388d315fd47710ce23128",
        "dataset_index": 22273
      },
      "stratixiv_bias_logic_9e301684": {
        "rtl_code": "module stratixiv_bias_logic (\n    input clk,\n    input shiftnld,\n    input captnupdt,\n    output mainclk,\n    output updateclk,\n    output capture,\n    output update\n);\n\nreg mainclk_tmp;\nreg updateclk_tmp;\nreg capture_tmp;\nreg update_tmp;\n\nalways @(*) begin\n    case ({captnupdt, shiftnld})\n        2'b10, 2'b11 :\n            begin\n                mainclk_tmp = 1'b0;\n                updateclk_tmp = clk;\n                capture_tmp = 1'b1;\n                update_tmp = 1'b0;\n            end\n        2'b01 :\n            begin\n                mainclk_tmp = 1'b0;\n                updateclk_tmp = clk;\n                capture_tmp = 1'b0;\n                update_tmp = 1'b0;\n            end\n        2'b00 :\n            begin\n                mainclk_tmp = clk;\n                updateclk_tmp = 1'b0;\n                capture_tmp = 1'b0;\n                update_tmp = 1'b1;\n            end\n        default :\n            begin\n                mainclk_tmp = 1'b0;\n                updateclk_tmp = 1'b0;\n                capture_tmp = 1'b0;\n                update_tmp = 1'b0;\n            end\n    endcase\nend\n\nassign mainclk = mainclk_tmp;\nassign updateclk = updateclk_tmp;\nassign capture = capture_tmp;\nassign update = update_tmp;\n\nendmodule",
        "module_name": "stratixiv_bias_logic",
        "module_hash": "9e30168402b5f1c4f8c7f4aae02e878e",
        "dataset_index": 15785
      },
      "ram_dp_8x512_522e1f5c": {
        "rtl_code": "module ram_dp_8x512\n\t(\n\tclock_a, \n\twren_a,\n\taddress_a, \n\tdata_a, \n\tclock_b,\n\twren_b,\n\taddress_b, \n\tdata_b, \n\tq_a,\n\tq_b\n\t);\n\ninput      \tclock_a;\ninput      \twren_a;\ninput\t[8:0]\taddress_a;\ninput\t[7:0]\tdata_a;\ninput\t\tclock_b;\ninput      \twren_b;\ninput\t[8:0]\taddress_b; \ninput\t[7:0]\tdata_b;\n\noutput\t[7:0]\tq_a, \n\t\tq_b;\n\nreg\t[7:0]\tq_a, \n\t\tq_b;\n\nreg\t[7:0]\tmema\t[0:511];\n\nalways @(posedge clock_a) if(wren_a) mema[address_a] <= data_a;\nalways @(posedge clock_a) q_a <= mema[address_a];\nalways @(posedge clock_b) q_b <= mema[address_b];\n\nendmodule\n",
        "module_name": "ram_dp_8x512",
        "module_hash": "522e1f5c1564f426360a116ed3eae2be",
        "dataset_index": 22454
      },
      "calculator_bf9a215e": {
        "rtl_code": "module calculator(clk, reset, op, in1, in2, out);\n  input clk, reset, op;\n  input [7:0] in1, in2;\n  output reg [7:0] out;\n  \n  always @(posedge clk) begin\n    if(reset) begin\n      out <= 0;\n    end else begin\n      case(op)\n        2'b00: out <= in1 + in2;\n        2'b01: out <= in1 - in2;\n        2'b10: out <= in1 * in2;\n        2'b11: begin\n          if(in2 == 0) begin\n            out <= 0;\n          end else begin\n            out <= in1 / in2;\n          end\n        end\n        default: out <= 0;\n      endcase\n    end\n  end\nendmodule",
        "module_name": "calculator",
        "module_hash": "bf9a215ee0017d84384ae5c475b43b45",
        "dataset_index": 9095
      },
      "top__8ca50310": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input sync_reset, // Synchronous active-high reset\n    input async_reset, // Asynchronous active-high reset\n    output reg [3:1] ena, // Enable signals for digits [3:1]\n    output reg [15:0] q // 4-digit BCD output\n);\n\nreg [3:0] johnson; // Johnson counter\nreg [3:0] count; // Counter for each digit\nreg [3:0] bcd; // BCD value for each digit\n\n// Decoder for generating BCD output\nalways @ (count)\n    case (count)\n        4'b0000: bcd = 4'b0000;\n        4'b0001: bcd = 4'b0001;\n        4'b0010: bcd = 4'b0010;\n        4'b0011: bcd = 4'b0011;\n        4'b0100: bcd = 4'b0100;\n        4'b0101: bcd = 4'b0101;\n        4'b0110: bcd = 4'b0110;\n        4'b0111: bcd = 4'b0111;\n        4'b1000: bcd = 4'b1000;\n        4'b1001: bcd = 4'b1001;\n        default: bcd = 4'b0000;\n    endcase\n\n// Control logic for enabling each digit separately\nalways @ (johnson)\n    case (johnson)\n        4'b0001: ena = 3'b100;\n        4'b0010: ena = 3'b010;\n        4'b0100: ena = 3'b001;\n        default: ena = 3'b000;\n    endcase\n\n// Johnson counter for incrementing digits\nalways @ (posedge clk, posedge sync_reset, posedge async_reset)\n    if (async_reset) begin\n        johnson <= 4'b0001;\n        count <= 4'b0000;\n        q <= 16'b0000000000000000; // Initialize all zeros\n    end else if (sync_reset) begin\n        johnson <= 4'b0001;\n        count <= 4'b0000;\n        q <= 16'b0000000000000000; // Initialize all zeros\n    end else begin\n        johnson <= {johnson[2:0], johnson[3]};\n        case (johnson[3])\n            1'b0: count <= count + 1;\n            1'b1: count <= count;\n        endcase\n        q <= {bcd, bcd, bcd, bcd};\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "8ca50310f2c0fc9400482953e3d55762",
        "dataset_index": 14178
      },
      "tx_fct_send_f2330dc7": {
        "rtl_code": "module tx_fct_send(\n\t\t\tinput pclk_tx,\n\t\t\tinput send_null_tx,\n\t\t\tinput enable_tx,\n\n\t\t\tinput send_fct_now,\n\t\t\tinput fct_sent,\n\t\t\toutput reg [2:0] fct_flag_p\n\t\t  );\n\n\treg [2:0] fct_flag;\n\treg clear_reg_fct_flag;\n\n\treg  [2:0] state_fct_send;\n\treg  [2:0] next_state_fct_send;\n\n\treg  [2:0] state_fct_send_p;\n\treg  [2:0] next_state_fct_send_p;\n\nalways@(*)\nbegin\n\tnext_state_fct_send = state_fct_send;\n\n\tcase(state_fct_send)\n\t3'd0:\n\tbegin\n\t\tif(send_fct_now)\n\t\tbegin\n\t\t\tnext_state_fct_send = 3'd1;\n\t\tend\n\t\telse \n\t\t\tnext_state_fct_send = 3'd0;\n\tend\n\t3'd1:\n\tbegin\n\t\tnext_state_fct_send = 3'd2;\n\tend\n\t3'd2:\n\tbegin\n\t\tif(send_fct_now)\n\t\tbegin\n\t\t\tnext_state_fct_send = 3'd2;\n\t\tend\n\t\telse \n\t\tbegin\n\t\t\tnext_state_fct_send = 3'd0;\n\t\tend\n\tend\n\tdefault:\n\tbegin\n\t\tnext_state_fct_send = 3'd0;\n\tend\n\tendcase\nend\n\nalways@(posedge pclk_tx or negedge enable_tx)\nbegin\n\tif(!enable_tx)\n\tbegin\n\t\tfct_flag <= 3'd0;\n\t\tstate_fct_send<= 3'd0;\n\tend\n\telse if(send_null_tx)\n\tbegin\n\t\tstate_fct_send <= next_state_fct_send;\n\n\t\tcase(state_fct_send)\n\t\t3'd0:\n\t\tbegin\n\t\t\tif(clear_reg_fct_flag)\n\t\t\tbegin\n\t\t\t\tfct_flag <= 3'd0;\n\t\t\tend\n\t\t\telse \n\t\t\tbegin\n\t\t\t\tfct_flag <= fct_flag;\n\t\t\tend\n\t\tend\n\t\t3'd1:\n\t\tbegin\n\t\t\tfct_flag <= fct_flag + 3'd1;\n\t\tend\n\t\t3'd2:\n\t\tbegin\n\t\t\tfct_flag <= fct_flag;\n\t\tend\n\t\tdefault:\n\t\tbegin\n\t\t\tfct_flag <= fct_flag;\n\t\tend\n\t\tendcase\n\tend\nend\n\n\n\n\nalways@(*)\nbegin\n\tnext_state_fct_send_p = state_fct_send_p;\n\n\tcase(state_fct_send_p)\n\t3'd0:\n\tbegin\n\t\tnext_state_fct_send_p = 3'd2;\n\tend\n\t3'd1:\n\tbegin\n\t\tif(fct_flag == 3'd7)\n\t\tbegin\n\t\t\tnext_state_fct_send_p = 3'd2;\n\t\tend\n\t\telse \n\t\t\tnext_state_fct_send_p = 3'd1;\n\tend\n\t3'd2:\n\tbegin\n\t\tif(fct_sent)\n\t\tbegin\n\t\t\tnext_state_fct_send_p = 3'd3;\n\t\tend\n\t\telse \n\t\t\tnext_state_fct_send_p = 3'd2;\n\tend\n\t3'd3:\n\tbegin\n\t\tif(fct_flag_p > 3'd0 && !fct_sent)\n\t\tbegin\n\t\t\tnext_state_fct_send_p = 3'd2;\n\t\tend\n\t\telse if(fct_flag_p == 3'd0 && !fct_sent)\n\t\tbegin\n\t\t\tnext_state_fct_send_p = 3'd1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tnext_state_fct_send_p = 3'd3;\n\t\tend\n\tend\n\tdefault:\n\tbegin\n\t\tnext_state_fct_send_p = 3'd0;\n\tend\n\tendcase\nend\n\nalways@(posedge pclk_tx or negedge enable_tx)\nbegin\n\tif(!enable_tx)\n\tbegin\n\t\tfct_flag_p <= 3'd0;\n\t\tstate_fct_send_p<= 3'd0;\n\t\tclear_reg_fct_flag <=1'b0;\n\tend\n\telse if(send_null_tx)\n\tbegin\n\t\tstate_fct_send_p <= next_state_fct_send_p;\n\n\t\tcase(state_fct_send_p)\n\t\t3'd0:\n\t\tbegin\n\t\t\tclear_reg_fct_flag <=1'b0;\n\t\t\tfct_flag_p <= 3'd7;\n\t\tend\n\t\t3'd1:\n\t\tbegin\n\t\t\tclear_reg_fct_flag <=1'b0;\n\n\t\t\tif(fct_flag == 3'd7)\n\t\t\tbegin\n\t\t\t\tfct_flag_p <= 3'd7;\n\t\t\tend\n\t\t\telse \n\t\t\tbegin\t\n\t\t\t\tfct_flag_p <= fct_flag_p;\t\t\t\t\n\t\t\tend\n\t\tend\n\t\t3'd2:\n\t\tbegin\n\t\t\tclear_reg_fct_flag <=1'b1;\n\n\t\t\tif(fct_sent)\n\t\t\tbegin\n\t\t\t\tfct_flag_p <= fct_flag_p - 3'd1;\n\t\t\tend\n\t\t\telse \n\t\t\tbegin\n\t\t\t\tfct_flag_p <= fct_flag_p;\n\t\t\tend\n\t\tend\n\t\t3'd3:\n\t\tbegin\n\t\t\tclear_reg_fct_flag <=1'b0;\n\t\t\tfct_flag_p <= fct_flag_p;\n\t\tend\n\t\tdefault:\n\t\tbegin\n\t\t\tfct_flag_p <= fct_flag_p;\n\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule",
        "module_name": "tx_fct_send",
        "module_hash": "f2330dc77571c5aeca12d512489429f0",
        "dataset_index": 16540
      },
      "SEG_HEX_4489e538": {
        "rtl_code": "module SEG_HEX\n\t(\n\t\tiDIG,\t\t\t\t\t\t\t\n\t\toHEX_D\t\t\n\t);\n\ninput\t  [3:0]   iDIG;\t\t\t\t\noutput\t  [6:0]\t  oHEX_D;   \n\n\nreg\t  [6:0]\t  oHEX_D;\t\n\nalways @(iDIG) \n        begin\n\t\t\tcase(iDIG)\n\t\t\t4'h0: oHEX_D <= 7'b1000000; 4'h1: oHEX_D <= 7'b1111001; 4'h2: oHEX_D <= 7'b0100100; 4'h3: oHEX_D <= 7'b0110000; 4'h4: oHEX_D <= 7'b0011001; 4'h5: oHEX_D <= 7'b0010010; 4'h6: oHEX_D <= 7'b0000010; 4'h7: oHEX_D <= 7'b1111000; 4'h8: oHEX_D <= 7'b0000000; 4'h9: oHEX_D <= 7'b0011000; 4'ha: oHEX_D <= 7'b0001000; 4'hb: oHEX_D <= 7'b0000011; 4'hc: oHEX_D <= 7'b1000110; 4'hd: oHEX_D <= 7'b0100001; 4'he: oHEX_D <= 7'b0000110; 4'hf: oHEX_D <= 7'b0001110; default: oHEX_D <= 7'b1000000; endcase\n\t\tend\n\nendmodule\n",
        "module_name": "SEG_HEX",
        "module_hash": "4489e538eb5c1044fb29e04437b003a5",
        "dataset_index": 23215
      },
      "shift_register_comparator_428f8a2a": {
        "rtl_code": "module shift_register_comparator (\n    input clk,\n    input reset,\n    input serial_data,\n    input [7:0] parallel_data,\n    output reg match\n);\n\nreg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 8'b0;\n        match <= 1'b0;\n    end else begin\n        shift_reg <= {shift_reg[6:0], serial_data};\n        if (shift_reg == parallel_data) begin\n            match <= 1'b1;\n        end else begin\n            match <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "shift_register_comparator",
        "module_hash": "428f8a2ac2bac5b424e9a36f38764c2e",
        "dataset_index": 8898
      },
      "sky130_fd_sc_lp__a2bb2o_1a9f448a": {
        "rtl_code": "module sky130_fd_sc_lp__a2bb2o (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    // Module ports\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Local signals\n    wire and0_out ;\n    wire nor0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , B1, B2            );\n    nor nor0 (nor0_out , A1_N, A2_N        );\n    or  or0  (or0_out_X, nor0_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a2bb2o",
        "module_hash": "1a9f448a7ed4495d26295c3b1db2bd53",
        "dataset_index": 7534
      },
      "counter_1798e6cf": {
        "rtl_code": "module counter(\n  input clk,\n  input rst,\n  input up_down,\n  output reg [7:0] out\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      out <= 8'd0;\n    end else begin\n      if (up_down) begin\n        if (out == 8'd255) begin\n          out <= 8'd0;\n        end else begin\n          out <= out + 1;\n        end\n      end else begin\n        if (out == 8'd0) begin\n          out <= 8'd255;\n        end else begin\n          out <= out - 1;\n        end\n      end\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "1798e6cfce216e3114ddf52abb284687",
        "dataset_index": 10493
      },
      "FSM_b0841fb9": {
        "rtl_code": "module FSM (\n  input [n-1:0] in,\n  output reg [m-1:0] out\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter s = 4; // number of states\n\n// Define sub-states for each state\nparameter S0_0 = 2'b00;\nparameter S0_1 = 2'b01;\nparameter S1_0 = 2'b10;\nparameter S1_1 = 2'b11;\n\nreg [1:0] state; // current state\n\n// Define transition logic between sub-states\nalways @ (in) begin\n  case (state)\n    S0_0: begin\n      // define output and next state based on input\n      out <= {in[0], in[1]};\n      if (in[2] == 1) begin\n        state <= S0_1;\n      end\n    end\n    S0_1: begin\n      // define output and next state based on input\n      out <= {in[3], in[2]};\n      if (in[1] == 1) begin\n        state <= S1_0;\n      end\n    end\n    S1_0: begin\n      // define output and next state based on input\n      out <= {in[0], in[3]};\n      if (in[2] == 1) begin\n        state <= S1_1;\n      end\n    end\n    S1_1: begin\n      // define output and next state based on input\n      out <= {in[1], in[2]};\n      if (in[0] == 1) begin\n        state <= S0_0;\n      end\n    end\n  endcase\nend\n\nendmodule",
        "module_name": "FSM",
        "module_hash": "b0841fb916677aa1ed5f451cacc518b8",
        "dataset_index": 10814
      },
      "sky130_fd_sc_ls__and4_12d56e21": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__and4",
        "module_hash": "12d56e218e43715cb841d61b5aadcc2a",
        "dataset_index": 18967
      },
      "top_module_b8935937": {
        "rtl_code": "module top_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] out\n);\n\nwire [3:0] adder_output;\nwire [3:0] shift_output;\n\nfour_bit_adder adder_inst(\n    .a(a),\n    .b(b),\n    .sum(adder_output)\n);\n\nshift_register shift_reg_inst(\n    .data_in(adder_output),\n    .shift_output(shift_output)\n);\n\nxor_output xor_output_inst(\n    .shift_data(shift_output),\n    .b(b),\n    .out(out)\n);\n\nendmodule\n\nmodule four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n\nwire c1, c2, c3;\n\nfull_adder fa0(\n    .a(a[0]),\n    .b(b[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(c1)\n);\n\nfull_adder fa1(\n    .a(a[1]),\n    .b(b[1]),\n    .cin(c1),\n    .sum(sum[1]),\n    .cout(c2)\n);\n\nfull_adder fa2(\n    .a(a[2]),\n    .b(b[2]),\n    .cin(c2),\n    .sum(sum[2]),\n    .cout(c3)\n);\n\nfull_adder fa3(\n    .a(a[3]),\n    .b(b[3]),\n    .cin(c3),\n    .sum(sum[3]),\n    .cout()\n);\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule shift_register(\n    input [3:0] data_in,\n    output [3:0] shift_output\n);\n\nreg [3:0] data_reg;\n\nalways @(data_in) begin\n    data_reg <= {data_in[2:0], data_in[3]};\nend\n\nassign shift_output = data_reg;\n\nendmodule\n\nmodule xor_output(\n    input [3:0] shift_data,\n    input [3:0] b,\n    output [3:0] out\n);\n\nassign out = shift_data ^ b;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "b893593778ca191e9540b34a382cc709",
        "dataset_index": 2265
      },
      "dff_async_set_clear_4278b438": {
        "rtl_code": "module dff_async_set_clear (\n    Q,\n    Q_N,\n    CLK,\n    D,\n    SET,\n    CLR\n);\n\n    output Q;\n    output Q_N;\n    input CLK;\n    input D;\n    input SET;\n    input CLR;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    reg Q_reg;\n    assign Q = Q_reg;\n    assign Q_N = ~Q_reg;\n\n    always @(posedge CLK) begin\n        if (SET) begin\n            Q_reg <= 1;\n        end else if (CLR) begin\n            Q_reg <= 0;\n        end else begin\n            Q_reg <= D;\n        end\n    end\n\nendmodule",
        "module_name": "dff_async_set_clear",
        "module_hash": "4278b438140c2f0f2b30da34ae3d5aac",
        "dataset_index": 14365
      },
      "three_input_gate_6e4c0f85": {
        "rtl_code": "module three_input_gate(\n    input A1,\n    input A2,\n    input B1,\n    output reg X\n);\n\n    always @ (A1, A2, B1)\n    begin\n        if (A1 == 1 && A2 == 1 && B1 == 1) begin\n            X <= 1;\n        end\n        else begin\n            X <= 0;\n        end\n    end\n\nendmodule",
        "module_name": "three_input_gate",
        "module_hash": "6e4c0f857349f6ca0d5832a971c74484",
        "dataset_index": 16897
      },
      "dffs_37_b24b5973": {
        "rtl_code": "\nmodule dffs_37 ( clk, set, d, q );\n\t// synthesis attribute keep_hierarchy dffs_37 \"true\";\n\tinput clk;\n\tinput set;\n\tinput [36:0] d;\n\toutput [36:0] q;\n\treg [36:0] q;\n\t`ifdef RANDOM_INIT\n\tinitial\n\t$random_init(\"q\");\n\t`endif\n\t`ifdef CHK_RESET_EOS\n\tassert_quiescent_state #(0,1,0, \n\t\"***ERROR ASSERT: set still asserted at end of simulation\")\n\ta0(.clk(clk),.reset_n(1'b1), .state_expr(set),\n\t.check_value(1'b0), .sample_event(1'b0));\n\t`endif\n\n\talways @(posedge clk) begin\n\tif (set)\n\tq <= ~(37'b0);\n\telse\n\tq <= d;\n\tend\nendmodule",
        "module_name": "dffs_37",
        "module_hash": "b24b5973a53c5d5e11da49437f51803a",
        "dataset_index": 21388
      },
      "top__49598c34": {
        "rtl_code": "module top_module (\n    input [3:0] load_value,\n    input [3:0] shift_value,\n    input up_down,\n    input shift_dir,\n    input clk,\n    input reset,\n    output [3:0] RESULT\n);\n\n    reg [3:0] counter;\n    reg [3:0] shifted_value;\n    reg [1:0] select;\n    \n    always @ (posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            counter <= 4'b0;\n            shifted_value <= 4'b0;\n            select <= 2'b0;\n        end else begin\n            if (up_down == 1) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= counter - 1;\n            end\n            \n            if (select == 2'b01) begin\n                shifted_value <= {shift_value[2:0], 1'b0};\n            end else if (select == 2'b10) begin\n                shifted_value <= {1'b0, shift_value[3:1]};\n            end else begin\n                shifted_value <= shift_value;\n            end\n            \n            if (shift_dir == 1) begin\n                select <= 2'b10;\n            end else begin\n                select <= 2'b01;\n            end\n        end\n    end\n    \n    assign RESULT = (select == 2'b00) ? counter : shifted_value; // Fix the syntax error in the always block\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "49598c346a18395ab7d479ef8ff07952",
        "dataset_index": 465
      },
      "barrel_shifter_93dc3f20": {
        "rtl_code": "module barrel_shifter (\n  input [31:0] data_in,\n  input [4:0] shift_amount,\n  output [31:0] data_out,\n  output zero_flag\n);\n\n  reg [31:0] shifted_data;\n  wire [31:0] mux_input [0:31];\n  wire [4:0] shift_amount_inv;\n  wire [4:0] shift_amount_inv_plus_one;\n\n  assign shift_amount_inv = ~shift_amount;\n  assign shift_amount_inv_plus_one = shift_amount_inv + 1;\n\n  // Generate all possible shift amounts\n  assign mux_input[0] = data_in;\n  generate\n    genvar i;\n    for (i = 1; i < 32; i = i + 1) begin\n      assign mux_input[i] = {mux_input[i-1][shift_amount_inv_plus_one-1:0], mux_input[i-1][31:shift_amount_inv_plus_one]};\n    end\n  endgenerate\n\n  // Select the output based on the shift amount\n  assign data_out = mux_input[shift_amount];\n\n  // Check if the output is zero\n  assign zero_flag = (data_out == 0);\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "93dc3f20d656f6172a6406f9d71c4a88",
        "dataset_index": 6890
      },
      "ripple_carry_adder_b34a1938": {
        "rtl_code": "module ripple_carry_adder(\n  input [3:0] a,\n  input [3:0] b,\n  output [3:0] sum,\n  output carry_out\n);\n\n  wire [3:0] carry;\n  full_adder fa0(a[0], b[0], 1'b0, carry[0], sum[0]);\n  full_adder fa1(a[1], b[1], carry[0], carry[1], sum[1]);\n  full_adder fa2(a[2], b[2], carry[1], carry[2], sum[2]);\n  full_adder fa3(a[3], b[3], carry[2], carry_out, sum[3]);\n\nendmodule\n\nmodule full_adder(\n  input a, b, cin,\n  output cout, sum\n);\n\n  assign {cout, sum} = a + b + cin;\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "b34a1938401ed0d17d69f68bb2607164",
        "dataset_index": 17029
      },
      "dff_sr_55e3afd2": {
        "rtl_code": "module dff_sr (CK, D, S, R, Q, QN);\ninput  CK ;\ninput  D ;\ninput  S ;\ninput  R ;\noutput Q ;\noutput QN ;\nreg    Q ;\n\nalways @(posedge CK)\nbegin\n   if (S)\n      Q <= 1'b1;\n   else if (R)\n      Q <= 1'b0;\n   else\n      Q <= D;\nend\n\nassign QN = ~Q;\n\nendmodule",
        "module_name": "dff_sr",
        "module_hash": "55e3afd209fd3aa9fc1ae696d4ad996a",
        "dataset_index": 16410
      },
      "pipelined_circuit_5a4d4711": {
        "rtl_code": "module pipelined_circuit(\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nwire [3:0] stage1_out;\nwire [2:0] stage2_out;\n\n// Stage 1\nassign stage1_out[0] = in[0] & in[1];\nassign stage1_out[1] = in[2] & in[3];\nassign stage1_out[2] = stage1_out[0] | stage1_out[1];\nassign stage1_out[3] = stage1_out[0] ^ stage1_out[1];\n\n// Stage 2\nassign stage2_out[0] = stage1_out[0] & stage1_out[1];\nassign stage2_out[1] = stage1_out[2] | stage1_out[3];\nassign stage2_out[2] = stage1_out[2] ^ stage1_out[3];\n\n// Output\nassign out_and = stage2_out[0];\nassign out_or = stage2_out[1];\nassign out_xor = stage2_out[2];\n\nendmodule\n\nmodule top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\npipelined_circuit pc(\n    .in(in),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xor(out_xor)\n);\n\nendmodule",
        "module_name": "pipelined_circuit",
        "module_hash": "5a4d471119aa0a03bc75eb2eab0c0e32",
        "dataset_index": 9573
      },
      "fsm_0101_sequence_detection_4e7856d1": {
        "rtl_code": "module fsm_0101_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  output reg match\n);\n\n  // Define the states\n  parameter STATE_IDLE = 2'b00;\n  parameter STATE_WAIT_1 = 2'b01;\n  parameter STATE_WAIT_2 = 2'b10;\n  parameter STATE_MATCH = 2'b11;\n  \n  // Define the state register and next state logic\n  reg [1:0] state, next_state;\n  \n  always @ (posedge clk) begin\n    if (reset) begin\n      state <= STATE_IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n  \n  // Define the next state logic\n  always @ (*) begin\n    case (state)\n      STATE_IDLE: begin\n        if (data == 1'b0) begin\n          next_state = STATE_WAIT_1;\n        end else begin\n          next_state = STATE_IDLE;\n        end\n      end\n      \n      STATE_WAIT_1: begin\n        if (data == 1'b1) begin\n          next_state = STATE_WAIT_2;\n        end else begin\n          next_state = STATE_IDLE;\n        end\n      end\n      \n      STATE_WAIT_2: begin\n        if (data == 1'b0) begin\n          next_state = STATE_MATCH;\n        end else begin\n          next_state = STATE_IDLE;\n        end\n      end\n      \n      STATE_MATCH: begin\n        next_state = STATE_IDLE;\n      end\n    endcase\n  end\n  \n  // Define the match output\n  always @ (*) begin\n    if (state == STATE_MATCH) begin\n      match = 1'b1;\n    end else begin\n      match = 1'b0;\n    end\n  end\n  \nendmodule\n",
        "module_name": "fsm_0101_sequence_detection",
        "module_hash": "4e7856d1323b7ca5985aa59d0d90e95a",
        "dataset_index": 12350
      },
      "binary_to_7seg_ba60c1e6": {
        "rtl_code": "module binary_to_7seg(\n  input [3:0] bin_in,\n  output reg [6:0] seg_out\n);\n\n  always @ (bin_in)\n    case (bin_in)\n      4'b0000: seg_out = 7'b0011111;\n      4'b0001: seg_out = 7'b0000110;\n      4'b0010: seg_out = 7'b0101101;\n      4'b0011: seg_out = 7'b0100111;\n      4'b0100: seg_out = 7'b0110011;\n      4'b0101: seg_out = 7'b0111011;\n      4'b0110: seg_out = 7'b1111011;\n      4'b0111: seg_out = 7'b0001111;\n      4'b1000: seg_out = 7'b1111111;\n      4'b1001: seg_out = 7'b0111111;\n      4'b1010: seg_out = 7'b1011111;\n      4'b1011: seg_out = 7'b1111000;\n      4'b1100: seg_out = 7'b0011100;\n      4'b1101: seg_out = 7'b0101110;\n      4'b1110: seg_out = 7'b1111101;\n      4'b1111: seg_out = 7'b1110001;\n      default: seg_out = 7'b1111111;\n    endcase // case (bin_in)\n\nendmodule",
        "module_name": "binary_to_7seg",
        "module_hash": "ba60c1e6f89b7263d6a3a4232e641a18",
        "dataset_index": 625
      },
      "TLATNTSCAX2TS_26a59efd": {
        "rtl_code": "\nmodule TLATNTSCAX2TS (E, SE, CK, ECK);\n  input E, SE, CK;\n  output ECK;\n\n  assign ECK = E & SE;\n\nendmodule\n",
        "module_name": "TLATNTSCAX2TS",
        "module_hash": "26a59efda5cd8d408bd228c7c6483a56",
        "dataset_index": 20835
      },
      "sky130_fd_sc_ls__nor2_1_644fbe64": {
        "rtl_code": "module sky130_fd_sc_ls__nor2_1 (\n    output Y,\n    input A,\n    input B\n);\n\n    sky130_fd_sc_ls__nor2 base (\n        .Y(Y),\n        .A(A),\n        .B(B)\n    );\n\nendmodule\n\nmodule sky130_fd_sc_ls__nor2 (\n    output Y,\n    input A,\n    input B\n);\n\n    assign Y = ~(A | B);\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__nor2_1",
        "module_hash": "644fbe64637156c962bf4782e16e887e",
        "dataset_index": 4116
      },
      "logic__3032dd30": {
        "rtl_code": "module logic_module (\n    A,\n    B,\n    C,\n    D,\n    E,\n    F,\n    G,\n    H,\n    X\n);\n\n    input A;\n    input B;\n    input C;\n    input D;\n    input E;\n    input F;\n    input G;\n    input H;\n    output X;\n\n    wire and0_out;\n    wire or0_out;\n    wire and1_out;\n    wire or1_out;\n\n    and and0 (and0_out, A, B);\n    or or0 (or0_out, C, D);\n    and and1 (and1_out, E, F);\n    or or1 (or1_out, G, H);\n\n    assign X = (and0_out || or0_out || !and1_out || !or1_out);\n\nendmodule",
        "module_name": "logic_",
        "module_hash": "3032dd304b42da028b186e741a0e32bc",
        "dataset_index": 19235
      },
      "multiply_fc1bd72e": {
        "rtl_code": "module multiply(\n\tinput clock, reset, start,\n\tinput [7:0] multiplicand, multiplier,\n\toutput [15:0] PR,\n\toutput Ready\n);\nwire Zero, Load_regs, Add_dec;\ncontroller_m m0(clock, reset, start, Zero, Ready, Load_regs, Add_dec);\ndatapath_m m1(clock, reset, multiplicand, multiplier, Load_regs, Add_dec, PR, Zero);\nendmodule\n\nmodule controller_m(\n\tinput clock, reset, start, Zero,\n\toutput Ready, Load_regs, Add_dec\n);\nparameter S_Idle = 1'b0, S_Mul = 1'b1;\nreg state, next_state;\nalways @(posedge clock, posedge reset)\n\tif (reset)\n\t\tstate <= S_Idle;\n\telse\n\t\tstate <= next_state;\n\nalways @(*)\nbegin\n\tcase (state)\n\t\tS_Idle: next_state = Load_regs ? S_Mul : S_Idle;\n\t\tS_Mul: next_state = Add_dec ? S_Mul : S_Idle;\n\t\tdefault: next_state = 1'bx;\n\tendcase\nend\n\nassign Ready = state == S_Idle;\nassign Load_regs = Ready & start;\nassign Add_dec = (state == S_Mul & ~Zero);\nendmodule\n\nmodule datapath_m(\n\tinput clock, reset,\n\tinput [7:0] multiplicand, multiplier,\n\tinput Load_regs, Add_dec,\n\toutput reg [15:0] PR,\n\toutput Zero\n);\nreg [7:0] AR, BR;\nalways @(posedge clock, posedge reset)\n\tif (reset) begin\n\t\tAR <= 8'b0;\n\t\tBR <= 8'b0;\n\t\tPR <= 16'b0;\n\tend else if (Load_regs) begin\n\t\tAR <= multiplier;\n\t\tBR <= multiplicand;\n\t\tPR <= 16'b0;\n\tend else if (Add_dec) begin\n\t\tPR <= PR + BR;\n\t\tAR <= AR - 1;\n\tend\n\nassign Zero = AR == 8'b0;\nendmodule\n",
        "module_name": "multiply",
        "module_hash": "fc1bd72e1527f389a7e2df872d9f80c0",
        "dataset_index": 18382
      },
      "ch_eq_59a080df": {
        "rtl_code": "\nmodule ch_eq (\n  input [n-1:0] in,\n  input [m-1:0] chan,\n  output [n-1:0] out\n);\n\nparameter n = 4; // number of input and output signals\nparameter m = 2; // number of channel response signals\n\n// Define the frequency response of the channel\nfunction [n-1:0] freq_resp;\n  input [m-1:0] chan_resp;\n  begin\n    // Define the frequency response as the absolute value of the channel response\n    freq_resp = abs(chan_resp);\n  end\nendfunction\n\n// Define the inverse of the channel frequency response\nfunction [n-1:0] inv_freq_resp;\n  input [m-1:0] chan_resp;\n  begin\n    // Calculate the inverse of the frequency response by taking the reciprocal of each element\n    inv_freq_resp = {n{1'b0}} / chan_resp;\n  end\nendfunction\n\n// Calculate the equalized signal using the inverse of the channel frequency response\nassign out = in * inv_freq_resp(chan);\n\nendmodule",
        "module_name": "ch_eq",
        "module_hash": "59a080df67e3c6bdf110c8fa25a40e1d",
        "dataset_index": 4902
      },
      "SpecialCases_8470744d": {
        "rtl_code": "\nmodule SpecialCases(\n\tinput [31:0] ain_Special,\n\tinput [31:0] bin_Special,\n\tinput [31:0] cin_Special,\n\tinput [1:0] mode_Special,\n\tinput operation_Special,\n\tinput NatLogFlag_Special,\n\tinput [7:0] InsTagFSMOut,\n\tinput reset,\n\tinput clock,\n\toutput reg [1:0] idle_Special = 1'b00,\n\toutput reg [32:0] aout_Special,\n\toutput reg [32:0] bout_Special,\n\toutput reg [35:0] cout_Special,\n\toutput reg [35:0] zout_Special,\n\toutput reg [31:0] sout_Special,\n\toutput reg [1:0]  modeout_Special,\n\toutput reg operationout_Special,\n\toutput reg NatLogFlagout_Special,\n\toutput reg [7:0] InsTag_Special\n   );\n\nwire a_sign;\nwire [7:0] a_exponent;\nwire [23:0] a_mantissa;\n\nwire b_sign;\nwire [7:0] b_exponent;\nwire [23:0] b_mantissa;\n\nwire c_sign;\nwire [7:0] c_exponent;\nwire [26:0] c_mantissa;\n\nassign a_sign = ain_Special[31];\nassign a_exponent = {ain_Special[30:23] - 127};\nassign a_mantissa = {1'b0, ain_Special[22:0]};\n\nassign b_sign = {bin_Special[31]};\nassign b_exponent = {bin_Special[30:23] - 127};\nassign b_mantissa = {1'b0, bin_Special[22:0]};\n\nassign c_sign = {cin_Special[31]};\nassign c_exponent = {cin_Special[30:23] - 127};\nassign c_mantissa = {cin_Special[22:0],3'd0};\n\nparameter no_idle = 2'b00,\n\t\t\t allign_idle = 2'b01,\n\t\t\t put_idle = 2'b10;\n\nalways @ (posedge clock)\nbegin\n   \n\tif(reset == 1'b1) begin\n\t\tidle_Special <= 1'b00;\n\tend\n\t\n\telse begin\n\tInsTag_Special <= InsTagFSMOut;\n\tmodeout_Special <= mode_Special;\n\toperationout_Special <= operation_Special;\n\tNatLogFlagout_Special <= NatLogFlag_Special;\n\t\n\tif ((a_exponent == 128 && a_mantissa != 0) || (b_exponent == 128 && b_mantissa != 0)) begin\n\t\t idle_Special <= allign_idle;\n\t\t aout_Special <= {a_sign,a_exponent+127,a_mantissa};\n\t\t bout_Special <= {b_sign,b_exponent+127,b_mantissa};\n\t\t cout_Special <= {c_sign,c_exponent+127,c_mantissa};\n\t\t zout_Special <= {1'b1,8'd255,1'b1,26'd0};\n\t\t sout_Special <= 0;\n   end else if (a_exponent == 128) begin\n\t\t idle_Special <= allign_idle;\n\t\t if ($signed(b_exponent == -127) && (b_mantissa == 0)) begin\n\t\t\t  idle_Special <= allign_idle;\n\t\t\t  aout_Special <= {a_sign,a_exponent,a_mantissa};\n\t\t     bout_Special <= {b_sign,b_exponent,b_mantissa};\n\t\t     cout_Special <= {c_sign,c_exponent,c_mantissa};\n\t\t     zout_Special <= {1'b1,8'd255,1'b1,26'd0};\n\t\t     sout_Special <= 0;\n       end\n\t\t else begin\n\t\t\t\taout_Special <= {a_sign,a_exponent,a_mantissa};\n\t\t\t\tbout_Special <= {b_sign,b_exponent,b_mantissa};\n\t\t\t\tcout_Special <= {c_sign,c_exponent,c_mantissa};\n\t\t\t\tzout_Special <= {a_sign ^ b_sign,8'd255,27'd0};\n\t\t\t\tsout_Special <= 0;\n\t\t end\n   end else if (b_exponent == 128) begin\n\t\t idle_Special <= allign_idle;\n\t\t aout_Special <= {a_sign,a_exponent,a_mantissa};\n\t\t bout_Special <= {b_sign,b_exponent,b_mantissa};\n\t\t cout_Special <= {c_sign,c_exponent,c_mantissa};\n\t\t zout_Special <= {a_sign ^ b_sign,8'd255,27'd0};\n\t\t sout_Special <= 0;\n   end else if (($signed(a_exponent) == -127) && (a_mantissa == 0)) begin\n\t\t idle_Special <= put_idle;\n\t\t aout_Special[32] <= a_sign; \n\t\t aout_Special[31:24] <= a_exponent+127;\n\t\t aout_Special[23] <= 1'b1;\n\t\t aout_Special[22:0] <= a_mantissa[22:0];\n\t\t bout_Special[32] <= b_sign; \n\t\t bout_Special[31:24] <= b_exponent+127;\n\t\t bout_Special[23] <= 1'b1;\n\t\t bout_Special[22:0] <= b_mantissa[22:0];\n\t\t cout_Special[35] <= c_sign; \n\t\t cout_Special[34:27] <= c_exponent+127;\n\t\t cout_Special[26:0] <= c_mantissa[26:0];\n\t\t zout_Special <= {a_sign ^ b_sign,8'd0,27'd0};\n\t\t sout_Special <= {c_sign,c_exponent + 127,c_mantissa[25:3]};\n   end else if (($signed(b_exponent) == -127) && (b_mantissa == 0)) begin\n\t\t aout_Special[32] <= a_sign; \n\t\t aout_Special[31:24] <= a_exponent+127;\n\t\t aout_Special[23] <= 1'b1;\n\t\t aout_Special[22:0] <= a_mantissa[22:0];\n\t\t bout_Special[32] <= b_sign; \n\t\t bout_Special[31:24] <= b_exponent+127;\n\t\t bout_Special[23] <= 1'b1;\n\t\t bout_Special[22:0] <= b_mantissa[22:0];\n\t\t cout_Special[35] <= c_sign; \n\t\t cout_Special[35] <= c_sign; \n\t\t cout_Special[34:27] <= c_exponent+127;\n\t\t cout_Special[26:0] <= c_mantissa[26:0];\n\t\t zout_Special <= {a_sign ^ b_sign,8'd0,27'd0};\n\t\t sout_Special <= {c_sign,c_exponent + 127,c_mantissa[25:3]};\t\t \n\t\t idle_Special <= put_idle;\n   end else if (mode_Special == 2'b00) begin\n\t\t idle_Special <= put_idle;\n\t\t aout_Special[32] <= a_sign; \n\t\t aout_Special[31:24] <= a_exponent+127;\n\t\t aout_Special[23] <= 1'b1;\n\t\t aout_Special[22:0] <= a_mantissa[22:0];\n\t\t bout_Special[32] <= b_sign; \n\t\t bout_Special[31:24] <= b_exponent+127;\n\t\t bout_Special[23] <= 1'b1;\n\t\t bout_Special[22:0] <= b_mantissa[22:0];\n\t\t cout_Special[35] <= c_sign; \n\t\t cout_Special[34:27] <= c_exponent+127;\n\t\t cout_Special[26:0] <= c_mantissa[26:0];\n\t\t zout_Special <= {a_sign ^ b_sign,8'd0,27'd0};\n\t\t sout_Special <= {c_sign,c_exponent + 127,c_mantissa[25:3]};\n   end else begin\n       cout_Special[35] <= c_sign; \n\t\t cout_Special[34:27] <= c_exponent+127;\n\t\t cout_Special[26:0] <= c_mantissa[26:0];\n\t\t zout_Special <= 0;\n\t\t sout_Special <= 0;\n\t\t idle_Special <= no_idle;\n       if ($signed(a_exponent) == -127) begin\n           aout_Special <= {a_sign,-126,a_mantissa};\n       end else begin\n\t\t\t  aout_Special[32] <= a_sign; \n\t\t\t  aout_Special[31:24] <= a_exponent+127;\n\t\t\t  aout_Special[23] <= 1'b1;\n\t\t\t  aout_Special[22:0] <= a_mantissa[22:0];\n       end\n       if ($signed(b_exponent) == -127) begin\n           bout_Special <= {b_sign,-126,b_mantissa};\n       end else begin\n\t\t\t  bout_Special[32] <= b_sign; \n\t\t\t  bout_Special[31:24] <= b_exponent+127;\n\t\t\t  bout_Special[23] <= 1'b1;\n\t\t\t  bout_Special[22:0] <= b_mantissa[22:0];\n       end\n   end\n\tend\nend\n\nendmodule\n",
        "module_name": "SpecialCases",
        "module_hash": "8470744dad191d71c7421be9c49f8355",
        "dataset_index": 8367
      },
      "or1200_fpu_pre_norm_mul_b4a933c8": {
        "rtl_code": "module or1200_fpu_pre_norm_mul (\n\t\t     clk_i,\n\t\t     opa_i,\n\t\t     opb_i,\n\t\t     exp_10_o,\n\t\t     fracta_24_o,\n\t\t     fractb_24_o\n\t\t     );\n\n   parameter FP_WIDTH = 32;\n   parameter MUL_SERIAL = 0; parameter MUL_COUNT = 11; parameter FRAC_WIDTH = 23;\n   parameter EXP_WIDTH = 8;\n   parameter ZERO_VECTOR = 31'd0;\n   parameter INF = 31'b1111111100000000000000000000000;\n   parameter QNAN = 31'b1111111110000000000000000000000;\n   parameter SNAN = 31'b1111111100000000000000000000001;\n\n\n   input clk_i;\n   input [FP_WIDTH-1:0] opa_i;\n   input [FP_WIDTH-1:0] opb_i;\n   output reg [EXP_WIDTH+1:0] exp_10_o;\n   output [FRAC_WIDTH:0] fracta_24_o;\n   output [FRAC_WIDTH:0] fractb_24_o; \n\n   \n   wire [EXP_WIDTH-1:0]      s_expa;\n   wire [EXP_WIDTH-1:0]      s_expb;\n   \n   wire [FRAC_WIDTH-1:0]     s_fracta;\n   wire [FRAC_WIDTH-1:0]     s_fractb;\n\n   wire [EXP_WIDTH+1:0]      s_exp_10_o;\n   wire [EXP_WIDTH+1:0]      s_expa_in;\n   wire [EXP_WIDTH+1:0]      s_expb_in;\n   \n   wire \t\t     s_opa_dn, s_opb_dn;\n\n   assign s_expa = opa_i[30:23];\n   assign s_expb = opb_i[30:23];\n   assign s_fracta = opa_i[22:0];\n   assign s_fractb = opb_i[22:0];\n   \n   always @(posedge clk_i)\n     exp_10_o <= s_exp_10_o;\n   \n   assign s_opa_dn = !(|s_expa);\n   assign s_opb_dn = !(|s_expb);\n   \n   assign fracta_24_o = {!s_opa_dn, s_fracta};\n   assign fractb_24_o = {!s_opb_dn, s_fractb};\n   \n   assign s_expa_in = {2'd0, s_expa} + {9'd0, s_opa_dn};\n   assign s_expb_in = {2'd0, s_expb} + {9'd0, s_opb_dn};\n   \n   assign s_exp_10_o = s_expa_in + s_expb_in - 10'b0001111111;\t\t\n\nendmodule ",
        "module_name": "or1200_fpu_pre_norm_mul",
        "module_hash": "b4a933c8f869ccc8ebfd0b340edbf68b",
        "dataset_index": 24894
      },
      "CORDIC_FSM_v3_212b3211": {
        "rtl_code": "\n\nmodule CORDIC_FSM_v3\n(\n  input wire clk,\t\t\t\t\t\t\t\t\t\t\tinput wire reset,\t\t\t\t\t\t\t\t\t\tinput wire beg_FSM_CORDIC,\t\t\t\t\t\t\t\tinput wire ACK_FSM_CORDIC,\t\t\t\t\t\t\t\tinput wire exception,\n  input wire max_tick_iter, \t\t\tinput wire max_tick_var, \t\t\t\tinput wire enab_dff_z,\n\n  output reg reset_reg_cordic,\n  output reg ready_CORDIC,\t\t\t\t\t\t\t\toutput reg beg_add_subt,\t\t\t\t\t\t\t\toutput reg enab_cont_iter,\t\t\t\toutput reg enab_cont_var,\t\t\t\toutput reg enab_RB1, enab_RB2, enab_RB3,\n  output reg enab_d_ff5_data_out\n);\n\nlocalparam [3:0]    est0 = 0,\n                    est1 = 1,\n                    est2 = 2,\n                    est3 = 3,\n                    est4 = 4,\n                    est5 = 5,\n                    est6 = 6,\n                    est7 = 7;\n\n\nreg [3:0] state_reg, state_next;\talways @( posedge clk, posedge reset)\n    begin\n        if(reset)\tstate_reg <= est0;\n        else\t\tstate_reg <= state_next;\n    end\n\nalways @*\n    begin\n    state_next = state_reg; reset_reg_cordic = 0;\n    enab_RB1 = 0;\n    enab_RB2 = 0;\n    enab_RB3 = 0;\n    enab_cont_var  = 0;\n    enab_cont_iter = 0;\n    enab_d_ff5_data_out = 0;\n    ready_CORDIC = 0;\n    beg_add_subt = 0;\n\n    case(state_reg)\n\n    est0:\n    begin\n      reset_reg_cordic = 1'b1;\n      enab_RB1 = 1'b1;\n      if(beg_FSM_CORDIC) begin\n        state_next = est1;\n      end else begin\n        state_next = est0;\n      end\n    end\n\n\t\test1:\n\t\tbegin\n      enab_RB1 = 1'b1;\n\t\t\tstate_next = est2;\n\t\tend\n\n    est2:\n    begin\n      enab_RB2 = 1'b1;\n\t\t\tif(exception) begin\n\t\t\t\tstate_next = est0;\n\t\t\tend else begin\n\t\t\t\tstate_next = est3;\n      end\n    end\n\n    est3:\n    begin\n      enab_RB3 = 1'b1;\n\t\t\tstate_next = est4;\n    end\n\n    est4:\n    begin\n      enab_cont_var = 1'b1; beg_add_subt = 1'b1;\n      if (max_tick_var) begin\n        state_next = est5;\n      end else begin\n        state_next = est4;\n      end\n    end\n\n    est5:\n    begin\n      beg_add_subt = 1'b1;\n      if (enab_dff_z) begin\n        state_next = est6;\n      end else begin\n        state_next = est5;\n      end\n    end\n\n    est6:\n    begin\n      enab_cont_iter = 1'b1; enab_cont_var = 1'b1; if (max_tick_iter) begin\n        state_next = est7; enab_d_ff5_data_out = 1;\n      end else begin\n        state_next = est2; end\n    end\n\n    est7:\n    begin\n      ready_CORDIC = 1'b1;\n      enab_d_ff5_data_out = 1'b1;\n      if(ACK_FSM_CORDIC) begin\n        state_next = est0;\n      end else begin\n        state_next = est7;\n      end\n    end\n\n    default :\n      begin\n        state_next = est0;\n      end\n\n    endcase\n  end\nendmodule\n",
        "module_name": "CORDIC_FSM_v3",
        "module_hash": "212b3211fc1b3d33b829040e3db97d98",
        "dataset_index": 12086
      },
      "UniversalCounter8bits_79751422": {
        "rtl_code": "\nmodule UniversalCounter8bits (\n    input CLOCK, Reset, S1, S0,\n    input [7:0] P, BeginCount, EndCount,\n    output reg [7:0] Q,\n    output reg TerminalCount\n);\n\nalways @ (posedge CLOCK or posedge Reset) begin\n    if (Reset) begin\n        Q <= 8'd0;\n        TerminalCount <= 0;\n    end\n    else begin\n        case ({S1, S0})\n            2'b00: begin // Hold mode\n                Q <= Q;\n                TerminalCount <= 0;\n            end\n            2'b01: begin // Count up mode\n                if (Q == EndCount) begin\n                    Q <= BeginCount;\n                    TerminalCount <= 1;\n                end\n                else begin\n                    Q <= Q + 1;\n                    TerminalCount <= 0;\n                end\n            end\n            2'b10: begin // Count down mode\n                if (Q == BeginCount) begin\n                    Q <= EndCount;\n                    TerminalCount <= 1;\n                end\n                else begin\n                    Q <= Q - 1;\n                    TerminalCount <= 0;\n                end\n            end\n            2'b11: begin // Parallel load mode\n                Q <= P;\n                TerminalCount <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "UniversalCounter8bits",
        "module_hash": "79751422d2fc3119febce0372fea27ff",
        "dataset_index": 16444
      },
      "shift_register_4bit_e53b7bdb": {
        "rtl_code": "\nmodule shift_register_4bit (\n  input SI, CLK,\n  output Q3, SO\n);\n  reg [3:0] shift_reg;\n  reg [3:0] next_reg;\n  wire [2:0] stage1_out;\n  wire [2:0] stage2_out;\n  wire [2:0] stage3_out;\n\n  assign SO = shift_reg[0];\n  assign Q3 = shift_reg[3];\n\n  // Pipeline Stage 1\n  always @ (posedge CLK) begin\n    next_reg[0] <= SI;\n    next_reg[1] <= shift_reg[0];\n    next_reg[2] <= shift_reg[1];\n    next_reg[3] <= shift_reg[2];\n  end\n\n  // Pipeline Stage 2\n  always @ (posedge CLK) begin\n    shift_reg[0] <= stage1_out[0];\n    shift_reg[1] <= stage1_out[1];\n    shift_reg[2] <= stage1_out[2];\n  end\n\n  // Pipeline Stage 3\n  always @ (posedge CLK) begin\n    shift_reg[3] <= stage2_out[0];\n  end\n\n  // Pipeline Stage 1 Logic\n  assign stage1_out[0] = next_reg[0];\n  assign stage1_out[1] = next_reg[1];\n  assign stage1_out[2] = next_reg[2];\n\n  // Pipeline Stage 2 Logic\n  assign stage2_out[0] = next_reg[3];\n\nendmodule",
        "module_name": "shift_register_4bit",
        "module_hash": "e53b7bdb8a01b4fa9b26a7bca792ed0b",
        "dataset_index": 12796
      },
      "mbus_wire_ctrl_25eee441": {
        "rtl_code": "\nmodule mbus_wire_ctrl(\n\tinput RESETn,\n\tinput DOUT_FROM_BUS,\n\tinput CLKOUT_FROM_BUS,\n\t`ifdef POWER_GATING\n\tinput DIN,\n\tinput CLKIN,\n\tinput RELEASE_ISO_FROM_SLEEP_CTRL,\n\tinput EXTERNAL_INT,\n\t`endif\n\toutput reg DOUT,\n\toutput reg CLKOUT\n);\n\n`ifdef POWER_GATING\nalways @ *\nbegin\n\tif (~RESETn)\n\t\tCLKOUT <= 1'b1;\n\telse if (RELEASE_ISO_FROM_SLEEP_CTRL==`IO_HOLD)\n\t\tCLKOUT <= CLKIN;\n\telse\n\t\tCLKOUT <= CLKOUT_FROM_BUS;\n\n\tif (~RESETn)\n\t\tDOUT <= 1'b1;\n\telse if (EXTERNAL_INT)\n\t\tDOUT <= 0;\n\telse\n\tbegin\n\t\tif (RELEASE_ISO_FROM_SLEEP_CTRL==`IO_HOLD)\n\t\t\tDOUT <= DIN;\n\t\telse\n\t\t\tDOUT <= DOUT_FROM_BUS;\n\tend\nend\n`else\nalways @ *\nbegin\n\tif (~RESETn)\n\t\tCLKOUT <= 1'b1;\n\telse\n\t\tCLKOUT <= CLKOUT_FROM_BUS;\n\n\tif (~RESETn)\n\t\tDOUT <= 1'b1;\n\telse\n\t\tDOUT <= DOUT_FROM_BUS;\nend\n`endif\n\nendmodule",
        "module_name": "mbus_wire_ctrl",
        "module_hash": "25eee441cd25d48368a4bb4f6cd4779f",
        "dataset_index": 3414
      },
      "nor_gate_b5f7753d": {
        "rtl_code": "module nor_gate (\n    input a,\n    input b,\n    output out\n);\n\nwire nand1_out, nand2_out;\n\nnand nand1 (nand1_out, a, a);\nnand nand2 (nand2_out, b, b);\nnand nand3 (out, nand1_out, nand2_out);\n\nendmodule",
        "module_name": "nor_gate",
        "module_hash": "b5f7753d6f001243fc6e3161a3613cf8",
        "dataset_index": 10175
      },
      "my__a81786fa": {
        "rtl_code": "\nmodule my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire nand0_out        ;\n    wire nand1_out        ;\n    wire and0_out_Y       ;\n\n    //                                 Name         Output             Other arguments\n    nand                               nand0       (nand0_out        , A2, A1                );\n    nand                               nand1       (nand1_out        , B2, B1                );\n    and                                and0        (and0_out_Y       , nand0_out, nand1_out  );\n    buf                                buf0        (Y                , and0_out_Y     );\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "a81786fa9be01fc6d8a51eabf727b688",
        "dataset_index": 14666
      },
      "Nerf_Sentry_sm3_b0fbc727": {
        "rtl_code": "module Nerf_Sentry_sm3(clock, uart, recieved, reset, pos, fire);\n\tinput clock;\n\tinput [7:0] uart;\n\tinput recieved;\n\tinput reset;\n\toutput reg [7:0] pos;\n\toutput reg fire;\n\treg [4:0] state;\n\treg [7:0] fireReg;\n\treg [7:0] x100, x010, x001;\n\t\n\tparameter IDLE = 5'b00000,\n\t\t\t    X100 = 5'b00001,\n\t\t\t\t X010 = 5'b00010,\n\t\t\t\t X001 = 5'b00011,\n\t\t\t    Y100 = 5'b00100,\n\t\t\t\t Y010 = 5'b00101,\n\t\t\t\t Y001 = 5'b00110,\n\t\t\t\t FIRE = 5'b00111,\n\t\t\t\t FIRESEL = 5'b01000,\n\t\t\t\t SCANSEL = 5'b01001,\n\t\t\t\t BIDLE = 5'b01011,\n\t\t\t    BX100 = 5'b01100,\n\t\t\t\t BX010 = 5'b01101,\n\t\t\t\t BX001 = 5'b01110,\n\t\t\t    BY100 = 5'b01111,\n\t\t\t\t BY010 = 5'b10000,\n\t\t\t\t BY001 = 5'b10001,\n\t\t\t\t BFIRE = 5'b10010,\n\t\t\t\t BFIRESEL = 5'b10011,\n\t\t\t\t BSCANSEL = 5'b10100;\n\t\n\talways @ (posedge clock)\n\t\tbegin\n\t\t\tcase(state)\n\t\t\t\tBIDLE: \n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BIDLE;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend\n\t\t\t\tIDLE: begin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (uart[7:0] == 8'b01100001)\n\t\t\t\t\t\t\t\t\tstate <= BX100;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tBX100:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BX100;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= X100;\n\t\t\t\t\tend\n\t\t\t\tX100: begin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BX010;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= X100;\n\t\t\t\t\tend\n\t\t\t\tBX010:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BX010;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= X010;\n\t\t\t\t\tend\n\t\t\t\tX010:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BX001;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= X010;\n\t\t\t\t\tend\n\t\t\t\tBX001:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BX001;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= X001;\n\t\t\t\t\tend\n\t\t\t\tX001: \n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BY100;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= X001;\n\t\t\t\t\tend\n\t\t\t\tBY100:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BY100;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= Y100;\n\t\t\t\t\tend\n\t\t\t\tY100: \n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BY010;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= Y100;\n\t\t\t\t\tend\n\t\t\t\tBY010:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BY010;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= Y010;\n\t\t\t\t\tend\n\t\t\t\tY010: \n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BY001;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= Y010;\n\t\t\t\t\tend\n\t\t\t\tBY001:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BY001;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= Y001;\n\t\t\t\t\tend\n\t\t\t\tY001:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BFIRE;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= Y001;\n\t\t\t\t\tend\n\t\t\t\tBFIRE:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BFIRE;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= FIRE;\n\t\t\t\t\tend\n\t\t\t\tFIRE:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BFIRESEL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= FIRE;\n\t\t\t\t\tend\n\t\t\t\tBFIRESEL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BFIRESEL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= FIRESEL;\n\t\t\t\t\tend\n\t\t\t\tFIRESEL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BSCANSEL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= FIRESEL;\n\t\t\t\t\tend\n\t\t\t\tBSCANSEL:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BSCANSEL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= SCANSEL;\n\t\t\t\t\tend\n\t\t\t\tSCANSEL: \n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (recieved == 1)\n\t\t\t\t\t\t\tstate <= BIDLE;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= SCANSEL;\n\t\t\t\t\tend\n\t\t\t\tdefault: ;endcase\n\t\tend\n\t\n\talways @ (posedge clock)\n\t\tbegin\n\t\t\tcase(state)\n\t\t\t\tIDLE: \n\t\t\t\tbegin\n\t\t\t\t\tpos[7:0] <= ((x100 - 8'b00110000) * 8'b01100100) + ((x010 - 8'b00110000) * 8'b00001010) + (x001 - 8'b00110000);\n\t\t\t\t\tfire <= fireReg[0];\n\t\t\t\tend\n\t\t\t\tX100: x100[7:0] <= uart[7:0];\n\t\t\t\tX010: x010[7:0] <= uart[7:0];\n\t\t\t\tX001: x001[7:0] <= uart[7:0];\n\t\t\t\tFIRE: fireReg[7:0] <= uart[7:0];\n\t\t\t\tdefault: ;\n\t\t\tendcase\n\t\t\t\n\t\tend\n\nendmodule",
        "module_name": "Nerf_Sentry_sm3",
        "module_hash": "b0fbc727be799103691a7d7422886b29",
        "dataset_index": 13498
      },
      "vending_machine_e674e212": {
        "rtl_code": "module vending_machine (\n  input clk,\n  input reset,\n  input [3:0] coin,\n  input [3:0] selection,\n  output reg dispense,\n  output reg [3:0] change\n);\n\n// Define the states\nparameter IDLE = 2'b00;\nparameter SELECT = 2'b01;\nparameter DISPENSE = 2'b10;\n\n// Define the state register and initialize to IDLE state\nreg [1:0] state = IDLE;\n\n// Define the coin and selection registers\nreg [3:0] coins_inserted;\nreg [3:0] product_selected;\n\n// Define the product prices\nparameter [3:0] PRODUCT_A_PRICE = 4;\nparameter [3:0] PRODUCT_B_PRICE = 6;\n\n// Define the change register\nreg [3:0] change_due;\n\n// Define the state machine\nalways @(posedge clk, posedge reset) begin\n  if (reset) begin\n    state <= IDLE;\n    coins_inserted <= 4'b0;\n    product_selected <= 4'b0;\n    dispense <= 1'b0;\n    change <= 4'b0;\n  end else begin\n    case (state)\n      IDLE: begin\n        if (coin != 4'b0) begin\n          coins_inserted <= coins_inserted + coin;\n          state <= SELECT;\n        end\n      end\n      SELECT: begin\n        if (selection == 4'b0001 && coins_inserted >= PRODUCT_A_PRICE) begin\n          product_selected <= selection;\n          coins_inserted <= coins_inserted - PRODUCT_A_PRICE;\n          state <= DISPENSE;\n        end else if (selection == 4'b0010 && coins_inserted >= PRODUCT_B_PRICE) begin\n          product_selected <= selection;\n          coins_inserted <= coins_inserted - PRODUCT_B_PRICE;\n          state <= DISPENSE;\n        end else if (selection != 4'b0000) begin\n          state <= SELECT;\n        end\n      end\n      DISPENSE: begin\n        dispense <= 1'b1;\n        change_due <= coins_inserted;\n        coins_inserted <= 4'b0;\n        product_selected <= 4'b0;\n        state <= IDLE;\n        change <= change_due;\n      end\n    endcase\n  end\nend\n\nendmodule\n",
        "module_name": "vending_machine",
        "module_hash": "e674e212804966bd62f91b07f1ba7703",
        "dataset_index": 13725
      },
      "bin_to_gray_a608a684": {
        "rtl_code": "module bin_to_gray(input [3:0] bin_in, output [3:0] gray_out);\n\n  assign gray_out[0] = bin_in[0];\n  assign gray_out[1] = bin_in[0] ^ bin_in[1];\n  assign gray_out[2] = bin_in[1] ^ bin_in[2];\n  assign gray_out[3] = bin_in[2] ^ bin_in[3];\n\nendmodule",
        "module_name": "bin_to_gray",
        "module_hash": "a608a684bb9ded5b033092013c821ef1",
        "dataset_index": 9013
      },
      "top__99feaa3a": {
        "rtl_code": "module top_module (\n    input [15:0] data_in, // Input for binary ones counter module\n    input [3:0] LOAD, // Input for up-down counter module\n    output [3:0] Q, // Output from up-down counter module\n    output [3:0] ones_count, // Output from binary ones counter module\n    output [3:0] final_output // Final output after adding both module outputs\n);\n\n// Instantiate binary ones counter module\nbinary_ones_counter boc (\n    .data_in(data_in),\n    .ones_count(ones_count)\n);\n\n// Instantiate up-down counter module\nup_down_counter udc (\n    .LOAD(LOAD),\n    .Q(Q)\n);\n\n// Instantiate adder module\nadder add (\n    .A(ones_count),\n    .B(Q),\n    .SUM(final_output)\n);\n\nendmodule\n\n// Binary ones counter module\nmodule binary_ones_counter (\n    input [15:0] data_in,\n    output [3:0] ones_count\n);\n\nassign ones_count = data_in[0] + data_in[1] + data_in[2] + data_in[3] + data_in[4] + data_in[5] + data_in[6] + data_in[7] + data_in[8] + data_in[9] + data_in[10] + data_in[11] + data_in[12] + data_in[13] + data_in[14] + data_in[15];\n\nendmodule\n\n// Up-down counter module\nmodule up_down_counter (\n    input [3:0] LOAD,\n    output [3:0] Q\n);\n\nreg [3:0] count;\nalways @(LOAD) begin\n    count <= LOAD;\nend\n\nassign Q = count;\n\nendmodule\n\n// Adder module\nmodule adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n\nassign SUM = A + B;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "99feaa3a02be3ff56bf85c245d2daaeb",
        "dataset_index": 19162
      },
      "Freq_Divider#_a42b57ca": {
        "rtl_code": "\n\n\nmodule Freq_Divider#(\n  parameter sys_clk = 50000000,\tclk_out = 1\t\t\t\t)\n  (Clk_in, Clk_out);\n\n  input wire Clk_in;\n\n  output reg Clk_out;\n  \nparameter max = sys_clk / (2*clk_out); localparam N=log2(max);\treg [N-1:0]counter = 0; always@(posedge Clk_in) begin\n    if (counter == max-1)\n      begin\n        counter <= 0;\n        Clk_out <= ~Clk_out;\n      end\n    else\n      begin\n        counter <= counter + 1'd1;\n      end\n  end\n\n  function integer log2(input integer n);\n    integer i;\n    begin\n      log2=1;\n      for (i=0; 2**i < n; i=i+1)\n        log2=i+1;\n    end\n\n  endfunction\n\nendmodule\n",
        "module_name": "Freq_Divider#",
        "module_hash": "a42b57cad49bd844dad5142eff088e46",
        "dataset_index": 15952
      },
      "bitwise_rotation_41cd6cc7": {
        "rtl_code": "module bitwise_rotation(\n    input [25:0] Data_i,\n    input select_i,\n    input bit_shift_i,\n    input clk,\n    output reg [25:0] Data_o\n);\n\nreg [25:0] temp;\n\nalways @(posedge clk) begin\n    if (select_i == 0) begin\n        temp[25:1] = Data_i[24:0];\n        temp[0] = Data_i[25];\n    end else begin\n        temp[24:0] = Data_i[25:1];\n        temp[25] = Data_i[0];\n    end\n\n    if (bit_shift_i == 0) begin\n        Data_o <= temp;\n    end else begin\n        if (select_i == 0) begin\n            Data_o[25] <= temp[0];\n            Data_o[24:0] <= temp[25:1];\n        end else begin\n            Data_o[0] <= temp[25];\n            Data_o[25:1] <= temp[24:0];\n        end\n    end\nend\n\nendmodule",
        "module_name": "bitwise_rotation",
        "module_hash": "41cd6cc7eb620c17a6eac790d0b4df13",
        "dataset_index": 814
      },
      "sky130_fd_sc_ls__nor4bb_65d70603": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__nor4bb (\n    Y  ,\n    A  ,\n    B  ,\n    C_N,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n    input  D_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out  ;\n    wire and0_out_Y;\n\n    nor nor0 (nor0_out  , A, B              );\n    and and0 (and0_out_Y, nor0_out, C_N, D_N);\n    buf buf0 (Y         , and0_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__nor4bb",
        "module_hash": "65d70603a22c5a251cf5fc468e1f3adf",
        "dataset_index": 22589
      },
      "full_adder_9fb500a8": {
        "rtl_code": "\nmodule full_adder (\n  input A,\n  input B,\n  input cin,\n  output sum,\n  output cout\n);\n\nassign sum = A ^ B ^ cin;\nassign cout = (A & B) | (cin & (A ^ B));\n\nendmodule\nmodule binary_multiplier (\n  input [3:0] A,\n  input [3:0] B,\n  output [7:0] P\n);\n\nwire [3:0] S0, S1, S2, S3;\nwire [3:0] C0, C1, C2, C3;\n\nfull_adder fa0(A[0], B[0], 1'b0, S0[0], C0[0]);\nfull_adder fa1(A[1], B[0], C0[0], S0[1], C0[1]);\nfull_adder fa2(A[2], B[0], C0[1], S0[2], C0[2]);\nfull_adder fa3(A[3], B[0], C0[2], S0[3], C0[3]);\n\nfull_adder fa4(A[0], B[1], 1'b0, S1[0], C1[0]);\nfull_adder fa5(A[1], B[1], C1[0], S1[1], C1[1]);\nfull_adder fa6(A[2], B[1], C1[1], S1[2], C1[2]);\nfull_adder fa7(A[3], B[1], C1[2], S1[3], C1[3]);\n\nfull_adder fa8(A[0], B[2], 1'b0, S2[0], C2[0]);\nfull_adder fa9(A[1], B[2], C2[0], S2[1], C2[1]);\nfull_adder fa10(A[2], B[2], C2[1], S2[2], C2[2]);\nfull_adder fa11(A[3], B[2], C2[2], S2[3], C2[3]);\n\nfull_adder fa12(A[0], B[3], 1'b0, S3[0], C3[0]);\nfull_adder fa13(A[1], B[3], C3[0], S3[1], C3[1]);\nfull_adder fa14(A[2], B[3], C3[1], S3[2], C3[2]);\nfull_adder fa15(A[3], B[3], C3[2], S3[3], C3[3]);\n\nassign P = {C3[3], C3[2], C3[1], C3[0], S3, S2, S1, S0};\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "9fb500a8df84e84577ba28dd822abc3e",
        "dataset_index": 806
      },
      "vgafb_ctlif #_790f5b1d": {
        "rtl_code": "\n\nmodule vgafb_ctlif #(\n\tparameter csr_addr = 4'h0,\n\tparameter fml_depth = 26\n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\tinput [13:0] csr_a,\n\tinput csr_we,\n\tinput [31:0] csr_di,\n\toutput reg [31:0] csr_do,\n\t\n\toutput reg vga_rst,\n\t\n\toutput reg [10:0] hres,\n\toutput reg [10:0] hsync_start,\n\toutput reg [10:0] hsync_end,\n\toutput reg [10:0] hscan,\n\t\n\toutput reg [10:0] vres,\n\toutput reg [10:0] vsync_start,\n\toutput reg [10:0] vsync_end,\n\toutput reg [10:0] vscan,\n\t\n\toutput reg [fml_depth-1:0] baseaddress,\n\tinput baseaddress_ack,\n\t\n\toutput reg [17:0] nbursts,\n\n\toutput reg [1:0] vga_clk_sel\n);\n\nreg [fml_depth-1:0] baseaddress_act;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tbaseaddress_act <= {fml_depth{1'b0}};\n\telse if(baseaddress_ack)\n\t\tbaseaddress_act <= baseaddress;\nend\n\nwire csr_selected = csr_a[13:10] == csr_addr;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tcsr_do <= 32'd0;\n\t\t\n\t\tvga_rst <= 1'b1;\n\t\t\n\t\thres <= 10'd640;\n\t\thsync_start <= 10'd656;\n\t\thsync_end <= 10'd752;\n\t\thscan <= 10'd799;\n\t\t\n\t\tvres <= 10'd480;\n\t\tvsync_start <= 10'd491;\n\t\tvsync_end <= 10'd493;\n\t\tvscan <= 10'd523;\n\t\t\n\t\tbaseaddress <= {fml_depth{1'b0}};\n\t\t\n\t\tnbursts <= 18'd19200;\n\t\tvga_clk_sel <= 2'b00;\n\tend else begin\n\t\tcsr_do <= 32'd0;\n\t\tif(csr_selected) begin\n\t\t\tif(csr_we) begin\n\t\t\t\tcase(csr_a[3:0])\n\t\t\t\t\t4'd0: vga_rst <= csr_di[0];\n\t\t\t\t\t4'd1: hres <= csr_di[10:0];\n\t\t\t\t\t4'd2: hsync_start <= csr_di[10:0];\n\t\t\t\t\t4'd3: hsync_end <= csr_di[10:0];\n\t\t\t\t\t4'd4: hscan <= csr_di[10:0];\n\t\t\t\t\t4'd5: vres <= csr_di[10:0];\n\t\t\t\t\t4'd6: vsync_start <= csr_di[10:0];\n\t\t\t\t\t4'd7: vsync_end <= csr_di[10:0];\n\t\t\t\t\t4'd8: vscan <= csr_di[10:0];\n\t\t\t\t\t4'd9: baseaddress <= csr_di[fml_depth-1:0];\n\t\t\t\t\t4'd11: nbursts <= csr_di[17:0];\n\t\t\t\t\t4'd12: vga_clk_sel <= csr_di[1:0];\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t\n\t\t\tcase(csr_a[3:0])\n\t\t\t\t4'd0: csr_do <= vga_rst;\n\t\t\t\t4'd1: csr_do <= hres;\n\t\t\t\t4'd2: csr_do <= hsync_start;\n\t\t\t\t4'd3: csr_do <= hsync_end;\n\t\t\t\t4'd4: csr_do <= hscan;\n\t\t\t\t4'd5: csr_do <= vres;\n\t\t\t\t4'd6: csr_do <= vsync_start;\n\t\t\t\t4'd7: csr_do <= vsync_end;\n\t\t\t\t4'd8: csr_do <= vscan;\n\t\t\t\t4'd9: csr_do <= baseaddress;\n\t\t\t\t4'd10: csr_do <= baseaddress_act;\n\t\t\t\t4'd11: csr_do <= nbursts;\n\t\t\t\t4'd12: csr_do <= vga_clk_sel;\n\t\t\tendcase\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "vgafb_ctlif #",
        "module_hash": "790f5b1da2be968cfad95db59dc4ff8b",
        "dataset_index": 23659
      },
      "sky130_fd_sc_hd__o2bb2a_5b5c1fe6": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__o2bb2a (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out ;\n    wire or0_out   ;\n    wire and0_out_X;\n\n    nand nand0 (nand0_out , A2_N, A1_N        );\n    or   or0   (or0_out   , B2, B1            );\n    and  and0  (and0_out_X, nand0_out, or0_out);\n    buf  buf0  (X         , and0_out_X        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__o2bb2a",
        "module_hash": "5b5c1fe6ab5d41af00182f933f91ff6d",
        "dataset_index": 10955
      },
      "top__68e70b49": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input SER_IN,\n    input SH_EN,\n    output reg [7:0] q\n);\n\n    // Instantiate the 4-bit counter module\n    wire [3:0] counter;\n    counter_module counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .q(counter)\n    );\n\n    // Instantiate the 4-bit shift register module\n    wire [3:0] shift_reg;\n    shift_register_module shift_reg_inst (\n        .clk(clk),\n        .SER_IN(SER_IN),\n        .SH_EN(SH_EN),\n        .reset(reset),\n        .q(shift_reg)\n    );\n\n    // Combine the counter and shift register outputs into an 8-bit output\n    always @(*) begin\n        q = {counter, shift_reg};\n    end\n\nendmodule\nmodule counter_module (\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1'b1;\n        end\n    end\n\nendmodule\nmodule shift_register_module (\n    input clk,\n    input SER_IN,\n    input SH_EN,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (SH_EN) begin\n            q <= {q[2:0], SER_IN};\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "68e70b49591ecec2a65ebc04b375829e",
        "dataset_index": 8701
      },
      "my__fc553128": {
        "rtl_code": "\nmodule my_module (\n    input  wire [7:0] di,\n    output wire [7:0] do\n);\n\n    // Output bits 0-4 should be the same as input bits 0-4\n    wire [4:0] forwarded;\n    assign forwarded[4] = di[4];\n    assign forwarded[3] = di[3];\n    assign forwarded[2] = di[2];\n    assign forwarded[1] = di[1];\n    assign forwarded[0] = di[0];\n    assign do[0] = forwarded[0];\n    assign do[1] = forwarded[1];\n    assign do[2] = forwarded[2];\n    assign do[3] = forwarded[3];\n    assign do[4] = forwarded[4];\n\n    // Output bit 5 should be the logical NOT of input bit 5\n    assign do[5] = ~di[5];\n\n    // Output bit 6 should be the logical NOT of input bit 6\n    assign do[6] = ~di[6];\n\n    // Output bit 7 should be the logical NOT of input bit 7\n    assign do[7] = ~di[7];\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "fc553128bef50c31b4c1f37329d82bec",
        "dataset_index": 21089
      },
      "reg8_46eaa3a0": {
        "rtl_code": "\n \n\n\nmodule reg8(\n\tinput clk,\n\tinput ce,\n\tinput [7:0] in,\n\toutput [7:0] out);\n  \n\treg [8:0] register;\n\t\n\tinitial register = 8'h00;\n  \n\tassign out = register;\n  \n\talways @(posedge clk) begin\n\t\tif(ce) begin\n\t\t\tregister = in;\n\t\tend\n\tend\nendmodule\n\n\n \nmodule divby1248(\n\tinput clk,\n\tinput cein,\n\tinput [1:0] divisor,\n\toutput ceout);\n\t\n\t\n\treg ceoutmux;\n\t\n\treg [2:0] counter;\n\t\n\tinitial counter = 0;\n\t\n\tassign ceout = ceoutmux;\n\t\n\talways @(posedge clk) begin\n\t\tif(cein)\n\t\t\tcounter <= counter + 1;\n\tend\n\t\n\talways @(*) begin\n\t\tcase(divisor)\n\t\t\t2'b00:\n\t\t\t\tceoutmux <= cein;\n\t\t\t2'b01:\n\t\t\t\tceoutmux <= cein & counter[0];\n\t\t\t2'b10: \n\t\t\t\tceoutmux <= cein & counter[0] & counter[1];\n\t\t\t2'b11:\n\t\t\t\tceoutmux <= cein & counter[0] & counter[1] & counter[2];\n\t\t\tdefault:\n\t\t\t\tceoutmux <= 1'bx;\n\t\tendcase\n\tend\nendmodule\n\n\n\nmodule fixeddivby2(\n\tinput clk,\n\tinput cein,\n\toutput ceout);\n\n\treg q;\n\t\t\n\tinitial q = 0;\n\t\n\tassign ceout = cein & q;\n\n\talways @(posedge clk) begin\n\t\tif(cein)\n\t\t\tq = ~q;\n\tend\n\t\nendmodule\n\n\n\n\n\nmodule fixeddivby32(\n\tinput clk,\n\tinput cein,\n\toutput ceout);\n\t\n\treg ceoutreg = 0;\n\treg ceoutregs = 0;\n\treg [4:0] counter = 0;\n\t\n\tassign ceout = ceoutregs;\n\t\n\talways @(*) begin\n\t\tif(counter == 31)\n\t\t\tceoutreg <= cein;\n\t\telse\n\t\t\tceoutreg <= 0;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tceoutregs <= ceoutreg;\n\t\tif(cein)\n\t\t\tcounter <= counter + 1;\n\tend\nendmodule\n\n\n\nmodule fixeddivby256(\n\tinput clk,\n\tinput cein,\n\toutput ceout);\n\t\n\treg ceoutreg = 0;\n\treg ceoutregs = 0;\n\treg [7:0] counter = 0;\n\t\n\t\n\tassign ceout = ceoutregs;\n\t\n\talways @(*) begin\n\t\tif(counter == 255)\n\t\t\tceoutreg <= cein;\n\t\telse\n\t\t\tceoutreg <= 0;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tceoutregs <= ceoutreg;\n\t\tif(cein)\n\t\t\tcounter <= counter + 1;\n\tend\nendmodule\n\n\n\n\n\nmodule wdtimer(\n\tinput clk,\n\tinput cein,\n\tinput enable,\n\tinput wdreset,\n\tinput wdogdis,\n\tinput [7:0] wdogdivreg,\n\toutput wdtripce);\n\t\n\treg [7:0] counter = 0;\n\treg wdtripcesreg = 0;\n\treg wdtripcereg = 0;\n\treg wdogdisreg = 0;\n\t\n\t\n\tassign wdtripce = wdtripcesreg;\n\t\n\talways @(*) begin\n\t\tif ((wdogdivreg == counter) && ~wdreset && enable && ~wdogdisreg)\n\t\t\twdtripcereg <= cein;\n\t\telse\n\t\t\twdtripcereg <= 0;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\twdtripcesreg <= wdtripcereg;\n\t\twdogdisreg = wdogdis;\n\t\t\n\t\tif(enable & ~wdreset & ~wdogdisreg) begin\n\t\t\tif(cein)\n\t\t\t\tcounter <= counter + 1;\n\t\tend\n\t\telse\n\t\t\tcounter <= 8'h00;\n\tend\nendmodule\n\n\n\n\t\t\nmodule wdregister(\n\tinput clk,\n\tinput ctrlld,\n\tinput wdtripce,\n\tinput wdogdis,\n\tinput [7:0] wrtdata,\n\toutput motorenaint,\n\toutput run0,\n\toutput run1,\n\toutput run2,\n\toutput [7:0] controlrdata);\n\t\n\treg motorenaintreg = 0;\n\treg wdtrip = 0;\n\treg [7:0] controlreg = 0;\n\treg [7:0] controlrdatareg;\n\n\t\n\tassign motorenaint = motorenaintreg;\n\tassign run0 = controlreg[0];\n\tassign run1 = controlreg[1];\n\tassign run2 = controlreg[2];\n\t\n\tassign controlrdata = controlrdatareg;\n\t\n\talways @(*) begin\n\t\tcontrolrdatareg <= {wdtrip, wdogdis, 1'b0, 1'b0, controlreg[3:0]};\n\t\tmotorenaintreg <=  ~wdtrip & controlreg[3];\n\tend\n\t\n\t\n\talways @(posedge clk) begin\n\t\tif(ctrlld)\n\t\t    controlreg <= wrtdata;\n\t\tif(wdtripce)\n\t\t\twdtrip <= 1;\n\t\tif(ctrlld && ( wrtdata == 8'h80))\n\t\t\twdtrip <= 0;\n\tend\nendmodule\n\t\t\t\nmodule ledctr(\n\tinput clk,\n\tinput ce,\n\toutput ledalive);\n\t\n\treg [9:0] counter = 0;\n\t\n\tassign ledalive = counter[9];\n\t\n\t\n\talways @ (posedge clk) begin\n\t\tif(ce)\n\t\t\tcounter <= counter + 1;\n\tend\nendmodule\n\n\t\t\n\t\t\n\t\n\t\n\t\n\n\nmodule control(\n\toutput pwmcntce0,\n\toutput pwmcntce1,\n\toutput pwmcntce2,\n\toutput filterce0,\n\toutput filterce1,\n\toutput filterce2,\n\toutput invphase0,\n\toutput invphase1,\n\toutput invphase2,\n\toutput invertpwm0,\n\toutput invertpwm1,\n\toutput invertpwm2,\n\toutput run0,\n\toutput run1,\n\toutput run2,\n\toutput motorenaint,\n\toutput ledalive,\n\toutput [7:0] controlrdata,\n\toutput [7:0] hwconfig,\n\toutput [7:0] configrdreg0,\n\toutput [7:0] configrdreg1,\n\toutput [7:0] configrdreg2,\n\tinput clk,\n\tinput cfgld0,\n\tinput cfgld1,\n\tinput cfgld2,\n\tinput ctrlld,\n\tinput wdogdivld,\n\tinput tst,\n\tinput wdogdis,\n\tinput wdreset,\n\tinput [7:0] wrtdata);\n\n\t\n\twire [7:0] configreg0;\n\twire [7:0] configreg1;\n\twire [7:0] configreg2;\n\t\n\twire [7:0] wdogdivreg;\n\twire ce32;\n\twire ce64;\n\twire ce16384;\n\twire cfgce0;\n\twire cfgce1;\n\twire cfgce2;\n\twire wdogdivregce;\n\twire wdtripce;\n\t\n\treg wdogcntce;\n\t\n\t\n\t\n\t\n\treg tie1 = 1;\n\t\n\tassign configrdreg0 = configreg0;\n\tassign configrdreg1 = configreg1;\n\tassign configrdreg2 = configreg2;\n\t\n\t\n\tassign cfgce0 = cfgld0 & ~motorenaint;\n\tassign cfgce1 = cfgld1 & ~motorenaint;\n\tassign cfgce2 = cfgld2 & ~motorenaint;\n\tassign wdogdivregce = wdogdivld & ~motorenaint;\n\t\n\tassign hwconfig = {1'b0,1'b0,2'b11,4'b0000};\n\n\t\n\talways @(*) begin\n\t\tif(tst)\n\t\t\twdogcntce <= ce64;\n\t\telse\n\t\t\twdogcntce <= ce16384;\n\tend\n\t\t\n\treg8 wdogdivregister(\n\t\t.clk(clk),\n\t\t.ce(wdogdivregce),\n\t\t.in(wrtdata),\n\t\t.out(wdogdivreg));\n\t\n\treg8 configregister0(\n\t\t.clk(clk),\n\t\t.ce(cfgce0),\n\t\t.in(wrtdata),\n\t\t.out(configreg0));\n\t\t\n\treg8 configregister1(\n\t\t.clk(clk),\n\t\t.ce(cfgce1),\n\t\t.in(wrtdata),\n\t\t.out(configreg1));\n\t\t\n\treg8 configregister2(\n\t\t.clk(clk),\n\t\t.ce(cfgce2),\n\t\t.in(wrtdata),\n\t\t.out(configreg2));\t\t\n\t\t\n\t\t\n\tfixeddivby2 fdiv2(\n\t\t.cein(ce32),\n\t\t.clk(clk),\n\t\t.ceout(ce64));\n\t\t\n\tfixeddivby32 fdiv32(\n\t\t.cein(tie1),\n\t\t.clk(clk),\n\t\t.ceout(ce32));\n\t\t\n\tfixeddivby256 fdiv256(\n\t\t.cein(ce64),\n\t\t.clk(clk),\n\t\t.ceout(ce16384));\n\t\t\n\tdivby1248 filterdiv0(\n\t\t.clk(clk),\n\t\t.cein(ce32),\n\t\t.divisor(configreg0[3:2]),\n\t\t.ceout(filterce0));\n\t\t\n\tdivby1248 pwmdiv0(\n\t\t.clk(clk),\n\t\t.cein(tie1),\n\t\t.divisor(configreg0[1:0]),\n\t\t.ceout(pwmcntce0));\n\n\tdivby1248 filterdiv1(\n\t\t.clk(clk),\n\t\t.cein(ce32),\n\t\t.divisor(configreg1[3:2]),\n\t\t.ceout(filterce1));\n\t\t\n\tdivby1248 pwmdiv1(\n\t\t.clk(clk),\n\t\t.cein(tie1),\n\t\t.divisor(configreg1[1:0]),\n\t\t.ceout(pwmcntce1));\t\t\n\n\tdivby1248 filterdiv2(\n\t\t.clk(clk),\n\t\t.cein(ce32),\n\t\t.divisor(configreg2[3:2]),\n\t\t.ceout(filterce2));\n\t\t\n\tdivby1248 pwmdiv2(\n\t\t.clk(clk),\n\t\t.cein(tie1),\n\t\t.divisor(configreg2[1:0]),\n\t\t.ceout(pwmcntce2));\t\t\n\t\t\n\twdtimer wdtimer0(\n\t\t.clk(clk),\n\t\t.cein(wdogcntce),\n\t\t.enable(motorenaint),\n\t\t.wdreset(wdreset),\n\t\t.wdogdis(wdogdis),\n\t\t.wdogdivreg(wdogdivreg),\n\t\t.wdtripce(wdtripce));\n\t\n\t\n\twdregister wdreg0(\n\t\t.clk(clk),\n\t\t.ctrlld(ctrlld),\n\t\t.wdtripce(wdtripce),\n\t\t.wdogdis(wdogdis),\n\t\t.wrtdata(wrtdata),\n\t\t.run0(run0),\n\t\t.run1(run1),\n\t\t.run2(run2),\n\t\t.motorenaint(motorenaint),\n\t\t.controlrdata(controlrdata));\n\t\n\t\n\tledctr ledctr0(\n\t\t.clk(clk),\n\t\t.ce(ce16384),\n\t\t.ledalive(ledalive));\n\t\t\n\tassign invphase0 = configreg0[5];\n\tassign invertpwm0 = configreg0[4];\n\tassign invphase1 = configreg1[5];\n\tassign invertpwm1 = configreg1[4];\n\tassign invphase2 = configreg2[5];\n\tassign invertpwm2 = configreg2[4];\n\n\t\nendmodule\n\n\t\n\t\n\n\t\n\t\t\t\n\t\n",
        "module_name": "reg8",
        "module_hash": "46eaa3a0aa046d855dc03cd320fcf647",
        "dataset_index": 22302
      },
      "crc_engine_830e8795": {
        "rtl_code": "module crc_engine\n(\n\t//OUTPUTS\n\toutput [31:0] HRDATA,\n\toutput HREADYOUT,\n\toutput HRESP,\n\toutput [31:0] bus_wr,\n\toutput [ 1:0] crc_poly_size,\n\toutput [ 1:0] bus_size,\n\toutput [ 1:0] rev_in_type,\n\toutput rev_out_type,\n\toutput crc_init_en,\n\toutput crc_idr_en,\n\toutput crc_poly_en,\n\toutput buffer_write_en,\n\toutput reset_chain,\n\t//INPUTS\n\tinput [31:0] HWDATA,\n\tinput [31:0] HADDR,\n\tinput [ 2:0] HSIZE,\n\tinput [ 1:0] HTRANS,\n\tinput HWRITE,\n\tinput HSElx,\n\tinput HREADY,\n\tinput HRESETn,\n\tinput HCLK,\n\tinput [31:0] crc_poly_out,\n\tinput [31:0] crc_out,\n\tinput [31:0] crc_init_out,\n\tinput [ 7:0] crc_idr_out,\n\tinput buffer_full,\n\tinput reset_pending,\n\tinput read_wait\n);\n\n//Reset Values\nlocalparam RESET_CRC_CR = 6'h00;\n\n//CRC Register Map\nlocalparam CRC_DR   = 3'h0;\nlocalparam CRC_IDR  = 3'h1;\nlocalparam CRC_CR   = 3'h2;\nlocalparam CRC_INIT = 3'h4;\nlocalparam CRC_POL  = 3'h5;\n\n//Transfer Type Encoding\nlocalparam IDLE    = 2'b00;\nlocalparam BUSY    = 2'b01;\nlocalparam NON_SEQ = 2'b10;\nlocalparam SEQ     = 2'b11;\n\n//HRESP Encoding\nlocalparam OK    = 1'b0;\nlocalparam ERROR = 1'b1;\n\n//Pipeline flops\nreg [2:0] haddr_pp;\nreg [2:0] hsize_pp;\nreg [1:0] htrans_pp;\nreg hwrite_pp;\nreg hselx_pp;\n\n//Flops\nreg [4:0] crc_cr_ff;\n\n//Internal Signals\nwire [31:0] crc_cr_rd;\nwire crc_dr_sel;\nwire crc_init_sel;\nwire crc_idr_sel;\nwire crc_poly_sel;\nwire crc_cr_sel;\nwire ahb_enable;\nwire write_en;\nwire read_en;\nwire crc_cr_en;\nwire sample_bus;\nwire buffer_read_en;\n\n//Pipeline Registers for Address Phase of AHB Protocol\nalways @(posedge HCLK)\n\tbegin\n\t\tif(!HRESETn)\n\t\t\tbegin\n\t\t\t\thselx_pp <= 1'b0;\n\t\t\tend\n\t\telse\n\t\t\tif(sample_bus)\n\t\t\t\tbegin\n\t\t\t\t\thaddr_pp  <= HADDR[4:2];\n\t\t\t\t\thsize_pp  <= HSIZE;\n\t\t\t\t\thtrans_pp <= HTRANS;\n\t\t\t\t\thwrite_pp <= HWRITE;\n\t\t\t\t\thselx_pp  <= HSElx;\n\t\t\t\tend\n\tend\n\n//Enable Signals\nassign ahb_enable = (htrans_pp == NON_SEQ);\nassign write_en = hselx_pp &&  hwrite_pp && ahb_enable;\nassign read_en  = hselx_pp && !hwrite_pp && ahb_enable;\n\n//Registers decoding\nassign crc_dr_sel   = (haddr_pp == CRC_DR  );\nassign crc_init_sel = (haddr_pp == CRC_INIT);\nassign crc_idr_sel  = (haddr_pp == CRC_IDR );\nassign crc_poly_sel = (haddr_pp == CRC_POL );\nassign crc_cr_sel   = (haddr_pp == CRC_CR  );\n\n//Write Enables Signals for Registers\nassign buffer_write_en = crc_dr_sel   && write_en;\nassign crc_init_en     = crc_init_sel && write_en;\nassign crc_idr_en      = crc_idr_sel  && write_en;\nassign crc_poly_en     = crc_poly_sel && write_en;\nassign crc_cr_en       = crc_cr_sel   && write_en;\n\n//Indicates reading operation request to crc_dr register\nassign buffer_read_en = crc_dr_sel && read_en;\n\n//Bus Size is the output of HSIZE pipeline register\nassign bus_size = hsize_pp;\n\n//The Write Bus is not pipelined\nassign bus_wr = HWDATA;\n\n//HREADY Signal outputed to Master\nassign HREADYOUT = !((buffer_write_en && buffer_full   ) ||\n                     (buffer_read_en  && read_wait     ) ||\n                     (crc_init_en     && reset_pending ) );\n\n//Signal to control sampling of bus\nassign sample_bus = HREADYOUT && HREADY;\n\nassign HRESP = OK;\n\n//CRC_CR Data Read\nassign crc_cr_rd = {24'h0, crc_cr_ff[4:0], 3'h0};\n\n//Mux to HRDATA\nassign HRDATA = ({32{crc_dr_sel  }} & crc_out             ) |\n                ({32{crc_init_sel}} & crc_init_out        ) |\n                ({32{crc_idr_sel }} & {24'h0, crc_idr_out}) |\n                ({32{crc_poly_sel}} & crc_poly_out        ) |\n                ({32{crc_cr_sel  }} & crc_cr_rd           ) ;\n\n//Control Register\nalways @(posedge HCLK)\n\tbegin\n\t\tif(!HRESETn)\n\t\t\tcrc_cr_ff <= RESET_CRC_CR;\n\t\telse\n\t\t\tif(crc_cr_en)\n\t\t\t\tcrc_cr_ff <= {HWDATA[7], HWDATA[6:5], HWDATA[4:3]};\n\tend\n\n//Configuration Signals\nassign reset_chain   = (crc_cr_en && HWDATA[0]);\nassign crc_poly_size = crc_cr_ff[1:0];\nassign rev_in_type   = crc_cr_ff[3:2];\nassign rev_out_type  = crc_cr_ff[4];\n\nendmodule",
        "module_name": "crc_engine",
        "module_hash": "830e879522997f363763140aad7aab40",
        "dataset_index": 14582
      },
      "mux21_1d4a66db": {
        "rtl_code": "\nmodule mux21 (\n    input A,\n    input B,\n    input S,\n    output Y\n);\n\n  assign Y = (~S & A) | (S & B);\n\nendmodule\nmodule demux (\n    input in0, in1, in2, in3, d0, d1,\n    output out\n);\n\n  wire n1, n2;\n\n  mux21 U0 ( .A(n1), .B(n2), .S(d1), .Y(out) );\n  mux21 U1 ( .A(in2), .B(in3), .S(d0), .Y(n2) );\n  mux21 U2 ( .A(in0), .B(in1), .S(d0), .Y(n1) );\n\nendmodule\nmodule mux41 (\n    input A0, A1, A2, A3,\n    input B0, B1, B2, B3,\n    input S0, S1,\n    output Y\n);\n\n  wire n1, n2;\n\n  mux21 U0 ( .A(A0), .B(A1), .S(S0), .Y(n1) );\n  mux21 U1 ( .A(A2), .B(A3), .S(S0), .Y(n2) );\n  mux21 U2 ( .A(n1), .B(n2), .S(S1), .Y(Y) );\n\nendmodule",
        "module_name": "mux21",
        "module_hash": "1d4a66db50412a6b39295638404c242e",
        "dataset_index": 13917
      },
      "Mux8_322b5f7a": {
        "rtl_code": "module Mux8(select, data_i00, data_i01, data_i02, data_i03, data_i04, data_i05, data_i06, data_i07, data_o);\n   parameter Size = 8;\n\n   input wire [2:0] select;\n   input wire [Size-1:0] data_i00;\n   input wire [Size-1:0] data_i01;\n   input wire [Size-1:0] data_i02;\n   input wire [Size-1:0] data_i03;\n   input wire [Size-1:0] data_i04;\n   input wire [Size-1:0] data_i05;\n   input wire [Size-1:0] data_i06;\n   input wire [Size-1:0] data_i07;\n\n   output reg [Size-1:0] data_o;\n\n   always @ (select or data_i00 or data_i01 or data_i02 or data_i03 or data_i04 or data_i05 or data_i06 or data_i07) begin\n      case (select)\n         3'b000: data_o = data_i00;\n         3'b001: data_o = data_i01;\n         3'b010: data_o = data_i02;\n         3'b011: data_o = data_i03;\n         3'b100: data_o = data_i04;\n         3'b101: data_o = data_i05;\n         3'b110: data_o = data_i06;\n         3'b111: data_o = data_i07;\n      endcase\n   end\n\nendmodule",
        "module_name": "Mux8",
        "module_hash": "322b5f7a0e70e6c2eb539b530ed03a63",
        "dataset_index": 2749
      },
      "keyboard_pressed_status_fd6de454": {
        "rtl_code": "module keyboard_pressed_status (\n    input wire clk,\n    input wire rst,\n    input wire scan_received,\n    input wire [7:0] scancode,\n    input wire extended,\n    input wire released,\n    output reg kbclean\n    );\n    \n    parameter\n        RESETTING = 2'd0,\n        UPDATING  = 2'd1,\n        SCANNING  = 2'd2;\n        \n    reg keybstat_ne[0:255];  // non extended keymap\n    reg keybstat_ex[0:255];  // extended keymap\n    reg [7:0] addrscan = 8'h00; // keymap bit address\n    reg keypressed_ne = 1'b0; // there is at least one key pressed\n    reg keypressed_ex = 1'b0; // there is at least one extended key pressed\n    reg [1:0] state = RESETTING;\n    \n    integer i;\n    initial begin\n        kbclean = 1'b1;\n        for (i=0;i<256;i=i+1) begin\n            keybstat_ne[i] = 1'b0;\n            keybstat_ex[i] = 1'b0;\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (rst == 1'b1) begin\n            state <= RESETTING;\n            addrscan <= 8'h00;\n        end\n        else begin\n            case (state)\n                RESETTING:\n                    begin\n                        if (addrscan == 8'hFF) begin\n                            addrscan <= 8'h00;\n                            state <= SCANNING;\n                            kbclean <= 1'b1;\n                        end\n                        else begin\n                            keybstat_ne[addrscan] <= 1'b0;\n                            keybstat_ex[addrscan] <= 1'b0;\n                            addrscan <= addrscan + 8'd1;\n                        end\n                    end\n                UPDATING:\n                    begin\n                        state <= SCANNING;\n                        addrscan <= 8'h00;\n                        kbclean <= 1'b0;\n                        keypressed_ne <= 1'b0;\n                        keypressed_ex <= 1'b0;\n                        if (extended == 1'b0)\n                            keybstat_ne[scancode] <= ~released;\n                        else\n                            keybstat_ex[scancode] <= ~released;\n                    end\n                SCANNING:\n                    begin\n                        if (scan_received == 1'b1)\n                            state <= UPDATING;\n                        addrscan <= addrscan + 8'd1;\n                        if (addrscan == 8'hFF) begin\n                            kbclean <= ~(keypressed_ne | keypressed_ex);\n                            keypressed_ne <= 1'b0;\n                            keypressed_ex <= 1'b0;\n                        end\n                        else begin\n                            keypressed_ne <= keypressed_ne | keybstat_ne[addrscan];\n                            keypressed_ex <= keypressed_ex | keybstat_ex[addrscan];\n                        end\n                    end\n            endcase\n        end\n    end\nendmodule",
        "module_name": "keyboard_pressed_status",
        "module_hash": "fd6de454bd3d417afa5a8b322115a79d",
        "dataset_index": 15380
      },
      "binary_adder_15052d03": {
        "rtl_code": "\nmodule binary_adder(input [3:0] A, B, output [3:0] S, output C_out);\n    wire [3:0] sum;\n    wire [4:1] carry; // 4:1 to include C_in\n\n    // Full adder for bit 0\n    full_adder fa0(A[0], B[0], 1'b0, sum[0], carry[1]);\n\n    // Full adder for bit 1\n    full_adder fa1(A[1], B[1], carry[1], sum[1], carry[2]);\n\n    // Full adder for bit 2\n    full_adder fa2(A[2], B[2], carry[2], sum[2], carry[3]);\n\n    // Full adder for bit 3\n    full_adder fa3(A[3], B[3], carry[3], sum[3], C_out);\n\n    assign S = sum;\nendmodule\nmodule full_adder(input a, b, c_in, output s, output c_out);\n    wire w1, w2, w3;\n\n    xor(w1, a, b);\n    xor(s, w1, c_in);\n    and(w2, a, b);\n    and(w3, w1, c_in);\n    or(c_out, w2, w3);\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "15052d0359d306c2f11458cffb63db50",
        "dataset_index": 20511
      },
      "bitwise_and #_40a90023": {
        "rtl_code": "module bitwise_and #(\n    parameter bits = 16\n) (\n    input [bits-1:0] a, b,\n    output [bits-1:0] q\n);\n    assign q = a & b;\nendmodule",
        "module_name": "bitwise_and #",
        "module_hash": "40a90023bdb43285db764b509b24769b",
        "dataset_index": 16350
      },
      "idec_61445ecf": {
        "rtl_code": "module idec(aluf,readAddrA,readAddrB, writeAddress,selA,selB,clrR,\n             clrIr0, gate, rw, sel_addr_reg, dojump, wrAddr,\n             ir0q,ir1q,flags,reset);\noutput [3:0] aluf,readAddrA,readAddrB, writeAddress;\noutput [1:0] selA,selB;\noutput clrR, clrIr0, gate, rw, sel_addr_reg, dojump,wrAddr ;\ninput [15:0] ir0q,ir1q;\ninput [3:0] flags;\ninput reset;\n\n\n\nwire m0 = ir0q[3],\n     m1 = ir1q[3];\n\n\n`define unc     3'b000\n`define pos     3'b001\n`define neg     3'b010\n`define zero    3'b011\n`define parodd  3'b100\n`define carry   3'b101\n`define ncarry  3'b110\n`define nzero   3'b111\n \nfunction jmpchk;\ninput [2:0] condition;\ninput [3:0] flags;\nreg sign,carry,parity,zero;\nbegin\n        {sign,carry,parity,zero} = flags;\n        case (condition)\n        `unc:   jmpchk = 1;\n        `pos:   jmpchk = ~ sign;\n        `neg:   jmpchk = sign;\n        `zero:  jmpchk = zero;\n        `parodd: jmpchk = parity;\n        `carry: jmpchk = carry;\n        `ncarry: jmpchk = ~carry;\n        `nzero: jmpchk = ~zero;\n        endcase\nend\nendfunction\n\nassign #1 \naluf = ir1q[15:12],\n\nreadAddrA = ir0q[11:8],\n        readAddrB = ir0q[ 7:4],\n\nwriteAddress = ir1q[11:8],\n\nselA = readAddrA[3:2] ? 2'b11 : readAddrA[1:0],\n\tselB = readAddrB[3:2] ? 2'b11 : readAddrB[1:0],\n\nsel_addr_reg = (m0 & (ir0q[ 7:4] == 4'b0)) \n                     | (m1 & (ir1q[11:8] == 4'b0)) ,\n\nrw = ~(m1 & (ir1q[11:8] == 4'b0)) ,\n\ndojump = jmpchk(ir1q[2:0],flags) & (ir1q[11:8] == 3'h1),\n\nwrAddr = (ir1q[11:8] == 3'h2),\ngate = | ir1q[15:12] ,\n\nclrR = reset,\n\nclrIr0 = reset | dojump \n                 | ((ir0q[ 7:4] == 4'b0) & (ir0q[ 11:8] != 4'b0))\n                 | ~rw ;\n\nendmodule\n",
        "module_name": "idec",
        "module_hash": "61445ecf2e7566cef83225c80c6eceda",
        "dataset_index": 9770
      },
      "mux_2_1_en_102149c4": {
        "rtl_code": "module mux_2_1_en(\n    input in0,\n    input in1,\n    input en,\n    output reg out\n);\n\nalways @(*) begin\n    out = en ? in1 : in0;\nend\n\nendmodule",
        "module_name": "mux_2_1_en",
        "module_hash": "102149c4d76be4e5b30c3eac52eb607b",
        "dataset_index": 10248
      },
      "memory_block_generator_5a80311f": {
        "rtl_code": "\nmodule memory_block_generator\n   (douta,\n    clka,\n    addra,\n    dina,\n    wea);\n\n  output [2:0]douta;\n  input clka;\n  input [12:0]addra;\n  input [2:0]dina;\n  input [0:0]wea;\n\n  reg [2:0] mem [0:8191];\n\n  assign douta = (wea) ? dina : mem[addra[12:1]][addra[0]];\n  \n  always @(posedge clka) begin\n    if (wea) begin\n      mem[addra[12:1]][addra[0]] <= dina;\n    end\n  end\nendmodule",
        "module_name": "memory_block_generator",
        "module_hash": "5a80311f9dce9a44e822f7161d9eb5c7",
        "dataset_index": 14114
      },
      "barrel_shifter_20aaa7bc": {
        "rtl_code": "module barrel_shifter (\n  input [7:0] data_in,\n  input [2:0] shift_amount,\n  input shift_direction,\n  output [7:0] data_out\n);\n  \n  wire [7:0] shifted_data;\n  \n  assign shifted_data = (shift_direction) ? (data_in << shift_amount) : (data_in >> shift_amount);\n  \n  assign data_out = shifted_data;\n  \nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "20aaa7bccaf664b9190c61a9348f9d25",
        "dataset_index": 3245
      },
      "priority_encoder_027b19b3": {
        "rtl_code": "module priority_encoder (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case(in)\n        4'b0001: pos = 2'b00;\n        4'b0010: pos = 2'b01;\n        4'b0100: pos = 2'b10;\n        4'b1000: pos = 2'b11;\n        default: pos = 2'b00;\n    endcase\nend\n\nendmodule\n\nmodule top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\npriority_encoder pe(\n    .in(in),\n    .pos(pos)\n);\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "027b19b3d431be2599023b904ceb3e65",
        "dataset_index": 1377
      },
      "MEM2WB_02480485": {
        "rtl_code": "\n\nmodule MEM2WB(\n    input clk, rst,\n    input RegWrite_In, \n    input [31:0] PC_In, ALUOut_In, rdata_In, \n    input [4:0] AddrC_In, \n    input [1:0] MemtoReg_In, \n    output reg RegWrite_Out, \n    output reg [31:0] PC_Out, ALUOut_Out, rdata_Out, \n    output reg [4:0] AddrC_Out, \n    output reg [1:0] MemtoReg_Out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            RegWrite_Out <= 0;\n            PC_Out <= 0;\n            ALUOut_Out <= 0;\n            AddrC_Out <= 0;\n            MemtoReg_Out <= 0;\n            rdata_Out <= 0;\n        end else begin\n            RegWrite_Out <= RegWrite_In;\n            PC_Out <= PC_In;\n            ALUOut_Out <= ALUOut_In;\n            AddrC_Out <= AddrC_In;\n            MemtoReg_Out <= MemtoReg_In;\n            rdata_Out <= rdata_In;\n        end\n    end\n\nendmodule\n",
        "module_name": "MEM2WB",
        "module_hash": "024804855267710566b8a7becc3ae8d4",
        "dataset_index": 20989
      },
      "v78e0a3_v9a2a06_8a9d50b4": {
        "rtl_code": "module v78e0a3_v9a2a06 (\n  output [0:31] o,\n  input [0:31] i0,\n  input [0:7] i1,\n  input [0:7] i2,\n  input [0:7] i3,\n  input [0:7] i4\n);\n\n  wire [0:31] concatenated_input;\n  wire [0:31] subtracted_value;\n  wire [0:31] twos_complement;\n  wire [0:31] inverted_subtracted_value;\n  wire [0:31] add_one;\n\n  assign concatenated_input = {i1, i2, i3, i4};\n  assign subtracted_value = i0 - concatenated_input;\n\n  assign twos_complement = ~subtracted_value;\n  assign inverted_subtracted_value = ~subtracted_value;\n  assign add_one = {1'b1, {30{1'b0}}, 1'b0};\n\n  assign o = (subtracted_value >= 0) ? subtracted_value : (inverted_subtracted_value + add_one);\n\nendmodule",
        "module_name": "v78e0a3_v9a2a06",
        "module_hash": "8a9d50b460ce3a0a5535d3ee9e954216",
        "dataset_index": 12754
      },
      "clk_divider_e1c3ef49": {
        "rtl_code": "module clk_divider(input reset, input wire in_clk,output reg out_clk, input [7:0] ratio);\n   reg [7:0] counter;\n   \n   always @(posedge in_clk or posedge reset)\n     if(reset)\n       counter <= #1 8'd0;\n     else if(counter == 0)\n       counter <= #1 ratio[7:1] + (ratio[0] & out_clk) - 8'b1;\n     else\n       counter <= #1 counter-8'd1;\n   \n   always @(posedge in_clk or posedge reset)\n     if(reset)\n       out_clk <= #1 1'b0;\n     else if(counter == 0)\n       out_clk <= #1 ~out_clk;\n   \nendmodule ",
        "module_name": "clk_divider",
        "module_hash": "e1c3ef49e89107a7d2efe4c3cb350e68",
        "dataset_index": 25790
      },
      "blinki_69602dac": {
        "rtl_code": "module blinki (\n  \n  input Reset_n_i,\n  \n  input Clk_i,\n  \n  output reg LED_o,\n  \n  input[15:0] PeriodH_i,\n  \n  input[15:0] PeriodL_i\n);\n\n  localparam stStart   = 3'b000;\n  localparam stOn      = 3'b001;\n  localparam stOff     = 3'b010;\n  reg  [2:0]             State;\n  reg  [2:0]             NextState;\n  reg                    TimerPreset;\n  reg                    TimerEnable;\n  wire                   TimerOvfl;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      State <= stStart;\n    end\n    else\n    begin State <= NextState;\n    end  \n  end\n\n  always @(State, TimerOvfl)\n  begin  NextState     = State;\n    TimerEnable   = 1'b1;\n    TimerPreset   = 1'b0;\n    case (State)\n      stStart: begin\n        TimerPreset   = 1'b1;\n        NextState     = stOn;\n      end\n      stOn: begin\n        LED_o = 1'b1;\n        if (TimerOvfl == 1'b1)\n        begin\n          NextState     = stOff;\n          TimerPreset   = 1'b1;\n        end\n      end\n      stOff: begin\n        LED_o = 1'b0;\n        if (TimerOvfl == 1'b1)\n        begin\n          NextState     = stOn;\n          TimerPreset   = 1'b1;\n        end\n      end\n      default: begin\n      end\n    endcase\n  end \n\n  reg [31:0] Timer;\n  \n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Timer <= 32'd0;\n    end\n    else\n    begin\n      if (TimerPreset)\n      begin\n        Timer <= {PeriodH_i, PeriodL_i};\n      end\n      else if (TimerEnable)\n      begin\n        Timer <= Timer - 1'b1;\n      end\n    end  \n  end\n\n  assign TimerOvfl = (Timer == 0) ? 1'b1 : 1'b0;\n\nendmodule\n",
        "module_name": "blinki",
        "module_hash": "69602dac06fd4ef1f601feee797765a0",
        "dataset_index": 21568
      },
      "parity_check_44133cdc": {
        "rtl_code": "module parity_check (\n  input clk,\n  input [7:0] data_in,\n  output reg parity\n);\n\n  reg [7:0] shift_reg;\n  reg [7:0] shifted_data;\n  reg [7:0] sum;\n  reg [2:0] i;\n\n  always @(posedge clk) begin\n    shift_reg <= {shift_reg[6:0], data_in};\n    shifted_data <= {shift_reg[5:0], 2'b00};\n    sum <= shifted_data + shift_reg;\n    parity <= 1'b1;\n\n    for (i = 0; i < 8; i = i + 1) begin\n      if (sum[i] == 1'b1) begin\n        parity <= ~parity;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "parity_check",
        "module_hash": "44133cdc92c43a2767e1f404a84e1023",
        "dataset_index": 6080
      },
      "d_ff_pre_0d2cc697": {
        "rtl_code": "module d_ff_pre (\n  input wire D,\n  input wire C,\n  input wire PRE,\n  output reg Q\n);\n\n  always @ (posedge C or posedge PRE) begin\n    if (PRE) begin\n      Q <= 1'b1;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule",
        "module_name": "d_ff_pre",
        "module_hash": "0d2cc69767373c12ef61a61c479d73eb",
        "dataset_index": 4608
      },
      "ALU_1f2a8199": {
        "rtl_code": "\n\nmodule ALU(A, B, ALUOp , ALUOut, Zero);\n\n    output reg [31:0] ALUOut;\n\t output reg [0:0] Zero;\n    input [31:0] A, B;\n    input [4:0] ALUOp;\n\t \n\tparameter ADD = 5'd0;\n   parameter SUB = 5'd1;\n   parameter ADDI  = 5'd2;\n\tparameter SUBI = 5'd3;\n\tparameter MLT = 5'd4;\n   parameter MLTI = 5'd5;\n   parameter AND = 5'd6;\n\tparameter OR = 5'd7;\n\tparameter ANDI = 5'd8;\n\tparameter ORI = 5'd9;\n\tparameter SLR = 5'd10;\n\tparameter SLL = 5'd11;\n\tparameter LDR = 5'd12;\n\tparameter STR = 5'd13;\n\tparameter BNE = 5'd14;\n\tparameter BEQ = 5'd15;\n\tparameter J = 5'd16;\n\tparameter CMP = 5'd17;\n\tparameter NOP = 5'b11111;\n\t\n\tparameter on = 1'd1; \n\tparameter off = 1'd0;\n\t \n\t \n\t \n\t initial begin\n\t\tALUOut=32'd0;\n\t\tZero=1'd0;\n\t end\n\t \n    always @ (A or B or ALUOp) begin\n\t\t\t  case (ALUOp)\n\t\t\t\t\tADD:\n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A+B; \n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend \n\t\t\t\t\tSUB:\n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A-B;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tADDI: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A+B; \n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tSUBI: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A-B;\n\t\t\t\t\t\t\tZero=off;\t\n\t\t\t\t\t\tend\n\t\t\t\t\tMLT: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A*B;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tMLTI: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A*B;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tAND: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A&B;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tOR:\n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A|B;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tANDI: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A&B;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tORI: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A|B; \n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tSLR:\n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A>>B; \n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tSLL: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A<<B; \n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tLDR:\n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A+B; \n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tSTR: \n\t\t\t\t\t\tbegin \n\t\t\t\t\t\t\tALUOut = A+B; \n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tBNE: \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tALUOut = 32'd0;\n\t\t\t\t\t\t\tif(A==B) Zero=on;\n\t\t\t\t\t\t\telse Zero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tBEQ:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tALUOut = 32'd0;\n\t\t\t\t\t\t\tif (A==B) Zero=on;\n\t\t\t\t\t\t\telse Zero=off;\n\t\t\t\t\t\tend\n\t\t\t\t\tCMP:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (A>B) ALUOut=2'd1;\n\t\t\t\t\t\t\telse if(A==B) ALUOut=2'd0;\n\t\t\t\t\t\t\telse ALUOut=2'd2;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend \n\t\t\t\t\tdefault: \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tALUOut = 32'd0;\n\t\t\t\t\t\t\tZero=off;\n\t\t\t\t\t\tend \n\t\t\t  endcase\n    end\nendmodule",
        "module_name": "ALU",
        "module_hash": "1f2a81991f10601ae5fd0c08504a5b9f",
        "dataset_index": 5672
      },
      "bullet_b928fb0e": {
        "rtl_code": "\nmodule bullet(\n\tinput clk,\n\tinput rst,\n\tinput [10:0] x,\n\tinput [10:0] y,\n\tinput [10:0] poX,\n\tinput [10:0] poY,\n\tinput trigger,\n\tinput timer,\n\tinput d,\n\toutput reg bullet\n    );\n\t\nparameter w = 4;\nparameter s = 4;\n\nreg [10:0] nowX, nowY;\nreg start;\nreg over;\nalways@(posedge clk ,posedge rst)\nbegin\n\tif(rst)start<=0;\n\telse if(trigger)start<=1;\n\telse start<=start;\nend\n\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) over <= 0;\n\telse begin\n\n\t\tif(d) begin if(start && nowX > 904) over <= 1;\n\t\t\telse over <= over;\n\t\tend\n\t\telse begin if(start && nowX < 104 && nowX>0) over <= 1;\n\t\t\telse over <= over;\n\t\tend\n\tend\nend\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) nowX <= 0;\n\telse begin\n\t\tif(trigger) nowX <= poX;\n\t\telse if(timer) begin\n\t\t\tif(start) nowX <= (d)? nowX+w : nowX-w;\n\t\t\telse nowX <= nowX;\n\t\tend\n\t\telse nowX <= nowX;\n\tend\nend\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) nowY <= 0;\n\telse begin\n\t\tif(trigger) nowY <= poY;\n\t\telse nowY <= nowY;\n\tend\nend\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) bullet <= 0;\n\telse begin\n\t\tif(over) bullet <= 0;\n\t\telse if(d &&start && x < nowX+w+36 && x > nowX+36 && y < nowY+w+20 && y > nowY+20) bullet <= 1;\n\t\telse if(!d && start && x < nowX+w && x > nowX && y < nowY+w+20 && y > nowY+20) bullet <= 1;\n\t\telse bullet <= 0;\n\tend\nend\n\nendmodule\n",
        "module_name": "bullet",
        "module_hash": "b928fb0ee0b425db52cb474501c06caf",
        "dataset_index": 23735
      },
      "booth_multiplier_87abba5e": {
        "rtl_code": "module booth_multiplier (\n  input clk,\n  input reset,\n  input start,\n  input [15:0] A,\n  input [15:0] B,\n  output reg [31:0] P,\n  output reg done\n);\n\n  reg [15:0] A_reg;\n  reg [15:0] B_reg;\n  reg [1:0] state;\n  reg [4:0] count;\n  reg [31:0] P_reg;\n  wire [15:0] B_comp;\n  wire [31:0] P_comp;\n\n  assign B_comp = ~B + 1;\n  assign P_comp = { {16{P_reg[31]}} , P_reg } + { {16{B_reg[15]}} , B_comp };\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= 2'b00;\n      count <= 5'd0;\n      P_reg <= 32'd0;\n      done <= 1'b0;\n    end else begin\n      case (state)\n        2'b00: begin // Idle state, waiting for start signal\n          if (start) begin\n            A_reg <= A;\n            B_reg <= B;\n            state <= 2'b01;\n          end\n        end\n        2'b01: begin // Booth's algorithm state\n          if (count < 5'd16) begin\n            if (B_reg[0] == 1 && P_reg[0] == 0) begin\n              P_reg <= P_reg + { {16{A_reg[15]}} , A_reg };\n            end else if (B_reg[0] == 0 && P_reg[0] == 1) begin\n              P_reg <= P_reg - { {16{A_reg[15]}} , A_reg };\n            end\n            B_reg <= { B_reg[15], B_reg[15:1] };\n            count <= count + 1;\n          end else begin\n            state <= 2'b10;\n          end\n        end\n        2'b10: begin // Output state\n          P <= P_comp;\n          done <= 1'b1;\n          state <= 2'b00;\n        end\n        default: begin\n          state <= 2'b00;\n        end\n      endcase\n    end\n  end\nendmodule\n",
        "module_name": "booth_multiplier",
        "module_hash": "87abba5ef162d1f284808920c9e2f767",
        "dataset_index": 2261
      },
      "addition_4bit_e7b57e6f": {
        "rtl_code": "module addition_4bit (\n  input [3:0] a,\n  input [3:0] b,\n  output reg [3:0] sum\n);\n\n  always @(*) begin\n    sum = a + b;\n    if(sum > 15) begin\n      sum = sum - 16;\n    end\n  end\n\nendmodule\n",
        "module_name": "addition_4bit",
        "module_hash": "e7b57e6f0ae89e5e566a497241f36256",
        "dataset_index": 6855
      },
      "inverted_input_buffer_ad398807": {
        "rtl_code": "module inverted_input_buffer\n  (output o, input i, input ibar);\n   assign o = ~i;\nendmodule",
        "module_name": "inverted_input_buffer",
        "module_hash": "ad3988071704e5bf6e4554f8313e946f",
        "dataset_index": 7328
      },
      "delay__2a931058": {
        "rtl_code": "module delay_module (\n    input CLK,\n    input D,\n    input SCD,\n    input SCE,\n    input RESET_B,\n    output reg Q\n);\n\nreg [1:0] delay_counter;\n\nalways @(posedge CLK) begin\n    if (RESET_B == 0) begin\n        Q <= 0;\n        delay_counter <= 0;\n    end else begin\n        if (SCE == 1) begin\n            if (delay_counter == 0) begin\n                Q <= D;\n                if (SCD == 1) begin\n                    delay_counter <= 1;\n                end\n            end else begin\n                Q <= Q;\n                delay_counter <= 0;\n            end\n        end else begin\n            Q <= D;\n            delay_counter <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "delay_",
        "module_hash": "2a931058b3218642bbdd7ee71283941d",
        "dataset_index": 11785
      },
      "reg_32bits_54cac3f6": {
        "rtl_code": "module reg_32bits(d, we, clk, rst, q);\n  input [31:0] d;\n  input clk, rst, we;\n  output [31:0] q;\n  reg [31:0] q_reg;\n\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      q_reg <= 32'b0;\n    end else if (we) begin\n      q_reg <= d;\n    end\n  end\n\n  assign q = q_reg;\nendmodule",
        "module_name": "reg_32bits",
        "module_hash": "54cac3f634e7978bdec27cfc50ef57a9",
        "dataset_index": 1131
      },
      "jt12_eg_cnt_3934fba6": {
        "rtl_code": "\n\nmodule jt12_eg_cnt(\n\tinput rst,\n\tinput clk,\n\tinput clk_en ,\n\tinput zero,\n\toutput reg [14:0] eg_cnt\n);\n\nreg\t[1:0] eg_cnt_base;\n\nalways @(posedge clk, posedge rst) begin : envelope_counter\n\tif( rst ) begin\n\t\teg_cnt_base\t<= 2'd0;\n\t\teg_cnt\t\t<=15'd0;\n\tend\n\telse begin\n\t\tif( zero && clk_en ) begin\n\t\t\tif( eg_cnt_base == 2'd2 ) begin\n\t\t\t\teg_cnt \t\t<= eg_cnt + 1'b1;\n\t\t\t\teg_cnt_base\t<= 2'd0;\n\t\t\tend\n\t\t\telse eg_cnt_base <= eg_cnt_base + 1'b1;\n\t\tend\n\tend\nend\n\nendmodule // jt12_eg_cnt",
        "module_name": "jt12_eg_cnt",
        "module_hash": "3934fba666e75859e5596e737e65af71",
        "dataset_index": 22906
      },
      "FSM_Ctrol_f063a549": {
        "rtl_code": "module FSM_Ctrol (\n\tinput\t\t\t\tRST,\tinput\t\t\t\tCLK,\tinput\t\t\t\tSTM,\toutput reg[7:0]\t\tENa,\toutput reg[7:0]\t\tENb,\toutput reg[7:0]\t\tENc,\toutput reg[7:0]\t\tSEL,\toutput reg\t\t\tEOM\t\t);\t \n\t\n\treg[2:0]\tQp,Qn;\n\t\n\talways @ *\n\tbegin : Combinacional\n\t\tcase (Qp)\n\t\t\t3'b000 : begin\tif (STM)\n\t\t\t\t\tQn = 3'b001;\n\t\t\t\telse\n\t\t\t\t\tQn = Qp;\n\t\t\t\tENa = 8'b00001111;\n\t\t\t\tENb = 8'b00001111;\n\t\t\t\tENc = 8'b00000000; \n\t\t\t\tSEL = 8'b00000000;\n\t\t\t\tEOM = 1'b1;\n\t\t\tend\n\t\t\t3'b001 : begin \n\t\t\t\tQn  = 3'b010;\n\t\t\t\tENa = 8'b11110000;\n\t\t\t\tENb = 8'b11110000;\n\t\t\t\tENc = 8'b00000000; \n\t\t\t\tSEL = 8'b00000000; \n\t\t\t\tEOM = 1'b0;\n\t\t\tend\n\t\t\t3'b010 : begin \n\t\t\t\tQn  = 3'b011;\n\t\t\t\tENa = 8'b01011010;\n\t\t\t\tENb = 8'b00000000;\n\t\t\t\tENc = 8'b00000000;  \n\t\t\t\tSEL = 8'b10010101;\n\t\t\t\tEOM = 1'b0;\n\t\t\tend\n\t\t\t3'b011 : begin \n\t\t\t\tQn  = 3'b100;\n\t\t\t\tENa = 8'b00000000;\n\t\t\t\tENb = 8'b00111100;\n\t\t\t\tENc = 8'b00000000; \n\t\t\t\tSEL = 8'b01101010;\n\t\t\t\tEOM = 1'b0;\n\t\t\tend\t \n\t\t\t3'b100 : begin \n\t\t\t\tQn  = 3'b000;\n\t\t\t\tENa = 8'b00000000;\n\t\t\t\tENb = 8'b00000000;\n\t\t\t\tENc = 8'b11111111; \t  \n\t\t\t\tSEL = 8'b01101010;\n\t\t\t\tEOM = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @ (posedge RST or posedge CLK)\n\tbegin : Secuencial\n\t\tif (RST)\n\t\t\tQp <= 0;\n\t\telse\n\t\t\tQp <= Qn;\n\tend\n\t\nendmodule\n",
        "module_name": "FSM_Ctrol",
        "module_hash": "f063a5496a5ba8c9d54c2eefd6cb405e",
        "dataset_index": 22638
      },
      "clk_divider #_c80235d5": {
        "rtl_code": "\nmodule clk_divider #\n    (\n        parameter DIVIDER = 15\n    )\n    (\n        input IN_SIG,\n        output wire OUT_SIG\n    );\n\n    function integer clogb2 (input integer bit_depth);\n      begin\n        for(clogb2=0; bit_depth>0; clogb2=clogb2+1)\n          bit_depth = bit_depth >> 1;\n      end\n    endfunction\n\n    localparam BITS = clogb2(DIVIDER-1);\n\n    localparam MAX = 1 << BITS;\n\n    localparam integer HIGH = DIVIDER / 2;\n\n    reg [BITS:0] counter = 0;\n\n    always @(posedge IN_SIG)\n    begin\n        counter = counter + 1;\n        if (counter >= DIVIDER) begin\n            counter = 0;\n        end\n    end\n\n    assign OUT_SIG = (counter <= HIGH);\n\nendmodule\n",
        "module_name": "clk_divider #",
        "module_hash": "c80235d57ceb4c1201407ceba93766f8",
        "dataset_index": 23550
      },
      "Raster_Laser_Projector_Video_In_video_rgb_resampler_0_9c825eb7": {
        "rtl_code": "\n\nmodule Raster_Laser_Projector_Video_In_video_rgb_resampler_0 (\n\tclk,\n\treset,\n\n\tstream_in_data,\n\tstream_in_startofpacket,\n\tstream_in_endofpacket,\n\tstream_in_empty,\n\tstream_in_valid,\n\n\tstream_out_ready,\n\t\n\tstream_in_ready,\n\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_empty,\n\tstream_out_valid\n);\n\n\n\nparameter IDW\t\t= 23;\nparameter ODW\t\t= 7;\n\nparameter IEW\t\t= 1;\nparameter OEW\t\t= 0;\n\nparameter ALPHA\t= 10'h3FF;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[IDW:0]\tstream_in_data;\ninput\t\t\t\t\t\tstream_in_startofpacket;\ninput\t\t\t\t\t\tstream_in_endofpacket;\ninput\t\t\t[IEW:0]\tstream_in_empty;\ninput\t\t\t\t\t\tstream_in_valid;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tstream_in_ready;\n\noutput reg\t[ODW:0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t[OEW:0]\tstream_out_empty;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire\t\t[ 9: 0]\tr;\nwire\t\t[ 9: 0]\tg;\nwire\t\t[ 9: 0]\tb;\nwire\t\t[ 9: 0]\ta;\n\nwire\t\t[11: 0]\taverage_color;\t\n\nwire\t\t[ODW:0]\tconverted_data;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'b0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_empty\t\t\t\t<=  'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (stream_out_ready | ~stream_out_valid)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= converted_data;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid;\n\tend\nend\n\n\n\nassign stream_in_ready = stream_out_ready | ~stream_out_valid;\n\nassign r = {stream_in_data[23:16], stream_in_data[23:22]};\nassign g = {stream_in_data[15: 8], stream_in_data[15:14]};\nassign b = {stream_in_data[ 7: 0], stream_in_data[ 7: 6]};\n\nassign a = ALPHA;\n\nassign average_color = {2'h0, r} + {1'b0, g, 1'b0} + {2'h0, b};\n\nassign converted_data[ 7: 0] = average_color[11:4];\n\n\n\n\nendmodule\n\n",
        "module_name": "Raster_Laser_Projector_Video_In_video_rgb_resampler_0",
        "module_hash": "9c825eb75193b89e87b8815039dffc2b",
        "dataset_index": 13991
      },
      "nand3b_23852500": {
        "rtl_code": "module nand3b (\n    output Y,\n    input A_N,\n    input B,\n    input C\n);\n\n    assign Y = ~(A_N & B & C);\n\nendmodule\n\nmodule nand4 (\n    output Y,\n    input A,\n    input B,\n    input C,\n    input D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    wire nand1_out;\n    wire nand2_out;\n    wire nand3_out;\n\n    nand3b nand1 (\n        .Y(nand1_out),\n        .A_N(A),\n        .B(B),\n        .C(VPB)\n    );\n\n    nand3b nand2 (\n        .Y(nand2_out),\n        .A_N(C),\n        .B(D),\n        .C(VPB)\n    );\n\n    nand3b nand3 (\n        .Y(nand3_out),\n        .A_N(nand1_out),\n        .B(nand2_out),\n        .C(VPB)\n    );\n\n    nand3b base (\n        .Y(Y),\n        .A_N(nand3_out),\n        .B(VGND),\n        .C(VPWR)\n    );\n\nendmodule",
        "module_name": "nand3b",
        "module_hash": "2385250068e93bb3e565345728f8b29c",
        "dataset_index": 8736
      },
      "ad_mem_7e8609a5": {
        "rtl_code": "\n\nmodule ad_mem (\n\n  clka,\n  wea,\n  addra,\n  dina,\n\n  clkb,\n  addrb,\n  doutb);\n\n  parameter       DATA_WIDTH = 16;\n  parameter       ADDRESS_WIDTH =  5;\n  localparam      DW = DATA_WIDTH - 1;\n  localparam      AW = ADDRESS_WIDTH - 1;\n\n  input           clka;\n  input           wea;\n  input   [AW:0]  addra;\n  input   [DW:0]  dina;\n\n  input           clkb;\n  input   [AW:0]  addrb;\n  output  [DW:0]  doutb;\n\n  reg     [DW:0]  m_ram[0:((2**ADDRESS_WIDTH)-1)];\n  reg     [DW:0]  doutb;\n\n  always @(posedge clka) begin\n    if (wea == 1'b1) begin\n      m_ram[addra] <= dina;\n    end\n  end\n\n  always @(posedge clkb) begin\n    doutb <= m_ram[addrb];\n  end\n\nendmodule\n\n",
        "module_name": "ad_mem",
        "module_hash": "7e8609a5560dc843d3cac2453d79bec8",
        "dataset_index": 18646
      },
      "pulse_cdb58b94": {
        "rtl_code": "module pulse\n  #(parameter dly=3,\n    parameter len=2)\n  (input rstn,\n   input clk,\n   output reg pulse);\n\n  localparam width = $clog2(dly+len)+1;\n\n  reg [width-1:0] cnt;\n\n  always @(posedge clk or negedge rstn) begin\n    if (~rstn)\n      cnt <= 1'b0;\n    else if (cnt != dly+len)\n      cnt <= cnt + 1'b1;\n  end\n\n  always @(posedge clk or negedge rstn) begin\n    if (~rstn)\n      pulse <= 1'b0;\n    else if (cnt == dly)\n      pulse <= 1'b1;\n    else if (cnt == dly+len)\n      pulse <= 1'b0;\n  end\nendmodule",
        "module_name": "pulse",
        "module_hash": "cdb58b94d091c2b47b29d41fa6f3f507",
        "dataset_index": 5739
      },
      "EscrituraRegistroToMemoria#_155a416d": {
        "rtl_code": "\nmodule EscrituraRegistroToMemoria#(parameter Width = 4)\n(Read,InError,Address,ListoIn,InDato,Coeff00,Coeff01,Coeff02,Coeff03,Coeff04,Coeff05,\nCoeff06,Coeff07,Coeff08,Coeff09,Coeff10,Coeff11,Coeff12,Coeff13,Coeff14,Coeff15,Coeff16,Coeff17,Coeff18,\nCoeff19,Offset,DatoEntradaSistema,Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,OutDato);\n\t \n\tinput Read,InError,ListoIn;\n   input [8:0] Address; \n\tinput signed [Width-1:0] InDato,Coeff00,Coeff01,Coeff02,Coeff03,Coeff04,Coeff05,\n   Coeff06,Coeff07,Coeff08,Coeff09,Coeff10,Coeff11,Coeff12,Coeff13,Coeff14,Coeff15,Coeff16,\n\tCoeff17,Coeff18,Coeff19,Offset,DatoEntradaSistema,Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9;\n\t\n\toutput reg signed [Width-1:0] OutDato;\n\n\talways @*begin if(Read) begin\n\t\t\tif(Address==9'h000 && ListoIn==1'b1) begin  OutDato <= 1; \n\t\t\tend else if(Address==9'h004 ) begin  OutDato <= InDato; \n\t\t\tend else if(Address==9'h008 && InError==1'b1) begin   OutDato <= 1;\n\t\t\tend else if(Address==9'h00C ) begin   OutDato <= Coeff00;\n\t\t\tend else if(Address==9'h010 ) begin   OutDato <= Coeff01;\n\t\t\tend else if(Address==9'h014 ) begin   OutDato <= Coeff02;\n\t\t\tend else if(Address==9'h018 ) begin   OutDato <= Coeff03;\n\t\t\tend else if(Address==9'h01C ) begin   OutDato <= Coeff04;\n\t\t\tend else if(Address==9'h020 ) begin   OutDato <= Coeff05;\n\t\t\tend else if(Address==9'h024 ) begin   OutDato <= Coeff06;\n\t\t\tend else if(Address==9'h028 ) begin   OutDato <= Coeff07;\n\t\t\tend else if(Address==9'h02C ) begin   OutDato <= Coeff08;\n\t\t\tend else if(Address==9'h030 ) begin   OutDato <= Coeff09;\n\t\t\tend else if(Address==9'h034 ) begin   OutDato <= Coeff10;\n\t\t\tend else if(Address==9'h038 ) begin   OutDato <= Coeff11;\n\t\t\tend else if(Address==9'h03C ) begin   OutDato <= Coeff12;\n\t\t\tend else if(Address==9'h040 ) begin   OutDato <= Coeff13;\n\t\t\tend else if(Address==9'h044 ) begin   OutDato <= Coeff14;\n\t\t\tend else if(Address==9'h048 ) begin   OutDato <= Coeff15;\n\t\t\tend else if(Address==9'h04C ) begin   OutDato <= Coeff16;\n\t\t\tend else if(Address==9'h050 ) begin   OutDato <= Coeff17;\n\t\t\tend else if(Address==9'h054 ) begin   OutDato <= Coeff18;\n\t\t\tend else if(Address==9'h058 ) begin   OutDato <= Coeff19;\n\t\t\tend else if(Address==9'h05C ) begin   OutDato <= Offset;\n\t\t\tend else if(Address==9'h060 ) begin   OutDato <= DatoEntradaSistema;\n\t\t\tend else if(Address==9'h064 ) begin   OutDato <= Y0;\n\t\t\tend else if(Address==9'h068 ) begin   OutDato <= Y1;\n\t\t\tend else if(Address==9'h06C ) begin   OutDato <= Y2;\n\t\t\tend else if(Address==9'h070 ) begin   OutDato <= Y3;\n\t\t\tend else if(Address==9'h074 ) begin   OutDato <= Y4;\n\t\t\tend else if(Address==9'h078 ) begin   OutDato <= Y5;\n\t\t\tend else if(Address==9'h07C ) begin   OutDato <= Y6;\n\t\t\tend else if(Address==9'h080 ) begin   OutDato <= Y7;\n\t\t\tend else if(Address==9'h084 ) begin   OutDato <= Y8;\n\t\t\tend else if(Address==9'h088 ) begin   OutDato <= Y9;\t\n\t\t\tend else begin\n\t\t\t\tOutDato <= 0;\n\t\t\tend\n\t\tend\n\t\telse begin\n\t\t\tOutDato <= 0;\n\t\tend\n\tend\nendmodule\n\n",
        "module_name": "EscrituraRegistroToMemoria#",
        "module_hash": "155a416d08c8ef7bc24d525a44d6a88f",
        "dataset_index": 13206
      },
      "decade_counter_89ba0769": {
        "rtl_code": "module decade_counter (\n    input clk,\n    input slowena,\n    input reset,\n    input pause,\n    output reg [3:0] q\n);\n\nreg [3:0] johnson_q;\nreg [3:0] next_johnson_q;\nreg pause_count;\n\nalways @ (posedge clk) begin\n    if (reset) begin\n        johnson_q <= 4'b0000;\n        q <= 4'b0000;\n        pause_count <= 0;\n    end else begin\n        if (slowena) begin\n            next_johnson_q[3] <= johnson_q[2];\n            next_johnson_q[2] <= johnson_q[1];\n            next_johnson_q[1] <= johnson_q[0];\n            next_johnson_q[0] <= ~johnson_q[3] & ~johnson_q[2] & ~johnson_q[1] & ~johnson_q[0];\n            johnson_q <= next_johnson_q;\n        end\n        \n        if (pause) begin\n            pause_count <= 1;\n        end else if (pause_count > 0) begin\n            pause_count <= pause_count + 1;\n        end else begin\n            q <= johnson_q;\n        end\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input slowena,\n    input reset,\n    output [3:0] q\n);\n\nwire pause;\nreg slow_clk;\n\nassign pause = q == 4'b1001;\n\nalways @ (posedge clk) begin\n    if (reset) begin\n        slow_clk <= 1'b0;\n    end else begin\n        if (slowena) begin\n            if (slow_clk) begin\n                slow_clk <= 1'b0;\n            end else begin\n                slow_clk <= 1'b1;\n            end\n        end\n    end\nend\n\ndecade_counter counter (\n    .clk(clk),\n    .slowena(slow_clk),\n    .reset(reset),\n    .pause(pause),\n    .q(q)\n);\n\nendmodule",
        "module_name": "decade_counter",
        "module_hash": "89ba0769cf9e640fd444e8efd5748884",
        "dataset_index": 16632
      },
      "byte_sum_and_multiply_751dee4c": {
        "rtl_code": "module byte_sum_and_multiply (\n  input wire [15:0] in,\n  output reg [15:0] out\n);\n\n  reg [7:0] upper_byte;\n  reg [7:0] lower_byte;\n  reg [15:0] sum;\n\n  always @(*) begin\n    upper_byte = in[15:8];\n    lower_byte = in[7:0];\n    sum = upper_byte + lower_byte;\n    out = sum * 2;\n  end\n\nendmodule",
        "module_name": "byte_sum_and_multiply",
        "module_hash": "751dee4c46be5c137650607691ae41d0",
        "dataset_index": 633
      },
      "video_scaler_sdivhbi_div_u_e9f97946": {
        "rtl_code": "\n\nmodule video_scaler_sdivhbi_div_u\n#(parameter\n    in0_WIDTH = 32,\n    in1_WIDTH = 32,\n    out_WIDTH = 32\n)\n(\n    input                       clk,\n    input                       reset,\n    input                       ce,\n    input                       start,\n    input       [in0_WIDTH-1:0] dividend,\n    input       [in1_WIDTH-1:0] divisor,\n    input       [1:0]           sign_i,\n    output wire [1:0]           sign_o,\n    output wire                 done,\n    output wire [out_WIDTH-1:0] quot,\n    output wire [out_WIDTH-1:0] remd\n);\n\nlocalparam cal_WIDTH = (in0_WIDTH > in1_WIDTH)? in0_WIDTH : in1_WIDTH;\n\nreg     [in0_WIDTH-1:0] dividend0;\nreg     [in1_WIDTH-1:0] divisor0;\nreg     [1:0]           sign0;\nreg     [in0_WIDTH-1:0] dividend_tmp;\nreg     [in0_WIDTH-1:0] remd_tmp;\nwire    [in0_WIDTH-1:0] dividend_tmp_mux;\nwire    [in0_WIDTH-1:0] remd_tmp_mux;\nwire    [in0_WIDTH-1:0] comb_tmp;\nwire    [cal_WIDTH:0]   cal_tmp;\n\nassign  quot   = dividend_tmp;\nassign  remd   = remd_tmp;\nassign  sign_o = sign0;\n\nalways @(posedge clk)\nbegin\n    if (start) begin\n        dividend0 <= dividend;\n        divisor0  <= divisor;\n        sign0     <= sign_i;\n    end\nend\n\nreg     [in0_WIDTH:0]     r_stage;\nassign done = r_stage[in0_WIDTH];\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        r_stage[in0_WIDTH:0] <= {in0_WIDTH{1'b0}};\n    else if (ce)\n        r_stage[in0_WIDTH:0] <= {r_stage[in0_WIDTH-1:0], start};\nend\n\nassign  dividend_tmp_mux = r_stage[0]? dividend0 : dividend_tmp;\nassign  remd_tmp_mux     = r_stage[0]? {in0_WIDTH{1'b0}} : remd_tmp;\n\nif (in0_WIDTH == 1) assign comb_tmp = dividend_tmp_mux[0];\nelse                assign comb_tmp = {remd_tmp_mux[in0_WIDTH-2:0], dividend_tmp_mux[in0_WIDTH-1]};\n\nassign  cal_tmp  = {1'b0, comb_tmp} - {1'b0, divisor0};\n\nalways @(posedge clk)\nbegin\n    if (ce) begin\n        if (in0_WIDTH == 1) dividend_tmp <= ~cal_tmp[cal_WIDTH];\n        else           dividend_tmp <= {dividend_tmp_mux[in0_WIDTH-2:0], ~cal_tmp[cal_WIDTH]};\n        remd_tmp     <= cal_tmp[cal_WIDTH]? comb_tmp : cal_tmp[in0_WIDTH-1:0];\n    end\nend\n\nendmodule\n\nmodule video_scaler_sdivhbi_div\n#(parameter\n        in0_WIDTH   = 32,\n        in1_WIDTH   = 32,\n        out_WIDTH   = 32\n)\n(\n        input                           clk,\n        input                           reset,\n        input                           ce,\n        input                           start,\n        output  reg                     done,\n        input           [in0_WIDTH-1:0] dividend,\n        input           [in1_WIDTH-1:0] divisor,\n        output  reg     [out_WIDTH-1:0] quot,\n        output  reg     [out_WIDTH-1:0] remd\n);\nreg                       start0 = 'b0;\nwire                      done0;\nreg     [in0_WIDTH-1:0] dividend0;\nreg     [in1_WIDTH-1:0] divisor0;\nwire    [in0_WIDTH-1:0] dividend_u;\nwire    [in1_WIDTH-1:0] divisor_u;\nwire    [out_WIDTH-1:0] quot_u;\nwire    [out_WIDTH-1:0] remd_u;\nwire    [1:0]   sign_i;\nwire    [1:0]   sign_o;\nvideo_scaler_sdivhbi_div_u #(\n    .in0_WIDTH      ( in0_WIDTH ),\n    .in1_WIDTH      ( in1_WIDTH ),\n    .out_WIDTH      ( out_WIDTH )\n) video_scaler_sdivhbi_div_u_0 (\n    .clk      ( clk ),\n    .reset    ( reset ),\n    .ce       ( ce ),\n    .start    ( start0 ),\n    .done     ( done0 ),\n    .dividend ( dividend_u ),\n    .divisor  ( divisor_u ),\n    .sign_i   ( sign_i ),\n    .sign_o   ( sign_o ),\n    .quot     ( quot_u ),\n    .remd     ( remd_u )\n);\nassign sign_i     = {dividend0[in0_WIDTH-1] ^ divisor0[in1_WIDTH-1], dividend0[in0_WIDTH-1]};\nassign dividend_u = dividend0[in0_WIDTH-1]? ~dividend0[in0_WIDTH-1:0] + 1'b1 :\n                                              dividend0[in0_WIDTH-1:0];\nassign divisor_u  = divisor0[in1_WIDTH-1]?  ~divisor0[in1_WIDTH-1:0] + 1'b1 :\n                                              divisor0[in1_WIDTH-1:0];\n\nalways @(posedge clk)\nbegin\n    if (ce) begin\n        dividend0 <= dividend;\n        divisor0  <= divisor;\n        start0    <= start;\n    end\nend\n\nalways @(posedge clk)\nbegin\n    done <= done0;\nend\n\nalways @(posedge clk)\nbegin\n    if (done0) begin\n        if (sign_o[1])\n            quot <= ~quot_u + 1'b1;\n        else\n            quot <= quot_u;\n    end\nend\n\nalways @(posedge clk)\nbegin\n    if (done0) begin\n        if (sign_o[0])\n            remd <= ~remd_u + 1'b1;\n        else\n            remd <= remd_u;\n    end\nend\n\nendmodule\n\nmodule video_scaler_sdivhbi(\n    clk,\n    reset,\n    ce,\n    start,\n    done,\n    din0,\n    din1,\n    dout);\n\nparameter ID = 32'd1;\nparameter NUM_STAGE = 32'd1;\nparameter din0_WIDTH = 32'd1;\nparameter din1_WIDTH = 32'd1;\nparameter dout_WIDTH = 32'd1;\ninput clk;\ninput reset;\ninput ce;\ninput start;\noutput done;\ninput[din0_WIDTH - 1:0] din0;\ninput[din1_WIDTH - 1:0] din1;\noutput[dout_WIDTH - 1:0] dout;\n\nwire[dout_WIDTH - 1:0] sig_remd;\n\n\nvideo_scaler_sdivhbi_div #(\n.in0_WIDTH( din0_WIDTH ),\n.in1_WIDTH( din1_WIDTH ),\n.out_WIDTH( dout_WIDTH ))\nvideo_scaler_sdivhbi_div_U(\n    .dividend( din0 ),\n    .divisor( din1 ),\n    .quot( dout ),\n    .remd( sig_remd ),\n    .clk( clk ),\n    .ce( ce ),\n    .reset( reset ),\n    .start( start ),\n    .done( done ));\n\nendmodule\n\n",
        "module_name": "video_scaler_sdivhbi_div_u",
        "module_hash": "e9f979461e38b0aeb196e1adba5c1ff7",
        "dataset_index": 21728
      },
      "MemTextures_ec3621ea": {
        "rtl_code": "\nmodule MemTextures(a, clk, spo);\n  input [7:0] a;\n  input clk;\n  output [91:0] spo;\n\n  reg [31:0] mem[255:0];\n  reg [91:0] spo;  // Change to reg\n\n  always @(posedge clk) begin\n    spo <= {a, mem[a]};\n  end\n\nendmodule\n",
        "module_name": "MemTextures",
        "module_hash": "ec3621ea6d491ba332f415d2eacbec0a",
        "dataset_index": 17499
      },
      "subleq_249daaaf": {
        "rtl_code": "module subleq(\n    input iClock,\n    input iReset,\n    input [31:0] iInstruction,\n    output reg [31:0] oIP,\n    output reg [31:0] oA,\n    output reg [31:0] oB,\n    output reg oJump,\n    output reg [31:0] oNextIP\n);\n\nreg [31:0] S;\nreg [31:0] D;\nreg [31:0] B;\nreg [31:0] sub;\nreg leq;\n\nalways @(posedge iClock) begin\n    if (iReset) begin\n        oIP <= 32'd0;\n        oA <= 32'd0;\n        oB <= 32'd0;\n        oJump <= 1'b0;\n        oNextIP <= 32'd0;\n    end else begin\n        // fetch instruction\n        S <= iInstruction[23:16];\n        D <= iInstruction[15:8];\n        B <= iInstruction[7:0];\n        \n        // execute subleq instruction\n        sub <= D - S;\n        leq <= sub[31] || sub == 32'b0;\n        oJump <= leq;\n        oNextIP <= leq ? B : oIP + 32'd4;\n        oA <= D - S;\n        oB <= B;\n        oIP <= oJump ? B : oIP + 32'd4;\n    end\nend\n\nendmodule",
        "module_name": "subleq",
        "module_hash": "249daaaf5dc3430c6120a189c548355a",
        "dataset_index": 18568
      },
      "binary_to_gray_ca33882a": {
        "rtl_code": "module binary_to_gray(\n    input  [3:0] binary,\n    output [3:0] gray\n);\n    assign gray[0] = binary[0];\n    assign gray[1] = binary[0] ^ binary[1];\n    assign gray[2] = binary[1] ^ binary[2];\n    assign gray[3] = binary[2] ^ binary[3];\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "ca33882ae4623b43d0d7e710209c242e",
        "dataset_index": 1709
      },
      "ripple_carry_adder_f0266233": {
        "rtl_code": "module ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] R,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    // Full adder instance\n    full_adder FA0(A[0], B[0], 1'b0, sum[0], carry[0]);\n    full_adder FA1(A[1], B[1], carry[0], sum[1], carry[1]);\n    full_adder FA2(A[2], B[2], carry[1], sum[2], carry[2]);\n    full_adder FA3(A[3], B[3], carry[2], sum[3], Cout);\n\n    assign R = sum;\n\nendmodule\n\n// Full adder module\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "f0266233e25f50be01f275f98699eff7",
        "dataset_index": 6690
      },
      "priority_mux_3a252ed9": {
        "rtl_code": "module priority_mux (\n    input [3:0] in,\n    output reg out\n);\n\nreg [1:0] select;\n\nalways @* begin\n    case(in)\n        4'b0001: select = 2'b00;\n        4'b0010: select = 2'b01;\n        4'b0100: select = 2'b10;\n        4'b1000: select = 2'b11;\n        default: select = 2'b00;\n    endcase\nend\n\nalways @* begin\n    case(select)\n        2'b00: out = in[0];\n        2'b01: out = in[1];\n        2'b10: out = in[2];\n        2'b11: out = in[3];\n        default: out = 1'b0;\n    endcase\nend\n\nendmodule",
        "module_name": "priority_mux",
        "module_hash": "3a252ed9afb0802c39788a1ddb2c8cd2",
        "dataset_index": 4174
      },
      "mux4to1_2b27427d": {
        "rtl_code": "module mux4to1 (Y, A, B, C, D, S0, S1);\n   input A, B, C, D, S0, S1;\n   output Y;\n\n   assign Y = (S1 == 0 && S0 == 0) ? A :\n              (S1 == 0 && S0 == 1) ? B :\n              (S1 == 1 && S0 == 0) ? C :\n                                     D ;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "2b27427df26c0a5be810b110712cc9e2",
        "dataset_index": 12328
      },
      "my__a093f404": {
        "rtl_code": "module my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n\n    // Local signals\n    wire\tand0_out          ;\n    wire    nor0_out_Y        ;\n\n    //                           Name          Output              Other arguments\n    and                          and0         (and0_out          , A1, A2                );\n    nor                          nor0         (nor0_out_Y        , B1, C1, D1, and0_out  );\n    buf                          buf0         (Y                 , nor0_out_Y    );\n\nendmodule",
        "module_name": "my_",
        "module_hash": "a093f4048343c08e347868010021309c",
        "dataset_index": 11124
      },
      "game_graph_d3b86173": {
        "rtl_code": "module game_graph\n   (\n    input wire clk, reset,\n    input wire video_on,\n    input wire [2:0] sw,\n    input wire gra_still,\n    input wire [9:0] pix_x, pix_y,\n    output reg hit, miss, kill,\n    output wire graph_on,\n    output reg [2:0] graph_rgb\n   );\n\n   localparam MAX_X = 640;\n   localparam MAX_Y = 480;\n   wire refr_tick;\n   localparam WALL_X_L = 20;\n   localparam WALL_X_R = 25;\n   localparam GUN_X_L = 50;\n   localparam GUN_X_R = 53;\n   wire [9:0] gun_y_t;\n   wire [9:0] gun_y_b;\n   reg [9:0] gun_y_reg;\n   reg [9:0] gun_y_next;\n   localparam GUN_V = 2;\n   localparam GUN_Y_SIZE = 62;\n   localparam BULLET_SIZE = 9;\n   localparam BULLET_V = 5;\n   wire [9:0] bullet_x_l, bullet_x_r;\n   wire [9:0] bullet_y_t, bullet_y_b;\n   reg [9:0] bullet_x_reg;\n   reg [9:0] bullet_y_reg; \n   reg [9:0] bullet_x_next;\n   reg [9:0] bullet_y_next;      \n   localparam BAR_X_L = 600;\n   localparam BAR_X_R = 603;\n   wire [9:0] bar_y_t, bar_y_b;\n   localparam BAR_Y_SIZE = 72;\n   reg [9:0] bar_y_reg, bar_y_next;\n   localparam BAR_V = 4;\n   localparam BALL_SIZE = 8;\n   wire [9:0] ball_x_l, ball_x_r;\n   wire [9:0] ball_y_t, ball_y_b;\n   reg [9:0] ball_x_reg, ball_y_reg;\n   wire [9:0] ball_x_next, ball_y_next;\n   reg [9:0] x_delta_reg, x_delta_next;\n   reg [9:0] y_delta_reg, y_delta_next;\n   localparam BALL_V_P = 2;\n   localparam BALL_V_N = -2;\n   wire [2:0] rom_addr, rom_col;\n   reg [7:0] rom_data;\n   wire rom_bit;\n   wire wall_on, bar_on, gun_on, bullet_on, sq_ball_on, rd_ball_on;\n   wire [2:0] wall_rgb, gun_rgb, bullet_rgb, bar_rgb, ball_rgb;\n\n   always @*\n   case (rom_addr)\n      3'h0: rom_data = 8'b00111100; 3'h1: rom_data = 8'b01111110; 3'h2: rom_data = 8'b11111111; 3'h3: rom_data = 8'b11111111; 3'h4: rom_data = 8'b11111111; 3'h5: rom_data = 8'b11111111; 3'h6: rom_data = 8'b01111110; 3'h7: rom_data = 8'b00111100; endcase\n\n   always @(posedge clk, posedge reset)\n      if (reset)\n         begin\n            bar_y_reg <= 0;\n            gun_y_reg <= 0;\n            ball_x_reg <= 0;\n            ball_y_reg <= 0;\n            bullet_x_reg <= GUN_X_R;\n            bullet_y_reg <= 0+GUN_Y_SIZE/2; \n            x_delta_reg <= 10'h004;\n            y_delta_reg <= 10'h004;\n         end\n      else\n         begin\n            bar_y_reg <= bar_y_next;\n            gun_y_reg <= gun_y_next;\n            ball_x_reg <= ball_x_next;\n            ball_y_reg <= ball_y_next;\n            x_delta_reg <= x_delta_next;\n            y_delta_reg <= y_delta_next;\n            bullet_x_reg <= bullet_x_next; bullet_y_reg <= bullet_y_next;\n            end\n\n   assign refr_tick = (pix_y==481) && (pix_x==0);\n\n   assign wall_on = (WALL_X_L<=pix_x) && (pix_x<=WALL_X_R);\n   assign wall_rgb = 3'b001; assign bar_y_t = bar_y_reg;\n   assign bar_y_b = bar_y_t + BAR_Y_SIZE - 1;\n   assign bar_on = (BAR_X_L<=pix_x) && (pix_x<=BAR_X_R) &&\n                   (bar_y_t<=pix_y) && (pix_y<=bar_y_b);\n   assign bar_rgb = 3'b010; always @*\n   begin\n      bar_y_next = bar_y_reg; if(gra_still)\n         bar_y_next = (MAX_Y-BAR_Y_SIZE)/2;\n      else if (refr_tick)\n         if (~sw[2] & (bar_y_b < (MAX_Y-1-BAR_V)))\n            bar_y_next = bar_y_reg + BAR_V; else if (sw[2] & (bar_y_t > BAR_V))\n            bar_y_next = bar_y_reg - BAR_V; end\n   assign gun_y_t = gun_y_reg;\n   assign gun_y_b = gun_y_t + GUN_Y_SIZE -1;\n   assign gun_on = (GUN_X_L<=pix_x) && (pix_x<=GUN_X_R) && (gun_y_t<=pix_y) && (pix_y<=gun_y_b);\n   assign gun_rgb = 3'b000;\n   always @*\n   begin\n      gun_y_next = gun_y_reg;\n      if(gra_still)\n         gun_y_next = (MAX_Y-GUN_Y_SIZE)/2;        \n      else if (refr_tick)\n         if (sw[0] & (gun_y_b < (MAX_Y-1-GUN_V)))\n            gun_y_next = gun_y_reg + GUN_V; else if ( (~sw[0]) & (gun_y_t > GUN_V) )\n            gun_y_next = gun_y_reg - GUN_V; end\n   assign bullet_x_l = bullet_x_reg;\n   assign bullet_x_r = bullet_x_l + BULLET_SIZE -1;\n   assign bullet_y_t = bullet_y_reg;\n   assign bullet_y_b = bullet_y_t + BULLET_SIZE -1;\n   \n   assign bullet_on =\n            (bullet_x_l<=pix_x) && (pix_x<=bullet_x_r) &&\n            (bullet_y_t<=pix_y) && (pix_y<=bullet_y_b);\n   assign bullet_rgb = 3'b000; always @*\n   begin\n      kill = 1'b0;\n      bullet_x_next = bullet_x_reg;\n      bullet_y_next = bullet_y_reg;\n      if(gra_still)\n         begin\n            bullet_x_next = GUN_X_R;\n            bullet_y_next = (MAX_Y-GUN_Y_SIZE)/2 + GUN_Y_SIZE/2; \n         end\n      else if (refr_tick)      \n         if ((BAR_X_L<=bullet_x_r) && (bullet_x_r<=BAR_X_R) &&\n               (bar_y_t<=bullet_y_b) && (bullet_y_t<=bar_y_b))\n         begin\n               bullet_x_next = GUN_X_R;\n               bullet_y_next = gun_y_reg+GUN_Y_SIZE/2;\n               kill = 1'b1;\n               end\n         else if ( sw[1] || (bullet_x_l >= GUN_X_R+5) )\n            bullet_x_next = bullet_x_reg + BULLET_V; \n         else if ( (bullet_x_reg<=(GUN_X_L-1)) || (bullet_x_reg>=(MAX_X-BULLET_SIZE-1)) ) \n         begin\n            bullet_x_next = GUN_X_R;\n            bullet_y_next = gun_y_reg+GUN_Y_SIZE/2;\n            end            \n         else\n            begin\n            bullet_x_next = GUN_X_R;\n            bullet_y_next = gun_y_reg+GUN_Y_SIZE/2;\n            end         \n   end\n   assign ball_x_l = ball_x_reg;\n   assign ball_y_t = ball_y_reg;\n   assign ball_x_r = ball_x_l + BALL_SIZE - 1;\n   assign ball_y_b = ball_y_t + BALL_SIZE - 1;\n   assign sq_ball_on =\n            (ball_x_l<=pix_x) && (pix_x<=ball_x_r) &&\n            (ball_y_t<=pix_y) && (pix_y<=ball_y_b);\n   assign rom_addr = pix_y[2:0] - ball_y_t[2:0];\n   assign rom_col = pix_x[2:0] - ball_x_l[2:0];\n   assign rom_bit = rom_data[rom_col];\n   assign rd_ball_on = sq_ball_on & rom_bit;\n   assign ball_rgb = 3'b100;   assign ball_x_next = (gra_still) ? MAX_X/2 :\n                        (refr_tick) ? ball_x_reg+x_delta_reg :\n                        ball_x_reg ;\n   assign ball_y_next = (gra_still) ? MAX_Y/2 :\n                        (refr_tick) ? ball_y_reg+y_delta_reg :\n                        ball_y_reg ;\n   always @*\n   begin\n      hit = 1'b0;\n      miss = 1'b0;\n      x_delta_next = x_delta_reg;\n      y_delta_next = y_delta_reg;\n      if (gra_still)     begin\n            x_delta_next = BALL_V_N;\n            y_delta_next = BALL_V_P;\n         end   \n      else if (ball_y_t < 1) y_delta_next = BALL_V_P;\n      else if (ball_y_b > (MAX_Y-1)) y_delta_next = BALL_V_N;\n      else if (ball_x_l <= WALL_X_R) x_delta_next = BALL_V_P;    else if ((BAR_X_L<=ball_x_r) && (ball_x_r<=BAR_X_R) &&\n               (bar_y_t<=ball_y_b) && (ball_y_t<=bar_y_b))\n         begin\n            x_delta_next = BALL_V_N;  \n            hit = 1'b1;\n         end\n      else if (ball_x_r>MAX_X)   miss = 1'b1;            end \n   always @*\n      if (~video_on)\n         graph_rgb = 3'b000; else\n         if (wall_on)\n            graph_rgb = wall_rgb;\n         else if (bullet_on)\n            graph_rgb = bullet_rgb;         \n         else if (bar_on)\n            graph_rgb = bar_rgb;\n         else if (gun_on)\n            graph_rgb = gun_rgb;\n         else if (rd_ball_on)\n         graph_rgb = ball_rgb;\n         else\n            graph_rgb = 3'b110; assign graph_on = wall_on | bar_on | rd_ball_on | bullet_on | gun_on;\n   endmodule\n",
        "module_name": "game_graph",
        "module_hash": "d3b861738a918e55950d12072a67bfe8",
        "dataset_index": 23090
      },
      "carry_lookahead_adder_e5054538": {
        "rtl_code": "module carry_lookahead_adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] sum\n);\n\nwire [15:0] p, g;\nwire [3:0] c;\n\nassign p = a ^ b;\nassign g = a & b;\n\nassign c[0] = g[0];\nassign c[1] = g[1] | (p[1] & g[0]);\nassign c[2] = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]);\nassign c[3] = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]);\n\nassign sum = {c[3], c[2], c[1], c[0]} + {a, b};\n\nendmodule\n\nmodule top_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] sum\n);\n\ncarry_lookahead_adder adder(a, b, sum);\n\nendmodule",
        "module_name": "carry_lookahead_adder",
        "module_hash": "e50545383b3a78d75a43fcf5951087c8",
        "dataset_index": 7781
      },
      "shift_register_f7f17cd1": {
        "rtl_code": "\nmodule shift_register (\n    input wire s_axi_aclk,\n    input wire [7:0] D,\n    input wire shift_reg_ld0,\n    input wire [0:0] SR,\n    input wire [0:0] E,\n    input wire detect_start,\n    input wire detect_stop_reg,\n    input wire sda_sample,\n    input wire master_slave_reg,\n    input wire [2:0] out,\n    output wire arb_lost_reg,\n    output wire abgc_i_reg_0,\n    output wire shift_reg_ld,\n    output reg [7:0] Q\n);\n\nreg [7:0] shift_reg;\n\nalways @(posedge s_axi_aclk) begin\n    if (SR == 1'b1) begin\n        shift_reg <= 8'b0;\n    end else if (E == 1'b1) begin\n        if (shift_reg_ld0 == 1'b1) begin\n            shift_reg <= 8'b0;\n        end else begin\n            if (detect_start == 1'b1) begin\n                shift_reg <= 8'b0;\n            end else begin\n                shift_reg <= {shift_reg[6:0], sda_sample};\n            end\n        end\n    end\n    Q <= shift_reg; // Move the assignment inside the always block\nend\n\nassign abgc_i_reg_0 = (out == 3'b000) ? 1'b0 : (detect_start == 1'b1) ? 1'b1 : shift_reg;\n\nassign shift_reg_ld = (out == 3'b000) ? 1'b0 : (out == 3'b001) ? 1'b1 : (detect_stop_reg == 1'b1) ? 1'b1 : (shift_reg_ld0 == 1'b1) ? 1'b0 : 1'bx;\n\nassign arb_lost_reg = (master_slave_reg == 1'b1) ? ((shift_reg_ld0 == 1'b1) || (detect_start == 1'b1)) ? 1'b0 : ((shift_reg[7] == 1'b0) && (sda_sample == 1'b1)) ? 1'b1 : shift_reg : 1'bx;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "f7f17cd138a84b5ac6f58717f4eff840",
        "dataset_index": 14672
      },
      "pfpu_prog_6fbd571c": {
        "rtl_code": "\n\n\n\nmodule pfpu_prog(\n\tinput sys_clk,\n\tinput count_rst,\n\n\toutput [6:0] a_addr,\n\toutput [6:0] b_addr,\n\toutput [3:0] opcode,\n\toutput [6:0] w_addr,\n\t\n\t\n\tinput c_en,\n\tinput [1:0] c_page,\n\tinput [8:0] c_offset,\n\toutput [31:0] c_do,\n\tinput [31:0] c_di,\n\tinput c_w_en,\n\n\toutput [10:0] pc\n);\n\n\nwire [10:0] mem_a;\nwire [24:0] mem_di;\nreg [24:0] mem_do;\nwire mem_we;\nreg [24:0] mem[0:2047];\nalways @(posedge sys_clk) begin\n\tif(mem_we)\n\t\tmem[mem_a] <= mem_di;\n\tmem_do <= mem[mem_a];\nend\n\n\nreg [10:0] counter;\nalways @(posedge sys_clk) begin\n\tif(count_rst)\n\t\tcounter <= 10'd0;\n\telse\n\t\tcounter <= counter + 10'd1;\nend\nassign mem_a = c_en ? {c_page, c_offset} : counter;\n\nassign c_do = {7'd0, mem_do};\nassign mem_di = c_di[24:0];\nassign mem_we = c_en & c_w_en;\n\nassign a_addr = mem_do[24:18];\tassign b_addr = mem_do[17:11];\tassign opcode = mem_do[10:7];\tassign w_addr = mem_do[6:0];\tassign pc = counter;\n\nendmodule\n",
        "module_name": "pfpu_prog",
        "module_hash": "6fbd571c92235099d3a00241b6d0db99",
        "dataset_index": 23615
      },
      "mux4bit_994e1cef": {
        "rtl_code": "module mux4bit (MO, A, B, S);\n   input [3:0] A, B;\n   input       S;\n   output [3:0] MO; \n   \n   assign MO = (S == 1) ? B : A; \n   \nendmodule",
        "module_name": "mux4bit",
        "module_hash": "994e1cefd56ea317d68349e6ae3a6780",
        "dataset_index": 12501
      },
      "SPM #_19236e41": {
        "rtl_code": "\nmodule SPM #(\n  parameter depth = 16, // size of the memory block\n  parameter data_width = 8 // width of each data element in bits\n)(\n  input clk,\n  input write_en,\n  input read_en,\n  input [clogb2(depth)-1:0] addr, \n  input [data_width-1:0] data_in,\n  output reg [data_width-1:0] data_out\n);\n\n\n// memory array\nreg [data_width-1:0] mem [0:depth-1];\n\n// Calculate the logarithm of depth using a constant expression\nparameter log2_depth = $clog2(depth);\n\nalways @(posedge clk) begin\n  if (write_en) begin\n    mem[addr] <= data_in;\n  end\n  if (read_en) begin\n    data_out <= mem[addr];\n  end\nend\n\nfunction integer clogb2;\n  input integer depth;\n  integer cnt;\n  begin\n    cnt = 0;\n    while (depth > 0) begin\n      depth = depth >> 1;\n      cnt = cnt + 1;\n    end\n    clogb2 = cnt - 1;\n  end\nendfunction\n\nendmodule\n",
        "module_name": "SPM #",
        "module_hash": "19236e419dbacd8ff0495194440f6073",
        "dataset_index": 18656
      },
      "BCD_to_Binary_463058a6": {
        "rtl_code": "module BCD_to_Binary (\n  input [3:0] bcd_in,\n  output reg [7:0] bin_out\n);\n\n  always @ (bcd_in) begin\n    case (bcd_in)\n      4'd0: bin_out = 8'b00000000;\n      4'd1: bin_out = 8'b00000001;\n      4'd2: bin_out = 8'b00000010;\n      4'd3: bin_out = 8'b00000011;\n      4'd4: bin_out = 8'b00000100;\n      4'd5: bin_out = 8'b00000101;\n      4'd6: bin_out = 8'b00000110;\n      4'd7: bin_out = 8'b00000111;\n      4'd8: bin_out = 8'b00001000;\n      4'd9: bin_out = 8'b00001001;\n      default: bin_out = 8'b00000000;\n    endcase\n  end\n\nendmodule",
        "module_name": "BCD_to_Binary",
        "module_hash": "463058a64186092e8bb7d2e08ed4ad0a",
        "dataset_index": 11842
      },
      "mux2to1_231afab3": {
        "rtl_code": "module mux2to1 (\n    input A0,\n    input A1,\n    input S,\n    output Y,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n    // Local signals\n    wire not_S;\n    wire A0_and_not_S;\n    wire A1_and_S;\n    wire Y_buf;\n\n    // Invert S signal\n    not #(1) not_S_inst (not_S, S);\n\n    // AND A0 with not(S)\n    and #(1) A0_and_not_S_inst (A0_and_not_S, A0, not_S);\n\n    // AND A1 with S\n    and #(1) A1_and_S_inst (A1_and_S, A1, S);\n\n    // OR A0_and_not_S with A1_and_S\n    or #(1) Y_buf_inst (Y_buf, A0_and_not_S, A1_and_S);\n\n    // Buffer Y_buf to Y\n    buf #(1) buf_inst (Y, Y_buf);\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "231afab304ce6d549c9aacc2304d76b6",
        "dataset_index": 3010
      },
      "ripple_carry_adder_c4bb9ac6": {
        "rtl_code": "module ripple_carry_adder (\n    input [3:0] in0,\n    input [3:0] in1,\n    input carry_in,\n    output reg [3:0] sum,\n    output reg carry_out\n);\n\n    // Define internal signals\n    reg [3:0] temp_sum;\n    reg temp_carry;\n\n    // Implement the adder\n    always @(*) begin\n        temp_sum = in0 + in1 + carry_in;\n        temp_carry = (temp_sum > 4'b1111) ? 1'b1 : 1'b0;\n        sum = temp_sum;\n        carry_out = temp_carry;\n    end\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "c4bb9ac6e730dbc9839cb0fe44029375",
        "dataset_index": 14983
      },
      "sky130_fd_sc_ls__a2bb2oi_46fa9b4e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a2bb2oi (\n    Y   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out  ;\n    wire nor1_out_Y;\n\n    and and0 (and0_out  , B1, B2            );\n    nor nor0 (nor0_out  , A1_N, A2_N        );\n    nor nor1 (nor1_out_Y, nor0_out, and0_out);\n    buf buf0 (Y         , nor1_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a2bb2oi",
        "module_hash": "46fa9b4e12ae6cc76e6ee736f7d8585c",
        "dataset_index": 12468
      },
      "jserialaddlab_98bbf5e3": {
        "rtl_code": "module jserialaddlab (\n  input wire clk, \n  input wire reset, \n  input wire a, \n  input wire b, \n  output reg sum, \n  output reg carry, \n  output reg cout, \n  output reg [3:0] so, \n  output reg [2:0] count\n);\n\n  reg cut;\n  reg cin;\n\n  always @*\n  begin\n    sum = a ^ b ^ cin;\n    cut = (a & b) | (a & cin) | (b & cin);\n    carry = (count == 4'b100) ? 1'b0 : cut;\n  end\n\n  always @(posedge clk)\n  begin\n    if(reset)\n      cin <= 1'b0;\n    else\n      cin <= carry;\n  end\n\n  always @(posedge clk)\n  begin\n    if(reset)\n      cout <= 1'b0;\n    else\n      cout <= (count == 4'b100) ? (a & 4'b1000) : 1'b0;\n  end\n\n  always @(posedge clk)\n  begin\n    if(reset)\n      so <= 4'b0;\n    else\n      so <= {sum, so[3:1]};\n  end\n\n  always @(posedge clk)\n  begin\n    if(reset)\n      count <= 3'b0;\n    else\n      count <= (cut) ? count + 1 : 3'b0;\n  end\n\nendmodule",
        "module_name": "jserialaddlab",
        "module_hash": "98bbf5e33e94bec20d8fdc796c8d200e",
        "dataset_index": 9111
      },
      "lcd_ctrl #_139b13af": {
        "rtl_code": "\n\nmodule lcd_ctrl #(\n\tparameter WB_CLOCK_FREQUENCY = 50_000_000\n)\n(\n\tinput\t\twb_clk_i,\n\tinput\t\twb_rst_i,\n\n\toutput\t\thsync_n_o,\n\toutput\t\tvsync_n_o,\n\toutput\t\tblank_n_o,\n\toutput\t[7:0]\tlcd_data_o,\n\toutput\t\tlcd_rst_n_o,\n\n\toutput\t\tlcd_scen_o,\n\toutput\t\tlcd_scl_o,\n\toutput\t\tlcd_sda_o,\n\n\tinput\t\tpixel_clk_i,\n\tinput\t\tpixel_rst_i,\n\n\tinput\t\thsync_i,\n\tinput\t\tvsync_i,\n\tinput\t\tblank_i,\n\tinput [7:0]\tr_i,\n\tinput [7:0]\tg_i,\n\tinput [7:0]\tb_i\n);\n\n\tlocalparam [3:0]\n\t\tLCD_RESET   = 4'h0,\n\t\tSTART_DELAY = 4'h1,\n\t\tIDLE        = 4'h2,\n\t\tDELAY_INIT  = 4'h3,\n\t\tSTART_XFER  = 4'h4,\n\t\tCLK_PULSE_0 = 4'h5,\n\t\tCLK_PULSE_1 = 4'h6,\n\t\tDONE        = 4'h7,\n\t\tWAIT        = 4'h8;\n\n\tlocalparam BIT_DELAY     = 100 * (WB_CLOCK_FREQUENCY / 1000000); localparam STARTUP_DELAY = 100 * (WB_CLOCK_FREQUENCY / 1000);    localparam RESET_DELAY   = 20  * (WB_CLOCK_FREQUENCY / 1000);    reg [4:0]\tstate;\n\n\treg\t\tlcd_scen;\n\treg\t\tlcd_scl;\n\treg\t\tlcd_sda;\n\treg\t\tlcd_req;\n\n\treg [15:0]\tlcd_serial_dat;\n\treg [5:0]\tlcd_serial_adr;\n\treg [7:0]\tlcd_serial_reg;\n\n\tassign\t\tlcd_scen_o = lcd_scen;\n\tassign\t\tlcd_scl_o = lcd_scl;\n\tassign\t\tlcd_sda_o = lcd_sda;\n\n\treg [7:0]\tcur_reg;\n\treg [4:0]\tbit_idx;\n\treg\t\tlcd_rst_n;\n\n\tinteger\t\tdelay;\n\n\tlocalparam NB_INIT_REGS  = 19;\n\n\treg [15:0]\tinit_values [0:31];\n\n\tinitial begin\n\t\tinit_values[0] = {6'h11, 2'b00, 8'h05};\n\t\tinit_values[1] = {6'h12, 2'b00, 8'h6A};\n\t\tinit_values[2] = {6'h13, 2'b00, 8'hFF};\n\t\tinit_values[3] = {6'h14, 2'b00, 8'h6A};\n\t\tinit_values[4] = {6'h15, 2'b00, 8'hC8};\n\t\tinit_values[5] = {6'h16, 2'b00, 8'h21};\n\t\tinit_values[6] = {6'h17, 2'b00, 8'h77};\n\t\tinit_values[7] = {6'h18, 2'b00, 8'hCC};\n\t\tinit_values[8] = {6'h19, 2'b00, 8'h1F};\n\t\tinit_values[9] = {6'h1A, 2'b00, 8'h71};\n\t\tinit_values[10] = {6'h1B, 2'b00, 8'hC1};\n\t\tinit_values[11] = {6'h1C, 2'b00, 8'h11};\n\t\tinit_values[12] = {6'h1D, 2'b00, 8'h60};\n\t\tinit_values[13] = {6'h1E, 2'b00, 8'hAE};\n\t\tinit_values[14] = {6'h1F, 2'b00, 8'hFC};\n\t\tinit_values[15] = {6'h20, 2'b00, 8'hF0};\n\t\tinit_values[16] = {6'h21, 2'b00, 8'hF0};\n\n\t\tinit_values[17] = {6'h03, 2'b00, 8'h5F};\n\n\t\tinit_values[18] = {6'h02, 2'b00, 8'h07};\n\tend\n\n\tassign\tlcd_rst_n_o = lcd_rst_n;\n\n\talways @(posedge wb_clk_i or posedge wb_rst_i)\n\t\tif (wb_rst_i) begin\n\t\t\tstate\t\t<= LCD_RESET;\n\t\t\tlcd_scen\t<= 1'b1;\n\t\t\tlcd_scl\t\t<= 1'b0;\n\t\t\tlcd_sda\t\t<= 1'b1;\n\t\t\tcur_reg\t\t<= 0;\n\t\t\tbit_idx\t\t<= 0;\n\t\t\tlcd_req\t\t<= 1'b1;\n\t\t\tlcd_rst_n\t<= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\n\t\t\tLCD_RESET: begin\n\t\t\t\tif (delay < RESET_DELAY)\n\t\t\t\t\tdelay <= delay + 1;\n\t\t\t\telse begin\n\t\t\t\t\tdelay <= 0;\n\t\t\t\t\tlcd_rst_n <= 1'b1;\n\t\t\t\t\tstate <= START_DELAY;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tSTART_DELAY: begin\n\t\t\t\tif (delay < STARTUP_DELAY)\n\t\t\t\t\tdelay <= delay + 1;\n\t\t\t\telse begin\n\t\t\t\t\tdelay <= 0;\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tIDLE: begin\n\t\t\t\tif (cur_reg < (NB_INIT_REGS - 1))\n\t\t\t\t\tcur_reg <= cur_reg + 1;\n\t\t\t\telse\n\t\t\t\t\tlcd_req <= 1'b0;\n\n\t\t\t\tlcd_serial_dat <= init_values[cur_reg];\n\t\t\t\tif (lcd_req) begin\n\t\t\t\t\tlcd_scen\t<= 1'b0;\n\t\t\t\t\tbit_idx\t\t<= 0;\n\t\t\t\t\tdelay\t\t<= 0;\n\t\t\t\t\tstate\t\t<= DELAY_INIT;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tDELAY_INIT: begin\n\t\t\t\tif (delay < BIT_DELAY)\n\t\t\t\t\tdelay\t<= delay + 1;\n\t\t\t\telse begin\n\t\t\t\t\tdelay\t<= 0;\n\t\t\t\t\tstate\t<= START_XFER;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tSTART_XFER: begin\n\t\t\t\tlcd_sda <= lcd_serial_dat[15-bit_idx];\n\t\t\t\tif (bit_idx < 16) begin\n\t\t\t\t\tstate\t<= CLK_PULSE_0;\n\t\t\t\tend else begin\n\t\t\t\t\tlcd_sda\t<= 1'b0;\n\t\t\t\t\tdelay\t<= 0;\n\t\t\t\t\tstate\t<= DONE;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tCLK_PULSE_0: begin\n\t\t\t\tif (delay < BIT_DELAY)\n\t\t\t\t\tdelay\t<= delay + 1;\n\t\t\t\telse begin\n\t\t\t\t\tdelay\t<= 0;\n\t\t\t\t\tstate\t<= CLK_PULSE_1;\n\t\t\t\t\tlcd_scl\t<= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tCLK_PULSE_1: begin\n\t\t\t\tif (delay < BIT_DELAY)\n\t\t\t\t\tdelay\t<= delay + 1;\n\t\t\t\telse begin\n\t\t\t\t\tdelay\t<= 0;\n\t\t\t\t\tlcd_scl\t<= 1'b0;\n\t\t\t\t\tstate\t<= START_XFER;\n\t\t\t\t\tbit_idx\t<= bit_idx + 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tDONE: begin\n\t\t\t\tif (delay < BIT_DELAY)\n\t\t\t\t\tdelay\t<= delay + 1;\n\t\t\t\telse begin\n\t\t\t\t\tlcd_scen<= 1'b1;\n\t\t\t\t\tdelay\t<= 0;\n\t\t\t\t\tif (lcd_req)\n\t\t\t\t\t\tstate <= WAIT;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tWAIT: begin\n\t\t\t\tif (delay < BIT_DELAY)\n\t\t\t\t\tdelay\t<= delay + 1;\n\t\t\t\telse\n\t\t\t\t\tstate\t<= IDLE;\n\t\t\tend\n\n\t\t\tendcase\n\t\tend\n\n\treg [1:0]\tpix_count;\n\n\treg\t\thsync_r, hsync_r2;\n\treg\t\tvsync_r, vsync_r2;\n\treg\t\tblank_r, blank_r2;\n\treg [7:0]\tr_r, r_r2;\n\treg [7:0]\tg_r, g_r2;\n\treg [7:0]\tb_r, b_r2;\n\n\tassign hsync_n_o = hsync_r2;\n\tassign vsync_n_o = vsync_r2;\n\tassign blank_n_o = blank_r2;\n\n\tassign lcd_data_o = (pix_count == 0) ? b_r2 : (pix_count == 1) ? r_r2 : g_r2;\n\n\talways @(posedge pixel_clk_i or posedge pixel_rst_i)\n\tbegin\n\t\tif (pixel_rst_i == 1) begin\n\t\t\tpix_count\t<= 2'b0;\n\t\tend else begin\n\n\t\t\thsync_r2 <= hsync_r; hsync_r <= ~hsync_i;\n\t\t\tvsync_r2 <= vsync_r; vsync_r <= ~vsync_i;\n\t\t\tblank_r2 <= blank_r; blank_r <= ~blank_i;\n\n\t\t\tr_r2 <= r_r; r_r <= r_i;\n\t\t\tg_r2 <= g_r; g_r <= g_i;\n\t\t\tb_r2 <= b_r; b_r <= b_i;\n\n\t\t\tif (pix_count < 2)\n\t\t\t\tpix_count <= pix_count + 1;\n\t\t\telse\n\t\t\t\tpix_count <= 0;\n\n\t\t\tif (hsync_r2 && !hsync_r)\n\t\t\t\tpix_count <= 0;\n\n\t\t\tend\n\tend\n\nendmodule\n\n\n",
        "module_name": "lcd_ctrl #",
        "module_hash": "139b13af9b99129b836886a8eaeab795",
        "dataset_index": 25369
      },
      "shift_register_counter_a15b6d2a": {
        "rtl_code": "\nmodule shift_register_counter (\n    input clk,\n    input rst,\n    input en,\n    input load,\n    input [3:0] data_in,\n    input sel,\n    output [3:0] out\n);\n\nreg [3:0] shift_reg;\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        shift_reg <= 4'b0000;\n        counter <= 4'b0000;\n    end else if (en) begin\n        if (load) begin\n            shift_reg <= data_in;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign out = sel ? counter : shift_reg;\n\nendmodule\n\nmodule adder (\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] sum\n);\n\nassign sum = in1 + in2;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input rst,\n    input en,\n    input load,\n    input [3:0] data_in,\n    input sel,\n    output [3:0] out\n);\n\nwire [3:0] shift_reg_out;\nwire [3:0] counter_out;\nwire [3:0] sum_out;\n\nshift_register_counter shift_counter (\n    .clk(clk),\n    .rst(rst),\n    .en(en),\n    .load(load),\n    .data_in(data_in),\n    .sel(sel),\n    .out(shift_reg_out)\n);\n\nshift_register_counter counter (\n    .clk(clk),\n    .rst(rst),\n    .en(en),\n    .load(1'b0),\n    .data_in(4'b0000),\n    .sel(sel),\n    .out(counter_out)\n);\n\nadder sum (\n    .in1(shift_reg_out),\n    .in2(counter_out),\n    .sum(sum_out)\n);\n\nassign out = sum_out;\n\nendmodule\n",
        "module_name": "shift_register_counter",
        "module_hash": "a15b6d2adc31b2f9d35d2bab85caad59",
        "dataset_index": 21093
      },
      "glitch_filter_4825a773": {
        "rtl_code": "module glitch_filter (\n  input in,\n  input clk,\n  output reg out\n);\n\nparameter n = 10; // number of clock cycles to wait\nparameter t = 5; // threshold value for glitch detection\nparameter v = 0; // value to output when a glitch is detected\n\nreg [n-1:0] timer;\nreg glitch_detected;\nreg [1:0] input_history;\nwire input_above_threshold;\n\nassign input_above_threshold = (in > t);\n\nalways @(posedge clk) begin\n  if (timer == n-1) begin\n    if (glitch_detected) begin\n      out <= v;\n    end else begin\n      out <= in;\n    end\n    timer <= 0;\n    glitch_detected <= 0;\n  end else begin\n    timer <= timer + 1;\n    if (input_above_threshold) begin\n      input_history <= {input_history[0], 1'b1};\n    end else begin\n      input_history <= {input_history[0], 1'b0};\n    end\n    if (input_history == 2'b10) begin\n      glitch_detected <= 1;\n    end\n  end\nend\n\nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "4825a7732126fd6f83315ee63d89c252",
        "dataset_index": 10938
      },
      "mux2to1_3132c8a0": {
        "rtl_code": "module mux2to1 (\n    input  I0,\n    input  I1,\n    input  S,\n    output Y\n);\n\nassign Y = (S) ? I1 : I0;\n\nendmodule\n\nmodule mux4to1 (\n    input  A,\n    input  B,\n    input  C,\n    input  D,\n    input  S0,\n    input  S1,\n    output Y\n);\n\nwire w1, w2, w3;\n\nmux2to1 m1 (.I0(A), .I1(B), .S(S1), .Y(w1));\nmux2to1 m2 (.I0(C), .I1(D), .S(S1), .Y(w2));\nmux2to1 m3 (.I0(w1), .I1(w2), .S(S0), .Y(w3));\nassign Y = w3;\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "3132c8a03b4e8b0677b7ce33977a847d",
        "dataset_index": 1655
      },
      "modified_decade_counter_2fadce80": {
        "rtl_code": "module modified_decade_counter (\n  input clk,\n  input reset,\n  input control,\n  output reg [3:0] count\n);\n\n  reg [3:0] next_count;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0001;\n    end else begin\n      if (control) begin\n        if (count == 4'b0101) begin\n          next_count = 4'b0001;\n        end else begin\n          next_count = count + 1;\n        end\n      end else begin\n        if (count == 4'b1010) begin\n          next_count = 4'b0110;\n        end else begin\n          next_count = count + 1;\n        end\n      end\n      if (count == 4'b1010) begin\n        count <= 4'b0001;\n      end else begin\n        count <= next_count;\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "modified_decade_counter",
        "module_hash": "2fadce8011ccb7442d02962bc6e69fbc",
        "dataset_index": 13710
      },
      "binary_counter_4bit_79517b4d": {
        "rtl_code": "module binary_counter_4bit (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output reg [3:0] q // Output of the binary counter\n);\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\n\nmodule binary_counter_loadable (\n    input clk,\n    input reset,          // Asynchronous active-high reset\n    input load,           // Active-high parallel load input\n    input [3:0] load_value, // 4-bit load value\n    output reg [3:0] q,   // Output of the binary counter\n    output reg carry_out  // Carry-out output\n);\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q <= 4'b0101;\n            carry_out <= 0;\n        end else if (load) begin\n            q <= load_value;\n            carry_out <= 0;\n        end else if (q == 4'b1111) begin\n            carry_out <= 1;\n        end else begin\n            q <= q + 1;\n            carry_out <= 0;\n        end\n    end\n\nendmodule\n\nmodule control_logic (\n    input select,         // Select input to choose between the two modules\n    input [3:0] q1,       // Output from the first module\n    input [3:0] q2,       // Output from the second module\n    input carry_out,      // Carry-out output from the second module\n    output [3:0] q_out,   // Output from the active module\n    output led            // LED output controlled by the carry-out output\n);\n\n    assign q_out = select ? q2 : q1;\n    assign led = carry_out;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,          // Synchronous active-high reset\n    input load,           // Active-high parallel load input for the second module\n    input [3:0] load_value, // 4-bit load value for the second module\n    input select,         // Select input to choose between the two modules\n    output [3:0] q_out,   // Output from the active module\n    output carry_out,     // Carry-out output from the second module\n    output led            // LED output controlled by the carry-out output\n);\n\n    wire [3:0] q1;\n    wire [3:0] q2;\n    wire carry_out;\n\n    binary_counter_4bit counter1 (\n        .clk(clk),\n        .reset(reset),\n        .q(q1)\n    );\n\n    binary_counter_loadable counter2 (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .load_value(load_value),\n        .q(q2),\n        .carry_out(carry_out)\n    );\n\n    control_logic control (\n        .select(select),\n        .q1(q1),\n        .q2(q2),\n        .carry_out(carry_out),\n        .q_out(q_out),\n        .led(led)\n    );\n\nendmodule",
        "module_name": "binary_counter_4bit",
        "module_hash": "79517b4dd94d5a29d79db3c39c078cb3",
        "dataset_index": 5067
      },
      "csa_generate_adder_32bit #_4f402d18": {
        "rtl_code": "\nmodule csa_generate_adder_32bit #(\n  parameter SIZE = 32\n  )\n  (\n  input  [SIZE-1:0] A,\n  input  [SIZE-1:0] B,\n  output [SIZE-1:0] S,\n  output C_OUT\n  );\n\n  wire [SIZE:0] C;\n\n  assign C[SIZE] = 0;\n  assign {C[SIZE-1:0], S} = A + B + C[SIZE];\n  assign C_OUT = C[SIZE];\n\nendmodule",
        "module_name": "csa_generate_adder_32bit #",
        "module_hash": "4f402d185a4ab0445e47e2c56ab659c1",
        "dataset_index": 20993
      },
      "counter_264ac475": {
        "rtl_code": "module counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset) \n            count <= 4'b0000;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "264ac475af4007bab620c9c71e86f61b",
        "dataset_index": 9545
      },
      "four_input__50cc3200": {
        "rtl_code": "module four_input_module (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    output Y\n);\n\n    assign Y = (A1 & A2 & A3) | (!B1 & !(A1 & A2 & A3));\n\nendmodule",
        "module_name": "four_input_",
        "module_hash": "50cc3200650fd36750a4bf60a5b826ef",
        "dataset_index": 18629
      },
      "sky130_fd_sc_hd__o41a_6cd05321": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__o41a (\n    X ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A4, A3, A2, A1 );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__o41a",
        "module_hash": "6cd053213fc1ad1dcd89885ada6f7bc3",
        "dataset_index": 22294
      },
      "RCB_FRL_CRC_gen_a87ec0f5": {
        "rtl_code": "\n\nmodule RCB_FRL_CRC_gen ( D, NewCRC);\n\n\tinput [47:0] D;\n\toutput [7:0] NewCRC;\n\t\n\t\n\tassign NewCRC[0] = D[46] ^ D[42] ^ D[41] ^ D[37] ^ D[36] ^ D[35] ^ D[34] ^ \n                D[33] ^ D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[24] ^ \n                D[20] ^ D[18] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^ \n                D[8] ^ D[7] ^ D[6] ^ D[3] ^ D[1] ^ D[0];\n    assign NewCRC[1] = D[47] ^ D[43] ^ D[42] ^ D[38] ^ D[37] ^ D[36] ^ D[35] ^ \n                D[34] ^ D[32] ^ D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[25] ^ \n                D[21] ^ D[19] ^ D[18] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ \n                D[9] ^ D[8] ^ D[7] ^ D[4] ^ D[2] ^ D[1];\n    assign NewCRC[2] = D[46] ^ D[44] ^ D[43] ^ D[42] ^ D[41] ^ D[39] ^ D[38] ^ \n                D[34] ^ D[32] ^ D[30] ^ D[28] ^ D[27] ^ D[24] ^ D[22] ^ \n                D[19] ^ D[14] ^ D[13] ^ D[10] ^ D[9] ^ D[7] ^ D[6] ^ \n                D[5] ^ D[2] ^ D[1] ^ D[0];\n    assign NewCRC[3] = D[47] ^ D[45] ^ D[44] ^ D[43] ^ D[42] ^ D[40] ^ D[39] ^ \n                D[35] ^ D[33] ^ D[31] ^ D[29] ^ D[28] ^ D[25] ^ D[23] ^ \n                D[20] ^ D[15] ^ D[14] ^ D[11] ^ D[10] ^ D[8] ^ D[7] ^ \n                D[6] ^ D[3] ^ D[2] ^ D[1];\n    assign NewCRC[4] = D[45] ^ D[44] ^ D[43] ^ D[42] ^ D[40] ^ D[37] ^ D[35] ^ \n                D[33] ^ D[32] ^ D[31] ^ D[27] ^ D[21] ^ D[20] ^ D[18] ^ \n                D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[9] ^ D[6] ^ \n                D[4] ^ D[2] ^ D[1] ^ D[0];\n    assign NewCRC[5] = D[46] ^ D[45] ^ D[44] ^ D[43] ^ D[41] ^ D[38] ^ D[36] ^ \n                D[34] ^ D[33] ^ D[32] ^ D[28] ^ D[22] ^ D[21] ^ D[19] ^ \n                D[18] ^ D[15] ^ D[14] ^ D[13] ^ D[12] ^ D[10] ^ D[7] ^ \n                D[5] ^ D[3] ^ D[2] ^ D[1];\n    assign NewCRC[6] = D[47] ^ D[45] ^ D[44] ^ D[41] ^ D[39] ^ D[36] ^ D[31] ^ \n                D[30] ^ D[27] ^ D[26] ^ D[24] ^ D[23] ^ D[22] ^ D[19] ^ \n                D[18] ^ D[17] ^ D[11] ^ D[7] ^ D[4] ^ D[2] ^ D[1] ^ \n                D[0];\n    assign NewCRC[7] = D[45] ^ D[41] ^ D[40] ^ D[36] ^ D[35] ^ D[34] ^ D[33] ^ \n                D[32] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[23] ^ \n                D[19] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^ D[12] ^ \n                D[7] ^ D[6] ^ D[5] ^ D[2] ^ D[0];\n\t\t\t\t\t \nendmodule\n",
        "module_name": "RCB_FRL_CRC_gen",
        "module_hash": "a87ec0f589a633b1dbc25db5f6844106",
        "dataset_index": 25800
      },
      "comb_circuit_fa65310f": {
        "rtl_code": "\nmodule comb_circuit(\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nwire [49:0] and_out;\nwire [49:0] or_out;\nwire [98:0] xor_out;\n\n// AND gates\ngenvar i;\ngenerate\n    for (i = 0; i < 50; i = i + 1) begin : and_gates\n        assign and_out[i] = in[2*i] & in[2*i+1];\n    end\nendgenerate\n\n// OR gates\ngenerate\n    for (i = 0; i < 50; i = i + 1) begin : or_gates\n        assign or_out[i] = in[2*i] | in[2*i+1];\n    end\nendgenerate\n\n// XOR gates\ngenerate\n    for (i = 0; i < 99; i = i + 1) begin : xor_gates\n        assign xor_out[i] = in[i] ^ in[i+1];\n    end\nendgenerate\n\n// AND of all inputs\nand and_all (\n    .a(and_out),\n    .y(out_and)\n);\n\n// OR of all inputs\nor or_all (\n    .a(or_out),\n    .y(out_or)\n);\n\n// XOR of all inputs\nassign out_xor = xor_out[0] ^ xor_out[1] ^ xor_out[2] ^ xor_out[3] ^ xor_out[4] ^ xor_out[5] ^ xor_out[6] ^ xor_out[7] ^ xor_out[8] ^ xor_out[9] ^ xor_out[10] ^ xor_out[11] ^ xor_out[12] ^ xor_out[13] ^ xor_out[14] ^ xor_out[15] ^ xor_out[16] ^ xor_out[17] ^ xor_out[18] ^ xor_out[19] ^ xor_out[20] ^ xor_out[21] ^ xor_out[22] ^ xor_out[23] ^ xor_out[24] ^ xor_out[25] ^ xor_out[26] ^ xor_out[27] ^ xor_out[28] ^ xor_out[29] ^ xor_out[30] ^ xor_out[31] ^ xor_out[32] ^ xor_out[33] ^ xor_out[34] ^ xor_out[35] ^ xor_out[36] ^ xor_out[37] ^ xor_out[38] ^ xor_out[39] ^ xor_out[40] ^ xor_out[41] ^ xor_out[42] ^ xor_out[43] ^ xor_out[44] ^ xor_out[45] ^ xor_out[46] ^ xor_out[47] ^ xor_out[48] ^ xor_out[49] ^ xor_out[50] ^ xor_out[51] ^ xor_out[52] ^ xor_out[53] ^ xor_out[54] ^ xor_out[55] ^ xor_out[56] ^ xor_out[57] ^ xor_out[58] ^ xor_out[59] ^ xor_out[60] ^ xor_out[61] ^ xor_out[62] ^ xor_out[63] ^ xor_out[64] ^ xor_out[65] ^ xor_out[66] ^ xor_out[67] ^ xor_out[68] ^ xor_out[69] ^ xor_out[70] ^ xor_out[71] ^ xor_out[72] ^ xor_out[73] ^ xor_out[74] ^ xor_out[75] ^ xor_out[76] ^ xor_out[77] ^ xor_out[78] ^ xor_out[79] ^ xor_out[80] ^ xor_out[81] ^ xor_out[82] ^ xor_out[83] ^ xor_out[84] ^ xor_out[85] ^ xor_out[86] ^ xor_out[87] ^ xor_out[88] ^ xor_out[89] ^ xor_out[90] ^ xor_out[91] ^ xor_out[92] ^ xor_out[93] ^ xor_out[94] ^ xor_out[95] ^ xor_out[96] ^ xor_out[97] ^ xor_out[98];\n\nendmodule",
        "module_name": "comb_circuit",
        "module_hash": "fa65310f0792703647bfa27004a27a30",
        "dataset_index": 10307
      },
      "dff_async_reset_set_79a9bc0c": {
        "rtl_code": "\nmodule dff_async_reset_set (\n    input        clk,\n    input        reset_b,\n    input        set_b,\n    output reg   q\n);\n\n    // Register inputs\n    reg reset_b_reg;\n    reg set_b_reg;\n\n    // Synchronize inputs to the clock\n    always @(posedge clk)\n    begin\n        reset_b_reg <= reset_b;\n        set_b_reg   <= set_b;\n    end\n\n    // Implement the flip-flop logic\n    always @(posedge clk) // fix: control over clocked behavior\n    begin\n        if (reset_b_reg == 1)\n            q <= 0;\n        else if (set_b_reg == 1)\n            q <= 1;\n        else\n            q <= q ^ 1;\n    end\n\nendmodule",
        "module_name": "dff_async_reset_set",
        "module_hash": "79a9bc0cf182fd7647c37fcfe1891fe7",
        "dataset_index": 2105
      },
      "LCDDisplay_8160ad41": {
        "rtl_code": "module LCDDisplay(clk_i, func_i, data_i, en_o, func_o, data_o);\n  input       clk_i;\n  input [2:0] func_i;\n  input [127:0] data_i; reg   [7:0] data_c [0:31];\n\n  output reg en_o;\n  output [1:0] func_o;\n  output [7:0] data_o;\n\n  reg [1:0] func_o_0;\n  reg [1:0] func_o_1;\n  assign func_o = func_o_0 | func_o_1;\n\n  reg [7:0] data_o_0;\n  reg [7:0] data_o_1;\n  assign data_o = data_o_0 | data_o_1;\n\n  `define IDLE 1'b0\n  `define BUSY 1'b1\n  `define SPACE 8'b00100000\n\n  integer   i;\n  reg       state;\n  reg [1:0] lcd_clr_state;\n  integer   lcd_clr_cyc;\n  reg [2:0] lcd_wrt_state;\n  integer   lcd_wrt_cyc;\n  reg [6:0] ddram_addr;\n  integer   cursor_pos;\n\n  initial begin\n    state = `BUSY;\n    for (i = 0; i < 31; i = i + 1) begin\n      data_c[i] = `SPACE;\n    end\n    en_o = 0;\n    func_o_0 = 2'b00;\n    func_o_1 = 2'b00;\n    data_o_0 = 8'b0;\n    data_o_1 = 8'b0;\n    lcd_clr_state = 2'b00;\n    lcd_wrt_state = 3'b000;\n    state = `IDLE;\n  end\n\n  `define NOP 3'b000\n  `define K0  3'b100\n  `define K1  3'b101\n  `define K2  3'b110\n  `define K3  3'b111\n\n  `define EN_PULSE_WIDTH 20\n  \n  always@(negedge clk_i) begin\n    if (state == `IDLE) begin\n      case (func_i)\n        `K0: begin\n          for (i = 0; i < 31; i = i + 1) begin\n            data_c[i] <= `SPACE;\n          end\n          lcd_clr_state <= 2'b01;\n          state <= `BUSY;\n        end\n        `K2: begin\n          for (i = 0; i < 16; i = i + 1) begin\n            data_c[i + 16] <= data_c[i];\n          end\n          data_c[0] <= data_i[7:0];\n          data_c[1] <= data_i[15:8];\n          data_c[2] <= data_i[23:16];\n          data_c[3] <= data_i[31:24];\n          data_c[4] <= data_i[39:32];\n          data_c[5] <= data_i[47:40];\n          data_c[6] <= data_i[55:48];\n          data_c[7] <= data_i[63:56];\n          data_c[8] <= data_i[71:64];\n          data_c[9] <= data_i[79:72];\n          data_c[10] <= data_i[87:80];\n          data_c[11] <= data_i[95:88];\n          data_c[12] <= data_i[103:96];\n          data_c[13] <= data_i[111:104];\n          data_c[14] <= data_i[119:112];\n          data_c[15] <= data_i[127:120];\n          cursor_pos <= 0;\n          ddram_addr <= 7'b0000000;\n          lcd_wrt_state <= 3'b001;\n          state <= `BUSY;\n        end\n      endcase\n    end else begin\n      case (lcd_clr_state)\n        2'b00: begin\n          end\n        2'b01: begin\n          en_o <= 1;\n          func_o_0 <= 2'b00;\n          data_o_0 <= 8'b00000001;\n          lcd_clr_state <= 2'b10;\n          lcd_clr_cyc <= 0;\n        end\n        2'b10: begin\n          if (lcd_clr_cyc != 8000) begin\n            if (lcd_clr_cyc == `EN_PULSE_WIDTH) begin\n              en_o <= 0;\n            end\n            lcd_clr_cyc <= lcd_clr_cyc + 1;\n          end else begin\n\t\t\tdata_o_0 <= 8'b0;\n\t\t\tfunc_o_0 <= 2'b00;\n            lcd_clr_state <= 2'b00;\n            state <= `IDLE;\n          end\n        end\n      endcase\n\n      case (lcd_wrt_state)\n        3'b000: begin\n          end\n        3'b001: begin\n          if (ddram_addr == 7'h50) begin\n\t\t\tdata_o_1 <= 8'b0;\n\t\t\tfunc_o_1 <= 2'b00;\n            lcd_wrt_state <= 3'b000;\n            state <= `IDLE;\n          end else begin\n\t\t\ten_o <= 1;\n            func_o_1 <= 2'b00;\n            data_o_1 <= {1'b1, ddram_addr};\n            if (ddram_addr == 7'h0F) begin\n              ddram_addr <= 7'h40;\n            end else begin\n              ddram_addr <= ddram_addr + 7'b1;\n            end\n            lcd_wrt_state <= 3'b010;\n            lcd_wrt_cyc <= 0;\n          end\n        end\n        3'b010: begin\n          if (lcd_wrt_cyc != 250) begin\n            if (lcd_wrt_cyc == `EN_PULSE_WIDTH) begin\n              en_o <= 0;\n            end\n            lcd_wrt_cyc <= lcd_wrt_cyc + 1;\n          end else begin\n            lcd_wrt_state <= 3'b011;\n          end\n        end\n        3'b011: begin\n\t\t  en_o <= 1;\n          func_o_1 <= 2'b10;\n          data_o_1 <= data_c[cursor_pos];\n          cursor_pos <= cursor_pos + 1;\n          lcd_wrt_state <= 3'b100;\n          lcd_wrt_cyc <= 0;\n        end\n        3'b100: begin\n          if (lcd_wrt_cyc != 250) begin\n            if (lcd_wrt_cyc == `EN_PULSE_WIDTH) begin\n              en_o <= 0;\n            end\n            lcd_wrt_cyc <= lcd_wrt_cyc + 1;\n          end else begin\n            lcd_wrt_state <= 3'b001;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "LCDDisplay",
        "module_hash": "8160ad410dc9ec7c2206c1c022c91afa",
        "dataset_index": 22275
      },
      "MUXF7_f03f740f": {
        "rtl_code": "\nmodule MUXF7 (O, I0, I1, S);\n\n\n`ifdef XIL_TIMING\n\n    parameter LOC = \"UNPLACED\";\n\n`endif\n\n    \n    output O;\n    input I0, I1, S;\n\n    reg O_out;\n\n    always @(I0 or I1 or S) \n\tif (S)\n\t    O_out = I1;\n\telse\n\t    O_out = I0;\n\n    assign O = O_out;\n    \n`ifdef XIL_TIMING\n\n    specify\n                                                                                 \n        (I0 => O) = (0:0:0, 0:0:0);\n        (I1 => O) = (0:0:0, 0:0:0);\n\t(S => O) = (0:0:0, 0:0:0);\n        specparam PATHPULSE$ = 0;\n                                                                                 \n    endspecify\n\n`endif\n    \nendmodule\n",
        "module_name": "MUXF7",
        "module_hash": "f03f740ffb910d7e129e77b5be0cbf22",
        "dataset_index": 22245
      },
      "updown_counter_6f487c2e": {
        "rtl_code": "module updown_counter (\n    input clk,\n    input U_D,\n    output reg [3:0] Q\n);\n\nreg [3:0] Q_reg1;\nreg [3:0] Q_reg2;\n\nalways @(posedge clk) begin\n    Q_reg1 <= Q;\nend\n\nalways @(posedge clk) begin\n    Q_reg2 <= Q_reg1;\nend\n\nalways @(posedge clk) begin\n    if (U_D) begin\n        Q <= Q_reg2 + 1;\n    end else begin\n        Q <= Q_reg2 - 1;\n    end\nend\n\nendmodule",
        "module_name": "updown_counter",
        "module_hash": "6f487c2e62fee00f8c52a3a0491d23c9",
        "dataset_index": 20366
      },
      "add_sub_ab18587e": {
        "rtl_code": "module add_sub (\n    input [3:0] A,\n    input [3:0] B,\n    input SUBTRACT,\n    output reg [3:0] SUM,\n    output reg OVERFLOW\n);\n\nalways @(*) begin\n    if (SUBTRACT == 1) begin\n        SUM <= A - B;\n        if (A < B) begin\n            OVERFLOW <= 1;\n        end else begin\n            OVERFLOW <= 0;\n        end\n    end else begin\n        SUM <= A + B;\n        if (SUM > 15) begin\n            OVERFLOW <= 1;\n        end else begin\n            OVERFLOW <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "ab18587e5c42b890a02139a6aa215544",
        "dataset_index": 15956
      },
      "sky130_fd_sc_ls__fahcon_38d893bc": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__fahcon (\n    COUT_N,\n    SUM   ,\n    A     ,\n    B     ,\n    CI\n);\n\n    output COUT_N;\n    output SUM   ;\n    input  A     ;\n    input  B     ;\n    input  CI    ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xor0_out_SUM ;\n    wire a_b          ;\n    wire a_ci         ;\n    wire b_ci         ;\n    wire or0_out_coutn;\n\n    xor xor0 (xor0_out_SUM , A, B, CI       );\n    buf buf0 (SUM          , xor0_out_SUM   );\n    nor nor0 (a_b          , A, B           );\n    nor nor1 (a_ci         , A, CI          );\n    nor nor2 (b_ci         , B, CI          );\n    or  or0  (or0_out_coutn, a_b, a_ci, b_ci);\n    buf buf1 (COUT_N       , or0_out_coutn  );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__fahcon",
        "module_hash": "38d893bc731dc1ed24889a1d6fa387ee",
        "dataset_index": 6556
      },
      "logic_gate_e9f167fc": {
        "rtl_code": "module logic_gate (\n    X,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input B1;\n    input B2;\n    input C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    wire AB_high = (A1 & A2) & (!B1 & !B2);\n\n    assign X = (AB_high | C1) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "logic_gate",
        "module_hash": "e9f167fc77f502ef7be6fc0df5b52f6e",
        "dataset_index": 15429
      },
      "mux_2to1_ea2870db": {
        "rtl_code": "module mux_2to1 (\n    input in0,\n    input in1,\n    input sel,\n    output out\n);\n\n    assign out = (sel == 1'b0) ? in0 : in1;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "ea2870dba55bc40cdce7b4b672cad336",
        "dataset_index": 10805
      },
      "binary_counter_b82d8c80": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0;\n    end\n    else begin\n        if (count == 4'b1001) begin\n            count <= 4'b0;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "b82d8c808b6dd0ae20493c940ad9d307",
        "dataset_index": 16287
      },
      "top__94d39686": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,          // Synchronous active-high reset\n    output reg led);      // Output for the LED controlled by the counter outputs\n\n    reg [3:0] sync_counter;\n    reg [3:0] async_counter;\n    reg [2:0] pattern_counter;\n    reg [2:0] pattern;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            sync_counter <= 0;\n            async_counter <= 0;\n            pattern_counter <= 0;\n            pattern <= 3'b001;\n            led <= 0;\n        end else begin\n            sync_counter <= sync_counter + 1;\n            async_counter <= async_counter + 1;\n            pattern_counter <= pattern_counter + 1;\n\n            if (sync_counter == 10) begin\n                sync_counter <= 0;\n            end\n\n            if (async_counter == 16) begin\n                async_counter <= 0;\n            end\n\n            if (pattern_counter == 10) begin\n                pattern_counter <= 0;\n                pattern <= pattern + 1;\n                if (pattern == 3'b100) begin\n                    pattern <= 3'b001;\n                end\n            end\n\n            case (pattern)\n                3'b001: led <= (sync_counter < 3) ? 1 : 0;\n                3'b010: led <= (sync_counter < 2) ? 1 : 0;\n                3'b011: led <= (sync_counter < 2) ? 1 : 0;\n                3'b100: led <= 0;\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "94d396865f907cb6fec4a226dd24acc0",
        "dataset_index": 7631
      },
      "MEM_WB_9cd8efb2": {
        "rtl_code": "\n\nmodule MEM_WB(\n\tinput clk,\n\tinput  [1:0]  control_wb_in,\n\tinput  [31:0] Read_data_in,\n\tinput  [31:0] ALU_result_in,\n\tinput  [4:0]  Write_reg_in,\n\toutput reg [1:0]  mem_control_wb,\n\toutput reg [31:0] Read_data,\n\toutput reg [31:0] mem_ALU_result,\n\toutput reg [4:0]  mem_Write_reg);\n\n\tinitial\n\t\tbegin\n\t\t\tmem_control_wb <= 0;\n\t\t\tRead_data      <= 0;\n\t\t\tmem_ALU_result <= 0;\n\t\t\tmem_Write_reg  <= 0;\n\t\tend\n\t\t\n\talways @ (posedge clk)\n\t\tbegin\n\t\t\tmem_control_wb <= control_wb_in;\n\t\t\tRead_data      <= Read_data_in;\n\t\t\tmem_ALU_result <= ALU_result_in;\n\t\t\tmem_Write_reg  <= Write_reg_in;\n\t\tend\nendmodule\n",
        "module_name": "MEM_WB",
        "module_hash": "9cd8efb241fb5058b988f265ca9df703",
        "dataset_index": 7700
      },
      "Modulo_47d42f53": {
        "rtl_code": "\nmodule Modulo (\n  input [31:0] A,\n  input [31:0] B,\n  output reg [31:0] C\n);\n\n  wire signed [31:0] C_temp;\n  assign C_temp = A % B;\n  always @(*) begin\n    if (B == 0) begin\n      C <= 0;\n    end else if (C_temp < 0) begin\n      C <= C_temp + B;\n    end else begin\n      C <= C_temp;\n    end\n  end\n\nendmodule",
        "module_name": "Modulo",
        "module_hash": "47d42f53954c93d403a579da775fa810",
        "dataset_index": 10075
      },
      "arbitrator_f05cae72": {
        "rtl_code": "module arbitrator(\t\n\treset,\n\tclk,\t\n\trequest0,\n\trelease0,\t\n\trequest1,\t\n\trelease1,\n\trequest2,\t\n\trelease2,\n\trequest3,\t\n\trelease3,\t\n\trequest4,\t\n\trelease4,\n\trequest5,\t\n\trelease5,\n\tpermit0,\n\tpermit1,\n\tpermit2,\n\tpermit3,\n\tpermit4,\n\tpermit5\n\t);\n\n\tinput reset;\n\tinput clk;\t\n\tinput request0;\t\n\tinput release0;\t\n\tinput request1;\t\n\tinput release1;\t\n\tinput request2;\t\n\tinput release2;\n\tinput request3;\t\n\tinput release3;\n\tinput request4;\t\n\tinput release4;\n\tinput request5;\t\n\tinput release5;\n\t\n\toutput permit0;\n\toutput permit1;\n\toutput permit2;\n\toutput permit3;\n\toutput permit4;\n\toutput permit5;\n\treg permit0;\n\treg permit1;\n\treg permit2;\n\treg permit3;\t\n\treg permit4;\n\treg permit5;\n\t\n\tparameter REQUEST0\t=4'b0000;\n\tparameter REQUEST1\t=4'b0001;\n\tparameter REQUEST2\t=4'b0010;\n\tparameter REQUEST3\t=4'b0011;\n\tparameter REQUEST4\t=4'b0100;\n\tparameter REQUEST5\t=4'b0101;\t\n\tparameter WAIT_RELEASE\t=4'b0110;\n\tparameter WAIT_CYCLES \t=4'b0111;\n\tparameter FINISH      \t=4'b1111;\n\t\n\treg [3:0] state;\n\treg [2:0] count;\n\treg [3:0] index;\n\t\n\talways@ (posedge clk or negedge reset)\n\tbegin\n\t\tif(!reset)\n\t\tbegin\n\t\t\tstate <= REQUEST0;\n\t\t\tpermit0 <= 0;\n\t\t\tpermit1 <= 0;\n\t\t\tpermit2 <= 0;\n\t\t\tpermit3 <= 0;\n\t\t\tpermit4 <= 0;\n\t\t\tpermit5 <= 0;\n\t\t\tindex   <= 0;\n\t\t\tcount\t<=0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tcase (state) \n\t\t\t\tREQUEST0:\n\t\t\t\tbegin\n\t\t\t\t\tif(request0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpermit0 <= 1;\n\t\t\t\t\t\tstate <= WAIT_RELEASE;\n\t\t\t\t\t\tindex <= REQUEST1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= REQUEST1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tREQUEST1:\n\t\t\t\tbegin\n\t\t\t\t\tif(request1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpermit1 <= 1;\n\t\t\t\t\t\tstate <= WAIT_RELEASE;\n\t\t\t\t\t\tindex <= REQUEST2;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= REQUEST2;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tREQUEST2:\n\t\t\t\tbegin\n\t\t\t\t\tif(request2)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpermit2 <= 1;\n\t\t\t\t\t\tstate <= WAIT_RELEASE;\n\t\t\t\t\t\tindex <= REQUEST3;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= REQUEST3;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tREQUEST3:\n\t\t\t\tbegin\n\t\t\t\t\tif(request3)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpermit3 <= 1;\n\t\t\t\t\t\tstate <= WAIT_RELEASE;\n\t\t\t\t\t\tindex <= REQUEST4;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= REQUEST4;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tREQUEST4:\n\t\t\t\tbegin\n\t\t\t\t\tif(request4)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpermit4 <= 1;\n\t\t\t\t\t\tstate <= WAIT_RELEASE;\n\t\t\t\t\t\tindex <= REQUEST5;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= REQUEST5;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tREQUEST5:\n\t\t\t\tbegin\n\t\t\t\t\tif(request5)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpermit5 <= 1;\n\t\t\t\t\t\tstate <= WAIT_RELEASE;\n\t\t\t\t\t\tindex <= REQUEST0;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= REQUEST0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tWAIT_RELEASE:\n\t\t\t\tbegin\n\t\t\t\t\tif(release0 | release1 | release2 | release3 | release4 | release5)\n\t\t\t\t\tbegin\t\t\t\t\t\t\n\t\t\t\t\t\tpermit0 <= 0;\n\t\t\t\t\t\tpermit1 <= 0;\n\t\t\t\t\t\tpermit2 <= 0;\n\t\t\t\t\t\tpermit3 <= 0;\n\t\t\t\t\t\tpermit4 <= 0;\n\t\t\t\t\t\tpermit5 <= 0;\n\t\t\t\t\t\tcount <= 0;\t\t\t\t\t\t\n\t\t\t\t\t\tstate <= WAIT_CYCLES;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tstate <= WAIT_RELEASE;\n\t\t\t\tend\n\t\t\t\tWAIT_CYCLES:\n\t\t\t\tbegin\n\t\t\t\t\tif(count==4)\n\t\t\t\t\t\tstate <= FINISH;\n\t\t\t\t\telse\n\t\t\t\t\t\tcount <= count+1;\n\t\t\t\tend\n\t\t\t\tFINISH:\n\t\t\t\tbegin\n\t\t\t\t\tstate <= index;\n\t\t\t\tend\n\t\t\t\tdefault:state <= REQUEST0;\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n",
        "module_name": "arbitrator",
        "module_hash": "f05cae727a2027efeaed84c1c884a0a0",
        "dataset_index": 16205
      },
      "c_clkgate_32ffecfa": {
        "rtl_code": "\n\n\n\nmodule c_clkgate\n  (clk, enable, clk_gated);\n   \n   input clk;\n   \n   input enable;\n   \n   output clk_gated;\n   wire clk_gated;\n   \n   reg \tenable_q;\n   always @(clk, enable)\n     begin\n\tif(clk == 0)\n          enable_q <= enable;\n     end\n   \n   assign clk_gated = clk & enable_q;\n   \nendmodule\n",
        "module_name": "c_clkgate",
        "module_hash": "32ffecfa60514d91ab82fe0d031fb10c",
        "dataset_index": 24821
      },
      "comb_circuit_e0606489": {
        "rtl_code": "module comb_circuit (\n  input a, b,\n  output out1, out2\n);\n\n  assign out1 = a ? ~b : b;\n  assign out2 = a ? b : ~b;\n\nendmodule",
        "module_name": "comb_circuit",
        "module_hash": "e0606489925bf42524522e912bb6b43f",
        "dataset_index": 7023
      },
      "MUXF7_6b9900a2": {
        "rtl_code": "module MUXF7 (O, I0, I1, I2, I3, I4, I5, I6, S);\n\n    output O;\n    input I0, I1, I2, I3, I4, I5, I6, S;\n\n    reg O_out;\n\n    always @(I0 or I1 or I2 or I3 or I4 or I5 or I6 or S) \n    begin\n        case(S)\n            3'b000: O_out = I0;\n            3'b001: O_out = I1;\n            3'b010: O_out = I2;\n            3'b011: O_out = I3;\n            3'b100: O_out = I4;\n            3'b101: O_out = I5;\n            3'b110: O_out = I6;\n            default: O_out = 1'b0; // This is the default value in case S is not a valid input\n        endcase\n    end\n\n    assign O = O_out;\n\nendmodule",
        "module_name": "MUXF7",
        "module_hash": "6b9900a2f91459a71baa59e1d3e874f7",
        "dataset_index": 8656
      },
      "top__85cdce90": {
        "rtl_code": "module top_module (\n    input clk,\n    input RST,\n    input [3:0] a,\n    input [3:0] b,\n    input sub,\n    input cin,\n    input select,\n    output reg cout,\n    output reg overflow,\n    output reg [7:0] q\n);\n\nreg [3:0] counter;\nreg [3:0] adder_out;\nreg [3:0] selected_out;\n\nwire [3:0] adder_in;\nassign adder_in = sub ? (a - b - cin) : (a + b + cin);\n\nalways @(posedge clk or negedge RST) begin\n    if (!RST) begin\n        counter <= 4'b0;\n        adder_out <= 4'b0;\n        selected_out <= 4'b0;\n        cout <= 1'b0;\n        overflow <= 1'b0;\n        q <= 8'b0;\n    end else begin\n        counter <= counter + 1;\n        adder_out <= adder_in;\n        selected_out <= select ? adder_out : counter;\n        {cout, q} <= selected_out + counter;\n        overflow <= (selected_out[3] == counter[3]) && (selected_out[3] != q[3]);\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "85cdce90535be8730296184ea4b5cc4f",
        "dataset_index": 7834
      },
      "left_rotation_dcd83b18": {
        "rtl_code": "module left_rotation(\n    output reg [31:0] o,\n    input [31:0] i,\n    input [4:0] n\n);\n\nalways @(*) begin\n    o = {i[(n+31):0], i[31:(n+1)]};\nend\n\nendmodule",
        "module_name": "left_rotation",
        "module_hash": "dcd83b18dd054244c78e9eceade334d6",
        "dataset_index": 16746
      },
      "two_to_one_mux_a57271ba": {
        "rtl_code": "module two_to_one_mux (\n    A,\n    B,\n    S,\n    Y\n);\n\n    input A;\n    input B;\n    input S;\n    output Y;\n\n    assign Y = (S == 0) ? A : B;\n\nendmodule",
        "module_name": "two_to_one_mux",
        "module_hash": "a57271ba10775a2bdc2a2f61acb5293b",
        "dataset_index": 8978
      },
      "full_adder_dacd0ffa": {
        "rtl_code": "\nmodule full_adder (\n  input A,\n  input B,\n  input CIN,\n  output SUM,\n  output COUT\n);\n\n  assign SUM = A ^ B ^ CIN;\n  assign COUT = (A & (B | CIN)) | (B & CIN);\n\nendmodule\nmodule four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  output [4:0] SUM\n);\n\n  wire CARRY0;\n  wire CARRY1;\n  wire CARRY2;\n\n  full_adder op1 (A[0], B[0], 0, SUM[0], CARRY0);\n  full_adder op2 (A[1], B[1], CARRY0, SUM[1], CARRY1);\n  full_adder op3 (A[2], B[2], CARRY1, SUM[2], CARRY2);\n  full_adder op4 (A[3], B[3], CARRY2, SUM[3], SUM[4]);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "dacd0ffa6751c36b7b8de8a6b8e147ec",
        "dataset_index": 17255
      },
      "xor_and_14ce1d18": {
        "rtl_code": "module xor_and (\n    input wire [3:0] vec1,\n    input wire [3:0] vec2,\n    output wire [3:0] out_xor,\n    output wire o4,\n    output wire o3,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\n    assign out_xor = vec1 ^ vec2;\n    assign o4 = vec1 & vec2;\n    \n    assign o3 = out_xor[3];\n    assign o2 = out_xor[2];\n    assign o1 = out_xor[1];\n    assign o0 = out_xor[0];\n\nendmodule",
        "module_name": "xor_and",
        "module_hash": "14ce1d18e22d182b99feb99ff9d8251a",
        "dataset_index": 11186
      },
      "sky130_fd_sc_lp__or4bb_39820c2d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__or4bb (\n    X  ,\n    A  ,\n    B  ,\n    C_N,\n    D_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n    input  D_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out;\n    wire or0_out_X;\n\n    nand nand0 (nand0_out, D_N, C_N       );\n    or   or0   (or0_out_X, B, A, nand0_out);\n    buf  buf0  (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__or4bb",
        "module_hash": "39820c2d3230ea60acf43af79ed6d443",
        "dataset_index": 21994
      },
      "Delay_ce093088": {
        "rtl_code": "\nmodule Delay(\n    CLK,\n    RST,\n    DELAY_MS,\n    DELAY_EN,\n    DELAY_FIN\n    );\n\n\tinput CLK;\n    input RST;\n    input [11:0] DELAY_MS;\n    input DELAY_EN;\n    output DELAY_FIN;\n\n\twire DELAY_FIN;\n\n\treg [31:0] current_state = \"Idle\";\t\t\t\t\t\treg [16:0] clk_counter = 17'b00000000000000000;\t\treg [11:0] ms_counter = 12'h000;\t\t\t\t\t\t\tassign DELAY_FIN = (current_state == \"Done\" && DELAY_EN == 1'b1) ? 1'b1 : 1'b0;\n\t\n\talways @(posedge CLK) begin\n\t\t\tif(RST == 1'b1) begin\n\t\t\t\t\tcurrent_state <= \"Idle\";\n\t\t\tend\n\t\t\telse begin\n\t\t\t\t\tcase(current_state)\n\n\t\t\t\t\t\t\t\"Idle\" : begin\n\t\t\t\t\t\t\t\t\tif(DELAY_EN == 1'b1) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= \"Hold\";\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\"Hold\" : begin\n\t\t\t\t\t\t\t\t\tif(ms_counter == DELAY_MS) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= \"Done\";\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\"Done\" : begin\n\t\t\t\t\t\t\t\t\tif(DELAY_EN == 1'b0) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= \"Idle\";\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdefault : current_state <= \"Idle\";\n\t\t\t\t\t\t\t\n\t\t\t\t\tendcase\n\t\t\tend\n\tend\n\talways @(posedge CLK) begin\n\t\t\tif(current_state == \"Hold\") begin\n\t\t\t\t\tif(clk_counter == 17'b11000011010100000) begin\t\tclk_counter <= 17'b00000000000000000;\n\t\t\t\t\t\t\tms_counter <= ms_counter + 1'b1;\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t\tclk_counter <= clk_counter + 1'b1;\n\t\t\t\t\tend\n\t\t\tend\n\t\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclk_counter <= 17'b00000000000000000;\n\t\t\t\t\tms_counter <= 12'h000;\n\t\t\tend\n\tend\n\nendmodule\n",
        "module_name": "Delay",
        "module_hash": "ce09308860efc91cf3e8e76dcaaae8f5",
        "dataset_index": 25243
      },
      "GDA_St_N8_M8_P1_a2e88e74": {
        "rtl_code": "\nmodule GDA_St_N8_M8_P1(\n    input  [7:0] in1,\n    input  [7:0] in2,\n    output [8:0] res\n    );\n\nwire [2:0] temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;\nwire p0, p1, p2, p3, p4, p5, p6, p7;\nwire g0, g1, g2, g3, g4, g5, g6, g7, c1, c2, c3, c4, c5, c6, c7, c8;\n\nand and_0(g0, in1[0], in2[0]);\nand and_1(g1, in1[1], in2[1]);\nand and_2(g2, in1[2], in2[2]);\nand and_3(g3, in1[3], in2[3]);\nand and_4(g4, in1[4], in2[4]);\nand and_5(g5, in1[5], in2[5]);\nand and_6(g6, in1[6], in2[6]);\nand and_7(g7, in1[7], in2[7]);\n\nxor xor_0(p0, in1[0], in2[0]);\nxor xor_1(p1, in1[1], in2[1]);\nxor xor_2(p2, in1[2], in2[2]);\nxor xor_3(p3, in1[3], in2[3]);\nxor xor_4(p4, in1[4], in2[4]);\nxor xor_5(p5, in1[5], in2[5]);\nxor xor_6(p6, in1[6], in2[6]);\nxor xor_7(p7, in1[7], in2[7]);\n\nassign c1 = g0;\nassign c2 = g1;\nassign c3 = g2;\nassign c4 = g3;\nassign c5 = g4;\nassign c6 = g5;\nassign c7 = g6;\nassign c8 = g7;\n\nassign temp1[1:0] = in1[0] + in2[0];\nassign temp2[1:0] = in1[1] + in2[1] + c1;\nassign temp3[1:0] = in1[2] + in2[2] + c2;\nassign temp4[1:0] = in1[3] + in2[3] + c3;\nassign temp5[1:0] = in1[4] + in2[4] + c4;\nassign temp6[1:0] = in1[5] + in2[5] + c5;\nassign temp7[1:0] = in1[6] + in2[6] + c6;\nassign temp8[1:0] = in1[7] + in2[7] + c7 + c8;\nassign res[8:0] = {temp8[1:0], temp7[0], temp6[0], temp5[0], temp4[0], temp3[0], temp2[0], temp1[0]};\n\nendmodule",
        "module_name": "GDA_St_N8_M8_P1",
        "module_hash": "a2e88e741de96945276541990a743f8f",
        "dataset_index": 20516
      },
      "MUX8_1_Icontrol_1e22478a": {
        "rtl_code": "module MUX8_1_Icontrol(Sel,S0,S1,S2,S3,S4,S5,S6,S7,out);\n\ninput [2:0] Sel;\ninput S0,S1,S2,S3,S4,S5,S6,S7;\noutput out;\n\nassign out = (Sel[2])? (Sel[1]?(Sel[0]?S7:S6) : (Sel[0]?S5:S4))  :  (Sel[1]?(Sel[0]?S3:S2) : (Sel[0]?S1:S0));\n\nendmodule\n\nmodule MUX8_1_SL(Sel,Write_Byte_En,S0,S1,S2,S3,S4,S5,S6,S7,out);\n\ninput [3:0] Sel;\ninput [3:0] Write_Byte_En;\ninput [3:0] S0,S1,S2,S3,S4,S5,S6,S7;\noutput [3:0] out;\n\nassign out = (Sel[3])?Write_Byte_En:((Sel[2])? (Sel[1]?(Sel[0]?S7:S6) : (Sel[0]?S5:S4))  :  (Sel[1]?(Sel[0]?S3:S2) : (Sel[0]?S1:S0)));\nendmodule\n\nmodule MUX4_1_SL(Sel,S0,S1,S2,S3,out);\n\ninput [1:0] Sel;\ninput [3:0] S0,S1,S2,S3;\noutput [3:0]out;\n\nassign out = (Sel[1]?(Sel[0]?S3:S2) : (Sel[0]?S1:S0));\n\nendmodule\n\n\nmodule Condition_Check(\ninput [2:0] Condition,PC_Write,\ninput [1:0] addr, \ninput MemWBSrc,\ninput OverflowEn,Branch,Overflow,\ninput [3:0] Mem_Byte_Write,\ninput [3:0] Rd_Write_Byte_en,\ninput Less,Zero,\n\noutput BranchValid,\noutput [3:0] RdWriteEn,\noutput [3:0] MemWriteEn\n);\n\nwire[1:0] Right;\nwire Load,Store;\nwire [3:0] LoadOut,StoreOut;\nassign Right = (PC_Write == 3'b110 ?2'b01:(PC_Write == 3'b010)?2'b00:2'b10);\nassign Load = (MemWBSrc == 1'b1)?1'b1:1'b0;\nassign Store = (Mem_Byte_Write == 4'b1111);\n\n\nMUX8_1_SL sl1({Right,addr[1:0]},Rd_Write_Byte_en,4'b1111,4'b1110,4'b1100,4'b1000,4'b0001,4'b0011,4'b0111,4'b1111,LoadOut);\nMUX8_1_SL sl2({Right,addr[1:0]},Mem_Byte_Write,4'b1111,4'b0111,4'b0011,4'b0001,4'b1000,4'b1100,4'b1110,4'b1111,StoreOut);\n\n\nwire condition_out;\nMUX8_1_Icontrol MUX_Con(Condition,1'b0,Zero,!Zero,!Less,!(Less^Zero),Less^Zero,Less,1'b1,condition_out);\nassign BranchValid = condition_out & Branch;\nassign RdWriteEn = (Load === 1'b1)?LoadOut:((OverflowEn == 0)?(Rd_Write_Byte_en):((Overflow == 1'b0)?(4'b1111):(4'b0000)));\n\nassign MemWriteEn = (Store === 1'b1) ? StoreOut:4'b0000;\n\nendmodule\n",
        "module_name": "MUX8_1_Icontrol",
        "module_hash": "1e22478a5506a12ba3d34c7da6aaa57c",
        "dataset_index": 16526
      },
      "mux_4to1_ad6090e9": {
        "rtl_code": "\nmodule mux_4to1 (\n    input A, B, C, D, S0, S1,\n    output Y\n);\n\n    wire not_S0, not_S1, not_S0_and_not_S1, not_S0_and_S1, S0_and_not_S1, S0_and_S1;\n    wire A_buf, B_buf, C_buf, D_buf;\n\n    buf_6 buf_A (.A(A), .X(A_buf), .VPWR(1'b1), .VGND(1'b0), .VPB(1'b0), .VNB(1'b0));\n    buf_6 buf_B (.A(B), .X(B_buf), .VPWR(1'b1), .VGND(1'b0), .VPB(1'b0), .VNB(1'b0));\n    buf_6 buf_C (.A(C), .X(C_buf), .VPWR(1'b1), .VGND(1'b0), .VPB(1'b0), .VNB(1'b0));\n    buf_6 buf_D (.A(D), .X(D_buf), .VPWR(1'b1), .VGND(1'b0), .VPB(1'b0), .VNB(1'b0));\n\n    assign not_S0 = ~S0;\n    assign not_S1 = ~S1;\n    assign not_S0_and_not_S1 = not_S0 & not_S1;\n    assign not_S0_and_S1 = not_S0 & S1;\n    assign S0_and_not_S1 = S0 & not_S1;\n    assign S0_and_S1 = S0 & S1;\n\n    assign Y = not_S0_and_not_S1 & A_buf |\n               not_S0_and_S1 & B_buf |\n               S0_and_not_S1 & C_buf |\n               S0_and_S1 & D_buf;\n\nendmodule\nmodule buf_6 (\n    input A,\n    output X,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    assign X = A;\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "ad6090e9f1ab6e30972623e51f074632",
        "dataset_index": 13605
      },
      "radio_controller_TxTiming_4b679b3e": {
        "rtl_code": "module radio_controller_TxTiming\n(\n    input clk,\n    input reset,\n    input Tx_swEnable,\n    input [5:0] TxGain_target,\n    input [3:0] TxGain_rampGainStep,\n    input [3:0] TxGain_rampTimeStep,\n    input [7:0] dly_hwTxEn,\n    input [7:0] dly_TxStart,\n    input [7:0] dly_PowerAmpEn,\n    input [7:0] dly_RampGain,\n    output hw_TxEn,\n    output hw_TxStart,\n    output hw_PAEn,\n    output [5:0] hw_TxGain\n);\n\n    reg [7:0] timing_counter;\n    reg [7:0] hwTxEn_counter;\n    reg [7:0] hwPAEn_counter;\n    reg [7:0] hwTxStart_counter;\n    reg [7:0] ramp_counter;\n    reg [6:0] TxGainBig;\n    wire [6:0] NewTxGain;\n    wire AutoGainRampEn;\n\n    assign NewTxGain = (TxGainBig + TxGain_rampGainStep > TxGain_target) ? TxGain_target : TxGainBig + TxGain_rampGainStep;\n    assign hw_TxGain = TxGainBig[5:0];\n\n    assign hw_TxEn = (hwTxEn_counter > dly_hwTxEn) || (dly_hwTxEn == 8'hFE);\n    assign hw_PAEn = (hwPAEn_counter > dly_PowerAmpEn) || (dly_PowerAmpEn == 8'hFE);\n    assign hw_TxStart = (hwTxStart_counter > dly_TxStart) || (dly_TxStart == 8'hFE);\n\n    assign AutoGainRampEn = ramp_counter > dly_RampGain;\n\n    always @(posedge clk) begin\n        if (reset || !Tx_swEnable) begin\n            TxGainBig <= 0;\n            hwTxEn_counter <= 0;\n            hwPAEn_counter <= 0;\n            hwTxStart_counter <= 0;\n            ramp_counter <= 0;\n        end else begin\n            if (hwTxEn_counter == 8'hFF) begin\n                hwTxEn_counter <= 0;\n            end else begin\n                hwTxEn_counter <= hwTxEn_counter + 1;\n            end\n            if (hwPAEn_counter == 8'hFF) begin\n                hwPAEn_counter <= 0;\n            end else begin\n                hwPAEn_counter <= hwPAEn_counter + 1;\n            end\n            if (hwTxStart_counter == 8'hFF) begin\n                hwTxStart_counter <= 0;\n            end else begin\n                hwTxStart_counter <= hwTxStart_counter + 1;\n            end\n            if (AutoGainRampEn) begin\n                if (ramp_counter == TxGain_rampTimeStep) begin\n                    TxGainBig <= NewTxGain;\n                    ramp_counter <= 0;\n                end else begin\n                    ramp_counter <= ramp_counter + 1;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (reset || !Tx_swEnable) begin\n            timing_counter <= 0;\n        end else begin\n            if (timing_counter == 8'hFD) begin\n                timing_counter <= 0;\n            end else begin\n                timing_counter <= timing_counter + 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "radio_controller_TxTiming",
        "module_hash": "4b679b3ee604d801ae1024e2fea5d27b",
        "dataset_index": 10551
      },
      "my__d60f22ff": {
        "rtl_code": "module my_module (a, b, c, out1, out2);\n\ninput a, b, c;\noutput out1, out2;\n\nwire b_and_c;\nwire b_xor_c;\n\nassign b_and_c = b & c;\nassign b_xor_c = b ^ c;\n\nassign out1 = (a == 1) ? b_and_c : b_xor_c;\nassign out2 = a ^ c;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "d60f22ff68c2b80dd3798687bcc5899c",
        "dataset_index": 5601
      },
      "signed_mag_comp_b5b9cfae": {
        "rtl_code": "\nmodule signed_mag_comp (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input clk,  // Added clock input\n    output reg C\n);\n\nreg [3:0] A_abs, B_abs;\nreg [3:0] A_sign, B_sign;\nreg [3:0] A_mag, B_mag;\n\nwire [3:0] A_mag_reg, B_mag_reg;\nwire [3:0] A_sign_reg, B_sign_reg;\nwire [3:0] A_abs_reg, B_abs_reg;\n\nassign A_mag_reg = A_mag;\nassign B_mag_reg = B_mag;\nassign A_sign_reg = A_sign;\nassign B_sign_reg = B_sign;\nassign A_abs_reg = A_abs;\nassign B_abs_reg = B_abs;\n\n// Pipeline Stage 1: Absolute Value Calculation\nalways @(*) begin\n    if (A[3] == 1'b1) begin\n        A_abs = ~A + 1;\n    end else begin\n        A_abs = A;\n    end\n    \n    if (B[3] == 1'b1) begin\n        B_abs = ~B + 1;\n    end else begin\n        B_abs = B;\n    end\nend\n\n// Pipeline Stage 2: Sign Calculation\nalways @(*) begin\n    if (A[3] == 1'b1) begin\n        A_sign = 1'b1;\n    end else begin\n        A_sign = 1'b0;\n    end\n    \n    if (B[3] == 1'b1) begin\n        B_sign = 1'b1;\n    end else begin\n        B_sign = 1'b0;\n    end\nend\n\n// Pipeline Stage 3: Magnitude Calculation\nalways @(*) begin\n    if (A_abs > B_abs) begin\n        A_mag = A_abs;\n        B_mag = B_abs;\n    end else begin\n        A_mag = B_abs;\n        B_mag = A_abs;\n    end\nend\n\n// Pipeline Stage 4: Comparison\nalways @(posedge clk) begin  // Changed from always @(*) to always @(posedge clk)\n    if (A_mag_reg >= B_mag_reg) begin\n        C <= 1'b1;\n    end else begin\n        C <= 1'b0;\n    end\nend\n\nendmodule\n",
        "module_name": "signed_mag_comp",
        "module_hash": "b5b9cfaebe64acf18e396331c80ae4a5",
        "dataset_index": 18061
      },
      "TBUFX2_abb139de": {
        "rtl_code": "module TBUFX2 (\n\tA, \n\tOE, \n\tY);\n   input [1:0] A;\n   input OE;\n   output [3:0] Y;\n   \n   assign Y = OE ? {A, ~A} : 4'b0;\nendmodule",
        "module_name": "TBUFX2",
        "module_hash": "abb139de893a5720e58e23274234cb2a",
        "dataset_index": 15106
      },
      "sky130_fd_sc_lp__a32o_4_0589dd97": {
        "rtl_code": "\nmodule sky130_fd_sc_lp__a32o_4 (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  B1  ,\n    input  B2  ,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    sky130_fd_sc_lp__a32o_1 _0_ (\n        .X   (X   ),\n        .A1  (A1  ),\n        .A2  (A2  ),\n        .A3  (A3  ),\n        .B1  (B1  ),\n        .B2  (B2  ),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB ),\n        .VNB(VNB )\n    );\n\nendmodule\nmodule sky130_fd_sc_lp__a32o_1 (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  B1  ,\n    input  B2  ,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    sky130_fd_sc_lp__a31o_1 _0_ (\n        .X   (X   ),\n        .A1  (A1  ),\n        .A2  (A2  ),\n        .A3  (A3  ),\n        .B1  (B1  ),\n        .B2  (B2  ),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB ),\n        .VNB(VNB )\n    );\n\nendmodule\nmodule sky130_fd_sc_lp__a31o_1 (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  B1  ,\n    input  B2  ,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n    wire s1a,s1b,s2a,s2b;\n    sky130_fd_sc_lp__a21o_1 _0_ (\n        .X   (s1a),\n        .A1  (A1  ),\n        .A2  (A2  ),\n        .B1  (B1  ),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB ),\n        .VNB(VNB )\n    );\n\n    sky130_fd_sc_lp__a21o_1 _1_ (\n        .X   (s1b),\n        .A1  (A3  ),\n        .A2  (B2  ),\n        .B1  (s1a),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB ),\n        .VNB(VNB )\n    );\n\n    sky130_fd_sc_lp__a21o_1 _2_ (\n        .X   (s2a),\n        .A1  (A1  ),\n        .A2  (A2  ),\n        .B1  (B2  ),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB ),\n        .VNB(VNB )\n    );\n\n    sky130_fd_sc_lp__a21o_1 _3_ (\n        .X   (s2b),\n        .A1  (A3  ),\n        .A2  (B1  ),\n        .B1  (s2a),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB ),\n        .VNB(VNB )\n    );\n\n    sky130_fd_sc_lp__or2_1 _4_ (\n        .X   (X  ),\n        .A1  (s1b ),\n        .A2  (s2b ),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB ),\n        .VNB(VNB )\n    );\nendmodule\nmodule sky130_fd_sc_lp__a21o_1 (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    assign X   = A1 ^ (A2 & B1);\n\nendmodule\nmodule sky130_fd_sc_lp__or2_1 (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    assign X   = A1 | A2;\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a32o_4",
        "module_hash": "0589dd9744e58bb5a2c826d0be5cd329",
        "dataset_index": 18280
      },
      "rp_adc #_b3641fee": {
        "rtl_code": "\n\nmodule rp_adc #\n(\n)\n(\n  input    [ 14-1: 0] adc_dat_a_i        ,  input    [ 14-1: 0] adc_dat_b_i        ,  input               adc_clk            ,\n  output [ 2-1: 0]    adc_clk_source     ,  output              adc_cdcs_o         ,  output   [ 14-1: 0] adc_dat_a_o        ,  output   [ 14-1: 0] adc_dat_b_o        ,  input               adc_rst_i             );\n  assign adc_cdcs_o = 1'b1 ;\n\n  assign adc_clk_source = 2'b10;\n\n  reg  [14-1: 0] adc_dat_a  ;\n  reg  [14-1: 0] adc_dat_b  ;\n\n  always @(posedge adc_clk) begin\n     adc_dat_a <= adc_dat_a_i[14-1:0]; adc_dat_b <= adc_dat_b_i[14-1:0];\n  end\n    \n  assign adc_dat_a_o = {adc_dat_a[14-1], ~adc_dat_a[14-2:0]}; assign adc_dat_b_o = {adc_dat_b[14-1], ~adc_dat_b[14-2:0]};\n\nendmodule\n\n",
        "module_name": "rp_adc #",
        "module_hash": "b3641fee8ad96a91ce6f7d79f5a6ad3f",
        "dataset_index": 24538
      },
      "sky130_fd_sc_lp__a2bb2oi_ffb3c424": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a2bb2oi (\n    Y   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    wire and0_out  ;\n    wire nor0_out  ;\n    wire nor1_out_Y;\n\n    and and0 (and0_out  , B1, B2            );\n    nor nor0 (nor0_out  , A1_N, A2_N        );\n    nor nor1 (nor1_out_Y, nor0_out, and0_out);\n    buf buf0 (Y         , nor1_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a2bb2oi",
        "module_hash": "ffb3c424e6d370d843f3b67bb124a967",
        "dataset_index": 4664
      },
      "sky130_fd_sc_ms__or3b_a4dcd710": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__or3b (\n    X  ,\n    A  ,\n    B  ,\n    C_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , C_N            );\n    or  or0  (or0_out_X, B, A, not0_out );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__or3b",
        "module_hash": "a4dcd710fbd57e4c78d1c9f5bb40e6d5",
        "dataset_index": 20138
      },
      "waveform_generator_addb54f0": {
        "rtl_code": "\nmodule waveform_generator(\n    output reg Y,\n    input A1,\n    input A2,\n    input B1\n);\n\n    // Internal signal\n    wire Y_internal;\n\n    // Instantiate an A21OI gate\n    sky130_fd_sc_hdll__a21oi_2 U1(\n        .Y(Y_internal),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1)\n    );\n\n    // Register update logic\n    always @(posedge B1) begin\n        Y <= Y_internal;\n    end\n\nendmodule\nmodule sky130_fd_sc_hdll__a21oi_2 (\n    output Y,\n    input A1,\n    input A2,\n    input B1\n);\n\n    // Instantiate an A21OI gate\n    assign Y = A1 & A2 | B1;\n\nendmodule",
        "module_name": "waveform_generator",
        "module_hash": "addb54f00ac143ce273c99dce0c74c51",
        "dataset_index": 2011
      },
      "cache_memory_block_91370496": {
        "rtl_code": "module cache_memory_block (\n  input clk,\n  input we,\n  input re,\n  input [$clog2(n)-1:0] addr,\n  input [m-1:0] wd,\n  output [m-1:0] rd\n);\n\nparameter n = 8; // number of words\nparameter m = 16; // number of bits in each word\nparameter addr_bits = $clog2(n);\n\nreg [m-1:0] cache [0:n-1]; // array to store the words\n\nalways @(posedge clk) begin\n  if (we) begin\n    cache[addr] <= wd;\n  end\nend\n\nassign rd = (re) ? cache[addr] : 0;\n\nendmodule",
        "module_name": "cache_memory_block",
        "module_hash": "91370496f46bda444bf5da9227100673",
        "dataset_index": 12042
      },
      "TubeROM_0e2462ac": {
        "rtl_code": "module TubeROM (\n    input wire[3:0] value,\n    input wire auxValue,\n    output reg[6:0] segments\n    );\n\nalways @ (*) begin\n    if (auxValue) begin\n        case (value)\n            4'h0: segments = 7'h00; 4'h1: segments = 7'h73; 4'h2: segments = 7'h78; 4'h3: segments = 7'h50; 4'h4: segments = 7'h1C; 4'h5: segments = 7'h76; 4'h6: segments = 7'h38; default: segments = 7'b0;\n        endcase\n    end\n    else begin \n        case (value)\n            4'h0: segments = 7'h3F; 4'h1: segments = 7'h06; 4'h2: segments = 7'h5B; 4'h3: segments = 7'h4F; 4'h4: segments = 7'h66; 4'h5: segments = 7'h6D; 4'h6: segments = 7'h7D; 4'h7: segments = 7'h07; 4'h8: segments = 7'h7F; 4'h9: segments = 7'h6F; 4'hA: segments = 7'h77; 4'hB: segments = 7'h7C; 4'hC: segments = 7'h39; 4'hD: segments = 7'h5E; 4'hE: segments = 7'h79; 4'hF: segments = 7'h71; default: segments = 7'b0;\n        endcase\n    end\nend\nendmodule\n\nmodule TubeController (\n    input wire[1:0] dig,\n    input wire[3:0] dig1,\n    input wire[3:0] dig2,\n    input wire[3:0] dig3,\n    input wire[3:0] dig4,\n    input wire[3:0] dots,\n    input wire[3:0] auxs,\n    output wire[3:0] tubeDig,\n    output wire[7:0] tubeSeg\n    );\n\nwire[3:0] value = (dig == 2'd0)? dig1 :\n                        (dig == 2'd1)? dig2 :\n                        (dig == 2'd2)? dig3 :\n                        dig4;\n\nTubeROM rom (value, auxs[dig], tubeSeg[6:0]);\n\nassign tubeSeg[7] = dots[dig];\nassign tubeDig = (dig == 2'd0)? 4'b0001 :\n                      (dig == 2'd1)? 4'b0010 :\n                      (dig == 2'd2)? 4'b0100 :\n                      4'b1000;\nendmodule\n",
        "module_name": "TubeROM",
        "module_hash": "0e2462acca2c32886511f06965cadbf8",
        "dataset_index": 8925
      },
      "denise_spritepriority_5f8a6a10": {
        "rtl_code": "module denise_spritepriority\n(\n  input   [5:0] bplcon2,         input  [2:1] nplayfield,    input  [7:0] nsprite,      output  reg sprsel        );\n\nreg    [2:0] sprcode;      wire  [3:0] sprgroup;      wire  pf1front;        wire  pf2front;        assign  sprgroup[0] = (nsprite[1:0]==2'd0) ? 1'b0 : 1'b1;\nassign  sprgroup[1] = (nsprite[3:2]==2'd0) ? 1'b0 : 1'b1;\nassign  sprgroup[2] = (nsprite[5:4]==2'd0) ? 1'b0 : 1'b1;\nassign  sprgroup[3] = (nsprite[7:6]==2'd0) ? 1'b0 : 1'b1;\n\nalways @(*)\n  if (sprgroup[0])\n    sprcode = 3'd1;\n  else if (sprgroup[1])\n    sprcode = 3'd2;\n  else if (sprgroup[2])\n    sprcode = 3'd3;\n  else if (sprgroup[3])\n    sprcode = 3'd4;\n  else\n    sprcode = 3'd7;\n\nassign pf1front = sprcode[2:0]>bplcon2[2:0] ? 1'b1 : 1'b0;\nassign pf2front = sprcode[2:0]>bplcon2[5:3] ? 1'b1 : 1'b0;\n\nalways @(*)\nbegin\n  if (sprcode[2:0]==3'd7) sprsel = 1'b0;\n  else if (pf1front && nplayfield[1]) sprsel = 1'b0;\n  else if (pf2front && nplayfield[2]) sprsel = 1'b0;\n  else sprsel = 1'b1;\nend\n\nendmodule\n\n",
        "module_name": "denise_spritepriority",
        "module_hash": "5f8a6a1063723d3c7ef4dd1559d52df5",
        "dataset_index": 10835
      },
      "MyTruthComplement_e85e7daa": {
        "rtl_code": "module MyTruthComplement(input[5:0] yIn , output[5:0] yOut);\n\twire[5:0] inverted_yIn;\n\tassign inverted_yIn = ~yIn;\n\tassign yOut = yIn[5] ? ({yIn[5],inverted_yIn[4:0]}+6'b1) : yIn;\nendmodule",
        "module_name": "MyTruthComplement",
        "module_hash": "e85e7daa40fc7e0cf725f1d50bd931d6",
        "dataset_index": 2358
      },
      "NIOS_SYSTEMV3_NIOS_CPU_nios2_avalon_reg_b5a40eef": {
        "rtl_code": "module NIOS_SYSTEMV3_NIOS_CPU_nios2_avalon_reg (\n                                                 // inputs:\n                                                  address,\n                                                  clk,\n                                                  debugaccess,\n                                                  monitor_error,\n                                                  monitor_go,\n                                                  monitor_ready,\n                                                  reset_n,\n                                                  write,\n                                                  writedata,\n\n                                                 // outputs:\n                                                  oci_ienable,\n                                                  oci_reg_readdata,\n                                                  oci_single_step_mode,\n                                                  ocireg_ers,\n                                                  ocireg_mrs,\n                                                  take_action_ocireg\n                                               )\n;\n\n  output  [ 31: 0] oci_ienable;\n  output  [ 31: 0] oci_reg_readdata;\n  output           oci_single_step_mode;\n  output           ocireg_ers;\n  output           ocireg_mrs;\n  output           take_action_ocireg;\n  input   [  8: 0] address;\n  input            clk;\n  input            debugaccess;\n  input            monitor_error;\n  input            monitor_go;\n  input            monitor_ready;\n  input            reset_n;\n  input            write;\n  input   [ 31: 0] writedata;\n\n  reg     [ 31: 0] oci_ienable;\n  wire             oci_reg_00_addressed;\n  wire             oci_reg_01_addressed;\n  wire    [ 31: 0] oci_reg_readdata;\n  reg              oci_single_step_mode;\n  wire             ocireg_ers;\n  wire             ocireg_mrs;\n  wire             ocireg_sstep;\n  wire             take_action_oci_intr_mask_reg;\n  wire             take_action_ocireg;\n  wire             write_strobe;\n  assign oci_reg_00_addressed = address == 9'h100;\n  assign oci_reg_01_addressed = address == 9'h101;\n  assign write_strobe = write & debugaccess;\n  assign take_action_ocireg = write_strobe & oci_reg_00_addressed;\n  assign take_action_oci_intr_mask_reg = write_strobe & oci_reg_01_addressed;\n  assign ocireg_ers = writedata[1];\n  assign ocireg_mrs = writedata[0];\n  assign ocireg_sstep = writedata[3];\n  assign oci_reg_readdata = oci_reg_00_addressed ? {28'b0, oci_single_step_mode, monitor_go,\n    monitor_ready, monitor_error} : \n    oci_reg_01_addressed ?  oci_ienable :   \n    32'b0;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          oci_single_step_mode <= 1'b0;\n      else if (take_action_ocireg)\n          oci_single_step_mode <= ocireg_sstep;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          oci_ienable <= 32'b00000000000000000000000000000001;\n      else if (take_action_oci_intr_mask_reg)\n          oci_ienable <= writedata | ~(32'b00000000000000000000000000000001);\n    end\n\n\n\nendmodule",
        "module_name": "NIOS_SYSTEMV3_NIOS_CPU_nios2_avalon_reg",
        "module_hash": "b5a40eef4c3dd663e29f98cffb987a9e",
        "dataset_index": 6711
      },
      "delay_block_e53ce2f0": {
        "rtl_code": "\nmodule delay_block (\n  input clk,\n  input in,\n  output reg out\n);\n\nparameter delay = 10; // delay time in nanoseconds\n\nreg [31:0] count = 0; // 32-bit counter to count up to the specified delay time\nreg delayed_in = 0; // delayed input signal\n\nalways @(posedge clk) begin\n  if (in != delayed_in) begin // reset the counter whenever the input signal changes\n    count <= 0;\n    delayed_in <= in;\n  end else if (count < delay) begin // increment the counter until it reaches the delay time\n    count <= count + 1;\n  end else begin // output the delayed input signal\n    out <= delayed_in;\n  end\nend\n\nendmodule\n",
        "module_name": "delay_block",
        "module_hash": "e53ce2f075ef33e8202c4eb2b66c61cf",
        "dataset_index": 18745
      },
      "priority_encoder_f4fef400": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] in,\n    output [2:0] pos\n);\n\nreg [2:0] pos_int;\n\nalways @* begin\n    if (in[0]) pos_int = 0;\n    else if (in[1]) pos_int = 1;\n    else if (in[2]) pos_int = 2;\n    else if (in[3]) pos_int = 3;\n    else if (in[4]) pos_int = 4;\n    else if (in[5]) pos_int = 5;\n    else if (in[6]) pos_int = 6;\n    else if (in[7]) pos_int = 7;\n    else pos_int = 0;\nend\n\nassign pos = pos_int;\n\nendmodule\n\nmodule multiplexer (\n    input [3:0] a, b, c, d,\n    input [1:0] sel,\n    output [3:0] y\n);\n\nwire [1:0] sel_inv;\nassign sel_inv[0] = ~sel[0];\nassign sel_inv[1] = ~sel[1];\n\nwire [3:0] ab, cd;\nassign ab = sel_inv[1] ? b : a;\nassign cd = sel_inv[1] ? d : c;\n\nwire [3:0] acd, bcd;\nassign acd = sel_inv[0] ? ab : cd;\nassign bcd = sel_inv[0] ? cd : ab;\n\nassign y = sel[1] ? bcd : acd;\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    input [3:0] a, b, c, d,\n    input [1:0] sel,\n    output [2:0] pos,\n    output [3:0] y\n);\n\npriority_encoder pe (\n    .in(in),\n    .pos(pos)\n);\n\nmultiplexer mux (\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .sel(sel),\n    .y(y)\n);\n\nendmodule\n",
        "module_name": "priority_encoder",
        "module_hash": "f4fef400eb34827976a475606cca4595",
        "dataset_index": 20048
      },
      "rotator_c5069e6c": {
        "rtl_code": "\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] out\n);\n\nreg [99:0] shift_reg;\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n    end else begin\n        if (ena[0]) begin\n            shift_reg <= {shift_reg[98:0], shift_reg[99]};\n        end\n        if (ena[1]) begin\n            shift_reg <= {shift_reg[1:99], shift_reg[0]};\n        end\n    end\n    out <= shift_reg;\nend\n\nendmodule\nmodule counter(\n    input clk,\n    input reset,\n    output reg [3:0] out\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 4'b0000;\n    end else begin\n        out <= out + 1;\n    end\nend\n\nendmodule\nmodule and_gate(\n    input [99:0] in1,\n    input [3:0] in2,\n    output reg [99:0] out\n);\n\nalways @(in1 or in2) begin\n    out = in1 & (in2 << 96);\nend\n\nendmodule\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [3:0] counter_out,\n    output reg [99:0] rotator_out,\n    output reg [99:0] final_out\n);\n\nrotator rotator_inst(\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .out(rotator_out)\n);\n\ncounter counter_inst(\n    .clk(clk),\n    .reset(load),\n    .out(counter_out)\n);\n\nand_gate and_gate_inst(\n    .in1(rotator_out),\n    .in2(counter_out),\n    .out(final_out)\n);\n\nendmodule",
        "module_name": "rotator",
        "module_hash": "c5069e6c256249ad9a140ff291b20785",
        "dataset_index": 3579
      },
      "ddr3_s4_uniphy_example_if0_p0_qsys_sequencer_cpu_inst_nios2_oci_fifowp_inc_6fd07bae": {
        "rtl_code": "module ddr3_s4_uniphy_example_if0_p0_qsys_sequencer_cpu_inst_nios2_oci_fifowp_inc (\n  // inputs:\n  free2,\n  free3,\n  tm_count,\n\n  // outputs:\n  fifowp_inc\n);\n\n  output  [3:0] fifowp_inc;\n  input   free2;\n  input   free3;\n  input   [1:0] tm_count;\n\n  reg [3:0] fifowp_inc;\n\n  always @*\n  begin\n    if (free3 && (tm_count == 3))\n      fifowp_inc = 3;\n    else if (free2 && (tm_count >= 2))\n      fifowp_inc = 2;\n    else if (tm_count >= 1)\n      fifowp_inc = 1;\n    else\n      fifowp_inc = 0;\n  end\n\nendmodule",
        "module_name": "ddr3_s4_uniphy_example_if0_p0_qsys_sequencer_cpu_inst_nios2_oci_fifowp_inc",
        "module_hash": "6fd07bae9c6911707bc0722a9973d26e",
        "dataset_index": 11796
      },
      "FxP_ABS_Function_2c416559": {
        "rtl_code": "\nmodule FxP_ABS_Function\n#(\n\tparameter DATA_WIDTH = 16\n)\n(\n\tinput   [DATA_WIDTH-1:0] DATA_IN,\n\toutput  [DATA_WIDTH-1:0] DATA_ABS\n);\n\n\tassign DATA_ABS = DATA_IN[DATA_WIDTH-1] ? ~DATA_IN + 1'b1 : DATA_IN;\n\nendmodule\n",
        "module_name": "FxP_ABS_Function",
        "module_hash": "2c41655937c2956b59cdc5bee90fd621",
        "dataset_index": 10796
      },
      "BROM_47ff2fbe": {
        "rtl_code": "\n\nmodule BROM(\n\tinput\t[7:1]\tadr_i,\n\tinput\t\tstb_i,\n\toutput\t\tack_o,\n\toutput\t[15:0]\tdat_o\n);\n\treg\t[15:0]\tdat_o;\n\tassign ack_o = stb_i;\n\talways @(*) begin\n\t\tcase(adr_i)\n\t\t7'd0: dat_o = 16'h0113;\n\t\t7'd1: dat_o = 16'h0000;\n\t\t7'd2: dat_o = 16'h01B7;\n\t\t7'd3: dat_o = 16'h0010;\n\t\t7'd4: dat_o = 16'h0113;\n\t\t7'd5: dat_o = 16'h0011;\n\t\t7'd6: dat_o = 16'h5213;\n\t\t7'd7: dat_o = 16'h0011;\n\t\t7'd8: dat_o = 16'h9123;\n\t\t7'd9: dat_o = 16'h0041;\n\t\t7'd10: dat_o = 16'hF06F;\n\t\t7'd11: dat_o = 16'hFF5F;\n\t\t7'd12: dat_o = 16'hCCCC;\n\t\t7'd13: dat_o = 16'hCCCC;\n\t\t7'd14: dat_o = 16'hCCCC;\n\t\t7'd15: dat_o = 16'hCCCC;\n\t\t7'd16: dat_o = 16'hCCCC;\n\t\t7'd17: dat_o = 16'hCCCC;\n\t\t7'd18: dat_o = 16'hCCCC;\n\t\t7'd19: dat_o = 16'hCCCC;\n\t\t7'd20: dat_o = 16'hCCCC;\n\t\t7'd21: dat_o = 16'hCCCC;\n\t\t7'd22: dat_o = 16'hCCCC;\n\t\t7'd23: dat_o = 16'hCCCC;\n\t\t7'd24: dat_o = 16'hCCCC;\n\t\t7'd25: dat_o = 16'hCCCC;\n\t\t7'd26: dat_o = 16'hCCCC;\n\t\t7'd27: dat_o = 16'hCCCC;\n\t\t7'd28: dat_o = 16'hCCCC;\n\t\t7'd29: dat_o = 16'hCCCC;\n\t\t7'd30: dat_o = 16'hCCCC;\n\t\t7'd31: dat_o = 16'hCCCC;\n\t\t7'd32: dat_o = 16'hCCCC;\n\t\t7'd33: dat_o = 16'hCCCC;\n\t\t7'd34: dat_o = 16'hCCCC;\n\t\t7'd35: dat_o = 16'hCCCC;\n\t\t7'd36: dat_o = 16'hCCCC;\n\t\t7'd37: dat_o = 16'hCCCC;\n\t\t7'd38: dat_o = 16'hCCCC;\n\t\t7'd39: dat_o = 16'hCCCC;\n\t\t7'd40: dat_o = 16'hCCCC;\n\t\t7'd41: dat_o = 16'hCCCC;\n\t\t7'd42: dat_o = 16'hCCCC;\n\t\t7'd43: dat_o = 16'hCCCC;\n\t\t7'd44: dat_o = 16'hCCCC;\n\t\t7'd45: dat_o = 16'hCCCC;\n\t\t7'd46: dat_o = 16'hCCCC;\n\t\t7'd47: dat_o = 16'hCCCC;\n\t\t7'd48: dat_o = 16'hCCCC;\n\t\t7'd49: dat_o = 16'hCCCC;\n\t\t7'd50: dat_o = 16'hCCCC;\n\t\t7'd51: dat_o = 16'hCCCC;\n\t\t7'd52: dat_o = 16'hCCCC;\n\t\t7'd53: dat_o = 16'hCCCC;\n\t\t7'd54: dat_o = 16'hCCCC;\n\t\t7'd55: dat_o = 16'hCCCC;\n\t\t7'd56: dat_o = 16'hCCCC;\n\t\t7'd57: dat_o = 16'hCCCC;\n\t\t7'd58: dat_o = 16'hCCCC;\n\t\t7'd59: dat_o = 16'hCCCC;\n\t\t7'd60: dat_o = 16'hCCCC;\n\t\t7'd61: dat_o = 16'hCCCC;\n\t\t7'd62: dat_o = 16'hCCCC;\n\t\t7'd63: dat_o = 16'hCCCC;\n\t\t7'd64: dat_o = 16'hCCCC;\n\t\t7'd65: dat_o = 16'hCCCC;\n\t\t7'd66: dat_o = 16'hCCCC;\n\t\t7'd67: dat_o = 16'hCCCC;\n\t\t7'd68: dat_o = 16'hCCCC;\n\t\t7'd69: dat_o = 16'hCCCC;\n\t\t7'd70: dat_o = 16'hCCCC;\n\t\t7'd71: dat_o = 16'hCCCC;\n\t\t7'd72: dat_o = 16'hCCCC;\n\t\t7'd73: dat_o = 16'hCCCC;\n\t\t7'd74: dat_o = 16'hCCCC;\n\t\t7'd75: dat_o = 16'hCCCC;\n\t\t7'd76: dat_o = 16'hCCCC;\n\t\t7'd77: dat_o = 16'hCCCC;\n\t\t7'd78: dat_o = 16'hCCCC;\n\t\t7'd79: dat_o = 16'hCCCC;\n\t\t7'd80: dat_o = 16'hCCCC;\n\t\t7'd81: dat_o = 16'hCCCC;\n\t\t7'd82: dat_o = 16'hCCCC;\n\t\t7'd83: dat_o = 16'hCCCC;\n\t\t7'd84: dat_o = 16'hCCCC;\n\t\t7'd85: dat_o = 16'hCCCC;\n\t\t7'd86: dat_o = 16'hCCCC;\n\t\t7'd87: dat_o = 16'hCCCC;\n\t\t7'd88: dat_o = 16'hCCCC;\n\t\t7'd89: dat_o = 16'hCCCC;\n\t\t7'd90: dat_o = 16'hCCCC;\n\t\t7'd91: dat_o = 16'hCCCC;\n\t\t7'd92: dat_o = 16'hCCCC;\n\t\t7'd93: dat_o = 16'hCCCC;\n\t\t7'd94: dat_o = 16'hCCCC;\n\t\t7'd95: dat_o = 16'hCCCC;\n\t\t7'd96: dat_o = 16'hCCCC;\n\t\t7'd97: dat_o = 16'hCCCC;\n\t\t7'd98: dat_o = 16'hCCCC;\n\t\t7'd99: dat_o = 16'hCCCC;\n\t\t7'd100: dat_o = 16'hCCCC;\n\t\t7'd101: dat_o = 16'hCCCC;\n\t\t7'd102: dat_o = 16'hCCCC;\n\t\t7'd103: dat_o = 16'hCCCC;\n\t\t7'd104: dat_o = 16'hCCCC;\n\t\t7'd105: dat_o = 16'hCCCC;\n\t\t7'd106: dat_o = 16'hCCCC;\n\t\t7'd107: dat_o = 16'hCCCC;\n\t\t7'd108: dat_o = 16'hCCCC;\n\t\t7'd109: dat_o = 16'hCCCC;\n\t\t7'd110: dat_o = 16'hCCCC;\n\t\t7'd111: dat_o = 16'hCCCC;\n\t\t7'd112: dat_o = 16'hCCCC;\n\t\t7'd113: dat_o = 16'hCCCC;\n\t\t7'd114: dat_o = 16'hCCCC;\n\t\t7'd115: dat_o = 16'hCCCC;\n\t\t7'd116: dat_o = 16'hCCCC;\n\t\t7'd117: dat_o = 16'hCCCC;\n\t\t7'd118: dat_o = 16'hCCCC;\n\t\t7'd119: dat_o = 16'hCCCC;\n\t\t7'd120: dat_o = 16'hCCCC;\n\t\t7'd121: dat_o = 16'hCCCC;\n\t\t7'd122: dat_o = 16'hCCCC;\n\t\t7'd123: dat_o = 16'hCCCC;\n\t\t7'd124: dat_o = 16'hCCCC;\n\t\t7'd125: dat_o = 16'hCCCC;\n\t\t7'd126: dat_o = 16'hCCCC;\n\t\t7'd127: dat_o = 16'hCCCC;\n\t\tendcase\n\tend\nendmodule\n",
        "module_name": "BROM",
        "module_hash": "47ff2fbe360526bb1ff32a6a2a5c49ca",
        "dataset_index": 23081
      },
      "debounce_switch #_d3484480": {
        "rtl_code": "module debounce_switch #(\n    parameter WIDTH = 1, // width of the input and output signals\n    parameter N = 3, // length of shift register\n    parameter RATE = 125000 // clock division factor\n)(\n    input wire clk,\n    input wire rst,\n    input wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\n\n    reg [23:0] cnt_reg = 24'd0;\n    reg [N-1:0] debounce_reg[WIDTH-1:0];\n    reg [WIDTH-1:0] state;\n\n    \n    assign out = state;\n\n    integer k;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            cnt_reg <= 0;\n            state <= 0;\n\n            for (k = 0; k < WIDTH; k = k + 1) begin\n                debounce_reg[k] <= 0;\n            end\n        end else begin\n            if (cnt_reg < RATE) begin\n                cnt_reg <= cnt_reg + 24'd1;\n            end else begin\n                cnt_reg <= 24'd0;\n            end\n\n            if (cnt_reg == 24'd0) begin\n                for (k = 0; k < WIDTH; k = k + 1) begin\n                    debounce_reg[k] <= {debounce_reg[k][N-2:0], in[k]};\n                end\n            end\n\n            for (k = 0; k < WIDTH; k = k + 1) begin\n                if (|debounce_reg[k] == 0) begin\n                    state[k] <= 0;\n                end else if (&debounce_reg[k] == 1) begin\n                    state[k] <= 1;\n                end else begin\n                    state[k] <= state[k];\n                end\n            end\n        end\n    end\n\nendmodule",
        "module_name": "debounce_switch #",
        "module_hash": "d34844807e0a5e89aaeda10a35392c89",
        "dataset_index": 13799
      },
      "dly01_16_f3c37f67": {
        "rtl_code": "\n\nmodule  dly01_16(\n    input       clk,\n    input       rst,\n    input [3:0] dly,\n    input       din,\n    output      dout\n);\n    reg [15:0] sr=0;\n`ifdef SHREG_SEQUENTIAL_RESET\n    always @ (posedge clk) begin\n        sr <= {sr[14:0], din & ~rst}; \n    end\n`else \nalways @ (posedge clk) begin\n       if (rst) sr <=0;\n       else     sr <= {sr[14:0],din}; \n    end\n`endif\n`ifdef SIMULATION\n    assign dout = (|sr) ? ((&sr) ? 1'b1 : sr[dly]) :  1'b0 ;\n`else\n    assign dout =sr[dly];\n`endif        \nendmodule\n\n",
        "module_name": "dly01_16",
        "module_hash": "f3c37f67e0658bfa523a4b64fa0c7a35",
        "dataset_index": 16190
      },
      "addsub_4bit_f4eb00e8": {
        "rtl_code": "module addsub_4bit (A, B, M, Y, O);\n\n  input [3:0] A, B;\n  input M;\n  output reg [3:0] Y;\n  output reg O;\n  \n  reg [4:0] temp;\n  \n  always @* begin\n    if (M == 0) begin\n      temp = A + B;\n    end\n    else begin\n      temp = A - B;\n    end\n    Y = temp[3:0];\n    O = temp[4];\n  end\n  \nendmodule",
        "module_name": "addsub_4bit",
        "module_hash": "f4eb00e87de08193272e3966d05b7caf",
        "dataset_index": 743
      },
      "binary_counter_1aea7b00": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    output reg [15:0] q,\n    output reg [3:0] ov,\n    output reg [3:1] ena\n);\n\nreg [3:0] count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 0;\n        q <= 0;\n        ov <= 0;\n    end else begin\n        if (ena[3]) begin\n            count[3] <= ~count[3];\n            if (count[3]) begin\n                if (ena[2]) begin\n                    count[2] <= ~count[2];\n                    if (count[2]) begin\n                        if (ena[1]) begin\n                            count[1] <= ~count[1];\n                            if (count[1]) begin\n                                count[0] <= ~count[0];\n                            end\n                        end\n                    end\n                end\n            end\n        end\n        q <= {count, 12'h0};\n        ov <= count == 4'hF;\n    end\nend\n\nendmodule\n\nmodule overflow_counter (\n    input [15:0] q,\n    output reg [3:0] ov\n);\n\nalways @(*) begin\n    ov = q[15] + q[14] + q[13] + q[12];\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "1aea7b005cf9a7942b16b3ab87378ca3",
        "dataset_index": 14701
      },
      "sky130_fd_sc_ms__a221o_43398abb": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__a221o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2                );\n    and and1 (and1_out , A1, A2                );\n    or  or0  (or0_out_X, and1_out, and0_out, C1);\n    buf buf0 (X        , or0_out_X             );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__a221o",
        "module_hash": "43398abb754220638d1c495fd4c05da2",
        "dataset_index": 2334
      },
      "sky130_fd_sc_hs__o311ai_3a9d48ad": {
        "rtl_code": "module sky130_fd_sc_hs__o311ai (\n    output Y,\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input C1,\n    input VPWR,\n    input VGND\n);\n\n    // Local signals\n    wire B1_or0_out;\n    wire nand0_out_Y;\n    wire u_vpwr_vgnd0_out_Y;\n\n    // OR gate for A1, A2, and A3\n    or or0 (\n        B1_or0_out, A1, A2, A3\n    );\n\n    // NAND gate for C1, B1, and OR gate output\n    nand nand0 (\n        nand0_out_Y, C1, B1_or0_out, B1\n    );\n\n    // Sky130_fd_sc_hs__u_vpwr_vgnd module\n    // sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (\n    //     u_vpwr_vgnd0_out_Y, nand0_out_Y, VPWR, VGND\n    // );\n\n    // Buffer for u_vpwr_vgnd0_out_Y to Y\n    buf buf0 (\n        Y, nand0_out_Y\n    );\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__o311ai",
        "module_hash": "3a9d48ad755459a200eb162e9c4fc411",
        "dataset_index": 6810
      },
      "fifo_dc6f6e1d": {
        "rtl_code": "module fifo (\n    input clock,\n    input [31:0] data,\n    input rdreq,\n    input wrreq,\n    output empty,\n    output full,\n    output reg [31:0] q\n);\n\n    reg [31:0] fifo [0:1023];\n    reg [9:0] head = 0;\n    reg [9:0] tail = 0;\n    reg [31:0] count = 0;\n\n    always @(posedge clock) begin\n        if (wrreq && !full) begin\n            fifo[head] <= data;\n            head <= (head == 1023) ? 0 : head + 1;\n            count <= count + 1;\n        end\n        if (rdreq && !empty) begin\n            q <= fifo[tail];\n            tail <= (tail == 1023) ? 0 : tail + 1;\n            count <= count - 1;\n        end\n    end\n\n    assign empty = (count == 0);\n    assign full = (count == 1024);\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "dc6f6e1dc75bcdee7a2c188142c3a134",
        "dataset_index": 13758
      },
      "fifo_buffer_e7623cb1": {
        "rtl_code": "module fifo_buffer (\n    input aclr,\n    input clock,\n    input [29:0] data,\n    input rdreq,\n    input wrreq,\n    output [29:0] q,\n    output [4:0] usedw\n);\n\nreg [29:0] buffer [31:0];\nreg [4:0] usedw_reg;\nreg [4:0] usedw_next;\nreg [4:0] usedw_next_next;\nreg [4:0] usedw_next_next_next;\nreg [29:0] q_reg;\nreg [29:0] q_next;\nreg [29:0] q_next_next;\nreg [29:0] q_next_next_next;\nreg wr_en;\nreg rd_en;\ninteger i;\n\nalways @(posedge clock or negedge aclr) begin\n    if (~aclr) begin\n        usedw_reg <= 0;\n        q_reg <= 0;\n        wr_en <= 0;\n        rd_en <= 0;\n    end\n    else begin\n        usedw_reg <= usedw_next_next_next;\n        q_reg <= q_next_next_next;\n        wr_en <= wrreq && (usedw_reg < 32);\n        rd_en <= rdreq && (usedw_reg > 0);\n    end\nend\n\nalways @(posedge clock or negedge aclr) begin\n    if (~aclr) begin\n        usedw_next <= 0;\n        usedw_next_next <= 0;\n        usedw_next_next_next <= 0;\n        q_next <= 0;\n        q_next_next <= 0;\n        q_next_next_next <= 0;\n    end\n    else begin\n        usedw_next <= usedw_reg + wr_en - rd_en;\n        usedw_next_next <= usedw_next;\n        usedw_next_next_next <= usedw_next_next;\n        q_next <= buffer[0];\n        q_next_next <= q_next;\n        q_next_next_next <= q_next_next;\n    end\nend\n\nalways @(posedge clock or negedge aclr) begin\n    if (~aclr) begin\n        buffer[0] <= 0;\n    end\n    else begin\n        if (wr_en) begin\n            buffer[usedw_reg] <= data;\n        end\n        if (rd_en) begin\n            buffer[usedw_reg - 1] <= 0;\n        end\n        for (i = 1; i < 32; i = i + 1) begin\n            buffer[i] <= buffer[i-1];\n        end\n    end\nend\n\nassign q = q_reg;\nassign usedw = usedw_reg;\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "e7623cb108685012c4e4549ecd1869e9",
        "dataset_index": 4460
      },
      "pipeline_register #_928e1837": {
        "rtl_code": "\nmodule pipeline_register #(\n    parameter width = 8 // width of the data signal\n)(\n  input wire clk,\n  input wire reset,\n  input [width-1:0] data_in,\n  output reg [width-1:0] data_out\n);\n\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out <= 0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule\n",
        "module_name": "pipeline_register #",
        "module_hash": "928e1837c1b95bae00f2fa06866185d6",
        "dataset_index": 19343
      },
      "sumwrap_uint16_to1_1_a5aa1513": {
        "rtl_code": "module sumwrap_uint16_to1_1(input CLK, input CE, input [31:0] process_input, output [15:0] process_output);\nparameter INSTANCE_NAME=\"INST\";\n\n  wire [15:0] least_sig_bits;\n  assign least_sig_bits = process_input[15:0]; // Extract the least significant 16 bits of process_input\n  \n  wire [15:0] most_sig_bits;\n  assign most_sig_bits = process_input[31:16]; // Extract the most significant 16 bits of process_input\n  \n  assign process_output = ((least_sig_bits == 16'd1) ? 16'd0 : (least_sig_bits + most_sig_bits)); // If least_sig_bits == 1, output 0, else output sum of least_sig_bits and most_sig_bits\n  \nendmodule",
        "module_name": "sumwrap_uint16_to1_1",
        "module_hash": "a5aa151329a70bbcfe12fb998bcd132d",
        "dataset_index": 1018
      },
      "DeBouncer_8b2e313a": {
        "rtl_code": "module DeBouncer(input \t\t clk, n_reset, button_in,\t\t\t\t\n\t\t\t\t\t  output reg DB_out);\n\t\t\t\t\t  \n\tparameter N = 23 ;\n\t\n   reg  [N-1 : 0]\tq_reg;\t\t\t\t\t\t\treg  [N-1 : 0]\tq_next;\n\treg DFF1, DFF2;\t\t\t\t\t\t\t\t\twire q_add;\t\t\t\t\t\t\t\t\t\t\twire q_reset;\n\n   assign q_reset = (DFF1  ^ DFF2);\t\tassign  q_add = ~(q_reg[N-1]);\t\t\talways @ ( q_reset, q_add, q_reg)\n\t\tcase( {q_reset , q_add})\n\t\t\t2'b00:   q_next <= q_reg;\n\t\t\t2'b01:   q_next <= q_reg + 1;\n\t\t\tdefault: q_next <= { N {1'b0} };\n\t\tendcase \t\n\t\n   always@(posedge clk)\n\t\tif(n_reset ==  1'b1)\n\t\tbegin\n\t\t\tDFF1 <= 1'b0;\n\t\t\tDFF2 <= 1'b0;\n\t\t\tq_reg <= { N {1'b0} };\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tDFF1 <= button_in;\n\t\t\tDFF2 <= DFF1;\n\t\t\tq_reg <= q_next;\n\t\tend\n\t\n   always@(posedge clk)\n\t\tif(q_reg[N-1] == 1'b1)\n\t\t\tDB_out <= DFF2;\n\t\telse\n\t\t\tDB_out <= DB_out;\n\t\t\t\nendmodule\n",
        "module_name": "DeBouncer",
        "module_hash": "8b2e313a472eb02d3a0f664c725a7773",
        "dataset_index": 22710
      },
      "simple_calculator_0497b768": {
        "rtl_code": "module simple_calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input signed [7:0] num1,\n    input signed [7:0] num2,\n    output reg signed [7:0] result,\n    output reg overflow\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 0;\n        overflow <= 0;\n    end\n    else begin\n        case (op)\n            2'b00: begin // addition\n                result <= num1 + num2;\n                overflow <= ((num1[7] == num2[7]) && (result[7] != num1[7]));\n            end\n            2'b01: begin // subtraction\n                result <= num1 - num2;\n                overflow <= ((num1[7] != num2[7]) && (result[7] != num1[7]));\n            end\n            2'b10: begin // multiplication\n                result <= num1 * num2;\n                overflow <= ((result[7:0] != 0) && (result[7:0] != -1));\n            end\n            2'b11: begin // division\n                if (num2 == 0) begin\n                    result <= 0;\n                    overflow <= 1;\n                end\n                else begin\n                    result <= num1 / num2;\n                    overflow <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "0497b76824d64425c764035390b526a3",
        "dataset_index": 13913
      },
      "qmem_bridge #_e3b187d6": {
        "rtl_code": "\n\n\n\n\n\n\n\nmodule qmem_bridge #(\n  parameter MAW = 22,\n  parameter MSW = 4,\n  parameter MDW = 32,\n  parameter SAW = 22,\n  parameter SSW = 2,\n  parameter SDW = 16\n)(\n  input  wire           m_clk,\n  input  wire [MAW-1:0] m_adr,\n  input  wire           m_cs,\n  input  wire           m_we,\n  input  wire [MSW-1:0] m_sel,\n  input  wire [MDW-1:0] m_dat_w,\n  output reg  [MDW-1:0] m_dat_r,\n  output reg            m_ack = 1'b0,\n  output wire           m_err,\n  input  wire           s_clk,\n  output reg  [SAW-1:0] s_adr,\n  output reg            s_cs,\n  output reg            s_we,\n  output reg  [SSW-1:0] s_sel,\n  output reg  [SDW-1:0] s_dat_w,\n  input  wire [SDW-1:0] s_dat_r,\n  input  wire           s_ack,\n  input  wire           s_err\n);\n\n\nreg [  3-1:0] cs_sync = 3'b000;\nalways @ (posedge s_clk) cs_sync <= #1 {cs_sync[1:0], m_cs};\n\nwire cs_posedge;\nassign cs_posedge = cs_sync[1] && !cs_sync[2];\n\nreg  [MAW-1:0] adr_d = {MAW{1'b0}};\nreg            we_d = 1'b0;\nreg  [MSW-1:0] sel_d = {MSW{1'b0}};\nreg  [MDW-1:0] dat_w_d = {MDW{1'b0}};\nalways @ (posedge s_clk) begin\n  if (cs_sync[1]) begin\n    adr_d   <= #1 m_adr;\n    we_d    <= #1 m_we;\n    sel_d   <= #1 m_sel;\n    dat_w_d <= #1 m_dat_w;\n  end\nend\n\nreg  [  3-1:0] state = 3'b000;\nlocalparam ST_IDLE     = 3'b000;\nlocalparam ST_U_SETUP  = 3'b010;\nlocalparam ST_U_WAIT   = 3'b011;\nlocalparam ST_L_SETUP  = 3'b100;\nlocalparam ST_L_WAIT   = 3'b101;\nlocalparam ST_A_WAIT   = 3'b111;\nreg  [  2-1:0] s_ack_sync = 2'b00;\nreg done = 1'b0;\nalways @ (posedge s_clk) begin\n  case (state)\n    ST_IDLE : begin\n      if (cs_sync[2]) begin\n        state <= #1 ST_U_SETUP;\n      end\n    end\n    ST_U_SETUP : begin\n      s_cs    <= #1 1'b1;\n      s_adr   <= #1 {adr_d[22-1:2], 1'b0, 1'b0};\n      s_sel   <= #1 sel_d[3:2];\n      s_we    <= #1 we_d;\n      s_dat_w <= #1 dat_w_d[31:16];\n      state   <= #1 ST_U_WAIT;\n    end\n    ST_U_WAIT : begin\n      if (s_ack) begin\n        s_cs           <= #1 1'b0;\n        m_dat_r[31:16] <= #1 s_dat_r;\n        state          <= #1 ST_L_SETUP;\n      end\n    end\n    ST_L_SETUP : begin\n      s_cs    <= #1 1'b1;\n      s_adr   <= #1 {adr_d[22-1:2], 1'b1, 1'b0};\n      s_sel   <= #1 sel_d[1:0];\n      s_we    <= #1 we_d;\n      s_dat_w <= #1 dat_w_d[15:0];\n      state   <= #1 ST_L_WAIT;\n    end\n    ST_L_WAIT : begin\n      if (s_ack) begin\n        s_cs           <= #1 1'b0;\n        m_dat_r[15: 0] <= #1 s_dat_r;\n        done           <= #1 1'b1;\n        state          <= #1 ST_A_WAIT;\n      end\n    end\n    ST_A_WAIT : begin\n      if (s_ack_sync[1]) begin\n        done  <= #1 1'b0;\n        state <= #1 ST_IDLE;\n      end\n    end\n  endcase\nend\n\nreg  [  3-1:0] m_ack_sync = 3'b000;\nalways @ (posedge m_clk) begin\n  m_ack_sync <= #1 {m_ack_sync[1:0], done};\nend\nwire m_ack_posedge;\nassign m_ack_posedge = m_ack_sync[1] && !m_ack_sync[2];\nalways @ (posedge m_clk) begin\n  if (m_ack_posedge) m_ack <= #1 1'b1;\n  else if (m_ack) m_ack <= #1 1'b0;\nend\nalways @ (posedge s_clk) begin\n  s_ack_sync <= #1 {s_ack_sync[0], m_ack_sync[2]};\nend\n\nassign m_err = 1'b0;\n\n\nendmodule\n\n",
        "module_name": "qmem_bridge #",
        "module_hash": "e3b187d643dec1c818b1fc81add44329",
        "dataset_index": 24868
      },
      "clk_rst_mngr_df0f9cd6": {
        "rtl_code": "module clk_rst_mngr (\n    input clk_in,\n    input rst_async_n,\n    input en_clk_div8,\n    output rst_sync_n,\n    output clk_out,\n    output clk_div2,\n    output clk_div4,\n    output clk_div8,\n    output clk_div8_proc\n  );\n\n  reg [2:0] counter;\n  reg synch_rst_reg1_n, synch_rst_reg2_n;\n  reg en_clk_div8_reg;\n\n  // clock divider\n  always@(posedge clk_in)begin\n    if(!rst_async_n)\n      counter <= 0;\n    else\n      counter <= counter + 1;\n  end\n\n  assign clk_out = clk_in;\n  assign clk_div2 = counter[0];\n  assign clk_div4 = counter[1];\n  assign clk_div8 = counter[2];\n\n  //change to make one delay to release the processor\n  always@(posedge clk_div8, negedge rst_async_n)begin\n    if(!rst_async_n)\n      en_clk_div8_reg <= 0;\n    else\n      en_clk_div8_reg <= en_clk_div8;\n  end\n\n  //\"clock gate\"\n  assign clk_div8_proc = en_clk_div8_reg ? (counter[2] & rst_async_n) : 1'b0;\n\n  always@(posedge clk_div8, negedge rst_async_n)begin\n    if(!rst_async_n)begin\n      synch_rst_reg1_n <= 1'b0;\n      synch_rst_reg2_n <= 1'b0;\n    end\n    else begin\n      synch_rst_reg1_n <= 1'b1;\n      synch_rst_reg2_n <= synch_rst_reg1_n;\n    end\n  end\n\n  assign rst_sync_n = synch_rst_reg2_n;\n\nendmodule",
        "module_name": "clk_rst_mngr",
        "module_hash": "df0f9cd6f096ce53d27f69e3c5b5f54c",
        "dataset_index": 4080
      },
      "des_comp_gen_fx_color_b50ac91f": {
        "rtl_code": "module des_comp_gen_fx_color\n  (\n   input              clk,\n   input              rstn,\n   input signed [31:0] dx_fx, // 16.16\n   input signed [31:0] dy_fx, // 16.16\n   input [95:0]        cmp_i,\n\n   output [7:0]        curr_i\n   );\n\n  reg signed [57:0]    ix;\n  reg signed [57:0]    iy;\n  reg signed [57:0]    ixy;\n  reg signed [19:0]    curr;\n  \n  assign curr_i = (curr[19]) ? 8'h00 : // Under flow.\n                  (curr[18]) ? 8'hff : // Over flow.\n                  curr[17:10];        // Normal.\n  \n  wire [17:0]           sp_fx;\n  wire signed [25:0]    idx_fx;\n  wire signed [25:0]    idy_fx;\n  \n  assign sp_fx  = flt_fx_8p10(cmp_i[95:64]);\n  assign idx_fx = flt_fx_16p10(cmp_i[63:32]);\n  assign idy_fx = flt_fx_16p10(cmp_i[31:0]);\n  \n  always @(posedge clk) begin\n    ix        <= dx_fx * idx_fx;            // 16.16 * 16.10 = 32.26\n    iy        <= dy_fx * idy_fx;            // 16.16 * 16.10 = 32.26\n    ixy       <= iy + ix;                  // 32.26 + 32.26 = 32.26\n    curr      <= ixy[35:16] + {2'b00, sp_fx}; // 10.10 + 10.10 = 10.10\n  end\n  \n  //////////////////////////////////////////////////////////////////\n  // Float to fixed converts floating point numbers to 16.16 sign\n  //\n  //\n  function [25:0] flt_fx_16p10;\n    input [31:0] fp_in;         // Floating point in IEEE fmt\n    //  16.10, Color.\n    reg [7:0]     bias_exp;       \n    reg [7:0]     bias_exp2;      \n    reg [47:0]    bias_mant;      \n    reg [47:0]    int_fixed_out;\n    reg [31:0]    fixed_out;\n    begin\n      bias_mant = {25'h0001, fp_in[22:0]};\n      bias_exp = fp_in[30:23] - 8'd127;\n      bias_exp2 = ~bias_exp + 8'h1;\n      // infinity or NaN - Don't do anything special, will overflow\n      // zero condition\n      if (fp_in[30:0] == 31'b0) int_fixed_out = 0;\n      // negative exponent\n      else if (bias_exp[7]) int_fixed_out = bias_mant >> bias_exp2;\n      // positive exponent\n      else int_fixed_out = bias_mant << bias_exp;\n      fixed_out = int_fixed_out[38:13];\n      flt_fx_16p10 = (fp_in[31]) ? ~fixed_out[25:0] + 26'h1 : fixed_out[25:0];\n    end\n  endfunction\n  \n  function [17:0] flt_fx_8p10;\n    input [31:0] fp_in;         // Floating point in IEEE fmt\n    //  16.10, Color.\n    reg [7:0]     bias_exp;       \n    reg [7:0]     bias_exp2;      \n    reg [47:0]    bias_mant;      \n    reg [47:0]    int_fixed_out;\n    reg [31:0]    fixed_out;\n    begin\n      bias_mant = {25'h0001, fp_in[22:0]};\n      bias_exp = fp_in[30:23] - 8'd127;\n      bias_exp2 = ~bias_exp + 8'h1;\n      // infinity or NaN - Don't do anything special, will overflow\n      // zero condition\n      if (fp_in[30:0] == 31'b0) int_fixed_out = 0;\n      // negative exponent\n      else if (bias_exp[7]) int_fixed_out = bias_mant >> bias_exp2;\n      // positive exponent\n      else int_fixed_out = bias_mant << bias_exp;\n      fixed_out = int_fixed_out[31:13];\n      flt_fx_8p10 = (fp_in[31]) ? ~fixed_out[17:0] + 18'h1 : fixed_out[17:0];\n    end\n  endfunction\n  \n  \nendmodule",
        "module_name": "des_comp_gen_fx_color",
        "module_hash": "b50ac91f8b34c90b3f682f7fc5bce4da",
        "dataset_index": 10049
      },
      "var13_multi_2c042081": {
        "rtl_code": "\nmodule var13_multi (A, B, C, D, E, F, G, H, I, J, K, L, M, valid);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M;\n    output valid;\n\n    wire [7:0] min_value = 8'd121;\n    wire [7:0] max_weight = 8'd60;\n    wire [7:0] max_volume = 8'd60;\nwire [7:0]  total_value = \n        A * 8'd4\n      + B * 8'd8\n      + C * 8'd0\n      + D * 8'd20\n      + E * 8'd10\n      + F * 8'd12\n      + G * 8'd18\n      + H * 8'd14\n      + I * 8'd6\n      + J * 8'd15\n      + K * 8'd30\n      + L * 8'd8\n      + M * 8'd16;\n\n    wire [7:0]  total_weight = \n        A * 8'd28\n      + B * 8'd8\n      + C * 8'd27\n      + D * 8'd18\n      + E * 8'd27\n      + F * 8'd28\n      + G * 8'd6\n      + H * 8'd1\n      + I * 8'd20\n      + J * 8'd0\n      + K * 8'd5\n      + L * 8'd13\n      + M * 8'd8;\n\n    wire [7:0]  total_volume = \n        A * 8'd27\n      + B * 8'd27\n      + C * 8'd4\n      + D * 8'd4\n      + E * 8'd0\n      + F * 8'd24\n      + G * 8'd4\n      + H * 8'd20\n      + I * 8'd12\n      + J * 8'd15\n      + K * 8'd5\n      + L * 8'd2\n      + M * 8'd9;\n\nassign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume));\nendmodule\n",
        "module_name": "var13_multi",
        "module_hash": "2c042081e474e307c7af4ba1cf72cc20",
        "dataset_index": 22391
      },
      "my__d6570c78": {
        "rtl_code": "module my_module (\n  Y,\n  A,\n  B_N,\n  VPWR\n);\n\n  output Y;\n  input A;\n  input [1:0] B_N;\n  input VPWR;\n\n  wire [2:0] input_signal;\n\n  assign input_signal = {~A, B_N};\n\n  assign Y = (VPWR == 1'b0) ? 1'b0 : (input_signal == 3'b101) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "d6570c784d50e1e65e77b5bd045ae7ba",
        "dataset_index": 15308
      },
      "rotator_ad570124": {
        "rtl_code": "\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nreg [99:0] pipeline_reg [2:0];\nreg [99:0] shifted_out;\nreg [99:0] shifted_in;\n\nalways @(posedge clk) begin\n    if (load) begin\n        pipeline_reg[0] <= data;\n        pipeline_reg[1] <= pipeline_reg[0];\n        pipeline_reg[2] <= pipeline_reg[1];\n    end else begin\n        pipeline_reg[0] <= shifted_in;\n        pipeline_reg[1] <= pipeline_reg[0];\n        pipeline_reg[2] <= pipeline_reg[1];\n    end\n    \n    if (ena == 2'b01) begin\n        shifted_out <= pipeline_reg[2][0];\n        shifted_in <= {shifted_out, pipeline_reg[2][99:1]};\n    end else if (ena == 2'b10) begin\n        shifted_out <= pipeline_reg[2][99];\n        shifted_in <= {pipeline_reg[2][98:0], shifted_out};\n    end else begin\n        shifted_in <= pipeline_reg[2];\n    end\nend\n\nassign q = pipeline_reg[0];\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nrotator rotator_inst(\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(q)\n);\n\nendmodule\n",
        "module_name": "rotator",
        "module_hash": "ad570124a311a86c9213e2088a045c4d",
        "dataset_index": 2557
      },
      "parity_generator_b24620d5": {
        "rtl_code": "\nmodule parity_generator (\n  input [15:0] data,\n  output [16:0] parity_data\n);\n\n  wire parity;\n\n  assign parity = ^data;\n  assign parity_data = {parity, data};\n  \nendmodule",
        "module_name": "parity_generator",
        "module_hash": "b24620d55ed9a3488dd6a71b1dcd9f82",
        "dataset_index": 12477
      },
      "pipeline_processor_81d7f2fd": {
        "rtl_code": "module pipeline_processor(\n    input clk, PCSrc,\n    input [31:0] EX_MEM_NPC, IF_ID_IR, IF_ID_NPC,\n    output reg [31:0] ID_EX_IR, ID_EX_A, ID_EX_B, ID_EX_NPC,\n    output reg ID_EX_Flush\n);\n\nreg [31:0] reg_file[31:0];\nreg [31:0] mem[1023:0];\nreg [31:0] PC;\n\nlocalparam ADD_OP = 5'b00000;\nlocalparam SUB_OP = 5'b00001;\nlocalparam LW_OP = 5'b00010;\nlocalparam SW_OP = 5'b00011;\nlocalparam BEQ_OP = 5'b00100;\n\nlocalparam ST_IF = 2'b00;\nlocalparam ST_ID = 2'b01;\nlocalparam ST_EX = 2'b10;\n\nreg [1:0] state;\nreg [31:0] ID_EX_IR_temp, ID_EX_NPC_temp;\nreg [4:0] ID_EX_rs, ID_EX_rt, ID_EX_rd, ID_EX_imm, ID_EX_func;\nreg [2:0] ID_EX_ALUOp;\nreg [31:0] ID_EX_A_temp, ID_EX_B_temp;\n\nalways @(posedge clk) begin\n    if (state == ST_IF) begin\n        ID_EX_Flush <= 0;\n        ID_EX_IR_temp <= IF_ID_IR;\n        ID_EX_NPC_temp <= IF_ID_NPC;\n        PC <= IF_ID_NPC;\n        state <= ST_ID;\n    end else if (state == ST_ID) begin\n        ID_EX_IR <= ID_EX_IR_temp;\n        ID_EX_NPC <= ID_EX_NPC_temp;\n        ID_EX_rs <= ID_EX_IR_temp[25:21];\n        ID_EX_rt <= ID_EX_IR_temp[20:16];\n        ID_EX_rd <= ID_EX_IR_temp[15:11];\n        ID_EX_imm <= ID_EX_IR_temp[15:0];\n        ID_EX_func <= ID_EX_IR_temp[5:0];\n        ID_EX_A_temp <= reg_file[ID_EX_rs];\n        ID_EX_B_temp <= reg_file[ID_EX_rt];\n        case (ID_EX_IR_temp[31:26])\n            ADD_OP, SUB_OP: ID_EX_ALUOp <= 3'b000;\n            LW_OP: ID_EX_ALUOp <= 3'b001;\n            SW_OP: ID_EX_ALUOp <= 3'b010;\n            BEQ_OP: ID_EX_ALUOp <= 3'b100;\n        endcase\n        state <= ST_EX;\n    end else if (state == ST_EX) begin\n        ID_EX_A <= ID_EX_A_temp;\n        ID_EX_B <= ID_EX_B_temp;\n        case (ID_EX_ALUOp)\n            3'b000: ID_EX_IR <= {6'b000000, ID_EX_rs, ID_EX_rt, ID_EX_rd, 5'b00000, ID_EX_func};\n            3'b001: ID_EX_IR <= {6'b100011, ID_EX_rs, ID_EX_rt, ID_EX_imm};\n            3'b010: ID_EX_IR <= {6'b101011, ID_EX_rs, ID_EX_rt, ID_EX_imm};\n            3'b100: begin\n                if (ID_EX_A_temp == ID_EX_B_temp) begin\n                    ID_EX_Flush <= 1;\n                    ID_EX_NPC <= ID_EX_NPC + (ID_EX_imm << 2);\n                end else begin\n                    ID_EX_Flush <= 0;\n                    ID_EX_NPC <= ID_EX_NPC + 4;\n                end\n            end\n        endcase\n        state <= ST_IF;\n        if (PCSrc == 1 || ID_EX_Flush == 1) begin\n            PC <= EX_MEM_NPC;\n        end else begin\n            PC <= ID_EX_NPC;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (state == ST_EX) begin\n        case (ID_EX_ALUOp)\n            3'b000: reg_file[ID_EX_rd] <= ID_EX_A_temp + ID_EX_B_temp;\n            3'b001: reg_file[ID_EX_rt] <= mem[ID_EX_A_temp + ID_EX_imm];\n            3'b010: mem[ID_EX_A_temp + ID_EX_imm] <= ID_EX_B_temp;\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "pipeline_processor",
        "module_hash": "81d7f2fd1532f431e6dda35dfe61a744",
        "dataset_index": 15299
      },
      "idelay_ctrl_rdy__7a1d3368": {
        "rtl_code": "module idelay_ctrl_rdy_module (\n   input  clk200,\n   input  rst200,\n   output idelay_ctrl_rdy\n   );\n\n   wire idelay_ctrl_rdy_x0y5;\n   wire idelay_ctrl_rdy_x0y6;\n\n  IDELAYCTRL  u_idelayctrl_x0y5\n    (\n     .RDY(idelay_ctrl_rdy_x0y5),\n     .REFCLK(clk200),\n     .RST(rst200)\n    );\n\n  IDELAYCTRL u_idelayctrl_x0y6\n    (\n     .RDY(idelay_ctrl_rdy_x0y6),\n     .REFCLK(clk200),\n     .RST(rst200)\n    );\n\n   assign idelay_ctrl_rdy = idelay_ctrl_rdy_x0y5 & idelay_ctrl_rdy_x0y6;\n\nendmodule \nmodule IDELAYCTRL (\n   input  REFCLK,\n   input  RST,\n   output RDY\n   );\n\n   reg delay_rdy;\n\n   always @ (posedge REFCLK or posedge RST) begin\n      if (RST) begin\n         delay_rdy <= 1'b0;\n      end else begin\n         delay_rdy <= 1'b1;\n      end\n   end\n\n   assign RDY = delay_rdy;\n\nendmodule",
        "module_name": "idelay_ctrl_rdy_",
        "module_hash": "7a1d3368f15207791c03fc8119c0dae4",
        "dataset_index": 4997
      },
      "output_demux #_d8415ab9": {
        "rtl_code": "\nmodule output_demux #(parameter C_FSM_SWITCH_WIDTH=20, C_INTERFACE=0)(\n    input [4:0] sel,\n    input in_pin,\n    output reg [C_FSM_SWITCH_WIDTH-1:0] out_pin\n    );\n    \n    generate\n    case (C_INTERFACE)\n       0: begin: ARDUINO\n                 always @(sel, in_pin)\n                   begin\n                       out_pin = 20'h00000;\n                       case(sel)\n                           5'h00 : out_pin[0] = in_pin;\n                           5'h01 : out_pin[1] = in_pin;\n                           5'h02 : out_pin[2] = in_pin;\n                           5'h03 : out_pin[3] = in_pin;\n                           5'h04 : out_pin[4] = in_pin;\n                           5'h05 : out_pin[5] = in_pin;\n                           5'h06 : out_pin[6] = in_pin;\n                           5'h07 : out_pin[7] = in_pin;\n                           5'h08 : out_pin[8] = in_pin;\n                           5'h09 : out_pin[9] = in_pin;\n                           5'h0A : out_pin[10] = in_pin;\n                           5'h0B : out_pin[11] = in_pin;\n                           5'h0C : out_pin[12] = in_pin;\n                           5'h0D : out_pin[13] = in_pin;\n                           5'h0E : out_pin[14] = in_pin;\n                           5'h0F : out_pin[15] = in_pin;\n                           5'h10 : out_pin[16] = in_pin;\n                           5'h11 : out_pin[17] = in_pin;\n                           5'h12 : out_pin[18] = in_pin;\n                           5'h13 : out_pin[19] = in_pin;\n                       endcase\n                   end\n                 end\n       1: begin: RASPBERRYPI\n                 always @(sel, in_pin)\n                   begin\n                       out_pin = 26'h00000;\n                       case(sel)\n                           5'h00 : out_pin[0] = in_pin;\n                           5'h01 : out_pin[1] = in_pin;\n                           5'h02 : out_pin[2] = in_pin;\n                           5'h03 : out_pin[3] = in_pin;\n                           5'h04 : out_pin[4] = in_pin;\n                           5'h05 : out_pin[5] = in_pin;\n                           5'h06 : out_pin[6] = in_pin;\n                           5'h07 : out_pin[7] = in_pin;\n                           5'h08 : out_pin[8] = in_pin;\n                           5'h09 : out_pin[9] = in_pin;\n                           5'h0A : out_pin[10] = in_pin;\n                           5'h0B : out_pin[11] = in_pin;\n                           5'h0C : out_pin[12] = in_pin;\n                           5'h0D : out_pin[13] = in_pin;\n                           5'h0E : out_pin[14] = in_pin;\n                           5'h0F : out_pin[15] = in_pin;\n                           5'h10 : out_pin[16] = in_pin;\n                           5'h11 : out_pin[17] = in_pin;\n                           5'h12 : out_pin[18] = in_pin;\n                           5'h13 : out_pin[19] = in_pin;\n                           5'h14 : out_pin[20] = in_pin;\n                           5'h15 : out_pin[21] = in_pin;\n                           5'h16 : out_pin[22] = in_pin;\n                           5'h17 : out_pin[23] = in_pin;\n                           5'h18 : out_pin[24] = in_pin;\n                           5'h19 : out_pin[25] = in_pin;\n                       endcase\n                   end\n                  end\n       default: begin: ARDUINO\n                       always @(sel, in_pin)\n                       begin\n                           out_pin = 20'h00000;\n                           case(sel)\n                               5'h00 : out_pin[0] = in_pin;\n                               5'h01 : out_pin[1] = in_pin;\n                               5'h02 : out_pin[2] = in_pin;\n                               5'h03 : out_pin[3] = in_pin;\n                               5'h04 : out_pin[4] = in_pin;\n                               5'h05 : out_pin[5] = in_pin;\n                               5'h06 : out_pin[6] = in_pin;\n                               5'h07 : out_pin[7] = in_pin;\n                               5'h08 : out_pin[8] = in_pin;\n                               5'h09 : out_pin[9] = in_pin;\n                               5'h0A : out_pin[10] = in_pin;\n                               5'h0B : out_pin[11] = in_pin;\n                               5'h0C : out_pin[12] = in_pin;\n                               5'h0D : out_pin[13] = in_pin;\n                               5'h0E : out_pin[14] = in_pin;\n                               5'h0F : out_pin[15] = in_pin;\n                               5'h10 : out_pin[16] = in_pin;\n                               5'h11 : out_pin[17] = in_pin;\n                               5'h12 : out_pin[18] = in_pin;\n                               5'h13 : out_pin[19] = in_pin;\n                           endcase\n                       end\n                end\n    endcase\n    endgenerate\n\n\nendmodule\n",
        "module_name": "output_demux #",
        "module_hash": "d8415ab901bb0e4508f445137b9a2a92",
        "dataset_index": 25297
      },
      "Ripple_Carry_Adder_526c5afd": {
        "rtl_code": "module Ripple_Carry_Adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] sum;  //intermediate sum bits\n  wire [3:0] carry;  //intermediate carry bits\n\n  //full adder for least significant bit\n  Full_Adder FA0 (\n    .A(A[0]),\n    .B(B[0]),\n    .Cin(Cin),\n    .S(sum[0]),\n    .Cout(carry[0])\n  );\n\n  //full adder for second least significant bit\n  Full_Adder FA1 (\n    .A(A[1]),\n    .B(B[1]),\n    .Cin(carry[0]),\n    .S(sum[1]),\n    .Cout(carry[1])\n  );\n\n  //full adder for third least significant bit\n  Full_Adder FA2 (\n    .A(A[2]),\n    .B(B[2]),\n    .Cin(carry[1]),\n    .S(sum[2]),\n    .Cout(carry[2])\n  );\n\n  //full adder for most significant bit\n  Full_Adder FA3 (\n    .A(A[3]),\n    .B(B[3]),\n    .Cin(carry[2]),\n    .S(sum[3]),\n    .Cout(Cout)\n  );\n\n  assign S = sum;  //output sum bits\n\nendmodule\n\n//full adder module\nmodule Full_Adder(\n  input A,\n  input B,\n  input Cin,\n  output S,\n  output Cout\n);\n\n  assign S = A ^ B ^ Cin;  //XOR of inputs\n  assign Cout = (A & B) | (Cin & (A ^ B));  //OR of ANDs\n\nendmodule",
        "module_name": "Ripple_Carry_Adder",
        "module_hash": "526c5afdecf5a9469b77fa88ae9ea750",
        "dataset_index": 5888
      },
      "mux8_bf34adfb": {
        "rtl_code": "module mux8\n  #(parameter WIDTH=32, parameter DISABLED=0)\n    (input en,\n     input [2:0] sel,\n     input [WIDTH-1:0] i0,\n     input [WIDTH-1:0] i1,\n     input [WIDTH-1:0] i2,\n     input [WIDTH-1:0] i3,\n     input [WIDTH-1:0] i4,\n     input [WIDTH-1:0] i5,\n     input [WIDTH-1:0] i6,\n     input [WIDTH-1:0] i7,\n     output [WIDTH-1:0] o);\n\n   assign \t\to = en ? (sel[2] ? (sel[1] ? (sel[0] ? i7 : i6) : (sel[0] ? i5 : i4)) :\n\t\t\t\t  (sel[1] ? (sel[0] ? i3 : i2) : (sel[0] ? i1 : i0))) :\n\t\t\tDISABLED;\n   \nendmodule ",
        "module_name": "mux8",
        "module_hash": "bf34adfbea3506c1a426520dc5a24ee6",
        "dataset_index": 24099
      },
      "ff_sub_1c9e57cb": {
        "rtl_code": "\n\nmodule ff_sub (\n\tinput clk,\n\tinput reset,\n\tinput [255:0] rx_a,\n\tinput [255:0] rx_b,\n\tinput [255:0] rx_p,\n\toutput reg tx_done = 1'b0,\n\toutput reg [255:0] tx_a = 256'd0\n);\n\n\treg carry;\n\n\talways @ (posedge clk)\n\tbegin\n\t\tif (!tx_done)\n\t\tbegin\n\t\t\tif (carry)\n\t\t\t\ttx_a <= tx_a + rx_p;\n\t\t\ttx_done <= 1'b1;\n\t\tend\n\n\t\tif (reset)\n\t\tbegin\n\t\t\t{carry, tx_a} <= rx_a - rx_b;\n\t\t\ttx_done <= 1'b0;\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "ff_sub",
        "module_hash": "1c9e57cb2bbe525ee50e50bcf9fac24c",
        "dataset_index": 2307
      },
      "unknown_module_1f07829e": {
        "rtl_code": "\nmodule\tzipdiv(i_clk, i_reset, i_wr, i_signed, i_numerator, i_denominator,\n\t\to_busy, o_valid, o_err, o_quotient, o_flags);\n\tparameter\t\tBW=32, LGBW = 5;\n\tinput\twire\t\ti_clk, i_reset;\n\tinput\twire\t\ti_wr, i_signed;\n\tinput\twire [(BW-1):0]\ti_numerator, i_denominator;\n\toutput\treg\t\to_busy, o_valid, o_err;\n\toutput\treg [(BW-1):0]\to_quotient;\n\toutput\twire\t[3:0]\to_flags;\n\n\treg\t\t\tr_busy;\n\treg\t[(2*BW-2):0]\tr_divisor;\n\treg\t[(BW-1):0]\tr_dividend;\n\twire\t[(BW):0]\tdiff; assign\tdiff = r_dividend - r_divisor[(BW-1):0];\n\n\treg\t\tr_sign, pre_sign, r_z, r_c, last_bit;\n\treg\t[(LGBW-1):0]\tr_bit;\n\treg\tzero_divisor;\n\n\tinitial\tr_busy = 1'b0;\n\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tr_busy <= 1'b0;\n\t\telse if (i_wr)\n\t\t\tr_busy <= 1'b1;\n\t\telse if ((last_bit)||(zero_divisor))\n\t\t\tr_busy <= 1'b0;\n\n\tinitial\to_busy = 1'b0;\n\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\to_busy <= 1'b0;\n\t\telse if (i_wr)\n\t\t\to_busy <= 1'b1;\n\t\telse if (((last_bit)&&(!r_sign))||(zero_divisor))\n\t\t\to_busy <= 1'b0;\n\t\telse if (!r_busy)\n\t\t\to_busy <= 1'b0;\n\n\tinitial\tzero_divisor = 1'b0;\n\talways @(posedge i_clk)\n\t\tif (i_reset)\n\t\t\tzero_divisor <= 1'b0;\n\t\telse if (i_wr)\n\t\t\tzero_divisor <= (i_denominator == 0);\n\t\telse if (!r_busy)\n\t\t\tzero_divisor <= 1'b0;\n\n\tinitial\to_valid = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_valid <= 1'b0;\n\telse if (r_busy)\n\tbegin\n\t\tif ((last_bit)||(zero_divisor))\n\t\t\to_valid <= (zero_divisor)||(!r_sign);\n\tend else if (r_sign)\n\tbegin\n\t\to_valid <= (!zero_divisor); end else\n\t\to_valid <= 1'b0;\n\n\tinitial\to_err = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_err <= 1'b0;\n\telse if (o_valid)\n\t\to_err <= 1'b0;\n\telse if (((r_busy)||(r_sign))&&(zero_divisor))\n\t\to_err <= 1'b1;\n\telse\n\t\to_err <= 1'b0;\n\n\tinitial\tr_bit = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_bit <= 0;\n\telse if ((r_busy)&&(!pre_sign))\n\t\tr_bit <= r_bit + 1'b1;\n\telse\n\t\tr_bit <= 0;\n\n\tinitial\tlast_bit = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tlast_bit <= 1'b0;\n\telse if (r_busy)\n\t\tlast_bit <= (r_bit == {(LGBW){1'b1}}-1'b1);\n\telse\n\t\tlast_bit <= 1'b0;\n\n\tinitial\tpre_sign = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tpre_sign <= 1'b0;\n\telse if (i_wr)\n\t\tpre_sign <= (i_signed)&&((i_numerator[BW-1])||(i_denominator[BW-1]));\n\telse\n\t\tpre_sign <= 1'b0;\n\n\tinitial\tr_z = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_z <= 1'b0;\n\telse if((r_busy)&&(r_divisor[(2*BW-2):(BW)] == 0)&&(!diff[BW]))\n\t\t\tr_z <= 1'b0;\n\telse if (i_wr)\n\t\tr_z <= 1'b1;\n\n\tinitial\tr_dividend = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_dividend <= 0;\n\telse if (pre_sign)\n\tbegin\n\t\tif (r_dividend[BW-1])\n\t\t\tr_dividend <= -r_dividend;\n\t\tend else if((r_busy)&&(r_divisor[(2*BW-2):(BW)]==0)&&(!diff[BW]))\n\t\tr_dividend <= diff[(BW-1):0];\n\telse if (!r_busy)\n\t\tr_dividend <=  i_numerator;\n\n\tinitial\tr_divisor = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_divisor <= 0;\n\telse if (pre_sign)\n\tbegin\n\t\tif (r_divisor[(2*BW-2)])\n\t\t\tr_divisor[(2*BW-2):(BW-1)]\n\t\t\t\t<= -r_divisor[(2*BW-2):(BW-1)];\n\tend else if (r_busy)\n\t\tr_divisor <= { 1'b0, r_divisor[(2*BW-2):1] };\n\telse\n\t\tr_divisor <= {  i_denominator, {(BW-1){1'b0}} };\n\n\tinitial\tr_sign = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_sign <= 1'b0;\n\telse if (pre_sign)\n\t\tr_sign <= ((r_divisor[(2*BW-2)])^(r_dividend[(BW-1)]));\n\telse if (r_busy)\n\t\tr_sign <= (r_sign)&&(!zero_divisor);\n\telse\n\t\tr_sign <= 1'b0;\n\n\tinitial\to_quotient = 0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\to_quotient <= 0;\n\telse if (r_busy)\n\tbegin\n\t\to_quotient <= { o_quotient[(BW-2):0], 1'b0 };\n\t\tif ((r_divisor[(2*BW-2):(BW)] == 0)&&(!diff[BW]))\n\t\t\to_quotient[0] <= 1'b1;\n\tend else if (r_sign)\n\t\to_quotient <= -o_quotient;\n\telse\n\t\to_quotient <= 0;\n\n\tinitial\tr_c = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tr_c <= 1'b0;\n\telse\n\t\tr_c <= (r_busy)&&((diff == 0)||(r_dividend == 0));\n\n\twire\tw_n;\n\tassign w_n = o_quotient[(BW-1)];\n\n\tassign o_flags = { 1'b0, w_n, r_c, r_z };\n\n`ifdef\tFORMAL\n\treg\tf_past_valid;\n\tinitial\tf_past_valid = 0;\n\talways @(posedge i_clk)\n\t\tf_past_valid <= 1'b1;\n\n`ifdef\tDIV\n`define\tASSUME\tassume\n`else\n`define\tASSUME\tassert\n`endif\n\n\tinitial\t`ASSUME(i_reset);\n\talways @(*)\n\tif (!f_past_valid)\n\t\t`ASSUME(i_reset);\n\n\talways @(posedge i_clk)\n\tif ((!f_past_valid)||($past(i_reset)))\n\tbegin\n\t\tassert(!o_busy);\n\t\tassert(!o_valid);\n\t\tassert(!o_err);\n\t\tassert(!r_busy);\n\t\tassert(!zero_divisor);\n\t\tassert(r_bit==0);\n\t\tassert(!last_bit);\n\t\tassert(!pre_sign);\n\t\tassert(!r_z);\n\t\tassert(r_dividend==0);\n\t\tassert(o_quotient==0);\n\t\tassert(!r_c);\n\t\tassert(r_divisor==0);\n\n\t\t`ASSUME(!i_wr);\n\tend\n\n\talways @(*)\n\tif (o_busy)\n\t\t`ASSUME(!i_wr);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(o_busy))&&(!o_busy))\n\tbegin\n\t\tassert(o_valid);\n\tend\n\n\talways @(*)\n\tif (o_err)\n\t\tassert(o_valid);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_wr)))\n\t\tassert(!pre_sign);\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr))&&($past(i_signed))\n\t\t\t&&(|$past({i_numerator[BW-1],i_denominator[BW-1]})))\n\t\tassert(pre_sign);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(i_wr)))\n\t\tassert(o_busy);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&($past(o_valid)))\n\t\tassert(!o_valid);\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\t\tassert(r_z == ((o_quotient == 0)? 1'b1:1'b0));\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\t\tassert(w_n == o_quotient[BW-1]);\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(r_busy))&&(!$past(i_wr)))\n\t\tassert(!o_busy);\n\talways @(posedge i_clk)\n\t\tassert((!o_busy)||(!o_valid));\n\talways @(posedge i_clk)\n\tif(o_busy) `ASSUME(!i_wr);\n\talways @(*)\n\t\tif(r_busy) assert(o_busy);\n\n\treg\t[BW:0]\tf_bits_set;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tf_bits_set <= 0;\n\telse if (i_wr)\n\t\tf_bits_set <= 0;\n\telse if ((r_busy)&&(!pre_sign))\n\t\tf_bits_set <= { f_bits_set[BW-1:0], 1'b1 };\n\n\talways @(*)\n\tif ((o_valid)&&(!o_err))\n\t\tassert((!f_bits_set[BW])&&(&f_bits_set[BW-1:0]));\n\n\n\talways @(posedge i_clk)\n\tif ((f_past_valid)&&(!$past(i_reset))&&($past(r_busy))\n\t\t&&($past(r_divisor[2*BW-2:BW])==0))\n\tbegin\n\t\tif ($past(r_divisor) == 0)\n\t\t\tassert(o_err);\n\t\telse if ($past(pre_sign))\n\t\tbegin\n\t\t\tif ($past(r_dividend[BW-1]))\n\t\t\t\tassert(r_dividend == -$past(r_dividend));\n\t\t\tif ($past(r_divisor[(2*BW-2)]))\n\t\t\tbegin\n\t\t\t\tassert(r_divisor[(2*BW-2):(BW-1)]\n\t\t\t\t\t== -$past(r_divisor[(2*BW-2):(BW-1)]));\n\t\t\t\tassert(r_divisor[BW-2:0] == 0);\n\t\t\tend\n\t\tend else begin\n\t\t\tif (o_quotient[0])\n\t\t\t\tassert(r_dividend == $past(diff));\n\t\t\telse\n\t\t\t\tassert(r_dividend == $past(r_dividend));\n\n\t\t\tassert(r_divisor[2*BW-2]==0);\n\t\t\tassert(r_divisor[2*BW-3:0]==$past(r_divisor[2*BW-2:1]));\n\t\tend\n\t\tif ($past(r_dividend) >= $past(r_divisor[BW-1:0]))\n\t\t\tassert(o_quotient[0]);\n\t\telse\n\t\t\tassert(!o_quotient[0]);\n\tend\n`endif\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "1f07829e25dd377189178b93e00eb8f6",
        "dataset_index": 11492
      },
      "jt12_logsin_73f9185b": {
        "rtl_code": "\n\nmodule jt12_logsin\n(\n    input [7:0] addr,\n    input clk, \n    input clk_en,\n    output reg [11:0] logsin\n);  \n\nreg [11:0] sinelut[255:0];\ninitial begin\n\tsinelut[8'd000] = 12'h000;\n\tsinelut[8'd001] = 12'h000;\n\tsinelut[8'd002] = 12'h000;\n\tsinelut[8'd003] = 12'h000;\n\tsinelut[8'd004] = 12'h000;\n\tsinelut[8'd005] = 12'h000;\n\tsinelut[8'd006] = 12'h000;\n\tsinelut[8'd007] = 12'h000;\n\tsinelut[8'd008] = 12'h001;\n\tsinelut[8'd009] = 12'h001;\n\tsinelut[8'd010] = 12'h001;\n\tsinelut[8'd011] = 12'h001;\n\tsinelut[8'd012] = 12'h001;\n\tsinelut[8'd013] = 12'h001;\n\tsinelut[8'd014] = 12'h001;\n\tsinelut[8'd015] = 12'h002;\n\tsinelut[8'd016] = 12'h002;\n\tsinelut[8'd017] = 12'h002;\n\tsinelut[8'd018] = 12'h002;\n\tsinelut[8'd019] = 12'h003;\n\tsinelut[8'd020] = 12'h003;\n\tsinelut[8'd021] = 12'h003;\n\tsinelut[8'd022] = 12'h004;\n\tsinelut[8'd023] = 12'h004;\n\tsinelut[8'd024] = 12'h004;\n\tsinelut[8'd025] = 12'h005;\n\tsinelut[8'd026] = 12'h005;\n\tsinelut[8'd027] = 12'h005;\n\tsinelut[8'd028] = 12'h006;\n\tsinelut[8'd029] = 12'h006;\n\tsinelut[8'd030] = 12'h007;\n\tsinelut[8'd031] = 12'h007;\n\tsinelut[8'd032] = 12'h007;\n\tsinelut[8'd033] = 12'h008;\n\tsinelut[8'd034] = 12'h008;\n\tsinelut[8'd035] = 12'h009;\n\tsinelut[8'd036] = 12'h009;\n\tsinelut[8'd037] = 12'h00a;\n\tsinelut[8'd038] = 12'h00a;\n\tsinelut[8'd039] = 12'h00b;\n\tsinelut[8'd040] = 12'h00c;\n\tsinelut[8'd041] = 12'h00c;\n\tsinelut[8'd042] = 12'h00d;\n\tsinelut[8'd043] = 12'h00d;\n\tsinelut[8'd044] = 12'h00e;\n\tsinelut[8'd045] = 12'h00f;\n\tsinelut[8'd046] = 12'h00f;\n\tsinelut[8'd047] = 12'h010;\n\tsinelut[8'd048] = 12'h011;\n\tsinelut[8'd049] = 12'h011;\n\tsinelut[8'd050] = 12'h012;\n\tsinelut[8'd051] = 12'h013;\n\tsinelut[8'd052] = 12'h014;\n\tsinelut[8'd053] = 12'h014;\n\tsinelut[8'd054] = 12'h015;\n\tsinelut[8'd055] = 12'h016;\n\tsinelut[8'd056] = 12'h017;\n\tsinelut[8'd057] = 12'h017;\n\tsinelut[8'd058] = 12'h018;\n\tsinelut[8'd059] = 12'h019;\n\tsinelut[8'd060] = 12'h01a;\n\tsinelut[8'd061] = 12'h01b;\n\tsinelut[8'd062] = 12'h01c;\n\tsinelut[8'd063] = 12'h01d;\n\tsinelut[8'd064] = 12'h01e;\n\tsinelut[8'd065] = 12'h01f;\n\tsinelut[8'd066] = 12'h020;\n\tsinelut[8'd067] = 12'h021;\n\tsinelut[8'd068] = 12'h022;\n\tsinelut[8'd069] = 12'h023;\n\tsinelut[8'd070] = 12'h024;\n\tsinelut[8'd071] = 12'h025;\n\tsinelut[8'd072] = 12'h026;\n\tsinelut[8'd073] = 12'h027;\n\tsinelut[8'd074] = 12'h028;\n\tsinelut[8'd075] = 12'h029;\n\tsinelut[8'd076] = 12'h02a;\n\tsinelut[8'd077] = 12'h02b;\n\tsinelut[8'd078] = 12'h02d;\n\tsinelut[8'd079] = 12'h02e;\n\tsinelut[8'd080] = 12'h02f;\n\tsinelut[8'd081] = 12'h030;\n\tsinelut[8'd082] = 12'h031;\n\tsinelut[8'd083] = 12'h033;\n\tsinelut[8'd084] = 12'h034;\n\tsinelut[8'd085] = 12'h035;\n\tsinelut[8'd086] = 12'h037;\n\tsinelut[8'd087] = 12'h038;\n\tsinelut[8'd088] = 12'h039;\n\tsinelut[8'd089] = 12'h03b;\n\tsinelut[8'd090] = 12'h03c;\n\tsinelut[8'd091] = 12'h03e;\n\tsinelut[8'd092] = 12'h03f;\n\tsinelut[8'd093] = 12'h040;\n\tsinelut[8'd094] = 12'h042;\n\tsinelut[8'd095] = 12'h043;\n\tsinelut[8'd096] = 12'h045;\n\tsinelut[8'd097] = 12'h046;\n\tsinelut[8'd098] = 12'h048;\n\tsinelut[8'd099] = 12'h04a;\n\tsinelut[8'd100] = 12'h04b;\n\tsinelut[8'd101] = 12'h04d;\n\tsinelut[8'd102] = 12'h04e;\n\tsinelut[8'd103] = 12'h050;\n\tsinelut[8'd104] = 12'h052;\n\tsinelut[8'd105] = 12'h053;\n\tsinelut[8'd106] = 12'h055;\n\tsinelut[8'd107] = 12'h057;\n\tsinelut[8'd108] = 12'h059;\n\tsinelut[8'd109] = 12'h05b;\n\tsinelut[8'd110] = 12'h05c;\n\tsinelut[8'd111] = 12'h05e;\n\tsinelut[8'd112] = 12'h060;\n\tsinelut[8'd113] = 12'h062;\n\tsinelut[8'd114] = 12'h064;\n\tsinelut[8'd115] = 12'h066;\n\tsinelut[8'd116] = 12'h068;\n\tsinelut[8'd117] = 12'h06a;\n\tsinelut[8'd118] = 12'h06c;\n\tsinelut[8'd119] = 12'h06e;\n\tsinelut[8'd120] = 12'h070;\n\tsinelut[8'd121] = 12'h072;\n\tsinelut[8'd122] = 12'h074;\n\tsinelut[8'd123] = 12'h076;\n\tsinelut[8'd124] = 12'h078;\n\tsinelut[8'd125] = 12'h07a;\n\tsinelut[8'd126] = 12'h07d;\n\tsinelut[8'd127] = 12'h07f;\n\tsinelut[8'd128] = 12'h081;\n\tsinelut[8'd129] = 12'h083;\n\tsinelut[8'd130] = 12'h086;\n\tsinelut[8'd131] = 12'h088;\n\tsinelut[8'd132] = 12'h08a;\n\tsinelut[8'd133] = 12'h08d;\n\tsinelut[8'd134] = 12'h08f;\n\tsinelut[8'd135] = 12'h092;\n\tsinelut[8'd136] = 12'h094;\n\tsinelut[8'd137] = 12'h097;\n\tsinelut[8'd138] = 12'h099;\n\tsinelut[8'd139] = 12'h09c;\n\tsinelut[8'd140] = 12'h09f;\n\tsinelut[8'd141] = 12'h0a1;\n\tsinelut[8'd142] = 12'h0a4;\n\tsinelut[8'd143] = 12'h0a7;\n\tsinelut[8'd144] = 12'h0a9;\n\tsinelut[8'd145] = 12'h0ac;\n\tsinelut[8'd146] = 12'h0af;\n\tsinelut[8'd147] = 12'h0b2;\n\tsinelut[8'd148] = 12'h0b5;\n\tsinelut[8'd149] = 12'h0b8;\n\tsinelut[8'd150] = 12'h0bb;\n\tsinelut[8'd151] = 12'h0be;\n\tsinelut[8'd152] = 12'h0c1;\n\tsinelut[8'd153] = 12'h0c4;\n\tsinelut[8'd154] = 12'h0c7;\n\tsinelut[8'd155] = 12'h0ca;\n\tsinelut[8'd156] = 12'h0cd;\n\tsinelut[8'd157] = 12'h0d1;\n\tsinelut[8'd158] = 12'h0d4;\n\tsinelut[8'd159] = 12'h0d7;\n\tsinelut[8'd160] = 12'h0db;\n\tsinelut[8'd161] = 12'h0de;\n\tsinelut[8'd162] = 12'h0e2;\n\tsinelut[8'd163] = 12'h0e5;\n\tsinelut[8'd164] = 12'h0e9;\n\tsinelut[8'd165] = 12'h0ec;\n\tsinelut[8'd166] = 12'h0f0;\n\tsinelut[8'd167] = 12'h0f4;\n\tsinelut[8'd168] = 12'h0f8;\n\tsinelut[8'd169] = 12'h0fb;\n\tsinelut[8'd170] = 12'h0ff;\n\tsinelut[8'd171] = 12'h103;\n\tsinelut[8'd172] = 12'h107;\n\tsinelut[8'd173] = 12'h10b;\n\tsinelut[8'd174] = 12'h10f;\n\tsinelut[8'd175] = 12'h114;\n\tsinelut[8'd176] = 12'h118;\n\tsinelut[8'd177] = 12'h11c;\n\tsinelut[8'd178] = 12'h121;\n\tsinelut[8'd179] = 12'h125;\n\tsinelut[8'd180] = 12'h129;\n\tsinelut[8'd181] = 12'h12e;\n\tsinelut[8'd182] = 12'h133;\n\tsinelut[8'd183] = 12'h137;\n\tsinelut[8'd184] = 12'h13c;\n\tsinelut[8'd185] = 12'h141;\n\tsinelut[8'd186] = 12'h146;\n\tsinelut[8'd187] = 12'h14b;\n\tsinelut[8'd188] = 12'h150;\n\tsinelut[8'd189] = 12'h155;\n\tsinelut[8'd190] = 12'h15b;\n\tsinelut[8'd191] = 12'h160;\n\tsinelut[8'd192] = 12'h166;\n\tsinelut[8'd193] = 12'h16b;\n\tsinelut[8'd194] = 12'h171;\n\tsinelut[8'd195] = 12'h177;\n\tsinelut[8'd196] = 12'h17c;\n\tsinelut[8'd197] = 12'h182;\n\tsinelut[8'd198] = 12'h188;\n\tsinelut[8'd199] = 12'h18f;\n\tsinelut[8'd200] = 12'h195;\n\tsinelut[8'd201] = 12'h19b;\n\tsinelut[8'd202] = 12'h1a2;\n\tsinelut[8'd203] = 12'h1a9;\n\tsinelut[8'd204] = 12'h1b0;\n\tsinelut[8'd205] = 12'h1b7;\n\tsinelut[8'd206] = 12'h1be;\n\tsinelut[8'd207] = 12'h1c5;\n\tsinelut[8'd208] = 12'h1cd;\n\tsinelut[8'd209] = 12'h1d4;\n\tsinelut[8'd210] = 12'h1dc;\n\tsinelut[8'd211] = 12'h1e4;\n\tsinelut[8'd212] = 12'h1ec;\n\tsinelut[8'd213] = 12'h1f5;\n\tsinelut[8'd214] = 12'h1fd;\n\tsinelut[8'd215] = 12'h206;\n\tsinelut[8'd216] = 12'h20f;\n\tsinelut[8'd217] = 12'h218;\n\tsinelut[8'd218] = 12'h222;\n\tsinelut[8'd219] = 12'h22c;\n\tsinelut[8'd220] = 12'h236;\n\tsinelut[8'd221] = 12'h240;\n\tsinelut[8'd222] = 12'h24b;\n\tsinelut[8'd223] = 12'h256;\n\tsinelut[8'd224] = 12'h261;\n\tsinelut[8'd225] = 12'h26d;\n\tsinelut[8'd226] = 12'h279;\n\tsinelut[8'd227] = 12'h286;\n\tsinelut[8'd228] = 12'h293;\n\tsinelut[8'd229] = 12'h2a0;\n\tsinelut[8'd230] = 12'h2af;\n\tsinelut[8'd231] = 12'h2bd;\n\tsinelut[8'd232] = 12'h2cd;\n\tsinelut[8'd233] = 12'h2dc;\n\tsinelut[8'd234] = 12'h2ed;\n\tsinelut[8'd235] = 12'h2ff;\n\tsinelut[8'd236] = 12'h311;\n\tsinelut[8'd237] = 12'h324;\n\tsinelut[8'd238] = 12'h339;\n\tsinelut[8'd239] = 12'h34e;\n\tsinelut[8'd240] = 12'h365;\n\tsinelut[8'd241] = 12'h37e;\n\tsinelut[8'd242] = 12'h398;\n\tsinelut[8'd243] = 12'h3b5;\n\tsinelut[8'd244] = 12'h3d3;\n\tsinelut[8'd245] = 12'h3f5;\n\tsinelut[8'd246] = 12'h41a;\n\tsinelut[8'd247] = 12'h443;\n\tsinelut[8'd248] = 12'h471;\n\tsinelut[8'd249] = 12'h4a6;\n\tsinelut[8'd250] = 12'h4e4;\n\tsinelut[8'd251] = 12'h52e;\n\tsinelut[8'd252] = 12'h58b;\n\tsinelut[8'd253] = 12'h607;\n\tsinelut[8'd254] = 12'h6c3;\n\tsinelut[8'd255] = 12'h859;\nend\n\n    always @ (posedge clk) if(clk_en)\n        logsin <= sinelut[addr];\n\nendmodule\n",
        "module_name": "jt12_logsin",
        "module_hash": "73f9185bde2292d892e321cf3ccf570a",
        "dataset_index": 23169
      },
      "binary_to_bcd_converter_9f041db0": {
        "rtl_code": "module binary_to_bcd_converter (\n    input [3:0] binary_in,\n    output reg [3:0] bcd_out,\n    output reg greater_than_nine\n);\n    \n    always @(*) begin\n        case (binary_in)\n            4'b0000: bcd_out = 4'b0000;\n            4'b0001: bcd_out = 4'b0001;\n            4'b0010: bcd_out = 4'b0010;\n            4'b0011: bcd_out = 4'b0011;\n            4'b0100: bcd_out = 4'b0100;\n            4'b0101: bcd_out = 4'b0101;\n            4'b0110: bcd_out = 4'b0110;\n            4'b0111: bcd_out = 4'b0111;\n            4'b1000: bcd_out = 4'b1000;\n            4'b1001: bcd_out = 4'b0001;\n            4'b1010: bcd_out = 4'b0010;\n            4'b1011: bcd_out = 4'b0011;\n            4'b1100: bcd_out = 4'b0100;\n            4'b1101: bcd_out = 4'b0101;\n            4'b1110: bcd_out = 4'b0110;\n            4'b1111: bcd_out = 4'b0111;\n            default: bcd_out = 4'bxxxx;\n        endcase\n        \n        if (binary_in > 4'b1001) begin\n            greater_than_nine = 1;\n        end\n        else begin\n            greater_than_nine = 0;\n        end\n    end\n    \nendmodule",
        "module_name": "binary_to_bcd_converter",
        "module_hash": "9f041db07cfe36eb2f55771524e684c5",
        "dataset_index": 14649
      },
      "my__701a3cdf": {
        "rtl_code": "\nmodule my_module (i_0r0, i_0r1, i_0a, o_0r0, o_0r1, o_0a, reset);\n  input i_0r0;\n  input i_0r1;\n  output i_0a;\n  output o_0r0;\n  output o_0r1;\n  input o_0a;\n  input reset;\n\n  wire bna_0;\n  wire tech1_oint;\n  wire tech2_oint;\n  wire bcomp_0;\n\n  and (o_0r0, i_0r0, bna_0);\n  nand (tech1_oint, o_0r0, reset);\n  and (o_0r1, i_0r1, bna_0);\n  nand (tech2_oint, o_0r1, reset);\n\n  not (bna_0, o_0a);\n\n  or (bcomp_0, o_0r0, o_0r1);\n  buf (i_0a, bcomp_0);\nendmodule\n",
        "module_name": "my_",
        "module_hash": "701a3cdfc9071b7e7e5638d984923a25",
        "dataset_index": 4858
      },
      "top__d031ce8f": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    input up_down,    // Control input to select count direction\n    input [1:0] input_value, // 2-bit input for the functional module\n    output [1:0] output_value, // 2-bit output from the functional module\n    output [2:0] counter_output // 3-bit output from the counter\n);\n\nreg [2:0] counter;\nwire [1:0] sum;\nwire carry_out;\n\n// 3-bit binary counter with asynchronous reset\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        counter <= 3'b0;\n    end else begin\n        if (up_down) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= counter - 1;\n        end\n    end\nend\n\n// Functional module that adds the output of the counter and a 2-bit input value using only XOR and AND gates\nassign sum[0] = counter[0] ^ input_value[0];\nassign sum[1] = (counter[1] ^ input_value[1]) ^ (counter[0] & input_value[0]);\nassign carry_out = (counter[1] & input_value[1]) | (counter[0] & input_value[0]);\nassign output_value = sum;\n\n// Output signals\nassign counter_output = counter;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "d031ce8f19275d6280f40e6f78aa7906",
        "dataset_index": 12577
      },
      "rr_event_picker_7b627a47": {
        "rtl_code": "\nmodule rr_event_picker(\n  input rclk,\n  input grst_l,\n  input arst_l,\n  input si,\n  input se,\n  input [3:0] events,\n  input [3:0] events_picked,\n  input [3:0] thread_force,\n  output [3:0] pick_one_hot\n);\n\n  wire         clk;\n  wire         reset,dbb_reset_l ;\n  wire  [3:0]  thread_force_pe_mask ;\n  wire  [3:0]  pick_thread_force_1hot ;\n  wire         thread_force_events_sel ;\n  wire  [3:0]  pick_rrobin_1hot, pick_rev_rrobin_1hot, pick_rrobin_1hot_mx ;\n  wire         events_pick_dir_d1 ;\n  wire         events_pick_dir ;\n  wire  [3:0]  pick_rrobin_status_or_one_hot ;\n  wire  [3:0]  pick_rrobin_din ;\n  wire  [3:0]  pick_rrobin ;\n  wire         pick_rrobin_reset ;\n  wire         pick_rrobin_dir_upd ;\n  wire  [3:0]  pick_rrobin_events ;\n\n  reg         dbb_rstff_Q;\n  reg  [3:0]  pick_rrobin_inst_Q;\n  reg         events_pick_dir_inst_Q;\n\n  assign clk = rclk;\n\n  assign\treset =  ~dbb_reset_l;\n\n  assign\tthread_force_events_sel = |(events[3:0] & thread_force[3:0]) ;\n\n  assign  thread_force_pe_mask[3:0]  =  events[3:0] & thread_force[3:0] ;\n  assign\tpick_thread_force_1hot[0] = thread_force_pe_mask[0] ;\n  assign\tpick_thread_force_1hot[1] = thread_force_pe_mask[1] & ~thread_force_pe_mask[0] ;\n  assign\tpick_thread_force_1hot[2] = thread_force_pe_mask[2] & ~|thread_force_pe_mask[1:0] ;\n  assign\tpick_thread_force_1hot[3] = thread_force_pe_mask[3] & ~|thread_force_pe_mask[2:0] ;\n\n  assign  pick_rrobin_events[3:0]  =  events[3:0] & ~pick_rrobin[3:0] ;\n\n  assign  pick_rrobin_1hot[0] = ~events_pick_dir_d1 & pick_rrobin_events[0] ;\n  assign\tpick_rrobin_1hot[1] = ~events_pick_dir_d1 & pick_rrobin_events[1] & ~pick_rrobin_events[0] ;\n  assign\tpick_rrobin_1hot[2] = ~events_pick_dir_d1 & pick_rrobin_events[2] & ~|pick_rrobin_events[1:0] ;\n  assign\tpick_rrobin_1hot[3] = ~events_pick_dir_d1 & pick_rrobin_events[3] & ~|pick_rrobin_events[2:0] ;\n\n  assign  pick_rev_rrobin_1hot[0] = events_pick_dir_d1 & pick_rrobin_events[0] & ~|pick_rrobin_events[3:1] ;\n  assign\tpick_rev_rrobin_1hot[1] = events_pick_dir_d1 & pick_rrobin_events[1] & ~|pick_rrobin_events[3:2] ;\n  assign\tpick_rev_rrobin_1hot[2] = events_pick_dir_d1 & pick_rrobin_events[2] & ~|pick_rrobin_events[3] ;\n  assign\tpick_rev_rrobin_1hot[3] = events_pick_dir_d1 & pick_rrobin_events[3] ;\n\n  assign  pick_rrobin_1hot_mx[3:0]  =  pick_rev_rrobin_1hot[3:0] | pick_rrobin_1hot[3:0] ;\n  assign  pick_one_hot[3:0]    =  thread_force_events_sel ? pick_thread_force_1hot[3:0] : \n                                                          pick_rrobin_1hot_mx[3:0] ;\n\n  assign pick_rrobin_status_or_one_hot[3:0] = pick_rrobin[3:0] | events_picked[3:0] ;\n  assign pick_rrobin_reset = reset | ~|(events[3:0] & ~pick_rrobin_status_or_one_hot[3:0]) ;\n  assign pick_rrobin_dir_upd = |events[3:0] & (~|(events[3:0] & ~pick_rrobin_status_or_one_hot[3:0])) ;\n\n  assign events_pick_dir  =  ~reset &\n                           (( ~pick_rrobin_dir_upd & events_pick_dir_d1) |\t\t//hold\n                            (  pick_rrobin_dir_upd & ~events_pick_dir_d1)) ;\t\t//set - invert direction\n   \n  always @(posedge clk) begin\n    dbb_rstff_Q <= (~arst_l | grst_l) & (dbb_rstff_Q & ~se);\n  end\n  assign dbb_reset_l = dbb_rstff_Q;\n\n  always @(posedge clk) begin\n    if (~reset) begin\n      pick_rrobin_inst_Q <= 4'b0;\n    end else begin\n      pick_rrobin_inst_Q <= pick_rrobin_din;\n    end\n  end\n  assign pick_rrobin = pick_rrobin_inst_Q;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      events_pick_dir_inst_Q <= 1'b0;\n    end else begin\n      events_pick_dir_inst_Q <= events_pick_dir;\n    end\n  end\n  assign events_pick_dir_d1 = events_pick_dir_inst_Q;\n\n  assign pick_rrobin_din[3:0] = pick_rrobin_reset ? 4'b0 :\n                              (pick_rrobin_dir_upd ? {pick_rrobin_events[2:0], pick_rrobin_events[3]} :\n                              pick_rrobin_events) ;\nendmodule\n",
        "module_name": "rr_event_picker",
        "module_hash": "7b627a471f1217f09c462e57e0cbb1e0",
        "dataset_index": 15878
      },
      "gps_6698a99c": {
        "rtl_code": "\nmodule gps (\n  input clk,\n  input rst,\n  input sat_data,\n  input antenna_data,\n  output reg [31:0] lat,\n  output reg [31:0] lon,\n  output reg [31:0] alt\n);\n\n  // Internal signals and registers\n  reg [31:0] local_clock;\n  reg [31:0] satellite_position;\n  reg [31:0] receiver_position;\n  reg [31:0] navigation_data;\n\n  // Acquisition process\n  always @(posedge rst or posedge sat_data) begin\n    // Initialize local clock and search for satellite signals\n    if (rst) begin\n      local_clock <= 0;\n      satellite_position <= 0;\n      receiver_position <= 0;\n    end else begin\n      local_clock <= local_clock + 1;\n      satellite_position <= satellite_position + sat_data;\n      receiver_position <= receiver_position + antenna_data;\n    end\n  end\n\n  // Tracking process\n  // No code needed, as tracking is done during acquisition\n\n  // Navigation process\n  always @(posedge clk) begin\n    // Compute position of the receiver using navigation equations\n    navigation_data <= satellite_position - receiver_position;\n\n    // Update latitude, longitude, and altitude\n    lat <= navigation_data[31:20];\n    lon <= navigation_data[19:8];\n    alt <= navigation_data[7:0];\n  end\n\nendmodule",
        "module_name": "gps",
        "module_hash": "6698a99c1bd1e5573698d2303f90ad20",
        "dataset_index": 12562
      },
      "barrel_shifter_c834e808": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] in,\n    input [1:0] shift_amt,\n    input dir,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (shift_amt)\n            2'b00: out = in;\n            2'b01: out = (dir == 1) ? {in[2:0], in[3]} : {in[1:0], in[3:2]};\n            2'b10: out = (dir == 1) ? {in[1:0], in[3:2]} : {in[2:0], in[3]};\n            2'b11: out = {in[0], in[3:1]};\n        endcase\n    end\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "c834e80881fe6f7aa40d6493387e1466",
        "dataset_index": 17594
      },
      "up_down_counter_bb8133cc": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input up_down,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset == 1) begin\n            q <= 4'b0;\n        end else begin\n            if (up_down == 1) begin\n                q <= q + 1;\n            end else begin\n                q <= q - 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "bb8133cc4d3506b60dfcd93c081d996f",
        "dataset_index": 21400
      },
      "shift_register_9d4946df": {
        "rtl_code": "\nmodule shift_register (input clk, stb, di, output [255:0] do);\n    localparam integer DIN_N = 256;\n    localparam integer DOUT_N = 256;\n\n    reg [DIN_N-1:0] din;\n    reg [DOUT_N-1:0] dout;\n\n    reg [DIN_N-1:0] din_shr;\n    reg [DOUT_N-1:0] dout_shr;\n\n    always @(posedge clk) begin\n        din_shr <= {din_shr, di};\n        dout_shr <= {dout_shr, din_shr[DIN_N-1]};\n        if (stb) begin\n            din <= din_shr;\n            dout <= dout_shr;\n        end\n    end\n\n    assign do = dout;\n\nendmodule\nmodule roi (input ci, s0, output o0);\n    assign o0 = ci & s0;\nendmodule",
        "module_name": "shift_register",
        "module_hash": "9d4946dff56918e8970773e7229561c7",
        "dataset_index": 8035
      },
      "ones_complement_88c58cb4": {
        "rtl_code": "module ones_complement (\n    input [3:0] binary,\n    input clk,\n    output reg [3:0] ones_comp\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\n// Pipeline stage 1\nalways @(*) begin\n    stage1_out = ~binary;\nend\n\n// Pipeline stage 2\nalways @(*) begin\n    stage2_out = ~stage1_out;\nend\n\n// Output stage\nalways @(posedge clk) begin\n    ones_comp <= stage2_out;\nend\n\nendmodule",
        "module_name": "ones_complement",
        "module_hash": "88c58cb48a5206ac346978c1971133e9",
        "dataset_index": 9399
      },
      "vending_machine_d3a21b98": {
        "rtl_code": "module vending_machine (\n    input wire reset,\n    input wire clk,\n    input wire [1:0] button,\n    input wire [1:0] coin,\n    output reg [7:0] disp_price,\n    output reg [7:0] disp_money,\n    output reg [7:0] disp_change\n);\n\n    // Define constants\n    parameter PRICE_1 = 50;\n    parameter PRICE_2 = 75;\n    parameter PRICE_3 = 100;\n    parameter PRICE_4 = 125;\n\n    // Define state machine states\n    localparam IDLE = 2'b00;\n    localparam DISP_PRICE = 2'b01;\n    localparam INSERT_COIN = 2'b10;\n    localparam DISP_CHANGE = 2'b11;\n\n    // Define state machine signals\n    reg [1:0] state;\n    reg [7:0] price;\n    reg [7:0] money;\n    reg [7:0] change;\n    reg [7:0] coin_value;\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            state <= IDLE;\n            price <= 0;\n            money <= 0;\n            change <= 0;\n            coin_value <= 0;\n            disp_price <= 0;\n            disp_money <= 0;\n            disp_change <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (button != 2'b00) begin\n                        state <= DISP_PRICE;\n                        case (button)\n                            2'b01: price <= PRICE_1;\n                            2'b10: price <= PRICE_2;\n                            2'b11: price <= PRICE_3;\n                            2'b00: price <= PRICE_4;\n                        endcase\n                        disp_price <= price;\n                    end else begin\n                        disp_price <= 0;\n                    end\n                    disp_money <= money;\n                    disp_change <= change;\n                end\n                DISP_PRICE: begin\n                    if (coin != 2'b00) begin\n                        state <= INSERT_COIN;\n                        case (coin)\n                            2'b01: coin_value <= 5;\n                            2'b10: coin_value <= 10;\n                            2'b11: coin_value <= 25;\n                            2'b00: coin_value <= 50;\n                        endcase\n                        money <= money + coin_value;\n                    end else begin\n                        disp_price <= price;\n                    end\n                    disp_money <= money;\n                    disp_change <= change;\n                end\n                INSERT_COIN: begin\n                    if (money >= price) begin\n                        state <= DISP_CHANGE;\n                        change <= money - price;\n                        money <= money - price;\n                    end else begin\n                        coin_value <= 0;\n                        state <= DISP_PRICE;\n                    end\n                    disp_price <= price;\n                    disp_money <= money;\n                    disp_change <= change;\n                end\n                DISP_CHANGE: begin\n                    if (coin != 2'b00) begin\n                        state <= INSERT_COIN;\n                        case (coin)\n                            2'b01: coin_value <= 5;\n                            2'b10: coin_value <= 10;\n                            2'b11: coin_value <= 25;\n                            2'b00: coin_value <= 50;\n                        endcase\n                        change <= change + coin_value;\n                    end else begin\n                        state <= IDLE;\n                        price <= 0;\n                        money <= 0;\n                        change <= 0;\n                        coin_value <= 0;\n                        disp_price <= 0;\n                        disp_money <= 0;\n                        disp_change <= 0;\n                    end\n                    disp_price <= price;\n                    disp_money <= money;\n                    disp_change <= change;\n                end\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "d3a21b989ee7988b84c699e9299ca3e9",
        "dataset_index": 18949
      },
      "full_adder_1bit_f92f439f": {
        "rtl_code": "\nmodule full_adder_1bit(\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\n    assign SUM = A ^ B ^ CIN;\n    assign COUT = (A & B) | (B & CIN) | (A & CIN);\n\nendmodule\nmodule adder_subtractor_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input SEL,\n    input CLK,\n    input RST,\n    output [3:0] Y,\n    output COUT\n);\n\n    wire [3:0] sum;\n    wire [3:0] neg_b;\n    wire [3:0] twos_comp_b;\n\n    full_adder_1bit fa0(.A(A[0]), .B(neg_b[0]), .CIN(SEL), .SUM(sum[0]));\n    full_adder_1bit fa1(.A(A[1]), .B(neg_b[1]), .CIN(sum[0]), .SUM(sum[1]));\n    full_adder_1bit fa2(.A(A[2]), .B(neg_b[2]), .CIN(sum[1]), .SUM(sum[2]));\n    full_adder_1bit fa3(.A(A[3]), .B(neg_b[3]), .CIN(sum[2]), .SUM(sum[3]), .COUT(COUT));\n\n    assign neg_b = ~B + 1;\n    assign twos_comp_b = SEL ? B : neg_b;\n    assign Y = SEL ? sum : twos_comp_b;\n\nendmodule",
        "module_name": "full_adder_1bit",
        "module_hash": "f92f439f4385bd7c3513f32a83e42b87",
        "dataset_index": 14581
      },
      "cpu_write_controller_1533fc08": {
        "rtl_code": "module cpu_write_controller(\n  input         ff_wr_pend,\n  input         hreset_n,\n  input         cpu_wr_gnt,\n  input         crt_req,\n  input         svga_ack,\n  input         mem_clk,\n  output reg    cpu_wr_req,\n  output        cpu_wr_svga_req,\n  output        enwr_cpu_ad_da_pl,\n  output        cpu_fifo_read,\n  output reg    int_cpu_fifo_rd,\n  output        cpu_mem_wr,\n  output reg    cpu_arb_wr\n);\n\n  reg [2:0] current_state;\n  reg [2:0] next_state;\n  reg en_cpu_fifo_read;\n  reg wen;\n  reg int_cpu_wr_svga_req;\n  \n  wire t32;\n  wire t34;\n\n  parameter cpuwr_state0 = 3'b000,\n             cpuwr_state1 = 3'b001,\n             cpuwr_state2 = 3'b011,\n             cpuwr_state3 = 3'b111,\n             cpuwr_state4 = 3'b110;\n  \n  assign t32 = (ff_wr_pend & (~crt_req));\n  assign t34 = ((~ff_wr_pend) | crt_req);\n    \n  assign cpu_fifo_read = ff_wr_pend & en_cpu_fifo_read;  \n  assign enwr_cpu_ad_da_pl = ff_wr_pend & en_cpu_fifo_read;\n  assign cpu_wr_svga_req  = int_cpu_wr_svga_req & ff_wr_pend;\n  \n  assign cpu_mem_wr = cpu_wr_req;\n    \n  always @ (posedge mem_clk or negedge hreset_n) begin\n    if (hreset_n == 0) current_state = cpuwr_state0;\n    else current_state = next_state;\n  end\n   \n  always @* begin\n    cpu_wr_req          = 1'b0;\n    int_cpu_wr_svga_req = 1'b0;\n    int_cpu_fifo_rd     = 1'b0;\n    en_cpu_fifo_read    = 1'b0;\n    cpu_arb_wr          = 1'b0;\n\t \n    case(current_state)\n      cpuwr_state0: next_state = (ff_wr_pend) ? cpuwr_state1 : cpuwr_state0;\n      cpuwr_state1: begin\n        cpu_wr_req = 1'b1;\n        next_state = (cpu_wr_gnt) ? cpuwr_state2 : cpuwr_state1;\n      end\n      cpuwr_state2: begin\n        cpu_arb_wr = 1'b1;\n        cpu_wr_req = 1'b1;\n        int_cpu_wr_svga_req = 1'b1;\n        int_cpu_fifo_rd = 1'b1;\n        if (svga_ack) next_state = cpuwr_state3;\n        else next_state = cpuwr_state2;\n      end\n      cpuwr_state3: begin\n        cpu_wr_req = 1'b1;\n        cpu_arb_wr = 1'b1;\n        en_cpu_fifo_read = 1'b1;\n        next_state = cpuwr_state4;\n      end\n      cpuwr_state4: begin\n        cpu_wr_req = 1'b1;\n        cpu_arb_wr = 1'b1;\n        if (t34) next_state = cpuwr_state0;\n        else if (t32) next_state = cpuwr_state2;\n        else next_state = cpuwr_state4;\n      end\n    endcase\n  end   \n\nendmodule",
        "module_name": "cpu_write_controller",
        "module_hash": "1533fc0882f0eb157b4375e9e3c95c78",
        "dataset_index": 3938
      },
      "clock_gating_cell_663aba1e": {
        "rtl_code": "module clock_gating_cell (\n  input clk,\n  input enable,\n  output gated_clk\n);\n\n  assign gated_clk = clk & enable;\n\n\nendmodule",
        "module_name": "clock_gating_cell",
        "module_hash": "663aba1e77e2e2b5166713f2e5e41f42",
        "dataset_index": 11192
      },
      "binary_counter_3939a40e": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input reset_n,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "3939a40e50373b74623628cbc802bb03",
        "dataset_index": 9237
      },
      "barrel_shifter_9b3f9a8d": {
        "rtl_code": "module barrel_shifter (\n  input [7:0] in,\n  input [1:0] shift_dir,\n  input [2:0] shift_amt,\n  output reg [7:0] out\n);\n\nparameter n = 8; // number of input and output signals\nparameter s = 8; // maximum shift amount (power of 2)\n\nreg [7:0] shifted_in;\n\nalways @(*) begin\n  if (shift_dir == 0) // shift right\n    shifted_in = {s{in[7]}}; // fill with MSB\n  else // shift left\n    shifted_in = {in, {s{1'b0}}}; // fill with 0s\n  if (shift_amt > s) // shift amount too large\n    out = {8{1'b0}}; // set output to 0\n  else if (shift_amt == 0) // no shift\n    out = in;\n  else if (shift_dir == 0) // shift right\n    out = shifted_in >> shift_amt;\n  else // shift left\n    out = shifted_in << shift_amt;\nend\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "9b3f9a8d5108435755046c710dfd924c",
        "dataset_index": 11226
      },
      "d_ff_async_rst_set_9af50935": {
        "rtl_code": "module d_ff_async_rst_set (\n  input clk,\n  input rst,\n  input set,\n  input d,\n  output q,\n  output qn\n);\n\n  reg q_i;\n  wire q = q_i;\n  assign qn = ~q_i;\n\n  always @(posedge clk) begin\n    if (rst == 1'b0) begin\n      q_i <= 1'b0; // Asynchronous reset\n    end else if (set == 1'b0) begin\n      q_i <= 1'b1; // Asynchronous set\n    end else begin\n      q_i <= d; // Rising edge triggered\n    end\n  end\n\nendmodule",
        "module_name": "d_ff_async_rst_set",
        "module_hash": "9af50935c9f9a10bc0045f05c0043e31",
        "dataset_index": 714
      },
      "dual_edge_ff_and_or_barrelshifter_e83ce3f1": {
        "rtl_code": "\nmodule dual_edge_ff_and_or_barrelshifter (\n  input clk,\n  input d,\n  output reg q,\n  input [7:0] in,\n  output [7:0] out,\n  input select\n);\n\n  reg [7:0] constant = 8'b10101010; // Define constant vector\n  reg d_reg;\n  reg [7:0] and_result; // Declare AND result register\n  reg [7:0] or_result; // Declare OR result register\n\n  always @(posedge clk) begin\n    if (d) begin\n      q <= d;\n    end\n  end\n\n  always @(*) begin\n    d_reg = d;\n  end\n\n  always @(*) begin // AND operation\n    and_result = select ? in & constant : in;\n  end\n\n  always @(*) begin // OR operation\n    or_result = select ? in : in | constant;\n  end\n\n  assign out = select ? {and_result[7], and_result[6], and_result[5], and_result[4], and_result[3], and_result[2], and_result[1], and_result[0]} : {or_result[7], or_result[6], or_result[5], or_result[4], or_result[3], or_result[2], or_result[1], or_result[0]};\n  // Barrel shifter\n\nendmodule\nmodule top_module (\n  input clk,\n  input d,\n  output q,\n  input [7:0] in,\n  output [7:0] out,\n  input select\n);\n\n  dual_edge_ff_and_or_barrelshifter module_inst (\n    .clk(clk),\n    .d(d),\n    .q(q),\n    .in(in),\n    .out(out),\n    .select(select)\n  );\n\nendmodule",
        "module_name": "dual_edge_ff_and_or_barrelshifter",
        "module_hash": "e83ce3f1e9ea552d86bbf54238d6303e",
        "dataset_index": 5475
      },
      "top__17b6781a": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [7:0] final_out\n);\n\n    // Inputs for the given modules\n    wire [7:0] anyedge;\n    wire [31:0] transition_out;\n    \n    // Instantiate the given modules\n    shift_register shift_reg(clk, in, anyedge);\n    transition_capture trans_cap(clk, reset, anyedge[0], transition_out);\n    \n    // Functional module to combine the outputs\n    reg [7:0] final_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            final_reg <= 8'b0;\n        end else begin\n            final_reg <= {transition_out[31], transition_out[31], transition_out[31], transition_out[31], \n                          transition_out[30], transition_out[29], transition_out[28], transition_out[27]};\n        end\n    end\n    \n    assign final_out = final_reg & ~anyedge;\n    \nendmodule\nmodule shift_register (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n    reg [7:0] reg_in;\n    always @(posedge clk) begin\n        reg_in <= in;\n    end\n    \n    assign anyedge = reg_in & ~{reg_in[6:0], 1'b0};\n    \nendmodule\nmodule transition_capture (\n    input clk,\n    input reset,\n    input [0:0] in,\n    output [31:0] out\n);\n    reg [31:0] reg_in;\n    always @(posedge clk) begin\n        if (reset) begin\n            reg_in <= 32'b0;\n        end else begin\n            reg_in <= {reg_in[30:0], in};\n        end\n    end\n    \n    assign out = reg_in;\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "17b6781a5c4070a9d4dfcf678bbf77c4",
        "dataset_index": 854
      },
      "vga_address_translator_8c1a764c": {
        "rtl_code": "\nmodule vga_address_translator(x, y, mem_address);\n\n\tparameter RESOLUTION = \"320x240\";\n\t\n\n\tinput [((RESOLUTION == \"320x240\") ? (8) : (7)):0] x; \n\tinput [((RESOLUTION == \"320x240\") ? (7) : (6)):0] y;\t\n\toutput reg [((RESOLUTION == \"320x240\") ? (16) : (14)):0] mem_address;\n\t\n\t\n\twire [16:0] res_320x240 = ({1'b0, y, 8'd0} + {1'b0, y, 6'd0} + {1'b0, x});\n\twire [15:0] res_160x120 = ({1'b0, y, 7'd0} + {1'b0, y, 5'd0} + {1'b0, x});\n\t\n\talways @(*)\n\tbegin\n\t\tif (RESOLUTION == \"320x240\")\n\t\t\tmem_address = res_320x240;\n\t\telse\n\t\t\tmem_address = res_160x120[14:0];\n\tend\nendmodule\n",
        "module_name": "vga_address_translator",
        "module_hash": "8c1a764cbb68cd581e010325f6c0d36e",
        "dataset_index": 24195
      },
      "NIOS_Sys_nios2_qsys_0_nios2_oci_fifocount_inc_315b071c": {
        "rtl_code": "module NIOS_Sys_nios2_qsys_0_nios2_oci_fifocount_inc (\n    input empty,\n    input free2,\n    input free3,\n    input [1:0] tm_count,\n    output reg [4:0] fifocount_inc\n);\n\nalways @(*) begin\n    if (empty) begin\n        fifocount_inc = tm_count;\n    end else if (free3 & (tm_count == 2'b11)) begin\n        fifocount_inc = 2;\n    end else if (free2 & (tm_count >= 2)) begin\n        fifocount_inc = 1;\n    end else if (tm_count >= 1) begin\n        fifocount_inc = 0;\n    end else begin\n        fifocount_inc = 5'b11111;\n    end\nend\n\nendmodule",
        "module_name": "NIOS_Sys_nios2_qsys_0_nios2_oci_fifocount_inc",
        "module_hash": "315b071cfcbc9fe1c9562ee2a0e063f6",
        "dataset_index": 15202
      },
      "ripple_carry_adder_17b83f11": {
        "rtl_code": "\nmodule ripple_carry_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [4:0] temp_S;  // Temporary output\n\n  assign temp_S = A + B + Cin;\n\n  assign S = temp_S[3:0];  // Assign the value of temp_S to S\n  assign Cout = temp_S[4];  // Assign the carry out to Cout\n\nendmodule\n",
        "module_name": "ripple_carry_adder",
        "module_hash": "17b83f11c32084fb002e3e1de2cc1d87",
        "dataset_index": 20898
      },
      "adder_4bit_carry_950048fb": {
        "rtl_code": "module adder_4bit_carry (\n    // Inputs\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    // Outputs\n    output [3:0] sum,\n    output cout\n);\n\n    wire [3:0] temp_sum;\n    wire c1, c2, c3;\n\n    // First bit\n    full_adder fa1(a[0], b[0], cin, temp_sum[0], c1);\n\n    // Second bit\n    full_adder fa2(a[1], b[1], c1, temp_sum[1], c2);\n\n    // Third bit\n    full_adder fa3(a[2], b[2], c2, temp_sum[2], c3);\n\n    // Fourth bit\n    full_adder fa4(a[3], b[3], c3, temp_sum[3], cout);\n\n    assign sum = temp_sum;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    wire s1, s2, s3;\n\n    // First XOR gate\n    xor x1(s1, a, b);\n\n    // Second XOR gate\n    xor x2(s2, s1, cin);\n\n    // Third AND gate\n    and a1(s3, s1, cin);\n\n    // Final sum output\n    assign sum = s2;\n\n    // Final carry output\n    assign cout = s3;\n\nendmodule",
        "module_name": "adder_4bit_carry",
        "module_hash": "950048fb112f5031486f755cf5594ff5",
        "dataset_index": 8675
      },
      "reverse_data_1226faaf": {
        "rtl_code": "module reverse_data(\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [3:0] control,\n  output [7:0] data_out\n);\n\n  reg [7:0] data_out_reg;\n  reg [3:0] counter;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      data_out_reg <= 8'h00;\n      counter <= 4'h0;\n    end\n    else begin\n      if (counter == control) begin\n        data_out_reg <= {data_in[7], data_in[6], data_in[5], data_in[4], data_in[3], data_in[2], data_in[1], data_in[0]};\n        counter <= 4'h0;\n      end\n      else begin\n        data_out_reg <= data_out_reg;\n        counter <= counter + 1;\n      end\n    end\n  end\n\n  assign data_out = data_out_reg;\n\nendmodule",
        "module_name": "reverse_data",
        "module_hash": "1226faaf7f9d20c5c4211f871f5df91e",
        "dataset_index": 954
      },
      "counter_406015ea": {
        "rtl_code": "module counter (\n  input clk,\n  input thresh_sw,\n  input count_sw,\n  input [31:0] threshold,\n  output reg [31:0] count,\n  output reg zero,\n  output reg max,\n  output reg gtu,\n  output reg gts,\n  output reg ltu,\n  output reg lts,\n  output reg geu,\n  output reg ges,\n  output reg leu,\n  output reg les\n);\n\n  always @(posedge clk) begin\n    if (count_sw) begin\n      count <= 32'd0;\n    end else if (thresh_sw) begin\n      count <= count - 1;\n    end else begin\n      count <= count + 1;\n    end\n\n    zero <= (count == 32'd0);\n    max <= (count == 32'hFFFFFFFF);\n    gtu <= (count > threshold);\n    gts <= ($signed(count) > $signed(threshold));\n    ltu <= (count < threshold);\n    lts <= ($signed(count) < $signed(threshold));\n    geu <= (count >= threshold);\n    ges <= ($signed(count) >= $signed(threshold));\n    leu <= (count <= threshold);\n    les <= ($signed(count) <= $signed(threshold));\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "406015eaf1d24eef91207bdbbcc89ed0",
        "dataset_index": 21252
      },
      "top__8e6b0a4b": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [99:0] a, b, // Inputs for the carry-lookahead adder\n    input cin, // Carry-in bit for the carry-lookahead adder\n    input select, // Select input to choose between the adder and counter\n    output [3:1] ena, // Enable signals for the upper three digits of the counter\n    output [15:0] q // 16-bit BCD output from the counter and final output from the functional module\n);\n\n    // Define internal wires and registers\n    wire [99:0] sum; // Output from the carry-lookahead adder\n    wire cout; // Carry-out bit from the carry-lookahead adder\n    wire [15:0] bcd_out; // Output from the BCD counter\n    reg [15:0] final_out; // Final output from the functional module\n    reg [3:1] ena_reg; // Register for the enable signals of the counter\n\n    // Instantiate the carry-lookahead adder\n    carry_lookahead_adder adder_inst (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(cout)\n    );\n\n    // Instantiate the BCD counter\n    bcd_counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .bcd_out(bcd_out)\n    );\n\n    // Define the control logic for selecting between the adder and counter\n    always @ (posedge clk) begin\n        if (reset) begin\n            ena_reg <= 3'b000;\n            final_out <= 16'b0;\n        end else begin\n            if (select) begin\n                ena_reg <= 3'b000;\n                final_out <= {12'b0, bcd_out};\n            end else begin\n                ena_reg <= 3'b111;\n                final_out <= {12'b0, sum};\n            end\n        end\n    end\n\n    // Assign the outputs\n    assign ena = ena_reg;\n    assign q = final_out;\n\nendmodule\nmodule carry_lookahead_adder (\n    input [99:0] a, b, // Inputs\n    input cin, // Carry-in bit\n    output [99:0] sum, // Output sum\n    output cout // Carry-out bit\n);\n\n    // Define internal wires and registers\n    wire [99:0] p, g; // Propagate and generate signals\n    wire [99:0] c; // Carry signals\n    reg [99:0] sum_reg; // Register for the sum output\n    reg cout_reg; // Register for the carry-out bit\n\n    // Generate the propagate and generate signals\n    generate\n        genvar i;\n        for (i = 0; i < 100; i = i + 1) begin\n            assign p[i] = a[i] ^ b[i];\n            assign g[i] = a[i] & b[i];\n        end\n    endgenerate\n\n    // Generate the carry signals\n    generate\n        genvar i;\n        assign c[0] = cin;\n        for (i = 1; i < 100; i = i + 1) begin\n            assign c[i] = g[i-1] | (p[i-1] & c[i-1]);\n        end\n    endgenerate\n\n    // Generate the sum output and carry-out bit\n    always @ (*) begin\n        sum_reg = a + b + cin;\n        cout_reg = c[99];\n    end\n\n    // Assign the outputs\n    assign sum = sum_reg;\n    assign cout = cout_reg;\n\nendmodule\nmodule bcd_counter (\n    input clk, // Clock input\n    input reset, // Synchronous active-high reset\n    output [15:0] bcd_out // 16-bit BCD output\n);\n\n    // Define internal wires and registers\n    reg [15:0] count; // Current count value\n\n    // Define the counter logic\n    always @ (posedge clk) begin\n        if (reset) begin\n            count <= 16'b0;\n        end else begin\n            count <= count + 1'b1;\n        end\n    end\n\n    // Assign the output\n    assign bcd_out = count;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "8e6b0a4b612af250dd0320d6fb2b07a4",
        "dataset_index": 7286
      },
      "hls_saturation_enqcK #_f21dc47e": {
        "rtl_code": "\n\nmodule hls_saturation_enqcK #(\nparameter\n    ID                = 0,\n    NUM_STAGE         = 1,\n    din0_WIDTH       = 32,\n    din1_WIDTH       = 32,\n    din2_WIDTH       = 32,\n    din3_WIDTH       = 32,\n    din4_WIDTH         = 32,\n    dout_WIDTH            = 32\n)(\n    input  [27 : 0]     din0,\n    input  [27 : 0]     din1,\n    input  [27 : 0]     din2,\n    input  [27 : 0]     din3,\n    input  [1 : 0]    din4,\n    output [27 : 0]   dout);\n\nwire [1 : 0]     sel;\nwire [27 : 0]         mux_1_0;\nwire [27 : 0]         mux_1_1;\nwire [27 : 0]         mux_2_0;\n\nassign sel = din4;\n\nassign mux_1_0 = (sel[0] == 0)? din0 : din1;\nassign mux_1_1 = (sel[0] == 0)? din2 : din3;\n\nassign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;\n\nassign dout = mux_2_0;\n\nendmodule\n",
        "module_name": "hls_saturation_enqcK #",
        "module_hash": "f21dc47e15984743213da78faf154fad",
        "dataset_index": 22653
      },
      "sky130_fd_sc_lp__iso0n_752a9e1e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__iso0n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    supply1 VPWR ;\n    supply0 KAGND;\n    supply1 VPB  ;\n    supply0 VNB  ;\n\n    and and0 (X     , A, SLEEP_B     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__iso0n",
        "module_hash": "752a9e1ee691a1582a0244266dc6becc",
        "dataset_index": 21596
      },
      "up_counter_3bit_b6fccb4b": {
        "rtl_code": "module up_counter_3bit (\n    input clk,\n    input rst,\n    output reg [2:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (rst == 0) begin\n            count <= 3'b000;\n        end else if (count == 3'b111) begin\n            count <= 3'b000;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_counter_3bit",
        "module_hash": "b6fccb4b7a70d05edba63efeca336b37",
        "dataset_index": 15064
      },
      "S4L2_3b054292": {
        "rtl_code": "module S4L2(clock_50mhz, clock_1hz, segmentos, anodo,estado);\ninput clock_50mhz; output reg clock_1hz; output reg [6:0] segmentos = 7'h3F; output reg anodo = 0; output reg [3:0] estado = 0; reg [25:0] cuenta_para_1hz = 0; parameter [6:0] cero \t= \t~7'h3F; \nparameter [6:0] uno \t= \t~7'h06; \nparameter [6:0] dos \t= \t~7'h5B; \nparameter [6:0] tres \t= \t~7'h4F; \nparameter [6:0] cuatro\t=\t~7'h66; \nparameter [6:0] cinco\t= \t~7'h6D; \nparameter [6:0] seis \t= \t~7'h7D; \nparameter [6:0] siete\t= \t~7'h07; \nparameter [6:0] ocho \t= \t~7'h7F; \nparameter [6:0] nueve\t=\t~7'h6F; \nparameter [6:0] ha \t\t= \t~7'h77; \nparameter [6:0] hb \t\t= \t~7'h7C; \nparameter [6:0] hc \t\t= \t~7'h39; \nparameter [6:0] hd \t\t= \t~7'h5E; \nparameter [6:0] he \t\t= \t~7'h79; \nparameter [6:0] hf \t\t= \t~7'h71; \n\n\nalways @(posedge clock_50mhz)\nbegin\ncuenta_para_1hz = cuenta_para_1hz + 1;\nif(cuenta_para_1hz == 25_000_000)\nbegin\nclock_1hz = ~clock_1hz; cuenta_para_1hz = 0; end\nend\n\nalways @(posedge clock_1hz)\nbegin\ncase(estado)\n0: estado <= 1;\n1: estado <= 2;\n2: estado <= 3;\n3: estado <= 4;\n4: estado <= 5;\n5: estado <= 6;\n6: estado <= 7;\n7: estado <= 8;\n8: estado <= 9;\n9: estado <= 10;\n10: estado <= 11;\n11: estado <= 12;\n12: estado <= 13;\n13: estado <= 14;\n14: estado <= 15;\n15: estado <= 0;\nendcase\nend\n\nalways @(estado)\nbegin\ncase(estado)\n0: segmentos = cero;\n1: segmentos = uno;\n2: segmentos = dos;\n3: segmentos = tres;\n4: segmentos = cuatro;\n5: segmentos = cinco;\n6: segmentos = seis;\n7: segmentos = siete;\n8: segmentos = ocho;\n9: segmentos = nueve;\n10: segmentos = ha;\n11: segmentos = hb;\n12: segmentos = hc;\n13: segmentos = hd;\n14: segmentos = he;\n15: segmentos = hf;\nendcase\nend\nendmodule",
        "module_name": "S4L2",
        "module_hash": "3b05429244425773060c663b33a27c41",
        "dataset_index": 24716
      },
      "top_module_577b2d1c": {
        "rtl_code": "module top_module(\n    input clk,\n    input reset,\n    input [3:0] in,\n    input [7:0] sel,\n    input [1:0] ena,\n    input load,\n    input select,\n    output [3:0] q);\n\n    wire [3:0] barrel_shift_out;\n    wire [3:0] mux_out;\n    wire [3:0] or_out;\n\n    barrel_shifter barrel_shift(\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .shift_sel(sel),\n        .out(barrel_shift_out)\n    );\n\n    mux_256to1 mux(\n        .sel(select ? sel : 8'hFF),\n        .in_0(barrel_shift_out),\n        .in_1(mux_out),\n        .out(mux_out)\n    );\n\n    or_gate or_op(\n        .in_0(barrel_shift_out),\n        .in_1(mux_out),\n        .out(or_out)\n    );\n\n    reg [3:0] q_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q_reg <= 4'b0000;\n        end else if (load) begin\n            q_reg <= in;\n        end else if (ena) begin\n            q_reg <= or_out;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule\n\nmodule barrel_shifter(\n    input clk,\n    input reset,\n    input [3:0] in,\n    input [7:0] shift_sel,\n    output [3:0] out\n);\n\n    reg [3:0] out_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out_reg <= 4'b0000;\n        end else begin\n            out_reg <= in << shift_sel[3:0];\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule mux_256to1(\n    input [7:0] sel,\n    input [3:0] in_0,\n    input [3:0] in_1,\n    output [3:0] out\n);\n\n    reg [3:0] out_reg;\n\n    always @(*) begin\n        case (sel)\n            8'h00: out_reg = in_0;\n            8'h01: out_reg = in_1;\n            // Add remaining cases for 254 inputs\n            8'hFE: out_reg = in_1;\n            8'hFF: out_reg = in_0;\n        endcase\n    end\n\n    assign out = out_reg;\n\nendmodule\n\nmodule or_gate(\n    input [3:0] in_0,\n    input [3:0] in_1,\n    output [3:0] out\n);\n\n    assign out = in_0 | in_1;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "577b2d1ccd11f58877fbf027ab3f6a58",
        "dataset_index": 2442
      },
      "d_ff_reset_preset_4b542053": {
        "rtl_code": "\nmodule d_ff_reset_preset(clk, reset, preset, d, q);\ninput clk, reset, preset, d;\noutput reg q;\n\nalways @(posedge clk)\nbegin\n    if (!reset)\n        q <= 1'b0;\n    else if (!preset)\n        q <= 1'b1;\n    else\n        q <= d;\nend\n\nendmodule",
        "module_name": "d_ff_reset_preset",
        "module_hash": "4b542053d533b5b34f06c09d9fa1b541",
        "dataset_index": 2617
      },
      "d_flip_flop_50e46329": {
        "rtl_code": "module d_flip_flop (CK, D, RST, Q, QN);\ninput CK, D, RST;\noutput Q, QN;\nreg Q, QN;\n\nalways @(posedge CK or negedge RST) begin\n  if (!RST) begin\n    Q <= 0;\n    QN <= 1;\n  end\n  else begin\n    Q <= D;\n    QN <= ~D;\n  end\nend\n\nendmodule",
        "module_name": "d_flip_flop",
        "module_hash": "50e463297ce401beb5179d55f84447cc",
        "dataset_index": 20619
      },
      "mux_4to1_case_85e48514": {
        "rtl_code": "module mux_4to1_case (\n  input a,\n  input b,\n  input c,\n  input d,\n  input sel0,\n  input sel1,\n  output reg out\n);\n\n  always @(*) begin\n    case ({sel1, sel0})\n      2'b00: out = a;\n      2'b01: out = b;\n      2'b10: out = c;\n      2'b11: out = d;\n    endcase\n  end\n\nendmodule\n",
        "module_name": "mux_4to1_case",
        "module_hash": "85e485149d2084c3105581ca4f996188",
        "dataset_index": 4861
      },
      "pipelined_JC_counter_fa99d35b": {
        "rtl_code": "\nmodule pipelined_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [15:0]   Q\n);\n\nreg [15:0] Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, Q10, Q11, Q12, Q13, Q14, Q15, Q16;\n\nalways @(posedge clk or negedge rst_n) begin\n  if(!rst_n) begin\n    Q1 <= 16'b0000000000000000;\n    Q2 <= 16'b0000000000000000;\n    Q3 <= 16'b0000000000000000;\n    Q4 <= 16'b0000000000000000;\n    Q5 <= 16'b0000000000000000;\n    Q6 <= 16'b0000000000000000;\n    Q7 <= 16'b0000000000000000;\n    Q8 <= 16'b0000000000000000;\n    Q9 <= 16'b0000000000000000;\n    Q10 <= 16'b0000000000000000;\n    Q11 <= 16'b0000000000000000;\n    Q12 <= 16'b0000000000000000;\n    Q13 <= 16'b0000000000000000;\n    Q14 <= 16'b0000000000000000;\n    Q15 <= 16'b0000000000000000;\n    Q16 <= 16'b0000000000000000;\n  end else begin\n    Q1 <= Q16 ^ 1'b1;\n    Q2 <= Q1 ^ 1'b1;\n    Q3 <= Q2 ^ 1'b1;\n    Q4 <= Q3 ^ 1'b1;\n    Q5 <= Q4 ^ 1'b1;\n    Q6 <= Q5 ^ 1'b1;\n    Q7 <= Q6 ^ 1'b1;\n    Q8 <= Q7 ^ 1'b1;\n    Q9 <= Q8 ^ 1'b1;\n    Q10 <= Q9 ^ 1'b1;\n    Q11 <= Q10 ^ 1'b1;\n    Q12 <= Q11 ^ 1'b1;\n    Q13 <= Q12 ^ 1'b1;\n    Q14 <= Q13 ^ 1'b1;\n    Q15 <= Q14 ^ 1'b1;\n    Q16 <= Q15 ^ 1'b1;\n\n    Q <= Q16;\n  end\nend\n\nendmodule\n",
        "module_name": "pipelined_JC_counter",
        "module_hash": "fa99d35b4e2e617289b9f4fd44135a58",
        "dataset_index": 6474
      },
      "square_wave_generator_e720a5a1": {
        "rtl_code": "\nmodule square_wave_generator (\n    input clk,\n    input reset,\n    output reg square_wave\n);\n\nreg [31:0] counter;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        square_wave <= 1'b0;\n        counter <= 32'd0;\n    end else begin\n        if (counter == 32'd49999999) begin\n            counter <= 32'd0;\n            square_wave <= ~square_wave;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule adder (\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] S,\n    output Cout\n);\n\nassign {Cout, S} = A + B + Cin;\n\nendmodule\n\nmodule final_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nwire square_wave;\nwire [15:0] adder_output;\nwire [15:0] subtractor_output;\n\nsquare_wave_generator square_wave_gen (\n    .clk(clk),\n    .reset(reset),\n    .square_wave(square_wave)\n);\n\nadder adder_inst (\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .S(adder_output),\n    .Cout()\n);\n\nassign subtractor_output = A - B;\n\nassign final_output = square_wave ? adder_output + subtractor_output : adder_output - subtractor_output;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input Cin,\n    output [15:0] final_output\n);\n\nfinal_module final_inst (\n    .clk(clk),\n    .reset(reset),\n    .A(A),\n    .B(B),\n    .Cin(Cin),\n    .final_output(final_output)\n);\n\nendmodule\n",
        "module_name": "square_wave_generator",
        "module_hash": "e720a5a166a14e46ff4da742c8463bc7",
        "dataset_index": 20317
      },
      "fifo_24in_24out_12kb_updn_cntr_3b2b58b2": {
        "rtl_code": "\nmodule fifo_24in_24out_12kb_updn_cntr (\n  input clk, E, rd_en, valid_fwft,\n  input [23:0] Q,\n  output reg [23:0] data_out,\n  output reg data_count_out,\n  output reg rd_en_out,\n  output reg valid_fwft_out,\n  output reg [23:0] Q_out\n);\n  localparam WIDTH = 24;\n  localparam DEPTH = 512;\n  localparam ADDR_WIDTH = $clog2(DEPTH);\n  localparam MEM_SIZE = 1 << ADDR_WIDTH;\n  reg [23:0] mem [0:MEM_SIZE-1];\n  reg [ADDR_WIDTH-1:0] wr_ptr;\n  reg [ADDR_WIDTH-1:0] rd_ptr;\n  reg [ADDR_WIDTH:0] data_count;\n  wire [ADDR_WIDTH-1:0] next_wr_ptr;\n  wire [ADDR_WIDTH-1:0] next_rd_ptr;\n  wire [ADDR_WIDTH:0] next_data_count;\n  reg [23:0] data_out_internal;\n  reg [ADDR_WIDTH:0] data_count_internal;\n  reg rd_en_internal;\n  reg valid_fwft_internal;\n  assign next_wr_ptr = (wr_ptr + 1) % MEM_SIZE;\n  assign next_rd_ptr = (rd_ptr + 1) % MEM_SIZE;\n  assign next_data_count = data_count + (rd_en_internal ? -1 : 0) + (rd_en ? 1 : 0);\n  always @(posedge clk) begin\n      wr_ptr <= rd_en_internal ? next_wr_ptr : wr_ptr;\n      rd_ptr <= rd_en ? next_rd_ptr : rd_ptr;\n      data_count <= next_data_count;\n      rd_en_internal <= rd_en;\n      valid_fwft_internal <= valid_fwft;\n      data_out_internal <= mem[rd_ptr];\n      data_count_internal <= next_data_count;\n  end\n  always @(posedge clk) begin\n      data_count_out <= data_count_internal[ADDR_WIDTH-1];\n      rd_en_out <= rd_en_internal;\n      valid_fwft_out <= valid_fwft_internal;\n      Q_out <= Q;\n      data_out <= data_out_internal;\n  end\n  always @(posedge clk) begin\n      mem[wr_ptr] <= (rd_en_internal == 1'b0 && rd_en == 1'b0) ? Q : mem[wr_ptr];\n  end\nendmodule",
        "module_name": "fifo_24in_24out_12kb_updn_cntr",
        "module_hash": "3b2b58b2ce70dc7c1d34f521ede4b722",
        "dataset_index": 15463
      },
      "des_sbox6_30533aba": {
        "rtl_code": "module des_sbox6\n    (\n    // -- inputs --------------------------------------------------------- >>>>>\n        input  wire [0:5] right_xor_key_segment_din,\n    // -- outputs -------------------------------------------------------- >>>>>\n        output reg  [0:3] sbox_dout\n    );\n\n    always @(*)\n        case ({right_xor_key_segment_din[0], right_xor_key_segment_din[5]})\n            2'b00:  \n                    case (right_xor_key_segment_din[1:4])\n                        4'd0:   sbox_dout = 4'd12;\n                        4'd1:   sbox_dout = 4'd1;\n                        4'd2:   sbox_dout = 4'd10;\n                        4'd3:   sbox_dout = 4'd15;\n                        4'd4:   sbox_dout = 4'd9;\n                        4'd5:   sbox_dout = 4'd2;\n                        4'd6:   sbox_dout = 4'd6;\n                        4'd7:   sbox_dout = 4'd8;\n                        4'd8:   sbox_dout = 4'd0;\n                        4'd9:   sbox_dout = 4'd13;\n                        4'd10:  sbox_dout = 4'd3;\n                        4'd11:  sbox_dout = 4'd4;\n                        4'd12:  sbox_dout = 4'd14;\n                        4'd13:  sbox_dout = 4'd7;\n                        4'd14:  sbox_dout = 4'd5;\n                        4'd15:  sbox_dout = 4'd11;\n                    endcase\n\n            2'b01:\n                    case (right_xor_key_segment_din[1:4])\n                        4'd0:   sbox_dout = 4'd10;\n                        4'd1:   sbox_dout = 4'd15;\n                        4'd2:   sbox_dout = 4'd4;\n                        4'd3:   sbox_dout = 4'd2;\n                        4'd4:   sbox_dout = 4'd7;\n                        4'd5:   sbox_dout = 4'd12;\n                        4'd6:   sbox_dout = 4'd9;\n                        4'd7:   sbox_dout = 4'd5;\n                        4'd8:   sbox_dout = 4'd6;\n                        4'd9:   sbox_dout = 4'd1;\n                        4'd10:  sbox_dout = 4'd13;\n                        4'd11:  sbox_dout = 4'd14;\n                        4'd12:  sbox_dout = 4'd0;\n                        4'd13:  sbox_dout = 4'd11;\n                        4'd14:  sbox_dout = 4'd3;\n                        4'd15:  sbox_dout = 4'd8;\n                    endcase\n\n            2'b10:\n                    case (right_xor_key_segment_din[1:4])\n                        4'd0:   sbox_dout = 4'd9;\n                        4'd1:   sbox_dout = 4'd14;\n                        4'd2:   sbox_dout = 4'd15;\n                        4'd3:   sbox_dout = 4'd5;\n                        4'd4:   sbox_dout = 4'd2;\n                        4'd5:   sbox_dout = 4'd8;\n                        4'd6:   sbox_dout = 4'd12;\n                        4'd7:   sbox_dout = 4'd3;\n                        4'd8:   sbox_dout = 4'd7;\n                        4'd9:   sbox_dout = 4'd0;\n                        4'd10:  sbox_dout = 4'd4;\n                        4'd11:  sbox_dout = 4'd10;\n                        4'd12:  sbox_dout = 4'd1;\n                        4'd13:  sbox_dout = 4'd13;\n                        4'd14:  sbox_dout = 4'd11;\n                        4'd15:  sbox_dout = 4'd6;\n                    endcase\n\n            2'b11:\n                    case (right_xor_key_segment_din[1:4])\n                        4'd0:   sbox_dout = 4'd4;\n                        4'd1:   sbox_dout = 4'd3;\n                        4'd2:   sbox_dout = 4'd2;\n                        4'd3:   sbox_dout = 4'd12;\n                        4'd4:   sbox_dout = 4'd9;\n                        4'd5:   sbox_dout = 4'd5;\n                        4'd6:   sbox_dout = 4'd15;\n                        4'd7:   sbox_dout = 4'd10;\n                        4'd8:   sbox_dout = 4'd11;\n                        4'd9:   sbox_dout = 4'd14;\n                        4'd10:  sbox_dout = 4'd1;\n                        4'd11:  sbox_dout = 4'd7;\n                        4'd12:  sbox_dout = 4'd6;\n                        4'd13:  sbox_dout = 4'd0;\n                        4'd14:  sbox_dout = 4'd8;\n                        4'd15:  sbox_dout = 4'd13;\n                    endcase\n        endcase // right_xor_key_segment_din[0], right_xor_key_segment_din[5]\n\nendmodule",
        "module_name": "des_sbox6",
        "module_hash": "30533aba3c15c3ae5a1d15875a226d81",
        "dataset_index": 11363
      },
      "binary_adder_2e437bfc": {
        "rtl_code": "module binary_adder (\n    input [99:0] a, b,     // Inputs to the binary adder\n    input cin,             // Carry-in for the binary adder\n    output cout,           // Carry-out from the binary adder\n    output [99:0] sum      // Sum output from the binary adder\n);\n\n    wire [100:0] adder_out; // Internal wire to hold the adder output\n\n    // Ripple-carry adder architecture\n    assign adder_out = {cin, a} + {1'b0, b};\n    assign cout = adder_out[100];\n    assign sum = adder_out[99:0];\n\nendmodule\n\nmodule shift_register (\n    input clk,             // Clock input for the shift register\n    input d,               // Input to the shift register\n    output q              // Output from the shift register\n);\n\n    reg [2:0] shift_reg;    // Internal register to hold the shift register state\n\n    always @(posedge clk) begin\n        shift_reg <= {d, shift_reg[2:1]};\n    end\n\n    assign q = shift_reg[0];\n\nendmodule\n\nmodule functional_module (\n    input [99:0] adder_sum, // Input from binary adder\n    input shift_q,         // Input from shift register\n    output [102:0] out     // Final output\n);\n\n    wire [102:0] final_out; // Internal wire to hold the final output\n\n    assign final_out = {adder_sum, shift_q};\n\n    assign out = final_out;\n\nendmodule\n\nmodule top_module (\n    input [99:0] a, b,     // Inputs to the binary adder\n    input cin,             // Carry-in for the binary adder\n    output cout,           // Carry-out from the binary adder\n    output [99:0] sum,     // Sum output from the binary adder\n    input clk,             // Clock input for the shift register\n    input d,               // Input to the shift register\n    output q,              // Output from the shift register\n    output [102:0] out     // Final output from the functional module\n);\n\n    binary_adder adder_inst (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .cout(cout),\n        .sum(sum)\n    );\n\n    shift_register shift_reg_inst (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    functional_module func_inst (\n        .adder_sum(sum),\n        .shift_q(q),\n        .out(out)\n    );\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "2e437bfc2c884a7d03074b4351612b5e",
        "dataset_index": 1809
      },
      "clock_gate_92573cfb": {
        "rtl_code": "module clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n\n  reg gated_clk;\n\n  always @(posedge CLK) begin\n    if (EN && TE) begin\n      gated_clk <= 1'b1;\n    end else begin\n      gated_clk <= 1'b0;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "92573cfb13df59d72d264ce7572e6cb2",
        "dataset_index": 2136
      },
      "asram16_if_4ea0f906": {
        "rtl_code": "module asram16_if \n(\n    clk_i, \n    rst_i, \n    timing_ctrl_i,\n    \n    sram_address_o, \n    sram_data_o, \n    sram_data_i, \n    sram_oe_o, \n    sram_cs_o, \n    sram_be_o, \n    sram_we_o, \n    sram_dir_out_o, \n    \n    address_i, \n    data_i, \n    data_o, \n    rd_i, \n    wr_i, \n    ack_o, \n    busy_o \n);\n\nparameter  [31:0]       EXT_ADDR_WIDTH = 17;\n    \ninput                   clk_i ;\ninput                   rst_i ;\ninput [(32 - 1):0]      timing_ctrl_i ;\noutput [(EXT_ADDR_WIDTH - 1):0]  sram_address_o ;\noutput [(16 - 1):0]     sram_data_o ;\ninput [(16 - 1):0]      sram_data_i ;\noutput                  sram_oe_o ;\noutput                  sram_cs_o ;\noutput [(2 - 1):0]      sram_be_o ;\noutput                  sram_we_o ;\noutput                  sram_dir_out_o ;\ninput [(32 - 1):0]      address_i ;\ninput [(32 - 1):0]      data_i ;\noutput [(32 - 1):0]     data_o ;\ninput                   rd_i ;\ninput [(4 - 1):0]       wr_i ;\noutput                  ack_o ;\noutput                  busy_o ;\n\nreg [3:0]                reg_state;\nparameter MEM_IDLE          = 4'd0;\nparameter MEM_WRITE_DATA1   = 4'd1;\nparameter MEM_WRITE_SETUP2  = 4'd2;\nparameter MEM_WRITE_DATA2   = 4'd3;\nparameter MEM_READ_DATA1    = 4'd4;\nparameter MEM_READ_DATA2    = 4'd5;\nparameter MEM_READ_WAIT1    = 4'd6;\nparameter MEM_READ_WAIT2    = 4'd7;\nparameter MEM_WRITE_WAIT1   = 4'd8;\nparameter MEM_WRITE_WAIT2   = 4'd9;\nparameter MEM_WRITE_HOLD    = 4'd10;\n\nreg [(EXT_ADDR_WIDTH - 1):0] v_reg_address;\nreg [(EXT_ADDR_WIDTH - 1):0] reg_address;\nreg [(32 - 1):0]             reg_data_o;\nreg [(32 - 1):0]             reg_data_i;\nreg [(4 - 1):0]              reg_wr;\nreg [3:0]                    reg_wait;\nreg [(EXT_ADDR_WIDTH - 1):0] sram_address_o;\nreg [(16 - 1):0]             sram_data_o;\nreg                          sram_oe_o;\nwire                         sram_cs_o;\nreg [(2 - 1):0]              sram_be_o;\nreg                          sram_we_o;\nreg                          sram_dir_out_o;\nwire [(32 - 1):0]            data_o;\nreg                          ack_o;\nwire                         busy_o;\n\nalways @ (posedge clk_i or posedge rst_i )\nbegin \n   if (rst_i == 1'b1)\n   begin \n       sram_oe_o        <= 1'b1;\n       sram_we_o        <= 1'b1;\n       sram_address_o   <= {(EXT_ADDR_WIDTH - 0){1'b0}};\n       sram_data_o      <= 16'h0000;\n       sram_be_o        <= 2'b11;\n       sram_dir_out_o   <= 1'b1;\n       \n       ack_o            <= 1'b0;\n       \n       reg_address      <= {(EXT_ADDR_WIDTH - 0){1'b0}};\n       reg_data_o       <= 32'h00000000;\n       reg_data_i       <= 32'h00000000;\n       reg_wr           <= 4'b0000;\n       reg_wait         <= 4'b0000;\n       reg_state        <= MEM_IDLE;       \n   end\n   else \n   begin \n   \n       ack_o <= 1'b0;\n       \n       case (reg_state)\n       \n       MEM_IDLE : \n       begin\n\n           v_reg_address = address_i[EXT_ADDR_WIDTH:1];\n           \n           if (wr_i != 4'b0000) \n           begin\n           \n               reg_address  <= v_reg_address;\n               reg_data_o   <= data_i;\n               reg_data_i   <= 32'h00000000;\n               reg_wr       <= wr_i;\n               \n               sram_dir_out_o    <= 1'b1;\n               \n               if (wr_i[3:2] != 2'b00)\n               begin\n                   sram_address_o   <= v_reg_address;\n                   sram_data_o      <= data_i[31:16];\n                   sram_be_o        <= ~wr_i[3:2];\n                   sram_we_o        <= 1'b0;\n                   \n                   if (timing_ctrl_i[3:0] != 4'b0000)\n                   begin\n                        reg_wait    <= timing_ctrl_i[3:0];\n                        reg_state   <= MEM_WRITE_WAIT1;\n                   end\n                   else\n                        reg_state   <= MEM_WRITE_DATA1;\n               end\n               else \n               begin \n                   sram_address_o   <= (v_reg_address + 1);\n                   sram_data_o      <= data_i[15:0];\n                   sram_be_o        <= ~wr_i[1:0];\n                   sram_we_o        <= 1'b0;\n\n                   if (timing_ctrl_i[3:0] != 4'b0000)\n                   begin\n                        reg_wait    <= timing_ctrl_i[3:0];\n                        reg_state   <= MEM_WRITE_WAIT2;\n                   end\n                   else\n                        reg_state   <= MEM_WRITE_DATA2;\n               end\n           end\n           else if (rd_i == 1'b1)\n           begin\n           \n               reg_address      <= v_reg_address;\n               reg_data_o       <= 32'h00000000;\n               reg_data_i       <= 32'h00000000;\n               reg_wr           <= 4'b0000;\n               \n               sram_address_o   <= v_reg_address;\n               sram_data_o      <= 16'h0000;\n               sram_be_o        <= 2'b00;\n               sram_we_o        <= 1'b1;\n               sram_oe_o        <= 1'b0;\n               sram_dir_out_o   <= 1'b0;\n               \n               if (timing_ctrl_i[7:4] != 4'b0000)\n               begin\n                    reg_wait    <= timing_ctrl_i[7:4];\n                    reg_state   <= MEM_READ_WAIT1;\n               end\n               else\n                    reg_state   <= MEM_READ_DATA1;\n           end\n           else \n           begin \n               sram_dir_out_o   <= 1'b1;\n               reg_state        <= MEM_IDLE;\n           end\n       end\n       MEM_WRITE_DATA1 : \n       begin\n           sram_we_o    <= 1'b1;\n           \n           reg_address    <= (reg_address + 1);\n           \n           if (reg_wr[1:0]!=2'b00)\n           begin\n\n               if (timing_ctrl_i[11:8] != 4'b0000)\n               begin\n                    reg_wait    <= timing_ctrl_i[11:8];\n                    reg_state   <= MEM_WRITE_HOLD;\n               end\n               else\n                    reg_state   <= MEM_WRITE_SETUP2;\n           end\n           else \n           begin \n               reg_state    <= MEM_IDLE;\n               ack_o        <= 1'b1;\n           end\n       end\n       MEM_WRITE_SETUP2 : \n       begin\n           sram_address_o   <= reg_address;\n           sram_be_o        <= ~reg_wr[1:0];\n           sram_data_o      <= reg_data_o[15:0];\n           sram_we_o        <= 1'b0;\n           \n           if (timing_ctrl_i[3:0] != 4'b0000)\n           begin\n                reg_wait    <= timing_ctrl_i[3:0];\n                reg_state   <= MEM_WRITE_WAIT2;\n           end\n           else\n                reg_state   <= MEM_WRITE_DATA2;\n       end\n       MEM_WRITE_DATA2 : \n       begin \n           sram_we_o    <= 1'b1;\n           \n           reg_state    <= MEM_IDLE;\n           ack_o        <= 1'b1;\n       end\n       MEM_READ_DATA1 : \n       begin \n           sram_oe_o    <= 1'b0;\n           \n           reg_data_i    <= {sram_data_i[15:0],16'h0000};\n           \n           v_reg_address = (reg_address + 1);\n           \n           sram_address_o <= v_reg_address[(EXT_ADDR_WIDTH - 1):0];\n           reg_address    <= v_reg_address;\n           \n           if (timing_ctrl_i[7:4] != 4'b0000)\n           begin\n                reg_wait    <= timing_ctrl_i[7:4];\n                reg_state   <= MEM_READ_WAIT2;\n           end\n           else\n                reg_state   <= MEM_READ_DATA2;\n       end\n       MEM_READ_DATA2 : \n       begin\n           reg_data_i    <= {reg_data_i[31:16],sram_data_i[15:0]};\n           \n           sram_oe_o    <= 1'b1;\n           \n           ack_o        <= 1'b1;\n           reg_state    <= MEM_IDLE;\n       end\n       MEM_READ_WAIT1 : \n       begin\n            reg_wait    <= reg_wait - 1;\n            \n            if (reg_wait == 4'b0001)\n            begin\n                reg_state   <= MEM_READ_DATA1;\n            end\n       end       \n       MEM_READ_WAIT2 : \n       begin\n            reg_wait    <= reg_wait - 1;\n            \n            if (reg_wait == 4'b0001)\n            begin\n                reg_state   <= MEM_READ_DATA2;\n            end\n       end      \n       \n       MEM_WRITE_WAIT1 : \n       begin\n            reg_wait    <= reg_wait - 1;\n            \n            if (reg_wait == 4'b0001)\n            begin\n                reg_state   <= MEM_WRITE_DATA1;\n            end\n       end       \n       MEM_WRITE_WAIT2 : \n       begin\n            reg_wait    <= reg_wait - 1;\n            \n            if (reg_wait == 4'b0001)\n            begin\n                reg_state   <= MEM_WRITE_DATA2;\n            end\n       end\n       MEM_WRITE_HOLD : \n       begin\n            reg_wait    <= reg_wait - 1;\n            \n            if (reg_wait == 4'b0001)\n            begin\n                reg_state   <= MEM_WRITE_SETUP2;\n            end\n       end         \n       \n       default : \n            reg_state   <= MEM_IDLE;\n       endcase\n   end\nend\n   \nassign data_o        = reg_data_i;\nassign busy_o        = (reg_state != MEM_IDLE) ? 1'b1 : 1'b0;\nassign sram_cs_o     = 1'b0;\n\nendmodule\n",
        "module_name": "asram16_if",
        "module_hash": "4ea0f9061040e7469f1ba7ee7f7eef7c",
        "dataset_index": 7875
      },
      "FSM #_0c1a60be": {
        "rtl_code": "\nmodule FSM #(\n  parameter n = 8, // number of states\n  parameter k = 3, // number of bits required to represent states in traditional encoding\n  parameter l = 2, // number of bits required to represent states in compressed encoding\n  parameter m = 2\n)(\n  input clk,\n  input reset,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\n\nreg [k-1:0] state; // traditional state encoding\nreg [l-1:0] compressed_state; // compressed state encoding\n\n// define the states and transitions of the FSM\nlocalparam STATE_A = 3'b000;\nlocalparam STATE_B = 3'b001;\nlocalparam STATE_C = 3'b010;\nlocalparam STATE_D = 3'b011;\nlocalparam STATE_E = 3'b100;\nlocalparam STATE_F = 3'b101;\nlocalparam STATE_G = 3'b110;\nlocalparam STATE_H = 3'b111;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    state <= STATE_A;\n    compressed_state <= 2'b00;\n  end else begin\n    case (state)\n      STATE_A: begin\n        if (in == 1) begin\n          state <= STATE_B;\n          compressed_state <= 2'b01;\n        end else begin\n          state <= STATE_C;\n          compressed_state <= 2'b10;\n        end\n      end\n      STATE_B: begin\n        if (in == 0) begin\n          state <= STATE_C;\n          compressed_state <= 2'b10;\n        end else begin\n          state <= STATE_D;\n          compressed_state <= 2'b11;\n        end\n      end\n      STATE_C: begin\n        if (in == 1) begin\n          state <= STATE_D;\n          compressed_state <= 2'b11;\n        end else begin\n          state <= STATE_E;\n          compressed_state <= 2'b00;\n        end\n      end\n      STATE_D: begin\n        if (in == 0) begin\n          state <= STATE_E;\n          compressed_state <= 2'b00;\n        end else begin\n          state <= STATE_F;\n          compressed_state <= 2'b01;\n        end\n      end\n      STATE_E: begin\n        if (in == 1) begin\n          state <= STATE_F;\n          compressed_state <= 2'b01;\n        end else begin\n          state <= STATE_G;\n          compressed_state <= 2'b10;\n        end\n      end\n      STATE_F: begin\n        if (in == 0) begin\n          state <= STATE_G;\n          compressed_state <= 2'b10;\n        end else begin\n          state <= STATE_H;\n          compressed_state <= 2'b11;\n        end\n      end\n      STATE_G: begin\n        if (in == 1) begin\n          state <= STATE_H;\n          compressed_state <= 2'b11;\n        end else begin\n          state <= STATE_A;\n          compressed_state <= 2'b00;\n        end\n      end\n      STATE_H: begin\n        if (in == 0) begin\n          state <= STATE_A;\n          compressed_state <= 2'b00;\n        end else begin\n          state <= STATE_B;\n          compressed_state <= 2'b01;\n        end\n      end\n    endcase\n  end\nend\n\n// use the updated state representation to control the output signals\nassign out = (compressed_state == 2'b00) ? 2'b00 :\n              (compressed_state == 2'b01) ? 2'b01 :\n              (compressed_state == 2'b10) ? 2'b10 :\n              (compressed_state == 2'b11) ? 2'b11 :\n              2'bx;\n\nendmodule\n",
        "module_name": "FSM #",
        "module_hash": "0c1a60be9f0a83835b92ba2bd3a58986",
        "dataset_index": 18302
      },
      "ecfg_7431f3b5": {
        "rtl_code": "\n\n\n\n`define E_REG_SYSRESET    20'hf0340\n`define E_REG_SYSCFGTX    20'hf0344\n`define E_REG_SYSCFGRX    20'hf0348\n`define E_REG_SYSCFGCLK   20'hf034c\n`define E_REG_SYSCOREID   20'hf0350\n`define E_REG_SYSVERSION  20'hf0354\n`define E_REG_SYSDATAIN   20'hf0358\n`define E_REG_SYSDATAOUT  20'hf035c\n`define E_VERSION         32'h01_02_03_04\n\nmodule ecfg (\n   mi_data_out, mi_data_sel, ecfg_sw_reset, ecfg_reset,\n   ecfg_tx_enable, ecfg_tx_mmu_mode, ecfg_tx_gpio_mode,\n   ecfg_tx_ctrl_mode, ecfg_tx_clkdiv, ecfg_rx_enable,\n   ecfg_rx_mmu_mode, ecfg_rx_gpio_mode, ecfg_rx_loopback_mode,\n   ecfg_cclk_en, ecfg_cclk_div, ecfg_cclk_pllcfg, ecfg_coreid,\n   ecfg_gpio_dataout,\n   param_coreid, clk, hw_reset, mi_access, mi_write, mi_addr,\n   mi_data_in\n   );\n   \nparameter EMAW   = 12;   parameter EDW    = 32;  parameter EAW    = 32;  parameter IDW    = 12;  parameter RFAW   = 5;   \n   \n   \n   input [IDW-1:0] param_coreid;\n   \n   \n   \n   \n   input              clk;   \n   input              hw_reset;\n   input              mi_access;\n   input              mi_write;\n   input  [19:0]      mi_addr;\n   input  [31:0]      mi_data_in;\n   output [31:0]      mi_data_out;\n   output \t      mi_data_sel;\n  \n   \n   \n   \n   output \t      ecfg_sw_reset;\n   output \t      ecfg_reset;\n\n   output \t     ecfg_tx_enable;         output \t     ecfg_tx_mmu_mode;       output \t     ecfg_tx_gpio_mode;      output [3:0]\t     ecfg_tx_ctrl_mode;      output [3:0]      ecfg_tx_clkdiv;         output \t     ecfg_rx_enable;         output \t     ecfg_rx_mmu_mode;       output \t     ecfg_rx_gpio_mode;      output \t     ecfg_rx_loopback_mode;  output \t     ecfg_cclk_en;           output [3:0]      ecfg_cclk_div;          output [3:0]      ecfg_cclk_pllcfg;       output [11:0]     ecfg_coreid;            output [11:0]     ecfg_gpio_dataout;      reg [11:0] \tecfg_cfgtx_reg;\n   reg [4:0] \tecfg_cfgrx_reg;\n   reg [7:0] \tecfg_cfgclk_reg;\n   reg [11:0] \tecfg_coreid_reg;\n   wire [31:0] \tecfg_version_reg;\n   reg \t\tecfg_reset_reg;\n   reg [11:0] \tecfg_gpio_datain_reg;\n   reg [11:0] \tecfg_gpio_dataout_reg;\n   reg [31:0] \tmi_data_out;\n   reg \t\tmi_data_sel;\n\n   wire \tecfg_read;\n   wire \tecfg_write;\n   wire \tecfg_reset_match;\n   wire \tecfg_cfgtx_match;\n   wire \tecfg_cfgrx_match;\n   wire \tecfg_cfgclk_match;\n   wire \tecfg_coreid_match;\n   wire \tecfg_version_match;\n   wire \tecfg_datain_match;\n   wire \tecfg_dataout_match;\n   wire         ecfg_match;\n   wire \tecfg_regmux;\n   wire [31:0] \tecfg_reg_mux;\n   wire \tecfg_cfgtx_write;\n   wire \tecfg_cfgrx_write;\n   wire \tecfg_cfgclk_write;\n   wire \tecfg_coreid_write;\n   wire \tecfg_version_write;\n   wire \tecfg_datain_write;\n   wire \tecfg_dataout_write;\n   wire \tecfg_rx_monitor_mode;\n   wire \tecfg_reset_write;\n   \n   \n   \n   \n\n   assign ecfg_write      = mi_access & mi_write;\n   assign ecfg_read       = mi_access & ~mi_write;   \n\n   assign ecfg_reset_match     = mi_addr[19:0]==`E_REG_SYSRESET;\n   assign ecfg_cfgtx_match     = mi_addr[19:0]==`E_REG_SYSCFGTX;\n   assign ecfg_cfgrx_match     = mi_addr[19:0]==`E_REG_SYSCFGRX;\n   assign ecfg_cfgclk_match    = mi_addr[19:0]==`E_REG_SYSCFGCLK;\n   assign ecfg_coreid_match    = mi_addr[19:0]==`E_REG_SYSCOREID;\n   assign ecfg_version_match   = mi_addr[19:0]==`E_REG_SYSVERSION;\n   assign ecfg_datain_match    = mi_addr[19:0]==`E_REG_SYSDATAIN;\n   assign ecfg_dataout_match   = mi_addr[19:0]==`E_REG_SYSDATAOUT;\n\n   assign ecfg_match           = ecfg_reset_match   |\n\t\t\t\t ecfg_cfgtx_match   |\n\t\t\t\t ecfg_cfgrx_match   |\n\t\t\t\t ecfg_cfgclk_match  |\n\t\t\t\t ecfg_coreid_match  |\n\t\t\t\t ecfg_version_match |\n\t\t\t\t ecfg_datain_match  |\n\t\t\t\t ecfg_dataout_match;\n   \n\t\t\t\t\n   assign ecfg_reset_write     = ecfg_reset_match   & ecfg_write;\n   assign ecfg_cfgtx_write     = ecfg_cfgtx_match   & ecfg_write;\n   assign ecfg_cfgrx_write     = ecfg_cfgrx_match   & ecfg_write;\n   assign ecfg_cfgclk_write    = ecfg_cfgclk_match  & ecfg_write;\n   assign ecfg_coreid_write    = ecfg_coreid_match  & ecfg_write;\n   assign ecfg_version_write   = ecfg_version_match & ecfg_write;\n   assign ecfg_datain_write    = ecfg_datain_match  & ecfg_write;\n   assign ecfg_dataout_write   = ecfg_dataout_match & ecfg_write;\n\n   \n   always @ (posedge clk)\n     if(hw_reset)\n       ecfg_cfgtx_reg[11:0] <= 12'b0;\n     else if (ecfg_cfgtx_write)\n       ecfg_cfgtx_reg[11:0] <= mi_data_in[11:0];\n\n   assign ecfg_tx_enable         = ecfg_cfgtx_reg[0];\n   assign ecfg_tx_mmu_mode       = ecfg_cfgtx_reg[1];   \n   assign ecfg_tx_gpio_mode      = ecfg_cfgtx_reg[3:2]==2'b01;\n   assign ecfg_tx_ctrl_mode[3:0] = ecfg_cfgtx_reg[7:4];\n   assign ecfg_tx_clkdiv[3:0]    = ecfg_cfgtx_reg[11:8];\n\n   always @ (posedge clk)\n     if(hw_reset)\n       ecfg_cfgrx_reg[4:0] <= 5'b0;\n     else if (ecfg_cfgrx_write)\n       ecfg_cfgrx_reg[4:0] <= mi_data_in[4:0];\n\n   assign ecfg_rx_enable        = ecfg_cfgrx_reg[0];\n   assign ecfg_rx_mmu_mode      = ecfg_cfgrx_reg[1];   \n   assign ecfg_rx_gpio_mode     = ecfg_cfgrx_reg[3:2]==2'b01;\n   assign ecfg_rx_loopback_mode = ecfg_cfgrx_reg[3:2]==2'b10;\n   assign ecfg_rx_monitor_mode  = ecfg_cfgrx_reg[4];\n\n   always @ (posedge clk)\n     if(hw_reset)\n       ecfg_cfgclk_reg[7:0] <= 8'b0;\n     else if (ecfg_cfgclk_write)\n       ecfg_cfgclk_reg[7:0] <= mi_data_in[7:0];\n\n   assign ecfg_cclk_en             = ~(ecfg_cfgclk_reg[3:0]==4'b0000);   \n   assign ecfg_cclk_div[3:0]       = ecfg_cfgclk_reg[3:0];\n   assign ecfg_cclk_pllcfg[3:0]    = ecfg_cfgclk_reg[7:4];\n\n   always @ (posedge clk)\n     if(hw_reset)\n       ecfg_coreid_reg[IDW-1:0] <= param_coreid[IDW-1:0];\n     else if (ecfg_coreid_write)\n       ecfg_coreid_reg[IDW-1:0] <= mi_data_in[IDW-1:0];   \n   \n   assign ecfg_coreid[IDW-1:0] = ecfg_coreid_reg[IDW-1:0];\n\n   assign ecfg_version_reg[31:0] = `E_VERSION;\n\n   always @ (posedge clk)\n     if(hw_reset)\n       ecfg_gpio_datain_reg[11:0] <= 12'b0;   \n     else if (ecfg_datain_write)\n       ecfg_gpio_datain_reg[11:0] <= mi_data_in[11:0];  \n\n   always @ (posedge clk)\n     if(hw_reset)\n       ecfg_gpio_dataout_reg[11:0] <= 12'b0;   \n     else if (ecfg_dataout_write)\n       ecfg_gpio_dataout_reg[11:0] <= mi_data_in[11:0];  \n\n   assign ecfg_gpio_dataout[11:0] = ecfg_gpio_dataout_reg[11:0];\n   \n   always @ (posedge clk)\n      if(hw_reset)\n\tecfg_reset_reg <= 1'b0;   \n      else if (ecfg_reset_write)\n\tecfg_reset_reg <= mi_data_in[0];  \n\n   assign ecfg_sw_reset = ecfg_reset_reg;\n   assign ecfg_reset    = ecfg_sw_reset | hw_reset;\n   \n   assign ecfg_reg_mux[31:0] =   ({(32){ecfg_reset_match}}   & {20'b0,ecfg_cfgtx_reg[11:0]})        |\n\t\t\t\t ({(32){ecfg_cfgtx_match}}   & {20'b0,ecfg_cfgtx_reg[11:0]})        |\n\t\t\t\t ({(32){ecfg_cfgrx_match}}   & {27'b0,ecfg_cfgrx_reg[4:0]})         |\n\t\t\t\t ({(32){ecfg_cfgclk_match}}  & {24'b0,ecfg_cfgclk_reg[7:0]})        |\n\t\t\t\t ({(32){ecfg_coreid_match}}  & {20'b0,ecfg_coreid_reg[11:0]})       |\n\t\t\t\t ({(32){ecfg_version_match}} & ecfg_version_reg[31:0])              |\n\t\t\t\t ({(32){ecfg_datain_match}}  & {20'b0,ecfg_gpio_datain_reg[11:0]})  |\n\t\t\t\t ({(32){ecfg_dataout_match}} & {20'b0,ecfg_gpio_dataout_reg[11:0]}) ;\n      \n   always @ (posedge clk)\n     if(ecfg_read)\n       begin\n\t  mi_data_out[31:0] <= ecfg_reg_mux[31:0];\n\t  mi_data_sel       <= ecfg_match;\n       end\nendmodule ",
        "module_name": "ecfg",
        "module_hash": "7431f3b5e06b55577359cc1e58726712",
        "dataset_index": 4613
      },
      "SP_RAM_32x512_f5489161": {
        "rtl_code": "\nmodule SP_RAM_32x512(\n    input clk,\n    input rce,\n    input [8:0] ra,\n    output reg [31:0] rq,\n    input wce,\n    input [8:0] wa,\n    input [31:0] wd\n);\n\nparameter AWIDTH = 9;\nparameter DWIDTH = 32;\n\nreg [DWIDTH-1:0] bram_out;\nwire [DWIDTH-1:0] bram_in;\n\nassign bram_in = wce ? wd : {DWIDTH{1'b0}};\n\nBRAM_SDP_32x512 #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\nBRAM_32x512 (.clk(clk),\n                     .rce(rce),\n                     .ra(ra),\n                     .rq(bram_out),\n                     .wce(wce),\n                     .wa(wa),\n                     .wd(bram_in));\n\nalways @(posedge clk) begin\n    if (rce) begin\n        rq <= bram_out;\n    end\nend\n\nendmodule\nmodule BRAM_SDP_32x512 (\n    input clk,\n    input rce,\n    input [8:0] ra,\n    output reg [31:0] rq,\n    input wce,\n    input [8:0] wa,\n    input [31:0] wd\n);\n\nparameter AWIDTH = 9;\nparameter DWIDTH = 32;\n\nreg [DWIDTH-1:0] memory [0:511];\n\nalways @(posedge clk) begin\n    if (wce) begin\n        memory[wa] <= wd;\n    end\n    if (rce) begin\n        rq <= memory[ra];\n    end\nend\n\nendmodule",
        "module_name": "SP_RAM_32x512",
        "module_hash": "f54891618f28acdf483059e2f04d3e09",
        "dataset_index": 1304
      },
      "sky130_fd_sc_hd__clkinvlp_2d8c1670": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__clkinvlp (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__clkinvlp",
        "module_hash": "2d8c1670dbcf1dfd7dda9e532f9ef834",
        "dataset_index": 23345
      },
      "top__f044fd1c": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input a,\n    input b,\n    input sel_b1,\n    output q\n);\n\n    wire mux_out;\n    wire flip_flop_out;\n    wire final_out;\n\n    // 2-to-1 mux\n    mux_2to1 mux_inst (\n        .a(a),\n        .b(b),\n        .sel(sel_b1),\n        .out(mux_out)\n    );\n\n    // Positive edge triggered flip-flop\n    posedge_edge_ff ff_inst (\n        .clk(clk),\n        .data(mux_out),\n        .out(flip_flop_out)\n    );\n\n    // Functional module\n    functional_module func_inst (\n        .a(mux_out),\n        .b(flip_flop_out),\n        .out(final_out)\n    );\n\n    // Output\n    assign q = final_out;\n\nendmodule\nmodule mux_2to1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = (sel == 1'b0) ? a : b;\nendmodule\nmodule posedge_edge_ff (\n    input clk,\n    input data,\n    output out\n);\n    reg ff;\n\n    always @(posedge clk) begin\n        ff <= data;\n    end\n\n    assign out = ff;\n\nendmodule\nmodule functional_module (\n    input a,\n    input b,\n    output out\n);\n    assign out = a + b;\nendmodule",
        "module_name": "top_",
        "module_hash": "f044fd1cf4dc0332788a09a660c60298",
        "dataset_index": 12312
      },
      "reset_synchronizer_da5f5111": {
        "rtl_code": "module reset_synchronizer (\n  input reset_n,\n  input clk,\n  output reset\n);\n\n  reg reset_synced;\n  reg [1:0] reset_synced_d;\n\n  always @(posedge clk) begin\n    reset_synced_d <= {reset_synced, reset_n};\n    reset_synced <= reset_synced_d[1] & ~reset_synced_d[0];\n  end\n\n  assign reset = reset_synced;\n\nendmodule",
        "module_name": "reset_synchronizer",
        "module_hash": "da5f5111835b066c68cfad2964b63c4a",
        "dataset_index": 3602
      },
      "mux_2to1_03e9b6b3": {
        "rtl_code": "module mux_2to1(input [1:0] data, input ctrl, output reg out);\n\nreg [1:0] stage1_data;\nreg stage1_ctrl;\n\nalways @(*) begin\n    stage1_data <= data;\n    stage1_ctrl <= ctrl;\nend\n\nreg [1:0] stage2_data;\nreg stage2_ctrl;\n\nalways @(*) begin\n    stage2_data <= stage1_data;\n    stage2_ctrl <= stage1_ctrl;\nend\n\nreg [1:0] stage3_data;\nreg stage3_ctrl;\n\nalways @(*) begin\n    stage3_data <= stage2_data;\n    stage3_ctrl <= stage2_ctrl;\nend\n\nreg [1:0] stage4_data;\nreg stage4_ctrl;\n\nalways @(*) begin\n    stage4_data <= stage3_data;\n    stage4_ctrl <= stage3_ctrl;\nend\n\nalways @(*) begin\n    case (stage4_ctrl)\n        1'b0: out <= stage4_data[0];\n        1'b1: out <= stage4_data[1];\n    endcase\nend\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "03e9b6b3bbc885fda558fee5e77a5c18",
        "dataset_index": 7685
      },
      "binary_to_3bit_decoder_f746b370": {
        "rtl_code": "\nmodule binary_to_3bit_decoder (\n    input wire [2:0] in,\n    output wire o0,\n    output wire o1,\n    output wire o2\n);\n\nassign o0 = in[0];\nassign o1 = in[1];\nassign o2 = in[2];\n\nendmodule\nmodule nor_gate_using_nand (\n    input wire a,\n    input wire b,\n    output wire out\n);\n\nassign out = !(a & b);\n\nendmodule\nmodule top_module (\n    input wire [2:0] vec,\n    input wire a,\n    input wire b,\n    output wire out\n);\n\nwire o0, o1, o2;\n\nbinary_to_3bit_decoder decoder(vec, o0, o1, o2);\nnor_gate_using_nand nor_gate(o0, o1, out);\n\nendmodule",
        "module_name": "binary_to_3bit_decoder",
        "module_hash": "f746b3708a555a12489d81ce0b7f0e00",
        "dataset_index": 559
      },
      "true_dual_port_ram_24e323af": {
        "rtl_code": "\nmodule true_dual_port_ram (\n    input clk,\n    input read_en,\n    input [2:0] read_addr,\n    output reg [3:0] read_data,\n    input write_en,\n    input [2:0] write_addr,\n    input [3:0] write_data\n);\n\nreg [3:0] ram [7:0];\n\nalways @(posedge clk) begin\n    if (write_en) begin\n        ram[write_addr] <= write_data;\n    end\nend\n\nalways @(*) begin\n    if (read_en) begin\n        read_data <= ram[read_addr];\n    end else begin\n        read_data <= 4'b0000;\n    end\nend\n\nendmodule\nmodule counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\nmodule register_8bit (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\nmodule arithmetic_logic (\n    input [3:0] counter_data,\n    input [7:0] register_data,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    result = {4'b0000, counter_data} + register_data;\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input select,\n    output reg [7:0] q\n);\n\nwire [3:0] counter_output;\nwire [7:0] register_output;\nwire [7:0] arithmetic_output;\n\ncounter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .count(counter_output)\n);\n\nregister_8bit register_inst (\n    .clk(clk),\n    .reset(reset),\n    .d(d),\n    .q(register_output)\n);\n\narithmetic_logic arithmetic_inst (\n    .counter_data(counter_output),\n    .register_data(register_output),\n    .result(arithmetic_output)\n);\n\nalways @(posedge clk) begin\n    if (select) begin\n        q <= register_output;\n    end else begin\n        q <= arithmetic_output;\n    end\nend\n\nendmodule",
        "module_name": "true_dual_port_ram",
        "module_hash": "24e323af2e73f0bdece235e6c9f5616c",
        "dataset_index": 12255
      },
      "calculator_e62273f4": {
        "rtl_code": "module calculator(\n    input  [31:0] a,\n    input  [31:0] b,\n    input  reset_n,\n    output  reg [31:0] add,\n    output  reg [31:0] sub,\n    output  reg [31:0] mul,\n    output  reg [31:0] div\n);\n\n    always @(a, b, reset_n) begin\n        if(!reset_n) begin\n            add <= 0;\n            sub <= 0;\n            mul <= 0;\n            div <= 0;\n        end else begin\n            add <= a + b;\n            sub <= a - b;\n            mul <= a * b;\n            if(b != 0) begin\n                div <= a / b;\n            end else begin\n                div <= 0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "e62273f4db26ac6e494b270e817624c6",
        "dataset_index": 0
      },
      "arriaiigz_lvds_tx_parallel_register_951cfa61": {
        "rtl_code": "module arriaiigz_lvds_tx_parallel_register (\n    input clk,\n    input enable,\n    input [3:0] datain,\n    input devclrn,\n    input devpor,\n    output reg [3:0] dataout\n);\n\n    always @ (posedge clk) begin\n        if (devpor == 1'b0 || devclrn == 1'b0) begin\n            dataout <= 4'b0;\n        end else if (enable == 1'b1) begin\n            dataout <= datain;\n        end\n    end\n\nendmodule",
        "module_name": "arriaiigz_lvds_tx_parallel_register",
        "module_hash": "951cfa61dc40585f07303e96de9faf8c",
        "dataset_index": 6336
      },
      "sky130_fd_sc_hdll__a22o_f30865a8": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__a22o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2            );\n    and and1 (and1_out , A1, A2            );\n    or  or0  (or0_out_X, and1_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__a22o",
        "module_hash": "f30865a8635f8950788ff1426a5c10a0",
        "dataset_index": 22595
      },
      "sky130_fd_sc_lp__udp_mux_2to1_N_f3040828": {
        "rtl_code": "module sky130_fd_sc_lp__udp_mux_2to1_N (\n    //# {{data|Data Signals}}\n    input  A0,\n    input  A1,\n    output Y ,\n\n    //# {{control|Control Signals}}\n    input  S\n);\n    wire notS;\n    assign notS = ~S;\n    assign Y = (notS & A0) | (S & A1);\nendmodule",
        "module_name": "sky130_fd_sc_lp__udp_mux_2to1_N",
        "module_hash": "f30408281074f7dc6d3b5f33a1909440",
        "dataset_index": 16723
      },
      "vga_palette_regs_fml_19a63345": {
        "rtl_code": "\n\nmodule vga_palette_regs_fml (\n    input clk,\n\n    input      [3:0] attr,\n    output reg [7:0] index,\n\n    input      [3:0] address,\n    input            write,\n    output reg [7:0] read_data,\n    input      [7:0] write_data\n  );\n\n  reg [7:0] palette [0:15];\n\n  always @(posedge clk) index <= palette[attr];\n\n  always @(posedge clk) read_data <= palette[address];\n\n  always @(posedge clk)\n    if (write) palette[address] <= write_data;\n\nendmodule\n",
        "module_name": "vga_palette_regs_fml",
        "module_hash": "19a63345cf1681bd82f009e015f8ed53",
        "dataset_index": 24771
      },
      "my_memory_245a317c": {
        "rtl_code": "\nmodule my_memory(\n  input clka,\n  input [15 : 0] addra,\n  output [11 : 0] douta,\n  input ena,\n  input regcea,\n  input wea,\n  input [11 : 0] dina,\n  input rst\n);\n\n\nreg [11 : 0] mem [256 : 0];\n\n  always @ (posedge clka)\n  begin\n    if (ena & regcea & wea)\n      mem[addra] <= dina;\n  end\n\n  assign douta = (ena & regcea) ? mem[addra] : 12'b0;\n\nendmodule",
        "module_name": "my_memory",
        "module_hash": "245a317cf7269f87ac195c61ee0bebef",
        "dataset_index": 9011
      },
      "alu_49e0ed3d": {
        "rtl_code": "module alu (A, B, function_sel,\n            aluout, zero_flag, parity_flag, carry_flag);\n\noutput [15:0] aluout;\noutput zero_flag, parity_flag, carry_flag;\ninput [15:0] A, B;\ninput [3:0] function_sel;\nreg [15:0] aluout;\nreg zero_flag, parity_flag, carry_flag;\n\n`define move 4'b0000 \n`define comp 4'b0001 \n`define and  4'b0010 \n`define or   4'b0011 \n`define xor  4'b0100 \n`define add  4'b0101 \n`define incr 4'b0110 \n`define sub  4'b0111 \n`define rotl 4'b1000 \n`define lshl 4'b1001 \n`define rotr 4'b1010 \n`define lshr 4'b1011 \n`define xnor 4'b1100 \n`define nor  4'b1101 \n`define decr 4'b1110 \n`define nand 4'b1111 \n\nalways @(A or B or function_sel)\n  begin\n   case (function_sel)\n        `move :  {carry_flag, aluout} = {1'b0, B};\n        `comp :  {carry_flag, aluout} = {1'b1, ~B};\n        `and  :  {carry_flag, aluout} = {1'b0, A & B};\n        `or   :  {carry_flag, aluout} = {1'b0, A | B};\n        `xor  :  {carry_flag, aluout} = {1'b0, A ^ B};\n        `add  :  {carry_flag, aluout} = A + B;\n        `incr :  {carry_flag, aluout} = B + 1;\n        `sub  :  {carry_flag, aluout} = {1'b1, A} - B;\n        `rotl :  {carry_flag, aluout} = {B[15:0], B[15]};\n        `lshl :  {carry_flag, aluout} = {B[15:0], 1'b0};\n        `rotr :  {carry_flag, aluout} = {B[0], B[0], B[15:1]};\n        `lshr :  {carry_flag, aluout} = {2'b0, B[15:1]};\n        `xnor :  {carry_flag, aluout} = {1'b1, A ~^ B};\n        `nor  :  {carry_flag, aluout} = {1'b1, ~(A | B)};\n        `decr :  {carry_flag, aluout} = B - 1;\n        `nand :  {carry_flag, aluout} = {1'b1, ~(A & B)};\n   endcase\n   zero_flag = ~|aluout;\n   parity_flag = ^aluout;\n  end\nendmodule\n",
        "module_name": "alu",
        "module_hash": "49e0ed3da7e4cfcaa4a67706b17e16dd",
        "dataset_index": 16790
      },
      "add4_ae5586df": {
        "rtl_code": "\nmodule add4(\n    input [3:0] A,\n    input [3:0] B,\n    output [4:0] C\n);\n\nwire [3:0] sum;\nwire carry_out;\n\nassign {carry_out, sum} = A + B;\n\nassign C[0] = sum[0];\nassign C[1] = sum[1];\nassign C[2] = sum[2];\nassign C[3] = sum[3];\nassign C[4] = carry_out;\n\nendmodule",
        "module_name": "add4",
        "module_hash": "ae5586dfb87eba9ff19f4863bb5c033a",
        "dataset_index": 15771
      },
      "output__e83178d1": {
        "rtl_code": "module output_module (\n  input clk,\n  input clkx2,\n  input jrst_n,\n  input [35:0] tw,\n  output reg tr_clk,\n  output reg [17:0] tr_data\n);\n\n  reg phase;\n  reg x1;\n  reg x2;\n\n  always @(posedge clk or negedge jrst_n) begin\n    if (!jrst_n) begin\n      x1 <= 1'b0;\n    end else begin\n      x1 <= ~x1;\n    end\n  end\n\n  always @(posedge clkx2 or negedge jrst_n) begin\n    if (!jrst_n) begin\n      x2 <= 1'b0;\n      tr_clk <= 1'b0;\n      tr_data <= 18'b0;\n    end else begin\n      x2 <= x1;\n      phase <= x1 ^ x2;\n      tr_clk <= ~phase;\n      tr_data <= phase ? tw[17:0] : tw[35:18];\n    end\n  end\n\nendmodule",
        "module_name": "output_",
        "module_hash": "e83178d142c7ec074dd05dd2b8730685",
        "dataset_index": 20681
      },
      "top__39df885c": {
        "rtl_code": "\nmodule top_module (\n    input [3:0] in0,\n    input [3:0] in1,\n    input DIR,\n    input [1:0] AMT,\n    output wire eq,\n    output wire gt,\n    output wire lt,\n    output wire [3:0] out\n);\n\nwire [3:0] shifted_in0;\n\n// Barrel shifter\nbarrel_shifter bs (\n    .in(in0),\n    .shift_dir(DIR),\n    .shift_amt(AMT),\n    .out(shifted_in0)\n);\n\n// Comparator\ncomparator cmp (\n    .in1(shifted_in0),\n    .in2(in1),\n    .eq(eq),\n    .gt(gt),\n    .lt(lt)\n);\n\n// Output\nassign out = shifted_in0;\n\nendmodule\n\nmodule barrel_shifter (\n    input [3:0] in,\n    input shift_dir,\n    input [1:0] shift_amt,\n    output [3:0] out\n);\n\nassign out = shift_dir ? in >> shift_amt : in << shift_amt;\n\nendmodule\n\nmodule comparator (\n    input [3:0] in1,\n    input [3:0] in2,\n    output eq,\n    output gt,\n    output lt\n);\n\nassign eq = (in1 == in2);\nassign gt = (in1 > in2);\nassign lt = (in1 < in2);\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "39df885c8cf80c14cf9b6e1979451350",
        "dataset_index": 7940
      },
      "UART_TX_28cac7ab": {
        "rtl_code": "module UART_TX(\n    input rst, clk, baud_edge, data_ready,\n    input [7:0] data,\n    output reg tx, data_accepted\n);\n    localparam START = (1 << 0), DATA = (1 << 1), END = (1 << 2);\n\n    reg [7:0] data_reg;\n    reg [2:0] data_counter;\n    reg [3:0] state;\n\n    initial begin\n        tx <= 1;\n        data_accepted <= 0;\n    end\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state <= END;\n            tx <= 1;\n            data_accepted <= 0;\n        end else if(baud_edge) begin\n            case(state)\n            START: begin\n                tx <= 0;\n                data_counter <= 0;\n                state <= DATA;\n            end\n            DATA: begin\n                tx <= data_reg[data_counter];\n                if(data_counter != 7) begin\n                    data_counter <= data_counter + 1;\n                end else begin\n                    state <= END;\n                    data_counter <= 0;\n                end\n            end\n            END: begin\n                tx <= 1;\n                if(data_ready) begin\n                    data_accepted <= 1;\n                    data_reg <= data;\n                    state <= START;\n                end\n            end\n            default: begin\n                tx <= 1;\n                state <= END;\n            end\n            endcase\n        end else begin\n            data_accepted <= 0;\n        end\n    end\nendmodule\n",
        "module_name": "UART_TX",
        "module_hash": "28cac7abcd36d02630c192ef73148815",
        "dataset_index": 21597
      },
      "one_shot_da95c4ef": {
        "rtl_code": "\nmodule one_shot (\n  input trig,\n  input clk,\n  input rst,\n  output out\n);\n\n  parameter t = 10; // duration of output pulse in clock cycles\n  \n  reg [31:0] count = 0;\n  reg pulse = 0;\n  reg out_reg = 0; // Registered output\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n      pulse <= 0;\n      out_reg <= 0;\n    end\n    else if (trig && !pulse) begin\n      count <= 0;\n      pulse <= 1;\n      out_reg <= 1;\n    end\n    else if (pulse && count < t-1) begin\n      count <= count + 1;\n      out_reg <= 1;\n    end\n    else if (pulse && count == t-1) begin\n      count <= 0;\n      pulse <= 0;\n      out_reg <= 0;\n    end\n    else begin\n      out_reg <= 0;\n    end\n  end\n  \n  assign out = out_reg; // Drive output from registered value\n  \nendmodule\n",
        "module_name": "one_shot",
        "module_hash": "da95c4ef92c1dfaf3c6df0b38c011896",
        "dataset_index": 15747
      },
      "sky130_fd_sc_ls__a211o_573ce09e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a211o (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A1, A2          );\n    or  or0  (or0_out_X, and0_out, C1, B1);\n    buf buf0 (X        , or0_out_X       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a211o",
        "module_hash": "573ce09ea22c3be843d0168c90c81f54",
        "dataset_index": 23435
      },
      "muxed_ctrl_data_3c0da8e7": {
        "rtl_code": "\nmodule muxed_ctrl_data(\n  input [5:0] ByteCnt,\n  input DlyCrcEn,\n  input [1:0] DlyCrcCnt,\n  input [47:0] MAC,\n  input [15:0] TxPauseTV,\n  input MTxClk,\n  input TxReset,\n  output reg [7:0] ControlData\n);\n\nreg [7:0] MuxedCtrlData;\n\nalways @ (ByteCnt or DlyCrcEn or MAC or TxPauseTV or DlyCrcCnt) begin\n  case(ByteCnt)\n    6'h0: if(~DlyCrcEn | DlyCrcEn & (&DlyCrcCnt[1:0]))\n           MuxedCtrlData[7:0] = 8'h01; // Reserved Multicast Address\n         else\n           MuxedCtrlData[7:0] = 8'h0;\n    6'h2: MuxedCtrlData[7:0] = 8'h80;\n    6'h4: MuxedCtrlData[7:0] = 8'hC2;\n    6'h6: MuxedCtrlData[7:0] = 8'h00;\n    6'h8: MuxedCtrlData[7:0] = 8'h00;\n    6'hA: MuxedCtrlData[7:0] = 8'h01;\n    6'hC: MuxedCtrlData[7:0] = MAC[47:40];\n    6'hE: MuxedCtrlData[7:0] = MAC[39:32];\n    6'h10: MuxedCtrlData[7:0] = MAC[31:24];\n    6'h12: MuxedCtrlData[7:0] = MAC[23:16];\n    6'h14: MuxedCtrlData[7:0] = MAC[15:8];\n    6'h16: MuxedCtrlData[7:0] = MAC[7:0];\n    6'h18: MuxedCtrlData[7:0] = 8'h88; // Type/Length\n    6'h1A: MuxedCtrlData[7:0] = 8'h08;\n    6'h1C: MuxedCtrlData[7:0] = 8'h00; // Opcode\n    6'h1E: MuxedCtrlData[7:0] = 8'h01;\n    6'h20: MuxedCtrlData[7:0] = TxPauseTV[15:8]; // Pause timer value\n    6'h22: MuxedCtrlData[7:0] = TxPauseTV[7:0];\n    default: MuxedCtrlData[7:0] = 8'h0;\n  endcase\nend\n\nalways @ (posedge MTxClk or posedge TxReset) begin\n  if(TxReset)\n    ControlData[7:0] <= 8'h0;\n  else if(~ByteCnt[0])\n    ControlData[7:0] <= MuxedCtrlData[7:0];\nend\n\nendmodule",
        "module_name": "muxed_ctrl_data",
        "module_hash": "3c0da8e72746f9bccca1a0a166e12566",
        "dataset_index": 21482
      },
      "sky130_fd_sc_hs__dlymetal6s2s_03b2fa7a": {
        "rtl_code": "\nmodule sky130_fd_sc_hs__dlymetal6s2s (\n    input A,\n    input D,\n    input delay_VPWR,\n    input delay_VGND,\n    output reg X\n);\n\nreg delay_A; // register to delay A by 1\nreg delay_D; // register to delay D by 1\n\n// Delay A by 1\nalways @(posedge A)\n    delay_A <= A;\n\n// Delay D by 1\nalways @(posedge D)\n    delay_D <= D;\n\n// Output X when delayed A, delay_VPWR, delay_VGND, and D are all high\nalways @*\n    X <= delay_A && delay_VPWR && delay_VGND && delay_D;\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__dlymetal6s2s",
        "module_hash": "03b2fa7aa36b52aabadcda46b70904ca",
        "dataset_index": 3492
      },
      "fifo_ctr_7de90c94": {
        "rtl_code": "module fifo_ctr (\n\n\t\t\t\tinput wire clk,\n\t\t\t\tinput wire rst_n,\n\t\t\t\tinput wire push,\n\t\t\t\tinput wire pop,\n\n\t\t\t\toutput reg empty,\n\t\t\t\toutput reg almost_empty,\n\t\t\t\toutput reg full,\n\t\t\t\toutput reg almost_full,\n\t\t\t\toutput reg error,\n\t\t\t\toutput reg cen,\n\t\t\t\toutput reg wen,\n\t\t\t\toutput reg oen,\n\t\t\t\toutput reg [4:0] addr\n\t\t\t\t);\n\nparameter numOfRam = 32;\nparameter delay = 1.5;\n\nparameter EMPTY   = 2'b00;\nparameter BETWEEN = 2'b01;\nparameter READOUT = 2'b10;\nparameter FULL    = 2'b11;\n\nreg    [1:0] state;\nreg    [1:0] state_next;\n\nreg    [4:0] head;\nreg    [4:0] head_next;\nreg    [4:0] tail;\nreg    [4:0] tail_next;\n\nreg    head_plus;\nreg    tail_plus;\nreg    addr_head;\nreg    addr_tail;\n\nreg\t\tdo_idle;\nreg\t\tdo_pop;\nreg\t\tdo_push;\nreg\t\tdo_push_pop;\n\nalways @(posedge clk or negedge rst_n) begin\nif (rst_n == 0) begin\nstate <= EMPTY;\nhead  <= 5'b0;\ntail  <= 5'b0;\nend else begin\nstate <= #(delay) state_next;\nhead  <= #(delay) head_next;\ntail  <= #(delay) tail_next;\nend\nend\n\n\nalways @(*) begin\n\t\tdo_idle = 1'b0;\n\t\tdo_pop  = 1'b0;\n\t\tdo_push = 1'b0;\n\t\tdo_push_pop = 1'b0;\n\t\tcase ({push,pop})\n\t\t\t\t2'b00: begin do_idle = 1'b1; end\n\t\t\t\t2'b01: begin do_pop = 1'b1; end\n\t\t\t\t2'b10: begin do_push = 1'b1; end\n\t\t\t\t2'b11: begin do_push_pop = 1'b1; end\n\t\tendcase\nend\n\nalways @(*) begin\n\t\tif (head_plus) begin\n\t\thead_next = (head + 1'b1)%numOfRam;\n\t\tend else begin\n\t\thead_next = head;\n\t\tend\n\t\tif (tail_plus) begin\n\t\ttail_next = (tail + 1'b1)%numOfRam;\n\t\tend else begin\n\t\ttail_next = tail;\n\t\tend\nend\n\n\n\t\talways @(*) begin\n\t\tif (tail == head - 1'b1) begin\n\t\talmost_empty  = 1'b1;\n\t\tend else begin\n\t\talmost_empty  = 1'b0;\n\t\tend\n\t\tif (head == tail - 1'b1) begin\n\t\talmost_full   = 1'b1;\n\t\tend else begin\n\t\talmost_full   = 1'b0;\n\t\tend\n\t\toen               = 1'b0;\n\t\tend\n\n\n\t\talways @(*) begin\n\t\tempty         = 1'b0;\n\t\tfull          = 1'b0;\n\t\terror         = 1'b0;\n\t\tcen           = 1'b0;\n\t\twen           = 1'b1;\n\t\taddr          = 5'b0;\n\t\thead_plus     = 1'b0;\n\t\ttail_plus     = 1'b0;\n\t\taddr_head     = 1'b0;\n\t\taddr_tail     = 1'b0;\n\t\t\t\tstate_next    = state;\n\t\t\t\tcase (state)\n\t\t\t\tEMPTY:    begin\n\t\t\t\tif (do_idle || do_pop || do_push_pop) begin\n\t\t\t\terror         = (do_pop | do_push_pop);\n\t\t\t\tstate_next    = EMPTY;\n\t\t\t\tend else if (do_push) begin\n\t\t\t\taddr          = head;\n\t\t\t\thead_plus     = 1'b1;\n\t\t\t\twen           = 1'b0;\n\t\t\t\tstate_next    = BETWEEN;\n\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tBETWEEN:  begin\n\t\t\t\tif (do_push && !almost_full) begin\n\t\t\t\taddr          = head;\n\t\t\t\thead_plus     = 1'b1;\n\t\t\t\twen           = 1'b0;\n\t\t\t\tstate_next    = BETWEEN;\n\t\t\t\tend else if (do_idle || do_push_pop) begin\n\t\t\t\terror         = do_push_pop;\n\t\t\t\tstate_next    = BETWEEN;\n\t\t\t\tend else if (do_pop) begin\n\t\t\t\taddr          = tail;\n\t\t\t\tstate_next    = READOUT;\n\t\t\t\tend else if (do_push && almost_full) begin\n\t\t\t\taddr          = head;\n\t\t\t\thead_plus     = 1'b1;\n\t\t\t\twen           = 1'b0;\n\t\t\t\tstate_next    = FULL;\n\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tREADOUT:  begin\n\t\t\t\tif (!almost_empty) begin\n\t\t\t\ttail_plus     = 1'b1;\n\t\t\t\terror         = (do_push | do_pop);\n\t\t\t\tstate_next    = BETWEEN;\n\t\t\t\tend else begin\n\t\t\t\ttail_plus     = 1'b1;\n\t\t\t\terror         = (do_push | do_pop);\n\t\t\t\tstate_next    = EMPTY;\n\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tFULL:     begin\n\t\t\t\tif (do_pop) begin\n\t\t\t\taddr          = tail;\n\t\t\t\tstate_next    = READOUT;\n\t\t\t\tend else if (do_idle || do_push || do_push_pop) begin\n\t\t\t\terror         = (do_push | do_push_pop);\n\t\t\t\tstate_next    = FULL;\n\t\t\t\tend\n\n\t\t\t\tend\n\t\t\t\tendcase\n\t\tend\n\t\tendmodule\n",
        "module_name": "fifo_ctr",
        "module_hash": "7de90c944c8fb9c1d054c42688cdbeee",
        "dataset_index": 23219
      },
      "Contador_AD_Dia_8c3da30a": {
        "rtl_code": "module Contador_AD_Dia(\n    input rst,\n    input [7:0]estado,\n    input [1:0] en,\n    input [7:0] Cambio,\n    input got_data,\n    input clk,\n    output reg [(N-1):0] Cuenta\n);\n\n    parameter N = 7;\n    parameter X = 99;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            Cuenta <= 1;\n        end else if (en == 2'd2 && estado == 8'h7D) begin\n            if (Cambio == 8'h73 && got_data) begin\n                if (Cuenta == X) begin\n                    Cuenta <= 1;\n                end else begin\n                    Cuenta <= Cuenta + 1'd1;\n                end\n            end else if (Cambio == 8'h72 && got_data) begin\n                if (Cuenta == 1) begin\n                    Cuenta <= X;\n                end else begin\n                    Cuenta <= Cuenta - 1'd1;\n                end\n            end else begin\n                Cuenta <= Cuenta;\n            end\n        end else begin\n            Cuenta <= Cuenta;\n        end\n    end\n\nendmodule",
        "module_name": "Contador_AD_Dia",
        "module_hash": "8c3da30a4113082d1e00f40fe568ed0d",
        "dataset_index": 4491
      },
      "decoder_4to16_d81eba0d": {
        "rtl_code": "module decoder_4to16 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg [15:0] Y\n);\n\nalways @(*) begin\n    if (A == 0 && B == 0 && C == 0 && D == 0) Y = 16'b1111111111111110;\n    else if (A == 0 && B == 0 && C == 0 && D == 1) Y = 16'b1111111111111101;\n    else if (A == 0 && B == 0 && C == 1 && D == 0) Y = 16'b1111111111111011;\n    else if (A == 0 && B == 0 && C == 1 && D == 1) Y = 16'b1111111111110111;\n    else if (A == 0 && B == 1 && C == 0 && D == 0) Y = 16'b1111111111101111;\n    else if (A == 0 && B == 1 && C == 0 && D == 1) Y = 16'b1111111111011111;\n    else if (A == 0 && B == 1 && C == 1 && D == 0) Y = 16'b1111111110111111;\n    else if (A == 0 && B == 1 && C == 1 && D == 1) Y = 16'b1111111101111111;\n    else if (A == 1 && B == 0 && C == 0 && D == 0) Y = 16'b1111111011111111;\n    else if (A == 1 && B == 0 && C == 0 && D == 1) Y = 16'b1111110111111111;\n    else if (A == 1 && B == 0 && C == 1 && D == 0) Y = 16'b1111101111111111;\n    else if (A == 1 && B == 0 && C == 1 && D == 1) Y = 16'b1111011111111111;\n    else if (A == 1 && B == 1 && C == 0 && D == 0) Y = 16'b1110111111111111;\n    else if (A == 1 && B == 1 && C == 0 && D == 1) Y = 16'b1101111111111111;\n    else if (A == 1 && B == 1 && C == 1 && D == 0) Y = 16'b1011111111111111;\n    else if (A == 1 && B == 1 && C == 1 && D == 1) Y = 16'b0111111111111111;\nend\n\nendmodule",
        "module_name": "decoder_4to16",
        "module_hash": "d81eba0d032ff026fc6184b84fbd5983",
        "dataset_index": 12354
      },
      "uartcon_tx_7ea57abc": {
        "rtl_code": "module uartcon_tx\n  (\n   input       rst_n,\n   input       clk,\n\n   output      txd,\n\n   input       valid,\n   output reg load,\n   input [7:0] data\n   );\n\n   reg [1:0]   sample_count;\n   reg [2:0]   bit_count;\n   reg [7:0]   tx_data;\n\n   wire        sample_point;\n\n   reg [3:0]   state;\n\n   localparam S_IDLE    = 4'd0;\n   localparam S_START   = 4'd1;\n   localparam S_DATA    = 4'd2;\n   localparam S_STOP    = 4'd3;\n   localparam S_LAST    = 4'd4;\n\n   reg         out_data;\n\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n         sample_count[1:0] <= 2'd0;\n         bit_count[2:0] <= 3'd0;\n      end else begin\n         if(state != S_IDLE) begin\n            sample_count[1:0] <= sample_count[1:0] + 2'd1;\n         end else begin\n            sample_count[1:0] <= 2'd0;\n         end\n         if(state == S_DATA) begin\n            if(sample_point == 1'b1) begin\n               bit_count[2:0] <= bit_count[2:0] + 3'd1;\n            end\n         end else begin\n            bit_count[2:0] <= 3'd0;\n         end\n      end\n   end\n\n   assign sample_point = (sample_count[1:0] == 2'd3)?1'b1:1'b0;\n\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n         state <= S_IDLE;\n         tx_data[7:0] <= 8'd0;\n         load <= 1'b0;\n         out_data <= 1'b1;\n      end else begin\n         case(state)\n           S_IDLE: begin\n              if(valid == 1'b1) begin\n                 state <= S_START;\n                 tx_data[7:0] <= data[7:0];\n                 load <= 1'b1;\n              end\n           end\n           S_START: begin\n              load <= 1'b0;\n              out_data <= 1'b0;\n              if(sample_point == 1'b1) begin\n                 state <= S_DATA;\n              end\n           end\n           S_DATA: begin\n              out_data <= tx_data[0];\n              if(sample_point == 1'b1) begin\n                 tx_data[7:0] <= {1'b0, tx_data[7:1]};\n                 if(bit_count[2:0] == 3'd7) begin\n                    state <= S_STOP;\n                 end\n              end\n           end\n           S_STOP: begin\n              out_data <= 1'b1;\n              if(sample_point == 1'b1) begin\n                 state <= S_LAST;\n              end\n           end\n           S_LAST: begin\n              out_data <= 1'b1;\n              if(sample_point == 1'b1) begin\n                 state <= S_IDLE;\n              end\n           end\n\n         endcase\n      end\n   end\n\n   assign txd = out_data;\n\nendmodule",
        "module_name": "uartcon_tx",
        "module_hash": "7ea57abce047db82218157a3f68b8bd0",
        "dataset_index": 1964
      },
      "Convolutional_Encoder_Viterbi_Decoder #_8fe42297": {
        "rtl_code": "\nmodule Convolutional_Encoder_Viterbi_Decoder #(\n  parameter k = 3, // number of input bits that are combined to produce each output bit\n  parameter n = 4, // number of output bits produced by the encoder\n  parameter m = 3 // number of input bits estimated by the decoder\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\nreg [k-1:0] shift_reg; // shift register to store input bits\nreg [n-1:0] encoded; // encoded output bits\nreg [m-1:0] decoded; // decoded input bits\n\n// Convolutional Encoder\nalways @ (in) begin\n  case (in)\n    3'b000: encoded = 4'b0000;\n    3'b001: encoded = 4'b1100;\n    3'b010: encoded = 4'b1010;\n    3'b011: encoded = 4'b0110;\n    3'b100: encoded = 4'b1001;\n    3'b101: encoded = 4'b0101;\n    3'b110: encoded = 4'b0011;\n    3'b111: encoded = 4'b1111;\n  endcase\nend\n\n// Viterbi Decoder\nalways @ (posedge clk) begin\n  // Placeholder implementation of Viterbi algorithm\n  decoded = in; // Temporary assignment for testing purposes\nend\n\nassign out = decoded;\n\nendmodule",
        "module_name": "Convolutional_Encoder_Viterbi_Decoder #",
        "module_hash": "8fe42297dd37004548f73e8d86e46f75",
        "dataset_index": 17661
      },
      "register_mux_22b9ec67": {
        "rtl_code": "module register_mux (\n    input clk,\n    input reset, // Synchronous active-high reset \n    input [7:0] d0, // 8-bit input for the first register \n    input [7:0] d1, // 8-bit input for the second register \n    input [2:0] sel, // Select input to choose between register 1, register 2, and multiplexer output \n    input [7:0] data0, // 8-bit input for multiplexer \n    input [7:0] data1, // 8-bit input for multiplexer \n    input [7:0] data2, // 8-bit input for multiplexer \n    input [7:0] data3, // 8-bit input for multiplexer \n    input [7:0] data4, // 8-bit input for multiplexer \n    input [7:0] data5, // 8-bit input for multiplexer \n    output reg [7:0] q // 8-bit output from the active module \n);\n\nreg [7:0] reg0, reg1;\nwire [7:0] mux_out;\n\n// Register 0\nalways @(posedge clk) begin\n    if (reset) begin\n        reg0 <= 8'h34;\n    end else begin\n        reg0 <= d0;\n    end\nend\n\n// Register 1\nalways @(posedge clk) begin\n    if (reset) begin\n        reg1 <= 8'h34;\n    end else begin\n        reg1 <= d1;\n    end\nend\n\n// Multiplexer\nassign mux_out = (sel == 3'b000) ? reg0 :\n                 (sel == 3'b001) ? reg1 :\n                 (sel == 3'b010) ? data0 :\n                 (sel == 3'b011) ? data1 :\n                 (sel == 3'b100) ? data2 :\n                 (sel == 3'b101) ? data3 :\n                 (sel == 3'b110) ? data4 :\n                                   data5;\n\n// Output\nalways @* begin\n    case (sel)\n        3'b000: q <= reg0;\n        3'b001: q <= reg1;\n        default: q <= mux_out;\n    endcase\nend\n\nendmodule",
        "module_name": "register_mux",
        "module_hash": "22b9ec67f92d5500bdd1779a1eedda85",
        "dataset_index": 13420
      },
      "four_bit_adder_c2a8d1ea": {
        "rtl_code": "module four_bit_adder(\n    input [3:0] A, B,\n    input C,\n    output reg [3:0] Y,\n    output reg OVF\n);\n\nreg [3:0] sum;\nreg [3:0] diff;\n\n// Calculate the sum and difference\nalways @ (A, B, C)\nbegin\n    if (C == 0) // Add\n    begin\n        sum = A + B;\n        diff = 4'b0;\n    end\n    else // Subtract\n    begin\n        sum = 4'b0;\n        diff = A - B;\n    end\nend\n\n// Calculate the output and overflow\nalways @ (sum, diff)\nbegin\n    if (sum > 4'b1111) // Overflow\n    begin\n        Y = 4'b1111;\n        OVF = 1;\n    end\n    else if (diff < 4'b0000) // Underflow\n    begin\n        Y = 4'b0000;\n        OVF = 1;\n    end\n    else // Normal output\n    begin\n        Y = (C == 0) ? sum : diff;\n        OVF = 0;\n    end\nend\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "c2a8d1ea042921617b9872502304596a",
        "dataset_index": 8783
      },
      "odd_parity_generator_c2c935e8": {
        "rtl_code": "\nmodule odd_parity_generator (\n    input [7:0] in,\n    output reg [8:0] out\n);\n    \n    always @(*) begin\n        out[8] = ^in;\n        out[7:0] = in;\n    end\n    \nendmodule\nmodule bcd_counter (\n    input clk,\n    input reset,\n    input [2:0] ena,\n    output reg [3:0] q\n);\n    \n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (ena[2]) begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1;\n            end\n        end else if (ena[1]) begin\n            if (q[3] == 1 && q[2:0] == 3'b011) begin\n                q <= {1'b0, 3'b000};\n            end else if (q[2:0] == 3'b100) begin\n                q <= {1'b1, 3'b000};\n            end else begin\n                q <= q + 1;\n            end\n        end else if (ena[0]) begin\n            if (q[3:1] == 3'b100) begin\n                q <= {1'b1, 3'b000};\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\n    \nendmodule\nmodule adder (\n    input [8:0] a,\n    input [3:0] b,\n    output [7:0] out\n);\n    \n    assign out = a[7:0] + b;\n    \nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [8:0] parity_out,\n    output [2:0] ena,\n    output [15:0] q,\n    output [7:0] add_out\n);\n    \n    wire [8:0] parity_in;\n    wire [3:0] ones_digit;\n    \n    odd_parity_generator parity_gen(\n        .in(in),\n        .out(parity_in)\n    );\n    \n    bcd_counter counter(\n        .clk(clk),\n        .reset(reset),\n        .ena(ena),\n        .q(q[3:0])\n    );\n    \n    assign ones_digit = q[3:0];\n    \n    adder add(\n        .a(parity_in),\n        .b(ones_digit),\n        .out(add_out)\n    );\n    \n    assign parity_out = parity_in;\n    assign q[15:4] = 12'b0;\n    assign ena = 3'b0;\n    \nendmodule",
        "module_name": "odd_parity_generator",
        "module_hash": "c2c935e829ef54ae368d85db1716b6d9",
        "dataset_index": 10417
      },
      "fifo496_1c65ab6c": {
        "rtl_code": "module fifo496 (clk, wen, din, dout);\n\n\tparameter WIDTH = 4'b1000;\n\n    input clk; \n    input wen; \n    input[WIDTH - 1:0] din; \n    output[WIDTH - 1:0] dout; \n    reg[WIDTH - 1:0] dout;\n\n    reg[WIDTH-1:0]buff1; \n    reg[WIDTH-1:0]buff2; \n\n    always @(posedge clk)\n    begin\n\t\tif (wen == 1'b1)\n\t\tbegin\n\t\t\tbuff1 <= din;\n\t\t\tbuff2 <= buff1;\n\t\t\tdout <= buff2;\n\t\tend\n\tend\nendmodule",
        "module_name": "fifo496",
        "module_hash": "1c65ab6c2929e0dc4c19152b1df4c870",
        "dataset_index": 6812
      },
      "ALU_759abc85": {
        "rtl_code": "module ALU(\n    output reg [31:0] alu_out,\n    output flag_z, flag_v, flag_n,\n    input [31:0] in0, in1,     input [4:0] shamt,\n    input [15:0] perf_cnt, input alu_ctrl0, alu_ctrl1, alu_ctrl2, alu_ctrl3\n);\n\nlocalparam ADD = 4'h0, SUB = 4'h1, LUI = 4'h2, MOV = 4'h3;\nlocalparam AND = 4'h4, SLL = 4'h5, SRA = 4'h6, SRL = 4'h7; \nlocalparam NOT = 4'h8, OR = 4'h9, XOR = 4'ha, ADDB = 4'hb;\nlocalparam ADDBI = 4'hc, SUBB = 4'hd, SUBBI = 4'he, LLDC = 4'hf; wire [3:0] alu_ctrl = {alu_ctrl3, alu_ctrl2, alu_ctrl1, alu_ctrl0};\n\nwire [31:0] dsll0, dsll1, dsll2, dsll3, dsll4;\nwire [31:0] dsrl0, dsrl1, dsrl2, dsrl3, dsrl4;\nwire [31:0] dsra0, dsra1, dsra2, dsra3, dsra4;\n\nwire [8:0] addb0_int, addb1_int, addb2_int, addb3_int; \nwire [7:0] addb0, addb1, addb2, addb3;       \nwire [7:0] subb0, subb1, subb2, subb3;\n\nalways @(alu_ctrl or in0 or in1) begin\n    case (alu_ctrl)\n        ADD: alu_out = in0 + in1;\n        SUB: alu_out = in0 - in1;\n        LUI: alu_out = {in1[15:0], 16'h0000};   MOV: alu_out = in0;\n        AND: alu_out = in0 & in1;\n        SLL: alu_out = dsll4;\n        SRA: alu_out = dsra4;\n        SRL: alu_out = dsrl4;\n        NOT: alu_out = ~in0;\n        OR: alu_out = in0 | in1;\n        XOR: alu_out = in0 ^ in1;\n        ADDB: alu_out = {addb3, addb2, addb1, addb0};         ADDBI: alu_out = {addb3, addb2, addb1, addb0};\n        SUBB: alu_out = {subb3, subb2, subb1, subb0};\n        SUBBI: alu_out = {subb3, subb2, subb1, subb0};\n        LLDC: alu_out = {16'h0000, perf_cnt};\n    endcase\nend\n\nassign flag_z = ~(|alu_out);\nassign flag_n = alu_out[31];\nassign flag_v = (in0[31] & in1[31] & ~alu_out[31]) || (~in0[31] & ~in1[31] & alu_out[31]);\nassign dsll0 = shamt[0] ? {in0[30:0], 1'b0} : in0;        assign dsll1 = shamt[1] ? {dsll0[29:0], 2'b00} : dsll0;\nassign dsll2 = shamt[2] ? {dsll1[27:0], 4'h0} : dsll1;\nassign dsll3 = shamt[3] ? {dsll2[23:0], 8'h00} : dsll2;\nassign dsll4 = shamt[4] ? {dsll3[15:0], 16'h0000} : dsll3;\n\nassign dsrl0 = shamt[0] ? {1'b0, in0[31:1]} : in0;    assign dsrl1 = shamt[1] ? {2'b00, dsrl0[31:2]} : dsrl0;  \nassign dsrl2 = shamt[2] ? {4'h0, dsrl1[31:4]} : dsrl1;\nassign dsrl3 = shamt[3] ? {8'h00, dsrl2[31:8]} : dsrl2;\nassign dsrl4 = shamt[4] ? {16'h0000, dsrl3[31:16]} : dsrl3;\n\nassign dsra0 = shamt[0] ? { in0[31], in0[31:1]} : in0;\nassign dsra1 = shamt[1] ? { {2{dsra0[31]}} , dsra0[31:2]} : dsra0;  assign dsra2 = shamt[2] ? { {4{dsra1[31]}} , dsra1[31:4]} : dsra1;\nassign dsra3 = shamt[3] ? { {8{dsra2[31]}} , dsra2[31:8]} : dsra2;\nassign dsra4 = shamt[4] ? { {16{dsra3[31]}} , dsra3[31:16]} : dsra3;\n\n\nassign addb0_int = in0[7:0] + in1[7:0];\nassign addb1_int = (alu_ctrl == ADDBI) ? in0[15:8] + in1[7:0] : in0[15:8] + in1[15:8];\nassign addb2_int = (alu_ctrl == ADDBI) ? in0[15:8] + in1[7:0] : in0[23:16] + in1[23:16];\nassign addb3_int = (alu_ctrl == ADDBI) ? in0[15:8] + in1[7:0] : in0[31:24] + in1[31:24];\nassign addb0 = addb0_int[8] ? 8'hFF : addb0_int[7:0];\nassign addb1 = addb1_int[8] ? 8'hFF : addb1_int[7:0];\nassign addb2 = addb2_int[8] ? 8'hFF : addb2_int[7:0];\nassign addb3 = addb3_int[8] ? 8'hFF : addb3_int[7:0];\nassign subb0 = in0[7:0] - in1[7:0];\nassign subb1 = (alu_ctrl == SUBBI) ? in0[15:8] - in1[7:0] : in0[15:8] - in1[15:8];\nassign subb2 = (alu_ctrl == SUBBI) ? in0[15:8] - in1[7:0] : in0[23:16] - in1[23:16];\nassign subb3 = (alu_ctrl == SUBBI) ? in0[15:8] - in1[7:0] : in0[31:24] - in1[31:24];\nendmodule\n",
        "module_name": "ALU",
        "module_hash": "759abc857767371e5cf8ad9e7e5504ac",
        "dataset_index": 15290
      },
      "boothMultiplier_48283f99": {
        "rtl_code": "module boothMultiplier(\n    input [3:0] multiplicand,\n    input [3:0] multiplier,\n    output reg [7:0] product,\n    input clock,\n    input reset\n    );\n\n    reg [3:0] A, Q, M;\n    reg Q_1;\n    reg [3:0] count;\n\n    wire [3:0] sum, difference;\n\n    always @(posedge clock)\n    begin\n        if (reset) begin\n            A <= 4'b0;      \n            M <= multiplicand;\n            Q <= multiplier;\n            Q_1 <= 1'b0;      \n            count <= 3'b0;\n        end\n        else begin\n            case ({Q[0], Q_1})\n                2'b01 : {A, Q, Q_1} <= {sum[3], sum, Q};\n                2'b10 : {A, Q, Q_1} <= {difference[3], difference, Q};\n                default: {A, Q, Q_1} <= {A[3], A, Q};\n            endcase\n            count <= count + 1;\n            if (count == 4) begin\n                product <= {A, Q};\n            end\n        end\n    end\n\n    alu adder (.A(A), .B(M), .cin(1'b0), .sum(sum));\n    alu subtracter (.A(A), .B(~M), .cin(1'b1), .sum(difference));\n\nendmodule\n\nmodule alu(\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    output [3:0] sum\n    );\n\n    assign sum = A + B + cin;\n\nendmodule",
        "module_name": "boothMultiplier",
        "module_hash": "48283f992810bbb51616b1ba8ea56bea",
        "dataset_index": 1118
      },
      "modifiedBooth_90287614": {
        "rtl_code": "module modifiedBooth(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [7:0] out\n);\n\nreg rC1, rC2, rC3; //registers for carries\nreg [2:0] rT1, rT2; //temporary registers\n\nalways @ (*) begin\n\n    //R0\n    out[0] = A[0] & B[0];\n\n    //R1\n    {rC1, out[1]} = (A[0] & B[1]) + (A[1] & B[0]);\n\n    //R2\n    {rC1, rT1[0]} = (A[2] & B[0]) + (A[1] & B[1]) + rC1;\n    {rC2, out[2]} = (A[0] & B[2]) + rT1[0];\n\n    //R3\n    {rC1, rT1[1]} = (A[3] & B[0]) + (A[2] & B[1]) + rC1;\n    {rC2, rT2[0]} = (A[1] & B[2]) + rT1[1] + rC2;\n    {rC3, out[3]} = (A[0] & B[3]) + rT2[0];\n\n    //R4\n    {rC1, rT1[2]} = (A[3] & B[1]) + rC1;\n    {rC2, rT2[1]} = (A[2] & B[2]) + rT1[2] + rC2;\n    {rC3, out[4]} = (A[1] & B[3]) + rT2[1] + rC3;\n\n    //R5\n    {rC2, rT2[2]} = (A[3] & B[2]) + rC2 + rC1;\n    {rC3, out[5]} = (A[2] & B[3]) + rT2[2] + rC3;\n\n    //R6 and R7\n    {out[7], out[6]} = (A[3] & B[3]) + rC2 + rC3;\n\nend\n\nendmodule",
        "module_name": "modifiedBooth",
        "module_hash": "902876148636316a863035373876334a",
        "dataset_index": 5899
      },
      "mig_7series_v2_3_ddr_phy_wrlvl_off_delay #_1987250b": {
        "rtl_code": "\n\nmodule mig_7series_v2_3_ddr_phy_wrlvl_off_delay #\n  (\n   parameter TCQ           = 100,\n   parameter tCK           = 3636,\n   parameter nCK_PER_CLK   = 2, \n   parameter CLK_PERIOD    = 4,\n   parameter PO_INITIAL_DLY= 46,\n   parameter DQS_CNT_WIDTH = 3,\n   parameter DQS_WIDTH     = 8, \n   parameter N_CTL_LANES   = 3\n   )\n  (\n   input                        clk,\n   input                        rst,\n   input                        pi_fine_dly_dec_done,\n   input                        cmd_delay_start,\n   output reg [DQS_CNT_WIDTH:0] ctl_lane_cnt,\n   output reg                   po_s2_incdec_f,\n   output reg                   po_en_s2_f,\n   output reg                   po_s2_incdec_c,\n   output reg                   po_en_s2_c,\n   output                      po_ck_addr_cmd_delay_done,\n   output                      po_dec_done,\n   output                      phy_ctl_rdy_dly\n   );\n\n\n  localparam TAP_LIMIT = 63; \n\n \n\nlocalparam TDQSS_DLY = (tCK > 2500 )? 2: 1;\n                        \n   reg       delay_done;\n   reg       delay_done_r1;\n   reg       delay_done_r2;\n   reg       delay_done_r3;\n   reg       delay_done_r4;\n   reg [5:0] po_delay_cnt_r;\n   reg       po_cnt_inc;\n   reg       cmd_delay_start_r1;\n   reg       cmd_delay_start_r2;\n   reg       cmd_delay_start_r3;\n   reg       cmd_delay_start_r4;\n   reg       cmd_delay_start_r5;\n   reg       cmd_delay_start_r6;\n   reg \t     po_delay_done;\n   reg       po_delay_done_r1;\n   reg       po_delay_done_r2;\n   reg       po_delay_done_r3;\n   reg       po_delay_done_r4;\n   reg \t     pi_fine_dly_dec_done_r;\n   reg \t     po_en_stg2_c;\n   reg       po_en_stg2_f;\n   reg \t     po_stg2_incdec_c;\n   reg \t     po_stg2_f_incdec;\n   reg [DQS_CNT_WIDTH:0] lane_cnt_dqs_c_r;\n   reg [DQS_CNT_WIDTH:0] lane_cnt_po_r;\n   reg [5:0] \t\t delay_cnt_r;\n\n   always @(posedge clk) begin\n      cmd_delay_start_r1     <= #TCQ cmd_delay_start;\n      cmd_delay_start_r2     <= #TCQ cmd_delay_start_r1;\n      cmd_delay_start_r3     <= #TCQ cmd_delay_start_r2;\n      cmd_delay_start_r4     <= #TCQ cmd_delay_start_r3;\n      cmd_delay_start_r5     <= #TCQ cmd_delay_start_r4;\n      cmd_delay_start_r6     <= #TCQ cmd_delay_start_r5;\n      pi_fine_dly_dec_done_r <= #TCQ pi_fine_dly_dec_done;\n    end \n\n   assign phy_ctl_rdy_dly  = cmd_delay_start_r6; \n\n\n  assign po_dec_done = (PO_INITIAL_DLY == 0) ? 1 : po_delay_done_r4;\n                        \n\n  always @(posedge clk)\n    if (rst || ~cmd_delay_start_r6 || po_delay_done) begin\n      po_stg2_f_incdec  <= #TCQ 1'b0;\n      po_en_stg2_f    <= #TCQ 1'b0;\n    end else if (po_delay_cnt_r > 6'd0) begin \n      po_en_stg2_f    <= #TCQ ~po_en_stg2_f;\n    end\n\n  always @(posedge clk)\n    if (rst || ~cmd_delay_start_r6 || (po_delay_cnt_r == 6'd0))\n      po_delay_cnt_r  <= #TCQ (PO_INITIAL_DLY - 31);\n    else if ( po_en_stg2_f && (po_delay_cnt_r > 6'd0))\n      po_delay_cnt_r  <= #TCQ po_delay_cnt_r - 1;\n\n  always @(posedge clk)\n    if (rst) \n      lane_cnt_po_r  <= #TCQ 'd0;\n    else if ( po_en_stg2_f  && (po_delay_cnt_r == 6'd1))\n      lane_cnt_po_r  <= #TCQ lane_cnt_po_r + 1;\n\n  always @(posedge clk)\n    if (rst || ~cmd_delay_start_r6 )\n      po_delay_done    <= #TCQ 1'b0;\n    else if ((po_delay_cnt_r == 6'd1) && (lane_cnt_po_r ==1'b0))\n      po_delay_done    <= #TCQ 1'b1;\n\n  always @(posedge clk) begin\n    po_delay_done_r1 <= #TCQ po_delay_done;\n    po_delay_done_r2 <= #TCQ po_delay_done_r1;\n    po_delay_done_r3 <= #TCQ po_delay_done_r2;\n    po_delay_done_r4 <= #TCQ po_delay_done_r3;\n  end\n\n  always @(posedge clk) begin\n    po_s2_incdec_f <= #TCQ po_stg2_f_incdec;\n    po_en_s2_f <= #TCQ po_en_stg2_f;\n  end \n\nassign po_ck_addr_cmd_delay_done = (TDQSS_DLY == 0) ? pi_fine_dly_dec_done_r \n                                     : delay_done_r4;\n\n  always @(posedge clk)\n    if (rst || ~pi_fine_dly_dec_done_r || delay_done) begin\n      po_stg2_incdec_c   <= #TCQ 1'b1;\n      po_en_stg2_c    <= #TCQ 1'b0;\n    end else if (delay_cnt_r > 6'd0) begin \n      po_en_stg2_c    <= #TCQ ~po_en_stg2_c;\n    end\n\n  always @(posedge clk)\n    if (rst || ~pi_fine_dly_dec_done_r || (delay_cnt_r == 6'd0)) \n     delay_cnt_r  <= #TCQ TDQSS_DLY;\n    else if ( po_en_stg2_c && (delay_cnt_r > 6'd0))\n      delay_cnt_r  <= #TCQ delay_cnt_r - 1;\n\n  always @(posedge clk)\n    if (rst) \n      lane_cnt_dqs_c_r  <= #TCQ 'd0;\n    else if ( po_en_stg2_c && (delay_cnt_r == 6'd1))\n      lane_cnt_dqs_c_r  <= #TCQ lane_cnt_dqs_c_r + 1;\n\n  always @(posedge clk)\n    if (rst || ~pi_fine_dly_dec_done_r)\n      delay_done    <= #TCQ 1'b0;\n    else if ((delay_cnt_r == 6'd1) && (lane_cnt_dqs_c_r == 1'b0))\n      delay_done    <= #TCQ 1'b1;\n\n\n   always @(posedge clk) begin\n     delay_done_r1 <= #TCQ delay_done;\n     delay_done_r2 <= #TCQ delay_done_r1;\n     delay_done_r3 <= #TCQ delay_done_r2;\n     delay_done_r4 <= #TCQ delay_done_r3;\n   end\n\n  always @(posedge clk) begin\n    po_s2_incdec_c <= #TCQ po_stg2_incdec_c;\n    po_en_s2_c <= #TCQ po_en_stg2_c;\n    ctl_lane_cnt <= #TCQ lane_cnt_dqs_c_r; \n  end \n\nendmodule\n",
        "module_name": "mig_7series_v2_3_ddr_phy_wrlvl_off_delay #",
        "module_hash": "1987250bb63cfc7c37ea0339c631af60",
        "dataset_index": 25856
      },
      "spi_master_cfb09d66": {
        "rtl_code": "\nmodule spi_master (\n  input clk,\n  input rst,\n  input mosi,\n  input cs,\n  input sck_div,\n  output reg miso\n);\n\nreg [7:0] shift_reg;\nreg [2:0] bit_counter;\nreg sck;\nreg cs_n;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    shift_reg <= 8'h00;\n    bit_counter <= 3'd0;\n    sck <= 1'b0;\n    cs_n <= 1'b1;\n    miso <= 1'b0;\n  end else begin\n    if (!cs_n && sck) begin\n      shift_reg <= {mosi, shift_reg[7:1]};\n      bit_counter <= bit_counter + 1;\n      if (bit_counter == 3'd7) begin\n        miso <= shift_reg[0];\n        bit_counter <= 3'd0;\n      end\n    end\n    sck <= ~sck; // Toggle the clock\n    if (sck) begin\n      cs_n <= cs;\n    end\n  end\nend\n\nendmodule\n\nmodule spi_slave (\n  input clk,\n  input rst,\n  input miso,\n  input cs,\n  input sck_div,\n  output reg mosi\n);\n\nreg [7:0] shift_reg;\nreg [2:0] bit_counter;\nreg sck;\nreg cs_n;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    shift_reg <= 8'h00;\n    bit_counter <= 3'd0;\n    sck <= 1'b0;\n    cs_n <= 1'b1;\n    mosi <= 1'b0;\n  end else begin\n    sck <= ~sck; // Toggle the clock\n    if (sck) begin\n      cs_n <= cs;\n      if (!cs_n) begin\n        shift_reg <= {shift_reg[6:0], miso};\n        bit_counter <= bit_counter + 1;\n        if (bit_counter == 3'd7) begin\n          mosi <= shift_reg[7];\n          bit_counter <= 3'd0;\n        end\n      end\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "spi_master",
        "module_hash": "cfb09d66c6ca991e419d1303b67b7665",
        "dataset_index": 4638
      },
      "not_gate_using_nand_a68a6363": {
        "rtl_code": "module not_gate_using_nand(input in, output out);\n  wire nand_out;\n  assign nand_out = ~(in & in);\n  assign out = nand_out;\nendmodule",
        "module_name": "not_gate_using_nand",
        "module_hash": "a68a63630976a7c3c06203c764e09431",
        "dataset_index": 19650
      },
      "binary_counter_8765341f": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 4'b0;\n    end else if (count == 4'b1001) begin\n        count <= 4'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "8765341f389d1e5d0855ee168346de26",
        "dataset_index": 12964
      },
      "mux_4to1_3d40a0c9": {
        "rtl_code": "module mux_4to1(\n  input [3:0] in,\n  input [1:0] sel,\n  output reg out\n);\n\nalways @(*)\nbegin\n  case(sel)\n    2'b00: out = in[0];\n    2'b01: out = in[1];\n    2'b10: out = in[2];\n    2'b11: out = in[3];\n  endcase\nend\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "3d40a0c9d8c77429231c2a9aee1dad76",
        "dataset_index": 14638
      },
      "fifo_buffer_10b03cdb": {
        "rtl_code": "module fifo_buffer (\n        clk     , \n        nrst    , \n        reset   , \n        din     , \n        dout    , \n        wr      , \n        rd      , \n        empty   , \n        full\n        ) ;\n\nparameter               DEPTH = 256 ;   // 128 slots\nparameter               ADDRW = 8 ; \nparameter               SW = 4 ;        \n        \ninput                   clk ;       // system clock \ninput                   nrst ;\ninput                   reset ;\ninput   [SW*2 -1:0]     din ;       \ninput                   wr ;\ninput                   rd ;\noutput  [SW*2 -1:0]     dout ;\noutput                  empty ;\noutput                  full ;\n\nreg     [SW*2 -1:0]     mem [DEPTH -1:0] ;\nwire    [SW*2 -1:0]     data ;\n\nreg     [ADDRW :0]      waddr ;\nreg     [ADDRW :0]      raddr ;\nwire    [ADDRW -1:0]    waddr_i ;\nwire    [ADDRW -1:0]    raddr_i ;\n\nassign dout = data ;\nassign waddr_i = waddr [ADDRW -1 : 0] ;\nassign raddr_i = raddr [ADDRW -1 : 0] ;\nassign empty = (waddr [ADDRW] ~^ raddr [ADDRW]) & (waddr_i == raddr_i) ;\nassign full = (waddr [ADDRW] ^ raddr [ADDRW]) & (waddr_i == raddr_i) ;\n\nalways @ (posedge clk or negedge nrst)\n  if (~nrst)\n    waddr <= 0 ;\n  else if (reset)\n    waddr <= 0 ;\n  else if (wr)\n    waddr <= waddr + 1 ;\n\nalways @ (posedge clk or negedge nrst)\n  if (~nrst)\n    raddr <= 0 ;\n  else if (reset)\n    raddr <= 0 ;\n  else if (rd)\n    raddr <= raddr + 1 ;\n\nalways @ (posedge clk)\n  if (wr)\n    mem [waddr_i] <= din ;\n    \nassign data = mem [raddr_i] ;\n\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "10b03cdbd704ae9478aa59a61c8950cd",
        "dataset_index": 5901
      },
      "DLL_0ca068b3": {
        "rtl_code": "\nmodule DLL (\n  input clk,\n  input rst,\n  input in,\n  output reg out\n);\n\nparameter delay_time = 10; // delay time in clock cycles\n\nreg [delay_time-1:0] delay_line; // delay line implemented as a shift register\nreg [1:0] phase_detector_out; // output of the phase detector\nreg [delay_time-1:0] delay_time_reg; // register to hold the current delay time\n\nalways @(posedge clk) begin\n  if (rst) begin\n    delay_line <= 0;\n    phase_detector_out <= 0;\n    delay_time_reg <= delay_time;\n  end else begin\n    // shift the input signal into the delay line\n    delay_line <= {in, delay_line[delay_time-1:1]};\n    \n    // compare the delayed signal to the input signal\n    phase_detector_out <= {delay_line[delay_time-1], delay_line[delay_time-2]} ^ {in, delay_line[delay_time-1]};\n    \n    // adjust the delay time based on the phase detector output\n    if (phase_detector_out == 2'b01) begin\n      delay_time_reg <= delay_time_reg + 1;\n    end else if (phase_detector_out == 2'b10) begin\n      delay_time_reg <= delay_time_reg - 1;\n    end\n    \n    // output the synchronized signal\n    out <= delay_line[delay_time_reg-1];\n  end\nend\n\nendmodule\n",
        "module_name": "DLL",
        "module_hash": "0ca068b3abfb71b24851e3b67c985d7b",
        "dataset_index": 18529
      },
      "full_adder_a57c610e": {
        "rtl_code": "module full_adder (\n  output sum,\n  output carry_out,\n  input a,\n  input b,\n  input carry_in\n);\n\n  assign {carry_out, sum} = a + b + carry_in;\n\nendmodule\n\nmodule ripple_adder(\n  output [3:0] sum,\n  output cout,\n  input [3:0] a,\n  input [3:0] b,\n  input cin\n);\n\n  wire [3:0] carry;\n  full_adder fa0(sum[0], carry[0], a[0], b[0], cin);\n  full_adder fa1(sum[1], carry[1], a[1], b[1], carry[0]);\n  full_adder fa2(sum[2], carry[2], a[2], b[2], carry[1]);\n  full_adder fa3(sum[3], cout, a[3], b[3], carry[2]);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "a57c610e3dd14a46de44ab00262a4856",
        "dataset_index": 7105
      },
      "mux4to1_e596f31f": {
        "rtl_code": "module mux4to1(\n    input [3:0] A0,\n    input [3:0] A1,\n    input [3:0] A2,\n    input [3:0] A3,\n    input S0,\n    input S1,\n    input VPWR,\n    input VGND,\n    output reg Y\n);\n\n    always @ (S1 or S0 or A0 or A1 or A2 or A3) begin\n        case ({S1, S0})\n            2'b00: Y <= A0;\n            2'b01: Y <= A1;\n            2'b10: Y <= A2;\n            2'b11: Y <= A3;\n        endcase\n    end\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "e596f31f17b01c3a3cc86c07d742b176",
        "dataset_index": 12998
      },
      "input_mux #_ba80c66d": {
        "rtl_code": "\nmodule input_mux #(parameter C_FSM_SWITCH_WIDTH=20, C_INTERFACE=0) (\n    input [4:0] sel,\n    input [C_FSM_SWITCH_WIDTH-1:0] in_pin,\n    output reg out_int\n    );\n        \n    generate\n    case (C_INTERFACE)\n       0: begin: ARDUINO\n                 always @(sel, in_pin)\n                   case(sel)\n                       5'h00 : out_int = in_pin[0];\n                       5'h01 : out_int = in_pin[1];\n                       5'h02 : out_int = in_pin[2];\n                       5'h03 : out_int = in_pin[3];\n                       5'h04 : out_int = in_pin[4];\n                       5'h05 : out_int = in_pin[5];\n                       5'h06 : out_int = in_pin[6];\n                       5'h07 : out_int = in_pin[7];\n                       5'h08 : out_int = in_pin[8];\n                       5'h09 : out_int = in_pin[9];\n                       5'h0A : out_int = in_pin[10];\n                       5'h0B : out_int = in_pin[11];\n                       5'h0C : out_int = in_pin[12];\n                       5'h0D : out_int = in_pin[13];\n                       5'h0E : out_int = in_pin[14];\n                       5'h0F : out_int = in_pin[15];\n                       5'h10 : out_int = in_pin[16];\n                       5'h11 : out_int = in_pin[17];\n                       5'h12 : out_int = in_pin[18];\n                       5'h13 : out_int = in_pin[19];\n                       default : out_int = 1'b0;\n                    endcase  \n                 end\n       1: begin: RASPBERRYPI\n                 always @(sel, in_pin)\n                    case(sel)\n                        5'h00 : out_int = in_pin[0];\n                        5'h01 : out_int = in_pin[1];\n                        5'h02 : out_int = in_pin[2];\n                        5'h03 : out_int = in_pin[3];\n                        5'h04 : out_int = in_pin[4];\n                        5'h05 : out_int = in_pin[5];\n                        5'h06 : out_int = in_pin[6];\n                        5'h07 : out_int = in_pin[7];\n                        5'h08 : out_int = in_pin[8];\n                        5'h09 : out_int = in_pin[9];\n                        5'h0A : out_int = in_pin[10];\n                        5'h0B : out_int = in_pin[11];\n                        5'h0C : out_int = in_pin[12];\n                        5'h0D : out_int = in_pin[13];\n                        5'h0E : out_int = in_pin[14];\n                        5'h0F : out_int = in_pin[15];\n                        5'h10 : out_int = in_pin[16];\n                        5'h11 : out_int = in_pin[17];\n                        5'h12 : out_int = in_pin[18];\n                        5'h13 : out_int = in_pin[19];\n                        5'h14 : out_int = in_pin[20];\n                        5'h15 : out_int = in_pin[21];\n                        5'h16 : out_int = in_pin[22];\n                        5'h17 : out_int = in_pin[23];\n                        5'h18 : out_int = in_pin[24];\n                        5'h19 : out_int = in_pin[25];\n                        default : out_int = 1'b0;\n                     endcase  \n                  end\n       default: begin: ARDUINO\n                      always @(sel, in_pin)\n                      case(sel)\n                          5'h00 : out_int = in_pin[0];\n                          5'h01 : out_int = in_pin[1];\n                          5'h02 : out_int = in_pin[2];\n                          5'h03 : out_int = in_pin[3];\n                          5'h04 : out_int = in_pin[4];\n                          5'h05 : out_int = in_pin[5];\n                          5'h06 : out_int = in_pin[6];\n                          5'h07 : out_int = in_pin[7];\n                          5'h08 : out_int = in_pin[8];\n                          5'h09 : out_int = in_pin[9];\n                          5'h0A : out_int = in_pin[10];\n                          5'h0B : out_int = in_pin[11];\n                          5'h0C : out_int = in_pin[12];\n                          5'h0D : out_int = in_pin[13];\n                          5'h0E : out_int = in_pin[14];\n                          5'h0F : out_int = in_pin[15];\n                          5'h10 : out_int = in_pin[16];\n                          5'h11 : out_int = in_pin[17];\n                          5'h12 : out_int = in_pin[18];\n                          5'h13 : out_int = in_pin[19];\n                          default : out_int = 1'b0;\n                       endcase  \n                    end\n    endcase\n    endgenerate\n      \nendmodule\n",
        "module_name": "input_mux #",
        "module_hash": "ba80c66d37c8bf585ce31f7be5b99252",
        "dataset_index": 25128
      },
      "adder_6b7d774c": {
        "rtl_code": "module adder(A, B, reset, clk, sum, carry);\n\n   input [3:0] A;\n   input [3:0] B;\n   input reset;\n   input clk;\n   output [3:0] sum;\n   output carry;\n\n   reg [3:0] sum_reg;\n   reg carry_reg;\n\n   always @(posedge clk) begin\n      if (reset) begin\n         sum_reg <= 4'b0;\n         carry_reg <= 1'b0;\n      end\n      else begin\n         sum_reg <= A + B;\n         carry_reg <= (A[3] & B[3]) | (A[3] & ~sum_reg[3]) | (B[3] & ~sum_reg[3]);\n      end\n   end\n\n   assign sum = sum_reg;\n   assign carry = carry_reg;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "6b7d774ca6f2952c77c5d8194c836a55",
        "dataset_index": 7926
      },
      "serial_rx #_6aec6120": {
        "rtl_code": "module serial_rx #(\n        parameter CLK_PER_BIT = 50\n    )(\n        input clk,\n        input rst,\n        input rx,\n        output [7:0] data,\n        output new_data\n    );\n\n    parameter CTR_SIZE = $clog2(CLK_PER_BIT);\n\n    localparam STATE_SIZE = 2;\n    localparam IDLE = 2'd0,\n    WAIT_HALF = 2'd1,\n    WAIT_FULL = 2'd2,\n    WAIT_HIGH = 2'd3;\n\n    reg [CTR_SIZE-1:0] ctr_d, ctr_q;\n    reg [2:0] bit_ctr_d, bit_ctr_q;\n    reg [7:0] data_d, data_q;\n    reg new_data_d, new_data_q;\n    reg [STATE_SIZE-1:0] state_d, state_q = IDLE;\n    reg rx_d, rx_q;\n\n    assign new_data = new_data_q;\n    assign data = data_q;\n\n    always @(*) begin\n        rx_d = rx;\n        state_d = state_q;\n        ctr_d = ctr_q;\n        bit_ctr_d = bit_ctr_q;\n        data_d = data_q;\n        new_data_d = 1'b0;\n\n        case (state_q)\n            IDLE: begin\n                bit_ctr_d = 3'b0;\n                ctr_d = 1'b0;\n                if (rx_q == 1'b0) begin\n                    state_d = WAIT_HALF;\n                end\n            end\n            WAIT_HALF: begin\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == (CLK_PER_BIT >> 1)) begin\n                    ctr_d = 1'b0;\n                    state_d = WAIT_FULL;\n                end\n            end\n            WAIT_FULL: begin\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    data_d = {rx_q, data_q[7:1]};\n                    bit_ctr_d = bit_ctr_q + 1'b1;\n                    ctr_d = 1'b0;\n                    if (bit_ctr_q == 3'd7) begin\n                        state_d = WAIT_HIGH;\n                        new_data_d = 1'b1;\n                    end\n                end\n            end\n            WAIT_HIGH: begin\n                if (rx_q == 1'b1) begin\n                    state_d = IDLE;\n                end\n            end\n            default: begin\n                state_d = IDLE;\n            end\n        endcase\n\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            ctr_q <= 1'b0;\n            bit_ctr_q <= 3'b0;\n            new_data_q <= 1'b0;\n            state_q <= IDLE;\n        end else begin\n            ctr_q <= ctr_d;\n            bit_ctr_q <= bit_ctr_d;\n            new_data_q <= new_data_d;\n            state_q <= state_d;\n        end\n\n        rx_q <= rx_d;\n        data_q <= data_d;\n    end\n\nendmodule",
        "module_name": "serial_rx #",
        "module_hash": "6aec6120498f29e7716f0e07c862a8af",
        "dataset_index": 25775
      },
      "decade_counter_952d8a53": {
        "rtl_code": "module decade_counter (\n    input clk,\n    input pause,\n    input reset,\n    output reg [3:0] q\n);\n\nreg [3:0] johnson;\nreg [3:0] johnson_next;\nreg flip_flop;\n\nalways @ (posedge clk) begin\n    if (reset) begin\n        johnson <= 4'b0001;\n        flip_flop <= 1'b0;\n        q <= 4'b0000;\n    end else if (pause) begin\n        johnson_next <= johnson;\n    end else begin\n        johnson_next[0] <= johnson[3];\n        johnson_next[1] <= johnson[0];\n        johnson_next[2] <= johnson[1];\n        johnson_next[3] <= johnson[2] ^ johnson[3];\n        johnson <= johnson_next;\n        \n        if (johnson == 4'b1001) begin\n            flip_flop <= ~flip_flop;\n        end\n        \n        if (flip_flop) begin\n            q <= 4'b0000;\n        end else begin\n            q <= johnson;\n        end\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input pause,\n    input reset,\n    output [3:0] q\n);\n\ndecade_counter counter (\n    .clk(clk),\n    .pause(pause),\n    .reset(reset),\n    .q(q)\n);\n\nendmodule",
        "module_name": "decade_counter",
        "module_hash": "952d8a53a6e45d10053f319397d74bf3",
        "dataset_index": 14808
      },
      "RegisterFile_756bd829": {
        "rtl_code": "module RegisterFile (\n    input clk,\n    input wr_en,\n    input [2:0] wr_addr,\n    input [7:0] wr_data,\n    input [2:0] rd1_addr,\n    input [2:0] rd2_addr,\n    output reg [7:0] rd1_data,\n    output reg [7:0] rd2_data\n);\n\nreg [7:0] registers [0:7];\n\nalways @(posedge clk) begin\n    if (wr_en) begin\n        registers[wr_addr] <= wr_data;\n    end\n    rd1_data <= registers[rd1_addr];\n    rd2_data <= registers[rd2_addr];\nend\n\nendmodule",
        "module_name": "RegisterFile",
        "module_hash": "756bd829b23435b2bb1e665a30cbc794",
        "dataset_index": 8751
      },
      "two_bit_counter_0537dd88": {
        "rtl_code": "\nmodule two_bit_counter(\n\t\tdclk,\n\t\trst,\n\t\tcontrol\n);\n\ninput        dclk;\n\t\t\tinput        rst;\n\t\t\toutput [1:0] control;\n   \nreg [1:0]    count;\n   \nalways @(posedge dclk or posedge rst)\n\t\t\t\t\n\t\t\t\tbegin\n\t\t\t\t\tif (rst == 1'b1)\n\t\t\t\t\t\tcount <= {2{1'b0}};\n\t\t\t\t\telse\n\t\t\t\t\t\tcount <= count + 1'b1;\n\t\t\t\tend\n\t\t\t\n\t\t\tassign control = count;\n   \nendmodule\n\n",
        "module_name": "two_bit_counter",
        "module_hash": "0537dd88699fb9e04e75b0deff6d9d7a",
        "dataset_index": 22738
      },
      "top_module_2535729a": {
        "rtl_code": "module top_module(\n    input wire [7:0] A,\n    input wire [7:0] B,\n    output wire [7:0] XOR_out,\n    output wire OR_out\n);\n\n    XOR_module XOR_inst(\n        .A(A),\n        .B(B),\n        .out(XOR_out)\n    );\n\n    OR_module OR_inst(\n        .in1(XOR_out[0]),\n        .in2(XOR_out[1]),\n        .out(OR_out)\n    );\n\nendmodule\n\nmodule XOR_module(\n    input wire [7:0] A,\n    input wire [7:0] B,\n    output wire [7:0] out\n);\n\n    assign out = {A[0]&~B[0] | ~A[0]&B[0], \n                 A[1]&~B[1] | ~A[1]&B[1], \n                 A[2]&~B[2] | ~A[2]&B[2], \n                 A[3]&~B[3] | ~A[3]&B[3], \n                 A[4]&~B[4] | ~A[4]&B[4], \n                 A[5]&~B[5] | ~A[5]&B[5], \n                 A[6]&~B[6] | ~A[6]&B[6], \n                 A[7]&~B[7] | ~A[7]&B[7]};\n\nendmodule\n\nmodule OR_module(\n    input wire in1,\n    input wire in2,\n    output wire out\n);\n\n    assign out = in1 | in2;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "2535729ac9ca02ec3c7a67da922dd628",
        "dataset_index": 13090
      },
      "and_display_module_d5459e41": {
        "rtl_code": "\nmodule and_display_module(\n    input [3:0] a,\n    input [3:0] b,\n    input clk,\n    output [6:0] seg_out,\n    output [7:0] out_not\n);\n\n    // bitwise AND module\n    wire [3:0] and_out;\n    and_module and_inst(\n        .a(a),\n        .b(b),\n        .out(and_out)\n    );\n\n    // logical AND module\n    wire [3:0] logical_and_out;\n    logical_and_module logical_and_inst(\n        .a(a),\n        .b(b),\n        .out(logical_and_out)\n    );\n\n    // NOT module for input a\n    wire [3:0] not_a_out;\n    not_module not_a_inst(\n        .in(a),\n        .out(not_a_out)\n    );\n\n    // NOT module for input b\n    wire [3:0] not_b_out;\n    not_module not_b_inst(\n        .in(b),\n        .out(not_b_out)\n    );\n\n    // combine NOT outputs into single output\n    assign out_not = {not_a_out, not_b_out};\n\n    // final output module\n    seven_segment_module seven_seg_inst(\n        .in(and_out & logical_and_out),\n        .out(seg_out)\n    );\n\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n    always @* begin\n        out = a & b;\n    end\nendmodule\n\nmodule logical_and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n    always @* begin\n        out = (a != 0) && (b != 0);\n    end\nendmodule\n\nmodule not_module(\n    input [3:0] in,\n    output reg [3:0] out\n);\n    always @* begin\n        out = ~in;\n    end\nendmodule\n\nmodule seven_segment_module(\n    input [3:0] in,\n    output reg [6:0] out\n);\n    always @* begin\n        case (in)\n            4'b0000: out = 7'b1000000; // 0\n            4'b0001: out = 7'b1111001; // 1\n            4'b0010: out = 7'b0100100; // 2\n            4'b0011: out = 7'b0110000; // 3\n            4'b0100: out = 7'b0011001; // 4\n            4'b0101: out = 7'b0010010; // 5\n            4'b0110: out = 7'b0000010; // 6\n            4'b0111: out = 7'b1111000; // 7\n            4'b1000: out = 7'b0000000; // 8\n            4'b1001: out = 7'b0011000; // 9\n            default: out = 7'b1111111; // off\n        endcase\n    end\nendmodule\n",
        "module_name": "and_display_module",
        "module_hash": "d5459e41831ebef3dd84ff8d5499bba6",
        "dataset_index": 14255
      },
      "sky130_fd_sc_ms__a2111o_52317091": {
        "rtl_code": "module sky130_fd_sc_ms__a2111o (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    // Module ports\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    // Local signals\n    wire and0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , A1, A2              );\n    or  or0  (or0_out_X, C1, B1, and0_out, D1);\n    buf buf0 (X        , or0_out_X           );\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__a2111o",
        "module_hash": "5231709140afd731cd8036ac7f657cc5",
        "dataset_index": 16666
      },
      "adder_cc2ad631": {
        "rtl_code": "\nmodule adder (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\nmodule multiplier (\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] product\n);\n\n    assign product = a * b;\n\nendmodule\nmodule final_module (\n    input [3:0] sum,\n    input [7:0] product,\n    output [7:0] final_output\n);\n\n    assign final_output = (sum * 2) + (product / 2);\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum,\n    output [7:0] product,\n    output [7:0] final_output\n);\n\n    wire [3:0] sum_wire;\n    wire [7:0] product_wire;\n\n    adder adder_inst (\n        .a(a),\n        .b(b),\n        .sum(sum_wire)\n    );\n\n    multiplier multiplier_inst (\n        .a(a),\n        .b(b),\n        .product(product_wire)\n    );\n\n    final_module final_inst (\n        .sum(sum_wire),\n        .product(product_wire),\n        .final_output(final_output)\n    );\n\n    assign sum = sum_wire;\n    assign product = product_wire;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "cc2ad6316a535619f1bfbc17ea4be87d",
        "dataset_index": 9398
      },
      "register #_77d1cdfe": {
        "rtl_code": "module register # (parameter N = 8)\n\t(input clk,\n\t input [N-1:0] in,\n    output reg [N-1:0] out,\n    input load,\n    input clear\n    );\n\t \n\t always @ (posedge clk or posedge clear)\n\t\tif (clear)\t\tout <= 0;\n\t\telse if (load)\tout <= in;\n\t\telse\t\t\tout <= in;\n\nendmodule\n\nmodule register_hl # (parameter N = 16)\n\t(input clk,\n\t input [N/2-1:0] inh,\n\t input [N/2-1:0] inl,\n\t input loadh,\n\t input loadl,\n\t input clear,\n\t output reg [N-1:0] out\n\t);\n\t\n\t always @ (posedge clk or posedge clear)\n\t\tif (clear)\t\t\tout <= 0;\n\t\telse begin \n\t\t\tif (loadh)\tout[N-1:N/2] <= inh;\n\t\t\tif (loadl)\tout[N/2-1:0] <= inl;\n\t\tend\n\t\nendmodule\n\nmodule upcreg(\n    input clk,\n    input reset,\n    input load_incr,\n    input [4:0] upc_next,\n    output reg [4:0] upc);\n\n    always @ (posedge clk, posedge reset)\n        if (reset)  upc <= 5'b00000;\n        else if (load_incr) upc <= upc_next;\n        else if (~load_incr) upc <= upc + 1;\n        else upc <= 5'b00000; endmodule     \n      \nmodule mux5 (input      d0, d1, d2, d3, d4,\n              input      [2:0]       s, \n              output reg  y);\n\n   always @( * )\n      case(s)\n         3'b000: y <= d0;\n         3'b001: y <= d1;\n         3'b010: y <= d2;\n         3'b011: y <= d3;\n         3'b100: y <= d4;\n         default: y <= 1'b0;\n      endcase\nendmodule\n\nmodule addsub\n(\n\tinput [7:0] dataa,\n\tinput [7:0] datab,\n\tinput add_sub,\t  input clk,\n\toutput reg [7:0] result\n);\n\n\talways @ (*)\n\tbegin\n\t\tif (add_sub)\n\t\t\tresult <= dataa + datab;\n\t\telse\n\t\t\tresult <= dataa - datab;\n\tend\n\nendmodule\n\nmodule counter_down\n(\n\tclk,\n\treset,\n\tena,\n\tresult\n);\n\n\tinput clk;\n\tinput reset;\n\tinput ena;\n\toutput reg [7:0] result;\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset) \n\t\t\tresult = 7;\t\t\n\t\telse if (ena) \n\t\t\tresult = result - 1;\n\tend\nendmodule\t\t\n",
        "module_name": "register #",
        "module_hash": "77d1cdfe945d332058c384ea2373e387",
        "dataset_index": 22796
      },
      "daala_4x4_transpose_v1_0_S00_AXIS #_2aa28480": {
        "rtl_code": "\tmodule daala_4x4_transpose_v1_0_S00_AXIS #\n\t(\n\t\tparameter integer C_S_AXIS_TDATA_WIDTH\t= 32\n\t)\n\t(\n\t\tinput wire  S_AXIS_ACLK,\n\t\tinput wire  S_AXIS_ARESETN,\n\t\toutput wire  S_AXIS_TREADY,\n\t\tinput wire [C_S_AXIS_TDATA_WIDTH-1 : 0] S_AXIS_TDATA,\n\t\tinput wire [(C_S_AXIS_TDATA_WIDTH/8)-1 : 0] S_AXIS_TSTRB,\n\t\tinput wire  S_AXIS_TLAST,\n\t\tinput wire  S_AXIS_TVALID\n\t);\n\tfunction integer clogb2 (input integer bit_depth);\n\t  begin\n\t    for(clogb2=0; bit_depth>0; clogb2=clogb2+1)\n\t      bit_depth = bit_depth >> 1;\n\t  end\n\tendfunction\n\n\tlocalparam NUMBER_OF_INPUT_WORDS  = 8;\n\tlocalparam bit_num  = clogb2(NUMBER_OF_INPUT_WORDS-1);\n\tparameter [1:0] IDLE = 1'b0,        WRITE_FIFO  = 1'b1; wire  \taxis_tready;\n\treg mst_exec_state;  \n\tgenvar byte_index;     \n\twire fifo_wren;\n\treg fifo_full_flag;\n\treg [bit_num-1:0] write_pointer;\n\treg writes_done;\n\tassign S_AXIS_TREADY\t= axis_tready;\n\talways @(posedge S_AXIS_ACLK) \n\tbegin  \n\t  if (!S_AXIS_ARESETN) \n\t  begin\n\t      mst_exec_state <= IDLE;\n\t    end  \n\t  else\n\t    case (mst_exec_state)\n\t      IDLE: \n\t        if (S_AXIS_TVALID)\n\t            begin\n\t              mst_exec_state <= WRITE_FIFO;\n\t            end\n\t          else\n\t            begin\n\t              mst_exec_state <= IDLE;\n\t            end\n\t      WRITE_FIFO: \n\t        if (writes_done)\n\t          begin\n\t            mst_exec_state <= IDLE;\n\t          end\n\t        else\n\t          begin\n\t            mst_exec_state <= WRITE_FIFO;\n\t          end\n\n\t    endcase\n\tend\n\tassign axis_tready = ((mst_exec_state == WRITE_FIFO) && (write_pointer <= NUMBER_OF_INPUT_WORDS-1));\n\n\talways@(posedge S_AXIS_ACLK)\n\tbegin\n\t  if(!S_AXIS_ARESETN)\n\t    begin\n\t      write_pointer <= 0;\n\t      writes_done <= 1'b0;\n\t    end  \n\t  else\n\t    if (write_pointer <= NUMBER_OF_INPUT_WORDS-1)\n\t      begin\n\t        if (fifo_wren)\n\t          begin\n\t            write_pointer <= write_pointer + 1;\n\t            writes_done <= 1'b0;\n\t          end\n\t          if ((write_pointer == NUMBER_OF_INPUT_WORDS-1)|| S_AXIS_TLAST)\n\t            begin\n\t              writes_done <= 1'b1;\n\t            end\n\t      end  \n\tend\n\n\tassign fifo_wren = S_AXIS_TVALID && axis_tready;\n\n\tgenerate \n\t  for(byte_index=0; byte_index<= (C_S_AXIS_TDATA_WIDTH/8-1); byte_index=byte_index+1)\n\t  begin:FIFO_GEN\n\n\t    reg  [(C_S_AXIS_TDATA_WIDTH/4)-1:0] stream_data_fifo [0 : NUMBER_OF_INPUT_WORDS-1];\n\n\t    always @( posedge S_AXIS_ACLK )\n\t    begin\n\t      if (fifo_wren)begin\n\t          stream_data_fifo[write_pointer] <= S_AXIS_TDATA[(byte_index*8+7) -: 8];\n\t        end  \n\t    end  \n\t  end\t\t\n\tendgenerate\n\n\tendmodule\n",
        "module_name": "daala_4x4_transpose_v1_0_S00_AXIS #",
        "module_hash": "2aa2848094c43b7fd2ae25ca8dd8035c",
        "dataset_index": 14839
      },
      "uart_a0aba87c": {
        "rtl_code": "module uart\n  (\n   input                      clk,\n   input                      rst,  // Synchronous reset\n   input                      rx,   // Data in\n   output reg                 busy, // Goes high when receiving data\n   output reg [7:0]           data  // Data output\n   );\n\n   parameter DATA_BITS = 8;\n   parameter BAUD = 19200;\n   parameter CLK_RATE = 100000000;\n   localparam CLK_DIV = CLK_RATE / BAUD;\n\n   reg [1:0] state = 2'b00;\n   reg rx_reg = 1'b1;\n   reg [$clog2(CLK_DIV)-1:0] baud_counter = 0;\n   reg [$clog2(DATA_BITS)-1:0] rx_counter = 0;\n\n   always @ (posedge clk) begin\n      if (rst) begin\n         state <= 2'b00;\n         busy <= 1'b0;\n         data <= 8'b0;\n      end else begin\n         case (state)\n            2'b00: begin // STATE_IDLE\n               if (~rx_reg) begin\n                  busy <= 1'b1;\n                  state <= 2'b01;\n                  baud_counter <= 0;\n                  rx_counter <= 0;\n               end\n            end\n            2'b01: begin // STATE_WAIT_HALF\n               if (baud_counter == (CLK_DIV / 2) - 1) begin\n                  state <= 2'b10;\n                  baud_counter <= 0;\n               end else begin\n                  baud_counter <= baud_counter + 1;\n               end\n            end\n            2'b10: begin // STATE_RX\n               if (baud_counter == CLK_DIV - 1) begin\n                  data <= { rx_reg, data[7:1] }; // Sample the serial input\n                  baud_counter <= 0;\n                  if (rx_counter == DATA_BITS - 1) begin\n                     state <= 2'b11;\n                  end else begin\n                     rx_counter <= rx_counter + 1;\n                  end\n               end else begin\n                  baud_counter <= baud_counter + 1;\n               end\n            end\n            2'b11: begin // STATE_END\n               if (baud_counter == CLK_DIV - 1) begin\n                  if (rx_reg) begin\n                     busy <= 1'b0;\n                     state <= 2'b00;\n                  end\n                  baud_counter <= 0;\n               end else begin\n                  baud_counter <= baud_counter + 1;\n               end\n            end\n         endcase\n         rx_reg <= rx;\n      end\n   end\n\nendmodule",
        "module_name": "uart",
        "module_hash": "a0aba87c16dbf1b39cdecae070f4c161",
        "dataset_index": 9324
      },
      "my_logic_gate_21de8a3a": {
        "rtl_code": "\nmodule my_logic_gate (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1 \n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n\n\n    wire and1;\n    wire and2;\n    wire or1;\n\n    and base(\n        .Y(and1),\n        .A(A1),\n        .B(A2),\n        .C(B1),\n        .D(C1),\n        .E(D1)\n    );\n\n    and and_gate1(\n        .Y(and2),\n        .A(B1),\n        .B(C1),\n        .C(D1)\n    );\n\n    or or_gate1(\n        .Y(Y),\n        .A(and1),\n        .B(and2)\n    );\n\nendmodule",
        "module_name": "my_logic_gate",
        "module_hash": "21de8a3ad1a26003e6c3219a4d49a808",
        "dataset_index": 2935
      },
      "TX_dfa276fd": {
        "rtl_code": "\n\nmodule TX\n\t#( parameter stateA = 'b00001,\n\t\tparameter stateB = 'b00010,\n\t\tparameter stateC = 'b00100,\n\t\tparameter stateD = 'b01000,\n\t\tparameter stateE = 'b10000)\n\t(input clk,\n    input baud_rate,\n    input [7:0]d_in,\n    input tx_start,\n    output reg tx,\n    output reg tx_done);\n\n\treg [4:0] state = stateA;\n\treg [4:0] next_state = stateA;\n\t\n\treg tick_enable = 0;\n\tinteger count = 0;\n\treg rst_count = 1;\n\tinteger bit_count = 0;\n   reg [7:0] d_aux;\n\t\n\t\n\talways@(posedge clk)\n\tbegin\n\t\tstate=next_state;\n\tend\n\n    always@(posedge clk)\n    begin\n        case(state)\n            stateA:\n                if(tx_start == 1) next_state = stateB;\n                else next_state = stateA;\n            stateB:\n                if(bit_count == 1) next_state = stateC;\n                else next_state = stateB;\n            stateC:\n                if(bit_count == 9) next_state = stateD;\n                else next_state = stateC;\n            stateD:\n                if(bit_count == 10) next_state = stateE;\n                else next_state =  stateD;\n            stateE:\n                if(tx_done == 1) next_state = stateA;\n                else next_state = stateE;\n        endcase\n    end\n\n    always@(posedge clk)\n    begin\n        case(state)\n            stateA:\n            begin\n                tx = 1;\n                tx_done = 1;\n                rst_count = 0;\n\t\t\t\t\t tick_enable = 0;\n            end\n            stateB:\n            begin\n\t\t\t\t\ttx_done = 0;\n\t\t\t\t\trst_count = 1;\n\t\t\t\t\ttick_enable = 1;\n\t\t\t\t\tif(count == 16)\n\t\t\t\t\tbegin\n\t\t\t\t\t  tx = 0;\n\t\t\t\t\t  d_aux = d_in;\n\t\t\t\t\t  bit_count = bit_count + 1;\n\t\t\t\t\t  rst_count = 0;\n\t\t\t\t\tend\n            end\n            stateC:\n            begin\n\t\t\t\t\trst_count = 1;\n\t\t\t\t\tif(count == 16)\n\t\t\t\t\tbegin\n\t\t\t\t\t  tx = d_aux[0];\n\t\t\t\t\t  d_aux = d_aux >> 1;\n\t\t\t\t\t  bit_count = bit_count + 1;\n\t\t\t\t\t  rst_count = 0;\n\t\t\t\t\tend\n            end\n            stateD:\n\t\t\t\tbegin\n\t\t\t\t\trst_count = 1;\n\t\t\t\t\tif(count == 16)\n\t\t\t\t\tbegin\n\t\t\t\t\t\ttx = 1;\n\t\t\t\t\t\tbit_count = bit_count + 1;\n\t\t\t\t\t\trst_count = 0;\n\t\t\t\t\tend\n            end\n            stateE:\n            begin\n\t\t\t\t\tif(count == 16)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tbit_count = 0;\n\t\t\t\t\t\ttx_done = 1;\n\t\t\t\t\tend\n            end\n        endcase\n    end\n                \n                \nalways@(posedge baud_rate or negedge rst_count)\n    begin\n\t\tif(rst_count == 0) count = 0;\n\t\telse\n\t\tbegin\n\t\t\tif(tick_enable == 1)count = count + 1;\n\t\tend\n    end\n\t\nendmodule\n",
        "module_name": "TX",
        "module_hash": "dfa276fd89b345657e9613e06cdf377a",
        "dataset_index": 15491
      },
      "lvds2lcds_608f0977": {
        "rtl_code": "module lvds2lcds (\n\n\tinput clk,\n\tinput reset,\n\n\tinput            avs_slave_write,\n\tinput            avs_slave_read,\n\tinput       [7:0]avs_slave_writedata,\n\toutput      [7:0]avs_slave_readdata,\n\n\toutput           reset_n,\n\toutput           scl,\n\toutput           sdi,\n\toutput           sld\n);\n\n\tparameter        divider = 50;\n\n\treg         [8:0]clk_counter;\n\treg              div_clk;\n\treg              scl_en;\n\treg         [6:0]shift_buffer;\n\treg              shift_busy;\n\treg         [2:0]shift_counter;\n\n\tassign reset_n            = !reset;\n\tassign avs_slave_readdata = shift_busy;\n\tassign scl                = scl_en ? div_clk : 0;\n\tassign sld                = (!scl_en && shift_busy) ? div_clk : 0;\n\tassign sdi                = shift_buffer[6];\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\n\t\tif(reset)\n\t\tbegin\n\t\t\n\t\t\tclk_counter   <= 1;\n\t\t\tdiv_clk       <= 0;\n\t\t\tscl_en        <= 0;\n\t\t\tshift_busy    <= 0;\n\t\t\tshift_counter <= 0;\n\n\t\tend\n\t\telse\n\t\tbegin\tif(shift_busy)\n\t\t\tbegin\n\t\t\t\n\t\t\t\tif(clk_counter == (divider/2))\n\t\t\t\tbegin\n\t\t\t\t\tclk_counter <= 1;\n\t\t\t\t\tdiv_clk     <= !div_clk;\n\t\t\t\t\tif(div_clk)\n\t\t\t\t\tbegin\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!scl_en)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tshift_busy <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif(shift_counter == 6)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tscl_en        <= 0;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tshift_counter <= shift_counter + 1;\n\t\t\t\t\t\t\t\tshift_buffer  <= shift_buffer << 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tclk_counter = clk_counter + 1;\n\t\t\t\tend\n\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\n\t\t\t\tclk_counter   <= 1;\n\t\t\t\tshift_counter <= 0;\n\t\t\t\tdiv_clk       <= 0;\n\t\t\t\tif(avs_slave_write)\n\t\t\t\tbegin\n\t\t\t\t\tshift_buffer <= avs_slave_writedata;\n\t\t\t\t\tshift_busy   <= 1;\n\t\t\t\t\tscl_en       <= 1;\n\t\t\t\tend\n\t\t\t\n\t\t\tend\n\n\t\tend\n\tend\n\nendmodule",
        "module_name": "lvds2lcds",
        "module_hash": "608f09774f2915e036f3992b72ce5d7a",
        "dataset_index": 24505
      },
      "Week8Lab_14d3ad93": {
        "rtl_code": "\nmodule Week8Lab(\n    input Clk,\n    output reg [6:0] Cathodes,\n    output reg [3:0] Anode\n    );\n    \n    reg[1:0 ] digit = 2'b00;\n    \n    reg [27:0] Count;\n    reg Rate;\n    initial begin\n        Count = 0;\n        Rate = 0;\n        end\n        \n    always @ (posedge Clk)\n        begin\n             \n             if (Count == 216666)\n             begin\n                Rate = ~Rate;\n                Count = 0;\n             end\n             else\n             begin\n                Count = Count + 1;\n                end\n        end\n    \n    always @ (posedge Rate)\n    begin\n        case (digit)\n            2'b00: begin\n                    Anode[0] = 0;\n                    Anode[1] = 1;\n                    Anode[2] = 1;\n                    Anode[3] = 1;\n                    Cathodes[0] = 1;\n                     Cathodes[1] = 0;\n                     Cathodes[2] = 0;\n                     Cathodes[3] = 1;\n                     Cathodes[4] = 1;\n                     Cathodes[5] = 0;\n                     Cathodes[6] = 0;\n                end\n                2'b01: begin\n                     Anode[0] = 1;\n                           Anode[1] = 0;\n                           Anode[2] = 1;\n                           Anode[3] = 1;\n                    Cathodes[0] = 0;\n                     Cathodes[1] = 0;\n                     Cathodes[2] = 0;\n                     Cathodes[3] = 0;\n                     Cathodes[4] = 1;\n                     Cathodes[5] = 1;\n                     Cathodes[6] = 0;\n                end\n                \n                2'b10: begin\n                    Anode[0] = 1;\n                           Anode[1] = 1;\n                           Anode[2] = 0;\n                           Anode[3] = 1;\n                    Cathodes[0] = 0;\n                     Cathodes[1] = 0;\n                     Cathodes[2] = 1;\n                     Cathodes[3] = 0;\n                     Cathodes[4] = 0;\n                     Cathodes[5] = 1;\n                     Cathodes[6] = 0;\n                end\n                \n                2'b11: begin\n                     Anode[0] = 1;\n                           Anode[1] = 1;\n                           Anode[2] = 1;\n                           Anode[3] = 0;\n                    Cathodes[0] = 1;\n                     Cathodes[1] = 0;\n                     Cathodes[2] = 0;\n                     Cathodes[3] = 1;\n                     Cathodes[4] = 1;\n                     Cathodes[5] = 1;\n                     Cathodes[6] = 1;\n                end\n        \n        \n        endcase\n        digit = digit + 1;\n        \n    end \n\n\nendmodule\n",
        "module_name": "Week8Lab",
        "module_hash": "14d3ad93f26405734b390010e40757b7",
        "dataset_index": 15182
      },
      "hamming #_d8e0ef25": {
        "rtl_code": "module hamming #(\n  parameter k = 4, // number of data bits\n  parameter n = 7 // number of encoded bits\n)(\n  input [k-1:0] data_in,\n  input [n-1:0] received,\n  output [n-1:0] encoded,\n  output [k-1:0] data_out\n);\n\n\nparameter h = {{3'b001, 3'b011, 3'b010, 3'b100},\n               {3'b101, 3'b111, 3'b110, 3'b000},\n               {3'b111, 3'b101, 3'b100, 3'b010},\n               {3'b011, 3'b001, 3'b000, 3'b110},\n               {3'b110, 3'b100, 3'b101, 3'b011},\n               {3'b010, 3'b000, 3'b001, 3'b111},\n               {3'b000, 3'b010, 3'b011, 3'b101}}; // parity check matrix\n\nwire [n-k-1:0] parity; // parity bits\n\n// Encoder\ngenvar i;\ngenerate\n  for (i = 0; i < n-k; i = i + 1) begin : parity_gen\n    assign parity[i] = data_in & h[i];\n  end\nendgenerate\nassign encoded = {parity, data_in};\n\n// Decoder\nwire [n-k-1:0] syndrome;\nwire [n-1:0] corrected;\ngenvar j;\ngenerate\n  for (j = 0; j < n-k; j = j + 1) begin : syndrome_gen\n    assign syndrome[j] = received & h[j];\n  end\nendgenerate\nassign corrected = received ^ {syndrome, {k{1'b0}}};\nassign data_out = corrected[n-1:n-k];\n\nendmodule",
        "module_name": "hamming #",
        "module_hash": "d8e0ef259d8a32f74d5b4716abf48200",
        "dataset_index": 15057
      },
      "axi_ad9680_if_8489a5ce": {
        "rtl_code": "module axi_ad9680_if (\n  input           rx_clk,\n  input  [127:0]  rx_data,\n  output          adc_clk,\n  input           adc_rst,\n  output  [55:0]  adc_data_a,\n  output  [55:0]  adc_data_b,\n  output          adc_or_a,\n  output          adc_or_b,\n  output          adc_status\n);\n\n  reg             adc_status = 1'b0;\n  wire    [15:0]  adc_data_a_s3_s;\n  wire    [15:0]  adc_data_a_s2_s;\n  wire    [15:0]  adc_data_a_s1_s;\n  wire    [15:0]  adc_data_a_s0_s;\n  wire    [15:0]  adc_data_b_s3_s;\n  wire    [15:0]  adc_data_b_s2_s;\n  wire    [15:0]  adc_data_b_s1_s;\n  wire    [15:0]  adc_data_b_s0_s;\n\n  assign adc_clk = rx_clk;\n  assign adc_or_a = 1'b0;\n  assign adc_or_b = 1'b0;\n\n  assign adc_data_a = { adc_data_a_s3_s[13:0], adc_data_a_s2_s[13:0],\n                        adc_data_a_s1_s[13:0], adc_data_a_s0_s[13:0]};\n\n  assign adc_data_b = { adc_data_b_s3_s[13:0], adc_data_b_s2_s[13:0],\n                        adc_data_b_s1_s[13:0], adc_data_b_s0_s[13:0]};\n\n  assign adc_data_a_s3_s = {rx_data[ 57: 56], rx_data[ 31: 24], rx_data[ 63: 58]};\n  assign adc_data_a_s2_s = {rx_data[ 49: 48], rx_data[ 23: 16], rx_data[ 55: 50]};\n  assign adc_data_a_s1_s = {rx_data[ 41: 40], rx_data[ 15:  8], rx_data[ 47: 42]};\n  assign adc_data_a_s0_s = {rx_data[ 33: 32], rx_data[  7:  0], rx_data[ 39: 34]};\n\n  assign adc_data_b_s3_s = {rx_data[121:120], rx_data[ 95: 88], rx_data[127:122]};\n  assign adc_data_b_s2_s = {rx_data[113:112], rx_data[ 87: 80], rx_data[119:114]};\n  assign adc_data_b_s1_s = {rx_data[105:104], rx_data[ 79: 72], rx_data[111:106]};\n  assign adc_data_b_s0_s = {rx_data[ 97: 96], rx_data[ 71: 64], rx_data[103: 98]};\n\n  always @(posedge rx_clk) begin\n    if (adc_rst == 1'b1) begin\n      adc_status <= 1'b0;\n    end else begin\n      adc_status <= 1'b1;\n    end\n  end\n\nendmodule",
        "module_name": "axi_ad9680_if",
        "module_hash": "8489a5cea4809951b545ea770ad24c6c",
        "dataset_index": 9052
      },
      "recepcion_07392174": {
        "rtl_code": "module recepcion(input rx,\n                 output reg avail, \n                 output reg [7:0] dout,\n                 input wire clk_div);\n\ninitial begin\n    avail=0;\n\tdout = 8'b00000000; \nend\n\nparameter RX_STATE_START\t= 2'b00;\nparameter RX_STATE_DATA\t\t= 2'b01;\nparameter RX_STATE_STOP\t\t= 2'b10;\n\nreg [1:0] state = RX_STATE_START;\nreg [3:0] bitpos = 0;\nreg [7:0] scratch = 8'b00000000;\n\nalways @(negedge clk_div) begin \n        \n\t\tcase (state)\n\t\tRX_STATE_START: begin\n            avail<=0;\t\t\t\n            if (rx==0) begin\n                bitpos <= 0;\n\t\t\t\tscratch <= 0;\t\t\t\t\n                state <= RX_STATE_DATA;\n\t\t\tend\n\t\tend\n        RX_STATE_DATA: begin \t\t\t\n                if(bitpos<=7) begin\n    \t\t\t\tscratch[bitpos] <= rx;\n    \t\t\t\tbitpos<=bitpos+1;\n    \t\t\tend\n    \t\t\tif (bitpos == 8)begin\n    \t\t\t\tstate <= RX_STATE_STOP;\n                end\n        end\n\t\tRX_STATE_STOP: begin\n\t\t\tif (rx==1) begin\n\t\t\t\tstate <= RX_STATE_START;\n\t\t\t\tdout <= scratch;\n\t\t\t\tavail <= 1;\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\tstate <= RX_STATE_START;\n\t\tend\n\t\tendcase\n\tend\n\nendmodule\n",
        "module_name": "recepcion",
        "module_hash": "0739217495b31a9bcefdf117baa5a5f1",
        "dataset_index": 24295
      },
      "vending_machine_475b3aba": {
        "rtl_code": "module vending_machine(\n    input clk, \n    input reset, \n    input [1:0] coin, \n    input [3:0] product, \n    output reg dispense, \n    output reg [1:0] change, \n    output reg ready\n);\n\nreg [3:0] product_price;\nreg [7:0] coins_inserted;\nreg [1:0] coins_returned;\nreg dispense_product;\nreg return_coins;\nreg ready_state;\n\nalways @(*) begin\n    case(product)\n        5'd5: product_price = 5;\n        5'd6: product_price = 10;\n        5'd7: product_price = 15;\n        5'd8: product_price = 20;\n        5'd9: product_price = 25;\n        5'd10: product_price = 30;\n        5'd11: product_price = 35;\n        5'd12: product_price = 40;\n        5'd13: product_price = 45;\n        5'd14: product_price = 50;\n        5'd15: product_price = 55;\n        5'd16: product_price = 60;\n        5'd17: product_price = 65;\n        5'd18: product_price = 70;\n        5'd19: product_price = 75;\n        5'd20: product_price = 80;\n        5'd21: product_price = 85;\n        5'd22: product_price = 90;\n        5'd23: product_price = 95;\n        5'd24: product_price = 100;\n        default: product_price = 0;\n    endcase;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        coins_inserted <= 0;\n        coins_returned <= 0;\n        dispense_product <= 0;\n        return_coins <= 0;\n        ready_state <= 1;\n    end else begin\n        if(coin == 2'b00) begin // 1 cent\n            coins_inserted <= coins_inserted + 1;\n        end else if(coin == 2'b01) begin // 5 cents\n            coins_inserted <= coins_inserted + 5;\n        end else if(coin == 2'b10) begin // 10 cents\n            coins_inserted <= coins_inserted + 10;\n        end else if(coin == 2'b11) begin // 25 cents\n            coins_inserted <= coins_inserted + 25;\n        end\n        \n        if(coins_inserted >= product_price && ready_state == 1) begin\n            dispense_product <= 1;\n            coins_returned <= coins_inserted - product_price;\n            coins_inserted <= 0;\n            ready_state <= 0;\n        end else if(product_price > coins_inserted) begin\n            return_coins <= coin;\n        end\n    end\nend\n\nalways @(*) begin\n    dispense = dispense_product;\n    change = coins_returned;\n    ready = ready_state;\nend\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "475b3abaa30a771286700f7c8666ccc4",
        "dataset_index": 11507
      },
      "MAC_REG_ACC_a0b76af9": {
        "rtl_code": "module MAC_REG_ACC(\n    input               clk,\n    input               reset,\n    input               waitrequest,\n    input       [31:0]  readdata,\n\n    output reg  [7:0]   address,\n    output reg          write,\n    output reg          read,\n    output reg  [31:0]  writedata\n);\n\n    reg         [2:0]   reg_count;\n    reg         [3:0]   count;\n    reg         [1:0]   current_state;\n    parameter   idle_s      =   2'b00,\n                wait_clk_s  =   2'b01,\n                write_s     =   2'b10,  \n                wait_s      =   2'b11;\n\n    always@(posedge clk or negedge reset) begin\n        if(!reset) begin\n            address     <= 8'b0;\n            write       <= 1'b0;\n            read        <= 1'b0;\n            writedata   <= 32'b0;\n            reg_count   <= 3'b0;\n            count       <= 4'b0;\n            current_state   <= wait_clk_s;\n        end \n        else begin\n            case(current_state)\n                wait_clk_s: begin\n                    reg_count   <= 3'b0;\n                    count       <= count + 1'b1;\n                    if(count[3] == 1'b1) begin\n                        current_state   <= idle_s;\n                    end\n                    else begin\n                        current_state   <= wait_clk_s;\n                    end\n                end\n                idle_s: begin\n                    address     <= 8'b0;\n                    write       <= 1'b0;\n                    read        <= 1'b0;\n                    writedata   <= 32'b0;\n                    count       <= 4'b0;\n                    if(reg_count < 3'd4) begin\n                        reg_count       <= reg_count + 3'b1;\n                        current_state   <= write_s;\n                    end\n                    else begin                        \n                        current_state   <= idle_s;\n                    end\n                end\n                write_s: begin\n                    \n                    current_state   <= wait_s;\n                    case(reg_count)\n                        3'd1: begin\n                            address     <= 8'h2;\n                            write       <= 1'b1;\n                            writedata   <= 32'h1000093;\n                        end\n                        3'd2: begin\n                            address     <= 8'he;\n                            write       <= 1'b1;\n                            writedata   <= 32'h4;\n                        end\n                        3'd3: begin\n                            address     <= 8'h94;\n                            write       <= 1'b1;\n                            writedata   <= 32'h7;\n                        end\n                        default: begin\n                            address     <= 8'h2;\n                            writedata   <= 32'h1000093; \n                        end\n                    endcase\n                end\n                wait_s: begin\n                    write   <= 1'b1;\n                    if(waitrequest == 1'b0) begin\n                        current_state   <= idle_s;\n                        write           <= 1'b1;\n                    end\n                    else begin\n                        current_state   <= wait_s;\n                    end\n                end\n            endcase\n        end \n    end \n\nendmodule",
        "module_name": "MAC_REG_ACC",
        "module_hash": "a0b76af93902886eba5fb67126aefe0f",
        "dataset_index": 19692
      },
      "dpth_addr_167915bd": {
        "rtl_code": "module dpth_addr (\n  input  wire        clk,\n  input  wire        rst_n,\n  input  wire [7:0]  ir_low,\n  input  wire [7:0]  rx_low,\n  input  wire        ld_rat,\n  input  wire        ld_pc,\n  input  wire        pc_at,\n  output wire [7:0]  m_at\n);\n\n  wire [7:0] low_sum;\n  wire [7:0] pc_plus_one;\n\n  reg  [7:0] rat;\n  reg  [7:0] pc;\n\n  always @(negedge rst_n, posedge clk)\n  begin: p_addr_rat_update\n\n    if (rst_n == 1'b0)\n      rat <= {8{1'b0}};\n    else if (ld_rat == 1'b1)\n      rat <= low_sum;\n\n  end\n\n  always @(negedge rst_n, posedge clk)\n  begin: p_addr_pc_update\n\n    if (rst_n == 1'b0)\n      pc <= {8{1'b0}};\n    else if (ld_rat == 1'b1)\n      pc <= pc_plus_one;\n\n  end\n\n  assign m_at = (pc_at == 1'b0) ? pc : rat;\n\n  assign low_sum = ir_low + rx_low;\n  assign pc_plus_one = m_at + 8'b00000001;\n\nendmodule\n\n",
        "module_name": "dpth_addr",
        "module_hash": "167915bd32fc77b863fd61001fe3e98d",
        "dataset_index": 20177
      },
      "sky130_fd_sc_hd__o221ai_e53966d9": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__o221ai",
        "module_hash": "e53966d95918efb4ba0d8f4745c97e13",
        "dataset_index": 22161
      },
      "address_operation_813bd6c5": {
        "rtl_code": "module address_operation (\n    input   [8:0]   address_a,\n    input   [8:0]   address_b,\n    input   clock,\n    output  [3:0]   q_a,\n    output  [3:0]   q_b\n);\n\n    reg     [3:0]   q_a;\n    reg     [3:0]   q_b;\n\n    always @(posedge clock) begin\n        if (address_a[8] == 1) begin\n            q_a = address_a[3:0] + 1;\n        end else begin\n            q_a = address_a[3:0] + 2;\n        end\n\n        if (address_b[8] == 1) begin\n            q_b = address_b[3:0] + 1;\n        end else begin\n            q_b = address_b[3:0] + 2;\n        end\n    end\n\nendmodule",
        "module_name": "address_operation",
        "module_hash": "813bd6c5576921dfe9b70f673cb929cb",
        "dataset_index": 315
      },
      "binary_to_excess3_d0bcb78e": {
        "rtl_code": "\nmodule binary_to_excess3 (\n    input [3:0] B,\n    output [3:0] E3\n);\n\nassign E3 = B + 3;\n\nendmodule\nmodule top_module (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] E\n);\n\nwire [7:0] sum;\nbinary_to_excess3 b2e1(.B(sum[3:0]), .E3(E[3:0]));\nbinary_to_excess3 b2e2(.B(sum[7:4]), .E3(E[7:4]));\n\nassign sum = A + B;\n\nendmodule",
        "module_name": "binary_to_excess3",
        "module_hash": "d0bcb78e332fc9b604218e5de2ab4479",
        "dataset_index": 10804
      },
      "Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Edge_Detection_Router_Controller_f488d811": {
        "rtl_code": "module Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Edge_Detection_Router_Controller (\n  // inputs:\n  input [1:0] address,\n  input chipselect,\n  input clk,\n  input reset_n,\n  input write_n,\n  input [31:0] writedata,\n\n  // outputs:\n  output out_port,\n  output [31:0] readdata\n);\n\n  wire clk_en;\n  reg data_out;\n  wire out_port;\n  wire read_mux_out;\n  wire [31:0] readdata;\n\n  assign clk_en = 1;\n\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {1 {(address == 0)}} & data_out;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      data_out <= 0;\n    end\n    else if (chipselect && !write_n && (address == 0)) begin\n      data_out <= writedata;\n    end\n  end\n\n  assign readdata = {32'b0, read_mux_out};\n  assign out_port = data_out;\n\nendmodule",
        "module_name": "Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Edge_Detection_Router_Controller",
        "module_hash": "f488d811c5a3dcd2fed50e33f0118712",
        "dataset_index": 11206
      },
      "sky130_fd_sc_hdll__a21boi_fdb87573": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__a21boi (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire b         ;\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    not not0 (b         , B1_N           );\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, b, and0_out    );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__a21boi",
        "module_hash": "fdb8757352ac31e49439384fda76f08f",
        "dataset_index": 22424
      },
      "constant_voltage_driver_09710af2": {
        "rtl_code": "module constant_voltage_driver (\n  input [3:0] data_in,\n  input [1:0] mode,\n  output reg [9:0] v_out\n);\n\n  // Define binary constants for the voltage levels\n  parameter ZERO_VOLT = 10'b0000000000;\n  parameter ONE_POINT_TWO_FIVE_VOLT = 10'b0100000000;\n  parameter TWO_POINT_FIVE_VOLT = 10'b1000000000;\n  parameter THREE_POINT_SEVEN_FIVE_VOLT = 10'b1100000000;\n\n  // Connect the inputs to an output buffer based on the mode\n  always @(*) begin\n    case (mode)\n      2'b00: v_out = ZERO_VOLT;\n      2'b01: v_out = ONE_POINT_TWO_FIVE_VOLT;\n      2'b10: v_out = TWO_POINT_FIVE_VOLT;\n      2'b11: v_out = THREE_POINT_SEVEN_FIVE_VOLT;\n      default: v_out = ZERO_VOLT;\n    endcase\n  end\n\nendmodule",
        "module_name": "constant_voltage_driver",
        "module_hash": "09710af25825c7b551eed523dd2cf775",
        "dataset_index": 2096
      },
      "wb_abrg_44aa859e": {
        "rtl_code": "\n\nmodule wb_abrg (\n    input sys_rst,\n\n    input             wbs_clk_i,\n    input      [19:1] wbs_adr_i,\n    input      [15:0] wbs_dat_i,\n    output reg [15:0] wbs_dat_o,\n    input      [ 1:0] wbs_sel_i,\n    input             wbs_tga_i,\n    input             wbs_stb_i,\n    input             wbs_cyc_i,\n    input             wbs_we_i,\n    output            wbs_ack_o,\n\n    input             wbm_clk_i,\n    output reg [19:1] wbm_adr_o,\n    output reg [15:0] wbm_dat_o,\n    input      [15:0] wbm_dat_i,\n    output reg [ 1:0] wbm_sel_o,\n    output reg        wbm_tga_o,\n    output            wbm_stb_o,\n    output            wbm_cyc_o,\n    output reg        wbm_we_o,\n    input             wbm_ack_i\n  );\n\n  wire       wbs_stb;\n  wire       init_tr;\n  reg        wbm_stb;\n  reg  [2:0] sync_stb;\n  reg  [2:0] sync_ack;\n  reg        ft_stb;\n  reg        ft_ack;\n  reg        stb_r;\n  reg        ack_r;\n\n  reg [19:1] wbm_adr_o_r;\n  reg [15:0] wbm_dat_o_r;\n  reg [ 1:0] wbm_sel_o_r;\n  reg        wbm_tga_o_r;\n  reg        wbm_we_o_r;\n  reg [15:0] wbs_dat_o_r;\n  reg [15:0] wbm_dat_i_r;\n\n  assign wbs_stb = wbs_stb_i & wbs_cyc_i;\n\n  assign wbs_ack_o = (sync_ack[2] ^ sync_ack[1]);\n  assign wbm_stb_o = wbm_stb;\n  assign wbm_cyc_o = wbm_stb;\n\n  \n  assign init_tr = ~stb_r & wbs_stb | ack_r & ~wbs_ack_o & wbs_stb;\n\n  always @(posedge wbm_clk_i)\n    wbm_stb <= sys_rst ? 1'b0\n      : (wbm_stb ? ~wbm_ack_i : sync_stb[2] ^ sync_stb[1]);\n\n  always @(posedge wbs_clk_i) stb_r <= wbs_stb;\n  always @(posedge wbs_clk_i) ack_r <= wbs_ack_o;\n\n  always @(posedge wbs_clk_i)\n    ft_stb <= sys_rst ? 1'b0 : (init_tr ? ~ft_stb : ft_stb);\n\n  always @(posedge wbm_clk_i)\n    sync_stb <= sys_rst ? 3'h0 : {sync_stb[1:0], ft_stb};\n\n  always @(posedge wbm_clk_i)\n    ft_ack <= sys_rst ? 1'b0 : (wbm_ack_i ? ~ft_ack : ft_ack);\n\n  always @(posedge wbs_clk_i)\n    sync_ack <= sys_rst ? 3'h0 : {sync_ack[1:0], ft_ack};\n\n  always @(posedge wbm_clk_i)\n    {wbm_adr_o, wbm_adr_o_r} <= {wbm_adr_o_r, wbs_adr_i};\n\n  always @(posedge wbm_clk_i)\n    {wbm_dat_o, wbm_dat_o_r} <= {wbm_dat_o_r, wbs_dat_i};\n\n  always @(posedge wbm_clk_i)\n    {wbm_sel_o, wbm_sel_o_r} <= {wbm_sel_o_r, wbs_sel_i};\n\n  always @(posedge wbm_clk_i)\n    {wbm_we_o, wbm_we_o_r} <= {wbm_we_o_r, wbs_we_i};\n\n  always @(posedge wbm_clk_i)\n    {wbm_tga_o, wbm_tga_o_r} <= {wbm_tga_o_r, wbs_tga_i};\n\n  \n  always @(posedge wbm_clk_i)\n    wbm_dat_i_r <= wbm_ack_i ? wbm_dat_i : wbm_dat_i_r;\n\n  always @(posedge wbs_clk_i)\n    {wbs_dat_o, wbs_dat_o_r} <= {wbs_dat_o_r, wbm_dat_i_r};\n\nendmodule\n",
        "module_name": "wb_abrg",
        "module_hash": "44aa859e4735ac6f6c770b0db4e2584a",
        "dataset_index": 24848
      },
      "thermal_management_block_944dfffd": {
        "rtl_code": "module thermal_management_block (\n  input clk,\n  input rst,\n  input temp_sensor,\n  input [7:0] temp_threshold_high,\n  input [7:0] temp_threshold_low,\n  output reg [7:0] fan_speed,\n  output reg [7:0] temp_digital\n);\n\n  // ADC module\n  reg [7:0] adc_value;\n  always @(posedge clk) begin\n    if (rst) begin\n      adc_value <= 8'h00;\n    end else begin\n      adc_value <= temp_sensor;\n    end\n  end\n  \n  // Digital filter module\n  reg [7:0] filtered_value;\n  always @(posedge clk) begin\n    if (rst) begin\n      filtered_value <= 8'h00;\n    end else begin\n      filtered_value <= (filtered_value + adc_value) >> 1;\n    end\n  end\n  \n  // PWM module\n  reg [7:0] pwm_count;\n  always @(posedge clk) begin\n    if (rst) begin\n      pwm_count <= 8'h00;\n      fan_speed <= 8'h00;\n    end else begin\n      if (pwm_count >= filtered_value) begin\n        pwm_count <= 8'h00;\n        if (filtered_value > temp_threshold_high) begin\n          fan_speed <= 8'hFF;\n        end else if (filtered_value < temp_threshold_low) begin\n          fan_speed <= 8'h00;\n        end\n      end else begin\n        pwm_count <= pwm_count + 1;\n      end\n    end\n  end\n  \n  // Output digital temperature value\n  always @(posedge clk) begin\n    if (rst) begin\n      temp_digital <= 8'h00;\n    end else begin\n      temp_digital <= filtered_value;\n    end\n  end\n  \nendmodule\n",
        "module_name": "thermal_management_block",
        "module_hash": "944dfffd74679ef7d828b0832a18efff",
        "dataset_index": 16097
      },
      "sky130_fd_sc_hd__fa_57318698": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__fa (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CIN\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CIN ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out     ;\n    wire and0_out    ;\n    wire and1_out    ;\n    wire and2_out    ;\n    wire nor0_out    ;\n    wire nor1_out    ;\n    wire or1_out_COUT;\n    wire or2_out_SUM ;\n\n    or  or0  (or0_out     , CIN, B            );\n    and and0 (and0_out    , or0_out, A        );\n    and and1 (and1_out    , B, CIN            );\n    or  or1  (or1_out_COUT, and1_out, and0_out);\n    buf buf0 (COUT        , or1_out_COUT      );\n    and and2 (and2_out    , CIN, A, B         );\n    nor nor0 (nor0_out    , A, or0_out        );\n    nor nor1 (nor1_out    , nor0_out, COUT    );\n    or  or2  (or2_out_SUM , nor1_out, and2_out);\n    buf buf1 (SUM         , or2_out_SUM       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__fa",
        "module_hash": "573186986dd6b12643bcc37f3ab5036c",
        "dataset_index": 21565
      },
      "barrel_shifter_574bdc90": {
        "rtl_code": "module barrel_shifter(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [15:0] data,\n    output reg [15:0] q,\n    output wire [2:0] final_output\n);\n\nreg [15:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n        q <= data;\n    end else begin\n        case (ena)\n            2'b00: shift_reg <= {shift_reg[13:0], shift_reg[15:14]};\n            2'b01: shift_reg <= {shift_reg[14:0], shift_reg[15]};\n            2'b10: shift_reg <= {shift_reg[1:0], shift_reg[15:2]};\n            2'b11: shift_reg <= {shift_reg[2:0], shift_reg[15:3]};\n        endcase;\n        q <= shift_reg;\n    end\nend\n\nreg [2:0] mod_output;\n\nalways @* begin\n    mod_output = shift_reg[2:0] % 8;\nend\n\nassign final_output = ~mod_output;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "574bdc90cf813a43bcff8b528d657393",
        "dataset_index": 9557
      },
      "comparator_64386e82": {
        "rtl_code": "module comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output reg EQ,\n    output reg GT,\n    output reg LT\n);\n    \n    always @(*) begin\n        if (A == B) begin\n            EQ = 1;\n            GT = 0;\n            LT = 0;\n        end else if (A > B) begin\n            EQ = 0;\n            GT = 1;\n            LT = 0;\n        end else begin\n            EQ = 0;\n            GT = 0;\n            LT = 1;\n        end\n    end\n    \nendmodule",
        "module_name": "comparator",
        "module_hash": "64386e82f35553e5ba7d4aba915e071a",
        "dataset_index": 805
      },
      "top__926ee1cb": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input a,b,c,   // Binary inputs for the decoder module\n    output [7:0] q // 8-bit final output from the functional module\n);\n\n    // Instantiate the decoder module\n    decoder_3to4 decoder_inst(\n        .a(a),\n        .b(b),\n        .c(c),\n        .w(q[3]),\n        .x(q[2]),\n        .y(q[1]),\n        .z(q[0])\n    );\n\n    // Instantiate the counter module\n    counter_4bit counter_inst(\n        .clk(clk),\n        .reset(reset),\n        .q3(q[7]),\n        .q2(q[6]),\n        .q1(q[5]),\n        .q0(q[4])\n    );\n\nendmodule\n\n// 3-to-4 decoder module\nmodule decoder_3to4 (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    assign w = ~(a & b & c);\n    assign x = ~(a & b & ~c);\n    assign y = ~(a & ~b & c);\n    assign z = ~(a & ~b & ~c);\n\nendmodule\n\n// 4-bit binary counter module\nmodule counter_4bit (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output reg q3,\n    output reg q2,\n    output reg q1,\n    output reg q0\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q3 <= 0;\n            q2 <= 0;\n            q1 <= 0;\n            q0 <= 0;\n        end else begin\n            if (q0 == 0 && q1 == 0 && q2 == 0 && q3 == 0) begin\n                q0 <= 1;\n            end else if (q0 == 1 && q1 == 0 && q2 == 0 && q3 == 0) begin\n                q0 <= 0;\n                q1 <= 1;\n            end else if (q0 == 0 && q1 == 1 && q2 == 0 && q3 == 0) begin\n                q0 <= 1;\n                q1 <= 0;\n            end else if (q0 == 1 && q1 == 1 && q2 == 0 && q3 == 0) begin\n                q0 <= 0;\n                q1 <= 1;\n            end else if (q0 == 0 && q1 == 0 && q2 == 1 && q3 == 0) begin\n                q0 <= 1;\n                q1 <= 0;\n                q2 <= 0;\n            end else if (q0 == 1 && q1 == 0 && q2 == 1 && q3 == 0) begin\n                q0 <= 0;\n                q1 <= 1;\n                q2 <= 0;\n            end else if (q0 == 0 && q1 == 1 && q2 == 1 && q3 == 0) begin\n                q0 <= 1;\n                q1 <= 0;\n                q2 <= 0;\n            end else if (q0 == 1 && q1 == 1 && q2 == 1 && q3 == 0) begin\n                q0 <= 0;\n                q1 <= 0;\n                q2 <= 1;\n            end else if (q0 == 0 && q1 == 0 && q2 == 0 && q3 == 1) begin\n                q0 <= 1;\n                q1 <= 0;\n                q2 <= 0;\n                q3 <= 0;\n            end else if (q0 == 1 && q1 == 0 && q2 == 0 && q3 == 1) begin\n                q0 <= 0;\n                q1 <= 1;\n                q2 <= 0;\n                q3 <= 0;\n            end else if (q0 == 0 && q1 == 1 && q2 == 0 && q3 == 1) begin\n                q0 <= 1;\n                q1 <= 0;\n                q2 <= 0;\n                q3 <= 0;\n            end else if (q0 == 1 && q1 == 1 && q2 == 0 && q3 == 1) begin\n                q0 <= 0;\n                q1 <= 0;\n                q2 <= 1;\n                q3 <= 0;\n            end else if (q0 == 0 && q1 == 0 && q2 == 1 && q3 == 1) begin\n                q0 <= 1;\n                q1 <= 0;\n                q2 <= 0;\n                q3 <= 0;\n            end else if (q0 == 1 && q1 == 0 && q2 == 1 && q3 == 1) begin\n                q0 <= 0;\n                q1 <= 1;\n                q2 <= 0;\n                q3 <= 0;\n            end else if (q0 == 0 && q1 == 1 && q2 == 1 && q3 == 1) begin\n                q0 <= 1;\n                q1 <= 0;\n                q2 <= 0;\n                q3 <= 0;\n            end else if (q0 == 1 && q1 == 1 && q2 == 1 && q3 == 1) begin\n                q0 <= 0;\n                q1 <= 0;\n                q2 <= 0;\n                q3 <= 0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "926ee1cb7573e40f109b5fb0eadaf453",
        "dataset_index": 5025
      },
      "multiplexer #_429faa3e": {
        "rtl_code": "module multiplexer #(parameter n=1)(\n  input ctrl,\n  input [n-1:0] D0,\n  input [n-1:0] D1,\n  output [n-1:0] S\n);\n\n  assign S = ctrl ? D1 : D0;\n\nendmodule",
        "module_name": "multiplexer #",
        "module_hash": "429faa3e2bba0bba38af8ff5d2fe6775",
        "dataset_index": 4563
      },
      "rotator_nand_gate_0951c43c": {
        "rtl_code": "module rotator_nand_gate (\n   input clk,\n   input reset,\n   input load,\n   input [1:0] ena,\n   input [49:0] data,\n   input a,\n   input b,\n   input c,\n   output reg [49:0] q\n);\n\nreg [49:0] shift_reg;\nreg [1:0] state;\n\nalways @ (posedge clk or posedge reset) begin\n   if (reset) begin\n      shift_reg <= 50'b0;\n      state <= 2'b00;\n   end else begin\n      if (load) begin\n         shift_reg <= data;\n         state <= 2'b00;\n      end else begin\n         case (state)\n            2'b00: begin // idle\n               shift_reg <= shift_reg;\n               if (ena == 2'b01) begin\n                  state <= 2'b01; // rotate left\n               end else if (ena == 2'b10) begin\n                  state <= 2'b10; // rotate right\n               end\n            end\n            2'b01: begin // rotate left\n               shift_reg <= {shift_reg[48:0], shift_reg[49]};\n               if (ena == 2'b00) begin\n                  state <= 2'b00; // idle\n               end\n            end\n            2'b10: begin // rotate right\n               shift_reg <= {shift_reg[0], shift_reg[49:1]};\n               if (ena == 2'b00) begin\n                  state <= 2'b00; // idle\n               end\n            end\n         endcase\n      end\n   end\nend\n\nalways @(*) begin\n   q <= shift_reg;\nend\n\nendmodule",
        "module_name": "rotator_nand_gate",
        "module_hash": "0951c43ca8e55d2d6f0055b5b1fd4533",
        "dataset_index": 2558
      },
      "ripple_adder_663d963a": {
        "rtl_code": "module ripple_adder(\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] temp_sum;\n  wire [4:0] temp_carry;\n\n  assign temp_sum = a + b + cin;\n  assign temp_carry = {cin, temp_sum} + 1'b0;\n\n  assign sum = temp_sum;\n  assign cout = temp_carry[4];\n\nendmodule",
        "module_name": "ripple_adder",
        "module_hash": "663d963a39b1415711b7aa8a4d61a377",
        "dataset_index": 5207
      },
      "sky130_fd_sc_ls__or4b_9be6fdb5": {
        "rtl_code": "module sky130_fd_sc_ls__or4b (\n    input  A   ,\n    input  B   ,\n    input  C   ,\n    input  D_N ,\n    output X   ,\n\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\nwire AB, CD_N, ABCD_N;\nassign AB = A | B;\nassign CD_N = C | D_N;\nassign ABCD_N = AB | CD_N;\nassign X = ~ABCD_N;\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__or4b",
        "module_hash": "9be6fdb5c2a1e152e412bf752941a743",
        "dataset_index": 15879
      },
      "blk_mem_gen #_0b40d240": {
        "rtl_code": "module blk_mem_gen #(parameter WIDTH = 8, parameter DEPTH = 256) (\n    input wire clk,\n    input wire [WIDTH-1:0] din,\n    input wire we,\n    input wire [WIDTH-1:0] addr,\n    output wire [WIDTH-1:0] dout\n);\n\n  reg [WIDTH-1:0] mem [DEPTH-1:0];\n  assign dout = mem[addr];\n\n  always @(posedge clk) begin\n    if (we) begin\n      mem[addr] <= din;\n    end\n  end\n\nendmodule",
        "module_name": "blk_mem_gen #",
        "module_hash": "0b40d2409c7db5aff41d9ae5246ce610",
        "dataset_index": 3128
      },
      "enemyPosition_aa09fde7": {
        "rtl_code": "\nmodule enemyPosition(\n\tinput clk,\n\tinput frameClk,\n\tinput isEnemyActive,\n\tinput wire [7:0] _randomSeed,\n\tinput [3:0] uid,\n\toutput reg [9:0] enemyPositionX,\n\toutput reg [8:0] enemyPositionY\n);\n\tparameter top = 20;\n\tparameter bottom = 440;\n\tparameter center = 220;\n\tparameter left = 20;\n\tparameter right = 600;\n\tparameter middle = 300;\n\tparameter north = 2'b00;\n\tparameter south = 2'b01;\n\tparameter west = 2'b10;\n\tparameter east = 2'b11;\n\n\t\n\treg [1:0] enemyDirectionFrom;\n\treg [1:0] enemyDirectionTo;\n\treg recentEnemyActive;\n\treg [10:0] randomSeed;\n\n\tinitial begin\n\t\tenemyPositionX     =  'd0;\n\t\tenemyPositionY     =  'd0;\n\t\tenemyDirectionFrom = 2'b00;\n\t\tenemyDirectionTo   = 2'b00;\n\t\trecentEnemyActive  = 1'b0;\n\t\trandomSeed         = 'd0;\n\tend\n\n\talways @(posedge frameClk) begin\n\t\trandomSeed = (_randomSeed[6:0] * uid)+uid;\n\t\tif(isEnemyActive == 1'b1) begin\n\t\t\tcase(recentEnemyActive)\n\t\t\t\t1'b0: begin\n\t\t\t\t\tenemyDirectionFrom <= randomSeed[1:0];\n\t\t\t\t\tenemyDirectionTo   <= randomSeed[3:2];\n\t\t\t\t\tif(enemyDirectionFrom == enemyDirectionTo) begin\n\t\t\t\t\t\tenemyDirectionTo <= enemyDirectionFrom + 1;\n\t\t\t\t\tend\n\n\t\t\t\t\tcase(enemyDirectionFrom)\n\t\t\t\t\t\tnorth: begin if (randomSeed[3] == 1'b1) begin\n\t\t\t\t\t\t\t\tenemyPositionX <= middle + (randomSeed[2:0] * 30);\n\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tenemyPositionX <= middle - (randomSeed[2:0] * 30);\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tenemyPositionY <= top+1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\tsouth: begin if (randomSeed[3] == 1'b1) begin\n\t\t\t\t\t\t\t\tenemyPositionX <= middle + (randomSeed[2:0] * 30);\n\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tenemyPositionX <= middle - (randomSeed[2:0] * 30);\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tenemyPositionY <= bottom-1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\twest: begin enemyPositionX <= left+1;\n\t\t\t\t\t\t\tif (randomSeed[3] == 1'b1) begin\n\t\t\t\t\t\t\t\tenemyPositionY <= center + (randomSeed[2:0] * 25);\n\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tenemyPositionY <= center - (randomSeed[2:0] * 25);\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\teast: begin enemyPositionX <= right-1;\n\t\t\t\t\t\t\tif (randomSeed[3] == 1'b1) begin\n\t\t\t\t\t\t\t\tenemyPositionY <= center + (randomSeed[2:0] * 25);\n\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tenemyPositionY <= center - (randomSeed[2:0] * 25);\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\tendcase\n\t\t\t\t\trecentEnemyActive <= 1'b1;\n\t\t\t\tend\n\t\t\t\t1'b1: begin\n\t\t\t\t\tif (enemyPositionX >= left && enemyPositionX <= right && enemyPositionY >= top && enemyPositionY <= bottom) begin\n\t\t\t\t\t\tcase(enemyDirectionFrom)\n\t\t\t\t\t\t\tnorth: begin enemyPositionY <= enemyPositionY + 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tsouth: begin enemyPositionY <= enemyPositionY - 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\twest: begin enemyPositionX <= enemyPositionX + 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\teast: begin enemyPositionX <= enemyPositionX - 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(enemyDirectionTo)\n\t\t\t\t\t\t\tnorth: begin enemyPositionY <= enemyPositionY - 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tsouth: begin enemyPositionY <= enemyPositionY + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\twest: begin enemyPositionX <= enemyPositionX - 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\teast: begin enemyPositionX <= enemyPositionX + 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\tendcase\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tenemyDirectionFrom <= enemyDirectionTo;\n\t\t\t\t\t\tenemyDirectionTo   <= randomSeed[3:2];\n\t\t\t\t\t\tif(enemyDirectionFrom == enemyDirectionTo) begin\n\t\t\t\t\t\t\tenemyDirectionTo <= enemyDirectionFrom + 1;\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\tif (enemyPositionY > top) begin\n\t\t\t\t\t\t\tenemyPositionY <= enemyPositionY - 2;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tenemyPositionY <= top + 2;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (enemyPositionX > left) begin\n\t\t\t\t\t\t\tenemyPositionX <= enemyPositionX - 2;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tenemyPositionX <= left + 2;\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\tcase(enemyDirectionFrom)\n\t\t\t\t\t\t\tnorth: begin enemyPositionY <= enemyPositionY + 2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tsouth: begin enemyPositionY <= enemyPositionY - 2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\twest: begin enemyPositionX <= enemyPositionX + 2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\teast: begin enemyPositionX <= enemyPositionX - 2;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tendcase\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend else begin\n\t\t\tenemyPositionX     <=  'd0;\n\t\t\tenemyPositionY     <=  'd0;\n\t\t\tenemyDirectionFrom <= 2'b00;\n\t\t\tenemyDirectionTo   <= 2'b00;\n\t\t\trecentEnemyActive  <= 1'b0;\n\t\tend\n\tend\nendmodule\n",
        "module_name": "enemyPosition",
        "module_hash": "aa09fde7c2948881cbdff4db841dc9dc",
        "dataset_index": 15311
      },
      "counter_2bit_71383ca8": {
        "rtl_code": "module counter_2bit (\n    input CLK,\n    input RESET,\n    output reg Q1,\n    output reg Q0\n);\n\nreg [1:0] count_reg;\nreg [1:0] next_count_reg;\n\nalways @(posedge CLK or posedge RESET) begin\n    if(RESET) begin\n        count_reg <= 2'b00;\n    end\n    else begin\n        count_reg <= next_count_reg;\n    end\nend\n\nalways @* begin\n    case(count_reg)\n        2'b00: next_count_reg = 2'b01;\n        2'b01: next_count_reg = 2'b10;\n        2'b10: next_count_reg = 2'b11;\n        2'b11: next_count_reg = 2'b00;\n    endcase\nend\n\nalways @* begin\n    Q1 = count_reg[1];\n    Q0 = count_reg[0];\nend\n\nendmodule",
        "module_name": "counter_2bit",
        "module_hash": "71383ca8efbb44c222cba0fc5c4e8937",
        "dataset_index": 13378
      },
      "HilbertTransform_1588cf95": {
        "rtl_code": "\nmodule HilbertTransform (\n  input in,\n  output out1,\n  output out2,\n  input clock\n);\n\n  parameter N = 32;        // number of filter taps\n  parameter Fs = 100;      // sampling frequency\n\n  reg [N-1:0] delay_line; // delay line for filter\n  reg [N-1:0] coefficients; // filter coefficients\n  reg signed [31:0] real_part; // real part of Hilbert transformed signal\n  reg signed [31:0] imag_part; // imaginary part of Hilbert transformed signal\n\n  integer i;\n\n  // initialize filter coefficients\n  initial begin\n    coefficients = {16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000,\n                    16'h0001, 16'h0001, 16'h0001, 16'h0001, 16'h0001, 16'h0001, 16'h0001, 16'h0001,\n                    16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000, 16'h0000,\n                    16'hFFFF, 16'hFFFF, 16'hFFFF, 16'hFFFF, 16'hFFFF, 16'hFFFF, 16'hFFFF, 16'hFFFF};\n  end\n\n  // compute Hilbert transformed signal\n  always @(posedge clock) begin\n    delay_line[0] <= in;\n    real_part <= 0;\n    imag_part <= 0;\n    for (i = 0; i < N; i = i+2) begin\n      real_part <= real_part + delay_line[i]*coefficients[i] - delay_line[i+1]*coefficients[i+1];\n      imag_part <= imag_part + delay_line[i]*coefficients[i+1] + delay_line[i+1]*coefficients[i];\n    end\n    for (i = N-1; i > 0; i = i-1) begin\n      delay_line[i] <= delay_line[i-1];\n    end\n  end\n\n  assign out1 = real_part;\n  assign out2 = imag_part;\n\nendmodule\n",
        "module_name": "HilbertTransform",
        "module_hash": "1588cf9576c379a99b2741b109ffe4bc",
        "dataset_index": 18243
      },
      "top__41208082": {
        "rtl_code": "\nmodule top_module (\n    input [3:0] a,\n    input [3:0] b,\n    input mode,\n    input [15:0] data_in,\n    output [31:0] final_out\n);\n\n    wire [3:0] add_sub_out;\n    wire [31:0] func_out;\n    wire [7:0] comp_concat_out;\n\n    add_sub add_sub_inst (\n        .a(a),\n        .b(b),\n        .mode(mode),\n        .out(add_sub_out)\n    );\n\n    functional_module func_inst (\n        .in1(add_sub_out),\n        .in2(comp_concat_out),\n        .mode(mode),\n        .out(func_out)\n    );\n\n    complement_concat comp_concat_inst (\n        .data_in(data_in),\n        .out(comp_concat_out)\n    );\n\n    assign final_out = func_out;\n\nendmodule\nmodule add_sub (\n    input [3:0] a,\n    input [3:0] b,\n    input mode,\n    output [3:0] out\n);\n\n    assign out = mode ? a + b : a - b;\n\nendmodule\nmodule complement_concat (\n    input [15:0] data_in,\n    output [7:0] out\n);\n\n    assign out = {~data_in[15:8], data_in[7:0]};\n\nendmodule\nmodule functional_module (\n    input [3:0] in1,\n    input [7:0] in2,\n    input mode,\n    output [31:0] out\n);\n\n    assign out = mode ? {in1, in2, 1'b0} : {in1, in2};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "41208082fa8d26929f5bd39d21e7baa8",
        "dataset_index": 880
      },
      "shift_register #_de8aa077": {
        "rtl_code": "module shift_register #(\n    parameter WIDTH = 8\n) (\n    input clk,\n    input rst,\n    input data_in,\n    input shift_in,\n    output reg data_out\n);\n\n    reg [WIDTH-1:0] reg_data;\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            reg_data <= 0;\n        end else begin\n            reg_data <= {reg_data[WIDTH-2:0], shift_in};\n            if (data_in) begin\n                reg_data <= {reg_data[WIDTH-2:0], 1'b1};\n            end\n        end\n    end\n\n    always @ (*) begin\n        data_out <= reg_data[0];\n    end\n\nendmodule",
        "module_name": "shift_register #",
        "module_hash": "de8aa07735891b97eda38a5ecd0a6388",
        "dataset_index": 7636
      },
      "adder_4bit_39974b9a": {
        "rtl_code": "module adder_4bit(\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  assign {cout, sum} = cin + a + b;\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "39974b9a1621cdf566c425ed0a1b4975",
        "dataset_index": 1795
      },
      "xor_gate_00d95c59": {
        "rtl_code": "module xor_gate(\n    input a,\n    input b,\n    output reg out\n);\n\nalways @(a, b)\n    out = (a & ~b) | (~a & b);\n\nendmodule\n",
        "module_name": "xor_gate",
        "module_hash": "00d95c59032c89aa6e4279072c79d6f6",
        "dataset_index": 6077
      },
      "FSM_INPUT_ENABLE_c4f81ea3": {
        "rtl_code": "\nmodule FSM_INPUT_ENABLE\n   (out,\n    E,\n    D,\n    CLK,\n    FSM_sequential_state_reg_reg_1_0 ,\n    FSM_sequential_state_reg_reg_2_0 );\n  output [0:0]out;\n  output [0:0]E;\n  output [0:0]D;\n  input CLK;\n  input [0:0]FSM_sequential_state_reg_reg_1_0 ;\n  input [1:0]FSM_sequential_state_reg_reg_2_0 ;\n\n  reg [2-1:0]state_reg;\n\n  wire [0:0]D;\n  wire [0:0]E;\n  wire \\FSM_sequential_state_reg_0_i_1_n_0 ;\n  wire \\FSM_sequential_state_reg_1_i_1_n_0 ;\n  wire \\FSM_sequential_state_reg_2_i_1_n_0 ;\n\n  assign FSM_sequential_state_reg_0_i_1_n_0   = (state_reg[0] & state_reg[1] & out) | ((~ state_reg[0]) & (~ state_reg[1]) & out) | (state_reg[0] & (~ state_reg[1]) & (~ out) & FSM_sequential_state_reg_reg_2_0[1] & FSM_sequential_state_reg_reg_2_0[0]);\n  assign FSM_sequential_state_reg_1_i_1_n_0   = (state_reg[0] & state_reg[1] & out) | ((~ state_reg[0]) & (~ state_reg[1]) & out) | (state_reg[0] & (~ state_reg[1]) & (~ out));\n  assign FSM_sequential_state_reg_2_i_1_n_0   = (state_reg[0] & state_reg[1] & out) | ((~ state_reg[0]) & (~ state_reg[1]) & out) | ((~ state_reg[0]) & state_reg[1] & (~ out));\n  assign D = out;\n  assign E = state_reg[0] & (~ out) & state_reg[1];\n  assign out = state_reg[2-1];\n\n  always @(posedge CLK) begin\n    if (FSM_sequential_state_reg_reg_1_0 ) begin\n      state_reg[0] <= 1'b0;\n      state_reg[1] <= 1'b0;\n    end else begin\n      state_reg[0] <= FSM_sequential_state_reg_0_i_1_n_0 ;\n      state_reg[1] <= FSM_sequential_state_reg_1_i_1_n_0 ;\n    end\n  end\nendmodule",
        "module_name": "FSM_INPUT_ENABLE",
        "module_hash": "c4f81ea35c33a7d5e73bb4f9c316bc4e",
        "dataset_index": 18900
      },
      "counter_58192b5b": {
        "rtl_code": "module counter(\n  input clk,\n  input rst,\n  input ctrl,\n  input load,\n  input [15:0] load_val,\n  output reg [15:0] count\n);\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    count <= 0;\n  end else if (load) begin\n    count <= load_val;\n  end else begin\n    if (ctrl) begin\n      count <= count + 1;\n    end else begin\n      count <= count - 1;\n    end\n  end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "58192b5b32bd06cea0b3eb7f0a81e1f5",
        "dataset_index": 1210
      },
      "memory_c3b034af": {
        "rtl_code": "module memory(\n  input clk,\n  input wen,\n  input [31:0] addr,\n  input [31:0] din,\n  output reg [31:0] dout\n);\n\n  reg [31:0] mem [0:1023]; // 1024 memory locations, each 32 bits wide\n\n  always @(posedge clk) begin\n    if (wen) begin\n      mem[addr] <= din; // write data to memory location specified by addr\n    end else begin\n      dout <= mem[addr]; // read data from memory location specified by addr\n    end\n  end\n\nendmodule",
        "module_name": "memory",
        "module_hash": "c3b034afb981652a491969cea6c4717f",
        "dataset_index": 19775
      },
      "add_sub_661faa8c": {
        "rtl_code": "module add_sub (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] OUT\n);\n\n    assign OUT = SUB ? B - A : A + B;\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "661faa8c593307c64a4a631c463df616",
        "dataset_index": 21348
      },
      "counter_2bit_7b0fc520": {
        "rtl_code": "module counter_2bit(\n    input clk,\n    input rst,\n    output reg [1:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 2'b00;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter_2bit",
        "module_hash": "7b0fc520fbec4e388b1bbcc6fef98e0c",
        "dataset_index": 5848
      },
      "base_a7b14ce2": {
        "rtl_code": "\nmodule base (\n    output X,\n    input A1,\n    input A2,\n    input B1,\n    input B2\n);\n\n    assign X = (A1 ^ A2) & (B1 ^ B2);\n\nendmodule\nmodule wrapper_module (\n    output X,\n    input A1,\n    input A2,\n    input B1,\n    input B2\n);\n\n    // Instantiate the correct module\n    base instance_name (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .B2(B2)\n    );\n\nendmodule",
        "module_name": "base",
        "module_hash": "a7b14ce28d076fbc4af810eff1e7998f",
        "dataset_index": 13187
      },
      "fifo_controller_4894e857": {
        "rtl_code": "module fifo_controller (\n  input wire ge2_free,\n  input wire ge3_free,\n  input wire [1:0] input_tm_cnt,\n  output reg [3:0] fifo_wrptr_inc\n);\n\n  always @*\n  begin\n    if (ge3_free && (input_tm_cnt == 2'd3))\n      fifo_wrptr_inc = 4'd3;\n    else if (ge2_free && (input_tm_cnt >= 2'd2))\n      fifo_wrptr_inc = 4'd2;\n    else if (input_tm_cnt >= 2'd1)\n      fifo_wrptr_inc = 4'd1;\n    else\n      fifo_wrptr_inc = 4'd0;\n  end\n\nendmodule",
        "module_name": "fifo_controller",
        "module_hash": "4894e85718ef732a6e321f753c86782b",
        "dataset_index": 3418
      },
      "up_down_counter_4caf6dff": {
        "rtl_code": "module up_down_counter (\n  input clk,\n  input reset,\n  input enable,\n  input direction,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 0;\n  end else begin\n    if (enable) begin\n      if (direction) begin\n        if (count == 15) begin\n          count <= 0;\n        end else begin\n          count <= count + 1;\n        end\n      end else begin\n        if (count == 0) begin\n          count <= 15;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "up_down_counter",
        "module_hash": "4caf6dff6e79afd0761c22e7f4b39614",
        "dataset_index": 11205
      },
      "img_delay_ctl #_b6c2bf46": {
        "rtl_code": "\n\nmodule img_delay_ctl # (\n\tparameter integer C_STEP_NUMBER_WIDTH = 32,\n\tparameter integer C_FRMN_WIDTH = 2,\n\tparameter integer C_TEST = 0\n) (\n\tinput clk,\n\tinput eof,\n\n\tinput  wire [31:0]              delay0_cnt,\n\tinput  wire [C_FRMN_WIDTH-1:0]  delay0_frm,\n\toutput reg                      delay0_pulse,\n\n\tinput wire signed [C_STEP_NUMBER_WIDTH-1:0] cur_pos,\n\toutput reg signed [C_STEP_NUMBER_WIDTH-1:0] movie_pos\n);\n\n\treg [31:0] time_cnt;\n\talways @ (posedge clk) begin\n\t\tif (eof)\n\t\t\ttime_cnt <= 0;\n\t\telse\n\t\t\ttime_cnt <= time_cnt + 1;\n\tend\n\talways @ (posedge clk) begin\n\t\tif (eof)\n\t\t\tdelay0_pulse <= 0;\n\t\telse if (time_cnt == delay0_cnt)\n\t\t\tdelay0_pulse <= 1'b1;\n\t\telse\n\t\t\tdelay0_pulse <= 0;\n\tend\n\n\tlocalparam integer C_MAX_FRMN = 2**C_FRMN_WIDTH;\n\treg signed [C_STEP_NUMBER_WIDTH-1:0]\thistory_pos[C_MAX_FRMN-1:1];\n\twire signed [C_STEP_NUMBER_WIDTH-1:0]   hisAcur_pos[C_MAX_FRMN-1:0];\n\talways @ (posedge clk) begin\n\t\tif (delay0_pulse)\n\t\t\thistory_pos[1] <= cur_pos;\n\tend\n\tgenvar i;\n\tgenerate\n\t\tfor (i = 2; i < C_MAX_FRMN; i = i+1) begin\n\t\t\talways @ (posedge clk) begin\n\t\t\t\tif (delay0_pulse)\n\t\t\t\t\thistory_pos[i] <= history_pos[i-1];\n\t\t\tend\n\t\tend\n\n\t\tfor (i = 1; i < C_MAX_FRMN; i = i+1) begin\n\t\t\tassign hisAcur_pos[i] = history_pos[i];\n\t\tend\n\t\tassign hisAcur_pos[0] = cur_pos;\n\tendgenerate\n\n\talways @ (posedge clk) begin\n\t\tif (delay0_pulse)\n\t\t\tmovie_pos <= hisAcur_pos[delay0_frm];\n\tend\nendmodule\n",
        "module_name": "img_delay_ctl #",
        "module_hash": "b6c2bf46c61879173ab327b33cfc3fe5",
        "dataset_index": 22910
      },
      "magnitude_comparator_41d3ff40": {
        "rtl_code": "module magnitude_comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output [1:0] out\n);\n\n    assign out = (a > b) ? 2'b01 : (a < b) ? 2'b10 : 2'b00;\n\nendmodule",
        "module_name": "magnitude_comparator",
        "module_hash": "41d3ff40c61f422c91dd31b7bc72a556",
        "dataset_index": 18211
      },
      "FSM_Convert_Fixed_To_Float_9208c384": {
        "rtl_code": "\nmodule FSM_Convert_Fixed_To_Float(\n\t\tinput wire CLK,           input wire RST_FF,        input wire Bandcomp,      input wire Begin_FSM_FF,  input wire [7:0] Encd,    output reg EN_REG1,       output reg EN_REGmult,    output reg LOAD,          output reg MS_1,          output reg ACK_FF,        output reg EN_MS_1,\n        output reg EN_REG2,\n        output reg RST\n\n\t );\n\nparameter [3:0] \n    a = 4'b0000,\n\t\tb = 4'b0001,\n\t    c = 4'b0010,\n\t    d = 4'b0011,\n\t    e = 4'b0100,\n\t    f = 4'b0101,\n\t\tg = 4'b0110,\n\t\th = 4'b0111,\n\t\ti = 4'b1000,\n\t\tj = 4'b1001,\n\t\tk = 4'b1010;\n\t\t\t\t\t\n    reg [3:0] state_reg, state_next ; always @(posedge CLK, posedge RST_FF)\n\t   if (RST_FF)\n\t      begin\n\t\t  state_reg <= a;\t\n\t      end\n\t   else \n\t      begin\n\t\t  state_reg <= state_next;\n\t   end\n\nalways @*\n    begin\n\tstate_next = state_reg;\n\t\n\tEN_REG1 = 1'b0;\n\tEN_REGmult = 1'b0;\n\tEN_REG2 = 1'b0;\n    ACK_FF = 1'b0;\n    EN_MS_1 = 1'b0;\n    MS_1 = 1'b0;\n    LOAD = 1'b0;\n    RST = 1'b0;\n    \n\tcase(state_reg)\n\t    a: \n        begin\n                \n            if(Begin_FSM_FF) \n                begin\n                RST = 1'b1;\n                ACK_FF = 1'b0;    \n                state_next = b;\n                end\n            else  \n                state_next = a;\n           \n        end\n            \n\t\tb: \n\t\tbegin\n\t\t    EN_REG1 = 1'b1;    \n\t        state_next = c;\n\t\tend\n\t\t\n\t\tc:\n\t\tbegin\n\t\t    state_next = d;\n\t\tend\n\t\t\n\t\td: \n        begin\n            EN_REGmult = 1'b1;    \n            state_next = e;\n        end\n\t\t\n\t\te:\n\t\tbegin\n\t\t\tEN_MS_1 = 1'b1;\n\t\t\tif(Encd == 8'b00011010)\n                state_next = k;\n            else\n            state_next = f;\n\t\tend\n\t\t\n\t\tf:\n        begin\n            EN_MS_1 = 1'b1;\n            MS_1 = 1'b1;\n            state_next = g;\n        end\n        \n        g:\n        begin\n            state_next = h;\n        end     \n           \t\t\n\t\th:\n\t\tbegin\n\t\t    LOAD = 1'b1;\n\t\t    state_next = i;\n        end\n\t\n\t    i:\n        begin\n            EN_REG2 = 1'b1;\n            state_next = j;\n        end\n            \n\t\tj:\n\t\tbegin\t\t\t\n\t\t\tACK_FF = 1'b1;\n\t\t\tif(RST_FF)\n                 state_next = a;\n            else\n                state_next = j;\n\t\tend\n\t\t\n\t\tk:\n        begin\n            state_next = h;\n        end\n                \n\tendcase\n    end\n\nendmodule\n",
        "module_name": "FSM_Convert_Fixed_To_Float",
        "module_hash": "9208c384ea32114012e7c1c189115e8d",
        "dataset_index": 23951
      },
      "two_bit_adder_630e4e61": {
        "rtl_code": "module two_bit_adder (\n    input [1:0] A,\n    input [1:0] B,\n    input Cin,\n    output [1:0] Sum,\n    output Cout\n);\n\n    wire c1, c2, s1, s2;\n\n    // Full adder for bit 0\n    full_adder fa0 (\n        .a(A[0]),\n        .b(B[0]),\n        .cin(Cin),\n        .sum(s1),\n        .cout(c1)\n    );\n\n    // Full adder for bit 1\n    full_adder fa1 (\n        .a(A[1]),\n        .b(B[1]),\n        .cin(c1),\n        .sum(s2),\n        .cout(c2)\n    );\n\n    // Output signals\n    assign Sum[0] = s1;\n    assign Sum[1] = s2;\n    assign Cout = c2;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    wire c1, c2, s1;\n\n    // First half adder\n    half_adder ha1 (\n        .a(a),\n        .b(b),\n        .sum(s1),\n        .carry(c1)\n    );\n\n    // Second half adder\n    half_adder ha2 (\n        .a(s1),\n        .b(cin),\n        .sum(sum),\n        .carry(c2)\n    );\n\n    // Carry out\n    assign cout = c1 | c2;\n\nendmodule\n\nmodule half_adder (\n    input a,\n    input b,\n    output sum,\n    output carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule",
        "module_name": "two_bit_adder",
        "module_hash": "630e4e61bbeddf2518f9ef645765b6db",
        "dataset_index": 16480
      },
      "t_6a2b62a3": {
        "rtl_code": "module t ( reset, a, b, c, en, o1, o2, o3, o4, o5);\n   input  reset;\n   input  a;\n   input  b;\n   input  c;\n   input  en;\n   output reg o1; output reg o2; output reg o3; output reg o4; output reg o5; always @(reset or en or a or b)\nif (reset)\nbegin\n    o1 = 1'b0;\n    o2 = 1'b0;\n    o3 = 1'b0;\n    o4 = 1'b0;\n    o5 <= 1'b0; end\nelse\nbegin\n    o1 = 1'b1;\n    if (en)\n    begin\n        o2 = 1'b0;\n\n\t    if (a)\n\t    begin\n            o3 = a;\n            o5 <= 1'b1; end\n\t    else\n\t    begin\n            o3 = ~a;\n            o5 <=  a; end\n\n        if (c)\n\t    begin\n            o2 = a ^ b;\n            o4 = 1'b1;\n        end\n\t    else\n            o4 = ~a ^ b;\n\n        o2 = 1'b1;\n    end\n    else\n    begin\n        o2 = 1'b1;\n\t    if (b)\n        begin\n            o3 = ~a | b;\n            o5 <= ~b; end\n\t    else\n\t    begin\n            o3 = a & ~b;\n            end\n        o4 <= 1'b0; end\nend\n\nendmodule\n",
        "module_name": "t",
        "module_hash": "6a2b62a38c80453798c06ff10c4416df",
        "dataset_index": 25247
      },
      "counter_7c9218d0": {
        "rtl_code": "\nmodule counter (\n    input clk,\n    input reset,\n    output reg [3:0] counter_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter_out <= 4'b0000;\n        end else begin\n            counter_out <= counter_out + 4'b0001;\n        end\n    end\n\nendmodule\nmodule register (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    output reg [7:0] register_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            register_out <= 8'b00000000;\n        end else begin\n            register_out <= data_in;\n        end\n    end\n\nendmodule\nmodule functional_module (\n    input [3:0] counter_out,\n    input [7:0] register_out,\n    output [7:0] final_output\n);\n\n    assign final_output = counter_out < register_out ? counter_out : register_out;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    output [7:0] final_output\n);\n\n    wire [3:0] counter_out;\n    wire [7:0] register_out;\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .counter_out(counter_out)\n    );\n\n    register register_inst (\n        .clk(clk),\n        .reset(reset),\n        .data_in(final_output),\n        .register_out(register_out)\n    );\n\n    functional_module functional_inst (\n        .counter_out(counter_out),\n        .register_out(register_out),\n        .final_output(final_output)\n    );\n\nendmodule",
        "module_name": "counter",
        "module_hash": "7c9218d02e902acc494e510b595ba634",
        "dataset_index": 498
      },
      "synchronous_ram_1aaf98d1": {
        "rtl_code": "module synchronous_ram (\n    input clk,\n    input [23:0] data_in,\n    input [9:0] write_addr,\n    input [9:0] read_addr,\n    input write_en,\n    output reg [23:0] data_out\n);\n\nreg [23:0] mem [0:1023];\n\nalways @(posedge clk) begin\n    if (write_en) begin\n        mem[write_addr] <= data_in;\n    end\n    data_out <= mem[read_addr];\nend\n\nendmodule",
        "module_name": "synchronous_ram",
        "module_hash": "1aaf98d1b5eed2a191f5d93477aa9eca",
        "dataset_index": 4247
      },
      "gray_shift_register_f34fc676": {
        "rtl_code": "module gray_shift_register (\n    input CLK,\n    input RST,\n    input [7:0] data_in,\n    input shift,\n    input load,\n    input select,\n    output reg [7:0] shift_reg_out,\n    output reg [7:0] counter_out,\n    output reg [7:0] final_output\n);\n\nreg [7:0] gray_counter_out;\nreg [7:0] shift_reg;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        gray_counter_out <= 8'b00000000;\n        shift_reg <= 8'b00000000;\n    end else begin\n        gray_counter_out <= gray_counter_out + 1;\n        if (load) begin\n            shift_reg <= data_in;\n        end else if (shift) begin\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        end\n    end\nend\n\nalways @* begin\n    counter_out = gray_counter_out ^ (gray_counter_out >> 1);\n    shift_reg_out = shift_reg ^ (shift_reg >> 1);\n    if (select) begin\n        final_output = shift_reg_out;\n    end else begin\n        final_output = counter_out;\n    end\nend\n\nendmodule",
        "module_name": "gray_shift_register",
        "module_hash": "f34fc676521c8f2ec6bda0af99f3980f",
        "dataset_index": 6863
      },
      "or3_b61e6320": {
        "rtl_code": "module or3 (\n    input  A   ,\n    input  B   ,\n    input  C   ,\n    output X   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n    assign X = A | B | C;\nendmodule",
        "module_name": "or3",
        "module_hash": "b61e6320af00f9e50c259448f00992ee",
        "dataset_index": 13999
      },
      "ddr_clkout_a0829920": {
        "rtl_code": "\nmodule ddr_clkout (pad, clk);\ninput clk;\noutput pad;\n\nreg sync_clk;\nwire clk_out;\nreg [7:0] count;\ninteger temp,flag1,flag2;\n\n// First stage of synchronizer\nreg sync_d1;\nalways @(posedge clk)\n    sync_d1 <= clk;\n\n// Second stage of synchronizer\nreg sync_d2;\nalways @(posedge sync_clk)\n    sync_d2 <= sync_d1;\n\n// Counter to generate clock signal\nalways @(posedge sync_clk) begin\n    if (count == 8'hFF)\n        count <= 0;\n    else\n        count <= count + 1;\nend\n\n// Output clock signal\nassign clk_out = count[6];\n\n// D flip-flop to generate 50% duty cycle\nreg d, d_temp;\nalways @(posedge clk_out)\n    d <= ~d;\n\n// Output to pad\nassign pad = d;\n\n// Synchronize input clock signal\nalways @(posedge clk)\n    sync_clk <= ~sync_clk;\n\nendmodule",
        "module_name": "ddr_clkout",
        "module_hash": "a0829920d5581952cf39c8f83dd140ab",
        "dataset_index": 14847
      },
      "sync_ram_b3c85387": {
        "rtl_code": "module sync_ram (\n    input clk,\n    input datain,\n    input write_reset,\n    input [2:0] waddr,\n    input [2:0] raddr,\n    input we,\n    output reg dataout\n);\n\n    reg [0:5] ram_d;\n    reg [0:5] ram_q;\n\n    wire [0:5] data_reg;\n\n    integer i;\n\n    initial begin\n        dataout = 0;\n        for (i = 0; i <= 5; i = i + 1)\n            ram_q[i] <= 1'b0;\n    end\n\n    // Write port\n    always @(posedge clk or posedge write_reset) begin\n        if (write_reset == 1'b1) begin\n            for (i = 0; i <= 5; i = i + 1)\n                ram_q[i] <= 1'b0;\n        end\n        else begin\n            for (i = 0; i <= 5; i = i + 1)\n                ram_q[i] <= ram_d[i];\n        end\n    end\n\n    always @(we or data_reg or ram_q) begin\n        if (we === 1'b1) begin\n            ram_d <= data_reg;\n        end\n        else begin\n            ram_d <= ram_q;\n        end\n    end\n\n    // Read port\n    assign data_reg[0] = (waddr == 3'b000) ? datain : ram_q[0];\n    assign data_reg[1] = (waddr == 3'b001) ? datain : ram_q[1];\n    assign data_reg[2] = (waddr == 3'b010) ? datain : ram_q[2];\n    assign data_reg[3] = (waddr == 3'b011) ? datain : ram_q[3];\n    assign data_reg[4] = (waddr == 3'b100) ? datain : ram_q[4];\n    assign data_reg[5] = (waddr == 3'b101) ? datain : ram_q[5];\n\n    always @(ram_q or we or waddr or raddr) begin\n        case (raddr)\n            3'b000: dataout <= ram_q[0];\n            3'b001: dataout <= ram_q[1];\n            3'b010: dataout <= ram_q[2];\n            3'b011: dataout <= ram_q[3];\n            3'b100: dataout <= ram_q[4];\n            3'b101: dataout <= ram_q[5];\n            default: dataout <= 0;\n        endcase\n    end\n\nendmodule",
        "module_name": "sync_ram",
        "module_hash": "b3c853876c22738628faa6b3303d917a",
        "dataset_index": 15672
      },
      "mode_write_d7f4cccb": {
        "rtl_code": "module mode_write(\n    input clk,\n    input rstn,\n    input [5:0] cnt,\n    input [6:0] blockcnt,\n    input [5:0] bestmode,\n    input [5:0] bestmode16,\n    input [5:0] bestmode32,\n    input finish,\n    output reg md_we,\n    output reg [5:0] md_wdata,\n    output reg [6:0] md_waddr\n);\n\n    always @(posedge clk or negedge rstn) begin\n        if (!rstn) begin\n            md_waddr <= 7'd0;\n        end\n        else if (md_we) begin\n            md_waddr <= md_waddr + 1'b1;\n        end\n        else if (finish) begin\n            md_waddr <= 7'd0;\n        end\n    end\n\n    always @(posedge clk or negedge rstn) begin\n        if (!rstn) begin\n            md_we <= 1'b0;\n        end\n        else if (((blockcnt > 7'd1) && (cnt == 6'd11))\n                 || ((blockcnt[1:0] == 2'b01) && (cnt == 6'd12) && (blockcnt != 7'd1))\n                 || ((blockcnt[3:0] == 4'b0001) && (cnt == 6'd13) && (blockcnt != 7'd1))) begin\n            md_we <= 1'b1;\n        end\n        else begin\n            md_we <= 1'b0;\n        end\n    end\n\n    always @(posedge clk or negedge rstn) begin\n        if (!rstn) begin\n            md_wdata <= 'd0;\n        end\n        else if (cnt == 'd11) begin\n            md_wdata <= bestmode;\n        end\n        else if (cnt == 'd12) begin\n            md_wdata <= bestmode16;\n        end\n        else if (cnt == 'd13) begin\n            md_wdata <= bestmode32;\n        end\n    end\n\nendmodule",
        "module_name": "mode_write",
        "module_hash": "d7f4cccbea80c42ea849a741df37a9cc",
        "dataset_index": 6060
      },
      "ram_rw_b4ad2ce8": {
        "rtl_code": "module ram_rw (\n  input clk,\n  input [3:0] waddr,\n  input [7:0] wdata,\n  input wen,\n  input [3:0] raddr,\n  output reg [7:0] rdata\n);\n\n  reg [7:0] mem [0:15];\n  integer i;\n\n  always @(posedge clk) begin\n    if (wen) begin\n      mem[waddr] <= wdata;\n    end\n    rdata <= mem[raddr];\n  end\n\nendmodule",
        "module_name": "ram_rw",
        "module_hash": "b4ad2ce808b235e5187169b30961af28",
        "dataset_index": 136
      },
      "circuit__f9150db4": {
        "rtl_code": "module circuit_module (\n    out,\n    a,\n    b,\n    c,\n    d,\n    e\n);\n\n    output out;\n    input a;\n    input [1:0] b;\n    input [2:0] c;\n    input [3:0] d;\n    input [4:0] e;\n\n    wire [4:0] complement;\n    wire [4:0] xor_inputs;\n    wire all_complement;\n\n    assign complement = {~a, ~b, ~c, ~d, ~e};\n    assign xor_inputs = {a, b[0], b[1], c[0], c[1], c[2], d[0], d[1], d[2], d[3], e[0], e[1], e[2], e[3], e[4]};\n    assign all_complement = &complement;\n\n    assign out = all_complement ? 0 : (|complement) ? 1 : ^xor_inputs;\n\nendmodule",
        "module_name": "circuit_",
        "module_hash": "f9150db4ef45228a6846a60fd897d5a8",
        "dataset_index": 4481
      },
      "reverse_bits_0b6e875d": {
        "rtl_code": "module reverse_bits (\n  input [7:0] input_vector,\n  output reg [7:0] output_vector\n);\n\n  reg [7:0] temp_vector;\n  integer i;\n\n  always @(*) begin\n    if (input_vector == 8'b00000000) begin\n      output_vector = 8'b00000000;\n    end else begin\n      for (i = 0; i < 8; i = i + 1) begin\n        temp_vector[i] = input_vector[7 - i];\n      end\n      output_vector = temp_vector;\n    end\n  end\n\nendmodule\n",
        "module_name": "reverse_bits",
        "module_hash": "0b6e875d6505335b951379a7616cffff",
        "dataset_index": 12142
      },
      "rcn_master_slave_e710ebaf": {
        "rtl_code": "\n\n\n\n\nmodule rcn_master_slave\n(\n    input rst,\n    input clk,\n\n    input [68:0] rcn_in,\n    output [68:0] rcn_out,\n\n    input cs,\n    input [1:0] seq,\n    output busy,\n    input wr,\n    input [3:0] mask,\n    input [23:0] addr,\n    input [31:0] wdata,\n\n    output rdone,\n    output wdone,\n    output [1:0] rsp_seq,\n    output [3:0] rsp_mask,\n    output [23:0] rsp_addr,\n    output [31:0] rsp_data,\n\n    output slave_cs,\n    output slave_wr,\n    output [3:0] slave_mask,\n    output [23:0] slave_addr,\n    output [31:0] slave_wdata,\n    input [31:0] slave_rdata\n);\n    parameter MASTER_ID = 0;\n    parameter ADDR_MASK = 0;\n    parameter ADDR_BASE = 1;\n\n    reg [68:0] rin;\n    reg [68:0] rin_d1;\n    reg [68:0] rout;\n\n    assign rcn_out = rout;\n\n    wire [5:0] my_id = MASTER_ID;\n    wire [23:0] my_mask = ADDR_MASK;\n    wire [23:0] my_base = ADDR_BASE;\n\n    wire my_resp = rin_d1[68] && !rin_d1[67] && (rin_d1[65:60] == my_id);\n\n    wire my_req = rin[68] && rin[67] && ((rin[55:34] & my_mask[23:2]) == my_base[23:2]);\n    reg my_req_d1;\n\n    wire [68:0] resp;\n\n    wire req_valid;\n    wire [68:0] req;\n\n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rin_d1 <= 69'd0;\n            my_req_d1 <= 1'b0;\n            rout <= 69'd0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rin_d1 <= rin;\n            my_req_d1 <= my_req;\n            rout <= (my_req_d1) ? resp : (req_valid) ? req : (my_resp) ? 69'd0 : rin_d1;\n        end\n\n    assign busy = rin_d1[68] && !my_resp;\n    assign req_valid = cs && !(rin_d1[68] && !my_resp);\n    assign req = {1'b1, 1'b1, wr, my_id, mask, addr[23:2], seq, wdata};\n\n    assign rdone = my_resp && !rin_d1[66];\n    assign wdone = my_resp && rin_d1[66];\n    assign rsp_seq = rin_d1[33:32];\n    assign rsp_mask = rin_d1[59:56];\n    assign rsp_addr = {rin_d1[55:34], 2'd0};\n    assign rsp_data = rin_d1[31:0];\n\n    assign slave_cs = my_req;\n    assign slave_wr = rin[66];\n    assign slave_mask = rin[59:56];\n    assign slave_addr = {rin[55:34], 2'd0};\n    assign slave_wdata = rin[31:0];\n\n    assign resp = {1'b1, 1'b0, rin_d1[66:32], slave_rdata};\n\nendmodule\n",
        "module_name": "rcn_master_slave",
        "module_hash": "e710ebafa3e5192989266bb8814f5a25",
        "dataset_index": 22967
      },
      "my__e5190014": {
        "rtl_code": "module my_module (\n    input A1,\n    input A2,\n    input B1,\n    input C1,\n    output reg X\n);\n\n    always @(*) begin\n        if ((A1 & A2) || (B1 & C1))\n            X = 1;\n        else\n            X = 0;\n    end\n\nendmodule",
        "module_name": "my_",
        "module_hash": "e5190014abb844719e7c030994a5ea87",
        "dataset_index": 12092
      },
      "uart_rx_b6551690": {
        "rtl_code": "\nmodule uart_rx (\n  input clk,\n  input rst,\n  input rx,\n  output reg [7:0] data_out\n);\n\n  reg [3:0] count;\n  reg [7:0] shift_reg;\n  reg start_bit;\n  reg stop_bit;\n  reg parity_bit;\n  reg [1:0] parity;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n      shift_reg <= 0;\n      start_bit <= 0;\n      stop_bit <= 1;\n      parity_bit <= 0;\n      parity <= 2'b00;\n      data_out <= 0;\n    end else begin\n      if (count == 0) begin\n        start_bit <= rx;\n        count <= 11;\n      end else if (count == 1) begin\n        shift_reg <= {shift_reg[6:0], rx};\n        parity_bit <= rx;\n      end else if (count == 10) begin\n        stop_bit <= rx;\n      end else if (count == 11) begin\n        data_out <= shift_reg;\n      end\n      count <= count - 1;\n    end\n  end\n\n  always @* begin\n    if (parity == 2'b00) begin\n      parity_bit = 1;\n    end else if (parity == 2'b01) begin\n      parity_bit = ~shift_reg[0];\n    end else if (parity == 2'b10) begin\n      parity_bit = ~|shift_reg;\n    end else if (parity == 2'b11) begin\n      parity_bit = ~(shift_reg[0]^|shift_reg[7:1]);\n    end\n  end\n\n  always @* begin\n    if (parity == 2'b00) begin\n      parity = 2'b01;\n    end else if (parity == 2'b01) begin\n      parity = 2'b10;\n    end else if (parity == 2'b10) begin\n      parity = 2'b11;\n    end else if (parity == 2'b11) begin\n      parity = 2'b00;\n    end\n  end\n\nendmodule\n",
        "module_name": "uart_rx",
        "module_hash": "b655169023b2b25df1ad2fe82e25512c",
        "dataset_index": 20137
      },
      "fifo_buffer_f74269a1": {
        "rtl_code": "module fifo_buffer(\n    input clk,\n    input rst,\n    input wr_en,\n    input rd_en,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n\nparameter DEPTH = 16;\n\nreg [31:0] buffer [0:DEPTH-1];\nreg [5:0] head = 0;\nreg [5:0] tail = 0;\nreg [5:0] count = 0;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        head <= 0;\n        tail <= 0;\n        count <= 0;\n    end else begin\n        if (wr_en && !rd_en && count < DEPTH) begin\n            buffer[head] <= data_in;\n            head <= head + 1;\n            count <= count + 1;\n        end\n        if (!wr_en && rd_en && count > 0) begin\n            data_out <= buffer[tail];\n            tail <= tail + 1;\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "f74269a16574156469ece87e76b61859",
        "dataset_index": 2113
      },
      "ECC_e43f932d": {
        "rtl_code": "\nmodule ECC (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 8; // number of input bits\nparameter m = 12; // number of output bits (n+p)\nparameter p = 4; // number of parity bits\n\nreg [n+p-1:0] codeword;\nwire [p-1:0] parity;\n\n// Generate parity bits\ngenvar i;\ngenerate\n  for (i = 0; i < p; i = i + 1) begin\n    assign parity[i] = ^({1'b0, codeword[n+p-1:n]} >> (2**i-1));\n  end\nendgenerate\n\n// Append parity bits to input bits\nalways @* begin\n  codeword = {in, parity};\nend\n\n// Output codeword\nassign out = codeword;\n\nendmodule",
        "module_name": "ECC",
        "module_hash": "e43f932d641baa32e43aa61eac371ebb",
        "dataset_index": 5200
      },
      "sky130_fd_sc_hd__nor4bb_1b1a0880": {
        "rtl_code": "module sky130_fd_sc_hd__nor4bb (\n    Y  ,\n    A  ,\n    B  ,\n    C_N,\n    D_N\n);\n\n    // Module ports\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n    input  D_N;\n\n    // Local signals\n    wire not0_out  ;\n    wire not1_out  ;\n    wire and0_out  ;\n    wire and1_out  ;\n    wire and2_out  ;\n    wire or0_out   ;\n    wire nor0_out  ;\n    wire nor1_out  ;\n    wire xor0_out  ;\n    wire xor1_out  ;\n    wire xor2_out  ;\n    wire xor3_out  ;\n    wire xor4_out  ;\n    wire xor5_out  ;\n    wire xor6_out  ;\n    wire xor7_out  ;\n    wire xor8_out  ;\n    wire xor9_out  ;\n    wire xor10_out ;\n    wire xor11_out ;\n    wire xor12_out ;\n    wire xor13_out ;\n    wire xor14_out ;\n    wire xor15_out ;\n\n    //  Name  Output      Other arguments\n    not not0 (not0_out, A);\n    not not1 (not1_out, B);\n    and and0 (and0_out, not0_out, not1_out, C_N, D_N);\n    and and1 (and1_out, A, not1_out, C_N, D_N);\n    and and2 (and2_out, not0_out, B, C_N, D_N);\n    or or0 (or0_out, and0_out, and1_out, and2_out);\n    nor nor0 (nor0_out, or0_out, or0_out);\n    xor xor0 (xor0_out, A, B);\n    xor xor1 (xor1_out, xor0_out, C_N);\n    xor xor2 (xor2_out, xor0_out, D_N);\n    xor xor3 (xor3_out, xor1_out, xor2_out);\n    xor xor4 (xor4_out, A, C_N);\n    xor xor5 (xor5_out, xor4_out, D_N);\n    xor xor6 (xor6_out, B, C_N);\n    xor xor7 (xor7_out, xor6_out, D_N);\n    xor xor8 (xor8_out, A, D_N);\n    xor xor9 (xor9_out, xor8_out, C_N);\n    xor xor10 (xor10_out, B, D_N);\n    xor xor11 (xor11_out, xor10_out, C_N);\n    xor xor12 (xor12_out, xor4_out, xor6_out);\n    xor xor13 (xor13_out, xor8_out, xor10_out);\n    xor xor14 (xor14_out, xor1_out, xor6_out);\n    xor xor15 (xor15_out, xor2_out, xor4_out);\n    nor nor1 (nor1_out, xor3_out, xor5_out, xor7_out, xor9_out, xor11_out, xor12_out, xor13_out, xor14_out, xor15_out);\n    buf buf0 (Y, nor1_out);\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__nor4bb",
        "module_hash": "1b1a08806bf2e1d13317aa83b6accd9f",
        "dataset_index": 8577
      },
      "binary_counter_4b53932a": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'd0;\n        end\n        else begin\n            if (count == 4'd15) begin\n                count <= 4'd0;\n            end\n            else begin\n                count <= count + 4'd1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "4b53932acab747cabc4677d997fa2ff4",
        "dataset_index": 6358
      },
      "bcd_counter_d4ba7dad": {
        "rtl_code": "\nmodule bcd_counter (\n    input clk,\n    input reset,\n    input [3:1] ena,\n    output reg [15:0] q_bcd\n);\n    always @(posedge reset or posedge clk) begin\n        if (reset) begin\n            q_bcd <= 16'b0000_0000_0000_0000;\n        end else begin\n            if (ena[3]) begin\n                if (q_bcd[3:0] == 4'b1001) begin\n                    q_bcd[3:0] <= 4'b0000;\n                    if (q_bcd[7:4] == 4'b1001) begin\n                        q_bcd[7:4] <= 4'b0000;\n                        if (q_bcd[11:8] == 4'b1001) begin\n                            q_bcd[11:8] <= 4'b0000;\n                            if (q_bcd[15:12] == 4'b1001) begin\n                                q_bcd[15:12] <= 4'b0000;\n                            end else begin\n                                q_bcd[15:12] <= q_bcd[15:12] + 4'b0001;\n                            end\n                        end else begin\n                            q_bcd[11:8] <= q_bcd[11:8] + 4'b0001;\n                        end\n                    end else begin\n                        q_bcd[7:4] <= q_bcd[7:4] + 4'b0001;\n                    end\n                end else begin\n                    q_bcd[3:0] <= q_bcd[3:0] + 4'b0001;\n                end\n            end\n        end\n    end\nendmodule\nmodule parallel_load_shift (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input [2:0] shift_amount,\n    output reg [7:0] data_out\n);\n    always @(posedge reset or posedge clk) begin\n        if (reset) begin\n            data_out <= 8'b0000_0000;\n        end else begin\n            if (shift_amount == 3'b000) begin\n                data_out <= data_in;\n            end else if (shift_amount == 3'b001) begin\n                data_out <= {data_in[6:0], data_in[7]};\n            end else if (shift_amount == 3'b010) begin\n                data_out <= {data_in[5:0], data_in[7:6]};\n            end else if (shift_amount == 3'b011) begin\n                data_out <= {data_in[4:0], data_in[7:5]};\n            end else if (shift_amount == 3'b100) begin\n                data_out <= {data_in[3:0], data_in[7:4]};\n            end else if (shift_amount == 3'b101) begin\n                data_out <= {data_in[2:0], data_in[7:3]};\n            end else if (shift_amount == 3'b110) begin\n                data_out <= {data_in[1:0], data_in[7:2]};\n            end else if (shift_amount == 3'b111) begin\n                data_out <= {data_in[0], data_in[7:1]};\n            end\n        end\n    end\nendmodule\nmodule sum_module (\n    input [15:0] bcd_in,\n    input [7:0] shift_in,\n    output reg [7:0] sum_out\n);\n    always @(*) begin\n        sum_out = bcd_in[15:8] + shift_in;\n    end\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output [15:0] q_bcd,\n    input [7:0] data_in,\n    input [2:0] shift_amount,\n    output [7:0] data_out,\n    output [7:0] sum\n);\n    assign ena = 4'b111;\n\n    bcd_counter bcd_counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .ena(ena),\n        .q_bcd(q_bcd)\n    );\n    \n    parallel_load_shift parallel_load_shift_inst (\n        .clk(clk),\n        .reset(reset),\n        .data_in(data_in),\n        .shift_amount(shift_amount),\n        .data_out(data_out)\n    );\n    \n    sum_module sum_module_inst (\n        .bcd_in(q_bcd),\n        .shift_in(data_out),\n        .sum_out(sum)\n    );\nendmodule",
        "module_name": "bcd_counter",
        "module_hash": "d4ba7dad181c05732c0ff58759025ba0",
        "dataset_index": 18460
      },
      "up_counter_9fe67c6a": {
        "rtl_code": "module up_counter(clk, rst, count, overflow);\n    input clk, rst;\n    output [3:0] count;\n    output overflow;\n    reg [3:0] count;\n\n    always @(posedge clk, posedge rst)\n    begin\n        if (rst)\n            count <= 4'b0;\n        else if (count == 4'hf)\n            count <= 4'b0;\n        else\n            count <= count + 1;\n    end\n\n    assign overflow = (count == 4'hf);\nendmodule",
        "module_name": "up_counter",
        "module_hash": "9fe67c6aa6513ffa3e0ce5f6fb53a58a",
        "dataset_index": 20258
      },
      "clk_generator_41b208c2": {
        "rtl_code": "\nmodule clk_generator(\n    input clk,\n    input en,\n    input [31:0] limit,\n    input [31:0] count,\n    output reg clk_0\n    );\n\n\t reg [31:0] ndCount;\n\t \n\t initial clk_0 = 1'b0;\n\t initial ndCount = 32'h00000000;\n\t \n\t always@(negedge clk) begin\n\t\tif(en) begin\n\t\t\tif(count > ndCount) begin ndCount <= count + limit; clk_0 <= ~clk_0;          end\n\t\t\telse begin\n\t\t\t\tndCount <= ndCount; clk_0 <= clk_0;\t\tend\n\t\tend\n\t\telse begin\n\t\t\tndCount <= count+limit;\n\t\t\tclk_0 <= 1'b0;\n\t\tend\n\t end\n\nendmodule\n",
        "module_name": "clk_generator",
        "module_hash": "41b208c2f8865f7877cbaf7cf4a5fdd1",
        "dataset_index": 24695
      }
    },
    "batch_6913ad8ecee48190bc8ce7ebcefce6d4": {
      "decoder_4to16_5c9a71da": {
        "rtl_code": "\nmodule decoder_4to16 (\n    input [3:0] in, // Input to the decoder\n    output [15:0] out // Output from the decoder\n);\n\n// Internal wires\nwire [15:0] temp;\n\n// Decoder logic\nassign temp[0] = ~in[3] & ~in[2] & ~in[1] & ~in[0];\nassign temp[1] = ~in[3] & ~in[2] & ~in[1] & in[0];\nassign temp[2] = ~in[3] & ~in[2] & in[1] & ~in[0];\nassign temp[3] = ~in[3] & ~in[2] & in[1] & in[0];\nassign temp[4] = ~in[3] & in[2] & ~in[1] & ~in[0];\nassign temp[5] = ~in[3] & in[2] & ~in[1] & in[0];\nassign temp[6] = ~in[3] & in[2] & in[1] & ~in[0];\nassign temp[7] = ~in[3] & in[2] & in[1] & in[0];\nassign temp[8] = in[3] & ~in[2] & ~in[1] & ~in[0];\nassign temp[9] = in[3] & ~in[2] & ~in[1] & in[0];\nassign temp[10] = in[3] & ~in[2] & in[1] & ~in[0];\nassign temp[11] = in[3] & ~in[2] & in[1] & in[0];\nassign temp[12] = in[3] & in[2] & ~in[1] & ~in[0];\nassign temp[13] = in[3] & in[2] & ~in[1] & in[0];\nassign temp[14] = in[3] & in[2] & in[1] & ~in[0];\nassign temp[15] = in[3] & in[2] & in[1] & in[0];\n\n// Output logic\nassign out = temp;\n\nendmodule\n",
        "module_name": "decoder_4to16",
        "module_hash": "5c9a71dafb2bdd61deef515ec7664ef7",
        "dataset_index": 5092
      },
      "binary_counter_3ab863f2": {
        "rtl_code": "module binary_counter (\n  input clock,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clock) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "3ab863f234f9e346f6f36cffb4b9e2d2",
        "dataset_index": 18505
      },
      "mydff_b6ed5736": {
        "rtl_code": "\nmodule mydff (\n    input D ,\n    input CLK ,\n    input R ,\n    output Q\n);\nwire Qbar ;\nreg Q ; // Use blocking assignments\nalways @(posedge CLK or negedge R) begin\n    if (!R) \n        Q <= 1'b0 ;\n    else \n        Q <= D ;\nend\nassign Qbar = ~Q ; // Assign Qbar to the complement of Q\nendmodule\n",
        "module_name": "mydff",
        "module_hash": "b6ed573657bca48c41efa8bf662a0b4c",
        "dataset_index": 15348
      },
      "splitter_9491c415": {
        "rtl_code": "module splitter (\n    input wire [2:0] in,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n    assign {o2, o1, o0} = in;\nendmodule\n\nmodule barrel_shifter (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n    assign {out_hi, out_lo} = in >> 8;\nendmodule\n\nmodule top_module (\n    input wire [18:0] in,\n    input wire select,\n    output wire [18:0] out,\n    output wire o2,\n    output wire o1,\n    output wire o0,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n    wire [2:0] splitter_out;\n    wire [7:0] barrel_out_hi;\n    wire [7:0] barrel_out_lo;\n\n    splitter splitter_inst (\n        .in(in[2:0]),\n        .o2(o2),\n        .o1(o1),\n        .o0(o0)\n    );\n\n    barrel_shifter barrel_inst (\n        .in(in[18:3]),\n        .out_hi(barrel_out_hi),\n        .out_lo(barrel_out_lo)\n    );\n\n    assign out = select ? {barrel_out_hi, {splitter_out, barrel_out_lo}} : {barrel_out_hi, barrel_out_lo};\n    assign splitter_out = {o2, o1, o0};\n    assign out_hi = barrel_out_hi;\n    assign out_lo = select ? {splitter_out, barrel_out_lo} : barrel_out_lo;\nendmodule",
        "module_name": "splitter",
        "module_hash": "9491c415816578a5910d80ac0f4a0598",
        "dataset_index": 1460
      },
      "div_clk_96dd4381": {
        "rtl_code": "\nmodule div_clk (\n    input clk_in,\n    input clk_type,\n    input reset,\n    output reg clk_out\n);\n\nreg clock_div2;\nreg [2:0] rst_reg;\n\nalways @(posedge clk_in or posedge reset) begin\n    if (reset == 1'b1) begin\n        rst_reg[0] <= 1'b1;\n        rst_reg[1] <= 1'b1;\n        rst_reg[2] <= 1'b1;\n    end else begin\n        rst_reg[0] <= reset;\n        rst_reg[1] <= rst_reg[0] & reset;\n        rst_reg[2] <= rst_reg[1] & rst_reg[0] & reset;\n    end\nend\n\nalways @(posedge clk_in) \n    clock_div2 <= ~clock_div2;\n\nalways @(posedge clk_in or posedge rst_reg[2]) begin\n    if (rst_reg[2] == 1'b1)\n        clk_out <= 1'b0;\n    else if (clk_type == 1'b1)\n        clk_out <= clock_div2;\n    else\n        clk_out <= clk_in;\nend\n\nendmodule",
        "module_name": "div_clk",
        "module_hash": "96dd4381a21973f3a976122388eb9385",
        "dataset_index": 8311
      },
      "ripple_adder_32_abccc57d": {
        "rtl_code": "module ripple_adder_32(a, b, cin, sum, cout);\n  input [31:0] a;\n  input [31:0] b;\n  input cin;\n  output [31:0] sum;\n  output cout;\n  \n  wire [31:0] c;\n  wire [31:0] s;\n  \n  full_adder fa0(a[0], b[0], cin, s[0], c[0]);\n  full_adder fa1(a[1], b[1], c[0], s[1], c[1]);\n  full_adder fa2(a[2], b[2], c[1], s[2], c[2]);\n  full_adder fa3(a[3], b[3], c[2], s[3], c[3]);\n  full_adder fa4(a[4], b[4], c[3], s[4], c[4]);\n  full_adder fa5(a[5], b[5], c[4], s[5], c[5]);\n  full_adder fa6(a[6], b[6], c[5], s[6], c[6]);\n  full_adder fa7(a[7], b[7], c[6], s[7], c[7]);\n  full_adder fa8(a[8], b[8], c[7], s[8], c[8]);\n  full_adder fa9(a[9], b[9], c[8], s[9], c[9]);\n  full_adder fa10(a[10], b[10], c[9], s[10], c[10]);\n  full_adder fa11(a[11], b[11], c[10], s[11], c[11]);\n  full_adder fa12(a[12], b[12], c[11], s[12], c[12]);\n  full_adder fa13(a[13], b[13], c[12], s[13], c[13]);\n  full_adder fa14(a[14], b[14], c[13], s[14], c[14]);\n  full_adder fa15(a[15], b[15], c[14], s[15], c[15]);\n  full_adder fa16(a[16], b[16], c[15], s[16], c[16]);\n  full_adder fa17(a[17], b[17], c[16], s[17], c[17]);\n  full_adder fa18(a[18], b[18], c[17], s[18], c[18]);\n  full_adder fa19(a[19], b[19], c[18], s[19], c[19]);\n  full_adder fa20(a[20], b[20], c[19], s[20], c[20]);\n  full_adder fa21(a[21], b[21], c[20], s[21], c[21]);\n  full_adder fa22(a[22], b[22], c[21], s[22], c[22]);\n  full_adder fa23(a[23], b[23], c[22], s[23], c[23]);\n  full_adder fa24(a[24], b[24], c[23], s[24], c[24]);\n  full_adder fa25(a[25], b[25], c[24], s[25], c[25]);\n  full_adder fa26(a[26], b[26], c[25], s[26], c[26]);\n  full_adder fa27(a[27], b[27], c[26], s[27], c[27]);\n  full_adder fa28(a[28], b[28], c[27], s[28], c[28]);\n  full_adder fa29(a[29], b[29], c[28], s[29], c[29]);\n  full_adder fa30(a[30], b[30], c[29], s[30], c[30]);\n  full_adder fa31(a[31], b[31], c[30], s[31], cout);\n  \n  assign sum = s;\n  \nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n  input a;\n  input b;\n  input cin;\n  output sum;\n  output cout;\n  \n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (a & cin) | (b & cin);\n  \nendmodule",
        "module_name": "ripple_adder_32",
        "module_hash": "abccc57de1dcd5fbad45da7be94e2bf7",
        "dataset_index": 20855
      },
      "DAC_607e4b6d": {
        "rtl_code": "\nmodule DAC (\n  input clk,\n  input rst,\n  input [n-1:0] din,\n  output analog_out\n);\n\nparameter n = 8; // number of bits in the digital input signal\nparameter v_ref_int = 32'd1000; // reference voltage for the DAC in mV\nparameter v_ref = v_ref_int / 1000.0; // reference voltage for the DAC in V\n\nreg [n-1:0] binary_value;\nwire [n-1:0] resistor_values;\nwire [31:0] analog_voltage;\n\nassign resistor_values = {v_ref_int, v_ref_int>>1, v_ref_int>>2, v_ref_int>>3, v_ref_int>>4, v_ref_int>>5, v_ref_int>>6, v_ref_int>>7}; // weighted resistor values\n\nassign analog_voltage = binary_value * resistor_values; // digital-to-analog conversion\n\nalways @(posedge clk) begin\n  if (rst) begin\n    binary_value <= 0; // reset to zero volts\n  end else begin\n    binary_value <= din; // update binary value\n  end\nend\n\nassign analog_out = analog_voltage;\n\nendmodule",
        "module_name": "DAC",
        "module_hash": "607e4b6d5281a158bd14824dd70dec48",
        "dataset_index": 9231
      },
      "adler_checksum #_aa974840": {
        "rtl_code": "module adler_checksum #(\n  parameter data_width = 8,\n  parameter prime = 65521\n\n)(\n  input clk,\n  input reset,\n  input [data_width-1:0] data_in,\n  input valid_in,\n  input start,\n  input [data_width-1:0] checksum_in, // Only for checker\n  output [data_width-1:0] data_out,\n  output valid_out,\n  output [data_width-1:0] checksum_out, // Only for generator\n  output checksum_match\n);\n\n\nreg [data_width-1:0] data_reg;\nreg [data_width-1:0] checksum_reg;\nreg [data_width-1:0] sum_reg;\nreg [data_width-1:0] sum_of_squares_reg;\nreg [data_width-1:0] checksum_calc;\nreg [data_width-1:0] checksum_match_reg;\n\nassign data_out = data_reg;\nassign valid_out = valid_in;\nassign checksum_out = checksum_reg;\nassign checksum_match = checksum_match_reg;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    data_reg <= 0;\n    checksum_reg <= 0;\n    sum_reg <= 0;\n    sum_of_squares_reg <= 0;\n    checksum_calc <= 0;\n    checksum_match_reg <= 0;\n  end else begin\n    if (valid_in) begin\n      data_reg <= data_in;\n      sum_reg <= sum_reg + data_in;\n      sum_of_squares_reg <= sum_of_squares_reg + (data_in * data_in);\n    end\n    if (start) begin\n      checksum_reg <= (sum_of_squares_reg * 65536) + sum_reg;\n      checksum_reg <= checksum_reg % prime;\n      if (checksum_in != 0) begin // Checker mode\n        if (checksum_in == checksum_reg) begin\n          checksum_match_reg <= 1;\n        end else begin\n          checksum_match_reg <= 0;\n        end\n      end else begin // Generator mode\n        checksum_calc <= checksum_reg;\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "adler_checksum #",
        "module_hash": "aa974840a7f85f5dcc0056116a560abc",
        "dataset_index": 4856
      },
      "alu_82ba5502": {
        "rtl_code": "module alu\n#(parameter WIDTH = 8)\n( input wire [WIDTH-1:0] in_a,\n  input wire [WIDTH-1:0] in_b,\n  input wire [2:0] opcode,\n  output reg [WIDTH-1:0] alu_out,\n  output wire a_is_zero );\n\n  assign a_is_zero = in_a ? 1'b0: 1'b1;\n\n  always @ ( * )\n  begin\n      if ( opcode == 3'b000 )\n        begin\n          alu_out = in_a;\n        end\n      else if ( opcode == 3'b001 )\n        begin\n          alu_out = in_a;\n        end\n      else if ( opcode == 3'b010 )\n        begin\n          alu_out = in_a + in_b;\n        end\n      else if ( opcode == 3'b011 )\n        begin\n          alu_out = in_a & in_b;\n        end\n      else if ( opcode == 3'b100 )\n        begin\n          alu_out = in_a ^ in_b;\n        end\n      else if ( opcode == 3'b101 )\n        begin\n          alu_out = in_b;\n        end\n      else if ( opcode == 3'b110 )\n        begin\n          alu_out = in_a;\n        end\n      else if ( opcode == 3'b111 )\n        begin\n          alu_out = in_a;\n        end\n      else\n        begin\n          alu_out = in_a;\n        end\n  end\nendmodule ",
        "module_name": "alu",
        "module_hash": "82ba55028814ce4c80f51c3c8acad27a",
        "dataset_index": 20690
      },
      "counter_3bit_b660616b": {
        "rtl_code": "module counter_3bit (\n  input clk,\n  input reset,\n  input inc_dec,\n  output reg [2:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    count <= 0;\n  end else begin\n    if (inc_dec) begin\n      if (count == 7) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    end else begin\n      if (count == 0) begin\n        count <= 7;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "counter_3bit",
        "module_hash": "b660616b4316e86e33431a88ab6c15df",
        "dataset_index": 1244
      },
      "adder_block_88c566b9": {
        "rtl_code": "module adder_block (\n    i_data0,\n    i_data1,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0, i_data1;\n  output  [31:0] o_data0;\n\n  //Adder:\n  wire [31:0] w1;\n  assign w1 = i_data0 + i_data1;\n  assign o_data0 = w1;\n\nendmodule",
        "module_name": "adder_block",
        "module_hash": "88c566b940e97f39f427c245639bb234",
        "dataset_index": 14191
      },
      "macc_simple_ena_09bb817a": {
        "rtl_code": "module macc_simple_ena (\n    input  wire        clk,\n    input  wire        ena,\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output reg  [15:0] Z\n);\n\n    always @(posedge clk)\n        if (ena) Z <= Z + (A * B);\n\nendmodule",
        "module_name": "macc_simple_ena",
        "module_hash": "09bb817a46bd0765ee877a82f9046867",
        "dataset_index": 8351
      },
      "NPM_Toggle_POR_ddd47855": {
        "rtl_code": "\n\nmodule NPM_Toggle_POR\n(\n    iSystemClock            ,\n    iReset                  ,\n    oReady                  ,\n    oLastStep               ,\n    iStart                  ,\n    oPO_Reset                       \n);\n    input                           iSystemClock            ;\n    input                           iReset                  ;\n    output                          oReady                  ;\n    output                          oLastStep               ;\n    input                           iStart                  ;\n    output                          oPO_Reset               ;\n    \n    parameter POR_FSM_BIT = 4;\n    parameter POR_RESET = 4'b0001;\n    parameter POR_READY = 4'b0010;\n    parameter POR_RFRST = 4'b0100; parameter POR_RLOOP = 4'b1000; reg     [POR_FSM_BIT-1:0]       rPOR_cur_state          ;\n    reg     [POR_FSM_BIT-1:0]       rPOR_nxt_state          ;\n    \n    \n    \n    reg                             rReady                  ;\n    \n    reg     [3:0]                   rTimer                  ;\n    \n    wire                            wJOBDone                ;\n    \n    reg                             rPO_Reset               ;\n    \n    \n    \n    assign wJOBDone = (4'b1001 == rTimer[3:0]); always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rPOR_cur_state <= POR_RESET;\n        end else begin\n            rPOR_cur_state <= rPOR_nxt_state;\n        end\n    end\n    \n    always @ ( * ) begin\n        case (rPOR_cur_state)\n            POR_RESET: begin\n                rPOR_nxt_state <= POR_READY;\n            end\n            POR_READY: begin\n                rPOR_nxt_state <= (iStart)? POR_RFRST:POR_READY;\n            end\n            POR_RFRST: begin\n                rPOR_nxt_state <= POR_RLOOP;\n            end\n            POR_RLOOP: begin\n                rPOR_nxt_state <= (wJOBDone)? ((iStart)? POR_RFRST:POR_READY):POR_RLOOP;\n            end\n            default:\n                rPOR_nxt_state <= POR_READY;\n        endcase\n    end\n    \n    always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rReady          <= 0;\n            rTimer[3:0]     <= 0;\n            rPO_Reset       <= 0;\n        end else begin\n            case (rPOR_nxt_state)\n                POR_RESET: begin\n                    rReady          <= 0;\n                    rTimer[3:0]     <= 0;\n                    rPO_Reset       <= 0;\n                end\n                POR_READY: begin\n                    rReady          <= 1;\n                    rTimer[3:0]     <= 0;\n                    rPO_Reset       <= 0;\n                end\n                POR_RFRST: begin\n                    rReady          <= 0;\n                    rTimer[3:0]     <= 4'b0000;\n                    rPO_Reset       <= 1;\n                end\n                POR_RLOOP: begin\n                    rReady          <= 0;\n                    rTimer[3:0]     <= rTimer[3:0] + 1'b1;\n                    rPO_Reset       <= 1;\n                end\n            endcase\n        end\n    end\n    \n    \n    \n    assign oReady               = rReady | wJOBDone     ;\n    assign oLastStep            = wJOBDone              ;\n    \n    assign oPO_Reset            = rPO_Reset              ;\n    \nendmodule\n",
        "module_name": "NPM_Toggle_POR",
        "module_hash": "ddd478550cb88a9b8a39f3631d663c5c",
        "dataset_index": 25591
      },
      "AXI_Master_831638ef": {
        "rtl_code": "\nmodule AXI_Master\n(\n    input axi_clk,\n    input axi_rst,\n    input [31:0] axi_araddr,\n    input axi_arvalid,\n    output axi_arready,\n    output [31:0] axi_rdata,\n    output axi_rvalid,\n    input axi_rready,\n    input [31:0] axi_awaddr,\n    input axi_awvalid,\n    output axi_awready,\n    input [31:0] axi_wdata,\n    input axi_wvalid,\n    output axi_wready,\n    output [1:0] axi_bresp,\n    output axi_bvalid,\n    input axi_bready\n);\n\n// Internal registers\nreg [31:0] addr_reg;\nreg [31:0] data_reg;\nreg [1:0] resp_reg;\nreg [1:0] state_reg;\n\n// Constants\nlocalparam IDLE = 2'b00;\nlocalparam READ = 2'b01;\nlocalparam WRITE = 2'b10;\n\n// RTL Code\n\n// Output logic\nassign axi_arready = (state_reg == IDLE) ? 1'b1 : 1'b0;\nassign axi_awready = (state_reg == IDLE) ? 1'b1 : 1'b0;\nassign axi_wready = (state_reg == IDLE) ? 1'b1 : 1'b0;\nassign axi_bresp = resp_reg;\nassign axi_bvalid = (state_reg == WRITE) ? 1'b1 : 1'b0;\nassign axi_rdata = (state_reg == READ) ? mem[addr_reg] : 32'h0;\nassign axi_rvalid = (state_reg == READ) ? 1'b1 : 1'b0;\n\n// State machine\nalways @(posedge axi_clk) begin\n    if (axi_rst) begin\n        state_reg <= IDLE;\n        addr_reg <= 32'h00000000;\n        data_reg <= 32'h00000000;\n        resp_reg <= 2'b00;\n    end else begin\n        case (state_reg)\n            IDLE: begin\n                if (axi_arvalid) begin\n                    state_reg <= READ;\n                    addr_reg <= axi_araddr;\n                end else if (axi_awvalid) begin\n                    state_reg <= WRITE;\n                    addr_reg <= axi_awaddr;\n                    data_reg <= axi_wdata;\n                end\n            end\n            READ: begin\n                if (axi_rready) begin\n                    resp_reg <= 2'b00;\n                    state_reg <= IDLE;\n                end\n            end\n            WRITE: begin\n                if (axi_bready) begin\n                    resp_reg <= 2'b00;\n                    state_reg <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\n// Memory\nreg [31:0] mem [0:1023];\n\nendmodule",
        "module_name": "AXI_Master",
        "module_hash": "831638ef890a03482285983918217009",
        "dataset_index": 17743
      },
      "mux4x1 #_f11fb52a": {
        "rtl_code": "module mux4x1 #(parameter SIZE=32) (\n    input wire [SIZE-1:0] iInput0,\n    input wire [SIZE-1:0] iInput1,\n    input wire [SIZE-1:0] iInput2,\n    input wire [SIZE-1:0] iInput3,\n    input wire [1:0] iSelect,\n    output reg [SIZE-1:0] oOutput\n);\n\n    always @(*) begin\n        case (iSelect)\n            2'b00: oOutput = iInput0;\n            2'b01: oOutput = iInput1;\n            2'b10: oOutput = iInput2;\n            2'b11: oOutput = iInput3;\n        endcase\n    end\n\nendmodule",
        "module_name": "mux4x1 #",
        "module_hash": "f11fb52afe01d99b049effc6ed41b350",
        "dataset_index": 14240
      },
      "synchronous_counter_4544de3f": {
        "rtl_code": "module synchronous_counter(CLK, RST, LOAD, EN, DATA_IN, DATA_OUT);\n\ninput CLK, RST, LOAD, EN;\ninput [3:0] DATA_IN;\noutput reg [3:0] DATA_OUT;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        DATA_OUT <= 4'b0;\n    end else if (LOAD) begin\n        DATA_OUT <= DATA_IN;\n    end else if (EN) begin\n        if (DATA_OUT == 4'b1111) begin\n            DATA_OUT <= 4'b0;\n        end else begin\n            DATA_OUT <= DATA_OUT + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "synchronous_counter",
        "module_hash": "4544de3f852c76874dba8758e0881a28",
        "dataset_index": 9840
      },
      "gray_code_state_machine_501843aa": {
        "rtl_code": "module gray_code_state_machine (\n  input clk,\n  input rst,\n  output [n-1:0] out\n);\n\nparameter n = 4; // number of output signals\n\nreg [n-1:0] state;\nreg [n-1:0] gray_code;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    state <= 0;\n  end else begin\n    state <= gray_code;\n  end\nend\n\nalways @* begin\n  case (state)\n    0: gray_code = 0;\n    1: gray_code = 1;\n    2: gray_code = 3;\n    3: gray_code = 2;\n    4: gray_code = 6;\n    5: gray_code = 7;\n    6: gray_code = 5;\n    7: gray_code = 4;\n    default: gray_code = 0;\n  endcase\nend\n\nassign out = gray_code;\n\nendmodule",
        "module_name": "gray_code_state_machine",
        "module_hash": "501843aa631a4f743b5ef6e20d40549d",
        "dataset_index": 17094
      },
      "multiplier_4bit_e102f7c2": {
        "rtl_code": "\nmodule multiplier_4bit (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    output [7:0] S\n);\n\nreg [7:0] reg_file [0:15]; // Register file with 16 registers\n\n// Fetch stage\nreg [3:0] addr1, addr2;\nalways @ (posedge clk) begin\n    addr1 <= A;\n    addr2 <= B;\nend\n\n// Execute stage\nreg [7:0] data1, data2;\nreg [15:0] result;\nalways @ (posedge clk) begin\n    data1 <= reg_file[addr1];\n    data2 <= reg_file[addr2];\n    result <= data1 * data2;\nend\n\n// Write back stage\nalways @ (posedge clk) begin\n    reg_file[addr1] <= result[7:0];\n    reg_file[addr2] <= result[15:8];\nend\n\n// Output stage\nassign S = reg_file[addr1]; // Output is the result in the first register\n\nendmodule\n",
        "module_name": "multiplier_4bit",
        "module_hash": "e102f7c2d00bbd82325a575483d6f806",
        "dataset_index": 19783
      },
      "fifo2_5b834410": {
        "rtl_code": "`ifndef _inc_fifo_\n`define _inc_fifo_\n\nmodule fifo2 (clk, reset, full, empty, item_in, item_out, write, read);\n\n\tparameter SIZE = 2;\n\tparameter DEPTH_LOG2 = 1;\n\n\tlocalparam DEPTH = 2 ** DEPTH_LOG2;\n\n\tinput clk, reset, write, read;\n\tinput [SIZE-1:0] item_in;\n\toutput [SIZE-1:0] item_out;\n\toutput full, empty;\n\n\treg full, empty;\n\treg [SIZE-1:0] memory [DEPTH-1:0];\n\treg [DEPTH_LOG2-1:0] read_ptr;\n\treg [DEPTH_LOG2-1:0] write_ptr;\n\twire [DEPTH_LOG2-1:0] read_ptr_p1 = read_ptr + 1;\n\twire [DEPTH_LOG2-1:0] write_ptr_p1 = write_ptr + 1;\n\n\tassign item_out = memory[read_ptr];\n\n\tinteger i;\n\n\twire do_read = read & !empty;\n\twire do_write = write & !full;\n\n\talways @(posedge clk or posedge reset) begin\n\n\t\tif (reset) begin\n\n\t\t\tread_ptr <= 0;\n\t\t\twrite_ptr <= 0;\n\t\t\tempty <= 1;\n\t\t\tfull <= 0;\n\t\t\tfor (i=0; i<DEPTH; i=i+1) memory[i] <= 0;\n\n\t\tend else begin\n\n\t\t\tif (do_read & do_write) begin\n\n\t\t\t\tread_ptr <= read_ptr_p1;\n\t\t\t\twrite_ptr <= write_ptr_p1;\n\t\t\t\tmemory[write_ptr] <= item_in;\n\n\t\t\tend else if (do_read) begin\n\n\t\t\t\tfull <= 0;\n\t\t\t\tread_ptr <= read_ptr_p1;\n\t\t\t\tempty <= (read_ptr_p1 == write_ptr);\n\n\t\t\tend else if (do_write) begin\n\n\t\t\t\tmemory[write_ptr] <= item_in;\n\t\t\t\tempty <= 0;\n\t\t\t\twrite_ptr <= write_ptr_p1;\n\t\t\t\tfull <= (read_ptr == write_ptr_p1);\n\n\t\t\tend\n\n\t\tend\n\n\tend\n\nendmodule\n\n`endif\n",
        "module_name": "fifo2",
        "module_hash": "5b834410fd13613084228700beb37cfb",
        "dataset_index": 16678
      },
      "shift_addsub_580b9803": {
        "rtl_code": "\nmodule shift_addsub (\n    input clk,\n    input reset,\n    input SER,\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] result\n);\n\n    reg [3:0] Q;\n    wire [3:0] shifted_Q;\n    wire [3:0] added_A;\n    wire [3:0] subbed_A;\n\n    shift_register shift_reg (\n        .clk(clk),\n        .reset(reset),\n        .SER(SER),\n        .SHIFT(shifted_Q),\n        .LOAD(Q)\n    );\n\n    adder_subtractor addsub (\n        .A(A),\n        .B(shifted_Q),\n        .sub(sub),\n        .result(added_A),\n        .sub_result(subbed_A)\n    );\n\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset)\n            Q <= 4'b0;\n        else\n            Q <= subbed_A;\n    end\n\n    assign result = (sub) ? subbed_A : added_A;\n\nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input SER,\n    output reg [3:0] SHIFT,\n    input [3:0] LOAD\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            SHIFT <= 4'b0;\n        end else begin\n            SHIFT <= LOAD;\n        end\n    end\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] result,\n    output [3:0] sub_result\n);\n\n    wire [3:0] subbed_A;\n    wire [3:0] subtracted_result;\n\n    assign subbed_A = (~A) + 1;\n    assign subtracted_result = subbed_A + B;\n\n    assign sub_result = subtracted_result[3:0];\n    assign result = sub ? subtracted_result[3:0] : A + B;\nendmodule",
        "module_name": "shift_addsub",
        "module_hash": "580b9803460d2322d062e9fa49fc04a4",
        "dataset_index": 492
      },
      "adder_shifter_b7160311": {
        "rtl_code": "module adder_shifter (\n    input [7:0] A,\n    input [7:0] B,\n    input carry_in,\n    input sub,\n    input [1:0] shift_amount,\n    input shift_direction,\n    output reg [7:0] sum,\n    output reg borrow_out,\n    output reg [7:0] shifted_output\n);\n\nreg [8:0] temp_sum;\nreg [7:0] temp_shifted_output;\n\nalways @(*) begin\n    if (sub) begin\n        temp_sum = {A, 1'b0} - {B, 1'b0} - carry_in;\n        borrow_out = temp_sum[8];\n    end else begin\n        temp_sum = {A, 1'b0} + {B, 1'b0} + carry_in;\n        borrow_out = temp_sum[8];\n    end\nend\n\nalways @(*) begin\n    case (shift_direction)\n        2'b00: temp_shifted_output = temp_sum << shift_amount;\n        2'b01: temp_shifted_output = temp_sum >> shift_amount;\n        default: temp_shifted_output = 8'b0;\n    endcase\nend\n\nalways @(*) begin\n    sum <= temp_sum[7:0];\n    shifted_output <= temp_shifted_output;\nend\n\nendmodule",
        "module_name": "adder_shifter",
        "module_hash": "b7160311d5880d05d19c234c1a7f259c",
        "dataset_index": 7751
      },
      "counter_with_adder_subtractor_4e109288": {
        "rtl_code": "\nmodule counter_with_adder_subtractor (\n    input [3:0] A,   // 4-bit input for adder/subtractor\n    input [3:0] B,   // 4-bit input for adder/subtractor\n    input sub,       // Input for adder/subtractor to choose between addition and subtraction\n    input RST,       // Asynchronous active-low reset input for counter\n    input clk,       // Clock input for counter\n    output [3:0] Q,  // 4-bit output from counter\n    output [3:0] sum, // 4-bit output from adder/subtractor\n    output overflow,  // Output from adder/subtractor to indicate overflow\n    output [3:0] final_output // 4-bit output from functional module\n);\n\nreg [3:0] counter;\nwire [3:0] adder_output;\n\n// Counter module\nalways @(posedge clk or negedge RST) begin\n    if (!RST) begin\n        counter <= 4'b0000;\n    end else begin\n        counter <= counter + 4'b0001;\n    end\nend\n\n// Adder/subtractor module\nassign sum = sub ? A - B : A + B;\nassign overflow = (sum[3] == 1 && sub == 0) || (sum[3] == 0 && sub == 1);\n\n// Functional module\nassign final_output = counter + adder_output;\n\n// Output assignments\nassign Q = counter;\nassign adder_output = sum;\n\nendmodule",
        "module_name": "counter_with_adder_subtractor",
        "module_hash": "4e109288691e5d5d75277e19be9fc7ce",
        "dataset_index": 10652
      },
      "flip_flop_5be9ed26": {
        "rtl_code": "module flip_flop (\n    Q      ,\n    Q_N    ,\n    D      ,\n    SCD    ,\n    SCE    ,\n    CLK    ,\n    SET_B  ,\n    RESET_B,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output Q      ;\n    output Q_N    ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  CLK    ;\n    input  SET_B  ;\n    input  RESET_B;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n    \n    reg Q;\n    assign Q_N = ~Q;\n    \n    always @(posedge CLK) begin\n        if (SET_B == 0) begin\n            Q <= 1;\n        end else if (RESET_B == 0) begin\n            Q <= 0;\n        end else if (SCD == 0) begin\n            Q <= 0;\n        end else if (SCE == 1) begin\n            Q <= D;\n        end\n    end\n    \nendmodule",
        "module_name": "flip_flop",
        "module_hash": "5be9ed26a569f5a53765c62aea3fd38f",
        "dataset_index": 14119
      },
      "barrel_shift_3bit_reg_and_gate_f5acda99": {
        "rtl_code": "module barrel_shift_3bit_reg_and_gate (\n    input clk,\n    input [3:0] data_in,\n    input [1:0] shift_amount,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    output [2:0] out\n);\n\n    // 4-bit Barrel Shifter\n    reg [3:0] shifted_data;\n    always @(*) begin\n        case(shift_amount)\n            2'b00: shifted_data = data_in;\n            2'b01: shifted_data = {data_in[3], data_in[0:2]};\n            2'b10: shifted_data = {data_in[2:3], data_in[0:1]};\n            2'b11: shifted_data = {data_in[1:3], data_in[0]};\n            default: shifted_data = 4'b0000;\n        endcase\n    end\n\n    // 3-bit Shift Register\n    reg [2:0] reg_data;\n    always @(posedge clk) begin\n        if(shift) begin\n            if(control) reg_data <= {reg_data[1:0], 1'b0};\n            else reg_data <= {1'b0, reg_data[2:1]};\n        end\n        else if(parallel_load != 3'b111) begin\n            reg_data <= parallel_load;\n        end\n    end\n\n    // AND Gate\n    assign out = shifted_data & reg_data;\n\nendmodule",
        "module_name": "barrel_shift_3bit_reg_and_gate",
        "module_hash": "f5acda993b5c8836025a1af792f67870",
        "dataset_index": 8578
      },
      "mux5 #_ca083ce6": {
        "rtl_code": "\nmodule mux5 #(parameter WIREWIDTH = 1) (input wire [2:0] s,\n\t\t\t\t\tinput wire [WIREWIDTH:0] d0, d1, d2,d3, d4,\n\t\t\t\t\toutput reg [WIREWIDTH:0] o);\n\n   always @* begin\n      case(s)\n\t0: o = d0;\n\t1: o = d1;\n        2: o = d2;\n        3: o = d3;\n        default: o = d4;\n      endcase\n   end\n\nendmodule",
        "module_name": "mux5 #",
        "module_hash": "ca083ce6ec72e470b624f79440381c12",
        "dataset_index": 3285
      },
      "counter_4bit_66f39994": {
        "rtl_code": "module counter_4bit (\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        count <= 4'b0000;\n    end else begin\n        if (count == 4'b1111) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "66f39994076bf4c4bc66694b2e584674",
        "dataset_index": 3708
      },
      "font_decoder_44ccc857": {
        "rtl_code": "module font_decoder(\n    input wire [31:0] font_data_in,\n    output reg [27:0] seg_out\n);\n\n    always @(*) begin\n        case(font_data_in)\n            4'b0000_0000_0000_0000_0000_0000_0000_0001: seg_out = {7'b0111111, 7'b0000110, 7'b1011011, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0010: seg_out = {7'b0000110, 7'b0000110, 7'b1111101, 7'b0000111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0011: seg_out = {7'b1011011, 7'b0000110, 7'b1101101, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0100: seg_out = {7'b1001110, 7'b1100110, 7'b0000110, 7'b0000111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0101: seg_out = {7'b1111101, 7'b1101101, 7'b0000110, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0110: seg_out = {7'b1111111, 7'b1101101, 7'b0000110, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0111: seg_out = {7'b0000111, 7'b0000110, 7'b1011011, 7'b0000111};\n            4'b0000_0000_0000_0000_0000_0000_0000_1000: seg_out = {7'b1111111, 7'b1101111, 7'b0000110, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_1001: seg_out = {7'b1111101, 7'b1101101, 7'b0000110, 7'b1001111};\n            default: seg_out = 28'b0;\n        endcase\n    end\n\nendmodule",
        "module_name": "font_decoder",
        "module_hash": "44ccc857784ccd8a1b0823759c9a0b75",
        "dataset_index": 7062
      },
      "binary_adder_4e8251b6": {
        "rtl_code": "\nmodule binary_adder (\n    A,\n    B,\n    C_in,\n    S,\n    C_out\n);\n\n    input [3:0] A;\n    input [3:0] B;\n    input C_in;\n    output [3:0] S;\n    output C_out;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire [4:0] sum; // Changed the range of the wire to [4:0]\n    wire carry;\n\n    assign sum = A + B + C_in;\n    assign S = sum[3:0];\n    assign carry = sum[4];\n\n    assign C_out = carry;\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "4e8251b6977ee0cfa2dd5ab4ba549b78",
        "dataset_index": 6439
      },
      "sky130_fd_sc_hvl__lsbuflv2hv_clkiso_hlkg_880698ab": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__lsbuflv2hv_clkiso_hlkg (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    wire SLEEP     ;\n    wire and0_out_X;\n\n    not not0 (SLEEP     , SLEEP_B        );\n    and and0 (and0_out_X, SLEEP_B, A     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__lsbuflv2hv_clkiso_hlkg",
        "module_hash": "880698ab76f2b3c36764790abe90aaff",
        "dataset_index": 22802
      },
      "xnor_gate_d18ad108": {
        "rtl_code": "\nmodule xnor_gate(\n    input a,\n    input b,\n    output out\n);\n\nwire nand_out, nor_out;\n\nnand_gate nand1(a, b, nand_out);\nnor_gate nor1(a, b, nor_out);\nnand_gate nand2(nand_out, nor_out, out);\n\nendmodule\nmodule nand_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a & b);\n\nendmodule\nmodule nor_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\nmodule top_module( \n    input [3:0] in,\n    output out\n);\n\nwire xnor_out1, xnor_out2;\n\nxnor_gate xnor1(in[0], in[1], xnor_out1);\nxnor_gate xnor2(in[2], in[3], xnor_out2);\nxnor_gate xnor3(xnor_out1, xnor_out2, out);\n\nendmodule",
        "module_name": "xnor_gate",
        "module_hash": "d18ad10888935cf80d16dc179564f243",
        "dataset_index": 9981
      },
      "ripple_carry_adder_5830f5c0": {
        "rtl_code": "module ripple_carry_adder (\n  input [3:0] a, b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] c;\n  \n  assign c[0] = cin;\n  assign c[1] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n  assign c[2] = (a[1] & b[1]) | (a[1] & c[1]) | (b[1] & c[1]);\n  assign c[3] = (a[2] & b[2]) | (a[2] & c[2]) | (b[2] & c[2]);\n  \n  assign sum = a + b + cin;\n  assign cout = c[3];\n  \nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "5830f5c0898dfca76d8615c45a795138",
        "dataset_index": 6448
      },
      "multiply_by_3_df44605a": {
        "rtl_code": "module multiply_by_3 (\n    input [3:0] a,\n    output reg [5:0] out\n);\n\nalways @ (a) begin\n    out = a << 1; // left shift by 1 is equivalent to multiplication by 2\n    out = out + a; // add the original number to get multiplication by 3\nend\n\nendmodule",
        "module_name": "multiply_by_3",
        "module_hash": "df44605a99ae7db705ad244038cd2ebf",
        "dataset_index": 5781
      },
      "sky130_fd_sc_lp__iso1n_4c9a5db0": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__iso1n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    wire SLEEP;\n\n    not not0 (SLEEP , SLEEP_B        );\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__iso1n",
        "module_hash": "4c9a5db0dd53e288daded2d9cd2a8422",
        "dataset_index": 12230
      },
      "count_even_01c35132": {
        "rtl_code": "module count_even(\n    input [255:0] in,\n    output reg [3:0] out\n);\n\n    integer i;\n    reg [7:0] even_count;\n\n    always @(*) begin\n        even_count = 0;\n        for (i = 0; i < 256; i = i + 2) begin\n            if (in[i]) begin\n                even_count = even_count + 1;\n            end\n        end\n        out = even_count[3:0];\n    end\n\nendmodule",
        "module_name": "count_even",
        "module_hash": "01c351326f3604428838bcac1506da52",
        "dataset_index": 8140
      },
      "bytewrite_ram_32bits_f375262c": {
        "rtl_code": "\nmodule bytewrite_ram_32bits (\n    input clk,\n    input [3:0] we,\n    input [11:0] addr,\n    input [31:0] din,\n    output [31:0] dout\n);\n\n    parameter SIZE = 1024;\n    parameter ADDR_WIDTH = 12;\n    parameter filename = \"code.hex\";\n    \n    localparam COL_WIDTH = 8;\n    localparam NB_COL = 4;\n    \n    reg [31:0] RAM [SIZE-1:0];\n    \n    integer _i;\n    \n    wire [11:0] addr_dly;\n    reg [31:0] dout_int;\n    \n    initial begin\n        for(_i=0; _i<SIZE; _i=(_i+1)) begin\n            RAM[_i] = 32'd0;\n        end\n    end\n    \n    always @(posedge clk) begin\n        dout_int <= RAM[addr];\n    end\n    \n    assign dout = dout_int;\n    \n    always @(posedge clk) begin\n        if (we[0]) begin\n            RAM[addr][7:0] <= din[7:0];\n        end\n        if (we[1]) begin\n            RAM[addr][15:8] <= din[15:8];\n        end\n        if (we[2]) begin\n            RAM[addr][23:16] <= din[23:16];\n        end\n        if (we[3]) begin\n            RAM[addr][31:24] <= din[31:24];\n        end\n    end\n    \nendmodule",
        "module_name": "bytewrite_ram_32bits",
        "module_hash": "f375262cd81c0a561432c30d1cee26e3",
        "dataset_index": 5808
      },
      "xor_gate_1236fd10": {
        "rtl_code": "module xor_gate(\n    input a,\n    input b,\n    output out\n);\n\nwire w1, w2, w3;\n\nand_gate and1(.a(a), .b(~b), .out(w1));\nand_gate and2(.a(~a), .b(b), .out(w2));\nor_gate or1(.a(w1), .b(w2), .out(w3));\nnot_gate not1(.a(w3), .out(out));\n\nendmodule\n\nmodule and_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n\nmodule or_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a | b;\n\nendmodule\n\nmodule not_gate(\n    input a,\n    output out\n);\n\nassign out = ~a;\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input a,\n    input b,\n    output out_always_ff\n);\n\nreg a_ff, b_ff;\n\nalways @(posedge clk) begin\n    a_ff <= a;\n    b_ff <= b;\nend\n\nxor_gate xor1(.a(a_ff), .b(b_ff), .out(out_always_ff));\n\nendmodule",
        "module_name": "xor_gate",
        "module_hash": "1236fd1003957f95bde8439a5d0a7faf",
        "dataset_index": 12396
      },
      "sky130_fd_sc_ls__and2b_721eb73a": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__and2b (\n    X  ,\n    A_N,\n    B\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N            );\n    and and0 (and0_out_X, not0_out, B    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__and2b",
        "module_hash": "721eb73aeb5040bb7550af944b9e7fe0",
        "dataset_index": 16625
      },
      "four_bit_alu_840b6574": {
        "rtl_code": "module four_bit_alu(\n    input [3:0] ctl,\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out,\n    output zero\n);\n\nwire [3:0] add_ab;\nwire [3:0] sub_ab;\nwire [3:0] and_ab;\nwire [3:0] or_ab;\nwire [3:0] xor_ab;\nwire [3:0] not_a;\nwire [3:0] shl_a;\nwire [3:0] shr_a;\nwire ovf;\n\nassign add_ab = a + b;\nassign sub_ab = a - b;\nassign and_ab = a & b;\nassign or_ab = a | b;\nassign xor_ab = a ^ b;\nassign not_a = ~a;\nassign shl_a = {a[2:0], 1'b0};\nassign shr_a = {1'b0, a[3:1]};\n\nassign zero = (out == 4'b0000);\n\nassign ovf = (ctl == 4'b0000 || ctl == 4'b0001) ? (a[3] == b[3] && out[3] != a[3]) : 1'b0;\n\nalways @(*) begin\n    case (ctl)\n        4'b0000: out <= add_ab; // Addition\n        4'b0001: out <= sub_ab; // Subtraction\n        4'b0010: out <= and_ab; // Bitwise AND\n        4'b0011: out <= or_ab; // Bitwise OR\n        4'b0100: out <= xor_ab; // Bitwise XOR\n        4'b0101: out <= not_a; // Bitwise NOT\n        4'b0110: out <= shl_a; // Shift left\n        4'b0111: out <= shr_a; // Shift right\n        default: out <= 4'b0000;\n    endcase\nend\n\nendmodule",
        "module_name": "four_bit_alu",
        "module_hash": "840b6574105f54add67806c2a5a9a8f2",
        "dataset_index": 7540
      },
      "Adder_ba3c459c": {
        "rtl_code": "\n\n\nmodule Adder(din_a, din_b, din_c, dout);\n\n\t\n\tinput wire[3:0] din_a;\n\n\t\n\tinput wire[3:0] din_b;\n\n\t\n\tinput wire[3:0] din_c;\n\n\t\n\toutput wire[3:0] dout;\n\n\t\n\n\tassign dout = din_a + din_b;\n\tendmodule\n",
        "module_name": "Adder",
        "module_hash": "ba3c459c9c034242b2272f9d6514b8bf",
        "dataset_index": 24572
      },
      "ring_ce9d22d8": {
        "rtl_code": "\n\nmodule ring\n#(parameter WIDTH = 32, ALARM_STEP = 24)\n(\n    input [(WIDTH-1):0] clk_src,\n    input power,\n    input weight_ch,\n    input mode_ch,\n    input [2:0] w_r_d_end,\n    output reg alarm\n);\n\n    reg [(WIDTH-1):0] count;\n    \n    reg [1:0] state, next_state;\n    parameter NO_ALARM = 0, BTN_ALARM = 1, PHASE_ALARM = 2;\n    \n    initial begin\n        alarm <= 0;\n        count <= 0;\n        state <= NO_ALARM;\n        next_state <= NO_ALARM;\n    end\n    \n    always @(clk_src[0]) begin\n        if (power) begin\n            state = next_state;\n        end else if (!power) begin\n            state = NO_ALARM;\n        end\n    end\n    \n    always @(mode_ch or weight_ch or w_r_d_end or count) begin\n        if (power) begin\n            case(state)\n                NO_ALARM: begin\n                    if (mode_ch || weight_ch) begin\n                        next_state = BTN_ALARM;\n                    end else if (w_r_d_end) begin\n                        next_state = PHASE_ALARM;\n                    end else begin\n                        next_state = NO_ALARM;\n                    end\n                end\n                BTN_ALARM: begin\n                    if (w_r_d_end) begin\n                        next_state = PHASE_ALARM;\n                    end else if (count >= 2) begin\n                        next_state = NO_ALARM;\n                    end else begin\n                        next_state = BTN_ALARM;\n                    end\n                end\n                PHASE_ALARM: begin\n                    if (mode_ch || weight_ch) begin\n                        next_state = BTN_ALARM;\n                    end\n                    else if (count >= 6) begin\n                        next_state = NO_ALARM;\n                    end else begin\n                    next_state = PHASE_ALARM;\n                    end\n                end\n            endcase\n        end else begin\n            next_state = NO_ALARM;\n        end\n    end\n    \n    always @(posedge clk_src[ALARM_STEP]) begin\n        case(state)\n            NO_ALARM: begin\n                count = 0;\n                alarm = 0;\n            end\n            BTN_ALARM: begin\n                count = count + 1;\n                alarm = ~alarm;\n            end\n            PHASE_ALARM: begin\n                count = count + 1;\n                alarm = ~alarm;\n            end\n       endcase\n   end\n    \nendmodule\n",
        "module_name": "ring",
        "module_hash": "ce9d22d8d5a8cf24144d9861e821f856",
        "dataset_index": 23126
      },
      "pipeline_register_20ad209c": {
        "rtl_code": "module pipeline_register (\n  input CLK,\n  input EN,\n  input [31:0] DATA_IN,\n  output [31:0] DATA_OUT_1,\n  output [31:0] DATA_OUT_2,\n  output [31:0] DATA_OUT_3\n);\n\n  reg [31:0] data_reg_1, data_reg_2, data_reg_3;\n\n  always @(posedge CLK) begin\n    if (EN) begin\n      data_reg_3 <= data_reg_2;\n      data_reg_2 <= data_reg_1;\n      data_reg_1 <= DATA_IN;\n    end\n  end\n\n  assign DATA_OUT_1 = data_reg_2;\n  assign DATA_OUT_2 = data_reg_3;\n  assign DATA_OUT_3 = DATA_IN;\n\nendmodule",
        "module_name": "pipeline_register",
        "module_hash": "20ad209c15845d301f7c0c369b18d727",
        "dataset_index": 8232
      },
      "calculator_a143f705": {
        "rtl_code": "module calculator(\n  input [7:0] num1,\n  input [7:0] num2,\n  input [1:0] op,\n  output reg [7:0] result\n);\n\nalways @(*)\nbegin\n  case(op)\n    2'b00: result = num1 + num2;\n    2'b01: result = num1 - num2;\n    2'b10: result = num1 * num2;\n    2'b11: result = num1 / num2;\n  endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "a143f705fe2a1fdfc755bc6b3b3b72ed",
        "dataset_index": 15412
      },
      "aurora_201_STANDARD_CC_MODULE_41e8cb53": {
        "rtl_code": "\n\nmodule aurora_201_STANDARD_CC_MODULE\n(\n    WARN_CC,\n    DO_CC,\n    \n    \n    DCM_NOT_LOCKED,\n    USER_CLK,\n    CHANNEL_UP\n\n);\n\n`define DLY #1\n\n\noutput      WARN_CC;\n    output      DO_CC;\n    \n    \n    input       DCM_NOT_LOCKED;\n    input       USER_CLK;\n    input       CHANNEL_UP;\n    \n    \nreg             WARN_CC;\n    reg             DO_CC;\n    \n\nreg     [0:9]   prepare_count_r;\n    reg     [0:5]   cc_count_r;\n    reg             reset_r;\n    \n    reg     [0:11]  count_13d_srl_r;\n    reg             count_13d_flop_r;\n    reg     [0:14]  count_16d_srl_r;\n    reg             count_16d_flop_r;\n    reg     [0:22]  count_24d_srl_r;\n    reg             count_24d_flop_r;    \n\n\n\nwire    start_cc_c;\n    wire    inner_count_done_r;\n    wire    middle_count_done_c;\n    wire    cc_idle_count_done_c;\n    \n   \nalways @(posedge USER_CLK)\n        count_13d_srl_r     <=  `DLY    {count_13d_flop_r, count_13d_srl_r[0:10]};\n        \n    \n    assign  inner_count_done_r  =  count_13d_srl_r[11];\n \n \n    always @(posedge USER_CLK)\n        if(~CHANNEL_UP)\n            count_13d_flop_r    <=  `DLY    1'b0;\n        else if(CHANNEL_UP && reset_r)\n            count_13d_flop_r    <=  `DLY    1'b1;\n        else\n            count_13d_flop_r    <=  `DLY    inner_count_done_r;\n            \n \n  \n \n \n \n \n    always @(posedge USER_CLK)\n        if(inner_count_done_r|| !CHANNEL_UP)\n            count_16d_srl_r     <=  `DLY    {count_16d_flop_r, count_16d_srl_r[0:13]};\n            \n    \n    assign  middle_count_done_c =   inner_count_done_r && count_16d_srl_r[14];     \n \n \n    \n    always @(posedge USER_CLK)\n        if(~CHANNEL_UP)\n            count_16d_flop_r    <=  `DLY    1'b0;\n        else if(CHANNEL_UP && reset_r)\n            count_16d_flop_r    <=  `DLY    1'b1;\n        else if(inner_count_done_r)    \n            count_16d_flop_r    <=  `DLY    middle_count_done_c;\n \n\n  \n \n \n    always @(posedge USER_CLK)\n        if(middle_count_done_c || !CHANNEL_UP)\n            count_24d_srl_r     <=  `DLY    {count_24d_flop_r, count_24d_srl_r[0:21]};\n            \n            \n    assign  cc_idle_count_done_c    =   middle_count_done_c & count_24d_srl_r[22];\n    \n    always @(posedge USER_CLK)\n        if(~CHANNEL_UP)\n            count_24d_flop_r    <=  `DLY    1'b0;\n        else if(CHANNEL_UP && reset_r)\n            count_24d_flop_r    <=  `DLY    1'b1;\n        else if(middle_count_done_c)\n            count_24d_flop_r    <=  `DLY    cc_idle_count_done_c;   \n \n    \n    \n    initial\n        prepare_count_r = 10'b0000000000;\n \n \n \n     always @(posedge USER_CLK)\n         prepare_count_r <=  `DLY    {cc_idle_count_done_c,prepare_count_r[0:8]};\n \n\n \n \n    always @(posedge USER_CLK)\n         if(!CHANNEL_UP)                            WARN_CC    <=  `DLY    1'b0;\n         else if(cc_idle_count_done_c)              WARN_CC    <=  `DLY    1'b1;\n         else if(prepare_count_r[9])                WARN_CC    <=  `DLY    1'b0;\n \n\n\n    initial\n         cc_count_r = 6'b000000;\n \n \n \n    always @(posedge USER_CLK)\n        reset_r <=  `DLY    !CHANNEL_UP;\n \n \n \n    assign start_cc_c   =   prepare_count_r[9] || (CHANNEL_UP && reset_r);\n \n \n     always @(posedge USER_CLK)\n         cc_count_r      <=  `DLY    {(!CHANNEL_UP|prepare_count_r[9]),cc_count_r[0:4]};\n        \n        \n        \n     always @(posedge USER_CLK)\n         if(!CHANNEL_UP)                 DO_CC <=  `DLY    1'b0;\n         else if(start_cc_c)             DO_CC <=  `DLY    1'b1;\n         else if(cc_count_r[5])          DO_CC <=  `DLY    1'b0;         \n         \nendmodule\n\n\n",
        "module_name": "aurora_201_STANDARD_CC_MODULE",
        "module_hash": "41e8cb53eac0bf21061fbd5542b9d051",
        "dataset_index": 24397
      },
      "compression_decompression_b83af55c": {
        "rtl_code": "module compression_decompression (\n  input [7:0] data_in,\n  output [3:0] data_out\n);\n\n  wire [1:0] code;\n  assign code = (data_in[7:4] == 4'b0000) ? 2'b10 : \n                (data_in[7:4] == 4'b1111) ? 2'b11 :\n                (data_in[7:4] == data_in[3:0]) ? 2'b01 : \n                2'b00;\n\n  assign data_out = {code, (code == 2'b10 || code == 2'b11) ? data_in[7:6] : data_in[1:0]};\n\nendmodule\n",
        "module_name": "compression_decompression",
        "module_hash": "b83af55c69962a1ca1c161a0fb7a8412",
        "dataset_index": 262
      },
      "DLL_c44b0d5b": {
        "rtl_code": "module DLL (\n  input ref_clk,\n  input data_in,\n  output reg data_out\n);\n\nparameter delay = 5; // amount of delay to be added to the reference clock signal\n\nreg delayed_ref_clk;\nreg [1:0] phase_difference;\nreg [1:0] loop_filter_output;\nreg [1:0] loop_filter_state;\n\nalways @(posedge ref_clk) begin\n  delayed_ref_clk <= #delay ref_clk;\n  phase_difference <= {phase_difference[0], data_in} ^ {delayed_ref_clk, delayed_ref_clk};\n  loop_filter_output <= loop_filter_state + phase_difference;\n  loop_filter_state <= loop_filter_output;\n  data_out <= #delayed_ref_clk data_in;\nend\n\nendmodule",
        "module_name": "DLL",
        "module_hash": "c44b0d5b18d2553ee228fe4c715bc32d",
        "dataset_index": 19464
      },
      "cart_81723705": {
        "rtl_code": "module cart\n(\n  input  wire           clk,\n  input  wire           clk7_en,\n  input  wire           clk7n_en,\n  input  wire           cpu_rst,\n  input  wire [ 24-1:1] cpu_address,\n  input  wire [ 24-1:1] cpu_address_in,\n  input  wire           _cpu_as,\n  input  wire           cpu_rd,\n  input  wire           cpu_hwr,\n  input  wire           cpu_lwr,\n  input  wire [ 32-1:0] cpu_vbr,\n  input  wire [  9-1:1] reg_address_in,\n  input  wire [ 16-1:0] reg_data_in,\n  input  wire           dbr,\n  input  wire           ovl,\n  input  wire           freeze,\n  output wire [ 16-1:0] cart_data_out,\n  output reg            int7 = 1'b0,\n  output wire           sel_cart,\n  output wire           ovr,\noutput wire           aron\n);\n\n\nreg  [32-1:0] nmi_vec_adr=0;\nreg           freeze_d=0;\nwire          freeze_req;\nwire          int7_req;\nwire          int7_ack;\nreg           l_int7_req=0;\nreg           l_int7_ack=0;\nreg           l_int7=0;\nreg           active=0;\nwire          sel_custom_mirror;\nwire [16-1:0] nmi_adr_out;\nreg  [16-1:0] custom_mirror_q;\nwire [16-1:0] custom_mirror_out;\nreg  [16-1:0] custom_mirror [0:256-1];\n\n\n`define ARON_HACK\n`ifndef ARON_HACK\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst && (cpu_address_in[23:19]==5'b1010_0) && cpu_lwr && !aron)\n      aron <= 1'b1;\n  end\nend\n`else\nassign aron = 1'b1;\n`endif\n\nassign sel_cart = ~dbr && (cpu_address_in[23:19]==5'b1010_0); always @ (posedge clk) begin\n  if (clk7_en) begin\n    nmi_vec_adr <= #1 cpu_vbr + 32'h0000007c; end\nend\n\nassign ovr = active && ~dbr && ~ovl && cpu_rd && (cpu_address_in[23:2] == nmi_vec_adr[23:2]);\n\nassign nmi_adr_out = ovr ? (!cpu_address_in[1] ? 16'h00a1 : 16'h000c) : 16'h0000;\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    freeze_d <= freeze;\n  end\nend\n\nassign freeze_req = freeze && ~freeze_d;\n\nassign int7_req =  freeze_req;\n\nassign int7_ack = &cpu_address_in && ~_cpu_as;\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst)\n      int7 <= 1'b0;\n    else if (int7_req)\n      int7 <= 1'b1;\n    else if (int7_ack)\n      int7 <= 1'b0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    l_int7_req <= int7_req;\n    l_int7_ack <= int7_ack;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst)\n      l_int7 <= 1'b0;\n    else if (l_int7_req)\n      l_int7 <= 1'b1;\n    else if (l_int7_ack && cpu_rd)\n      l_int7 <= 1'b0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst)\n      active <= #1 1'b0;\n    else if ( l_int7 && l_int7_ack && cpu_rd)\n      active <= #1 1'b1;\n    else if (sel_cart && cpu_rd)\n      active <= #1 1'b0;\n  end\nend\n\nassign sel_custom_mirror = ~dbr && cpu_rd && (cpu_address_in[23:12]==12'b1010_1001_1111); always @ (posedge clk) begin\n  if (clk7_en) begin\n    custom_mirror[reg_address_in] <= #1 reg_data_in;\n  end\n  custom_mirror_q <= #1 custom_mirror[cpu_address_in[8:1]];\nend\n\nassign custom_mirror_out = sel_custom_mirror ? custom_mirror_q : 16'h0000;\n\nassign cart_data_out = custom_mirror_out | nmi_adr_out;\n\n\nendmodule\n\n",
        "module_name": "cart",
        "module_hash": "81723705fbeb0607a4f7b9e3f64965f8",
        "dataset_index": 13108
      },
      "clock_gate_d_ff_en_W32_0_11_e6f46b4f": {
        "rtl_code": "module clock_gate_d_ff_en_W32_0_11 (\n  input CLK,\n  input EN,\n  input TE,\n  input [31:0] d,\n  output reg ENCLK\n);\n\n  TLALATCH clock_gating_cell (\n    .CLK(CLK),\n    .EN(EN),\n    .TE(TE),\n    .GATED_CLK(ENCLK)\n  );\n\n\nendmodule\n\n// Clock gating cell (simplified example)\nmodule TLALATCH(\n  input CLK,\n  input EN,\n  input TE,\n  output GATED_CLK\n);\n\n  // Simple clock gating logic\n  assign GATED_CLK = CLK & (EN | ~TE);\n\nendmodule\n",
        "module_name": "clock_gate_d_ff_en_W32_0_11",
        "module_hash": "e6f46b4fa85ee3c3bded524a1b065583",
        "dataset_index": 1641
      },
      "shift_right #_9ae9f15a": {
        "rtl_code": "module shift_right #(parameter A_SIGNED = 0, A_WIDTH = 32, Y_WIDTH = 32) (\n    input [A_WIDTH-1:0] A,\n    input [4:0] B,\n    output [A_WIDTH-1:0] Y\n);\n\n    wire [A_WIDTH-1:0] shifted;\n    assign shifted = A >> B;\n\n    assign Y = shifted;\n\nendmodule",
        "module_name": "shift_right #",
        "module_hash": "9ae9f15aa2c77de00ed446cc6ac80f16",
        "dataset_index": 19653
      },
      "sky130_fd_sc_ms__a2111o_c8e4b91c": {
        "rtl_code": "module sky130_fd_sc_ms__a2111o (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign X = (A1 && !A2) ? 1 :\n               (!A1 && A2) ? 0 :\n               (A1 && A2) ? 0 :\n               (!A1 && !A2) ? 1 :\n               (B1) ? 0 :\n               (C1) ? 1 :\n               (D1) ? 0 :\n               (VPWR) ? 1 :\n               (VGND) ? 0 :\n               (VPB) ? 0 :\n               (VNB) ? 1 :\n               0;\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__a2111o",
        "module_hash": "c8e4b91c36d2da3984e08e212d7707ad",
        "dataset_index": 6213
      },
      "decoder_0301bfab": {
        "rtl_code": "module decoder (\n    input [3:0] ABCD,\n    output reg [15:0] out\n);\n\nalways @(*) begin\n    case (ABCD)\n        4'b0000: out = 16'b0000_0000_0000_0001;\n        4'b0001: out = 16'b0000_0000_0000_0010;\n        4'b0010: out = 16'b0000_0000_0000_0100;\n        4'b0011: out = 16'b0000_0000_0000_1000;\n        4'b0100: out = 16'b0000_0000_0001_0000;\n        4'b0101: out = 16'b0000_0000_0010_0000;\n        4'b0110: out = 16'b0000_0000_0100_0000;\n        4'b0111: out = 16'b0000_0000_1000_0000;\n        4'b1000: out = 16'b0000_0001_0000_0000;\n        4'b1001: out = 16'b0000_0010_0000_0000;\n        4'b1010: out = 16'b0000_0100_0000_0000;\n        4'b1011: out = 16'b0000_1000_0000_0000;\n        4'b1100: out = 16'b0001_0000_0000_0000;\n        4'b1101: out = 16'b0010_0000_0000_0000;\n        4'b1110: out = 16'b0100_0000_0000_0000;\n        4'b1111: out = 16'b1000_0000_0000_0000;\n        default: out = 16'b0000_0000_0000_0000;\n    endcase\nend\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "0301bfabe0c5cfa31d83a926d70d50b6",
        "dataset_index": 20832
      },
      "memory_0f8e2565": {
        "rtl_code": "module memory (\n    input [9:0] address,\n    input clock,\n    input [11:0] data_in,\n    input write_en,\n    output reg [11:0] data_out\n);\n\n    reg [11:0] mem[1023:0];\n\n    always @(posedge clock) begin\n        if (write_en) begin\n            mem[address] <= data_in;\n        end\n        data_out <= mem[address];\n    end\n\nendmodule",
        "module_name": "memory",
        "module_hash": "0f8e25657ab5c1e31d6c0e29834d5fc7",
        "dataset_index": 7954
      },
      "unknown_module_51e85de7": {
        "rtl_code": "`define\tOPT_DUMBECHO\n`ifndef\tVERILATOR\n`define OPT_STANDALONE\n`endif\nmodule\techotest(\n\t\tinput\t\ti_clk,\n`ifndef\tOPT_STANDALONE\n\t\tinput\t[30:0]\ti_setup,\n`endif\n\t\tinput\t\ti_uart_rx,\n\t\toutput\twire\to_uart_tx\n\t\t);\n\n`ifdef\tOPT_DUMBECHO\n\treg\tr_uart_tx;\n\n\tinitial\tr_uart_tx = 1'b1;\n\talways @(posedge i_clk)\n\t\tr_uart_tx <= i_uart_rx;\n\tassign\to_uart_tx = r_uart_tx;\n\t`else\n\t`ifdef\tOPT_STANDALONE\n\twire\t[30:0]\ti_setup;\n\tassign\t\ti_setup = 31'd868;\t`endif\n\treg\tpwr_reset;\n\tinitial\tpwr_reset = 1'b1;\n\talways @(posedge i_clk)\n\t\tpwr_reset = 1'b0;\n\twire\trx_stb, rx_break, rx_perr, rx_ferr, rx_ignored;\n\twire\t[7:0]\trx_data;\n\n`ifdef\tUSE_LITE_UART\n\trxuartlite\t#(24'd868)\n\t\treceiver(i_clk, i_uart_rx, rx_stb, rx_data);\n`else\n\trxuart\treceiver(i_clk, pwr_reset, i_setup, i_uart_rx, rx_stb, rx_data,\n\t\t\trx_break, rx_perr, rx_ferr, rx_ignored);\n`endif\n\twire\tcts_n;\n\tassign cts_n = 1'b0;\n\n\twire\ttx_busy;\n`ifdef\tUSE_LITE_UART\n\ttxuartlite #(24'd868)\n\t\ttransmitter(i_clk, rx_stb, rx_data, o_uart_tx, tx_busy);\n`else\n\ttxuart\ttransmitter(i_clk, pwr_reset, i_setup, rx_break,\n\t\t\trx_stb, rx_data, rts, o_uart_tx, tx_busy);\n`endif\n\t`endif\tendmodule\n\n",
        "module_name": "unknown_module",
        "module_hash": "51e85de764699a414ef857c1a81c9b7e",
        "dataset_index": 21932
      },
      "any_edge_detector_e711b03e": {
        "rtl_code": "module any_edge_detector (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    anyedge <= (in ^ prev_in) & in;\n    prev_in <= in;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nany_edge_detector detector (\n    .clk(clk),\n    .in(in),\n    .anyedge(anyedge)\n);\n\nendmodule",
        "module_name": "any_edge_detector",
        "module_hash": "e711b03ebcc1616ae9e770d8b3f520c9",
        "dataset_index": 20508
      },
      "regfile_7e893e30": {
        "rtl_code": "\nmodule regfile (regA, regB, RegWrite, regTEST,Wdat,regW, clk, Adat, Bdat,resetn,TESTdat);\n    input clk,RegWrite,resetn;\t\tinput [4:0] regA, regB, regW,regTEST;\tinput [31:0] Wdat;\t\t\toutput wire [31:0] Adat, Bdat,TESTdat;\t\treg [31:0] regfile [0:31];\n\t reg [5:0] i;\n\t assign  Adat=regfile[regA];\n\t assign  Bdat=regfile[regB];\n\t assign  TESTdat=regfile[regTEST];\n\t always @(posedge clk) begin\n        if (resetn) for (i=0;i<32;i=i+1) regfile[i]=0; else\n\t\tif(RegWrite) regfile[regW]=(regW==0)?32'b0:Wdat;\n\tend\nendmodule\n\n",
        "module_name": "regfile",
        "module_hash": "7e893e30005995df221a61e8c31b4323",
        "dataset_index": 23989
      },
      "omsp_clock_mux_f8e87f14": {
        "rtl_code": "module  omsp_clock_mux (\n\nclk_out,                   clk_in0,                   clk_in1,                   reset,                     scan_mode,                 select_in                  );\n\noutput         clk_out;        input          clk_in0;        input          clk_in1;        input          reset;          input          scan_mode;      input          select_in;      wire in0_select;\nreg  in0_select_s;\nreg  in0_select_ss;\nwire in0_enable;\n\nwire in1_select;\nreg  in1_select_s;\nreg  in1_select_ss;\nwire in1_enable;\n\nwire clk_in0_inv;\nwire clk_in1_inv;\nwire clk_in0_scan_fix_inv;\nwire clk_in1_scan_fix_inv;\nwire gated_clk_in0;\nwire gated_clk_in1;\n\n`ifdef SCAN_REPAIR_INV_CLOCKS\n   omsp_scan_mux scan_mux_repair_clk_in0_inv (.scan_mode(scan_mode), .data_in_scan(clk_in0), .data_in_func(~clk_in0), .data_out(clk_in0_scan_fix_inv));\n   omsp_scan_mux scan_mux_repair_clk_in1_inv (.scan_mode(scan_mode), .data_in_scan(clk_in1), .data_in_func(~clk_in1), .data_out(clk_in1_scan_fix_inv));\n`else\n   assign clk_in0_scan_fix_inv = ~clk_in0;\n   assign clk_in1_scan_fix_inv = ~clk_in1;\n`endif\n\nassign in0_select = ~select_in & ~in1_select_ss;\n\nalways @ (posedge clk_in0_scan_fix_inv or posedge reset)\n  if (reset) in0_select_s  <=  1'b1;\n  else       in0_select_s  <=  in0_select;\n\nalways @ (posedge clk_in0              or posedge reset)\n  if (reset) in0_select_ss <=  1'b1;\n  else       in0_select_ss <=  in0_select_s;\n\nassign in0_enable = in0_select_ss | scan_mode;\n\n\nassign in1_select =  select_in & ~in0_select_ss;\n\nalways @ (posedge clk_in1_scan_fix_inv or posedge reset)\n  if (reset) in1_select_s  <=  1'b0;\n  else       in1_select_s  <=  in1_select;\n\nalways @ (posedge clk_in1     or posedge reset)\n  if (reset) in1_select_ss <=  1'b0;\n  else       in1_select_ss <=  in1_select_s;\n\nassign in1_enable = in1_select_ss & ~scan_mode;\n\n\nassign clk_in0_inv   = ~clk_in0;\nassign clk_in1_inv   = ~clk_in1;\n\nassign gated_clk_in0 = ~(clk_in0_inv & in0_enable);\nassign gated_clk_in1 = ~(clk_in1_inv & in1_enable);\n\n\nassign clk_out       =  (gated_clk_in0 & gated_clk_in1);\n\n\n\nendmodule ",
        "module_name": "omsp_clock_mux",
        "module_hash": "f8e87f14170d827e2fa68519cf20d3de",
        "dataset_index": 25498
      },
      "barrel_shift_and_separate_99b1d286": {
        "rtl_code": "module barrel_shift_and_separate(\n    input wire [15:0] in,\n    input wire [3:0] shift_amt,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n\n    // 16-bit barrel shifter\n    reg [15:0] shifted_in;\n    always @(*) begin\n        shifted_in = (shift_amt == 0) ? in :\n                     (shift_amt == 1) ? {in[14:0], 1'b0} :\n                     (shift_amt == 2) ? {in[13:0], 2'b00} :\n                     (shift_amt == 3) ? {in[12:0], 3'b000} :\n                     (shift_amt == 4) ? {in[11:0], 4'b0000} :\n                     (shift_amt == 5) ? {in[10:0], 5'b00000} :\n                     (shift_amt == 6) ? {in[9:0], 6'b000000} :\n                     (shift_amt == 7) ? {in[8:0], 7'b0000000} :\n                     (shift_amt == 8) ? {in[7:0], 8'b00000000} :\n                     (shift_amt == 9) ? {in[6:0], 9'b000000000} :\n                     (shift_amt == 10) ? {in[5:0], 10'b0000000000} :\n                     (shift_amt == 11) ? {in[4:0], 11'b00000000000} :\n                     (shift_amt == 12) ? {in[3:0], 12'b000000000000} :\n                     (shift_amt == 13) ? {in[2:0], 13'b0000000000000} :\n                     (shift_amt == 14) ? {in[1:0], 14'b00000000000000} :\n                     {in[0], 15'b000000000000000};\n    end\n\n    // Separate 16-bit input into two 8-bit outputs\n    assign out_hi = shifted_in[15:8];\n    assign out_lo = shifted_in[7:0];\n\nendmodule",
        "module_name": "barrel_shift_and_separate",
        "module_hash": "99b1d28670a6140b4176726c2787634a",
        "dataset_index": 10472
      },
      "full_adder_4fcd8d97": {
        "rtl_code": "module full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n    // Implementing full adder using structural verilog\n    wire w1, w2, w3;\n    xor x1(w1, A, B);\n    xor x2(S, w1, Cin);\n    and a1(w2, A, B);\n    and a2(w3, w1, Cin);\n    or o1(Cout, w2, w3);\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n    wire c0, c1, c2;\n    full_adder fa0(A[0], B[0], Cin, S[0], c0);\n    full_adder fa1(A[1], B[1], c0, S[1], c1);\n    full_adder fa2(A[2], B[2], c1, S[2], c2);\n    full_adder fa3(A[3], B[3], c2, S[3], Cout);\nendmodule",
        "module_name": "full_adder",
        "module_hash": "4fcd8d9768cea05657a8c67fc80fb8d2",
        "dataset_index": 2181
      },
      "driver_b7312272": {
        "rtl_code": "module driver (clk, state, enable);\n\n\ninput clk;\ninput [6:0] state; output enable; reg enableReg; reg [2:0] settleTimeCntr;\nreg [4:0] enableOnCntr;\n\nreg settleTimeFlag; reg enableOnFlag; reg [6:0] stateLast; parameter SETTLE_TIME=3'b111;\nparameter ENABLE_ON_TIME=5'b11111;\n\ninitial begin\n\tstateLast=7'b0; settleTimeCntr=3'b0; enableOnCntr=5'b0; settleTimeFlag=1'b0; enableOnFlag=1'b0; enableReg=1'b0; end\n\nalways @(posedge clk) begin\n\tif(|(stateLast - state)) begin settleTimeCntr=3'b0;\n\t\t\n\t\tsettleTimeFlag=1'b1;\n\t\t\n\t\tstateLast=state; end\n\t\n\tif(settleTimeFlag) begin\n\t\tif(settleTimeCntr==SETTLE_TIME) begin\n\t\t\tsettleTimeFlag=1'b0; enableOnFlag=1'b1; settleTimeCntr=3'b0; enableOnCntr=5'b0;\n\t\tend else settleTimeCntr=settleTimeCntr+3'b1; end\n\t\n\tif(enableOnFlag) begin\n\t\tif(enableOnCntr==ENABLE_ON_TIME) begin\n\t\t\tenableReg=1'b0; enableOnFlag=1'b0; enableOnCntr=5'b0; end else begin\n\t\t\tenableReg=1'b1; enableOnCntr=enableOnCntr+5'b1; end\n\tend\nend\n\nassign enable=enableReg; endmodule\n",
        "module_name": "driver",
        "module_hash": "b73122722f6340b1b2377e9bb5dc221f",
        "dataset_index": 19247
      },
      "sequence_counter_5e93a107": {
        "rtl_code": "\nmodule sequence_counter (\n  input clk,\n  input reset,\n  input [9:0] data,\n  output [3:0] count\n);\n\n  reg [2:0] seq;\n  reg [3:0] cnt;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      seq <= 3'b0;\n      cnt <= 4'b0;\n    end else begin\n      seq <= {seq[1:0], data[0]};\n      if (seq == 3'b101) begin\n        cnt <= cnt + 1;\n      end\n    end\n  end\n  \n  assign count = cnt;    // Remove the semicolon here\n  \nendmodule\n",
        "module_name": "sequence_counter",
        "module_hash": "5e93a10775a2f9a43831aeb7a138e5c8",
        "dataset_index": 14262
      },
      "add16_996fdc8c": {
        "rtl_code": "\nmodule add16 (\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\n    wire [16:0] temp_sum;\n    wire carry_out;\n\n    assign {carry_out, temp_sum} = a + b + cin;\n    assign sum = {1'b0, temp_sum[15:1]};\n    assign cout = carry_out;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [15:0] in1,\n    input [15:0] in2,\n    input enable_mult,\n    output reg [31:0] out\n);\n\n    wire [15:0] adder1_out;\n    wire [15:0] adder2_out;\n    wire [31:0] mult_out = { {16{1'b0}}, in1 & in2 };\n\n    wire adder1_cout;\n    wire adder2_cout;\n\n    add16 adder1(.a(in1), .b(in2), .cin(1'b0), .sum(adder1_out), .cout(adder1_cout));\n    add16 adder2(.a(adder1_out), .b(in2), .cin(adder1_cout), .sum(adder2_out), .cout(adder2_cout));\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            out <= 0;\n        end else begin\n            if (enable_mult) begin\n                out <= mult_out;\n            end else begin\n                out <= { adder2_out, adder2_cout };\n            end\n        end\n    end\n\nendmodule",
        "module_name": "add16",
        "module_hash": "996fdc8cfa169c88217ba68621f16755",
        "dataset_index": 3020
      },
      "binary_to_bcd_420d67d2": {
        "rtl_code": "\nmodule binary_to_bcd (\n    input [3:0] binary_in,\n    output reg [15:0] bcd_out\n);\n\nreg [3:0] bcd_temp;\nreg [3:0] binary_temp;\nreg [2:0] bcd_count;\n\nalways @ (*) begin\n    bcd_temp = 0;\n    bcd_count = 0;\n    binary_temp = binary_in;\n    for (bcd_count = 0; bcd_count < 4; bcd_count = bcd_count + 1) begin\n        if (binary_temp >= 4'b1010) begin\n            bcd_temp = bcd_temp + 4'b0001;\n            binary_temp = binary_temp - 4'b1010;\n        end\n        else if (binary_temp >= 4'b1000) begin\n            bcd_temp = bcd_temp + 4'b0001;\n            binary_temp = binary_temp - 4'b1000;\n        end\n        else if (binary_temp >= 4'b0100) begin\n            bcd_temp = bcd_temp + 4'b0010;\n            binary_temp = binary_temp - 4'b0100;\n        end\n        else if (binary_temp >= 4'b0010) begin\n            bcd_temp = bcd_temp + 4'b0010;\n            binary_temp = binary_temp - 4'b0010;\n        end\n        else if (binary_temp >= 4'b0001) begin\n            bcd_temp = bcd_temp + 4'b0100;\n            binary_temp = binary_temp - 4'b0001;\n        end\n    end\nend\n\nalways @ (bcd_count) begin\n    case (bcd_count)\n        3'b000: bcd_out = {8'b0, bcd_temp};\n        3'b001: bcd_out = {7'b0, bcd_temp};\n        3'b010: bcd_out = {6'b0, bcd_temp};\n        3'b011: bcd_out = {5'b0, bcd_temp};\n        3'b100: bcd_out = {4'b0, bcd_temp};\n        default: bcd_out = 16'b0;\n    endcase\nend\n\nendmodule",
        "module_name": "binary_to_bcd",
        "module_hash": "420d67d20107f326c3a4f609f00e4be6",
        "dataset_index": 7512
      },
      "signed_multiplier_6cd75317": {
        "rtl_code": "module signed_multiplier(\n    input clk, // clock input\n    input rst, // reset input\n    input load_b_i, // load input\n    input signed [25:0] Data_A_i, // input A\n    input signed [25:0] Data_B_i, // input B\n    output signed [51:0] sgf_result_o // output result\n);\n\n    reg signed [25:0] reg_Data_B_i; // register to store input B\n    reg signed [51:0] reg_sgf_result_o; // register to store result\n\n    always @(posedge clk) begin\n        if (rst) begin\n            reg_Data_B_i <= 0;\n            reg_sgf_result_o <= 0;\n        end else begin\n            if (load_b_i) begin\n                reg_Data_B_i <= Data_B_i;\n            end\n            reg_sgf_result_o <= $signed(Data_A_i) * $signed(reg_Data_B_i);\n        end\n    end\n\n    assign sgf_result_o = reg_sgf_result_o;\n\nendmodule",
        "module_name": "signed_multiplier",
        "module_hash": "6cd75317f1ee330f6fdd78fd9bbfd466",
        "dataset_index": 5743
      },
      "mux4to1_805ac8cc": {
        "rtl_code": "module mux4to1(\n    input [3:0] data_in,\n    input [1:0] sel,\n    output reg data_out\n);\n\nalways @(*) begin\n    case (sel)\n        2'b00: data_out = data_in[0];\n        2'b01: data_out = data_in[1];\n        2'b10: data_out = data_in[2];\n        2'b11: data_out = data_in[3];\n    endcase\nend\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "805ac8cc362224645f4e4a4d181cf147",
        "dataset_index": 21054
      },
      "sha256_W_6a3db12f": {
        "rtl_code": "\n\nmodule sha256_W (\n    input clk,\n    input load_i,\n\t input busy_i,\n\t input [511:0] data_i,\n    output [31:0] W_o\n);\n\n`define DATA_IDX(x) data_i[512 - (x * 32) - 1:512 - (x * 32) - 32]\n\nreg [31:0] W[15:0];\nreg [31:0] W_new00, W_new01, W_new02, W_new03, W_new04, W_new05, W_new06, W_new07;\nreg [31:0] W_new08, W_new09, W_new10, W_new11, W_new12, W_new13, W_new14, W_new15;\nreg [31:0] W_new;\nreg [31:0] h0, h1, h0_new, h1_new;\n\nalways @(posedge clk)\nbegin\t\n\tW[ 0] <= W_new00;\n\tW[ 1] <= W_new01;\n\tW[ 2] <= W_new02;\n\tW[ 3] <= W_new03;\n\tW[ 4] <= W_new04;\n\tW[ 5] <= W_new05;\n\tW[ 6] <= W_new06;\n\tW[ 7] <= W_new07;\n\tW[ 8] <= W_new08;\n\tW[ 9] <= W_new09;\n\tW[10] <= W_new10;\n\tW[11] <= W_new11;\n\tW[12] <= W_new12;\n\tW[13] <= W_new13;\n\tW[14] <= W_new14;\n\tW[15] <= W_new15;\n\t\t\n\th0 <= h0_new;\n\th1 <= h1_new;\nend\n\nassign W_o = W[0];\n\nalways @*\nbegin : W_update\n\treg [31:0] w_0, w_1, w_9, w_14, d0, d1;\n\t\n\tW_new00 = 0;\n\tW_new01 = 0;\n\tW_new02 = 0;\n\tW_new03 = 0;\n\tW_new04 = 0;\n\tW_new05 = 0;\n\tW_new06 = 0;\n\tW_new07 = 0;\n\tW_new08 = 0;\n\tW_new09 = 0;\n\tW_new10 = 0;\n\tW_new11 = 0;\n\tW_new12 = 0;\n\tW_new13 = 0;\n\tW_new14 = 0;\n\tW_new15 = 0;\n\n\tw_0 = W[1];\n\tw_1 = W[2];\n\tw_9 = W[10];\n\tw_14 = W[15];\n\t\n\tW_new = h0 + h1;\n\n\tif(load_i)\n\tbegin\n\t\tW_new00 = `DATA_IDX( 0);\n\t\tW_new01 = `DATA_IDX( 1);\n\t\tW_new02 = `DATA_IDX( 2);\n\t\tW_new03 = `DATA_IDX( 3);\n\t\tW_new04 = `DATA_IDX( 4);\n\t\tW_new05 = `DATA_IDX( 5);\n\t\tW_new06 = `DATA_IDX( 6);\n\t\tW_new07 = `DATA_IDX( 7);\n\t\tW_new08 = `DATA_IDX( 8);\n\t\tW_new09 = `DATA_IDX( 9);\n\t\tW_new10 = `DATA_IDX(10);\n\t\tW_new11 = `DATA_IDX(11);\n\t\tW_new12 = `DATA_IDX(12);\n\t\tW_new13 = `DATA_IDX(13);\n\t\tW_new14 = `DATA_IDX(14);\n\t\tW_new15 = `DATA_IDX(15);\n\t\t\n\t\tw_0 = `DATA_IDX(0);\n\t\tw_1 = `DATA_IDX(1);\n\t\tw_9 = `DATA_IDX(9);\n\t\tw_14 = `DATA_IDX(14);\n\tend\n\telse if(busy_i)\n\tbegin\n\t\tW_new00 = W[ 1];\n\t\tW_new01 = W[ 2];\n\t\tW_new02 = W[ 3];\n\t\tW_new03 = W[ 4];\n\t\tW_new04 = W[ 5];\n\t\tW_new05 = W[ 6];\n\t\tW_new06 = W[ 7];\n\t\tW_new07 = W[ 8];\n\t\tW_new08 = W[ 9];\n\t\tW_new09 = W[10];\n\t\tW_new10 = W[11];\n\t\tW_new11 = W[12];\n\t\tW_new12 = W[13];\n\t\tW_new13 = W[14];\n\t\tW_new14 = W[15];\n\t\tW_new15 = W_new;\n\tend\n\t\n\td0 = {w_1[ 6: 0], w_1[31: 7]} ^ {w_1[17: 0], w_1[31:18]} ^ {3'h0, w_1[31: 3]};\n\td1 = {w_14[16: 0], w_14[31:17]} ^ {w_14[18: 0], w_14[31:19]} ^ {10'h0, w_14[31:10]};\n\t\n\th0_new = d0 + w_0;\n\th1_new = d1 + w_9;\nend\n\nendmodule\n\n",
        "module_name": "sha256_W",
        "module_hash": "6a3db12fa67fb837d3e2af464796ec30",
        "dataset_index": 25458
      },
      "mux2to1_4d82fcdd": {
        "rtl_code": "module mux2to1 (in0, in1, ctrl, out);\n  input [3:0] in0;\n  input [3:0] in1;\n  input ctrl;\n  output [3:0] out;\n\n  assign out = (ctrl == 1'b0) ? in0 : in1;\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "4d82fcdde95e254b9c45a6198cea0afd",
        "dataset_index": 10169
      },
      "sky130_fd_sc_ls__o32ai_14168a4a": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o32ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out ;\n    wire nor1_out ;\n    wire or0_out_Y;\n\n    nor nor0 (nor0_out , A3, A1, A2        );\n    nor nor1 (nor1_out , B1, B2            );\n    or  or0  (or0_out_Y, nor1_out, nor0_out);\n    buf buf0 (Y        , or0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o32ai",
        "module_hash": "14168a4a2b9977a1941821c9cc27ac78",
        "dataset_index": 5897
      },
      "sky130_fd_sc_ms__nor2_1_0991d5f5": {
        "rtl_code": "\nmodule sky130_fd_sc_ms__nor2_1 (\n    output Y,\n    input A,\n    input B,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    wire w1;\n    sky130_fd_sc_ms__a211oi_1 U1 (\n        .Y(w1),\n        .A1(A),\n        .A2(B),\n        .B1(VPWR),\n        .C1(VNB),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n    sky130_fd_sc_ms__inv_1 U2 (\n        .Y(Y),\n        .A(w1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n\nmodule sky130_fd_sc_ms__inv_1 (\n    output Y,\n    input A,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    sky130_fd_sc_ms__a211oi_1 U1 (\n        .Y(Y),\n        .A1(A),\n        .A2(VPWR),\n        .B1(VGND),\n        .C1(VNB),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n\nmodule sky130_fd_sc_ms__a211oi_1 (\n    output Y,\n    input A1,\n    input A2,\n    input B1,\n    input C1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    wire NMOS_TB;\n    wire NMOS_BA;\n    wire NMOS_AB;\n    wire PMOS_BC;\n\n    assign NMOS_TB = B1 & C1;\n    assign NMOS_BA = A1 & B1;\n    assign NMOS_AB = A1 & A2;\n    assign PMOS_BC = B1 & C1;\n\n    assign Y = (NMOS_AB | (NMOS_BA & ~PMOS_BC)) | (NMOS_TB & ~A2);\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__nor2_1",
        "module_hash": "0991d5f59fde01690512872521b909f3",
        "dataset_index": 20027
      },
      "my__5a5a67de": {
        "rtl_code": "\nmodule my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    assign X = (A1 & A2) | ~B1_N;\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "5a5a67de240861de7e355d8466f9b82e",
        "dataset_index": 6139
      },
      "start_for_CvtColowdI_shiftReg_258cba5f": {
        "rtl_code": "module start_for_CvtColowdI_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 32'd1;\nparameter ADDR_WIDTH = 32'd2;\nparameter DEPTH = 32'd3;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\n    begin\n        if (ce)\n        begin\n            for (i=0;i<DEPTH-1;i=i+1)\n                SRL_SIG[i+1] <= SRL_SIG[i];\n            SRL_SIG[0] <= data;\n        end\n    end\n\nassign q = SRL_SIG[a];\n\nendmodule",
        "module_name": "start_for_CvtColowdI_shiftReg",
        "module_hash": "258cba5fa0036ebcd45209458498402e",
        "dataset_index": 20154
      },
      "axi_basic_tx_pipeline #_280cb2c5": {
        "rtl_code": "\n\nmodule axi_basic_tx_pipeline #(\n  parameter C_DATA_WIDTH = 128,           parameter C_PM_PRIORITY = \"FALSE\",      parameter TCQ = 1,                      parameter REM_WIDTH  = (C_DATA_WIDTH == 128) ? 2 : 1, parameter STRB_WIDTH = C_DATA_WIDTH / 8               ) (\n  input      [C_DATA_WIDTH-1:0] s_axis_tx_tdata,     input                         s_axis_tx_tvalid,    output                        s_axis_tx_tready,    input        [STRB_WIDTH-1:0] s_axis_tx_tstrb,     input                         s_axis_tx_tlast,     input                   [3:0] s_axis_tx_tuser,     output     [C_DATA_WIDTH-1:0] trn_td,              output                        trn_tsof,            output                        trn_teof,            output                        trn_tsrc_rdy,        input                         trn_tdst_rdy,        output                        trn_tsrc_dsc,        output        [REM_WIDTH-1:0] trn_trem,            output                        trn_terrfwd,         output                        trn_tstr,            output                        trn_tecrc_gen,       input                         trn_lnk_up,          input                         tready_thrtl,        input                         user_clk,            input                         user_rst             );\n\n\nreg  [C_DATA_WIDTH-1:0] reg_tdata;\nreg                     reg_tvalid;\nreg    [STRB_WIDTH-1:0] reg_tstrb;\nreg               [3:0] reg_tuser;\nreg                     reg_tlast;\nreg                     reg_tready;\n\nreg                     trn_in_packet;\nreg                     axi_in_packet;\nreg                     flush_axi;\nwire                    disable_trn;\nreg                     reg_disable_trn;\n\nwire                    axi_beat_live  = s_axis_tx_tvalid && s_axis_tx_tready;\nwire                    axi_end_packet = axi_beat_live && s_axis_tx_tlast;\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : td_DW_swap_128\n    assign trn_td = {reg_tdata[31:0],\n                     reg_tdata[63:32],\n                     reg_tdata[95:64],\n                     reg_tdata[127:96]};\n  end\n  else if(C_DATA_WIDTH == 64) begin : td_DW_swap_64\n    assign trn_td = {reg_tdata[31:0], reg_tdata[63:32]};\n  end\n  else begin : td_DW_swap_32\n    assign trn_td = reg_tdata;\n  end\nendgenerate\n\n\nassign trn_tsof = reg_tvalid && !trn_in_packet;\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    trn_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(trn_tsof && trn_tsrc_rdy && trn_tdst_rdy && !trn_teof) begin\n      trn_in_packet <= #TCQ 1'b1;\n    end\n    else if((trn_in_packet && trn_teof && trn_tsrc_rdy) || !trn_lnk_up) begin\n      trn_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    axi_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(axi_beat_live && !s_axis_tx_tlast) begin\n      axi_in_packet <= #TCQ 1'b1;\n    end\n    else if(axi_beat_live) begin\n      axi_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\ngenerate\n  if(C_PM_PRIORITY == \"TRUE\") begin : pm_priority_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b1;\n      end\n      else begin\n        if(!trn_lnk_up)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(!flush_axi && s_axis_tx_tready) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn;\n  end\n\n  else begin : thrtl_ctl_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b0;\n      end\n      else begin\n        if(axi_in_packet && !trn_lnk_up && !axi_end_packet)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(axi_end_packet) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn || !trn_lnk_up;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : tstrb_to_trem_128\n    wire   axi_DW_1    = reg_tstrb[7];\n    wire   axi_DW_2    = reg_tstrb[11];\n    wire   axi_DW_3    = reg_tstrb[15];\n    assign trn_trem[1] = axi_DW_2;\n    assign trn_trem[0] = axi_DW_3 || (axi_DW_1 && !axi_DW_2);\n  end\n  else if(C_DATA_WIDTH == 64) begin : tstrb_to_trem_64\n    assign trn_trem    = reg_tstrb[7];\n  end\n  else begin : tstrb_to_trem_32\n    assign trn_trem    = 1'b0;\n  end\nendgenerate\n\n\nassign trn_teof      = reg_tlast;\nassign trn_tecrc_gen = reg_tuser[0];\nassign trn_terrfwd   = reg_tuser[1];\nassign trn_tstr      = reg_tuser[2];\nassign trn_tsrc_dsc  = reg_tuser[3];\n\n\ngenerate\n  reg reg_tsrc_rdy;\n\n  if(C_PM_PRIORITY == \"FALSE\") begin : throttle_ctl_pipeline\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata        <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid       <= #TCQ 1'b0;\n        reg_tstrb        <= #TCQ {STRB_WIDTH{1'b0}};\n        reg_tlast        <= #TCQ 1'b0;\n        reg_tuser        <= #TCQ 4'h0;\n        reg_tsrc_rdy     <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdata        <= #TCQ s_axis_tx_tdata;\n        reg_tvalid       <= #TCQ s_axis_tx_tvalid;\n        reg_tstrb        <= #TCQ s_axis_tx_tstrb;\n        reg_tlast        <= #TCQ s_axis_tx_tlast;\n        reg_tuser        <= #TCQ s_axis_tx_tuser;\n\n        reg_tsrc_rdy     <= #TCQ axi_beat_live && !disable_trn;\n      end\n    end\n\n    assign trn_tsrc_rdy = reg_tsrc_rdy;\n\n    assign s_axis_tx_tready = tready_thrtl;\n  end\n\n  else begin : pm_prioity_pipeline\n    reg  [C_DATA_WIDTH-1:0] tdata_prev;\n    reg                     tvalid_prev;\n    reg    [STRB_WIDTH-1:0] tstrb_prev;\n    reg                     tlast_prev;\n    reg               [3:0] tuser_prev;\n    reg                     reg_tdst_rdy;\n\n    wire                    data_hold;\n    reg                     data_prev;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        tdata_prev   <= #TCQ {C_DATA_WIDTH{1'b0}};\n        tvalid_prev  <= #TCQ 1'b0;\n        tstrb_prev   <= #TCQ {STRB_WIDTH{1'b0}};\n        tlast_prev   <= #TCQ 1'b0;\n        tuser_prev   <= #TCQ 4'h 0;\n      end\n      else begin\n        if(!s_axis_tx_tready) begin\n          tdata_prev   <= #TCQ tdata_prev;\n          tvalid_prev  <= #TCQ tvalid_prev;\n          tstrb_prev   <= #TCQ tstrb_prev;\n          tlast_prev   <= #TCQ tlast_prev;\n          tuser_prev   <= #TCQ tuser_prev;\n        end\n        else begin\n          tdata_prev   <= #TCQ s_axis_tx_tdata;\n          tvalid_prev  <= #TCQ s_axis_tx_tvalid;\n          tstrb_prev   <= #TCQ s_axis_tx_tstrb;\n          tlast_prev   <= #TCQ s_axis_tx_tlast;\n          tuser_prev   <= #TCQ s_axis_tx_tuser;\n        end\n      end\n    end\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata  <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid <= #TCQ 1'b0;\n        reg_tstrb  <= #TCQ {STRB_WIDTH{1'b0}};\n        reg_tlast  <= #TCQ 1'b0;\n        reg_tuser  <= #TCQ 4'h0;\n\n        reg_tdst_rdy <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdst_rdy <= #TCQ trn_tdst_rdy;\n\n        if(!data_hold) begin\n          if(data_prev) begin\n            reg_tdata  <= #TCQ tdata_prev;\n            reg_tvalid <= #TCQ tvalid_prev;\n            reg_tstrb  <= #TCQ tstrb_prev;\n            reg_tlast  <= #TCQ tlast_prev;\n            reg_tuser  <= #TCQ tuser_prev;\n          end\n\n          else begin\n            reg_tdata  <= #TCQ s_axis_tx_tdata;\n            reg_tvalid <= #TCQ s_axis_tx_tvalid;\n            reg_tstrb  <= #TCQ s_axis_tx_tstrb;\n            reg_tlast  <= #TCQ s_axis_tx_tlast;\n            reg_tuser  <= #TCQ s_axis_tx_tuser;\n          end\n        end\n        end\n    end\n\n\n    assign data_hold = trn_tsrc_rdy && !trn_tdst_rdy;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        data_prev <= #TCQ 1'b0;\n      end\n      else begin\n        data_prev <= #TCQ data_hold;\n      end\n    end\n\n\n    assign trn_tsrc_rdy = reg_tvalid && !disable_trn;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tready <= #TCQ 1'b0;\n      end\n      else begin\n        if(flush_axi && !axi_end_packet) begin\n          reg_tready <= #TCQ 1'b1;\n        end\n\n        else if(trn_lnk_up) begin\n          reg_tready <= #TCQ trn_tdst_rdy || !trn_tsrc_rdy;\n        end\n\n        else begin\n          reg_tready <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign s_axis_tx_tready = reg_tready;\n  end\n\n\n  always @(posedge user_clk) begin\n    if(user_rst) begin\n      flush_axi    <= #TCQ 1'b0;\n    end\n    else begin\n      if(axi_in_packet && !trn_lnk_up && !axi_end_packet) begin\n        flush_axi <= #TCQ 1'b1;\n      end\n\n      else if(axi_end_packet) begin\n        flush_axi <= #TCQ 1'b0;\n      end\n    end\n  end\nendgenerate\n\nendmodule\n",
        "module_name": "axi_basic_tx_pipeline #",
        "module_hash": "280cb2c50c7990423adf4464caab2de5",
        "dataset_index": 23195
      },
      "WDT_e9c75eec": {
        "rtl_code": "module WDT (\n  input clk, rst,\n  output wdt\n);\n\n  parameter t = 10; // timeout period in clock cycles\n  \n  reg [31:0] counter;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      counter <= 0;\n    end\n    else begin\n      counter <= counter + 1;\n    end\n  end\n  \n  assign wdt = (counter >= t) ? 1'b1 : 1'b0;\n  \nendmodule",
        "module_name": "WDT",
        "module_hash": "e9c75eec54a51c29edf042927b480329",
        "dataset_index": 17112
      },
      "rcn_filter_8c2be3eb": {
        "rtl_code": "\n\n\nmodule rcn_filter\n(\n    input clk,\n    input rst,\n\n    input [68:0] rcn_in,\n    output [68:0] rcn_out,\n    \n    output reg filtered\n);\n    parameter START_0 = 1;\n    parameter END_0 = 0;\n    parameter START_1 = 1;\n    parameter END_1 = 0;\n    parameter START_2 = 1;\n    parameter END_2 = 0;\n    parameter START_3 = 1;\n    parameter END_3 = 0;\n\n    reg [68:0] rin;\n    reg [68:0] rout;\n    \n    assign rcn_out = rout;\n    \n    wire [23:0] addr_start_0 = START_0;\n    wire [23:0] addr_end_0 = END_0;\n    wire filter_0 = (rin[55:34] >= addr_start_0) && (rin[55:34] <= addr_end_0);\n    \n    wire [23:0] addr_start_1 = START_1;\n    wire [23:0] addr_end_1 = END_1;\n    wire filter_1 = (rin[55:34] >= addr_start_1) && (rin[55:34] <= addr_end_1);\n    \n    wire [23:0] addr_start_2 = START_2;\n    wire [23:0] addr_end_2 = END_2;\n    wire filter_2 = (rin[55:34] >= addr_start_2) && (rin[55:34] <= addr_end_2);\n    \n    wire [23:0] addr_start_3 = START_3;\n    wire [23:0] addr_end_3 = END_3;\n    wire filter_3 = (rin[55:34] >= addr_start_3) && (rin[55:34] <= addr_end_3);\n    \n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rout <= 69'd0;\n            filtered <= 1'b0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rout <= (filter_0 || filter_1 || filter_2 || filter_3) ? 69'd0 : rcn_in;\n            filtered <= (filter_0 || filter_1 || filter_2 || filter_3);\n        end\n    \n\nendmodule\n",
        "module_name": "rcn_filter",
        "module_hash": "8c2be3eb25ec361e01efb38b7f4e9e52",
        "dataset_index": 23416
      },
      "register_4bit_2ca7c6cc": {
        "rtl_code": "module register_4bit (\n    input clk,\n    input reset,\n    input enable,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            data_out <= 4'b0;\n        end else if (enable) begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule",
        "module_name": "register_4bit",
        "module_hash": "2ca7c6cc29ce0c813ed5908b3ce96a67",
        "dataset_index": 17830
      },
      "mux_2to1_912b39ab": {
        "rtl_code": "module mux_2to1 (\n    input A,\n    input B,\n    input Sel,\n    output Y\n);\n\n    wire and_out, or_out;\n\n    // Implement the AND gate\n    and_gate and_gate_inst (\n        .A(A),\n        .B(Sel),\n        .Z(and_out)\n    );\n\n    // Implement the OR gate\n    or_gate or_gate_inst (\n        .A(B),\n        .B(and_out),\n        .Z(or_out)\n    );\n\n    // Assign the output\n    assign Y = or_out;\n\nendmodule\n\nmodule and_gate (\n    input A,\n    input B,\n    output Z\n);\n\n    assign Z = A & B;\n\nendmodule\n\nmodule or_gate (\n    input A,\n    input B,\n    output Z\n);\n\n    assign Z = A | B;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "912b39ab5cc117cda50729c09f00d3cf",
        "dataset_index": 10728
      },
      "nand4_pwrgood_39e8f7fb": {
        "rtl_code": "\nmodule nand4_pwrgood (\n    Y,\n    A,\n    B,\n    C,\n    VDD,\n    VSS\n);\n\n    // Module ports\n    output  Y   ;\n    input   A   ;\n    input   B   ;\n    input   C   ;\n    input   VDD ;\n    input   VSS ;\n\n    // Local signals\n    wire nand0_out_Y      ;\n    wire nand1_out_Y      ;\n    wire nand2_out_Y      ;\n\n    //                                 Name         Output             Other arguments\n    nand                               nand0       (nand0_out_Y      , B, A, C                );\n    nand                               nand1       (nand1_out_Y      , nand0_out_Y, nand0_out_Y);\n    nand                               nand2       (nand2_out_Y      , nand1_out_Y, nand1_out_Y);\n    not                                inv0         (Y                , nand2_out_Y);\n\nendmodule\n",
        "module_name": "nand4_pwrgood",
        "module_hash": "39e8f7fb12daad2525a5717304cdccf3",
        "dataset_index": 20468
      },
      "binary_counter_fca8dc26": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input reset,\n    output reg [3:0] q\n    );\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "fca8dc268c88476a6e64664553aa2684",
        "dataset_index": 1507
      },
      "sub_8f0029e7": {
        "rtl_code": "\nmodule sub (\n    // Outputs\n    outy_w92, outz_w22,\n    // Inputs\n    clk, inw_w31, inx_w11\n    );\n\n    input clk;\n    input        inw_w31;\n    input [60:0] inx_w11;\n    output [91:0] outy_w92;\n    output [21:0] outz_w22;\n\n    wire [29:0] outc_w30;\n    wire [72:0] outd_w73;\nendmodule\n\nmodule t (\n    // Outputs\n    outc_w30,\n    outd_w73,\n    // Inputs\n    clk,\n    ina_w1,\n    inb_w61\n    );\n\n    input clk;\n    input ina_w1;\n    input [60:0] inb_w61;\n    output [29:0] outc_w30;\n    output [72:0] outd_w73;\n\n    assign outc_w30 = ina_w1 - inb_w61[30:0];\n    assign outd_w73 = ina_w1 * inb_w61;\n\nendmodule\n",
        "module_name": "sub",
        "module_hash": "8f0029e7cdf3cfa94b3628d6b587f841",
        "dataset_index": 20011
      },
      "four_bit_adder_74a1a1a0": {
        "rtl_code": "\nmodule four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire c0, c1, c2;\n\n    full_adder U0(\n        .a(A[0]),\n        .b(B[0]),\n        .cin(Cin),\n        .sum(S[0]),\n        .cout(c0)\n    );\n\n    full_adder U1(\n        .a(A[1]),\n        .b(B[1]),\n        .cin(c0),\n        .sum(S[1]),\n        .cout(c1)\n    );\n\n    full_adder U2(\n        .a(A[2]),\n        .b(B[2]),\n        .cin(c1),\n        .sum(S[2]),\n        .cout(c2)\n    );\n\n    full_adder U3(\n        .a(A[3]),\n        .b(B[3]),\n        .cin(c2),\n        .sum(S[3]),\n        .cout(Cout)\n    );\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a^b^cin;\n    assign cout = (a&b) | (a&cin) | (b&cin);\nendmodule\n",
        "module_name": "four_bit_adder",
        "module_hash": "74a1a1a0c9ac86fc460343ec0f16cac8",
        "dataset_index": 20262
      },
      "decoder_6b6b905f": {
        "rtl_code": "module decoder(\n    input clk,\n    input [63:0] probe0,\n    input [63:0] probe1,\n    input [0:0] probe2,\n    input [0:0] probe3,\n    input [0:0] probe4,\n    input [0:0] probe5,\n    input [0:0] probe6,\n    input [63:0] probe7,\n    input [0:0] probe8,\n    input [0:0] probe9,\n    input [0:0] probe10,\n    input [0:0] probe11,\n    input [63:0] probe12,\n    input [0:0] probe13,\n    input [0:0] probe14,\n    input [0:0] probe15,\n    input [0:0] probe16,\n    input [0:0] probe17,\n    input [7:0] probe18,\n    input [8:0] probe19,\n    input [0:0] probe20,\n    input [2:0] probe21,\n    input [2:0] probe22,\n    input [0:0] probe23,\n    input [7:0] probe24,\n    output reg [63:0] output0,\n    output reg output1,\n    output reg [63:0] output2,\n    output reg [7:0] output3,\n    output reg [8:0] output4\n);\n\nalways @(posedge clk) begin\n    output0 <= {probe0, probe1};\n    output1 <= &{probe2, probe3, probe4, probe5, probe6};\n    output2 <= {probe7, probe12};\n    output3 <= {probe18, probe24};\n    output4 <= {probe19, probe21, probe22};\nend\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "6b6b905fceb731af3179d41c57d1e7d2",
        "dataset_index": 9724
      },
      "piso_shift_register_7732df1e": {
        "rtl_code": "module piso_shift_register (\n    input [3:0] parallel_in,\n    input clk,\n    input shift_enable,\n    input reset,\n    output serial_out\n);\n\n    reg [3:0] shift_reg;\n    reg serial_out_reg;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n            serial_out_reg <= 1'b0;\n        end else if (shift_enable) begin\n            shift_reg <= {shift_reg[2:0], parallel_in[0]};\n            serial_out_reg <= shift_reg[3];\n        end else begin\n            shift_reg <= shift_reg;\n            serial_out_reg <= shift_reg[3];\n        end\n    end\n    \n    assign serial_out = serial_out_reg;\n    \nendmodule",
        "module_name": "piso_shift_register",
        "module_hash": "7732df1e0a8d20f2e3737274ff6b3196",
        "dataset_index": 18002
      },
      "vga_linear_fml_dab690fd": {
        "rtl_code": "\n\nmodule vga_linear_fml (\n    input clk,\n    input rst,\n    \n    input enable,\n\n    output [17:1] fml_adr_o,\n    input  [15:0] fml_dat_i,\n    output        fml_stb_o,\n\n    input [9:0] h_count,\n    input [9:0] v_count,\n    input       horiz_sync_i,\n    input       video_on_h_i,\n    output      video_on_h_o,\n\n    output [7:0] color,\n    output       horiz_sync_o\n  );\n\n  reg [ 9:0] row_addr;\n  reg [ 6:0] col_addr;\n  reg [14:1] word_offset;\n  reg [ 1:0] plane_addr;\n  reg [ 1:0] plane_addr0;\n  reg [ 7:0] color_l;\n  \n  reg  [ 15:0] fml1_dat;\n  reg  [ 15:0] fml2_dat;\n  reg  [ 15:0] fml3_dat;\n  reg  [ 15:0] fml4_dat;\n  reg  [ 15:0] fml5_dat;\n  reg  [ 15:0] fml6_dat;\n  reg  [ 15:0] fml7_dat;\n  \n  reg [4:0] video_on_h;\n  reg [4:0] horiz_sync;\n  reg [18:0] pipe;  \n\n  assign fml_adr_o = { 1'b0, word_offset, plane_addr };\n  assign fml_stb_o = pipe[1];\n  \n  assign color = pipe[4] ? fml_dat_i[7:0] : color_l;    \n  \n  assign video_on_h_o = video_on_h[4];\n  assign horiz_sync_o = horiz_sync[4];\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        pipe <= 18'b0;    \n      end\n    else\n      if (enable)\n        begin\n          pipe <= { pipe[17:0], (h_count[3:0]==4'h0) };\n        end\n\n  always @(posedge clk)\n    if (enable)\n      begin\n        fml1_dat <= pipe[5]  ? fml_dat_i[15:0] : fml1_dat;\n        fml2_dat <= pipe[6]  ? fml_dat_i[15:0] : fml2_dat;\n        fml3_dat <= pipe[7]  ? fml_dat_i[15:0] : fml3_dat;\n        fml4_dat <= pipe[8]  ? fml_dat_i[15:0] : fml4_dat;\n        fml5_dat <= pipe[9]  ? fml_dat_i[15:0] : fml5_dat;\n        fml6_dat <= pipe[10] ? fml_dat_i[15:0] : fml6_dat;\n        fml7_dat <= pipe[11] ? fml_dat_i[15:0] : fml7_dat;\n      end\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        video_on_h <= 5'b0;\n      end\n    else\n      if (enable)\n        begin\n          video_on_h <= { video_on_h[3:0], video_on_h_i };\n        end\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        horiz_sync <= 5'b0;\n      end\n    else\n      if (enable)\n        begin\n          horiz_sync <= { horiz_sync[3:0], horiz_sync_i };\n        end\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        row_addr    <= 10'h0;\n        col_addr    <= 7'h0;\n        plane_addr0 <= 2'b00;\n        word_offset <= 14'h0;\n        plane_addr  <= 2'b00;\n      end\n    else\n      if (enable)\n        begin\n          row_addr    <= { v_count[8:1], 2'b00 } + v_count[8:1];\n          col_addr    <= h_count[9:3];\n          plane_addr0 <= h_count[2:1];\n\n          word_offset <= { row_addr + col_addr[6:4], col_addr[3:0] };\n          plane_addr  <= plane_addr0;\n        end\n \n always @(posedge clk)\n    if (rst)\n      begin\n        color_l <= 8'h0;\n      end\n    else\n      if (enable)\n        begin\n          if (pipe[4])\n            color_l <= fml_dat_i[7:0];\n          else\n          if (pipe[5])\n            color_l <= fml_dat_i[7:0];\n          else\n          if (pipe[7])\n            color_l <= fml2_dat[7:0];\n          else\n          if (pipe[9])\n            color_l <= fml3_dat[7:0];\n          else\n          if (pipe[11])\n            color_l <= fml4_dat[7:0];\n          else\n          if (pipe[13])\n            color_l <= fml5_dat[7:0];\n          else\n          if (pipe[15])\n            color_l <= fml6_dat[7:0];\n          else\n          if (pipe[17])\n            color_l <= fml7_dat[7:0];\n        end\n\nendmodule\n",
        "module_name": "vga_linear_fml",
        "module_hash": "dab690fd1fd1494c97b89f1815587bd8",
        "dataset_index": 25071
      },
      "decoder_3to8_2d6c0fee": {
        "rtl_code": "module decoder_3to8 (\n    input [2:0] A, B, C,\n    input EN,\n    output reg [7:0] Y\n);\n    \n    always @(*) begin\n        if (EN == 1'b0) begin\n            Y <= 8'b00000000;\n        end\n        else begin\n            case ({A, B, C})\n                3'b000: Y <= 8'b00000001;\n                3'b001: Y <= 8'b00000010;\n                3'b010: Y <= 8'b00000100;\n                3'b011: Y <= 8'b00001000;\n                3'b100: Y <= 8'b00010000;\n                3'b101: Y <= 8'b00100000;\n                3'b110: Y <= 8'b01000000;\n                3'b111: Y <= 8'b10000000;\n                default: Y <= 8'b00000000;\n            endcase\n        end\n    end\n    \nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "2d6c0feefd45dea3026ea3995c083aa4",
        "dataset_index": 17201
      },
      "nvme_cq_check #_f3236443": {
        "rtl_code": "\n\nmodule nvme_cq_check # (\n\tparameter\tC_PCIE_DATA_WIDTH\t\t\t= 128,\n\tparameter\tC_PCIE_ADDR_WIDTH\t\t\t= 36\n)\n(\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\n\tinput\t\t\t\t\t\t\t\t\tpcie_msi_en,\n\n\tinput\t\t\t\t\t\t\t\t\tcq_rst_n,\n\tinput\t\t\t\t\t\t\t\t\tcq_valid,\n\tinput\t\t\t\t\t\t\t\t\tio_cq_irq_en,\n\t\n\tinput\t[7:0]\t\t\t\t\t\t\tcq_tail_ptr,\n\tinput\t[7:0]\t\t\t\t\t\t\tcq_head_ptr,\n\tinput\t\t\t\t\t\t\t\t\tcq_head_update,\n\n\toutput\t\t\t\t\t\t\t\t\tcq_legacy_irq_req,\n\toutput\t\t\t\t\t\t\t\t\tcq_msi_irq_req,\n\tinput\t\t\t\t\t\t\t\t\tcq_msi_irq_ack\n\t\n);\n\nlocalparam\tLP_CQ_IRQ_DELAY_TIME\t\t\t= 8'h01;\n\n\nlocalparam\tS_IDLE\t\t\t\t\t\t\t= 4'b0001;\nlocalparam\tS_CQ_MSI_IRQ_REQ\t\t\t\t= 4'b0010;\nlocalparam\tS_CQ_MSI_HEAD_SET\t\t\t\t= 4'b0100;\nlocalparam\tS_CQ_MSI_IRQ_TIMER\t\t\t\t= 4'b1000;\n\nreg\t\t[3:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[3:0]\t\t\t\t\t\t\t\tnext_state;\n\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_cq_tail_ptr;\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_cq_msi_irq_head_ptr;\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_irq_timer;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cq_legacy_irq_req;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cq_msi_irq_req;\n\nwire\t\t\t\t\t\t\t\t\t\tw_cq_rst_n;\n\nassign cq_legacy_irq_req = r_cq_legacy_irq_req;\nassign cq_msi_irq_req = r_cq_msi_irq_req;\n\nassign w_cq_rst_n = pcie_user_rst_n & cq_rst_n;\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_cq_tail_ptr <= cq_tail_ptr;\n\tr_cq_legacy_irq_req <= ((cq_head_ptr != r_cq_tail_ptr) && ((cq_valid & io_cq_irq_en) == 1));\nend\n\nalways @ (posedge pcie_user_clk or negedge w_cq_rst_n)\nbegin\n\tif(w_cq_rst_n == 0)\n\t\tcur_state <= S_IDLE;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tif(((r_cq_msi_irq_head_ptr != r_cq_tail_ptr) & (pcie_msi_en & cq_valid & io_cq_irq_en)) == 1)\n\t\t\t\tnext_state <= S_CQ_MSI_IRQ_REQ;\n\t\t\telse\n\t\t\t\tnext_state <= S_IDLE;\n\t\tend\n\t\tS_CQ_MSI_IRQ_REQ: begin\n\t\t\tif(cq_msi_irq_ack == 1)\n\t\t\t\tnext_state <= S_CQ_MSI_HEAD_SET;\n\t\t\telse\n\t\t\t\tnext_state <= S_CQ_MSI_IRQ_REQ;\n\t\tend\n\t\tS_CQ_MSI_HEAD_SET: begin\n\n\t\t\tnext_state <= S_CQ_MSI_IRQ_TIMER;\n\t\tend\n\t\tS_CQ_MSI_IRQ_TIMER: begin\n\t\t\tif(r_irq_timer == 0)\n\t\t\t\tnext_state <= S_IDLE;\n\t\t\telse\n\t\t\t\tnext_state <= S_CQ_MSI_IRQ_TIMER;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_IDLE;\n\t\tend\n\tendcase\nend\n\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\n\t\tend\n\t\tS_CQ_MSI_IRQ_REQ: begin\n\n\t\tend\n\t\tS_CQ_MSI_HEAD_SET: begin\n\t\t\tr_irq_timer <= LP_CQ_IRQ_DELAY_TIME;\n\t\tend\n\t\tS_CQ_MSI_IRQ_TIMER: begin\n\t\t\tr_irq_timer <= r_irq_timer - 1;\n\t\tend\n\t\tdefault: begin\n\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk or negedge w_cq_rst_n)\nbegin\n\tif(w_cq_rst_n == 0) begin\n\t\tr_cq_msi_irq_head_ptr <= 0;\n\tend\n\telse begin\n\t\tcase(cur_state)\n\t\t\tS_IDLE: begin\n\t\t\t\tif((pcie_msi_en & cq_valid & io_cq_irq_en) == 0)\n\t\t\t\t\tr_cq_msi_irq_head_ptr <= r_cq_tail_ptr;\n\t\t\tend\n\t\t\tS_CQ_MSI_IRQ_REQ: begin\n\n\t\t\tend\n\t\t\tS_CQ_MSI_HEAD_SET: begin\n\t\t\t\tr_cq_msi_irq_head_ptr <= r_cq_tail_ptr;\n\t\t\tend\n\t\t\tS_CQ_MSI_IRQ_TIMER: begin\n\n\t\t\tend\n\t\t\tdefault: begin\n\n\t\t\tend\n\t\tendcase\n\tend\n\n\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\t\tS_CQ_MSI_IRQ_REQ: begin\n\t\t\tr_cq_msi_irq_req <= 1;\n\t\tend\n\t\tS_CQ_MSI_HEAD_SET: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\t\tS_CQ_MSI_IRQ_TIMER: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\tendcase\nend\n\n\nendmodule",
        "module_name": "nvme_cq_check #",
        "module_hash": "f3236443d62c90ee4bd06c73a16cd294",
        "dataset_index": 25788
      },
      "block_memory_generator_30080f36": {
        "rtl_code": "module block_memory_generator (\n  input ENA,\n  input clka,\n  input ENB,\n  input clkb,\n  input [9:0] addra,\n  input [9:0] addrb,\n  input  dina,\n  output reg  DOUTB\n);\n\n  reg mem [0:1023]; // 2^16 bits of memory\n\n  always @(posedge clka) begin\n    if (ENA) begin\n      mem[addra] <= dina;\n    end\n  end\n\n  always @(posedge clkb) begin\n    if (ENB) begin\n      DOUTB <= mem[addrb];\n    end\n  end\n\nendmodule",
        "module_name": "block_memory_generator",
        "module_hash": "30080f366d11154cb1ff5ed2d01097be",
        "dataset_index": 3390
      },
      "add8bit_62c5121d": {
        "rtl_code": "\nmodule add8bit (\n    input [7:0] in1,\n    input [7:0] in2,\n    output [7:0] sum\n    );\n\n    // The sum of two 8-bit unsigned integers can be calculated by simply adding them together.\n    // We can use the \"+\" operator to perform the addition.\n    // Since we are using unsigned integers, the output will automatically wrap around if it exceeds 8 bits.\n\n    assign sum = in1 + in2;\n\nendmodule",
        "module_name": "add8bit",
        "module_hash": "62c5121d9d255ed2a7827bf66ccc4714",
        "dataset_index": 1069
      },
      "sky130_fd_sc_lp__and4bb_b717ef05": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__and4bb (\n    X  ,\n    A_N,\n    B_N,\n    C  ,\n    D\n);\n\n    output X  ;\n    input  A_N;\n    input  B_N;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out  ;\n    wire and0_out_X;\n\n    nor nor0 (nor0_out  , A_N, B_N       );\n    and and0 (and0_out_X, nor0_out, C, D );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__and4bb",
        "module_hash": "b717ef0521157f857b4bab1ac115e235",
        "dataset_index": 22348
      },
      "ram16k_dualport_5e0f7b84": {
        "rtl_code": "module ram16k_dualport(\n    input CLK,\n    input [9:0] A1ADDR, B1ADDR,\n    input [31:0] B1DATA,\n    input A1EN, B1EN,\n    output reg [31:0] A1DATA\n);\n\n     reg [31:0] mem [0:4095];\n\n    always @(posedge CLK) begin\n        if (B1EN) begin\n            mem[B1ADDR] <= B1DATA;\n        end\n        if (A1EN) begin\n            A1DATA <= mem[A1ADDR];\n        end\n    end\n\nendmodule",
        "module_name": "ram16k_dualport",
        "module_hash": "5e0f7b84f1011c7720fed34fd5bd0e52",
        "dataset_index": 2615
      },
      "video_sys_jtag_uart_0_sim_scfifo_r_2763508b": {
        "rtl_code": "\nmodule video_sys_jtag_uart_0_sim_scfifo_r (\n    // inputs:\n    clk,\n    fifo_rd,\n    rst_n,\n\n    // outputs:\n    fifo_EF,\n    fifo_rdata,\n    rfifo_full,\n    rfifo_used\n);\n    output fifo_EF;\n    output [7:0] fifo_rdata;\n    output rfifo_full;\n    output [5:0] rfifo_used;\n\n    input clk;\n    input fifo_rd;\n    input rst_n;\n\n    reg [63:0] fifo;\n    reg [5:0] rfifo_used;\n    reg [7:0] fifo_rdata_r;\n\n    assign fifo_EF = (rfifo_used == 0);\n    assign rfifo_full = (rfifo_used == 64);\n\n    always @(posedge clk) begin\n        if (rst_n == 0) begin\n            fifo <= 64'h0;\n            rfifo_used <= 6'h0;\n        end else if (fifo_rd) begin\n            fifo_rdata_r <= fifo[7:0];\n            rfifo_used <= rfifo_used - 1;\n            fifo <= {fifo[55:0], 8'h00};\n        end else begin\n            if (rfifo_used < 64) begin\n                fifo <= {fifo[55:0], 8'h00};\n                rfifo_used <= rfifo_used + 1;\n            end\n        end\n    end\n\n    assign fifo_rdata = fifo_rdata_r;\nendmodule\n",
        "module_name": "video_sys_jtag_uart_0_sim_scfifo_r",
        "module_hash": "2763508bf010a5c63f1f8e0a046b34b7",
        "dataset_index": 15807
      },
      "pcieCore_axi_basic_rx_null_gen #_513f0174": {
        "rtl_code": "\n\nmodule pcieCore_axi_basic_rx_null_gen # (\n  parameter C_DATA_WIDTH = 128,           parameter TCQ = 1,                      parameter KEEP_WIDTH = C_DATA_WIDTH / 8            ) (\n\n  input      [C_DATA_WIDTH-1:0] m_axis_rx_tdata,     input                         m_axis_rx_tvalid,    input                         m_axis_rx_tready,    input                         m_axis_rx_tlast,     input                  [21:0] m_axis_rx_tuser,     output                        null_rx_tvalid,      output                        null_rx_tlast,       output       [KEEP_WIDTH-1:0] null_rx_tkeep,       output                        null_rdst_rdy,       output reg              [4:0] null_is_eof,         input                         user_clk,            input                         user_rst             );\n\n\nlocalparam INTERFACE_WIDTH_DWORDS = (C_DATA_WIDTH == 128) ? 11'd4 :\n                                           (C_DATA_WIDTH == 64) ? 11'd2 : 11'd1;\n\nlocalparam            IDLE      = 0;\nlocalparam            IN_PACKET = 1;\nreg                   cur_state;\nreg                   next_state;\n\nreg            [11:0] reg_pkt_len_counter;\nreg            [11:0] pkt_len_counter;\nwire           [11:0] pkt_len_counter_dec;\nwire                  pkt_done;\n\nwire           [11:0] new_pkt_len;\nwire            [9:0] payload_len;\nwire            [1:0] packet_fmt;\nwire                  packet_td;\nreg             [3:0] packet_overhead;\n\nwire [KEEP_WIDTH-1:0] eof_tkeep;\nwire                  straddle_sof;\nwire                  eof;\n\n\nassign eof = m_axis_rx_tuser[21];\ngenerate\n  if(C_DATA_WIDTH == 128) begin : sof_eof_128\n    assign straddle_sof = (m_axis_rx_tuser[14:13] == 2'b11);\n  end\n  else begin : sof_eof_64_32\n    assign straddle_sof = 1'b0;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : len_calc_128\n    assign packet_fmt  = straddle_sof ?\n                                m_axis_rx_tdata[94:93] : m_axis_rx_tdata[30:29];\n    assign packet_td   = straddle_sof ?\n                                      m_axis_rx_tdata[79] : m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ?\n         (straddle_sof ? m_axis_rx_tdata[73:64] : m_axis_rx_tdata[9:0]) : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td, straddle_sof})\n        3'b0_0_0: packet_overhead = 4'd3 + 4'd0 - 4'd4;\n        3'b0_0_1: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        3'b0_1_0: packet_overhead = 4'd3 + 4'd1 - 4'd4;\n        3'b0_1_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        3'b1_0_0: packet_overhead = 4'd4 + 4'd0 - 4'd4;\n        3'b1_0_1: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        3'b1_1_0: packet_overhead = 4'd4 + 4'd1 - 4'd4;\n        3'b1_1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else if(C_DATA_WIDTH == 64) begin : len_calc_64\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else begin : len_calc_32\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd1;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd1;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd1;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd1;\n      endcase\n    end\n  end\nendgenerate\n\nassign new_pkt_len =\n         {{9{packet_overhead[3]}}, packet_overhead[2:0]} + {2'b0, payload_len};\n\n\nassign pkt_len_counter_dec = reg_pkt_len_counter - INTERFACE_WIDTH_DWORDS;\nassign pkt_done = (reg_pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\n\nalways @(*) begin\n  case (cur_state)\n\n    IDLE: begin\n      if(m_axis_rx_tvalid && m_axis_rx_tready && !eof) begin\n        next_state = IN_PACKET;\n      end\n      else begin\n        next_state = IDLE;\n      end\n\n      pkt_len_counter = new_pkt_len;\n    end\n\n    IN_PACKET: begin\n      if((C_DATA_WIDTH == 128) && straddle_sof && m_axis_rx_tvalid) begin\n        pkt_len_counter = new_pkt_len;\n        next_state = IN_PACKET;\n      end\n\n      else if(m_axis_rx_tready && pkt_done)\n      begin\n        pkt_len_counter = new_pkt_len;\n        next_state      = IDLE;\n      end\n\n      else begin\n        if(m_axis_rx_tready) begin\n          pkt_len_counter = pkt_len_counter_dec;\n        end\n        else begin\n          pkt_len_counter = reg_pkt_len_counter;\n        end\n\n        next_state = IN_PACKET;\n      end\n    end\n\n    default: begin\n      pkt_len_counter = reg_pkt_len_counter;\n      next_state      = IDLE;\n    end\n  endcase\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    cur_state           <= #TCQ IDLE;\n    reg_pkt_len_counter <= #TCQ 12'h0;\n  end\n  else begin\n    cur_state           <= #TCQ next_state;\n    reg_pkt_len_counter <= #TCQ pkt_len_counter;\n  end\nend\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : strb_calc_128\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        10'd3:   null_is_eof = 5'b11011;\n        10'd4:   null_is_eof = 5'b11111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = {KEEP_WIDTH{1'b0}};\n  end\n  else if(C_DATA_WIDTH == 64) begin : strb_calc_64\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = { ((pkt_len_counter == 12'd2) ? 4'hF:4'h0), 4'hF };\n  end\n  else begin : strb_calc_32\n    always @(*) begin\n      if(pkt_len_counter == 12'd1) begin\n        null_is_eof = 5'b10011;\n      end\n      else begin\n        null_is_eof = 5'b00011;\n      end\n    end\n\n    assign eof_tkeep = 4'hF;\n  end\nendgenerate\n\n\nassign null_rx_tvalid = 1'b1;\nassign null_rx_tlast  = (pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\nassign null_rx_tkeep  = null_rx_tlast ? eof_tkeep : {KEEP_WIDTH{1'b1}};\nassign null_rdst_rdy  = null_rx_tlast;\n\nendmodule\n",
        "module_name": "pcieCore_axi_basic_rx_null_gen #",
        "module_hash": "513f01740ac85291a498f3404be3831e",
        "dataset_index": 23595
      },
      "multiplier_c396f73f": {
        "rtl_code": "module multiplier (\n  input [n-1:0] A,\n  input [n-1:0] B,\n  input mode,\n  output reg [n-1:0] P\n);\n\nparameter n = 8; // number of bits in A and B\n\nreg [n-1:0] partial_product;\nreg [2*n-1:0] shifted_A;\nreg [n:0] extended_A, extended_B;\ninteger i;\n\nalways @(*) begin\n  if (mode == 0) begin // Unsigned multiplication\n    partial_product = 0;\n    for (i = 0; i < n; i = i + 1) begin\n      if (B[i]) begin\n        shifted_A = A << i;\n        partial_product = partial_product + shifted_A[n-1:0];\n      end\n    end\n  end else begin // Signed multiplication\n    partial_product = 0;\n    extended_A = {A[n-1], A};\n    extended_B = {B[n-1], B};\n    for (i = 0; i < n; i = i + 1) begin\n      case ({extended_B[i+1], extended_B[i]})\n        2'b01: partial_product <= partial_product - extended_A[n-1:0];\n        2'b10: partial_product <= partial_product + extended_A[n-1:0];\n        default: ; // do nothing\n      endcase\n      extended_A = extended_A << 1;\n    end\n  end\n  P <= partial_product;\nend\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "c396f73f9d974ec019c5e28d52b24211",
        "dataset_index": 9623
      },
      "byte_reversal_03dca645": {
        "rtl_code": "module byte_reversal (\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nalways @(*) begin\n    out[7:0] = in[31:24];\n    out[15:8] = in[23:16];\n    out[23:16] = in[15:8];\n    out[31:24] = in[7:0];\nend\n\nendmodule\n\nmodule priority_encoder (\n    input [31:0] in,\n    output reg [4:0] pos // Position of the first high bit in the input\n);\n\nalways @(*) begin\n    case(in)\n        32'b00000000000000000000000000000000: pos = 5'b00000;\n        32'b00000000000000000000000000000001: pos = 5'b00001;\n        32'b00000000000000000000000000000011: pos = 5'b00010;\n        32'b00000000000000000000000000000111: pos = 5'b00011;\n        32'b00000000000000000000000000001111: pos = 5'b00100;\n        32'b00000000000000000000000000011111: pos = 5'b00101;\n        32'b00000000000000000000000000111111: pos = 5'b00110;\n        32'b00000000000000000000000001111111: pos = 5'b00111;\n        32'b00000000000000000000000011111111: pos = 5'b01000;\n        32'b00000000000000000000000111111111: pos = 5'b01001;\n        32'b00000000000000000000001111111111: pos = 5'b01010;\n        32'b00000000000000000000011111111111: pos = 5'b01011;\n        default: pos = 5'b01111;\n    endcase\nend\n\nendmodule",
        "module_name": "byte_reversal",
        "module_hash": "03dca64576b4b2a2b93aca4c06806d9b",
        "dataset_index": 13344
      },
      "ripple_bcd_adder_570efa78": {
        "rtl_code": "module ripple_bcd_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input select,\n    output [3:0] binary_sum,\n    output reg [3:0] BCD0,\n    output reg [3:0] BCD1\n);\n\nreg [3:0] sum;\nwire [7:0] bcd_sum;\n\n// Ripple carry adder\nassign binary_sum = A + B;\n\n// Binary to BCD converter\nbinary_to_bcd_converter bcd_converter(\n    .binary_in(binary_sum),\n    .bcd_out(bcd_sum)\n);\n\n// Output select\nalways @(*) begin\n    if (select) begin\n        BCD0 = bcd_sum[3:0];\n        BCD1 = bcd_sum[7:4];\n    end\n    else begin\n        BCD0 = 4'b0000;\n        BCD1 = 4'b0000;\n    end\nend\n\nendmodule\n\nmodule binary_to_bcd_converter (\n    input [3:0] binary_in,\n    output reg [7:0] bcd_out\n);\n\nalways @(*) begin\n    case (binary_in)\n        4'b0000: bcd_out = 8'b00000001;\n        4'b0001: bcd_out = 8'b00000010;\n        4'b0010: bcd_out = 8'b00000100;\n        4'b0011: bcd_out = 8'b00000110;\n        4'b0100: bcd_out = 8'b00001000;\n        4'b0101: bcd_out = 8'b00001010;\n        4'b0110: bcd_out = 8'b00001100;\n        4'b0111: bcd_out = 8'b00001110;\n        4'b1000: bcd_out = 8'b00010000;\n        4'b1001: bcd_out = 8'b00010001;\n        4'b1010: bcd_out = 8'b00010010;\n        4'b1011: bcd_out = 8'b00010011;\n        4'b1100: bcd_out = 8'b00010100;\n        4'b1101: bcd_out = 8'b00010101;\n        4'b1110: bcd_out = 8'b00010110;\n        4'b1111: bcd_out = 8'b00010111;\n        default: bcd_out = 8'b00000000;\n    endcase\nend\n\nendmodule",
        "module_name": "ripple_bcd_adder",
        "module_hash": "570efa7851d16d3462a939821d33e9c6",
        "dataset_index": 2230
      },
      "axis_lfsr #_bfd810ed": {
        "rtl_code": "\n\nmodule axis_lfsr #\n(\n  parameter integer AXIS_TDATA_WIDTH = 64\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n\n  input  wire                        m_axis_tready,\n  output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,\n  output wire                        m_axis_tvalid\n);\n\n  reg [AXIS_TDATA_WIDTH-1:0] int_lfsr_reg, int_lfsr_next;\n  reg int_enbl_reg, int_enbl_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_lfsr_reg <= 64'h5555555555555555;\n      int_enbl_reg <= 1'b0;\n    end\n    else\n    begin\n      int_lfsr_reg <= int_lfsr_next;\n      int_enbl_reg <= int_enbl_next;\n    end\n  end\n\n  always @*\n  begin\n    int_lfsr_next = int_lfsr_reg;\n    int_enbl_next = int_enbl_reg;\n\n    if(~int_enbl_reg)\n    begin\n      int_enbl_next = 1'b1;\n    end\n\n    if(int_enbl_reg & m_axis_tready)\n    begin\n      int_lfsr_next = {int_lfsr_reg[62:0], int_lfsr_reg[62] ~^ int_lfsr_reg[61]}; \n    end\n  end\n\n  assign m_axis_tdata = int_lfsr_reg;\n  assign m_axis_tvalid = int_enbl_reg;\n\nendmodule\n",
        "module_name": "axis_lfsr #",
        "module_hash": "bfd810ed252c66466e280781d7c806d6",
        "dataset_index": 23555
      },
      "shift_register_f55b1ff9": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input load,\n    input [3:0] in,\n    output [3:0] out,\n    output [3:0] out_next\n);\n    \n    reg [3:0] stage1, stage2, stage3, stage4;\n    \n    always @(posedge clk) begin\n        if (load) begin\n            stage1 <= in;\n        end else begin\n            stage1 <= stage2;\n        end\n        \n        stage2 <= stage3;\n        stage3 <= stage4;\n        stage4 <= out_next;\n    end\n    \n    assign out = stage1;\n    assign out_next = stage2;\n    \nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "f55b1ff9b4d57bfd731c1e3493473f6c",
        "dataset_index": 15079
      },
      "lights_switches_28ff8321": {
        "rtl_code": "module lights_switches (\n                         // inputs:\n                          address,\n                          clk,\n                          in_port,\n                          reset_n,\n\n                         // outputs:\n                          readdata\n                       )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  7: 0] in_port;\n  input            reset_n;\n\n\n  wire             clk_en;\n  wire    [  7: 0] data_in;\n  wire    [  7: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n\n  assign clk_en = 1;\n\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {8 {(address == 0)}} & data_in;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "lights_switches",
        "module_hash": "28ff8321be7a35b6914fb723e2b54706",
        "dataset_index": 21212
      },
      "xor_gate_057684fe": {
        "rtl_code": "\nmodule xor_gate (\n    input A,\n    input B,\n    output X,\n    input VPWR,\n    input VGND\n);\n\n    wire not_A;\n    wire not_B;\n    wire A_and_not_B;\n    wire not_A_and_B;\n\n    not (not_A, A);\n    not (not_B, B);\n    and (A_and_not_B, A, not_B);\n    and (not_A_and_B, not_A, B);\n\n    or (X, A_and_not_B, not_A_and_B);\n\nendmodule\n",
        "module_name": "xor_gate",
        "module_hash": "057684fe468f45fafe1c96eff59c0da5",
        "dataset_index": 3452
      },
      "wait_generator_84228197": {
        "rtl_code": "module wait_generator(\n    input clk, nreset, WAIT,\n    output reg wait_random\n);\n\n    reg [8:0] wait_counter;\n\n    always @(posedge clk or negedge nreset) begin\n        if (!nreset) begin\n            wait_counter <= 9'b0;\n        end else begin\n            wait_counter <= wait_counter + 1'b1;\n        end\n    end\n\n    always @* begin\n        if (WAIT) begin\n            if (wait_counter[5:0] != 6'b0) begin\n                wait_random = 1'b1;\n            end else begin\n                wait_random = 1'b0;\n            end\n        end else begin\n            wait_random = 1'b0;\n        end\n    end\n\nendmodule",
        "module_name": "wait_generator",
        "module_hash": "84228197114682ff8224416642c86973",
        "dataset_index": 1079
      },
      "EHRU_8_a2e623b2": {
        "rtl_code": "module EHRU_8 (\n    CLK,\n    read_0,\n    write_0,\n    EN_write_0,\n    read_1,\n    write_1,\n    EN_write_1,\n    read_2,\n    write_2,\n    EN_write_2,\n    read_3,\n    write_3,\n    EN_write_3,\n    read_4,\n    write_4,\n    EN_write_4,\n    read_5,\n    write_5,\n    EN_write_5,\n    read_6,\n    write_6,\n    EN_write_6,\n    read_7,\n    write_7,\n    EN_write_7\n);\n    parameter            DATA_SZ = 1;\n    parameter            RESET_VAL = 0;\n\n    input                CLK;\n    output [DATA_SZ-1:0] read_0;\n    input  [DATA_SZ-1:0] write_0;\n    input                EN_write_0;\n    output [DATA_SZ-1:0] read_1;\n    input  [DATA_SZ-1:0] write_1;\n    input                EN_write_1;\n    output [DATA_SZ-1:0] read_2;\n    input  [DATA_SZ-1:0] write_2;\n    input                EN_write_2;\n    output [DATA_SZ-1:0] read_3;\n    input  [DATA_SZ-1:0] write_3;\n    input                EN_write_3;\n    output [DATA_SZ-1:0] read_4;\n    input  [DATA_SZ-1:0] write_4;\n    input                EN_write_4;\n    output [DATA_SZ-1:0] read_5;\n    input  [DATA_SZ-1:0] write_5;\n    input                EN_write_5;\n    output [DATA_SZ-1:0] read_6;\n    input  [DATA_SZ-1:0] write_6;\n    input                EN_write_6;\n    output [DATA_SZ-1:0] read_7;\n    input  [DATA_SZ-1:0] write_7;\n    input                EN_write_7;\n\n    reg    [DATA_SZ-1:0] r;\n    wire   [DATA_SZ-1:0] wire_0;\n    wire   [DATA_SZ-1:0] wire_1;\n    wire   [DATA_SZ-1:0] wire_2;\n    wire   [DATA_SZ-1:0] wire_3;\n    wire   [DATA_SZ-1:0] wire_4;\n    wire   [DATA_SZ-1:0] wire_5;\n    wire   [DATA_SZ-1:0] wire_6;\n    wire   [DATA_SZ-1:0] wire_7;\n    wire   [DATA_SZ-1:0] wire_8;\n\n    assign wire_0 = r;\n    assign wire_1 = EN_write_0 ? write_0 : wire_0;\n    assign wire_2 = EN_write_1 ? write_1 : wire_1;\n    assign wire_3 = EN_write_2 ? write_2 : wire_2;\n    assign wire_4 = EN_write_3 ? write_3 : wire_3;\n    assign wire_5 = EN_write_4 ? write_4 : wire_4;\n    assign wire_6 = EN_write_5 ? write_5 : wire_5;\n    assign wire_7 = EN_write_6 ? write_6 : wire_6;\n    assign wire_8 = EN_write_7 ? write_7 : wire_7;\n\n    assign read_0 = wire_0;\n    assign read_1 = wire_1;\n    assign read_2 = wire_2;\n    assign read_3 = wire_3;\n    assign read_4 = wire_4;\n    assign read_5 = wire_5;\n    assign read_6 = wire_6;\n    assign read_7 = wire_7;\n\n    always @(posedge CLK) begin\n        r <= wire_8;\n    end\nendmodule\n",
        "module_name": "EHRU_8",
        "module_hash": "a2e623b2558adb580f273edfbcde0485",
        "dataset_index": 22489
      },
      "shift_register_d_ff_6531e61c": {
        "rtl_code": "\nmodule shift_register_d_ff (\n    input clk,\n    input d,\n    output [2:0] shift_register_out,\n    output q\n);\n\nreg [2:0] shift_register;\n\nassign shift_register_out = shift_register[2];\nassign q = shift_register[0];\n\nalways @(posedge clk) begin\n    shift_register <= {shift_register[1], shift_register[2], shift_register[0] ^ shift_register[2]};\nend\n\nendmodule\n",
        "module_name": "shift_register_d_ff",
        "module_hash": "6531e61c75e72e338525f162b0984402",
        "dataset_index": 17257
      },
      "top__275c0994": {
        "rtl_code": "\nmodule top_module (\n    input CLK,\n    input UP_DOWN,\n    input RESET,\n    input [3:0] gray,\n    output reg [3:0] OUT\n);\n\nwire [3:0] binary;\nwire [3:0] counter;\nwire [3:0] sum;\n\ngray_to_binary gray_to_binary_inst (\n    .gray(gray),\n    .binary(binary)\n);\n\nup_down_counter up_down_counter_inst (\n    .CLK(CLK),\n    .UP_DOWN(UP_DOWN),\n    .RESET(RESET),\n    .OUT(counter)\n);\n\nfunctional_module functional_module_inst (\n    .binary(binary),\n    .counter(counter),\n    .sum(sum)\n);\n\nalways @ (posedge CLK) begin\n    if (RESET) begin\n        OUT <= 4'b0000;\n    end else begin\n        if (UP_DOWN) begin\n            OUT <= OUT + 4'b0001;\n        end else begin\n            OUT <= OUT - 4'b0001;\n        end\n    end\nend\n\nendmodule\nmodule gray_to_binary (\n    input [3:0] gray,\n    output reg [3:0] binary\n);\n\nalways @* begin\n    binary[3] = gray[3];\n    binary[2] = binary[3] ^ gray[2];\n    binary[1] = binary[2] ^ gray[1];\n    binary[0] = binary[1] ^ gray[0];\nend\n\nendmodule\nmodule up_down_counter (\n    input CLK,\n    input UP_DOWN,\n    input RESET,\n    output reg [3:0] OUT\n);\n\nalways @ (posedge CLK) begin\n    if (RESET) begin\n        OUT <= 4'b0000;\n    end else begin\n        if (UP_DOWN) begin\n            OUT <= OUT + 4'b0001;\n        end else begin\n            OUT <= OUT - 4'b0001;\n        end\n    end\nend\n\nendmodule\nmodule functional_module (\n    input [3:0] binary,\n    input [3:0] counter,\n    output reg [3:0] sum\n);\n\nalways @* begin\n    sum = binary + counter;\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "275c0994b036c9fbef8d2a0235ca4671",
        "dataset_index": 5852
      },
      "ChooseModule_b0438985": {
        "rtl_code": "module ChooseModule(\n    input  io_valid_0,\n    input  io_ready,\n    output io_chosen\n);\n\n  assign io_chosen = io_ready ? ~io_valid_0 : 1'b1; \n\nendmodule",
        "module_name": "ChooseModule",
        "module_hash": "b0438985f268cad9d1e830fb9244a5d0",
        "dataset_index": 16298
      },
      "memory_64bit_4bank_ef14777c": {
        "rtl_code": "\nmodule memory_64bit_4bank(\n    input clk,\n    input [63:0] din,\n    input wr_en,\n    input [1:0] wr_addr,\n    input rd_en,\n    input [1:0] rd_addr,\n    output [63:0] dout,\n    output full\n);\nreg [15:0] mem [0:1023];\nreg [63:0] dout_tmp;       // declare dout_tmp as a register\nassign full = 0; \n\nalways @(posedge clk) begin\n    if (wr_en) begin\n        case (wr_addr)\n            2'b00: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n            2'b01: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n            2'b10: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n            2'b11: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n        endcase\n    end\n    if (rd_en) begin\n        case (rd_addr)\n            2'b00: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n            2'b01: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n            2'b10: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n            2'b11: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n        endcase\n    end\nend\nassign dout = dout_tmp;\nendmodule",
        "module_name": "memory_64bit_4bank",
        "module_hash": "ef14777cff092e1ebceccd87a3c79384",
        "dataset_index": 7904
      },
      "twos_complement_267bcd4c": {
        "rtl_code": "module twos_complement(clk, rst, in, out);\n    input clk, rst;\n    input [3:0] in;\n    output reg [7:0] out;\n    reg [3:0] in_reg;\n    reg valid;\n\n    always @(posedge clk, posedge rst) begin\n        if (rst) begin\n            in_reg <= 4'b0;\n            valid <= 0;\n            out <= 8'b0;\n        end\n        else begin\n            in_reg <= in;\n            if (in_reg == in && valid) begin\n                out <= $signed({6'b0, in_reg}) + 1'b1;\n            end\n            else begin\n                valid <= 1;\n            end\n        end\n    end\nendmodule",
        "module_name": "twos_complement",
        "module_hash": "267bcd4c58c3587bdb0f3e7cffabdae5",
        "dataset_index": 20303
      },
      "FSM #_6342a00b": {
        "rtl_code": "module FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\n\nparameter s = 8; // number of states in the FSM\n\nreg [s-1:0] state;\nreg [m-1:0] output_reg;\n\nalways @ (posedge clk) begin\n  case(state)\n    3'b000: begin // state 0\n      if (in[0] && !in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b000;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b001: begin // state 1\n      if (in[0] && !in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b001;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b010: begin // state 2\n      if (in[0] && !in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b010;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b011: begin // state 3\n      if (in[0] && !in[1]) begin\n        state <= 3'b111;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b011;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b100: begin // state 4\n      if (in[0] && !in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b100;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b101: begin // state 5\n      if (in[0] && !in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b101;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b110: begin // state 6\n      if (in[0] && !in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b110;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b111: begin // state 7\n      if (in[0] && !in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b111;\n        output_reg <= 2'b00;\n      end\n    end\n  endcase\nend\n\nassign out = output_reg;\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "6342a00b770ba38fbac5217a228757de",
        "dataset_index": 727
      },
      "calculator_392d24d7": {
        "rtl_code": "module calculator(output reg [7:0] result, input [7:0] num1, input [7:0] num2, input [2:0] op);\n\n    always @ (*)\n    begin\n        case (op)\n            3'b000: result = num1 + num2; // addition\n            3'b001: result = num1 - num2; // subtraction\n            3'b010: result = num1 * num2; // multiplication\n            3'b011: result = num1 / num2; // division\n            default: result = 8'b0; // default case\n        endcase\n    end\n    \nendmodule",
        "module_name": "calculator",
        "module_hash": "392d24d75f3d0ec80e0ed944e0892fb6",
        "dataset_index": 19210
      },
      "top__fd5b0328": {
        "rtl_code": "module top_module (\n    input clk,\n    input areset,\n    input load,\n    input up_down,\n    input select,\n    output reg [4:0] counter4,\n    output reg [2:0] counter3,\n    output reg [5:0] sum\n);\n\nreg [4:0] counter4_next;\nreg [2:0] counter3_next;\n\nalways @(posedge clk or negedge areset) begin\n    if (areset == 0) begin\n        counter4 <= 0;\n        counter3 <= 0;\n    end else begin\n        if (load) begin\n            if (select) begin\n                counter4 <= counter4_next;\n            end else begin\n                counter3 <= counter3_next;\n            end\n        end else begin\n            if (up_down) begin\n                if (select) begin\n                    if (counter4 == 15) begin\n                        counter4_next <= 0;\n                    end else begin\n                        counter4_next <= counter4 + 1;\n                    end\n                end else begin\n                    if (counter3 == 7) begin\n                        counter3_next <= 0;\n                    end else begin\n                        counter3_next <= counter3 + 1;\n                    end\n                end\n            end else begin\n                if (select) begin\n                    if (counter4 == 0) begin\n                        counter4_next <= 15;\n                    end else begin\n                        counter4_next <= counter4 - 1;\n                    end\n                end else begin\n                    if (counter3 == 0) begin\n                        counter3_next <= 7;\n                    end else begin\n                        counter3_next <= counter3 - 1;\n                    end\n                end\n            end\n        end\n    end\nend\n\nalways @(counter4 or counter3) begin\n    sum = counter4 + counter3;\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "fd5b0328959746580ef9f34bc80f7c1f",
        "dataset_index": 19829
      },
      "control_2ffa5658": {
        "rtl_code": "module control (\n    input [5:0] op,\n    output [1:0] alu_op,\n    output regDst, aluSrc, memToReg, regWrite,\n    output memRead, memWrite, branch\n  );\n\nwire int0, op0_bar, op1_bar, op2_bar, op3_bar, op4_bar, op5_bar;\n\nnot (op0_bar, op[0]);\nnot (op1_bar, op[1]);\nnot (op2_bar, op[2]);\nnot (op3_bar, op[3]);\nnot (op4_bar, op[4]);\nnot (op5_bar, op[5]);\n\nand (alu_op[0], op5_bar, op4_bar, op3_bar, op[2]  , op1_bar, op0_bar); \nand (alu_op[1], op5_bar, op4_bar, op3_bar, op2_bar, op1_bar, op0_bar); \nand (regDst   , op5_bar, op4_bar, op3_bar, op2_bar, op1_bar, op0_bar); \nand (memToReg , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  );\nand (memRead  , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  ); \nand (memWrite , op[5]  , op4_bar, op[3]  , op2_bar, op[1]  , op[0]  ); \nand (branch   , op5_bar, op4_bar, op3_bar, op[2]  , op1_bar, op0_bar); \nand (int0     , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  );\nand (aluSrc   , op[5]  , op4_bar, op2_bar, op[1]  , op[0] ); \nor  (regWrite , int0   , alu_op[1]);\n\nendmodule\n",
        "module_name": "control",
        "module_hash": "2ffa5658773f71a957b9065868e8a8c1",
        "dataset_index": 1412
      },
      "rotator_bf4612d3": {
        "rtl_code": "\nmodule rotator (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nreg [99:0] shift_reg;\nreg [99:0] shifted_out;\nreg [1:0] rotate_mode;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n    end else if (ena[0] == 1) begin\n        // Rotate right by one bit\n        shift_reg <= {shift_reg[0], shift_reg[99:1]};\n    end else if (ena[1] == 1) begin\n        // Rotate left by one bit\n        shift_reg <= {shift_reg[98:0], shift_reg[99]};\n    end else if (ena == 2'b11) begin\n        // Rotate right by two bits\n        shift_reg <= {shift_reg[0], shift_reg[99:2]};\n    end\nend\n\nassign q = shift_reg;\n\nendmodule\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nrotator rotator_inst (\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(q)\n);\n\nendmodule",
        "module_name": "rotator",
        "module_hash": "bf4612d3bff26a63108e76b9999b8d2d",
        "dataset_index": 8427
      },
      "logic_unit_8242acfb": {
        "rtl_code": "module logic_unit (\n    input a,\n    input b,\n    input c,\n    output x\n);\n\n    wire ab = a & b;\n    wire ac = a & c;\n    wire bc = b & c;\n    \n    assign x = ab | ac | bc;\n    \nendmodule",
        "module_name": "logic_unit",
        "module_hash": "8242acfb39709bfc31ce5ca380113ae4",
        "dataset_index": 4430
      },
      "openhmc_ram #_f1123b09": {
        "rtl_code": "\n\nmodule openhmc_ram #(\n        parameter DATASIZE  = 78,   parameter ADDRSIZE  = 9,    parameter PIPELINED = 0     \n    ) (\n        input wire                  clk,\n\n        input wire                  wen,\n        input wire [DATASIZE-1:0]   wdata,\n        input wire [ADDRSIZE-1:0]   waddr,\n        input wire                  ren,\n        input wire [ADDRSIZE-1:0]   raddr,\n        output wire [DATASIZE-1:0]  rdata\n    );\n\nwire [DATASIZE-1:0] rdata_ram;\n\n    generate\n        if (PIPELINED == 0)\n        begin\n            assign rdata    = rdata_ram;\n        end\n        else\n        begin\n            reg [DATASIZE-1:0]  rdata_dly;\n            reg                 ren_dly;\n\n            assign rdata    = rdata_dly;\n\n            always @(posedge clk)\n            begin\n                ren_dly         <= ren;\n\n                if (ren_dly)\n                    rdata_dly   <= rdata_ram;\n            end\n        end\n    endgenerate\n\n    reg [DATASIZE-1:0]  MEM [0:(2**ADDRSIZE)-1];\n\n    reg [DATASIZE-1:0]  data_out;\n\n    assign rdata_ram = data_out;\n\n    always @(posedge clk)\n    begin\n        if (wen)\n            MEM[waddr]  <= wdata;\n    end\n\n    always @(posedge clk)\n    begin\n        if (ren)\n            data_out    <= MEM[raddr];\n    end\n\nendmodule\n\n",
        "module_name": "openhmc_ram #",
        "module_hash": "f1123b09dd254df9d9170ece323f1c3b",
        "dataset_index": 9745
      },
      "adder4 #_09ea1154": {
        "rtl_code": "\nmodule adder4 #(parameter WIDTH = 4)(\n    input [WIDTH-1:0] A,\n    input [WIDTH-1:0] B,\n    input Cin,\n    output [WIDTH-1:0] S,\n    output Cout\n);\n\n    wire [WIDTH:0] C;\n\n    assign C[0] = Cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : adder\n            full_adder FA(\n                .A(A[i]),\n                .B(B[i]),\n                .Cin(C[i]),\n                .S(S[i]),\n                .Cout(C[i+1])\n            );\n        end\n    endgenerate\n\n    assign Cout = C[WIDTH];\n\nendmodule\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    wire w1, w2, w3;\n\n    assign w1 = A ^ B;\n    assign w2 = A & B;\n    assign w3 = w1 & Cin;\n    assign S = w1 ^ Cin;\n    assign Cout = w2 | w3;\n\nendmodule",
        "module_name": "adder4 #",
        "module_hash": "09ea11543638685176756616bde5b583",
        "dataset_index": 8865
      },
      "queue_8x9_6b63bc90": {
        "rtl_code": "\n\nmodule queue_8x9(\n\tinput\t\tclk,\n\tinput\t\treset,\n\tinput\t\tnchar,\n\tinput\t\tlchar,\n\tinput\t[7:0]\tchar_i,\n\tinput\t\tstb_i,\n\toutput\t\tack_o,\n\toutput\t[8:0]\tdat_o,\n\toutput\t\tfull_o,\n\toutput\t\tempty_o,\n\n\toutput\t[7:0]\toccupied_tb,\toutput\t[2:0]\trp_tb,\n\toutput\t[2:0]\twp_tb,\n\toutput\t\twe_tb\n);\n\treg [8:0] queue[0:7];\n\treg [7:0] occupied;\treg [2:0] rp, wp;\treg oe_r;\n\n\tassign ack_o = oe_r;\n\tassign dat_o = queue[rp];\n\tassign full_o = occupied[wp];\n\tassign empty_o = ~occupied[rp];\n\n\twire is_eop = (char_i[1:0] == 2'b01) | (char_i[1:0] == 2'b10);\n\twire we = (nchar | (lchar & is_eop));\n\twire ptrs_eq = (wp == rp);\n\n\talways @(posedge clk) begin\n\t\toe_r <= oe_r;\n\n\t\tif(reset) begin\n\t\t\toe_r <= 0;\n\t\tend\n\t\telse if(stb_i) begin\n\t\t\toe_r <= 1;\n\t\tend\n\t\telse if(oe_r) begin\n\t\t\toe_r <= 0;\n\t\tend\n\tend\n\n\twire should_set_occupied_flag = (~ack_o & we & ~occupied[wp]);\n\twire read_write_concurrently = (ack_o & we & ptrs_eq);\n\twire should_store = should_set_occupied_flag | read_write_concurrently;\n\twire should_pop_queue = ack_o & occupied[rp];\n\n\talways @(posedge clk) begin\n\t\toccupied <= occupied;\n\t\trp <= rp;\n\t\twp <= wp;\n\n\t\tif(reset) begin\n\t\t\toccupied <= 8'h00;\n\t\t\trp <= 3'd0;\n\t\t\twp <= 3'd0;\n\t\tend\n\t\telse begin\n\t\t\tif(should_store) begin\n\t\t\t\tqueue[wp] <= {lchar, char_i};\n\t\t\t\twp <= wp + 1;\n\t\t\tend\n\t\t\tif(should_set_occupied_flag) begin\n\t\t\t\toccupied[wp] <= 1;\n\t\t\tend\n\t\t\tif(should_pop_queue) begin\n\t\t\t\tif(~read_write_concurrently) begin\n\t\t\t\t\toccupied[rp] <= 0;\n\t\t\t\tend\n\t\t\t\trp <= rp + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign occupied_tb = occupied;\n\tassign rp_tb = rp;\n\tassign wp_tb = wp;\n\tassign we_tb = we;\nendmodule\n\n",
        "module_name": "queue_8x9",
        "module_hash": "6b63bc90769e10c4adfce0cf02784b84",
        "dataset_index": 23485
      },
      "bin2gray_4ad81465": {
        "rtl_code": "module bin2gray(\n    input clk,\n    input [3:0] bin,\n    output reg [3:0] gray,\n    output reg valid\n);\n\n    reg [3:0] prev_gray;\n\n    always@(posedge clk) begin\n        // Set valid to 0 by default\n        valid <= 0;\n\n        // Calculate MSB of gray\n        gray[3] <= bin[3];\n\n        // Calculate remaining bits of gray\n        gray[2] <= bin[3] ^ bin[2];\n        gray[1] <= bin[2] ^ bin[1];\n        gray[0] <= bin[1] ^ bin[0];\n\n        // Check if gray has changed from previous cycle\n        if (gray != prev_gray) begin\n            valid <= 1;\n        end\n\n        // Store current gray as previous gray\n        prev_gray <= gray;\n    end\n\nendmodule",
        "module_name": "bin2gray",
        "module_hash": "4ad81465965bc2e511ad9856562d6249",
        "dataset_index": 7071
      },
      "top__ec196bf5": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input select,\n    output reg [7:0] sum,\n    output reg [7:0] min,\n    output [15:0] product\n);\n\n    wire [7:0] min_value;\n    wire [7:0] adder_sum;\n    \n    find_min min_module(\n        .a(a),\n        .b(b),\n        .c(8'h0),\n        .d(8'h0),\n        .min(min_value)\n    );\n    \n    adder adder_module(\n        .a(a),\n        .b(b),\n        .sum(adder_sum)\n    );\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            sum <= 8'h0;\n            min <= 8'h0;\n        end else begin\n            if (select) begin\n                sum <= adder_sum;\n                min <= min_value;\n            end else begin\n                sum <= min_value;\n                min <= adder_sum;\n            end\n        end\n    end\n    \n    assign product = {adder_sum, min_value};\n    \nendmodule\n\nmodule find_min (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output [7:0] min\n);\n    wire [7:0] ab_min;\n    wire [7:0] cd_min;\n    \n    assign ab_min = (a < b) ? a : b;\n    assign cd_min = (c < d) ? c : d;\n    \n    assign min = (ab_min < cd_min) ? ab_min : cd_min;\n    \nendmodule\n\nmodule adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n",
        "module_name": "top_",
        "module_hash": "ec196bf54ead5dc2a590e87fea7bb7c5",
        "dataset_index": 5988
      },
      "mux_4to1_e26b1753": {
        "rtl_code": "module mux_4to1 (\n    output reg Y,\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1\n);\n\nalways @(*) begin\n    case({S1, S0})\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "e26b17532b251e8df84dc04309aac1e3",
        "dataset_index": 12346
      },
      "pixel_reader_71f69b56": {
        "rtl_code": "\n\nmodule pixel_reader (\n  input                     clk,\n  input                     rst,\n\n  input                     i_read_rdy,\n  output  reg               o_read_act,\n  input           [23:0]    i_read_size,\n  input           [24:0]    i_read_data,\n  output  reg               o_read_stb,\n\n  output  reg     [7:0]     o_red,\n  output  reg     [7:0]     o_green,\n  output  reg     [7:0]     o_blue,\n\n  output  reg               o_pixel_rdy,\n  input                     i_pixel_stb,\n\n  input                     i_tp_red,\n  input                     i_tp_blue,\n  input                     i_tp_green,\n\n  output  reg               o_last\n);\nreg               [7:0]     r_next_red;\nreg               [7:0]     r_next_green;\nreg               [7:0]     r_next_blue;\nreg               [31:0]    r_read_count;\nreg                         r_tp_green;\nreg                         r_tp_blue;\nalways @ (posedge clk) begin\n  o_read_stb                <=  0;\n  o_pixel_rdy               <=  0;\n  if (rst) begin\n    o_read_act              <=  0;\n\n    o_red                   <=  0;\n    o_green                 <=  0;\n    o_blue                  <=  0;\n\n    r_next_red              <=  0;\n    r_next_green            <=  0;\n    r_next_blue             <=  0;\n\n    o_last                  <=  0;\n  end\n  else begin\n\n    if (i_read_rdy && !o_read_act) begin\n      r_read_count              <=  0;\n      o_read_act                <=  1;\n    end\n\n    if (o_pixel_rdy) begin\n      if (i_pixel_stb) begin\n        o_pixel_rdy             <=  0;\n        o_red                   <=  i_read_data[23:16];\n        o_green                 <=  i_read_data[15:8];\n        o_blue                  <=  i_read_data[7:0];\n        o_last                  <=  i_read_data[24];\n      end\n    end\n\n    if (o_read_act) begin\n      o_pixel_rdy               <=  1;\n      if (r_read_count < i_read_size) begin\n        if (i_pixel_stb) begin\n          r_read_count          <=  r_read_count + 1;\n          o_read_stb            <=  1;\n        end\n      end\n      else begin\n        o_read_act              <=  0;\n      end\n    end\n  end\nend\n\n\n\nendmodule\n",
        "module_name": "pixel_reader",
        "module_hash": "71f69b562d7a46ac21c4d7a002a3cab6",
        "dataset_index": 22173
      },
      "sky130_fd_sc_ms__a221oi_b12c103e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__a221oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire and0_out  ;\n    wire and1_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , B1, B2                );\n    and and1 (and1_out  , A1, A2                );\n    nor nor0 (nor0_out_Y, and0_out, C1, and1_out);\n    buf buf0 (Y         , nor0_out_Y            );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__a221oi",
        "module_hash": "b12c103e11937aab327edf1450a7b802",
        "dataset_index": 23263
      },
      "sky130_fd_sc_ls__and4_12d56e21": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__and4",
        "module_hash": "12d56e218e43715cb841d61b5aadcc2a",
        "dataset_index": 18967
      },
      "and__2f63068b": {
        "rtl_code": "\nmodule and_module (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule decoder_module (\n    input [1:0] sel,\n    output [3:0] out\n);\n    assign out = (sel == 2'b00) ? 4'b1110 :\n                  (sel == 2'b01) ? 4'b1101 :\n                  (sel == 2'b10) ? 4'b1011 :\n                  (sel == 2'b11) ? 4'b0111 : 4'b0000;\nendmodule\n\nmodule mux_module (\n    input [3:0] a,\n    input [3:0] b,\n    input A,\n    input B,\n    output out\n);\n    wire [3:0] and_out;\n    wire [3:0] decoder_out;\n    \n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .out(and_out)\n    );\n    \n    decoder_module decoder_inst (\n        .sel({A, B}),\n        .out(decoder_out)\n    );\n    \n    assign out = (decoder_out == 4'b1110) ? and_out[0] :\n                  (decoder_out == 4'b1101) ? and_out[1] :\n                  (decoder_out == 4'b1011) ? and_out[2] :\n                  (decoder_out == 4'b0111) ? and_out[3] : 1'b0;\nendmodule\n\nmodule top_module (\n    input [3:0] a,\n    input [3:0] b,\n    input A,\n    input B,\n    output out\n);\n    wire mux_out;\n    mux_module mux_inst (\n        .a(a),\n        .b(b),\n        .A(A),\n        .B(B),\n        .out(mux_out)\n    );\n    \n    assign out = ~mux_out;\nendmodule\n",
        "module_name": "and_",
        "module_hash": "2f63068beee618c5b6b6c7bf6284fcd6",
        "dataset_index": 5977
      },
      "ps2_mouse_datain_f6c70d10": {
        "rtl_code": "\n\nmodule ps2_mouse_datain (\n    input            clk,\n    input            reset,\n    input            wait_for_incoming_data,\n    input            start_receiving_data,\n    input            ps2_clk_posedge,\n    input            ps2_clk_negedge,\n    input            ps2_data,\n    output reg [7:0] received_data,\n    output reg       received_data_en );\n\n  localparam PS2_STATE_0_IDLE          = 3'h0,\n             PS2_STATE_1_WAIT_FOR_DATA = 3'h1,\n             PS2_STATE_2_DATA_IN       = 3'h2,\n             PS2_STATE_3_PARITY_IN     = 3'h3,\n             PS2_STATE_4_STOP_IN       = 3'h4;\n\n  reg [3:0] data_count;\n  reg [7:0] data_shift_reg;\n\n  reg [2:0] ns_ps2_receiver;\n  reg [2:0] s_ps2_receiver;\n\n  always @(posedge clk) begin\n    if (reset == 1'b1) s_ps2_receiver <= PS2_STATE_0_IDLE;\n    else               s_ps2_receiver <= ns_ps2_receiver;\n  end\n\n  always @(*) begin     ns_ps2_receiver = PS2_STATE_0_IDLE;\n\n    case (s_ps2_receiver)\n    PS2_STATE_0_IDLE:\n        begin\n            if((wait_for_incoming_data == 1'b1) && (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n            else if ((start_receiving_data == 1'b1) && (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    PS2_STATE_1_WAIT_FOR_DATA:\n        begin\n            if((ps2_data == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else if (wait_for_incoming_data == 1'b0)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n        end\n    PS2_STATE_2_DATA_IN:\n        begin\n            if((data_count == 3'h7) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n        end\n    PS2_STATE_3_PARITY_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n        end\n    PS2_STATE_4_STOP_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n        end\n    default:\n        begin\n            ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset == 1'b1)     data_count <= 3'h0;\n    else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1))\n        data_count    <= data_count + 3'h1;\n    else if(s_ps2_receiver != PS2_STATE_2_DATA_IN)\n        data_count    <= 3'h0;\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1)     data_shift_reg <= 8'h00;\n    else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1))\n        data_shift_reg    <= {ps2_data, data_shift_reg[7:1]};\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1) received_data <= 8'h00;\n    else if(s_ps2_receiver == PS2_STATE_4_STOP_IN)\n        received_data    <= data_shift_reg;\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1) received_data_en <= 1'b0;\n    else if((s_ps2_receiver == PS2_STATE_4_STOP_IN) && (ps2_clk_posedge == 1'b1))\n        received_data_en    <= 1'b1;\n    else\n        received_data_en    <= 1'b0;\n  end\n\nendmodule\n",
        "module_name": "ps2_mouse_datain",
        "module_hash": "f6c70d1039089c9ed8c608a8be5d23a6",
        "dataset_index": 24727
      },
      "adder_subtractor_0285f351": {
        "rtl_code": "module adder_subtractor(\n  input [3:0] A,\n  input [3:0] B,\n  input SUB,\n  output reg [3:0] S,\n  output reg OVF\n);\n\n  reg [3:0] B_neg;\n  reg C_in;\n  \n  always @ (A or B or SUB) begin\n    if (SUB == 1) begin\n      B_neg = ~B + 1;\n    end else begin\n      B_neg = B;\n    end\n  end\n  \n  always @ (A or B or SUB) begin\n    C_in = SUB & (A < B_neg);\n  end\n  \n  always @ (A or B or SUB) begin\n    if (SUB == 1) begin\n      S = A - B_neg;\n    end else begin\n      S = A + B;\n    end\n  end\n  \n  always @ (A or B or SUB) begin\n    OVF = C_in ^ (S[3] ^ A[3]);\n  end\n  \nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "0285f3515775f48726940c7fea81b92e",
        "dataset_index": 9055
      },
      "ripple_carry_adder_1aeb436b": {
        "rtl_code": "module ripple_carry_adder (\n    input wire [3:0] a, b,\n    output wire [3:0] sum,\n    output wire cout,\n    output wire overflow\n);\n\n    wire [4:0] c;\n    assign c[0] = 1'b0;\n\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : adder\n            full_adder fa(\n                .a(a[i]),\n                .b(b[i]),\n                .cin(c[i]),\n                .sum(sum[i]),\n                .cout(c[i+1])\n            );\n        end\n    endgenerate\n\n    assign cout = c[4];\n    assign overflow = (a[3] & b[3] & ~sum[3]) | (~a[3] & ~b[3] & sum[3]);\n\nendmodule\n\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule greater_than_9 (\n    input wire [3:0] sum,\n    output wire greater_than_9\n);\n\n    assign greater_than_9 = (sum > 4'b1001);\n\nendmodule\n\nmodule top_module (\n    input wire [3:0] a, b,\n    output wire [3:0] sum,\n    output wire cout,\n    output wire overflow,\n    output wire greater_than_9\n);\n\n    ripple_carry_adder rca(\n        .a(a),\n        .b(b),\n        .sum(sum),\n        .cout(cout),\n        .overflow(overflow)\n    );\n\n    greater_than_9 gto9(\n        .sum(sum),\n        .greater_than_9(greater_than_9)\n    );\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "1aeb436bca011d6cd170dc07e398b3df",
        "dataset_index": 212
      },
      "shift_register_6b3d8218": {
        "rtl_code": "module shift_register (\n    input clk,\n    input rst,\n    input [3:0] shift_in,\n    output reg [3:0] shift_out\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        shift_out <= 4'b0000;\n    end else begin\n        shift_out <= {shift_out[2:0], shift_in};\n    end\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "6b3d82188de1ceb259009a1dc4f975e7",
        "dataset_index": 1469
      },
      "DataMemory_7fda27e8": {
        "rtl_code": "\nmodule DataMemory(\n    output reg [31:0] ReadData,\n\t output reg [31:0] DATO1,\n\t output reg [31:0] DATO2,\n\t output reg [31:0] RESULTADO,\n    input [31:0] Address,\n    input [31:0] WriteData,\n\t input [31:0] MouseData,\n\t input MouseEnable,\n    input WriteEnable,\n    input CLK\n    );\n\n\treg [31:0] block [0:9];\n\n\talways @ (*) begin\n\t\tDATO1 = block[4];\n\t\tDATO2 = block[5];\n\t\tRESULTADO = block[7];\n\t\tif (CLK) begin\n\t\t\tcase (Address)\n\t\t\t\t32'h00000000: ReadData = block[0];\n\t\t\t\t32'h00000004: ReadData = block[1];\n\t\t\t\t32'h00000008: ReadData = block[2];\n\t\t\t\t32'h0000000c: ReadData = block[3];\n\t\t\t\t32'h00000010: ReadData = block[4];\n\t\t\t\t32'h00000014: ReadData = block[5];\n\t\t\t\t32'h00000018: ReadData = block[6];\n\t\t\t\t32'h0000001c: ReadData = block[7];\n\t\t\t\t32'h00000020: ReadData = block[8];\n\t\t\t\t32'h00000024: ReadData = block[9];\n\t\t\t\tdefault: ReadData = 32'b0;\n\t\t\tendcase\n\t\tend\n\t\telse begin\n\t\t\tif (MouseEnable) begin\n\t\t\t\tblock[1] = MouseData;\n\t\t\tend\n\t\t\tif (WriteEnable)\n\t\t\t\tcase (Address)\n\t\t\t\t\t32'h00000000: block[0] = WriteData;\n\t\t\t\t\t32'h00000004: block[1] = WriteData;\n\t\t\t\t\t32'h00000008: block[2] = WriteData;\n\t\t\t\t\t32'h0000000c: block[3] = WriteData;\n\t\t\t\t\t32'h00000010: block[4] = WriteData;\n\t\t\t\t\t32'h00000014: block[5] = WriteData;\n\t\t\t\t\t32'h00000018: block[6] = WriteData;\n\t\t\t\t\t32'h0000001c: block[7] = WriteData;\n\t\t\t\t\t32'h00000020: block[8] = WriteData;\n\t\t\t\t\t32'h00000024: block[9] = WriteData;\n\t\t\t\tendcase\n\t\tend\n\tend\n\t\n\tinteger i = 0;\n\tinitial begin \n\t\tfor (i=0;i<10;i=i+1)\n\t\t\tblock[i] = 32'b0;\n\t\tblock[1] = 2;\n\t\tblock[4] = 2;\n\tend\n\nendmodule\n",
        "module_name": "DataMemory",
        "module_hash": "7fda27e81a00f496b0bdd0c210dc82d5",
        "dataset_index": 447
      },
      "key_Processor_f05ae95e": {
        "rtl_code": "\nmodule key_Processor(\n    input select,\n    input [63:0] key,\n    output [28:1] lefto,\n    output [28:1] righto\n);\n\nreg [63:0] temp;\n\nalways @ (select or key) begin\n    // Perform permutation if select is 1, else pass input key as is\n    temp = (select == 1) ? { key[58:57], key[50:49], key[42:41], key[34:33], key[26:25], key[18:17], key[10:9], key[2:1] } : key;\nend\n\n// Split the key into left and right halves\nassign lefto = temp[63:36];\nassign righto = temp[35:2];\n\nendmodule\n",
        "module_name": "key_Processor",
        "module_hash": "f05ae95ef722ed8ed32825c2e2fd5655",
        "dataset_index": 19006
      },
      "spm_16a8f043": {
        "rtl_code": "module spm(clk, rst, x, y, ld, p);\n    parameter size = 32;\n    input clk, rst;\n    input y;\n    input[size-1:0] x;\n    input ld;\n    output p;\n\n    wire[size-1:1] pp;\n    wire[size-1:0] xy;\n\n    genvar i;\n\n    CSADD csa0 (.clk(clk), .rst(rst), .x(x[0]&y), .y(pp[1]), .ld(ld), .sum(p));\n    generate for(i=1; i<size-1; i=i+1) begin\n        CSADD csa (.clk(clk), .rst(rst), .x(x[i]&y), .y(pp[i+1]), .ld(ld), .sum(pp[i]));\n    end endgenerate\n    TCMP tcmp (.clk(clk), .rst(rst), .a(x[size-1]&y), .ld(ld), .s(pp[size-1]));\n\nendmodule\n\nmodule TCMP(clk, rst, a, ld, s);\n    input clk, rst;\n    input a;\n    input ld;\n    output reg s;\n    \n    reg z;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            //Reset logic goes here.\n            s <= 1'b0;\n            z <= 1'b0;\n        end\n        else  if (ld) begin              // idle state reset before each input word\n            s  <= 1'b0;\n            z  <= 1'b0;\n        end\n        else begin\n            //Sequential logic goes here.\n            z <= a | z;\n            s <= a ^ z;\n        end\n    end\nendmodule\n\nmodule CSADD(clk, rst, x, y, ld, sum);\n    input clk, rst;\n    input x, y;\n    input ld;\n    output reg sum;\n\n    reg sc;\n\n    // Half Adders logic\n    wire hsum1, hco1;\n    assign hsum1 = y ^ sc;\n    assign hco1 = y & sc;\n\n    wire hsum2, hco2;\n    assign hsum2 = x ^ hsum1;\n    assign hco2 = x & hsum1;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            //Reset logic goes here.\n            sum <= 1'b0;\n            sc <= 1'b0;\n        end\n        else if (ld) begin\n             sum <= 1'b0;\n             sc  <= 1'b0;\n        end\n        else begin\n            //Sequential logic goes here.\n            sum <= hsum2;\n            sc <= hco1 ^ hco2;\n        end\n    end\nendmodule",
        "module_name": "spm",
        "module_hash": "16a8f04302f315c8487b75f896e4dc2c",
        "dataset_index": 77
      },
      "random_gen_e2e84ec9": {
        "rtl_code": "module random_gen (\n   input clk,      // clock signal\n   input nreset,   // asynchronous reset\n   input WAIT,     // enable signal\n   output reg ready_random // random signal\n   );\n\n   // Generate a random signal when WAIT is asserted\n   reg [8:0] ready_counter;  // Declare the counter register\n\n   // Counter increments on every clock edge\n   always @ (posedge clk or negedge nreset) begin\n      if (!nreset) begin\n         ready_counter <= 9'b0;   // Reset the counter on reset\n      end else begin\n         if (WAIT) begin\n            ready_counter <= ready_counter + 1'b1;  // Increment the counter if WAIT is asserted\n         end\n      end\n   end\n\n   // Generate the random signal based on the counter value\n   always @(*) begin\n      ready_random = ready_counter[5] ^ ready_counter[4];\n   end\n\nendmodule",
        "module_name": "random_gen",
        "module_hash": "e2e84ec975f1c1b4e4a9f7fed4fc5723",
        "dataset_index": 337
      },
      "decoder_c767656e": {
        "rtl_code": "module decoder (\n    input [3:0] in,\n    output [15:0] out\n);\n\nassign out = ~(1 << in);\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "c767656ea6ec0f347c94616bdecb58ee",
        "dataset_index": 7321
      },
      "my__cddf7b5e": {
        "rtl_code": "module my_module (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    output X\n);\n\n    wire and1_out;\n    wire and2_out;\n    wire not1_out;\n\n    and and1 (and1_out, A1, A2);\n    and and2 (and2_out, B1, B2);\n    not not1 (not1_out, and2_out);\n\n    assign X = and1_out & not1_out;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "cddf7b5e2fbc495550bd432ac13c50ea",
        "dataset_index": 4109
      },
      "dat_i_arbiter_276b5301": {
        "rtl_code": "\n\nmodule dat_i_arbiter(\n\t\tinput wire clock_i,\n\n\t\toutput wire [7:0] D,\n\t\t\n\t\tinput [7:0] l_rom,\n\t\tinput l_rom_e,\n\t\t\n\t\tinput [7:0] u_rom,\n\t\tinput u_rom_e,\n\n\t\tinput [7:0] ram,\n\t\tinput ram_e,\n\n\t\tinput [7:0] eram,\n\t\tinput u_ram_e,\n\t\t\n\t\tinput [7:0] pio8255,\n\t\tinput pio8255_e,\n\t\t\n\t\tinput [7:0] io,\n\t\tinput io_e,\n\t\t\n\t\tinput [7:0] fdc,\n\t\tinput fdc_e\n\t);\n\n\tassign D =\t(l_rom_e) ? l_rom :\n\t\t\t\t\t(u_rom_e) ? u_rom :\n\t\t\t\t\t(u_ram_e) ? eram :\n\t\t\t\t\t(ram_e) ? ram :\n\t\t\t\t\t(pio8255_e) ? pio8255 :\n\t\t\t\t\t(io_e) ? io :\n\t\t\t\t\t(fdc_e) ? fdc :\n\t\t\t\t\t8'd255;\nendmodule\n",
        "module_name": "dat_i_arbiter",
        "module_hash": "276b530105bda8df3d57bfb1f71cbbe3",
        "dataset_index": 15016
      },
      "m_4to1_2bit_mux_93ad9d06": {
        "rtl_code": "module m_4to1_2bit_mux (w_bus_mux_out, w_bus_mux_in_0, w_bus_mux_in_1, w_bus_mux_in_2, w_bus_mux_in_3, w_channel);\n\toutput [1:0] w_bus_mux_out;\n\tinput [1:0] w_bus_mux_in_0, w_bus_mux_in_1, w_bus_mux_in_2, w_bus_mux_in_3;\n\tinput [1:0] w_channel;\n\n\tassign w_bus_mux_out = (w_channel == 2'b00) ? w_bus_mux_in_0 :\n\t                       (w_channel == 2'b01) ? w_bus_mux_in_1 :\n\t                       (w_channel == 2'b10) ? w_bus_mux_in_2 :\n\t                                             w_bus_mux_in_3;\nendmodule",
        "module_name": "m_4to1_2bit_mux",
        "module_hash": "93ad9d06d420784ff1a0fb330d6c4ec8",
        "dataset_index": 15070
      },
      "barrel_shifter_4bit_b2a71183": {
        "rtl_code": "module barrel_shifter_4bit (\n    input clk, // Correctly included clock input in the module's port list\n    input [3:0] A,\n    input load,\n    input reset,\n    input [1:0] shift,\n    input shift_dir, // 0 for left shift, 1 for right shift\n    output reg [3:0] Q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        Q <= 4'b0; // Reset the output Q to 0\n    end else if (load) begin\n        Q <= A; // Load the input A into Q\n    end else begin\n        case (shift)\n            2'b00: Q <= Q; // No shift\n            2'b01: begin\n                // Shift once, direction based on shift_dir\n                if (shift_dir) begin\n                    // Right shift\n                    Q <= {1'b0, Q[3:1]};\n                end else begin\n                    // Left shift\n                    Q <= {Q[2:0], 1'b0};\n                end\n            end\n            2'b10: begin\n                // Shift twice, direction based on shift_dir\n                if (shift_dir) begin\n                    // Right shift\n                    Q <= {2'b00, Q[3:2]};\n                end else begin\n                    // Left shift\n                    Q <= {Q[1:0], 2'b00};\n                end\n            end\n            2'b11: begin\n                if (shift_dir) begin\n                    // Right rotate\n                    Q <= {Q[0], Q[3:1]};\n                end else begin\n                    // Left rotate\n                    Q <= {Q[2:0], Q[3]};\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n",
        "module_name": "barrel_shifter_4bit",
        "module_hash": "b2a711833d26a558001f2ab32eceaa68",
        "dataset_index": 756
      },
      "emesh_if_fb96e861": {
        "rtl_code": "\nmodule emesh_if (\n   // Outputs\n   cmesh_ready_out, cmesh_access_out, cmesh_packet_out,\n   rmesh_ready_out, rmesh_access_out, rmesh_packet_out,\n   xmesh_ready_out, xmesh_access_out, xmesh_packet_out,\n   emesh_ready_out, emesh_access_out, emesh_packet_out,\n   // Inputs\n   cmesh_access_in, cmesh_packet_in, cmesh_ready_in, rmesh_access_in,\n   rmesh_packet_in, rmesh_ready_in, xmesh_access_in, xmesh_packet_in,\n   xmesh_ready_in, emesh_access_in, emesh_packet_in, emesh_ready_in\n   );\n\n   parameter AW   = 32;   \n   parameter PW   = 2*AW+40; \n\n   //##Cmesh##    \n   input \t   cmesh_access_in;\n   input [PW-1:0]  cmesh_packet_in;\n   output \t   cmesh_ready_out;\n   output \t   cmesh_access_out;\n   output [PW-1:0] cmesh_packet_out;\n   input \t   cmesh_ready_in;\n      \n   //##Rmesh## \n   input \t   rmesh_access_in;\n   input [PW-1:0]  rmesh_packet_in;\n   output \t   rmesh_ready_out;\n   output \t   rmesh_access_out;\n   output [PW-1:0] rmesh_packet_out;\n   input \t   rmesh_ready_in;\n   \n   //##Xmesh## \n   input \t   xmesh_access_in;\n   input [PW-1:0]  xmesh_packet_in;\n   output \t   xmesh_ready_out;  \n   output \t   xmesh_access_out;\n   output [PW-1:0] xmesh_packet_out;\n   input \t   xmesh_ready_in;\n   \n   //##Emesh##\n   input \t   emesh_access_in;\n   input [PW-1:0]  emesh_packet_in;\n   output \t   emesh_ready_out;\n   output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n   input \t   emesh_ready_in;\n      \n   //#####################################################\n   //# EMESH-->(RMESH/XMESH/CMESH)\n   //#####################################################\n      \n   assign cmesh_access_out = emesh_access_in & emesh_packet_in[0];\n\n   assign rmesh_access_out = emesh_access_in & ~emesh_packet_in[0];\n\n   //Don't drive on xmesh for now\n   assign xmesh_access_out = 1'b0;\n      \n   //Distribute emesh to xmesh,cmesh, rmesh\n   assign cmesh_packet_out = emesh_packet_in;\t \n   assign rmesh_packet_out = emesh_packet_in;\t \n   assign xmesh_packet_out = emesh_packet_in;\n\n   assign emesh_ready_out = cmesh_ready_in &\n\t\t\t    rmesh_ready_in &\n\t\t\t    xmesh_ready_in;\n  \t \t \n   //#####################################################\n   //# (RMESH/XMESH/CMESH)-->EMESH\n   //#####################################################\n\n   assign emesh_access_out = cmesh_access_in &\n\t\t\t     rmesh_access_in &\n\t\t\t     xmesh_access_in;\n   \n   //Choose the module to send packet to in a round-robin fashion\n   reg [1:0] round_robin;\n   always @(posedge emesh_ready_in) begin\n      if (cmesh_access_in) round_robin <= 2'b01;\n      else if (rmesh_access_in) round_robin <= 2'b10;\n      else if (xmesh_access_in) round_robin <= 2'b00;\n   end\n   \n   wire [PW-1:0] sel_packet;\n   assign sel_packet = (round_robin == 2'b01) ? cmesh_packet_in :\n                                     ((round_robin == 2'b10) ? rmesh_packet_in : xmesh_packet_in);\n   \n   assign cmesh_ready_out = ~(cmesh_access_in & ~emesh_ready_in);\n   \n   assign rmesh_ready_out = ~(rmesh_access_in & \n\t\t\t    (~emesh_ready_in | ~cmesh_ready_in));\n\n   assign xmesh_ready_out = ~(xmesh_access_in & \n\t\t\t      (~emesh_ready_in | ~cmesh_access_in | ~rmesh_access_in));\n   \n   assign emesh_packet_out = sel_packet;\n\t\t\t\t     \nendmodule\n",
        "module_name": "emesh_if",
        "module_hash": "fb96e861e8c9e0e67a7a64ccb711f4b7",
        "dataset_index": 5053
      },
      "up_xfer_cntrl_a7b86a45": {
        "rtl_code": "\n\nmodule up_xfer_cntrl (\n\n  up_rstn,\n  up_clk,\n  up_data_cntrl,\n  up_xfer_done,\n\n  d_rst,\n  d_clk,\n  d_data_cntrl);\n\n  parameter     DATA_WIDTH = 8;\n  localparam    DW = DATA_WIDTH - 1;\n\n  input           up_rstn;\n  input           up_clk;\n  input   [DW:0]  up_data_cntrl;\n  output          up_xfer_done;\n\n  input           d_rst;\n  input           d_clk;\n  output  [DW:0]  d_data_cntrl;\n\n  reg             up_xfer_state_m1 = 'd0;\n  reg             up_xfer_state_m2 = 'd0;\n  reg             up_xfer_state = 'd0;\n  reg     [ 5:0]  up_xfer_count = 'd0;\n  reg             up_xfer_done = 'd0;\n  reg             up_xfer_toggle = 'd0;\n  reg     [DW:0]  up_xfer_data = 'd0;\n  reg             d_xfer_toggle_m1 = 'd0;\n  reg             d_xfer_toggle_m2 = 'd0;\n  reg             d_xfer_toggle_m3 = 'd0;\n  reg             d_xfer_toggle = 'd0;\n  reg     [DW:0]  d_data_cntrl = 'd0;\n\n  wire            up_xfer_enable_s;\n  wire            d_xfer_toggle_s;\n\n  assign up_xfer_enable_s = up_xfer_state ^ up_xfer_toggle;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_xfer_state_m1 <= 'd0;\n      up_xfer_state_m2 <= 'd0;\n      up_xfer_state <= 'd0;\n      up_xfer_count <= 'd0;\n      up_xfer_done <= 'd0;\n      up_xfer_toggle <= 'd0;\n      up_xfer_data <= 'd0;\n    end else begin\n      up_xfer_state_m1 <= d_xfer_toggle;\n      up_xfer_state_m2 <= up_xfer_state_m1;\n      up_xfer_state <= up_xfer_state_m2;\n      up_xfer_count <= up_xfer_count + 1'd1;\n      up_xfer_done <= (up_xfer_count == 6'd1) ? ~up_xfer_enable_s : 1'b0;\n      if ((up_xfer_count == 6'd1) && (up_xfer_enable_s == 1'b0)) begin\n        up_xfer_toggle <= ~up_xfer_toggle;\n        up_xfer_data <= up_data_cntrl;\n      end\n    end\n  end\n\n  assign d_xfer_toggle_s = d_xfer_toggle_m3 ^ d_xfer_toggle_m2;\n\n  always @(posedge d_clk or posedge d_rst) begin\n    if (d_rst == 1'b1) begin\n      d_xfer_toggle_m1 <= 'd0;\n      d_xfer_toggle_m2 <= 'd0;\n      d_xfer_toggle_m3 <= 'd0;\n      d_xfer_toggle <= 'd0;\n      d_data_cntrl <= 'd0;\n    end else begin\n      d_xfer_toggle_m1 <= up_xfer_toggle;\n      d_xfer_toggle_m2 <= d_xfer_toggle_m1;\n      d_xfer_toggle_m3 <= d_xfer_toggle_m2;\n      d_xfer_toggle <= d_xfer_toggle_m3;\n      if (d_xfer_toggle_s == 1'b1) begin\n        d_data_cntrl <= up_xfer_data;\n      end\n    end\n  end\n\nendmodule\n\n",
        "module_name": "up_xfer_cntrl",
        "module_hash": "a7b86a45b774c119ad81719734a03b23",
        "dataset_index": 21913
      },
      "mux_ff_72753969": {
        "rtl_code": "\nmodule mux_ff(\n    input clk,\n    input [3:0] in,\n    input [1:0] sel,\n    output reg q\n);\n\n    reg selected_signal;\n\n    // Register initialization\n    initial begin\n        q <= 0;\n    end\n\n    always @(*) begin\n        case (sel)\n            2'b00: selected_signal = in[0];\n            2'b01: selected_signal = in[1];\n            2'b10: selected_signal = in[2];\n            2'b11: selected_signal = in[3];\n        endcase\n    end\n\n    always @(posedge clk) begin\n        q <= selected_signal;\n    end\n\nendmodule",
        "module_name": "mux_ff",
        "module_hash": "72753969edaa3df800ba43826e621be6",
        "dataset_index": 10773
      },
      "binary_counter_c0d1f613": {
        "rtl_code": "\nmodule binary_counter (\n  input clk,\n  input rst,\n  output reg [2:0] count\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter COUNTING = 2'b01;\n  parameter RESET = 2'b10;\n\n  // Define the current state and next state variables\n  reg [1:0] current_state, next_state;\n\n  // Define the counter variable\n  reg [2:0] counter;\n\n  // Assign the initial state to idle and the counter to 0\n  initial begin\n    current_state = IDLE;\n    counter = 3'b000;\n  end\n\n  // Define the state machine\n  always @ (posedge clk) begin\n    // Set the next state based on the current state and inputs\n    case (current_state)\n      IDLE: begin\n        if (rst) begin\n          next_state = RESET;\n        end else begin\n          next_state = COUNTING;\n        end\n      end\n      COUNTING: begin\n        if (counter == 3'b111) begin\n          next_state = IDLE;\n        end else begin\n          next_state = COUNTING;\n        end\n      end\n      RESET: begin\n        next_state = IDLE;\n      end\n    endcase\n\n    // Set the current state to the next state\n    current_state <= next_state;\n\n    // Update the counter based on the current state\n    case (current_state)\n      COUNTING: begin\n        count <= count + 1;\n      end\n      RESET: begin\n        count <= 3'b000;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "c0d1f613a34a6c81c45f8624d5d6ddb0",
        "dataset_index": 12689
      },
      "synchronizer_be8cb949": {
        "rtl_code": "module synchronizer (\n  input async_in,\n  input clk_in,\n  output reg sync_out\n);\n\n  reg async_sync;\n  reg async_sync_prev;\n  \n  always @(posedge clk_in) begin\n    async_sync_prev <= async_sync;\n    async_sync <= async_in;\n  end\n  \n  always @(posedge clk_in) begin\n    if (clk_in) begin\n      sync_out <= async_sync;\n    end else begin\n      sync_out <= async_sync_prev;\n    end\n  end\n  \nendmodule",
        "module_name": "synchronizer",
        "module_hash": "be8cb9495e512abbb8f729afec3ed8a4",
        "dataset_index": 12190
      },
      "top__f7245901": {
        "rtl_code": "\nmodule top_module (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [7:0] data_in,    // 8-bit input data\n    input [2:0] sel,        // 3-bit select input for choosing operation\n    output wire [3:0] q          // 4-bit final output\n);\n\n    // Declare internal wires for intermediate values\n    wire [3:0] q_shifted;      // Result of barrel shift operation\n    wire [3:0] q_decoded;      // Result of decoder with enable operation\n\n    // Barrel shift module\n    // Shift amount is determined by sel[2] and sel[1:0]\n    // (1, 2, or no shift)\n    wire [2:0] shift_amount = {sel[2], sel[1:0]}; // Added braces for clarity\n\n    // Barrel Shifter module `bs`\n    // Connect the wires to the module ports\n    barrel_shifter bs (\n        .clk(clk),\n        .reset(reset),\n        .data_in(data_in),\n        .shift_sel(sel[2:1]), // sel[2:1] is used for shift_sel\n        .shift_amt(shift_amount),\n        .shift_out(q_shifted)\n    );\n\n    // Decoder with enable module\n    // Enable is determined by sel[2], and data_in is the decoded value\n    decoder_with_enable dwen (\n        .data_in(data_in),\n        .enable(sel[2]),\n        .decode_out(q_decoded)\n    );\n\n    // Bitwise OR module\n    // `a` is the result of the barrel shift operation(`q_shifted`),\n    // and `b` is the result of the decoder with enable operation(`q_decoded`)\n    bitwise_or bo (\n        .a(q_shifted),\n        .b(q_decoded),\n        .or_out(q)\n    );\n\nendmodule\n\nmodule barrel_shifter (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [7:0] data_in,    // 8-bit input data\n    input [1:0] shift_sel,  // 2-bit select input for choosing shift direction\n    input [2:0] shift_amt,  // 3-bit select input for choosing shift amount\n    output reg [3:0] shift_out  // 4-bit shifted output\n);\n\n    reg [7:0] shift_reg;    // Shift register\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'b0;\n        end else begin\n            case (shift_sel)\n                2'b00: shift_reg <= shift_reg; // No shift\n                2'b01: shift_reg <= {shift_reg[6:0], 1'b0}; // Shift left by 1\n                2'b10: shift_reg <= {1'b0, shift_reg[7:1]}; // Shift right by 1\n                2'b11: begin // Shift right by 2\n                    shift_reg <= {2'b00, shift_reg[7:2]};\n                end\n            endcase\n\n            case (shift_amt)\n                3'b000: shift_out <= shift_reg[3:0]; // No shift\n                3'b001: shift_out <= shift_reg[4:1]; // Shift left by 1\n                3'b010: shift_out <= shift_reg[5:2]; // Shift right by 1\n                3'b011: shift_out <= shift_reg[6:3]; // Shift right by 2\n                default: shift_out <= 4'bxxxx; // Invalid shift amount\n            endcase\n        end\n    end\n\nendmodule\n\nmodule decoder_with_enable (\n    input [7:0] data_in,    // 8-bit input data\n    input enable,            // Enable input\n    output reg [3:0] decode_out  // 4-bit decoded output\n);\n\n    always @(data_in, enable) begin\n        if (enable) begin\n            case (data_in[7:6])\n                2'b00: decode_out <= 4'b0000;\n                2'b01: decode_out <= 4'b0001;\n                2'b10: decode_out <= 4'b0010;\n                2'b11: decode_out <= 4'b0011;\n            endcase\n        end else begin\n            case (data_in[5:4])\n                2'b00: decode_out <= 4'b0100;\n                2'b01: decode_out <= 4'b0101;\n                2'b10: decode_out <= 4'b0110;\n                2'b11: decode_out <= 4'b0111;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule bitwise_or (\n    input [3:0] a,          // 4-bit input a\n    input [3:0] b,          // 4-bit input b\n    output wire [3:0] or_out // 4-bit bitwise OR output\n);\n\n    assign or_out = a | b;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "f72459012b0cf9408a5be4e8fda7ef27",
        "dataset_index": 2809
      },
      "pipeline_registers #_eee5f41e": {
        "rtl_code": "\nmodule pipeline_registers #(\n  parameter n = 4, // number of input signals\n  parameter m = 2, // number of output signals\n  parameter s = 3 // number of pipeline stages\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk  // Clock signal\n);\n\n\nreg [n-1:0] stage1_reg;\nreg [n-1:0] stage2_reg;\nreg [n-1:0] stage3_reg;\n\nalways @ (posedge clk) begin\n  stage1_reg <= in;\n  stage2_reg <= stage1_reg;\n  stage3_reg <= stage2_reg;\nend\n\n\nassign out = stage3_reg;\n\nendmodule\n\n",
        "module_name": "pipeline_registers #",
        "module_hash": "eee5f41eb2e540f74b31db41770fbe53",
        "dataset_index": 19684
      },
      "four_bit_adder_18cefc2a": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] C;\n\n    assign S = A + B;\n    assign C = (A + B) > 4'b1111;\n\n    assign Cout = C[3];\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "18cefc2ae63a25d19d0a0b65ad540d9d",
        "dataset_index": 6415
      },
      "mux_4to1_and_084253a8": {
        "rtl_code": "\nmodule mux_4to1_and(input [3:0] a, b, c, d, input [1:0] sel, output [3:0] y);\n  wire [3:0] mux1_out, mux2_out;\n\n  // First 2-to-1 MUX\n  mux2to1 mux1(.a(a), .b(b), .sel(sel[0]), .y(mux1_out));\n  \n  // Second 2-to-1 MUX\n  mux2to1 mux2(.a(c), .b(d), .sel(sel[0]), .y(mux2_out));\n  \n  // Final 2-to-1 MUX\n  mux2to1 mux3(.a(mux1_out), .b(mux2_out), .sel(sel[1]), .y(y));\n  \n  // Bitwise AND gate\n  // assign y = y & 4'b1010;\nendmodule\nmodule mux2to1(input [3:0] a, b, input sel, output [3:0] y);\n  assign y = sel ? b : a;\nendmodule",
        "module_name": "mux_4to1_and",
        "module_hash": "084253a8095f69c57e8a363127e3be76",
        "dataset_index": 1630
      },
      "fsm_using_always_013454dd": {
        "rtl_code": "module fsm_using_always (\nclock      , reset      , req_0      , req_1      , gnt_0      , gnt_1      \n);\ninput   clock,reset,req_0,req_1;\n output  gnt_0,gnt_1;\nwire    clock,reset,req_0,req_1;\nreg     gnt_0,gnt_1;\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\nreg   [SIZE-1:0]          state        ;reg   [SIZE-1:0]          next_state   ;always @ (state or req_0 or req_1)\nbegin : FSM_COMBO\n next_state = 3'b000;\n case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else if (req_1 == 1'b1) begin\n                next_state= GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                next_state = GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   default : next_state = IDLE;\n  endcase\nend\nalways @ (posedge clock)\nbegin : FSM_SEQ\n  if (reset == 1'b1) begin\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n  end\nend\nalways @ (posedge clock)\nbegin : OUTPUT_LOGIC\nif (reset == 1'b1) begin\n  gnt_0 <= #1 1'b0;\n  gnt_1 <= #1 1'b0;\nend\nelse begin\n  case(state)\n    IDLE : begin\n                  gnt_0 <= #1 1'b0;\n                  gnt_1 <= #1 1'b0;\n               end\n   GNT0 : begin\n                   gnt_0 <= #1 1'b1;\n                   gnt_1 <= #1 1'b0;\n                end\n   GNT1 : begin\n                   gnt_0 <= #1 1'b0;\n                   gnt_1 <= #1 1'b1;\n                end\n   default : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                  end\n  endcase\nend\nend endmodule // End of Module arbiter",
        "module_name": "fsm_using_always",
        "module_hash": "013454dde991df8a6008ec7ca6dff58c",
        "dataset_index": 23070
      },
      "mux_2to1_9f4ee20d": {
        "rtl_code": "module mux_2to1 (\n    input wire D0, \n    input wire D1,\n    input wire S,\n    input wire RST,\n    input wire CLK,\n    output reg Y\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Y <= 0;\n        end else begin\n            if (S) begin\n                Y <= D1;\n            end else begin\n                Y <= D0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "9f4ee20dfe2a60c3aee235a85293bb69",
        "dataset_index": 10671
      },
      "complement_concat_e5e4abe4": {
        "rtl_code": "\nmodule complement_concat (\n    input clk,\n    input [15:0] data_in,\n    output reg [31:0] comp_concat_out\n);\n\nreg [7:0] data_out1;\nreg [23:0] data_out2;\n\nalways @ (posedge clk) begin\n    data_out1 <= data_in[7:0];\nend\n\nalways @ (posedge clk) begin\n    data_out2 <= ~data_in[15:8];\nend\n\nalways @ (posedge clk) begin\n    comp_concat_out <= {data_out1, data_out2};\nend\n\nendmodule\n",
        "module_name": "complement_concat",
        "module_hash": "e5e4abe43f93945e5d0ed55a94631881",
        "dataset_index": 16921
      },
      "adder_subtractor_418ff124": {
        "rtl_code": "module adder_subtractor (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    output reg [3:0] out\n);\n\nalways @(posedge clk) begin\n    if (mode == 1'b1) // Addition\n        out <= A + B;\n    else // Subtraction\n        out <= A - B;\nend\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "418ff124c7c0b82236ed5d424e1db33c",
        "dataset_index": 10706
      },
      "Latch_96d8e50a": {
        "rtl_code": "module Latch(\n    input D, CLK,\n    output Q, Q_bar\n);\n\nreg Q, Q_bar, D_prev;\n\nalways @(posedge CLK) begin\n    Q <= D_prev;\n    Q_bar <= ~D_prev;\n    D_prev <= D;\nend\n\nendmodule",
        "module_name": "Latch",
        "module_hash": "96d8e50aa8298e2a8da22ac2a5cf937a",
        "dataset_index": 9533
      },
      "erx_remap_062afcf0": {
        "rtl_code": "module erx_remap (\n   emesh_access_out, emesh_packet_out,\n   clk, emesh_access_in, emesh_packet_in, remap_mode, remap_sel,\n   remap_pattern, remap_base\n   );\n\n   parameter AW = 32;\n   parameter DW = 32;\n   parameter PW = 104;\n   parameter ID = 12'h808;\n   \n   input          clk;\n   \n   input          emesh_access_in;\n   input [PW-1:0] emesh_packet_in;\n   \n   input [1:0] \t  remap_mode;    input [11:0]   remap_sel;     input [11:0]   remap_pattern; input [31:0]   remap_base;    output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n\n   wire [31:0] \t   static_remap;\n   wire [31:0] \t   dynamic_remap;\n   wire [31:0] \t   remap_mux;\n   wire [31:0] \t   addr_in;\n   wire [31:0] \t   addr_out;\n   wire \t   remap_en;\n   \n   reg \t\t   emesh_access_out;\n   reg [PW-1:0]    emesh_packet_out;\n\n   parameter[5:0]  colid = ID[5:0];\n   \n   assign addr_in[31:0]  =  emesh_packet_in[39:8];\n \n   \n   assign static_remap[31:20] = (remap_sel[11:0] & remap_pattern[11:0]) |\n\t\t\t        (~remap_sel[11:0] & addr_in[31:20]);\n\n   assign static_remap[19:0]  = addr_in[19:0];\n    \n   assign dynamic_remap[31:0] = addr_in[31:0]    - (colid << 20)     + remap_base[31:0]  - (addr_in[31:26]<<$clog2(colid));\n     \t\t\t     \n   assign remap_mux[31:0]  = (addr_in[31:20]==ID)     ? addr_in[31:0] : (remap_mode[1:0]==2'b00) ? addr_in[31:0] :\n\t\t\t     (remap_mode[1:0]==2'b01) ? static_remap[31:0] :\n\t  \t\t                                dynamic_remap[31:0];\n\n   always @ (posedge clk)\n       emesh_access_out <= emesh_access_in;\n\n   always @ (posedge clk)    \n       emesh_packet_out[PW-1:0] <= {emesh_packet_in[103:40],\n                                    remap_mux[31:0],\n                                    emesh_packet_in[7:0]\n\t\t\t\t    };\n   \nendmodule ",
        "module_name": "erx_remap",
        "module_hash": "062afcf0999f5fc5fb094d47c053b077",
        "dataset_index": 25206
      },
      "lfsr_counter_37ce4ed7": {
        "rtl_code": "module lfsr_counter(\n  input clk, reset,\n  output reg [SIZE-1:0] out\n);\n\n  parameter SIZE = 4;\n\n  reg [SIZE-1:0] state;\n\n  always @(posedge clk or posedge reset)\n    begin\n      if (reset) begin\n        state <= 0;\n        out <= 0;\n      end\n      else begin\n        state <= {state[SIZE-2:0], state[SIZE-1] ^ state[SIZE-2] ^ 1'b1};\n        out <= state;\n      end\n    end\nendmodule",
        "module_name": "lfsr_counter",
        "module_hash": "37ce4ed730714120c2f62acbc444d98a",
        "dataset_index": 9610
      },
      "cordic_stage_17cd47a0": {
        "rtl_code": "module cordic_stage( clock, reset, enable, xi,yi,zi,constant,xo,yo,zo);\n   parameter bitwidth = 16;\n   parameter zwidth = 16;\n   parameter shift = 1;\n   \n   input     clock;\n   input     reset;\n   input     enable;\n   input [bitwidth-1:0] xi,yi;\n   input [zwidth-1:0] zi;\n   input [zwidth-1:0] constant;\n   output [bitwidth-1:0] xo,yo;\n   output [zwidth-1:0] zo;\n   \n   wire z_is_pos = ~zi[zwidth-1];\n\n   reg [bitwidth-1:0] \t xo,yo;\n   reg [zwidth-1:0] zo;\n   \n   always @(posedge clock)\n     if(reset)\n       begin\n\t  xo <= 0;\n\t  yo <= 0;\n\t  zo <= 0;\n       end\n     else begin\n\t  xo <= z_is_pos ?   \n\t\txi - {{shift+1{yi[bitwidth-1]}},yi[bitwidth-2:shift]} :\n\t\txi + {{shift+1{yi[bitwidth-1]}},yi[bitwidth-2:shift]};\n\t  yo <= z_is_pos ?   \n\t\tyi + {{shift+1{xi[bitwidth-1]}},xi[bitwidth-2:shift]} :\n\t\tyi - {{shift+1{xi[bitwidth-1]}},xi[bitwidth-2:shift]};\n\t  zo <= z_is_pos ?   \n\t\tzi - constant :\n\t\tzi + constant;\n       end\nendmodule\n",
        "module_name": "cordic_stage",
        "module_hash": "17cd47a0fd965f61cbe0be470b3b1d7c",
        "dataset_index": 24200
      },
      "matrix_multiplier_4d1f3307": {
        "rtl_code": "module matrix_multiplier(in1, in2, enable, out);\n  input [3:0] in1;\n  input [3:0] in2;\n  input enable;\n  output [3:0] out;\n  \n  wire [3:0] result;\n  \n  assign result = in1 * in2; // multiply the two input vectors\n  \n  assign out = enable ? result : 4'b0; // output the result if enable is high, otherwise output 0\n  \nendmodule",
        "module_name": "matrix_multiplier",
        "module_hash": "4d1f33078d55df1f52e1db01f502a1c7",
        "dataset_index": 16581
      },
      "spi_engine_interconnect_fbe89adf": {
        "rtl_code": "\n\nmodule spi_engine_interconnect (\n\tinput clk,\n\tinput resetn,\n\n\toutput m_cmd_valid,\n\tinput m_cmd_ready,\n\toutput [15:0] m_cmd_data,\n\n\toutput m_sdo_valid,\n\tinput m_sdo_ready,\n\toutput [7:0] m_sdo_data,\n\n\tinput m_sdi_valid,\n\toutput m_sdi_ready,\n\tinput [7:0] m_sdi_data,\n\n\tinput m_sync_valid,\n\toutput m_sync_ready,\n\tinput [7:0] m_sync,\n\n\n\tinput s0_cmd_valid,\n\toutput s0_cmd_ready,\n\tinput [15:0] s0_cmd_data,\n\n\tinput s0_sdo_valid,\n\toutput s0_sdo_ready,\n\tinput [7:0] s0_sdo_data,\n\n\toutput s0_sdi_valid,\n\tinput s0_sdi_ready,\n\toutput [7:0] s0_sdi_data,\n\n\toutput s0_sync_valid,\n\tinput s0_sync_ready,\n\toutput [7:0] s0_sync,\n\n\n\tinput s1_cmd_valid,\n\toutput s1_cmd_ready,\n\tinput [15:0] s1_cmd_data,\n\n\tinput s1_sdo_valid,\n\toutput s1_sdo_ready,\n\tinput [7:0] s1_sdo_data,\n\n\toutput s1_sdi_valid,\n\tinput s1_sdi_ready,\n\toutput [7:0] s1_sdi_data,\n\n\toutput s1_sync_valid,\n\tinput s1_sync_ready,\n\toutput [7:0] s1_sync\n);\n\nreg s_active = 1'b0;\n\nreg idle = 1'b1;\n\n`define spi_engine_interconnect_mux(s0, s1) (idle == 1'b1 ? 1'b0 : (s_active == 1'b0 ? s0 : s1))\n\nassign m_cmd_data   = s_active == 1'b0 ? s0_cmd_data : s1_cmd_data;\nassign m_cmd_valid  = `spi_engine_interconnect_mux(s0_cmd_valid, s1_cmd_valid);\nassign s0_cmd_ready = `spi_engine_interconnect_mux(m_cmd_ready, 1'b0);\nassign s1_cmd_ready = `spi_engine_interconnect_mux(1'b0, m_cmd_ready);\n\nassign m_sdo_data   = s_active == 1'b0 ? s0_sdo_data : s1_sdo_data;\nassign m_sdo_valid  = `spi_engine_interconnect_mux(s0_sdo_valid, s1_sdo_valid);\nassign s0_sdo_ready = `spi_engine_interconnect_mux(m_sdo_ready, 1'b0);\nassign s1_sdo_ready = `spi_engine_interconnect_mux(1'b0, m_sdo_ready);\n\nassign s0_sdi_data  = m_sdi_data;\nassign s1_sdi_data  = m_sdi_data;\nassign m_sdi_ready  = `spi_engine_interconnect_mux(s0_sdi_ready, s1_sdi_ready);\nassign s0_sdi_valid = `spi_engine_interconnect_mux(m_sdi_valid, 1'b0);\nassign s1_sdi_valid = `spi_engine_interconnect_mux(1'b0, m_sdi_valid);\n\nassign s0_sync       = m_sync;\nassign s1_sync       = m_sync;\nassign m_sync_ready  = `spi_engine_interconnect_mux(s0_sync_ready, s1_sync_ready);\nassign s0_sync_valid = `spi_engine_interconnect_mux(m_sync_valid, 1'b0);\nassign s1_sync_valid = `spi_engine_interconnect_mux(1'b0, m_sync_valid);\n\nalways @(posedge clk) begin\n\tif (idle == 1'b1) begin\n\t\tif (s0_cmd_valid)\n\t\t\ts_active <= 1'b0;\n\t\telse if (s1_cmd_valid)\n\t\t\ts_active <= 1'b1;\n\tend\nend\n\nalways @(posedge clk) begin\n\tif (resetn == 1'b0) begin\n\t\tidle = 1'b1;\n\tend else begin\n\t\tif (m_sync_valid == 1'b1 && m_sync_ready == 1'b1) begin\n\t\t\tidle <= 1'b1;\n\t\tend else if (s0_cmd_valid == 1'b1 || s1_cmd_valid == 1'b1) begin\n\t\t\tidle <= 1'b0;\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "spi_engine_interconnect",
        "module_hash": "fbe89adff6e667f1973ad2204c832f96",
        "dataset_index": 13969
      },
      "rotator_97701d85": {
        "rtl_code": "module rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nreg [99:0] pipeline_reg [2:0];\n\nalways @(posedge clk) begin\n    if (load) begin\n        pipeline_reg[0] <= data;\n        pipeline_reg[1] <= 100'b0;\n        pipeline_reg[2] <= 100'b0;\n    end else if (ena == 2'b01) begin\n        pipeline_reg[0] <= {pipeline_reg[0][98:0], pipeline_reg[2][0]};\n        pipeline_reg[1] <= pipeline_reg[0];\n        pipeline_reg[2] <= {pipeline_reg[2][98:0], pipeline_reg[0][0]};\n    end else if (ena == 2'b10) begin\n        pipeline_reg[0] <= {pipeline_reg[1][98:1], pipeline_reg[0][0]};\n        pipeline_reg[1] <= {pipeline_reg[2][98:1], pipeline_reg[1][0]};\n        pipeline_reg[2] <= pipeline_reg[2];\n    end else begin\n        pipeline_reg[0] <= pipeline_reg[0];\n        pipeline_reg[1] <= pipeline_reg[1];\n        pipeline_reg[2] <= pipeline_reg[2];\n    end\nend\n\nassign q = pipeline_reg[0];\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nrotator rotator_inst(\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(q)\n);\n\nendmodule",
        "module_name": "rotator",
        "module_hash": "97701d85f743d073976f47f79b71da11",
        "dataset_index": 123
      },
      "dualport_RAM_3ff56869": {
        "rtl_code": "module dualport_RAM(clk, d_in_1, d_out_1, addr_1, rd_1, wr_1, d_in_2, d_out_2, addr_2, rd_2, wr_2);\n  \n  input clk;\n\n  input [15:0]d_in_1;\n  output reg [15:0]d_out_1=0;\n  input [7:0]addr_1; input rd_1;\n  input wr_1;\n\n  input [15:0]d_in_2;\n  output reg [15:0]d_out_2=0;\n  input [7:0]addr_2; input rd_2;\n  input wr_2;\n\n\n  reg [7:0] ram [0:31]; always @(negedge clk)\nbegin\n\nif (rd_1) begin\n\t\td_out_1[7:0] <= ram[addr_1];\n\t\td_out_1[15:8] <= ram[addr_1+1];\n\tend\n\telse if(wr_1) begin\n\t\tram[addr_1] <= d_in_1[7:0];\n\t\tram[addr_1+1] <= d_in_1[15:8];\n\tend\n\nelse if (rd_2) begin\n\t\td_out_2[7:0] <= ram[addr_2];\n\t\td_out_2[15:8] <= ram[addr_2+1];\n\tend\n\telse if(wr_2) begin\n\t\tram[addr_2] <= d_in_2[7:0];\n\t\tram[addr_2+1] <= d_in_2[15:8];\n\tend\nend\n\n\n\n\nendmodule\n",
        "module_name": "dualport_RAM",
        "module_hash": "3ff56869f3c7106d575610c7cef990aa",
        "dataset_index": 25418
      },
      "comparator_4bit_8f4c32d8": {
        "rtl_code": "module comparator_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  output reg EQ\n);\n\n  always @(*) begin\n    if (A == B) begin\n      EQ = 1;\n    end else begin\n      EQ = 0;\n    end\n  end\n\nendmodule\n",
        "module_name": "comparator_4bit",
        "module_hash": "8f4c32d8d3afc992311a6ec8a3b5c93e",
        "dataset_index": 2907
      },
      "PAD_BANK2_e22dc3d9": {
        "rtl_code": "\nmodule PAD_BANK2(PAD, PADIN, PADOUT, PADOEN);\n  inout PAD;\n  output PADIN;\n  input PADOEN;\n  input PADOUT;\n\n  reg PAD_drv_reg;\n  assign PAD = (PADOEN & ~PADOUT) ? PAD_drv_reg : 1'b1;\n  assign PADIN = PAD_drv_reg;\n\n  always @(*) begin\n    PAD_drv_reg = PADOUT;\n  end\n\nendmodule",
        "module_name": "PAD_BANK2",
        "module_hash": "e22dc3d944177bb777979ae9022ec5b4",
        "dataset_index": 4147
      },
      "bitwise_op_635c92df": {
        "rtl_code": "module bitwise_op(input [7:0] A, input [7:0] B, input [1:0] C, output reg [7:0] out);\n    always @(*) begin\n        case(C)\n            2'b00: out = A & B;\n            2'b01: out = A | B;\n            2'b10: out = A ^ B;\n            2'b11: out = ~(A ^ B);\n        endcase\n    end\nendmodule",
        "module_name": "bitwise_op",
        "module_hash": "635c92df40f7eb848fd7ffe8fe5251f0",
        "dataset_index": 11719
      },
      "binary_to_gray_aaa06383": {
        "rtl_code": "module binary_to_gray(\n    input [3:0] bin_in,\n    output [3:0] gray_out\n);\n\n    assign gray_out[3] = bin_in[3];\n    assign gray_out[2] = bin_in[3] ^ bin_in[2];\n    assign gray_out[1] = bin_in[2] ^ bin_in[1];\n    assign gray_out[0] = bin_in[1] ^ bin_in[0];\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "aaa06383e9f2ad26aad0804bce22d910",
        "dataset_index": 16317
      },
      "encodeBcd10to4_c8b7a060": {
        "rtl_code": "module encodeBcd10to4(in, out);\n\tinput [0:8]in;\n\toutput [0:3]out;\n\twire and0out, and1out, and2out, and3out, and4out, and5out, and6out, and7out, and8out, and9out, and10out, and11out, and12out, nor0out;\n\t\n\tand\n\tandGate0(and0out, ~in[0], in[1], in[3], in[5], nor0out),\n\tandGate1(and1out, ~in[2], in[3], in[5], nor0out),\n\tandGate2(and2out, ~in[4], in[5], nor0out),\n\tandGate3(and3out, ~in[6], nor0out),\n\tandGate4(and4out, ~in[8]),\n\tandGate5(and5out, ~in[1], in[3], in[4], nor0out),\n\tandGate6(and6out, ~in[2], in[3], in[4], nor0out),\n\tandGate7(and7out, ~in[5], nor0out),\n\tandGate8(and8out, ~in[6], nor0out),\n\tandGate9(and9out, ~in[3], nor0out),\n\tandGate10(and10out, ~in[4], nor0out),\n\tandGate11(and11out, ~in[5], nor0out),\n\tandGate12(and12out, ~in[6], nor0out);\n\t\n\tnor\n\tnorGate0(nor0out, ~in[7], ~in[8]),\n\tnorGate1(out[0], and0out, and1out, and2out, and3out, and4out),\n\tnorGate2(out[1], and5out, and6out, and7out, and8out),\n\tnorGate3(out[2], and9out, and10out, and11out, and12out);\n\t\n\tassign out[3] = nor0out;\n\t\n\tendmodule",
        "module_name": "encodeBcd10to4",
        "module_hash": "c8b7a06077d1e9cf10b0c1ddd4aa95f0",
        "dataset_index": 23358
      },
      "RoundSaturation #_ea6cb59a": {
        "rtl_code": "module RoundSaturation #(\n  parameter integer IB = 4, // Number of integer bits\n  parameter integer FB = 8 // Number of fractional bits\n)(\n  input signed [IB + FB - 1:0] in,\n  output signed [IB + FB - 1:0] out\n);\n\n\nwire signed [IB + FB - 1:0] in_val;\nwire signed [IB + FB - 1:0] round_val;\nwire signed [IB + FB - 1:0] max_val;\nwire signed [IB + FB - 1:0] min_val;\n\nassign in_val = in * (2 ** FB); // Shift input to left by fb bits to convert to integer\n\nassign round_val = (in_val >= 0) ? ((in_val + (2 ** (FB - 1))) >> FB) : ((in_val - (2 ** (FB - 1))) >> FB); // Round up/down based on fractional part\n\nassign max_val = (2 ** (IB + FB - 1)) - 1; // Calculate maximum representable value\nassign min_val = -(2 ** (IB + FB - 1)); // Calculate minimum representable value\n\nassign out = (round_val > max_val) ? max_val : ((round_val < min_val) ? min_val : round_val); // Saturation: Output rounded value or max/min if out of range\n\nendmodule\n",
        "module_name": "RoundSaturation #",
        "module_hash": "ea6cb59a6a7cdf38b45f68975d248317",
        "dataset_index": 865
      },
      "cic_filter #_06b23247": {
        "rtl_code": "module cic_filter #(\n  parameter N = 3, // order of filter\n  parameter R = 4, // decimation or interpolation factor\n  parameter M = 16 // number of bits in input signal\n) (\n  input [M-1:0] in,\n  input clk,\n  input rst,\n  output [M-1:0] out\n);\n\nreg [M-1:0] integrator_reg = 0; // accumulator for integrator\nreg [M-1:0] comb_reg [0:N-1]; // shift register for comb filter\nreg [M-1:0] decimator_reg = 0; // register for decimator\nreg [M-1:0] interpolator_reg = 0; // register for interpolator\nreg [M-1:0] out_reg = 0; // register for output\n\ninteger i;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    integrator_reg <= 0;\n    for (i = 0; i < N; i = i + 1) begin\n      comb_reg[i] <= 0;\n    end\n    decimator_reg <= 0;\n    interpolator_reg <= 0;\n    out_reg <= 0;\n  end else begin\n    // integrator\n    integrator_reg <= integrator_reg + in;\n    \n    // comb filter\n    comb_reg[0] <= integrator_reg;\n    for (i = 1; i < N; i = i + 1) begin\n      comb_reg[i] <= comb_reg[i-1];\n    end\n    \n    // decimator or interpolator\n    if (R > 1) begin\n      decimator_reg <= decimator_reg + 1;\n      if (decimator_reg == R-1) begin\n        out_reg <= comb_reg[N-1];\n        decimator_reg <= 0;\n      end\n    end else begin\n      interpolator_reg <= interpolator_reg + 1;\n      if (interpolator_reg == R-1) begin\n        out_reg <= comb_reg[N-1];\n        interpolator_reg <= 0;\n      end\n    end\n  end\nend\n\nassign out = out_reg;\n\nendmodule",
        "module_name": "cic_filter #",
        "module_hash": "06b232477561a54216f98e91e68de295",
        "dataset_index": 18128
      },
      "four_input_and_bc55c67e": {
        "rtl_code": "module four_input_and (\n    A1,\n    A2,\n    B1_N,\n    C1,\n    X\n);\n\n    input A1;\n    input A2;\n    input B1_N;\n    input C1;\n    output X;\n\n    wire and1_out;\n    wire and2_out;\n\n    o21ba and1 (\n        .A1(A1),\n        .A2(A2),\n        .B1_N(B1_N),\n        .X(and1_out)\n    );\n\n    o21ba and2 (\n        .A1(A1),\n        .A2(A2),\n        .B1_N(C1),\n        .X(and2_out)\n    );\n\n    assign X = and1_out & and2_out;\n\nendmodule\n\nmodule o21ba (\n    input A1,\n    input A2,\n    input B1_N,\n    output X\n);\n\n    // Implementing the logic: X = A1 & A2 & ~B1_N\n    assign X = A1 & A2 & ~B1_N;\n\nendmodule\n",
        "module_name": "four_input_and",
        "module_hash": "bc55c67e16fd4faecf075d7f932def8d",
        "dataset_index": 11025
      },
      "data_storage_5a32a6f1": {
        "rtl_code": "module data_storage(\n    input clk,\n    input reset,\n    input [31:0] in_data,\n    input in_valid,\n    output reg [31:0] out_data,\n    output reg out_valid\n);\n\nreg [31:0] stored_data;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        stored_data <= 0;\n        out_valid <= 0;\n    end else if (in_valid) begin\n        stored_data <= in_data;\n        out_valid <= 1;\n    end else begin\n        out_valid <= 0;\n    end\nend\n\nalways @* begin\n    out_data = stored_data;\nend\n\nendmodule",
        "module_name": "data_storage",
        "module_hash": "5a32a6f1383cea8ba6f8e8f3dc0113b5",
        "dataset_index": 5854
      },
      "top__95ca43f3": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input [2:0] sel,\n    output [3:0] out,\n    output parity,\n    output overflow\n);\n\n    wire [7:0] sum;\n    wire add_overflow;\n    add_overflow_detection adder(a, b, sum, add_overflow);\n\n    wire [3:0] data0;\n    wire [3:0] data1;\n    wire [3:0] data2;\n    wire [3:0] data3;\n    wire [3:0] data4;\n    wire [3:0] data5;\n\n    assign data0 = a[3:0];\n    assign data1 = b[3:0];\n    assign data2 = sum[3:0];\n    assign data3 = 4'b0;\n    assign data4 = 4'b0;\n    assign data5 = 4'b0;\n\n    reg [3:0] out_reg;\n    reg overflow_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out_reg <= 4'b0;\n            overflow_reg <= 1'b0;\n        end else begin\n            case (sel)\n                3'b000: begin\n                    out_reg <= data0;\n                end\n                3'b001: begin\n                    out_reg <= data1;\n                end\n                3'b010: begin\n                    out_reg <= data2;\n                    overflow_reg <= add_overflow;\n                end\n                default: begin\n                    out_reg <= 4'b0;\n                    overflow_reg <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    mux mux_parity(sel, data0, data1, data2, data3, data4, data5, parity);\n\n    assign out = out_reg;\n    assign overflow = overflow_reg;\n\nendmodule\n\nmodule add_overflow_detection (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule\n\nmodule mux (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg parity\n);\n\n    always @(*) begin\n        case (sel)\n            3'b000: parity = ^data0;\n            3'b001: parity = ^data1;\n            3'b010: parity = ^data2;\n            3'b011: parity = ^data3;\n            3'b100: parity = ^data4;\n            3'b101: parity = ^data5;\n            default: parity = 1'b0;\n        endcase\n    end\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "95ca43f37072ebc57c2d1cae63b92b77",
        "dataset_index": 2348
      },
      "oam_7772401c": {
        "rtl_code": "\nmodule oam (\n  input [7:0] data_a,\n  input [7:0] data_b,\n  input [7:0] address_a,\n  input [7:0] address_b,\n  input clock,\n  input wren_a,\n  input wren_b,\n  output reg [7:0] q_a,\n  output reg [7:0] q_b\n);\n\n  // Memory for port A\n  reg [7:0] memory_a[255:0];\n\n  // Memory for port B\n  reg [7:0] memory_b[255:0];\n\n  // Read and write logic for port A\n  always @(posedge clock) begin\n    if (wren_a)\n      memory_a[address_a] <= data_a;\n    q_a <= memory_a[address_a];\n  end\n\n  // Read and write logic for port B\n  always @(posedge clock) begin\n    if (wren_b)\n      memory_b[address_b] <= data_b;\n    q_b <= memory_b[address_b];\n  end\n\nendmodule",
        "module_name": "oam",
        "module_hash": "7772401ca67b26a1837dec07a8b6bce5",
        "dataset_index": 16924
      },
      "mux_2to1_36b95011": {
        "rtl_code": "module mux_2to1 (\n    input in0,\n    input in1,\n    input sel,\n    output reg out\n);\n\n    always @(*) begin\n        if (sel == 1'b0) begin\n            out = in0;\n        end else begin\n            out = in1;\n        end\n    end\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "36b95011391c66c20771e4d86ec90c3c",
        "dataset_index": 4341
      },
      "nonrestore_div #_8b54af9b": {
        "rtl_code": "module nonrestore_div #(\n\tparameter\tNUMERATOR_WIDTH\t\t= 64,\n\tparameter\tDENOMINATOR_WIDTH\t= 64\n)(\n\tinput\t\t\t\t\t\t\t\t\t\tclk,\n\tinput\t\t\t\t\t\t\t\t\t\tclr,\n\tinput\t\t[NUMERATOR_WIDTH\t- 1\t: 0]\tnumer_in,\n\tinput\t\t[DENOMINATOR_WIDTH\t- 1\t: 0]\tdenom_in,\n\toutput\treg\t[NUMERATOR_WIDTH\t- 1\t: 0]\tquot_out,\n\toutput\treg\t[DENOMINATOR_WIDTH\t- 1\t: 0]\trem_out,\n\toutput\treg\t\t\t\t\t\t\t\t\trdy_out\n);\nlocalparam\ts0 = 4'b0001;\nlocalparam\ts1 = 4'b0010;\nlocalparam\ts2 = 4'b0100;\nlocalparam\ts3 = 4'b1000;\n\nlocalparam\tTMPVAR_WIDTH\t\t= NUMERATOR_WIDTH + DENOMINATOR_WIDTH;\nlocalparam\tREM_ITER_MSB\t\t= DENOMINATOR_WIDTH;\nlocalparam\tQUOT_MSB\t\t\t= NUMERATOR_WIDTH - 1;\n\nreg\t\t\t[3\t\t\t\t\t\t: 0]\tstate;\nreg\t\t\t[NUMERATOR_WIDTH\t- 1\t: 0]\tnumer;\nreg\t\t\t[DENOMINATOR_WIDTH\t- 1\t: 0]\tdenom;\nreg\t\t\t[DENOMINATOR_WIDTH\t\t: 0]\tdenom_neg;\nreg\t\t\t[NUMERATOR_WIDTH\t- 1\t: 0]\tquot;\nreg\t\t\t[DENOMINATOR_WIDTH\t- 1 : 0]\trem;\nreg\t\t\t[DENOMINATOR_WIDTH\t\t: 0]\trem_iter;\nreg\t\t\t[7\t\t\t\t\t\t: 0]\tcount;\n\nwire\t\t[DENOMINATOR_WIDTH\t\t: 0]\trem_iter_shift;\nwire\t\t[NUMERATOR_WIDTH\t- 1 : 0]\tquot_shift;\nwire\t\t[DENOMINATOR_WIDTH\t\t: 0]\trem_iter_sum;\n\nassign\t\t{rem_iter_shift, quot_shift} = {rem_iter, quot} << 1;\nassign\t\trem_iter_sum = rem_iter_shift + (rem_iter[REM_ITER_MSB]) ? denom : denom_neg;\n\nalways @ (posedge clk or posedge clr)\nbegin\n\tif (clr) begin\n\t\tstate\t\t<= s0;\n\t\trdy_out\t\t<= 1'b0;\n\t\tnumer\t\t<= 0;\n\t\tdenom\t\t<= 0;\n\t\tdenom_neg\t<= 0;\n\t\tquot\t\t<= 0;\n\t\trem_iter\t<= 0;\n\t\trem\t\t\t<= 0;\n\t\tcount\t\t<= 0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\ts0\t: begin\n\t\t\t\tnumer\t\t<= numer_in;\n\t\t\t\tdenom\t\t<= denom_in;\n\t\t\t\tdenom_neg\t<= {1'b1,~denom_in} + 1;\n\t\t\t\tquot\t\t<= numer_in;\n\t\t\t\trem_iter\t<= 0;\n\t\t\t\tcount\t\t<= 0;\n\t\t\t\tstate\t\t<= s1;\n\t\t\tend\n\t\t\ts1\t: begin\n\t\t\t\tcount\t\t<= count + 1;\n\t\t\t\tquot[QUOT_MSB : 1]\t<= quot_shift[QUOT_MSB : 1];\n\t\t\t\trem_iter\t<= rem_iter_sum;\n\t\t\t\tif (rem_iter_sum[REM_ITER_MSB]) begin\n\t\t\t\t\tquot[0] <= 0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tquot[0] <= 1;\n\t\t\t\tend\n\t\t\t\tif (count == NUMERATOR_WIDTH - 1) begin\n\t\t\t\t\tstate\t<= s2;\n\t\t\t\tend\n\t\t\tend\n\t\t\ts2\t: begin\n\t\t\t\tif (rem_iter[REM_ITER_MSB]) begin\trem \t<= rem_iter + denom;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\trem \t<= rem_iter;\n\t\t\t\tend\n\t\t\t\tstate \t\t<= s3;\n\t\t\tend\n\t\t\ts3\t: begin\n\t\t\t\tquot_out\t<= quot;\n\t\t\t\trem_out\t\t<= rem;\n\t\t\t\trdy_out\t\t<= 1'b1;\n\t\t\tend\n\t\t\tdefault : begin\n\t\t\t\tstate \t\t<= s0;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule\n",
        "module_name": "nonrestore_div #",
        "module_hash": "8b54af9b0af1a41c8ffd18394e851346",
        "dataset_index": 3951
      },
      "instruction_fetch_490a4334": {
        "rtl_code": "module instruction_fetch(\n    input wire clk,\n    input wire nrst,\n    input wire [31:0] addr,\n    input wire rd_cmd,\n    output wire [31:0] instr_dat,\n    output wire busy,\n    output wire err_align,\n    output wire err_bus,\n    output reg [31:0] o_IAddr,\n    output reg o_IRdC,\n    input wire [31:0] i_IData,\n    input wire i_IRdy,\n    input wire i_IErr\n);\n\n    localparam IDLE = 1'b0;\n    localparam WAIT = 1'b1;\n\n    reg [31:0] lch_idata;\n    reg state;\n\n    assign err_align = (rd_cmd == 1'b1 && addr[1:0] != 2'b00);\n\n    wire active = (!err_align && !i_IErr && rd_cmd == 1'b1);\n\n    assign busy = ((active || (state == WAIT)) && !i_IRdy);\n\n    assign err_bus = i_IErr;\n\n    always @(*) begin\n        o_IAddr = 32'b0;\n        o_IRdC = 1'b0;\n\n        if(active) begin\n            o_IAddr = addr;\n            o_IRdC = 1'b1;\n        end\n    end\n\n    always @(posedge clk or negedge nrst) begin\n        if(!nrst) begin\n            state <= IDLE;\n            lch_idata <= {32{1'b0}};\n        end\n        else begin\n            if(state == IDLE && (active && i_IRdy)) begin\n                lch_idata <= i_IData;\n            end\n            else if(state == IDLE && (active && !i_IRdy)) begin\n                state <= !i_IErr ? WAIT : IDLE;\n            end\n            else if(state == WAIT && i_IRdy) begin\n                state <= IDLE;\n                lch_idata <= i_IData;\n            end\n        end\n    end\n\n    assign instr_dat = (active || state == WAIT) ? i_IData : lch_idata;\n\nendmodule",
        "module_name": "instruction_fetch",
        "module_hash": "490a43342aa75016a5682133a1d1ae80",
        "dataset_index": 889
      },
      "sky130_fd_sc_ls__clkdlyinv3sd3_c67f077e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__clkdlyinv3sd3 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__clkdlyinv3sd3",
        "module_hash": "c67f077e70b54c4d4b9db74007cc4fee",
        "dataset_index": 15584
      },
      "pace_catcher_0c6c0239": {
        "rtl_code": "\n\nmodule pace_catcher\n          (\n           clk_fast,\n\t\t\t  clk_slow,\n\t\t\t  signal_i,\n\t\t\t  signal_o\n          );\n\t\t\t \ninput clk_fast;\ninput clk_slow;\ninput signal_i;\noutput signal_o;\n\t\t\t \nparameter COUNT = 15; parameter s_idle = 0;\nparameter s_out = 1;\n\n\nreg[15:0] cnt = 0;\nreg state = 0;\n\nalways @(posedge clk_fast) begin\n\t\tcase(state)\n\t\t\ts_idle:\n\t\t\tbegin\n\t\t\t\tstate <= (signal_i) ? s_out : s_idle;\n\t\t\tend\n\t\t\ts_out:\n\t\t\tbegin\n\t\t\t\tstate <= (cnt >= COUNT) ? s_idle : s_out;\n\t\t\tend\n\t\tendcase\nend\n\nalways @(posedge clk_slow) begin\n\t\tif (state == s_out) cnt <= cnt + 8'b1;\n\t\telse if (state == s_idle) cnt  <= 8'b0;\nend\n\nassign signal_o = (state == s_out);\n\nendmodule\n",
        "module_name": "pace_catcher",
        "module_hash": "0c6c0239ba0a8d5573642e75b2a5f99b",
        "dataset_index": 24249
      },
      "or4_68907dfb": {
        "rtl_code": "module or4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Internal wires\n    wire AB;\n    wire CD;\n    wire ABCD;\n\n    // Implement OR gate logic\n    assign AB = A | B;\n    assign CD = C | D;\n    assign ABCD = AB | CD;\n    assign X = ABCD;\n\nendmodule",
        "module_name": "or4",
        "module_hash": "68907dfb0ed7a24e56f1eff2b2e40edf",
        "dataset_index": 2122
      },
      "DFF_SR_GATED_6d09ddc8": {
        "rtl_code": "module DFF_SR_GATED (D, S, R, G, Q, QN);\ninput  D ;\ninput  S ;\ninput  R ;\ninput  G ;\noutput Q ;\noutput QN ;\nreg Q;\n\nalways @(posedge G)\nbegin\n    if (R == 1'b1)\n        Q <= 1'b0;\n    else if (S == 1'b1)\n        Q <= 1'b1;\n    else\n        Q <= D;\nend\n\nassign QN = ~Q;\n\nendmodule",
        "module_name": "DFF_SR_GATED",
        "module_hash": "6d09ddc823030660f25b0ebd3624eaef",
        "dataset_index": 6624
      },
      "mux_4to1_eeed726b": {
        "rtl_code": "module mux_4to1(\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output reg Y\n);\n\nalways @ (S1 or S0 or A or B or C or D)\nbegin\n    case ({S1, S0})\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "eeed726bea4a5f16b7b3f1d20470cd56",
        "dataset_index": 1035
      },
      "byte_reversal_3ac9957c": {
        "rtl_code": "\nmodule byte_reversal (\n    input [31:0] input_word,\n    output [31:0] output_word\n);\n\n    assign output_word[7:0] = input_word[31:24];\n    assign output_word[15:8] = input_word[23:16];\n    assign output_word[23:16] = input_word[15:8];\n    assign output_word[31:24] = input_word[7:0];\n\nendmodule\nmodule reg_with_reset (\n    input clk,\n    input reset,\n    input [7:0] input_data,\n    output reg [7:0] output_data\n);\n\n    always @(posedge clk) begin\n        if (reset == 0) begin\n            output_data <= 8'h34;\n        end else begin\n            output_data <= input_data;\n        end\n    end\n\nendmodule\nmodule bitwise_or (\n    input [7:0] input_a,\n    input [7:0] input_b,\n    output [7:0] output_data\n);\n\n    assign output_data = input_a | input_b;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] reg_input,\n    input [31:0] byte_input,\n    output [7:0] func_output\n);\n\n    wire [7:0] reg_output;\n    wire [31:0] byte_output;\n\n    reg_with_reset reg_inst (\n        .clk(clk),\n        .reset(reset),\n        .input_data(reg_input),\n        .output_data(reg_output)\n    );\n\n    byte_reversal byte_inst (\n        .input_word(byte_input),\n        .output_word(byte_output)\n    );\n\n    bitwise_or or_inst (\n        .input_a(reg_output),\n        .input_b(byte_output[31:24]),\n        .output_data(func_output)\n    );\n\nendmodule",
        "module_name": "byte_reversal",
        "module_hash": "3ac9957ccb154057fd786af4262af929",
        "dataset_index": 12287
      },
      "rfid_1c5db08e": {
        "rtl_code": "module rfid (\n  input clk,\n  input [7:0] tx_data,\n  input tx_en,\n  input rx_en,\n  output [7:0] rx_data\n);\n\n  // Define modulation scheme used by transmitter block\n  // For simplicity, we will use amplitude shift keying (ASK)\n  reg [1:0] tx_mod;\n  always @ (posedge clk) begin\n    if (tx_en) begin\n      if (tx_data[0]) begin\n        tx_mod <= 2'b11; // High amplitude\n      end else begin\n        tx_mod <= 2'b01; // Low amplitude\n      end\n    end else begin\n      tx_mod <= 2'b00; // No transmission\n    end\n  end\n  \n  // Define decoding algorithm used by receiver block\n  // For simplicity, we will use amplitude detection for ASK\n  reg [7:0] rx_data_reg;\n  always @ (posedge clk) begin\n    if (rx_en) begin\n      if (tx_mod == 2'b11) begin\n        rx_data_reg <= 8'b11111111; // High amplitude detected, set all bits to 1\n      end else begin\n        rx_data_reg <= tx_data; // Low amplitude detected, retrieve original data\n      end\n    end\n  end\n  \n  // Connect inputs to transmitter and receiver blocks\n  assign rx_data = rx_data_reg;\n  \nendmodule",
        "module_name": "rfid",
        "module_hash": "1c5db08ee6d62996ea965720ae6e02be",
        "dataset_index": 17475
      },
      "my_circuit_a2a20c57": {
        "rtl_code": "module my_circuit (\n    Y,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    wire A_and = A1 & A2 & A3;\n    wire A_or = A1 | A2 | A3;\n\n    assign Y = (B1 == 1'b1) ? 1'b1 : ((A_and == 1'b1) || ((A_or - A_and) >= 2'b10));\n\nendmodule",
        "module_name": "my_circuit",
        "module_hash": "a2a20c57ca9a29759f8fb83c93770e39",
        "dataset_index": 7314
      },
      "binary_adder_5fc94162": {
        "rtl_code": "module binary_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input C_in,\n  output [3:0] S\n);\n\n  wire [3:0] sum_wire;\n\n  assign sum_wire = A + B + C_in;\n\n  assign S = sum_wire;\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "5fc941625d764621e81da42492aa1db2",
        "dataset_index": 1662
      },
      "sky130_fd_sc_hdll__isobufsrc_28963a2f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__isobufsrc (\n    X    ,\n    SLEEP,\n    A\n);\n\n    output X    ;\n    input  SLEEP;\n    input  A    ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , SLEEP          );\n    and and0 (and0_out_X, not0_out, A    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__isobufsrc",
        "module_hash": "28963a2fd12e2d36dad59a0f2cf0e35d",
        "dataset_index": 10922
      },
      "Pipeline #_3509dd06": {
        "rtl_code": "\nmodule Pipeline #(\n  parameter n = 4, // number of input signals\n  parameter m = 2, // number of output signals\n  parameter p = 3  // number of pipeline stages\n) (\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\n  wire [n-1:0] stage0_out; // output of stage 0\n  wire [n-1:0] stage1_out; // output of stage 1\n  wire [n-1:0] stage2_out; // output of stage 2\n\n  // instantiate pipeline stages\n  Stage0 #(.n(n)) stage0(\n    .in(in),\n    .out(stage0_out),\n    .clk(clk)\n  );\n\n  Stage1 #(.n(n)) stage1(\n    .in(stage0_out),\n    .out(stage1_out),\n    .clk(clk)\n  );\n\n  Stage2 #(.n(n)) stage2(\n    .in(stage1_out),\n    .out(stage2_out),\n    .clk(clk)\n  );\n\n\n  // output signals are the final output of the last stage of the pipeline\n  assign out = stage2_out[m-1:0];\n\nendmodule\nmodule Stage0 #(\n  parameter n = 4\n) (\n  input [n-1:0] in,\n  output [n-1:0] out,\n  input clk\n);\n\n  reg [n-1:0] reg_out; // pipeline register\n\n  // perform computation in this stage\n  assign out = in + 1;\n\n  // store output in pipeline register\n  always @(posedge clk) begin\n    reg_out <= out;\n  end\n\nendmodule\nmodule Stage1 #(\n  parameter n = 4\n) (\n  input [n-1:0] in,\n  output [n-1:0] out,\n  input clk\n);\n\n  reg [n-1:0] reg_out; // pipeline register\n\n  // perform computation in this stage\n  assign out = in + 2;\n\n  // store output in pipeline register\n  always @(posedge clk) begin\n    reg_out <= out;\n  end\n\nendmodule\nmodule Stage2 #(\n  parameter n = 4\n) (\n  input [n-1:0] in,\n  output [n-1:0] out,\n  input clk\n);\n\n  reg [n-1:0] reg_out; // pipeline register\n\n  // perform computation in this stage\n  assign out = in + 3;\n\n  // store output in pipeline register\n  always @(posedge clk) begin\n    reg_out <= out;\n  end\n\nendmodule",
        "module_name": "Pipeline #",
        "module_hash": "3509dd06fe74e21faff27e74feb01d2e",
        "dataset_index": 14853
      },
      "add_sub_shift_e033ff6b": {
        "rtl_code": "\nmodule add_sub_shift (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    input DIR,\n    input [1:0] AMT,\n    output [3:0] Q\n);\n\nreg [3:0] shifted_A;\nwire [3:0] shifted_B;\n\n// Barrel shifter module\nbarrel_shifter bs(\n    .A(A),\n    .B(B),\n    .DIR(DIR),\n    .AMT(AMT),\n    .Q(shifted_A),\n    .fill(shifted_B)\n);\n\n// Adder-subtractor module\nadder_subtractor as(\n    .A(shifted_A),\n    .B(shifted_B),\n    .mode(mode),\n    .Q(Q)\n);\n\nendmodule\nmodule barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    input DIR,\n    input [1:0] AMT,\n    output [3:0] Q,\n    output [3:0] fill\n);\n\nwire [3:0] shifted_A;\n\nassign shifted_A = (DIR) ? {B[3-AMT[1:0]:0], A[3:AMT[1:0]]} : {A[AMT[1:0]-1:0], B[3:AMT[1:0]]};\n\nassign Q = shifted_A;\nassign fill = (DIR) ? {B[3:AMT[1:0]], shifted_A[AMT[1:0]-1:0]} : {A[AMT[1:0]-1:0], shifted_A[AMT[1:0]-1:0]};\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    output [3:0] Q\n);\n\nassign Q = (mode) ? A - B : A + B;\n\nendmodule",
        "module_name": "add_sub_shift",
        "module_hash": "e033ff6bdcd1480ddef8e1aaee7847d0",
        "dataset_index": 1434
      },
      "audio_codec_d9fed97c": {
        "rtl_code": "module audio_codec (\n  input clk,\n  input rst,\n  input [15:0] audio_in,\n  input [7:0] config_data,\n  input config_en,\n  output [15:0] audio_out,\n  output valid_out\n);\n\nparameter sample_rate = 44100;\nparameter bit_rate = 128;\nparameter channels = 2;\nparameter format = \"MP3\";\n\n// Define internal signals\nreg [15:0] audio_compressed;\nreg [15:0] audio_decompressed;\nreg valid_out;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    audio_compressed <= 0;\n    audio_decompressed <= 0;\n    valid_out <= 0;\n  end else begin\n    if (config_en) begin\n      // Parse configuration data to determine codec settings\n      // For the purpose of this example, we will simply ignore the configuration data\n    end else begin\n      // Apply compression or decompression algorithm to input audio stream\n      // For the purpose of this example, we will simply pass the audio through without compression or decompression\n      audio_compressed <= audio_in;\n      audio_decompressed <= audio_in;\n      valid_out <= 1;\n    end\n  end\nend\n\n// Output compressed or decompressed audio stream\nassign audio_out = (format == \"MP3\") ? audio_compressed : audio_decompressed;\n\nendmodule",
        "module_name": "audio_codec",
        "module_hash": "d9fed97ce24c15271938ee8c190196b2",
        "dataset_index": 2297
      },
      "verilog_mult_32bit_92225527": {
        "rtl_code": "\nmodule verilog_mult_32bit\n#(parameter\n    ID         = 1,\n    NUM_STAGE  = 4,\n    din0_WIDTH = 32,\n    din1_WIDTH = 32,\n    dout_WIDTH = 32\n)(\n    input  wire                  clk,\n    input  wire                  reset,\n    input  wire                  ce,\n    input  wire [din0_WIDTH-1:0] din0,\n    input  wire [din1_WIDTH-1:0] din1,\n    output wire [dout_WIDTH-1:0] dout\n);\n\nwire                  aclk;\nwire                  aclken;\nwire                  a_tvalid;\nwire [31:0]           a_tdata;\nwire                  b_tvalid;\nwire [31:0]           b_tdata;\nwire                  r_tvalid;\nwire [31:0]           r_tdata;\nreg  [din0_WIDTH-1:0] din0_buf1;\nreg  [din1_WIDTH-1:0] din1_buf1;\n\nHLS_accel_fmul_32ns_32ns_32_4_max_dsp #(\n    .ID(ID),\n    .NUM_STAGE(NUM_STAGE),\n    .din0_WIDTH(din0_WIDTH),\n    .din1_WIDTH(din1_WIDTH),\n    .dout_WIDTH(dout_WIDTH)\n) HLS_accel_fmul_32ns_32ns_32_4_max_dsp_u (\n    .aclk(aclk),\n    .aclken(aclken),\n    .a_tvalid(a_tvalid),\n    .a_tdata(a_tdata),\n    .b_tvalid(b_tvalid),\n    .b_tdata(b_tdata),\n    .r_tvalid(r_tvalid),\n    .r_tdata(r_tdata)\n);\n\nassign aclk     = clk;\nassign aclken   = ce;\nassign a_tvalid = 1'b1;\nassign a_tdata  = din0_buf1;\nassign b_tvalid = 1'b1;\nassign b_tdata  = din1_buf1;\nassign dout     = r_tdata;\n\nalways @(posedge clk) begin\n    if (ce) begin\n        din0_buf1 <= din0;\n        din1_buf1 <= din1;\n    end\nend\n\nendmodule\nmodule HLS_accel_fmul_32ns_32ns_32_4_max_dsp\n#(parameter\n    ID         = 1,\n    NUM_STAGE  = 4,\n    din0_WIDTH = 32,\n    din1_WIDTH = 32,\n    dout_WIDTH = 32\n)(\n    input  wire                  aclk,\n    input  wire                  aclken,\n    input  wire                  a_tvalid,\n    input  wire [din0_WIDTH-1:0] a_tdata,\n    input  wire                  b_tvalid,\n    input  wire [din1_WIDTH-1:0] b_tdata,\n    output wire                  r_tvalid,\n    output wire [dout_WIDTH-1:0] r_tdata\n);\n\nreg                   a_tvalid_1;\nreg  [din0_WIDTH-1:0] a_tdata_1;\nreg                   b_tvalid_1;\nreg  [din1_WIDTH-1:0] b_tdata_1;\nreg  [dout_WIDTH-1:0] r_tdata;\nwire                  ap_ce_reg;\n\nalways @(*) begin\n    if (aclken) begin\n        a_tvalid_1  <= a_tvalid;\n        a_tdata_1   <= a_tdata;\n        b_tvalid_1  <= b_tvalid;\n        b_tdata_1   <= b_tdata;\n    end\nend\n\nalways @(posedge aclk) begin\n    if (aclken) begin\n        r_tdata <= a_tdata_1 * b_tdata_1;\n    end\nend\n\nassign ap_ce_reg = 1'b1;\n\nassign r_tvalid = a_tvalid_1 & b_tvalid_1;\n\nendmodule",
        "module_name": "verilog_mult_32bit",
        "module_hash": "92225527df8c8a428260685ba7de09d2",
        "dataset_index": 15027
      },
      "counter_f15a0c2b": {
        "rtl_code": "module counter(\n  input clk,\n  input reset,\n  output reg [3:0] out\n);\n\n  always @(posedge clk) begin\n    if (!reset) begin\n      out <= 4'b0000;\n    end else begin\n      out <= out + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "f15a0c2b0ad48ffda19f60e51e75dbda",
        "dataset_index": 15451
      },
      "serdes_fc_rx_27d84bfd": {
        "rtl_code": "module serdes_fc_rx\n  #(parameter LWMARK = 64,\n    parameter HWMARK = 320)\n    (input clk, input rst,\n     input [15:0] fifo_space, \n     output reg send_xon,\n     output reg send_xoff,\n     input sent);\n    \n   reg [15:0] \t  countdown;\n   reg \t\t  send_xon_int, send_xoff_int;\n   \n   always @(posedge clk)\n     if(rst)\n       begin\n\t  send_xon_int <= 0;\n\t  send_xoff_int <= 0;\n\t  countdown <= 0;\n       end\n     else \n       begin\n\t  send_xon_int <= 0;\n\t  send_xoff_int <= 0;\n\t  if(countdown == 0)\n\t    if(fifo_space < LWMARK)\n\t      begin\n\t\t send_xoff_int <= 1;\n\t\t countdown <= 240;\n\t      end\n\t    else\n\t      ;\n\t  else\n\t    if(fifo_space > HWMARK)\n\t      begin\n\t\t send_xon_int <= 1;\n\t\t countdown <= 0;\n\t      end\n\t    else\n\t      countdown <= countdown - 1;\n       end always @(posedge clk)\n     if(rst)\n       send_xon <= 0;\n     else if(send_xon_int)\n       send_xon <= 1;\n     else if(sent)\n       send_xon <= 0;\n\n   always @(posedge clk)\n     if(rst)\n       send_xoff <= 0;\n     else if(send_xoff_int)\n       send_xoff <= 1;\n     else if(sent)\n       send_xoff <= 0;\n   \nendmodule ",
        "module_name": "serdes_fc_rx",
        "module_hash": "27d84bfdc2627d5836bdb50cf4143477",
        "dataset_index": 24178
      },
      "sky130_fd_sc_ls__o21ai_2_3874012e": {
        "rtl_code": "\nmodule sky130_fd_sc_ls__o21ai_2 (\n    Y,\n    A1,\n    A2,\n    B1,\n    VPWR,\n    VGND,\n    VPB,\n    VNB\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input B1;\n    input VPWR;\n    input VGND;\n    input VPB;\n    input VNB;\n\nendmodule\n\nmodule my_module(\n    out_wire,\n    in_wire1,\n    in_wire2,\n    in_wire3,\n    power,\n    ground,\n    power_bond,\n    ground_bond\n);\n\n    output out_wire;\n    input in_wire1;\n    input in_wire2;\n    input in_wire3;\n    input power;\n    input ground;\n    input power_bond;\n    input ground_bond;\n\n    wire Y;\n    sky130_fd_sc_ls__o21ai_2 base (\n        .Y(Y),\n        .A1(in_wire1),\n        .A2(in_wire2),\n        .B1(in_wire3),\n        .VPWR(power),\n        .VGND(ground),\n        .VPB(power_bond),\n        .VNB(ground_bond)\n    );\n\n    assign out_wire = (in_wire1 & ~in_wire2 & ~in_wire3) |\n                      (~in_wire1 & in_wire2 & ~in_wire3) |\n                      (~in_wire1 & in_wire2 & in_wire3) |\n                      (~in_wire1 & ~in_wire2 & in_wire3);\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o21ai_2",
        "module_hash": "3874012e1ae771a273d210ad542f4a7e",
        "dataset_index": 1649
      },
      "timer_e54ebea0": {
        "rtl_code": "module timer (\n    input clk,\n    input rst,\n    input start,\n    input stop,\n    input reset,\n    input load,\n    input [31:0] value,\n    output interrupt\n);\n\n    reg [31:0] counter;\n    reg [31:0] load_value;\n    reg [1:0] state;\n    reg interrupt_reg;\n\n    parameter IDLE = 2'b00;\n    parameter RUNNING = 2'b01;\n    parameter STOPPED = 2'b10;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            state <= IDLE;\n            interrupt_reg <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= value;\n                    if (load) begin\n                        load_value <= value;\n                        state <= IDLE;\n                    end else if (start) begin\n                        state <= RUNNING;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n                RUNNING: begin\n                    if (stop) begin\n                        state <= STOPPED;\n                    end else if (counter == 0) begin\n                        interrupt_reg <= 1;\n                        state <= IDLE;\n                    end else begin\n                        counter <= counter - 1;\n                        state <= RUNNING;\n                    end\n                end\n                STOPPED: begin\n                    if (start) begin\n                        state <= RUNNING;\n                    end else if (reset) begin\n                        counter <= 0;\n                        state <= IDLE;\n                    end else begin\n                        state <= STOPPED;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign interrupt = interrupt_reg;\n\nendmodule",
        "module_name": "timer",
        "module_hash": "e54ebea044e16b0294a5271475182ca1",
        "dataset_index": 4256
      },
      "axi_protocol_converter_v2_1_7_decerr_slave #_6ae04900": {
        "rtl_code": "\n\n\n \nmodule axi_protocol_converter_v2_1_7_decerr_slave #\n  (\n   parameter integer C_AXI_ID_WIDTH           = 1,\n   parameter integer C_AXI_DATA_WIDTH         = 32,\n   parameter integer C_AXI_BUSER_WIDTH        = 1,\n   parameter integer C_AXI_RUSER_WIDTH        = 1,\n   parameter integer C_AXI_PROTOCOL           = 0,\n   parameter integer C_RESP                   = 2'b11,\n   parameter integer C_IGNORE_ID              = 0\n   )\n  (\n   input   wire                                         ACLK,\n   input   wire                                         ARESETN,\n   input   wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_AWID,\n   input   wire                                         S_AXI_AWVALID,\n   output  wire                                         S_AXI_AWREADY,\n   input   wire                                         S_AXI_WLAST,\n   input   wire                                         S_AXI_WVALID,\n   output  wire                                         S_AXI_WREADY,\n   output  wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_BID,\n   output  wire [1:0]                                   S_AXI_BRESP,\n   output  wire [C_AXI_BUSER_WIDTH-1:0]                 S_AXI_BUSER,\n   output  wire                                         S_AXI_BVALID,\n   input   wire                                         S_AXI_BREADY,\n   input   wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_ARID,\n   input   wire [((C_AXI_PROTOCOL == 1) ? 4 : 8)-1:0]   S_AXI_ARLEN,\n   input   wire                                         S_AXI_ARVALID,\n   output  wire                                         S_AXI_ARREADY,\n   output  wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_RID,\n   output  wire [(C_AXI_DATA_WIDTH-1):0]                S_AXI_RDATA,\n   output  wire [1:0]                                   S_AXI_RRESP,\n   output  wire [C_AXI_RUSER_WIDTH-1:0]                 S_AXI_RUSER,\n   output  wire                                         S_AXI_RLAST,\n   output  wire                                         S_AXI_RVALID,\n   input   wire                                         S_AXI_RREADY\n   );\n   \n  reg s_axi_awready_i;\n  reg s_axi_wready_i;\n  reg s_axi_bvalid_i;\n  reg s_axi_arready_i;\n  reg s_axi_rvalid_i;\n  \n  localparam P_WRITE_IDLE = 2'b00;\n  localparam P_WRITE_DATA = 2'b01;\n  localparam P_WRITE_RESP = 2'b10;\n  localparam P_READ_IDLE  = 2'b00;\n  localparam P_READ_START = 2'b01;\n  localparam P_READ_DATA  = 2'b10;\n  localparam integer  P_AXI4 = 0;\n  localparam integer  P_AXI3 = 1;\n  localparam integer  P_AXILITE = 2;\n   \n  assign S_AXI_BRESP = C_RESP;\n  assign S_AXI_RRESP = C_RESP;\n  assign S_AXI_RDATA = {C_AXI_DATA_WIDTH{1'b0}};\n  assign S_AXI_BUSER = {C_AXI_BUSER_WIDTH{1'b0}};\n  assign S_AXI_RUSER = {C_AXI_RUSER_WIDTH{1'b0}};\n  assign S_AXI_AWREADY = s_axi_awready_i;\n  assign S_AXI_WREADY = s_axi_wready_i;\n  assign S_AXI_BVALID = s_axi_bvalid_i;\n  assign S_AXI_ARREADY = s_axi_arready_i;\n  assign S_AXI_RVALID = s_axi_rvalid_i;\n  \n  generate\n  if (C_AXI_PROTOCOL == P_AXILITE) begin : gen_axilite\n    \n    reg s_axi_rvalid_en;\n    assign S_AXI_RLAST = 1'b1;\n    assign S_AXI_BID = 0;\n    assign S_AXI_RID = 0;\n    \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        s_axi_awready_i <= 1'b0;\n        s_axi_wready_i <= 1'b0;\n        s_axi_bvalid_i <= 1'b0;\n      end else begin\n        if (s_axi_bvalid_i) begin\n          if (S_AXI_BREADY) begin\n            s_axi_bvalid_i <= 1'b0;\n            s_axi_awready_i <= 1'b1;\n          end\n        end else if (S_AXI_WVALID & s_axi_wready_i) begin\n            s_axi_wready_i <= 1'b0;\n            s_axi_bvalid_i <= 1'b1;\n        end else if (S_AXI_AWVALID & s_axi_awready_i) begin\n          s_axi_awready_i <= 1'b0;\n          s_axi_wready_i <= 1'b1;\n        end else begin\n          s_axi_awready_i <= 1'b1;\n        end\n      end\n    end\n           \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        s_axi_arready_i <= 1'b0;\n        s_axi_rvalid_i <= 1'b0;\n        s_axi_rvalid_en <= 1'b0;\n      end else begin\n        if (s_axi_rvalid_i) begin\n          if (S_AXI_RREADY) begin\n            s_axi_rvalid_i <= 1'b0;\n            s_axi_arready_i <= 1'b1;\n          end\n        end else if (s_axi_rvalid_en) begin\n          s_axi_rvalid_en <= 1'b0;\n          s_axi_rvalid_i <= 1'b1;\n        end else if (S_AXI_ARVALID & s_axi_arready_i) begin\n          s_axi_arready_i <= 1'b0;\n          s_axi_rvalid_en <= 1'b1;\n        end else begin\n          s_axi_arready_i <= 1'b1;\n        end\n      end\n    end\n        \n  end else begin : gen_axi\n  \n    reg s_axi_rlast_i;\n    reg [(C_AXI_ID_WIDTH-1):0] s_axi_bid_i;\n    reg [(C_AXI_ID_WIDTH-1):0] s_axi_rid_i;\n    reg [((C_AXI_PROTOCOL == 1) ? 4 : 8)-1:0] read_cnt;\n    reg [1:0] write_cs;\n    reg [1:0] read_cs;\n  \n    assign S_AXI_RLAST = s_axi_rlast_i;\n    assign S_AXI_BID = C_IGNORE_ID ? 0 : s_axi_bid_i;\n    assign S_AXI_RID = C_IGNORE_ID ? 0 : s_axi_rid_i;\n  \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        write_cs <= P_WRITE_IDLE;\n        s_axi_awready_i <= 1'b0;\n        s_axi_wready_i <= 1'b0;\n        s_axi_bvalid_i <= 1'b0;\n        s_axi_bid_i <= 0;\n      end else begin\n        case (write_cs) \n          P_WRITE_IDLE: \n            begin\n              if (S_AXI_AWVALID & s_axi_awready_i) begin\n                s_axi_awready_i <= 1'b0;\n                if (C_IGNORE_ID == 0) s_axi_bid_i <= S_AXI_AWID;\n                s_axi_wready_i <= 1'b1;\n                write_cs <= P_WRITE_DATA;\n              end else begin\n                s_axi_awready_i <= 1'b1;\n              end\n            end\n          P_WRITE_DATA:\n            begin\n              if (S_AXI_WVALID & S_AXI_WLAST) begin\n                s_axi_wready_i <= 1'b0;\n                s_axi_bvalid_i <= 1'b1;\n                write_cs <= P_WRITE_RESP;\n              end\n            end\n          P_WRITE_RESP:\n            begin\n              if (S_AXI_BREADY) begin\n                s_axi_bvalid_i <= 1'b0;\n                s_axi_awready_i <= 1'b1;\n                write_cs <= P_WRITE_IDLE;\n              end\n            end\n        endcase\n      end\n    end\n  \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        read_cs <= P_READ_IDLE;\n        s_axi_arready_i <= 1'b0;\n        s_axi_rvalid_i <= 1'b0;\n        s_axi_rlast_i <= 1'b0;\n        s_axi_rid_i <= 0;\n        read_cnt <= 0;\n      end else begin\n        case (read_cs) \n          P_READ_IDLE: \n            begin\n              if (S_AXI_ARVALID & s_axi_arready_i) begin\n                s_axi_arready_i <= 1'b0;\n                if (C_IGNORE_ID == 0) s_axi_rid_i <= S_AXI_ARID;\n                read_cnt <= S_AXI_ARLEN;\n                s_axi_rlast_i <= (S_AXI_ARLEN == 0);\n                read_cs <= P_READ_START;\n              end else begin\n                s_axi_arready_i <= 1'b1;\n              end\n            end\n          P_READ_START:\n            begin\n              s_axi_rvalid_i <= 1'b1;\n              read_cs <= P_READ_DATA;\n            end\n          P_READ_DATA:\n            begin\n              if (S_AXI_RREADY) begin\n                if (read_cnt == 0) begin\n                  s_axi_rvalid_i <= 1'b0;\n                  s_axi_rlast_i <= 1'b0;\n                  s_axi_arready_i <= 1'b1;\n                  read_cs <= P_READ_IDLE;\n                end else begin\n                  if (read_cnt == 1) begin\n                    s_axi_rlast_i <= 1'b1;\n                  end\n                  read_cnt <= read_cnt - 1;\n                end\n              end\n            end\n        endcase\n      end\n    end\n  \n  end  \n  endgenerate\n\nendmodule\n\n",
        "module_name": "axi_protocol_converter_v2_1_7_decerr_slave #",
        "module_hash": "6ae049007e27de1e517f146dc7e70c7b",
        "dataset_index": 25435
      },
      "nand3_011c4fd1": {
        "rtl_code": "module nand3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = ~(A & B & C);\n\nendmodule",
        "module_name": "nand3",
        "module_hash": "011c4fd17cc512182739642e5e5cb9bc",
        "dataset_index": 4773
      },
      "clkgate_15f01913": {
        "rtl_code": "module clkgate (\n  input   clk_in,\n  input   test_mode,\n  input   clock_en,\n  input   FPGA_SOURCE,\n  output  clk_out\n);\n\nwire clk_enb;\n\n`ifdef FPGA_SOURCE\nassign clk_enb = 1'b1;\n`else\nassign clk_enb = (clk_in & (clock_en | test_mode));\n`endif\n\nassign clk_out = clk_in & clk_enb;\n\nendmodule",
        "module_name": "clkgate",
        "module_hash": "15f019133fda3162097eb1c10185afce",
        "dataset_index": 5949
      },
      "pipeline_register_3bc69630": {
        "rtl_code": "module pipeline_register\n    (\n    input clock,\n    input clrn,\n    input d,\n    input ena,\n    output q\n    );\n\n    reg [2:0] stage_data;\n\n    always @(posedge clock) begin\n        if (clrn == 1'b0) begin\n            stage_data <= 3'b0;\n        end else if (ena == 1'b1) begin\n            stage_data[2] <= d;\n            stage_data[1] <= stage_data[2];\n            stage_data[0] <= stage_data[1];\n        end\n    end\n\n    assign q = stage_data[0];\n\nendmodule",
        "module_name": "pipeline_register",
        "module_hash": "3bc6963089fd119142c9b848c4926654",
        "dataset_index": 10458
      },
      "four_bit_adder_42f1c617": {
        "rtl_code": "module four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [3:0] c;\n    assign c[0] = cin;\n    \n    full_adder fa0(a[0], b[0], c[0], sum[0], c[1]);\n    full_adder fa1(a[1], b[1], c[1], sum[1], c[2]);\n    full_adder fa2(a[2], b[2], c[2], sum[2], c[3]);\n    full_adder fa3(a[3], b[3], c[3], sum[3], cout);\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "42f1c6178dc8786ba095370b7bc3dbac",
        "dataset_index": 5442
      },
      "Control_Register_Block #_8ce8468d": {
        "rtl_code": "module Control_Register_Block #(\n  parameter n = 4, // number of control signals\n  parameter m = 2 // number of enable signals\n\n) (\n  input [n-1:0] ctrl,\n  output [m-1:0] en\n);\n\n\n// Define subsets of control signals for each enable signal\nparameter [n-1:0] en1_ctrls = 4'b0001;\nparameter [n-1:0] en2_ctrls = 4'b0011;\n\n// Implement the functionality of the control register block\nassign en[0] = (ctrl & en1_ctrls) == en1_ctrls;\nassign en[1] = (ctrl & en2_ctrls) == en2_ctrls;\n\nendmodule",
        "module_name": "Control_Register_Block #",
        "module_hash": "8ce8468dac80377cee3a3dad9599d747",
        "dataset_index": 1700
      },
      "dual_edge_triggered_ff_4de2d663": {
        "rtl_code": "\nmodule dual_edge_triggered_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q;\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\ndual_edge_triggered_ff ff (\n    .clk(clk),\n    .d(d),\n    .q(q)\n);\n\nendmodule",
        "module_name": "dual_edge_triggered_ff",
        "module_hash": "4de2d663b46fa891114b99053ce94817",
        "dataset_index": 2705
      },
      "reg32_R0_c5fa8953": {
        "rtl_code": "module reg32_R0(Rout, clr, clk, BA_out, write_enable, write_value);\n\tinput clr,clk, write_enable, BA_out;\n\tinput [31:0] write_value;\n\toutput [31:0]Rout;\n\treg[31:0] Rout;\n\n\talways @ (posedge clk)begin\n\t\tif(clr) begin\n\t\t\tRout = 32'h00000000;\n\t\tend\n\t\tif(write_enable && !BA_out) begin\n\t\t\tRout = write_value;\n\t\tend\n\tend\nendmodule",
        "module_name": "reg32_R0",
        "module_hash": "c5fa8953bf001f63c33809fcb6b855e2",
        "dataset_index": 20515
      },
      "pipelined_adder_45ee7613": {
        "rtl_code": "module pipelined_adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\nwire [7:0] p, g, c;\n\nassign p = a ^ b;\nassign g = a & b;\nassign c[0] = 1'b0;\n\ngenvar i;\n\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin : carry_lookahead\n        assign c[i] = g[i-1] | (p[i-1] & c[i-1]);\n    end\nendgenerate\n\nassign s = a + b + c;\n\nassign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\n\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\npipelined_adder adder(a, b, s, overflow);\n\nendmodule",
        "module_name": "pipelined_adder",
        "module_hash": "45ee76136fbcd43c0d0aef7099dc86a7",
        "dataset_index": 2900
      },
      "single_port_ram #_a6c31fb1": {
        "rtl_code": "module single_port_ram #(\n  parameter addr_width = 8,\n  parameter data_width = 8\n)(\n  input clock,\n  input [addr_width-1:0] addr,\n  input [data_width-1:0] data,\n  input we,\n  output reg [data_width-1:0] out\n);\n\n  parameter mem_depth = 1024;\n\n  reg [data_width-1:0] Mem [0:mem_depth-1];\n\n  always @(posedge clock) begin\n    if (we) begin\n      Mem[addr] <= data;\n    end\n    out <= Mem[addr];\n  end\n\nendmodule",
        "module_name": "single_port_ram #",
        "module_hash": "a6c31fb1e987260e06702ed394789314",
        "dataset_index": 7102
      },
      "audio_codec_782178ec": {
        "rtl_code": "\nmodule audio_codec (\n  input [n-1:0] in,\n  input clk, \n  input ctrl_in,\n  output [m-1:0] out,\n  output reg ctrl_out \n);\n\nparameter n = 16; \nparameter m = 16; \nparameter fs = 44100; \nparameter bitrate = 128; \nparameter mode = \"MP3\"; \n\nreg [m-1:0] out_reg; \nassign out = out_reg; \n\nalways @ (posedge clk) begin\n  if (ctrl_in == 1'b0) begin\n    ctrl_out <= 1'b0; \n    out_reg <= {16{1'b0}}; \n  end else begin\n    ctrl_out <= 1'b1; \n    out_reg <= {16{1'b0}}; \n  end\nend\n\nendmodule",
        "module_name": "audio_codec",
        "module_hash": "782178ec54a78fec2a385caf6f8fcc31",
        "dataset_index": 6578
      },
      "mc_ctrl_e6888511": {
        "rtl_code": "module mc_ctrl (\n\tclk\t\t,\n\trstn\t\t,\n\tmc_start_i\t\t,\n\tmc_done_o\t\t,\n  mvd_access_o    ,\n\tchroma_start_o\t\t,\n\tchroma_sel_o\t\t,\n\tchroma_done_i\t\t,\n\ttq_start_o\t\t,\n\ttq_sel_o\t\t,\n\ttq_done_i\t\t\n);\n\n\ninput \t [1-1:0] \t clk \t         ; // clk signal \ninput \t [1-1:0] \t rstn \t         ; // asynchronous reset\ninput \t [1-1:0] \t mc_start_i \t ; // mc start \noutput \t [1-1:0] \t mc_done_o \t ; // mc done \noutput             mvd_access_o ;\noutput \t [1-1:0] \t chroma_start_o  ; // chroma interpolation start \noutput \t [1-1:0] \t chroma_sel_o \t ; // chroma interpolation select: 0:cb, 1:cr\ninput \t [1-1:0] \t chroma_done_i \t ; // chroma interpolation done \noutput \t [1-1:0] \t tq_start_o \t ; // tq start \noutput \t [2-1:0] \t tq_sel_o \t ; // tq sel: 00:luma, 10:cb, 11:cr\ninput \t [1-1:0] \t tq_done_i \t ; // tq done \n\n\nparameter IDLE         = 3'd0;\nparameter TQ_LUMA      = 3'd1;\nparameter MC_CB        = 3'd2;\nparameter TQ_CB        = 3'd3;\nparameter MC_CR        = 3'd4;\nparameter TQ_CR        = 3'd5;\nparameter DONE         = 3'd6;\n\nreg      [3-1:0]        current_state, next_state;\n\nalways @(*) begin\n                next_state = IDLE;\n    case(current_state) \n        IDLE : begin\n            if ( mc_start_i)\n                next_state = TQ_LUMA;\n            else\n                next_state = IDLE;\n        end\n        TQ_LUMA: begin\n            if ( tq_done_i)\n                next_state = MC_CB;\n            else\n                next_state = TQ_LUMA;\n        end\n        MC_CB: begin\n            if ( chroma_done_i)\n                next_state = TQ_CB;\n            else\n                next_state = MC_CB;\n        end\n        TQ_CB: begin\n            if ( tq_done_i)\n                next_state = MC_CR;\n            else\n                next_state = TQ_CB;\n        end\n        MC_CR: begin\n            if ( chroma_done_i)\n                next_state = TQ_CR;\n            else\n                next_state = MC_CR;\n        end\n        TQ_CR: begin\n            if ( tq_done_i)\n                next_state = DONE;\n            else\n                next_state = TQ_CR;\n        end\n        DONE: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n\nassign \t mc_done_o \t = (current_state == DONE); \nassign \t chroma_start_o  = (current_state == TQ_LUMA && next_state == MC_CB)  ||\n                           (current_state == TQ_CB   && next_state == MC_CR)  ; \nassign \t chroma_sel_o \t = (current_state == MC_CR) ? 1'b1 : 1'b0; \nassign \t tq_start_o \t = (current_state == IDLE    && next_state == TQ_LUMA)||\n                           (current_state == MC_CB   && next_state == TQ_CB)  || \n                           (current_state == MC_CR   && next_state == TQ_CR)  ; \nassign \t tq_sel_o \t = (current_state == TQ_LUMA) ? 2'b00 :\n                           (current_state == TQ_CB  ) ? 2'b10 :\n                           (current_state == TQ_CR  ) ? 2'b11 : 2'b00;\n\nassign mvd_access_o = ( current_state == TQ_LUMA );\n\n\nalways @ (posedge clk or negedge rstn) begin\n    if(~rstn) begin\n        current_state <= IDLE;\n    end\n    else begin\n        current_state <= next_state;\n    end\nend\n\n\nendmodule",
        "module_name": "mc_ctrl",
        "module_hash": "e6888511339e5e5ec8010bedb6b048d5",
        "dataset_index": 7414
      },
      "tracking_camera_system_jtag_uart_0_sim_scfifo_r_9b9d6bc6": {
        "rtl_code": "\nmodule tracking_camera_system_jtag_uart_0_sim_scfifo_r (\n  // inputs:\n  input clk,\n  input fifo_rd,\n  input rst_n,\n\n  // outputs:\n  output fifo_EF,\n  output [7:0] fifo_rdata,\n  output rfifo_full,\n  output [5:0] rfifo_used,\n  output [6:0] rfifo_entries\n);\n  reg [31:0] bytes_left;\n  reg fifo_rd_d;\n\n  // Generate rfifo_entries for simulation\n  assign rfifo_entries = bytes_left[5:0];  // Fix the width\n\n  // Decrement bytes_left on read\n  always @(posedge clk) begin\n    if (fifo_rd_d) begin\n      bytes_left <= bytes_left - 1;\n    end\n  end\n\n  // Set fifo_rd_d on reset\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      fifo_rd_d <= 0;\n    end else begin\n      fifo_rd_d <= fifo_rd;\n    end\n  end\n\n  // Set fifo_EF and rfifo_full\n  assign fifo_EF = (bytes_left == 0);\n  assign rfifo_full = (bytes_left > 64);\n\n  // Set fifo_rdata\n  assign fifo_rdata = 8'b0;  // Initialize to 0 for now\n\n  // Set rfifo_used\n  assign rfifo_used = 64 - rfifo_entries;\n\nendmodule",
        "module_name": "tracking_camera_system_jtag_uart_0_sim_scfifo_r",
        "module_hash": "9b9d6bc6736c0c1c651f61934da00772",
        "dataset_index": 10605
      },
      "fifo_02af291a": {
        "rtl_code": "module fifo\n   #(\n  \tparameter adr_width = 4,\n\tparameter dat_width = 8\n   )\n   (\n    input  clk, reset,\n    input  rd, wr,\n    input  [dat_width-1:0] data_in,\n    output [dat_width-1:0] data_out,\n    output empty, \n    output full\n   );\n\n   \n   parameter depth = (1 << adr_width);\n\n   reg [dat_width-1:0] array_reg [depth-1:0];reg [adr_width-1:0] w_ptr_reg, w_ptr_next;\n   reg [adr_width-1:0] r_ptr_reg, r_ptr_next;\n   reg full_reg, empty_reg, full_next, empty_next;\n   wire wr_en;\n\treg\t[1:0]\torden;\n\n\n   assign data_out = array_reg[r_ptr_reg];\n   assign wr_en = wr & ~full_reg;\n\n   assign full = full_reg;\n   assign empty = empty_reg;\n\n   always @(posedge clk) begin\n      if (wr_en)\n         array_reg[w_ptr_reg] <= data_in;\n   end\n\n   always @(posedge clk, posedge reset) begin\n      if (reset)\n         begin\n            w_ptr_reg <= 0;\n            r_ptr_reg <= 0;\n            full_reg <= 1'b0;\n            empty_reg <= 1'b1;\n         end\n      else\n         begin\n            w_ptr_reg <= w_ptr_next;\n            r_ptr_reg <= r_ptr_next;\n            full_reg <= full_next;\n            empty_reg <= empty_next;\n         end\n   end\n\n\talways @(posedge clk)\n\tbegin\n\t\tif(!wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b01;\n\t\tend\n\t\tif(wr&&!rd)\n\t\tbegin\n\t\t\torden = 2'b10;\n\t\tend\n\t\tif(wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b11;\n\t\tend\n\tend\n\n   \n   always @(posedge clk)\n   begin\n      if (reset) begin\n\tw_ptr_next =  0;\n        r_ptr_next =  0;       \n      end else begin\n\t      full_next = full_reg;\n\t      empty_next = empty_reg;\n\t      case (orden)\n\t\t 2'b01: if (~empty_reg) begin\n\t\t          r_ptr_next = r_ptr_reg + 1;\n\t\t          full_next = 1'b0;\n\t\t          if (r_ptr_next==w_ptr_reg)\n\t\t             empty_next = 1'b1;\n\t\t       end\n\t\t 2'b10: if (~full_reg) begin\n\t\t          w_ptr_next = w_ptr_reg + 1;\n\t\t          empty_next = 1'b0;\n\t\t          if (w_ptr_next==r_ptr_reg)\n\t\t             full_next = 1'b1;\n\t\t       end\n\t\t 2'b11: begin\n\t\t       w_ptr_next =  w_ptr_reg + 1;\n\t\t       r_ptr_next = r_ptr_reg + 1;\n\t\t    end\n\t      endcase\n\tend\n   end\n\n\n  \nendmodule\n\n",
        "module_name": "fifo",
        "module_hash": "02af291ad5f44825dd2b9e85baeee208",
        "dataset_index": 24123
      },
      "valve_controller_2e38d3f6": {
        "rtl_code": "module valve_controller\n  (input clk, input reset, input clear,\n   input shutoff,\n   input [35:0] data_i, input src_rdy_i, output dst_rdy_o,\n   output [35:0] data_o, output src_rdy_o, input dst_rdy_i);\n   \n   reg shutoff_int, active;\n   wire active_next = (src_rdy_i & dst_rdy_o) ? ~data_i[33] : active;\n\n   assign data_o = data_i;\n\n   assign dst_rdy_o = shutoff_int ? 1'b1 : dst_rdy_i;\n   assign src_rdy_o = shutoff_int ? 1'b0 : src_rdy_i;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active <= 0;\n     else\n       active <= active_next;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       shutoff_int <= 0;\n     else if(~active_next)\n       shutoff_int <= shutoff;\n   \nendmodule",
        "module_name": "valve_controller",
        "module_hash": "2e38d3f65ddd3a91cdd0175826a9e6a7",
        "dataset_index": 15282
      },
      "mealy_fsm_890a9259": {
        "rtl_code": "module mealy_fsm (\n  input clk,\n  input reset,\n  input in1,\n  input in2,\n  output reg out\n);\n\n  parameter A = 2'b00;\n  parameter B = 2'b01;\n  parameter C = 2'b10;\n  parameter D = 2'b11;\n  \n  reg [1:0] state, next_state;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= A;\n    end else begin\n      state <= next_state;\n    end\n  end\n  \n  always @(*) begin\n    case (state)\n      A: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = A;\n            out = 0;\n          end\n        end\n      end\n      B: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = B;\n            out = 0;\n          end\n        end\n      end\n      C: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = C;\n            out = 1;\n          end\n        end\n      end\n      D: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = D;\n            out = 0;\n          end\n        end\n      end\n      default: begin\n        next_state = A;\n        out = 0;\n      end\n    endcase\n  end\n  \nendmodule\n",
        "module_name": "mealy_fsm",
        "module_hash": "890a9259df30e9e9ebc0b04e6078c5a9",
        "dataset_index": 2144
      },
      "delay_gate_b5c69546": {
        "rtl_code": "module delay_gate (\n  input clk,\n  input data,\n  output delayed_data\n);\n\n  parameter DELAY = 1;\n  reg [DELAY-1:0] data_buffer;\n  reg [DELAY-1:0] delayed_data_buffer;\n  reg [DELAY-1:0] delay_counter;\n\n  always @(posedge clk) begin\n    delay_counter <= delay_counter + 1;\n    if (delay_counter == DELAY) begin\n      delayed_data_buffer <= data_buffer;\n    end\n    data_buffer <= data;\n  end\n\n  assign delayed_data = delayed_data_buffer[DELAY-1];\n\nendmodule",
        "module_name": "delay_gate",
        "module_hash": "b5c69546e58de4f79218982bd8374162",
        "dataset_index": 19240
      },
      "Round_Sgf_Dec_84a34a78": {
        "rtl_code": "\nmodule Round_Sgf_Dec(\n    input wire clk,\n    input wire [1:0] Data_i,\n    input wire [1:0] Round_Type_i,\n    input wire Sign_Result_i,\n    output reg Round_Flag_o\n    );\n    \n    always @*\n    \tcase ({Sign_Result_i,Round_Type_i,Data_i})\n    \t\n\n\t\t\n\n    \t\n\n    \t5'b10101: Round_Flag_o <=1;  \n    \t5'b10110: Round_Flag_o <=1;  \n    \t5'b10111: Round_Flag_o <=1;  \n\n    \t5'b01001: Round_Flag_o <=1;  \n    \t5'b01010: Round_Flag_o <=1;  \n    \t5'b01011: Round_Flag_o <=1;  \n\n\n    \t\n\n    \tdefault: Round_Flag_o <=0;\n\n    \tendcase\n\nendmodule\n",
        "module_name": "Round_Sgf_Dec",
        "module_hash": "84a34a7884d2a0134dc77ab3751738a8",
        "dataset_index": 25795
      },
      "multi_input_output_875d8aff": {
        "rtl_code": "module multi_input_output (\n    input [7:0] A,\n    input [7:0] B,\n    input [7:0] C,\n    input [7:0] D,\n    input [7:0] E,\n    input [7:0] F,\n    input [7:0] G,\n    input [7:0] H,\n    output [7:0] Y\n);\n\n    assign Y = (A + B) - (C + D) + (E + F) - (G + H);\n\nendmodule",
        "module_name": "multi_input_output",
        "module_hash": "875d8afff97d93e9d89fc8e890926768",
        "dataset_index": 10094
      },
      "input_output_module_9e3e7a03": {
        "rtl_code": "module input_output_module(\n    input wire CLK,\n    output reg [6:0] Q\n);\n\nreg [6:0] inputs_reg;\nwire [6:0] inputs_delayed;\n\nalways @(posedge CLK) begin\n    inputs_reg <= Q;\nend\n\nassign inputs_delayed[0] = inputs_reg[6];\nassign inputs_delayed[1] = inputs_reg[5];\nassign inputs_delayed[2] = inputs_reg[4];\nassign inputs_delayed[3] = inputs_reg[3];\nassign inputs_delayed[4] = inputs_reg[2];\nassign inputs_delayed[5] = inputs_reg[1];\nassign inputs_delayed[6] = inputs_reg[0];\n\nreg [6:0] delay_counter;\nreg [2:0] input_counter;\nreg [1:0] state_counter;\n\nalways @(posedge CLK) begin\n    delay_counter <= delay_counter + 1;\n    if (delay_counter == 20) begin\n        delay_counter <= 0;\n        input_counter <= input_counter + 1;\n        if (input_counter == 7) begin\n            input_counter <= 0;\n            state_counter <= state_counter + 1;\n            if (state_counter == 3) begin\n                state_counter <= 0;\n            end\n        end\n    end\nend\n\nreg [6:0] inputs_pattern_0 = 7'b1000000;\nreg [6:0] inputs_pattern_1 = 7'b0111111;\nreg [6:0] inputs_pattern_2 = 7'bxxxxxxx;\n\nalways @(posedge CLK) begin\n    case (state_counter)\n        0: Q <= inputs_pattern_0;\n        1: Q <= inputs_pattern_1;\n        2: Q <= inputs_pattern_2;\n    endcase\nend\n\nwire Q_delayed;\nreg Q_delayed_reg;\nassign Q_delayed = Q;\n\nalways @(posedge CLK) begin\n    Q_delayed_reg <= Q;\nend\n\nendmodule",
        "module_name": "input_output_module",
        "module_hash": "9e3e7a03e69c0b2b19722cf26aec164a",
        "dataset_index": 1976
      },
      "four_to_one_mux_9ccde0e5": {
        "rtl_code": "module four_to_one_mux(\n    input [3:0] in,\n    input [1:0] sel,\n    output reg out\n);\n\nalways @ (*)\n    case(sel)\n        2'b00: out = in[0];\n        2'b01: out = in[1];\n        2'b10: out = in[2];\n        2'b11: out = in[3];\n        default: out = 1'b0;\n    endcase\n\nendmodule",
        "module_name": "four_to_one_mux",
        "module_hash": "9ccde0e53f86dc07f6c07814969a2d9b",
        "dataset_index": 1923
      },
      "v468a05_e9b64b5c": {
        "rtl_code": "\nmodule v468a05 (\n  input [31:0] ve841af,\n  output [7:0] vdd0469,\n  output [7:0] v4ba85d,\n  output [7:0] vf93ecb,\n  output [7:0] vc6471a\n);\n\n  // Instantiate v468a05_v9a2a06 module\n  v468a05_v9a2a06 v9a2a06 (\n    .i(ve841af),\n    .o0(vdd0469),\n    .o1(vf93ecb),\n    .o2(v4ba85d),\n    .o3(vc6471a)\n  );\n\nendmodule\nmodule v468a05_v9a2a06 (\n  input [31:0] i,\n  output [7:0] o0,\n  output [7:0] o1,\n  output [7:0] o2,\n  output [7:0] o3\n);\n\n  wire [31:0] w0;\n  wire [31:0] w1;\n  wire [31:0] w2;\n  wire [31:0] w3;\n  wire [31:0] w4;\n\n  // Assign input to wire\n  assign w0 = i;\n\n  // Xors of i\n  assign w1 = i ^ 32'h09436c12;\n  assign w2 = i ^ 32'h1423bf56;\n  assign w3 = i ^ 32'h22fb9439;\n  assign w4 = i ^ 32'h30648dbc;\n\n  // Assign wires to outputs\n  assign o0 = w1[7:0];\n  assign o1 = w2[7:0];\n  assign o2 = w3[7:0];\n  assign o3 = w4[7:0];\n\nendmodule",
        "module_name": "v468a05",
        "module_hash": "e9b64b5c914f0cc884bb6adaf4a61720",
        "dataset_index": 10084
      },
      "adder_f16cff88": {
        "rtl_code": "module adder (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] sum,\n    output carry_out\n);\n\n    wire [8:0] temp_sum;\n    assign temp_sum = A + B;\n    assign carry_out = temp_sum[8];\n    assign sum = temp_sum[7:0];\n\nendmodule",
        "module_name": "adder",
        "module_hash": "f16cff8861671d1f2ab1b23aea7b2b24",
        "dataset_index": 14209
      },
      "top_module_b30ff500": {
        "rtl_code": "\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    input sel,\n    output [31:0] sum\n);\n\nwire [7:0] adder1_out;\nwire [7:0] adder2_out;\nwire [15:0] adder3_out;\nwire [3:0] mux_out;\n\nmux_3_4 mux_inst(\n    .a(a[23]),\n    .b(a[15]),\n    .c(a[7]),\n    .sel(sel),\n    .y(mux_out)\n);\n\nadd_8 adder1_inst(\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .sum(adder1_out)\n);\n\nadd_8 adder2_inst(\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .sum(adder2_out)\n);\n\nadd_16 adder3_inst(\n    .a(a[31:16]),\n    .b(b[31:16]),\n    .sum(adder3_out)\n);\n\nassign sum = sel ? {mux_out, a[31:23]} + b : a + b;\n\nendmodule\n\nmodule mux_3_4(\n    input a,\n    input b,\n    input c,\n    input sel,\n    output [3:0] y\n);\n\nassign y[0] = (~sel & ~a) & b;\nassign y[1] = (~sel & a) & c;\nassign y[2] = (sel & ~a) & b;\nassign y[3] = (sel & a) & c;\n\nendmodule\n\nmodule add_8(\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n\nassign sum = a + b;\n\nendmodule\n\nmodule add_16(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n\nadd_8 adder1_inst(\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .sum(sum[7:0])\n);\n\nadd_8 adder2_inst(\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .sum(sum[15:8])\n);\n\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "b30ff5004b2e245c042652181c1cb2d8",
        "dataset_index": 18539
      },
      "led_flasher_c6151c8d": {
        "rtl_code": "\n\nmodule led_flasher\n          (\n           clk,\n\t\t\t  LED_flash,\n\t\t\t  LED_out\n          );\n\t\t\t \ninput clk;\ninput LED_flash;\noutput LED_out;\n\t\t\t \nparameter HIGH_PERIOD = 600; parameter LOW_PERIOD = 600; parameter s_reset = 2'd0;\nparameter s_off = 2'd1;\nparameter s_on = 2'd2;\n\n\nreg[15:0] cnt = 0;\nreg [1:0] state = 2'd0;\n\nalways @(posedge clk) begin\n\t\tcase(state)\n\t\t\ts_reset:\n\t\t\t\tbegin\n\t\t\t\t\tcnt  <= 16'd0;\n\t\t\t\t\tstate <= (LED_flash) ? s_on : s_reset;\n\t\t\t\tend\n\t\t\t\n\t\t\ts_off: \n\t\t\t\tbegin\n\t\t\t\t\tstate <= (cnt == LOW_PERIOD && LED_flash) ? s_on : \n\t\t\t\t\t\t\t\t(!LED_flash) ? s_reset : \n\t\t\t\t\t\t\t\ts_off;\n\t\t\t\t\tcnt <= (cnt == LOW_PERIOD && LED_flash) ? 16'd0 : cnt + 16'd1;\n\t\t\t\tend\n\t\t\t\n\t\t\ts_on: \n\t\t\t\tbegin\n\t\t\t\t\tstate <= (cnt == HIGH_PERIOD && LED_flash) ? s_off : \n\t\t\t\t\t\t\t\t(!LED_flash) ? s_reset : \n\t\t\t\t\t\t\t\ts_on;\n\t\t\t\t\tcnt <= (cnt == HIGH_PERIOD && LED_flash) ? 16'd0 : cnt + 16'd1;\n\t\t\t\tend\n\t\tendcase\nend\n\nassign LED_out = (state == s_on);\n\nendmodule\n",
        "module_name": "led_flasher",
        "module_hash": "c6151c8dfed34a7e3a6c1afedac28c2e",
        "dataset_index": 24091
      },
      "d_ff_d8bdf159": {
        "rtl_code": "\nmodule d_ff(\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\nmodule xor_gate(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_xor\n);\n    assign out_xor = a ^ b;\nendmodule\nmodule and_gate(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and\n);\n    assign out_and = a & b;\nendmodule\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    input select,\n    input clk,\n    output reg [2:0] out_xor_bitwise,\n    output reg out_and_logical,\n    output reg [5:0] out_not\n);\n    wire [2:0] xor_out;\n    wire [2:0] and_out;\n    wire [2:0] a_not;\n    wire [2:0] b_not;\n\n    xor_gate xor_inst(.a(a), .b(b), .out_xor(xor_out));\n    and_gate and_inst(.a(a), .b(b), .out_and(and_out));\n    d_ff d_ff_inst_a(.clk(clk), .d(~a[0]), .q(a_not[0]));\n    d_ff d_ff_inst_b(.clk(clk), .d(~b[0]), .q(b_not[0]));\n    d_ff d_ff_inst_a_1(.clk(clk), .d(~a[1]), .q(a_not[1]));\n    d_ff d_ff_inst_b_1(.clk(clk), .d(~b[1]), .q(b_not[1]));\n    d_ff d_ff_inst_a_2(.clk(clk), .d(~a[2]), .q(a_not[2]));\n    d_ff d_ff_inst_b_2(.clk(clk), .d(~b[2]), .q(b_not[2]));\n\n    always @(*) begin\n        if (select == 1'b1) begin\n            out_xor_bitwise <= xor_out;\n            out_and_logical <= and_out[0];\n            out_not[2:0] <= b_not;\n            out_not[5:3] <= a_not;\n        end\n        else begin\n            out_xor_bitwise <= 3'b0;\n            out_and_logical <= 1'b0;\n            out_not <= {~a, ~b, 3'b0, 3'b0};\n        end\n    end\nendmodule",
        "module_name": "d_ff",
        "module_hash": "d8bdf1597dbbf6736348bb24c6b17ec3",
        "dataset_index": 7732
      },
      "async_reset_release_bdce19e3": {
        "rtl_code": "module async_reset_release (\n  input clk,\n  input rst,\n  input in,\n  output out\n);\n\n  reg out_reg; // register to hold the output value\n\n  always @(posedge clk) begin\n    if (rst) begin // reset state\n      out_reg <= 0;\n    end else begin // release state\n      out_reg <= in;\n    end\n  end\n\n  assign out = out_reg;\n\nendmodule",
        "module_name": "async_reset_release",
        "module_hash": "bdce19e30df562254cc7a4e8066a7c3e",
        "dataset_index": 1141
      },
      "sum_4bit_f2b6dd42": {
        "rtl_code": "module sum_4bit(input [3:0] input_a, output reg [4:0] output_sum);\n\nalways @(*) begin\n    output_sum = {1'b0, input_a} + 4'b0001;\nend\n\nendmodule",
        "module_name": "sum_4bit",
        "module_hash": "f2b6dd42511df0f820483866d01d9745",
        "dataset_index": 10603
      },
      "sky130_fd_sc_lp__a21oi_e67edd80": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a21oi",
        "module_hash": "e67edd80014a136d34adfc11385a0cc1",
        "dataset_index": 21680
      },
      "sky130_fd_sc_lp__nor3_62f7bd9b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__nor3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, C, A, B        );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__nor3",
        "module_hash": "62f7bd9b474e52b8138538fe0fe6854b",
        "dataset_index": 20224
      },
      "top__4ae7e6a2": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [1:0] d,\n    output [4:0] q\n);\n\nreg [2:0] shift_reg_async;\nreg [1:0] shift_reg_sync;\n\n// Asynchronous reset for the 3-bit shift register\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        shift_reg_async <= 3'b0;\n    end else begin\n        shift_reg_async <= {shift_reg_async[1:0], d};\n    end\nend\n\n// Synchronous reset for the 2-bit shift register\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg_sync <= 2'b0;\n    end else begin\n        shift_reg_sync <= {shift_reg_sync[0], d[1]};\n    end\nend\n\n// Functional module that combines the two shift registers\nassign q = {shift_reg_async, shift_reg_sync};\n\nendmodule\n\n// Inputs and outputs for the two given modules\nmodule shift_register_async (\n    input clk,\n    input reset,\n    input d,\n    output reg [2:0] q\n);\n\n// Asynchronous reset for the 3-bit shift register\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        q <= 3'b0;\n    end else begin\n        q <= {q[1:0], d};\n    end\nend\n\nendmodule\n\nmodule shift_register_sync (\n    input clk,\n    input reset,\n    input [1:0] d,\n    output reg [1:0] q\n);\n\n// Synchronous reset for the 2-bit shift register\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 2'b0;\n    end else begin\n        q <= {q[0], d[1]};\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "4ae7e6a2e67f71bbc875e10382aef4b7",
        "dataset_index": 5351
      },
      "macc_simple_arst_clr_ena_46465a41": {
        "rtl_code": "module macc_simple_arst_clr_ena (\n    input  wire        clk,\n    input  wire        rst,\n    input  wire        clr,\n    input  wire        ena,\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output reg  [15:0] Z\n);\n\n    always @(posedge clk or posedge rst)\n        if (rst)     Z <= 0;\n        else if (ena) begin\n            if (clr) Z <=     (A * B);\n            else     Z <= Z + (A * B);\n        end\n\nendmodule",
        "module_name": "macc_simple_arst_clr_ena",
        "module_hash": "46465a411450fd7a89b9814700b7678f",
        "dataset_index": 4374
      },
      "hard_sync #_07b32bb4": {
        "rtl_code": "\nmodule hard_sync #(\n    parameter INIT = 1'b0, // optional initialization value\n    parameter IS_CLK_INVERTED = 1'b0, // optional clock inversion\n    parameter LATENCY = 2 // latency of 2 or 3 clock cycles\n)(\n    output reg DOUT,\n    input CLK,\n    input DIN\n);\n\n    reg [2:0] DIN_reg; // register to store input data\n\n    always @(posedge CLK) begin\n        if (IS_CLK_INVERTED) begin // invert clock if enabled\n            DIN_reg <= {DIN_reg[1:0], ~DIN};\n        end else begin\n            DIN_reg <= {DIN_reg[1:0], DIN};\n        end\n\n        if (LATENCY == 2) begin // synchronize output after 2 clock cycles\n            DOUT <= DIN_reg[1];\n        end else begin // synchronize output after 3 clock cycles\n            DOUT <= DIN_reg[2];\n        end\n    end\n\n    initial begin\n        DIN_reg <= {INIT, INIT, INIT}; // initialize register with INIT value\n    end\n\nendmodule",
        "module_name": "hard_sync #",
        "module_hash": "07b32bb4f22646e45fc3fdf81a403442",
        "dataset_index": 6294
      },
      "temperature_sensor_5bf1a5d1": {
        "rtl_code": "module temperature_sensor (\n  input [9:0] analog_in,\n  output reg [3:0] temp_range\n);\n\n  always @* begin\n    case(analog_in)\n      0: temp_range = 4'b0000; // below 0 degrees Celsius\n      1: temp_range = 4'b0001; // below 0 degrees Celsius\n      2: temp_range = 4'b0001; // below 0 degrees Celsius\n      3: temp_range = 4'b0001; // below 0 degrees Celsius\n      4: temp_range = 4'b0001; // below 0 degrees Celsius\n      5: temp_range = 4'b0001; // below 0 degrees Celsius\n      6: temp_range = 4'b0001; // below 0 degrees Celsius\n      7: temp_range = 4'b0001; // below 0 degrees Celsius\n      8: temp_range = 4'b0001; // below 0 degrees Celsius\n      9: temp_range = 4'b0001; // below 0 degrees Celsius\n      10: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      11: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      12: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      13: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      14: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      15: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      16: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      17: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      18: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      19: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      20: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      21: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      22: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      23: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      24: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      25: temp_range = 4'b0100; // above 20 degrees Celsius\n      26: temp_range = 4'b0100; // above 20 degrees Celsius\n      27: temp_range = 4'b0100; // above 20 degrees Celsius\n      28: temp_range = 4'b0100; // above 20 degrees Celsius\n      29: temp_range = 4'b0100; // above 20 degrees Celsius\n      30: temp_range = 4'b0100; // above 20 degrees Celsius\n      31: temp_range = 4'b0100; // above 20 degrees Celsius\n      32: temp_range = 4'b0100; // above 20 degrees Celsius\n      33: temp_range = 4'b0100; // above 20 degrees Celsius\n      34: temp_range = 4'b0100; // above 20 degrees Celsius\n      default: temp_range = 4'b0000; // below 0 degrees Celsius (default case)\n    endcase\n  end\n\nendmodule",
        "module_name": "temperature_sensor",
        "module_hash": "5bf1a5d1110f094b28b6ac7ca1788ee5",
        "dataset_index": 14885
      },
      "vending_machine_3ccdf13c": {
        "rtl_code": "module vending_machine (\n    input clk,\n    input reset,\n    input [2:0] coin,\n    input [1:0] product,\n    output reg dispense,\n    output reg [2:0] change,\n    output reg [3:0] display\n);\n\n    // Constants for product costs\n    localparam COST_A = 2;\n    localparam COST_B = 3;\n    localparam COST_C = 4;\n\n    // Registers for amount inserted and product cost\n    reg [2:0] amount_inserted;\n    reg [2:0] product_cost;\n\n    // Register for excess change\n    reg [2:0] excess_change;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            amount_inserted <= 0;\n            product_cost <= 0;\n            excess_change <= 0;\n            dispense <= 0;\n            change <= 0;\n            display <= 0;\n        end else begin\n            // Update amount inserted\n            case (coin)\n                1: amount_inserted <= amount_inserted + 5;\n                2: amount_inserted <= amount_inserted + 10;\n                3: amount_inserted <= amount_inserted + 25;\n                4: amount_inserted <= amount_inserted + 50;\n                5: amount_inserted <= amount_inserted + 100;\n            endcase\n\n            // Update product cost\n            case (product)\n                1: product_cost <= COST_A;\n                2: product_cost <= COST_B;\n                3: product_cost <= COST_C;\n            endcase\n\n            // Calculate change\n            excess_change <= amount_inserted - product_cost;\n            change <= excess_change;\n\n            // Dispense product if exact amount inserted\n            if (amount_inserted >= product_cost) begin\n                dispense <= 1;\n                amount_inserted <= amount_inserted - product_cost;\n            end else begin\n                dispense <= 0;\n            end\n\n            // Update display\n            display <= {amount_inserted, product_cost};\n        end\n    end\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "3ccdf13c8efda5a3b975c1eba592819f",
        "dataset_index": 682
      },
      "my_logic_op_955ee02c": {
        "rtl_code": "\nmodule my_logic_op (\n    input [2:0] in,\n    output out\n);\n\n    wire [1:0] and_out;\n    wire and0_out;\n    wire and1_out;\n    wire and2_out;\n    wire or0_out;\n    wire or1_out;\n    wire not0_out;\n    wire not1_out;\n    wire not2_out;\n    wire xor0_out;\n    wire xor1_out;\n    wire xor2_out;\n    wire xor3_out;\n    wire xor4_out;\n    wire xor5_out;\n    wire xor6_out;\n\n    // AND gates\n    and and0 (and0_out, in[0], in[1]);\n    and and1 (and1_out, in[0], in[2]);\n    and and2 (and2_out, in[1], in[2]);\n\n    // XOR gates\n    xor xor0 (xor0_out, in[0], in[1]);\n    xor xor1 (xor1_out, in[0], in[2]);\n    xor xor2 (xor2_out, in[1], in[2]);\n    xor xor3 (xor3_out, xor0_out, in[2]);\n    xor xor4 (xor4_out, xor1_out, in[1]);\n    xor xor5 (xor5_out, xor2_out, in[0]);\n    xor xor6 (xor6_out, xor3_out, xor4_out, xor5_out);\n\n    // OR gates\n    or or0 (or0_out, and0_out, and1_out);\n    or or1 (or1_out, or0_out, and2_out, xor6_out);\n\n    // NOT gates\n    not not0 (not0_out, in[0]);\n    not not1 (not1_out, in[1]);\n    not not2 (not2_out, in[2]);\n\n    // Final output\n    assign out = (not1_out & not2_out & or1_out ) | (not0_out & not2_out & or1_out ) | (not0_out & not1_out & or1_out) | (not0_out & not1_out & not2_out);\n\nendmodule",
        "module_name": "my_logic_op",
        "module_hash": "955ee02c03369d6831ab230e7803855d",
        "dataset_index": 10860
      },
      "and4_56dab7a1": {
        "rtl_code": "module and4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\n    wire and1_out;\n    wire and2_out;\n\n    and and1 (and1_out, A, B);\n    and and2 (and2_out, C, D);\n    and and3 (Y, and1_out, and2_out);\n\nendmodule",
        "module_name": "and4",
        "module_hash": "56dab7a15648b738948c450f7de68d8f",
        "dataset_index": 21138
      },
      "shift_register_16bit_2416e7b0": {
        "rtl_code": "module shift_register_16bit (\n  input clk,\n  input resetn,\n  input parallel_load,\n  input serial_in,\n  output serial_out\n);\n\n  reg [15:0] shift_reg;\n\n  always @(posedge clk or negedge resetn) begin\n    if (!resetn) begin\n      shift_reg <= 16'b0;\n    end\n    else if (parallel_load) begin\n      shift_reg <= serial_in;\n    end\n    else begin\n      shift_reg <= {shift_reg[14:0], 1'b0};\n    end\n  end\n\n  assign serial_out = shift_reg[15];\n\nendmodule\n",
        "module_name": "shift_register_16bit",
        "module_hash": "2416e7b00b51b2fa492933f14a117b06",
        "dataset_index": 3655
      },
      "lpm_ram_dq_9a0c8061": {
        "rtl_code": "\nmodule lpm_ram_dq (\n    address,\n    inclock,\n    outclock,\n    data,\n    we,\n    q\n);\n\nparameter lpm_width = 8;\nparameter lpm_widthad = 11;\nparameter lpm_indata = \"REGISTERED\";            parameter lpm_address_control = \"REGISTERED\";   parameter lpm_outdata = \"UNREGISTERED\";         parameter lpm_hint = \"USE_EAB=ON\";              localparam dw = lpm_width;\nlocalparam aw = lpm_widthad;\n\ninput [aw-1:0] address;\ninput inclock;\ninput outclock;\ninput [dw-1:0] data;\ninput we;\noutput [dw-1:0] q;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign q = mem[addr_reg];\n\nalways @(posedge inclock)\n    addr_reg <= #1 address;\n\nalways @(posedge inclock)\n\tif (we)\n\t\tmem[address] <= #1 data;\n\nendmodule\n\nmodule altqpram (\n\twraddress_a,\n\tinclocken_a,\n\twraddress_b,\n\twren_a,\n\tinclocken_b,\n\twren_b,\n\tinaclr_a,\n\tinaclr_b,\n\tinclock_a,\n\tinclock_b,\n\tdata_a,\n\tdata_b,\n\tq_a,\n\tq_b \n);\n\nparameter width_write_a = 8;\nparameter widthad_write_a = 11;\nparameter width_write_b = 8;\nparameter widthad_write_b = 11;\n\nlocalparam dw = width_write_a;\nlocalparam aw = widthad_write_a;\n\ninput inclock_a, inaclr_a, inclocken_a, wren_a, inclock_b, inaclr_b, inclocken_b, wren_b;\ninput [dw-1:0] data_a, data_b;\noutput [dw-1:0] q_a, q_b;\ninput [aw-1:0] wraddress_a, wraddress_b;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg_a;\t\treg\t[aw-1:0]\taddr_reg_b;\t\tassign q_a = mem[addr_reg_a][dw-1:0];\nassign q_b = mem[addr_reg_b][dw-1:0];\n\nalways @(posedge inclock_a or posedge inaclr_a)\n    if ( inaclr_a == 1'b1 )\n        addr_reg_a <= #1 {aw{1'b0}};\n    else if ( inclocken_a )\n        addr_reg_a <= #1 wraddress_a;\n\nalways @(posedge inclock_b or posedge inaclr_b)\n    if ( inaclr_b == 1'b1 )\n        addr_reg_b <= #1 {aw{1'b0}};\n    else if ( inclocken_b )\n        addr_reg_b <= #1 wraddress_b;\n\nalways @(posedge inclock_a)\n\tif (inclocken_a && wren_a)\n\t\tmem[wraddress_a] <= #1 data_a;\n\nalways @(posedge inclock_b)\n\tif (inclocken_b && wren_b)\n\t\tmem[wraddress_b] <= #1 data_b;\n\nendmodule\nmodule RAMB16_S36_S36 (\n    CLKA,\n    SSRA,\n    ADDRA,\n    DIA,\n    DIPA,\n    ENA,\n    WEA,\n    DOA,\n    DOPA,\n\n    CLKB,\n    SSRB,\n    ADDRB,\n    DIB,\n    DIPB,\n    ENB,\n    WEB,\n    DOB,\n    DOPB\n);\n\nparameter dw = 32;\nparameter dwp = 4;\nparameter aw = 9;\n\ninput CLKA, SSRA, ENA, WEA, CLKB, SSRB, ENB, WEB;\ninput [dw-1:0] DIA, DIB;\noutput [dw-1:0] DOA, DOB;\ninput [dwp-1:0] DIPA, DIPB;\noutput [dwp-1:0] DOPA, DOPB;\ninput [aw-1:0] ADDRA, ADDRB;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg_a;\t\treg\t[aw-1:0]\taddr_reg_b;\t\tassign DOA = mem[addr_reg_a][dw-1:0];\nassign DOPA = mem[addr_reg_a][dwp+dw-1:dw];\nassign DOB = mem[addr_reg_b][dw-1:0];\nassign DOPB = mem[addr_reg_b][dwp+dw-1:dw];\n\nalways @(posedge CLKA or posedge SSRA)\n    if ( SSRA == 1'b1 )\n        addr_reg_a <= #1 {aw{1'b0}};\n    else if ( ENA )\n        addr_reg_a <= #1 ADDRA;\n\nalways @(posedge CLKB or posedge SSRB)\n    if ( SSRB == 1'b1 )\n        addr_reg_b <= #1 {aw{1'b0}};\n    else if ( ENB )\n        addr_reg_b <= #1 ADDRB;\n\nalways @(posedge CLKA)\n\tif (ENA && WEA)\n\t\tmem[ADDRA] <= #1 { DIPA , DIA };\n\nalways @(posedge CLKB)\n\tif (ENB && WEB)\n\t\tmem[ADDRB] <= #1 { DIPB , DIB };\n\nendmodule\n\n\nmodule RAMB16_S9 (\n    CLK,\n    SSR,\n    ADDR,\n    DI,\n    DIP,\n    EN,\n    WE,\n    DO,\n    DOP\n);\n\nparameter dw = 8;\nparameter dwp = 1;\nparameter aw = 11;\n\ninput CLK, SSR, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [dwp-1:0] DIP;\noutput [dwp-1:0] DOP;\ninput [aw-1:0] ADDR;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\nassign DOP = mem[addr_reg][dwp+dw-1:dw];\n\nalways @(posedge CLK or posedge SSR)\n    if ( SSR == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 { DIP , DI };\n\nendmodule\n\n\nmodule RAMB16_S36 (\n    CLK,\n    SSR,\n    ADDR,\n    DI,\n    DIP,\n    EN,\n    WE,\n    DO,\n    DOP\n);\n\nparameter dw = 32;\nparameter dwp = 4;\nparameter aw = 9;\n\ninput CLK, SSR, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [dwp-1:0] DIP;\noutput [dwp-1:0] DOP;\ninput [aw-1:0] ADDR;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\nassign DOP = mem[addr_reg][dwp+dw-1:dw];\n\nalways @(posedge CLK or posedge SSR)\n    if ( SSR == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 { DIP , DI };\n\nendmodule\n\n\nmodule RAMB16_S18 (\n    CLK,\n    SSR,\n    ADDR,\n    DI,\n    DIP,\n    EN,\n    WE,\n    DO,\n    DOP\n);\n\nparameter dw = 16;\nparameter dwp = 2;\nparameter aw = 10;\n\ninput CLK, SSR, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [dwp-1:0] DIP;\noutput [dwp-1:0] DOP;\ninput [aw-1:0] ADDR;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\nassign DOP = mem[addr_reg][dwp+dw-1:dw];\n\nalways @(posedge CLK or posedge SSR)\n    if ( SSR == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 { DIP , DI };\n\nendmodule\nmodule RAMB4_S16_S16 (\n    CLKA,\n    RSTA,\n    ADDRA,\n    DIA,\n    ENA,\n    WEA,\n    DOA,\n\n    CLKB,\n    RSTB,\n    ADDRB,\n    DIB,\n    ENB,\n    WEB,\n    DOB\n);\n\nparameter dw = 16;\nparameter aw = 8;\n\ninput CLKA, RSTA, ENA, WEA, CLKB, RSTB, ENB, WEB;\ninput [dw-1:0] DIA, DIB;\noutput [dw-1:0] DOA, DOB;\ninput [aw-1:0] ADDRA, ADDRB;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg_a;\t\treg\t[aw-1:0]\taddr_reg_b;\t\tassign DOA = mem[addr_reg_a][dw-1:0];\nassign DOB = mem[addr_reg_b][dw-1:0];\n\nalways @(posedge CLKA or posedge RSTA)\n    if ( RSTA == 1'b1 )\n        addr_reg_a <= #1 {aw{1'b0}};\n    else if ( ENA )\n        addr_reg_a <= #1 ADDRA;\n\nalways @(posedge CLKB or posedge RSTB)\n    if ( RSTB == 1'b1 )\n        addr_reg_b <= #1 {aw{1'b0}};\n    else if ( ENB )\n        addr_reg_b <= #1 ADDRB;\n\nalways @(posedge CLKA)\n\tif (ENA && WEA)\n\t\tmem[ADDRA] <= #1 DIA;\n\nalways @(posedge CLKB)\n\tif (ENB && WEB)\n\t\tmem[ADDRB] <= #1 DIB;\n\nendmodule\n\nmodule RAMB4_S4 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO,\n);\n\nparameter dw = 4;\nparameter aw = 10;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\n\nmodule RAMB4_S16 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO\n);\n\nparameter dw = 16;\nparameter aw = 8;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\n\nmodule RAMB4_S2 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO,\n);\n\nparameter dw = 2;\nparameter aw = 11;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\n\nmodule RAMB4_S8 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO,\n);\n\nparameter dw = 8;\nparameter aw = 9;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\nmodule RAM32X1D (\n    DPO,\n    SPO,\n    A0,\n    A1,\n    A2,\n    A3,\n    A4,\n    D,\n    DPRA0,\n    DPRA1,\n    DPRA2,\n    DPRA3,\n    DPRA4,\n    WCLK,\n    WE\n);\n\nparameter dw = 1;\nparameter aw = 5;\n\noutput DPO, SPO;\ninput DPRA0, DPRA1, DPRA2, DPRA3, DPRA4;\ninput A0, A1, A2, A3, A4;\ninput D;\ninput WCLK;\ninput WE;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\tassign DPO = mem[{DPRA4 , DPRA3 , DPRA2 , DPRA1 , DPRA0}][dw-1:0];\nassign SPO = mem[{A4 , A3 , A2 , A1 , A0}][dw-1:0];\n\nalways @(posedge WCLK)\n\tif (WE)\n\t\tmem[{A4 , A3 , A2 , A1 , A0}] <= #1 D;\n\nendmodule\nmodule RAM16X1D (\n    DPO,\n    SPO,\n    A0,\n    A1,\n    A2,\n    A3,\n    D,\n    DPRA0,\n    DPRA1,\n    DPRA2,\n    DPRA3,\n    WCLK,\n    WE\n);\n\nparameter dw = 1;\nparameter aw = 4;\n\noutput DPO, SPO;\ninput DPRA0, DPRA1, DPRA2, DPRA3;\ninput A0, A1, A2, A3;\ninput D;\ninput WCLK;\ninput WE;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\tassign DPO = mem[{DPRA3 , DPRA2 , DPRA1 , DPRA0}][dw-1:0];\nassign SPO = mem[{A3 , A2 , A1 , A0}][dw-1:0];\n\nalways @(posedge WCLK)\n\tif (WE)\n\t\tmem[{A3 , A2 , A1 , A0}] <= #1 D;\n\nendmodule\n",
        "module_name": "lpm_ram_dq",
        "module_hash": "9a0c8061ef10ebd52fb64a869bc84dff",
        "dataset_index": 21604
      },
      "edge_detector_a6a89063": {
        "rtl_code": "module edge_detector (\n    input clk,\n    input [15:0] in,\n    output reg [15:0] anyedge\n);\n\nreg [15:0] in_reg1, in_reg2;\nreg [15:0] out_reg1, out_reg2;\n\nalways @(posedge clk) begin\n    in_reg1 <= in;\n    out_reg1 <= out_reg2;\nend\n\nalways @(posedge clk) begin\n    in_reg2 <= in_reg1;\n    out_reg2 <= out_reg1;\nend\n\nalways @(posedge clk) begin\n    if (in_reg2[0] == 1 && in_reg1[0] == 0) begin\n        anyedge <= out_reg2;\n    end\nend\n\nendmodule",
        "module_name": "edge_detector",
        "module_hash": "a6a89063b04750cac463667bc200797c",
        "dataset_index": 16379
      },
      "crossbar_3x2_c200b241": {
        "rtl_code": "\nmodule crossbar_3x2 (\n    input aclk,\n    input aresetn,\n    input [31:0] s_axis_0_tdata,\n    input [31:0] s_axis_1_tdata,\n    input [31:0] s_axis_2_tdata,\n    input s_axis_0_tvalid,\n    input s_axis_1_tvalid,\n    input s_axis_2_tvalid,\n    output s_axis_0_tready,\n    output s_axis_1_tready,\n    output s_axis_2_tready,\n    output [31:0] m_axis_0_tdata,\n    output [31:0] m_axis_1_tdata,\n    output m_axis_0_tvalid,\n    output m_axis_1_tvalid,\n    input m_axis_0_tready,\n    input m_axis_1_tready\n);\n\n// internal signals\nreg [31:0] buffer_0;\nreg [31:0] buffer_1;\nreg [31:0] buffer_2;\nreg [1:0] current_route;\nreg [1:0] next_route;\n\n// initialize buffers to zero\ninitial begin\n    buffer_0 <= 0;\n    buffer_1 <= 0;\n    buffer_2 <= 0;\nend\n\n// compute next buffers\nalways @(*) begin\n    buffer_0 <= (current_route == 0) ? s_axis_0_tdata :\n                    (current_route == 1) ? s_axis_1_tdata :\n                                         s_axis_2_tdata;\n    buffer_1 <= (current_route == 0) ? s_axis_1_tdata :\n                    (current_route == 1) ? s_axis_2_tdata :\n                                         s_axis_0_tdata;\n    buffer_2 <= (current_route == 0) ? s_axis_2_tdata :\n                    (current_route == 1) ? s_axis_0_tdata :\n                                         s_axis_1_tdata;\nend\n\n// compute current route\nalways @(posedge aclk or negedge aresetn) begin\n    if (!aresetn) begin\n        current_route <= 0;\n    end else begin\n        case (m_axis_0_tvalid)\n            1: current_route <= (s_axis_1_tvalid || s_axis_2_tvalid) ? 1 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 current_route;\n            0: case (m_axis_1_tvalid)\n                1: current_route <= (s_axis_0_tvalid || s_axis_2_tvalid) ? 0 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 current_route;\n                0: current_route <= (s_axis_0_tvalid || s_axis_1_tvalid) ? 0 :\n                               (s_axis_1_tvalid) ? 1 :\n                                                 current_route;\n            endcase\n        endcase\n    end\nend\n\n// compute next route\nalways @(posedge aclk or negedge aresetn) begin\n    if (!aresetn) begin\n        next_route <= 0;\n    end else begin\n        case (current_route)\n            0: next_route <= (s_axis_1_tvalid || s_axis_2_tvalid) ? 1 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 next_route;\n            1: next_route <= (s_axis_0_tvalid || s_axis_2_tvalid) ? 0 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 next_route;\n            2: next_route <= (s_axis_0_tvalid || s_axis_1_tvalid) ? 0 :\n                               (s_axis_1_tvalid) ? 1 :\n                                                 next_route;\n            default: next_route <= next_route;\n        endcase\n    end\nend\n\n// assign outputs\nassign s_axis_0_tready = !(m_axis_0_tvalid || m_axis_1_tvalid);\nassign s_axis_1_tready = !(m_axis_0_tvalid || m_axis_1_tvalid);\nassign s_axis_2_tready = !m_axis_0_tvalid;\nassign m_axis_0_tdata = buffer_0;\nassign m_axis_1_tdata = buffer_1;\nassign m_axis_0_tvalid = (m_axis_0_tready) && ((s_axis_0_tvalid) || (s_axis_1_tvalid) || (s_axis_2_tvalid));\nassign m_axis_1_tvalid = (m_axis_1_tready) && ((s_axis_0_tvalid) || (s_axis_1_tvalid) || (s_axis_2_tvalid));\n\nendmodule",
        "module_name": "crossbar_3x2",
        "module_hash": "c200b241b5bec30da19ccd4714f9add2",
        "dataset_index": 20274
      },
      "communication_module_ae235b27": {
        "rtl_code": "module communication_module(\n\n    input wire clk,\n    input wire rst,\n    input wire ready_op,\n    input wire max_tick_address,\n    input wire max_tick_ch,\n    input wire TX_DONE,\n    \n    output reg beg_op,\n    output reg ack_op,\n    output reg load_address,\n    output reg enab_address,\n    output reg enab_ch,\n    output reg load_ch,\n    output reg TX_START\n    );\n\n//symbolic state declaration\nlocalparam [3:0]    est0 = 4'b0000,\n                    est1 = 4'b0001,\n                    est2 = 4'b0010,\n                    est3 = 4'b0011,\n                    est4 = 4'b0100,\n                    est5 = 4'b0101, \n                    est6 = 4'b0110,\n                    est7 = 4'b0111,\n                    est8 = 4'b1000,\n                    est9 = 4'b1001,\n                    est10 = 4'b1010,\n                    est11 = 4'b1011;\n//signal declaration\nreg [3:0] state_reg, state_next;    //    Guardan el estado actual y el estado futuro, respectivamente.\n\n//state register\n\nalways @( posedge clk, posedge rst)\n    begin\n        if(rst)\t// Si hay reset, el estado actual es el estado inicial.\n            state_reg <= est0;\n        else\t\t//Si no hay reset el estado actual es igual al estado siguiente.\n            state_reg <= state_next;\n    end\n    \n//next-state logic and output logic\n\nalways @*\n    begin\n        state_next = state_reg; // default state : the same\n        \n        //declaration of default outputs. \n        beg_op = 1'b0;\n        ack_op = 1'b0;\n        load_address = 1'b0;\n        enab_address = 1'b0;\n        enab_ch = 1'b0;\n        load_ch = 1'b0;\n        TX_START = 1'b0;\n        \n        case(state_reg)\n        est0:\n            begin\n                state_next = est1;\n            end\n            \n        est1:\n            begin\n                load_address = 1'b1;\n                enab_address = 1'b1;\n                state_next = est2;\n            end\n            \n        est2:\n            begin\n                beg_op = 1'b1;\n                state_next=est3;\n            end\n            \n        est3:\n            begin\n                beg_op = 1'b1;\n                enab_ch = 1'b1;\n                load_ch = 1'b1;\n                state_next=est4;\n            end\n            \n        est4:\n            begin\n                if(ready_op)\n                    state_next=est5;\n                else\n                    state_next=est4;\n            end\n            \n        est5:\n            begin\n                state_next=est6;\n            end\n            \n        est6:\n            begin\n                TX_START = 1'b1;\n                state_next=est7;\n            end\n            \n        est7:\n            begin\n                if(TX_DONE)\n                    if(max_tick_ch)\n                        state_next=est9;\n                    else\n                        begin\n                            state_next=est8;\n                        end\n                else\n                    state_next=est7;\n            end\n            \n        est8:\n            begin\n                enab_ch = 1'b1;\n                state_next=est5;\n            end\n            \n        est9:\n            begin\n                if(max_tick_address)\n                    state_next=est11;\n                else\n                    begin\n                        state_next=est10;\n                    end\n            end\n            \n        est10:\n            begin\n                enab_address = 1'b1;\n                ack_op = 1'b1;\n                state_next=est2;\n            end\n            \n        est11:\n            begin\n                state_next=est11;\n            end\n            \n        default:\n            state_next=est0;\n        endcase\n    end\n\nendmodule",
        "module_name": "communication_module",
        "module_hash": "ae235b27f3a293cd61647ebdad5bdf55",
        "dataset_index": 15794
      },
      "top__fe751193": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input load,    // Load value into counter when asserted\n    input up_down, // Count up or down based on value\n    input [31:0] in, // Input vector for the transition detector\n    output [7:0] q // 8-bit output from the functional module\n);\n\n    // Counter module with parallel load and up/down counting\n    reg [15:0] count;\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (load) begin\n            count <= {in[15:12], in[23:20], in[31:28], in[27:24]};\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\n    // Transition detector module using FSM architecture\n    reg [31:0] prev_in;\n    reg [31:0] transition;\n    parameter IDLE = 2'b00;\n    parameter DETECT = 2'b01;\n    parameter OUTPUT = 2'b10;\n    reg [1:0] state;\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            prev_in <= 0;\n            transition <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in != prev_in) begin\n                        state <= DETECT;\n                        prev_in <= in;\n                    end\n                end\n                DETECT: begin\n                    if (in == prev_in) begin\n                        state <= IDLE;\n                        transition <= transition | prev_in;\n                    end else begin\n                        prev_in <= in;\n                    end\n                end\n                OUTPUT: begin\n                    state <= IDLE;\n                    prev_in <= in;\n                end\n            endcase\n        end\n    end\n\n    // Functional module to combine counter and transition detector outputs\n    assign q = {count[3:0], count[7:4], count[11:8], count[15:12], transition[31:24], transition[23:16], transition[15:8], transition[7:0]};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "fe751193d0b8da282ebc8f0894cb5c13",
        "dataset_index": 3739
      },
      "nand2_7ddc56f0": {
        "rtl_code": "module nand2 (\n    output Y,\n    input A,\n    input B\n);\n\n    // NAND gate\n    assign Y = ~(A & B);\n\nendmodule\n",
        "module_name": "nand2",
        "module_hash": "7ddc56f074a605dc430f722b3e4ead6f",
        "dataset_index": 2972
      },
      "my__2bdb6e78": {
        "rtl_code": "\nmodule my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    C1  ,\n    VPWR,\n    VGND,\n    Y\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    output Y;\n\n    nor  (X, A1, A2);\n    buf  (Y, X);\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "2bdb6e780a13211101d3dd6bd63afd67",
        "dataset_index": 15413
      },
      "debounce_switch  #_c3f91ca9": {
        "rtl_code": "\n\n\nmodule debounce_switch  #(\n    parameter WIDTH=1, parameter N=3, parameter RATE=125000 )(\n    input wire clk,\n    input wire rst,\n    input wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\n\nreg [23:0] cnt_reg = 24'd0;\n\nreg [N-1:0] debounce_reg[WIDTH-1:0];\n\nreg [WIDTH-1:0] state;\n\n\nassign out = state;\n\ninteger k;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        cnt_reg <= 0;\n        state <= 0;\n\n        for (k = 0; k < WIDTH; k = k + 1) begin\n            debounce_reg[k] <= 0;\n        end\n    end else begin\n        if (cnt_reg < RATE) begin\n            cnt_reg <= cnt_reg + 24'd1;\n        end else begin\n            cnt_reg <= 24'd0;\n        end\n\n        if (cnt_reg == 24'd0) begin\n            for (k = 0; k < WIDTH; k = k + 1) begin\n                debounce_reg[k] <= {debounce_reg[k][N-2:0], in[k]};\n            end\n        end\n\n        for (k = 0; k < WIDTH; k = k + 1) begin\n            if (|debounce_reg[k] == 0) begin\n                state[k] <= 0;\n            end else if (&debounce_reg[k] == 1) begin\n                state[k] <= 1;\n            end else begin\n                state[k] <= state[k];\n            end\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "debounce_switch  #",
        "module_hash": "c3f91ca90d09907c1554268dfc09cfcf",
        "dataset_index": 21988
      },
      "top__d41b22d0": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    input a,           // 1-bit input for edge detection\n    output [3:0] counter_out,  // 4-bit output from the counter\n    output reg rise,   // Output indicating rising edge detection\n    output reg down,   // Output indicating falling edge detection\n    output [3:0] final_out  // 4-bit output from the functional module\n);\n\nreg [3:0] counter;\nreg [1:0] edge_detect;\nreg [1:0] edge_detect_prev;\n\nalways @(posedge clk or negedge reset) begin\n    if (!reset) begin\n        counter <= 4'b1000; // Reset to 8\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    edge_detect_prev <= edge_detect;\n    edge_detect <= {edge_detect[0], a} ^ {edge_detect_prev[0], edge_detect_prev[1]};\n    rise <= edge_detect[1] & !edge_detect_prev[1];\n    down <= !edge_detect[1] & edge_detect_prev[1];\nend\n\nassign final_out = counter + rise - down;\nassign counter_out = counter;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "d41b22d00702df6749b4e69f7a5ededf",
        "dataset_index": 20042
      },
      "multiplexer_c612e50f": {
        "rtl_code": "module multiplexer (in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel, out);\n    input[5:0] in1;\n    input[5:0] in2;\n    input[5:0] in3;\n    input[5:0] in4;\n    input[5:0] in5;\n    input[5:0] in6;\n    input[5:0] in7;\n    input[5:0] in8;\n    input[5:0] in9;\n    input[5:0] in10;\n    input[5:0] in11;\n    input[5:0] in12;\n    input[5:0] in13;\n    input[5:0] in14;\n    input[5:0] in15;\n    input[5:0] in16;\n    input[3:0] sel;\n    output[5:0] out;\n    reg[5:0] out;\n    \n    \n    always @(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel)\n    begin \n    case(sel)\n        4'b0000: out = in1;\n        4'b0001: out = in2;\n        4'b0010: out = in3;\n        4'b0011: out = in4;\n        4'b0100: out = in5;\n        4'b0101: out = in6;\n        4'b0110: out = in7;\n        4'b0111: out = in8;\n        4'b1000: out = in9;\n        4'b1001: out = in10;\n        4'b1010: out = in11;\n        4'b1011: out = in12;\n        4'b1100: out = in13;\n        4'b1101: out = in14;\n        4'b1110: out = in15;\n        4'b1111: out = in16;\n        default: out = 0;\n    endcase\n    end\nendmodule",
        "module_name": "multiplexer",
        "module_hash": "c612e50f7955a496d2b3510d91bdee37",
        "dataset_index": 22950
      },
      "binary_to_gray_406f8567": {
        "rtl_code": "\nmodule binary_to_gray(\n  input [7:0] bin_in,\n  output [7:0] gray_out\n);\n\n  wire [7:0] bin_to_gray; // Temporary variable to calculate binary code\n\n  // Calculate binary code by xoring gray_out with shifted bin_to_gray\n  assign gray_out = bin_in ^ ({bin_in[7], bin_in[7:1]});\n  assign bin_to_gray = gray_out ^ ({gray_out[7], gray_out[7:1]});\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "406f856706ba1f951e9b5bbeaadeda25",
        "dataset_index": 14629
      },
      "binary_counter_ccdd2ebc": {
        "rtl_code": "\nmodule binary_counter (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output [3:1] ena,\n    output [15:0] q);\n    \n    reg [15:0] count;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (ena[3]) begin\n                count <= count + 8'b0001_0000;\n            end\n            if (ena[2]) begin\n                count <= count + 8'b0000_1000;\n            end\n            if (ena[1]) begin\n                count <= count + 8'b0000_0010;\n            end\n            count <= count + 8'b0000_0001;\n        end\n    end\n    \n    assign q = count;\n    \n    assign ena = {1'b0, 1'b0, 1'b0, 1'b1}; // Enable all bits\n    \nendmodule",
        "module_name": "binary_counter",
        "module_hash": "ccdd2ebce0dfb3ad28d706942b5df530",
        "dataset_index": 17276
      },
      "shift_register_counter_d3689067": {
        "rtl_code": "\nmodule shift_register_counter (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input areset,     // Async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output wire [3:0] shift_out,\n    output wire [3:0] counter_out\n);\n\n    // Shift register\n    reg [3:0] shift_reg;\n    always @(posedge clk, negedge areset) begin\n        if (!areset) begin\n            shift_reg <= 4'b0000;\n        end else if (load) begin\n            shift_reg <= data;\n        end else if (ena) begin\n            shift_reg <= {shift_reg[2:0], shift_reg[3]};\n        end\n    end\n    assign shift_out = shift_reg;\n\n    // Counter\n    reg [3:0] count;\n    always @(posedge clk, negedge reset) begin\n        if (!reset) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\n    assign counter_out = count;\n\n    // Output\n    assign shift_out = shift_reg;\n    assign counter_out = count;\n\nendmodule",
        "module_name": "shift_register_counter",
        "module_hash": "d368906729894f0cb8accd6712f57ee0",
        "dataset_index": 6068
      },
      "sel_add_eaac20de": {
        "rtl_code": "module sel_add(\n    input [3:0] A,\n    input [3:0] B,\n    input SEL,\n    input ADD,\n    output reg [3:0] OUT\n);\n\nalways @(*) begin\n    if(SEL == 0) begin\n        OUT = A;\n    end\n    else if(SEL == 1 && ADD == 0) begin\n        OUT = B;\n    end\n    else if(SEL == 1 && ADD == 1) begin\n        OUT = A + B;\n    end\nend\n\nendmodule",
        "module_name": "sel_add",
        "module_hash": "eaac20defff5f459c8384b27a9feac49",
        "dataset_index": 2444
      },
      "Alu_6d7e1249": {
        "rtl_code": "\nmodule Alu(Alu_in1,Alu_in2,Alu_sel,Alu_zero_flg,Alu_out\n    );\n\t \n\t parameter wrd_size = 8,\n\t           sel_width= 3;\n\tinput [wrd_size-1:0] Alu_in1,Alu_in2;\n\tinput [sel_width-1:0] Alu_sel;\n\toutput reg [wrd_size-1:0] Alu_out;\n\toutput  Alu_zero_flg;\n\tlocalparam NOP = 3'b000,\n\t           ADD = 3'b001,\n\t\t\t\t  SUB = 3'b010,\n\t           AND = 3'b011,\n\t\t\t\t  OR  = 3'b100,\n              SLT = 3'b101,\n\t\t\t\t  SRT = 3'b110,\t\t\t\t  \n\t\t\t\t  NOT = 3'b111;\n\t\t\t\t  \t\t\t\t  \n\tassign Alu_zero_flg = ~|Alu_out;\n\t\t\t  \n\t\nalways @(*)\ncase(Alu_sel)\n           NOP:  Alu_out = 0;\n\t\t\t  AND:  Alu_out = Alu_in1&Alu_in2;\n\t\t\t  OR:   Alu_out = Alu_in1|Alu_in2;\n\t\t\t  ADD:  Alu_out = Alu_in1+Alu_in2;\n\t\t\t  SUB:  Alu_out = Alu_in1-Alu_in2;\n\t\t\t  NOT:  Alu_out = ~Alu_in1;\n\t\t\t  SLT:  Alu_out =  Alu_in1<<Alu_in2;\n\t\t\t  SRT:  Alu_out =  Alu_in1>>Alu_in2;\n\t\t\t  default: Alu_out = 0;\n\t\t\t  endcase\n\n\n\nendmodule\n",
        "module_name": "Alu",
        "module_hash": "6d7e1249d1eb473e4ac9faa03da68611",
        "dataset_index": 12097
      },
      "adder_475baf57": {
        "rtl_code": "module adder (\n    input clk,\n    input rst,\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] Y\n);\n\n    wire [31:0] sum;\n\n    assign sum = A + B;\n\n    assign Y = rst ? 0 : sum;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "475baf57d594749aeaa1c44fb5b6b154",
        "dataset_index": 18289
      },
      "logic__38c31d76": {
        "rtl_code": "module logic_module (\n    Y,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    // Module ports\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n    input B2;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire nand0_out;\n    wire nand1_out;\n    wire and0_out_Y;\n\n    // Gates\n    nand nand0 (nand0_out, A1, A2, A3);\n    nand nand1 (nand1_out, B1, B2);\n    and and0 (and0_out_Y, nand0_out, nand1_out);\n    buf buf0 (Y, and0_out_Y);\n\nendmodule",
        "module_name": "logic_",
        "module_hash": "38c31d7624329ba79140cdc22a5d5793",
        "dataset_index": 12907
      },
      "dc_offset_removal_9ce4c190": {
        "rtl_code": "module dc_offset_removal \n  #(parameter WIDTH=16,\n    parameter ADDR=8'd0,\n    parameter alpha_shift=20)\n   (input clk, input rst, \n    input set_stb, input [7:0] set_addr, input [31:0] set_data,\n    input [WIDTH-1:0] in, output [WIDTH-1:0] out);\n   \n   wire \t      set_now = set_stb & (ADDR == set_addr);\n   \n   reg \t\t      fixed;  // uses fixed offset\n   wire [WIDTH-1:0]   fixed_dco;\n\n   localparam int_width = WIDTH + alpha_shift;\n   reg [int_width-1:0] integrator;\n   wire [WIDTH-1:0]    quantized;\n\n   always @(posedge clk)\n     if(rst)\n       begin\n\t  fixed <= 0;\n\t  integrator <= {int_width{1'b0}};\n       end\n     else if(set_now)\n       begin\n\t  fixed <= set_data[31];\n\t  if(set_data[30])\n\t    integrator <= {set_data[29:0],{(int_width-30){1'b0}}};\n       end\n     else if(~fixed)\n       integrator <= integrator +  {{(alpha_shift){in[WIDTH-1]}},in};\n\n   round_sd #(.WIDTH_IN(int_width),.WIDTH_OUT(WIDTH)) round_sd\n     (.clk(clk), .reset(rst), .in(integrator), .strobe_in(1'b1), .out(quantized), .strobe_out());\n   \n   add2_and_clip_reg #(.WIDTH(WIDTH)) add2_and_clip_reg\n     (.clk(clk), .rst(rst), .in1(in), .in2(-quantized), .strobe_in(1'b1), .sum(out), .strobe_out());\n\nendmodule\n\n// Round to nearest with saturation\nmodule round_sd #(parameter WIDTH_IN=16, WIDTH_OUT=16) (\n    input clk,\n    input reset,\n    input signed [WIDTH_IN-1:0] in,\n    input strobe_in,\n    output reg signed [WIDTH_OUT-1:0] out,\n    output reg strobe_out\n);\n    localparam WIDTH_OUT_1 = WIDTH_OUT - 1;\n    localparam WIDTH_IN_1 = WIDTH_IN - 1;\n    localparam WIDTH_DIFF = WIDTH_IN - WIDTH_OUT;\n    localparam WIDTH_DIFF_1 = WIDTH_DIFF - 1;\n    localparam ROUND_CONST = (1 << (WIDTH_DIFF - 1)) - 1;\n    reg signed [WIDTH_IN_1:0] in_shifted;\n    reg signed [WIDTH_OUT_1:0] out_shifted;\n    reg [WIDTH_DIFF_1:0] round_bits;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 0;\n            strobe_out <= 0;\n            in_shifted <= 0;\n            out_shifted <= 0;\n            round_bits <= 0;\n        end\n        else if (strobe_in) begin\n            in_shifted <= in >> WIDTH_DIFF;\n            out_shifted <= in_shifted + round_bits;\n            if (out_shifted > (1 << WIDTH_OUT_1) - 1) begin\n                out <= (1 << WIDTH_OUT_1) - 1;\n            end\n            else if (out_shifted < -(1 << WIDTH_OUT_1)) begin\n                out <= -(1 << WIDTH_OUT_1);\n            end\n            else begin\n                out <= out_shifted;\n            end\n            round_bits <= ROUND_CONST & in[WIDTH_DIFF_1:0];\n            strobe_out <= 1;\n        end\n        else begin\n            strobe_out <= 0;\n        end\n    end\nendmodule\n\n// Add two signed numbers and clip the result to the range of [-2^(WIDTH-1), 2^(WIDTH-1)-1]\nmodule add2_and_clip_reg #(parameter WIDTH=16) (\n    input clk,\n    input rst,\n    input signed [WIDTH-1:0] in1,\n    input signed [WIDTH-1:0] in2,\n    input strobe_in,\n    output reg signed [WIDTH-1:0] sum,\n    output reg strobe_out\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            sum <= 0;\n            strobe_out <= 0;\n        end\n        else if (strobe_in) begin\n            sum <= in1 + in2;\n            if (sum > (1 << (WIDTH-1)) - 1) begin\n                sum <= (1 << (WIDTH-1)) - 1;\n            end\n            else if (sum < -(1 << (WIDTH-1))) begin\n                sum <= -(1 << (WIDTH-1));\n            end\n            strobe_out <= 1;\n        end\n        else begin\n            strobe_out <= 0;\n        end\n    end\nendmodule",
        "module_name": "dc_offset_removal",
        "module_hash": "9ce4c19037a8830283e1bc681f0d4bbe",
        "dataset_index": 17707
      },
      "video_7f2acbf0": {
        "rtl_code": "\n \nmodule video(\n\n    input wire        clock,        \n    input wire [7:0]  d8_chr,\n    output reg [13:0] addr,\n    output reg [4:0]  r,\n    output reg [5:0]  g,\n    output reg [4:0]  b,\n    output reg        hs,\n    output reg        vs\n);\n\nreg  [9:0] x;\nreg  [9:0] y;\nreg  [7:0] attr;\nreg  [7:0] bit8;\nreg  [7:0] mask;\n\nwire [9:0] rx = x - 8'd48;\nwire [9:0] ry = y - 8'd48;\nwire       bitset = mask[ 3'h7 ^ rx[3:1] ];\n\nalways @(posedge clock) begin\n\n    if (x == 10'd800) begin\n    \n        x <= 1'b0;\n        y <= (y == 10'd525) ? 1'b0 : (y + 1'b1); \n        \n    end else x <= x + 1'b1;\n    \n    hs <= (x >= 10'd656 && x <= 10'd751); vs <= (y >= 10'd490 && y <= 10'd492); if (x < 10'd640 && y < 10'd480) begin\n    \n        if (x >= 64 && x < 576 && y >= 48 && y < 432) begin\n        \n            r <= bitset? 1'b0 : 5'h0F; g <= bitset? 1'b0 : 6'h1F;\n            b <= bitset? 1'b0 : 5'h0F;\n        \n        end else begin r <= 5'h0F; g <= 6'h1F; b <= 5'h0F; end\n\n    end else begin r <= 1'b0; g <= 1'b0; b <= 1'b0; end\n    case (rx[3:0])\n    \n        4'h0: begin addr <= {2'b10, ry[8:1], rx[8:4]}; end \n        \n        4'h1: begin addr <= {5'b10110, ry[8:4], rx[8:4]}; bit8 <= d8_chr; end \n        \n        4'hF: begin attr <= d8_chr; mask <= bit8; end \n\n    endcase\n\nend\n\nendmodule",
        "module_name": "video",
        "module_hash": "7f2acbf03777c5daebeaa893cc13939a",
        "dataset_index": 15271
      },
      "top__e1509b24": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] q\n);\n\n// Edge Detection Module\nreg [7:0] in_prev;\nreg [7:0] edge_detected;\nalways @(posedge clk) begin\n    in_prev <= in;\n    edge_detected <= in ^ in_prev;\nend\n\n// Functional Module\nreg [7:0] q_reg;\nalways @(*) begin\n    q_reg <= edge_detected;\nend\n\nalways @(posedge clk) begin\n    q <= q_reg;\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "e1509b24ab7b31522593d3e8dc15479e",
        "dataset_index": 13857
      },
      "shift_register_ring_counter_99ddd5b4": {
        "rtl_code": "module shift_register_ring_counter (input clk, input d, output reg q);\n\n  reg [2:0] shift_reg;\n\n  always @(posedge clk)\n    shift_reg <= {shift_reg[1:0], d};\n\n  always @*\n    q = shift_reg[2];\n\nendmodule",
        "module_name": "shift_register_ring_counter",
        "module_hash": "99ddd5b48689a80259dd51cd9bb7956e",
        "dataset_index": 8825
      },
      "logic_operation_2fb476a3": {
        "rtl_code": "module logic_operation (\n    input [1:0] logic_op_x,\n    input [31:0] operand_0_x,\n    input [31:0] operand_1_x,\n    output [31:0] logic_result_x\n);\n\nreg [31:0] temp_result;\n\nalways @*\nbegin\n    case (logic_op_x)\n        2'b00: temp_result = operand_0_x & operand_1_x;\n        2'b01: temp_result = operand_0_x | operand_1_x;\n        2'b10: temp_result = operand_0_x ^ operand_1_x;\n        default: temp_result = 0;\n    endcase\nend\n\nassign logic_result_x = temp_result;\n\nendmodule",
        "module_name": "logic_operation",
        "module_hash": "2fb476a39e170a7e01d2d4653f054822",
        "dataset_index": 4561
      },
      "dff_reset_set_ce_b5041092": {
        "rtl_code": "module dff_reset_set_ce (\n    input  wire D,\n    input  wire CLK,\n    input  wire RESET,\n    input  wire SET,\n    input  wire CE,\n    output reg  Q,\n    output reg  Q_N\n);\n\n    always @(posedge CLK) begin\n        if (RESET) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (SET) begin\n            Q <= 1;\n            Q_N <= 0;\n        end else if (CE) begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule",
        "module_name": "dff_reset_set_ce",
        "module_hash": "b504109293dba3c467af92d8f64fa861",
        "dataset_index": 11307
      },
      "TLATNTSCAX2TS_9a9ec2ad": {
        "rtl_code": "\nmodule TLATNTSCAX2TS (E, SE, CK, ECK);\n  input E, SE, CK;\n  output ECK;\n\n  assign ECK = SE ? E : ~E;\nendmodule\nmodule flipflop (CLK, D, RESET, EN, Q);\n  input CLK, D, RESET, EN;\n  output Q;\n\n  wire E, SE, ECK;\n  TLATNTSCAX2TS latch ( .E(E), .SE(SE), .CK(CLK), .ECK(ECK) );\n\n  assign E = EN;\n  assign SE = RESET;\n  assign Q = ECK;\n\n  reg SE_REG; initial SE_REG=0; // moved the declaration of SE here\n  always @ (posedge CLK) begin\n    if (EN) begin\n      if (D) begin\n        SE_REG <= 1'b0;\n      end else begin\n        SE_REG <= 1'b1;\n      end\n    end\n  end\nendmodule",
        "module_name": "TLATNTSCAX2TS",
        "module_hash": "9a9ec2ad42badc5e00c13b508255d4ec",
        "dataset_index": 11839
      },
      "mux_4to1_5cec47af": {
        "rtl_code": "\nmodule mux_4to1(\n  input [3:0] a, b, c, d,\n  input [1:0] sel,\n  output reg [3:0] y\n);\n\n  wire [3:0] ab_sel, cd_sel;\n\n  // First level of 2-to-1 MUXes\n  mux2to1 mux_ab(.a(a[0]), .b(b[0]), .sel(sel[0]), .y(ab_sel[0]));\n  mux2to1 mux_cd(.a(c[0]), .b(d[0]), .sel(sel[0]), .y(cd_sel[0]));\n  mux2to1 mux_ab1(.a(a[1]), .b(b[1]), .sel(sel[0]), .y(ab_sel[1]));\n  mux2to1 mux_cd1(.a(c[1]), .b(d[1]), .sel(sel[0]), .y(cd_sel[1]));\n  mux2to1 mux_ab2(.a(a[2]), .b(b[2]), .sel(sel[0]), .y(ab_sel[2]));\n  mux2to1 mux_cd2(.a(c[2]), .b(d[2]), .sel(sel[0]), .y(cd_sel[2]));\n  mux2to1 mux_ab3(.a(a[3]), .b(b[3]), .sel(sel[0]), .y(ab_sel[3]));\n  mux2to1 mux_cd3(.a(c[3]), .b(d[3]), .sel(sel[0]), .y(cd_sel[3]));\n\n  // Second level of 2-to-1 MUX to select between the outputs of the first level\n  always @(*) begin\n    case (sel[1])\n      1'b0: y = ab_sel;\n      1'b1: y = cd_sel;\n    endcase\n  end\n\nendmodule\nmodule mux2to1(\n  input a, b, sel,\n  output reg y\n);\n\n  always @(*) begin\n    y = (sel == 1'b0) ? a : b;\n  end\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "5cec47afa3d26eab4f30ee18da0620f8",
        "dataset_index": 5686
      },
      "ps2_keyboard_13972019": {
        "rtl_code": "module ps2_keyboard (\n    input CLK,\n    input RESET_N,\n    input PS2_CLK,\n    input PS2_DATA,\n    output RX_PRESSED,\n    output RX_EXTENDED,\n    output [7:0] RX_SCAN\n);\n\nreg [7:0] scan_code;\nreg rx_pressed;\nreg rx_extended;\nreg [2:0] bit_count;\nreg [3:0] state;\nreg [7:0] timer;\nreg [7:0] rx_scan;\n\nassign RX_PRESSED = rx_pressed;\nassign RX_EXTENDED = rx_extended;\nassign RX_SCAN = rx_scan;\n\nparameter IDLE = 3'b000;\nparameter START_BIT = 3'b001;\nparameter DATA_BIT = 3'b010;\nparameter PARITY_BIT = 3'b011;\nparameter STOP_BIT = 3'b100;\nparameter EXTENDED_CODE = 8'hE0;\nparameter RELEASE_CODE = 8'hF0;\n\nalways @(posedge CLK or negedge RESET_N) begin\n    if (~RESET_N) begin\n        scan_code <= 0;\n        rx_scan <= 0;\n        rx_pressed <= 0;\n        rx_extended <= 0;\n        bit_count <= 0;\n        state <= IDLE;\n        timer <= 0;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                if (!PS2_CLK && PS2_DATA) begin\n                    state <= START_BIT;\n                    bit_count <= 0;\n                    scan_code <= 0;\n                    timer <= 0;\n                end\n            end\n            START_BIT: begin\n                if (PS2_CLK) begin\n                    state <= DATA_BIT;\n                end\n            end\n            DATA_BIT: begin\n                if (!PS2_CLK) begin\n                    scan_code[bit_count] <= PS2_DATA;\n                    bit_count <= bit_count + 1;\n                    if (bit_count == 7) begin\n                        state <= PARITY_BIT;\n                    end\n                end\n            end\n            PARITY_BIT: begin\n                if (PS2_CLK) begin\n                    state <= STOP_BIT;\n                end\n                else begin\n                    if (PS2_DATA == ~(scan_code[0]^scan_code[1]^scan_code[2]^scan_code[3]^scan_code[4]^scan_code[5]^scan_code[6])) begin\n                        if (scan_code == EXTENDED_CODE) begin\n                            rx_extended <= 1;\n                            state <= IDLE;\n                        end\n                        else if (scan_code == RELEASE_CODE) begin\n                            rx_pressed <= 0;\n                            state <= IDLE;\n                        end\n                        else begin\n                            rx_scan <= scan_code;\n                            rx_pressed <= 1;\n                            state <= STOP_BIT;\n                        end\n                    end\n                    else begin\n                        state <= IDLE;\n                    end\n                end\n            end\n            STOP_BIT: begin\n                if (PS2_CLK) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n        if (!PS2_CLK && !PS2_DATA) begin\n            timer <= 0;\n        end\n        else if (!PS2_CLK && PS2_DATA) begin\n            timer <= timer + 1;\n            if (timer == 255) begin\n                state <= IDLE;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "ps2_keyboard",
        "module_hash": "1397201963a50c1ff29cd05544291f18",
        "dataset_index": 1234
      },
      "RegFile_ae16b4f4": {
        "rtl_code": "\nmodule RegFile (clk,  regA, regB, regTEST, regW, Wdat, RegWrite,  Adat, Bdat, TESTdat);\n    input clk,RegWrite;\t\tinput [4:0] regTEST, regA, regB, regW;\tinput [31:0] Wdat;\t\t\toutput wire [31:0] Adat, Bdat, TESTdat;\t\treg [31:0] regfile [0:31];\n\t assign  Adat=regfile[regA];\n\t assign  Bdat=regfile[regB];\n\t assign  TESTdat=regfile[regTEST];\n\t always @(posedge clk) begin\n        if(RegWrite) regfile[regW]=(regW==0)?0:Wdat;\n\tend\nendmodule\n\n",
        "module_name": "RegFile",
        "module_hash": "ae16b4f420a11e94fab9f25bf7273200",
        "dataset_index": 24149
      },
      "eight_to_one_32796bf9": {
        "rtl_code": "module eight_to_one (\n    y,\n    a1,\n    a2,\n    a3,\n    b1,\n    vpwr,\n    vgnd,\n    vpb,\n    vnb\n);\n\n    output y;\n    input [3:0] a1, a2, a3, b1;\n    input vpwr, vgnd, vpb, vnb;\n\n    wire [4:0] sum;\n    assign sum = a1 + a2 + a3 + b1;\n\n    wire greater_than_or_equal_to_10;\n    assign greater_than_or_equal_to_10 = (sum >= 10);\n\n    assign y = (greater_than_or_equal_to_10) ? 1 : 0;\n\nendmodule",
        "module_name": "eight_to_one",
        "module_hash": "32796bf9cbc86b10ada22cf916bf3626",
        "dataset_index": 7271
      },
      "Multiplier_d67d742e": {
        "rtl_code": "module Multiplier(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [7:0] C\n);\n\n    wire [3:0] B0, B1, B2, B3;\n    wire [7:0] P0, P1, P2, P3;\n\n    // Splitting B into 4 bits\n    assign {B3, B2, B1, B0} = B;\n\n    // Multiplying A with each bit of B\n    assign P0 = A * B0;\n    assign P1 = A * B1;\n    assign P2 = A * B2;\n    assign P3 = A * B3;\n\n    // Combining the results to get the final output\n    always @(*) begin\n        C = {P3[7:4], P2[7:4], P1[7:4], P0[7:4]};\n    end\n\nendmodule",
        "module_name": "Multiplier",
        "module_hash": "d67d742e864d384f2e0b049e5b2d42d8",
        "dataset_index": 6803
      },
      "edge_detection_b6d717c1": {
        "rtl_code": "module edge_detection (\n    input clk,\n    input reset,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nreg [3:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        prev_in <= 4'b0000;\n        out <= 4'b0000;\n    end else begin\n        prev_in <= in;\n        out <= 4'b0000;\n        if (in[0] != prev_in[0]) out[0] <= 1'b1;\n        if (in[1] != prev_in[1]) out[1] <= 1'b1;\n        if (in[2] != prev_in[2]) out[2] <= 1'b1;\n        if (in[3] != prev_in[3]) out[3] <= 1'b1;\n    end\nend\n\nendmodule\n\nmodule bitwise_or (\n    input [3:0] in1,\n    input [3:0] in2,\n    output reg [3:0] out\n);\n\nalways @(in1, in2) begin\n    out <= in1 | in2;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out\n);\n\nwire [3:0] edge1;\nwire [3:0] edge2;\n\nedge_detection ed1(clk, reset, in1, edge1);\nedge_detection ed2(clk, reset, in2, edge2);\nbitwise_or or_gate(edge1, edge2, out);\n\nendmodule",
        "module_name": "edge_detection",
        "module_hash": "b6d717c19020a1c0d304988d4e20cd29",
        "dataset_index": 16530
      },
      "dpram_664121cc": {
        "rtl_code": "module dpram(wclk,wdata,waddr,wen,rclk,rdata,raddr);\n   parameter depth = 4;\n   parameter width = 16;\n   parameter size = 16;\n   \n   input wclk;\n   input [width-1:0] wdata;\n   input [depth-1:0] waddr;\n   input \t     wen;\n\n   input rclk;\n   output reg [width-1:0] rdata;\n   input [depth-1:0]  raddr;\n   \n   reg [width-1:0]    ram [0:size-1];\n   \n   always @(posedge wclk)\n     if(wen)\n       ram[waddr] <= #1 wdata;\n   \n   always @(posedge rclk)\n     rdata <= #1 ram[raddr];\n   \nendmodule ",
        "module_name": "dpram",
        "module_hash": "664121cc0b6c7c6e8fe0bfdc3062b3e8",
        "dataset_index": 25812
      },
      "ll8_to_txmac_c4667177": {
        "rtl_code": "module ll8_to_txmac\n  (input clk, input reset, input clear,\n   input [7:0] ll_data, input ll_sof, input ll_eof, input ll_src_rdy, output ll_dst_rdy,\n   output [7:0] tx_data, output tx_valid, output tx_error, input tx_ack );\n\n   reg [2:0] xfer_state;\n\n   localparam XFER_IDLE      = 0;\n   localparam XFER_ACTIVE    = 1;\n   localparam XFER_WAIT1     = 2;\n   localparam XFER_UNDERRUN  = 3;\n   localparam XFER_DROP      = 4;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       xfer_state \t    <= XFER_IDLE;\n     else\n       case(xfer_state)\n\t XFER_IDLE :\n\t   if(tx_ack)\n\t     xfer_state <= XFER_ACTIVE;\n\t XFER_ACTIVE :\n\t   if(~ll_src_rdy)\n\t     xfer_state <= XFER_UNDERRUN;\n\t   else if(ll_eof)\n\t     xfer_state <= XFER_WAIT1;\n\t XFER_WAIT1 :\n\t   xfer_state <= XFER_IDLE;\n\t XFER_UNDERRUN :\n\t   xfer_state <= XFER_DROP;\n\t XFER_DROP :\n\t   if(ll_eof)\n\t     xfer_state <= XFER_IDLE;\n       endcase assign ll_dst_rdy \t = (xfer_state == XFER_ACTIVE) | tx_ack | (xfer_state == XFER_DROP);\n   assign tx_valid \t = (ll_src_rdy & (xfer_state == XFER_IDLE))|(xfer_state == XFER_ACTIVE);\n   assign tx_data \t = ll_data;\n   assign tx_error \t = (xfer_state == XFER_UNDERRUN);\n   \nendmodule ",
        "module_name": "ll8_to_txmac",
        "module_hash": "c4667177a4fc06e196e9f2b8f628d809",
        "dataset_index": 23992
      },
      "top__c9a821a8": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // Input data for the adder\n    output pwm,       // PWM output\n    output reg [7:0] q,   // 8-bit output from the counter\n    output reg [7:0] out  // Final output from the functional module\n);\n\n    reg [7:0] counter;\n    reg [7:0] adder_out;\n    reg pwm_out;\n\n    // Counter module\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 8'b0;\n        end else begin\n            if (counter == 8'hff) begin\n                counter <= 8'b0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    // Adder module\n    always @(posedge clk) begin\n        adder_out <= counter + d;\n    end\n\n    // PWM module\n    always @(posedge clk) begin\n        if (adder_out > 8'h80) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\n    // Functional module\n    always @(posedge clk) begin\n        q <= counter;\n        out <= q * pwm_out;\n    end\n\n    // Output assignments\n    assign pwm = pwm_out;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "c9a821a8d71c0a558b897a65e8c5d5cd",
        "dataset_index": 5880
      },
      "magnitude_comparator_9369c88e": {
        "rtl_code": "module magnitude_comparator (\n    input valid,\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] sel,\n    output [1:0] out_mode0,\n    output less_than,\n    output equal_to,\n    output greater_than\n);\n\n    reg [1:0] magnitude;\n    reg less_than_reg, equal_to_reg, greater_than_reg;\n    \n    always @(*) begin\n        if (A == B) begin\n            magnitude = 2'b00;\n            less_than_reg = 1'b0;\n            equal_to_reg = 1'b1;\n            greater_than_reg = 1'b0;\n        end else if (A > B) begin\n            magnitude = 2'b01;\n            less_than_reg = 1'b0;\n            equal_to_reg = 1'b0;\n            greater_than_reg = 1'b1;\n        end else begin\n            magnitude = 2'b10;\n            less_than_reg = 1'b1;\n            equal_to_reg = 1'b0;\n            greater_than_reg = 1'b0;\n        end\n    end\n    \n    assign out_mode0 = (sel == 2'b00) ? magnitude : 2'b00;\n    assign less_than = (sel == 2'b01) ? less_than_reg : 1'b0;\n    assign equal_to = (sel == 2'b01) ? equal_to_reg : 1'b0;\n    assign greater_than = (sel == 2'b01) ? greater_than_reg : 1'b0;\n    \nendmodule",
        "module_name": "magnitude_comparator",
        "module_hash": "9369c88e52bafa9fae02837e60e5bcda",
        "dataset_index": 9903
      },
      "sky130_fd_sc_lp__inputiso1n_457c303f": {
        "rtl_code": "module sky130_fd_sc_lp__inputiso1n (\n    input A,\n    input SLEEP_B,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    assign X = (!A && !SLEEP_B && !VPWR && !VGND && !VPB && !VNB);\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__inputiso1n",
        "module_hash": "457c303f5d24e3b50c120c4828130f67",
        "dataset_index": 19786
      },
      "mux_comp_34a15785": {
        "rtl_code": "module mux_comp(\n    input [63:0] in,\n    input [3:0] sel,\n    input [3:0] comp_val,\n    output out\n);\n\nreg [3:0] selected_input;\n\nalways @(*) begin\n    case(sel)\n        0: selected_input = in[3:0];\n        1: selected_input = in[7:4];\n        2: selected_input = in[11:8];\n        3: selected_input = in[15:12];\n        4: selected_input = in[19:16];\n        5: selected_input = in[23:20];\n        6: selected_input = in[27:24];\n        7: selected_input = in[31:28];\n        8: selected_input = in[35:32];\n        9: selected_input = in[39:36];\n        10: selected_input = in[43:40];\n        11: selected_input = in[47:44];\n        12: selected_input = in[51:48];\n        13: selected_input = in[55:52];\n        14: selected_input = in[59:56];\n        15: selected_input = in[63:60];\n    endcase\nend\n\nassign out = (selected_input == comp_val) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "mux_comp",
        "module_hash": "34a1578594bc9a5afa2610d6beb593a8",
        "dataset_index": 12088
      },
      "video_sys_CPU_nios2_performance_monitors_91cef8b8": {
        "rtl_code": "module video_sys_CPU_nios2_performance_monitors (\n    input clk,\n    input reset,\n    input [31:0] inst,\n    input stall,\n    output reg [31:0] ipc,\n    output reg [31:0] cpi\n);\n\nreg [31:0] inst_count;\nreg [31:0] cycle_count;\nreg [31:0] stalled_cycle_count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        inst_count <= 0;\n        cycle_count <= 0;\n        stalled_cycle_count <= 0;\n    end else begin\n        inst_count <= inst_count + 1;\n        cycle_count <= cycle_count + 1;\n        if (stall) begin\n            stalled_cycle_count <= stalled_cycle_count + 1;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        ipc <= 0;\n        cpi <= 0;\n    end else begin\n        if (cycle_count - stalled_cycle_count == 0) begin\n            ipc <= 0;\n        end else begin\n            ipc <= inst_count / (cycle_count - stalled_cycle_count);\n        end\n        if (inst_count == 0) begin\n            cpi <= 0;\n        end else begin\n            cpi <= (cycle_count - stalled_cycle_count) / inst_count;\n        end\n    end\nend\n\nendmodule",
        "module_name": "video_sys_CPU_nios2_performance_monitors",
        "module_hash": "91cef8b8a16e12341c54ae89dc21e692",
        "dataset_index": 13955
      },
      "vga_converter_4dcbbecb": {
        "rtl_code": "\nmodule vga_converter (\n  input [23:0] data,\n  input blank,\n  input hs,\n  input vs,\n  input clk,\n  output [7:0] vga_data,\n  output blank_out,\n  output hs_out,\n  output vs_out\n);\n\n  reg [1:0] cnt;\n  reg [23:0] data_reg;\n  reg hs_reg;\n  reg hs_reg1;\n  reg vs_reg;\n  reg blank_reg;\n\n  always @(posedge clk) begin\n    hs_reg <= hs;\n    hs_reg1 <= hs_reg;\n    vs_reg <= vs;\n    blank_reg <= blank;\n  end\n\n  wire sync_pulse = (hs_reg & !hs_reg1) ? 1'b1 : 1'b0;\n  always @(posedge clk) begin\n    if (sync_pulse) begin\n      cnt <= 2'b11; \n    end\n    else begin\n      if (cnt == 2)\n        cnt <= 2'b00;\n      else    \n        cnt <= cnt+1;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (cnt == 2'b11)\n      data_reg <= data;\n  end\n\n  assign vga_data = {3'b0, cnt[1] ? data_reg[23:16] : (cnt[0] ? data_reg[15:8] : data_reg[7:0])};\n  assign blank_out = blank_reg & cnt != 0;\n  assign hs_out = hs_reg & cnt != 0;\n  assign vs_out = vs_reg & cnt != 0;\n\nendmodule",
        "module_name": "vga_converter",
        "module_hash": "4dcbbecb2f5f9987db69995ea8cfd985",
        "dataset_index": 2347
      },
      "counter_35b88f49": {
        "rtl_code": "module counter (\n  input CLK,\n  input RST,\n  input EN,\n  output reg [3:0] COUNT\n);\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      COUNT <= 4'b0;\n    end else if (EN) begin\n      COUNT <= COUNT + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "35b88f495d293a17682610ce8e6acd4b",
        "dataset_index": 1186
      },
      "top__6926522b": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input data,\n    output reg q\n);\nreg [2:0] shift_reg;\nwire [2:0] complement;\n\nshift_register sr (.clk(clk), .reset(reset), .data(data), .q(shift_reg));\nfunctional_module fm (.in1(shift_reg), .in2(q), .out(complement));\nd_ff ff (.clk(clk), .reset(reset), .d(complement[2]), .q(q));\nendmodule\nmodule shift_register(\n    input clk,\n    input reset,\n    input data,\n    output reg [2:0] q\n);\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 3'b0;\n    end else begin\n        q <= {q[1:0], data};\n    end\nend\nendmodule\nmodule d_ff (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\nmodule functional_module (\n    input [2:0] in1,\n    input in2,\n    output reg [2:0] out\n);\nalways@(*) begin\n    out = ~in1;\nend\nendmodule",
        "module_name": "top_",
        "module_hash": "6926522b64766ef5441b6c6771e81c33",
        "dataset_index": 1223
      },
      "majority_gate_bcc0bd4e": {
        "rtl_code": "\nmodule majority_gate(\n    input a, \n    input b,\n    input c,\n    input reset,\n    output wire out_assign,\n    output reg out_alwaysblock\n);\n\n    // Majority gate using assign statements\n    assign out_assign = (a & b) | (a & c) | (b & c);\n    \n    // Majority gate using a combinational always block\n    always @* begin\n        if(reset == 1'b1)\n             out_alwaysblock = 1'b0;\n        else begin\n           case ({a, b, c}) \n             3'b111: out_alwaysblock = 1'b1;\n             3'b110: out_alwaysblock = 1'b1;\n             3'b101: out_alwaysblock = 1'b1;\n             3'b011: out_alwaysblock = 1'b1;\n             default: out_alwaysblock = 1'b0;\n           endcase\n       end\n    end\n\nendmodule",
        "module_name": "majority_gate",
        "module_hash": "bcc0bd4e19a64d366bc47acc562a89a0",
        "dataset_index": 8584
      },
      "counter_3bit_a86d53c9": {
        "rtl_code": "module counter_3bit (\n    input clk,\n    input rst,\n    input en,\n    output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 3'b0;\n    end else if (en) begin\n        count <= count + 3'b1;\n    end\nend\n\nendmodule",
        "module_name": "counter_3bit",
        "module_hash": "a86d53c9b8920c2b9884ad1f66390ccf",
        "dataset_index": 14284
      },
      "VoltageLevelShifter #_1ae1b245": {
        "rtl_code": "\nmodule VoltageLevelShifter #(\n  parameter n = 4, // number of input signals \n  parameter m = 2 // number of output signal\n) (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\n\nparameter V1 = 3.3; // input voltage level\nparameter V2 = 5; // output voltage level\n\n// calculate R1 based on input parameters\nparameter R2 = 1000; // choose a value for R2\nparameter R1 = (V2 - V1) / (V1 / R2);\n\n// fixed implementation to avoid division\nassign out = (in * R2) >> 10; // equivalent to out = (in * R2) / (R1 + R2)\n\nendmodule",
        "module_name": "VoltageLevelShifter #",
        "module_hash": "1ae1b24526e0ecd5227e4000e4d89ffd",
        "dataset_index": 10659
      },
      "func5_17b3a3fa": {
        "rtl_code": "\nmodule func5(A, C);\n    input [25:0] A;\n    output [25:0] C;\n\n    wire [24:0] sum;  // Internal wire to store the sum of each bit\n    wire [24:0] c_out; // Internal wire to store the carry-out of each bit\n\n    // FullAdder module\n    FullAdder FA0(.a(A[25]), .b(A[24]), .c_in(1'b0), .sum(sum[24]), .c_out(c_out[24]));\n    FullAdder FA1(.a(sum[24]), .b(A[23]), .c_in(c_out[24]), .sum(sum[23]), .c_out(c_out[23]));\n    FullAdder FA2(.a(sum[23]), .b(A[22]), .c_in(c_out[23]), .sum(sum[22]), .c_out(c_out[22]));\n    FullAdder FA3(.a(sum[22]), .b(A[21]), .c_in(c_out[22]), .sum(sum[21]), .c_out(c_out[21]));\n    FullAdder FA4(.a(sum[21]), .b(A[20]), .c_in(c_out[21]), .sum(sum[20]), .c_out(c_out[20]));\n    FullAdder FA5(.a(sum[20]), .b(A[19]), .c_in(c_out[20]), .sum(sum[19]), .c_out(c_out[19]));\n    FullAdder FA6(.a(sum[19]), .b(A[18]), .c_in(c_out[19]), .sum(sum[18]), .c_out(c_out[18]));\n    FullAdder FA7(.a(sum[18]), .b(A[17]), .c_in(c_out[18]), .sum(sum[17]), .c_out(c_out[17]));\n    FullAdder FA8(.a(sum[17]), .b(A[16]), .c_in(c_out[17]), .sum(sum[16]), .c_out(c_out[16]));\n    FullAdder FA9(.a(sum[16]), .b(A[15]), .c_in(c_out[16]), .sum(sum[15]), .c_out(c_out[15]));\n    FullAdder FA10(.a(sum[15]), .b(A[14]), .c_in(c_out[15]), .sum(sum[14]), .c_out(c_out[14]));\n    FullAdder FA11(.a(sum[14]), .b(A[13]), .c_in(c_out[14]), .sum(sum[13]), .c_out(c_out[13]));\n    FullAdder FA12(.a(sum[13]), .b(A[12]), .c_in(c_out[13]), .sum(sum[12]), .c_out(c_out[12]));\n    FullAdder FA13(.a(sum[12]), .b(A[11]), .c_in(c_out[12]), .sum(sum[11]), .c_out(c_out[11]));\n    FullAdder FA14(.a(sum[11]), .b(A[10]), .c_in(c_out[11]), .sum(sum[10]), .c_out(c_out[10]));\n    FullAdder FA15(.a(sum[10]), .b(A[9]), .c_in(c_out[10]), .sum(sum[9]), .c_out(c_out[9]));\n    FullAdder FA16(.a(sum[9]), .b(A[8]), .c_in(c_out[9]), .sum(sum[8]), .c_out(c_out[8]));\n    FullAdder FA17(.a(sum[8]), .b(A[7]), .c_in(c_out[8]), .sum(sum[7]), .c_out(c_out[7]));\n    FullAdder FA18(.a(sum[7]), .b(A[6]), .c_in(c_out[7]), .sum(sum[6]), .c_out(c_out[6]));\n    FullAdder FA19(.a(sum[6]), .b(A[5]), .c_in(c_out[6]), .sum(sum[5]), .c_out(c_out[5]));\n    FullAdder FA20(.a(sum[5]), .b(A[4]), .c_in(c_out[5]), .sum(sum[4]), .c_out(c_out[4]));\n    FullAdder FA21(.a(sum[4]), .b(A[3]), .c_in(c_out[4]), .sum(sum[3]), .c_out(c_out[3]));\n    FullAdder FA22(.a(sum[3]), .b(A[2]), .c_in(c_out[3]), .sum(sum[2]), .c_out(c_out[2]));\n    FullAdder FA23(.a(sum[2]), .b(A[1]), .c_in(c_out[2]), .sum(sum[1]), .c_out(c_out[1]));\n    FullAdder FA24(.a(sum[1]), .b(A[0]), .c_in(c_out[1]), .sum(C[0]), .c_out(c_out[0]));\n\n    // Assign the carry-out of the last FullAdder to the carry-out of the top-level module\n    assign C[25] = c_out[0];\n\n    // Assign the sum of each FullAdder to the output of the top-level module\n    assign C[24:1] = sum[24:1];\nendmodule\nmodule FullAdder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n\n    assign sum = a ^ b ^ c_in;\n    assign c_out = (a & b) | (c_in & (a ^ b));\nendmodule",
        "module_name": "func5",
        "module_hash": "17b3a3fa7ffd168bdd340684be1a64df",
        "dataset_index": 1834
      },
      "parity_checker_97374f46": {
        "rtl_code": "\nmodule parity_checker (\n  input [7:0] in,\n  output [8:0] out\n);\n  assign out[8] = ^in;\n  assign out[7:0] = {in[6:4], in[2:0]};\nendmodule\n\nmodule edge_detector (\n  input clk,\n  input reset,\n  input in,\n  output rise,\n  output down\n);\n  reg [1:0] dff_out;\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      dff_out <= 2'b0;\n    end else begin\n      dff_out <= {dff_out[0], in};\n    end\n  end\n  assign rise = (dff_out[0] == 1'b1) && (dff_out[1] == 1'b0);\n  assign down = (dff_out[0] == 1'b0) && (dff_out[1] == 1'b1);\nendmodule\n\nmodule active_signal (\n  input [8:0] parity_in,\n  input rise_in,\n  input down_in,\n  output active_out\n);\n  assign active_out = ((parity_in[8] == 1'b0 && rise_in == 1'b1) || (parity_in[8] == 1'b1 && down_in == 1'b1)) ? 1'b1 : 1'b0;\nendmodule\n\nmodule top_module (\n  input               clk,\n  input               reset,\n  input [7:0]         in,\n  output [8:0]    parity_out,\n  output          rise,\n  output          down,\n  output          active\n);\n\n  parity_checker parity_checker_inst (\n    .in(in),\n    .out(parity_out)\n  );\n\n  edge_detector edge_detector_inst (\n    .clk(clk),\n    .reset(reset),\n    .in(in[0]),\n    .rise(rise),\n    .down(down)\n  );\n\n  active_signal active_signal_inst (\n    .parity_in(parity_out),\n    .rise_in(rise),\n    .down_in(down),\n    .active_out(active)\n  );\n\nendmodule\n",
        "module_name": "parity_checker",
        "module_hash": "97374f462fddbedf1d3bde3f78213c4e",
        "dataset_index": 18178
      },
      "wallace_multiplier_2ce6e161": {
        "rtl_code": "\nmodule wallace_multiplier (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input signed_ctrl,\n    output signed [15:0] result,\n    input clk  // Added clock input\n);\n\n// Pipeline registers\nreg signed [7:0] a_reg, b_reg;\nreg signed_ctrl_reg;\nreg signed [15:0] partial_sum_reg [0:2];\n\n// Wallace tree multiplier components\nwire signed [7:0] a1, b1, a2, b2, a3, b3;\nwire signed [11:0] p1, p2, p3, p4, p5;\nwire signed [15:0] s1, s2, s3;\n\n// Assign inputs to pipeline registers\nalways @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\n    signed_ctrl_reg <= signed_ctrl;\nend\n\n// Stage 1\nassign a1 = a_reg;\nassign b1 = signed_ctrl_reg ? b_reg : {1'b0, b_reg[6:0]};\nassign p1 = a1 * b1;\nassign s1 = {p1[5:0], 4'b0};\n\n// Stage 2\nassign a2 = a_reg;\nassign b2 = signed_ctrl_reg ? {1'b0, b_reg[7:0]} : b_reg;\nassign p2 = a2 * b2;\nassign s2 = {p2[5:0], 4'b0};\n\n// Stage 3\nassign a3 = a_reg;\nassign b3 = signed_ctrl_reg ? {1'b0, b_reg[7:1]} : {1'b0, b_reg[6:0]};\nassign p3 = a3 * b3;\nassign p4 = a3 * b2;\nassign p5 = a1 * b3;\nassign s3 = {p3[8:3], p4[8:3], p5[8:3]};\n\n// Stage 4\nalways @(posedge clk) begin\n    partial_sum_reg[0] <= s1;\n    partial_sum_reg[1] <= s2;\n    partial_sum_reg[2] <= s3;\nend\n\n// Final stage\nassign result = partial_sum_reg[0] + partial_sum_reg[1] + partial_sum_reg[2];\n\nendmodule\n",
        "module_name": "wallace_multiplier",
        "module_hash": "2ce6e161b92d9b166a4ee1c144ea85c9",
        "dataset_index": 21461
      },
      "ROM_TEST #_3981e2c7": {
        "rtl_code": "module ROM_TEST #(\n    parameter ADDR_WIDTH = 6,\n    parameter DATA_WIDTH = 1,\n    parameter ADDRESS_STEP = 1,\n    parameter MAX_ADDRESS = 63\n) (\n    input rst,\n    input clk,\n    input [DATA_WIDTH-1:0] read_data,\n    output reg [ADDR_WIDTH-1:0] read_address,\n    input [DATA_WIDTH-1:0] rom_read_data,\n    output reg [ADDR_WIDTH-1:0] rom_read_address,\n    output reg loop_complete,\n    output reg error,\n    output reg [7:0] error_state,\n    output reg [ADDR_WIDTH-1:0] error_address,\n    output reg [DATA_WIDTH-1:0] expected_data,\n    output reg [DATA_WIDTH-1:0] actual_data\n);\n    reg [7:0] state;\n    reg [DATA_WIDTH-1:0] test_value;\n    reg [1:0]            delay = 1'b0;\n\n    localparam START = 8'd1,\n        VERIFY_INIT = 8'd2;\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state <= START;\n            error <= 0;\n        end else begin\n            case(state)\n                START: begin\n                    loop_complete <= 0;\n                    state <= VERIFY_INIT;\n                    read_address <= 0;\n                    rom_read_address <= 0;\n                    error <= 0;\n                end\n                VERIFY_INIT: begin\n                    if(delay == 0) begin\n                        if(rom_read_data != read_data) begin\n                            error <= 1;\n                            error_state <= state;\n                            error_address <= read_address;\n                            expected_data <= rom_read_data;\n                            actual_data <= read_data;\n                        end else begin\n                            error <= 0;\n                        end\n                    end\n                    else if (delay == 1) begin\n                        if(read_address + ADDRESS_STEP <= MAX_ADDRESS) begin\n                            read_address <= read_address + ADDRESS_STEP;\n                            rom_read_address <= rom_read_address + ADDRESS_STEP;\n                        end else begin\n                            rom_read_address <= 0;\n                            read_address <= 0;\n                            loop_complete <= 1;\n                            state <= START;\n                        end\n                    end\n                    delay <= delay + 1;\n                end\n            endcase\n        end\n    end\nendmodule\n",
        "module_name": "ROM_TEST #",
        "module_hash": "3981e2c7e1984d1530d759fd71329775",
        "dataset_index": 17256
      },
      "shift_register_counter_757a3f49": {
        "rtl_code": "module shift_register_counter (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input in,         // Input signal to be delayed\n    input [3:0] delay, // Number of clock cycles to delay the input signal\n    output [3:0] q    // 4-bit output from the functional module\n);\n\n    reg [3:0] counter = 4'd0;\n    reg [3:0] shift_reg = 4'd0;\n    wire [3:0] delayed_out;\n    wire [3:0] counter_out;\n\n    // Shift register with delay\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'd0;\n        end else begin\n            shift_reg <= {in, shift_reg[3:1]};\n        end\n    end\n\n    assign delayed_out = shift_reg[delay];\n\n    // State machine counter\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'd0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign counter_out = counter;\n\n    // Functional module\n    assign q = delayed_out | counter_out;\n\nendmodule",
        "module_name": "shift_register_counter",
        "module_hash": "757a3f49835fb603eaac48fd5e072893",
        "dataset_index": 14289
      },
      "key_gen_f250ac8e": {
        "rtl_code": "\n\nmodule key_gen(previous_key,iteration,decrypt,non_perm_key,new_key);\n\ninput [55:0] previous_key;\ninput [3:0] iteration;\ninput decrypt;\noutput [55:0] non_perm_key;\noutput [47:0] new_key;\n\nreg [55:0] non_perm_key;\nreg [47:0] new_key;\n\n\nreg  prev0,prev1;\nreg[55:0]  prev_key_var,non_perm_key_var;\nreg[47:0]  new_key_var;\nreg[27:0]  semi_key;\n\n\nalways @(  previous_key or   iteration or   decrypt)\n\nbegin\n\n\n\t\n\tprev_key_var=previous_key;\n\tnew_key_var=0;\n\tnew_key = (0);\n\tnon_perm_key_var=0;\n\tnon_perm_key = (0);\n\t\n\tif(!decrypt)\n      begin\n\t  case(iteration)\n\n\t\t  0, 1, 8, 15:\n\t\t\tbegin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[27];\n\t\t      semi_key=semi_key<<1;\n\t\t      semi_key[0]=prev0;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[27];\n\t\t      semi_key=semi_key<<1;\n\t\t      semi_key[0]=prev0;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t     end\n\t\t  default:    \n\t\t\tbegin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[27];\n\t\t      prev1=semi_key[26];\n\t\t      semi_key=semi_key<<2;\n\t\t      semi_key[1]=prev0;\n\t\t      semi_key[0]=prev1;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[27];\n\t\t      prev1=semi_key[26];\n\t\t      semi_key=semi_key<<2;\n\t\t      semi_key[1]=prev0;\n\t\t      semi_key[0]=prev1;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t\tend\n      \n      endcase\n\t  end\n    else\n    begin\n\t  case(iteration)\n\n\t\t  0:\n\t\t  begin\n\t\t\t  semi_key=prev_key_var[55:28];\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n              non_perm_key_var[27:0]=semi_key;\n\t\t  end\n\t\t  1, 8, 15:\n\t\t  begin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[0];\n\t\t      semi_key=semi_key>>1;\n\t\t      semi_key[27]=prev0;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[0];\n\t\t      semi_key=semi_key>>1;\n\t\t      semi_key[27]=prev0;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t  end\n\t\t  default:    \n\t\t\tbegin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[0];\n\t\t      prev1=semi_key[1];\n\t\t      semi_key=semi_key>>2;\n\t\t      semi_key[26]=prev0;\n\t\t      semi_key[27]=prev1;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[0];\n\t\t      prev1=semi_key[1];\n\t\t      semi_key=semi_key>>2;\n\t\t      semi_key[26]=prev0;\n\t\t      semi_key[27]=prev1;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t  end\n\t \n      endcase\n\tend\n\n   \n   non_perm_key = (non_perm_key_var);\n      \n\n   new_key_var[47]=non_perm_key_var[42]; new_key_var[46]=non_perm_key_var[39]; new_key_var[45]=non_perm_key_var[45]; new_key_var[44]=non_perm_key_var[32];\n   new_key_var[43]=non_perm_key_var[55]; new_key_var[42]=non_perm_key_var[51]; new_key_var[41]=non_perm_key_var[53]; new_key_var[40]=non_perm_key_var[28];\n\t\n   new_key_var[39]=non_perm_key_var[41]; new_key_var[38]=non_perm_key_var[50]; new_key_var[37]=non_perm_key_var[35]; new_key_var[36]=non_perm_key_var[46];\n   new_key_var[35]=non_perm_key_var[33]; new_key_var[34]=non_perm_key_var[37]; new_key_var[33]=non_perm_key_var[44]; new_key_var[32]=non_perm_key_var[52];\n  \n   new_key_var[31]=non_perm_key_var[30]; new_key_var[30]=non_perm_key_var[48]; new_key_var[29]=non_perm_key_var[40]; new_key_var[28]=non_perm_key_var[49];\n   new_key_var[27]=non_perm_key_var[29]; new_key_var[26]=non_perm_key_var[36]; new_key_var[25]=non_perm_key_var[43]; new_key_var[24]=non_perm_key_var[54];\n\t\n   new_key_var[23]=non_perm_key_var[15]; new_key_var[22]=non_perm_key_var[4]; new_key_var[21]=non_perm_key_var[25]; new_key_var[20]=non_perm_key_var[19];\n   new_key_var[19]=non_perm_key_var[9]; new_key_var[18]=non_perm_key_var[1]; new_key_var[17]=non_perm_key_var[26]; new_key_var[16]=non_perm_key_var[16]; \n\n   new_key_var[15]=non_perm_key_var[5]; new_key_var[14]=non_perm_key_var[11]; new_key_var[13]=non_perm_key_var[23]; new_key_var[12]=non_perm_key_var[8]; \n   new_key_var[11]=non_perm_key_var[12]; new_key_var[10]=non_perm_key_var[7]; new_key_var[9]=non_perm_key_var[17]; new_key_var[8]=non_perm_key_var[0]; \n\t\n   new_key_var[7]=non_perm_key_var[22]; new_key_var[6]=non_perm_key_var[3]; new_key_var[5]=non_perm_key_var[10]; new_key_var[4]=non_perm_key_var[14]; \n   new_key_var[3]=non_perm_key_var[6]; new_key_var[2]=non_perm_key_var[20]; new_key_var[1]=non_perm_key_var[27]; new_key_var[0]=non_perm_key_var[24]; \n\n   new_key = (new_key_var);\n   \n\nend\n\nendmodule\n",
        "module_name": "key_gen",
        "module_hash": "f250ac8e74f855ba18279c51a29291e9",
        "dataset_index": 64
      },
      "mux2_1_d46fbd46": {
        "rtl_code": "\nmodule mux2_1(\n    input A,\n    input B,\n    input SEL,\n    output VOUT,\n    output VOUT_N\n);\n    assign VOUT = (SEL)? B:A;\n    assign VOUT_N = ~(SEL)? B:A;\n\nendmodule",
        "module_name": "mux2_1",
        "module_hash": "d46fbd46499ac3a97123b8a3ce903a0b",
        "dataset_index": 10754
      },
      "mux_adder_xor_b7eb5225": {
        "rtl_code": "module mux_adder_xor (\n    input [1:0] a,b,c,d,\n    input [1:0] sel,\n    output [1:0] mux_out,\n    output [1:0] adder_out,\n    output [1:0] final_output\n);\n\n    // 4-to-1 multiplexer module\n    reg [1:0] mux_input;\n    always @(*) begin\n        case(sel)\n            2'b00: mux_input = a;\n            2'b01: mux_input = b;\n            2'b10: mux_input = c;\n            2'b11: mux_input = d;\n        endcase\n    end\n    assign mux_out = mux_input;\n\n    // 2-bit adder module\n    wire [1:0] adder_input = {mux_input, b};\n    wire [1:0] sum = adder_input + 2'b01;\n    assign adder_out = sum;\n\n    // Functional module for XOR operation\n    wire [1:0] xor_output = mux_out ^ adder_out;\n    assign final_output = xor_output;\n\nendmodule",
        "module_name": "mux_adder_xor",
        "module_hash": "b7eb5225b5329a8385d3a4f4c5bad554",
        "dataset_index": 13332
      },
      "sky130_fd_sc_ms__einvp_c4f094cd": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__einvp (\n    Z ,\n    A ,\n    TE\n);\n\n    output Z ;\n    input  A ;\n    input  TE;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    notif1 notif10 (Z     , A, TE          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__einvp",
        "module_hash": "c4f094cd91d15b425572c6bc06d594c8",
        "dataset_index": 21863
      },
      "altera_up_video_camera_decoder_141c6266": {
        "rtl_code": "\n\n\n\nmodule altera_up_video_camera_decoder (\n\tclk,\n\treset,\n\n\tPIXEL_DATA,\n\tLINE_VALID,\n\tFRAME_VALID,\n\n\tready,\n\n\tdata,\n\tstartofpacket,\n\tendofpacket,\n\tvalid\n);\n\n\n\nparameter DW = 9;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[DW: 0]\tPIXEL_DATA;\ninput\t\t\t\t\t\tLINE_VALID;\ninput\t\t\t\t\t\tFRAME_VALID;\n\ninput\t\t\t\t\t\tready;\n\noutput reg\t[DW: 0]\tdata;\noutput reg\t\t\t\tstartofpacket;\noutput reg\t\t\t \tendofpacket;\noutput reg\t\t\t \tvalid;\n\n\n\n\nwire\t\t\t\tread_temps;\n\nreg\t\t\t[DW: 0]\tio_pixel_data;\nreg\t\t\t\t\t\tio_line_valid;\nreg\t\t\t\t\t\tio_frame_valid;\n\nreg\t\t\t\t\t\tframe_sync;\n\nreg\t\t\t[DW: 0]\ttemp_data;\nreg\t\t\t\t\t\ttemp_start;\nreg\t\t\t\t\t\ttemp_end;\nreg\t\t\t\t\t\ttemp_valid;\n\n\n\n\n\nalways @ (posedge clk)\nbegin\n\tio_pixel_data\t\t<= PIXEL_DATA;\n\tio_line_valid\t\t<= LINE_VALID;\n\tio_frame_valid\t\t<= FRAME_VALID;\nend\n\nalways @ (posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tdata\t\t\t\t<= 'h0;\n\t\tstartofpacket\t<= 1'b0;\n\t\tendofpacket\t\t<= 1'b0;\n\t\tvalid\t\t\t\t<= 1'b0;\n\tend\n\telse if (read_temps)\n\tbegin\n\t\tdata\t\t\t\t<= temp_data;\n\t\tstartofpacket\t<= temp_start;\n\t\tendofpacket\t\t<= temp_end;\n\t\tvalid\t\t\t\t<= temp_valid;\n\tend\n\telse if (ready)\n\t\tvalid\t\t\t\t<= 1'b0;\nend\n\nalways @ (posedge clk)\nbegin\n\tif (reset)\n\t\tframe_sync \t\t<= 1'b0;\n\telse if (~io_frame_valid)\n\t\tframe_sync \t\t<= 1'b1;\n\telse if (io_line_valid & io_frame_valid)\n\t\tframe_sync \t\t<= 1'b0;\nend\n\nalways @ (posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\ttemp_data \t\t<= 'h0;\n\t\ttemp_start\t\t<= 1'b0;\n\t\ttemp_end\t\t\t<= 1'b0;\n\t\ttemp_valid\t\t<= 1'b0;\n\tend\n\telse if (read_temps)\n\tbegin\n\t\ttemp_data \t\t<= io_pixel_data;\n\t\ttemp_start\t\t<= frame_sync;\n\t\ttemp_end\t\t\t<= ~io_frame_valid;\n\t\ttemp_valid\t\t<= io_line_valid & io_frame_valid;\n\tend\n\telse if (~io_frame_valid)\n\tbegin\n\t\ttemp_end\t\t\t<= ~io_frame_valid;\n\tend\nend\n\n\nassign read_temps = (ready | ~valid) & \n\t((io_line_valid & io_frame_valid) | \n\t ((temp_start | temp_end) & temp_valid));\n\n\n\n\n\nendmodule\n\n",
        "module_name": "altera_up_video_camera_decoder",
        "module_hash": "141c62661b6be158a4f7686d7d84525c",
        "dataset_index": 25186
      },
      "up_down_counter_b29231c4": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input up_down,\n    input reset,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0;\n        end else begin\n            if (up_down) begin\n                out <= out + 4'b1;\n            end else begin\n                out <= out - 4'b1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "b29231c4b6947a07adc9c80dc6956c77",
        "dataset_index": 2592
      },
      "decoder_3to8_case_99b0211b": {
        "rtl_code": "module decoder_3to8_case (\n    input A, B, C,\n    output reg [7:0] Y\n);\n\n    always @* begin\n        case ({A, B, C})\n            3'b000: Y = 8'b00000001;\n            3'b001: Y = 8'b00000010;\n            3'b010: Y = 8'b00000100;\n            3'b011: Y = 8'b00001000;\n            3'b100: Y = 8'b00010000;\n            3'b101: Y = 8'b00100000;\n            3'b110: Y = 8'b01000000;\n            3'b111: Y = 8'b10000000;\n        endcase\n    end\n\nendmodule",
        "module_name": "decoder_3to8_case",
        "module_hash": "99b0211bc367b40c6f44a7a50e5b5277",
        "dataset_index": 7818
      },
      "t_ff_6e670c8e": {
        "rtl_code": "\nmodule t_ff (\n    input clk,\n    input t,\n    output reg q\n);\n\nreg d1, d2;\n\nalways @(posedge clk) begin\n    d1 <= t;\n    d2 <= d1;\n    q <= d1 ^ d2;\nend\n\nendmodule\nmodule bcd_counter (\n    input clk,\n    input reset,\n    input [2:0] ena, // ena[3] is undef\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        if (ena[0]) begin\n            if (count[0] == 4'b1001) begin\n                count[0] <= 4'b0000;\n                if (ena[1]) begin\n                    if (count[1] == 4'b1001) begin\n                        count[1] <= 4'b0000;\n                        if (ena[2]) begin\n                            if (count[2] == 4'b1001) begin\n                                count[2] <= 4'b0000;\n                                if (count[3] == 4'b1001) begin\n                                    count[3] <= 4'b0000;\n                                end else begin\n                                    count[3] <= count[3] + 1;\n                                end\n                            end else begin\n                                count[2] <= count[2] + 1;\n                            end\n                        end\n                    end else begin\n                        count[1] <= count[1] + 1;\n                    end\n                end\n            end else begin\n                count[0] <= count[0] + 1;\n            end\n        end\n    end\nend\n\nendmodule\nmodule functional_module (\n    input t,\n    input [3:0] count,\n    output [15:0] q\n);\n\nassign q = {count, 1'b0} | (t ? 16'b0000000000000001 : 16'b0);\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input t,\n    output reg [2:0] ena,\n    output [15:0] q\n);\n\nwire t_ff_q;\nwire [3:0] bcd_count;\n\nt_ff t_ff_inst (\n    .clk(clk),\n    .t(t),\n    .q(t_ff_q)\n);\n\nbcd_counter bcd_counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .ena(ena),\n    .count(bcd_count)\n);\n\nfunctional_module functional_module_inst (\n    .t(t_ff_q),\n    .count(bcd_count),\n    .q(q)\n);\n\ninitial begin\n    ena = 3'b000;\nend\n\nendmodule",
        "module_name": "t_ff",
        "module_hash": "6e670c8e420e3c52a893cd9c57782d7e",
        "dataset_index": 20265
      },
      "util_rfifo_7e6aa621": {
        "rtl_code": "\n\nmodule util_rfifo (\n\n  dac_clk,\n  dac_rd,\n  dac_rdata,\n  dac_runf,\n\n  dma_clk,\n  dma_rd,\n  dma_rdata,\n  dma_runf,\n\n  fifo_rst,\n  fifo_rstn,\n  fifo_wr,\n  fifo_wdata,\n  fifo_wfull,\n  fifo_rd,\n  fifo_rdata,\n  fifo_rempty,\n  fifo_runf);\n\n  parameter DAC_DATA_WIDTH = 32;\n  parameter DMA_DATA_WIDTH = 64;\n \n  input                           dac_clk;\n  input                           dac_rd;\n  output  [DAC_DATA_WIDTH-1:0]    dac_rdata;\n  output                          dac_runf;\n\n  input                           dma_clk;\n  output                          dma_rd;\n  input   [DMA_DATA_WIDTH-1:0]    dma_rdata;\n  input                           dma_runf;\n\n  output                          fifo_rst;\n  output                          fifo_rstn;\n  output                          fifo_wr;\n  output  [DMA_DATA_WIDTH-1:0]    fifo_wdata;\n  input                           fifo_wfull;\n  output                          fifo_rd;\n  input   [DAC_DATA_WIDTH-1:0]    fifo_rdata;\n  input                           fifo_rempty;\n  input                           fifo_runf;\n\n  reg     [ 1:0]                  dac_runf_m = 'd0;\n  reg                             dac_runf = 'd0;\n  reg                             dma_rd = 'd0;\n\n  always @(posedge dac_clk) begin\n    dac_runf_m[0] <= dma_runf | fifo_runf;\n    dac_runf_m[1] <= dac_runf_m[0];\n    dac_runf <= dac_runf_m[1];\n  end\n\n  always @(posedge dma_clk) begin\n    dma_rd <= ~fifo_wfull;\n  end\n\n  assign fifo_wr = dma_rd;\n\n  genvar s;\n  generate\n  for (s = 0; s < DMA_DATA_WIDTH; s = s + 1) begin: g_wdata\n  assign fifo_wdata[s] = dma_rdata[(DMA_DATA_WIDTH-1)-s];\n  end\n  endgenerate\n\n  assign fifo_rd = ~fifo_rempty & dac_rd;\n\n  genvar m;\n  generate\n  for (m = 0; m < DAC_DATA_WIDTH; m = m + 1) begin: g_rdata\n  assign dac_rdata[m] = fifo_rdata[(DAC_DATA_WIDTH-1)-m];\n  end\n  endgenerate\n\n  assign fifo_rst = 1'b0;\n  assign fifo_rstn = 1'b1;\n\nendmodule\n\n",
        "module_name": "util_rfifo",
        "module_hash": "7e6aa6215cabe724137a561b81b4baa2",
        "dataset_index": 20933
      },
      "scale_1d #_72676cb5": {
        "rtl_code": "\n\nmodule scale_1d #\n(\n\tparameter integer C_M_WIDTH = 12,\n\tparameter integer C_S_WIDTH = 10,\n\n\tparameter integer C_S_ADDR_WIDTH = 32\n)\n(\n\tinput wire clk,\n\tinput wire resetn,\n\n\tinput wire [C_S_WIDTH-1:0] s_width,\n\tinput wire [C_M_WIDTH-1:0] m_width,\n\n\tinput wire start,\n\n\toutput wire o_valid,\n\toutput wire [C_S_WIDTH-1:0] s_index,\n\toutput wire [C_M_WIDTH-1:0] m_index,\n\toutput wire o_last,\n\tinput wire  o_ready,\n\n\tinput  wire [C_S_ADDR_WIDTH-1:0] s_base_addr,\n\tinput  wire [C_S_ADDR_WIDTH-1:0] s_off_addr,\n\tinput  wire [C_S_ADDR_WIDTH-1:0] s_inc_addr,\n\toutput reg  [C_S_ADDR_WIDTH-1:0] s_addr\n);\n\n\tlocalparam integer C_CNT_WIDTH = C_M_WIDTH + C_S_WIDTH;\n\n\twire progress;\n\tassign progress = ~o_valid || o_ready;\n\twire next;\n\tassign next = o_valid && o_ready;\n\n\treg [C_CNT_WIDTH-1 : 0] s_cnt;\n\treg [C_CNT_WIDTH-1 : 0] m_cnt;\n\n\treg [C_S_WIDTH-1 : 0] s_idx;\n\tassign s_index = s_idx;\n\treg [C_M_WIDTH-1 : 0] m_idx;\n\tassign m_index = m_idx;\n\n\treg running;\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\trunning <= 0;\n\t\tend\n\t\telse if (start) begin\n\t\t\trunning <= 1;\n\t\tend\n\t\telse if (next && m_idx == m_width - 1) begin\n\t\t\trunning <= 0;\n\t\tend\n\tend\n\n\tassign o_valid = (running && s_cnt >= m_cnt);\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\ts_cnt <= 0;\n\t\t\ts_idx <= 0;\n\t\t\ts_addr <= 0;\n\n\t\t\tm_cnt <= 0;\n\t\t\tm_idx <= 0;\n\t\tend\n\t\telse if (start) begin\n\t\t\ts_cnt <= m_width;\n\t\t\ts_idx <= 0;\n\t\t\ts_addr <= s_base_addr + s_off_addr;\n\n\t\t\tm_cnt <= s_width;\n\t\t\tm_idx <= 0;\n\t\tend\n\t\telse if (running) begin\n\t\t\tif (progress) begin\n\t\t\t\tif (s_cnt <= m_cnt) begin\n\t\t\t\t\ts_cnt <= s_cnt + m_width;\n\t\t\t\t\ts_idx <= s_idx + 1;\n\t\t\t\t\ts_addr <= s_addr + s_inc_addr;\n\t\t\t\tend\n\t\t\t\tif (s_cnt >= m_cnt) begin\n\t\t\t\t\tm_cnt <= m_cnt + s_width;\n\t\t\t\t\tm_idx <= m_idx + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treg last;\n\tassign o_last = last;\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\tlast <= 0;\n\t\tend\n\t\telse if (start) begin\n\t\t\tlast <= 0;\n\t\tend\n\t\telse if (next && m_idx == m_width - 2) begin\n\t\t\tlast <= 1;\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "scale_1d #",
        "module_hash": "72676cb5005772e526c1073fbce5d8b2",
        "dataset_index": 17148
      },
      "system_axi_quad_spi_shield_0_wr_status_flags_as_d61aebb1": {
        "rtl_code": "\nmodule system_axi_quad_spi_shield_0_wr_status_flags_as\n   (\\gic0.gc1.count_reg[0] ,\n    E,\n    \\gic0.gc1.count_d2_reg[0] ,\n    s_axi_aclk,\n    out,\n    p_6_in,\n    ip2Bus_WrAck_core_reg_1,\n    Bus_RNW_reg);\n  output \\gic0.gc1.count_reg[0] ;\n  output [0:0]E;\n  input \\gic0.gc1.count_d2_reg[0] ;\n  input s_axi_aclk;\n  input out;\n  input p_6_in;\n  input ip2Bus_WrAck_core_reg_1;\n  input Bus_RNW_reg;\n\n  wire Bus_RNW_reg;\n  wire [0:0]E;\n  wire \\gic0.gc1.count_d2_reg[0] ;\n  wire ip2Bus_WrAck_core_reg_1;\n  wire out;\n  wire p_6_in;\n  reg ram_full_fb_i;\n  reg ram_full_i;\n  reg ram_full_i_reg0;\n  reg ram_full_i_reg1;\n  reg ram_full_i_reg2;\n  wire s_axi_aclk;\n\n  assign \\gic0.gc1.count_reg[0]  = ram_full_i_reg2;\n  assign E = 1'b0;\n\n   reg [255:0] ram [0:0] ; \n\n  always @(posedge s_axi_aclk) begin\n    if (p_6_in) begin\n        ram[0][ip2Bus_WrAck_core_reg_1] <= 1'b1;\n    end\n  end\n\n  // Flip-flops\n  always @(posedge s_axi_aclk) begin\n    if (Bus_RNW_reg) begin\n      ram_full_i <= out;\n      ram_full_fb_i <= 1'b0;\n    end\n    else begin\n      ram_full_fb_i <= ram_full_i;\n    end\n  end\n\n  always @(posedge s_axi_aclk) begin\n    ram_full_i_reg0 <= ram_full_fb_i;\n    ram_full_i_reg1 <= ram_full_i_reg0;\n    ram_full_i_reg2 <= ram_full_i_reg1;\n  end\n\nendmodule",
        "module_name": "system_axi_quad_spi_shield_0_wr_status_flags_as",
        "module_hash": "d61aebb11266e983d4a5a7ac039cb204",
        "dataset_index": 9374
      },
      "top__5885fe3f": {
        "rtl_code": "module top_module (\n    input [3:0] A,\n    input [3:0] B,\n    output eq,\n    output gt,\n    input C,\n    input [3:0] D,\n    output [3:0] final_output\n);\n\n    assign eq = (A == B); \n    assign gt = (A > B); \n\n\n    wire [3:0] shifted_value;\n    assign shifted_value = (C == 0) ? (A << D[1:0]) : (A >> D[1:0]); // Limit shift to meaningful range\n\n\n    assign final_output = eq ? shifted_value : 4'b0000;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "5885fe3f97c4df246381ff9aea179204",
        "dataset_index": 246
      },
      "top_module_8c9dfa74": {
        "rtl_code": "module top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output reg [7:0] final_out\n);\n\n    // 2-level AND-OR circuit\n    wire [1:0] and_out;\n    assign and_out[0] = in[0] & in[1];\n    assign and_out[1] = in[2] & in[3];\n    assign out_and = and_out[0] | and_out[1];\n    \n    // 2-level OR-AND circuit\n    wire [1:0] or_out;\n    assign or_out[0] = in[0] | in[1];\n    assign or_out[1] = in[2] | in[3];\n    assign out_or = or_out[0] & or_out[1];\n    \n    // 2-level XOR-AND circuit\n    wire [1:0] xor_out;\n    assign xor_out[0] = in[0] ^ in[1];\n    assign xor_out[1] = in[2] ^ in[3];\n    assign out_xor = xor_out[0] & xor_out[1];\n    \n    // Final output\n    always @* begin\n        final_out = {1'b0, out_and, out_or, out_xor};\n    end\n    \nendmodule",
        "module_name": "top_module",
        "module_hash": "8c9dfa749d483d0f152496fb214e9705",
        "dataset_index": 5934
      },
      "signal_module_936bd7b8": {
        "rtl_code": "module signal_module(\n    input clk,\n    input reset,\n    input [3:0] data_in,\n    input enable,\n    output [3:0] data_out,\n    output parity,\n    output overflow,\n    output underflow\n);\n\nreg [3:0] data_out_reg;\nreg parity_reg;\nreg overflow_reg;\nreg underflow_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out_reg <= 4'b0000;\n        parity_reg <= 1'b0;\n        overflow_reg <= 1'b0;\n        underflow_reg <= 1'b0;\n    end else if (enable) begin\n        data_out_reg <= data_out_reg + data_in;\n        parity_reg <= ~parity_reg;\n        overflow_reg <= (data_out_reg + data_in) > 4'b1111;\n        underflow_reg <= (data_out_reg + data_in) < 4'b0000;\n    end\nend\n\nassign data_out = data_out_reg;\nassign parity = parity_reg;\nassign overflow = overflow_reg;\nassign underflow = underflow_reg;\n\nendmodule",
        "module_name": "signal_module",
        "module_hash": "936bd7b81587b4a7a4bfc2c2276b58ed",
        "dataset_index": 13581
      },
      "mux4to1_536e986e": {
        "rtl_code": "\nmodule mux4to1 (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input sel0,\n    input sel1,\n    output out,\n    inout VPWR,\n    inout VGND,\n    inout VPB,\n    inout VNB\n);\n\n    assign out = (sel1 & (sel0 & in0 | ~sel0 & in1)) | (~sel1 & (sel0 & in2 | ~sel0 & in3));\n\nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "536e986e8fec59e0efd19cb561b21640",
        "dataset_index": 20070
      },
      "sqrt_16bit_c0e70a85": {
        "rtl_code": "\nmodule sqrt_16bit (\n    input [15:0] a,\n    input ctrl,\n    output reg [15:0] b\n);\n\n    reg [15:0] x;\n    reg [3:0] i;\n    reg [15:0] temp;\n\n    always @(*) begin\n        x = 8'd0;\n        i = 4'd0;\n        temp = 16'd0;\n        for (i = 4'd0; i < 4'd8; i = i + 1) begin\n            temp = (x << 1) + (1 << (7 - i));\n            if (temp * temp <= a) begin\n                x = temp;\n            end\n        end\n        if (ctrl == 1) begin\n            if (((x + 1) * (x + 1) - a) <= (a - x * x)) begin\n                b = x + 1;\n            end else begin\n                b = x;\n            end\n        end else begin\n            b = x;\n        end\n    end\n\nendmodule",
        "module_name": "sqrt_16bit",
        "module_hash": "c0e70a854358eef8cc4cf0f8143fa75a",
        "dataset_index": 21307
      },
      "top__89baf090": {
        "rtl_code": "\nmodule top_module (\n    input wire [15:0] in,\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [7:0] out\n);\n\n    wire [7:0] upper_byte;\n    wire [7:0] lower_byte;\n    wire [7:0] sum;\n    wire overflow;\n\n    byte_splitter bs(\n        .in(in),\n        .out_hi(upper_byte),\n        .out_lo(lower_byte)\n    );\n\n    add_overflow_detection aod_upper(\n        .a(a),\n        .b(upper_byte),\n        .s(sum),\n        .overflow(overflow)\n    );\n\n    add_overflow_detection aod_lower(\n        .a(b),\n        .b(lower_byte),\n        .s(),\n        .overflow()\n    );\n\n    assign out = sum;\n\nendmodule\nmodule byte_splitter (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule\nmodule add_overflow_detection (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    reg [8:0] temp_sum;\n    assign s = temp_sum[7:0];\n    assign overflow = (temp_sum[8] == 1);\n\n    always @(*) begin\n        temp_sum = a + b;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "89baf090c0da47b7da66e1946930f695",
        "dataset_index": 14144
      },
      "sky130_fd_sc_hs__a222o_0559ff41": {
        "rtl_code": "module sky130_fd_sc_hs__a222o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1,\n    C2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n    input  C2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign X = ((A1 & A2) | (B1 & B2) | (~C1 & ~C2)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__a222o",
        "module_hash": "0559ff41332472bbfeb3b9385ad5b5a6",
        "dataset_index": 11388
      },
      "sync_ptr_d27fe5fd": {
        "rtl_code": "\n\n\nmodule sync_ptr\n\n    #(\n    parameter ASIZE = 4\n    )(\n    input  wire              dest_clk,\n    input  wire              dest_rst_n,\n    input  wire [ASIZE:0] src_ptr,\n    output reg  [ASIZE:0] dest_ptr\n    );\n\n    reg [ASIZE:0] ptr_x;\n\n    always @(posedge dest_clk or negedge dest_rst_n) begin\n\n        if (!dest_rst_n)\n            {dest_ptr,ptr_x} <= 0;\n        else\n            {dest_ptr,ptr_x} <= {ptr_x,src_ptr};\n    end\n\nendmodule\n\n`resetall\n",
        "module_name": "sync_ptr",
        "module_hash": "d27fe5fda617c61d8f215fd765a3f1ea",
        "dataset_index": 5839
      },
      "user_design_cbce69ca": {
        "rtl_code": "module user_design\n   (IN1_STB,\n    OUT1_ACK,\n    output_rs232_out,\n    INTERNAL_RST_reg,\n    OUT1,\n    IN1_ACK,\n    ETH_CLK_OBUF,\n    OUT1_STB);\n  output IN1_STB;\n  output OUT1_ACK;\n  output [7:0]output_rs232_out;\n  input INTERNAL_RST_reg;\n  input [7:0]OUT1;\n  input IN1_ACK;\n  input ETH_CLK_OBUF;\n  input OUT1_STB;\n\n  assign IN1_STB = (INTERNAL_RST_reg == 1'b0) && (IN1_ACK == 1'b1) && (OUT1_STB == 1'b0);\n  assign OUT1_ACK = (INTERNAL_RST_reg == 1'b0) && (OUT1_STB == 1'b1);\n  assign output_rs232_out = (INTERNAL_RST_reg == 1'b0) && (OUT1_STB == 1'b1) ? OUT1 : 8'h0;\n\nendmodule",
        "module_name": "user_design",
        "module_hash": "cbce69ca02467ceef61869686790ef49",
        "dataset_index": 4312
      },
      "parity #_7c9351b3": {
        "rtl_code": "module parity #(\n  parameter n = 8 // width of the data stream (number of bits)\n)(\n  input [n-1:0] data,\n  input sel,\n  output parity,\n  output [n:0] out\n);\n\n\nreg [n-1:0] temp_data;\nreg [n:0] temp_out;\nreg temp_parity;\n\ninteger i;\ninteger count;\n\nalways @(*) begin\n  count = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    if (data[i] == 1) begin\n      count = count + 1;\n    end\n  end\n  \n  if (sel == 0) begin // parity generator\n    if (count % 2 == 0) begin // even parity\n      temp_parity = 0;\n      temp_out = {data, temp_parity};\n    end\n    else begin // odd parity\n      temp_parity = 1;\n      temp_out = {data, temp_parity};\n    end\n  end\n  else begin // parity checker\n    if (count % 2 == 0) begin // even parity\n      temp_parity = 0;\n      temp_out = data;\n    end\n    else begin // odd parity\n      temp_parity = 1;\n      temp_out = data ^ 1; // flip the last bit to correct the parity\n    end\n  end\nend\n\nassign parity = temp_parity;\nassign out = temp_out;\n\nendmodule",
        "module_name": "parity #",
        "module_hash": "7c9351b385e21a9cbb45b3304b7cc0d5",
        "dataset_index": 15220
      },
      "barrel_shifter_4bit_babef8b8": {
        "rtl_code": "module barrel_shifter_4bit (\n    input [3:0] DATA_IN,\n    input [1:0] SHIFT,\n    output reg [3:0] DATA_OUT\n);\n\n    always @(*) begin\n        case(SHIFT)\n            2'b00: DATA_OUT = DATA_IN;\n            2'b01: DATA_OUT = {DATA_IN[3], DATA_IN[2:0]};\n            2'b10: DATA_OUT = {DATA_IN[2:0], DATA_IN[3]};\n            2'b11: DATA_OUT = {DATA_IN[1:0], DATA_IN[3:2]};\n        endcase\n    end\n\nendmodule",
        "module_name": "barrel_shifter_4bit",
        "module_hash": "babef8b84e4cda8093be624fc11e64d8",
        "dataset_index": 2552
      },
      "mux_2to1_66d12da0": {
        "rtl_code": "module mux_2to1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "66d12da0f2e51b418cb2f09812060321",
        "dataset_index": 11160
      },
      "lcd_driver_d6047d03": {
        "rtl_code": "module lcd_driver (\n  input [3:0] data,\n  input [1:0] ctrl,\n  output [6:0] seg\n);\n\n  // Define the 7-bit segment signal as a Boolean function of the 4-bit data signal and the 2-bit control signal\n  assign seg[0] = (data[0] & ctrl[0]) | (~data[0] & ctrl[1]);\n  assign seg[1] = (data[1] & ctrl[0]) | (~data[1] & ctrl[1]);\n  assign seg[2] = (data[2] & ctrl[0]) | (~data[2] & ctrl[1]);\n  assign seg[3] = (data[3] & ctrl[0]) | (~data[3] & ctrl[1]);\n  assign seg[4] = ctrl[0];\n  assign seg[5] = ctrl[1];\n  assign seg[6] = 0;\n\nendmodule",
        "module_name": "lcd_driver",
        "module_hash": "d6047d03357561cd9db39f7668a68a3e",
        "dataset_index": 16742
      },
      "mux_adder_2317b27c": {
        "rtl_code": "module mux_adder (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    input [1:0] add_in,\n    input clk,\n    input reset,\n    input select,\n    output reg [7:0] out\n);\n\nreg [3:0] mux_out;\nreg [1:0] add_out;\n\nalways @ (sel or data0 or data1 or data2 or data3 or data4 or data5) begin\n    case (sel)\n        3'b000: mux_out = data0;\n        3'b001: mux_out = data1;\n        3'b010: mux_out = data2;\n        3'b011: mux_out = data3;\n        3'b100: mux_out = data4;\n        3'b101: mux_out = data5;\n        default: mux_out = 4'b0;\n    endcase\nend\n\nalways @ (add_in or select) begin\n    if (select == 1'b0) begin\n        add_out = 2'b0;\n    end else begin\n        add_out = add_in;\n    end\nend\n\nalways @ (posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 8'b0;\n    end else begin\n        if (select == 1'b0) begin\n            out <= mux_out;\n        end else begin\n            out <= {2'b0, mux_out} + {2'b0, add_out};\n        end\n    end\nend\n\nendmodule",
        "module_name": "mux_adder",
        "module_hash": "2317b27c79055e63c6a1d1e636a1cd12",
        "dataset_index": 8637
      },
      "pfpu_prog_6fbd571c": {
        "rtl_code": "\n\n\n\nmodule pfpu_prog(\n\tinput sys_clk,\n\tinput count_rst,\n\n\toutput [6:0] a_addr,\n\toutput [6:0] b_addr,\n\toutput [3:0] opcode,\n\toutput [6:0] w_addr,\n\t\n\t\n\tinput c_en,\n\tinput [1:0] c_page,\n\tinput [8:0] c_offset,\n\toutput [31:0] c_do,\n\tinput [31:0] c_di,\n\tinput c_w_en,\n\n\toutput [10:0] pc\n);\n\n\nwire [10:0] mem_a;\nwire [24:0] mem_di;\nreg [24:0] mem_do;\nwire mem_we;\nreg [24:0] mem[0:2047];\nalways @(posedge sys_clk) begin\n\tif(mem_we)\n\t\tmem[mem_a] <= mem_di;\n\tmem_do <= mem[mem_a];\nend\n\n\nreg [10:0] counter;\nalways @(posedge sys_clk) begin\n\tif(count_rst)\n\t\tcounter <= 10'd0;\n\telse\n\t\tcounter <= counter + 10'd1;\nend\nassign mem_a = c_en ? {c_page, c_offset} : counter;\n\nassign c_do = {7'd0, mem_do};\nassign mem_di = c_di[24:0];\nassign mem_we = c_en & c_w_en;\n\nassign a_addr = mem_do[24:18];\tassign b_addr = mem_do[17:11];\tassign opcode = mem_do[10:7];\tassign w_addr = mem_do[6:0];\tassign pc = counter;\n\nendmodule\n",
        "module_name": "pfpu_prog",
        "module_hash": "6fbd571c92235099d3a00241b6d0db99",
        "dataset_index": 23615
      },
      "mux4to1_5c5b6652": {
        "rtl_code": "module mux4to1 (\n    // module ports\n    input [3:0] D,\n    input S0,\n    input S1,\n    output Y\n);\n\n    wire not_S1;\n    wire not_S0;\n\n    // invert S1 and S0 signals\n    assign not_S1 = ~S1;\n    assign not_S0 = ~S0;\n\n    // select the correct input based on S1 and S0\n    assign Y = (D[0] & not_S1 & not_S0) | (D[1] & not_S1 & S0) | (D[2] & S1 & not_S0) | (D[3] & S1 & S0);\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "5c5b6652774e049f962a96bc11a3c17e",
        "dataset_index": 17419
      },
      "sky130_fd_sc_ls__o22a_095569e2": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o22a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1          );\n    or  or1  (or1_out   , B2, B1          );\n    and and0 (and0_out_X, or0_out, or1_out);\n    buf buf0 (X         , and0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o22a",
        "module_hash": "095569e2f0ee74c886683de61e1b614c",
        "dataset_index": 22300
      },
      "generic_dpram_faa6eece": {
        "rtl_code": "`define VENDOR_FPGA\nmodule generic_dpram(\n\trclk, rrst, rce, oe, raddr, do,\n\twclk, wrst, wce, we, waddr, di\n);\n\n\tparameter aw = 5;  parameter dw = 16; input           rclk;  input           rrst;  input           rce;   input           oe;\t   input  [aw-1:0] raddr; output [dw-1:0] do;    input          wclk;  input          wrst;  input          wce;   input          we;    input [aw-1:0] waddr; input [dw-1:0] di;    `ifdef VENDOR_FPGA\n\treg [dw-1:0] mem [(1<<aw) -1:0]; reg [aw-1:0] ra;                 always @(posedge rclk)\n\t  if (rce)\n\t    ra <= raddr;\n\n\tassign do = mem[ra];\n\n\talways@(posedge wclk)\n\t\tif (we && wce)\n\t\t\tmem[waddr] <= di;\n\n`else\n\n`ifdef VENDOR_XILINX\n\txilinx_ram_dp xilinx_ram(\n\t\t.CLKA(rclk),\n\t\t.RSTA(rrst),\n\t\t.ENA(rce),\n\t\t.ADDRA(raddr),\n\t\t.DIA( {dw{1'b0}} ),\n\t\t.WEA(1'b0),\n\t\t.DOA(do),\n\n\t\t.CLKB(wclk),\n\t\t.RSTB(wrst),\n\t\t.ENB(wce),\n\t\t.ADDRB(waddr),\n\t\t.DIB(di),\n\t\t.WEB(we),\n\t\t.DOB()\n\t);\n\n\tdefparam\n\t\txilinx_ram.dwidth = dw,\n\t\txilinx_ram.awidth = aw;\n\n`else\n\n`ifdef VENDOR_ALTERA\n\taltera_ram_dp altera_ram(\n\t\t.rdclock(rclk),\n\t\t.rdclocken(rce),\n\t\t.rdaddress(raddr),\n\t\t.q(do),\n\n\t\t.wrclock(wclk),\n\t\t.wrclocken(wce),\n\t\t.wren(we),\n\t\t.wraddress(waddr),\n\t\t.data(di)\n\t);\n\n\tdefparam\n\t\taltera_ram.dwidth = dw,\n\t\taltera_ram.awidth = aw;\n\n`else\n\n`ifdef VENDOR_ARTISAN\n\n\tart_hsdp #(dw, 1<<aw, aw) artisan_sdp(\n\t\t.qa(do),\n\t\t.clka(rclk),\n\t\t.cena(~rce),\n\t\t.wena(1'b1),\n\t\t.aa(raddr),\n\t\t.da( {dw{1'b0}} ),\n\t\t.oena(~oe),\n\n\t\t.qb(),\n\t\t.clkb(wclk),\n\t\t.cenb(~wce),\n\t\t.wenb(~we),\n\t\t.ab(waddr),\n\t\t.db(di),\n\t\t.oenb(1'b1)\n\t);\n\n`else\n\n`ifdef VENDOR_AVANT\n\n\tavant_atp avant_atp(\n\t\t.web(~we),\n\t\t.reb(),\n\t\t.oeb(~oe),\n\t\t.rcsb(),\n\t\t.wcsb(),\n\t\t.ra(raddr),\n\t\t.wa(waddr),\n\t\t.di(di),\n\t\t.do(do)\n\t);\n\n`else\n\n`ifdef VENDOR_VIRAGE\n\n\tvirage_stp virage_stp(\n\t\t.CLKA(rclk),\n\t\t.MEA(rce_a),\n\t\t.ADRA(raddr),\n\t\t.DA( {dw{1'b0}} ),\n\t\t.WEA(1'b0),\n\t\t.OEA(oe),\n\t\t.QA(do),\n\n\t\t.CLKB(wclk),\n\t\t.MEB(wce),\n\t\t.ADRB(waddr),\n\t\t.DB(di),\n\t\t.WEB(we),\n\t\t.OEB(1'b1),\n\t\t.QB()\n\t);\n\n`else\n\n\treg\t[dw-1:0]\tmem [(1<<aw)-1:0]; reg\t[dw-1:0]\tdo_reg;            assign do = (oe & rce) ? do_reg : {dw{1'bz}};\n\n\talways @(posedge rclk)\n\t\tif (rce)\n          \t\tdo_reg <= (we && (waddr==raddr)) ? {dw{1'b x}} : mem[raddr];\n\n\talways @(posedge wclk)\n\t\tif (wce && we)\n\t\t\tmem[waddr] <= di;\n\n\n\ttask print_ram;\n\tinput [aw-1:0] start;\n\tinput [aw-1:0] finish;\n\tinteger rnum;\n  \tbegin\n    \t\tfor (rnum=start;rnum<=finish;rnum=rnum+1)\n      \t\t\t$display(\"Addr %h = %h\",rnum,mem[rnum]);\n  \tend\n\tendtask\n\n`endif `endif `endif `endif `endif `endif endmodule\n\n`ifdef VENDOR_ALTERA\n\tmodule altera_ram_dp(\n\t\tdata,\n\t\twraddress,\n\t\trdaddress,\n\t\twren,\n\t\twrclock,\n\t\twrclocken,\n\t\trdclock,\n\t\trdclocken,\n\t\tq) ;\n\n\t\tparameter awidth = 7;\n\t\tparameter dwidth = 8;\n\n\t\tinput [dwidth -1:0] data;\n\t\tinput [awidth -1:0] wraddress;\n\t\tinput [awidth -1:0] rdaddress;\n\t\tinput               wren;\n\t\tinput               wrclock;\n\t\tinput               wrclocken;\n\t\tinput               rdclock;\n\t\tinput               rdclocken;\n\t\toutput [dwidth -1:0] q;\n\n\t\tsyn_dpram_rowr #(\n\t\t\t\"UNUSED\",\n\t\t\tdwidth,\n\t\t\tawidth,\n\t\t\t1 << awidth\n\t\t)\n\t\taltera_dpram_model (\n\t\t\t.RdClock(rdclock),\n\t\t\t.RdClken(rdclocken),\n\t\t\t.RdAddress(rdaddress),\n\t\t\t.RdEn(1'b1),\n\t\t\t.Q(q),\n\n\t\t\t.WrClock(wrclock),\n\t\t\t.WrClken(wrclocken),\n\t\t\t.WrAddress(wraddress),\n\t\t\t.WrEn(wren),\n\t\t\t.Data(data)\n\t\t);\n\n\t\tendmodule\n`endif `ifdef VENDOR_XILINX\n\tmodule xilinx_ram_dp (\n\t\tADDRA,\n\t\tCLKA,\n\t\tADDRB,\n\t\tCLKB,\n\t\tDIA,\n\t\tWEA,\n\t\tDIB,\n\t\tWEB,\n\t\tENA,\n\t\tENB,\n\t\tRSTA,\n\t\tRSTB,\n\t\tDOA,\n\t\tDOB)  ;\n\n\tparameter awidth = 7;\n\tparameter dwidth = 8;\n\n\tinput               CLKA;\n\tinput               RSTA;\n\tinput               ENA;\n\tinput [awidth-1:0]  ADDRA;\n\tinput [dwidth-1:0]  DIA;\n\tinput               WEA;\n\toutput [dwidth-1:0] DOA;\n\n\tinput               CLKB;\n\tinput               RSTB;\n\tinput               ENB;\n\tinput [awidth-1:0]  ADDRB;\n\tinput [dwidth-1:0]  DIB;\n\tinput               WEB;\n\toutput [dwidth-1:0] DOB;\n\n\tC_MEM_DP_BLOCK_V1_0 #(\n\t\tawidth,\n\t\tawidth,\n\t\t1,\n\t\t1,\n\t\t\"0\",\n\t\t1 << awidth,\n\t\t1 << awidth,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t\"\",\n\t\t16,\n\t\t0,\n\t\t0,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\tdwidth,\n\t\tdwidth)\n\txilinx_dpram_model (\n\t\t.ADDRA(ADDRA),\n\t\t.CLKA(CLKA),\n\t\t.ADDRB(ADDRB),\n\t\t.CLKB(CLKB),\n\t\t.DIA(DIA),\n\t\t.WEA(WEA),\n\t\t.DIB(DIB),\n\t\t.WEB(WEB),\n\t\t.ENA(ENA),\n\t\t.ENB(ENB),\n\t\t.RSTA(RSTA),\n\t\t.RSTB(RSTB),\n\t\t.DOA(DOA),\n\t\t.DOB(DOB));\n\n\t\tendmodule\n`endif ",
        "module_name": "generic_dpram",
        "module_hash": "faa6eece5d1d63a50eb0319de24703c3",
        "dataset_index": 24601
      },
      "VGACtrl_ed9ad47b": {
        "rtl_code": "module VGACtrl(clk, reset, vga_h_sync, vga_v_sync, inDisplayArea, CounterX, CounterY);\n\ninput clk, reset;\n\noutput vga_h_sync, vga_v_sync;\noutput inDisplayArea;\noutput [9:0] CounterX;\noutput [9:0] CounterY;\n\nreg [9:0] CounterX;\nreg [9:0] CounterY;\nreg vga_HS, vga_VS;\nreg inDisplayArea;\n\nalways @(posedge clk, posedge reset)\n\tbegin\n\t\tif(reset)\n\t\t\tCounterX <= 0;\n\t\telse if(CounterX==10'h320)\n\t\t\tCounterX <= 0;\n\t\telse\n\t\t\tCounterX <= CounterX + 1;\n\tend\n\nalways @(posedge clk, posedge reset)\n\tbegin\n\t\tif(reset)\n\t\t\tCounterY<=0; \n\t\telse if(CounterY==10'h209)    CounterY<=0;\n\t\telse if(CounterX==10'h320)    CounterY <= CounterY + 1;\n\tend\n\t\nalways @(posedge clk)\n\tbegin\n\t\tvga_HS <= (CounterX > 655 && CounterX < 752); \tvga_VS <= (CounterY == 490 || CounterY == 491); \tend \n\n\nalways @(posedge clk, posedge reset)\n   if(reset)\n      inDisplayArea<=0;\n   else\n\t   inDisplayArea <= (CounterX<640) && (CounterY<480);\n\t\nassign vga_h_sync = ~vga_HS;\nassign vga_v_sync = ~vga_VS;\n\nendmodule\n",
        "module_name": "VGACtrl",
        "module_hash": "ed9ad47bd82ec939d31c1618dd015397",
        "dataset_index": 20760
      },
      "sky130_fd_sc_ms__dlxtn_d9066d82": {
        "rtl_code": "module sky130_fd_sc_ms__dlxtn (\n    input D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    input GATE_N,\n    output reg Q\n);\n\nalways @ (GATE_N, VPWR, VGND, VPB, VNB, D)\nbegin\n    if (GATE_N == 1'b0) begin\n        Q <= 1'bx;\n    end else begin\n        if (VPWR == 1'b1 && VGND == 1'b0) begin\n            Q <= D;\n        end else if (VPWR == 1'b0 && VGND == 1'b0) begin\n            Q <= VPB;\n        end else if (VPWR == 1'b1 && VGND == 1'b1) begin\n            Q <= VNB;\n        end else if (VPWR == 1'b0 && VGND == 1'b1) begin\n            Q <= VGND;\n        end\n    end\nend\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__dlxtn",
        "module_hash": "d9066d820c24950c9f1968af3d31ae4f",
        "dataset_index": 21142
      },
      "pram_sram_ctrl_3d356cf6": {
        "rtl_code": "module pram_sram_ctrl(\n\tinput clk,\n\tinput clr,\n\tinput go,\n\tinput halt,\n\toutput reg we,\n\toutput [17:0] sram_addr,\n\toutput [5:0] pattern,\n\toutput reg en\n);\n\nreg[2:0] state;\nparameter\n\tSTART\t\t= 3'b000,\n\tADDROUT\t\t= 3'b001,\n\tTEST1\t\t= 3'b010,\n\tWAIT_AND_GO\t= 3'b011,\n\tREAD\t\t= 3'b100,\n\tTEST2\t\t= 3'b101,\n\tHALT\t\t= 3'b110;\nreg [17:0] addrv;\nreg [5:0] patternv;\n\nassign sram_addr = addrv;\nassign pattern = patternv;\n\nalways @(posedge clk or posedge clr)\nbegin\n\tif (clr == 1)\n\t\tbegin\n\t\t\tstate <= START;\n\t\t\taddrv = 0;\n\t\t\tpatternv = 0;\n\t\t\twe <= 1;\n\t\t\ten <= 0;\n\t\tend\n\telse\n\t\tcase(state)\n\t\t\tSTART:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (go == 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\taddrv = 0;\n\t\t\t\t\t\ten <= 1;\n\t\t\t\t\t\tstate <= ADDROUT;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tstate <= START;\n\t\t\tend\n\t\t\t\n\t\t\tADDROUT:\n\t\t\tbegin\n\t\t\t\tstate <= TEST1;\n\t\t\t\twe <= 1;\n\t\t\tend\n\t\t\t\n\t\t\tTEST1:\n\t\t\tbegin\n\t\t\t\twe <= 0;\n\t\t\t\tif (halt == 1)\n\t\t\t\t\tstate <= HALT;\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\taddrv = addrv + 1;\n\t\t\t\t\t\tif (addrv == 0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tstate <= WAIT_AND_GO;\n\t\t\t\t\t\t\t\ten <= 0;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= ADDROUT;\n\t\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tWAIT_AND_GO:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (go == 1)\n\t\t\t\t\tstate <= WAIT_AND_GO;\n\t\t\t\telse\n\t\t\t\t\tstate <= READ;\n\t\t\tend\n\t\t\t\n\t\t\tREAD:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (go == 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= TEST2;\n\t\t\t\t\t\taddrv = addrv + 1;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tstate <= READ;\n\t\t\tend\n\t\t\t\n\t\t\tTEST2:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (addrv == 0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpatternv = patternv + 1;\n\t\t\t\t\t\tstate <= START;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tstate <= WAIT_AND_GO;\n\t\t\tend\n\t\t\t\n\t\t\tHALT:\n\t\t\tbegin\n\t\t\t\tstate <= HALT;\n\t\t\tend\n\t\t\t\n\t\t\tdefault;\n\t\tendcase\nend\n\nendmodule\n",
        "module_name": "pram_sram_ctrl",
        "module_hash": "3d356cf656f07c86b83fe30dc066c8f9",
        "dataset_index": 22760
      },
      "simple_ram_e575d1d0": {
        "rtl_code": "\n\nmodule simple_ram\n  #(parameter width     = 1,\n    parameter widthad   = 1\n    )\n   (\n    input \t\t   clk,\n    \n    input [widthad-1:0]    wraddress,\n    input \t\t   wren,\n    input [width-1:0] \t   data,\n    \n    input [widthad-1:0]    rdaddress,\n    output reg [width-1:0] q\n    );\n\nreg [width-1:0] mem [(2**widthad)-1:0];\n\nalways @(posedge clk) begin\n    if(wren) mem[wraddress] <= data;\n    \n    q <= mem[rdaddress];\nend\n\nendmodule\n",
        "module_name": "simple_ram",
        "module_hash": "e575d1d045a43fc117a72216942ad595",
        "dataset_index": 22969
      },
      "data_converter_67e16cc5": {
        "rtl_code": "module data_converter (\n  input clk,\n  input reset,\n  input [7:0] in,\n  input select,\n  output [15:0] out\n);\n\n  reg [15:0] out_reg;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      out_reg <= 16'b0;\n    end else begin\n      if (select) begin\n        out_reg <= {8'b0, in};\n      end else begin\n        out_reg <= {in, 8'b0};\n      end\n    end\n  end\n\n  assign out = out_reg;\n\nendmodule\n",
        "module_name": "data_converter",
        "module_hash": "67e16cc52c0b3e912da3501725419a94",
        "dataset_index": 18195
      },
      "mux_b7f802ae": {
        "rtl_code": "module mux (\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    input [1:0] sel,\n    input en,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = en ? in0 : 8'b0;\n        2'b01: out = en ? in1 : 8'b0;\n        2'b10: out = en ? in2 : 8'b0;\n        2'b11: out = en ? in3 : 8'b0;\n    endcase\nend\n\nendmodule",
        "module_name": "mux",
        "module_hash": "b7f802ae890a44d4830c53bf9176051c",
        "dataset_index": 1778
      },
      "alu4bit_bf48f099": {
        "rtl_code": "\nmodule alu4bit(\n  input [3:0] A, B,\n  input CIN, BINV,\n  input [1:0] OP,\n  output reg COUT,\n  output reg [3:0] Y\n);\n\n  reg [3:0] B_inv;\n  always @(*)\n    B_inv = BINV ? ~B : B;\n  \n  always @(*) begin\n    case(OP)\n      2'b00: begin // Addition\n        {COUT, Y} = A + B_inv + CIN;\n      end\n      2'b01: begin // Subtraction\n        {COUT, Y} = A - B_inv - ~CIN;\n      end\n      2'b10: begin // Logical AND\n        Y = A & B_inv;\n        COUT = 1'b0;\n      end\n      2'b11: begin // Logical OR\n        Y = A | B_inv;\n        COUT = 1'b0;\n      end\n    endcase\n  end\nendmodule",
        "module_name": "alu4bit",
        "module_hash": "bf48f0994611e1c467dd526ecea5f81e",
        "dataset_index": 19590
      },
      "wb_readback_mux_16LE_db43c249": {
        "rtl_code": "module wb_readback_mux_16LE\n  (input wb_clk_i,\n   input wb_rst_i,\n   input wb_stb_i,\n   input [15:0] wb_adr_i,\n   output [15:0] wb_dat_o,\n   output reg wb_ack_o,\n\n   input [31:0] word00,\n   input [31:0] word01,\n   input [31:0] word02,\n   input [31:0] word03,\n   input [31:0] word04,\n   input [31:0] word05,\n   input [31:0] word06,\n   input [31:0] word07,\n   input [31:0] word08,\n   input [31:0] word09,\n   input [31:0] word10,\n   input [31:0] word11,\n   input [31:0] word12,\n   input [31:0] word13,\n   input [31:0] word14,\n   input [31:0] word15\n   );\n\n   wire ack_next = wb_stb_i & ~wb_ack_o;\n\n   always @(posedge wb_clk_i)\n     if(wb_rst_i)\n       wb_ack_o <= 0;\n     else\n       wb_ack_o <= ack_next;\n\n   reg [31:0] data;\n   assign wb_dat_o = data[15:0];\n\n   always @(posedge wb_clk_i)\n    if (wb_adr_i[1] & ack_next) begin data[15:0] <= data[31:16];\n    end\n    else if (~wb_adr_i[1] & ack_next) begin case(wb_adr_i[5:2])\n       0 : data <= word00;\n       1 : data <= word01;\n       2 : data <= word02;\n       3 : data <= word03;\n       4 : data <= word04;\n       5 : data <= word05;\n       6 : data <= word06;\n       7 : data <= word07;\n       8 : data <= word08;\n       9 : data <= word09;\n       10: data <= word10;\n       11: data <= word11;\n       12: data <= word12;\n       13: data <= word13;\n       14: data <= word14;\n       15: data <= word15;\n     endcase end\n\nendmodule ",
        "module_name": "wb_readback_mux_16LE",
        "module_hash": "db43c24939d9c646dd9cc1dea0988037",
        "dataset_index": 24502
      },
      "pcie3_7x_0_qpll_reset #_b497bccd": {
        "rtl_code": "\n\n\n\nmodule pcie3_7x_0_qpll_reset #\n(\n\n    parameter PCIE_PLL_SEL       = \"CPLL\",                  parameter PCIE_POWER_SAVING  = \"TRUE\",                  parameter PCIE_LANE          = 1,                       parameter BYPASS_COARSE_OVRD = 1                        )\n\n(\n\n    input                           QRST_CLK,\n    input                           QRST_RST_N,\n    input                           QRST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     QRST_CPLLLOCK,\n    input       [(PCIE_LANE-1)>>2:0]QRST_DRP_DONE,\n    input       [(PCIE_LANE-1)>>2:0]QRST_QPLLLOCK,\n    input       [ 1:0]              QRST_RATE,\n    input       [PCIE_LANE-1:0]     QRST_QPLLRESET_IN,\n    input       [PCIE_LANE-1:0]     QRST_QPLLPD_IN,\n    \n    output                          QRST_OVRD,\n    output                          QRST_DRP_START,\n    output                          QRST_QPLLRESET_OUT,\n    output                          QRST_QPLLPD_OUT,\n    output                          QRST_IDLE,\n    output      [11:0]              QRST_FSM\n\n);\n\n        reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     cplllock_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg1;\n    reg         [ 1:0]              rate_reg1;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg1;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg1;\n\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     cplllock_reg2;  \n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg2;\n    reg         [ 1:0]              rate_reg2;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg2;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg2;\n    \n    reg                             ovrd              =  1'd0;\n    reg                             qpllreset         =  1'd1;\n    reg                             qpllpd            =  1'd0;\n    reg         [11:0]              fsm               = 12'd2;                 \n   \n    localparam                      FSM_IDLE          = 12'b000000000001; \n    localparam                      FSM_WAIT_LOCK     = 12'b000000000010;\n    localparam                      FSM_MMCM_LOCK     = 12'b000000000100;   \n    localparam                      FSM_DRP_START_NOM = 12'b000000001000;\n    localparam                      FSM_DRP_DONE_NOM  = 12'b000000010000;\n    localparam                      FSM_QPLLLOCK      = 12'b000000100000;\n    localparam                      FSM_DRP_START_OPT = 12'b000001000000;                            \n    localparam                      FSM_DRP_DONE_OPT  = 12'b000010000000;\n    localparam                      FSM_QPLL_RESET    = 12'b000100000000;                                                         \n    localparam                      FSM_QPLLLOCK2     = 12'b001000000000;\n    localparam                      FSM_QPLL_PDRESET  = 12'b010000000000;\n    localparam                      FSM_QPLL_PD       = 12'b100000000000;                                         \n \n \n    \nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin    \n        mmcm_lock_reg1    <=  1'd0;\n        cplllock_reg1     <= {PCIE_LANE{1'd1}}; \n        drp_done_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};     \n        qplllock_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg1         <=  2'd0; \n        qpllreset_in_reg1 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg1    <= {PCIE_LANE{1'd0}}; \n        mmcm_lock_reg2    <=  1'd0;\n        cplllock_reg2     <= {PCIE_LANE{1'd1}};\n        drp_done_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        qplllock_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg2         <=  2'd0;\n        qpllreset_in_reg2 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg2    <= {PCIE_LANE{1'd0}};  \n        end\n    else\n        begin  \n        mmcm_lock_reg1    <= QRST_MMCM_LOCK;   \n        cplllock_reg1     <= QRST_CPLLLOCK; \n        drp_done_reg1     <= QRST_DRP_DONE; \n        qplllock_reg1     <= QRST_QPLLLOCK;\n        rate_reg1         <= QRST_RATE; \n        qpllreset_in_reg1 <= QRST_QPLLRESET_IN;\n        qpllpd_in_reg1    <= QRST_QPLLPD_IN;\n        mmcm_lock_reg2    <= mmcm_lock_reg1;\n        cplllock_reg2     <= cplllock_reg1;\n        drp_done_reg2     <= drp_done_reg1; \n        qplllock_reg2     <= qplllock_reg1;\n        rate_reg2         <= rate_reg1;\n        qpllreset_in_reg2 <= qpllreset_in_reg1;\n        qpllpd_in_reg2    <= qpllpd_in_reg1;\n        end\n        \nend    \n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        fsm       <= FSM_WAIT_LOCK;\n        ovrd      <= 1'd0;\n        qpllreset <= 1'd1;\n        qpllpd    <= 1'd0;\n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (!QRST_RST_N)\n                begin\n                fsm       <= FSM_WAIT_LOCK;\n                ovrd      <= 1'd0;\n                qpllreset <= 1'd1;\n                qpllpd    <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                ovrd      <= ovrd;\n                qpllreset <= &qpllreset_in_reg2;\n                qpllpd    <= &qpllpd_in_reg2;\n                end\n            end  \n            \n        FSM_WAIT_LOCK :\n        \n            begin\n            fsm       <= ((&(~cplllock_reg2)) && (&(~qplllock_reg2)) ? FSM_MMCM_LOCK : FSM_WAIT_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_MMCM_LOCK :\n        \n            begin\n            fsm       <= ((mmcm_lock_reg2 && (&cplllock_reg2)) ? FSM_DRP_START_NOM : FSM_MMCM_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_DRP_START_NOM:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_NOM : FSM_DRP_START_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_NOM :\n        \n            begin\n            fsm       <= (&drp_done_reg2 ? FSM_QPLLLOCK : FSM_DRP_DONE_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end \n            \n        FSM_QPLLLOCK :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? ((BYPASS_COARSE_OVRD == 1) ? FSM_QPLL_PDRESET : FSM_DRP_START_OPT) : FSM_QPLLLOCK);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_DRP_START_OPT:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_OPT : FSM_DRP_START_OPT);\n            ovrd      <= 1'd1;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_OPT :\n        \n            begin\n            if (&drp_done_reg2)\n                begin\n                fsm       <= ((PCIE_PLL_SEL == \"QPLL\") ? FSM_QPLL_RESET : FSM_QPLL_PDRESET);\n                ovrd      <= ovrd;\n                qpllreset <= (PCIE_PLL_SEL == \"QPLL\");\n                qpllpd    <= qpllpd;\n                end\n            else\n                begin\n                fsm       <= FSM_DRP_DONE_OPT;\n                ovrd      <= ovrd;\n                qpllreset <= qpllreset;\n                qpllpd    <= qpllpd;\n                end\n            end \n            \n        FSM_QPLL_RESET :\n            \n            begin\n            fsm       <= (&(~qplllock_reg2) ? FSM_QPLLLOCK2 : FSM_QPLL_RESET);  \n            ovrd      <= ovrd;\n            qpllreset <= 1'd1;\n            qpllpd    <= 1'd0;\n            end     \n            \n        FSM_QPLLLOCK2 :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK2);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n            \n        FSM_QPLL_PDRESET :\n        \n            begin\n            fsm       <= FSM_QPLL_PD;\n            ovrd      <= ovrd;\n            qpllreset <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_QPLL_PD :\n        \n            begin\n            fsm       <= FSM_IDLE;\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            end \n                \n        default :\n        \n            begin\n            fsm       <= FSM_WAIT_LOCK;\n            ovrd      <= 1'd0;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        endcase\n        \n        end\n        \nend\n\n\n\nassign QRST_OVRD          = ovrd;\nassign QRST_DRP_START     = (fsm == FSM_DRP_START_NOM) || (fsm == FSM_DRP_START_OPT); \nassign QRST_QPLLRESET_OUT = qpllreset;\nassign QRST_QPLLPD_OUT    = ((PCIE_POWER_SAVING == \"FALSE\") ? 1'd0 : qpllpd);  \nassign QRST_IDLE          = (fsm == FSM_IDLE);\nassign QRST_FSM           = fsm;                   \n\n\n\nendmodule\n",
        "module_name": "pcie3_7x_0_qpll_reset #",
        "module_hash": "b497bccddede2e74f155933d7901a3fd",
        "dataset_index": 2414
      },
      "settings_bus_16LE_276f80af": {
        "rtl_code": "module settings_bus_16LE\n  #(parameter AWIDTH=16, RWIDTH=8)\n    (input wb_clk, \n     input wb_rst, \n     input [AWIDTH-1:0] wb_adr_i,\n     input [15:0] wb_dat_i,\n     input wb_stb_i,\n     input wb_we_i,\n     output reg wb_ack_o,\n     output strobe,\n     output reg [7:0] addr,\n     output reg [31:0] data);\n\n   reg \t\t       stb_int;\n   \n   always @(posedge wb_clk)\n     if(wb_rst)\n       begin\n\t  stb_int <= 1'b0;\n\t  addr <= 8'd0;\n\t  data <= 32'd0;\n       end\n     else if(wb_we_i & wb_stb_i)\n       begin\n\t  addr <= wb_adr_i[RWIDTH+1:2];  if(wb_adr_i[1])\n\t    begin\n\t       stb_int <= 1'b1;     data[31:16] <= wb_dat_i;\n\t    end\n\t  else\n\t    begin\n\t       stb_int <= 1'b0;     data[15:0] <= wb_dat_i;\n\t    end\n       end\n     else\n       stb_int <= 1'b0;\n\n   always @(posedge wb_clk)\n     if(wb_rst)\n       wb_ack_o <= 0;\n     else\n       wb_ack_o <= wb_stb_i & ~wb_ack_o;\n\n   assign strobe = stb_int & wb_ack_o;\n          \nendmodule ",
        "module_name": "settings_bus_16LE",
        "module_hash": "276f80af153634e0b2917b4d3583390c",
        "dataset_index": 24787
      },
      "fifo_d2a2ba1f": {
        "rtl_code": "module fifo\n   #(\n  \tparameter adr_width = 10,\n\tparameter dat_width = 8\n   )\n   (\n    input  clk_div, reset,\n    input  wr,rd,\n    input  [dat_width-1:0] data_in,\n    output [dat_width-1:0] data_out,\n    output empty, \n    output full\n);\n\n\n   parameter depth = (1 << adr_width);\n\n   reg [dat_width-1:0] array_reg [depth-1:0];reg [adr_width-1:0] w_ptr_reg, w_ptr_next;\n   reg [adr_width-1:0] r_ptr_reg, r_ptr_next;\n   reg full_reg, empty_reg, full_next, empty_next;\n   wire wr_en;\n  \n   \n\n   assign data_out = array_reg[r_ptr_reg];\n   assign wr_en = wr & ~full_reg;\n\n   assign full = full_reg;\n   assign empty = empty_reg;\n\n   always @(posedge clk_div) begin\n      if (wr_en)\n         array_reg[w_ptr_reg] <= data_in;\n   end\n\n   always @(posedge clk_div, posedge reset) begin\n      if (reset)\n         begin\n            w_ptr_reg <= 0;\n            r_ptr_reg <= 0;\n            full_reg <= 1'b0;\n            empty_reg <= 1'b1;\n         end\n      else\n         begin\n            w_ptr_reg <= w_ptr_next;\n            r_ptr_reg <= r_ptr_next;\n            full_reg <= full_next;\n            empty_reg <= empty_next;\n         end\n   end\n\n\n   \n   always @(*)\n   begin\n      if (reset) begin\n\tw_ptr_next =  0;\n        r_ptr_next =  0;       \n      end else begin\n\t      full_next = full_reg;\n\t      empty_next = empty_reg;\n\t      case ({wr, rd})\n\t\t 2'b01: if (~empty_reg) begin\n\t\t          r_ptr_next = r_ptr_reg + 1;\n\t\t          full_next = 1'b0;\n\t\t          if (r_ptr_next==w_ptr_reg)\n\t\t             empty_next = 1'b1;\n\t\t       end\n\t\t 2'b10: if (~full_reg) begin\n\t\t          w_ptr_next = w_ptr_reg + 1;\n\t\t          empty_next = 1'b0;\n\t\t          if (w_ptr_next==r_ptr_reg)\n\t\t             full_next = 1'b1;\n\t\t       end\n\t\t 2'b11: begin\n\t\t       w_ptr_next =  w_ptr_reg + 1;\n\t\t       r_ptr_next = r_ptr_reg + 1;\n\t\t    end\n\t      endcase\n\tend\n   end\n\n\n  \nendmodule\n",
        "module_name": "fifo",
        "module_hash": "d2a2ba1f63205b43172f14738f634af1",
        "dataset_index": 16307
      },
      "addfxp_e1ad70ff": {
        "rtl_code": "module addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule",
        "module_name": "addfxp",
        "module_hash": "e1ad70ff577c172dcfb9cb55c008ea1b",
        "dataset_index": 21385
      },
      "acl_vector_to_stream_converter_single_65f78187": {
        "rtl_code": "module acl_vector_to_stream_converter_single(\n\t\t\tclock, clock2x, resetn, start,\n\t\t\ta1, a2, dataa,\n\t\t\tvalid_in, valid_out, stall_in, stall_out);\n\tparameter WIDTH = 32;\n\t\n  input clock, clock2x, resetn, valid_in, stall_in, start;\n\tinput [WIDTH-1:0] a1;\n  input [WIDTH-1:0] a2;\n  output [WIDTH-1:0] dataa;\n\toutput valid_out;\n\toutput stall_out;\n\n  reg [WIDTH-1:0] a1_sr ;\n  reg [WIDTH-1:0] a2_sr ;\n  reg sr_in_valid ;\n  wire stall_sr;\n  assign stall_out = sr_in_valid;\n  reg start_reg ;\n  \n  always@(posedge clock or negedge resetn)\n  begin\n    if (~resetn)\n    begin\n      sr_in_valid <= 1'b0;\n      start_reg <= 1'b0;\n      a1_sr <= {WIDTH{1'bx}};\n      a2_sr <= {WIDTH{1'bx}};\n    end\n    else\n    begin\n      start_reg <= start;\n      if (~stall_sr | start)\n        sr_in_valid <= 1'b0;\n      else if (~sr_in_valid)\n        sr_in_valid <= valid_in;\n\n      if (~sr_in_valid)\n      begin\n        a1_sr <= a1;\n        a2_sr <= a2;\n      end\n    end\n  end\n  \n  reg sel2x, sel_ref ;\n\tinitial\n\tbegin\n\t\tsel2x = 1'b0;\n\t\tsel_ref = 1'b0;\n\tend\n\n  always@(posedge clock2x)\n  begin\n    sel2x <= ~sel2x;\t\n  end\n  \n\treg [WIDTH-1:0] a1_reg ;\n  reg [WIDTH-1:0] a2_reg ;\n  reg valid_reg ;\n  wire stall_reg;\n  \n  assign stall_sr = valid_reg & stall_reg;\n  \n  always@(posedge clock or negedge resetn)\n  begin\n    if (~resetn)\n    begin\n      sel_ref <= 1'b0;\n      valid_reg <= 1'b0;\n      a1_reg <= {WIDTH{1'bx}};\n      a2_reg <= {WIDTH{1'bx}};\n    end\n    else \n    begin\n      sel_ref <= sel2x;\n      if (start)\n        valid_reg <= 1'b0;\n      else if (~valid_reg | ~stall_reg)\n        valid_reg <= valid_in | sr_in_valid;\n        \n      if (~valid_reg | ~stall_reg)\n      begin\n        a1_reg <= sr_in_valid ? a1_sr : a1;\n        a2_reg <= sr_in_valid ? a2_sr : a2;\n      end\n    end\n  end\n  \n  reg [WIDTH-1:0] shift_reg_a1 ;\n  reg [WIDTH-1:0] shift_reg_a2 ;\n  reg read_data ;\n  reg valid_a1, valid_a2 ;\n  reg start_reg_2x ;\n  wire stall_shift;\n  assign stall_reg = ~read_data;\n  wire w;\n  assign w = (sel_ref == sel2x);\n  always@(posedge clock2x or negedge resetn)  \n  begin\n    if (~resetn)\n    begin\n      start_reg_2x <= 1'b0;\n      valid_a1 <= 1'b0;\n      valid_a2 <= 1'b0;\n      read_data <= 1'b0;\n      shift_reg_a1 <= {WIDTH{1'bx}};\n      shift_reg_a2 <= {WIDTH{1'bx}};\n    end\n    else\n    begin\n     start_reg_2x <= start_reg;\n\t   if (~w)\n\t\t begin\n\t\t   if (~valid_a1)\n       begin\n         valid_a1 <= valid_reg & ~start_reg_2x;\n         valid_a2 <= valid_reg & ~start_reg_2x;\n         shift_reg_a1 <= a1_reg;\n         shift_reg_a2 <= a2_reg;\n\t\t\t   read_data <= valid_reg;\n       end\n\t\t   else if (~stall_shift)\n\t\t   begin\n\t\t     if (~valid_a2)\n         begin\n           valid_a1 <= valid_reg & ~start_reg_2x;\n           valid_a2 <= valid_reg & ~start_reg_2x;\n           shift_reg_a1 <= a1_reg;\n           shift_reg_a2 <= a2_reg;\n\t\t\t\t   read_data <= valid_reg;\n         end\n         else\n         begin\n\t\t\t     valid_a1 <= valid_a2 & ~start_reg_2x;\n           valid_a2 <= 1'b0;\n           shift_reg_a1 <= shift_reg_a2;\n           shift_reg_a2 <= {WIDTH{1'b0}};\n           read_data <= 1'b0;\n         end\t\t\t \n\t\t   end\n       else\n         read_data <= 1'b0;\n\t\t end\n\t\t else\n\t\t begin\n\t\t   if (~stall_shift)\n       begin\n\t\t     valid_a1 <= valid_a2 & ~start_reg_2x;\n         valid_a2 <= 1'b0;\n         shift_reg_a1 <= shift_reg_a2;\n         shift_reg_a2 <= {WIDTH{1'b0}};\n       end\n       else\n       begin\n         valid_a1 <= valid_a1 & ~start_reg_2x;\n         valid_a2 <= valid_a2 & ~start_reg_2x;\n       end\n     end\n    end\n  end\n  \n  assign dataa = shift_reg_a1;\n  assign stall_shift = stall_in;\n  assign valid_out = valid_a1;\nendmodule\n",
        "module_name": "acl_vector_to_stream_converter_single",
        "module_hash": "65f78187b9a89008ce423d1cf02df9f2",
        "dataset_index": 25755
      },
      "anteconmutador_9e571a59": {
        "rtl_code": "module anteconmutador (\n    input clk,\n    input [7:0] count,\n    input calculate,\n    output reg [3:0] centenas,\n    output reg [3:0] decenas,\n    output reg [3:0] unidades,\n    output reg C,\n    output reg De,\n    output reg U\n);\n\n    reg [7:0] digitT;\n    reg i;\n\n    always @(posedge clk) begin\n        if (calculate) begin\n            if (i) begin\n                digitT = count;\n                i = 0;\n            end\n            if (digitT > 7'b1100011) begin\n                digitT = digitT - 7'b1100100;\n                centenas = centenas + 1;\n            end\n            else begin\n                if (digitT > 7'b0001001) begin\n                    digitT = digitT - 7'b0001010;\n                    decenas = decenas + 1;\n                end\n                else begin\n                    unidades = {digitT[3:0]};\n                    if (centenas >= 1) begin\n                        C = 1;\n                    end\n                    if (decenas >= 1) begin\n                        De = 1;\n                    end\n                    if (unidades >= 1) begin\n                        U = 1;\n                    end\n                end\n            end\n        end\n        else begin\n            digitT = 0;\n            C = 0;\n            De = 0;\n            U = 0;\n            i = 1;\n            centenas = 0;\n            decenas = 0;\n            unidades = 0;\n        end\n    end\nendmodule",
        "module_name": "anteconmutador",
        "module_hash": "9e571a594a4945096f80d1b38e4ba7fc",
        "dataset_index": 19752
      },
      "bt_receiver #_c84fe60c": {
        "rtl_code": "module bt_receiver #(\n  parameter n = 8,\n  parameter m = 8\n)(\n  input [n-1:0] rx_in,\n  input clk,\n  input reset,\n  output reg rx_en,\n  output reg [m-1:0] data_out\n);\n\n  parameter baud_rate = 9600;\n  integer counter;\n  reg [n-1:0] data_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      counter <= 0;\n      rx_en <= 0;\n      data_out <= 0;\n    end else begin\n      if (counter == 0) begin\n        counter <= (50_000_000 / baud_rate) - 1;\n        data_reg <= rx_in;\n        rx_en <= 1;\n        data_out <= data_reg;\n        data_reg <= data_reg >> 1;\n      end else begin\n        counter <= counter - 1;\n      end\n    end\n  end\nendmodule",
        "module_name": "bt_receiver #",
        "module_hash": "c84fe60cd137a4f8f4e3bae6b19e7f13",
        "dataset_index": 33
      },
      "calculator_4e19dcea": {
        "rtl_code": "module calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n\nalways @ (posedge clk) begin\n    if (rst == 1) begin\n        result <= 0;\n    end\n    else begin\n        case (op)\n            2'b00: result <= a + b;\n            2'b01: result <= a - b;\n            2'b10: result <= a * b;\n            2'b11: result <= a / b;\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "4e19dcea9896936f94b0a8c6c3cbbafb",
        "dataset_index": 3326
      },
      "jt51_sh #_ad5177dd": {
        "rtl_code": "\n\n\nmodule jt51_sh #(parameter width=5, stages=32, rstval=1'b0 ) (\n    input                           rst,\n    input                           clk,\n    input                           cen,\n    input       [width-1:0]         din,\n    output      [width-1:0]         drop\n);\n\nreg [stages-1:0] bits[width-1:0];\n\ngenvar i;\ngenerate\n    for (i=0; i < width; i=i+1) begin: bit_shifter\n        always @(posedge clk, posedge rst) begin\n            if(rst)\n                bits[i] <= {stages{rstval}};\n            else if(cen)\n                bits[i] <= {bits[i][stages-2:0], din[i]};\n        end\n        assign drop[i] = bits[i][stages-1];\n    end\nendgenerate\n\nendmodule\n",
        "module_name": "jt51_sh #",
        "module_hash": "ad5177dd0590f501f8b322727352f848",
        "dataset_index": 21607
      },
      "MIB #_b8994511": {
        "rtl_code": "module MIB #(\n    parameter data_width = 32, // width of the data bus (in bits)\n    parameter addr_width = 8 // width of the address bus (in bits)\n)(\n  input clk,\n  input rst,\n  input [addr_width-1:0] addr,\n  input wr_en,\n  input [data_width-1:0] wr_data,\n  input rd_en,\n  output reg [data_width-1:0] rd_data\n);\n\n\nreg [data_width-1:0] mem[0:2**addr_width-1]; // internal memory array\n\nreg [1:0] state; // state variable for FSM\nparameter IDLE = 2'b00;\nparameter READ = 2'b01;\nparameter WRITE = 2'b10;\n\nreg [addr_width-1:0] burst_addr; // address for burst operations\nreg [1:0] burst_count; // counter for burst operations\nparameter BURST_IDLE = 2'b00;\nparameter BURST_READ = 2'b01;\nparameter BURST_WRITE = 2'b10;\n\nalways @( posedge clk ) begin\n    if (rst) begin\n        state <= IDLE;\n        burst_count <= 0;\n        rd_data <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (rd_en) begin\n                    state <= READ;\n                    rd_data <= mem[addr];\n                end else if (wr_en) begin\n                    state <= WRITE;\n                    mem[addr] <= wr_data;\n                end\n            end\n            READ: begin\n                if (rd_en) begin\n                    rd_data <= mem[addr];\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            WRITE: begin\n                if (wr_en) begin\n                    mem[addr] <= wr_data;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n        if (rd_en && (burst_count != 0)) begin\n            burst_count <= burst_count - 1;\n            burst_addr <= burst_addr + 1;\n            rd_data <= mem[burst_addr];\n        end else if (wr_en && (burst_count != 0)) begin\n            burst_count <= burst_count - 1;\n            burst_addr <= burst_addr + 1;\n            mem[burst_addr] <= wr_data;\n        end else if (rd_en && (burst_count == 0)) begin\n            burst_count <= addr_width/2 - 1;\n            burst_addr <= addr + 1;\n            rd_data <= mem[addr];\n            state <= BURST_READ;\n        end else if (wr_en && (burst_count == 0)) begin\n            burst_count <= addr_width/2 - 1;\n            burst_addr <= addr + 1;\n            mem[addr] <= wr_data;\n            state <= BURST_WRITE;\n        end else if (state == BURST_READ) begin\n            if (rd_en) begin\n                burst_count <= burst_count - 1;\n                burst_addr <= burst_addr + 1;\n                rd_data <= mem[burst_addr];\n            end else begin\n                state <= IDLE;\n            end\n        end else if (state == BURST_WRITE) begin\n            if (wr_en) begin\n                burst_count <= burst_count - 1;\n                burst_addr <= burst_addr + 1;\n                mem[burst_addr] <= wr_data;\n            end else begin\n                state <= IDLE;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "MIB #",
        "module_hash": "b8994511e92836b076ff39eb4754e2ef",
        "dataset_index": 683
      },
      "SNPS_CLOCK_GATE_HIGH_d_ff_en_W32_0_11_94e66ff0": {
        "rtl_code": "\nmodule SNPS_CLOCK_GATE_HIGH_d_ff_en_W32_0_11 ( CLK, EN, TE, ENCLK );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg ENCLK_reg;\n\n  always @ (posedge CLK) begin\n    if (EN && TE) begin\n      ENCLK_reg <= 1;\n    end else begin\n      ENCLK_reg <= 0;\n    end\n  end\n\n  assign ENCLK = ENCLK_reg;\n\nendmodule",
        "module_name": "SNPS_CLOCK_GATE_HIGH_d_ff_en_W32_0_11",
        "module_hash": "94e66ff0117f619dc60e36b6a12f658f",
        "dataset_index": 506
      },
      "top__a3337de6": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [7:0] toggled,\n    output [7:0] count,\n    output [7:0] final_output\n);\n\nreg [7:0] toggled_reg;\nreg [7:0] count_reg;\nreg [7:0] final_output_reg;\n\nwire [7:0] toggled_wire;\nwire [7:0] count_wire;\n\n// Toggling circuit\nreg [7:0] dff_in;\nreg [7:0] dff_out;\nwire [7:0] xor_out;\n\nalways @(posedge clk) begin\n    dff_in <= in;\n    dff_out <= dff_in ^ toggled_reg;\nend\n\nassign toggled_wire = xor_out;\nassign toggled = toggled_reg;\n\n// Population count circuit\nwire [3:0] count_0;\nwire [3:0] count_1;\nwire [3:0] count_2;\nwire [3:0] count_3;\n\nassign count_0 = in[0] + in[4];\nassign count_1 = in[1] + in[5];\nassign count_2 = in[2] + in[6];\nassign count_3 = in[3] + in[7];\n\nwire [3:0] count_01;\nwire [3:0] count_23;\n\nassign count_01 = count_0 + count_1;\nassign count_23 = count_2 + count_3;\n\nassign count_wire = count_01 + count_23;\nassign count = count_reg;\n\n// Final functional module\nalways @(posedge clk) begin\n    toggled_reg <= dff_out;\n    count_reg <= count_wire;\n    final_output_reg <= toggled_reg + count_reg;\nend\n\nassign final_output = final_output_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "a3337de6bb4fd15e5e2860cf88aa15e3",
        "dataset_index": 2372
      },
      "d_ff_en_7aaef812": {
        "rtl_code": "module d_ff_en(clk, en, te, d, q);\n    input clk, en, te, d;\n    output q;\n    reg q;\n\n    always @(posedge clk) begin\n        if (en && te) begin\n            q <= d;\n        end\n    end\nendmodule",
        "module_name": "d_ff_en",
        "module_hash": "7aaef8128685c6abb8b52fed7a0660c3",
        "dataset_index": 16171
      },
      "dpMem_dc_51bcf767": {
        "rtl_code": "module dpMem_dc(  addrIn, addrOut, wrClk, rdClk, dataIn, writeEn, readEn, dataOut);\n  parameter FIFO_WIDTH = 8;\n  parameter FIFO_DEPTH = 64; \n  parameter ADDR_WIDTH = 6;   \n  \ninput wrClk;\ninput rdClk;\ninput [FIFO_WIDTH-1:0] dataIn;\noutput [FIFO_WIDTH-1:0] dataOut;\ninput writeEn;\ninput readEn;\ninput [ADDR_WIDTH-1:0] addrIn;\ninput [ADDR_WIDTH-1:0] addrOut;\n\nwire wrClk;\nwire rdClk;\nwire [FIFO_WIDTH-1:0] dataIn;\nreg [FIFO_WIDTH-1:0] dataOut;\nwire writeEn;\nwire readEn;\nwire [ADDR_WIDTH-1:0] addrIn;\nwire [ADDR_WIDTH-1:0] addrOut;\n\nreg [FIFO_WIDTH-1:0] buffer [0:FIFO_DEPTH-1];\n\nalways @(posedge rdClk) begin\n  dataOut <= buffer[addrOut];\nend\n\nalways @(posedge wrClk) begin\n  if (writeEn == 1'b1)\n    buffer[addrIn] <= dataIn;\nend                  \n\n\nendmodule\n",
        "module_name": "dpMem_dc",
        "module_hash": "51bcf767702fc26d9bc46f710ba507ad",
        "dataset_index": 22080
      },
      "UART_TX_f7534648": {
        "rtl_code": "\nmodule UART_TX(\n    input [7:0] RxD_par, input RxD_start,\n\t input RTS, input sys_clk,\n\t input BaudTick,\n    output reg TxD_ser\n    );\n\n\n\treg [3:0] state=0;\n\treg [7:0] RxD_buff=0;\n\t\n\talways @(posedge sys_clk)\n\tbegin\n\t\tif (RxD_start & state<2) begin\n\t\t\tRxD_buff <= RxD_par; end else if (state[3] & BaudTick) begin\n\t\t\tRxD_buff <= (RxD_buff >> 1); end\n\t\n\t\tcase(state)\n\t\t\t4'b0000: if(RxD_start & RTS) state <= 4'b0010;4'b0010: if(BaudTick) state <= 4'b0011; 4'b0011: if(BaudTick) state <= 4'b1000; 4'b1000: if(BaudTick) state <= 4'b1001; 4'b1001: if(BaudTick) state <= 4'b1010; 4'b1010: if(BaudTick) state <= 4'b1011; 4'b1011: if(BaudTick) state <= 4'b1100; 4'b1100: if(BaudTick) state <= 4'b1101; 4'b1101: if(BaudTick) state <= 4'b1110; 4'b1110: if(BaudTick) state <= 4'b1111; 4'b1111: if(BaudTick) state <= 4'b0001; 4'b0001: if(BaudTick) begin if(RxD_start & RTS) begin\n\t\t\t\t\t\t\t\tstate <= 4'b0011; end else begin\n\t\t\t\t\t\t\t\tstate <= 4'b0000; end\n\t\t\t\t\t\tend\t\t\t\t\t\t\n\t\t\tdefault: if(BaudTick) state <= 4'b0000; \n\t\tendcase\n\t\t\t\n\tend\n\t\n\talways @(posedge sys_clk)\n\tbegin\n\t\tTxD_ser <= (state < 3) | (state[3] & RxD_buff[0]); end\n\nendmodule\n",
        "module_name": "UART_TX",
        "module_hash": "f7534648345c90d12fdfdd472749a2a0",
        "dataset_index": 8593
      },
      "johnson_code_d7144465": {
        "rtl_code": "module johnson_code (\n    input clk,\n    output reg [4:0] johnson_out\n);\n\nreg [4:0] pipeline1;\nreg [4:0] pipeline2;\nreg [4:0] pipeline3;\nreg [4:0] pipeline4;\n\nalways @(posedge clk) begin\n    pipeline1 <= johnson_out;\n    pipeline2 <= pipeline1;\n    pipeline3 <= pipeline2;\n    pipeline4 <= pipeline3;\n    johnson_out <= {pipeline4[3:0], ~pipeline4[4]};\nend\n\nendmodule",
        "module_name": "johnson_code",
        "module_hash": "d71444652e2765a44e52e236d924d0c7",
        "dataset_index": 9057
      },
      "mig_7series_v4_0_poc_meta #_ab97a92b": {
        "rtl_code": "\n\nmodule mig_7series_v4_0_poc_meta #\n  (parameter SCANFROMRIGHT              = 0,\n   parameter TCQ                        = 100,\n   parameter TAPCNTRWIDTH               = 7,\n   parameter TAPSPERKCLK                = 112)\n  (\n  run_ends, mmcm_edge_detect_done, edge_center, left, right,\n  window_center, diff, poc_backup, mmcm_lbclk_edge_aligned,\n  rst, clk, mmcm_edge_detect_rdy, run_too_small, run, run_end,\n  run_polarity, rise_lead_right, rise_trail_left, rise_lead_center,\n  rise_trail_center, rise_trail_right, rise_lead_left, ninety_offsets,\n  use_noise_window, ktap_at_right_edge, ktap_at_left_edge\n  );\n\n  localparam NINETY = TAPSPERKCLK/4;\n  \n  function [TAPCNTRWIDTH-1:0] offset (input [TAPCNTRWIDTH-1:0] a, \n                                      input [1:0] b,\n                                      input integer base);\n    integer offset_ii;\n    begin\n      offset_ii = (a + b * NINETY) < base\n                     ? (a + b * NINETY) \n                     : (a + b * NINETY - base);\n      offset = offset_ii[TAPCNTRWIDTH-1:0];\n    end\n  endfunction function [TAPCNTRWIDTH-1:0] mod_sub (input [TAPCNTRWIDTH-1:0] a, \n                                       input [TAPCNTRWIDTH-1:0] b,\n                                       input integer base); \n    begin\n      mod_sub = (a>=b) ? a-b : a+base-b;\n    end\n  endfunction function [TAPCNTRWIDTH:0] center (input [TAPCNTRWIDTH-1:0] left, \n                                    input [TAPCNTRWIDTH-1:0] diff,\n                                    input integer base);\n    integer center_ii;\n    begin\n      center_ii = ({left, 1'b0} + diff < base * 2)\n                    ? {left, 1'b0} + diff + 32'h0\n\t            : {left, 1'b0} + diff - base * 2;\n      center = center_ii[TAPCNTRWIDTH:0];\n    end\n  endfunction input rst;\n  input clk;\n\n\n  input mmcm_edge_detect_rdy;\n\n  reg [1:0] run_ends_r;\n\n  input run_too_small;\n  reg run_too_small_r1, run_too_small_r2, run_too_small_r3;\n\n  always @ (posedge clk) run_too_small_r1 <= #TCQ run_too_small & (run_ends_r == 'd1);  always @ (posedge clk) run_too_small_r2 <= #TCQ run_too_small_r1;\n  always @ (posedge clk) run_too_small_r3 <= #TCQ run_too_small_r2;\n\n  wire reset_run_ends = rst || ~mmcm_edge_detect_rdy || run_too_small_r3 ;\n\n  input [TAPCNTRWIDTH-1:0] run;\n  \n  input run_end;\n  reg run_end_r, run_end_r1, run_end_r2, run_end_r3;\n  always @(posedge clk) run_end_r <= #TCQ run_end;\n  always @(posedge clk) run_end_r1 <= #TCQ run_end_r;\n  always @(posedge clk) run_end_r2 <= #TCQ run_end_r1;\n  always @(posedge clk) run_end_r3 <= #TCQ run_end_r2;\n\n  input run_polarity;\n  reg run_polarity_held_ns, run_polarity_held_r;\n  always @(posedge clk) run_polarity_held_r <= #TCQ run_polarity_held_ns;\n  always @(*) run_polarity_held_ns = run_end ? run_polarity : run_polarity_held_r;\n  \n  reg [1:0] run_ends_ns;\n  always @(posedge clk) run_ends_r <= #TCQ run_ends_ns;\n  always @(*) begin\n    run_ends_ns = run_ends_r;\n    if (reset_run_ends) run_ends_ns = 2'b0;\n    else case (run_ends_r) \n           2'b00 : run_ends_ns = run_ends_r + {1'b0, run_end_r3 && run_polarity_held_r};\n\t   2'b01, 2'b10 : run_ends_ns = run_ends_r + {1'b0, run_end_r3};\n\t  endcase end output [1:0] run_ends;\n  assign run_ends = run_ends_r;\n\n  reg done_r;\n  wire done_ns = mmcm_edge_detect_rdy && &run_ends_r;\n  always @(posedge clk) done_r <= #TCQ done_ns;\n  output mmcm_edge_detect_done;\n  assign mmcm_edge_detect_done = done_r;  \n\n  input [TAPCNTRWIDTH-1:0] rise_lead_right;\n  input [TAPCNTRWIDTH-1:0] rise_trail_left;\n  input [TAPCNTRWIDTH-1:0] rise_lead_center;\n  input [TAPCNTRWIDTH-1:0] rise_trail_center;\n  input [TAPCNTRWIDTH-1:0] rise_trail_right;\n  input [TAPCNTRWIDTH-1:0] rise_lead_left;\n\n  input [1:0] ninety_offsets;\n  wire [1:0] offsets = SCANFROMRIGHT == 1 ? ninety_offsets : 2'b00 - ninety_offsets;\n\n  wire [TAPCNTRWIDTH-1:0] rise_lead_center_offset_ns = offset(rise_lead_center, offsets, TAPSPERKCLK);\n  wire [TAPCNTRWIDTH-1:0] rise_trail_center_offset_ns = offset(rise_trail_center, offsets, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] rise_lead_center_offset_r, rise_trail_center_offset_r;\n  always @(posedge clk) rise_lead_center_offset_r <= #TCQ rise_lead_center_offset_ns;\n  always @(posedge clk) rise_trail_center_offset_r <= #TCQ rise_trail_center_offset_ns;\n\n  wire [TAPCNTRWIDTH-1:0] edge_diff_ns = mod_sub(rise_trail_center_offset_r, rise_lead_center_offset_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] edge_diff_r;\n  always @(posedge clk) edge_diff_r <= #TCQ edge_diff_ns;\n  \n  wire [TAPCNTRWIDTH:0] edge_center_ns = center(rise_lead_center_offset_r, edge_diff_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH:0] edge_center_r;\n  always @(posedge clk) edge_center_r <= #TCQ edge_center_ns;\n  output [TAPCNTRWIDTH:0] edge_center;\n  assign edge_center = edge_center_r;\n\n  input use_noise_window;\n  output [TAPCNTRWIDTH-1:0] left, right;\n  assign left = use_noise_window ? rise_lead_left : rise_trail_left;\n  assign right = use_noise_window ? rise_trail_right : rise_lead_right;\n\n  wire [TAPCNTRWIDTH-1:0] center_diff_ns = mod_sub(right, left, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] center_diff_r;\n  always @(posedge clk) center_diff_r <= #TCQ center_diff_ns;\n  \n  wire [TAPCNTRWIDTH:0] window_center_ns = center(left, center_diff_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH:0] window_center_r;\n  always @(posedge clk) window_center_r <= #TCQ window_center_ns;\n  output [TAPCNTRWIDTH:0] window_center;\n  assign window_center = window_center_r;\n\n  localparam TAPSPERKCLKX2 = TAPSPERKCLK * 2;\n\n  wire [TAPCNTRWIDTH+1:0] left_center = {1'b0, SCANFROMRIGHT == 1 ? window_center_r : edge_center_r};\n  wire [TAPCNTRWIDTH+1:0] right_center = {1'b0, SCANFROMRIGHT == 1 ? edge_center_r : window_center_r};\n\t\t\t  \n  wire [TAPCNTRWIDTH+1:0] diff_ns = right_center >= left_center\n                                     ? right_center - left_center\n                                     : right_center + TAPSPERKCLKX2[TAPCNTRWIDTH+1:0] - left_center;\n  \n  reg [TAPCNTRWIDTH+1:0] diff_r;\n  always @(posedge clk) diff_r <= #TCQ diff_ns;\n  output [TAPCNTRWIDTH+1:0] diff;\n  assign diff = diff_r;\n\n  wire [TAPCNTRWIDTH+1:0] abs_diff = diff_r > TAPSPERKCLKX2[TAPCNTRWIDTH+1:0]/2\n                                       ? TAPSPERKCLKX2[TAPCNTRWIDTH+1:0] - diff_r\n                                       : diff_r;\n\n  reg [TAPCNTRWIDTH+1:0] prev_ns, prev_r;\n  always @(posedge clk) prev_r <= #TCQ prev_ns;\n  always @(*) prev_ns = done_ns ? diff_r : prev_r;\n\n  input ktap_at_right_edge;\n  input ktap_at_left_edge;\n  \n  wire centering = !(ktap_at_right_edge || ktap_at_left_edge);\n  wire diffs_eq = abs_diff == diff_r;\n  reg diffs_eq_ns, diffs_eq_r;\n  always @(*) diffs_eq_ns = centering && ((done_r && done_ns) ? diffs_eq : diffs_eq_r);\n  always @(posedge clk) diffs_eq_r <= #TCQ diffs_eq_ns;\n\n  reg edge_aligned_r;\n  reg prev_valid_ns, prev_valid_r;\n  always @(posedge clk) prev_valid_r <= #TCQ prev_valid_ns;\n  always @(*) prev_valid_ns = (~rst && ~ktap_at_right_edge && ~ktap_at_left_edge && ~edge_aligned_r) && prev_valid_r | done_ns;\n\n  wire indicate_alignment = ~rst && centering && done_ns;\n  wire edge_aligned_ns = indicate_alignment && (~|diff_r || ~diffs_eq & diffs_eq_r);\n  always @(posedge clk) edge_aligned_r <= #TCQ edge_aligned_ns;\n\n  reg poc_backup_r;\n  wire poc_backup_ns = edge_aligned_ns && abs_diff > prev_r;\n  always @(posedge clk) poc_backup_r <= #TCQ poc_backup_ns;\n  output poc_backup;\n  assign poc_backup = poc_backup_r;\n\n  output mmcm_lbclk_edge_aligned;\n  assign mmcm_lbclk_edge_aligned = edge_aligned_r;\n  \nendmodule ",
        "module_name": "mig_7series_v4_0_poc_meta #",
        "module_hash": "ab97a92b8c7a67440fca8db1a9dbf58e",
        "dataset_index": 25581
      },
      "shift_register #_b9a63447": {
        "rtl_code": "module shift_register #(\n  parameter DATA_WIDTH = 8\n) (\n  input clk,\n  input reset,\n  input shift_in,\n  output reg shift_out\n);\n\n  reg [DATA_WIDTH-1:0] buffer;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      buffer <= 0;\n      shift_out <= 0;\n    end else begin\n      buffer <= {shift_in, buffer[DATA_WIDTH-1:1]};\n      shift_out <= buffer[0];\n    end\n  end\n\nendmodule",
        "module_name": "shift_register #",
        "module_hash": "b9a6344793366beef431ced7a03a4b3c",
        "dataset_index": 19020
      },
      "top__69cf08fc": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output reg pwm,   // 1-bit PWM output\n    input [3:0] encoder_out,\n    output reg [1:0] pos  );  // 2-bit output indicating the highest priority input bit.\n\n    reg [3:0] counter;\n    reg [7:0] compare_value;\n    reg [3:0] gray_code;\n    reg [2:0] highest_priority;\n\n    // Generate PWM signal with 100Hz frequency and 50% duty cycle\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            counter <= 4'b0000;\n            compare_value <= 8'd125;\n            pwm <= 1'b0;\n        end else begin\n            if (counter == compare_value) begin\n                counter <= 4'b0000;\n                pwm <= ~pwm;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    // Convert binary to gray code\n    always @(encoder_out) begin\n        gray_code[0] = encoder_out[0];\n        gray_code[1] = encoder_out[0] ^ encoder_out[1];\n        gray_code[2] = encoder_out[1] ^ encoder_out[2];\n        gray_code[3] = encoder_out[2] ^ encoder_out[3];\n    end\n\n    // Convert gray code to one-hot code\n    always @(gray_code) begin\n        case (gray_code)\n            4'b0001: highest_priority = 3'b001;\n            4'b0010: highest_priority = 3'b010;\n            4'b0100: highest_priority = 3'b100;\n            4'b1000: highest_priority = 3'b000;\n            default: highest_priority = 3'b000;\n        endcase\n    end\n\n    // Output the highest priority input bit\n    always @(highest_priority) begin\n        case (highest_priority)\n            3'b001: pos = 2'b01;\n            3'b010: pos = 2'b10;\n            3'b100: pos = 2'b11;\n            default: pos = 2'b00;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "69cf08fce6dfd3571689ce33734c7a6c",
        "dataset_index": 20199
      },
      "top__b4ba587c": {
        "rtl_code": "\nmodule top_module (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] S,\n    input [3:0] input_bcd,\n    output [7:0] final_output\n);\n\n    wire [15:0] barrel_shifter_output;\n    wire [7:0] bcd_converter_output;\n    \n    assign barrel_shifter_output = (S == 4'b0000) ? A :\n                                   (S == 4'b0001) ? A << 1 :\n                                   (S == 4'b0010) ? A << 2 :\n                                   (S == 4'b0011) ? A << 3 :\n                                   (S == 4'b0100) ? A << 4 :\n                                   (S == 4'b0101) ? A << 5 :\n                                   (S == 4'b0110) ? A << 6 :\n                                   (S == 4'b0111) ? A << 7 :\n                                   (S == 4'b1000) ? A << 8 :\n                                   (S == 4'b1001) ? A << 9 :\n                                   (S == 4'b1010) ? A << 10 :\n                                   (S == 4'b1011) ? A << 11 :\n                                   (S == 4'b1100) ? A << 12 :\n                                   (S == 4'b1101) ? A << 13 :\n                                   (S == 4'b1110) ? A << 14 :\n                                   (S == 4'b1111) ? A << 15 : 16'b0;\n\n    assign bcd_converter_output = (input_bcd == 4'b0000) ? 8'b00000000 :\n                                  (input_bcd == 4'b0001) ? 8'b00000001 :\n                                  (input_bcd == 4'b0010) ? 8'b00000010 :\n                                  (input_bcd == 4'b0011) ? 8'b00000011 :\n                                  (input_bcd == 4'b0100) ? 8'b00000100 :\n                                  (input_bcd == 4'b0101) ? 8'b00000101 :\n                                  (input_bcd == 4'b0110) ? 8'b00000110 :\n                                  (input_bcd == 4'b0111) ? 8'b00000111 :\n                                  (input_bcd == 4'b1000) ? 8'b00001000 :\n                                  (input_bcd == 4'b1001) ? 8'b00001001 :\n                                  (input_bcd == 4'b1010) ? 8'b00001010 :\n                                  (input_bcd == 4'b1011) ? 8'b00001011 :\n                                  (input_bcd == 4'b1100) ? 8'b00001100 :\n                                  (input_bcd == 4'b1101) ? 8'b00001101 :\n                                  (input_bcd == 4'b1110) ? 8'b00001110 :\n                                  8'b00000000;\n\n    assign final_output = barrel_shifter_output[15:8] + bcd_converter_output[7:0];\n    \nendmodule\nmodule barrel_shifter (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] S,\n    output [15:0] Y\n);\n\n    assign Y = (S == 4'b0000) ? A :\n               (S == 4'b0001) ? A << 1 :\n               (S == 4'b0010) ? A << 2 :\n               (S == 4'b0011) ? A << 3 :\n               (S == 4'b0100) ? A << 4 :\n               (S == 4'b0101) ? A << 5 :\n               (S == 4'b0110) ? A << 6 :\n               (S == 4'b0111) ? A << 7 :\n               (S == 4'b1000) ? A << 8 :\n               (S == 4'b1001) ? A << 9 :\n               (S == 4'b1010) ? A << 10 :\n               (S == 4'b1011) ? A << 11 :\n               (S == 4'b1100) ? A << 12 :\n               (S == 4'b1101) ? A << 13 :\n               (S == 4'b1110) ? A << 14 :\n               (S == 4'b1111) ? A << 15 : 16'b0;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "b4ba587c867aeb2b942a958bcb76f55f",
        "dataset_index": 16955
      },
      "sky130_fd_sc_ms__a2111o_52317091": {
        "rtl_code": "module sky130_fd_sc_ms__a2111o (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    // Module ports\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    // Local signals\n    wire and0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , A1, A2              );\n    or  or0  (or0_out_X, C1, B1, and0_out, D1);\n    buf buf0 (X        , or0_out_X           );\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__a2111o",
        "module_hash": "5231709140afd731cd8036ac7f657cc5",
        "dataset_index": 16666
      },
      "counter_0c0c265b": {
        "rtl_code": "module counter (\n    input clk,\n    input reset,\n    output reg [3:0] count_out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule mux (\n    input [3:0] d,\n    input [3:0] count_out,\n    input select,\n    output reg [3:0] mux_out\n);\n    always @(*) begin\n        if (select) begin\n            mux_out = d;\n        end else begin\n            mux_out = count_out;\n        end\n    end\nendmodule\n\nmodule adder (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n    always @(*) begin\n        sum = a + b;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] d,\n    input select,\n    output [3:0] final_out\n);\n    wire [3:0] count_out;\n    wire [3:0] mux_out;\n    wire [3:0] adder_out;\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .count_out(count_out)\n    );\n\n    mux mux_inst (\n        .d(d),\n        .count_out(count_out),\n        .select(select),\n        .mux_out(mux_out)\n    );\n\n    adder adder_inst (\n        .a(mux_out),\n        .b(count_out),\n        .sum(adder_out)\n    );\n\n    reg [3:0] final_out_reg;\n    always @(posedge clk) begin\n        final_out_reg <= adder_out;\n    end\n\n    assign final_out = final_out_reg;\nendmodule",
        "module_name": "counter",
        "module_hash": "0c0c265bd8886d1fc4330ff9c0c14bb0",
        "dataset_index": 16935
      },
      "multiplier_81bca97c": {
        "rtl_code": "\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n\nreg [3:0] i;\n\nalways @(*) begin\n    result = 0;\n    for (i = 0; i < 8; i = i + 1) begin\n        if (a[i] == 1) begin\n            result = result + (b << i);\n        end\n    end\nend\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "81bca97ca963155c3373fd68c92f3fd5",
        "dataset_index": 12965
      },
      "pipelined_multiplier_1f19b281": {
        "rtl_code": "module pipelined_multiplier (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n\nreg [7:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        a_reg <= 8'h00;\n        b_reg <= 8'h00;\n        result <= 16'h0000;\n    end else begin\n        a_reg <= a;\n        b_reg <= b;\n        result <= {8'h00, a_reg} * {8'h00, b_reg};\n    end\nend\n\nendmodule",
        "module_name": "pipelined_multiplier",
        "module_hash": "1f19b281f234beab45e1543ff10c7a39",
        "dataset_index": 10621
      },
      "modulo_operator_fd78c8a9": {
        "rtl_code": "module modulo_operator (\n  input [31:0] dividend,\n  input [31:0] divisor,\n  output reg [31:0] remainder\n);\n\n  // Calculate the quotient\n  reg [31:0] quotient;\n  always @* begin\n    quotient = dividend / divisor;\n  end\n\n  // Calculate the product of the quotient and the divisor\n  reg [31:0] product;\n  always @* begin\n    product = quotient * divisor;\n  end\n\n  // Subtract the product from the dividend to get the remainder\n  always @* begin\n    remainder = dividend - product;\n  end\n\nendmodule",
        "module_name": "modulo_operator",
        "module_hash": "fd78c8a9f6f0bcc18fc20b85ab67022c",
        "dataset_index": 3211
      },
      "ripple_adder_663d963a": {
        "rtl_code": "module ripple_adder(\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] temp_sum;\n  wire [4:0] temp_carry;\n\n  assign temp_sum = a + b + cin;\n  assign temp_carry = {cin, temp_sum} + 1'b0;\n\n  assign sum = temp_sum;\n  assign cout = temp_carry[4];\n\nendmodule",
        "module_name": "ripple_adder",
        "module_hash": "663d963a39b1415711b7aa8a4d61a377",
        "dataset_index": 5207
      },
      "adder_8aca14bf": {
        "rtl_code": "module adder(\n    input [3:0] a, \n    input [3:0] b, \n    input cin, \n    output [3:0] sum, \n    output cout\n);\n\n    wire c1, c2, c3;\n    full_adder fa1(a[0], b[0], cin, sum[0], c1);\n    full_adder fa2(a[1], b[1], c1, sum[1], c2);\n    full_adder fa3(a[2], b[2], c2, sum[2], c3);\n    full_adder fa4(a[3], b[3], c3, sum[3], cout);\n    \nendmodule\n\nmodule full_adder(\n    input a, \n    input b, \n    input cin, \n    output sum, \n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n    \nendmodule",
        "module_name": "adder",
        "module_hash": "8aca14bf9d25efd6a4a72a568bb1d2aa",
        "dataset_index": 5304
      },
      "MUX_4to1_d6356c8b": {
        "rtl_code": "module MUX_4to1 (\n  input X0,\n  input X1,\n  input X2,\n  input X3,\n  input S0,\n  input S1,\n  output Y\n);\n\n  assign Y = (S1 & S0) ? X3 :\n             (S1 & ~S0) ? X2 :\n             (~S1 & S0) ? X1 :\n             X0;\n\nendmodule",
        "module_name": "MUX_4to1",
        "module_hash": "d6356c8b7affff1718629f8be0c53321",
        "dataset_index": 13695
      },
      "FpuFp32_fc63c546": {
        "rtl_code": "\nmodule FpuFp32(\n    input clk,\n    input [3:0] opMode,\n    input [31:0] srca,\n    input [31:0] srcb,\n    output [31:0] dst\n);\n\n// Parameter definitions\nparameter [3:0] OP_NONE = 4'h00;\nparameter [3:0] OP_ADD = 4'h01;\nparameter [3:0] OP_SUB = 4'h02;\nparameter [3:0] OP_MUL = 4'h03;\nparameter [3:0] OP_DIV = 4'h04;\nparameter [3:0] OP_ABS = 4'h05;\nparameter [3:0] OP_NEG = 4'h06;\nparameter [3:0] OP_RCP = 4'h07;\nparameter [3:0] OP_SQRT = 4'h08;\n\n// Internal signals\nwire fpaIsSub;\nwire [31:0] fpaDst;\nwire [31:0] fpmSrcB;\nwire [31:0] fpmDst;\nwire [31:0] fpRcpDst;\n\n// Instantiate submodules\nFpuFp32Add fpadd(clk, fpaIsSub, srca, srcb, fpaDst);\nFpuFp32Mul fpmul(clk, srca, fpmSrcB, fpmDst);\nFpuFp32Rcp fprcp(clk, srcb, fpRcpDst);\n\n// Assign inputs to submodules\nassign fpaIsSub = (opMode == OP_SUB);\nassign fpmSrcB = (opMode == OP_DIV) ? fpRcpDst : srcb;\n\n// Output selection logic\nassign dst = (opMode == OP_ADD) ? fpaDst :\n             (opMode == OP_SUB) ? fpaDst :\n             (opMode == OP_MUL) ? fpmDst :\n             (opMode == OP_DIV) ? fpmDst :\n             (opMode == OP_ABS) ? ((srcb[31] == 1) ? -srcb : srcb) :\n             (opMode == OP_NEG) ? -srcb :\n             (opMode == OP_RCP) ? fpRcpDst :\n             (opMode == OP_SQRT) ? ((srcb - 32'h3F80_0000) >>> 1) + 32'h3F80_0000 :\n             srcb;\n\nendmodule\n\nmodule FpuFp32Add(clk, isSub, srca, srcb, dst);\n\ninput clk;\ninput isSub;\ninput [31:0] srca;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    if (isSub) begin\n        dst_reg = srca - srcb;\n    end else begin\n        dst_reg = srca + srcb;\n    end\nend\n\nassign dst = dst_reg;\n\nendmodule\n\nmodule FpuFp32Mul(clk, srca, srcb, dst);\n\ninput clk;\ninput [31:0] srca;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    dst_reg = srca * srcb;\nend\n\nassign dst = dst_reg;\n\nendmodule\n\nmodule FpuFp32Rcp(clk, srcb, dst);\n\ninput clk;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    dst_reg = 32'h3F80_0000 / srcb;\nend\n\nassign dst = dst_reg;\n\nendmodule\n",
        "module_name": "FpuFp32",
        "module_hash": "fc63c546b72ba254f19e482c55bde72d",
        "dataset_index": 21337
      },
      "adder_tree_top_aee90600": {
        "rtl_code": "`define ADDER_WIDTH 019\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "aee90600fbc64d25f067d503447d6b85",
        "dataset_index": 24900
      },
      "center_pos_97e85c9d": {
        "rtl_code": "\nmodule center_pos(\n    input [15:0] x_row,\n    input [15:0] y_col,\n    input reset,\n    input clk,\n    input [15:0] valid,\n    output reg [15:0] center_x,\n    output reg [15:0] center_y\n);\n\nreg [31:0] center_x_temp;\nreg [31:0] center_y_temp;\nreg [31:0] pixel_counter;\nreg [31:0] dirty;\n\nwire [31:0] result_x;\nwire [31:0] result_y;\n\n// Replace the alt_div modules with generic division operators\n\n// Calculate the center x position\nassign result_x = (center_x_temp / pixel_counter);\n\n// Calculate the center y position\nassign result_y = (center_y_temp / pixel_counter);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        center_x <= 16'h0;\n        center_y <= 16'h0;\n        center_x_temp <= 32'h0;\n        center_y_temp <= 32'h0;\n        pixel_counter <= 32'h0;\n        dirty <= 32'h0;\n    end else begin\n        if (dirty >= 32'h00075300) begin\n            center_x <= result_x[15:0];\n            center_y <= result_y[15:0];\n            center_x_temp <= 32'h0;\n            center_y_temp <= 32'h0;\n            pixel_counter <= 32'h0;\n            dirty <= 32'h0;\n        end else if (valid[dirty[31:16]]) begin\n            center_x_temp <= center_x_temp + x_row;\n            center_y_temp <= center_y_temp + y_col;\n            pixel_counter <= pixel_counter + 1;\n            dirty <= dirty + 1;\n        end else begin\n            dirty <= dirty + 1;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "center_pos",
        "module_hash": "97e85c9db21ec8e39b2b8c35ffa68f06",
        "dataset_index": 19517
      },
      "full_adder_f8f349fd": {
        "rtl_code": "module full_adder (\n    input A,\n    input B,\n    input CI,\n    output SUM,\n    output COUT_N\n);\n\n    // Local signals\n    wire xor0_out_SUM ;\n    wire a_b          ;\n    wire a_ci         ;\n    wire b_ci         ;\n    wire or0_out_coutn;\n\n    //  Name  Output         Other arguments\n    xor xor0 (xor0_out_SUM , A, B, CI       );\n    buf buf0 (SUM          , xor0_out_SUM   );\n    nor nor0 (a_b          , A, B           );\n    nor nor1 (a_ci         , A, CI          );\n    nor nor2 (b_ci         , B, CI          );\n    or  or0  (or0_out_coutn, a_b, a_ci, b_ci);\n    buf buf1 (COUT_N       , or0_out_coutn  );\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "f8f349fd9e1dcee705ea1b636b9a9ac6",
        "dataset_index": 2508
      },
      "RegFileWW_9b80856b": {
        "rtl_code": "\n\nmodule RegFileWW (rd1data,rd2data,wrdata,rd1addr,rd2addr,wraddr,\n\trd1en,rd2en,wren,wrbyteen,clk);\n\n\n\t\n\toutput [127:0] rd1data,rd2data;\n\t\n\t\n\t\n\tinput [0:127] wrdata;\n\tinput clk;\n\tinput wren;\n\tinput rd1en, rd2en;\n\t\n\tinput [4:0] wraddr, rd1addr, rd2addr;\n\t\n\tinput [15:0] wrbyteen;\n\t\n\t\n\t\n\t\n\treg [127:0] rd1data,rd2data;\t\t\n\treg [127:0] reg_file [31:0];\t\treg [127:0] ones;\t\t\t\t\treg [127:0] result;\t\t\t\t\treg [7:0] operand;\t\t\t\t\talways @(posedge clk)\n\tbegin\n\t\tones=128'd0;\n\t\tones=ones-1'd1;\n\t\n\t\tif(wren)\n\t\tbegin\n\t\t\tif(wrbyteen==16'h1)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[0:7];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[8:15];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[16:23];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hf)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[24:31];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h1f)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[32:39];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3f)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[40:47];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7f)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[48:55];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[56:63];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h1ff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[64:71];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3ff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[72:79];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7ff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[80:87];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hfff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[88:95];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h1fff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[96:103];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3fff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[104:111];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7fff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[112:119];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hffff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[120:127];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\t\n\t\tend\n\t\t\n\t\t\n\t\tif(rd1en)\n\t\tbegin\n\t\t\trd1data<=reg_file[rd1addr];\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trd1data<=128'b0;\n\t\tend\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif(rd2en)\n\t\tbegin\n\t\t\trd2data<=reg_file[rd2addr];\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trd2data<=128'b0;\n\t\tend\n\tend\n\t\n\t\n\t\n\t\nendmodule\n",
        "module_name": "RegFileWW",
        "module_hash": "9b80856b25676e9a041bcc0e3f15494f",
        "dataset_index": 10510
      },
      "and_gate_ctrl_fbfa6ff2": {
        "rtl_code": "module and_gate_ctrl(\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input [3:0] d,\n    input ctrl,\n    input vdd,\n    input gnd,\n    output out\n);\n\nwire [3:0] and_out;\n\nassign and_out = a & b & c & d;\n\nassign out = (ctrl == 1'b1) ? (~and_out) : and_out;\n\nendmodule",
        "module_name": "and_gate_ctrl",
        "module_hash": "fbfa6ff20b6e7ad00e28e9169ae2253c",
        "dataset_index": 17180
      },
      "zbroji_7b74bf42": {
        "rtl_code": "\n\n\n\nmodule zbroji (\n        ap_start,\n        ap_done,\n        ap_idle,\n        ap_ready,\n        a,\n        b,\n        ap_return\n);\n\ninput   ap_start;\noutput   ap_done;\noutput   ap_idle;\noutput   ap_ready;\ninput  [31:0] a;\ninput  [31:0] b;\noutput  [31:0] ap_return;\n\nparameter    ap_const_logic_1 = 1'b1;\nparameter    ap_const_logic_0 = 1'b0;\n\n\n\nassign ap_done = ap_start;\nassign ap_idle = ap_const_logic_1;\nassign ap_ready = ap_start;\nassign ap_return = (b + a);\n\n\nendmodule ",
        "module_name": "zbroji",
        "module_hash": "7b74bf4219935a391d9ed4f38362aa07",
        "dataset_index": 8355
      },
      "hamming_encoder_decoder_fe628fcd": {
        "rtl_code": "module hamming_encoder_decoder (\n  input [k-1:0] data_in,\n  output [n-1:0] encoded_data,\n  output [k-1:0] decoded_data\n);\n\nparameter k = 4; // length of input data\nparameter n = 7; // length of encoded data\n\n// Calculate the parity bits for the encoded data\nwire p1, p2, p3;\nassign p1 = data_in[0] ^ data_in[1] ^ data_in[3];\nassign p2 = data_in[0] ^ data_in[2] ^ data_in[3];\nassign p3 = data_in[1] ^ data_in[2] ^ data_in[3];\n\n// Append the parity bits to the input data to create the encoded data\nassign encoded_data = {data_in, p1, p2, p3};\n\n// Calculate the syndrome of the encoded data\nwire s1, s2, s3;\nassign s1 = encoded_data[0] ^ encoded_data[1] ^ encoded_data[3] ^ encoded_data[4] ^ encoded_data[6];\nassign s2 = encoded_data[0] ^ encoded_data[2] ^ encoded_data[3] ^ encoded_data[5] ^ encoded_data[6];\nassign s3 = encoded_data[1] ^ encoded_data[2] ^ encoded_data[3] ^ encoded_data[6];\n\n// Correct any single-bit errors in the encoded data\nwire [n-1:0] corrected_data;\nassign corrected_data = encoded_data;\nassign corrected_data[s1 + s2*2 + s3*4 - 1] = ~corrected_data[s1 + s2*2 + s3*4 - 1];\n\n// Extract the original input data from the corrected data\nassign decoded_data = {corrected_data[3], corrected_data[5], corrected_data[6], corrected_data[4]};\n\nendmodule",
        "module_name": "hamming_encoder_decoder",
        "module_hash": "fe628fcd4ef6f9acd749571a02363997",
        "dataset_index": 5213
      },
      "AND4_W9_c9b37ae3": {
        "rtl_code": "module AND4_W9 (\n  input [3:0] A,\n  output Y\n);\n\n  wire n1, n2, n3;\n  \n  assign n1 = ~(A[0] & A[1]);\n  assign n2 = ~(A[2] & A[3]);\n  assign n3 = ~(n1 & n2);\n  \n  assign Y = ~n3;\n\nendmodule",
        "module_name": "AND4_W9",
        "module_hash": "c9b37ae3d0a96500fa4f074e0b32966e",
        "dataset_index": 1129
      },
      "adder_327ba869": {
        "rtl_code": "\nmodule adder(\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire [15:0] sum_in,\n    output wire [7:0] sum,\n    output wire carry\n);\n\n    assign {carry, sum} = sum_in + {a, b};\n\nendmodule\n",
        "module_name": "adder",
        "module_hash": "327ba869d366e65182c775798fb30121",
        "dataset_index": 15658
      },
      "sync_fifo #_37a37cd2": {
        "rtl_code": "module sync_fifo #(\n    parameter DWIDTH = 16,\n    parameter DEPTH = 8\n) (\n    input clk,\n    input res_n,\n    input [DWIDTH-1:0] d_in,\n    input shift_in,\n    input shift_out,\n    output reg [DWIDTH-1:0] d_out,\n    output reg full,\n    output reg empty,\n    output wire almost_full,\n    output wire almost_empty\n);\n\n    reg [DWIDTH-1:0] buffer [DEPTH-1:0];\n    reg [DEPTH-1:0] fill_level;\n    reg [DEPTH-1:0] read_pointer;\n    reg [DEPTH-1:0] write_pointer;\n    \n    always @(posedge clk, negedge res_n) begin\n        if (~res_n) begin\n            d_out <= 0;\n            fill_level <= 0;\n            read_pointer <= 0;\n            write_pointer <= 0;\n            empty <= 1;\n            full <= 0;\n        end else begin\n            if (shift_out && ~empty) begin\n                d_out <= buffer[read_pointer];\n                read_pointer <= read_pointer + 1;\n                if (read_pointer == write_pointer) begin\n                    empty <= 1;\n                end\n                fill_level <= fill_level - 1;\n                full <= 0;\n            end else if (shift_in && ~full) begin\n                buffer[write_pointer] <= d_in;\n                write_pointer <= write_pointer + 1;\n                if (write_pointer == read_pointer) begin\n                    full <= 1;\n                end\n                fill_level <= fill_level + 1;\n                empty <= 0;\n            end else begin\n                d_out <= d_out;\n            end\n        end\n    end\n    \n    assign almost_full = (fill_level >= DEPTH-1);\n    assign almost_empty = (fill_level <= 1);\n    \nendmodule",
        "module_name": "sync_fifo #",
        "module_hash": "37a37cd289c75f480b74c011e46163b9",
        "dataset_index": 7462
      },
      "my_or_28677c13": {
        "rtl_code": "module my_or (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    // Module ports\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    or  or0  (or0_out_X, D, C, B, A     );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule",
        "module_name": "my_or",
        "module_hash": "28677c13c6b1b15edd9cdbafbe8f448f",
        "dataset_index": 1042
      },
      "and3_not_A_24f4a44c": {
        "rtl_code": "\nmodule and3_not_A (\n    input A,\n    input B,\n    input C,\n    output X\n);\n\n    // Intermediate signals\n    wire not_A, and_B_C;\n\n    // Logic gates\n    not not_A(not_A, A);\n    and and_B_C(and_B_C, B, C);\n\n    assign X = not_A & and_B_C;\n\nendmodule\n",
        "module_name": "and3_not_A",
        "module_hash": "24f4a44cd72809a879553c43836d2931",
        "dataset_index": 8228
      },
      "tg68_ram #_869f481c": {
        "rtl_code": "module tg68_ram #(\n  parameter MS = 512\n)(\n  input  wire           clk,\n  input  wire           tg68_as,\n  input  wire [ 32-1:0] tg68_adr,\n  input  wire           tg68_rw,\n  input  wire           tg68_lds,\n  input  wire           tg68_uds,\n  input  wire [ 16-1:0] tg68_dat_out,\n  output wire [ 16-1:0] tg68_dat_in,\n  output wire           tg68_dtack\n);\n\nreg  [8-1:0] mem0 [0:MS-1];\nreg  [8-1:0] mem1 [0:MS-1];\n\nreg  [16-1:0] mem_do = 0;\nreg           trn = 1;\nreg           ack = 1;\n\ninteger i;\ninitial begin\n  for (i=0; i<MS; i=i+1) begin\n    mem1[i] = 0;\n    mem0[i] = 0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && tg68_rw) mem_do <= #1 {mem1[tg68_adr[31:1]], mem0[tg68_adr[31:1]]};\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && !tg68_rw) begin\n    if (!tg68_uds) mem1[tg68_adr[31:1]] <= #1 tg68_dat_out[15:8];\n    if (!tg68_lds) mem0[tg68_adr[31:1]] <= #1 tg68_dat_out[7:0];\n  end\nend\n\nalways @ (posedge clk) begin\n  trn <= #1 tg68_as;\n  ack <= #1 trn;\nend\n\nassign tg68_dat_in = mem_do;\nassign tg68_dtack = ack || tg68_as; task load;\n  input [1024*8-1:0] file;\n  reg [16-1:0] memory[0:MS-1];\n  reg [16-1:0] dat;\n  integer i;\nbegin\n  $readmemh(file, memory);\n  for (i=0; i<MS; i=i+1) begin\n    dat = memory[i];\n    mem1[i] = dat[15:8];\n    mem0[i] = dat[7:0];\n  end\nend\nendtask\n\n\nendmodule\n\n",
        "module_name": "tg68_ram #",
        "module_hash": "869f481c926886592c7ca9657325ac16",
        "dataset_index": 2336
      },
      "mult_16x16_c253e063": {
        "rtl_code": "module mult_16x16 (\n    input  wire [15:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n\nmodule mult_20x18 (\n    input  wire [19:0] A,\n    input  wire [17:0] B,\n    output wire [37:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n\nmodule mult_8x8 (\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output wire [15:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n\nmodule mult_10x9 (\n    input  wire [ 9:0] A,\n    input  wire [ 8:0] B,\n    output wire [18:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n",
        "module_name": "mult_16x16",
        "module_hash": "c253e0630a648c04bfee499a1ef9a3cf",
        "dataset_index": 5520
      },
      "RAM_SHIFTER #_1b7b3f93": {
        "rtl_code": "module RAM_SHIFTER #(\n    parameter IO_WIDTH = 16,\n    parameter ADDR_WIDTH = 4,\n    parameter PHASE_SHIFT = 2\n) (\n    input                       clk,\n\n    input [IO_WIDTH-1:0]        in,\n    output reg [IO_WIDTH-1:0]   out,\n\n    output reg [ADDR_WIDTH-1:0] addr,\n    input                       ram_out,\n    output                      ram_in\n);\n\n    reg [IO_WIDTH-1:0]          shift_in;\n    reg [IO_WIDTH-1:0]          shift_out;\n\n    assign ram_in = shift_in[0];\n\n    initial begin\n        out       <= 0;\n        addr      <= 0;\n        shift_in  <= 0;\n        shift_out <= 0;\n    end\n\n    always @(posedge clk) begin\n        if(addr == 0)\n          begin out <= {shift_out[IO_WIDTH-PHASE_SHIFT-1:0], shift_out[IO_WIDTH-1:IO_WIDTH-PHASE_SHIFT]};\n\n              shift_in <= in;\n          end\n        else\n          begin\n              shift_in <= {shift_in[IO_WIDTH-2:0], shift_in[IO_WIDTH-1]};\n          end\n\n        shift_out <= {shift_out[IO_WIDTH-2:0], ram_out};\n\n        addr <= addr + 1;\n    end\nendmodule\n",
        "module_name": "RAM_SHIFTER #",
        "module_hash": "1b7b3f93097df6c2f57062f8204ca7f6",
        "dataset_index": 21987
      },
      "shift_register_c7050afa": {
        "rtl_code": "module shift_register (\n    input clk,\n    input parallel_load,\n    input [3:0] in,\n    output reg out\n);\n\nreg [3:0] reg1, reg2, reg3, reg4;\n\nalways @(posedge clk) begin\n    reg4 <= reg3;\n    reg3 <= reg2;\n    reg2 <= reg1;\n    reg1 <= parallel_load ? in : reg1;\n    out <= reg4;\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "c7050afa713a9b972796842b8cb5c417",
        "dataset_index": 811
      },
      "sequence_detector_9ecdde8e": {
        "rtl_code": "\nmodule sequence_detector (\n    input clk,\n    input reset,\n    input [35:0] in,\n    output [3:0] sequence_detected,\n    output [31:0] change_detection\n);\n\n    reg [35:0] shift_reg;\n    reg [3:0] sequence_detected_reg;\n    reg [31:0] change_detection_reg;\n    wire [31:0] change_detection_output;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 36'b0;\n            sequence_detected_reg <= 4'b0;\n            change_detection_reg <= 32'b0;\n        end else begin\n            shift_reg <= {shift_reg[34:0], in};\n            if (shift_reg[35:32] == 4'b1010) begin\n                sequence_detected_reg <= 4'b1010;\n            end else begin\n                sequence_detected_reg <= 4'b0;\n            end\n            change_detection_reg <= change_detection_output;\n        end\n    end\n\n    assign change_detection_output = ({32'b0, sequence_detected_reg} & (in ^ shift_reg[35:2]));\n\n    assign sequence_detected = sequence_detected_reg;\n    assign change_detection = change_detection_reg;\n\nendmodule\nmodule combined_module (\n    input clk,\n    input reset,\n    input [35:0] in,\n    output [31:0] out\n);\n\n    wire [3:0] sequence_detected;\n    wire [31:0] change_detection;\n\n    sequence_detector detector (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .sequence_detected(sequence_detected),\n        .change_detection(change_detection)\n    );\n\n    assign out = (in ^ change_detection) | ({32'b0, sequence_detected} << 28);\n\nendmodule",
        "module_name": "sequence_detector",
        "module_hash": "9ecdde8e153e4a9aaa2a9df26efebc76",
        "dataset_index": 16470
      },
      "fifo_24in_24out_12kb_compare_0_097996f9": {
        "rtl_code": "module fifo_24in_24out_12kb_compare_0 (\n  input wire clk,\n  input wire rst,\n  input wire [23:0] din,\n  output reg [23:0] dout,\n  output reg comp\n);\n\n  // Constants\n  localparam WIDTH = 24;\n  localparam DEPTH = 512;\n  localparam ADDR_WIDTH = 9;\n  localparam FULL_ADDR = DEPTH - 1;\n  localparam EMPTY_ADDR = 0;\n  localparam COMP_OFFSET = 24;\n\n  // Registers\n  reg [ADDR_WIDTH-1:0] write_ptr;\n  reg [ADDR_WIDTH-1:0] read_ptr;\n  reg [WIDTH-1:0] fifo [0:DEPTH-1];\n\n  // Wires\n  wire [WIDTH-1:0] read_data;\n  wire [WIDTH-1:0] comp_data;\n  wire full;\n  wire empty;\n\n  // Internal logic\n  assign full = (write_ptr == FULL_ADDR) && (read_ptr == EMPTY_ADDR);\n  assign empty = (write_ptr == read_ptr) && (read_ptr != EMPTY_ADDR);\n\n  assign read_data = empty ? 0 : fifo[read_ptr];\n  assign comp_data = (read_ptr >= COMP_OFFSET) ? fifo[read_ptr - COMP_OFFSET] : 0;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      write_ptr <= EMPTY_ADDR;\n      read_ptr <= EMPTY_ADDR;\n      dout <= 0;\n      comp <= 0;\n    end else begin\n      if (!full) begin\n        fifo[write_ptr] <= din;\n        write_ptr <= (write_ptr == FULL_ADDR) ? EMPTY_ADDR : write_ptr + 1;\n      end\n      if (!empty) begin\n        dout <= read_data;\n        read_ptr <= (read_ptr == FULL_ADDR) ? EMPTY_ADDR : read_ptr + 1;\n      end\n      comp <= (comp_data == dout) ? 1 : 0;\n    end\n  end\n\nendmodule",
        "module_name": "fifo_24in_24out_12kb_compare_0",
        "module_hash": "097996f9a14781bbb5a1e52847157cd7",
        "dataset_index": 16776
      },
      "pipeline_register_e9ff71f3": {
        "rtl_code": "module pipeline_register (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  output [31:0] data_out\n);\n\n  reg [31:0] data_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      data_reg <= 0;\n    end else begin\n      data_reg <= data_in;\n    end\n  end\n\n  assign data_out = data_reg;\n\nendmodule",
        "module_name": "pipeline_register",
        "module_hash": "e9ff71f3e91d8855970c37bf2f0a0e31",
        "dataset_index": 8895
      },
      "four_bit_adder_98bc81d9": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] c;\n    wire [3:0] g;\n    wire [3:0] p;\n\n    assign g = a ^ b;\n    assign p = a & b;\n\n    assign c[0] = cin;\n    assign c[4:1] = {p[3], g[2], g[1], g[0]};\n\n    assign sum = g + c[4:1];\n    assign cout = c[4];\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "98bc81d97f546946296075765392c9a2",
        "dataset_index": 21155
      },
      "DecoEscrituraRegistros_8e90f7be": {
        "rtl_code": "\nmodule DecoEscrituraRegistros(Address,Write,EnableStart,EnableRegister\n );\n \n input Write;\n input [8:0] Address;\n output    [21:0] EnableRegister ;\n output  EnableStart;\n \n\n\n\tassign EnableStart = (Address==9'h08C) ? 1'b1 : 1'b0 ;\n\t\n\tassign EnableRegister[0] = (Address==9'h00C)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[1] = (Address==9'h010)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[2] = (Address==9'h014)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[3] = (Address==9'h018)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[4] = (Address==9'h01C)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[5] = (Address==9'h020)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[6] = (Address==9'h024)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[7] = (Address==9'h028)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[8] = (Address==9'h02C)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[9] = (Address==9'h030)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[10] = (Address==9'h034)&Write ? 1'b1 : 1'b0;  assign EnableRegister[11] = (Address==9'h038)&Write ? 1'b1 : 1'b0;  assign EnableRegister[12] = (Address==9'h03C)&Write ? 1'b1 : 1'b0;  assign EnableRegister[13] = (Address==9'h040)&Write ? 1'b1 : 1'b0;  assign EnableRegister[14] = (Address==9'h044)&Write ? 1'b1 : 1'b0;  assign EnableRegister[15] = (Address==9'h048)&Write ? 1'b1 : 1'b0;  assign EnableRegister[16] = (Address==9'h04C)&Write ? 1'b1 : 1'b0;  assign EnableRegister[17] = (Address==9'h050)&Write ? 1'b1 : 1'b0;  assign EnableRegister[18] = (Address==9'h054)&Write ? 1'b1 : 1'b0;  assign EnableRegister[19] = (Address==9'h058)&Write ? 1'b1 : 1'b0;  assign EnableRegister[20] = (Address==9'h05C)&Write ? 1'b1 : 1'b0; assign EnableRegister[21] = (Address==9'h060)&Write ? 1'b1 : 1'b0; endmodule\n\n",
        "module_name": "DecoEscrituraRegistros",
        "module_hash": "8e90f7be282918237d9d436cc93ac190",
        "dataset_index": 22877
      },
      "wait_time__bfa7d2c0": {
        "rtl_code": "module wait_time_module (reset, work, clk, wait_time); \ninput  clk,work,reset;\noutput [11:0] wait_time;\nreg [11:0] wait_time;\n\nreg [5:0] i;\n\nalways @ (posedge clk or negedge reset)\nbegin\n\tif(!reset) \n\tbegin\n\t\twait_time <= 0;\n\t\ti <= 0;\n\tend\n\telse if (work == 0)\n\tbegin\n\t\tif(i >= 4)\n\t\t\tbegin\n\t\t\t\twait_time <= wait_time +1;\n\t\t\t\ti <= 0;\n\t\t\tend\n\t\telse i <= i+1;\n\tend\nend\n\n\n\n\n\n\n\n\n\nendmodule \n",
        "module_name": "wait_time_",
        "module_hash": "bfa7d2c0cbaba771151da039cb7231d5",
        "dataset_index": 9415
      },
      "bin2sevenseg_fce1175f": {
        "rtl_code": "module bin2sevenseg(inputbin, displayout);\n\ninput [3:0] inputbin;\noutput [6:0] displayout;\n\nparameter bit0 = 7'b0000001;\nparameter bit1 = 7'b0000010;\nparameter bit2 = 7'b0000100;\nparameter bit3 = 7'b0001000;\nparameter bit4 = 7'b0010000;\nparameter bit5 = 7'b0100000;\nparameter bit6 = 7'b1000000;\n\nparameter zero  = ~(bit0 | bit1 | bit2 | bit3 | bit4 | bit5);\nparameter one   = ~(bit1 | bit2);\nparameter two   = ~(bit0 | bit1 | bit3 | bit4 | bit6);\nparameter three = ~(bit0 | bit1 | bit2 | bit3 | bit6);\nparameter four  = ~(bit1 | bit2 | bit5 | bit6);\nparameter five  = ~(bit0 | bit2 | bit3 | bit5 | bit6);\nparameter six   = ~(bit0 | bit2 | bit3 | bit4 | bit5 | bit6);\nparameter seven = ~(bit0 | bit1 | bit2);\nparameter eight = ~(bit0 | bit1 | bit2 | bit3 | bit4 | bit5 | bit6);\nparameter nine  = ~(bit0 | bit1 | bit2 | bit5 | bit6);\nparameter blank = ~(7'd0);\n\nreg [6:0] displayout;\n\nalways @ (inputbin)\nbegin\n    case (inputbin)\n        4'd0: displayout = zero;\n        4'd1: displayout = one;\n        4'd2: displayout = two;\n        4'd3: displayout = three;\n        4'd4: displayout = four;\n        4'd5: displayout = five;\n        4'd6: displayout = six;\n        4'd7: displayout = seven;\n        4'd8: displayout = eight;\n        4'd9: displayout = nine;\n        4'd10: displayout = 7'b0111111; // A\n        4'd11: displayout = 7'b0001111; // b\n        4'd12: displayout = 7'b0100111; // C\n        4'd13: displayout = 7'b0011110; // d\n        4'd14: displayout = 7'b0100111; // E\n        4'd15: displayout = 7'b0100011; // F\n        default: displayout = blank;\n    endcase\nend\n\nendmodule",
        "module_name": "bin2sevenseg",
        "module_hash": "fce1175fb558a210342437ad6adb19b5",
        "dataset_index": 13901
      },
      "calculator_79b2de3f": {
        "rtl_code": "\nmodule calculator(\n   input [7:0] a,\n   input [7:0] b,\n   input [1:0] op,\n   input start,\n   output reg done,\n   output reg [7:0] result\n   );\n\n   reg [15:0] temp;\n   reg [7:0] i;\n   \n   always@(posedge start)\n   begin\n      case(op)\n         2'b00:result <= a + b;\n         2'b01:result <= a - b;\n         2'b10:result <= a * b;\n         2'b11:begin\n                  if(b == 0) begin\n                     done <= 1;\n                     result <= 8'hFF; // division by zero\n                  end\n                  else begin\n                     temp <= a;\n                     result <= 0;\n                     for (i = 0; i < 8; i = i + 1) begin\n                        if (temp >= b) begin\n                           temp <= temp - b;\n                           result[i] <= 1;\n                        end\n                        temp <= {temp[6:0], 1'b0};\n                     end\n                     done <= 1;\n                  end\n               end\n         default:begin\n                     done <= 1;\n                     result <= 8'hFF; // invalid operation\n                  end\n      endcase\n      done <= 0;\n   end\n   \nendmodule",
        "module_name": "calculator",
        "module_hash": "79b2de3f6269f5b15439ccf96a351904",
        "dataset_index": 11088
      },
      "binary_display_1c094147": {
        "rtl_code": "module binary_display(\n    input clk,\n    input [3:0] data,\n    output reg display_enable  \n);\n\nreg [3:0] prev_data;\nreg [3:0] data_count;\n\nalways @(posedge clk) begin\n    if (data == prev_data) begin\n        data_count <= data_count + 1;\n    end else begin\n        data_count <= 0;\n    end\n    \n    if (data_count == 9) begin\n        display_enable <= 1;\n        data_count <= 0;  \n    end else begin\n        display_enable <= (data_count == 0) ? 0 : display_enable;\n    end\n    \n    prev_data <= data;\nend\n\nreg [3:0] count;  \n\nalways @(posedge clk) begin\n    if (display_enable) begin\n        count <= (count == 10) ? 0 : count + 1;\n    end else begin\n        count <= 0;  // Reset count when display_enable is not active\n    end\nend\n\nendmodule\n",
        "module_name": "binary_display",
        "module_hash": "1c094147d02b8d36648357ddf0c97c53",
        "dataset_index": 18031
      },
      "nand4_07bb3b2f": {
        "rtl_code": "module nand4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\nwire AB, CD, ABCD;\nnot (AB, A & B);\nnot (CD, C & D);\nnot (ABCD, AB & CD);\nnot (Y, ABCD);\n\nendmodule",
        "module_name": "nand4",
        "module_hash": "07bb3b2f73dc316e0ed00c021acc155d",
        "dataset_index": 16762
      },
      "clock_divider_0acb425f": {
        "rtl_code": "\nmodule clock_divider (\n  input clock,\n  input reset,\n  output reg clk_out\n);\n\nparameter divisor = 2; // factor by which the frequency of the input clock signal is divided\n\nalways @ (posedge clock, posedge reset) begin\n  if (reset) begin\n    clk_out <= 0;\n    counter <= 0;\n  end else begin\n    if (counter == divisor - 1) begin\n      clk_out <= ~clk_out;\n      counter <= 0;\n    end else begin\n      counter <= counter + 1;\n    end\n  end\nend\n\nreg [32-1:0] counter;\n\nendmodule\n",
        "module_name": "clock_divider",
        "module_hash": "0acb425fa8c4eab380d62bbcec188b57",
        "dataset_index": 14448
      },
      "antiDroopIIR_16_038fc804": {
        "rtl_code": "module antiDroopIIR_16 (\n\tinput clk,\n\tinput trig,\n\tinput signed [15:0] din,\n\tinput signed [6:0] tapWeight,\n\tinput accClr_en,\n\t output reg oflowDetect = 1'd0,\n\toutput reg signed [15:0] dout = 16'sd0);\n\nparameter IIR_scale = 15;  reg signed [15:0] din_del = 16'sd0;\n`ifdef ADDPIPEREG  reg signed [15:0] din_del_b = 16'sd0;\n`endif\nreg signed [47:0] tap = 48'sd0;\nreg signed [22:0] multreg = 23'sd0;\n\n reg trig_a = 1'b0, trig_b = 1'b0;\nwire trig_edge = trig_a & ~trig_b;\n reg signed [6:0] tapWeight_a = 7'sd0, tapWeight_b = 7'sd0;\n\nwire oflow = (~&tap[47:IIR_scale+15] && ~&(~tap[47:IIR_scale+15]));\n\n\nalways @(posedge clk) begin\n\ttapWeight_a <= tapWeight;\n\ttapWeight_b <= tapWeight_a;\n\ttrig_a <= trig;\n\ttrig_b <= trig_a;\n\tdin_del <= din;\n\t`ifdef ADDPIPEREG\n\t\tdin_del_b <= din_del;\n\t\tmultreg <= din_del*tapWeight_b;\n\t\tif (oflow) dout <= (tap[IIR_scale+16]) ? -16'sd32768 : 16'sd32767;\n\t\telse dout <= din_del_b + tap[IIR_scale+15:IIR_scale];\n\t`else\n\t\tmultreg <= din*tapWeight_b;\n\t\tif (oflow) dout <= (tap[IIR_scale+16]) ? -16'sd32768 : 16'sd32767;\n\t\telse dout <= din_del + tap[IIR_scale+15:IIR_scale];\n\t`endif\n\tif (trig_edge && accClr_en) tap <= 48'sd0;\n\telse tap <= multreg + tap;\n\toflowDetect <= oflow;\nend\n\nendmodule\n",
        "module_name": "antiDroopIIR_16",
        "module_hash": "038fc804c6859c71fee981d0f0b4f9f2",
        "dataset_index": 505
      },
      "mux_2to1_ca92ca15": {
        "rtl_code": "module mux_2to1 (\n    Y   ,\n    A   ,\n    B   ,\n    S   \n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  S   ;\n\n    assign Y = (S == 1) ? B : A;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "ca92ca1590f4c8279ce65c8759ffa78c",
        "dataset_index": 13877
      },
      "inputiso1n_855ce8a7": {
        "rtl_code": "module inputiso1n (\n    X      ,\n    A      ,\n    SLEEP_B,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    wire A_iso, SLEEP_B_iso, VPWR_iso, VGND_iso, VPB_iso, VNB_iso;\n\n    assign A_iso = A ^ VPWR;\n    assign SLEEP_B_iso = SLEEP_B ^ VGND;\n    assign VPWR_iso = VPWR;\n    assign VGND_iso = VGND;\n    assign VPB_iso = VPB;\n    assign VNB_iso = VNB;\n\n    assign X = A_iso & SLEEP_B_iso & VPWR_iso & VGND_iso & VPB_iso & VNB_iso;\n\nendmodule",
        "module_name": "inputiso1n",
        "module_hash": "855ce8a7a0f2f4d226449257f7d095fc",
        "dataset_index": 16198
      },
      "and_nand_e1546799": {
        "rtl_code": "module and_nand (\n    input A,\n    input B,\n    output Y\n);\n\n    wire nand1;\n    wire nand2;\n    wire nand3;\n\n    nand nand_gate1(nand1, A, B);\n    nand nand_gate2(nand2, nand1, nand1);\n    nand nand_gate3(nand3, nand2, nand2);\n    nand nand_gate4(Y, nand3, nand3);\n\nendmodule",
        "module_name": "and_nand",
        "module_hash": "e1546799c757d1fb1c85a96f28094c27",
        "dataset_index": 215
      },
      "wb_drp #_423110ef": {
        "rtl_code": "\n\n\nmodule wb_drp #\n(\n    parameter ADDR_WIDTH = 16\n)\n(\n    input  wire                    clk,\n    input  wire                    rst,\n\n    \n    input  wire [ADDR_WIDTH-1:0]   wb_adr_i,   input  wire [15:0]             wb_dat_i,   output wire [15:0]             wb_dat_o,   input  wire                    wb_we_i,    input  wire                    wb_stb_i,   output wire                    wb_ack_o,   input  wire                    wb_cyc_i,   \n    output wire [ADDR_WIDTH-1:0]   drp_addr,\n    output wire [15:0]             drp_do,\n    input  wire [15:0]             drp_di,\n    output wire                    drp_en,\n    output wire                    drp_we,\n    input  wire                    drp_rdy\n);\n\nreg cycle = 1'b0;\n\nassign drp_addr = wb_adr_i;\nassign drp_do = wb_dat_i;\nassign wb_dat_o = drp_di;\nassign drp_en = wb_cyc_i & wb_stb_i & ~cycle;\nassign drp_we = wb_cyc_i & wb_stb_i & wb_we_i & ~cycle;\nassign wb_ack_o = drp_rdy;\n\nalways @(posedge clk) begin\n    cycle <= wb_cyc_i & wb_stb_i & ~drp_rdy;\n\n    if (rst) begin\n        cycle <= 1'b0;\n    end\nend\n\nendmodule\n",
        "module_name": "wb_drp #",
        "module_hash": "423110ef0aaa610a92319315b5965c03",
        "dataset_index": 1326
      },
      "four_bit_adder_f89a296b": {
        "rtl_code": "module four_bit_adder(\n  input [3:0] A, B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire C1, C2, C3;\n  full_adder FA1(S[0], C1, A[0], B[0], Cin);\n  full_adder FA2(S[1], C2, A[1], B[1], C1);\n  full_adder FA3(S[2], C3, A[2], B[2], C2);\n  full_adder FA4(S[3], Cout, A[3], B[3], C3);\n\nendmodule\n\nmodule full_adder(\n  output sum,\n  output carry_out,\n  input A,\n  input B,\n  input carry_in\n);\n\n  assign {carry_out, sum} = A + B + carry_in;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "f89a296b6c027f7c68221109442afbe1",
        "dataset_index": 7252
      },
      "Clock_Gating_Module_a016a727": {
        "rtl_code": "module Clock_Gating_Module(CLK, EN, TE, RESET, ENCLK);\n  input CLK, EN, TE, RESET;\n  output ENCLK;\n\n  wire gated_clk;\n\n  assign gated_clk = (EN & ~RESET) ? CLK : 1'b0;\n\n  assign ENCLK = (TE) ? ~gated_clk : gated_clk;\n\nendmodule",
        "module_name": "Clock_Gating_Module",
        "module_hash": "a016a72788eaf608db535fe095fd028b",
        "dataset_index": 7585
      },
      "priority_encoder_shift_register_b5eaeaa5": {
        "rtl_code": "\nmodule priority_encoder_shift_register (\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [7:0] in,\n    output reg [6:0] out\n);\n\n    // Priority Encoder\n    wire [2:0] gray_code;\n    wire [2:0] decimal_code;\n    wire [8:0] in_gray;\n    assign in_gray = {in[7], in[7]^in[6], in[6]^in[5], in[5]^in[4], in[4]^in[3], in[3]^in[2], in[2]^in[1], in[1]^in[0]};\n    gray_to_decimal_converter gray_to_decimal(.gray(in_gray[2:0]), .decimal(decimal_code));\n\n    // Shift Register\n    reg [3:0] shift_reg;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            shift_reg <= 4'b0;\n        end else if (load) begin\n            shift_reg <= in[3:0];\n        end else if (ena) begin\n            shift_reg <= {shift_reg[2:0], shift_reg[3]};\n        end\n    end\n\n    // Mux\n    wire [3:0] mux_out;\n    assign mux_out = load ? in[3:0] : shift_reg;\n\n    // Output\n    wire [6:0] sum;\n    adder add(.a(decimal_code), .b(mux_out), .sum(sum));\n    always @* begin\n        out = sum;\n    end\n\nendmodule\nmodule gray_to_decimal_converter (\n    input [2:0] gray,\n    output reg [2:0] decimal\n);\n\n    always @* begin\n        case (gray)\n            3'b000: decimal = 3'b000;\n            3'b001: decimal = 3'b001;\n            3'b010: decimal = 3'b011;\n            3'b011: decimal = 3'b010;\n            3'b100: decimal = 3'b110;\n            3'b101: decimal = 3'b111;\n            3'b110: decimal = 3'b101;\n            3'b111: decimal = 3'b100;\n        endcase\n    end\nendmodule\nmodule adder (\n    input [2:0] a,\n    input [3:0] b,\n    output reg [6:0] sum\n);\n\n    always @* begin\n        sum = {1'b0, a} + b;\n    end\nendmodule",
        "module_name": "priority_encoder_shift_register",
        "module_hash": "b5eaeaa5eb495ebe3f7c64946576c5d5",
        "dataset_index": 13141
      },
      "nfa_get_finals_8db73dc5": {
        "rtl_code": "\n\nmodule nfa_get_finals (\n        ap_clk,\n        ap_rst,\n        ap_start,\n        ap_done,\n        ap_idle,\n        ap_ready,\n        ap_ce,\n        nfa_finals_buckets_req_din,\n        nfa_finals_buckets_req_full_n,\n        nfa_finals_buckets_req_write,\n        nfa_finals_buckets_rsp_empty_n,\n        nfa_finals_buckets_rsp_read,\n        nfa_finals_buckets_address,\n        nfa_finals_buckets_datain,\n        nfa_finals_buckets_dataout,\n        nfa_finals_buckets_size,\n        ap_return_0,\n        ap_return_1\n);\n\nparameter    ap_const_logic_1 = 1'b1;\nparameter    ap_const_logic_0 = 1'b0;\nparameter    ap_ST_pp0_stg0_fsm_0 = 2'b10;\nparameter    ap_ST_pp0_stg1_fsm_1 = 2'b00;\nparameter    ap_ST_pp0_stg2_fsm_2 = 2'b1;\nparameter    ap_ST_pp0_stg3_fsm_3 = 2'b11;\nparameter    ap_const_lv64_1 = 64'b1;\nparameter    ap_const_lv32_0 = 32'b00000000000000000000000000000000;\nparameter    ap_const_lv32_1 = 32'b1;\nparameter    ap_true = 1'b1;\n\ninput   ap_clk;\ninput   ap_rst;\ninput   ap_start;\noutput   ap_done;\noutput   ap_idle;\noutput   ap_ready;\ninput   ap_ce;\noutput   nfa_finals_buckets_req_din;\ninput   nfa_finals_buckets_req_full_n;\noutput   nfa_finals_buckets_req_write;\ninput   nfa_finals_buckets_rsp_empty_n;\noutput   nfa_finals_buckets_rsp_read;\noutput  [31:0] nfa_finals_buckets_address;\ninput  [31:0] nfa_finals_buckets_datain;\noutput  [31:0] nfa_finals_buckets_dataout;\noutput  [31:0] nfa_finals_buckets_size;\noutput  [31:0] ap_return_0;\noutput  [31:0] ap_return_1;\n\nreg ap_done;\nreg ap_idle;\nreg ap_ready;\nreg nfa_finals_buckets_req_write;\nreg nfa_finals_buckets_rsp_read;\nreg[31:0] nfa_finals_buckets_address;\nreg   [1:0] ap_CS_fsm = 2'b10;\nreg    ap_reg_ppiten_pp0_it0;\nreg    ap_reg_ppiten_pp0_it1 = 1'b0;\nreg   [31:0] nfa_finals_buckets_read_reg_59;\nreg    ap_reg_ppiten_pp0_it0_preg = 1'b0;\nreg   [1:0] ap_NS_fsm;\nreg    ap_sig_pprstidle_pp0;\nreg    ap_sig_bdd_131;\nreg    ap_sig_bdd_130;\n\n\n\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_CS_fsm\n    if (ap_rst == 1'b1) begin\n        ap_CS_fsm <= ap_ST_pp0_stg0_fsm_0;\n    end else begin\n        ap_CS_fsm <= ap_NS_fsm;\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_reg_ppiten_pp0_it0_preg\n    if (ap_rst == 1'b1) begin\n        ap_reg_ppiten_pp0_it0_preg <= ap_const_logic_0;\n    end else begin\n        if (((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & ~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0))))) begin\n            ap_reg_ppiten_pp0_it0_preg <= ap_start;\n        end\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_reg_ppiten_pp0_it1\n    if (ap_rst == 1'b1) begin\n        ap_reg_ppiten_pp0_it1 <= ap_const_logic_0;\n    end else begin\n        if (((ap_ST_pp0_stg1_fsm_1 == ap_CS_fsm) & ~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) & ~(ap_const_logic_1 == ap_reg_ppiten_pp0_it0))) begin\n            ap_reg_ppiten_pp0_it1 <= ap_const_logic_0;\n        end else if (((ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm) & (ap_const_logic_1 == ap_ce))) begin\n            ap_reg_ppiten_pp0_it1 <= ap_reg_ppiten_pp0_it0;\n        end\n    end\nend\n\nalways @(posedge ap_clk)\nbegin\n    if (((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg2_fsm_2 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0)))) begin\n        nfa_finals_buckets_read_reg_59 <= nfa_finals_buckets_datain;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1 or ap_ce or nfa_finals_buckets_rsp_empty_n)\nbegin\n    if (((~(ap_const_logic_1 == ap_start) & (ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & (ap_const_logic_1 == ap_reg_ppiten_pp0_it0)) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg1_fsm_1 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))))) begin\n        ap_done = ap_const_logic_1;\n    end else begin\n        ap_done = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1)\nbegin\n    if ((~(ap_const_logic_1 == ap_start) & (ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & (ap_const_logic_0 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_0 == ap_reg_ppiten_pp0_it1))) begin\n        ap_idle = ap_const_logic_1;\n    end else begin\n        ap_idle = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_ce)\nbegin\n    if (((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm) & (ap_const_logic_1 == ap_ce))) begin\n        ap_ready = ap_const_logic_1;\n    end else begin\n        ap_ready = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0_preg)\nbegin\n    if ((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm)) begin\n        ap_reg_ppiten_pp0_it0 = ap_start;\n    end else begin\n        ap_reg_ppiten_pp0_it0 = ap_reg_ppiten_pp0_it0_preg;\n    end\nend\n\nalways @ (ap_start or ap_reg_ppiten_pp0_it0)\nbegin\n    if (((ap_const_logic_0 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_0 == ap_start))) begin\n        ap_sig_pprstidle_pp0 = ap_const_logic_1;\n    end else begin\n        ap_sig_pprstidle_pp0 = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or ap_sig_bdd_131 or ap_sig_bdd_130)\nbegin\n    if (ap_sig_bdd_130) begin\n        if ((ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm)) begin\n            nfa_finals_buckets_address = ap_const_lv64_1;\n        end else if (ap_sig_bdd_131) begin\n            nfa_finals_buckets_address = ap_const_lv32_0;\n        end else begin\n            nfa_finals_buckets_address = 'bx;\n        end\n    end else begin\n        nfa_finals_buckets_address = 'bx;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_ce)\nbegin\n    if ((((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm) & (ap_const_logic_1 == ap_ce)) | ((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & (ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0))))) begin\n        nfa_finals_buckets_req_write = ap_const_logic_1;\n    end else begin\n        nfa_finals_buckets_req_write = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1 or ap_ce or nfa_finals_buckets_rsp_empty_n)\nbegin\n    if ((((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg2_fsm_2 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg1_fsm_1 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))))) begin\n        nfa_finals_buckets_rsp_read = ap_const_logic_1;\n    end else begin\n        nfa_finals_buckets_rsp_read = ap_const_logic_0;\n    end\nend\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1 or ap_ce or nfa_finals_buckets_rsp_empty_n or ap_sig_pprstidle_pp0)\nbegin\n    case (ap_CS_fsm)\n        ap_ST_pp0_stg0_fsm_0 : \n            if ((~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0))) & ~((ap_const_logic_0 == ap_reg_ppiten_pp0_it1) & (ap_const_logic_0 == ap_start)))) begin\n                ap_NS_fsm = ap_ST_pp0_stg1_fsm_1;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg0_fsm_0;\n            end\n        ap_ST_pp0_stg1_fsm_1 : \n            if ((~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) & ~(ap_const_logic_1 == ap_sig_pprstidle_pp0))) begin\n                ap_NS_fsm = ap_ST_pp0_stg2_fsm_2;\n            end else if ((~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) & (ap_const_logic_1 == ap_sig_pprstidle_pp0))) begin\n                ap_NS_fsm = ap_ST_pp0_stg0_fsm_0;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg1_fsm_1;\n            end\n        ap_ST_pp0_stg2_fsm_2 : \n            if (~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0)))) begin\n                ap_NS_fsm = ap_ST_pp0_stg3_fsm_3;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg2_fsm_2;\n            end\n        ap_ST_pp0_stg3_fsm_3 : \n            if ((ap_const_logic_1 == ap_ce)) begin\n                ap_NS_fsm = ap_ST_pp0_stg0_fsm_0;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg3_fsm_3;\n            end\n        default : \n            ap_NS_fsm = 'bx;\n    endcase\nend\nassign ap_return_0 = nfa_finals_buckets_read_reg_59;\nassign ap_return_1 = nfa_finals_buckets_datain;\n\nalways @ (ap_reg_ppiten_pp0_it0 or ap_ce)\nbegin\n    ap_sig_bdd_130 = ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce));\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0)\nbegin\n    ap_sig_bdd_131 = ((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0)));\nend\nassign nfa_finals_buckets_dataout = ap_const_lv32_0;\nassign nfa_finals_buckets_req_din = ap_const_logic_0;\nassign nfa_finals_buckets_size = ap_const_lv32_1;\n\n\nendmodule ",
        "module_name": "nfa_get_finals",
        "module_hash": "8db73dc5f029f067259e796d587e2c81",
        "dataset_index": 25518
      },
      "eth_clockgen_b28b194c": {
        "rtl_code": "\n\nmodule eth_clockgen(Clk, Reset, Divider, MdcEn, MdcEn_n, Mdc);\n\nparameter Tp=1;\n\ninput       Clk;              input       Reset;            input [7:0] Divider;          output      Mdc;              output      MdcEn;            output      MdcEn_n;          reg         Mdc;\nreg   [7:0] Counter;\n\nwire        CountEq0;\nwire  [7:0] CounterPreset;\nwire  [7:0] TempDivider;\n\n\nassign TempDivider[7:0]   = (Divider[7:0]<2)? 8'h02 : Divider[7:0]; assign CounterPreset[7:0] = (TempDivider[7:0]>>1) -1;               always @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    Counter[7:0] <= #Tp 8'h1;\n  else\n    begin\n      if(CountEq0)\n        begin\n          Counter[7:0] <= #Tp CounterPreset[7:0];\n        end\n      else\n        Counter[7:0] <= #Tp Counter - 8'h1;\n    end\nend\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    Mdc <= #Tp 1'b0;\n  else\n    begin\n      if(CountEq0)\n        Mdc <= #Tp ~Mdc;\n    end\nend\n\n\nassign CountEq0 = Counter == 8'h0;\nassign MdcEn = CountEq0 & ~Mdc;\nassign MdcEn_n = CountEq0 & Mdc;\n\nendmodule\n\n\n",
        "module_name": "eth_clockgen",
        "module_hash": "b28b194c6ea7b5a577b2510c1c97610f",
        "dataset_index": 22404
      },
      "dff_en_e376f30b": {
        "rtl_code": "module dff_en(input D, C, E, output Q);\n  reg Q;\n\n  always @(posedge C) begin\n    if (E) begin\n      Q <= D;\n    end\n  end\n\nendmodule",
        "module_name": "dff_en",
        "module_hash": "e376f30b5c028abfafb7b4af851ba70a",
        "dataset_index": 17514
      },
      "BRAM1_ba2f84e4": {
        "rtl_code": "module BRAM1(\n    input CLK,\n    input EN,\n    input WE,\n    input [ADDR_WIDTH-1:0] ADDR,\n    input [DATA_WIDTH-1:0] DI,\n    output [DATA_WIDTH-1:0] DO\n);\n\nparameter PIPELINED = 0;\nparameter ADDR_WIDTH = 1;\nparameter DATA_WIDTH = 1;\nparameter MEMSIZE = 1;\n\nreg [DATA_WIDTH-1:0] RAM [0:MEMSIZE-1];\nreg [DATA_WIDTH-1:0] DO_R;\nreg [DATA_WIDTH-1:0] DO_R2;\n\nalways @(posedge CLK) begin\n    if (EN) begin\n        if (WE) begin\n            RAM[ADDR] <= DI;\n            DO_R <= DI;\n        end else begin\n            DO_R <= RAM[ADDR];\n        end\n    end\n    DO_R2 <= DO_R;\nend\n\nassign DO = (PIPELINED) ? DO_R2 : DO_R;\n\nendmodule",
        "module_name": "BRAM1",
        "module_hash": "ba2f84e43bc2d0b9ef67b3d5c7733a85",
        "dataset_index": 5310
      },
      "shift_reg_3650de4e": {
        "rtl_code": "module shift_reg (\n  input clk,\n  input reset,\n  input load,\n  input [3:0] data_in,\n  output reg [3:0] shift_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      shift_out <= 4'b0;\n    end\n    else if (load) begin\n      shift_out <= data_in;\n    end\n    else begin\n      shift_out <= {shift_out[2:0], shift_out[3]};\n    end\n  end\n\nendmodule\n",
        "module_name": "shift_reg",
        "module_hash": "3650de4e1f9d3d36cc896e6302472588",
        "dataset_index": 2400
      },
      "macc_module_96e4eb70": {
        "rtl_code": "module macc_module(\n  input clk,\n  input reset,\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] out\n);\n\n  reg [31:0] accum; // register to hold accumulated value\n\n  always @(posedge clk) begin\n    if (reset) begin\n      accum <= 0;\n    end else begin\n      accum <= accum + (a * b);\n    end\n  end\n\n  assign out = accum;\n\nendmodule",
        "module_name": "macc_module",
        "module_hash": "96e4eb70cc55ed461992ac518cc3b175",
        "dataset_index": 1949
      },
      "binary_adder_c40e4a6f": {
        "rtl_code": "module binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C\n);\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    full_adder fa0(.A(A[0]), .B(B[0]), .C_in(1'b0), .S(sum[0]), .C_out(carry[1]));\n    full_adder fa1(.A(A[1]), .B(B[1]), .C_in(carry[1]), .S(sum[1]), .C_out(carry[2]));\n    full_adder fa2(.A(A[2]), .B(B[2]), .C_in(carry[2]), .S(sum[2]), .C_out(carry[3]));\n    full_adder fa3(.A(A[3]), .B(B[3]), .C_in(carry[3]), .S(sum[3]), .C_out(C));\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder(\n    input A,\n    input B,\n    input C_in,\n    output S,\n    output C_out\n);\n\n    assign {C_out, S} = A + B + C_in;\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "c40e4a6f6694eaaa0d1a059b8ea58c2c",
        "dataset_index": 5232
      },
      "select_bits #_f1f3e897": {
        "rtl_code": "module select_bits #(\n    parameter WIDTH = 16\n)(\n    input signed [WIDTH-1:0] in,\n    output reg [9:0] out\n);\n\n    always @(*) begin\n        if (in[0] == 1'b0) // even\n            out = in[9:0];\n        else // odd\n            out = in[WIDTH-1:WIDTH-10];\n    end\n\nendmodule",
        "module_name": "select_bits #",
        "module_hash": "f1f3e89745dfe57fd85d6d2553bf6d00",
        "dataset_index": 8360
      },
      "mux_4to1_cd286f1a": {
        "rtl_code": "module mux_4to1 (\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output Y\n);\n\n    wire sel1, sel2;\n\n    // First level of selection\n    assign sel1 = (S1 == 0) ? S0 : ~S0;\n\n    // Second level of selection\n    assign sel2 = (S1 == 0) ? A : B;\n    assign Y = (sel1 & sel2) | (~sel1 & ((S1 == 0) ? C : D));\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "cd286f1a200fc099289ebcc0cfacd22c",
        "dataset_index": 2159
      },
      "my__00645347": {
        "rtl_code": "module my_module (\n    X,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n\n    assign X = ((A1 & ~A2) | (A2 & ~A1 & A3 & ~B1) | (~A1 & ~A2 & ~A3 & B1)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "006453470462859ca8d14a51f017685b",
        "dataset_index": 19201
      },
      "sky130_fd_sc_lp__o2111ai_e71debc7": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o2111ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1             );\n    nand nand0 (nand0_out_Y, C1, B1, D1, or0_out);\n    buf  buf0  (Y          , nand0_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o2111ai",
        "module_hash": "e71debc78efb6d753f1d089185ec5a14",
        "dataset_index": 13747
      },
      "sky130_fd_sc_hd__fahcon_044f8233": {
        "rtl_code": "module sky130_fd_sc_hd__fahcon (\n    input A,\n    input B,\n    input CI,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output COUT_N,\n    output SUM\n);\n\nwire w1, w2, w3;\n\nassign w1 = A ^ B;\nassign SUM = w1 ^ CI;\nassign w2 = A & B;\nassign w3 = CI & w1;\nassign COUT_N = w2 | w3;\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__fahcon",
        "module_hash": "044f8233527c2c366c8bdf83ca920893",
        "dataset_index": 14293
      },
      "counter_3d891443": {
        "rtl_code": "module counter(\n  input rst, clk, enable,\n  input [31:0] inc_value,\n  output reg [31:0] count\n);\n\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= count + inc_value;\n      if (count >= 2**32 - inc_value) begin\n        count <= 0;\n      end\n    end\n  end\n  \nendmodule",
        "module_name": "counter",
        "module_hash": "3d89144314218c0f550f2f223e03d039",
        "dataset_index": 3312
      },
      "binary_to_bcd_d8676919": {
        "rtl_code": "\nmodule binary_to_bcd(clk, reset, in, out1, out2, out3, out4, clear);\n    input clk, reset, clear;\n    input [7:0] in;\n    output reg [3:0] out1, out2, out3, out4;\n\n    reg [23:0] temp;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            temp <= 0;\n            out1 <= 0;\n            out2 <= 0;\n            out3 <= 0;\n            out4 <= 0;\n        end\n        else begin\n            if (clear) begin\n                out1 <= 0;\n                out2 <= 0;\n                out3 <= 0;\n                out4 <= 0;\n                temp <= 0;\n            end\n            else begin\n                temp <= {temp[19:0], in};\n                if (temp >= 24'd10000) begin\n                    temp <= temp + 3'd3;\n                end\n                if (temp >= 24'd100000) begin\n                    temp <= temp + 3'd3;\n                end\n                if (temp >= 24'd1000000) begin\n                    temp <= temp + 3'd3;\n                end\n                if (temp >= 24'd10000000) begin\n                    temp <= temp + 3'd3;\n                end\n                out1 <= temp[3:0];\n                out2 <= temp[7:4];\n                out3 <= temp[11:8];\n                out4 <= temp[15:12];\n            end\n        end\n    end\nendmodule",
        "module_name": "binary_to_bcd",
        "module_hash": "d86769194ef5c0d20cd525e293ae5732",
        "dataset_index": 5021
      },
      "addition_module_d8db8a87": {
        "rtl_code": "module addition_module\n  (\n   input   [1:0] i,\n   input   [1:0] a,\n   output  [1:0] o\n   );\n   assign o = i + a;\nendmodule",
        "module_name": "addition_module",
        "module_hash": "d8db8a8721b3ea3276634ec7ef0478d5",
        "dataset_index": 9959
      },
      "majority_circuit_4ae782e7": {
        "rtl_code": "module majority_circuit (\n  input a,\n  input b,\n  input c,\n  output reg out\n);\n\n  always @ (a, b, c) begin\n    out = (a & b) | (b & c) | (c & a);\n  end\n  \nendmodule\n",
        "module_name": "majority_circuit",
        "module_hash": "4ae782e79631b7f221390925cbebed20",
        "dataset_index": 15825
      },
      "sky130_fd_sc_ls__and4_3b82f347": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__and4",
        "module_hash": "3b82f3472c4bcbc12b8e6a18a577ad38",
        "dataset_index": 19807
      },
      "mux2to1_b19fc623": {
        "rtl_code": "module mux2to1 (Y, A, B, S);\n    output Y;\n    input A, B, S;\n    assign Y = (S == 1'b0) ? A : B;\nendmodule\n\nmodule mux4to1 (Y, D0, D1, D2, D3, S0, S1);\n    output Y;\n    input D0, D1, D2, D3, S0, S1;\n    wire w1, w2, w3;\n    mux2to1 mux1 (.Y(w1), .A(D0), .B(D1), .S(S1));\n    mux2to1 mux2 (.Y(w2), .A(D2), .B(D3), .S(S1));\n    mux2to1 mux3 (.Y(w3), .A(w1), .B(w2), .S(S0));\n    assign Y = w3;\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "b19fc623692daaedb020747c4a1bd7e1",
        "dataset_index": 21188
      },
      "sky130_fd_sc_ls__a211o_b9a08d7f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a211o (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A1, A2          );\n    or  or0  (or0_out_X, and0_out, C1, B1);\n    buf buf0 (X        , or0_out_X       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a211o",
        "module_hash": "b9a08d7f9095239b1ac9761e210f7a81",
        "dataset_index": 22933
      },
      "counter_8200ddc7": {
        "rtl_code": "module counter (\n    input clk,\n    input reset,\n    output reg [7:0] counter,\n    output reg [7:0] waveforms,\n    output reg interrupt_event\n);\n\nreg [3:0] state;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        counter <= 8'b0;\n        waveforms <= 8'b0;\n        interrupt_event <= 1'b0;\n        state <= 4'b0000;\n    end else begin\n        counter <= counter + 1;\n        case (state)\n            4'b0000: begin // count < 128\n                waveforms <= {8{counter[6]}};\n                if (counter == 127) begin\n                    state <= 4'b0001;\n                end\n            end\n            4'b0001: begin // 128 <= count <= 191\n                waveforms <= counter[2:0] << 5;\n                if (counter == 191) begin\n                    state <= 4'b0010;\n                end\n            end\n            4'b0010: begin // count >= 192\n                waveforms <= {6{counter[6]}};\n                if (counter == 255) begin\n                    interrupt_event <= 1'b1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "8200ddc75e18550795c13f4fb355a23e",
        "dataset_index": 467
      },
      "calculator_f0b170a3": {
        "rtl_code": "module calculator(\n  input clk,\n  input rst,\n  input [1:0] op,\n  input [7:0] num1,\n  input [7:0] num2,\n  output [7:0] result,\n  output valid);\n\n  reg [7:0] result_reg;\n  reg valid_reg;\n  \n  always@(posedge clk) begin\n    if(rst) begin\n      result_reg <= 8'b0;\n      valid_reg <= 1'b0;\n    end else begin\n      case(op)\n        2'b00: result_reg <= num1 + num2;\n        2'b01: result_reg <= num1 - num2;\n        2'b10: result_reg <= num1 * num2;\n        2'b11: result_reg <= num1 / num2;\n      endcase\n      \n      valid_reg <= 1'b1;\n    end\n  end\n  \n  assign result = result_reg;\n  assign valid = valid_reg;\n  \nendmodule",
        "module_name": "calculator",
        "module_hash": "f0b170a30b4e9e005ff3fc3259808970",
        "dataset_index": 3179
      },
      "averager_counter_1d02cee3": {
        "rtl_code": "module averager_counter (\n  input        restart,\n  input        clken,\n  input [31:0] count_max,\n  input        clk,\n  input        avg_on,\n  output       clr_fback,\n  output       ready,\n  output       wen,\n  output       avg_on_out,\n  output [31:0] n_avg,\n  output [31:0] address\n);\n\n  parameter N = 4; // number of values to average (must be a power of 2)\n  parameter WIDTH = $clog2(N); // number of bits needed to represent N\n  parameter AVG_WIDTH = 2*WIDTH + $clog2(32); // number of bits needed to represent the average\n\n  reg [WIDTH-1:0]  index; // index of the current value in the averaging buffer\n  reg [31:0]       sum;   // sum of the last N values of the counter\n  reg [AVG_WIDTH-1:0] avg; // current average value\n  \n  reg [31:0] count; // current value of the counter\n  reg [31:0] next_count; // next value of the counter (after incrementing)\n  reg [31:0] max_count; // maximum value of the counter\n  \n  reg avg_on_reg; // register to store the value of avg_on\n  reg [WIDTH-1:0]  wen_cnt; // counter to track the number of values written to the averaging buffer\n  wire wen_int; // internal signal to indicate when the averaging buffer is ready to receive a new value\n  wire ready_int; // internal signal to indicate when the averaging function has calculated a new average value\n  \n  assign clr_fback = (count == count_max); // clear the counter when it reaches its maximum value\n  assign address = count; // output the current value of the counter\n  \n  // increment the counter on each clock cycle\n  always @(posedge clk) begin\n    if (restart) begin\n      count <= 0;\n    end else if (clken) begin\n      if (count == count_max) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n  \n  // calculate the next value of the counter (after incrementing)\n  always @(*) begin\n    if (count == count_max) begin\n      next_count = 0;\n    end else begin\n      next_count = count + 1;\n    end\n  end\n  \n  // calculate the maximum value of the counter\n  always @(*) begin\n    max_count = count_max;\n  end\n  \n  // enable or disable the averaging function\n  always @(posedge clk) begin\n    if (restart) begin\n      avg_on_reg <= 0;\n    end else if (clken) begin\n      avg_on_reg <= avg_on;\n    end\n  end\n  \n  // calculate the sum of the last N values of the counter\n  always @(posedge clk) begin\n    if (restart) begin\n      sum <= 0;\n    end else if (clken) begin\n      if (count == count_max) begin\n        sum <= 0;\n      end else begin\n        sum <= sum + count - (wen_int ? avg[N-1] : 0);\n      end\n    end\n  end\n  \n  // calculate the current average value\n  always @(posedge clk) begin\n    if (restart) begin\n      avg <= 0;\n    end else if (clken) begin\n      if (count == count_max) begin\n        avg <= 0;\n      end else if (wen_int) begin\n        avg <= {sum[N-1:0], wen_cnt, count};\n      end\n    end\n  end\n  \n  // write the current value of the counter to the averaging buffer\n  always @(posedge clk) begin\n    if (restart) begin\n      index <= 0;\n      wen_cnt <= 0;\n    end else if (clken) begin\n      if (wen_int) begin\n        index <= index + 1;\n        wen_cnt <= wen_cnt + 1;\n      end\n    end\n  end\n  \n  // check if the averaging buffer is ready to receive a new value\n  assign wen_int = (wen_cnt < N);\n  \n  // check if the averaging function has calculated a new average value\n  assign ready_int = (wen_cnt == N);\n  \n  // output the current average value\n  assign n_avg = avg[N-1:0];\n  \n  // output the control signals\n  assign wen = wen_int && avg_on_reg;\n  assign ready = ready_int;\n  assign avg_on_out = avg_on_reg;\n  \nendmodule",
        "module_name": "averager_counter",
        "module_hash": "1d02cee3185302d3451e9203ec4c7827",
        "dataset_index": 2101
      },
      "async_fifo_align_64in_out_rd_handshaking_flags_a71f5a3e": {
        "rtl_code": "module async_fifo_align_64in_out_rd_handshaking_flags\n   (valid,\n    ram_valid_i,\n    clk,\n    Q);\n  output valid;\n  input ram_valid_i;\n  input clk;\n  input [0:0]Q;\n\n  reg [0:0] Q_reg;\n  reg [0:0] ram_valid_d1_reg;\n  wire [0:0] Q;\n  wire clk;\n  wire ram_valid_i;\n  wire valid;\n\n  always @(posedge clk) begin\n    Q_reg <= Q;\n    ram_valid_d1_reg <= ram_valid_i;\n  end\n\n  assign valid = (Q_reg && ram_valid_d1_reg);\n\nendmodule",
        "module_name": "async_fifo_align_64in_out_rd_handshaking_flags",
        "module_hash": "a71f5a3e129d479785eefa59da3d6b83",
        "dataset_index": 12707
      },
      "avalon_to_wb_bridge #_ddd41088": {
        "rtl_code": "\n\nmodule avalon_to_wb_bridge #(\n\tparameter DW = 32,\tparameter AW = 32\t)(\n\tinput \t\t  clk,\n\tinput \t\t  rst,\n\tinput [AW-1:0] \t  avm_address_i,\n\tinput [DW/8-1:0]  avm_byteenable_i,\n\tinput \t\t  avm_read_i,\n\toutput [DW-1:0]   avm_readdata_o,\n\tinput [7:0] \t  avm_burstcount_i,\n\tinput \t\t  avm_write_i,\n\tinput [DW-1:0] \t  avm_writedata_i,\n\toutput \t\t  avm_waitrequest_o,\n\toutput \t\t  avm_readdatavalid_o,\n\toutput [AW-1:0]   wbm_adr_o,\n\toutput [DW-1:0]   wbm_dat_o,\n\toutput [DW/8-1:0] wbm_sel_o,\n\toutput \t\t  wbm_we_o,\n\toutput \t\t  wbm_cyc_o,\n\toutput \t\t  wbm_stb_o,\n\toutput [2:0] \t  wbm_cti_o,\n\toutput [1:0] \t  wbm_bte_o,\n\tinput [DW-1:0] \t  wbm_dat_i,\n\tinput \t\t  wbm_ack_i,\n\tinput \t\t  wbm_err_i,\n\tinput \t\t  wbm_rty_i\n);\n\nreg read_access;\n\nalways @(posedge clk)\n\tif (rst)\n\t\tread_access <= 0;\n\telse if (wbm_ack_i | wbm_err_i)\n\t\tread_access <= 0;\n\telse if (avm_read_i)\n\t\tread_access <= 1;\n\nreg readdatavalid;\nreg [DW-1:0] readdata;\nalways @(posedge clk) begin\n\treaddatavalid <= (wbm_ack_i | wbm_err_i) & read_access;\n\treaddata <= wbm_dat_i;\nend\n\nassign wbm_adr_o = avm_address_i;\nassign wbm_dat_o = avm_writedata_i;\nassign wbm_sel_o =  avm_byteenable_i;\nassign wbm_we_o = avm_write_i;\nassign wbm_cyc_o = read_access | avm_write_i;\nassign wbm_stb_o = read_access | avm_write_i;\nassign wbm_cti_o = 3'b111; assign wbm_bte_o = 2'b00;\nassign avm_waitrequest_o = !(wbm_ack_i | wbm_err_i);\nassign avm_readdatavalid_o = readdatavalid;\nassign avm_readdata_o = readdata;\n\nendmodule\n",
        "module_name": "avalon_to_wb_bridge #",
        "module_hash": "ddd4108809874fdd79f007cf0024cae2",
        "dataset_index": 24939
      },
      "hpdmc_mgmt #_eab536be": {
        "rtl_code": "\n\nmodule hpdmc_mgmt #(\n\tparameter sdram_depth = 26,\n\tparameter sdram_columndepth = 9,\n\tparameter sdram_addrdepth = sdram_depth-1-1-(sdram_columndepth+2)+1\n) (\n\tinput sys_clk,\n\tinput sdram_rst,\n\t\n\tinput [2:0] tim_rp,\n\tinput [2:0] tim_rcd,\n\tinput [10:0] tim_refi,\n\tinput [3:0] tim_rfc,\n\t\n\tinput stb,\n\tinput we,\n\tinput [sdram_depth-1-1:0] address, \n\toutput reg ack,\n\t\n\toutput reg read,\n\toutput reg write,\n\toutput [3:0] concerned_bank,\n\tinput read_safe,\n\tinput write_safe,\n\tinput [3:0] precharge_safe,\n\t\n\toutput sdram_cs_n,\n\toutput sdram_we_n,\n\toutput sdram_cas_n,\n\toutput sdram_ras_n,\n\toutput [sdram_addrdepth-1:0] sdram_adr,\n\toutput [1:0] sdram_ba\n);\n\n\n\nlocalparam rowdepth = sdram_depth-1-1-(sdram_columndepth+2)+1;\nlocalparam sdram_addrdepth_o1024 = sdram_addrdepth-11;\n\nwire [sdram_depth-1-1:0] address16 = address;\n\nwire [sdram_columndepth-1:0] col_address = address16[sdram_columndepth-1:0];\nwire [1:0] bank_address = address16[sdram_columndepth+1:sdram_columndepth];\nwire [rowdepth-1:0] row_address = address16[sdram_depth-1-1:sdram_columndepth+2];\n\nreg [3:0] bank_address_onehot;\nalways @(*) begin\n\tcase(bank_address)\n\t\t2'b00: bank_address_onehot <= 4'b0001;\n\t\t2'b01: bank_address_onehot <= 4'b0010;\n\t\t2'b10: bank_address_onehot <= 4'b0100;\n\t\t2'b11: bank_address_onehot <= 4'b1000;\n\tendcase\nend\n\n\nreg [3:0] has_openrow;\nreg [rowdepth-1:0] openrows[0:3];\nreg [3:0] track_close;\nreg [3:0] track_open;\n\nalways @(posedge sys_clk) begin\n\tif(sdram_rst) begin\n\t\thas_openrow <= 4'h0;\n\tend else begin\n\t\thas_openrow <= (has_openrow | track_open) & ~track_close;\n\t\t\n\t\tif(track_open[0]) openrows[0] <= row_address;\n\t\tif(track_open[1]) openrows[1] <= row_address;\n\t\tif(track_open[2]) openrows[2] <= row_address;\n \t\tif(track_open[3]) openrows[3] <= row_address;\n\tend\nend\n\n\nassign concerned_bank = bank_address_onehot;\nwire current_precharge_safe =\n\t (precharge_safe[0] | ~bank_address_onehot[0])\n\t&(precharge_safe[1] | ~bank_address_onehot[1])\n\t&(precharge_safe[2] | ~bank_address_onehot[2])\n\t&(precharge_safe[3] | ~bank_address_onehot[3]);\n\n\n\nwire bank_open = has_openrow[bank_address];\nwire page_hit = bank_open & (openrows[bank_address] == row_address);\n\n\nreg sdram_adr_loadrow;\nreg sdram_adr_loadcol;\nreg sdram_adr_loadA10;\nassign sdram_adr =\n\t ({sdram_addrdepth{sdram_adr_loadrow}}\t& row_address)\n\t|({sdram_addrdepth{sdram_adr_loadcol}}\t& col_address)\n\t|({sdram_addrdepth{sdram_adr_loadA10}}\n     & { {sdram_addrdepth_o1024{1'b0}} , 11'd1024});\n\nassign sdram_ba = bank_address;\n\n\nreg sdram_cs;\nreg sdram_we;\nreg sdram_cas;\nreg sdram_ras;\nassign sdram_cs_n = ~sdram_cs;\nassign sdram_we_n = ~sdram_we;\nassign sdram_cas_n = ~sdram_cas;\nassign sdram_ras_n = ~sdram_ras;\n\n\n\n\nreg [2:0] precharge_counter;\nreg reload_precharge_counter;\nwire precharge_done = (precharge_counter == 3'd0);\nalways @(posedge sys_clk) begin\n\tif(reload_precharge_counter)\n\t\tprecharge_counter <= tim_rp;\n\telse if(~precharge_done)\n\t\tprecharge_counter <= precharge_counter - 3'd1;\nend\n\n\nreg [2:0] activate_counter;\nreg reload_activate_counter;\nwire activate_done = (activate_counter == 3'd0);\nalways @(posedge sys_clk) begin\n\tif(reload_activate_counter)\n\t\tactivate_counter <= tim_rcd;\n\telse if(~activate_done)\n\t\tactivate_counter <= activate_counter - 3'd1;\nend\n\n\nreg [10:0] refresh_counter;\nreg reload_refresh_counter;\nwire must_refresh = refresh_counter == 11'd0;\nalways @(posedge sys_clk) begin\n\tif(sdram_rst)\n\t\trefresh_counter <= 11'd0;\n\telse begin\n\t\tif(reload_refresh_counter)\n\t\t\trefresh_counter <= tim_refi;\n\t\telse if(~must_refresh)\n\t\t\trefresh_counter <= refresh_counter - 11'd1;\n\tend\nend\n\n\nreg [3:0] autorefresh_counter;\nreg reload_autorefresh_counter;\nwire autorefresh_done = (autorefresh_counter == 4'd0);\nalways @(posedge sys_clk) begin\n\tif(reload_autorefresh_counter)\n\t\tautorefresh_counter <= tim_rfc;\n\telse if(~autorefresh_done)\n\t\tautorefresh_counter <= autorefresh_counter - 4'd1;\nend\n\n\n\nreg [3:0] state;\nreg [3:0] next_state;\n\n  localparam [3:0]\n    IDLE\t\t\t= 4'd0,\n    ACTIVATE\t\t= 4'd1,\n    READ\t\t\t= 4'd2,\n    WRITE\t\t\t= 4'd3,\n    PRECHARGEALL\t\t= 4'd4,\n    AUTOREFRESH\t\t= 4'd5,\n    AUTOREFRESH_WAIT\t= 4'd6;\n\nalways @(posedge sys_clk) begin\n\tif(sdram_rst)\n\t\tstate <= IDLE;\n\telse begin\n\t\tstate <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tnext_state = state;\n\t\n\treload_precharge_counter = 1'b0;\n\treload_activate_counter = 1'b0;\n\treload_refresh_counter = 1'b0;\n\treload_autorefresh_counter = 1'b0;\n\t\n\tsdram_cs = 1'b0;\n\tsdram_we = 1'b0;\n\tsdram_cas = 1'b0;\n\tsdram_ras = 1'b0;\n\t\n\tsdram_adr_loadrow = 1'b0;\n\tsdram_adr_loadcol = 1'b0;\n\tsdram_adr_loadA10 = 1'b0;\n\t\n\ttrack_close = 4'b0000;\n\ttrack_open = 4'b0000;\n\t\n\tread = 1'b0;\n\twrite = 1'b0;\n\t\n\tack = 1'b0;\n\t\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tif(must_refresh)\n\t\t\t\tnext_state = PRECHARGEALL;\n\t\t\telse begin\n\t\t\t\tif(stb) begin\n\t\t\t\t\tif(page_hit) begin\n\t\t\t\t\t\tif(we) begin\n\t\t\t\t\t\t\tif(write_safe) begin\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\t\t\t\tsdram_we = 1'b1;\n\t\t\t\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twrite = 1'b1;\n\t\t\t\t\t\t\t\tack = 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tif(read_safe) begin\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\t\t\t\tsdram_we = 1'b0;\n\t\t\t\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tread = 1'b1;\n\t\t\t\t\t\t\t\tack = 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tif(bank_open) begin\n\t\t\t\t\t\t\tif(current_precharge_safe) begin\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\t\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\t\t\t\t\tsdram_we = 1'b1;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\ttrack_close = bank_address_onehot;\n\t\t\t\t\t\t\t\treload_precharge_counter = 1'b1;\n\t\t\t\t\t\t\t\tnext_state = ACTIVATE;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\t\t\t\tsdram_we = 1'b0;\n\t\t\t\t\t\t\tsdram_adr_loadrow = 1'b1;\n\t\t\t\t\n\t\t\t\t\t\t\ttrack_open = bank_address_onehot;\n\t\t\t\t\t\t\treload_activate_counter = 1'b1;\n\t\t\t\t\t\t\tif(we)\n\t\t\t\t\t\t\t\tnext_state = WRITE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = READ;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tACTIVATE: begin\n\t\t\tif(precharge_done) begin\n\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\tsdram_we = 1'b0;\n\t\t\t\tsdram_adr_loadrow = 1'b1;\n\t\t\t\t\n\t\t\t\ttrack_open = bank_address_onehot;\n\t\t\t\treload_activate_counter = 1'b1;\n\t\t\t\tif(we)\n\t\t\t\t\tnext_state = WRITE;\n\t\t\t\telse\n\t\t\t\t\tnext_state = READ;\n\t\t\tend\n\t\tend\n\t\tREAD: begin\n\t\t\tif(activate_done) begin\n\t\t\t\tif(read_safe) begin\n\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\tsdram_we = 1'b0;\n\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\n\t\t\t\t\tread = 1'b1;\n\t\t\t\t\tack = 1'b1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tWRITE: begin\n\t\t\tif(activate_done) begin\n\t\t\t\tif(write_safe) begin\n\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\tsdram_we = 1'b1;\n\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\n\t\t\t\t\twrite = 1'b1;\n\t\t\t\t\tack = 1'b1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tPRECHARGEALL: begin\n\t\t\tif(precharge_safe == 4'b1111) begin\n\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\tsdram_we = 1'b1;\n\t\t\t\tsdram_adr_loadA10 = 1'b1;\n\t\n\t\t\t\treload_precharge_counter = 1'b1;\n\t\t\t\t\n\t\t\t\ttrack_close = 4'b1111;\n\t\t\t\t\n\t\t\t\tnext_state = AUTOREFRESH;\n\t\t\tend\n\t\tend\n\t\tAUTOREFRESH: begin\n\t\t\tif(precharge_done) begin\n\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\tsdram_we = 1'b0;\n\t\t\t\treload_refresh_counter = 1'b1;\n\t\t\t\treload_autorefresh_counter = 1'b1;\n\t\t\t\tnext_state = AUTOREFRESH_WAIT;\n\t\t\tend\n\t\tend\n\t\tAUTOREFRESH_WAIT: begin\n\t\t\tif(autorefresh_done)\n\t\t\t\tnext_state = IDLE;\n\t\tend\n\t\t\n\tendcase\nend\n\nendmodule\n",
        "module_name": "hpdmc_mgmt #",
        "module_hash": "eab536be416e44e2c679d54dfa33d283",
        "dataset_index": 24803
      },
      "sky130_fd_sc_h__a2bb2o_1_15910329": {
        "rtl_code": "\nmodule sky130_fd_sc_h__a2bb2o_1 (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Implement AND gate functionality\n    assign X = (A1_N & A2_N) | (B1 & B2);\n\nendmodule\n\nmodule my_AND_gate (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Instantiate sky130_fd_sc_h__a2bb2o_1 module\n    sky130_fd_sc_h__a2bb2o_1 AND_gate (\n        .X(X),\n        .A1_N(A1_N),\n        .A2_N(A2_N),\n        .B1(B1),\n        .B2(B2)\n    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_h__a2bb2o_1",
        "module_hash": "15910329ad07d63b0daa15a352b76c1f",
        "dataset_index": 14556
      },
      "sfifo_nto8_320107d2": {
        "rtl_code": "module sfifo_nto8 (\n        clk         ,   // clock\n        ce          ,   // clock enable\n        nrst        ,   // asyn reset\n        reset       ,   // sync reset\n        din         ,   // data input\n        dout        ,   // data output\n        rd          ,   // read\n        wr          ,   // write\n        full        ,   // fifo full\n        empty       ,   // fifo empty\n        nsin        ,   // num of shift in (bits)\n        nsout           // num of shift out (bits)\n        ) ;\n        \ninput           clk ;\ninput           ce ;\ninput           nrst ;\ninput           reset ;\ninput   [7:0]   din ;\noutput  [7:0]   dout ;\ninput           rd ;\ninput           wr ;\noutput          full ;\noutput          empty ;\ninput   [3:0]   nsin ;\ninput   [3:0]   nsout ;\n\nreg     [23:0]  buffer ;        // 24-bit buffer\nreg     [5:0]   cnt ;           // counter to record num of bits loaded into buffer\nwire    [31:0]  shift_out ;\nwire    [31:0]  shift_in ;\nwire    [5:0]   space_left ;\n\nassign dout = shift_out [31:24] ;\nassign full = (cnt + nsin) > 24 ;\nassign empty = cnt < nsout ;\n\nalways @ (posedge clk or negedge nrst)\n  if (~nrst)\n    cnt <= 0 ;\n  else if (ce)\n  begin\n    if (reset)\n      cnt <= 0 ;\n    else\n    begin\n      if (wr & rd)\n        cnt <= cnt + nsin - nsout ;\n      if (wr & ~rd)\n        cnt <= cnt + nsin ;\n      if (~wr & rd)\n        cnt <= cnt - nsout ;\n    end\n  end\n  \nassign shift_out = {8'h0, buffer} << nsout ;  \nassign space_left = rd ? 24 -cnt + nsout : 24 -cnt ;  \nassign shift_in = {24'h0, din} << space_left ;\n  \nalways @ (posedge clk or negedge nrst)\n  if (~nrst)\n    buffer <= 0 ;\n  else if (ce)\n  begin\n    if (reset)\n      buffer <= 0 ;\n    else\n    begin\n      if (wr & rd)\n        buffer <= shift_out [23:0] | shift_in [31:8] ;\n      if (wr & ~rd)\n        buffer <= buffer | shift_in [31:8] ;\n      if (~wr & rd)\n        buffer <= shift_out [23:0] ;\n    end\n  end  \n\nendmodule",
        "module_name": "sfifo_nto8",
        "module_hash": "320107d29e7415ba525ebca3794c3770",
        "dataset_index": 20346
      },
      "counter_0798e8fc": {
        "rtl_code": "module counter(\n    input clk,\n    input reset,\n    input up_down,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0;\n        end else begin\n            if (up_down) begin\n                out <= out + 4'b1;\n            end else begin\n                out <= out - 4'b1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "0798e8fc2aa6636224da37a34b0c9c0d",
        "dataset_index": 12875
      },
      "sky130_fd_sc_ls__o2111ai_f8f2ab01": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o2111ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1             );\n    nand nand0 (nand0_out_Y, C1, B1, D1, or0_out);\n    buf  buf0  (Y          , nand0_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o2111ai",
        "module_hash": "f8f2ab01d942e78baae70694c8c1c4b3",
        "dataset_index": 22035
      },
      "calculator_d58a50b8": {
        "rtl_code": "module calculator(input clk, input [7:0] a, input [7:0] b, input [1:0] op, output [7:0] result);\n  reg [7:0] temp;\n  \n  always @ (posedge clk) begin\n    case(op)\n      2'b00: temp <= a + b; // Addition\n      2'b01: temp <= a - b; // Subtraction\n      2'b10: temp <= a * b; // Multiplication\n      2'b11: temp <= a / b; // Division\n      default: temp <= 8'b0; // Default value\n    endcase\n  end\n  \n  assign result = temp;\nendmodule",
        "module_name": "calculator",
        "module_hash": "d58a50b8ce5be4d7273345eb6c4dbb18",
        "dataset_index": 10617
      },
      "sram_byte_en_824efe13": {
        "rtl_code": "module sram_byte_en\n#(\nparameter DATA_WIDTH    = 128,\nparameter ADDRESS_WIDTH = 7\n)\n(\n    input                           i_clk,\n    input      [DATA_WIDTH-1:0]     i_write_data,\n    input                           i_write_enable,\n    input      [ADDRESS_WIDTH-1:0]  i_address,\n    input      [DATA_WIDTH/8-1:0]   i_byte_enable,\n    output reg [DATA_WIDTH-1:0]     o_read_data\n);\n\n    reg [DATA_WIDTH-1:0]   mem  [0:2**ADDRESS_WIDTH-1];\n    integer i;\n\n    always @(posedge i_clk) begin\n        // read\n        o_read_data <= i_write_enable ? {DATA_WIDTH{1'd0}} : mem[i_address];\n\n        // write\n        if (i_write_enable) begin\n            for (i=0; i<DATA_WIDTH/8; i=i+1) begin\n                mem[i_address][i*8+0] <= i_byte_enable[i] ? i_write_data[i*8+0] : mem[i_address][i*8+0] ;\n                mem[i_address][i*8+1] <= i_byte_enable[i] ? i_write_data[i*8+1] : mem[i_address][i*8+1] ;\n                mem[i_address][i*8+2] <= i_byte_enable[i] ? i_write_data[i*8+2] : mem[i_address][i*8+2] ;\n                mem[i_address][i*8+3] <= i_byte_enable[i] ? i_write_data[i*8+3] : mem[i_address][i*8+3] ;\n                mem[i_address][i*8+4] <= i_byte_enable[i] ? i_write_data[i*8+4] : mem[i_address][i*8+4] ;\n                mem[i_address][i*8+5] <= i_byte_enable[i] ? i_write_data[i*8+5] : mem[i_address][i*8+5] ;\n                mem[i_address][i*8+6] <= i_byte_enable[i] ? i_write_data[i*8+6] : mem[i_address][i*8+6] ;\n                mem[i_address][i*8+7] <= i_byte_enable[i] ? i_write_data[i*8+7] : mem[i_address][i*8+7] ;\n            end\n        end\n    end\nendmodule",
        "module_name": "sram_byte_en",
        "module_hash": "824efe13e4b5f88ca111009bfa6214c1",
        "dataset_index": 10340
      },
      "top__83ed03c4": {
        "rtl_code": "module top_module (\n    input clk,\n    input [7:0] d,\n    input a,\n    input b,\n    output [7:0] q\n);\n\n    // XOR gate\n    wire xor_out;\n    assign xor_out = a ^ b;\n\n    // 8-bit shift register\n    reg [7:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[6:0], d};\n    end\n\n    // Additive functional module\n    assign q = shift_reg + xor_out;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "83ed03c4844385bccdc63b2b69eb025a",
        "dataset_index": 3382
      },
      "binary_counter_1c8455dd": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 4'b0;\n    end else if (count == 4'b1111) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "1c8455dd66c573a21402af49c659473c",
        "dataset_index": 3797
      },
      "RCB_FRL_count_to_128_95cd1a8c": {
        "rtl_code": "\n\nmodule RCB_FRL_count_to_128(clk, rst, count, ud, counter_value);\n\ninput clk, rst, count, ud;\noutput [6:0] counter_value;\n\nwire [6:0] counter_value_preserver;\nreg [6:0] counter_value;\n\nalways@(posedge clk or posedge rst)\nbegin\nif(rst == 1'b1)\n counter_value = 7'h00;\nelse\n begin\n  case({count,ud})\n   2'b00: counter_value = 7'h00;\n   2'b01: counter_value = counter_value_preserver;\n   2'b10: counter_value = counter_value_preserver - 1;\n   2'b11: counter_value = counter_value_preserver + 1;\n   default: counter_value = 7'h00;\n  endcase\n end\nend\n\nassign counter_value_preserver = counter_value;\n\nendmodule\t\n",
        "module_name": "RCB_FRL_count_to_128",
        "module_hash": "95cd1a8cb33bf7f852f1e076c9277f09",
        "dataset_index": 25499
      },
      "top__16c541b2": {
        "rtl_code": "module top_module (\n    input clk,\n    input [255:0] in0,\n    input [7:0] sel0,\n    input [255:0] in1,\n    input [7:0] sel1,\n    input select,\n    output [7:0] sum\n);\n\nreg [255:0] mux_in;\nreg [7:0] mux_sel;\nwire mux_out0, mux_out1;\n\nalways @(posedge clk) begin\n    if (select) begin\n        mux_in <= in1;\n        mux_sel <= sel1;\n    end else begin\n        mux_in <= in0;\n        mux_sel <= sel0;\n    end\nend\n\nmux256to1 mux0 (.in(mux_in), .sel(mux_sel), .out(mux_out0));\nmux256to1 mux1 (.in(in1), .sel(sel1), .out(mux_out1));\n\nreg [3:0] adder_in0, adder_in1;\nalways @(posedge clk) begin\n    adder_in0 <= {4{mux_out0}};\n    adder_in1 <= {4{mux_out1}};\nend\n\nadder4bit adder (.a(adder_in0), .b(adder_in1), .sum(sum));\n\nendmodule\n\nmodule mux256to1 (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\nassign out = in[sel];\n\nendmodule\n\nmodule adder4bit (\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] sum\n);\n\nwire [4:0] tmp_sum;\n\nassign tmp_sum = a + b;\nassign sum = {tmp_sum[4], tmp_sum[3:0], 3'b0};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "16c541b2d8593f0d6db09dcbe777e121",
        "dataset_index": 7374
      },
      "PGM_c9bb4a03": {
        "rtl_code": "module PGM(\n\tinput CLK, RESET, IN_VALID, BUTTON,\n\tinput [1:0] MORE,\n\toutput reg OUT_VALID,\n\toutput reg [1:0] WIN,\n\toutput reg [3:0] CARD,\n\toutput reg [3:0] SUM\n);\nparameter MAXH = 10;\nparameter ST_INIT = 3'b000;\nparameter ST_FC = 3'b001;\nparameter ST_SC = 3'b010;\nparameter ST_A = 3'b011;\nparameter ST_B = 3'b100;\nparameter ST_WAIT = 3'b101;\nparameter ST_OUTPUT = 3'b110;\nparameter ST_DONE = 3'b111;\n\nreg [2:0] state, next_state;\nreg [3:0] randcard;\ninteger m_w;\nreg inIN, inBT;\nreg [1:0] inMR;\nreg [4:0] handA, handB;\n\n\nalways @(posedge CLK)\nbegin\n\tif (RESET) begin\n\t\trandcard <= 4'b0000;\n\t\tm_w <= 55332;\n\tend\n\telse begin\n\t\tm_w <= 18000 * (m_w & 65535) + (m_w >> 16);\n\t\trandcard <= ((m_w >> 4) % 8) + 1;\n\tend\nend\n\n\nalways @(posedge CLK)\nbegin\n\tif (RESET) begin\n\t\tinIN <= 1'b0;\n\t\tinBT <= 1'b0;\n\t\tinMR <= 2'bxx;\n\tend\n\telse begin\n\t\tinIN <= IN_VALID;\n\t\tinBT <= BUTTON;\n\t\tinMR <= MORE;\n\tend\n\t\t\nend\n\nalways @(posedge CLK)\nbegin\n\tif (RESET)\n\t\tstate <= ST_INIT;\n\telse\n\t\tstate <= next_state;\nend\n\nalways @(state, handA, handB, MORE, inIN, inBT, inMR, RESET)\nbegin\n\tcase (state)\n\t\tST_INIT: if (inIN && inBT) next_state = ST_FC;\n\t\t\t\telse next_state = ST_INIT;\n\t\tST_FC: next_state = ST_SC;\n\t\tST_SC: if (handA > MAXH || handB > MAXH) next_state = ST_OUTPUT;\n\t\t\telse next_state = ST_WAIT;\n\t\tST_A: if (handA > MAXH || handB > MAXH) next_state = ST_OUTPUT;\n\t\t\telse next_state = ST_WAIT;\n\t\tST_B: if (handA > MAXH || handB > MAXH) next_state = ST_OUTPUT;\n\t\t\telse next_state = ST_WAIT;\n\t\tST_WAIT: if (inIN && inBT)\n\t\t\t\tcase (inMR)\n\t\t\t\t\t2'b00: next_state = ST_OUTPUT;\n\t\t\t\t\t2'b01: next_state = ST_A;\n\t\t\t\t\t2'b10: next_state = ST_B;\n\t\t\t\t\t2'b11: next_state = ST_FC;\n\t\t\t\tendcase\n\t\t\telse next_state = ST_WAIT;\n\t\tdefault: next_state = ST_DONE;\n\tendcase\n\tif (RESET)\n\t\tnext_state = ST_INIT;\nend\n\nalways @(posedge CLK)\nbegin\n\tcase (next_state)\n\t\tST_INIT: begin\n\t\t\thandA <= 3'b000;\n\t\t\thandB <= 3'b000;\n\t\tend\n\t\tST_FC: begin\n\t\t\thandA <= handA + randcard;\n\t\tend\n\t\tST_SC: begin\n\t\t\thandB <= handB + randcard;\n\t\tend\n\t\tST_A: begin\n\t\t\thandA <= handA + randcard;\n\t\tend\n\t\tST_B: begin\n\t\t\thandB <= handB + randcard;\n\t\tend\n\tendcase\n\tif (RESET) begin\n\t\thandA <= 3'b000;\n\t\thandB <= 3'b000;\n\tend\nend\n\n\n\nalways @(posedge CLK)\nbegin\n\tcase (next_state)\n\t\tST_FC: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_SC: begin\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_A: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_B: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_OUTPUT: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\tend\n\t\tdefault: begin\n\t\t\tOUT_VALID <= 1'b0;\n\t\t\tCARD <= 3'b000;\n\t\tend\n\tendcase\n\tif (RESET) begin\n\t\tOUT_VALID <= 1'b0;\n\t\tCARD <= 3'b000;\n\tend\nend\n\n\n\n\nalways @(posedge CLK)\nbegin\n\tif ((handA > handB || handB > MAXH) && handA <= MAXH) begin\n\t\tWIN <= 2'b00;\n\t\tSUM <= handA;\n\tend\n\telse if ((handB > handA || handA > MAXH) && handB <= MAXH) begin\n\t\tWIN <= 2'b01;\n\t\tSUM <= handB;\n\tend\n\telse begin\n\t\tWIN <= 2'b10;\n\t\tSUM <= 4'd0;\n\tend\n\n\tif (RESET) begin\n\t\tWIN <= 2'b10;\n\t\tSUM <= 4'd0;\n\tend\nend\nendmodule\n",
        "module_name": "PGM",
        "module_hash": "c9bb4a037c79399e7e29028f39fe8d95",
        "dataset_index": 22177
      },
      "top__0b62a65b": {
        "rtl_code": "module top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input clk,\n    input reset,\n    input enable,\n    output reg [7:0] result\n);\n\n    wire [7:0] mult_out;\n    wire [3:0] count_out;\n\n    multiplier mult_inst (\n        .A(A),\n        .B(B),\n        .result(mult_out)\n    );\n\n    counter count_inst (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .count(count_out)\n    );\n\n    always @(*) begin\n        result = mult_out + count_out;\n    end\n\nendmodule\n\nmodule multiplier (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [7:0] result\n);\n\n    always @(*) begin\n        result = A * B;\n    end\n\nendmodule\n\nmodule counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "0b62a65bca05fa7e14c6ca8a18003d22",
        "dataset_index": 5049
      },
      "timer_d4b5c3ce": {
        "rtl_code": "\n\nmodule timer\n#(parameter WIDTH = 32, RANGE = 60)\n(\n    input clk_normal,\n    input clk_change_time,\n    input power,\n    input enable,\n    input reset,\n    input add_time,\n    input sub_time,\n    output reg [(WIDTH-1):0] count,\n    output reg sig_end\n);\n\n    wire true_clk;\n\n    initial begin\n        count <= 0;\n        sig_end <= 0;\n    end\n    \n    assign true_clk = (!power || reset || !enable && (add_time || sub_time)) ? clk_change_time : clk_normal;\n    \n    always @(posedge true_clk) begin\n        if (power) begin\n            if (reset) begin\n                count <= 0;\n            end else if (enable) begin\n                count = (count + 1) % RANGE;\n                \n                if (count == 0) begin\n                    sig_end = 1;\n                end else begin\n                    sig_end = 0;\n                end\n            end else if (add_time) begin\n                count <= (count + 1) % RANGE;\n            end else if (sub_time) begin\n                if (count == 0) begin\n                    count = RANGE-1;\n                end else begin\n                    count <= (count - 1);\n                end\n            end\n        end else begin\n            count <= 0;\n            sig_end <= 0;\n        end\n    end\nendmodule\n",
        "module_name": "timer",
        "module_hash": "d4b5c3ce2e2e682bb6620c67492cad84",
        "dataset_index": 23883
      },
      "top__51234180": {
        "rtl_code": "\nmodule top_module (\n    input [15:0] D,\n    input [15:0] V,\n    output equal,\n    output greater,\n    output [3:0] Q_out\n);\n\nwire equal_comp, greater_comp;\nwire [15:0] Q, R;\n\nmag_comp mag_comp_inst (\n    .A(D[3:0]),\n    .B(V[3:0]),\n    .equal(equal_comp),\n    .greater(greater_comp)\n);\n\ndiv_16bit_unsigned div_inst (\n    .D(D),\n    .V(V),\n    .Q(Q),\n    .R(R)\n);\n\nfunctional_module func_mod_inst (\n    .equal(equal_comp),\n    .greater(greater_comp),\n    .Q_in(Q),\n    .Q_out(Q_out)\n);\n\nassign equal = equal_comp;\nassign greater = greater_comp;\n\nendmodule\nmodule mag_comp (\n    input [3:0] A,\n    input [3:0] B,\n    output equal,\n    output greater\n);\n\n    assign equal = (A == B);\n    assign greater = (A > B);\n\nendmodule\nmodule div_16bit_unsigned (\n    input [15:0] D,\n    input [15:0] V,\n    output [15:0] Q,\n    output [15:0] R\n);\n\n    assign Q = D / V;\n    assign R = D % V;\n\nendmodule\nmodule functional_module (\n    input equal,\n    input greater,\n    input [15:0] Q_in,\n    output reg [3:0] Q_out\n);\n\n    always @(*) begin\n        if (greater) begin\n            Q_out = Q_in[15:12];\n        end else begin\n            Q_out = Q_in[3:0];\n        end\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "51234180b79cdbf6e940ff122456fcef",
        "dataset_index": 8814
      },
      "RegGPR_48c25645": {
        "rtl_code": "module RegGPR(\n    \n    clock, reset,\n    regIdRs, regValRs,\n    regIdRt, regValRt,\n    regIdRm, regValRm,\n    regIdRn, regValRn,\n    regSrVal);\n\ninput clock;\ninput reset;\n\ninput[6:0] regIdRs;\ninput[6:0] regIdRt;\ninput[6:0] regIdRm;\ninput[6:0] regIdRn;\n\noutput[31:0] regValRs;\noutput[31:0] regValRt;\noutput[31:0] regValRm;\ninput[31:0] regValRn;\n\ninput[31:0] regSrVal;\n\nreg regSrRB;\nreg[31:0] tRegValRs;\nreg[31:0] tRegValRt;\nreg[31:0] tRegValRm;\n\nreg[31:0] regGprLA[7:0];\nreg[31:0] regGprLB[7:0];\nreg[31:0] regGprH[7:0];\n\nassign regValRs = tRegValRs;\nassign regValRt = tRegValRt;\nassign regValRm = tRegValRm;\n\nalways @ (clock)\nbegin\n    tRegValRs=0;\n    tRegValRt=0;\n    tRegValRm=0;\n\n    regSrRB=regSrVal[29];\n\n    if(regIdRs[6:3]==4'h0)\n    begin\n        tRegValRs=regSrRB?\n            regGprLB[regIdRs[2:0]]:\n            regGprLA[regIdRs[2:0]];\n    end\n    else if(regIdRs[6:3]==4'h1)\n    begin\n        tRegValRs=regGprH[regIdRs[2:0]];\n    end\n    else if(regIdRs[6:3]==4'h4)\n    begin\n        tRegValRs=regSrRB?\n            regGprLB[regIdRs[2:0]]:\n            regGprLA[regIdRs[2:0]];\n    end\n\n    if(regIdRt[6:3]==4'h0)\n    begin\n        tRegValRt=regSrRB?\n            regGprLB[regIdRt[2:0]]:\n            regGprLA[regIdRt[2:0]];\n    end\n    else if(regIdRt[6:3]==4'h1)\n    begin\n        tRegValRt=regGprH[regIdRt[2:0]];\n    end\n    else if(regIdRt[6:3]==4'h4)\n    begin\n        tRegValRt=regSrRB?\n            regGprLB[regIdRt[2:0]]:\n            regGprLA[regIdRt[2:0]];\n    end\n\n    if(regIdRm[6:3]==4'h0)\n    begin\n        tRegValRm=regSrRB?\n            regGprLB[regIdRm[2:0]]:\n            regGprLA[regIdRm[2:0]];\n    end\n    else if(regIdRm[6:3]==4'h1)\n    begin\n        tRegValRm=regGprH[regIdRm[2:0]];\n    end\n    else if(regIdRm[6:3]==4'h4)\n    begin\n        tRegValRm=regSrRB?\n            regGprLB[regIdRm[2:0]]:\n            regGprLA[regIdRm[2:0]];\n    end\nend\n\nalways @ (posedge clock)\nbegin\n    if(regIdRn[6:3]==4'h0)\n    begin\n        if(regSrRB)\n            regGprLB[regIdRn[2:0]] <= regValRn;\n        else\n            regGprLA[regIdRn[2:0]] <= regValRn;\n    end\n    else if(regIdRn[6:3]==4'h1)\n    begin\n        regGprH[regIdRn[2:0]] <= regValRn;\n    end\n    else if(regIdRn[6:3]==4'h4)\n    begin\n        if(regSrRB)\n            regGprLA[regIdRn[2:0]] <= regValRn;\n        else\n            regGprLB[regIdRn[2:0]] <= regValRn;\n    end\nend\n\nendmodule",
        "module_name": "RegGPR",
        "module_hash": "48c25645c255b1bfc0561660f9af41e2",
        "dataset_index": 19830
      },
      "wb_mcb_32_83ef75bc": {
        "rtl_code": "module wb_mcb_32\n(\n    input  wire        clk,\n    input  wire        rst,\n\n    \n    input  wire [31:0] wb_adr_i,     // ADR_I() address input\n    input  wire [31:0] wb_dat_i,     // DAT_I() data in\n    output wire [31:0] wb_dat_o,     // DAT_O() data out\n    input  wire        wb_we_i,      // WE_I write enable input\n    input  wire [3:0]  wb_sel_i,     // SEL_I() select input\n    input  wire        wb_stb_i,     // STB_I strobe input\n    output wire        wb_ack_o,     // ACK_O acknowledge output\n    input  wire        wb_cyc_i,     // CYC_I cycle input\n\n    \n    output wire        mcb_cmd_clk,\n    output wire        mcb_cmd_en,\n    output wire [2:0]  mcb_cmd_instr,\n    output wire [5:0]  mcb_cmd_bl,\n    output wire [31:0] mcb_cmd_byte_addr,\n    input  wire        mcb_cmd_empty,\n    input  wire        mcb_cmd_full,\n    output wire        mcb_wr_clk,\n    output wire        mcb_wr_en,\n    output wire [3:0]  mcb_wr_mask,\n    output wire [31:0] mcb_wr_data,\n    input  wire        mcb_wr_empty,\n    input  wire        mcb_wr_full,\n    input  wire        mcb_wr_underrun,\n    input  wire [6:0]  mcb_wr_count,\n    input  wire        mcb_wr_error,\n    output wire        mcb_rd_clk,\n    output wire        mcb_rd_en,\n    input  wire [31:0] mcb_rd_data,\n    input  wire        mcb_rd_empty,\n    input  wire        mcb_rd_full,\n    input  wire        mcb_rd_overflow,\n    input  wire [6:0]  mcb_rd_count,\n    input  wire        mcb_rd_error\n);\n\nreg cycle_reg = 0;\n\nreg [31:0] wb_dat_reg = 0;\nreg wb_ack_reg = 0;\n\nreg mcb_cmd_en_reg = 0;\nreg mcb_cmd_instr_reg = 0;\nreg mcb_wr_en_reg = 0;\nreg [3:0] mcb_wr_mask_reg = 0;\n\nassign wb_dat_o = wb_dat_reg;\nassign wb_ack_o = wb_ack_reg;\n\nassign mcb_cmd_clk = clk;\nassign mcb_cmd_en = mcb_cmd_en_reg;\nassign mcb_cmd_instr = mcb_cmd_instr_reg;\nassign mcb_cmd_bl = 0;\nassign mcb_cmd_byte_addr = wb_adr_i;\nassign mcb_wr_clk = clk;\nassign mcb_wr_en = mcb_wr_en_reg;\nassign mcb_wr_mask = mcb_wr_mask_reg;\nassign mcb_wr_data = wb_dat_i;\nassign mcb_rd_clk = clk;\nassign mcb_rd_en = 1;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        cycle_reg <= 0;\n        mcb_cmd_en_reg <= 0;\n        mcb_cmd_instr_reg <= 0;\n        mcb_wr_en_reg <= 0;\n    end else begin\n        wb_ack_reg <= 0;\n        mcb_cmd_en_reg <= 0;\n        mcb_cmd_instr_reg <= 0;\n        mcb_wr_en_reg <= 0;\n\n        if (cycle_reg) begin\n            if (~mcb_rd_empty) begin\n                cycle_reg <= 0;\n                wb_dat_reg <= mcb_rd_data;\n                wb_ack_reg <= 1;\n            end\n        end else if (wb_cyc_i & wb_stb_i & ~wb_ack_o) begin\n            if (wb_we_i) begin\n                mcb_cmd_instr_reg <= 3'b000;\n                mcb_cmd_en_reg <= 1;\n                mcb_wr_en_reg <= 1;\n                mcb_wr_mask_reg <= ~wb_sel_i;\n                wb_ack_reg <= 1;\n            end else begin\n                mcb_cmd_instr_reg <= 3'b001;\n                mcb_cmd_en_reg <= 1;\n                cycle_reg <= 1;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "wb_mcb_32",
        "module_hash": "83ef75bcfe0ae04c35a67876171e3f0b",
        "dataset_index": 476
      },
      "up_down_counter_eedee02c": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input up_down,\n    input load,\n    input [2:0] D,\n    output reg [2:0] Q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            Q <= D;\n        end else if (!up_down) begin\n            Q <= Q;\n        end else if (up_down) begin\n            Q <= Q + 1;\n        end else begin\n            Q <= Q - 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "eedee02cdd01501fe1ddd9ad4b3257f0",
        "dataset_index": 8528
      },
      "top_module_e2c98961": {
        "rtl_code": "\nmodule top_module(\n    input signed [31:0] a,\n    input signed [31:0] b,\n    output signed [63:0] product\n);\n\n    wire signed [15:0] stage1_out;\n    wire signed [15:0] stage2_out;\n    wire signed [15:0] stage3_out;\n    wire signed [15:0] stage4_out;\n\n    // instantiate four 8-bit multiplication modules\n    mult8bit mult1(.a(a[7:0]), .b(b[7:0]), .product(stage1_out[15:0]));\n    mult8bit mult2(.a(a[15:8]), .b(b[15:8]), .product(stage2_out[15:0]));\n    mult8bit mult3(.a(a[23:16]), .b(b[23:16]), .product(stage3_out[15:0]));\n    mult8bit mult4(.a(a[31:24]), .b(b[31:24]), .product(stage4_out[15:0]));\n\n    // pipeline structure\n    reg signed [15:0] stage1_reg;\n    reg signed [15:0] stage2_reg;\n    reg signed [15:0] stage3_reg;\n    reg signed [15:0] stage4_reg;\n\n    always @(*) begin\n        stage1_reg = stage1_out;\n    end\n\n    always @(*) begin\n        stage2_reg = stage2_out;\n    end\n\n    always @(*) begin\n        stage3_reg = stage3_out;\n    end\n\n    always @(*) begin\n        stage4_reg = stage4_out;\n    end\n\n    assign product = {stage4_reg, stage3_reg, stage2_reg, stage1_reg};\n\nendmodule\nmodule mult8bit(\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [15:0] product\n);\n\n    assign product = a * b;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "e2c98961504c9750c0f2dc119bd06cea",
        "dataset_index": 19772
      },
      "top__111f840c": {
        "rtl_code": "\nmodule top_module (\n    input signed [15:0] in1, // First 16-bit signed integer input\n    input signed [15:0] in2, // Second 16-bit signed integer input\n    output reg signed [15:0] sum_out, // 16-bit signed sum output\n    input [15:0] absolute_in, // Input for absolute_value module\n    output reg [15:0] max_out // 16-bit unsigned output from functional module\n);\n\n// Declare internal wires\nwire [2:0] priority_input;\n\n// Calculate sum of in1 and in2\nalways @* begin\n    sum_out = in1 + in2;\nend\n\n// Assign priority encoder input\nassign priority_input = {sum_out[15], absolute_in[15], sum_out[14:0] > absolute_in[14:0]};\n\n// Use a case statement to determine max value\nalways @* begin\n    case (priority_input)\n        3'b000: max_out = 16'b0000000000000001;\n        3'b001: max_out = 16'b0000000000000010;\n        3'b010: max_out = 16'b0000000000000100;\n        3'b011: max_out = 16'b0000000000001000;\n        3'b100: max_out = 16'b0000000000010000;\n        3'b101: max_out = 16'b0000000000100000;\n        3'b110: max_out = 16'b0000000001000000;\n        3'b111: max_out = 16'b0000000010000000;\n        default: max_out = 16'b0000000000000000;\n    endcase\nend\n\nendmodule\n\nmodule absolute_value (\n    input signed [15:0] in,\n    output reg [15:0] out\n);\n\nalways @* begin\n    if (in < 0) begin\n        out = ~in + 1;\n    end\n    else begin\n        out = in;\n    end\nend\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "111f840ca770935ae43ded57c56c4dca",
        "dataset_index": 16582
      },
      "gtwizard_ultrascale_v1_7_1_bit_synchronizer #_1f0059f8": {
        "rtl_code": "module gtwizard_ultrascale_v1_7_1_bit_synchronizer # (\n\n  parameter INITIALIZE = 5'b00000,\n  parameter FREQUENCY  = 512\n\n)(\n\n  input  wire clk_in,\n  input  wire i_in,\n  output wire o_out\n\n);\n\n  // Use 5 flip-flops as a single synchronizer, and tag each declaration with the appropriate synthesis attribute to\n  // enable clustering. Their GSR default values are provided by the INITIALIZE parameter.\n\n   reg i_in_meta  = INITIALIZE[0];\n   reg i_in_sync1 = INITIALIZE[1];\n   reg i_in_sync2 = INITIALIZE[2];\n   reg i_in_sync3 = INITIALIZE[3];\n                           reg i_in_out   = INITIALIZE[4];\n\n  always @(posedge clk_in) begin\n    i_in_meta  <= i_in;\n    i_in_sync1 <= i_in_meta;\n    i_in_sync2 <= i_in_sync1;\n    i_in_sync3 <= i_in_sync2;\n    i_in_out   <= i_in_sync3;\n  end\n\n  assign o_out = i_in_out;\n\n\nendmodule",
        "module_name": "gtwizard_ultrascale_v1_7_1_bit_synchronizer #",
        "module_hash": "1f0059f8b9067d7f38a6498b9ddfff48",
        "dataset_index": 9120
      },
      "binary_ones_complement_2db3ed22": {
        "rtl_code": "module binary_ones_complement (\n    input [3:0] B,\n    output reg [3:0] C\n);\n\n    always @ (B) begin\n        C <= ~B;\n    end\n\nendmodule",
        "module_name": "binary_ones_complement",
        "module_hash": "2db3ed22a4a6ab520b15e3fa54d75ddc",
        "dataset_index": 7466
      },
      "pcie_7x_v1_8_gtp_pipe_rate #_a18afc57": {
        "rtl_code": "\n\n\n\nmodule pcie_7x_v1_8_gtp_pipe_rate #\n(\n\n    parameter TXDATA_WAIT_MAX   = 4'd15                     )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input               RATE_RST_IDLE,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [23:0]  RATE_FSM\n\n);\n\n    reg                 rst_idle_reg1;\n    reg         [ 1:0]  rate_in_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg                 rst_idle_reg2;\n    reg         [ 1:0]  rate_in_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire                pll_lock;\n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel   =  1'd0; \n    reg         [ 2:0]  rate_out   =  3'd0; \n    reg         [7:0]   fsm        =  8'd0;                 \n   \n    localparam          FSM_IDLE             = 8'b00000001; \n    localparam          FSM_TXDATA_WAIT      = 8'b00000010;           \n    localparam          FSM_PCLK_SEL         = 8'b00000100;   \n    localparam          FSM_RATE_SEL         = 8'b00001000;\n    localparam          FSM_RATE_DONE        = 8'b00010000;\n    localparam          FSM_TXSYNC_START     = 8'b00100000;\n    localparam          FSM_TXSYNC_DONE      = 8'b01000000;             \n    localparam          FSM_DONE             = 8'b10000000; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rst_idle_reg1       <= 1'd0;   \n        rate_in_reg1        <= 2'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rst_idle_reg2       <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rst_idle_reg1       <= RATE_RST_IDLE;\n        rate_in_reg1        <= RATE_RATE_IN;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rst_idle_reg2       <= rst_idle_reg1;\n        rate_in_reg2        <= rate_in_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if (fsm == FSM_RATE_DONE)\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm        <= FSM_IDLE;\n        pclk_sel   <= 1'd0; \n        rate_out   <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm        <=  FSM_TXDATA_WAIT;\n                pclk_sel   <= pclk_sel;\n                rate_out   <= rate_out;\n                end\n            else\n                begin\n                fsm        <= FSM_IDLE;\n                pclk_sel   <= pclk_sel;\n                rate_out   <= rate_out;\n                end\n            end \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm        <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm        <= FSM_RATE_SEL;    \n            pclk_sel   <= (rate_in_reg2 == 2'd1);\n            rate_out   <= rate_out;\n            end\n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm        <= FSM_RATE_DONE;\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate;                             end    \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone ) \n                    fsm <= FSM_TXSYNC_START;\n            else      \n                    fsm <= FSM_RATE_DONE;\n            \n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm        <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm        <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm        <= FSM_IDLE;\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm        <= FSM_IDLE;\n            pclk_sel   <= 1'd0; \n            rate_out   <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL        = pclk_sel;\nassign RATE_RATE_OUT        = rate_out;\nassign RATE_TXSYNC_START    = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE            = (fsm == FSM_DONE);\nassign RATE_IDLE            = (fsm == FSM_IDLE);\nassign RATE_FSM             = fsm;   \n\n\n\nendmodule\n",
        "module_name": "pcie_7x_v1_8_gtp_pipe_rate #",
        "module_hash": "a18afc57e9c58deb4e97d067a7fe2e84",
        "dataset_index": 24022
      },
      "mux_8to1_bd27451c": {
        "rtl_code": "module mux_8to1 (\n  input [3:0] sel,\n  input [7:0] a,\n  input [7:0] b,\n  input [7:0] c,\n  input [7:0] d,\n  output reg [7:0] mux_out\n);\n\nalways @ (*) begin\n  case(sel)\n    4'b0000: mux_out = a;\n    4'b0001: mux_out = b;\n    4'b0010: mux_out = c;\n    4'b0011: mux_out = d;\n    4'b0100: mux_out = a;\n    4'b0101: mux_out = b;\n    4'b0110: mux_out = c;\n    4'b0111: mux_out = d;\n    4'b1000: mux_out = a;\n    4'b1001: mux_out = b;\n    4'b1010: mux_out = c;\n    4'b1011: mux_out = d;\n    4'b1100: mux_out = a;\n    4'b1101: mux_out = b;\n    4'b1110: mux_out = c;\n    4'b1111: mux_out = d;\n  endcase\nend\n\nendmodule\n",
        "module_name": "mux_8to1",
        "module_hash": "bd27451cfc4699e6acb10899a52793ef",
        "dataset_index": 15211
      },
      "adder_subtractor_093799d0": {
        "rtl_code": "module adder_subtractor(output reg [3:0] SUM, output reg C_OUT, input [3:0] A, input [3:0] B, input SUB);\n\n\treg [4:0] temp;\n\t\n\talways @(*) begin\n\t\tif(SUB == 0) begin\n\t\t\ttemp = A + B;\n\t\t\tSUM = temp;\n\t\t\tC_OUT = (temp[4] == 1) ? 1 : 0;\n\t\tend\n\t\telse begin\n\t\t\ttemp = A - B;\n\t\t\tSUM = temp;\n\t\t\tC_OUT = (temp[4] == 1) ? 1 : 0;\n\t\tend\n\tend\n\t\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "093799d0d970dc63b5070c3dffcf39ae",
        "dataset_index": 2738
      },
      "csrbrg_e28efd83": {
        "rtl_code": "\n\nmodule csrbrg(\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\t\n\tinput [31:0] wb_adr_i,\n\tinput [31:0] wb_dat_i,\n\toutput reg [31:0] wb_dat_o,\n\tinput wb_cyc_i,\n\tinput wb_stb_i,\n\tinput wb_we_i,\n\toutput reg wb_ack_o,\n\t\n\t\n\toutput reg [13:0] csr_a,\n\toutput reg csr_we,\n\toutput reg [31:0] csr_do,\n\tinput [31:0] csr_di\n);\n\n\nalways @(posedge sys_clk) begin\n\twb_dat_o <= csr_di;\nend\n\n\nreg next_csr_we;\nalways @(posedge sys_clk) begin\n\tcsr_a <= wb_adr_i[15:2];\n\tcsr_we <= next_csr_we;\n\tcsr_do <= wb_dat_i;\nend\n\n\n\nreg [1:0] state;\nreg [1:0] next_state;\n\nparameter IDLE\t\t= 2'd0;\nparameter DELAYACK1\t= 2'd1;\nparameter DELAYACK2\t= 2'd2;\nparameter ACK\t\t= 2'd3;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tstate <= IDLE;\n\telse\n\t\tstate <= next_state;\nend\n\nalways @(*) begin\n\tnext_state = state;\n\t\n\twb_ack_o = 1'b0;\n\tnext_csr_we = 1'b0;\n\t\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tif(wb_cyc_i & wb_stb_i) begin\n\t\t\t\t\n\t\t\t\tnext_csr_we = wb_we_i;\n\t\t\t\tif(wb_we_i)\n\t\t\t\t\tnext_state = ACK;\n\t\t\t\telse\n\t\t\t\t\tnext_state = DELAYACK1;\n\t\t\tend\n\t\tend\n\t\tDELAYACK1: next_state = DELAYACK2;\n\t\tDELAYACK2: next_state = ACK;\n\t\tACK: begin\n\t\t\twb_ack_o = 1'b1;\n\t\t\tnext_state = IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "csrbrg",
        "module_hash": "e28efd8366a8dbc59d9098e343071754",
        "dataset_index": 14621
      },
      "pipeline_c8a95260": {
        "rtl_code": "\nmodule pipeline (\n  input clk,\n  input reset,\n  input [15:0] instruction,\n  input [2:0] reg1_addr,\n  input [2:0] reg2_addr,\n  input [2:0] reg3_addr,\n  input [15:0] reg1_data,\n  input [15:0] reg2_data,\n  input [15:0] reg3_data,\n  output reg [15:0] reg1_out,\n  output reg [15:0] reg2_out,\n  output reg [15:0] reg3_out\n);\n\nreg [15:0] inst1, inst2, inst3;\nreg [2:0] reg1_addr1, reg2_addr1, reg3_addr1;\nreg [2:0] reg1_addr2, reg2_addr2, reg3_addr2;\nreg [2:0] reg1_addr3, reg2_addr3, reg3_addr3;\nreg [15:0] reg1_data1, reg2_data1, reg3_data1;\nreg [15:0] reg1_data2, reg2_data2, reg3_data2;\nreg [15:0] reg1_data3, reg2_data3, reg3_data3;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    inst1 <= 16'h0;\n    inst2 <= 16'h0;\n    inst3 <= 16'h0;\n    reg1_addr1 <= 3'b0;\n    reg2_addr1 <= 3'b0;\n    reg3_addr1 <= 3'b0;\n    reg1_data1 <= 16'h0;\n    reg2_data1 <= 16'h0;\n    reg3_data1 <= 16'h0;\n  end else begin\n    inst1 <= instruction;\n    inst2 <= inst1;\n    inst3 <= inst2;\n    reg1_addr1 <= reg1_addr;\n    reg2_addr1 <= reg2_addr;\n    reg3_addr1 <= reg3_addr;\n    reg1_data1 <= reg1_data;\n    reg2_data1 <= reg2_data;\n    reg3_data1 <= reg3_data;\n  end\nend\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    reg1_addr2 <= 3'b0;\n    reg2_addr2 <= 3'b0;\n    reg3_addr2 <= 3'b0;\n    reg1_data2 <= 16'h0;\n    reg2_data2 <= 16'h0;\n    reg3_data2 <= 16'h0;\n  end else begin\n    reg1_addr2 <= reg1_addr1;\n    reg2_addr2 <= reg2_addr1;\n    reg3_addr2 <= reg3_addr1;\n    reg1_data2 <= reg1_data1;\n    reg2_data2 <= reg2_data1;\n    reg3_data2 <= reg3_data1;\n  end\nend\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    reg1_addr3 <= 3'b0;\n    reg2_addr3 <= 3'b0;\n    reg3_addr3 <= 3'b0;\n    reg1_data3 <= 16'h0;\n    reg2_data3 <= 16'h0;\n    reg3_data3 <= 16'h0;\n  end else begin\n    reg1_addr3 <= reg1_addr2;\n    reg2_addr3 <= reg2_addr2;\n    reg3_addr3 <= reg3_addr2;\n    reg1_data3 <= reg1_data2;\n    reg2_data3 <= reg2_data2;\n    reg3_data3 <= reg3_data2;\n\n    case (inst3[15:13])\n      3'b000: reg1_out <= reg1_data3 + reg2_data3;\n      3'b001: reg1_out <= reg1_data3 - reg2_data3;\n      3'b010: reg1_out <= reg1_data3 & reg2_data3;\n      3'b011: reg1_out <= reg1_data3 | reg2_data3;\n      3'b100: reg1_out <= reg1_data3 ^ reg2_data3;\n    endcase\n\n    case (inst2[15:13])\n      3'b000: reg2_out <= reg2_data3 + reg3_data3;\n      3'b001: reg2_out <= reg2_data3 - reg3_data3;\n      3'b010: reg2_out <= reg2_data3 & reg3_data3;\n      3'b011: reg2_out <= reg2_data3 | reg3_data3;\n      3'b100: reg2_out <= reg2_data3 ^ reg3_data3;\n    endcase\n\n    case (inst1[15:13])\n      3'b000: reg3_out <= reg3_data3 + reg1_data3;\n      3'b001: reg3_out <= reg3_data3 - reg1_data3;\n      3'b010: reg3_out <= reg3_data3 & reg1_data3;\n      3'b011: reg3_out <= reg3_data3 | reg1_data3;\n      3'b100: reg3_out <= reg3_data3 ^ reg1_data3;\n    endcase\n  end\nend\n\nendmodule\n",
        "module_name": "pipeline",
        "module_hash": "c8a95260ce0fb455db63a2fc1a5cd963",
        "dataset_index": 8028
      },
      "sky130_fd_sc_ls__o21ai_f9d8d1a2": {
        "rtl_code": "module sky130_fd_sc_ls__o21ai (\n    //# {{data|Data Signals}}\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    output Y   ,\n\n    //# {{power|Power}}\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    assign Y = (A1 ^ A2) ? ~B1 : (A1 & A2) ? B1 : A1 & A2;\n    \nendmodule",
        "module_name": "sky130_fd_sc_ls__o21ai",
        "module_hash": "f9d8d1a2932e8b754c90d9f879e66311",
        "dataset_index": 17529
      },
      "adder_tree_top_43d620e2": {
        "rtl_code": "`define ADDER_WIDTH 018\n`define DUMMY_WIDTH 128\n\n`define 2_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "43d620e2af81c5976cfbc799c44c7478",
        "dataset_index": 25088
      },
      "shift_register_1269c7ae": {
        "rtl_code": "\nmodule shift_register(\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output [3:0] q);\n\n    reg [3:0] q1, q2, q3, q4;\n\n    always @(posedge clk) begin\n        if (areset) begin\n            q1 <= 4'b0;\n            q2 <= 4'b0;\n            q3 <= 4'b0;\n            q4 <= 4'b0;\n        end else begin\n            if (load && ena) begin\n                q1 <= data;\n                q2 <= 4'b0;\n                q3 <= 4'b0;\n                q4 <= 4'b0;\n            end else if (load) begin\n                q1 <= data;\n            end else if (ena) begin\n                q1 <= q2;\n                q2 <= q3;\n                q3 <= q4;\n                q4 <= 4'b0;\n            end\n        end\n    end\n\n    assign q = {q4, q3, q2, q1}; // Fix the output order to match the RTL\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "1269c7ae0e5572d6fb775b6ab404d6d3",
        "dataset_index": 16552
      },
      "delay_module_a6b5585b": {
        "rtl_code": "module delay_module(\n    input input_signal,\n    input [1:0] delay_amount,\n    input clk,\n    output reg output_signal\n);\n\nreg [3:0] delay_counter;\n\nalways @(posedge clk) begin\n    if(delay_amount == 0) begin\n        delay_counter <= 1;\n    end else if(delay_amount == 1) begin\n        delay_counter <= 2;\n    end else begin\n        delay_counter <= 4;\n    end\n    \n    if(delay_counter == 1) begin\n        output_signal <= input_signal;\n    end else if(delay_counter > 1) begin\n        output_signal <= 0;\n    end\n    \n    delay_counter <= delay_counter - 1;\nend\n\nendmodule",
        "module_name": "delay_module",
        "module_hash": "a6b5585b201d6e98f9eda67fa5f663e3",
        "dataset_index": 10112
      },
      "decoder_3to8_2911511c": {
        "rtl_code": "module decoder_3to8 (\n    input [2:0] in,\n    output [7:0] out\n);\n\nassign out[0] = ~(in[2] | in[1] | in[0]);\nassign out[1] = ~(in[2] | in[1] | ~in[0]);\nassign out[2] = ~(in[2] | ~in[1] | in[0]);\nassign out[3] = ~(in[2] | ~in[1] | ~in[0]);\nassign out[4] = ~(~in[2] | in[1] | in[0]);\nassign out[5] = ~(~in[2] | in[1] | ~in[0]);\nassign out[6] = ~(~in[2] | ~in[1] | in[0]);\nassign out[7] = ~(~in[2] | ~in[1] | ~in[0]);\n\nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "2911511c68838f05e5be451b050142d6",
        "dataset_index": 9003
      },
      "decoder_4to16_45cfc24c": {
        "rtl_code": "module decoder_4to16 (\n    input [1:0] A, B,\n    input EN,\n    output reg [15:0] Y\n);\n\nalways @ (A or B or EN) begin\n    case ({A,B})\n        2'b00: Y = EN ? 16'b1111111111111110 : 16'b1111111111111111;\n        2'b01: Y = EN ? 16'b1111111111111101 : 16'b1111111111111111;\n        2'b10: Y = EN ? 16'b1111111111111011 : 16'b1111111111111111;\n        2'b11: Y = EN ? 16'b1111111111110111 : 16'b1111111111111111;\n        default: Y = 16'b1111111111111111;\n    endcase\nend\n\nendmodule",
        "module_name": "decoder_4to16",
        "module_hash": "45cfc24c8abd75d5718af8c504c60aed",
        "dataset_index": 6908
      },
      "LCD_7639fd3e": {
        "rtl_code": "\nmodule LCD(\n    input clk,\n    input rst, input en,\n    input reset, input set,\n    input clear,\n    input off,\n    input on,\n    input entry_mode,\n    input cursor,\n    input w_char,\n\t input [7:0] cursor_pos,\n\t input [7:0] ascii_char,\n\t output reg busy,\n\t \n    input int_cnt,\n    output reg [15:0] limit_cnt,\n    output reg en_cnt,\n\t \n    output reg rs,\n    output reg e,\n    output reg [7:0] data\n    );\n\t \n\t reg rs_d;\n\t reg [5:0] state;\n\t reg [7:0] data_d; \n\t \n\t localparam f_rst\t\t= 0,\n\t\t\t\t\tf_idle\t= 1,\n\t\t\t\t\tf_reset\t= 2,\n\t\t\t\t\tf_set\t\t= 3,\n\t\t\t\t\tf_clear\t= 4,\n\t\t\t\t\tf_off\t\t= 5,\n\t\t\t\t\tf_on\t\t= 6,\n\t\t\t\t\tf_entry\t= 7,\n\t\t\t\t\tf_cursor\t= 8,\n\t\t\t\t\tf_w_char\t= 9;\n\t localparam res_data \t= 10;\n\t localparam set_data\t\t= 11;\n\t localparam clear_data\t= 12;\n\t localparam off_data\t\t= 13;\n\t localparam on_data\t\t= 14;\n\t localparam entry_data\t= 15;\n\t localparam cursor_data\t= 16;\n\t localparam write_data\t= 17;\n\t localparam lcd_en\t\t= 18,\n\t\t\t\t\tlcd_del_1\t= 19,\n\t\t\t\t\tlcd_dis\t\t= 20,\n\t\t\t\t\tlcd_del_200\t= 21;\n\t \n\t always@(posedge clk) begin\n\t\tif(rst) state <= f_rst;\n\t\telse begin\n\t\t\tcase(state)\n\t\t\tf_rst: state <= f_idle;\n\t\t\t\n\t\t\tf_idle: begin\n\t\t\t\tif(en) begin\n\t\t\t\t\tif(reset)\t\t\t\tstate <= f_reset;\n\t\t\t\t\telse if(set) \t\t\tstate <= f_set;\n\t\t\t\t\telse if(clear)\t\t\tstate <= f_clear;\n\t\t\t\t\telse if(off) \t\t\tstate <= f_off;\n\t\t\t\t\telse if(on) \t\t\tstate <= f_on;\n\t\t\t\t\telse if(entry_mode) \tstate <= f_entry;\n\t\t\t\t\telse if(cursor) \t\tstate <= f_cursor;\n\t\t\t\t\telse if(w_char) \t\tstate <= f_w_char;\n\t\t\t\t\telse \t\t\t\t\t\tstate <= f_idle;\n\t\t\t\tend else state <= f_idle;\n\t\t\tend\n\t\t\t\n\t\t\tf_reset: state <= res_data;\n\t\t\t\n\t\t\tres_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\t\t\t\t\t\t\n\t\t\tf_set: state <= set_data;\n\t\t\t\n\t\t\tset_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\t\t\t\n\t\t\t\n\t\t\tf_clear: state <= clear_data;\n\t\t\t\n\t\t\tclear_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_off: state <= off_data;\n\t\t\t\n\t\t\toff_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_on: state <= on_data;\n\t\t\t\n\t\t\ton_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_entry: state <= entry_data;\n\t\t\t\n\t\t\tentry_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_cursor: state <= cursor_data;\n\t\t\t\n\t\t\tcursor_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_w_char: state <= write_data;\n\t\t\t\n\t\t\twrite_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: state <= f_rst;\n\t\t\t\n\t\t\tendcase\n\t\tend\n\t end\n\t \n\t always@(*) begin\n\t\tcase(state)\n\t\t\tf_rst: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_idle: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 0; end\n\t\t\tf_reset: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_set: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_clear: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_off: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_on: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_entry: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_cursor: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_w_char: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 1;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tres_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h30;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tset_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h38;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tclear_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h01;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\toff_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h08;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\ton_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h0C;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tentry_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h06;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tcursor_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h80|cursor_pos; busy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\twrite_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 1;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= ascii_char; busy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_en: begin\n\t\t\t\tlimit_cnt \t<= 100;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t1;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_del_1: begin\n\t\t\t\tlimit_cnt \t<= 100; en_cnt\t\t<= 1;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t1;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_dis: begin\n\t\t\t\tlimit_cnt \t<= 20000;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_del_200: begin\n\t\t\t\tlimit_cnt \t<= 20000; en_cnt\t\t<= 1;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\tendcase\n\t end\n\t \n\t always@(negedge clk) begin\n\t\tdata_d <= data;\n\t\trs_d <= rs;\n\t end\n\t \nendmodule\n",
        "module_name": "LCD",
        "module_hash": "7639fd3e28183aacb0c466c4f42f5ead",
        "dataset_index": 24360
      },
      "counter_8b2c40fd": {
        "rtl_code": "\nmodule counter (\n   input clk,\n   input reset,\n   input [3:0] i_value,\n   output reg [3:0] value\n);\n\n   always @(posedge clk or posedge reset) begin\n      if (reset) begin\n         value <= 0;\n      end else if (value == 4'hF) begin\n         value <= 4'h0;\n      end else begin\n         value <= value + 4'h1;\n      end\n   end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "8b2c40fd74201e979e683ca65ed84426",
        "dataset_index": 4487
      },
      "Delay_936933bc": {
        "rtl_code": "\nmodule Delay(\n    CLK,\n    RST,\n    DELAY_MS,\n    DELAY_EN,\n    DELAY_FIN\n    );\n\n\tinput CLK;\n    input RST;\n    input [11:0] DELAY_MS;\n    input DELAY_EN;\n    output DELAY_FIN;\n\n\twire DELAY_FIN;\n\t\t\t\t\treg [13:0] clk_counter = 14'b00000000000000;\t\treg [11:0] ms_counter = 12'h000;\t\t\t\t\t\t\tparameter Idle = 2'd0, Hold = 2'd1, Done = 2'd2;\n\treg [1:0] current_state = Idle;\n\n\tassign DELAY_FIN = (current_state == Done && DELAY_EN == 1'b1) ? 1'b1 : 1'b0;\n\t\n\talways @(posedge CLK) begin\n\t\t\tif(RST == 1'b1) begin\n\t\t\t\t\tcurrent_state <= Idle;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\t\tcase(current_state)\n\n\t\t\t\t\t\t\tIdle : begin\n\t\t\t\t\t\t\t\t\tif(DELAY_EN == 1'b1) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= Hold;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tHold : begin\n\t\t\t\t\t\t\t\t\tif(ms_counter == DELAY_MS) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= Done;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tDone : begin\n\t\t\t\t\t\t\t\t\tif(DELAY_EN == 1'b0) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= Idle;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdefault : current_state <= Idle;\n\t\t\t\t\t\t\t\n\t\t\t\t\tendcase\n\t\t\tend\n\tend\n\talways @(posedge CLK) begin\n\t\t\tif(current_state == Hold) begin\n\t\t\t\t\tif(clk_counter == 14'b10111011100000) begin\t\tclk_counter <= 14'b00000000000000;\n\t\t\t\t\t\t\tms_counter <= ms_counter + 1'b1;\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t\tclk_counter <= clk_counter + 1'b1;\n\t\t\t\t\tend\n\t\t\tend\n\t\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclk_counter <= 14'b00000000000000;\n\t\t\t\t\tms_counter <= 12'h000;\n\t\t\tend\n\tend\n\nendmodule\n",
        "module_name": "Delay",
        "module_hash": "936933bc3e71e69b1c1389f119ac5697",
        "dataset_index": 22002
      },
      "twos_complement_sum_d84812e6": {
        "rtl_code": "\nmodule twos_complement_sum (\n  input [31:0] input_data,\n  output reg [15:0] output_sum\n);\n\n  reg [15:0] lower_bits_twos_comp;\n  reg [15:0] upper_bits_twos_comp;\n  reg [15:0] sum;\n\n  always @(*) begin\n    lower_bits_twos_comp = ~input_data[15:0] + 1;\n    upper_bits_twos_comp = ~input_data[31:16] + 1;\n  end\n\n  always @(*) begin\n    sum = lower_bits_twos_comp + upper_bits_twos_comp;\n    if (sum > 32767) begin\n      output_sum = 32767;\n    end else begin\n      output_sum = sum;\n    end\n  end\n\nendmodule\n",
        "module_name": "twos_complement_sum",
        "module_hash": "d84812e6641a5157a64d530012d73897",
        "dataset_index": 18530
      },
      "sky130_fd_sc_hd__o21bai_a63fa427": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__o21bai (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    wire b          ;\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    not  not0  (b          , B1_N           );\n    or   or0   (or0_out    , A2, A1         );\n    nand nand0 (nand0_out_Y, b, or0_out     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__o21bai",
        "module_hash": "a63fa427f8f85f76e4a6ccb674f4e863",
        "dataset_index": 14204
      },
      "UpDownCtr_c67a8260": {
        "rtl_code": "\nmodule UpDownCtr(\n  input        clock,\n  input        reset,\n  input  [9:0] io_strideInc,\n  input  [9:0] io_strideDec,\n  input        io_inc,\n  input        io_dec,\n  output [9:0] io_out,\n  output [9:0] io_nextInc,\n  output [9:0] io_nextDec\n);\n  reg  [9:0] reg$;  \n  wire [9:0] reg$_T_1;\n  wire [9:0] reg$_T_2;\n  wire [9:0] reg$_T_3;\n\n  assign io_out = reg$;\n  assign io_nextInc = reg$ + io_strideInc;\n  assign io_nextDec = reg$ - io_strideDec;\n  assign reg$_T_1 = io_inc ? io_strideInc : 10'h0;\n  assign reg$_T_2 = io_dec ? io_strideDec : 10'h0;\n\n  always @(posedge clock) begin\n    if (reset) begin\n      reg$ <= 10'h0;\n    end else begin\n      reg$ <= reg$_T_3;\n    end\n  end\n\n  assign reg$_T_3 = io_inc | io_dec ? reg$ + reg$_T_1 - reg$_T_2 : reg$;\n\nendmodule",
        "module_name": "UpDownCtr",
        "module_hash": "c67a8260ca47e132c6ddcccb238b7ceb",
        "dataset_index": 4076
      },
      "adder_subtractor_4bit_d28d222c": {
        "rtl_code": "module adder_subtractor_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output reg [3:0] result,\n    output reg OVFL\n    );\n\n    always @(*) begin\n        if(SUB == 1) begin\n            result = A - B;\n            OVFL = (result[3] == 1) ? 1 : 0;\n        end\n        else begin\n            result = A + B;\n            OVFL = (result[3] == 1) ? 1 : 0;\n        end\n    end\n\nendmodule",
        "module_name": "adder_subtractor_4bit",
        "module_hash": "d28d222cc1b8ff81485b069e392c5d3d",
        "dataset_index": 16624
      },
      "bitwise_operations_30bf2ce5": {
        "rtl_code": "module bitwise_operations(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and,\n    output [2:0] out_xor,\n    output [2:0] out_nand\n);\n\nassign out_and = a & b;\nassign out_xor = a ^ b;\nassign out_nand = !(a & b);\n\nendmodule",
        "module_name": "bitwise_operations",
        "module_hash": "30bf2ce57e582647db2a66a205b1b484",
        "dataset_index": 3191
      },
      "fpu_round_697d67e8": {
        "rtl_code": "\n\nmodule fpu_round( clk, rst, enable, round_mode, sign_term, \nmantissa_term, exponent_term, round_out, exponent_final);\ninput\t\tclk;\ninput\t\trst;\ninput\t\tenable;\ninput\t[1:0]\tround_mode;\ninput\t\tsign_term;\ninput\t[55:0]\tmantissa_term;\ninput\t[11:0]\texponent_term;\noutput\t[63:0]\tround_out;\noutput\t[11:0]\texponent_final;\n\nwire\t[55:0] rounding_amount = { 53'b0, 1'b1, 2'b0};\nwire\tround_nearest = (round_mode == 2'b00);\nwire\tround_to_zero = (round_mode == 2'b01);\nwire\tround_to_pos_inf = (round_mode == 2'b10);\nwire\tround_to_neg_inf = (round_mode == 2'b11);\nwire \tround_nearest_trigger = round_nearest &  mantissa_term[1]; \nwire\tround_to_pos_inf_trigger = !sign_term & |mantissa_term[1:0]; \nwire\tround_to_neg_inf_trigger = sign_term & |mantissa_term[1:0];\nwire \tround_trigger = ( round_nearest & round_nearest_trigger)\n\t\t\t\t\t\t| (round_to_pos_inf & round_to_pos_inf_trigger) \n\t\t\t\t\t\t| (round_to_neg_inf & round_to_neg_inf_trigger);\n\n\nreg\t  [55:0] sum_round;\nwire\tsum_round_overflow = sum_round[55]; \n\treg\t  [55:0] sum_round_2;\nreg   [11:0] exponent_round;\nreg\t  [55:0] sum_final; \nreg   [11:0] exponent_final;\nreg   [63:0] round_out;\n\nalways @(posedge clk) \n\tbegin\n\t\tif (rst) begin\n\t\t\tsum_round <= 0;\n\t\t\tsum_round_2 <= 0;\n\t\t\texponent_round <= 0;\n\t\t\tsum_final <= 0; \n\t\t\texponent_final <= 0;\n\t\t\tround_out <= 0;\n\t\tend\n\t\telse begin\n\t\t\tsum_round <= rounding_amount + mantissa_term;\n\t\t\tsum_round_2 <= sum_round_overflow ? sum_round >> 1 : sum_round;\n\t\t\texponent_round <= sum_round_overflow ? (exponent_term + 1) : exponent_term;\n\t\t\tsum_final <= round_trigger ? sum_round_2 : mantissa_term; \n\t\t\texponent_final <= round_trigger ? exponent_round : exponent_term;\n\t\t\tround_out <= { sign_term, exponent_final[10:0], sum_final[53:2] };\n\t\t\tend\n\tend\nendmodule\t",
        "module_name": "fpu_round",
        "module_hash": "697d67e84dbc145ede982f2fbaa0a4b6",
        "dataset_index": 25019
      },
      "top__27d6f1cc": {
        "rtl_code": "module top_module (\n    input A,\n    input B,\n    input C_in,\n    output [8:0] out\n);\n\n    wire [1:0] fa1_out;\n    wire [1:0] fa2_out;\n    wire parity_bit;\n\n    // Full Adder 1\n    full_adder fa1 (\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .sum(fa1_out[0]),\n        .C_out(fa1_out[1])\n    );\n\n    // Full Adder 2\n    full_adder fa2 (\n        .A(fa1_out[0]),\n        .B(fa1_out[1]),\n        .C_in(1'b0),\n        .sum(fa2_out[0]),\n        .C_out(fa2_out[1])\n    );\n\n    // Parity Bit Calculation\n    assign parity_bit = (A ^ B ^ fa2_out[0]) & (A | B | fa2_out[0]);\n\n    // Output\n    assign out = {parity_bit, fa2_out};\n\nendmodule\n\n// Full Adder\nmodule full_adder (\n    input A,\n    input B,\n    input C_in,\n    output sum,\n    output C_out\n);\n\n    assign sum = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule",
        "module_name": "top_",
        "module_hash": "27d6f1cc0293a047a2cf3f0a31c06f55",
        "dataset_index": 14457
      },
      "InstrDecod_839e0c69": {
        "rtl_code": "module InstrDecod(instr, pc, regWrite, writeData, writeRegister, opcode, funct, regOut1, regOut2, regRt, regRd, immValue, jumpDest, branchDest);\n  input [31:0] instr;    input [31:0] pc; input [31:0] writeData; input [4:0] writeRegister; input regWrite;   output [5:0] opcode; output [5:0] funct;  output [31:0] regOut1; output [31:0] regOut2; output [4:0] regRt;  output [4:0] regRd;  output [31:0] jumpDest;  output [31:0] immValue; output [31:0] branchDest; reg signed [31:0] registerMem [0:31];\n\n  wire signed [31:0] writeData;\n  wire signed [31:0] pc;\n  reg [5:0] opcode, funct;\n  reg [4:0] regRs, regRt, regRd;\n  reg signed [31:0] regOut1, regOut2;\n  reg signed [31:0] immValue, jumpDest, branchDest;\n  reg signed [31:0] signedBranch;\n\n\n  integer idx;\n  initial\n    begin\n    for (idx = 0; idx < 32; idx = idx + 1)\n      begin\n        registerMem[idx] = 0;\n      end\n  end\n\n  always @(*) begin\n    if (regWrite == 1)\n      registerMem[writeRegister] = writeData;\n  end\n\n  always @(instr) begin\n    opcode = instr[31:26];\n     funct = instr[5:0];\n\n    regRs = instr[25:21];\n    regRt = instr[20:16];\n    regRd = instr[15:11];\n\n    immValue = { {16{instr[15]}}, instr[15:0] };\n\n    jumpDest = { {5{instr[25]}}, instr[25:0] };\n\n    signedBranch = { {16{instr[15]}}, instr[15:0] };\n    branchDest = pc + signedBranch;\n\n    regOut1 = registerMem[regRs];\n    regOut2 = registerMem[regRt];\n  end\n  \nendmodule\n",
        "module_name": "InstrDecod",
        "module_hash": "839e0c697cca581b5f786bd8533062aa",
        "dataset_index": 22406
      },
      "up_down_counter_9663cc57": {
        "rtl_code": "\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input enable,\n    input up_down,\n    output reg [3:0] count\n);\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (enable) begin\n            if (up_down) begin\n                count <= count + 1;\n            end else if (count > 0) begin\n                count <= count - 1;\n            end\n        end\n    end\n    \nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n    \n    reg [3:0] shift_reg;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 0;\n        end else if (load) begin\n            shift_reg <= data_in;\n        end else begin\n            shift_reg <= {shift_reg[3:1], 1'b0};\n        end\n    end\n    \n    always@(*) begin\n        data_out <= shift_reg;\n    end\n    \nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input up_down,\n    input load,\n    input [3:0] data_in,\n    output [3:0] data_out\n);\n    \n    reg enable;\n    wire [3:0] count;\n    \n    up_down_counter counter (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .up_down(up_down),\n        .count(count)\n    );\n    \n    shift_register shift_reg (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(count),\n        .data_out(data_out)\n    );\n    \n    always @(posedge clk) begin\n        enable <= !load;\n    end\n    \nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "9663cc57fd229c4e06d5fca2291650fd",
        "dataset_index": 19488
      },
      "vga_core_748f1793": {
        "rtl_code": "module vga_core(\n                vga_clk, \n                rst, \n                addr,\n                v_active,\n                h_sync, \n                v_sync\n                );\n\n\tinput              \tvga_clk;                // 25MHz\n\tinput              \trst;\n\toutput     \t[18: 0] addr;                   // pixel Screen address, 640 (1024) x 480 (512)\n\toutput             \tv_active;               // read VRAM RAM (active_low)\n\toutput             \th_sync, v_sync;         // horizontal and vertical synchronization\n\n\t// h_count: VGA horizontal counter (0-799)\n\treg [9:0] h_count = 0; // VGA horizontal counter (0-799): pixels\n\talways @ (posedge vga_clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\th_count <= 10'h0;\n\t\tend else if (h_count == 10'd799) begin\n\t\t\th_count <= 10'h0;\n\t\tend else begin\n\t\t\th_count <= h_count + 10'h1;\n\t\tend\n\tend\n\n\t// v_count: VGA vertical counter (0-524)\n\treg [9:0] v_count = 0; // VGA vertical counter (0-524): lines\n\talways @ (posedge vga_clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\tv_count <= 10'h0;\n\t\tend else if (h_count == 10'd799) begin\n\t\t\tif (v_count == 10'd524) begin\n\t\t\t\tv_count <= 10'h0;\n\t\t\tend else begin\n\t\t\t\tv_count <= v_count + 10'h1;\n\t\t\tend\n\t\tend\n\tend\n\n\t// signal timing\n\twire h_sync \t\t= (h_count > 10'd95);          // 96 -> 799\n\twire v_sync \t\t= (v_count > 10'd1);           // 2 -> 524\n\twire v_active \t\t= (h_count > 10'd142) &&     // 143 -> 782\n\t\t\t\t\t\t  (h_count < 10'd783) &&     // 640 pixels\n\t\t\t\t\t\t  (v_count > 10'd34) &&      // 35 -> 514\n\t\t\t\t\t\t  (v_count < 10'd515);       // 480 lines\n\n\twire [ 9: 0] col   \t= h_count - 10'd143;    // pixel Screen addr col\n\twire [ 9: 0] row   \t= v_count - 10'd35;     // pixel Screen addr row\n\twire [18: 0] addr  \t= {row[ 8: 0], col};    // pixel Screen addr\n\nendmodule",
        "module_name": "vga_core",
        "module_hash": "748f1793ae426883401401834d636252",
        "dataset_index": 4584
      },
      "adder_ff6c6e41": {
        "rtl_code": "\nmodule adder (\n    input [3:0] A,\n    input [3:0] B,\n    input sel,\n    output reg [3:0] C\n);\n\n    wire [3:0] sum;\n    wire carry;\n\n    assign sum = A + B;\n    assign carry = (A[3] & B[3]) | (A[3] & ~sum[3]) | (B[3] & ~sum[3]);\n\n    always @ (*) begin\n        C = sel ? ~{carry, sum} : {carry, sum};\n    end\n\nendmodule",
        "module_name": "adder",
        "module_hash": "ff6c6e410e89bd44e444546015eb5ebb",
        "dataset_index": 4103
      },
      "top__104ab48d": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [3:0] a, // 4-bit input A for the comparator\n    input [3:0] b, // 4-bit input B for the comparator\n    output reg out_func, // 1-bit output from the functional module\n    output [2:0] count // 3-bit output from the counter\n);\n\nreg [2:0] counter;\nwire equal;\n\ncomparator_4bit comp_inst (\n    .a(a),\n    .b(b),\n    .equal(equal)\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'b0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (counter > b) begin\n        out_func <= 1'b1;\n    end else begin\n        out_func <= 1'b0;\n    end\nend\n\nassign count = counter;\n\nendmodule\n\nmodule comparator_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    output reg equal\n);\n\nalways @(a, b) begin\n    if (a == b) begin\n        equal <= 1'b1;\n    end else begin\n        equal <= 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "104ab48d31f0389319a241816163562a",
        "dataset_index": 12791
      },
      "binary_to_bcd_6584fb96": {
        "rtl_code": "module binary_to_bcd(\n    input [7:0] binary,\n    output [11:0] bcd\n);\n\nreg [3:0] digit1;\nreg [3:0] digit2;\nreg [3:0] digit3;\n\nalways @ (binary) begin\n    if (binary >= 100) begin\n        digit1 = binary / 100;\n        digit2 = (binary % 100) / 10;\n        digit3 = binary % 10;\n    end else if (binary >= 10) begin\n        digit1 = 0;\n        digit2 = binary / 10;\n        digit3 = binary % 10;\n    end else begin\n        digit1 = 0;\n        digit2 = 0;\n        digit3 = binary;\n    end\nend\n\nassign bcd = {digit1, digit2, digit3};\n\nendmodule",
        "module_name": "binary_to_bcd",
        "module_hash": "6584fb96be2c2bdcdf4481fba0c3d667",
        "dataset_index": 1591
      },
      "DemoInterconnect_jtag_axi_0_0_wr_status_flags_as_124a823f": {
        "rtl_code": "module DemoInterconnect_jtag_axi_0_0_wr_status_flags_as\n   (out,\n    \\gic0.gc0.count_d1_reg[5] ,\n    s_dclk_o);\n  output out;\n  input \\gic0.gc0.count_d1_reg[5] ;\n  input s_dclk_o;\n\n  wire \\gic0.gc0.count_d1_reg[5] ;\n   wire ram_full_fb_i;\n   wire ram_full_i;\n  wire s_dclk_o;\n\n  assign out = ram_full_fb_i;\n   \n   \n   \n  FDRE #(\n    .INIT(1'b0)) \n    ram_full_fb_i_reg\n       (.C(s_dclk_o),\n        .CE(1'b1),\n        .D(\\gic0.gc0.count_d1_reg[5] ),\n        .Q(ram_full_fb_i),\n        .R(1'b0));\n   \n   \n   \n  FDRE #(\n    .INIT(1'b0)) \n    ram_full_i_reg\n       (.C(s_dclk_o),\n        .CE(1'b1),\n        .D(\\gic0.gc0.count_d1_reg[5] ),\n        .Q(ram_full_i),\n        .R(1'b0));\nendmodule\n\n \nmodule FDRE \n  #(parameter INIT = 0) \n  (Q, D, C, CE, R);\n  output Q;\n  input D, C, CE, R;\n  reg Q;\n\n  always @(posedge C) begin\n    if (R) begin\n      Q <= INIT;\n    end\n    else if (CE) begin\n      Q <= D;\n    end\n  end\nendmodule",
        "module_name": "DemoInterconnect_jtag_axi_0_0_wr_status_flags_as",
        "module_hash": "124a823f2d9248d834ac4a25563b14fe",
        "dataset_index": 4181
      },
      "RCB_FRL_LED_Clock_796216f4": {
        "rtl_code": "\nmodule RCB_FRL_LED_Clock(Test_Clock_in, LED_Clock_out, RST);\n    input Test_Clock_in;\n    output LED_Clock_out;\n    input RST;\n\n\treg[9:0] count1;\n\treg[9:0] count2;\n\treg[9:0] count3;\n\treg LED_Clock_out_reg;\n\t\n\tassign LED_Clock_out = LED_Clock_out_reg;\n\nalways @(posedge Test_Clock_in or posedge RST) begin\n\tif (RST) begin\n\t\tcount1 <= 1'b0;\n\t\tcount2 <= 1'b0;\n\t\tcount3 <= 1'b0;\n\t\tLED_Clock_out_reg <= 1'b0;\n\t\tend\n\telse begin\n\t\tif (count3 < 448) begin\n\t\t\tif (count2 < 1000) begin\n\t\t\t\tif (count1 < 1000) \n\t\t\t\t\tcount1 <= count1 + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tcount1 <= 1'b0;\n\t\t\t\t\t\tcount2 <= count2 + 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tcount2 <= 1'b0;\n\t\t\t\t\tcount3 <= count3 + 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\telse\t\t\t\t\n\t\t\tbegin\n\t\t\t\tcount3 <= 1'b0;\n\t\t\t\tLED_Clock_out_reg <= ~LED_Clock_out_reg;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n\nmodule RCB_FRL_LED_Clock_DIV(Test_Clock_in, LED_Clock_out, RST);\n    input Test_Clock_in;\n    output LED_Clock_out;\n    input RST;\n\n\treg[9:0] count1;\n\treg[9:0] count2;\n\treg[9:0] count3;\n\treg LED_Clock_out_reg;\n\t\n\tassign LED_Clock_out = LED_Clock_out_reg;\n\nalways @(posedge Test_Clock_in or posedge RST) begin\n\tif (RST) begin\n\t\tcount1 <= 1'b0;\n\t\tcount2 <= 1'b0;\n\t\tcount3 <= 1'b0;\n\t\tLED_Clock_out_reg <= 1'b0;\n\t\tend\n\telse begin\n\t\tif (count3 < 56) begin\n\t\t\tif (count2 < 1000) begin\n\t\t\t\tif (count1 < 1000) \n\t\t\t\t\tcount1 <= count1 + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tcount1 <= 1'b0;\n\t\t\t\t\t\tcount2 <= count2 + 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tcount2 <= 1'b0;\n\t\t\t\t\tcount3 <= count3 + 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\telse\t\t\t\t\n\t\t\tbegin\n\t\t\t\tcount3 <= 1'b0;\n\t\t\t\tLED_Clock_out_reg <= ~LED_Clock_out_reg;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "RCB_FRL_LED_Clock",
        "module_hash": "796216f49d721368eafa34ef591613a3",
        "dataset_index": 25766
      },
      "prometheus_fx3_partial_718499a2": {
        "rtl_code": "module prometheus_fx3_partial(\n\tinput  rst_n,\n        input  clk_100,\n        input  partial_mode_selected,\n        input  i_gpif_in_ch0_rdy_d,\n        input  i_gpif_out_ch0_rdy_d,\n        output o_gpif_we_n_partial_,\n\toutput o_gpif_pkt_end_n_partial_,\n        output [31:0] data_out_partial\n);\n\nreg [2:0]current_partial_state;\nreg [2:0]next_partial_state;\nparameter [2:0] partial_idle                      = 3'd0;\nparameter [2:0] partial_wait_flagb                = 3'd1;\nparameter [2:0] partial_write                     = 3'd2;\nparameter [2:0] partial_write_wr_delay            = 3'd3;\nparameter [2:0] partial_wait\t\t          = 3'd4;\n\n\nreg [3:0] strob_cnt;\nreg       strob; \nreg [3:0] short_pkt_cnt;\nreg [31:0]data_gen_partial;\nreg o_gpif_pkt_end_n_prtl_;\n\nassign o_gpif_we_n_partial_ = ((current_partial_state == partial_write) && (i_gpif_out_ch0_rdy_d == 1'b1)) ? 1'b0 : 1'b1;\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tshort_pkt_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_idle)begin\n\t\tshort_pkt_cnt <= 4'd0;\n\tend else if((current_partial_state == partial_write))begin\n\t\tshort_pkt_cnt <= short_pkt_cnt + 1'b1;\n\tend\t\nend\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tstrob_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_idle)begin\n\t\tstrob_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_wait)begin\n\t\tstrob_cnt <= strob_cnt + 1'b1;\n\tend\t\nend\n\nalways@(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin\n\t\tstrob <= 1'b0;\n\tend else if((current_partial_state == partial_wait) && (strob_cnt == 4'b0111)) begin\n\t\tstrob <= !strob;\n\tend\nend\n\nalways@(*)begin\n\tif((partial_mode_selected) & (strob == 1'b1) & (short_pkt_cnt == 4'b1111))begin\n\t\to_gpif_pkt_end_n_prtl_ = 1'b0;\n\tend else begin\n\t\to_gpif_pkt_end_n_prtl_ = 1'b1;\n\tend\nend\t\n\nassign o_gpif_pkt_end_n_partial_ = o_gpif_pkt_end_n_prtl_;\n\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tcurrent_partial_state <= partial_idle;\n\tend else begin\n\t\tcurrent_partial_state <= next_partial_state;\n\tend\t\nend\n\nalways @(*)begin\n\tnext_partial_state = current_partial_state;\n\tcase(current_partial_state)\n\tpartial_idle:begin\n\t\tif((partial_mode_selected) & (i_gpif_in_ch0_rdy_d == 1'b1))begin\n\t\t\tnext_partial_state = partial_wait_flagb; \n\t\tend else begin\n\t\t\tnext_partial_state = partial_idle;\n\t\tend\t\n\tend\n\tpartial_wait_flagb :begin\n\t\tif (i_gpif_out_ch0_rdy_d == 1'b1)begin\n\t\t\tnext_partial_state = partial_write; \n\t\tend else begin\n\t\t\tnext_partial_state = partial_wait_flagb; \n\t\tend\n\tend\n\tpartial_write:begin\n\t\tif((i_gpif_out_ch0_rdy_d == 1'b0) | ((strob == 1'b1) & (short_pkt_cnt == 4'b1111)))begin\n\t\t\tnext_partial_state = partial_write_wr_delay;\n\t\tend else begin\n\t\t \tnext_partial_state = partial_write;\n\t\tend\n\tend\n        partial_write_wr_delay:begin\n\t\tnext_partial_state = partial_wait;\n\tend\n\tpartial_wait:begin\n\t\tif(strob_cnt == 4'b0111)begin\n\t\t\tnext_partial_state = partial_idle;\n\t\tend else begin\n\t\t\tnext_partial_state = partial_wait;\n\t\tend\n\tend\t\n\tendcase\nend\n\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tdata_gen_partial <= 32'd0;\n\tend else if((o_gpif_we_n_partial_ == 1'b0) & (partial_mode_selected)) begin\n\t\tdata_gen_partial <= data_gen_partial + 1;\n\tend else if (!partial_mode_selected) begin\n\t\tdata_gen_partial <= 32'd0;\n\tend\t\nend\n\nassign data_out_partial = data_gen_partial;\n\nendmodule\n\n",
        "module_name": "prometheus_fx3_partial",
        "module_hash": "718499a25974b46a4e9afea28e465417",
        "dataset_index": 17205
      },
      "max_value_0105be0e": {
        "rtl_code": "module max_value (input [7:0] A, B, C, D, output reg [15:0] out);\n\nreg [7:0] max_val;\n\nalways @ (A, B, C, D) begin\n    max_val = A > B ? A : B;\n    max_val = max_val > C ? max_val : C;\n    max_val = max_val > D ? max_val : D;\n    out = {max_val, 8'b0};\nend\n\nendmodule",
        "module_name": "max_value",
        "module_hash": "0105be0ea2a6e9acba062cee48ff8442",
        "dataset_index": 10695
      },
      "sky130_fd_sc_lp__and2_aa76f330": {
        "rtl_code": "\nmodule sky130_fd_sc_lp__and2 (\n    X   ,\n    A   ,\n    B   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    // Module ports\n    output X   ;\n    input  A   ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire and0_out_X       ;\n\n    //                                 Name         Output             Other arguments\n    and                                and0        (and0_out_X       , A, B                  );\n    buf                                buf0        (X                , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__and2",
        "module_hash": "aa76f330d1ad63e64075fd49949c0fb1",
        "dataset_index": 17281
      },
      "sync_counter_bf3ba698": {
        "rtl_code": "module sync_counter(\n    input rst,\n    input clk,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if(rst) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "sync_counter",
        "module_hash": "bf3ba6986caf6c03bbaf2794494c8a88",
        "dataset_index": 17977
      },
      "processing_system7_v5_3_aw_atc #_fe06d774": {
        "rtl_code": "\n\n\nmodule processing_system7_v5_3_aw_atc #\n  (\n   parameter         C_FAMILY                         = \"rtl\", \n                       parameter integer C_AXI_ID_WIDTH                   = 4, \n                       parameter integer C_AXI_ADDR_WIDTH                 = 32, \n                       parameter integer C_AXI_AWUSER_WIDTH               = 1,\n                       parameter integer C_FIFO_DEPTH_LOG                 = 4\n   )\n  (\n   input  wire                                  ARESET,\n   input  wire                                  ACLK,\n\n   output reg                                   cmd_w_valid,\n   output wire                                  cmd_w_check,\n   output wire [C_AXI_ID_WIDTH-1:0]             cmd_w_id,\n   input  wire                                  cmd_w_ready,\n   input  wire [C_FIFO_DEPTH_LOG-1:0]           cmd_b_addr,\n   input  wire                                  cmd_b_ready,\n   \n   input  wire [C_AXI_ID_WIDTH-1:0]             S_AXI_AWID,\n   input  wire [C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,\n   input  wire [4-1:0]                          S_AXI_AWLEN,\n   input  wire [3-1:0]                          S_AXI_AWSIZE,\n   input  wire [2-1:0]                          S_AXI_AWBURST,\n   input  wire [2-1:0]                          S_AXI_AWLOCK,\n   input  wire [4-1:0]                          S_AXI_AWCACHE,\n   input  wire [3-1:0]                          S_AXI_AWPROT,\n   input  wire [C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,\n   input  wire                                  S_AXI_AWVALID,\n   output wire                                  S_AXI_AWREADY,\n\n   output wire [C_AXI_ID_WIDTH-1:0]             M_AXI_AWID,\n   output wire [C_AXI_ADDR_WIDTH-1:0]           M_AXI_AWADDR,\n   output wire [4-1:0]                          M_AXI_AWLEN,\n   output wire [3-1:0]                          M_AXI_AWSIZE,\n   output wire [2-1:0]                          M_AXI_AWBURST,\n   output wire [2-1:0]                          M_AXI_AWLOCK,\n   output wire [4-1:0]                          M_AXI_AWCACHE,\n   output wire [3-1:0]                          M_AXI_AWPROT,\n   output wire [C_AXI_AWUSER_WIDTH-1:0]         M_AXI_AWUSER,\n   output wire                                  M_AXI_AWVALID,\n   input  wire                                  M_AXI_AWREADY\n   );\n  \n  \n  localparam [2-1:0] C_FIX_BURST         = 2'b00;\n  localparam [2-1:0] C_INCR_BURST        = 2'b01;\n  localparam [2-1:0] C_WRAP_BURST        = 2'b10;\n  \n  localparam [3-1:0] C_OPTIMIZED_SIZE    = 3'b011;\n  \n  localparam [4-1:0] C_OPTIMIZED_LEN     = 4'b0011;\n\n  localparam [4-1:0] C_NO_ADDR_OFFSET    = 5'b0;\n  \n  localparam C_FIFO_WIDTH                = C_AXI_ID_WIDTH + 1;\n  localparam C_FIFO_DEPTH                = 2 ** C_FIFO_DEPTH_LOG;\n    \n  \n  integer index;\n  \n  \n  wire                                access_is_incr;\n  wire                                access_is_wrap;\n  wire                                access_is_coherent;\n  wire                                access_optimized_size;\n  wire                                incr_addr_boundary;\n  wire                                incr_is_optimized;\n  wire                                wrap_is_optimized;\n  wire                                access_is_optimized;\n  \n  wire                                cmd_w_push;\n  reg                                 cmd_full;\n  reg  [C_FIFO_DEPTH_LOG-1:0]         addr_ptr;\n  wire [C_FIFO_DEPTH_LOG-1:0]         all_addr_ptr;\n  reg  [C_FIFO_WIDTH-1:0]             data_srl[C_FIFO_DEPTH-1:0];\n  \n  \n  assign access_is_incr         = ( S_AXI_AWBURST == C_INCR_BURST );\n  assign access_is_wrap         = ( S_AXI_AWBURST == C_WRAP_BURST );\n  \n  assign access_is_coherent     = ( S_AXI_AWUSER[0]  == 1'b1 ) &\n                                  ( S_AXI_AWCACHE[1] == 1'b1 );\n  \n  assign incr_addr_boundary     = ( S_AXI_AWADDR[4:0] == C_NO_ADDR_OFFSET );\n  \n  assign access_optimized_size  = ( S_AXI_AWSIZE == C_OPTIMIZED_SIZE ) & \n                                  ( S_AXI_AWLEN  == C_OPTIMIZED_LEN  );\n  \n  assign incr_is_optimized      = access_is_incr & access_is_coherent & access_optimized_size & incr_addr_boundary;\n  assign wrap_is_optimized      = access_is_wrap & access_is_coherent & access_optimized_size;\n  assign access_is_optimized    = ( incr_is_optimized | wrap_is_optimized );\n  \n  \n  assign cmd_w_push = S_AXI_AWVALID & M_AXI_AWREADY & ~cmd_full;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      addr_ptr <= {C_FIFO_DEPTH_LOG{1'b1}};\n    end else begin\n      if ( cmd_w_push & ~cmd_w_ready ) begin\n        addr_ptr <= addr_ptr + 1;\n      end else if ( ~cmd_w_push & cmd_w_ready ) begin\n        addr_ptr <= addr_ptr - 1;\n      end\n    end\n  end\n  \n  assign all_addr_ptr = addr_ptr + cmd_b_addr + 2;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      cmd_full    <= 1'b0;\n      cmd_w_valid <= 1'b0;\n    end else begin\n      if ( cmd_w_push & ~cmd_w_ready ) begin\n        cmd_w_valid <= 1'b1;\n      end else if ( ~cmd_w_push & cmd_w_ready ) begin\n        cmd_w_valid <= ( addr_ptr != 0 );\n      end\n      if ( cmd_w_push & ~cmd_b_ready ) begin\n        cmd_full    <= ( all_addr_ptr == C_FIFO_DEPTH-3 );\n      end else if ( ~cmd_w_push & cmd_b_ready ) begin\n        cmd_full    <= ( all_addr_ptr == C_FIFO_DEPTH-2 );\n      end\n    end\n  end\n  \n  always @ (posedge ACLK) begin\n    if ( cmd_w_push ) begin\n      for (index = 0; index < C_FIFO_DEPTH-1 ; index = index + 1) begin\n        data_srl[index+1] <= data_srl[index];\n      end\n      data_srl[0]   <= {access_is_optimized, S_AXI_AWID};\n    end\n  end\n  \n  assign {cmd_w_check, cmd_w_id} = data_srl[addr_ptr];\n  \n  \n  assign M_AXI_AWVALID   = S_AXI_AWVALID & ~cmd_full;\n  \n  assign S_AXI_AWREADY   = M_AXI_AWREADY & ~cmd_full;\n  \n  \n  assign M_AXI_AWID      = S_AXI_AWID; \n  assign M_AXI_AWADDR    = S_AXI_AWADDR;\n  assign M_AXI_AWLEN     = S_AXI_AWLEN;\n  assign M_AXI_AWSIZE    = S_AXI_AWSIZE;\n  assign M_AXI_AWBURST   = S_AXI_AWBURST;\n  assign M_AXI_AWLOCK    = S_AXI_AWLOCK;\n  assign M_AXI_AWCACHE   = S_AXI_AWCACHE;\n  assign M_AXI_AWPROT    = S_AXI_AWPROT;\n  assign M_AXI_AWUSER    = S_AXI_AWUSER;\n  \n  \nendmodule\n",
        "module_name": "processing_system7_v5_3_aw_atc #",
        "module_hash": "fe06d774fe3bb9990bb5f6596d175ca3",
        "dataset_index": 25312
      },
      "shift_and_add_multiplier_11dbb2af": {
        "rtl_code": "module shift_and_add_multiplier (\n    input clk,\n    input reset,\n    input [3:0] a, b,\n    output reg [7:0] product\n);\n\n    reg [2:0] i; // Declare 'i' as a 3-bit register\n\n    always @(posedge clk) begin\n        if (reset) begin\n            product <= 8'b0;\n        end else begin\n            for (i = 0; i < 4; i = i + 1) begin\n                if (b[i]) begin\n                    product <= product + (a << i);\n                end\n            end\n        end\n    end\n\nendmodule",
        "module_name": "shift_and_add_multiplier",
        "module_hash": "11dbb2af820af7f22a1ec1b1da715354",
        "dataset_index": 607
      },
      "three_input_gate_168490a7": {
        "rtl_code": "module three_input_gate (\n    Y,\n    A1,\n    A2,\n    B1\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input B1;\n\n    wire A1_AND_A2;\n    wire B1_OR_A1_AND_A2;\n\n    assign A1_AND_A2 = A1 & A2;\n    assign B1_OR_A1_AND_A2 = B1 | A1_AND_A2;\n\n    assign Y = B1_OR_A1_AND_A2;\n\nendmodule",
        "module_name": "three_input_gate",
        "module_hash": "168490a73128dbe3d4bd1f725bc65448",
        "dataset_index": 2058
      },
      "up_down_counter_shifter_4b547551": {
        "rtl_code": "\nmodule up_down_counter_shifter (\n    input CLK,\n    input UP,\n    input DOWN,\n    input SHIFT,\n    input RST,\n    input [3:0] B,\n    output [3:0] Q,\n    output reg [3:0] RESULT\n);\n\nreg [3:0] counter;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        counter <= 4'b0;\n        RESULT <= 4'b0;\n    end else if (UP && !DOWN) begin\n        counter <= counter + 4'b1;\n    end else if (!UP && DOWN) begin\n        counter <= counter - 4'b1;\n    end else begin\n        counter <= counter;\n    end\n    \n    if (SHIFT) begin\n        RESULT <= counter << B;\n    end else begin\n        RESULT <= counter;\n    end\nend\n\nassign Q = counter;\n\nendmodule\n",
        "module_name": "up_down_counter_shifter",
        "module_hash": "4b547551306a09bab2b059c0f8e77372",
        "dataset_index": 6538
      },
      "up_down_shift_4681f912": {
        "rtl_code": "module up_down_shift(\n    input [3:0] LOAD,\n    input UP_DOWN,\n    input CLK,\n    input RESET,\n    input [3:0] D,\n    output reg [3:0] OUT\n);\n\nreg [3:0] up_down_counter;\nreg [3:0] shift_register;\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        up_down_counter <= 4'b0;\n        shift_register <= 4'b0;\n        OUT <= 4'b0;\n    end\n    else if (LOAD) begin\n        up_down_counter <= LOAD;\n        shift_register <= D;\n        OUT <= up_down_counter + shift_register;\n    end\n    else begin\n        if (UP_DOWN) begin\n            up_down_counter <= up_down_counter + 1;\n        end\n        else begin\n            up_down_counter <= up_down_counter - 1;\n        end\n        shift_register <= {shift_register[2:0], D[0]};\n        OUT <= up_down_counter + shift_register;\n    end\nend\n\nendmodule",
        "module_name": "up_down_shift",
        "module_hash": "4681f9128eda6032cb35c90d0f6ef908",
        "dataset_index": 11675
      },
      "dmem_mux3_e99d1b28": {
        "rtl_code": "module dmem_mux3\n(\n    output reg [31:0] out0_addr_o,\n    output reg [31:0] out0_data_o,\n    input [31:0]      out0_data_i,\n    output reg [3:0]  out0_sel_o,\n    output reg        out0_we_o,\n    output reg        out0_stb_o,\n    output reg        out0_cyc_o,\n    output reg [2:0]  out0_cti_o,\n    input             out0_ack_i,\n    input             out0_stall_i,\n\n    output reg [31:0] out1_addr_o,\n    output reg [31:0] out1_data_o,\n    input [31:0]      out1_data_i,\n    output reg [3:0]  out1_sel_o,\n    output reg        out1_we_o,\n    output reg        out1_stb_o,\n    output reg        out1_cyc_o,\n    output reg [2:0]  out1_cti_o,\n    input             out1_ack_i,\n    input             out1_stall_i,\n\n    output reg [31:0] out2_addr_o,\n    output reg [31:0] out2_data_o,\n    input [31:0]      out2_data_i,\n    output reg [3:0]  out2_sel_o,\n    output reg        out2_we_o,\n    output reg        out2_stb_o,\n    output reg        out2_cyc_o,\n    output reg [2:0]  out2_cti_o,\n    input             out2_ack_i,\n    input             out2_stall_i,\n\n    input [31:0]      mem_addr_i,\n    input [31:0]      mem_data_i,\n    output reg[31:0]  mem_data_o,\n    input [3:0]       mem_sel_i,\n    input             mem_we_i,\n    input             mem_stb_i,\n    input             mem_cyc_i,\n    input [2:0]       mem_cti_i,\n    output reg        mem_ack_o,\n    output reg        mem_stall_o\n);\n\nparameter           ADDR_MUX_START      = 28;\n\nalways @ *\nbegin\n\n   out0_addr_o      = 32'h00000000;\n   out0_data_o      = 32'h00000000;\n   out0_sel_o       = 4'b0000;\n   out0_we_o        = 1'b0;\n   out0_stb_o       = 1'b0;\n   out0_cyc_o       = 1'b0;\n   out0_cti_o       = 3'b0;\n   out1_addr_o      = 32'h00000000;\n   out1_data_o      = 32'h00000000;\n   out1_sel_o       = 4'b0000;\n   out1_we_o        = 1'b0;\n   out1_stb_o       = 1'b0;\n   out1_cyc_o       = 1'b0;\n   out1_cti_o       = 3'b0;\n   out2_addr_o      = 32'h00000000;\n   out2_data_o      = 32'h00000000;\n   out2_sel_o       = 4'b0000;\n   out2_we_o        = 1'b0;\n   out2_stb_o       = 1'b0;\n   out2_cyc_o       = 1'b0;\n   out2_cti_o       = 3'b0;\n\n   case (mem_addr_i[ADDR_MUX_START+2-1:ADDR_MUX_START])\n\n   2'd0:\n   begin\n       out0_addr_o      = mem_addr_i;\n       out0_data_o      = mem_data_i;\n       out0_sel_o       = mem_sel_i;\n       out0_we_o        = mem_we_i;\n       out0_stb_o       = mem_stb_i;\n       out0_cyc_o       = mem_cyc_i;\n       out0_cti_o       = mem_cti_i;\n   end\n   2'd1:\n   begin\n       out1_addr_o      = mem_addr_i;\n       out1_data_o      = mem_data_i;\n       out1_sel_o       = mem_sel_i;\n       out1_we_o        = mem_we_i;\n       out1_stb_o       = mem_stb_i;\n       out1_cyc_o       = mem_cyc_i;\n       out1_cti_o       = mem_cti_i;\n   end\n   2'd2:\n   begin\n       out2_addr_o      = mem_addr_i;\n       out2_data_o      = mem_data_i;\n       out2_sel_o       = mem_sel_i;\n       out2_we_o        = mem_we_i;\n       out2_stb_o       = mem_stb_i;\n       out2_cyc_o       = mem_cyc_i;\n       out2_cti_o       = mem_cti_i;\n   end\n\n   default :\n      ;      \n   endcase\nend\n\nalways @ *\nbegin\n   case (mem_addr_i[ADDR_MUX_START+2-1:ADDR_MUX_START])\n\n    2'd0:\n    begin\n       mem_data_o   = out0_data_i;\n       mem_stall_o  = out0_stall_i;\n       mem_ack_o    = out0_ack_i;\n    end\n    2'd1:\n    begin\n       mem_data_o   = out1_data_i;\n       mem_stall_o  = out1_stall_i;\n       mem_ack_o    = out1_ack_i;\n    end\n    2'd2:\n    begin\n       mem_data_o   = out2_data_i;\n       mem_stall_o  = out2_stall_i;\n       mem_ack_o    = out2_ack_i;\n    end\n\n   default :\n   begin\n       mem_data_o   = 32'h00000000;\n       mem_stall_o  = 1'b0;\n       mem_ack_o    = 1'b0;\n   end\n   endcase\nend\n\nendmodule\n",
        "module_name": "dmem_mux3",
        "module_hash": "e99d1b2896dc8bb8807f71aed31a878e",
        "dataset_index": 24063
      },
      "four_bit_adder_908e330e": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input reset,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] xor1_out;\n    wire [3:0] xor2_out;\n    wire [3:0] and1_out;\n    wire [3:0] and2_out;\n    wire [3:0] and3_out;\n    wire [3:0] or1_out;\n    wire [3:0] or2_out;\n    wire [3:0] or3_out;\n    wire [3:0] or4_out;\n    wire [3:0] sum_out;\n    wire [3:0] carry_out;\n\n    assign xor1_out = A ^ B;\n    assign xor2_out = xor1_out ^ Cin;\n    assign and1_out = A & B;\n    assign and2_out = A & Cin;\n    assign and3_out = B & Cin;\n    assign or1_out = and1_out | and2_out;\n    assign or2_out = and1_out | and3_out;\n    assign or3_out = and2_out | and3_out;\n    assign or4_out = or1_out | or2_out | or3_out;\n    assign sum_out = xor2_out;\n    assign carry_out = or4_out;\n\n    assign Cout = carry_out[3];\n\n    reg [3:0] Sum;\n\n    always @ (posedge reset, posedge Cin) begin\n        if (reset) begin\n            Sum <= 0;\n        end else begin\n            Sum <= sum_out;\n        end\n    end\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "908e330ecfd871a3ed42c44ec69c69e9",
        "dataset_index": 20231
      },
      "magnitude_903b7646": {
        "rtl_code": "module magnitude(Y0, Y1, Y2, Y3, mag1, mag2);\n\t\n\tinput [11:0] Y0, Y1, Y2, Y3;\n\toutput [11:0] mag1, mag2;\n\twire [11:0] max1, max2, min1, min2;\n\twire [11:0] Z0, Z1, Z2, Z3;\n\t\n\ttoPositive p1 (.in(Y0), .out(Z0));\n\ttoPositive p2 (.in(Y1), .out(Z1));\n\ttoPositive p3 (.in(Y2), .out(Z2));\n\ttoPositive p4 (.in(Y3), .out(Z3));\n\t\n\tmax m1 (.imagPart(Z1), .realPart(Z0), .maximun(max1));\n\tmax m2 (.imagPart(Z3), .realPart(Z2), .maximun(max2));\n\tmin m3 (.imagPart(Z1), .realPart(Z0), .minimum(min1));\n\tmin m4 (.imagPart(Z3), .realPart(Z2), .minimum(min2));\n\t\n\tassign mag1 = max1 + (min1 >> 2) - (max1 >> 4);\n\tassign mag2 = max2 + (min2 >> 2) - (max2 >> 4);\n\t\nendmodule\n\nmodule toPositive(\n\tinput [11:0] in,\n\toutput reg [11:0] out);\n\t\n\talways @ * begin\n\t\tif(in[11] == 1'b1)\n\t\t\tout = ~in + 12'b1;\n\t\telse\n\t\t\tout = in;\n\tend\nendmodule\n\nmodule max(\n\tinput [11:0] imagPart,\n\tinput [11:0] realPart,\n\toutput reg [11:0] maximun);\n\t\n\talways @ * begin\n\t\tif(imagPart > realPart)\n\t\t\tmaximun = imagPart;\n\t\telse\n\t\t\tmaximun = realPart;\n\tend\nendmodule\n\nmodule min(\n\tinput [11:0] imagPart,\n\tinput [11:0] realPart,\n\toutput reg [11:0] minimum);\n\t\n\talways @ * begin\n\t\tif(imagPart > realPart)\n\t\t\tminimum = realPart;\n\t\telse\n\t\t\tminimum = imagPart;\n\tend\nendmodule\n",
        "module_name": "magnitude",
        "module_hash": "903b7646c07f55e86dc71ecf0ad43347",
        "dataset_index": 21644
      },
      "signed_mult_shift_81ecc33b": {
        "rtl_code": "\nmodule signed_mult_shift(\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input [3:0] shift,\n    input dir,\n    output reg signed [15:0] out\n);\n\n    wire signed [7:0] mult_result;\n    wire [3:0] shift_amt;\n\n    // Signed multiplication module\n    signed_mult mult(\n        .A(A),\n        .B(B),\n        .out(mult_result)\n    );\n\n    // Determine shift amount based on direction input\n    assign shift_amt = (dir == 1'b1) ? shift : -shift;\n\n    // Instantiate the barrel shifter module\n    barrel_shifter shift_reg(\n        .in(mult_result),\n        .shift_amt(shift_amt),\n        .out(out)\n    );\n\nendmodule\nmodule signed_mult(\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output reg signed [7:0] out\n);\n\n    wire [7:0] temp;\n    assign temp = A * B;\n    always @(*) begin\n        out = temp;\n    end\n\nendmodule\nmodule barrel_shifter(\n    input [7:0] in,\n    input [3:0] shift_amt,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        out = in << shift_amt;\n    end\n\nendmodule",
        "module_name": "signed_mult_shift",
        "module_hash": "81ecc33b8ebdf4be7e65925171ad60b7",
        "dataset_index": 4445
      },
      "nios_altmemddr_0_ex_lfsr8_901a5da5": {
        "rtl_code": "module nios_altmemddr_0_ex_lfsr8 (\nclk, reset_n, enable, pause, load, data, ldata);\n\n   parameter seed  = 32;\n   input clk;\n   input reset_n;\n   input enable;\n   input pause;\n   input load;\n   output[8 - 1:0] data;\n   wire[8 - 1:0] data;\n   input[8 - 1:0] ldata;\n\n   reg[8 - 1:0] lfsr_data;\n\n   assign data = lfsr_data ;\n\n   always @(posedge clk or negedge reset_n)\n   begin\n      if (!reset_n)\n      begin\n         lfsr_data <= seed[7:0] ;\n      end\n      else\n      begin\n         if (!enable)\n         begin\n            lfsr_data <= seed[7:0];\n         end\n         else\n         begin\n            if (load)\n            begin\n               lfsr_data <= ldata ;\n            end\n            else\n            begin\n               if (!pause)\n               begin\n                  lfsr_data[0] <= lfsr_data[7] ;\n                  lfsr_data[1] <= lfsr_data[0] ;\n                  lfsr_data[2] <= lfsr_data[1] ^ lfsr_data[7] ;\n                  lfsr_data[3] <= lfsr_data[2] ^ lfsr_data[7] ;\n                  lfsr_data[4] <= lfsr_data[3] ^ lfsr_data[7] ;\n                  lfsr_data[5] <= lfsr_data[4] ;\n                  lfsr_data[6] <= lfsr_data[5] ;\n                  lfsr_data[7] <= lfsr_data[6] ;\n               end\n            end\n         end\n      end\n   end\nendmodule\n",
        "module_name": "nios_altmemddr_0_ex_lfsr8",
        "module_hash": "901a5da59bc3146fd49fc0d49c82213b",
        "dataset_index": 23802
      },
      "binary_decoder_3to8_a5cfd204": {
        "rtl_code": "module binary_decoder_3to8 (\n    input [2:0] in,      // 3-bit input\n    output reg [7:0] out // 8-bit output\n);\n\n    always @(*) begin\n        // Initialize output to 0\n        out = 8'b00000000;\n\n        // Decode the input to one-hot output\n        case (in)\n            3'b000: out[0] = 1'b1;\n            3'b001: out[1] = 1'b1;\n            3'b010: out[2] = 1'b1;\n            3'b011: out[3] = 1'b1;\n            3'b100: out[4] = 1'b1;\n            3'b101: out[5] = 1'b1;\n            3'b110: out[6] = 1'b1;\n            3'b111: out[7] = 1'b1;\n            default: out = 8'b00000000; // Default case to handle unknown states\n        endcase\n    end\n\nendmodule\n",
        "module_name": "binary_decoder_3to8",
        "module_hash": "a5cfd204efbd7c8627586dcb9842c46e",
        "dataset_index": 10031
      },
      "dff_reset_1ac74fbc": {
        "rtl_code": "\nmodule dff_reset (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] q_reg;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        q_reg <= 8'b0;\n    end else begin\n        q_reg <= d;\n    end\nend\n\nassign q = q_reg;\n\nendmodule\n\nmodule counter (\n    input clk,\n    input reset,\n    output reg [2:0] count\n);\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        count <= 3'b0;\n    end else begin\n        if (count == 3'b111) begin\n            count <= 3'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule and_module (\n    input [7:0] d,\n    input [2:0] count,\n    output [7:0] q\n);\n\nassign q = d & {3{count[2]}} & {3{count[1]}} & {3{count[0]}};\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q\n);\n\nwire [2:0] count;\nwire [7:0] dff_out;\n\ndff_reset dff_inst (\n    .clk(clk),\n    .reset(count[2]),\n    .d(d),\n    .q(dff_out)\n);\n\ncounter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .count(count)\n);\n\nand_module and_inst (\n    .d(dff_out),\n    .count(count),\n    .q(q)\n);\n\nendmodule\n",
        "module_name": "dff_reset",
        "module_hash": "1ac74fbc031151cb4c01262ac6e229d6",
        "dataset_index": 14475
      },
      "signalinput_a0ac6f52": {
        "rtl_code": "module signalinput(\n    input [1:0] testmode,\n    input sysclk,\n    output sigin1\n);\n\nreg [20:0] state;\nreg [20:0] divide;\nreg sigin;\n\nassign sigin1 = sigin;\n\ninitial\nbegin\n    sigin = 0;\n    state = 21'b000000000000000000000;\n    divide = 21'b0_0000_0111_1101_0000_0000;\nend\n\nalways @(testmode)\nbegin\n    case(testmode[1:0])\n    2'b00: divide = 21'b0_0000_0111_1101_0000_0000;  // 3125Hz, divide by 32000\n    2'b01: divide = 21'b0_0000_0011_1110_1000_0000;  // 250Hz, divide by 400000\n    2'b10: divide = 21'b1_1110_1000_0100_1000_0000;  // 50Hz, divide by 2000000\n    2'b11: divide = 21'b0_0000_0001_1111_0100_0000;  // 12500Hz, divide by 8000\n    endcase\nend\n\nalways @(posedge sysclk)\nbegin\n    if(state == 0)\n        sigin = ~sigin;\n    state = state + 21'd2;\n    if(state == divide)\n        state = 0;\nend\n\nendmodule",
        "module_name": "signalinput",
        "module_hash": "a0ac6f52c803115bae68722ea9e3c6a9",
        "dataset_index": 6772
      },
      "axi_timer_ce8c251c": {
        "rtl_code": "\nmodule axi_timer\n    #(parameter WIDTH = 32, parameter TICK_RATE = 1)\n    (input clk, rst, enable, load,\n     input [WIDTH-1:0] value,\n     output [WIDTH-1:0] timer,\n     output reg done);\n\n    reg [WIDTH-1:0] load_value;\n    reg [WIDTH-1:0] count;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0;\n            done <= 0;\n        end else if (enable) begin\n            if (load) begin\n                load_value <= value;\n                count <= load_value;\n                done <= 0;\n            end else if (count > 0) begin\n                count <= count - 1;\n                done <= 0;\n            end else begin\n                count <= load_value;\n                done <= 1;\n            end\n        end else begin\n            done <= 0;\n        end\n    end\n\n    assign timer = count;\n\nendmodule",
        "module_name": "axi_timer",
        "module_hash": "ce8c251c15f7efdee2e2c81b5cb2b7db",
        "dataset_index": 17516
      },
      "sky130_fd_sc_lp__a32o_1d834cec": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a32o (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A3, A1, A2        );\n    and and1 (and1_out , B1, B2            );\n    or  or0  (or0_out_X, and1_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a32o",
        "module_hash": "1d834cec50ac117794df189f72a833a1",
        "dataset_index": 22592
      },
      "i2c_control_9acdf4af": {
        "rtl_code": "\n\n\n\n\n\n\nmodule i2c_control\n(\n\tinput clk,\n\tinput reset,\n\t\n\tinput   [2:0]address,\n\tinput        write,\n\tinput  [31:0]writedata,\n\tinput        read,\n\toutput reg [31:0]readdata,\n\n\toutput reg go,\n\tinput full,\n\toutput reg [11:0]memd,\n\toutput memw,\n\tinput busy,\n\toutput tbm,\n\tinput [31:0]rda\n);\n\n\twire [9:0]i2c_data;\n\treg rdbff;\n\n\tassign memw = write & (address>=1) & (address<=5);\n\tassign i2c_data = {writedata[7:4], !writedata[4],\n\t              writedata[3:0], !writedata[0]};\n  always @(*)\n\tcase (address)\n\t\t3'd2: memd <= {2'b00, i2c_data};\n\t\t3'd3: memd <= {2'b10, i2c_data}; 3'd4: memd <= {2'b01, i2c_data}; 3'd5: memd <= {2'b11, i2c_data}; default: memd <= writedata[11:0];\n\tendcase\n\t\n\talways @(*)\n\tcase (address)\n\t\t3'd1:   readdata <= rda;\n\t\tdefault readdata <= {28'h1234_567, 1'b0, full, rdbff, busy || rda[31]};\n\tendcase\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t  rdbff <= 0;\n\t\t  go    <= 0;\n    end\n\t\telse if (write && (address == 3'd0))\n\t\tbegin\n\t\t\trdbff <= writedata[1];\n\t\t\tgo    <= writedata[0];\n\t\tend\n\t\telse go <= 0;\n\tend\n\t\n\tassign tbm = rdbff;\n\nendmodule\n",
        "module_name": "i2c_control",
        "module_hash": "9acdf4af2b40677c4985c3ef0fd1021e",
        "dataset_index": 25298
      },
      "full_adder_193e7bc0": {
        "rtl_code": "module full_adder (A, B, Ci, S, Co);\n  input A, B, Ci;\n  output S, Co;\n  wire n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11;\n\n  assign n11 = ~(A ^ B);\n  assign S = ~(Ci ^ n11);\n  assign n10 = ~(A & B & Ci);\n  assign n9 = ~(A & B);\n  assign Co = ~(n10 & n9);\n  assign n1 = ~(Ci & n11);\n  assign n2 = ~(B & n11);\n  assign n3 = ~(A & Ci);\n  assign n4 = ~(n1 & n2);\n  assign n5 = ~(n3 & n9);\n  assign n6 = ~(n3 & n2);\n  assign n7 = ~(n1 & n9);\n  assign n8 = ~(n6 & n7);\nendmodule",
        "module_name": "full_adder",
        "module_hash": "193e7bc0dcc1a86fc72b3de2f65168d7",
        "dataset_index": 3857
      },
      "eg_limiter_32582f63": {
        "rtl_code": "module eg_limiter(\n\tinput [6:0] lfo_mod,\n\tinput amsen,\n\tinput [1:0] ams,\n\tinput [6:0] tl,\n\tinput [9:0] eg_pure_in,\n\tinput ssg_inv,\n\toutput reg [9:0] eg_limited\n);\n\nreg [8:0] am_final;\nreg [11:0] sum_eg_tl;\nreg [11:0] sum_eg_tl_am;\nreg [5:0] am_inverted;\nreg [9:0] eg_pream;\n\nalways @(*) begin\n\tam_inverted = lfo_mod[6] ? ~lfo_mod[5:0] : lfo_mod[5:0];\nend\n\nalways @(*) begin\n\tcasez({amsen, ams})\n\t\tdefault: am_final = 9'd0;\n\t\t3'b1_01: am_final = {5'd0, am_inverted[5:2]};\n\t\t3'b1_10: am_final = {3'd0, am_inverted};\n\t\t3'b1_11: am_final = {2'd0, am_inverted, 1'b0};\n\tendcase\n\teg_pream = ssg_inv ? (10'h200 - eg_pure_in) : eg_pure_in;\n\tsum_eg_tl = {1'b0, tl, 3'd0} + {1'b0, eg_pream}; // leading zeros needed to compute correctly\n\tsum_eg_tl_am = sum_eg_tl + {3'd0, am_final};\nend\n\nalways @(*)\n\teg_limited = sum_eg_tl_am[11:10] == 2'd0 ? sum_eg_tl_am[9:0] : 10'h3ff;\n\nendmodule",
        "module_name": "eg_limiter",
        "module_hash": "32582f633e005e46ac40e16af704e3fa",
        "dataset_index": 812
      },
      "state_machine_e7120704": {
        "rtl_code": "module state_machine (\n  input clock,\n  input reset,\n  output reg [1:0] state_out,\n  output reg done\n);\n\n  parameter COUNT_TO_DONE = 3;\n\n  localparam IDLE = 2'b00;\n  localparam COUNT = 2'b01;\n  localparam DONE = 2'b10;\n\n  reg [1:0] state;\n\n  always @(posedge clock or negedge reset) begin\n    if (~reset) begin\n      state <= IDLE;\n      state_out <= IDLE;\n      done <= 0;\n    end\n    else begin\n      case (state)\n        IDLE: begin\n          if (clock) begin\n            state <= COUNT;\n            state_out <= COUNT;\n          end\n        end\n        COUNT: begin\n          if (clock) begin\n            if (state_out == COUNT_TO_DONE) begin\n              state <= DONE;\n              state_out <= DONE;\n              done <= 1;\n            end\n            else begin\n              state_out <= state_out + 1;\n            end\n          end\n        end\n        DONE: begin\n          if (clock) begin\n            done <= 1;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "state_machine",
        "module_hash": "e712070492d1921ef10963192528d047",
        "dataset_index": 7450
      },
      "four_bit_adder_9941dd19": {
        "rtl_code": "module four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input enable,\n    output reg [3:0] sum\n);\n\nalways @ (a, b, enable)\nbegin\n    if(enable == 1'b1)\n        sum = a + b;\n    else\n        sum = 4'b0000;\nend\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "9941dd19a5d9577481ca5203d90e817c",
        "dataset_index": 6924
      },
      "xor_module_fcb7417f": {
        "rtl_code": "module xor_module(\n    input [3:0] a,\n    output [3:0] b\n);\n\n    // Define constant value\n    parameter [3:0] c = 4'b1011;\n\n    // Perform XOR operation between a and c\n    assign b = a ^ c;\n\nendmodule",
        "module_name": "xor_module",
        "module_hash": "fcb7417fef3217ccba9a8479c7c57542",
        "dataset_index": 11166
      },
      "system_controller_4c735cf8": {
        "rtl_code": "module system_controller(\n   clk_sys, reset_sys, locked,\n   clk_in, reset_in\n   );\n   input wire clk_in;\n   output wire clk_sys;\n   input  wire reset_in;\n   output wire reset_sys;   \n   output wire locked;\n   \n    \n   `ifdef XILINX\n   wire                         xclk_buf;\n   IBUFG xclk_ibufg(.I(clk_in), .O(xclk_buf));\n   wire                         locked;\n`else\n   assign locked = 1;\n   \n`endif\n   \n\n   reg [5:0]                    reset_count = 6'h0;\n   assign reset_sys = reset_in | ~locked | (|reset_count);   \n   \n   always @(posedge clk_in)\n     if (reset_in | ~locked) begin\n        reset_count <= 6'h1;        \n     end else begin\n        if (reset_count) begin\n           reset_count <= reset_count + 1;           \n        end\n     end\n   \n   `ifdef XILINX   \n   BUFG clk_bug (\n                 .O(clk_sys), .I(CLKFBOUT) );\n\n   clk_wiz_0 lab9_clocks\n     (\n      .clk_in1(xclk_buf),      .clk_out1(CLKFBOUT),     .reset(reset_in), .locked(locked));      `else assign clk_sys = clk_in;   \n   \n`endif endmodule ",
        "module_name": "system_controller",
        "module_hash": "4c735cf8a099cea70171c78f7ac1d8bd",
        "dataset_index": 22092
      },
      "multiply_complex #_9509568e": {
        "rtl_code": "module multiply_complex #(parameter WIDTH = 32)\n  (\n    input wire clk,\n    input wire rst_n,\n    input wire signed [WIDTH-1:0] x,\n    input wire signed [WIDTH-1:0] y,\n    output reg signed [2*WIDTH-1:0] z\n  );\n\n  reg signed [2*WIDTH-1:0] temp_z;\n\n  always @ (posedge clk)\n  begin\n    if (~rst_n)\n    begin\n      temp_z <= 0;\n      z <= 0;\n    end\n    else\n    begin\n      temp_z <= x * y;\n      z <= temp_z >> WIDTH;\n    end\n  end\n\nendmodule",
        "module_name": "multiply_complex #",
        "module_hash": "9509568ef2e3765c46d5d936d5103394",
        "dataset_index": 10851
      },
      "calculator_9b15c05d": {
        "rtl_code": "module calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = a + b;\n        2'b01: result = a - b;\n        2'b10: result = a * b;\n        2'b11: result = a / b;\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "9b15c05d84b7cc83afaf0feeac976953",
        "dataset_index": 20527
      },
      "top__b444f542": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [2:0] input_data, // 3-bit input data\n    input control, // Control signal for the multiplexer\n    output reg [2:0] counter_out, // 3-bit output from the counter\n    output reg [2:0] xor_out // 3-bit output from the XOR module\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'b000;\n    end\n    else if (counter == 3'b111) begin\n        counter <= 3'b000;\n    end\n    else begin\n        counter <= counter + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        xor_out <= 3'b000;\n    end\n    else begin\n        case (control)\n            1'b0: xor_out <= counter ^ input_data;\n            1'b1: xor_out <= counter_out ^ input_data;\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter_out <= 3'b000;\n    end\n    else begin\n        case (control)\n            1'b0: counter_out <= counter;\n            1'b1: counter_out <= counter_out;\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "b444f5422ebc02522b69fd9dc7797b8c",
        "dataset_index": 8144
      },
      "DelayTest_c3de9d7e": {
        "rtl_code": "\nmodule DelayTest(\n    input clk,\n    input reset,\n    input [3:0] data,\n    output reg [3:0] out1,\n    output reg [3:0] out2,\n    output reg [3:0] out3\n);\n\n  // Test different delays.\n  always @(posedge clk) begin\n    if (reset) begin\n      out1 <= 0;\n      out2 <= 0;\n      out3 <= 0;\n    end else begin\n      out1 <= data;\n      out2 <= out1;\n      out3 <= out2;\n    end\n  end\n\nendmodule",
        "module_name": "DelayTest",
        "module_hash": "c3de9d7e9ed67755a2bf92f228304ff1",
        "dataset_index": 21435
      },
      "mux4_88907058": {
        "rtl_code": "module mux4(input [3:0] in, input [1:0] sel, output reg out);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = in[0];\n        2'b01: out = in[1];\n        2'b10: out = in[2];\n        2'b11: out = in[3];\n    endcase\nend\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "88907058f36a5d7f9857b530ec9542a8",
        "dataset_index": 2208
      },
      "sd2_dac_a6f55e23": {
        "rtl_code": "module sd2_dac (\n\tinput \t\t\tclk,\t\t\tinput\t[15:0]\tldatasum,\tinput\t[15:0] \trdatasum,\toutput\treg \tleft=0,\t\toutput\treg \tright=0\t\t);\n\nlocalparam DW = 16;\nlocalparam CW = 2;\nlocalparam RW  = 4;\nlocalparam A1W = 2;\nlocalparam A2W = 5;\n\nwire [DW+2+0  -1:0] sd_l_er0, sd_r_er0;\nreg  [DW+2+0  -1:0] sd_l_er0_prev=0, sd_r_er0_prev=0;\nwire [DW+A1W+2-1:0] sd_l_aca1,  sd_r_aca1;\nwire [DW+A2W+2-1:0] sd_l_aca2,  sd_r_aca2;\nreg  [DW+A1W+2-1:0] sd_l_ac1=0, sd_r_ac1=0;\nreg  [DW+A2W+2-1:0] sd_l_ac2=0, sd_r_ac2=0;\nwire [DW+A2W+3-1:0] sd_l_quant, sd_r_quant;\n\nreg [24-1:0] seed1 = 24'h654321;\nreg [19-1:0] seed2 = 19'h12345;\nreg [24-1:0] seed_sum=0, seed_prev=0, seed_out=0;\nalways @ (posedge clk) begin\n  if (&seed1)\n    seed1 <= 24'h654321;\n  else\n    seed1 <= {seed1[22:0], ~(seed1[23] ^ seed1[22] ^ seed1[21] ^ seed1[16])};\nend\nalways @ (posedge clk) begin\n  if (&seed2)\n    seed2 <= 19'h12345;\n  else\n    seed2 <= {seed2[17:0], ~(seed2[18] ^ seed2[17] ^ seed2[16] ^ seed2[13] ^ seed2[0])};\nend\nalways @ (posedge clk) begin\n  seed_sum  <= seed1 + {5'b0, seed2};\n  seed_prev <= seed_sum;\n  seed_out  <= seed_sum - seed_prev;\nend\n\nlocalparam ID=4; reg  [ID+0-1:0] int_cnt = 0;\nalways @ (posedge clk) int_cnt <= int_cnt + 'd1;\n\nreg  [DW+0-1:0] ldata_cur=0, ldata_prev=0;\nreg  [DW+0-1:0] rdata_cur=0, rdata_prev=0;\nwire [DW+1-1:0] ldata_step, rdata_step;\nreg  [DW+ID-1:0] ldata_int=0, rdata_int=0;\nwire [DW+0-1:0] ldata_int_out, rdata_int_out;\nassign ldata_step = {ldata_cur[DW-1], ldata_cur} - {ldata_prev[DW-1], ldata_prev}; assign rdata_step = {rdata_cur[DW-1], rdata_cur} - {rdata_prev[DW-1], rdata_prev}; always @ (posedge clk) begin\n  if (~|int_cnt) begin\n    ldata_prev <= ldata_cur;\n    ldata_cur  <= ldatasum; rdata_prev <= rdata_cur;\n    rdata_cur  <= rdatasum; ldata_int  <= {ldata_cur[DW-1], ldata_cur, {ID{1'b0}}};\n    rdata_int  <= {rdata_cur[DW-1], rdata_cur, {ID{1'b0}}};\n  end else begin\n    ldata_int  <= ldata_int + {{ID{ldata_step[DW+1-1]}}, ldata_step};\n    rdata_int  <= rdata_int + {{ID{rdata_step[DW+1-1]}}, rdata_step};\n  end\nend\nassign ldata_int_out = ldata_int[DW+ID-1:ID];\nassign rdata_int_out = rdata_int[DW+ID-1:ID];\n\nwire [DW+2-1:0] ldata_gain, rdata_gain;\nassign ldata_gain = {ldata_int_out[DW-1], ldata_int_out, 1'b0} + {{(2){ldata_int_out[DW-1]}}, ldata_int_out};\nassign rdata_gain = {rdata_int_out[DW-1], rdata_int_out, 1'b0} + {{(2){rdata_int_out[DW-1]}}, rdata_int_out};\n\n\n\n\nassign sd_l_aca1 = {{(A1W){ldata_gain[DW+2-1]}}, ldata_gain} - {{(A1W){sd_l_er0[DW+2-1]}}, sd_l_er0} + sd_l_ac1;\nassign sd_r_aca1 = {{(A1W){rdata_gain[DW+2-1]}}, rdata_gain} - {{(A1W){sd_r_er0[DW+2-1]}}, sd_r_er0} + sd_r_ac1;\n\nassign sd_l_aca2 = {{(A2W-A1W){sd_l_aca1[DW+A1W+2-1]}}, sd_l_aca1} - {{(A2W){sd_l_er0[DW+2-1]}}, sd_l_er0} - {{(A2W+1){sd_l_er0_prev[DW+2-1]}}, sd_l_er0_prev[DW+2-1:1]} + sd_l_ac2;\nassign sd_r_aca2 = {{(A2W-A1W){sd_r_aca1[DW+A1W+2-1]}}, sd_r_aca1} - {{(A2W){sd_r_er0[DW+2-1]}}, sd_r_er0} - {{(A2W+1){sd_r_er0_prev[DW+2-1]}}, sd_r_er0_prev[DW+2-1:1]} + sd_r_ac2;\n\nalways @ (posedge clk) begin\n  sd_l_ac1 <= sd_l_aca1;\n  sd_r_ac1 <= sd_r_aca1;\n  sd_l_ac2 <= sd_l_aca2;\n  sd_r_ac2 <= sd_r_aca2;\nend\n\nassign sd_l_quant = {sd_l_ac2[DW+A2W+2-1], sd_l_ac2} + {{(DW+A2W+3-RW){seed_out[RW-1]}}, seed_out[RW-1:0]};\nassign sd_r_quant = {sd_r_ac2[DW+A2W+2-1], sd_r_ac2} + {{(DW+A2W+3-RW){seed_out[RW-1]}}, seed_out[RW-1:0]};\n\nassign sd_l_er0 = sd_l_quant[DW+A2W+3-1] ? {1'b1, {(DW+2-1){1'b0}}} : {1'b0, {(DW+2-1){1'b1}}};\nassign sd_r_er0 = sd_r_quant[DW+A2W+3-1] ? {1'b1, {(DW+2-1){1'b0}}} : {1'b0, {(DW+2-1){1'b1}}};\nalways @ (posedge clk) begin\n  sd_l_er0_prev <= (&sd_l_er0) ? sd_l_er0 : sd_l_er0+1;\n  sd_r_er0_prev <= (&sd_r_er0) ? sd_r_er0 : sd_r_er0+1;\nend\n\nalways @ (posedge clk) begin\n  left  <= (~|ldata_gain) ? ~left  : ~sd_l_er0[DW+2-1];\n  right <= (~|rdata_gain) ? ~right : ~sd_r_er0[DW+2-1];\nend\n\nendmodule\n",
        "module_name": "sd2_dac",
        "module_hash": "a6f55e23395299e7bc87765d53c17236",
        "dataset_index": 18148
      },
      "four_bit_adder_6f6daa1e": {
        "rtl_code": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input Clock,\n    output [3:0] Sum,\n    output Cout\n);\n\nreg [3:0] Sum;\nreg Cout;\n\nalways @(posedge Clock) begin\n    {Cout, Sum} = A + B + Cin;\nend\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "6f6daa1e8cbc202160e8e11705156c57",
        "dataset_index": 4214
      },
      "state__7335ca8a": {
        "rtl_code": "\nmodule state_module ( g, p, g_prec, p_prec, g_out, p_out );\n  input g, p, g_prec, p_prec;\n  output g_out, p_out;\n  wire   n5, p_prec_inv;\n\n  // Inverting p_prec\n  not U4 ( p_prec_inv, p_prec);\n\n  // AND-OR-INVERT gate\n  and ( n5, p_prec_inv, g_prec);\n  or ( g_out, p, n5);\n\n  // AND gate\n  and ( p_out, p, p_prec);\nendmodule",
        "module_name": "state_",
        "module_hash": "7335ca8a69444a2ab6a9ee6ac95e4179",
        "dataset_index": 14238
      },
      "div_top_cd7e5123": {
        "rtl_code": "\nmodule div_top(\n    clk,\n    reset,\n    ce,\n    din0,\n    din1,\n    dout);\n\nparameter ID = 32'd1;\nparameter NUM_STAGE = 32'd1;\nparameter din0_WIDTH = 32'd1;\nparameter din1_WIDTH = 32'd1;\nparameter dout_WIDTH = 32'd1;\n\ninput clk;\ninput reset;\ninput ce;\ninput[din0_WIDTH - 1:0] din0;\ninput[din1_WIDTH - 1:0] din1;\noutput[dout_WIDTH - 1:0] dout;\n\nwire[dout_WIDTH - 1:0] sig_remd;\n\ndiv #(\n.in0_WIDTH( din0_WIDTH ),\n.in1_WIDTH( din1_WIDTH ),\n.out_WIDTH( dout_WIDTH ))\ndiv_U(\n    .dividend( din0 ),\n    .divisor( din1 ),\n    .quot( dout ),\n    .remd( sig_remd ),\n    .clk( clk ),\n    .ce( ce ),\n    .reset( reset ));\n\nendmodule\nmodule div #(\nparameter in0_WIDTH = 32,\nparameter in1_WIDTH = 32,\nparameter out_WIDTH = 32)\n(\n    input [in0_WIDTH - 1:0] dividend,\n    input [in1_WIDTH - 1:0] divisor,\n    output reg [out_WIDTH - 1:0] quot,\n    output reg [out_WIDTH - 1:0] remd,\n    input clk,\n    input ce,\n    input reset);\n\n    reg [in0_WIDTH - 1:0] temp_dividend;\n    reg [in1_WIDTH - 1:0] temp_divisor;\n    reg [out_WIDTH - 1:0] temp_quot;\n    reg [out_WIDTH - 1:0] temp_remd;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            temp_dividend <= 0;\n            temp_divisor <= 0;\n            temp_quot <= 0;\n            temp_remd <= 0;\n        end else if (ce) begin\n            temp_dividend <= dividend;\n            temp_divisor <= divisor;\n            temp_quot <= quot;\n            temp_remd <= remd;\n\n            if (temp_divisor == 0) begin\n                temp_quot <= 0;\n                temp_remd <= temp_dividend;\n            end else begin\n                temp_quot <= temp_dividend / temp_divisor;\n                temp_remd <= temp_dividend % temp_divisor;\n            end\n        end\n    end\n\n    always @(*) begin\n        quot <= temp_quot;\n        remd <= temp_remd;\n    end\n\nendmodule",
        "module_name": "div_top",
        "module_hash": "cd7e512325215cdef60041b3a3661e8b",
        "dataset_index": 16388
      },
      "delay__a7f957b8": {
        "rtl_code": "module delay_module (\n    input clk,\n    input reset,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nreg [3:0] delay_reg1;\nreg [3:0] delay_reg2;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        delay_reg1 <= 4'b0;\n        delay_reg2 <= 4'b0;\n        out <= 4'b0;\n    end else begin\n        delay_reg1 <= in;\n        delay_reg2 <= delay_reg1;\n        out <= delay_reg2;\n    end\nend\n\nendmodule",
        "module_name": "delay_",
        "module_hash": "a7f957b817efa2f914546225f13e5f5b",
        "dataset_index": 19942
      },
      "fmrv32im_axim_8ce45836": {
        "rtl_code": "module fmrv32im_axim\n  (\n   input         RST_N,\n   input         CLK,\n\n   output [0:0]  M_AXI_AWID,\n   output [31:0] M_AXI_AWADDR,\n   output [7:0]  M_AXI_AWLEN,\n   output [2:0]  M_AXI_AWSIZE,\n   output [1:0]  M_AXI_AWBURST,\n   output        M_AXI_AWLOCK,\n   output [3:0]  M_AXI_AWCACHE,\n   output [2:0]  M_AXI_AWPROT,\n   output [3:0]  M_AXI_AWQOS,\n   output [0:0]  M_AXI_AWUSER,\n   output        M_AXI_AWVALID,\n   input         M_AXI_AWREADY,\n\n   output [31:0] M_AXI_WDATA,\n   output [3:0]  M_AXI_WSTRB,\n   output        M_AXI_WLAST,\n   output [0:0]  M_AXI_WUSER,\n   output        M_AXI_WVALID,\n   input         M_AXI_WREADY,\n\n   input [0:0]   M_AXI_BID,\n   input [1:0]   M_AXI_BRESP,\n   input [0:0]   M_AXI_BUSER,\n   input         M_AXI_BVALID,\n   output        M_AXI_BREADY,\n\n   output [0:0]  M_AXI_ARID,\n   output [31:0] M_AXI_ARADDR,\n   output [7:0]  M_AXI_ARLEN,\n   output [2:0]  M_AXI_ARSIZE,\n   output [1:0]  M_AXI_ARBURST,\n   output [1:0]  M_AXI_ARLOCK,\n   output [3:0]  M_AXI_ARCACHE,\n   output [2:0]  M_AXI_ARPROT,\n   output [3:0]  M_AXI_ARQOS,\n   output [0:0]  M_AXI_ARUSER,\n   output        M_AXI_ARVALID,\n   input         M_AXI_ARREADY,\n\n   input [0:0]   M_AXI_RID,\n   input [31:0]  M_AXI_RDATA,\n   input [1:0]   M_AXI_RRESP,\n   input         M_AXI_RLAST,\n   input [0:0]   M_AXI_RUSER,\n   input         M_AXI_RVALID,\n   output        M_AXI_RREADY,\n\n   input         WR_REQ_START,\n   input [31:0]  WR_REQ_ADDR,\n   input [15:0]  WR_REQ_LEN,\n   output        WR_REQ_READY,\n   output [9:0]  WR_REQ_MEM_ADDR,\n   input [31:0]  WR_REQ_MEM_WDATA,\n\n   input         RD_REQ_START,\n   input [31:0]  RD_REQ_ADDR,\n   input [15:0]  RD_REQ_LEN,\n   output        RD_REQ_READY,\n   output        RD_REQ_MEM_WE,\n   output [9:0]  RD_REQ_MEM_ADDR,\n   output [31:0] RD_REQ_MEM_RDATA\n   );\n\n   localparam S_WR_REQ_IDLE  = 3'd0;\n   localparam S_WA_WAIT  = 3'd1;\n   localparam S_WA_START = 3'd2;\n   localparam S_WD_WAIT  = 3'd3;\n   localparam S_WD_PROC  = 3'd4;\n   localparam S_WR_REQ_WAIT  = 3'd5;\n\n   reg [2:0]     WR_REQ_state;\n   reg [31:0]    reg_WR_REQ_adrs;\n   reg [15:0]    reg_WR_REQ_len;\n   reg           reg_awvalid, reg_wvalid, reg_w_last;\n   reg [7:0]     reg_w_len;\n   reg [3:0]     reg_w_stb;\n   reg           reg_w_delay;\n   reg [31:0]    reg_w_data;\n   reg [13:0]    reg_wmem_addr;\n\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         WR_REQ_state            <= S_WR_REQ_IDLE;\n         reg_WR_REQ_adrs[31:0]   <= 32'd0;\n         reg_WR_REQ_len[15:0]    <= 16'd0;\n         reg_awvalid         <= 1'b0;\n         reg_wvalid          <= 1'b0;\n         reg_w_last          <= 1'b0;\n         reg_w_len[7:0]      <= 8'd0;\n         reg_w_stb[3:0]      <= 4'd0;\n         reg_wmem_addr       <= 13'd0;\n\t\t reg_w_data          <= 1'b0;\n\t\t reg_w_delay         <= 1'b0;\n      end else begin\n         case(WR_REQ_state)\n           S_WR_REQ_IDLE: begin\n              if(WR_REQ_START) begin\n                 WR_REQ_state          <= S_WA_START;\n                 reg_WR_REQ_adrs[31:0] <= WR_REQ_ADDR[31:0];\n                 reg_WR_REQ_len[15:0]  <= WR_REQ_LEN[15:0] -16'd1;\n              end\n              reg_awvalid         <= 1'b0;\n              reg_wvalid          <= 1'b0;\n              reg_w_last          <= 1'b0;\n              reg_w_len[7:0]      <= 8'd0;\n              reg_w_stb[3:0]      <= 4'd0;\n              reg_wmem_addr <= 13'd0;\n           end\n           S_WA_START: begin\n              WR_REQ_state            <= S_WD_WAIT;\n              reg_awvalid         <= 1'b1;\n              reg_WR_REQ_len[15:10]    <= reg_WR_REQ_len[15:10] - 6'd1;\n              if(reg_WR_REQ_len[15:10] != 6'd0) begin\n                 reg_w_len[7:0]  <= 8'hFF;\n                 reg_w_last      <= 1'b0;\n                 reg_w_stb[3:0]  <= 4'hF;\n              end else begin\n                 reg_w_len[7:0]  <= reg_WR_REQ_len[9:2];\n                 reg_w_last      <= 1'b1;\n                 reg_w_stb[3:0]  <= 4'hF;\n              end\n           end\n           S_WD_WAIT: begin\n              if(M_AXI_AWREADY) begin\n                 WR_REQ_state        <= S_WD_PROC;\n                 reg_awvalid     <= 1'b0;\n                 reg_wvalid      <= 1'b1;\n                 reg_wmem_addr  <= reg_wmem_addr +13'd1;\n              end\n           end\n           S_WD_PROC: begin\n              if(M_AXI_WREADY) begin\n                 if(reg_w_len[7:0] == 8'd0) begin\n                    WR_REQ_state        <= S_WR_REQ_WAIT;\n                    reg_wvalid      <= 1'b0;\n                    reg_w_stb[3:0]  <= 4'h0;\n                 end else begin\n                    reg_w_len[7:0]  <= reg_w_len[7:0] -8'd1;\n                    reg_wmem_addr  <= reg_wmem_addr +13'd1;\n                 end\n              end\n           end\n           S_WR_REQ_WAIT: begin\n              if(M_AXI_BVALID) begin\n                 if(reg_w_last) begin\n                    WR_REQ_state          <= S_WR_REQ_IDLE;\n                 end else begin\n                    WR_REQ_state          <= S_WA_START;\n                    reg_WR_REQ_adrs[31:0] <= reg_WR_REQ_adrs[31:0] + 32'd1024;\n                 end\n              end\n           end\n           default: begin\n              WR_REQ_state <= S_WR_REQ_IDLE;\n           end\n         endcase\n      end\n\n      reg_w_delay <= M_AXI_WREADY;\n      if((WR_REQ_state == S_WA_START) |\n         ((WR_REQ_state == S_WD_PROC) & reg_w_delay)) begin\n         reg_w_data <= WR_REQ_MEM_WDATA;\n      end\n   end\n\n   assign M_AXI_AWID         = 1'b0;\n   assign M_AXI_AWADDR[31:0] = reg_WR_REQ_adrs[31:0];\n   assign M_AXI_AWLEN[7:0]   = reg_w_len[7:0];\n   assign M_AXI_AWSIZE[2:0]  = 2'b010;\n   assign M_AXI_AWBURST[1:0] = 2'b01;\n   assign M_AXI_AWLOCK       = 1'b0;\n   assign M_AXI_AWCACHE[3:0] = 4'b0011;\n   assign M_AXI_AWPROT[2:0]  = 3'b000;\n   assign M_AXI_AWQOS[3:0]   = 4'b0000;\n   assign M_AXI_AWUSER[0]    = 1'b1;\n   assign M_AXI_AWVALID      = reg_awvalid;\n\nassign M_AXI_WDATA[31:0]  = (reg_w_delay)?WR_REQ_MEM_WDATA:reg_w_data;\n   assign M_AXI_WSTRB[3:0]   = (reg_wvalid)?reg_w_stb:4'h0;\n   assign M_AXI_WLAST        = (reg_w_len[7:0] == 8'd0)?1'b1:1'b0;\n   assign M_AXI_WUSER        = 1;\n   assign M_AXI_WVALID       = reg_wvalid;\n\n   assign M_AXI_BREADY       = (WR_REQ_state == S_WR_REQ_WAIT)?1'b1:1'b0;\n\n   assign WR_REQ_READY           = (WR_REQ_state == S_WR_REQ_IDLE)?1'b1:1'b0;\n   assign WR_REQ_MEM_ADDR        = reg_wmem_addr;\n\n   localparam S_RD_REQ_IDLE    = 3'd0;\n   localparam S_RS_REQUEST = 3'd1;\n   localparam S_RA_WAIT    = 3'd2;\n   localparam S_RA_START   = 3'd3;\n   localparam S_RD_REQ_WAIT    = 3'd4;\n   localparam S_RD_REQ_PROC    = 3'd5;\n\n   reg [2:0]   RD_REQ_state;\n   reg [31:0]  reg_RD_REQ_adrs;\n   reg [15:0]  reg_RD_REQ_len;\n   reg         reg_arvalid, reg_r_last;\n   reg [7:0]   reg_r_len;\n   reg [13:0]  reg_rmem_addr;\n\n   always @(posedge CLK or negedge RST_N) begin\n      if(!RST_N) begin\n         RD_REQ_state          <= S_RD_REQ_IDLE;\n         reg_RD_REQ_adrs[31:0] <= 32'd0;\n         reg_RD_REQ_len[15:0]  <= 16'd0;\n         reg_arvalid       <= 1'b0;\n         reg_r_len[7:0]    <= 8'd0;\n         reg_r_last        <= 1'b0;\n         reg_rmem_addr     <= 13'd0;\n      end else begin\n         case(RD_REQ_state)\n           S_RD_REQ_IDLE: begin\n              if(RD_REQ_START) begin\n                 RD_REQ_state          <= S_RA_START;\n                 reg_RD_REQ_adrs[31:0] <= RD_REQ_ADDR[31:0];\n                 reg_RD_REQ_len[15:0]  <= RD_REQ_LEN[15:0] -16'd1;\n              end\n              reg_arvalid     <= 1'b0;\n              reg_r_len[7:0]  <= 8'd0;\n              reg_rmem_addr   <= 13'd0;\n           end\n           S_RA_START: begin\n              RD_REQ_state          <= S_RD_REQ_WAIT;\n              reg_arvalid       <= 1'b1;\n              reg_RD_REQ_len[15:10] <= reg_RD_REQ_len[15:10] -6'd1;\n              if(reg_RD_REQ_len[15:10] != 16'd0) begin\n                 reg_r_last      <= 1'b0;\n                 reg_r_len[7:0]  <= 8'd255;\n              end else begin\n                 reg_r_last      <= 1'b1;\n                 reg_r_len[7:0]  <= reg_RD_REQ_len[9:2];\n              end\n           end\n           S_RD_REQ_WAIT: begin\n              if(M_AXI_ARREADY) begin\n                 RD_REQ_state        <= S_RD_REQ_PROC;\n                 reg_arvalid     <= 1'b0;\n              end\n           end\n           S_RD_REQ_PROC: begin\n              if(M_AXI_RVALID) begin\n                 reg_rmem_addr <= reg_rmem_addr +1;\n                 if(M_AXI_RLAST) begin\n                    if(reg_r_last) begin\n                       RD_REQ_state          <= S_RD_REQ_IDLE;\n                    end else begin\n                       RD_REQ_state          <= S_RA_START;\n                       reg_RD_REQ_adrs[31:0] <= reg_RD_REQ_adrs[31:0] + 32'd1024;\n                    end\n                 end else begin\n                    reg_r_len[7:0] <= reg_r_len[7:0] -8'd1;\n                 end\n              end\n           end\n         endcase\n      end\n   end\n\n   assign M_AXI_ARID         = 1'b0;\n   assign M_AXI_ARADDR[31:0] = reg_RD_REQ_adrs[31:0];\n   assign M_AXI_ARLEN[7:0]   = reg_r_len[7:0];\n   assign M_AXI_ARSIZE[2:0]  = 3'b010;\n   assign M_AXI_ARBURST[1:0] = 2'b01;\n   assign M_AXI_ARLOCK       = 1'b0;\n   assign M_AXI_ARCACHE[3:0] = 4'b0011;\n   assign M_AXI_ARPROT[2:0]  = 3'b000;\n   assign M_AXI_ARQOS[3:0]   = 4'b0000;\n   assign M_AXI_ARUSER[0]    = 1'b1;\n   assign M_AXI_ARVALID      = reg_arvalid;\n\n   assign M_AXI_RREADY       = 1'b1;\n\n   assign RD_REQ_READY           = (RD_REQ_state == S_RD_REQ_IDLE)?1'b1:1'b0;\n   assign RD_REQ_MEM_WE          = M_AXI_RVALID;\n   assign RD_REQ_MEM_ADDR        = reg_rmem_addr;\n   assign RD_REQ_MEM_RDATA        = M_AXI_RDATA[31:0];\n\nendmodule\n",
        "module_name": "fmrv32im_axim",
        "module_hash": "8ce458368b3ce74f307e86f814225fd0",
        "dataset_index": 19771
      },
      "vec_multiplier_d1243cd1": {
        "rtl_code": "module vec_multiplier (\n  input clk, rst,\n  input signed [7:0] vector1,\n  input signed [7:0] vector2,\n  output reg signed [15:0] product\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      product <= 0;\n    end\n    else begin\n      product <= vector1 * vector2;\n    end\n  end\n\nendmodule",
        "module_name": "vec_multiplier",
        "module_hash": "d1243cd12bcf2a97b9d7f2f1e80da5bf",
        "dataset_index": 20519
      },
      "fourBitAdder_2460be75": {
        "rtl_code": "\nmodule fourBitAdder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[3:0];\n    assign Cout = temp_sum[4];\n\nendmodule",
        "module_name": "fourBitAdder",
        "module_hash": "2460be758b1467ea076f8403f56d0522",
        "dataset_index": 17439
      },
      "sky130_fd_sc_hd__and2_1_e96a68f2": {
        "rtl_code": "\nmodule sky130_fd_sc_hd__and2_1 (\n    A,\n    B,\n    X\n);\n\n    input  A;\n    input  B;\n    output X;\n\n    wire _TECHMAP_FAIL_ = A && B;\n\n    assign X = _TECHMAP_FAIL_;\n\nendmodule\n\nmodule my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    sky130_fd_sc_hd__and2_1 base (\n        .A(A1),\n        .B(A2),\n        .X(Y)\n    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__and2_1",
        "module_hash": "e96a68f2c6acf5bff433c0171839e5e5",
        "dataset_index": 14785
      },
      "dff_ram_7389af5e": {
        "rtl_code": "module dff_ram (\n    input clk,\n    input rst_n,\n    input [3:0] d,\n    input we,\n    input [7:0] waddr,\n    input re,\n    input [7:0] raddr,\n    output reg [3:0] q\n);\n\n    reg [3:0] ram [0:7];\n    reg [2:0] read_ptr;\n    reg [2:0] write_ptr;\n    reg [2:0] next_write_ptr;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            q <= 4'b0;\n            read_ptr <= 3'b0;\n            write_ptr <= 3'b0;\n            next_write_ptr <= 3'b0;\n        end else begin\n            if (we) begin\n                ram[waddr][3:0] <= d;\n                next_write_ptr <= write_ptr + 1;\n            end\n            write_ptr <= next_write_ptr;\n            if (re) begin\n                q <= ram[raddr][3:0] ^ q;\n                read_ptr <= read_ptr + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule xor_ram (\n    input clk,\n    input rst_n,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    output reg [7:0] final_output\n);\n\n    reg [3:0] dff_data;\n    wire [3:0] ram_data;\n    wire [7:0] read_ptr;\n    wire [7:0] write_ptr;\n\n    dff_ram dff_ram_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .d(dff_data),\n        .we(1'b1),\n        .waddr(write_addr),\n        .re(read_en),\n        .raddr(read_addr),\n        .q(ram_data)\n    );\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            final_output <= 8'b0;\n        end else begin\n            dff_data <= write_data;\n            final_output <= {ram_data, dff_data};\n        end\n    end\n\nendmodule",
        "module_name": "dff_ram",
        "module_hash": "7389af5e7157dda961bb56e14b9372b6",
        "dataset_index": 11652
      },
      "uart_tx_0ce38646": {
        "rtl_code": "module uart_tx\n#(\n    parameter RTX_EXTERNAL_OVERRIDE = \"NO\"\n)\n(\n\tinput clk_i, rst_i,\n\n\tinput tx_start_i,\n\tinput [7:0] din_bi,\n\n\tinput locked_i,\n\tinput [28:0] bitperiod_i,\n\n\toutput reg tx_done_tick_o,\n\toutput reg tx_o\n);\n\nreg [7:0] \tdatabuf;\nreg [3:0] \tstate;\nreg [31:0] \tclk_counter;\nreg [2:0] \tbit_counter;\n\nlocalparam ST_IDLE \t\t= 8'h0;\nlocalparam ST_START \t= 8'h1;\nlocalparam ST_TX_DATA \t= 8'h2;\nlocalparam ST_STOP \t\t= 8'h3;\n\n\nalways @(posedge clk_i)\n\tbegin\n\tif (rst_i)\n\t\tbegin\n\t\tstate <= ST_IDLE;\n\t\tdatabuf <= 8'h0;\n\t\tclk_counter <= 32'h0;\n\t\ttx_o <= 1'b1;\n\t\ttx_done_tick_o <= 1'b0;\n\t\tend\n\telse \n\t\tbegin\n\t\t\n\t\t\n\t\tif (RTX_EXTERNAL_OVERRIDE == \"NO\") tx_done_tick_o <= 1'b0;\n\t\telse tx_done_tick_o <= 1'b1;\n\n\t\t\n\t\tcase (state)\n\n\t\t\tST_IDLE:\n\t\t\t\tbegin\n\t\t\t\ttx_o <= 1'b1;\n\t\t\t\tif ((tx_start_i == 1'b1) && (locked_i == 1'b1))\n\t\t\t\t\tbegin\n\t\t\t\t\ttx_o <= 1'b0;\n\t\t\t\t\tstate <= ST_START;\n\t\t\t\t\tdatabuf <= din_bi;\n\t\t\t\t\tclk_counter <= 32'h0;\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\tST_START:\n\t\t\t\tbegin\n\t\t\t\tclk_counter <= clk_counter + 32'h1;\n\t\t\t\tif (clk_counter == {3'h0, bitperiod_i})\n\t\t\t\t\tbegin\n\t\t\t\t\tstate <= ST_TX_DATA;\n\t\t\t\t\tclk_counter <= 32'h0;\n\t\t\t\t\tbit_counter <= 3'h0;\n\t\t\t\t\ttx_o <= databuf[0];\n\t\t\t\t\tdatabuf <= {1'b0, databuf[7:1]};\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\tST_TX_DATA:\n\t\t\t\tbegin\n\t\t\t\tclk_counter <= clk_counter + 32'h1;\n\t\t\t\tif (clk_counter == {3'h0, bitperiod_i})\n\t\t\t\t\tbegin\n\t\t\t\t\tclk_counter <= 32'h0;\n\t\t\t\t\tbit_counter <= bit_counter + 3'h1;\n\t\t\t\t\tif (bit_counter == 3'h7)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\ttx_o <= 1'b1;\n\t\t\t\t\t\tstate <= ST_STOP;\n\t\t\t\t\t\tend\n\t\t\t\t\telse \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\ttx_o <= databuf[0];\n\t\t\t\t\t\tdatabuf <= {1'b0, databuf[7:1]};\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\tST_STOP:\n\t\t\t\tbegin\n\t\t\t\tclk_counter <= clk_counter + 32'h1;\n\t\t\t\tif (clk_counter == {2'h0, bitperiod_i, 1'b0})\t\t// 2 * bit\n\t\t\t\t\tbegin\n\t\t\t\t\ttx_o <= 1'b1;\n\t\t\t\t\ttx_done_tick_o <= 1'b1;\n\t\t\t\t\tstate <= ST_IDLE;\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\tendcase\n\n\t\tend\n\tend\n\nendmodule",
        "module_name": "uart_tx",
        "module_hash": "0ce386465a43c380344bfe7057ba678c",
        "dataset_index": 7660
      },
      "calculator_8f7121c9": {
        "rtl_code": "module calculator (\n  input [7:0] A,\n  input [7:0] B,\n  input [1:0] op,\n  output reg [7:0] result\n);\n\nalways @(*) begin\n  case(op)\n    2'b00: result = A + B;\n    2'b01: result = A - B;\n    2'b10: result = A * B;\n    2'b11: result = A / B;\n  endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "8f7121c9cd2a53a31464ce852fbe989c",
        "dataset_index": 2001
      },
      "pcie_core_gtp_pipe_rate #_35daa010": {
        "rtl_code": "\n\n\n\nmodule pcie_core_gtp_pipe_rate #\n(\n\n    parameter PCIE_SIM_SPEEDUP = \"FALSE\",                   parameter TXDATA_WAIT_MAX  = 4'd15                      )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_DRP_DONE,\n    input               RATE_RXPMARESETDONE,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output              RATE_DRP_START,\n    output              RATE_DRP_X16,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [ 4:0]  RATE_FSM\n\n);\n\n        reg         [ 1:0]  rate_in_reg1;\n    reg                 drp_done_reg1;\n    reg                 rxpmaresetdone_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg         [ 1:0]  rate_in_reg2;\n    reg                 drp_done_reg2;\n    reg                 rxpmaresetdone_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel =  1'd0; \n    reg         [ 2:0]  rate_out =  3'd0; \n    reg         [ 3:0]  fsm      =  0;                 \n   \n    localparam          FSM_IDLE           = 0; \n    localparam          FSM_TXDATA_WAIT    = 1;           \n    localparam          FSM_PCLK_SEL       = 2; \n    localparam          FSM_DRP_X16_START  = 3;\n    localparam          FSM_DRP_X16_DONE   = 4;   \n    localparam          FSM_RATE_SEL       = 5;\n    localparam          FSM_RXPMARESETDONE = 6; \n    localparam          FSM_DRP_X20_START  = 7;\n    localparam          FSM_DRP_X20_DONE   = 8;   \n    localparam          FSM_RATE_DONE      = 9;\n    localparam          FSM_TXSYNC_START   = 10;\n    localparam          FSM_TXSYNC_DONE    = 11;             \n    localparam          FSM_DONE           = 12; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rate_in_reg1        <= 2'd0;\n        drp_done_reg1       <= 1'd0;\n        rxpmaresetdone_reg1 <= 1'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        drp_done_reg2       <= 1'd0;\n        rxpmaresetdone_reg2 <= 1'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rate_in_reg1        <= RATE_RATE_IN;\n        drp_done_reg1       <= RATE_DRP_DONE;\n        rxpmaresetdone_reg1 <= RATE_RXPMARESETDONE;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rate_in_reg2        <= rate_in_reg1;\n        drp_done_reg2       <= drp_done_reg1;\n        rxpmaresetdone_reg2 <= rxpmaresetdone_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if ((fsm == FSM_RATE_DONE) || (fsm == FSM_RXPMARESETDONE) || (fsm == FSM_DRP_X20_START) || (fsm == FSM_DRP_X20_DONE))\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm      <= FSM_IDLE;\n        pclk_sel <= 1'd0; \n        rate_out <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm      <= FSM_TXDATA_WAIT;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            else\n                begin\n                fsm      <= FSM_IDLE;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            end \n            \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm      <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_SEL : FSM_DRP_X16_START;    \n            pclk_sel <= (rate_in_reg2 == 2'd1);\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X16_DONE : FSM_DRP_X16_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_SEL : FSM_DRP_X16_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_DONE : FSM_RXPMARESETDONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate;                               end    \n            \n        FSM_RXPMARESETDONE :\n        \n            begin\n            fsm      <= (!rxpmaresetdone_reg2) ? FSM_DRP_X20_START : FSM_RXPMARESETDONE;  \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end  \n            \n        FSM_DRP_X20_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X20_DONE : FSM_DRP_X20_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X20_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_DONE : FSM_DRP_X20_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone) \n                fsm <= FSM_TXSYNC_START;\n            else      \n                fsm <= FSM_RATE_DONE;\n            \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm      <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm      <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm      <= FSM_IDLE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm      <= FSM_IDLE;\n            pclk_sel <= 1'd0; \n            rate_out <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL     = pclk_sel;\nassign RATE_DRP_START    = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X20_START); \nassign RATE_DRP_X16      = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X16_DONE);\nassign RATE_RATE_OUT     = rate_out;\nassign RATE_TXSYNC_START = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE         = (fsm == FSM_DONE);\nassign RATE_IDLE         = (fsm == FSM_IDLE);\nassign RATE_FSM          = {1'd0, fsm};   \n\n\n\nendmodule\n",
        "module_name": "pcie_core_gtp_pipe_rate #",
        "module_hash": "35daa010206f14f64e647d93f8c3daf3",
        "dataset_index": 23904
      },
      "Counter7SD_a69c8d33": {
        "rtl_code": "module Counter7SD(\n  clock,\n  reset,\n  pause,\n  reverse,\n  data\n  );\ninput             clock;\ninput             reset;\ninput             pause;\ninput             reverse;\noutput reg [6:0]  data;\n       reg [6:0]  temp_data;\nparameter ZERO  = 7'b1111110; parameter ONE   = 7'b0110000; parameter TWO   = 7'b1101101; parameter THREE = 7'b1101101; parameter FOUR  = 7'b0110011; parameter FIVE  = 7'b1011011; parameter SIX   = 7'b1011011; parameter SEVEN = 7'b1110000; parameter EIGHT = 7'b1111111; parameter NINE  = 7'b1111011; \n\nparameter PAUSE = 7'b1100111; parameter HOLD  = 7'b0110111; always @ ( posedge clock ) begin\n  if (pause==0)\n    data <= PAUSE;\n  else\n    data <= temp_data;\n  case(reset)\n    0: temp_data <= HOLD;\n    1: case (pause)\n              0: temp_data <= temp_data;\n        default: case (temp_data)\n                  HOLD:   case (reverse)\n                                  0: temp_data <= ZERO;\n                            default: temp_data <= NINE;\n                          endcase\n                  ZERO:   case (reverse)\n                                  0: temp_data <= ONE;\n                            default: temp_data <= NINE;\n                          endcase\n                  ONE:    case (reverse)\n                                  0: temp_data <= TWO;\n                            default: temp_data <= ZERO;\n                          endcase\n                  TWO:    case (reverse)\n                                  0: temp_data <= THREE;\n                            default: temp_data <= ONE;\n                          endcase\n                  THREE:  case (reverse)\n                                  0: temp_data <= FOUR;\n                            default: temp_data <= TWO;\n                          endcase\n                  FOUR:   case (reverse)\n                                  0: temp_data <= FIVE;\n                            default: temp_data <= THREE;\n                          endcase\n                  FIVE:   case (reverse)\n                                  0: temp_data <= SIX;\n                            default: temp_data <= FOUR;\n                          endcase\n                  SIX:     case (reverse)\n                                  0: temp_data <= SEVEN;\n                            default: temp_data <= FIVE;\n                          endcase\n                  SEVEN:  case (reverse)\n                                  0: temp_data <= EIGHT;\n                            default: temp_data <= SIX;\n                          endcase\n                  EIGHT:  case (reverse)\n                                  0: temp_data <= NINE;\n                            default: temp_data <= SEVEN;\n                          endcase\n                  NINE:   case (reverse)\n                                  0: temp_data <= ZERO;\n                            default: temp_data <= EIGHT;\n                          endcase\n                  default:temp_data <= HOLD;\n                endcase\n       endcase\n  endcase\nend\nendmodule ",
        "module_name": "Counter7SD",
        "module_hash": "a69c8d33feb2e8ff6759cc6298487020",
        "dataset_index": 21708
      },
      "D_FlipFlop_8b2e6b0f": {
        "rtl_code": "\nmodule D_FlipFlop (\n  output reg Q,\n  input D,\n  input CLK,\n  input RST\n);\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      Q <= 1'b0;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule\nmodule full_adder (\n  output S,\n  output C_out,\n  input A,\n  input B,\n  input C_in\n);\n\n  wire w1;\n  wire w2;\n\n  assign w1 = A ^ B;\n  assign w2 = A & B;\n\n  wire [0:0] CLK = 1'b0;\n  wire [0:0] RST = 1'b0;\n  wire [0:0] Q;\n\n  D_FlipFlop dffp1(\n    .Q(C_out),\n    .D(w2),\n    .CLK(CLK),\n    .RST(RST)\n  );\n\n  assign S = w1 ^ C_in;\nendmodule\nmodule ripple_adder (\n  output [3:0] Sum,\n  output Cout,\n  input [3:0] A,\n  input [3:0] B,\n  input Cin\n);\n\n  wire [3:0] s;\n  wire [3:0] c;\n\n  full_adder fa0(\n    .S(s[0]),\n    .C_out(c[0]),\n    .A(A[0]),\n    .B(B[0]),\n    .C_in(Cin)\n  );\n\n  full_adder fa1(\n    .S(s[1]),\n    .C_out(c[1]),\n    .A(A[1]),\n    .B(B[1]),\n    .C_in(c[0])\n  );\n\n  full_adder fa2(\n    .S(s[2]),\n    .C_out(c[2]),\n    .A(A[2]),\n    .B(B[2]),\n    .C_in(c[1])\n  );\n\n  full_adder fa3(\n    .S(s[3]),\n    .C_out(Cout),\n    .A(A[3]),\n    .B(B[3]),\n    .C_in(c[2])\n  );\n\n  assign Sum = s;\nendmodule",
        "module_name": "D_FlipFlop",
        "module_hash": "8b2e6b0f23ea1929b16ce6ece2312fbe",
        "dataset_index": 21430
      },
      "ff_inv_c3e5744b": {
        "rtl_code": "\n\nmodule ff_inv (\n\tinput clk,\n\tinput reset,\n\tinput [255:0] rx_a,\n\tinput [255:0] rx_p,\n\n\toutput reg tx_done,\n\toutput reg [255:0] tx_a\n);\n\n\treg [255:0] u, v, x, y;\n\treg x_carry, y_carry;\n\n\twire u_even = u[0] == 1'b0;\n\twire v_even = v[0] == 1'b0;\n\twire [256:0] u_minus_v = {1'b0, u} - {1'b0, v};\n\twire [256:0] v_minus_u = {1'b0, v} - {1'b0, u};\n\treg [256:0] x_adder, y_adder;\n\n\n\talways @ (*)\n\tbegin\n\t\tif (x_carry || y_carry)\n\t\tbegin\n\t\t\tx_adder = x + rx_p;\n\t\t\ty_adder = y + rx_p;\n\t\tend\n\t\telse if (u_even || v_even)\n\t\tbegin\n\t\t\tx_adder = x + rx_p;\n\t\t\ty_adder = y + rx_p;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tx_adder = x - y;\n\t\t\ty_adder = y - x;\n\t\tend\n\tend\n\n\n\talways @ (posedge clk)\n\tbegin\n\t\tif (u == 256'd1 && !tx_done)\n\t\tbegin\n\t\t\ttx_done <= 1'b1;\n\t\t\ttx_a <= x;\n\t\tend\n\t\telse if (v == 256'd1 && !tx_done)\n\t\tbegin\n\t\t\ttx_done <= 1'b1;\n\t\t\ttx_a <= y;\n\t\tend\n\n\t\tif (x_carry || y_carry)\n\t\tbegin\n\t\t\tx <= x_carry ? x_adder[255:0] : x;\n\t\t\ty <= y_carry ? y_adder[255:0] : y;\n\t\t\tx_carry <= 1'b0;\n\t\t\ty_carry <= 1'b0;\n\t\tend\n\t\telse if (u_even || v_even)\n\t\tbegin\n\t\t\tif (u_even)\n\t\t\tbegin\n\t\t\t\tu <= u >> 1;\n\t\t\t\tif (x[0] == 1'b0)\n\t\t\t\t\tx <= x >> 1;\n\t\t\t\telse\n\t\t\t\t\tx <= x_adder[256:1];\n\t\t\tend\n\n\t\t\tif (v_even)\n\t\t\tbegin\n\t\t\t\tv <= v >> 1;\n\t\t\t\tif (y[0] == 1'b0)\n\t\t\t\t\ty <= y >> 1;\n\t\t\t\telse\n\t\t\t\t\ty <= y_adder[256:1];\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (u_minus_v[256] == 1'b0)\tbegin\n\t\t\t\tu <= u_minus_v;\n\t\t\t\tx <= x_adder[255:0];\n\t\t\t\tx_carry <= x_adder[256];\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tv <= v_minus_u;\n\t\t\t\ty <= y_adder[255:0];\n\t\t\t\ty_carry <= y_adder[256];\n\t\t\tend\n\t\tend\n\n\t\tif (reset)\n\t\tbegin\n\t\t\tu <= rx_a;\n\t\t\tv <= rx_p;\n\t\t\tx <= 256'd1;\n\t\t\ty <= 256'd0;\n\t\t\tx_carry <= 1'b0;\n\t\t\ty_carry <= 1'b0;\n\t\t\ttx_done <= 1'b0;\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "ff_inv",
        "module_hash": "c3e5744b4ac540cbecf3874a83cf5c6b",
        "dataset_index": 23769
      },
      "adler_checksum_a7ce9e67": {
        "rtl_code": "module adler_checksum (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [31:0] data_len,\n  output reg [15:0] checksum,\n  output reg valid\n);\n\n  // Define constants\n  parameter PRIME = 65521;\n  parameter BLOCK_SIZE = 16;\n\n  // Define state machine states\n  localparam IDLE = 0;\n  localparam PROCESSING = 1;\n  localparam CHECKSUM = 2;\n\n  // Define state machine variables\n  reg [31:0] byte_count;\n  reg [15:0] rolling_sum;\n  reg [15:0] block_sum;\n  reg [1:0] state;\n\n  // Define internal signals\n  reg [7:0] data_in_reg;\n  reg [15:0] checksum_reg;\n\n  // Register input data on clock edge\n  always @(posedge clk) begin\n    if (reset) begin\n      data_in_reg <= 0;\n    end else begin\n      data_in_reg <= data_in;\n    end\n  end\n\n  // State machine\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      byte_count <= 0;\n      rolling_sum <= 1;\n      block_sum <= 0;\n      checksum <= 0;\n      valid <= 0;\n    end else begin\n      case (state)\n        IDLE: begin\n          // Wait for data to be valid\n          if (data_len > 0) begin\n            state <= PROCESSING;\n          end\n        end\n        PROCESSING: begin\n          // Add byte to rolling sum\n          rolling_sum <= (rolling_sum + data_in_reg) % PRIME;\n          block_sum <= (block_sum + data_in_reg) % PRIME;\n          byte_count <= byte_count + 1;\n\n          // Check if block is complete\n          if (byte_count == BLOCK_SIZE || byte_count == data_len) begin\n            state <= CHECKSUM;\n          end\n        end\n        CHECKSUM: begin\n          // Calculate final checksum\n          checksum_reg <= (block_sum << 16) + rolling_sum;\n          if (checksum_reg == checksum) begin\n            valid <= 1;\n          end else begin\n            valid <= 0;\n          end\n\n          // Reset state machine\n          byte_count <= 0;\n          rolling_sum <= 1;\n          block_sum <= 0;\n          checksum <= checksum_reg;\n          state <= IDLE;\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "adler_checksum",
        "module_hash": "a7ce9e671eabf1eb2b46bf79706d3e05",
        "dataset_index": 11589
      },
      "adder16_c9bc0e02": {
        "rtl_code": "module adder16(\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\n    wire [15:0] carry;\n    \n    assign carry[0] = cin;\n    genvar i;\n    generate\n        for (i = 1; i < 16; i = i + 1) begin\n            full_adder fa(\n                .a(a[i]),\n                .b(b[i]),\n                .cin(carry[i-1]),\n                .sum(sum[i]),\n                .cout(carry[i])\n            );\n        end\n    endgenerate\n    \n    assign sum[0] = a[0] ^ b[0] ^ cin;\n    assign cout = carry[15];\n    \nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n    \nendmodule",
        "module_name": "adder16",
        "module_hash": "c9bc0e02a0b7e1d1bbb4f8c3f4935515",
        "dataset_index": 12745
      },
      "rw_manager_lfsr36_08b57ba8": {
        "rtl_code": "\n\nmodule rw_manager_lfsr36(\n\tclk, \n\tnrst, \n\tena, \n\tword\n);\n\n\tinput clk;\n\tinput nrst;\n\tinput ena;\n\toutput reg [35:0] word;\n\n\talways @(posedge clk or negedge nrst) begin\n\t\tif(~nrst) begin\n\t\t\tword <= 36'hF0F0AA55;\n\t\tend\n\t\telse if(ena) begin\n\t\t\tword[35] <= word[0];\n\t\t\tword[34] <= word[35];\n\t\t\tword[33] <= word[34];\n\t\t\tword[32] <= word[33];\n\t\t\tword[31] <= word[32];\n\t\t\tword[30] <= word[31];\n\t\t\tword[29] <= word[30];\n\t\t\tword[28] <= word[29];\n\t\t\tword[27] <= word[28];\n\t\t\tword[26] <= word[27];\n\t\t\tword[25] <= word[26];\n\t\t\tword[24] <= word[25] ^ word[0];\n\t\t\tword[23] <= word[24];\n\t\t\tword[22] <= word[23];\n\t\t\tword[21] <= word[22];\n\t\t\tword[20] <= word[21];\n\t\t\tword[19] <= word[20];\n\t\t\tword[18] <= word[19];\n\t\t\tword[17] <= word[18];\n\t\t\tword[16] <= word[17];\n\t\t\tword[15] <= word[16];\n\t\t\tword[14] <= word[15];\n\t\t\tword[13] <= word[14];\n\t\t\tword[12] <= word[13];\n\t\t\tword[11] <= word[12];\n\t\t\tword[10] <= word[11];\n\t\t\tword[9] <= word[10];\n\t\t\tword[8] <= word[9];\n\t\t\tword[7] <= word[8];\n\t\t\tword[6] <= word[7];\n\t\t\tword[5] <= word[6];\n\t\t\tword[4] <= word[5];\n\t\t\tword[3] <= word[4];\n\t\t\tword[2] <= word[3];\n\t\t\tword[1] <= word[2];\n\t\t\tword[0] <= word[1];\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "rw_manager_lfsr36",
        "module_hash": "08b57ba88cda9465cfded41b85eb0b1b",
        "dataset_index": 12839
      },
      "johnson_counter_de568d38": {
        "rtl_code": "\nmodule johnson_counter (\n    input wire clk,\n    input wire rst_n,\n    output reg [7:0] out_vec\n);\n\nreg [7:0] state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        state <= 8'b00000000;\n    end else begin\n        state <= {state[6:0], state[7]};\n    end\nend\n\nalways @* begin\n    case(state)\n        8'b00000000: out_vec = 8'b00000000;\n        8'b10000000: out_vec = 8'b10000000;\n        8'b11000000: out_vec = 8'b11000000;\n        8'b11100000: out_vec = 8'b11100000;\n        8'b11110000: out_vec = 8'b11110000;\n        8'b01111000: out_vec = 8'b01111000;\n        8'b00111100: out_vec = 8'b00111100;\n        8'b00011110: out_vec = 8'b00011110;\n        8'b00001111: out_vec = 8'b00001111;\n        default: out_vec = 8'b00000000;\n    endcase\nend\n\nendmodule\nmodule binary_number_module (\n    input wire [3:0] in_vec,\n    output reg [3:0] out_vec,\n    output reg msb_out,\n    output reg mid_out,\n    output reg lsb_out\n);\n\nwire [3:0] temp_vec;\n\nassign temp_vec = in_vec;\n\nalways @* begin\n    out_vec = temp_vec;\n    msb_out = temp_vec[3];\n    mid_out = temp_vec[2];\n    lsb_out = temp_vec[1];\nend\n\nendmodule\nmodule functional_module (\n    input wire [7:0] in_vec_1,\n    input wire [3:0] in_vec_2,\n    output reg [7:0] out_vec\n);\n\nalways @* begin\n    out_vec = in_vec_1 | {4'b0000, in_vec_2};\nend\n\nendmodule\nmodule top_module ( \n    input wire clk, \n    input wire rst_n, \n    input wire [3:0] in_vec, \n    output wire [7:0] out_vec, \n    output wire msb_out, \n    output wire mid_out, \n    output wire lsb_out \n);\n\nwire [7:0] jc_out;\nwire [3:0] bn_out;\nwire bn_msb_out;\nwire bn_mid_out;\nwire bn_lsb_out;\n\njohnson_counter jc_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .out_vec(jc_out)\n);\n\nbinary_number_module bn_inst (\n    .in_vec(in_vec),\n    .out_vec(bn_out),\n    .msb_out(bn_msb_out),\n    .mid_out(bn_mid_out),\n    .lsb_out(bn_lsb_out)\n);\n\nfunctional_module fm_inst (\n    .in_vec_1(jc_out),\n    .in_vec_2(bn_out),\n    .out_vec(out_vec)\n);\n\nassign msb_out = bn_msb_out;\nassign mid_out = bn_mid_out;\nassign lsb_out = bn_lsb_out;\n\nendmodule",
        "module_name": "johnson_counter",
        "module_hash": "de568d389e0b584ee676fdeed029d6e6",
        "dataset_index": 6748
      },
      "shift_register_f795ea84": {
        "rtl_code": "module shift_register (\n    input        clk,\n    input        reset,\n    input  [7:0] data_in,\n    output [7:0] data_out\n);\n\n    reg [7:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'b0;\n        end else begin\n            shift_reg <= {shift_reg[6:0], data_in};\n        end\n    end\n\n    assign data_out = shift_reg;\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "f795ea842237177696a869a51b468e24",
        "dataset_index": 17775
      },
      "ham_15_11_decoder_a60860a0": {
        "rtl_code": "\nmodule ham_15_11_decoder (c,q);\n\toutput [10:0] q;\n\treg [10:0] q;\n\t\n\t\n\tinput [14:0] c;\n\t\n\t\n\treg [3:0] pb;\n\treg [3:0] s;\n\treg [3:0] temp;\n\treg [14:0] inputs;\n\t\n\talways @(c or q)\n\tbegin\n\t\n\t\t\n\t\tpb[0]=c[2]^c[4]^c[6]^c[8]^c[10]^c[12]^c[14];\n\t\tpb[1]=c[2]^c[5]^c[6]^c[9]^c[10]^c[13]^c[14];\n\t\tpb[2]=c[4]^c[5]^c[6]^c[11]^c[12]^c[13]^c[14];\n\t\tpb[3]=c[8]^c[9]^c[10]^c[11]^c[12]^c[13]^c[14];\ns[0] = c[0]^pb[0];\n\t\ts[1] = c[1]^pb[1];\n\t\ts[2] = c[3]^pb[2];\n\t\ts[3] = c[7]^pb[3];\n\t\n\t\tinputs=c;\n\t\n\t\t\t\n\t\t\n\t\ttemp=s[0]*1;\n\t\ttemp=temp+s[1]*2;\n\t\ttemp=temp+s[2]*4;\n\t\ttemp=temp+s[3]*8-1;\n\t\tinputs[temp]=c[temp]^1;\n\t\t\n\t\t\n\t\tq[0]=inputs[2];\n\t\tq[1]=inputs[4];\n\t\tq[2]=inputs[5];\n\t\tq[3]=inputs[6];\n\t\tq[4]=inputs[8];\n\t\tq[5]=inputs[9];\n\t\tq[6]=inputs[10];\n\t\tq[7]=inputs[11];\n\t\tq[8]=inputs[12];\n\t\tq[9]=inputs[13];\n\t\tq[10]=inputs[14];\n\n\tend\n\t\n\t\nendmodule\n\n\n\n\n\n\n\n\nmodule ham_decoder (cc,qq);\n\tinput [14:0] cc;\n\toutput [10:0] qq;\n\tham_15_11_decoder hdec (cc,qq);\nendmodule\n",
        "module_name": "ham_15_11_decoder",
        "module_hash": "a60860a06874b5a0afa7ec58d9bc8fdf",
        "dataset_index": 24738
      }
    },
    "batch_6913ad90f2d48190888153d96e63434c": {
      "top_module_8ce0d061": {
        "rtl_code": "module top_module(\n    input [31:0] a,\n    input [31:0] b,\n    input select,\n    output [31:0] sum\n);\n\n    wire [15:0] a_low, b_low;\n    wire carry_in;\n    wire [15:0] sum_low;\n\n    // Split the input numbers into high and low halves\n    assign a_low = a[15:0];\n    assign b_low = b[15:0];\n\n    // Instantiate the 16-bit adder module\n    adder16bit adder(\n        .a(a_low),\n        .b(b_low),\n        .carry_in(carry_in),\n        .sum(sum_low)\n    );\n\n    // Perform addition or subtraction based on select input\n    assign carry_in = (select) ? ~b[15] : 1'b0;\n    assign sum = (select) ? {~b,1'b1} + a : {sum_low,a[31:16]} + {a_low,b_low};\n\nendmodule\n\n// 16-bit adder module\nmodule adder16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input carry_in,\n    output [15:0] sum\n);\n\n    wire [15:0] sum_temp;\n\n    assign sum_temp = a + b + carry_in;\n    assign sum = sum_temp;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "8ce0d0616363e4cdfc2d6c8baf5c3af9",
        "dataset_index": 17535
      },
      "sky130_fd_sc_hd__nor4bb_f57d0a6d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nor4bb (\n    Y  ,\n    A  ,\n    B  ,\n    C_N,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n    input  D_N;\n\n    wire nor0_out  ;\n    wire and0_out_Y;\n\n    nor nor0 (nor0_out  , A, B              );\n    and and0 (and0_out_Y, nor0_out, C_N, D_N);\n    buf buf0 (Y         , and0_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nor4bb",
        "module_hash": "f57d0a6d2b7c01f63ec89e377b925535",
        "dataset_index": 16141
      },
      "input_pipeline_0ed15bd8": {
        "rtl_code": "module input_pipeline (\n    clk,\n    clk_ena,\n    in_stream,\n    pipeline_reg_0,\n    pipeline_reg_1,\n    pipeline_reg_2,\n    pipeline_reg_3,\n    pipeline_reg_4,\n    pipeline_reg_5,\n    pipeline_reg_6,\n    pipeline_reg_7,\n    pipeline_reg_8,\n    pipeline_reg_9,\n    pipeline_reg_10,\n    pipeline_reg_11,\n    pipeline_reg_12,\n    pipeline_reg_13,\n    pipeline_reg_14,\n    pipeline_reg_15,\n    pipeline_reg_16,\n    pipeline_reg_17,\n    pipeline_reg_18,\n    pipeline_reg_19,\n    pipeline_reg_20,\n    pipeline_reg_21,\n    pipeline_reg_22,\n    pipeline_reg_23,\n    reset);\n    \n    parameter WIDTH = 1;\n    \n    input clk;\n    input clk_ena;\n    input [WIDTH-1:0] in_stream;\n    output [WIDTH-1:0] pipeline_reg_0;\n    output [WIDTH-1:0] pipeline_reg_1;\n    output [WIDTH-1:0] pipeline_reg_2;\n    output [WIDTH-1:0] pipeline_reg_3;\n    output [WIDTH-1:0] pipeline_reg_4;\n    output [WIDTH-1:0] pipeline_reg_5;\n    output [WIDTH-1:0] pipeline_reg_6;\n    output [WIDTH-1:0] pipeline_reg_7;\n    output [WIDTH-1:0] pipeline_reg_8;\n    output [WIDTH-1:0] pipeline_reg_9;\n    output [WIDTH-1:0] pipeline_reg_10;\n    output [WIDTH-1:0] pipeline_reg_11;\n    output [WIDTH-1:0] pipeline_reg_12;\n    output [WIDTH-1:0] pipeline_reg_13;\n    output [WIDTH-1:0] pipeline_reg_14;\n    output [WIDTH-1:0] pipeline_reg_15;\n    output [WIDTH-1:0] pipeline_reg_16;\n    output [WIDTH-1:0] pipeline_reg_17;\n    output [WIDTH-1:0] pipeline_reg_18;\n    output [WIDTH-1:0] pipeline_reg_19;\n    output [WIDTH-1:0] pipeline_reg_20;\n    output [WIDTH-1:0] pipeline_reg_21;\n    output [WIDTH-1:0] pipeline_reg_22;\n    output [WIDTH-1:0] pipeline_reg_23;\n    \n    reg [WIDTH-1:0] pipeline_reg_0;\n    reg [WIDTH-1:0] pipeline_reg_1;\n    reg [WIDTH-1:0] pipeline_reg_2;\n    reg [WIDTH-1:0] pipeline_reg_3;\n    reg [WIDTH-1:0] pipeline_reg_4;\n    reg [WIDTH-1:0] pipeline_reg_5;\n    reg [WIDTH-1:0] pipeline_reg_6;\n    reg [WIDTH-1:0] pipeline_reg_7;\n    reg [WIDTH-1:0] pipeline_reg_8;\n    reg [WIDTH-1:0] pipeline_reg_9;\n    reg [WIDTH-1:0] pipeline_reg_10;\n    reg [WIDTH-1:0] pipeline_reg_11;\n    reg [WIDTH-1:0] pipeline_reg_12;\n    reg [WIDTH-1:0] pipeline_reg_13;\n    reg [WIDTH-1:0] pipeline_reg_14;\n    reg [WIDTH-1:0] pipeline_reg_15;\n    reg [WIDTH-1:0] pipeline_reg_16;\n    reg [WIDTH-1:0] pipeline_reg_17;\n    reg [WIDTH-1:0] pipeline_reg_18;\n    reg [WIDTH-1:0] pipeline_reg_19;\n    reg [WIDTH-1:0] pipeline_reg_20;\n    reg [WIDTH-1:0] pipeline_reg_21;\n    reg [WIDTH-1:0] pipeline_reg_22;\n    reg [WIDTH-1:0] pipeline_reg_23;\n    \n    input reset;\n    \n    always@(posedge clk or posedge reset) begin\n        if(reset) begin\n            pipeline_reg_0 <= 0;\n            pipeline_reg_1 <= 0;\n            pipeline_reg_2 <= 0;\n            pipeline_reg_3 <= 0;\n            pipeline_reg_4 <= 0;\n            pipeline_reg_5 <= 0;\n            pipeline_reg_6 <= 0;\n            pipeline_reg_7 <= 0;\n            pipeline_reg_8 <= 0;\n            pipeline_reg_9 <= 0;\n            pipeline_reg_10 <= 0;\n            pipeline_reg_11 <= 0;\n            pipeline_reg_12 <= 0;\n            pipeline_reg_13 <= 0;\n            pipeline_reg_14 <= 0;\n            pipeline_reg_15 <= 0;\n            pipeline_reg_16 <= 0;\n            pipeline_reg_17 <= 0;\n            pipeline_reg_18 <= 0;\n            pipeline_reg_19 <= 0;\n            pipeline_reg_20 <= 0;\n            pipeline_reg_21 <= 0;\n            pipeline_reg_22 <= 0;\n            pipeline_reg_23 <= 0;\n        end else begin\n            if(clk_ena) begin\n                pipeline_reg_23 <= pipeline_reg_22;\n                pipeline_reg_22 <= pipeline_reg_21;\n                pipeline_reg_21 <= pipeline_reg_20;\n                pipeline_reg_20 <= pipeline_reg_19;\n                pipeline_reg_19 <= pipeline_reg_18;\n                pipeline_reg_18 <= pipeline_reg_17;\n                pipeline_reg_17 <= pipeline_reg_16;\n                pipeline_reg_16 <= pipeline_reg_15;\n                pipeline_reg_15 <= pipeline_reg_14;\n                pipeline_reg_14 <= pipeline_reg_13;\n                pipeline_reg_13 <= pipeline_reg_12;\n                pipeline_reg_12 <= pipeline_reg_11;\n                pipeline_reg_11 <= pipeline_reg_10;\n                pipeline_reg_10 <= pipeline_reg_9;\n                pipeline_reg_9 <= pipeline_reg_8;\n                pipeline_reg_8 <= pipeline_reg_7;\n                pipeline_reg_7 <= pipeline_reg_6;\n                pipeline_reg_6 <= pipeline_reg_5;\n                pipeline_reg_5 <= pipeline_reg_4;\n                pipeline_reg_4 <= pipeline_reg_3;\n                pipeline_reg_3 <= pipeline_reg_2;\n                pipeline_reg_2 <= pipeline_reg_1;\n                pipeline_reg_1 <= pipeline_reg_0;\n                pipeline_reg_0 <= in_stream;\n            end\n        end\n    end\nendmodule",
        "module_name": "input_pipeline",
        "module_hash": "0ed15bd8da5d9d4a4fef87be2862e0bf",
        "dataset_index": 257
      },
      "dffl_64_57258451": {
        "rtl_code": "module dffl_64 ( clk, ld, d, rst, q );\n    input clk;\n    input ld;\n    input rst;\n    input [63:0] d;\n    output [63:0] q;\n    reg [63:0] q;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            q <= 0;\n        end else if (ld) begin\n            q <= d;\n        end\n    end\nendmodule",
        "module_name": "dffl_64",
        "module_hash": "57258451b1dd42991e5270979220f68d",
        "dataset_index": 10156
      },
      "top__feb2e0de": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,            // Synchronous active-high reset\n    input [15:0] in,        // 16-bit input\n    output [7:0] out_hi,    // 8-bit output for the upper byte\n    output [7:0] out_lo,    // 8-bit output for the lower byte\n    output [7:0] out         // 8-bit output for the final output\n);\n\n    wire [7:0] hi_reg;\n    wire [7:0] lo_reg;\n    wire [7:0] out_reg;\n\n    barrel_shifter shifter(.in(in), .out(hi_reg));\n    flip_flop lo_dff(.clk(clk), .reset(reset), .d(in[7:0]), .q(lo_reg));\n    functional_module func(.in1(hi_reg), .in2(lo_reg), .out(out_reg));\n\n    assign out_hi = hi_reg;\n    assign out_lo = lo_reg;\n    assign out = out_reg;\n\nendmodule\nmodule barrel_shifter (\n    input [15:0] in,        // 16-bit input\n    output [7:0] out    // 8-bit output for the upper byte\n);\n\n    assign out = in[15:8];\n\nendmodule\nmodule flip_flop (\n    input clk,\n    input reset,            // Asynchronous active-high reset\n    input [7:0] d,          // 8-bit input\n    output reg [7:0] q      // 8-bit output (complement of input)\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 8'h00;\n        end else begin\n            q <= ~d;\n        end\n    end\n\nendmodule\nmodule functional_module (\n    input [7:0] in1,        // 8-bit input from the barrel shifter\n    input [7:0] in2,        // 8-bit input from the flip-flop\n    output [7:0] out    // 8-bit output (OR of the two inputs)\n);\n\n    assign out = in1 | in2;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "feb2e0de5bf53896a7397ffdf40a6d40",
        "dataset_index": 11957
      },
      "TFFSR_1031f89d": {
        "rtl_code": "module TFFSR (D, S, R, CLK, Q, QN);\ninput D;\ninput S;\ninput R;\ninput CLK;\noutput Q;\noutput QN;\n\nreg Q;\nreg QN;\n\nalways @(posedge CLK) begin\n  if (S == 1'b1) begin\n    Q <= 1'b1;\n    QN <= 1'b0;\n  end else if (R == 1'b1) begin\n    Q <= 1'b0;\n    QN <= 1'b1;\n  end else begin\n    Q <= D ^ Q;\n    QN <= ~Q;\n  end\nend\n\nendmodule",
        "module_name": "TFFSR",
        "module_hash": "1031f89dc412579fe9b88793494e4007",
        "dataset_index": 8711
      },
      "TurnSignal_7ed9a6fb": {
        "rtl_code": "module TurnSignal(\n\tinput reset, left, right, clk,\n\toutput LA, LB, LC, RA, RB, RC\n);\n\nparameter ST_IDLE = 3'b000;\nparameter ST_L1 = 3'b001;\nparameter ST_L2 = 3'b010;\nparameter ST_L3 = 3'b011;\nparameter ST_R1 = 3'b100;\nparameter ST_R2 = 3'b101;\nparameter ST_R3 = 3'b110;\n\nreg [2:0] state, next_state;\n\nalways @(posedge clk)\n\tif (reset)\n\t\tstate <= ST_IDLE;\n\telse\n\t\tstate <= next_state;\n\nalways @*\nbegin\n\tcase (state)\n\t\tST_IDLE: begin\n\t\t\tif (left && ~right)\n\t\t\t\tnext_state = ST_L1;\n\t\t\telse if (~left && right)\n\t\t\t\tnext_state = ST_R1;\n\t\t\telse\n\t\t\t\tnext_state = ST_IDLE;\n\t\tend\n\t\tST_L1: next_state = ST_L2;\n\t\tST_L2: next_state = ST_L3;\n\t\tST_R1: next_state = ST_R2;\n\t\tST_R2: next_state = ST_R3;\n\t\tdefault: next_state = ST_IDLE;\n\tendcase\n\tif (left && right)\n\t\tnext_state = ST_IDLE;\n\nend\n\nassign LA = state == ST_L1 || state == ST_L2 || state == ST_L3;\nassign LB = state == ST_L2 || state == ST_L3;\nassign LC = state == ST_L3;\nassign RA = state == ST_R1 || state == ST_R2 || state == ST_R3;\nassign RB = state == ST_R2 || state == ST_R3;\nassign RC = state == ST_R3;\n\nendmodule",
        "module_name": "TurnSignal",
        "module_hash": "7ed9a6fb2dc0ea693f8aff3002f226ac",
        "dataset_index": 5061
      },
      "adder_subtractor_f1c13caa": {
        "rtl_code": "\nmodule adder_subtractor (\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output reg [31:0] sum,\n    output reg [31:0] sum_reverse\n);\n    always @(*) begin\n        sum = sub ? a - b : a + b;\n        sum_reverse = {sum[31:24], sum[23:16], sum[15:8], sum[7:0]};\n    end\nendmodule\nmodule byte_reversal (\n    input [31:0] input_data,\n    output reg [31:0] output_data\n);\n    always @(*) begin\n        output_data = {input_data[31:24], input_data[23:16], input_data[15:8], input_data[7:0]};\n    end\nendmodule\nmodule functional_module (\n    input [31:0] input1,\n    input [31:0] input2,\n    output reg [31:0] final_output\n);\n    always @(*) begin\n        final_output = input1 + input2;\n    end\nendmodule\nmodule top_module (\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum,\n    output [31:0] sum_reverse,\n    output [31:0] final_output\n);\n    wire [31:0] add_sub_result;\n    wire [31:0] byte_reversal_result;\n    adder_subtractor add_sub_module (\n        .a(a),\n        .b(b),\n        .sub(sub),\n        .sum(add_sub_result)\n    );\n    byte_reversal byte_reversal_module (\n        .input_data(add_sub_result),\n        .output_data(byte_reversal_result)\n    );\n    functional_module functional_module (\n        .input1(byte_reversal_result),\n        .input2(add_sub_result),\n        .final_output(final_output)\n    );\n    assign sum = add_sub_result;\n    assign sum_reverse = byte_reversal_result;\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "f1c13caa0f5959028c311e8aa4285c07",
        "dataset_index": 11620
      },
      "shift_left__27efac3f": {
        "rtl_code": "\nmodule shift_left_module (\n    input [99:0] in,\n    input [5:0] shift_amount,\n    output [99:0] out\n);\n    assign out = {in[shift_amount-1:0], {94{1'b0}}, in[99:shift_amount]};\nendmodule\nmodule accumulator (\n    input [7:0] data_in,\n    input clk,\n    input rst_n,\n    output [7:0] accum_out\n);\n    reg [7:0] accum_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            accum_reg <= 8'b0;\n        end\n        else begin\n            accum_reg <= accum_reg + data_in;\n        end\n    end\n    assign accum_out = accum_reg;\nendmodule\nmodule sum_module (\n    input [99:0] shift_out,\n    input [7:0] accum_out,\n    input select,\n    output [107:0] out\n);\n    assign out = {shift_out, accum_out};\nendmodule\nmodule top_module (\n    input clk,\n    input rst_n,\n    input [99:0] in,\n    input [5:0] shift_amount,\n    input [7:0] data_in,\n    input valid_a,\n    input ready_b,\n    input select,\n    output ready_a,\n    output valid_b,\n    output [107:0] out\n);\n    wire [99:0] shift_out;\n    wire [7:0] accum_out;\n\n    shift_left_module shift_left_inst (\n        .in(in),\n        .shift_amount(shift_amount),\n        .out(shift_out)\n    );\n\n    accumulator accum_inst (\n        .data_in(data_in),\n        .clk(clk),\n        .rst_n(rst_n),\n        .accum_out(accum_out)\n    );\n\n    sum_module sum_inst (\n        .shift_out(shift_out),\n        .accum_out(accum_out),\n        .select(select),\n        .out(out)\n    );\n\n    assign ready_a = ~valid_a | valid_b;\n    assign valid_b = ready_b;\nendmodule",
        "module_name": "shift_left_",
        "module_hash": "27efac3fc9c0371a6ad245694a69e8e8",
        "dataset_index": 2878
      },
      "nor4_gate_0280d592": {
        "rtl_code": "\nmodule nor4_gate(\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\n    nor (Y, A, B, C, D);\n\nendmodule\n",
        "module_name": "nor4_gate",
        "module_hash": "0280d592b73f906a75ba0bf2a3e5a2ef",
        "dataset_index": 15296
      },
      "top__16ae41b5": {
        "rtl_code": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] c;\n    wire [7:0] p;\n    wire [7:0] g;\n    wire [7:0] c_out;\n\n    carry_lookahead_adder adder(\n        .a(a),\n        .b(b),\n        .c_in(1'b0),\n        .s(s),\n        .c(c_out),\n        .p(p),\n        .g(g)\n    );\n\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\n\nmodule carry_lookahead_adder (\n    input [7:0] a,\n    input [7:0] b,\n    input c_in,\n    output [7:0] s,\n    output [7:0] c,\n    output [7:0] p,\n    output [7:0] g\n);\n\n    wire [7:0] p0;\n    wire [7:0] g0;\n    wire [7:0] p1;\n    wire [7:0] g1;\n    wire [7:0] p2;\n    wire [7:0] g2;\n    wire [7:0] p3;\n    wire [7:0] g3;\n    wire [7:0] p4;\n    wire [7:0] g4;\n    wire [7:0] p5;\n    wire [7:0] g5;\n    wire [7:0] p6;\n    wire [7:0] g6;\n    wire [7:0] p7;\n    wire [7:0] g7;\n\n    assign p0 = a[0] ^ b[0];\n    assign g0 = a[0] & b[0];\n    assign p1 = a[1] ^ b[1] ^ g0;\n    assign g1 = (a[1] & b[1]) | (g0 & (a[1] ^ b[1]));\n    assign p2 = a[2] ^ b[2] ^ g1;\n    assign g2 = (a[2] & b[2]) | (g1 & (a[2] ^ b[2]));\n    assign p3 = a[3] ^ b[3] ^ g2;\n    assign g3 = (a[3] & b[3]) | (g2 & (a[3] ^ b[3]));\n    assign p4 = a[4] ^ b[4] ^ g3;\n    assign g4 = (a[4] & b[4]) | (g3 & (a[4] ^ b[4]));\n    assign p5 = a[5] ^ b[5] ^ g4;\n    assign g5 = (a[5] & b[5]) | (g4 & (a[5] ^ b[5]));\n    assign p6 = a[6] ^ b[6] ^ g5;\n    assign g6 = (a[6] & b[6]) | (g5 & (a[6] ^ b[6]));\n    assign p7 = a[7] ^ b[7] ^ g6;\n    assign g7 = (a[7] & b[7]) | (g6 & (a[7] ^ b[7]));\n\n    assign s = {p7, p6, p5, p4, p3, p2, p1, p0};\n    assign c = {g7, g6, g5, g4, g3, g2, g1, g0};\n    assign p = {p7, p6, p5, p4, p3, p2, p1, p0};\n    assign g = {g7, g6, g5, g4, g3, g2, g1, g0, c_in};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "16ae41b55663cc38a121edbe04899a70",
        "dataset_index": 1971
      },
      "mealy_state_machine_c925169e": {
        "rtl_code": "module mealy_state_machine (\n  input clk,\n  input reset,\n  input in1,\n  input in2,\n  output reg out1,\n  output reg out2\n);\n\n  parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n  reg [2:0] state, next_state;\n  \n  always @(posedge clk, negedge reset) begin\n    if (!reset) begin\n      state <= A;\n      out1 <= 1'b0;\n      out2 <= 1'b0;\n    end else begin\n      state <= next_state;\n      case (state)\n        A: begin\n          if (in1 == 1'b0 && in2 == 1'b0) begin\n            next_state <= B;\n            out1 <= 1'b1;\n            out2 <= 1'b0;\n          end else if (in1 == 1'b0 && in2 == 1'b1) begin\n            next_state <= A;\n            out1 <= 1'b0;\n            out2 <= 1'b0;\n          end else if (in1 == 1'b1 && in2 == 1'b0) begin\n            next_state <= D;\n            out1 <= 1'b0;\n            out2 <= 1'b1;\n          end else begin // in1 == 1'b1 && in2 == 1'b1\n            next_state <= C;\n            out1 <= 1'b1;\n            out2 <= 1'b1;\n          end\n        end\n        B: begin\n          if (in1 == 1'b0 && in2 == 1'b0) begin\n            next_state <= C;\n            out1 <= 1'b0;\n            out2 <= 1'b1;\n          end else if (in1 == 1'b0 && in2 == 1'b1) begin\n            next_state <= B;\n            out1 <= 1'b0;\n            out2 <= 1'b0;\n          end else if (in1 == 1'b1 && in2 == 1'b0) begin\n            next_state <= E;\n            out1 <= 1'b1;\n            out2 <= 1'b0;\n          end else begin // in1 == 1'b1 && in2 == 1'b1\n            next_state <= A;\n            out1 <= 1'b0;\n            out2 <= 1'b1;\n          end\n        end\n        C: begin\n          if (in1 == 1'b0 && in2 == 1'b0) begin\n            next_state <= A;\n            out1 <= 1'b1;\n            out2 <= 1'b1;\n          end else if (in1 == 1'b0 && in2 == 1'b1) begin\n            next_state <= C;\n            out1 <= 1'b0;\n            out2 <= 1'b1;\n          end else if (in1 == 1'b1 && in2 == 1'b0) begin\n            next_state <= B;\n            out1 <= 1'b1;\n            out2 <= 1'b1;\n          end else begin // in1 == 1'b1 && in2 == 1'b1\n            next_state <= D;\n            out1 <= 1'b0;\n            out2 <= 1'b1;\n          end\n        end\n        D: begin\n          if (in1 == 1'b0 && in2 == 1'b0) begin\n            next_state <= E;\n            out1 <= 1'b0;\n            out2 <= 1'b0;\n          end else if (in1 == 1'b0 && in2 == 1'b1) begin\n            next_state <= D;\n            out1 <= 1'b0;\n            out2 <= 1'b0;\n          end else if (in1 == 1'b1 && in2 == 1'b0) begin\n            next_state <= C;\n            out1 <= 1'b1;\n            out2 <= 1'b1;\n          end else begin // in1 == 1'b1 && in2 == 1'b1\n            next_state <= B;\n            out1 <= 1'b0;\n            out2 <= 1'b0;\n          end\n        end\n        E: begin\n          next_state <= E;\n          if (in1 == 1'b0 && in2 == 1'b0) begin\n            out1 <= 1'b1;\n            out2 <= 1'b0;\n          end else if (in1 == 1'b0 && in2 == 1'b1) begin\n            out1 <= 1'b1;\n            out2 <= 1'b0;\n          end else if (in1 == 1'b1 && in2 == 1'b0) begin\n            out1 <= 1'b0;\n            out2 <= 1'b0;\n          end else begin // in1 == 1'b1 && in2 == 1'b1\n            out1 <= 1'b1;\n            out2 <= 1'b0;\n          end\n        end\n      endcase\n    end\n  end\n  \nendmodule\n",
        "module_name": "mealy_state_machine",
        "module_hash": "c925169e57fce329a5a5cad185e7e17d",
        "dataset_index": 5643
      },
      "Controller_b56c45a8": {
        "rtl_code": "module Controller(input clk,rst,output reg RdOrR2,AluOrMem,RFWE,MWE,output reg[1:0] stackContrl,pcContrl,input Zero,Cout,input[5:0] cntlInstruc);\n\t\n\t\n\talways@(rst,Zero,Cout,cntlInstruc)\n\tbegin\n\t\tif((cntlInstruc[5] == 1'b0) || (cntlInstruc[5:3] == 3'b110))  begin\n\t\t\tRdOrR2=1'b0;\n\t\t\tAluOrMem=1'b1;\n\t\t\tRFWE=1'b1;\n\t\t\tMWE=1'b0;\n\t\t\tstackContrl=2'b00;\n\t\t\tpcContrl=2'b00;\n\t\tend\n\t\telse if(cntlInstruc[5:1] == 5'b10000) begin\n\t\t\tRdOrR2=1'b0;\n\t\t\tAluOrMem=1'b0;\n\t\t\tRFWE=1'b1;\n\t\t\tMWE=1'b0;\n\t\t\tstackContrl=2'b00;\n\t\t\tpcContrl=2'b00;\n\t\tend\n\t\telse if(cntlInstruc[5:1] == 5'b10001) begin\n\t\t\tRdOrR2=1'b1;\n\t\t\tAluOrMem=1'b1;RFWE=1'b0;\n\t\t\tMWE=1'b1;\n\t\t\tstackContrl=2'b00;\n\t\t\tpcContrl=2'b00;\n\t\tend\n\t\telse if(cntlInstruc[5:3] == 3'b101) begin\n\t\t\tRdOrR2=1'b0;AluOrMem=1'b1;RFWE=1'b0;\n\t\t\tMWE=1'b0;\n\t\t\tstackContrl=2'b00;\n\t\t\tcase(cntlInstruc[2:1])\n\t\t\t\t2'b00: pcContrl= Zero ? 2'b01 : 2'b00;\n\t\t\t\t2'b01: pcContrl= (~Zero) ? 2'b01 : 2'b00;\n\t\t\t\t2'b10: pcContrl= Cout ? 2'b01 : 2'b00;\n\t\t\t\t2'b11: pcContrl= (~Cout) ? 2'b01 : 2'b00;\n\t\t\tendcase\n\t\tend\n\t\telse if(cntlInstruc[5:1] == 5'b11100) begin\n\t\t\tRdOrR2=1'b0;AluOrMem=1'b1;RFWE=1'b0;\n\t\t\tMWE=1'b0;\n\t\t\tstackContrl=2'b00;\n\t\t\tpcContrl=2'b11;\n\t\tend\n\t\telse if(cntlInstruc[5:1] == 5'b11101) begin\n\t\t\tRdOrR2=1'b0;AluOrMem=1'b1;RFWE=1'b0;\n\t\t\tMWE=1'b0;\n\t\t\tstackContrl=2'b01;\n\t\t\tpcContrl=2'b11;\n\t\tend\n\t\telse if(cntlInstruc[5:0] == 6'b111100) begin\n\t\t\tRdOrR2=1'b0;AluOrMem=1'b1;RFWE=1'b0;\n\t\t\tMWE=1'b0;\n\t\t\tstackContrl=2'b10;\n\t\t\tpcContrl=2'b10;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tRdOrR2=1'b0;\n\t\t\tAluOrMem=1'b0;\n\t\t\tRFWE=1'b0;\n\t\t\tMWE=1'b0;\n\t\t\tstackContrl=2'b00;\n\t\t\tpcContrl=2'b00;\n\t\tend\n\tend\nendmodule\n",
        "module_name": "Controller",
        "module_hash": "b56c45a8eb8fc9cbd7bf95350b004a7f",
        "dataset_index": 23436
      },
      "mux4to1_17bd720e": {
        "rtl_code": "module mux4to1 (\n  q,\n  i0,\n  i1,\n  i2,\n  i3,\n  sel\n);\n  output q;\n  input i0;\n  input i1;\n  input i2;\n  input i3;\n  input [1:0] sel;\n\n  wire w0, w1, w2, w3;\n\n  assign w0 = sel[0] & sel[1] ? i3 : i2;\n  assign w1 = sel[0] & sel[1] ? i2 : i1;\n  assign w2 = sel[0] & sel[1] ? i1 : i0;\n  assign w3 = sel[0] & sel[1] ? i0 : i3;\n\n  assign q = sel[0] & sel[1] ? w0 : sel[0] & ~sel[1] ? w1 : ~sel[0] & sel[1] ? w2 : w3;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "17bd720e5c9d8eb9b41e855a5808d591",
        "dataset_index": 6367
      },
      "combinational_circuit_0d29277a": {
        "rtl_code": "module combinational_circuit (\n    input A1,\n    input A2,\n    input B1_N,\n    output reg Y\n);\n\nalways @* begin\n    if (A1 && A2) begin\n        Y = 1;\n    end else if (A1 && !A2) begin\n        Y = 0;\n    end else if (!A1 && A2) begin\n        Y = 0;\n    end else begin\n        Y = B1_N;\n    end\nend\n\nendmodule",
        "module_name": "combinational_circuit",
        "module_hash": "0d29277aad7108a2d0dc039f3ab8e16d",
        "dataset_index": 13307
      },
      "d_ff_with_async_reset_set_a58267f0": {
        "rtl_code": "module d_ff_with_async_reset_set (\n    input D,\n    input CLK,\n    input SCD,\n    input SCE,\n    output Q,\n    output Q_N\n);\n\n    reg Q;\n    reg Q_N;\n\n    always @(posedge CLK) begin\n        if (SCD) begin\n            Q <= 0;\n            Q_N <= 1;\n        end\n        else if (SCE) begin\n            Q <= 1;\n            Q_N <= 0;\n        end\n        else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule",
        "module_name": "d_ff_with_async_reset_set",
        "module_hash": "a58267f0fe5f032dffe704dc6638c4d1",
        "dataset_index": 14025
      },
      "interrupt_controller_2c8bcd3d": {
        "rtl_code": "`define S_INTRCTLR_IDLE\t\t\t\t3'd0\n`define S_INTRCLTR_WORKING\t\t\t3'd1\n`define S_INTRCLTR_COMPLETE\t\t\t3'd2\n`define S_INTRCLTR_CLEAR_LEGACY\t\t3'd3\n`define S_INTRCLTR_CLEARING_LEGACY\t3'd4\n`define S_INTRCLTR_DONE\t\t\t\t3'd5\n\nmodule interrupt_controller (\n\tinput CLK,\t\t\t\t\t\tinput RST,\t\t\t\t\t\tinput INTR,\t\t\t\t\t\tinput INTR_LEGACY_CLR,\t\t\toutput INTR_DONE,\t\t\t\tinput CONFIG_INTERRUPT_MSIENABLE,\toutput CFG_INTERRUPT_ASSERT,\tinput INTR_MSI_RDY,\t\toutput INTR_MSI_REQUEST\t\t\t);\n\nreg\t\t[2:0]\trState=`S_INTRCTLR_IDLE;\nreg\t\t[2:0]\trStateNext=`S_INTRCTLR_IDLE;\nreg\t\t\t\trIntr=0;\nreg\t\t\t\trIntrAssert=0;\n\nassign INTR_DONE = (rState == `S_INTRCLTR_DONE);\nassign INTR_MSI_REQUEST = rIntr;\nassign CFG_INTERRUPT_ASSERT = rIntrAssert;\n\nalways @(*) begin\n\tcase (rState)\n\n\t`S_INTRCTLR_IDLE : begin\n\t\tif (INTR) begin\n\t\t\trIntr = 1;\n\t\t\trIntrAssert = !CONFIG_INTERRUPT_MSIENABLE;\n\t\t\trStateNext = (INTR_MSI_RDY ? `S_INTRCLTR_COMPLETE : `S_INTRCLTR_WORKING);\n\t\tend \n\t\telse begin\n\t\t\trIntr = 0;\n\t\t\trIntrAssert = 0;\n\t\t\trStateNext = `S_INTRCTLR_IDLE;\n\t\tend\n\tend\n\n\t`S_INTRCLTR_WORKING : begin\n\t\trIntr = 1;\n\t\trIntrAssert = !CONFIG_INTERRUPT_MSIENABLE;\n\t\trStateNext = (INTR_MSI_RDY ? `S_INTRCLTR_COMPLETE : `S_INTRCLTR_WORKING);\n\tend\n\n\t`S_INTRCLTR_COMPLETE : begin\n\t\trIntr = 0;\n\t\trIntrAssert = !CONFIG_INTERRUPT_MSIENABLE;\n\t\trStateNext = (CONFIG_INTERRUPT_MSIENABLE ? `S_INTRCLTR_DONE : `S_INTRCLTR_CLEAR_LEGACY);\n\tend\n\n\t`S_INTRCLTR_CLEAR_LEGACY : begin\n\t\tif (INTR_LEGACY_CLR) begin\n\t\t\trIntr = 1;\n\t\t\trIntrAssert = 0;\n\t\t\trStateNext = (INTR_MSI_RDY ? `S_INTRCLTR_DONE : `S_INTRCLTR_CLEARING_LEGACY);\n\t\tend \n\t\telse begin\n\t\t\trIntr = 0;\n\t\t\trIntrAssert = 1;\n\t\t\trStateNext = `S_INTRCLTR_CLEAR_LEGACY;\n\t\tend\n\tend\n\n\t`S_INTRCLTR_CLEARING_LEGACY : begin\n\t\trIntr = 1;\n\t\trIntrAssert = 0;\n\t\trStateNext = (INTR_MSI_RDY ? `S_INTRCLTR_DONE : `S_INTRCLTR_CLEARING_LEGACY);\n\tend\n\n\t`S_INTRCLTR_DONE : begin\n\t\trIntr = 0;\n\t\trIntrAssert = 0;\n\t\trStateNext = `S_INTRCTLR_IDLE;\n\tend\n\t\n\tdefault: begin\n\t\trIntr = 0;\n\t\trIntrAssert = 0;\n\t\trStateNext = `S_INTRCTLR_IDLE;\n\tend\n\t\n\tendcase\nend\n\nalways @(posedge CLK) begin\n\tif (RST)\n\t\trState <= #1 `S_INTRCTLR_IDLE;\n\telse\n\t\trState <= #1 rStateNext;\nend\n\nendmodule\n\n",
        "module_name": "interrupt_controller",
        "module_hash": "2c8bcd3d58b8e11b15f523a26c56d2ba",
        "dataset_index": 24292
      },
      "two_input_inv_a0197e4e": {
        "rtl_code": "module two_input_inv (\n    input a,\n    input b,\n    output y\n);\n\n    wire not_a;\n    wire not_b;\n    wire a_and_b;\n\n    assign not_a = ~a;\n    assign not_b = ~b;\n    assign a_and_b = a & b;\n\n    assign y = not_a & not_b;\n\nendmodule",
        "module_name": "two_input_inv",
        "module_hash": "a0197e4eb17ada84f2bec721a5e81510",
        "dataset_index": 11972
      },
      "ripple_carry_adder_e19a7dcd": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    A    ,\n    B    ,\n    C_in ,\n    CLK  ,\n    S    ,\n    C_out\n);\n\n    input  [3:0] A;\n    input  [3:0] B;\n    input  C_in;\n    input  CLK;\n    output [3:0] S;\n    output C_out;\n\n    wire [3:0] sum;\n    wire [3:0] carry; // 4 bits carry\n\n    // Full adder module\n    full_adder fa0(sum[0], carry[0], A[0], B[0], C_in);\n    full_adder fa1(sum[1], carry[1], A[1], B[1], carry[0]);\n    full_adder fa2(sum[2], carry[2], A[2], B[2], carry[1]);\n    full_adder fa3(sum[3], C_out, A[3], B[3], carry[2]);\n\n    // Connect the sum outputs of the full adders to the S output of the ripple carry adder module\n    assign S = sum;\n\nendmodule\nmodule full_adder (\n    sum  ,\n    carry,\n    A    ,\n    B    ,\n    C_in\n);\n\n    output sum;\n    output carry;\n    input  A;\n    input  B;\n    input  C_in;\n\n    assign sum   = A ^ B ^ C_in;\n    assign carry = (A & B) | (A & C_in) | (B & C_in);\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "e19a7dcd1e89c87f03054c835f090f1a",
        "dataset_index": 7498
      },
      "threshold_module_775d45ac": {
        "rtl_code": "module threshold_module(input [3:0] input_value, output reg [1:0] output_value);\n   parameter THRESHOLD = 10;\n   \n   always @(*) begin\n      if (input_value <= 5) begin\n         output_value = 2'b00;\n      end else if (input_value >= THRESHOLD) begin\n         output_value = 2'b10;\n      end else begin\n         output_value = 2'b01;\n      end\n   end\nendmodule",
        "module_name": "threshold_module",
        "module_hash": "775d45ac7e48df12ab12d081fb30b92e",
        "dataset_index": 1323
      },
      "top__af7989b5": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input enable1, // Enable input for counter 1\n    input enable2, // Enable input for counter 2\n    output [3:0] q1, // 4-bit output from counter 1\n    output [3:0] q2, // 4-bit output from counter 2\n    output [3:0] final_output // Result of bitwise OR operation\n);\n\n    // Define two 4-bit binary counters with asynchronous reset and enable inputs\n    reg [3:0] counter1;\n    reg [3:0] counter2;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter1 <= 4'b0;\n            counter2 <= 4'b0;\n        end else if (enable1) begin\n            counter1 <= counter1 + 1;\n        end else if (enable2) begin\n            counter2 <= counter2 + 1;\n        end\n    end\n    \n    assign q1 = counter1;\n    assign q2 = counter2;\n    \n    // Define a functional module that takes in both of the 4-bit outputs from the counters\n    // and outputs the bitwise OR of the two outputs\n    assign final_output = q1 | q2;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "af7989b56c943abb19b2b00fc33f641c",
        "dataset_index": 16647
      },
      "binary_counter_a3e96545": {
        "rtl_code": "module binary_counter (\n    input  wire        CLK,\n    input  wire        RST,\n    input  wire        COUNT_EN,\n    output reg  [3:0]  Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 4'b0000;\n        end else if (COUNT_EN) begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "a3e96545ae517902f89729b5903bd956",
        "dataset_index": 18768
      },
      "min__cfc10e6d": {
        "rtl_code": "\nmodule min_module (\n    input [7:0] a, b, c, d, // Inputs to find minimum\n    output reg [7:0] min // Output minimum value\n);\n\nreg [7:0] ab_min, cd_min, abcd_min;\n\nalways @(*) begin\n    ab_min = (a < b) ? a : b;\n    cd_min = (c < d) ? c : d;\n    abcd_min = (ab_min < cd_min) ? ab_min : cd_min;\n    min = abcd_min;\nend\n\nendmodule\n\nmodule add_module (\n    input [7:0] x, y, // Inputs to add\n    output [7:0] sum, // Output sum\n    output overflow // Output overflow\n);\n\nwire [8:0] x_plus_y, x_minus_y, y_minus_x; // Use wider wires to prevent overflow\n\nassign x_plus_y = x + y;\nassign x_minus_y = x - y;\nassign y_minus_x = y - x;\n\nassign sum = x_plus_y[7:0]; // Truncate to 8 bits to match input/output width\n\nassign overflow = x_plus_y[8] ^ x[7] ^ y[7]; // XOR of MSBs indicates overflow\n\nendmodule\n\nmodule top_module (\n    input [7:0] a, b, c, d, // Inputs to the minimum module\n    input [7:0] x, y, // Inputs to the addition module\n    input select, // Selects which module to use as input to the functional module\n    output [7:0] result, // Output of the functional module\n    output overflow // Output of the addition module indicating overflow\n);\n\nwire [7:0] min_output, add_output; // Wire to connect outputs of min and add modules\n\nmin_module min_inst (\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .min(min_output)\n);\n\nadd_module add_inst (\n    .x(x),\n    .y(y),\n    .sum(add_output),\n    .overflow(overflow)\n);\n\nassign result = select ? min_output : add_output; // Select output based on 'select' input\n\nendmodule\n",
        "module_name": "min_",
        "module_hash": "cfc10e6d90328430abac7e48aa8515da",
        "dataset_index": 19323
      },
      "jt10_adpcm_acc_64a0be41": {
        "rtl_code": "\n\nmodule jt10_adpcm_acc(\n    input           rst_n,\n    input           clk,        input           cen,        input   [5:0]   cur_ch,\n    input   [5:0]   en_ch,\n    input           match,\n\n    input           en_sum,\n    input  signed [15:0] pcm_in,    output reg signed [15:0] pcm_out    );\n\nwire signed [17:0] pcm_in_long = en_sum ? { {2{pcm_in[15]}}, pcm_in } : 18'd0;\nreg  signed [17:0] acc, last, pcm_full;\nreg  signed [17:0] step;\n\nreg signed [17:0] diff;\nreg signed [22:0] diff_ext, step_full; \n\nalways @(*) begin\n    diff = acc-last;\n    diff_ext = { {5{diff[17]}}, diff };\n    step_full = diff_ext        + ( diff_ext << 1 )     + ( diff_ext << 3 )     + ( diff_ext << 5 );    end\n\nwire adv = en_ch[0] & cur_ch[0];\n\nalways @(posedge clk or negedge rst_n)\n    if( !rst_n ) begin\n        step <= 'd0;\n        acc  <= 18'd0;\n        last <= 18'd0;\n    end else if(cen) begin\n        if( match )\n            acc <= cur_ch[0] ? pcm_in_long : ( pcm_in_long + acc );\n        if( adv ) begin\n            step <= { {2{step_full[22]}}, step_full[22:7] }; last <= acc;\n        end\n    end\nwire overflow = |pcm_full[17:15] & ~&pcm_full[17:15];\n\nalways @(posedge clk or negedge rst_n)\n    if( !rst_n ) begin\n        pcm_full <= 18'd0;\n    end else if(cen && cur_ch[0]) begin\n        case( en_ch )\n            6'b000_001: pcm_full <= last;\n            6'b000_100,\n            6'b010_000: pcm_full <= pcm_full + step;\n            default:;\n        endcase\n        if( overflow )\n            pcm_out <= pcm_full[17] ? 16'h8000 : 16'h7fff; else\n            pcm_out <= pcm_full[15:0];\n    end\n\nendmodule // jt10_adpcm_acc",
        "module_name": "jt10_adpcm_acc",
        "module_hash": "64a0be411258dfa371d5344b9907710a",
        "dataset_index": 18500
      },
      "debounce #_b325c2eb": {
        "rtl_code": "\n\nmodule debounce # (\n  parameter pCLKS = 32'd 1_000_000) (\n  input iCLK,\n  input iRESET, input iSIG,\n  output reg oSIG\n);\n\ninteger debounceCtr = 0;\n\nalways @(posedge iCLK or posedge iRESET) begin\n    if (iRESET)\n    begin\n        debounceCtr <= 0;\n        oSIG <= 0;\n    end\n    else if (iSIG)\n    begin if (!oSIG)\n        begin if (debounceCtr < pCLKS)\n            begin\n                debounceCtr <= debounceCtr + 1;\n                oSIG <= 0;\n            end\n            else\n            begin\n                debounceCtr <= 0;\n                oSIG <= 1;\n            end\n        end\n        else\n        begin debounceCtr <= 0;\n        end\n    end\n    else\n    begin if (oSIG)\n        begin\n            if (debounceCtr < pCLKS)\n            begin debounceCtr <= debounceCtr + 1;\n                oSIG <= 1;\n            end\n            else\n            begin\n                debounceCtr <= 0;\n                oSIG <= 0;\n            end\n        end\n        else\n        begin debounceCtr <= 0;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "debounce #",
        "module_hash": "b325c2eb2b3586cbc4660d62d88683b4",
        "dataset_index": 19764
      },
      "dc_filter_0d6e9700": {
        "rtl_code": "\nmodule dc_filter (\n  // data interface\n  input clk,\n  input valid,\n  input [15:0] data,\n  output reg valid_out,\n  output reg [15:0] data_out,\n  // control interface\n  input dcfilt_enb,\n  input [15:0] dcfilt_coeff,\n  input [15:0] dcfilt_offset\n);\n  // internal registers\n  reg [47:0] dc_offset;\n  reg [47:0] dc_offset_d;\n  reg valid_d;\n  reg [15:0] data_d;\n  reg valid_2d;\n  reg [15:0] data_2d;\n  reg [15:0] data_dcfilt;\n  // internal signals\n  wire [47:0] dc_offset_s = dc_offset[32:0] - (dc_offset[47:33] << 15);\n  // cancelling the dc offset\n  always @(posedge clk) begin\n    dc_offset_d <= dc_offset_s;\n    valid_d <= valid;\n    if (valid == 1'b1) begin\n      data_d <= data + dcfilt_offset;\n    end\n    valid_2d <= valid_d;\n    data_2d <= data_d;\n    data_dcfilt <= data_d - dc_offset_s[32:17];\n    if (dcfilt_enb == 1'b1) begin\n      valid_out <= valid_2d;\n      data_out <= data_dcfilt;\n    end else begin\n      valid_out <= valid_2d;\n      data_out <= data_2d;\n    end\n  end\n  // always block to avoid latch\n  always @(posedge clk) begin\n    dc_offset <= dc_offset_d;\n  end\nendmodule",
        "module_name": "dc_filter",
        "module_hash": "0d6e9700776ef4b12dd7dde90941465f",
        "dataset_index": 10445
      },
      "my_RAM64X1D2_83bd895d": {
        "rtl_code": "module my_RAM64X1D2 (\n    input clk,\n    input [7:0] din,\n    output reg [7:0] dout\n);\n\n    reg [7:0] ram [0:63];\n    reg [5:0] addr1, addr2;\n    reg [1:0] read_en;\n    reg write_en;\n\n    always @(posedge clk) begin\n        if (write_en) begin\n            ram[addr1] <= din;\n        end\n        if (read_en[0]) begin\n            dout <= ram[addr2];\n        end\n        if (read_en[1]) begin\n            dout <= ram[addr2];\n        end\n    end\n\n    always @* begin\n        addr1 = din[5:0];\n        addr2 = {din[5:0], 1'b0};\n        read_en = din[6:5];\n        write_en = din[7];\n    end\n\nendmodule",
        "module_name": "my_RAM64X1D2",
        "module_hash": "83bd895d69d6b702f05a5fa7cc74860e",
        "dataset_index": 19622
      },
      "digital_clock_3b906072": {
        "rtl_code": "\nmodule digital_clock(\n    input CLK,\n    input RST,\n    output reg [5:0] SEC,\n    output reg [5:0] MIN,\n    output reg [4:0] HOUR\n);\n\n    parameter SEC_CNT    = 60;\n    parameter MIN_CNT    = 60;\n    parameter HOUR_CNT   = 24;\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            SEC <= 6'b0;\n            MIN <= 6'b0;\n            HOUR <= 5'b0;\n        end else begin\n            if (SEC == (SEC_CNT - 1)) begin\n                SEC <= 6'b0;\n                if (MIN == (MIN_CNT - 1)) begin\n                    MIN <= 6'b0;\n                    if (HOUR == (HOUR_CNT - 1)) begin\n                        HOUR <= 5'b0;\n                    end else begin\n                        HOUR <= HOUR + 1;\n                    end\n                end else begin\n                    MIN <= MIN + 1;\n                end\n            end else begin\n                SEC <= SEC + 1;\n            end\n        end\n    end\n    \nendmodule",
        "module_name": "digital_clock",
        "module_hash": "3b90607225c4a155112915d7a0b55b49",
        "dataset_index": 1788
      },
      "sum_threshold_a43f3a7c": {
        "rtl_code": "module sum_threshold (out, in);\n\tinput [15:0] in;\n\toutput [3:0] out;\n\t\n\treg [3:0] out;\n\t\n\talways @ (in)\n\tbegin\n\t\tout[0] = (in[3:0] + in[7:4] + in[11:8] + in[15:12]) >= 8;\n\t\tout[1] = (in[3:0] + in[7:4] + in[11:8] + in[15:12]) >= 8;\n\t\tout[2] = (in[3:0] + in[7:4] + in[11:8] + in[15:12]) >= 8;\n\t\tout[3] = (in[3:0] + in[7:4] + in[11:8] + in[15:12]) >= 8;\n\tend\nendmodule",
        "module_name": "sum_threshold",
        "module_hash": "a43f3a7cfc6fbc64c93562bc45675320",
        "dataset_index": 11771
      },
      "excess_3_ced60068": {
        "rtl_code": "module excess_3 (\n    input [3:0] binary,\n    output reg [3:0] bcd\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @(*) begin\n    stage1_out = binary + 4'b0011;\nend\n\nalways @(*) begin\n    stage2_out = stage1_out + (stage1_out >= 5'b1010 ? 2 : 0);\nend\n\nalways @(*) begin\n    bcd = stage2_out + (stage2_out >= 10 ? 4 : 0);\nend\n\nendmodule",
        "module_name": "excess_3",
        "module_hash": "ced6006883ee9eae2b1117214e8a2ee8",
        "dataset_index": 10542
      },
      "Latch_Index_Pulse_f2479abb": {
        "rtl_code": "\n\nmodule Latch_Index_Pulse\n          (\n           CLK_IN,\n           reset,\n           enb,\n           In1,\n           Out1\n          );\n\n\n  input   CLK_IN;\n  input   reset;\n  input   enb;\n  input   In1;\n  output  Out1;\n\n\n  wire Constant1_out1;\n  wire Switch_out1;\n  reg  Delay_out1;\n\n\n  assign Constant1_out1 = 1'b1;\n\n\n\n  always @(posedge CLK_IN)\n    begin : Delay_process\n      if (reset == 1'b1) begin\n        Delay_out1 <= 1'b0;\n      end\n      else if (enb) begin\n        Delay_out1 <= Switch_out1;\n      end\n    end\n\n\n\n  assign Switch_out1 = (Delay_out1 == 1'b0 ? In1 :\n              Constant1_out1);\n\n\n\n  assign Out1 = Switch_out1;\n\nendmodule  ",
        "module_name": "Latch_Index_Pulse",
        "module_hash": "f2479abb9e4703fec53845a3a0508c9f",
        "dataset_index": 21139
      },
      "sky130_fd_sc_ls__fahcin_b57846c2": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__fahcin (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CIN\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CIN ;\n\n    wire ci          ;\n    wire xor0_out_SUM;\n    wire a_b         ;\n    wire a_ci        ;\n    wire b_ci        ;\n    wire or0_out_COUT;\n\n    not not0 (ci          , CIN            );\n    xor xor0 (xor0_out_SUM, A, B, ci       );\n    buf buf0 (SUM         , xor0_out_SUM   );\n    and and0 (a_b         , A, B           );\n    and and1 (a_ci        , A, ci          );\n    and and2 (b_ci        , B, ci          );\n    or  or0  (or0_out_COUT, a_b, a_ci, b_ci);\n    buf buf1 (COUT        , or0_out_COUT   );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__fahcin",
        "module_hash": "b57846c2feed837e7eb2a6b23137ea9a",
        "dataset_index": 21726
      },
      "calculator_163b8a51": {
        "rtl_code": "module calculator(\n    input [7:0] a, b,\n    input [1:0] op,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = a + b;\n        2'b01: result = a - b;\n        2'b10: result = a * b;\n        2'b11: result = a / b;\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "163b8a5178503f8ecc675d35deed8f7b",
        "dataset_index": 20498
      },
      "binary_subtractor_baf8bfb9": {
        "rtl_code": "module binary_subtractor (\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] diff\n);\n\n    wire [7:0] b_not;\n    wire [8:0] sum;\n\n    // Bitwise NOT operation on b\n    assign b_not = ~b;\n\n    // Binary adder module\n    adder adder_inst (\n        .a(a),\n        .b(b_not),\n        .sum(sum)\n    );\n\n    // Bitwise AND operation on a and b_not\n    assign diff = {1'b0, a} & {1'b0, b_not};\n\nendmodule\n\nmodule adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n\n    wire [7:0] carry;\n    assign carry = {1'b0, a} + {1'b0, b};\n\n    assign sum = carry + 1'b0;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] a, // 8-bit input\n    input [7:0] b, // 8-bit input\n    output [8:0] diff // 9-bit output with MSB representing the sign bit\n);\n\n    reg [8:0] diff_reg;\n    wire [8:0] diff_wire;\n\n    binary_subtractor sub_inst (\n        .a(a),\n        .b(b),\n        .diff(diff_wire)\n    );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            diff_reg <= 9'b1;\n        end else begin\n            diff_reg <= diff_wire;\n        end\n    end\n\n    assign diff = diff_reg;\n\nendmodule",
        "module_name": "binary_subtractor",
        "module_hash": "baf8bfb956e432d6439686d7d70820f6",
        "dataset_index": 18661
      },
      "binary_counter_9a894744": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "9a894744bc0dd447a4212ee9cff97f5e",
        "dataset_index": 2920
      },
      "gfx_transform_caa0ac13": {
        "rtl_code": "\n\n\n\n\nmodule gfx_transform(clk_i, rst_i,\nx_i, y_i, z_i, point_id_i,\naa, ab, ac, tx, ba, bb, bc, ty, ca, cb, cc, tz, p0_x_o, p0_y_o, p0_z_o, p1_x_o, p1_y_o, p1_z_o, p2_x_o, p2_y_o, p2_z_o,\ntransform_i, forward_i,\nack_o\n);\n\ninput clk_i;\ninput rst_i;\n\nparameter point_width = 16;\nparameter subpixel_width = 16;\n\ninput signed [point_width-1:-subpixel_width] x_i;\ninput signed [point_width-1:-subpixel_width] y_i;\ninput signed [point_width-1:-subpixel_width] z_i;\ninput                                  [1:0] point_id_i; input signed [point_width-1:-subpixel_width] aa;\ninput signed [point_width-1:-subpixel_width] ab;\ninput signed [point_width-1:-subpixel_width] ac;\ninput signed [point_width-1:-subpixel_width] tx;\ninput signed [point_width-1:-subpixel_width] ba;\ninput signed [point_width-1:-subpixel_width] bb;\ninput signed [point_width-1:-subpixel_width] bc;\ninput signed [point_width-1:-subpixel_width] ty;\ninput signed [point_width-1:-subpixel_width] ca;\ninput signed [point_width-1:-subpixel_width] cb;\ninput signed [point_width-1:-subpixel_width] cc;\ninput signed [point_width-1:-subpixel_width] tz;\n\noutput reg signed [point_width-1:-subpixel_width] p0_x_o;\noutput reg signed [point_width-1:-subpixel_width] p0_y_o;\noutput reg signed               [point_width-1:0] p0_z_o;\noutput reg signed [point_width-1:-subpixel_width] p1_x_o;\noutput reg signed [point_width-1:-subpixel_width] p1_y_o;\noutput reg signed               [point_width-1:0] p1_z_o;\noutput reg signed [point_width-1:-subpixel_width] p2_x_o;\noutput reg signed [point_width-1:-subpixel_width] p2_y_o;\noutput reg signed               [point_width-1:0] p2_z_o;\n\ninput transform_i, forward_i;\n\noutput reg ack_o;\n\nreg [1:0] state;\nparameter wait_state = 2'b00, forward_state = 2'b01, transform_state = 2'b10;\n\nreg signed [2*point_width-1:-subpixel_width*2] aax;\nreg signed [2*point_width-1:-subpixel_width*2] aby;\nreg signed [2*point_width-1:-subpixel_width*2] acz;\nreg signed [2*point_width-1:-subpixel_width*2] bax;\nreg signed [2*point_width-1:-subpixel_width*2] bby;\nreg signed [2*point_width-1:-subpixel_width*2] bcz;\nreg signed [2*point_width-1:-subpixel_width*2] cax;\nreg signed [2*point_width-1:-subpixel_width*2] cby;\nreg signed [2*point_width-1:-subpixel_width*2] ccz;\n\nalways @(posedge clk_i or posedge rst_i)\nif(rst_i)\nbegin\n  ack_o             <= 1'b0;\n  p0_x_o            <= 1'b0;\n  p0_y_o            <= 1'b0;\n  p0_z_o            <= 1'b0;\n  p1_x_o            <= 1'b0;\n  p1_y_o            <= 1'b0;\n  p1_z_o            <= 1'b0;\n  p2_x_o            <= 1'b0;\n  p2_y_o            <= 1'b0;\n  p2_z_o            <= 1'b0;\n\n  aax               <= 1'b0;\n  aby               <= 1'b0;\n  acz               <= 1'b0;\n  bax               <= 1'b0;\n  bby               <= 1'b0;\n  bcz               <= 1'b0;\n  cax               <= 1'b0;\n  cby               <= 1'b0;\n  ccz               <= 1'b0;\nend\nelse\n  case(state)\n    wait_state:\n    begin\n      ack_o <= 1'b0;\n\n      if(transform_i)\n      begin\n        aax <= aa * x_i;\n        aby <= ab * y_i;\n        acz <= ac * z_i;\n        bax <= ba * x_i;\n        bby <= bb * y_i;\n        bcz <= bc * z_i;\n        cax <= ca * x_i;\n        cby <= cb * y_i;\n        ccz <= cc * z_i;\n      end\n      else if(forward_i)\n      begin\n        if(point_id_i == 2'b00)\n        begin\n          p0_x_o <= x_i;\n          p0_y_o <= y_i;\n          p0_z_o <= z_i[point_width-1:0];\n        end\n        else if(point_id_i == 2'b01)\n        begin\n          p1_x_o <= x_i;\n          p1_y_o <= y_i;\n          p1_z_o <= z_i[point_width-1:0];\n        end\n        else if(point_id_i == 2'b10)\n        begin\n          p2_x_o <= x_i;\n          p2_y_o <= y_i;\n          p2_z_o <= z_i[point_width-1:0];\n        end\n      end\n    end\n\n    forward_state:\n      ack_o <= 1'b1;\n\n    transform_state:\n    begin\n      ack_o <= 1'b1;\n\n      if(point_id_i == 2'b00)\n        begin\n          p0_x_o <= x_prime_trunc;\n          p0_y_o <= y_prime_trunc;\n          p0_z_o <= z_prime_trunc[point_width-1:0];\n        end\n        else if(point_id_i == 2'b01)\n        begin\n          p1_x_o <= x_prime_trunc;\n          p1_y_o <= y_prime_trunc;\n          p1_z_o <= z_prime_trunc[point_width-1:0];\n        end\n        else if(point_id_i == 2'b10)\n        begin\n          p2_x_o <= x_prime_trunc;\n          p2_y_o <= y_prime_trunc;\n          p2_z_o <= z_prime_trunc[point_width-1:0];\n        end\n    end\n  endcase\n\nwire [subpixel_width-1:0] zeroes = 1'b0;\n\nwire signed [2*point_width-1:-subpixel_width*2] x_prime = aax + aby + acz + {tx,zeroes};\nwire signed [2*point_width-1:-subpixel_width*2] y_prime = bax + bby + bcz + {ty,zeroes};\nwire signed [2*point_width-1:-subpixel_width*2] z_prime = cax + cby + ccz + {tz,zeroes};\n\nwire signed [point_width-1:-subpixel_width] x_prime_trunc = x_prime[point_width-1:-subpixel_width];\nwire signed [point_width-1:-subpixel_width] y_prime_trunc = y_prime[point_width-1:-subpixel_width];\nwire signed [point_width-1:-subpixel_width] z_prime_trunc = z_prime[point_width-1:-subpixel_width];\n\nalways @(posedge clk_i or posedge rst_i)\nif(rst_i)\n  state <= wait_state;\nelse\n  case(state)\n    wait_state:\n      if(transform_i)\n        state <= transform_state;\n      else if(forward_i)\n        state <= forward_state;\n\n    forward_state:\n      state <= wait_state;\n    \n    transform_state:\n      state <= wait_state;\n  endcase\n\nendmodule\n\n",
        "module_name": "gfx_transform",
        "module_hash": "caa0ac13b41a13866a55514848b52f88",
        "dataset_index": 23199
      },
      "synchronizer_flop_b18abe99": {
        "rtl_code": "module synchronizer_flop (\n  data_in, clk_out, sync_data_out, async_reset\n);\nparameter               width = 1 ;\nparameter               reset_val = 0 ;\n\n  input   [width-1:0]   data_in;\n  input                 clk_out;\n  output  [width-1:0]   sync_data_out;\n  input                 async_reset;\n\n  reg     [width-1:0]   sync_data_out;\n\n  always @(posedge clk_out or posedge async_reset)\n  begin\n    if (async_reset == 1'b1)\n    begin\n      sync_data_out <= reset_val;\n    end\n    else\n    begin\nsync_data_out <= data_in;\n    end\n  end\nendmodule\n\n",
        "module_name": "synchronizer_flop",
        "module_hash": "b18abe992210c65eadeaf998f9f7664f",
        "dataset_index": 22250
      },
      "d_flip_flop_chain_df53fb31": {
        "rtl_code": "module d_flip_flop_chain (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] q_reg;\nwire [7:0] d_wire;\n\nassign d_wire = {q_reg[6:0], d};\n\nalways @(negedge clk) begin\n    q_reg <= d_wire;\nend\n\nassign q = q_reg;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nd_flip_flop_chain flip_flop_chain (\n    .clk(clk),\n    .d(d),\n    .q(q)\n);\n\nendmodule",
        "module_name": "d_flip_flop_chain",
        "module_hash": "df53fb31c6ee633071dc51a42ff13937",
        "dataset_index": 4885
      },
      "sky130_fd_sc_hdll__a21oi_62f6c5b5": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__a21oi",
        "module_hash": "62f6c5b561391cd434a12815ecf32e37",
        "dataset_index": 22549
      },
      "up_down_counter_6a55e916": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input load,    // Load value into counter when asserted\n    input up_down, // Count up or down based on value\n    output reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else if (load) begin\n            q <= {q[15:12], q[11:8], q[7:4], q[3:0]};\n        end else if (up_down) begin\n            q <= q + 16'd1;\n        end else begin\n            q <= q - 16'd1;\n        end\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input load,    // Load value into counter when asserted\n    input up_down, // Count up or down based on value\n    output [15:0] q);\n\n    up_down_counter counter (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .up_down(up_down),\n        .q(q)\n    );\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "6a55e916a8ba38891ee22af5e50e0fe3",
        "dataset_index": 8655
      },
      "jt12_single_acc #_0afe865d": {
        "rtl_code": "\n\nmodule jt12_single_acc #(parameter \n        win=14, wout=16 )(\n    input                 clk,\n    input                 clk_en ,\n    input [win-1:0]       op_result,\n    input                 sum_en,\n    input                 zero,\n    output reg [wout-1:0] snd\n);\n\nreg signed [wout-1:0] next, acc, current;\nreg overflow;\n\nwire [wout-1:0] plus_inf  = { 1'b0, {(wout-1){1'b1}} }; wire [wout-1:0] minus_inf = { 1'b1, {(wout-1){1'b0}} }; always @(*) begin\n    current = sum_en ? { {(wout-win){op_result[win-1]}}, op_result } : {wout{1'b0}};\n    next = zero ? current : current + acc;\n    overflow = !zero && \n        (current[wout-1] == acc[wout-1]) && \n        (acc[wout-1]!=next[wout-1]);\nend\n\nalways @(posedge clk) if( clk_en ) begin\n    acc <= overflow ? (acc[wout-1] ? minus_inf : plus_inf) : next;\n    if(zero) snd <= acc;\nend\n\nendmodule // jt12_single_acc",
        "module_name": "jt12_single_acc #",
        "module_hash": "0afe865d419a2bdee58f989493f66a64",
        "dataset_index": 15866
      },
      "priority_bcd_mux_3e0160b9": {
        "rtl_code": "module priority_bcd_mux (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input [1:0] S,\n    input [3:0] binary_in,\n    input clk,\n    output reg [6:0] seven_segment_out,\n    output reg EN1,\n    output reg EN2,\n    output reg EN3\n);\n\nreg [3:0] priority_input;\nreg [3:0] bcd_out;\nreg [1:0] digit_counter;\nreg [3:0] bcd_counter;\n\nalways @(posedge clk) begin\n    // Priority encoder\n    case ({A, B, C, D})\n        4'b1110: priority_input <= A;\n        4'b1101: priority_input <= B;\n        4'b1011: priority_input <= C;\n        4'b0111: priority_input <= D;\n        default: priority_input <= 4'b0000;\n    endcase\n    \n    // Binary to BCD converter\n    if (digit_counter == 0) begin\n        bcd_out <= binary_in % 10;\n    end else if (digit_counter == 1) begin\n        bcd_out <= (binary_in / 10) % 10;\n    end else if (digit_counter == 2) begin\n        bcd_out <= (binary_in / 100) % 10;\n    end else begin\n        bcd_out <= (binary_in / 1000) % 10;\n    end\n    \n    // Output selection\n    case (S)\n        2'b00: seven_segment_out <= bcd_out;\n        2'b01: seven_segment_out <= priority_input;\n        2'b10: seven_segment_out <= 7'b1111111;\n        2'b11: seven_segment_out <= 7'b0000000;\n    endcase\n    \n    // Digit enable signals\n    if (digit_counter == 0) begin\n        EN1 <= 1;\n        EN2 <= 0;\n        EN3 <= 0;\n    end else if (digit_counter == 1) begin\n        EN1 <= 0;\n        EN2 <= 1;\n        EN3 <= 0;\n    end else if (digit_counter == 2) begin\n        EN1 <= 0;\n        EN2 <= 0;\n        EN3 <= 1;\n    end else begin\n        EN1 <= 0;\n        EN2 <= 0;\n        EN3 <= 0;\n    end\n    \n    // Digit counter\n    if (digit_counter == 3) begin\n        digit_counter <= 0;\n    end else begin\n        digit_counter <= digit_counter + 1;\n    end\nend\n\nendmodule",
        "module_name": "priority_bcd_mux",
        "module_hash": "3e0160b939ba248dd42f420a2662b46f",
        "dataset_index": 13368
      },
      "original_gate_3ad01065": {
        "rtl_code": "\nmodule original_gate (clk, ctrl, din, sel, dout);\n   input wire clk;\n   input wire [4:0] ctrl;\n   input wire [1:0] din;\n   input wire [0:0] sel;\n   output reg [31:0] dout;\n   always @(posedge clk)\n     case (({(ctrl)*(sel)})+(0))\n       0:\n         dout[31:0] <= din;\n       1:\n         dout[31:1] <= din;\n       2:\n         dout[31:2] <= din;\n       3:\n         dout[31:3] <= din;\n       4:\n         dout[31:4] <= din;\n       5:\n         dout[31:5] <= din;\n       6:\n         dout[31:6] <= din;\n       7:\n         dout[31:7] <= din;\n       8:\n         dout[31:8] <= din;\n       9:\n         dout[31:9] <= din;\n       10:\n         dout[31:10] <= din;\n       11:\n         dout[31:11] <= din;\n       12:\n         dout[31:12] <= din;\n       13:\n         dout[31:13] <= din;\n       14:\n         dout[31:14] <= din;\n       15:\n         dout[31:15] <= din;\n       16:\n         dout[31:16] <= din;\n       17:\n         dout[31:17] <= din;\n       18:\n         dout[31:18] <= din;\n       19:\n         dout[31:19] <= din;\n       20:\n         dout[31:20] <= din;\n       21:\n         dout[31:21] <= din;\n       22:\n         dout[31:22] <= din;\n       23:\n         dout[31:23] <= din;\n       24:\n         dout[31:24] <= din;\n       25:\n         dout[31:25] <= din;\n       26:\n         dout[31:26] <= din;\n       27:\n         dout[31:27] <= din;\n       28:\n         dout[31:28] <= din;\n       29:\n         dout[31:29] <= din;\n       30:\n         dout[31:30] <= din;\n       31:\n         dout[31:31] <= din;\n     endcase\nendmodule\n",
        "module_name": "original_gate",
        "module_hash": "3ad0106587ec904b1c3fdbeadc22ba01",
        "dataset_index": 25183
      },
      "priority_encoder_dc02531e": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] I,\n    input clk,\n    output reg EN,\n    output reg V,\n    output reg [2:0] Q\n);\n\nreg [7:0] I_reg;\nreg [7:0] I_next;\nreg [2:0] Q_reg;\nreg [2:0] Q_next;\nreg [2:0] Q_next_next;\nreg [2:0] Q_next_next_next;\n\nalways @(posedge clk) begin\n    I_reg <= I;\nend\n\nalways @(posedge clk) begin\n    I_next <= I_reg;\nend\n\nalways @(posedge clk) begin\n    Q_reg <= Q_next_next;\nend\n\nalways @(posedge clk) begin\n    Q_next <= Q_reg;\nend\n\nalways @(posedge clk) begin\n    Q_next_next <= Q_next_next_next;\nend\n\nalways @(posedge clk) begin\n    if (I_next[7] == 1) begin\n        Q_next_next_next <= 3'b111;\n    end else if (I_next[6] == 1) begin\n        Q_next_next_next <= 3'b110;\n    end else if (I_next[5] == 1) begin\n        Q_next_next_next <= 3'b101;\n    end else if (I_next[4] == 1) begin\n        Q_next_next_next <= 3'b100;\n    end else if (I_next[3] == 1) begin\n        Q_next_next_next <= 3'b011;\n    end else if (I_next[2] == 1) begin\n        Q_next_next_next <= 3'b010;\n    end else if (I_next[1] == 1) begin\n        Q_next_next_next <= 3'b001;\n    end else if (I_next[0] == 1) begin\n        Q_next_next_next <= 3'b000;\n    end else begin\n        Q_next_next_next <= Q_next;\n    end\nend\n\nalways @(posedge clk) begin\n    if (I_next != 8'b00000000) begin\n        EN <= 1;\n    end else begin\n        EN <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (I_next != 8'b00000000 && V == 0) begin\n        V <= 1;\n    end else begin\n        V <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    Q <= Q_next_next_next;\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "dc02531e3ea25d9d3ddd589814771588",
        "dataset_index": 2099
      },
      "Span12Mux_v0_68b57e2b": {
        "rtl_code": "\nmodule Span12Mux_v0(I, S, O);\n  input [11:0] I;\n  input [3:0] S;\n  output reg [11:0] O;\n\n  always @ (S or I) begin\n    case (S)\n      4'b0000: O <= I;\n      4'b0001: O <= I;\n      4'b0010: O <= I;\n      4'b0011: O <= I;\n      4'b0100: O <= I;\n      4'b0101: O <= I;\n      4'b0110: O <= I;\n      4'b0111: O <= I;\n      4'b1000: O <= I;\n      4'b1001: O <= I;\n      4'b1010: O <= I;\n      4'b1011: O <= I;\n      default: O <= 0;\n    endcase\n  end\nendmodule",
        "module_name": "Span12Mux_v0",
        "module_hash": "68b57e2bced707d984044f965d51622e",
        "dataset_index": 20219
      },
      "system_control_a666db9e": {
        "rtl_code": "module system_control \n  (input wb_clk_i,\n   output reg ram_loader_rst_o,\n   output reg wb_rst_o,\n   input ram_loader_done_i\n   );\n\n   reg \t\tPOR = 1'b1;\n   reg [3:0] \tPOR_ctr;\n\n   initial POR_ctr = 4'd0;\n   always @(posedge wb_clk_i)\n     if(POR_ctr == 4'd15)\n       POR <= 1'b0;\n     else\n       POR_ctr <= POR_ctr + 4'd1;\n   \n   always @(posedge POR or posedge wb_clk_i)\n     if(POR)\n       ram_loader_rst_o <= 1'b1;\n     else\n       ram_loader_rst_o <= #1 1'b0;\n\n   reg \t\tdelayed_rst;\n   \n   always @(posedge POR or posedge wb_clk_i)\n     if(POR)\n       begin\n\t  wb_rst_o <= 1'b1;\n\t  delayed_rst <= 1'b1;\n       end\n     else if(ram_loader_done_i)\n       begin\n\t  delayed_rst <= 1'b0;\n\t  wb_rst_o <= delayed_rst;\n       end\n\nendmodule ",
        "module_name": "system_control",
        "module_hash": "a666db9eecba47f72244b2f0a34a51c8",
        "dataset_index": 23941
      },
      "mux21_reg_49d08057": {
        "rtl_code": "module mux21_reg(\n    input I0,\n    input I1,\n    input S,\n    input clk,\n    output reg O\n);\n\nalways @(posedge clk) begin\n    if (S == 0) begin\n        O <= I0;\n    end else begin\n        O <= I1;\n    end\nend\n\nendmodule",
        "module_name": "mux21_reg",
        "module_hash": "49d0805757cd42b0cb7de15216c4acdd",
        "dataset_index": 9357
      },
      "uart_tx #_eacfbd10": {
        "rtl_code": "\n\n\nmodule uart_tx #\n(\n    parameter DATA_WIDTH = 8\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]  input_axis_tdata,\n    input  wire                   input_axis_tvalid,\n    output wire                   input_axis_tready,\n\n    \n    output wire                   txd,\n\n    \n    output wire                   busy,\n\n    \n    input  wire [3:0]            uart_data_width,\n    input  wire [1:0]            uart_bits,\n    input  wire [1:0]            uart_parity,\n\tinput  wire [1:0]            uart_stopbit,\n    input  wire [15:0]            prescale\n);\n\nreg input_axis_tready_reg = 0;\n\nreg txd_reg = 1;\n\nreg busy_reg = 0;\n\nreg [DATA_WIDTH+2:0] data_reg = 0;\nreg [18:0] prescale_reg = 0;\nreg [3:0] bit_cnt = 0;\n\nassign input_axis_tready = input_axis_tready_reg;\nassign txd = txd_reg;\n\nassign busy = busy_reg;\n\ngenvar idx;\nwire parity;\nwire [DATA_WIDTH-1:0] bitmask_parity;\nwire [DATA_WIDTH-1:0] bitmask_parity_reversed;\nassign bitmask_parity = ~((1<<uart_bits) - 1);\ngenerate\n    for(idx = 0; idx < DATA_WIDTH; idx = idx + 1) begin : PROCESS_REVERSE_BITS\n        assign bitmask_parity_reversed[idx] = bitmask_parity[DATA_WIDTH-idx-1];\n    end\nendgenerate\nassign parity = (^(input_axis_tdata & bitmask_parity_reversed)) ^ uart_parity[1];\n\nalways @(posedge clk) begin\n    if (rst) begin\n        input_axis_tready_reg <= 0;\n        txd_reg <= 1;\n        prescale_reg <= 0;\n        bit_cnt <= 0;\n        busy_reg <= 0;\n    end else begin\n        if (prescale_reg > 0) begin\n            input_axis_tready_reg <= 0;\n            prescale_reg <= prescale_reg - 1;\n        end else if (bit_cnt == 0) begin\n            input_axis_tready_reg <= 1;\n            busy_reg <= 0;\n\n            if (input_axis_tvalid) begin\n                input_axis_tready_reg <= ~input_axis_tready_reg;\n                prescale_reg <= (prescale << 3)-1;\n                bit_cnt <= uart_data_width+(uart_stopbit?2:1);\n\t\t\t\tif(uart_parity == 2'b00)\n\t\t\t\tcase(uart_bits)\n\t\t\t\t\t2'b00: data_reg <= {3'b111, input_axis_tdata};\n\t\t\t\t\t2'b01: data_reg <= {4'b1111, input_axis_tdata[DATA_WIDTH-2:0]};\n\t\t\t\t\t2'b10: data_reg <= {5'b11111, input_axis_tdata[DATA_WIDTH-3:0]};\n\t\t\t\t\t2'b11: data_reg <= {6'b111111, input_axis_tdata[DATA_WIDTH-4:0]};\n\t\t\t\tendcase\n\t\t\t\telse\n\t\t\t\tcase(uart_bits)\n\t\t\t\t\t2'b00: data_reg <= {2'b11, parity, input_axis_tdata};\n\t\t\t\t\t2'b01: data_reg <= {3'b111, parity, input_axis_tdata[DATA_WIDTH-2:0]};\n\t\t\t\t\t2'b10: data_reg <= {4'b1111, parity, input_axis_tdata[DATA_WIDTH-3:0]};\n\t\t\t\t\t2'b11: data_reg <= {5'b11111, parity, input_axis_tdata[DATA_WIDTH-4:0]};\n\t\t\t\tendcase\n                txd_reg <= 0;\n                busy_reg <= 1;\n            end\n        end else begin\n            if (bit_cnt > 1) begin\n                bit_cnt <= bit_cnt - 1;\n                if (bit_cnt == 2 && uart_stopbit[1] == 1'b1) prescale_reg <= (prescale << 2)-1;\n\t\t\t\telse prescale_reg <= (prescale << 3)-1;\n                {data_reg, txd_reg} <= {1'b0, data_reg};\n            end else if (bit_cnt == 1) begin\n                bit_cnt <= bit_cnt - 1;\n                prescale_reg <= (prescale << 3);\n                txd_reg <= 1;\n            end\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "uart_tx #",
        "module_hash": "eacfbd10d988ea8e5bc0df69d5e4d1b0",
        "dataset_index": 24375
      },
      "SevenSegmentLED_a06a3245": {
        "rtl_code": "module SevenSegmentLED(\n    i_data,\n    o_a,\n    o_b,\n    o_c,\n    o_d,\n    o_e,\n    o_f,\n    o_g);\n  input [3:0] i_data;\n  output      o_a;\n  output      o_b;\n  output      o_c;\n  output      o_d;\n  output      o_e;\n  output      o_f;\n  output      o_g;\n\n  wire  [6:0] w_out;\n\n  function [6:0] Decode;\n    input [3:0] data;\n    begin\n      case (i_data)\n        4'h0: Decode = 7'b0000001;\n        4'h1: Decode = 7'b1001111;\n        4'h2: Decode = 7'b0010010;\n        4'h3: Decode = 7'b0000110;\n        4'h4: Decode = 7'b1001100;\n        4'h5: Decode = 7'b0100100;\n        4'h6: Decode = 7'b0100000;\n        4'h7: Decode = 7'b0001111;\n        4'h8: Decode = 7'b0000000;\n        4'h9: Decode = 7'b0000100;\n        4'ha: Decode = 7'b0001000;\n        4'hb: Decode = 7'b1100000;\n        4'hc: Decode = 7'b0110001;\n        4'hd: Decode = 7'b1000010;\n        4'he: Decode = 7'b0110000;\n        4'hf: Decode = 7'b0111000;\n      endcase\n    end\n  endfunction  assign      w_out = Decode(i_data);\n  assign      o_a = w_out[6];\n  assign      o_b = w_out[5];\n  assign      o_c = w_out[4];\n  assign      o_d = w_out[3];\n  assign      o_e = w_out[2];\n  assign      o_f = w_out[1];\n  assign      o_g = w_out[0];\n\nendmodule  ",
        "module_name": "SevenSegmentLED",
        "module_hash": "a06a3245ed5c9eaa138455948e3ccd20",
        "dataset_index": 13007
      },
      "timecode_memory_interface_fef3e9b9": {
        "rtl_code": "module timecode_memory_interface(\n    input clk,\n    input reset,\n    input [7:0] timecode_data,\n    input timecode_valid,\n    input [12:0] timecode_address,\n    output reg [7:0] data_out,\n    output reg write_enable\n);\n\n    // Internal signals\n    reg [7:0] memory_data;\n    reg [12:0] memory_address;\n    reg memory_write_enable;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset internal signals\n            memory_data <= 8'h00;\n            memory_address <= 13'h000;\n            memory_write_enable <= 1'b0;\n            data_out <= 8'h00;\n            write_enable <= 1'b0;\n        end else begin\n            if (timecode_valid) begin\n                // Write timecode data to memory\n                memory_data <= timecode_data;\n                memory_address <= timecode_address;\n                memory_write_enable <= 1'b1;\n            end else begin\n                // Read data from memory\n                memory_address <= timecode_address;\n                memory_write_enable <= 1'b0;\n                data_out <= memory_data;\n                write_enable <= memory_write_enable;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "timecode_memory_interface",
        "module_hash": "fef3e9b9c34aeddf631667b18e44ae03",
        "dataset_index": 3073
      },
      "multiplexer #_ea3c355e": {
        "rtl_code": "module multiplexer #(parameter N = 1) (\n    input ctrl,\n    input [N-1:0] D0,\n    input [N-1:0] D1,\n    output [N-1:0] S\n);\n\ngenvar i;\ngenerate\n    for (i = 0; i < N; i = i + 1) begin : mux_loop\n        assign S[i] = (ctrl == 1'b0) ? D0[i] : D1[i];\n    end\nendgenerate\n\nendmodule",
        "module_name": "multiplexer #",
        "module_hash": "ea3c355ee914581037a4dde45864083e",
        "dataset_index": 17827
      },
      "Profibus_8bd5647f": {
        "rtl_code": "\nmodule Profibus (\n  input clk,\n  input rst,\n  input [7:0] din_master,\n  input [7:0] din_slave,\n  output reg [7:0] dout_master,\n  output reg [7:0] dout_slave,\n  output status_master,\n  output status_slave\n);\n\n  // Define communication protocol between master and slave\n  reg [1:0] state_master;\n  reg [1:0] state_slave;\n  parameter IDLE = 2'b00;\n  parameter SEND_CMD = 2'b01;\n  parameter RECEIVE_DATA = 2'b10;\n  parameter SEND_DATA = 2'b11;\n  \n  // Define communication lines between master and slave\n  reg [7:0] cmd_master;\n  reg [7:0] cmd_slave;\n  reg [7:0] data_master;\n  reg [7:0] data_slave;\n  \n  // Status signals to indicate idle state\n  wire status_master_int;\n  wire status_slave_int;\n  assign status_master = (state_master == IDLE) ? 1'b1 : 1'b0;\n  assign status_slave = (state_slave == IDLE) ? 1'b1 : 1'b0;\n  \n  // Master block\n  always @(posedge clk) begin\n    if (rst) begin\n      state_master <= IDLE;\n      dout_slave <= 8'b0;\n    end else begin\n      case (state_master)\n        IDLE: begin\n          if (din_master != 8'b0) begin\n            cmd_master <= din_master;\n            state_master <= SEND_CMD;\n          end\n        end\n        SEND_CMD: begin\n          dout_slave <= cmd_master;\n          state_master <= RECEIVE_DATA;\n        end\n        RECEIVE_DATA: begin\n          if (din_master != 8'b0) begin\n            data_master <= din_master;\n            state_master <= SEND_DATA;\n          end\n        end\n        SEND_DATA: begin\n          dout_slave <= data_master;\n          state_master <= IDLE;\n        end\n      endcase\n    end\n  end\n  \n  // Slave block\n  always @(posedge clk) begin\n    if (rst) begin\n      state_slave <= IDLE;\n      dout_master <= 8'b0;\n    end else begin\n      case (state_slave)\n        IDLE: begin\n          if (din_slave != 8'b0) begin\n            cmd_slave <= din_slave;\n            state_slave <= RECEIVE_DATA;\n          end\n        end\n        RECEIVE_DATA: begin\n          dout_master <= cmd_slave;\n          state_slave <= SEND_DATA;\n        end\n        SEND_DATA: begin\n          if (din_slave != 8'b0) begin\n            data_slave <= din_slave;\n            state_slave <= IDLE;\n          end\n        end\n      endcase\n    end\n  end\n  \nendmodule\n",
        "module_name": "Profibus",
        "module_hash": "8bd5647f5da2c706524917c59f4ddb89",
        "dataset_index": 19985
      },
      "USB_JTAG_6d9198ec": {
        "rtl_code": "module USB_JTAG (iTxD_DATA, oTxD_Done,  iTxD_Start,\n                 oRxD_DATA, oRxD_Ready, iRST_n,iCLK,\n\n                 TDO, TDI, TCS, TCK);\n\ninput       [7:0] iTxD_DATA;\ninput             iTxD_Start, iRST_n, iCLK;\noutput reg  [7:0] oRxD_DATA;\noutput reg        oTxD_Done, oRxD_Ready;\n\ninput             TDI, TCS, TCK;\noutput            TDO;\n\nwire  [7:0] mRxD_DATA;\nwire        mTxD_Done, mRxD_Ready;                      \n\nreg         Pre_TxD_Done, Pre_RxD_Ready;\nreg         mTCK;\n\n   JTAG_REC u0 (mRxD_DATA, mRxD_Ready, TDI, TCS, mTCK);\n\n  JTAG_TRANS u1 (iTxD_DATA, iTxD_Start, mTxD_Done, TDO, TCK, TCS);\n\n\nalways @(posedge iCLK)\nbegin\n  mTCK <= TCK;\nend\n\nalways @(posedge iCLK or negedge iRST_n)\nbegin\n  if(!iRST_n)\n  begin\n    oRxD_Ready    <= 1'b0;\n    Pre_RxD_Ready <= 1'b0;\n  end\n  else\n  begin\n    Pre_RxD_Ready <= mRxD_Ready;\n\n    if ({Pre_RxD_Ready, mRxD_Ready} == 2'b01 && ~iTxD_Start)\n    begin\n      oRxD_Ready <= 1'b1;\n      oRxD_DATA  <= mRxD_DATA;\n    end\n    else\n    begin\n      oRxD_Ready <= 1'b0;\n    end\n  end\nend\n\nalways @(posedge iCLK or negedge iRST_n)\nbegin\n  if(!iRST_n)\n  begin\n    oTxD_Done    <= 1'b0;\n    Pre_TxD_Done <= 1'b0;\n  end\n  else\n  begin\n    Pre_TxD_Done <= mTxD_Done;\n\n    if ({Pre_TxD_Done,mTxD_Done} == 2'b01)\n    begin\n      oTxD_Done  <= 1'b1;\n    end\n    else\n    begin\n      oTxD_Done  <= 1'b0;\n    end\n  end\nend\nendmodule\n\nmodule JTAG_REC (oRxD_DATA, oRxD_Ready,\n\n                 TDI, TCS, TCK);\n\ninput             TDI, TCS, TCK;\noutput reg  [7:0] oRxD_DATA;\noutput reg        oRxD_Ready;\n\nreg         [7:0] rDATA;\nreg         [2:0] rCont;\n\nalways@(posedge TCK or posedge TCS)\nbegin\n  if(TCS)\n  begin\n    oRxD_Ready <= 1'b0;\n    rCont      <= 3'b000;\n  end\n  else\n  begin\n    rCont        <= rCont + 3'b001;\n    rDATA        <= {TDI, rDATA[7:1]};\n\n    if (rCont == 3'b000)\n    begin\n      oRxD_DATA  <= {TDI, rDATA[7:1]};\n      oRxD_Ready <= 1'b1;\n    end\n    else\n    begin\n      oRxD_Ready <= 1'b0;\n    end\n  end\nend             \nendmodule\n\nmodule JTAG_TRANS (iTxD_DATA, iTxD_Start, oTxD_Done,\n\n                   TDO, TCK, TCS);\n\ninput       [7:0] iTxD_DATA;\ninput             iTxD_Start;\noutput reg        oTxD_Done;\ninput             TCK, TCS;\noutput reg        TDO;\n\nreg         [2:0] rCont;\n\nalways@(posedge TCK or posedge TCS)\nbegin\n  if (TCS)\n  begin\n    oTxD_Done   <= 1'b0;\n    rCont       <= 3'b000;\n    TDO         <= 1'b0;\n  end\n  else\n  begin\n    if (iTxD_Start)\n    begin\n      rCont     <= rCont + 3'b001;\n      TDO       <= iTxD_DATA[rCont];\n    end\n    else\n    begin\n      rCont     <= 3'b000;\n      TDO       <= 1'b0;\n    end\n\n    if (rCont == 3'b111)\n    begin\n      oTxD_Done <= 1'b1;\n    end\n    else\n    begin\n      oTxD_Done <= 1'b0;\n    end\n  end\nend\n\nendmodule\n\n",
        "module_name": "USB_JTAG",
        "module_hash": "6d9198ec71cadc2f1a3e58a909ede064",
        "dataset_index": 22752
      },
      "mux_2_1_37f8ee83": {
        "rtl_code": "module mux_2_1 (\n    // Input ports\n    input A,\n    input B,\n    input S,\n\n    // Output port\n    output Y\n);\n\n    assign Y = (S == 1) ? B : A;\n\nendmodule",
        "module_name": "mux_2_1",
        "module_hash": "37f8ee8318fbf905d438a96f39d7916a",
        "dataset_index": 7564
      },
      "calculator_fixed_0e5dafa7": {
        "rtl_code": "\nmodule calculator_fixed(input [3:0] num1, input [3:0] num2, input [1:0] op, input clk, input rst, output [3:0] result, output [3:0] display);\n\nreg [7:0] temp_result;\nreg [3:0] temp_display;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        temp_result <= 0;\n        temp_display <= 0;\n    end else begin\n        case (op)\n            2'b00: begin // addition\n                temp_result <= num1 + num2;\n            end\n            2'b01: begin // subtraction\n                temp_result <= num1 - num2;\n            end\n            2'b10: begin // multiplication\n                temp_result <= num1 * num2;\n            end\n            2'b11: begin // division\n                temp_result <= num1 / num2;\n            end\n        endcase\n        case (op)\n            2'b00: begin // addition\n                temp_display <= {1'b0, temp_result[3:0]}; // Corrected to add leading zero for addition\n            end\n            2'b01: begin // subtraction\n                if (temp_result[7]) begin // Negative number\n                    temp_display <= {1'b1, temp_result[3:0]}; // Corrected to add negative sign for negative numbers\n                end else begin // Positive number\n                    temp_display <= {1'b0, temp_result[3:0]}; // Corrected to add leading zero for positive numbers\n                end\n            end\n            2'b10: begin // multiplication\n                temp_display <= temp_result[3:0]; // Corrected to remove leading zero for multiplication\n            end\n            2'b11: begin // division\n                temp_display <= {1'b0, temp_result[3:0]}; // Corrected to add leading zero for division\n            end\n        endcase\n    end\nend\n\nassign result = temp_result[3:0];\nassign display = temp_display;\n\nendmodule",
        "module_name": "calculator_fixed",
        "module_hash": "0e5dafa7eefaaee6057a33b6f9233feb",
        "dataset_index": 8903
      },
      "wishbone_buf_480c6a6e": {
        "rtl_code": "\nmodule wishbone_buf (\n    input i_clk,\n    input i_req,\n    input i_write,\n    input [127:0] i_wdata,\n    input [15:0] i_be,\n    input [31:0] i_addr,\n    output [127:0] o_rdata,\n    output o_ack,\n    output o_valid,\n    input i_accepted,\n    output o_write,\n    output [127:0] o_wdata,\n    output [15:0] o_be,\n    output [31:0] o_addr,\n    input [127:0] i_rdata,\n    input i_rdata_valid\n);\n\nreg [1:0] wbuf_used_r = 2'd0;\nreg [31:0] wbuf_addr_r0;\nreg [31:0] wbuf_addr_r1;\nreg [127:0] wbuf_wdata_r0;\nreg [127:0] wbuf_wdata_r1;\nreg [15:0] wbuf_be_r0;\nreg [15:0] wbuf_be_r1;\nreg [1:0] wbuf_write_r = 2'd0;\nreg wbuf_wp_r = 1'd0;\nreg wbuf_rp_r = 1'd0;\nreg busy_reading_r = 1'd0;\nreg wait_rdata_valid_r = 1'd0;\nreg ack_owed_r = 1'd0;\nwire in_wreq;\n\nassign in_wreq = i_req && i_write;\n\nalways @(posedge i_clk) begin\n    if ((in_wreq && !busy_reading_r) && ((wbuf_used_r == 2'd1) || (wbuf_used_r == 2'd0 && !i_accepted))) begin\n        wbuf_used_r <= wbuf_used_r + 1'd1;\n    end else if (o_valid && i_accepted && (wbuf_used_r != 2'd0)) begin\n        wbuf_used_r <= wbuf_used_r - 1'd1;\n    end\nend\n\nalways @(posedge i_clk) begin\n    if (in_wreq) begin\n        ack_owed_r <= 1'd1;\n    end else if (!i_req && o_ack) begin\n        ack_owed_r <= 1'd0;\n    end\nend\n\nalways @(posedge i_clk) begin\n    if (in_wreq && !o_ack) begin\n        if (wbuf_wp_r == 1'd0) begin\n            wbuf_wdata_r0 <= i_wdata;\n            wbuf_addr_r0 <= i_addr;\n            wbuf_be_r0 <= i_write ? i_be : 16'hffff;\n            wbuf_write_r[0] <= i_write;\n        end else if (wbuf_wp_r == 1'd1) begin\n            wbuf_wdata_r1 <= i_wdata;\n            wbuf_addr_r1 <= i_addr;\n            wbuf_be_r1 <= i_write ? i_be : 16'hffff;\n            wbuf_write_r[1] <= i_write;\n        end\n        wbuf_wp_r <= !wbuf_wp_r;\n    end\nend\n\nalways @(posedge i_clk) begin\n    if (o_valid && i_accepted && (wbuf_used_r != 2'd0)) begin\n        wbuf_rp_r <= !wbuf_rp_r;\n    end\nend\n\nassign o_wdata = (wbuf_used_r != 2'd0) ? (wbuf_rp_r == 1'd0 ? wbuf_wdata_r0 : wbuf_wdata_r1 ) : i_wdata;\nassign o_write = (wbuf_used_r != 2'd0) ? (wbuf_rp_r == 1'd0 ? wbuf_write_r[0] : wbuf_write_r[1]) : i_write;\nassign o_addr = (wbuf_used_r != 2'd0) ? (wbuf_rp_r == 1'd0 ? wbuf_addr_r0 : wbuf_addr_r1 ) : i_addr;\nassign o_be = (wbuf_used_r != 2'd0) ? (wbuf_rp_r == 1'd0 ? wbuf_be_r0 : wbuf_be_r1) : i_write ? i_be : 16'hffff;\nassign o_ack = (in_wreq ? (wbuf_used_r == 2'd0) : i_rdata_valid) || (ack_owed_r && o_valid && i_accepted && (wbuf_used_r != 2'd0));\nassign o_valid = (wbuf_used_r != 2'd0 || i_req) && !wait_rdata_valid_r;\nassign o_rdata = i_rdata;\n\nalways @(posedge i_clk) begin\n    if (o_valid && !o_write) begin\n        busy_reading_r <= 1'd1;\n    end else if (i_rdata_valid) begin\n        busy_reading_r <= 1'd0;\n    end\nend\n\nalways @(posedge i_clk) begin\n    if (o_valid && !o_write && i_accepted) begin\n        wait_rdata_valid_r <= 1'd1;\n    end else if (i_rdata_valid) begin\n        wait_rdata_valid_r <= 1'd0;\n    end\nend\n\nendmodule",
        "module_name": "wishbone_buf",
        "module_hash": "480c6a6e878083203366cd2b2c23d36f",
        "dataset_index": 1104
      },
      "schmitt_trigger_d35da216": {
        "rtl_code": "\nmodule schmitt_trigger (\n  input in,\n  input clk,\n  output out\n);\n\nparameter vth = 1'b1; // threshold voltage for switching from low to high\nparameter vtl = 1'b0; // threshold voltage for switching from high to low\nparameter hysteresis = 1'b1; // difference between vth and vtl\n\nreg out_reg; // output register\nreg prev_in; // previous input value\n\nalways @(posedge clk) begin\n  if (in > (vth + hysteresis)) begin\n    out_reg <= 1'b1;\n  end else if (in < (vtl - hysteresis)) begin\n    out_reg <= 1'b0;\n  end\n  prev_in <= in;\nend\n\nassign out = out_reg;\n\nendmodule",
        "module_name": "schmitt_trigger",
        "module_hash": "d35da2162734d3d515619c23cb019cc4",
        "dataset_index": 6318
      },
      "consecutive_ones_counter_1ecff290": {
        "rtl_code": "module consecutive_ones_counter (\n  input clk,\n  input reset,\n  input [3:0] data,\n  output reg [2:0] count\n);\n\nreg [2:0] count_reg;\nreg [2:0] count_next;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count_reg <= 3'b000;\n  end else begin\n    count_reg <= count_next;\n  end\nend\n\nalways @* begin\n  count_next = 3'b000;\n  if (data[0] == 1) begin\n    count_next = 3'b001;\n    if (data[1] == 1) begin\n      count_next = 3'b010;\n      if (data[2] == 1) begin\n        count_next = 3'b011;\n      end\n    end\n  end\nend\n\nalways @* begin\n  count = count_reg;\nend\n\nendmodule",
        "module_name": "consecutive_ones_counter",
        "module_hash": "1ecff290c58c4b12653619b851a73cb8",
        "dataset_index": 3823
      },
      "zero_detect_owire_36ea24ac": {
        "rtl_code": "module zero_detect_owire(in, out);\n  input [3:0] in;\n  output out;\n  \n  // local\n  wire zero_found;\n  assign zero_found = |in; // OR reduction\n\n  // out\n  assign out = ~zero_found;\nendmodule",
        "module_name": "zero_detect_owire",
        "module_hash": "36ea24ac3418773fbf127a76eebc8da7",
        "dataset_index": 6654
      },
      "adder_comparator_5b05a4ed": {
        "rtl_code": "\nmodule adder_comparator (\n  input clk,\n  input reset,\n  input [3:0] input1,\n  input [3:0] input2,\n  output reg [3:0] sum,  // Declare sum as a register\n  output reg [1:0] comparison_result\n);\n\nreg [3:0] adder_output;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    adder_output <= 4'b0;\n    comparison_result <= 2'b0;\n  end else begin\n    adder_output <= input1 + input2;\n    sum <= adder_output; // Assign the value of adder_output to sum\n    \n    if (adder_output[3:2] > 2'b10) begin\n      comparison_result <= 2'b10; // greater than\n    end else if (adder_output[3:2] == 2'b10) begin\n      comparison_result <= 2'b01; // equal to\n    end else begin\n      comparison_result <= 2'b00; // less than\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "adder_comparator",
        "module_hash": "5b05a4ed02c62b644c99f02348028034",
        "dataset_index": 19832
      },
      "d_ff_cffb9480": {
        "rtl_code": "module d_ff(\n  input         clock,\n  input         reset,\n  input  [10:0] io_in,\n  input  [10:0] io_init,\n  output [10:0] io_out,\n  input         io_enable\n);\n  wire [10:0] d;\n  reg [10:0] ff;\n  wire  _T_13;\n  wire [10:0] _GEN_1;\n  assign io_out = ff;\n  assign d = _GEN_1;\n  assign _T_13 = io_enable == 1'h0;\n  assign _GEN_1 = _T_13 ? ff : io_in;\n  \n  always @(posedge clock) begin\n    if (reset) begin\n      ff <= io_init;\n    end else if (io_enable) begin\n      ff <= d;\n    end\n  end\nendmodule",
        "module_name": "d_ff",
        "module_hash": "cffb94809763e668ecdc87e4e0251206",
        "dataset_index": 13532
      },
      "Comparator #_0d57d729": {
        "rtl_code": "module Comparator #(\n  parameter n = 8 \n) (\n  input [n-1:0] a,\n  input [n-1:0] b,\n  output gt,\n  output lt,\n  output eq\n);\n\n\nwire [n-1:0] a_xor_b;\nwire [n-1:0] a_and_b;\nwire [n-1:0] a_lt_b;\nwire [n-1:0] a_eq_b;\n\nassign a_xor_b = a ^ b;\nassign a_and_b = a & b;\nassign a_lt_b = ~a_and_b & a_xor_b;\nassign a_eq_b = ~a_xor_b;\n\nassign gt = |(a_lt_b);\nassign lt = |(~(a_lt_b | a_eq_b));\nassign eq = |(a_eq_b);\n\nendmodule",
        "module_name": "Comparator #",
        "module_hash": "0d57d72955ab08b36f2346d6903bf20a",
        "dataset_index": 713
      },
      "multiplier__c1ea1e11": {
        "rtl_code": "module multiplier_module (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [15:0] i_data0;\n  output  [15:0] o_data0;\n\n  //Multipliers:\n  wire [15:0]\n    w1,\n    w2,\n    w3,\n    w4,\n    w5,\n    w6,\n    w7,\n    w8,\n    w9,\n    w10,\n    w11,\n    w12,\n    w13,\n    w14,\n    w15,\n    w16;\n\n  assign w1 = i_data0;\n  assign w2 = w1 << 1;\n  assign w3 = w1 << 2;\n  assign w4 = w1 << 3;\n  assign w5 = w1 << 4;\n  assign w6 = w1 << 5;\n  assign w7 = w1 << 6;\n  assign w8 = w1 << 7;\n  assign w9 = w1 << 8;\n  assign w10 = w1 << 9;\n  assign w11 = w1 << 10;\n  assign w12 = w1 << 11;\n  assign w13 = w1 << 12;\n  assign w14 = w1 << 13;\n  assign w15 = w1 << 14;\n  assign w16 = w1 << 15;\n\n  assign o_data0 = w1 + w2 + w3 + w4 + w5 + w6 + w7 + w8 + w9 + w10 + w11 + w12 + w13 + w14 + w15 + w16;\n\nendmodule",
        "module_name": "multiplier_",
        "module_hash": "c1ea1e11033e2997a87759cbc16212df",
        "dataset_index": 9561
      },
      "jt10_adpcm_comb_dd8869c4": {
        "rtl_code": "\n\nmodule jt10_adpcm_comb(\n    input           rst_n,\n    input           clk,        input           cen,        input   [3:0]   data,\n    input           chon,       output signed [15:0] pcm\n);\n\nlocalparam stepw = 15;\n\nreg signed [15:0] x1, x2, x3, x4, x5, x6;\nreg [stepw-1:0] step1, step2, step6;\nreg [stepw+1:0] step3, step4, step5;\nassign pcm = x2;\n\nreg  [18:0] d2l;\nreg  [15:0] d3,d4;\nreg  [3:0]  d1,d2;\nreg         sign2, sign3, sign4, sign5;\nreg  [7:0]  step_val;\nreg  [22:0] step2l;\n\nreg chon2, chon3, chon4, chon5;\nreg signEqu4, signEqu5;\nreg [3:0] data1,data2;\n\nalways @( * )\n    if( ! rst_n ) begin\n        x2 = 'd0; step2 = 'd127;\n        x3 = 'd0; step3 = 'd127;\n        x4 = 'd0; step4 = 'd127;\n        x5 = 'd0; step5 = 'd127;\n        x6 = 'd0; step6 = 'd127;\n        d2 = 'd0; d3 = 'd0; d4 = 'd0;\n        sign2 = 'b0;\n        sign3 = 'b0;\n        sign4 = 'b0; sign5 = 'b0;\n        chon2 = 'b0;   chon3 = 'b0;   chon4 = 'b0; chon5 = 1'b0;\n    end else begin\n        d2        = d1;\n        sign2     = data1[3];\n        data2     = data1;\n        x2        = x1;\n        step2     = step1;\n        chon2     = chon;\n        casez( d2[3:1] )\n            3'b0_??: step_val = 8'd57;\n            3'b1_00: step_val = 8'd77;\n            3'b1_01: step_val = 8'd102;\n            3'b1_10: step_val = 8'd128;\n            3'b1_11: step_val = 8'd153;\n        endcase d2l    = d2 * step2; step2l = step_val * step2; d3        = d2l[18:3]; sign3     = sign2;\n        x3        = x2;\n        step3     = step2l[22:6];\n        chon3     = chon2;\n        d4        = sign3 ? ~d3+16'b1 : d3;\n        sign4     = sign3;\n        signEqu4  = sign3 == x3[15];\n        x4        = x3;\n        step4     = step3;\n        chon4     = chon3;\n        x5        = x4+d4;\n        sign5     = sign4;\n        signEqu5  = signEqu4;\n        step5     = step4;\n        chon5     = chon4;\n        if( chon5 ) begin\n            if( signEqu5 && (sign5!=x5[15]) )\n                x6 = sign5 ? 16'h8000 : 16'h7FFF;\n            else\n                x6 = x5;\n\n            if( step5 < 127 )\n                step6  = 15'd127;\n            else if( step5 > 24576 )\n                step6  = 15'd24576;\n            else\n                step6 = step5[14:0];\n        end else begin\n            x6      = 'd0;\n            step6   = 'd127;\n        end\n    end\n\nalways @(posedge clk or negedge rst_n) \n    if( ! rst_n ) begin\n        x1 <= 'd0; step1 <= 'd127; \n        d1 <= 'd0; data1 <= 'd0;\n    end else if(cen) begin\n        d1    <= {data[2:0],1'b1};\n        x1    <= x6;\n        step1 <= step6;\n        data1 <= data;\n    end\n\nendmodule // jt10_adpcm    ",
        "module_name": "jt10_adpcm_comb",
        "module_hash": "dd8869c42e404a7d58c358329c859acb",
        "dataset_index": 22895
      },
      "mux2to1_behav_9967cce6": {
        "rtl_code": "module mux2to1_behav (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule",
        "module_name": "mux2to1_behav",
        "module_hash": "9967cce67c8b21bc2fb0fd3ff595658d",
        "dataset_index": 1015
      },
      "ME_WB_bd418927": {
        "rtl_code": "\nmodule ME_WB(\n\tclk,rst,stall,\n\tme_memdata, me_td, me_WREG,\n\twb_memdata, wb_td, wb_WREG\n    );\n\tinput clk,rst,stall;\n\tinput wire [31:0] me_memdata;\n\tinput wire [4:0] me_td;\n\tinput wire me_WREG;\n\toutput reg [31:0] wb_memdata;\n\toutput reg [4:0] wb_td;\n\toutput reg wb_WREG;\n\n\talways @(posedge clk or posedge rst)\n\tbegin\n\tif(rst)\n\tbegin\n\t\twb_memdata <= 0;\n\t\twb_td <= 0;\n\t\twb_WREG <= 0;\n\tend\n\telse if(stall)\n\tbegin\n\t\t\twb_memdata <= 0;\n\t\t\twb_td <= 0;\n\t\t\twb_WREG <= 0;\n\tend\n\telse\n\tbegin\n\t\twb_memdata <= me_memdata;\n\t\twb_td <= me_td;\n\t\twb_WREG <= me_WREG;\n\tend\n\tend\n\t\nendmodule\n",
        "module_name": "ME_WB",
        "module_hash": "bd418927faf33f8bd4bf1b7e7961eb4f",
        "dataset_index": 15621
      },
      "tone_generator_17f98c3b": {
        "rtl_code": "module tone_generator (\n    input wire clk,\n    input wire [2:0] octave,\n    input wire [8:0] freq,\n    output reg out,\n    output reg pulseout\n);\n  \n    reg [7:0] fcounter;\n    always @* begin\n        case (octave)\n            3'd0: fcounter = 8'd255;\n            3'd1: fcounter = 8'd127;\n            3'd2: fcounter = 8'd63;\n            3'd3: fcounter = 8'd31;\n            3'd4: fcounter = 8'd15;\n            3'd5: fcounter = 8'd7;\n            3'd6: fcounter = 8'd3;\n            3'd7: fcounter = 8'd1;\n        endcase\n    end\n  \n    reg [7:0] count = 8'd0;\n    always @(posedge clk) begin\n        if (count == fcounter)\n            count <= 8'd0;\n        else\n        count <= count + 1;\n    end\n  \n    reg pulse;\n    always @* begin\n        if (count == fcounter)\n            pulse = 1'b1;\n        else\n            pulse = 1'b0;\n    end\n  \n    initial out = 1'b0;    \n    reg [8:0] cfinal = 9'd0;\n    always @(posedge clk) begin\n        if (pulse == 1'b1) begin\n            if (cfinal == freq) begin\n                cfinal <= 9'd0;\n                out <= ~out;\n            end\n            else\n                cfinal <= cfinal + 1;\n        end\n    end\n    \n    always @* begin\n        if (pulse == 1'b1 && cfinal == freq)\n            pulseout = 1'b1;\n        else\n            pulseout = 1'b0;\n    end\nendmodule",
        "module_name": "tone_generator",
        "module_hash": "17f98c3be7a42667cbd99cf027c5cbda",
        "dataset_index": 14966
      },
      "four_bit_adder_c8c073f7": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\nwire [3:0] carry;\nwire [3:0] xor_sum;\n\n// First bit\nfull_adder FA0(A[0], B[0], Cin, Sum[0], carry[0]);\nassign xor_sum[0] = A[0] ^ B[0];\n\n// Second bit\nfull_adder FA1(A[1], B[1], carry[0], Sum[1], carry[1]);\nassign xor_sum[1] = A[1] ^ B[1];\n\n// Third bit\nfull_adder FA2(A[2], B[2], carry[1], Sum[2], carry[2]);\nassign xor_sum[2] = A[2] ^ B[2];\n\n// Fourth bit\nfull_adder FA3(A[3], B[3], carry[2], Sum[3], carry[3]);\nassign xor_sum[3] = A[3] ^ B[3];\n\nassign Cout = carry[3] | xor_sum[3];\n\nendmodule\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output Sum,\n    output Cout\n);\n\nwire sum1;\nwire carry1;\n\n// First adder\nxor (sum1, A, B);\nand (carry1, A, B);\n\n// Second adder\nxor (Sum, sum1, Cin);\nand (Cout, sum1, Cin);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "c8c073f7768853a793c159627fa2a7ae",
        "dataset_index": 7222
      },
      "SyncCounter_e6374a94": {
        "rtl_code": "\nmodule SyncCounter(\n    input clk,\n    input rst,\n    output reg [3:0] count,\n    output [3:0] leds\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nassign leds = count;\n\nendmodule\n",
        "module_name": "SyncCounter",
        "module_hash": "e6374a941f709559057db542e83899d3",
        "dataset_index": 20790
      },
      "velocityControlHdl_Dynamic_Saturation_0c476a82": {
        "rtl_code": "\n\nmodule velocityControlHdl_Dynamic_Saturation\n          (\n           up,\n           u,\n           lo,\n           y,\n           sat_mode\n          );\n\n\n  input   signed [17:0] up;  input   signed [35:0] u;  input   signed [17:0] lo;  output  signed [35:0] y;  output  sat_mode;\n\n\n  wire signed [35:0] LowerRelop1_1_cast;  wire LowerRelop1_relop1;\n  wire signed [35:0] UpperRelop_1_cast;  wire UpperRelop_relop1;\n  wire signed [35:0] lo_dtc;  wire signed [35:0] Switch_out1;  wire signed [35:0] up_dtc;  wire signed [35:0] Switch2_out1;  wire LowerRelop1_out1;\n\n\n  assign LowerRelop1_1_cast = {{8{up[17]}}, {up, 10'b0000000000}};\n  assign LowerRelop1_relop1 = (u > LowerRelop1_1_cast ? 1'b1 :\n              1'b0);\n\n\n\n  assign UpperRelop_1_cast = {{8{lo[17]}}, {lo, 10'b0000000000}};\n  assign UpperRelop_relop1 = (u < UpperRelop_1_cast ? 1'b1 :\n              1'b0);\n\n\n\n  assign lo_dtc = {{8{lo[17]}}, {lo, 10'b0000000000}};\n\n\n\n  assign Switch_out1 = (UpperRelop_relop1 == 1'b0 ? u :\n              lo_dtc);\n\n\n\n  assign up_dtc = {{8{up[17]}}, {up, 10'b0000000000}};\n\n\n\n  assign Switch2_out1 = (LowerRelop1_relop1 == 1'b0 ? Switch_out1 :\n              up_dtc);\n\n\n\n  assign y = Switch2_out1;\n\n  assign LowerRelop1_out1 = LowerRelop1_relop1 | UpperRelop_relop1;\n\n\n\n  assign sat_mode = LowerRelop1_out1;\n\nendmodule  ",
        "module_name": "velocityControlHdl_Dynamic_Saturation",
        "module_hash": "0c476a82c4fa4b1c0226cad0bd548da6",
        "dataset_index": 22956
      },
      "vending_machine_896a2f4f": {
        "rtl_code": "module vending_machine(\n    input clk, // clock signal\n    input rst, // reset signal\n    input start, // start signal to initiate transaction\n    input cancel, // cancel signal to cancel transaction\n    input [1:0] coin, // input for coin values (00 - no coin, 01 - 5 cents, 10 - 10 cents, 11 - 25 cents)\n    output reg [6:0] display, // 7-segment display output for amount inserted (max value 99 cents)\n    output reg [1:0] dispense // output for item selection (00 - no item, 01 - item 1, 10 - item 2, 11 - item 3)\n    );\n\n    reg [6:0] amount_inserted = 0;\n    reg [1:0] item_selected = 0;\n    reg [6:0] item_price_1 = 25;\n    reg [6:0] item_price_2 = 50;\n    reg [6:0] item_price_3 = 75;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            amount_inserted <= 0;\n            item_selected <= 0;\n            display <= 0;\n            dispense <= 0;\n        end else if (start) begin\n            if (amount_inserted + coin <= 99) begin\n                amount_inserted <= amount_inserted + coin;\n                display <= amount_inserted;\n            end else begin\n                display <= 99;\n            end\n        end else if (cancel) begin\n            amount_inserted <= 0;\n            display <= 0;\n        end else if (amount_inserted >= item_price_1 && item_selected == 0) begin\n            item_selected <= 1;\n            amount_inserted <= amount_inserted - item_price_1;\n            display <= 0;\n            dispense <= item_selected;\n        end else if (amount_inserted >= item_price_2 && item_selected == 0) begin\n            item_selected <= 2;\n            amount_inserted <= amount_inserted - item_price_2;\n            display <= 0;\n            dispense <= item_selected;\n        end else if (amount_inserted >= item_price_3 && item_selected == 0) begin\n            item_selected <= 3;\n            amount_inserted <= amount_inserted - item_price_3;\n            display <= 0;\n            dispense <= item_selected;\n        end else begin\n            display <= amount_inserted;\n            dispense <= 0;\n        end\n    end\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "896a2f4f1259718ead89b70b64f8f77a",
        "dataset_index": 21133
      },
      "dual_edge_ff_e4aaea21": {
        "rtl_code": "module dual_edge_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= q1;\nend\n\nassign q = q2;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\ndual_edge_ff ff (\n    .clk(clk),\n    .d(d),\n    .q(q)\n);\n\nendmodule",
        "module_name": "dual_edge_ff",
        "module_hash": "e4aaea2117c9b5779b3a0d35aa251b97",
        "dataset_index": 4549
      },
      "main_54e55cb8": {
        "rtl_code": "\n\nmodule main(\n    input CLK100M,\n    input CLK24M576,\n    input CLK22M5792,\n    output LED_M,\n    output [3:0] LED,\n    output [3:0] SPDIF,\n    output [3:0] GPIO,\n    output UART_RXD,\n    output UART_TXD,\n    output SPI_MISO,\n    output SPI_MOSI,\n    output SPI_SSEL,\n    output SPI_SCK,\n    output I2S0_MCLK,\n    output I2S0_WS,\n    output I2S0_SDA,\n    output I2S0_SCK,\n    output I2S1_MCLK_N,\n    output I2S1_MCLK_P,\n    output I2S1_WS,\n    output I2S1_SDA,\n    output I2S1_SCK,\n    output I2S2_MCLK,\n    output I2S2_WS,\n    output I2S2_SDA,\n    output I2S2_SCK,\n    output SATA_RX_N,\n    output SATA_RX_P,\n    output SATA_TX_N,\n    output SATA_TX_P\n\t );\n\nwire clk = CLK22M5792;\n\nreg [31:0] counter_ff;\nalways @(posedge clk) begin\n    counter_ff <= counter_ff + 4;\nend\n\nassign LED_M = counter_ff[28];\nassign LED[3:0] = counter_ff[27:24];\nassign SPDIF[3:0] = counter_ff[19:16];\nassign GPIO[3:0] = counter_ff[19:16];\n\nassign UART_RXD = counter_ff[15];\nassign UART_TXD = counter_ff[14];\nassign SPI_MISO = counter_ff[16];\nassign SPI_MOSI = counter_ff[17];\nassign SPI_SSEL = counter_ff[18];\nassign SPI_SCK  = counter_ff[19];\nassign I2S0_MCLK = counter_ff[16];\nassign I2S0_WS = counter_ff[17];\nassign I2S0_SDA = counter_ff[18];\nassign I2S0_SCK = counter_ff[19];\nassign I2S1_MCLK_N = counter_ff[15];\nassign I2S1_MCLK_P = counter_ff[16];\nassign I2S1_WS = counter_ff[17];\nassign I2S1_SDA = counter_ff[18];\nassign I2S1_SCK = counter_ff[19];\nassign I2S2_MCLK = counter_ff[16];\nassign I2S2_WS   = counter_ff[17];\nassign I2S2_SDA  = counter_ff[18];\nassign I2S2_SCK  = counter_ff[19];\nassign SATA_RX_N = counter_ff[16];\nassign SATA_RX_P = counter_ff[17];\nassign SATA_TX_N = counter_ff[18];\nassign SATA_TX_P = counter_ff[19];\n\nendmodule\n",
        "module_name": "main",
        "module_hash": "54e55cb859de0b67c3b76b5a94c13994",
        "dataset_index": 22508
      },
      "binary_to_one_hot_0fd29e1d": {
        "rtl_code": "module binary_to_one_hot (\n    input [3:0] B,\n    output reg O0,\n    output reg O1,\n    output reg O2,\n    output reg O3\n);\n\nalways @(*) begin\n    case(B)\n        4'b0001: begin O0 = 1; O1 = 0; O2 = 0; O3 = 0; end\n        4'b0010: begin O0 = 0; O1 = 1; O2 = 0; O3 = 0; end\n        4'b0100: begin O0 = 0; O1 = 0; O2 = 1; O3 = 0; end\n        4'b1000: begin O0 = 0; O1 = 0; O2 = 0; O3 = 1; end\n        default: begin O0 = 0; O1 = 0; O2 = 0; O3 = 0; end\n    endcase\nend\n\nendmodule",
        "module_name": "binary_to_one_hot",
        "module_hash": "0fd29e1dacd9eb528dcce1844f9149a8",
        "dataset_index": 5663
      },
      "add4bit_46d7d362": {
        "rtl_code": "module add4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    output reg [4:0] sum\n);\n\nalways @ (*) begin\n    sum = {1'b0, A} + {1'b0, B} + {1'b0, C} + {1'b0, D};\n    if (sum > 15) begin\n        sum = sum[3:0];\n    end\nend\n\nendmodule",
        "module_name": "add4bit",
        "module_hash": "46d7d3627958069ddacbbb4243be9da7",
        "dataset_index": 18994
      },
      "binary_to_gray_5b3aa52a": {
        "rtl_code": "\nmodule binary_to_gray (\n  input clk,\n  input [3:0] bin_in,\n  output [3:0] gray_out\n);\n\n  reg [3:0] gray_reg;\n  reg [1:0] state;\n\n  always @(posedge clk) begin\n    case (state)\n      2'b00: begin // State 0\n        state <= 2'b01;\n      end\n      2'b01: begin // State 1\n        gray_reg[3] <= bin_in[3];\n        gray_reg[2] <= bin_in[3] ^ bin_in[2];\n        gray_reg[1] <= bin_in[2] ^ bin_in[1];\n        gray_reg[0] <= bin_in[1] ^ bin_in[0];\n        state <= 2'b00;\n      end\n      default: begin\n        state <= 2'b00;\n      end\n    endcase\n  end\n\n  assign gray_out = gray_reg;\n\nendmodule\n",
        "module_name": "binary_to_gray",
        "module_hash": "5b3aa52a937112851dac53d673d430c2",
        "dataset_index": 17799
      },
      "uart_87193f8d": {
        "rtl_code": "\nmodule uart(\n    input clk, input rst, input rx, output tx, input transmit, input [7:0] tx_byte, output received, output [7:0] rx_byte, output is_receiving, output is_transmitting, output recv_error );\n\nparameter CLOCK_DIVIDE = 2604; parameter RX_IDLE = 0;\nparameter RX_CHECK_START = 1;\nparameter RX_READ_BITS = 2;\nparameter RX_CHECK_STOP = 3;\nparameter RX_DELAY_RESTART = 4;\nparameter RX_ERROR = 5;\nparameter RX_RECEIVED = 6;\n\nparameter TX_IDLE = 0;\nparameter TX_SENDING = 1;\nparameter TX_DELAY_RESTART = 2;\n\nreg [12:0] rx_clk_divider = CLOCK_DIVIDE;\nreg [12:0] tx_clk_divider = CLOCK_DIVIDE;\n\nreg [2:0] recv_state = RX_IDLE;\nreg [5:0] rx_countdown;\nreg [3:0] rx_bits_remaining;\nreg [7:0] rx_data;\n\nreg tx_out = 1'b1;\nreg [1:0] tx_state = TX_IDLE;\nreg [5:0] tx_countdown;\nreg [3:0] tx_bits_remaining;\nreg [7:0] tx_data;\n\nassign received = recv_state == RX_RECEIVED;\nassign recv_error = recv_state == RX_ERROR;\nassign is_receiving = recv_state != RX_IDLE;\nassign rx_byte = rx_data;\n\nassign tx = tx_out;\nassign is_transmitting = tx_state != TX_IDLE;\n\nalways @(posedge clk) begin\n\tif (rst) begin\n\t\trecv_state = RX_IDLE;\n\t\ttx_state = TX_IDLE;\n\tend\n\t\n\trx_clk_divider = rx_clk_divider - 1'b1;\n\tif (!rx_clk_divider) begin\n\t\trx_clk_divider = CLOCK_DIVIDE;\n\t\trx_countdown = rx_countdown - 1'b1;\n\t\tend\n\ttx_clk_divider = tx_clk_divider - 1'b1;\n\tif (!tx_clk_divider) begin\n\t\ttx_clk_divider = CLOCK_DIVIDE;\n\t\ttx_countdown = tx_countdown - 1'b1;\n\tend\n\t\n\tcase (recv_state)\n\t\tRX_IDLE: begin\n\t\t\tif (!rx) begin\n\t\t\t\trx_clk_divider = CLOCK_DIVIDE;\n\t\t\t\trx_countdown = 2;\n\t\t\t\trecv_state = RX_CHECK_START;\n\t\t\tend\n\t\tend\n\t\tRX_CHECK_START: begin\n\t\t\tif (rx_countdown > 2) begin\n\t\t\t\trx_countdown = 1;\n\t\t\tend\n\t\t\tif (!rx_countdown) begin\n\t\t\t\tif (!rx) begin\n\t\t\t\t\trx_countdown = 4;\n\t\t\t\t\trx_bits_remaining = 8;\n\t\t\t\t\trecv_state = RX_READ_BITS;\n\t\t\t\tend else begin\n\t\t\t\t\trecv_state = RX_ERROR;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tRX_READ_BITS: begin\n\t\t\tif (!rx_countdown) begin\n\t\t\t\trx_data = {rx, rx_data[7:1]};\n\t\t\t\trx_countdown = 4;\n\t\t\t\trx_bits_remaining = rx_bits_remaining - 1'b1;\n\t\t\t\trecv_state = rx_bits_remaining ? RX_READ_BITS : RX_CHECK_STOP;\n\t\t\tend\n\t\tend\n\t\tRX_CHECK_STOP: begin\n\t\t\tif (!rx_countdown) begin\n\t\t\t\trecv_state = rx ? RX_RECEIVED : RX_ERROR;\n\t\t\tend\n\t\tend\n\t\tRX_DELAY_RESTART: begin\n\t\t\trecv_state = rx_countdown ? RX_DELAY_RESTART : RX_IDLE;\n\t\tend\n\t\tRX_ERROR: begin\n\t\t\trx_countdown = 8;\n\t\t\trecv_state = RX_DELAY_RESTART;\n\t\tend\n\t\tRX_RECEIVED: begin\n\t\t\trecv_state = RX_IDLE;\n\t\tend\n\t\tdefault: begin\n\t\t\trx_countdown = 2;\n\t\t\trecv_state = RX_IDLE;\n\t\tend\n\tendcase\n\t\n\tcase (tx_state)\n\t\tTX_IDLE: begin\n\t\t\tif (transmit) begin\n\t\t\t\ttx_data = tx_byte;\n\t\t\t\ttx_clk_divider = CLOCK_DIVIDE;\n\t\t\t\ttx_countdown = 4;\n\t\t\t\ttx_out = 0;\n\t\t\t\ttx_bits_remaining = 8;\n\t\t\t\ttx_state = TX_SENDING;\n\t\t\tend\n\t\tend\n\t\tTX_SENDING: begin\n\t\t\tif (!tx_countdown) begin\n\t\t\t\tif (tx_bits_remaining) begin\n\t\t\t\t\ttx_bits_remaining = tx_bits_remaining - 1;\n\t\t\t\t\ttx_out = tx_data[0];\n\t\t\t\t\ttx_data = {1'b0, tx_data[7:1]};\n\t\t\t\t\ttx_countdown = 4;\n\t\t\t\t\ttx_state = TX_SENDING;\n\t\t\t\tend else begin\n\t\t\t\t\ttx_out = 1;\n\t\t\t\t\ttx_countdown = 8;\n\t\t\t\t\ttx_state = TX_DELAY_RESTART;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tTX_DELAY_RESTART: begin\n\t\t\ttx_state = tx_countdown ? TX_DELAY_RESTART : TX_IDLE;\n\t\tend\n\t\tdefault: begin\n\t\t\ttx_state = TX_IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule",
        "module_name": "uart",
        "module_hash": "87193f8d586dcb7f30946436e2e7a5f3",
        "dataset_index": 17627
      },
      "AdderSubtractor_3ae5d8d4": {
        "rtl_code": "module AdderSubtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input Sub,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] A_comp;\nwire [3:0] B_comp;\n\nassign A_comp = ~A + 1;\nassign B_comp = ~B + 1;\n\nwire [4:0] temp_sum;\nassign temp_sum = (Sub == 1) ? A + B_comp : A + B;\n\nassign Cout = (Sub == 1) ? (A >= B) : (temp_sum[4] == 1);\nassign S = (Sub == 1) ? temp_sum : temp_sum[3:0];\n\nendmodule\n\n",
        "module_name": "AdderSubtractor",
        "module_hash": "3ae5d8d45fa45d1629f75e32b6ff1c02",
        "dataset_index": 16456
      },
      "counter_7deffabb": {
        "rtl_code": "module counter (\n    clk,\n    rst,\n    ctrl,\n    out\n  );\n\n  input clk, rst, ctrl;\n  output [3:0] out;\n  reg [3:0] out;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      out <= 4'b0;\n    end else begin\n      if (ctrl) begin\n        if (out == 4'hF) begin\n          out <= 4'b0;\n        end else begin\n          out <= out + 1;\n        end\n      end else begin\n        if (out == 4'b0) begin\n          out <= 4'hF;\n        end else begin\n          out <= out - 1;\n        end\n      end\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "7deffabb1a91f5013bcbf1abc94485ba",
        "dataset_index": 235
      },
      "Gateway_caca2108": {
        "rtl_code": "\nmodule Gateway(\n    input wire Clock, Reset,\n    input [7:0] DataIn,\n    input DataInValid,\n    output DataInReady,\n    output [7:0] DataOut,\n    output DataOutValid,\n    input DataOutReady,\n    input [31:0] ProcessorDataIn,\n    output reg [31:0] ProcessorDataOut,\n    input [31:0] ProcessorAddress,\n    input ProcessorMemRead, ProcessorMemWrite\n);\n\n    // Registers for data transfer\n    reg [7:0] dataInReg = 8'h00;\n    reg [7:0] dataOutReg = 8'h00;\n\n    // Control signals\n    wire pollingControlIn = ProcessorAddress == 32'hffff_0000;\n    wire pollingControlOut = ProcessorAddress == 32'hffff_0008;\n    wire uartDataInTransfer = DataInReady & DataInValid;\n    wire uartDataOutTransfer = DataOutReady & DataOutValid;\n    wire readingData = ProcessorMemRead & (ProcessorAddress == 32'hffff_0004);\n    wire writingData = ProcessorMemWrite & (ProcessorAddress == 32'hffff_000c);\n\n    // Control registers\n    reg controlInReady = 1'b0;\n    reg dataOutValid = 1'b0;\n\n    always @(posedge Clock, posedge Reset) begin\n        if (Reset) begin\n            controlInReady <= 1'b0;\n            dataOutValid <= 1'b0;\n        end\n        else begin\n            if (readingData) begin\n                ProcessorDataOut <= {24'b0, dataInReg};\n            end\n            else if (writingData) begin\n                dataOutReg <= ProcessorDataIn[7:0];\n                dataOutValid <= 1'b1;\n            end\n            else begin\n                dataOutValid <= 1'b0;\n            end\n\n            if (pollingControlIn) begin\n                controlInReady <= 1'b1;\n            end\n            else if (pollingControlOut) begin\n                ProcessorDataOut <= {24'b0, dataOutReg};\n            end\n            else begin\n                if (uartDataInTransfer) begin\n                    dataInReg <= DataIn;\n                end\n                ProcessorDataOut <= {24'b0, controlInReady};\n            end\n        end\n    end\n\n    assign DataInReady = ~controlInReady;\n    assign DataOut = dataOutReg;\n    assign DataOutValid = dataOutValid;\n\nendmodule\n",
        "module_name": "Gateway",
        "module_hash": "caca2108ad4c018ffb7107928f63c175",
        "dataset_index": 1745
      },
      "nor_gate_aaca25c8": {
        "rtl_code": "\nmodule nor_gate (\n    input  A,\n    input  B,\n    output Y\n);\n\n    assign Y = ~(A | B);\n\nendmodule\n\nmodule pwrgood_pp (\n    input  A,\n    input  B,\n    input  C,\n    output Y\n);\n\n    assign Y = (A & B) | C;\n\nendmodule\n\nmodule custom_module (\n    input  A1,\n    input  A2,\n    input  B1,\n    input  Vdd,\n    input  Gnd,\n    output X\n);\n\n    wire nor0_out;\n    wire nor1_out_X;\n    wire pwrgood_pp_out_X;\n\n    nor_gate nor0 (\n        .A(A1),\n        .B(A2),\n        .Y(nor0_out)\n    );\n\n    nor_gate nor1 (\n        .A(B1),\n        .B(nor0_out),\n        .Y(nor1_out_X)\n    );\n\n    pwrgood_pp pwrgood_pp (\n        .A(Vdd),\n        .B(nor1_out_X),\n        .C(Gnd),\n        .Y(pwrgood_pp_out_X)\n    );\n\n    assign X = pwrgood_pp_out_X; // Remove the buffer\n\nendmodule\n",
        "module_name": "nor_gate",
        "module_hash": "aaca25c8629ac251b9a6a57c87ce6b0a",
        "dataset_index": 14324
      },
      "mig_7series_v1_8_ddr_of_pre_fifo #_367eaa29": {
        "rtl_code": "\n\nmodule mig_7series_v1_8_ddr_of_pre_fifo #\n  (\n   parameter TCQ   = 100,             parameter DEPTH = 4,               parameter WIDTH = 32               )\n  (\n   input              clk,            input              rst,            input              full_in,        input              wr_en_in,       input [WIDTH-1:0]  d_in,           output             wr_en_out,      output [WIDTH-1:0] d_out,          output             afull           );\n  \n  localparam PTR_BITS \n             = (DEPTH == 2) ? 1 : \n               ((DEPTH == 3) || (DEPTH == 4)) ? 2 : \n               (((DEPTH == 5) || (DEPTH == 6) || \n                 (DEPTH == 7) || (DEPTH == 8)) ? 3 : \n                  DEPTH == 9 ? 4 : 'bx);\n                 \n  localparam ALMOST_FULL_VALUE = DEPTH - 5;\n\n  integer i;\n  \n  reg [WIDTH-1:0]    mem[0:DEPTH-1] ;\n   reg [2:0]          my_empty;\n   reg [2:0]          my_full;\n  reg [PTR_BITS-1:0] rd_ptr;\n    reg [PTR_BITS-1:0] wr_ptr;\n  reg [PTR_BITS:0] entry_cnt;\n  wire [PTR_BITS-1:0] nxt_rd_ptr;\n  wire [PTR_BITS-1:0] nxt_wr_ptr;\n  wire [WIDTH-1:0] mem_out;\n  wire wr_en;\n\n  assign d_out = my_empty[0] ? d_in : mem_out;\n  assign wr_en_out = !full_in && (!my_empty[1] || wr_en_in);\n  assign wr_en = wr_en_in & ((!my_empty[2] & !full_in)|(!my_full[2] & full_in));\n\n  always @ (posedge clk)\n    if (wr_en)\n      mem[wr_ptr] <= #TCQ d_in;\n\n  assign mem_out = mem[rd_ptr];\n\n  assign nxt_rd_ptr = (rd_ptr + 1'b1)%DEPTH;\n\n  always @ (posedge clk)\n  begin\n    if (rst)\n      rd_ptr <= 'b0;\n    else if ((!my_empty[2]) & (!full_in))\n      rd_ptr <= nxt_rd_ptr;\n  end\n\n  always @ (posedge clk)\n  begin\n    if (rst)\n      my_empty <= 3'b111;\n    else if (my_empty[2] & !my_full[1] & full_in & wr_en_in)\n      my_empty <= 3'b000;\n    else if (!my_empty[2] & !my_full[1] & !full_in & !wr_en_in) begin\n      my_empty[0] <= (nxt_rd_ptr == wr_ptr);\n      my_empty[1] <= (nxt_rd_ptr == wr_ptr);\n      my_empty[2] <= (nxt_rd_ptr == wr_ptr);\n    end\n  end\n\n  assign nxt_wr_ptr = (wr_ptr + 1'b1)%DEPTH;\n\n  always @ (posedge clk)\n  begin\n    if (rst)\n      wr_ptr <= 'b0;\n    else if ((wr_en_in) & ((!my_empty[2] & !full_in) | (!my_full[1] & full_in)))\n      wr_ptr <= nxt_wr_ptr;\n  end\n\n  always @ (posedge clk)\n  begin\n    if (rst)\n      my_full <= 3'b000;\n    else if (!my_empty[2] & my_full[0] & !full_in & !wr_en_in)\n      my_full <= 3'b000;\n    else if (!my_empty[2] & !my_full[0] & full_in & wr_en_in) begin\n      my_full[0] <= (nxt_wr_ptr == rd_ptr);\n      my_full[1] <= (nxt_wr_ptr == rd_ptr);\n      my_full[2] <= (nxt_wr_ptr == rd_ptr);\n    end\n  end\n\n  always @ (posedge clk)\n  begin\n    if (rst)\n      entry_cnt <= 'b0;\n    else if (wr_en_in & full_in & !my_full[1])\n      entry_cnt <= entry_cnt + 1'b1;\n    else if (!wr_en_in & !full_in & !my_empty[2])\n      entry_cnt <= entry_cnt - 1'b1;\n  end\n\n  assign afull = (entry_cnt >= ALMOST_FULL_VALUE);\n\nendmodule\n",
        "module_name": "mig_7series_v1_8_ddr_of_pre_fifo #",
        "module_hash": "367eaa29bba0b67e9c1f4158a396c775",
        "dataset_index": 24897
      },
      "dac_26525b68": {
        "rtl_code": "\nmodule dac(\n  input clkin,\n  input sysclk,\n  input we,\n  input[10:0] pgm_address,\n  input[7:0] pgm_data,\n  input play,\n  input reset,\n  output sdout,\n  output lrck,\n  output mclk,\n  output DAC_STATUS\n);\n\nreg[8:0] dac_address_r;\nwire[8:0] dac_address = dac_address_r;\n\nwire[31:0] dac_data = 32'b 0;\nreg[7:0] vol_reg;\nreg[7:0] vol_target_reg;\nreg[1:0] vol_latch_reg;\nreg vol_valid;\nreg[2:0] sysclk_sreg;\nwire sysclk_rising = (sysclk_sreg[2:1] == 2'b01);\n\nreg [25:0] interpol_count;\n\nalways @(posedge clkin) begin\n  sysclk_sreg <= {sysclk_sreg[1:0], sysclk};\nend\n\n`ifdef MK2\ndac_buf snes_dac_buf (\n  .clka(clkin),\n  .wea(~we), // Bus [0 : 0]\n  .addra(pgm_address), // Bus [10 : 0]\n  .dina(pgm_data), // Bus [7 : 0]\n  .clkb(clkin),\n  .addrb(dac_address), // Bus [8 : 0]\n  .doutb(dac_data) // Bus [31 : 0]\n);\n`endif\n\n`ifdef MK3\ndac_buf snes_dac_buf (\n  .clock(clkin),\n  .wren(~we), // Bus [0 : 0]\n  .wraddress(pgm_address), // Bus [10 : 0]\n  .data(pgm_data), // Bus [7 : 0]\n  .rdaddress(dac_address), // Bus [8 : 0]\n  .q(dac_data) // Bus [31 : 0]\n);\n`endif\n\nreg [8:0] cnt;\nreg [15:0] smpcnt;\nreg [1:0] samples;\nreg [15:0] smpshift;\n\nassign mclk = cnt[2]; // mclk = clk/8\nassign lrck = cnt[8]; // lrck = mclk/128\nwire sclk = cnt[3];   // sclk = lrck*32\n\nreg [2:0] lrck_sreg;\nreg [2:0] sclk_sreg;\nwire lrck_rising = ({lrck_sreg[2:1]} == 2'b01);\nwire lrck_falling = ({lrck_sreg[2:1]} == 2'b10);\n\nwire sclk_rising = ({sclk_sreg[2:1]} == 2'b01);\n\nreg sdout_reg;\nassign sdout = sdout_reg;\n\nreg [1:0] reset_sreg;\nwire reset_rising = (reset_sreg[1:0] == 2'b01);\n\nreg play_r;\n\ninitial begin\n  cnt = 9'h100;\n  smpcnt = 16'b0;\n  lrck_sreg = 2'b11;\n  sclk_sreg = 1'b0;\n  dac_address_r = 10'b0;\n  vol_valid = 1'b0;\n  vol_latch_reg = 1'b0;\n  vol_reg = 8'h0;\n  vol_target_reg = 8'hff;\n  samples <= 2'b00;\nend\n\nassign DAC_STATUS = dac_address_r[8];\n\nalways @(posedge clkin) begin\n  if(reset_rising) begin\n    dac_address_r <= 0;\n    interpol_count <= 0;\n  end else if(sysclk_rising) begin\n    if(interpol_count > 59378938) begin\n      interpol_count <= interpol_count + 122500 - 59501439;\n      dac_address_r <= dac_address_r + play_r;\n    end else begin\n      interpol_count <= interpol_count + 122500;\n    end\n  end\nend\n\nalways @(posedge clkin) begin\n  cnt <= cnt + 1;\n  lrck_sreg <= {lrck_sreg[1:0], lrck};\n  sclk_sreg <= {sclk_sreg[1:0], sclk};\n  play_r <= play;\n  reset_sreg <= {reset_sreg[0], reset};\nend\n\n// ramp volume only every 4 samples\nalways @(posedge clkin) begin\n  if (lrck_rising && &samples[1:0]) begin\n    if(vol_reg > vol_target_reg)\n      vol_reg <= vol_reg - 1;\n    else if(vol_reg < vol_target_reg)\n      vol_reg <= vol_reg + 1;\n  end\nend\n\nalways @(posedge clkin) begin\n  if (lrck_rising) begin // right channel\n    smpshift <= (({16'h0, dac_data[31:16]} * vol_reg) >> 8);\n    samples <= samples + 1;\n  end else if (lrck_falling) begin // left channel\n    smpshift <= (({16'h0, dac_data[15:0]} * vol_reg) >> 8);\n  end else begin\n    if (sclk_rising) begin\n      smpcnt <= smpcnt + 1;\n      sdout_reg <= smpshift[15];\n      smpshift <= {smpshift[14:0], 1'b0};\n    end\n  end\nend\n\nendmodule",
        "module_name": "dac",
        "module_hash": "26525b6848a219d9d2057eb37e2fc448",
        "dataset_index": 10794
      },
      "shift_reg_comb_a803ab90": {
        "rtl_code": "module shift_reg_comb (\n    input clk,          // Clock input\n    input d,            // Input for shift register\n    input [3:0] in,     // Input for combinational circuit\n    output out_and,     // 2-level AND-OR circuit output\n    output out_or,      // 2-level OR-AND circuit output\n    output out_xor,     // 2-level XOR-AND circuit output\n    output [7:0] sum    // Sum of shift register and combinational circuit outputs\n);\n\nreg [2:0] shift_reg;\nwire q;\n\n// Shift register\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[1:0], d};\nend\n\nassign q = shift_reg[2];\n\n// Combinational circuit\nwire and1 = in[0] & in[1];\nwire and2 = in[2] & in[3];\nwire or1 = in[0] | in[1];\nwire or2 = in[2] | in[3];\nwire xor1 = in[0] ^ in[1];\nwire xor2 = in[2] ^ in[3];\n\nassign out_and = and1 | and2;\nassign out_or = or1 & or2;\nassign out_xor = xor1 & xor2;\n\n// Sum module\nwire [7:0] shift_sum = {1'b0, shift_reg};\nwire [7:0] comb_sum = {1'b0, out_and, out_or, out_xor};\n\nassign sum = shift_sum + comb_sum;\n\nendmodule",
        "module_name": "shift_reg_comb",
        "module_hash": "a803ab902ef815ce8a6d855b06070a33",
        "dataset_index": 15572
      },
      "mux4_5356a77e": {
        "rtl_code": "module mux4 (\n    x,\n    a0,\n    a1,\n    a2,\n    a3,\n    s0,\n    s1\n);\n\n    output x;\n    input a0;\n    input a1;\n    input a2;\n    input a3;\n    input s0;\n    input s1;\n\n    wire not_s0, not_s1;\n    wire and1, and2, and3, and4;\n    wire or1, or2;\n\n    // Invert select signals\n    not not_s0 (not_s0, s0);\n    not not_s1 (not_s1, s1);\n\n    // AND gates for each input and select signal combination\n    and and1 (and1, a0, not_s1, not_s0);\n    and and2 (and2, a1, not_s1, s0);\n    and and3 (and3, a2, s1, not_s0);\n    and and4 (and4, a3, s1, s0);\n\n    // OR gates for the output\n    or or1 (or1, and1, and2);\n    or or2 (or2, and3, and4);\n    or or3 (x, or1, or2);\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "5356a77e6ee6b969916cc1ed41ec4104",
        "dataset_index": 4402
      },
      "carry_select_adder_c6ebe087": {
        "rtl_code": "\nmodule carry_select_adder (\n    input [31:0] a, b,\n    input cin,\n    output cout,\n    output [31:0] sum\n);\n\nwire [31:0] ripple_carry_out_0;\nwire [31:0] ripple_carry_out_1;\n\nrca32 rca32_0 (\n    .a(a),\n    .b(b),\n    .cin(cin),\n    .cout(ripple_carry_out_0)\n);\n\nrca32 rca32_1 (\n    .a(a),\n    .b(b),\n    .cin(~cin),\n    .cout(ripple_carry_out_1)\n);\n\nmux32 mux32_0 (\n    .a(ripple_carry_out_0),\n    .b(ripple_carry_out_1),\n    .s(cin),\n    .y(sum)\n);\n\nor_gate or_gate_0 (\n    .a(ripple_carry_out_0[31]),\n    .b(ripple_carry_out_1[31]),\n    .y(cout)\n);\n\nendmodule\nmodule mux32 (\n    input [31:0] a, b,\n    input s,\n    output [31:0] y\n);\n\nassign y = s ? b : a;\n\nendmodule\nmodule or_gate (\n    input a, b,\n    output y\n);\n\nassign y = a | b;\n\nendmodule\nmodule rca32 (\n    input [31:0] a, b,\n    input cin,\n    output [31:0] cout\n);\n\nwire [31:0] carry;\n\nassign carry[0] = cin;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 31; i = i + 1) begin\n        full_adder fa (\n            .a(a[i]),\n            .b(b[i]),\n            .cin(carry[i]),\n            .cout(carry[i + 1]),\n            .sum(cout[i])\n        );\n    end\nendgenerate\n\nassign cout[31] = carry[31];\n\nendmodule\nmodule full_adder (\n    input a, b, cin,\n    output cout, sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule",
        "module_name": "carry_select_adder",
        "module_hash": "c6ebe08787944fd70e0edfc44b329dca",
        "dataset_index": 2678
      },
      "top__65180a5d": {
        "rtl_code": "\nmodule top_module (\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    output [7:0] s,\n    output overflow\n    );\n\n\n    // Carry look-ahead adder for addition and overflow detection\n    wire [3:0] a_ext, b_ext;\n    assign a_ext = {1'b0, a};\n    assign b_ext = {1'b0, b};\n\n    wire [3:0] add_out;\n    wire add_carry_out;\n    cla_adder_4bit adder(.a(a_ext), .b(b_ext), .sum(add_out), .carry_out(add_carry_out));\n\n    assign s = {add_carry_out, add_out};\n    assign overflow = add_carry_out;\n\n    // Combinational circuit for bitwise-OR and logical-OR operations\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = |out_or_bitwise;\n\n    // Functional module for 2's complement addition\n    wire [2:0] add_in;\n    assign add_in = out_or_bitwise;\n    wire [2:0] add_out2;\n    wire add_overflow;\n    twos_comp_adder adder2(.a(add_in), .b_in(out_or_logical), .sum(add_out2), .overflow(add_overflow));\n\n    // Output\n    assign out_not = {~b, ~a};\n\nendmodule\nmodule cla_adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum,\n    output carry_out\n);\n\n    wire [3:0] g, p, c;\n    assign g[0] = a[0] & b[0];\n    assign p[0] = a[0] ^ b[0];\n    assign g[1] = a[1] & b[1];\n    assign p[1] = a[1] ^ b[1];\n    assign g[2] = a[2] & b[2];\n    assign p[2] = a[2] ^ b[2];\n    assign g[3] = a[3] & b[3];\n    assign p[3] = a[3] ^ b[3];\n    assign c[0] = g[0];\n    assign c[1] = g[1] | (p[1] & c[0]);\n    assign c[2] = g[2] | (p[2] & c[1]);\n    assign carry_out = g[3] | (p[3] & c[2]);\n\n    assign sum[0] = p[0] ^ c[0];\n    assign sum[1] = p[1] ^ c[1];\n    assign sum[2] = p[2] ^ c[2];\n    assign sum[3] = p[3] ^ carry_out;\n\nendmodule\nmodule twos_comp_adder (\n    input [2:0] a,\n    input b_in,\n    output [2:0] sum,\n    output overflow\n    );\n\n    wire [2:0] b;\n    assign b = b_in ? 3'b111 : 3'b000;\n\n    wire [3:0] a_ext, b_ext;\n    assign a_ext = {1'b0, a};\n    assign b_ext = {1'b0, b};\n\n    wire [3:0] add;\n    wire carry_out;\n    cla_adder_4bit adder(.a(a_ext), .b(~b_ext), .sum(add), .carry_out(carry_out));\n\n    assign sum = add[2:0];\n    assign overflow = carry_out;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "65180a5d6fb41f27ca7b380a81d99440",
        "dataset_index": 9168
      },
      "Computer_Datapath_RegisterFile_c6be610e": {
        "rtl_code": "module Computer_Datapath_RegisterFile(\n\toutput reg [WORD_WIDTH-1:0] ADDR_bus_out,\n\toutput reg [WORD_WIDTH-1:0] B_data_out,\n\tinput [CNTRL_WIDTH-1:0] CNTRL_bus_in,\n\tinput [WORD_WIDTH-1:0] D_bus_in,\n\tinput CLK,\n\tinput RST\n\t);\n\nparameter WORD_WIDTH = 16;\nparameter DR_WIDTH = 3;\nparameter SB_WIDTH = DR_WIDTH;\nparameter SA_WIDTH = DR_WIDTH;\nparameter OPCODE_WIDTH = 7;\nparameter CNTRL_WIDTH = DR_WIDTH+SB_WIDTH+SA_WIDTH+11;\nparameter COUNTER_WIDTH = 4;\n\nwire RW = CNTRL_bus_in[4];\n\nwire [SA_WIDTH-1:0] DA = CNTRL_bus_in[19:17];\nwire [SA_WIDTH-1:0] AA = CNTRL_bus_in[16:14];\nwire [SA_WIDTH-1:0] BA = CNTRL_bus_in[13:11];\n\nreg [WORD_WIDTH-1:0] SYNC_RAM0 [2**DR_WIDTH-1:0];\nreg [WORD_WIDTH-1:0] SYNC_RAM1 [2**DR_WIDTH-1:0];\n\nreg [DR_WIDTH-1:0] i;\n\nalways@(posedge CLK) begin\n\t\n\tif(RW) begin\n\t\tSYNC_RAM0[DA] <= D_bus_in;\n\t\tSYNC_RAM1[DA] <= D_bus_in;\n\tend\nend\n\nalways@(*) begin\n\tADDR_bus_out <= SYNC_RAM0[AA];\n\tB_data_out <= SYNC_RAM1[BA];\nend\n\t\n\nendmodule",
        "module_name": "Computer_Datapath_RegisterFile",
        "module_hash": "c6be610e55b943a3012038f0be5b843a",
        "dataset_index": 10972
      },
      "jt12_sh #_2bb7a38e": {
        "rtl_code": "\n\n\nmodule jt12_sh #(parameter width=5, stages=24 )\n(\n\tinput \t\t\t\tclk,\n\tinput\t\t\t\tclk_en ,\n\tinput\t[width-1:0]\tdin,\n   \toutput\t[width-1:0]\tdrop\n);\n\nreg [stages-1:0] bits[width-1:0];\n\ngenvar i;\ngenerate\n\tfor (i=0; i < width; i=i+1) begin: bit_shifter\n\t\talways @(posedge clk) if(clk_en) begin\n\t\t\tbits[i] <= {bits[i][stages-2:0], din[i]};\n\t\tend\n\t\tassign drop[i] = bits[i][stages-1];\n\tend\nendgenerate\n\nendmodule\n",
        "module_name": "jt12_sh #",
        "module_hash": "2bb7a38e5706e63642f6ac5661c930ae",
        "dataset_index": 22826
      },
      "d_ff_18408f4c": {
        "rtl_code": "\nmodule d_ff (\n    output reg Q,\n    output Q_N,\n    input CLK,\n    input D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    assign Q_N = ~Q;\n\n    // D Flip-Flop logic\n    always @(posedge CLK) begin\n        if (VPB == 0) begin // Set reset condition\n            Q <= 0;\n        end else begin\n            Q <= D;     // Add explicit assignment delay\n        end\n    end\n\nendmodule",
        "module_name": "d_ff",
        "module_hash": "18408f4c6272f524840208d30a25b346",
        "dataset_index": 8386
      },
      "controller_950e1487": {
        "rtl_code": "\n\nmodule controller(\n  clock, reset, run,\n  wrSize, config_data,\n  validIn, dataIn, busy, arm, \n  send, memoryWrData, memoryRead, \n  memoryWrite, memoryLastWrite);\n\ninput clock;\ninput reset;\ninput run;\ninput wrSize;\ninput [31:0] config_data;\ninput validIn;\ninput [31:0] dataIn;\ninput busy;\ninput arm;\n\noutput send;\noutput [31:0] memoryWrData;\noutput memoryRead;\noutput memoryWrite;\noutput memoryLastWrite;\n\nreg [15:0] fwd, next_fwd; reg [15:0] bwd, next_bwd;\n\nreg send, next_send;\nreg memoryRead, next_memoryRead;\nreg memoryWrite, next_memoryWrite;\nreg memoryLastWrite, next_memoryLastWrite;\n\nreg [17:0] counter, next_counter; \nwire [17:0] counter_inc = counter+1'b1;\n\n\nreg [31:0] memoryWrData, next_memoryWrData;\nalways @(posedge clock) \nbegin\n  memoryWrData = next_memoryWrData;\nend\nalways @*\nbegin\n  #1; next_memoryWrData = dataIn;\nend\n\n\n\nparameter [2:0]\n  IDLE =     3'h0,\n  SAMPLE =   3'h1,\n  DELAY =    3'h2,\n  READ =     3'h3,\n  READWAIT = 3'h4;\n\nreg [2:0] state, next_state; \n\ninitial state = IDLE;\nalways @(posedge clock or posedge reset) \nbegin\n  if (reset)\n    begin\n      state = IDLE;\n      memoryWrite = 1'b0;\n      memoryLastWrite = 1'b0;\n      memoryRead = 1'b0;\n    end\n  else \n    begin\n      state = next_state;\n      memoryWrite = next_memoryWrite;\n      memoryLastWrite = next_memoryLastWrite;\n      memoryRead = next_memoryRead;\n    end\nend\n\nalways @(posedge clock)\nbegin\n  counter = next_counter;\n  send = next_send;\nend\n\nalways @*\nbegin\n  #1;\n  next_state = state;\n  next_counter = counter;\n  next_memoryWrite = 1'b0;\n  next_memoryLastWrite = 1'b0;\n  next_memoryRead = 1'b0;\n  next_send = 1'b0;\n\n  case(state)\n    IDLE :\n      begin\n        next_counter = 0;\n        next_memoryWrite = 1;\n\tif (run) next_state = DELAY;\n\telse if (arm) next_state = SAMPLE;\n      end\n\n    SAMPLE : \n      begin\n        next_counter = 0;\n        next_memoryWrite = validIn;\n        if (run) next_state = DELAY;\n      end\n\n    DELAY : \n      begin\n\tif (validIn)\n\t  begin\n\t    next_memoryWrite = 1'b1;\n            next_counter = counter_inc;\n            if (counter == {fwd,2'b11}) \tbegin\t\t\t\tnext_memoryLastWrite = 1'b1;\tnext_counter = 0;\n\t\tnext_state = READ;\n\t      end\n\t  end\n      end\n\n    READ : \n      begin\n        next_memoryRead = 1'b1;\n        next_send = 1'b1;\n        if (counter == {bwd,2'b11}) \n\t  begin\n            next_counter = 0;\n            next_state = IDLE;\n          end\n        else \n\t  begin\n            next_counter = counter_inc;\n            next_state = READWAIT;\n          end\n      end\n\n    READWAIT : \n      begin\n        if (!busy && !send) next_state = READ;\n      end\n  endcase\nend\n\n\nalways @(posedge clock) \nbegin\n  fwd = next_fwd;\n  bwd = next_bwd;\nend\n\nalways @*\nbegin\n  #1;\n  next_fwd = fwd;\n  next_bwd = bwd;\n\n  if (wrSize) \n    begin\n      next_fwd = config_data[31:16];\n      next_bwd = config_data[15:0];\n    end\nend\nendmodule\n\n",
        "module_name": "controller",
        "module_hash": "950e148733317489a2c9ad7bccd55e67",
        "dataset_index": 10303
      },
      "pwm_42bf3db5": {
        "rtl_code": "\nmodule pwm(clk,rst,pwm_duty,pwm_offset,pwm_out);\ninput clk;input rst;input [7:0] pwm_duty;input [7:0] pwm_offset;output pwm_out;reg pwm_buffer;reg [7:0] counter;\n\nparameter [7:0] PWM_DEFAULT = 8'd150;\nwire [7:0] duty_temp;\nwire [7:0] duty_check;\n\nassign duty_temp = pwm_duty + ( pwm_offset - PWM_DEFAULT );assign duty_check = ( duty_temp >= 50 && duty_temp <= 250) ? duty_temp : PWM_DEFAULT;always @ (posedge clk or posedge rst)\n    if(rst)\n        begin\n            counter <= 0;\n            pwm_buffer <= 1;\n        end\n    else\n        begin\n            if( counter <= duty_check )\n                begin\n                    pwm_buffer <= 1;\n                    counter <= counter + 1;\n                end\n            else\n                begin\n                    pwm_buffer <= 0;\n                    counter <= counter;end\n        end\n        \n    assign pwm_out = pwm_buffer;\n\nendmodule\n",
        "module_name": "pwm",
        "module_hash": "42bf3db5df938f3f8b06bbb35e6a815b",
        "dataset_index": 23759
      },
      "mips_memory2_a7b53e99": {
        "rtl_code": "\n\nmodule mips_memory2 (clk, addr, din, dout, pc, access_size, rw, busy, enable);\n\nparameter MEMSIZE = 1024;\nparameter START_ADDR = 32'h8002_0000;\n\ninput         clk;\n\tinput [31:0]  addr;\n\tinput [31:0]  din;\n\tinput [2:0]   access_size;\n\tinput \t      rw; input\t      enable;\n\noutput reg        busy;\n\toutput reg [31:0] dout;\n\toutput reg [31:0] pc;\n\t\nreg    [7:0]  mem[0:MEMSIZE];\n\nreg  [31:0]   reg_cur_addr\t= 'hffff; reg  [5:0]\t\treg_counter\t= 0;  reg\t      \t\treg_rw\t\t= 0;\t    reg  [31:0]   reg_din\t\t= 'hffff; wire\t      wire_busy;    wire\t      wire_output;  assign wire_busy = (reg_counter > 1);\n\tassign wire_output = (reg_counter != 0);\n\nalways @(posedge clk)\n\tbegin\n\t\tif (wire_busy == 'b1)\n\t\tbegin\n\t\t\treg_cur_addr <= reg_cur_addr + 4;\n\t\tend\n\t\telse if (enable == 'b1) begin\n\t\t\treg_cur_addr <= addr - START_ADDR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\treg_cur_addr <= reg_cur_addr; end\n\t\t\n\t\tif (wire_busy == 'b0 && enable == 'b1)\n\t\tbegin\n\t\t\tcase (access_size)\n\t\t\t\t3'b000 : reg_counter <= 'd1;\t3'b001 : reg_counter <= 'd4;\t3'b010 : reg_counter <= 'd8;\t3'b011 : reg_counter <= 'd16;\t3'b100 : reg_counter <= 'd1;\t3'b101 : reg_counter <= 'd1;\tdefault : reg_counter <= 'd0;\n\t\t\tendcase\n\n\t\t\treg_rw <= rw;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\treg_counter <= reg_counter == 0 ? 0 : reg_counter - 1;\n\t\t\treg_rw <= reg_rw;\n\t\tend\n\t\t\n\t\tif (wire_output == 'b1 && reg_rw == 'b0)\n\t\tbegin\n\t\t\tif (access_size == 3'b100)\n\t\t\t\tbegin\n\t\t\t\t\tdout[31:24] <= 0;\n\t\t\t\t\tdout[23:16] <= 0;\n\t\t\t\t\tdout[15:8]  <= 0;\n\t\t\t\t\tdout[7:0]   <= mem[reg_cur_addr]; end\n\t\t\telse if  (access_size == 3'b101)\n\t\t\t\tbegin\n\t\t\t\t\tdout[31:24] <= 0;\n\t\t\t\t\tdout[23:16] <= 0;\n\t\t\t\t\tdout[15:8]  <= mem[reg_cur_addr];\n\t\t\t\t\tdout[7:0]   <= mem[reg_cur_addr+1]; end\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tdout[31:24] <= mem[reg_cur_addr];   dout[23:16] <= mem[reg_cur_addr+1];\n\t\t\t\t\tdout[15:8]  <= mem[reg_cur_addr+2];\n\t\t\t\t\tdout[7:0]   <= mem[reg_cur_addr+3]; end\n\t\t\tpc <= reg_cur_addr + START_ADDR;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tdout[31:0] <= 'bx;\n\t\tend\n\n\t\tif (wire_output == 'b1 && reg_rw == 'b1)\n\t\tbegin\n\t\t\tif (access_size == 3'b100)\n\t\t\t\tbegin\n\t\t\t\t\tmem[reg_cur_addr]   <= reg_din[7:0];\n\t\t\t\tend\n\t\t\telse if  (access_size == 3'b101)\n\t\t\t\tbegin\n\t\t\t\t\tmem[reg_cur_addr]   <= reg_din[15:8];   mem[reg_cur_addr+1] <= reg_din[7:0];\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tmem[reg_cur_addr]   <= reg_din[31:24];   mem[reg_cur_addr+1] <= reg_din[23:16];\n\t\t\t\t\tmem[reg_cur_addr+2] <= reg_din[15:8];\n\t\t\t\t\tmem[reg_cur_addr+3] <= reg_din[7:0]; end\n\t\tend\n\n\tbusy <= wire_busy;\n\n\treg_din <= din;\n\n\tend\n\nendmodule",
        "module_name": "mips_memory2",
        "module_hash": "a7b53e993131ac0584008c29196ea72b",
        "dataset_index": 23433
      },
      "majority_gate_2aecbf94": {
        "rtl_code": "module majority_gate (\n    // input ports\n    input A,\n    input B,\n    input C,\n    input D,\n    // output ports\n    output X\n);\n\n    wire AB = A & B;\n    wire AC = A & C;\n    wire AD = A & D;\n    wire BC = B & C;\n    wire BD = B & D;\n    wire CD = C & D;\n\n    wire majority1 = AB | AC | AD | BC | BD | CD;\n    wire majority0 = ~AB & ~AC & ~AD & ~BC & ~BD & ~CD;\n\n    assign X = (majority1 & ~majority0);\n\nendmodule",
        "module_name": "majority_gate",
        "module_hash": "2aecbf94b77e59a3401bec463b276cb4",
        "dataset_index": 20066
      },
      "delay__a761ca0d": {
        "rtl_code": "\nmodule delay_module (\n    input clk,\n    input A,\n    input [3:0] delay_val,\n    output reg X\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (counter == delay_val) begin\n        X <= A;\n    end else begin\n        X <= X;\n    end\n    counter <= counter + 1;\nend\n\nendmodule\n",
        "module_name": "delay_",
        "module_hash": "a761ca0d40de312dd794fbef3c0fdf03",
        "dataset_index": 17817
      },
      "dffrl_async_ns_463b5b03": {
        "rtl_code": "module dffrl_async_ns (din, clk, rst_l, load, q);\n  parameter SIZE = 1;\n\n  input   [SIZE-1:0]      din ;   // data in\n  input                   clk ;   // clk or scan clk\n  input                   rst_l ;   // reset\n  input                   load ;   // load\n\n  output  [SIZE-1:0]      q ;     // output\n\n  reg [SIZE-1:0] q;\n  always @ (posedge clk or negedge rst_l)\n    if (~rst_l) begin\n      q <= {SIZE{1'b0}};\n    end else if (load) begin\n      q <= din;\n    end else begin\n      q <= q;\n    end\n\nendmodule",
        "module_name": "dffrl_async_ns",
        "module_hash": "463b5b037d3fe905d240a1d3c7805c92",
        "dataset_index": 13453
      },
      "key_encoder_bde40099": {
        "rtl_code": "\nmodule key_encoder( key_input, key_code, clk );\n   input [8:0] \tkey_input;\tinput \t\t\tclk;\n\n   output [4:0] \tkey_code; \treg [2:0] \t\tkey_note;\n   reg [1:0] \t\trange;\n\n   always @ (posedge clk) begin\n      case (key_input[8:7]) \t2'b11: range <= 0;\n\t\t\t2'b01: range <= 1;\n\t\t\t2'b00: range <= 2;\n\t\t\t2'b10: range <= 3;\n      endcase\n\n      case (key_input[6:0]) \n\t\t\t7'b0000001: key_note <= 1;\n\t\t\t7'b0000010: key_note <= 2;\n\t\t\t7'b0000100: key_note <= 3;\n\t\t\t7'b0001000: key_note <= 4;\n\t\t\t7'b0010000: key_note <= 5;\n\t\t\t7'b0100000: key_note <= 6;\n\t\t\t7'b1000000: key_note <= 7;\n\t\t\tdefault:    key_note <= 0;\n      endcase\n   end\n\n   assign key_code[4:0] = range * key_note;\n\nendmodule\n",
        "module_name": "key_encoder",
        "module_hash": "bde40099c7618af96293b01d72d177b7",
        "dataset_index": 17459
      },
      "encryption_module_995a4492": {
        "rtl_code": "module encryption_module(\n    input clk,\n    input rst,\n    input [99:0] in,\n    input [31:0] key,\n    output [99:0] out\n);\n\n    // Shift register with circular buffer architecture\n    reg [4:0] shift_reg [99:0];\n    reg [4:0] shift_reg_out;\n    integer i;\n    \n    // Barrel shifter\n    reg [99:0] barrel_shifter_out;\n    \n    // XOR gate\n    reg [99:0] xor_out;\n    \n    // Control logic\n    always @(posedge clk, posedge rst) begin\n        if (rst) begin\n            // Reset shift register\n            for (i = 0; i < 100; i = i + 1) begin\n                shift_reg[i] <= 0;\n            end\n            shift_reg_out <= 0;\n            \n            // Reset barrel shifter\n            barrel_shifter_out <= 0;\n            \n            // Reset XOR gate\n            xor_out <= 0;\n        end else begin\n            // Shift register\n            for (i = 99; i > 0; i = i - 1) begin\n                shift_reg[i] <= shift_reg[i-1];\n            end\n            shift_reg[0] <= in[99];\n            shift_reg_out <= shift_reg[4];\n            \n            // Barrel shifter\n            if (shift_reg_out == 0) begin\n                barrel_shifter_out <= in;\n            end else begin\n                barrel_shifter_out <= {in[99-shift_reg_out+1:0], in[99:99-shift_reg_out+2]};\n            end\n            \n            // XOR gate\n            xor_out <= barrel_shifter_out ^ key;\n        end\n    end\n    \n    // Output\n    assign out = xor_out;\n\nendmodule",
        "module_name": "encryption_module",
        "module_hash": "995a4492cb59f40b80f891371d5b494c",
        "dataset_index": 3436
      },
      "gpio_delayed_trigger #_619c4271": {
        "rtl_code": "module gpio_delayed_trigger #(\n  parameter integer GPIO_DATA_WIDTH = 8,\n  parameter integer GPIO_INPUT_WIDTH = 4,\n  parameter integer GPIO_OUTPUT_WIDTH = 4\n)\n(\n  // System signals\n  input  wire                        aclk,\n  input  wire                        aresetn,\n\n  inout  wire [GPIO_DATA_WIDTH-1:0]  gpio_data,\n  input  wire [GPIO_OUTPUT_WIDTH-1:0]  out_data,\n\n  input  wire                        soft_trig,\n  input  wire [31:0]                 delay,\n  output wire                        trigger,\n  output wire                        instant_trigger,\n  output wire                        delay_pulse\n);\n\n  reg  [GPIO_DATA_WIDTH-1:0] int_data_reg [1:0];\n  reg  triggered, int_trig_reg, int_trig_reg_next, out_trig, out_trig_next;\n  reg  [31:0] counter, counter_next;\n  wire [GPIO_DATA_WIDTH-1:0] int_data_wire;\n  wire int_comp_wire;\n  wire [GPIO_OUTPUT_WIDTH-1:0] int_output;\n\n  genvar j;\n\n  // input pins\n  generate\n    for (j = 0; j < GPIO_INPUT_WIDTH; j = j + 1)\n      begin : GPIO\n        assign int_data_wire[j] = gpio_data[j]; \n      end\n  endgenerate\n\n  // output pins\n  generate\n    for (j = GPIO_INPUT_WIDTH; j < GPIO_DATA_WIDTH; j = j + 1)\n      begin : GPIO_OUT\n        assign int_data_wire[j] = (j-GPIO_INPUT_WIDTH < GPIO_OUTPUT_WIDTH) ? out_data[j-GPIO_INPUT_WIDTH] : 1'b0; \n      end\n  endgenerate\n\n  assign int_comp_wire = counter < delay;\n  always @(posedge aclk)\n  begin\n    int_data_reg[0] <= int_data_wire;\n    int_data_reg[1] <= int_data_reg[0];\n    if (~aresetn)\n    begin\n      int_trig_reg <= 1'b0;\n      out_trig <= 1'b0;\n      counter <= 32'b0;\n    end\n    else\n    begin\n      int_trig_reg <= int_trig_reg_next;\n      out_trig <= out_trig_next;\n      counter <= counter_next;\n    end\n  end\n\n  always @*\n  begin \n    int_trig_reg_next = int_trig_reg;\n    out_trig_next = out_trig;\n    counter_next = counter;\n    if (soft_trig | int_data_reg[1][0])\n      int_trig_reg_next = 1'b1;\n    if (int_comp_wire & int_trig_reg)\n      counter_next = counter + 1;\n    if (!int_comp_wire)\n      out_trig_next = 1'b1;\n  end\n\n  assign trigger = out_trig;\n  assign instant_trigger = int_trig_reg;\n  assign delay_pulse = instant_trigger & ~trigger;\n  assign int_output = {{(GPIO_OUTPUT_WIDTH){1'b0}}, delay_pulse};\n\nendmodule",
        "module_name": "gpio_delayed_trigger #",
        "module_hash": "619c4271518c292958cfd01a47f6d484",
        "dataset_index": 5082
      },
      "axi_hdmi_tx_es #_030f152f": {
        "rtl_code": "\n\nmodule axi_hdmi_tx_es #(\n\n  parameter   DATA_WIDTH = 32) (\n\n  input                   hdmi_clk,\n  input                   hdmi_hs_de,\n  input                   hdmi_vs_de,\n  input       [(DATA_WIDTH-1):0]  hdmi_data_de,\n  output  reg [(DATA_WIDTH-1):0]  hdmi_data);\n\n  localparam  BYTE_WIDTH = DATA_WIDTH/8;\n\n  reg                         hdmi_hs_de_d = 'd0;\n  reg     [(DATA_WIDTH-1):0]  hdmi_data_d = 'd0;\n  reg                         hdmi_hs_de_2d = 'd0;\n  reg     [(DATA_WIDTH-1):0]  hdmi_data_2d = 'd0;\n  reg                         hdmi_hs_de_3d = 'd0;\n  reg     [(DATA_WIDTH-1):0]  hdmi_data_3d = 'd0;\n  reg                         hdmi_hs_de_4d = 'd0;\n  reg     [(DATA_WIDTH-1):0]  hdmi_data_4d = 'd0;\n  reg                         hdmi_hs_de_5d = 'd0;\n  reg     [(DATA_WIDTH-1):0]  hdmi_data_5d = 'd0;\n\n  wire    [(DATA_WIDTH-1):0]  hdmi_sav_s;\n  wire    [(DATA_WIDTH-1):0]  hdmi_eav_s;\n\n  assign hdmi_sav_s = (hdmi_vs_de == 1) ? {BYTE_WIDTH{8'h80}} : {BYTE_WIDTH{8'hab}};\n  assign hdmi_eav_s = (hdmi_vs_de == 1) ? {BYTE_WIDTH{8'h9d}} : {BYTE_WIDTH{8'hb6}};\n\n  always @(posedge hdmi_clk) begin\n    hdmi_hs_de_d <= hdmi_hs_de;\n    case ({hdmi_hs_de_4d, hdmi_hs_de_3d, hdmi_hs_de_2d,\n      hdmi_hs_de_d, hdmi_hs_de})\n      5'b11000: hdmi_data_d <= {BYTE_WIDTH{8'h00}};\n      5'b11100: hdmi_data_d <= {BYTE_WIDTH{8'h00}};\n      5'b11110: hdmi_data_d <= {BYTE_WIDTH{8'hff}};\n      5'b10000: hdmi_data_d <= hdmi_eav_s;\n      default: hdmi_data_d <= hdmi_data_de;\n    endcase\n    hdmi_hs_de_2d <= hdmi_hs_de_d;\n    hdmi_data_2d <= hdmi_data_d;\n    hdmi_hs_de_3d <= hdmi_hs_de_2d;\n    hdmi_data_3d <= hdmi_data_2d;\n    hdmi_hs_de_4d <= hdmi_hs_de_3d;\n    hdmi_data_4d <= hdmi_data_3d;\n    hdmi_hs_de_5d <= hdmi_hs_de_4d;\n    hdmi_data_5d <= hdmi_data_4d;\n    case ({hdmi_hs_de_5d, hdmi_hs_de_4d, hdmi_hs_de_3d,\n      hdmi_hs_de_2d, hdmi_hs_de_d})\n      5'b00111: hdmi_data <= {BYTE_WIDTH{8'h00}};\n      5'b00011: hdmi_data <= {BYTE_WIDTH{8'h00}};\n      5'b00001: hdmi_data <= {BYTE_WIDTH{8'hff}};\n      5'b01111: hdmi_data <= hdmi_sav_s;\n      default:  hdmi_data <= hdmi_data_5d;\n    endcase\n  end\n\nendmodule\n\n",
        "module_name": "axi_hdmi_tx_es #",
        "module_hash": "030f152fda2d67e9867c01697743b850",
        "dataset_index": 23575
      },
      "sky130_fd_sc_ls__o21ai_f9d8d1a2": {
        "rtl_code": "module sky130_fd_sc_ls__o21ai (\n    //# {{data|Data Signals}}\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    output Y   ,\n\n    //# {{power|Power}}\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    assign Y = (A1 ^ A2) ? ~B1 : (A1 & A2) ? B1 : A1 & A2;\n    \nendmodule",
        "module_name": "sky130_fd_sc_ls__o21ai",
        "module_hash": "f9d8d1a2932e8b754c90d9f879e66311",
        "dataset_index": 17529
      },
      "data_modifier_6c833350": {
        "rtl_code": "\nmodule data_modifier(\n    input [31:0] reg_input,\n    input [3:0] address,\n    input reg_out_syn,\n    input ack,\n    input ack_syn,\n    output reg [31:0] reg_out\n);\n\nreg [31:0] shifted_input;\nreg [31:0] reversed_input;\nreg [31:0] reg_out_nxt;\n\nalways @(*) begin\n    if (ack && !ack_syn) begin\n        shifted_input = {reg_input[30:0], 1'b0};\n        reg_out_nxt     = shifted_input;\n    end\n    else if (!ack && ack_syn) begin\n        shifted_input = {1'b0, reg_input[31:1]};\n        reg_out_nxt     = shifted_input;\n    end\n    else if (ack && ack_syn) begin\n        reversed_input = {reg_input[7:0], reg_input[15:8], reg_input[23:16], reg_input[31:24]};\n        reg_out_nxt     = reversed_input;\n    end\n    else begin\n        reg_out_nxt = reg_input;\n    end\nend\n\nwire reg_out_syn_nxt;\nassign reg_out_syn_nxt = ack || ack_syn;\n\nreg reg_out_syn_nxt_r;\nalways @(*) begin\n    reg_out_syn_nxt_r = reg_out_syn_nxt;\nend\n\nreg reg_out_syn_r;\nalways @(*) begin\n    reg_out_syn_r <= reg_out_syn_nxt_r;\nend\n\nassign reg_out_syn = reg_out_syn_r;\n\nalways @(*) begin\n    reg_out = reg_out_nxt;\nend\n\nendmodule",
        "module_name": "data_modifier",
        "module_hash": "6c833350c10e8c8bb4c9f3cd2c3fdbf0",
        "dataset_index": 21129
      },
      "oh_mux4 #_c2642979": {
        "rtl_code": "module oh_mux4 #(parameter DW = 1 ) (\n    input \t    sel3,\n    input \t    sel2,\n    input \t    sel1,\n    input \t    sel0,\n    input [DW-1:0]  in3,\n    input [DW-1:0]  in2,\n    input [DW-1:0]  in1,\n    input [DW-1:0]  in0, \n    output [DW-1:0] out  );\n\n   assign out[DW-1:0] = ({(DW){sel0}} & in0[DW-1:0] |\n\t\t\t {(DW){sel1}} & in1[DW-1:0] |\n\t\t\t {(DW){sel2}} & in2[DW-1:0] |\n\t\t\t {(DW){sel3}} & in3[DW-1:0]);\n\n`ifdef TARGET_SIM\n   wire \t    error;\n   assign error = (sel0 | sel1 | sel2 | sel3) &\n   \t\t  ~(sel0 ^ sel1 ^ sel2 ^ sel3);\n\n   always @ (posedge error)\n     begin\n\t#1 if(error)\n\t  $display (\"ERROR at in oh_mux4 %m at \",$time);\n     end\n`endif   \t\t\t\nendmodule ",
        "module_name": "oh_mux4 #",
        "module_hash": "c2642979959349fe643f6a6219c4192c",
        "dataset_index": 24119
      },
      "binary_counter_be52981b": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "be52981b3cecc8d427ad85f2eab7602c",
        "dataset_index": 8823
      },
      "gray_code_counter_df0142b6": {
        "rtl_code": "module gray_code_counter (\n  input clk,\n  input reset,\n  input enable,\n  output reg q0,\n  output reg q1,\n  output reg q2\n);\n\n  reg d0, d1, d2;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      q0 <= 1'b0;\n      q1 <= 1'b0;\n      q2 <= 1'b0;\n    end else if (enable) begin\n      d0 <= q0 ^ q1;\n      d1 <= q1 ^ q2;\n      d2 <= q2 ^ enable;\n      q0 <= d0;\n      q1 <= d1;\n      q2 <= d2;\n    end\n  end\n\nendmodule\n",
        "module_name": "gray_code_counter",
        "module_hash": "df0142b682385b69d5a67779096619d1",
        "dataset_index": 14173
      },
      "pipelined_JC_counter_f4b21dfe": {
        "rtl_code": "module pipelined_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [3:0]    Q\n);\n\n  reg [3:0] Q1, Q2, Q3, Q4;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      Q1 <= 4'b0000;\n      Q2 <= 4'b0000;\n      Q3 <= 4'b0000;\n      Q4 <= 4'b0000;\n      Q  <= 4'b0000;\n    end\n    else begin\n      Q1 <= Q;\n      Q2 <= Q1;\n      Q3 <= Q2;\n      Q4 <= Q3;\n      Q  <= ~(Q1 ^ Q2 ^ Q3 ^ Q4);\n    end\n  end\n\nendmodule",
        "module_name": "pipelined_JC_counter",
        "module_hash": "f4b21dfe953715eb75cd4ac676dcdac9",
        "dataset_index": 17901
      },
      "adder_fc718aca": {
        "rtl_code": "\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n\nassign sum = a + b;\n\nendmodule\nmodule average(\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    output [7:0] result\n);\n\nwire [7:0] sum;\nwire [7:0] divisor = 3;\n\nadder adder1(.a(a), .b(b), .sum(sum));\nadder adder2(.a(sum), .b(c), .sum(result));\n\nendmodule\nmodule top_module(\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    output [7:0] result\n);\n\naverage avg(.a(a), .b(b), .c(c), .result(result));\n\nendmodule",
        "module_name": "adder",
        "module_hash": "fc718acad0002f5fe378836f9dc11f38",
        "dataset_index": 17300
      },
      "lcd_driver_26f06e5f": {
        "rtl_code": "module lcd_driver (\n  input clk,\n  input reset,\n  input enable,\n  input in_cmd,\n  input [7:0] in_data,\n  output [7:0] lcd_pins,\n  output rs,\n  output rw,\n  output backlight\n);\n\n  // Define internal signals\n  reg [7:0] lcd_data;\n  reg lcd_rs;\n  reg lcd_rw;\n  reg lcd_backlight;\n  reg lcd_enable;\n\n  // Define constants for LCD commands\n  parameter LCD_CLEAR_DISPLAY = 8'h01;\n  parameter LCD_RETURN_HOME = 8'h02;\n  parameter LCD_ENTRY_MODE_SET = 8'h04;\n  parameter LCD_DISPLAY_ON_OFF_CONTROL = 8'h08;\n  parameter LCD_CURSOR_DISPLAY_SHIFT = 8'h10;\n  parameter LCD_FUNCTION_SET = 8'h20;\n  parameter LCD_SET_CGRAM_ADDRESS = 8'h40;\n  parameter LCD_SET_DDRAM_ADDRESS = 8'h80;\n\n  // Define state variables\n  reg [2:0] state;\n  parameter STATE_IDLE = 3'b000;\n  parameter STATE_WAIT_ENABLE = 3'b001;\n  parameter STATE_SEND_COMMAND = 3'b010;\n  parameter STATE_SEND_DATA = 3'b011;\n\n  // Initialize internal signals and state variables\n  initial begin\n    lcd_data <= 8'h00;\n    lcd_rs <= 1'b0;\n    lcd_rw <= 1'b0;\n    lcd_backlight <= 1'b0;\n    lcd_enable <= 1'b0;\n    state <= STATE_IDLE;\n  end\n\n  // Define state machine\n  always @(posedge clk) begin\n    case (state)\n      STATE_IDLE: begin\n        if (reset) begin\n          state <= STATE_IDLE;\n        end else if (enable) begin\n          state <= STATE_WAIT_ENABLE;\n        end\n      end\n      STATE_WAIT_ENABLE: begin\n        if (reset) begin\n          state <= STATE_IDLE;\n        end else if (!enable) begin\n          state <= STATE_IDLE;\n        end else if (in_cmd) begin\n          state <= STATE_SEND_COMMAND;\n        end else begin\n          state <= STATE_SEND_DATA;\n        end\n      end\n      STATE_SEND_COMMAND: begin\n        lcd_data <= in_data;\n        lcd_rs <= 1'b0;\n        lcd_rw <= 1'b0;\n        lcd_backlight <= 1'b1;\n        lcd_enable <= 1'b1;\n        state <= STATE_IDLE;\n      end\n      STATE_SEND_DATA: begin\n        lcd_data <= in_data;\n        lcd_rs <= 1'b1;\n        lcd_rw <= 1'b0;\n        lcd_backlight <= 1'b1;\n        lcd_enable <= 1'b1;\n        state <= STATE_IDLE;\n      end\n    endcase\n  end\n\n  // Assign outputs\n  assign lcd_pins = lcd_data;\n  assign rs = lcd_rs;\n  assign rw = lcd_rw;\n  assign backlight = lcd_backlight;\n\nendmodule",
        "module_name": "lcd_driver",
        "module_hash": "26f06e5f8330ec106cd6cf3c73a1d133",
        "dataset_index": 5727
      },
      "transition_detector_a563ae2f": {
        "rtl_code": "module transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 0;\n        prev_in <= 0;\n    end else begin\n        if (in != prev_in) begin\n            out <= out | (~in & prev_in);\n        end\n        prev_in <= in;\n    end\nend\n\nendmodule\n\nmodule shift_register (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] q\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 0;\n        counter <= 0;\n    end else begin\n        q <= {q[30:0], in};\n        counter <= counter + 1;\n        if (counter == 3) begin\n            counter <= 0;\n        end\n    end\nend\n\nendmodule\n\nmodule or_module (\n    input [31:0] in1,\n    input [31:0] in2,\n    output reg [31:0] out\n);\n\nalways @(*) begin\n    out = in1 | in2;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nwire [31:0] trans_out;\nwire [31:0] shift_out;\n\ntransition_detector trans_detector (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(trans_out)\n);\n\nshift_register shift_reg (\n    .clk(clk),\n    .reset(reset),\n    .in(trans_out),\n    .q(shift_out)\n);\n\nor_module or_gate (\n    .in1(trans_out),\n    .in2(shift_out),\n    .out(out)\n);\n\nendmodule",
        "module_name": "transition_detector",
        "module_hash": "a563ae2ff6ceac95fb641bddc2f880a8",
        "dataset_index": 10873
      },
      "regfile_2092beaa": {
        "rtl_code": "module regfile (\n  //------------------------------\n  // Top level control signals\n  //------------------------------\n  input wire clk,\n  //------------------------------\n  // Input data\n  //------------------------------\n  input  wire [2:0]       rd_at,\n  input  wire [2:0]       wr_at,\n  input  wire             wr_en,\n  input  wire [31:0]      din,\n  //------------------------------\n  // Output data\n  //------------------------------\n  output wire [31:0]      dout\n);\n  \n  reg [31:0] data [2:0];\n  \n  always @(posedge clk)\n  begin\n    if (wr_en == 1'b1)\n      data[wr_at] <= din;\n  end\n      \n  assign dout = data[rd_at];\n  \nendmodule",
        "module_name": "regfile",
        "module_hash": "2092beaa243da30183bb2442a6fb92b9",
        "dataset_index": 8721
      },
      "calculator_2ef804ba": {
        "rtl_code": "\nmodule calculator (\n  input clk,\n  input areset, // async active-high reset to zero\n  input load,\n  input ena,\n  input [2:0] bin_in,  // Binary input for the binary to binary converter\n  input shift_left,   // Control input to shift left instead of right\n  input operation,    // 0 for addition, 1 for subtraction\n  output [3:0] result // 4-bit output from the shift register\n);\n\n  wire [2:0] bin_out;\n  wire o2, o1, o0;\n  binary_to_binary b2b(.vec(bin_in), .outv(bin_out), .o2(o2), .o1(o1), .o0(o0));\n  shift_register sr(.clk(clk), .areset(areset), .load(load), .ena(ena), .shift_left(shift_left), .data_in({bin_out[2], bin_out[1], bin_out[0], o2, o1, o0}), .result(result));\n\n  reg [3:0] reg_result;\n\n  always @(posedge clk or posedge areset) begin\n    if (areset) begin\n      reg_result <= 0;\n    end else if (load) begin\n      reg_result <= {1'b0, bin_out};\n    end else if (ena) begin\n      if (operation == 0) begin\n        reg_result <= reg_result + {1'b0, bin_out};\n      end else begin\n        reg_result <= reg_result - {1'b0, bin_out};\n      end\n    end\n  end\n\nendmodule\nmodule binary_to_binary (\n  input wire [2:0] vec, // 3-bit binary input\n  output wire [2:0] outv, // Binary output\n  output wire o2, // Output corresponding to the input binary at bit position 2\n  output wire o1, // Output corresponding to the input binary at bit position 1\n  output wire o0 // Output corresponding to the input binary at bit position 0\n);\n\n  assign outv = vec;\n  assign o2 = vec[2];\n  assign o1 = vec[1];\n  assign o0 = vec[0];\n\nendmodule\nmodule shift_register (\n  input clk,\n  input areset, // async active-high reset to zero\n  input load,\n  input ena,\n  input shift_left,   // Control input to shift left instead of right\n  input [5:0] data_in, // 6-bit input for the shift register\n  output reg [3:0] result // 4-bit output from the shift register\n);\n\n  always @(posedge clk or posedge areset) begin\n    if (areset) begin\n      result <= 0;\n    end else if (load) begin\n      result <= data_in[3:0];\n    end else if (ena) begin\n      if (shift_left) begin\n        result <= {result[2:0], data_in[5]};\n      end else begin\n        result <= {data_in[4], result[3:1]};\n      end\n    end\n  end\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "2ef804ba4b04aaca8f83eae19d548d71",
        "dataset_index": 14698
      },
      "up_down_counter_0b795e59": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input rst,\n    input load,\n    input up_down,\n    input [2:0] data_in,\n    output reg [2:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 3'b0;\n        end else if (load) begin\n            count <= data_in;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "0b795e5971a63f8870b7376911a5a49b",
        "dataset_index": 7460
      },
      "first_counter_4bf46c74": {
        "rtl_code": "module first_counter (\nclock , reset , enable , counter_out ); input clock ;\ninput reset ;\ninput enable ;\noutput [3:0] counter_out ;\nwire clock ;\nwire reset ;\nwire enable ;\nreg [3:0] counter_out ;\n\nalways @ (posedge clock)\nbegin : COUNTER if (reset == 1'b1) begin\n    counter_out <= 4'b0000;\n  end\n  else if (enable == 1'b1) begin\n    counter_out <= counter_out + 1;\n  end\nend endmodule ",
        "module_name": "first_counter",
        "module_hash": "4bf46c7492260f1b7572c9727a6a75d3",
        "dataset_index": 25501
      },
      "pmsm_bb5d7aff": {
        "rtl_code": "module pmsm (npm0, npm1, npm2, npm3, pm0, pm1, pm2, pm3, clk, reset);\n\n   output [3:0] pm0, pm1, pm2, pm3;\n\n   input  \tclk, reset;\n   input [3:0] \tnpm0, npm1, npm2, npm3;\n\n   reg [3:0] \tpm0, pm1, pm2, pm3;\n   reg [3:0] \tnpm0norm, npm1norm, npm2norm, npm3norm;\n   \n   always @ (npm0 or npm1 or npm2 or npm3)\n\t begin\n\t   if ((npm0 <= npm1)&&(npm0 <= npm2)&&(npm0 <= npm3))\n\t     begin\n\t       npm0norm <= 0;\n\t       npm1norm <= npm1-npm0;\n\t       npm2norm <= npm2-npm0;\n\t       npm3norm <= npm3-npm0;\n\t     end\n\t   else if ((npm1 <= npm0)&&(npm1 <= npm2)&&(npm1 <= npm3))\n\t     begin\n\t       npm0norm <= npm0-npm1;\n\t       npm1norm <= 0;\n\t       npm2norm <= npm2-npm1;\n\t       npm3norm <= npm3-npm1;\n\t     end\n\t   else if ((npm2 <= npm0)&&(npm2 <= npm1)&&(npm2 <= npm3))\n\t     begin\n\t       npm0norm <= npm0-npm2;\n\t       npm1norm <= npm1-npm2;\n\t       npm2norm <= 0;\n\t       npm3norm <= npm3-npm2;\n\t     end\n\t   else if ((npm3 <= npm0)&&(npm3 <= npm1)&&(npm3 <= npm2))\n\t     begin\n\t       npm0norm <= npm0-npm3;\n\t       npm1norm <= npm1-npm3;\n\t       npm2norm <= npm2-npm3;\n\t       npm3norm <= 0;\n\t     end\n\t end always @ (posedge clk)\n\t begin\n\t\tif (reset)\n\t\t  begin\n\t\t    pm0 <= 4'd0;\n\t\t    pm1 <= 4'd0;\n\t\t    pm2 <= 4'd0;\n\t\t    pm3 <= 4'd0;\n\t\t  end\n\t\telse\n\t\t  begin\n\t\t    pm0 <= npm0norm;\n\t\t    pm1 <= npm1norm;\n\t\t    pm2 <= npm2norm;\n\t\t    pm3 <= npm3norm;\n\t\t  end\n\t end endmodule\n",
        "module_name": "pmsm",
        "module_hash": "bb5d7aff33a6504749066efa05ab7472",
        "dataset_index": 23948
      },
      "nor3_86c44dbe": {
        "rtl_code": "module nor3 (\n    output Y,\n    input A,\n    input B,\n    input C\n);\n\n    assign Y = ~(A | B | C);\n\nendmodule\n\nmodule nor4 (\n    output Y,\n    input A,\n    input B,\n    input C,\n    input D\n);\n    \n    wire n1, n2, n3, n4, n5, n6;\n    \n    nor3 n3_1 (\n        .Y(n1),\n        .A(A),\n        .B(B),\n        .C(C)\n    );\n    \n    nor3 n3_2 (\n        .Y(n2),\n        .A(B),\n        .B(C),\n        .C(D)\n    );\n    \n    nor3 n3_3 (\n        .Y(n3),\n        .A(A),\n        .B(C),\n        .C(D)\n    );\n    \n    nor3 n3_4 (\n        .Y(n4),\n        .A(A),\n        .B(B),\n        .C(D)\n    );\n    \n    nor3 n3_5 (\n        .Y(n5),\n        .A(n1),\n        .B(n2),\n        .C(n3)\n    );\n    \n    nor3 n3_6 (\n        .Y(Y),\n        .A(n5),\n        .B(n4),\n        .C(D)\n    );\n\nendmodule",
        "module_name": "nor3",
        "module_hash": "86c44dbe9a4507d9532c5293843618cb",
        "dataset_index": 6753
      },
      "sync_4743fea3": {
        "rtl_code": "module sync\n    (input wire OutputClock,  //\n    input  wire reset_b,      //\n    input  wire InputData,    //\n    output wire OutputData);  //\n\n    \n    wire synch_flop_1;\n    assign synch_flop_1 = InputData;\n    \n    \n    \n    dff_async_reset\n        dff_1\n        (// Global Signals                  // ----------------------------\n        .clk     (OutputClock),\n        .reset_b (reset_b),\n        //                                  // ----------------------------\n        .d       (synch_flop_1),\n        .q       (OutputData));\n    \nendmodule\n\nmodule dff_async_reset\n    (input  wire clk,      //\n    input  wire reset_b,  //\n    input  wire d,        //\n    output reg  q);       //\n    \n    always @(posedge clk or negedge reset_b) begin\n        if (!reset_b) begin\n            q <= 0;\n        end else begin\n            q <= d;\n        end\n    end\n    \nendmodule",
        "module_name": "sync",
        "module_hash": "4743fea3b2a8a09bd7c6b4b0fad8690a",
        "dataset_index": 13040
      },
      "counter_541b884f": {
        "rtl_code": "module counter(\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg [7:0] count_out\n);\n\nreg in_prev;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        count_out <= 0;\n        in_prev <= 0;\n    end\n    else begin\n        if (in && !in_prev) begin\n            count_out <= count_out + 1;\n        end\n        in_prev <= in;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "541b884f29be286fcd7fa2f7aff9cd95",
        "dataset_index": 1353
      },
      "calculator_top_84940daa": {
        "rtl_code": "module calculator_top (\n  input clk,\n  input rst_n,\n  input [7:0] a,\n  input [7:0] b,\n  input [1:0] op,\n  output [7:0] result,\n  output valid\n);\n\n  reg [8:0] sum;\n  assign result = sum[7:0];\n  assign valid = (sum[8] == 1'b0);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      sum <= 9'b0;\n    end\n    else begin\n      case (op)\n        2'b00: sum <= a + b;\n        2'b01: sum <= a - b;\n        default: sum <= 9'b0;\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "calculator_top",
        "module_hash": "84940daac4423c4ebe127391e6178d79",
        "dataset_index": 9612
      },
      "seven_segment_13551ab9": {
        "rtl_code": "module seven_segment (\n    input [3:0] data_in,\n    output reg [6:0] seg_out,\n    input clk\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\nreg [3:0] stage3_out;\n\nalways @(posedge clk) begin\n    stage1_out <= data_in;\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\nend\n\nalways @(posedge clk) begin\n    stage3_out <= stage2_out;\nend\n\nalways @(*) begin\n    case(stage3_out)\n        4'b0000: seg_out = 7'b1111110; // 0\n        4'b0001: seg_out = 7'b0110000; // 1\n        4'b0010: seg_out = 7'b1101101; // 2\n        4'b0011: seg_out = 7'b1111001; // 3\n        4'b0100: seg_out = 7'b0110011; // 4\n        4'b0101: seg_out = 7'b1011011; // 5\n        4'b0110: seg_out = 7'b1011111; // 6\n        4'b0111: seg_out = 7'b1110000; // 7\n        4'b1000: seg_out = 7'b1111111; // 8\n        4'b1001: seg_out = 7'b1111011; // 9\n        default: seg_out = 7'b0000000; // invalid input\n    endcase\nend\n\nendmodule",
        "module_name": "seven_segment",
        "module_hash": "13551ab9d1759295f3c9f1cdb811a8c7",
        "dataset_index": 446
      },
      "counter_e91dc4ae": {
        "rtl_code": "module counter(\n    input reset,\n    input clk,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 0;\n    end else if (count == 255) begin\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "e91dc4ae399e41fa738c00c980544a6a",
        "dataset_index": 5792
      },
      "shiftll_f2d5615e": {
        "rtl_code": "module shiftll (busSLL, busA, sel, zSLL, oSLL, cSLL, nSLL);\n\toutput [31:0] busSLL;\n\tinput  [31:0] busA, sel;\n    output zSLL, nSLL;\n    output reg oSLL, cSLL;\n\n    assign busSLL = busA << sel[2:0];\n\n    assign zSLL = ~|busSLL[31:0];\n    assign nSLL = busSLL[31];\n    always @(*) begin\n    \tif (sel[2:0] == 3'b0) begin\n    \t\tcSLL = 1'b0;\n    \t\toSLL = 1'b0;\n    \tend else if (sel[2:0] == 3'b1) begin\n    \t\tcSLL = busSLL[31];\n    \t\toSLL = busSLL[31];\n    \tend else if (sel[2:0] == 3'b10) begin\n    \t\tcSLL = busSLL[30];\n            oSLL = |busSLL[31:30];\n        end else if (sel[2:0] == 3'b11) begin\n            cSLL = busSLL[29];\n            oSLL = |busSLL[31:29];\n        end else if (sel[2:0] == 3'b100) begin\n            cSLL = busSLL[28];\n            oSLL = |busSLL[31:28];\n        end else if (sel[2:0] == 3'b101) begin\n            cSLL = busSLL[27];\n            oSLL = |busSLL[31:27];\n        end else if (sel[2:0] == 3'b110) begin\n            cSLL = busSLL[26];\n            oSLL = |busSLL[31:26];\n    \tend\telse begin\n    \t\tcSLL = busSLL[25];\n    \t\toSLL = |busSLL[31:25];\n    \tend\n    end\nendmodule",
        "module_name": "shiftll",
        "module_hash": "f2d5615e616ab646a870722d91fcf533",
        "dataset_index": 1401
      },
      "conflict_ff_clk_6b4e246c": {
        "rtl_code": "module conflict_ff_clk (\n    input wire CLK1,\n    input wire CLK2,\n    input wire [8:0] A,\n    input wire [8:0] B,\n    output reg [17:0] Z\n);\n\n    always @(posedge CLK2)\n        Z <= {B[8:0], Z[17:9]};\n\nendmodule\n\nmodule MULT9X9 (\n    input wire [8:0] A,\n    input wire [8:0] B,\n    output reg [17:0] Z\n);\n\n    always @*\n        Z = A * B;\n\nendmodule",
        "module_name": "conflict_ff_clk",
        "module_hash": "6b4e246c4dba680b37d14c02eaffc8cb",
        "dataset_index": 1496
      },
      "top__cf19651f": {
        "rtl_code": "module top_module (\n    input clk,\n    input rst_n,\n    input [15:0] in,\n    input [1:0] select,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input [7:0] read_addr,\n    output reg [7:0] out_hi,\n    output reg [7:0] out_lo\n);\n\nreg [3:0] ram [0:7];\nreg [15:0] bitwise_result;\nreg [7:0] read_data;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        out_hi <= 8'b0;\n        out_lo <= 8'b0;\n    end else begin\n        case (select)\n            2'b00: bitwise_result = in & (in << 1);\n            2'b01: bitwise_result = in | (in << 1);\n            2'b10: bitwise_result = in ^ (in << 1);\n            default: bitwise_result = in;\n        endcase\n\n        if (write_addr < 8) begin\n            ram[write_addr] <= write_data;\n        end\n\n        if (read_addr < 8) begin\n            read_data <= ram[read_addr];\n        end\n\n        out_hi <= {bitwise_result[15], bitwise_result[13], bitwise_result[11], bitwise_result[9],\n                   read_data[3], read_data[2], read_data[1], read_data[0]};\n        out_lo <= {bitwise_result[14], bitwise_result[12], bitwise_result[10], bitwise_result[8],\n                   read_data[7], read_data[6], read_data[5], read_data[4]};\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "cf19651f0a0ff19a947874d778def94b",
        "dataset_index": 13166
      },
      "fifo_buffer_d91e4c3a": {
        "rtl_code": "\nmodule fifo_buffer (\n    input clk,\n    input rst_n,\n    input wr_en,\n    input rd_en,\n    input [7:0] data_in,\n    output reg [7:0] data_out,\n    output empty,\n    output full\n);\n\n    parameter BUFFER_SIZE = 16;\n    reg [7:0] buffer [0:BUFFER_SIZE-1];\n    reg [3:0] head = 0;\n    reg [3:0] tail = 0;\n    reg [3:0] count = 0;\n\n    assign empty = (count == 0);\n    assign full = (count == BUFFER_SIZE);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            head <= 0;\n            tail <= 0;\n            count <= 0;\n        end\n        else begin\n            if (wr_en && ~full) begin\n                buffer[head] <= data_in;\n                head <= (head == BUFFER_SIZE-1) ? 0 : head+1;\n                count <= count + 1;\n            end\n            if (rd_en && ~empty) begin\n                data_out <= buffer[tail];\n                tail <= (tail == BUFFER_SIZE-1) ? 0 : tail+1;\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "d91e4c3a04a735c8e28986c94cc554c0",
        "dataset_index": 15633
      },
      "multiplier_2x2_b0c4c5a6": {
        "rtl_code": "module multiplier_2x2 (\n    input [1:0] A,\n    input [1:0] B,\n    output reg [3:0] P,\n    output reg [3:0] Q\n);\n\n    always @(*) begin\n        P = A * B[0];\n        Q = A * B[1];\n    end\n\nendmodule",
        "module_name": "multiplier_2x2",
        "module_hash": "b0c4c5a6690514824c8b322693cabb56",
        "dataset_index": 3634
      },
      "mux_2_to_1_957aba6f": {
        "rtl_code": "module mux_2_to_1 (\n    input A,\n    input B,\n    input S,\n    input clk,\n    output reg Y\n);\n\nreg reg_A;\nreg reg_B;\n\nalways @(posedge clk) begin\n    reg_A <= A;\n    reg_B <= B;\nend\n\nalways @(posedge clk) begin\n    if (S == 0) begin\n        Y <= reg_A;\n    end\n    else begin\n        Y <= reg_B;\n    end\nend\n\nendmodule",
        "module_name": "mux_2_to_1",
        "module_hash": "957aba6fdf26ae6642bde0e47621290a",
        "dataset_index": 13503
      },
      "Divisor_Frecuencia_de8f4772": {
        "rtl_code": "\nmodule Divisor_Frecuencia (\n\t\tinput  C_100Mhz, output  C_1Hz\n\t);\n\n\treg[31:0] contador = 0; reg C_1Hz=0;\n\t \n\talways @(posedge C_100Mhz)\n\t\tbegin\n\t\t\t\tif (contador == 50000000-1)          begin\n\t\t\t\t\tC_1Hz <= ~C_1Hz;\n\t\t\t\t\tcontador <=0;\n\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\tcontador <= contador + 1;        end\n\t  end\nendmodule\n",
        "module_name": "Divisor_Frecuencia",
        "module_hash": "de8f47725f8538db3c15abf318a97d6d",
        "dataset_index": 20772
      },
      "crtc6845_d4127383": {
        "rtl_code": "module crtc6845( \nI_E, \nI_DI, \nI_RS, \nI_RWn, \nI_CSn, \nI_CLK, \nI_RSTn, \n \nO_RA, \nO_MA, \nO_H_SYNC, \nO_V_SYNC, \nO_DISPTMG,\nvideo_offset_o \n \n); \n \ninput  I_E; \ninput  [7:0]I_DI; \ninput  I_RS; \ninput  I_RWn; \ninput  I_CSn; \n \ninput  I_CLK; \ninput  I_RSTn; \n \noutput [4:0]O_RA; \noutput [13:0]O_MA; \noutput O_H_SYNC; \noutput O_V_SYNC; \noutput O_DISPTMG; \n\noutput [15:0] video_offset_o;\n \nwire   [7:0]W_Nht; \nwire   [7:0]W_Nhd; \nwire   [7:0]W_Nhsp; \nwire   [3:0]W_Nhsw; \nwire   [6:0]W_Nvt; \nwire   [4:0]W_Nadj; \nwire   [6:0]W_Nvd; \nwire   [6:0]W_Nvsp; \nwire   [3:0]W_Nvsw; \nwire   [4:0]W_Nr; \nwire   [13:0]W_Msa; \n \nwire   W_Vmode; \nwire   W_IntSync; \nwire   [1:0] W_DScue; \nwire   [1:0] W_CScue; \n\nassign video_offset_o = {5'b11000,W_Msa[9:0],1'b0};\n \nmpu_if mpu_if( \n \n.I_RSTn(I_RSTn), \n.I_E(I_E), \n.I_DI(I_DI), \n.I_RS(I_RS), \n.I_RWn(I_RWn), \n.I_CSn(I_CSn), \n \n.O_Nht(W_Nht), \n.O_Nhd(W_Nhd), \n.O_Nhsp(W_Nhsp), \n.O_Nhsw(W_Nhsw), \n.O_Nvt(W_Nvt), \n.O_Nadj(W_Nadj), \n.O_Nvd(W_Nvd), \n.O_Nvsp(W_Nvsp), \n.O_Nvsw(W_Nvsw), \n.O_Nr(W_Nr), \n.O_Msa(W_Msa), \n \n.O_VMode(W_Vmode), \n.O_IntSync(W_IntSync), \n.O_DScue(W_DScue), \n.O_CScue(W_CScue)\n); \n \ncrtc_gen crtc_gen( \n \n.I_CLK(I_CLK), \n.I_RSTn(I_RSTn), \n.I_Nht(W_Nht), \n.I_Nhd(W_Nhd), \n.I_Nhsp(W_Nhsp), \n.I_Nhsw(W_Nhsw), \n.I_Nvt(W_Nvt), \n.I_Nadj(W_Nadj), \n.I_Nvd(W_Nvd), \n.I_Nvsp(W_Nvsp), \n.I_Nvsw(W_Nvsw), \n.I_Nr(W_Nr), \n.I_Msa(W_Msa), \n \n.O_RA(O_RA), \n.O_MA(O_MA), \n.O_H_SYNC(O_H_SYNC), \n.O_V_SYNC(O_V_SYNC), \n.O_DISPTMG(O_DISPTMG) \n \n); \n \n \nendmodule \n \n \nmodule mpu_if( \n \nI_RSTn, \nI_E, \nI_DI, \nI_RS, \nI_RWn, \nI_CSn, \n \nO_Nht, \nO_Nhd, \nO_Nhsp, \nO_Nhsw, \nO_Nvt, \nO_Nadj, \nO_Nvd, \nO_Nvsp, \nO_Nvsw, \nO_Nr, \nO_Msa, \n \nO_DScue, \nO_CScue, \nO_VMode, \nO_IntSync\n); \n \ninput I_RSTn; \ninput  I_E; \ninput  [7:0]I_DI; \ninput  I_RS; \ninput  I_RWn; \ninput  I_CSn; \n \noutput [7:0]O_Nht; \noutput [7:0]O_Nhd; \noutput [7:0]O_Nhsp; \noutput [3:0]O_Nhsw; \noutput [6:0]O_Nvt; \noutput [4:0]O_Nadj; \noutput [6:0]O_Nvd; \noutput [6:0]O_Nvsp; \noutput [3:0]O_Nvsw; \noutput [4:0]O_Nr; \noutput [13:0]O_Msa; \noutput [1:0] O_DScue; \noutput [1:0] O_CScue; \noutput O_VMode; \noutput O_IntSync; \n \n\nreg    [4:0]R_ADR; \nreg    [7:0]R_Nht; \nreg    [7:0]R_Nhd; \nreg    [7:0]R_Nhsp; \nreg    [7:0]R_Nsw; \nreg    [6:0]R_Nvt; \nreg    [4:0]R_Nadj; \nreg    [6:0]R_Nvd; \nreg    [6:0]R_Nvsp; \nreg    [7:0]R_Intr; \nreg    [4:0]R_Nr; \nreg    [5:0]R_Msah; \nreg    [7:0]R_Msal; \n\nassign O_Nht  = R_Nht; \nassign O_Nhd  = R_Nhd; \nassign O_Nhsp = R_Nhsp; \nassign O_Nhsw = R_Nsw[3:0]; \nassign O_Nvt  = R_Nvt; \nassign O_Nadj = R_Nadj; \nassign O_Nvd  = R_Nvd; \nassign O_Nvsp = R_Nvsp; \nassign O_Nvsw = R_Nsw[7:4]; \nassign O_Nr   = R_Nr; \nassign O_Msa  = {R_Msah,R_Msal}; \n \nassign O_VMode   =  R_Intr[1]; \nassign O_IntSync =  R_Intr[0]; \nassign O_DScue   = R_Intr[5:4]; assign O_CScue   = R_Intr[7:6]; always@(negedge I_RSTn or negedge I_E) \nbegin \n  if(~I_RSTn) begin \n   R_Nht  <= 8'h3F;     R_Nhd  <= 8'h28;     R_Nhsp <= 8'h33;     R_Nsw  <= 8'h24;     R_Nvt  <= 7'h1E;     R_Nadj <= 5'h02;     R_Nvd  <= 7'h19;     R_Nvsp <= 7'h1B; R_Intr <= 8'h91; R_Nr   <= 5'h09; R_Msah <= 6'h28;     R_Msal <= 8'h00;     end else \n  if(~I_CSn)begin \n    if(~I_RWn)begin \n      if(~I_RS)begin       \n        R_ADR <= I_DI[4:0]; \n      end else begin \n        case(R_ADR) \n          5'h0 : R_Nht  <= I_DI ; \n          5'h1 : R_Nhd  <= I_DI ; \n          5'h2 : R_Nhsp <= I_DI ; \n          5'h3 : R_Nsw  <= I_DI ; \n          5'h4 : R_Nvt  <= I_DI[6:0] ; \n          4'h5 : R_Nadj <= I_DI[4:0] ; \n          5'h6 : R_Nvd  <= I_DI[6:0] ; \n          5'h7 : R_Nvsp <= I_DI[6:0] ; \n          5'h8 : R_Intr <= I_DI[7:0] ; \n          5'h9 : R_Nr   <= I_DI[4:0] ; \n          5'hC : R_Msah <= I_DI[5:0] ; \n          5'hD : R_Msal <= I_DI ; \n          default:; \n        endcase \n      end \n    end \n  end \nend \n \nendmodule \n \nmodule crtc_gen( \n \nI_CLK, \nI_RSTn, \nI_Nht, \nI_Nhd, \nI_Nhsp, \nI_Nhsw, \nI_Nvt, \nI_Nadj, \nI_Nvd, \nI_Nvsp, \nI_Nvsw, \nI_Nr, \nI_Msa, \n \nO_RA, \nO_MA, \nO_H_SYNC, \nO_V_SYNC, \nO_DISPTMG \n \n); \n \ninput  I_CLK; \ninput  I_RSTn; \ninput  [7:0]I_Nht; \ninput  [7:0]I_Nhd; \ninput  [7:0]I_Nhsp; \ninput  [3:0]I_Nhsw; \ninput  [6:0]I_Nvt; \ninput  [4:0]I_Nr; \ninput  [4:0]I_Nadj;  input  [6:0]I_Nvd; \ninput  [6:0]I_Nvsp; \ninput  [3:0]I_Nvsw; \ninput  [13:0]I_Msa; \n \noutput [4:0]O_RA; \noutput [13:0]O_MA; \noutput O_H_SYNC; \noutput O_V_SYNC; \noutput O_DISPTMG; \n \nreg    [7:0]R_H_CNT; \nreg    [6:0]R_V_CNT; \nreg    [4:0]R_RA; \nreg    [13:0]R_MA; \nreg    R_H_SYNC,R_V_SYNC; \nreg    R_DISPTMG ,R_V_DISPTMG; \nreg    R_LAST_LINE; \n \nwire   [7:0] NEXT_R_H_CNT = (R_H_CNT+8'h01); \nwire   [6:0] NEXT_R_V_CNT = (R_V_CNT+7'h01); \nwire   [4:0] NEXT_R_RA    = R_RA + 1'b1; \n \nwire W_HD       = (R_H_CNT==I_Nht); \n \nwire W_VD       = (R_V_CNT==I_Nvt); \nwire W_ADJ_C    = R_LAST_LINE & (NEXT_R_RA==I_Nadj); \nwire W_VCNT_RET = ((R_RA==I_Nr) & (I_Nadj==0) & W_VD) | W_ADJ_C; \n \nwire W_RA_C     = (R_RA==I_Nr) | W_ADJ_C; \n \nwire   W_HSYNC_P = (NEXT_R_H_CNT == I_Nhsp); \nwire   W_HSYNC_W = (NEXT_R_H_CNT[3:0] == (I_Nhsp[3:0]+I_Nhsw) ); \nwire   W_VSYNC_P = (NEXT_R_V_CNT == I_Nvsp ) & W_RA_C; \nwire   W_VSYNC_W = (NEXT_R_RA[3:0]==I_Nvsw); \n \nwire W_HDISP_N   = (NEXT_R_H_CNT==I_Nhd); \nwire W_VDISP_N   = (NEXT_R_V_CNT==I_Nvd) & W_RA_C; \n \nassign O_H_SYNC = R_H_SYNC; \nassign O_V_SYNC = R_V_SYNC; \nassign O_RA     = R_RA; \nassign O_MA     = R_MA; \nassign O_DISPTMG = R_DISPTMG; \n \nreg    [13:0] R_MA_C; \nalways@(negedge I_CLK or negedge I_RSTn) \nbegin \n  if(! I_RSTn)begin \n    R_MA   <= 14'h0000; \n    R_MA_C <= 14'h0000; \n    R_H_CNT <= 8'h00;  \n    R_H_SYNC <= 0;  \n    R_RA <= 5'h00;  \n \n    R_V_CNT <= 7'h00;  \n    R_LAST_LINE <= 1'b0; \n    R_V_SYNC <= 0;  \n \n    R_V_DISPTMG <= 1'b0; \n    R_DISPTMG   <= 1'b0; \n  end \n  else begin \n    R_H_CNT <= W_HD ? 8'h00 : NEXT_R_H_CNT; \n \n    R_MA <= W_HD ? R_MA_C : R_MA + 1'b1; \n \n    if(W_RA_C & (R_H_CNT==I_Nhd) ) \n      R_MA_C <= W_VCNT_RET ? I_Msa : R_MA; \n \n    if(W_HSYNC_P)      R_H_SYNC <= 1'b1; \n    else if(W_HSYNC_W) R_H_SYNC <= 1'b0; \n \n    if(W_HD) \n    begin \n      R_RA <= W_RA_C ? 5'h00 : NEXT_R_RA; \n \n      if(W_VSYNC_P) R_V_SYNC <= 1'b1; \n      else if(W_VSYNC_W) R_V_SYNC <= 1'b0; \n \n      if(W_RA_C) \n      begin \n        R_LAST_LINE <= W_VD; \n \n        R_V_CNT <= W_VCNT_RET ? 7'h00 : NEXT_R_V_CNT; \n      end \n    end \n \n    if(W_VCNT_RET)     R_V_DISPTMG <= 1'b1; \n    else if(W_VDISP_N) R_V_DISPTMG <= 1'b0; \n \n    if(W_HD)           R_DISPTMG <= R_V_DISPTMG; \n    else if(W_HDISP_N) R_DISPTMG <= 1'b0; \n  end \nend \n \nendmodule\n",
        "module_name": "crtc6845",
        "module_hash": "d41273836187c6fb002d98ae1aa63ee6",
        "dataset_index": 14648
      },
      "adder_with_overflow_detection_37b879eb": {
        "rtl_code": "module adder_with_overflow_detection (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output reg [3:0] Sum,\n  output reg Cout\n);\n\nalways @(*) begin\n  Sum = A + B + Cin;\n  if (Sum > 15) begin\n    Cout = 1;\n  end else begin\n    Cout = 0;\n  end\nend\n\nendmodule\n",
        "module_name": "adder_with_overflow_detection",
        "module_hash": "37b879ebadd7a9600a555d8622e70be2",
        "dataset_index": 2034
      },
      "Change2Negedge_bfa257e4": {
        "rtl_code": "\nmodule Change2Negedge\n(\n    input wire hsync_in,\n    input wire vsync_in,\n    input wire blnk_in,\n    input wire [23:0] rgb_in,\n    input wire clk,\n    input wire rst,\n    \n    output reg hsync_out,\n    output reg vsync_out,\n    output reg blnk_out,\n    output reg [23:0] rgb_out\n    );\n \n    always @(negedge clk or posedge rst) begin\n        if(rst) begin\n            hsync_out   <= #1 0;\n            vsync_out   <= #1 0;\n            blnk_out    <= #1 0;\n            rgb_out     <= #1 0;\n        end\n        else begin\n            hsync_out   <= #1 hsync_in;\n            vsync_out   <= #1 vsync_in;\n            blnk_out    <= #1 blnk_in;\n            rgb_out     <= #1 rgb_in;\n        end\n    end\n  \nendmodule\n",
        "module_name": "Change2Negedge",
        "module_hash": "bfa257e4d738d221b2b657807d637530",
        "dataset_index": 4363
      },
      "doublencomparator_fff8ccfa": {
        "rtl_code": "\n\nmodule doublencomparator(x0, x1, y0, y1, eqin, gtin, ltin, eqout, gtout, ltout);\n\n\tinput x0, x1, y0, y1;\t\t\t\tinput eqin, gtin, ltin;\t\t\t\toutput eqout, gtout, ltout;\t\tassign eqout = eqin & (x0 ~^ y0) & (x1 ~^ y1);\n\tassign gtout = (gtin | (x0 & ~y0) | (x1 & ~y0 & ~y1) | (x0 & x1 & y0 & ~y1)) & ~ltin;\n\tassign ltout = ltin | ~(eqout | gtout);\n\tendmodule ",
        "module_name": "doublencomparator",
        "module_hash": "fff8ccfaa8d0c35e0aca8e4809a13f13",
        "dataset_index": 22083
      },
      "transmision_621abee6": {
        "rtl_code": "module transmision (input enable, \n                    input wire [7:0] dout,   \n                    output busy,\n                    output reg done,\n                    input wire clk_div, \n                    output reg tx);\n\nparameter count = 8;\n\ninitial begin\n\ttx <= 1'b1;\n    done=0;\nend\n\nparameter STATE_IDLE\t= 2'b00;\nparameter STATE_START\t= 2'b01;\nparameter STATE_DATA\t= 2'b10;\nparameter STATE_STOP\t= 2'b11;\n\nreg [7:0] data = 8'b11111111;\nreg [2:0] bitpos = 0;\nreg [1:0] state = STATE_IDLE;\n\nalways @(posedge clk_div) begin \n        case (state)\n\t        STATE_IDLE: begin\n                done<=0;\n                tx <= 1'b1;\n                if(enable)begin\n\t    \t\t    state <= STATE_START;\n\t    \t\t    data <= dout;\n\t    \t\t    bitpos <= 0;\n                end\n    \t    end\n    \t    STATE_START: begin\n    \t\t\ttx <= 1'b0;\n    \t\t\tstate <= STATE_DATA;\n    \t    end\n    \t    STATE_DATA: begin\n    \t\t\tif (bitpos == count-1)begin\n    \t\t\t\ttx<=data[bitpos]; \n    \t\t\t\tstate <= STATE_STOP;\n    \t\t\tend\n    \t\t\telse begin\n    \t\t\t\ttx<=data[bitpos];\n    \t\t\t\tbitpos <= bitpos + 1;\n    \t\t\tend\n    \t    end\n        \tSTATE_STOP: begin\n    \t\t\ttx <= 1'b1;\n                done<=1;\n    \t\t\tstate <= STATE_IDLE;\n    \t    end\n    \t    default: begin\n    \t\t    tx <= 1'b1;\n    \t    \tstate <= STATE_IDLE;\n    \t    end\n    \tendcase\nend\n\nassign busy = (state != STATE_IDLE);\n\nendmodule\n",
        "module_name": "transmision",
        "module_hash": "621abee677d63626d9b234f6433940d6",
        "dataset_index": 21584
      },
      "arbiter_58ac5e86": {
        "rtl_code": "\n\nmodule arbiter(\n\tinput\t[63:0]\tidat_i,\n\tinput\t[63:0]\tiadr_i,\n\tinput\t\tiwe_i,\n\tinput\t\ticyc_i,\n\tinput\t\tistb_i,\n\tinput\t[1:0]\tisiz_i,\n\tinput\t\tisigned_i,\n\toutput\t\tiack_o,\n\toutput\t[63:0]\tidat_o,\n\n\tinput\t[63:0]\tddat_i,\n\tinput\t[63:0]\tdadr_i,\n\tinput\t\tdwe_i,\n\tinput\t\tdcyc_i,\n\tinput\t\tdstb_i,\n\tinput\t[1:0]\tdsiz_i,\n\tinput\t\tdsigned_i,\n\toutput\t\tdack_o,\n\toutput\t[63:0]\tddat_o,\n\n\toutput\t[63:0]\txdat_o,\n\toutput\t[63:0]\txadr_o,\n\toutput\t\txwe_o,\n\toutput\t\txcyc_o,\n\toutput\t\txstb_o,\n\toutput\t[1:0]\txsiz_o,\n\toutput\t\txsigned_o,\n\tinput\t\txack_i,\n\tinput\t[63:0]\txdat_i,\n\n\tinput\t\tclk_i,\n\tinput\t\treset_i\n);\n\treg reserve_i, reserve_d;\n\n\twire en_i = (~reset_i & icyc_i & ~dcyc_i) |\n\t\t    (~reset_i & icyc_i & dcyc_i & reserve_i & ~reserve_d);\n\n\twire en_d = (~reset_i & ~icyc_i & dcyc_i) |\n\t\t    (~reset_i & icyc_i & dcyc_i & ~reserve_i) |\n\t\t    (~reset_i & icyc_i & dcyc_i & reserve_i & reserve_d);\n\n\tassign xdat_o = (en_i ? idat_i : 64'd0) | (en_d ? ddat_i : 64'd0);\n\tassign xadr_o = (en_i ? iadr_i : 64'd0) | (en_d ? dadr_i : 64'd0);\n\tassign xwe_o = (en_i & iwe_i) | (en_d & dwe_i);\n\tassign xcyc_o = (en_i & icyc_i) | (en_d & dcyc_i);\n\tassign xstb_o = (en_i & istb_i) | (en_d & dstb_i);\n\tassign xsiz_o = (en_i ? isiz_i : 2'd0) | (en_d ? dsiz_i : 2'd0);\n\tassign xsigned_o = (en_i & isigned_i) | (en_d & dsigned_i);\n\n\tassign iack_o = (en_i & xack_i);\n\tassign dack_o = (en_d & xack_i);\n\n\tassign idat_o = (en_i ? xdat_i : 64'd0);\n\tassign ddat_o = (en_d ? xdat_i : 64'd0);\n\n\talways @(posedge clk_i) begin\n\t\treserve_i <= en_i;\n\t\treserve_d <= en_d;\n\tend\nendmodule\n\n",
        "module_name": "arbiter",
        "module_hash": "58ac5e8649e4838a2a2e6970cc6aee18",
        "dataset_index": 25159
      },
      "transition_capture_af2e094e": {
        "rtl_code": "module transition_capture (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_state;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        prev_state <= 0;\n        out <= 0;\n    end else begin\n        prev_state <= in;\n        out <= prev_state & ~in;\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\ntransition_capture tc (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule",
        "module_name": "transition_capture",
        "module_hash": "af2e094e819058fb3b3f2774aa7697f9",
        "dataset_index": 2068
      },
      "wasca_switches_8287db3d": {
        "rtl_code": "module wasca_switches (\n                        // inputs:\n                         address,\n                         clk,\n                         in_port,\n                         reset_n,\n\n                        // outputs:\n                         readdata\n                      )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  2: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  2: 0] data_in;\n  wire    [  2: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {3 {(address == 0)}} & data_in;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "wasca_switches",
        "module_hash": "8287db3d07b3935d16281354bb963617",
        "dataset_index": 12919
      },
      "adder_5c3313e9": {
        "rtl_code": "module adder (\n  // Outputs\n  S,\n  // Inputs\n  A, B, clk\n  );\n  \n  input [7:0] A, B;\n  input clk;\n  output [7:0] S;\n  \n  \n  \n  \n  \n  reg [7:0] S_reg;\n  \n\n  always @(posedge clk) begin\n    S_reg <= A + B;\n  end\n  \n  assign S = S_reg;\n  \nendmodule",
        "module_name": "adder",
        "module_hash": "5c3313e93fb76e7ca765bc67d39c4b36",
        "dataset_index": 18056
      },
      "mux4_ctrl_d7f261fb": {
        "rtl_code": "\nmodule mux4_ctrl(\n    input [7:0] A,\n    input [7:0] B,\n    input [7:0] C,\n    input [7:0] D,\n    input ctrl,\n    output reg [7:0] out\n);\n\nalways @ (A or B or C or D or ctrl) begin\n    case(ctrl)\n        1'b0: out = A;\n        1'b1: out = D;\n        default: out = 0; // out = 8'hZZ; // tri-state output\n    endcase\nend\n\nendmodule",
        "module_name": "mux4_ctrl",
        "module_hash": "d7f261fbd0cfa51f434dd39ac26e32bd",
        "dataset_index": 124
      },
      "des_sbox8_939f28d0": {
        "rtl_code": "\n\n\n\n\nmodule des_sbox8\n\t(\n\tinput  wire [0:5] right_xor_key_segment_din,\n\toutput reg  [0:3] sbox_dout\n\t);\n\n\n\talways @(*)\n\t\tcase ({right_xor_key_segment_din[0], right_xor_key_segment_din[5]})\n\t\t\t2'b00:\t\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd2;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd8;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd11;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd1;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd12;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd7;\n\t\t\t\t\tendcase\n\n\t\t\t2'b01:\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd1;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd8;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd7;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd12;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd11;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd2;\n\t\t\t\t\tendcase\n\n\t\t\t2'b10:\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd7;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd11;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd1;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd12;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd2;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd8;\n\t\t\t\t\tendcase\n\n\t\t\t2'b11:\n\t\t\t\t\tcase (right_xor_key_segment_din[1:4])\n\t\t\t\t\t\t4'd0:\tsbox_dout = 4'd2;\n\t\t\t\t\t\t4'd1:\tsbox_dout = 4'd1;\n\t\t\t\t\t\t4'd2:\tsbox_dout = 4'd14;\n\t\t\t\t\t\t4'd3:\tsbox_dout = 4'd7;\n\t\t\t\t\t\t4'd4:\tsbox_dout = 4'd4;\n\t\t\t\t\t\t4'd5:\tsbox_dout = 4'd10;\n\t\t\t\t\t\t4'd6:\tsbox_dout = 4'd8;\n\t\t\t\t\t\t4'd7:\tsbox_dout = 4'd13;\n\t\t\t\t\t\t4'd8:\tsbox_dout = 4'd15;\n\t\t\t\t\t\t4'd9:\tsbox_dout = 4'd12;\n\t\t\t\t\t\t4'd10:\tsbox_dout = 4'd9;\n\t\t\t\t\t\t4'd11:\tsbox_dout = 4'd0;\n\t\t\t\t\t\t4'd12:\tsbox_dout = 4'd3;\n\t\t\t\t\t\t4'd13:\tsbox_dout = 4'd5;\n\t\t\t\t\t\t4'd14:\tsbox_dout = 4'd6;\n\t\t\t\t\t\t4'd15:\tsbox_dout = 4'd11;\n\t\t\t\t\tendcase\n\t\tendcase endmodule\n\n",
        "module_name": "des_sbox8",
        "module_hash": "939f28d02d638b39c917a5b23469ce65",
        "dataset_index": 22984
      },
      "Peripheral_clk_generator_6d1feefd": {
        "rtl_code": "module Peripheral_clk_generator (clk, rst, d_in, cs, addr, rd, wr, d_out);\n\n    input clk;\n    input rst;\n    input [15:0] d_in;\n    input cs;\n    input [3:0] addr;\n    input rd;\n    input wr;\n    output reg [15:0] d_out;\n\n    reg [5:0] s;\n    reg [31:0] limit;\n    reg [31:0] count;\n    reg en = 0;\n    wire clk_0;\n    wire done;\n\n    always @(*) begin\n        case (addr)\n            4'h0: begin s = (cs && wr) ? 6'b000001 : 6'b000000; end //limit\n            4'h2: begin s = (cs && wr) ? 6'b000010 : 6'b000000; end //count\n            4'h4: begin s = (cs && wr) ? 6'b000100 : 6'b000000; end //en\n            4'h6: begin s = (cs && rd) ? 6'b001000 : 6'b000000; end //done\n            4'h8: begin s = (cs && rd) ? 6'b010000 : 6'b000000; end //clk_0\n            default: begin s = 6'b000000; end\n        endcase\n    end\n\n    always @(negedge clk) begin\n        limit = (s[0]) ? d_in : limit;\n        count = (s[1]) ? d_in : count;\n        en = (s[2]) ? d_in : en;\n    end\n\n    clk_generator c_g (.clk(clk), .rst(rst), .limit(limit), .count(count), .en(en), .clk_0(clk_0), .done(done));\n\n    always @(negedge clk) begin\n        case (s[5:3])\n            3'b001: d_out[0] = done;\n            3'b010: d_out = clk_0;\n            default: d_out = 0;\n        endcase\n    end\n\nendmodule\n\nmodule clk_generator (clk, rst, limit, count, en, clk_0, done);\n\n    input clk;\n    input rst;\n    input [31:0] limit;\n    input [31:0] count;\n    input en;\n    output reg clk_0;\n    output reg done;\n\n    reg [31:0] cnt;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            cnt <= 0;\n            clk_0 <= 0;\n            done <= 1;\n        end else begin\n            if (en) begin\n                if (cnt == limit) begin\n                    cnt <= 0;\n                    clk_0 <= ~clk_0;\n                    done <= 1;\n                end else begin\n                    cnt <= cnt + 1;\n                    done <= 0;\n                end\n            end else begin\n                cnt <= 0;\n                clk_0 <= 0;\n                done <= 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "Peripheral_clk_generator",
        "module_hash": "6d1feefd5bb97032b9de3f2eb6251c9a",
        "dataset_index": 7181
      },
      "sky130_fd_sc_ls__a22o_2_8c4807d9": {
        "rtl_code": "module sky130_fd_sc_ls__a22o_2 (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign X = ((A1 && !A2) || (!B1 && B2) || (!A1 && !A2 && !B1 && !B2) || (A1 && A2 && B1 && B2)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__a22o_2",
        "module_hash": "8c4807d9681c70af3a2838e6da41b710",
        "dataset_index": 10788
      },
      "sky130_fd_sc_hs__o21a_1_45cf15a5": {
        "rtl_code": "\nmodule sky130_fd_sc_hs__o21a_1 (A1, A2, B1, VPWR, VGND, Y);\n  input A1, A2, B1, VPWR, VGND;\n  output Y;\n\n  // Implementation of the module\n\nendmodule\n\nmodule sky130_fd_sc_hs__o21a_2 (A1, A2, B1, VPWR, VGND, Y);\n  input A1, A2, B1, VPWR, VGND;\n  output Y;\n\n  assign Y = (A1 & A2) | B1;\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hs__o21a_1",
        "module_hash": "45cf15a5256c842338b8bb72b6ac9f3f",
        "dataset_index": 14750
      },
      "logic__38c31d76": {
        "rtl_code": "module logic_module (\n    Y,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    // Module ports\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n    input B2;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire nand0_out;\n    wire nand1_out;\n    wire and0_out_Y;\n\n    // Gates\n    nand nand0 (nand0_out, A1, A2, A3);\n    nand nand1 (nand1_out, B1, B2);\n    and and0 (and0_out_Y, nand0_out, nand1_out);\n    buf buf0 (Y, and0_out_Y);\n\nendmodule",
        "module_name": "logic_",
        "module_hash": "38c31d7624329ba79140cdc22a5d5793",
        "dataset_index": 12907
      },
      "top_module_dfbe047f": {
        "rtl_code": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    reg [99:0] shift_reg;\n    reg [2:0] shift_amt;\n    wire [99:0] shifted_data;\n\n    // Barrel shifter\n    assign shifted_data = {shift_reg[shift_amt[2:0]], shift_reg} >> shift_amt;\n\n    // Multiplexer for rotating\n    always @(*) begin\n        case (ena)\n            2'b00: q = shifted_data; // No rotation\n            2'b01: q = {shifted_data[2:0], shifted_data[99:3]}; // Rotate left by 3 bits\n            2'b10: q = {shifted_data[97:0], shifted_data[99:98]}; // Rotate right by 3 bits\n            2'b11: q = shift_reg; // Load\n        endcase\n    end\n\n    // Load data\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n            shift_amt <= 3;\n        end else begin\n            shift_reg <= shifted_data;\n            shift_amt <= ena == 2'b10 ? -3 : 3; // Negative shift amount for right rotation\n        end\n    end\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "dfbe047f82ec541f52190182e7d77f15",
        "dataset_index": 4958
      },
      "top__488c9a8a": {
        "rtl_code": "\nmodule top_module (\n    input wire [2:0] a,\n    input wire [2:0] b,\n    output wire sum_carry_out,\n    output wire [2:0] sum,\n    output wire carry_out,\n    output wire [5:0] sum_decimal\n);\n\n    // Splitting the input numbers into separate 1-bit binary numbers\n    wire [2:0] a_1, b_1;\n    splitter splitter_inst(.in_a(a), .in_b(b), .out_a(a_1), .out_b(b_1));\n\n    // Adding the two 3-bit binary numbers using a half adder\n    wire [2:0] sum_half_adder;\n    wire carry_out_half_adder;\n    half_adder half_adder_inst1(.a(a_1[0]), .b(b_1[0]), .sum(sum_half_adder[0]), .carry_out(carry_out_half_adder));\n    half_adder half_adder_inst2(.a(a_1[1]), .b(b_1[1]), .sum(sum_half_adder[1]), .carry_out());\n    half_adder half_adder_inst3(.a(a_1[2]), .b(b_1[2]), .sum(sum_half_adder[2]), .carry_out(carry_out));\n\n    // Combining the separate 1-bit binary numbers of the sum using the same logic circuit as in problem 1\n    wire [5:0] sum_decimal_logic_circuit;\n    logic_circuit logic_circuit_inst(.in(sum_half_adder), .out(sum_decimal_logic_circuit));\n\n    // Outputting the sum and carry-out of the addition as well as the separate 1-bit binary numbers of the sum\n    assign sum = sum_half_adder;\n    assign sum_carry_out = {carry_out_half_adder, sum_half_adder};\n    assign sum_decimal = sum_decimal_logic_circuit;\n\nendmodule\nmodule splitter (\n    input wire [2:0] in_a,\n    input wire [2:0] in_b,\n    output wire [2:0] out_a,\n    output wire [2:0] out_b\n);\n\n    assign out_a = in_a;\n    assign out_b = in_b;\n\nendmodule\nmodule half_adder (\n    input wire a,\n    input wire b,\n    output wire sum,\n    output wire carry_out\n);\n\n    assign {carry_out, sum} = a + b;\n\nendmodule\nmodule logic_circuit (\n    input wire [2:0] in,\n    output wire [5:0] out\n);\n\n    assign out = in;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "488c9a8a5af9c917c58808381ab18f4a",
        "dataset_index": 8047
      },
      "sky130_fd_sc_ms__and4bb_538a6f81": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__and4bb (\n    X  ,\n    A_N,\n    B_N,\n    C  ,\n    D\n);\n\n    output X  ;\n    input  A_N;\n    input  B_N;\n    input  C  ;\n    input  D  ;\n\n    wire nor0_out  ;\n    wire and0_out_X;\n\n    nor nor0 (nor0_out  , A_N, B_N       );\n    and and0 (and0_out_X, nor0_out, C, D );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__and4bb",
        "module_hash": "538a6f81ddbc4e31e0e102350365b683",
        "dataset_index": 19927
      },
      "eth_rxcounters_b847ce9f": {
        "rtl_code": "\nmodule eth_rxcounters (\n  input MRxClk,\n  input Reset,\n  input MRxDV,\n  input StateIdle,\n  input StateSFD,\n  input [1:0] StateData,\n  input StateDrop,\n  input StatePreamble,\n  input MRxDEqD,\n  input DlyCrcEn,\n  input HugEn,\n  input [15:0] MaxFL,\n  input r_IFG,\n  output IFGCounterEq24,\n  output [3:0] DlyCrcCnt,\n  output ByteCntEq0,\n  output ByteCntEq1,\n  output ByteCntEq2,\n  output ByteCntEq3,\n  output ByteCntEq4,\n  output ByteCntEq5,\n  output ByteCntEq6,\n  output ByteCntEq7,\n  output ByteCntGreat2,\n  output ByteCntSmall7,\n  output ByteCntMaxFrame,\n  output [15:0] ByteCntOut\n);\n\n  parameter Tp = 1;\n  \n  wire ResetByteCounter;\n  wire IncrementByteCounter;\n  wire ResetIFGCounter;\n  wire IncrementIFGCounter;\n  wire ByteCntMax;\n  \n  reg [15:0] ByteCnt;\n  reg [3:0] DlyCrcCnt;\n  reg [4:0] IFGCounter;\n  \n  wire [15:0] ByteCntDelayed;\n  wire Transmitting;\n  \n  assign ResetByteCounter = MRxDV & (StateSFD & MRxDEqD | StateData[0] & ByteCntMaxFrame);\n  assign IncrementByteCounter = ~ResetByteCounter & MRxDV & \n                                (StatePreamble | StateSFD | StateIdle & ~Transmitting |\n                                 StateData[1] & ~ByteCntMax & ~(DlyCrcEn & DlyCrcCnt)\n                                );\n  always @ (posedge MRxClk or posedge Reset) begin\n    if (Reset) ByteCnt[15:0] <= #Tp 16'h0;\n    else begin\n      if (ResetByteCounter) ByteCnt[15:0] <= #Tp 16'h0;\n      else if (IncrementByteCounter) ByteCnt[15:0] <= #Tp ByteCnt[15:0] + 1'b1;\n    end\n  end\n  \n  assign ByteCntDelayed = ByteCnt + 3'h4;\n  assign ByteCntOut = DlyCrcEn ? ByteCntDelayed : ByteCnt;\n  \n  assign ByteCntEq0 = ByteCnt == 16'h0;\n  assign ByteCntEq1 = ByteCnt == 16'h1;\n  assign ByteCntEq2 = ByteCnt == 16'h2;\n  assign ByteCntEq3 = ByteCnt == 16'h3;\n  assign ByteCntEq4 = ByteCnt == 16'h4;\n  assign ByteCntEq5 = ByteCnt == 16'h5;\n  assign ByteCntEq6 = ByteCnt == 16'h6;\n  assign ByteCntEq7 = ByteCnt == 16'h7;\n  assign ByteCntGreat2 = ByteCnt > 16'h2;\n  assign ByteCntSmall7 = ByteCnt < 16'h7;\n  assign ByteCntMax = ByteCnt == 16'hffff;\n  assign ByteCntMaxFrame = ByteCnt == MaxFL[15:0] & ~HugEn;\n  \n  assign ResetIFGCounter = StateSFD & MRxDV & MRxDEqD | StateDrop;\n  assign IncrementIFGCounter = ~ResetIFGCounter & (StateDrop | StateIdle | StatePreamble | StateSFD) & ~IFGCounterEq24;\n  always @ (posedge MRxClk or posedge Reset) begin\n    if (Reset) IFGCounter[4:0] <= #Tp 5'h0;\n    else begin\n      if (ResetIFGCounter) IFGCounter[4:0] <= #Tp 5'h0;\n      else if (IncrementIFGCounter) IFGCounter[4:0] <= #Tp IFGCounter[4:0] + 1'b1;\n    end\n  end\n  \n  assign IFGCounterEq24 = (IFGCounter[4:0] == 5'h18) | r_IFG;\n  \n  always @ (posedge MRxClk or posedge Reset) begin\n    if (Reset) DlyCrcCnt[3:0] <= #Tp 4'h0;\n    else begin\n      if (DlyCrcCnt[3:0] == 4'h9) DlyCrcCnt[3:0] <= #Tp 4'h0;\n      else if (DlyCrcEn & StateSFD) DlyCrcCnt[3:0] <= #Tp 4'h1;\n      else if (DlyCrcEn & (|DlyCrcCnt[3:0])) DlyCrcCnt[3:0] <= #Tp DlyCrcCnt[3:0] + 1'b1;\n    end\n  end\n  \n  assign Transmitting = ((StateData[0]) & (ByteCntGreat2)) | ((StateData[1]) & (ByteCntSmall7));\nendmodule",
        "module_name": "eth_rxcounters",
        "module_hash": "b847ce9fa7a41eb7ea696009249c7771",
        "dataset_index": 9154
      },
      "clock_divider_eb7d209e": {
        "rtl_code": "\nmodule clock_divider (\n  input clk,\n  input reset,\n  output reg locked,\n  output reg clk_out1,\n  output reg clk_out2,\n  output reg clk_out3\n);\n\n  reg [23:0] count = 0;\n  reg [23:0] limit1 = 24'd10_000_000;\n  reg [23:0] limit2 = 24'd5_000_000;\n  reg [23:0] limit3 = 24'd2_500_000;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 0;\n      clk_out1 <= 0;\n      locked <= 0;\n    end else begin\n      count <= count + 1;\n      if (count == limit1) begin\n        clk_out1 <= ~clk_out1;\n      end\n      if (count == limit2) begin\n        clk_out2 <= ~clk_out2;\n      end\n      if (count == limit3) begin\n        clk_out3 <= ~clk_out3;\n      end\n      if (count == 0) begin\n        locked <= 1;\n      end else if (count == limit1/2) begin\n        locked <= (clk_out1 == clk);\n      end else if (count == limit2/2) begin\n        locked <= (clk_out2 == clk);\n      end else if (count == limit3/2) begin\n        locked <= (clk_out3 == clk);\n      end\n    end\n  end\n\nendmodule",
        "module_name": "clock_divider",
        "module_hash": "eb7d209ea9bcbf52185c977302d36a79",
        "dataset_index": 20510
      },
      "mig_7series_v4_0_poc_tap_base #_bdba1a35": {
        "rtl_code": "\n\nmodule mig_7series_v4_0_poc_tap_base #\n  (parameter MMCM_SAMP_WAIT             = 10,\n   parameter POC_USE_METASTABLE_SAMP    = \"FALSE\",\n   parameter TCQ                        = 100,\n   parameter SAMPCNTRWIDTH              = 8,\n   parameter SMWIDTH                    = 2,\n   parameter TAPCNTRWIDTH               = 7,\n   parameter TAPSPERKCLK                = 112)\n  (\n  psincdec, psen, run, run_end, run_too_small, run_polarity,\n  samp_cntr, samps_hi, samps_hi_held, tap, sm, samps_zero, samps_one,\n  pd_out, clk, samples, samps_solid_thresh, psdone, rst,\n  poc_sample_pd\n  );\n\n  \n  function integer clogb2 (input integer size); begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction input pd_out;\n  input clk;\n  input [SAMPCNTRWIDTH:0] samples, samps_solid_thresh;\n  input psdone;\n  input rst;\n\n  localparam ONE = 1;\n\n  localparam SAMP_WAIT_WIDTH = clogb2(MMCM_SAMP_WAIT);\n  reg [SAMP_WAIT_WIDTH-1:0] samp_wait_ns, samp_wait_r;\n  always @(posedge clk) samp_wait_r <= #TCQ samp_wait_ns;\n\n  reg pd_out_r;\n  always @(posedge clk) pd_out_r <= #TCQ pd_out;\n  wire pd_out_sel = POC_USE_METASTABLE_SAMP == \"TRUE\" ? pd_out_r : pd_out;\n\n  output psincdec;\n  assign psincdec = 1'b1;\n  output psen;\n  reg psen_int;\n  assign psen = psen_int;\n \n  reg [TAPCNTRWIDTH-1:0] run_r;\n   reg [TAPCNTRWIDTH-1:0] run_ns;\n  always @(posedge clk) run_r <= #TCQ run_ns;\n  output [TAPCNTRWIDTH-1:0] run;\n  assign run = run_r;\n\n  output run_end;\n  reg run_end_int;\n  assign run_end = run_end_int;\n\n  output run_too_small;\n  reg run_too_small_r, run_too_small_ns;\n  always @(*) run_too_small_ns = run_end && (run <  TAPSPERKCLK/4);\n  always @(posedge clk) run_too_small_r <= #TCQ run_too_small_ns;\n  assign run_too_small = run_too_small_r;\n  \n  reg run_polarity_r;\n  reg run_polarity_ns;\n  always @(posedge clk) run_polarity_r <= #TCQ run_polarity_ns;\n  output run_polarity;\n  assign run_polarity = run_polarity_r;\n\n  reg [SAMPCNTRWIDTH-1:0] samp_cntr_r;\n  reg [SAMPCNTRWIDTH-1:0] samp_cntr_ns;\n  always @(posedge clk) samp_cntr_r <= #TCQ samp_cntr_ns;\n  output [SAMPCNTRWIDTH-1:0] samp_cntr;\n  assign samp_cntr = samp_cntr_r;\n\n  reg [SAMPCNTRWIDTH:0] samps_hi_r;\n  reg [SAMPCNTRWIDTH:0] samps_hi_ns;\n  always @(posedge clk) samps_hi_r <= #TCQ samps_hi_ns;\n  output [SAMPCNTRWIDTH:0] samps_hi;\n  assign samps_hi = samps_hi_r;\n\n  reg [SAMPCNTRWIDTH:0] samps_hi_held_r;\n  reg [SAMPCNTRWIDTH:0] samps_hi_held_ns;\n  always @(posedge clk) samps_hi_held_r <= #TCQ samps_hi_held_ns;\n  output [SAMPCNTRWIDTH:0] samps_hi_held;\n  assign samps_hi_held = samps_hi_held_r;\n\n  reg [TAPCNTRWIDTH-1:0] tap_ns, tap_r;\n  always @(posedge clk) tap_r <= #TCQ tap_ns;\n  output [TAPCNTRWIDTH-1:0] tap;\n  assign tap = tap_r;\n  \n  reg [SMWIDTH-1:0] sm_ns;\n  reg [SMWIDTH-1:0] sm_r;\n  always @(posedge clk) sm_r <= #TCQ sm_ns;\n  output [SMWIDTH-1:0] sm;\n  assign sm = sm_r;\n\n  reg samps_zero_ns, samps_zero_r, samps_one_ns, samps_one_r;\n  always @(posedge clk) samps_zero_r <= #TCQ samps_zero_ns;\n  always @(posedge clk) samps_one_r <= #TCQ samps_one_ns;\n  output samps_zero, samps_one;\n  assign samps_zero = samps_zero_r;\n  assign samps_one = samps_one_r;\n\n  wire [SAMPCNTRWIDTH:0] samps_lo = samples + ONE[SAMPCNTRWIDTH:0] - samps_hi_r;\n  always @(*) begin\n    samps_zero_ns = samps_zero_r;\n    samps_one_ns = samps_one_r;\n    samps_zero_ns = samps_lo >= samps_solid_thresh;\n    samps_one_ns = samps_hi_r >= samps_solid_thresh;\n  end wire new_polarity = run_polarity_ns ^ run_polarity_r;\n\n  input poc_sample_pd;\n\n  always @(*) begin\n    \n    if (rst == 1'b1) begin\n      \n psen_int = 1'b0;\n      sm_ns = 2'd0;\n      run_polarity_ns = 1'b0;\n      run_ns = {TAPCNTRWIDTH{1'b0}};\n      run_end_int = 1'b0;\n      samp_cntr_ns = {SAMPCNTRWIDTH{1'b0}};\n      samps_hi_ns = {SAMPCNTRWIDTH+1{1'b0}};\n      tap_ns = {TAPCNTRWIDTH{1'b0}};\n      samp_wait_ns = MMCM_SAMP_WAIT[SAMP_WAIT_WIDTH-1:0];\n      samps_hi_held_ns = {SAMPCNTRWIDTH+1{1'b0}};\n    end else begin\n\n psen_int = 1'b0;\n      sm_ns = sm_r;\n      run_polarity_ns = run_polarity_r;\n      run_ns = run_r;\n      run_end_int = 1'b0;\n      samp_cntr_ns = samp_cntr_r;\n      samps_hi_ns = samps_hi_r;\n      tap_ns = tap_r;\n      samp_wait_ns = samp_wait_r;\n      if (|samp_wait_r) samp_wait_ns = samp_wait_r - ONE[SAMP_WAIT_WIDTH-1:0];\n      samps_hi_held_ns = samps_hi_held_r;\n\ncase (sm_r)\n        2'd0: begin\n\t  if (~|samp_wait_r && poc_sample_pd | POC_USE_METASTABLE_SAMP == \"TRUE\") begin\n\t    if (POC_USE_METASTABLE_SAMP == \"TRUE\") samp_wait_ns = ONE[SAMP_WAIT_WIDTH-1:0];\n\t    if ({1'b0, samp_cntr_r} == samples) sm_ns = 2'd1;\n\t    samps_hi_ns = samps_hi_r + {{SAMPCNTRWIDTH{1'b0}}, pd_out_sel};\n\t    samp_cntr_ns = samp_cntr_r + ONE[SAMPCNTRWIDTH-1:0];\n\t  end\n        end\n\t\n\t2'd1:begin\n\t   sm_ns = 2'd2;\n        end\n\n        2'd2:begin\n\t  sm_ns = 2'd3;\n\t  psen_int = 1'b1;\n\t  samp_cntr_ns = {SAMPCNTRWIDTH{1'b0}};\n\t  samps_hi_ns = {SAMPCNTRWIDTH+1{1'b0}};\n\t  samps_hi_held_ns = samps_hi_r;\n\t  tap_ns = (tap_r < TAPSPERKCLK[TAPCNTRWIDTH-1:0] - ONE[TAPCNTRWIDTH-1:0])\n\t             ? tap_r + ONE[TAPCNTRWIDTH-1:0]\n\t\t     : {TAPCNTRWIDTH{1'b0}};\n\n\t  if (run_polarity_r) begin\n\t    if (samps_zero_r) run_polarity_ns = 1'b0;\n\t  end else begin\n\t    if (samps_one_r) run_polarity_ns = 1'b1;\n\t  end\n\t  if (new_polarity) begin\n            run_ns ={TAPCNTRWIDTH{1'b0}};\n\t    run_end_int = 1'b1;\n\t  end else run_ns = run_r + ONE[TAPCNTRWIDTH-1:0];\n        end\n\n        2'd3:begin\n\t  samp_wait_ns = MMCM_SAMP_WAIT[SAMP_WAIT_WIDTH-1:0] - ONE[SAMP_WAIT_WIDTH-1:0];\n\t  if (psdone) sm_ns = 2'd0;\n        end\n\t\n      endcase end end endmodule ",
        "module_name": "mig_7series_v4_0_poc_tap_base #",
        "module_hash": "bdba1a35b452e27557107f5b83c140a1",
        "dataset_index": 25422
      },
      "core_if_id_6cb2925b": {
        "rtl_code": "module     core_if_id(clk,\n                       rst,\n                      if_id_we,\n                       if_flush,\n                       pc_plus_4,\n                       inst_word,\n                       pc,\n                       pred_target,\n                       delayed_PHT,\n                       delayed_BHR,\n                       btb_type,\n                       btb_v,\n                       pc_plus_4_out,\n                       inst_word_out,\n                       pc_out,\n                       pred_target_out,\n                       delayed_PHT_out,\n                       delayed_BHR_out,\n                       btb_type_out,\n                       btb_v_out\n                       );\ninput        clk;\ninput        rst;\ninput [31:0] pc_plus_4;\ninput [31:0] inst_word;\ninput [31:0] pc;\ninput [31:0] pred_target;\ninput [1:0]  delayed_PHT;\ninput [2:0]  delayed_BHR;\ninput [1:0]  btb_type;\ninput        btb_v;\ninput        if_id_we;\ninput        if_flush;\n\noutput [31:0] pc_plus_4_out;\noutput [31:0] inst_word_out;\noutput [31:0] pc_out;\noutput [31:0] pred_target_out;\noutput [1:0]  delayed_PHT_out;\noutput [2:0]  delayed_BHR_out;\noutput [1:0]  btb_type_out;\noutput        btb_v_out;\n\nreg  [31:0]  inst_word_out;\nreg  [31:0]  pc_plus_4_out;\nreg  [31:0]  pc_out;\nreg  [31:0]  pred_target_out;\nreg  [1:0]   delayed_PHT_out;\nreg  [2:0]   delayed_BHR_out;\nreg  [1:0]   btb_type_out;\nreg          btb_v_out;\nalways@(posedge clk)\nbegin\n  if(rst||if_flush)\n    begin\n      pc_plus_4_out<=32'h0000;\n      inst_word_out<=32'h0000;\n      pc_out<=32'h0000;\n      pred_target_out<=32'h0000;\n      delayed_PHT_out<=2'b00;\n      delayed_BHR_out<=3'b000;\n      btb_type_out<=2'b00;\n      btb_v_out<=1'b0;\n    end\n    else if(if_id_we)\n      begin\n        pc_plus_4_out<=pc_plus_4;\n        inst_word_out<=inst_word;\n        pc_out<=pc;\n        pred_target_out<=pred_target;\n        delayed_PHT_out<=delayed_PHT;\n        delayed_BHR_out<=delayed_BHR;\n        btb_type_out<=btb_type;\n        btb_v_out<=btb_v;\n      end\nend\nendmodule\n\n",
        "module_name": "core_if_id",
        "module_hash": "6cb2925b107628b4ca1aad3bbf030c1b",
        "dataset_index": 9716
      },
      "top__3f756e8a": {
        "rtl_code": "\nmodule top_module (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] shift_amount,\n    output [15:0] result\n);\n\n    wire A_greater_B;\n    magnitude_comparator mag_comp(A, B, A_greater_B);\n    barrel_shifter barrel_shift(A, B, shift_amount, A_greater_B, result);\n\nendmodule\n\nmodule magnitude_comparator (\n    input [15:0] A,\n    input [15:0] B,\n    output reg A_greater_B\n);\n\n    always @* begin\n        if (A > B)\n            A_greater_B = 1;\n        else\n            A_greater_B = 0;\n    end\n\nendmodule\n\nmodule barrel_shifter (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] shift_amount,\n    input A_greater_B,\n    output reg [15:0] result\n);\n\n    always @* begin\n        if (A_greater_B)\n            result = A << shift_amount;\n        else if (A < B)\n            result = B >> shift_amount;\n        else\n            result = A;\n    end\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "3f756e8a0c7dbb4952e32cd8a9680fd3",
        "dataset_index": 19215
      },
      "rx_dsp_model_86f23b4d": {
        "rtl_code": "module rx_dsp_model\n(\n  input clk,\n  input reset,\n  input run,\n  input [7:0] decim,\n  output strobe,\n  output reg [31:0] sample\n);\n\n  reg [15:0] pktnum = 0;\n  reg [15:0] counter = 0;\n  reg run_d1;\n\n  always @(posedge clk)\n    run_d1 <= run;\n\n  always @(posedge clk)\n  begin\n    if(run & ~run_d1)\n    begin\n      counter <= 0;\n      pktnum <= pktnum + 1;\n    end\n    else if(run & strobe)\n    begin\n      counter <= counter + 1;\n    end\n  end\n\n  always @(posedge clk)\n  begin\n    if(reset)\n      sample <= 32'h0;\n    else\n      sample <= {pktnum, counter};\n  end\n\n  reg [7:0] stb_ctr = 0;\n\n  always @(posedge clk)\n  begin\n    if(reset)\n      stb_ctr <= 0;\n    else if(run & ~run_d1)\n      stb_ctr <= 1;\n    else if(run)\n    begin\n      if(stb_ctr == decim - 1)\n        stb_ctr <= 0;\n      else\n        stb_ctr <= stb_ctr + 1;\n    end\n  end\n\n  assign strobe = stb_ctr == decim - 1;\n\nendmodule",
        "module_name": "rx_dsp_model",
        "module_hash": "86f23b4d46925984295394a4267bbf32",
        "dataset_index": 5761
      },
      "axi_dwidth_converter_v2_1_b_downsizer #_d9271871": {
        "rtl_code": "\n\n \nmodule axi_dwidth_converter_v2_1_b_downsizer #\n  (\n   parameter         C_FAMILY                         = \"none\", \n                       parameter integer C_AXI_ID_WIDTH                   = 1\n                       )\n  (\n   input  wire                                                    ARESET,\n   input  wire                                                    ACLK,\n\n   input  wire                              cmd_valid,\n   input  wire                              cmd_split,\n   input  wire [8-1:0]                      cmd_repeat,\n   output wire                              cmd_ready,\n   input  wire [C_AXI_ID_WIDTH-1:0]         cmd_id,\n   \n   output wire [C_AXI_ID_WIDTH-1:0]           S_AXI_BID,\n   output wire [2-1:0]                          S_AXI_BRESP,\n   output wire                                                    S_AXI_BVALID,\n   input  wire                                                    S_AXI_BREADY,\n\n   input  wire [2-1:0]                         M_AXI_BRESP,\n   input  wire                                                   M_AXI_BVALID,\n   output wire                                                   M_AXI_BREADY\n   );\n  \n  \n  localparam [2-1:0] C_RESP_OKAY        = 2'b00;\n  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;\n  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;\n  localparam [2-1:0] C_RESP_DECERR      = 2'b11;\n  \n  \n  wire                            cmd_ready_i;\n  wire                            pop_mi_data;\n  wire                            mi_stalling;\n  \n  reg  [8-1:0]                    repeat_cnt_pre;\n  reg  [8-1:0]                    repeat_cnt;\n  wire [8-1:0]                    next_repeat_cnt;\n  reg                             first_mi_word;\n  wire                            last_word;\n  \n  wire                            load_bresp;\n  wire                            need_to_update_bresp;\n  reg  [2-1:0]                    S_AXI_BRESP_ACC;\n  \n  wire                            M_AXI_BREADY_I;\n  \n  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_BID_I;\n  reg  [2-1:0]                    S_AXI_BRESP_I;\n  wire                            S_AXI_BVALID_I;\n  wire                            S_AXI_BREADY_I;\n  \n  \n  assign M_AXI_BREADY_I = ~mi_stalling;\n  assign M_AXI_BREADY   = M_AXI_BREADY_I;\n  \n  assign S_AXI_BVALID_I = M_AXI_BVALID & last_word;\n  \n  assign pop_mi_data    = M_AXI_BVALID & M_AXI_BREADY_I;\n  \n  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;\n  assign cmd_ready      = cmd_ready_i;\n  \n  assign mi_stalling    = (~S_AXI_BREADY_I & last_word);\n                          \n  \n  assign load_bresp           = (cmd_split & first_mi_word);\n  \n  assign need_to_update_bresp = ( M_AXI_BRESP > S_AXI_BRESP_ACC );\n  \n  always @ *\n  begin\n    if ( cmd_split ) begin\n      if ( load_bresp || need_to_update_bresp ) begin\n        S_AXI_BRESP_I = M_AXI_BRESP;\n      end else begin\n        S_AXI_BRESP_I = S_AXI_BRESP_ACC;\n      end\n    end else begin\n      S_AXI_BRESP_I = M_AXI_BRESP;\n    end\n  end\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      S_AXI_BRESP_ACC <= C_RESP_OKAY;\n    end else begin\n      if ( pop_mi_data ) begin\n        S_AXI_BRESP_ACC <= S_AXI_BRESP_I;\n      end\n    end\n  end\n  \n  \n  assign last_word  = ( ( repeat_cnt == 8'b0 ) & ~first_mi_word ) | \n                      ~cmd_split;\n  \n  always @ *\n  begin\n    if ( first_mi_word ) begin\n      repeat_cnt_pre  =  cmd_repeat;\n    end else begin\n      repeat_cnt_pre  =  repeat_cnt;\n    end\n  end\n  \n  assign next_repeat_cnt  = repeat_cnt_pre - 2'b01;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      repeat_cnt    <= 8'b0;\n      first_mi_word <= 1'b1;\n    end else begin\n      if ( pop_mi_data ) begin\n        repeat_cnt    <= next_repeat_cnt;\n        first_mi_word <= last_word;\n      end\n    end\n  end\n  \n  \n  assign S_AXI_BID_I  = cmd_id;\n  \n    assign S_AXI_BID      = S_AXI_BID_I;\n  assign S_AXI_BRESP    = S_AXI_BRESP_I;\n  assign S_AXI_BVALID   = S_AXI_BVALID_I;\n  assign S_AXI_BREADY_I = S_AXI_BREADY;\n  \n  \nendmodule\n",
        "module_name": "axi_dwidth_converter_v2_1_b_downsizer #",
        "module_hash": "d92718719a8159b5f8d70284d220ad49",
        "dataset_index": 25476
      },
      "vga_controller_32719864": {
        "rtl_code": "module vga_controller(\n    input vclock,\n    output reg [10:0] hcount,\n    output reg [9:0] vcount,\n    output reg vsync,\n    output reg hsync,\n    output reg blank\n);\n\n    // horizontal: 1056 pixels total\n    // display 800 pixels per line\n    reg hblank;\n    wire hblankon, hsyncon, hsyncoff, hreset;\n    assign hblankon = (hcount == 799);\n    assign hsyncon = (hcount == 839);\n    assign hsyncoff = (hcount == 967);\n    assign hreset = (hcount == 1055);\n\n    // vertical: 628 lines total\n    // display 600 lines\n    reg vblank;\n    wire vblankon, vsyncon, vsyncoff, vreset;\n    assign vblankon = hreset & (vcount == 599);\n    assign vsyncon = hreset & (vcount == 600);\n    assign vsyncoff = hreset & (vcount == 604);\n    assign vreset = hreset & (vcount == 627);\n\n    // sync and blanking\n    wire next_hblank, next_vblank;\n    assign next_hblank = hreset ? 0 : hblankon ? 1 : hblank;\n    assign next_vblank = vreset ? 0 : vblankon ? 1 : vblank;\n    always @(posedge vclock) begin\n        hcount <= hreset ? 0 : hcount + 1;\n        hblank <= next_hblank;\n        hsync <= hsyncon ? 0 : hsyncoff ? 1 : hsync;  // active low\n\n        vcount <= hreset ? (vreset ? 0 : vcount + 1) : vcount;\n        vblank <= next_vblank;\n        vsync <= vsyncon ? 0 : vsyncoff ? 1 : vsync;  // active low\n\n        blank <= next_vblank | (next_hblank & ~hreset);\n    end\nendmodule",
        "module_name": "vga_controller",
        "module_hash": "327198649c9e4c710388b0f9e5003524",
        "dataset_index": 13097
      },
      "fpu_denorm_3to1_acd9f304": {
        "rtl_code": "module fpu_denorm_3to1 (\n\tdin2_din1_nz_hi,\n\tdin2_din1_denorm_hi,\n\tdin2_din1_nz_mid,\n\tdin2_din1_denorm_mid,\n\tdin2_din1_nz_lo,\n\tdin2_din1_denorm_lo,\n\n\tdin2_din1_nz,\n\tdin2_din1_denorm\n);\n\ninput\t\tdin2_din1_nz_hi;\t// input 1 and input 2 != 0- high 3 bits\ninput\t\tdin2_din1_denorm_hi;\t// input 1 == denorm- high 3 bits\ninput\t\tdin2_din1_nz_mid;\t// input 1 and input 2 != 0- mid 3 bits\ninput\t\tdin2_din1_denorm_mid;\t// input 1 == denorm- mid 3 bits\ninput\t\tdin2_din1_nz_lo;\t// input 1 and input 2 != 0- low 3 bits\ninput\t\tdin2_din1_denorm_lo;\t// input 1 == denorm- low 3 bits\n\noutput\t\tdin2_din1_nz;\t\t// input 1 and input 2 != 0\noutput\t\tdin2_din1_denorm;\t// input 1 == denorm\n\nwire\t\tdin2_din1_nz;\nwire\t\tdin2_din1_denorm;\n\nassign din2_din1_nz= din2_din1_nz_hi || din2_din1_nz_mid || din2_din1_nz_lo;\n\nassign din2_din1_denorm= (din2_din1_nz_hi && din2_din1_denorm_hi) || ((!din2_din1_nz_hi) && din2_din1_nz_mid && din2_din1_denorm_mid) || ((!din2_din1_nz_hi) && (!din2_din1_nz_mid) && din2_din1_denorm_lo);\n\nendmodule",
        "module_name": "fpu_denorm_3to1",
        "module_hash": "acd9f304b43325d729f35b08e2084262",
        "dataset_index": 17041
      },
      "simple_encryption_8174c752": {
        "rtl_code": "module simple_encryption(\n  input clk,\n  input rst,\n  input [15:0] data_in,\n  input [7:0] key,\n  input encrypt,\n  output reg [15:0] data_out\n);\n\nreg [7:0] A;\nreg [7:0] B;\nreg [7:0] temp;\n\nalways @(posedge clk or negedge rst) begin\n  if (!rst) begin\n    A <= 8'h00;\n    B <= 8'h00;\n  end else begin\n    if (encrypt) begin // encryption mode\n      A <= data_in[15:8];\n      B <= data_in[7:0];\n      temp <= A;\n      A <= (A << 3) ^ B ^ key;\n      B <= (B >> 2) ^ temp ^ key;\n      temp <= A;\n      A <= B;\n      B <= temp;\n      data_out <= {A, B};\n    end else begin // decryption mode\n      A <= data_in[7:0];\n      B <= data_in[15:8];\n      temp <= B;\n      B <= (B ^ key) << 2 | (A ^ temp ^ key) >> 6;\n      A <= (A ^ key) >> 3 | (B ^ temp ^ key) << 5;\n      temp <= A;\n      A <= B;\n      B <= temp;\n      data_out <= {B, A};\n    end\n  end\nend\n\nendmodule",
        "module_name": "simple_encryption",
        "module_hash": "8174c752551795901185f3452fb786fa",
        "dataset_index": 3685
      },
      "Test_e9ef1b43": {
        "rtl_code": "module Test (\n  input clk,\n  input [7:0] operand_a,\n  input [7:0] operand_b,\n  output reg [6:0] out\n);\n\nalways @(posedge clk) begin\n  out <= operand_a + operand_b;\nend\n\nendmodule",
        "module_name": "Test",
        "module_hash": "e9ef1b43f0345233ce9fa6a8861b6330",
        "dataset_index": 7084
      },
      "adder4bit_f40c82a3": {
        "rtl_code": "\nmodule adder4bit (A, B, Ci, S, Co);\n  input [3:0] A, B;\n  input Ci;\n  output [3:0] S;\n  output Co;\n\n  wire [3:0] c;\n  wire [3:0] x;\n  wire [3:0] y;\n\n  // Full adder for the least significant bit\n  full_adder FA0 (.a(A[0]), .b(B[0]), .ci(Ci), .s(S[0]), .co(c[0]));\n\n  // Full adders for the remaining bits\n  genvar i;\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(B[i]), .ci(c[i-1]), .s(S[i]), .co(c[i]));\n    end\n  endgenerate\n\n  // Invert carry out to get Co\n  assign Co = ~c[3];\n\n  // Invert B to get 2's complement\n  assign y = ~B;\n  assign y[0] = y[0] ^ 1'b1;\n\n  // Add inverted B to A\n  full_adder FA1 (.a(A[0]), .b(y[0]), .ci(Ci), .s(x[0]), .co());\n  generate\n    for (i = 1; i < 4; i = i + 1) begin\n      full_adder FA (.a(A[i]), .b(y[i]), .ci(c[i-1]), .s(x[i]), .co());\n    end\n  endgenerate\nendmodule\nmodule full_adder (a, b, ci, s, co);\n  input a, b, ci;\n  output s, co;\n\n  wire x1, x2, x3;\n\n  // First XOR gate\n  assign x1 = a ^ b;\n\n  // Second XOR gate\n  assign s = x1 ^ ci;\n\n  // AND gate\n  assign x2 = a & b;\n\n  // Third XOR gate\n  assign x3 = x1 & ci;\n\n  // OR gate\n  assign co = x2 | x3;\nendmodule",
        "module_name": "adder4bit",
        "module_hash": "f40c82a354bbdb0d00078529b6a013dc",
        "dataset_index": 8501
      },
      "add8_48b698c2": {
        "rtl_code": "\nmodule add8 (\n    input [7:0] A,\n    input [7:0] B,\n    input signed_unsigned,\n    output [7:0] sum,\n    output carry_out\n);\n\n    wire [8:0] temp_sum;\n    assign temp_sum = A + B + {1'b0, signed_unsigned};\n    assign {carry_out, sum} = temp_sum;\n\nendmodule",
        "module_name": "add8",
        "module_hash": "48b698c260568a2a762f5c970ba71593",
        "dataset_index": 11042
      },
      "adder_5316ba33": {
        "rtl_code": "\nmodule adder(A, B, C, CO);\n  input [3:0] A, B;\n  output [3:0] C;\n  output CO;\n\n  wire [4:0] sum;  // Changed from [3:0] to [4:0] to accommodate the carry-out bit\n\n  assign sum = A + B;\n  assign C = sum[3:0];\n  assign CO = sum[4];\n\nendmodule",
        "module_name": "adder",
        "module_hash": "5316ba33760bf1400f2460293f1c3c11",
        "dataset_index": 10395
      },
      "top_module_ea29f5fb": {
        "rtl_code": "module top_module(\n    input a,\n    input b,\n    input c,\n    input d,\n    output reg out_func\n);\n\nreg xor1_out, xor2_out;\n\nalways @(*) begin\n    xor1_out = a ^ b;\nend\n\nalways @(*) begin\n    xor2_out = c ^ d;\nend\n\nalways @(*) begin\n    if (xor1_out == 0 && xor2_out == 0)\n        out_func = 0;\n    else if (xor1_out == 1 || xor2_out == 1)\n        out_func = 1;\n    else\n        out_func = 0;\nend\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "ea29f5fbe1c137da40eabcd55f44705b",
        "dataset_index": 11106
      },
      "and_gate_b0997fe7": {
        "rtl_code": "\nmodule and_gate (\n    input a,\n    input b,\n    output out\n);\n\n    wire na, nb, nand_out;\n\n    not (na, a);\n    not (nb, b);\n    nand (nand_out, na, nb);\n    not (out, nand_out);\n\nendmodule\n",
        "module_name": "and_gate",
        "module_hash": "b0997fe72fc208375ee882001b64be88",
        "dataset_index": 13795
      },
      "precision_dac #_c445a7dd": {
        "rtl_code": "\n\nmodule precision_dac #\n(\n  parameter CLK_DIV = 3\n)\n(\n  input wire                      clk,\n  input wire [16*4-1:0]           data,\n  input wire                      valid,\n  input wire [4-1:0]              cmd,\n\n  output reg                      sync,\n  output reg                      sclk,\n  output reg                      sdi,\n  output reg                      ldac\n);\n  reg [16*8-1:0] data_reg;\n  reg [4-1:0] cmd_reg;\n  reg [CLK_DIV-1:0] cnt_clk  = 0; reg [7-1: 0] cnt_sclk = 0;\n  initial sync = 1'b1;\n\n  always @(posedge clk) begin\n    if (valid == 1'b1) begin\n      cnt_clk <= cnt_clk + 1;\n\n      if (cnt_clk == {{1'b0}, {(CLK_DIV-1){1'b1}}}) begin\n        sclk <= 1'b1;\n        if (cnt_sclk == {(7){1'b0}}) begin\n          ldac <= 1'b1;\n          cmd_reg <= cmd;\n          data_reg <= data;\n        end\n\n        if (cnt_sclk[5-1:0] == {(5){1'b0}}) begin\n          sync <= 1'b0;\n        end\n\n        cnt_sclk <= cnt_sclk + 1;\n\n        if (sync == 1'b0 | cnt_sclk[5-1:0] == {(5){1'b0}}) begin\n          if (cnt_sclk[5-1:2] == 3'b000) begin\n            sdi <= cmd[3-cnt_sclk[2-1:0]]; end else if (cnt_sclk[5-1:2] == 3'b001) begin\n            sdi <= (cnt_sclk[7-1:5] == ~cnt_sclk[2-1:0]);\n          end else if (cnt_sclk[5-1:0] == 5'b11000) begin\n            sync <= 1'b1;\n            if (cnt_sclk[7-1:5] == 3'b11) begin\n              ldac <= 1'b0;\n            end\n          end else begin\n            sdi <= data_reg[16*cnt_sclk[7-1:5] + 23 - cnt_sclk[5-1:0]];\n          end\n        end\n      end\n      if (cnt_clk == {(CLK_DIV){1'b1}}) begin\n        sclk <= 1'b0;\n      end\n    end else begin cnt_clk <= 0;\n      cnt_sclk <= 0;\n      sync <= 1;\n      sdi <= 0;\n      ldac <= 0;\n      sclk <= 0;\n    end\n  end\n\n\nendmodule\n",
        "module_name": "precision_dac #",
        "module_hash": "c445a7dd64553abde38f0e1f461e38a0",
        "dataset_index": 24419
      },
      "binary_priority_decoder #_cacd6416": {
        "rtl_code": "\nmodule binary_priority_decoder #(\n  parameter n = 4 // number of binary signals\n)(\n  input [n-1:0] in,\n  input [n-1:0] priority_bits,\n  output reg out\n);\n\n\nwire [n-1:0] priority_encoded;\nwire [n-1:0] priority_sorted;\nwire [n-1:0] priority_mask;\nwire [n-1:0] priority_masked;\n\nassign priority_encoded = ~(in ^ priority_bits);\nassign priority_sorted = {priority_encoded[n-1], priority_encoded[n-2:0]};\nassign priority_mask = {priority_sorted[n-1] & priority_sorted[n-2:0], priority_sorted[n-2] & priority_sorted[n-3:0], priority_sorted[n-3] & priority_sorted[n-4:0], priority_sorted[n-4]};\nassign priority_masked = priority_encoded & priority_mask;\n\nalways @(*) begin\n  case (priority_masked)\n    4'b0000: out = 1'b0;\n    4'b0001: out = 1'b1;\n    4'b0010: out = 1'b1;\n    4'b0100: out = 1'b1;\n    4'b1000: out = 1'b1;\n    default: out = 1'bx;\n  endcase\nend\n\nendmodule\n",
        "module_name": "binary_priority_decoder #",
        "module_hash": "cacd6416143e9ea2e803e084be74c29a",
        "dataset_index": 18898
      },
      "twos_complement_6bfa0e20": {
        "rtl_code": "module twos_complement (\n    input [3:0] binary,\n    output reg [3:0] twos_comp\n);\n\n    always @(*) begin\n        twos_comp = ~binary + 1;\n    end\n\nendmodule",
        "module_name": "twos_complement",
        "module_hash": "6bfa0e20f34de5e7e35609a2e84da9c5",
        "dataset_index": 13249
      },
      "johnson_counter_93aa6ddf": {
        "rtl_code": "module johnson_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] q );\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            q <= 4'b0000;\n        end else begin\n            q <= {q[2:0], q[3] ^ q[0]};\n        end\n    end\nendmodule\n\nmodule population_count(\n    input [254:0] in,\n    output reg [7:0] out );\n\n    always @* begin\n        out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]} +\n              {in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15]} +\n              {in[16], in[17], in[18], in[19], in[20], in[21], in[22], in[23]} +\n              {in[24], in[25], in[26], in[27], in[28], in[29], in[30], in[31]} +\n              {in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39]} +\n              {in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47]} +\n              {in[48], in[49], in[50], in[51], in[52], in[53], in[54], in[55]} +\n              {in[56], in[57], in[58], in[59], in[60], in[61], in[62], in[63]} +\n              {in[64], in[65], in[66], in[67], in[68], in[69], in[70], in[71]} +\n              {in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79]} +\n              {in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87]} +\n              {in[88], in[89], in[90], in[91], in[92], in[93], in[94], in[95]} +\n              {in[96], in[97], in[98], in[99], in[100], in[101], in[102], in[103]} +\n              {in[104], in[105], in[106], in[107], in[108], in[109], in[110], in[111]} +\n              {in[112], in[113], in[114], in[115], in[116], in[117], in[118], in[119]} +\n              {in[120], in[121], in[122], in[123], in[124], in[125], in[126], in[127]} +\n              {in[128], in[129], in[130], in[131], in[132], in[133], in[134], in[135]} +\n              {in[136], in[137], in[138], in[139], in[140], in[141], in[142], in[143]} +\n              {in[144], in[145], in[146], in[147], in[148], in[149], in[150], in[151]} +\n              {in[152], in[153], in[154], in[155], in[156], in[157], in[158], in[159]} +\n              {in[160], in[161], in[162], in[163], in[164], in[165], in[166], in[167]} +\n              {in[168], in[169], in[170], in[171], in[172], in[173], in[174], in[175]} +\n              {in[176], in[177], in[178], in[179], in[180], in[181], in[182], in[183]} +\n              {in[184], in[185], in[186], in[187], in[188], in[189], in[190], in[191]} +\n              {in[192], in[193], in[194], in[195], in[196], in[197], in[198], in[199]} +\n              {in[200], in[201], in[202], in[203], in[204], in[205], in[206], in[207]} +\n              {in[208], in[209], in[210], in[211], in[212], in[213], in[214], in[215]} +\n              {in[216], in[217], in[218], in[219], in[220], in[221], in[222], in[223]} +\n              {in[224], in[225], in[226], in[227], in[228], in[229], in[230], in[231]} +\n              {in[232], in[233], in[234], in[235], in[236], in[237], in[238], in[239]} +\n              {in[240], in[241], in[242], in[243], in[244], in[245], in[246], in[247]} +\n              {in[248], in[249], in[250], in[251], in[252], in[253], in[254], 1'b0};\n    end\nendmodule\n\nmodule and_module(\n    input [3:0] johnson_out,\n    input [7:0] population_out,\n    output reg [7:0] out );\n\n    always @* begin\n        out = johnson_out & population_out;\n    end\nendmodule\n\nmodule top_module( \n    input clk,\n    input rst_n,\n    input [254:0] in,\n    output [7:0] out );\n\n    wire [3:0] johnson_out;\n    wire [7:0] population_out;\n\n    johnson_counter jc(\n        .clk(clk),\n        .rst_n(rst_n),\n        .q(johnson_out)\n    );\n\n    population_count pc(\n        .in(in),\n        .out(population_out)\n    );\n\n    and_module am(\n        .johnson_out(johnson_out),\n        .population_out(population_out),\n        .out(out)\n    );\nendmodule",
        "module_name": "johnson_counter",
        "module_hash": "93aa6ddf20e164bb23e7d3741bf9bf85",
        "dataset_index": 2119
      },
      "NOR4X0_8df7bf1e": {
        "rtl_code": "module NOR4X0 (input IN1, IN2, IN3, IN4, output QN, input VDD, VSS);\n\n  wire n1, n2, n3;\n\n  assign n1 = ~(IN1 | IN2);\n  assign n2 = ~(IN3 | IN4);\n  assign n3 = ~(n1 | n2);\n\n  assign QN = n3;\n\nendmodule",
        "module_name": "NOR4X0",
        "module_hash": "8df7bf1e8bf3df0ebd6dda923c7db89e",
        "dataset_index": 4954
      },
      "ParamModule_b54a53ef": {
        "rtl_code": "module ParamModule (\n    input clk,\n    input reset_l,\n    input [3:0] param1,\n    input [7:0] param2,\n    input [15:0] param3,\n    output reg [31:0] result\n);\n\n    parameter PARAM1 = 2;\n    parameter PARAM2 = 4;\n    parameter PARAM3 = 8;\n\n    always @(posedge clk) begin\n        if (!reset_l) begin\n            result <= 0;\n        end else begin\n            result <= param1 + param2 + param3;\n        end\n    end\n\nendmodule",
        "module_name": "ParamModule",
        "module_hash": "b54a53efa82aa0e566732d9a2eb6f20d",
        "dataset_index": 17875
      },
      "VGA1Interface_d82e5a86": {
        "rtl_code": "module VGA1Interface(clock,reset,framebuffer,vga_hsync,vga_vsync,vga_r,vga_g,vga_b);\n   input wire         clock;\n   input wire         reset;\n\n   input wire [63:0]  framebuffer;\n\n   output wire        vga_hsync;\n   output wire        vga_vsync;\n   output wire        vga_r;\n   output wire        vga_g;\n   output wire        vga_b;\n\n   reg [9:0]          CounterX;\n   reg [8:0]          CounterY;\n\n   wire               value;\n\n   reg                clock2 = 0;\n\n   always @ (posedge clock) begin\n      if (reset) begin\n         clock2 = 0;\n      end\n      else begin\n         clock2 = ~clock2;\n      end\n   end\n\n   reg         vga_HS;\n   reg         vga_VS;\n   wire        inDisplayArea = CounterX < 640 && CounterY < 480;\n   wire        CounterXmaxed = (CounterX==767);\n\n   always @ (posedge clock2) begin\n      if(CounterXmaxed) begin\n         CounterX <= 0;\n      end\n      else begin\n         CounterX <= CounterX + 1;\n      end\n   end\n   \n   always @ (posedge clock2) begin\n      if(CounterXmaxed) begin\n         CounterY <= CounterY + 1;\n      end\n   end\n   \n   always @ (posedge clock2) begin\n      vga_HS <= (CounterX[9:4]==0);\n      vga_VS <= (CounterY==0);\n   end\n\n\n   assign vga_hsync = ~vga_HS;\n   assign vga_vsync = ~vga_VS;\n\n   reg [2:0] ix;\n   reg [2:0] iy;\n\n   always @ (posedge clock2) begin\n      if (CounterX < 80) begin\n         ix = 0;\n      end\n      else if (CounterX < 160) begin\n         ix = 1;\n      end\n      else if (CounterX < 240) begin\n         ix = 2;\n      end\n      else if (CounterX < 320) begin\n         ix = 3;\n      end\n      else if (CounterX < 400) begin\n         ix = 4;\n      end\n      else if (CounterX < 480) begin\n         ix = 5;\n      end\n      else if (CounterX < 560) begin\n         ix = 6;\n      end\n      else if (CounterX < 640) begin\n         ix = 7;\n      end\n   end always @ (posedge clock2) begin\n      if (CounterY < 60) begin\n         iy = 0;\n      end\n      else if (CounterY < 120) begin\n         iy = 1;\n      end\n      else if (CounterY < 180) begin\n         iy = 2;\n      end\n      else if (CounterY < 240) begin\n         iy = 3;\n      end\n      else if (CounterY < 300) begin\n         iy = 4;\n      end\n      else if (CounterY < 360) begin\n         iy = 5;\n      end\n      else if (CounterY < 420) begin\n         iy = 6;\n      end\n      else if (CounterY < 480) begin\n         iy = 7;\n      end\n   end assign value = framebuffer[{iy,ix}];\n\n   assign vga_r = value & inDisplayArea;\n   assign vga_g = value & inDisplayArea;\n   assign vga_b = value & inDisplayArea;\nendmodule ",
        "module_name": "VGA1Interface",
        "module_hash": "d82e5a861a17b85fcfb2b3233537c7cd",
        "dataset_index": 13329
      },
      "mag_comparator_4bit_90475121": {
        "rtl_code": "module mag_comparator_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    output reg LT,\n    input clk \n);\n\nreg [3:0] A_reg, B_reg;\nreg [2:0] stage;\n\n// Added clock in the sensitivity list\nalways @(posedge clk) begin\n    case(stage)\n        0: begin\n            A_reg <= A;\n            B_reg <= B;\n            stage <= 1;\n        end\n        1: begin\n            if(A_reg < B_reg) begin\n                LT <= 1'b1; // Fixed the assignment to LT\n            end else begin\n                LT <= 1'b0; // Fixed the assignment to LT\n            end\n            stage <= 0;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "mag_comparator_4bit",
        "module_hash": "9047512156899e13c855bff050d7156f",
        "dataset_index": 2925
      },
      "half_subtractor_a04f1f9d": {
        "rtl_code": "module half_subtractor(\n  input a,\n  input b,\n  output diff,\n  output borrow\n);\n\n  assign diff = a ^ b;\n  assign borrow = ~a & b;\n\nendmodule\n\nmodule full_subtractor(\n  input a,\n  input b,\n  input c_in,\n  output diff,\n  output borrow\n);\n\n  wire temp_diff;\n  wire temp_borrow1;\n  wire temp_borrow2;\n\n  half_subtractor ha1(a, b, temp_diff, temp_borrow1);\n  half_subtractor ha2(temp_diff, c_in, diff, temp_borrow2);\n  assign borrow = temp_borrow1 | temp_borrow2;\n\nendmodule",
        "module_name": "half_subtractor",
        "module_hash": "a04f1f9df4e740695c5808f7ab493d30",
        "dataset_index": 14368
      },
      "vending_machine_9bb10b35": {
        "rtl_code": "module vending_machine(\n  input clk,\n  input reset,\n  input quarter,\n  input button_a,\n  input button_b,\n  input button_c,\n  output reg dispense,\n  output reg product_a,\n  output reg product_b,\n  output reg product_c\n);\n\n  parameter WAIT = 2'd0;\n  parameter INSERTED = 2'd1;\n  parameter DISPENSED = 2'd2;\n\n  reg [1:0] state;\n  reg [1:0] product;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= WAIT;\n      product <= 2'b0;\n      dispense <= 1'b0;\n      product_a <= 1'b0;\n      product_b <= 1'b0;\n      product_c <= 1'b0;\n    end else begin\n      case (state)\n        WAIT: begin\n          if (button_a) begin\n            product <= 2'b01;\n            state <= INSERTED;\n          end else if (button_b) begin\n            product <= 2'b10;\n            state <= INSERTED;\n          end else if (button_c) begin\n            product <= 2'b11;\n            state <= INSERTED;\n          end\n        end\n        INSERTED: begin\n          if (quarter) begin\n            state <= (product == 2'b01 || product == 2'b10 || product == 2'b11) ? DISPENSED : INSERTED;\n          end\n        end\n        DISPENSED: begin\n          dispense <= 1'b1;\n          case (product)\n            2'b01: product_a <= 1'b1;\n            2'b10: product_b <= 1'b1;\n            2'b11: product_c <= 1'b1;\n          endcase\n          state <= WAIT;\n        end\n      endcase\n    end\n  end\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "9bb10b35a7de25c03c1f188a05342bcf",
        "dataset_index": 3990
      },
      "add_sub_pipeline_574f9ebd": {
        "rtl_code": "module add_sub_pipeline(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\n    wire [15:0] a_lo, b_lo, sum_lo;\n    wire [15:0] a_hi, b_hi, sum_hi;\n    wire carry;\n\n    // Instantiate the 16-bit adder module twice\n    adder16bit adder_lo(.a(a_lo), .b(b_lo), .carry_in(sub), .sum(sum_lo), .carry_out(carry));\n    adder16bit adder_hi(.a(a_hi), .b(b_hi), .carry_in(carry), .sum(sum_hi), .carry_out());\n\n    // Connect the inputs to the 16-bit adders\n    assign a_lo = a[15:0];\n    assign b_lo = b[15:0] ^ (sub ? 32'hFFFF : 0);\n    assign a_hi = a[31:16];\n    assign b_hi = b[31:16] ^ (sub ? 32'hFFFF : 0);\n\n    // Connect the outputs of the 16-bit adders to the output of the module\n    assign sum = {sum_hi, sum_lo};\n\nendmodule\n\nmodule adder16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input carry_in,\n    output [15:0] sum,\n    output carry_out\n);\n\n    assign {carry_out, sum} = a + b + carry_in;\n\nendmodule",
        "module_name": "add_sub_pipeline",
        "module_hash": "574f9ebd3c73ddf18e665d5c32008cf7",
        "dataset_index": 8668
      },
      "d_ff_async_reset_fc8324bc": {
        "rtl_code": "module d_ff_async_reset (\n    input D, RESET_B, CLK,\n    output Q\n);\n\nreg Q;\n\nalways @(posedge CLK, negedge RESET_B) begin\n    if (!RESET_B) begin\n        Q <= 0;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule",
        "module_name": "d_ff_async_reset",
        "module_hash": "fc8324bce25175e459284fd88b805013",
        "dataset_index": 7357
      },
      "brush_motor_driver_57237d6a": {
        "rtl_code": "\nmodule brush_motor_driver(\n// Qsys bus interface\t\n\t\tinput\t\t\t\t\trsi_MRST_reset,\n\t\tinput\t\t\t\t\tcsi_MCLK_clk,\n\t\tinput\t\t[31:0]\tavs_ctrl_writedata,\n\t\toutput\t[31:0]\tavs_ctrl_readdata,\n\t\tinput\t\t[3:0]\t\tavs_ctrl_byteenable,\n\t\tinput\t\t[2:0]\t\tavs_ctrl_address,\n\t\tinput\t\t\t\t\tavs_ctrl_write,\n\t\tinput\t\t\t\t\tavs_ctrl_read,\n\t\toutput\t\t\t\tavs_ctrl_waitrequest,\n\t\t\n\t\tinput\t\t\t\t\trsi_PWMRST_reset,\n      input\t\t\t\t\tcsi_PWMCLK_clk,\n\n//brush_moter_interface\t\t\n\t\toutput \t\t\t\tHX,\n\t\toutput \t\t\t\tHY\t\t\n\t\t);\n\n// Registers for Qsys bus interface\n\treg \t\t\t\t\tforward_back;\n   reg \t\t\t\t\ton_off;\n\treg \t[31:0] \tPWM_width;\n\treg \t[31:0] \tPWM_frequent;\n\treg \t[31:0] \tread_data;\n\n\t// Assigning read data output\n\tassign\tavs_ctrl_readdata = read_data;\n\tassign  avs_ctrl_waitrequest=1'b0;\n\n\t// Qsys bus interface logic\n\talways@(posedge csi_MCLK_clk or posedge rsi_MRST_reset)\n\tbegin\n\t\tif(rsi_MRST_reset) begin\n\t\t\tread_data <= 0;\n\t\tend\n\t\telse if(avs_ctrl_write) \n\t\tbegin\n\t\t\tcase(avs_ctrl_address)\n\t\t\t\t1: begin\n\t\t\t\t\tif(avs_ctrl_byteenable[3]) PWM_frequent[31:24] <= avs_ctrl_writedata[31:24];\n\t\t\t\t\tif(avs_ctrl_byteenable[2]) PWM_frequent[23:16] <= avs_ctrl_writedata[23:16];\n\t\t\t\t\tif(avs_ctrl_byteenable[1]) PWM_frequent[15:8] <= avs_ctrl_writedata[15:8];\n\t\t\t\t\tif(avs_ctrl_byteenable[0]) PWM_frequent[7:0] <= avs_ctrl_writedata[7:0];\n\t\t\t\tend\n\t\t\t\t2: begin\n\t\t\t\t\tif(avs_ctrl_byteenable[3]) PWM_width[31:24] <= avs_ctrl_writedata[31:24];\n\t\t\t\t\tif(avs_ctrl_byteenable[2]) PWM_width[23:16] <= avs_ctrl_writedata[23:16];\n\t\t\t\t\tif(avs_ctrl_byteenable[1]) PWM_width[15:8] <= avs_ctrl_writedata[15:8];\n\t\t\t\t\tif(avs_ctrl_byteenable[0]) PWM_width[7:0] <= avs_ctrl_writedata[7:0];\n\t\t\t\tend\n\t\t\t\t3: on_off <= avs_ctrl_writedata[0];\n\t\t\t\t4: forward_back <= avs_ctrl_writedata[0];\n\t\t\t\tdefault:;\n\t\t\tendcase\n\t   end\n\t\telse begin\n\t\t\tcase(avs_ctrl_address)\n\t\t\t\t0: read_data <= 32'hEA680003;\n\t\t\t\t1: read_data <= PWM_frequent;\n\t\t\t\t2: read_data <= PWM_width;\n\t\t\t\t3: read_data <= {31'b0,on_off};\n\t\t\t\t4: read_data <= {31'b0,forward_back};\n\t\t\t\tdefault: read_data <= 32'b0;\n\t\t\tendcase\n\t\tend\n\tend\n\n// PWM controller logic\n\treg \t[31:0] \tPWM;\n\treg \t\t\t\tPWM_out;\n\talways @ (posedge csi_PWMCLK_clk or posedge rsi_PWMRST_reset)\n\tbegin\n\t\tif(rsi_PWMRST_reset)\n\t\t\tPWM <= 32'b0;\n\t\telse\n\t\tbegin\n\t\t\tPWM <= PWM + PWM_frequent;\n\t\t\tPWM_out <=(PWM > PWM_width) ? 1'b0:1'b1;   \n\t\tend\n\tend\n\n// Output logic\n\twire \t\t\tX, Y;\t\n   assign X  = forward_back?PWM_out:1'b0;\n   assign Y  = forward_back?1'b0:PWM_out;\n   assign HX = on_off?X:1'b0; \n\tassign HY = on_off?Y:1'b0; \t\n\nendmodule",
        "module_name": "brush_motor_driver",
        "module_hash": "57237d6a9967e7612a8fa5e5257d8114",
        "dataset_index": 16858
      },
      "top__19e11a59": {
        "rtl_code": "module top_module (\n    input [2:0] sel,\n    input [3:0] a0,\n    input [3:0] b0,\n    input [3:0] a1,\n    input [3:0] b1,\n    output [3:0] result\n);\n\n    // Define the two 4-bit adders\n    wire [4:0] sum0, sum1;\n    wire cout0, cout1;\n    adder4 adder0(.a(a0), .b(b0), .sum(sum0), .cout(cout0));\n    adder4 adder1(.a(a1), .b(b1), .sum(sum1), .cout(cout1));\n\n    // Define the bitwise AND of the two least significant bits of all inputs\n    wire [1:0] and_out;\n    assign and_out = (a0[1:0] & b0[1:0] & a1[1:0] & b1[1:0]);\n\n    // Define the 6-to-1 multiplexer\n    wire [4:0] mux_out;\n    assign mux_out = (sel == 0) ? {1'b0, sum0} :\n                     (sel == 1) ? {1'b0, sum1} :\n                     (sel == 2) ? {1'b0, sum0 + sum1} :\n                     (sel == 3) ? {1'b0, sum0 - sum1} :\n                     (sel == 4) ? {1'b0, sum1 - sum0} :\n                     (sel == 5) ? {1'b0, cout0 + cout1} :\n                     (sel == 6) ? {1'b0, and_out} :\n                                  {1'b0, 4'b1111};\n\n    // Define the output\n    assign result = mux_out[3:0];\n\nendmodule\n\n// Define the 4-bit adder module\nmodule adder4 (\n    input [3:0] a,\n    input [3:0] b,\n    output [4:0] sum,\n    output cout\n);\n\n    assign sum = a + b;\n    assign cout = (sum[4] == 1);\n\nendmodule",
        "module_name": "top_",
        "module_hash": "19e11a594a8549f43829d855263e1d19",
        "dataset_index": 12977
      },
      "rng_9c34466b": {
        "rtl_code": "\n\nmodule rng(reset, rnreset, rngbitin, rngbitinclk, rngbitoutclk, rngbitout, rngdone, handle);\ninput reset, rnreset, rngbitoutclk;\ninput rngbitin, rngbitinclk;\noutput rngbitout, rngdone;\noutput [15:0] handle;\n\nreg [15:0] rn;\nreg [3:0] bitoutcounter;\n\n\n\nassign handle[15:0] = rn[15:0];\nassign rngbitout    = rn[bitoutcounter];\n\nassign rngdone   = (bitoutcounter == 0);\nreg    initialized;\n\nalways @ (posedge rngbitoutclk or posedge reset) begin\n  if (reset) begin\n    bitoutcounter <= 0;\n    initialized   <= 0;\n  end else if (!initialized) begin\n    initialized   <= 1;\n    bitoutcounter <= 15;\n  end else if (!rngdone) begin\n    bitoutcounter <= bitoutcounter - 4'd1;\n  end else begin\n  end end always @ (posedge rngbitinclk or posedge rnreset) begin\n  if (rnreset) begin\n    rn <= 16'h0000;\n  end else begin\n    rn[0]  <= rngbitin ^ rn[15];\n    rn[1]  <= rn[0];\n    rn[2]  <= rn[1];\n    rn[3]  <= rn[2];\n    rn[4]  <= rn[3];\n    rn[5]  <= rn[4] ^ rngbitin ^ rn[15];\n    rn[6]  <= rn[5];\n    rn[7]  <= rn[6];\n    rn[8]  <= rn[7];\n    rn[9]  <= rn[8];\n    rn[10] <= rn[9];\n    rn[11] <= rn[10];\n    rn[12] <= rn[11] ^ rngbitin ^ rn[15];\n    rn[13] <= rn[12];\n    rn[14] <= rn[13];\n    rn[15] <= rn[14];\n  end end endmodule\n\n",
        "module_name": "rng",
        "module_hash": "9c34466bac41e47a188505550f2b051c",
        "dataset_index": 22602
      },
      "two_bit_output_0aa99175": {
        "rtl_code": "module two_bit_output(clk, b, so);\ninput clk;\ninput [3:0] b;\noutput [1:0] so;\nreg [1:0] so;\n\n\talways @(posedge clk)\n\t\tcase (b)\n\t\t\t4'b0000, 4'b0001, 4'b0010: so = 2'b00;\n\t\t\t4'b0011, 4'b0100: so = 2'b01;\n\t\t\t4'b0101, 4'b0110: so = 2'b10;\n\t\t\t4'b0111: so = 2'b11;\n\t\t\tdefault: so = 2'b00;\n\t\tendcase\n\nendmodule",
        "module_name": "two_bit_output",
        "module_hash": "0aa9917541230b550670a1adb7655263",
        "dataset_index": 17565
      },
      "my__81f7eeb5": {
        "rtl_code": "module my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    // Module ports\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire and0_out         ;\n    wire and1_out         ;\n    wire or0_out_X        ;\n    wire pwrgood_pp0_out_X;\n\n    // Internal modules\n    my_and  and0 (and0_out, B1, B2);\n    my_and  and1 (and1_out, A1, A2);\n    my_or   or0  (or0_out_X, and1_out, and0_out, C1);\n    my_pg   pg0  (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);\n    my_buf  buf0 (X, pwrgood_pp0_out_X);\n\nendmodule\n\nmodule my_and (\n    out,\n    in1,\n    in2\n);\n\n    // Module ports\n    output out;\n    input  in1;\n    input  in2;\n\n    // Local signals\n    wire and_out;\n\n    // Implementation\n    assign and_out = in1 & in2;\n    assign out     = and_out;\n\nendmodule\n\nmodule my_or (\n    out,\n    in1,\n    in2,\n    in3\n);\n\n    // Module ports\n    output out;\n    input  in1;\n    input  in2;\n    input  in3;\n\n    // Local signals\n    wire or_out;\n\n    // Implementation\n    assign or_out = in1 | in2 | in3;\n    assign out    = or_out;\n\nendmodule\n\nmodule my_pg (\n    out,\n    in1,\n    in2,\n    in3\n);\n\n    // Module ports\n    output out;\n    input  in1;\n    input  in2;\n    input  in3;\n\n    // Local signals\n    wire pg_out;\n\n    // Implementation\n    assign pg_out = in1 & ~in2 & in3;\n    assign out    = pg_out;\n\nendmodule\n\nmodule my_buf (\n    out,\n    in1\n);\n\n    // Module ports\n    output out;\n    input  in1;\n\n    // Implementation\n    assign out = in1;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "81f7eeb5415c42ee7f8aea0862bcd9cd",
        "dataset_index": 17082
      },
      "sky130_fd_sc_hd__nor2b_8a43f54a": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nor2b (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_Y;\n\n    not not0 (not0_out  , A              );\n    and and0 (and0_out_Y, not0_out, B_N  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nor2b",
        "module_hash": "8a43f54ad736802c8d3477e55f42d2a1",
        "dataset_index": 17972
      },
      "clock_divider_991610aa": {
        "rtl_code": "module clock_divider(\n    input clk_50,\n    output reg clk_1\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    reg [31:0] counter = 0;\n\n    always @(posedge clk_50) begin\n        counter <= counter + 1;\n        if (counter == 50000000) begin\n            counter <= 0;\n            clk_1 <= ~clk_1;\n        end\n    end\n\nendmodule",
        "module_name": "clock_divider",
        "module_hash": "991610aab024d353b1449c4864f1c636",
        "dataset_index": 18473
      },
      "my__28c0f0df": {
        "rtl_code": "module my_module (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign X = (A1 & A2 & A3) | (B1 & B2);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "28c0f0df4947338754dec7497f509292",
        "dataset_index": 12803
      },
      "calculator_009742e0": {
        "rtl_code": "module calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] result,\n    output reg overflow,\n    output reg zero\n);\n\nalways @ (posedge clk) begin\n    if (rst) begin\n        result <= 0;\n        overflow <= 0;\n        zero <= 0;\n    end\n    else begin\n        case (op)\n            2'b00: // addition\n                begin\n                    result <= in1 + in2;\n                    overflow <= (result > 8'hFF);\n                    zero <= (result == 0);\n                end\n            2'b01: // subtraction\n                begin\n                    result <= in1 - in2;\n                    overflow <= (result < 0);\n                    zero <= (result == 0);\n                end\n            2'b10: // multiplication\n                begin\n                    result <= in1 * in2;\n                    overflow <= (result > 8'hFF);\n                    zero <= (result == 0);\n                end\n            2'b11: // division\n                begin\n                    if (in2 == 0) begin\n                        result <= 8'h00;\n                        overflow <= 0;\n                        zero <= 1;\n                    end\n                    else begin\n                        result <= in1 / in2;\n                        overflow <= (result > 8'hFF);\n                        zero <= (result == 0);\n                    end\n                end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "009742e070311234050ab64827d33f23",
        "dataset_index": 297
      },
      "sine_lut_bca0ab6b": {
        "rtl_code": "module sine_lut(addr, s);\n\ninput [7:0] addr;\noutput [7:0] s;\n\nreg [7:0] s;\n\nalways @(addr) begin\ncase (addr)\n0: s = 8'h80;\n1: s = 8'h83;\n2: s = 8'h86;\n3: s = 8'h89;\n4: s = 8'h8C;\n5: s = 8'h8F;\n6: s = 8'h92;\n7: s = 8'h95;\n8: s = 8'h98;\n9: s = 8'h9B;\n10: s = 8'h9E;\n11: s = 8'hA2;\n12: s = 8'hA5;\n13: s = 8'hA7;\n14: s = 8'hAA;\n15: s = 8'hAD;\n16: s = 8'hB0;\n17: s = 8'hB3;\n18: s = 8'hB6;\n19: s = 8'hB9;\n20: s = 8'hBC;\n21: s = 8'hBE;\n22: s = 8'hC1;\n23: s = 8'hC4;\n24: s = 8'hC6;\n25: s = 8'hC9;\n26: s = 8'hCB;\n27: s = 8'hCE;\n28: s = 8'hD0;\n29: s = 8'hD3;\n30: s = 8'hD5;\n31: s = 8'hD7;\n32: s = 8'hDA;\n33: s = 8'hDC;\n34: s = 8'hDE;\n35: s = 8'hE0;\n36: s = 8'hE2;\n37: s = 8'hE4;\n38: s = 8'hE6;\n39: s = 8'hE8;\n40: s = 8'hEA;\n41: s = 8'hEB;\n42: s = 8'hED;\n43: s = 8'hEE;\n44: s = 8'hF0;\n45: s = 8'hF1;\n46: s = 8'hF3;\n47: s = 8'hF4;\n48: s = 8'hF5;\n49: s = 8'hF6;\n50: s = 8'hF8;\n51: s = 8'hF9;\n52: s = 8'hFA;\n53: s = 8'hFA;\n54: s = 8'hFB;\n55: s = 8'hFC;\n56: s = 8'hFD;\n57: s = 8'hFD;\n58: s = 8'hFE;\n59: s = 8'hFE;\n60: s = 8'hFE;\n61: s = 8'hFF;\n62: s = 8'hFF;\n63: s = 8'hFF;\n64: s = 8'hFF;\n65: s = 8'hFF;\n66: s = 8'hFF;\n67: s = 8'hFF;\n68: s = 8'hFE;\n69: s = 8'hFE;\n70: s = 8'hFE;\n71: s = 8'hFD;\n72: s = 8'hFD;\n73: s = 8'hFC;\n74: s = 8'hFB;\n75: s = 8'hFA;\n76: s = 8'hFA;\n77: s = 8'hF9;\n78: s = 8'hF8;\n79: s = 8'hF6;\n80: s = 8'hF5;\n81: s = 8'hF4;\n82: s = 8'hF3;\n83: s = 8'hF1;\n84: s = 8'hF0;\n85: s = 8'hEE;\n86: s = 8'hED;\n87: s = 8'hEB;\n88: s = 8'hEA;\n89: s = 8'hE8;\n90: s = 8'hE6;\n91: s = 8'hE4;\n92: s = 8'hE2;\n93: s = 8'hE0;\n94: s = 8'hDE;\n95: s = 8'hDC;\n96: s = 8'hDA;\n97: s = 8'hD7;\n98: s = 8'hD5;\n99: s = 8'hD3;\n100: s = 8'hD0;\n101: s = 8'hCE;\n102: s = 8'hCB;\n103: s = 8'hC9;\n104: s = 8'hC6;\n105: s = 8'hC4;\n106: s = 8'hC1;\n107: s = 8'hBE;\n108: s = 8'hBC;\n109: s = 8'hB9;\n110: s = 8'hB6;\n111: s = 8'hB3;\n112: s = 8'hB0;\n113: s = 8'hAD;\n114: s = 8'hAA;\n115: s = 8'hA7;\n116: s = 8'hA5;\n117: s = 8'hA2;\n118: s = 8'h9E;\n119: s = 8'h9B;\n120: s = 8'h98;\n121: s = 8'h95;\n122: s = 8'h92;\n123: s = 8'h8F;\n124: s = 8'h8C;\n125: s = 8'h89;\n126: s = 8'h86;\n127: s = 8'h83;\n128: s = 8'h80;\n129: s = 8'h7C;\n130: s = 8'h79;\n131: s = 8'h76;\n132: s = 8'h73;\n133: s = 8'h70;\n134: s = 8'h6D;\n135: s = 8'h6A;\n136: s = 8'h67;\n137: s = 8'h64;\n138: s = 8'h61;\n139: s = 8'h5D;\n140: s = 8'h5A;\n141: s = 8'h58;\n142: s = 8'h55;\n143: s = 8'h52;\n144: s = 8'h4F;\n145: s = 8'h4C;\n146: s = 8'h49;\n147: s = 8'h46;\n148: s = 8'h43;\n149: s = 8'h41;\n150: s = 8'h3E;\n151: s = 8'h3B;\n152: s = 8'h39;\n153: s = 8'h36;\n154: s = 8'h34;\n155: s = 8'h31;\n156: s = 8'h2F;\n157: s = 8'h2C;\n158: s = 8'h2A;\n159: s = 8'h28;\n160: s = 8'h25;\n161: s = 8'h23;\n162: s = 8'h21;\n163: s = 8'h1F;\n164: s = 8'h1D;\n165: s = 8'h1B;\n166: s = 8'h19;\n167: s = 8'h17;\n168: s = 8'h15;\n169: s = 8'h14;\n170: s = 8'h12;\n171: s = 8'h11;\n172: s = 8'h0F;\n173: s = 8'h0E;\n174: s = 8'h0C;\n175: s = 8'h0B;\n176: s = 8'h0A;\n177: s = 8'h09;\n178: s = 8'h07;\n179: s = 8'h06;\n180: s = 8'h05;\n181: s = 8'h05;\n182: s = 8'h04;\n183: s = 8'h03;\n184: s = 8'h02;\n185: s = 8'h02;\n186: s = 8'h01;\n187: s = 8'h01;\n188: s = 8'h01;\n189: s = 8'h00;\n190: s = 8'h00;\n191: s = 8'h00;\n192: s = 8'h00;\n193: s = 8'h00;\n194: s = 8'h00;\n195: s = 8'h00;\n196: s = 8'h01;\n197: s = 8'h01;\n198: s = 8'h01;\n199: s = 8'h02;\n200: s = 8'h02;\n201: s = 8'h03;\n202: s = 8'h04;\n203: s = 8'h05;\n204: s = 8'h05;\n205: s = 8'h06;\n206: s = 8'h07;\n207: s = 8'h09;\n208: s = 8'h0A;\n209: s = 8'h0B;\n210: s = 8'h0C;\n211: s = 8'h0E;\n212: s = 8'h0F;\n213: s = 8'h11;\n214: s = 8'h12;\n215: s = 8'h14;\n216: s = 8'h15;\n217: s = 8'h17;\n218: s = 8'h19;\n219: s = 8'h1B;\n220: s = 8'h1D;\n221: s = 8'h1F;\n222: s = 8'h21;\n223: s = 8'h23;\n224: s = 8'h25;\n225: s = 8'h28;\n226: s = 8'h2A;\n227: s = 8'h2C;\n228: s = 8'h2F;\n229: s = 8'h31;\n230: s = 8'h34;\n231: s = 8'h36;\n232: s = 8'h39;\n233: s = 8'h3B;\n234: s = 8'h3E;\n235: s = 8'h41;\n236: s = 8'h43;\n237: s = 8'h46;\n238: s = 8'h49;\n239: s = 8'h4C;\n240: s = 8'h4F;\n241: s = 8'h52;\n242: s = 8'h55;\n243: s = 8'h58;\n244: s = 8'h5A;\n245: s = 8'h5D;\n246: s = 8'h61;\n247: s = 8'h64;\n248: s = 8'h67;\n249: s = 8'h6A;\n250: s = 8'h6D;\n251: s = 8'h70;\n252: s = 8'h73;\n253: s = 8'h76;\n254: s = 8'h79;\n255: s = 8'h7C;\nendcase\nend\nendmodule\n\n",
        "module_name": "sine_lut",
        "module_hash": "bca0ab6bbfcdc714678ad2ee67b93eaa",
        "dataset_index": 21618
      },
      "mux4to1_573f0aa6": {
        "rtl_code": "\nmodule mux4to1 (\n    input A0,\n    input A1,\n    input A2,\n    input A3,\n    input S0,\n    input S1,\n    output X\n);\n\n    wire mux_2to1_0_out;\n    wire mux_2to1_1_out;\n    wire mux_2to1_2_out;\n\n    mux2 mux_2to1_0 (mux_2to1_0_out, A0, A1, S0);\n    mux2 mux_2to1_1 (mux_2to1_1_out, A2, A3, S0);\n    mux2 mux_2to1_2 (mux_2to1_2_out, mux_2to1_0_out, mux_2to1_1_out, S1);\n\n    mux2 mux_2to1_3 (X, mux_2to1_2_out, mux_2to1_2_out, S1);\n\nendmodule\n\nmodule mux2 (output out, input a, input b, input sel);\n    assign out = sel ? b : a;\nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "573f0aa60ca8abb35a42bfc67bf355ab",
        "dataset_index": 19395
      },
      "binary_multiplier_control_unit_4584b38a": {
        "rtl_code": "\nmodule binary_multiplier_control_unit\n(\n    input start,\n    input clk,\n    input cnt_done,\n    input lsb,\n    output start_process,\n    output reg add,\n    output reg shift,\n    output reg count_up,\n    output reg done\n    );\n\n    reg [2:0] state, nextState;\n    parameter off = 0, on = 1, process = 2, finish = 3;\n    \n    assign start_process = start;\n    \n    initial begin\n        state = off;\n    end\n    \n    always @(posedge clk) begin\n        state <= nextState;\n    end\n    \n    always @(start or lsb or cnt_done or state) begin\n        add = 0;\n        case (state)\n            off: begin\n                if (start) nextState = on;\n                else nextState = off;\n            end\n            on: begin\n                if (lsb) begin\n                    nextState = process;\n                    add = 1;\n                end\n                else begin\n                    nextState = process;\n                end\n            end\n            process: begin\n                if (cnt_done) nextState = finish;\n                else nextState = on;\n            end\n            finish: begin\n                nextState = off;\n            end\n            default: begin\n                nextState = off;\n            end\n        endcase\n    end\n    \n    always @(state) begin\n        shift = 0;\n        count_up = 0;\n        done = 0;\n        case (state)\n            process: begin\n                shift = 1;\n                count_up = 1;\n            end\n            finish: begin\n                done = 1;\n            end\n            default: begin\n                shift = 0;\n                count_up = 0;\n                done = 0;\n            end\n        endcase\n    end\nendmodule\n",
        "module_name": "binary_multiplier_control_unit",
        "module_hash": "4584b38ac24114e8009a8463afe3f2ad",
        "dataset_index": 21845
      },
      "priority_encoder_8bit_412173a5": {
        "rtl_code": "module priority_encoder_8bit (\n    input [7:0] code,\n    output reg [2:0] out\n);\n\nalways @(*) begin\n    case (code)\n        8'b10000000: out = 3'b100; // Highest priority input\n        8'b01000000: out = 3'b010; // Second highest priority input\n        8'b00100000: out = 3'b001; // Third highest priority input\n        default: out = 3'b000; // No inputs active\n    endcase\nend\n\nendmodule",
        "module_name": "priority_encoder_8bit",
        "module_hash": "412173a50a927ab026d819eccc322a5e",
        "dataset_index": 7927
      },
      "mux4_0aa0cb99": {
        "rtl_code": "module mux4\n  #(parameter WIDTH=32, parameter DISABLED=0)\n    (input en,\n     input [1:0] sel,\n     input [WIDTH-1:0] i0,\n     input [WIDTH-1:0] i1,\n     input [WIDTH-1:0] i2,\n     input [WIDTH-1:0] i3,\n     output [WIDTH-1:0] o);\n\n   assign o = en ? (sel[1] ? (sel[0] ? i3 : i2) : (sel[0] ? i1 : i0)) : DISABLED;\n   \nendmodule",
        "module_name": "mux4",
        "module_hash": "0aa0cb994d9202b720dc2446c045e01d",
        "dataset_index": 12926
      },
      "master #_fba424af": {
        "rtl_code": "module master #(\n\tparameter\tADDR_WIDTH = 16,\n\tparameter\tIPL_READ_ADDR = 16'h0,\n\tparameter\tIPL_WRITE_ADDR = 16'h1,\n\tparameter\tAW = ADDR_WIDTH - 1\n\n)(\n\tinput\t\tclk_i,\n\tinput\t\treset_i,\n\n\tinput\t\tdreq_i,\n\toutput\t\tdack_o,\n\n\toutput\t[AW:0]\tadr_o,\n\toutput\t\tcyc_o,\n\toutput\t\tstb_o,\n\toutput\t\twe_o,\n\tinput\t\tack_i\n);\n\n\treg\t[AW:0]\tadr_o;\n\treg\t\tstb_o;\n\treg\t\twe_o;\n\n\treg\t[AW:0]\trd_adr, wr_adr;\n\treg\t\trd_cyc, wr_cyc;\n\n\treg\t\tdack_o;\n\n\tassign\t\tcyc_o = rd_cyc | wr_cyc;\n\n\talways @(posedge clk_i) begin\n\t\t// Unless otherwise instructed, the following signals assume\n\t\t// these values on any given clock cycle.\n\n\t\tadr_o <= 0;\n\t\tstb_o <= 0;\n\t\twe_o <= 0;\n\t\trd_cyc <= rd_cyc;\n\t\twr_cyc <= wr_cyc;\n\t\tdack_o <= 0;\n\n\t\t// Upon reset, reset internal registers to their power-on\n\t\t// defaults.\n\n\t\tif(reset_i) begin\n\t\t\trd_adr <= IPL_READ_ADDR;\n\t\t\twr_adr <= IPL_WRITE_ADDR;\n\t\t\trd_cyc <= 0;\n\t\t\twr_cyc <= 0;\n\t\tend\n\n\t\t// Otherwise, implement the read/write state machine here.\n\n\t\telse begin\n\t\t\t// WARNING: THIS CODE IS NOT EXPRESSLY DESIGNED FOR\n\t\t\t// SINGLE-CYCLE TRANSACTIONS.  Experience on my\n\t\t\t// simulator shows that it works in practice; but, I\n\t\t\t// offer NO PROMISE that it'll work for you.  You'll\n\t\t\t// need to explore/experiment on your own.\n\n\t\t\t// If the DMAC isn't doing anything at the moment,\n\t\t\t// initiate a read cycle.  At this time, we acknowledge\n\t\t\t// the request for data to tell the slave that it's\n\t\t\t// in-progress.\n\n\t\t\tif(dreq_i && ~cyc_o) begin\n\t\t\t\tadr_o <= rd_adr;\n\t\t\t\tstb_o <= 1;\n\t\t\t\trd_cyc <= 1;\n\t\t\t\tdack_o <= 1;\n\t\t\tend\n\n\t\t\t// If the read cycle is complete, then we kick off the\n\t\t\t// write cycle.\n\n\t\t\tif(rd_cyc && ack_i) begin\n\t\t\t\trd_cyc <= 0;\n\t\t\t\twr_cyc <= 1;\n\t\t\t\tadr_o <= wr_adr;\n\t\t\t\tstb_o <= 1;\n\t\t\t\twe_o <= 1;\n\t\t\tend\n\n\t\t\t// If the write cycle is complete, we sample the DREQ_I\n\t\t\t// signal.  If it's still asserted, kick off another\n\t\t\t// read cycle.\tOtherwise, revert back to idle\n\t\t\t// condition.\n\n\t\t\tif(wr_cyc && ack_i) begin\n\t\t\t\twr_cyc <= 0;\n\t\t\t\tif(dreq_i) begin\n\t\t\t\t\tadr_o <= rd_adr;\n\t\t\t\t\tstb_o <= 1;\n\t\t\t\t\trd_cyc <= 1;\n\t\t\t\t\tdack_o <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nendmodule",
        "module_name": "master #",
        "module_hash": "fba424afb2e8d84c0a36c424e7c389bf",
        "dataset_index": 9145
      },
      "full_adder_43fd7317": {
        "rtl_code": "module full_adder(\n    input a, b, cin,\n    output cout, sum\n);\n\n    wire w1, w2, w3;\n    \n    // XOR gate for sum calculation\n    xor(sum, a, b, cin);\n    \n    // AND gate for carry-out calculation\n    and(w1, a, b);\n    and(w2, a, cin);\n    and(w3, b, cin);\n    or(cout, w1, w2, w3);\n    \nendmodule",
        "module_name": "full_adder",
        "module_hash": "43fd731748539bf9d250d56d0e6bb3f0",
        "dataset_index": 7400
      },
      "tx_run_length_limiter #_b22774b1": {
        "rtl_code": "\n\nmodule tx_run_length_limiter #(\n    parameter LANE_WIDTH  =64,\n    parameter GRANULARITY =4,\n    parameter RUN_LIMIT   =85\n)\n(\n    input wire              clk,\n    input wire              res_n,\n    input wire              enable,\n    input wire [LANE_WIDTH-1:0] data_in,\n    output reg [LANE_WIDTH-1:0] data_out,\n    output reg              rf_bit_flip\n);\n\nlocalparam NUM_CHUNKS   = (LANE_WIDTH + GRANULARITY-1)/(GRANULARITY);\nlocalparam REM_BITS     = LANE_WIDTH - (GRANULARITY * (LANE_WIDTH/GRANULARITY));\nlocalparam COUNT_BITS   = 8;\n\nwire [NUM_CHUNKS-1:0] no_flip;\nwire [NUM_CHUNKS-1:0] still_counting_top;\nwire [NUM_CHUNKS-1:0] still_counting_bottom;\n\nwire [COUNT_BITS-1:0] count_top;\nwire [COUNT_BITS-1:0] count_top_part    [NUM_CHUNKS-1:0];\nwire [COUNT_BITS-1:0] count_bottom;\nwire [COUNT_BITS-1:0] count_bottom_part [NUM_CHUNKS-1:0];\n\nwire bit_flip;\n\nreg [COUNT_BITS-1:0] count_bottom_d1;\nreg                  no_flip_bottom_d1;\nreg                  data_in_bottom_d1;\n\ngenvar chunk;\ngenvar chunkT;\ngenvar chunkB;\ngenerate\n\n    assign no_flip[0] = &( {data_in[GRANULARITY-1:0],data_in_bottom_d1}) ||\n                        &(~{data_in[GRANULARITY-1:0],data_in_bottom_d1});\n\n    for(chunk=1; chunk<NUM_CHUNKS-1; chunk=chunk+1) begin : no_flip_gen\n        assign no_flip[chunk]    =  &( data_in[(chunk+1)*(GRANULARITY)-1:chunk*(GRANULARITY)-1]) ||\n                                    &(~data_in[(chunk+1)*(GRANULARITY)-1:chunk*(GRANULARITY)-1]);\n    end\n\n    assign no_flip[NUM_CHUNKS-1] =  &( data_in[LANE_WIDTH-1:(NUM_CHUNKS-1)*(GRANULARITY)-1]) ||\n                                    &(~data_in[LANE_WIDTH-1:(NUM_CHUNKS-1)*(GRANULARITY)-1]);\n\n\n    assign still_counting_top[0] = no_flip[0];\n    assign count_top_part[0]     = (no_flip[0] ? GRANULARITY : 0);\n\n    for(chunkT=1; chunkT<NUM_CHUNKS; chunkT=chunkT+1) begin : count_top_gen\n        assign still_counting_top[chunkT]   = still_counting_top[chunkT-1] && no_flip[chunkT];\n        assign count_top_part[chunkT]       = (still_counting_top[chunkT] ? GRANULARITY : 0) + count_top_part[chunkT-1];\n    end\n\n    assign count_top = (still_counting_top[NUM_CHUNKS-1] ? LANE_WIDTH :             count_top_part[NUM_CHUNKS-2]) +                     (no_flip[0] ? (count_bottom_d1 == 0 ? 1 : count_bottom_d1) : 0); assign still_counting_bottom[0] = no_flip[NUM_CHUNKS-1];\n    assign count_bottom_part[0]     = 0;\n\n    for(chunkB=1; chunkB<NUM_CHUNKS; chunkB=chunkB+1) begin : count_bottom_gen\n        assign still_counting_bottom[chunkB] = still_counting_bottom[chunkB-1] && no_flip[NUM_CHUNKS-1-chunkB];\n        assign count_bottom_part[chunkB]     = (still_counting_bottom[chunkB] ? GRANULARITY : 0) + count_bottom_part[chunkB-1];\n    end\n\n    assign count_bottom = still_counting_bottom[NUM_CHUNKS-1] ? LANE_WIDTH + (count_bottom_d1 == 0 ? 1 : count_bottom_d1) : count_bottom_part[NUM_CHUNKS-2] +                                     (no_flip[NUM_CHUNKS-1] ? (REM_BITS ? REM_BITS : GRANULARITY) + 1 : 0);    endgenerate\n\nassign bit_flip = count_top > (RUN_LIMIT - (GRANULARITY-1) - (REM_BITS ? REM_BITS-1 : GRANULARITY-1));\n\n`ifdef ASYNC_RES\nalways @(posedge clk or negedge res_n)  begin `else\nalways @(posedge clk)  begin `endif\n    if (!res_n) begin\n        count_bottom_d1   <= { COUNT_BITS {1'b0}};\n        no_flip_bottom_d1 <= 1'b0;\n        data_in_bottom_d1 <= 1'b0;\n        rf_bit_flip       <= 1'b0;\n        data_out          <= {LANE_WIDTH{1'b0}};\n    end else begin\n        count_bottom_d1   <= count_bottom;\n        no_flip_bottom_d1 <= no_flip[NUM_CHUNKS-1];\n        data_in_bottom_d1 <= data_in[LANE_WIDTH-1];\n\n        if (enable && bit_flip) begin\n            data_out    <= {data_in[LANE_WIDTH-1:1], ~data_in[0]};\n            rf_bit_flip <= bit_flip;\n        end else begin\n            data_out    <= data_in;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "tx_run_length_limiter #",
        "module_hash": "b22774b1f10999e5adbdce398e85558d",
        "dataset_index": 18594
      },
      "small_fifo_b3a3e4e4": {
        "rtl_code": "\nmodule small_fifo(\n    input [31:0] data,\n    input inclock,\n    input outclock,\n    input outclocken,\n    output reg [31:0] q,\n    input [4:0] rdaddress,\n    input [4:0] wraddress,\n    input wren\n);\n\n    parameter DEPTH = 16;\n    parameter WIDTH = 32;\n\n    reg [WIDTH-1:0] mem [DEPTH-1:0];\n    reg [4:0] read_ptr, write_ptr;\n    reg empty, full;\n\n    wire new_empty = (read_ptr == write_ptr);\n    wire new_full = (write_ptr == read_ptr - 1);\n\n    always @(posedge inclock) begin\n        if (wren && !full) begin\n            mem[write_ptr] <= data;\n            write_ptr <= (write_ptr == DEPTH-1) ? 0 : write_ptr + 1;\n        end\n        empty <= new_empty;\n        full <= new_full;\n    end\n\n    always @(posedge outclock) begin\n        if (outclocken && !empty) begin\n            q <= mem[read_ptr];\n            read_ptr <= (read_ptr == DEPTH-1) ? 0 : read_ptr + 1;\n        end            \n    end\n\nendmodule",
        "module_name": "small_fifo",
        "module_hash": "b3a3e4e4a8391759a94aa260f5cb8ccb",
        "dataset_index": 3504
      },
      "top__60372a96": {
        "rtl_code": "module top_module (\n    input [3:0] a,\n    input [3:0] b,\n    input select,\n    input CLK,\n    input RST,\n    input UP,\n    input LD,\n    input [3:0] D,\n    output [3:0] final_output\n);\n\n    wire [3:0] binary_sum;\n    wire [3:0] counter_output;\n\n    binary_adder binary_adder_inst (\n        .a(a),\n        .b(b),\n        .sum(binary_sum)\n    );\n\n    up_down_counter up_down_counter_inst (\n        .CLK(CLK),\n        .RST(RST),\n        .UP(UP),\n        .LD(LD),\n        .D(D),\n        .Q(counter_output)\n    );\n\n    assign final_output = select ? counter_output : binary_sum;\n\nendmodule\n\nmodule binary_adder (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n\n    always @(*) begin\n        sum = a + b;\n        if (sum > 15) begin\n            sum = sum[3:0];\n        end\n    end\n\nendmodule\n\nmodule up_down_counter (\n    input CLK,\n    input RST,\n    input UP,\n    input LD,\n    input [3:0] D,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 0;\n        end else if (UP) begin\n            Q <= Q + 1;\n        end else if (LD) begin\n            Q <= Q - 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "60372a969667ca8ba2cbd3b48103fef5",
        "dataset_index": 21076
      },
      "shift_mux_xor_64999183": {
        "rtl_code": "\nmodule shift_mux_xor (\n    input clk,\n    input [255:0] in, // 256-bit input for the shift register\n    output [7:0] q // 8-bit output from the XOR gate\n);\n\n    // Define the 256-bit shift register\n    reg [255:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[254:0], in[0]};\n    end\n\n    // Define the 8-to-1 multiplexer\n    reg [7:0] mux_inputs [7:0];\n    always @(*) begin\n        mux_inputs[0] = 8'h01;\n        mux_inputs[1] = 8'h02;\n        mux_inputs[2] = 8'h04;\n        mux_inputs[3] = 8'h08;\n        mux_inputs[4] = 8'h10;\n        mux_inputs[5] = 8'h20;\n        mux_inputs[6] = 8'h40;\n        mux_inputs[7] = 8'h80;\n    end\n    reg [2:0] counter;\n    always @(posedge clk) begin\n        counter <= counter + 1;\n    end\n    wire [7:0] mux_output;\n    assign mux_output = mux_inputs[counter];\n\n    // Define the XOR gate\n    wire [255:0] xor_input;\n    assign xor_input = {shift_reg[255], shift_reg[127], shift_reg[63], shift_reg[31], shift_reg[15], shift_reg[7], shift_reg[3], shift_reg[1]};\n    assign q = xor_input[7] ^ xor_input[6] ^ xor_input[5] ^ xor_input[4] ^ xor_input[3] ^ xor_input[2] ^ xor_input[1] ^ xor_input[0];\n\nendmodule\nmodule top_module (\n    input clk,\n    input [255:0] in, // 256-bit input for the shift register\n    output [7:0] q // 8-bit output from the XOR gate\n);\n\n    shift_mux_xor smx (.clk(clk), .in(in), .q(q));\n\nendmodule",
        "module_name": "shift_mux_xor",
        "module_hash": "649991832bd20dca811de432728bc84c",
        "dataset_index": 11946
      },
      "arithmetic__59d65471": {
        "rtl_code": "module arithmetic_module #(parameter WIDTH=32)\n  (input [1:0] op,\n   input [WIDTH-1:0] a,\n   input [WIDTH-1:0] b,\n   output reg [WIDTH-1:0] out);\n\n  always @(*) begin\n    case (op)\n      2'b00: out = a + b; // addition\n      2'b01: out = a - b; // subtraction\n      2'b10: out = a * b; // multiplication\n      2'b11: out = a / b; // division\n    endcase\n  end\n\nendmodule",
        "module_name": "arithmetic_",
        "module_hash": "59d65471deb9400b5cd58eab3be2202d",
        "dataset_index": 21264
      },
      "barrel_shifter_387d54d1": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] data,\n    input [1:0] shift,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case(shift)\n            2'b00: result = data; // no shift\n            2'b01: result = {data[2:0], data[3]}; // right shift\n            2'b10: result = {data[3], data[2:0]}; // left shift\n            2'b11: result = {data[0], data[3:1]}; // rotate left\n        endcase\n    end\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "387d54d1bbbeee1d38a7bf3ac21f2ead",
        "dataset_index": 8663
      },
      "axis_adder #_e0ecd527": {
        "rtl_code": "\n\nmodule axis_adder #\n(\n  parameter integer AXIS_TDATA_WIDTH = 32,\n  parameter         AXIS_TDATA_SIGNED = \"FALSE\"\n)\n(\n  input  wire                        aclk,\n\n  output wire                        s_axis_a_tready,\n  input  wire [AXIS_TDATA_WIDTH-1:0] s_axis_a_tdata,\n  input  wire                        s_axis_a_tvalid,\n\n  output wire                        s_axis_b_tready,\n  input  wire [AXIS_TDATA_WIDTH-1:0] s_axis_b_tdata,\n  input  wire                        s_axis_b_tvalid,\n\n  input  wire                        m_axis_tready,\n  output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,\n  output wire                        m_axis_tvalid\n);\n\n  wire [AXIS_TDATA_WIDTH-1:0] int_tdata_wire;\n  wire int_tready_wire, int_tvalid_wire;\n\n  generate\n    if(AXIS_TDATA_SIGNED == \"TRUE\")\n    begin : SIGNED\n      assign int_tdata_wire = $signed(s_axis_a_tdata) + $signed(s_axis_b_tdata);\n    end\n    else\n    begin : UNSIGNED\n      assign int_tdata_wire = s_axis_a_tdata + s_axis_b_tdata;\n    end\n  endgenerate\n\n  assign int_tvalid_wire = s_axis_a_tvalid & s_axis_b_tvalid;\n  assign int_tready_wire = int_tvalid_wire & m_axis_tready;\n\n  assign s_axis_a_tready = int_tready_wire;\n  assign s_axis_b_tready = int_tready_wire;\n  assign m_axis_tdata = int_tdata_wire;\n  assign m_axis_tvalid = int_tvalid_wire;\n\nendmodule\n",
        "module_name": "axis_adder #",
        "module_hash": "e0ecd52784b207b86ca14f9b333bab80",
        "dataset_index": 24152
      },
      "AdlerChecksum #_802368c5": {
        "rtl_code": "module AdlerChecksum #(\n    parameter n = 16 // number of 8-bit data signals\n)(\n    input [n*8-1:0] data_in,\n    input [15:0] checksum,\n    output reg [15:0] checksum_result,\n    output reg data_valid,       // Signal to indicate valid data\n    output reg error_detected,   // Signal to indicate an error (checksum mismatch)\n    input clk\n);\n\nreg [7:0] A;\nreg [7:0] B;\ninteger i;\n\nalways @(posedge clk) begin\n    A <= 1;  // Initialize A to 1 at every clock cycle start\n    B <= 1;  // Initialize B to 1 at every clock cycle start\n    for (i = 0; i < n; i = i + 1) begin\n        A <= (A + data_in[i*8 +: 8]) % 251;  // Modular addition in Adler-32 algorithm\n        B <= (B + A) % 251;                  // Modular addition in Adler-32 algorithm\n    end\n    checksum_result <= (B << 8) | A;  // Combine B and A to form the checksum\nend\n\n// Logic to handle valid and invalid data\nalways @(posedge clk) begin\n    if (checksum_result == checksum) begin\n        // Checksum matches, data is valid\n        data_valid <= 1'b1;\n        error_detected <= 1'b0; // No error detected\n    end else begin\n        // Checksum does not match, data is invalid\n        data_valid <= 1'b0;\n        error_detected <= 1'b1; // Error detected\n    end\nend\n\nendmodule\n",
        "module_name": "AdlerChecksum #",
        "module_hash": "802368c5fc12a72e3809907e81defb89",
        "dataset_index": 17358
      },
      "bin2gray_1f35655c": {
        "rtl_code": "module bin2gray (\n  input [3:0] in,\n  output reg [3:0] out\n);\n\n  always @(*) begin\n    out[3] = in[3];\n    out[2] = in[3] ^ in[2];\n    out[1] = in[2] ^ in[1];\n    out[0] = in[1] ^ in[0];\n  end\n\nendmodule\n",
        "module_name": "bin2gray",
        "module_hash": "1f35655c3b7d278f7692155a14f44658",
        "dataset_index": 15930
      },
      "top__bdcafd58": {
        "rtl_code": "module top_module (\n    input clk,\n    input [3:0] data_in,\n    input load,\n    input EN,\n    output [7:0] final_output\n);\n\nreg [3:0] data_out;\nreg [3:0] COUNT;\nwire [7:0] concat_output;\n\nshift_register sr (\n    .clk(clk),\n    .data_in(data_in),\n    .load(load),\n    .data_out(data_out)\n);\n\nbinary_counter bc (\n    .clk(clk),\n    .EN(EN),\n    .RST(1'b0),\n    .COUNT(COUNT)\n);\n\nfunctional_module fm (\n    .data_out(data_out),\n    .COUNT(COUNT),\n    .final_output(concat_output)\n);\n\nassign final_output = concat_output;\n\nendmodule\n\nmodule shift_register (\n    input clk,\n    input [3:0] data_in,\n    input load,\n    output reg [3:0] data_out\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        data_out <= data_in;\n    end else begin\n        data_out <= {data_out[2:0], 1'b0};\n    end\nend\n\nendmodule\n\nmodule binary_counter (\n    input clk,\n    input EN,\n    input RST,\n    output reg [3:0] COUNT\n);\n\nalways @(posedge clk or negedge RST) begin\n    if (!RST) begin\n        COUNT <= 4'b0000;\n    end else if (EN) begin\n        COUNT <= COUNT + 1;\n    end\nend\n\nendmodule\n\nmodule functional_module (\n    input [3:0] data_out,\n    input [3:0] COUNT,\n    output reg [7:0] final_output\n);\n\nalways @(data_out or COUNT) begin\n    final_output <= {COUNT, data_out};\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "bdcafd5893d7b759f48df43f8b5a837d",
        "dataset_index": 11164
      },
      "encoderDCAC_30973064": {
        "rtl_code": "\n\n\nmodule encoderDCAC(clk,\n\t\t\t\t\t\ten,\nlasti,\tfirst_blocki,   comp_numberi,   comp_firsti,    comp_colori,    comp_lastinmbi, stb,\t\tzdi,\t\tfirst_blockz,  zds,\t\tlast,\t\tdo,\n\t\t\t\t\t\tdv\n\t\t\t\t\t\t);\n    input\t\t clk;\n    input\t\t en;\ninput\t\t lasti;\n    input       first_blocki;   input [2:0] comp_numberi;   input       comp_firsti;    input       comp_colori;    input       comp_lastinmbi; input\t\t stb;\n    input [12:0] zdi;\n    input       first_blockz;  input \t\t zds;\n\n    output\t\t  last;\n\n\t output\t[15:0]\tdo;\n\t output\t\t\t\tdv;\n\nreg\t\t\tlast;\n\nreg  [12:0]   dc_mem[7:0];\n    reg  [12:0]   dc_diff0, dc_diff;\n    wire [11:0]   dc_diff_limited=  (dc_diff[12]==dc_diff[11])? dc_diff[11:0] : {~dc_diff[11],{11{dc_diff[11]}}}; reg  [12:0]   dc_restored; reg  [5:0]\t\trll_cntr;\n\t reg [15:0]\t\tdo;\nreg\t\t\t\tdv;\n\nreg\t[5:0]\tcntr;\nreg\t[11:0] ac_in;\n\n\t wire\t\t\tizero=(ac_in[11:0]==12'b0);\n\n\t reg\t[14:0] val_r;\treg\t\t\t DCACen;\twire\t\t\t rll_out;\nwire\t\t\t pre_dv;\n\t reg\t\t\t was_nonzero_AC;\n    reg  [12:0] zdi_d;\n    reg   [3:0] zds_d;\nwire        DC_tosend=  zds_d[2];\n    wire        pre_DCACen= zds_d[1];\n\n    wire  [2:0] comp_numbero;   wire        comp_firsto;    wire        comp_coloro;    wire        comp_lastinmbo; wire        lasto;          reg   [2:0] block_mem_ra;\n    reg   [2:0] block_mem_wa;\n    reg   [2:0] block_mem_wa_save;\n    reg   [6:0] block_mem[0:7];\n    wire  [6:0] block_mem_o=block_mem[block_mem_ra[2:0]];\n    assign      comp_numbero[2:0]= block_mem_o[2:0];\n    assign      comp_firsto=      block_mem_o[3];\n    assign      comp_coloro=       block_mem_o[4];\nassign      comp_lastinmbo=    block_mem_o[5];\n    assign      lasto=             block_mem_o[6];\n    always @ (posedge clk) begin\n      if (stb) block_mem[block_mem_wa[2:0]] <= {lasti, comp_lastinmbi,  comp_colori,comp_firsti,comp_numberi[2:0]};\n      if      (!en) block_mem_wa[2:0] <= 3'h0;\n      else if (stb) block_mem_wa[2:0] <= block_mem_wa[2:0] +1;\n\n      if (stb && first_blocki) block_mem_wa_save[2:0] <= block_mem_wa[2:0];\n\n      if      (!en) block_mem_ra[2:0] <= 3'h0;\n      else if (zds) block_mem_ra[2:0] <= first_blockz?block_mem_wa_save[2:0]:(block_mem_ra[2:0] +1);\n    end\n\n    assign\t rll_out= ((val_r[12] && !val_r[14]) || (ac_in[11:0]!=12'b0)) && (rll_cntr[5:0]!=6'b0);\n\n\t assign\t pre_dv=rll_out || val_r[14] || was_nonzero_AC;\n\n\t always @ (posedge clk) begin\n\t    val_r[14:0] <={ DC_tosend?\n\t\t\t\t\t\t    {en,\n                       comp_coloro,\n                       comp_lastinmbo && lasto, dc_diff_limited[11:0]}:\n\t\t\t\t\t\t    {2'b0,\n\t\t\t\t\t\t\t  (cntr[5:0]==6'h3f),\n\t\t\t\t\t\t\t  ac_in[11:0]}}; \n\t\t was_nonzero_AC <= en && (ac_in[11:0]!=12'b0) && DCACen;\n\t\t if (pre_dv) do <= rll_out? {3'b0,val_r[12],6'b0,rll_cntr[5:0]}:{1'b1,val_r[14:0]};\n \t\t dv\t<= pre_dv;\n\t \t DCACen\t<= en && (pre_DCACen || (DCACen && (cntr[5:0]!=6'h3f)));\tif (!DCACen) cntr[5:0] <=6'b0;\n\t\t else\t\t\t  cntr[5:0] <=cntr[5:0]+1;\n\t end\n\n\t always @ (posedge clk) begin\n      zdi_d[12:0] <= zdi[12:0];\n      ac_in[11:0] <= (zdi_d[12]==zdi_d[11])? zdi_d[11:0]:{~zdi_d[11],{11{zdi_d[11]}}};  if (DC_tosend || !izero || !DCACen) rll_cntr[5:0]\t<= 6'h0;\n\t\telse if (DCACen) rll_cntr[5:0]\t<= rll_cntr[5:0] +1 ;\n      if (DC_tosend) last <= lasto;\n\t end\n\nalways @ (posedge clk) begin\n      zds_d[3:0]           <= {zds_d[2:0], zds};\n\t \tif (zds_d[0])   dc_diff0[12:0] <= comp_firsto?13'b0:dc_mem[comp_numbero[2:0]];\n\t\tif (zds_d[1])   dc_diff [12:0] <= zdi_d[12:0]-dc_diff0[12:0];\n      if (zds_d[2])   dc_restored[12:0] <=  dc_diff0[12:0] + {dc_diff_limited[11],dc_diff_limited[11:0]};\n      if (zds_d[3])   dc_mem[comp_numbero[2:0]]   <= dc_restored[12:0];\n\t end\n\n\nendmodule\n",
        "module_name": "encoderDCAC",
        "module_hash": "30973064e2269ebc542b7f319dbbc32d",
        "dataset_index": 15761
      },
      "altera_up_av_config_auto_init_1676f342": {
        "rtl_code": "\n\n\n\nmodule altera_up_av_config_auto_init (\n\tclk,\n\treset,\n\n\tclear_error,\n\n\tack,\n\ttransfer_complete,\n\n\trom_data,\n\n\tdata_out,\n\ttransfer_data,\n\n\trom_address,\n\t\n\tauto_init_complete,\n\tauto_init_error,\n);\n\n\n\nparameter ROM_SIZE\t= 50;\n\nparameter AW\t\t\t= 5;\t\tparameter DW\t\t\t= 23;\t\t\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t\t\t\tclear_error;\n\ninput\t\t\t\t\t\tack;\ninput\t\t\t\t\t\ttransfer_complete;\n\ninput\t\t\t[DW: 0]\trom_data;\n\noutput reg\t[DW: 0]\tdata_out;\noutput reg\t\t\t\ttransfer_data;\n\noutput reg\t[AW: 0]\trom_address;\n\noutput reg\t\t\t\tauto_init_complete;\noutput reg\t\t\t\tauto_init_error;\n\n\n\n\n\nwire\t\t\t\t\t\ttoggle_next_transfer;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tdata_out <= 'h0;\n\telse\n\t\tdata_out <= rom_data;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\ttransfer_data <= 1'b0;\n\telse if (auto_init_complete | transfer_complete)\n\t\ttransfer_data <= 1'b0;\n\telse\n\t\ttransfer_data <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\trom_address <= 'h0;\n\telse if (toggle_next_transfer)\n\t\trom_address <= rom_address + 'h1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tauto_init_complete <= 1'b0;\n\telse if (toggle_next_transfer & (rom_address == (ROM_SIZE - 1)))\n\t\tauto_init_complete <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tauto_init_error <= 1'b0;\n\telse if (toggle_next_transfer & ack)\n\t\tauto_init_error <= 1'b1;\n\telse if (clear_error)\n\t\tauto_init_error <= 1'b0;\nend\n\n\n\nassign toggle_next_transfer = transfer_data & transfer_complete;\n\n\n\n\nendmodule\n\n",
        "module_name": "altera_up_av_config_auto_init",
        "module_hash": "1676f342502953254418f6ac08b4a9b5",
        "dataset_index": 22132
      },
      "MISTRAL_ALUT6_0e6ced1d": {
        "rtl_code": "\n\n\nmodule MISTRAL_ALUT6(input A, B, C, D, E, F, output Q);\n\nparameter [63:0] LUT = 64'h0000_0000_0000_0000;\n\n`ifdef cyclonev\nspecify\n    (A => Q) = 605;\n    (B => Q) = 583;\n    (C => Q) = 510;\n    (D => Q) = 512;\n    (E => Q) = 400;\n    (F => Q) = 97;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    (A => Q) = 275;\n    (B => Q) = 272;\n    (C => Q) = 175;\n    (D => Q) = 165;\n    (E => Q) = 162;\n    (F => Q) = 53;\nendspecify\n`endif\n\nassign Q = LUT >> {F, E, D, C, B, A};\n\nendmodule\n\n\n\nmodule MISTRAL_ALUT5(input A, B, C, D, E, output Q);\n\nparameter [31:0] LUT = 32'h0000_0000;\n\n`ifdef cyclonev\nspecify\n    (A => Q) = 583;\n    (B => Q) = 510;\n    (C => Q) = 512;\n    (D => Q) = 400;\n    (E => Q) = 97;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    (A => Q) = 272;\n    (B => Q) = 175;\n    (C => Q) = 165;\n    (D => Q) = 162;\n    (E => Q) = 53;\nendspecify\n`endif\n\nassign Q = LUT >> {E, D, C, B, A};\n\nendmodule\n\n\n\nmodule MISTRAL_ALUT4(input A, B, C, D, output Q);\n\nparameter [15:0] LUT = 16'h0000;\n\n`ifdef cyclonev\nspecify\n    (A => Q) = 510;\n    (B => Q) = 512;\n    (C => Q) = 400;\n    (D => Q) = 97;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    (A => Q) = 175;\n    (B => Q) = 165;\n    (C => Q) = 162;\n    (D => Q) = 53;\nendspecify\n`endif\n\nassign Q = LUT >> {D, C, B, A};\n\nendmodule\n\n\n\nmodule MISTRAL_ALUT3(input A, B, C, output Q);\n\nparameter [7:0] LUT = 8'h00;\n\n`ifdef cyclonev\nspecify\n    (A => Q) = 510;\n    (B => Q) = 400;\n    (C => Q) = 97;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    (A => Q) = 165;\n    (B => Q) = 162;\n    (C => Q) = 53;\nendspecify\n`endif\n\nassign Q = LUT >> {C, B, A};\n\nendmodule\n\n\n\nmodule MISTRAL_ALUT2(input A, B, output Q);\n\nparameter [3:0] LUT = 4'h0;\n\n`ifdef cyclonev\nspecify\n    (A => Q) = 400;\n    (B => Q) = 97;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    (A => Q) = 162;\n    (B => Q) = 53;\nendspecify\n`endif\n\nassign Q = LUT >> {B, A};\n\nendmodule\n\n\n\nmodule MISTRAL_NOT(input A, output Q);\n\n`ifdef cyclonev\nspecify\n    (A => Q) = 97;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    (A => Q) = 53;\nendspecify\n`endif\n\nassign Q = ~A;\n\nendmodule\n\n\nmodule MISTRAL_ALUT_ARITH(input A, B, C, D0, D1,  input CI, output SO,  output CO);\n\nparameter LUT0 = 16'h0000;\nparameter LUT1 = 16'h0000;\n\n`ifdef cyclonev\nspecify\n    (A  => SO) = 1342;\n    (B  => SO) = 1323;\n    (C  => SO) = 927;\n    (D0 => SO) = 887;\n    (D1 => SO) = 785;\n    (CI => SO) = 368;\n\n    (A  => CO) = 1082;\n    (B  => CO) = 1062;\n    (C  => CO) = 813;\n    (D0 => CO) = 866;\n    (D1 => CO) = 1198;\n    (CI => CO) = 36; endspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    (A  => SO) = 644;\n    (B  => SO) = 477;\n    (C  => SO) = 416;\n    (D0 => SO) = 380;\n    (D1 => SO) = 431;\n    (CI => SO) = 276;\n\n    (A  => CO) = 525;\n    (B  => CO) = 433;\n    (C  => CO) = 712;\n    (D0 => CO) = 653;\n    (D1 => CO) = 593;\n    (CI => CO) = 16;\nendspecify\n`endif\n\nwire q0, q1;\n\nassign q0 = LUT0 >> {D0, C, B, A};\nassign q1 = LUT1 >> {D1, C, B, A};\n\nassign {CO, SO} = q0 + !q1 + CI;\n\nendmodule\n\n\n\n",
        "module_name": "MISTRAL_ALUT6",
        "module_hash": "0e6ced1db357f5fcb60cb1aa12a966be",
        "dataset_index": 9295
      },
      "add8bit_5f6e864c": {
        "rtl_code": "module add8bit (\n  input [7:0] A,\n  input [7:0] B,\n  input Cin,\n  output Cout,\n  output [7:0] C\n);\n\n  wire [7:0] S;\n  wire [7:0] C1;\n  wire [7:0] C2;\n\n  // Full adder logic\n  assign S = A ^ B ^ Cin;\n  assign C1 = A & B;\n  assign C2 = Cin & (A ^ B);\n  assign Cout = C1 | C2;\n\n  assign C = S;\n\nendmodule",
        "module_name": "add8bit",
        "module_hash": "5f6e864c75fccfdfaa70d492282b0b28",
        "dataset_index": 2538
      },
      "add_sub_and_bfe2e451": {
        "rtl_code": "module add_sub_and (\n    input wire [7:0] in1,\n    input wire [7:0] in2,\n    input wire ctrl,\n    output wire [7:0] out,\n    output wire [7:0] out_and\n);\n\n    wire [7:0] add_in;\n    wire [7:0] sub_in;\n    wire [7:0] add_out;\n    wire [7:0] and_out;\n\n    // 2-to-1 multiplexer to select input based on control input\n    mux2to1 mux (\n        .in0(in1),\n        .in1(in2),\n        .sel(ctrl),\n        .out(add_in)\n    );\n\n    assign sub_in = in2; // Assign sub_in to in2 for subtraction\n\n    // 8-bit adder to perform addition or subtraction\n    adder8 adder (\n        .in1(add_in),\n        .in2(sub_in),\n        .sub(ctrl),\n        .out(add_out)\n    );\n\n    // Bitwise AND module to perform AND operation on inputs\n    and8 and_gate (\n        .in1(in1),\n        .in2(in2),\n        .out(and_out)\n    );\n\n    assign out = add_out;\n    assign out_and = and_out;\n\nendmodule\n\nmodule mux2to1 (\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sel == 1'b0)\n            out = in0;\n        else\n            out = in1;\n    end\nendmodule\n\nmodule adder8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    input sub,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sub)\n            out = in1 - in2;\n        else\n            out = in1 + in2;\n    end\nendmodule\n\nmodule and8 (\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] out\n);\n    always @* begin\n        out = in1 & in2;\n    end\nendmodule",
        "module_name": "add_sub_and",
        "module_hash": "bfe2e451d60d262951c002fc61fe2cba",
        "dataset_index": 11676
      },
      "ROM_reader_2a156d37": {
        "rtl_code": "module ROM_reader(\n    input [3:0] address,\n    input read,\n    input clk,\n    output reg [7:0] data_out\n);\n\nparameter ROM_SIZE = 16;\n\nreg [7:0] rom [0:ROM_SIZE-1];\n\ninitial begin\n    rom[0] = 8'h01;\n    rom[1] = 8'h02;\n    rom[2] = 8'h03;\n    rom[3] = 8'h04;\n    rom[4] = 8'h05;\n    rom[5] = 8'h06;\n    rom[6] = 8'h07;\n    rom[7] = 8'h08;\n    rom[8] = 8'h09;\n    rom[9] = 8'h0A;\n    rom[10] = 8'h0B;\n    rom[11] = 8'h0C;\n    rom[12] = 8'h0D;\n    rom[13] = 8'h0E;\n    rom[14] = 8'h0F;\n    rom[15] = 8'h10;\nend\n\nalways @(posedge clk) begin\n    if (read && address < ROM_SIZE) begin\n        data_out <= rom[address];\n    end\nend\n\nendmodule",
        "module_name": "ROM_reader",
        "module_hash": "2a156d37ee08aa927a415ba6af4f4141",
        "dataset_index": 9808
      },
      "dlp_reg_864bdacc": {
        "rtl_code": "\n\nmodule dlp_reg\n  (\n   input  \thb_clk,         \n   input \thb_rstn,        \n   input        dlp_rstn_hb,    input [8:2] \thb_adr,         \n   input \thb_wstrb,       \n   input [3:0] \thb_ben,         \n   input \thb_csn,       \t\n   input [31:0] hb_din,         \n   input [8:2] \tde_adr,         \n   input \tde_wstrb,       \n   input [3:0] \tde_ben,         \n   input \tde_csn,       \t\n   input [31:0] de_din,         \n   input \tactv_stp,       \n   input \tnext_dle,       \n   input \tcmd_ack,        \n   input        reset_wait,     input [3:0]  dlp_offset,     output reg [27:0] hb_addr,    \n   output reg [27:0] hb_end,     \n   output \t hb_fmt,         \n   output \t hb_wc,          \n   output \t hb_sen,         \n   output \t hb_stp,         \n   output reg\t dlp_actv_2,     \n   output \t dl_idle,        \n   output reg\t hold_start,     \n   output reg \t cmd_rdy_ld,     \n   output \t wcf,            \n   output reg    [4:0]  dlp_wcnt \n   );\n  \n  `define DLP_BURST_SIZE 28'h8\n  `define DLP_BURST_SIZE_M1 5'h7\n\n  reg signed [28:0] \tremainder;\n  reg \t\tdl_cmd_strb;    \n  reg \t\tstart_strobe;   \n  reg [27:0] \thb_addr1;     \n  reg [27:0] \thb_end1;      \n  reg \t\twc1;          \n  reg [3:0] \thb_cntrl_w1;  \n  reg \t\twc2;          \n  reg [3:0] \thb_cntrl_w2;  \n  reg [1:0] \tadr_cntrl2;   \n  reg [1:0] \tadr_cntrl1;   \n  \n  wire \t\tnext_stp;       \n  wire \t\ttoggle_out;     \n  wire \t\tdlp_hb_w;       \n  wire \t\tdlp_de_w;       \n  wire \t\tstart_strobe_comb;\n  \n  parameter \tDLCNT_DLADR\t= 6'b0_1111_1;\t\n\n  always @(posedge hb_clk or negedge hb_rstn) begin\n    if (!hb_rstn)            cmd_rdy_ld <= 1'b0;\n    else if (dlp_rstn_hb)    cmd_rdy_ld <= 1'b0;\n    else if (dl_cmd_strb || start_strobe && dl_idle)  cmd_rdy_ld <= 1'b1;\n    else if (cmd_ack)        cmd_rdy_ld <= 1'b0;\n  end\n\n  \n  \n  \n  \n  assign dlp_hb_w = (hb_adr[8:3]==DLCNT_DLADR) && hb_wstrb && !hb_csn;\n  assign dlp_de_w = (de_adr[8:3]==DLCNT_DLADR) && de_wstrb && !de_csn;\n\n  assign start_strobe_comb = \t((dlp_hb_w & ~hb_ben[3] & ~hb_adr[2]) |\n\t\t\t\t (dlp_de_w & ~de_adr[2]));\n\n  wire \t \t stop_list;\n  assign \t stop_list = ~hb_cntrl_w2[3] && hb_cntrl_w1[3];\n\n  always @(posedge hb_clk) begin\n    if (!hb_rstn) begin\n      dl_cmd_strb  <= 1'b0;\n      hb_addr1     <= 28'b0;\n      hb_end1      <= 28'b0;\n      adr_cntrl1   <= 2'b0;\n      wc1          <= 1'b0;\n      hb_cntrl_w1  <= 4'b0;\n      hb_addr      <= 28'b0;\n      hb_end       <= 28'b0;\n      hb_cntrl_w2  <= 4'b1000;\n      start_strobe <= 1'b0;\n      adr_cntrl2   <= 2'b0;\n      wc2          <= 1'b0;\n      hold_start   <= 1'b0;\n       remainder   <= 0;\n    end else if (dlp_rstn_hb) begin\n      dl_cmd_strb  <= 1'b0;\n      start_strobe <= 1'b0;\n      hb_cntrl_w2  <= 4'b1000;\n      hold_start   <= 1'b0;\n       remainder   <= 0;\n    end else begin\n       remainder <= (hb_end - hb_addr);\n      if (start_strobe_comb) start_strobe <= 1'b1;\n      \n      \n      \n      if (dlp_hb_w && ~hb_adr[2]) begin\n\thold_start <= 1'b1;\n\tif(!hb_ben[0]) hb_addr1[3:0]   <= hb_din[7:4];\n\tif(!hb_ben[1]) hb_addr1[11:4]  <= hb_din[15:8];\n\tif(!hb_ben[2]) hb_addr1[19:12] <= hb_din[23:16];\n\tif(!hb_ben[3]) begin\n\t  hb_addr1[27:20] <= {dlp_offset, hb_din[27:24]};\n\tend\n\tif(!hb_ben[3]) adr_cntrl1      <= hb_din[30:29];\n\tif(!hb_ben[3]) wc1             <= hb_din[31];\n      end else if (dlp_de_w && ~de_adr[2]) begin\n\thold_start <= 1'b1;\n\tif(!de_ben[0]) hb_addr1[3:0]   <= de_din[7:4];\n\tif(!de_ben[1]) hb_addr1[11:4]  <= de_din[15:8];\n\tif(!de_ben[2]) hb_addr1[19:12] <= de_din[23:16];\n\tif(!de_ben[3]) begin\n\t  hb_addr1[27:20] <= {dlp_offset, de_din[27:24]};\n\tend\n\tif(!de_ben[3]) adr_cntrl1      <= de_din[30:29]; if(!de_ben[3]) wc1             <= de_din[31];\n      end\n      \n      \n      \n      \n      \n      \n      if (dlp_hb_w && hb_adr[2]) begin\n\tdl_cmd_strb <= ~hb_ben[3];\n\tif(!hb_ben[0]) hb_end1[3:0]     <= hb_din[7:4];\n\tif(!hb_ben[1]) hb_end1[11:4]    <= hb_din[15:8];\n\tif(!hb_ben[2]) hb_end1[19:12]   <= hb_din[23:16];\n\tif(!hb_ben[3]) begin\n\t  hb_end1[27:20]   <= {dlp_offset, hb_din[27:24]};\n\tend\n\tif(!hb_ben[3]) hb_cntrl_w1[3:0] <= hb_din[31:28];\n      end else if (dlp_de_w && de_adr[2]) begin \n\tdl_cmd_strb <= ~de_ben[3];\n\tif(!de_ben[0]) hb_end1[3:0]     <= de_din[7:4];\n\tif(!de_ben[1]) hb_end1[11:4]    <= de_din[15:8];\n\tif(!de_ben[2]) hb_end1[19:12]   <= de_din[23:16];\n\tif(!de_ben[3]) begin\n\t  hb_end1[27:20]   <= {dlp_offset, de_din[27:24]};\n\tend\n\tif(!de_ben[3]) hb_cntrl_w1[3:0] <= de_din[31:28];\n      end\n\n      \n      \n      \n      if (reset_wait) adr_cntrl2[0] <= 1'b0;\n\n      if (dl_cmd_strb && ~hold_start && stop_list && ~dl_idle) begin\n\thb_addr      <= hb_end1-28'h1;\n\tstart_strobe <= 1'b0;\n\tdl_cmd_strb  <= 1'b0;\n\tend else if (start_strobe && dl_idle) begin\n\thold_start   <= 1'b0;\n\tstart_strobe <= 1'b0;\n\thb_addr      <= hb_addr1;\n\tadr_cntrl2   <= adr_cntrl1;\n\twc2          <= wc1;\n      end else if (next_dle && ~dl_idle) \n\thb_addr      <= hb_addr + 28'h1;\n\n\n      if (dl_cmd_strb && ~hold_start)\n      begin\n\thb_end      <= hb_end1;\n\thb_cntrl_w2 <= hb_cntrl_w1;\n\tdl_cmd_strb <= 1'b0;\n      end \n      else if (dl_idle && ~start_strobe) \n\thb_cntrl_w2[3] <= 1'b1;\n\n    end end \n   always @*\n    if(remainder > `DLP_BURST_SIZE) dlp_wcnt = `DLP_BURST_SIZE_M1;\n    else dlp_wcnt = remainder -1'b1;\n      \n  \n  \n  \n  assign hb_fmt  = hb_cntrl_w2[1];\n  assign hb_sen  = hb_cntrl_w2[2];\n  assign hb_stp  = hb_cntrl_w2[3];\n  assign hb_wc   = wc2;\n  assign wcf     = adr_cntrl2[0];\n  \n  \n  \n  \n\n  reg dl_idle_hold;\n  \n  assign dl_idle = (hb_addr == hb_end) | dl_idle_hold; always @(posedge hb_clk, negedge hb_rstn) begin\n    if (!hb_rstn)            \t\t dl_idle_hold <= 1'b0;\n    else if (dl_cmd_strb && ~hold_start) dl_idle_hold <= 1'b0;\n    else if (hb_stp || dl_idle) \t dl_idle_hold <= 1'b1;\n  end\n\n  assign next_stp = hb_cntrl_w2[3];\n  assign toggle_out = dl_idle & ~next_stp;\n  \n  \n  \n  \n  always @(posedge hb_clk or negedge hb_rstn) begin\n    if(!hb_rstn)                     \t\t\t     dlp_actv_2 <= 1'b0;\n    else if(dlp_rstn_hb)             \t\t\t     dlp_actv_2 <= 1'b0;\n    else if ((dl_cmd_strb && ~hb_cntrl_w1[3]) || toggle_out) dlp_actv_2 <= 1'b1;\n    else if ((~actv_stp && dl_idle && next_stp) ||\n\t     (dl_cmd_strb && hb_cntrl_w1[3])) \t\t     dlp_actv_2 <= 1'b0;\n  end\n\nendmodule\n",
        "module_name": "dlp_reg",
        "module_hash": "864bdacc0260585d90cfd23f2c59129a",
        "dataset_index": 8398
      },
      "decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_proc_sys_reset_fbba9f85": {
        "rtl_code": "\nmodule decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_proc_sys_reset (\n    input slowest_sync_clk,\n    input ext_reset_in,\n    input aux_reset_in,\n    input mb_debug_sys_rst,\n    input dcm_locked,\n    output mb_reset,\n    output [0:0]bus_struct_reset,\n    output [0:0]peripheral_reset,\n    output [0:0]interconnect_aresetn,\n    output [0:0]peripheral_aresetn\n);\n\n    reg mb_reset_reg = 1'b1;\n\n    assign bus_struct_reset = ext_reset_in | mb_debug_sys_rst;\n    assign peripheral_reset = aux_reset_in | mb_debug_sys_rst;\n    assign interconnect_aresetn = ~mb_debug_sys_rst;\n    assign peripheral_aresetn = ~mb_debug_sys_rst;\n\n    always @(posedge slowest_sync_clk) begin\n        if (dcm_locked == 1'b1) begin\n            if (mb_debug_sys_rst == 1'b1) begin\n                mb_reset_reg <= 1'b0;\n            end else begin\n                mb_reset_reg <= 1'b1;\n            end\n        end\n    end\n\n    assign mb_reset = mb_reset_reg;\n\nendmodule\n",
        "module_name": "decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_proc_sys_reset",
        "module_hash": "fbba9f85e5a7bf928a33d7d0175bc933",
        "dataset_index": 15113
      },
      "small_fifo_a_dpfifo_9ccf2d54": {
        "rtl_code": "\nmodule small_fifo_a_dpfifo (\n    clock,\n    data,\n    empty,\n    full,\n    q,\n    rreq,\n    sclr,\n    usedw,\n    wreq\n);\n\n    // Module inputs and outputs\n\n    input   clock;\n    input   [71:0]  data;\n    output   empty;\n    output   full;\n    output   [71:0]  q;\n    input   rreq;\n    input   sclr;\n    output   [2:0]  usedw;\n    input   wreq;\n\n    // Internal registers and wires\n\n    reg  [71:0]   mem [0:7];\n    reg  [2:0]   ptr_r;\n    reg  [2:0]   ptr_w;\n    reg  empty_reg;\n    reg  full_reg;\n    reg  [2:0]   usedw_reg;\n\n    // Combinational logic\n\n    assign empty = empty_reg;\n    assign full = full_reg;\n    assign q = mem[ptr_r];\n    assign usedw = usedw_reg;\n\n    // Sequential logic\n\n    always @(posedge clock) begin\n        if (sclr) begin\n            // Reset the FIFO\n            ptr_r <= 0;\n            ptr_w <= 0;\n            empty_reg <= 1;\n            full_reg <= 0;\n            usedw_reg <= 0;\n        end else begin\n            if (wreq & !full_reg) begin\n                // Write data to the FIFO\n                mem[ptr_w] <= data;\n                ptr_w <= ptr_w + 1;\n                usedw_reg <= usedw_reg + 1;\n                if (ptr_w == 8) begin\n                    ptr_w <= 0;\n                end\n                if (usedw_reg == 8) begin\n                    full_reg <= 1;\n                end\n                empty_reg <= 0;\n            end\n            if (rreq && !empty_reg) begin\n                // Read data from the FIFO\n                ptr_r <= ptr_r + 1;\n                usedw_reg <= usedw_reg - 1;\n                if (ptr_r == 8) begin\n                    ptr_r <= 0;\n                end\n                if (usedw_reg == 0) begin\n                    empty_reg <= 1;\n                end\n                full_reg <= 0;\n            end\n        end\n    end\n\nendmodule\n",
        "module_name": "small_fifo_a_dpfifo",
        "module_hash": "9ccf2d54e4b69eaa408a82be5e3a0189",
        "dataset_index": 4390
      },
      "mux4to1_ffb43319": {
        "rtl_code": "module mux4to1 (\n  input A,\n  input B,\n  input C,\n  input D,\n  input [1:0] S,\n  output Y\n);\n\n  wire notS0, notS1;\n\n  assign notS0 = ~S[0];\n  assign notS1 = ~S[1];\n\n  assign Y = (A & notS1 & notS0) | (B & notS1 & S[0]) | (C & S[1] & notS0) | (D & S[1] & S[0]);\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "ffb4331924a41ef6e3696d0abc1dd5fb",
        "dataset_index": 11003
      },
      "counter_0c0c265b": {
        "rtl_code": "module counter (\n    input clk,\n    input reset,\n    output reg [3:0] count_out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule mux (\n    input [3:0] d,\n    input [3:0] count_out,\n    input select,\n    output reg [3:0] mux_out\n);\n    always @(*) begin\n        if (select) begin\n            mux_out = d;\n        end else begin\n            mux_out = count_out;\n        end\n    end\nendmodule\n\nmodule adder (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n    always @(*) begin\n        sum = a + b;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] d,\n    input select,\n    output [3:0] final_out\n);\n    wire [3:0] count_out;\n    wire [3:0] mux_out;\n    wire [3:0] adder_out;\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .count_out(count_out)\n    );\n\n    mux mux_inst (\n        .d(d),\n        .count_out(count_out),\n        .select(select),\n        .mux_out(mux_out)\n    );\n\n    adder adder_inst (\n        .a(mux_out),\n        .b(count_out),\n        .sum(adder_out)\n    );\n\n    reg [3:0] final_out_reg;\n    always @(posedge clk) begin\n        final_out_reg <= adder_out;\n    end\n\n    assign final_out = final_out_reg;\nendmodule",
        "module_name": "counter",
        "module_hash": "0c0c265bd8886d1fc4330ff9c0c14bb0",
        "dataset_index": 16935
      },
      "inverted_5input_OR_gate_302d1e87": {
        "rtl_code": "module inverted_5input_OR_gate (\n  input p1,\n  input p2,\n  input p3,\n  input p4,\n  input p5,\n  output reg y\n);\n\n  always @(*) begin\n    if (p1 || p2 || p3 || p4 || p5) begin\n      y <= 0;\n    end else begin\n      y <= 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "inverted_5input_OR_gate",
        "module_hash": "302d1e877f10ee0d64d1ac7e39fd44d7",
        "dataset_index": 11368
      },
      "sky130_fd_sc_ls__clkdlyinv3sd3_49845758": {
        "rtl_code": "module sky130_fd_sc_ls__clkdlyinv3sd3 (\n    input A,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output Y\n);\n\n    wire inv1_out;\n    wire inv2_out;\n    wire inv3_out;\n    wire inv4_out;\n\n    assign inv1_out = ~VGND;\n    assign inv2_out = ~VNB;\n    assign inv3_out = ~VPB;\n    assign inv4_out = ~VPWR;\n\n    assign Y = (A & inv1_out & inv2_out & inv3_out & inv4_out);\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__clkdlyinv3sd3",
        "module_hash": "49845758bcc1a2826d5267a3ce4aad0a",
        "dataset_index": 19135
      },
      "buffer_97395462": {
        "rtl_code": "\nmodule buffer (\n    input VPWR,\n    input VGND,\n    output Z,\n    input A,\n    input TE_B\n);\n\n    // Local signals\n    wire u_vpwr_vgnd_out_A;\n\n    // Voltage level shifter\n    assign u_vpwr_vgnd_out_A = (VPWR & !VGND);\n    assign Z = TE_B ? u_vpwr_vgnd_out_A : 1'b0;\n\nendmodule",
        "module_name": "buffer",
        "module_hash": "97395462a22d24387d165b946c6aee75",
        "dataset_index": 6598
      },
      "pwm_a3bcdd91": {
        "rtl_code": "module pwm (\n  input clk,\n  input ctrl,\n  output reg pwm\n);\n\n  reg [7:0] duty_cycle = 8'h80; // initialize duty cycle to 50%\n  reg [7:0] counter = 8'h00; // initialize counter to 0\n  \n  always @(posedge clk) begin\n    if (counter == 8'hFF) begin\n      counter <= 8'h00;\n    end else begin\n      counter <= counter + 1;\n    end\n    \n    if (counter < duty_cycle) begin\n      pwm <= 1;\n    end else begin\n      pwm <= 0;\n    end\n  end\n  \n  always @(posedge clk) begin\n    if (ctrl > 8'hFF) begin\n      duty_cycle <= 8'hFF;\n    end else begin\n      duty_cycle <= ctrl;\n    end\n  end\n  \nendmodule",
        "module_name": "pwm",
        "module_hash": "a3bcdd91d98496196d70567445629ef8",
        "dataset_index": 4131
      },
      "sd_counter_358397b1": {
        "rtl_code": "`define CNT_TYPE_GRAY\n`define CNT_Q\n`define CNT_Q_BIN\n\n`define CNT_LENGTH 9\n\n`define CNT_SET_VALUE `CNT_LENGTH'h9\n\n`define CNT_WRAP_VALUE `CNT_LENGTH'h9\n\n`define CNT_CE\n\n`define LFSR_LENGTH `CNT_LENGTH\n\nmodule sd_counter\n  (\n`ifdef CNT_TYPE_GRAY\n    output reg [`CNT_LENGTH:1] q,\n`ifdef CNT_Q_BIN\n    output [`CNT_LENGTH:1]    q_bin,\n`endif\n`else\n`ifdef CNT_Q\n    output [`CNT_LENGTH:1]    q,\n`endif\n`endif\n`ifdef CNT_CLEAR\n    input clear,\n`endif\n`ifdef CNT_SET\n    input set,\n`endif\n`ifdef CNT_REW\n    input rew,\n`endif\n`ifdef CNT_CE\n    input cke,\n`endif\n`ifdef CNT_QNEXT\n    output [`CNT_LENGTH:1] q_next,\n`endif\n`ifdef CNT_Z\n    output z,\n`endif\n`ifdef CNT_ZQ\n    output reg zq,\n`endif\n    input clk,\n    input rst\n   );\n   \n`ifdef CNT_SET\n   parameter set_value = `CNT_SET_VALUE;\n`endif\n`ifdef CNT_WRAP\n   parameter wrap_value = `CNT_WRAP_VALUE;\n`endif\n\n   reg [`CNT_LENGTH:1] qi;\n   \n`ifdef CNT_QNEXT\n`else\n   wire [`CNT_LENGTH:1] q_next;   \n`endif\n`ifdef CNT_REW\n   wire [`CNT_LENGTH:1] q_next_fw;   \n   wire [`CNT_LENGTH:1] q_next_rew;   \n`endif\n\n`ifdef CNT_REW\n`else\n   assign q_next =\n`endif\n`ifdef CNT_REW\n     assign q_next_fw =\n`endif\n`ifdef CNT_CLEAR\n       clear ? `CNT_LENGTH'd0 :\n`endif\n`ifdef CNT_SET\n\t set ? set_value :\n`endif\n`ifdef CNT_WRAP\n\t   (qi == wrap_value) ? `CNT_LENGTH'd0 :\n`endif\n`ifdef CNT_TYPE_LFSR\n\t     {qi[8:1],~(q[`LFSR_LENGTH]^q[1])};\n`else\n   qi + `CNT_LENGTH'd1;\n`endif\n   \n`ifdef CNT_REW\n   assign q_next_rew =\n`ifdef CNT_CLEAR\n     clear ? `CNT_LENGTH'd0 :\n`endif\n`ifdef CNT_SET\n       set ? set_value :\n`endif\n`ifdef CNT_WRAP\n\t (qi == `CNT_LENGTH'd0) ? wrap_value :\n`endif\n`ifdef CNT_TYPE_LFSR\n\t   {~(q[1]^q[2]),qi[`CNT_LENGTH:2]};\n`else\n   qi - `CNT_LENGTH'd1;\n`endif\n`endif\n   \n`ifdef CNT_REW\n   assign q_next = rew ? q_next_rew : q_next_fw;\n`endif\n   \n   always @ (posedge clk or posedge rst)\n     if (rst)\n       qi <= `CNT_LENGTH'd0;\n     else\n`ifdef CNT_CE\n   if (cke)\n`endif\n     qi <= q_next;\n\n`ifdef CNT_Q\n`ifdef CNT_TYPE_GRAY\n   always @ (posedge clk or posedge rst)\n     if (rst)\n       q <= `CNT_LENGTH'd0;\n     else\n`ifdef CNT_CE\n       if (cke)\n`endif\n\t q <= (q_next>>1) ^ q_next;\n`ifdef CNT_Q_BIN\n   assign q_bin = qi;\n`endif\n`else\n   assign q = q_next;\n`endif\n`endif\n   \n`ifdef CNT_Z\n   assign z = (q == `CNT_LENGTH'd0);\n`endif\n\n`ifdef CNT_ZQ\n   always @ (posedge clk or posedge rst)\n     if (rst)\n       zq <= 1'b1;\n     else\n`ifdef CNT_CE\n       if (cke)\n`endif\n\t zq <= q_next == `CNT_LENGTH'd0;\n`endif\nendmodule\n",
        "module_name": "sd_counter",
        "module_hash": "358397b1273a7b770347c154b20aeaff",
        "dataset_index": 25444
      },
      "add4_b2dd399b": {
        "rtl_code": "module add4(A, B, S, Cout);\n  input [3:0] A, B;\n  output [3:0] S;\n  output Cout;\n\n  assign {Cout, S} = A + B;\n\nendmodule",
        "module_name": "add4",
        "module_hash": "b2dd399bc6088cf33373ad5fd3329766",
        "dataset_index": 15894
      },
      "inverter_gate_dcd29e11": {
        "rtl_code": "\nmodule inverter_gate (\n    input  A,\n    output Z,\n    input  TE,\n    input  VPB,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    wire inv_A;\n\n    assign inv_A = ~A;\n\n    assign Z = (TE) ? inv_A : VNB;\n\nendmodule",
        "module_name": "inverter_gate",
        "module_hash": "dcd29e11b597cd2505e47651450d0b1d",
        "dataset_index": 14953
      },
      "priority_encoder #_b5372ed2": {
        "rtl_code": "module priority_encoder #(\n  parameter n = 8 // number of input signals\n) (\n  input [n-1:0] in,\n  output reg [($clog2(n)-1):0] out\n);\n\n\nalways @* begin\n  casez(in) // priority encoder logic\n    8'b10000000: out = 3'b000; // highest priority input\n    8'b01000000: out = 3'b001;\n    8'b00100000: out = 3'b010;\n    8'b00010000: out = 3'b011;\n    8'b00001000: out = 3'b100;\n    8'b00000100: out = 3'b101;\n    8'b00000010: out = 3'b110;\n    8'b00000001: out = 3'b111;\n    default: out = 3'b000; // default output\n  endcase\nend\n\nendmodule",
        "module_name": "priority_encoder #",
        "module_hash": "b5372ed28eba341eab8f6f8453d623f9",
        "dataset_index": 994
      },
      "shift_register_1567270e": {
        "rtl_code": "module shift_register (\n  input CLK,\n  input RST,\n  input SHIFT,\n  input LOAD,\n  input [7:0] DATA_IN,\n  input DATA_IN_VALID,\n  output reg [7:0] DATA_OUT,\n  output reg DATA_OUT_VALID\n);\n\n  reg [7:0] shift_reg;\n\n  always @(posedge CLK) begin\n    if (RST) begin\n      shift_reg <= 8'b0;\n      DATA_OUT_VALID <= 1'b0;\n    end\n    else begin\n      if (LOAD) begin\n        shift_reg <= DATA_IN;\n        DATA_OUT_VALID <= DATA_IN_VALID;\n      end\n      else if (SHIFT) begin\n        shift_reg <= {shift_reg[6:0], shift_reg[7]};\n        DATA_OUT_VALID <= 1'b1;\n      end\n      else begin\n        DATA_OUT_VALID <= 1'b1;\n      end\n    end\n    DATA_OUT <= shift_reg;\n  end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "1567270e82200ea168bae51a27ac53f9",
        "dataset_index": 17946
      },
      "RCB_FRL_COUNT_TO_64_3d64f9c3": {
        "rtl_code": "\nmodule RCB_FRL_COUNT_TO_64(\n\t\tinput\t\tclk, \n\t\tinput\t\trst, \n\t\tinput\t\tcount, \n\t\tinput\t\tud, \n\t\toutput reg [5:0]\tcounter_value \n\t);\n\nwire [5:0]\tcounter_value_preserver;\nalways@(posedge clk or posedge rst) begin\n\t\tif(rst == 1'b1)\n\t\t\tcounter_value = 6'h00;\n\t\telse begin\n\t\t\tcase({count,ud})\n\t\t\t\t2'b00: counter_value\t\t= counter_value_preserver;\n\t\t\t\t2'b01: counter_value\t\t= counter_value_preserver;\n\t\t\t\t2'b10: counter_value\t\t= counter_value_preserver - 1;\n\t\t\t\t2'b11: counter_value\t\t= counter_value_preserver + 1;\n\t\t\t\tdefault: counter_value\t= 6'h00;\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign counter_value_preserver = counter_value;\n\nendmodule\n",
        "module_name": "RCB_FRL_COUNT_TO_64",
        "module_hash": "3d64f9c3a21851519415f74db0b14722",
        "dataset_index": 25571
      },
      "calculator_e9b401d5": {
        "rtl_code": "\nmodule calculator (\n    input [7:0] op1,\n    input [7:0] op2,\n    output [7:0] result,\n    output carry,\n    output overflow,\n    output error\n);\n\n    wire [8:0] sum;\n    wire [8:0] diff;\n    wire [15:0] prod;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    \n    assign sum = op1 + op2;\n    assign diff = op1 - op2;\n    assign prod = op1 * op2;\n    assign overflow = (prod[15:8] != 8'b0) || ((prod[7] == 1) && (op1[7] != op2[7]));\n    \n    assign quotient = (op2 == 8'b0) ? 8'b0 : op1 / op2;\n    assign remainder = (op2 == 8'b0) ? 8'b0 : op1 % op2;\n    \n    assign carry = (op2 == 8'b0) ? 0 : remainder[7];\n    assign error = (op2 == 8'b0);\n    assign result = (op2 == 8'b0) ? 8'b0 : quotient;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "e9b401d5f5921d8ed52ec871a9f41ae4",
        "dataset_index": 16587
      },
      "top__01f61807": {
        "rtl_code": "\nmodule top_module (\n    input CLK,\n    input RESET,\n    input LOAD,\n    input [3:0] DATA,\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    output final_output\n);\n\nreg [3:0] counter_out_reg;\nwire [3:0] counter_out_next;\nwire comparator_out;\n\ncounter counter_inst (\n    .CLK(CLK),\n    .RESET(RESET),\n    .LOAD(LOAD),\n    .DATA(DATA),\n    .out(counter_out_next)\n);\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        counter_out_reg <= 0;\n    end else begin\n        counter_out_reg <= counter_out_next;\n    end\nend\n\ncomparator comparator_inst (\n    .A(A),\n    .B(B),\n    .mode(mode),\n    .out(comparator_out)\n);\n\nassign final_output = comparator_out & (counter_out_reg == 9);\n\nendmodule\n\nmodule counter (\n    input CLK,\n    input RESET,\n    input LOAD,\n    input [3:0] DATA,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        out_reg <= 0;\n    end else if (LOAD) begin\n        out_reg <= DATA;\n    end else begin\n        out_reg <= out_reg + 1;\n    end\nend\n\nassign out = out_reg;\n\nendmodule\n\nmodule comparator (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    output out\n);\n\nwire A_eq_B, A_gt_B, A_lt_B, A_neq_B;\n\nassign A_eq_B = (A == B);\nassign A_gt_B = (A > B);\nassign A_lt_B = (A < B);\nassign A_neq_B = (A != B);\n\nassign out = (mode == 2'b00) ? A_eq_B :\n             (mode == 2'b01) ? A_gt_B :\n             (mode == 2'b10) ? A_lt_B :\n             (mode == 2'b11) ? A_neq_B :\n             1'b0;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "01f618077165482641dcc8e1cc291ab5",
        "dataset_index": 5876
      },
      "big_lcd_7a7b0e1d": {
        "rtl_code": "module big_lcd(\n\ninput clk,\ninput reset,\ninput [15:0] lcd_readdata,\noutput lcd_read,\n\noutput wire [7:0] R,\noutput wire [7:0] G,\noutput wire [7:0] B,\noutput wire HSYNC,\noutput wire VSYNC,\noutput wire LCD_CLK\n\n);\n\nreg [10:0] counter_hs;\nreg [10:0] counter_vs;\n\nreg [20:0] pixel_counter;\n\nassign LCD_CLK = reset == 1 ? clk : 0;\n\nalways@(posedge clk)\nbegin\nif(reset == 1'b0)\n\tbegin\n\t\tcounter_hs <= 0;\n\t\tcounter_vs <= 0;\n\tend\n\telse\n\t\tbegin\n\t\t\tif(counter_hs == 1055\t)\n\t\t\tbegin\n\t\t\t\n\t\t\t\tif(counter_vs == 524)\n\t\t\t\t\tcounter_vs <= 0;\n\t\t\t\telse\n\t\t\t\t\tcounter_vs <= counter_vs + 1;\n\t\t\t\n\t\t\t\tcounter_hs <= 0;\n\t\t\tend\n\t\t\telse\n\t\t\t\tcounter_hs <= counter_hs + 1;\n\t\tend\t\nend\n\nwire data_en;\n\nassign lcd_read = (counter_hs >= 42 && counter_hs <= 681 && counter_vs >= 23  && counter_vs < 503) ? 1 : 0;\n\nassign data_en = (counter_hs >= 46 && counter_hs <= 686 && counter_vs >= 23  && counter_vs < 503) ? 1 : 0;\n\nassign VSYNC = (counter_vs >= 0 && counter_vs < 10) ? 0 : 1;\nassign HSYNC = (counter_hs >= 0 && counter_hs < 10) ? 0 : 1;\n\nassign R = data_en == 1 ? {lcd_readdata[15:11], lcd_readdata[15:13]} : 8'hff;\nassign G = data_en == 1 ? {lcd_readdata[10:5], lcd_readdata[10:9]} : 8'h00;\nassign B = data_en == 1 ? {lcd_readdata[4:0], lcd_readdata[4:2]} : 8'h0f;\n\n\nendmodule",
        "module_name": "big_lcd",
        "module_hash": "7a7b0e1dffd64c1a3061a115060250c1",
        "dataset_index": 22734
      },
      "tx_4391a02c": {
        "rtl_code": "module tx (\n    clk,\n    reset_,\n    baud,\n    txdata,\n    tx_enable,\n    tx_ready,\t   \n    tx);\n\n   input       clk;\n   input       reset_;    \n   input       baud;       // Baud enable\n   input [7:0] txdata;     // Parallel data to transmit\n   input       tx_enable;  // When asserted, txdata is sampled for transmission\n   output      tx_ready;   // Asserted when transmit complete (ready for next byte)\n   output      tx;         // Serial transmit data\n\n   reg \t       tx;\n   reg [1:0]   state;\n   reg [7:0]   txdata_sampled;\n   reg [2:0]   txpos;   \n   \n   // Transmitter states\n   parameter ST_IDLE    = 2'd0;\n   parameter ST_TXSTART = 2'd1;\n   parameter ST_TXDATA  = 2'd2;\n   parameter ST_TXSTOP  = 2'd3;\n\n   assign tx_ready = state == ST_IDLE;   \n   \n   // State machine\n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       state <= ST_IDLE;\n     else if (state == ST_IDLE && tx_enable)\n       state <= ST_TXSTART;\n     else if (state == ST_TXSTART && baud)\n       state <= ST_TXDATA;\n     else if (state == ST_TXDATA && baud && txpos == 3'd7)\n       state <= ST_TXSTOP;\n     else if (state == ST_TXSTOP && baud)\n       state <= ST_IDLE;\n\n   // Serial transmit data\n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       tx <= 1'b1;\n     else if (state == ST_TXSTART && baud)\n       tx <= 1'b0;\n     else if (state == ST_TXDATA && baud)\n       tx <= txdata_sampled[txpos];\n     else if (state == ST_TXSTOP && baud)\n       tx <= 1'b1;\n\n   // Transmit position (bit of txdata being sent)\n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       txpos <= 3'd0;\n     else if (state == ST_IDLE)\n       txpos <= 3'd0;     \n     else if (state == ST_TXDATA && baud)\n       txpos <= txpos + 3'd1;\n\n   // Local copy of txdata\n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       txdata_sampled <= 8'h0;\n     else if (tx_enable && tx_ready)\n       txdata_sampled <= txdata;\n      \nendmodule",
        "module_name": "tx",
        "module_hash": "4391a02c8631f69b69d0b0672321763a",
        "dataset_index": 3784
      },
      "sky130_fd_sc_hs__einvn_f962254c": {
        "rtl_code": "\nmodule sky130_fd_sc_hs__einvn (\n    A   ,\n    TE_B,\n    Z\n);\n\n    input  A   ; // input A\n    input  TE_B; // tri-state enable \n    output Z   ; // output \n\n    assign Z = (TE_B) ? ~A : A; //tri-state enabled\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__einvn",
        "module_hash": "f962254c85a5cf8f3c24409ea233123c",
        "dataset_index": 7716
      },
      "controllerHdl_Phase_Voltages_To_Compare_Values_40867277": {
        "rtl_code": "\n\nmodule controllerHdl_Phase_Voltages_To_Compare_Values\n          (\n           V_0,\n           V_1,\n           V_2,\n           C_0,\n           C_1,\n           C_2\n          );\n\n\n  input   signed [19:0] V_0;  input   signed [19:0] V_1;  input   signed [19:0] V_2;  output  [15:0] C_0;  output  [15:0] C_1;  output  [15:0] C_2;  wire signed [19:0] V [0:2];  wire signed [19:0] Half_Bus_Voltage_out1;  wire signed [20:0] Add2_v;  wire signed [20:0] Add2_add_cast;  wire signed [20:0] Add2_add_temp;  wire signed [20:0] Add2_add_cast_1;  wire signed [20:0] Add2_add_temp_1;  wire signed [20:0] Add2_add_cast_2;  wire signed [20:0] Add2_add_temp_2;  wire signed [19:0] Add2_out1 [0:2];  wire signed [39:0] Voltage_To_PWM_Compare_Units_out1 [0:2];  wire signed [39:0] Saturation1_out1 [0:2];  wire [15:0] pwm_compare [0:2];  assign V[0] = V_0;\n  assign V[1] = V_1;\n  assign V[2] = V_2;\n\n  assign Half_Bus_Voltage_out1 = 20'sb00000110000000000000;\n\n\n\n  assign Add2_v = Half_Bus_Voltage_out1;\n  assign Add2_add_cast = V[0];\n  assign Add2_add_temp = Add2_add_cast + Add2_v;\n  assign Add2_out1[0] = Add2_add_temp[19:0];\n  assign Add2_add_cast_1 = V[1];\n  assign Add2_add_temp_1 = Add2_add_cast_1 + Add2_v;\n  assign Add2_out1[1] = Add2_add_temp_1[19:0];\n  assign Add2_add_cast_2 = V[2];\n  assign Add2_add_temp_2 = Add2_add_cast_2 + Add2_v;\n  assign Add2_out1[2] = Add2_add_temp_2[19:0];\n\n\n\n  assign Voltage_To_PWM_Compare_Units_out1[0] = 341333 * Add2_out1[0];\n  assign Voltage_To_PWM_Compare_Units_out1[1] = 341333 * Add2_out1[1];\n  assign Voltage_To_PWM_Compare_Units_out1[2] = 341333 * Add2_out1[2];\n\n\n\n  assign Saturation1_out1[0] = (Voltage_To_PWM_Compare_Units_out1[0] > 40'sh03E8000000 ? 40'sh03E8000000 :\n              (Voltage_To_PWM_Compare_Units_out1[0] < 40'sh0000000000 ? 40'sh0000000000 :\n              Voltage_To_PWM_Compare_Units_out1[0]));\n  assign Saturation1_out1[1] = (Voltage_To_PWM_Compare_Units_out1[1] > 40'sh03E8000000 ? 40'sh03E8000000 :\n              (Voltage_To_PWM_Compare_Units_out1[1] < 40'sh0000000000 ? 40'sh0000000000 :\n              Voltage_To_PWM_Compare_Units_out1[1]));\n  assign Saturation1_out1[2] = (Voltage_To_PWM_Compare_Units_out1[2] > 40'sh03E8000000 ? 40'sh03E8000000 :\n              (Voltage_To_PWM_Compare_Units_out1[2] < 40'sh0000000000 ? 40'sh0000000000 :\n              Voltage_To_PWM_Compare_Units_out1[2]));\n\n\n\n  assign pwm_compare[0] = Saturation1_out1[0][39:24];\n  assign pwm_compare[1] = Saturation1_out1[1][39:24];\n  assign pwm_compare[2] = Saturation1_out1[2][39:24];\n\n\n\n  assign C_0 = pwm_compare[0];\n\n  assign C_1 = pwm_compare[1];\n\n  assign C_2 = pwm_compare[2];\n\nendmodule  ",
        "module_name": "controllerHdl_Phase_Voltages_To_Compare_Values",
        "module_hash": "40867277c0325f0ee6c7b9cbc4552fc2",
        "dataset_index": 21794
      },
      "fsm_4bit_sequence_detection_a4a16a1b": {
        "rtl_code": "module fsm_4bit_sequence_detection (\n  input clk,\n  input reset,\n  input [3:0] data,\n  output reg match\n);\n\n  // Define the states\n  parameter STATE_0 = 2'b00;\n  parameter STATE_1 = 2'b01;\n  parameter STATE_2 = 2'b10;\n  parameter STATE_3 = 2'b11;\n\n  // Define the state register and next state logic\n  reg [1:0] state, next_state;\n\n  always @ (posedge clk) begin\n    if (reset) begin\n      state <= STATE_0;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Define the output logic\n  always @ (state, data) begin\n    match = 0;\n    case (state)\n      STATE_0: begin\n        if (data == 4'b0001) begin\n          next_state = STATE_1;\n        end else begin\n          next_state = STATE_0;\n        end\n      end\n      STATE_1: begin\n        if (data == 4'b0010) begin\n          next_state = STATE_2;\n        end else begin\n          next_state = STATE_0;\n        end\n      end\n      STATE_2: begin\n        if (data == 4'b0100) begin\n          next_state = STATE_3;\n          match = 1;\n        end else begin\n          next_state = STATE_0;\n        end\n      end\n      STATE_3: begin\n        if (data == 4'b1000) begin\n          next_state = STATE_0;\n        end else begin\n          next_state = STATE_0;\n        end\n      end\n    endcase\n  end\n\nendmodule\n",
        "module_name": "fsm_4bit_sequence_detection",
        "module_hash": "a4a16a1ba6c8f89c603b21d0550d193f",
        "dataset_index": 3216
      },
      "zbroji_7b74bf42": {
        "rtl_code": "\n\n\n\nmodule zbroji (\n        ap_start,\n        ap_done,\n        ap_idle,\n        ap_ready,\n        a,\n        b,\n        ap_return\n);\n\ninput   ap_start;\noutput   ap_done;\noutput   ap_idle;\noutput   ap_ready;\ninput  [31:0] a;\ninput  [31:0] b;\noutput  [31:0] ap_return;\n\nparameter    ap_const_logic_1 = 1'b1;\nparameter    ap_const_logic_0 = 1'b0;\n\n\n\nassign ap_done = ap_start;\nassign ap_idle = ap_const_logic_1;\nassign ap_ready = ap_start;\nassign ap_return = (b + a);\n\n\nendmodule ",
        "module_name": "zbroji",
        "module_hash": "7b74bf4219935a391d9ed4f38362aa07",
        "dataset_index": 8355
      },
      "sky130_fd_sc_hdll__nand4_1c1abcee": {
        "rtl_code": "\nmodule sky130_fd_sc_hdll__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    // Module ports\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    // Local signals\n    wire nand0_out;\n    wire nand1_out;\n    wire nand2_out;\n    wire not0_out;\n    wire and0_out;\n    wire and1_out;\n    wire or0_out;\n\n    //   Name        Output       Other arguments\n    nand nand0     (nand0_out,   A, B);\n    nand nand1     (nand1_out,   C, D);\n    nand nand2     (nand2_out,   nand0_out, nand1_out);\n    not  not0      (not0_out,    nand2_out);\n    and  and0      (and0_out,    A, B);\n    and  and1      (and1_out,    C, D);\n    or   or0       (or0_out,     and0_out, and1_out);\n    buf  buf0      (Y,           not0_out, or0_out);\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__nand4",
        "module_hash": "1c1abceec1517565d5db7e21d4cd8e8d",
        "dataset_index": 16367
      },
      "sky130_fd_sc_ms__ha_3626591b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__ha (\n    COUT,\n    SUM ,\n    A   ,\n    B\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out_COUT;\n    wire xor0_out_SUM ;\n\n    and and0 (and0_out_COUT, A, B           );\n    buf buf0 (COUT         , and0_out_COUT  );\n    xor xor0 (xor0_out_SUM , B, A           );\n    buf buf1 (SUM          , xor0_out_SUM   );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__ha",
        "module_hash": "3626591b1e9824202ca2cdb28769ba13",
        "dataset_index": 23373
      },
      "wptr_full_1a7db09c": {
        "rtl_code": "\n\n\nmodule wptr_full\n\n    #(\n    parameter ADDRSIZE = 4\n    )(\n    input  wire                wclk,\n    input  wire                wrst_n,\n    input  wire                winc,\n    input  wire [ADDRSIZE  :0] wq2_rptr,\n    output reg                 wfull,\n    output reg                 awfull,\n    output wire [ADDRSIZE-1:0] waddr,\n    output reg  [ADDRSIZE  :0] wptr\n    );\n\n    reg  [ADDRSIZE:0] wbin;\n    wire [ADDRSIZE:0] wgraynext, wbinnext, wgraynextp1;\n    wire              awfull_val, wfull_val;\n\n    always @(posedge wclk or negedge wrst_n) begin\n\n        if (!wrst_n) \n            {wbin, wptr} <= 0;\n        else         \n            {wbin, wptr} <= {wbinnext, wgraynext};\n\n    end\n    \n    assign waddr = wbin[ADDRSIZE-1:0];\n    assign wbinnext  = wbin + (winc & ~wfull);\n    assign wgraynext = (wbinnext >> 1) ^ wbinnext;\n    assign wgraynextp1 = ((wbinnext + 1'b1) >> 1) ^ (wbinnext + 1'b1);\n    \n    assign wfull_val = (wgraynext == {~wq2_rptr[ADDRSIZE:ADDRSIZE-1],wq2_rptr[ADDRSIZE-2:0]});\n     assign awfull_val = (wgraynextp1 == {~wq2_rptr[ADDRSIZE:ADDRSIZE-1],wq2_rptr[ADDRSIZE-2:0]});\n\n     always @(posedge wclk or negedge wrst_n) begin\n\n        if (!wrst_n) begin\n            awfull <= 1'b0;\n            wfull  <= 1'b0;\n        end\n        else begin\n            awfull <= awfull_val;\n            wfull  <= wfull_val;\n        end\n\n    end\n\nendmodule\n\n`resetall\n",
        "module_name": "wptr_full",
        "module_hash": "1a7db09c476ca871df08209a74bb785e",
        "dataset_index": 21996
      },
      "MPUC924_383_8eebc5f4": {
        "rtl_code": "\nmodule MPUC924_383 ( CLK,DS ,ED, MPYJ,C383,DR,DI ,DOR ,DOI  );\n\tparameter total_bits = 32;\n\tinput CLK ;\n\twire CLK ;\n\tinput DS ;\n\twire DS ;\n\tinput ED; \t\t\t\t\tinput MPYJ ;\t\t\t\twire MPYJ ;\n\tinput C383 ;\t\t\t\twire C383 ;\n\tinput [total_bits-1:0] DR ;\n\twire signed [total_bits-1:0] DR ;\n\tinput [total_bits-1:0] DI ;\n\twire signed [total_bits-1:0] DI ;\t   \n\t\n\toutput [total_bits-1:0] DOR ;\n\treg [total_bits-1:0] DOR ;\t\n\toutput [total_bits-1:0] DOI ;\n\treg [total_bits-1:0] DOI ;\t \n\t\n\treg signed [total_bits+1 :0] dx7;\t \n\treg signed [total_bits :0] dx3;\t \n\treg signed [total_bits-1 :0] dii;\t \n\treg signed\t[total_bits-1 : 0] dt;\t\t   \n\twire signed [total_bits+1 : 0]  dx5p; \n\twire  signed  [total_bits+1 : 0] dot;\t\n\treg edd,edd2, edd3;        \t\treg mpyjd,mpyjd2,mpyjd3,c3d,c3d2,c3d3;\n\treg [total_bits-1:0] doo ;\t\n\treg [total_bits-1:0] droo ;\t\n\t\n\talways @(posedge CLK)\n\t\tbegin\n\t\t\tif (ED) begin\t  \n\t\t\t\t\tedd<=DS;\n\t\t\t\t\tedd2<=edd;\t\n\t\t\t\t\tedd3<=edd2;\t\n\t\t\t\t\tmpyjd<=MPYJ;\n\t\t\t\t\tmpyjd2<=mpyjd;\n\t\t\t\t\tmpyjd3<=mpyjd2;\t\t\n\t\t\t\t\tc3d<=C383;\n\t\t\t\t\tc3d2<=c3d;\n\t\t\t\t\tc3d3<=c3d2;\n\t\t\t\t\tif (DS)\t begin\t\t\t\t   \t\tdx7<=(DR<<2) - (DR >>>1);\t dx3<=DR+(DR >>>1);\t dt<=DR;\t  \n\t\t\t\t\t\t\tdii<=DI;\n\t\t\t\t\t\tend\n\t\t\t\t\telse\t begin\n\t\t\t\t\t\t\tdx7<=(dii<<2) - (dii >>>1);\t dx3<=dii +(dii >>>1);\t dt<=dii;\n\t\t\t\t\tend\t  \n\t\t\t\t\tif (c3d || c3d2)  \tdoo<=dot >>>2;\t\n\t\t\t\t\telse\t\t\tdoo<=dot >>>2;\t\t \n\t\t\t\t\t\t\n\t\t\t\t\tdroo<=doo;\t\n\t\t\t\t\tif (edd3) \t \n\t\t\t\t\t\tif (mpyjd3) begin\n\t\t\t\t\t\t\t\tDOR<=doo;\n\t\t\t\t\t\t\tDOI<= - droo; end\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\tDOR<=droo;\n\t\t\t\t\t\t\tDOI<=  doo; end\t\t\t\t\t\n\t\t\t\tend \n\t\tend\t\t\n\t\t\n\tassign dx5p=\t(c3d || c3d2)? ((dt>>>5)+dx3)  : ( dx7+(dx3>>>3));\t\tassign   dot=\t(c3d || c3d2)? dx5p-(dt>>>11) :(dx5p+((dt>>>7) +(dx3>>>13)));endmodule\n",
        "module_name": "MPUC924_383",
        "module_hash": "8eebc5f4ff778f2bf8075f7dc241fc4a",
        "dataset_index": 22697
      },
      "pcie_rx_recv #_2b248ce5": {
        "rtl_code": "\n\n\nmodule pcie_rx_recv # (\n\tparameter\tC_PCIE_DATA_WIDTH\t\t\t= 128\n)\n(\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\ninput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\ts_axis_rx_tdata,\n\tinput\t[(C_PCIE_DATA_WIDTH/8)-1:0]\t\ts_axis_rx_tkeep,\n\tinput\t\t\t\t\t\t\t\t\ts_axis_rx_tlast,\n\tinput\t\t\t\t\t\t\t\t\ts_axis_rx_tvalid,\n\toutput\t\t\t\t\t\t\t\t\ts_axis_rx_tready,\n\tinput\t[21:0]\t\t\t\t\t\t\ts_axis_rx_tuser,\n\n\toutput\t\t\t\t\t\t\t\t\tpcie_mreq_err,\n\toutput\t\t\t\t\t\t\t\t\tpcie_cpld_err,\n\toutput\t\t\t\t\t\t\t\t\tpcie_cpld_len_err,\n\n\toutput\t\t\t\t\t\t\t\t\tmreq_fifo_wr_en,\n\toutput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\tmreq_fifo_wr_data,\n\n\toutput\t[7:0]\t\t\t\t\t\t\tcpld_fifo_tag,\n\toutput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\tcpld_fifo_wr_data,\n\toutput\t\t\t\t\t\t\t\t\tcpld_fifo_wr_en,\n\toutput\t\t\t\t\t\t\t\t\tcpld_fifo_tag_last\n);\n\n\nlocalparam\tS_RX_IDLE_SOF\t\t\t\t\t= 4'b0001;\nlocalparam\tS_RX_DATA\t\t\t\t\t\t= 4'b0010;\nlocalparam\tS_RX_STRADDLED\t\t\t\t\t= 4'b0100;\nlocalparam\tS_RX_STRADDLED_HOLD\t\t\t\t= 4'b1000;\n\nreg\t\t[3:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[3:0]\t\t\t\t\t\t\t\tnext_state;\n\n\nwire\t[4:0]\t\t\t\t\t\t\t\tw_rx_is_sof;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_rx_is_eof;\n\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head0;\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head1;\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head2;\n\nwire\t[2:0]\t\t\t\t\t\t\t\tw_mreq_head_fmt;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_mreq_head_type;\nwire\t\t\t\t\t\t\t\t\t\tw_mreq_head_ep;\nwire\t[2:0]\t\t\t\t\t\t\t\tw_cpld_head_fmt;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_cpld_head_type;\nwire\t\t\t\t\t\t\t\t\t\tw_cpld_head_ep;\nwire\t[9:0]\t\t\t\t\t\t\t\tw_cpld_head_len;\nwire\t[2:0]\t\t\t\t\t\t\t\tw_cpld_head_cs;\nwire\t[11:0]\t\t\t\t\t\t\t\tw_cpld_head_bc;\nwire\t[7:0]\t\t\t\t\t\t\t\tw_cpld_head_tag;\nwire\t\t\t\t\t\t\t\t\t\tw_pcie_mreq_type;\nwire\t\t\t\t\t\t\t\t\t\tw_pcie_cpld_type;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_mreq_type;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_type;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_mreq_err;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_err;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_len_err;\n\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_cpld_tag;\nreg\t\t[11:2]\t\t\t\t\t\t\t\tr_cpld_len;\nreg\t\t[11:2]\t\t\t\t\t\t\t\tr_cpld_bc;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_lhead;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_mem_req_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_data_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_tag_last;\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_straddled;\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_straddled_hold;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_data_straddled;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_s_axis_rx_tdata;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_s_axis_rx_tdata_d1;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_mreq_fifo_wr_en;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_mreq_fifo_wr_data;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_tag_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_wr_en;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_cpld_fifo_wr_data;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_tag_last;\n\nassign s_axis_rx_tready = ~r_rx_straddled_hold;\n\nassign pcie_mreq_err = r_pcie_mreq_err;\nassign pcie_cpld_err = r_pcie_cpld_err;\nassign pcie_cpld_len_err = r_pcie_cpld_len_err;\n\nassign mreq_fifo_wr_en = r_mreq_fifo_wr_en;\nassign mreq_fifo_wr_data = r_mreq_fifo_wr_data;\n\nassign cpld_fifo_tag = r_cpld_tag;\nassign cpld_fifo_wr_en = r_cpld_fifo_wr_en;\n\nassign cpld_fifo_wr_data[31:0] = {r_cpld_fifo_wr_data[7:0], r_cpld_fifo_wr_data[15:8], r_cpld_fifo_wr_data[23:16], r_cpld_fifo_wr_data[31:24]};\nassign cpld_fifo_wr_data[63:32] = {r_cpld_fifo_wr_data[39:32], r_cpld_fifo_wr_data[47:40], r_cpld_fifo_wr_data[55:48], r_cpld_fifo_wr_data[63:56]};\nassign cpld_fifo_wr_data[95:64] = {r_cpld_fifo_wr_data[71:64], r_cpld_fifo_wr_data[79:72], r_cpld_fifo_wr_data[87:80], r_cpld_fifo_wr_data[95:88]};\nassign cpld_fifo_wr_data[127:96] = {r_cpld_fifo_wr_data[103:96], r_cpld_fifo_wr_data[111:104], r_cpld_fifo_wr_data[119:112], r_cpld_fifo_wr_data[127:120]};\n\nassign cpld_fifo_tag_last = r_cpld_fifo_tag_last;\n\n\nassign w_rx_is_sof = s_axis_rx_tuser[14:10];\nassign w_rx_is_eof = s_axis_rx_tuser[21:17];\n\nalways @ (*)\nbegin\n\tif(w_rx_is_sof[3] == 1) begin\n\t\tr_pcie_head0 <= s_axis_rx_tdata[95:64];\n\t\tr_pcie_head1 <= s_axis_rx_tdata[127:96];\n\tend\n\telse begin\n\t\tr_pcie_head0 <= s_axis_rx_tdata[31:0];\n\t\tr_pcie_head1 <= s_axis_rx_tdata[63:32];\n\tend\n\n\tif(r_rx_straddled == 1)\n\t\tr_pcie_head2 <= s_axis_rx_tdata[31:0];\n\telse\n\t\tr_pcie_head2 <= s_axis_rx_tdata[95:64];\nend\n\n\n\nassign w_mreq_head_fmt = r_pcie_head0[31:29];\nassign w_mreq_head_type = r_pcie_head0[28:24];\nassign w_mreq_head_ep = r_pcie_head0[14];\nassign w_cpld_head_fmt = r_pcie_head0[31:29];\nassign w_cpld_head_type = r_pcie_head0[28:24];\nassign w_cpld_head_ep = r_pcie_head0[14];\nassign w_cpld_head_len = r_pcie_head0[9:0];\nassign w_cpld_head_cs = r_pcie_head1[15:13];\nassign w_cpld_head_bc = r_pcie_head1[11:0];\nassign w_cpld_head_tag = r_pcie_head2[15:8];\nassign w_pcie_mreq_type = ({w_mreq_head_fmt[2], w_mreq_head_type} == {1'b0, 5'b00000});\nassign w_pcie_cpld_type = ({w_cpld_head_fmt, w_cpld_head_type} == {3'b010, 5'b01010});\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0)\n\t\tcur_state <= S_RX_IDLE_SOF;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1 && w_rx_is_eof[4] == 0 ) begin\n\t\t\t\tif(w_rx_is_sof[3] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_DATA;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\t\tS_RX_DATA: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_eof[4] == 1) begin\n\t\t\t\tif(w_rx_is_sof[4] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_DATA;\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_eof[4] == 1) begin\n\t\t\t\tif(w_rx_is_sof[4] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse if(w_rx_is_eof[3] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED_HOLD;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1) begin\n\t\tr_pcie_mreq_type <= w_pcie_mreq_type & ~w_mreq_head_ep;\n\t\tr_pcie_cpld_type <= w_pcie_cpld_type & ~w_cpld_head_ep & (w_cpld_head_cs == 0);\n\n\t\tr_cpld_len <= w_cpld_head_len;\n\t\tr_cpld_bc[11:2] <= w_cpld_head_bc[11:2];\n\tend\nend\n\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_pcie_mreq_err <= 0;\n\t\tr_pcie_cpld_err <= 0;\n\t\tr_pcie_cpld_len_err <= 0;\n\tend\n\telse begin\n\t\tif(r_pcie_cpld_type == 1 && r_cpld_len < 2) begin\n\t\t\tr_pcie_cpld_len_err <= 1;\n\t\tend\n\n\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1) begin\n\t\t\tr_pcie_mreq_err <= w_pcie_mreq_type & w_mreq_head_ep;\n\t\t\tr_pcie_cpld_err <= w_pcie_cpld_type & (w_cpld_head_ep | (w_cpld_head_cs != 0));\n\t\tend\n\tend\nend\n\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tr_cpld_tag <= w_cpld_head_tag;\n\t\t\tr_cpld_lhead <= 0;\n\t\tend\n\t\tS_RX_DATA: begin\n\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tif(s_axis_rx_tvalid == 1)\n\t\t\t\tr_cpld_lhead <= ~w_rx_is_sof[4];\n\n\t\t\tif(r_cpld_lhead == 0)\n\t\t\t\tr_cpld_tag <= w_cpld_head_tag;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\n\t\tend\n\t\tdefault: begin\n\n\t\tend\n\tendcase\nend\n\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tr_mem_req_en <= (s_axis_rx_tvalid & w_rx_is_sof[4] & ~w_rx_is_sof[3]) & w_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= 0;\n\t\t\tr_cpld_tag_last <= 0;\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_DATA: begin\n\t\t\tr_mem_req_en <= s_axis_rx_tvalid & r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= s_axis_rx_tvalid & r_pcie_cpld_type;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & (s_axis_rx_tvalid & r_pcie_cpld_type & w_rx_is_eof[4]);\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tr_mem_req_en <= s_axis_rx_tvalid & r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= s_axis_rx_tvalid & r_pcie_cpld_type & r_cpld_lhead;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & (s_axis_rx_tvalid & r_pcie_cpld_type & w_rx_is_eof[4] & ~w_rx_is_eof[3]);\n\t\t\tr_rx_straddled <= 1;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\t\t\tr_mem_req_en <= r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= r_pcie_cpld_type;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & r_pcie_cpld_type;\n\t\t\tr_rx_straddled <= 1;\n\t\t\tr_rx_straddled_hold <= 1;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_mem_req_en <= 0;\n\t\t\tr_cpld_data_en <= 0;\n\t\t\tr_cpld_tag_last <= 0;\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_mreq_fifo_wr_en <= r_mem_req_en;\n\tr_cpld_fifo_wr_en <= r_cpld_data_en;\n\tr_cpld_fifo_tag_last <= r_cpld_tag_last;\n\tr_rx_data_straddled <= r_rx_straddled;\n\n\tif(s_axis_rx_tvalid == 1 || r_rx_straddled_hold == 1) begin\n\t\tr_s_axis_rx_tdata <= s_axis_rx_tdata;\n\t\tr_s_axis_rx_tdata_d1 <= r_s_axis_rx_tdata;\n\tend\nend\n\nalways @ (*)\nbegin\n\tif(r_rx_data_straddled == 1)\n\t\tr_mreq_fifo_wr_data <= {r_s_axis_rx_tdata[63:0], r_s_axis_rx_tdata_d1[127:64]};\n\telse\n\t\tr_mreq_fifo_wr_data <= r_s_axis_rx_tdata;\n\n\tif(r_rx_data_straddled == 1)\n\t\tr_cpld_fifo_wr_data <= {r_s_axis_rx_tdata[31:0], r_s_axis_rx_tdata_d1[127:32]};\n\telse\n\t\tr_cpld_fifo_wr_data <= {r_s_axis_rx_tdata[95:0], r_s_axis_rx_tdata_d1[127:96]};\nend\n\n\nendmodule",
        "module_name": "pcie_rx_recv #",
        "module_hash": "2b248ce59b397936f27936d11787ba5e",
        "dataset_index": 25697
      },
      "wb_stream_writer_ctrl_a05d589f": {
        "rtl_code": "module wb_stream_writer_ctrl\n  #(parameter WB_AW = 32,\n    parameter WB_DW = 32,\n    parameter FIFO_AW = 0,\n    parameter MAX_BURST_LEN = 0)\n  (input \t\t  wb_clk_i,\n   input \t\t  wb_rst_i,\n   output [WB_AW-1:0] \t  wbm_adr_o,\n   output [WB_DW-1:0] \t  wbm_dat_o,\n   output [WB_DW/8-1:0]   wbm_sel_o,\n   output \t\t  wbm_we_o ,\n   output \t\t  wbm_cyc_o,\n   output \t\t  wbm_stb_o,\n   output reg [2:0] \t  wbm_cti_o,\n   output [1:0] \t  wbm_bte_o,\n   input [WB_DW-1:0] \t  wbm_dat_i,\n   input \t\t  wbm_ack_i,\n   input \t\t  wbm_err_i,\n   output [WB_DW-1:0] \t  fifo_d,\n   output \t\t  fifo_wr,\n   input [FIFO_AW:0] \t  fifo_cnt,\n   output reg \t\t  busy,\n   input \t\t  enable,\n   output reg [WB_DW-1:0] tx_cnt,\n   input [WB_AW-1:0] \t  start_adr,\n   input [WB_AW-1:0] \t  buf_size,\n   input [WB_AW-1:0] \t  burst_size);\n\n   wire\t\t\t    active;\n\n   wire \t\t    timeout = 1'b0;\n   reg \t\t\t    last_adr;\n   reg [$clog2(MAX_BURST_LEN-1):0] burst_cnt;\n\n   localparam S_IDLE   = 0;\n   localparam S_ACTIVE = 1;\n   \n   reg [1:0] \t\t\t      state;\n\n   wire \t\t\t      burst_end = (burst_cnt == burst_size-1);\n   wire fifo_ready = (fifo_cnt+burst_size <= 2**FIFO_AW);\n\n   always @(active or burst_end) begin\n      wbm_cti_o = !active     ? 3'b000 :\n\t\t  burst_end   ? 3'b111 :\n\t\t  3'b010; end\n\n   assign active = (state == S_ACTIVE);\n   assign fifo_d = wbm_dat_i;\n   assign fifo_wr = wbm_ack_i;\n\n   assign wbm_sel_o = 4'hf;\n   assign wbm_we_o = 1'b0;\n   assign wbm_cyc_o = active;\n   assign wbm_stb_o = active;\n   assign wbm_bte_o = 2'b00;\n   assign wbm_dat_o = {WB_DW{1'b0}};\n   assign wbm_adr_o = start_adr + tx_cnt*4;\n\n   always @(posedge wb_clk_i) begin\n      last_adr = (tx_cnt == buf_size[WB_AW-1:2]-1);\n      if (wbm_ack_i)\n\t if (last_adr)\n\t   tx_cnt <= 0;\n\t else\n\t   tx_cnt <= tx_cnt+1;\n\n      if(!active)\n\tburst_cnt <= 0;\n      else\n\tif(wbm_ack_i)\n\t  burst_cnt <= burst_cnt + 1;\n      \n      case (state)\n\tS_IDLE : begin\n\t   if (busy & fifo_ready)\n\t     state <= S_ACTIVE;\n\t   if (enable)\n\t     busy <= 1'b1;\n\tend\n\tS_ACTIVE : begin\n\t   if (burst_end & wbm_ack_i) begin\n\t      state <= S_IDLE;\n\t      if (last_adr)\n\t\tbusy <= 1'b0;\n\t   end\n\tend\n\tdefault : begin\n\t   state <= S_IDLE;\n\tend\n      endcase if(wb_rst_i) begin\n\t state <= S_IDLE;\n\t tx_cnt <= 0;\n\t busy <= 1'b0;\n      end\n   end\n   \nendmodule\n",
        "module_name": "wb_stream_writer_ctrl",
        "module_hash": "a05d589f7a11ecaf91a348536ee936a1",
        "dataset_index": 16655
      },
      "freq_divider_4ec2b5de": {
        "rtl_code": "module freq_divider (\n  input wire clk_in,\n  output wire clk_out\n);\n\n  //-- Valor por defecto del divisor\n  //-- Como en la iCEstick el reloj es de 12MHz, ponermos un valor de 12M\n  //-- para obtener una frecuencia de salida de 1Hz\n  parameter M = 12;\n\n  //-- Numero de bits para almacenar el divisor\n  //-- Se calculan con la funcion de verilog $clog2, que nos devuelve el\n  //-- numero de bits necesarios para representar el numero M\n  //-- Es un parametro local, que no se puede modificar al instanciar\n  localparam N = $clog2(M);\n\n  //-- Registro para implementar el contador modulo M\n  reg [N-1:0] divcounter = 0;\n\n  //-- Contador m\u00f3dulo M\n  always @(posedge clk_in)\n    if (divcounter == M - 1)\n      divcounter <= 0;\n    else\n      divcounter <= divcounter + 1;\n\n  //-- Sacar el bit mas significativo por clk_out\n  assign clk_out = divcounter[N-1];\n\nendmodule",
        "module_name": "freq_divider",
        "module_hash": "4ec2b5de088c442edcdf611de04a4dc2",
        "dataset_index": 19647
      },
      "IBUFCTRL_ce5fe873": {
        "rtl_code": "\nmodule IBUFCTRL (\n  input I,\n  input IBUFDISABLE,\n  input T,\n  output O\n);\n\n  assign O = IBUFDISABLE ? (T ? 1'b0 : 1'b1) : I;\n\nendmodule",
        "module_name": "IBUFCTRL",
        "module_hash": "ce5fe87322502fcf6c9fcda5bdd1d6e5",
        "dataset_index": 3532
      },
      "register_monitor_34814b9d": {
        "rtl_code": "\nmodule register_monitor (\n  input  wire clk,\n  input  wire reset_n,\n  input  wire [31:0] MonDReg,\n  input  wire enable,\n  output reg  [31:0] monitored_value\n);\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 1'b0) begin\n      monitored_value <= 0;\n    end else begin\n      if (enable) begin\n        monitored_value <= MonDReg;\n      end\n    end\n  end\n\nendmodule\nmodule lab9_soc_nios2_qsys_0_jtag_debug_module_wrapper (\n  // inputs:\n  input  [31:0] MonDReg,\n  input  [31:0] break_readreg,\n  input         clk,\n  input         dbrk_hit0_latch,\n  input         dbrk_hit1_latch,\n  input         dbrk_hit2_latch,\n  input         dbrk_hit3_latch,\n  input         debugack,\n  input         monitor_error,\n  input         monitor_ready,\n  input         reset_n,\n  input         resetlatch,\n  input         tracemem_on,\n  input  [35:0] tracemem_trcdata,\n  input         tracemem_tw,\n  input   [6:0] trc_im_addr,\n  input         trc_on,\n  input         trc_wrap,\n  input         trigbrktype,\n  input         trigger_state_1,\n\n  // outputs:\n  output [37:0] jdo,\n  output        jrst_n,\n  output        st_ready_test_idle,\n  output        take_action_break_a,\n  output        take_action_break_b,\n  output        take_action_break_c,\n  output        take_action_ocimem_a,\n  output        take_action_ocimem_b,\n  output        take_action_tracectrl,\n  output        take_action_tracemem_a,\n  output        take_action_tracemem_b,\n  output        take_no_action_break_a,\n  output        take_no_action_break_b,\n  output        take_no_action_break_c,\n  output        take_no_action_ocimem_a,\n  output        take_no_action_tracemem_a\n);\n\n  wire         vji_cdr;\n  wire   [1:0] vji_ir_in;\n  wire   [1:0] vji_ir_out;\n  wire         vji_rti;\n  wire         vji_sdr;\n  wire         vji_tck;\n  wire         vji_tdi;\n  wire         vji_tdo;\n  wire         vji_udr;\n  wire         vji_uir;\n\n  register_monitor monitor (\n    .clk             (clk),\n    .reset_n         (reset_n),\n    .MonDReg         (MonDReg),\n    .enable          (1'b1),\n    .monitored_value (jdo[31:0])\n  );\n\n  assign jdo[37] = 1'b0;\n  assign jdo[36] = 1'b0;\n  assign jdo[35] = 1'b0;\n  assign jdo[34] = 1'b0;\n  assign jdo[33] = 1'b0;\n  assign jdo[32] = 1'b0;\n\n  assign jrst_n = 1'b0;\n  assign st_ready_test_idle = 1'b0;\n  assign take_action_break_a = 1'b0;\n  assign take_action_break_b = 1'b0;\n  assign take_action_break_c = 1'b0;\n  assign take_action_ocimem_a = 1'b0;\n  assign take_action_ocimem_b = 1'b0;\n  assign take_action_tracectrl = 1'b0;\n  assign take_action_tracemem_a = 1'b0;\n  assign take_action_tracemem_b = 1'b0;\n  assign take_no_action_break_a = 1'b1;\n  assign take_no_action_break_b = 1'b1;\n  assign take_no_action_break_c = 1'b1;\n  assign take_no_action_ocimem_a = 1'b1;\n  assign take_no_action_tracemem_a = 1'b1;\nendmodule",
        "module_name": "register_monitor",
        "module_hash": "34814b9dcb3e973199cf1d401a9eef18",
        "dataset_index": 20551
      },
      "NV_NVDLA_CACC_CALC_int8_99ada3c4": {
        "rtl_code": "\n// File Name: NV_NVDLA_CACC_CALC_int8.v\n\nmodule NV_NVDLA_CACC_CALC_int8 (\n   nvdla_core_clk\n  ,nvdla_core_rstn\n  ,cfg_truncate\n  ,in_data\n  ,in_op\n  ,in_op_valid\n  ,in_sel\n  ,in_valid\n  ,out_final_data\n  ,out_final_sat\n  ,out_final_valid\n  ,out_partial_data\n  ,out_partial_valid\n  );\ninput   [4:0] cfg_truncate;\ninput  [21:0] in_data;\ninput  [33:0] in_op;\ninput         in_op_valid;\ninput         in_sel;\ninput         in_valid;\noutput [31:0] out_final_data;\noutput        out_final_sat;\noutput        out_final_valid;\noutput [33:0] out_partial_data;\noutput        out_partial_valid;\n\ninput nvdla_core_clk;\ninput nvdla_core_rstn;\n\nreg    [32:0] i_sat_bits;\nreg           i_sat_sel;\nreg           i_sat_vld;\nreg    [34:0] i_sum_pd;\nreg    [31:0] out_final_data;\nreg           out_final_sat;\nreg           out_final_valid;\nreg    [33:0] out_partial_data;\nreg           out_partial_valid;\nwire   [21:0] di_pd;\nwire   [31:0] i_final_result;\nwire          i_final_vld;\nwire          i_guide;\nwire   [33:0] i_partial_result;\nwire          i_partial_vld;\nwire          i_point5;\nwire   [31:0] i_pos_pd;\nwire   [33:0] i_pre_sft_pd;\nwire   [33:0] i_sat_pd;\nwire          i_sat_sign;\nwire          i_sel;\nwire   [31:0] i_sft_max;\nwire          i_sft_need_sat;\nwire   [33:0] i_sft_pd;\nwire   [14:0] i_stick;\nwire          i_sum_msb;\nwire   [34:0] i_sum_pd_nxt;\nwire          i_sum_sign;\nwire   [31:0] i_tru_pd;\nwire          i_vld;\nwire   [33:0] in_mask_op;\nwire          mon_pos_pd_c;\nwire   [33:0] oi_pd;\n\n// synoff nets\n\n// monitor nets\n\n// debug nets\n\n// tie high nets\n\n// tie low nets\n\n// no connect nets\n\n// not all bits used nets\n\n// todo nets\n\n    \n\nassign i_sel = in_sel;\nassign i_vld = in_valid;\nassign in_mask_op = in_op_valid ? in_op[33:0] : 34'b0;\n\nassign di_pd = in_data[21:0];\nassign oi_pd = in_mask_op[33:0];\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    i_sat_vld <= 1'b0;\n  end else begin\n  i_sat_vld <= i_vld;\n  end\nend\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    i_sat_sel <= 1'b0;\n  end else begin\n  if ((i_vld) == 1'b1) begin\n    i_sat_sel <= i_sel;\n  // VCS coverage off\n  end else if ((i_vld) == 1'b0) begin\n  end else begin\n    i_sat_sel <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\n  end\nend\n`ifdef SPYGLASS_ASSERT_ON\n`else\n`endif // SPYGLASS_ASSERT_ON\n`ifdef ASSERT_ON\n`ifdef FV_ASSERT_ON\n`define ASSERT_RESET nvdla_core_rstn\n`else\n`ifdef SYNTHESIS\n`define ASSERT_RESET nvdla_core_rstn\n`else\n`ifdef ASSERT_OFF_RESET_IS_X\n`define ASSERT_RESET ((1'bx === nvdla_core_rstn) ? 1'b0 : nvdla_core_rstn)\n`else\n`define ASSERT_RESET ((1'bx === nvdla_core_rstn) ? 1'b1 : nvdla_core_rstn)\n`endif // ASSERT_OFF_RESET_IS_X\n`endif // SYNTHESIS\n`endif // FV_ASSERT_ON\n`ifndef SYNTHESIS\n  // VCS coverage off \n  nv_assert_no_x #(0,1,0,\"No X's allowed on control signals\")      zzz_assert_no_x_1x (nvdla_core_clk, `ASSERT_RESET, 1'd1,  (^(i_vld))); // spyglass disable W504 SelfDeterminedExpr-ML \n  // VCS coverage on\n`endif\n`undef ASSERT_RESET\n`endif // ASSERT_ON\n`ifdef SPYGLASS_ASSERT_ON\n`else\n`endif // SPYGLASS_ASSERT_ON\n\nassign i_sum_pd_nxt[34:0] = $signed(di_pd) + $signed(oi_pd);\nalways @(posedge nvdla_core_clk) begin\n  if ((i_vld) == 1'b1) begin\n    i_sum_pd <= i_sum_pd_nxt;\n  // VCS coverage off\n  end else if ((i_vld) == 1'b0) begin\n  end else begin\n    i_sum_pd <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\nassign i_sum_sign = i_sum_pd[34 +1 -1];\nassign i_sum_msb  = i_sum_pd[34 +1 -2];\nassign i_sat_sign = i_sum_sign;\n\nalways @(\n  i_sum_sign\n  or i_sum_msb\n  or i_sum_pd\n  ) begin\n    if (i_sum_sign ^ i_sum_msb) begin // overflow, need satuation\n        i_sat_bits = {33{~i_sum_sign}};\n    end else begin\n        i_sat_bits = i_sum_pd[32:0];\n    end\nend\n\nassign i_sat_pd = {i_sat_sign,i_sat_bits};\nassign i_partial_result = i_sat_pd;\n\nassign i_pre_sft_pd = i_sat_sel ? i_sat_pd[33:0] : {34{1'b0}};\nassign {i_sft_pd[33:0], i_guide, i_stick[14:0]} = ($signed({i_pre_sft_pd, 16'b0}) >>> cfg_truncate);\n\nassign i_sft_need_sat = (i_sat_sign & ~(&i_sft_pd[32:31])) |\n                        (~i_sat_sign & (|i_sft_pd[32:31])) |\n                        (~i_sat_sign & (&{i_sft_pd[30:0], i_point5}));\nassign i_sft_max      = i_sat_sign ? {1'b1, 31'b0} : ~{1'b1, 31'b0};\n\nassign i_point5 = i_sat_sel & i_guide & (~i_sat_sign | (|i_stick));\nassign {mon_pos_pd_c, i_pos_pd[31:0]} = i_sft_pd[31:0] + i_point5;\nassign i_tru_pd   = i_pos_pd;\n\nassign i_final_result = i_sft_need_sat ? i_sft_max : i_tru_pd;\n\nassign i_partial_vld = i_sat_vld & ~i_sat_sel;\nassign i_final_vld = i_sat_vld & i_sat_sel;\n\n//====================\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    out_partial_valid <= 1'b0;\n  end else begin\n  out_partial_valid <= i_partial_vld;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((i_partial_vld) == 1'b1) begin\n    out_partial_data <= i_partial_result;\n  // VCS coverage off\n  end else if ((i_partial_vld) == 1'b0) begin\n  end else begin\n    out_partial_data <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    out_final_valid <= 1'b0;\n  end else begin\n  out_final_valid <= i_final_vld;\n  end\nend\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    out_final_sat <= 1'b0;\n  end else begin\n  out_final_sat <= i_final_vld & i_sft_need_sat;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((i_final_vld) == 1'b1) begin\n    out_final_data <= i_final_result;\n  // VCS coverage off\n  end else if ((i_final_vld) == 1'b0) begin\n  end else begin\n    out_final_data <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\n//VCS coverage off\n`ifndef DISABLE_FUNCPOINT\n  `ifdef ENABLE_FUNCPOINT\n\n    reg funcpoint_cover_off;\n    initial begin\n        if ( $test$plusargs( \"cover_off\" ) ) begin\n            funcpoint_cover_off = 1'b1;\n        end else begin\n            funcpoint_cover_off = 1'b0;\n        end\n    end\n\n    property cacc_calc_int8__partial_sum_need_sat__0_cov;\n        disable iff((nvdla_core_rstn !== 1) || funcpoint_cover_off)\n        @(posedge nvdla_core_clk)\n        i_sum_sign ^ i_sum_msb;\n    endproperty\n    // Cover 0 : \"i_sum_sign ^ i_sum_msb\"\n    FUNCPOINT_cacc_calc_int8__partial_sum_need_sat__0_COV : cover property (cacc_calc_int8__partial_sum_need_sat__0_cov);\n\n  `endif\n`endif\n//VCS coverage on\n\n//VCS coverage off\n`ifndef DISABLE_FUNCPOINT\n  `ifdef ENABLE_FUNCPOINT\n\n    property cacc_calc_int8__out32_need_sat_pos__1_cov;\n        disable iff((nvdla_core_rstn !== 1) || funcpoint_cover_off)\n        @(posedge nvdla_core_clk)\n        i_sft_need_sat & ~i_sat_sign & ~i_point5;\n    endproperty\n    // Cover 1 : \"i_sft_need_sat & ~i_sat_sign & ~i_point5\"\n    FUNCPOINT_cacc_calc_int8__out32_need_sat_pos__1_COV : cover property (cacc_calc_int8__out32_need_sat_pos__1_cov);\n\n  `endif\n`endif\n//VCS coverage on\n\n//VCS coverage off\n`ifndef DISABLE_FUNCPOINT\n  `ifdef ENABLE_FUNCPOINT\n\n    property cacc_calc_int8__out32_round_need_sat_pos__2_cov;\n        disable iff((nvdla_core_rstn !== 1) || funcpoint_cover_off)\n        @(posedge nvdla_core_clk)\n        i_sft_need_sat & ~i_sat_sign & i_point5;\n    endproperty\n    // Cover 2 : \"i_sft_need_sat & ~i_sat_sign & i_point5\"\n    FUNCPOINT_cacc_calc_int8__out32_round_need_sat_pos__2_COV : cover property (cacc_calc_int8__out32_round_need_sat_pos__2_cov);\n\n  `endif\n`endif\n//VCS coverage on\n\n//VCS coverage off\n`ifndef DISABLE_FUNCPOINT\n  `ifdef ENABLE_FUNCPOINT\n\n    property cacc_calc_int8__out32_round_need_sat_neg__3_cov;\n        disable iff((nvdla_core_rstn !== 1) || funcpoint_cover_off)\n        @(posedge nvdla_core_clk)\n        i_sft_need_sat & i_sat_sign;\n    endproperty\n    // Cover 3 : \"i_sft_need_sat & i_sat_sign\"\n    FUNCPOINT_cacc_calc_int8__out32_round_need_sat_neg__3_COV : cover property (cacc_calc_int8__out32_round_need_sat_neg__3_cov);\n\n  `endif\n`endif\n//VCS coverage on\n\n\nendmodule // NV_NVDLA_CACC_CALC_int8\n\n",
        "module_name": "NV_NVDLA_CACC_CALC_int8",
        "module_hash": "99ada3c417148df42697b2ff109c6da3",
        "dataset_index": 116
      },
      "synchronous_counter_aec40903": {
        "rtl_code": "module synchronous_counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "synchronous_counter",
        "module_hash": "aec409030f2ed8cf0e5f8eb9cc4157cd",
        "dataset_index": 5037
      },
      "glitch_filter_547989d6": {
        "rtl_code": "module glitch_filter (\n  input in,\n  input clk, // Added clock input\n  output out\n);\n\nparameter glitch_duration = 10; // duration of glitch to be removed (in clock cycles)\n\nreg [glitch_duration-1:0] glitch_counter; // counter to measure duration of glitch\nreg out_reg; // register to store output signal\n\nalways @(posedge clk) begin // Fix: Remove posedge in from the always statement\n  if (in == 1'b1) begin\n    if (glitch_counter < glitch_duration) begin\n      glitch_counter <= glitch_counter + 1;\n    end else begin\n      out_reg <= 1'b1;\n      glitch_counter <= 0;\n    end\n  end else begin\n    if (glitch_counter > 0) begin\n      glitch_counter <= glitch_counter - 1;\n    end else begin\n      out_reg <= 1'b0;\n    end\n  end\nend\n\nassign out = out_reg;\n\nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "547989d6f861682230ba05d346419625",
        "dataset_index": 1984
      },
      "SPI_sender_323f0a35": {
        "rtl_code": "\nmodule SPI_sender(\n    input CLK,\n    input RST,\n    input [7:0] DATA,\n    input [31:0] T_DIV,\n    input ST,\n    output SCK,\n    output MOSI,\n    output reg SS,\n    output reg DONE\n);\n\nreg [31:0] counter;\nreg [7:0] shift_register;\nreg [7:0] data_out;\nreg [3:0] bit_counter;\nreg ss_done;\n\nassign MOSI = shift_register[7-bit_counter];\nassign SCK = counter < (T_DIV/2);\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        counter <= 0;\n        shift_register <= 0;\n        data_out <= 0;\n        bit_counter <= 0;\n        ss_done <= 0;\n        DONE <= 0;\n    end else if (ST) begin\n        if (counter < T_DIV) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n            if (!ss_done) begin\n                SS <= 0;\n                ss_done <= 1;\n            end else begin\n                if (bit_counter < 7) begin\n                    shift_register <= {DATA[bit_counter], shift_register[7:1]};\n                    bit_counter <= bit_counter + 1;\n                end else begin\n                    data_out <= shift_register;\n                    bit_counter <= 0;\n                    if (ss_done) begin\n                        SS <= 1;\n                        DONE <= 1;\n                    end\n                end\n            end\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "SPI_sender",
        "module_hash": "323f0a35cd070b818acd6a2f1ae4445b",
        "dataset_index": 15513
      },
      "rgb_generator #_188bfcda": {
        "rtl_code": "\n\nmodule rgb_generator #(\n  parameter           CLOCK_RATE    = 100000000,\n  parameter           FPS           = 60,\n\n  parameter           FRAME_WIDTH   = 480,\n  parameter           FRAME_HEIGHT  = 272,\n  parameter           X_OFFSET      = 112,\n  parameter           Y_OFFSET      = 6,\n  parameter           BG_COLOR      = 8'h00,\n  parameter           HBLANK        = 100,\n  parameter           VBLANK        = 10\n)(\n  input               clk,                input               rst,                output        [9:0] o_nes_x_out,        output        [9:0] o_nes_y_out,        output        [9:0] o_nes_y_next_out,   output  reg         o_pix_pulse_out,    output              o_vblank,           input         [5:0] i_sys_palette_idx_in,  output  reg         o_video_hsync = 0,  output  reg         o_sof_stb = 0,      output        [2:0] o_r_out,            output        [2:0] o_g_out,            output        [1:0] o_b_out             );\n\n\nlocalparam  IMAGE_WIDTH     = 256;\nlocalparam  IMAGE_HEIGHT    = 240;\n\nlocalparam VBLANK_TIMEOUT = ((((FRAME_WIDTH + HBLANK) * FRAME_HEIGHT) + VBLANK) > (CLOCK_RATE / FPS)) ?\n                                          10 :\n                                          (CLOCK_RATE / FPS) - (((FRAME_WIDTH + HBLANK) * FRAME_HEIGHT) + VBLANK);\n\nlocalparam  IDLE            = 0;\nlocalparam  VID             = 1;\n\nreg   [8:0]       r_x_pos;\nreg   [8:0]       r_y_pos;\nreg   [7:0]       r_rgb;\n\nwire  [8:0]       w_x_pos;\nwire  [8:0]       w_y_pos;\n\nreg   [7:0]       r_clk_div_count;\nreg   [3:0]       state;\n\nwire  [7:0]       w_bg_color;\nwire              w_valid;\nreg               r_valid;\nwire  [31:0]      w_vblank_timeout = VBLANK_TIMEOUT;\nreg   [9:0]       r_nes_x_next;\nreg               r_start_stb;\n\n\n\nalways @ (posedge clk) begin\n  r_start_stb       <=  0;\n  if (rst) begin\n    r_clk_div_count <=  0;\n  end\n  else begin\n    if (r_clk_div_count < VBLANK_TIMEOUT) begin\n      r_clk_div_count <= r_clk_div_count + 1;\n    end\n    else begin\n      r_clk_div_count <=  0;\n      r_start_stb     <=  1;\n    end\n  end\nend\n\nalways @ (*) begin\n  if (!r_valid) begin\n    r_rgb             = 0;\n  end\n  else begin\n    case (i_sys_palette_idx_in)\n      6'h00:  r_rgb = { 3'h3, 3'h3, 2'h1 };\n      6'h01:  r_rgb = { 3'h1, 3'h0, 2'h2 };\n      6'h02:  r_rgb = { 3'h0, 3'h0, 2'h2 };\n      6'h03:  r_rgb = { 3'h2, 3'h0, 2'h2 };\n      6'h04:  r_rgb = { 3'h4, 3'h0, 2'h1 };\n      6'h05:  r_rgb = { 3'h5, 3'h0, 2'h0 };\n      6'h06:  r_rgb = { 3'h5, 3'h0, 2'h0 };\n      6'h07:  r_rgb = { 3'h3, 3'h0, 2'h0 };\n      6'h08:  r_rgb = { 3'h2, 3'h1, 2'h0 };\n      6'h09:  r_rgb = { 3'h0, 3'h2, 2'h0 };\n      6'h0a:  r_rgb = { 3'h0, 3'h2, 2'h0 };\n      6'h0b:  r_rgb = { 3'h0, 3'h1, 2'h0 };\n      6'h0c:  r_rgb = { 3'h0, 3'h1, 2'h1 };\n      6'h0d:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h0e:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h0f:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n\n      6'h10:  r_rgb = { 3'h5, 3'h5, 2'h2 };\n      6'h11:  r_rgb = { 3'h0, 3'h3, 2'h3 };\n      6'h12:  r_rgb = { 3'h1, 3'h1, 2'h3 };\n      6'h13:  r_rgb = { 3'h4, 3'h0, 2'h3 };\n      6'h14:  r_rgb = { 3'h5, 3'h0, 2'h2 };\n      6'h15:  r_rgb = { 3'h7, 3'h0, 2'h1 };\n      6'h16:  r_rgb = { 3'h6, 3'h1, 2'h0 };\n      6'h17:  r_rgb = { 3'h6, 3'h2, 2'h0 };\n      6'h18:  r_rgb = { 3'h4, 3'h3, 2'h0 };\n      6'h19:  r_rgb = { 3'h0, 3'h4, 2'h0 };\n      6'h1a:  r_rgb = { 3'h0, 3'h5, 2'h0 };\n      6'h1b:  r_rgb = { 3'h0, 3'h4, 2'h0 };\n      6'h1c:  r_rgb = { 3'h0, 3'h4, 2'h2 };\n      6'h1d:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h1e:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h1f:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n\n      6'h20:  r_rgb = { 3'h7, 3'h7, 2'h3 };\n      6'h21:  r_rgb = { 3'h1, 3'h5, 2'h3 };\n      6'h22:  r_rgb = { 3'h2, 3'h4, 2'h3 };\n      6'h23:  r_rgb = { 3'h5, 3'h4, 2'h3 };\n      6'h24:  r_rgb = { 3'h7, 3'h3, 2'h3 };\n      6'h25:  r_rgb = { 3'h7, 3'h3, 2'h2 };\n      6'h26:  r_rgb = { 3'h7, 3'h3, 2'h1 };\n      6'h27:  r_rgb = { 3'h7, 3'h4, 2'h0 };\n      6'h28:  r_rgb = { 3'h7, 3'h5, 2'h0 };\n      6'h29:  r_rgb = { 3'h4, 3'h6, 2'h0 };\n      6'h2a:  r_rgb = { 3'h2, 3'h6, 2'h1 };\n      6'h2b:  r_rgb = { 3'h2, 3'h7, 2'h2 };\n      6'h2c:  r_rgb = { 3'h0, 3'h7, 2'h3 };\n      6'h2d:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h2e:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h2f:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n\n      6'h30:  r_rgb = { 3'h7, 3'h7, 2'h3 };\n      6'h31:  r_rgb = { 3'h5, 3'h7, 2'h3 };\n      6'h32:  r_rgb = { 3'h6, 3'h6, 2'h3 };\n      6'h33:  r_rgb = { 3'h6, 3'h6, 2'h3 };\n      6'h34:  r_rgb = { 3'h7, 3'h6, 2'h3 };\n      6'h35:  r_rgb = { 3'h7, 3'h6, 2'h3 };\n      6'h36:  r_rgb = { 3'h7, 3'h5, 2'h2 };\n      6'h37:  r_rgb = { 3'h7, 3'h6, 2'h2 };\n      6'h38:  r_rgb = { 3'h7, 3'h7, 2'h2 };\n      6'h39:  r_rgb = { 3'h7, 3'h7, 2'h2 };\n      6'h3a:  r_rgb = { 3'h5, 3'h7, 2'h2 };\n      6'h3b:  r_rgb = { 3'h5, 3'h7, 2'h3 };\n      6'h3c:  r_rgb = { 3'h4, 3'h7, 2'h3 };\n      6'h3d:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h3e:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n      6'h3f:  r_rgb = { 3'h0, 3'h0, 2'h0 };\n    endcase\n  end\nend\n\nassign  o_vblank          = state == VID;\nassign  w_valid           = (r_x_pos >= X_OFFSET) && (r_x_pos < (X_OFFSET + IMAGE_WIDTH)) &&\n                            (r_y_pos >= Y_OFFSET) && (r_y_pos < (Y_OFFSET + IMAGE_HEIGHT));\n\n\nassign  w_x_pos           = w_valid ? r_x_pos - X_OFFSET: 0;\nassign  w_y_pos           = w_valid ? r_y_pos - Y_OFFSET: 0;\n\nassign  o_nes_x_out       = {1'b0, w_x_pos};\nassign  o_nes_y_out       = {1'b0, w_y_pos};\nassign  o_nes_y_next_out  = w_valid ? o_nes_y_out + 1: 1;\n\nassign  o_r_out           = r_valid ? r_rgb[7:5]: w_bg_color[7:5];\nassign  o_g_out           = r_valid ? r_rgb[4:2]: w_bg_color[4:2];\nassign  o_b_out           = r_valid ? r_rgb[1:0]: w_bg_color[1:0];\n\nassign  w_bg_color        = BG_COLOR;\n\n\nalways @ (posedge clk) begin\n  o_sof_stb               <=  0;\n  r_valid                 <=  w_valid;\n  o_pix_pulse_out         <=  0;\n  if (rst) begin\n    r_x_pos               <=  0;\n    r_y_pos               <=  0;\n    r_nes_x_next          <=  0;\n    o_video_hsync         <=  0;\n    state                 <=  IDLE;\n  end\n  else begin\n    case (state)\n      IDLE: begin\n        if (r_start_stb) begin\n          state           <=  VID;\n          r_y_pos         <=  0;\n          r_x_pos         <=  0;\n          r_nes_x_next    <=  1;\n        end\n      end\n      VID: begin\n        if ((r_y_pos == 0) && (r_x_pos == 0)) begin\n          o_sof_stb       <=  1;\n        end\n        if (r_x_pos == 0) begin\n          o_video_hsync   <=  1;\n        end\n        if (r_y_pos < (FRAME_HEIGHT + VBLANK)) begin\n          if (r_x_pos < (FRAME_WIDTH + HBLANK)) begin\n            if (r_x_pos < FRAME_WIDTH) begin\n              if (((r_y_pos >= (Y_OFFSET - 1)) && (r_y_pos < (Y_OFFSET + IMAGE_HEIGHT))) &&\n                  ((r_x_pos >= (X_OFFSET - 1)) && (r_x_pos < (X_OFFSET + IMAGE_WIDTH )))) begin\n                o_pix_pulse_out <=  1;\n              end\n            end\n            else begin\n              o_video_hsync   <=  0;\n            end\n            r_x_pos       <=  r_x_pos + 1;\n          end\n          else begin\n            r_x_pos       <=  0;\n            r_y_pos       <=  r_y_pos + 1;\n          end\n        end\n        else begin\n          state           <=  IDLE;\n        end\n      end\n    endcase\n  end\nend\n\nendmodule\n",
        "module_name": "rgb_generator #",
        "module_hash": "188bfcda63d3752abca8364ea43a0337",
        "dataset_index": 22930
      },
      "integer_to_segment_074a6ce9": {
        "rtl_code": "\nmodule integer_to_segment\n(\n    input [3:0] int_data,\n    output reg [7:0] seg_data\n);\n    \n    always @(int_data) begin\n        case (int_data)\n            4'b0000:    seg_data <= 8'b11000000;    4'b0001:    seg_data <= 8'b11111001;    4'b0010:    seg_data <= 8'b10100100;    4'b0011:    seg_data <= 8'b10110000;    4'b0100:    seg_data <= 8'b10011001;    4'b0101:    seg_data <= 8'b10010010;    4'b0110:    seg_data <= 8'b10000010;    4'b0111:    seg_data <= 8'b11111000;    4'b1000:    seg_data <= 8'b10000000;    4'b1001:    seg_data <= 8'b10010000;    4'b1010:    seg_data <= 8'b10001000;    4'b1011:    seg_data <= 8'b10000011;    4'b1100:    seg_data <= 8'b11000110;    4'b1101:    seg_data <= 8'b10100001;    4'b1110:    seg_data <= 8'b10000110;    4'b1111:    seg_data <= 8'b10001110;    default:    seg_data <= 8'b11111111;    endcase\n    end\nendmodule\n",
        "module_name": "integer_to_segment",
        "module_hash": "074a6ce911efcc0d3f6e025d6cd63492",
        "dataset_index": 14749
      },
      "and_pipeline_bb6126bc": {
        "rtl_code": "\nmodule and_pipeline(\n    input a,\n    input b,\n    input clk, // Added clock input port\n    output reg out\n);\n\nreg stage1_out;\nreg stage2_out;\n\nalways @(posedge clk) begin\n    stage1_out <= a & b;\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\nend\n\nalways @(posedge clk) begin\n    out <= stage2_out;\nend\n\nendmodule\n",
        "module_name": "and_pipeline",
        "module_hash": "bb6126bcd69e41b80d959cddffb40689",
        "dataset_index": 21219
      },
      "ripple_adder_c409fb12": {
        "rtl_code": "\nmodule ripple_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output reg [3:0] SUM,\n    output reg COUT\n);\n\nreg [3:0] stage1_SUM, stage2_SUM, stage3_SUM;\nreg stage1_COUT, stage2_COUT;\n\n// Stage 1\nalways @(*) begin\n    stage1_SUM[0] = A[0] ^ B[0] ^ CIN;\n    stage1_COUT = (A[0] & B[0]) | (A[0] & CIN) | (B[0] & CIN);\nend\n\n// Stage 2\nalways @(*) begin\n    stage2_SUM[1] = A[1] ^ B[1] ^ stage1_COUT;\n    stage2_COUT = (A[1] & B[1]) | (A[1] & stage1_COUT) | (B[1] & stage1_COUT);\nend\n\n// Stage 3\nalways @(*) begin\n    stage3_SUM[2] = A[2] ^ B[2] ^ stage2_COUT;\n    COUT = (A[2] & B[2]) | (A[2] & stage2_COUT) | (B[2] & stage2_COUT);\n    SUM[0] = stage1_SUM[0];\n    SUM[1] = stage2_SUM[1];\n    SUM[2] = stage3_SUM[2];\nend\n\n// Stage 4\nalways @(*) begin\n    stage3_SUM[3] = A[3] ^ B[3] ^ COUT;\n    SUM[3] = stage3_SUM[3];\nend\n\nendmodule",
        "module_name": "ripple_adder",
        "module_hash": "c409fb121822c67c7dba609d15b363fb",
        "dataset_index": 11791
      },
      "nor_gate_using_nand_0ed8ed11": {
        "rtl_code": "module nor_gate_using_nand(\n    input a,\n    input b,\n    output out\n);\n\nwire temp1, temp2;\n\nnand gate1(temp1, a, a);\nnand gate2(temp2, b, b);\nnand gate3(out, temp1, temp2);\n\nendmodule",
        "module_name": "nor_gate_using_nand",
        "module_hash": "0ed8ed11abdaae2b7f71bd0e4782d77f",
        "dataset_index": 16899
      },
      "FSM #_ffd5d21e": {
        "rtl_code": "module FSM #(\nparameter n = 4, // number of states\nparameter m = 2 // number of inputs\n)(\n  input [m-1:0] in,\n  input clk,\n  output reg [n-1:0] out\n);\n\nreg [n-1:0] state; // current state\nreg [n-1:0] next_state; // next state\n\n// Define your state transition and output logic here\nalways @ (in) begin\n  case (state)\n    0: if (in[0] && in[1]) next_state = 3; else if (in[0]) next_state = 1; else if (in[1]) next_state = 2; else next_state = 0;\n    1: if (in[0] && in[1]) next_state = 3; else if (in[1]) next_state = 2; else next_state = 0;\n    2: if (in[0] && in[1]) next_state = 3; else if (in[0]) next_state = 1; else next_state = 0;\n    3: if (in[0] && in[1]) next_state = 3; else if (in[0]) next_state = 1; else if (in[1]) next_state = 2; else next_state = 0;\n  endcase\nend\n\nalways @ (state, in) begin\n  case (state)\n    0: out = {1'b0, 1'b0, 1'b0, 1'b1};\n    1: out = {1'b0, 1'b0, 1'b1, 1'b0};\n    2: out = {1'b0, 1'b1, 1'b0, 1'b0};\n    3: out = {1'b1, 1'b0, 1'b0, 1'b0};\n  endcase\nend\n\nalways @ (posedge clk) begin\n  state <= next_state;\nend\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "ffd5d21efda052b67913ed02c14f800f",
        "dataset_index": 5427
      },
      "flipflop_adder_ecc02dd6": {
        "rtl_code": "module flipflop_adder (\n    input clk,\n    input [7:0] reset,      // Synchronous reset\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] q_reg;\nwire [7:0] sum;\n\nalways @(negedge clk) begin\n    if (reset[0]) q_reg[0] <= 1'b0;\n    else q_reg[0] <= d[0];\n    \n    if (reset[1]) q_reg[1] <= 1'b0;\n    else q_reg[1] <= d[1];\n    \n    if (reset[2]) q_reg[2] <= 1'b0;\n    else q_reg[2] <= d[2];\n    \n    if (reset[3]) q_reg[3] <= 1'b0;\n    else q_reg[3] <= d[3];\n    \n    if (reset[4]) q_reg[4] <= 1'b0;\n    else q_reg[4] <= d[4];\n    \n    if (reset[5]) q_reg[5] <= 1'b0;\n    else q_reg[5] <= d[5];\n    \n    if (reset[6]) q_reg[6] <= 1'b0;\n    else q_reg[6] <= d[6];\n    \n    if (reset[7]) q_reg[7] <= 1'b0;\n    else q_reg[7] <= d[7];\nend\n\nassign sum = q_reg[0] + q_reg[1] + q_reg[2] + q_reg[3] + q_reg[4] + q_reg[5] + q_reg[6] + q_reg[7];\n\nassign q = sum;\n\nendmodule",
        "module_name": "flipflop_adder",
        "module_hash": "ecc02dd695ea5c907d1f558106383f1a",
        "dataset_index": 9528
      },
      "unknown_module_f98e0eed": {
        "rtl_code": "\n\n\n\n\nmodule\n    reverse#(parameter width = 1) (\n        input [(width - 1):0] in, output [(width - 1):0] out\n    );\n\n    genvar ix;\n    generate\n        for (ix = 0; ix < width; ix = ix + 1) begin :Bit\n            assign out[ix] = in[width - 1 - ix];\n        end\n    endgenerate\n\nendmodule\n\n\n\nmodule\n    lowMaskHiLo#(\n        parameter inWidth = 1,\n        parameter topBound = 1,\n        parameter bottomBound = 0\n    ) (\n        input [(inWidth - 1):0] in,\n        output [(topBound - bottomBound - 1):0] out\n    );\n\n    \n    localparam numInVals = 1<<inWidth;\n    \n    wire signed [numInVals:0] c;\n    assign c[numInVals] = 1;\n    assign c[(numInVals - 1):0] = 0;\n    wire [(topBound - bottomBound - 1):0] reverseOut =\n        (c>>>in)>>(numInVals - topBound);\n    reverse#(topBound - bottomBound) reverse(reverseOut, out);\n\nendmodule\n\n\n\nmodule\n    lowMaskLoHi#(\n        parameter inWidth = 1,\n        parameter topBound = 0,\n        parameter bottomBound = 1\n    ) (\n        input [(inWidth - 1):0] in,\n        output [(bottomBound - topBound - 1):0] out\n    );\n\n    \n    localparam numInVals = 1<<inWidth;\n    \n    wire signed [numInVals:0] c;\n    assign c[numInVals] = 1;\n    assign c[(numInVals - 1):0] = 0;\n    wire [(bottomBound - topBound - 1):0] reverseOut =\n        (c>>>~in)>>(topBound + 1);\n    reverse#(bottomBound - topBound) reverse(reverseOut, out);\n\nendmodule\n\n\n\nmodule\n    countLeadingZeros#(parameter inWidth = 1, parameter countWidth = 1) (\n        input [(inWidth - 1):0] in, output [(countWidth - 1):0] count\n    );\n\n    wire [(inWidth - 1):0] reverseIn;\n    reverse#(inWidth) reverse_in(in, reverseIn);\n    wire [inWidth:0] oneLeastReverseIn =\n        {1'b1, reverseIn} & ({1'b0, ~reverseIn} + 1);\n    genvar ix;\n    generate\n        for (ix = 0; ix <= inWidth; ix = ix + 1) begin :Bit\n            wire [(countWidth - 1):0] countSoFar;\n            if (ix == 0) begin\n                assign countSoFar = 0;\n            end else begin\n                assign countSoFar =\n                    Bit[ix - 1].countSoFar | (oneLeastReverseIn[ix] ? ix : 0);\n                if (ix == inWidth) assign count = countSoFar;\n            end\n        end\n    endgenerate\n\nendmodule\n\n\n\nmodule\n    compressBy2#(parameter inWidth = 1) (\n        input [(inWidth - 1):0] in, output [((inWidth - 1)/2):0] out\n    );\n\n    localparam maxBitNumReduced = (inWidth - 1)/2;\n    genvar ix;\n    generate\n        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit\n            assign out[ix] = |in[(ix*2 + 1):ix*2];\n        end\n    endgenerate\n    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*2];\n\nendmodule\n\n\n\nmodule\n    compressBy4#(parameter inWidth = 1) (\n        input [(inWidth - 1):0] in, output [(inWidth - 1)/4:0] out\n    );\n\n    localparam maxBitNumReduced = (inWidth - 1)/4;\n    genvar ix;\n    generate\n        for (ix = 0; ix < maxBitNumReduced; ix = ix + 1) begin :Bit\n            assign out[ix] = |in[(ix*4 + 3):ix*4];\n        end\n    endgenerate\n    assign out[maxBitNumReduced] = |in[(inWidth - 1):maxBitNumReduced*4];\n\nendmodule\n\n",
        "module_name": "unknown_module",
        "module_hash": "f98e0eed9bb52a8de37f58451f69bec8",
        "dataset_index": 23898
      },
      "comparator_2bit_990b1770": {
        "rtl_code": "\nmodule comparator_2bit (\n  input [1:0] A,\n  input [1:0] B,\n  output equal,\n  output greater\n);\n\n  assign equal = (A == B);\n  assign greater = (A > B);\n\nendmodule\nmodule and_nor (\n  input a,\n  input b,\n  output y\n);\n\n  assign y = ~(a | b);\n\nendmodule\nmodule greater_than (\n  input clk,\n  input reset,\n  input [7:0] A,\n  input [7:0] B,\n  output result\n);\n\n  wire [1:0] comp_out [3:0];\n  wire and_out;\n  reg and_out_reg;\n\n  comparator_2bit comp0(.A(A[7:6]), .B(B[7:6]), .equal(comp_out[0][0]), .greater(comp_out[0][1]));\n  comparator_2bit comp1(.A(A[5:4]), .B(B[5:4]), .equal(comp_out[1][0]), .greater(comp_out[1][1]));\n  comparator_2bit comp2(.A(A[3:2]), .B(B[3:2]), .equal(comp_out[2][0]), .greater(comp_out[2][1]));\n  comparator_2bit comp3(.A(A[1:0]), .B(B[1:0]), .equal(comp_out[3][0]), .greater(comp_out[3][1]));\n\n  and_nor and_gate(.a(comp_out[3][1]), .b(and_out_reg), .y(and_out));\n\n  reg [3:0] result_reg;\n  \n  wire or_gate;\n  assign or_gate = comp_out[3][0] || and_out_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      result_reg <= 4'b0;\n      and_out_reg <= 1'b0;\n    end else begin\n      result_reg <= {result_reg[2:0], or_gate};\n      and_out_reg <= and_out;\n    end\n  end\n\n  assign result = result_reg[3];\n\nendmodule",
        "module_name": "comparator_2bit",
        "module_hash": "990b1770337d43fe933cf879452bd505",
        "dataset_index": 679
      },
      "mux_2to1_c5aa4100": {
        "rtl_code": "module mux_2to1 (\n    input [1:0] data_in,\n    input sel,\n    output data_out\n);\n\n    assign data_out = (sel == 1'b0) ? data_in[0] : data_in[1];\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "c5aa4100c71f2c75b1e10a44d1fffb54",
        "dataset_index": 8803
      },
      "generic_sram_line_en_95a5c65c": {
        "rtl_code": "module generic_sram_line_en\n#(\nparameter DATA_WIDTH            = 128,\nparameter ADDRESS_WIDTH         = 7,\nparameter INITIALIZE_TO_ZERO    = 0\n)\n\n(\ninput                           i_clk,\ninput      [DATA_WIDTH-1:0]     i_write_data,\ninput                           i_write_enable,\ninput      [ADDRESS_WIDTH-1:0]  i_address,\noutput reg [DATA_WIDTH-1:0]     o_read_data\n);\n\nreg [DATA_WIDTH-1:0]   mem  [0:2**ADDRESS_WIDTH-1];\n\ngenerate\nif ( INITIALIZE_TO_ZERO ) begin : init0\ninteger i;\ninitial\n    begin\n    for (i=0;i<2**ADDRESS_WIDTH;i=i+1)\n        mem[i] <= 'd0;\n    end\nend\nendgenerate\n\n    \nalways @(posedge i_clk)\n    begin\n    // read\n    o_read_data <= i_write_enable ? {DATA_WIDTH{1'd0}} : mem[i_address];\n\n    // write\n    if (i_write_enable)\n        mem[i_address] <= i_write_data;\n    end\n    \n    \n\nendmodule",
        "module_name": "generic_sram_line_en",
        "module_hash": "95a5c65c6acddf9a84a466687cdd82f8",
        "dataset_index": 7565
      },
      "BFM_APB2APB_39f20eef": {
        "rtl_code": "\nmodule BFM_APB2APB ( PCLK_PM, PRESETN_PM, PADDR_PM, PWRITE_PM, PENABLE_PM, PWDATA_PM, PRDATA_PM, PREADY_PM, PSLVERR_PM,\n                     PCLK_SC, PSEL_SC, PADDR_SC, PWRITE_SC, PENABLE_SC, PWDATA_SC, PRDATA_SC, PREADY_SC, PSLVERR_SC);\n\n    parameter[9:0] TPD  = 1;\n   \n   \n    localparam TPDns  = TPD * 1;\n\n    input PCLK_PM; \n    input PRESETN_PM; \n    input[31:0] PADDR_PM; \n    input PWRITE_PM; \n    input PENABLE_PM; \n    input[31:0] PWDATA_PM; \n    output[31:0] PRDATA_PM; \n    reg[31:0] PRDATA_PM;\n    output PREADY_PM; \n    reg PREADY_PM;\n    output PSLVERR_PM; \n    reg PSLVERR_PM;\n    input PCLK_SC; \n    output[15:0] PSEL_SC; \n    wire[15:0] #TPDns PSEL_SC;\n    output[31:0] PADDR_SC; \n    wire[31:0] #TPDns PADDR_SC;\n    output PWRITE_SC; \n    wire #TPDns PWRITE_SC;\n    output PENABLE_SC; \n    wire #TPDns PENABLE_SC;\n    output[31:0] PWDATA_SC; \n    wire[31:0] #TPDns PWDATA_SC;\n    input[31:0] PRDATA_SC; \n    input PREADY_SC; \n    input PSLVERR_SC; \n\n    parameter[0:0] IDLE = 0; \n    parameter[0:0] ACTIVE = 1; \n    reg[0:0] STATE_PM; \n    parameter[1:0] T0 = 0; \n    parameter[1:0] T1 = 1; \n    parameter[1:0] T2 = 2; \n    reg[1:0] STATE_SC; \n\n    reg[15:0] PSEL_P0; \n    reg[31:0] PADDR_P0; \n    reg PWRITE_P0; \n    reg PENABLE_P0; \n    reg[31:0] PWDATA_P0; \n    reg PSELEN; \n    reg[31:0] PRDATA_HD; \n    reg PSLVERR_HD; \n    reg PENABLE_PM_P0; \n    reg TRIGGER; \n    reg DONE; \n\n    always @(posedge PCLK_PM or negedge PRESETN_PM)\n    begin\n        if (PRESETN_PM == 1'b0)\n        begin\n            STATE_PM <= IDLE ; \n            TRIGGER <= 1'b0 ; \n            PREADY_PM <= 1'b0 ; \n            PSLVERR_PM <= 1'b0 ; \n            PRDATA_PM <= {32{1'b0}} ; \n            PENABLE_PM_P0 <= 1'b0 ; \n        end\n        else\n        begin\n            PREADY_PM <= 1'b0 ; \n            PENABLE_PM_P0 <= PENABLE_PM ; \n            case (STATE_PM)\n                IDLE :\n                            begin\n                                if (PENABLE_PM == 1'b1 & PENABLE_PM_P0 == 1'b0)\n                                begin\n                                    TRIGGER <= 1'b1 ; \n                                    STATE_PM <= ACTIVE ; \n                                end \n                            end\n                ACTIVE :\n                            begin\n                                if (DONE == 1'b1)\n                                begin\n                                    STATE_PM <= IDLE ; \n                                    TRIGGER <= 1'b0 ; \n                                    PREADY_PM <= 1'b1 ; \n                                    PSLVERR_PM <= PSLVERR_HD ; \n                                    PRDATA_PM <= PRDATA_HD ; \n                                end \n                            end\n            endcase \n        end \n    end \n\n    always @(posedge PCLK_SC or negedge TRIGGER)\n    begin\n        if (TRIGGER == 1'b0)\n        begin\n            STATE_SC <= T0 ; \n            DONE <= 1'b0 ; \n            PRDATA_HD <= {32{1'b0}} ; \n            PSLVERR_HD <= 1'b0 ; \n            PSELEN <= 1'b0 ; \n            PENABLE_P0 <= 1'b0 ; \n            PADDR_P0 <= {32{1'b0}} ; \n            PWDATA_P0 <= {32{1'b0}} ; \n            PWRITE_P0 <= 1'b0 ; \n        end\n        else\n        begin\n            case (STATE_SC)\n                T0 :\n                            begin\n                                STATE_SC <= T1 ; \n                                PADDR_P0 <= PADDR_PM ; \n                                PWDATA_P0 <= PWDATA_PM ; \n                                PWRITE_P0 <= PWRITE_PM ; \n                                PSELEN <= 1'b1 ; \n                                PENABLE_P0 <= 1'b0 ; \n                                DONE <= 1'b0 ; \n                            end\n                T1 :\n                            begin\n                                STATE_SC <= T2 ; \n                                PENABLE_P0 <= 1'b1 ; \n                            end\n                T2 :\n                            begin\n                                if (PREADY_SC == 1'b1)\n                                begin\n                                    DONE <= 1'b1 ; \n                                    PRDATA_HD <= PRDATA_SC ; \n                                    PSLVERR_HD <= PSLVERR_SC ; \n                                    PSELEN <= 1'b0 ; \n                                    PENABLE_P0 <= 1'b0 ; \n                                    PADDR_P0 <= {32{1'b0}} ; \n                                    PWDATA_P0 <= {32{1'b0}} ; \n                                    PWRITE_P0 <= 1'b0 ; \n                                end \n                            end\n            endcase \n        end \n    end \n\n    always @(PADDR_P0 or PSELEN)\n    begin\n        PSEL_P0 <= {16{1'b0}} ; \n        if (PSELEN == 1'b1)\n        begin\n            begin : xhdl_5\n                integer i;\n                for(i = 0; i <= 15; i = i + 1)\n                begin\n                    PSEL_P0[i] <= (PADDR_P0[27:24] == i); \n                end\n            end \n        end \n    end \n\n    assign PSEL_SC    = PSEL_P0 ;\n    assign PADDR_SC   = PADDR_P0 ;\n    assign PWRITE_SC  = PWRITE_P0 ;\n    assign PENABLE_SC = PENABLE_P0 ;\n    assign PWDATA_SC  = PWDATA_P0 ;\n\n\nendmodule\n",
        "module_name": "BFM_APB2APB",
        "module_hash": "39f20eefa1d224bb827783bd88d92b59",
        "dataset_index": 11217
      },
      "ripple_carry_adder_3ef92dfe": {
        "rtl_code": "module ripple_carry_adder(\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [8:0] res\n);\n\nreg [2:0] temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;\nwire p0, p1, p2, p3, p4, p5, p6, g0, g1, g2, g3, g4, g5, g6, c1, c2, c3, c4, c5, c6, c7;\nwire p1c1, p2c2, p3c3, p4c4, p5c5, p6c6;\nwire carry_pred_1, carry_pred_2, carry_pred_3, carry_pred_4, carry_pred_5, carry_pred_6;\n\nand and_0(g0, in1[0], in2[0]);\nand and_1(g1, in1[1], in2[1]);\nand and_2(g2, in1[2], in2[2]);\nand and_3(g3, in1[3], in2[3]);\nand and_4(g4, in1[4], in2[4]);\nand and_5(g5, in1[5], in2[5]);\nand and_6(g6, in1[6], in2[6]);\n\nxor xor_0(p0, in1[0], in2[0]);\nxor xor_1(p1, in1[1], in2[1]);\nxor xor_2(p2, in1[2], in2[2]);\nxor xor_3(p3, in1[3], in2[3]);\nxor xor_4(p4, in1[4], in2[4]);\nxor xor_5(p5, in1[5], in2[5]);\nxor xor_6(p6, in1[6], in2[6]);\n\nassign c1 = g0;\n\nassign c2 = g1;\nand and_7(p1c1, p1, c1);\nor or_0(carry_pred_1, c2, p1c1);\n\nassign c3 = g2;\nand and_8(p2c2, p2, c2);\nor or_2(carry_pred_2, c3, p2c2);\n\nassign c4 = g3;\nand and_10(p3c3, p3, c3);\nor or_5(carry_pred_3, c4, p3c3);\n\nassign c5 = g4;\nand and_13(p4c4, p4, c4);\nor or_9(carry_pred_4, c5, p4c4);\n\nassign c6 = g5;\nand and_17(p5c5, p5, c5);\nor or_14(carry_pred_5, c6, p5c5);\n\nassign c7 = g6;\nand and_22(p6c6, p6, c6);\nor or_20(carry_pred_6, c7, p6c6);\n\n// Results\nalways @(*) begin\n    temp1[1:0] = in1[0] + in2[0];\n    temp2[1:0] = in1[1] + in2[1] + c1;\n    temp3[1:0] = in1[2] + in2[2] + carry_pred_1;\n    temp4[1:0] = in1[3] + in2[3] + carry_pred_2;\n    temp5[1:0] = in1[4] + in2[4] + carry_pred_3;\n    temp6[1:0] = in1[5] + in2[5] + carry_pred_4;\n    temp7[1:0] = in1[6] + in2[6] + carry_pred_5;\n    temp8[1:0] = in1[7] + in2[7] + carry_pred_6;\n    res[8:0] = {temp8[1:0], temp7[0], temp6[0], temp5[0], temp4[0], temp3[0], temp2[0], temp1[0]};\nend\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "3ef92dfe53075bcae7f480ebb12e6a4d",
        "dataset_index": 6731
      },
      "full_adder_2bit_0202592c": {
        "rtl_code": "\nmodule full_adder_2bit(\n    input [1:0] A,\n    input [1:0] B,\n    input Cin,\n    output [1:0] S,\n    output Cout\n);\n\nwire CO1, CO2;\n\nHAHD2X HA1(A[0], B[0], CO1, S[0]);\nHAHD2X HA2(A[1], B[1], CO2, S[1]);\n\nassign Cout = CO1 | CO2 | Cin; // Fix: Assign Cout directly\n\nendmodule\nmodule HAHD2X(\n    input A,\n    input B,\n    output CO,\n    output S\n);\n\nxor gate1(S, A, B);\nand gate2(CO, A, B);\n\nendmodule\nmodule or_gate(\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\nassign Y = A | B | C;\n\nendmodule",
        "module_name": "full_adder_2bit",
        "module_hash": "0202592cf0e05a0cc5a0829ac2eb6d61",
        "dataset_index": 2388
      },
      "decoder_40bcbb5c": {
        "rtl_code": "module decoder (\n    input [3:0] in,\n    input clk,\n    output [15:0] out\n);\n\nreg [15:0] out_reg1, out_reg2, out_reg3, out_reg4;\n\nassign out = out_reg4;\n\nalways @ (in) begin\n    out_reg1[0] = ~in[0] & ~in[1] & ~in[2] & ~in[3];\n    out_reg1[1] = ~in[0] & ~in[1] & ~in[2] & in[3];\n    out_reg1[2] = ~in[0] & ~in[1] & in[2] & ~in[3];\n    out_reg1[3] = ~in[0] & ~in[1] & in[2] & in[3];\n    out_reg1[4] = ~in[0] & in[1] & ~in[2] & ~in[3];\n    out_reg1[5] = ~in[0] & in[1] & ~in[2] & in[3];\n    out_reg1[6] = ~in[0] & in[1] & in[2] & ~in[3];\n    out_reg1[7] = ~in[0] & in[1] & in[2] & in[3];\n    out_reg1[8] = in[0] & ~in[1] & ~in[2] & ~in[3];\n    out_reg1[9] = in[0] & ~in[1] & ~in[2] & in[3];\n    out_reg1[10] = in[0] & ~in[1] & in[2] & ~in[3];\n    out_reg1[11] = in[0] & ~in[1] & in[2] & in[3];\n    out_reg1[12] = in[0] & in[1] & ~in[2] & ~in[3];\n    out_reg1[13] = in[0] & in[1] & ~in[2] & in[3];\n    out_reg1[14] = in[0] & in[1] & in[2] & ~in[3];\n    out_reg1[15] = in[0] & in[1] & in[2] & in[3];\nend\n\nalways @ (posedge clk) begin\n    out_reg4 <= out_reg3;\n    out_reg3 <= out_reg2;\n    out_reg2 <= out_reg1;\nend\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "40bcbb5c08f41ebe32124d6476edb9a6",
        "dataset_index": 3979
      },
      "priority_encoder_e007b3cb": {
        "rtl_code": "\nmodule priority_encoder (\n    input [15:0] data_in,\n    output [1:0] priority_input,\n    output [1:0] highest_input\n);\n\n    assign priority_input = (data_in[15] == 1) ? 2'b01 : (data_in[14] == 1) ? 2'b10 : 2'b00;\n    assign highest_input = (priority_input == 2'b00) ? (data_in[0]) ? 2'b01 : 2'b00 : (priority_input == 2'b01) ? (data_in[1]) ? 2'b10 : 2'b01 : (data_in[2]) ? 2'b11 : 2'b10;\n\nendmodule\n",
        "module_name": "priority_encoder",
        "module_hash": "e007b3cb750a9b54d0200194cc1a2678",
        "dataset_index": 6055
      },
      "sky130_fd_sc_lp__or3b_11b4d39f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__or3b (\n    X  ,\n    A  ,\n    B  ,\n    C_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , C_N            );\n    or  or0  (or0_out_X, B, A, not0_out );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__or3b",
        "module_hash": "11b4d39fb569bb4eca492ca58413dc1f",
        "dataset_index": 16113
      },
      "binary_adder_0c63785d": {
        "rtl_code": "module binary_adder (\n    // inputs\n    input [3:0] A,\n    input [3:0] B,\n    // outputs\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] sum;\nwire [3:0] carry;\n\nfull_adder fa0(\n    .A(A[0]),\n    .B(B[0]),\n    .Cin(1'b0),\n    .S(sum[0]),\n    .Cout(carry[0])\n);\n\nfull_adder fa1(\n    .A(A[1]),\n    .B(B[1]),\n    .Cin(carry[0]),\n    .S(sum[1]),\n    .Cout(carry[1])\n);\n\nfull_adder fa2(\n    .A(A[2]),\n    .B(B[2]),\n    .Cin(carry[1]),\n    .S(sum[2]),\n    .Cout(carry[2])\n);\n\nfull_adder fa3(\n    .A(A[3]),\n    .B(B[3]),\n    .Cin(carry[2]),\n    .S(sum[3]),\n    .Cout(Cout)\n);\n\nassign S = sum;\n\nendmodule\n\nmodule full_adder (\n    // inputs\n    input A,\n    input B,\n    input Cin,\n    // outputs\n    output S,\n    output Cout\n);\n\nwire xor1;\nwire and1;\nwire and2;\n\nassign xor1 = A ^ B;\nassign and1 = A & B;\nassign and2 = xor1 & Cin;\n\nassign S = xor1 ^ Cin;\nassign Cout = and1 | and2;\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "0c63785d4c08c41a5e254a7316e12d52",
        "dataset_index": 2950
      },
      "up_counter_064bfdd3": {
        "rtl_code": "module up_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 4'b0000;\n  end else begin\n    if (count == 4'b1111) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "up_counter",
        "module_hash": "064bfdd3480d7e8eb4a5a2decad49de5",
        "dataset_index": 2582
      },
      "sky130_fd_sc_ms__a22o_9d93e98d": {
        "rtl_code": "\nmodule sky130_fd_sc_ms__a22o (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire sel;\n\n    assign sel = VPB & ~VNB;\n\n    assign X = sel ? A1 : A2;\n    // assign X = sel ? A1 : B1;\n    // assign X = sel ? B2 : A2;\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__a22o",
        "module_hash": "9d93e98d9b25477732aeb5b44ca52759",
        "dataset_index": 21279
      },
      "VGA_Control_d2d9fbb9": {
        "rtl_code": "\nmodule VGA_Control(clock, reset, actual_x, actual_y, h_sync, v_sync);\n\tinput clock, reset;\n\toutput reg h_sync, v_sync;\n\t\n\t\n\toutput [9:0] actual_x;\n\toutput [8:0] actual_y;\n\t\n\t\n\treg [9:0] hcounter, vcounter;\n\t\n\tinitial\n\t\tbegin\n\t\t\thcounter <= 10'b0;\n\t\t\tvcounter <= 10'b0;\n\t\tend\n\n\t\n\tassign actual_x = hcounter - 144;\n\tassign actual_y = vcounter - 31;\t\n\t\n\talways @ (posedge clock or posedge reset)\n\t\tbegin\n\t\t\tif(reset)\n\t\t\t\tbegin\n\t\t\t\t\thcounter <= 10'b0;\n\t\t\t\t\tvcounter <= 10'b0;\t\t\n\t\t\t\tend \n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\n\t\t\t\t\t\t \n\t\t\t\t\tif( (hcounter > 10'd0) && (hcounter < 10'd97) ) \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\th_sync <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\th_sync <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif( (vcounter > 10'd0) && (vcounter < 10'd3) ) \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tv_sync <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tv_sync <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\n\t\t\t\t\t\n\t\t\t\t\thcounter <= hcounter + 1;\n\t\t\t\t\tif(hcounter == 10'd800)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tvcounter <= vcounter + 1;\n\t\t\t\t\t\t\thcounter <= 10'b0;\n\t\t\t\t\t\tend\n\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(vcounter == 10'd521)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tvcounter <= 10'b0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\t\n\t\tend \n\nendmodule\n",
        "module_name": "VGA_Control",
        "module_hash": "d2d9fbb9950dcf10bbb5a9b33c38b3d6",
        "dataset_index": 22810
      },
      "min_finder_e2e38a2b": {
        "rtl_code": "module min_finder (\n    input [7:0] a, b, c, d,\n    output [7:0] min);\n\n    wire [7:0] ab_min, cd_min;\n    wire [7:0] abcd_min;\n\n    // Find minimum of a and b\n    pipeline_stage #(.WIDTH(8)) stage1 (.in_a(a), .in_b(b), .out(ab_min));\n\n    // Find minimum of c and d\n    pipeline_stage #(.WIDTH(8)) stage2 (.in_a(c), .in_b(d), .out(cd_min));\n\n    // Find minimum of ab_min and cd_min\n    pipeline_stage #(.WIDTH(8)) stage3 (.in_a(ab_min), .in_b(cd_min), .out(abcd_min));\n\n    assign min = abcd_min;\n\nendmodule\n\nmodule pipeline_stage #(\n    parameter WIDTH = 8\n) (\n    input [WIDTH-1:0] in_a,\n    input [WIDTH-1:0] in_b,\n    output reg [WIDTH-1:0] out\n);\n\n    always @(*) begin\n        if (in_a < in_b) begin\n            out = in_a;\n        end else begin\n            out = in_b;\n        end\n    end\n\nendmodule",
        "module_name": "min_finder",
        "module_hash": "e2e38a2b5a62d250f1c1b5a6ac73aefd",
        "dataset_index": 16321
      },
      "combinational_circuit_54acbec8": {
        "rtl_code": "module combinational_circuit (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input B2,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign X = (A1 == 1'b1) ? B1 : ((A2 == 1'b1) && (A3 == 1'b0)) ? B2 : B1;\n\nendmodule",
        "module_name": "combinational_circuit",
        "module_hash": "54acbec89fe7830e565cd77e2f55b43e",
        "dataset_index": 2810
      },
      "top__69f135bb": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input rst,\n    input [3:0] in,\n    input load,\n    output reg [15:0] data_out,\n    output reg [3:0] count\n);\n\nwire [15:0] decoder_out;\nreg [15:0] shift_reg;\n\n// 4-to-16 decoder module\ndecoder_4to16 decoder (\n    .in(in),\n    .out(decoder_out)\n);\n\n// 16-bit shift register module\nshift_register_16bit shift_reg_inst (\n    .clk(clk),\n    .rst(rst),\n    .load(load),\n    .data_in(decoder_out),\n    .data_out(shift_reg)\n);\n\n// Counter module\ncounter_16bit counter_inst (\n    .data_in(shift_reg),\n    .count(count)\n);\n\nalways @(posedge clk) begin\n    data_out <= shift_reg;\nend\n\nendmodule\nmodule decoder_4to16 (\n    input [3:0] in,\n    output [15:0] out\n);\n\nassign out = 1 << in;\n\nendmodule\nmodule shift_register_16bit (\n    input clk,\n    input rst,\n    input load,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_out <= 16'b0;\n    end else if (load) begin\n        data_out <= data_in;\n    end else begin\n        data_out <= {data_out[14:0], 1'b0};\n    end\nend\n\nendmodule\nmodule counter_16bit (\n    input [15:0] data_in,\n    output reg [3:0] count\n);\n\ninteger i;\n\nalways @(*) begin\n    count = 0;\n    for (i = 0; i < 16; i = i + 1) begin\n        if (data_in[i]) begin\n            count = count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "69f135bb5be9417e0570e27b49d1dcb9",
        "dataset_index": 279
      },
      "nios_altmemddr_0_ex_lfsr8_901a5da5": {
        "rtl_code": "module nios_altmemddr_0_ex_lfsr8 (\nclk, reset_n, enable, pause, load, data, ldata);\n\n   parameter seed  = 32;\n   input clk;\n   input reset_n;\n   input enable;\n   input pause;\n   input load;\n   output[8 - 1:0] data;\n   wire[8 - 1:0] data;\n   input[8 - 1:0] ldata;\n\n   reg[8 - 1:0] lfsr_data;\n\n   assign data = lfsr_data ;\n\n   always @(posedge clk or negedge reset_n)\n   begin\n      if (!reset_n)\n      begin\n         lfsr_data <= seed[7:0] ;\n      end\n      else\n      begin\n         if (!enable)\n         begin\n            lfsr_data <= seed[7:0];\n         end\n         else\n         begin\n            if (load)\n            begin\n               lfsr_data <= ldata ;\n            end\n            else\n            begin\n               if (!pause)\n               begin\n                  lfsr_data[0] <= lfsr_data[7] ;\n                  lfsr_data[1] <= lfsr_data[0] ;\n                  lfsr_data[2] <= lfsr_data[1] ^ lfsr_data[7] ;\n                  lfsr_data[3] <= lfsr_data[2] ^ lfsr_data[7] ;\n                  lfsr_data[4] <= lfsr_data[3] ^ lfsr_data[7] ;\n                  lfsr_data[5] <= lfsr_data[4] ;\n                  lfsr_data[6] <= lfsr_data[5] ;\n                  lfsr_data[7] <= lfsr_data[6] ;\n               end\n            end\n         end\n      end\n   end\nendmodule\n",
        "module_name": "nios_altmemddr_0_ex_lfsr8",
        "module_hash": "901a5da59bc3146fd49fc0d49c82213b",
        "dataset_index": 23802
      },
      "kb_code_1bf831ed": {
        "rtl_code": "module kb_code\n  (\n    input wire clk, reset,scan_done_tick,\n    input wire [7:0] scan_out,\n    output reg got_code_tick\n   );\n\n   localparam BRK = 8'hf0; localparam\n      wait_brk = 1'b0,\n      get_code = 1'b1;\n\n   reg state_reg, state_next;\n\n   always @(posedge clk, posedge reset)\n      if (reset)\n         state_reg <= wait_brk;\n      else\n         state_reg <= state_next;\n\n   always @*\n   begin\n      got_code_tick = 1'b0;\n      state_next = state_reg;\n      case (state_reg)\n         wait_brk:  if (scan_done_tick==1'b1 && scan_out==BRK)\n               state_next = get_code;\n         get_code:  if (scan_done_tick)\n               begin\n                  got_code_tick =1'b1;\n                  state_next = wait_brk;\n               end\n      endcase\n   end\n\nendmodule\n",
        "module_name": "kb_code",
        "module_hash": "1bf831ed6629db8d0cd9d66a032054bb",
        "dataset_index": 21702
      },
      "signed_mag_multiplier_62683920": {
        "rtl_code": "module signed_mag_multiplier (\n    input signed [3:0] a,\n    input signed [3:0] b,\n    output signed [7:0] product,\n    output overflow\n);\n    \n    reg signed [7:0] temp_product;\n    reg signed [3:0] temp_a;\n    reg signed [3:0] temp_b;\n    reg overflow_flag;\n    \n    always @(*) begin\n        temp_a = (a < 0) ? (~a + 1) : a;\n        temp_b = (b < 0) ? (~b + 1) : b;\n        temp_product = temp_a * temp_b;\n        if (temp_product > 127 || temp_product < -128) begin\n            overflow_flag = 1;\n        end else begin\n            overflow_flag = 0;\n        end\n    end\n    \n    assign product = (a < 0) ^ (b < 0) ? (~temp_product + 1) : temp_product;\n    assign overflow = overflow_flag;\n    \nendmodule",
        "module_name": "signed_mag_multiplier",
        "module_hash": "62683920987e9c31b72ff75f062260a0",
        "dataset_index": 9762
      },
      "adder_e450c7cf": {
        "rtl_code": "module adder\n(\n\tinput                     clk      ,\n\tinput                     rst      ,\n\tinput      [31:0]         ain      ,\n\tinput      [31:0]         bin      ,\n\toutput reg [31:0]         result   ,\n\toutput reg [31:0]         statistic \n);\n\n\n\treg [31:0] result_last;\n\n\n\t\n\talways @(posedge clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\tresult      <= 32'h0;\n\t\t\tresult_last <= 32'h0;\n\t\tend else begin\n\t\t\tresult      <= ain + bin;\n\t\t\tresult_last <= result;\n\t\tend\n\tend\n\t\n\t\n\talways @(posedge clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\tstatistic[31:16] <= 16'hc001;\n\t\t\tstatistic[15:0]  <= 16'h0;\n\t\tend else begin\n\t\t\tif ( result != result_last ) begin\n\t\t\t\tstatistic[15:0] <= statistic[15:0] + 16'h1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule",
        "module_name": "adder",
        "module_hash": "e450c7cf22ddb85a0d8f244db415eeab",
        "dataset_index": 4633
      },
      "toy_icache_656701d1": {
        "rtl_code": "`define IC_WIDTH_BITS 4\n`define IC_LINES_BITS 6\n`define IC_WIDTH_ZERO 4'b0000\n`define IC_WIDTH_ONES 4'b1111\n\n`define IC_WIDTH (1<<`IC_WIDTH_BITS)\n`define IC_LINES (1<<`IC_LINES_BITS)\n\n`ifdef DUMMY_CACHE\nmodule toy_icache(input clk,\n                  input             reset,\n\n                  input [31:0]      ic_addr,\n                  input             ic_rq,\n                  output reg        ic_data_out_valid,\n                  output reg [31:0] ic_data_out,\n\n                  input [31:0]      data_in, input             data_in_ready, output reg        data_rd, output reg [31:0] data_address );\n   always @(posedge clk)\n     begin\n        data_address <= ic_addr;\n        data_rd <= ic_rq;\n        ic_data_out <= data_in;\n        ic_data_out_valid <= data_in_ready;\n     end\n\nendmodule\n`endif\n\n`ifndef DUMMY_CACHE\nmodule toy_icache(input clk,\n                  input \t    reset,\n\n                  input [31:0] \t    ic_addr,\n                  input \t    ic_rq,\n                  output reg \t    ic_data_out_valid,\n                  output reg [31:0] ic_data_out,\n\n                  input [31:0] \t    data_in, input \t    data_in_ready, output reg \t    data_rd, output reg [31:0] data_address );\n\n   reg [31-`IC_WIDTH_BITS+1:0]      ictags[0:`IC_LINES-1];\n   reg [31:0]                       cacheram[0:`IC_LINES*`IC_WIDTH-1];\n\n   wire [31-`IC_WIDTH_BITS:0]       addrtag;\n   \n   assign addrtag = ic_addr[31:`IC_WIDTH_BITS];\n   \n   reg [31-`IC_WIDTH_BITS+1:0]      icnewtag;\n   \n\n   parameter S_IDLE = 0;\n   parameter S_FILL = 1;\n   parameter S_FILL_STEP = 2;\n   parameter S_FILL_START = 3;\n   \n   reg [2:0]                                   ic_state;\n\n   reg [31:0]                                  ictagsout;\n   reg [1:0]                                   ic_rq_shift;\n   \n   always @(posedge clk)\n     if (!reset) begin\n        ic_data_out_valid <= 0;\n        ic_data_out <= 0;\n        icnewtag <= 0;\n        data_rd <= 0;\n        ic_state <= S_IDLE;\n        ictagsout <= 0;\n        ic_rq_shift <= 0;\n     end else begin\n        ic_rq_shift <= {ic_rq_shift[0],ic_rq};\n        ictagsout <= ictags[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:`IC_WIDTH_BITS]];\n        case (ic_state)\n          S_IDLE:\n            if (ic_rq_shift[1]) begin\n               if(ictagsout == {1'b1,addrtag}) begin\n`ifdef ICDEBUG\n                    $display(\"ICACHE HIT: %X -> %X\", ic_addr, cacheram[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:0]]);\n                    \n`endif\n\n                    ic_data_out <= cacheram[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:0]];\n                    ic_data_out_valid <= 1;\n                 end else begin `ifdef ICDEBUG\n                    $display(\"ICACHE SHIT: %X [%X vs. %X] at %X\", ic_addr, ictags[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:`IC_WIDTH_BITS]], {1'b1,addrtag}, ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:`IC_WIDTH_BITS]);\n`endif\n                    ic_data_out_valid <= 0;\n                    ictags[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:`IC_WIDTH_BITS]] <= 0; ic_state <= S_FILL_START;\n                    data_address <= {ic_addr[31:`IC_WIDTH_BITS],`IC_WIDTH_ZERO}; data_rd <= 0;\n                    icnewtag <= {1'b1, addrtag};\n                 end\n            end else begin \n               ic_data_out_valid <= 0;\n               ic_data_out <= 0;\n            end S_FILL_START: begin\n             ic_state <= S_FILL_STEP;\n          end\n          S_FILL: begin\n             if (data_in_ready) begin\n`ifdef ICDEBUG\n                $display(\"ICACHE FILL %X <- %X\", data_address, data_in);\n`endif\n                \n                if (ic_rq && data_address == ic_addr) begin `ifdef ICDEBUG\n                   $display(\"ICACHE FHIT: %X -> %X\", ic_addr, data_in);\n`endif\n\n                   ic_data_out <= data_in;\n                   ic_data_out_valid <= 1;\n                end else begin\n                   ic_data_out_valid <= 0;\n                   ic_data_out <= 0;\n                end\n                cacheram[data_address[`IC_LINES_BITS+`IC_WIDTH_BITS-1:0]] <= data_in;\n                data_rd <= 0;\n                if (data_address[`IC_WIDTH_BITS-1:0] == `IC_WIDTH_ONES) begin\n`ifdef ICDEBUG\n                   $display(\"ICACHE FILLING DONE %X at %X\", icnewtag, data_address[`IC_LINES_BITS+`IC_WIDTH_BITS-1:`IC_WIDTH_BITS]);\n`endif\n                   \n                   ictags[data_address[`IC_LINES_BITS+`IC_WIDTH_BITS-1:`IC_WIDTH_BITS]] <= icnewtag; ic_state <= S_IDLE;\n                end else begin\n                   ic_state <= S_FILL_STEP;\n                   data_address <= data_address + 1;\n                end\n             end else begin if (ic_rq && \n                    data_address[`IC_LINES_BITS+`IC_WIDTH_BITS-1:`IC_WIDTH_BITS]\n                      ==\n                    ic_addr[`IC_LINES_BITS+`IC_WIDTH_BITS-1:`IC_WIDTH_BITS]\n                    && !(data_address[31:`IC_WIDTH_BITS] == ic_addr[31:`IC_WIDTH_BITS])) begin\n                   ictags[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:`IC_WIDTH_BITS]] <= 0;\n                   ic_state <= S_IDLE;\n                   ic_data_out_valid <= 0;\n                end\n                if (ic_rq && data_address[31:`IC_WIDTH_BITS] == ic_addr[31:`IC_WIDTH_BITS]\n                    && ic_addr[`IC_WIDTH_BITS-1:0] < data_address[`IC_WIDTH_BITS-1:0]) begin\n`ifdef ICDEBUG\n                   $display(\"ICACHE FFHIT: %X -> %X [%X vs %X]\", ic_addr, cacheram[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:0]],\n                            ic_addr[`IC_WIDTH_BITS-1:0], data_address[`IC_WIDTH_BITS-1:0]);\n                   \n`endif\n\n                   ic_data_out <= cacheram[ic_addr[`IC_WIDTH_BITS+`IC_LINES_BITS-1:0]];\n                   ic_data_out_valid <= 1;\n                end else begin \n                   ic_data_out_valid <= 0;\n                   ic_data_out <= 0;\n                end\n             end\n          end S_FILL_STEP: begin \n             data_rd <= 1;\n             ic_state <= S_FILL;\n             ic_data_out_valid <= 0;\n             ic_data_out <= 0;\n          end\n        endcase end\n\nendmodule\n`endif ",
        "module_name": "toy_icache",
        "module_hash": "656701d14519664092381d4739a15957",
        "dataset_index": 22012
      },
      "POR_22e01e4d": {
        "rtl_code": "module POR (\n    input VDD,\n    input CLK,\n    input reset, \n    output reg RESET\n);\n\nparameter t = 10; // Number of clock cycles for the reset signal delay\nparameter IDLE = 2'b00, DELAY = 2'b01, NORMAL = 2'b10, DEFAULT = 2'b11;\n\nreg [1:0] state; // Removed the initialization from here\nreg [31:0] counter; // Counter for delay\n\nalways @(posedge CLK or posedge reset) begin\n    if (reset) begin\n        state <= IDLE; // Set the state to IDLE on reset\n        RESET <= 1'b1; // Assert the RESET signal initially\n        counter <= 0; // Initialize the counter\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                RESET <= 1'b1; // Assert reset signal\n                state <= DELAY; // Transition to the DELAY state\n                counter <= 0;\n            end\n            DELAY: begin\n                if (counter < t) begin\n                    counter <= counter + 1;\n                end else begin\n                    RESET <= 1'b0; // De-assert reset signal after delay\n                    state <= NORMAL; // Transition to the NORMAL state\n                end\n            end\n            NORMAL: begin\n                RESET <= 1'b0;\n            end\n            DEFAULT: begin\n                state <= IDLE; // Transition back to the IDLE state for recovery\n            end\n            default: begin\n                state <= DEFAULT; // Handle any undefined states\n            end\n        endcase\n    end\nend\n\nendmodule\n",
        "module_name": "POR",
        "module_hash": "22e01e4d05de8261540daca10ec0bda1",
        "dataset_index": 7267
      },
      "multiplier_de7da78c": {
        "rtl_code": "module multiplier (\n    input wire clk,\n    input wire [10:0] Q, // Multiplier\n    input wire [10:0] Q_reg, // Multiplicand, loaded once and kept constant\n    output reg [23:0] P // Product\n);\n\n    reg [10:0] multiplier;\n    reg [21:0] multiplicand;\n    reg [5:0] counter; // Counter to track the multiplication steps\n\n    always @(posedge clk) begin\n        if (counter == 0) begin // Initialization\n            multiplier <= Q;\n            multiplicand <= Q_reg;\n            P <= 0;\n            counter <= 11; // Set the counter for 11 cycles of multiplication\n        end else begin\n            if (multiplier[0]) // If the LSB of the multiplier is 1, add the multiplicand to the product\n                P <= P + {multiplicand, 10'b0}; // Shift multiplicand to align with the current bit of multiplier\n            \n            // Shift the multiplicand and multiplier for the next bit\n            multiplicand <= multiplicand << 1;\n            multiplier <= multiplier >> 1;\n            counter <= counter - 1;\n        end\n    end\nendmodule\n",
        "module_name": "multiplier",
        "module_hash": "de7da78cc7d6762f9ec38f25e21b6b78",
        "dataset_index": 993
      },
      "iq_comp_ed5d0822": {
        "rtl_code": "module iq_comp(\n    input clk,\n    input RESETn,\n    input freeze_iqcomp,\n    input [1:0] op_mode,\n    input signed [3:0] Ix,\n    input signed [3:0] Qx,\n    input signed [12:0] Wr_in,\n    input signed [12:0] Wj_in,\n    output signed [3:0] Iy,\n    output signed [3:0] Qy,\n    output wire settled,\n    output signed [12:0] Wr,\n    output signed [12:0] Wj\n);\n\n    reg signed [3:0] Iy_reg;\n    reg signed [3:0] Qy_reg;\n    reg signed [12:0] Wr_reg;\n    reg signed [12:0] Wj_reg;\n    reg settled_reg;\n\n    always @(posedge clk) begin\n        if (RESETn == 0) begin\n            Iy_reg <= 4'd0;\n            Qy_reg <= 4'd0;\n            Wr_reg <= 13'd0;\n            Wj_reg <= 13'd0;\n            settled_reg <= 0;\n        end else if (freeze_iqcomp == 0) begin\n            Iy_reg <= Ix - Wr_in * Qx;\n            Qy_reg <= Qx + Wj_in * Ix;\n            Wr_reg <= Wr_in;\n            Wj_reg <= Wj_in;\n            settled_reg <= 1;\n        end else begin\n            settled_reg <= 0;\n        end\n    end\n\n    assign Iy = Iy_reg;\n    assign Qy = Qy_reg;\n    assign Wr = Wr_reg;\n    assign Wj = Wj_reg;\n    assign settled = settled_reg;\n\nendmodule",
        "module_name": "iq_comp",
        "module_hash": "ed5d08225ed6caa97ecbf90e1167082b",
        "dataset_index": 160
      },
      "addition_28481372": {
        "rtl_code": "module addition(\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum,\n    output overflow\n);\n\nwire [8:0] temp_sum;\nwire carry;\n\nassign temp_sum = {1'b0, a} + {1'b0, b}; // Add a and b, include a carry bit\nassign sum = temp_sum[7:0]; // Output the sum\nassign carry = temp_sum[8]; // Check if there was an overflow\n\nassign overflow = (a[7] == b[7] && sum[7] != a[7]) || (a[7] != b[7] && sum[7] == carry);\n\nendmodule",
        "module_name": "addition",
        "module_hash": "28481372af8b1b347148331f6ba460ed",
        "dataset_index": 3058
      },
      "multiplier_8bit_88c93a6e": {
        "rtl_code": "module multiplier_8bit (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [15:0] c\n);\n\n    always @(*) begin\n        if (ctrl == 1) begin // signed multiplication\n            c = $signed(a) * $signed(b);\n        end else begin // unsigned multiplication\n            c = a * b;\n        end\n    end\n\nendmodule",
        "module_name": "multiplier_8bit",
        "module_hash": "88c93a6e780ddd5ca04acf7c2c75fb58",
        "dataset_index": 4525
      },
      "channel_bridge_453409cd": {
        "rtl_code": "\nmodule channel_bridge (\n    input clk,\n    input reset_n,\n    input in_valid,\n    input [7:0] in_data,\n    input [7:0] in_channel,\n    input in_startofpacket,\n    input in_endofpacket,\n    output reg out_valid,\n    output reg [7:0] out_data,\n    output reg [7:0] out_channel,\n    output reg out_startofpacket,\n    output reg out_endofpacket\n);\n\n    reg [7:0] stored_data;\n    reg [7:0] stored_channel;\n    reg stored_startofpacket;\n    reg stored_endofpacket;\n\n    always @(posedge clk) begin\n        if (!reset_n) begin\n            out_valid <= 1'b0;\n            out_data <= 8'd0;\n            out_channel <= 8'd0;\n            out_startofpacket <= 1'b0;\n            out_endofpacket <= 1'b0;\n        end else begin\n            if (in_valid) begin\n                stored_data <= in_data;\n                stored_channel <= in_channel;\n                stored_startofpacket <= in_startofpacket;\n                stored_endofpacket <= in_endofpacket;\n            end\n\n            if (out_valid) begin\n                out_data <= stored_data;\n                out_channel <= stored_channel;\n                out_startofpacket <= stored_startofpacket;\n                out_endofpacket <= stored_endofpacket;\n\n                if (in_channel > 8'd0) begin\n                    out_valid <= 1'b0;\n                    //$display(\"Simulation Message: Channel %d is suppressed\", in_channel);\n                end\n            end else begin\n                out_valid <= 1'b1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "channel_bridge",
        "module_hash": "453409cd189640001b9a475edf4634be",
        "dataset_index": 4425
      },
      "not_gate_7ff769ae": {
        "rtl_code": "\nmodule not_gate (\n    input in,\n    output out_not\n);\n    assign out_not = in ^ 1;\nendmodule\nmodule edge_detector (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out_edge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        out_edge <= (in & ~prev_in);\n        prev_in <= in;\n    end\nendmodule\nmodule functional_module (\n    input [7:0] in_edge,\n    input in_not,\n    output [7:0] out_func\n);\n    assign out_func = in_edge & {8{in_not}};\nendmodule\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] out_edge,\n    output out_not,\n    output [7:0] out_func\n);\n    wire [7:0] edge_out;\n    wire not_out;\n\n    not_gate not_inst (\n        .in(in[0]),\n        .out_not(not_out)\n    );\n\n    edge_detector edge_inst (\n        .clk(clk),\n        .in(in),\n        .out_edge(edge_out)\n    );\n\n    functional_module func_inst (\n        .in_edge(edge_out),\n        .in_not(not_out),\n        .out_func(out_func)\n    );\n\n    assign out_edge = edge_out;\n    assign out_not = not_out;\nendmodule",
        "module_name": "not_gate",
        "module_hash": "7ff769ae2e024a836c4e20e0c7b79dc0",
        "dataset_index": 11289
      },
      "binary_counter_d2c34573": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n    );\n\n    always @(posedge clk)\n    begin\n        if (reset)\n            count <= 4'b0;\n        else if (enable)\n            count <= count + 1;\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "d2c3457330360b264c1c15d2d2e39176",
        "dataset_index": 18173
      },
      "error2_32c2c093": {
        "rtl_code": "module error2 (\n  input clk,\n  output reg [1:0] leds\n);\n\nreg [19:0] counter = 0;\n\nalways @(posedge clk) begin\n  counter <= counter + 1;\n  if (counter == 1000000) begin\n    counter <= 0;\n    leds <= ~leds;\n  end\nend\n\nendmodule",
        "module_name": "error2",
        "module_hash": "32c2c09323c70e0e8ae8732350de126a",
        "dataset_index": 6140
      },
      "LogicCell_bba7ee13": {
        "rtl_code": "module LogicCell(carryout, lcout, carryin, clk, clkb, in0, in1, in2, in3, sr);\n  input carryin;\n  output carryout;\n  input clk;\n  input clkb;\n  input in0;\n  input in1;\n  input in2;\n  input in3;\n  output lcout;\n  input sr;\n\n  reg [3:0] inputs;\n  reg lcout_reg;\n  reg carryout_reg;\n\n  always @(posedge clk, negedge clkb) begin\n    if (!clkb) begin\n      // Asynchronous reset\n      lcout_reg <= 1'b0;\n      carryout_reg <= 1'b0;\n    end else if (sr) begin\n      // Synchronous reset\n      lcout_reg <= 1'b0;\n      carryout_reg <= 1'b0;\n    end else begin\n      // Compute outputs\n      inputs <= {in3, in2, in1, in0};\n      lcout_reg <= |inputs;\n      carryout_reg <= &inputs;\n    end\n  end\n\n  assign carryout = carryin & carryout_reg;\n  assign lcout = lcout_reg;\n\nendmodule",
        "module_name": "LogicCell",
        "module_hash": "bba7ee13af90719e5ec7704ae783a861",
        "dataset_index": 7599
      },
      "alu_ba38fbe9": {
        "rtl_code": "\n\nmodule alu(\n\tinput\t[63:0]\tinA_i,\n\tinput\t[63:0]\tinB_i,\n\tinput\t\tcflag_i,\n\tinput\t\tsum_en_i,\n\tinput\t\tand_en_i,\n\tinput\t\txor_en_i,\n\tinput\t\tinvB_en_i,\n\tinput\t\tlsh_en_i,\n\tinput\t\trsh_en_i,\n\tinput\t\tltu_en_i,\tinput\t\tlts_en_i,\toutput\t[63:0]\tout_o,\n\toutput\t\tcflag_o,\n\toutput\t\tvflag_o,\n\toutput\t\tzflag_o\n);\n\twire [63:0] b = inB_i ^ ({64{invB_en_i}});\n\n\twire [63:0] sumL = inA_i[62:0] + b[62:0] + {62'b0, cflag_i};\n\twire c62 = sumL[63];\n\twire [64:63] sumH = inA_i[63] + b[63] + c62;\n\twire [63:0] rawSums = {sumH[63], sumL[62:0]};\n\n\twire [63:0] sums = sum_en_i ? rawSums : 64'd0;\n\tassign zflag_o = ~(|out_o);\n\tassign vflag_o = sumH[64] ^ sumL[63];\n\tassign cflag_o = sumH[64];\n\n\twire [63:0] ands = and_en_i ? (inA_i & b) : 64'd0;\n\twire [63:0] xors = xor_en_i ? (inA_i ^ b) : 64'd0;\n\n\twire [63:0] lsh32 = inB_i[5] ? {inA_i[31:0], 32'd0} : inA_i;\n\twire [63:0] lsh16 = inB_i[4] ? {lsh32[47:0], 16'd0} : lsh32;\n\twire [63:0] lsh8  = inB_i[3] ? {lsh16[55:0], 8'd0} : lsh16;\n\twire [63:0] lsh4  = inB_i[2] ? {lsh8[59:0], 4'd0} : lsh8;\n\twire [63:0] lsh2  = inB_i[1] ? {lsh4[61:0], 2'd0} : lsh4;\n\twire [63:0] lsh1  = inB_i[0] ? {lsh2[62:0], 1'd0} : lsh2;\n\twire [63:0] lshs = lsh_en_i ? lsh1 : 0;\n\n\twire [63:32] sx5 = cflag_i ? {32{inA_i[63]}} : 0;\n\twire [63:0] rsh32 = inB_i[5] ? {sx5, inA_i[63:32]} : inA_i;\n\twire [63:48] sx4 = cflag_i ? {16{rsh32[63]}} : 0;\n\twire [63:0] rsh16 = inB_i[4] ? {sx4, rsh32[63:16]} : rsh32;\n\twire [63:56] sx3 = cflag_i ? {8{rsh16[63]}} : 0;\n\twire [63:0] rsh8  = inB_i[3] ? {sx3, rsh16[63:8]} : rsh16;\n\twire [63:60] sx2 = cflag_i ? {4{rsh8[63]}} : 0;\n\twire [63:0] rsh4  = inB_i[2] ? {sx2, rsh8[63:4]} : rsh8;\n\twire [63:62] sx1 = cflag_i ? {2{rsh4[63]}} : 0;\n\twire [63:0] rsh2  = inB_i[1] ? {sx1, rsh4[63:2]} : rsh4;\n\twire sx0 = cflag_i & rsh2[63];\n\n\twire [63:0] rsh1  = inB_i[0] ? {sx0, rsh2[63:1]} : rsh2;\n\twire [63:0] rshs = rsh_en_i ? rsh1 : 0;\n\n\twire [63:0] isLTS = lts_en_i ? {63'd0, rawSums[63] ^ vflag_o} : 0;\n\twire [63:0] isLTU = ltu_en_i ? {63'd0, ~cflag_o} : 0;\n\n\tassign out_o = sums | ands | xors | lshs | rshs | isLTS | isLTU;\nendmodule\n",
        "module_name": "alu",
        "module_hash": "ba38fbe95f5f8c33e13d99166afe912f",
        "dataset_index": 22279
      },
      "sky130_fd_sc_hvl__o22a_a71376e2": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__o22a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1          );\n    or  or1  (or1_out   , B2, B1          );\n    and and0 (and0_out_X, or0_out, or1_out);\n    buf buf0 (X         , and0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__o22a",
        "module_hash": "a71376e2ca44bb6087ff933ffdc5c913",
        "dataset_index": 15808
      },
      "dual_edge_triggered_ff_2df66db5": {
        "rtl_code": "module dual_edge_triggered_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= q1;\nend\n\nassign q = q2;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\ndual_edge_triggered_ff ff(\n    .clk(clk),\n    .d(d),\n    .q(q)\n);\n\nendmodule",
        "module_name": "dual_edge_triggered_ff",
        "module_hash": "2df66db50587f0ff6e378aba5e557141",
        "dataset_index": 13399
      },
      "fifo_dfb8abc6": {
        "rtl_code": "module fifo(datain, rd, wr, rst, clk, full, empty,led_n,wei);\n\ninput [3:0] datain;\ninput rd, wr, rst, clk;\n\noutput [6:0] led_n;\noutput full, empty, wei;\n\nreg [3:0] dataout;\nreg full_in, empty_in,wei_in,div;\nreg [3:0] mem [15:0];\nreg [23:0]cnt;\nreg [3:0] rp, wp;\nreg [6:0] led_n;\n\nassign full = full_in;\nassign empty = empty_in;\nassign wei=wei_in;\n\nparameter \n    reg0=7'b0000001,\n    reg1=7'b1001111,\n    reg2=7'b0010010,\n    reg3=7'b0000110,\n    reg4=7'b1001100,\n    reg5=7'b0100100,\n    reg6=7'b0100000,\n    reg7=7'b0001101,\n    reg8=7'b0000000,\n    reg9=7'b0000100,\n    rega=7'b0001000,\n    regb=7'b1100000,\n    regc=7'b0110001,\n    regd=7'b1000010,\n    rege=7'b0110000,\n    regf=7'b0111000;\n\nalways@(posedge clk) \nbegin\n    if(cnt==24'b111111111111111111111111)\n\t    begin\n\t    div=~div;\n\t    cnt<=0;\n\t    end\n    else\n\t    begin\n\t    cnt<=cnt+1;\n\t    end\nend\n\nalways@(posedge clk) \nbegin\n    wei_in<=1'b0;\nend\n\nalways@(posedge div) \nbegin\n    if(~wr && ~full_in) \n\t    mem[wp]<=datain;\nend\n\nalways@(posedge div) \nbegin\n    if(!rst) \n\t    wp<=0;\n    else \n    begin\n        if(~wr && ~full_in)    \n        wp<= wp+1'b1;\n    end\nend\n\nalways@(posedge div)\nbegin\n    if(!rst) \n        rp <= 0;\n    else \n    begin\n        if(~rd && ~empty_in) \n        rp <= rp + 1'b1;\n    end\nend\n\nalways@(posedge div) \nbegin\n    if(!rst) \n        full_in <= 1'b0;\n    else \n    begin\n        if(rd && ~wr)\n            begin\n            if((wp==rp-1)||(rp==4'h0&&wp==4'hf))\n\t\t        full_in <= 1'b1;\n\t\t    end\n        else if(full_in && ~rd) \n\t\t    full_in <= 1'b0;\n    end\nend\n\nalways@(posedge div ) \nbegin\n    if(!rst) \n        empty_in <= 1'b1;\n\telse \n\t    begin\n        if(~rd&&wr)\n\t\t    begin  \n                if(rp==wp-1 || (rp==4'hf&&wp==4'h0))\n                    empty_in<=1'b1;\n            end\n        else if(empty_in && ~wr) \n            empty_in<=1'b0;\n        end\nend\n\nalways@(posedge div) \nbegin\n    if(~rd && ~empty_in) \n\t\tdataout<=mem[rp];\n\t\t case(dataout) \n            4'h0: led_n<=reg0;\n            4'h1: led_n<=reg1;\n            4'h2: led_n<=reg2;\n            4'h3: led_n<=reg3;\n            4'h4: led_n<=reg4;\n            4'h5: led_n<=reg5;\n            4'h6: led_n<=reg6;\n            4'h7: led_n<=reg7;\n            4'h8: led_n<=reg8;\n            4'h9: led_n<=reg9;\n            4'ha: led_n<=rega;\n            4'hb: led_n<=regb;\n            4'hc: led_n<=regc;\n            4'hd: led_n<=regd;\n            4'he: led_n<=rege;\n            4'hf: led_n<=regf;\n        default:;\n        endcase\t\t\t\t\t\t\t\t\nend\nendmodule\n\n\n\n\n",
        "module_name": "fifo",
        "module_hash": "dfb8abc6ba2e2ba4da7fd606b527519f",
        "dataset_index": 1922
      },
      "my_clock_gate_310f8693": {
        "rtl_code": "module my_clock_gate (\n    input CLK,\n    input EN,\n    input TE,\n    output ENCLK\n);\n\n    wire n2;\n    reg EN_reg;\n    \n    always @ (posedge CLK, posedge TE) begin\n        if (TE) begin\n            EN_reg <= 1'b0;\n        end else begin\n            EN_reg <= EN;\n        end\n    end\n    \n    assign n2 = EN_reg & CLK;\n    assign ENCLK = n2;\n    \nendmodule",
        "module_name": "my_clock_gate",
        "module_hash": "310f8693e04beafc25e77390ecf2a213",
        "dataset_index": 4965
      },
      "axi_ad9152_if_70b192c4": {
        "rtl_code": "\n\nmodule axi_ad9152_if (\n\n  tx_clk,\n  tx_data,\n\n  dac_clk,\n  dac_rst,\n  dac_data_0_0,\n  dac_data_0_1,\n  dac_data_0_2,\n  dac_data_0_3,\n  dac_data_1_0,\n  dac_data_1_1,\n  dac_data_1_2,\n  dac_data_1_3);\n\n  input           tx_clk;\n  output [127:0]  tx_data;\n\n  output          dac_clk;\n  input           dac_rst;\n  input   [15:0]  dac_data_0_0;\n  input   [15:0]  dac_data_0_1;\n  input   [15:0]  dac_data_0_2;\n  input   [15:0]  dac_data_0_3;\n  input   [15:0]  dac_data_1_0;\n  input   [15:0]  dac_data_1_1;\n  input   [15:0]  dac_data_1_2;\n  input   [15:0]  dac_data_1_3;\n\n  reg    [127:0]  tx_data = 'd0;\n\n  assign dac_clk = tx_clk;\n\n  always @(posedge dac_clk) begin\n    if (dac_rst == 1'b1) begin\n      tx_data <= 128'd0;\n    end else begin\n      tx_data[127:120] <= dac_data_1_3[ 7: 0];\n      tx_data[119:112] <= dac_data_1_2[ 7: 0];\n      tx_data[111:104] <= dac_data_1_1[ 7: 0];\n      tx_data[103: 96] <= dac_data_1_0[ 7: 0];\n      tx_data[ 95: 88] <= dac_data_1_3[15: 8];\n      tx_data[ 87: 80] <= dac_data_1_2[15: 8];\n      tx_data[ 79: 72] <= dac_data_1_1[15: 8];\n      tx_data[ 71: 64] <= dac_data_1_0[15: 8];\n      tx_data[ 63: 56] <= dac_data_0_3[ 7: 0];\n      tx_data[ 55: 48] <= dac_data_0_2[ 7: 0];\n      tx_data[ 47: 40] <= dac_data_0_1[ 7: 0];\n      tx_data[ 39: 32] <= dac_data_0_0[ 7: 0];\n      tx_data[ 31: 24] <= dac_data_0_3[15: 8];\n      tx_data[ 23: 16] <= dac_data_0_2[15: 8];\n      tx_data[ 15:  8] <= dac_data_0_1[15: 8];\n      tx_data[  7:  0] <= dac_data_0_0[15: 8];\n    end\n  end\n\nendmodule\n\n",
        "module_name": "axi_ad9152_if",
        "module_hash": "70b192c438e9c3c9a4cb40542d0916d3",
        "dataset_index": 15845
      },
      "Incrementer_5603e19b": {
        "rtl_code": "module Incrementer (\n    input [3:0] in,\n    output [3:0] out\n);\n\n//`#start` -- edit after this line, do not edit this line\n\n    assign out = in + 4'b0001;\n\n//`#end` -- edit above this line, do not edit this line\nendmodule",
        "module_name": "Incrementer",
        "module_hash": "5603e19bf80334030bf5c895efe36734",
        "dataset_index": 10609
      },
      "combinational_circuit_2ed83a03": {
        "rtl_code": "module combinational_circuit(\n    input [49:0] in,\n    input sel,\n    output out_and,\n    output out_or,\n    output out_xnor\n);\n\n    wire [49:0] in_sel;\n    wire [49:0] in_inv;\n\n    // 2-to-1 multiplexer\n    assign in_sel = sel ? in : 50'b0;\n    assign in_inv = sel ? ~in : 50'b0;\n\n    // AND gate\n    assign out_and = &in_sel;\n\n    // OR gate\n    assign out_or = |in_sel;\n\n    // XNOR gate\n    assign out_xnor = ~(in_sel ^ in_inv);\n\nendmodule",
        "module_name": "combinational_circuit",
        "module_hash": "2ed83a036b502eb7b181b78a12ac226f",
        "dataset_index": 389
      },
      "synchronous_reset_bdc8f4e1": {
        "rtl_code": "module synchronous_reset (\n    input wire clk,\n    input wire out,\n    input wire in0,\n    output reg AS\n);\n\n    always @(posedge clk or negedge in0) begin\n        if (!in0) begin\n            AS <= 0;\n        end else begin\n            AS <= out;\n        end\n    end\n\nendmodule",
        "module_name": "synchronous_reset",
        "module_hash": "bdc8f4e1de2376a7f17e57907f5ec02c",
        "dataset_index": 1962
      },
      "counter_mod_rtl_28190247": {
        "rtl_code": "module counter_mod_rtl(\n  input clk, rst, up_down,\n  output reg [3:0] q,\n  output reg carry\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      q <= 4'b0;\n      carry <= 1'b0;\n    end else if (up_down == 1'b0) begin\n      // Up counter\n      if (q == 4'b1111) begin\n        q <= 4'b0;\n        carry <= 1'b1;\n      end else begin\n        q <= q + 4'b1;\n        carry <= 1'b0;\n      end\n    end else begin\n      // Down counter\n      if (q == 4'b0000) begin\n        q <= 4'b1111;\n        carry <= 1'b1;\n      end else begin\n        q <= q - 4'b1;\n        carry <= 1'b0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "counter_mod_rtl",
        "module_hash": "28190247326f1a983eeb4320fb5e873d",
        "dataset_index": 14890
      },
      "clock_bootstrap_rom_eb51a9e2": {
        "rtl_code": "module clock_bootstrap_rom(input [15:0] addr, output [47:0] data);\n\n   reg [47:0] rom [0:15];\n   \n   assign     data = rom[addr];\n\n   initial \n     begin\n\trom[0] = 48'h0000_0C00_0F03;  rom[1] = 48'h1014_0000_0000;  rom[2] = 48'h1018_0000_0001;  rom[3] = 48'h1010_0000_3418;  rom[4] = 48'h1000_0000_0010;  rom[5] = 48'h1010_0000_3518;  rom[6] = 48'hffff_ffff_ffff;  rom[7] = 48'hffff_ffff_ffff;  rom[8] = 48'hffff_ffff_ffff;  rom[9] = 48'hffff_ffff_ffff;  rom[10] = 48'hffff_ffff_ffff;  rom[11] = 48'hffff_ffff_ffff;  rom[12] = 48'hffff_ffff_ffff;  rom[13] = 48'hffff_ffff_ffff;  rom[14] = 48'hffff_ffff_ffff;  rom[15] = 48'hffff_ffff_ffff;  end endmodule ",
        "module_name": "clock_bootstrap_rom",
        "module_hash": "eb51a9e20b78e8f1b05332684d0807fe",
        "dataset_index": 24155
      },
      "scrambler #_622e553f": {
        "rtl_code": "module scrambler # (\n\tparameter WIDTH = 512\n)(\n\tinput clk, arst, ena,\n\tinput [WIDTH-1:0] din,\t\t// bit 0 is to be sent first\n\toutput reg [WIDTH-1:0] dout\n);\n\nlocalparam SCRAM_INIT = 58'h3ff_ffff_ffff_ffff;\n\nreg [57:0] scram_state = SCRAM_INIT;\n\nwire [WIDTH+58-1:0] history;\nassign history [57:0] = scram_state;\n\ngenvar i;\ngenerate\n\tfor (i=58; i<WIDTH+58; i=i+1) begin : lp\n\t\tassign history[i] = history[i-58] ^ history[i-39] ^ din[i-58];\t\t\n\tend\nendgenerate\n\t\nalways @(posedge clk or posedge arst) begin\n\tif (arst) begin\n\t\tdout <= 0;\n\t\tscram_state <= SCRAM_INIT;\n\tend\n\telse if (ena) begin\n\t\tdout <= history[WIDTH+58-1:58];\n\t\tscram_state <= history[WIDTH+58-1:WIDTH];\n\tend\nend\n\nendmodule",
        "module_name": "scrambler #",
        "module_hash": "622e553f74b1a48cf7c048de22cc9f4d",
        "dataset_index": 10557
      },
      "bit_counter_8591def0": {
        "rtl_code": "module bit_counter(\n    input [3:0] in,\n    output reg count\n);\n\n    reg [2:0] i;\n    reg [3:0] current_bit;\n    reg [2:0] ones_count;\n\n    always @* begin\n        ones_count = 0;\n        for (i = 0; i < 4; i = i + 1) begin\n            current_bit = in[i];\n            if (current_bit == 1) begin\n                ones_count = ones_count + 1;\n            end\n        end\n        count = ones_count;\n    end\n\nendmodule",
        "module_name": "bit_counter",
        "module_hash": "8591def0bd92325347df86534279d0e7",
        "dataset_index": 9516
      },
      "mux_2x4_3d13489a": {
        "rtl_code": "module mux_2x4 (\n    input [1:0] in,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (in)\n        2'b00: out = 4'b0001;\n        2'b01: out = 4'b0010;\n        2'b10: out = 4'b0100;\n        2'b11: out = 4'b1000;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule",
        "module_name": "mux_2x4",
        "module_hash": "3d13489a3906aaf860f06b6aaf04802d",
        "dataset_index": 4084
      },
      "pixel_reader_71f69b56": {
        "rtl_code": "\n\nmodule pixel_reader (\n  input                     clk,\n  input                     rst,\n\n  input                     i_read_rdy,\n  output  reg               o_read_act,\n  input           [23:0]    i_read_size,\n  input           [24:0]    i_read_data,\n  output  reg               o_read_stb,\n\n  output  reg     [7:0]     o_red,\n  output  reg     [7:0]     o_green,\n  output  reg     [7:0]     o_blue,\n\n  output  reg               o_pixel_rdy,\n  input                     i_pixel_stb,\n\n  input                     i_tp_red,\n  input                     i_tp_blue,\n  input                     i_tp_green,\n\n  output  reg               o_last\n);\nreg               [7:0]     r_next_red;\nreg               [7:0]     r_next_green;\nreg               [7:0]     r_next_blue;\nreg               [31:0]    r_read_count;\nreg                         r_tp_green;\nreg                         r_tp_blue;\nalways @ (posedge clk) begin\n  o_read_stb                <=  0;\n  o_pixel_rdy               <=  0;\n  if (rst) begin\n    o_read_act              <=  0;\n\n    o_red                   <=  0;\n    o_green                 <=  0;\n    o_blue                  <=  0;\n\n    r_next_red              <=  0;\n    r_next_green            <=  0;\n    r_next_blue             <=  0;\n\n    o_last                  <=  0;\n  end\n  else begin\n\n    if (i_read_rdy && !o_read_act) begin\n      r_read_count              <=  0;\n      o_read_act                <=  1;\n    end\n\n    if (o_pixel_rdy) begin\n      if (i_pixel_stb) begin\n        o_pixel_rdy             <=  0;\n        o_red                   <=  i_read_data[23:16];\n        o_green                 <=  i_read_data[15:8];\n        o_blue                  <=  i_read_data[7:0];\n        o_last                  <=  i_read_data[24];\n      end\n    end\n\n    if (o_read_act) begin\n      o_pixel_rdy               <=  1;\n      if (r_read_count < i_read_size) begin\n        if (i_pixel_stb) begin\n          r_read_count          <=  r_read_count + 1;\n          o_read_stb            <=  1;\n        end\n      end\n      else begin\n        o_read_act              <=  0;\n      end\n    end\n  end\nend\n\n\n\nendmodule\n",
        "module_name": "pixel_reader",
        "module_hash": "71f69b562d7a46ac21c4d7a002a3cab6",
        "dataset_index": 22173
      },
      "up_counter_c7b1089b": {
        "rtl_code": "module up_counter(\n    input clk,\n    input reset,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or negedge reset) begin\n    if(!reset) begin\n        out <= 4'b0000;\n    end\n    else begin\n        out <= out + 1;\n    end\nend\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "c7b1089b2cd73f8864a3316547450232",
        "dataset_index": 17587
      },
      "counter_a578cd64": {
        "rtl_code": "module counter (\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "a578cd64284ac34263e39cb6978a40cb",
        "dataset_index": 11884
      },
      "bitwise_add_sub_553992c6": {
        "rtl_code": "module bitwise_add_sub (\n    input clk,\n    input reset,\n    input [7:0] in_a,\n    input [7:0] in_b,\n    input select,\n    output reg [7:0] out\n);\n\nreg [7:0] a_shifted;\nreg [7:0] b_shifted;\nreg [7:0] result;\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        a_shifted <= 8'b0;\n        b_shifted <= 8'b0;\n        result <= 8'b0;\n    end else begin\n        a_shifted <= {in_a[7], in_a[6], in_a[5], in_a[4], in_a[3], in_a[2], in_a[1], in_a[0]};\n        b_shifted <= {in_b[7], in_b[6], in_b[5], in_b[4], in_b[3], in_b[2], in_b[1], in_b[0]};\n        if (select == 1) begin\n            result <= a_shifted + b_shifted;\n        end else begin\n            result <= a_shifted - b_shifted;\n        end\n    end\nend\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        out <= 8'b0;\n    end else begin\n        out <= {result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7]};\n    end\nend\n\nendmodule",
        "module_name": "bitwise_add_sub",
        "module_hash": "553992c617263d9165a4e62e29c6e66e",
        "dataset_index": 11859
      },
      "soc_system_pio_led_7696d161": {
        "rtl_code": "module soc_system_pio_led (\n  // inputs:\n  address,\n  chipselect,\n  clk,\n  reset_n,\n  write_n,\n  writedata,\n\n  // outputs:\n  out_port,\n  readdata\n);\n\n  output [7:0] out_port;\n  output [31:0] readdata;\n  input [1:0] address;\n  input chipselect;\n  input clk;\n  input reset_n;\n  input write_n;\n  input [31:0] writedata;\n\n  wire clk_en;\n  reg [7:0] data_out;\n  wire [7:0] out_port;\n  wire [7:0] read_mux_out;\n  wire [31:0] readdata;\n\n  assign clk_en = 1;\n\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {8 {(address == 0)}} & data_out;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      data_out <= 8'b11111111;\n    end else if (chipselect && ~write_n && (address == 0)) begin\n      data_out <= writedata[7:0];\n    end\n  end\n\n  assign readdata = {32'b0 | read_mux_out};\n  assign out_port = data_out;\n\nendmodule",
        "module_name": "soc_system_pio_led",
        "module_hash": "7696d16190571d16a7b8a0400eb44260",
        "dataset_index": 5159
      },
      "sky130_fd_sc_lp__o2111ai_e71debc7": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o2111ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1             );\n    nand nand0 (nand0_out_Y, C1, B1, D1, or0_out);\n    buf  buf0  (Y          , nand0_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o2111ai",
        "module_hash": "e71debc78efb6d753f1d089185ec5a14",
        "dataset_index": 13747
      },
      "nor_using_nand_pipeline_6884370f": {
        "rtl_code": "\nmodule nor_using_nand_pipeline(\n    input a,\n    input b,\n    output out,\n    input clk\n);\n\nreg a_reg, b_reg;\nwire nand1_out, nand2_out, nand3_out;\n\n// Pipeline stage 1\nassign nand1_out = ~(a & b);\nalways @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\nend\n\n// Pipeline stage 2\nassign nand2_out = ~(a_reg & nand1_out);\n\n// Pipeline stage 3\nassign nand3_out = ~(b_reg & nand2_out);\n\n// Output stage\nassign out = nand3_out;\n\nendmodule",
        "module_name": "nor_using_nand_pipeline",
        "module_hash": "6884370f830f186780951c6dd6bc40f4",
        "dataset_index": 15677
      },
      "dma_request_generator_954d784a": {
        "rtl_code": "\nmodule dma_request_generator (\n    input req_aclk,\n    input req_aresetn,\n\n    output [C_ID_WIDTH-1:0] request_id,\n    input [C_ID_WIDTH-1:0] response_id,\n\n    input req_valid,\n    output reg req_ready,\n    input [C_BURSTS_PER_TRANSFER_WIDTH-1:0] req_burst_count,\n\n    input enable,\n    input pause,\n\n    output eot\n);\n\nparameter C_ID_WIDTH = 3;\nparameter C_BURSTS_PER_TRANSFER_WIDTH = 17;\n\nreg [C_BURSTS_PER_TRANSFER_WIDTH-1:0] burst_count = 'h00;\nreg [C_ID_WIDTH-1:0] id;\nwire [C_ID_WIDTH-1:0] id_next = id + 1'b1;\n\nassign eot = burst_count == 'h00;\nassign request_id = id;\n\nalways @(posedge req_aclk)\nbegin\n    if (req_aresetn == 1'b0) begin\n        burst_count <= 'h00;\n        id <= 'h0;\n        req_ready <= 1'b1;\n    end else if (enable == 1'b0) begin\n        req_ready <= 1'b1;\n    end else begin\n        if (req_ready) begin\n            if (req_valid && enable) begin\n                burst_count <= req_burst_count;\n                req_ready <= 1'b0;\n            end\n        end else if (response_id != id_next && ~pause) begin\n            if (eot)\n                req_ready <= 1'b1;\n            burst_count <= burst_count - 1'b1;\n            id <= id_next;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "dma_request_generator",
        "module_hash": "954d784a081dfa60c8a0798adc6e83eb",
        "dataset_index": 17020
      },
      "and_gate_a0db7d69": {
        "rtl_code": "module and_gate (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    assign Y = A & B & C;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "a0db7d6924e7f0cfd98e004230c6ea7a",
        "dataset_index": 9950
      },
      "soc_system_led_pio_0493f184": {
        "rtl_code": "module soc_system_led_pio (\n                            // inputs:\n                             address,\n                             chipselect,\n                             clk,\n                             reset_n,\n                             write_n,\n                             writedata,\n\n                            // outputs:\n                             out_port,\n                             readdata\n                          )\n;\n\n  output  [  3: 0] out_port;\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            chipselect;\n  input            clk;\n  input            reset_n;\n  input            write_n;\n  input   [ 31: 0] writedata;\n\n  wire             clk_en;\n  reg     [  3: 0] data_out;\n  wire    [  3: 0] out_port;\n  wire    [  3: 0] read_mux_out;\n  wire    [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {4 {(address == 0)}} & data_out;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          data_out <= 15;\n      else if (chipselect && ~write_n && (address == 0))\n          data_out <= writedata[3 : 0];\n    end\n\n\n  assign readdata = {32'b0 | read_mux_out};\n  assign out_port = data_out;\n\nendmodule",
        "module_name": "soc_system_led_pio",
        "module_hash": "0493f1841026457efb0eb13f8fed2ccb",
        "dataset_index": 18986
      },
      "delay_one_cycle_0e3eb5c1": {
        "rtl_code": "module delay_one_cycle(\n    input data,\n    input clk,\n    output to_pad\n);\n\nreg delayed_data;\n\nalways @(posedge clk) begin\n    delayed_data <= data;\nend\n\nassign to_pad = delayed_data;\n\nendmodule",
        "module_name": "delay_one_cycle",
        "module_hash": "0e3eb5c133d06f00d36cac420c173577",
        "dataset_index": 822
      },
      "alu_d4738ce7": {
        "rtl_code": "`ifndef _alu\n`define _alu\n\nmodule alu(\n\t\tinput\t\t[3:0]\tctl,\n\t\tinput\t\t[31:0]\ta, b,\n\t\toutput reg\t[31:0]\tout,\n\t\toutput\t\t\t\tzero);\n\n\twire [31:0] sub_ab;\n\twire [31:0] add_ab;\n\twire \t\toflow_add;\n\twire \t\toflow_sub;\n\twire \t\toflow;\n\twire \t\tslt;\n\n\tassign zero = (0 == out);\n\n\tassign sub_ab = a - b;\n\tassign add_ab = a + b;\n\n\tassign oflow_add = (a[31] == b[31] && add_ab[31] != a[31]) ? 1 : 0;\n\tassign oflow_sub = (a[31] == b[31] && sub_ab[31] != a[31]) ? 1 : 0;\n\n\tassign oflow = (ctl == 4'b0010) ? oflow_add : oflow_sub;\n\n\tassign slt = oflow_sub ? ~(a[31]) : a[31];\n\n\talways @(*) begin\n\t\tcase (ctl)\n\t\t\t4'b0010: out <= add_ab;\t\t\t\t4'b0000: out <= a & b;\t\t\t\t4'b1100: out <= ~(a | b);\t\t\t4'b0001: out <= a | b;\t\t\t\t4'b0111: out <= {{31{1'b0}}, slt};\t4'b0110: out <= sub_ab;\t\t\t\t4'b1101: out <= a ^ b;\t\t\t\tdefault: out <= 0;\n\t\tendcase\n\tend\n\nendmodule\n\n`endif\n",
        "module_name": "alu",
        "module_hash": "d4738ce7d90b6d3be42a84bb7dafc3c0",
        "dataset_index": 9855
      },
      "spi_engine_offload_fdbdc52d": {
        "rtl_code": "\nmodule spi_engine_offload (\n\tinput ctrl_clk,\n\n\tinput ctrl_cmd_wr_en,\n\tinput [15:0] ctrl_cmd_wr_data,\n\n\tinput ctrl_sdo_wr_en,\n\tinput [7:0] ctrl_sdo_wr_data,\n\n\tinput ctrl_enable,\n\toutput ctrl_enabled,\n\tinput ctrl_mem_reset,\n\n\tinput spi_clk,\n\tinput spi_resetn,\n\n\tinput trigger,\n\n\toutput cmd_valid,\n\tinput cmd_ready,\n\toutput [15:0] cmd,\n\n\toutput sdo_data_valid,\n\tinput sdo_data_ready,\n\toutput [7:0] sdo_data,\n\n\tinput sdi_data_valid,\n\toutput sdi_data_ready,\n\tinput [7:0] sdi_data,\n\n\tinput sync_valid,\n\toutput sync_ready,\n\tinput [7:0] sync_data,\n\n\toutput offload_sdi_valid,\n\tinput offload_sdi_ready,\n\toutput [7:0] offload_sdi_data\n);\n\nparameter SPI_CLK_ASYNC = 0;\nparameter CMD_MEM_ADDR_WIDTH = 4;\nparameter SDO_MEM_ADDR_WIDTH = 4;\n\nreg spi_active = 1'b0;\n\nreg [CMD_MEM_ADDR_WIDTH-1:0] ctrl_cmd_wr_addr = 'h00;\nreg [CMD_MEM_ADDR_WIDTH-1:0] spi_cmd_rd_addr = 'h00;\nreg [SDO_MEM_ADDR_WIDTH-1:0] ctrl_sdo_wr_addr = 'h00;\nreg [SDO_MEM_ADDR_WIDTH-1:0] spi_sdo_rd_addr = 'h00;\n\nreg [15:0] cmd_mem[0:2**CMD_MEM_ADDR_WIDTH-1];\nreg [7:0] sdo_mem[0:2**SDO_MEM_ADDR_WIDTH-1];\n\nwire [CMD_MEM_ADDR_WIDTH-1:0] spi_cmd_rd_addr_next;\nwire spi_enable;\n\nassign cmd_valid = spi_active;\nassign sdo_data_valid = spi_active;\nassign sync_ready = 1'b1;\n\nassign offload_sdi_valid = sdi_data_valid;\nassign sdi_data_ready = offload_sdi_ready;\nassign offload_sdi_data = sdi_data;\n\nassign cmd = cmd_mem[spi_cmd_rd_addr];\nassign sdo_data = sdo_mem[spi_sdo_rd_addr];\n\ngenerate if (SPI_CLK_ASYNC) begin\n\n\n\nreg ctrl_do_enable = 1'b0;\nwire ctrl_is_enabled;\nreg spi_enabled = 1'b0;\n\nalways @(posedge ctrl_clk) begin\n\tif (ctrl_enable == 1'b1) begin\n\t\tctrl_do_enable <= 1'b1;\n\tend else if (ctrl_is_enabled == 1'b1) begin\n\t\tctrl_do_enable <= 1'b0;\n\tend\nend\n\nassign ctrl_enabled = ctrl_is_enabled | ctrl_do_enable;\n\nalways @(posedge spi_clk) begin\n\tspi_enabled <= spi_enable | spi_active;\t\nend\n\nsync_bits # (\n    .NUM_BITS(1),\n    .CLK_ASYNC(1)\n) i_sync_enable (\n    .in(ctrl_do_enable),\n    .out_clk(spi_clk),\n    .out_resetn(1'b1),\n    .out(spi_enable)\n);\n\nsync_bits # (\n    .NUM_BITS(1),\n    .CLK_ASYNC(1)\n) i_sync_enabled (\n    .in(spi_enabled),\n    .out_clk(ctrl_clk),\n    .out_resetn(1'b1),\n    .out(ctrl_is_enabled)\n);\n\nend else begin\nassign spi_enable = ctrl_enable;\nassign ctrl_enabled = spi_enable | spi_active;\nend endgenerate\n\nassign spi_cmd_rd_addr_next = spi_cmd_rd_addr + 1;\n\nalways @(posedge spi_clk) begin\n\tif (spi_resetn == 1'b0) begin\n\t\tspi_active <= 1'b0;\n\tend else begin\n\t\tif (spi_active == 1'b0) begin\n\t\t\tif (trigger == 1'b1 && spi_enable == 1'b1)\n\t\t\t\tspi_active <= 1'b1;\n\t\tend else if (cmd_ready == 1'b1 && spi_cmd_rd_addr_next == ctrl_cmd_wr_addr) begin\n\t\t\tspi_active <= 1'b0;\n\t\tend\n\tend\nend\n\nalways @(posedge spi_clk) begin\n\tif (cmd_valid == 1'b0) begin\n\t\tspi_cmd_rd_addr <= 'h00;\n\tend else if (cmd_ready == 1'b1) begin\n\t\tspi_cmd_rd_addr <= spi_cmd_rd_addr_next;\n\tend\nend\n\nalways @(posedge spi_clk) begin\n\tif (spi_active == 1'b0) begin\n\t\tspi_sdo_rd_addr <= 'h00;\n\tend else if (sdo_data_ready == 1'b1) begin\n\t\tspi_sdo_rd_addr <= spi_sdo_rd_addr + 1'b1;\n\tend\nend\n\nalways @(posedge ctrl_clk) begin\n\tif (ctrl_mem_reset == 1'b1)\n\t\tctrl_cmd_wr_addr <= 'h00;\n\telse if (ctrl_cmd_wr_en == 1'b1)\n\t\tctrl_cmd_wr_addr <= ctrl_cmd_wr_addr + 1'b1;\nend\n\nalways @(posedge ctrl_clk) begin\n\tif (ctrl_cmd_wr_en == 1'b1)\n\t\tcmd_mem[ctrl_cmd_wr_addr] <= ctrl_cmd_wr_data;\nend\n\nalways @(posedge ctrl_clk) begin\n\tif (ctrl_mem_reset == 1'b1)\n\t\tctrl_sdo_wr_addr <= 'h00;\n\telse if (ctrl_sdo_wr_en == 1'b1)\n\t\tctrl_sdo_wr_addr <= ctrl_sdo_wr_addr + 1'b1;\nend\n\nalways @(posedge ctrl_clk) begin\n\tif (ctrl_sdo_wr_en == 1'b1)\n\t\tsdo_mem[ctrl_sdo_wr_addr] <= ctrl_sdo_wr_data;\nend\n\nendmodule\n",
        "module_name": "spi_engine_offload",
        "module_hash": "fdbdc52dac865b49f5e574eb1fbc167a",
        "dataset_index": 23517
      },
      "carry_save_adder_55f4ec12": {
        "rtl_code": "module carry_save_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input clk,\n    output reg [3:0] s,\n    output reg [3:0] c_out\n);\n\nreg [3:0] p1, g1, p2, g2, p3, g3;\n\nalways @(*) begin\n    p1 = a ^ b;\n    g1 = a & b;\n    p2 = p1 ^ c;\n    g2 = p1 & c;\n    p3 = p2 ^ g1;\n    g3 = p2 & g1;\nend\n\nalways @(posedge clk) begin\n    s <= p3;\n    c_out <= g3;\nend\n\nendmodule",
        "module_name": "carry_save_adder",
        "module_hash": "55f4ec12007ba0c8d07641ac0871411d",
        "dataset_index": 5765
      },
      "data_power__e33a103c": {
        "rtl_code": "module data_power_module (\n    input  A   ,\n    output X   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    reg [7:0] data_reg;\n    wire power_wire;\n    wire data_power_wire;\n\n    always @(posedge VPB) begin\n        data_reg <= A;\n    end\n\n    assign power_wire = VPWR;\n\n    assign data_power_wire = data_reg & power_wire;\n\n    assign X = data_power_wire;\n\nendmodule",
        "module_name": "data_power_",
        "module_hash": "e33a103c5ea5ba44cd28e6c220202506",
        "dataset_index": 6134
      },
      "nibble_match_count_01949a17": {
        "rtl_code": "\nmodule nibble_match_count(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [2:0] count,\n    input clk\n);\n\n// Register variables for storing nibbles\nreg [3:0] shift_reg_a;\nreg [3:0] shift_reg_b;\n\n// Always block to update shift registers and count matching nibbles\nalways @( posedge clk ) begin\n    shift_reg_a <= {shift_reg_a[2:0], a[3:0]};\n    shift_reg_b <= {shift_reg_b[2:0], b[3:0]};\n\n    if (shift_reg_a[3:0] == shift_reg_b[3:0]) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "nibble_match_count",
        "module_hash": "01949a17efd620d87dcaefc616af3737",
        "dataset_index": 21297
      },
      "serializer #_582e2e99": {
        "rtl_code": "\n\nmodule serializer #(\n\tparameter DWIDTH=64\n)\n(\n\tinput wire clk,\n\tinput wire fast_clk,\n\tinput wire res_n,\n\tinput wire [DWIDTH-1:0] data_in,\n\toutput wire data_out\n);\n\nreg [7:0] curr_bit = 'h0;\n\nalways @ (posedge fast_clk)\nbegin\n\tif(!res_n) begin\n\t\tcurr_bit <= 0;\n\tend else begin\n\t\tif(curr_bit == DWIDTH-1)\n\t\t\tcurr_bit <= 0;\n\t\telse\n\t\t\tcurr_bit <= curr_bit + 1;\n\tend\nend\n\nassign data_out = data_in[curr_bit];\n\nendmodule\n\n",
        "module_name": "serializer #",
        "module_hash": "582e2e99331156e4af391b1efd74fa36",
        "dataset_index": 22355
      },
      "top__11899202": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d1,   // Input for multiplexer\n    input [7:0] d2,   // Input for multiplexer\n    input sel,        // Select input for multiplexer\n    output [7:0] q    // Output from functional module\n);\n\n    // Counter module\n    reg [3:0] count;\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\n    \n    // Multiplexer module\n    wire [7:0] mux_out;\n    mux_2to1 mux_inst (\n        .a(d1),\n        .b(d2),\n        .sel(sel),\n        .out(mux_out)\n    );\n    \n    // Functional module\n    wire [7:0] sum;\n    assign sum = count + mux_out;\n    \n    // Output\n    assign q = sum;\n\nendmodule\n\n// 2-to-1 multiplexer module\nmodule mux_2to1 (\n    input [7:0] a,\n    input [7:0] b,\n    input sel,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sel) begin\n            out = b;\n        end else begin\n            out = a;\n        end\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "1189920293fcd505b15d5a653f2dcfc3",
        "dataset_index": 19094
      },
      "spi_amba_connector_e8540774": {
        "rtl_code": "\n\nmodule spi_amba_connector(\n    input             clk,\n    input             rst,\n\n    input             hwrite,\n    input      [31:0] hwdata,\n    input      [31:0] haddr,\n    input             hsel,\n    output     [31:0] hrdata,\n\n    input      [ 7:0] spi_data_out,\n    input             spi_busy,\n    output reg [ 7:0] spi_data_in,\n    output reg        spi_ready_send\n);\n\nreg [7:0] spi_data_out_reg;\nreg [7:0] spi_data_in_reg;\n\nassign hrdata = {{25'b0, phase || spi_busy || spi_ready_send, spi_busy ? spi_data_out_reg : spi_data_out}};\n\nlocalparam IDLE = 0, DATA = 1;\n\nreg phase;\n\n\nalways @(posedge clk) begin\n    if (rst) begin\n        spi_data_in <= 0;\n        spi_ready_send <= 0;\n        phase <= 0;\n    end else if (spi_ready_send && spi_busy) begin\n        spi_ready_send <= 0;\n    end else if (!spi_ready_send && !spi_busy) begin\n          if (!phase) begin\n              if (hsel && haddr[15:0] == 'h0000 && hwrite) phase <= 1;\n          end else begin\n              spi_data_out_reg <= spi_data_in;\n              spi_data_in <= spi_data_in_reg;\n              spi_ready_send <= 1;\n              phase <= 0;\n          end\n    end\nend\n\nalways @(negedge clk) begin\n    if (phase) spi_data_in_reg <= hwdata[7:0];\nend\n\nendmodule\n",
        "module_name": "spi_amba_connector",
        "module_hash": "e8540774cb5de636198da1c29e796770",
        "dataset_index": 10685
      },
      "register_02188486": {
        "rtl_code": "module register (\n  input clk,\n  input reset,\n  input load,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\n  reg [3:0] reg_data;\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      reg_data <= 4'b0000;\n    end\n    else if (load == 1) begin\n      reg_data <= data_in;\n    end\n  end\n\n  assign data_out = reg_data;\n\nendmodule",
        "module_name": "register",
        "module_hash": "02188486e27763f2f61e3dfb271be700",
        "dataset_index": 10390
      },
      "dff_en_3d2427c5": {
        "rtl_code": "\nmodule dff_en(clk, d, en, q, q_bar);\n  input clk, d, en;\n  output q, q_bar;\n\n  wire q_next;\n  assign q_next = en ? d : q;\n\n  dff dff_inst(.clk(clk), .d(q_next), .q(q), .q_bar(q_bar));\nendmodule\nmodule dff(clk, d, q, q_bar);\n  input clk, d;\n  output q, q_bar;\n\n  reg q;\n  assign q_bar = ~q;\n\n  always @(posedge clk) begin\n    q <= d;\n  end\nendmodule",
        "module_name": "dff_en",
        "module_hash": "3d2427c57abef1c02eec3164b22566e8",
        "dataset_index": 1053
      },
      "sync_r2w_cc40b5b2": {
        "rtl_code": "\n\n\nmodule sync_r2w\n\n    #(\n    parameter ASIZE = 4\n    )(\n    input  wire              wclk,\n    input  wire              wrst_n,\n    input  wire [ASIZE:0] rptr,\n    output reg  [ASIZE:0] wq2_rptr\n    );\n\n    reg [ASIZE:0] wq1_rptr;\n\n    always @(posedge wclk or negedge wrst_n) begin\n\n        if (!wrst_n)\n            {wq2_rptr,wq1_rptr} <= 0;\n        else\n            {wq2_rptr,wq1_rptr} <= {wq1_rptr,rptr};\n\n    end\n\nendmodule\n\n`resetall\n",
        "module_name": "sync_r2w",
        "module_hash": "cc40b5b2388c12b32dd495c96229378f",
        "dataset_index": 22054
      },
      "NormaliseAdder_44f243c8": {
        "rtl_code": "\nmodule NormaliseAdder(\n\tinput idle_AddState,\n\tinput [31:0] sout_AddState,\n\tinput [27:0] sum_AddState,\n\tinput clock,\n\toutput reg idle_NormaliseSum,\n\toutput reg [31:0] sout_NormaliseSum,\n\toutput reg [27:0] sum_NormaliseSum\n    );\n\nparameter no_idle = 1'b0,\n\t\t\t put_idle = 1'b1;\n\nwire [7:0] s_exponent;\n\nassign s_exponent = sout_AddState[30:23];\n\nalways @ (posedge clock)\nbegin\n\t\n\tidle_NormaliseSum <= idle_AddState;\n\t\n\tif (idle_AddState != put_idle) begin\n\t\t\t\n\t\t\tsout_NormaliseSum[31] <= sout_AddState[31];\n\t\t\tsout_NormaliseSum[22:0] <= sout_AddState[22:0];\n\t\t\t\n\t\t\tif (sum_AddState[27] == 1'b1) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent + 1;\n\t\t\t\tsum_NormaliseSum <= sum_AddState >> 1;\n\t\t\tend\n\n\t\t\telse if(sum_AddState[26:3] == 24'h000000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= 10'h382;\n\t\t\tend\n\t\t\t\n\t\t\telse if (sum_AddState[26:4] == 23'h000000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 23;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 23;\n\t\t\tend\n\t\t\t\n\t\t\telse if (sum_AddState[26:5] == 22'h000000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 22;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 22;\t\t\t\n\t\t\tend\n\t\t\t\n\t\t\telse if (sum_AddState[26:6] == 21'h000000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 21;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 21;\t\t\t\n\t\t\tend\n\t\t\t\n\t\t\telse if (sum_AddState[26:7] == 20'h00000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 20;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 20;\t\t\t\n\t\t\tend\n\t\t\t\n\t\t\telse if (sum_AddState[26:8] == 19'h00000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 19;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 19;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:9] == 18'h00000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 18;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 18;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:10] == 17'h00000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 17;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 17;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:11] == 16'h0000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 16;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 16;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:12] == 15'h0000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 15;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 15;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:13] == 14'h0000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 14;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 14;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:14] == 13'h0000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 13;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 13;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:15] == 12'h000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 12;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 12;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:16] == 11'h000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 11;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 11;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:17] == 10'h000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 10;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 10;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:18] == 9'h0000) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 9;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 9;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:19] == 8'h00) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 8;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 8;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:20] == 7'h00) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 7;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 7;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:21] == 6'h00) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 6;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 6;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:22] == 5'h00) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 5;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 5;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:23] == 4'h0) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 4;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 4;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:24] == 3'h0) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 3;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 3;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26:25] == 2'h0) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 2;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 2;\t\t\t\n\t\t\tend\n\n\t\t\telse if (sum_AddState[26] == 1'h0) begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent - 1;\n\t\t\t\tsum_NormaliseSum <= sum_AddState << 1;\t\t\t\n\t\t\tend\n\t\t\t\t\n\t\t\telse begin\n\t\t\t\tsout_NormaliseSum[30:23] <= s_exponent;\n\t\t\t\tsum_NormaliseSum <= sum_AddState;\n\t\t\tend\n\tend\n\t\n\telse begin\n\t\tsout_NormaliseSum <= sout_AddState;\n\t\tsum_NormaliseSum <= 0;\n\tend\nend\n\nendmodule\n",
        "module_name": "NormaliseAdder",
        "module_hash": "44f243c8b4cca567bd0d77321c6db3a5",
        "dataset_index": 23047
      },
      "control_1f1bc029": {
        "rtl_code": "module control(\n\trstn,\n\tclk,\n\tenable,\n\tcyclecnt,\n\tblockcnt,\n\tnewblock,\n\tgxgyrun,\n\tcounterrun1,\n\tcounterrun2,\n\tfinish\n);\n\n\tinput\t\t\t\trstn;\n\tinput\t\t\t\tclk;\n\t\n\tinput\t\t\t\tenable;\n\toutput\t[5:0]\t\tcyclecnt;\n\toutput\t[6:0]\t\tblockcnt;\n\toutput\t\t\t\tgxgyrun;\n\toutput\t\t\t\tcounterrun1;\n\toutput\t\t\t\tcounterrun2;\n\toutput\t\t\t\tfinish;\n\toutput\t\t\t\tnewblock;\n\t\n\treg\t\t\t\t\tgxgyrun;\n\treg\t\t\t\t\tcounterrun1;\n\treg\t\t\t\t\tcounterrun2;\n\treg\t\t\t\t\tfinish;\n\treg\t\t\t\t\tnewblock;\n\t\n\treg\t\t[5:0]\t\tcyclecnt;\n\treg\t\t[6:0]\t\tblockcnt;\n\t\n\treg\t\t[2:0]\t\ttid_o;\t\t\n\t\n\talways@(posedge clk or negedge rstn)\n\t\tif(!rstn)\n\t\t\tnewblock\t<=\t1'b0;\n\t\telse\tif(cyclecnt\t==\t'd40)\n\t\t\tnewblock\t<=\t1'b1;\n\t\telse\n\t\t\tnewblock\t<=\t1'b0;\n\t\n\talways@(posedge clk or negedge rstn)\n\t\tif(!rstn)\n\t\t\tcyclecnt <= 'd0;\n\t\telse if((cyclecnt == 'd40) || finish)\n\t\t\tcyclecnt <= 'd0;\n\t\telse if(enable)\n\t\t\tcyclecnt <= cyclecnt + 1'b1;\n\t\t\t\n\talways@(posedge clk or negedge rstn)\n\t\tif(!rstn)\n\t\t\tblockcnt <= 'd0;\n\t\telse if(enable && (cyclecnt == 'd40))\n\t\t\tblockcnt <= blockcnt + 1'b1;\n\t\telse if(finish)\n\t\t\tblockcnt <= 'd0;\n\t\t\t\n\talways@(posedge clk or negedge rstn)\n\t\tif(!rstn)\n\t\t\tgxgyrun <= 'd0;\n\t\telse if((cyclecnt == 'd5)  && (blockcnt != 'd64))\n\t\t\tgxgyrun <= 1'b1;\n\t\telse if(cyclecnt == 'd1) \n\t\t\tgxgyrun <= 1'b0;\n\t\t\t\n\talways@(posedge clk or negedge rstn)\n\t\tif(!rstn)\n\t\t\tcounterrun1 <= 'd0;\n\t\telse\n\t\t\tcounterrun1 <= gxgyrun;\n\t\t\t\n\talways@(posedge clk or negedge rstn)\n\t\tif(!rstn)\n\t\t\tcounterrun2 <= 'd0;\n\t\telse\n\t\t\tcounterrun2 <= counterrun1;\n\t\t\t\n\talways@(posedge clk or negedge rstn)\n\t\tif(!rstn)\n\t\t\tfinish <= 1'b0;\n\t\telse if((blockcnt == 'd65) && (cyclecnt == 'd10))\n\t\t\tfinish <= 1'b1;\n\t\telse if(enable)\n\t\t\tfinish <= 1'b0;\n\t\nendmodule\n\t",
        "module_name": "control",
        "module_hash": "1f1bc0294b9415584d0f85d5d0797efc",
        "dataset_index": 20187
      },
      "byte_swap_pipeline_28fbc7b3": {
        "rtl_code": "module byte_swap_pipeline(\n    input [31:0] in,\n    input reset,\n    input clk,\n    output reg [31:0] out\n);\n\nreg [31:0] shift_reg [0:2];\nreg [1:0] stage;\n\nalways @(*) begin\n    case(stage)\n        0: shift_reg[0] = in;\n        1: shift_reg[1] = {shift_reg[0][23:0], shift_reg[0][31:24]};\n        2: shift_reg[2] = {shift_reg[1][7:0], shift_reg[1][15:8], shift_reg[1][23:16], shift_reg[1][31:24]};\n    endcase\nend\n\nalways @(posedge clk) begin\n    if(reset) begin\n        stage <= 0;\n    end else begin\n        if(stage == 2) begin\n            out <= shift_reg[2];\n            stage <= 0;\n        end else begin\n            stage <= stage + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "byte_swap_pipeline",
        "module_hash": "28fbc7b355124e4eb70b7d3809bee167",
        "dataset_index": 8453
      },
      "counter_rollover_b5152fdd": {
        "rtl_code": "module counter_rollover\n#(parameter       W = 256, // width of counter\n  parameter       N = 4)   // how many parts contain counter?\n (input  wire         CLK,\n  input  wire         ENABLE,\n  input  wire         LOAD,\n  input  wire [W-1:0] DI,\n  output wire [W-1:0] DO\n  );\n\nreg [(W/N)-1:0] cnt [N-1:0];\n\nwire [N-1:0] tc; // TerminalCount\nwire [N-1:0] ro; // RollOver\n\n\ngenvar k;\ngenerate\n  for (k=0;k<N;k=k+1) begin: gen_counter\n\n    assign tc[k] = (k==0) ? 1'b1 : (tc[k-1] && (& cnt[k-1]));\n    assign ro[k] = tc[k] & ENABLE;\n\n    always @(posedge CLK) begin\n      if (LOAD)\n        cnt[k] <= DI[W/N*(k+1)-1:W/N*k];\n      else if (ro[k])\n        cnt[k] <= cnt[k] + 1;\n    end\n\n    assign DO[W/N*(k+1)-1:W/N*k] = cnt[k];\n\n  end\nendgenerate\n\nendmodule",
        "module_name": "counter_rollover",
        "module_hash": "b5152fddb7764b2b3ab9f987ec53a7a7",
        "dataset_index": 11180
      },
      "sequential_multiplier_e235bbf5": {
        "rtl_code": "\nmodule sequential_multiplier (\n    input clk,\n    input [7:0] A,\n    input [7:0] B,\n    output [15:0] P\n);\n    reg [15:0] temp_P;\n\n    always @(posedge clk) begin\n        temp_P <= A * B;\n    end\n    assign P = temp_P;\nendmodule\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg eq,\n    output reg gt_a,\n    output reg gt_b\n);\n\n    always @(*) begin\n        eq = (a == b);\n        gt_a = (a > b);\n        gt_b = (b > a);\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] A,\n    input [7:0] B,\n    input [3:0] a,\n    input [3:0] b,\n    output [15:0] P,\n    output out\n);\n    wire eq, gt_a, gt_b;\n\n    sequential_multiplier multiplier(\n        .clk(clk),\n        .A(A),\n        .B(B),\n        .P(P)\n    );\n\n    comparator comp(\n        .a(a),\n        .b(b),\n        .eq(eq),\n        .gt_a(gt_a),\n        .gt_b(gt_b)\n    );\n\n    assign out = eq | gt_a;\n\nendmodule",
        "module_name": "sequential_multiplier",
        "module_hash": "e235bbf593ff588a0fad00d31c8f2b6c",
        "dataset_index": 2803
      },
      "top__d1f8ee3d": {
        "rtl_code": "\nmodule top_module (\n    input wire [15:0] in,\n    input wire [2:0] sel,\n    input wire [3:0] data0,\n    input wire [3:0] data1,\n    input wire [3:0] data2,\n    input wire [3:0] data3,\n    input wire [3:0] data4,\n    input wire [3:0] data5,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n\n    wire [3:0] mux_out;\n    wire [7:0] split_out_hi;\n    wire [7:0] split_out_lo;\n    wire [7:0] and_out;\n\n    assign mux_out = (sel == 0) ? data0 :\n                     (sel == 1) ? data1 :\n                     (sel == 2) ? data2 :\n                     (sel == 3) ? data3 :\n                     (sel == 4) ? data4 : data5;\n    assign split_out_hi = in[15:8];\n    assign split_out_lo = in[7:0];\n    assign and_out = split_out_hi & split_out_lo;\n\n    assign out_lo = and_out;\n    assign out_hi = mux_out;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "d1f8ee3d743c52e3374174b40f05b0e8",
        "dataset_index": 12823
      },
      "EHR_5_6a12f8de": {
        "rtl_code": "module EHR_5 (\n    CLK,\n    RST_N,\n    read_0,\n    write_0,\n    EN_write_0,\n    read_1,\n    write_1,\n    EN_write_1,\n    read_2,\n    write_2,\n    EN_write_2,\n    read_3,\n    write_3,\n    EN_write_3,\n    read_4,\n    write_4,\n    EN_write_4\n);\n    parameter            DATA_SZ = 1;\n    parameter            RESET_VAL = 0;\n\n    input                CLK;\n    input                RST_N;\n    output [DATA_SZ-1:0] read_0;\n    input  [DATA_SZ-1:0] write_0;\n    input                EN_write_0;\n    output [DATA_SZ-1:0] read_1;\n    input  [DATA_SZ-1:0] write_1;\n    input                EN_write_1;\n    output [DATA_SZ-1:0] read_2;\n    input  [DATA_SZ-1:0] write_2;\n    input                EN_write_2;\n    output [DATA_SZ-1:0] read_3;\n    input  [DATA_SZ-1:0] write_3;\n    input                EN_write_3;\n    output [DATA_SZ-1:0] read_4;\n    input  [DATA_SZ-1:0] write_4;\n    input                EN_write_4;\n\n    reg    [DATA_SZ-1:0] r;\n    wire   [DATA_SZ-1:0] wire_0;\n    wire   [DATA_SZ-1:0] wire_1;\n    wire   [DATA_SZ-1:0] wire_2;\n    wire   [DATA_SZ-1:0] wire_3;\n    wire   [DATA_SZ-1:0] wire_4;\n    wire   [DATA_SZ-1:0] wire_5;\n\n    assign wire_0 = r;\n    assign wire_1 = EN_write_0 ? write_0 : wire_0;\n    assign wire_2 = EN_write_1 ? write_1 : wire_1;\n    assign wire_3 = EN_write_2 ? write_2 : wire_2;\n    assign wire_4 = EN_write_3 ? write_3 : wire_3;\n    assign wire_5 = EN_write_4 ? write_4 : wire_4;\n\n    assign read_0 = wire_0;\n    assign read_1 = wire_1;\n    assign read_2 = wire_2;\n    assign read_3 = wire_3;\n    assign read_4 = wire_4;\n\n    always @(posedge CLK) begin\n        if (RST_N == 0) begin\n            r <= RESET_VAL;\n        end else begin\n            r <= wire_5;\n        end\n    end\nendmodule\n",
        "module_name": "EHR_5",
        "module_hash": "6a12f8deac3d68e6a12fccaeacfa9a6b",
        "dataset_index": 11331
      },
      "two_input_logic_cf944f18": {
        "rtl_code": "module two_input_logic (\n    A,\n    B,\n    X\n);\n\n    // Module ports\n    input  A;\n    input  B;\n    output X;\n\n    // Local signals\n    wire not_A;\n    wire not_B;\n    wire and1_out;\n    wire and2_out;\n    wire or_out;\n\n    //  Name        Output      Other arguments\n    not not_A_gate (not_A, A);\n    not not_B_gate (not_B, B);\n    and and1_gate   (and1_out, A, not_B);\n    and and2_gate   (and2_out, not_A, B);\n    or  or_gate     (or_out, and1_out, and2_out);\n    not not_out     (X, or_out);\n\nendmodule",
        "module_name": "two_input_logic",
        "module_hash": "cf944f18f978d0252358c597ebdad945",
        "dataset_index": 10110
      },
      "softusb_hostif #_dcbed0bd": {
        "rtl_code": "module softusb_hostif #(\n    parameter csr_addr = 4'h0,\n    parameter pmem_width = 12\n) (\n    input sys_clk,\n    input sys_rst,\n\n    input usb_clk,\n    output reg usb_rst,\n\n    input [13:0] csr_a,\n    input csr_we,\n    input [31:0] csr_di,\n    output reg [31:0] csr_do,\n\n    output irq,\n\n    input io_we,\n    input [5:0] io_a,\n\n    input [pmem_width-1:0] dbg_pc\n);\n\nreg usb_rst0;\n\nalways @(posedge sys_clk) begin\n    if(sys_rst) begin\n        usb_rst0 <= 1'b1;\n        csr_do <= 1'b0;\n    end else begin\n        csr_do <= 1'b0;\n        if(csr_a[13:10] == csr_addr) begin\n            if(csr_we)\n                usb_rst0 <= csr_di[0];\n            csr_do <= { dbg_pc, 1'b0 };\n        end\n    end\nend\n\n\nreg usb_rst1;\n\nalways @(posedge usb_clk) begin\n    usb_rst1 <= usb_rst0;\n    usb_rst <= usb_rst1;\nend\n\n\n\nreg irq_flip;\nalways @(posedge usb_clk) begin\n    if(usb_rst)\n        irq_flip <= 1'b0;\n    else if(io_we && (io_a == 6'h15))\n        irq_flip <= ~irq_flip;\nend\n\nreg irq_flip0;\nreg irq_flip1;\nreg irq_flip2;\n\nalways @(posedge sys_clk) begin\n    irq_flip0 <= irq_flip;\n    irq_flip1 <= irq_flip0;\n    irq_flip2 <= irq_flip1;\nend\n\nassign irq = irq_flip1 != irq_flip2;\n\nendmodule",
        "module_name": "softusb_hostif #",
        "module_hash": "dcbed0bd732b168751a4d4d29851803d",
        "dataset_index": 10205
      },
      "logic_circuit_b3b0b307": {
        "rtl_code": "module logic_circuit (\n    output Y   ,\n    input  A1_N,\n    input  A2_N,\n    input  B1  ,\n    input  B2  \n);\n\n    assign Y = (!A1_N & !A2_N & !B1 & !B2) | (!A1_N & !A2_N & !B1 & B2) | (!A1_N & !A2_N & B1 & !B2) | (!A1_N & !A2_N & B1 & B2) | (!A1_N & A2_N & !B1 & B2) | (!A1_N & A2_N & B1 & !B2) | (!A1_N & A2_N & B1 & B2) | (A1_N & !A2_N & B1 & !B2) | (A1_N & !A2_N & B1 & B2) | (A1_N & A2_N & !B1 & !B2) | (A1_N & A2_N & !B1 & B2) | (A1_N & A2_N & B1 & !B2) | (A1_N & A2_N & B1 & B2);\n\nendmodule",
        "module_name": "logic_circuit",
        "module_hash": "b3b0b3074e14314fcb4321c1818e857a",
        "dataset_index": 9390
      },
      "communication__8520161a": {
        "rtl_code": "module communication_module (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input VPWR,\n    input VGND,\n    output reg X\n);\n\n    wire o31a_out;\n    //sky130_fd_sc_hs__o31a base (\n    //    .X(o31a_out),\n    //    .A1(A1),\n    //    .A2(A2),\n    //    .A3(A3),\n    //    .B1(B1),\n    //    .VPWR(VPWR),\n    //    .VGND(VGND)\n    //);\n\n    always @* begin\n        X = (A1 & A2 & A3 & ~B1) ? 1'b1 : 1'b0;\n    end\n\nendmodule",
        "module_name": "communication_",
        "module_hash": "8520161a132958c69bf6fb6eb56dab90",
        "dataset_index": 9380
      },
      "adder_8da32ed0": {
        "rtl_code": "module adder (\n  input [3:0] A,\n  input [3:0] B,\n  input C,\n  output reg [3:0] S\n);\n\n  always @(*) begin\n    if (C == 0) begin\n      S = A + B;\n    end else begin\n      S = A - B;\n    end\n  end\n\nendmodule\n\n",
        "module_name": "adder",
        "module_hash": "8da32ed035b7699736732d925f6f49af",
        "dataset_index": 3942
      },
      "Multiplexer_AC__parameterized133_bdae89b9": {
        "rtl_code": "\nmodule Multiplexer_AC__parameterized133 (\n  input ctrl,\n  input [0:0] D0,\n  input [0:0] D1,\n  output [0:0] S\n);\n\n  wire [0:0] wD0;\n  wire [0:0] wD1;\n  wire [0:0] wS;\n  wire wCtrl;\n\n  // LUT3 with initial value of 8'hB8\n  assign wS = ctrl ? D0 : D1;\n  assign S = wS;\n\nendmodule",
        "module_name": "Multiplexer_AC__parameterized133",
        "module_hash": "bdae89b9d683f8122e45a1f272f1e6a4",
        "dataset_index": 5638
      },
      "memory_13ba15ee": {
        "rtl_code": "\nmodule memory(clk, cen, we, addr, write_data, read_data,\n             ram_clk, ram_we_b, ram_address, ram_data, ram_cen_b);\n\n   input clk;            // system clock\n   input cen;            // clock enable for gating ZBT cycles\n   input we;             // write enable (active HIGH)\n   input [18:0] addr;    // memory address\n   input [35:0] write_data;   // data to write\n   output [35:0] read_data;   // data read from memory\n   output ram_clk;       // physical line to ram clock\n   output ram_we_b;      // physical line to ram we_b\n   output [18:0] ram_address; // physical line to ram address\n   output [35:0] ram_data; // physical line to ram data\n   output ram_cen_b;     // physical line to ram clock enable\n\n   reg [35:0] ram_data;\n\n   assign ram_cen_b = ~cen;\n   assign ram_clk = 1'b0;\n   assign ram_we_b = ~we;\n   assign ram_address = addr;\n   assign read_data = ram_data;\n\n   always @(posedge clk) begin\n     if (cen == 1'b1) begin\n       if (we == 1'b1) begin\n         ram_data <= write_data;\n       end\n     end\n   end\n\nendmodule",
        "module_name": "memory",
        "module_hash": "13ba15ee8dc374e0c98ac5e8e5b45645",
        "dataset_index": 13689
      },
      "umult8_b04e499a": {
        "rtl_code": "module umult8(reg_A, reg_B, result);\n\tinput [0:7] reg_A, reg_B;\n\t\n\toutput [0:15] result;\n\t\n\treg [0:15] p8a_0;\n\treg [0:15] p8b_0;\n\treg [0:15] pt;\n\treg [0:15] result;\n\t\n\tinteger i;\n\n\talways @ (reg_A or reg_B)\n\t\tbegin\n\t\tp8a_0=16'b0;\n\t\tp8b_0=16'b0;\n\t\tpt=16'b0;\n\t\t\n\t\t\n\t\tp8b_0={{8{1'b0}},reg_B[0:7]};\n\t\t\n\t\tp8a_0={{8{1'b0}},reg_A[0:7]};\n\n\t\t\n\t\tfor (i=15; i>7; i=i-1)\n\t\t\tbegin\n\t\t\tpt=pt+(p8a_0[i]?(p8b_0<<(8'd15-i)):16'b0);\n\t\t\tend\n\t\tresult<=pt;\n\t\tend\nendmodule\n",
        "module_name": "umult8",
        "module_hash": "b04e499a7f954398c03aad0921d55bfe",
        "dataset_index": 1461
      },
      "EHR_8_7b2fb111": {
        "rtl_code": "module EHR_8 (\n    CLK,\n    RST_N,\n    read_0,\n    write_0,\n    EN_write_0,\n    read_1,\n    write_1,\n    EN_write_1,\n    read_2,\n    write_2,\n    EN_write_2,\n    read_3,\n    write_3,\n    EN_write_3,\n    read_4,\n    write_4,\n    EN_write_4,\n    read_5,\n    write_5,\n    EN_write_5,\n    read_6,\n    write_6,\n    EN_write_6,\n    read_7,\n    write_7,\n    EN_write_7\n);\n    parameter            DATA_SZ = 1;\n    parameter            RESET_VAL = 0;\n\n    input                CLK;\n    input                RST_N;\n    output [DATA_SZ-1:0] read_0;\n    input  [DATA_SZ-1:0] write_0;\n    input                EN_write_0;\n    output [DATA_SZ-1:0] read_1;\n    input  [DATA_SZ-1:0] write_1;\n    input                EN_write_1;\n    output [DATA_SZ-1:0] read_2;\n    input  [DATA_SZ-1:0] write_2;\n    input                EN_write_2;\n    output [DATA_SZ-1:0] read_3;\n    input  [DATA_SZ-1:0] write_3;\n    input                EN_write_3;\n    output [DATA_SZ-1:0] read_4;\n    input  [DATA_SZ-1:0] write_4;\n    input                EN_write_4;\n    output [DATA_SZ-1:0] read_5;\n    input  [DATA_SZ-1:0] write_5;\n    input                EN_write_5;\n    output [DATA_SZ-1:0] read_6;\n    input  [DATA_SZ-1:0] write_6;\n    input                EN_write_6;\n    output [DATA_SZ-1:0] read_7;\n    input  [DATA_SZ-1:0] write_7;\n    input                EN_write_7;\n\n    reg    [DATA_SZ-1:0] r;\n    wire   [DATA_SZ-1:0] wire_0;\n    wire   [DATA_SZ-1:0] wire_1;\n    wire   [DATA_SZ-1:0] wire_2;\n    wire   [DATA_SZ-1:0] wire_3;\n    wire   [DATA_SZ-1:0] wire_4;\n    wire   [DATA_SZ-1:0] wire_5;\n    wire   [DATA_SZ-1:0] wire_6;\n    wire   [DATA_SZ-1:0] wire_7;\n    wire   [DATA_SZ-1:0] wire_8;\n\n    assign wire_0 = r;\n    assign wire_1 = EN_write_0 ? write_0 : wire_0;\n    assign wire_2 = EN_write_1 ? write_1 : wire_1;\n    assign wire_3 = EN_write_2 ? write_2 : wire_2;\n    assign wire_4 = EN_write_3 ? write_3 : wire_3;\n    assign wire_5 = EN_write_4 ? write_4 : wire_4;\n    assign wire_6 = EN_write_5 ? write_5 : wire_5;\n    assign wire_7 = EN_write_6 ? write_6 : wire_6;\n    assign wire_8 = EN_write_7 ? write_7 : wire_7;\n\n    assign read_0 = wire_0;\n    assign read_1 = wire_1;\n    assign read_2 = wire_2;\n    assign read_3 = wire_3;\n    assign read_4 = wire_4;\n    assign read_5 = wire_5;\n    assign read_6 = wire_6;\n    assign read_7 = wire_7;\n\n    always @(posedge CLK) begin\n        if (RST_N == 0) begin\n            r <= RESET_VAL;\n        end else begin\n            r <= wire_8;\n        end\n    end\nendmodule\n",
        "module_name": "EHR_8",
        "module_hash": "7b2fb1111ea41f00704cd20fa841e3c7",
        "dataset_index": 21558
      },
      "sky130_fd_sc_hdll__xnor3_62a97923": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__xnor3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    wire xnor0_out_X;\n\n    xnor xnor0 (xnor0_out_X, A, B, C        );\n    buf  buf0  (X          , xnor0_out_X    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__xnor3",
        "module_hash": "62a979230e75bf7779653ea9f0fe6bdc",
        "dataset_index": 23285
      },
      "counter_5afc1c7c": {
        "rtl_code": "module counter (\n    input CLK,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (Q == 4'b1111) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "5afc1c7ce6d103bb57f825e3bac4d319",
        "dataset_index": 15898
      },
      "early_boot_cee2347e": {
        "rtl_code": "\n\nmodule early_boot(\n\tinput CLK_I,\n\tinput RST_I,\n\t\n\toutput reg CYC_O,\n\toutput reg [31:0] DAT_O,\n\toutput reg STB_O,\n\toutput reg WE_O,\n\toutput reg [31:2] ADR_O,\n\toutput [3:0] SEL_O,\n\t\n\tinput [31:0] DAT_I,\n\tinput ACK_I,\n\tinput ERR_I,\n\tinput RTY_I,\n\t\n\toutput loading_finished_o\n);\nassign SEL_O = 4'b1111;\n\nassign loading_finished_o = (state == S_FINISHED) ? 1'b1 : 1'b0;\n\nreg [3:0] state;\nreg [9:0] wait_counter;\n\nparameter [3:0]\n\tS_CHECK_STATUS \t\t= 4'd0,\n\tS_CHECK_STATUS_2 \t= 4'd1,\n\tS_CHECK_STATUS_3 \t= 4'd2,\n\tS_SET_SIZE \t\t\t= 4'd3,\n\tS_SET_SIZE_2 \t\t= 4'd4,\n\tS_SET_CONTROL \t\t= 4'd5,\n\tS_SET_CONTROL_2 \t= 4'd6,\n\tS_CHECK_FINISHED\t= 4'd7,\n\tS_CHECK_FINISHED_2\t= 4'd8,\n\tS_CHECK_FINISHED_3\t= 4'd9,\n\tS_FINISHED \t\t\t= 4'd10;\n\nalways @(posedge CLK_I) begin\n\tif(RST_I == 1'b1) begin\n\t\tCYC_O <= 1'b0;\n\t\tDAT_O <= 32'd0;\n\t\tSTB_O <= 1'b0;\n\t\tWE_O <= 1'b0;\n\t\tADR_O <= 30'd0;\n\t\tstate <= S_CHECK_STATUS;\n\t\twait_counter <= 10'd0;\n\tend\n\telse if(state == S_CHECK_STATUS) begin\n\t\tCYC_O <= 1'b1;\n\t\tDAT_O <= 32'd0;\n\t\tSTB_O <= 1'b1;\n\t\tWE_O <= 1'b0;\n\t\tADR_O <= 30'h30000000;\n\t\t\n\t\tstate <= S_CHECK_STATUS_2;\n\tend\n\telse if(state == S_CHECK_STATUS_2) begin\n\t\tif(ACK_I == 1'b1) begin\n\t\t\tCYC_O <= 1'b0;\n\t\t\tSTB_O <= 1'b0;\n\t\t\t\n\t\t\tif(DAT_I == 32'd2) begin\n\t\t\t\tstate <= S_SET_SIZE;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate <= S_CHECK_STATUS_3;\n\t\t\tend\n\t\tend\n\tend\n\telse if(state == S_CHECK_STATUS_3) begin\n\t\tif(wait_counter == 10'd1023) begin\n\t\t\twait_counter <= 10'd0;\n\t\t\tstate <= S_CHECK_STATUS;\n\t\tend\n\t\telse wait_counter <= wait_counter + 10'd1;\n\tend\n\telse if(state == S_SET_SIZE) begin\n\t\tCYC_O <= 1'b1;\n\t\tDAT_O <= 32'd2048;\n\t\tSTB_O <= 1'b1;\n\t\tWE_O <= 1'b1;\n\t\tADR_O <= 30'h30000002;\n\t\t\n\t\tstate <= S_SET_SIZE_2;\n\tend\n\telse if(state == S_SET_SIZE_2) begin\n\t\tif(ACK_I == 1'b1) begin\n\t\t\tCYC_O <= 1'b0;\n\t\t\tSTB_O <= 1'b0;\n\t\t\t\n\t\t\tstate <= S_SET_CONTROL;\n\t\tend\n\tend\n\telse if(state == S_SET_CONTROL) begin\n\t\tCYC_O <= 1'b1;\n\t\tDAT_O <= 32'd2;\n\t\tSTB_O <= 1'b1;\n\t\tWE_O <= 1'b1;\n\t\tADR_O <= 30'h30000003;\n\t\t\n\t\tstate <= S_SET_CONTROL_2;\n\tend\n\telse if(state == S_SET_CONTROL_2) begin\n\t\tif(ACK_I == 1'b1) begin\n\t\t\tCYC_O <= 1'b0;\n\t\t\tSTB_O <= 1'b0;\n\t\t\t\n\t\t\tstate <= S_CHECK_FINISHED;\n\t\tend\n\tend\n\telse if(state == S_CHECK_FINISHED) begin\n\t\tCYC_O <= 1'b1;\n\t\tDAT_O <= 32'd0;\n\t\tSTB_O <= 1'b1;\n\t\tWE_O <= 1'b0;\n\t\tADR_O <= 30'h30000000;\n\t\t\n\t\tstate <= S_CHECK_FINISHED_2;\n\tend\n\telse if(state == S_CHECK_FINISHED_2) begin\n\t\tif(ACK_I == 1'b1) begin\n\t\t\tCYC_O <= 1'b0;\n\t\t\tSTB_O <= 1'b0;\n\t\t\t\n\t\t\tif(DAT_I == 32'd2) begin state <= S_FINISHED;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate <= S_CHECK_FINISHED_3;\n\t\t\tend\n\t\tend\n\tend\n\telse if(state == S_CHECK_FINISHED_3) begin\n\t\tif(wait_counter == 10'd1023) begin\n\t\t\twait_counter <= 10'd0;\n\t\t\tstate <= S_CHECK_FINISHED;\n\t\tend\n\t\telse wait_counter <= wait_counter + 10'd1;\n\tend\n\telse if(state == S_FINISHED) begin\n\tend\n\t\nend\n\nendmodule\n\n",
        "module_name": "early_boot",
        "module_hash": "cee2347e84f42338b17d398155b9ddb4",
        "dataset_index": 9916
      },
      "magnitude_comparator_328c596d": {
        "rtl_code": "module magnitude_comparator(\n  input [3:0] A,\n  input [3:0] B,\n  output EQ,\n  output GT,\n  output LT\n);\n\n  assign EQ = (A == B);\n  assign GT = (A > B);\n  assign LT = (A < B);\n\nendmodule",
        "module_name": "magnitude_comparator",
        "module_hash": "328c596d53522bef2f220d6958920171",
        "dataset_index": 1615
      },
      "mux_4x1_w8_78cff61c": {
        "rtl_code": "module mux_4x1_w8 (ctrl, D0, D1, D2, D3, S);\n  input [1:0] ctrl;\n  input [7:0] D0;\n  input [7:0] D1;\n  input [7:0] D2;\n  input [7:0] D3;\n  output [7:0] S;\n\n  assign S = (ctrl == 2'b00) ? D0 :\n             (ctrl == 2'b01) ? D1 :\n             (ctrl == 2'b10) ? D2 :\n             (ctrl == 2'b11) ? D3 :\n             8'b0;\nendmodule",
        "module_name": "mux_4x1_w8",
        "module_hash": "78cff61c572e59e8a6070e90d624678b",
        "dataset_index": 10511
      },
      "address_decoder_a40953c1": {
        "rtl_code": "module address_decoder(\n    input [14:0] address,\n    input clock,\n    output reg [11:0] q\n);\n\nalways @(posedge clock) begin\n    if(address < 15'h0800) begin\n        q <= 12'h000;\n    end else if(address < 15'h1000) begin\n        q <= address[11:0];\n    end else begin\n        q <= address[14:3];\n    end\nend\n\nendmodule",
        "module_name": "address_decoder",
        "module_hash": "a40953c10d7d2e5b2953607dafded59b",
        "dataset_index": 17705
      },
      "fifo_generator_3c9b93cb": {
        "rtl_code": "\nmodule fifo_generator\n   (DOUTB,\n    clk,\n    ENB,\n    E,\n    Q,\n    ADDRB,\n    ADDRA,\n    din);\n  output [93:0]DOUTB;\n  input clk;\n  input ENB;\n  input [0:0]E;\n  input [0:0]Q;\n  input [5:0]ADDRB;\n  input [5:0]ADDRA;\n  input [93:0]din;\n\n  reg [93:0] mem [255:0];\n  integer ii;\n\n  assign ADDRA = ADDRA[5:0];\n  assign ADDRB = ADDRB[5:0];\n\n  assign DOUTB = mem[ADDRB];\n\n  always @(posedge clk) begin\n    if (E)\n      mem[ADDRA] <= din;\n  end\n\n  always @(posedge clk) begin\n    if (ENB) begin\n      if (Q)\n        mem[ADDRB] <= mem[ADDRB+1];\n      else\n        mem[ADDRB] <= mem[ADDRB-1];\n    end\n  end\n\nendmodule",
        "module_name": "fifo_generator",
        "module_hash": "3c9b93cbb84ba2ec1083cc6d07534bc5",
        "dataset_index": 9030
      },
      "multiplier_alu_top_872d4f48": {
        "rtl_code": "\nmodule multiplier_alu_top (\n    input [7:0] A,\n    input [7:0] B,\n    input [2:0] OP,\n    output reg [7:0] final_output\n);\n\n    // 8-bit multiplier module\n    wire [15:0] mult_result;\n    multiplier_8bit mult_inst (\n        .A(A),\n        .B(B),\n        .P(mult_result)\n    );\n\n    // 4-bit ALU module\n    wire [3:0] alu_result;\n    alu_4bit alu_inst (\n        .A(mult_result[7:4]), // Truncate the MSB 4 bits of the multiplication result\n        .B(A[3:0]), // Truncate the MSB 4 bits of A\n        .OP(OP),\n        .Y(alu_result)\n    );\n\n    // Additive functional module\n    always @ (*) //Changed from always @ (mult_result or alu_result)\n    begin\n        final_output = mult_result[15:8] + alu_result;\n    end\n\nendmodule\n\nmodule multiplier_8bit (\n    input [7:0] A,\n    input [7:0] B,\n    output reg [15:0] P\n);\n\n    reg [8:0] sum; //Changed the width from 16 to 9\n    integer i; //Declare i as an integer for the loop\n\n    always @ (*) //Changed from always @ (A or B)\n    begin\n        P = 0;\n        sum = 0;\n        for (i = 0; i < 8; i = i + 1)\n        begin\n            if (B[i] == 1)\n            begin\n                sum = sum + (A << i);\n            end\n        end\n        P = sum[7:0]; //Truncate the MSB 8 bits\n    end\n\nendmodule\n\nmodule alu_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] OP,\n    output reg [3:0] Y\n);\n\n    always @ (*) //Changed from always @ (A or B or OP)\n    begin\n        case (OP)\n            3'b000: Y = A + B; // addition\n            3'b001: Y = A - B; // subtraction\n            3'b010: Y = A & B; // bitwise AND\n            3'b011: Y = A | B; // bitwise OR\n            3'b100: Y = A ^ B; // bitwise XOR\n            3'b101: Y = A << 1; // arithmetic shift left\n            default: Y = 0;\n        endcase\n    end\n\nendmodule\n",
        "module_name": "multiplier_alu_top",
        "module_hash": "872d4f48df3c09d31de7a65024819b76",
        "dataset_index": 17870
      },
      "calculator_f0b170a3": {
        "rtl_code": "module calculator(\n  input clk,\n  input rst,\n  input [1:0] op,\n  input [7:0] num1,\n  input [7:0] num2,\n  output [7:0] result,\n  output valid);\n\n  reg [7:0] result_reg;\n  reg valid_reg;\n  \n  always@(posedge clk) begin\n    if(rst) begin\n      result_reg <= 8'b0;\n      valid_reg <= 1'b0;\n    end else begin\n      case(op)\n        2'b00: result_reg <= num1 + num2;\n        2'b01: result_reg <= num1 - num2;\n        2'b10: result_reg <= num1 * num2;\n        2'b11: result_reg <= num1 / num2;\n      endcase\n      \n      valid_reg <= 1'b1;\n    end\n  end\n  \n  assign result = result_reg;\n  assign valid = valid_reg;\n  \nendmodule",
        "module_name": "calculator",
        "module_hash": "f0b170a30b4e9e005ff3fc3259808970",
        "dataset_index": 3179
      },
      "counter_5853c9ff": {
        "rtl_code": "module counter(\n  input clk,\n  input rst,\n  input en,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 4'b0000;\n    end else if (en) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "5853c9ff94f2c249eedc16c6103390b0",
        "dataset_index": 11519
      },
      "adder4_aaf35456": {
        "rtl_code": "module adder4 (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [3:0] xor_out;\n    wire [3:0] and_out;\n    wire [3:0] or_out;\n\n    assign xor_out = a ^ b;\n    assign and_out = a & b;\n    assign or_out = a | b;\n\n    assign sum[0] = xor_out[0] ^ cin;\n    assign sum[1] = xor_out[1] ^ and_out[0];\n    assign sum[2] = xor_out[2] ^ and_out[1];\n    assign sum[3] = xor_out[3] ^ and_out[2];\n\n    assign cout = or_out[3] | and_out[2] & xor_out[3] |\n                  and_out[1] & xor_out[2] |\n                  and_out[0] & xor_out[1] |\n                  cin & xor_out[0];\n\nendmodule",
        "module_name": "adder4",
        "module_hash": "aaf354568309c18558816d7206208d82",
        "dataset_index": 12856
      },
      "uart_c3cfd729": {
        "rtl_code": "\nmodule uart(\n    input clk, input rst, input rx, output tx, input transmit, input [7:0] tx_byte, output received, output [7:0] rx_byte, output is_receiving, output is_transmitting, output recv_error );\n\nparameter CLOCK_DIVIDE = 1302; parameter RX_IDLE = 0;\nparameter RX_CHECK_START = 1;\nparameter RX_READ_BITS = 2;\nparameter RX_CHECK_STOP = 3;\nparameter RX_DELAY_RESTART = 4;\nparameter RX_ERROR = 5;\nparameter RX_RECEIVED = 6;\n\nparameter TX_IDLE = 0;\nparameter TX_SENDING = 1;\nparameter TX_DELAY_RESTART = 2;\n\nreg [10:0] rx_clk_divider = CLOCK_DIVIDE;\nreg [10:0] tx_clk_divider = CLOCK_DIVIDE;\n\nreg [2:0] recv_state = RX_IDLE;\nreg [5:0] rx_countdown;\nreg [3:0] rx_bits_remaining;\nreg [7:0] rx_data;\n\nreg tx_out = 1'b1;\nreg [1:0] tx_state = TX_IDLE;\nreg [5:0] tx_countdown;\nreg [3:0] tx_bits_remaining;\nreg [7:0] tx_data;\n\nassign received = recv_state == RX_RECEIVED;\nassign recv_error = recv_state == RX_ERROR;\nassign is_receiving = recv_state != RX_IDLE;\nassign rx_byte = rx_data;\n\nassign tx = tx_out;\nassign is_transmitting = tx_state != TX_IDLE;\n\nalways @(posedge clk) begin\n\tif (rst) begin\n\t\trecv_state = RX_IDLE;\n\t\ttx_state = TX_IDLE;\n\tend\n\t\n\trx_clk_divider = rx_clk_divider - 1;\n\tif (!rx_clk_divider) begin\n\t\trx_clk_divider = CLOCK_DIVIDE;\n\t\trx_countdown = rx_countdown - 1;\n\tend\n\ttx_clk_divider = tx_clk_divider - 1;\n\tif (!tx_clk_divider) begin\n\t\ttx_clk_divider = CLOCK_DIVIDE;\n\t\ttx_countdown = tx_countdown - 1;\n\tend\n\t\n\tcase (recv_state)\n\t\tRX_IDLE: begin\n\t\t\tif (!rx) begin\n\t\t\t\trx_clk_divider = CLOCK_DIVIDE;\n\t\t\t\trx_countdown = 2;\n\t\t\t\trecv_state = RX_CHECK_START;\n\t\t\tend\n\t\tend\n\t\tRX_CHECK_START: begin\n\t\t\tif (!rx_countdown) begin\n\t\t\t\tif (!rx) begin\n\t\t\t\t\trx_countdown = 4;\n\t\t\t\t\trx_bits_remaining = 8;\n\t\t\t\t\trecv_state = RX_READ_BITS;\n\t\t\t\tend else begin\n\t\t\t\t\trecv_state = RX_ERROR;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tRX_READ_BITS: begin\n\t\t\tif (!rx_countdown) begin\n\t\t\t\trx_data = {rx, rx_data[7:1]};\n\t\t\t\trx_countdown = 4;\n\t\t\t\trx_bits_remaining = rx_bits_remaining - 1;\n\t\t\t\trecv_state = rx_bits_remaining ? RX_READ_BITS : RX_CHECK_STOP;\n\t\t\tend\n\t\tend\n\t\tRX_CHECK_STOP: begin\n\t\t\tif (!rx_countdown) begin\n\t\t\t\trecv_state = rx ? RX_RECEIVED : RX_ERROR;\n\t\t\tend\n\t\tend\n\t\tRX_DELAY_RESTART: begin\n\t\t\trecv_state = rx_countdown ? RX_DELAY_RESTART : RX_IDLE;\n\t\tend\n\t\tRX_ERROR: begin\n\t\t\trx_countdown = 8;\n\t\t\trecv_state = RX_DELAY_RESTART;\n\t\tend\n\t\tRX_RECEIVED: begin\n\t\t\trecv_state = RX_IDLE;\n\t\tend\n\tendcase\n\t\n\tcase (tx_state)\n\t\tTX_IDLE: begin\n\t\t\tif (transmit) begin\n\t\t\t\ttx_data = tx_byte;\n\t\t\t\ttx_clk_divider = CLOCK_DIVIDE;\n\t\t\t\ttx_countdown = 4;\n\t\t\t\ttx_out = 0;\n\t\t\t\ttx_bits_remaining = 8;\n\t\t\t\ttx_state = TX_SENDING;\n\t\t\tend\n\t\tend\n\t\tTX_SENDING: begin\n\t\t\tif (!tx_countdown) begin\n\t\t\t\tif (tx_bits_remaining) begin\n\t\t\t\t\ttx_bits_remaining = tx_bits_remaining - 1;\n\t\t\t\t\ttx_out = tx_data[0];\n\t\t\t\t\ttx_data = {1'b0, tx_data[7:1]};\n\t\t\t\t\ttx_countdown = 4;\n\t\t\t\t\ttx_state = TX_SENDING;\n\t\t\t\tend else begin\n\t\t\t\t\ttx_out = 1;\n\t\t\t\t\ttx_countdown = 8;\n\t\t\t\t\ttx_state = TX_DELAY_RESTART;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tTX_DELAY_RESTART: begin\n\t\t\ttx_state = tx_countdown ? TX_DELAY_RESTART : TX_IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "uart",
        "module_hash": "c3cfd729e27f7b0168ed65a8fcbe5347",
        "dataset_index": 25289
      },
      "byte_counter_9b2ee8e6": {
        "rtl_code": "\nmodule byte_counter (\n    input wire [15:0] in,\n    input wire [7:0] in_vec,\n    output reg [7:0] out\n);\n\n// Split input word into two bytes\nwire [7:0] upper_byte = in[15:8];\nwire [7:0] lower_byte = in[7:0];\n\n// Count number of 1's in upper byte\nwire [7:0] upper_count;\nbarrel_shifter barrel_upper(.in(upper_byte), .out(upper_count));\n\n// Count number of 1's in lower byte\nwire [7:0] lower_count;\nbarrel_shifter barrel_lower(.in(lower_byte), .out(lower_count));\n\n// Count number of 1's in input vector\nwire [7:0] vec_count;\nbarrel_shifter barrel_vec(.in(in_vec), .out(vec_count));\n\n// Add the three counts\nwire [8:0] sum;\nbinary_tree_adder adder(.in({upper_count, lower_count, vec_count}), .out(sum));\n\n// Output the sum\nalways @(*)\n    out = sum[7:0];\n\nendmodule\nmodule barrel_shifter (\n    input wire [7:0] in,\n    output reg [7:0] out\n);\n\n// Shift input left by 1, 2, 4, 8 bits and add results\nwire [7:0] shift1 = {in[6:0], 1'b0};\nwire [7:0] shift2 = {in[5:0], 2'b00};\nwire [7:0] shift4 = {in[3:0], 4'b0000};\nwire [7:0] shift8 = {in[0], 7'b0000000};\nwire [7:0] sum1 = shift1 + in;\nwire [7:0] sum2 = shift2 + sum1;\nwire [7:0] sum4 = shift4 + sum2;\nwire [7:0] sum8 = shift8 + sum4;\n\n// Output sum8\nalways @(*)\n    out = sum8;\n\nendmodule\nmodule binary_tree_adder (\n    input wire [23:0] in,\n    output reg [8:0] out\n);\n\n// Add pairs of adjacent bits until only one bit is left\nwire [22:0] sum1 = in[0] + in[1];\nwire [21:0] sum2 = sum1[0] + sum1[1];\nwire [20:0] sum3 = sum2[0] + sum2[1];\nwire [19:0] sum4 = sum3[0] + sum3[1];\nwire [18:0] sum5 = sum4[0] + sum4[1];\nwire [17:0] sum6 = sum5[0] + sum5[1];\nwire [16:0] sum7 = sum6[0] + sum6[1];\nwire [15:0] sum8 = sum7[0] + sum7[1];\nwire [14:0] sum9 = sum8[0] + sum8[1];\nwire [13:0] sum10 = sum9[0] + sum9[1];\nwire [12:0] sum11 = sum10[0] + sum10[1];\nwire [11:0] sum12 = sum11[0] + sum11[1];\nwire [10:0] sum13 = sum12[0] + sum12[1];\nwire [9:0] sum14 = sum13[0] + sum13[1];\nwire [8:0] sum15 = sum14[0] + sum14[1];\n\n// Output sum15\nalways @(*)\n    out = sum15;\n\nendmodule",
        "module_name": "byte_counter",
        "module_hash": "9b2ee8e64c39d2448cf7bbcc6aba2e9b",
        "dataset_index": 759
      },
      "two_bit_adder_60ca86a8": {
        "rtl_code": "module two_bit_adder(\n  input [1:0] A,\n  input [1:0] B,\n  output [1:0] S,\n  output C\n);\n\n  // Calculate the sum of the least significant bits of A and B\n  wire sum_lsb = A[0] ^ B[0];\n\n  // Calculate the sum of the most significant bits of A and B along with the carry out from the previous step\n  wire sum_msb = A[1] ^ B[1] ^ sum_lsb;\n  wire carry_out = (A[1] & B[1]) | (A[1] & sum_lsb) | (B[1] & sum_lsb);\n\n  // Combine the two sums and the carry out to produce the final output\n  assign S = {sum_msb, sum_lsb};\n  assign C = carry_out;\n\nendmodule",
        "module_name": "two_bit_adder",
        "module_hash": "60ca86a8ff70d07d7cb9af62c984e833",
        "dataset_index": 6824
      },
      "sky130_fd_sc_hdll__or4b_0d053ea4": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__or4b (\n    X  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , D_N              );\n    or  or0  (or0_out_X, not0_out, C, B, A);\n    buf buf0 (X        , or0_out_X        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__or4b",
        "module_hash": "0d053ea44666b568f449879c5374998c",
        "dataset_index": 22725
      },
      "flow_ctrl_tx_9e157146": {
        "rtl_code": "module flow_ctrl_tx\n  (input        rst,\n   input        tx_clk,\n   //host processor\n   input        tx_pause_en,\n   // From MAC_rx_ctrl\n   input [15:0] pause_quanta,\n   input        pause_quanta_val,\n   // MAC_tx_ctrl\n   output       pause_apply,\n   input        paused);\n     \n   // ******************************************************************************        \n   // Inhibit our TX from transmitting because they sent us a PAUSE frame\n   // ******************************************************************************\n\n   // Pauses are in units of 512 bit times, or 64 bytes/clock cycles, and can be\n   //   as big as 16 bits, so 22 bits are needed for the counter\n   \n   reg [15+6:0] pause_quanta_counter;\n   reg         pqval_d1, pqval_d2;       \n\n   always @(posedge tx_clk) pqval_d1 <= pause_quanta_val;\n   always @(posedge tx_clk) pqval_d2 <= pqval_d1;\n\n   always @ (posedge tx_clk or posedge rst)\n     if (rst)\n       pause_quanta_counter <= 0;\n     else if (pqval_d1 & ~pqval_d2)\n       pause_quanta_counter <= {pause_quanta, 6'b0}; \n     else if((pause_quanta_counter!=0) & paused)\n       pause_quanta_counter <= pause_quanta_counter - 1;\n\n   assign    pause_apply = tx_pause_en & (pause_quanta_counter != 0);\n   \nendmodule",
        "module_name": "flow_ctrl_tx",
        "module_hash": "9e157146b0652d35f3db05347f81d972",
        "dataset_index": 7315
      },
      "binary_to_gray_c2ae41f8": {
        "rtl_code": "module binary_to_gray(\n  input [2:0] bin,\n  output [2:0] gray\n);\n\n  wire x1, x2, x3, x4, x5, x6;\n\n  // XOR gates\n  xor(x1, bin[2], bin[1]);\n  xor(x2, bin[1], bin[0]);\n  xor(x3, bin[2], x1);\n  xor(x4, bin[1], x2);\n  xor(x5, bin[0], x4);\n\n  // AND gates\n  and(x6, x3, x5);\n\n  assign gray = {x6, x5, x4};\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "c2ae41f8456e47617213c83603488979",
        "dataset_index": 18951
      },
      "decoder_d1e498fd": {
        "rtl_code": "\nmodule decoder (\n    input enable,\n    input [1:0] in,\n    output reg [3:0] out\n);\n\nreg [1:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @(posedge enable) begin\n    stage1_out <= in;\nend\n\nalways @(posedge enable) begin\n    case (stage1_out)\n        2'b00: stage2_out <= 4'b0001;\n        2'b01: stage2_out <= 4'b0010;\n        2'b10: stage2_out <= 4'b0100;\n        2'b11: stage2_out <= 4'b1000;\n        default: stage2_out <= 4'b0000;\n    endcase\n    out = stage2_out;   // Blocking assignment\nend\n\nendmodule\n",
        "module_name": "decoder",
        "module_hash": "d1e498fd6bc9b706142633909f31637b",
        "dataset_index": 15109
      },
      "eth_outputcontrol_30dc4ad7": {
        "rtl_code": "\n`include \"timescale.v\"\n\nmodule eth_outputcontrol(Clk, Reset, InProgress, ShiftedBit, BitCounter, WriteOp, NoPre, MdcEn_n, Mdo, MdoEn);\n\nparameter Tp = 1;\n\ninput         Clk;                // Host Clock\ninput         Reset;              // General Reset\ninput         WriteOp;            // Write Operation Latch (When asserted, write operation is in progress)\ninput         NoPre;              // No Preamble (no 32-bit preamble)\ninput         InProgress;         // Operation in progress\ninput         ShiftedBit;         // This bit is output of the shift register and is connected to the Mdo signal\ninput   [6:0] BitCounter;         // Bit Counter\ninput         MdcEn_n;            // MII Management Data Clock Enable signal is asserted for one Clk period before Mdc falls.\n\noutput        Mdo;                // MII Management Data Output\noutput        MdoEn;              // MII Management Data Output Enable\n\nwire          SerialEn;\n\nreg           MdoEn_2d;\nreg           MdoEn_d;\nreg           MdoEn;\n\nreg           Mdo_2d;\nreg           Mdo_d;\nreg           Mdo;                // MII Management Data Output\n\n\n\n// Generation of the Serial Enable signal (enables the serialization of the data)\nassign SerialEn =  WriteOp & InProgress & ( BitCounter>31 | ( ( BitCounter == 0 ) & NoPre ) )\n                | ~WriteOp & InProgress & (( BitCounter>31 & BitCounter<46 ) | ( ( BitCounter == 0 ) & NoPre ));\n\n\n// Generation of the MdoEn signal\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      MdoEn_2d <= #Tp 1'b0;\n      MdoEn_d <= #Tp 1'b0;\n      MdoEn <= #Tp 1'b0;\n    end\n  else\n    begin\n      if(MdcEn_n)\n        begin\n          MdoEn_2d <= #Tp SerialEn | InProgress & BitCounter<32;\n          MdoEn_d <= #Tp MdoEn_2d;\n          MdoEn <= #Tp MdoEn_d;\n        end\n    end\nend\n\n\n// Generation of the Mdo signal.\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      Mdo_2d <= #Tp 1'b0;\n      Mdo_d <= #Tp 1'b0;\n      Mdo <= #Tp 1'b0;\n    end\n  else\n    begin\n      if(MdcEn_n)\n        begin\n          Mdo_2d <= #Tp ~SerialEn & BitCounter<32;\n          Mdo_d <= #Tp ShiftedBit | Mdo_2d;\n          Mdo <= #Tp Mdo_d;\n        end\n    end\nend\n\n\n\nendmodule\n",
        "module_name": "eth_outputcontrol",
        "module_hash": "30dc4ad74b8f5876fce144daf1c842ff",
        "dataset_index": 43
      },
      "bcd_converter_192fa6b4": {
        "rtl_code": "module bcd_converter (\n    input [3:0] in,\n    output [3:0] bcd_high,\n    output [3:0] bcd_low\n);\n\nwire [6:0] bcd_out;\nassign bcd_out = (in >= 5) ? (3'd3 << 4) | (in - 5) : (3'd0 << 4) | in;\n\nassign bcd_high = bcd_out[6:4];\nassign bcd_low = bcd_out[3:0];\n\nendmodule\nmodule mux_and_adder (\n    input [15:0] mux_in,\n    input [3:0] sel,\n    input EN,\n    input [3:0] bcd_high,\n    input [3:0] bcd_low,\n    output reg [3:0] bcd_sum\n);\n\nalways @(*) begin\n    case (sel)\n        4'b0000: bcd_sum = bcd_low + mux_in[3:0];\n        4'b0001: bcd_sum = bcd_low + mux_in[7:4];\n        4'b0010: bcd_sum = bcd_low + mux_in[11:8];\n        4'b0011: bcd_sum = bcd_low + mux_in[15:12];\n        4'b0100: bcd_sum = bcd_high + mux_in[3:0];\n        4'b0101: bcd_sum = bcd_high + mux_in[7:4];\n        4'b0110: bcd_sum = bcd_high + mux_in[11:8];\n        4'b0111: bcd_sum = bcd_high + mux_in[15:12];\n        4'b1000: bcd_sum = bcd_low + bcd_high + mux_in[3:0];\n        4'b1001: bcd_sum = bcd_low + bcd_high + mux_in[7:4];\n        4'b1010: bcd_sum = bcd_low + bcd_high + mux_in[11:8];\n        4'b1011: bcd_sum = bcd_low + bcd_high + mux_in[15:12];\n        default: bcd_sum = 4'b0000;\n    endcase\nend\n\nendmodule\nmodule top_module (\n    input [3:0] in,\n    input [15:0] mux_in,\n    input [3:0] sel,\n    input EN,\n    output [3:0] bcd_high,\n    output [3:0] bcd_low\n);\n\nwire [3:0] bcd_high_wire;\nwire [3:0] bcd_low_wire;\nwire [3:0] bcd_sum;\n\nbcd_converter bcd_converter_inst (\n    .in(in),\n    .bcd_high(bcd_high_wire),\n    .bcd_low(bcd_low_wire)\n);\n\nmux_and_adder mux_and_adder_inst (\n    .mux_in(mux_in),\n    .sel(sel),\n    .EN(EN),\n    .bcd_high(bcd_high_wire),\n    .bcd_low(bcd_low_wire),\n    .bcd_sum(bcd_sum)\n);\n\nbcd_converter bcd_converter_inst2 (\n    .in(bcd_sum),\n    .bcd_high(bcd_high),\n    .bcd_low(bcd_low)\n);\n\nendmodule\n",
        "module_name": "bcd_converter",
        "module_hash": "192fa6b49e72b0e6842f1a99273265f8",
        "dataset_index": 10134
      },
      "mux_4to1_125daffc": {
        "rtl_code": "module mux_4to1 (\n    sel,\n    in0,\n    in1,\n    in2,\n    in3,\n    out\n);\n\ninput [1:0] sel;\ninput in0;\ninput in1;\ninput in2;\ninput in3;\noutput out;\n\nwire sel0;\nwire sel1;\n\nassign sel0 = ~sel[1] & ~sel[0];\nassign sel1 = ~sel[1] & sel[0];\n\nassign out = (sel0 & in0) | (sel1 & in1) | (sel0 & in2) | (sel1 & in3);\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "125daffc298d6fdf76fbc763d822879a",
        "dataset_index": 5461
      },
      "rf_2p_8a4dc630": {
        "rtl_code": "module rf_2p (\n    clka    ,  \n    cena_i  ,\n    addra_i ,\n    dataa_o ,\n    clkb    ,     \n    cenb_i  ,   \n    wenb_i  ,   \n    addrb_i ,  \n    datab_i\n);\n\nparameter       Word_Width=32;\nparameter       Addr_Width=8;\n\ninput                   clka;      // clock input\ninput                   cena_i;    // chip enable, low active\ninput   [Addr_Width-1:0]  addra_i;   // address input\noutput  [Word_Width-1:0]  dataa_o;   // data output\n\n// B Port\ninput                   clkb;      // clock input                     \ninput                   cenb_i;    // chip enable, low active      \ninput                   wenb_i;    // write enable, low active        \ninput   [Addr_Width-1:0]  addrb_i;   // address input                   \ninput   [Word_Width-1:0]  datab_i;   // data input                     \n\nreg    [Word_Width-1:0]   mem_array[(1<<Addr_Width)-1:0];\n\nreg    [Word_Width-1:0]   dataa_r;\n\nalways @(posedge clka) begin\n    if (!cena_i)\n        dataa_r <= mem_array[addra_i];\n    else\n        dataa_r <= 'bx;\nend\n\nassign dataa_o = dataa_r;\n\n// -- B Port --//\nalways @(posedge clkb) begin\n    if(!cenb_i) begin\n        if(wenb_i) begin\n            if(datab_i > mem_array[addrb_i]) begin\n                mem_array[addrb_i] <= datab_i;\n            end\n        end else begin\n            mem_array[addrb_i] <= datab_i;\n        end\n    end\nend\n\nendmodule",
        "module_name": "rf_2p",
        "module_hash": "8a4dc630c04197ca41401a59a0029085",
        "dataset_index": 8019
      },
      "mag_comp #_04015d5b": {
        "rtl_code": "module mag_comp #(\n    parameter n = 8\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output A_greater_than_B,\n  output A_equal_to_B,\n  output A_less_than_B\n);\n\n\n  reg [n-1:0] A_xor_B;\n  reg [n-1:0] A_and_B;\n  reg [n-1:0] A_greater_than_B_bits;\n  reg [n-1:0] A_equal_to_B_bits;\n  reg [n-1:0] A_less_than_B_bits;\n\n  always @* begin\n    A_xor_B = A ^ B;\n    A_and_B = A & B;\n    A_greater_than_B_bits = A & A_xor_B;\n    A_equal_to_B_bits = ~A_xor_B & A_and_B;\n    A_less_than_B_bits = B & A_xor_B;\n  end\n\n  assign A_greater_than_B = |A_greater_than_B_bits;\n  assign A_equal_to_B = |A_equal_to_B_bits;\n  assign A_less_than_B = |A_less_than_B_bits;\n\nendmodule",
        "module_name": "mag_comp #",
        "module_hash": "04015d5b7d38857aa6bce13c0cf8fad3",
        "dataset_index": 9886
      },
      "my__94779937": {
        "rtl_code": "module my_module (\n    Q,\n    Q_N,\n    CLK,\n    D\n);\n\n    output Q;\n    output Q_N;\n    input CLK;\n    input D;\n\n    reg Q;\n\n    always @(posedge CLK) begin\n        Q <= D;\n    end\n\n    assign Q_N = ~Q;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "9477993752b17ccd4c20a91d8a66264d",
        "dataset_index": 10260
      },
      "full_adder_87eaae6f": {
        "rtl_code": "\nmodule full_adder(A, B, Cin, S, Cout);\n\ninput A, B, Cin;\noutput S, Cout;\n\nwire w1, w2, w3;\n\nxor(w1, A, B);\nxor(S, w1, Cin);\nand(w2, A, B);\nand(w3, w1, Cin);\nor(Cout, w2, w3);\n\nendmodule\nmodule half_adder(A, B, S, Cout);\n\ninput A, B;\noutput S, Cout;\n\nwire w1;\n\nxor(S, A, B);\nand(Cout, A, B);\n\nendmodule\nmodule four_bit_adder(A, B, Cin, S, Cout);\n\ninput [3:0] A, B;\ninput Cin;\noutput [3:0] S;\noutput Cout;\n\nwire c1, c2, c3;\n\nfull_adder fa1(A[0], B[0], Cin, S[0], c1);\nfull_adder fa2(A[1], B[1], c1, S[1], c2);\nfull_adder fa3(A[2], B[2], c2, S[2], c3);\nfull_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "87eaae6f5678159354a6d6fcf5a9ce85",
        "dataset_index": 5550
      },
      "mul_16_32_mult_87048555": {
        "rtl_code": "module mul_16_32_mult\n   (CLK,\n    A,\n    B,\n    CE,\n    SCLR,\n    ZERO_DETECT,\n    P,\n    PCASC);\n  input CLK;\n  input [15:0]A;\n  input [31:0]B;\n  input CE;\n  input SCLR;\n  output [1:0]ZERO_DETECT;\n  output [47:0]P;\n  output [47:0]PCASC;\n\n  reg [15:0] A_reg;\n  reg [31:0] B_reg;\n  reg [47:0] P_reg;\n  reg [47:0] PCASC_reg;\n  reg [1:0] ZERO_DETECT_reg;\n  wire [15:0] A_shifted;\n  wire [31:0] B_shifted;\n  wire [47:0] P_shifted;\n  wire [47:0] PCASC_shifted;\n\n  assign A_shifted = {16'b0, A};\n  assign B_shifted = {16'b0, B};\n  assign P_shifted = {32'b0, P_reg};\n  assign PCASC_shifted = {32'b0, PCASC_reg};\n\n  always @(posedge CLK) begin\n    if (SCLR) begin\n      A_reg <= 16'b0;\n      B_reg <= 32'b0;\n      P_reg <= 48'b0;\n      PCASC_reg <= 48'b0;\n      ZERO_DETECT_reg <= 2'b11;\n    end else if (CE) begin\n      A_reg <= A;\n      B_reg <= B;\n      P_reg <= P_shifted + (A_shifted * B_shifted);\n      PCASC_reg <= PCASC_shifted + ({32'b0, A} * B_shifted);\n      ZERO_DETECT_reg <= (P_reg == 48'b0) ? 2'b11 : (P_reg[47:0] == 0) ? 2'b10 : 2'b00;\n    end\n  end\n\n  assign P = P_reg;\n  assign PCASC = PCASC_reg;\n  assign ZERO_DETECT = ZERO_DETECT_reg;\n\nendmodule",
        "module_name": "mul_16_32_mult",
        "module_hash": "87048555bef8c30d52ff234ec124f8a2",
        "dataset_index": 10907
      },
      "full_adder_bbcd74df": {
        "rtl_code": "\nmodule full_adder(output sum, carry_out, input a, b, carry_in);\n    wire w1, w2, w3;\n    xor(sum, a, b, carry_in);\n    and(w1, a, b);\n    and(w2, a, carry_in);\n    and(w3, b, carry_in);\n    or(carry_out, w1, w2, w3);\nendmodule\nmodule ripple_carry_adder(output [3:0] S, output Cout, input [3:0] A, B, input Cin);\n    wire [2:0] c;\n    full_adder fa1(S[0], c[0], A[0], B[0], Cin);\n    full_adder fa2(S[1], c[1], A[1], B[1], c[0]);\n    full_adder fa3(S[2], c[2], A[2], B[2], c[1]);\n    full_adder fa4(S[3], Cout, A[3], B[3], c[2]);\nendmodule",
        "module_name": "full_adder",
        "module_hash": "bbcd74dfdc5da662e4199f81f8de36c1",
        "dataset_index": 9366
      },
      "sky130_fd_sc_ms__a21o_008472fd": {
        "rtl_code": "module sky130_fd_sc_ms__a21o (\n    //# {{data|Data Signals}}\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    output X   ,\n\n    //# {{power|Power}}\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n    wire temp1, temp2, temp3, temp4;\n    assign temp1 = ~(A1 & A2);\n    assign temp2 = A1 ^ B1;\n    assign temp3 = ~B1;\n    assign temp4 = A1;\n    assign X = temp1 & temp2 | temp3 & temp4;\nendmodule",
        "module_name": "sky130_fd_sc_ms__a21o",
        "module_hash": "008472fd188d96bd77d16976308b4753",
        "dataset_index": 19283
      },
      "UART_Tx_20b25b23": {
        "rtl_code": "\nmodule UART_Tx(\n\tinput CLK,\n\tinput [7:0]D,\n\tinput WR,\n\tinput RST,\n\toutput TX,\n\toutput reg TXE = 1'b1\n   );\n\t\nparameter CLOCK = 1_000_000;\nparameter BAUD_RATE = 9_600;\n\nlocalparam CLK_DIV = CLOCK/(BAUD_RATE*2);\nreg [$clog2(CLK_DIV)-1:0]baud_counter = 0;\n\nreg prev_CLK_B;\nreg CLK_B = 1'b0; \n\nreg [9:0]send_reg = 10'h3FF;\nreg [3:0]counter = 0;\n\nassign TX = send_reg[0]; \n\nalways @ (posedge CLK) begin \n\tprev_CLK_B <= CLK_B;\n\tbaud_counter <= baud_counter+1'b1;\n\tif ( baud_counter == CLK_DIV-1) begin\n\t\tbaud_counter <=0; \n\t\tCLK_B <= ~CLK_B;\n\tend\nend\n\nalways @(posedge CLK) begin\n\tif (RST == 1'b1) begin\n\t\tsend_reg <= 10'h3FF;\n\t\tcounter <= 0;\n\t\tTXE <= 1'b1;\n\tend\n\telse if (WR == 1'b1 && TXE) begin\n\t\tsend_reg <= {D, 1'b0, 1'b1};\n\t\tcounter <= 10;\n\t\tTXE <= 1'b0;\n\tend\n\telse if(CLK_B == 1'b1 && prev_CLK_B == 1'b0) begin\n\t\tsend_reg <= {1'b1, send_reg[9:1]};\n\t\tif(counter > 0) begin\n\t\t\tcounter <= counter - 1'b1;\n\t\tend else begin\n\t\t\tTXE <= 1'b1;\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "UART_Tx",
        "module_hash": "20b25b23e5ae7e6d888b9f4916942702",
        "dataset_index": 24450
      },
      "jserialadder_50a8a188": {
        "rtl_code": "module jserialadder(y,carryout,isValid,currentsum,currentcarryout,currentbitcount,clk,rst,a,b,carryin);\n  output reg [3:0]y;\n  output reg carryout;\n  output reg isValid; \n  output reg currentsum, currentcarryout;\n  output reg [1:0]currentbitcount;\n  input clk,rst;\n  input a,b,carryin;\n\n  wire intermediatecarry;\n  \n  // intermediatecarry should point to the carryin only for the 1st bit afterward it is previous bit's carryout\n  assign intermediatecarry = ( currentbitcount == 3'd0) ? carryin : currentcarryout;\n  \n  // Full adder to work on the posedge of the clock\n  always@(posedge clk)\n  begin\n    currentsum <= a ^ b ^ intermediatecarry;\n    currentcarryout <= ( a & b ) | ( a & intermediatecarry ) | ( b & intermediatecarry );\n  end\n\n  // Shift register for serial addition\n  always@(posedge clk)\n  begin\n    if(rst)\n      begin\n        y <= 0;\n        carryout <= 0;\n      end\n    else\n      begin\n        y <= {currentsum, y[3:1]};\n        carryout <= ( currentbitcount == 3'd4 ) ? currentcarryout : 0;\n      end\n    end\n\n  // Bit counter to keep track of number of bits added\n  always@(posedge clk)\n  begin\n    if(rst)\n        currentbitcount <= 0;\n    else\n        currentbitcount <= currentbitcount + 1;\n  end\n\n  // isValid will provide the indication as to whether the addition is completed  \n  always@(posedge clk)\n  begin\n    if(rst)\n        isValid <= 0;\n    else\n        isValid <= (currentbitcount == 3) ? 1 : 0;\n  end\n  \nendmodule",
        "module_name": "jserialadder",
        "module_hash": "50a8a18850c26d97eb575addce77d99b",
        "dataset_index": 15115
      },
      "priority_encoder_6a55f67d": {
        "rtl_code": "\nmodule priority_encoder (\n  input [3:0] in,\n  output [1:0] out\n);\n\n  assign out = in[3] ? 2'b11 :\n               in[2] ? 2'b10 :\n               in[1] ? 2'b01 :\n                            2'b00;\n\nendmodule\nmodule full_adder (\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\nmodule binary_multiplier (\n  input [3:0] a,\n  input [3:0] b,\n  output [7:0] product\n);\n\n  wire [1:0] a_high, b_high;\n  wire [3:0] a_shifted, b_shifted;\n  wire [7:0] p0, p1, p2, p3;\n\n  priority_encoder pe_a(.in(a), .out(a_high));\n  priority_encoder pe_b(.in(b), .out(b_high));\n\n  assign a_shifted = {b_high == 2'b00 ? 2'b00 : a[1:0], 2'b00};\n  assign b_shifted = {a_high == 2'b00 ? 2'b00 : b[1:0], 2'b00};\n\n  full_adder fa0(.a(a_shifted[0]), .b(b_shifted[0]), .cin(1'b0), .sum(p0[0]), .cout(p0[1]));\n  full_adder fa1(.a(a_shifted[1]), .b(b_shifted[0]), .cin(p0[1]), .sum(p1[0]), .cout(p1[1]));\n  full_adder fa2(.a(a_shifted[2]), .b(b_shifted[0]), .cin(p1[1]), .sum(p2[0]), .cout(p2[1]));\n  full_adder fa3(.a(a_shifted[3]), .b(b_shifted[0]), .cin(p2[1]), .sum(p3[0]), .cout(p3[1]));\n\n  assign product = {p3[1], p3[0], p2[0], p1[0], p0[0], 3'b000};\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "6a55f67d0e7b266cd3879d7648b57a34",
        "dataset_index": 19257
      },
      "altera_reset_synchronizer_6c6efbae": {
        "rtl_code": "module altera_reset_synchronizer\n#(\n    parameter ASYNC_RESET = 1,\n    parameter DEPTH       = 2\n)\n(\n    input   reset_in ,\n\n    input   clk,\n    output  reset_out\n);\n\n    // -----------------------------------------------\n    // Synchronizer register chain. We cannot reuse the\n    // standard synchronizer in this implementation \n    // because our timing constraints are different.\n    //\n    // Instead of cutting the timing path to the d-input \n    // on the first flop we need to cut the aclr input.\n    // \n    // We omit the \"preserve\" attribute on the final\n    // output register, so that the synthesis tool can\n    // duplicate it where needed.\n    // -----------------------------------------------\n     reg [DEPTH-1:0] altera_reset_synchronizer_int_chain;\n    reg altera_reset_synchronizer_int_chain_out;\n\n    generate if (ASYNC_RESET) begin\n\n        // -----------------------------------------------\n        // Assert asynchronously, deassert synchronously.\n        // -----------------------------------------------\n        always @(posedge clk or posedge reset_in) begin\n            if (reset_in) begin\n                altera_reset_synchronizer_int_chain <= {DEPTH{1'b1}};\n                altera_reset_synchronizer_int_chain_out <= 1'b1;\n            end\n            else begin\n                altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n                altera_reset_synchronizer_int_chain[DEPTH-1] <= 0;\n                altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n            end\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n     \n    end else begin\n\n        // -----------------------------------------------\n        // Assert synchronously, deassert synchronously.\n        // -----------------------------------------------\n        always @(posedge clk) begin\n            altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n            altera_reset_synchronizer_int_chain[DEPTH-1] <= reset_in;\n            altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n \n    end\n    endgenerate\n\nendmodule",
        "module_name": "altera_reset_synchronizer",
        "module_hash": "6c6efbae22d44c565a57cb0172c6f2a5",
        "dataset_index": 15566
      },
      "up_counter_3cf8b0be": {
        "rtl_code": "module up_counter\n(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end\n    else if (en) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "3cf8b0be5cc461af3652d370e8859cb6",
        "dataset_index": 18114
      },
      "decoder_c1b752f6": {
        "rtl_code": "module decoder(\n    output [15:0] decoderout,\n    input [3:0] waddr\n);\n\n    assign decoderout = 16'b0000_0000_0000_0001 << waddr;\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "c1b752f6684d31b696aff932747d1fc6",
        "dataset_index": 15692
      },
      "multiplier_block_2f75ba5f": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w4,\n    w5,\n    w8192,\n    w8187,\n    w160,\n    w8027,\n    w16054;\n\n  assign w1 = i_data0;\n  assign w4 = w1 << 2;\n  assign w5 = w1 + w4;\n  assign w8192 = w1 << 13;\n  assign w8187 = w8192 - w5;\n  assign w160 = w5 << 5;\n  assign w8027 = w8187 - w160;\n  assign w16054 = w8027 << 1;\n\n  assign o_data0 = w16054;\n\n  //multiplier_block area estimate = 5272.34396680147;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "2f75ba5fe9c54b5861584459abca478d",
        "dataset_index": 18817
      },
      "sky130_fd_sc_hdll__o21bai_6a8660a4": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__o21bai (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    wire b          ;\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    not  not0  (b          , B1_N           );\n    or   or0   (or0_out    , A2, A1         );\n    nand nand0 (nand0_out_Y, b, or0_out     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__o21bai",
        "module_hash": "6a8660a4bc95ad165c6998b8c0b09aec",
        "dataset_index": 18548
      },
      "timer_wait_11781e56": {
        "rtl_code": "module timer_wait(\n  input wire clk,\n  input wire rsth,\n  input wire mod_sel,\n  input wire req,\n  input wire [7:0] w_wdata,\n  output wire ack\n);\n\n  wire        en_wait_countup;  reg [15:0]  en_wait_cnt;      reg [7:0]   wait_cnt;\n  reg         req_1d;\n  wire        req_pe;\n\n  always @(posedge clk) begin\n    if(rsth) req_1d <= 0;\n    else     req_1d <= req;\n  end\n\n  assign req_pe = (mod_sel) & (req & ~req_1d);\n\n  always @(posedge clk) begin\n    if(rsth) en_wait_cnt <= 49999;\n    else if(en_wait_cnt == 0) en_wait_cnt <= 49999;\n    else                      en_wait_cnt <= en_wait_cnt - 1;\n  end\n  assign en_wait_countup = (en_wait_cnt == 0);\n\n  always @(posedge clk) begin\n    if(rsth) wait_cnt <= 0;\n    else if(req_pe)           wait_cnt <= w_wdata;\n    else if(wait_cnt == 0)    wait_cnt <= wait_cnt;\n    else if(en_wait_countup)  wait_cnt <= wait_cnt - 1;\n  end\n\n  assign ack = (wait_cnt == 0);\n\nendmodule\n\n",
        "module_name": "timer_wait",
        "module_hash": "11781e562b8b5566f4cb3fe894b961e1",
        "dataset_index": 21108
      },
      "serial_interface_7b2a0f91": {
        "rtl_code": "module serial_interface (\n    input reset,\n    input clk,\n    input [3:0] mcu_data,\n    input mcu_data_valid,\n    input [3:0] periph_data,\n    input periph_data_valid,\n    output reg mcu_data_ready,\n    output reg periph_data_ready,\n    output reg [3:0] mcu_response,\n    output reg [3:0] periph_response\n);\n\n    reg [3:0] mcu_buffer;\n    reg [3:0] periph_buffer;\n    reg [1:0] state_reg = 2'b00;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state_reg <= 2'b00;\n            mcu_buffer <= 4'b0;\n            periph_buffer <= 4'b0;\n            mcu_data_ready <= 1'b0;\n            periph_data_ready <= 1'b0;\n            mcu_response <= 4'b0;\n            periph_response <= 4'b0;\n        end\n        else begin\n            case (state_reg)\n                2'b00: // Idle state\n                    begin\n                        if (mcu_data_valid && !periph_data_ready) begin\n                            // Store data in buffer\n                            mcu_buffer <= mcu_data;\n                            // Set data ready signal\n                            mcu_data_ready <= 1'b1;\n                            // Move to next state\n                            state_reg <= 2'b01;\n                        end\n                        else if (!mcu_data_ready && periph_data_valid) begin\n                            // Store data in buffer\n                            periph_buffer <= periph_data;\n                            // Set data ready signal\n                            periph_data_ready <= 1'b1;\n                            // Move to next state\n                            state_reg <= 2'b10;\n                        end\n                    end\n                2'b01: // Wait for peripheral device to be ready\n                    begin\n                        if (periph_data_ready) begin\n                            // Transfer data to peripheral device\n                            periph_response <= mcu_buffer;\n                            // Clear data ready signals\n                            mcu_data_ready <= 1'b0;\n                            periph_data_ready <= 1'b0;\n                            // Move back to idle state\n                            state_reg <= 2'b00;\n                        end\n                    end\n                2'b10: // Wait for microcontroller to be ready\n                    begin\n                        if (mcu_data_ready) begin\n                            // Transfer data to microcontroller\n                            mcu_response <= periph_buffer;\n                            // Clear data ready signals\n                            mcu_data_ready <= 1'b0;\n                            periph_data_ready <= 1'b0;\n                            // Move back to idle state\n                            state_reg <= 2'b00;\n                        end\n                    end\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "serial_interface",
        "module_hash": "7b2a0f914b9eee3011a73ead11b1a284",
        "dataset_index": 4673
      },
      "axi_traffic_gen_v2_0_7_id_track_701c418c": {
        "rtl_code": "module axi_traffic_gen_v2_0_7_id_track\n        #(\nparameter ID_WIDTH = 1\n) (\n  input                 Clk           ,\n  input                 rst_l         ,\n  input [ID_WIDTH-1:0]  in_push_id    ,\n  input                 in_push       ,\n  input [ID_WIDTH-1:0]  in_search_id  ,\n  input [3:0]           in_clear_pos  ,\n  input                 in_only_entry0,\n  output [3:0]          out_push_pos  ,\n  output [3:0]          out_search_hit,\n  output [3:0]          out_free\n);\n\n// Declare registers to store the IDs\nreg [ID_WIDTH:0] id_arr0_ff, id_arr1_ff, id_arr2_ff, id_arr3_ff;\n\n// Declare registers to store the positions of the incoming transaction\nreg [3:0] push_pos_ff, push_pos_2ff;\n\n// Declare register to store the positions to be cleared\nreg [3:0] in_clear_pos_ff;\n\n// Create a wire to append a '1' to the incoming ID\nwire [ID_WIDTH:0] push_id = { 1'b1, in_push_id[ID_WIDTH-1:0] };\n\n// Create a wire to determine the positions of the incoming transaction\nwire [3:0] push_search = { (push_id[ID_WIDTH:0] == id_arr3_ff[ID_WIDTH:0]),\n                        (push_id[ID_WIDTH:0] == id_arr2_ff[ID_WIDTH:0]),\n                        (push_id[ID_WIDTH:0] == id_arr1_ff[ID_WIDTH:0]),\n                        (push_id[ID_WIDTH:0] == id_arr0_ff[ID_WIDTH:0]) };\n\n// Create a wire to determine the positions of free slots\nwire [3:0] free_pre = { ~id_arr3_ff[ID_WIDTH], ~id_arr2_ff[ID_WIDTH],\n                        ~id_arr1_ff[ID_WIDTH], ~id_arr0_ff[ID_WIDTH] };\nwire [3:0] free = (in_only_entry0) ? { 3'b000, free_pre[0] } : free_pre[3:0];\nwire [3:0] first_free = (free[0]) ? 4'h1 :\n                        (free[1]) ? 4'h2 :\n                        (free[2]) ? 4'h4 :\n                        (free[3]) ? 4'h8 : 4'h0;\n\n// Create a wire to determine the position of the incoming transaction\nwire [3:0] push_pos = (in_push == 1'b0) ? 4'h0 :\n                (push_search[3:0] != 4'h0) ? push_search[3:0] :\n                        first_free[3:0];\n\n// Create a wire to append a '1' to the searched ID\nwire [ID_WIDTH:0] search_id = { 1'b1, in_search_id[ID_WIDTH-1:0] };\n\n// Create a wire to determine the position of the searched ID\nwire [3:0] search_pos = { (search_id[ID_WIDTH:0] == id_arr3_ff[ID_WIDTH:0]),\n                        (search_id[ID_WIDTH:0] == id_arr2_ff[ID_WIDTH:0]),\n                        (search_id[ID_WIDTH:0] == id_arr1_ff[ID_WIDTH:0]),\n                        (search_id[ID_WIDTH:0] == id_arr0_ff[ID_WIDTH:0]) };\n\n// Create a wire to determine the positions to be cleared\nwire [3:0] do_clear = ~push_pos_ff[3:0] & ~push_pos_2ff[3:0] &\n                                                in_clear_pos_ff[3:0];\n\n// Create wires to update the ID array\nwire [ID_WIDTH:0] id_arr0 = (push_pos[0]) ? push_id[ID_WIDTH:0] :\n        { (do_clear[0]) ? 1'b0:id_arr0_ff[ID_WIDTH], id_arr0_ff[ID_WIDTH-1:0] };\nwire [ID_WIDTH:0] id_arr1 = (push_pos[1]) ? push_id[ID_WIDTH:0] :\n        { (do_clear[1]) ? 1'b0:id_arr1_ff[ID_WIDTH], id_arr1_ff[ID_WIDTH-1:0] };\nwire [ID_WIDTH:0] id_arr2 = (push_pos[2]) ? push_id[ID_WIDTH:0] :\n        { (do_clear[2]) ? 1'b0:id_arr2_ff[ID_WIDTH], id_arr2_ff[ID_WIDTH-1:0] };\nwire [ID_WIDTH:0] id_arr3 = (push_pos[3]) ? push_id[ID_WIDTH:0] :\n        { (do_clear[3]) ? 1'b0:id_arr3_ff[ID_WIDTH], id_arr3_ff[ID_WIDTH-1:0] };\n\n// Update the registers on the positive edge of the clock\nalways @(posedge Clk) begin\n        id_arr0_ff[ID_WIDTH:0] <= (rst_l) ? id_arr0[ID_WIDTH:0] : 1'b0;\n        id_arr1_ff[ID_WIDTH:0] <= (rst_l) ? id_arr1[ID_WIDTH:0] : 1'b0;\n        id_arr2_ff[ID_WIDTH:0] <= (rst_l) ? id_arr2[ID_WIDTH:0] : 1'b0;\n        id_arr3_ff[ID_WIDTH:0] <= (rst_l) ? id_arr3[ID_WIDTH:0] : 1'b0;\n        push_pos_ff[3:0] <= (rst_l) ? push_pos[3:0] : 4'h0;\n        push_pos_2ff[3:0] <= (rst_l) ? push_pos_ff[3:0] : 4'h0;\n        in_clear_pos_ff[3:0] <= (rst_l) ? in_clear_pos[3:0] : 4'h0;\nend\n\n// Assign the output wires\nassign out_search_hit[3:0] = search_pos[3:0];\nassign out_push_pos[3:0] = push_pos[3:0];\nassign out_free[3:0] = free[3:0];\n\nendmodule",
        "module_name": "axi_traffic_gen_v2_0_7_id_track",
        "module_hash": "701c418c02e834153498b6ce271e9c28",
        "dataset_index": 5024
      },
      "inc_module_dfdadfa4": {
        "rtl_code": "module inc_module(\n    input clk, reset, \n    input [2:0] SW, \n    output reg [3:0] LED\n);\n\nreg [2:0] SW_reg;\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        SW_reg <= 3'b0;\n        LED <= 4'b0;\n    end else begin\n        SW_reg <= SW;\n        LED <= SW_reg + 1;\n    end\nend\n\nendmodule",
        "module_name": "inc_module",
        "module_hash": "dfdadfa4a0ea3d77eb9441cc87afcda3",
        "dataset_index": 11968
      },
      "priority_encoder_fb1e7794": {
        "rtl_code": "module priority_encoder (\n    input [7:0] in,\n    input clk,\n    output reg [2:0] out\n);\n\nreg [7:0] in_reg;\nreg [2:0] out_reg;\n\nalways @(posedge clk) begin\n    in_reg <= in;\nend\n\nalways @(posedge clk) begin\n    casez(in_reg)\n        8'b00000001: out_reg <= 3'b000;\n        8'b00000010: out_reg <= 3'b001;\n        8'b00000100: out_reg <= 3'b010;\n        8'b00001000: out_reg <= 3'b011;\n        8'b00010000: out_reg <= 3'b100;\n        8'b00100000: out_reg <= 3'b101;\n        8'b01000000: out_reg <= 3'b110;\n        8'b10000000: out_reg <= 3'b111;\n        default: out_reg <= out_reg;\n    endcase;\nend\n\nalways @(posedge clk) begin\n    out <= out_reg;\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "fb1e77940c29eae035ad106eadb00463",
        "dataset_index": 10896
      },
      "acc_vadd_hls_6d4769d2": {
        "rtl_code": "\n\n\n\nmodule acc_vadd_hls (\n        ap_clk,\n        ap_rst_n,\n        cmd_TDATA,\n        cmd_TVALID,\n        cmd_TREADY,\n        resp_TDATA,\n        resp_TVALID,\n        resp_TREADY,\n        a_Addr_A,\n        a_EN_A,\n        a_WEN_A,\n        a_Din_A,\n        a_Dout_A,\n        a_Clk_A,\n        a_Rst_A,\n        b_Addr_A,\n        b_EN_A,\n        b_WEN_A,\n        b_Din_A,\n        b_Dout_A,\n        b_Clk_A,\n        b_Rst_A,\n        result_Addr_A,\n        result_EN_A,\n        result_WEN_A,\n        result_Din_A,\n        result_Dout_A,\n        result_Clk_A,\n        result_Rst_A\n);\n\nparameter    ap_const_logic_1 = 1'b1;\nparameter    ap_const_logic_0 = 1'b0;\nparameter    ap_ST_st1_fsm_0 = 3'b000;\nparameter    ap_ST_st2_fsm_1 = 3'b1;\nparameter    ap_ST_st3_fsm_2 = 3'b10;\nparameter    ap_ST_st4_fsm_3 = 3'b11;\nparameter    ap_ST_st5_fsm_4 = 3'b100;\nparameter    ap_const_lv1_0 = 1'b0;\nparameter    ap_const_lv32_1 = 32'b1;\nparameter    ap_const_lv32_2 = 32'b10;\nparameter    ap_const_lv4_0 = 4'b0000;\nparameter    ap_const_lv4_F = 4'b1111;\nparameter    ap_const_lv32_FFFFFFFF = 32'b11111111111111111111111111111111;\nparameter    ap_const_lv32_0 = 32'b00000000000000000000000000000000;\nparameter    ap_true = 1'b1;\n\ninput   ap_clk;\ninput   ap_rst_n;\ninput  [31:0] cmd_TDATA;\ninput   cmd_TVALID;\noutput   cmd_TREADY;\noutput  [31:0] resp_TDATA;\noutput   resp_TVALID;\ninput   resp_TREADY;\noutput  [31:0] a_Addr_A;\noutput   a_EN_A;\noutput  [3:0] a_WEN_A;\noutput  [31:0] a_Din_A;\ninput  [31:0] a_Dout_A;\noutput   a_Clk_A;\noutput   a_Rst_A;\noutput  [31:0] b_Addr_A;\noutput   b_EN_A;\noutput  [3:0] b_WEN_A;\noutput  [31:0] b_Din_A;\ninput  [31:0] b_Dout_A;\noutput   b_Clk_A;\noutput   b_Rst_A;\noutput  [31:0] result_Addr_A;\noutput   result_EN_A;\noutput  [3:0] result_WEN_A;\noutput  [31:0] result_Din_A;\ninput  [31:0] result_Dout_A;\noutput   result_Clk_A;\noutput   result_Rst_A;\n\nreg cmd_TREADY;\nreg resp_TVALID;\nreg a_EN_A;\nreg b_EN_A;\nreg result_EN_A;\nreg[3:0] result_WEN_A;\nwire   [0:0] tmp_fu_111_p2;\nreg   [0:0] tmp_reg_157;\nreg   [2:0] ap_CS_fsm = 3'b000;\nreg   [31:0] end_reg_161;\nwire   [31:0] tmp_1_fu_117_p2;\nreg   [31:0] tmp_1_reg_172;\nwire   [63:0] tmp_3_fu_127_p1;\nreg   [63:0] tmp_3_reg_180;\nwire   [0:0] tmp_2_fu_122_p2;\nwire   [0:0] tmp_6_fu_133_p2;\nreg   [0:0] tmp_6_reg_195;\nwire   [31:0] i_1_fu_151_p2;\nreg    ap_sig_ioackin_resp_TREADY;\nreg   [31:0] i_reg_100;\nreg    ap_reg_ioackin_resp_TREADY = 1'b0;\nwire   [31:0] a_Addr_A_orig;\nwire   [31:0] b_Addr_A_orig;\nwire   [31:0] result_Addr_A_orig;\nwire   [31:0] tmp_4_fu_138_p2;\nreg   [2:0] ap_NS_fsm;\nreg    ap_sig_bdd_96;\n\n\n\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_CS_fsm\n    if (ap_rst_n == 1'b0) begin\n        ap_CS_fsm <= ap_ST_st1_fsm_0;\n    end else begin\n        ap_CS_fsm <= ap_NS_fsm;\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_reg_ioackin_resp_TREADY\n    if (ap_rst_n == 1'b0) begin\n        ap_reg_ioackin_resp_TREADY <= ap_const_logic_0;\n    end else begin\n        if (ap_sig_bdd_96) begin\n            if (~(~(ap_const_lv1_0 == tmp_6_reg_195) & (ap_const_logic_0 == ap_sig_ioackin_resp_TREADY))) begin\n                ap_reg_ioackin_resp_TREADY <= ap_const_logic_0;\n            end else if ((ap_const_logic_1 == resp_TREADY)) begin\n                ap_reg_ioackin_resp_TREADY <= ap_const_logic_1;\n            end\n        end\n    end\nend\n\nalways @(posedge ap_clk)\nbegin\n    if ((~(cmd_TVALID == ap_const_logic_0) & (ap_ST_st3_fsm_2 == ap_CS_fsm) & ~(tmp_reg_157 == ap_const_lv1_0))) begin\n        i_reg_100 <= cmd_TDATA;\n    end else if (((ap_ST_st5_fsm_4 == ap_CS_fsm) & ~(~(ap_const_lv1_0 == tmp_6_reg_195) & (ap_const_logic_0 == ap_sig_ioackin_resp_TREADY)))) begin\n        i_reg_100 <= i_1_fu_151_p2;\n    end\nend\n\nalways @(posedge ap_clk)\nbegin\n    if ((~(cmd_TVALID == ap_const_logic_0) & (ap_ST_st2_fsm_1 == ap_CS_fsm))) begin\n        end_reg_161 <= cmd_TDATA;\n    end\nend\n\nalways @(posedge ap_clk)\nbegin\n    if ((~(cmd_TVALID == ap_const_logic_0) & (ap_ST_st3_fsm_2 == ap_CS_fsm) & ~(tmp_reg_157 == ap_const_lv1_0))) begin\n        tmp_1_reg_172 <= tmp_1_fu_117_p2;\n    end\nend\n\nalways @(posedge ap_clk)\nbegin\n    if ((~(tmp_reg_157 == ap_const_lv1_0) & (ap_ST_st4_fsm_3 == ap_CS_fsm) & ~(ap_const_lv1_0 == tmp_2_fu_122_p2))) begin\n        tmp_3_reg_180 <= tmp_3_fu_127_p1;\n        tmp_6_reg_195 <= tmp_6_fu_133_p2;\n    end\nend\n\nalways @(posedge ap_clk)\nbegin\n    if (((ap_ST_st1_fsm_0 == ap_CS_fsm) & ~(cmd_TVALID == ap_const_logic_0))) begin\n        tmp_reg_157 <= tmp_fu_111_p2;\n    end\nend\n\nalways @ (ap_CS_fsm)\nbegin\n    if ((ap_ST_st4_fsm_3 == ap_CS_fsm)) begin\n        a_EN_A = ap_const_logic_1;\n    end else begin\n        a_EN_A = ap_const_logic_0;\n    end\nend\n\nalways @ (resp_TREADY or ap_reg_ioackin_resp_TREADY)\nbegin\n    if ((ap_const_logic_0 == ap_reg_ioackin_resp_TREADY)) begin\n        ap_sig_ioackin_resp_TREADY = resp_TREADY;\n    end else begin\n        ap_sig_ioackin_resp_TREADY = ap_const_logic_1;\n    end\nend\n\nalways @ (ap_CS_fsm)\nbegin\n    if ((ap_ST_st4_fsm_3 == ap_CS_fsm)) begin\n        b_EN_A = ap_const_logic_1;\n    end else begin\n        b_EN_A = ap_const_logic_0;\n    end\nend\n\nalways @ (cmd_TVALID or ap_CS_fsm)\nbegin\n    if ((((ap_ST_st1_fsm_0 == ap_CS_fsm) & ~(cmd_TVALID == ap_const_logic_0)) | (~(cmd_TVALID == ap_const_logic_0) & (ap_ST_st2_fsm_1 == ap_CS_fsm)) | (~(cmd_TVALID == ap_const_logic_0) & (ap_ST_st3_fsm_2 == ap_CS_fsm)))) begin\n        cmd_TREADY = ap_const_logic_1;\n    end else begin\n        cmd_TREADY = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or tmp_6_reg_195 or ap_reg_ioackin_resp_TREADY)\nbegin\n    if (((ap_ST_st5_fsm_4 == ap_CS_fsm) & ~(ap_const_lv1_0 == tmp_6_reg_195) & (ap_const_logic_0 == ap_reg_ioackin_resp_TREADY))) begin\n        resp_TVALID = ap_const_logic_1;\n    end else begin\n        resp_TVALID = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or tmp_6_reg_195 or ap_sig_ioackin_resp_TREADY)\nbegin\n    if (((ap_ST_st5_fsm_4 == ap_CS_fsm) & ~(~(ap_const_lv1_0 == tmp_6_reg_195) & (ap_const_logic_0 == ap_sig_ioackin_resp_TREADY)))) begin\n        result_EN_A = ap_const_logic_1;\n    end else begin\n        result_EN_A = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or tmp_6_reg_195 or ap_sig_ioackin_resp_TREADY)\nbegin\n    if (((ap_ST_st5_fsm_4 == ap_CS_fsm) & ~(~(ap_const_lv1_0 == tmp_6_reg_195) & (ap_const_logic_0 == ap_sig_ioackin_resp_TREADY)))) begin\n        result_WEN_A = ap_const_lv4_F;\n    end else begin\n        result_WEN_A = ap_const_lv4_0;\n    end\nend\nalways @ (cmd_TVALID or tmp_reg_157 or ap_CS_fsm or tmp_2_fu_122_p2 or tmp_6_reg_195 or ap_sig_ioackin_resp_TREADY)\nbegin\n    case (ap_CS_fsm)\n        ap_ST_st1_fsm_0 : \n        begin\n            if (~(cmd_TVALID == ap_const_logic_0)) begin\n                ap_NS_fsm = ap_ST_st2_fsm_1;\n            end else begin\n                ap_NS_fsm = ap_ST_st1_fsm_0;\n            end\n        end\n        ap_ST_st2_fsm_1 : \n        begin\n            if (~(cmd_TVALID == ap_const_logic_0)) begin\n                ap_NS_fsm = ap_ST_st3_fsm_2;\n            end else begin\n                ap_NS_fsm = ap_ST_st2_fsm_1;\n            end\n        end\n        ap_ST_st3_fsm_2 : \n        begin\n            if (~(cmd_TVALID == ap_const_logic_0)) begin\n                ap_NS_fsm = ap_ST_st4_fsm_3;\n            end else begin\n                ap_NS_fsm = ap_ST_st3_fsm_2;\n            end\n        end\n        ap_ST_st4_fsm_3 : \n        begin\n            if (((tmp_reg_157 == ap_const_lv1_0) | (ap_const_lv1_0 == tmp_2_fu_122_p2))) begin\n                ap_NS_fsm = ap_ST_st1_fsm_0;\n            end else begin\n                ap_NS_fsm = ap_ST_st5_fsm_4;\n            end\n        end\n        ap_ST_st5_fsm_4 : \n        begin\n            if (~(~(ap_const_lv1_0 == tmp_6_reg_195) & (ap_const_logic_0 == ap_sig_ioackin_resp_TREADY))) begin\n                ap_NS_fsm = ap_ST_st4_fsm_3;\n            end else begin\n                ap_NS_fsm = ap_ST_st5_fsm_4;\n            end\n        end\n        default : \n        begin\n            ap_NS_fsm = 'bx;\n        end\n    endcase\nend\n\nassign a_Addr_A = a_Addr_A_orig << ap_const_lv32_2;\nassign a_Addr_A_orig = tmp_3_fu_127_p1;\nassign a_Clk_A = ap_clk;\nassign a_Din_A = ap_const_lv32_0;\nassign a_Rst_A = ap_rst_n;\nassign a_WEN_A = ap_const_lv4_0;\n\nalways @ (ap_CS_fsm or tmp_6_reg_195)\nbegin\n    ap_sig_bdd_96 = ((ap_ST_st5_fsm_4 == ap_CS_fsm) & ~(ap_const_lv1_0 == tmp_6_reg_195));\nend\nassign b_Addr_A = b_Addr_A_orig << ap_const_lv32_2;\nassign b_Addr_A_orig = tmp_3_fu_127_p1;\nassign b_Clk_A = ap_clk;\nassign b_Din_A = ap_const_lv32_0;\nassign b_Rst_A = ap_rst_n;\nassign b_WEN_A = ap_const_lv4_0;\nassign i_1_fu_151_p2 = (i_reg_100 + ap_const_lv32_1);\nassign resp_TDATA = ap_const_lv32_1;\nassign result_Addr_A = result_Addr_A_orig << ap_const_lv32_2;\nassign result_Addr_A_orig = tmp_3_reg_180;\nassign result_Clk_A = ap_clk;\nassign result_Din_A = (tmp_4_fu_138_p2 + a_Dout_A);\nassign result_Rst_A = ap_rst_n;\nassign tmp_1_fu_117_p2 = (end_reg_161 + ap_const_lv32_FFFFFFFF);\nassign tmp_2_fu_122_p2 = ($signed(i_reg_100) < $signed(end_reg_161)? 1'b1: 1'b0);\nassign tmp_3_fu_127_p1 = $signed(i_reg_100);\nassign tmp_4_fu_138_p2 = b_Dout_A << ap_const_lv32_1;\nassign tmp_6_fu_133_p2 = (i_reg_100 == tmp_1_reg_172? 1'b1: 1'b0);\nassign tmp_fu_111_p2 = (cmd_TDATA == ap_const_lv32_1? 1'b1: 1'b0);\n\n\nendmodule ",
        "module_name": "acc_vadd_hls",
        "module_hash": "6d4769d25d423432f94dcbcfc8710ae4",
        "dataset_index": 24203
      },
      "nand4_6ee85bbf": {
        "rtl_code": "\nmodule nand4(Y, A, B, C, D);\n    output Y;\n    input A, B, C, D;\n    wire nand1_out, nand2_out;\n\n    nand2 nand1(nand1_out, A, B);\n    nand2 nand2(nand2_out, C, D);\n    nand2 nand3(Y, nand1_out, nand2_out);\nendmodule\nmodule nand2(Y, A, B);\n    output Y;\n    input A, B;\n\n    assign Y = ~(A & B);\nendmodule",
        "module_name": "nand4",
        "module_hash": "6ee85bbfe4f1cfbdd30b57cf51e5f995",
        "dataset_index": 11892
      },
      "magnitude_comparator_4bit_4a6dd207": {
        "rtl_code": "\nmodule magnitude_comparator_4bit (\n    input [3:0] A, B,\n    output EQ, GT, LT\n);\n\nwire [4:0] sum;\nwire EQ_int, GT_int, LT_int;\n\npipeline_stage1 stage1(\n    .A(A),\n    .B(B),\n    .sum(sum)\n);\n\npipeline_stage2 stage2(\n    .sum(sum),\n    .EQ(EQ_int),\n    .GT(GT_int),\n    .LT(LT_int)\n);\n\nassign EQ = EQ_int;\nassign GT = GT_int;\nassign LT = LT_int;\n\nendmodule\nmodule pipeline_stage1 (\n    input [3:0] A, B,\n    output reg [4:0] sum\n);\n\nwire [3:0] A_xor_B;\nwire [3:0] A_and_B;\n\nassign A_xor_B = A ^ B;\nassign A_and_B = A & B;\n\nalways @(*) begin\n    sum[4] = A[3] ^ B[3];\n    sum[3] = A_and_B[2];\n    sum[2] = A_xor_B[2] ^ A_and_B[1];\n    sum[1] = A_xor_B[1] ^ A_and_B[0];\n    sum[0] = A_xor_B[0];\nend\n\nendmodule\nmodule pipeline_stage2 (\n    input [4:0] sum,\n    output reg EQ, GT, LT\n);\n\nwire [4:0] sum_abs;\n\nassign sum_abs = (sum[4] == 1) ? ~sum + 5'b1 : sum;\n\nalways @(*) begin\n    EQ = (sum_abs == 5'b0) ? 1'b1 : 1'b0;\n    GT = (sum_abs[4] == 1) ? 1'b0 : 1'b1;\n    LT = (sum_abs[4] == 1) ? 1'b1 : 1'b0;\nend\n\nendmodule",
        "module_name": "magnitude_comparator_4bit",
        "module_hash": "4a6dd2076aa4c676444b9e86b5d17527",
        "dataset_index": 20188
      },
      "four_bit_adder_b1a0a48f": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] S;\n    wire C1, C2, C3;\n\n    // Instantiate full adders\n    full_adder FA0 (.A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(C1));\n    full_adder FA1 (.A(A[1]), .B(B[1]), .Cin(C1), .S(S[1]), .Cout(C2));\n    full_adder FA2 (.A(A[2]), .B(B[2]), .Cin(C2), .S(S[2]), .Cout(C3));\n    full_adder FA3 (.A(A[3]), .B(B[3]), .Cin(C3), .S(S[3]), .Cout(Cout));\n\n    // Assign outputs\n    assign Sum = S;\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    wire S1, C1, C2;\n\n    // XOR gate\n    xor (S1, A, B);\n\n    // AND gates\n    and (C1, A, B);\n    and (C2, S1, Cin);\n\n    // OR gate\n    or (Cout, C1, C2);\n\n    // Assign outputs\n    assign S = S1;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "b1a0a48fb8a2fba41539eb156b9e4dfc",
        "dataset_index": 9829
      },
      "adder_tree_top_343ac99e": {
        "rtl_code": "`define ADDER_WIDTH 015\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "343ac99e0a284d2c7374a8cfd7749287",
        "dataset_index": 25066
      },
      "three_input_and_3a97e13e": {
        "rtl_code": "module three_input_and (\n    input a,\n    input b,\n    input c,\n    output out\n);\n\n    wire ab, bc, abc;\n\n    and and1 (ab, a, b);\n    and and2 (bc, b, c);\n    and and3 (abc, ab, c);\n    assign out = abc;\n\nendmodule",
        "module_name": "three_input_and",
        "module_hash": "3a97e13e39ec141aa87f1258e91b9bf3",
        "dataset_index": 7228
      },
      "premuat_8_542fd854": {
        "rtl_code": "module premuat_8(\n            enable,\n           inverse,\n           \n               i_0,\n               i_1,\n               i_2,\n               i_3,\n               i_4,\n               i_5,\n               i_6,\n               i_7,\n               \n               o_0,\n               o_1,\n               o_2,\n               o_3,\n               o_4,\n               o_5,\n               o_6,\n               o_7\n);\n\ninput                enable;\ninput               inverse;\ninput  signed  [27:0]   i_0;\ninput  signed  [27:0]   i_1;\ninput  signed  [27:0]   i_2;\ninput  signed  [27:0]   i_3;\ninput  signed  [27:0]   i_4;\ninput  signed  [27:0]   i_5;\ninput  signed  [27:0]   i_6;\ninput  signed  [27:0]   i_7;\n\n\noutput  signed [27:0]   o_0;\noutput  signed [27:0]   o_1;\noutput  signed [27:0]   o_2;\noutput  signed [27:0]   o_3;\noutput  signed [27:0]   o_4;\noutput  signed [27:0]   o_5;\noutput  signed [27:0]   o_6;\noutput  signed [27:0]   o_7;\n\nreg   signed   [27:0]    o1;\nreg   signed   [27:0]    o2;\nreg   signed   [27:0]    o3;\nreg   signed   [27:0]    o4;\nreg   signed   [27:0]    o5;\nreg   signed   [27:0]    o6;\n\nalways @(*)\nbegin\n    if(inverse)\n    begin\n        o1 = i_2;\n        o2 = i_4;\n        o3 = i_6;\n        o4 = i_1;\n        o5 = i_3;\n        o6 = i_5;\n    end\n    else\n    begin\n        o1 = i_4;\n        o2 = i_1;\n        o3 = i_5;\n        o4 = i_2;\n        o5 = i_6;\n        o6 = i_3;\n    end\nend\n\nassign  o_0=i_0;\nassign  o_1=enable?o1:i_1;\nassign  o_2=enable?o2:i_2;\nassign  o_3=enable?o3:i_3;\nassign  o_4=enable?o4:i_4;\nassign  o_5=enable?o5:i_5;\nassign  o_6=enable?o6:i_6;\nassign  o_7=i_7;\n\nendmodule",
        "module_name": "premuat_8",
        "module_hash": "542fd8545d926a0cb03d6460f5a953b0",
        "dataset_index": 9570
      },
      "half_adder_886254f5": {
        "rtl_code": "\nmodule half_adder (\n    input x_in,\n    input y_in,\n    output wire s_out,\n    output wire c_out\n);\n\nassign s_out = x_in ^ y_in;\nassign c_out = x_in & y_in;\n\nendmodule\nmodule full_adder (\n    input A,\n    input B,\n    input C_in,\n    output reg S,\n    output reg C_out\n);\n\nwire S1, C1, C2;\n\nhalf_adder HA1(.x_in(A), .y_in(B), .s_out(S1), .c_out(C1));\nhalf_adder HA2(.x_in(S1), .y_in(C_in), .s_out(S), .c_out(C2));\n\nalways @(*) begin\n    C_out <= C1 | C2;\nend\n\nendmodule",
        "module_name": "half_adder",
        "module_hash": "886254f5775de32d73aa4a6c6cf7e3d2",
        "dataset_index": 8054
      },
      "top__a60aa1c0": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] a,\n    input [31:0] b,\n    input select,\n    output reg [7:0] high_bit_chunk\n);\n\n    reg [31:0] sum;\n    reg [2:0] high_bit_pos;\n    wire [31:0] adder_out;\n    wire [4:0] priority_enc_out;\n\n    // Instantiate 32-bit adder module\n    adder_32 adder_inst (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .out(adder_out)\n    );\n\n    // Instantiate priority encoder module\n    priority_encoder priority_enc_inst (\n        .in(adder_out),\n        .out(priority_enc_out)\n    );\n\n    // Control logic to select between adder and priority encoder\n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            high_bit_pos <= 0;\n            sum <= 0;\n        end else begin\n            if (select) begin\n                high_bit_pos <= priority_enc_out;\n                sum <= adder_out;\n            end else begin\n                high_bit_pos <= 0;\n                sum <= a + b;\n            end\n        end\n    end\n\n    // Functional module to output high bit chunk\n    always @ (high_bit_pos, sum) begin\n        case (high_bit_pos)\n            0: high_bit_chunk <= sum[7:0];\n            1: high_bit_chunk <= sum[15:8];\n            2: high_bit_chunk <= sum[23:16];\n            3: high_bit_chunk <= sum[31:24];\n            default: high_bit_chunk <= 8'b0;\n        endcase\n    end\n\nendmodule\nmodule adder_32 (\n    input clk,\n    input reset,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n\n    wire [7:0] carry;\n    wire [8:0] sum1;\n    wire [8:0] sum2;\n    wire [8:0] sum3;\n    wire [8:0] sum4;\n\n    // Instantiate 8-bit adders\n    adder_8 adder0 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(1'b0),\n        .sum(sum1)\n    );\n    adder_8 adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(sum1[7]),\n        .sum(sum2)\n    );\n    adder_8 adder2 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .cin(sum2[7]),\n        .sum(sum3)\n    );\n    adder_8 adder3 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .cin(sum3[7]),\n        .sum(sum4)\n    );\n\n    // Final 8-bit adder to combine results\n    assign out = sum4[7:0];\n\nendmodule\nmodule adder_8 (\n    input [7:0] a,\n    input [7:0] b,\n    input cin,\n    output [8:0] sum\n);\n\n    assign sum = a + b + cin;\n\nendmodule\nmodule priority_encoder (\n    input [31:0] in,\n    output reg [4:0] out\n);\n\n    always @ (in) begin\n        case (in)\n            32'hFFFFFFFF: out = 4'b1111;\n            32'h7FFFFFFF: out = 4'b1110;\n            32'h3FFFFFFF: out = 4'b1101;\n            32'h1FFFFFFF: out = 4'b1100;\n            32'h0FFFFFFF: out = 4'b1011;\n            32'h07FFFFFF: out = 4'b1010;\n            32'h03FFFFFF: out = 4'b1001;\n            32'h01FFFFFF: out = 4'b1000;\n            32'h00FFFFFF: out = 4'b0111;\n            32'h007FFFFF: out = 4'b0110;\n            32'h003FFFFF: out = 4'b0101;\n            32'h001FFFFF: out = 4'b0100;\n            32'h000FFFFF: out = 4'b0011;\n            32'h0007FFFF: out = 4'b0010;\n            32'h0003FFFF: out = 4'b0001;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "a60aa1c0cab4964ae9fc20dce158fd5e",
        "dataset_index": 8590
      },
      "lifo_top_9436a98d": {
        "rtl_code": "\n\n`define POP\t\t\t\t2'b01\n`define PUSH\t\t\t2'b10\n`define DO_NOTHING\t2'b00\n`define INVALID\t\t2'b11\n\n`define DATA_VALID\t1'b1\n`define DATA_INVALID\t1'b0\n\n`define LIFO_FULL\t\t\t1'b1\n`define LIFO_NOT_FULL\t1'b0\n\n`define LIFO_EMPTY\t\t1'b1\n`define LIFO_NOT_EMPTY\t1'b0\n\n`define LOG2(width) \t(width<=2)?1:\\\n\t\t\t\t\t\t\t(width<=4)?2:\\\n\t\t\t\t\t\t\t(width<=8)?3:\\\n\t\t\t\t\t\t\t(width<=16)?4:\\\n\t\t\t\t\t\t\t(width<=32)?5:\\\n\t\t\t\t\t\t\t(width<=64)?6:\\\n\t\t\t\t\t\t\t(width<=128)?7:\\\n\t\t\t\t\t\t\t(width<=256)?8:\\\n\t\t\t\t\t\t\t-1\t\t\t\t\nmodule lifo_top(\n\tdata_out, empty_flag, full_flag,\n\tvector_in, reset,\n\tclk\n   );\nparameter DATA_WIDTH = 4;\nparameter NUM_ENTRIES = 4;\nparameter OPCODE_WIDTH = 2;\nparameter LINE_WIDTH = DATA_WIDTH+OPCODE_WIDTH; parameter INITIAL_VALUE = 'b0; \nparameter NUM_ENTRIES_BIT = `LOG2(NUM_ENTRIES); \n\noutput reg [DATA_WIDTH-1:0]data_out;\noutput reg empty_flag;\noutput reg full_flag;\ninput [OPCODE_WIDTH+DATA_WIDTH-1:0]vector_in;\ninput reset;\ninput clk;\n\nreg [DATA_WIDTH-1:0]lifo_data[NUM_ENTRIES-1:0];\nreg [NUM_ENTRIES-1:0]lifo_valid_invalid_bit;\n\nreg [OPCODE_WIDTH-1:0]control_in;\treg [DATA_WIDTH-1:0]data_in;\t\t\treg [NUM_ENTRIES_BIT-1:0]lifo_head_pos;\nreg [NUM_ENTRIES_BIT-1:0]lifo_tail_pos;\n\nreg [NUM_ENTRIES_BIT-1:0]loop_variable;\n\nalways@(posedge clk)\nbegin\t\n\tif(reset)\n\tbegin\n\t\tdata_out = INITIAL_VALUE;\n\t\tlifo_head_pos = INITIAL_VALUE;\n\t\tlifo_tail_pos = INITIAL_VALUE;\n\t\tloop_variable = INITIAL_VALUE;\n\t\tcontrol_in = INITIAL_VALUE;\n\t\tdata_in = INITIAL_VALUE;\n\t\tlifo_valid_invalid_bit = INITIAL_VALUE;\n\t\tempty_flag = `LIFO_NOT_EMPTY;\n\t\tfull_flag = `LIFO_NOT_FULL;\n\tend else\n\t\tbegin\n\t\t\tif(lifo_head_pos == INITIAL_VALUE && lifo_tail_pos == INITIAL_VALUE)\n\t\t\tbegin\t\t\t\t\n\t\t\t\tempty_flag = `LIFO_EMPTY;\n\t\t\t\tfull_flag = `LIFO_NOT_FULL;\n\t\t\tend else\n\t\t\t\tbegin\n\t\t\t\t\tif(lifo_head_pos == NUM_ENTRIES-1 && lifo_tail_pos == NUM_ENTRIES-1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tempty_flag = `LIFO_NOT_EMPTY;\n\t\t\t\t\t\tfull_flag = `LIFO_FULL;\t\t\t\t\t\n\t\t\t\t\tend else\n\t\t\t\t\t\tbegin\nempty_flag = `LIFO_EMPTY;\n\t\t\t\t\t\t\tfull_flag = `LIFO_NOT_FULL;\n\t\t\t\t\t\tend\n\t\t\t\tend\ncontrol_in = vector_in[LINE_WIDTH-1:LINE_WIDTH-OPCODE_WIDTH];\t\n\t\tdata_in = vector_in[LINE_WIDTH-OPCODE_WIDTH-1:LINE_WIDTH-OPCODE_WIDTH-DATA_WIDTH];\ncase(control_in)\t\t\t\n\t\t\t`POP: \n\t\t\t\tbegin\nif(lifo_valid_invalid_bit[lifo_tail_pos] == `DATA_VALID)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tdata_out = lifo_data[lifo_tail_pos];\n\t\t\t\t\t\tlifo_valid_invalid_bit[lifo_tail_pos] = `DATA_INVALID;\n\t\t\t\t\t\tif(lifo_tail_pos == INITIAL_VALUE)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tlifo_tail_pos = INITIAL_VALUE;\n\t\t\t\t\t\t\tlifo_head_pos = lifo_head_pos - 1'b1;\t\t\t\t\t\t\t\n\t\t\t\t\t\tend else \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(empty_flag == `LIFO_NOT_EMPTY && full_flag == `LIFO_FULL)\n\t\t\t\t\t\t\t\t\tlifo_tail_pos = lifo_tail_pos - 1'b1;\n\t\t\t\t\t\t\t\telse begin\t\n\t\t\t\t\t\t\t\t\tlifo_tail_pos = lifo_tail_pos - 1'b1;\n\t\t\t\t\t\t\t\t\tlifo_head_pos = lifo_head_pos - 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\t\t\n\t\t\t\t\tend else\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdata_out = 'bx;\n\t\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t`PUSH: \n\t\t\t\tbegin\nif(empty_flag == `LIFO_EMPTY && full_flag == `LIFO_NOT_FULL)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tlifo_data[lifo_head_pos] = data_in;\n\t\t\t\t\t\tlifo_valid_invalid_bit[lifo_head_pos] = `DATA_VALID;\n\t\t\t\t\t\tif(lifo_head_pos == NUM_ENTRIES-1)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tlifo_tail_pos = lifo_tail_pos + 1'b1;;\n\t\t\t\t\t\t\tlifo_head_pos = NUM_ENTRIES-1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tlifo_tail_pos = lifo_head_pos;\n\t\t\t\t\t\t\tlifo_head_pos = lifo_head_pos + 1'b1;\n\t\t\t\t\t\tend \n\t\t\t\t\tend \nend\ndefault: data_out = 'bx;\n\t\tendcase\t\t\t\t\n\tend\nend\t\t\nendmodule\n",
        "module_name": "lifo_top",
        "module_hash": "9436a98ddf866a05a04650de4893f449",
        "dataset_index": 14693
      },
      "combinational_logic_7522abf7": {
        "rtl_code": "\nmodule combinational_logic (\n    input [2:0] vec,\n    output reg out1,\n    output reg out2,\n    output reg out3\n);\n\nalways @(*) begin\n    out1 = vec[0];\n    out2 = vec[1];\n    out3 = vec[2];\nend\n\nendmodule\n\nmodule shift_register (\n    input clk,\n    input serial_in,\n    output reg serial_out\n);\n\nreg [2:0] shift_reg;\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[1:0], serial_in};\n    serial_out = shift_reg[2];\nend\n\nendmodule\n\nmodule functional_module (\n    input in1,\n    input in2,\n    input in3,\n    input serial_out,\n    output [3:0] final_output\n);\n\nassign final_output = {in1, in2, in3, serial_out};\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [2:0] vec,\n    input serial_in,\n    output [3:0] final_output\n);\n\nwire out1, out2, out3, serial_out;\n\ncombinational_logic comb(.vec(vec), .out1(out1), .out2(out2), .out3(out3));\nshift_register shift_reg(.clk(clk), .serial_in(serial_in), .serial_out(serial_out));\nfunctional_module func(.in1(out1), .in2(out2), .in3(out3), .serial_out(serial_out), .final_output(final_output));\n\nendmodule\n",
        "module_name": "combinational_logic",
        "module_hash": "7522abf70a82709769bd6e560058fc05",
        "dataset_index": 3674
      },
      "flipflop_preset_clear_4934d7b9": {
        "rtl_code": "\nmodule flipflop_preset_clear(\n    input CLK,\n    input D,\n    input PRE,\n    input CLR,\n    output Q,\n    output Q_bar\n);\n\nreg Q;\n\nalways @ (posedge CLK) begin\n    if (PRE) begin\n        Q <= 1'b1;\n    end else if (CLR) begin\n        Q <= 1'b0;\n    end else begin\n        Q <= D;\n    end\nend\n\nassign Q_bar = ~Q;\n\nendmodule\n",
        "module_name": "flipflop_preset_clear",
        "module_hash": "4934d7b93551b2de214efeb9b3042890",
        "dataset_index": 17564
      },
      "vga_sync_generator_8f3a2675": {
        "rtl_code": "module vga_sync_generator(\n  input clk,\n  output vga_h_sync,\n  output vga_v_sync,\n  output inDisplayArea,\n  output reg [10:0] CounterX,\n  output reg [10:0] CounterY\n);\n\n  // VGA display parameters\n  parameter WIDTH = 800;\n  parameter HEIGHT = 600;\n  parameter COUNT_DOTS = 1056;\n  parameter COUNT_LINES = 625;\n  \n  parameter H_FRONT_PORCH = 16;\n  parameter H_SYNC_PULSE = 80;\n  parameter H_BACK_PORCH = 160;\n  \n  parameter V_FRONT_PORCH = 1;\n  parameter V_SYNC_PULSE = 3;\n  parameter V_BACK_PORCH = 21;\n  \n  // Horizontal and vertical sync signals\n  reg vga_HS, vga_VS;\n  \n  // Counter max values\n  wire CounterXmaxed = (CounterX == COUNT_DOTS);\n  wire CounterYmaxed = (CounterY == COUNT_LINES);\n  \n  // Increment counters\n  always @(posedge clk) begin\n    if (CounterXmaxed) begin\n      CounterX <= 0;\n      if (CounterYmaxed)\n        CounterY <= 0;\n      else\n        CounterY <= CounterY + 1;\n    end\n    else\n      CounterX <= CounterX + 1;\n  end\n  \n  // Generate sync signals\n  always @(posedge clk) begin\n    vga_HS <= (CounterX >= (WIDTH + H_FRONT_PORCH) && CounterX < (WIDTH + H_FRONT_PORCH + H_SYNC_PULSE)); \n    vga_VS <= (CounterY >= (HEIGHT + V_FRONT_PORCH) && CounterY < (HEIGHT + V_FRONT_PORCH + V_SYNC_PULSE)); \n  end\n  \n  // Determine if in visible area\n  assign inDisplayArea = (CounterX < WIDTH && CounterY < HEIGHT) ? 1'b1 : 1'b0;\n  \n  // Output sync signals\n  assign vga_h_sync = vga_HS;\n  assign vga_v_sync = vga_VS;\n  \nendmodule",
        "module_name": "vga_sync_generator",
        "module_hash": "8f3a2675f94a4c07732ca9ab1ffa5ef0",
        "dataset_index": 7223
      },
      "blockmem2r1wptr_632963af": {
        "rtl_code": "module blockmem2r1wptr(\n                       input wire           clk,\n                       input wire           reset_n,\n\n                       input wire  [07 : 0] read_addr0,\n                       output wire [31 : 0] read_data0,\n\n                       output wire [31 : 0] read_data1,\n\n                       input wire           rst,\n                       input wire           cs,\n                       input wire           wr,\n                       input wire  [31 : 0] write_data\n                      );\n\n\n  reg [31 : 0] mem [0 : 255];\n  reg [31 : 0] tmp_read_data0;\n  reg [31 : 0] tmp_read_data1;\n\n  reg [7 : 0] ptr_reg;\n  reg [7 : 0] ptr_new;\n  reg         ptr_we;\n\n\n  assign read_data0 = tmp_read_data0;\n  assign read_data1 = tmp_read_data1;\n\n\n  always @ (posedge clk)\n    begin : mem_update\n      if (wr)\n        mem[ptr_reg] <= write_data;\n\n      tmp_read_data0 <= mem[read_addr0];\n      tmp_read_data1 <= mem[ptr_reg];\n    end\n\n\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_mem_update\n      if (!reset_n)\n        ptr_reg <= 8'h00;\n\n      else\n        if (ptr_we)\n          ptr_reg <= ptr_new;\n    end\n\n\n  always @*\n    begin : ptr_logic\n      ptr_new = 8'h00;\n      ptr_we  = 1'b0;\n\n      if (rst)\n        begin\n          ptr_new = 8'h00;\n          ptr_we  = 1'b1;\n        end\n\n      if (cs)\n        begin\n          ptr_new = ptr_reg + 1'b1;\n          ptr_we  = 1'b1;\n        end\n    end\n\nendmodule ",
        "module_name": "blockmem2r1wptr",
        "module_hash": "632963af14b7f327040be294b49fa958",
        "dataset_index": 24272
      },
      "counter_b6a86236": {
        "rtl_code": "module counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "b6a86236f8fa3e1c4c96f8010d0240b6",
        "dataset_index": 17534
      },
      "shift_register_1f82f382": {
        "rtl_code": "module shift_register (\n    input clk,\n    input serial_in,\n    input reset,\n    output reg [3:0] parallel_out\n);\n\nreg [3:0] pipeline [0:2];\n\nalways @(posedge clk) begin\n    pipeline[0] <= serial_in;\n    pipeline[1] <= pipeline[0];\n    pipeline[2] <= pipeline[1];\nend\n\nalways @(negedge clk) begin\n    if (!reset) begin\n        parallel_out <= 4'b0;\n    end else begin\n        parallel_out <= pipeline[2];\n    end\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "1f82f382fe662dc2aed25ee3d3bb1b19",
        "dataset_index": 2072
      },
      "SDCard_bcbb59ed": {
        "rtl_code": "module SDCard(\ninput\t\twire\t\t\tclk_i,\t\t\tinput\t\twire\t\t\tcpuclk_n_i,\t\tinput\t\twire\t\t\treset_n_i,\t\tinput\t\twire\t\t\tcs_i,\t\t\t\tinput\t\twire\t\t\tadr_i,         input\t\twire\t\t\trw_n_i,\t\t\toutput\treg\t\t\thalt_o,\t\t\t\tinput\t\twire\t[7:0]\tdat_i,\t\t\toutput\twire\t[7:0]\tdat_o,\n\toutput\twire\t\t\tirq_n_o,\t\t\toutput\twire\t\t\tact_led_n_o,\n\tinput\t\twire\t\t\tcard_detect_n_i,\tinput\t\twire\t\t\twp_locked_i,\t\toutput\treg\t\t\tspi_ss_n_o,\t\toutput\treg\t\t\tsclk_o,\t\t\toutput\treg\t\t\tmosi_o,\t\t\tinput\t\twire\t\t\tmiso_i\t\t\t);\n\nreg\t\t\t\t\t\t\ten_spi;\nreg\t\t\t\t\t[2:0]\tstate;\nreg\t\t\t\t\t[3:0]\tbcnt;\nreg\t\t\t\t\t\t\twffull;\nreg\t\t\t\t\t[1:0]\twffull_buf;\nreg\t\t\t\t\t[7:0]\trreg1;\nreg\t\t\t\t\t[7:0]\tbuffer1;\nreg\t\t\t\t\t\t\twffull_reset;\nreg\t\t\t\t\t[2:0]\tcd_buff0;\nreg\t\t\t\t\t\t\tirq_n;\nreg\t\t\t\t\t\t\ten_irq;\nwire\t\t\t\t\t\t\tirq_reset_n;\nreg\t\t\t\t\t\t\thalt_buf0;\nreg\t\t\t\t\t\t\thalt_buf1;\nreg\t\t\t\t\t[1:0]\thalt_state;\n\nassign dat_o = (!adr_i)\t?\t{!irq_n, 5'b00000, wp_locked_i, !card_detect_n_i}:\trreg1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassign irq_reset_n =\t~reset_n_i\t\t\t\t\t\t\t?\t1'b0:\t\t\t\t\t\t\t~en_spi\t\t\t\t\t\t\t\t?\t1'b0:\t\t\t\t\t\t\t~en_irq\t\t\t\t\t\t\t\t?\t1'b0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1'b1;\n\nassign irq_n_o = \t\t\tirq_n;\n\nassign act_led_n_o = state[0];\n\nalways @(negedge cpuclk_n_i or posedge wffull_reset)\nbegin\n\tif(wffull_reset)\n\t\twffull <= 1'b0;\n\telse\n\t\tif({cs_i, adr_i} == 2'b11)\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\twffull <= 1'b1;\n\t\tend\nend\n\nalways @(negedge cpuclk_n_i or negedge reset_n_i)\nbegin\n\tif(!reset_n_i)\n\tbegin\n\t\thalt_buf0 <= 1'b0; \n\t\thalt_buf1 <= 1'b0;\n\t\thalt_state <= 2'b00;\n\t\thalt_o <= 1'b0;\n\tend\n\telse\n\tbegin\n\t\thalt_buf0 <= !state[0];\t\t\thalt_buf1 <= halt_buf0;\n\t\tcase(halt_state)\n\t\t2'b00:\n\t\tbegin\n\t\t\tif({cs_i, adr_i, en_spi}== 3'b111)\t\tbegin\n\t\t\t\thalt_o <= 1'b1;\t\t\t\thalt_state <= 2'b01;\n\t\t\tend\n\t\tend\n\t\t2'b01:\n\t\tbegin\n\t\t\tif(halt_buf1)\t\t\t\t\t\thalt_state <= 2'b10;\n\t\tend\n\t\t2'b10:\n\t\tbegin\n\t\t\tif(!halt_buf1)\t\t\t\t\t\tbegin\n\t\t\t\thalt_state <= 2'b00;\n\t\t\t\thalt_o <= 1'b0;\t\t\t\tend\n\t\tend\n\t\t2'b11:\t\t\t\t\t\t\t\t\tbegin\n\t\t\thalt_state <= 2'b00;\n\t\tend\n\t\tendcase\n\tend\nend\n\nalways @(negedge cpuclk_n_i or negedge reset_n_i)\nbegin\n\tif(!reset_n_i)\n\tbegin\n\t\tspi_ss_n_o <= 1'b1;\n\t\ten_irq <= 1'b0;\n\t\ten_spi <= 1'b0;\n\t\tbuffer1 <= 8'hFF;\n\tend\n\telse\n\tbegin\n\t\tcase ({cs_i, rw_n_i, adr_i})\n\t\t3'b100:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tspi_ss_n_o <= !dat_i[0]|!dat_i[7];\t\t\t\t\t\t\t\ten_irq <= dat_i[6];\n\t\t\ten_spi <= dat_i[7];\n\t\tend\n\t\t3'b101:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tbuffer1 <= dat_i;\n\t\tend\n\t\t3'b111:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffer1 <= 8'hFF;\n\t\tend\n\t\tendcase\n\tend\nend\n\nalways @(negedge cpuclk_n_i)\nbegin\n\tif(!irq_reset_n)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\tirq_n <= 1'b1;\n\t\tcd_buff0 <= 3'b000;\n\tend\n\telse\n\tbegin\n\t\tcd_buff0 <= ({cd_buff0[1], cd_buff0[0], card_detect_n_i});\t\t\tif(cd_buff0 == 3'b100)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tirq_n <= 1'b0;\n\tend\nend\n\nalways @(posedge clk_i)\nbegin\n\tif (~en_spi)\n\tbegin\n\t\tstate <= 3'b001; \t\t\t\tbcnt  <= 4'h0;\n\t\tsclk_o <= 1'b0;\n\t\twffull_buf <= 2'b00;\n\t\twffull_reset <= 1'b1;\t\trreg1 <= 8'h00;\n\tend\n\telse\n\tbegin\n\t\twffull_buf <= {wffull_buf[0], wffull};\n\t\tcase (state)\n\t\t3'b001:\t\t\t\t\t\t\t\tbegin\n\t\t\tsclk_o <= 1'b0;\t\t\t\twffull_reset <= 1'b0;\n\t\t\tif (wffull_buf[1])\n\t\t\tbegin\n\t\t\t\tbcnt  <= 4'h0;\t\t\t\trreg1 <= buffer1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\tend\n\t\t3'b010:\t\t\t\t\t\t\t\tbegin\n\t\t\tsclk_o   <= 1'b0;\n\t\t\twffull_reset <= 1'b1;\n\t\t\tstate   <= 3'b100;\n\t\t\tif (bcnt[3])\n\t\t\tbegin\n\t\t\t\tstate <= 3'b001;\n\t\t\t\twffull_reset <= 1'b0;\n\t\t\t\tmosi_o <= 1'b1;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate <= 3'b100;\n\t\t\t\twffull_reset <= 1'b1;\n\t\t\t\tmosi_o <= rreg1[7];\n\t\t\tend\n\t\tend\n\n\t\t3'b100:\t\t\t\t\t\t\t\tbegin\n\t\t\tstate <= 3'b010;\n\t\t\tsclk_o <= 1'b1;\n\t\t\trreg1 <= {rreg1[6:0], miso_i};\n\t\t\tbcnt <= bcnt + 4'h1;\n\t\tend\n\t\tdefault:\n\t\tbegin\n\t\t\tstate <= 3'b001;\n\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule\n",
        "module_name": "SDCard",
        "module_hash": "bcbb59ed5640310ccbb694da41311744",
        "dataset_index": 22256
      },
      "my__5b53f1c0": {
        "rtl_code": "module my_module (\n    output X   ,\n    input  A1  ,\n    input  A2  \n);\n\n\n\n    // Local signals\n    wire and0_out_X       ;\n\n    //                                 Name         Output             Other arguments\n    and                                and0        (and0_out_X       , A1, A2                );\n    buf                                buf0        (X                , and0_out_X     );\n\nendmodule",
        "module_name": "my_",
        "module_hash": "5b53f1c0813ca1211936534c7cd57d54",
        "dataset_index": 5523
      },
      "sky130_fd_sc_hdll__nor2b_bb238ab9": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__nor2b (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    wire not0_out  ;\n    wire and0_out_Y;\n\n    not not0 (not0_out  , A              );\n    and and0 (and0_out_Y, not0_out, B_N  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__nor2b",
        "module_hash": "bb238ab944ebe7d27511c81400a6a4b5",
        "dataset_index": 12699
      },
      "mux4to1_d0454cd3": {
        "rtl_code": "module mux4to1 (\n    input [3:0] D0, D1, D2, D3,\n    input [1:0] S0, S1,\n    output [3:0] Y\n);\n\n    assign Y = (S1 & S0) ? D3 :\n               (S1 & ~S0) ? D2 :\n               (~S1 & S0) ? D1 :\n               (~S1 & ~S0) ? D0 : 4'bX;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "d0454cd3a728f7038b086cea38143c48",
        "dataset_index": 1457
      },
      "update_TAGRAM_50e91679": {
        "rtl_code": "\nmodule update_TAGRAM (\n   input clk_in,\n   input srst,\n   input [7:0] tx_length_dw,\n   input [7:0] tx_tag,\n   input tx_ack0,\n   input [7:0] tx_fmt_type,\n   input [7:0] rx_length_dw_byte,\n   input [7:0] rx_tag,\n   input rx_ack_reg,\n   input [7:0] rx_fmt_type,\n   output reg [7:0] tagram_data_a,\n   output reg [7:0] tagram_address_a,\n   output reg tagram_wren_a,\n   output reg [7:0] tagram_data_b,\n   output reg tagram_wren_b,\n   output reg [7:0] tagram_address_b,\n   output reg [4:0] read_tagram\n);\n\n   // TAGRAM port A\n   always @ (posedge clk_in) begin\n      tagram_address_a <= tx_tag;\n      tagram_data_a <= tx_length_dw;\n      tagram_wren_a <= ((tx_ack0==1'b1) &&\n                           (tx_fmt_type[4:0]==5'b00000) &&\n                           (tx_fmt_type[6]==1'b0)) ? 1'b1 : 1'b0;\n   end\n\n   // TAGRAM port B\n   always @ (posedge clk_in) begin\n      if (srst == 1'b1)\n         tagram_address_b <= 8'b0;\n      else if (rx_ack_reg == 1'b1) begin\n         tagram_address_b <= rx_tag;\n         tagram_data_b <= rx_length_dw_byte;\n         tagram_wren_b <= 1'b1;\n      end\n      else\n         tagram_wren_b <= 1'b0;\n   end\n\n   always @ (posedge clk_in) begin\n      if (srst == 1'b1)\n         read_tagram[0] <= 1'b0;\n      else if ((rx_length_dw_byte >= 8'h0) &&\n                 (rx_fmt_type[6:1] == 6'b100101) && (rx_ack_reg == 1'b1))\n         read_tagram[0] <= 1'b1;\n      else\n         read_tagram[0] <= 1'b0;\n   end\n\n   always @ (posedge clk_in) begin\n      read_tagram[1] <= read_tagram[0];\n      read_tagram[2] <= read_tagram[1];\n      read_tagram[3] <= read_tagram[2];\n      read_tagram[4] <= read_tagram[3];\n   end\n\nendmodule",
        "module_name": "update_TAGRAM",
        "module_hash": "50e916797616cfd53c8badd25087d5e5",
        "dataset_index": 10191
      },
      "four_to_one_b496d77f": {
        "rtl_code": "module four_to_one(\n    input in1,\n    input in2,\n    input in3,\n    input in4,\n    output out\n);\n\n    assign out = (in1 || in2 || in3) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "four_to_one",
        "module_hash": "b496d77f05968b8b18bbfaba35be3cf9",
        "dataset_index": 2313
      },
      "mux_2to1_9d5b2436": {
        "rtl_code": "module mux_2to1 (\n    input sel,\n    input in0,\n    input in1,\n    output reg out\n);\n\nalways @ (sel or in0 or in1)\nbegin\n    if (sel == 0)\n        out = in0;\n    else\n        out = in1;\nend\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "9d5b2436d35d320b7d2f0e6f10d9bd68",
        "dataset_index": 3648
      },
      "d_ff_async_reset_sync_set_c332f9bb": {
        "rtl_code": "\nmodule d_ff_async_reset_sync_set (\n  input D,\n  input C,\n  input R,\n  input E,\n  output Q\n);\n\n  reg Q_next;\n\n  always @ (posedge C or negedge E) begin\n    if (!E) begin\n      Q_next <= Q_next;\n    end else if (R) begin\n      Q_next <= 1'b0;\n    end else begin\n      Q_next <= D;\n    end\n  end\n\n  assign Q = Q_next;\n\nendmodule",
        "module_name": "d_ff_async_reset_sync_set",
        "module_hash": "c332f9bb06683ed3f96ce716efe4f5a6",
        "dataset_index": 15272
      },
      "ControlUnit_f00553b6": {
        "rtl_code": "\n\nmodule ControlUnit (clk,OPCODE,BOpCode,Zero,BSelector,MemRD,MemWD,RegWrite,RegSelector,PCSelect,Enable1,Enable2,Enable3,Enable4);\n\tinput wire clk;\n\tinput [4:0] OPCODE;\n\tinput [0:0] Zero;\n\tinput [4:0] BOpCode;\n\t\n\toutput reg[0:0] BSelector;\n\toutput reg[0:0] MemRD;\n\toutput reg[0:0] MemWD;\n\toutput reg[0:0] RegWrite;\n\toutput reg[1:0] RegSelector;\n\toutput reg[0:0] PCSelect;\n\toutput reg[0:0] Enable1;\n\toutput reg[0:0] Enable2;\n\toutput reg[0:0] Enable3;\n\toutput reg[0:0] Enable4;\n\t\n\tparameter ADD = 5'd0;\n   parameter SUB = 5'd1;\n   parameter ADDI  = 5'd2;\n\tparameter SUBI = 5'd3;\n\tparameter MLT = 5'd4;\n   parameter MLTI = 5'd5;\n   parameter AND = 5'd6;\n\tparameter OR = 5'd7;\n\tparameter ANDI = 5'd8;\n\tparameter ORI = 5'd9;\n\tparameter SLR = 5'd10;\n\tparameter SLL = 5'd11;\n\tparameter LDR = 5'd12;\n\tparameter STR = 5'd13;\n\tparameter BNE = 5'd14;\n\tparameter BEQ = 5'd15;\n\tparameter J = 5'd16;\n\tparameter CMP = 5'd17;\n\tparameter NOP = 5'b11111;\n\t\n\t\n\tinitial begin\n\t\tBSelector = 1'd0;\n\t\tPCSelect= 1'd0;\n\t\tMemRD = 1'd0;\n\t\tMemWD = 1'd0;\n\t\tRegWrite = 1'd0;\n\t\tRegSelector = 2'd0;\n\t\tEnable1 = 1'd1;\n\t\tEnable2 = 1'd1;\n\t\tEnable3 = 1'd1;\n\t\tEnable4 = 1'd1;\n\tend\n\t\n\t\n\t\n\talways @ (posedge clk) begin\n\t\tcase(OPCODE)\n\t\t\tADD:\n\t\t\t\tbegin \n\t\t\t\t\tBSelector = 1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend\n\t\t\tSUB:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector =2'd0 ;\n\t\t\t\tend\n\t\t\tADDI:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tSUBI:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tMLT:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend\n\t\t\tMLTI:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tAND:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend\n\t\t\tOR:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend\n\t\t\tANDI:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tORI:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tSLR:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector =2'd1;\n\t\t\t\tend\n\t\t\tSLL:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector = 1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tLDR:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd1;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd2;\n\t\t\t\tend\n\t\t\tSTR:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd1;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd1;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd2;\n\t\t\t\tend\n\t\t\tBNE:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd0;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tBEQ:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd0;\n\t\t\t\t\tRegSelector = 2'd1;\n\t\t\t\tend\n\t\t\tJ:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd0;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend\n\t\t\tCMP:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector =1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD =1'd0 ;\n\t\t\t\t\tRegWrite = 1'd1;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend\n\t\t\tNOP:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector = 1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd0;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend\n\t\t\tdefault:\n\t\t\t\tbegin\n\t\t\t\t\tBSelector = 1'd0;\n\t\t\t\t\tMemRD = 1'd0;\n\t\t\t\t\tMemWD = 1'd0;\n\t\t\t\t\tRegWrite = 1'd0;\n\t\t\t\t\tRegSelector = 2'd0;\n\t\t\t\tend \n\t\tendcase\n\tend\n\t\n\talways @ (Zero,BOpCode) begin\n\t   if (BOpCode==BNE && !Zero) PCSelect=1'd1; \n        else if (BOpCode==BEQ && Zero) PCSelect=1'd1;\n        else PCSelect=1'd0;\n    end\n    \n\nendmodule",
        "module_name": "ControlUnit",
        "module_hash": "f00553b65ffec106b912cbe4bfd3e816",
        "dataset_index": 5346
      },
      "sky130_fd_sc_lp__a32o_0392d2ab": {
        "rtl_code": "module sky130_fd_sc_lp__a32o (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input B2,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    assign X = (A1 & ~A2 & ~A3 & ~B1 & ~B2 & ~VPWR & ~VGND & ~VPB & ~VNB);\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a32o",
        "module_hash": "0392d2abef1e4a6290347873a6bfbb55",
        "dataset_index": 18551
      },
      "counter_9ad2aa8e": {
        "rtl_code": "module counter (\n    input clk,\n    input rst,\n    input [31:0] max_val,\n    output reg [31:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end else if (count == max_val) begin\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "9ad2aa8e2e37bf0b53e99a4eeee57b59",
        "dataset_index": 19079
      },
      "TrafficLightController_19c5d14d": {
        "rtl_code": "module TrafficLightController (\n    input clk,\n    input rst,\n    output reg [1:0] state\n);\n\nlocalparam GREEN_TIME = 20;\nlocalparam YELLOW_TIME = 5;\nlocalparam RED_TIME = 15;\n\nreg [5:0] counter;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        state <= 2'b01; // Green state\n    end else begin\n        counter <= counter + 1;\n        case (state)\n            2'b01: // Green state\n                if (counter >= GREEN_TIME) begin\n                    state <= 2'b10; // Yellow state\n                    counter <= 0;\n                end\n            2'b10: // Yellow state\n                if (counter >= YELLOW_TIME) begin\n                    state <= 2'b11; // Red state\n                    counter <= 0;\n                end\n            2'b11: // Red state\n                if (counter >= RED_TIME) begin\n                    state <= 2'b01; // Green state\n                    counter <= 0;\n                end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "TrafficLightController",
        "module_hash": "19c5d14dfba3fe64d3aee0fe28b7e7a0",
        "dataset_index": 8275
      },
      "sky130_fd_sc_ms__a21o_c1009077": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__a21o (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A1, A2         );\n    or  or0  (or0_out_X, and0_out, B1   );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__a21o",
        "module_hash": "c1009077ef82ee9e9b670252b0c52294",
        "dataset_index": 23459
      },
      "combined__ade1d822": {
        "rtl_code": "module combined_module (\n    input up_down,\n    input load,\n    input shift,\n    input clk,\n    input reset,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\n    reg [15:0] counter;\n    reg [15:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 16'd0;\n            shift_reg <= 16'd0;\n        end else if (load) begin\n            counter <= data_in;\n            shift_reg <= data_in;\n        end else if (shift) begin\n            counter <= up_down ? counter + 1 : counter - 1;\n            shift_reg <= {shift_reg[14:0], counter};\n        end\n    end\n\n    assign data_out = shift_reg;\n\nendmodule",
        "module_name": "combined_",
        "module_hash": "ade1d822be7e764ef05e4bf264a006ed",
        "dataset_index": 11389
      },
      "uart_rx_521d6331": {
        "rtl_code": "module uart_rx(\n    input clk,\n    input rst,\n    input rxd,\n    output [7:0] data_rx,\n    output busy\n);\n\nreg [8:0] rxdata;\nassign data_rx[7:0] = rxdata[8:1];\n\nreg busy_reg;\nassign busy = busy_reg;\n\nreg [9:0] bitTmr;\nreg [3:0] bitIndex;\nreg rxState;\n\nreg [9:0] bitCnt_0;\nreg [9:0] bitCnt_1;\n\nalways@(posedge clk) begin\n    if(rst)\n        begin\n            rxState  <= 1'b0;\n            busy_reg <= 1'b0;\n        end\n    else\n        begin\n            case(rxState)\n                1'b0 :\n                    begin\n                        bitIndex <= 4'd0;\n                        bitTmr   <= 10'd0;\n                        bitCnt_0 <= 10'd0;\n                        bitCnt_1 <= 10'd0;\n                        if( rxd == 1'b0 )\n                            begin\n                                rxState <= 1'b1;\n                            end\n                        else\n                            rxState <= 1'b0;\n                    end\n\n                1'b1 :\n                    begin\n                        if (bitTmr == 10'd7)\n                            begin\n                                bitTmr   <= 10'd0;\n                                bitCnt_0 <= 10'd0;\n                                bitCnt_1 <= 10'd0;\n                                rxdata[bitIndex] <= rxd;\n                                if (bitIndex == 4'd7)\n                                    begin\n                                        // done!\n                                        busy_reg <= 1'b0;\n                                        rxState <= 1'b0;\n                                    end\n                                else\n                                    begin\n                                        busy_reg <= 1'b1;\n                                        bitIndex <= bitIndex + 1'b1;\n                                        rxState <= 1'b1;\n                                    end\n                            end\n                        else\n                            begin\n                                bitTmr <= bitTmr + 1'b1;\n                                if(rxd == 1'b0)\n                                    bitCnt_0 <= bitCnt_0 + 1'b1;\n                                else\n                                    bitCnt_1 <= bitCnt_1 + 1'b1;\n                                if( bitCnt_0 > bitCnt_1 )\n                                    rxdata[bitIndex] <= 1'b0;\n                                else\n                                    rxdata[bitIndex] <= 1'b1;\n                                rxState <= 1'b1;\n                            end\n                    end\n                default :\n                    begin\n                        rxState  <= 1'b0;\n                        busy_reg <= 1'b0;\n                    end\n            endcase\n        end\nend\n\nendmodule",
        "module_name": "uart_rx",
        "module_hash": "521d633144ddbb05ea9383df1f767e86",
        "dataset_index": 6948
      },
      "sky130_fd_sc_lp__invlp_15dba04b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__invlp (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__invlp",
        "module_hash": "15dba04b13bc16d05fe7b5915c4b9786",
        "dataset_index": 1837
      },
      "control_unit_8a0fc9dc": {
        "rtl_code": "\nmodule control_unit(pcsource,wpcir,op,func,rs,rt,mrn,mm2reg,mwreg,ern,em2reg,ewreg,wreg,m2reg,wmem,jal,daluc,aluimm,shift,rsrtequ,regrt,sext,fwdb,fwda);\n\tinput wire [5:0] op,func;\n\tinput wire [4:0] rs,rt,mrn,ern;\n\tinput wire mm2reg,mwreg,em2reg,ewreg,rsrtequ;\n\toutput wire wpcir,wreg,m2reg,wmem,jal,aluimm,shift,regrt,sext;\n\toutput wire [3:0] daluc;\n\toutput wire [1:0] pcsource,fwda,fwdb;\n\twire r,i_and,i_or,i_xor,i_add,i_sub,i_addi,i_andi,i_ori,i_xori,i_lw,i_sw,i_beq,i_bne,i_sll,i_srl,i_sra,i_jr,i_j,i_jal,i_lui,i_rs,i_rt;\n\tassign r=~op[5]&~op[4]&~op[3]&~op[2]&~op[1]&~op[0];\n\tassign i_and=r&func[5]&~func[4]&~func[3]&func[2]&~func[1]&~func[0];\n\tassign i_or=r&func[5]&~func[4]&~func[3]&func[2]&~func[1]&func[0];\n\tassign i_xor=r&func[5]&~func[4]&~func[3]&func[2]&func[1]&~func[0];\n\tassign i_add=r&func[5]&~func[4]&~func[3]&~func[2]&~func[1]&~func[0];\n\tassign i_sub=r&func[5]&~func[4]&~func[3]&~func[2]&func[1]&~func[0];\n\tassign i_sll=r&~func[5]&~func[4]&~func[3]&~func[2]&~func[1]&~func[0];\n\tassign i_srl=r&~func[5]&~func[4]&~func[3]&~func[2]&func[1]&~func[0];\n\tassign i_sra=r&~func[5]&~func[4]&~func[3]&~func[2]&func[1]&func[0];\n\tassign i_jr=r&~func[5]&~func[4]&func[3]&~func[2]&~func[1]&~func[0];\n\tassign i_j=~op[5]&~op[4]&~op[3]&~op[2]&op[1]&~op[0];\n\tassign i_jal=~op[5]&~op[4]&~op[3]&~op[2]&op[1]&op[0];\n\tassign i_addi=~op[5]&~op[4]&op[3]&~op[2]&~op[1]&~op[0];\n\tassign i_andi=~op[5]&~op[4]&op[3]&op[2]&~op[1]&~op[0];\n\tassign i_ori=~op[5]&~op[4]&op[3]&op[2]&~op[1]&op[0];\n\tassign i_xori=~op[5]&~op[4]&op[3]&op[2]&op[1]&~op[0];\n\tassign i_lw=op[5]&~op[4]&~op[3]&~op[2]&op[1]&op[0];\n\tassign i_sw=op[5]&~op[4]&op[3]&~op[2]&op[1]&op[0];\n\tassign i_beq=~op[5]&~op[4]&~op[3]&op[2]&~op[1]&~op[0];\n\tassign i_bne=~op[5]&~op[4]&~op[3]&op[2]&~op[1]&op[0];\n\tassign i_lui=~op[5]&~op[4]&op[3]&op[2]&op[1]&op[0];\n\tassign i_rs=i_add|i_sub|i_and|i_or|i_xor|i_jr|i_addi|i_andi|i_ori|i_xori|i_lw|i_sw|i_beq|i_bne;\n\tassign i_rt=i_add|i_sub|i_and|i_or|i_xor|i_sll|i_srl|i_sra|i_sw|i_beq|i_bne;\n\tassign daluc[3]=i_sra;\n\tassign daluc[2]=i_sub|i_beq|i_bne|i_or|i_ori|i_lui|i_srl|i_sra;\n\tassign daluc[1]=i_xor|i_xori|i_lui|i_sll|i_srl|i_sra;\n\tassign daluc[0]=i_and|i_andi|i_or|i_ori|i_sll|i_srl|i_sra;\n\tassign wpcir=~(ewreg&em2reg&(ern!=0)&(i_rs&(ern==rs)|i_rt&(ern==rt)));\n\tassign wreg=(i_add|i_sub|i_and|i_or|i_xor|i_sll|i_srl|i_sra|i_addi|i_andi|i_ori|i_xori|i_lw|i_lui|i_jal)&wpcir;\n\tassign wmem=i_sw&wpcir;\n\tassign m2reg=i_lw;\n\tassign jal=i_jal;\n\tassign aluimm=i_addi|i_andi|i_ori|i_xori|i_lui|i_sw|i_lw;\n\tassign shift=i_sll|i_srl|i_sra;\n\tassign regrt=i_lui|i_addi|i_andi|i_ori|i_xori|i_lw;\n\tassign sext=i_lui|i_addi|i_lw|i_sw|i_beq|i_bne;\n\tassign fwda=(ewreg&(ern!=0)&(ern==rs)&~em2reg)?2'b01:((mwreg&(mrn!=0)&(mrn==rs)&~mm2reg)?2'b10:((mwreg&(mrn!=0)&(mrn==rs)&mm2reg)?2'b11:2'b00));\n\tassign fwdb=(ewreg&(ern!=0)&(ern==rt)&~em2reg)?2'b01:((mwreg&(mrn!=0)&(mrn==rt)&~mm2reg)?2'b10:((mwreg&(mrn!=0)&(mrn==rt)&mm2reg)?2'b11:2'b00));\n\tassign pcsource[1]=i_j|i_jr|i_jal;\n\tassign pcsource[0]=(i_beq&rsrtequ)|(i_bne&~rsrtequ)|i_j|i_jal;\nendmodule\n\n",
        "module_name": "control_unit",
        "module_hash": "8a0fc9dc77bbba465caf82da5ee52d0b",
        "dataset_index": 24857
      },
      "alt_mem_ddrx_mm_st_converter #_87315e76": {
        "rtl_code": "\n\nmodule alt_mem_ddrx_mm_st_converter # (\n    parameter\n        AVL_SIZE_WIDTH     = 3,\n        AVL_ADDR_WIDTH     = 25,\n        AVL_DATA_WIDTH     = 32,\n        LOCAL_ID_WIDTH     = 8,\n        CFG_DWIDTH_RATIO   = 4,\n        CFG_MM_ST_CONV_REG = 0\n    )\n    (\n        \n        ctl_clk, ctl_reset_n, ctl_half_clk, ctl_half_clk_reset_n, avl_ready, avl_read_req, avl_write_req, avl_size, avl_burstbegin, avl_addr, avl_rdata_valid, avl_rdata, avl_wdata, avl_be, local_rdata_error, local_multicast, local_autopch_req, local_priority, itf_cmd_ready,\n        itf_cmd_valid,\n        itf_cmd,\n        itf_cmd_address,\n        itf_cmd_burstlen,\n        itf_cmd_id,\n        itf_cmd_priority,\n        itf_cmd_autopercharge,\n        itf_cmd_multicast,\n    \n        itf_wr_data_ready,\n        itf_wr_data_valid,\n        itf_wr_data,\n        itf_wr_data_byte_en,\n        itf_wr_data_begin,\n        itf_wr_data_last,\n        itf_wr_data_id,\n        \n        itf_rd_data_ready,\n        itf_rd_data_valid,\n        itf_rd_data,\n        itf_rd_data_error,\n        itf_rd_data_begin,\n        itf_rd_data_last,\n        itf_rd_data_id\n);\n    localparam AVL_BE_WIDTH = AVL_DATA_WIDTH / 8;\n    \n    input ctl_clk;\n    input ctl_reset_n;\n    \n    input ctl_half_clk;\n    input ctl_half_clk_reset_n;\n    \n    output                      avl_ready;\n    input                       avl_read_req;\n    input                       avl_write_req;\n    input  [AVL_SIZE_WIDTH-1:0] avl_size;\n    input                       avl_burstbegin;\n    input  [AVL_ADDR_WIDTH-1:0] avl_addr;\n    output                      avl_rdata_valid;\n    output [3:0]                local_rdata_error;\n    output [AVL_DATA_WIDTH-1:0] avl_rdata;\n    input  [AVL_DATA_WIDTH-1:0] avl_wdata;\n    input  [AVL_BE_WIDTH-1:0]   avl_be;\n    \n    input local_multicast;\n    input local_autopch_req;\n    input local_priority;\n    \n    input                       itf_cmd_ready;\n    output                      itf_cmd_valid;\n    output                      itf_cmd;\n    output [AVL_ADDR_WIDTH-1:0] itf_cmd_address;\n    output [AVL_SIZE_WIDTH-1:0] itf_cmd_burstlen;\n    output [LOCAL_ID_WIDTH-1:0] itf_cmd_id;\n    output                      itf_cmd_priority;\n    output                      itf_cmd_autopercharge;\n    output                      itf_cmd_multicast;\n    \n    input                       itf_wr_data_ready;\n    output                      itf_wr_data_valid;\n    output [AVL_DATA_WIDTH-1:0] itf_wr_data;\n    output [AVL_BE_WIDTH-1:0]   itf_wr_data_byte_en;\n    output                      itf_wr_data_begin;\n    output                      itf_wr_data_last;\n    output [LOCAL_ID_WIDTH-1:0] itf_wr_data_id;\n    \n    output                     itf_rd_data_ready;\n    input                      itf_rd_data_valid;\n    input [AVL_DATA_WIDTH-1:0] itf_rd_data;\n    input                      itf_rd_data_error;\n    input                      itf_rd_data_begin;\n    input                      itf_rd_data_last;\n    input [LOCAL_ID_WIDTH-1:0] itf_rd_data_id;\n    \n    reg   [AVL_SIZE_WIDTH-1:0] burst_count;\n    \n    wire                       int_ready;\n    wire                       itf_cmd; wire                       itf_wr_if_ready;\n    wire  [LOCAL_ID_WIDTH-1:0] itf_cmd_id;\n    wire                       itf_wr_data_begin;\n    wire                       itf_wr_data_last;\n    wire  [LOCAL_ID_WIDTH-1:0] itf_wr_data_id;\n    reg                        data_pass;\n    reg   [AVL_SIZE_WIDTH-1:0] burst_counter;\n    \n    reg                          avl_read_req_reg;\n    reg                          avl_write_req_reg;\n    reg   [AVL_SIZE_WIDTH-1:0]   avl_size_reg;\n    reg   [AVL_ADDR_WIDTH-1:0]   avl_addr_reg;\n    reg   [AVL_DATA_WIDTH-1:0]   avl_wdata_reg;\n    reg   [AVL_DATA_WIDTH/8-1:0] avl_be_reg;\n    \n    reg                          itf_rd_data_valid_reg;\n    reg   [AVL_DATA_WIDTH-1:0]   itf_rd_data_reg;\n    reg   [3:0]                  itf_rd_data_error_reg;\n    \n    reg                          local_multicast_reg;\n    reg                          local_autopch_req_reg;\n    reg                          local_priority_reg;\n    \n    generate\n        if (CFG_MM_ST_CONV_REG == 1)\n        begin\n            always @ (posedge ctl_clk or negedge ctl_reset_n)\n            begin\n                if (!ctl_reset_n)\n                begin\n                    avl_read_req_reg            <= 1'b0;\n                    avl_write_req_reg           <= 1'b0;\n                    avl_size_reg                <= {AVL_SIZE_WIDTH{1'b0}};\n                    avl_addr_reg                <= {AVL_ADDR_WIDTH{1'b0}};\n                    avl_wdata_reg               <= {AVL_DATA_WIDTH{1'b0}};\n                    avl_be_reg                  <= {AVL_BE_WIDTH{1'b0}};\n                    itf_rd_data_valid_reg       <= 1'b0;\n                    itf_rd_data_reg             <= {AVL_DATA_WIDTH{1'b0}};\n                    itf_rd_data_error_reg       <= 4'b0;\n                    local_multicast_reg         <= 1'b0;\n                    local_autopch_req_reg       <= 1'b0;\n                    local_priority_reg          <= 1'b0;\n                end else\n                begin\n                    if (int_ready)\n                    begin\n                        avl_read_req_reg        <= avl_read_req;\n                        avl_write_req_reg       <= avl_write_req;\n                        avl_size_reg            <= avl_size;\n                        avl_addr_reg            <= avl_addr;\n                        avl_wdata_reg           <= avl_wdata;\n                        avl_be_reg              <= avl_be;\n                        local_multicast_reg     <= local_multicast;\n                        local_autopch_req_reg   <= local_autopch_req;\n                        local_priority_reg      <= local_priority;\n                    end\n                        itf_rd_data_valid_reg   <= itf_rd_data_valid;\n                        itf_rd_data_reg         <= itf_rd_data;\n                        itf_rd_data_error_reg   <= itf_rd_data_error;\n                end\n            end\n        end else \n        begin\n            always @ (*)\n            begin\n                avl_read_req_reg            = avl_read_req;\n                avl_write_req_reg           = avl_write_req;\n                avl_size_reg                = avl_size;\n                avl_addr_reg                = avl_addr;\n                avl_wdata_reg               = avl_wdata;\n                avl_be_reg                  = avl_be;\n                itf_rd_data_valid_reg       = itf_rd_data_valid;\n                itf_rd_data_reg             = itf_rd_data;\n                itf_rd_data_error_reg       = {4{itf_rd_data_error}};\n                local_multicast_reg         = local_multicast;\n                local_autopch_req_reg       = local_autopch_req;\n                local_priority_reg          = local_priority;\n            end\n        end\n    endgenerate\n    \n    assign itf_cmd_valid = avl_read_req_reg | itf_wr_if_ready;\n\n    assign itf_wr_if_ready = itf_wr_data_ready & avl_write_req_reg & ~data_pass;\n    \n    assign avl_ready = int_ready;\n    assign itf_rd_data_ready = 1'b1;\n    assign itf_cmd_address = avl_addr_reg ;\n    assign itf_cmd_burstlen = avl_size_reg ;\n    assign itf_cmd_autopercharge = local_autopch_req_reg ;\n    assign itf_cmd_priority = local_priority_reg ;\n    assign itf_cmd_multicast = local_multicast_reg ;\n    assign itf_cmd = avl_write_req_reg;\n\n    assign itf_cmd_id = {LOCAL_ID_WIDTH{1'b0}};\n    assign itf_wr_data_begin = 1'b0;\n    assign itf_wr_data_last = 1'b0;\n    assign itf_wr_data_id = {LOCAL_ID_WIDTH{1'b0}};\n    \n    assign itf_wr_data_valid = (data_pass) ? avl_write_req_reg : itf_cmd_ready & avl_write_req_reg;\n    assign itf_wr_data = avl_wdata_reg ;\n    assign itf_wr_data_byte_en = avl_be_reg ;\n             \n    assign avl_rdata_valid = itf_rd_data_valid_reg;\n    assign avl_rdata =  itf_rd_data_reg;\n    assign local_rdata_error = itf_rd_data_error_reg;\n    \n    assign int_ready = (data_pass) ? itf_wr_data_ready : ((itf_cmd) ? (itf_wr_data_ready & itf_cmd_ready) : itf_cmd_ready);\n    \n    always @(posedge ctl_clk, negedge ctl_reset_n)\n        begin\n            if (!ctl_reset_n)\n                burst_counter  <=  {AVL_SIZE_WIDTH{1'b0}};\n            else\n                begin\n                    if (itf_wr_if_ready && avl_size_reg > 1 && itf_cmd_ready)\n                        burst_counter   <=  avl_size_reg - 1'b1;\n                    else if (avl_write_req_reg && itf_wr_data_ready)\n                        burst_counter   <=  burst_counter - 1'b1;\n                end\n        end\n    \n    always @(posedge ctl_clk, negedge ctl_reset_n)\n        begin\n            if (!ctl_reset_n)\n                data_pass  <=  1'b0;\n            else\n                begin\n                    if (itf_wr_if_ready && avl_size_reg > 1 && itf_cmd_ready)\n                        data_pass  <=  1'b1;\n                    else if (burst_counter == 1 && avl_write_req_reg && itf_wr_data_ready)\n                        data_pass  <=  1'b0;\n                end\n        end\n        \nendmodule\n",
        "module_name": "alt_mem_ddrx_mm_st_converter #",
        "module_hash": "87315e761870fcae1ff01e5f0a7e4b57",
        "dataset_index": 23852
      },
      "barrel_shifter_fa3fde8d": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [3:0] data,\n    input [1:0] shift,\n    output reg [3:0] q,\n    input clk\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @(*) begin\n    case(shift)\n        2'b00: stage1_out = data;\n        2'b01: stage1_out = {data[0], data[3:1]};\n        2'b10: stage1_out = {data[1:0], data[3:2]};\n        2'b11: stage1_out = {data[2:0], data[3]};\n    endcase\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\n    q <= stage2_out;\nend\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "fa3fde8dfa3b56cc4805f563e07eb535",
        "dataset_index": 19665
      },
      "d_ff_async_reset_26d88d43": {
        "rtl_code": "module d_ff_async_reset (\n    input D,\n    input RESET_B,\n    input CLK,\n    output Q,\n    output Q_N\n);\n\n    reg q;\n    assign Q = q;\n    assign Q_N = ~q;\n\n    always @(posedge CLK or negedge RESET_B) begin\n        if (~RESET_B) begin\n            q <= 0;\n        end else begin\n            q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "d_ff_async_reset",
        "module_hash": "26d88d437375f1f6206855d731296f8c",
        "dataset_index": 5131
      },
      "blockmem2rptr1w_3e7b1c12": {
        "rtl_code": "module blockmem2rptr1w(\n                       input wire           clk,\n                       input wire           reset_n,\n\n                       input wire  [07 : 0] read_addr0,\n                       output wire [31 : 0] read_data0,\n\n                       output wire [31 : 0] read_data1,\n\n                       input wire           rst,\n                       input wire           cs,\n                       input wire           wr,\n                       input wire  [07 : 0] write_addr,\n                       input wire  [31 : 0] write_data\n                      );\n\n\n  //----------------------------------------------------------------\n  // Memories and regs including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] mem [0 : 255];\n  reg [31 : 0] tmp_read_data0;\n  reg [31 : 0] tmp_read_data1;\n\n  reg [7 : 0] ptr_reg;\n  reg [7 : 0] ptr_new;\n  reg         ptr_we;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign read_data0 = tmp_read_data0;\n  assign read_data1 = mem[ptr_reg];\n\n\n  //----------------------------------------------------------------\n  // mem_update\n  //\n  // Clocked update of memory This should cause\n  // the memory to be implemented as a block memory.\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : mem_update\n      if (wr)\n        mem[write_addr] <= write_data;\n\n      tmp_read_data0 <= mem[read_addr0];\n    end\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_mem_update\n      if (!reset_n)\n        ptr_reg <= 8'h00;\n\n      else\n        if (ptr_we)\n          ptr_reg <= ptr_new;\n    end\n\n\n  //----------------------------------------------------------------\n  // ptr_logic\n  //----------------------------------------------------------------\n  always @*\n    begin : ptr_logic\n      ptr_new = 8'h00;\n      ptr_we  = 1'b0;\n\n      if (rst)\n        begin\n          ptr_new = 8'h00;\n          ptr_we  = 1'b1;\n        end\n\n      if (cs)\n        begin\n          ptr_new = ptr_reg + 1'b1;\n          ptr_we  = 1'b1;\n        end\n    end\n\nendmodule",
        "module_name": "blockmem2rptr1w",
        "module_hash": "3e7b1c12ef454b05e2cb3fcbc48d5736",
        "dataset_index": 13624
      },
      "switch_reader_6c3746b1": {
        "rtl_code": "module switch_reader (\n  input clk,\n  input reset_n,\n  input [3:0] switches,\n  output reg [3:0] data_out\n);\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      data_out <= 0;\n    end else begin\n      data_out <= switches;\n    end\n  end\n\nendmodule",
        "module_name": "switch_reader",
        "module_hash": "6c3746b1191fe78c57b87e60e01d43ab",
        "dataset_index": 14755
      },
      "top_module_fb638a91": {
        "rtl_code": "module top_module( \n    input [2:0] a,\n    input [2:0] b,\n    input c,\n    input control,\n    input select,\n    output [2:0] out_and_bitwise,\n    output out_and_logical,\n    output [2:0] out_xor,\n    output [5:0] out_not,\n    output [3:0] out_mux\n);\n\n    // Binary logic module\n    wire [2:0] and_bitwise = a & b;\n    wire and_logical = (a != 0) && (b != 0);\n    wire [2:0] xor_result = a ^ b;\n    assign out_and_bitwise = and_bitwise;\n    assign out_and_logical = and_logical;\n    assign out_xor = xor_result;\n\n    // Inverse of a and b\n    wire [2:0] not_a = ~a;\n    wire [2:0] not_b = ~b;\n    assign out_not = {not_a[2], not_a[1], not_a[0], not_b[2], not_b[1], not_b[0]};\n\n    // Multiplexer\n    wire [2:0] mux_input;\n    assign mux_input = (select == 0) ? a : ((select == 1) ? b : xor_result);\n    assign out_mux = mux_input;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "fb638a914848789e250090f8f5a800a6",
        "dataset_index": 7307
      },
      "half_adder_7be799ae": {
        "rtl_code": "module half_adder(\n    input a,\n    input b,\n    output sum,\n    output carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    wire sum1, carry1, sum2, carry2;\n\n    half_adder ha1(.a(A), .b(B), .sum(sum1), .carry(carry1));\n    half_adder ha2(.a(sum1), .b(Cin), .sum(sum2), .carry(carry2));\n\n    assign S = sum2;\n    assign Cout = carry1 | carry2;\n\nendmodule",
        "module_name": "half_adder",
        "module_hash": "7be799ae687ea3f2221378b0b531c575",
        "dataset_index": 7922
      },
      "modulo_operator_98ca4ce8": {
        "rtl_code": "module modulo_operator (\n  input [31:0] dividend,\n  input [31:0] divisor,\n  output reg [31:0] remainder\n);\n\nalways @(*) begin\n  if (divisor == 0) begin\n    remainder = 0;\n  end else begin\n    remainder = dividend % divisor;\n  end\nend\n\nendmodule",
        "module_name": "modulo_operator",
        "module_hash": "98ca4ce878487bc1b6b12b9a01df3266",
        "dataset_index": 17849
      },
      "expand_key_type_B_256_0f9d001d": {
        "rtl_code": "\nmodule expand_key_type_B_256 (in, out_1, out_2);\n\n    input      [255:0] in;\n    output reg [255:0] out_1;\n    output     [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, k6, k7,\n                       v5, v6, v7, k8;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a, k6a, k7a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b;\n\n    assign {k0, k1, k2, k3, k4, k5, k6, k7} = in;\n\n    assign v5 = k4 ^ k5;\n    assign v6 = v5 ^ k6;\n    assign v7 = v6 ^ k7;\n\n    always @ (*)\n        {k0a, k1a, k2a, k3a, k4a, k5a, k6a, k7a} <= {k0, k1, k2, k3, k4, v5, v6, v7};\n\n    S4 S4_0 (.in(k3), .out(k8));\n\n    assign {k0b, k1b, k2b, k3b} = {k0a, k1a, k2a, k3a};\n    assign k4b = k4a ^ k8;\n    assign k5b = k5a ^ k8;\n    assign k6b = k6a ^ k8;\n    assign k7b = k7a ^ k8;\n\n    always @ (*)\n        out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b};\n\n    assign out_2 = {k4b, k5b, k6b, k7b};\n\nendmodule\n\nmodule S4 (in, out);\n\n    input  [31:0] in;\n    output [31:0] out;\n\n    assign out = in ^ (in << 11) ^ (in << 22);\n\nendmodule\n",
        "module_name": "expand_key_type_B_256",
        "module_hash": "0f9d001dea0db5bf786d15eb9ebb6630",
        "dataset_index": 21039
      },
      "and_pg_7898ee1b": {
        "rtl_code": "module and_pg (\n    A   ,\n    B   ,\n    PG  \n);\n\n    // Module ports\n    input  A   ;\n    input  B   ;\n    output PG  ;\n\n    // Local signals\n    wire  and_out        ;\n\n    //                                 Name         Output             Other arguments\n    and                                and0        (and_out          , A, B    );\n    buf                                buf0       (PG               , and_out         );\n\nendmodule",
        "module_name": "and_pg",
        "module_hash": "7898ee1b141ac5173b0a63bf4f052fc8",
        "dataset_index": 18965
      },
      "memory_block_94cf39a9": {
        "rtl_code": "module memory_block(\n    input clk_a,\n    input clk_b,\n    input en_a,\n    input en_b,\n    input [3:0] addr_a,\n    input [3:0] addr_b,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    input we_a,\n    input we_b,\n    output reg [3:0] data_out_a,\n    output reg [3:0] data_out_b\n);\n\n    reg [3:0] mem_a [0:3];\n    reg [3:0] mem_b [0:3];\n\n    always @(posedge clk_a) begin\n        if (en_a) begin\n            if (we_a) begin\n                mem_a[addr_a] <= data_a;\n            end\n            data_out_a <= mem_a[addr_a];\n        end\n    end\n\n    always @(posedge clk_b) begin\n        if (en_b) begin\n            if (we_b) begin\n                mem_b[addr_b] <= data_b;\n            end\n            data_out_b <= mem_b[addr_b];\n        end\n    end\n\nendmodule",
        "module_name": "memory_block",
        "module_hash": "94cf39a9037feef8aa37a076b1e5f9a3",
        "dataset_index": 6629
      },
      "alu_4bit_1b1ce074": {
        "rtl_code": "\nmodule alu_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] OP,\n    output reg [3:0] result\n);\n\nreg [3:0] alu_out1;\nreg [3:0] alu_out2;\n\nalways @(*) begin\n    case(OP)\n        3'b000: alu_out1 = A + B; // addition\n        3'b001: alu_out1 = A - B; // subtraction\n        3'b010: alu_out1 = A & B; // bitwise AND\n        3'b011: alu_out1 = A | B; // bitwise OR\n        3'b100: alu_out1 = A ^ B; // bitwise XOR\n        3'b101: alu_out1 = {A[2:0], 1'b0}; // arithmetic shift left\n        default: alu_out1 = 4'b0; // default case\n    endcase\nend\n\nalways @(*) begin\n    alu_out2 = alu_out1;\n    result = alu_out2;\nend\n\nendmodule\n",
        "module_name": "alu_4bit",
        "module_hash": "1b1ce074acd7a4007b97c92a71eb84a3",
        "dataset_index": 17278
      },
      "bluetooth_receiver_27b2a8c1": {
        "rtl_code": "module bluetooth_receiver (\n  input clk,\n  input reset,\n  input [15:0] rx_in,\n  output reg [7:0] data_out\n);\n\n  reg [15:0] demodulated_data;\n  reg [7:0] decoded_data;\n  reg [3:0] bit_counter;\n  reg [15:0] carrier_signal;\n\n  // Bluetooth demodulation\n  always @ (posedge clk) begin\n    if (reset) begin\n      demodulated_data <= 16'b0000000000000000;\n      carrier_signal <= 16'b0000000000000000;\n    end else begin\n      if (rx_in[15] != carrier_signal[15]) begin\n        demodulated_data <= {demodulated_data[14:0], rx_in[15]};\n      end\n      carrier_signal <= {carrier_signal[14:0], rx_in[15]};\n    end\n  end\n\n  // Bluetooth decoding scheme\n  always @ (posedge clk) begin\n    if (reset) begin\n      decoded_data <= 8'b00000000;\n      bit_counter <= 4'd0;\n    end else begin\n      if (bit_counter == 4'd3) begin\n        decoded_data <= {demodulated_data[6], demodulated_data[5], demodulated_data[4], demodulated_data[3], demodulated_data[2], demodulated_data[1], demodulated_data[0]};\n        bit_counter <= 4'd0;\n      end else begin\n        bit_counter <= bit_counter + 1;\n      end\n    end\n  end\n\n  // Output data\n  always @ (posedge clk) begin\n    if (reset) begin\n      data_out <= 8'b00000000;\n    end else begin\n      data_out <= decoded_data;\n    end\n  end\n\nendmodule",
        "module_name": "bluetooth_receiver",
        "module_hash": "27b2a8c10217da0ecdfb91495c689329",
        "dataset_index": 13559
      },
      "prbs_gen_6861f53b": {
        "rtl_code": "`define GLBL\n\nmodule prbs_gen (\ninput\t\tck,\ninput\t\trst,\n\ninput\t\ti_req,\n\noutput\t      \to_rdy,\noutput\t      \to_vld,\noutput [63:0]\to_res_lower,\noutput [63:0]\to_res_upper\n);\n   \n   reg \t\tr_init_active;\n   reg [6:0]\tr_init_cnt;\n   reg \t\tr_init_done;\n   always @(posedge ck) begin\n      if (rst) begin\n\t r_init_active <= 1'b0;\n\t r_init_done   <= 1'b0;\n      end\n\n      else if (r_init_cnt == 7'h7f) begin\n\t r_init_active <= 1'b0;\n\t r_init_done   <= 1'b1;\n      end\n\n      else begin\n\t r_init_active <= 1'b1;\n\t r_init_done   <= 1'b0;\n      end\n   end\n   \n   always @(posedge ck) begin\n      if (rst) begin\n\t r_init_cnt <= 7'b0;\n      end\n\n      else if (r_init_active && r_init_cnt != 7'h7f) begin\n\t r_init_cnt <= r_init_cnt + 1;\n      end\n\n      else begin\n\t r_init_cnt <= r_init_cnt;\n      end\n   end\n\n   reg \t[127:0]\tr_seed;\n   always @(posedge ck) begin\n      if (rst) begin\n\t r_seed <= 128'h0123456789ABCDEFFEDCBA9876543210;\n      end\n\n      else if (r_init_active) begin\n\t r_seed <= {r_seed[126:0], r_seed[127]};\n      end\n\n      else begin\n\t r_seed <= r_seed;\n      end\n   end\n\n   assign o_rdy = r_init_done;\n   \n   wire\t[127:0]\tr_vld, r_res;\n   genvar i;\n   generate for (i=0; i<128; i=i+1) begin : g0\n\n      wire \t  init_vld = r_init_active && (r_init_cnt == i);\n      \n      prbs_lfsr_tx prbs_lfsr_tx (\n\t\t\t\t .ck(ck),\n\t\t\t\t .i_init(init_vld),\n\t\t\t\t .i_init_clk(r_init_active),\n\t\t\t\t .i_seed(r_seed[127:96]),\n\t\t\t\t .i_req(i_req),\n\t\t\t\t .o_vld(r_vld[i]),\n\t\t\t\t .o_res(r_res[i])\n\t\t\t\t );\n\n   end endgenerate\n\n   assign o_vld = r_vld[0];\n\n   assign o_res_lower = r_res[63:0];\n   assign o_res_upper = r_res[127:64];\n   \nendmodule\n\n\nmodule prbs_lfsr_tx (\ninput\t\tck,\ninput\t\ti_init,\ninput\t\ti_init_clk,\ninput [31:0]\ti_seed,\n\ninput\t\ti_req,\noutput\t      \to_vld,\noutput \t\to_res\n);\n\n   reg \t[31:0]\tr_lfsr;\n   wire         c_xor_in = r_lfsr[31] ^ r_lfsr[21] ^ r_lfsr[1] ^ r_lfsr[0];\n   always @(posedge ck) begin\n      if (i_init) begin\n\t r_lfsr <= i_seed;\n      end\n\n      else if (i_req | i_init_clk) begin\n\t r_lfsr <= {r_lfsr[30:0], c_xor_in};\n      end\n\n      else begin\n\t r_lfsr <= r_lfsr;\n      end\n   end\n\n\n   reg \t\tr_t2_vld;\n   reg  \tr_t2_res;\n   always @(posedge ck) begin\n      r_t2_vld <= i_req;\n      r_t2_res <= r_lfsr[31];\n   end\n\n   assign o_vld = r_t2_vld;\n   assign o_res = r_t2_res;\n\nendmodule",
        "module_name": "prbs_gen",
        "module_hash": "6861f53b0f16764325ebe38b4cc8486a",
        "dataset_index": 23827
      },
      "fsm_example_5ab4738b": {
        "rtl_code": "module fsm_example (\n    input clk,           // Clock input\n    input rst_n,         // Active low reset\n    input next_state,    // Input to trigger the next state\n    output reg [1:0] state_out // Output representing the current state\n);\n\n// State encoding\nlocalparam S0 = 2'b00,\n           S1 = 2'b01,\n           S2 = 2'b10,\n           S3 = 2'b11;\n\n// Internal state register\nreg [1:0] current_state, next_state_reg;\n\n// State transition logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        current_state <= S0; // Reset to state S0\n    end else begin\n        current_state <= next_state_reg; // Move to the next state\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state_reg = next_state ? S1 : S0;\n        S1: next_state_reg = next_state ? S2 : S1;\n        S2: next_state_reg = next_state ? S3 : S2;\n        S3: next_state_reg = next_state ? S0 : S3;\n        default: next_state_reg = S0;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state_out <= 2'b00; // Reset output\n    end else begin\n        state_out <= current_state; // Output the current state\n    end\nend\n\nendmodule\n",
        "module_name": "fsm_example",
        "module_hash": "5ab4738b3e743f9bc4d46a84e5cc17fc",
        "dataset_index": 9853
      },
      "AND_GATE_a35dbcde": {
        "rtl_code": "module AND_GATE (\n  input a,\n  input b,\n  output y\n);\n\n  assign y = a & b;\n\nendmodule",
        "module_name": "AND_GATE",
        "module_hash": "a35dbcde3122f4c0badf8fa5e47b62e5",
        "dataset_index": 17460
      },
      "shift_register_8538568f": {
        "rtl_code": "module shift_register(\n  input [3:0] data_in,\n  input shift,\n  output [3:0] data_out\n);\n\n  reg [3:0] shift_reg = 4'b0000;\n\n  always @(*) begin\n    if (shift == 0) begin\n      shift_reg <= data_in;\n    end else begin\n      if (shift == 1) begin\n        if (shift_reg[3] == 1) begin\n          shift_reg <= {shift_reg[2:0], 1'b0};\n        end else begin\n          shift_reg <= {shift_reg[2:0], shift_reg[3]};\n        end\n      end else begin\n        shift_reg <= shift_reg;\n      end\n    end\n  end\n\n  assign data_out = shift_reg;\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "8538568fd17eeec7dc0eae87ed9851bd",
        "dataset_index": 7648
      },
      "parity_check_44133cdc": {
        "rtl_code": "module parity_check (\n  input clk,\n  input [7:0] data_in,\n  output reg parity\n);\n\n  reg [7:0] shift_reg;\n  reg [7:0] shifted_data;\n  reg [7:0] sum;\n  reg [2:0] i;\n\n  always @(posedge clk) begin\n    shift_reg <= {shift_reg[6:0], data_in};\n    shifted_data <= {shift_reg[5:0], 2'b00};\n    sum <= shifted_data + shift_reg;\n    parity <= 1'b1;\n\n    for (i = 0; i < 8; i = i + 1) begin\n      if (sum[i] == 1'b1) begin\n        parity <= ~parity;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "parity_check",
        "module_hash": "44133cdc92c43a2767e1f404a84e1023",
        "dataset_index": 6080
      },
      "or4b_7715d0a8": {
        "rtl_code": "module or4b (\n    input  A  ,\n    input  B  ,\n    input  C  ,\n    input  D_N,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire temp;\n\n    assign temp = A | B | C | D_N;\n    assign X = ~temp;\n\nendmodule",
        "module_name": "or4b",
        "module_hash": "7715d0a8dbf355f46f3c45e40c8913f4",
        "dataset_index": 13630
      },
      "pwm_generator_25689e59": {
        "rtl_code": "module pwm_generator (\n  input clk,\n  input rst,\n  output reg pwm_out\n);\n\nreg [1:0] counter = 2'b0;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    pwm_out <= 0;\n    counter <= 2'b0;\n  end else begin\n    if (counter == 2'b11) begin\n      pwm_out <= 1;\n      counter <= 2'b0;\n    end else begin\n      pwm_out <= 0;\n      counter <= counter + 1;\n    end\n  end\nend\n\nendmodule",
        "module_name": "pwm_generator",
        "module_hash": "25689e59b08b7af4108ff3b2c02c992a",
        "dataset_index": 11121
      },
      "ledtest_pio_1_bac6b8ac": {
        "rtl_code": "module ledtest_pio_1 (\n                       // inputs:\n                        address,\n                        clk,\n                        in_port,\n                        reset_n,\n\n                       // outputs:\n                        readdata\n                     )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input            in_port;\n  input            reset_n;\n\n\n  wire             clk_en;\n  wire             data_in;\n  wire             read_mux_out;\n  reg     [ 31: 0] readdata;\n  \n  // Clock enable signal\n  assign clk_en = 1;\n  \n  // Read multiplexer output\n  assign read_mux_out = {1 {(address == 0)}} & data_in;\n  \n  // Read data output\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n  // Data input\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "ledtest_pio_1",
        "module_hash": "bac6b8ac80fc6401a23cf1f9d0f10338",
        "dataset_index": 8100
      },
      "simple_calculator_0497b768": {
        "rtl_code": "module simple_calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input signed [7:0] num1,\n    input signed [7:0] num2,\n    output reg signed [7:0] result,\n    output reg overflow\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 0;\n        overflow <= 0;\n    end\n    else begin\n        case (op)\n            2'b00: begin // addition\n                result <= num1 + num2;\n                overflow <= ((num1[7] == num2[7]) && (result[7] != num1[7]));\n            end\n            2'b01: begin // subtraction\n                result <= num1 - num2;\n                overflow <= ((num1[7] != num2[7]) && (result[7] != num1[7]));\n            end\n            2'b10: begin // multiplication\n                result <= num1 * num2;\n                overflow <= ((result[7:0] != 0) && (result[7:0] != -1));\n            end\n            2'b11: begin // division\n                if (num2 == 0) begin\n                    result <= 0;\n                    overflow <= 1;\n                end\n                else begin\n                    result <= num1 / num2;\n                    overflow <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "0497b76824d64425c764035390b526a3",
        "dataset_index": 13913
      },
      "full_adder_f3ee4c82": {
        "rtl_code": "\nmodule full_adder(\n  input  a,\n  input  b,\n  input  cin,\n  output cout,\n  output sum\n);\n\n  wire w1, w2, w3;\n  assign w1 = a ^ b;\n  assign w2 = a & b;\n  assign w3 = w1 & cin;\n  assign sum = w1 ^ cin;\n  assign cout = w2 | w3;\n\nendmodule\nmodule gray_code_counter(\n  input        clk,\n  input        reset,\n  output reg [15:0] Q\n);\n\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      Q <= 16'b0000000000000000;\n    end else begin\n      Q <= Q ^ ({Q[14:0],1'b0});\n    end\n  end\n\nendmodule\nmodule top_module(\n  input        clk,\n  input        reset,\n  input        a,\n  input        b,\n  input        cin,\n  output       cout,\n  output       sum,\n  output [15:0] Q\n);\n\n  wire [15:0] gray_code;\n  wire adder_sum;\n  wire adder_cout;\n\n  gray_code_counter gc(\n    .clk(clk),\n    .reset(reset),\n    .Q(gray_code)\n  );\n\n  full_adder fa(\n    .a(a),\n    .b(b),\n    .cin(cin),\n    .sum(adder_sum),\n    .cout(adder_cout)\n  );\n\n  assign sum = adder_sum ^ gray_code[0];\n  assign cout = adder_cout;\n  assign Q = gray_code;\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "f3ee4c82aae1d3adb02107a383340ac1",
        "dataset_index": 10212
      },
      "drac_wb_adapter_a65845cc": {
        "rtl_code": "\n\nmodule drac_wb_adapter (\n    output              drac_srd_o,\n    output              drac_swr_o,\n    output      [33:5]  drac_sa_o,\n    output      [255:0] drac_swdat_o,\n    output      [31:0]  drac_smsk_o,\n    input       [255:0] drac_srdat_i,\n    input               drac_srdy_i,\n    input               clk150,\n\n    input       [35:0]  wb_adr_i,\n    input               wb_we_i,\n    input       [3:0]   wb_sel_i,\n    input               wb_stb_i,\n    input               wb_cyc_i,\n    input       [31:0]  wb_dat_i,\n    output      [31:0]  wb_dat_o,\n    output              wb_ack_o,\n    input               clk75,\n\n    input               reset\n);\n\nreg     [31:0]  rdat;\nreg     [255:0] wdat;\nreg     [31:0]  msk;\nreg     [33:2]  addr;\nreg             rdy1 = 1'b0;\nreg             rdy2 = 1'b0;\nreg             read = 1'b0;\nreg             write = 1'b0;\nreg             wb_stb_delay = 1'b0;\n\nalways @(posedge clk75) begin\n    if (wb_stb_i && !wb_stb_delay && wb_we_i) begin\n        case (wb_adr_i[2:0])\n            3'b000: wdat[31:0] <= wb_dat_i;\n            3'b001: wdat[63:32] <= wb_dat_i;\n            3'b010: wdat[95:64] <= wb_dat_i;\n            3'b011: wdat[127:96] <= wb_dat_i;\n            3'b100: wdat[159:128] <= wb_dat_i;\n            3'b101: wdat[191:160] <= wb_dat_i;\n            3'b110: wdat[223:192] <= wb_dat_i;\n            3'b111: wdat[255:224] <= wb_dat_i;\n        endcase\n\n        case (wb_adr_i[2:0])\n            3'b000: msk <= 32'hFFFFFFF0;\n            3'b001: msk <= 32'hFFFFFF0F;\n            3'b010: msk <= 32'hFFFFF0FF;\n            3'b011: msk <= 32'hFFFF0FFF;\n            3'b100: msk <= 32'hFFF0FFFF;\n            3'b101: msk <= 32'hFF0FFFFF;\n            3'b110: msk <= 32'hF0FFFFFF;\n            3'b111: msk <= 32'h0FFFFFFF;\n        endcase\n    end\n\n    if (wb_stb_i && !wb_stb_delay) begin\n        addr[33:2] <= wb_adr_i[31:0];\n    end\nend\n\nalways @(posedge clk75 or posedge reset) begin\n    if (reset) begin\n        read <= 1'b0;\n        write <= 1'b0;\n        rdy2 <= 1'b0;\n        wb_stb_delay <= 1'b0;\n    end else begin\n        wb_stb_delay <= wb_stb_i;\n\n        if (wb_stb_i && !wb_stb_delay && !wb_we_i) begin\n            read <= 1'b1;\n        end else if (wb_stb_i && !wb_stb_delay && wb_we_i) begin\n            write <= 1'b1;\n        end\n\n        if (rdy1) begin\n            read <= 1'b0;\n            write <= 1'b0;\n            rdy2 <= 1'b1;\n        end\n\n        if (rdy2) begin\n            rdy2 <= 1'b0;\n        end\n    end\nend\n\nalways @(posedge clk150 or posedge reset) begin\n    if (reset) begin\n        rdy1 <= 1'b0;\n    end else begin\n        if (drac_srdy_i) begin\n            rdy1 <= 1'b1;\n        end\n        if (rdy2) begin\n            rdy1 <= 1'b0;\n        end\n        if (drac_srdy_i) case (addr[4:2])\n            3'b000: rdat <= drac_srdat_i[31:0];\n            3'b001: rdat <= drac_srdat_i[63:32];\n            3'b010: rdat <= drac_srdat_i[95:64];\n            3'b011: rdat <= drac_srdat_i[127:96];\n            3'b100: rdat <= drac_srdat_i[159:128];\n            3'b101: rdat <= drac_srdat_i[191:160];\n            3'b110: rdat <= drac_srdat_i[223:192];\n            3'b111: rdat <= drac_srdat_i[255:224];\n        endcase\n    end\nend\n\nassign wb_dat_o = rdat;\nassign wb_ack_o = rdy2;\nassign drac_srd_o = read;\nassign drac_swr_o = write;\nassign drac_swdat_o = wdat;\nassign drac_smsk_o = msk;\nassign drac_sa_o = addr[33:5];\n\nendmodule\n",
        "module_name": "drac_wb_adapter",
        "module_hash": "a65845cc4df40748dd425e20c78452e3",
        "dataset_index": 7304
      },
      "top__26289002": {
        "rtl_code": "module top_module (\n    input [15:0] a, // Input for the multiplier and adder modules\n    input [15:0] b, // Input for the multiplier module\n    input sub, // Input for the adder module\n    output [31:0] mult_output, // Output from the multiplier module\n    output [15:0] sum_output, // Output from the adder module\n    output xor_output // Output from the functional module\n);\n\nwire [31:0] mult_result;\nwire [15:0] add_result;\nwire [31:0] xor_result;\n\nmultiplier mult_inst (\n    .a(a),\n    .b(b),\n    .product(mult_result)\n);\n\nadder add_inst (\n    .a(a),\n    .b(b),\n    .sub(sub),\n    .sum(add_result)\n);\n\nfunctional_module func_inst (\n    .mult_input(mult_result),\n    .add_input(add_result),\n    .xor_output(xor_result)\n);\n\nassign mult_output = mult_result;\nassign sum_output = add_result;\nassign xor_output = xor_result[0];\n\nendmodule\n\nmodule multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n\ninteger i;\nreg [31:0] temp_product;\n\nalways @(*) begin\n    temp_product = 0;\n    for (i = 0; i < 16; i = i + 1) begin\n        if (b[i]) begin\n            temp_product = temp_product + (a << i);\n        end\n    end\nend\n\nassign product = temp_product;\n\nendmodule\n\nmodule adder (\n    input [15:0] a,\n    input [15:0] b,\n    input sub,\n    output [15:0] sum\n);\n\nwire [15:0] b_xor;\n\nassign b_xor = sub ? b ^ 16'hFFFF : b;\n\nadder16 add_inst (\n    .a(a),\n    .b(b_xor),\n    .sum(sum)\n);\n\nendmodule\n\nmodule adder16 (\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n\nassign sum = a + b;\n\nendmodule\n\nmodule functional_module (\n    input [31:0] mult_input,\n    input [15:0] add_input,\n    output [31:0] xor_output\n);\n\nassign xor_output = mult_input ^ {16'b0, add_input};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "2628900255957d5982d6ea5dcd14d656",
        "dataset_index": 18434
      },
      "ps2_4473c2d2": {
        "rtl_code": "module ps2 (\n    input CLKOUT,\n    input Rx,\n    output reg Tx\n);\n\nreg [8:0] data_bits;\nreg parity_bit;\nreg start_bit_detected;\nreg [3:0] bit_count;\n\nparameter IDLE = 2'b00;\nparameter START_BIT = 2'b01;\nparameter DATA_BITS = 2'b10;\nparameter PARITY_BIT = 2'b11;\n\nreg [1:0] state;\n\n// initialize signals\ninitial begin\n    state = IDLE;\n    Tx = 1;\n    data_bits = 0;\n    parity_bit = 0;\n    start_bit_detected = 0;\n    bit_count = 0;\nend\n\nalways @(posedge CLKOUT) begin\n    case (state)\n        IDLE: begin\n            Tx = 1;\n            if (Rx == 0) begin\n                state = START_BIT;\n                bit_count = 0;\n                start_bit_detected = 1;\n            end\n        end\n        START_BIT: begin\n            Tx = 0;\n            if (bit_count == 7) begin\n                state = PARITY_BIT;\n                bit_count = 0;\n            end\n            else begin\n                state = DATA_BITS;\n            end\n            data_bits[bit_count] = Rx;\n            bit_count = bit_count + 1;\n        end\n        DATA_BITS: begin\n            Tx = data_bits[bit_count];\n            if (bit_count == 7) begin\n                state = PARITY_BIT;\n                bit_count = 0;\n            end\n            else begin\n                bit_count = bit_count + 1;\n            end\n        end\n        PARITY_BIT: begin\n            if (parity_bit == 1) begin\n                Tx = 0;\n            end\n            else begin\n                Tx = 1;\n            end\n            state = IDLE;\n            if (start_bit_detected == 1) begin\n                parity_bit = ^data_bits;\n                start_bit_detected = 0;\n            end\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "ps2",
        "module_hash": "4473c2d250314e9f73f996be2260adde",
        "dataset_index": 2667
      },
      "aes_29df315f": {
        "rtl_code": "\nmodule aes(\n\tinput [3:0] addroundkey_data_i,\n\tinput [3:0] addroundkey_data_reg,\n\tinput [3:0] addroundkey_round,\n\tinput [3:0] key_i,\n\tinput [3:0] keysched_new_key_o,\n\tinput [3:0] round,\n\tinput addroundkey_start_i,\n\tinput keysched_ready_o,\n\n\toutput reg [3:0] keysched_last_key_i,\n\toutput reg [3:0] keysched_round_i,\n\toutput reg [3:0] next_addroundkey_data_reg,\n\toutput reg [3:0] next_addroundkey_round,\n\toutput reg [3:0] round_data_var,\n\toutput reg keysched_start_i,\n\toutput reg next_addroundkey_ready_o\n);\n\nreg [3:0] data_var;\nreg [3:0] round_key_var;\n\nalways @*\nbegin\n\tkeysched_start_i = 0;\n\tkeysched_round_i = addroundkey_round;\n\tround_data_var = addroundkey_data_reg;\n\tnext_addroundkey_data_reg = addroundkey_data_reg;\n\tnext_addroundkey_ready_o = 0;\n\tnext_addroundkey_round = addroundkey_round;\n\n\tif (addroundkey_round == 1 || addroundkey_round == 0)\n\t\tkeysched_last_key_i = key_i;\n\telse\n\t\tkeysched_last_key_i = keysched_new_key_o;\n\n\tif (round == 0 && addroundkey_start_i)\n\tbegin\n\t\tdata_var = addroundkey_data_i;\n\t\tround_key_var = key_i;\n\t\tround_data_var = round_key_var ^ data_var;\n\t\tnext_addroundkey_data_reg = round_data_var;\n\t\tnext_addroundkey_ready_o = 1;\n\tend\n\telse if (addroundkey_start_i && round != 0)\n\tbegin\n\t\tkeysched_last_key_i = key_i;\n\t\tkeysched_start_i = 1;\n\t\tkeysched_round_i = 1;\n\t\tnext_addroundkey_round = 1;\n\tend\n\telse if (addroundkey_round != round && keysched_ready_o)\n\tbegin\n\t\tnext_addroundkey_round = addroundkey_round + 1;\n\t\tkeysched_last_key_i = keysched_new_key_o;\n\t\tkeysched_start_i = 1;\n\t\tkeysched_round_i = addroundkey_round + 1;\n\tend\n\telse if (addroundkey_round == round && keysched_ready_o)\n\tbegin\n\t\tdata_var = addroundkey_data_i;\n\t\tround_key_var = keysched_new_key_o;\n\t\tround_data_var = round_key_var ^ data_var;\n\t\tnext_addroundkey_data_reg = round_data_var;\n\t\tnext_addroundkey_ready_o = 1;\n\t\tnext_addroundkey_round = 0;\n\tend\nend\n\nendmodule\n\n",
        "module_name": "aes",
        "module_hash": "29df315f6e29f4c7f8a0c97c7a1164bf",
        "dataset_index": 25725
      },
      "altpcierd_tx_ecrc_ctl_fifo_18d3268a": {
        "rtl_code": "\nmodule altpcierd_tx_ecrc_ctl_fifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    almost_full,\n    empty,\n    full,\n    q);\n\n    input aclr;\n    input clock;\n    input [0:0] data;\n    input rdreq;\n    input wrreq;\n    output almost_full;\n    output empty;\n    output full;\n    output [0:0] q;\n    \n    wire almost_empty;\n    wire almost_full;\n    \n    reg q_reg = 1'b0;\n\n    always @(posedge clock or posedge aclr)\n        if (aclr)\n            q_reg <= 1'b0;\n        else if (!empty && rdreq)\n            q_reg <= 1'bx;\n        else if (wrreq && rdreq)\n            q_reg <= 1'bx;\n        else if (!full && wrreq)\n            q_reg <= data;\n\n    assign q = q_reg;\n    assign full = 0;\n    assign empty = q == 1'b0;\n    assign almost_full = 0;\n\nendmodule",
        "module_name": "altpcierd_tx_ecrc_ctl_fifo",
        "module_hash": "18d3268a72e290d3a1d9ebd8f967ed9c",
        "dataset_index": 13306
      },
      "my_circuit_38864992": {
        "rtl_code": "module my_circuit (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = (A1 & A2) & (B1 | C1);\n\nendmodule",
        "module_name": "my_circuit",
        "module_hash": "388649921e56356d94be3d8040d221c4",
        "dataset_index": 3936
      },
      "top_module_94d3f2da": {
        "rtl_code": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    reg [99:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else begin\n            if (ena[0]) begin\n                shift_reg <= {shift_reg[98:0], shift_reg[99]};\n            end\n            if (ena[1]) begin\n                shift_reg <= {shift_reg[0], shift_reg[99:1]};\n            end\n        end\n    end\n\n    always @*\n    begin\n        q = shift_reg;\n    end\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "94d3f2dad1852a83226c219f68fc0b61",
        "dataset_index": 5862
      },
      "PSWreg_7799887c": {
        "rtl_code": "module PSWreg (\n    rst, \n    clk, \n    unaligned, \n    ovf, \n    status\n);\n\ninput rst;\ninput clk;\ninput unaligned;\ninput ovf;\noutput [31:0] status;\n\nreg [31:0] status_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        status_reg <= 32'h0;\n    end else begin\n        status_reg[1] <= unaligned;\n        status_reg[0] <= ovf;\n    end\nend\n\nassign status = status_reg;\n\nendmodule",
        "module_name": "PSWreg",
        "module_hash": "7799887ceb4d8f0389711e08b4d68f5f",
        "dataset_index": 1890
      },
      "JNOR3C_a9b6aef1": {
        "rtl_code": "module JNOR3C(A1, A2, A3, A4, O);\ninput   A1;\ninput   A2;\ninput   A3;\ninput   A4;\noutput  O;\n\nwire    M1;\nwire    M2;\nwire    M3;\nwire    N1;\nwire    N2;\n\n// Implement majority gate using standard gates\nassign M1 = A1 & A2;\nassign M2 = A2 & A3;\nassign M3 = A1 & A3;\nassign N1 = ~(M1 | M2);\nassign N2 = ~(M1 | M3);\nassign O = ~(N1 | N2 | (A1 & A2 & A3 & A4));\n\nendmodule",
        "module_name": "JNOR3C",
        "module_hash": "a9b6aef177047d8c0fe96bd0f7dba438",
        "dataset_index": 3863
      },
      "system_controller_4c735cf8": {
        "rtl_code": "module system_controller(\n   clk_sys, reset_sys, locked,\n   clk_in, reset_in\n   );\n   input wire clk_in;\n   output wire clk_sys;\n   input  wire reset_in;\n   output wire reset_sys;   \n   output wire locked;\n   \n    \n   `ifdef XILINX\n   wire                         xclk_buf;\n   IBUFG xclk_ibufg(.I(clk_in), .O(xclk_buf));\n   wire                         locked;\n`else\n   assign locked = 1;\n   \n`endif\n   \n\n   reg [5:0]                    reset_count = 6'h0;\n   assign reset_sys = reset_in | ~locked | (|reset_count);   \n   \n   always @(posedge clk_in)\n     if (reset_in | ~locked) begin\n        reset_count <= 6'h1;        \n     end else begin\n        if (reset_count) begin\n           reset_count <= reset_count + 1;           \n        end\n     end\n   \n   `ifdef XILINX   \n   BUFG clk_bug (\n                 .O(clk_sys), .I(CLKFBOUT) );\n\n   clk_wiz_0 lab9_clocks\n     (\n      .clk_in1(xclk_buf),      .clk_out1(CLKFBOUT),     .reset(reset_in), .locked(locked));      `else assign clk_sys = clk_in;   \n   \n`endif endmodule ",
        "module_name": "system_controller",
        "module_hash": "4c735cf8a099cea70171c78f7ac1d8bd",
        "dataset_index": 22092
      },
      "priority_encoder_e54a3ca4": {
        "rtl_code": "module priority_encoder (\n    input [3:0] A, B, C, D, // Four 4-bit binary values to be encoded\n    input S1, S0, // Select inputs to determine which input to encode\n    output reg [1:0] Q // 2-bit output of the priority encoder module\n);\n\nalways @(*) begin\n    if (S1 == 0 && S0 == 0) begin\n        if (A > B && A > C && A > D) Q = 0;\n        else if (B > C && B > D) Q = 1;\n        else if (C > D) Q = 2;\n        else Q = 3;\n    end\n    else if (S1 == 0 && S0 == 1) begin\n        if (B > A && B > C && B > D) Q = 0;\n        else if (A > C && A > D) Q = 1;\n        else if (C > D) Q = 2;\n        else Q = 3;\n    end\n    else if (S1 == 1 && S0 == 0) begin\n        if (C > A && C > B && C > D) Q = 0;\n        else if (A > B && A > D) Q = 1;\n        else if (B > D) Q = 2;\n        else Q = 3;\n    end\n    else if (S1 == 1 && S0 == 1) begin\n        if (D > A && D > B && D > C) Q = 0;\n        else if (A > B && A > C) Q = 1;\n        else if (B > C) Q = 2;\n        else Q = 3;\n    end\nend\n\nendmodule\n\nmodule adder_subtractor (\n    input [3:0] A, B, // Two 4-bit binary values to be added or subtracted\n    input Cn, // Carry-in input for the adder\n    input Sub, // Subtraction mode select input\n    output reg [3:0] S, // 4-bit output of the adder/subtractor module\n    output reg Cout // Carry-out output of the adder\n);\n\nalways @(*) begin\n    if (Sub == 1) begin\n        S = A - B;\n        Cout = ~(A < B);\n    end\n    else begin\n        S = A + B + Cn;\n        Cout = (S > 15);\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input [3:0] A, B, C, D, // Four 4-bit binary values to be added or subtracted\n    input S1, S0, // Select inputs to determine which input to encode\n    output reg [1:0] encoded_input // 2-bit encoded input for adder_subtractor\n);\n\nwire [1:0] pe_output;\npriority_encoder pe (\n    .A(A),\n    .B(B),\n    .C(C),\n    .D(D),\n    .S1(S1),\n    .S0(S0),\n    .Q(pe_output)\n);\n\nalways @* begin\n    encoded_input = (pe_output == 2'b10 || pe_output == 2'b11) ? 1'b1 : 1'b0;\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "e54a3ca4848fb1f708d38dabcd2b5757",
        "dataset_index": 4938
      },
      "barrel_shifter_0c35a009": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] data_in,\n    input [1:0] shift_amount,\n    input mode,\n    output reg [3:0] data_out\n);\n\nreg [3:0] shift_reg1, shift_reg2, shift_reg3;\n\nalways @(*) begin\n    shift_reg1 = data_in;\n    shift_reg2 = shift_reg1 >> shift_amount;\n    shift_reg3 = shift_reg1 << shift_amount;\nend\n\nalways @(posedge mode) begin\n    if (mode == 1'b0) begin\n        data_out <= shift_reg2;\n    end else begin\n        data_out <= shift_reg3;\n    end\nend\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "0c35a009195aa1c7b8fd6fb04cb4425a",
        "dataset_index": 10607
      },
      "wireless_comm_24bfb42e": {
        "rtl_code": "\nmodule wireless_comm (\n  input clk,\n  input reset_n,\n  input [7:0] tx_data,\n  input tx_en,\n  input rx_en,\n  output [7:0] rx_data,\n  output reg tx_busy\n);\n\n  // Declare internal registers for receiver and transmitter data\n  reg [7:0] tx_data_reg;\n  reg [7:0] rx_data_reg;\n\n  // Define transmitter logic using selected wireless communication protocol\n  // ...\n\n  // Define receiver logic using selected wireless communication protocol\n  // ...\n\n  // Connect inputs and outputs to transmitter and receiver logic\n  // ...\n\n  // Handle asynchronous reset signal\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      // Reset logic here\n      tx_busy <= 0;\n      tx_data_reg <= 0;\n      rx_data_reg <= 0;\n    end else begin\n      // Normal operation here\n      // ...\n\n      // Update transmitter data\n      if (tx_en) begin\n        tx_data_reg <= tx_data;\n        tx_busy <= 1;\n      end else begin\n        tx_busy <= 0;\n      end\n\n      // Update receiver data\n      if (rx_en) begin\n        rx_data_reg <= rx_data_reg + 1;\n      end\n    end\n  end\n\n  // Assign receiver data to output\n  assign rx_data = rx_data_reg;\n\nendmodule",
        "module_name": "wireless_comm",
        "module_hash": "24bfb42e3d3a97ad16c4e6a7da0df95c",
        "dataset_index": 819
      },
      "blake2_G_52e2bd9d": {
        "rtl_code": "module blake2_G(\n                input wire [63 : 0]  a,\n                input wire [63 : 0]  b,\n                input wire [63 : 0]  c,\n                input wire [63 : 0]  d,\n                input wire [63 : 0]  m0,\n                input wire [63 : 0]  m1,\n\n                output wire [63 : 0] a_prim,\n                output wire [63 : 0] b_prim,\n                output wire [63 : 0] c_prim,\n                output wire [63 : 0] d_prim\n               );\n\n  wire [63 : 0] a0 = a + b + m0;\n\n  wire [63 : 0] d0 = d ^ a0;\n  wire [63 : 0] d1 = {d0[31 : 0], d0[63 : 32]};\n\n  wire [63 : 0] c0 = c + d1;\n\n  wire [63 : 0] b0 = b ^ c0;\n  wire [63 : 0] b1 = {b0[23 : 0], b0[63 : 24]};\n\n  wire [63 : 0] a1 = a0 + b1 + m1;\n\n  wire [63 : 0] d2 = d1 ^ a1;\n  wire [63 : 0] d3 = {d2[15 : 0], d2[63 : 16]};\n\n  wire [63 : 0] c1 = c0 + d3;\n\n  wire [63 : 0] b2 = b1 ^ c1;\n  wire [63 : 0] b3 = {b2[62 : 0], b2[63]};\n\n  assign a_prim = a1;\n  assign b_prim = b3;\n  assign c_prim = c1;\n  assign d_prim = d3;\n\nendmodule ",
        "module_name": "blake2_G",
        "module_hash": "52e2bd9d34a4ddf00daa44664a9a1996",
        "dataset_index": 10199
      },
      "dff_async_reset_enable_492d9ecc": {
        "rtl_code": "module dff_async_reset_enable (\n    input CLK,\n    input D,\n    input RESET,\n    input EN,\n    output Q,\n    output Q_N\n);\n\nreg Q;\nreg Q_N;\n\nalways @(posedge CLK or negedge RESET)\nbegin\n    if (!RESET)\n    begin\n        Q <= 1'b0;\n        Q_N <= 1'b1;\n    end\n    else if (!EN)\n    begin\n        Q <= Q;\n        Q_N <= Q_N;\n    end\n    else\n    begin\n        Q <= D;\n        Q_N <= ~D;\n    end\nend\n\nendmodule",
        "module_name": "dff_async_reset_enable",
        "module_hash": "492d9ecc915bb283cc04e5c1e14fa3d0",
        "dataset_index": 7106
      },
      "SPIinterface_d9ae606a": {
        "rtl_code": "\nmodule SPIinterface(\n\t\ttxbuffer,\n\t\trxbuffer,\n\t\ttransmit,\n\t\tdone_out,\n\t\tsdi, sdo,\n\t\trst, clk,\n\t\tsclk\n);\n   \ninput            clk;\n   input            rst;\n   input            transmit;\n   input            sdi;\n\tinput [15:0]     txbuffer;\n   output [7:0]     rxbuffer;\n   output           done_out;\n   output           sdo;\n   output           sclk;\n   \n   \nwire             sclk;\n\twire             done_out;\n   reg              sdo;\n\twire [7:0]\t\t  rxbuffer;\n   \n   parameter [7:0]  CLKDIVIDER = 8'hFF;\t\tparameter [1:0]  TxType_idle = 0,\n                    TxType_transmitting = 1;\n\n   parameter [1:0]  RxType_idle = 0,\n                    RxType_recieving = 1;\n\n   parameter [1:0]  SCLKType_idle = 0,\n                    SCLKType_running = 1;\n\t\t\t\t\t\t  \n   reg [7:0]        clk_count = 7'd0;\n   reg              clk_edge_buffer = 1'd0;\n   \n   reg              sck_previous = 1'b1;\n   reg              sck_buffer = 1'b1;\n   \n   reg [15:0]       tx_shift_register = 16'h0000;\n   reg [3:0]        tx_count = 4'h0;\n   reg [7:0]        rx_shift_register = 8'h00;\n   reg [3:0]        rx_count = 4'h0;\n\n   reg              done = 1'b0;\n   reg [1:0]        TxSTATE = TxType_idle;\n   reg [1:0]        RxSTATE = RxType_idle;\n   reg [1:0]        SCLKSTATE = SCLKType_idle;\n   \nalways @(posedge clk)\n\t\tbegin: TxProcess\n\t\t\tbegin\n\t\t\t\tif (rst == 1'b1)\n\t\t\t\tbegin\n\t\t\t\t\ttx_shift_register <= 16'd0;\n\t\t\t\t\ttx_count <= 4'd0;\n\t\t\t\t\tsdo <= 1'b1;\n\t\t\t\t\tTxSTATE <= TxType_idle;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tcase (TxSTATE)\n\t\t\t\t\t\tTxType_idle :\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\ttx_shift_register <= txbuffer;\n\t\t\t\t\t\t\t\tif (transmit == 1'b1)\n\t\t\t\t\t\t\t\t\tTxSTATE <= TxType_transmitting;\n\t\t\t\t\t\t\t\telse if (done == 1'b1)\n\t\t\t\t\t\t\t\t\tsdo <= 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tTxType_transmitting :\n\t\t\t\t\t\t\tif (sck_previous == 1'b1 & sck_buffer == 1'b0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (tx_count == 4'b1111) begin\n\t\t\t\t\t\t\t\t\tTxSTATE <= TxType_idle;\n\t\t\t\t\t\t\t\t\ttx_count <= 4'd0;\n\t\t\t\t\t\t\t\t\tsdo <= tx_shift_register[15];\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\t\ttx_count <= tx_count + 4'b0001;\n\t\t\t\t\t\t\t\t\tsdo <= tx_shift_register[15];\n\t\t\t\t\t\t\t\t\ttx_shift_register <= {tx_shift_register[14:0], 1'b0};\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\t\t\n\t\talways @(posedge clk)\n\t\tbegin: RxProcess\n\t\t\tbegin\n\t\t\t\tif (rst == 1'b1)\n\t\t\t\tbegin\n\t\t\t\t\trx_shift_register <= 8'h00;\n\t\t\t\t\trx_count <= 4'h0;\n\t\t\t\t\tdone <= 1'b0;\n\t\t\t\t\tRxSTATE <= RxType_idle;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tcase (RxSTATE)\n\t\t\t\t\t\tRxType_idle :\n\t\t\t\t\t\t\tif (transmit == 1'b1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tRxSTATE <= RxType_recieving;\n\t\t\t\t\t\t\t\trx_shift_register <= 8'h00;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (SCLKSTATE == RxType_idle)\n\t\t\t\t\t\t\t\tdone <= 1'b0;\n\t\t\t\t\t\tRxType_recieving :\n\t\t\t\t\t\t\tif (sck_previous == 1'b0 & sck_buffer == 1'b1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif (rx_count == 4'b1111)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tRxSTATE <= RxType_idle;\n\t\t\t\t\t\t\t\t\trx_count <= 4'd0;\n\t\t\t\t\t\t\t\t\trx_shift_register <= {rx_shift_register[6:0], sdi};\n\t\t\t\t\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\trx_count <= rx_count + 4'd1;\n\t\t\t\t\t\t\t\t\trx_shift_register <= {rx_shift_register[6:0], sdi};\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\t\t\n\t\talways @(posedge clk)\n\t\tbegin: SCLKgen\n\t\t\tbegin\n\t\t\t\tif (rst == 1'b1)\n\t\t\t\tbegin\n\t\t\t\t\tclk_count <= 8'h00;\n\t\t\t\t\tSCLKSTATE <= SCLKType_idle;\n\t\t\t\t\tsck_previous <= 1'b1;\n\t\t\t\t\tsck_buffer <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tcase (SCLKSTATE)\n\t\t\t\t\t\tSCLKType_idle :\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tsck_previous <= 1'b1;\n\t\t\t\t\t\t\t\tsck_buffer <= 1'b1;\n\t\t\t\t\t\t\t\tclk_count <= 8'h00;\n\t\t\t\t\t\t\t\tclk_edge_buffer <= 1'b0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (transmit == 1'b1)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tSCLKSTATE <= SCLKType_running;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tSCLKType_running :\n\t\t\t\t\t\t\tif (done == 1'b1) begin\n\t\t\t\t\t\t\t\tSCLKSTATE <= SCLKType_idle;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (clk_count == CLKDIVIDER) begin\n\t\t\t\t\t\t\t\tif (clk_edge_buffer == 1'b0) begin\n\t\t\t\t\t\t\t\t\tsck_buffer <= 1'b1;\n\t\t\t\t\t\t\t\t\tclk_edge_buffer <= 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\t\tsck_buffer <= (~sck_buffer);\n\t\t\t\t\t\t\t\t\tclk_count <= 8'h00;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\tsck_previous <= sck_buffer;\n\t\t\t\t\t\t\t\tclk_count <= clk_count + 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\t\t\n\t\tassign rxbuffer = rx_shift_register;\n\t\tassign sclk = sck_buffer;\n\t\tassign done_out = done;\n   \nendmodule\n\n\n",
        "module_name": "SPIinterface",
        "module_hash": "d9ae606ad693e3742b08671895d0c9b5",
        "dataset_index": 22615
      },
      "accu_7ac1a671": {
        "rtl_code": "module accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               control     ,\n    input               ready_b     ,\n \n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [7:0]   data_out\n);\n\nreg [7:0] accumulator;\nreg [2:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        accumulator <= 8'b0;\n        counter <= 3'b0;\n        valid_b <= 1'b0;\n    end\n    else begin\n        if (control) begin\n            accumulator <= accumulator ^ data_in;\n            counter <= counter + 1;\n            if (counter == 3'b111) begin\n                data_out <= accumulator;\n                accumulator <= 8'b0;\n                counter <= 3'b0;\n                valid_b <= 1'b1;\n            end\n            else begin\n                valid_b <= 1'b0;\n            end\n        end\n        else begin\n            valid_b <= 1'b0;\n        end\n    end\nend\n\nassign ready_a = ~ready_b;\n\nendmodule",
        "module_name": "accu",
        "module_hash": "7ac1a671a2bb670ec134117a752ec221",
        "dataset_index": 6506
      },
      "delayN_f3d2249e": {
        "rtl_code": "module delayN(clk,in,out);\n   input clk;\n   input in;\n   output out;\n\n   parameter NDELAY = 3;\n\n   reg [NDELAY-1:0] shiftreg;\n   wire \t    out = shiftreg[NDELAY-1];\n\n   always @(posedge clk)\n     shiftreg <= {shiftreg[NDELAY-2:0],in};\n\nendmodule",
        "module_name": "delayN",
        "module_hash": "f3d2249e66abb3ffa8f63e75f117a25f",
        "dataset_index": 17957
      },
      "flt_mult_7f9ff672": {
        "rtl_code": "module flt_mult\n\t(\n\tinput\t\t\tclk,\n\tinput\t\t\trstn,\n\tinput\t    [31:0]\tafl,\n\tinput\t    [31:0]\tbfl,\n\toutput\treg [31:0]\tfl\n\t);\n\nreg\t[47:0]\tmfl_0;\t\t// Mantisa of the Float\nreg\t\tsfl_0;\t\t// Sign of the Float\nreg\t[7:0]\tefl_0;\t\t// Exponent of the Float\nreg\t\tzero_out_0;\nreg\t\tsfl_1;\t\t// Sign of the Float\nreg\t[7:0]\tefl_1;\t\t// Exponent of the Float\nreg\t\tzero_out_1;\nreg\t\tmfl47_1;\t// Mantisa of the Float\nreg\t[24:0]\tnmfl_1;\t\t// Normalized Mantisa of the Float\nreg \t\tnot_mfl_47;\n\nalways @* not_mfl_47 = (~mfl47_1 & ~nmfl_1[24]);\n\nalways @(posedge clk, negedge rstn) begin\n\tif(!rstn) begin\n\t\tmfl_0 \t   <= 48'h0;\n\t\tsfl_0 \t   <= 1'b0;\n\t\tefl_0 \t   <= 8'h0;\n\t\tzero_out_0 <= 1'b0;\n\t\tefl_1 \t   <= 8'h0;\n\t\tsfl_1 \t   <= 1'b0;\n\t\tzero_out_1 <= 1'b0;\n\t\tmfl47_1    <= 1'b0;\n\t\tnmfl_1     <= 25'h0;\n\t\tfl \t   <= 32'h0;\n\tend\n\telse begin\n\t\t// Pipe 0.\n\t\t// Multiply the mantisa.\n\t\tmfl_0 <= {1'b1,afl[22:0]} * {1'b1,bfl[22:0]};\n\t\t// Calulate the Sign.\n\t\tsfl_0 <= afl[31] ^ bfl[31];\n\t\tefl_0 <= afl[30:23] + bfl[30:23] - 8'h7E;\n\t\t// If a or b equals zero, return zero.\n\t\tif((afl[30:0] == 0) || (bfl[30:0] == 0))zero_out_0 <= 1'b1;\n\t\telse zero_out_0 <= 1'b0;\n\t\t// Pipe 1.\n\t\tefl_1 <= efl_0;\t\n\t\tsfl_1 <= sfl_0;\t\n\t\tzero_out_1 <= zero_out_0;\n\t\tmfl47_1  <= mfl_0[47];\n\t\tif(mfl_0[47]) nmfl_1 <= mfl_0[47:24] + mfl_0[23];\n\t\telse \t      nmfl_1 <= mfl_0[47:23] + mfl_0[22];\n\t\t// Pipe 2.\n\t\tif(zero_out_1) fl <= 32'h0;\n\t\telse \t       fl <= {sfl_1,(efl_1 - not_mfl_47),nmfl_1[22:0]};\n\tend\nend\n\nendmodule",
        "module_name": "flt_mult",
        "module_hash": "7f9ff672680944e35fe1e464a655c8f1",
        "dataset_index": 18963
      },
      "top_module_5f4dab04": {
        "rtl_code": "\nmodule top_module(\n    input [1023:0] in,\n    input [7:0] sel,\n    input clk,\n    input rst_n,\n    output reg rise,\n    output reg down,\n    output reg [15:0] out\n);\n\n    reg [3:0] delay_sel;\n    wire [3:0] delayed_in;\n    reg [3:0] delayed_in_prev;\n    reg [3:0] edge_rising;\n    reg [3:0] edge_falling;\n\n    // 256-to-1 multiplexer for programmable delay line\n    mux256to1 mux(\n        .in(in),\n        .sel(delay_sel),\n        .out(delayed_in)\n    );\n\n    // Delay line\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            delay_sel <= 0;\n        end else begin\n            delay_sel <= sel;\n        end\n    end\n\n    // Edge detection\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            delayed_in_prev <= 0;\n            rise <= 0;\n            down <= 0;\n            out <= 0;\n        end else begin\n            delayed_in_prev <= delayed_in;\n            edge_rising <= (delayed_in_prev < delayed_in) ? delayed_in : 0;\n            edge_falling <= (delayed_in_prev > delayed_in) ? delayed_in : 0;\n            rise <= |edge_rising;\n            down <= |edge_falling;\n            if (rise && down && (out == 0)) begin\n                out <= {{11{edge_rising[3]}}, edge_rising - edge_falling};\n            end\n        end\n    end\n\nendmodule\nmodule mux256to1(\n    input [1023:0] in,\n    input [3:0] sel,\n    output [3:0] out\n);\n\n    assign out = in[sel * 4 +: 4];\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "5f4dab044be435784d5d9257148ff2c8",
        "dataset_index": 18655
      },
      "pulses_8a9d123d": {
        "rtl_code": "module pulses(\n\t      \n\t      input \t   clk_pll, input \t   clk, input [23:0]  per, input [15:0] p1wid,\n\t      input [15:0] del,\n\t      input [15:0] p2wid,\n\t      input \t   cp,\n              input \t   bl,\n\t      input \t   rxd,\n\t      output \t   sync_on, output \t   pulse_on, output \t   inhib );\n\n   reg [31:0] \t\t   counter = 0; reg \t\t\t   sync;\n   reg \t\t\t   pulse;\n   reg \t\t\t   inh;\n   reg \t\t\t   rec = 0;\n   reg \t\t\t   cw = 0; \t\t\t   \n   \n   parameter stperiod = 100500 >> 8; reg [23:0] \t\t   period = stperiod;\n   reg [15:0] \t\t   p1width;\n   reg [15:0] \t\t   delay;\n   reg [15:0] \t\t   p2width;\n   reg \t\t\t   cpmg;\n   reg \t\t\t   block;\n   reg [7:0] \t\t   pulse_block = 8'd50;\n   reg \t\t\t   rx_done;\n   reg [15:0] \t\t   p2start;\n   reg [23:0] \t\t   sync_down;\n   reg [15:0] \t\t   block_off;\n\n   assign sync_on = sync; assign pulse_on = pulse; assign inhib = inh; always @(posedge clk) begin\n      period <= per;\n\t p1width <= p1wid;\n\t p2width <= p2wid;\n\t delay <= del;\n\t cpmg <= cp;\n\t block <= bl;\n\n      p2start <= p1width + delay;\n      sync_down <= (cpmg > 0) ? p2start + p2width : period << 7;\n      block_off <= p2start + p2width + delay - pulse_block;\n\n      cw <= (cpmg > 0) ? 0 : 1;\n\t \n   end\n\n   \n   always @(posedge clk_pll) begin\n      case (counter)\n\t0: begin\n\t   pulse <= 1;\n\t   inh <= block;\n\t   sync <= 1;\n\tend\n\n\tp1width: begin\n\t   pulse <= cw;\n\tend\n\n\tp2start: begin\n\t   pulse <= 1;\n\tend\n\n\tsync_down: begin\n\t   pulse <= cw;\n\t   sync <= 0;\n\tend\n\n\tblock_off: begin\n\t   inh <= 0;\n\tend\n\t\n      endcase counter <= (counter < (period << 8)) ? counter + 1 : 0; end endmodule ",
        "module_name": "pulses",
        "module_hash": "8a9d123d6698023986eb0753f34adac9",
        "dataset_index": 23584
      },
      "clock_gate_67baaa53": {
        "rtl_code": "module clock_gate (\n    input clk,\n    input en,\n    input te,\n    output reg en_clk\n);\n\nalways @(*) begin\n    if (en && te) begin\n        en_clk = clk;\n    end\n    else begin\n        en_clk = 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "67baaa53c19f29a3682473ac3af691f5",
        "dataset_index": 11502
      },
      "lpf__405f78cc": {
        "rtl_code": "module lpf_module (\n   input slowest_sync_clk,\n   input dcm_locked,\n   input aux_reset_in,\n   input mb_debug_sys_rst,\n   input ext_reset_in,\n   output lpf_int\n);\n\n  wire asr_lpf;\n  wire lpf_asr;\n  wire lpf_exr;\n  wire lpf_int0__0;\n  wire Q;\n  \n  reg asr_lpf_reg;\n  reg lpf_asr_reg;\n  reg lpf_exr_reg;\n  \n  always @ (posedge slowest_sync_clk) begin\n    asr_lpf_reg <= dcm_locked;\n    lpf_asr_reg <= asr_lpf_reg;\n    lpf_exr_reg <= mb_debug_sys_rst;\n  end\n  \n  assign asr_lpf = asr_lpf_reg;\n  assign lpf_asr = lpf_asr_reg;\n  assign lpf_exr = lpf_exr_reg;\n  \n  reg [15:0] Q_reg;\n  \n  always @ (posedge slowest_sync_clk) begin\n    Q_reg <= {Q_reg[14:0], 1'b0};\n  end\n  \n  assign Q = Q_reg[15];\n  \n  reg [15:0] lpf_int0__0_reg;\n  \n  always @ (posedge slowest_sync_clk) begin\n    lpf_int0__0_reg <= {Q, lpf_asr, dcm_locked, lpf_exr};\n  end\n  \n  assign lpf_int0__0 = lpf_int0__0_reg[0];\n  \n  reg [15:0] lpf_int_reg;\n  \n  always @ (posedge slowest_sync_clk) begin\n    lpf_int_reg <= lpf_int0__0_reg;\n  end\n  \n  assign lpf_int = lpf_int_reg[0];\n  \nendmodule",
        "module_name": "lpf_",
        "module_hash": "405f78ccc91d43753fc40148dcfc99e3",
        "dataset_index": 5982
      },
      "carry_lookahead_adder_9467720f": {
        "rtl_code": "module carry_lookahead_adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output carry_out\n);\n\nwire [7:0] p, g;\nwire [7:0] c;\n\nassign p = a ^ b;\nassign g = a & b;\n\nassign c[0] = g[0];\nassign c[1] = g[1] | (p[1] & g[0]);\nassign c[2] = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]);\nassign c[3] = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]);\nassign c[4] = g[4] | (p[4] & g[3]) | (p[4] & p[3] & g[2]) | (p[4] & p[3] & p[2] & g[1]) | (p[4] & p[3] & p[2] & p[1] & g[0]);\nassign c[5] = g[5] | (p[5] & g[4]) | (p[5] & p[4] & g[3]) | (p[5] & p[4] & p[3] & g[2]) | (p[5] & p[4] & p[3] & p[2] & g[1]) | (p[5] & p[4] & p[3] & p[2] & p[1] & g[0]);\nassign c[6] = g[6] | (p[6] & g[5]) | (p[6] & p[5] & g[4]) | (p[6] & p[5] & p[4] & g[3]) | (p[6] & p[5] & p[4] & p[3] & g[2]) | (p[6] & p[5] & p[4] & p[3] & p[2] & g[1]) | (p[6] & p[5] & p[4] & p[3] & p[2] & p[1] & g[0]);\nassign c[7] = g[7] | (p[7] & g[6]) | (p[7] & p[6] & g[5]) | (p[7] & p[6] & p[5] & g[4]) | (p[7] & p[6] & p[5] & p[4] & g[3]) | (p[7] & p[6] & p[5] & p[4] & p[3] & g[2]) | (p[7] & p[6] & p[5] & p[4] & p[3] & p[2] & g[1]) | (p[7] & p[6] & p[5] & p[4] & p[3] & p[2] & p[1] & g[0]);\n\nassign s = a + b + {1'b0, c};\n\nassign carry_out = c[7];\n\nendmodule\n\nmodule overflow_detector (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] s,\n    output overflow\n);\n\nassign overflow = ((a[7] == b[7]) && (a[7] != s[7]));\n\nendmodule\n\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\ncarry_lookahead_adder adder(\n    .a(a),\n    .b(b),\n    .s(s),\n    .carry_out()\n);\n\noverflow_detector detector(\n    .a(a),\n    .b(b),\n    .s(s),\n    .overflow(overflow)\n);\n\nendmodule",
        "module_name": "carry_lookahead_adder",
        "module_hash": "9467720f15bad8d7e91c841fcd48cdf5",
        "dataset_index": 8253
      },
      "calculator_eb1d6c05": {
        "rtl_code": "module calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    input [3:0] sel,\n    output reg [7:0] out,\n    output reg overflow\n);\n\nwire [7:0] a_mag, b_mag; // Removed 'add_result' as it is a wire and cannot be assigned to\nreg [7:0] add_result; // Declared 'add_result' as a reg since it is assigned to\n\nreg [1:0] op_sel;\n\n// Convert a and b to sign-magnitude format\nassign a_mag = (a[7] == 1) ? {1'b0, ~a[7:0] + 1'b1} : a;\nassign b_mag = (b[7] == 1) ? {1'b0, ~b[7:0] + 1'b1} : b;\n\n// Select operation based on op input\nalways @(op, sel) begin\n    case (sel)\n        2'b00: op_sel = op; // Output result of selected operation\n        2'b01: op_sel = 2'b00; // Addition\n        2'b10: op_sel = 2'b01; // Subtraction\n        2'b11: op_sel = 2'b10; // Multiplication\n        default: op_sel = 2'b11; // Division\n    endcase\nend\n\n// Perform selected operation using 8-bit adder\nalways @(a_mag, b_mag, op_sel) begin\n    case (op_sel)\n        2'b00: add_result = a_mag + b_mag; // Addition\n        2'b01: add_result = a_mag - b_mag; // Subtraction\n        2'b10: add_result = a_mag * b_mag; // Multiplication\n        2'b11: add_result = a_mag / b_mag; // Division\n    endcase\nend\n\n// Check for signed overflow\nalways @(add_result) begin\n    if (add_result[7] != add_result[6]) begin\n        overflow = 1'b1;\n    end else begin\n        overflow = 1'b0;\n    end\nend\n\n// Output result of selected operation or previous operation\nalways @(op_sel, add_result) begin\n    if (sel < 4'd4) begin\n        out = add_result;\n    end else begin\n        out = out;\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "eb1d6c0593990aae84b6be47c8b2cf54",
        "dataset_index": 2854
      },
      "my__d849331c": {
        "rtl_code": "\nmodule my_module (\n    input wire reset,\n    input wire set,\n    input wire d,\n    input wire data_en,\n    input wire notifier,\n    input wire vpwr,\n    input wire vgnd,\n    output wire q,\n    input wire clk\n);\n\n    wire d_wire;\n    wire data_en_wire;\n    wire notifier_wire;\n    wire vpwr_wire;\n    wire vgnd_wire;\n    wire q_wire;\n    wire clk_wire;\n\n    assign d_wire = (data_en == 1'b1) ? q_wire : d;\n    assign data_en_wire = (notifier == 1'b1) ? 1'bx : data_en;\n    assign notifier_wire = (notifier == 1'b1) ? 1'b0 : notifier;\n    assign vpwr_wire = (vpwr == 1'b0) ? 1'b1 : vpwr;\n    assign vgnd_wire = (vgnd == 1'b0) ? 1'b0 : vgnd;\n    assign q = q_wire;\n\n    reg q_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            q_reg <= 1'b0;\n        end else if (set) begin\n            q_reg <= 1'b1;\n        end else if (data_en == 1'b1) begin\n            q_reg <= q_wire;\n        end else begin\n            q_reg <= d_wire;\n        end\n    end\n\n    assign q_wire = q_reg;\n    assign clk_wire = clk;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "d849331c8aeffc968d548a32d0981067",
        "dataset_index": 6829
      },
      "nand3_gate_61ea7da6": {
        "rtl_code": "\nmodule nand3_gate(input A, input B, input C, output Y);\n\n    // Inputs are registered\n    reg A_reg;\n    reg B_reg;\n    reg C_reg;\n\n    // Outputs are wires\n    wire Y_and;\n\n    // Connect to power and ground\n    supply1 VDD;\n    supply0 VSS;\n\n    // Instantiate buffers\n    buf A_buf (A, A_reg);\n    buf B_buf (B, B_reg);\n    buf C_buf (C, C_reg);\n    buf Y_buf (Y_and, Y);\n\n    // Instantiate NAND gates\n    nand (Y_and, A_reg, B_reg, C_reg); // 3-input NAND gate\n\nendmodule",
        "module_name": "nand3_gate",
        "module_hash": "61ea7da6556ad6b4f91631036282577d",
        "dataset_index": 9359
      },
      "synth_ram #_9af3ae34": {
        "rtl_code": "module synth_ram #( parameter integer WORDS = 64) (\n  input clk,\n  input ena,\n  input [3:0] wen,\n  input [21:0] addr,\n  input [31:0] wdata,\n  output[31:0] rdata\n);\n\n  reg [31:0] rdata;\n  reg [31:0] mem [0:WORDS-1];\n\n  always @(posedge clk) begin\n          if (ena == 1'b1) begin\n                  rdata <= mem[addr];\n                  if (wen[0]) mem[addr][ 7: 0] <= wdata[ 7: 0];\n                  if (wen[1]) mem[addr][15: 8] <= wdata[15: 8];\n                  if (wen[2]) mem[addr][23:16] <= wdata[23:16];\n                  if (wen[3]) mem[addr][31:24] <= wdata[31:24];\n          end\n  end\n        \nendmodule\n",
        "module_name": "synth_ram #",
        "module_hash": "9af3ae34ef6b8768e471c0ddac734f36",
        "dataset_index": 5001
      },
      "borderscan_97aeedd1": {
        "rtl_code": "module borderscan(\n    input clk,\n    input xstart,\n    input xend,\n    input [9:0] realy,\n    output q\n);\n\n    parameter SCREENWIDTH = 1024;\n    parameter SCREENHEIGHT = 768;\n\n    assign q = (xstart == 0 && realy == 0) || \n               (xend == SCREENWIDTH - 1 && realy == 0) || \n               (xstart == 0 && realy == SCREENHEIGHT - 1) || \n               (xend == SCREENWIDTH - 1 && realy == SCREENHEIGHT - 1) || \n               (realy > 0 && realy < SCREENHEIGHT - 1 && (xstart == 0 || xend == SCREENWIDTH - 1));\n\nendmodule",
        "module_name": "borderscan",
        "module_hash": "97aeedd15f3f630c354d01e6dc7ecaed",
        "dataset_index": 16424
      },
      "AGrises_638b6c5c": {
        "rtl_code": "\n\nmodule AGrises (\n\tinput clk,\n\tinput rst,\n\n\toutput [DATA_WIDTH-1:0] data_fifo_out,\n\toutput data_valid_fifo_out,\n\tinput wire [FIFO_DEPTH_LOG2:0] usedw_fifo_out,\n\t\n\tinput wire [DATA_WIDTH-1:0] data_fifo_in,\n\toutput read_fifo_in,\n\tinput wire [FIFO_DEPTH_LOG2:0] usedw_fifo_in,\n\n\tinput start,\n\toutput endf\n);\n   \n\tparameter DATA_WIDTH=32;\n\tparameter FIFO_DEPTH = 256;\n\tparameter FIFO_DEPTH_LOG2 = 8;\n\t\n\treg [1:0] stages;\n\twire stages_init;\n\treg [1:0] run;\n\t\n\treg [14:0] grey_aux;\n\treg [7:0] grey;\n\t\n\treg [18:0] pixel_counter;\n\t\n\talways @ (posedge clk or posedge rst) begin\n\t\tif (rst == 1) begin\n\t\t\trun <= 0;\n\t\tend else begin\n\t\t\tif (start == 1) begin\n\t\t\t\trun <= 1;\n\t\t\tend else begin\n\t\t\t\tif (pixel_counter == 0) begin\n\t\t\t\t\trun <= 2;\n\t\t\t\tend\n\t\t\t\tif (endf == 1) begin\n\t\t\t\t\trun <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\talways @ (posedge clk) begin\n\t\tif (start == 1) begin\n\t\t\tpixel_counter <= 384000;\n\t\tend else begin\n\t\t\tif (data_valid_fifo_out) begin\n\t\t\t\tpixel_counter <= pixel_counter - 1;\n\t\t\tend\n\t\tend\n\tend\n\t\n\talways @ (posedge clk) begin\n      if (start == 1) begin\n\t\t\tstages <= 0;\n\t\tend else begin\n\t\t\tif (stages_init == 1) begin\n\t\t\t\tstages <= 1;\n\t\t\t\tgrey_aux = data_fifo_in[23:16]*8'd30 + data_fifo_in[15:8]*8'd59 + data_fifo_in[7:0]*8'd11;\n\t\t\t\tgrey = 8'd2 * grey_aux[14:8];\n\t\t\t\tgrey = grey + (grey_aux[14:8] / 8'd2);\n\t\t\tend else begin\n\t\t\t\tif (stages == 1) begin\n\t\t\t\t\tstages <= 2;\n\t\t\t\t\tgrey = grey + (grey_aux[14:8] / 8'd19);\n\t\t\t\t\tgrey = grey + (grey_aux[7:0] / 8'd64);\n\t\t\t\tend else begin\n\t\t\t\t\tif (stages == 2) begin\n\t\t\t\t\t\tstages <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign stages_init = ((usedw_fifo_in > 32)|(pixel_counter < 33)) & (usedw_fifo_out < FIFO_DEPTH) & (run == 1) & (stages == 0);\n\n\tassign read_fifo_in = (run == 1) & (stages == 1);\n\n\tassign data_fifo_out = {8'd0,{3{grey}}};\n\tassign data_valid_fifo_out = (run == 1) & (stages == 2);\n\t\n\tassign endf = (run == 2);\n\t\nendmodule\n",
        "module_name": "AGrises",
        "module_hash": "638b6c5cde106d7696a579bb3c3ad738",
        "dataset_index": 12509
      },
      "controlrecorder_94972aaa": {
        "rtl_code": "\nmodule controlrecorder(clock, reset, go, keys, countdown, mode, num_keys, cyclecounter, cell_number);\n\n  input clock, reset, go;\n  input [3:0] keys;\n  input [25:0] countdown;\n  output reg [1:0] mode;\n  output reg [4:0] num_keys;\n  output reg [25:0] cyclecounter;\n  output reg [4:0] cell_number;\n\n  reg [3:0] prev_keys;\n  reg [2:0] current_state, next_state;\n  reg [25:0] countdown_register;\n  reg [31:0] keystrokes[0:30];\n  integer i;\n\n  localparam STATIONARY = 3'b000, \n             START_RECORD = 3'b001,\n             RECORDING = 3'b010, \n             WAITING_FOR_PLAYBACK = 3'b011, \n             START_PLAYBACK = 3'b100, \n             PLAYBACK = 3'b101;\n\n  always @(posedge clock) begin \n    if (!reset) begin \n      current_state <= STATIONARY;\n      num_keys <= 5'b0;\n      cyclecounter <= 26'b0;\n      cell_number <= 5'b0;\n    end \n    else begin \n      current_state <= next_state;\n      case (current_state)\n        STATIONARY: begin \n          if (go) begin \n            next_state <= START_RECORD;\n          end \n          else begin \n            next_state <= STATIONARY;\n          end \n        end \n        START_RECORD: begin \n          next_state <= RECORDING;\n          cyclecounter <= 26'b0;\n          num_keys <= 5'b0;\n          cell_number <= 5'b0;\n        end \n        RECORDING: begin \n          if (num_keys == 5'b11111) begin \n            next_state <= WAITING_FOR_PLAYBACK;\n            cyclecounter <= 26'b0;\n            cell_number <= 5'b0;\n          end \n          else if (prev_keys != keys) begin \n            keystrokes[num_keys] <= keys;\n            num_keys <= num_keys + 1'b1;\n            cyclecounter <= 26'b0;\n            cell_number <= cell_number + 1'b1;\n          end \n          else if (cyclecounter == 26'b10111110101111000001111111) begin \n            cyclecounter <= 26'b0;\n            cell_number <= cell_number + 1'b1;\n          end \n          else begin \n            cyclecounter <= cyclecounter + 1'b1;\n          end \n          next_state <= RECORDING;\n        end \n        WAITING_FOR_PLAYBACK: begin \n          if (!go) begin \n            next_state <= START_PLAYBACK;\n          end \n          else begin \n            next_state <= WAITING_FOR_PLAYBACK;\n          end \n        end \n        START_PLAYBACK: begin \n          next_state <= PLAYBACK;\n          countdown_register <= countdown;\n          i <= 0;\n          cell_number <= 5'b0;\n        end \n        PLAYBACK: begin \n          if (countdown_register == 26'b0) begin \n            if (i == num_keys) begin \n              next_state <= STATIONARY;\n            end\n            else begin \n              prev_keys <= keystrokes[i];\n              countdown_register <= countdown;\n              i <= i + 1;\n              cell_number <= cell_number + 1'b1;\n            end \n          end \n          else begin \n            countdown_register <= countdown_register - 1'b1;\n          end \n          next_state <= PLAYBACK;\n        end \n      endcase \n    end \n  end \n\n  always @(*) begin \n    case (current_state)\n      RECORDING: begin \n        mode <= 2'b01;\n      end\n      PLAYBACK: begin \n        mode <= 2'b10;\n      end \n      default: begin \n        mode <= 2'b00;\n      end \n    endcase \n  end \nendmodule",
        "module_name": "controlrecorder",
        "module_hash": "94972aaa718f17d053ec8b4042b0cd20",
        "dataset_index": 5046
      },
      "DebugIR_2012c0ad": {
        "rtl_code": "module DebugIR (\n    input wire clk,\n    input wire rst,\n    input wire ir,\n    output reg[3:0] mode,\n    output reg showName,\n    output reg err,\n    output wire stateOut,\n    output reg[1:0] cpuClkMode,\n    output reg[3:0] numberPressedData,\n    output reg numberPressed\n    );\n\nreg[31:0] irRead; reg[5:0] irDataPos; reg ir0, ir1, ir2; always @(posedge clk) begin\n    if (rst) begin\n        ir0 <= 1'b0;\n        ir1 <= 1'b0;\n        ir2 <= 1'b0;\n    end\n    else begin\n        ir0 <= ir;\n        ir1 <= ir0;\n        ir2 <= ir1;\n    end\nend\n\nwire irPosEdge = !ir2 && ir1;\nwire irNegEdge = ir2 && !ir1;\nwire irChange = irPosEdge || irNegEdge;\n\nreg[10:0] counter1; reg[8:0] counter2; always @(posedge clk) begin\n    if (rst)\n        counter1 <= 11'b0;\n    else if (irChange)\n        counter1 <= 11'b0;\n    else if (counter1 == 11'd1750)\n        counter1 <= 11'b0;\n    else\n        counter1 <= counter1 + 11'b1;\nend\nalways @(posedge clk) begin\n    if (rst)\n        counter2 <= 9'b0;\n    else if (irChange)\n        counter2 <= 9'b0;\n    else if (counter1 == 11'd1750)\n        counter2 <= counter2 + 9'b1;\nend\n\nwire check9ms = (217 < counter2) && (counter2 < 297); wire check4ms = (88 < counter2)  && (counter2 < 168); wire high     = (6 < counter2)   && (counter2 < 26);  wire low      = (38 < counter2)  && (counter2 < 58);  parameter   CHANNEL_MINUS = 8'hA2,\n            CHANNEL = 8'h62,\n            CHANNEL_PLUS = 8'hE2,\n            PLAY = 8'hC2,\n            EQ = 8'h90,\n            N0 = 8'h68,\n            N1 = 8'h30,\n            N2 = 8'h18,\n            N3 = 8'h7A,\n            N4 = 8'h10,\n            N5 = 8'h38,\n            N6 = 8'h5A,\n            N7 = 8'h42,\n            N8 = 8'h4A,\n            N9 = 8'h52;\n\nparameter   IDLE = 3'b000,\n            LEADING_9MS = 3'b001,\n            LEADING_4MS = 3'b010,\n            DATA_READ   = 3'b100;\n\nreg[2:0] state;\nreg[2:0] nextState;\n\nalways @(posedge clk) begin\n    if (rst)\n        state <= IDLE;\n    else\n        state <= nextState;\nend\n\nalways @(*) begin\n    case (state)\n        IDLE:\n            if (ir1)\n                nextState = LEADING_9MS;\n            else\n                nextState = IDLE;\n        LEADING_9MS:\n            if (irNegEdge) begin\n                if (check9ms)\n                    nextState = LEADING_4MS;\n                else\n                    nextState = IDLE;\n            end else\n                nextState = LEADING_9MS;\n        LEADING_4MS:\n            if (irPosEdge) begin\n                if (check4ms)\n                    nextState = DATA_READ;\n                else\n                    nextState = IDLE;\n            end else\n                nextState = LEADING_4MS;\n        DATA_READ:\n            if ((irDataPos == 6'd32) && !ir2 && !ir1)\n                nextState = IDLE;\n            else if (err)\n                nextState = IDLE;\n            else\n                nextState = DATA_READ;\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        irDataPos <= 6'b0;\n        irRead <= 32'b0;\n        err <= 1'b0;\n    end\n    else if (state == IDLE) begin\n        irDataPos <= 6'b0;\n        irRead <= 32'b0;\n        err <= 1'b0;\n    end\n    else if (state == DATA_READ) begin\n        if (irNegEdge) begin\n            if (!high)\n                err <= 1'b1;\n        end else if (irPosEdge) begin\n            if (high)\n                irRead[0] <= 1'b0;\n            else if (low)\n                irRead[0] <= 1'b1;\n            else\n                err <= 1'b1;\n            irRead[31:1] <= irRead[30:0];\n            irDataPos <= irDataPos + 6'b1;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        showName <= 1'b0;\n        mode <= 4'b0;\n        cpuClkMode <= 2'd0;\n        numberPressed <= 0;\n        numberPressedData <= 4'd0;\n    end else if ((irDataPos == 6'd32) && !ir1 && ir2) begin\n        case (irRead[15:8])\n            CHANNEL:\n                showName <= !showName;\n            CHANNEL_PLUS:\n                if (mode < 4'd13)\n                    mode <= mode + 1;\n                else\n                    mode <= 4'd0;\n            CHANNEL_MINUS:\n                if (mode > 4'd0)\n                    mode <= mode - 1;\n                else\n                    mode <= 4'd13;\n            PLAY:\n                cpuClkMode <= cpuClkMode ^ 2'b10;\n            EQ:\n                cpuClkMode <= cpuClkMode ^ 2'b01;\n            N0: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd0;\n            end\n            N1: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd1;\n            end\n            N2: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd2;\n            end\n            N3: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd3;\n            end\n            N4: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd4;\n            end\n            N5: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd5;\n            end\n            N6: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd6;\n            end\n            N7: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd7;\n            end\n            N8: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd8;\n            end\n            N9: begin\n                numberPressed <= 1;\n                numberPressedData <= 4'd9;\n            end\n        endcase\n    end\n    if (numberPressed)\n        numberPressed <= 0;\nend\n\nassign stateOut = (irDataPos == 6'd32) && (!ir2) && (!ir1);\nendmodule\n",
        "module_name": "DebugIR",
        "module_hash": "2012c0add5a30513272b0930a73c2abc",
        "dataset_index": 20454
      },
      "alu_6454194b": {
        "rtl_code": "module alu(\n\t\tinput\t\t[3:0]\tctl,\n\t\tinput\t\t[31:0]\ta, b,\n\t\toutput reg\t[31:0]\tout,\n\t\toutput\t\t\t\tzero,\n\t\toutput\t\t\t\toflow);\n\n\twire [31:0] sub_ab;\n\twire [31:0] add_ab;\n\twire \t\toflow_add;\n\twire \t\toflow_sub;\n\twire \t\tslt;\n\n\tassign zero = (0 == out);\n\n\tassign sub_ab = a - b;\n\tassign add_ab = a + b;\n\n\tassign oflow_add = (a[31] == b[31] && add_ab[31] != a[31]) ? 1 : 0;\n\tassign oflow_sub = (a[31] == b[31] && sub_ab[31] != a[31]) ? 1 : 0;\n\n\tassign oflow = (ctl == 4'b0010) ? oflow_add : oflow_sub;\n\n\tassign slt = oflow_sub ? ~(a[31]) : a[31];\n\n\talways @(*) begin\n\t\tcase (ctl)\n\t\t\t4'd2:  out <= add_ab;\t\t\t\t\n\t\t\t4'd0:  out <= a & b;\t\t\t\t\n\t\t\t4'd12: out <= ~(a | b);\t\t\t\t\n\t\t\t4'd1:  out <= a | b;\t\t\t\t\n\t\t\t4'd7:  out <= {{31{1'b0}}, slt};\t\n\t\t\t4'd6:  out <= sub_ab;\t\t\t\t\n\t\t\t4'd13: out <= a ^ b;\t\t\t\t\n\t\t\tdefault: out <= 0;\n\t\tendcase\n\tend\n\nendmodule",
        "module_name": "alu",
        "module_hash": "6454194b9851cd669e919f5cf862da4b",
        "dataset_index": 11023
      },
      "hex_7_segment_28af5c10": {
        "rtl_code": "module hex_7_segment(\n\tinput wire [15:0] x,\n\tinput wire clk,\n\tinput wire clr,\n\toutput reg [6:0] a_to_g,\n\toutput reg [3:0] an\n);\n\nwire [1:0] s;\nreg [3:0] digit;\nwire [3:0] aen;\nreg [18:0] clkdiv;\n\nassign s = clkdiv[18:17];\nassign aen = 4'b1111;\n\nalways @(*)\n\tcase (s)\n\t\t0: digit = x[3:0];\n\t\t1: digit = x[7:4];\n\t\t2: digit = x[11:8];\n\t\t3: digit = x[15:12];\n\t\tdefault: digit = x[3:0];\n\tendcase\n\nalways @(*)\n\tcase (digit)\n\t\t'h0: a_to_g = 7'b0000001;\n\t\t'h1: a_to_g = 7'b1001111;\n\t\t'h2: a_to_g = 7'b0010010;\n\t\t'h3: a_to_g = 7'b0000110;\n\t\t'h4: a_to_g = 7'b1001100;\n\t\t'h5: a_to_g = 7'b0100100;\n\t\t'h6: a_to_g = 7'b0100000;\n\t\t'h7: a_to_g = 7'b0001111;\n\t\t'h8: a_to_g = 7'b0000000;\n\t\t'h9: a_to_g = 7'b0000100;\n\t\t'ha: a_to_g = 7'b0001000;\n\t\t'hb: a_to_g = 7'b1100000;\n\t\t'hc: a_to_g = 7'b0110001;\n\t\t'hd: a_to_g = 7'b1000010;\n\t\t'he: a_to_g = 7'b0110000;\n\t\t'hf: a_to_g = 7'b0111000;\n\t\tdefault: a_to_g = 7'b0000001;\n\tendcase\n\nalways @(*)\n\tbegin\n\t\tan = 4'b0000;\n\t\tif (aen[s] == 1)\n\t\t\tan[s] = 1;\n\tend\n\nalways @(posedge clk or posedge clr)\n\tbegin\n\t\tif (clr == 1)\n\t\t\tclkdiv <= 0;\n\t\telse\n\t\t\tclkdiv <= clkdiv + 1;\n\tend\n\nendmodule\n",
        "module_name": "hex_7_segment",
        "module_hash": "28af5c106109ebea321302187740f2ba",
        "dataset_index": 23531
      },
      "profibus_slave_28563e08": {
        "rtl_code": "\nmodule profibus_slave (\n  input clk,\n  input rst,\n  input enable,\n  input req,\n  input [7:0] data_in,\n  output ack,\n  output [7:0] data_out\n);\n\n  reg [7:0] internal_data;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      internal_data <= 0;\n    end else if (enable) begin\n      if (req) begin\n        internal_data <= data_in;\n      end\n    end\n  end\n\n  assign ack = enable & req;\n  assign data_out = internal_data;\n\nendmodule\n\nmodule profibus_master (\n  input clk,\n  input rst,\n  input enable,\n  output reg req,\n  input ack,\n  output reg [7:0] data_out,\n  input [7:0] data_in\n);\n\n  reg [7:0] internal_data;\n  reg [2:0] state;\n\n  parameter IDLE = 3'b000;\n  parameter SEND_REQ = 3'b001;\n  parameter WAIT_ACK = 3'b010;\n  parameter READ_DATA = 3'b011;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      req <= 0;\n      internal_data <= 0;\n      state <= IDLE;\n    end else if (enable) begin\n      case (state)\n        IDLE: begin\n          req <= 0;\n          if (data_in != 0) begin\n            internal_data <= data_in;\n            state <= SEND_REQ;\n          end\n        end\n        SEND_REQ: begin\n          req <= 1;\n          state <= WAIT_ACK;\n        end\n        WAIT_ACK: begin\n          if (ack) begin\n            state <= READ_DATA;\n          end\n        end\n        READ_DATA: begin\n          data_out <= internal_data;\n          state <= IDLE;\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "profibus_slave",
        "module_hash": "28563e08fc47a397073d55b39080fdd4",
        "dataset_index": 16009
      },
      "clk_generator_0f6cf7fb": {
        "rtl_code": "\nmodule clk_generator(\n    input clk,\n    input clk_ena,\n    input rstn,\n    output reg clk_out\n);\n\nparameter BAUDRATE = 8;\nparameter M2 = 4;\n\nlocalparam COUNTER_WIDTH = $clog2(BAUDRATE);\n\nreg [COUNTER_WIDTH-1:0] divcounter = 0;\n\n// Counter\nalways @(posedge clk or negedge rstn) begin\n    if (!rstn) begin\n        divcounter <= 0;\n    end\n    else if (clk_ena) begin\n        divcounter <= (divcounter == BAUDRATE - 1) ? 0 : divcounter + 1;\n    end\n    else begin\n        divcounter <= BAUDRATE - 1;\n    end\nend\n\n// Output\nalways @(posedge clk) begin\n    clk_out <= (divcounter == M2) ? clk_ena : 0;\nend\n\nendmodule\n",
        "module_name": "clk_generator",
        "module_hash": "0f6cf7fbf8e1a2d412286bc1b5eb58a4",
        "dataset_index": 19997
      },
      "motor_control_82197f67": {
        "rtl_code": "module motor_control (\n  input clk,\n  input rst,\n  input pwm_in,\n  input dir,\n  input [7:0] speed,\n  output pwm_out,\n  output [1:0] motor_a_b\n);\n\n  reg [7:0] counter;\n  reg pwm_out;\n  reg [1:0] motor_a_b;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      counter <= 8'd0;\n      pwm_out <= 1'b0;\n      motor_a_b <= 2'b00;\n    end else begin\n      counter <= counter + 1;\n      if (counter >= speed) begin\n        counter <= 8'd0;\n        pwm_out <= ~pwm_out;\n      end\n      if (dir) begin\n        motor_a_b <= 2'b10;\n      end else begin\n        motor_a_b <= 2'b01;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "motor_control",
        "module_hash": "82197f6793b7d0fba19b7ec449bf67a7",
        "dataset_index": 8244
      },
      "tri_buf_16260cf3": {
        "rtl_code": "\nmodule tri_buf (\n    inout wire A,\n    output wire Z,\n    input wire TE_B\n);\n\n    assign Z = (TE_B) ? 1'b0 : A;\n\nendmodule",
        "module_name": "tri_buf",
        "module_hash": "16260cf33f71700ad8c4912f5bc8feff",
        "dataset_index": 5009
      },
      "decoder_4to16_7430f24e": {
        "rtl_code": "\nmodule decoder_4to16 (\n    input enable,\n    input [3:0] select,\n    output [15:0] out\n);\n\n    assign out[0] = (enable && (select == 4'b0000)) ? 1'b1 : 1'b0;\n    assign out[1] = (enable && (select == 4'b0001)) ? 1'b1 : 1'b0;\n    assign out[2] = (enable && (select == 4'b0010)) ? 1'b1 : 1'b0;\n    assign out[3] = (enable && (select == 4'b0011)) ? 1'b1 : 1'b0;\n    assign out[4] = (enable && (select == 4'b0100)) ? 1'b1 : 1'b0;\n    assign out[5] = (enable && (select == 4'b0101)) ? 1'b1 : 1'b0;\n    assign out[6] = (enable && (select == 4'b0110)) ? 1'b1 : 1'b0;\n    assign out[7] = (enable && (select == 4'b0111)) ? 1'b1 : 1'b0;\n    assign out[8] = (enable && (select == 4'b1000)) ? 1'b1 : 1'b0;\n    assign out[9] = (enable && (select == 4'b1001)) ? 1'b1 : 1'b0;\n    assign out[10] = (enable && (select == 4'b1010)) ? 1'b1 : 1'b0;\n    assign out[11] = (enable && (select == 4'b1011)) ? 1'b1 : 1'b0;\n    assign out[12] = (enable && (select == 4'b1100)) ? 1'b1 : 1'b0;\n    assign out[13] = (enable && (select == 4'b1101)) ? 1'b1 : 1'b0;\n    assign out[14] = (enable && (select == 4'b1110)) ? 1'b1 : 1'b0;\n    assign out[15] = (enable && (select == 4'b1111)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "decoder_4to16",
        "module_hash": "7430f24ebd3e91a1b73e750bbd243a01",
        "dataset_index": 6351
      },
      "counter_5daa89b6": {
        "rtl_code": "module counter(input clk, rst, en, output reg [3:0] out);\n    always @(posedge clk) begin\n        if (rst) begin\n            out <= 0; // reset to 0 when rst is asserted\n        end else if (en) begin\n            out <= out + 1; // increment count value by 1 on each rising edge of clk when en is asserted\n        end\n    end\nendmodule",
        "module_name": "counter",
        "module_hash": "5daa89b6077d9ad3de80887f810e408b",
        "dataset_index": 4278
      },
      "pfpu_above_e006097c": {
        "rtl_code": "\n\nmodule pfpu_above(\n\tinput sys_clk,\n\tinput alu_rst,\n\n\tinput [31:0] a,\n\tinput [31:0] b,\n\tinput valid_i,\n\n\toutput [31:0] r,\n\toutput reg valid_o\n);\n\nreg r_one;\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tvalid_o <= 1'b0;\n\telse\n\t\tvalid_o <= valid_i;\n\tcase({a[31], b[31]})\n\t\t2'b00: r_one <= a[30:0] > b[30:0];\n\t\t2'b01: r_one <= 1'b1;\n\t\t2'b10: r_one <= 1'b0;\n\t\t2'b11: r_one <= a[30:0] < b[30:0];\n\tendcase\nend\n\nassign r = r_one ? 32'h3f800000: 32'h00000000;\n\nendmodule\n",
        "module_name": "pfpu_above",
        "module_hash": "e006097ce064298c0b2945e906271f92",
        "dataset_index": 7759
      },
      "addsub_32_9f589dda": {
        "rtl_code": "module addsub_32 (\n    input signed [31:0] A,\n    input signed [31:0] B,\n    input C,\n    output signed [31:0] S,\n    output V\n);\n\n    wire [31:0] notB;\n    wire [31:0] carryIn;\n    wire [31:0] carryOut;\n    wire [31:0] sum;\n    wire [31:0] notSum;\n    wire overflow;\n\n    assign notB = ~B;\n    assign carryIn = {32{C}};\n    assign {carryOut, sum} = A + notB + carryIn;\n    assign notSum = ~sum;\n    assign overflow = (A[31] == B[31] && A[31] != sum[31]) ? 1 : 0;\n\n    assign S = (C == 1) ? sum : (notSum + 1);\n    assign V = overflow;\n\nendmodule",
        "module_name": "addsub_32",
        "module_hash": "9f589ddae2a1ebe46ccc12f563f4cdea",
        "dataset_index": 1114
      },
      "step_id_dea67552": {
        "rtl_code": "module step_id(inst, ena_, cond_dout,\n    rdy_nop_, rdy_cpf_, rdy_cpt_, rdy_ld_, rdy_st_, rdy_clr_, rdy_im_, rdy_tce_, rdy_ts_, rdy_add_, rdy_sub_);\n    input [7:0] inst;\n    input ena_;\n    input cond_dout;\n    output rdy_nop_, rdy_cpf_, rdy_cpt_, rdy_ld_, rdy_st_, rdy_clr_, rdy_im_, rdy_tce_, rdy_ts_, rdy_add_, rdy_sub_;\n\n    wire cond_ = inst[7] ^ cond_dout;\n    wire [6:0] inst_cond = inst[6:0] & {7{~(cond_ | ena_)}};\n\n    assign rdy_nop_ = inst_cond[6:0] != 7'b0000000 || ena_;\n    assign rdy_cpf_ = inst_cond[6:4] != 3'b010 || inst_cond[3:0] == 4'b0000;\n    assign rdy_cpt_ = inst_cond[6:4] != 3'b011 || inst_cond[3:0] == 4'b0000;\n    assign rdy_ld_  = {inst_cond[6:2], inst_cond[0]} != {5'b10001, 1'b0};\n    assign rdy_st_  = {inst_cond[6:2], inst_cond[0]} != {5'b10001, 1'b1};\n    assign rdy_clr_ = inst_cond != 7'b1010000;\n    assign rdy_im_  = inst_cond[6:5] != 2'b11;\n    assign rdy_tce_ = inst_cond != 7'b0001100;\n    assign rdy_ts_  = {inst_cond[6], inst_cond[3:0]} != {1'b0, 4'b0000} || inst_cond[5:4] == 2'b00;\n    assign rdy_add_ = inst_cond != 7'b1010110;\n    assign rdy_sub_ = inst_cond != 7'b1010111;\n\nendmodule",
        "module_name": "step_id",
        "module_hash": "dea67552d19df0d9312c1c5a7d9b3591",
        "dataset_index": 2188
      },
      "maj3_2_8bd26cea": {
        "rtl_code": "module maj3_2 (\n    input A,\n    input B,\n    input C,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    wire majority;\n    maj3 base (\n        .X(majority),\n        .A(A),\n        .B(B),\n        .C(C),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\n    assign X = (majority == 1'b1) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule maj3 (\n    output X,\n    input A,\n    input B,\n    input C,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    assign X = (A & B) | (A & C) | (B & C);\n\nendmodule",
        "module_name": "maj3_2",
        "module_hash": "8bd26cead41c340afceba727afbc5c46",
        "dataset_index": 9164
      },
      "my__4540dc69": {
        "rtl_code": "module my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign X = (A1 & A2 & A3 & ~B1 & ~B2 & VPWR & ~VGND & VPB & ~VNB);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "4540dc696c83db13e5de7f1ca71df532",
        "dataset_index": 2499
      },
      "binary_search_953eff33": {
        "rtl_code": "\nmodule binary_search(\n    input clk,\n    input reset,\n    input [31:0] target,\n    input [31:0] data, // Change to packed array\n    output reg found,\n    output reg [4:0] index\n);\n\n    reg [4:0] low = 0;\n    reg [4:0] high = 31;\n    reg [4:0] mid;\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            found <= 0;\n            index <= -1;\n            low <= 0;\n            high <= 31;\n        end else begin\n            if (low > high) begin\n                found <= 0;\n                index <= -1;\n            end else begin\n                mid <= (low + high) / 2;\n                if (data[mid] == target) begin\n                    found <= 1;\n                    index <= mid;\n                end else if (data[mid] > target) begin\n                    high <= mid - 1;\n                end else begin\n                    low <= mid + 1;\n                end\n            end\n        end\n    end\n\nendmodule\n",
        "module_name": "binary_search",
        "module_hash": "953eff33e8a1988c0e657eceff6f8a78",
        "dataset_index": 17689
      },
      "unknown_module_4f8a1ae8": {
        "rtl_code": "\nmodule\tprefetch(i_clk, i_rst, i_new_pc, i_clear_cache, i_stalled_n, i_pc,\n\t\t\to_i, o_pc, o_valid, o_illegal,\n\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,\n\t\t\ti_wb_ack, i_wb_stall, i_wb_err, i_wb_data);\n\tparameter\t\tADDRESS_WIDTH=32;\n\tlocalparam\t\tAW=ADDRESS_WIDTH;\n\tinput\twire\t\t\ti_clk, i_rst, i_new_pc, i_clear_cache,\n\t\t\t\t\ti_stalled_n;\n\tinput\twire\t[(AW-1):0]\ti_pc;\n\toutput\treg\t[31:0]\t\to_i;\n\toutput\twire\t[(AW-1):0]\to_pc;\n\toutput\treg\t\t\to_valid;\n\toutput\treg\t\t\to_wb_cyc, o_wb_stb;\n\toutput\twire\t\t\to_wb_we;\n\toutput\treg\t[(AW-1):0]\to_wb_addr;\n\toutput\twire\t[31:0]\t\to_wb_data;\n\tinput\twire\t\t\ti_wb_ack, i_wb_stall, i_wb_err;\n\tinput\twire\t[31:0]\t\ti_wb_data;\n\toutput\treg\t\t\to_illegal;\n\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = 32'h0000;\n\n\tinitial\to_wb_cyc = 1'b0;\n\tinitial\to_wb_stb = 1'b0;\n\tinitial\to_wb_addr= 0;\n\talways @(posedge i_clk)\n\t\tif ((i_rst)||(i_wb_ack)||(i_wb_err))\n\t\tbegin\n\t\t\to_wb_cyc <= 1'b0;\n\t\t\to_wb_stb <= 1'b0;\n\t\tend else if ((!o_wb_cyc)&&((i_stalled_n)||(!o_valid)||(i_new_pc)))\n\t\tbegin o_wb_cyc <= 1'b1;\n\t\t\to_wb_stb <= 1'b1;\n\t\tend else if (o_wb_cyc) begin\n\t\t\tif (!i_wb_stall)\n\t\t\t\to_wb_stb <= 1'b0;\n\t\tend\n\n\treg\tinvalid;\n\tinitial\tinvalid = 1'b0;\n\talways @(posedge i_clk)\n\t\tif (!o_wb_cyc)\n\t\t\tinvalid <= 1'b0;\n\t\telse if ((i_new_pc)||(i_clear_cache))\n\t\t\tinvalid <= 1'b1;\n\n\talways @(posedge i_clk)\n\t\tif (i_new_pc)\n\t\t\to_wb_addr <= i_pc;\n\t\telse if ((!o_wb_cyc)&&(i_stalled_n)&&(!invalid))\n\t\t\to_wb_addr <= o_wb_addr + 1'b1;\n\n\talways @(posedge i_clk)\n\t\tif ((o_wb_cyc)&&(i_wb_ack))\n\t\t\to_i <= i_wb_data;\n\n\tinitial o_valid   = 1'b0;\n\tinitial o_illegal = 1'b0;\n\talways @(posedge i_clk)\n\t\tif ((i_rst)||(i_new_pc))\n\t\tbegin\n\t\t\to_valid   <= 1'b0;\n\t\t\to_illegal <= 1'b0;\n\t\tend else if ((o_wb_cyc)&&((i_wb_ack)||(i_wb_err)))\n\t\tbegin\n\t\t\to_valid   <= (!invalid);\n\t\t\to_illegal <= ( i_wb_err)&&(!invalid);\n\t\tend else if ((i_stalled_n)||(i_clear_cache)||(i_new_pc))\n\t\tbegin\n\t\t\to_valid <= 1'b0;\n\t\t\to_illegal <= 1'b0;\n\t\tend\n\n\tassign\to_pc = o_wb_addr;\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "4f8a1ae8a463b5452b567ab4df3d020d",
        "dataset_index": 5587
      },
      "gpio_57a1084e": {
        "rtl_code": "module gpio\n       (\n\tinput\t\t\twb_clk,\n\tinput\t\t\twb_rst,\n\n\tinput\t\t\twb_adr_i,\n\tinput\t\t[7:0] \twb_dat_i,\n\tinput\t\t\twb_we_i,\n\tinput\t\t\twb_cyc_i,\n\tinput\t\t\twb_stb_i,\n\tinput\t\t[2:0] \twb_cti_i,\n\tinput\t\t[1:0]\twb_bte_i,\n\toutput reg\t[7:0]\twb_dat_o,\n\toutput reg\t\twb_ack_o,\n\toutput\t\t\twb_err_o,\n\toutput\t\t\twb_rty_o,\n\n\tinput\t\t[7:0]\tgpio_i,\n\toutput reg\t[7:0]\tgpio_o,\n\toutput reg\t[7:0]\tgpio_dir_o\n);\n\n\n// GPIO dir register\nalways @(posedge wb_clk)\n\tif (wb_rst)\n\t\tgpio_dir_o <= 0; // All set to in at reset\n\telse if (wb_cyc_i & wb_stb_i & wb_we_i) begin\n\t\tif (wb_adr_i == 1)\n\t\t\tgpio_dir_o[7:0] <= wb_dat_i;\n\tend\n\n\n// GPIO data out register\nalways @(posedge wb_clk)\n\tif (wb_rst)\n\t\tgpio_o <= 0;\n\telse if (wb_cyc_i & wb_stb_i & wb_we_i) begin\n\t\tif (wb_adr_i == 0)\n\t\t\tgpio_o[7:0] <= wb_dat_i;\n\tend\n\n\n// Register the gpio in signal\nalways @(posedge wb_clk) begin\n\t// Data regs\n\tif (wb_adr_i == 0)\n\t\twb_dat_o[7:0] <= gpio_i[7:0];\n\n\t// Direction regs\n\tif (wb_adr_i == 1)\n\t\twb_dat_o[7:0] <= gpio_dir_o[7:0];\n     end\n\n// Ack generation\nalways @(posedge wb_clk)\n\tif (wb_rst)\n\t\twb_ack_o <= 0;\n\telse if (wb_ack_o)\n\t\twb_ack_o <= 0;\n\telse if (wb_cyc_i & wb_stb_i & !wb_ack_o)\n\t\twb_ack_o <= 1;\n\nassign wb_err_o = 0;\nassign wb_rty_o = 0;\n\nendmodule",
        "module_name": "gpio",
        "module_hash": "57a1084ed6fc28d708e7760a2a7a1582",
        "dataset_index": 1571
      },
      "axi_dwidth_converter_v2_1_8_w_downsizer #_a0ae0517": {
        "rtl_code": "\n\n \nmodule axi_dwidth_converter_v2_1_8_w_downsizer #\n  (\n   parameter         C_FAMILY                         = \"none\", \n                       parameter integer C_S_AXI_DATA_WIDTH               = 64,\n                       parameter integer C_M_AXI_DATA_WIDTH               = 32,\n                       parameter integer C_S_AXI_BYTES_LOG                = 3,\n                       parameter integer C_M_AXI_BYTES_LOG                = 2,\n                       parameter integer C_RATIO_LOG                      = 1\n                       )\n  (\n   input  wire                                                    ARESET,\n   input  wire                                                    ACLK,\n\n   input  wire                              cmd_valid,\n   input  wire                              cmd_mirror,\n   input  wire                              cmd_fix,\n   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_first_word, \n   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_offset,\n   input  wire [C_S_AXI_BYTES_LOG-1:0]      cmd_mask,\n   input  wire [C_M_AXI_BYTES_LOG:0]        cmd_step,\n   input  wire [3-1:0]                      cmd_size,\n   input  wire [8-1:0]                      cmd_length,\n   output wire                              cmd_ready,\n   \n   input  wire [C_S_AXI_DATA_WIDTH-1:0]     S_AXI_WDATA,\n   input  wire [C_S_AXI_DATA_WIDTH/8-1:0]   S_AXI_WSTRB,\n   input  wire                                                    S_AXI_WLAST,\n   input  wire                                                    S_AXI_WVALID,\n   output wire                                                    S_AXI_WREADY,\n\n   output wire [C_M_AXI_DATA_WIDTH-1:0]    M_AXI_WDATA,\n   output wire [C_M_AXI_DATA_WIDTH/8-1:0]  M_AXI_WSTRB,\n   output wire                                                   M_AXI_WLAST,\n   output wire                                                   M_AXI_WVALID,\n   input  wire                                                   M_AXI_WREADY\n   );\n\n   \n  localparam [24-1:0] C_DOUBLE_LEN       = 24'b0000_0000_0000_0000_1111_1111;\n  \n  \n  reg                             first_word;\n  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word_1;\n  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word;\n  wire [C_S_AXI_BYTES_LOG-1:0]    current_word_adjusted;\n  wire [C_RATIO_LOG-1:0]          current_index;\n  wire                            last_beat;\n  wire                            last_word;\n  reg  [C_S_AXI_BYTES_LOG-1:0]    size_mask;\n  \n  wire [C_S_AXI_BYTES_LOG-1:0]    next_word;\n  \n  reg                             first_mi_word;\n  reg  [8-1:0]                    length_counter_1;\n  reg  [8-1:0]                    length_counter;\n  wire [8-1:0]                    next_length_counter;\n  \n  wire                            word_completed;\n  wire                            cmd_ready_i;\n  wire                            pop_mi_data;\n  wire                            mi_stalling;\n  \n  wire                            S_AXI_WREADY_I;\n  \n  wire [C_M_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA_I;\n  wire [C_M_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB_I;\n  wire                            M_AXI_WLAST_I;\n  wire                            M_AXI_WVALID_I;\n  wire                            M_AXI_WREADY_I;\n  \n  \n  always @ *\n  begin\n    case (cmd_size)\n      3'b000: size_mask = C_DOUBLE_LEN[8 +: C_S_AXI_BYTES_LOG];\n      3'b001: size_mask = C_DOUBLE_LEN[7 +: C_S_AXI_BYTES_LOG];\n      3'b010: size_mask = C_DOUBLE_LEN[6 +: C_S_AXI_BYTES_LOG];\n      3'b011: size_mask = C_DOUBLE_LEN[5 +: C_S_AXI_BYTES_LOG];\n      3'b100: size_mask = C_DOUBLE_LEN[4 +: C_S_AXI_BYTES_LOG];\n      3'b101: size_mask = C_DOUBLE_LEN[3 +: C_S_AXI_BYTES_LOG];\n      3'b110: size_mask = C_DOUBLE_LEN[2 +: C_S_AXI_BYTES_LOG];\n      3'b111: size_mask = C_DOUBLE_LEN[1 +: C_S_AXI_BYTES_LOG];  endcase\n  end\n  \n  assign word_completed = ( cmd_fix ) |\n                          ( cmd_mirror ) |\n                          ( ~cmd_fix & ( ( next_word & size_mask ) == {C_S_AXI_BYTES_LOG{1'b0}} ) ) | \n                          ( ~cmd_fix & last_word );\n  \n  assign S_AXI_WREADY_I = cmd_valid & word_completed & M_AXI_WREADY_I;\n  assign S_AXI_WREADY   = S_AXI_WREADY_I;\n  \n  assign M_AXI_WVALID_I = S_AXI_WVALID & cmd_valid;\n  \n  assign pop_mi_data    = M_AXI_WVALID_I & M_AXI_WREADY_I;\n  \n  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;\n  assign cmd_ready      = cmd_ready_i;\n  \n  assign mi_stalling    = M_AXI_WVALID_I & ~M_AXI_WREADY_I;\n                          \n  \n  always @ *\n  begin\n    if ( first_word | cmd_fix )\n      current_word = cmd_first_word;\n    else\n      current_word = current_word_1;\n  end\n  \n  assign next_word              = ( current_word + cmd_step ) & cmd_mask;\n  \n  assign current_word_adjusted  = current_word + cmd_offset;\n  \n  assign current_index          = current_word_adjusted[C_S_AXI_BYTES_LOG-C_RATIO_LOG +: C_RATIO_LOG];\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      first_word      <= 1'b1;\n      current_word_1  <= 'b0;\n    end else begin\n      if ( pop_mi_data ) begin\n        if ( M_AXI_WLAST_I ) begin\n          first_word      <=  1'b1;\n        end else begin\n          first_word      <=  1'b0;\n        end\n      \n        current_word_1  <= next_word;\n      end\n    end\n  end\n  \n  always @ *\n  begin\n    if ( first_mi_word )\n      length_counter = cmd_length;\n    else\n      length_counter = length_counter_1;\n  end\n  \n  assign next_length_counter = length_counter - 1'b1;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      first_mi_word    <= 1'b1;\n      length_counter_1 <= 8'b0;\n    end else begin\n      if ( pop_mi_data ) begin\n        if ( M_AXI_WLAST_I ) begin\n          first_mi_word    <= 1'b1;\n        end else begin\n          first_mi_word    <= 1'b0;\n        end\n      \n        length_counter_1 <= next_length_counter;\n      end\n    end\n  end\n  \n  assign last_beat = ( length_counter == 8'b0 );\n  \n  assign last_word = ( last_beat );\n  \n  \n  assign M_AXI_WDATA_I  = S_AXI_WDATA[current_index * C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH];\n  assign M_AXI_WSTRB_I  = S_AXI_WSTRB[current_index * C_M_AXI_DATA_WIDTH/8 +: C_M_AXI_DATA_WIDTH/8];\n  \n  assign M_AXI_WLAST_I  = last_word;\n  \n  \n  assign M_AXI_WDATA    = M_AXI_WDATA_I;\n  assign M_AXI_WSTRB    = M_AXI_WSTRB_I;\n  assign M_AXI_WLAST    = M_AXI_WLAST_I;\n  assign M_AXI_WVALID   = M_AXI_WVALID_I;\n  assign M_AXI_WREADY_I = M_AXI_WREADY;\n  \nendmodule\n",
        "module_name": "axi_dwidth_converter_v2_1_8_w_downsizer #",
        "module_hash": "a0ae0517250e8ae3cd640cc084b17af9",
        "dataset_index": 24767
      },
      "sky130_fd_sc_hdll__inputiso0n_37490569": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__inputiso0n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    and and0 (X     , A, SLEEP_B     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__inputiso0n",
        "module_hash": "37490569e267d4996983bcce9fd92083",
        "dataset_index": 6032
      },
      "uart_tx_8n1_ea042185": {
        "rtl_code": "\nmodule uart_tx_8n1 (\n    input clk,\n    input [7:0] txbyte,\n    input senddata,\n    output txdone,\n    output reg tx\n);\n\nreg [3:0] state;\nreg [7:0] data;\nreg startbit;\nreg [2:0] bitcount;\n\nassign txdone = (state == 3'b100);\n\nalways @(posedge clk) begin\n    case (state)\n        3'b000: begin // idle\n            tx <= 1'b1;\n            if (senddata) begin\n                state <= 3'b001; // start bit\n                data <= txbyte;\n                startbit <= 1'b0;\n                bitcount <= 3'b000;\n            end\n        end\n        3'b001: begin // start bit\n            tx <= 1'b0;\n            startbit <= 1'b1;\n            state <= 3'b010; // data bits\n        end\n        3'b010: begin // data bits\n            tx <= data[0];\n            data <= {data[6:0], 1'b0};\n            bitcount <= bitcount + 1;\n            if (bitcount == 3'b111) begin\n                state <= 3'b011; // stop bit\n            end\n        end\n        3'b011: begin // stop bit\n            tx <= 1'b1;\n            state <= 3'b100; // done\n        end\n        default: begin // done\n            tx <= 1'b1;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "uart_tx_8n1",
        "module_hash": "ea042185808475f4a41137a7e2edf28c",
        "dataset_index": 17480
      },
      "edge_detector_c7a5e73d": {
        "rtl_code": "module edge_detector (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nreg [7:0] prev;\nreg [7:0] curr;\nwire [7:0] xor_out;\n\nalways @(posedge clk) begin\n    prev <= curr;\n    curr <= in;\nend\n\nassign xor_out = curr ^ prev;\nassign anyedge = xor_out & curr;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nedge_detector detector(\n    .clk(clk),\n    .in(in),\n    .anyedge(anyedge)\n);\n\nendmodule",
        "module_name": "edge_detector",
        "module_hash": "c7a5e73dfc8d1e76fe8050fcfc201122",
        "dataset_index": 1579
      },
      "adder #_7842bccb": {
        "rtl_code": "\nmodule adder #(parameter WIDTH=8) (\n    input clk, rst, load,\n    input [WIDTH-1:0] A, B,\n    output [WIDTH-1:0] Q\n);\n\n    wire [WIDTH:0] carry;\n    wire [WIDTH-1:0] sum;\n\n    // Ripple-carry adder\n    genvar i;\n    generate \n        for (i = 0; i < WIDTH; i = i + 1) begin : adder_stage\n            full_adder FA (\n                .a(A[i]), .b(B[i]), .c(carry[i]),\n                .sum(sum[i]), .carry(carry[i+1])\n            );\n        end\n    endgenerate\n\n    // Carry-out for the last stage\n    assign carry[WIDTH] = (A[WIDTH-1] & B[WIDTH-1]) | (A[WIDTH-1] & carry[WIDTH-1]) | (B[WIDTH-1] & carry[WIDTH-1]);\n\n    // Registering the output\n    reg [WIDTH-1:0] Q_reg;\n    always @(posedge clk) begin\n        if (rst) begin\n            Q_reg <= 0;\n        end else if (load) begin\n            Q_reg <= sum;\n        end\n    end\n\n    assign Q = Q_reg;\n\n    assign carry[0] = 0; // Connect the first carry-in to 0.\n\nendmodule\nmodule full_adder (\n    input a, b, c,\n    output sum, carry\n);\n\n    assign sum = a ^ b ^ c;\n    assign carry = (a & b) | (a & c) | (b & c);\n\nendmodule",
        "module_name": "adder #",
        "module_hash": "7842bccbe4162b2c9be4012cd0016102",
        "dataset_index": 567
      },
      "binary_counter_98e4317e": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input rst,\n    input enable,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 8'b0;\n    end else if (enable) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "98e4317e16fd5475b94c52c63fec9936",
        "dataset_index": 3239
      },
      "chatgpt_generate_JC_counter_9ae8cf30": {
        "rtl_code": "module chatgpt_generate_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [3:0]    Q\n);\n\n  reg [63:0] shift_reg;\n  reg [3:0] next_state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      shift_reg <= 64'b0;\n      Q <= 4'b0;\n    end\n    else begin\n      shift_reg <= {shift_reg[62:0], Q[3]};\n      next_state = {shift_reg[0], shift_reg[31], shift_reg[47], shift_reg[55]} ^ 4'b1111;\n      Q <= next_state;\n    end\n  end\n\nendmodule",
        "module_name": "chatgpt_generate_JC_counter",
        "module_hash": "9ae8cf30bde38ee3617db5a0bd123528",
        "dataset_index": 732
      },
      "counter_3373e089": {
        "rtl_code": "module counter(\n    input iCLK,\n    input iRST,\n    output reg [3:0] oCNT\n);\n\nalways @(posedge iCLK) begin\n    if (iRST) begin\n        oCNT <= 4'b0; // Reset to 0\n    end else begin\n        oCNT <= oCNT + 1; // Increment count\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "3373e0895ff7a8d285ee275bbd99ca41",
        "dataset_index": 10432
      },
      "sky130_fd_sc_ls__a31oi_a4333b3e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a31oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2     );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a31oi",
        "module_hash": "a4333b3eecfe0d3928989091b617cbca",
        "dataset_index": 9785
      },
      "FpuFp64FromInt_afe99bbc": {
        "rtl_code": "module FpuFp64FromInt(\n\tclk,\n\tenable,\n\tis32,\n\tsrc,\n\tdst\n);\n\ninput\t\t\tclk;\ninput\t\t\tenable;\ninput\t\t\tis32;\n\ninput[63:0]\t\tsrc;\noutput[63:0]\tdst;\n\nreg\t\tsgn;\nreg\t\tsgnc;\n\nreg[12:0] exa;\nreg[12:0] exb;\nreg[12:0] exc;\nreg[12:0] exm;\n\nreg[63:0] tFracA;\nreg[63:0] tFracB;\nreg[63:0] tFracC;\nreg[63:0] tFracA1;\nreg[63:0] tFracB1;\nreg[63:0] tFracC1;\n\nreg[63:0] tFracC2;\n\nreg[63:0] tFracC2_A;\treg[63:0] tFracC2_B;\treg[63:0] tFracC2_C;\treg[63:0] tFracC2_D;\treg[63:0] tFracC2_E;\treg[12:0] tExc_A;\nreg[12:0] tExc_B;\nreg[12:0] tExc_C;\nreg[12:0] tExc_D;\nreg[12:0] tExc_E;\n\nreg[63:0] tDst;\n\nassign dst = tDst;\n\nalways @ (clk && enable)\nbegin\n\tsgnc = 0;\n\n\tif(is32)\n\tbegin\n\t\tif(src[31])\n\t\tbegin\n\t\t\tsgn = 1;\n\t\t\ttFracC2[63:32] = 0;\n\t\t\ttFracC2[31:0] = ~(src[31:0]);\n\t\t\texm = 1023 + 52;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tsgn = 0;\n\t\t\ttFracC2[63:32] = 0;\n\t\t\ttFracC2[31:0] = src[31:0];\n\t\t\texm = 1023 + 52;\n\t\tend\n\tend\n\telse\n\tbegin\n\t\tif(src[63])\n\t\tbegin\n\t\t\tsgn = 1;\n\t\t\ttFracC2[63:0] = ~(src[63:0]);\n\t\t\texm = 1023 + 52;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tsgn = 0;\n\t\t\ttFracC2[63:0] = src[63:0];\n\t\t\texm = 1023 + 52;\n\t\tend\n\tend\n\n\tif(tFracC2[52:0]==0)\n\tbegin\n\t\tsgnc=0;\n\t\ttFracC=0;\n\t\texc=0;\n\tend\n\telse\n\t\tif(tFracC2[63:52]==0)\n\tbegin\n\n\t\tif(tFracC2[52:21]==0)\n\t\tbegin\n\t\t\ttFracC2_A=tFracC2<<32;\n\t\t\ttExc_A=exm-32;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_A=tFracC2;\n\t\t\ttExc_A=exm;\n\t\tend\n\n\t\tif(tFracC2_A[52:37]==0)\n\t\tbegin\n\t\t\ttFracC2_B=tFracC2_A<<16;\n\t\t\ttExc_B=tExc_A-16;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_B=tFracC2_A;\n\t\t\ttExc_B=tExc_A;\n\t\tend\n\n\t\tif(tFracC2_B[52:45]==0)\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B<<8;\n\t\t\ttExc_C=tExc_B-8;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B;\n\t\t\ttExc_C=tExc_B;\n\t\tend\n\t\t\n\t\tif(tFracC2_C[52:49]==0)\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C<<4;\n\t\t\ttExc_D=tExc_C-4;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C;\n\t\t\ttExc_D=tExc_C;\n\t\tend\n\t\t\n\t\tif(tFracC2_D[52:51]==0)\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D<<2;\n\t\t\ttExc_E=tExc_D-2;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D;\n\t\t\ttExc_E=tExc_D;\n\t\tend\n\n\t\tif(tFracC2_E[52]==0)\n\t\tbegin\n\t\t\ttFracC=tFracC2_E<<1;\n\t\t\texc=tExc_E-1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC=tFracC2_E;\n\t\t\texc=tExc_E;\n\t\tend\n\tend\n\telse\n\tbegin\n\t\ttFracC2_B=tFracC2;\n\t\ttExc_B=exm;\n\n\t\tif(tFracC2_B[63:60]!=0)\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B>>8;\n\t\t\ttExc_C=tExc_B+8;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_C=tFracC2_B;\n\t\t\ttExc_C=tExc_B;\n\t\tend\n\t\t\n\t\tif(tFracC2_C[59:56]!=0)\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C>>4;\n\t\t\ttExc_D=tExc_C+4;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_D=tFracC2_C;\n\t\t\ttExc_D=tExc_C;\n\t\tend\n\t\t\n\t\tif(tFracC2_D[55:54]==0)\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D>>2;\n\t\t\ttExc_E=tExc_D+2;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC2_E=tFracC2_D;\n\t\t\ttExc_E=tExc_D;\n\t\tend\n\n\t\tif(tFracC2_E[53])\n\t\tbegin\n\t\t\ttFracC=tFracC2_E>>1;\n\t\t\texc=tExc_E+1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttFracC=tFracC2_E;\n\t\t\texc=tExc_E;\n\t\tend\n\tend\n\t\n\tif(exc[12])\n\tbegin\n\t\ttDst[63:0]=64'h0;\n\tend\n\telse if(exc[11])\n\tbegin\n\t\ttDst[63]=sgnc;\n\t\ttDst[62:0]=63'h7FF0_0000_0000_0000;\n\tend\n\telse\n\tbegin\n\t\ttDst[63]=sgnc;\n\t\ttDst[62:52]=exc[10:0];\n\t\ttDst[51:0]=tFracC[51:0];\n\tend\n\t\nend\n\nalways @ (posedge clk)\nbegin\nend\n\nendmodule\n",
        "module_name": "FpuFp64FromInt",
        "module_hash": "afe99bbced5b863b24e8f1078cc10b75",
        "dataset_index": 25273
      },
      "HAZARD_CONTROL_UNIT #_7874ced8": {
        "rtl_code": "\nmodule HAZARD_CONTROL_UNIT #(\n        parameter   REG_ADD_WIDTH           = 5         ,\n        parameter   D_CACHE_LW_WIDTH        = 3         ,\n        \n        parameter   DATA_CACHE_LOAD_NONE    = 3'b000    ,\n        \n        parameter   HIGH                    = 1'b1      ,\n        parameter   LOW                     = 1'b0\n    ) (\n        input                                   INSTRUCTION_CACHE_READY         ,\n        input                                   DATA_CACHE_READY                ,\n        input                                   PC_MISPREDICTED                 ,\n        input   [REG_ADD_WIDTH -1      : 0]     RS1_ADDRESS_EXECUTION           ,\n        input   [REG_ADD_WIDTH -1      : 0]     RS2_ADDRESS_EXECUTION           ,\n        input   [D_CACHE_LW_WIDTH - 1  : 0]     DATA_CACHE_LOAD_DM1             ,\n        input   [REG_ADD_WIDTH -1      : 0]     RD_ADDRESS_DM1                  ,\n        input   [D_CACHE_LW_WIDTH - 1  : 0]     DATA_CACHE_LOAD_DM2             ,\n        input   [REG_ADD_WIDTH -1      : 0]     RD_ADDRESS_DM2                  ,\n        input   [D_CACHE_LW_WIDTH - 1  : 0]     DATA_CACHE_LOAD_DM3             ,\n        input   [REG_ADD_WIDTH -1      : 0]     RD_ADDRESS_DM3                  ,\n        output                                  CLEAR_INSTRUCTION_FETCH_STAGE   ,\n        output                                  CLEAR_DECODING_STAGE            ,\n        output                                  CLEAR_EXECUTION_STAGE           ,\n        output                                  STALL_PROGRAME_COUNTER_STAGE    ,\n        output                                  STALL_INSTRUCTION_CACHE         ,\n        output                                  STALL_INSTRUCTION_FETCH_STAGE   ,\n        output                                  STALL_DECODING_STAGE            ,\n        output                                  STALL_EXECUTION_STAGE           ,\n        output                                  STALL_DATA_MEMORY_STAGE                       \n    );\n    \n    reg             clear_instruction_fetch_stage_reg       ;\n    reg             clear_decoding_stage_reg                ;\n    reg             clear_execution_stage_reg               ;\n    reg             stall_programe_counter_stage_reg        ;\n    reg             stall_instruction_cache_reg             ;\n    reg             stall_instruction_fetch_stage_reg       ;\n    reg             stall_decoding_stage_reg                ;\n    reg             stall_execution_stage_reg               ;\n    reg             stall_data_memory_stage_reg             ;\n    \n    initial\n    begin\n        clear_instruction_fetch_stage_reg   = LOW       ;\n        clear_decoding_stage_reg            = LOW       ;\n        clear_execution_stage_reg           = LOW       ;\n        stall_programe_counter_stage_reg    = LOW       ;\n        stall_instruction_cache_reg         = LOW       ;\n        stall_instruction_fetch_stage_reg   = LOW       ;\n        stall_decoding_stage_reg            = LOW       ;\n        stall_execution_stage_reg           = LOW       ;\n        stall_data_memory_stage_reg         = LOW       ;\n    end\n    \n    always@(*) \n    begin\n        if(PC_MISPREDICTED == HIGH)\n        begin\n            clear_instruction_fetch_stage_reg   = HIGH      ;\n            clear_decoding_stage_reg            = HIGH      ;\n        end\n        else\n        begin\n            clear_instruction_fetch_stage_reg   = LOW       ;\n            clear_decoding_stage_reg            = LOW       ;\n        end\n \n        if((((RS1_ADDRESS_EXECUTION == RD_ADDRESS_DM1) | (RS2_ADDRESS_EXECUTION == RD_ADDRESS_DM1))& DATA_CACHE_LOAD_DM1 != DATA_CACHE_LOAD_NONE) | (((RS1_ADDRESS_EXECUTION == RD_ADDRESS_DM2) | (RS2_ADDRESS_EXECUTION == RD_ADDRESS_DM2))& DATA_CACHE_LOAD_DM2 != DATA_CACHE_LOAD_NONE) | (((RS1_ADDRESS_EXECUTION == RD_ADDRESS_DM3) | (RS2_ADDRESS_EXECUTION == RD_ADDRESS_DM3))& DATA_CACHE_LOAD_DM3 != DATA_CACHE_LOAD_NONE)) \n        begin\n            clear_decoding_stage_reg            = LOW       ;\n            clear_execution_stage_reg           = HIGH      ;\n            stall_programe_counter_stage_reg    = HIGH      ;\n            stall_instruction_cache_reg         = HIGH      ;\n            stall_instruction_fetch_stage_reg   = HIGH      ;\n            stall_decoding_stage_reg            = HIGH      ;\n            stall_execution_stage_reg           = HIGH      ;\n        end\n        else if(INSTRUCTION_CACHE_READY == LOW)\n        begin\n            clear_decoding_stage_reg            = HIGH      ;\n            clear_execution_stage_reg           = LOW       ;\n            stall_programe_counter_stage_reg    = HIGH      ;\n            stall_instruction_cache_reg         = LOW       ;\n            stall_instruction_fetch_stage_reg   = HIGH      ;\n            stall_decoding_stage_reg            = HIGH      ;\n            stall_execution_stage_reg           = LOW       ;\n        end\n        else\n        begin\n            clear_decoding_stage_reg            = LOW       ;\n            clear_execution_stage_reg           = LOW       ;\n            stall_programe_counter_stage_reg    = LOW       ;\n            stall_instruction_cache_reg         = LOW       ;\n            stall_instruction_fetch_stage_reg   = LOW       ;\n            stall_decoding_stage_reg            = LOW       ;\n            stall_execution_stage_reg           = LOW       ;\n        end\n    end\n    \n    assign CLEAR_INSTRUCTION_FETCH_STAGE    = clear_instruction_fetch_stage_reg     ;\n    assign CLEAR_DECODING_STAGE             = clear_decoding_stage_reg              ;\n    assign CLEAR_EXECUTION_STAGE            = clear_execution_stage_reg             ;\n    assign STALL_PROGRAME_COUNTER_STAGE     = stall_programe_counter_stage_reg      ;\n    assign STALL_INSTRUCTION_CACHE          = stall_instruction_cache_reg           ;\n    assign STALL_INSTRUCTION_FETCH_STAGE    = stall_instruction_fetch_stage_reg     ;\n    assign STALL_DECODING_STAGE             = stall_decoding_stage_reg              ;\n    assign STALL_EXECUTION_STAGE            = stall_execution_stage_reg             ;\n    assign STALL_DATA_MEMORY_STAGE          = stall_data_memory_stage_reg           ;\n    \nendmodule\n",
        "module_name": "HAZARD_CONTROL_UNIT #",
        "module_hash": "7874ced8f0c774b24f2c448eea55c62f",
        "dataset_index": 18281
      },
      "single_port_RAM_4195f380": {
        "rtl_code": "module single_port_RAM (\n  input clk,\n  input write_en,\n  input read_en,\n  input [8*depth-1:0] address,\n  input [data_width-1:0] data_in,\n  output reg [data_width-1:0] data_out\n);\n\nparameter data_width = 8; // size of the data (in bits)\nparameter depth = 256; // number of memory locations\n\n// Define memory array\nreg [data_width-1:0] memory [depth-1:0];\n\n// Write operation\nalways @(posedge clk) begin\n    if (write_en) begin\n        memory[address] <= data_in;\n    end\nend\n\n// Read operation\nalways @(posedge clk) begin\n    if (read_en) begin\n        data_out <= memory[address];\n    end\nend\nendmodule",
        "module_name": "single_port_RAM",
        "module_hash": "4195f38012e881424fb648a8ab37f940",
        "dataset_index": 12015
      },
      "ID_EX_8c13d437": {
        "rtl_code": "module ID_EX(\n    clk, rst, stall,\n    id_a, id_b, id_td, id_d2, id_Aluc, id_WREG, id_WMEM, id_LW, id_instr, id_pc,\n    ex_a, ex_b, ex_td, ex_d2, ex_Aluc, ex_WREG, ex_WMEM, ex_LW, ex_instr, ex_pc\n);\n\n    input clk, rst, stall;\n    input [31:0] id_a, id_b, id_d2, id_instr, id_pc;\n    input [4:0] id_td, id_Aluc;\n    input id_WREG, id_WMEM, id_LW;\n    output reg [31:0] ex_a, ex_b, ex_d2, ex_instr, ex_pc;\n    output reg [4:0] ex_td, ex_Aluc;\n    output reg ex_WREG, ex_WMEM, ex_LW;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            ex_a <= 0;\n            ex_b <= 0;\n            ex_d2 <= 0;\n            ex_td <= 0;\n            ex_Aluc <= 0;\n            ex_WREG <= 0;\n            ex_WMEM <= 0;\n            ex_LW <= 0;\n            ex_instr <= 32'b100000;\n            ex_pc <= 32'b0;\n        end\n        else if (stall) begin\n            ex_a <= ex_a;\n            ex_b <= ex_b;\n            ex_d2 <= ex_d2;\n            ex_td <= ex_td;\n            ex_Aluc <= ex_Aluc;\n            ex_WREG <= ex_WREG;\n            ex_WMEM <= ex_WMEM;\n            ex_LW <= ex_LW;\n            ex_instr <= id_instr;\n            ex_pc <= id_pc;\n        end\n        else begin\n            ex_a <= id_a;\n            ex_b <= id_b;\n            ex_d2 <= id_d2;\n            ex_td <= id_td;\n            ex_Aluc <= id_Aluc;\n            ex_WREG <= id_WREG;\n            ex_WMEM <= id_WMEM;\n            ex_LW <= id_LW;\n            ex_instr <= id_instr;\n            ex_pc <= id_pc;\n        end\n    end\n\nendmodule",
        "module_name": "ID_EX",
        "module_hash": "8c13d43744dc88d03f9434a473f46a21",
        "dataset_index": 20036
      },
      "min_shift_register_398e481d": {
        "rtl_code": "module min_shift_register (\n    input [7:0] a, b, c, d, // Inputs for finding minimum value\n    input clk, // Clock input for shift register\n    output [7:0] min, // Output of the minimum value\n    output q, // Output of the last flip-flop for shift register\n    output [7:0] final_output // Final output of the system\n);\n\n// Find minimum value\nwire [7:0] min_ab, min_cd, min_value;\n\n// Compare a and b, c and d first\nassign min_ab = (a < b) ? a : b;\nassign min_cd = (c < d) ? c : d;\n\n// Then find the minimum of min_ab and min_cd\nassign min_value = (min_ab < min_cd) ? min_ab : min_cd;\n\nassign min = min_value; // Assign the minimum value to min\n\n// Shift register\nreg [7:0] shift_reg;\nalways @(posedge clk) begin\n    shift_reg <= min_value; // Load min_value into shift register on positive edge of clk\nend\n\nassign q = shift_reg[0]; // Assign the LSB of the shift register to q\n\n// Final output\nassign final_output = shift_reg; \n\nendmodule\n",
        "module_name": "min_shift_register",
        "module_hash": "398e481d6c87726f775f40803a8e8741",
        "dataset_index": 318
      },
      "HalfSubtractor_f0d309c4": {
        "rtl_code": "module HalfSubtractor (\n  input A,\n  input B,\n  output difference,\n  output borrow\n);\n  \n  assign difference = A ^ B;\n  assign borrow = ~A & B;\n  \nendmodule\n\nmodule FullSubtractor (\n  input A,\n  input B,\n  input borrow,\n  output difference,\n  output borrow_out\n);\n  \n  wire temp_diff1, temp_diff2, temp_borrow1, temp_borrow2;\n  \n  HalfSubtractor HS1(.A(A), .B(B), .difference(temp_diff1), .borrow(temp_borrow1));\n  HalfSubtractor HS2(.A(temp_diff1), .B(borrow), .difference(difference), .borrow(temp_borrow2));\n  assign borrow_out = temp_borrow1 | temp_borrow2;\n  \nendmodule",
        "module_name": "HalfSubtractor",
        "module_hash": "f0d309c4a8617f65ec16670789067f2a",
        "dataset_index": 7864
      },
      "Control_a992cb32": {
        "rtl_code": "module Control(Op_i,RegDst_o,Jump_o,Branch_o,MemRead_o,MemtoReg_o,ALUOp_o,MemWrite_o,ALUSrc_o,RegWrite_o);\nparameter Op_lw=6'b100011,Op_sw=6'b101011,Op_beq=6'b000100,Op_ALU=6'b000000,Op_j=6'b000010,Op_addi=6'b001000;\ninput\t[5:0]\tOp_i;\noutput\t\t\tRegDst_o,Jump_o,Branch_o,MemRead_o,MemtoReg_o,MemWrite_o,ALUSrc_o,RegWrite_o;\noutput\t[1:0]\tALUOp_o;\n\nassign RegDst_o=(Op_i==0 || (Op_i&6'b111110)==6'b000010 || \n\t(Op_i&6'b111100)==6'b010000)?1:0;\nassign Jump_o=(Op_i==Op_j)?1:0;\nassign Branch_o=(Op_i==Op_beq)?1:0;\nassign MemRead_o=(Op_i==Op_lw)?1:0;\nassign MemtoReg_o=(Op_i==Op_lw)?1:0;\nassign ALUOp_o=(Op_i==Op_beq)?2'b01:(Op_i==Op_lw || Op_i==Op_sw || Op_i==Op_addi)?2'b00:2'b10;\nassign MemWrite_o=(Op_i==Op_sw)?1:0;\nassign ALUSrc_o=(Op_i==Op_beq || Op_i==0 || (Op_i&6'b111110)==6'b000010 || \n\t(Op_i&6'b111100)==6'b010000)?0:1;\nassign RegWrite_o=(Op_i==Op_lw || Op_i==Op_ALU || Op_i==6'b001000)?1:0;\n\nendmodule\n\n",
        "module_name": "Control",
        "module_hash": "a992cb3242e0e08b899225668de67794",
        "dataset_index": 10383
      },
      "barrel_shifter_b0802d22": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] data_in,\n    input [1:0] shift_amount,\n    input direction_left,\n    output reg [3:0] data_out\n);\n\nreg [3:0] shift_reg [1:3];\n\nalways @(*) begin\n    shift_reg[1] = data_in;\n    shift_reg[2] = shift_reg[1] << 1;\n    shift_reg[3] = shift_reg[2] << 1;\n    \n    if (shift_amount == 2'b00) begin\n        data_out = data_in;\n    end else if (shift_amount == 2'b01) begin\n        data_out = shift_reg[2];\n    end else if (shift_amount == 2'b10) begin\n        data_out = shift_reg[3];\n    end else if (shift_amount == 2'b11) begin\n        data_out = direction_left ? shift_reg[3] : shift_reg[1];\n    end\nend\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "b0802d22eb8d7d24860ae853a9062eff",
        "dataset_index": 17694
      },
      "parity_check_131e3e3a": {
        "rtl_code": "\nmodule parity_check (\n  input [7:0] data_in,\n  input control,\n  output reg parity\n);\n\n  integer i;\n  reg [7:0] data_temp;\n  reg parity_temp;\n\n  always @ (data_in, control) begin\n    if (control == 0) begin\n      parity <= 0;\n    end else begin\n      data_temp <= data_in;\n      parity_temp <= 0;\n      for (i = 0; i < 8; i = i + 1) begin\n        parity_temp <= parity_temp ^ data_temp[i];\n      end\n      parity <= parity_temp;\n    end\n  end\n\nendmodule",
        "module_name": "parity_check",
        "module_hash": "131e3e3a9d869393fba9dccd4fe5b356",
        "dataset_index": 12495
      },
      "karnaugh_map_db169f2f": {
        "rtl_code": "module karnaugh_map(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @* begin\n    case ({A,B,C,D})\n      4'b0000: F = 1;\n      4'b0001: F = 0;\n      4'b0010: F = 1;\n      4'b0011: F = 0;\n      4'b0100: F = 0;\n      4'b0101: F = 1;\n      4'b0110: F = 1;\n      4'b0111: F = 0;\n      4'b1000: F = 1;\n      4'b1001: F = 0;\n      4'b1010: F = 0;\n      4'b1011: F = 1;\n      4'b1100: F = 1;\n      4'b1101: F = 0;\n      4'b1110: F = 0;\n      4'b1111: F = 1;\n    endcase\n  end\n\nendmodule",
        "module_name": "karnaugh_map",
        "module_hash": "db169f2f4acabf9f38fae7ac00c3d328",
        "dataset_index": 2887
      },
      "debounce_11215c3b": {
        "rtl_code": "\nmodule debounce(\n    input clk,\n    input button,\n    output reg button_state,\n    output reg button_up,\n    output reg button_down\n);\n\n    // Register to hold the current state of the button\n    reg current_state;\n\n    // Register to hold the previous state of the button\n    reg previous_state;\n\n    // Debounce counter\n    reg [15:0] debounce_counter;\n\n    // Define the initial values of the registers\n    initial begin\n        current_state = 1'b0;\n        previous_state = 1'b0;\n        debounce_counter = 16'd0;\n        button_state = 1'b0;\n        button_up = 1'b0;\n        button_down = 1'b0;\n    end\n\n    // Debounce logic\n    always @(posedge clk) begin\n        // Update the current state of the button\n        current_state <= button;\n\n        // Increment the debounce counter\n        if (debounce_counter < 16'd10000) begin\n            debounce_counter <= debounce_counter + 16'd1;\n        end\n\n        // Check if the button has been pressed for long enough\n        if (debounce_counter == 16'd10000) begin\n            // Update the button state\n            button_state <= current_state;\n            if (current_state & ~previous_state) begin\n                button_down <= 1;\n            end else if (~current_state & previous_state) begin\n                button_up <= 1;\n            end\n        end\n\n        // Update the previous state of the button\n        previous_state <= current_state;\n    end\n\nendmodule\n",
        "module_name": "debounce",
        "module_hash": "11215c3bb03b8118e329e776969942ad",
        "dataset_index": 16774
      },
      "top_module_5e9621d4": {
        "rtl_code": "module top_module( \n    input clk,\n    input reset,      // Synchronous active-high reset\n    input a,b,c,\n    input [31:0] in,\n    output [31:0] out,\n    output w,x,y,z );\n\n    wire [31:0] mux_out;\n    wire [31:0] reverse_out;\n\n    // Multiplexer module\n    mux_3to4 mux_inst (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .c(c),\n        .w(w),\n        .x(x),\n        .y(y),\n        .z(z),\n        .mux_out(mux_out)\n    );\n\n    // Byte reversal module\n    byte_reversal br_inst (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .out(reverse_out)\n    );\n\n    // XOR module\n    xor_module xor_inst (\n        .in1(mux_out),\n        .in2(reverse_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule mux_3to4 (\n    input clk,\n    input reset,\n    input a, b, c,\n    output w, x, y, z,\n    output [31:0] mux_out\n);\n\n    reg [31:0] mux_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            mux_reg <= 32'h0;\n        end else begin\n            case ({a, b, c})\n                3'b000: mux_reg <= 32'h0;\n                3'b001: mux_reg <= 32'h1;\n                3'b010: mux_reg <= 32'h2;\n                3'b011: mux_reg <= 32'h3;\n                3'b100: mux_reg <= 32'h4;\n                3'b101: mux_reg <= 32'h5;\n                3'b110: mux_reg <= 32'h6;\n                3'b111: mux_reg <= 32'h7;\n            endcase\n        end\n    end\n\n    assign mux_out = mux_reg;\n    assign {w, x, y, z} = mux_reg[3:0];\n\nendmodule\n\nmodule byte_reversal (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\n    reg [31:0] reverse_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            reverse_reg <= 32'h0;\n        end else begin\n            reverse_reg <= {in[7:0], in[15:8], in[23:16], in[31:24]};\n        end\n    end\n\n    assign out = reverse_reg;\n\nendmodule\n\nmodule xor_module (\n    input [31:0] in1,\n    input [31:0] in2,\n    output [31:0] out\n);\n\n    assign out = in1 ^ in2;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "5e9621d4634cb5b257e4c7efe0820f98",
        "dataset_index": 12351
      },
      "full_adder_f05cce9c": {
        "rtl_code": "module full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule\n\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] S_int;\n    wire C0, C1, C2;\n\n    full_adder fa0 (\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .S(S_int[0]),\n        .Cout(C0)\n    );\n\n    full_adder fa1 (\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(C0),\n        .S(S_int[1]),\n        .Cout(C1)\n    );\n\n    full_adder fa2 (\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(C1),\n        .S(S_int[2]),\n        .Cout(C2)\n    );\n\n    full_adder fa3 (\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(C2),\n        .S(S_int[3]),\n        .Cout(Cout)\n    );\n\n    assign S = S_int;\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "f05cce9cbede196784c2c172aee36206",
        "dataset_index": 18401
      },
      "up_down_counter_dc950d6b": {
        "rtl_code": "\nmodule up_down_counter (\n    input CLK,\n    input RST,\n    input DIR,\n    output reg [15:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 16'h0000;\n        end else begin\n            if (DIR) begin\n                Q <= Q + 16'b1;\n            end else if (Q != 16'h0000) begin\n                Q <= Q - 16'b1;\n            end\n        end\n    end\n\nendmodule\nmodule comparator (\n    input [15:0] a,\n    input [15:0] b,\n    output reg lt,\n    output reg eq,\n    output reg gt\n);\n\n    always @(*) begin\n        if (a < b) begin\n            lt = 1'b1;\n            eq = 1'b0;\n            gt = 1'b0;\n        end else if (a == b) begin\n            lt = 1'b0;\n            eq = 1'b1;\n            gt = 1'b0;\n        end else begin\n            lt = 1'b0;\n            eq = 1'b0;\n            gt = 1'b1;\n        end\n    end\n\nendmodule\nmodule max_value (\n    input [15:0] a,\n    input lt,\n    input eq,\n    input gt,\n    input [15:0] b,\n    output reg [15:0] max_output\n);\n\n    always @(*) begin\n        if (gt) begin\n            max_output = b;\n        end else begin\n            max_output = a;\n        end\n    end\n\nendmodule\nmodule top_module (\n    input CLK,\n    input RST,\n    input DIR,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] Q,\n    output reg lt,\n    output reg eq,\n    output reg gt,\n    output reg [15:0] max_output\n);\n\n    up_down_counter counter (\n        .CLK(CLK),\n        .RST(RST),\n        .DIR(DIR),\n        .Q(Q)\n    );\n\n    comparator comp (\n        .a(Q),\n        .b(b),\n        .lt(lt),\n        .eq(eq),\n        .gt(gt)\n    );\n\n    max_value max (\n        .a(Q),\n        .lt(lt),\n        .eq(eq),\n        .gt(gt),\n        .b(b),\n        .max_output(max_output)\n    );\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "dc950d6beae5d11e2d47b621c40f36d6",
        "dataset_index": 10490
      }
    },
    "batch_6913ad9230688190a8064d1d7c44c54d": {
      "edgedetect_e6de9563": {
        "rtl_code": "\n\nmodule edgedetect (\n    input iCLK      ,\n    input iRST      ,\n    input iSIG      ,\n    output wire oRE ,\n    output wire oFE ,\n    output wire oRFE\n);\n\nparameter registered = \"FALSE\";\n\nreg delay;\n\nwire re;\nwire fe;\nwire rfe;\n\n\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        delay <= 1'b0;\n    end\n    else\n    begin\n        delay <= iSIG;\n    end\nend\n\n\nassign re   = (iSIG && !delay) ? 1'b1 : 1'b0;\nassign fe   = (!iSIG && delay) ? 1'b1 : 1'b0;\nassign rfe  = ((iSIG && !delay) || (!iSIG && delay)) ? 1'b1 : 1'b0;\n\n\nreg re_reg, fe_reg, rfe_reg;\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        re_reg     <= 1'b0;\n        fe_reg     <= 1'b0;\n        rfe_reg    <= 1'b0;\n    end\n    else\n    begin\n        re_reg     <= re;\n        fe_reg     <= fe;\n        rfe_reg    <= rfe;\n    end\nend\n\n\nassign oRE =    (registered == \"TRUE\") ? re_reg  : re ;\nassign oFE =    (registered == \"TRUE\") ? fe_reg  : fe ;\nassign oRFE =   (registered == \"TRUE\") ? rfe_reg : rfe;\n\n\nendmodule\n",
        "module_name": "edgedetect",
        "module_hash": "e6de9563b7129e0e6eedf4c963427991",
        "dataset_index": 5835
      },
      "shift_register_65c2467a": {
        "rtl_code": "module shift_register (\n    input [15:0] D,\n    input SH,\n    input LD,\n    input clk,\n    output reg [15:0] Q\n);\n\nreg [15:0] Q1, Q2;\n\nalways @ (posedge clk) begin\n    if (LD) begin\n        Q1 <= D;\n    end else begin\n        Q1 <= Q2;\n    end\nend\n\nalways @ (posedge clk) begin\n    if (SH) begin\n        Q2 <= {Q1[14:0], 1'b0};\n    end else begin\n        Q2 <= {1'b0, Q1[15:1]};\n    end\nend\n\nalways @* begin\n    Q = Q2;\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "65c2467a5624cd1d67d0d7be411ca0b6",
        "dataset_index": 7826
      },
      "memory_generator_511a26fa": {
        "rtl_code": "module memory_generator\n  #(parameter MEM_DEPTH = 1024,\n            INIT_VECTOR = 256'h0000000000000000000000000000000000000000000000000000000000000000)\n  (\n    output reg [35:0] douta,\n    input wire clka,\n    input wire [9:0] addra,\n    input wire en,\n    input wire [35:0] data_in\n  );\n\n  reg [35:0] mem [0:MEM_DEPTH-1];\n\n  // Initialize memory with INIT_VECTOR\n  integer i;\n  initial begin\n    for (i=0; i<MEM_DEPTH; i=i+1) begin\n      mem[i] = INIT_VECTOR;\n    end\n  end\n\n  always @(posedge clka) begin\n    douta <= mem[addra];\n    if (en) begin\n      mem[addra] <= data_in;\n    end\n  end\n\nendmodule",
        "module_name": "memory_generator",
        "module_hash": "511a26fa86ea499086e1d6e21a6caef8",
        "dataset_index": 12653
      },
      "cpu_ctl_64d64e03": {
        "rtl_code": "\nmodule cpu_ctl(\n    input wire [5:0] op, func,\n    input wire equal_result,\n    output wire JR, J, JAL, LW, WREG, WMEM, RDorRT, SE, SA, IorR, BJ,\n    output reg [4:0] Aluc\n);\n\n    wire r_type = ~op[5] & ~op[4] & ~op[3] & ~op[2] & ~op[1] & ~op[0];\n    wire i_jr = r_type & ~func[5] & ~func[4] & func[3] & ~func[2] & ~func[1] & ~func[0];\n    wire i_sll = r_type & ~func[5] & ~func[4] & ~func[3] & ~func[2] & ~func[1] & ~func[0];\n    wire i_srl = r_type & ~func[5] & ~func[4] & ~func[3] & ~func[2] & func[1] & ~func[0];\n    wire i_sra = r_type & ~func[5] & ~func[4] & ~func[3] & ~func[2] & func[1] & func[0];\n\n    wire i_addi, i_addiu, i_andi, i_ori, i_xori, i_lui, i_lw, i_sw, i_slti, i_sltiu;\n    wire b_type, i_beq, i_bne;\n    wire i_j, i_jal;\n\n    wire i_type = i_addi | i_addiu | i_andi | i_ori | i_xori | i_lui | i_lw | i_sw | i_slti | i_sltiu;\n\n    assign i_addi = ~op[5] & ~op[4] & op[3] & ~op[2] & ~op[1] & ~op[0];\n    assign i_addiu = ~op[5] & ~op[4] & op[3] & ~op[2] & ~op[1] & op[0];\n    assign i_andi = ~op[5] & ~op[4] & op[3] & op[2] & ~op[1] & ~op[0];\n    assign i_ori = ~op[5] & ~op[4] & op[3] & op[2] & ~op[1] & op[0];\n    assign i_xori = ~op[5] & ~op[4] & op[3] & op[2] & op[1] & ~op[0];\n    assign i_lui = ~op[5] & ~op[4] & op[3] & op[2] & op[1] & op[0];\n    assign i_lw = op[5] & ~op[4] & ~op[3] & ~op[2] & op[1] & op[0];\n    assign i_sw = op[5] & ~op[4] & op[3] & ~op[2] & op[1] & op[0];\n    assign i_slti = ~op[5] & ~op[4] & op[3] & ~op[2] & op[1] & ~op[0];\n    assign i_sltiu = ~op[5] & ~op[4] & op[3] & ~op[2] & op[1] & op[0];\n\n    assign b_type = i_beq | i_bne;\n    assign i_beq = ~op[5] & ~op[4] & ~op[3] & op[2] & ~op[1] & ~op[0];\n    assign i_bne = ~op[5] & ~op[4] & ~op[3] & op[2] & ~op[1] & op[0];\n\n    assign i_j = ~op[5] & ~op[4] & ~op[3] & ~op[2] & op[1] & ~op[0];\n    assign i_jal = ~op[5] & ~op[4] & ~op[3] & ~op[2] & op[1] & op[0];\n\n    assign JR = i_jr;\n    assign J = i_j;\n    assign JAL = i_jal;\n    assign LW = i_lw;\n    assign WREG = i_jal | (IorR & ~i_sw) | (r_type & ~i_jr);\n    assign WMEM = i_sw;\n    assign RDorRT = r_type & ~i_jr;\n    assign SE = i_addi | i_addiu | i_lw | i_sw | i_slti;\n    assign SA = i_sll | i_srl | i_sra;\n    assign IorR = i_type & ~b_type;\n    assign BJ = (i_beq & equal_result) | (i_bne & ~equal_result);\n\n    always @(*) begin\n        case ({op, func})\n            6'b000000: Aluc = func[3:0]; // R-Type\n            6'b001000: Aluc = 4'b0010; // ADDI\n            6'b001001: Aluc = 4'b0011; // ADDIU\n            6'b001100: Aluc = 4'b0000; // ANDI\n            6'b001101: Aluc = 4'b0101; // ORI\n            6'b001110: Aluc = 4'b0110; // XORI\n            6'b001010: Aluc = 4'b0111; // SLTI\n            6'b001011: Aluc = 4'b1000; // SLTIU\n            6'b100011: Aluc = 4'b0001; // LW\n            6'b101011: Aluc = 4'b0001; // SW\n            default: Aluc = 4'b0000; // Default to 0\n        endcase\n    end\n\nendmodule",
        "module_name": "cpu_ctl",
        "module_hash": "64d64e0326278800127f3a31e485c987",
        "dataset_index": 5859
      },
      "carry_lookahead_gen_69932ac3": {
        "rtl_code": "module carry_lookahead_gen \n    (\n        input   wire[3:0]   g,\n        input   wire[3:0]   p,\n        input   wire        cin,\n        output  wire[3:0]   cout\n        );\n\n    wire    and_out_1;\n    wire    and_out_2;\n    wire    and_out_3;\n    wire    and_out_4;\n    wire    and_out_5;\n    wire    and_out_6;\n    wire    or_out_1;\n    wire    or_out_2;\n    wire    or_out_3;\n    assign  cout = {or_out_3, or_out_2, or_out_1, cin};\n    and     A1 (and_out_1, p[0], cin);\n    or      O1 (or_out_1, g[0], and_out_1);\n\n    and     A2 (and_out_2, p[1], g[0]);\n    and     A3 (and_out_3, p[1], p[0], cin);\n    or      O2 (or_out_2, g[1], and_out_3, and_out_2);\n\n    and     A4 (and_out_4, p[2], g[1]);\n    and     A5 (and_out_5, p[2], p[1], g[0]);\n    and     A6 (and_out_6, p[2], p[1], p[0], cin);\n    or      O3 (or_out_3, g[2], and_out_6, and_out_5, and_out_4);\n\n    endmodule\n",
        "module_name": "carry_lookahead_gen",
        "module_hash": "69932ac3aef88edb65d33dfdcafd2fa2",
        "dataset_index": 24687
      },
      "dmac_2d_transfer_4d146544": {
        "rtl_code": "module dmac_2d_transfer (\n\tinput req_aclk,\n\tinput req_aresetn,\n\n\tinput req_valid,\n\toutput reg req_ready,\n\n\tinput [31:C_BYTES_PER_BEAT_WIDTH_DEST] req_dest_address,\n\tinput [31:C_BYTES_PER_BEAT_WIDTH_SRC] req_src_address,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_x_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_y_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_dest_stride,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_src_stride,\n\tinput req_sync_transfer_start,\n\toutput reg req_eot,\n\t\n\toutput reg out_req_valid,\n\tinput out_req_ready,\n\toutput [31:C_BYTES_PER_BEAT_WIDTH_DEST] out_req_dest_address,\n\toutput [31:C_BYTES_PER_BEAT_WIDTH_SRC] out_req_src_address,\n\toutput [C_DMA_LENGTH_WIDTH-1:0] out_req_length,\n\toutput reg out_req_sync_transfer_start,\n\tinput out_eot\n);\n\nparameter C_DMA_LENGTH_WIDTH = 24;\nparameter C_BYTES_PER_BEAT_WIDTH_SRC = 3;\nparameter C_BYTES_PER_BEAT_WIDTH_DEST = 3;\n\nreg [31:C_BYTES_PER_BEAT_WIDTH_DEST] dest_address;\nreg [31:C_BYTES_PER_BEAT_WIDTH_SRC] src_address;\nreg [C_DMA_LENGTH_WIDTH-1:0] x_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] y_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] dest_stride;\nreg [C_DMA_LENGTH_WIDTH-1:0] src_stride;\n\nreg [1:0] req_id;\nreg [1:0] eot_id;\nreg [3:0] last_req;\n\nassign out_req_dest_address = dest_address;\nassign out_req_src_address = src_address;\nassign out_req_length = x_length;\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\treq_id <= 2'b0;\n\t\teot_id <= 2'b0;\n\t\treq_eot <= 1'b0;\n\tend else begin\n\t\tif (out_req_valid && out_req_ready) begin\n\t\t\treq_id <= req_id + 1'b1;\n\t\t\tlast_req[req_id] <= y_length == 0;\n\t\tend\n\t\treq_eot <= 1'b0;\n\t\tif (out_eot) begin\n\t\t\teot_id <= eot_id + 1'b1;\n\t\t\treq_eot <= last_req[eot_id];\n\t\tend\n\tend\nend\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\tdest_address <= 'h00;\n\t\tsrc_address <= 'h00;\n\t\tx_length <= 'h00;\n\t\ty_length <= 'h00;\n\t\tdest_stride <= 'h00;\n\t\tsrc_stride <= 'h00;\n\t\treq_ready <= 1'b1;\n\t\tout_req_valid <= 1'b0;\n\t\tout_req_sync_transfer_start <= 1'b0;\n\tend else begin\n\t\tif (req_ready) begin\n\t\t\tif (req_valid) begin\n\t\t\t\tdest_address <= req_dest_address;\n\t\t\t\tsrc_address <= req_src_address;\n\t\t\t\tx_length <= req_x_length;\n\t\t\t\ty_length <= req_y_length;\n\t\t\t\tdest_stride <= req_dest_stride;\n\t\t\t\tsrc_stride <= req_src_stride;\n\t\t\t\tout_req_sync_transfer_start <= req_sync_transfer_start;\n\t\t\t\treq_ready <= 1'b0;\n\t\t\t\tout_req_valid <= 1'b1;\n\t\t\tend\n\t\tend else begin\n\t\t\tif (out_req_valid && out_req_ready) begin\n\t\t\t\tdest_address <= dest_address + dest_stride[C_DMA_LENGTH_WIDTH-1:C_BYTES_PER_BEAT_WIDTH_DEST];\n\t\t\t\tsrc_address <= src_address + src_stride[C_DMA_LENGTH_WIDTH-1:C_BYTES_PER_BEAT_WIDTH_SRC];\n\t\t\t\ty_length <= y_length - 1'b1;\n\t\t\t\tout_req_sync_transfer_start <= 1'b0;\n\t\t\t\tif (y_length == 0) begin\n\t\t\t\t\tout_req_valid <= 1'b0;\n\t\t\t\t\treq_ready <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "dmac_2d_transfer",
        "module_hash": "4d146544a7dfbb75ae78eeab45fa35ac",
        "dataset_index": 23494
      },
      "four_bit_adder_8f4be089": {
        "rtl_code": "module four_bit_adder(\n    input signed [3:0] a,\n    input signed [3:0] b,\n    input signed cin,\n    output signed [3:0] sum,\n    output signed cout\n);\n\nwire signed [4:0] temp_sum;\nwire signed temp_cout;\n\nassign temp_sum = a + b + cin;\nassign sum = temp_sum[3:0];\nassign temp_cout = (temp_sum[4] == 1) ? 1 : 0;\nassign cout = temp_cout;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "8f4be0896b4e84b341fdc12e63aa46b7",
        "dataset_index": 7157
      },
      "snoop_module_e662fdb6": {
        "rtl_code": "\nmodule snoop_module(\n    input clk,\n    input reset,\n    input [7:0] snoopa,\n    input [7:0] snoopd,\n    input snoopp,\n    output reg snoopq,\n    output snoopm\n);\n\nreg [7:0] prgram [0:255];\n\ninteger i;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        snoopq <= 0;\n        i <= 0;\n    end else begin\n        snoopq <= prgram[snoopa];\n        if (snoopp) begin\n            prgram[snoopa] <= snoopd;\n        end\n        if (i == 255) begin\n            i <= 0;\n        end else begin\n            i <= i + 1;\n        end\n    end\nend\n\nassign snoopm = (i == 255);\n\nendmodule",
        "module_name": "snoop_module",
        "module_hash": "e662fdb64dcf38194aee46ef2fa578c1",
        "dataset_index": 10798
      },
      "shift_reg_463d2a93": {
        "rtl_code": "module shift_reg (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= {q[6:0], d};\nend\n\nendmodule\n\nmodule d_ff (\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(negedge clk) begin\n    q <= d;\nend\n\nendmodule\n\nmodule concat_module (\n    input [7:0] shift_reg_out,\n    input [0:0] d_ff_out,\n    output [15:0] q\n);\n\nassign q = {shift_reg_out, d_ff_out};\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [15:0] q\n);\n\nwire [7:0] shift_reg_out;\nwire [0:0] d_ff_out;\n\nshift_reg shift_reg_inst (\n    .clk(clk),\n    .d(d),\n    .q(shift_reg_out)\n);\n\nd_ff d_ff_inst (\n    .clk(clk),\n    .d(shift_reg_out[7]),\n    .q(d_ff_out)\n);\n\nconcat_module concat_inst (\n    .shift_reg_out(shift_reg_out),\n    .d_ff_out(d_ff_out),\n    .q(q)\n);\n\nendmodule",
        "module_name": "shift_reg",
        "module_hash": "463d2a93deeb9ec4db1222132391fe9e",
        "dataset_index": 11445
      },
      "traffic_light_7f1fdd70": {
        "rtl_code": "module traffic_light(\n    input clk,\n    input reset,\n    input car_sensor_road1_lane1,\n    input car_sensor_road1_lane2,\n    input car_sensor_road2_lane1,\n    input car_sensor_road2_lane2,\n    input pedestrian_sensor,\n    output reg [3:0] traffic_light_road1,\n    output reg [3:0] traffic_light_road2,\n    output reg pedestrian_light\n);\n\nparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\nparameter GREEN_TIME = 5, PEDESTRIAN_TIME = 10, YELLOW_TIME = 2;\n\nreg [1:0] state;\nreg [3:0] timer;\nreg [1:0] current_road1_lane;\nreg [1:0] current_road2_lane;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= S0;\n        timer <= 0;\n        current_road1_lane <= 2'b00;\n        current_road2_lane <= 2'b00;\n        traffic_light_road1 <= 4'b0100;\n        traffic_light_road2 <= 4'b0100;\n        pedestrian_light <= 1'b0;\n    end else begin\n        case (state)\n            S0: begin\n                if (timer == 0) begin\n                    if (pedestrian_sensor) begin\n                        state <= S1;\n                        timer <= PEDESTRIAN_TIME;\n                        pedestrian_light <= 1'b1;\n                        traffic_light_road1 <= {2'b10, 2'b01};\n                        traffic_light_road2 <= {2'b00, 2'b10};\n                    end else if (car_sensor_road1_lane1 || car_sensor_road1_lane2) begin\n                        state <= S1;\n                        timer <= GREEN_TIME;\n                        current_road1_lane <= 2'b01;\n                        traffic_light_road1 <= {2'b10, 2'b01};\n                        traffic_light_road2 <= {2'b00, 2'b10};\n                    end else if (car_sensor_road2_lane1 || car_sensor_road2_lane2) begin\n                        state <= S2;\n                        timer <= YELLOW_TIME;\n                        traffic_light_road1 <= {2'b10, 2'b00};\n                        traffic_light_road2 <= {2'b01, 2'b00};\n                    end\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n            S1: begin\n                if (timer == 0) begin\n                    state <= S2;\n                    timer <= YELLOW_TIME;\n                    traffic_light_road1 <= {2'b10, 2'b00};\n                    traffic_light_road2 <= {2'b01, 2'b00};\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n            S2: begin\n                if (timer == 0) begin\n                    if (pedestrian_sensor) begin\n                        state <= S3;\n                        timer <= PEDESTRIAN_TIME;\n                        pedestrian_light <= 1'b1;\n                        traffic_light_road1 <= {2'b00, 2'b10};\n                        traffic_light_road2 <= {2'b10, 2'b01};\n                    end else if (car_sensor_road2_lane1 || car_sensor_road2_lane2) begin\n                        state <= S3;\n                        timer <= GREEN_TIME;\n                        current_road2_lane <= 2'b01;\n                        traffic_light_road1 <= {2'b00, 2'b10};\n                        traffic_light_road2 <= {2'b10, 2'b01};\n                    end else if (car_sensor_road1_lane1 || car_sensor_road1_lane2) begin\n                        state <= S1;\n                        timer <= YELLOW_TIME;\n                        traffic_light_road1 <= {2'b10, 2'b01};\n                        traffic_light_road2 <= {2'b00, 2'b10};\n                    end\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n            S3: begin\n                if (timer == 0) begin\n                    state <= S0;\n                    timer <= YELLOW_TIME;\n                    traffic_light_road1 <= {2'b01, 2'b00};\n                    traffic_light_road2 <= {2'b01, 2'b00};\n                    pedestrian_light <= 1'b0;\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "traffic_light",
        "module_hash": "7f1fdd70d57a2325e9dc98505f48b92e",
        "dataset_index": 10180
      },
      "shift_reg_mux_adder_88aaf3f0": {
        "rtl_code": "\nmodule shift_reg_mux_adder (\n    input         clk,\n    input         d,\n    input  [255:0] in,\n    input   [7:0] sel,\n    output reg out\n);\n\n    reg [2:0] shift_reg;\n    reg [7:0] shifted_in;\n    wire [7:0] mux_out;\n    wire       reg_out;\n    \n    // Shift register\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[1:0], d};\n    end\n    \n    // Barrel shifter\n    always @(*) begin\n        case (sel)\n            8'h00: shifted_in = in[7:0];\n            8'h01: shifted_in = in[15:8];\n            8'h02: shifted_in = in[23:16];\n            8'h03: shifted_in = in[31:24];\n            8'h04: shifted_in = in[39:32];\n            8'h05: shifted_in = in[47:40];\n            8'h06: shifted_in = in[55:48];\n            8'h07: shifted_in = in[63:56];\n            8'h08: shifted_in = in[71:64];\n            8'h09: shifted_in = in[79:72];\n            8'h0A: shifted_in = in[87:80];\n            8'h0B: shifted_in = in[95:88];\n            8'h0C: shifted_in = in[103:96];\n            8'h0D: shifted_in = in[111:104];\n            8'h0E: shifted_in = in[119:112];\n            8'h0F: shifted_in = in[127:120];\n            8'h10: shifted_in = in[135:128];\n            8'h11: shifted_in = in[143:136];\n            8'h12: shifted_in = in[151:144];\n            8'h13: shifted_in = in[159:152];\n            8'h14: shifted_in = in[167:160];\n            8'h15: shifted_in = in[175:168];\n            8'h16: shifted_in = in[183:176];\n            8'h17: shifted_in = in[191:184];\n            8'h18: shifted_in = in[199:192];\n            8'h19: shifted_in = in[207:200];\n            8'h1A: shifted_in = in[215:208];\n            8'h1B: shifted_in = in[223:216];\n            8'h1C: shifted_in = in[231:224];\n            8'h1D: shifted_in = in[239:232];\n            8'h1E: shifted_in = in[247:240];\n            8'h1F: shifted_in = in[255:248];\n            default: shifted_in = 8'h00;\n        endcase\n    end\n    \n    // Multiplexer\n    assign mux_out = shifted_in;\n    \n    // 4-to-1 multiplexer\n    assign reg_out = mux_out[shift_reg[2:0]];\n    \n    // Adder\n    always @(*) begin\n        out = reg_out + shift_reg[2];\n    end\n    \nendmodule",
        "module_name": "shift_reg_mux_adder",
        "module_hash": "88aaf3f069795d44310fb3f11ad5221e",
        "dataset_index": 10756
      },
      "Control_Register_Block #_8ce8468d": {
        "rtl_code": "module Control_Register_Block #(\n  parameter n = 4, // number of control signals\n  parameter m = 2 // number of enable signals\n\n) (\n  input [n-1:0] ctrl,\n  output [m-1:0] en\n);\n\n\n// Define subsets of control signals for each enable signal\nparameter [n-1:0] en1_ctrls = 4'b0001;\nparameter [n-1:0] en2_ctrls = 4'b0011;\n\n// Implement the functionality of the control register block\nassign en[0] = (ctrl & en1_ctrls) == en1_ctrls;\nassign en[1] = (ctrl & en2_ctrls) == en2_ctrls;\n\nendmodule",
        "module_name": "Control_Register_Block #",
        "module_hash": "8ce8468dac80377cee3a3dad9599d747",
        "dataset_index": 1700
      },
      "pg_5_fbb5890b": {
        "rtl_code": "module pg_5 ( g, p, g_prec, p_prec, g_out, p_out );\n  input g, p, g_prec, p_prec;\n  output g_out, p_out;\n  wire   n5, n6;\n\n  and U1 (p_out, p, p_prec);\n  not U2 (n6, g);\n  nand U3 (n5, p, g_prec);\n  nand U4 (g_out, n5, n6);\nendmodule",
        "module_name": "pg_5",
        "module_hash": "fbb5890bbe8108c3fec544424d43b666",
        "dataset_index": 12960
      },
      "top_module_82273001": {
        "rtl_code": "module top_module( \n    input wire [15:0] in,\n    output wire [3:0] in1_hi, in1_lo,\n    output wire [3:0] in2_hi, in2_lo,\n    output wire [7:0] out );\n\n  wire [7:0] in1, in2;\n\n  // Split the 16-bit input into two 8-bit outputs\n  assign in1 = in[15:8];\n  assign in2 = in[7:0];\n\n  // Split each 8-bit input into two 4-bit inputs\n  assign in1_hi = in1[7:4];\n  assign in1_lo = in1[3:0];\n  assign in2_hi = in2[7:4];\n  assign in2_lo = in2[3:0];\n\n  // Compute the absolute difference between each pair of corresponding 4-bit inputs\n  wire [3:0] abs_diff_hi, abs_diff_lo;\n  assign abs_diff_hi = (in1_hi >= in2_hi) ? (in1_hi - in2_hi) : (in2_hi - in1_hi);\n  assign abs_diff_lo = (in1_lo >= in2_lo) ? (in1_lo - in2_lo) : (in2_lo - in1_lo);\n\n  // Output the sum of the absolute differences\n  assign out = abs_diff_hi + abs_diff_lo;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "82273001a924341c3592b480cac1c736",
        "dataset_index": 4591
      },
      "bridge_db1898f5": {
        "rtl_code": "module bridge (\n    input [7:0] RGA,\n    input [0:0] RGB,\n    input [7:0] OPT,\n    input [1:0] KEY,\n    input CLK,\n    input RST,\n    input ENA,\n    output reg [7:0] RGZ\n);\n\nreg [7:0] shift_reg;\nreg [7:0] not_reg;\nreg [7:0] zero_reg;\n\nalways @ (posedge CLK or negedge RST)\nbegin\n    if (!RST)\n    begin\n        shift_reg <= 8'b0;\n        not_reg <= 8'b0;\n        zero_reg <= 8'b0;\n    end\n    else if (ENA)\n    begin\n        case ({OPT, KEY})\n            8'b00000010: shift_reg <= {RGA[6:0], 1'b0};\n            8'b00000000: shift_reg <= {1'b0, RGA[7:1]};\n            8'b00000011: shift_reg <= {RGA[5:0], 2'b00};\n            8'b00000001: shift_reg <= {2'b00, RGA[7:2]};\n            8'b00000100: not_reg <= ~RGA;\n            8'b00000010: zero_reg <= 8'b0;\n            default: shift_reg <= RGA;\n        endcase\n    end\nend\n\nalways @*\nbegin\n    RGZ = RGB ? not_reg : (KEY == 2'b10 ? zero_reg : shift_reg);\nend\n\nendmodule",
        "module_name": "bridge",
        "module_hash": "db1898f5158851e1d9adadbf02227981",
        "dataset_index": 4231
      },
      "clock_gating_b86631d2": {
        "rtl_code": "module clock_gating (\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  always @ (posedge CLK) begin\n    if (TE) begin\n      ENCLK <= CLK;\n    end else if (EN) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "clock_gating",
        "module_hash": "b86631d28a3979632d572d79f566cf32",
        "dataset_index": 306
      },
      "top_module_61d42292": {
        "rtl_code": "\nmodule top_module(\n    input [254:0] in, // 255-bit input vector for population count circuit\n    input [31:0] in_swap, // 32-bit input vector for byte swapping module\n    output [7:0] count_out, // 8-bit output from population count circuit\n    output [31:0] swap_out, // 32-bit output from byte swapping module\n    output [7:0] sum_out, // 8-bit output from functional module\n    input clk // Clock signal\n);\n\n// Population count circuit\nreg [7:0] count_reg;\nreg [254:0] shift_reg;\nreg [7:0] adder_out;\n\nalways @(posedge clk) begin\n    shift_reg = {shift_reg[253:0], in};\n    adder_out = adder_out + shift_reg[254]; // \n    count_reg = adder_out;\nend\n\nassign count_out = count_reg;\n\n// Byte swapping module\nreg [7:0] swap_reg [3:0];\nreg [31:0] swap_out_reg;\n\nalways @(posedge clk) begin\n    swap_reg[0] = in_swap[31:24];\n    swap_reg[1] = in_swap[23:16];\n    swap_reg[2] = in_swap[15:8];\n    swap_reg[3] = in_swap[7:0];\n    swap_out_reg = {swap_reg[3], swap_reg[2], swap_reg[1], swap_reg[0]};\nend\n\nassign swap_out = swap_out_reg;\n\n// Functional module\nreg [7:0] sum_reg;\n\nalways @(posedge clk) begin\n    sum_reg = count_out + swap_out[31];\nend\n\nassign sum_out = sum_reg;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "61d422925d037e8cb119a784b8fb0615",
        "dataset_index": 19863
      },
      "Voter #_c80ef766": {
        "rtl_code": "\nmodule Voter #(parameter WIDTH = 1)(\n    input  [(WIDTH-1):0] A, B, C,\n    output [(WIDTH-1):0] True\n    );\n\ngenvar i;\n\ngenerate\t\n\tfor (i = 0; i < WIDTH; i = i +1) begin : Vote_Bit\nassign True[i] =  (A[i] && B[i]) || (A[i] && C[i]) || (B[i] && C[i]);\nend\nendgenerate\n\nendmodule\n",
        "module_name": "Voter #",
        "module_hash": "c80ef766c5e95bf487142f4a73fa7fc0",
        "dataset_index": 23515
      },
      "binary_counter_b19a5e1f": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      if (count == 4'b1111) begin\n        count <= 4'b0000;\n      end else begin\n        count <= count + 4'b0001;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "b19a5e1f6f273860086fe7e865f01551",
        "dataset_index": 10848
      },
      "top__21e57853": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [3:0] a, b, // Two 4-bit inputs\n    input select,     // Select input to choose between adder and subtractor outputs\n    output [3:0] out  // 4-bit output from the selected module\n);\n\n    // Declare internal wires\n    wire [3:0] add_out_int, sub_out_int;\n\n    // Instantiate the adder and subtractor modules\n    four_bit_adder adder(.a(a), .b(b), .sum(add_out_int));\n    four_bit_subtractor subtractor(.a(a), .b(b), .diff(sub_out_int));\n\n    // Declare a flip-flop for the reset signal\n    reg reset_ff;\n\n    // Synchronous active-high reset\n    always @(posedge clk) begin\n        if (reset) begin\n            reset_ff <= 1;\n        end else begin\n            reset_ff <= 0;\n        end\n    end\n\n    // Instantiate the select module\n    select_module select_inst(.add_out(add_out_int), .sub_out(sub_out_int), .select(select), .out(out));\n\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] a, b, // Two 4-bit inputs\n    output [3:0] sum  // 4-bit output from the adder\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule four_bit_subtractor (\n    input [3:0] a, b, // Two 4-bit inputs\n    output [3:0] diff // 4-bit output from the subtractor\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule select_module (\n    input [3:0] add_out, sub_out, // Outputs from the adder and subtractor modules\n    input select,                 // Select input to choose between adder and subtractor outputs\n    output [3:0] out              // Final output from the selected module\n);\n\n    assign out = select ? add_out : sub_out;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "21e5785388de1931374e9f5fdb78a8ef",
        "dataset_index": 18158
      },
      "pcie_rx_recv #_2b248ce5": {
        "rtl_code": "\n\n\nmodule pcie_rx_recv # (\n\tparameter\tC_PCIE_DATA_WIDTH\t\t\t= 128\n)\n(\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\ninput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\ts_axis_rx_tdata,\n\tinput\t[(C_PCIE_DATA_WIDTH/8)-1:0]\t\ts_axis_rx_tkeep,\n\tinput\t\t\t\t\t\t\t\t\ts_axis_rx_tlast,\n\tinput\t\t\t\t\t\t\t\t\ts_axis_rx_tvalid,\n\toutput\t\t\t\t\t\t\t\t\ts_axis_rx_tready,\n\tinput\t[21:0]\t\t\t\t\t\t\ts_axis_rx_tuser,\n\n\toutput\t\t\t\t\t\t\t\t\tpcie_mreq_err,\n\toutput\t\t\t\t\t\t\t\t\tpcie_cpld_err,\n\toutput\t\t\t\t\t\t\t\t\tpcie_cpld_len_err,\n\n\toutput\t\t\t\t\t\t\t\t\tmreq_fifo_wr_en,\n\toutput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\tmreq_fifo_wr_data,\n\n\toutput\t[7:0]\t\t\t\t\t\t\tcpld_fifo_tag,\n\toutput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\tcpld_fifo_wr_data,\n\toutput\t\t\t\t\t\t\t\t\tcpld_fifo_wr_en,\n\toutput\t\t\t\t\t\t\t\t\tcpld_fifo_tag_last\n);\n\n\nlocalparam\tS_RX_IDLE_SOF\t\t\t\t\t= 4'b0001;\nlocalparam\tS_RX_DATA\t\t\t\t\t\t= 4'b0010;\nlocalparam\tS_RX_STRADDLED\t\t\t\t\t= 4'b0100;\nlocalparam\tS_RX_STRADDLED_HOLD\t\t\t\t= 4'b1000;\n\nreg\t\t[3:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[3:0]\t\t\t\t\t\t\t\tnext_state;\n\n\nwire\t[4:0]\t\t\t\t\t\t\t\tw_rx_is_sof;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_rx_is_eof;\n\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head0;\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head1;\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head2;\n\nwire\t[2:0]\t\t\t\t\t\t\t\tw_mreq_head_fmt;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_mreq_head_type;\nwire\t\t\t\t\t\t\t\t\t\tw_mreq_head_ep;\nwire\t[2:0]\t\t\t\t\t\t\t\tw_cpld_head_fmt;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_cpld_head_type;\nwire\t\t\t\t\t\t\t\t\t\tw_cpld_head_ep;\nwire\t[9:0]\t\t\t\t\t\t\t\tw_cpld_head_len;\nwire\t[2:0]\t\t\t\t\t\t\t\tw_cpld_head_cs;\nwire\t[11:0]\t\t\t\t\t\t\t\tw_cpld_head_bc;\nwire\t[7:0]\t\t\t\t\t\t\t\tw_cpld_head_tag;\nwire\t\t\t\t\t\t\t\t\t\tw_pcie_mreq_type;\nwire\t\t\t\t\t\t\t\t\t\tw_pcie_cpld_type;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_mreq_type;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_type;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_mreq_err;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_err;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_len_err;\n\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_cpld_tag;\nreg\t\t[11:2]\t\t\t\t\t\t\t\tr_cpld_len;\nreg\t\t[11:2]\t\t\t\t\t\t\t\tr_cpld_bc;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_lhead;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_mem_req_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_data_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_tag_last;\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_straddled;\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_straddled_hold;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_data_straddled;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_s_axis_rx_tdata;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_s_axis_rx_tdata_d1;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_mreq_fifo_wr_en;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_mreq_fifo_wr_data;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_tag_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_wr_en;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_cpld_fifo_wr_data;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_tag_last;\n\nassign s_axis_rx_tready = ~r_rx_straddled_hold;\n\nassign pcie_mreq_err = r_pcie_mreq_err;\nassign pcie_cpld_err = r_pcie_cpld_err;\nassign pcie_cpld_len_err = r_pcie_cpld_len_err;\n\nassign mreq_fifo_wr_en = r_mreq_fifo_wr_en;\nassign mreq_fifo_wr_data = r_mreq_fifo_wr_data;\n\nassign cpld_fifo_tag = r_cpld_tag;\nassign cpld_fifo_wr_en = r_cpld_fifo_wr_en;\n\nassign cpld_fifo_wr_data[31:0] = {r_cpld_fifo_wr_data[7:0], r_cpld_fifo_wr_data[15:8], r_cpld_fifo_wr_data[23:16], r_cpld_fifo_wr_data[31:24]};\nassign cpld_fifo_wr_data[63:32] = {r_cpld_fifo_wr_data[39:32], r_cpld_fifo_wr_data[47:40], r_cpld_fifo_wr_data[55:48], r_cpld_fifo_wr_data[63:56]};\nassign cpld_fifo_wr_data[95:64] = {r_cpld_fifo_wr_data[71:64], r_cpld_fifo_wr_data[79:72], r_cpld_fifo_wr_data[87:80], r_cpld_fifo_wr_data[95:88]};\nassign cpld_fifo_wr_data[127:96] = {r_cpld_fifo_wr_data[103:96], r_cpld_fifo_wr_data[111:104], r_cpld_fifo_wr_data[119:112], r_cpld_fifo_wr_data[127:120]};\n\nassign cpld_fifo_tag_last = r_cpld_fifo_tag_last;\n\n\nassign w_rx_is_sof = s_axis_rx_tuser[14:10];\nassign w_rx_is_eof = s_axis_rx_tuser[21:17];\n\nalways @ (*)\nbegin\n\tif(w_rx_is_sof[3] == 1) begin\n\t\tr_pcie_head0 <= s_axis_rx_tdata[95:64];\n\t\tr_pcie_head1 <= s_axis_rx_tdata[127:96];\n\tend\n\telse begin\n\t\tr_pcie_head0 <= s_axis_rx_tdata[31:0];\n\t\tr_pcie_head1 <= s_axis_rx_tdata[63:32];\n\tend\n\n\tif(r_rx_straddled == 1)\n\t\tr_pcie_head2 <= s_axis_rx_tdata[31:0];\n\telse\n\t\tr_pcie_head2 <= s_axis_rx_tdata[95:64];\nend\n\n\n\nassign w_mreq_head_fmt = r_pcie_head0[31:29];\nassign w_mreq_head_type = r_pcie_head0[28:24];\nassign w_mreq_head_ep = r_pcie_head0[14];\nassign w_cpld_head_fmt = r_pcie_head0[31:29];\nassign w_cpld_head_type = r_pcie_head0[28:24];\nassign w_cpld_head_ep = r_pcie_head0[14];\nassign w_cpld_head_len = r_pcie_head0[9:0];\nassign w_cpld_head_cs = r_pcie_head1[15:13];\nassign w_cpld_head_bc = r_pcie_head1[11:0];\nassign w_cpld_head_tag = r_pcie_head2[15:8];\nassign w_pcie_mreq_type = ({w_mreq_head_fmt[2], w_mreq_head_type} == {1'b0, 5'b00000});\nassign w_pcie_cpld_type = ({w_cpld_head_fmt, w_cpld_head_type} == {3'b010, 5'b01010});\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0)\n\t\tcur_state <= S_RX_IDLE_SOF;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1 && w_rx_is_eof[4] == 0 ) begin\n\t\t\t\tif(w_rx_is_sof[3] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_DATA;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\t\tS_RX_DATA: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_eof[4] == 1) begin\n\t\t\t\tif(w_rx_is_sof[4] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_DATA;\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_eof[4] == 1) begin\n\t\t\t\tif(w_rx_is_sof[4] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse if(w_rx_is_eof[3] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED_HOLD;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1) begin\n\t\tr_pcie_mreq_type <= w_pcie_mreq_type & ~w_mreq_head_ep;\n\t\tr_pcie_cpld_type <= w_pcie_cpld_type & ~w_cpld_head_ep & (w_cpld_head_cs == 0);\n\n\t\tr_cpld_len <= w_cpld_head_len;\n\t\tr_cpld_bc[11:2] <= w_cpld_head_bc[11:2];\n\tend\nend\n\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_pcie_mreq_err <= 0;\n\t\tr_pcie_cpld_err <= 0;\n\t\tr_pcie_cpld_len_err <= 0;\n\tend\n\telse begin\n\t\tif(r_pcie_cpld_type == 1 && r_cpld_len < 2) begin\n\t\t\tr_pcie_cpld_len_err <= 1;\n\t\tend\n\n\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1) begin\n\t\t\tr_pcie_mreq_err <= w_pcie_mreq_type & w_mreq_head_ep;\n\t\t\tr_pcie_cpld_err <= w_pcie_cpld_type & (w_cpld_head_ep | (w_cpld_head_cs != 0));\n\t\tend\n\tend\nend\n\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tr_cpld_tag <= w_cpld_head_tag;\n\t\t\tr_cpld_lhead <= 0;\n\t\tend\n\t\tS_RX_DATA: begin\n\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tif(s_axis_rx_tvalid == 1)\n\t\t\t\tr_cpld_lhead <= ~w_rx_is_sof[4];\n\n\t\t\tif(r_cpld_lhead == 0)\n\t\t\t\tr_cpld_tag <= w_cpld_head_tag;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\n\t\tend\n\t\tdefault: begin\n\n\t\tend\n\tendcase\nend\n\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tr_mem_req_en <= (s_axis_rx_tvalid & w_rx_is_sof[4] & ~w_rx_is_sof[3]) & w_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= 0;\n\t\t\tr_cpld_tag_last <= 0;\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_DATA: begin\n\t\t\tr_mem_req_en <= s_axis_rx_tvalid & r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= s_axis_rx_tvalid & r_pcie_cpld_type;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & (s_axis_rx_tvalid & r_pcie_cpld_type & w_rx_is_eof[4]);\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tr_mem_req_en <= s_axis_rx_tvalid & r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= s_axis_rx_tvalid & r_pcie_cpld_type & r_cpld_lhead;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & (s_axis_rx_tvalid & r_pcie_cpld_type & w_rx_is_eof[4] & ~w_rx_is_eof[3]);\n\t\t\tr_rx_straddled <= 1;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\t\t\tr_mem_req_en <= r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= r_pcie_cpld_type;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & r_pcie_cpld_type;\n\t\t\tr_rx_straddled <= 1;\n\t\t\tr_rx_straddled_hold <= 1;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_mem_req_en <= 0;\n\t\t\tr_cpld_data_en <= 0;\n\t\t\tr_cpld_tag_last <= 0;\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_mreq_fifo_wr_en <= r_mem_req_en;\n\tr_cpld_fifo_wr_en <= r_cpld_data_en;\n\tr_cpld_fifo_tag_last <= r_cpld_tag_last;\n\tr_rx_data_straddled <= r_rx_straddled;\n\n\tif(s_axis_rx_tvalid == 1 || r_rx_straddled_hold == 1) begin\n\t\tr_s_axis_rx_tdata <= s_axis_rx_tdata;\n\t\tr_s_axis_rx_tdata_d1 <= r_s_axis_rx_tdata;\n\tend\nend\n\nalways @ (*)\nbegin\n\tif(r_rx_data_straddled == 1)\n\t\tr_mreq_fifo_wr_data <= {r_s_axis_rx_tdata[63:0], r_s_axis_rx_tdata_d1[127:64]};\n\telse\n\t\tr_mreq_fifo_wr_data <= r_s_axis_rx_tdata;\n\n\tif(r_rx_data_straddled == 1)\n\t\tr_cpld_fifo_wr_data <= {r_s_axis_rx_tdata[31:0], r_s_axis_rx_tdata_d1[127:32]};\n\telse\n\t\tr_cpld_fifo_wr_data <= {r_s_axis_rx_tdata[95:0], r_s_axis_rx_tdata_d1[127:96]};\nend\n\n\nendmodule",
        "module_name": "pcie_rx_recv #",
        "module_hash": "2b248ce59b397936f27936d11787ba5e",
        "dataset_index": 25697
      },
      "top_module_36a9a4bc": {
        "rtl_code": "\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] in,\n    output [7:0] q\n);\n\n    wire [99:0] rotated_data;\n    wire [2:0] comb_out;\n    wire [7:0] final_out;\n\n    rotator rotator_inst(\n        .clk(clk),\n        .load(load),\n        .ena(ena),\n        .data(in),\n        .rotated_data(rotated_data)\n    );\n\n    combinational combinational_inst(\n        .in(rotated_data),\n        .out(comb_out)\n    );\n\n    final_module final_inst(\n        .in1(rotated_data[7:0]),\n        .in2(comb_out),\n        .out(final_out)\n    );\n\n    assign q = final_out;\n\nendmodule\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] rotated_data\n);\n\n    reg [99:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else begin\n            if (ena[0]) begin\n                shift_reg <= {shift_reg[98:0], shift_reg[99]};\n            end else if (ena[1]) begin\n                shift_reg <= {shift_reg[1:99], shift_reg[0]};\n            end\n        end\n    end\n\n    assign rotated_data = shift_reg;\n\nendmodule\nmodule combinational(\n    input [99:0] in,\n    output [2:0] out\n);\n\n    assign out[0] = &in;\n    assign out[1] = |in;\n    assign out[2] = ^in;\n\nendmodule\nmodule final_module(\n    input [7:0] in1,\n    input [2:0] in2,\n    output [7:0] out\n);\n\n    reg [7:0] out;\n\n    always @(*) begin\n        case (in2)\n            3'b000: out = in1 & 8'hFF;\n            3'b001: out = in1 | 8'hFF;\n            3'b010: out = in1 ^ 8'hFF;\n            3'b011: out = in1 + 8'h01;\n            3'b100: out = in1 - 8'h01;\n            default: out = 8'h00;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "36a9a4bc6b9964b1435cf400149bb2d4",
        "dataset_index": 11163
      },
      "spis_5ea0c3e2": {
        "rtl_code": "\nmodule spis(\n    input clk,\n    input rst,\n    input SCLK,\n    input SSbar,\n    input MOSI,\n    output reg[7:0] dout,\n    output reg data_present,\n    input rd\n    );\n\t  \n\t reg clear;\n\t always @(posedge clk or posedge rst) begin\n\t\tif(rst) clear <= 1;\n\t\telse if(rd) clear <= 1;\n\t\t\t\telse clear <= 0;\n\t end\n\n\t always @(posedge rst or posedge SCLK) begin\n\t\tif(rst) dout <= 0;\n\t\telse if (SSbar==0 & ~data_present) dout <= { dout[6:0] , MOSI};\n\t end\n\t \n\t reg data_present_temp;\n\t always @(posedge SSbar or posedge clear) begin\n\t\tif(clear)\tdata_present_temp <= 0;\n\t\telse\tdata_present_temp <= 1;\n\t end\n\t \n\t always @(posedge clk or posedge rst) begin\n\t\tif(rst) data_present <= 0;\n\t\telse data_present <= data_present_temp;\n\t end\n\nendmodule\n",
        "module_name": "spis",
        "module_hash": "5ea0c3e2e332d4d2ec68361de7371922",
        "dataset_index": 24184
      },
      "vga_67df3312": {
        "rtl_code": "module vga(input vclock,\n            output reg [9:0] hcount,  // pixel number on current line\n            output reg [9:0] vcount,  // line number\n            output reg vsync,hsync,blank);\n\n// VGA (640x480) @ 60 Hz\nparameter VGA_HBLANKON  =  10'd639;\nparameter VGA_HSYNCON   =  10'd655;\nparameter VGA_HSYNCOFF  =  10'd751;\nparameter VGA_HRESET    =  10'd799;\nparameter VGA_VBLANKON  =  10'd479;\nparameter VGA_VSYNCON   =  10'd490;\nparameter VGA_VSYNCOFF  =  10'd492;\nparameter VGA_VRESET    =  10'd523;\n\nreg hblank,vblank;\nwire hsyncon,hsyncoff,hreset,hblankon;\nassign hblankon = (hcount == VGA_HBLANKON);\nassign hsyncon = (hcount == VGA_HSYNCON);\nassign hsyncoff = (hcount == VGA_HSYNCOFF);\nassign hreset = (hcount == VGA_HRESET);\n\nwire vsyncon,vsyncoff,vreset,vblankon;\nassign vblankon = hreset & (vcount == VGA_VBLANKON);\nassign vsyncon = hreset & (vcount == VGA_VSYNCON);\nassign vsyncoff = hreset & (vcount == VGA_VSYNCOFF);\nassign vreset = hreset & (vcount == VGA_VRESET);\n\n// sync and blanking\nwire next_hblank,next_vblank;\nassign next_hblank = hreset ? 0 : hblankon ? 1 : hblank;\nassign next_vblank = vreset ? 0 : vblankon ? 1 : vblank;\n\n// VGA controller\nalways @(posedge vclock) begin\n    if (hcount == 799 && vcount == 523) begin\n        // End of frame, reset counters\n        hcount <= 0;\n        vcount <= 0;\n    end else if (hcount == 799) begin\n        // End of line, reset hcount\n        hcount <= 0;\n        vcount <= vcount + 1;\n    end else begin\n        // Increment hcount\n        hcount <= hcount + 1;\n    end\n\n    // Update sync and blanking signals\n    hblank <= next_hblank;\n    hsync <= hsyncon ? 0 : hsyncoff ? 1 : hsync;  // active low\n    vblank <= next_vblank;\n    vsync <= vsyncon ? 0 : vsyncoff ? 1 : vsync;  // active low\n    blank <= next_vblank | (next_hblank & ~hreset);\nend\n\nendmodule",
        "module_name": "vga",
        "module_hash": "67df3312081c0f86328d4727bd9515c5",
        "dataset_index": 18245
      },
      "decoder_7914e129": {
        "rtl_code": "\nmodule decoder (\n    input [2:0] ABC,\n    input clk,  // Clock input added\n    output reg [7:0] Y\n);\n\nreg [2:0] A, B, C;\nreg [7:0] Y_temp;\n\nalways @ (posedge clk) begin\n    A <= ABC[0];\n    B <= ABC[1];\n    C <= ABC[2];\nend\n\nalways @ (posedge clk) begin\n    Y_temp <= 8'b00000000;\n    if (A == 0 && B == 0 && C == 0) Y_temp[0] <= 1;\n    else if (A == 0 && B == 0 && C == 1) Y_temp[1] <= 1;\n    else if (A == 0 && B == 1 && C == 0) Y_temp[2] <= 1;\n    else if (A == 0 && B == 1 && C == 1) Y_temp[3] <= 1;\n    else if (A == 1 && B == 0 && C == 0) Y_temp[4] <= 1;\n    else if (A == 1 && B == 0 && C == 1) Y_temp[5] <= 1;\n    else if (A == 1 && B == 1 && C == 0) Y_temp[6] <= 1;\n    else if (A == 1 && B == 1 && C == 1) Y_temp[7] <= 1;\nend\n\nalways @ (posedge clk) begin\n    Y <= Y_temp;\nend\n\nendmodule\n",
        "module_name": "decoder",
        "module_hash": "7914e1292673426a1aefaa64b476fa43",
        "dataset_index": 15762
      },
      "WcaDcOffset_ddaa2e2b": {
        "rtl_code": "\nmodule WcaDcOffset (\n    input clock, \n    input reset, \n    input strobe,\t \n\t input  iqSel,\n\n    input  signed [11:0] sig_in,    output signed [11:0] dcoffset,  output signed [11:0] sigout \t );\n\n\n\t \n\n\treg  signed [25:0] integrator[1:0];\n\n\tassign dcoffset = integrator[iqSel][25:14];\n   assign sigout   = sig_in - dcoffset;\n\twire  signed [25:0] update = integrator[iqSel] + {{(14){sigout[11]}},sigout}; \n\t\t\n   always @(negedge clock)\n\t begin\n     if(reset)\n\t  begin \n\t\t integrator[0] <= #1 26'd0;\n\t\t integrator[1] <= #1 26'd0;\n\t  end\n     else if(strobe) \n\t\t integrator[iqSel] <= #1 update; \n\t end \n\n\n\nendmodule ",
        "module_name": "WcaDcOffset",
        "module_hash": "ddaa2e2bf4d97dd96003e521cb8fae31",
        "dataset_index": 10899
      },
      "counter_49474d96": {
        "rtl_code": "module counter (\n    input clk,\n    input rst,\n    input up_down,\n    output [3:0] count\n);\n\n    reg [3:0] count_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count_reg <= 4'b0000;\n        end else begin\n            if (up_down == 1) begin\n                if (count_reg == 4'b0000) begin\n                    count_reg <= 4'b1111;\n                end else begin\n                    count_reg <= count_reg - 1;\n                end\n            end else begin\n                if (count_reg == 4'b1111) begin\n                    count_reg <= 4'b0000;\n                end else begin\n                    count_reg <= count_reg + 1;\n                end\n            end\n        end\n    end\n\n    assign count = count_reg;\n\nendmodule",
        "module_name": "counter",
        "module_hash": "49474d96a292665104e419ab0aa5fd70",
        "dataset_index": 19152
      },
      "shift_register_144ffa03": {
        "rtl_code": "\nmodule shift_register (\n    LOAD,\n    DATA_IN,\n    CLK,\n    RESET_B,\n    DATA_OUT,\n    Q_N\n);\n\n    input LOAD;\n    input [3:0] DATA_IN;\n    input CLK;\n    input RESET_B;\n    output [3:0] DATA_OUT;\n    output Q_N;\n\n    wire [3:0] Q;\n    wire DATAPATH_LOAD;\n\n    assign DATAPATH_LOAD = RESET_B && LOAD;\n\n    DFF flip_flop_0 (\n        .D(DATA_IN[0]),\n        .Q(Q[0]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    DFF flip_flop_1 (\n        .D(Q[0]),\n        .Q(Q[1]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    DFF flip_flop_2 (\n        .D(Q[1]),\n        .Q(Q[2]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    DFF flip_flop_3 (\n        .D(Q[2]),\n        .Q(Q[3]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    assign Q_N = ~Q[3];\n\n    assign DATA_OUT = Q;\n\nendmodule\nmodule DFF (\n    D,\n    Q,\n    CLK,\n    RST_N,\n    SET_N\n);\n\n    input D;\n    output Q;\n    input CLK;\n    input RST_N;\n    input SET_N;\n\n    wire D1, D2;\n\n    nand (D1, RST_N, SET_N);\n    nand (D2, D1, D, CLK);\n    nand (Q, RST_N, CLK, D2);\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "144ffa033577d67aea062c4e879a261f",
        "dataset_index": 12602
      },
      "binary_counter_edf5570d": {
        "rtl_code": "\nmodule binary_counter(input clk, rst, en, output reg [3:0] count);\n\n  reg [3:0] next_count;\n  reg carry_out;\n\n  always @(*) begin\n    if (rst) begin\n      next_count = 4'b0;\n    end\n    else if (en) begin\n      next_count = count + 1'b1;\n    end\n    else begin\n      next_count = count;\n    end\n  end\n\n  always @(posedge clk) begin\n    count <= next_count;\n  end\n\n  always @(*)\n  if (count == 4'b1111)\n      carry_out = 1'b1;\n  else\n      carry_out = 1'b0;\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "edf5570d6bf562b1b20511edd820d63a",
        "dataset_index": 14442
      },
      "top_module_15626ab9": {
        "rtl_code": "module top_module( \n    input [7:0] in,\n    input [1:0] sel,\n    output [3:0] out );\n    \n    wire [1:0] sel_inv;\n    assign sel_inv = ~sel;\n    \n    wire [1:0] sel_2to1;\n    assign sel_2to1[0] = sel[0];\n    assign sel_2to1[1] = sel[1];\n    \n    wire [1:0] sel_inv_2to1;\n    assign sel_inv_2to1[0] = sel_inv[0];\n    assign sel_inv_2to1[1] = sel_inv[1];\n    \n    wire [1:0] mux1_out;\n    wire [1:0] mux2_out;\n    wire [1:0] mux3_out;\n    wire [1:0] mux4_out;\n    \n    mux_2to1 mux1(.in0(in[1:0]), .in1(in[3:2]), .sel(sel_2to1[0]), .out(mux1_out));\n    mux_2to1 mux2(.in0(in[5:4]), .in1(in[7:6]), .sel(sel_2to1[1]), .out(mux2_out));\n    mux_2to1 mux3(.in0(mux1_out), .in1(mux2_out), .sel(sel_inv_2to1[0]), .out(mux3_out));\n    mux_2to1 mux4(.in0(mux3_out), .in1(mux3_out), .sel(sel_inv_2to1[1]), .out(mux4_out));\n    \n    assign out = mux4_out;\n    \nendmodule\n\nmodule mux_2to1(\n    input [1:0] in0,\n    input [1:0] in1,\n    input sel,\n    output [1:0] out );\n    \n    assign out = (sel == 1'b0) ? in0 : in1;\n    \nendmodule",
        "module_name": "top_module",
        "module_hash": "15626ab903abc5a1a8b9058a35c2b21b",
        "dataset_index": 20514
      },
      "fifo_empty_block_1535e5a4": {
        "rtl_code": "\nmodule fifo_empty_block (\n   rd_fifo_empty, rd_addr, rd_gray_pointer,\n   reset, rd_clk, rd_wr_gray_pointer, rd_read\n   );\n\n   parameter AW   = 2; input           reset;\n   input           rd_clk;\n   \n   input [AW:0]    rd_wr_gray_pointer;input           rd_read;\n   \n   output          rd_fifo_empty;\n   output [AW-1:0] rd_addr;\n   output [AW:0]   rd_gray_pointer;\n   \n   reg [AW:0]      rd_gray_pointer;\n   reg [AW:0]      rd_binary_pointer;\n   reg             rd_fifo_empty;\n\n   wire \t   rd_fifo_empty_next;\n   wire [AW:0]     rd_binary_next;\n   wire [AW:0]     rd_gray_next;\n   \n   \n   always @(posedge rd_clk or posedge reset)\n     if(reset)\n       begin\n\t  rd_binary_pointer[AW:0]     <= {(AW+1){1'b0}};\n\t  rd_gray_pointer[AW:0]       <= {(AW+1){1'b0}};\n       end\n     else if(rd_read)\n       begin\n\t  rd_binary_pointer[AW:0]     <= rd_binary_next[AW:0];\t  \n\t  rd_gray_pointer[AW:0]       <= rd_gray_next[AW:0];\t  \n       end\n\n   assign rd_addr[AW-1:0]        = rd_binary_pointer[AW-1:0];\n\n   assign rd_binary_next[AW:0]  = rd_binary_pointer[AW:0] + \n\t\t\t\t  {{(AW){1'b0}},rd_read};\n\n   assign rd_gray_next[AW:0] = {1'b0,rd_binary_next[AW:1]} ^ \n\t\t\t       rd_binary_next[AW:0];\n\n\n   assign rd_fifo_empty_next = (rd_gray_next[AW:0]==rd_wr_gray_pointer[AW:0]);\n\n   always @ (posedge rd_clk or posedge reset)\n     if(reset)\n       rd_fifo_empty <= 1'b1;\n     else \n       rd_fifo_empty <= rd_fifo_empty_next;\n \nendmodule ",
        "module_name": "fifo_empty_block",
        "module_hash": "1535e5a474853b7931a68d31b38bc206",
        "dataset_index": 3838
      },
      "unknown_module_0ecf5a3b": {
        "rtl_code": "`define\tWBA_ALTERNATING\nmodule\twbarbiter(i_clk, i_rst, \n\ti_a_cyc, i_a_stb, i_a_we, i_a_adr, i_a_dat, i_a_sel, o_a_ack, o_a_stall, o_a_err,\n\ti_b_cyc, i_b_stb, i_b_we, i_b_adr, i_b_dat, i_b_sel, o_b_ack, o_b_stall, o_b_err,\n\to_cyc, o_stb, o_we, o_adr, o_dat, o_sel, i_ack, i_stall, i_err);\n\tparameter\t\t\tDW=32, AW=19;\n\tinput\twire\t\t\ti_clk, i_rst;\n\tinput\twire\t\t\ti_a_cyc, i_a_stb, i_a_we;\n\tinput\twire\t[(AW-1):0]\ti_a_adr;\n\tinput\twire\t[(DW-1):0]\ti_a_dat;\n\tinput\twire\t[(DW/8-1):0]\ti_a_sel;\n\toutput\twire\t\t\to_a_ack, o_a_stall, o_a_err;\n\tinput\twire\t\t\ti_b_cyc, i_b_stb, i_b_we;\n\tinput\twire\t[(AW-1):0]\ti_b_adr;\n\tinput\twire\t[(DW-1):0]\ti_b_dat;\n\tinput\twire\t[(DW/8-1):0]\ti_b_sel;\n\toutput\twire\t\t\to_b_ack, o_b_stall, o_b_err;\n\toutput\twire\t\t\to_cyc, o_stb, o_we;\n\toutput\twire\t[(AW-1):0]\to_adr;\n\toutput\twire\t[(DW-1):0]\to_dat;\n\toutput\twire\t[(DW/8-1):0]\to_sel;\n\tinput\twire\t\t\ti_ack, i_stall, i_err;\n\n\treg\tr_cyc;\n\talways @(posedge i_clk)\n\t\tif (i_rst)\n\t\t\tr_cyc <= 1'b0;\n\t\telse\n\t\t\tr_cyc <= o_cyc;\n\n\twire\tw_a_owner, w_b_owner;   \n\tassign o_cyc = ((~r_cyc)&&((i_a_cyc)||(i_b_cyc))) || ((r_cyc)&&((w_a_owner)||(w_b_owner)));\n\n\n\treg\tr_a_owner, r_b_owner;\n`ifdef\tWBA_ALTERNATING\n\treg\tr_a_last_owner;\n\n`endif\n\talways @(posedge i_clk)\n\t\tif (i_rst)\n\t\tbegin\n\t\t\tr_a_owner <= 1'b0;\n\t\t\tr_b_owner <= 1'b0;\n\t\tend else begin\n\t\t\tr_a_owner <= w_a_owner;\n\t\t\tr_b_owner <= w_b_owner;\n`ifdef\tWBA_ALTERNATING\n\t\t\tif (w_a_owner)\n\t\t\t\tr_a_last_owner <= 1'b1;\n\t\t\telse if (w_b_owner)\n\t\t\t\tr_a_last_owner <= 1'b0;\n`endif\n\t\tend\n\t`ifdef\tWBA_ALTERNATING\n\tassign w_a_owner = (i_a_cyc)\t&& ((r_a_owner) || ((~r_cyc) &&((~i_b_cyc) ||(~r_a_last_owner)) )); assign w_b_owner = (i_b_cyc)&& ((r_b_owner) || ((~r_cyc)&&((~i_a_cyc)||(r_a_last_owner)) ));\n`else\n\tassign w_a_owner = (i_a_cyc)&& ((r_a_owner) ||  (~r_cyc) );\n\tassign w_b_owner = (i_b_cyc)&& ((r_b_owner) || ((~r_cyc)&&(~i_a_cyc)) );\n`endif\n\n\tassign o_stb = (o_cyc) && ((w_a_owner) ? i_a_stb : i_b_stb);\n\tassign o_we  = (w_a_owner) ? i_a_we  : i_b_we;\n\tassign o_adr = (w_a_owner) ? i_a_adr : i_b_adr;\n\tassign o_dat = (w_a_owner) ? i_a_dat : i_b_dat;\n\tassign o_sel = (w_a_owner) ? i_a_sel : i_b_sel;\n\n\tassign\to_a_ack   = (w_a_owner) ? i_ack   : 1'b0;\n\tassign\to_b_ack   = (w_b_owner) ? i_ack   : 1'b0;\n\n\tassign\to_a_stall = (w_a_owner) ? i_stall : 1'b1;\n\tassign\to_b_stall = (w_b_owner) ? i_stall : 1'b1;\n\n\tassign\to_a_err = (w_a_owner) ? i_err : 1'b0;\n\tassign\to_b_err = (w_b_owner) ? i_err : 1'b0;\n\nendmodule\n\n",
        "module_name": "unknown_module",
        "module_hash": "0ecf5a3baec976b3f7725c19b7fb8a62",
        "dataset_index": 12365
      },
      "top__efaf92b0": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input select,  // 1 to use adder, 0 to use shifter\n    input [31:0] a,  // input for carry select adder\n    input [31:0] b,  // input for carry select adder\n    input [3:0] data,  // input for barrel shifter\n    output reg [31:0] q  // output from selected module\n);\n\n    // Define internal signals\n    wire [31:0] adder_out;\n    wire [3:0] shifter_out;\n    reg [3:0] buffer [3:0];\n    reg [1:0] buffer_ptr;\n\n    // Define carry select adder\n    carry_select_adder adder_inst (\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        .s(adder_out),\n        .cout()\n    );\n\n    // Define barrel shifter\n    always @(posedge clk) begin\n        if (areset) begin\n            buffer_ptr <= 2'b0;\n        end else begin\n            if (load) begin\n                buffer[buffer_ptr] <= data;\n            end else if (ena) begin\n                buffer[buffer_ptr] <= {1'b0, buffer[buffer_ptr][3:1]};\n            end\n            buffer_ptr <= buffer_ptr + 1'b1;\n        end\n    end\n    assign shifter_out = buffer[buffer_ptr];\n\n    // Select output based on select input\n    always @(posedge clk) begin\n        if (areset) begin\n            q <= 32'b0;\n        end else begin\n            if (select) begin\n                q <= adder_out;\n            end else begin\n                q <= {28'b0, shifter_out};\n            end\n        end\n    end\n\nendmodule\nmodule carry_select_adder (\n    input [31:0] a,\n    input [31:0] b,\n    input cin,\n    output reg [31:0] s,\n    output reg cout\n);\n    reg [31:0] p, g;\n    reg [4:0] c;\n\n    always @(*) begin\n        p = a + b;\n        g = a & b;\n        c[0] = cin;\n        c[1] = g[0] | (p[0] & cin);\n        c[2] = g[1] | (p[1] & c[1]);\n        c[3] = g[2] | (p[2] & c[2]);\n        c[4] = g[3] | (p[3] & c[3]);\n        s = p + (c[4] << 4);\n        cout = c[4];\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "efaf92b084e6f3bb32f6288c672624e7",
        "dataset_index": 4860
      },
      "InputCell_f57bdd64": {
        "rtl_code": "\n\n\n\n\n\nmodule InputCell( InputPin, FromPreviousBSCell, CaptureDR, ShiftDR, TCK, ToNextBSCell);\ninput  InputPin;\ninput  FromPreviousBSCell;\ninput  CaptureDR;\ninput  ShiftDR; \ninput  TCK;     \n                \nreg Latch;      \n                \noutput ToNextBSCell;\nreg    ToNextBSCell;\n\nwire SelectedInput = CaptureDR? InputPin : FromPreviousBSCell;\n\nalways @ (posedge TCK)\nbegin\n\tif(CaptureDR | ShiftDR)\n\t\tLatch<=SelectedInput;\nend\n\nalways @ (negedge TCK)\nbegin\n\tToNextBSCell<=Latch;\nend\n\n\nendmodule\t// InputCell",
        "module_name": "InputCell",
        "module_hash": "f57bdd64b5f4e580996dae959ef4f056",
        "dataset_index": 25448
      },
      "my_fir_h3_f8d67901": {
        "rtl_code": "module my_fir_h3 (clk, new_data_rdy, output_data_ready, din, dout);\n\n    parameter WIDTH = 5'b10000;\n    parameter COEF0_3 = -9;\n    parameter COEF1_3 = -56;\n    parameter COEF2_3 = -109;\n    parameter COEF4_3 = 109;\n    parameter COEF5_3 = 56;\n    parameter COEF6_3 = 9;\n\n    input clk; \n    input[WIDTH - 1:0] din; \n    output[28 - 1:0] dout; \n    reg[28 - 1:0] dout;\n    input new_data_rdy;\n    output output_data_ready;\n    reg output_data_ready;\n\n    reg[WIDTH - 1:0]n_delay_reg1;\n    reg[WIDTH - 1:0]n_delay_reg2;\n    reg[WIDTH - 1:0]n_delay_reg3;\n    reg[WIDTH - 1:0]n_delay_reg4;\n    reg[WIDTH - 1:0]n_delay_reg5;\n    reg[WIDTH - 1:0]n_delay_reg6;\n\n    always @(posedge clk)\n    begin\n        if (new_data_rdy == 1'b1)\n        begin\n            n_delay_reg1 <= din;\n            n_delay_reg2 <= n_delay_reg1;\n            n_delay_reg3 <= n_delay_reg2;\n            n_delay_reg4 <= n_delay_reg3;\n            n_delay_reg5 <= n_delay_reg4;\n            n_delay_reg6 <= n_delay_reg5;\n        \n            output_data_ready <= 1'b1;\n            dout <= (din * COEF0_3) + \n                (n_delay_reg1 * COEF1_3) + \n                (n_delay_reg2 * COEF2_3) + \n                (n_delay_reg4 * COEF4_3) + \n                (n_delay_reg5 * COEF5_3) + \n                (n_delay_reg6 * COEF6_3);\n        end\n        else\n        begin\n            output_data_ready <= 1'b0;\n        end\n    end\nendmodule",
        "module_name": "my_fir_h3",
        "module_hash": "f8d6790159c70f6ab2fde6edffb13d48",
        "dataset_index": 13311
      },
      "adder_2bb9263e": {
        "rtl_code": "module adder(input [3:0] a, input [3:0] b, output reg [4:0] sum);\n\n  always @(*) begin\n    sum = a + b;\n    if (sum > 15) sum = sum[3:0];\n  end\n\nendmodule",
        "module_name": "adder",
        "module_hash": "2bb9263e97840f307b4475768f431bbf",
        "dataset_index": 8720
      },
      "sky130_fd_sc_hd__nand2_687d63aa": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nand2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A           );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nand2",
        "module_hash": "687d63aa895de515603676761ad2acae",
        "dataset_index": 23738
      },
      "clockdivider_1d0b0682": {
        "rtl_code": "\nmodule clockdivider(\n\t input clk,\n    input rst,\n\t input select,\n    output reg [31:0] OUT1,\n\t output reg [31:0] OUT2,\n    output clkdivided1hz,\n\t output clkdivided200hz,\n\t output clkselect\n    );\n\t \n\t always @ (posedge clk or posedge rst)\n\t\tbegin\n\t\tif (rst)\n\t\t\tOUT1<=32'd0;\n\t\telse\n\t\tif (OUT1 == 32'd50000000)\n\t\t\tOUT1<=32'd0;\n\t\telse\n\t\t\tOUT1 <= OUT1 + 1;\n\t\tend\n\t\t\n\t always @ (posedge clk or posedge rst)\n\t\tbegin\n\t\tif (rst)\n\t\t\tOUT2<=32'd0;\n\t\telse\n\t\tif (OUT2 == 32'd500000)\n\t\t\tOUT2<=32'd0;\n\t\telse\n\t\t\tOUT2 <= OUT2 + 1;\n\t\tend\nassign clkdivided1hz = (OUT1 == 32'd50000000);\nassign clkdivided200hz = (OUT2 == 32'd250000);\n\nassign clkselect  = clkdivided200hz;\nendmodule\n",
        "module_name": "clockdivider",
        "module_hash": "1d0b068259c33a59f2381404246213fb",
        "dataset_index": 22122
      },
      "data_accumulation_f9707220": {
        "rtl_code": "module data_accumulation (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input valid_a,\n  input ready_b,\n  output reg ready_a,\n  output reg valid_b,\n  output reg [15:0] data_out\n);\n\n  parameter THRESHOLD = 256; // configurable threshold value\n  \n  reg [15:0] accumulator = 0;\n  reg [3:0] count = 0;\n  reg [15:0] temp_data = 0;\n  reg [15:0] next_accumulator;\n  \n  always @ (posedge clk) begin\n    if (reset) begin\n      accumulator <= 0;\n      count <= 0;\n      valid_b <= 0;\n    end\n    else if (valid_a) begin\n      temp_data <= data_in << (count * 8);\n      accumulator <= next_accumulator;\n      count <= count + 1;\n      if (count == 1) begin\n        ready_a <= 0;\n      end\n      else if (count == 2) begin\n        ready_a <= 1;\n      end\n      if (accumulator >= THRESHOLD) begin\n        valid_b <= 1;\n      end\n    end\n    else if (ready_b && valid_b) begin\n      accumulator <= 0;\n      count <= 0;\n      valid_b <= 0;\n      ready_a <= 1;\n    end\n  end\n  \n  always @*\n    next_accumulator = accumulator + temp_data;\n  \n  always @*\n    data_out = accumulator;\n\nendmodule",
        "module_name": "data_accumulation",
        "module_hash": "f970722034a91c5be6b29529294316f9",
        "dataset_index": 6794
      },
      "complement_b6e8cde3": {
        "rtl_code": "module complement(\n    input [3:0] A,\n    output reg [3:0] C\n);\n\n    always @(*) begin\n        C = ~A + 4'b1;\n    end\n\nendmodule",
        "module_name": "complement",
        "module_hash": "b6e8cde3aa16476b8af32cc91ec61072",
        "dataset_index": 5254
      },
      "srl8_to_64_3ff0998d": {
        "rtl_code": "module srl8_to_64(clk, enable, reset, dataIn, ready, result); \n    input clk, enable, reset; \n    input [7:0] dataIn; \n    output ready; \n    output [63:0] result; \n\n    reg [7:0] regBank[7:0]; \n    reg [3:0] status_int;\n    integer i; \n\n    parameter s1=0, s2=1, s3=2, s4=3, s5=4, s6=5, s7=6, s8=7, s9=8; \n\n    always @(posedge clk)\n    begin\n        if (reset == 1)\n        begin\n            status_int <= s1;\n            for (i=0; i<8; i=i+1) begin \n                regBank[i] <= 8'h0; \n            end \n        end else \n        if (enable == 0)\n        begin\n            regBank[0] <= dataIn; \n            for (i=7; i>0; i=i-1) begin \n                regBank[i] <= regBank[i-1]; \n            end \n            if (status_int == s9) begin\n                status_int <= s1;\n            end else begin\n                status_int <= status_int + 1;\n            end\n        end else begin\n            status_int <= s1;\n        end\n    end\n\n    assign result = (status_int == s9) ? {regBank[7], regBank[6], regBank[5], regBank[4], regBank[3], regBank[2], regBank[1], regBank[0]} : 64'h0; \n    assign ready = (status_int == s9) ? 1'b1 : 1'b0;\nendmodule",
        "module_name": "srl8_to_64",
        "module_hash": "3ff0998d53872aab5bcce0f6f915973e",
        "dataset_index": 21113
      },
      "bcd_converter_03979e56": {
        "rtl_code": "module bcd_converter (\n    input [3:0] binary,\n    output reg [3:0] bcd_high,\n    output reg [3:0] bcd_low\n);\n\nalways @* begin\n    case (binary)\n        4'b0000: begin bcd_high = 4'b0000; bcd_low = 4'b0000; end\n        4'b0001: begin bcd_high = 4'b0000; bcd_low = 4'b0001; end\n        4'b0010: begin bcd_high = 4'b0000; bcd_low = 4'b0010; end\n        4'b0011: begin bcd_high = 4'b0000; bcd_low = 4'b0011; end\n        4'b0100: begin bcd_high = 4'b0000; bcd_low = 4'b0100; end\n        4'b0101: begin bcd_high = 4'b0000; bcd_low = 4'b0101; end\n        4'b0110: begin bcd_high = 4'b0000; bcd_low = 4'b0110; end\n        4'b0111: begin bcd_high = 4'b0000; bcd_low = 4'b0111; end\n        4'b1000: begin bcd_high = 4'b0001; bcd_low = 4'b0000; end\n        4'b1001: begin bcd_high = 4'b0001; bcd_low = 4'b0001; end\n        4'b1010: begin bcd_high = 4'b0001; bcd_low = 4'b0010; end\n        4'b1011: begin bcd_high = 4'b0001; bcd_low = 4'b0011; end\n        4'b1100: begin bcd_high = 4'b0001; bcd_low = 4'b0100; end\n        4'b1101: begin bcd_high = 4'b0001; bcd_low = 4'b0101; end\n        4'b1110: begin bcd_high = 4'b0001; bcd_low = 4'b0110; end\n        4'b1111: begin bcd_high = 4'b0001; bcd_low = 4'b0111; end\n        default: begin bcd_high = 4'b0000; bcd_low = 4'b0000; end\n    endcase\nend\n\nendmodule\n\nmodule absolute_value (\n    input [3:0] binary,\n    output reg [3:0] abs_val\n);\n\nalways @* begin\n    if (binary[3] == 1) begin\n        abs_val = ~binary + 1;\n    end else begin\n        abs_val = binary;\n    end\nend\n\nendmodule\n\nmodule abs_bcd_converter (\n    input [3:0] binary,\n    output reg [3:0] bcd_high,\n    output reg [3:0] bcd_low,\n    output reg [3:0] abs_val,\n    output reg [11:0] abs_bcd_val\n);\n\nbcd_converter bcd_converter_inst (\n    .binary(binary),\n    .bcd_high(bcd_high),\n    .bcd_low(bcd_low)\n);\n\nabsolute_value absolute_value_inst (\n    .binary(binary),\n    .abs_val(abs_val)\n);\n\nalways @* begin\n    if (abs_val[3] == 1) begin\n        abs_bcd_val = {4'b0001, ~bcd_high + 1, ~bcd_low + 1};\n    end else begin\n        abs_bcd_val = {4'b0000, bcd_high, bcd_low};\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] binary,\n    output [3:0] bcd_high,\n    output [3:0] bcd_low,\n    output reg [3:0] abs_val,\n    output reg [11:0] abs_bcd_val\n);\n\nabs_bcd_converter abs_bcd_converter_inst (\n    .binary(binary),\n    .bcd_high(bcd_high),\n    .bcd_low(bcd_low),\n    .abs_val(abs_val),\n    .abs_bcd_val(abs_bcd_val)\n);\n\nendmodule",
        "module_name": "bcd_converter",
        "module_hash": "03979e5604e368ea75bb9af23efab56a",
        "dataset_index": 10594
      },
      "sequential_circuit_d7878243": {
        "rtl_code": "module sequential_circuit (\n  input clk,\n  input a,\n  output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n  q1 <= a;\n  q2 <= q1;\n  q <= q2;\nend\n\nendmodule\n",
        "module_name": "sequential_circuit",
        "module_hash": "d7878243fd8d4b9501e46e94c07b3d4e",
        "dataset_index": 10729
      },
      "binary_counter_3b7b07bd": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0;\n    end else if (enable) begin\n        if (count == 4'b1111) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "3b7b07bd7af30ca76ce750df39e30adf",
        "dataset_index": 488
      },
      "traffic_light_controller_17a881ef": {
        "rtl_code": "\nmodule traffic_light_controller (\n  input clk,\n  input areset,\n  input pedestrian_button,\n  output reg red_light,\n  output reg yellow_light,\n  output reg green_light,\n  output reg walk_signal\n);\n\n  // Define the states\n  parameter STATE_0 = 3'b000;\n  parameter STATE_1 = 3'b001;\n  parameter STATE_2 = 3'b010;\n  parameter STATE_3 = 3'b011;\n  parameter STATE_4 = 3'b100;\n\n  // Define the current state\n  reg [2:0] current_state, next_state;\n\n  // State machine logic\n  always @(posedge clk) begin\n    if (areset == 1'b1) begin\n      current_state <= STATE_0;\n    end else begin\n      current_state <= next_state;\n    end\n  end\n\n  always @* begin\n    case (current_state)\n      STATE_0: begin\n        if (pedestrian_button == 1'b1) begin\n          next_state <= STATE_4;\n        end else begin\n          next_state <= STATE_1;\n        end\n      end\n      STATE_1: begin\n        next_state <= STATE_2;\n      end\n      STATE_2: begin\n        next_state <= STATE_3;\n      end\n      STATE_3: begin\n        next_state <= STATE_0;\n      end\n      STATE_4: begin\n        next_state <= STATE_0;\n      end\n    endcase\n  end\n\n  // Output logic\n  always @* begin\n    case (current_state)\n      STATE_0: begin\n        red_light <= 1'b1;\n        yellow_light <= 1'b0;\n        green_light <= 1'b0;\n        walk_signal <= 1'b0;\n      end\n      STATE_1: begin\n        red_light <= 1'b1;\n        yellow_light <= 1'b0;\n        green_light <= 1'b0;\n        walk_signal <= 1'b1;\n      end\n      STATE_2: begin\n        red_light <= 1'b0;\n        yellow_light <= 1'b1;\n        green_light <= 1'b0;\n        walk_signal <= 1'b0;\n      end\n      STATE_3: begin\n        red_light <= 1'b0;\n        yellow_light <= 1'b0;\n        green_light <= 1'b1;\n        walk_signal <= 1'b1;\n      end\n      STATE_4: begin\n        red_light <= 1'b0;\n        yellow_light <= 1'b1;\n        green_light <= 1'b0;\n        walk_signal <= 1'b1;\n      end\n    endcase\n  end\nendmodule",
        "module_name": "traffic_light_controller",
        "module_hash": "17a881efe52b6d8df53d24710ee140b5",
        "dataset_index": 6764
      },
      "memory_controller #_bf671a48": {
        "rtl_code": "module memory_controller #(\n  parameter n = 8, // number of address signals\n  parameter m = 32 // number of data signals\n) (\n  input [n-1:0] addr,\n  input we,\n  input [m-1:0] data,\n  output mem_we,\n  output mem_re,\n  output [m-1:0] mem_data\n);\n\nreg [n-1:0] state;\nreg [m-1:0] mem_data_reg;\nreg mem_we_reg;\nreg mem_re_reg;\n\nalways @(*) begin\n  case(state)\n    0: begin // idle state\n      mem_we_reg = 0;\n      mem_re_reg = 0;\n      if (we) begin\n        state = 1; // write state\n      end else begin\n        state = 2; // read state\n      end\n    end\n    1: begin // write state\n      mem_we_reg = 1;\n      mem_re_reg = 0;\n      mem_data_reg = data;\n      state = 0; // return to idle state\n    end\n    2: begin // read state\n      mem_we_reg = 0;\n      mem_re_reg = 1;\n      state = 3; // wait for memory read\n    end\n    3: begin // wait for memory read\n      mem_we_reg = 0;\n      mem_re_reg = 0;\n      mem_data_reg = mem_data;\n      state = 0; // return to idle state\n    end\n  endcase\nend\n\nassign mem_we = mem_we_reg;\nassign mem_re = mem_re_reg;\nassign mem_data = mem_data_reg;\n\nendmodule",
        "module_name": "memory_controller #",
        "module_hash": "bf671a481091473f2445aa3328ddce33",
        "dataset_index": 10731
      },
      "shift_register_6fdc2c07": {
        "rtl_code": "\nmodule shift_register (\n    input CLK,\n    input RESET_N,\n    input LOAD,\n    input [7:0] DATA_IN,\n    output Q\n);\n\nreg [7:0] shift_reg;\n\nalways @ (posedge CLK, negedge RESET_N) begin\n    if (~RESET_N) begin\n        shift_reg <= 8'b0;\n    end else if (LOAD) begin\n        shift_reg <= DATA_IN;\n    end else begin\n        shift_reg <= {shift_reg[6:0], shift_reg[7]};\n    end\nend\n\nassign Q = shift_reg[0];\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "6fdc2c0769a5f3b374efec1ea4ac3981",
        "dataset_index": 7977
      },
      "up_xfer_status_fc7c3287": {
        "rtl_code": "\n\nmodule up_xfer_status (\n\n  up_rstn,\n  up_clk,\n  up_data_status,\n\n  d_rst,\n  d_clk,\n  d_data_status);\n\n  parameter     DATA_WIDTH = 8;\n  localparam    DW = DATA_WIDTH - 1;\n\n  input           up_rstn;\n  input           up_clk;\n  output  [DW:0]  up_data_status;\n\n  input           d_rst;\n  input           d_clk;\n  input   [DW:0]  d_data_status;\n\n  reg             d_xfer_state_m1 = 'd0;\n  reg             d_xfer_state_m2 = 'd0;\n  reg             d_xfer_state = 'd0;\n  reg     [ 5:0]  d_xfer_count = 'd0;\n  reg             d_xfer_toggle = 'd0;\n  reg     [DW:0]  d_xfer_data = 'd0;\n  reg     [DW:0]  d_acc_data = 'd0;\n  reg             up_xfer_toggle_m1 = 'd0;\n  reg             up_xfer_toggle_m2 = 'd0;\n  reg             up_xfer_toggle_m3 = 'd0;\n  reg             up_xfer_toggle = 'd0;\n  reg     [DW:0]  up_data_status = 'd0;\n\n  wire            d_xfer_enable_s;\n  wire            up_xfer_toggle_s;\n\n  assign d_xfer_enable_s = d_xfer_state ^ d_xfer_toggle;\n\n  always @(posedge d_clk or posedge d_rst) begin\n    if (d_rst == 1'b1) begin\n      d_xfer_state_m1 <= 'd0;\n      d_xfer_state_m2 <= 'd0;\n      d_xfer_state <= 'd0;\n      d_xfer_count <= 'd0;\n      d_xfer_toggle <= 'd0;\n      d_xfer_data <= 'd0;\n      d_acc_data <= 'd0;\n    end else begin\n      d_xfer_state_m1 <= up_xfer_toggle;\n      d_xfer_state_m2 <= d_xfer_state_m1;\n      d_xfer_state <= d_xfer_state_m2;\n      d_xfer_count <= d_xfer_count + 1'd1;\n      if ((d_xfer_count == 6'd1) && (d_xfer_enable_s == 1'b0)) begin\n        d_xfer_toggle <= ~d_xfer_toggle;\n        d_xfer_data <= d_acc_data;\n      end\n      if ((d_xfer_count == 6'd1) && (d_xfer_enable_s == 1'b0)) begin\n        d_acc_data <= d_data_status;\n      end else begin\n        d_acc_data <= d_acc_data | d_data_status;\n      end\n    end\n  end\n\n  assign up_xfer_toggle_s = up_xfer_toggle_m3 ^ up_xfer_toggle_m2;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_xfer_toggle_m1 <= 'd0;\n      up_xfer_toggle_m2 <= 'd0;\n      up_xfer_toggle_m3 <= 'd0;\n      up_xfer_toggle <= 'd0;\n      up_data_status <= 'd0;\n    end else begin\n      up_xfer_toggle_m1 <= d_xfer_toggle;\n      up_xfer_toggle_m2 <= up_xfer_toggle_m1;\n      up_xfer_toggle_m3 <= up_xfer_toggle_m2;\n      up_xfer_toggle <= up_xfer_toggle_m3;\n      if (up_xfer_toggle_s == 1'b1) begin\n        up_data_status <= d_xfer_data;\n      end\n    end\n  end\n\nendmodule\n\n",
        "module_name": "up_xfer_status",
        "module_hash": "fc7c32875694cf693ca1bc5780c79b85",
        "dataset_index": 22617
      },
      "ripple_carry_adder_3dc2a3f4": {
        "rtl_code": "\nmodule ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] sum;\nwire [3:0] carry;\n\nassign sum = A ^ B ^ Cin;\nassign carry[0] = (A & B) | (Cin & (A ^ B));\n\nassign S = sum;\nassign Cout = carry[3];\n\ngenvar i;\ngenerate\n    for(i=1; i<4; i=i+1) begin : carry_propagation\n        assign carry[i] = carry[i-1] & sum[i-1];\n    end\nendgenerate\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "3dc2a3f4e8f07988c15248ecea4f9a0a",
        "dataset_index": 11787
      },
      "KeyScanController_719c52bb": {
        "rtl_code": "module KeyScanController(\n  input clk, rst, start, load, shift,\n  output reg [2:0] currentState,\n  output reg startTimer\n);\n\n  parameter DIVIDER = 3;\n  reg [DIVIDER-1:0] timer;\n  \n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      currentState <= 3'b000;\n      startTimer <= 0;\n      timer <= 0;\n    end else begin\n      case (currentState)\n        3'b000: begin\n          if (start) begin\n            currentState <= 3'b001;\n            startTimer <= 1;\n            timer <= 0;\n          end\n        end\n        3'b001: begin\n          startTimer <= 0;\n          if (timer == DIVIDER-1) begin\n            if (load) begin\n              currentState <= 3'b010;\n              timer <= 0;\n            end else if (shift) begin\n              currentState <= 3'b100;\n              timer <= 0;\n            end else begin\n              currentState <= 3'b000;\n              timer <= 0;\n            end\n          end else begin\n            timer <= timer + 1;\n          end\n        end\n        3'b010: begin\n          if (timer == DIVIDER-1) begin\n            currentState <= 3'b001;\n            timer <= 0;\n          end else begin\n            timer <= timer + 1;\n          end\n        end\n        3'b100: begin\n          if (timer == DIVIDER-1) begin\n            currentState <= 3'b001;\n            timer <= 0;\n          end else begin\n            timer <= timer + 1;\n          end\n        end\n      endcase\n    end\n  end\nendmodule",
        "module_name": "KeyScanController",
        "module_hash": "719c52bbf55046f59c33deeda78c6e66",
        "dataset_index": 2619
      },
      "bitwise_and_42252938": {
        "rtl_code": "module bitwise_and (\n    clk,\n    input_a,\n    input_b,\n    output_result\n);\n\ninput clk;\ninput [7:0] input_a;\ninput [7:0] input_b;\noutput [7:0] output_result;\n\nwire [7:0] wire_and0;\nwire [7:0] wire_and1;\nwire [7:0] wire_and2;\nwire [7:0] wire_and3;\nwire [7:0] wire_and4;\nwire [7:0] wire_and5;\nwire [7:0] wire_and6;\nwire [7:0] wire_and7;\n\nassign wire_and0 = input_a[0] & input_b[0];\nassign wire_and1 = input_a[1] & input_b[1];\nassign wire_and2 = input_a[2] & input_b[2];\nassign wire_and3 = input_a[3] & input_b[3];\nassign wire_and4 = input_a[4] & input_b[4];\nassign wire_and5 = input_a[5] & input_b[5];\nassign wire_and6 = input_a[6] & input_b[6];\nassign wire_and7 = input_a[7] & input_b[7];\n\nassign output_result[0] = wire_and0;\nassign output_result[1] = wire_and1;\nassign output_result[2] = wire_and2;\nassign output_result[3] = wire_and3;\nassign output_result[4] = wire_and4;\nassign output_result[5] = wire_and5;\nassign output_result[6] = wire_and6;\nassign output_result[7] = wire_and7;\n\nendmodule",
        "module_name": "bitwise_and",
        "module_hash": "42252938a3028cba712c488083825e41",
        "dataset_index": 1039
      },
      "bcd_to_7seg_ef461ceb": {
        "rtl_code": "\nmodule bcd_to_7seg (\n    input [3:0] BCD,\n    output reg [6:0] SEG,\n    input clk, // Added clock input\n    input reset // Added reset as an input\n);\n\nreg [3:0] bcd_reg;\nreg [2:0] stage;\n\nalways @(posedge clk) begin\n    if (reset) begin // Reset logic\n        SEG <= 7'b0000000;\n        stage <= 0;\n    end else begin\n        case (stage)\n            0: SEG <= 7'b0111111; // 0\n            1: SEG <= 7'b0000110; // 1\n            2: SEG <= 7'b1011011; // 2\n            3: SEG <= 7'b1001111; // 3\n            4: SEG <= 7'b1100110; // 4\n            5: SEG <= 7'b1101101; // 5\n            6: SEG <= 7'b1111101; // 6\n            7: SEG <= 7'b0000111; // 7\n        endcase\n        stage <= stage + 1;\n        if (stage == 7) begin\n            stage <= 0;\n        end\n    end\nend\n\nalways @(*) begin\n    case (stage)\n        0: bcd_reg <= BCD;\n        1: bcd_reg <= bcd_reg << 1;\n        2: bcd_reg <= bcd_reg << 1;\n        3: bcd_reg <= bcd_reg << 1;\n        4: bcd_reg <= bcd_reg << 1;\n        5: bcd_reg <= bcd_reg << 1;\n        6: bcd_reg <= bcd_reg << 1;\n        7: bcd_reg <= bcd_reg << 1;\n    endcase\nend\n\nendmodule\n",
        "module_name": "bcd_to_7seg",
        "module_hash": "ef461ceb7adae66d64462cee7bb3eca7",
        "dataset_index": 14728
      },
      "reset_module_8a86ed87": {
        "rtl_code": "module reset_module(\n    input   rst,\n    input   clk,\n    output  reg rst_n\n);\n\nreg r;\n\nalways @(negedge clk)\n    if( rst ) begin\n        r     <= 1'b0;\n        rst_n <= 1'b0;\n    end else begin\n        { rst_n, r } <= { r, 1'b1 };\n    end\n\nendmodule",
        "module_name": "reset_module",
        "module_hash": "8a86ed8751f12cd517f75930acc5a497",
        "dataset_index": 12249
      },
      "priority_encoder_321e5817": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] a, b, c, d,\n    output reg [1:0] index\n);\n\n    always @* begin\n        if ({a,b,c,d} != 8'b00000000)\n            index = a ? 2'b00 : (b ? 2'b01 : (c ? 2'b10 : 2'b11));\n        else\n            index = 2'b11;\n    end\n\nendmodule\nmodule mux_4to1_priority_encoder (\n    input [7:0] a, b, c, d,\n    input [1:0] select,\n    output reg [7:0] out\n);\n\n    wire [1:0] index;\n    priority_encoder pe(a, b, c, d, index);\n\n    always @* begin\n        case (select)\n            2'b00: out = a;\n            2'b01: out = b;\n            2'b10: out = c;\n            2'b11: out = d;\n        endcase\n    end\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "321e5817fbf0517a6b20ac418ed956c4",
        "dataset_index": 5371
      },
      "vending_machine_9e3aa935": {
        "rtl_code": "module vending_machine (\n  input clk,\n  input reset,\n  input [3:0] data,\n  input purchase,\n  output reg [3:0] display,\n  output reg item_dispensed\n);\n\n  // Define state machine states\n  parameter IDLE = 2'b00;\n  parameter SELECTING = 2'b01;\n  parameter DISPENSING = 2'b10;\n  \n  // Define item prices\n  parameter ITEM_1_PRICE = 2;\n  parameter ITEM_2_PRICE = 3;\n  parameter ITEM_3_PRICE = 4;\n  \n  // Define state machine registers\n  reg [1:0] state;\n  reg [3:0] item_selected;\n  reg [3:0] item_price;\n  reg [3:0] item_dispensed_temp;\n  \n  // Define state machine outputs\n  always @* begin\n    display = (state == IDLE) ? 4'b0001 : (state == SELECTING) ? {4'b0010, item_price} : (state == DISPENSING) ? 4'b0100 : 4'b1111;\n  end\n  \n  // Define state machine logic\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      item_selected <= 4'b0000;\n      item_price <= 4'b0000;\n      item_dispensed_temp <= 4'b0000;\n      item_dispensed <= 1'b0;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (purchase) begin\n            state <= SELECTING;\n          end\n        end\n        SELECTING: begin\n          item_price <= (data == 4'b0001) ? ITEM_1_PRICE : (data == 4'b0010) ? ITEM_2_PRICE : (data == 4'b0100) ? ITEM_3_PRICE : 4'b0000;\n          if (purchase && item_price > 0) begin\n            item_selected <= data;\n            item_dispensed_temp <= item_selected;\n            state <= DISPENSING;\n          end\n        end\n        DISPENSING: begin\n          item_dispensed <= 1'b1;\n          item_dispensed_temp <= 4'b0000;\n          state <= IDLE;\n        end\n      endcase\n    end\n  end\n  \nendmodule",
        "module_name": "vending_machine",
        "module_hash": "9e3aa93583038ba128d4b634ddd1a692",
        "dataset_index": 7900
      },
      "sky130_fd_sc_hs__a31o_a53e0ca7": {
        "rtl_code": "\nmodule sky130_fd_sc_hs__a31o (\n    VPWR,\n    VGND,\n    X,\n    A1,\n    A2,\n    A3,\n    B1\n);\n    // Module ports\n    input  VPWR;\n    input  VGND;\n    output X;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    // Internal logic\n    wire n1, n2, n3;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__and2_1 and2_1 (\n        .A(A1),\n        .B(A2),\n        .X(n1)\n    );\n\n    sky130_fd_sc_hs__and2_1 and2_2 (\n        .A(n1),\n        .B(A3),\n        .X(n2)\n    );\n\n    sky130_fd_sc_hs__and2_1 and2_3 (\n        .A(B1),\n        .B(n2),\n        .X(n3)\n    );\n\n    // Output assignment\n    assign X = n3;\n\nendmodule\n\nmodule sky130_fd_sc_hs__a31o_wrapper (\n    VPWR,\n    VGND,\n    Y,\n    A1,\n    A2,\n    A3,\n    B1,\n    SEL\n);\n\n    // Module ports\n    input  VPWR;\n    input  VGND;\n    output Y;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  SEL;\n\n    // Local signals\n    wire X;\n    wire not_X;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__a31o a31o_inst (\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1)\n    );\n\n    // Output assignment\n    assign not_X = ~X;\n\n    assign Y = (SEL == 1'b0) ? X : not_X;\n\nendmodule\n\nmodule sky130_fd_sc_hs__and2_1 (\n    A,\n    B,\n    X\n);\n    // Module ports\n    input  A;\n    input  B;\n    output X;\n\n    // Internal logic\n    wire n1;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__nand2_1 nand2_1 (\n        .A(A),\n        .B(B),\n        .Y(n1)\n    );\n\n    // Output assignment\n    assign X = ~n1;\n\nendmodule\n\nmodule sky130_fd_sc_hs__nand2_1 (\n    A,\n    B,\n    Y\n);\n    // Module ports\n    input  A;\n    input  B;\n    output Y;\n\n    // Internal logic\n    wire n1;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__nor2_1 nor2_1 (\n        .A(A),\n        .B(B),\n        .Y(n1)\n    );\n\n    // Output assignment\n    assign Y = ~n1;\n\nendmodule\n\nmodule sky130_fd_sc_hs__nor2_1 (\n    A,\n    B,\n    Y\n);\n    // Module ports\n    input  A;\n    input  B;\n    output Y;\n\n    // Logic logic\n    assign Y = ~(A | B);\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hs__a31o",
        "module_hash": "a53e0ca756353c032d2640bf319fe114",
        "dataset_index": 14194
      },
      "signed_mag_multiplier_62683920": {
        "rtl_code": "module signed_mag_multiplier (\n    input signed [3:0] a,\n    input signed [3:0] b,\n    output signed [7:0] product,\n    output overflow\n);\n    \n    reg signed [7:0] temp_product;\n    reg signed [3:0] temp_a;\n    reg signed [3:0] temp_b;\n    reg overflow_flag;\n    \n    always @(*) begin\n        temp_a = (a < 0) ? (~a + 1) : a;\n        temp_b = (b < 0) ? (~b + 1) : b;\n        temp_product = temp_a * temp_b;\n        if (temp_product > 127 || temp_product < -128) begin\n            overflow_flag = 1;\n        end else begin\n            overflow_flag = 0;\n        end\n    end\n    \n    assign product = (a < 0) ^ (b < 0) ? (~temp_product + 1) : temp_product;\n    assign overflow = overflow_flag;\n    \nendmodule",
        "module_name": "signed_mag_multiplier",
        "module_hash": "62683920987e9c31b72ff75f062260a0",
        "dataset_index": 9762
      },
      "address_4b609e42": {
        "rtl_code": "\n`define SGB_HOOK\n\nmodule address(\n  input CLK,\n  input [15:0] featurebits, input [23:0] SNES_ADDR,   input [7:0] SNES_PA,      input SNES_ROMSEL,        output [23:0] ROM_ADDR,   output ROM_HIT,           output IS_SAVERAM,        output IS_ROM,            output IS_WRITABLE,       output msu_enable,\n  output sgb_enable,\n  output r213f_enable,\n  output r2100_hit,\n  output snescmd_enable,\n\n  output button_enable,\n  output button_addr\n);\n\n\nparameter [2:0]\n  FEAT_DSPX = 0,\n  FEAT_ST0010 = 1,\n  FEAT_SRTC = 2,\n  FEAT_MSU1 = 3,\n  FEAT_213F = 4,\n  FEAT_2100 = 6\n;\n\nwire [23:0] SRAM_SNES_ADDR;\n\n\n\nassign IS_ROM = ~SNES_ROMSEL;\n\nassign IS_SAVERAM = 0;\n\nassign IS_WRITABLE = IS_SAVERAM;\n\nassign SRAM_SNES_ADDR = {5'h00, SNES_ADDR[19:16], SNES_ADDR[14:0]};\n\nassign ROM_ADDR = SRAM_SNES_ADDR;\n\nassign ROM_HIT = IS_ROM | IS_WRITABLE;\n\nassign msu_enable = featurebits[FEAT_MSU1] & (!SNES_ADDR[22] && ((SNES_ADDR[15:0] & 16'hfff8) == 16'h2000));\nassign sgb_enable = !SNES_ADDR[22] && ((SNES_ADDR[15:0] & 16'hf808) == 16'h6000 || (SNES_ADDR[15:0] & 16'hf80F) == 16'h600F || (SNES_ADDR[15:0] & 16'hf000) == 16'h7000); assign r213f_enable = featurebits[FEAT_213F] & (SNES_PA == 8'h3f);\nassign r2100_hit = (SNES_PA == 8'h00);\n\nassign snescmd_enable = ({SNES_ADDR[22], SNES_ADDR[15:9]} == 8'b0_0010101);\n\nassign button_enable = {SNES_ADDR[23:2],2'b00} == {24'h010F10} && SNES_ADDR[1] != SNES_ADDR[0];\nassign button_addr   = ~SNES_ADDR[0];\n\nendmodule\n",
        "module_name": "address",
        "module_hash": "4b609e42ca5a0ed802a52842754e6b14",
        "dataset_index": 23359
      },
      "TOP_e1371f79": {
        "rtl_code": "module TOP(\n    input wire in0,\n    input wire in1,\n    output reg out\n);\n\nalways @(in0, in1) begin\n    out = in0 & in1;\nend\n\nendmodule",
        "module_name": "TOP",
        "module_hash": "e1371f79acb8c49f6dde1e3078561a25",
        "dataset_index": 2848
      },
      "square_bc693e03": {
        "rtl_code": "module square(input clksamp, \n            input[31:0] freq, \n            input signed[16:0] amp, \n            input signed[16:0] offset, \n            input[9:0] duty,\n            output[11:0] sq);\nparameter SAMP_FREQ = 100_000_000;\n\nreg state = 1'b0;\nreg[15:0] period_counter = 16'b0;\nreg[15:0] duty_counter = 16'b0;\n\nwire[15:0] period_load = (SAMP_FREQ/freq);\nwire[15:0] duty_load = (period_load * duty) / 1000;\n\nreg[15:0] period_load_reg = 32'b0;\nreg[15:0] duty_load_reg = 32'b0;\n\nalways @(posedge clksamp) begin\n    period_load_reg <= period_load;\n    duty_load_reg <= duty_load;\n    period_counter <= (period_load_reg != period_load) ? period_load_reg - 1 : (period_counter > 0) ? period_counter - 1 : period_load_reg - 1;\n    duty_counter <= (duty_load_reg != duty_load) ? duty_load_reg - 1 : (duty_counter > 0) ? duty_counter - 1 : (period_counter > 0) ? 0 : duty_load_reg - 1;\n    state <= (duty_counter == 0 && period_counter > 0) ? 0 : 1;\nend\n\nwire signed[16:0] preclip = state ? offset + amp : offset - amp;\n\nassign sq = (freq == 0 || amp == 0) ? offset > 4095 ? 4095 : offset : duty == 0 ? 0 : preclip > 4095 ? 4095 : preclip < 0 ? 0 : preclip;\n\nendmodule",
        "module_name": "square",
        "module_hash": "bc693e03bb71d43f9e8c8f17520f5667",
        "dataset_index": 18423
      },
      "sm_timer_64_340ae035": {
        "rtl_code": "\n\nmodule sm_timer_64\n(\n  output wire             sCMD_tready   ,\n  input  wire             sCMD_tvalid   ,\n  input  wire  [31 : 0]   sCMD_tdata    ,\n\n  input  wire             mRet_tready   ,\n  output wire             mRet_tvalid   ,\n  output wire  [31 : 0]   mRet_tdata    ,\n\n  input  wire             ACLK          ,\n  input  wire             ARESETN\n);\n\nlocalparam Fetch           = 8'b00000001; localparam Decode          = 8'b00000010; localparam SMSTART         = 8'b00000100; localparam SMRESET         = 8'b00001000; localparam SMSTOP          = 8'b00010000; localparam SMLAP           = 8'b00100000; localparam SMSEND_Lo       = 8'b01000000; localparam SMSEND_Hi       = 8'b10000000; localparam OPSTART         = 16'h1;\nlocalparam OPSTOP          = 16'h2;\nlocalparam OPRESET         = 16'h3;\nlocalparam OPREAD          = 16'h4;\nlocalparam OPLAP           = 16'h5;\n\nreg [ 7:0] state       ;\nreg [31:0] instruction ;\nreg [31:0] rVal        ;\n\nassign mRet_tdata  = rVal;\nassign sCMD_tready = (state == Fetch);\nassign mRet_tvalid = (state == SMSEND_Lo || state == SMSEND_Hi);\nreg  [63 : 0]  counterR;\n\nreg            rRESET;\nreg            rEN;\n\nalways @(posedge ACLK) begin\n  if (rRESET) begin\n    counterR <= 64'd0;\n  end\n  else begin\n    if (rEN) begin\n      counterR <= counterR + 1;\n    end\n  end\nend\n\n\nalways @(posedge ACLK)\nbegin\n  if(!ARESETN) begin\n    state <= Fetch;\n    instruction <= 32'd0;\n    rVal  <= 32'd0;\n    rEN   <= 1'b0;\n    rRESET<= 1'b1;\n  end\n  else begin\n    case (state)\n\n      Fetch: begin\n        rRESET <= 1'b0;\n        if (sCMD_tvalid == 1) begin\n          instruction  <= sCMD_tdata;\n          state        <= Decode;\n        end\n        else begin\n          state        <= Fetch;\n        end\n      end\n\n      Decode: begin\n        case (instruction[31:16])\n          OPSTART: begin\n            rEN <= 1'b1;\n            state        <= Fetch;\n          end\n\n          OPSTOP: begin\n            rEN <= 1'b0;\n            state        <= Fetch;\n          end\n\n          OPRESET: begin\n            rRESET <= 1'b1;\n            state        <= Fetch;\n          end\n\n          OPREAD: begin\n            rVal         <= counterR[31:0];\n            state        <= SMSEND_Lo;\n          end\n\n          default: begin\n            state        <= Fetch;\n          end\n        endcase\n      end\n\n      SMSEND_Lo: begin\n        if (mRet_tready == 1) begin\n          rVal  <= counterR[63:32];\n          state <= SMSEND_Hi;\n        end\n        else begin\n          state <= SMSEND_Lo;\n        end\n      end\n\n      SMSEND_Hi: begin\n        if (mRet_tready == 1) begin\n          state <= Fetch;\n        end\n        else begin\n          state <= SMSEND_Hi;\n        end\n      end\n\n    endcase\n  end\nend\n\nendmodule\n\n\n",
        "module_name": "sm_timer_64",
        "module_hash": "340ae0351b503be61143717c94960ad4",
        "dataset_index": 24409
      },
      "mult_gate_6c66ae82": {
        "rtl_code": "\nmodule mult_gate (\n    output Y,\n    input J,\n    input I,\n    input H,\n    input G,\n    input F,\n    input E,\n    input D,\n    input C,\n    input B,\n    input A\n);\n\n    wire w3;\n    wire w2;\n    wire w1;\n\n    and gate3(w3, I, H, G);\n    and gate2(w2, F, E, D);\n    and gate1(w1, C, B, A);\n    or gate4(Y, w3, w2, w1, J);\n\nendmodule",
        "module_name": "mult_gate",
        "module_hash": "6c66ae82a67bf479884bdfdeb5034652",
        "dataset_index": 19289
      },
      "adder_subtractor_4bit_40dc9543": {
        "rtl_code": "module adder_subtractor_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] SUM\n);\n\nwire [3:0] CIN;\nwire [3:0] COUT;\n\nassign CIN[0] = SUB;\nassign CIN[1] = COUT[0];\nassign CIN[2] = COUT[1];\nassign CIN[3] = COUT[2];\n\nfa fa0 (\n    .A(A[0]),\n    .B(B[0]),\n    .CIN(CIN[0]),\n    .SUM(SUM[0]),\n    .COUT(COUT[0])\n);\nfa fa1 (\n    .A(A[1]),\n    .B(B[1]),\n    .CIN(CIN[1]),\n    .SUM(SUM[1]),\n    .COUT(COUT[1])\n);\nfa fa2 (\n    .A(A[2]),\n    .B(B[2]),\n    .CIN(CIN[2]),\n    .SUM(SUM[2]),\n    .COUT(COUT[2])\n);\nfa fa3 (\n    .A(A[3]),\n    .B(B[3]),\n    .CIN(CIN[3]),\n    .SUM(SUM[3]),\n    .COUT(COUT[3])\n);\n\nendmodule\n\nmodule fa (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\nassign {COUT, SUM} = A + B + CIN;\n\nendmodule",
        "module_name": "adder_subtractor_4bit",
        "module_hash": "40dc95431fa66441714cbdde87b8358a",
        "dataset_index": 7261
      },
      "adder_e60d231c": {
        "rtl_code": "module adder (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = cin + A + B;\n\nendmodule\n\nmodule ripple_addsub (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    input select,\n    output [3:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = select ? (cin + A - B) : (cin + A + B);\n\nendmodule\n\nmodule top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    input select,\n    output reg [3:0] sum,\n    output reg cout\n);\n\n    wire [3:0] adder_out;\n    wire adder_cout;\n    wire [3:0] ripple_addsub_out;\n    wire ripple_addsub_cout;\n\n    adder adder_inst (\n        .A(A),\n        .B(B),\n        .cin(cin),\n        .sum(adder_out),\n        .cout(adder_cout)\n    );\n\n    ripple_addsub ripple_addsub_inst (\n        .A(A),\n        .B(B),\n        .cin(cin),\n        .select(select),\n        .sum(ripple_addsub_out),\n        .cout(ripple_addsub_cout)\n    );\n\n    always @(*) begin\n        if (select) begin\n            if (adder_cout) begin\n                sum <= ripple_addsub_out + 4'b0001;\n            end else begin\n                sum <= ripple_addsub_out;\n            end\n        end else begin\n            sum <= adder_out;\n        end\n    end\n\n    always @(*) begin\n        if (select) begin\n            cout <= ripple_addsub_cout;\n        end else begin\n            cout <= adder_cout;\n        end\n    end\n\nendmodule",
        "module_name": "adder",
        "module_hash": "e60d231cd82562528dcfc30cb8d58867",
        "dataset_index": 9297
      },
      "selector_mode_3472fbd8": {
        "rtl_code": "\n\nmodule selector_mode\n#(parameter LO = 2, HI = 5, CLK_CH = 25)\n(\n    input [31:0]clk,\n    input switch_power,\n    input switch_en,\n    input sig_change,\n    input [1:0]washing_machine_running,\n    output reg push,\n    output reg [2:0] sel_value\n);\n\n    reg init_flag;\n    wire real_clk;\n\n    initial begin\n        init_flag <= 1;\n        sel_value <= LO;\n        push <= 1'b0;\n    end\n\n    always @(posedge clk[CLK_CH]) begin\n        if (switch_power) begin\n            if (!switch_en) begin   \n                if(washing_machine_running[1]) begin\n                    push = 1'b1;\n                    sel_value = LO;\n                end else begin\n                    if(init_flag) begin\n                        sel_value = LO;\n                        init_flag = 0;\n                        push = 1'b0;\n                    end\n                    if (sig_change) begin\n                        sel_value = (sel_value + 1) % (HI+1) ? (sel_value + 1) % (HI+1) : LO;\n                        push = 1'b1;\n                    end else begin\n                        sel_value = sel_value;\n                        push = push;\n                    end\n                end\n            end else begin\n                push = 1'b0;\n                sel_value = sel_value;\n            end\n        end else begin\n            init_flag = 1;\n            sel_value = LO;\n            push = 1'b0;\n        end\n    end\n    \nendmodule",
        "module_name": "selector_mode",
        "module_hash": "3472fbd814cffeb96919b7674c8d8847",
        "dataset_index": 8747
      },
      "KeyEncoder_f5d2fec6": {
        "rtl_code": "\nmodule KeyEncoder(Columns, Rows, Clock, Reset, OnesDigit, TensDigit, Found);\n\tinput [3:0] Columns;\n\tinput [3:0] Rows;\n\tinput Clock, Reset;\n\toutput reg [3:0] OnesDigit;\n\toutput reg [3:0] TensDigit;\n\toutput reg Found;\n\tparameter NoKey = 9'd0;\n\tparameter key1 = 9'b100000001;\n\tparameter key2 = 9'b100000010;\n\tparameter key3 = 9'b100000011;\n\tparameter key4 = 9'b100000100;\n\tparameter key5 = 9'b100000101;\n\tparameter key6 = 9'b100000110;\n\tparameter key7 = 9'b100000111;\n\tparameter key8 = 9'b100001000;\n\tparameter key9 = 9'b100001001;\n\tparameter keyA = 9'b100010000;\n\tparameter keyB = 9'b100010001;\n\tparameter keyC = 9'b100010010;\n\tparameter keyD = 9'b100010011;\n\tparameter keyStar = 9'b100010100;\n\tparameter key0 = 9'b100010101;\n\tparameter keyPound = 9'b100010110;\n\talways@(posedge Clock or posedge Reset)\n\tif (Reset == 1) {Found, TensDigit, OnesDigit} <= NoKey;\n\telse case ({ Columns, Rows })\n\t\t8'b01110111: {Found, TensDigit, OnesDigit} <= key1;\n\t\t8'b10110111: {Found, TensDigit, OnesDigit} <= key2;\n\t\t8'b11010111: {Found, TensDigit, OnesDigit} <= key3;\n\t\t8'b01111011: {Found, TensDigit, OnesDigit} <= key4;\n\t\t8'b10111011: {Found, TensDigit, OnesDigit} <= key5;\n\t\t8'b11011011: {Found, TensDigit, OnesDigit} <= key6;\n\t\t8'b01111101: {Found, TensDigit, OnesDigit} <= key7;\n\t\t8'b10111101: {Found, TensDigit, OnesDigit} <= key8;\n\t\t8'b11011101: {Found, TensDigit, OnesDigit} <= key9;\n\t\t8'b11100111: {Found, TensDigit, OnesDigit} <= keyA;\n\t\t8'b11101011: {Found, TensDigit, OnesDigit} <= keyB;\n\t\t8'b11101101: {Found, TensDigit, OnesDigit} <= keyC;\n\t\t8'b11101110: {Found, TensDigit, OnesDigit} <= keyD;\n\t\t8'b01111110: {Found, TensDigit, OnesDigit} <= keyStar;\n\t\t8'b10111110: {Found, TensDigit, OnesDigit} <= key0;\n\t\t8'b11011110: {Found, TensDigit, OnesDigit} <= keyPound;\n\t\tdefault: {Found, TensDigit, OnesDigit} <= NoKey;\n\tendcase\nendmodule",
        "module_name": "KeyEncoder",
        "module_hash": "f5d2fec619455d1da57633a4779b8eb4",
        "dataset_index": 6252
      },
      "top__1809b38e": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input [7:0] d,  // 8-bit input for the register\n    input select,  // Select input to choose between register and counter\n    output [7:0] q  // 8-bit output from the addition operation\n);\n\n    // Declare internal wires\n    wire [7:0] reg_out;\n    wire [3:0] counter_out;\n\n    // Instantiate the register module\n    reg_module reg_inst (\n        .clk(clk),\n        .reset(reset),\n        .d(d),\n        .q(reg_out)\n    );\n\n    // Instantiate the counter module\n    counter_module counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .q(counter_out)\n    );\n\n    // Instantiate the adder module\n    adder_module adder_inst (\n        .a(select ? reg_out : counter_out),\n        .b(select ? counter_out : reg_out),\n        .sum(q)\n    );\n\nendmodule\n\n// 8-bit register with active high synchronous reset\nmodule reg_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input [7:0] d,  // 8-bit input\n    output reg [7:0] q  // 8-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'h34;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n\n// 4-bit binary counter that counts from 0 through 15, with synchronous reset to 0\nmodule counter_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    output reg [3:0] q  // 4-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\n\n// Functional module that adds two 8-bit inputs\nmodule adder_module (\n    input [7:0] a,  // 8-bit input a\n    input [7:0] b,  // 8-bit input b\n    output reg [7:0] sum  // 8-bit output sum\n);\n\n    always @(*) begin\n        sum = a + b;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "1809b38e460a1b13b5c3b96955d964cb",
        "dataset_index": 13363
      },
      "sd_clock_divider_07df698d": {
        "rtl_code": "module sd_clock_divider (\n           input CLK,\n           input [7:0] DIVIDER,\n           input RST,\n           output SD_CLK\n       );\n\nreg [7:0] ClockDiv;\nreg SD_CLK_O;\n\nassign SD_CLK = SD_CLK_O;\n\nalways @(posedge CLK or posedge RST)\nbegin\n    if (RST) begin\n        ClockDiv <= 8'b0000_0000;\n        SD_CLK_O <= 0;\n    end\n    else if (ClockDiv == DIVIDER) begin\n        ClockDiv <= 0;\n        SD_CLK_O <= ~SD_CLK_O;\n    end else begin\n        ClockDiv <= ClockDiv + 8'h1;\n        SD_CLK_O <= SD_CLK_O;\n    end\nend\n\nendmodule\n\n\n",
        "module_name": "sd_clock_divider",
        "module_hash": "07df698d456b7a240aa9cbacfcd9a106",
        "dataset_index": 24014
      },
      "counter_display_879b0d1d": {
        "rtl_code": "\nmodule counter_display(\n    input CLOCK_50, // 50 MHz FPGA Clock\n    input [1:0] KEY, // Pushbutton Keys\n    input [5:0] SW, // DIP Switches\n    output [6:0] HEX0, HEX1, HEX2, HEX3 // Seven-Segment Displays\n);\n\n    wire enable;\n    wire [15:0] hexDigits;\n    wire [3:0] countValue;\n\n    // Instantiate keyPressed module\n    keyPressed K1 ( // Module instantiation with correct module name.\n        .clock(CLOCK_50),\n        .reset(KEY[0]),\n        .enable_in(KEY[1]),\n        .enable_out(enable)\n    );\n\n    // Instantiate counter16bit module\n    counter16bit C1 ( // Module instantiation with correct module name.\n        .clock(CLOCK_50),\n        .enable(enable),\n        .clear(KEY[0]),\n        .disp(SW[5]),\n        .dir(SW[4]),\n        .countValue(countValue),\n        .outputValue(hexDigits)\n    );\n\n    // Instantiate seven-segment display drivers\n    sevenSegmentDecoder S0 (// Module instantiation with correct module name.\n        .digit(hexDigits[3:0]),\n        .drivers(HEX0)\n    );\n    sevenSegmentDecoder S1 ( // Module instantiation with correct module name.\n        .digit(hexDigits[7:4]),\n        .drivers(HEX1)\n    );\n    sevenSegmentDecoder S2 ( // Module instantiation with correct module name.\n        .digit(hexDigits[11:8]),\n        .drivers(HEX2)\n    );\n    sevenSegmentDecoder S3 ( // Module instantiation with correct module name.\n        .digit(hexDigits[15:12]),\n        .drivers(HEX3)\n    );\n\nendmodule\n\nmodule keyPressed(\n    input clock,\n    input reset,\n    input enable_in,\n    output reg enable_out\n);\n\n    always @ (posedge clock) begin\n        if (reset) begin\n            enable_out <= 0;\n        end else if (enable_in) begin\n            enable_out <= 1;\n        end else begin\n            enable_out <= 0;\n        end\n    end\n\nendmodule\n\nmodule counter16bit(\n    input clock,\n    input enable,\n    input clear,\n    input disp,\n    input dir, // Corrected typo\n    output reg [3:0] countValue,\n    output reg [15:0] outputValue\n);\n\n    always @ (posedge clock) begin\n        if (clear) begin\n            countValue <= 0;\n            outputValue <= 0;\n        end else if (enable) begin\n            if (dir) begin\n                countValue <= countValue - 1;\n            end else begin\n                countValue <= countValue + 1;\n            end\n            outputValue <= {disp, countValue};\n        end\n    end\n\nendmodule\n\nmodule sevenSegmentDecoder(\n    input [3:0] digit,\n    output reg [6:0] drivers\n);\n\n    always @ (digit) begin\n        case (digit)\n            4'b0000: drivers = 7'b1000000; // 0\n            4'b0001: drivers = 7'b1111001; // 1\n            4'b0010: drivers = 7'b0100100; // 2\n            4'b0011: drivers = 7'b0110000; // 3\n            4'b0100: drivers = 7'b0011001; // 4\n            4'b0101: drivers = 7'b0010010; // 5\n            4'b0110: drivers = 7'b0000010; // 6\n            4'b0111: drivers = 7'b1111000; // 7\n            4'b1000: drivers = 7'b0000000; // 8\n            4'b1001: drivers = 7'b0010000; // 9\n            default: drivers = 7'b1111111; // Error\n        endcase\n    end\n\nendmodule\n",
        "module_name": "counter_display",
        "module_hash": "879b0d1de71c78adeffe197f59736558",
        "dataset_index": 7552
      },
      "full_adder_c9759237": {
        "rtl_code": "module full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule ripple_carry_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire c0, c1, c2, c3;\n\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n\n    assign cout = c3;\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "c97592379a6d18d9c209163dc336f787",
        "dataset_index": 5361
      },
      "byte_reversal_03dca645": {
        "rtl_code": "module byte_reversal (\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nalways @(*) begin\n    out[7:0] = in[31:24];\n    out[15:8] = in[23:16];\n    out[23:16] = in[15:8];\n    out[31:24] = in[7:0];\nend\n\nendmodule\n\nmodule priority_encoder (\n    input [31:0] in,\n    output reg [4:0] pos // Position of the first high bit in the input\n);\n\nalways @(*) begin\n    case(in)\n        32'b00000000000000000000000000000000: pos = 5'b00000;\n        32'b00000000000000000000000000000001: pos = 5'b00001;\n        32'b00000000000000000000000000000011: pos = 5'b00010;\n        32'b00000000000000000000000000000111: pos = 5'b00011;\n        32'b00000000000000000000000000001111: pos = 5'b00100;\n        32'b00000000000000000000000000011111: pos = 5'b00101;\n        32'b00000000000000000000000000111111: pos = 5'b00110;\n        32'b00000000000000000000000001111111: pos = 5'b00111;\n        32'b00000000000000000000000011111111: pos = 5'b01000;\n        32'b00000000000000000000000111111111: pos = 5'b01001;\n        32'b00000000000000000000001111111111: pos = 5'b01010;\n        32'b00000000000000000000011111111111: pos = 5'b01011;\n        default: pos = 5'b01111;\n    endcase\nend\n\nendmodule",
        "module_name": "byte_reversal",
        "module_hash": "03dca64576b4b2a2b93aca4c06806d9b",
        "dataset_index": 13344
      },
      "binary_counter_with_sync_reset_4d529226": {
        "rtl_code": "\nmodule binary_counter_with_sync_reset (\n    input clk,\n    input reset,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end\n    end\n\nendmodule\nmodule shift_register_with_serial_in_out (\n    input clk,\n    input reset,\n    input SI,\n    output reg SO,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= {Q[2:0], SI};\n            SO <= Q[0];\n        end\n    end\n\nendmodule\nmodule bitwise_OR_module (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Y\n);\n\n    always @(*) begin\n        Y = A | B;\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input SI,\n    input select,\n    output reg [3:0] Q\n);\n\n    reg [3:0] counter_out;\n    reg [3:0] shift_reg_out;\n    reg [3:0] bitwise_OR_out;\n\n    binary_counter_with_sync_reset counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .Q(counter_out)\n    );\n\n    shift_register_with_serial_in_out shift_reg_inst (\n        .clk(clk),\n        .reset(reset),\n        .SI(SI),\n        .Q(shift_reg_out)\n    );\n\n    bitwise_OR_module bitwise_OR_inst (\n        .A(counter_out),\n        .B(shift_reg_out),\n        .Y(bitwise_OR_out)\n    );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= bitwise_OR_out;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter_with_sync_reset",
        "module_hash": "4d5292268c80211782b1f52438410642",
        "dataset_index": 10444
      },
      "square_wave_gen_55ccaa2d": {
        "rtl_code": "\nmodule square_wave_gen (\n  input clk,\n  input freq,\n  output reg square_wave\n);\n\n  reg [31:0] counter, half_period, clk_period;\n\n  always @(posedge clk) begin\n    if (counter == half_period) begin\n      square_wave <= ~square_wave;\n      counter <= 0;\n    end else begin\n      counter <= counter + 1'b1;\n    end\n  end\n\n  always @(posedge clk) begin\n    clk_period <= (clk_period / freq) ? (clk_period / freq) : 1'b0;\n    half_period <= clk_period / 2;\n  end\n\nendmodule",
        "module_name": "square_wave_gen",
        "module_hash": "55ccaa2d8594fd5a7168343bac0a6780",
        "dataset_index": 16211
      },
      "gray_to_binary_9e913ef0": {
        "rtl_code": "module gray_to_binary (\n    input clk,\n    input rst,\n    input ena,\n    input [3:0] gray,\n    output [3:0] binary\n);\n\nreg [3:0] gray_reg1, gray_reg2;\nreg [3:0] binary_reg1, binary_reg2;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        gray_reg1 <= 4'b0000;\n        gray_reg2 <= 4'b0000;\n        binary_reg1 <= 4'b0000;\n        binary_reg2 <= 4'b0000;\n    end else if (ena) begin\n        gray_reg1 <= gray;\n        gray_reg2 <= gray_reg1;\n        binary_reg1 <= binary_reg2;\n        binary_reg2 <= binary_reg1 ^ gray_reg2;\n    end\nend\n\nassign binary = binary_reg2;\n\nendmodule",
        "module_name": "gray_to_binary",
        "module_hash": "9e913ef04c8782a90217686a40412fe1",
        "dataset_index": 2969
      },
      "fsm_bit_pattern_detection_cfeb4f39": {
        "rtl_code": "module fsm_bit_pattern_detection (\n  input clk,\n  input reset,\n  input [7:0] data,\n  output reg pulse\n);\n\n  parameter S0 = 2'b00; // Idle state\n  parameter S1 = 2'b01; // First bit of pattern detected\n  parameter S2 = 2'b10; // Second bit of pattern detected\n  parameter S3 = 2'b11; // Pattern detected\n  \n  reg [1:0] state; // FSM state register\n  reg [7:0] shift_reg; // Shift register for input data\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= S0;\n      shift_reg <= 8'h00;\n      pulse <= 1'b0;\n    end\n    else begin\n      case (state)\n        S0: begin // Idle state\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg == 8'b10110101) begin // Detect pattern\n            state <= S3;\n            pulse <= 1'b1; // Output pulse\n          end\n          else if (shift_reg[7] == 1'b1) begin // First bit detected\n            state <= S1;\n          end\n        end\n        S1: begin // First bit detected\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg[7:6] == 2'b10) begin // Second bit detected\n            state <= S2;\n          end\n          else if (shift_reg[7] == 1'b0) begin // Reset if pattern not found\n            state <= S0;\n          end\n        end\n        S2: begin // Second bit detected\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg[7:5] == 3'b101) begin // Pattern detected\n            state <= S3;\n            pulse <= 1'b1; // Output pulse\n          end\n          else if (shift_reg[7:6] != 2'b10) begin // Reset if pattern not found\n            state <= S0;\n          end\n        end\n        S3: begin // Pattern detected\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg[7:0] != 8'b10110101) begin // Reset if pattern not found\n            state <= S0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "fsm_bit_pattern_detection",
        "module_hash": "cfeb4f39235d27378a023ebc4b17f538",
        "dataset_index": 4138
      },
      "Multiplexer_AC__parameterized61_fb8f84e1": {
        "rtl_code": "\nmodule Multiplexer_AC__parameterized61\n   (ctrl,\n    D0,\n    D1,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  output [0:0]S;\n\n  wire [0:0]S;\n\n  assign S = ctrl ? D1 : D0;\nendmodule",
        "module_name": "Multiplexer_AC__parameterized61",
        "module_hash": "fb8f84e16a38e05f4c44f310c565417a",
        "dataset_index": 18862
      },
      "NOR3X1_74c0ceb4": {
        "rtl_code": "module NOR3X1 (\n\tA, \n\tB, \n\tC, \n\tY);\n   input A;\n   input B;\n   input C;\n   output Y;\n   \n   wire AB_nor;\n   wire AB_nor_C_nor;\n   \n   nor(AB_nor, A, B);\n   nor(AB_nor_C_nor, AB_nor, C);\n   assign Y = AB_nor_C_nor;\n   \nendmodule",
        "module_name": "NOR3X1",
        "module_hash": "74c0ceb4c4c41c17e4eb1bf581c3d6a2",
        "dataset_index": 20082
      },
      "sky130_fd_sc_ls__o311a_7434c429": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o311a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1, A3     );\n    and and0 (and0_out_X, or0_out, B1, C1);\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o311a",
        "module_hash": "7434c42905a9bc517a90de6e56196055",
        "dataset_index": 14650
      },
      "bitwise_operators #_984d93ae": {
        "rtl_code": "module bitwise_operators #(\n  parameter n = 4\n) (\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output [n-1:0] C1,\n  output [n-1:0] C2,\n  output [n-1:0] C3,\n  output [n-1:0] C4\n\n);\n\n// Bitwise AND\nassign C1 = A & B;\n\n// Bitwise OR\nassign C2 = A | B;\n\n// Bitwise XOR\nassign C3 = A ^ B;\n\n// Bitwise NOT\nassign C4 = ~A;\n\nendmodule",
        "module_name": "bitwise_operators #",
        "module_hash": "984d93ae542a8bc4a7a1e0e1ce8a6bd4",
        "dataset_index": 16575
      },
      "mouse_painter_36a97d42": {
        "rtl_code": "module mouse_painter(\n    input [4:0] line_number,\n    output reg [7:0] line_code\n);\n\nparameter [7:0] line00 = 8'h01;\nparameter [7:0] line01 = 8'h03;\nparameter [7:0] line02 = 8'h07;\nparameter [7:0] line03 = 8'h0F;\nparameter [7:0] line04 = 8'h1F;\nparameter [7:0] line05 = 8'h3F;\nparameter [7:0] line06 = 8'h7F;\nparameter [7:0] line07 = 8'hFF;\nparameter [7:0] line08 = 8'h07;\nparameter [7:0] line09 = 8'h03;\nparameter [7:0] line10 = 8'h01;\n\nalways @(*) begin\n    case(line_number)\n        5'b00000 : line_code = line00;\n        5'b00001 : line_code = line01;\n        5'b00010 : line_code = line02;\n        5'b00011 : line_code = line03;\n        5'b00100 : line_code = line04;\n        5'b00101 : line_code = line05;\n        5'b00110 : line_code = line06;\n        5'b00111 : line_code = line07;\n        5'b01000 : line_code = line08;\n        5'b01001 : line_code = line09;\n        5'b01010 : line_code = line10;\n        default : line_code = 8'b00000000;\n    endcase\nend\n\nendmodule",
        "module_name": "mouse_painter",
        "module_hash": "36a97d426c2c0c6d769c233b5b7c14a1",
        "dataset_index": 13383
      },
      "max_value_9592a13e": {
        "rtl_code": "module max_value (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] max,\n    output reg equal_flag\n);\n\nalways @(*) begin\n    if (a > b) begin\n        max = a;\n        equal_flag = 0;\n    end\n    else if (b > a) begin\n        max = b;\n        equal_flag = 0;\n    end\n    else begin\n        max = a;\n        equal_flag = 1;\n    end\nend\n\nendmodule",
        "module_name": "max_value",
        "module_hash": "9592a13e8f1991983eac2f757f426c1f",
        "dataset_index": 2044
      },
      "comparator_4bit_8319eb3f": {
        "rtl_code": "\nmodule comparator_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  input [3:0] C,\n  input [3:0] D,\n  output reg eq,\n  output reg gt,\n  output reg lt\n);\n\n  always @(*) begin\n    eq = (A==B) && (B==C) && (C==D);\n    gt = (A>B) && (B>C) && (C>D);\n    lt = (A<B) && (B<C) && (C<D);\n  end\n\nendmodule\n",
        "module_name": "comparator_4bit",
        "module_hash": "8319eb3f777a1a8a15b13d1696146765",
        "dataset_index": 18789
      },
      "CLK_GATE_MODULE_66129a73": {
        "rtl_code": "\nmodule CLK_GATE_MODULE (\n  input CLK, EN, TE,\n  output ENCLK\n);\n\n  assign ENCLK = (EN & ~TE) ? CLK & EN : 1'b0;\n\nendmodule\n",
        "module_name": "CLK_GATE_MODULE",
        "module_hash": "66129a736fbc44aba02debcbc2f56ce7",
        "dataset_index": 14087
      },
      "processor_reset_71ae9ec1": {
        "rtl_code": "\nmodule processor_reset(\n  input  input_sync_clk,\n  input  ext_reset_in,\n  input  aux_reset_in,\n  input  mb_debug_sys_rst,\n  input  dcm_locked,\n  output reg mb_reset,\n  output reg bus_struct_reset,\n  output reg peripheral_reset,\n  output reg interconnect_aresetn,\n  output reg peripheral_aresetn\n);\n\n  parameter C_EXT_RST_WIDTH = 4;\n  parameter C_AUX_RST_WIDTH = 4;\n  parameter C_NUM_BUS_RST = 1;\n  parameter C_NUM_INTERCONNECT_ARESETN = 1;\n  parameter C_NUM_PERP_ARESETN = 1;\n  parameter C_AUX_RESET_HIGH = 1'b0;\n  parameter C_EXT_RESET_HIGH = 1'b1;\n  parameter C_FAMILY = \"artix7\";\n\n  reg [C_EXT_RST_WIDTH-1:0] ext_rst_count;\n  reg [C_AUX_RST_WIDTH-1:0] aux_rst_count;\n  reg [1:0] debug_rst_count;\n  reg dcm_locked_1;\n  \n  always @(posedge input_sync_clk) begin\n    ext_rst_count <= (ext_reset_in == C_EXT_RESET_HIGH) ? ext_rst_count + 1 : 0;\n    aux_rst_count <= (aux_reset_in == C_AUX_RESET_HIGH) ? aux_rst_count + 1 : 0;\n    debug_rst_count <= (mb_debug_sys_rst == 1'b1) ? debug_rst_count + 1 : 0;\n    dcm_locked_1 <= dcm_locked;\n  end\n\n  always @(ext_rst_count or aux_rst_count or debug_rst_count) begin\n    if (ext_rst_count == C_EXT_RST_WIDTH || aux_rst_count == C_AUX_RST_WIDTH || debug_rst_count == 2'd1) begin\n      mb_reset <= 1'b1;\n      bus_struct_reset <= 1'b1;\n      peripheral_reset <= 1'b1;\n    end\n\n    else if (dcm_locked_1 == 1'b0) begin\n      mb_reset <= 1'b0;\n      bus_struct_reset <= 1'b0;\n      peripheral_reset <= 1'b0;\n    end\n  end\n\n  always @* begin\n    interconnect_aresetn = (dcm_locked_1 == 1'b1) ? 1'b1 : 1'b0;\n    peripheral_aresetn = (dcm_locked_1 == 1'b1) ? 1'b1 : 1'b0;\n  end\n\nendmodule",
        "module_name": "processor_reset",
        "module_hash": "71ae9ec17dfbe2631585e66da335e5e6",
        "dataset_index": 16187
      },
      "mix_columns_ecf4b6c1": {
        "rtl_code": "module mix_columns\n(\n\toutput [31:0] mix_out_enc,\n\toutput [31:0] mix_out_dec,\n\tinput  [31:0] mix_in\n);\n\nlocalparam integer SIZE      = 32;\nlocalparam integer WORD_SIZE = 8;\nlocalparam integer NUM_WORDS = 4;\n\nwire [WORD_SIZE - 1 : 0] col  [0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] sum_p[0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] y    [0 : NUM_WORDS - 2];\n\nfunction [7:0] aes_mult_02;\n  input [7:0] data_in;\n  begin\n    aes_mult_02 = (data_in << 1) ^ {8{data_in[7]}} & 8'h1b;\n  end\nendfunction\n\nfunction [7:0] aes_mult_04;\n  input [7:0] data_in;\n  begin\n    aes_mult_04 = ((data_in << 2) ^ {8{data_in[6]}} & 8'h1b) ^ {8{data_in[7]}} & 8'h36;\n  end\nendfunction\n\ngenerate\n\tgenvar i;\n\tfor(i = 0 ; i < NUM_WORDS; i = i + 1)\n\tbegin:WBT\n\t\tassign col[i] = mix_in[WORD_SIZE*(i + 1) - 1: WORD_SIZE*i];\n\tend\nendgenerate\n\ngenerate\n\tgenvar j;\n\tfor(j = 0; j < NUM_WORDS; j = j + 1)\n\t\tbegin:DMCO\n\t\t\tassign sum_p[j] = col[(j + 1)%NUM_WORDS] ^ col[(j + 2)%NUM_WORDS] ^ col[(j + 3)%NUM_WORDS];\n\t\t\tassign mix_out_enc[ WORD_SIZE*(j + 1) - 1 : WORD_SIZE*j] = aes_mult_02(col[j] ^ col[(j + NUM_WORDS - 1)%NUM_WORDS]) ^ sum_p[j];\n\t\tend\nendgenerate\n\nassign y[0] = aes_mult_04(col[2] ^ col[0]); \nassign y[1] = aes_mult_04(col[3] ^ col[1]);\nassign y[2] = aes_mult_02(  y[1] ^   y[0]);  \nassign mix_out_dec = mix_out_enc ^ {2{y[2] ^ y[1], y[2] ^ y[0]}};\n\nendmodule\n",
        "module_name": "mix_columns",
        "module_hash": "ecf4b6c1beabe5503f8cac5b0a521fb7",
        "dataset_index": 24530
      },
      "binary_counter_2c7d777e": {
        "rtl_code": "\nmodule binary_counter (\n    input clk,\n    input reset,\n    input count_en,\n    input [31:0] max_count,\n    input [31:0] load_val,\n    input load,\n    input count_dir,\n    output reg [31:0] count_out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_out <= 32'b0;\n    end\n    else if (load) begin\n        count_out <= load_val;\n    end\n    else if (count_en) begin\n        if (count_dir) begin\n            if (count_out == max_count) begin\n                count_out <= 32'b0;\n            end\n            else begin\n                count_out <= count_out + 1;\n            end\n        end\n        else begin\n            if (count_out == 0) begin\n                count_out <= max_count;\n            end\n            else begin\n                count_out <= count_out - 1;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "2c7d777ecfda621540fca33f9bfac4f0",
        "dataset_index": 17157
      },
      "top__791ff194": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [3:0] a,    // 4-bit input for ALU\n    input [3:0] b,    // 4-bit input for ALU\n    input [2:0] op,   // 3-bit control signal for ALU\n    output [3:0] q // 4-bit output of the functional module\n);\n\nwire [3:0] alu_output;\n\nalu alu_inst (\n    .a(a),\n    .b(b),\n    .op(op),\n    .result(alu_output)\n);\n\ntwos_complement twos_complement_inst (\n    .input_value(alu_output),\n    .output_value(q)\n);\n\nendmodule\n\nmodule alu (\n    input [3:0] a,\n    input [3:0] b,\n    input [2:0] op,\n    output reg [3:0] result\n);\n\nalways @(*) begin\n    case (op)\n        3'b000: result = a + b;\n        3'b001: result = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        3'b101: result = a << 1;\n        default: result = 4'b0;\n    endcase\nend\n\nendmodule\n\nmodule twos_complement (\n    input [3:0] input_value,\n    output reg [3:0] output_value\n);\n\nalways @(*) begin\n    output_value = ~input_value + 4'b0001;\nend\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "791ff194c57fdbcdcbd10d830e13983b",
        "dataset_index": 3591
      },
      "HallwayRight_4a8d3845": {
        "rtl_code": "module HallwayRight(clk_vga, CurrentX, CurrentY, mapData, wall);\n\n\tinput clk_vga;\n\tinput [9:0]CurrentX;\n\tinput [8:0]CurrentY;\n\tinput [7:0]wall;\n\t\n\toutput [7:0]mapData;\n\t\n\treg [7:0]mColor;\n\t\n\talways @(posedge clk_vga) begin\n\t\t//Top walls\n\t\tif((CurrentY < 40) && ~(CurrentX < 0)) begin\n\t\t\tmColor[7:0] <= wall;\n\t\tend \n\t\t//Right side wall\n\t\telse if(~(CurrentX < 600)) begin\n\t\t\tmColor[7:0] <= wall;\n\t\tend\n\t\t//Bottom wall\n\t\telse if((~(CurrentY < 440) && (CurrentX < 260)) || (~(CurrentY < 440) && ~(CurrentX < 380))) begin\n\t\t\tmColor[7:0] <= wall;\n\t\t//floor area - grey\n\t\tend else\n\t\t\tmColor[7:0] <= 8'b10110110;\n\t\t\t\n\tend\n\t\n\tassign mapData = mColor;\n\t\nendmodule",
        "module_name": "HallwayRight",
        "module_hash": "4a8d38450b5c98f17ff1b8b41c3a3792",
        "dataset_index": 17353
      },
      "usb_crc5_7417fc84": {
        "rtl_code": "\nmodule usb_crc5(\n  input [10:0] data_in,\n  input crc_en,\n  output [4:0] crc_out,\n  input rst,\n  input clk);\n\n  reg [4:0] lfsr_q,lfsr_c;\n\n  assign crc_out = ~lfsr_q;\n\n  always @(*) begin\n    lfsr_c[0] = lfsr_q[0] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[0] ^ data_in[3] ^ data_in[5] ^ data_in[6] ^ data_in[9] ^ data_in[10];\n    lfsr_c[1] = lfsr_q[0] ^ lfsr_q[1] ^ lfsr_q[4] ^ data_in[1] ^ data_in[4] ^ data_in[6] ^ data_in[7] ^ data_in[10];\n    lfsr_c[2] = lfsr_q[0] ^ lfsr_q[1] ^ lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[0] ^ data_in[2] ^ data_in[3] ^ data_in[6] ^ data_in[7] ^ data_in[8] ^ data_in[9] ^ data_in[10];\n    lfsr_c[3] = lfsr_q[1] ^ lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[1] ^ data_in[3] ^ data_in[4] ^ data_in[7] ^ data_in[8] ^ data_in[9] ^ data_in[10];\n    lfsr_c[4] = lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[2] ^ data_in[4] ^ data_in[5] ^ data_in[8] ^ data_in[9] ^ data_in[10];\n\n  end always @(posedge clk, posedge rst) begin\n    if(rst) begin\n      lfsr_q <= {5{1'b1}};\n    end\n    else begin\n      lfsr_q <= crc_en ? lfsr_c : lfsr_q;\n    end\n  end endmodule `ifdef TEST_USB_CRC5\nmodule tb();\nreg [10:0] data_in;\nreg crc_en;\nwire [4:0] crc_out;\nreg rst;\nwire clk;\nsim_clk #(125) clk_125_r(.clk(clk));\nusb_crc5 dut(.*);\nwire [4:0] to_wire = ~crc_out; initial begin\n  $dumpfile(\"crc5.lxt\");\n  $dumpvars();\n  rst <= 1'b0;\n  crc_en <= 1'b0;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b1;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b0;\n  wait(clk);\n  wait(~clk);\n  data_in <= 11'b10000000000;\n  crc_en <= 1'b1;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b1;\n  crc_en <= 1'b0;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b0;\n  crc_en <= 1'b1;\n  data_in <= 11'b01000000000;\n  #1000;\n  $finish();\nend\nendmodule\n`endif\n\n",
        "module_name": "usb_crc5",
        "module_hash": "7417fc8416a52ddd803277a7f7c88cb4",
        "dataset_index": 13443
      },
      "altera_up_av_config_auto_init_ltm_3988eba4": {
        "rtl_code": "\nmodule altera_up_av_config_auto_init_ltm (\n    // Inputs\n    clk,\n    rom_address,\n\n    // Outputs\n    rom_data\n);\n\n\n\n\n// Inputs\ninput           clk;\ninput           [4:0]   rom_address;\n\n// Outputs\noutput      [23:0]  rom_data;\n\n\n\n// States\nlocalparam [4:0] STATE_0 = 5'h0;\nlocalparam [4:0] STATE_1 = 5'h1;\nlocalparam [4:0] STATE_2 = 5'h2;\nlocalparam [4:0] STATE_3 = 5'h3;\nlocalparam [4:0] STATE_4 = 5'h4;\nlocalparam [4:0] STATE_5 = 5'h5;\nlocalparam [4:0] STATE_6 = 5'h6;\nlocalparam [4:0] STATE_7 = 5'h7;\nlocalparam [4:0] STATE_8 = 5'h8;\nlocalparam [4:0] STATE_9 = 5'h9;\nlocalparam [4:0] STATE_10 = 5'hA;\nlocalparam [4:0] STATE_11 = 5'hB;\nlocalparam [4:0] STATE_12 = 5'hC;\nlocalparam [4:0] STATE_13 = 5'hD;\nlocalparam [4:0] STATE_14 = 5'hE;\nlocalparam [4:0] STATE_15 = 5'hF;\nlocalparam [4:0] STATE_16 = 5'h10;\nlocalparam [4:0] STATE_17 = 5'h11;\nlocalparam [4:0] STATE_18 = 5'h12;\nlocalparam [4:0] STATE_19 = 5'h13;\n\n\n// Internal Wires\nreg         [23:0] data;\n\n// State Machine Registers\nreg         [4:0]   state_reg;\nreg         [4:0]   next_state;\n\n\n\nalways @(*) begin\n    case (state_reg)\n        STATE_0 : next_state = (rom_address == 5'h0) ? STATE_0 : STATE_1;\n        STATE_1 : next_state = (rom_address == 5'h1) ? STATE_1 : STATE_2;\n        STATE_2 : next_state = (rom_address == 5'h2) ? STATE_2 : STATE_3;\n        STATE_3 : next_state = (rom_address == 5'h3) ? STATE_3 : STATE_4;\n        STATE_4 : next_state = (rom_address == 5'h4) ? STATE_4 : STATE_5;\n        STATE_5 : next_state = (rom_address == 5'h5) ? STATE_5 : STATE_6;\n        STATE_6 : next_state = (rom_address == 5'h6) ? STATE_6 : STATE_7;\n        STATE_7 : next_state = (rom_address == 5'h7) ? STATE_7 : STATE_8;\n        STATE_8 : next_state = (rom_address == 5'h8) ? STATE_8 : STATE_9;\n        STATE_9 : next_state = (rom_address == 5'h9) ? STATE_9 : STATE_10;\n        STATE_10 : next_state = (rom_address == 5'hA) ? STATE_10 : STATE_11;\n        STATE_11 : next_state = (rom_address == 5'hB) ? STATE_11 : STATE_12;\n        STATE_12 : next_state = (rom_address == 5'hC) ? STATE_12 : STATE_13;\n        STATE_13 : next_state = (rom_address == 5'hD) ? STATE_13 : STATE_14;\n        STATE_14 : next_state = (rom_address == 5'hE) ? STATE_14 : STATE_15;\n        STATE_15 : next_state = (rom_address == 5'hF) ? STATE_15 : STATE_16;\n        STATE_16 : next_state = (rom_address == 5'h10) ? STATE_16 : STATE_17;\n        STATE_17 : next_state = (rom_address == 5'h11) ? STATE_17 : STATE_18;\n        STATE_18 : next_state = (rom_address == 5'h12) ? STATE_18 : STATE_19;\n        STATE_19 : next_state = (rom_address == 5'h13) ? STATE_19 : STATE_0;\n        default : next_state = STATE_0;\n    endcase\nend\n\n\n\n// State machine\nalways @(posedge clk) begin\n    state_reg <= next_state;\nend\n\n\n\n// Output Assignments\nassign rom_data = {data[13:8], 2'h0, data[7:0]};\n\n// Internal Assignments\nalways @(*) begin\n    case (state_reg)\n        STATE_0 : data <= {6'h02, 8'h07};\n        STATE_1 : data <= {6'h03, 8'hDF};\n        STATE_2 : data <= {6'h04, 8'h17};\n        STATE_3 : data <= {6'h11, 8'h00};\n        STATE_4 : data <= {6'h12, 8'h5B};\n        STATE_5 : data <= {6'h13, 8'hFF};\n        STATE_6 : data <= {6'h14, 8'h00};\n        STATE_7 : data <= {6'h15, 8'h20};\n        STATE_8 : data <= {6'h16, 8'h40};\n        STATE_9 : data <= {6'h17, 8'h80};\n        STATE_10 : data <= {6'h18, 8'h00};\n        STATE_11 : data <= {6'h19, 8'h80};\n        STATE_12 : data <= {6'h1A, 8'h00};\n        STATE_13 : data <= {6'h1B, 8'h00};\n        STATE_14 : data <= {6'h1C, 8'h80};\n        STATE_15 : data <= {6'h1D, 8'hC0};\n        STATE_16 : data <= {6'h1E, 8'hE0};\n        STATE_17 : data <= {6'h1F, 8'hFF};\n        STATE_18 : data <= {6'h20, 8'hD2};\n        STATE_19 : data <= {6'h21, 8'hD2};\n        default : data <= 24'h000000;\n    endcase\nend\n\n\n\nendmodule",
        "module_name": "altera_up_av_config_auto_init_ltm",
        "module_hash": "3988eba4a5be7e7427222020e8fadc67",
        "dataset_index": 11863
      },
      "fmlarb_dack_b01bc0c9": {
        "rtl_code": "\n\n\n\nmodule fmlarb_dack(\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\tinput stb,\n\tinput eack,\n\tinput we,\n\n\toutput stbm,\n\toutput reg ack\n);\n\nwire read = eack & ~we;\nwire write = eack & we;\n\nreg ack_read2;\nreg ack_read1;\nreg ack_read0;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack_read2 <= 1'b0;\n\t\tack_read1 <= 1'b0;\n\t\tack_read0 <= 1'b0;\n\tend else begin\n\t\tack_read2 <= read;\n\t\tack_read1 <= ack_read2;\n\t\tack_read0 <= ack_read1;\n\tend\nend\n\nreg ack0;\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack0 <= 1'b0;\n\t\tack <= 1'b0;\n\tend else begin\n\t\tack0 <= ack_read0|write;\n\t\tack <= ack0;\n\tend\nend\n\nreg mask;\nassign stbm = stb & ~mask;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tmask <= 1'b0;\n\telse begin\n\t\tif(eack)\n\t\t\tmask <= 1'b1;\n\t\tif(ack)\n\t\t\tmask <= 1'b0;\n\tend\nend\n\nendmodule\n",
        "module_name": "fmlarb_dack",
        "module_hash": "b01bc0c956a997c1f0e1bb862e5b87f6",
        "dataset_index": 24730
      },
      "mux_2to1_behavioral_cef3b88a": {
        "rtl_code": "module mux_2to1_behavioral (\n  input [3:0] a,\n  input [3:0] b,\n  input s,\n  output reg [3:0] mux_out\n);\n\n  always @(*) begin\n    if (s == 1'b0) begin\n      mux_out = a;\n    end else begin\n      mux_out = b;\n    end\n  end\n\nendmodule\n",
        "module_name": "mux_2to1_behavioral",
        "module_hash": "cef3b88a488152d36f1ae9fa207add57",
        "dataset_index": 20785
      },
      "control_enable_options_7f6aa6a5": {
        "rtl_code": "\n\n\nmodule control_enable_options(\n    input wire clk,\n    input wire rst_n,\n    input wire [7:0] zxuno_addr,\n    input wire zxuno_regrd,\n    input wire zxuno_regwr,\n    input wire [7:0] din,\n    output reg [7:0] dout,\n    output reg oe_n,\n    output wire disable_ay,\n    output wire disable_turboay,\n    output wire disable_7ffd,\n    output wire disable_1ffd,\n    output wire disable_romsel7f,\n    output wire disable_romsel1f,\n    output wire enable_timexmmu,\n    output wire disable_spisd,\n    output wire disable_timexscr,\n    output wire disable_ulaplus,\n    output wire disable_radas\n    );\n\n    parameter DEVOPTIONS = 8'h0E;\n    parameter DEVOPTS2   = 8'h0F;\n    \n    reg [7:0] devoptions = 8'h00;  reg [7:0] devopts2 = 8'h00;    assign disable_ay = devoptions[0];\n    assign disable_turboay = devoptions[1];\n    assign disable_7ffd = devoptions[2];\n    assign disable_1ffd = devoptions[3];\n    assign disable_romsel7f = devoptions[4];\n    assign disable_romsel1f = devoptions[5];\n    assign enable_timexmmu = devoptions[6];\n    assign disable_spisd = devoptions[7];\n    assign disable_timexscr = devopts2[0];\n    assign disable_ulaplus = devopts2[1];\n    assign disable_radas = devopts2[2];\n    \n    always @(posedge clk) begin\n        if (rst_n == 1'b0) begin\n            devoptions <= 8'h00;  devopts2 <= 8'h00;\n        end\n        else if (zxuno_addr == DEVOPTIONS && zxuno_regwr == 1'b1)\n            devoptions <= din;\n        else if (zxuno_addr == DEVOPTS2 && zxuno_regwr == 1'b1)\n            devopts2 <= din;\n    end\n    \n    always @* begin\n        oe_n = 1'b1;\n        dout = 8'hFF;\n        if (zxuno_regrd == 1'b1)            \n            if (zxuno_addr == DEVOPTIONS) begin\n                oe_n = 1'b0;\n                dout = devoptions;\n            end\n            else if (zxuno_addr == DEVOPTS2) begin\n                oe_n = 1'b0;\n                dout = devopts2;\n            end\n        end\nendmodule\n",
        "module_name": "control_enable_options",
        "module_hash": "7f6aa6a5730eb3d77cfddda7179e1598",
        "dataset_index": 8252
      },
      "memory_module_b480f87c": {
        "rtl_code": "module memory_module\n  (\n    clk_i,\n    rst_i,\n    we_i,  \n    stb_i,\n    ack_o,\n    dat_i,\n    dat_o,\n    adr_i,\n    a11,\n    a12,\n    b10,\n    b11,\n    b12\n  );\n\n  input clk_i;\n  input rst_i;\n  input we_i;\n  input stb_i;\n  output ack_o;\n  input [15:0] dat_i;\n  output [15:0] dat_o;\n  input [2:0] adr_i;\n  output [15:0] a11;\n  output [15:0] a12;\n  output [15:0] b10;\n  output [15:0] b11;\n  output [15:0] b12;\n\n  reg [15:0] a11;\n  reg [15:0] a12;\n  reg [15:0] b10;\n  reg [15:0] b11;\n  reg [15:0] b12;\n\n  wire ack_o;\n  wire sel_a11;\n  wire sel_a12;\n  wire sel_b10;\n  wire sel_b11;\n  wire sel_b12;\n\n  assign sel_a11 = (adr_i == 3'b000);\n  assign sel_a12 = (adr_i == 3'b001);\n  assign sel_b10 = (adr_i == 3'b010);\n  assign sel_b11 = (adr_i == 3'b011);\n  assign sel_b12 = (adr_i == 3'b100);\n\n  assign ack_o = stb_i;\n\n  always @(posedge clk_i or posedge rst_i)\n    if (rst_i) begin\n      a11 <= 16'hFF;\n      a12 <= 16'h1F;\n      b10 <= 16'h7F;\n      b11 <= 16'h3;\n      b12 <= 16'hFF;\n    end\n    else begin\n      a11 <= (stb_i & we_i & sel_a11) ? dat_i : a11;\n      a12 <= (stb_i & we_i & sel_a12) ? dat_i : a12;\n      b10 <= (stb_i & we_i & sel_b10) ? dat_i : b10;\n      b11 <= (stb_i & we_i & sel_b11) ? dat_i : b11;\n      b12 <= (stb_i & we_i & sel_b12) ? dat_i : b12;\n    end\n\n  assign dat_o = sel_a11 ? a11 :\n    (sel_a12 ? a12 :\n    (sel_b10 ? b10 :\n    (sel_b11 ? b11 :\n    (sel_b12 ? b12 : 16'h0000))));\n\nendmodule",
        "module_name": "memory_module",
        "module_hash": "b480f87c2be17aa95b14543d3d72037b",
        "dataset_index": 6304
      },
      "parity_sum_292fad87": {
        "rtl_code": "\nmodule parity_sum (\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] parity_sum\n);\n\nendmodule\nmodule parity_checker #(\n    parameter DATAWIDTH = 8\n) (\n    input [DATAWIDTH-1:0] data,\n    output parity\n);\n\n    wire [DATAWIDTH-1:0] sum;\n    genvar i;\n    \n    for (i = 0; i < DATAWIDTH; i = i + 1) begin : adder_tree\n        assign sum[i] = data[i] ^ (i == 0 ? 0 : sum[i-1]);\n    end\n    \n    assign parity = sum[DATAWIDTH-1];\n\nendmodule",
        "module_name": "parity_sum",
        "module_hash": "292fad878bd5ff1c785da8bb17985949",
        "dataset_index": 11306
      },
      "binary_counter_8775e333": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "8775e333ac4c10de89e56e85bd65b713",
        "dataset_index": 16940
      },
      "ddr_ctrl_wrapper #_aaad6b8b": {
        "rtl_code": "\n\nmodule ddr_ctrl_wrapper #(\n\tparameter ADDR_WIDTH\t= 25\t)\n(\n\toutput\t\t\trdy_o,\n\toutput\t\t\tidle_o,\n\tinput  [31:0]\t\tadr_i,\n\toutput [31:0]\t\tadr_o,\n\tinput  [31:0]\t\tdat_i,\n\toutput [31:0]\t\tdat_o,\n\tinput  [3:0]\t\tsel_i,\n\tinput\t\t\tacc_i,\n\toutput\t\t\tack_o,\n\tinput\t\t\twe_i,\n\tinput  [3:0]\t\tbuf_width_i,\n\n\toutput [ADDR_WIDTH-3:0]\tlocal_address_o,\n\toutput\t\t\tlocal_write_req_o,\n\toutput\t\t\tlocal_read_req_o,\n\toutput\t\t\tlocal_burstbegin_o,\n\toutput [31:0]\t\tlocal_wdata_o,\n\toutput [3:0]\t\tlocal_be_o,\n\toutput [6:0]\t\tlocal_size_o,\n\tinput  [31:0]\t\tlocal_rdata_i,\n\tinput\t\t\tlocal_rdata_valid_i,\n\tinput\t\t\tlocal_reset_n_i,\n\tinput\t\t\tlocal_clk_i,\n\tinput\t\t\tlocal_ready_i\n);\n\n\tlocalparam LOCAL_ADR_WIDTH = ADDR_WIDTH-2;\n\n\tfunction [31:0] get_mask;\n\tinput [3:0] width;\n\t\tbegin\n\t\t\tget_mask = ((1 << (width)) - 1);\n\t\tend\n\tendfunction\n\n\tassign local_be_o\t= sel_i;\n\tassign dat_o\t\t= local_rdata_i;\n\tassign local_address_o\t= we_i ? adr_i[LOCAL_ADR_WIDTH+1:2] : adr_i[LOCAL_ADR_WIDTH+1:2] & ~get_mask(buf_width_i);\n\tassign local_wdata_o\t= dat_i;\n\n\treg [22:0]\tlocal_address;\n\treg\t\tlocal_write_req;\n\treg\t\tlocal_read_req;\n\treg\t\tlocal_burstbegin;\n\treg [31:0]\tlocal_wdata;\n\treg [6:0]\tlocal_size;\n\n\tassign local_write_req_o\t= local_write_req;\n\tassign local_read_req_o\t\t= local_read_req;\n\tassign local_burstbegin_o\t= local_burstbegin;\n\tassign local_size_o\t\t= local_size;\n\n\treg [3:0]\tstate;\n\treg [31:0]\tcount;\n\treg\t\tack_w;\n\treg [31:0]\tadr;\n\n\tlocalparam [3:0]\n\t\tWAIT_READY    = 4'h0,\n\t\tIDLE          = 4'h1,\n\t\tWRITE         = 4'h2,\n\t\tREAD          = 4'h3;\n\n\tassign rdy_o = local_ready_i;\n\tassign idle_o = (state == IDLE);\n\tassign adr_o = adr;\n\n\tassign ack_o = acc_i ? (we_i ? ack_w : local_rdata_valid_i) : 1'b0;\n\n\talways @(posedge local_clk_i) begin\n\t\tif (local_reset_n_i == 1'b0) begin\n\t\t\tlocal_write_req\t\t<= 1'b0;\n\t\t\tlocal_read_req\t\t<= 1'b0;\n\t\t\tlocal_burstbegin\t<= 1'b0;\n\t\t\tlocal_size\t\t<= 6'b1;\n\t\t\tcount\t\t\t<= 0;\n\t\t\tadr\t\t\t<= 32'b0;\n\t\t\tstate\t\t\t<= WAIT_READY;\n\t\tend else begin\n\n\t\t\tack_w\t\t\t<= 1'b0;\n\t\t\tlocal_burstbegin\t<= 1'b0;\n\t\t\tlocal_write_req\t\t<= 1'b0;\n\t\t\tlocal_burstbegin\t<= 1'b0;\n\t\t\tlocal_read_req\t\t<= 1'b0;\n\n\t\t\tcase (state)\n\n\t\t\tWAIT_READY: begin\n\t\t\t\tif (local_ready_i)\n\t\t\t\t\tstate <= IDLE;\n\t\t\tend\n\n\t\t\tIDLE: begin\n\t\t\t\tif (acc_i) begin\n\t\t\t\t\tif (we_i & local_ready_i) begin\n\t\t\t\t\t\tack_w\t\t\t<= 1'b1;\n\t\t\t\t\t\tlocal_burstbegin\t<= 1'b1;\n\t\t\t\t\t\tlocal_write_req\t\t<= 1'b1;\n\t\t\t\t\t\tlocal_size\t\t<= 1;\n\t\t\t\t\t\tstate\t\t\t<= WRITE;\n\t\t\t\t\tend\n\t\t\t\t\tif (!we_i & local_ready_i) begin\n\t\t\t\t\t\tlocal_burstbegin\t<= 1'b1;\n\t\t\t\t\t\tlocal_read_req\t\t<= 1'b1;\n\t\t\t\t\t\tstate\t\t\t<= READ;\n\t\t\t\t\t\tlocal_size\t\t<= (1<<buf_width_i);\n\t\t\t\t\t\tadr\t\t\t<= adr_i & ~get_mask(buf_width_i+2);\n\t\t\t\t\t\tcount\t\t\t<= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tWRITE : begin\n\t\t\t\tstate <= IDLE;\n\t\t\tend\n\n\t\t\tREAD : begin\n\t\t\t\tif (local_rdata_valid_i) begin\n\t\t\t\t\tcount <= count + 1'b1;\n\t\t\t\t\tadr <= (adr & ~get_mask(buf_width_i+2)) | ((((adr >> 2) + 1) & get_mask(buf_width_i)) << 2);\n\t\t\t\tend\n\n\t\t\t\tif (count == (1<<buf_width_i)) begin\n\t\t\t\t\tcount <= 0;\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend\n\t\t\tend\n\n\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "ddr_ctrl_wrapper #",
        "module_hash": "aaad6b8b2d0c489e6c1a02245080750c",
        "dataset_index": 25292
      },
      "count_ones_82f4207b": {
        "rtl_code": "module count_ones (\n    input [31:0] in,\n    input clk,\n    output reg [5:0] out\n);\n\nreg [31:0] in_reg;\nreg [31:0] in_reg_pipe1;\nreg [31:0] in_reg_pipe32;\n\nreg [31:0] sum_reg;\nreg [31:0] sum_reg_pipe31;\nreg [31:0] sum_reg_pipe32;\n\nalways @(posedge clk) begin\n    in_reg_pipe1 <= in_reg;\n    in_reg_pipe32 <= in_reg_pipe1;\n    \n    sum_reg_pipe31 <= sum_reg;\n    sum_reg_pipe32 <= sum_reg_pipe31;\nend\n\nalways @(posedge clk) begin\n    in_reg <= in;\n    sum_reg <= sum_reg_pipe31 + in_reg_pipe32;\nend\n\nalways @(*) begin\n    out = sum_reg_pipe32[5:0];\nend\n\nendmodule",
        "module_name": "count_ones",
        "module_hash": "82f4207b20b892cc3189a19e6ab9262f",
        "dataset_index": 13293
      },
      "adapter_axi_stream_2_ppfifo_wl #_7bdd5501": {
        "rtl_code": "module adapter_axi_stream_2_ppfifo_wl #(\n  parameter                         DATA_WIDTH    = 32,\n  parameter                         STROBE_WIDTH  = DATA_WIDTH / 8,\n  parameter                         USE_KEEP      = 0\n)(\n  input                             rst,\n\n  input                             i_tear_effect,\n  input                             i_fsync,\n  input       [31:0]                i_pixel_count,\n\n  //AXI Stream Input\n  input                             i_axi_clk,\n  output                            o_axi_ready,\n  input       [DATA_WIDTH - 1:0]    i_axi_data,\n  input       [STROBE_WIDTH - 1:0]  i_axi_keep,\n  input                             i_axi_last,\n  input                             i_axi_valid,\n\n  //Ping Pong FIFO Write Controller\n  output                            o_ppfifo_clk,\n  input       [1:0]                 i_ppfifo_rdy,\n  output  reg [1:0]                 o_ppfifo_act,\n  input       [23:0]                i_ppfifo_size,\n  output  reg                       o_ppfifo_stb,\n  output  reg [DATA_WIDTH:0]        o_ppfifo_data\n);\n//local parameters\nlocalparam      WAIT_FOR_TEAR_EFFECT  = 0;\nlocalparam      WAIT_FOR_FRAME        = 1;\nlocalparam      READ_FRAME            = 2;\nlocalparam      WAIT_FOR_END_TEAR     = 3;\n\nlocalparam      TEAR_WINDOW_COUNT     = 100;\n\n//registes/wires\nwire                        clk;  //Convenience Signal\nreg           [3:0]         state;\nreg           [23:0]        r_count;\nreg                         r_last;\nreg           [31:0]        r_pixel_count;\nreg                         r_prev_tear;\nreg                         r_pos_edge_tear;\n\nassign  o_ppfifo_clk    = i_axi_clk;\nassign  clk             = i_axi_clk;\nassign  o_axi_ready     = (o_ppfifo_act > 0) &&\n                          (r_count < i_ppfifo_size) &&\n                          !r_last &&\n                          (state == READ_FRAME);\n//synchronous logic\n\nalways @ (posedge clk) begin\n  o_ppfifo_stb                                <=  0;\n  r_last                                      <=  0;\n\n  if (rst) begin\n    r_count                                   <=  0;\n    o_ppfifo_act                              <=  0;\n    o_ppfifo_data                             <=  0;\n    r_pos_edge_tear                           <=  0;\n    r_pixel_count                             <=  0;\n    state                                     <=  WAIT_FOR_TEAR_EFFECT;\n  end\n  else begin\n    if ((i_ppfifo_rdy > 0) && (o_ppfifo_act == 0)) begin\n      r_count                                 <=  0;\n      if (i_ppfifo_rdy[0]) begin\n        o_ppfifo_act[0]                       <=  1;\n      end\n      else begin\n        o_ppfifo_act[1]                       <=  1;\n      end\n    end\n\n    case (state)\n      WAIT_FOR_TEAR_EFFECT: begin\n        if (r_pos_edge_tear) begin\n          r_pos_edge_tear                     <=  0;\n          r_pixel_count                       <=  0;\n          state                               <=  WAIT_FOR_FRAME;\n        end\n      end\n      WAIT_FOR_FRAME: begin\n        r_pixel_count                         <=  0;\n        if (i_fsync) begin\n          state                               <= READ_FRAME;\n          r_pixel_count                       <= 0;\n        end\n        else if (r_pixel_count < TEAR_WINDOW_COUNT) begin\n          r_pixel_count                       <= r_pixel_count + 1;\n        end\n        else begin\n          state                               <= WAIT_FOR_TEAR_EFFECT;  \n        end\n      end\n      READ_FRAME: begin\n        if (o_ppfifo_act) begin\n          if (r_last) begin\n            o_ppfifo_act                      <=  0;\n            if (r_pixel_count >= i_pixel_count) begin\n              state                           <=  WAIT_FOR_END_TEAR;\n            end\n          end\n          else if (r_count < i_ppfifo_size) begin\n            if (i_axi_valid && o_axi_ready) begin\n              o_ppfifo_stb                      <=  1;\n              r_pixel_count                     <=  r_pixel_count + 1;\n              o_ppfifo_data[DATA_WIDTH - 1: 0]  <=  i_axi_data;\n              o_ppfifo_data[DATA_WIDTH]         <=  i_axi_last;\n              r_last                            <=  i_axi_last;\n              r_count                           <=  r_count + 1;\n            end\n          end\n          else begin\n            o_ppfifo_act                        <=  0;\n          end\n        end\n      end\n      WAIT_FOR_END_TEAR: begin\n        if (!i_tear_effect) begin\n          state                                 <=  WAIT_FOR_TEAR_EFFECT;\n        end\n      end\n    endcase\n\n    //Detect the positive edge of a tear effect\n    if (!r_prev_tear && i_tear_effect) begin\n      r_pos_edge_tear                           <=  1;\n    end\n    r_prev_tear                                 <=  i_tear_effect;\n  end\nend\n\nendmodule",
        "module_name": "adapter_axi_stream_2_ppfifo_wl #",
        "module_hash": "7bdd5501f1636da7dd18097c7f0b77b8",
        "dataset_index": 9088
      },
      "I2C_d70d7d27": {
        "rtl_code": "module I2C (\n  input SDA,\n  input SCL,\n  input rst,\n  output [2:0] state,\n  output ack\n);\n\n  // Define the states\n  parameter IDLE = 3'b000;\n  parameter START = 3'b001;\n  parameter WRITE = 3'b010;\n  parameter READ = 3'b011;\n  parameter ACK = 3'b100;\n  parameter NACK = 3'b101;\n  \n  // Define the state register\n  reg [2:0] current_state;\n  \n  // Define the acknowledge register\n  reg ack_reg;\n  \n  // Define the slave address and R/W bit\n  reg [6:0] slave_address;\n  reg rw_bit;\n  \n  // Define the data buffer\n  reg [7:0] data_buffer;\n  reg [2:0] data_index;\n  \n  // Define the start condition flag\n  reg start_condition;\n  \n  // Define the SDA and SCL signals\n  reg sda_signal;\n  reg scl_signal;\n  \n  // Define the SDA and SCL signal delays\n  parameter DELAY = 10;\n  reg [3:0] delay_counter;\n  \n  // Define the state machine\n  always @(posedge SCL or posedge rst) begin\n    if (rst) begin\n      current_state <= IDLE;\n      ack_reg <= 1'b0;\n      slave_address <= 7'b0000000;\n      rw_bit <= 1'b0;\n      data_buffer <= 8'b0;\n      data_index <= 3'b000;\n      start_condition <= 1'b0;\n      sda_signal <= 1'b1;\n      scl_signal <= 1'b1;\n      delay_counter <= 4'b0000;\n    end else begin\n      case (current_state)\n        IDLE: begin\n          if (start_condition) begin\n            current_state <= START;\n          end\n        end\n        START: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            sda_signal <= 1'b0;\n            scl_signal <= 1'b0;\n            current_state <= WRITE;\n          end\n        end\n        WRITE: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            if (data_index == 3'b000) begin\n              slave_address <= {1'b0, SDA};\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b001) begin\n              slave_address <= {slave_address[5:0], SDA};\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b010) begin\n              slave_address <= {slave_address[5:0], SDA};\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b011) begin\n              rw_bit <= SDA;\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b100) begin\n              ack_reg <= ~SDA;\n              if (ack_reg) begin\n                current_state <= ACK;\n              end else begin\n                current_state <= NACK;\n              end\n              data_index <= 3'b000;\n            end\n          end\n        end\n        READ: begin\n          // Not implemented\n        end\n        ACK: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            sda_signal <= 1'b1;\n            scl_signal <= 1'b1;\n            current_state <= IDLE;\n          end\n        end\n        NACK: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            sda_signal <= 1'b1;\n            scl_signal <= 1'b1;\n            current_state <= IDLE;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // Generate the SDA and SCL signals\n  always @(posedge SCL or posedge rst) begin\n    if (rst) begin\n      sda_signal <= 1'b1;\n      scl_signal <= 1'b1;\n    end else begin\n      case (current_state)\n        IDLE: begin\n          sda_signal <= 1'b1;\n          scl_signal <= 1'b1;\n        end\n        START: begin\n          sda_signal <= sda_signal;\n          scl_signal <= scl_signal;\n        end\n        WRITE: begin\n          sda_signal <= data_buffer[data_index];\n          scl_signal <= scl_signal;\n        end\n        READ: begin\n          // Not implemented\n        end\n        ACK: begin\n          sda_signal <= sda_signal;\n          scl_signal <= scl_signal;\n        end\n        NACK: begin\n          sda_signal <= sda_signal;\n          scl_signal <= scl_signal;\n        end\n      endcase\n    end\n  end\n  \n  // Assign the state and acknowledge signals\n  assign state = current_state;\n  assign ack = ack_reg;\n  \nendmodule",
        "module_name": "I2C",
        "module_hash": "d70d7d2784cd6d5259fd0d39b0bd0487",
        "dataset_index": 2443
      },
      "DATA_PHYSICAL_df175320": {
        "rtl_code": "\n\n\nmodule DATA_PHYSICAL(\n    input wire SD_CLK,\n    input wire RESET_L,\n    input wire strobe_IN_DATA_Phy,\n    input wire ack_IN_DATA_Phy,\n    input wire [15:0] timeout_Reg_DATA_Phy,\n    input wire [3:0] blocks_DATA_Phy,\n    input wire writeRead_DATA_Phy,\n    input wire multiple_DATA_Phy,\n    input wire idle_in_DATA_Phy,\n    input wire transmission_complete_PS_Phy,\n    input wire reception_complete_SP_Phy,\n    input wire [31:0] data_read_SP_Phy,\n    input wire [31:0] dataFromFIFO_FIFO_Phy,\n    output reg serial_Ready_Phy_DATA,\n    output reg complete_Phy_DATA,\n    output reg ack_OUT_Phy_DATA,\n    output reg data_timeout_Phy_DATA,\n    output reg reset_Wrapper_Phy_PS,\n    output reg enable_pts_Wrapper_Phy_PS,\n    output reg enable_stp_Wrapper_Phy_SP,\n    output reg [31:0] dataParallel_Phy_PS,\n    output reg pad_state_Phy_PAD,\n    output reg pad_enable_Phy_PAD,\n    output reg writeFIFO_enable_Phy_FIFO,\n    output reg readFIFO_enable_Phy_FIFO,\n    output reg [31:0] dataReadToFIFO_Phy_FIFO,\n    output reg IO_enable_Phy_SD_CARD\n);\n\nparameter RESET                  = 11'b00000000001;\nparameter IDLE                   = 11'b00000000010;\nparameter FIFO_READ              = 11'b00000000100;\nparameter LOAD_WRITE             = 11'b00000001000;\nparameter SEND                   = 11'b00000010000;\nparameter WAIT_RESPONSE          = 11'b00000100000;\nparameter READ                   = 11'b00001000000;\nparameter READ_FIFO_WRITE        = 11'b00010000000;\nparameter READ_WRAPPER_RESET     = 11'b00100000000;\nparameter WAIT_ACK               = 11'b01000000000;\nparameter SEND_ACK               = 11'b10000000000;\n\nreg [15:0] timeout_input;\nreg [3:0] blocks;\nreg [10:0] STATE;\nreg [10:0] NEXT_STATE;\n\n\nalways @ (posedge SD_CLK)\nbegin\n    if (!RESET_L)\n        begin\n        STATE <= RESET;\n        end\n    else\n        begin\n            STATE <= NEXT_STATE;\n        end\nend\nalways @ (*)\nbegin\n    case (STATE)\n        RESET:\n            begin\n            serial_Ready_Phy_DATA       = 0;\n            complete_Phy_DATA           = 0;\n            ack_OUT_Phy_DATA            = 0;\n            data_timeout_Phy_DATA       = 0;\n            reset_Wrapper_Phy_PS        = 1;                 enable_pts_Wrapper_Phy_PS   = 0;\n            enable_stp_Wrapper_Phy_SP   = 0;\n            dataParallel_Phy_PS         = 32'b0;\n            pad_state_Phy_PAD           = 0;\n            pad_enable_Phy_PAD          = 0;\n            writeFIFO_enable_Phy_FIFO   = 0;\n            readFIFO_enable_Phy_FIFO    = 0;\n            dataReadToFIFO_Phy_FIFO     = 32'b0;\n            IO_enable_Phy_SD_CARD        = 0;                NEXT_STATE = IDLE;\n            end\n        IDLE:\n            begin\n            serial_Ready_Phy_DATA = 1;\n            blocks = 4'b0;\n            timeout_input = 16'b0;\n\n            if (strobe_IN_DATA_Phy && writeRead_DATA_Phy)\n                begin\n                    NEXT_STATE = FIFO_READ;\n                end\n            else\n                begin\n                    NEXT_STATE = READ;\n                end\n            end\n        FIFO_READ:\n            begin\n            writeFIFO_enable_Phy_FIFO = 1;\n            dataParallel_Phy_PS = dataFromFIFO_FIFO_Phy;\n\n            NEXT_STATE = LOAD_WRITE;\n            end\n        LOAD_WRITE:\n            begin\n            enable_pts_Wrapper_Phy_PS = 1;\n            IO_enable_Phy_SD_CARD = 0;\n            pad_state_Phy_PAD = 1;\n            pad_enable_Phy_PAD = 1;\n\n            NEXT_STATE = SEND;\n            end\n        SEND:\n            begin\n            IO_enable_Phy_SD_CARD = 1;\n            NEXT_STATE = WAIT_RESPONSE;\n            end\n        WAIT_RESPONSE:\n            begin\n            enable_pts_Wrapper_Phy_PS = 0;\n            enable_stp_Wrapper_Phy_SP = 1;\n            pad_state_Phy_PAD = 0;\n            timeout_input = timeout_input + 1;\n            if (timeout_input == timeout_Reg_DATA_Phy)\n                begin\n                    data_timeout_Phy_DATA = 1;\n                end\n            else\n                begin\n                    data_timeout_Phy_DATA = 0;\n                end\n\n            if (reception_complete_SP_Phy)\n                begin\n                    blocks = blocks + 1;\n                    if (!multiple_DATA_Phy || (blocks==blocks_DATA_Phy))\n                        begin\n                            NEXT_STATE = WAIT_ACK;\n                        end\n                    else\n                        begin\n                            NEXT_STATE = FIFO_READ;\n                        end\n                end\n            else\n                begin\n                    NEXT_STATE = WAIT_RESPONSE;\n                end\n            end\n        READ:\n            begin\n            pad_enable_Phy_PAD = 1;\n            pad_state_Phy_PAD = 0;\n            enable_stp_Wrapper_Phy_SP = 1;\n            timeout_input = timeout_input + 1;\n            if (timeout_input == timeout_Reg_DATA_Phy)\n                begin\n                    data_timeout_Phy_DATA = 1;\n                end\n            else\n                begin\n                    data_timeout_Phy_DATA = 0;\n                end\n\n            if (reception_complete_SP_Phy)\n                begin\n                    blocks = blocks + 1;\n                    NEXT_STATE = READ_FIFO_WRITE;\n                end\n            else\n                begin\n                    NEXT_STATE = READ;\n                end\n            end\n        READ_FIFO_WRITE:\n            begin\n            readFIFO_enable_Phy_FIFO = 1;\n            dataReadToFIFO_Phy_FIFO = data_read_SP_Phy;\n            enable_stp_Wrapper_Phy_SP = 0;\n            if ((blocks == blocks_DATA_Phy) || !multiple_DATA_Phy)\n                begin\n                    NEXT_STATE = WAIT_ACK;\n                end\n            else\n                begin\n                    NEXT_STATE = READ_WRAPPER_RESET;\n                end\n            end\n        READ_WRAPPER_RESET:\n            begin\n            reset_Wrapper_Phy_PS = 1;\n            NEXT_STATE = READ;\n            end\n        WAIT_ACK:\n            begin\n            complete_Phy_DATA = 1;\n            if (ack_IN_DATA_Phy)\n                begin\n                    NEXT_STATE = SEND_ACK;\n                end\n            else\n                begin\n                    NEXT_STATE = WAIT_ACK;\n                end\n            end\n        SEND_ACK:\n            begin\n                ack_OUT_Phy_DATA = 1;\n                NEXT_STATE = IDLE;\n            end\n        default:\n            begin\n            NEXT_STATE = IDLE;  end\n    endcase\nend endmodule ",
        "module_name": "DATA_PHYSICAL",
        "module_hash": "df175320db5f9002eac8727367d9f43e",
        "dataset_index": 2359
      },
      "nor_buf_0bc39cea": {
        "rtl_code": "module nor_buf (\n    Y,\n    A,\n    B,\n    C\n);\n\n    // Module ports\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    // Local signals\n    wire nor_out_Y;\n\n    //  Name  Output      Other arguments\n    nor nor_gate (nor_out_Y, A, B, C);\n    buf buffer (Y, nor_out_Y);\n\nendmodule",
        "module_name": "nor_buf",
        "module_hash": "0bc39ceadc8b38ac3009f3df66f44ad2",
        "dataset_index": 250
      },
      "sky130_fd_sc_hd__lpflow_inputiso1n_8357da96": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__lpflow_inputiso1n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire SLEEP;\n\n    not not0 (SLEEP , SLEEP_B        );\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__lpflow_inputiso1n",
        "module_hash": "8357da9654609d843855457321196575",
        "dataset_index": 22702
      },
      "mux_2_to_1_en_df1c290b": {
        "rtl_code": "module mux_2_to_1_en(\n  input a,\n  input b,\n  input en,\n  output out\n);\n\n  assign out = en ? b : a;\n\nendmodule",
        "module_name": "mux_2_to_1_en",
        "module_hash": "df1c290b829f1d15b938dbcf1d24f699",
        "dataset_index": 21031
      },
      "digital_circuit_d346cda3": {
        "rtl_code": "\nmodule digital_circuit (\n    input input_1,\n    input input_2,    \n    input input_3,    \n    input input_4,    \n    output output_1,    \n    output output_2    \n);\n\n    // Implement output_1 as the AND of input_1 and input_2\n    assign output_1 = input_1 & input_2;\n    \n    // Implement output_2 as the OR of input_3 and input_4\n    assign output_2 = input_3 | input_4;\n    \nendmodule\n",
        "module_name": "digital_circuit",
        "module_hash": "d346cda38458ad26e9742b51a2ce1839",
        "dataset_index": 18697
      },
      "opc6cpu_e29e6186": {
        "rtl_code": "module opc6cpu(input[15:0] din,input clk,input reset_b,input[1:0] int_b,input clken,output vpa,output vda,output vio,output[15:0] dout,output[15:0] address,output rnw);\n    parameter MOV=5'h0,AND=5'h1,OR=5'h2,XOR=5'h3,ADD=5'h4,ADC=5'h5,STO=5'h6,LD=5'h7,ROR=5'h8,JSR=5'h9,SUB=5'hA,SBC=5'hB,INC=5'hC,LSR=5'hD,DEC=5'hE,ASR=5'hF;\n    parameter HLT=5'h10,BSWP=5'h11,PPSR=5'h12,GPSR=5'h13,RTI=5'h14,NOT=5'h15,OUT=5'h16,IN=5'h17,PUSH=5'h18,POP=5'h19,CMP=5'h1A,CMPC=5'h1B;    \n    parameter FET0=3'h0,FET1=3'h1,EAD=3'h2,RDM=3'h3,EXEC=3'h4,WRM=3'h5,INT=3'h6;\n    parameter EI=3,S=2,C=1,Z=0,P0=15,P1=14,P2=13,IRLEN=12,IRLD=16,IRSTO=17,IRNPRED=18,IRWBK=19,INT_VECTOR0=16'h0002,INT_VECTOR1=16'h0004;\n    reg [15:0] OR_q,PC_q,PCI_q,result;\n    reg [19:0] IR_q; \n    reg [15:0] RF_q[15:0];\n    reg [2:0]  FSM_q;\n    reg [3:0]  swiid,PSRI_q;\n    reg [7:0]  PSR_q ;\n    reg        zero,carry,sign,enable_int,reset_s0_b,reset_s1_b,pred_q;\n    wire [4:0]  op            = {IR_q[IRNPRED],IR_q[11:8]};\n    wire [4:0]  op_d          = { (din[15:13]==3'b001),din[11:8] };\n    wire        pred_d        = (din[15:13]==3'b001) || (din[P2] ^ (din[P1] ? (din[P0] ? sign : zero): (din[P0] ? carry : 1))); wire        pred_din      = (din[15:13]==3'b001) || (din[P2] ^ (din[P1]?(din[P0]?PSR_q[S]:PSR_q[Z]):(din[P0]?PSR_q[C]:1))); wire [15:0] RF_w_p2       = (IR_q[7:4]==4'hF) ? PC_q: {16{(IR_q[7:4]!=4'h0)}} & RF_q[IR_q[7:4]];                          wire [15:0] RF_dout       = (IR_q[3:0]==4'hF) ? PC_q: {16{(IR_q[3:0]!=4'h0)}} & RF_q[IR_q[3:0]];                          wire [15:0] operand       = (IR_q[IRLEN]||IR_q[IRLD]||(op==INC)||(op==DEC)||(IR_q[IRWBK]))?OR_q:RF_w_p2;     assign {rnw,dout,address} = {!(FSM_q==WRM), RF_w_p2,(FSM_q==WRM||FSM_q==RDM)? ((op==POP)? RF_dout: OR_q)  : PC_q};\n    assign {vpa,vda,vio}      = {((FSM_q==FET0)||(FSM_q==FET1)||(FSM_q==EXEC)),({2{(FSM_q==RDM)||(FSM_q==WRM)}} & {!((op==IN)||(op==OUT)),(op==IN)||(op==OUT)})};\n    always @( * ) begin\n        case (op)\n            AND,OR               :{carry,result} = {PSR_q[C],(IR_q[8])?(RF_dout & operand):(RF_dout | operand)};\n            ADD,ADC,INC          :{carry,result} = RF_dout + operand + (IR_q[8] & PSR_q[C]);\n            SUB,SBC,CMP,CMPC,DEC :{carry,result} = RF_dout + (operand ^ 16'hFFFF) + ((IR_q[8])?PSR_q[C]:1);\n            XOR,GPSR             :{carry,result} = (IR_q[IRNPRED])?{PSR_q[C],8'b0,PSR_q}:{PSR_q[C],RF_dout ^ operand};\n            NOT,BSWP             :{result,carry} = (IR_q[10])? {~operand,PSR_q[C]} : {operand[7:0],operand[15:8],PSR_q[C]};\n            ROR,ASR,LSR          :{result,carry} = {(IR_q[10]==0)?PSR_q[C]:(IR_q[8]==1)?operand[15]:1'b0,operand};\n            default              :{carry,result} = {PSR_q[C],operand} ; endcase {swiid,enable_int,sign,carry,zero} = (op==PPSR)?operand[7:0]:(IR_q[3:0]!=4'hF)?{PSR_q[7:3],result[15],carry,!(|result)}:PSR_q;\n    end always @(posedge clk)\n        if (clken) begin\n            {reset_s0_b,reset_s1_b,pred_q} <= {reset_b,reset_s0_b,(FSM_q==FET0)?pred_din:pred_d};\n            if (!reset_s1_b)\n                {PC_q,PCI_q,PSRI_q,PSR_q,FSM_q} <= 0;\n            else begin\n                case (FSM_q)\n                    FET0   : FSM_q <= (din[IRLEN]) ? FET1 : (!pred_din) ? FET0 : ((din[11:8]==LD)||(din[11:8]==STO)||(op_d==PUSH)||(op_d==POP)) ? EAD : EXEC;\n                    FET1   : FSM_q <= (!pred_q )? FET0: ((IR_q[3:0]!=0) || (IR_q[IRLD])||IR_q[IRSTO])?EAD:EXEC;\n                    EAD    : FSM_q <= (IR_q[IRLD]) ? RDM : (IR_q[IRSTO]) ? WRM : EXEC;\n                    EXEC   : FSM_q <= ((!(&int_b) & PSR_q[EI])||((op==PPSR) && (|swiid)))?INT:((IR_q[3:0]==4'hF)||(op==JSR))?FET0:\n                                      (din[IRLEN]) ? FET1 : ((din[11:8]==LD)||(din[11:8]==STO)||(op_d==POP)||(op_d==PUSH))?EAD:(pred_d)?EXEC:FET0;\n                    WRM    : FSM_q <= (!(&int_b) & PSR_q[EI])?INT:FET0;\n                    default: FSM_q <= (FSM_q==RDM)? EXEC : FET0;  endcase \n                OR_q <= ((FSM_q==FET0)||(FSM_q==EXEC))?({16{op_d==PUSH}}^({12'b0,(op_d==DEC)||(op_d==INC)?din[7:4]:{3'b0,(op_d==POP)}})):(FSM_q==EAD)?RF_w_p2+OR_q:din;\n                if ( FSM_q == INT )\n                    {PC_q,PCI_q,PSRI_q,PSR_q[EI]} <= {(!int_b[1])?INT_VECTOR1:INT_VECTOR0,PC_q,PSR_q[3:0],1'b0} ; else if ((FSM_q==FET0)||(FSM_q==FET1)) \n                    PC_q  <= PC_q + 1;\n                else if ( FSM_q == EXEC) begin\n                    PC_q <= (op==RTI)?PCI_q: ((IR_q[3:0]==4'hF)||(op==JSR))?result:(((!(&int_b)) && PSR_q[EI])||((op==PPSR)&&(|swiid)))?PC_q:PC_q + 1;\n                    PSR_q <= (op==RTI)?{4'b0,PSRI_q}:{swiid,enable_int,sign,carry,zero}; end\n                if (((FSM_q==EXEC) && !((op==CMP)||(op==CMPC)))|| (((FSM_q==WRM)||(FSM_q==RDM)) && IR_q[IRWBK]))\n                    RF_q[IR_q[3:0]] <= (op==JSR)? PC_q : result ;\n                if ((FSM_q==FET0)||(FSM_q==EXEC))\n                    IR_q <= {(op_d==PUSH)||(op_d==POP),(din[15:13]==3'b001),(din[11:8]==STO)||(op_d==PUSH),(din[11:8]==LD)||(op_d==POP),din};\n                else if (((FSM_q==EAD && (IR_q[IRLD]||IR_q[IRSTO]))||(FSM_q==RDM)))\n                  IR_q[7:0] <= {IR_q[3:0],IR_q[7:4]}; end \n        end\nendmodule\n",
        "module_name": "opc6cpu",
        "module_hash": "e29e618631c4c628c886e0551eae73e8",
        "dataset_index": 23945
      },
      "pll_lock_lookup_61d04cc7": {
        "rtl_code": "\nmodule pll_lock_lookup(\n    input clk,\n    input [6:0] divider,\n    output reg [39:0] value\n    );\n     reg [39:0] lookup [0:64];\n    wire [5:0] addr;\n   initial\n   begin\n            lookup[00]=40'b00110_00110_1111101000_1111101001_0000000001;\n            lookup[01]=40'b00110_00110_1111101000_1111101001_0000000001;\n            lookup[02]=40'b01000_01000_1111101000_1111101001_0000000001;\n            lookup[03]=40'b01011_01011_1111101000_1111101001_0000000001;\n            lookup[04]=40'b01110_01110_1111101000_1111101001_0000000001;\n            lookup[05]=40'b10001_10001_1111101000_1111101001_0000000001;\n            lookup[06]=40'b10011_10011_1111101000_1111101001_0000000001;\n            lookup[07]=40'b10110_10110_1111101000_1111101001_0000000001;\n            lookup[08]=40'b11001_11001_1111101000_1111101001_0000000001;\n            lookup[09]=40'b11100_11100_1111101000_1111101001_0000000001;\n            lookup[10]=40'b11111_11111_1110000100_1111101001_0000000001;\n            lookup[11]=40'b11111_11111_1100111001_1111101001_0000000001;\n            lookup[12]=40'b11111_11111_1011101110_1111101001_0000000001;\n            lookup[13]=40'b11111_11111_1010111100_1111101001_0000000001;\n            lookup[14]=40'b11111_11111_1010001010_1111101001_0000000001;\n            lookup[15]=40'b11111_11111_1001110001_1111101001_0000000001;\n            lookup[16]=40'b11111_11111_1000111111_1111101001_0000000001;\n            lookup[17]=40'b11111_11111_1000100110_1111101001_0000000001;\n            lookup[18]=40'b11111_11111_1000001101_1111101001_0000000001;\n            lookup[19]=40'b11111_11111_0111110100_1111101001_0000000001;\n            lookup[20]=40'b11111_11111_0111011011_1111101001_0000000001;\n            lookup[21]=40'b11111_11111_0111000010_1111101001_0000000001;\n            lookup[22]=40'b11111_11111_0110101001_1111101001_0000000001;\n            lookup[23]=40'b11111_11111_0110010000_1111101001_0000000001;\n            lookup[24]=40'b11111_11111_0110010000_1111101001_0000000001;\n            lookup[25]=40'b11111_11111_0101110111_1111101001_0000000001;\n            lookup[26]=40'b11111_11111_0101011110_1111101001_0000000001;\n            lookup[27]=40'b11111_11111_0101011110_1111101001_0000000001;\n            lookup[28]=40'b11111_11111_0101000101_1111101001_0000000001;\n            lookup[29]=40'b11111_11111_0101000101_1111101001_0000000001;\n            lookup[30]=40'b11111_11111_0100101100_1111101001_0000000001;\n            lookup[31]=40'b11111_11111_0100101100_1111101001_0000000001;\n            lookup[32]=40'b11111_11111_0100101100_1111101001_0000000001;\n            lookup[33]=40'b11111_11111_0100010011_1111101001_0000000001;\n            lookup[34]=40'b11111_11111_0100010011_1111101001_0000000001;\n            lookup[35]=40'b11111_11111_0100010011_1111101001_0000000001;\n            lookup[36]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[37]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[38]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[39]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[40]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[41]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[42]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[43]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[44]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[45]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[46]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[47]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[48]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[49]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[50]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[51]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[52]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[53]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[54]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[55]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[56]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[57]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[58]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[59]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[60]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[6]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[00]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[00]=40'b11111_11111_0011111010_1111101001_0000000001;\n   end\n   \n   assign addr = divider - 1;\n   always @(posedge clk)\n   begin\n       value = lookup[addr];\n   end \n\nendmodule\n",
        "module_name": "pll_lock_lookup",
        "module_hash": "61d04cc77942767783d13d46f5941a78",
        "dataset_index": 6231
      },
      "intern_sync_604f1288": {
        "rtl_code": "\n\nmodule intern_sync\n(\n\tinput       clk       ,\n\tinput       rstn      ,\n\n\tinput       rc_is_idle,\n\n\tinput       rc_reqn,\n\toutput reg  rc_ackn\n);\n\n\n\treg [1:0] state_c, state_n;\n\nlocalparam [1:0]\n\t\tRC_Idle    = 4'd0,\n\t\tRC_ReqAck  = 4'd1;\n\n\talways @(posedge clk or negedge rstn) begin\n\t\tif (~rstn)\n\t\t\tstate_c <= RC_Idle;\n\t\telse\n\t\t\tstate_c <= state_n;\n\tend\n\n\talways @(*) begin\n\t\t{rc_ackn} = {1'b1};\n\n\t\t\n\t\tcase (state_c)\n\t\t\tRC_Idle: begin state_n = (~rc_reqn)? RC_ReqAck:RC_Idle; end\n\t\t\tRC_ReqAck:begin\n\t\t\t\tif(rc_is_idle) begin\n\t\t\t\t\tstate_n = RC_Idle;\n\t\t\t\t\trc_ackn = 1'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_n = RC_ReqAck;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin state_n = RC_Idle; end\n\t\tendcase\n\tend\n\nendmodule\n\n\n",
        "module_name": "intern_sync",
        "module_hash": "604f1288902da46fea4077a917f1df88",
        "dataset_index": 25650
      },
      "address_counter #_79965bf6": {
        "rtl_code": "\n\nmodule address_counter #\n(\n  parameter integer COUNT_WIDTH = 13\n)\n(\n  input  wire clken, input  wire trig, input  wire clk,\n  output wire [31:0] address,\n  output wire [3:0] wen );\n\n  localparam count_max = (1 << COUNT_WIDTH) - 1;\n  reg trig_reg;\n  reg trig_detected;\n\n  reg wen_reg;\n\n  reg [COUNT_WIDTH-1:0] count;\n\n  initial count = 0;\n  initial trig_detected = 0;\n  initial wen_reg = 0;\n\n  always @(posedge clk) begin\n    trig_reg <= trig;\n    if (trig & ~trig_reg) begin\n        trig_detected <= 1;\n    end else if (count == count_max) begin\n        trig_detected <= 0;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (clken) begin\n      count <= count + 1;\n      if (count == count_max) begin\n        wen_reg <= trig_detected;\n      end\n    end\n  end\n\n  assign address = count << 2;\n  assign wen = {4{wen_reg}};\n\nendmodule\n",
        "module_name": "address_counter #",
        "module_hash": "79965bf6a0a8dce2896c3071a44fdf02",
        "dataset_index": 25293
      },
      "shift_register_34c5888e": {
        "rtl_code": "module shift_register(clk, rst, load, shift_left, shift_right, serial_in, shift_reg);\n\tinput clk, rst, load, shift_left, shift_right, serial_in;\n\toutput reg [3:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (rst) begin\n\t\t\tshift_reg <= 0;\n\t\tend else if (load) begin\n\t\t\tshift_reg <= serial_in;\n\t\tend else if (shift_left) begin\n\t\t\tshift_reg <= {shift_reg[2:0], shift_reg[3]};\n\t\tend else if (shift_right) begin\n\t\t\tshift_reg <= {shift_reg[1], shift_reg[3:1]};\n\t\tend\n\tend\nendmodule",
        "module_name": "shift_register",
        "module_hash": "34c5888e9539593aa5915804bf7c2ce3",
        "dataset_index": 11014
      },
      "sky130_fd_sc_ls__nand3_246fff1f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__nand3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A, C        );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__nand3",
        "module_hash": "246fff1ff78aff3b94850f3fd1ea6533",
        "dataset_index": 20886
      },
      "servo_control_0f64a51b": {
        "rtl_code": "module servo_control (\n  input clk,\n  input rst,\n  input [15:0] pwm_in,\n  output reg [15:0] pwm_out\n);\n\nparameter min_pulse_width = 1000; // in microseconds\nparameter max_pulse_width = 2000; // in microseconds\nparameter frequency = 50; // in Hz\nparameter resolution = 16; // in bits\n\nreg [15:0] counter = 0;\nreg [15:0] threshold = 0;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    pwm_out <= min_pulse_width;\n    counter <= 0;\n    threshold <= 0;\n  end else begin\n    counter <= counter + 1;\n    if (counter == resolution) begin\n      counter <= 0;\n      threshold <= pwm_in;\n    end\n    if (threshold > counter) begin\n      pwm_out <= max_pulse_width;\n    end else begin\n      pwm_out <= min_pulse_width;\n    end\n  end\nend\n\nendmodule",
        "module_name": "servo_control",
        "module_hash": "0f64a51b08eccc283cc02495d4d981a7",
        "dataset_index": 288
      },
      "alu_min_c730b6bf": {
        "rtl_code": "\nmodule alu_min( RST, CLK, ENA, RGA, RGB, RGZ, KEY, OPT);\n\tinput RST, CLK, ENA;\n\tinput [7:0]OPT,RGA,RGB;\n\toutput [7:0]RGZ;\n\tinput [1:0]KEY;\n\treg [7:0]RGZ;\n\n\talways@(posedge CLK)begin\n\t\tif(RST) RGZ = 0;\n\t\telse begin\n\t\tcase(OPT)\n\t\t\t8'b00000001: RGZ = 0; \n\t\t\t8'b00000010: RGZ = RGA + RGB;\n\t\t\t8'b00000011: RGZ = RGA - RGB;\n\t\t\t8'b00000011: RGZ = RGA^RGB;\n\t\t\t8'b00000100: RGZ = RGA&RGB;\n\t\t\t8'b00000101: RGZ = RGA|RGB;\n\t\t\t8'b00000110: RGZ = RGA&&RGB;\n\t\t\t8'b00000111: RGZ = RGA||RGB;\n\n\t\t\t8'b00001000: RGZ = RGA+1;\n\t\t\t8'b00001001: RGZ = RGA-1;\n\t\t\t8'b00001010: RGZ = RGA<<1;\n\t\t\t8'b00001011: RGZ = RGA>>1;\n\t\t\t8'b00001100: RGZ = !RGA;\n\t\t\t8'b00001101: RGZ = ~RGA;\n\t\t\t8'b00001110: RGZ = RGA+RGA;\n\t\t\t8'b00001111: RGZ = RGA-RGA;\n\n\t\t\t8'b00010000: RGZ = RGB+RGZ;\n\t\t\t8'b00010001: RGZ = RGB-RGZ;\n\t\t\t\n\t\t\t8'b00010011: RGZ = RGB^RGZ;\n\t\t\t8'b00010100: RGZ = RGB&RGZ;\n\t\t\t8'b00010101: RGZ = RGB|RGZ;\n\t\t\t8'b00010110: RGZ = RGB&&RGZ;\n\t\t\t8'b00010111: RGZ = RGB||RGZ;\n\n\t\t\t8'b00111000: RGZ = RGZ+1;\n\t\t\t8'b00111001: RGZ = RGZ-1;\n\t\t\t8'b00111010: RGZ = RGZ<<1;\n\t\t\t8'b00111011: RGZ = RGZ>>1;\n\t\t\t8'b00111100: RGZ = !RGZ;\n\t\t\t8'b00111101: RGZ = ~RGZ;\n\t\t\t8'b00111110: RGZ = RGB+RGZ;\n\t\t\t8'b00111111: RGZ = RGB-RGZ;\n\n\t\t\t8'b00100000: RGZ = RGA+RGB;\n\t\t\t8'b00100001: RGZ = RGA-RGB;\n\t\t\t\n\t\t\t8'b00100011: RGZ = RGA^RGB;\n\t\t\t8'b00100100: RGZ = RGA&RGB;\n\t\t\t8'b00100101: RGZ = RGA|RGB;\n\t\t\t8'b00100110: RGZ = RGA&&RGB;\n\t\t\t8'b00100111: RGZ = RGA||RGB;\n\n\t\t\t8'b00101000: RGZ = RGA+1;\n\t\t\t8'b00101001: RGZ = RGA-1;\n\t\t\t8'b00101010: RGZ = RGA<<1;\n\t\t\t8'b00101011: RGZ = RGA>>1;\n\t\t\t8'b00101100: RGZ = !RGA;\n\t\t\t8'b00101101: RGZ = ~RGA;\n\t\t\t8'b00101110: RGZ = RGA+RGA;\n\t\t\t8'b00101111: RGZ = RGA-RGA;\n\n\t\t\t8'b00110000: RGZ = RGZ+RGA;\n\t\t\t8'b00110001: RGZ = RGZ-RGA;\n\t\t\t\n\t\t\t8'b00111000: RGZ = RGZ+1;\n\t\t\t8'b00111001: RGZ = RGZ-1;\n\t\t\t8'b00111010: RGZ = RGZ<<1;\n\t\t\t8'b00111011: RGZ = RGZ>>1;\n\t\t\t8'b00111100: RGZ = !RGZ;\n\t\t\t8'b00111101: RGZ = ~RGZ;\n\t\t\t8'b00111110: RGZ = RGZ+RGB;\n\t\t\t8'b00111111: RGZ = RGZ-RGB;\n\t\t\t8'b01000000: RGZ=RGA+RGB;\n\t\t\t8'b01000001: RGZ=RGA-RGB;\n\t\t\t8'b01000010: RGZ=RGB-1;\n\n\t\t\t8'b01000100: RGZ=RGA&&RGB;\n\t\t\t8'b01000101: RGZ=RGA||RGB;\n\t\t\t8'b01000110: RGZ=!RGA;\n\t\t\t8'b01000111: RGZ=~RGA;\n\n\t\t\t8'b01001000: RGZ=RGA&RGB;\n\t\t\t8'b01001001: RGZ=RGA|RGB;\n\t\t\t8'b01001010: RGZ=RGA^RGB;\n\t\t\t8'b01001011: RGZ=RGA<<1;\n\t\t\t8'b01001100: RGZ=RGA>>1;\n\t\t\t8'b01001101: RGZ=RGA+1;\n\t\t\t8'b01001110: RGZ=RGA-1;\n\t\t\t8'b01001111: RGZ=RGA-1;\n\n\t\t\t8'b01010000: RGZ=RGA+RGB;\n\t\t\t8'b01010001: RGZ=RGA-RGB;\n\t\t\t8'b01010010: RGZ=RGB-1;\n\t\t\t8'b01010011: RGZ=RGA*RGB;\n\t\t\t8'b01010100: RGZ=RGA&&RGB;\n\t\t\t8'b01010101: RGZ=RGA||RGB;\n\t\t\t8'b01010110: RGZ=!RGA;\n\t\t\t8'b01010111: RGZ=~RGA;\n\n\t\t\t8'b01011000: RGZ=RGA&RGB;\n\t\t\t8'b01011001: RGZ=RGA|RGB;\n\t\t\t8'b01011010: RGZ=RGA^RGB;\n\t\t\t8'b01011011: RGZ=RGA<<1;\n\t\t\t8'b01011100: RGZ=RGA>>1;\n\t\t\t8'b01011101: RGZ=RGA+1;\n\t\t\t8'b01011110: RGZ=RGA-1;\n\t\t\t8'b01011111: RGZ=RGA-1;\n\n\t\t\t8'b01100000: RGZ=RGA+RGB;\n\t\t\t8'b01100001: RGZ=RGA-RGB;\n\t\t\t8'b01100010: RGZ=RGB-1;\n\t\t\t\n\t\t\t8'b01100100: RGZ=RGA&&RGB;\n\t\t\t8'b01100101: RGZ=RGA||RGB;\n\t\t\t8'b01100110: RGZ=!RGA;\n\t\t\t8'b01100111: RGZ=~RGA;\n\n\t\t\t8'b01101000: RGZ=RGA&RGB;\n\t\t\t8'b01101001: RGZ=RGA|RGB;\n\t\t\t8'b01101010: RGZ=RGA^RGB;\n\t\t\t8'b01101011: RGZ=RGA<<1;\n\t\t\t8'b01101100: RGZ=RGA>>1;\n\t\t\t8'b01101101: RGZ=RGA+1;\n\t\t\t8'b01101110: RGZ=RGA-1;\n\t\t\t8'b01101111: RGZ=RGA-1;\n\n\t\t\t8'b01110000: RGZ=RGA+RGB;\n\t\t\t8'b01110001: RGZ=RGA-RGB;\n\t\t\t8'b01110010: RGZ=RGB-1;\n\t\t\t8'b01110011: RGZ=RGA*RGB;\n\t\t\t8'b01110100: RGZ=RGA&&RGB;\n\t\t\t8'b01110101: RGZ=RGA||RGB;\n\t\t\t8'b01110110: RGZ=!RGA;\n\t\t\t8'b01110111: RGZ=~RGA;\n\n\t\t\t8'b01111000: RGZ=RGA&RGB;\n\t\t\t8'b01111001: RGZ=RGA|RGB;\n\t\t\t8'b01111010: RGZ=RGA^RGB;\n\t\t\t8'b01111011: RGZ=RGA<<1;\n\t\t\t8'b01111100: RGZ=RGA>>1;\n\t\t\t8'b01111101: RGZ=RGA+1;\n\t\t\t8'b01111110: RGZ=RGA-1;\n\t\t\t8'b01111111: RGZ=RGA-1;\n\n\t\t\t8'b10000000: RGZ=RGA+RGB;\n\t\t\t8'b10000001: RGZ=RGA-RGB;\n\t\t\t8'b10000010: RGZ=RGB-1;\n\t\t\t\n\t\t\t8'b10000100: RGZ=RGA&&RGB;\n\t\t\t8'b10000101: RGZ=RGA||RGB;\n\t\t\t8'b10000110: RGZ=!RGA;\n\t\t\t8'b10000111: RGZ=~RGA;\n\n\t\t\t8'b10001000: RGZ=RGA&RGB;\n\t\t\t8'b10001001: RGZ=RGA|RGB;\n\t\t\t8'b10001010: RGZ=RGA^RGB;\n\t\t\t8'b10001011: RGZ=RGA<<1;\n\t\t\t8'b10001100: RGZ=RGA>>1;\n\t\t\t8'b10001101: RGZ=RGA+1;\n\t\t\t8'b10001110: RGZ=RGA-1;\n\t\t\t8'b10001111: RGZ=RGA-1;\n\n\t\t\t8'b10010000: RGZ=RGA+RGB;\n\t\t\t8'b10010001: RGZ=RGA-RGB;\n\t\t\t8'b10010010: RGZ=RGB-1;\n\n\t\t\t8'b10010100: RGZ=RGA&&RGB;\n\t\t\t8'b10010101: RGZ=RGA||RGB;\n\t\t\t8'b10010110: RGZ=!RGA;\n\t\t\t8'b10010111: RGZ=~RGA;\n\n\t\t\t8'b10011000: RGZ=RGA&RGB;\n\t\t\t8'b10011001: RGZ=RGA|RGB;\n\t\t\t8'b10011010: RGZ=RGA^RGB;\n\t\t\t8'b10011011: RGZ=RGA<<1;\n\t\t\t8'b10011100: RGZ=RGA>>1;\n\t\t\t8'b10011101: RGZ=RGA+1;\n\t\t\t8'b10011110: RGZ=RGA-1;\n\t\t\t8'b10011111: RGZ=RGA-1;\n\n\t\t\t8'b10100000: RGZ=RGA+RGB;\n\t\t\t8'b10100001: RGZ=RGA-RGB;\n\t\t\t8'b10100010: RGZ=RGB-1;\n\t\t\t8'b10100011: RGZ=RGA*RGB;\n\t\t\t8'b10100100: RGZ=RGA&&RGB;\n\t\t\t8'b10100101: RGZ=RGA||RGB;\n\t\t\t8'b10100110: RGZ=!RGA;\n\t\t\t8'b10100111: RGZ=~RGA;\n\n\t\t\t8'b10101000: RGZ=RGA&RGB;\n\t\t\t8'b10101001: RGZ=RGA|RGB;\n\t\t\t8'b10101010: RGZ=RGA^RGB;\n\t\t\t8'b10101011: RGZ=RGA<<1;\n\t\t\t8'b10101100: RGZ=RGA>>1;\n\t\t\t8'b10101101: RGZ=RGA+1;\n\t\t\t8'b10101110: RGZ=RGA-1;\n\t\t\t8'b10101111: RGZ=RGA-1;\n\n\t\t\t8'b10110000: RGZ=RGA+RGB;\n\t\t\t8'b10110001: RGZ=RGA-RGB;\n\t\t\t8'b10110010: RGZ=RGB-1;\n\t\t\t8'b10110011: RGZ=RGA*RGB;\n\t\t\t8'b10110100: RGZ=RGA&&RGB;\n\t\t\t8'b10110101: RGZ=RGA||RGB;\n\t\t\t8'b10110110: RGZ=!RGA;\n\t\t\t8'b10110111: RGZ=~RGA;\n\n\t\t\t8'b10111000: RGZ=RGA&RGB;\n\t\t\t8'b10111001: RGZ=RGA|RGB;\n\t\t\t8'b10111010: RGZ=RGA^RGB;\n\t\t\t8'b10111011: RGZ=RGA<<1;\n\t\t\t8'b10111100: RGZ=RGA>>1;\n\t\t\t8'b10111101: RGZ=RGA+1;\n\t\t\t8'b10111110: RGZ=RGA-1;\n\t\t\t8'b10111111: RGZ=RGA-1;\n\n\t\t\t8'b11000000: RGZ=RGA+RGB;\n\t\t\t8'b11000001: RGZ=RGA-RGB;\n\t\t\t8'b11000010: RGZ=RGB-1;\n\t\t\t8'b11000011: RGZ=RGA*RGB;\n\t\t\t8'b11000100: RGZ=RGA&&RGB;\n\t\t\t8'b11000101: RGZ=RGA||RGB;\n\t\t\t8'b11000110: RGZ=!RGA;\n\t\t\t8'b11000111: RGZ=~RGA;\n\n\t\t\t8'b11001000: RGZ=RGA&RGB;\n\t\t\t8'b11001001: RGZ=RGA|RGB;\n\t\t\t8'b11001010: RGZ=RGA^RGB;\n\t\t\t8'b11001011: RGZ=RGA<<1;\n\t\t\t8'b11001100: RGZ=RGA>>1;\n\t\t\t8'b11001101: RGZ=RGA+1;\n\t\t\t8'b11001110: RGZ=RGA-1;\n\t\t\t8'b11001111: RGZ=RGA-1;\n\n\t\t\t8'b11010000: RGZ=RGA+RGB;\n\t\t\t8'b11010001: RGZ=RGA-RGB;\n\t\t\t8'b11010010: RGZ=RGB-1;\n\t\t\t8'b11010011: RGZ=RGA*RGB;\n\t\t\t8'b11010100: RGZ=RGA&&RGB;\n\t\t\t8'b11010101: RGZ=RGA||RGB;\n\t\t\t8'b11010110: RGZ=!RGA;\n\t\t\t8'b11010111: RGZ=~RGA;\n\n\t\t\t8'b11011000: RGZ=RGA&RGB;\n\t\t\t8'b11011001: RGZ=RGA|RGB;\n\t\t\t8'b11011010: RGZ=RGA^RGB;\n\t\t\t8'b11011011: RGZ=RGA<<1;\n\t\t\t8'b11011100: RGZ=RGA>>1;\n\t\t\t8'b11011101: RGZ=RGA+1;\n\t\t\t8'b11011110: RGZ=RGA-1;\n\t\t\t8'b11011111: RGZ=RGA-1;\n\n\t\t\t8'b11100000: RGZ=RGA+RGB;\n\t\t\t8'b11100001: RGZ=RGA-RGB;\n\t\t\t8'b11100010: RGZ=RGB-1;\n\t\t\t8'b11100011: RGZ=RGA*RGB;\n\t\t\t8'b11100100: RGZ=RGA&&RGB;\n\t\t\t8'b11100101: RGZ=RGA||RGB;\n\t\t\t8'b11100110: RGZ=!RGA;\n\t\t\t8'b11100111: RGZ=~RGA;\n\n\t\t\t8'b11101000: RGZ=RGA&RGB;\n\t\t\t8'b11101001: RGZ=RGA|RGB;\n\t\t\t8'b11101010: RGZ=RGA^RGB;\n\t\t\t8'b11101011: RGZ=RGA<<1;\n\t\t\t8'b11101100: RGZ=RGA>>1;\n\t\t\t8'b11101101: RGZ=RGA+1;\n\t\t\t8'b11101110: RGZ=RGA-1;\n\t\t\t8'b11101111: RGZ=RGA-1;\n\n\t\t\t8'b11110000: RGZ=RGA+RGB;\n\t\t\t8'b11110001: RGZ=RGA-RGB;\n\t\t\t8'b11110010: RGZ=RGB-1;\n\t\t\t8'b11110011: RGZ=RGA*RGB;\n\t\t\t8'b11110100: RGZ=RGA&&RGB;\n\t\t\t8'b11110101: RGZ=RGA||RGB;\n\t\t\t8'b11110110: RGZ=!RGA;\n\t\t\t8'b11110111: RGZ=~RGA;\n\n\t\t\t8'b11111000: RGZ=RGA&RGB;\n\t\t\t8'b11111001: RGZ=RGA|RGB;\n\t\t\t8'b11111010: RGZ=RGA^RGB;\n\t\t\t8'b11111011: RGZ=RGA<<1;\n\t\t\t8'b11111100: RGZ=RGA>>1;\n\t\t\t8'b11111101: RGZ=RGA+1;\n\t\t\t8'b11111110: RGZ=RGA-1;\n\t\t\t8'b11111111: RGZ=RGA-1;\n\t\tendcase\n\t\tend\n\tend\nendmodule\n",
        "module_name": "alu_min",
        "module_hash": "c730b6bf94d9cc4002853dc9148aeb17",
        "dataset_index": 8816
      },
      "AdlerChecksum #_a2386f97": {
        "rtl_code": "module AdlerChecksum #(\n  parameter n = 16 // number of input bytes\n)(\n  input [n*8-1:0] in,\n  input [15:0] check,\n  output reg error,\n  output reg [15:0] out\n);\n\n\nreg [15:0] A = 1;\nreg [15:0] B = 1;\n\ninteger i;\n\nalways @(*) begin\n  A = 1;\n  B = 1;\n  for (i = 0; i < n; i = i + 1) begin\n    A = (A + in[i*8 +: 8]) % 65521;\n    B = (B + A) % 65521;\n  end\n  out = (B << 16) | A;\nend\n\nalways @(*) begin\n  error = (out == check) ? 0 : 1;\nend\n\nendmodule",
        "module_name": "AdlerChecksum #",
        "module_hash": "a2386f97ac0a7d3f728e4b5ca95630c9",
        "dataset_index": 20712
      },
      "four_bit_adder_4151a2d7": {
        "rtl_code": "module four_bit_adder(a, b, sum, carry_out);\n  \n  input [3:0] a;\n  input [3:0] b;\n  output [3:0] sum;\n  output carry_out;\n\n  assign {carry_out, sum} = a + b;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "4151a2d7a6a8140cc1787b596c0d1882",
        "dataset_index": 7436
      },
      "afifo_sram #_1b583428": {
        "rtl_code": "\nmodule afifo_sram #(\n    parameter DEPTH =256,\n    parameter ADDRESS_WIDTH = 8, \n    parameter WIDTH=8\n)(\n    input CLK,\n    input REN,\n    input WEN,\n    input RESET,\n    input valid_in,\n    input [WIDTH-1:0] Data_in,\n    output [WIDTH-1:0] Data_out,\n    output Full_out,\n    output Empty_out\n);\n\n\nreg [ADDRESS_WIDTH-1:0] read_ptr;\nreg [ADDRESS_WIDTH-1:0] write_ptr;\nwire [ADDRESS_WIDTH-1:0] next_write_ptr;\nwire [ADDRESS_WIDTH-1:0] next_read_ptr;\nwire [ADDRESS_WIDTH-1:0] mem_addr;\nreg [WIDTH-1:0] mem [DEPTH-1:0];\n\nassign mem_addr = REN ? read_ptr : write_ptr;\nassign Data_out = mem[mem_addr];\n\nassign Full_out = (next_write_ptr == read_ptr) & (REN==1'b0);\nassign Empty_out = (write_ptr == read_ptr) & (WEN==1'b0);\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        read_ptr <= 0;\n        write_ptr <= 0;\n    end else begin\n        if (WEN && !Full_out) begin\n            mem[write_ptr] <= Data_in;\n            write_ptr <= next_write_ptr;\n        end\n        if (REN && !Empty_out && valid_in) begin\n            read_ptr <= next_read_ptr;\n        end\n    end\nend\n\nassign next_write_ptr = (write_ptr == DEPTH-1) ? 0 : write_ptr + 1;\nassign next_read_ptr = (read_ptr == DEPTH-1) ? 0 : read_ptr + 1;\n\nendmodule",
        "module_name": "afifo_sram #",
        "module_hash": "1b58342874c7e200bca9a8bb57460b62",
        "dataset_index": 18015
      },
      "encryption_module_432be79e": {
        "rtl_code": "module encryption_module(\n  input aclk,\n  input reset,\n  input [15:0] data_in,\n  output reg [15:0] data_out\n);\n\n  reg [7:0] A;\n  reg [7:0] B;\n  reg [7:0] rotated_A;\n  reg [15:0] result;\n\n  always @(posedge aclk) begin\n    if (reset) begin\n      A <= 8'd0;\n      B <= 8'd0;\n      rotated_A <= 8'd0;\n      result <= 16'd0;\n      data_out <= 16'd0;\n    end else begin\n      A <= data_in[15:8];\n      B <= data_in[7:0];\n\n      rotated_A <= {A[5:0], A[7:6]};\n      result <= rotated_A + B;\n      data_out <= {result[15:8], result[7:0]};\n    end\n  end\n\nendmodule",
        "module_name": "encryption_module",
        "module_hash": "432be79e82d357f976a47b74b81cc445",
        "dataset_index": 12264
      },
      "fourbitmuxcase_6a998ba9": {
        "rtl_code": "module fourbitmuxcase(in, s, out);\n\tinput wire[3: 0] in;\n\tinput wire[1: 0] s;\n\toutput wire out;\n\treg _out;\n\talways @(in or s)\n\t\tcase (s)\n\t\t\t2'b00: _out = in[0];\n\t\t\t2'b01: _out = in[1];\n\t\t\t2'b10: _out = in[2];\n\t\t\t2'b11: _out = in[3];\n\t\t\tdefault: _out = 1'b0;\n\t\tendcase\n\tassign out = _out;\nendmodule",
        "module_name": "fourbitmuxcase",
        "module_hash": "6a998ba9fe69d584db7b37878e791672",
        "dataset_index": 7125
      },
      "acc_e87633a5": {
        "rtl_code": "module acc (input clock, input reset, input clear, input enable_in, output reg enable_out,\n            input signed [30:0] addend, output reg signed [33:0] sum );\n\n   always @(posedge clock)\n     if(reset)\n       sum <= #1 34'd0;\n     else if(clear)\n       sum <= #1 addend;\n     else if(enable_in)\n       sum <= #1 sum + addend;\n\n   always @(posedge clock)\n     enable_out <= #1 enable_in;\n   \nendmodule",
        "module_name": "acc",
        "module_hash": "e87633a5fa4146b8fda83d46805b094b",
        "dataset_index": 20648
      },
      "CRC_16_d7bbea6e": {
        "rtl_code": "module CRC_16(BITVAL, Enable, CLK, RST, CRC);\n input        BITVAL;input Enable;\n   input        CLK;                           input        RST;                             output reg [15:0] CRC;                               wire         inv;\n   \n   assign inv = BITVAL ^ CRC[15];                   always @(posedge CLK or posedge RST) begin\n\t\tif (RST) begin\n\t\t\tCRC = 0;   \n\t\t\n        end\n      else begin\n        if (Enable==1) begin\n         CRC[15] = CRC[14];\n         CRC[14] = CRC[13];\n         CRC[13] = CRC[12];\n         CRC[12] = CRC[11] ^ inv;\n         CRC[11] = CRC[10];\n         CRC[10] = CRC[9];\n         CRC[9] = CRC[8];\n         CRC[8] = CRC[7];\n         CRC[7] = CRC[6];\n         CRC[6] = CRC[5];\n         CRC[5] = CRC[4] ^ inv;\n         CRC[4] = CRC[3];\n         CRC[3] = CRC[2];\n         CRC[2] = CRC[1];\n         CRC[1] = CRC[0];\n         CRC[0] = inv;\n        end\n         end\n      end\n   \nendmodule\n",
        "module_name": "CRC_16",
        "module_hash": "d7bbea6ebf946337f8510b6b670926ca",
        "dataset_index": 25492
      },
      "SensorFSM #_96c6f568": {
        "rtl_code": "\n\nmodule SensorFSM #(\n  parameter DataWidth = 8\n) (\n  input                        Reset_n_i,\n  input                        Clk_i,\n  input                        Enable_i,\n  output reg                   CpuIntr_o,\n  output     [2*DataWidth-1:0] SensorValueL_o,\n  output     [2*DataWidth-1:0] SensorValueR_o,\n  output reg                   MeasureFSM_QueryLocal_o,\n  output reg                   MeasureFSM_QueryRemote_o,\n  input                        MeasureFSM_Done_i,\n  input                        MeasureFSM_Error_i,\n  input     [DataWidth-1:0]    MeasureFSM_Byte0_i,\n  input     [DataWidth-1:0]    MeasureFSM_Byte1_i,\n  input [2*DataWidth-1:0]      ParamCounterPresetH_i,\n  input [2*DataWidth-1:0]      ParamCounterPresetL_i\n);\n\n  localparam stDisabled    = 3'd0;\n  localparam stIdle        = 3'd1;\n  localparam stQueryLocal  = 3'd2;\n  localparam stWait1       = 3'd3;\n  localparam stQueryRemote = 3'd4;\n  localparam stNotify      = 3'd5;\n  localparam stError       = 3'd6;\n  reg  [2:0]             SensorFSM_State;\n  reg  [2:0]             SensorFSM_NextState;\n  wire                   SensorFSM_TimerOvfl;\n  reg                    SensorFSM_TimerPreset;\n  reg                    SensorFSM_TimerEnable;\n  reg                    SensorFSM_StoreLocal;\n  reg                    SensorFSM_StoreRemote;\n  wire [2*DataWidth-1:0] SensorValue;\n  reg  [2*DataWidth-1:0] WordL;\n  reg  [2*DataWidth-1:0] WordR;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SensorFSM_State <= stDisabled;\n    end\n    else\n    begin\n      SensorFSM_State <= SensorFSM_NextState;\n    end  \n  end\n\n  always @(SensorFSM_State, Enable_i, SensorFSM_TimerOvfl, MeasureFSM_Done_i, MeasureFSM_Error_i)\n  begin  SensorFSM_NextState      = SensorFSM_State;\n    SensorFSM_TimerPreset    = 1'b0;\n    SensorFSM_TimerEnable    = 1'b0;\n    MeasureFSM_QueryLocal_o  = 1'b0;\n    MeasureFSM_QueryRemote_o = 1'b0;\n    SensorFSM_StoreLocal     = 1'b0;\n    SensorFSM_StoreRemote    = 1'b0;\n    CpuIntr_o                = 1'b0;\n    case (SensorFSM_State)\n      stDisabled: begin\n        if (Enable_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stIdle;\n          SensorFSM_TimerPreset   = 1'b1;  SensorFSM_TimerEnable   = 1'b0;\n        end\n      end\n      stIdle: begin\n        if (Enable_i == 1'b0)\n        begin\n          SensorFSM_NextState     = stDisabled;\n        end\n        else\n        if (SensorFSM_TimerOvfl == 1'b1)\n        begin\n          SensorFSM_NextState     = stQueryLocal;\n          MeasureFSM_QueryLocal_o = 1'b1;\n        end\n        else\n        begin\n          SensorFSM_TimerEnable   = 1'b1;  end\n      end\n      stQueryLocal: begin\n        if (MeasureFSM_Error_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stError;\n          CpuIntr_o               = 1'b1;  end\n        else if (MeasureFSM_Done_i == 1'b1)\n        begin\n          SensorFSM_StoreLocal     = 1'b1;  SensorFSM_NextState      = stWait1;\n        end\n      end\n      stWait1: begin\n        MeasureFSM_QueryRemote_o = 1'b1;\n        SensorFSM_NextState      = stQueryRemote;\n      end\n      stQueryRemote: begin\n        if (MeasureFSM_Error_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stError;\n          CpuIntr_o               = 1'b1;  end\n        else if (MeasureFSM_Done_i == 1'b1)\n        begin\n          SensorFSM_StoreRemote   = 1'b1;  SensorFSM_NextState     = stNotify;\n        end\n      end\n      stNotify: begin\n        SensorFSM_TimerPreset   = 1'b1;  CpuIntr_o               = 1'b1;  SensorFSM_NextState     = stIdle;\n      end\n      stError: begin\n        if (Enable_i == 1'b0)\n        begin\n          SensorFSM_NextState     = stDisabled;\n        end\n      end\n      default: begin\n      end\n    endcase\n  end \n\n  reg [31:0] SensorFSM_Timer;\n  \n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SensorFSM_Timer <= 32'd0;\n    end\n    else\n    begin\n      if (SensorFSM_TimerPreset)\n      begin\n        SensorFSM_Timer <= {ParamCounterPresetH_i, ParamCounterPresetL_i};\n      end\n      else if (SensorFSM_TimerEnable)\n      begin\n        SensorFSM_Timer <= SensorFSM_Timer - 1'b1;\n      end\n    end  \n  end\n\n  assign SensorFSM_TimerOvfl = (SensorFSM_Timer == 0) ? 1'b1 : 1'b0;\n\n  assign SensorValue = {MeasureFSM_Byte1_i, MeasureFSM_Byte0_i};\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      WordL <= 16'd0;\n      WordR <= 16'd0;\n    end\n    else\n    begin\n      if (SensorFSM_StoreLocal)\n      begin\n        WordL <= SensorValue;\n      end\n      if (SensorFSM_StoreRemote)\n      begin\n        WordR <= SensorValue;\n      end\n    end  \n  end\n\n  assign SensorValueL_o = WordL;\n  assign SensorValueR_o = WordR;\n\nendmodule ",
        "module_name": "SensorFSM #",
        "module_hash": "96c6f568a6c137746b522b9b275fbb8f",
        "dataset_index": 22784
      },
      "ExtADCSimple_4a143165": {
        "rtl_code": "module ExtADCSimple (\n  input Reset_n_i,\n  input Clk_i,\n  input Enable_i,\n  output reg CpuIntr_o,\n  output reg SensorPower_o,\n  output reg SensorStart_o,\n  input SensorReady_i,\n  output reg AdcStart_o,\n  input AdcDone_i,\n  input [15:0] AdcValue_i,\n  input [15:0] PeriodCounterPreset_i,\n  output [15:0] SensorValue_o\n);\n\n  // Sensor FSM\n  localparam stDisabled     = 3'b000;\n  localparam stIdle         = 3'b001;\n  localparam stSensorPower  = 3'b010;\n  localparam stSensorSettle = 3'b011;\n  localparam stMeasure      = 3'b100;\n  reg  [2:0]             State;\n  reg  [2:0]             NextState;\n  wire                   TimerOvfl;\n  reg                    TimerPreset;\n  reg                    TimerEnable;\n  wire                   DiffTooLarge;\n  reg                    StoreNewValue;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      State <= stDisabled;\n    end\n    else\n    begin // rising clock edge\n      // state register\n      State <= NextState;\n    end  \n  end\n\n  always @(State, Enable_i, TimerOvfl, SensorReady_i, AdcDone_i, DiffTooLarge)\n  begin  // process CombProc\n    NextState     = State;\n    // control signal default values\n    TimerPreset   = 1'b1;\n    TimerEnable   = 1'b0;\n    SensorPower_o = 1'b0;\n    SensorStart_o = 1'b0;\n    AdcStart_o    = 1'b0;\n    StoreNewValue = 1'b0;\n    CpuIntr_o     = 1'b0;\n    // next state and output logic\n    case (State)\n      stDisabled: begin\n        if (Enable_i == 1'b1)\n        begin\n          NextState     = stIdle;\n          TimerPreset   = 1'b0;\n          TimerEnable   = 1'b1;\n        end\n      end\n      stIdle: begin\n        if (Enable_i == 1'b0)\n        begin\n          NextState     = stDisabled;\n        end\n        else\n        if (TimerOvfl == 1'b1)\n        begin\n          NextState     = stSensorPower;\n          SensorPower_o = 1'b1;\n        end\n        else\n        begin\n          TimerPreset   = 1'b0;\n          TimerEnable   = 1'b1;\n        end\n      end\n      stSensorPower: begin\n        SensorPower_o = 1'b1;\n        SensorStart_o = 1'b1;\n        NextState     = stSensorSettle;\n      end\n      stSensorSettle: begin\n        SensorPower_o = 1'b1;\n        SensorStart_o = 1'b1;\n        if (SensorReady_i == 1'b1) \n        begin\n          NextState     = stMeasure;\n          AdcStart_o    = 1'b1;\n        end\n      end\n      stMeasure: begin\n        SensorPower_o = 1'b1;\n        SensorStart_o = 1'b1;\n        AdcStart_o    = 1'b1;\n        if (AdcDone_i == 1'b1)\n        begin\n          NextState     = stIdle;\n          StoreNewValue = 1'b1;  // store new value\n          CpuIntr_o     = 1'b1;  // notify CPU\n        end\n      end\n      default: begin\n      end\n    endcase\n  end \n\n  /////////////////////////////////////////////////////////////////////////////\n  // Word Arithmetic //////////////////////////////////////////////////////////\n  /////////////////////////////////////////////////////////////////////////////\n\n  reg [15:0] Timer;\n  \n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Timer <= 16'd0;\n    end\n    else\n    begin\n      if (TimerPreset)\n      begin\n        Timer <= PeriodCounterPreset_i;\n      end\n      else if (TimerEnable)\n      begin\n        Timer <= Timer - 1'b1;\n      end\n    end  \n  end\n\n  assign TimerOvfl = (Timer == 0) ? 1'b1 : 1'b0;\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Word Arithmetic\n  // interconnecting signals\n  reg  [15:0] Word0;\n  wire [15:0] AbsDiffResult;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Word0 <= 16'd0;\n    end\n    else\n    begin\n      if (StoreNewValue)\n      begin\n        Word0 <= AdcValue_i;\n      end\n    end  \n  end\n\n  assign SensorValue_o = Word0;\n\nendmodule",
        "module_name": "ExtADCSimple",
        "module_hash": "4a143165551eb201861dba2506eddfcf",
        "dataset_index": 2247
      },
      "rs_fe1_pre_dec_bc67e86d": {
        "rtl_code": "\n\n\n\nmodule rs_fe1_pre_dec\n(\n\t\tinput\twire\t[13:0]\taddr_i,\n\t\toutput\twire\t\tpre_dec_o,\n\t\toutput\twire\t\tpre_dec_err_o\n\t);\n\n\tparameter N_DOMAINS = 2;\n\n    reg pre_dec;\n    reg pre_dec_err;\n    assign pre_dec_o = pre_dec;\n    assign pre_dec_err_o = pre_dec_err;\n\n    always @(addr_i) begin\n        pre_dec     = 0;\n        pre_dec_err = 0;\n        case (addr_i[5:2])\n            'h0, 'h8, 'ha: pre_dec = 0;\n            'h1, 'h2, 'h3, 'h4, 'h5, 'h6, 'h7: pre_dec = 1;\n            default: begin \n                pre_dec     = 0;\n                pre_dec_err = 1;\n            end\n        endcase\n    end\n\n\tendmodule\n",
        "module_name": "rs_fe1_pre_dec",
        "module_hash": "bc67e86d1251629d966ba50dc9a6b878",
        "dataset_index": 8669
      },
      "amiq_mux2_1_8382f2fc": {
        "rtl_code": "\nmodule amiq_mux2_1(input clk, input sel, input in0, input in1, output reg out);\n\tinitial out=0;\n\t\n\talways@(posedge clk) begin\n\t\tout<=sel?in1:in0;\t\n\tend\nendmodule\n\n",
        "module_name": "amiq_mux2_1",
        "module_hash": "8382f2fc311db35f24e226e14f0e3736",
        "dataset_index": 10826
      },
      "FSM #_6342a00b": {
        "rtl_code": "module FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\n\nparameter s = 8; // number of states in the FSM\n\nreg [s-1:0] state;\nreg [m-1:0] output_reg;\n\nalways @ (posedge clk) begin\n  case(state)\n    3'b000: begin // state 0\n      if (in[0] && !in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b000;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b001: begin // state 1\n      if (in[0] && !in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b001;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b010: begin // state 2\n      if (in[0] && !in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b010;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b011: begin // state 3\n      if (in[0] && !in[1]) begin\n        state <= 3'b111;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b011;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b100: begin // state 4\n      if (in[0] && !in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b100;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b101: begin // state 5\n      if (in[0] && !in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b101;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b110: begin // state 6\n      if (in[0] && !in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b110;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b111: begin // state 7\n      if (in[0] && !in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b111;\n        output_reg <= 2'b00;\n      end\n    end\n  endcase\nend\n\nassign out = output_reg;\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "6342a00b770ba38fbac5217a228757de",
        "dataset_index": 727
      },
      "mux_2to1_3956c6be": {
        "rtl_code": "module mux_2to1(\n    input A,\n    input B,\n    input sel,\n    output Y\n);\n\nassign Y = sel ? B : A;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "3956c6bee48db9ade790d8f5371c5c1d",
        "dataset_index": 767
      },
      "rising_edge_detector_c9792474": {
        "rtl_code": "module rising_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] pipeline_reg [2:0];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        pipeline_reg[0] <= 0;\n        pipeline_reg[1] <= 0;\n        pipeline_reg[2] <= 0;\n        out <= 0;\n    end else begin\n        pipeline_reg[0] <= in;\n        pipeline_reg[1] <= pipeline_reg[0];\n        pipeline_reg[2] <= pipeline_reg[1];\n        \n        out[0] <= pipeline_reg[2][0] & ~pipeline_reg[1][0] & pipeline_reg[0][0];\n        out[1] <= pipeline_reg[2][1] & ~pipeline_reg[1][1] & pipeline_reg[0][1];\n        out[2] <= pipeline_reg[2][2] & ~pipeline_reg[1][2] & pipeline_reg[0][2];\n        out[3] <= pipeline_reg[2][3] & ~pipeline_reg[1][3] & pipeline_reg[0][3];\n        out[4] <= pipeline_reg[2][4] & ~pipeline_reg[1][4] & pipeline_reg[0][4];\n        out[5] <= pipeline_reg[2][5] & ~pipeline_reg[1][5] & pipeline_reg[0][5];\n        out[6] <= pipeline_reg[2][6] & ~pipeline_reg[1][6] & pipeline_reg[0][6];\n        out[7] <= pipeline_reg[2][7] & ~pipeline_reg[1][7] & pipeline_reg[0][7];\n        out[8] <= pipeline_reg[2][8] & ~pipeline_reg[1][8] & pipeline_reg[0][8];\n        out[9] <= pipeline_reg[2][9] & ~pipeline_reg[1][9] & pipeline_reg[0][9];\n        out[10] <= pipeline_reg[2][10] & ~pipeline_reg[1][10] & pipeline_reg[0][10];\n        out[11] <= pipeline_reg[2][11] & ~pipeline_reg[1][11] & pipeline_reg[0][11];\n        out[12] <= pipeline_reg[2][12] & ~pipeline_reg[1][12] & pipeline_reg[0][12];\n        out[13] <= pipeline_reg[2][13] & ~pipeline_reg[1][13] & pipeline_reg[0][13];\n        out[14] <= pipeline_reg[2][14] & ~pipeline_reg[1][14] & pipeline_reg[0][14];\n        out[15] <= pipeline_reg[2][15] & ~pipeline_reg[1][15] & pipeline_reg[0][15];\n        out[16] <= pipeline_reg[2][16] & ~pipeline_reg[1][16] & pipeline_reg[0][16];\n        out[17] <= pipeline_reg[2][17] & ~pipeline_reg[1][17] & pipeline_reg[0][17];\n        out[18] <= pipeline_reg[2][18] & ~pipeline_reg[1][18] & pipeline_reg[0][18];\n        out[19] <= pipeline_reg[2][19] & ~pipeline_reg[1][19] & pipeline_reg[0][19];\n        out[20] <= pipeline_reg[2][20] & ~pipeline_reg[1][20] & pipeline_reg[0][20];\n        out[21] <= pipeline_reg[2][21] & ~pipeline_reg[1][21] & pipeline_reg[0][21];\n        out[22] <= pipeline_reg[2][22] & ~pipeline_reg[1][22] & pipeline_reg[0][22];\n        out[23] <= pipeline_reg[2][23] & ~pipeline_reg[1][23] & pipeline_reg[0][23];\n        out[24] <= pipeline_reg[2][24] & ~pipeline_reg[1][24] & pipeline_reg[0][24];\n        out[25] <= pipeline_reg[2][25] & ~pipeline_reg[1][25] & pipeline_reg[0][25];\n        out[26] <= pipeline_reg[2][26] & ~pipeline_reg[1][26] & pipeline_reg[0][26];\n        out[27] <= pipeline_reg[2][27] & ~pipeline_reg[1][27] & pipeline_reg[0][27];\n        out[28] <= pipeline_reg[2][28] & ~pipeline_reg[1][28] & pipeline_reg[0][28];\n        out[29] <= pipeline_reg[2][29] & ~pipeline_reg[1][29] & pipeline_reg[0][29];\n        out[30] <= pipeline_reg[2][30] & ~pipeline_reg[1][30] & pipeline_reg[0][30];\n        out[31] <= pipeline_reg[2][31] & ~pipeline_reg[1][31] & pipeline_reg[0][31];\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nrising_edge_detector detector (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule",
        "module_name": "rising_edge_detector",
        "module_hash": "c97924741d43dc8409be8c1f62ac4e0a",
        "dataset_index": 252
      },
      "clk_1_khz_3c9360b8": {
        "rtl_code": "\nmodule clk_1_khz(\n    input clk_50mhz,\n    output reg clk_1khz\n);\n\nreg [3:0] count;\n\nalways @(posedge clk_50mhz)\nbegin\n    count <= count + 1;\n    if(count == 7) begin // 7 is chosen because 7*143 = 1001\n        count <= 0;\n        clk_1khz <= ~clk_1khz;\n    end\nend\n\nendmodule",
        "module_name": "clk_1_khz",
        "module_hash": "3c9360b86de12ac751ef571de8b009f5",
        "dataset_index": 19806
      },
      "ResetInverter_a360c34d": {
        "rtl_code": "\n`ifdef BSV_ASSIGNMENT_DELAY\n`else\n`define BSV_ASSIGNMENT_DELAY\n`endif\n\nmodule ResetInverter(RESET_IN, RESET_OUT);\n\n   input     RESET_IN;            output    RESET_OUT;           wire      RESET_OUT;\n   \n   assign    RESET_OUT = ! RESET_IN ;\n   \nendmodule ",
        "module_name": "ResetInverter",
        "module_hash": "a360c34de03571ccd2b26bfbf69514d2",
        "dataset_index": 24714
      },
      "binary_counter #_728384c7": {
        "rtl_code": "module binary_counter #(parameter N = 4) (\n    input clk,\n    input rst,\n    output reg [N-1:0] count\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (rst == 0) begin\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter #",
        "module_hash": "728384c78a4edfc159b26c45f41f3ab3",
        "dataset_index": 1447
      },
      "image_processor_dbg_142cdce2": {
        "rtl_code": "\nmodule image_processor_dbg (\n        input                   iClk,\n        input                   iLineValid,\n        input                   iFrameValid,\n        input                   iSW,\n        \n        output          [23:0]  oDebug\n    );\n\n    assign oDebug = (iSW == 1) ? rDebugFPS : rDebugRes;\n    \n    \n    reg     [23:0]  rDebugFPS       = 0;\n    reg     [23:0]  rDebugRes       = 0;\n    reg     [23:0]  rFPS            = 0;\n    reg     [32:0]  rTime           = 0;\n    reg     [23:0]  rWidth          = 0;\n    reg     [23:0]  rHeight         = 0;\n    reg             rLineValidL     = 0;\n    reg             rFrameValidL    = 0;\n    \n    always@(posedge iClk)\n    begin\n        rTime <= rTime + 1;\n        if({rFrameValidL,iFrameValid} == 2'b10)  rFPS <= rFPS + 1;\n        case({rLineValidL,iLineValid})\n            2'b10:  rDebugRes[23:12] <= rWidth[11:0];\n            2'b00:  rWidth <= 0;\n            2'b01:  rWidth <= 0;\n            2'b11:  rWidth <= rWidth + 1;\n        endcase\n        rLineValidL <= iLineValid;\n        case({rFrameValidL,iFrameValid})\n            2'b10:  rDebugRes[11:0] <= rHeight[11:0];\n            2'b00:  rHeight <= 0;\n            2'b01:  rHeight <= 0;\n            2'b11:  if({rLineValidL,iLineValid} == 2'b10) rHeight <= rHeight + 1;\n        endcase\n        rFrameValidL    <=  iFrameValid;\n        if(rTime == 25000000)\n        begin\n            rTime       <=  0;\n            rDebugFPS   <=  rFPS;\n            rFPS        <=  0;\n        end\n    end\n    \nendmodule\n    \n",
        "module_name": "image_processor_dbg",
        "module_hash": "142cdce27c175d59d8a18da11422236e",
        "dataset_index": 24055
      },
      "adder32_9cfac13c": {
        "rtl_code": "module adder32 ( \n    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,\n    b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,\n    s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15,\n    cout  );\n  input  a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, \nb0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;\n  output s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, cout;\n  wire n50, n51, n53, n54, n55, n56, n57, n58, n60, n61, n62, n63, n64, n65,    n66, n67, n68, n69, n71, n72, n73, n74, n75, n76, n77, n78, n79, n80,    n82, n83, n84, n85, n86, n87, n88, n89, n90, n91, n93, n94, n95, n96,    n97, n98, n99, n100, n101, n102, n104, n105, n106, n107, n108, n109,    n110, n111, n112, n113, n115, n116, n117, n118, n119, n120, n121, n122,    n123, n124, n126, n127, n128, n129, n130, n131, n132, n133, n134, n135,    n137, n138, n139, n140, n141, n142, n143, n144, n145, n146, n148, n149,    n150, n151, n152, n153, n154, n155, n156, n157, n159, n160, n161, n162,    n163, n164, n165, n166, n167, n168, n170, n171, n172, n173, n174, n175,    n176, n177, n178, n179, n181, n182, n183, n184, n185, n186, n187, n188,    n189, n190, n192, n193, n194, n195, n196, n197, n198, n199, n200, n201,    n203, n204, n205, n206, n207, n208, n209, n210, n211, n212, n214, n215,   n216, n217;\n  assign n50 = ~a0 & b0;\n  assign n51 = a0 & ~b0;\n  assign s0 = n50 | n51;\n  assign n53 = a0 & b0;\n  assign n54 = ~a1 & b1;\n  assign n55 = a1 & ~b1;\n  assign n56 = ~n54 & ~n55;\n  assign n57 = n53 & n56;\n  assign n58 = ~n53 & ~n56;\n  assign s1 = n57 | n58;\n  assign n60 = a1 & b1;\n  assign n61 = a1 & n53;\n  assign n62 = ~n60 & ~n61;\n  assign n63 = b1 & n53;\n  assign n64 = n62 & ~n63;\n  assign n65 = ~a2 & b2;\n  assign n66 = a2 & ~b2;\n  assign n67 = ~n65 & ~n66;\n  assign n68 = ~n64 & n67;\n  assign n69 = n64 & ~n67;\n  assign s2 = n68 | n69;\n  assign n71 = a2 & b2;\n  assign n72 = a2 & ~n64;\n  assign n73 = ~n71 & ~n72;\n  assign n74 = b2 & ~n64;\n  assign n75 = n73 & ~n74;\n  assign n76 = ~a3 & b3;\n  assign n77 = a3 & ~b3;\n  assign n78 = ~n76 & ~n77;\n  assign n79 = ~n75 & n78;\n  assign n80 = n75 & ~n78;\n  assign s3 = n79 | n80;\n  assign n82 = a3 & b3;\n  assign n83 = a3 & ~n75;\n  assign n84 = ~n82 & ~n83;\n  assign n85 = b3 & ~n75;\n  assign n86 = n84 & ~n85;\n  assign n87 = ~a4 & b4;\n  assign n88 = a4 & ~b4;\n  assign n89 = ~n87 & ~n88;\n  assign n90 = ~n86 & n89;\n  assign n91 = n86 & ~n89;\n  assign s4 = n90 | n91;\n  assign n93 = a4 & b4;\n  assign n94 = a4 & ~n86;\n  assign n95 = ~n93 & ~n94;\n  assign n96 = b4 & ~n86;\n  assign n97 = n95 & ~n96;\n  assign n98 = ~a5 & b5;\n  assign n99 = a5 & ~b5;\n  assign n100 = ~n98 & ~n99;\n  assign n101 = ~n97 & n100;\n  assign n102 = n97 & ~n100;\n  assign s5 = n101 | n102;\n  assign n104 = a5 & b5;\n  assign n105 = a5 & ~n97;\n  assign n106 = ~n104 & ~n105;\n  assign n107 = b5 & ~n97;\n  assign n108 = n106 & ~n107;\n  assign n109 = ~a6 & b6;\n  assign n110 = a6 & ~b6;\n  assign n111 = ~n109 & ~n110;\n  assign n112 = ~n108 & n111;\n  assign n113 = n108 & ~n111;\n  assign s6 = n112 | n113;\n  assign n115 = a6 & b6;\n  assign n116 = a6 & ~n108;\n  assign n117 = ~n115 & ~n116;\n  assign n118 = b6 & ~n108;\n  assign n119 = n117 & ~n118;\n  assign n120 = ~a7 & b7;\n  assign n121 = a7 & ~b7;\n  assign n122 = ~n120 & ~n121;\n  assign n123 = ~n119 & n122;\n  assign n124 = n119 & ~n122;\n  assign s7 = n123 | n124;\n  assign n126 = a7 & b7;\n  assign n127 = a7 & ~n119;\n  assign n128 = ~n126 & ~n127;\n  assign n129 = b7 & ~n119;\n  assign n130 = n128 & ~n129;\n  assign n131 = ~a8 & b8;\n  assign n132 = a8 & ~b8;\n  assign n133 = ~n131 & ~n132;\n  assign n134 = ~n130 & n133;\n  assign n135 = n130 & ~n133;\n  assign s8 = n134 | n135;\n  assign n137 = a8 & b8;\n  assign n138 = a8 & ~n130;\n  assign n139 = ~n137 & ~n138;\n  assign n140 = b8 & ~n130;\n  assign n141 = n139 & ~n140;\n  assign n142 = ~a9 & b9;\n  assign n143 = a9 & ~b9;\n  assign n144 = ~n142 & ~n143;\n  assign n145 = ~n141 & n144;\n  assign n146 = n141 & ~n144;\n  assign s9 = n145 | n146;\n  assign n148 = a9 & b9;\n  assign n149 = a9 & ~n141;\n  assign n150 = ~n148 & ~n149;\n  assign n151 = b9 & ~n141;\n  assign n152 = n150 & ~n151;\n  assign n153 = ~a10 & b10;\n  assign n154 = a10 & ~b10;\n  assign n155 = ~n153 & ~n154;\n  assign n156 = ~n152 & n155;\n  assign n157 = n152 & ~n155;\n  assign s10 = n156 | n157;\n  assign n159 = a10 & b10;\n  assign n160 = a10 & ~n152;\n  assign n161 = ~n159 & ~n160;\n  assign n162 = b10 & ~n152;\n  assign n163 = n161 & ~n162;\n  assign n164 = ~a11 & b11;\n  assign n165 = a11 & ~b11;\n  assign n166 = ~n164 & ~n165;\n  assign n167 = ~n163 & n166;\n  assign n168 = n163 & ~n166;\n  assign s11 = n167 | n168;\n  assign n170 = a11 & b11;\n  assign n171 = a11 & ~n163;\n  assign n172 = ~n170 & ~n171;\n  assign n173 = b11 & ~n163;\n  assign n174 = n172 & ~n173;\n  assign n175 = ~a12 & b12;\n  assign n176 = a12 & ~b12;\n  assign n177 = ~n175 & ~n176;\n  assign n178 = ~n174 & n177;\n  assign n179 = n174 & ~n177;\n  assign s12 = n178 | n179;\n  assign n181 = a12 & b12;\n  assign n182 = a12 & ~n174;\n  assign n183 = ~n181 & ~n182;\n  assign n184 = b12 & ~n174;\n  assign n185 = n183 & ~n184;\n  assign n186 = ~a13 & b13;\n  assign n187 = a13 & ~b13;\n  assign n188 = ~n186 & ~n187;\n  assign n189 = ~n185 & n188;\n  assign n190 = n185 & ~n188;\n  assign s13 = n189 | n190;\n  assign n192 = a13 & b13;\n  assign n193 = a13 & ~n185;\n  assign n194 = ~n192 & ~n193;\n  assign n195 = b13 & ~n185;\n  assign n196 = n194 & ~n195;\n  assign n197 = ~a14 & b14;\n  assign n198 = a14 & ~b14;\n  assign n199 = ~n197 & ~n198;\n  assign n200 = ~n196 & n199;\n  assign n201 = n196 & ~n199;\n  assign s14 = n200 | n201;\n  assign n203 = a14 & b14;\n  assign n204 = a14 & ~n196;\n  assign n205 = ~n203 & ~n204;\n  assign n206 = b14 & ~n196;\n  assign n207 = n205 & ~n206;\n  assign n208 = ~a15 & b15;\n  assign n209 = a15 & ~b15;\n  assign n210 = ~n208 & ~n209;\n  assign n211 = ~n207 & n210;\n  assign n212 = n207 & ~n210;\n  assign s15 = n211 | n212;\n  assign n214 = a15 & b15;\n  assign n215 = a15 & ~n207;\n  assign n216 = ~n214 & ~n215;\n  assign n217 = b15 & ~n207;\n  assign cout = ~n216 | n217;\nendmodule\n\n\n",
        "module_name": "adder32",
        "module_hash": "9cfac13ca6e050850ab5c960d8ea0f70",
        "dataset_index": 23745
      },
      "binary_counter_55494cf4": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst,\n    input up_down,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 4'b0000;\n        end\n        else if (up_down) begin\n            count <= count + 1;\n        end\n        else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "55494cf40c6f98d67b4f61e3b370bea3",
        "dataset_index": 4182
      },
      "dff_8_reset_73c6b564": {
        "rtl_code": "module dff_8_reset (clk, d, rst, q);\n    input clk, rst;\n    input [7:0] d;\n    output [7:0] q;\n    reg [7:0] q;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule",
        "module_name": "dff_8_reset",
        "module_hash": "73c6b564aceb97b320422cd69e801461",
        "dataset_index": 17102
      },
      "bus_manager #_34fb4c72": {
        "rtl_code": "\n\nmodule bus_manager #(parameter RAM_MSB=10)(\ninput [7:0] ROM_data_out,\n\tinput [7:0]\tRAM_data,\n\tinput [7:0] jt_data_out,\n\tinput\t\tgame_sel,\n\tinput [7:0]\tsound_latch,\n\toutput\t\tclear_irq,\n\toutput reg [7:0] cpu_data_in,\t\n\tinput [15:0]addr,\n\tinput\t\tcpu_vma,\n\tinput\t\tcpu_rw,\n\toutput\treg\tRAM_cs,\n\toutput\treg\topm_cs_n\n\t\n);\n\nwire ROM_cs = addr[15];\n\nparameter RAM_START = 16'h6000;\nparameter RAM_END = RAM_START+(2**(RAM_MSB+1));\nparameter ROM_START=16'h8000;\n\nwire [15:0] ram_start_contra\t= 16'h6000;\nwire [15:0] ram_end_contra\t\t= 16'h7FFF;\nwire [15:0] ram_start_ddragon\t= 16'h0000;\nwire [15:0] ram_end_ddragon\t\t= 16'h0FFF;\n\nreg [15:0] irq_clear_addr;\n\nreg LATCH_rd;\n\nalways @(*) begin\n\tif( cpu_rw && cpu_vma)\n\t\tcasex( {~opm_cs_n, RAM_cs, ROM_cs, LATCH_rd } )\n\t\t\t4'b1XXX: cpu_data_in = jt_data_out;\n\t\t\t4'b01XX: cpu_data_in = RAM_data;\n\t\t\t4'b001X: cpu_data_in = ROM_data_out;\n\t\t\t4'b0001: cpu_data_in = sound_latch;\n\t\t\tdefault: cpu_data_in = 8'h0;\n\t\tendcase\n\telse\n\t\tcpu_data_in = 8'h0;\nend\n\nwire opm_cs_contra = !addr[15] && !addr[14] && addr[13]; \nwire opm_cs_ddragon= addr>=16'h2800 && addr<=16'h2801;\n\nalways @(*)\n\tif( game_sel ) begin\n\t\tRAM_cs\t= cpu_vma && (addr>=ram_start_ddragon && addr<=ram_end_ddragon);\n\t\topm_cs_n= !(cpu_vma && opm_cs_ddragon);\n\t\tLATCH_rd= cpu_vma && addr==16'h1000; irq_clear_addr = 16'h1000;\n\tend\n\telse begin\n\t\tRAM_cs \t= cpu_vma && (addr>=ram_start_contra && addr<=ram_end_contra);\n\t\topm_cs_n= !(cpu_vma && opm_cs_contra);\n\t\tLATCH_rd= cpu_vma && addr==16'h0; irq_clear_addr = 16'h4000;\n\tend\n\t\nassign clear_irq = (addr==irq_clear_addr) && cpu_vma ? 1'b1 : 1'b0;\n\t\nendmodule\n",
        "module_name": "bus_manager #",
        "module_hash": "34fb4c72a4eee60b993c11103146a1c6",
        "dataset_index": 18649
      },
      "fsm_traffic_light_control_234f2e99": {
        "rtl_code": "module fsm_traffic_light_control (\n  input clk,\n  input reset,\n  input ped,\n  output reg red,\n  output reg green,\n  output reg yellow\n);\n\n  parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n  reg [1:0] state, next_state;\n\n  localparam red_time = 4;\n  localparam green_time = 6;\n  localparam yellow_time = 2;\n\n  reg [2:0] counter;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= S0;\n      counter <= 0;\n    end\n    else begin\n      state <= next_state;\n      case (state)\n        S0: begin\n          counter <= red_time;\n        end\n        S1: begin\n          if (ped) begin\n            counter <= yellow_time;\n          end\n          else begin\n            counter <= green_time;\n          end\n        end\n        S2: begin\n          counter <= yellow_time;\n        end\n        default: begin\n          counter <= 0;\n        end\n      endcase\n    end\n  end\n\n  always @(posedge clk) begin\n    if (reset) begin\n      red <= 1'b1;\n      green <= 1'b0;\n      yellow <= 1'b0;\n    end\n    else begin\n      case (state)\n        S0: begin\n          red <= 1'b1;\n          green <= 1'b0;\n          yellow <= 1'b0;\n        end\n        S1: begin\n          if (ped) begin\n            red <= 1'b0;\n            green <= 1'b0;\n            yellow <= 1'b1;\n          end\n          else begin\n            red <= 1'b0;\n            green <= 1'b1;\n            yellow <= 1'b0;\n          end\n        end\n        S2: begin\n          red <= 1'b0;\n          green <= 1'b0;\n          yellow <= 1'b1;\n        end\n        default: begin\n          red <= 1'b0;\n          green <= 1'b0;\n          yellow <= 1'b0;\n        end\n      endcase\n    end\n  end\n\n  always @(*) begin\n    case (state)\n      S0: begin\n        next_state = S1;\n      end\n      S1: begin\n        if (counter == 0) begin\n          next_state = S2;\n        end\n        else begin\n          next_state = S1;\n        end\n      end\n      S2: begin\n        if (counter == 0) begin\n          next_state = S0;\n        end\n        else begin\n          next_state = S2;\n        end\n      end\n      default: begin\n        next_state = S0;\n      end\n    endcase\n  end\n\nendmodule\n",
        "module_name": "fsm_traffic_light_control",
        "module_hash": "234f2e9967d6f9b3b19f7ba62b0ce95f",
        "dataset_index": 11320
      },
      "byte_reverser_158ee812": {
        "rtl_code": "\nmodule byte_reverser (\n  input [31:0] in,\n  output [31:0] out\n);\n  assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\nmodule full_adder (\n  input a, b, cin,\n  output reg sum, carry_out\n);\n  always @ (a, b, cin) begin\n    sum = a ^ b ^ cin;\n    carry_out = (a & b) | (a & cin) | (b & cin);\n  end\nendmodule\nmodule functional_module (\n  input [31:0] in1,\n  input [2:0] in2,\n  output [31:0] out\n);\n  assign out = in1 ^ {in2[2], in2[2], in2[1:0]};\nendmodule\nmodule control_logic (\n  input select,\n  input [31:0] in1,\n  input a, b, cin,\n  output reg [31:0] out\n);\n  wire [31:0] in2;\n  assign in2 = select ? {a, b, cin} : in1;\n\n  byte_reverser byte_reverser_inst (\n    .in(in2),\n    .out(out)\n  );\nendmodule\nmodule top_module (\n  input clk,\n  input reset,\n  input [31:0] in,\n  input a, b, cin,\n  input select,\n  output [31:0] out\n);\n  wire [31:0] in1;\n  control_logic control_logic_inst (\n    .select(select),\n    .in1(in),\n    .a(a),\n    .b(b),\n    .cin(cin),\n    .out(in1)\n  );\n\n  assign out = in1;\nendmodule",
        "module_name": "byte_reverser",
        "module_hash": "158ee812c9a7dcf9987bd4433e17eeb1",
        "dataset_index": 10137
      },
      "minimac2_sync_7543b2d3": {
        "rtl_code": "module minimac2_sync(\n    input sys_clk,\n    input phy_rx_clk,\n    input phy_tx_clk,\n    \n    input [1:0] sys_rx_ready,\n    output [1:0] sys_rx_done,\n    output reg [10:0] sys_rx_count_0,\n    output reg [10:0] sys_rx_count_1,\n    \n    input sys_tx_start,\n    output sys_tx_done,\n    input [10:0] sys_tx_count,\n    \n    output [1:0] phy_rx_ready,\n    input [1:0] phy_rx_done,\n    input [10:0] phy_rx_count_0,\n    input [10:0] phy_rx_count_1,\n    \n    output phy_tx_start,\n    input phy_tx_done,\n    output reg [10:0] phy_tx_count\n);\n\nminimac2_psync rx_ready_0(\n    .clk1(sys_clk),\n    .i(sys_rx_ready[0]),\n    .clk2(phy_rx_clk),\n    .o(phy_rx_ready[0])\n);\nminimac2_psync rx_ready_1(\n    .clk1(sys_clk),\n    .i(sys_rx_ready[1]),\n    .clk2(phy_rx_clk),\n    .o(phy_rx_ready[1])\n);\nminimac2_psync rx_done_0(\n    .clk1(phy_rx_clk),\n    .i(phy_rx_done[0]),\n    .clk2(sys_clk),\n    .o(sys_rx_done[0])\n);\nminimac2_psync rx_done_1(\n    .clk1(phy_rx_clk),\n    .i(phy_rx_done[1]),\n    .clk2(sys_clk),\n    .o(sys_rx_done[1])\n);\nreg [10:0] sys_rx_count_0_r;\nreg [10:0] sys_rx_count_1_r;\nalways @(posedge sys_clk) begin\n    sys_rx_count_0_r <= phy_rx_count_0;\n    sys_rx_count_0 <= sys_rx_count_0_r;\n    sys_rx_count_1_r <= phy_rx_count_1;\n    sys_rx_count_1 <= sys_rx_count_1_r;\nend\n\nminimac2_psync tx_start(\n    .clk1(sys_clk),\n    .i(sys_tx_start),\n    .clk2(phy_tx_clk),\n    .o(phy_tx_start)\n);\nminimac2_psync tx_done(\n    .clk1(phy_tx_clk),\n    .i(phy_tx_done),\n    .clk2(sys_clk),\n    .o(sys_tx_done)\n);\nreg [10:0] phy_tx_count_r;\nalways @(posedge phy_tx_clk) begin\n    phy_tx_count_r <= sys_tx_count;\n    phy_tx_count <= phy_tx_count_r;\nend\n\nendmodule\n\nmodule minimac2_psync(\n    input clk1,       // Source clock\n    input i,          // Input signal in the source clock domain\n    input clk2,       // Destination clock\n    output reg o      // Output signal in the destination clock domain\n);\n\n    // Synchronization from clk1 to clk2 domain\n    reg intermediate;\n    reg [1:0] sync_reg; // Double flip-flop for synchronizing the signal\n\n    // Pulse detection in clk1 domain\n    reg i_reg;\n    wire pulse; // Detected pulse\n\n    always @(posedge clk1) begin\n        i_reg <= i;\n    end\n    assign pulse = i & ~i_reg; // Detecting rising edge\n\n    // Transfer the pulse to the clk2 domain\n    always @(posedge clk2) begin\n        if (pulse)\n            intermediate <= 1'b1; // Set intermediate high if a pulse is detected\n        else if (sync_reg[1])\n            intermediate <= 1'b0; // Reset intermediate when the pulse has been acknowledged\n\n        sync_reg <= {sync_reg[0], intermediate}; // Synchronize the intermediate signal\n    end\n\n    always @(posedge clk2) begin\n        o <= sync_reg[1]; // Output the synchronized signal\n    end\n\nendmodule\n",
        "module_name": "minimac2_sync",
        "module_hash": "7543b2d3f4958fe870e61f8d1926473f",
        "dataset_index": 125
      },
      "clk_generator_9b9ed134": {
        "rtl_code": "module clk_generator(\n    input       clk_i,      output  reg clk_core,   output      clk_bus     );\n\n    assign clk_bus = clk_i;\n\n    initial begin\n        clk_core <= 1'b0;\n    end\n\n    always @(posedge clk_i ) begin\n        clk_core <= !clk_core;\n    end\nendmodule\n",
        "module_name": "clk_generator",
        "module_hash": "9b9ed1346fccbf4884b91a3e877f588f",
        "dataset_index": 19652
      },
      "Shift_Register_e582c9a7": {
        "rtl_code": "module Shift_Register (\n  input CLK,\n  input EN,\n  input TE,\n  input [6:0] DATA_IN,\n  output reg [6:0] DATA_OUT,\n  output reg ENCLK\n);\n\n  reg [6:0] data_out_reg;\n  reg [6:0] data_out;\n\n  always @ (posedge CLK) begin\n    if (EN) begin\n      data_out_reg <= {DATA_IN[6], data_out_reg[6:1]};\n    end\n  end\n\n  always @ (*) begin\n    if (TE) begin\n      data_out <= data_out_reg;\n    end\n  end\n\n  always @ (*) begin\n    DATA_OUT = data_out;\n    ENCLK = data_out[0];\n  end\n\nendmodule\n\nmodule TLATNTSCAX2TS (\n  input E,\n  input SE,\n  input CK,\n  output reg ECK\n);\n\n  // Define behavior here\n\nendmodule",
        "module_name": "Shift_Register",
        "module_hash": "e582c9a7e0da2bbe075909c6de3c3735",
        "dataset_index": 4334
      },
      "fifo_634c0bd4": {
        "rtl_code": "module fifo(clk, rst, din, wr_en, rd_en, dout, full, empty, data_count);\n  parameter DEPTH = 4096;\n  parameter WIDTH = 24;\n  parameter ADDR_WIDTH = $clog2(DEPTH);\n  \n  input clk, rst, wr_en, rd_en;\n  input [WIDTH-1:0] din;\n  output [WIDTH-1:0] dout;\n  output full, empty;\n  output reg [ADDR_WIDTH-1:0] data_count;\n  \n  reg [WIDTH-1:0] mem [0:DEPTH-1];\n  reg [ADDR_WIDTH-1:0] wr_ptr, rd_ptr;\n  wire [ADDR_WIDTH-1:0] next_wr_ptr = wr_ptr + 1'b1;\n  wire [ADDR_WIDTH-1:0] next_rd_ptr = rd_ptr + 1'b1;\n  \n  assign dout = mem[rd_ptr];\n  assign full = (wr_ptr == next_rd_ptr);\n  assign empty = (wr_ptr == rd_ptr);\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      wr_ptr <= 0;\n      rd_ptr <= 0;\n      data_count <= 0;\n    end else begin\n      if (wr_en && !full) begin\n        mem[wr_ptr] <= din;\n        wr_ptr <= next_wr_ptr;\n        data_count <= data_count + 1'b1;\n      end\n      if (rd_en && !empty) begin\n        rd_ptr <= next_rd_ptr;\n        data_count <= data_count - 1'b1;\n      end\n    end\n  end\nendmodule",
        "module_name": "fifo",
        "module_hash": "634c0bd493812e039f79f37f425d1f0c",
        "dataset_index": 21010
      },
      "rbo_test_1f121256": {
        "rtl_code": "\nmodule rbo_test\n(\n  input clk,\n  output reg CAL,\n  output reg CS,\n  output reg IS1,\n  output reg IS2,\n  output reg LE,\n  output reg R12,\n  output reg RBI,\n  output reg RESET,\n  output reg RPHI1,\n  output reg RPHI2,\n  output reg SBI,\n  output reg SEB,\n  output reg SPHI1,\n  output reg SPHI2,\n  output reg SR,\n  output [15:0]Aref,\n  output [15:0]RG,\n  output [15:0]Vana,\n  output [15:0]Vthr,\n  input reset_gen\n);\n\nreg [31:0]counter;\nreg [7:0]stage;\nreg [15:0]stage_iter;\nassign Vthr=16'H0025;\nassign Aref=16'H0033;\nassign Vana=16'H0066;\nassign RG=16'H0033;\nalways @(posedge clk) begin\n  if(reset_gen == 1) begin\n    counter <= 0;\n    stage <= 0;\n    stage_iter <= 0;\n    CAL <= 0;\n    SBI <= 0;\n    SPHI1 <= 0;\n    SPHI2 <= 0;\n    SEB <= 1;\n    IS1 <= 1;\n    IS2 <= 0;\n    SR <= 1;\n    RESET <= 1;\n    R12 <= 1;\n    RBI <= 0;\n    RPHI1 <= 1;\n    RPHI2 <= 1;\n    LE <= 0;\n    CS<=0;\n  end\n  else begin\n    if(stage == 0) begin\n      if(counter == 7) begin\n        RBI <= 1;\n      end\n      if(counter == 16) begin\n        RBI <= 0;\n      end\n      if(counter == 22) begin\n        RPHI1 <= 0;\n        RPHI2 <= 0;\n      end\n      if(counter == 24) begin\n        RBI <= 1;\n      end\n      if(counter == 25) begin\n        RPHI1 <= 1;\n      end\n      if(counter == 26) begin\n        RPHI1 <= 0;\n      end\n      if(counter == 27) begin\n        RBI <= 0;\n      end\n      if(counter == 28) begin\n        RPHI2 <= 1;\n      end\n      if(counter == 29) begin\n        RPHI2 <= 0;\n      end\n      if(counter == 29) begin\n        if(stage_iter == 0) begin\n          stage <= (stage + 1) % 2;\n          stage_iter <= 0;\n        end\n        else begin\n          stage_iter <= stage_iter + 1;\n        end\n        counter <= 0;\n      end\n      else begin\n        counter <= counter + 1;\n      end\n    end\n    if(stage == 1) begin\n      if(counter == 1) begin\n        RPHI1 <= 0;\n        CS<=1;\n      end\n      if(counter == 2) begin\n        RPHI2 <= 1;\n      end\n      if(counter == 3) begin\n        RPHI2 <= 0;\n      end\n      if(counter == 3) begin\n        if(stage_iter == 128) begin\n          stage <= (stage + 1) % 2;\n          stage_iter <= 0;\n        end\n        else begin\n          stage_iter <= stage_iter + 1;\n        end\n        counter <= 0;\n      end\n      else begin\n        counter <= counter + 1;\n      end\n    end\n  end\nend\nendmodule",
        "module_name": "rbo_test",
        "module_hash": "1f121256ab80ab9fb19b7fcc03adaeac",
        "dataset_index": 733
      },
      "d_flip_flop_mux_latch_cf8f5a2b": {
        "rtl_code": "module d_flip_flop_mux_latch (\n    input clk,\n    input d,\n    output reg q );\n\n    reg mux_out;\n    reg latch_out;\n\n    always @ (posedge clk) begin\n        mux_out <= d;\n    end\n\n    always @ (mux_out) begin\n        if (mux_out) begin\n            latch_out <= 1'b1;\n        end else begin\n            latch_out <= 1'b0;\n        end\n    end\n\n    always @ (posedge clk) begin\n        q <= latch_out;\n    end\n\nendmodule",
        "module_name": "d_flip_flop_mux_latch",
        "module_hash": "cf8f5a2b867e75d5072d9e02b9a18454",
        "dataset_index": 16088
      },
      "counter #_46d8f7a9": {
        "rtl_code": "\nmodule counter #(\n  parameter M = 0\n) (\n  input clk,\n  input rst,\n  input cnt,\n  output reg [31:0] q,\n  output reg ov\n);\n\n  localparam N = M < 32 ? M : 32;\n\n  always @(posedge clk) begin\n    if (rst || ov) begin\n      q <= 0;\n      ov <= 0;\n    end else begin\n      if (cnt) begin\n        q <= q + 1;\n        if (q == M-1) begin\n          ov <= 1;\n        end\n      end\n    end\n  end\n\nendmodule",
        "module_name": "counter #",
        "module_hash": "46d8f7a9955f30c4fccf3c7e543ea087",
        "dataset_index": 17357
      },
      "multiplicadorPuntoFijo  #_a25a5896": {
        "rtl_code": "\nmodule multiplicadorPuntoFijo  #(parameter Width = 24, Magnitud = 4, Precision = 19, Signo = 1)\n\t\t(EnableMul,In,Coeff,OutMul,Error);\n\t \n\t input EnableMul;\n\t input signed [Width-1:0] In,Coeff;\n\t output reg signed [Width-1:0] OutMul = 0; \n\t output Error;\n\t reg signed [2*Width-1:0]  AuxMul = 0; \n\t reg Overflow = 0;\n\t reg Underflow = 0;\n\t \n\t \n\t \n\t\talways @* begin if (EnableMul) begin\n\t\t\t\tAuxMul <= In * Coeff; end\n\t\t\telse begin\n\t\t\t\tAuxMul <= 0;\n\t\t\tend\n\t\tend\n\t\t\n\t\talways @* begin if (~In[Width-1] && ~Coeff[Width-1] && AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 1;\n\t\t\t\tUnderflow <= 0;\n\t\t\tend\n\t\t\telse if(In[Width-1] && Coeff[Width-1] && AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 1;\n\t\t\t\tUnderflow <= 0;\n\t\t\tend\n\t\t\telse if(~In[Width-1] && Coeff[Width-1] && ~AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 0;\n\t\t\t\tUnderflow <= 1;\n\t\t\tend\n\t\t\telse if(In[Width-1] && ~Coeff[Width-1] && ~AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 0;\n\t\t\t\tUnderflow <= 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tOverflow <= 0;\n\t\t\t\tUnderflow <= 0;\n\t\t\tend\n\t\tend\n\t\t\n\t\talways @* begin if (In == 0 || Coeff==0) begin\n\t\t\t\t\tOutMul <= 0;\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tif (Overflow) begin\n\t\t\t\t\tOutMul <= 2**(Width-1) -1;  end\n\t\t\t\telse begin\n\t\t\t\t\tif (Underflow) begin\n\t\t\t\t\t\tOutMul <= -2**(Width-1);    end\n\t\t\t\t\telse begin\n\t\t\t\t\t\tOutMul <= AuxMul[2*Width -1 - Magnitud - Signo : Precision];      end\n\t\t\t\tend\t\n\t\t\tend\n\t\tend\n\t\t\n\t\tassign Error =  Overflow | Underflow;\n\t\t\n\t\n\t endmodule\n",
        "module_name": "multiplicadorPuntoFijo  #",
        "module_hash": "a25a58961c8629cecfc641504dc35973",
        "dataset_index": 7550
      },
      "sync_counter_5225359f": {
        "rtl_code": "module sync_counter(\n    input clk,\n    input rst,\n    output reg [2:0] count_out\n);\n\n    always @ (posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 3'b0;\n        end\n        else begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule",
        "module_name": "sync_counter",
        "module_hash": "5225359f6d9081d204a947ed38c6bbdb",
        "dataset_index": 5753
      },
      "sky130_fd_sc_hd__ha_72ddc35d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__ha (\n    COUT,\n    SUM ,\n    A   ,\n    B\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n\n    wire and0_out_COUT;\n    wire xor0_out_SUM ;\n\n    and and0 (and0_out_COUT, A, B           );\n    buf buf0 (COUT         , and0_out_COUT  );\n    xor xor0 (xor0_out_SUM , B, A           );\n    buf buf1 (SUM          , xor0_out_SUM   );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__ha",
        "module_hash": "72ddc35d209b560d76a7f862fc065dfa",
        "dataset_index": 23736
      },
      "four_to_one_7cad60b1": {
        "rtl_code": "module four_to_one (\n    Y,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input B1;\n    input B2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign Y = ((A1 & A2 == 0) & (B1 == 1 & B2 == 1)) | ((A1 == 1 & A2 == 0) & (B1 == 0 & B2 == 0)) | ((A1 == 0 & A2 == 1) & (B1 == 0 & B2 == 0)) | ((A1 & A2 == 1) & (B1 == 0 & B2 == 0));\n\nendmodule",
        "module_name": "four_to_one",
        "module_hash": "7cad60b19e2c9fde58d3883eeeaa002c",
        "dataset_index": 19706
      },
      "shift_register_1b098cb4": {
        "rtl_code": "module shift_register (\n  input clk,\n  input reset,\n  input enable,\n  input d,\n  output reg q\n);\n\n  reg [2:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shift_reg <= 3'b0;\n      q <= 1'b0;\n    end else if (enable) begin\n      shift_reg <= {shift_reg[1:0], d};\n      q <= shift_reg[2];\n    end\n  end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "1b098cb4ac4f0688c7f30d8706d7943e",
        "dataset_index": 18791
      },
      "rgmii_c92eaa6d": {
        "rtl_code": "module rgmii \n(\n    input   wire        reset,\n    input   wire        generated_clk,\n\n    output  wire [3:0]  phy_txd_rising,\n    output  wire [3:0]  phy_txd_falling,    \n    output  wire        phy_tx_ctl_rising,\n    output  wire        phy_tx_ctl_falling,    \n    output  wire        phy_gtx_clk,\n    input   wire [3:0]  phy_rxd_rising,\n    input   wire [3:0]  phy_rxd_falling,\n    input   wire        phy_rx_ctl_rising,\n    input   wire        phy_rx_ctl_falling,    \n    input   wire        phy_rx_clk,\n\n    input   wire        mac_tx_er,\n    input   wire [7:0]  mac_txd,\n    input   wire        mac_tx_en,\n    output  wire        mac_tx_clk,\n    output  wire        mac_col,\n    output  wire [7:0]  mac_rxd,\n    output  wire        mac_rx_er,\n    output  wire        mac_rx_clk,\n    output  wire        mac_crs,\n    output  wire        mac_rx_dv\n);\n\nassign phy_txd_rising       = mac_txd[3:0];\nassign phy_txd_falling      = mac_txd[7:4];\nassign phy_tx_ctl_rising    = mac_tx_en;\nassign phy_tx_ctl_falling   = mac_tx_en ^ mac_tx_er;\nassign phy_gtx_clk          = generated_clk;\nassign mac_col              = (mac_crs & mac_tx_en) | (mac_rx_dv & mac_tx_en);\nassign mac_rxd [3:0]        = phy_rxd_rising;\nassign mac_rxd [7:4]        = phy_rxd_falling;\nassign mac_rx_er            = phy_rx_ctl_falling ^ phy_rx_ctl_rising;\nassign mac_rx_clk           = phy_rx_clk;\nassign mac_crs              = mac_rx_dv | ( mac_rx_er && mac_rxd == 8'hFF ) | ( mac_rx_er && mac_rxd == 8'h0E ) | ( mac_rx_er && mac_rxd == 8'h0F ) | ( mac_rx_er && mac_rxd == 8'h1F );\nassign mac_rx_dv            = phy_rx_ctl_rising;\nassign mac_tx_clk           = generated_clk;\n\nendmodule\n",
        "module_name": "rgmii",
        "module_hash": "c92eaa6de656fb421d26935def33a0c4",
        "dataset_index": 21844
      },
      "assert_unchange_assert #_c568d1f3": {
        "rtl_code": "module assert_unchange_assert #(\n    parameter width = 8\n) (\n    input clk, reset_n, start_event, xzcheck_enable,\n    input [width-1:0] test_expr,\n    input window, ignore_new_start, reset_on_new_start, error_on_new_start,\n    output reg pass, fail, error\n);\n\n    parameter num_cks = 2;\n\n    reg [width-1:0] prev_test_expr;\n    reg [num_cks-1:0] window_counter;\n    reg start_detected;\n    reg reset_detected;\n\n    always @(posedge clk) begin\n        if (!reset_n) begin\n            prev_test_expr <= 'bx;\n            window_counter <= 0;\n            start_detected <= 0;\n            reset_detected <= 0;\n            pass <= 0;\n            fail <= 0;\n            error <= 0;\n        end else begin\n            if (reset_detected) begin\n                prev_test_expr <= 'bx;\n                window_counter <= 0;\n                start_detected <= 0;\n                reset_detected <= 0;\n                pass <= 0;\n                fail <= 0;\n                error <= 0;\n            end else begin\n                if (start_event && !start_detected) begin\n                    prev_test_expr <= test_expr;\n                    window_counter <= 1;\n                    start_detected <= 1;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 0;\n                end else if (start_event && reset_on_new_start) begin\n                    prev_test_expr <= test_expr;\n                    window_counter <= 1;\n                    start_detected <= 1;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= error_on_new_start;\n                end else if (start_event && error_on_new_start) begin\n                    prev_test_expr <= 'bx;\n                    window_counter <= 0;\n                    start_detected <= 0;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 1;\n                end else if (start_detected && window_counter < window) begin\n                    if (test_expr !== prev_test_expr && xzcheck_enable) begin\n                        fail <= 1;\n                        error <= 1;\n                    end else begin\n                        fail <= 0;\n                        error <= 0;\n                    end\n                    prev_test_expr <= test_expr;\n                    window_counter <= window_counter + 1;\n                    pass <= 0;\n                end else if (start_detected && window_counter == window) begin\n                    if (test_expr !== prev_test_expr && xzcheck_enable) begin\n                        fail <= 1;\n                        error <= 1;\n                    end else begin\n                        fail <= 0;\n                        error <= 0;\n                    end\n                    prev_test_expr <= test_expr;\n                    window_counter <= 0;\n                    start_detected <= ignore_new_start;\n                    reset_detected <= 0;\n                    pass <= 1;\n                end else if (start_detected && ignore_new_start) begin\n                    if (test_expr !== prev_test_expr && xzcheck_enable) begin\n                        fail <= 1;\n                        error <= 1;\n                    end else begin\n                        fail <= 0;\n                        error <= 0;\n                    end\n                    prev_test_expr <= test_expr;\n                    window_counter <= window_counter + 1;\n                    pass <= 0;\n                end else if (start_detected && reset_on_new_start) begin\n                    prev_test_expr <= test_expr;\n                    window_counter <= 1;\n                    start_detected <= 1;\n                    reset_detected <= 1;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 0;\n                end else if (start_detected && error_on_new_start) begin\n                    prev_test_expr <= 'bx;\n                    window_counter <= 0;\n                    start_detected <= 0;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 1;\n                end\n            end\n        end\n    end\n\nendmodule",
        "module_name": "assert_unchange_assert #",
        "module_hash": "c568d1f3c917cba663d0b10f1196fda5",
        "dataset_index": 6061
      },
      "sky130_fd_sc_hdll__nor3b_63884955": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__nor3b (\n    Y  ,\n    A  ,\n    B  ,\n    C_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out  ;\n    wire and0_out_Y;\n\n    nor nor0 (nor0_out  , A, B           );\n    and and0 (and0_out_Y, C_N, nor0_out  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__nor3b",
        "module_hash": "63884955631685dcab704e5962ed5c5c",
        "dataset_index": 10717
      },
      "BOR_24b8ee49": {
        "rtl_code": "module BOR (\n    input wire Vin,\n    input wire Reset_en,\n    input wire Threshold,\n    input wire clk,\n    output reg Reset\n);\n\nparameter RESET_DURATION = 10; // duration of reset pulse (in clock cycles)\n\nreg [1:0] state; // state machine to control reset pulse generation\nreg [7:0] counter; // counter to measure reset pulse duration\n\nwire comparator_out = Vin & Threshold; // Placeholder for comparator logic\n\n// State machine and counter logic\nalways @(posedge clk) begin\n    if (Reset_en) begin\n        case (state)\n            2'b00: begin // Idle state\n                if (comparator_out) begin\n                    state <= 2'b01; // Move to pulse generation state\n                    counter <= 0;\n                    Reset <= 1'b1; // Start the Reset pulse\n                end\n            end\n            2'b01: begin // Reset pulse generation state\n                if (counter < RESET_DURATION) begin\n                    counter <= counter + 1;\n                end else begin\n                    Reset <= 1'b0; // End the Reset pulse\n                    state <= 2'b00; // Return to idle state\n                    counter <= 0;\n                end\n            end\n        endcase\n    end else begin\n        state <= 2'b00; // Reset the state machine\n        counter <= 0;\n        Reset <= 1'b0;\n    end\nend\n\nendmodule\n",
        "module_name": "BOR",
        "module_hash": "24b8ee49bbcdced4e0dfec1916a6eb6d",
        "dataset_index": 6874
      },
      "inverted_5input_OR_gate_302d1e87": {
        "rtl_code": "module inverted_5input_OR_gate (\n  input p1,\n  input p2,\n  input p3,\n  input p4,\n  input p5,\n  output reg y\n);\n\n  always @(*) begin\n    if (p1 || p2 || p3 || p4 || p5) begin\n      y <= 0;\n    end else begin\n      y <= 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "inverted_5input_OR_gate",
        "module_hash": "302d1e877f10ee0d64d1ac7e39fd44d7",
        "dataset_index": 11368
      },
      "parity_bit_d6613f2b": {
        "rtl_code": "\nmodule parity_bit (\n    input [7:0] in,\n    output wire parity\n);\n\nwire [3:0] and_out;\nwire xor_out;\n\nassign and_out = in[7:4] & in[3:0];\nassign xor_out = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\nassign parity = and_out[3] & and_out[2] & and_out[1] & and_out[0] & xor_out;\n\nendmodule\n\nmodule combinational_logic (\n    input [3:0] in,\n    output wire [3:0] out_logic\n);\n\nassign out_logic[0] = in[0] & in[1];\nassign out_logic[1] = in[1] | in[2];\nassign out_logic[2] = in[2] ^ in[3];\nassign out_logic[3] = in[0] & in[3];\n\nendmodule\n\nmodule sum_computation (\n    input parity,\n    input [3:0] xor_out,\n    output wire [3:0] sum\n);\n\nassign sum = (parity + xor_out) % 16;\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    output wire [3:0] out_logic\n);\n\nwire parity;\nwire [3:0] xor_out;\nwire [3:0] sum;\n\nparity_bit parity_bit_inst (\n    .in(in),\n    .parity(parity)\n);\n\ncombinational_logic combinational_logic_inst (\n    .in({in[4], in[5], in[6], in[7]}),\n    .out_logic(xor_out)\n);\n\nsum_computation sum_computation_inst (\n    .parity(parity),\n    .xor_out(xor_out),\n    .sum(sum)\n);\n\nassign out_logic = sum;\n\nendmodule\n",
        "module_name": "parity_bit",
        "module_hash": "d6613f2bcf01190d76cb81f4d2ad8c59",
        "dataset_index": 17191
      },
      "wb_mux_2 #_5620eaa6": {
        "rtl_code": "\n\n\nmodule wb_mux_2 #\n(\n    parameter DATA_WIDTH = 32,                    parameter ADDR_WIDTH = 32,                    parameter SELECT_WIDTH = (DATA_WIDTH/8)       )\n(\n    input  wire                    clk,\n    input  wire                    rst,\n\n    \n    input  wire [ADDR_WIDTH-1:0]   wbm_adr_i,     input  wire [DATA_WIDTH-1:0]   wbm_dat_i,     output wire [DATA_WIDTH-1:0]   wbm_dat_o,     input  wire                    wbm_we_i,      input  wire [SELECT_WIDTH-1:0] wbm_sel_i,     input  wire                    wbm_stb_i,     output wire                    wbm_ack_o,     output wire                    wbm_err_o,     output wire                    wbm_rty_o,     input  wire                    wbm_cyc_i,     \n    output wire [ADDR_WIDTH-1:0]   wbs0_adr_o,    input  wire [DATA_WIDTH-1:0]   wbs0_dat_i,    output wire [DATA_WIDTH-1:0]   wbs0_dat_o,    output wire                    wbs0_we_o,     output wire [SELECT_WIDTH-1:0] wbs0_sel_o,    output wire                    wbs0_stb_o,    input  wire                    wbs0_ack_i,    input  wire                    wbs0_err_i,    input  wire                    wbs0_rty_i,    output wire                    wbs0_cyc_o,    \n    input  wire [ADDR_WIDTH-1:0]   wbs0_addr,     input  wire [ADDR_WIDTH-1:0]   wbs0_addr_msk, \n    output wire [ADDR_WIDTH-1:0]   wbs1_adr_o,    input  wire [DATA_WIDTH-1:0]   wbs1_dat_i,    output wire [DATA_WIDTH-1:0]   wbs1_dat_o,    output wire                    wbs1_we_o,     output wire [SELECT_WIDTH-1:0] wbs1_sel_o,    output wire                    wbs1_stb_o,    input  wire                    wbs1_ack_i,    input  wire                    wbs1_err_i,    input  wire                    wbs1_rty_i,    output wire                    wbs1_cyc_o,    \n    input  wire [ADDR_WIDTH-1:0]   wbs1_addr,     input  wire [ADDR_WIDTH-1:0]   wbs1_addr_msk  );\n\nwire wbs0_match = ~|((wbm_adr_i ^ wbs0_addr) & wbs0_addr_msk);\nwire wbs1_match = ~|((wbm_adr_i ^ wbs1_addr) & wbs1_addr_msk);\n\nwire wbs0_sel = wbs0_match;\nwire wbs1_sel = wbs1_match & ~(wbs0_match);\n\nwire master_cycle = wbm_cyc_i & wbm_stb_i;\n\nwire select_error = ~(wbs0_sel | wbs1_sel) & master_cycle;\n\nassign wbm_dat_o = wbs0_sel ? wbs0_dat_i :\n                   wbs1_sel ? wbs1_dat_i :\n                   {DATA_WIDTH{1'b0}};\n\nassign wbm_ack_o = wbs0_ack_i |\n                   wbs1_ack_i;\n\nassign wbm_err_o = wbs0_err_i |\n                   wbs1_err_i |\n                   select_error;\n\nassign wbm_rty_o = wbs0_rty_i |\n                   wbs1_rty_i;\n\nassign wbs0_adr_o = wbm_adr_i;\nassign wbs0_dat_o = wbm_dat_i;\nassign wbs0_we_o = wbm_we_i & wbs0_sel;\nassign wbs0_sel_o = wbm_sel_i;\nassign wbs0_stb_o = wbm_stb_i & wbs0_sel;\nassign wbs0_cyc_o = wbm_cyc_i & wbs0_sel;\n\nassign wbs1_adr_o = wbm_adr_i;\nassign wbs1_dat_o = wbm_dat_i;\nassign wbs1_we_o = wbm_we_i & wbs1_sel;\nassign wbs1_sel_o = wbm_sel_i;\nassign wbs1_stb_o = wbm_stb_i & wbs1_sel;\nassign wbs1_cyc_o = wbm_cyc_i & wbs1_sel;\n\n\nendmodule\n",
        "module_name": "wb_mux_2 #",
        "module_hash": "5620eaa68e050c3185ff8ad86cb7bd3d",
        "dataset_index": 20175
      },
      "sky130_fd_sc_hd__lpflow_clkinvkapwr_16d2c055": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__lpflow_clkinvkapwr (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__lpflow_clkinvkapwr",
        "module_hash": "16d2c05523728e93bc289e719e7b797b",
        "dataset_index": 10707
      },
      "sky130_fd_sc_hdll__nand3_0891dbef": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__nand3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A, C        );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__nand3",
        "module_hash": "0891dbef2ec6b22daf012c941a8a7aac",
        "dataset_index": 17706
      },
      "LedDriver_e2de55af": {
        "rtl_code": "module LedDriver(input clk,\n                 input [31:0] value,\n                 input [7:0] enable,\n                 output reg [7:0] SSEG_CA,\n                 output reg [7:0] SSEG_AN);\n  reg [2:0] state;\n  reg [3:0] digit;\n  reg [16:0] timer;\n  \n  always @(posedge clk) begin\n    timer <= timer + 1;\n    if (timer == 20000) begin\n      timer <= 0;\n      state <= state + 1;\n    end\n    case (state)\n    0: begin SSEG_AN <= enable[0] ? 8'b11111110 : 8'b11111111; digit = value[3:0];  end\n    1: begin SSEG_AN <= enable[1] ? 8'b11111101 : 8'b11111111; digit = value[7:4];  end\n    2: begin SSEG_AN <= enable[2] ? 8'b11111011 : 8'b11111111; digit = value[11:8]; end\n    3: begin SSEG_AN <= enable[3] ? 8'b11110111 : 8'b11111111; digit = value[15:12];end\n    4: begin SSEG_AN <= enable[4] ? 8'b11101111 : 8'b11111111; digit = value[19:16];end\n    5: begin SSEG_AN <= enable[5] ? 8'b11011111 : 8'b11111111; digit = value[23:20];end\n    6: begin SSEG_AN <= enable[6] ? 8'b10111111 : 8'b11111111; digit = value[27:24];end\n    7: begin SSEG_AN <= enable[7] ? 8'b01111111 : 8'b11111111; digit = value[31:28];end\n    endcase\n    case (digit)\n    0: SSEG_CA  <= 8'b11000000;\n    1: SSEG_CA  <= 8'b11111001;\n    2: SSEG_CA  <= 8'b10100100;\n    3: SSEG_CA  <= 8'b10110000;\n    4: SSEG_CA  <= 8'b10011001;\n    5: SSEG_CA  <= 8'b10010010;\n    6: SSEG_CA  <= 8'b10000010;\n    7: SSEG_CA  <= 8'b11111000;\n    8: SSEG_CA  <= 8'b10000000;\n    9: SSEG_CA  <= 8'b10010000;\n    10: SSEG_CA <= 8'b10001000; 11: SSEG_CA <= 8'b10000011; 12: SSEG_CA <= 8'b10100111; 13: SSEG_CA <= 8'b10100001; 14: SSEG_CA <= 8'b10000110; 15: SSEG_CA <= 8'b10001110; endcase\n  end\nendmodule\n\n",
        "module_name": "LedDriver",
        "module_hash": "e2de55af354447108ec37fdebe207ce0",
        "dataset_index": 23934
      },
      "full_adder_2bit_5a588222": {
        "rtl_code": "\nmodule full_adder_2bit(\n    input [1:0] A,\n    input [1:0] B,\n    input Cin,\n    output [1:0] Sum,\n    output Cout\n);\n\nwire [1:0] s1, s2, s3;\nwire c1, c2, c3;\n\n// First adder\nnand (s1[0], A[0], B[0], Cin);\nnand (c1, A[0], B[0]);\n\n// Second adder\nnand (s2[0], A[1], B[1], s1[0]);\nnand (c2, A[1], B[1]);\n\n// Third adder\nnand (s3[0], A[0], B[0], B[1]);\nnand (c3, A[0], B[0]);\n\nassign Sum = {s2[0], s3[0]};\nassign Cout = (Cin & c1) | (c2 & s1[0]) | (c3 & s2[0]);\n\nendmodule\n",
        "module_name": "full_adder_2bit",
        "module_hash": "5a58822224b9a5804d6434bd2793c4c6",
        "dataset_index": 15473
      },
      "sky130_fd_sc_ms__clkdlyinv3sd3_f8b88536": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__clkdlyinv3sd3 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__clkdlyinv3sd3",
        "module_hash": "f8b88536a227cb00baad3000347b9ad9",
        "dataset_index": 13051
      },
      "mux2to1_3cb83cae": {
        "rtl_code": "module mux2to1(\n   input         in0, in1, sel,\n   output        out);\n\n   assign out = sel ? in1 : in0;\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "3cb83caecdac10e73684d970dc6a0d4b",
        "dataset_index": 1808
      },
      "PhaseDelayMain_01be2b83": {
        "rtl_code": "module PhaseDelayMain(\n    input clk,\n    input decoderInput,\n    output reg sigOut\n);\n\nparameter NUM_SIZE=7;\nparameter SEQ_SIZE=NUM_SIZE+4;\n\nreg [SEQ_SIZE-1:0] seq1,seq2,seq3,seq4;\n\ninteger i;\n\nalways @(posedge clk) begin\n    // Shift the sequence to the right by one bit\n    seq1 <= {seq1[0], seq1[SEQ_SIZE-1:1]};\n    seq2 <= {seq2[0], seq2[SEQ_SIZE-1:1]};\n    seq3 <= {seq3[0], seq3[SEQ_SIZE-1:1]};\n    seq4 <= {seq4[0], seq4[SEQ_SIZE-1:1]};\n\n    // Update the output signal based on the input binary sequence\n    case ({seq1[NUM_SIZE-1], seq1[NUM_SIZE], seq1[NUM_SIZE+1], decoderInput})\n        4'b0000: sigOut <= 1'b0; // No delay\n        4'b0001: sigOut <= 1'b0; // No delay\n        4'b0010: sigOut <= 1'b0; // No delay\n        4'b0011: sigOut <= 1'b0; // No delay\n        4'b0100: sigOut <= 1'b0; // No delay\n        4'b0101: sigOut <= 1'b0; // No delay\n        4'b0110: sigOut <= 1'b0; // No delay\n        4'b0111: sigOut <= 1'b0; // No delay\n        4'b1000: sigOut <= 1'b0; // No delay\n        4'b1001: sigOut <= 1'b0; // No delay\n        4'b1010: sigOut <= seq2[NUM_SIZE]; // 90 degrees delay\n        4'b1011: sigOut <= seq2[NUM_SIZE+1]; // 90 degrees delay\n        4'b1100: sigOut <= seq3[NUM_SIZE]; // 180 degrees delay\n        4'b1101: sigOut <= seq3[NUM_SIZE+1]; // 180 degrees delay\n        4'b1110: sigOut <= seq4[NUM_SIZE]; // 270 degrees delay\n        4'b1111: sigOut <= seq4[NUM_SIZE+1]; // 270 degrees delay\n    endcase\nend\n\n// Initialize the binary sequences\ninitial begin\n    seq1 = 11'b01000000000; // In phase\n    seq2 = 11'b01001000000; // 90 degrees out of phase\n    seq3 = 11'b01010000000; // 180 degrees out of phase\n    seq4 = 11'b01011000000; // 270 degrees out of phase\nend\n\nendmodule",
        "module_name": "PhaseDelayMain",
        "module_hash": "01be2b83416ee08dc97d98c6540218b2",
        "dataset_index": 10916
      },
      "controllerHdl_ADC_Peripheral_To_Phase_Current_6ea3752c": {
        "rtl_code": "\n\nmodule controllerHdl_ADC_Peripheral_To_Phase_Current\n          (\n           adc_0,\n           adc_1,\n           phase_currents_0,\n           phase_currents_1\n          );\n\n\n  input   signed [17:0] adc_0;  input   signed [17:0] adc_1;  output  signed [17:0] phase_currents_0;  output  signed [17:0] phase_currents_1;  wire signed [17:0] adc [0:1];  wire signed [17:0] ADC_Zero_Offset_out1;  wire signed [19:0] Add_v;  wire signed [19:0] Add_sub_cast;  wire signed [19:0] Add_sub_cast_1;  wire signed [19:0] Add_out1 [0:1];  wire signed [17:0] ADC_Amps_Per_Driver_Unit_out1;  wire signed [37:0] Product_mul_temp;  wire signed [37:0] Product_mul_temp_1;  wire signed [17:0] phase_currents [0:1];  assign adc[0] = adc_0;\n  assign adc[1] = adc_1;\n\n  assign ADC_Zero_Offset_out1 = 18'sb000000000000000000;\n\n\n\n  assign Add_v = {ADC_Zero_Offset_out1[17], {ADC_Zero_Offset_out1, 1'b0}};\n  assign Add_sub_cast = adc[0];\n  assign Add_out1[0] = Add_sub_cast - Add_v;\n  assign Add_sub_cast_1 = adc[1];\n  assign Add_out1[1] = Add_sub_cast_1 - Add_v;\n\n\n\n  assign ADC_Amps_Per_Driver_Unit_out1 = 18'sb010100000000000000;\n\n\n\n  assign Product_mul_temp = Add_out1[0] * ADC_Amps_Per_Driver_Unit_out1;\n  assign phase_currents[0] = ((Product_mul_temp[37] == 1'b0) && (Product_mul_temp[36:34] != 3'b000) ? 18'sb011111111111111111 :\n              ((Product_mul_temp[37] == 1'b1) && (Product_mul_temp[36:34] != 3'b111) ? 18'sb100000000000000000 :\n              $signed(Product_mul_temp[34:17])));\n  assign Product_mul_temp_1 = Add_out1[1] * ADC_Amps_Per_Driver_Unit_out1;\n  assign phase_currents[1] = ((Product_mul_temp_1[37] == 1'b0) && (Product_mul_temp_1[36:34] != 3'b000) ? 18'sb011111111111111111 :\n              ((Product_mul_temp_1[37] == 1'b1) && (Product_mul_temp_1[36:34] != 3'b111) ? 18'sb100000000000000000 :\n              $signed(Product_mul_temp_1[34:17])));\n\n\n\n  assign phase_currents_0 = phase_currents[0];\n\n  assign phase_currents_1 = phase_currents[1];\n\nendmodule  ",
        "module_name": "controllerHdl_ADC_Peripheral_To_Phase_Current",
        "module_hash": "6ea3752ce5c7b2c68b690ab62bfe9e88",
        "dataset_index": 22372
      },
      "instdec_6f29f266": {
        "rtl_code": "\n\n\n\nmodule instdec (\ninput\t[31:0]\tcae_inst,\ninput\t[63:0]\tcae_data,\ninput\t\tcae_inst_vld,\n\noutput\t\tinst_val,\noutput\t[4:0]\tinst_caep,\noutput\t\tinst_aeg_wr,\noutput\t\tinst_aeg_rd,\noutput\t[17:0]\tinst_aeg_idx,\n\noutput\t\terr_unimpl\n);\n\n    reg\t\tc_val, c_aeg_wr, c_aeg_rd, c_unimpl;\n    reg [4:0]\tc_caep;\n    reg [17:0]\tc_aeg_idx;\n\n    always @* begin\n\tc_val = 'b0;\n\tc_caep = 'b0;\n\tc_aeg_wr = 'b0;\n\tc_aeg_rd = 'b0;\n\tc_aeg_idx = 'b0;\n\tc_unimpl = 'b0;\n\n\tcasex (cae_inst[28:24])\n\t5'b1101?: begin\n\t    case (cae_inst[24:18])\n\t    7'h40: begin\n\t\tc_aeg_idx = cae_inst[17:0];\n\t\tc_aeg_wr  = cae_inst_vld;\n\t    end\n\t    7'h68: begin\n\t\tc_aeg_idx = cae_data[17:0];\n\t\tc_aeg_rd  = cae_inst_vld;\n\t    end\n\t    7'h70: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:6]};\n\t\tc_aeg_rd  = cae_inst_vld;\n\t    end\n\t    default: c_unimpl = cae_inst_vld;\n\t    endcase\n\tend\n\t5'b11100: begin\n\t    case (cae_inst[23:18])\n\t    6'h18: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:12], cae_inst[5:0]};\n\t\tc_aeg_wr  = cae_inst_vld;\n\t    end\n\t    6'h20: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:12], cae_inst[5:0]};\n\t\tc_aeg_wr  = cae_inst_vld;\n\t    end\n\t    default: c_unimpl = cae_inst_vld;\n\t    endcase\n\tend\n\t5'b11101: begin\n\t    case (cae_inst[23:18])\n\t    6'h1c: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:6]};\n\t\tc_aeg_rd  = cae_inst_vld;\n\t    end\n\t    default: c_unimpl = cae_inst_vld;\n\t    endcase\n\tend\n\t5'b11110: begin\n\t    c_caep   = cae_inst[22:18];\n\t    c_val    = cae_inst_vld &  cae_inst[23];\n\t    c_unimpl = cae_inst_vld & !cae_inst[23];\n\tend\n\n\tdefault: c_unimpl = cae_inst_vld;\n\tendcase\n    end\n\n    assign inst_val = c_val;\n    assign inst_caep = c_caep;\n    assign inst_aeg_wr = c_aeg_wr;\n    assign inst_aeg_rd = c_aeg_rd;\n    assign inst_aeg_idx = c_aeg_idx;\n    assign err_unimpl = c_unimpl;\n\nendmodule\n",
        "module_name": "instdec",
        "module_hash": "6f29f266be4d62f629f236dadc4430b9",
        "dataset_index": 24367
      },
      "pcie_fc_cntl_4c2d6a59": {
        "rtl_code": "\n\n\nmodule pcie_fc_cntl \n(\ninput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\ninput\t[11:0]\t\t\t\t\t\t\tfc_cpld,\n\tinput\t[7:0]\t\t\t\t\t\t\tfc_cplh,\n\tinput\t[11:0]\t\t\t\t\t\t\tfc_npd,\n\tinput\t[7:0]\t\t\t\t\t\t\tfc_nph,\n\tinput\t[11:0]\t\t\t\t\t\t\tfc_pd,\n\tinput\t[7:0]\t\t\t\t\t\t\tfc_ph,\n\toutput\t[2:0]\t\t\t\t\t\t\tfc_sel,\n\n\tinput\t\t\t\t\t\t\t\t\ttx_cfg_req,\n\toutput\t\t\t\t\t\t\t\t\ttx_cfg_gnt,\n\tinput\t[5:0]\t\t\t\t\t\t\ttx_buf_av,\n\n\toutput\t\t\t\t\t\t\t\t\ttx_cpld_gnt,\n\toutput\t\t\t\t\t\t\t\t\ttx_mrd_gnt,\n\toutput\t\t\t\t\t\t\t\t\ttx_mwr_gnt\n);\n\nparameter\tP_RX_CONSTRAINT_FC_CPLD\t\t= 32;\nparameter\tP_RX_CONSTRAINT_FC_CPLH\t\t= 8;\n\nparameter\tP_TX_CONSTRAINT_FC_CPLD\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_CPLH\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_NPD\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_NPH\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_PD\t\t= 32;\nparameter\tP_TX_CONSTRAINT_FC_PH\t\t= 1;\n\nlocalparam\tS_RX_AVAILABLE_FC_SEL\t\t\t= 2'b01;\nlocalparam\tS_TX_AVAILABLE_FC_SEL\t\t\t= 2'b10;\n\nreg\t\t[1:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[1:0]\t\t\t\t\t\t\t\tnext_state;\n\nreg\t\t[11:0]\t\t\t\t\t\t\tr_rx_available_fc_cpld;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_rx_available_fc_cplh;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_rx_available_fc_npd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_rx_available_fc_nph;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_rx_available_fc_pd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_rx_available_fc_ph;\n\nreg\t\t[11:0]\t\t\t\t\t\t\tr_tx_available_fc_cpld;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_tx_available_fc_cplh;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_tx_available_fc_npd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_tx_available_fc_nph;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_tx_available_fc_pd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_tx_available_fc_ph;\n\nwire\t\t\t\t\t\t\t\t\tw_rx_available_fc_cpld;\nwire\t\t\t\t\t\t\t\t\tw_rx_available_fc_cplh;\n\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_cpld;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_cplh;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_npd;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_nph;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_pd;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_ph;\n\nreg\t\t[2:0]\t\t\t\t\t\t\tr_fc_sel;\nreg\t\t[1:0]\t\t\t\t\t\t\tr_rd_fc_sel;\nreg\t\t[1:0]\t\t\t\t\t\t\tr_rd_fc_sel_d1;\nreg\t\t[1:0]\t\t\t\t\t\t\tr_rd_fc_sel_d2;\n\nreg\t\t\t\t\t\t\t\t\t\tr_tx_cpld_gnt;\nreg\t\t\t\t\t\t\t\t\t\tr_tx_mrd_gnt;\nreg\t\t\t\t\t\t\t\t\t\tr_tx_mwr_gnt;\n\nassign fc_sel = r_fc_sel;\nassign tx_cfg_gnt = 1'b1;\n\nassign tx_cpld_gnt = r_tx_cpld_gnt;\nassign tx_mrd_gnt = r_tx_mrd_gnt;\nassign tx_mwr_gnt = r_tx_mwr_gnt;\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0)\n\t\tcur_state <= S_RX_AVAILABLE_FC_SEL;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_AVAILABLE_FC_SEL: begin\n\t\t\tnext_state <= S_TX_AVAILABLE_FC_SEL;\n\t\tend\n\t\tS_TX_AVAILABLE_FC_SEL: begin\n\t\t\tnext_state <= S_RX_AVAILABLE_FC_SEL;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_RX_AVAILABLE_FC_SEL;\n\t\tend\n\tendcase\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_AVAILABLE_FC_SEL: begin\n\t\t\tr_fc_sel <= 3'b000;\n\t\t\tr_rd_fc_sel <= 2'b01;\n\t\tend\n\t\tS_TX_AVAILABLE_FC_SEL: begin\n\t\t\tr_fc_sel <= 3'b100;\n\t\t\tr_rd_fc_sel <= 2'b10;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_fc_sel <= 3'b000;\n\t\t\tr_rd_fc_sel <= 2'b00;\n\t\tend\n\tendcase\nend\n\nassign w_rx_available_fc_cpld = (r_rx_available_fc_cpld > P_RX_CONSTRAINT_FC_CPLD);\nassign w_rx_available_fc_cplh = (r_rx_available_fc_cplh > P_RX_CONSTRAINT_FC_CPLH);\n\nassign w_tx_available_fc_cpld = (r_tx_available_fc_cpld > P_TX_CONSTRAINT_FC_CPLD);\nassign w_tx_available_fc_cplh = (r_tx_available_fc_cplh > P_TX_CONSTRAINT_FC_CPLH);\nassign w_tx_available_fc_npd = (r_tx_available_fc_npd > P_TX_CONSTRAINT_FC_NPD);\nassign w_tx_available_fc_nph = (r_tx_available_fc_nph > P_TX_CONSTRAINT_FC_NPH);\nassign w_tx_available_fc_pd = (r_tx_available_fc_pd > P_TX_CONSTRAINT_FC_PD);\nassign w_tx_available_fc_ph = (r_tx_available_fc_ph > P_TX_CONSTRAINT_FC_PH);\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_tx_cpld_gnt <= w_tx_available_fc_cpld & w_tx_available_fc_cplh;\n\tr_tx_mrd_gnt <= (w_tx_available_fc_npd & w_tx_available_fc_nph) & (w_rx_available_fc_cpld & w_rx_available_fc_cplh);\n\tr_tx_mwr_gnt <= w_tx_available_fc_pd & w_tx_available_fc_ph;\nend\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_rd_fc_sel_d1 <= 0;\n\t\tr_rd_fc_sel_d2 <= 0;\n\tend\n\telse begin\n\t\tr_rd_fc_sel_d1 <= r_rd_fc_sel;\n\t\tr_rd_fc_sel_d2 <= r_rd_fc_sel_d1;\n\tend\nend\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_rx_available_fc_cpld <= 0;\n\t\tr_rx_available_fc_cplh <= 0;\n\t\tr_rx_available_fc_npd <= 0;\n\t\tr_rx_available_fc_nph <= 0;\n\t\tr_rx_available_fc_pd <= 0;\n\t\tr_rx_available_fc_ph <= 0;\n\n\t\tr_tx_available_fc_cpld <= 0;\n\t\tr_tx_available_fc_cplh <= 0;\n\t\tr_tx_available_fc_npd <= 0;\n\t\tr_tx_available_fc_nph <= 0;\n\t\tr_tx_available_fc_pd <= 0;\n\t\tr_tx_available_fc_ph <= 0;\n\tend\n\telse begin\n\t\tif(r_rd_fc_sel_d2[0] == 1) begin\n\t\t\tr_rx_available_fc_cpld <= fc_cpld;\n\t\t\tr_rx_available_fc_cplh <= fc_cplh;\n\t\t\tr_rx_available_fc_npd <= fc_npd;\n\t\t\tr_rx_available_fc_nph <= fc_nph;\n\t\t\tr_rx_available_fc_pd <= fc_pd;\n\t\t\tr_rx_available_fc_ph <= fc_ph;\n\t\tend\n\t\tif(r_rd_fc_sel_d2[1] == 1) begin\n\t\t\tr_tx_available_fc_cpld <= fc_cpld;\n\t\t\tr_tx_available_fc_cplh <= fc_cplh;\n\t\t\tr_tx_available_fc_npd <= fc_npd;\n\t\t\tr_tx_available_fc_nph <= fc_nph;\n\t\t\tr_tx_available_fc_pd <= fc_pd;\n\t\t\tr_tx_available_fc_ph <= fc_ph;\n\t\tend\n\tend\nend\n\n\n\nendmodule\n\n",
        "module_name": "pcie_fc_cntl",
        "module_hash": "4c2d6a595a2d10a36e6ca4af8d836e2f",
        "dataset_index": 25803
      },
      "top__a5d97acb": {
        "rtl_code": "\nmodule top_module (\n    input CLK,\n    input CLR,\n    input LD,\n    input [3:0] DATA,\n    output [3:0] Y\n);\n// Temp Reg\nwire [3:0] counter_output;\nwire [3:0] bitwise_and_output;\n\n// Sub Modules\ncounter counter_inst (\n    .CLK(CLK),\n    .CLR(CLR),\n    .LD(LD),\n    .DATA(DATA),\n    // Output Ports\n    .Q(counter_output)\n);\n\nbitwise_and bitwise_and_inst (\n    .A(counter_output),\n    .B(DATA),\n    // Output Ports\n    .Y(bitwise_and_output)\n);\n\nfunctional_module functional_module_inst (\n    .counter_output(counter_output),\n    .bitwise_and_output(bitwise_and_output),\n    // Output Ports\n    .final_output(Y)\n);\n\nendmodule\n\nmodule counter (\n    input CLK,\n    input CLR,\n    input LD,\n    input [3:0] DATA,\n    // Output Ports\n    output reg [3:0] Q\n);\n\nalways @(posedge CLK or negedge CLR) begin\n    if (CLR == 0) begin\n        Q <= 0;\n    end else if (LD == 1) begin\n        Q <= DATA;\n    end else begin\n        Q <= Q + 1;\n        if (Q == 16) begin\n            Q <= 0;\n        end\n    end\nend\n\nendmodule\n\nmodule bitwise_and (\n    input [3:0] A,\n    input [3:0] B,\n    // Output Ports\n    output reg [3:0] Y\n);\n\nalways @(A or B) begin\n  Y = A & B;\nend\n\nendmodule\n\nmodule functional_module (\n    input [3:0] counter_output,\n    input [3:0] bitwise_and_output,\n    // Output Ports\n    output reg [3:0] final_output\n);\n\nalways @(counter_output or bitwise_and_output) begin\n  final_output = bitwise_and_output & counter_output;\nend\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "a5d97acb2dd07daddc7573d44ac3ca17",
        "dataset_index": 5237
      },
      "Multiplexer #_12ef4cbf": {
        "rtl_code": "module Multiplexer #(parameter WIDTH = 1) (\n  input wire ctrl,\n  input wire [WIDTH-1:0] D0,\n  input wire [WIDTH-1:0] D1,\n  output reg [WIDTH-1:0] S\n);\n\n  always @(*) begin\n    if (ctrl == 1'b0) begin\n      S <= D0;\n    end else begin\n      S <= D1;\n    end\n  end\n\nendmodule",
        "module_name": "Multiplexer #",
        "module_hash": "12ef4cbfe15d46ac4041f30940978e66",
        "dataset_index": 10976
      },
      "full_adder_c87beaec": {
        "rtl_code": "module full_adder(input A, input B, input Cin, output S, output Cout);\n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule",
        "module_name": "full_adder",
        "module_hash": "c87beaec2579f355ea497c50719686d7",
        "dataset_index": 1534
      },
      "NOR4X0_79909410": {
        "rtl_code": "\nmodule NOR4X0 (IN1, IN2, IN3, IN4, QN);\n\n   input IN1;\n   input IN2, IN3, IN4;\n   output QN;\n\n   wire n1, n2, n3, n4;\n\n   nand (n1, IN1, IN2);\n   nand (n2, IN3, IN4);\n   nand (n3, n1, n2);\n   nand (n4, n3, n3);\n\n   nand (QN, n4, n4);\n\nendmodule\n",
        "module_name": "NOR4X0",
        "module_hash": "79909410bc2e91b63b5bb2c07332b64d",
        "dataset_index": 18256
      },
      "FB_IOManager_dffec785": {
        "rtl_code": "`define STATE_Start 0\n\n\nmodule FB_IOManager \n\n(\n\t\tinput wire clk,\n\t\t\n\t\tinput wire DoorReleaseCanister_eI,\n\t\tinput wire ConveyorChanged_eI,\n\t\tinput wire InjectorPositionChanged_eI,\n\t\tinput wire InjectorControlsChanged_eI,\n\t\tinput wire FillContentsChanged_eI,\n\t\tinput wire StartVacuumTimer_eI,\n\t\tinput wire GoRejectArm_eI,\n\t\tinput wire CanisterCountChanged_eI,\n\t\tinput wire InjectDone_eI,\n\t\t\n\t\toutput wire InjectorArmFinishMovement_eO,\n\t\toutput wire EmergencyStopChanged_eO,\n\t\toutput wire CanisterPressureChanged_eO,\n\t\toutput wire FillContentsAvailableChanged_eO,\n\t\toutput wire LasersChanged_eO,\n\t\toutput wire DoorOverride_eO,\n\t\toutput wire VacuumTimerElapsed_eO,\n\t\t\n\t\tinput wire [7:0] ConveyorSpeed_I,\n\t\tinput wire [7:0] InjectorPosition_I,\n\t\tinput wire  InjectorContentsValveOpen_I,\n\t\tinput wire  InjectorVacuumRun_I,\n\t\tinput wire  InjectorPressurePumpRun_I,\n\t\tinput wire  FillContents_I,\n\t\tinput wire [7:0] CanisterCount_I,\n\t\t\n\t\toutput reg  EmergencyStop_O ,\n\t\toutput reg [7:0] CanisterPressure_O ,\n\t\toutput reg [7:0] FillContentsAvailable_O ,\n\t\toutput reg  DoorSiteLaser_O ,\n\t\toutput reg  InjectSiteLaser_O ,\n\t\toutput reg  RejectSiteLaser_O ,\n\t\toutput reg  RejectBinLaser_O ,\n\t\toutput reg  AcceptBinLaser_O ,\n\t\t\n\n\t\tinput reset\n);\n\n\nwire DoorReleaseCanister;\nassign DoorReleaseCanister = DoorReleaseCanister_eI;\nwire ConveyorChanged;\nassign ConveyorChanged = ConveyorChanged_eI;\nwire InjectorPositionChanged;\nassign InjectorPositionChanged = InjectorPositionChanged_eI;\nwire InjectorControlsChanged;\nassign InjectorControlsChanged = InjectorControlsChanged_eI;\nwire FillContentsChanged;\nassign FillContentsChanged = FillContentsChanged_eI;\nwire StartVacuumTimer;\nassign StartVacuumTimer = StartVacuumTimer_eI;\nwire GoRejectArm;\nassign GoRejectArm = GoRejectArm_eI;\nwire CanisterCountChanged;\nassign CanisterCountChanged = CanisterCountChanged_eI;\nwire InjectDone;\nassign InjectDone = InjectDone_eI;\n\nreg InjectorArmFinishMovement;\nassign InjectorArmFinishMovement_eO = InjectorArmFinishMovement;\nreg EmergencyStopChanged;\nassign EmergencyStopChanged_eO = EmergencyStopChanged;\nreg CanisterPressureChanged;\nassign CanisterPressureChanged_eO = CanisterPressureChanged;\nreg FillContentsAvailableChanged;\nassign FillContentsAvailableChanged_eO = FillContentsAvailableChanged;\nreg LasersChanged;\nassign LasersChanged_eO = LasersChanged;\nreg DoorOverride;\nassign DoorOverride_eO = DoorOverride;\nreg VacuumTimerElapsed;\nassign VacuumTimerElapsed_eO = VacuumTimerElapsed;\n\nreg [7:0] ConveyorSpeed ;\nreg [7:0] InjectorPosition ;\nreg  InjectorContentsValveOpen ;\nreg  InjectorVacuumRun ;\nreg  InjectorPressurePumpRun ;\nreg  FillContents ;\nreg [7:0] CanisterCount ;\n\nreg  EmergencyStop ;\nreg [7:0] CanisterPressure ;\nreg [7:0] FillContentsAvailable ;\nreg  DoorSiteLaser ;\nreg  InjectSiteLaser ;\nreg  RejectSiteLaser ;\nreg  RejectBinLaser ;\nreg  AcceptBinLaser ;\n\nreg   EmergencyStopped ; \nreg  state = `STATE_Start;\nreg entered = 1'b0;\nreg IOAlgorithm_alg_en = 1'b0; \n\nalways@(posedge clk) begin\n\n\tif(reset) begin\n\t\tstate = `STATE_Start;\n\n\t\tInjectorArmFinishMovement = 1'b0;\n\t\tEmergencyStopChanged = 1'b0;\n\t\tCanisterPressureChanged = 1'b0;\n\t\tFillContentsAvailableChanged = 1'b0;\n\t\tLasersChanged = 1'b0;\n\t\tDoorOverride = 1'b0;\n\t\tVacuumTimerElapsed = 1'b0;\n\t\t\n\t\tConveyorSpeed = 0;\n\t\tInjectorPosition = 0;\n\t\tInjectorContentsValveOpen = 0;\n\t\tInjectorVacuumRun = 0;\n\t\tInjectorPressurePumpRun = 0;\n\t\tFillContents = 0;\n\t\tCanisterCount = 0;\n\t\t\n\t\tEmergencyStop = 0;\n\t\tCanisterPressure = 0;\n\t\tFillContentsAvailable = 0;\n\t\tDoorSiteLaser = 0;\n\t\tInjectSiteLaser = 0;\n\t\tRejectSiteLaser = 0;\n\t\tRejectBinLaser = 0;\n\t\tAcceptBinLaser = 0;\n\t\tEmergencyStopped = 0;\n\tend else begin\n\n\t\tInjectorArmFinishMovement = 1'b0;\n\t\tEmergencyStopChanged = 1'b0;\n\t\tCanisterPressureChanged = 1'b0;\n\t\tFillContentsAvailableChanged = 1'b0;\n\t\tLasersChanged = 1'b0;\n\t\tDoorOverride = 1'b0;\n\t\tVacuumTimerElapsed = 1'b0;\n\t\t\n\t\tif(ConveyorChanged) begin \n\t\t\tConveyorSpeed = ConveyorSpeed_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(InjectorPositionChanged) begin \n\t\t\tInjectorPosition = InjectorPosition_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(InjectorControlsChanged) begin \n\t\t\tInjectorContentsValveOpen = InjectorContentsValveOpen_I;\n\t\t\tInjectorVacuumRun = InjectorVacuumRun_I;\n\t\t\tInjectorPressurePumpRun = InjectorPressurePumpRun_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(FillContentsChanged) begin \n\t\t\tFillContents = FillContents_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(CanisterCountChanged) begin \n\t\t\tCanisterCount = CanisterCount_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tentered = 1'b0;\n\t\tcase(state) \n\t\t\t`STATE_Start: begin\n\t\t\t\tif(1) begin\n\t\t\t\t\tstate = `STATE_Start;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\tdefault: begin\n\t\t\t\tstate = 0;\n\t\t\tend\n\t\tendcase\n\t\tIOAlgorithm_alg_en = 1'b0; \n\t\t\n\t\tif(entered) begin\n\t\t\tcase(state)\n\t\t\t\t`STATE_Start: begin\n\t\t\t\t\tIOAlgorithm_alg_en = 1'b1;\n\t\t\t\t\tEmergencyStopChanged = 1'b1;\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\tdefault: begin\n\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\tif(IOAlgorithm_alg_en) begin\n\t\t\t\n\t\tend \n\t\t\n\t\tif(EmergencyStopChanged) begin \n\t\t\tEmergencyStop_O = EmergencyStop;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(CanisterPressureChanged) begin \n\t\t\tCanisterPressure_O = CanisterPressure;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(FillContentsAvailableChanged) begin \n\t\t\tFillContentsAvailable_O = FillContentsAvailable;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(LasersChanged) begin \n\t\t\tDoorSiteLaser_O = DoorSiteLaser;\n\t\t\tInjectSiteLaser_O = InjectSiteLaser;\n\t\t\tRejectSiteLaser_O = RejectSiteLaser;\n\t\t\tRejectBinLaser_O = RejectBinLaser;\n\t\t\tAcceptBinLaser_O = AcceptBinLaser;\n\t\t\t\n\t\tend\n\t\t\n\t\tend\nend\nendmodule",
        "module_name": "FB_IOManager",
        "module_hash": "dffec785b202de23946d9baefd7318ac",
        "dataset_index": 22786
      },
      "io_mux_47659a65": {
        "rtl_code": "module  io_mux (\n\na_din,\n    a_dout,\n    a_dout_en,\n\nb_din,\n    b_dout,\n    b_dout_en,\n\nio_din,\n    io_dout,\n    io_dout_en,\n\nsel\n);\n\nparameter          WIDTH = 8;\n   \noutput [WIDTH-1:0] a_din;\ninput  [WIDTH-1:0] a_dout;\ninput  [WIDTH-1:0] a_dout_en;\n\noutput [WIDTH-1:0] b_din;\ninput  [WIDTH-1:0] b_dout;\ninput  [WIDTH-1:0] b_dout_en;\n\ninput  [WIDTH-1:0] io_din;\noutput [WIDTH-1:0] io_dout;\noutput [WIDTH-1:0] io_dout_en;\n\ninput  [WIDTH-1:0] sel;\n\n\nfunction [WIDTH-1:0] mux (\n   input [WIDTH-1:0] A,\n   input [WIDTH-1:0] B,\n   input [WIDTH-1:0] SEL\n);\n   integer i;   \n   begin\n      mux = {WIDTH{1'b0}};\n      for (i = 0; i < WIDTH; i = i + 1)\n\tmux[i] = sel[i] ? B[i] : A[i];\n   end\nendfunction\n\n\nassign a_din      = mux(       io_din, {WIDTH{1'b0}}, sel);\nassign b_din      = mux({WIDTH{1'b0}},        io_din, sel);\nassign io_dout    = mux(       a_dout,        b_dout, sel);\nassign io_dout_en = mux(    a_dout_en,     b_dout_en, sel);\n\n\t   \nendmodule ",
        "module_name": "io_mux",
        "module_hash": "47659a65cb190123f6e73266fad74b49",
        "dataset_index": 7175
      },
      "and_gate_ctrl_63012dbd": {
        "rtl_code": "module and_gate_ctrl (\n    input A,\n    input B,\n    input C1,\n    output Y\n);\n\n    assign Y = (C1 == 1'b1) ? (A & B) : 1'b0;\n\nendmodule",
        "module_name": "and_gate_ctrl",
        "module_hash": "63012dbdbc8acb438177ef1e2e39ee06",
        "dataset_index": 21057
      },
      "mc_crt_ba3ec733": {
        "rtl_code": "\n\nmodule mc_crt\n  (\n   input\t      mclock,\n   input\t      reset_n,\n   input              pixclk,\n   input\t      crt_clock,\n   input\t      crt_gnt,\n   input\t      crt_req,\n   input [20:0]\t      crt_org,\n   input [4:0]\t      crt_page,\n   input [11:0]\t      crt_ptch,\n   input [9:0]\t      crt_x,\n   input [11:0]\t      crt_y,\n   \n   output reg\t      crt_ready,\n   output reg\t      crt_arb_req,\n   output reg [4:0]   crt_arb_page,\n   output reg [20:0]  crt_arb_addr\n   );\n  \n  reg\t\tcapt_req;\n  reg [20:0]\tcapt_org;\n  reg [11:0]\tcapt_ptch;\n  reg [9:0]\tcapt_x;\n  reg [11:0]\tcapt_y;\n  reg [4:0]\tcapt_page;\n\n  reg\t\treq_sync_m1, req_sync_1, req_sync_2, req_sync_3;\n  reg\t\tgnt_sync_1, gnt_sync_2, gnt_sync_3;\n  reg [20:0] \tpmult, int_add;\n  \n  reg\t\tfinal_grant; reg [1:0] \trequests;\n  reg \t\thold_req;\n  \n  wire \t\treq_toggle;\n\n  always @ (posedge pixclk or negedge reset_n) begin\n    if(!reset_n) begin\n      crt_ready <= 1'b1;\n      capt_req  <= 1'b0;\n      capt_org  <= 21'h0;\n      capt_ptch <= 12'b0;\n      capt_x    <= 10'b0;\n      capt_y    <= 12'b0;\n      capt_page <= 5'b0;\n      gnt_sync_1<= 1'b0;\n      gnt_sync_2<= 1'b0;\n      gnt_sync_3<= 1'b0;\n    end else if (crt_clock) begin\n      if (crt_req) begin\n\tcapt_req <= ~capt_req;\n\tcapt_org <= crt_org;\n\tcapt_ptch <= crt_ptch;\n\tcapt_x <= crt_x;\n\tcapt_y <= crt_y;\n\tcapt_page <= crt_page - 5'b1;\n\tcrt_ready <= 1'b0;\n      end gnt_sync_1 <= final_grant;\n      gnt_sync_2 <= gnt_sync_1;\n      gnt_sync_3 <= gnt_sync_2;\n      if(gnt_sync_2 ^ gnt_sync_3) crt_ready <= 1'b1;\n    end end assign req_toggle = req_sync_2 ^ req_sync_3;\n  \n  always @ (posedge mclock or negedge reset_n) begin\n    if(!reset_n) begin\n      crt_arb_req  <= 1'b0;\n      final_grant  <= 1'b0; requests     <= 2'b0;\n      hold_req     <= 1'b0;\n      pmult        <= 21'b0;\n      int_add      <= 21'b0;\n      req_sync_m1  <= 1'b0;\n      req_sync_1   <= 1'b0;\n      req_sync_2   <= 1'b0;\n      req_sync_3   <= 1'b0;\n      crt_arb_req  <= 1'b0;\n      crt_arb_page <= 5'b0;\n      crt_arb_addr <= 21'b0;\n    end else begin\n\n      case ({crt_gnt, req_toggle})\n\t2'b01: requests <= requests + 2'b1;\n\t2'b10: requests <= requests - 2'b1;\n      endcase\n      \n      pmult <= (capt_y * {{4{capt_ptch[11]}}, capt_ptch});\nint_add <= (capt_org + {{11{capt_x[9]}}, capt_x});\n      \n      req_sync_m1 <= capt_req; req_sync_1 <= req_sync_m1;\n      req_sync_2 <= req_sync_1;\n      req_sync_3 <= req_sync_2;\n\n      if (hold_req && ~&requests[1]) begin\n\thold_req <= 0;\n\tcrt_arb_req <= 1'b1;\n\tcrt_arb_page <= capt_page;\n\tcrt_arb_addr <= pmult + int_add;\n      end else if(req_toggle && ~&requests[1]) begin\n\tcrt_arb_req <= 1'b1;\n\tcrt_arb_page <= capt_page;\n\tcrt_arb_addr <= pmult + int_add;\n      end else if(req_toggle && (&requests[1])) begin\n\thold_req <= 1;\n      end if(crt_gnt) begin\n\tcrt_arb_req <= 1'b0;\n\tfinal_grant <= ~final_grant;\n      end end end endmodule\n",
        "module_name": "mc_crt",
        "module_hash": "ba3ec733d56fbc6bd4b8b61051e2c386",
        "dataset_index": 5780
      },
      "int_to_float_c21ce0b2": {
        "rtl_code": "module int_to_float(\n        input_a,\n        input_a_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [31:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  output    [31:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [31:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [2:0] state;\n  parameter get_a         = 3'd0,\n            convert_0     = 3'd1,\n            convert_1     = 3'd2,\n            convert_2     = 3'd3,\n            round         = 3'd4,\n            pack          = 3'd5,\n            put_z         = 3'd6;\n\n  reg [31:0] a, z, value;\n  reg [23:0] z_m;\n  reg [7:0] z_r;\n  reg [7:0] z_e;\n  reg z_s;\n  reg guard, round_bit, sticky;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= convert_0;\n        end\n      end\n\n      convert_0:\n      begin\n        if ( a == 0 ) begin\n          z_s <= 0;\n          z_m <= 0;\n          z_e <= -127;\n          state <= pack;\n        end else begin\n          value <= a[31] ? -a : a;\n          z_s <= a[31];\n          state <= convert_1;\n        end\n      end\n\n      convert_1:\n      begin\n        z_e <= 31;\n        z_m <= value[31:8];\n        z_r <= value[7:0];\n        state <= convert_2;\n      end\n\n      convert_2:\n      begin\n        if (!z_m[23]) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= z_r[7];\n          z_r <= z_r << 1;\n        end else begin\n          guard <= z_r[7];\n          round_bit <= z_r[6];\n          sticky <= z_r[5:0] != 0;\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit || sticky || z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 24'hffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[22 : 0] <= z_m[22:0];\n        z[30 : 23] <= z_e + 127;\n        z[31] <= z_s;\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n",
        "module_name": "int_to_float",
        "module_hash": "c21ce0b2e390b6694b22086fd647343e",
        "dataset_index": 21676
      },
      "clock_gate_93fc5d52": {
        "rtl_code": "module clock_gate(\n  input CLK, // clock input\n  input EN, // enable input\n  input TE, // test enable input\n  output reg ENCLK // clock gated output\n);\n\n  always @ (posedge CLK) begin\n    if (EN && TE) begin\n      ENCLK <= 1'b1;\n    end\n    else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "93fc5d52c927010c69a8324c7416761d",
        "dataset_index": 5818
      },
      "my__efb105ef": {
        "rtl_code": "\nmodule my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    nor (X, A1, A2);\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "efb105efed3f8da50488e6b31d450bb7",
        "dataset_index": 4543
      },
      "reverse_byte_order_3aa6bd86": {
        "rtl_code": "\nmodule reverse_byte_order(\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output reg sum,\n    output reg cout\n);\n\n    always @ (a or b or cin) begin\n        {cout, sum} = a + b + cin;\n    end\n\nendmodule\nmodule adder_with_carry_in(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [4:0] sum\n);\n\n    wire c1, c2, c3;\n\n    full_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder fa2(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa3(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa4(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\nmodule top_module(\n    input [31:0] in1,\n    input [31:0] in2,\n    input cin,\n    output [31:0] out\n);\n\n    wire [31:0] rev_in1, rev_in2;\n    wire [4:0] sum;\n\n    reverse_byte_order rbo1(.in(in1), .out(rev_in1));\n    reverse_byte_order rbo2(.in(in2), .out(rev_in2));\n    adder_with_carry_in awci(.a(rev_in1[3:0]), .b(rev_in2[3:0]), .cin(cin), .sum(sum));\n    reverse_byte_order rbo3(.in({sum[4], sum[3:0], 27'b0}), .out(out));\n\nendmodule",
        "module_name": "reverse_byte_order",
        "module_hash": "3aa6bd86e4a4cc51e1056667ebbb8113",
        "dataset_index": 10193
      },
      "full_adder_608847cc": {
        "rtl_code": "module full_adder (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\n    wire C1, S1, C2;\n    fa fa1 (\n        .A(A),\n        .B(B),\n        .CI(CIN),\n        .S(S1),\n        .CO(C1)\n    );\n    fa fa2 (\n        .A(S1),\n        .B(C1),\n        .CI(1'b0),\n        .S(SUM),\n        .CO(C2)\n    );\n    assign COUT = C1 | C2;\n\nendmodule \n\nmodule fa (\n    input A,\n    input B,\n    input CI,\n    output S,\n    output CO\n);\n\n    assign {CO, S} = A + B + CI;\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "608847cc050cbc31fa930e4d8e7d7102",
        "dataset_index": 4659
      },
      "Seven_seg_84a63712": {
        "rtl_code": "module Seven_seg(clk, reset, DAT_I, STB, DAT_O, ACK, WE, Segment, AN, debug_data_hold);\n    input clk, reset;\n    input [31: 0] DAT_I;\n    input STB;\n    input WE;\n    output reg [3: 0] AN;\n    output [7: 0] Segment;\n    output [31: 0] DAT_O;\n    output ACK;\n    output [15: 0] debug_data_hold;\n\n    reg [7: 0] digit_seg, digit;\n    reg [15: 0] data_hold = 16'h2333;\n    reg [31: 0] cnt = 0;\n\n    wire [1: 0] scan;\n\n    always @(posedge clk) begin\n        cnt <= cnt + 1;\n    end\n\n    assign scan = cnt[18: 17];\n\n    assign ACK = STB;\n\n    assign Segment = digit_seg;\n    assign DAT_O = Segment;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) data_hold <= 16'h2333;\n        else data_hold <= STB ? DAT_I : data_hold;\n    end\n\n    always @* begin\n        case(scan)\n            0: AN = 4'b1110;\n            1: AN = 4'b1101;\n            2: AN = 4'b1011;\n            3: AN = 4'b0111;\n        endcase\n    end\n\n    always @* begin\n        case(scan)\n            0: digit = data_hold[3: 0];\n            1: digit = data_hold[7: 4];\n            2: digit = data_hold[11: 8];\n            3: digit = data_hold[15: 12];\n        endcase\n    end\n\n    always @* begin\n        case(digit)\n            4'b0000: digit_seg = 8'b11000000;\n            4'b0001: digit_seg = 8'b11111001;\n            4'b0010: digit_seg = 8'b10100100;\n            4'b0011: digit_seg = 8'b10110000;\n            4'b0100: digit_seg = 8'b10011001;\n            4'b0101: digit_seg = 8'b10010010;\n            4'b0110: digit_seg = 8'b10000010;\n            4'b0111: digit_seg = 8'b11111000;\n            4'b1000: digit_seg = 8'b10000000;\n            4'b1001: digit_seg = 8'b10010000;\n            4'b1010: digit_seg = 8'b10001000;\n            4'b1011: digit_seg = 8'b10000011;\n            4'b1100: digit_seg = 8'b11000110;\n            4'b1101: digit_seg = 8'b10100001;\n            4'b1110: digit_seg = 8'b10000110;\n            4'b1111: digit_seg = 8'b10001110;\n        endcase\n    end\n\n    assign debug_data_hold = data_hold;\n\nendmodule\n",
        "module_name": "Seven_seg",
        "module_hash": "84a6371209b8ce26b0e64966bf45007f",
        "dataset_index": 19828
      },
      "drp_other_registers#_6b9ef748": {
        "rtl_code": "\n\nmodule  drp_other_registers#(\n    parameter DRP_ABITS =       8,\n    parameter DRP_REG0 =        8,\n    parameter DRP_REG1 =        9,\n    parameter DRP_REG2 =       10,\n    parameter DRP_REG3 =       11\n)(\n    input                   drp_rst,\n    input                   drp_clk,\n    input                   drp_en, input                   drp_we,\n    input   [DRP_ABITS-1:0] drp_addr,       \n    input            [15:0] drp_di,\n    output reg              drp_rdy,\n    output reg       [15:0] drp_do,\n    output           [15:0] drp_register0,\n    output           [15:0] drp_register1,\n    output           [15:0] drp_register2,\n    output           [15:0] drp_register3\n);\n    \n    reg           [DRP_ABITS-1:0] drp_addr_r;\n    reg                           drp_wr_r;\n    reg                    [ 1:0] drp_rd_r;\n    reg                    [15:0] drp_di_r;\n    reg                           drp_reg0_set;\n    reg                           drp_reg1_set;\n    reg                           drp_reg2_set;\n    reg                           drp_reg3_set;\n    reg                           drp_reg0_get;\n    reg                           drp_reg1_get;\n    reg                           drp_reg2_get;\n    reg                           drp_reg3_get;\n    \n    reg                    [15:0] drp_register0_r;\n    reg                    [15:0] drp_register1_r;\n    reg                    [15:0] drp_register2_r;\n    reg                    [15:0] drp_register3_r;\n    \n    assign drp_register0 = drp_register0_r;\n    assign drp_register1 = drp_register1_r;\n    assign drp_register2 = drp_register2_r;\n    assign drp_register3 = drp_register3_r;\n    \n    always @ (posedge drp_clk) begin\n        drp_addr_r <=           drp_addr;\n        drp_wr_r <=             drp_we && drp_en;\n        drp_rd_r <=             {drp_rd_r[0],~drp_we & drp_en};\n        drp_di_r <=             drp_di;\n        \n        drp_reg0_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG0);\n        drp_reg1_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG1);\n        drp_reg2_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG2);\n        drp_reg3_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG3);\n        drp_reg0_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG0);       \n        drp_reg1_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG1);       \n        drp_reg2_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG2);       \n        drp_reg3_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG3);       \n        \n        drp_rdy <=              drp_wr_r || drp_rd_r[1];\n        drp_do <=               ({16{drp_reg0_get}} & drp_register0_r) |\n                                ({16{drp_reg1_get}} & drp_register1_r) |\n                                ({16{drp_reg2_get}} & drp_register2_r) |\n                                ({16{drp_reg3_get}} & drp_register3_r);\n                                \n        if      (drp_rst)       drp_register0_r <= 0;\n        else if (drp_reg0_set)  drp_register0_r <= drp_di_r;\n        \n        if      (drp_rst)       drp_register1_r <= 0;\n        else if (drp_reg1_set)  drp_register1_r <= drp_di_r;\n        \n        if      (drp_rst)       drp_register2_r <= 0;\n        else if (drp_reg2_set)  drp_register2_r <= drp_di_r;\n        \n        if      (drp_rst)       drp_register3_r <= 0;\n        else if (drp_reg3_set)  drp_register3_r <= drp_di_r;\n        \n    end\n\nendmodule\n\n",
        "module_name": "drp_other_registers#",
        "module_hash": "6b9ef748d831a083dfe42772407410d0",
        "dataset_index": 16798
      },
      "uart51_rx_dbfbf133": {
        "rtl_code": "module uart51_rx(\nRESET_N,\nBAUD_CLK,\nRX_DATA,\nRX_BUFFER,\nRX_WORD,\nRX_PAR_DIS,\nRX_PARITY,\nPARITY_ERR,\nFRAME,\nREADY\n);\ninput\t\t\t\t\tRESET_N;\ninput\t\t\t\t\tBAUD_CLK;\ninput\t\t\t\t\tRX_DATA;\noutput\t[7:0]\t\tRX_BUFFER;\nreg\t\t[7:0]\t\tRX_BUFFER;\ninput\t\t[1:0]\t\tRX_WORD;\ninput\t\t\t\t\tRX_PAR_DIS;\ninput\t\t[1:0]\t\tRX_PARITY;\noutput\t\t\t\tPARITY_ERR;\nreg\t\t\t\t\tPARITY_ERR;\noutput\t\t\t\tFRAME;\nreg\t\t\t\t\tFRAME;\noutput\t\t\t\tREADY;\nreg\t\t\t\t\tREADY;\nreg\t\t[5:0]\t\tSTATE;\nreg\t\t[2:0]\t\tBIT;\nreg\t\t\t\t\tRX_DATA0;\nreg\t\t\t\t\tRX_DATA1;\n\nalways @ (posedge BAUD_CLK or negedge RESET_N)\nbegin\n\tif(!RESET_N)\n\tbegin\n\t\tRX_BUFFER <= 8'h00;\n\t\tSTATE <= 6'b000000;\n\t\tFRAME <= 1'b0;\n\t\tBIT <= 3'b000;\n\t\tRX_DATA0 <= 1'b1;\n\t\tRX_DATA1 <= 1'b1;\n\t\tREADY <= 1'b0;\n\tend\n\telse\n\tbegin\n\t\tRX_DATA0 <= RX_DATA;\n\t\tRX_DATA1 <= RX_DATA0;\n\t\tcase (STATE)\n\t\t6'b000000:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tBIT <= 3'b000;\n\t\t\tif(~RX_DATA1)\n\t\t\t\tSTATE <= 6'b000001;\n\t\tend\n\t\t6'b001111:\t\t\t\t\t\t\t\tbegin\t\t\t\t\t\t\t\t\t\tREADY <= 1'b0;\n\t\t\tSTATE <= 6'b010000;\n\t\tend\n\t\t6'b010111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tRX_BUFFER[BIT] <= RX_DATA1;\n\t\t\tSTATE <= 6'b011000;\n\t\tend\n\t\t6'b011111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tif(BIT == 3'b111)\n\t\t\tbegin\n\t\t\t\tSTATE <= 6'b100000;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif((RX_WORD == 2'b01) && (BIT == 3'b110))\n\t\t\t\tbegin\n\t\t\t\t\tSTATE <= 6'b100000;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif((RX_WORD == 2'b10) && (BIT == 3'b101)) \n\t\t\t\t\tbegin\n\t\t\t\t\t\tSTATE <= 6'b100000;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif((RX_WORD == 2'b11) && (BIT == 3'b100))\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tSTATE <= 6'b100000;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tBIT <= BIT + 1'b1;\n\t\t\t\t\t\t\tSTATE <= 6'b010000;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t6'b100000:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tif(RX_PAR_DIS)\n\t\t\t\tSTATE <= 6'b110001;\t\telse\n\t\t\t\tSTATE <= 6'b100001;\t\tend\n\t\t6'b100111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tPARITY_ERR <= ~RX_PARITY[1] &\t\t\t\t\t\t\t\t\t\t\t(((RX_BUFFER[0] ^ RX_BUFFER[1])\n\t\t\t\t\t\t\t ^ (RX_BUFFER[2] ^ RX_BUFFER[3]))\n\n\t\t\t\t\t\t\t ^((RX_BUFFER[4] ^ RX_BUFFER[5])\n\t\t\t\t\t\t\t ^ (RX_BUFFER[6] ^ RX_BUFFER[7]))\t^ (~RX_PARITY[0] ^ RX_DATA1));\n\t\t\tSTATE <= 6'b101000;\nend\n\t\t6'b110111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tFRAME <= !RX_DATA1;\t\t\tREADY <= 1'b1;\n\t\t\tSTATE <= 6'b111000;\n\t\tend\n6'b111000:\n\t\tbegin\n\t\t\tif(RX_DATA1)\n\t\t\t\tSTATE <= 6'b000000;\n\t\tend\n\t\tdefault: STATE <= STATE + 1'b1;\n\t\tendcase\n\tend\nend\nendmodule\n",
        "module_name": "uart51_rx",
        "module_hash": "dbfbf133ed6fa722a3ba3b8872223949",
        "dataset_index": 12288
      },
      "analinput_de19ae11": {
        "rtl_code": "module analinput(clk, pay, pby, miso, mosi, cs, sck);\nparameter PADDLESIZE = 0;\nparameter SCREENHEIGHT = 0;\ninput clk;\noutput reg[9:0] pay;\noutput reg[9:0] pby;\ninput miso;\noutput reg mosi;\noutput reg cs;\noutput sck;\n\nparameter state0 = 0, state1 = 1, state2 = 2, state3 = 3;\n\nreg [1:0] state;\n\nreg [4:0] sckcount;\nreg [11:0] datain;\n\nreg ab;\n\nassign sck = clk;\n\nalways @(posedge sck) begin\n\tcase(state)\n\tstate0:\n\t\tbegin\n\t\t\tab <= 1;\n\t\t\tstate <= state1;\n\t\tend\n\tstate1: \n\t\tbegin\n\t\t\tab <= !ab;\n\t\t\tcs <= 0;\n\t\t\tmosi <= !ab;\n\t\t\tsckcount <= 15;\n\t\t\tstate <= state2;\n\t\tend\n\tstate2:\n\t\tbegin\n\t\t\tif (sckcount != 0) \n\t\t\t\tsckcount <= sckcount - 1'b1;\n\t\t\telse \n\t\t\t\tstate <= state3;\n\t\tend\n\tstate3:\n\t\tbegin\n\t\t\tcs <= 1;\n\t\t\tmosi <= 0;\n\t\t\tif (ab == 0) begin\n\t\t\t\tpay <= paddlelimiter(datain[7:0], PADDLESIZE, SCREENHEIGHT);\n\t\t\tend else begin\n\t\t\t\tpby <= paddlelimiter(datain[10:8], PADDLESIZE, SCREENHEIGHT);\n\t\t\tend\n\t\t\tstate <= state1;\n\t\tend\n\tdefault:\n\t\tstate <= state0;\n\tendcase\nend\n\nalways @(negedge sck) begin\n\tif (state == state2)\n\t\tdatain <= (datain << 1) | miso; \n\telse if (state == state1)\n\t\tdatain <= 0;\nend\n\n\nfunction [9:0] paddlelimiter;\ninput [9:0] py;\ninput [3:0] paddlesize;\ninput [9:0] screenheight;\nbegin\n\tif (py < paddlesize/2) \n\t\tpaddlelimiter = paddlesize/2;\n\telse \n\tif (py > screenheight-96/2)\n\t\tpaddlelimiter = screenheight-paddlesize/2;\n\telse\n\t\tpaddlelimiter = py;\nend\nendfunction\n\n\nendmodule",
        "module_name": "analinput",
        "module_hash": "de19ae1164a15ba91ecb8cf028fcf1f8",
        "dataset_index": 10591
      },
      "and_gate_efd9f085": {
        "rtl_code": "module and_gate (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VDD;\n    supply0 VSS;\n\n    // AND gate logic\n    assign Y = A & B & C;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "efd9f08596afaf12227b1d73cc763926",
        "dataset_index": 17263
      },
      "generic_baseblocks_v2_1_mux_enc #_4fdb965f": {
        "rtl_code": "\n\n\n \nmodule generic_baseblocks_v2_1_mux_enc #\n  (\n   parameter         C_FAMILY                       = \"rtl\",\n                       parameter integer C_RATIO                        = 4,\n                       parameter integer C_SEL_WIDTH                    = 2,\n                       parameter integer C_DATA_WIDTH                   = 1\n                       )\n  (\n   input  wire [C_SEL_WIDTH-1:0]                    S,\n   input  wire [C_RATIO*C_DATA_WIDTH-1:0]           A,\n   output wire [C_DATA_WIDTH-1:0]                   O,\n   input  wire                                      OE\n   );\n  \n  wire [C_DATA_WIDTH-1:0] o_i;\n  genvar bit_cnt;\n  \n  function [C_DATA_WIDTH-1:0] f_mux\n    (\n     input [C_SEL_WIDTH-1:0] s,\n     input [C_RATIO*C_DATA_WIDTH-1:0] a\n     );\n    integer i;\n    reg [C_RATIO*C_DATA_WIDTH-1:0] carry;\n    begin\n      carry[C_DATA_WIDTH-1:0] = {C_DATA_WIDTH{(s==0)?1'b1:1'b0}} & a[C_DATA_WIDTH-1:0];\n      for (i=1;i<C_RATIO;i=i+1) begin : gen_carrychain_enc\n        carry[i*C_DATA_WIDTH +: C_DATA_WIDTH] = \n          carry[(i-1)*C_DATA_WIDTH +: C_DATA_WIDTH] |\n          ({C_DATA_WIDTH{(s==i)?1'b1:1'b0}} & a[i*C_DATA_WIDTH +: C_DATA_WIDTH]);\n      end\n      f_mux = carry[C_DATA_WIDTH*C_RATIO-1:C_DATA_WIDTH*(C_RATIO-1)];\n    end\n  endfunction\n  \n  function [C_DATA_WIDTH-1:0] f_mux4\n    (\n     input [1:0] s,\n     input [4*C_DATA_WIDTH-1:0] a\n     );\n    integer i;\n    reg [4*C_DATA_WIDTH-1:0] carry;\n    begin\n      carry[C_DATA_WIDTH-1:0] = {C_DATA_WIDTH{(s==0)?1'b1:1'b0}} & a[C_DATA_WIDTH-1:0];\n      for (i=1;i<4;i=i+1) begin : gen_carrychain_enc\n        carry[i*C_DATA_WIDTH +: C_DATA_WIDTH] = \n          carry[(i-1)*C_DATA_WIDTH +: C_DATA_WIDTH] |\n          ({C_DATA_WIDTH{(s==i)?1'b1:1'b0}} & a[i*C_DATA_WIDTH +: C_DATA_WIDTH]);\n      end\n      f_mux4 = carry[C_DATA_WIDTH*4-1:C_DATA_WIDTH*3];\n    end\n  endfunction\n  \n  assign O = o_i & {C_DATA_WIDTH{OE}};  generate\n    if ( C_RATIO < 2 ) begin : gen_bypass\n      assign o_i = A;\n    end else if ( C_FAMILY == \"rtl\" || C_RATIO < 5 ) begin : gen_rtl\n      assign o_i = f_mux(S, A);\n      \n    end else begin : gen_fpga\n      wire [C_DATA_WIDTH-1:0] l;\n      wire [C_DATA_WIDTH-1:0] h;\n      wire [C_DATA_WIDTH-1:0] ll;\n      wire [C_DATA_WIDTH-1:0] lh;\n      wire [C_DATA_WIDTH-1:0] hl;\n      wire [C_DATA_WIDTH-1:0] hh;\n      \n      case (C_RATIO)\n        1, 5, 9, 13: \n          assign hh = A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH];\n        2, 6, 10, 14:\n          assign hh = S[0] ? \n            A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n            A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] ;\n        3, 7, 11, 15:\n          assign hh = S[1] ? \n            A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n            (S[0] ? \n              A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[(C_RATIO-3)*C_DATA_WIDTH +: C_DATA_WIDTH] );\n        4, 8, 12, 16:\n          assign hh = S[1] ? \n            (S[0] ? \n              A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] ) :\n            (S[0] ? \n              A[(C_RATIO-3)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[(C_RATIO-4)*C_DATA_WIDTH +: C_DATA_WIDTH] );\n        17:\n          assign hh = S[1] ? \n            (S[0] ? \n              A[15*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[14*C_DATA_WIDTH +: C_DATA_WIDTH] ) :\n            (S[0] ? \n              A[13*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[12*C_DATA_WIDTH +: C_DATA_WIDTH] );\n        default:\n          assign hh = 0; \n      endcase\n\n      case (C_RATIO)\n        5, 6, 7, 8: begin\n          assign l = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_5_8\n            MUXF7 mux_s2_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[2]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        9, 10, 11, 12: begin\n          assign ll = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);\n          assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_9_12\n            MUXF7 muxf_s2_low_inst \n            (\n             .I0  (ll[bit_cnt]),\n             .I1  (lh[bit_cnt]),\n             .S   (S[2]),\n             .O   (l[bit_cnt])\n            ); \n            MUXF8 muxf_s3_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[3]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        13,14,15,16: begin\n          assign ll = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);\n          assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          assign hl = f_mux4(S[1:0], A[8*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_13_16\n            MUXF7 muxf_s2_low_inst \n            (\n             .I0  (ll[bit_cnt]),\n             .I1  (lh[bit_cnt]),\n             .S   (S[2]),\n             .O   (l[bit_cnt])\n            ); \n            MUXF7 muxf_s2_hi_inst \n            (\n             .I0  (hl[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[2]),\n             .O   (h[bit_cnt])\n            );\n          \n            MUXF8 muxf_s3_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (h[bit_cnt]),\n             .S   (S[3]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        17: begin\n          assign ll = S[4] ? A[16*C_DATA_WIDTH +: C_DATA_WIDTH] : f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);  assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          assign hl = f_mux4(S[1:0], A[8*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_17\n            MUXF7 muxf_s2_low_inst \n            (\n             .I0  (ll[bit_cnt]),\n             .I1  (lh[bit_cnt]),\n             .S   (S[2]),\n             .O   (l[bit_cnt])\n            ); \n            MUXF7 muxf_s2_hi_inst \n            (\n             .I0  (hl[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[2]),\n             .O   (h[bit_cnt])\n            ); \n            MUXF8 muxf_s3_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (h[bit_cnt]),\n             .S   (S[3]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        default:  assign o_i = f_mux(S, A);\n      endcase\n    end  endgenerate\nendmodule\n",
        "module_name": "generic_baseblocks_v2_1_mux_enc #",
        "module_hash": "4fdb965f9b0446f264837c2203dea3bc",
        "dataset_index": 25854
      },
      "gpio_wb #_c35df79e": {
        "rtl_code": "module gpio_wb #(parameter BASE_ADDR = 32'h00000400) (\n    \n    input clk_i, \n    input rst_i,\n    \n    input      [31:0] dat_i, \n    output reg [31:0] dat_o, \n    input      [31:0] adr_i, \n    input      we_i, \n    input      [3:0] sel_i, \n    input      cyc_i, \n    input      stb_i, \n    output reg ack_o,\n    \n    input [15:0] sw_bi,\n    output reg [15:0] gpio_bo\n);\n\nlocalparam IDLE = 0;\nlocalparam ACK  = 1;\n\nwire read  = cyc_i & stb_i & !we_i;\nwire write = cyc_i & stb_i & we_i;\n    \nreg state_r;\n    \nalways@(posedge clk_i, posedge rst_i)\n    if(rst_i) begin\n        state_r  <= 0;\n        ack_o    <= 1'b0;\n        gpio_bo  <= 0;\n        dat_o    <= 0;\n    end else begin\n    \n        ack_o <= 1'b0;\n        \n        case(state_r)\n            IDLE: \n                begin\n                    if(write) begin\n                        if(adr_i == BASE_ADDR)\n                            gpio_bo <= dat_i[15:0];\n                        ack_o   <= 1'b1;\n                        state_r <= ACK; \n                    end else if(read) begin\n                        dat_o <= (adr_i == BASE_ADDR)? sw_bi: 0;\n                        state_r <= ACK;\n                    end\n                end\n            ACK:\n                begin\n                    ack_o   <= 1'b1;\n                    state_r <= IDLE;\n                end\n        endcase\n    end\n\n\nendmodule\n",
        "module_name": "gpio_wb #",
        "module_hash": "c35df79ef8c381595a2802c3ddd8f824",
        "dataset_index": 24446
      },
      "bitwise_or_logical_not_059fc16e": {
        "rtl_code": "module bitwise_or_logical_not(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR using XOR and inverter gates\n    wire [2:0] xor_result;\n    assign xor_result = a ^ b;\n    assign out_or_bitwise = ~xor_result;\n\n    // Logical OR using AND and OR gates\n    wire [2:0] and_result;\n    assign and_result = a & b;\n    assign out_or_logical = |and_result;\n\n    // NOT using inverter gates\n    wire [2:0] not_a;\n    wire [2:0] not_b;\n    assign not_a = ~a;\n    assign not_b = ~b;\n    assign out_not = {not_a, not_b};\n\nendmodule",
        "module_name": "bitwise_or_logical_not",
        "module_hash": "059fc16e57f6a919559a57e8ad32bb8b",
        "dataset_index": 5121
      },
      "bar #_03f9c6b6": {
        "rtl_code": "module bar #(parameter OP_ADD = 2'b00) (\n   input [3:0] a,\n   input [3:0] b,\n   input [1:0] sel,\n   output reg [3:0] result\n);\n   \n   always @(*) begin\n      case(sel)\n         2'b00: result = a + b;\n         2'b01: result = a + ~b + 1;\n         2'b10: result = a & b;\n         2'b11: result = a | b;\n         default: result = 4'b0;\n      endcase\n   end\n   \n   assign sel[1:0] = OP_ADD; // set sel value for addition operation\n   \nendmodule",
        "module_name": "bar #",
        "module_hash": "03f9c6b6e283d48fce122daab7cd9b1f",
        "dataset_index": 12756
      },
      "xnor2_fc8c64b8": {
        "rtl_code": "module xnor2 (\n    Y   ,\n    A   ,\n    B   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    wire A_inv, B_inv, A_B, A_inv_B_inv;\n    \n    // Invert A and B\n    not (A_inv, A);\n    not (B_inv, B);\n    \n    // AND A and B\n    and (A_B, A, B);\n    \n    // AND inverted A and inverted B\n    and (A_inv_B_inv, A_inv, B_inv);\n    \n    // OR the results of the two AND gates\n    or (Y, A_B, A_inv_B_inv);\n\nendmodule",
        "module_name": "xnor2",
        "module_hash": "fc8c64b8d7afd65c3200d68d6a174ba3",
        "dataset_index": 1385
      },
      "counter_21cefbd3": {
        "rtl_code": "module counter\n    (input clk, rst, up_down,\n     output reg [1:0] count);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 2'b0;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "21cefbd3fbebc2da09ab9ddd8452dc58",
        "dataset_index": 4331
      },
      "transition_detector_2ae7c513": {
        "rtl_code": "module transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nreg [31:0] in_reg1, in_reg2, in_reg3, in_reg4;\nreg [31:0] out_reg1, out_reg2, out_reg3, out_reg4;\n\nalways @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n        in_reg1 <= 0;\n        in_reg2 <= 0;\n        in_reg3 <= 0;\n        in_reg4 <= 0;\n        out_reg1 <= 0;\n        out_reg2 <= 0;\n        out_reg3 <= 0;\n        out_reg4 <= 0;\n    end\n    else begin\n        in_reg1 <= in;\n        in_reg2 <= in_reg1;\n        in_reg3 <= in_reg2;\n        in_reg4 <= in_reg3;\n        \n        if (in_reg4 == 32'hFFFFFFFF) begin\n            out_reg1 <= 0;\n            out_reg2 <= 0;\n            out_reg3 <= 0;\n            out_reg4 <= 0;\n        end\n        else if (in_reg4 == 32'hFFFFFFFE) begin\n            out_reg1 <= 1;\n            out_reg2 <= 1;\n            out_reg3 <= 1;\n            out_reg4 <= 1;\n        end\n        else begin\n            out_reg1 <= out_reg2;\n            out_reg2 <= out_reg3;\n            out_reg3 <= out_reg4;\n            out_reg4 <= 0;\n        end\n    end\nend\n\nassign out = out_reg1;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\ntransition_detector td (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule",
        "module_name": "transition_detector",
        "module_hash": "2ae7c5131988a31f429727420a271c26",
        "dataset_index": 9862
      },
      "clock_gate_d_ff_1c09765f": {
        "rtl_code": "module clock_gate_d_ff (\n    input clk,\n    input en,\n    input en_ff,\n    input [31:0] data,\n    output reg q\n);\n\n    wire gated_clk = clk & en; // create a gated clock signal\n    \n    always @(posedge gated_clk) begin // use the gated clock for the flip-flop\n        if (en_ff) begin // only update the output when enabled\n            q <= data;\n        end\n    end\n    \nendmodule",
        "module_name": "clock_gate_d_ff",
        "module_hash": "1c09765f72594ae0f7905b3321735ff2",
        "dataset_index": 13993
      },
      "binary_counter_f8e1d5eb": {
        "rtl_code": "module binary_counter(\n    input clk, reset, enable,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        q <= 4'b0000;\n    end\n    else if(enable) begin\n        q <= q + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "f8e1d5eb74a2422aa0140864e5469f04",
        "dataset_index": 13831
      },
      "mig_7series_v2_3_poc_edge_store #_4aeb0957": {
        "rtl_code": "\n\nmodule mig_7series_v2_3_poc_edge_store #\n  (parameter TCQ                        = 100,\n   parameter TAPCNTRWIDTH               = 7,\n   parameter TAPSPERKCLK                = 112)\n  (\n  fall_lead, fall_trail, rise_lead, rise_trail,\n  clk, run_polarity, run_end, select0, select1, tap, run\n  );\n  \n  input clk;\n\n  input run_polarity;\n  input run_end;\n  input select0;\n  input select1;\n  input [TAPCNTRWIDTH-1:0] tap;\n  input [TAPCNTRWIDTH-1:0] run;\n\n  wire [TAPCNTRWIDTH:0] trailing_edge = run > tap ? tap + TAPSPERKCLK[TAPCNTRWIDTH-1:0] - run\n                                                  : tap - run;\n\n  wire run_end_this = run_end && select0 && select1;\n\n  reg [TAPCNTRWIDTH-1:0] fall_lead_r, fall_trail_r, rise_lead_r, rise_trail_r;\n  output [TAPCNTRWIDTH-1:0] fall_lead, fall_trail, rise_lead, rise_trail;\n  assign fall_lead = fall_lead_r;\n  assign fall_trail = fall_trail_r;\n  assign rise_lead = rise_lead_r;\n  assign rise_trail = rise_trail_r;\n  \n  wire [TAPCNTRWIDTH-1:0] fall_lead_ns = run_end_this & run_polarity ? tap : fall_lead_r;\n  wire [TAPCNTRWIDTH-1:0] rise_trail_ns = run_end_this & run_polarity ? trailing_edge[TAPCNTRWIDTH-1:0]\n                                                                      : rise_trail_r;\n  wire [TAPCNTRWIDTH-1:0] rise_lead_ns = run_end_this & ~run_polarity ? tap : rise_lead_r;\n  wire [TAPCNTRWIDTH-1:0] fall_trail_ns = run_end_this & ~run_polarity ? trailing_edge[TAPCNTRWIDTH-1:0]\n                                                                       : fall_trail_r;\n     \n  always @(posedge clk) fall_lead_r <= #TCQ fall_lead_ns;\n  always @(posedge clk) fall_trail_r <= #TCQ fall_trail_ns;\n  always @(posedge clk) rise_lead_r <= #TCQ rise_lead_ns;\n  always @(posedge clk) rise_trail_r <= #TCQ rise_trail_ns;\n  \nendmodule ",
        "module_name": "mig_7series_v2_3_poc_edge_store #",
        "module_hash": "4aeb0957bc5cd35172c08822f35857e0",
        "dataset_index": 25843
      },
      "four_input_or_gate_f6f6981e": {
        "rtl_code": "\nmodule four_input_or_gate (\n    X   ,\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    wire   AB, CD, ABCD;\n\n    or (AB, A, B);\n    or (CD, C, D);\n    or (ABCD, AB, CD);\n\n    assign X = ABCD;\n\nendmodule",
        "module_name": "four_input_or_gate",
        "module_hash": "f6f6981e1d845ff9ba551f3acc641567",
        "dataset_index": 20207
      },
      "tx_reset_sm_57b9b6b2": {
        "rtl_code": "\nmodule tx_reset_sm\n(\ninput        refclkdiv2,\ninput        rst_n,\ninput        tx_pll_lol_qd_s,\n                                                                                              \noutput   reg    tx_pcs_rst_ch_c,      output   reg    rst_qd_c          );\n                                                                                              \n                                                                                              \nparameter count_index = 17;\n                                                                                              \n                                                                                              \nlocalparam   QUAD_RESET      = 0,\n             WAIT_FOR_TIMER1       = 1,\n             CHECK_PLOL       = 2,\n             WAIT_FOR_TIMER2       = 3,\n             NORMAL    = 4;\n                                                                                              \nlocalparam STATEWIDTH =3;\nreg [STATEWIDTH-1:0]    cs ;               reg [STATEWIDTH-1:0]    ns;               reg tx_pll_lol_qd_s_int;\nreg tx_pll_lol_qd_s_int1;\nreg    [3:0]   tx_pcs_rst_ch_c_int;      reg       rst_qd_c_int;          always @(posedge refclkdiv2 or negedge rst_n)\n   begin\n   if (rst_n == 1'b0)\n      begin\n      cs                     <= QUAD_RESET;\n      tx_pll_lol_qd_s_int    <= 1;\n      tx_pll_lol_qd_s_int1   <= 1;\n      tx_pcs_rst_ch_c        <= 1'b1;\n      rst_qd_c               <= 1;\n      end\n   else\n      begin\n      cs <= ns;\n      tx_pll_lol_qd_s_int1   <= tx_pll_lol_qd_s;\n      tx_pll_lol_qd_s_int    <= tx_pll_lol_qd_s_int1;\n      tx_pcs_rst_ch_c        <= tx_pcs_rst_ch_c_int[0];\n      rst_qd_c               <= rst_qd_c_int;\n      end\n   end\n                                                                                              \nreg reset_timer1, reset_timer2;\n                                                                                              \n                                                                                              \nlocalparam TIMER1WIDTH=3;\nreg [TIMER1WIDTH-1:0] counter1;\nreg TIMER1;\n                                                                                              \nalways @(posedge refclkdiv2 or posedge reset_timer1)\n   begin\n   if (reset_timer1)\n      begin\n      counter1 <= 0;\n      TIMER1 <= 0;\n      end\n   else\n      begin\n      if (counter1[2] == 1)\n         TIMER1 <=1;\n      else\n         begin\n         TIMER1 <=0;\n         counter1 <= counter1 + 1 ;\n         end\n      end\n   end\n                                                                                              \nlocalparam TIMER2WIDTH=18;\nreg [TIMER2WIDTH-1:0] counter2;\nreg TIMER2;\n                                                                                              \nalways @(posedge refclkdiv2 or posedge reset_timer2)\n   begin\n   if (reset_timer2)\n      begin\n      counter2 <= 0;\n      TIMER2 <= 0;\n      end\n   else\n      begin\nif (counter2[count_index] == 1)\n         TIMER2 <=1;\n      else\n         begin\n         TIMER2 <=0;\n         counter2 <= counter2 + 1 ;\n         end\n      end\n   end\n                                                                                              \n                                                                                              \nalways @(*)\n   begin : NEXT_STATE\n   reset_timer1 = 0;\n   reset_timer2 = 0;\n         case (cs)\n                                                                                              \n            QUAD_RESET: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 1;\n               reset_timer1 = 1;\n               ns = WAIT_FOR_TIMER1;\n               end\n                                                                                              \n            WAIT_FOR_TIMER1: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 1;\n               if (TIMER1)\n                  ns = CHECK_PLOL;\n               else\n                  ns = WAIT_FOR_TIMER1;\n            end\n                                                                                              \n            CHECK_PLOL: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 0;\n               reset_timer2 = 1;\n               ns = WAIT_FOR_TIMER2;\n            end\n                                                                                              \n            WAIT_FOR_TIMER2: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 0;\n               if (TIMER2)\n                  if (tx_pll_lol_qd_s_int)\n                     ns = QUAD_RESET;\n                  else\n                     ns = NORMAL;\n               else\n                     ns = WAIT_FOR_TIMER2;\n            end\n                                                                                              \n            NORMAL: begin\n               tx_pcs_rst_ch_c_int = 4'h0;\n               rst_qd_c_int = 0;\n               if (tx_pll_lol_qd_s_int)\n                  ns = QUAD_RESET;\n               else\n                  ns = NORMAL;\n            end\n                                                                                              \n                                                                                              \n                                                                                              \n            default: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 1;\n               ns = QUAD_RESET;\n            end\n         endcase end endmodule\n",
        "module_name": "tx_reset_sm",
        "module_hash": "57b9b6b2ef5f2f0fccf6ed71e4169e37",
        "dataset_index": 4337
      },
      "sky130_fd_sc_ms__nor2b_20f4a631": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__nor2b (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_Y;\n\n    not not0 (not0_out  , A              );\n    and and0 (and0_out_Y, not0_out, B_N  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__nor2b",
        "module_hash": "20f4a631e550840d2bdacb8689849499",
        "dataset_index": 22397
      },
      "three_input_and_gate_dc585bfa": {
        "rtl_code": "\nmodule three_input_and_gate (\n    X,\n    A1,\n    A2,\n    A3\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule\n\nmodule sky130_fd_sc_lp__a311o_0 (\n    output X,\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input C1\n);\n\n    assign X = (A1 & A2 & A3 & B1 & C1);\n\nendmodule\n",
        "module_name": "three_input_and_gate",
        "module_hash": "dc585bfa45a877a6f5355b2471d3ddb9",
        "dataset_index": 2616
      },
      "binary_to_gray_97fa5df5": {
        "rtl_code": "module binary_to_gray (\n    input [2:0] B,\n    output reg [2:0] G\n);\n\n    always @ (B) begin\n        G[0] = B[0] ^ B[1];\n        G[1] = B[1] ^ B[2];\n        G[2] = B[2];\n    end\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "97fa5df5220c0231796bc0f8206d54c3",
        "dataset_index": 17572
      },
      "jt51_lin2exp_00953a5a": {
        "rtl_code": "\n\nmodule jt51_lin2exp(\n  input      [15:0] lin,\n  output reg [9:0] man,\n  output reg [2:0] exp\n);\n\nalways @(*) begin\n  casex( lin[15:9] )\n    7'b10XXXXX: begin\n        man = lin[15:6];\n        exp = 3'd7;\n      end\n    7'b110XXXX: begin\n        man = lin[14:5];\n        exp = 3'd6;\n      end\n    7'b1110XXX: begin\n        man = lin[13:4];\n        exp = 3'd5;\n      end\n    7'b11110XX: begin\n        man = lin[12:3];\n        exp = 3'd4;\n      end\n    7'b111110X: begin\n        man = lin[11:2];\n        exp = 3'd3;\n      end\n    7'b1111110: begin\n        man = lin[10:1];\n        exp = 3'd2;\n      end\n    7'b1111111: begin\n        man = lin[ 9:0];\n        exp = 3'd1;\n      end    \n    7'b01XXXXX: begin\n        man = lin[15:6];\n        exp = 3'd7;\n      end\n    7'b001XXXX: begin\n        man = lin[14:5];\n        exp = 3'd6;\n      end\n    7'b0001XXX: begin\n        man = lin[13:4];\n        exp = 3'd5;\n      end\n    7'b00001XX: begin\n        man = lin[12:3];\n        exp = 3'd4;\n      end\n    7'b000001X: begin\n        man = lin[11:2];\n        exp = 3'd3;\n      end\n    7'b0000001: begin\n        man = lin[10:1];\n        exp = 3'd2;\n      end\n    7'b0000000: begin\n        man = lin[ 9:0];\n        exp = 3'd1;\n      end\n    \n    default: begin\n        man = lin[9:0];\n        exp = 3'd1;\n      end\n  endcase\nend\n\nendmodule\n",
        "module_name": "jt51_lin2exp",
        "module_hash": "00953a5acf8c8e5c237afbf5b8f41724",
        "dataset_index": 12240
      },
      "Raster_Laser_Projector_Video_In_video_rgb_resampler_0_9c825eb7": {
        "rtl_code": "\n\nmodule Raster_Laser_Projector_Video_In_video_rgb_resampler_0 (\n\tclk,\n\treset,\n\n\tstream_in_data,\n\tstream_in_startofpacket,\n\tstream_in_endofpacket,\n\tstream_in_empty,\n\tstream_in_valid,\n\n\tstream_out_ready,\n\t\n\tstream_in_ready,\n\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_empty,\n\tstream_out_valid\n);\n\n\n\nparameter IDW\t\t= 23;\nparameter ODW\t\t= 7;\n\nparameter IEW\t\t= 1;\nparameter OEW\t\t= 0;\n\nparameter ALPHA\t= 10'h3FF;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[IDW:0]\tstream_in_data;\ninput\t\t\t\t\t\tstream_in_startofpacket;\ninput\t\t\t\t\t\tstream_in_endofpacket;\ninput\t\t\t[IEW:0]\tstream_in_empty;\ninput\t\t\t\t\t\tstream_in_valid;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tstream_in_ready;\n\noutput reg\t[ODW:0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t[OEW:0]\tstream_out_empty;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire\t\t[ 9: 0]\tr;\nwire\t\t[ 9: 0]\tg;\nwire\t\t[ 9: 0]\tb;\nwire\t\t[ 9: 0]\ta;\n\nwire\t\t[11: 0]\taverage_color;\t\n\nwire\t\t[ODW:0]\tconverted_data;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'b0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_empty\t\t\t\t<=  'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (stream_out_ready | ~stream_out_valid)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= converted_data;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid;\n\tend\nend\n\n\n\nassign stream_in_ready = stream_out_ready | ~stream_out_valid;\n\nassign r = {stream_in_data[23:16], stream_in_data[23:22]};\nassign g = {stream_in_data[15: 8], stream_in_data[15:14]};\nassign b = {stream_in_data[ 7: 0], stream_in_data[ 7: 6]};\n\nassign a = ALPHA;\n\nassign average_color = {2'h0, r} + {1'b0, g, 1'b0} + {2'h0, b};\n\nassign converted_data[ 7: 0] = average_color[11:4];\n\n\n\n\nendmodule\n\n",
        "module_name": "Raster_Laser_Projector_Video_In_video_rgb_resampler_0",
        "module_hash": "9c825eb75193b89e87b8815039dffc2b",
        "dataset_index": 13991
      },
      "counter_6889ffa5": {
        "rtl_code": "module counter (\n  input clk,\n  input reset,\n  input [3:0] modulus,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0;\n    end else if (count == modulus) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "counter",
        "module_hash": "6889ffa54b05c968da14e6fca3e19554",
        "dataset_index": 21310
      },
      "ripple_carry_adder_5badc7c9": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output overflow\n);\n\n    wire [4:0] sum;\n    wire carry;\n\n    assign sum = A + B;\n    assign carry = sum[4];\n\n    assign S = sum[3:0];\n    assign overflow = carry;\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "5badc7c9a1fdf7ca8d232f742c4bc0ea",
        "dataset_index": 15069
      },
      "top__204af974": {
        "rtl_code": "\nmodule top_module (\n    input [2:0] a,\n    input [2:0] b,\n    input sel_b1,\n    input sel_b2,\n    output reg out_always,\n    output [2:0] out_or_reg,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // 2-to-1 multiplexer\n    always @(*) begin\n        out_always <= sel_b1 ? b : a;\n    end\n\n    // Bitwise-OR\n    assign out_or_reg = a | b;\n\n    // Logical-OR\n    assign out_or_logical = (a != 0) || (b != 0);\n\n    // Inverse of both vectors\n    assign out_not = ~{a, b};\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "204af974f872df7110e8bfafd71c98f8",
        "dataset_index": 20836
      },
      "adder_module_b52b57fb": {
        "rtl_code": "module adder_module(\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] R\n);\n\nalways @ (posedge clk) begin\n    if (rst) begin\n        R <= 8'h0;\n    end else begin\n        R <= A + B + 1;\n    end\nend\n\nendmodule",
        "module_name": "adder_module",
        "module_hash": "b52b57fb0ee47afc7e669455ce39211b",
        "dataset_index": 10052
      },
      "priority_encoder_6623e941": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] in,\n    output [2:0] pos );\n\n    wire [2:0] pos_int;\n\n    assign pos_int = in[2:0];\n\n    assign pos = ~pos_int;\n\nendmodule\nmodule top_module (\n    input [7:0] in,\n    output [2:0] pos );\n\n    priority_encoder pe(in, pos);\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "6623e941e84ef51c04cebeb850378895",
        "dataset_index": 13500
      },
      "dffs_6_705f2235": {
        "rtl_code": "module dffs_6 ( clk, set, d, q );\n    input clk;\n    input set;\n    input [5:0] d;\n    output [5:0] q;\n    reg [5:0] q;\n\n    always @(posedge clk or posedge set) begin\n        if (set) begin\n            q <= 6'b111111;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule",
        "module_name": "dffs_6",
        "module_hash": "705f22358aea74f3d894b7fa72185372",
        "dataset_index": 5075
      },
      "RegFile_3port_6c81f580": {
        "rtl_code": "module RegFile_3port(CLK, rst_n,\n                     ADDR_IN1, D_IN1, WE1,\n                     ADDR_IN2, D_IN2, WE2,\n                     ADDR_OUT1, ADDR_OUT2, ADDR_OUT3,\n                     D_OUT1, D_OUT2, D_OUT3\n                     );\n\n   parameter data_width = 8;\n   parameter addr_width = 4;\n   parameter depth = 1<<addr_width;\n   \n   input CLK;\n   input rst_n;\n   \n   input [addr_width - 1 : 0] ADDR_IN1;\n   input [data_width - 1 : 0] D_IN1;\n   input WE1;\n   \n   input [addr_width - 1 : 0] ADDR_IN2;\n   input [data_width - 1 : 0] D_IN2;\n   input WE2;\n   \n   input [addr_width - 1 : 0] ADDR_OUT1;\n   input [addr_width - 1 : 0] ADDR_OUT2;\n   input [addr_width - 1 : 0] ADDR_OUT3;\n   \n   output [data_width - 1 : 0] D_OUT1;\n   output [data_width - 1 : 0] D_OUT2;\n   output [data_width - 1 : 0] D_OUT3;\n   \n   reg [data_width - 1 : 0] arr [0 : depth-1];\n   \n   integer i;\n   \n   always @(posedge CLK) begin\n      if (!rst_n) begin\n         for (i = 0; i < depth; i = i + 1) begin\n            arr[i] <= 0;\n         end\n      end else begin\n         if (WE1) begin\n            arr[ADDR_IN1] <= D_IN1;\n         end\n         if (WE2) begin\n            arr[ADDR_IN2] <= D_IN2;\n         end\n      end\n   end\n   \n   assign D_OUT1 = arr[ADDR_OUT1];\n   assign D_OUT2 = arr[ADDR_OUT2];\n   assign D_OUT3 = arr[ADDR_OUT3];\n\nendmodule",
        "module_name": "RegFile_3port",
        "module_hash": "6c81f580c3323af8f806bce73b6cd390",
        "dataset_index": 1791
      },
      "karnaugh_map_00f51d02": {
        "rtl_code": "module karnaugh_map(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @(*) begin\n    case ({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0010: F = 1'b1;\n      4'b0011: F = 1'b0;\n      4'b0100: F = 1'b1;\n      4'b0101: F = 1'b0;\n      4'b0110: F = 1'b0;\n      4'b0111: F = 1'b1;\n      4'b1000: F = 1'b0;\n      4'b1001: F = 1'b1;\n      4'b1010: F = 1'b1;\n      4'b1011: F = 1'b0;\n      4'b1100: F = 1'b0;\n      4'b1101: F = 1'b1;\n      4'b1110: F = 1'b1;\n      4'b1111: F = 1'b0;\n    endcase\n  end\n\nendmodule",
        "module_name": "karnaugh_map",
        "module_hash": "00f51d02cd47c795647fe1a09ae482d8",
        "dataset_index": 13202
      },
      "compute_tm_count_8d384773": {
        "rtl_code": "module compute_tm_count (\n  input atm_valid,\n  input dtm_valid,\n  input itm_valid,\n  output reg [1:0] compute_tm_count\n);\n\n  always @* begin\n    case ({itm_valid, atm_valid, dtm_valid})\n      3'b000: compute_tm_count = 2'b00;\n      3'b001: compute_tm_count = 2'b01;\n      3'b010: compute_tm_count = 2'b01;\n      3'b011: compute_tm_count = 2'b10;\n      3'b100: compute_tm_count = 2'b01;\n      3'b101: compute_tm_count = 2'b10;\n      3'b110: compute_tm_count = 2'b10;\n      3'b111: compute_tm_count = 2'b11;\n    endcase\n  end\n\nendmodule",
        "module_name": "compute_tm_count",
        "module_hash": "8d384773874f9405cb9dc041f66bf995",
        "dataset_index": 14429
      },
      "fsm_299962aa": {
        "rtl_code": "module fsm(X, RESET, CLOCK, Z);\n  input X, RESET, CLOCK;\n  output reg Z;\n\n  // State variables\n  reg [1:0] CurrentState;\n  reg [1:0] NextState;\n\n  // State codes\n  parameter State0 = 2'b00, State1 = 2'b01, State2 = 2'b10, State3 = 2'b11;\n\n  // Output logic\n  always @ (CurrentState)\n    begin\n    case (CurrentState)\n      State0: Z <= 1;\n      State3: Z <= 0;\n      default: Z <= 0;\n    endcase\n    end\n\n  // State registers\n  always @ (posedge CLOCK or posedge RESET)\n    if (RESET == 1)\n      CurrentState <= State0;\n    else\n      CurrentState <= NextState;\n\n  // Next state logic\n  always @ (CurrentState or X)\n    begin\n    case (CurrentState)\n      State0: if (X == 0) NextState <= State1;\n              else NextState <= State0;\n      State1: if (X == 0) NextState <= State1;\n              else NextState <= State0;\n      State3: if (X == 0) NextState <= State1;\n              else NextState <= State2;\n      State2: NextState <= State2;\n    endcase\n    end\n\nendmodule",
        "module_name": "fsm",
        "module_hash": "299962aa37a04764baf87f08bf23c21b",
        "dataset_index": 13640
      },
      "sasc_fifo4_89f41488": {
        "rtl_code": "\n\n`include \"timescale.v\"\n\n// 4 entry deep fast fifo\nmodule sasc_fifo4(clk, rst, clr,  din, we, dout, re, full, empty);\n\ninput\t\tclk, rst;\ninput\t\tclr;\ninput   [7:0]\tdin;\ninput\t\twe;\noutput  [7:0]\tdout;\ninput\t\tre;\noutput\t\tfull, empty;\n\n\n\nreg     [7:0]\tmem[0:3];\nreg     [1:0]   wp;\nreg     [1:0]   rp;\nwire    [1:0]   wp_p1;\nwire    [1:0]   wp_p2;\nwire    [1:0]   rp_p1;\nwire\t\tfull, empty;\nreg\t\tgb;\n\n\nalways @(posedge clk or negedge rst)\n        if(!rst)\twp <= #1 2'h0;\n        else\n        if(clr)\t\twp <= #1 2'h0;\n        else\n        if(we)\t\twp <= #1 wp_p1;\n\nassign wp_p1 = wp + 2'h1;\nassign wp_p2 = wp + 2'h2;\n\nalways @(posedge clk or negedge rst)\n        if(!rst)\trp <= #1 2'h0;\n        else\n        if(clr)\t\trp <= #1 2'h0;\n        else\n        if(re)\t\trp <= #1 rp_p1;\n\nassign rp_p1 = rp + 2'h1;\n\n// Fifo Output\nassign  dout = mem[ rp ];\n\n// Fifo Input \nalways @(posedge clk)\n        if(we)     mem[ wp ] <= #1 din;\n\n// Status\nassign empty = (wp == rp) & !gb;\nassign full  = (wp == rp) &  gb;\n\n// Guard Bit ...\nalways @(posedge clk)\n\tif(!rst)\t\t\tgb <= #1 1'b0;\n\telse\n\tif(clr)\t\t\t\tgb <= #1 1'b0;\n\telse\n\tif((wp_p1 == rp) & we)\t\tgb <= #1 1'b1;\n\telse\n\tif(re)\t\t\t\tgb <= #1 1'b0;\n\nendmodule\n\n\n",
        "module_name": "sasc_fifo4",
        "module_hash": "89f41488b4ea46b7461cf1ee51ca61c6",
        "dataset_index": 107
      },
      "and_module_e67f8366": {
        "rtl_code": "module and_module(\n    input wire a,\n    input wire b,\n    input wire c,\n    input wire d,\n    output wire out0,\n    output wire out1,\n    output wire out2,\n    output wire out3\n);\n\n    assign out0 = a & b;\n    assign out1 = b & c;\n    assign out2 = (a == 1) ? d : 1'b0;\n    assign out3 = b & d;\n\nendmodule\n\n",
        "module_name": "and_module",
        "module_hash": "e67f8366c6b0a391f444d3acc6a799d4",
        "dataset_index": 154
      },
      "output_generator_8b24106f": {
        "rtl_code": "\nmodule output_generator(\n  input [3:0] num1,\n  input [3:0] num2,\n  input [1:0] operation,\n  output [3:0] result\n);\n\n  reg [3:0] result_reg; // declare result as a register\n\n  always @(*) begin\n    case(operation)\n      2'b00: result_reg = num1 + num2; // addition\n      2'b01: result_reg = num1 - num2; // subtraction\n      2'b10: result_reg = num1 * num2; // multiplication\n      2'b11: result_reg = num1 / num2; // division\n      default: result_reg = 4'b0000; // default case\n    endcase\n  end\n\n  assign result = result_reg; // assign result to the output port\n\nendmodule\n",
        "module_name": "output_generator",
        "module_hash": "8b24106f1265fd2be07c6eb675db40d1",
        "dataset_index": 13981
      },
      "adder_c546856a": {
        "rtl_code": "\nmodule adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\nwire [8:0] sum;\nwire carry;\n\nassign {carry, sum} = a + b;\n\nassign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nassign s = sum[7:0];\n\nendmodule\nmodule xor_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = in ^ 8'b10101010;\n\nendmodule\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow,\n    output [7:0] out\n);\n\nwire [7:0] adder_out;\n\nadder adder_inst (.a(a), .b(b), .s(adder_out), .overflow(overflow));\nxor_module xor_inst (.in(adder_out), .out(out));\n\nassign s = adder_out;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "c546856a108fbae63a33a2bbd7049c5b",
        "dataset_index": 2761
      },
      "decade_counter_ae2306d9": {
        "rtl_code": "\nmodule decade_counter (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    output reg [3:0] q\n);\n\n    // Define states\n    parameter [2:0] COUNT_0 = 3'b000;\n    parameter [2:0] COUNT_1 = 3'b001;\n    parameter [2:0] COUNT_2 = 3'b010;\n    parameter [2:0] COUNT_3 = 3'b011;\n    parameter [2:0] COUNT_4 = 3'b100;\n    parameter [2:0] COUNT_5 = 3'b101;\n    parameter [2:0] COUNT_6 = 3'b110;\n    parameter [2:0] COUNT_7 = 3'b111;\n\n    // Define signals\n    reg [2:0] state;\n    reg [3:0] next_q;\n\n    // Default output\n    always @* begin\n        q = next_q;\n    end\n\n    // State machine\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= COUNT_0;\n            next_q <= 4'b0000;\n        end else begin\n            if (pause == 1'b0) begin\n                case (state)\n                    COUNT_0: begin\n                        next_q <= 4'b0001;\n                        state <= COUNT_1;\n                    end\n                    COUNT_1: begin\n                        next_q <= 4'b0010;\n                        state <= COUNT_2;\n                    end\n                    COUNT_2: begin\n                        next_q <= 4'b0011;\n                        state <= COUNT_3;\n                    end\n                    COUNT_3: begin\n                        next_q <= 4'b0100;\n                        state <= COUNT_4;\n                    end\n                    COUNT_4: begin\n                        next_q <= 4'b0101;\n                        state <= COUNT_5;\n                    end\n                    COUNT_5: begin\n                        next_q <= 4'b0110;\n                        state <= COUNT_6;\n                    end\n                    COUNT_6: begin\n                        next_q <= 4'b0111;\n                        state <= COUNT_7;\n                    end\n                    COUNT_7: begin\n                        next_q <= 4'b1000;\n                        state <= COUNT_0;\n                    end\n                endcase\n            end\n            if(resume == 1'b1)\n                state <= state + 1;\n        end\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    output [3:0] q\n);\n\n    // Instantiate decade counter\n    decade_counter counter (\n        .clk(clk),\n        .pause(pause),\n        .resume(resume),\n        .reset(reset),\n        .q(q)\n    );\n\nendmodule",
        "module_name": "decade_counter",
        "module_hash": "ae2306d9ad2cea810bf0f752894102f2",
        "dataset_index": 3766
      },
      "smr_reg_ac72d38f": {
        "rtl_code": "module smr_reg(clk, rst, we, incr, wr, rd);\n\n\tparameter width = 'd16; parameter add_width = 'd13; input wire clk , rst ; input wire we , incr ; input wire [width-1:0] wr ;\n\n\toutput wire [add_width-1:0] rd ;\n\n\treg [width-1:0] mem ;\n\n\tassign rd [add_width-1:0] = mem [add_width-1:0];\n\n\talways@(posedge clk) begin\n\t\tif(rst) mem [width-1:0] <= {width{1'b0}}; else if(we) mem [width-1:0] <= wr [width-1:0]; else if(incr) mem [width-1:0] <= mem [width-1:0] + 1'b1; end\n\nendmodule",
        "module_name": "smr_reg",
        "module_hash": "ac72d38f4683d3a14f4a1cb2e7ca9538",
        "dataset_index": 9868
      },
      "MPUC1307_04b7671f": {
        "rtl_code": "\nmodule MPUC1307 ( CLK,DS ,ED, MPYJ,DR,DI ,DOR ,DOI  );\n\t\n\tparameter total_bits = 32;\n\tinput CLK ;\n\twire CLK ;\n\tinput DS ;\n\twire DS ;\n\tinput ED; \t\t\t\t\tinput MPYJ ;\t\t\t\twire MPYJ ;\n\tinput [total_bits-1:0] DR ;\n\twire signed [total_bits-1:0] DR ;\n\tinput [total_bits-1:0] DI ;\n\twire signed [total_bits-1:0] DI ;\t   \n\t\n\toutput [total_bits:0] DOR ;\n\treg [total_bits:0] DOR ;\t\n\toutput [total_bits:0] DOI ;\n\treg [total_bits:0] DOI ;\t \n\t\n\treg signed [total_bits+2 :0] dx5;\t \n\treg signed [total_bits-1 :0] dx7;\t \n\treg signed [total_bits-1 :0] dii;\t \n\treg signed\t[total_bits : 0] dt;\t\t   \n\twire signed [total_bits+3 : 0]  dx5p; \n\twire  signed  [total_bits+3 : 0] dot;\t\n\treg edd,edd2, edd3;        \t\treg mpyjd,mpyjd2,mpyjd3;\n\treg [total_bits:0] doo ;\t\n\treg [total_bits:0] droo ;\t\n\t\n\talways @(posedge CLK)\n\t\tbegin\n\t\t\tif (ED) begin\t  \n\t\t\t\t\tedd<=DS;\n\t\t\t\t\tedd2<=edd;\t\n\t\t\t\t\tedd3<=edd2;\t\n\t\t\t\t\tmpyjd<=MPYJ;\n\t\t\t\t\tmpyjd2<=mpyjd;\n\t\t\t\t\tmpyjd3<=mpyjd2;\t\t\t\t\t if (DS)\t begin\t\t\t\t   \t\tdx5<=DR+(DR <<2);\t dx7<=DR-(DR>>>3);\t dt<=DR;\t  \n\t\t\t\t\t\t\tdii<=DI;\n\t\t\t\t\t\tend\n\t\t\t\t\telse\t begin\n\t\t\t\t\t\t\tdx5<=dii+(dii <<2);\t dx7<=dii-(dii>>>3);\t dt<=dii;\n\t\t\t\t\t\tend\n\t\t\t\t\tdoo<=dot >>>3;\t\n\t\t\t\t\tdroo<=doo;\t\n\t\t\t\t\tif (edd3) \t \n\t\t\t\t\t\tif (mpyjd3) begin\n\t\t\t\t\t\t\t\tDOR<=doo;\n\t\t\t\t\t\t\tDOI<= - droo; end\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\tDOR<=droo;\n\t\t\t\t\t\t\tDOI<=  doo; end\t\t\t\t\t\n\t\t\t\tend \n\t\tend\t\t\n\t\n\tassign\tdx5p=(dx5<<1)+(dx7>>>1);\t\tassign   dot=\t(dx5p+(dt>>>6) -(dx5>>>13));endmodule\n",
        "module_name": "MPUC1307",
        "module_hash": "04b7671f660bd5916cfabb0cc10ce093",
        "dataset_index": 5484
      },
      "pcie_data_receiver_1de04073": {
        "rtl_code": "module pcie_data_receiver (\n    input clk,\n    input rst,\n    input rx,\n    input rx_valid,\n    output reg rx_ready,\n    output reg rx_ack,\n    output reg tx,\n    output reg tx_valid,\n    input tx_ready,\n    input tx_ack\n);\n\nparameter BUFFER_SIZE = 16; // Set the size of the FIFO buffer\n\nreg [7:0] buffer[BUFFER_SIZE-1:0]; // Create a FIFO buffer to store the received data\nreg [3:0] head = 0; // Track the head of the buffer\nreg [3:0] tail = 0; // Track the tail of the buffer\nreg [3:0] count = 0; // Track the number of elements in the buffer\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        head <= 0;\n        tail <= 0;\n        count <= 0;\n        rx_ready <= 0; // Assign rx_ready value in reset condition\n    end else begin\n        rx_ready <= (count < BUFFER_SIZE); // Set rx_ready to indicate whether there is space in the buffer\n\n        if (rx_valid && rx_ready) begin\n            buffer[head] <= rx;\n            head <= (head == BUFFER_SIZE-1) ? 0 : head + 1;\n            count <= count + 1;\n            rx_ack <= 1;\n        end else begin\n            rx_ack <= 0;\n        end\n\n        if (tx_ready && count > 0) begin\n            tx <= buffer[tail];\n            tail <= (tail == BUFFER_SIZE-1) ? 0 : tail + 1;\n            count <= count - 1;\n            tx_valid <= 1;\n        end else begin\n            tx_valid <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "pcie_data_receiver",
        "module_hash": "1de04073718a02805352ad6b74212c1e",
        "dataset_index": 11084
      },
      "controller_m_5ea7a84b": {
        "rtl_code": "module controller_m(\n    input clock, reset, start, Zero,\n    output Ready, Load_regs, Add_dec\n);\nparameter S_Idle = 1'b0, S_Mul = 1'b1;\n\nreg state, next_state;\n\nalways @(posedge clock, posedge reset)\n    if (reset)\n        state <= S_Idle;\n    else\n        state <= next_state;\n\nalways @(*)\nbegin\n    case (state)\n        S_Idle: next_state = Load_regs ? S_Mul : S_Idle;\n        S_Mul: next_state = Add_dec ? S_Idle : S_Mul;\n        default: next_state = 1'bx;\n    endcase\nend\n\nassign Ready = state == S_Idle;\nassign Load_regs = Ready & start;\nassign Add_dec = (state == S_Mul & ~Zero);\n\nendmodule",
        "module_name": "controller_m",
        "module_hash": "5ea7a84b060d07c4c91061f7d5732305",
        "dataset_index": 16825
      },
      "full_adder_8dd2da84": {
        "rtl_code": "module full_adder ( input A, B, Ci, output S, Co );\n  wire   n1, n2, n3;\n\n  assign n1 = ~(A ^ B);\n  assign n2 = ~(n1 ^ Ci);\n  assign n3 = ~(A ^ Ci);\n  assign Co = n1 & Ci;\n  assign S = n2 & n3;\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "8dd2da84ec7a199c72c10915178cedd9",
        "dataset_index": 5700
      },
      "clock_gate_4ec41ffd": {
        "rtl_code": "module clock_gate(\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  always @ (posedge CLK) begin\n    if (EN && !TE) begin\n      ENCLK <= 1'b1;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "4ec41ffd64ec7fa56663ca82bd12c2aa",
        "dataset_index": 8342
      },
      "StateUpdater_bb54fa09": {
        "rtl_code": "module StateUpdater(clk, enable, code, addr, state);\n\ninput clk, enable;\ninput [6:0] addr;\ninput [6:0] code;\noutput reg [3:0] state;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        case (code)\n            7'b0000000: state <= 4'b0000; // all 0s\n            7'b1111111: state <= 4'b1111; // all 1s\n            7'bxxxxxx1: state <= state ^ (1 << addr); // toggle\n            7'bxxxxx1x: state <= state | (1 << addr); // set to 1\n            7'bxxxx1xx: state <= state & ~(1 << addr); // set to 0\n            7'bxxx1xxx: state <= state ^ (1 << addr); // invert\n            7'bxx1xxxx: state <= {state[2:0], 1'b0}; // left shift\n            7'bx1xxxxx: state <= {1'b0, state[3:1]}; // right shift\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "StateUpdater",
        "module_hash": "bb54fa0942271e25d8118fee552c7478",
        "dataset_index": 11252
      },
      "calculator_b615a26f": {
        "rtl_code": "module calculator(a, b, op, clk, result);\n\n  input [7:0] a, b;\n  input [1:0] op;\n  input clk;\n  output [7:0] result;\n\n  reg [7:0] temp_result;\n  \n  always @(posedge clk) begin\n    case(op)\n      2'b00: temp_result <= a + b; // addition\n      2'b01: temp_result <= a - b; // subtraction\n      2'b10: temp_result <= a * b; // multiplication\n      2'b11: temp_result <= a / b; // division\n    endcase\n  end\n  \n  assign result = temp_result;\n  \nendmodule",
        "module_name": "calculator",
        "module_hash": "b615a26f76e87e15e75fa892b9e73c84",
        "dataset_index": 14054
      },
      "rgbmatrix_14249b15": {
        "rtl_code": "module rgbmatrix (\n    input clk,\n    input rst,\n    output reg R0,\n\t output reg G0,\n\t output reg B0,\n    output reg R1,\n\t output reg G1,\n\t output reg B1,\n\t output reg A,\n\t output reg B,\n\t output reg C,\n\t output reg D,\n\t output reg MATCLK,\n\t output reg MATLAT,\n\t output reg MATOE\n);\n\nlocalparam WAIT = 0,\n\t\t   BLANK = 1,\n\t\t   LATCH = 2,\n\t\t   UNBLANK = 3,\n\t\t   READ = 4,\n\t\t   SHIFT1 = 5,\n\t\t   SHIFT2 = 6;\n\nreg [2:0] state;\n\nreg [10:0] timer;\nreg [3:0] delay;\nreg [3:0] rd_row;\nreg [1:0] rd_bit;\nreg [4:0] rd_col;\n\nalways @ (posedge clk or posedge rst)\nbegin\n\tif (rst)\n\tbegin\n\t\tR0 <= 0;\n\t\tG0 <= 0;\n\t\tB0 <= 0;\n\t\tR1 <= 0;\n\t\tG1 <= 0;\n\t\tB1 <= 0;\n\t\tA <= 0;\n\t\tB <= 0;\n\t\tC <= 0;\n\t\tD <= 0;\n\t\tMATCLK <= 0;\n\t\tMATLAT <= 0;\n\t\tMATOE <= 1;\n\t\t\n\t\tstate <= READ;\n\n\t\ttimer <= 0;\n\t\tdelay <= 0;\n\n\t\trd_row <= 0;\n\t\trd_bit <= 0;\n\t\trd_col <= 0;\n\tend\n\telse\n\tbegin\n\t\tif (timer == 0)\n\t\tbegin\n\t\t\tcase (rd_bit)\n\t\t\t\t0: timer <= 191;\n\t\t\t\t1: timer <= 383;\n\t\t\t\t2: timer <= 767;\n\t\t\t\t3: timer <= 1535;\n\t\t\tendcase\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttimer <= timer - 1;\n\t\tend\n\n\t\tcase (state)\n\n\t\t\tWAIT: begin\n\t\t\t\tMATCLK <= 0;\n\t\t\t\tif (timer == 0)\n\t\t\t\tbegin\n\t\t\t\t\tMATOE <= 1;\n\t\t\t\t\tdelay <= 8;\n\t\t\t\t\tstate <= BLANK;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tBLANK: begin\n\t\t\t\tif (delay == 0)\n\t\t\t\tbegin\n\t\t\t\t\tMATLAT <= 1;\n\t\t\t\t\tdelay <= 8;\n\t\t\t\t\tstate <= LATCH;\n\t\t\t\t\tA <= rd_row[0];\n\t\t\t\t\tB <= rd_row[1];\n\t\t\t\t\tC <= rd_row[2];\n\t\t\t\t\tD <= rd_row[3];\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tdelay <= delay - 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tLATCH: begin\n\t\t\t\tif (delay == 0)\n\t\t\t\tbegin\n\t\t\t\t\tMATOE <= 0;\n\t\t\t\t\tMATLAT <= 0;\n\t\t\t\t\tstate <= UNBLANK;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tdelay <= delay - 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tUNBLANK: begin\n\t\t\t\tif (rd_bit == 3)\n\t\t\t\tbegin\n\t\t\t\t\trd_bit <= 0;\n\t\t\t\t\tif (rd_row == 15)\n\t\t\t\t\tbegin\n\t\t\t\t\t\trd_row <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\trd_row <= rd_row + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trd_bit <= rd_bit + 1;\n\t\t\t\tend\n\t\t\t\trd_col <= 0;\n\t\t\t\tstate <= READ;\n\t\t\tend\n\t\t\t\n\t\t\tREAD: begin\n\t\t\t\tstate <= SHIFT1;\n\t\t\t\tMATCLK <= 0;\n\t\t\tend\n\n\t\t\tSHIFT1: begin\n\t\t\t\tR0 <= rd_row[0];\n\t\t\t\tG0 <= rd_row[1];\n\t\t\t\tB0 <= 0;\n\t\t\t\tR1 <= 0;\n\t\t\t\tG1 <= rd_row[1];\n\t\t\t\tB1 <= 0;\n\t\t\t\tstate <= SHIFT2;\n\t\t\tend\n\n\t\t\tSHIFT2: begin\n\t\t\t\tMATCLK <= 1;\n\t\t\t\tif (rd_col == 31)\n\t\t\t\tbegin\n\t\t\t\t\trd_col <= 0;\n\t\t\t\t\tstate <= WAIT;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trd_col <= rd_col + 1;\n\t\t\t\t\tstate <= READ;\n\t\t\t\tend\n\t\t\tend\n\n\t\tendcase\n\tend\nend\nendmodule",
        "module_name": "rgbmatrix",
        "module_hash": "14249b158478d2e99866384b505caad6",
        "dataset_index": 8788
      },
      "ao22_874d0464": {
        "rtl_code": "\nmodule ao22 (\n  q,\n  i0,\n  i1,\n  i2,\n  i3\n);\n  output q;\n  input i0;\n  input i1;\n  input i2;\n  input i3;\n\n  wire [1:0] int_0n;\n\n  // AND gate for int_0n[0]\n  and I0 (int_0n[0], i0, i1);\n\n  // AND gate for int_0n[1]\n  and I1 (int_0n[1], i2, i3);\n\n  // OR gate for q\n  or I2 (q, int_0n[0], int_0n[1]);\nendmodule",
        "module_name": "ao22",
        "module_hash": "874d04647ac7227098ceab0d72d4bf0d",
        "dataset_index": 740
      },
      "mux4to1_e9286adf": {
        "rtl_code": "module mux4to1 (\n    input A,\n    input B,\n    input C,\n    input D,\n    input sel0,\n    input sel1,\n    output Y\n);\n\n    wire w1, w2, w3, w4, w5, w6;\n\n    assign w1 = (~sel1 & ~sel0) ? A : 1'b0;\n    assign w2 = (~sel1 & sel0) ? B : 1'b0;\n    assign w3 = (sel1 & ~sel0) ? C : 1'b0;\n    assign w4 = (sel1 & sel0) ? D : 1'b0;\n\n    assign w5 = w1 | w2;\n    assign w6 = w3 | w4;\n\n    assign Y = w5 | w6;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "e9286adf839645f00d772d9b8e8f3bd9",
        "dataset_index": 15049
      },
      "full_adder_575f84dd": {
        "rtl_code": "\nmodule full_adder ( A, B, Ci, S, Co );\n  input A, B, Ci;\n  output S, Co;\n  wire   n1, n2, n3;\n\n  xor (n1, A, B);\n  xor (S, n1, Ci);\n  and (n2, A, B);\n  and (n3, n1, Ci);\n  or (Co, n2, n3);\nendmodule\n",
        "module_name": "full_adder",
        "module_hash": "575f84dd182337a2de93e255dd2d4c33",
        "dataset_index": 15240
      },
      "TwosComplement_06c807a8": {
        "rtl_code": "module TwosComplement (\n   input clk,\n   input [3:0] in,\n   output reg [3:0] out\n   );\n\n   always @(posedge clk) begin\n      out <= ~in + 1;\n   end\n\nendmodule",
        "module_name": "TwosComplement",
        "module_hash": "06c807a876089d9a73d8e7df20e39c05",
        "dataset_index": 5066
      },
      "comparator_81cb2674": {
        "rtl_code": "module comparator (\n    input [15:0] A,\n    input [15:0] B,\n    output reg result\n);\n\n    always @(*) begin\n        if (A <= B) begin\n            result = 1'b1;\n        end else begin\n            result = 1'b0;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "81cb26740c46552ac3cda07434acff53",
        "dataset_index": 6622
      },
      "up_down_counter_d708aa1d": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input up_down,\n    input load,\n    output reg [2:0] count\n);\n\nreg [2:0] count_reg1;\nreg [2:0] count_reg2;\n\nalways @(posedge clk) begin\n    if (load) begin\n        count_reg1 <= 3'b0;\n        count_reg2 <= 3'b0;\n    end else begin\n        count_reg1 <= count_reg2;\n        count_reg2 <= count;\n    end\nend\n\nalways @(*) begin\n    if (up_down) begin\n        count = count_reg1 + 3'b001;\n    end else begin\n        count = count_reg1 - 3'b001;\n    end\nend\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "d708aa1dc836c6e6cbf81d2321dbf061",
        "dataset_index": 7794
      },
      "key_b1da4d35": {
        "rtl_code": "\nmodule key (\n  input [1:0] address,\n  input chipselect,\n  input clk,\n  input in_port,\n  input reset_n,\n  input write_n,\n  input [31:0] writedata,\n  output irq,\n  output [31:0] readdata\n);\n\n  reg [31:0] mem [3:0];\n  reg [31:0] read_mux_out;\n  reg [31:0] readdata_reg;\n  reg irq_mask;\n  wire clk_en;\n\n  assign clk_en = 1;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      readdata_reg <= 0;\n      irq_mask <= 0;\n    end else if (clk_en) begin\n      readdata_reg <= read_mux_out;\n      // *** fix conflict\n      if (chipselect & write_n && (address == 2)) begin\n        irq_mask <= writedata;\n      end\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      mem[0] <= 0;\n      mem[1] <= 0;\n      mem[2] <= 0;\n      mem[3] <= 0;\n    end else if (chipselect && ~write_n) begin\n      mem[address] <= writedata;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      read_mux_out <= 0;\n    end else begin\n      case (address)\n        2'b00: read_mux_out <= mem[0];\n        2'b01: read_mux_out <= mem[1];\n        2'b10: read_mux_out <= irq_mask;\n        2'b11: read_mux_out <= mem[3];\n      endcase\n    end\n  end\n\n  assign irq = |(in_port & irq_mask);\n\n  assign readdata = readdata_reg;\n\nendmodule",
        "module_name": "key",
        "module_hash": "b1da4d3589cbb302fc1f14707a779043",
        "dataset_index": 11089
      },
      "signal_decoder #_d9c388ff": {
        "rtl_code": "\nmodule signal_decoder # \n(\n    parameter ADC_WIDTH = 14,\n    parameter AXIS_TDATA_WIDTH = 32,\n    parameter BIT_OFFSET = 4 )\n(\n    \n    input [AXIS_TDATA_WIDTH-1:0]    S_AXIS_tdata,\n    input                           S_AXIS_tvalid,\n    input                           clk,\n    input                           rst,\n\toutput reg [7:0]                led_out\n);\n    wire [2:0] value;\n    \n    assign value = S_AXIS_tdata[ADC_WIDTH-BIT_OFFSET-1:ADC_WIDTH-BIT_OFFSET-3];\n \n    always @(posedge clk)\n       if (~rst)\n          led_out <= 8'hFF;\n       else\n          case (value)\n             3'b011  : led_out <= 8'b00000001;\n             3'b010  : led_out <= 8'b00000010;\n             3'b001  : led_out <= 8'b00000100;\n             3'b000  : led_out <= 8'b00001000;\n             3'b111  : led_out <= 8'b00010000;\n             3'b110  : led_out <= 8'b00100000;\n             3'b101  : led_out <= 8'b01000000;\n             3'b100  : led_out <= 8'b10000000;\n             default : led_out <= 8'b00000000;\n          endcase\nendmodule\n",
        "module_name": "signal_decoder #",
        "module_hash": "d9c388ffb93f5e628eee1f33cce61ca0",
        "dataset_index": 16368
      },
      "sky130_fd_sc_ls__a2bb2o_392751e0": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a2bb2o (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire nor0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2            );\n    nor nor0 (nor0_out , A1_N, A2_N        );\n    or  or0  (or0_out_X, nor0_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a2bb2o",
        "module_hash": "392751e0d9ecb92825ecc59fcde2f10d",
        "dataset_index": 23320
      },
      "sky130_fd_sc_hd__or2b_4ac82166": {
        "rtl_code": "\nmodule sky130_fd_sc_hd__or2b (\n    input A,\n    input B_N,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    reg A_reg;\n    reg B_N_reg;\n    reg X_reg;\n\n    wire A_stable;\n    wire B_N_stable;\n    wire X_stable;\n\n    assign A_stable = (A_reg === A);\n    assign B_N_stable = (B_N_reg === B_N);\n    assign X_stable = (X_reg === X);\n\n    always @(posedge VPWR) begin // Using posedge operator for VPWR\n        A_reg <= A;\n        B_N_reg <= B_N;\n    end\n\n    always @(A or B_N or A_stable or B_N_stable or X_stable) begin\n        if (A_stable && B_N_stable) begin\n            X_reg <= A | B_N;\n        end else begin\n            X_reg <= #2 A | B_N;\n        end\n    end\n\n    assign X = X_reg;\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__or2b",
        "module_hash": "4ac82166fd21d5a9b268be768db9827e",
        "dataset_index": 11455
      },
      "Inverse_Clarke_Transform_3db426bf": {
        "rtl_code": "module Inverse_Clarke_Transform (\n    input signed [17:0] alpha_voltage,\n    input signed [17:0] beta_voltage,\n    output signed [17:0] phase_voltages_0,\n    output signed [17:0] phase_voltages_1,\n    output signed [17:0] phase_voltages_2\n);\n\n    wire signed [35:0] voltage_phase_a;\n    wire signed [35:0] Gain1_out1;\n    wire signed [35:0] Gain_out1;\n    wire signed [35:0] voltage_phase_b;\n    wire signed [37:0] Add1_cast;\n    wire signed [37:0] Add1_cast_1;\n    wire signed [37:0] Add1_sub_cast;\n    wire signed [37:0] Add1_sub_temp;\n    wire signed [35:0] voltage_phase_c;\n    wire signed [35:0] Mux_out1 [0:2];\n    wire signed [17:0] Current_Data_Type_out1 [0:2];\n\n    assign voltage_phase_a = {{2{alpha_voltage[17]}}, {alpha_voltage, 16'b0000000000000000}};\n    assign Gain1_out1 = 56756 * beta_voltage;\n    assign Gain_out1 = {{3{alpha_voltage[17]}}, {alpha_voltage, 15'b000000000000000}};\n    assign voltage_phase_b = Gain1_out1 - Gain_out1;\n    assign Add1_cast = Gain_out1;\n    assign Add1_cast_1 =  - (Add1_cast);\n    assign Add1_sub_cast = Gain1_out1;\n    assign Add1_sub_temp = Add1_cast_1 - Add1_sub_cast;\n    assign voltage_phase_c = Add1_sub_temp[35:0];\n    assign Mux_out1[0] = voltage_phase_a;\n    assign Mux_out1[1] = voltage_phase_b;\n    assign Mux_out1[2] = voltage_phase_c;\n\n    assign Current_Data_Type_out1[0] = ((Mux_out1[0][35] == 1'b0) && (Mux_out1[0][34:30] != 5'b00000) ? 18'sb011111111111111111 :\n              ((Mux_out1[0][35] == 1'b1) && (Mux_out1[0][34:30] != 5'b11111) ? 18'sb100000000000000000 :\n              $signed(Mux_out1[0][30:13])));\n    assign Current_Data_Type_out1[1] = ((Mux_out1[1][35] == 1'b0) && (Mux_out1[1][34:30] != 5'b00000) ? 18'sb011111111111111111 :\n              ((Mux_out1[1][35] == 1'b1) && (Mux_out1[1][34:30] != 5'b11111) ? 18'sb100000000000000000 :\n              $signed(Mux_out1[1][30:13])));\n    assign Current_Data_Type_out1[2] = ((Mux_out1[2][35] == 1'b0) && (Mux_out1[2][34:30] != 5'b00000) ? 18'sb011111111111111111 :\n              ((Mux_out1[2][35] == 1'b1) && (Mux_out1[2][34:30] != 5'b11111) ? 18'sb100000000000000000 :\n              $signed(Mux_out1[2][30:13])));\n\n    assign phase_voltages_0 = Current_Data_Type_out1[0];\n    assign phase_voltages_1 = Current_Data_Type_out1[1];\n    assign phase_voltages_2 = Current_Data_Type_out1[2];\n\nendmodule",
        "module_name": "Inverse_Clarke_Transform",
        "module_hash": "3db426bfee17f4b4178682145ecd8b16",
        "dataset_index": 21519
      },
      "top__78382287": {
        "rtl_code": "module top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] q_reg1, q_reg2, q_reg3, q_reg4, q_reg5, q_reg6, q_reg7, q_reg8;\n\nalways @(negedge clk) begin\n    q_reg1 <= d;\n    q_reg2 <= q_reg1;\n    q_reg3 <= q_reg2;\n    q_reg4 <= q_reg3;\n    q_reg5 <= q_reg4;\n    q_reg6 <= q_reg5;\n    q_reg7 <= q_reg6;\n    q_reg8 <= q_reg7;\nend\n\nassign q = q_reg8;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "78382287571b8054b2ec5543438b7882",
        "dataset_index": 20234
      },
      "d_ff_scd_sce_1d620ffb": {
        "rtl_code": "module d_ff_scd_sce (\n    input CLK,\n    input D,\n    input SCD,\n    input SCE,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK) begin\n        if (SCD) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (SCE) begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule",
        "module_name": "d_ff_scd_sce",
        "module_hash": "1d620ffb4d63e70bcb3ef923bba16796",
        "dataset_index": 18444
      },
      "lin_transmitter_f905ba42": {
        "rtl_code": "\nmodule lin_transmitter (\n  input clk,\n  input rst,\n  input tx_en,\n  input [7:0] tx_data,\n  input [5:0] id,\n  output reg tx\n);\n\n  // Define LIN frame structure\n  parameter SYNC_BYTE = 8'h55;\n  parameter ID_BYTE = 6;\n  parameter DATA_BYTE = 8;\n  parameter CHECKSUM_BYTE = 8;\n  parameter FRAME_SIZE = SYNC_BYTE + ID_BYTE + DATA_BYTE + CHECKSUM_BYTE;\n  \n  // Define state machine states\n  parameter IDLE = 2'b00;\n  parameter SYNC = 2'b01;\n  parameter ID = 2'b10;\n  parameter DATA = 2'b11;\n  \n  // Define state machine signals\n  reg [1:0] state;\n  reg [FRAME_SIZE-1:0] frame;\n  reg [7:0] checksum;\n  reg [3:0] bit_count;\n  reg [7:0] data_byte;\n  \n  // Initialize state machine\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      state <= IDLE;\n      bit_count <= 0;\n      checksum <= 0;\n      tx <= 1;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (tx_en) begin\n            state <= SYNC;\n            frame[SYNC_BYTE-1:0] <= SYNC_BYTE;\n          end\n        end\n        SYNC: begin\n          if (bit_count == 0) begin\n            tx <= 0;\n            bit_count <= 1;\n          end else if (bit_count == 1) begin\n            tx <= 1;\n            bit_count <= 2;\n          end else if (bit_count == 2) begin\n            tx <= 0;\n            bit_count <= 3;\n          end else if (bit_count == 3) begin\n            tx <= 1;\n            bit_count <= 4;\n          end else if (bit_count == 4) begin\n            tx <= 0;\n            bit_count <= 5;\n          end else if (bit_count == 5) begin\n            tx <= 1;\n            bit_count <= 6;\n          end else if (bit_count == 6) begin\n            tx <= 0;\n            bit_count <= 7;\n          end else if (bit_count == 7) begin\n            tx <= 1;\n            bit_count <= 0;\n            state <= ID;\n            frame[ID_BYTE+SYNC_BYTE-1:SYNC_BYTE] <= {1'b0, id};\n            checksum <= id;\n          end\n        end\n        ID: begin\n          if (bit_count == 0) begin\n            tx <= 0;\n            bit_count <= 1;\n          end else if (bit_count == 1) begin\n            tx <= 1;\n            bit_count <= 2;\n          end else if (bit_count == 2) begin\n            tx <= 0;\n            bit_count <= 3;\n          end else if (bit_count == 3) begin\n            tx <= 1;\n            bit_count <= 4;\n          end else if (bit_count == 4) begin\n            tx <= 0;\n            bit_count <= 5;\n          end else if (bit_count == 5) begin\n            tx <= 1;\n            bit_count <= 6;\n          end else if (bit_count == 6) begin\n            tx <= 0;\n            bit_count <= 7;\n          end else if (bit_count == 7) begin\n            tx <= 1;\n            bit_count <= 0;\n            state <= DATA;\n            frame[DATA_BYTE+ID_BYTE+SYNC_BYTE-1:ID_BYTE+SYNC_BYTE] <= tx_data;\n            checksum <= checksum + tx_data;\n          end\n        end\n        DATA: begin\n          if (bit_count == 0) begin\n            tx <= 0;\n            bit_count <= 1;\n          end else if (bit_count == 1) begin\n            tx <= 1;\n            bit_count <= 2;\n          end else if (bit_count == 2) begin\n            tx <= 0;\n            bit_count <= 3;\n          end else if (bit_count == 3) begin\n            tx <= 1;\n            bit_count <= 4;\n          end else if (bit_count == 4) begin\n            tx <= 0;\n            bit_count <= 5;\n          end else if (bit_count == 5) begin\n            tx <= 1;\n            bit_count <= 6;\n          end else if (bit_count == 6) begin\n            tx <= 0;\n            bit_count <= 7;\n          end else if (bit_count == 7) begin\n            tx <= 1;\n            bit_count <= 0;\n            state <= IDLE;\n            frame[FRAME_SIZE-1:DATA_BYTE+ID_BYTE+SYNC_BYTE] <= ~checksum;\n          end\n        end\n      endcase\n    end\n  end\n  \nendmodule",
        "module_name": "lin_transmitter",
        "module_hash": "f905ba42cbea6dac283bd788e9e46999",
        "dataset_index": 13596
      },
      "edge_detection_b7091468": {
        "rtl_code": "\nmodule edge_detection (\n    input clk,\n    input rst_n,\n    input signal,\n    output reg rise,\n    output reg fall\n);\n\nreg prev_signal;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        rise <= 0;\n        fall <= 0;\n        prev_signal <= 0;\n    end else begin\n        rise <= signal & ~prev_signal;\n        fall <= ~signal & prev_signal;\n        prev_signal <= signal;\n    end\nend\n\nendmodule\n\nmodule minimum_finding (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min_val\n);\n\nalways @(*) begin\n    if(a < b && a < c && a < d) begin\n        min_val = a;\n    end else if(b < c && b < d) begin\n        min_val = b;\n    end else if(c < d) begin\n        min_val = c;\n    end else begin\n        min_val = d;\n    end\nend\n\nendmodule\n\nmodule functional_module (\n    input clk,\n    input rst_n,\n    input rise,\n    input fall,\n    input [7:0] min_val,\n    output reg out\n);\n\nreg [7:0] max_val;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        max_val <= 0;\n    end else begin\n        if(rise) begin\n            max_val <= 8'hFF; // Set max_val to the maximum possible value\n        end\n\n        if(fall) begin\n            out <= min_val; // Output the minimum value\n        end\n\n        if(max_val > min_val) begin\n            out <= max_val; // Output the maximum value if it's greater than the minimum value\n        end\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input rst_n,\n    input [7:0] a, // It's 7 bits wide in the top_module instantiation, but 8 bits wide in the minimum_finding instantiation. This is an error.\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output wire out\n);\n\nreg signal;\nwire rise, fall;\nwire [7:0] min_val;\n\nedge_detection ed(\n    .clk(clk),\n    .rst_n(rst_n),\n    .signal(signal),\n    .rise(rise),\n    .fall(fall)\n);\n\nminimum_finding mf(\n    .a(a), // Mismatch between the width of a (7 bits) and the width of the ports of the minimum_finding module (8 bits)\n    .b(b),\n    .c(c),\n    .d(d),\n    .min_val(min_val)\n);\n\nfunctional_module fm(\n    .clk(clk),\n    .rst_n(rst_n),\n    .rise(rise),\n    .fall(fall),\n    .min_val(min_val),\n    .out(out)\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        signal <= 0;\n    end else begin\n        signal <= a;\n    end\nend\n\nendmodule\n",
        "module_name": "edge_detection",
        "module_hash": "b70914688711b006a2ed2f89c52fd400",
        "dataset_index": 7016
      },
      "decoder_4to16_pipeline_b24efc70": {
        "rtl_code": "module decoder_4to16_pipeline (\n    input [1:0] select,\n    input en,\n    input clk,\n    output reg [15:0] out\n);\n\nreg [1:0] select_reg;\nreg en_reg;\n\nalways @(posedge clk) begin\n    select_reg <= select;\n    en_reg <= en;\nend\n\nalways @(posedge clk) begin\n    if (en_reg == 0) begin\n        case (select_reg)\n            2'b00: out <= 16'b1111111111111110;\n            2'b01: out <= 16'b1111111111111101;\n            2'b10: out <= 16'b1111111111111011;\n            2'b11: out <= 16'b1111111111110111;\n        endcase;\n    end else begin\n        out <= 16'b1111111111111111;\n    end\nend\n\nendmodule",
        "module_name": "decoder_4to16_pipeline",
        "module_hash": "b24efc704d910b590f0c062a0325dc96",
        "dataset_index": 13330
      },
      "shift_register_b9277b84": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] load_value,\n    output [3:0] shift_out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        shift_reg <= 4'b0;\n    end else if (load) begin\n        shift_reg <= load_value;\n    end else begin\n        shift_reg <= {shift_reg[2:0], 1'b0};\n    end\nend\n\nassign shift_out = shift_reg;\n\nendmodule\n\nmodule d_flip_flop (\n    input clk,\n    input d,\n    input aset,\n    input areset,\n    output q\n);\n\nreg q;\n\nalways @(posedge clk, negedge areset) begin\n    if (!areset) begin\n        q <= 1'b0;\n    end else if (aset) begin\n        q <= 1'b1;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] load_value,\n    input d,\n    input aset,\n    input areset,\n    output q,\n    output [3:0] shift_out\n);\n\nshift_register shift_reg (\n    .clk(clk),\n    .reset(reset),\n    .load(load),\n    .load_value(load_value),\n    .shift_out(shift_out)\n);\n\nd_flip_flop d_ff (\n    .clk(clk),\n    .d(d),\n    .aset(aset),\n    .areset(areset),\n    .q(q)\n);\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "b9277b844282b6b1b97ec32d198dd91c",
        "dataset_index": 16813
      },
      "pipelined_adder_45ee7613": {
        "rtl_code": "module pipelined_adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\nwire [7:0] p, g, c;\n\nassign p = a ^ b;\nassign g = a & b;\nassign c[0] = 1'b0;\n\ngenvar i;\n\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin : carry_lookahead\n        assign c[i] = g[i-1] | (p[i-1] & c[i-1]);\n    end\nendgenerate\n\nassign s = a + b + c;\n\nassign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\n\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\npipelined_adder adder(a, b, s, overflow);\n\nendmodule",
        "module_name": "pipelined_adder",
        "module_hash": "45ee76136fbcd43c0d0aef7099dc86a7",
        "dataset_index": 2900
      },
      "nand_gate_e98f4921": {
        "rtl_code": "module nand_gate (\n    A,\n    B,\n    X,\n    SLEEP_B\n);\n\n    input A;\n    input B;\n    output X;\n    input SLEEP_B;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign X = ~(A & B) & SLEEP_B;\n\nendmodule",
        "module_name": "nand_gate",
        "module_hash": "e98f49217fe40b7967fedb5608992cfa",
        "dataset_index": 3654
      },
      "clk_synchronizer#_0e048b28": {
        "rtl_code": "\nmodule clk_synchronizer#(\n\tparameter\tSYSCLK_FREQ_HZ\t\t= 64'd100_000_000,\n\tparameter\tPPS_HIGH_LEVEL_US\t= 64'd10_000,\n\tparameter\tGENCLK_FREQ_HZ\t\t= 1,\n\tparameter\tFORWARD_OFFSET_CLK\t= 0\n)(\n\tinput\t\tclk,\n\tinput\t\trst_n,\n\tinput\t\tpps_in,\n\toutput\t\tsync_clk_out,\n\toutput\t\tclk_sync_ok_out\n);\n\nfunction integer log2ceil;\ninput reg [63 : 0] val;\nreg [63 : 0] i;\nbegin\n\ti = 1;\n\tlog2ceil = 0;\n\twhile (i < val) begin\n\t\tlog2ceil = log2ceil + 1;\n\t\ti = i << 1;\n\tend\nend\nendfunction\n\nlocalparam\t\t\t\t\t\tDUTY_CNT_N\t= SYSCLK_FREQ_HZ * PPS_HIGH_LEVEL_US / 64'd1_000_000;\nlocalparam\t\t\t\t\t\tDIVIDER_NUM\t= SYSCLK_FREQ_HZ / GENCLK_FREQ_HZ;\nlocalparam\t\t\t\t\t\tDIVIDER_BIT\t= log2ceil(DIVIDER_NUM);\n\nreg\t\t\t\t\t\t\t\tclk_sync_flag;\nreg\t\t\t\t\t\t\t\trst_release;\nwire\t\t\t\t\t\t\trst_pps_rst;\nreg\t\t\t\t\t\t\t\trst_pps;\nreg\t\t[DIVIDER_BIT - 1 : 0]\tclk_divider;\nwire\t\t\t\t\t\t\tclk_gen_forward;\nreg\t\t\t\t\t\t\t\tclk_generated;\n\nalways @ (posedge pps_in or posedge rst_pps_rst)\nbegin\n\tif (rst_pps_rst) begin\n\t\trst_pps <= 0;\n\tend\n\telse begin\n\t\trst_pps <= 1;\n\tend\nend\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\trst_release <= 0;\n\tend\n\telse if ((rst_pps == 1) || (clk_sync_flag == 1)) begin\n\t\trst_release <= 1;\n\tend\n\telse begin\n\t\trst_release <= 0;\n\tend\nend\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\tclk_sync_flag <= 0;\n\tend\n\telse if (rst_release == 1) begin\n\t\tclk_sync_flag <= 1;\n\tend\n\telse begin\n\t\tclk_sync_flag <= clk_sync_flag;\n\tend\nend\n\nalways @ (posedge clk or posedge rst_pps)\nbegin\n\tif (rst_pps) begin\n\t\tclk_divider <= FORWARD_OFFSET_CLK + 2;\n\tend\n\telse if (clk_divider < DIVIDER_NUM - 1) begin\n\t\tclk_divider <= clk_divider + 1'b1;\n\tend\n\telse begin\n\t\tclk_divider <= 0;\n\tend\nend\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\tclk_generated <= 0;\n\tend\n\telse if (clk_sync_flag) begin\n\t\tclk_generated <= clk_gen_forward;\n\tend\n\telse begin\n\t\tclk_generated <= 0;\n\tend\nend\n\nassign rst_pps_rst = rst_release | (~rst_n);\nassign clk_gen_forward = (clk_divider < DUTY_CNT_N) ? 1'b1: 1'b0;\nassign clk_sync_ok_out = clk_sync_flag;\nassign sync_clk_out = clk_generated;\n\nendmodule\n",
        "module_name": "clk_synchronizer#",
        "module_hash": "0e048b2822a9dd10bb297d8024443386",
        "dataset_index": 23256
      },
      "lab4_3_1_df54a8dc": {
        "rtl_code": "\nmodule lab4_3_1(\n    input m,clk,\n    output reg [3:0] Z\n    );\n    reg [1:0] state,nextstate;\n    parameter S0 = 2'b00,S1 = 2'b01,S2 = 2'b11,S3 = 2'b10;\n    initial\n    begin\n        state = S0;\n      end\n    always @(posedge clk)\n    begin\n       state = nextstate;\n      end\n    always @(state)\n    begin\n        case(state)\n        S0:if(m) Z = 4'b0001;else Z = 4'b0001;\n        S1:if(m) Z = 4'b0010;else Z = 4'b1000;\n        S2:if(m) Z = 4'b0100;else Z = 4'b0100;\n        S3:if(m) Z = 4'b1000;else Z = 4'b0010;\n        endcase\n    end\n    always @(state)\n    begin\n        case(state)\n        S0: nextstate = S1;\n        S1: nextstate = S2;\n        S2: nextstate = S3;\n        S3: nextstate = S0;\n        endcase\n    end\nendmodule\n",
        "module_name": "lab4_3_1",
        "module_hash": "df54a8dc855ee9ba0808a137aedde273",
        "dataset_index": 13128
      },
      "register_4bit_ae2e5113": {
        "rtl_code": "module register_4bit (\n    input [3:0] data_in,\n    input load,\n    input reset,\n    input clk,\n    output reg [3:0] Q\n);\n\n    // Local signals\n    reg [3:0] Q_reg;\n\n    // Instantiate 4 D Flip-Flops with Set and Reset functionality\n    always @ (posedge clk or posedge reset)\n    begin\n        if (reset)\n        begin\n            Q_reg <= 4'b0;\n        end\n        else if (load)\n        begin\n            Q_reg <= data_in;\n        end\n    end\n\n    always @*\n    begin\n        Q = Q_reg;\n    end\n\nendmodule",
        "module_name": "register_4bit",
        "module_hash": "ae2e5113b2f55aac4df8b1054c111611",
        "dataset_index": 6581
      },
      "baudgen_f57d4b12": {
        "rtl_code": "module baudgen(\n  input wire clk,\n  input wire resetq,\n  input wire [31:0] baud,\n  input wire restart,\n  output wire ser_clk);\n  parameter CLKFREQ = 1000000;\n  \n  parameter RWIDTH = 25;\n\n  wire [RWIDTH-1:0] aclkfreq = CLKFREQ;\n  reg [RWIDTH-1:0] d;\n  wire [RWIDTH-1:0] dInc = d[RWIDTH-1] ? ({4'd0, baud}) : (({4'd0, baud}) - aclkfreq);\n  wire [RWIDTH-1:0] dN = restart ? 0 : (d + dInc);\n  wire fastclk = ~d[RWIDTH-1];\n  assign ser_clk = fastclk;\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      d <= 0;\n    end else begin\n      d <= dN;\n    end\n  end\nendmodule",
        "module_name": "baudgen",
        "module_hash": "f57d4b124d42d7b8ea78574ea8f958ad",
        "dataset_index": 5328
      },
      "blk_mem_gen_0blk_mem_gen_v8_2_synth_78c96151": {
        "rtl_code": "\nmodule blk_mem_gen_0blk_mem_gen_v8_2_synth\n  (\n    output [63:0] doutb,\n    input enb,\n    input clkb,\n    input wea,\n    input clka,\n    input [8:0] addrb,\n    input [8:0] addra,\n    input [63:0] dina\n  );\n\n  parameter ADDR_WIDTH = 9;\n  parameter DATA_WIDTH = 64;\n  parameter DEPTH = 2 ** ADDR_WIDTH;\n\n  // Internal wires\n  reg  [DATA_WIDTH-1:0] mem [DEPTH-1:0];\n  wire [ADDR_WIDTH-1:0] addr;\n  reg  [DATA_WIDTH-1:0] data;\n\n  // Address decoding\n  assign addr = (clka) ? addra : addrb;\n\n  // Read/Write operations\n  always @(posedge clkb) begin\n    if (enb) begin\n      if (wea) begin // Write operation\n        mem[addr] <= dina;\n      end else begin // Read operation\n        data <= mem[addr];\n      end\n    end\n  end\n\n  assign doutb = data;\n\nendmodule\n",
        "module_name": "blk_mem_gen_0blk_mem_gen_v8_2_synth",
        "module_hash": "78c96151662508c4da9b9f2ef0b49010",
        "dataset_index": 15483
      },
      "RegisterAdd_parameterized8_ffaa5dca": {
        "rtl_code": "module RegisterAdd_parameterized8\n   (\n    input clk,\n    input rst,\n    input load,\n    input [7:0] D1,\n    input [7:0] D2,\n    output reg [7:0] Q\n  );\n\n  reg [7:0] reg1;\n  reg [7:0] reg2;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      reg1 <= 8'b0;\n      reg2 <= 8'b0;\n    end else if (load) begin\n      reg1 <= D1;\n      reg2 <= D2;\n    end else begin\n      Q <= reg1 + reg2;\n    end\n  end\nendmodule\n",
        "module_name": "RegisterAdd_parameterized8",
        "module_hash": "ffaa5dca4146c475811189c02f0640bd",
        "dataset_index": 11481
      },
      "store_data_translator #_f0d5a09c": {
        "rtl_code": "module store_data_translator #(\n    parameter WIDTH=32\n)(\n    input [WIDTH-1:0] write_data,\n    input [1:0] d_address,\n    input [1:0] store_size,\n    output [3:0] d_byteena,\n    output [WIDTH-1:0] d_writedataout\n);\n\n\nreg [3:0] d_byteena;\nreg [WIDTH-1:0] d_writedataout;\n\nalways @*\nbegin\n    case (store_size)\n        2'b11:\n            case(d_address[1:0])\n                0: \n                begin \n                    d_byteena=4'b1000; \n                    d_writedataout={write_data[7:0],24'b0}; \n                end\n                1: \n                begin \n                    d_byteena=4'b0100; \n                    d_writedataout={8'b0,write_data[7:0],16'b0}; \n                end\n                2: \n                begin \n                    d_byteena=4'b0010; \n                    d_writedataout={16'b0,write_data[7:0],8'b0}; \n                end\n                default: \n                begin \n                    d_byteena=4'b0001; \n                    d_writedataout={24'b0,write_data[7:0]}; \n                end\n            endcase\n        2'b01:\n            case(d_address[1])\n                0: \n                begin \n                    d_byteena=4'b1100; \n                    d_writedataout={write_data[15:0],16'b0}; \n                end\n                default: \n                begin \n                    d_byteena=4'b0011; \n                    d_writedataout={16'b0,write_data[15:0]}; \n                end\n            endcase\n        default:\n        begin\n            d_byteena=4'b1111;\n            d_writedataout=write_data;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "store_data_translator #",
        "module_hash": "f0d5a09c2412de1720a22d606598d50a",
        "dataset_index": 2818
      },
      "data_transfer_2dc00c47": {
        "rtl_code": "module data_transfer(clk, rst, input_data, input_valid, output_data, output_valid);\n  input clk, rst, input_valid;\n  input [7:0] input_data;\n  output [7:0] output_data;\n  output output_valid;\n  \n  reg [7:0] data_reg;\n  reg valid_reg;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      data_reg <= 0;\n      valid_reg <= 0;\n    end else if (input_valid) begin\n      data_reg <= input_data;\n      valid_reg <= 1;\n    end else begin\n      valid_reg <= 0;\n    end\n  end\n  \n  assign output_data = data_reg;\n  assign output_valid = valid_reg;\n  \nendmodule",
        "module_name": "data_transfer",
        "module_hash": "2dc00c477dd78ac0b0a7ed292f45f0bb",
        "dataset_index": 16920
      },
      "top__774ee52b": {
        "rtl_code": "module top_module (\n    input clk,\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output reg q\n);\n\n    wire mux_out;\n    mux_2to1 mux_inst (\n        .a(a),\n        .b(b),\n        .sel(sel_b1),\n        .out(mux_out)\n    );\n\n    d_flip_flop dff_inst (\n        .clk(clk),\n        .d(mux_out),\n        .q(q)\n    );\n\nendmodule\n\nmodule mux_2to1 (\n    input a,\n    input b,\n    input sel,\n    output reg out\n);\n\n    always @(*) begin\n        if (sel == 1'b0) begin\n            out = a;\n        end else begin\n            out = b;\n        end\n    end\n\nendmodule\n\nmodule d_flip_flop (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "774ee52b43e8846ea748add275b808c9",
        "dataset_index": 12527
      },
      "sky130_fd_sc_ls__and3b_ace64a1d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__and3b (\n    X  ,\n    A_N,\n    B  ,\n    C\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N            );\n    and and0 (and0_out_X, C, not0_out, B );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__and3b",
        "module_hash": "ace64a1dd32c4a694b20d0cd4f7912c1",
        "dataset_index": 23564
      },
      "r_FAULT_STATUS_914e227c": {
        "rtl_code": "module r_FAULT_STATUS(output reg [7:0] reg_0x1F, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n    always @(posedge clk) begin\n        if (reset == 1'b1) begin\n            reg_0x1F <= 8'h00;\n        end\n        else begin\n            if (wenb == 1'b0) begin\n                reg_0x1F <= in_data;\n            end\n            else begin\n                reg_0x1F <= reg_0x1F;\n            end\n        end\n    end\nendmodule",
        "module_name": "r_FAULT_STATUS",
        "module_hash": "914e227c3089131c849de7f0983b437c",
        "dataset_index": 15705
      },
      "Arithmetic_Unit_32b68c8a": {
        "rtl_code": "module Arithmetic_Unit(a, b, ctrl, result);\n    input [3:0] a, b;\n    input [1:0] ctrl;\n    output reg [3:0] result;\n    \n    always @(*) begin\n        case(ctrl)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule",
        "module_name": "Arithmetic_Unit",
        "module_hash": "32b68c8a04097ec26a9f5693bbe05dfc",
        "dataset_index": 11567
      },
      "a23_multiply_3db8e73d": {
        "rtl_code": "module a23_multiply (\ninput                       i_clk,\ninput                       i_rst,\n\ninput       [31:0]          i_a_in,         input       [31:0]          i_b_in,         input       [1:0]           i_function,\ninput                       i_execute,\n\noutput      [31:0]          o_out,\noutput      [1:0]           o_flags,        output                      o_done    );\n\n\nwire        enable;\nwire        accumulate;\n\nreg  [31:0] product;\nreg  [3:0]  count;\n\nassign enable         = i_function[0];\nassign accumulate     = i_function[1];\n\nassign o_out   = product;\n\nassign o_flags = {o_out[31], o_out == 32'd0 }; \nassign o_done  = 1'b1;\n\n\nalways @(posedge i_clk or posedge i_rst) begin\n  if (i_rst) begin\n    product <= 32'b0;\n    count <= 4'b0;\n  end else if(enable) begin\n    count <= count + 1;\n    if (i_execute && count == 0) begin\n      product <= i_a_in*i_b_in;\n    end else if (i_execute && accumulate && count == 3) begin\n      product <= product + i_a_in;\n    end\n  end else begin\n    product <= 32'b0;\n    count <= 4'b0;\n  end\nend\n\nendmodule\n\n\n",
        "module_name": "a23_multiply",
        "module_hash": "3db8e73df52c3d0ae37382617bef446d",
        "dataset_index": 24637
      },
      "bin2gray_d5720010": {
        "rtl_code": "module bin2gray(\n    input [3:0] bin_in,\n    output [3:0] gray_out\n);\n\n    assign gray_out[0] = bin_in[0];\n    assign gray_out[1] = bin_in[0] ^ bin_in[1];\n    assign gray_out[2] = bin_in[1] ^ bin_in[2];\n    assign gray_out[3] = bin_in[2] ^ bin_in[3];\n    \nendmodule",
        "module_name": "bin2gray",
        "module_hash": "d572001018fd76592a8b849e8d19bff2",
        "dataset_index": 8629
      },
      "INV4BITS_2b36abec": {
        "rtl_code": "module INV4BITS (\n    input [3:0] in,\n    output [3:0] out\n);\n\n    assign out = ~in;\n\nendmodule",
        "module_name": "INV4BITS",
        "module_hash": "2b36abec0180d8cfd859628eacfe72cf",
        "dataset_index": 6338
      },
      "rfid_1c5db08e": {
        "rtl_code": "module rfid (\n  input clk,\n  input [7:0] tx_data,\n  input tx_en,\n  input rx_en,\n  output [7:0] rx_data\n);\n\n  // Define modulation scheme used by transmitter block\n  // For simplicity, we will use amplitude shift keying (ASK)\n  reg [1:0] tx_mod;\n  always @ (posedge clk) begin\n    if (tx_en) begin\n      if (tx_data[0]) begin\n        tx_mod <= 2'b11; // High amplitude\n      end else begin\n        tx_mod <= 2'b01; // Low amplitude\n      end\n    end else begin\n      tx_mod <= 2'b00; // No transmission\n    end\n  end\n  \n  // Define decoding algorithm used by receiver block\n  // For simplicity, we will use amplitude detection for ASK\n  reg [7:0] rx_data_reg;\n  always @ (posedge clk) begin\n    if (rx_en) begin\n      if (tx_mod == 2'b11) begin\n        rx_data_reg <= 8'b11111111; // High amplitude detected, set all bits to 1\n      end else begin\n        rx_data_reg <= tx_data; // Low amplitude detected, retrieve original data\n      end\n    end\n  end\n  \n  // Connect inputs to transmitter and receiver blocks\n  assign rx_data = rx_data_reg;\n  \nendmodule",
        "module_name": "rfid",
        "module_hash": "1c5db08ee6d62996ea965720ae6e02be",
        "dataset_index": 17475
      },
      "BOOL_EXP_850bea89": {
        "rtl_code": "module BOOL_EXP (\n  input A,\n  input B,\n  output OUT\n);\n\n  wire a_and_not_b_or_a = A & ~(B | A);\n  wire not_a_and_b = ~A & B;\n  \n  assign OUT = a_and_not_b_or_a | not_a_and_b;\n\nendmodule",
        "module_name": "BOOL_EXP",
        "module_hash": "850bea896e8616cc17ba72bad0cb8712",
        "dataset_index": 15718
      },
      "win_blk_mem_gen_prim_width__parameterized3_27dc6486": {
        "rtl_code": "\nmodule win_blk_mem_gen_prim_width__parameterized3 (\n    douta10,\n    douta11,\n    clka,\n    addra,\n    dina,\n    wea\n);\n\n    output [7:0] douta10;\n    output douta11;\n    input clka;\n    input [13:0] addra;\n    input [8:0] dina;\n    input wea;\n\n    // Code for the module implementation\n\nendmodule\n\nmodule block_mem\n(\n    input clk,\n    input [12:0] addr,\n    input [9:0] din,\n    input we,\n    output reg [9:0] dout\n);\n\n    wire [7:0] douta10;\n    wire douta11;\n    wire [13:0] addra;\n    wire [8:0] dina;\n    wire wea;\n\n    assign addra = addr;\n    assign dina = din;\n    assign wea = we;\n\n    win_blk_mem_gen_prim_width__parameterized3 mem\n    (\n        .douta10(douta10),\n        .douta11(douta11),\n        .clka(clk),\n        .addra(addra),\n        .dina(dina),\n        .wea(wea)\n    );\n\n    always @(posedge clk) begin\n        if (douta11) begin\n            dout <= {1'b0, douta10};\n        end\n        else begin\n            dout <= douta10;\n        end\n    end\n\nendmodule\n",
        "module_name": "win_blk_mem_gen_prim_width__parameterized3",
        "module_hash": "27dc64864debe88cab3c8fadb3c49507",
        "dataset_index": 17458
      },
      "mux4to1_471fc984": {
        "rtl_code": "module mux4to1 (\n    input  [3:0] data_in,\n    input  [1:0] sel,\n    output reg     data_out\n);\n\n    wire [3:0] sel_inv;\n    assign sel_inv = ~sel;\n\n    always @ (*) begin\n        if (sel == 2'b00) begin\n            data_out = data_in[0];\n        end else if (sel == 2'b01) begin\n            data_out = data_in[1];\n        end else if (sel == 2'b10) begin\n            data_out = data_in[2];\n        end else if (sel == 2'b11) begin\n            data_out = data_in[3];\n        end\n    end\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "471fc984f1c406894565889524b49ee2",
        "dataset_index": 7204
      },
      "mux4to1_59748d65": {
        "rtl_code": "\nmodule mux4to1 (input [1:0] S, input D0, input D1, input D2, input D3, input OE, output Y);\n\nwire Z0, Z1, Z2, Z3;\nassign Z0 = OE ? D0 : 1'b0;\nassign Z1 = OE ? D1 : 1'b0;\nassign Z2 = OE ? D2 : 1'b0;\nassign Z3 = OE ? D3 : 1'b0;\n\nassign Y = (S == 2'b00) ? Z0 :\n           (S == 2'b01) ? Z1 :\n           (S == 2'b10) ? Z2 :\n           (S == 2'b11) ? Z3 : 1'b0;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "59748d65bf92d2459bc4785763b60bba",
        "dataset_index": 10971
      },
      "four_bit_adder_dee2bd19": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [3:0] c;\nassign c[0] = cin;\nassign c[1] = a[0] & b[0];\nassign c[2] = a[1] & b[1] | a[1] & c[1] | b[1] & c[1];\nassign c[3] = a[2] & b[2] | a[2] & c[2] | b[2] & c[2];\nassign sum = a + b + c;\nassign cout = (a[3] & b[3]) | (a[3] & c[3]) | (b[3] & c[3]);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "dee2bd19c6266174e33281eff3cb8762",
        "dataset_index": 10579
      },
      "adder_8bit_a046b0a8": {
        "rtl_code": "module adder_8bit(\n  input [7:0] A,\n  input [7:0] B,\n  input enable,\n  output reg [7:0] C\n);\n\n  always @(*) begin\n    if(enable) begin\n      C <= A + B;\n    end else begin\n      C <= 8'b0;\n    end\n  end\n  \nendmodule",
        "module_name": "adder_8bit",
        "module_hash": "a046b0a8ff4f294df5b098bed494c866",
        "dataset_index": 15838
      },
      "ram_16x1k_sp_2b163ff9": {
        "rtl_code": "\nmodule ram_16x1k_sp (\n  clka,\n  ena,\n  wea,\n  addra,\n  dina,\n  douta\n);\n\ninput clka;\ninput ena;\ninput [1 : 0] wea;\ninput [9 : 0] addra;\ninput [15 : 0] dina;\noutput [15 : 0] douta;\n\n\nreg [15:0] mem[0:16383];\n\nalways @(posedge clka) begin\n    if (ena) begin\n        if (wea == 2'b01) // byte write\n            mem[addra][7:0] <= dina[7:0];\n        else if (wea == 2'b10) // half-word write\n            mem[addra][15:8] <= dina[15:8];\n        else if (wea == 2'b11) // word write\n            mem[addra] <= dina;\n    end\nend\n\nassign douta = mem[addra];\n\nendmodule\n",
        "module_name": "ram_16x1k_sp",
        "module_hash": "2b163ff914b6d09b6087f3cd81023e41",
        "dataset_index": 14604
      },
      "top__a61e3d19": {
        "rtl_code": "\nmodule top_module (\n    input a, b, c,\n    input [7:0] in,\n    output reg [2:0] pos,\n    output reg w, x, y, z\n);\n\n    // Priority Encoder\n    wire [7:0] in_inv;\n    assign in_inv = ~in;\n    wire [2:0] pos_inv;\n    priority_encoder pe(\n        .in(in_inv),\n        .pos(pos_inv)\n    );\n    \n    // Multiplexer\n    wire [1:0] sel = pos_inv[1:0];\n    mux4to1 mux(\n        .a(a),\n        .b(b),\n        .c(c),\n        .d(0),\n        .sel(sel)\n    );\n    \n    // Output\n    always @(*) begin\n        case (pos_inv)\n            3'b000: begin\n                w <= in[sel];\n                x <= 0;\n                y <= 0;\n                z <= 0;\n            end\n            3'b001: begin\n                w <= 0;\n                x <= in[sel];\n                y <= 0;\n                z <= 0;\n            end\n            3'b010: begin\n                w <= 0;\n                x <= 0;\n                y <= in[sel];\n                z <= 0;\n            end\n            3'b011: begin\n                w <= 0;\n                x <= 0;\n                y <= 0;\n                z <= in[sel];\n            end\n            default: begin\n                w <= 0;\n                x <= 0;\n                y <= 0;\n                z <= 0;\n            end\n        endcase\n    end\n    \n    // Output Position\n    always @(in) begin\n        if (in == 8'b00000000) begin\n            pos <= 3'b000;\n        end else begin\n            pos <= pos_inv;\n        end\n    end\n    \nendmodule\nmodule mux4to1 (\n    input a, b, c, d,\n    input [1:0] sel,\n    output reg out\n);\n\n    always @* begin\n        case (sel)\n            2'b00: out <= a;\n            2'b01: out <= b;\n            2'b10: out <= c;\n            2'b11: out <= d;\n            default: out <= 0;\n        endcase\n    end\n    \nendmodule\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @* begin\n        casez (in)\n            8'b00000001: pos <= 3'b000;\n            8'b00000011: pos <= 3'b001;\n            8'b00000111: pos <= 3'b010;\n            8'b00001111: pos <= 3'b011;\n            8'b00011111: pos <= 3'b100;\n            8'b00111111: pos <= 3'b101;\n            8'b01111111: pos <= 3'b110;\n            8'b11111111: pos <= 3'b111;\n            default: pos <= 3'b000;\n        endcase\n    end\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "a61e3d195ff2b9c2be3733d45fd1592e",
        "dataset_index": 11090
      },
      "d_ff_en_gated_4b80d57d": {
        "rtl_code": "\nmodule d_ff_en_gated (\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  reg ENCLK_internal = 0; // Initialize to 0 \n  always @ (posedge CLK) \n    if (EN) \n      ENCLK_internal <= TE;\n    else \n      ENCLK_internal <= 0;\n\n  always @*\n    ENCLK = ENCLK_internal;\n\nendmodule",
        "module_name": "d_ff_en_gated",
        "module_hash": "4b80d57d1cd15f618aca217184f11ec2",
        "dataset_index": 7979
      },
      "modulo_92734193": {
        "rtl_code": "\nmodule modulo (\n  input [31:0] A,\n  input [31:0] B,\n  output [31:0] C\n);\n\n  // If B is zero, the output C should be zero.\n  // If A is zero, the output C should be zero.\n  // In both cases, we can simply assign zero to the output.\n  assign C = (B == 0) ? 0 : ((A == 0) ? 0 : ((A < 0) ? ((B < 0) ? -A % -B : -A % B) : ((B < 0) ? A % -B : A % B)));\n\nendmodule",
        "module_name": "modulo",
        "module_hash": "927341938b81716908b789c7b5069031",
        "dataset_index": 14221
      },
      "MULT18X18S_62982c69": {
        "rtl_code": "module MULT18X18S\n  (output reg signed [35:0] P,\n   input signed [17:0] A,\n   input signed [17:0] B,\n   input C,    input CE,   input R     );\n   \n   always @(posedge C)\n     if(R)\n       P <= 36'sd0;\n     else if(CE)\n       P <= A * B;\n\nendmodule ",
        "module_name": "MULT18X18S",
        "module_hash": "62982c6903cb7ee277e47aa3524a9cf4",
        "dataset_index": 24694
      },
      "test_831fd56e": {
        "rtl_code": "module test(I1,I2,I3,I4,enter,win,lose,reset,equal,bigger,smaller,nums,CLK,outs,numa);\n\tinput CLK;\n\twire good;\n\toutput reg outs;\n\treg[0:22] out;\n\talways @(posedge good or posedge reset) begin\n\t\tif(reset)\n\t\t\touts = 0 ;\n\t\telse\n\t\t\touts = ~outs;\n\tend\n\talways @(posedge CLK or posedge reset) begin\n\t\tif(reset)\n\t\t\tout = 0 ;\n\t\telse\n\t\t\tout = out + 1;\n\tend\n\tassign good = (out == 23'd100000);\n\tinput I1, I2, I3, I4, enter,reset; \n\treg[0:6] a1,a2,a3,a4,suc,b1,b2,b3,b4;\n\toutput reg[0:3] numa;\n\treg[0:3] numb;\n\toutput reg win,lose;\n\toutput reg equal,bigger,smaller;\n\treg runa,runb;\n\treg [0:3] turn;\n\toutput reg [0:3] nums;\n\treg [0:4] ins;\n\tinitial begin\n\t\tins = 0;\n\t\tnums = 0;\n\t\twin = 0;\n\t\tsuc = 0;\n\t\truna = 1;\n\t\trunb = 0;\n\t\tlose = 0;\n\t\tequal = 0;\n\t\tbigger = 0;\n\t\tsmaller = 0;\n\t\ta1 = 0;\n\t\ta2 = 0;\n\t\ta3 = 0;\n\t\ta4 = 0;\n\t\tb1 = 0;\n\t\tb2 = 0;\n\t\tb3 = 0;\n\t\tb4 = 0;\n\t\tnuma = 0;\n\t\tnumb = 0;\n\t\tturn = 0;\n\tend\n\talways @(posedge good or posedge reset) begin\n\t\tif(reset) begin\n\t\t\twin = 0;\n\t\t\tsuc = 0;\n\t\t\truna = 1;\n\t\t\trunb = 0;\n\t\t\tlose = 0;\n\t\t\tequal = 0;\n\t\t\tbigger = 0;\n\t\t\tsmaller = 0;\n\t\t\tnums = 0;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\ta3 = 0;\n\t\t\ta4 = 0;\n\t\t\tb1 = 0;\n\t\t\tb2 = 0;\n\t\t\tb3 = 0;\n\t\t\tb4 = 0;\n\t\t\tnuma = 0;\n\t\t\tnumb = 0;\n\t\t\tturn = 0;\n\t\t\tins = 0;\n\t\tend\n\t\telse begin\n\t\t\tif(I1 & ~ins[0]) begin\n\t\t\t\tins[0] = 1;\n\t\t\t\tnums = 0;\n\t\t\t\tnums[0] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta1[numa] = 1;\n\t\t\t\t\tnuma = numa + 1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb1[numb] = 1;\n\t\t\t\t\tnumb=numb + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if(~I1)\n\t\t\t\tins[0] = 0;\n\t\t\tif(I2 & ~ins[1]) begin\n\t\t\t\tnums = 0;\n\t\t\t\tnums[1] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta2[numa] = 1;\n\t\t\t\t\tnuma=numa+1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb2[numb] = 1;\n\t\t\t\t\tnumb=numb+1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if(~I2)\n\t\t\t\tins[1] = 0;\n\t\t\tif(I3 & ~ins[2]) begin\n\t\t\t\tnums = 0;\n\t\t\t\tins[2] = 1;\n\t\t\t\tnums[2] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta3[numa] = 1;\n\t\t\t\t\tnuma=numa+1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb3[numb] = 1;\n\t\t\t\t\tnumb=numb+1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if(~I3)\n\t\t\t\tins[2] = 0;\n\t\t\tif(I4 & ~ins[3]) begin\n\t\t\t\tins[3] = 1;\n\t\t\t\tnums = 0;\n\t\t\t\tnums[3] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta4[numa] = 1;\n\t\t\t\t\tnuma=numa+1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb4[numb] = 1;\n\t\t\t\t\tnumb=numb+1;\n\t\t\t\tend   \n\t\t\tend\n\t\t\telse if(~I4)\n\t\t\t\tins[3] = 0;\n\t\t\tif(enter & ~ins[4]) begin\n\t\t\t\tif(numa > 3) begin\n\t\t\t\t\truna = 0;\n\t\t\t\t\trunb = 1;\n\t\t\t\tend\n\t\t\t\telse if(numa < 4) begin\n\t\t\t\t  a1 = 0;\n\t\t\t\t  a2 = 0;\n\t\t\t\t  a3 = 0;\n\t\t\t\t  a4 = 0;\n\t\t\t\t  numa = 0;\n\t\t\t\tend\n\t\t\t\tif(numb >=4) begin\n\t\t\t\t\tsuc = (a1~^b1)&(a2~^b2)&(a3~^b3)&(a4~^b4);\n\t\t\t\t\twin = suc[0]&suc[1]&suc[2]&suc[3]&suc[4]&suc[5]&suc[6];\n\t\t\t\t\tif((~win) & (turn <3)) begin\n\t\t\t\t\t\tturn=turn+1;\n\t\t\t\t\t\tb1=0;\n\t\t\t\t\t\tb2=0;\n\t\t\t\t\t\tb3=0;\n\t\t\t\t\t\tb4=0;\n\t\t\t\t\tend\n\t\t\t\t\tif(numb > numa) begin\n\t\t\t\t\t\tsmaller = 1;\n\t\t\t\t\t\tbigger = 0;\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\tend\n\t\t\t\t\tif(numb == numa) begin\n\t\t\t\t\t\tsmaller = 0;\n\t\t\t\t\t\tbigger = 0;\n\t\t\t\t\t\tequal = 1;\n\t\t\t\t\tend\n\t\t\t\t\tif(numb < numa) begin\n\t\t\t\t\t\tsmaller = 0;\n\t\t\t\t\t\tbigger = 1;\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\tend\n\t\t\t\t  numb = 0;\n\t\t\t\tend \n\t\t\t\tif((~win) & (turn >= 3))\n\t\t\t\t\tlose = 1;\n\t\t\tend\n\t\t\telse if(~enter)\n\t\t\t\tins[4] = 0;\n\t\t\tbegin\n\t\t\t\tif(numa == 7) begin\n\t\t\t\t\truna = 0;\n\t\t\t\t\trunb = 1;\n\t\t\t\tend\n\t\t\t\tif(numb == 7)\n\t\t\t\t\trunb = 0;\n\t\t\tend\n\t\tend\n\tend\nendmodule ",
        "module_name": "test",
        "module_hash": "831fd56ef4d9b68f84a3d05a06a48a44",
        "dataset_index": 23579
      },
      "up_counter_1fec7a47": {
        "rtl_code": "module up_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count_out\n);\n\nreg j, k;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    count_out <= 4'b0000;\n    j <= 1'b0;\n    k <= 1'b0;\n  end\n  else begin\n    case ({j,k})\n      2'b00: begin // Qn-1 = 0, Qn = 0\n        count_out <= count_out + 1;\n        j <= 1'b1;\n      end\n      2'b01: begin // Qn-1 = 0, Qn = 1\n        j <= 1'b0;\n        k <= 1'b1;\n      end\n      2'b10: begin // Qn-1 = 1, Qn = 0\n        j <= 1'b1;\n        k <= 1'b0;\n      end\n      2'b11: begin // Qn-1 = 1, Qn = 1\n        j <= 1'b1;\n        k <= 1'b1;\n      end\n    endcase\n  end\nend\n\nendmodule\n",
        "module_name": "up_counter",
        "module_hash": "1fec7a47bed6f3e33664a39ca7a29944",
        "dataset_index": 18161
      },
      "PLL_2f8e48c1": {
        "rtl_code": "module PLL (\n    inclk0,\n    c0\n);\n\n    parameter   integer   DIV_FACTOR = 2;\n\n    input       inclk0;\n    output      c0;\n\n    reg         [31:0]   counter;\n    reg                   clk_out;\n\n    always @(posedge inclk0) begin\n        if (counter == DIV_FACTOR - 1) begin\n            counter <= 0;\n            clk_out <= ~clk_out;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign c0 = clk_out;\n\nendmodule",
        "module_name": "PLL",
        "module_hash": "2f8e48c13e2bfa5e182bd3fb5187da90",
        "dataset_index": 4825
      },
      "binary_ones_counter_388df24e": {
        "rtl_code": "module binary_ones_counter (\n    input [15:0] data_in,\n    output reg [3:0] ones_count\n);\n\n    integer i;\n    reg [15:0] temp;\n\n    always @ (data_in) begin\n        temp = data_in;\n        ones_count = 0;\n        for (i = 0; i < 16; i = i + 1) begin\n            if (temp[0] == 1'b1) begin\n                ones_count = ones_count + 1;\n            end\n            temp = temp >> 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_ones_counter",
        "module_hash": "388df24ef7c5dbd10c24e180def161b0",
        "dataset_index": 18324
      },
      "my_module_1f07a7c9": {
        "rtl_code": "\nmodule my_module(\n    input CLOCK_IN,\n    input RESET,\n    input [2:0] SWITCH,\n    output reg [3:0] LED\n);\n\nalways @(posedge CLOCK_IN) begin\n    if(RESET) begin\n        LED <= 4'b0000;\n    end\n    else begin\n        case(SWITCH)\n            3'b000: LED <= 4'b0001;\n            3'b001: LED <= 4'b0010;\n            3'b010: LED <= 4'b0100;\n            3'b011: LED <= 4'b1000;\n            default: LED <= 4'b1111;\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "my_module",
        "module_hash": "1f07a7c908f5252fe2486720ed045a14",
        "dataset_index": 19803
      },
      "sub_8f0029e7": {
        "rtl_code": "\nmodule sub (\n    // Outputs\n    outy_w92, outz_w22,\n    // Inputs\n    clk, inw_w31, inx_w11\n    );\n\n    input clk;\n    input        inw_w31;\n    input [60:0] inx_w11;\n    output [91:0] outy_w92;\n    output [21:0] outz_w22;\n\n    wire [29:0] outc_w30;\n    wire [72:0] outd_w73;\nendmodule\n\nmodule t (\n    // Outputs\n    outc_w30,\n    outd_w73,\n    // Inputs\n    clk,\n    ina_w1,\n    inb_w61\n    );\n\n    input clk;\n    input ina_w1;\n    input [60:0] inb_w61;\n    output [29:0] outc_w30;\n    output [72:0] outd_w73;\n\n    assign outc_w30 = ina_w1 - inb_w61[30:0];\n    assign outd_w73 = ina_w1 * inb_w61;\n\nendmodule\n",
        "module_name": "sub",
        "module_hash": "8f0029e7cdf3cfa94b3628d6b587f841",
        "dataset_index": 20011
      },
      "unsigned_non_restoring_divider_5ba12919": {
        "rtl_code": "\nmodule unsigned_non_restoring_divider (\n  input [N-1:0] dividend,\n  input [N-1:0] divisor,\n  input clk,\n  input rst,\n  output [N-1:0] quotient,\n  output [N-1:0] remainder\n);\n\nparameter N = 8; // number of bits for dividend and divisor\n\nreg [N-1:0] dividend_reg;\nreg [N-1:0] divisor_reg;\nreg [N-1:0] quotient_reg;\nreg [N-1:0] remainder_reg;\nreg [N-1:0] dividend_shift_reg;\nreg [N:0] counter_reg;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    dividend_reg <= 0;\n    divisor_reg <= 0;\n    quotient_reg <= 0;\n    remainder_reg <= 0;\n    dividend_shift_reg <= {dividend, 1'b0};\n    counter_reg <= N+1;\n  end\n  else begin\n    dividend_reg <= dividend_shift_reg[N-1:0];\n    divisor_reg <= divisor;\n    if (counter_reg == 0) begin\n      remainder_reg <= dividend_shift_reg[N-1:0];\n      quotient_reg <= quotient_reg << 1 | dividend[N-1];\n      dividend_shift_reg <= {dividend, 1'b0};\n      counter_reg <= N+1;\n    end\n    else begin\n      if (remainder_reg >= divisor_reg) begin\n        remainder_reg <= remainder_reg - divisor_reg;\n        quotient_reg <= quotient_reg | 1<<(counter_reg-1);\n      end\n      else begin\n        quotient_reg <= quotient_reg | 0<<(counter_reg-1);\n      end\n      counter_reg <= counter_reg - 1;\n    end\n  end\nend\n\nassign quotient = quotient_reg;\nassign remainder = remainder_reg;\n\nendmodule",
        "module_name": "unsigned_non_restoring_divider",
        "module_hash": "5ba129190c645b7410f354266e67d7e9",
        "dataset_index": 15896
      },
      "karnaugh_map_5_2b23a91c": {
        "rtl_code": "module karnaugh_map_5(\n  input wire A, B, C, D, E,\n  output reg F\n);\n\nalways @(*) begin\n  case ({A,B,C,D,E})\n    5'b00000: F = 1'b0;\n    5'b00001: F = 1'b1;\n    5'b00010: F = 1'b0;\n    5'b00011: F = 1'b1;\n    5'b00100: F = 1'b0;\n    5'b00101: F = 1'b1;\n    5'b00110: F = 1'b0;\n    5'b00111: F = 1'b1;\n    5'b01000: F = 1'b0;\n    5'b01001: F = 1'b1;\n    5'b01010: F = 1'b0;\n    5'b01011: F = 1'b1;\n    5'b01100: F = 1'b0;\n    5'b01101: F = 1'b1;\n    5'b01110: F = 1'b0;\n    5'b01111: F = 1'b1;\n    default: F = 1'b0;\n  endcase\nend\n\nendmodule",
        "module_name": "karnaugh_map_5",
        "module_hash": "2b23a91c81621fc0347c0bcf295e5db2",
        "dataset_index": 14989
      },
      "mux4_20544d3a": {
        "rtl_code": "\nmodule mux4 (\n    input A, B, C, D,\n    input S0, S1,\n    output X\n);\n\n    wire not_S0, not_S1, and0, and1, and2, and3, or0, or1;\n\n    not (not_S0, S0);\n    not (not_S1, S1);\n\n    and (and0, A, not_S0, not_S1);\n    and (and1, B, not_S0, S1);\n    and (and2, C, S0, not_S1);\n    and (and3, D, S0, S1);\n\n    or (or0, and0, and1);\n    or (or1, and2, and3);\n\n    or (X, or0, or1);\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "20544d3a738016010922fff91bbabef9",
        "dataset_index": 9077
      },
      "multiplier_block_acad15d2": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w32768,\n    w32769,\n    w8192,\n    w24577,\n    w16,\n    w24593,\n    w128,\n    w24465;\n\n  assign w1 = i_data0;\n  assign w128 = w1 << 7;\n  assign w16 = w1 << 4;\n  assign w32768 = w1 << 15;\n  assign w32769 = w1 + w32768;\n  assign w8192 = w1 << 13;\n  assign w24577 = w32769 - w8192;\n  assign w24593 = w24577 + w16;\n  assign w24465 = w24593 - w128;\n\n  assign o_data0 = w24465;\n\n  //multiplier_block area estimate = 6350.09758873383;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "acad15d2d9255b0c5282ceb7b9d72b49",
        "dataset_index": 2970
      },
      "bitwise_op_635c92df": {
        "rtl_code": "module bitwise_op(input [7:0] A, input [7:0] B, input [1:0] C, output reg [7:0] out);\n    always @(*) begin\n        case(C)\n            2'b00: out = A & B;\n            2'b01: out = A | B;\n            2'b10: out = A ^ B;\n            2'b11: out = ~(A ^ B);\n        endcase\n    end\nendmodule",
        "module_name": "bitwise_op",
        "module_hash": "635c92df40f7eb848fd7ffe8fe5251f0",
        "dataset_index": 11719
      },
      "top__31ed6d49": {
        "rtl_code": "module top_module (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    // Instantiate the barrel shifter module\n    barrel_shifter bs(\n        .data(in),\n        .shift(1),\n        .out(wire_bs_out)\n    );\n    \n    // Instantiate the two's complement module\n    twos_complement tc(\n        .in(wire_bs_out),\n        .out(out)\n    );\n\n    // Declare wire for output of barrel shifter module\n    wire [3:0] wire_bs_out;\n\nendmodule\n\n// Barrel shifter module\nmodule barrel_shifter (\n    input [3:0] data,\n    input [1:0] shift,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(shift)\n            2'b00: out = data; // No shift\n            2'b01: out = {data[2:0], data[3]}; // Rotate left by 1 bit\n            2'b10: out = {data[1:0], data[3:2]}; // Rotate left by 2 bits\n            2'b11: out = {data[0], data[3:1]}; // Rotate left by 3 bits\n        endcase\n    end\n\nendmodule\n\n// Two's complement module\nmodule twos_complement (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        out = ~in + 1;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "31ed6d49326495e474d9783135b9e09f",
        "dataset_index": 12296
      },
      "lfsr_count255_a8647800": {
        "rtl_code": "module lfsr_count255(\n                     input i_sys_clk,\n                     input i_sys_rst,\n                     output reg o_lfsr_256_done);\n\n    reg [7:0]                   lfsr_reg_i;\n    wire                        lfsr_d0_i,lfsr_256_equal_i;\n\n    // Feedback polynomial: x^7 + x^5 + x^4 + x^3 + 1\n    xnor(lfsr_d0_i,lfsr_reg_i[7],lfsr_reg_i[5],lfsr_reg_i[4],lfsr_reg_i[3]);\n    assign lfsr_256_equal_i = (lfsr_reg_i == 8'hFF);\n\n    always @(posedge i_sys_clk,posedge i_sys_rst) begin\n        if(i_sys_rst) begin\n            lfsr_reg_i <= 0;\n            o_lfsr_256_done <= 0;\n        end\n        else begin\n            lfsr_reg_i <= lfsr_256_equal_i ? 8'h0 : {lfsr_reg_i[6:0],lfsr_d0_i};\n            o_lfsr_256_done <= lfsr_256_equal_i;\n        end\n    end\nendmodule",
        "module_name": "lfsr_count255",
        "module_hash": "a8647800e201e0e2413230cba0a1a869",
        "dataset_index": 19716
      },
      "erx_remap_062afcf0": {
        "rtl_code": "module erx_remap (\n   emesh_access_out, emesh_packet_out,\n   clk, emesh_access_in, emesh_packet_in, remap_mode, remap_sel,\n   remap_pattern, remap_base\n   );\n\n   parameter AW = 32;\n   parameter DW = 32;\n   parameter PW = 104;\n   parameter ID = 12'h808;\n   \n   input          clk;\n   \n   input          emesh_access_in;\n   input [PW-1:0] emesh_packet_in;\n   \n   input [1:0] \t  remap_mode;    input [11:0]   remap_sel;     input [11:0]   remap_pattern; input [31:0]   remap_base;    output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n\n   wire [31:0] \t   static_remap;\n   wire [31:0] \t   dynamic_remap;\n   wire [31:0] \t   remap_mux;\n   wire [31:0] \t   addr_in;\n   wire [31:0] \t   addr_out;\n   wire \t   remap_en;\n   \n   reg \t\t   emesh_access_out;\n   reg [PW-1:0]    emesh_packet_out;\n\n   parameter[5:0]  colid = ID[5:0];\n   \n   assign addr_in[31:0]  =  emesh_packet_in[39:8];\n \n   \n   assign static_remap[31:20] = (remap_sel[11:0] & remap_pattern[11:0]) |\n\t\t\t        (~remap_sel[11:0] & addr_in[31:20]);\n\n   assign static_remap[19:0]  = addr_in[19:0];\n    \n   assign dynamic_remap[31:0] = addr_in[31:0]    - (colid << 20)     + remap_base[31:0]  - (addr_in[31:26]<<$clog2(colid));\n     \t\t\t     \n   assign remap_mux[31:0]  = (addr_in[31:20]==ID)     ? addr_in[31:0] : (remap_mode[1:0]==2'b00) ? addr_in[31:0] :\n\t\t\t     (remap_mode[1:0]==2'b01) ? static_remap[31:0] :\n\t  \t\t                                dynamic_remap[31:0];\n\n   always @ (posedge clk)\n       emesh_access_out <= emesh_access_in;\n\n   always @ (posedge clk)    \n       emesh_packet_out[PW-1:0] <= {emesh_packet_in[103:40],\n                                    remap_mux[31:0],\n                                    emesh_packet_in[7:0]\n\t\t\t\t    };\n   \nendmodule ",
        "module_name": "erx_remap",
        "module_hash": "062afcf0999f5fc5fb094d47c053b077",
        "dataset_index": 25206
      },
      "daala_idct4_stream_v1_0_S00_AXIS #_fa4449e0": {
        "rtl_code": "\tmodule daala_idct4_stream_v1_0_S00_AXIS #\n\t(\n\t\tparameter integer C_S_AXIS_TDATA_WIDTH\t= 32\n\t)\n\t(\n\t\tinput wire  S_AXIS_ACLK,\n\t\tinput wire  S_AXIS_ARESETN,\n\t\toutput wire  S_AXIS_TREADY,\n\t\tinput wire [C_S_AXIS_TDATA_WIDTH-1 : 0] S_AXIS_TDATA,\n\t\tinput wire [(C_S_AXIS_TDATA_WIDTH/8)-1 : 0] S_AXIS_TSTRB,\n\t\tinput wire  S_AXIS_TLAST,\n\t\tinput wire  S_AXIS_TVALID\n\t);\n\tfunction integer clogb2 (input integer bit_depth);\n\t  begin\n\t    for(clogb2=0; bit_depth>0; clogb2=clogb2+1)\n\t      bit_depth = bit_depth >> 1;\n\t  end\n\tendfunction\n\n\tlocalparam NUMBER_OF_INPUT_WORDS  = 8;\n\tlocalparam bit_num  = clogb2(NUMBER_OF_INPUT_WORDS-1);\n\tparameter [1:0] IDLE = 1'b0,        WRITE_FIFO  = 1'b1; wire  \taxis_tready;\n\treg mst_exec_state;  \n\tgenvar byte_index;     \n\twire fifo_wren;\n\treg fifo_full_flag;\n\treg [bit_num-1:0] write_pointer;\n\treg writes_done;\n\tassign S_AXIS_TREADY\t= axis_tready;\n\talways @(posedge S_AXIS_ACLK) \n\tbegin  \n\t  if (!S_AXIS_ARESETN) \n\t  begin\n\t      mst_exec_state <= IDLE;\n\t    end  \n\t  else\n\t    case (mst_exec_state)\n\t      IDLE: \n\t        if (S_AXIS_TVALID)\n\t            begin\n\t              mst_exec_state <= WRITE_FIFO;\n\t            end\n\t          else\n\t            begin\n\t              mst_exec_state <= IDLE;\n\t            end\n\t      WRITE_FIFO: \n\t        if (writes_done)\n\t          begin\n\t            mst_exec_state <= IDLE;\n\t          end\n\t        else\n\t          begin\n\t            mst_exec_state <= WRITE_FIFO;\n\t          end\n\n\t    endcase\n\tend\n\tassign axis_tready = ((mst_exec_state == WRITE_FIFO) && (write_pointer <= NUMBER_OF_INPUT_WORDS-1));\n\n\talways@(posedge S_AXIS_ACLK)\n\tbegin\n\t  if(!S_AXIS_ARESETN)\n\t    begin\n\t      write_pointer <= 0;\n\t      writes_done <= 1'b0;\n\t    end  \n\t  else\n\t    if (write_pointer <= NUMBER_OF_INPUT_WORDS-1)\n\t      begin\n\t        if (fifo_wren)\n\t          begin\n\t            write_pointer <= write_pointer + 1;\n\t            writes_done <= 1'b0;\n\t          end\n\t          if ((write_pointer == NUMBER_OF_INPUT_WORDS-1)|| S_AXIS_TLAST)\n\t            begin\n\t              writes_done <= 1'b1;\n\t            end\n\t      end  \n\tend\n\n\tassign fifo_wren = S_AXIS_TVALID && axis_tready;\n\n\tgenerate \n\t  for(byte_index=0; byte_index<= (C_S_AXIS_TDATA_WIDTH/8-1); byte_index=byte_index+1)\n\t  begin:FIFO_GEN\n\n\t    reg  [(C_S_AXIS_TDATA_WIDTH/4)-1:0] stream_data_fifo [0 : NUMBER_OF_INPUT_WORDS-1];\n\n\t    always @( posedge S_AXIS_ACLK )\n\t    begin\n\t      if (fifo_wren)begin\n\t          stream_data_fifo[write_pointer] <= S_AXIS_TDATA[(byte_index*8+7) -: 8];\n\t        end  \n\t    end  \n\t  end\t\t\n\tendgenerate\n\n\tendmodule\n",
        "module_name": "daala_idct4_stream_v1_0_S00_AXIS #",
        "module_hash": "fa4449e019c92b344f45de14d8961cdb",
        "dataset_index": 24220
      },
      "ripple_adder_e1c2d7d0": {
        "rtl_code": "\nmodule ripple_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input clk,  // Added clock input\n    output reg [4:0] sum\n);\n\nreg [3:0] a_reg, b_reg;\nreg [3:0] carry_reg;\n\nalways @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\nend\n\nalways @(posedge clk) begin\n    // Initialize the carry input for the first stage\n    carry_reg[0] <= 0;\n\n    sum[0] <= a_reg[0] ^ b_reg[0] ^ carry_reg[0];\n    carry_reg[0] <= (a_reg[0] & b_reg[0]) | (a_reg[0] & carry_reg[0]) | (b_reg[0] & carry_reg[0]);\n    sum[1] <= a_reg[1] ^ b_reg[1] ^ carry_reg[1];\n    carry_reg[1] <= (a_reg[1] & b_reg[1]) | (a_reg[1] & carry_reg[1]) | (b_reg[1] & carry_reg[1]);\n    sum[2] <= a_reg[2] ^ b_reg[2] ^ carry_reg[2];\n    carry_reg[2] <= (a_reg[2] & b_reg[2]) | (a_reg[2] & carry_reg[2]) | (b_reg[2] & carry_reg[2]);\n    sum[3] <= a_reg[3] ^ b_reg[3] ^ carry_reg[3];\n    carry_reg[3] <= (a_reg[3] & b_reg[3]) | (a_reg[3] & carry_reg[3]) | (b_reg[3] & carry_reg[3]);\n    sum[4] <= carry_reg[3];\nend\n\nendmodule\n",
        "module_name": "ripple_adder",
        "module_hash": "e1c2d7d06f6e8ef9c4d9221ce432d818",
        "dataset_index": 18863
      },
      "fifo_data_info_cd4f3897": {
        "rtl_code": "\nmodule fifo_data_info (\n  // inputs:\n  address,\n  clk,\n  in_port,\n  reset_n,\n\n  // outputs:\n  readdata\n);\n\n  output [31:0] readdata;\n  input [1:0] address;\n  input clk;\n  input [13:0] in_port;\n  input reset_n;\n\n  reg [13:0] fifo [0:13];\n  reg [3:0] write_ptr;\n  reg [3:0] read_ptr;\n  reg [3:0] count;\n\n  // Write enable signal\n  wire we;\n  assign we = (count < 14);\n\n  // Read enable signal\n  wire re;\n  assign re = (count > 0);\n\n  // Write pointer incrementer\n  always @(posedge clk)\n    if (we && reset_n)\n      write_ptr <= write_ptr + 1;\n\n  // Read pointer incrementer\n  always @(posedge clk)\n    if (re && reset_n)\n      read_ptr <= read_ptr + 1;\n\n  // Count incrementer/decrementer\n  always @(posedge clk)\n    if (we && reset_n)\n      count <= count + 1;\n    else if (re && reset_n)\n      count <= count - 1;\n\n  // Write data to FIFO\n  always @(posedge clk)\n    if (we && reset_n)\n      fifo[write_ptr] <= in_port;\n\n  // Read data from FIFO\n  assign readdata = (re && reset_n) ? fifo[read_ptr] : 0;\n\nendmodule\n",
        "module_name": "fifo_data_info",
        "module_hash": "cd4f3897064c755b41ea40d6d3c8aac5",
        "dataset_index": 16389
      },
      "mkSoC_Map_28e40fa5": {
        "rtl_code": "`ifdef BSV_ASSIGNMENT_DELAY\n`else\n  `define BSV_ASSIGNMENT_DELAY\n`endif\n\n`ifdef BSV_POSITIVE_RESET\n  `define BSV_RESET_VALUE 1'b1\n  `define BSV_RESET_EDGE posedge\n`else\n  `define BSV_RESET_VALUE 1'b0\n  `define BSV_RESET_EDGE negedge\n`endif\n\nmodule mkSoC_Map(CLK,\n\t\t RST_N,\n\n\t\t m_plic_addr_base,\n\n\t\t m_plic_addr_size,\n\n\t\t m_plic_addr_lim,\n\n\t\t m_near_mem_io_addr_base,\n\n\t\t m_near_mem_io_addr_size,\n\n\t\t m_near_mem_io_addr_lim,\n\n\t\t m_flash_mem_addr_base,\n\n\t\t m_flash_mem_addr_size,\n\n\t\t m_flash_mem_addr_lim,\n\n\t\t m_ethernet_0_addr_base,\n\n\t\t m_ethernet_0_addr_size,\n\n\t\t m_ethernet_0_addr_lim,\n\n\t\t m_dma_0_addr_base,\n\n\t\t m_dma_0_addr_size,\n\n\t\t m_dma_0_addr_lim,\n\n\t\t m_uart16550_0_addr_base,\n\n\t\t m_uart16550_0_addr_size,\n\n\t\t m_uart16550_0_addr_lim,\n\n\t\t m_gpio_0_addr_base,\n\n\t\t m_gpio_0_addr_size,\n\n\t\t m_gpio_0_addr_lim,\n\n\t\t m_boot_rom_addr_base,\n\n\t\t m_boot_rom_addr_size,\n\n\t\t m_boot_rom_addr_lim,\n\n\t\t m_ddr4_0_uncached_addr_base,\n\n\t\t m_ddr4_0_uncached_addr_size,\n\n\t\t m_ddr4_0_uncached_addr_lim,\n\n\t\t m_ddr4_0_cached_addr_base,\n\n\t\t m_ddr4_0_cached_addr_size,\n\n\t\t m_ddr4_0_cached_addr_lim,\n\n\t\t m_is_mem_addr_addr,\n\t\t m_is_mem_addr,\n\n\t\t m_is_IO_addr_addr,\n\t\t m_is_IO_addr,\n\n\t\t m_is_near_mem_IO_addr_addr,\n\t\t m_is_near_mem_IO_addr,\n\n\t\t m_pc_reset_value,\n\n\t\t m_mtvec_reset_value,\n\n\t\t m_nmivec_reset_value);\n  input  CLK;\n  input  RST_N;\n\n  output [63 : 0] m_plic_addr_base;\n\n  output [63 : 0] m_plic_addr_size;\n\n  output [63 : 0] m_plic_addr_lim;\n\n  output [63 : 0] m_near_mem_io_addr_base;\n\n  output [63 : 0] m_near_mem_io_addr_size;\n\n  output [63 : 0] m_near_mem_io_addr_lim;\n\n  output [63 : 0] m_flash_mem_addr_base;\n\n  output [63 : 0] m_flash_mem_addr_size;\n\n  output [63 : 0] m_flash_mem_addr_lim;\n\n  output [63 : 0] m_ethernet_0_addr_base;\n\n  output [63 : 0] m_ethernet_0_addr_size;\n\n  output [63 : 0] m_ethernet_0_addr_lim;\n\n  output [63 : 0] m_dma_0_addr_base;\n\n  output [63 : 0] m_dma_0_addr_size;\n\n  output [63 : 0] m_dma_0_addr_lim;\n\n  output [63 : 0] m_uart16550_0_addr_base;\n\n  output [63 : 0] m_uart16550_0_addr_size;\n\n  output [63 : 0] m_uart16550_0_addr_lim;\n\n  output [63 : 0] m_gpio_0_addr_base;\n\n  output [63 : 0] m_gpio_0_addr_size;\n\n  output [63 : 0] m_gpio_0_addr_lim;\n\n  output [63 : 0] m_boot_rom_addr_base;\n\n  output [63 : 0] m_boot_rom_addr_size;\n\n  output [63 : 0] m_boot_rom_addr_lim;\n\n  output [63 : 0] m_ddr4_0_uncached_addr_base;\n\n  output [63 : 0] m_ddr4_0_uncached_addr_size;\n\n  output [63 : 0] m_ddr4_0_uncached_addr_lim;\n\n  output [63 : 0] m_ddr4_0_cached_addr_base;\n\n  output [63 : 0] m_ddr4_0_cached_addr_size;\n\n  output [63 : 0] m_ddr4_0_cached_addr_lim;\n\n  input  [63 : 0] m_is_mem_addr_addr;\n  output m_is_mem_addr;\n\n  input  [63 : 0] m_is_IO_addr_addr;\n  output m_is_IO_addr;\n\n  input  [63 : 0] m_is_near_mem_IO_addr_addr;\n  output m_is_near_mem_IO_addr;\n\n  output [63 : 0] m_pc_reset_value;\n\n  output [63 : 0] m_mtvec_reset_value;\n\n  output [63 : 0] m_nmivec_reset_value;\n\n  wire [63 : 0] m_boot_rom_addr_base,\n\t\tm_boot_rom_addr_lim,\n\t\tm_boot_rom_addr_size,\n\t\tm_ddr4_0_cached_addr_base,\n\t\tm_ddr4_0_cached_addr_lim,\n\t\tm_ddr4_0_cached_addr_size,\n\t\tm_ddr4_0_uncached_addr_base,\n\t\tm_ddr4_0_uncached_addr_lim,\n\t\tm_ddr4_0_uncached_addr_size,\n\t\tm_dma_0_addr_base,\n\t\tm_dma_0_addr_lim,\n\t\tm_dma_0_addr_size,\n\t\tm_ethernet_0_addr_base,\n\t\tm_ethernet_0_addr_lim,\n\t\tm_ethernet_0_addr_size,\n\t\tm_flash_mem_addr_base,\n\t\tm_flash_mem_addr_lim,\n\t\tm_flash_mem_addr_size,\n\t\tm_gpio_0_addr_base,\n\t\tm_gpio_0_addr_lim,\n\t\tm_gpio_0_addr_size,\n\t\tm_mtvec_reset_value,\n\t\tm_near_mem_io_addr_base,\n\t\tm_near_mem_io_addr_lim,\n\t\tm_near_mem_io_addr_size,\n\t\tm_nmivec_reset_value,\n\t\tm_pc_reset_value,\n\t\tm_plic_addr_base,\n\t\tm_plic_addr_lim,\n\t\tm_plic_addr_size,\n\t\tm_uart16550_0_addr_base,\n\t\tm_uart16550_0_addr_lim,\n\t\tm_uart16550_0_addr_size;\n  wire m_is_IO_addr, m_is_mem_addr, m_is_near_mem_IO_addr;\n\n  wire NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d37,\n       NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d82,\n       m_is_IO_addr_addr_ULT_0x30000000___d80,\n       m_is_IO_addr_addr_ULT_0x70000000___d35,\n       m_is_IO_addr_addr_ULT_1073741824___d13;\n\n  assign m_plic_addr_base = 64'h000000000C000000 ;\n\n  assign m_plic_addr_size = 64'h0000000000400000 ;\n\n  assign m_plic_addr_lim = 64'd205520896 ;\n\n  assign m_near_mem_io_addr_base = 64'h0000000010000000 ;\n\n  assign m_near_mem_io_addr_size = 64'h0000000000010000 ;\n\n  assign m_near_mem_io_addr_lim = 64'd268500992 ;\n\n  assign m_flash_mem_addr_base = 64'h0000000040000000 ;\n\n  assign m_flash_mem_addr_size = 64'h0000000008000000 ;\n\n  assign m_flash_mem_addr_lim = 64'd1207959552 ;\n\n  assign m_ethernet_0_addr_base = 64'h0000000062100000 ;\n\n  assign m_ethernet_0_addr_size = 64'h0000000000040000 ;\n\n  assign m_ethernet_0_addr_lim = 64'd1645477888 ;\n\n  assign m_dma_0_addr_base = 64'h0000000062200000 ;\n\n  assign m_dma_0_addr_size = 64'h0000000000010000 ;\n\n  assign m_dma_0_addr_lim = 64'd1646329856 ;\n\n  assign m_uart16550_0_addr_base = 64'h0000000062300000 ;\n\n  assign m_uart16550_0_addr_size = 64'h0000000000001000 ;\n\n  assign m_uart16550_0_addr_lim = 64'd1647316992 ;\n\n  assign m_gpio_0_addr_base = 64'h000000006FFF0000 ;\n\n  assign m_gpio_0_addr_size = 64'h0000000000010000 ;\n\n  assign m_gpio_0_addr_lim = 64'd1879048192 ;\n\n  assign m_boot_rom_addr_base = 64'h0000000070000000 ;\n\n  assign m_boot_rom_addr_size = 64'h0000000000001000 ;\n\n  assign m_boot_rom_addr_lim = 64'd1879052288 ;\n\n  assign m_ddr4_0_uncached_addr_base = 64'h0000000080000000 ;\n\n  assign m_ddr4_0_uncached_addr_size = 64'h0000000040000000 ;\n\n  assign m_ddr4_0_uncached_addr_lim = 64'h00000000C0000000 ;\n\n  assign m_ddr4_0_cached_addr_base = 64'h00000000C0000000 ;\n\n  assign m_ddr4_0_cached_addr_size = 64'h0000000040000000 ;\n\n  assign m_ddr4_0_cached_addr_lim = 64'h0000000100000000 ;\n\n  assign m_is_mem_addr =\n\t     m_is_mem_addr_addr >= 64'h00000000C0000000 &&\n\t     m_is_mem_addr_addr < 64'h0000000100000000 ;\n\n  assign m_is_IO_addr =\n\t     NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d82 ||\n\t     !m_is_IO_addr_addr_ULT_0x30000000___d80 &&\n\t     m_is_IO_addr_addr_ULT_1073741824___d13 ;\n\n  assign m_is_near_mem_IO_addr =\n\t     m_is_near_mem_IO_addr_addr >= 64'h0000000010000000 &&\n\t     m_is_near_mem_IO_addr_addr < 64'd268500992 ;\n\n  assign m_pc_reset_value = 64'h0000000070000000 ;\n\n  assign m_mtvec_reset_value = 64'h0000000000001000 ;\n\n  assign m_nmivec_reset_value = 64'hAAAAAAAAAAAAAAAA ;\n\n  assign NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d37 =\n\t     m_is_IO_addr_addr >= 64'h000000000C000000 &&\n\t     m_is_IO_addr_addr < 64'd205520896 ||\n\t     m_is_IO_addr_addr >= 64'h0000000010000000 &&\n\t     m_is_IO_addr_addr < 64'd268500992 ||\n\t     !m_is_IO_addr_addr_ULT_1073741824___d13 &&\n\t     m_is_IO_addr_addr < 64'd1207959552 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062100000 &&\n\t     m_is_IO_addr_addr < 64'd1645477888 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062200000 &&\n\t     m_is_IO_addr_addr < 64'd1646329856 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062300000 &&\n\t     m_is_IO_addr_addr < 64'd1647316992 ||\n\t     m_is_IO_addr_addr >= 64'h000000006FFF0000 &&\n\t     m_is_IO_addr_addr_ULT_0x70000000___d35 ;\n  assign NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d82 =\n\t     NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d37 ||\n\t     !m_is_IO_addr_addr_ULT_0x70000000___d35 &&\n\t     m_is_IO_addr_addr < 64'd1879052288 ||\n\t     m_is_IO_addr_addr >= 64'h0000000080000000 &&\n\t     m_is_IO_addr_addr < 64'h00000000C0000000 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062400000 &&\n\t     m_is_IO_addr_addr < 64'd1648365568 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062310000 &&\n\t     m_is_IO_addr_addr < 64'd1647382528 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062320000 &&\n\t     m_is_IO_addr_addr < 64'd1647448064 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062360000 &&\n\t     m_is_IO_addr_addr < 64'd1647710208 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062330000 &&\n\t     m_is_IO_addr_addr < 64'd1647513600 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062370000 &&\n\t     m_is_IO_addr_addr < 64'd1647775744 ||\n\t     m_is_IO_addr_addr >= 64'h0000000020000000 &&\n\t     m_is_IO_addr_addr_ULT_0x30000000___d80 ;\n  assign m_is_IO_addr_addr_ULT_0x30000000___d80 =\n\t     m_is_IO_addr_addr < 64'h0000000030000000 ;\n  assign m_is_IO_addr_addr_ULT_0x70000000___d35 =\n\t     m_is_IO_addr_addr < 64'h0000000070000000 ;\n  assign m_is_IO_addr_addr_ULT_1073741824___d13 =\n\t     m_is_IO_addr_addr < 64'd1073741824 ;\nendmodule  ",
        "module_name": "mkSoC_Map",
        "module_hash": "28e40fa50457b527d611c5e2c47e6fae",
        "dataset_index": 23789
      },
      "bitwise_op_ba80c9ff": {
        "rtl_code": "module bitwise_op (\n    input [15:0] in1,\n    input [15:0] in2,\n    input [15:0] in3,\n    input [15:0] in4,\n    input reset,\n    output reg [15:0] out1,\n    output reg [15:0] out2\n);\n\n    always @(*) begin\n        if (reset) begin\n            out1 <= 16'b0;\n            out2 <= 16'b0;\n        end else begin\n            out1 <= in1 & in2;\n            out2 <= in3 ^ in4;\n        end\n    end\n\nendmodule",
        "module_name": "bitwise_op",
        "module_hash": "ba80c9ff8a5d1bcda6fad1af941ae8ea",
        "dataset_index": 10372
      },
      "myModule_83298c19": {
        "rtl_code": "module myModule (\n    input CLK,\n    input ready_downstream,\n    output reg ready,\n    input reset,\n    input [64:0] process_input,\n    output reg [64:0] process_output\n);\n\nreg too_soon = process_input[64];\nreg [31:0] output_count = 0;\n\nalways @(posedge CLK) begin\n    if (reset) begin\n        ready <= 1'b0;\n        output_count <= 0;\n        process_output <= 0;\n    end else if (too_soon) begin\n        ready <= 1'b0;\n    end else if (ready_downstream && output_count < 76800) begin\n        ready <= 1'b1;\n        output_count <= output_count + 1;\n        process_output <= ~reset;\n    end else begin\n        ready <= 1'b1;\n        output_count <= output_count + 1;\n        process_output <= {1'b1, process_input[63:0]};\n    end\nend\n\nendmodule",
        "module_name": "myModule",
        "module_hash": "83298c19afeef02564cbdf57c2e3437d",
        "dataset_index": 8023
      },
      "qmem_sram #_d53f81bf": {
        "rtl_code": "\n\n\n\n\n\n\n\n\nmodule qmem_sram #(\n  parameter AW = 32,\n  parameter DW = 32,\n  parameter SW = DW/8\n)(\n  input  wire           clk50,\n  input  wire           clk100,\n  input  wire           rst,\n  input  wire [AW-1:0]  adr,\n  input  wire           cs,\n  input  wire           we,\n  input  wire [SW-1:0]  sel,\n  input  wire [DW-1:0]  dat_w,\n  output reg  [DW-1:0]  dat_r,\n  output wire           ack,\n  output wire           err,\n  output wire [18-1:0]  sram_adr,\n  output wire           sram_ce_n,\n  output wire           sram_we_n,\n  output wire           sram_ub_n,\n  output wire           sram_lb_n,\n  output wire           sram_oe_n,\n  output wire [16-1:0]  sram_dat_w,\n  input  wire [16-1:0]  sram_dat_r\n);\n\n\n\n`ifndef QMEM_SRAM_ASYNC\n`ifdef QMEM_SRAM_SLOW\n\nlocalparam S_ID  = 3'b000; localparam S_HI1 = 3'b011; localparam S_HI2 = 3'b111;\nlocalparam S_LO1 = 3'b010; localparam S_LO2 = 3'b110;\nlocalparam S_FH  = 3'b001; reg [2:0] state, next_state;\n\nalways @ (*)\nbegin\n  case (state)\n    S_ID    : begin if (cs) next_state = S_HI1; else next_state = S_ID; end\n    S_HI1   : begin if (cs) next_state = S_HI2; else next_state = S_ID; end\n    S_HI2   : begin if (cs) next_state = S_LO1; else next_state = S_ID; end\n    S_LO1   : begin if (cs) next_state = S_LO2; else next_state = S_ID; end\n    S_LO2   : begin if (cs) next_state = S_FH;  else next_state = S_ID; end\n    S_FH    : begin                                  next_state = S_ID; end\n    default : begin                                  next_state = S_ID; end\n  endcase\nend\n\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    state <= #1 S_ID;\n  else\n    state <= #1 next_state;\nend\n\n\n\n\nreg [17:0] s_adr;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI1)\n    s_adr <= #1 {adr[18:2], 1'b0};\n  else if (next_state == S_LO1)\n    s_adr <= #1 {adr[18:2], 1'b1};\nend\n\nreg s_ce_n;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ce_n <= #1 1'b1;\n  else if ((next_state == S_HI1) || (next_state == S_HI2) || (next_state == S_LO1) || (next_state == S_LO2))\n    s_ce_n <= #1 1'b0;\n  else\n    s_ce_n <= #1 1'b1;\nend\n\nreg s_we_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI1) || (next_state == S_HI2) || (next_state == S_LO1) || (next_state == S_LO2))\n    s_we_n <= #1 !we;\nend\n\nreg s_ub_n, s_lb_n;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI1)\n    {s_ub_n, s_lb_n} <= #1 {!sel[3], !sel[2]};\n  else if (next_state == S_LO1)\n    {s_ub_n, s_lb_n} <= #1 {!sel[1], !sel[0]};\nend\n\nreg s_oe_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI1) || (next_state == S_HI2) || (next_state == S_LO1) || (next_state == S_LO2))\n    s_oe_n <= #1 we;\n  else\n    s_oe_n <= #1 1'b0;\nend\n\nreg [15:0] s_dat_w;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI1)\n    s_dat_w <= #1 dat_w[31:16];\n  else if (next_state == S_LO1)\n    s_dat_w <= #1 dat_w[15:0];\nend\n\n\n\n\nreg [31:0] s_dat_r;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_LO1) && !we)\n    dat_r[31:16] <= #1 sram_dat_r;\n  else if ((next_state == S_FH) && !we)\n    dat_r[15: 0] <= #1 sram_dat_r;\nend\n\nreg s_ack;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ack <= #1 1'b0;\n  else if ((state == S_LO2) || (state == S_FH))\n    s_ack <= #1 1'b1;\n  else\n    s_ack <= #1 1'b0;\nend\n\n\n\nassign sram_adr   = s_adr;\nassign sram_ce_n  = s_ce_n;\nassign sram_we_n  = s_we_n;\nassign sram_ub_n  = s_ub_n;\nassign sram_lb_n  = s_lb_n;\nassign sram_oe_n  = s_oe_n;\nassign sram_dat_w = s_dat_w;\nassign ack        = s_ack;\nassign err        = 1'b0;\n\n\n`else \nlocalparam S_ID = 2'b00; localparam S_HI = 2'b11; localparam S_LO = 2'b10; localparam S_FH = 2'b01; reg [1:0] state, next_state;\n\nalways @ (*)\nbegin\n  case (state)\n    S_ID    : begin if (cs) next_state = S_HI; else next_state = S_ID; end\n    S_HI    : begin if (cs) next_state = S_LO; else next_state = S_ID; end\n    S_LO    : begin if (cs) next_state = S_FH; else next_state = S_ID; end\n    S_FH    : begin                                 next_state = S_ID; end\n    default : begin                                 next_state = S_ID; end\n  endcase\nend\n\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    state <= #1 S_ID;\n  else\n    state <= #1 next_state;\nend\n\n\n\n\nreg [17:0] s_adr;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI)\n    s_adr <= #1 {adr[18:2], 1'b0};\n  else if (next_state == S_LO)\n    s_adr <= #1 {adr[18:2], 1'b1};\nend\n\nreg s_ce_n;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ce_n <= #1 1'b1;\n  else if ((next_state == S_HI) || (next_state == S_LO))\n    s_ce_n <= #1 1'b0;\n  else\n    s_ce_n <= #1 1'b1;\nend\n\nreg s_we_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI) || (next_state == S_LO))\n    s_we_n <= #1 !we;\nend\n\nreg s_ub_n, s_lb_n;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI)\n    {s_ub_n, s_lb_n} <= #1 {!sel[3], !sel[2]};\n  else if (next_state == S_LO)\n    {s_ub_n, s_lb_n} <= #1 {!sel[1], !sel[0]};\nend\n\nreg s_oe_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI) || (next_state == S_LO))\n    s_oe_n <= #1 we;\n  else\n    s_oe_n <= #1 1'b0;\nend\n\nreg [15:0] s_dat_w;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI)\n    s_dat_w <= #1 dat_w[31:16];\n  else if (next_state == S_LO)\n    s_dat_w <= #1 dat_w[15:0];\nend\n\n\n\n\nreg [31:0] s_dat_r;\nalways @ (posedge clk100)\nbegin\n  if ((state == S_LO) && !we)\n    dat_r[31:16] <= #1 sram_dat_r;\n  else if ((state == S_FH) && !we)\n    dat_r[15: 0] <= #1 sram_dat_r;\nend\n\nreg s_ack;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ack <= #1 1'b0;\n  else if (state == S_LO)\n    s_ack <= #1 1'b1;\n  else\n    s_ack <= #1 1'b0;\nend\n\n\n\nassign sram_adr   = s_adr;\nassign sram_ce_n  = s_ce_n;\nassign sram_we_n  = s_we_n;\nassign sram_ub_n  = s_ub_n;\nassign sram_lb_n  = s_lb_n;\nassign sram_oe_n  = s_oe_n;\nassign sram_dat_w = s_dat_w;\nassign ack        = s_ack;\nassign err        = 1'b0;\n\n\n`endif `else \nreg  [ AW-1:0] adr_r;\nwire           adr_changed;\nreg            cnt;\nreg  [ 16-1:0] rdat_r;\n\n\n\nalways @ (posedge clk50) adr_r <= #1 adr;\nassign adr_changed = (adr != adr_r);\n\n\n\nalways @ (posedge clk50 or posedge rst)\nbegin\n  if (rst)\n    cnt <= #1 1'b0;\n  else if (adr_changed)\n    cnt <= #1 1'b0;\n  else if (cs)\n    cnt <= #1 !cnt;\nend\n\n\n\nalways @ (posedge clk50) if (cs && !cnt && !we) rdat_r <= #1 sram_dat_r;\n\n\n\nalways @ (posedge clk50) if (cs && cnt && !we) dat_r <= #1 {sram_dat_r, rdat_r};\nassign ack = cnt;\nassign err = 1'b0;\n\n\n\nassign sram_adr   = (!cnt) ? {adr[18:2], 1'b0} : {adr[18:2], 1'b1};\nassign sram_ce_n  = !cs;\nassign sram_we_n  = !we;\nassign sram_ub_n  = !((!cnt) ? sel[1] : sel[3]);\nassign sram_lb_n  = !((!cnt) ? sel[0] : sel[2]);\nassign sram_oe_n  = we;\nassign sram_dat_w = (!cnt) ?  dat_w[15:0] : dat_w[31:16];\n\n\n`endif endmodule\n\n",
        "module_name": "qmem_sram #",
        "module_hash": "d53f81bf2b506f53225e9ea95ed5382d",
        "dataset_index": 24974
      },
      "even_parity_checker_79668709": {
        "rtl_code": "\nmodule even_parity_checker(\n    input D0, D1, D2, D3, RST, ECLK, DQSW,\n    output reg Q\n);\n\n    reg [3:0] data_reg;\n\n    always @(posedge ECLK) begin\n        if (RST) begin\n            Q <= 1'b0;\n            data_reg <= 4'b0;\n        end\n        else if (!DQSW) begin\n            data_reg <= {data_reg[2:0], D3};\n        end\n        else begin\n            Q <= ~^data_reg;\n            data_reg <= {D3, D2, D1, D0};\n        end\n    end\n\nendmodule",
        "module_name": "even_parity_checker",
        "module_hash": "79668709d2b6feb35b8b912aed71e1d0",
        "dataset_index": 20966
      },
      "decoder_2to4_adder_85148b9a": {
        "rtl_code": "module decoder_2to4_adder (\n    input clk, \n    input [1:0] in,\n    input ena,\n    input cin,\n    output reg [3:0] out,\n    output reg cout\n);\n\n// Pipeline registers\nreg [1:0] in_reg;\nreg ena_reg;\nreg cin_reg;\n\n// 2-to-4 decoder\nwire [3:0] dec_out;\n// Corrected decoder logic\nassign dec_out = ena ? (1 << in) : 4'b0000;\n\n// Adder logic corrected\nwire [3:0] add_out;\nwire [3:0] add_in = {2'b00, in_reg}; // Ensure matching bit widths for addition\nwire cout_temp; // Temporary carry-out\n\nassign {cout_temp, add_out[1:0]} = add_in[1:0] + {2'b00, cin_reg};\nassign add_out[3:2] = 2'b00; // Upper bits of add_out are not affected by addition\n\n\nalways @(posedge clk) begin\n    in_reg <= in;\n    ena_reg <= ena;\n    cin_reg <= cin;\n    \n    if (ena_reg) begin\n        out <= dec_out | add_out;\n        cout <= cout_temp; \n    end else begin\n        out <= 4'b0000;\n        cout <= 0;\n    end\nend\n\nendmodule\n",
        "module_name": "decoder_2to4_adder",
        "module_hash": "85148b9aa90e4b02b19798e799fb0b7e",
        "dataset_index": 272
      },
      "d_ff_async_reset_26d88d43": {
        "rtl_code": "module d_ff_async_reset (\n    input D,\n    input RESET_B,\n    input CLK,\n    output Q,\n    output Q_N\n);\n\n    reg q;\n    assign Q = q;\n    assign Q_N = ~q;\n\n    always @(posedge CLK or negedge RESET_B) begin\n        if (~RESET_B) begin\n            q <= 0;\n        end else begin\n            q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "d_ff_async_reset",
        "module_hash": "26d88d437375f1f6206855d731296f8c",
        "dataset_index": 5131
      },
      "NV_NVDLA_RT_csb2cacc_25f5b5aa": {
        "rtl_code": "\n// File Name: NV_NVDLA_RT_csb2cacc.v\n\nmodule NV_NVDLA_RT_csb2cacc (\n   nvdla_core_clk\n  ,nvdla_core_rstn\n  ,csb2cacc_req_src_pvld\n  ,csb2cacc_req_src_prdy\n  ,csb2cacc_req_src_pd\n  ,cacc2csb_resp_src_valid\n  ,cacc2csb_resp_src_pd\n  ,csb2cacc_req_dst_pvld\n  ,csb2cacc_req_dst_prdy\n  ,csb2cacc_req_dst_pd\n  ,cacc2csb_resp_dst_valid\n  ,cacc2csb_resp_dst_pd\n  );\n\ninput  nvdla_core_clk;\ninput  nvdla_core_rstn;\n\ninput         csb2cacc_req_src_pvld;  \noutput        csb2cacc_req_src_prdy;  \ninput  [62:0] csb2cacc_req_src_pd;\n\ninput        cacc2csb_resp_src_valid;  \ninput [33:0] cacc2csb_resp_src_pd;     \n\noutput        csb2cacc_req_dst_pvld;  \ninput         csb2cacc_req_dst_prdy;  \noutput [62:0] csb2cacc_req_dst_pd;\n\noutput        cacc2csb_resp_dst_valid;  \noutput [33:0] cacc2csb_resp_dst_pd;     \n\nwire [33:0] cacc2csb_resp_pd_d0;\nwire        cacc2csb_resp_valid_d0;\nwire [62:0] csb2cacc_req_pd_d0;\nwire        csb2cacc_req_pvld_d0;\nreg  [33:0] cacc2csb_resp_pd_d1;\nreg  [33:0] cacc2csb_resp_pd_d2;\nreg  [33:0] cacc2csb_resp_pd_d3;\nreg         cacc2csb_resp_valid_d1;\nreg         cacc2csb_resp_valid_d2;\nreg         cacc2csb_resp_valid_d3;\nreg  [62:0] csb2cacc_req_pd_d1;\nreg  [62:0] csb2cacc_req_pd_d2;\nreg  [62:0] csb2cacc_req_pd_d3;\nreg         csb2cacc_req_pvld_d1;\nreg         csb2cacc_req_pvld_d2;\nreg         csb2cacc_req_pvld_d3;\n\n\nassign csb2cacc_req_src_prdy = 1'b1;\n\n\n\n\nassign csb2cacc_req_pvld_d0 = csb2cacc_req_src_pvld;\nassign csb2cacc_req_pd_d0 = csb2cacc_req_src_pd;\n\n\nassign cacc2csb_resp_valid_d0 = cacc2csb_resp_src_valid;\nassign cacc2csb_resp_pd_d0 = cacc2csb_resp_src_pd;\n\n\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    csb2cacc_req_pvld_d1 <= 1'b0;\n  end else begin\n  csb2cacc_req_pvld_d1 <= csb2cacc_req_pvld_d0;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((csb2cacc_req_pvld_d0) == 1'b1) begin\n    csb2cacc_req_pd_d1 <= csb2cacc_req_pd_d0;\n  // VCS coverage off\n  end else if ((csb2cacc_req_pvld_d0) == 1'b0) begin\n  end else begin\n    csb2cacc_req_pd_d1 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    cacc2csb_resp_valid_d1 <= 1'b0;\n  end else begin\n  cacc2csb_resp_valid_d1 <= cacc2csb_resp_valid_d0;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((cacc2csb_resp_valid_d0) == 1'b1) begin\n    cacc2csb_resp_pd_d1 <= cacc2csb_resp_pd_d0;\n  // VCS coverage off\n  end else if ((cacc2csb_resp_valid_d0) == 1'b0) begin\n  end else begin\n    cacc2csb_resp_pd_d1 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    csb2cacc_req_pvld_d2 <= 1'b0;\n  end else begin\n  csb2cacc_req_pvld_d2 <= csb2cacc_req_pvld_d1;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((csb2cacc_req_pvld_d1) == 1'b1) begin\n    csb2cacc_req_pd_d2 <= csb2cacc_req_pd_d1;\n  // VCS coverage off\n  end else if ((csb2cacc_req_pvld_d1) == 1'b0) begin\n  end else begin\n    csb2cacc_req_pd_d2 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    cacc2csb_resp_valid_d2 <= 1'b0;\n  end else begin\n  cacc2csb_resp_valid_d2 <= cacc2csb_resp_valid_d1;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((cacc2csb_resp_valid_d1) == 1'b1) begin\n    cacc2csb_resp_pd_d2 <= cacc2csb_resp_pd_d1;\n  // VCS coverage off\n  end else if ((cacc2csb_resp_valid_d1) == 1'b0) begin\n  end else begin\n    cacc2csb_resp_pd_d2 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    csb2cacc_req_pvld_d3 <= 1'b0;\n  end else begin\n  csb2cacc_req_pvld_d3 <= csb2cacc_req_pvld_d2;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((csb2cacc_req_pvld_d2) == 1'b1) begin\n    csb2cacc_req_pd_d3 <= csb2cacc_req_pd_d2;\n  // VCS coverage off\n  end else if ((csb2cacc_req_pvld_d2) == 1'b0) begin\n  end else begin\n    csb2cacc_req_pd_d3 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    cacc2csb_resp_valid_d3 <= 1'b0;\n  end else begin\n  cacc2csb_resp_valid_d3 <= cacc2csb_resp_valid_d2;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((cacc2csb_resp_valid_d2) == 1'b1) begin\n    cacc2csb_resp_pd_d3 <= cacc2csb_resp_pd_d2;\n  // VCS coverage off\n  end else if ((cacc2csb_resp_valid_d2) == 1'b0) begin\n  end else begin\n    cacc2csb_resp_pd_d3 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\n\n\nassign csb2cacc_req_dst_pvld = csb2cacc_req_pvld_d3;\nassign csb2cacc_req_dst_pd = csb2cacc_req_pd_d3;\n\n\nassign cacc2csb_resp_dst_valid = cacc2csb_resp_valid_d3;\nassign cacc2csb_resp_dst_pd = cacc2csb_resp_pd_d3;\n\n\n\n\n\nendmodule // NV_NVDLA_RT_csb2cacc\n\n",
        "module_name": "NV_NVDLA_RT_csb2cacc",
        "module_hash": "25f5b5aa3a6eb12ef2b0b5df1813be60",
        "dataset_index": 95
      },
      "half_subtractor_36a8da1e": {
        "rtl_code": "module half_subtractor (\n  input a,\n  input b,\n  output diff,\n  output bout\n);\n  assign diff = a ^ b;\n  assign bout = a & ~b;\nendmodule\n\nmodule full_subtractor (\n  input a,\n  input b,\n  input bin,\n  output diff,\n  output bout\n);\n  wire temp_diff1, temp_diff2, temp_bout1, temp_bout2;\n  half_subtractor hs1(.a(a), .b(b), .diff(temp_diff1), .bout(temp_bout1));\n  half_subtractor hs2(.a(temp_diff1), .b(bin), .diff(diff), .bout(temp_bout2));\n  assign bout = temp_bout1 | temp_bout2;\nendmodule",
        "module_name": "half_subtractor",
        "module_hash": "36a8da1e07c408aa7f6dd9e0a82bfe19",
        "dataset_index": 11223
      },
      "mux6to1_pipeline_696119fa": {
        "rtl_code": "\nmodule mux6to1_pipeline (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'bx;\n    endcase\nend\n\nendmodule\n",
        "module_name": "mux6to1_pipeline",
        "module_hash": "696119faec693c4c23947ffcbc5c882a",
        "dataset_index": 18944
      },
      "top__7f26b86e": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [15:0] in,\n    output reg [7:0] out_sum);\n\n    // Split input into two 8-bit outputs using a barrel shifter\n    reg [7:0] upper_out;\n    reg [7:0] lower_out;\n    always @(*) begin\n        upper_out = in >> 8;\n        lower_out = in & 8'hFF;\n    end\n\n    // 4-bit binary counter\n    reg [3:0] counter;\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'h0;\n        end else if (counter == 4'hF) begin\n            counter <= 4'h0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    // Adder to sum the two values\n    reg [7:0] sum;\n    always @(*) begin\n        sum = upper_out + counter + lower_out;\n    end\n\n    // Output the sum\n    always @(posedge clk) begin\n        if (reset) begin\n            out_sum <= 8'h0;\n        end else begin\n            out_sum <= sum;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "7f26b86e6a1236f3393d35d2da4281e8",
        "dataset_index": 4764
      },
      "binary_counter_52c8b630": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "52c8b6301a4c92f7883c116bf87b64dc",
        "dataset_index": 1609
      },
      "up_down_counter_9b1c5f5f": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input up_down,\n    input load,\n    input [3:0] binary,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        count <= binary;\n    end else if (up_down) begin\n        count <= count + 1;\n    end else begin\n        count <= count - 1;\n    end\nend\n\nendmodule\n\nmodule binary_to_bcd_converter (\n    input [3:0] binary,\n    output [3:0] BCD_HIGH,\n    output [3:0] BCD_LOW\n);\n\nassign BCD_HIGH = binary / 10;\nassign BCD_LOW = binary % 10;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input up_down,\n    input load,\n    input [3:0] binary,\n    output [3:0] BCD_HIGH,\n    output [3:0] BCD_LOW\n);\n\nwire [3:0] count;\nup_down_counter counter(.clk(clk), .up_down(up_down), .load(load), .binary(binary), .count(count));\nbinary_to_bcd_converter converter(.binary(count), .BCD_HIGH(BCD_HIGH), .BCD_LOW(BCD_LOW));\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "9b1c5f5f65b9b0e824e7da8b05d0165a",
        "dataset_index": 7987
      },
      "dmac_2d_transfer_9b61e966": {
        "rtl_code": "module dmac_2d_transfer (\n\tinput req_aclk,\n\tinput req_aresetn,\n\n\tinput req_valid,\n\toutput reg req_ready,\n\n\tinput [31:C_ADDR_ALIGN_BITS] req_dest_address,\n\tinput [31:C_ADDR_ALIGN_BITS] req_src_address,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_x_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_y_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_dest_stride,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_src_stride,\n\tinput req_sync_transfer_start,\n\toutput reg req_eot,\n\t\n\toutput reg out_req_valid,\n\tinput out_req_ready,\n\toutput [31:C_ADDR_ALIGN_BITS] out_req_dest_address,\n\toutput [31:C_ADDR_ALIGN_BITS] out_req_src_address,\n\toutput [C_DMA_LENGTH_WIDTH-1:0] out_req_length,\n\toutput reg out_req_sync_transfer_start,\n\tinput out_eot\n);\n\nparameter C_DMA_LENGTH_WIDTH = 24;\nparameter C_ADDR_ALIGN_BITS = 3;\n\nreg [31:C_ADDR_ALIGN_BITS] dest_address;\nreg [31:C_ADDR_ALIGN_BITS] src_address;\nreg [C_DMA_LENGTH_WIDTH-1:0] x_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] y_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] dest_stride;\nreg [C_DMA_LENGTH_WIDTH-1:0] src_stride;\n\nreg [1:0] req_id;\nreg [1:0] eot_id;\nreg [3:0] last_req;\n\nassign out_req_dest_address = dest_address;\nassign out_req_src_address = src_address;\nassign out_req_length = x_length;\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\treq_id <= 2'b0;\n\t\teot_id <= 2'b0;\n\t\treq_eot <= 1'b0;\n\tend else begin\n\t\tif (out_req_valid && out_req_ready) begin\n\t\t\treq_id <= req_id + 1'b1;\n\t\t\tlast_req[req_id] <= y_length == 0;\n\t\tend\n\t\treq_eot <= 1'b0;\n\t\tif (out_eot) begin\n\t\t\teot_id <= eot_id + 1'b1;\n\t\t\treq_eot <= last_req[eot_id];\n\t\tend\n\tend\nend\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\tdest_address <= 'h00;\n\t\tsrc_address <= 'h00;\n\t\tx_length <= 'h00;\n\t\ty_length <= 'h00;\n\t\tdest_stride <= 'h00;\n\t\tsrc_stride <= 'h00;\n\t\treq_ready <= 1'b1;\n\t\tout_req_valid <= 1'b0;\n\t\tout_req_sync_transfer_start <= 1'b0;\n\tend else begin\n\t\tif (req_ready) begin\n\t\t\tif (req_valid) begin\n\t\t\t\tdest_address <= req_dest_address;\n\t\t\t\tsrc_address <= req_src_address;\n\t\t\t\tx_length <= req_x_length;\n\t\t\t\ty_length <= req_y_length;\n\t\t\t\tdest_stride <= req_dest_stride;\n\t\t\t\tsrc_stride <= req_src_stride;\n\t\t\t\tout_req_sync_transfer_start <= req_sync_transfer_start;\n\t\t\t\treq_ready <= 1'b0;\n\t\t\t\tout_req_valid <= 1'b1;\n\t\t\tend\n\t\tend else begin\n\t\t\tif (out_req_valid && out_req_ready) begin\n\t\t\t\tdest_address <= dest_address + dest_stride[C_DMA_LENGTH_WIDTH-1:C_ADDR_ALIGN_BITS];\n\t\t\t\tsrc_address <= src_address + src_stride[C_DMA_LENGTH_WIDTH-1:C_ADDR_ALIGN_BITS];\n\t\t\t\ty_length <= y_length - 1'b1;\n\t\t\t\tout_req_sync_transfer_start <= 1'b0;\n\t\t\t\tif (y_length == 0) begin\n\t\t\t\t\tout_req_valid <= 1'b0;\n\t\t\t\t\treq_ready <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "dmac_2d_transfer",
        "module_hash": "9b61e966b28b5b555e91d44733a19589",
        "dataset_index": 21600
      },
      "decoder_3to8_22e96d73": {
        "rtl_code": "\nmodule decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output Y0,\n    output Y1,\n    output Y2,\n    output Y3,\n    output Y4,\n    output Y5,\n    output Y6,\n    output Y7\n);\n\nreg [2:0] input_reg;\nwire [7:0] output_wire;\n\nassign output_wire = (input_reg == 3'b000) ? 8'b00000001 :\n                     (input_reg == 3'b001) ? 8'b00000010 :\n                     (input_reg == 3'b010) ? 8'b00000100 :\n                     (input_reg == 3'b011) ? 8'b00001000 :\n                     (input_reg == 3'b100) ? 8'b00010000 :\n                     (input_reg == 3'b101) ? 8'b00100000 :\n                     (input_reg == 3'b110) ? 8'b01000000 :\n                                           8'b10000000 ;\n\nalways @(A or B or C) begin\n    input_reg <= {C, B, A};\nend\n\nassign {Y7, Y6, Y5, Y4, Y3, Y2, Y1, Y0} = output_wire;\n\nendmodule\n",
        "module_name": "decoder_3to8",
        "module_hash": "22e96d73cd1b348990ccb7242aa67c25",
        "dataset_index": 15669
      },
      "SERIAL_OUT_935e530d": {
        "rtl_code": "module SERIAL_OUT(CLK,BYTEIN,ADDR,READ,READY,CLEAR,RX_D,RESET);\ninput CLK,READY,RESET;\ninput [7:0]BYTEIN;\noutput reg RX_D,READ,CLEAR=1;\noutput reg [4:0]ADDR=0;\n\nreg [9:0] data_out=0;\nreg [6:0] count=0;\n\nalways@(posedge CLK or negedge RESET)\nbegin\n\n\tif(RESET==0)\n\t\tbegin\n\t\tcount=0;\n\t\tADDR=0;\n\t\tCLEAR=1;\n\t\tREAD=0;\n\t\tRX_D=1;\n\t\tend\n\telse\n\t\tbegin\n\t\tif(READY==1)\n\t\t\tbegin\n\t\t\tdata_out[0]=0;\n\t\t\tdata_out[1]=BYTEIN[0];\n\t\t\tdata_out[2]=BYTEIN[1];\n\t\t\tdata_out[3]=BYTEIN[2];\n\t\t\tdata_out[4]=BYTEIN[3];\n\t\t\tdata_out[5]=BYTEIN[4];\n\t\t\tdata_out[6]=BYTEIN[5];\n\t\t\tdata_out[7]=BYTEIN[6];\n\t\t\tdata_out[8]=BYTEIN[7];\n\t\t\tdata_out[9]=1;\n\t\t\t\n\t\t\tif(count==9)\n\t\t\t\tbegin\n\t\t\t\tREAD=1;\n\t\t\t\tcount=0;\n\t\t\t\tRX_D=1;\n\t\t\t\tend\n\t\t\telse if(count==8)\n\t\t\t\tbegin\n\t\t\t\tRX_D=data_out[count];\n\t\t\t\tcount=count+1;\n\t\t\t\tREAD=0;\n\t\t\t\tADDR=ADDR+1;\n\t\t\t\tif(ADDR==32)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tADDR=0;\n\t\t\t\t\t\tCLEAR=0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\tRX_D=data_out[count];\n\t\t\t\tcount=count+1;\n\t\t\t\tREAD=0;\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\tCLEAR=1;\n\t\t\tADDR=0;\n\t\t\tRX_D=1;\n\t\t\tend\n\t\tend\n\nend\n\nendmodule\n\n\t\t\t\n\n\t\t\t",
        "module_name": "SERIAL_OUT",
        "module_hash": "935e530d8b790cd9f00c2fce5831c917",
        "dataset_index": 24048
      },
      "sky130_fd_sc_hdll__bufinv_d3f21ae3": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__bufinv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__bufinv",
        "module_hash": "d3f21ae3b8dff80cb849195e9b44b4c8",
        "dataset_index": 16273
      },
      "mux_4to1_ac23265a": {
        "rtl_code": "module mux_4to1(\n    input [7:0] d0, d1, d2, d3,\n    input s0, s1,\n    output [7:0] out\n);\n\nwire [1:0] sel;\nassign sel = {s1, s0};\n\nassign out = (sel == 2'b00) ? d0 :\n             (sel == 2'b01) ? d1 :\n             (sel == 2'b10) ? d2 :\n             (sel == 2'b11) ? d3 : 8'b0;\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "ac23265a02d6f5eb33caa3c06f1752b8",
        "dataset_index": 857
      },
      "fmlarb_dack_22edecc2": {
        "rtl_code": "\n\n\n\nmodule fmlarb_dack(\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\tinput stb,\n\tinput eack,\n\tinput we,\n\n\toutput stbm,\n\toutput reg ack\n);\n\nwire read = eack & ~we;\nwire write = eack & we;\n\nreg ack_read2;\nreg ack_read1;\nreg ack_read0;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack_read2 <= 1'b0;\n\t\tack_read1 <= 1'b0;\n\t\tack_read0 <= 1'b0;\n\tend else begin\n\t\tack_read2 <= read;\n\t\tack_read1 <= ack_read2;\n\t\tack_read0 <= ack_read1;\n\tend\nend\n\nreg ack0;\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack0 <= 1'b0;\n\t\tack <= 1'b0;\n\tend else begin\nack <= ack_read0|write;\n\n\tend\nend\n\nreg mask;\nassign stbm = stb & ~mask;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tmask <= 1'b0;\n\telse begin\n\t\tif(eack)\n\t\t\tmask <= 1'b1;\n\t\tif(ack)\n\t\t\tmask <= 1'b0;\n\tend\nend\n\nendmodule\n",
        "module_name": "fmlarb_dack",
        "module_hash": "22edecc29972ae04a7139161e7231297",
        "dataset_index": 17045
      },
      "commutation_top_91f7a6cf": {
        "rtl_code": "\nmodule commutation_top(\n    input clk,\n    input enable_i,\n    input reset_i,\n    input advance_i,\n    input direction_i,\n    input break_i,\n    input align_i,\n    output reg [3:0] state_o\n);\n\nparameter STATE_IDLE = 4'b0000;\nparameter STATE_ADVANCE = 4'b0001;\nparameter STATE_BREAK = 4'b0010;\nparameter STATE_ALIGN = 4'b0011;\n\nalways @(posedge clk) begin\n    if (reset_i) begin\n        state_o <= STATE_IDLE;\n    end else begin\n        case (state_o)\n            STATE_IDLE: begin\n                if (enable_i) begin\n                    if (advance_i) begin\n                        state_o <= STATE_ADVANCE;\n                    end else if (break_i) begin\n                        state_o <= STATE_BREAK;\n                    end else if (align_i) begin\n                        state_o <= STATE_ALIGN;\n                    end else begin\n                        state_o <= STATE_IDLE;\n                    end\n                end else begin\n                    state_o <= STATE_IDLE;\n                end\n            end\n            STATE_ADVANCE: begin\n                if (direction_i) begin\n                    state_o <= STATE_IDLE;\n                end else begin\n                    state_o <= STATE_ADVANCE;\n                end\n            end\n            STATE_BREAK: begin\n                state_o <= STATE_IDLE;\n            end\n            STATE_ALIGN: begin\n                state_o <= STATE_IDLE;\n            end\n            default: begin\n                state_o <= STATE_IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule\nmodule timer(\n    input clk,\n    input enable_i,\n    input reset_i,\n    input [15:0] compare_i,\n    input [15:0] autoreload_i,\n    output compare_o,\n    output [15:0] value_o\n);\n\nreg [15:0] counter;\n\nalways @(posedge clk) begin\n    if (reset_i) begin\n        counter <= 16'b0;\n    end else if (enable_i) begin\n        if (counter == compare_i) begin\n            counter <= autoreload_i;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end else begin\n        counter <= counter;\n    end\nend\n\nassign compare_o = (counter == compare_i);\nassign value_o = counter;\n\nendmodule\nmodule debouncer(\n    input clk_i,\n    input reset_i,\n    input pin_i,\n    output pos_o,\n    output neg_o,\n    output debounced_o\n);\n\nparameter DEBOUNCE_COUNT = 2;\n\nreg [DEBOUNCE_COUNT-1:0] counter;\nreg prev_pin_i;\nreg pos_flag;\nreg neg_flag;\n\nalways @(posedge clk_i) begin\n    if (reset_i) begin\n        counter <= {DEBOUNCE_COUNT{1'b0}};\n        prev_pin_i <= 1'b0;\n        pos_flag <= 1'b0;\n        neg_flag <= 1'b0;\n    end else begin\n        counter <= counter + 1'b1;\n        prev_pin_i <= pin_i;\n        if (pin_i && !prev_pin_i) begin\n            pos_flag <= 1'b1;\n        end else begin\n            pos_flag <= 1'b0;\n        end\n        if (!pin_i && prev_pin_i) begin\n            neg_flag <= 1'b1;\n        end else begin\n            neg_flag <= 1'b0;\n        end\n    end\nend\n\nassign pos_o = pos_flag;\nassign neg_o = neg_flag;\nassign debounced_o = counter == DEBOUNCE_COUNT;\n\nendmodule",
        "module_name": "commutation_top",
        "module_hash": "91f7a6cf61662755e12f20c0b6d355ba",
        "dataset_index": 12774
      },
      "up_down_counter_bfc77ab4": {
        "rtl_code": "module up_down_counter (\n  input clk,\n  input reset,\n  input enable,\n  input mode,\n  output reg [2:0] q\n);\n\n  always @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      q <= 3'b0;\n    end else if (enable) begin\n      if (mode) begin\n        // Down mode\n        if (q == 3'b000) begin\n          q <= 3'b111;\n        end else begin\n          q <= q - 1;\n        end\n      end else begin\n        // Up mode\n        if (q == 3'b111) begin\n          q <= 3'b000;\n        end else begin\n          q <= q + 1;\n        end\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "up_down_counter",
        "module_hash": "bfc77ab46a361408d043ca82832cb389",
        "dataset_index": 7848
      },
      "arbiter_24ddbe6f": {
        "rtl_code": "\n`ifndef _arbiter_ `define _arbiter_\n\n\nmodule arbiter\n  #(parameter\n    NUM_PORTS = 6,\n    SEL_WIDTH = ((NUM_PORTS > 1) ? $clog2(NUM_PORTS) : 1))\n   (input                       clk,\n    input                       rst,\n    input      [NUM_PORTS-1:0]  request,\n    output reg [NUM_PORTS-1:0]  grant,\n    output reg [SEL_WIDTH-1:0]  select,\n    output reg                  active\n);\n\n    \n\n    localparam WRAP_LENGTH = 2*NUM_PORTS;\n\n\n    function [SEL_WIDTH-1:0] ff1 (\n        input [NUM_PORTS-1:0] in\n    );\n        reg     set;\n        integer i;\n\n        begin\n            set = 1'b0;\n            ff1 = 'b0;\n\n            for (i = 0; i < NUM_PORTS; i = i + 1) begin\n                if (in[i] & ~set) begin\n                    set = 1'b1;\n                    ff1 = i[0 +: SEL_WIDTH];\n                end\n            end\n        end\n    endfunction\n\n\n`ifdef VERBOSE\n    initial $display(\"Bus arbiter with %d units\", NUM_PORTS);\n`endif\n\n\n    \n\n    integer                 yy;\n\n    wire                    next;\n    wire [NUM_PORTS-1:0]    order;\n\n    reg  [NUM_PORTS-1:0]    token;\n    wire [NUM_PORTS-1:0]    token_lookahead [NUM_PORTS-1:0];\n    wire [WRAP_LENGTH-1:0]  token_wrap;\n\n\n    \n\n    assign token_wrap   = {token, token};\n\n    assign next         = ~|(token & request);\n\n\n    always @(posedge clk)\n        grant <= token & request;\n\n\n    always @(posedge clk)\n        select <= ff1(token & request);\n\n\n    always @(posedge clk)\n        active <= |(token & request);\n\n\n    always @(posedge clk)\n        if (rst) token <= 'b1;\n        else if (next) begin\n\n            for (yy = 0; yy < NUM_PORTS; yy = yy + 1) begin : TOKEN_\n\n                if (order[yy]) begin\n                    token <= token_lookahead[yy];\n                end\n            end\n        end\n\n\n    genvar xx;\n    generate\n        for (xx = 0; xx < NUM_PORTS; xx = xx + 1) begin : ORDER_\n\n            assign token_lookahead[xx]  = token_wrap[xx +: NUM_PORTS];\n\n            assign order[xx]            = |(token_lookahead[xx] & request);\n\n        end\n    endgenerate\n\n\nendmodule\n\n`endif ",
        "module_name": "arbiter",
        "module_hash": "24ddbe6fcb61db2f571e4f8baa22a0c4",
        "dataset_index": 8008
      },
      "shift_reg_ee76b712": {
        "rtl_code": "\nmodule shift_reg(\n    input rx,\n    output reg[(reg_length-1):0] shifted_bus,\n\toutput reg finished_rx,\n    input rst,\n    input baud_clk\n    );\n\t\n\tparameter reg_length = 150;\n\n\tinitial finished_rx = 0;\n\tparameter idle = 2'b00, reading = 2'b01, finished = 2'b10, finished_and_waiting = 2'b11;\n\treg[1:0] current_state, next_state;\n\t\n\treg [(reg_length-1):0] bitShiftReg = {reg_length{1'b1}};\n\n\talways @(posedge baud_clk or posedge rst) begin\n\t\tif(rst) begin\n\t\t\tbitShiftReg <= {reg_length{1'b1}};\n\t\t\tcurrent_state <=  idle;\n\t\tend\n\t\telse begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tbitShiftReg <= {bitShiftReg[(reg_length-2):0],rx};\n\t\tend\n\tend\n\talways @(rx or bitShiftReg or current_state) begin\n\t\tcase(current_state) \n\t\t\tidle: begin\n\t\t\t\tif(rx == 1)\n\t\t\t\t\tnext_state <= idle;\n\t\t\t\telse \n\t\t\t\t\tnext_state <= reading;\n\t\t\t\tend\n\t\t\treading: begin\n\t\t\t\tif(bitShiftReg[6:0] == {7{1'b1}})\n\t\t\t\t\tnext_state <= finished;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= reading;\n\t\t\t\tend\n\t\t\tfinished: begin\n\t\t\t\tnext_state<= finished_and_waiting;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\tnext_state<=idle;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @ (current_state) begin\n\t\tif(current_state == finished)\n\t\t\tfinished_rx <= 1;\n\t\telse\n\t\t\tfinished_rx <= 0;\n\tend\n\t\n\talways @ (posedge finished_rx or posedge rst) begin\n\t\tif(rst) \n\t\t\tshifted_bus <= {reg_length{1'b1}};\n\t\telse\n\t\t\tshifted_bus <= bitShiftReg;\n\tend\n\nendmodule\n",
        "module_name": "shift_reg",
        "module_hash": "ee76b7126a080d5ea56d7686cb3c4cc0",
        "dataset_index": 626
      },
      "reversed_gate_5cc51311": {
        "rtl_code": "module reversed_gate (clk, ctrl, din, sel, dout);\n   input clk;\n   input [4:0] ctrl;\n   input [15:0] din;\n   input [3:0] \tsel;\n   output reg [31:0] dout;\n   always @(posedge clk)\n     case ((({(32)-((ctrl)*(sel))})+(1))-(2))\n       0:\n         dout[1:0] <= din;\n       1:\n         dout[2:1] <= din;\n       2:\n         dout[3:2] <= din;\n       3:\n         dout[4:3] <= din;\n       4:\n         dout[5:4] <= din;\n       5:\n         dout[6:5] <= din;\n       6:\n         dout[7:6] <= din;\n       7:\n         dout[8:7] <= din;\n       8:\n         dout[9:8] <= din;\n       9:\n         dout[10:9] <= din;\n       10:\n         dout[11:10] <= din;\n       11:\n         dout[12:11] <= din;\n       12:\n         dout[13:12] <= din;\n       13:\n         dout[14:13] <= din;\n       14:\n         dout[15:14] <= din;\n       15:\n         dout[16:15] <= din;\n       16:\n         dout[17:16] <= din;\n       17:\n         dout[18:17] <= din;\n       18:\n         dout[19:18] <= din;\n       19:\n         dout[20:19] <= din;\n       20:\n         dout[21:20] <= din;\n       21:\n         dout[22:21] <= din;\n       22:\n         dout[23:22] <= din;\n       23:\n         dout[24:23] <= din;\n       24:\n         dout[25:24] <= din;\n       25:\n         dout[26:25] <= din;\n       26:\n         dout[27:26] <= din;\n       27:\n         dout[28:27] <= din;\n       28:\n         dout[29:28] <= din;\n       29:\n         dout[30:29] <= din;\n       30:\n         dout[31:30] <= din;\n       31:\n         dout[31:31] <= din;\n     endcase\nendmodule\n",
        "module_name": "reversed_gate",
        "module_hash": "5cc5131129570a62f0b62347442f9748",
        "dataset_index": 21773
      },
      "receiver #_29d8d787": {
        "rtl_code": "\nmodule receiver #(\n    parameter DATA_BITS = 32\n)(\n    input clk, rst, stb,\n    input [DATA_BITS-1:0] data,  // Added the data input\n    output [DATA_BITS-1:0] data_out,\n    output ack, valid\n);\n\n    reg [DATA_BITS-1:0] data_reg;\n    reg ack_reg, valid_reg;\n    wire stb_selected;\n\n    // Synchronizer for stb signal\n    wire stb_sync;\n    synchronizer_1bit sync1 (clk, rst, stb, stb_sync);\n    assign stb_selected = stb_sync;\n\n    // Latch data into register on stb signal assertion\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_reg <= 0;\n        end else if (stb_selected) begin\n            data_reg <= data;\n        end\n    end\n\n    // Connect data_out to stored data value\n    assign data_out = data_reg;\n\n    // Acknowledge signal\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            ack_reg <= 1'b0;\n        end else if (stb_selected) begin\n            ack_reg <= 1'b1;\n        end\n    end\n    assign ack = ack_reg;\n\n    // Valid signal\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            valid_reg <= 1'b0;\n        end else if (ack_reg) begin\n            valid_reg <= 1'b1;\n        end\n    end\n    assign valid = valid_reg;\n\nendmodule\nmodule synchronizer_1bit (\n    input clk, rst, in,\n    output out\n);\n\n    reg [1:0] sync_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sync_reg <= 2'b00;\n        end else begin\n            sync_reg <= {sync_reg[0], in};\n        end\n    end\n\n    assign out = sync_reg[1];\n\nendmodule",
        "module_name": "receiver #",
        "module_hash": "29d8d787df3230a1f8adae963a8aa621",
        "dataset_index": 8762
      },
      "precision_dac #_c445a7dd": {
        "rtl_code": "\n\nmodule precision_dac #\n(\n  parameter CLK_DIV = 3\n)\n(\n  input wire                      clk,\n  input wire [16*4-1:0]           data,\n  input wire                      valid,\n  input wire [4-1:0]              cmd,\n\n  output reg                      sync,\n  output reg                      sclk,\n  output reg                      sdi,\n  output reg                      ldac\n);\n  reg [16*8-1:0] data_reg;\n  reg [4-1:0] cmd_reg;\n  reg [CLK_DIV-1:0] cnt_clk  = 0; reg [7-1: 0] cnt_sclk = 0;\n  initial sync = 1'b1;\n\n  always @(posedge clk) begin\n    if (valid == 1'b1) begin\n      cnt_clk <= cnt_clk + 1;\n\n      if (cnt_clk == {{1'b0}, {(CLK_DIV-1){1'b1}}}) begin\n        sclk <= 1'b1;\n        if (cnt_sclk == {(7){1'b0}}) begin\n          ldac <= 1'b1;\n          cmd_reg <= cmd;\n          data_reg <= data;\n        end\n\n        if (cnt_sclk[5-1:0] == {(5){1'b0}}) begin\n          sync <= 1'b0;\n        end\n\n        cnt_sclk <= cnt_sclk + 1;\n\n        if (sync == 1'b0 | cnt_sclk[5-1:0] == {(5){1'b0}}) begin\n          if (cnt_sclk[5-1:2] == 3'b000) begin\n            sdi <= cmd[3-cnt_sclk[2-1:0]]; end else if (cnt_sclk[5-1:2] == 3'b001) begin\n            sdi <= (cnt_sclk[7-1:5] == ~cnt_sclk[2-1:0]);\n          end else if (cnt_sclk[5-1:0] == 5'b11000) begin\n            sync <= 1'b1;\n            if (cnt_sclk[7-1:5] == 3'b11) begin\n              ldac <= 1'b0;\n            end\n          end else begin\n            sdi <= data_reg[16*cnt_sclk[7-1:5] + 23 - cnt_sclk[5-1:0]];\n          end\n        end\n      end\n      if (cnt_clk == {(CLK_DIV){1'b1}}) begin\n        sclk <= 1'b0;\n      end\n    end else begin cnt_clk <= 0;\n      cnt_sclk <= 0;\n      sync <= 1;\n      sdi <= 0;\n      ldac <= 0;\n      sclk <= 0;\n    end\n  end\n\n\nendmodule\n",
        "module_name": "precision_dac #",
        "module_hash": "c445a7dd64553abde38f0e1f461e38a0",
        "dataset_index": 24419
      },
      "top__52ed1c3d": {
        "rtl_code": "module top_module (\n    input [3:0] multiplier,\n    input [3:0] multiplicand,\n    input [15:0] in0,\n    input [15:0] in1,\n    input ctrl,\n    output reg [15:0] out\n);\n\n    wire [7:0] unsigned_mult_out;\n    wire [3:0] add_sub_out;\n    wire [15:0] final_out;\n\n    unsigned_multiplier unsigned_mult(.a(multiplier), .b(multiplicand), .p(unsigned_mult_out));\n    add_sub add_sub(.a(multiplier), .b(multiplicand), .ctrl(ctrl), .s(add_sub_out));\n    functional_module functional(.in0(unsigned_mult_out), .in1(add_sub_out), .out(final_out));\n\n    always @(*) begin\n        if (ctrl == 0) begin\n            out = final_out;\n        end else begin\n            out = final_out + in0 + in1;\n        end\n    end\n\nendmodule\n\nmodule unsigned_multiplier (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [7:0] p\n);\n\n    always @(*) begin\n        p = a * b;\n    end\n\nendmodule\n\nmodule add_sub (\n    input [3:0] a,\n    input [3:0] b,\n    input ctrl,\n    output reg [3:0] s\n);\n\n    always @(*) begin\n        if (ctrl == 0) begin\n            s = a + b;\n        end else begin\n            s = a - b;\n        end\n    end\n\nendmodule\n\nmodule functional_module (\n    input [7:0] in0,\n    input [3:0] in1,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        out = {8'b0, in0} + {12'b0, in1};\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "52ed1c3d9f53ec3bf3fc7249b1e2ba58",
        "dataset_index": 2257
      },
      "bitwise_add_sub_553992c6": {
        "rtl_code": "module bitwise_add_sub (\n    input clk,\n    input reset,\n    input [7:0] in_a,\n    input [7:0] in_b,\n    input select,\n    output reg [7:0] out\n);\n\nreg [7:0] a_shifted;\nreg [7:0] b_shifted;\nreg [7:0] result;\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        a_shifted <= 8'b0;\n        b_shifted <= 8'b0;\n        result <= 8'b0;\n    end else begin\n        a_shifted <= {in_a[7], in_a[6], in_a[5], in_a[4], in_a[3], in_a[2], in_a[1], in_a[0]};\n        b_shifted <= {in_b[7], in_b[6], in_b[5], in_b[4], in_b[3], in_b[2], in_b[1], in_b[0]};\n        if (select == 1) begin\n            result <= a_shifted + b_shifted;\n        end else begin\n            result <= a_shifted - b_shifted;\n        end\n    end\nend\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        out <= 8'b0;\n    end else begin\n        out <= {result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7]};\n    end\nend\n\nendmodule",
        "module_name": "bitwise_add_sub",
        "module_hash": "553992c617263d9165a4e62e29c6e66e",
        "dataset_index": 11859
      },
      "top__6a035f51": {
        "rtl_code": "module top_module (\n    input clk,         // Clock input\n    input reset,       // Synchronous active-high reset\n    input [7:0] in,    // 8-bit input signal for the edge detector\n    input select,      // Select input to choose between counter and edge detector\n    output [3:0] counter_out,  // 4-bit output from the counter\n    output [7:0] edge_out,     // 8-bit output from the edge detector\n    output [7:0] and_out       // Output from the functional module\n);\n\n    // Counter module\n    reg [3:0] counter_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            counter_reg <= 4'b0;\n        end else begin\n            counter_reg <= counter_reg + 1;\n        end\n    end\n    assign counter_out = counter_reg;\n\n    // Edge detector module\n    reg [7:0] edge_reg;\n    reg [7:0] edge_out_reg;\n    always @(posedge clk) begin\n        edge_reg <= {edge_reg[6:0], in};\n        if (edge_reg[7] != edge_reg[6]) begin\n            edge_out_reg <= 8'b11111111;\n        end else begin\n            edge_out_reg <= edge_out_reg;\n        end\n    end\n    assign edge_out = edge_out_reg;\n\n    // Functional module\n    reg [7:0] and_out_reg;\n    always @(posedge clk) begin\n        if (select) begin\n            and_out_reg <= edge_out_reg & counter_reg;\n        end else begin\n            and_out_reg <= 8'b0;\n        end\n    end\n    assign and_out = and_out_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "6a035f51e43cff4d621a1b3a594cc8b7",
        "dataset_index": 4738
      },
      "xor_gate_ad9f6486": {
        "rtl_code": "\nmodule xor_gate(\n    input a,\n    input b,\n    output wire xor_out\n);\n\nassign xor_out = a ^ b;\n\nendmodule\n\nmodule functional_module(\n    input xor_out,\n    output reg func_out\n);\n\nalways @(*) begin\n    if(xor_out == 1'b1) begin\n        func_out = 1'b1;\n    end else begin\n        func_out = 1'b0;\n    end\nend\n\nendmodule\n\nmodule control_logic(\n    input a,\n    input b,\n    input select,\n    output reg out\n);\n\nwire xor_out;\nwire func_out;\n\nxor_gate xor_inst(\n    .a(a),\n    .b(b),\n    .xor_out(xor_out)\n);\n\nfunctional_module func_inst(\n    .xor_out(xor_out),\n    .func_out(func_out)\n);\n\nalways @(*) begin\n    if(select == 1'b1) begin\n        out = func_out;\n    end else begin\n        out = xor_out;\n    end\nend\n\nendmodule\n\nmodule top_module(\n    input a, \n    input b,\n    input select,\n    output wire out\n);\n\ncontrol_logic control_inst(\n    .a(a),\n    .b(b),\n    .select(select),\n    .out(out)\n);\n\nendmodule\n",
        "module_name": "xor_gate",
        "module_hash": "ad9f64863ddbd7da3a7cdb928e4b6c21",
        "dataset_index": 13975
      },
      "CSADD_bd21f8a3": {
        "rtl_code": "module CSADD(clk, rst, x, y, ld, sum);\n    input clk, rst;\n    input x, y;\n    input ld;\n    output reg sum;\n\n    reg sc;\n\n    // Half Adders logic\n    wire hsum1, hco1;\n    assign hsum1 = y ^ sc;\n    assign hco1 = y & sc;\n\n    wire hsum2, hco2;\n    assign hsum2 = x ^ hsum1;\n    assign hco2 = x & hsum1;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            //Reset logic goes here.\n            sum <= 1'b0;\n            sc <= 1'b0;\n        end\n        else if (ld) begin\n             sum <= 1'b0;\n             sc  <= 1'b0;\n        end\n        else begin\n            //Sequential logic goes here.\n            sum <= hsum2;\n            sc <= hco1 ^ hco2;\n        end\n    end\nendmodule",
        "module_name": "CSADD",
        "module_hash": "bd21f8a3a9b3064831e8e3ae1c816aab",
        "dataset_index": 37
      },
      "dff_asr_en_df6360f7": {
        "rtl_code": "module dff_asr_en (CLK, D, SET, RESET, EN, Q, QN);\n   input CLK, D, SET, RESET, EN;\n   output Q, QN;\n   reg Q;\n\n   always @(posedge CLK) begin\n      if (EN) begin\n         if (SET) Q <= 1'b1;\n         else if (RESET) Q <= 1'b0;\n         else Q <= D;\n      end\n   end\n\n   assign QN = ~Q;\n\nendmodule",
        "module_name": "dff_asr_en",
        "module_hash": "df6360f7e6312142784526604097b678",
        "dataset_index": 20636
      },
      "top__7c0a3e7b": {
        "rtl_code": "\nmodule top_module (\n  input clk,\n  input reset,      // Synchronous active-high reset\n  input [2:0] load_data, // 3-bit input for the shift register\n  input load, // Parallel load input for the shift register\n  output serial_out // Serial output from the shift register\n);\n\n  reg [2:0] shift_reg;\n  reg [63:0] jc_output;\n  wire [2:0] sr_output;\n  wire result;\n\n  // Instantiate the Johnson counter module\n  chatgpt_generate_JC_counter jc_counter (\n    .clk(clk),\n    .rst_n(reset),\n    .Q(jc_output)\n  );\n\n  // Instantiate the shift register module\n  shift_register shift_reg_inst (\n    .clk(clk),\n    .load(load),\n    .load_data(load_data),\n    .shift_in(jc_output[0]),\n    .shift_out(sr_output)\n  );\n\n  // Instantiate the functional module\n  functional_module func_inst (\n    .jc_output(jc_output),\n    .sr_output(sr_output),\n    .result(result)\n  );\n\n  // Assign the serial output to the result of the shift register\n  assign serial_out = sr_output[2];\n\nendmodule\nmodule chatgpt_generate_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [63:0]   Q\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      Q <= 64'b1;\n    end else begin\n      Q <= {Q[62:0], ~Q[63]};\n    end\n  end\n\nendmodule\nmodule shift_register(\n  input clk,\n  input load,\n  input [2:0] load_data,\n  input shift_in,\n  output reg [2:0] shift_out\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      shift_out <= load_data;\n    end else begin\n      shift_out <= {shift_out[1:0], shift_in};\n    end\n  end\n\nendmodule\nmodule functional_module(\n  input [63:0] jc_output, // Output from Johnson counter\n  input [2:0] sr_output, // Output from shift register\n  output reg result // XOR of the two inputs\n);\n\n  always @* begin\n    result = jc_output[0] ^ sr_output[0];\n  end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "7c0a3e7b1516dd97b8d901ee1039b579",
        "dataset_index": 12369
      },
      "pipelined_add_sub_5ded90bf": {
        "rtl_code": "\nmodule pipelined_add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\nwire [31:0] csa_out;\nwire [31:0] cla_out;\n\n// Carry save adder\ncsa csa_inst(\n    .a(a),\n    .b(b),\n    .c(sub),\n    .s(csa_out)\n);\n\n// Carry lookahead adder\ncla cla_inst(\n    .a(csa_out),\n    .b({32{sub}}),\n    .c(32'b0),\n    .s(cla_out)\n);\n\n// Output sum\nassign sum = cla_out;\n\nendmodule\nmodule csa(\n    input [31:0] a,\n    input [31:0] b,\n    input c,\n    output [31:0] s\n);\n\nwire [31:0] p;\nwire [31:0] g;\n\n// Generate and propagate signals\ngen_propagate gen_propagate_inst(\n    .a(a),\n    .b(b),\n    .p(p),\n    .g(g)\n);\n\n// Sum calculation\nassign s = p ^ c ^ g;\n\nendmodule\nmodule gen_propagate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] p,\n    output [31:0] g\n);\n\nassign p = a ^ b;\nassign g = a & b;\n\nendmodule\nmodule cla(\n    input [31:0] a,\n    input [31:0] b,\n    input [31:0] c,\n    output [31:0] s\n);\n\nwire [31:0] p;\nwire [31:0] g;\n\n// Generate and propagate signals\ngen_propagate gen_propagate_inst(\n    .a(a),\n    .b(b),\n    .p(p),\n    .g(g)\n);\n\n// Carry lookahead signals\nwire [31:0] c0;\nwire [31:0] c1;\nwire [31:0] c2;\nwire [31:0] c3;\n\nassign c0 = c[0];\nassign c1 = g[0] | (p[0] & c0);\nassign c2 = g[1] | (p[1] & c1);\nassign c3 = g[2] | (p[2] & c2);\n\n// Sum calculation\nassign s = p ^ c ^ (c3 << 3);\n\nendmodule",
        "module_name": "pipelined_add_sub",
        "module_hash": "5ded90bf6d42acaf93823961dd6ee24b",
        "dataset_index": 10845
      },
      "niosii_nios2_gen2_0_cpu_nios2_oci_dtrace_5ea2e7a9": {
        "rtl_code": "\nmodule niosii_nios2_gen2_0_cpu_nios2_oci_dtrace (\n  // inputs:\n  clk,\n  cpu_d_address,\n  cpu_d_read,\n  cpu_d_readdata,\n  cpu_d_wait,\n  cpu_d_write,\n  cpu_d_writedata,\n  jrst_n,\n  trc_ctrl,\n  // outputs:\n  atm,\n  dtm\n);\n\n  output [31:0] atm;\n  output [31:0] dtm;\n  input clk;\n  input [22:0] cpu_d_address;\n  input cpu_d_read;\n  input [31:0] cpu_d_readdata;\n  input cpu_d_wait;\n  input cpu_d_write;\n  input [31:0] cpu_d_writedata;\n  input jrst_n;\n  input [15:0] trc_ctrl;\n\n  reg [31:0] atm;\n  reg [31:0] dtm;\n\n  wire [31:0] cpu_d_address_0_padded;\n  wire [31:0] cpu_d_readdata_0_padded;\n  wire [31:0] cpu_d_writedata_0_padded;\n  wire dummy_tie_off;\n  wire record_load_addr;\n  wire record_load_data;\n  wire record_store_addr;\n  wire record_store_data;\n  wire [3:0] td_mode_trc_ctrl;\n\n  assign cpu_d_writedata_0_padded = {7'b0, cpu_d_writedata};\n  assign cpu_d_readdata_0_padded = {7'b0, cpu_d_readdata};\n  assign cpu_d_address_0_padded = {7'b0, cpu_d_address[22:0]};\n\n  niosii_nios2_gen2_0_cpu_nios2_oci_td_mode niosii_nios2_gen2_0_cpu_nios2_oci_trc_ctrl_td_mode_inst  (\n    .ctrl(trc_ctrl),\n    .td_mode(td_mode_trc_ctrl)\n  );\n\n  assign {record_load_addr, record_store_addr, record_load_data, record_store_data} = td_mode_trc_ctrl;\n\n  always @(posedge clk or negedge jrst_n) begin\n    if (jrst_n == 0) begin\n      atm <= 0;\n      dtm <= 0;\n    end\n    else begin\n      if (cpu_d_wait == 0) begin\n        if (cpu_d_read == 1) begin\n          if (record_load_addr) begin\n            atm <= cpu_d_address_0_padded[31:0];\n          end\n          if (record_load_data) begin\n            dtm <= cpu_d_readdata_0_padded[31:0];\n          end\n        end\n        else if (cpu_d_write == 1) begin\n          if (record_store_addr) begin\n            atm <= cpu_d_address_0_padded[31:0];\n          end\n          if (record_store_data) begin\n            dtm <= cpu_d_writedata_0_padded[31:0];\n          end\n        end\n      end\n    end\n  end\n\n  assign dummy_tie_off = cpu_d_wait | cpu_d_read | cpu_d_write;\n\nendmodule\nmodule niosii_nios2_gen2_0_cpu_nios2_oci_td_mode (\n  ctrl,\n  td_mode\n);\n\n  input  [15:0] ctrl;\n  output [3:0] td_mode;\n\n  assign td_mode = ctrl[3:0];\n\nendmodule",
        "module_name": "niosii_nios2_gen2_0_cpu_nios2_oci_dtrace",
        "module_hash": "5ea2e7a90baa6b9ca229b3222b08f656",
        "dataset_index": 11460
      },
      "binary_to_bcd_converter_cbeba535": {
        "rtl_code": "module binary_to_bcd_converter (\n  input clk,\n  input reset,\n  input [3:0] binary_input,\n  output reg [3:0] msd_output,\n  output reg [3:0] lsd1_output,\n  output reg [3:0] lsd2_output\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      msd_output <= 4'b0000;\n      lsd1_output <= 4'b0000;\n      lsd2_output <= 4'b0000;\n    end else begin\n      case (binary_input)\n        4'b0000: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0001: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0001;\n        end\n        4'b0010: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0011: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0001;\n        end\n        4'b0100: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0101: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0001;\n        end\n        4'b0110: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0111: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1000: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1001: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1010: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1011: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1100: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1101: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1110: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1111: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0001;\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "binary_to_bcd_converter",
        "module_hash": "cbeba535fb795ce2edd9b7b70a529e5a",
        "dataset_index": 4294
      },
      "sky130_fd_sc_ls__o221ai_21446f6f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o221ai",
        "module_hash": "21446f6fa48b3a38ccbdf6ffec9d2552",
        "dataset_index": 13618
      },
      "binary_counter_f6d0d653": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output reg [3:0] q);\n    \n    // Define states\n    parameter [1:0]\n        S0 = 2'b00,\n        S1 = 2'b01,\n        S2 = 2'b10,\n        S3 = 2'b11;\n    \n    // Define state register and next state logic\n    reg [1:0] state, next_state;\n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // Define output logic\n    always @ (*) begin\n        case (state)\n            S0: q = 4'b0000;\n            S1: q = 4'b0001;\n            S2: q = 4'b0010;\n            S3: q = 4'b0011;\n        endcase\n    end\n    \n    // Define next state logic\n    always @ (*) begin\n        case (state)\n            S0: next_state = S1;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = S0;\n        endcase\n    end\n    \nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output [3:0] q);\n    \n    binary_counter counter (\n        .clk(clk),\n        .reset(reset),\n        .q(q)\n    );\n    \nendmodule",
        "module_name": "binary_counter",
        "module_hash": "f6d0d653d9d928c0e291becc63dd0a47",
        "dataset_index": 18737
      },
      "sky130_fd_sc_lp__o41ai_0b084048": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o41ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A4, A3, A2, A1 );\n    nand nand0 (nand0_out_Y, B1, or0_out    );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o41ai",
        "module_hash": "0b0840484ff6692d714d5886fda88062",
        "dataset_index": 22309
      },
      "comparator_8bit_4a87b6e9": {
        "rtl_code": "module comparator_8bit (\n  input [7:0] in1,\n  input [7:0] in2,\n  output reg match\n);\n\n  reg [7:0] temp;\n  integer i;\n\n  always @* begin\n    match = 1;\n    for (i = 0; i < 8; i = i + 1) begin\n      temp[i] = (in1[i] == in2[i]);\n      match = match & temp[i];\n    end\n  end\n\nendmodule\n",
        "module_name": "comparator_8bit",
        "module_hash": "4a87b6e9336ac4147eb071355671b5e2",
        "dataset_index": 19943
      },
      "freq_synth_f1e8e7f9": {
        "rtl_code": "\nmodule freq_synth (\n  input clk,\n  input [31:0] ref_clk,\n  input [31:0] out_freq,\n  output reg [7:0] synth_freq\n);\n\nparameter resolution = 8; // number of bits used to represent the synthesized frequency\nparameter frequency_range = 100000000; // range of output frequencies that can be generated by the synthesizer (in Hz)\n\nreg [31:0] integer_value; // programmable integer value used to divide the reference clock frequency\nreg [31:0] synthesized_freq; // synthesized frequency generated by the frequency synthesizer\n\nalways @ (posedge clk) begin\n  integer_value <= (ref_clk / out_freq) - 1; // calculate the integer value by dividing the reference clock frequency by the desired output frequency\n  synthesized_freq <= ref_clk / (integer_value + 1); // generate the synthesized frequency by dividing the reference clock frequency by the integer value\n  synth_freq <= synthesized_freq / (frequency_range / (2 ** resolution)); // output the synthesized frequency in binary format with the specified resolution\nend\n\nendmodule",
        "module_name": "freq_synth",
        "module_hash": "f1e8e7f9363c98912a738f744eac9614",
        "dataset_index": 10895
      },
      "priority_bcd_mux_3e0160b9": {
        "rtl_code": "module priority_bcd_mux (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input [1:0] S,\n    input [3:0] binary_in,\n    input clk,\n    output reg [6:0] seven_segment_out,\n    output reg EN1,\n    output reg EN2,\n    output reg EN3\n);\n\nreg [3:0] priority_input;\nreg [3:0] bcd_out;\nreg [1:0] digit_counter;\nreg [3:0] bcd_counter;\n\nalways @(posedge clk) begin\n    // Priority encoder\n    case ({A, B, C, D})\n        4'b1110: priority_input <= A;\n        4'b1101: priority_input <= B;\n        4'b1011: priority_input <= C;\n        4'b0111: priority_input <= D;\n        default: priority_input <= 4'b0000;\n    endcase\n    \n    // Binary to BCD converter\n    if (digit_counter == 0) begin\n        bcd_out <= binary_in % 10;\n    end else if (digit_counter == 1) begin\n        bcd_out <= (binary_in / 10) % 10;\n    end else if (digit_counter == 2) begin\n        bcd_out <= (binary_in / 100) % 10;\n    end else begin\n        bcd_out <= (binary_in / 1000) % 10;\n    end\n    \n    // Output selection\n    case (S)\n        2'b00: seven_segment_out <= bcd_out;\n        2'b01: seven_segment_out <= priority_input;\n        2'b10: seven_segment_out <= 7'b1111111;\n        2'b11: seven_segment_out <= 7'b0000000;\n    endcase\n    \n    // Digit enable signals\n    if (digit_counter == 0) begin\n        EN1 <= 1;\n        EN2 <= 0;\n        EN3 <= 0;\n    end else if (digit_counter == 1) begin\n        EN1 <= 0;\n        EN2 <= 1;\n        EN3 <= 0;\n    end else if (digit_counter == 2) begin\n        EN1 <= 0;\n        EN2 <= 0;\n        EN3 <= 1;\n    end else begin\n        EN1 <= 0;\n        EN2 <= 0;\n        EN3 <= 0;\n    end\n    \n    // Digit counter\n    if (digit_counter == 3) begin\n        digit_counter <= 0;\n    end else begin\n        digit_counter <= digit_counter + 1;\n    end\nend\n\nendmodule",
        "module_name": "priority_bcd_mux",
        "module_hash": "3e0160b939ba248dd42f420a2662b46f",
        "dataset_index": 13368
      },
      "clk_gated_module_c3e83d3e": {
        "rtl_code": "\nmodule clk_gated_module(\n    src_clk            ,clk_en             ,gated_clk           );\n\n    input               src_clk     ;input               clk_en      ;output              gated_clk   ;reg                 clk_en_reg      ;always @(posedge src_clk) begin : CLK_EN_REG\n        clk_en_reg  <= clk_en;\n    end\n    assign  gated_clk   = clk_en_reg & src_clk ;\n    \n    endmodule    \n",
        "module_name": "clk_gated_module",
        "module_hash": "c3e83d3e0a786848f4949b9371968071",
        "dataset_index": 22669
      },
      "register_02188486": {
        "rtl_code": "module register (\n  input clk,\n  input reset,\n  input load,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\n  reg [3:0] reg_data;\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      reg_data <= 4'b0000;\n    end\n    else if (load == 1) begin\n      reg_data <= data_in;\n    end\n  end\n\n  assign data_out = reg_data;\n\nendmodule",
        "module_name": "register",
        "module_hash": "02188486e27763f2f61e3dfb271be700",
        "dataset_index": 10390
      },
      "comparator_block #_68c8999d": {
        "rtl_code": "module comparator_block #(\n  parameter n = 4\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output reg [1:0] eq_gt\n);\n\n\nalways @(*) begin\n  if (A === B) begin // A is equal to B\n    eq_gt = 2'b11;\n  end else if (A > B) begin // A is greater than B\n    eq_gt = 2'b10;\n  end else if (A < B) begin // A is less than B\n    eq_gt = 2'b01;\n  end else if (A === {n{1'bx}} && B !== {n{1'bx}}) begin // A is X and B is not X\n    eq_gt = 2'b01;\n  end else if (A !== {n{1'bx}} && B === {n{1'bx}}) begin // A is not X and B is X\n    eq_gt = 2'b10;\n  end else begin // A and B are both X (unknown)\n    eq_gt = 2'b10;\n  end\nend\n\nendmodule",
        "module_name": "comparator_block #",
        "module_hash": "68c8999d9804ddbd1e213e4e2a6cfa36",
        "dataset_index": 5896
      },
      "priority_encoder_a2da623d": {
        "rtl_code": "\nmodule priority_encoder (\n  input clk,\n  input reset,\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  output reg [1:0] out,\n  output reg valid\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      out <= 2'b00;\n      valid <= 1'b0;\n    end else begin\n      casez({in3, in2, in1, in0})\n        4'b0001: out <= 2'b00;\n        4'b0010: out <= 2'b01;\n        4'b0100: out <= 2'b10;\n        4'b1000: out <= 2'b11;\n        default: out <= out;\n      endcase\n      if (in0 || in1 || in2 || in3) begin\n        valid <= 1'b1;\n      end else begin\n        valid <= 1'b0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "a2da623d5490af669bfd1832c6ff19a7",
        "dataset_index": 2863
      },
      "manchester_coder_56d499dc": {
        "rtl_code": "module manchester_coder (\n  input clk_in,\n  input data_in,\n  output data_out,\n  output reg data_decoded\n);\n\n// No parameters needed for this module\n\n// input signals\nassign data_out = (clk_in ^ data_in) ? 1'b0 : 1'b1;\n\n// output signals\nalways @(posedge clk_in)\nbegin\n  if (data_out == 1'b0)\n    data_decoded <= 1'b0;\n  else if (data_out == 1'b1)\n    data_decoded <= 1'b1;\nend\n\nendmodule",
        "module_name": "manchester_coder",
        "module_hash": "56d499dc1c1ec4639aec8be6f8753778",
        "dataset_index": 10160
      },
      "i2s_d2111017": {
        "rtl_code": "module i2s\n(\n    clk_i,\n    rst_i,\n    pcm_data_i,\n    pcm_fifo_empty_i,\n    pcm_fifo_rd_o,\n    pcm_fifo_ur_o,\n    bclk_o,\n    ws_o,\n    data_o\n);\n\nparameter       CLK_DIVISOR = 6;\n\ninput           clk_i ;\ninput           rst_i ;\ninput[31:0]     pcm_data_i ;\ninput           pcm_fifo_empty_i ;\noutput          pcm_fifo_rd_o ;\noutput          pcm_fifo_ur_o ;\noutput          bclk_o ;\noutput          ws_o ;\noutput          data_o ;\n\nreg             audio_clock;\ninteger         audio_clock_div;\ninteger         bit_count;\nreg             word_sel;\n\nreg [15:0]      input_reg0;\nreg [15:0]      input_reg1;\n\nreg [31:0]      pcm_data_last;\nreg             prev_audio_clock;\n\nreg             pcm_fifo_rd_o;\nreg             pcm_fifo_ur_o;\nreg             bclk_o;\nreg             data_o;\n\nalways @(posedge clk_i or posedge rst_i) \nbegin\n    if (rst_i == 1'b1) \n    begin\n        audio_clock_div <= 0;\n        audio_clock     <= 1'b0;\n    end \n    else \n    begin\n        if (audio_clock_div == (CLK_DIVISOR - 1))\n        begin\n            audio_clock     <= ~audio_clock;\n            audio_clock_div <= 0;\n        end\n        else \n            audio_clock_div <= audio_clock_div + 1;\n    end\nend\n\nalways @(posedge clk_i or posedge rst_i) \nbegin\n    if (rst_i == 1'b1) \n    begin\n        input_reg0      <= 16'h0000;\n        input_reg1      <= 16'h0000;\n        bit_count       <= 0;\n        data_o          <= 1'b0;\n        word_sel        <= 1'b0;\n        prev_audio_clock<= 1'b0;\n        pcm_fifo_rd_o   <= 1'b0;\n        pcm_fifo_ur_o   <= 1'b0;\n        pcm_data_last   <= 32'h00000000;\n    end \n    else \n    begin\n        pcm_fifo_rd_o   <= 1'b0;\n        pcm_fifo_ur_o   <= 1'b0;\n      \n        prev_audio_clock <= audio_clock;\n        \n        if ((prev_audio_clock == 1'b1) && (audio_clock == 1'b0)) \n        begin\n            bclk_o <= 1'b0;\n            \n            if (bit_count == 0) \n            begin\n                if (word_sel == 1'b0)\n                    data_o <= input_reg0[15];\n                else \n                    data_o <= input_reg1[15];\n                \n                word_sel <=  ~word_sel;\n                \n                bit_count <= bit_count + 1;\n                \n                if (pcm_fifo_empty_i == 1'b0) \n                begin\n                    pcm_data_last   <= pcm_data_i;\n                    input_reg0      <= pcm_data_i[31:16];\n                    input_reg1      <= pcm_data_i[15:0];\n                    pcm_fifo_rd_o   <= 1'b1;\n                end\n                else \n                begin\n                    input_reg0      <= pcm_data_last[31:16];\n                    input_reg1      <= pcm_data_last[15:0];\n                    pcm_fifo_ur_o   <= 1'b1;\n                end\n            end\n            else \n            begin\n                if (word_sel == 1'b0) \n                begin\n                    data_o <= input_reg0[15];\n                    \n                    input_reg0 <= {input_reg0[14:0], 1'b0};\n                end\n                else \n                begin\n                    data_o <= input_reg1[15];\n                    \n                    input_reg1 <= {input_reg1[14:0], 1'b0};\n                end\n                \n                if (bit_count == 15)\n                    bit_count <= 0;\n                else \n                    bit_count <= bit_count + 1;\n            end\n        end\n        else if((prev_audio_clock == 1'b0) && (audio_clock == 1'b1)) \n            bclk_o <= 1'b1;\n    end\nend\n\nassign ws_o = word_sel;\n\nendmodule\n",
        "module_name": "i2s",
        "module_hash": "d21110170507782d551b0801b02825d4",
        "dataset_index": 7994
      },
      "LLbit_reg_2a563aea": {
        "rtl_code": "module LLbit_reg(\n    input wire clk,\n    input wire rst,\n    input wire flush,\n    input wire LLbit_i,\n    input wire we,\n    output reg LLbit_o\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            LLbit_o <= 1'b0;\n        end else if (flush) begin\n            LLbit_o <= 1'b0;\n        end else if (we) begin\n            LLbit_o <= LLbit_i;\n        end\n    end\n\nendmodule",
        "module_name": "LLbit_reg",
        "module_hash": "2a563aea6219166aba9e20bcbea78b49",
        "dataset_index": 15881
      },
      "nand4_2bf9e7ec": {
        "rtl_code": "module nand4 (\n    input a,\n    input b,\n    input c,\n    input d,\n    output y\n);\n\n    wire temp;\n\n    assign temp = a & b & c & d;\n    assign y = ~temp;\n\nendmodule",
        "module_name": "nand4",
        "module_hash": "2bf9e7eca1ad52cc700be91744129ab7",
        "dataset_index": 12500
      },
      "ddr_interface_09be53e1": {
        "rtl_code": "\nmodule ddr_interface(\n   inout [14:0]         DDR_addr,\n   inout [2:0]          DDR_ba,\n   inout                DDR_cas_n,\n   inout                DDR_ck_n,\n   inout                DDR_ck_p,\n   inout                DDR_cke,\n   inout                DDR_cs_n,\n   inout [3:0]          DDR_dm,\n   inout [31:0]         DDR_dq,\n   inout [3:0]          DDR_dqs_n,\n   inout [3:0]          DDR_dqs_p,\n   inout                DDR_odt,\n   inout                DDR_ras_n,\n   inout                DDR_reset_n,\n   inout                DDR_we_n,\n   inout                FIXED_IO_ddr_vrn,\n   inout                FIXED_IO_ddr_vrp,\n   inout [53:0]         FIXED_IO_mio,\n   inout                FIXED_IO_ps_clk,\n   inout                FIXED_IO_ps_porb,\n   inout                FIXED_IO_ps_srstb,\n\n   input                PL_SGMII_REFCLK_125M_P,\n   input                PL_SGMII_REFCLK_125M_N,\n\n   output reg [1:0]     pl_led      ,\n   output reg [1:0]     pl_pmod\n);\n\n   reg [23:0] cnt_0;\n   reg [24:0] cnt_1;\n   reg [24:0] cnt_2;\n   reg [23:0] cnt_3;\n\n   always @(posedge FIXED_IO_ps_clk) begin\n     if (cnt_0 == 24'd8388607) cnt_0 <= 0;\n     else cnt_0 <= cnt_0 + 1'b1;\n   end\n   always @(posedge FIXED_IO_ps_clk) begin\n     if (cnt_1 == 25'd16777215) cnt_1 <= 0;\n     else cnt_1 <= cnt_1 + 1'b1;\n   end\n   always @(posedge FIXED_IO_ps_clk) begin\n     if (cnt_2 == 25'd33554431) cnt_2 <= 0;\n     else cnt_2 <= cnt_2 + 1'b1;\n   end\n   always @(posedge PL_SGMII_REFCLK_125M_P) begin\n     if (cnt_3 == 24'd16777215) cnt_3 <= 0;\n     else cnt_3 <= cnt_3 + 1'b1;\n   end\n\n   always @(cnt_0) begin\n     pl_led[0] = cnt_0[23];\n   end\n   always @(cnt_1) begin\n     pl_led[1] = cnt_1[24];\n   end\n   always @(cnt_2) begin\n     pl_pmod[0] = cnt_2[24];\n   end\n   always @(cnt_3) begin\n     pl_pmod[1] = cnt_3[23];\n   end\n\nendmodule",
        "module_name": "ddr_interface",
        "module_hash": "09be53e1779234cf6f325d1a3eb68efc",
        "dataset_index": 5142
      },
      "ripple_carry_adder_2ad58563": {
        "rtl_code": "module ripple_carry_adder(\n    input [7:0] a,\n    input [7:0] b,\n    input clk,\n    input rst,\n    output reg [8:0] sum\n);\n\nreg [8:0] carry;\n\nalways @ (posedge clk) begin\n    if (rst) begin\n        sum <= 0;\n        carry <= 0;\n    end else begin\n        {carry, sum} <= a + b + carry;\n    end\nend\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "2ad58563598b6a3af93b358ac1749ef5",
        "dataset_index": 15362
      },
      "calculator_93ef39ef": {
        "rtl_code": "module calculator(\n    input clk,\n    input reset,\n    input [1:0] op,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [7:0] result,\n    output reg overflow\n);\n\n    // Use an intermediate variable for multiplication to capture the full result\n    reg [15:0] mult_result;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            result <= 0;\n            overflow <= 0;\n        end else begin\n            case (op)\n                2'b00: begin // Addition\n                    {overflow, result} <= operand1 + operand2;\n                end\n                2'b01: begin // Subtraction\n                    {overflow, result} <= {1'b0, operand1} - {1'b0, operand2};\n                    overflow <= overflow != result[7] && (operand1[7] != operand2[7]);\n                end\n                2'b10: begin // Multiplication\n                    mult_result <= operand1 * operand2;\n                    result <= mult_result[7:0]; // Assign the lower 8 bits to the result\n                    overflow <= |mult_result[15:8]; // Overflow if any of the upper 8 bits are set\n                end\n                2'b11: begin // Division\n                    if (operand2 == 0) begin\n                        result <= 0; // Define behavior for division by zero\n                        overflow <= 1; // Set overflow flag\n                    end else begin\n                        result <= operand1 / operand2;\n                        overflow <= 0; // Overflow is not applicable in normal division\n                    end\n                end\n                default: begin\n                    result <= 0;\n                    overflow <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n",
        "module_name": "calculator",
        "module_hash": "93ef39ef26df05603d212944baf42521",
        "dataset_index": 3061
      },
      "driver_b7312272": {
        "rtl_code": "module driver (clk, state, enable);\n\n\ninput clk;\ninput [6:0] state; output enable; reg enableReg; reg [2:0] settleTimeCntr;\nreg [4:0] enableOnCntr;\n\nreg settleTimeFlag; reg enableOnFlag; reg [6:0] stateLast; parameter SETTLE_TIME=3'b111;\nparameter ENABLE_ON_TIME=5'b11111;\n\ninitial begin\n\tstateLast=7'b0; settleTimeCntr=3'b0; enableOnCntr=5'b0; settleTimeFlag=1'b0; enableOnFlag=1'b0; enableReg=1'b0; end\n\nalways @(posedge clk) begin\n\tif(|(stateLast - state)) begin settleTimeCntr=3'b0;\n\t\t\n\t\tsettleTimeFlag=1'b1;\n\t\t\n\t\tstateLast=state; end\n\t\n\tif(settleTimeFlag) begin\n\t\tif(settleTimeCntr==SETTLE_TIME) begin\n\t\t\tsettleTimeFlag=1'b0; enableOnFlag=1'b1; settleTimeCntr=3'b0; enableOnCntr=5'b0;\n\t\tend else settleTimeCntr=settleTimeCntr+3'b1; end\n\t\n\tif(enableOnFlag) begin\n\t\tif(enableOnCntr==ENABLE_ON_TIME) begin\n\t\t\tenableReg=1'b0; enableOnFlag=1'b0; enableOnCntr=5'b0; end else begin\n\t\t\tenableReg=1'b1; enableOnCntr=enableOnCntr+5'b1; end\n\tend\nend\n\nassign enable=enableReg; endmodule\n",
        "module_name": "driver",
        "module_hash": "b73122722f6340b1b2377e9bb5dc221f",
        "dataset_index": 19247
      },
      "adder_subtractor_7b5eabda": {
        "rtl_code": "\nmodule adder_subtractor (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input Mode,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [3:0] Adder_out;\n  wire [3:0] Sub_out;\n  wire [3:0] Twos_comp;\n  wire Mode_inv;\n\n  assign Mode_inv = ~Mode;\n\n  // Adder\n  assign Adder_out = A + B + Cin;\n\n  // Subtractor\n  assign Twos_comp = ~B + 1;\n  assign Sub_out = A - Twos_comp + Mode;\n\n  // Multiplexer\n  assign Sum = Mode_inv ? Adder_out : Sub_out;\n\n  // Carry out\n  assign Cout = Mode_inv ? Adder_out[3] : Sub_out[3];\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "7b5eabda4994536c453b43a559378ae0",
        "dataset_index": 16378
      },
      "sky130_fd_sc_lp__bufinv_18433002": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__bufinv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__bufinv",
        "module_hash": "18433002b26ac50c1ebe5300328b56f3",
        "dataset_index": 14602
      },
      "alu_0ea0a8cd": {
        "rtl_code": "\n\nmodule alu(a,b,aluc,result\n\t);\n\tinput wire [31:0] a,b;\n\tinput wire [4:0] aluc;\n\toutput reg [31:0] result;\n\t\n\talways @*\n\tbegin\n\t\tcase(aluc)\n\t\t\t5'd0:result=a+b;\n\t\t\t5'd1:result=a+b;\n\t\t\t5'd2:result=a-b;\n\t\t\t5'd3:result=a-b;\n\t\t\t5'd4:result=a&b;\n\t\t\t5'd5:result=a|b;\n\t\t\t5'd6:result=a^b;\n\t\t\t5'd7:result=~(a|b);\n\t\t\t5'd8:result=a<b;\n\t\t\t5'd9:result=a<b;\n\t\t\t5'd10:result=b<<a;\n\t\t\t5'd11:result=b>>a;\n\t\t\t5'd12:begin\n\t\t\t\tcase(a[4:0])\n\t\t\t\t5'd0:result=b;\n\t\t\t\t5'd1:result={b[31],b[31:1]};\n\t\t\t\t5'd2:result={{2{b[31]}},b[31:2]};\n\t\t\t\t5'd3:result={{3{b[31]}},b[31:3]};\n\t\t\t\t5'd4:result={{4{b[31]}},b[31:4]};\n\t\t\t\t5'd5:result={{5{b[31]}},b[31:5]};\n\t\t\t\t5'd6:result={{6{b[31]}},b[31:6]};\n\t\t\t\t5'd7:result={{7{b[31]}},b[31:7]};\n\t\t\t\t5'd8:result={{8{b[31]}},b[31:8]};\n\t\t\t\t5'd9:result={{9{b[31]}},b[31:9]};\n\t\t\t\t5'd10:result={{10{b[31]}},b[31:10]};\n\t\t\t\t5'd11:result={{11{b[31]}},b[31:11]};\n\t\t\t\t5'd12:result={{12{b[31]}},b[31:12]};\n\t\t\t\t5'd13:result={{13{b[31]}},b[31:13]};\n\t\t\t\t5'd14:result={{14{b[31]}},b[31:14]};\n\t\t\t\t5'd15:result={{15{b[31]}},b[31:15]};\n\t\t\t\t5'd16:result={{16{b[31]}},b[31:16]};\n\t\t\t\t5'd17:result={{17{b[31]}},b[31:17]};\n\t\t\t\t5'd18:result={{18{b[31]}},b[31:18]};\n\t\t\t\t5'd19:result={{19{b[31]}},b[31:19]};\n\t\t\t\t5'd20:result={{20{b[31]}},b[31:20]};\n\t\t\t\t5'd21:result={{21{b[31]}},b[31:21]};\n\t\t\t\t5'd22:result={{22{b[31]}},b[31:22]};\n\t\t\t\t5'd23:result={{23{b[31]}},b[31:23]};\n\t\t\t\t5'd24:result={{24{b[31]}},b[31:24]};\n\t\t\t\t5'd25:result={{25{b[31]}},b[31:25]};\n\t\t\t\t5'd26:result={{26{b[31]}},b[31:26]};\n\t\t\t\t5'd27:result={{27{b[31]}},b[31:27]};\n\t\t\t\t5'd28:result={{28{b[31]}},b[31:28]};\n\t\t\t\t5'd29:result={{29{b[31]}},b[31:29]};\n\t\t\t\t5'd30:result={{30{b[31]}},b[31:30]};\n\t\t\t\t5'd31:result={32{b[31]}};\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t5'd14:result={b[15:0],16'b0};\n\t\t\tdefault:\n\t\t\tbegin\n\t\t\t\tresult=0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n",
        "module_name": "alu",
        "module_hash": "0ea0a8cdfc16bf26c62d87849c916d3d",
        "dataset_index": 22285
      },
      "sky130_fd_sc_hd__nand4b_19e2b096": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nand4b (\n    Y  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N              );\n    nand nand0 (nand0_out_Y, D, C, B, not0_out);\n    buf  buf0  (Y          , nand0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nand4b",
        "module_hash": "19e2b096adf4a8feb077db7fa9d77122",
        "dataset_index": 17829
      },
      "falling_edge_detector_ea4c0bdf": {
        "rtl_code": "module falling_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        out <= 0;\n    end else begin\n        out <= (in ^ (in & (in - 1))) & ~out;\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nfalling_edge_detector detector (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule",
        "module_name": "falling_edge_detector",
        "module_hash": "ea4c0bdfd5a63b649b76a3fb35244e2d",
        "dataset_index": 10480
      },
      "rx_control_data_rdy_12369f58": {
        "rtl_code": "module rx_control_data_rdy(\n\t\t\t\tinput posedge_clk,\n\t\t\t\tinput rx_resetn,\n\n\t\t\t\tinput rx_error_c,\n\t\t\t\tinput rx_error_d,\n\n\t\t\t\tinput [2:0] control,\n\t\t\t\tinput [2:0] control_l_r,\n\n\t\t\t\tinput is_control,\n\t\t\t\tinput [5:0] counter_neg,\n\t\t\t\tinput last_is_control,\n\n\t\t\t\toutput reg rx_error,\n\t\t\t\toutput reg ready_control_p_r,\n\t\t\t\toutput reg ready_data_p_r,\n\t\t\t\toutput reg rx_got_fct_fsm\n\t\t\t  );\n\nalways@(posedge posedge_clk or negedge rx_resetn)\nbegin\n\tif(!rx_resetn)\n\tbegin\n\t\trx_got_fct_fsm  <=  1'b0;\n\t\tready_control_p_r <= 1'b0;\n\t\tready_data_p_r  <=  1'b0;\n\t\trx_error <= 1'b0;\n\tend\n\telse\n\tbegin\n\n\t\trx_error <= rx_error_c | rx_error_d;\n\n\t\tif(counter_neg == 6'd4 && is_control)\n\t\tbegin\n\t\t\tready_control_p_r <= 1'b1;\n\t\t\tready_data_p_r <= 1'b0;\n\t\tend\n\t\telse if(counter_neg  == 6'd32)\n\t\tbegin\n\t\t\tready_control_p_r <= 1'b0;\n\t\t\tready_data_p_r <= 1'b1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tready_control_p_r <= 1'b0;\n\t\t\tready_data_p_r <= 1'b0;\n\t\tend\n\n\t\tif((control_l_r[2:0] != 3'd7 && control[2:0] == 3'd4 && last_is_control == 1'b1 ) == 1'b1)\n\t\t\trx_got_fct_fsm <= 1'b1;\n\t\telse\n\t\t\trx_got_fct_fsm <= rx_got_fct_fsm;\n\tend\nend\n\nendmodule\n",
        "module_name": "rx_control_data_rdy",
        "module_hash": "12369f58e202b672284c9a86c1b5eb8f",
        "dataset_index": 14593
      },
      "JNOR3C_a9b6aef1": {
        "rtl_code": "module JNOR3C(A1, A2, A3, A4, O);\ninput   A1;\ninput   A2;\ninput   A3;\ninput   A4;\noutput  O;\n\nwire    M1;\nwire    M2;\nwire    M3;\nwire    N1;\nwire    N2;\n\n// Implement majority gate using standard gates\nassign M1 = A1 & A2;\nassign M2 = A2 & A3;\nassign M3 = A1 & A3;\nassign N1 = ~(M1 | M2);\nassign N2 = ~(M1 | M3);\nassign O = ~(N1 | N2 | (A1 & A2 & A3 & A4));\n\nendmodule",
        "module_name": "JNOR3C",
        "module_hash": "a9b6aef177047d8c0fe96bd0f7dba438",
        "dataset_index": 3863
      },
      "MISTRAL_FF_f9c5cf53": {
        "rtl_code": "\nmodule MISTRAL_FF(\n    input DATAIN,\n     input CLK,\n    input ACLR, ENA, SCLR, SLOAD, SDATA,\n    output reg Q\n);\n\n`ifdef cyclonev\nspecify\n    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 731;\n    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 890;\n    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 618;\n\n    $setup(DATAIN, posedge CLK,  0);\n    $setup(ENA, posedge CLK,  0);\n    $setup(SCLR, posedge CLK,  0);\n    $setup(SLOAD, posedge CLK,  0);\n    $setup(SDATA, posedge CLK,  0);\n\n    if (ACLR === 1'b0) (ACLR => Q) = 282;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 219;\n    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 219;\n    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 219;\n\n    $setup(DATAIN, posedge CLK, 268);\n    $setup(ENA, posedge CLK, 268);\n    $setup(SCLR, posedge CLK, 268);\n    $setup(SLOAD, posedge CLK, 268);\n    $setup(SDATA, posedge CLK, 268);\n\n    if (ACLR === 1'b0) (ACLR => Q) = 0;\nendspecify\n`endif\n\ninitial begin\n    Q = 0;\nend\n\nalways @(posedge CLK, negedge ACLR) begin\n    if (!ACLR) Q <= 0;\n    else if (ENA) begin\n        if (SCLR) Q <= 0;\n        else if (SLOAD) Q <= SDATA;\n        else Q <= DATAIN;\n    end\nend\n\nendmodule\n",
        "module_name": "MISTRAL_FF",
        "module_hash": "f9c5cf53d7a8ab7edfa33697f46ec779",
        "dataset_index": 24035
      },
      "binary_counter_4142baeb": {
        "rtl_code": "module binary_counter (\n  input clk,\n  input reset,\n  input ena,\n  output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    q <= 4'b0000;\n  end else if (ena) begin\n    q <= q + 1;\n    if (q == 4'b1111) begin\n      q <= 4'b0000;\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "binary_counter",
        "module_hash": "4142baeb00a57d062fea4523d74c1ce7",
        "dataset_index": 5401
      },
      "comparator_8e653aef": {
        "rtl_code": "module comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output greater_than,\n    output less_than,\n    output equal_to,\n    output valid\n);\n\n    reg [1:0] result;\n    \n    always @* begin\n        if (A > B) begin\n            result = 2'b01;\n        end\n        else if (A < B) begin\n            result = 2'b10;\n        end\n        else begin\n            result = 2'b00;\n        end\n    end\n    \n    assign greater_than = (result == 2'b01);\n    assign less_than = (result == 2'b10);\n    assign equal_to = (result == 2'b00);\n    assign valid = (result != 2'b11);\n    \nendmodule",
        "module_name": "comparator",
        "module_hash": "8e653aef19f610518427a0b402b3da23",
        "dataset_index": 11465
      },
      "my__51d95b81": {
        "rtl_code": "module my_module (\n    input input1,\n    input input2,\n    input [3:0] input3,\n    input [3:0] input4,\n    input [7:0] input5,\n    input [7:0] input6,\n    input [7:0] input7,\n    input [7:0] input8,\n    input [7:0] input9,\n    input [7:0] input10,\n    output reg [15:0] output1\n);\n\n    reg [3:0] sum1;\n    reg [47:0] concat1;\n\n    always @(*) begin\n        if (input2 == 0) begin\n            output1 = 0;\n        end else begin\n            output1 = input1;\n        end\n\n        sum1 = input3 + input4;\n        concat1 = {input5, input6, input7, input8, input9, input10};\n        output1 = output1 + {sum1, concat1};\n    end\n\nendmodule",
        "module_name": "my_",
        "module_hash": "51d95b815bd613976d29a3cc9b219284",
        "dataset_index": 21304
      },
      "sky130_fd_sc_hs__sdlclkp_b1870005": {
        "rtl_code": "module sky130_fd_sc_hs__sdlclkp (\n    GCLK,\n    GATE,\n    CLK ,\n    SCE\n);\n\n    output GCLK;\n    input  GATE;\n    input  CLK ;\n    input  SCE ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    reg gate_state;\n\n    always @ (posedge SCE)\n    begin\n        gate_state <= GATE;\n    end\n\n    assign GCLK = (gate_state == 1'b1) ? CLK : 1'b0;\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__sdlclkp",
        "module_hash": "b1870005d397928b2973781a2222740e",
        "dataset_index": 12374
      },
      "ripple_carry_adder_2a14b4d0": {
        "rtl_code": "\nmodule ripple_carry_adder(\n    input [1:0] a,\n    input [1:0] b,\n    input cin,\n    output [1:0] sum,\n    output cout\n);\n\nassign {cout, sum} = a + b + cin;\n\nendmodule\nmodule detect_carry_adder(\n    input [1:0] a,\n    input [1:0] b,\n    input cin,\n    output p,\n    output g\n);\n\nassign p = a & b;\nassign g = a | b;\n\nendmodule\nmodule GDA_St_N8_M4_P2(\n    input [7:0] in1,\n    input [7:0] in2,\n    output [7:0] res\n);\n\nwire [1:0] temp1, temp2, temp3, temp4;\nwire g0, g1, g2, g3, g4, g5;\nwire p0, p1, p2, p3, p4, p5;\nwire p1g0, p3g2, p5g4;\nwire c2, c4, c6;\n\nripple_carry_adder rca_0(.a(in1[1:0]), .b(in2[1:0]), .cin(1'b0), .sum(temp1), .cout(c2));\nripple_carry_adder rca_1(.a(in1[3:2]), .b(in2[3:2]), .cin(c2), .sum(temp2), .cout(c4));\nripple_carry_adder rca_2(.a(in1[5:4]), .b(in2[5:4]), .cin(c4), .sum(temp3), .cout(c6));\nripple_carry_adder rca_3(.a(in1[7:6]), .b(in2[7:6]), .cin(c6), .sum(temp4), .cout());\n\ndetect_carry_adder dca_0(.a(in1[1:0]), .b(in2[1:0]), .cin(1'b0), .p(p0), .g(g0));\ndetect_carry_adder dca_1(.a(in1[1:0]), .b(in2[1:0]), .cin(p1g0), .p(p1), .g(g1));\ndetect_carry_adder dca_2(.a(in1[3:2]), .b(in2[3:2]), .cin(p1g0), .p(p2), .g(g2));\ndetect_carry_adder dca_3(.a(in1[3:2]), .b(in2[3:2]), .cin(p3g2), .p(p3), .g(g3));\ndetect_carry_adder dca_4(.a(in1[5:4]), .b(in2[5:4]), .cin(p3g2), .p(p4), .g(g4));\ndetect_carry_adder dca_5(.a(in1[5:4]), .b(in2[5:4]), .cin(p5g4), .p(p5), .g(g5));\n\nassign p1g0 = p1 & g0;\nassign p3g2 = p3 & g2;\nassign p5g4 = p5 & g4;\n\nassign res[1:0] = temp1;\nassign res[3:2] = temp2;\nassign res[5:4] = temp3;\nassign res[7:6] = temp4;\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "2a14b4d0ff935df6afd529ad78bbdb05",
        "dataset_index": 7080
      },
      "cf_add_e99343b9": {
        "rtl_code": "module cf_add (\n  clk,\n  data_1,\n  data_2,\n  data_3,\n  data_4,\n  data_p,\n  ddata_in,\n  ddata_out);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input           clk;\n  input   [24:0]  data_1;\n  input   [24:0]  data_2;\n  input   [24:0]  data_3;\n  input   [24:0]  data_4;\n  output  [ 7:0]  data_p;\n  input   [DW:0]  ddata_in;\n  output  [DW:0]  ddata_out;\n\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [24:0]  p1_data_1 = 'd0;\n  reg     [24:0]  p1_data_2 = 'd0;\n  reg     [24:0]  p1_data_3 = 'd0;\n  reg     [24:0]  p1_data_4 = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [24:0]  p2_data_0 = 'd0;\n  reg     [24:0]  p2_data_1 = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [24:0]  p3_data = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [ 7:0]  data_p = 'd0;\n\n  wire    [24:0]  p1_data_1_p_s;\n  wire    [24:0]  p1_data_1_n_s;\n  wire    [24:0]  p1_data_1_s;\n  wire    [24:0]  p1_data_2_p_s;\n  wire    [24:0]  p1_data_2_n_s;\n  wire    [24:0]  p1_data_2_s;\n  wire    [24:0]  p1_data_3_p_s;\n  wire    [24:0]  p1_data_3_n_s;\n  wire    [24:0]  p1_data_3_s;\n  wire    [24:0]  p1_data_4_p_s;\n  wire    [24:0]  p1_data_4_n_s;\n  wire    [24:0]  p1_data_4_s;\n\n  assign p1_data_1_p_s = {1'b0, data_1[23:0]};\n  assign p1_data_1_n_s = ~p1_data_1_p_s + 1'b1;\n  assign p1_data_1_s = (data_1[24] == 1'b1) ? p1_data_1_n_s : p1_data_1_p_s;\n\n  assign p1_data_2_p_s = {1'b0, data_2[23:0]};\n  assign p1_data_2_n_s = ~p1_data_2_p_s + 1'b1;\n  assign p1_data_2_s = (data_2[24] == 1'b1) ? p1_data_2_n_s : p1_data_2_p_s;\n\n  assign p1_data_3_p_s = {1'b0, data_3[23:0]};\n  assign p1_data_3_n_s = ~p1_data_3_p_s + 1'b1;\n  assign p1_data_3_s = (data_3[24] == 1'b1) ? p1_data_3_n_s : p1_data_3_p_s;\n\n  assign p1_data_4_p_s = {1'b0, data_4[23:0]};\n  assign p1_data_4_n_s = ~p1_data_4_p_s + 1'b1;\n  assign p1_data_4_s = (data_4[24] == 1'b1) ? p1_data_4_n_s : p1_data_4_p_s;\n\n  always @(posedge clk) begin\n    p1_ddata <= ddata_in;\n    p1_data_1 <= p1_data_1_s;\n    p1_data_2 <= p1_data_2_s;\n    p1_data_3 <= p1_data_3_s;\n    p1_data_4 <= p1_data_4_s;\n  end\n\n  always @(posedge clk) begin\n    p2_ddata <= p1_ddata;\n    p2_data_0 <= p1_data_1 + p1_data_2;\n    p2_data_1 <= p1_data_3 + p1_data_4;\n  end\n\n  always @(posedge clk) begin\n    p3_ddata <= p2_ddata;\n    p3_data <= p2_data_0 + p2_data_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    if (p3_data[24] == 1'b1) begin\n      data_p <= 8'h00;\n    end else if (p3_data[23:20] == 'd0) begin\n      data_p <= p3_data[19:12];\n    end else begin\n      data_p <= 8'hff;\n    end\n  end\n\nendmodule",
        "module_name": "cf_add",
        "module_hash": "e99343b92bc0a29730f4c48ac27a544d",
        "dataset_index": 10102
      },
      "fifo_02af291a": {
        "rtl_code": "module fifo\n   #(\n  \tparameter adr_width = 4,\n\tparameter dat_width = 8\n   )\n   (\n    input  clk, reset,\n    input  rd, wr,\n    input  [dat_width-1:0] data_in,\n    output [dat_width-1:0] data_out,\n    output empty, \n    output full\n   );\n\n   \n   parameter depth = (1 << adr_width);\n\n   reg [dat_width-1:0] array_reg [depth-1:0];reg [adr_width-1:0] w_ptr_reg, w_ptr_next;\n   reg [adr_width-1:0] r_ptr_reg, r_ptr_next;\n   reg full_reg, empty_reg, full_next, empty_next;\n   wire wr_en;\n\treg\t[1:0]\torden;\n\n\n   assign data_out = array_reg[r_ptr_reg];\n   assign wr_en = wr & ~full_reg;\n\n   assign full = full_reg;\n   assign empty = empty_reg;\n\n   always @(posedge clk) begin\n      if (wr_en)\n         array_reg[w_ptr_reg] <= data_in;\n   end\n\n   always @(posedge clk, posedge reset) begin\n      if (reset)\n         begin\n            w_ptr_reg <= 0;\n            r_ptr_reg <= 0;\n            full_reg <= 1'b0;\n            empty_reg <= 1'b1;\n         end\n      else\n         begin\n            w_ptr_reg <= w_ptr_next;\n            r_ptr_reg <= r_ptr_next;\n            full_reg <= full_next;\n            empty_reg <= empty_next;\n         end\n   end\n\n\talways @(posedge clk)\n\tbegin\n\t\tif(!wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b01;\n\t\tend\n\t\tif(wr&&!rd)\n\t\tbegin\n\t\t\torden = 2'b10;\n\t\tend\n\t\tif(wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b11;\n\t\tend\n\tend\n\n   \n   always @(posedge clk)\n   begin\n      if (reset) begin\n\tw_ptr_next =  0;\n        r_ptr_next =  0;       \n      end else begin\n\t      full_next = full_reg;\n\t      empty_next = empty_reg;\n\t      case (orden)\n\t\t 2'b01: if (~empty_reg) begin\n\t\t          r_ptr_next = r_ptr_reg + 1;\n\t\t          full_next = 1'b0;\n\t\t          if (r_ptr_next==w_ptr_reg)\n\t\t             empty_next = 1'b1;\n\t\t       end\n\t\t 2'b10: if (~full_reg) begin\n\t\t          w_ptr_next = w_ptr_reg + 1;\n\t\t          empty_next = 1'b0;\n\t\t          if (w_ptr_next==r_ptr_reg)\n\t\t             full_next = 1'b1;\n\t\t       end\n\t\t 2'b11: begin\n\t\t       w_ptr_next =  w_ptr_reg + 1;\n\t\t       r_ptr_next = r_ptr_reg + 1;\n\t\t    end\n\t      endcase\n\tend\n   end\n\n\n  \nendmodule\n\n",
        "module_name": "fifo",
        "module_hash": "02af291ad5f44825dd2b9e85baeee208",
        "dataset_index": 24123
      },
      "pcie_7x_v1_3_qpll_reset #_597a5f47": {
        "rtl_code": "\n\n\n\nmodule pcie_7x_v1_3_qpll_reset #\n(\n\n    parameter PCIE_PLL_SEL       = \"CPLL\",                  parameter PCIE_POWER_SAVING  = \"TRUE\",                  parameter PCIE_LANE          = 1,                       parameter BYPASS_COARSE_OVRD = 1                        )\n\n(\n\n    input                           QRST_CLK,\n    input                           QRST_RST_N,\n    input                           QRST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     QRST_CPLLLOCK,\n    input       [(PCIE_LANE-1)>>2:0]QRST_DRP_DONE,\n    input       [(PCIE_LANE-1)>>2:0]QRST_QPLLLOCK,\n    input       [ 1:0]              QRST_RATE,\n    input       [PCIE_LANE-1:0]     QRST_QPLLRESET_IN,\n    input       [PCIE_LANE-1:0]     QRST_QPLLPD_IN,\n\n    output                          QRST_OVRD,\n    output                          QRST_DRP_START,\n    output                          QRST_QPLLRESET_OUT,\n    output                          QRST_QPLLPD_OUT,\n    output                          QRST_IDLE,\n    output      [11:0]              QRST_FSM\n\n);\n\n    reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     cplllock_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg1;\n    reg         [ 1:0]              rate_reg1;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg1;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg1;\n\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     cplllock_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg2;\n    reg         [ 1:0]              rate_reg2;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg2;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg2;\n\n    reg                             ovrd              =  1'd0;\n    reg                             qpllreset         =  1'd1;\n    reg                             qpllpd            =  1'd0;\n    reg         [11:0]              fsm               = 12'd2;\n\n    localparam                      FSM_IDLE          = 12'b000000000001;\n    localparam                      FSM_WAIT_LOCK     = 12'b000000000010;\n    localparam                      FSM_MMCM_LOCK     = 12'b000000000100;\n    localparam                      FSM_DRP_START_NOM = 12'b000000001000;\n    localparam                      FSM_DRP_DONE_NOM  = 12'b000000010000;\n    localparam                      FSM_QPLLLOCK      = 12'b000000100000;\n    localparam                      FSM_DRP_START_OPT = 12'b000001000000;\n    localparam                      FSM_DRP_DONE_OPT  = 12'b000010000000;\n    localparam                      FSM_QPLL_RESET    = 12'b000100000000;\n    localparam                      FSM_QPLLLOCK2     = 12'b001000000000;\n    localparam                      FSM_QPLL_PDRESET  = 12'b010000000000;\n    localparam                      FSM_QPLL_PD       = 12'b100000000000;\n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        mmcm_lock_reg1    <=  1'd0;\n        cplllock_reg1     <= {PCIE_LANE{1'd1}};\n        drp_done_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        qplllock_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        rate_reg1         <=  2'd0;\n        qpllreset_in_reg1 <= {PCIE_LANE{1'd1}};\n        qpllpd_in_reg1    <= {PCIE_LANE{1'd0}};\n        mmcm_lock_reg2    <=  1'd0;\n        cplllock_reg2     <= {PCIE_LANE{1'd1}};\n        drp_done_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        qplllock_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        rate_reg2         <=  2'd0;\n        qpllreset_in_reg2 <= {PCIE_LANE{1'd1}};\n        qpllpd_in_reg2    <= {PCIE_LANE{1'd0}};\n        end\n    else\n        begin\n        mmcm_lock_reg1    <= QRST_MMCM_LOCK;\n        cplllock_reg1     <= QRST_CPLLLOCK;\n        drp_done_reg1     <= QRST_DRP_DONE;\n        qplllock_reg1     <= QRST_QPLLLOCK;\n        rate_reg1         <= QRST_RATE;\n        qpllreset_in_reg1 <= QRST_QPLLRESET_IN;\n        qpllpd_in_reg1    <= QRST_QPLLPD_IN;\n        mmcm_lock_reg2    <= mmcm_lock_reg1;\n        cplllock_reg2     <= cplllock_reg1;\n        drp_done_reg2     <= drp_done_reg1;\n        qplllock_reg2     <= qplllock_reg1;\n        rate_reg2         <= rate_reg1;\n        qpllreset_in_reg2 <= qpllreset_in_reg1;\n        qpllpd_in_reg2    <= qpllpd_in_reg1;\n        end\n\nend\n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        fsm       <= FSM_WAIT_LOCK;\n        ovrd      <= 1'd0;\n        qpllreset <= 1'd1;\n        qpllpd    <= 1'd0;\n        end\n    else\n        begin\n\n        case (fsm)\n\n        FSM_IDLE :\n\n            begin\n            if (!QRST_RST_N)\n                begin\n                fsm       <= FSM_WAIT_LOCK;\n                ovrd      <= 1'd0;\n                qpllreset <= 1'd1;\n                qpllpd    <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                ovrd      <= ovrd;\n                qpllreset <= &qpllreset_in_reg2;\n                qpllpd    <= &qpllpd_in_reg2;\n                end\n            end\n\n        FSM_WAIT_LOCK :\n\n            begin\n            fsm       <= ((&(~cplllock_reg2)) && (&(~qplllock_reg2)) ? FSM_MMCM_LOCK : FSM_WAIT_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_MMCM_LOCK :\n\n            begin\n            fsm       <= ((mmcm_lock_reg2 && (&cplllock_reg2)) ? FSM_DRP_START_NOM : FSM_MMCM_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_START_NOM:\n\n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_NOM : FSM_DRP_START_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_NOM :\n\n            begin\n            fsm       <= (&drp_done_reg2 ? FSM_QPLLLOCK : FSM_DRP_DONE_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_QPLLLOCK :\n\n            begin\n            fsm       <= (&qplllock_reg2 ? ((BYPASS_COARSE_OVRD == 1) ? FSM_QPLL_PDRESET : FSM_DRP_START_OPT) : FSM_QPLLLOCK);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_START_OPT:\n\n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_OPT : FSM_DRP_START_OPT);\n            ovrd      <= 1'd1;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_OPT :\n\n            begin\n            if (&drp_done_reg2)\n                begin\n                fsm       <= ((PCIE_PLL_SEL == \"QPLL\") ? FSM_QPLL_RESET : FSM_QPLL_PDRESET);\n                ovrd      <= ovrd;\n                qpllreset <= (PCIE_PLL_SEL == \"QPLL\");\n                qpllpd    <= qpllpd;\n                end\n            else\n                begin\n                fsm       <= FSM_DRP_DONE_OPT;\n                ovrd      <= ovrd;\n                qpllreset <= qpllreset;\n                qpllpd    <= qpllpd;\n                end\n            end\n\n        FSM_QPLL_RESET :\n\n            begin\n            fsm       <= (&(~qplllock_reg2) ? FSM_QPLLLOCK2 : FSM_QPLL_RESET);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd1;\n            qpllpd    <= 1'd0;\n            end\n\n        FSM_QPLLLOCK2 :\n\n            begin\n            fsm       <= (&qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK2);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        FSM_QPLL_PDRESET :\n\n            begin\n            fsm       <= FSM_QPLL_PD;\n            ovrd      <= ovrd;\n            qpllreset <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_QPLL_PD :\n\n            begin\n            fsm       <= FSM_IDLE;\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0;\n            end\n\n        default :\n\n            begin\n            fsm       <= FSM_WAIT_LOCK;\n            ovrd      <= 1'd0;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        endcase\n\n        end\n\nend\n\n\n\nassign QRST_OVRD          = ovrd;\nassign QRST_DRP_START     = (fsm == FSM_DRP_START_NOM) || (fsm == FSM_DRP_START_OPT);\nassign QRST_QPLLRESET_OUT = qpllreset;\nassign QRST_QPLLPD_OUT    = ((PCIE_POWER_SAVING == \"FALSE\") ? 1'd0 : qpllpd);\nassign QRST_IDLE          = (fsm == FSM_IDLE);\nassign QRST_FSM           = fsm;\n\n\n\nendmodule\n",
        "module_name": "pcie_7x_v1_3_qpll_reset #",
        "module_hash": "597a5f47723dbddd5c25ce442c48969f",
        "dataset_index": 24432
      },
      "binary_counter_15f2b0ba": {
        "rtl_code": "module binary_counter (\n    input clk,\n    output reg [3:0] Q\n);\n\nreg [3:0] Q_reg1, Q_reg2, Q_reg3;\n\nalways @(posedge clk) begin\n    Q_reg1 <= Q;\nend\n\nalways @(posedge clk) begin\n    Q_reg2 <= Q_reg1;\nend\n\nalways @(posedge clk) begin\n    Q_reg3 <= Q_reg2;\nend\n\nalways @(posedge clk) begin\n    if (Q_reg3 == 4'b1111) begin\n        Q <= 4'b0000;\n    end else begin\n        Q <= Q_reg3 + 1;\n    end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "15f2b0ba66946a22ac0a1b3b14564f1a",
        "dataset_index": 4542
      },
      "LUT1_9a742ba5": {
        "rtl_code": "\nmodule LUT1 (\n    input I0,\n    output O\n);\n\nassign O = (I0 == 1'b1) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule shift_register\n(\n    input [8:0]in,\n    output [8:0]out,\n    input clk\n);\n\nreg [8:0]shift_reg;\n\nassign out[8] = shift_reg[8];\nassign out[7] = shift_reg[7];\nassign out[6] = shift_reg[6];\nassign out[5] = shift_reg[5];\nassign out[4] = shift_reg[4];\nassign out[3] = shift_reg[3];\nassign out[2] = shift_reg[2];\nassign out[1] = shift_reg[1];\nassign out[0] = shift_reg[0];\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[7:0], in[8]};\nend\nendmodule\n",
        "module_name": "LUT1",
        "module_hash": "9a742ba5b6dab0656e859fe0bde0723e",
        "dataset_index": 14373
      },
      "softusb_timer_78fd7a03": {
        "rtl_code": "\n\nmodule softusb_timer(\n\tinput usb_clk,\n\tinput usb_rst,\n\n\tinput io_we,\n\tinput [5:0] io_a,\n\toutput reg [7:0] io_do\n);\n\nreg [31:0] counter;\n\nalways @(posedge usb_clk) begin\n\tif(usb_rst) begin\n\t\tcounter <= 32'd0;\n\t\tio_do <= 8'd0;\n\tend else begin\n\t\tio_do <= 8'd0;\n\t\tcase(io_a)\n\t\t\t6'h20: io_do <= counter[7:0];\n\t\t\t6'h21: io_do <= counter[15:8];\n\t\t\t6'h22: io_do <= counter[23:16];\n\t\t\t6'h23: io_do <= counter[31:24];\n\t\tendcase\n\t\tif(io_we & ((io_a == 6'h20)|(io_a == 6'h21)|(io_a == 6'h22)|(io_a == 6'h23)))\n\t\t\tcounter <= 32'd0;\n\t\telse\n\t\t\tcounter <= counter + 32'd1;\n\tend\nend\n\nendmodule\n",
        "module_name": "softusb_timer",
        "module_hash": "78fd7a036db57e0c17f5ca65f6cbfe90",
        "dataset_index": 24789
      },
      "scan_chain_interface_88ae7d9b": {
        "rtl_code": "module scan_chain_interface (\n    input ctu_tst_pre_grst_l,\n    input arst_l,\n    input global_shift_enable,\n    input ctu_tst_scan_disable,\n    input ctu_tst_scanmode,\n    input ctu_tst_macrotest,\n    input ctu_tst_short_chain,\n    input long_chain_so_0,\n    input short_chain_so_0,\n    input long_chain_so_1,\n    input short_chain_so_1,\n    input long_chain_so_2,\n    input short_chain_so_2,\n    output mux_drive_disable,\n    output mem_write_disable,\n    output sehold,\n    output se,\n    output testmode_l,\n    output mem_bypass,\n    output so_0,\n    output so_1,\n    output so_2\n);\n\n    wire pin_based_scan;\n    wire short_chain_en;\n    wire short_chain_select;\n\n    assign pin_based_scan = ctu_tst_scan_disable;\n    assign se = global_shift_enable;\n    assign testmode_l = ~ctu_tst_scanmode;\n    assign mem_bypass = ~ctu_tst_macrotest & ~testmode_l;\n    assign short_chain_en = ~(pin_based_scan & se);\n    assign short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;\n    assign so_0 = short_chain_select ? short_chain_so_0 : long_chain_so_0;\n    assign so_1 = short_chain_select ? short_chain_so_1 : long_chain_so_1;\n    assign so_2 = short_chain_select ? short_chain_so_2 : long_chain_so_2;\n    assign mux_drive_disable = ~ctu_tst_pre_grst_l | short_chain_select | se;\n    assign mem_write_disable = ~ctu_tst_pre_grst_l | se;\n    assign sehold = ctu_tst_macrotest & ~se;\n\nendmodule",
        "module_name": "scan_chain_interface",
        "module_hash": "88ae7d9b6000c65fd26773c087b4f769",
        "dataset_index": 8068
      },
      "mux4x1_6e56b68d": {
        "rtl_code": "module mux4x1(\n    input clk,\n    input rst,\n    input sel0,\n    input sel1,\n    input [143:0] port0_ci,\n    input [143:0] port1_ci,\n    input [143:0] port2_ci,\n    input [143:0] port3_ci,\n    output reg [143:0] port_co\n    );\n\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      port_co <= 144'h000000000000000000000000000000000000;\n    end else begin\n      case ({sel1, sel0})\n        2'b00: port_co <= port0_ci;\n        2'b01: port_co <= port1_ci;\n        2'b10: port_co <= port2_ci;\n        2'b11: port_co <= port3_ci;\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "mux4x1",
        "module_hash": "6e56b68d090a0e94c98c862cb92593aa",
        "dataset_index": 19193
      },
      "xor_gate_8b58eda3": {
        "rtl_code": "module xor_gate (\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output reg XOR_output\n);\n\n    always @(*) begin\n        XOR_output = VPB ^ VNB;\n    end\n\nendmodule",
        "module_name": "xor_gate",
        "module_hash": "8b58eda3f484ba525dd8e01612fe6e3d",
        "dataset_index": 3290
      },
      "Clock_Divider_c09e9e36": {
        "rtl_code": "module Clock_Divider(\n    input clock,\n    input reset,\n    output reg clock_out\n);\n\nreg [1:0] counter;\nalways @(posedge clock or posedge reset) begin\n    if (reset) begin\n        counter <= 2'b0;\n        clock_out <= 1'b0;\n    end else begin\n        counter <= counter + 1;\n        if (counter == 2'b10) begin\n            counter <= 2'b0;\n            clock_out <= ~clock_out;\n        end\n    end\nend\n\nendmodule",
        "module_name": "Clock_Divider",
        "module_hash": "c09e9e36d8e4c9cbc5be1cdf636dd00d",
        "dataset_index": 13331
      },
      "pcie_7x_v1_3_fast_cfg_init_cntr #_6ba54a9d": {
        "rtl_code": "module pcie_7x_v1_3_fast_cfg_init_cntr #(\n  parameter PATTERN_WIDTH = 8,\n  parameter INIT_PATTERN  = 8'hA5,\n  parameter TCQ           = 1\n) (\n  input                          clk,\n  input                          rst,\n  output reg [PATTERN_WIDTH-1:0] pattern_o\n);\n\nalways @(posedge clk) begin\n  if(rst) begin\n    pattern_o <= #TCQ {PATTERN_WIDTH{1'b0}};\n  end else begin\n    if(pattern_o != INIT_PATTERN) begin\n      pattern_o <= #TCQ pattern_o + 1;\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "pcie_7x_v1_3_fast_cfg_init_cntr #",
        "module_hash": "6ba54a9d13c459f973b96e941564fc8e",
        "dataset_index": 10274
      },
      "dual_edge_triggered_ff_ef2ce85c": {
        "rtl_code": "module dual_edge_triggered_ff (\n  input clk,\n  input reset,\n  input data,\n  output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    q1 <= 1'b0;\n    q2 <= 1'b0;\n  end else begin\n    q1 <= data;\n    q2 <= q1;\n  end\nend\n\nalways @(negedge clk) begin\n  if (reset) begin\n    q <= 1'b0;\n  end else begin\n    q <= q2;\n  end\nend\n\nendmodule\n",
        "module_name": "dual_edge_triggered_ff",
        "module_hash": "ef2ce85c47f2c99fa3cdef8fd574118a",
        "dataset_index": 4927
      },
      "profibus_master_2efca194": {
        "rtl_code": "\nmodule profibus_master (\n  input clk,\n  input reset,\n  input [7:0] tx_data,\n  output reg tx_en,\n  output reg tx_done\n);\n\n  // Define Profibus frame format\n  parameter FRAME_START = 8'hFF;\n  parameter FRAME_END = 8'hFF;\n  parameter FRAME_ADDR = 8'h00;\n  parameter FRAME_CONTROL = 8'h00;\n  parameter FRAME_DATA_LEN = 8'h01;\n  \n  // Define internal signals\n  reg [7:0] tx_frame [0:10];\n  reg [3:0] tx_state;\n  reg tx_busy;\n  \n  // Initialize internal signals\n  initial begin\n    tx_frame[0] = FRAME_START;\n    tx_frame[1] = FRAME_ADDR;\n    tx_frame[2] = FRAME_CONTROL;\n    tx_frame[3] = FRAME_DATA_LEN;\n    tx_frame[4] = tx_data;\n    tx_frame[5] = FRAME_END;\n    tx_state = 0;\n    tx_busy = 0;\n  end\n  \n  // State machine for transmitting Profibus frame\n  always @(posedge clk) begin\n    if (reset) begin\n      tx_state <= 0;\n      tx_busy <= 0;\n    end else begin\n      case (tx_state)\n        0: begin // Idle state\n          if (tx_busy) begin\n            tx_state <= 1;\n          end\n        end\n        1: begin // Send start of frame\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 2;\n          end\n        end\n        2: begin // Send address and control bytes\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 3;\n          end\n        end\n        3: begin // Send data length and data\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 4;\n          end\n        end\n        4: begin // Send end of frame\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 0;\n            tx_busy <= 0;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // Trigger transmission of Profibus frame\n  always @(posedge clk) begin\n    if (reset) begin\n      tx_busy <= 0;\n    end else begin\n      if (!tx_busy && tx_state == 0) begin\n        tx_busy <= 1;\n      end\n    end\n  end\n  \nendmodule\nmodule profibus_slave (\n  input clk,\n  input reset,\n  input [7:0] rx_data,\n  output reg rx_en,\n  output wire rx_done\n);\n\n  // Define Profibus frame format\n  parameter FRAME_START = 8'hFF;\n  parameter FRAME_END = 8'hFF;\n  parameter FRAME_ADDR = 8'h00;\n  parameter FRAME_CONTROL = 8'h00;\n  parameter FRAME_DATA_LEN = 8'h01;\n  \n  // Define internal signals\n  reg [7:0] rx_frame [0:10];\n  reg [3:0] rx_state;\n  wire rx_busy;\n  \n  // Initialize internal signals\n  initial begin\n    rx_state = 0;\n  end\n  \n  // State machine for receiving Profibus frame\n  always @(posedge clk) begin\n    if (reset) begin\n      rx_state <= 0;\n    end else begin\n      case (rx_state)\n        0: begin // Idle state\n          if (rx_busy) begin\n            rx_state <= 1;\n          end\n        end\n        1: begin // Wait for start of frame\n          rx_en <= 1;\n          if (rx_done && rx_data == FRAME_START) begin\n            rx_frame[0] <= rx_data;\n            rx_state <= 2;\n          end\n        end\n        2: begin // Receive address and control bytes\n          rx_en <= 1;\n          if (rx_done) begin\n            rx_frame[1] <= rx_data;\n            rx_frame[2] <= rx_data;\n            rx_state <= 3;\n          end\n        end\n        3: begin // Receive data length and data\n          rx_en <= 1;\n          if (rx_done) begin\n            rx_frame[3] <= rx_data;\n            rx_frame[4] <= rx_data;\n            rx_state <= 4;\n          end\n        end\n        4: begin // Wait for end of frame\n          rx_en <= 1;\n          if (rx_done && rx_data == FRAME_END) begin\n            rx_frame[5] <= rx_data;\n            rx_state <= 0;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // Trigger reception of Profibus frame\n  assign rx_busy = (rx_state != 0);\n  \n  assign rx_done = (rx_state == 4) && (rx_data == FRAME_END);\n  \nendmodule",
        "module_name": "profibus_master",
        "module_hash": "2efca19443ecf43c929c704e3af8277b",
        "dataset_index": 10186
      },
      "simple_cpu_2c0a4153": {
        "rtl_code": "module simple_cpu(\n    input clk,\n    input reset,\n    input [7:0] address,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\nreg [15:0] accumulator;\nreg [7:0] program_counter;\n\nreg [15:0] memory [255:0];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        accumulator <= 16'b0;\n        program_counter <= 8'b0;\n    end else begin\n        case (memory[program_counter])\n            3'h0: accumulator <= accumulator + memory[address];\n            3'h1: accumulator <= accumulator - memory[address];\n            3'h2: accumulator <= accumulator & memory[address];\n            3'h3: accumulator <= accumulator | memory[address];\n            3'h4: accumulator <= accumulator ^ memory[address];\n            3'h5: accumulator <= memory[address];\n            3'h6: memory[address] <= accumulator;\n            default: accumulator <= accumulator;\n        endcase\n        program_counter <= program_counter + 1;\n    end\nend\n\nassign data_out = accumulator;\n\nendmodule",
        "module_name": "simple_cpu",
        "module_hash": "2c0a415353fcd04cf5477276d12485df",
        "dataset_index": 4404
      },
      "top__9aa193d1": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input d1,\n    input d2,\n    input reset,\n    input [15:0] in1,\n    input [15:0] in2,\n    output reg q1,\n    output reg q2,\n    output [15:0] out_xor,\n    output [15:0] out_and,\n    output [15:0] out_final\n );\n\n    // Define the T flip-flop for D1\n    reg t1;\n    always @(posedge clk) begin\n        if (reset) begin\n            q1 <= 0;\n        end else begin\n            q1 <= t1;\n        end\n    end\n    always @(posedge clk) begin\n        if (reset) begin\n            t1 <= 0;\n        end else begin\n            t1 <= d1;\n        end\n    end\n    \n    // Define the JK flip-flop for D2\n    reg j2, k2;\n    always @(posedge clk) begin\n        if (reset) begin\n            q2 <= 0;\n        end else begin\n            j2 <= d2;\n            k2 <= ~d2;\n            if (j2 && k2) begin\n                q2 <= ~q2;\n            end else if (j2) begin\n                q2 <= 1;\n            end else if (k2) begin\n                q2 <= 0;\n            end\n        end\n    end\n    \n    // Define the combinational circuit for XOR and AND\n    assign out_xor = in1 ^ in2;\n    assign out_and = in1 & in2;\n    \n    // Define the functional module for bitwise OR\n    assign out_final = q2 | out_and;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "9aa193d1fbe89b5d8813597701abd786",
        "dataset_index": 17195
      },
      "xor_gate_e8e83455": {
        "rtl_code": "\nmodule xor_gate (\n    input wire a,\n    input wire b,\n    output wire  out\n);\n\n    assign out = a ^ b;\n\nendmodule\nmodule byte_reversal (\n    input wire [31:0] in,\n    output wire  [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\nmodule functional_module (\n    input wire  in1,\n    input wire [31:0] in2,\n    output wire  [31:0] out\n);\n\n    assign out = {31'b0, in1} | in2;\n\nendmodule\nmodule top_module (\n    input wire a,\n    input wire b,\n    input wire [31:0] in,\n    input wire select,\n    output wire [31:0] out\n);\n\n    wire out_xor;\n    wire [31:0] byte_rev_out;\n    wire [31:0] func_out;\n\n    xor_gate xor_inst (\n        .a(a),\n        .b(b),\n        .out(out_xor)\n    );\n\n    byte_reversal byte_rev_inst (\n        .in(in),\n        .out(byte_rev_out)\n    );\n\n    functional_module func_inst (\n        .in1(out_xor),\n        .in2(byte_rev_out),\n        .out(func_out)\n    );\n\n    assign out = (select) ? func_out : {31'b0, out_xor};\n\nendmodule",
        "module_name": "xor_gate",
        "module_hash": "e8e83455c4285f73140606677dc41d08",
        "dataset_index": 15160
      },
      "BitsliceALU_b0dc94d5": {
        "rtl_code": "\nmodule BitsliceALU (\n    input  [15:0] A,\n    input  [15:0] B,\n    input  [5:0] Op,\n    output [15:0] Q,\n    output [2:0] Flags\n);\n\n    wire [15:0] result;\n    wire [3:0] X, Y;\n    wire [4:0] C;\n    wire [3:0] Z;\n    wire [3:0] C_out;\n\n    Circuit74181b slice3 (\n        .a(A[15:12]),\n        .b(B[15:12]),\n        .c(Op[4:1]),\n        .d(C[2]),\n        .e(Op[5]),\n        .f(1'b0),\n        .g(result[15:12]),\n        .h(X[3]),\n        .i(Y[3]),\n        .j(C[3])\n    );\n    Circuit74181b slice2 (\n        .a(A[11:8]),\n        .b(B[11:8]),\n        .c(Op[4:1]),\n        .d(C[1]),\n        .e(Op[5]),\n        .f(1'b0),\n        .g(result[11:8]),\n        .h(X[2]),\n        .i(Y[2]),\n        .j(C[2])\n    );\n    Circuit74181b slice1 (\n        .a(A[7:4]),\n        .b(B[7:4]),\n        .c(Op[4:1]),\n        .d(C[0]),\n        .e(Op[5]),\n        .f(1'b0),\n        .g(result[7:4]),\n        .h(X[1]),\n        .i(Y[1]),\n        .j(C[1])\n    );\n    Circuit74181b slice0 (\n        .a(A[3:0]),\n        .b(B[3:0]),\n        .c(Op[4:1]),\n        .d(Op[5]),\n        .e(Op[0]),\n        .f(1'b0),\n        .g(result[3:0]),\n        .h(X[0]),\n        .i(Y[0]),\n        .j(C[0])\n    );\n\n    assign Q = result;\n\n    assign Flags[0] = ~C_out[3];\n    assign Flags[1] = result[15];\n    assign Flags[2] = (result == 16'h0000);\n\n    assign C_out[0] = C[0];\n    assign C_out[1] = C[1] | (C[0] & ~Y[1]);\n    assign C_out[2] = C[2] | (C[1] & ~Y[2]) | (C[0] & ~Y[1] & ~Y[2]);\n    assign C_out[3] = C[3] | (C[2] & ~Y[3]) | (C[1] & ~Y[2] & ~Y[3]) | (C[0] & ~Y[1] & ~Y[2] & ~Y[3]);\nendmodule\nmodule Circuit74181b (\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input d,\n    input e,\n    input [1:0] f,\n    output [3:0] g,\n    output h,\n    output i,\n    output j\n);\n    wire [3:0] P, G;\n\n    assign P[0] = a[0] & b[0];\n    assign P[1] = a[1] & b[1];\n    assign P[2] = a[2] & b[2];\n    assign P[3] = a[3] & b[3];\n\n    assign G[0] = a[0] | b[0];\n    assign G[1] = a[1] | b[1];\n    assign G[2] = a[2] | b[2];\n    assign G[3] = a[3] | b[3];\n\n    assign g[0] = P[0];\n    assign g[1] = P[1] | (P[0] & G[1]);\n    assign g[2] = P[2] | (P[1] & G[2]) | (P[0] & G[1] & G[2]);\n    assign g[3] = P[3] | (P[2] & G[3]) | (P[1] & G[2] & G[3]) | (P[0] & G[1] & G[2] & G[3]);\n\n    assign h = c[0];\n    assign i = e & f[0];\n    assign j = ~e | ~f[1];\nendmodule",
        "module_name": "BitsliceALU",
        "module_hash": "b0dc94d54541dc89c2929c4619002f97",
        "dataset_index": 20339
      },
      "sram_e84a1d0a": {
        "rtl_code": "\nmodule sram (\n\tclock,\n\tdata,\n\trdaddress,\n\twraddress,\n\twren,\n\tq);\n\n\tinput\t  clock;\n\tinput\t[15:0]  data;\n\tinput\t[11:0]  rdaddress;\n\tinput\t[11:0]  wraddress;\n\tinput\t  wren;\n\toutput reg [15:0]  q;\n\n\treg [15:0] mem [0:(1<<12)-1];\n\n\talways @(posedge clock) begin\n\t\tif (wren) begin\n\t\t\tmem[wraddress] <= data;\n\t\tend else begin\n\t\t\tq <= mem[rdaddress];\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "sram",
        "module_hash": "e84a1d0aecd2fc181dbb5cc451961726",
        "dataset_index": 15239
      },
      "rst_generator_3f5a5829": {
        "rtl_code": "module rst_generator(\n    input       clk,            input       rst_i,          output  reg rst_o           );\n\n    reg [6:0] counter_r;\n    reg       rst_i_sync_0;\n    reg       rst_i_sync_1;\n\n  initial begin\n        rst_o     <= 1'b0;\n        counter_r <= 7'b0;\n    end\n\n    always @(posedge clk) begin\n        rst_i_sync_0 <= rst_i;\n        rst_i_sync_1 <= rst_i_sync_0;\n\n        if (rst_o != rst_i_sync_1) begin\n            counter_r <= counter_r + 7'b1;\n        end\n        else begin\n            counter_r <= 7'b0;\n        end\n\n        if (counter_r == 7'h7F) begin\n            rst_o <= ~rst_o;\n        end\n        else begin\n            rst_o <= rst_o;\n        end\n    end\nendmodule\n",
        "module_name": "rst_generator",
        "module_hash": "3f5a5829a46607a865775d68180867c4",
        "dataset_index": 7354
      },
      "eth_outputcontrol_d239338d": {
        "rtl_code": "module eth_outputcontrol(Clk, Reset, InProgress, ShiftedBit, BitCounter, WriteOp, NoPre, MdcEn_n, Mdo, MdoEn);\n\ninput         Clk;                // Host Clock\ninput         Reset;              // General Reset\ninput         WriteOp;            // Write Operation Latch (When asserted, write operation is in progress)\ninput         NoPre;              // No Preamble (no 32-bit preamble)\ninput         InProgress;         // Operation in progress\ninput         ShiftedBit;         // This bit is output of the shift register and is connected to the Mdo signal\ninput   [6:0] BitCounter;         // Bit Counter\ninput         MdcEn_n;            // MII Management Data Clock Enable signal is asserted for one Clk period before Mdc falls.\n\noutput        Mdo;                // MII Management Data Output\noutput        MdoEn;              // MII Management Data Output Enable\n\nwire          SerialEn;\n\nreg           MdoEn_2d;\nreg           MdoEn_d;\nreg           MdoEn;\n\nreg           Mdo_2d;\nreg           Mdo_d;\nreg           Mdo;                // MII Management Data Output\n\n// Generation of the Serial Enable signal (enables the serialization of the data)\nassign SerialEn =  WriteOp & InProgress & ( BitCounter>31 | ( ( BitCounter == 0 ) & NoPre ) )\n                | ~WriteOp & InProgress & (( BitCounter>31 & BitCounter<46 ) | ( ( BitCounter == 0 ) & NoPre ));\n\n// Generation of the MdoEn signal.\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      MdoEn_2d <= 1'b0;\n      MdoEn_d <= 1'b0;\n      MdoEn <= 1'b0;\n    end\n  else\n    begin\n      if(MdcEn_n)\n        begin\n          MdoEn_2d <= SerialEn | InProgress & BitCounter<32;\n          MdoEn_d <= MdoEn_2d;\n          MdoEn <= MdoEn_d;\n        end\n    end\nend\n\n// Generation of the Mdo signal.\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      Mdo_2d <= 1'b0;\n      Mdo_d <= 1'b0;\n      Mdo <= 1'b0;\n    end\n  else\n    begin\n      if(MdcEn_n)\n        begin\n          Mdo_2d <= ~SerialEn & BitCounter<32;\n          Mdo_d <= ShiftedBit | Mdo_2d;\n          Mdo <= Mdo_d;\n        end\n    end\nend\n\nendmodule",
        "module_name": "eth_outputcontrol",
        "module_hash": "d239338deaeb4712d06994db2fcc5121",
        "dataset_index": 478
      },
      "barrel_shifter_5e5772e0": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [7:0] data_in,\n    input [1:0] shift_amt,\n    input shift_dir,\n    input enable,\n    output [7:0] data_out\n);\n\nreg [7:0] data_out_int;\n\nalways @(*) begin\n    if (enable) begin\n        if (shift_dir) begin\n            data_out_int = data_in << shift_amt;\n        end else begin\n            data_out_int = data_in >> shift_amt;\n        end\n    end else begin\n        data_out_int = data_in;\n    end\nend\n\nassign data_out = data_out_int;\n\nendmodule\n\nmodule up_down_counter (\n    input clk,\n    input rst,\n    input load,\n    input up_down,\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n\nreg [7:0] count;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end else if (load) begin\n        count <= data_in;\n    end else begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nassign data_out = count;\n\nendmodule\n\nmodule bitwise_and (\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    output [7:0] data_out\n);\n\nassign data_out = data_in1 & data_in2;\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "5e5772e04c2fa12453b14ace14aaef7f",
        "dataset_index": 17583
      },
      "addr_gen_e221f5ad": {
        "rtl_code": "\nmodule addr_gen(nrst, clk, wr_en, wr_inc, load_w2r, rd_inc, rd_step, addr_wr, addr_rd, wr_end);\n    input nrst;\n    input clk;\n    input wr_en;\n    input wr_inc;\n    input load_w2r;\n    input rd_inc;\n    input [7:0] rd_step;\n    output [17:0] addr_wr;\n    output [17:0] addr_rd;\n    output wr_end;\n    \n    wire [17:0] addr_wr;\n    wire [17:0] addr_rd;\n    wire [17:0] rd_step_ex;\n    reg wr_end;\n    wire wr_inc_sig;\n    wire reach;\n    \n    // \u5199\u5730\u5740\u8fd4\u56de\u5230\u8bfb\u5730\u5740\u8868\u793a\u5199\u6ee1\uff0c\u5b9e\u73b0\u9884\u89e6\u53d1\u6df1\u5ea6\u8c03\u6574\u662f\u89e6\u53d1\u540e\u7acb\u5373\u4fee\u6539\u8bfb\u5730\u5740\u5230\u9700\u8981\u4f4d\u7f6e\n    assign reach = (addr_wr == addr_rd);\n    assign wr_inc_sig = wr_en & wr_inc & ~wr_end;\n    \n    assign rd_step_ex = {{11{rd_step[7]}}, rd_step[6:0]};\n    \n    // \u5199\u5730\u5740\u81ea\u589e\n    cnt #(18) u_wrcnt(.nrst(nrst), .clk(clk),\n        .en(wr_inc_sig), .step(1), .load(0), .cin(0), .cnt(addr_wr));\n    \n    // \u89e6\u53d1\u65f6\u8bbe\u7f6e\u8bfb\u5730\u5740\u4e3a\u5199\u5730\u5740\uff0c\u5426\u5219\u81ea\u589e\u6216\u81ea\u51cf\n    cnt #(18) u_rdcnt(.nrst(nrst), .clk(clk),\n        .en(rd_inc), .step(rd_step_ex), .load(load_w2r), .cin(addr_wr), .cnt(addr_rd));\n    \n    // \u751f\u6210\u91c7\u6837\u5b8c\u6210\u4fe1\u53f7\uff0c\u5728\u505c\u6b62\u91c7\u6837\u65f6\u6e05\u9664\n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            wr_end <= 1'b0;\n        end else if (reach) begin\n            wr_end <= 1'b1;\n        end else if (~wr_en) begin\n            wr_end <= 1'b0;\n        end\n    end\nendmodule\nmodule cnt #(parameter WIDTH = 8)\n(\n    input nrst,\n    input clk,\n    input en,\n    input [WIDTH-1:0] step,\n    input load,\n    input [WIDTH-1:0] cin,\n    output reg [WIDTH-1:0] cnt\n);\n\n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            cnt <= 'b0;\n        end else if (load) begin\n            cnt <= cin;\n        end else if (en) begin\n            cnt <= cnt + step;\n        end\n    end\n\nendmodule",
        "module_name": "addr_gen",
        "module_hash": "e221f5ad583712e449bd8068177c7d9c",
        "dataset_index": 11227
      },
      "OAI21X1_3e58a631": {
        "rtl_code": "module OAI21X1 (input IN1, IN2, IN3, output QN, input VDD, VSS);\n\n  wire a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n\n  assign a = IN1 | IN2;\n  assign b = ~a;\n  assign c = ~IN2;\n  assign d = c | IN3;\n  assign e = b & d;\n  assign f = ~c;\n  assign g = f & IN3;\n  assign h = e | g;\n  assign i = ~h;\n  assign j = i & VDD;\n  assign k = ~VSS;\n  assign l = j & k;\n  assign m = ~l;\n  assign n = m & VDD;\n  assign o = ~VSS;\n  assign p = n & o;\n  assign q = ~p;\n  assign r = q & VDD;\n  assign s = ~VSS;\n  assign t = r & s;\n  assign u = ~t;\n  assign v = u & VDD;\n  assign w = ~VSS;\n  assign x = v & w;\n  assign y = ~x;\n  assign z = y & VDD;\n\n  assign QN = z & ~VSS;\n\nendmodule",
        "module_name": "OAI21X1",
        "module_hash": "3e58a6310a32174aea02fe33a3d28195",
        "dataset_index": 15198
      },
      "mux32bits_32to1_69eaa406": {
        "rtl_code": "\nmodule mux32bits_32to1 (\n  input [4:0] s,\n  input [31:0] i31,\n  input [31:0] i30,\n  input [31:0] i29,\n  input [31:0] i28,\n  input [31:0] i27,\n  input [31:0] i26,\n  input [31:0] i25,\n  input [31:0] i24,\n  input [31:0] i23,\n  input [31:0] i22,\n  input [31:0] i21,\n  input [31:0] i20,\n  input [31:0] i19,\n  input [31:0] i18,\n  input [31:0] i17,\n  input [31:0] i16,\n  input [31:0] i15,   \n  input [31:0] i14,\n  input [31:0] i13,\n  input [31:0] i12,\n  input [31:0] i11,\n  input [31:0] i10,\n  input [31:0] i9 ,\n  input [31:0] i8 ,\n  input [31:0] i7 ,\n  input [31:0] i6 ,\n  input [31:0] i5 ,\n  input [31:0] i4 ,\n  input [31:0] i3 ,\n  input [31:0] i2 ,\n  input [31:0] i1 ,\n  input [31:0] i0 ,\n  output reg [31:0] z\n);\n\n  always @(*) begin\n    case (s)\n      5'b00001: z <= i0;\n      5'b00010: z <= i1;\n      5'b00011: z <= i2;\n      5'b00100: z <= i3;\n      5'b00101: z <= i4;\n      5'b00110: z <= i5;\n      5'b00111: z <= i6;\n      5'b01000: z <= i7;\n      5'b01001: z <= i8;\n      5'b01010: z <= i9;\n      5'b01011: z <= i10;\n      5'b01100: z <= i11;\n      5'b01101: z <= i12;\n      5'b01110: z <= i13;\n      5'b01111: z <= i14;\n      5'b10000: z <= i15;\n      5'b10001: z <= i16;\n      5'b10010: z <= i17;\n      5'b10011: z <= i18;\n      5'b10100: z <= i19;\n      5'b10101: z <= i20;\n      5'b10110: z <= i21;\n      5'b10111: z <= i22;\n      5'b11000: z <= i23;\n      5'b11001: z <= i24;\n      5'b11010: z <= i25;\n      5'b11011: z <= i26;\n      5'b11100: z <= i27;\n      5'b11101: z <= i28;\n      5'b11110: z <= i29;\n      5'b11111: z <= i30;\n      default:  z <= 0;\n    endcase\n  end\n\nendmodule\n",
        "module_name": "mux32bits_32to1",
        "module_hash": "69eaa406e1808bc4a0d2a8c5ac8bda8c",
        "dataset_index": 17582
      },
      "sky130_fd_sc_hdll__einvn_083e6873": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__einvn (\n    Z   ,\n    A   ,\n    TE_B\n);\n\n    output Z   ;\n    input  A   ;\n    input  TE_B;\n\n    notif0 notif00 (Z     , A, TE_B        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__einvn",
        "module_hash": "083e687396df2b262db1c2299eebf1da",
        "dataset_index": 16604
      },
      "counter_4bit_e7e50ed7": {
        "rtl_code": "module counter_4bit(clk, rst, q);\n\ninput clk, rst;\noutput reg [3:0] q;\n\nalways @(posedge clk) begin\n\tif (rst == 1'b1) // Synchronous reset\n\t\tq <= 4'b0;\n\telse if (q == 4'b1111) // Counter rolls over to 0\n\t\tq <= 4'b0;\n\telse\n\t\tq <= q + 1; // Counter increments\nend\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "e7e50ed7b20a22cc240bded322f73638",
        "dataset_index": 19249
      },
      "top_module_cc4a7249": {
        "rtl_code": "module top_module(\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    input [3:0] data6,\n    input [3:0] data7,\n    output [3:0] out\n);\n\n// 8-to-1 MUX implementation\nassign out = (sel == 3'd0) ? data0 :\n             (sel == 3'd1) ? data1 :\n             (sel == 3'd2) ? data2 :\n             (sel == 3'd3) ? data3 :\n             (sel == 3'd4) ? data4 :\n             (sel == 3'd5) ? data5 :\n             (sel == 3'd6) ? data6 :\n                             data7;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "cc4a724942f73345f447f91e50e7c7d9",
        "dataset_index": 131
      },
      "decoder_6b6b905f": {
        "rtl_code": "module decoder(\n    input clk,\n    input [63:0] probe0,\n    input [63:0] probe1,\n    input [0:0] probe2,\n    input [0:0] probe3,\n    input [0:0] probe4,\n    input [0:0] probe5,\n    input [0:0] probe6,\n    input [63:0] probe7,\n    input [0:0] probe8,\n    input [0:0] probe9,\n    input [0:0] probe10,\n    input [0:0] probe11,\n    input [63:0] probe12,\n    input [0:0] probe13,\n    input [0:0] probe14,\n    input [0:0] probe15,\n    input [0:0] probe16,\n    input [0:0] probe17,\n    input [7:0] probe18,\n    input [8:0] probe19,\n    input [0:0] probe20,\n    input [2:0] probe21,\n    input [2:0] probe22,\n    input [0:0] probe23,\n    input [7:0] probe24,\n    output reg [63:0] output0,\n    output reg output1,\n    output reg [63:0] output2,\n    output reg [7:0] output3,\n    output reg [8:0] output4\n);\n\nalways @(posedge clk) begin\n    output0 <= {probe0, probe1};\n    output1 <= &{probe2, probe3, probe4, probe5, probe6};\n    output2 <= {probe7, probe12};\n    output3 <= {probe18, probe24};\n    output4 <= {probe19, probe21, probe22};\nend\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "6b6b905fceb731af3179d41c57d1e7d2",
        "dataset_index": 9724
      },
      "d_flip_flop_7c645a11": {
        "rtl_code": "module d_flip_flop (\n    input D,\n    input CLK,\n    input SET,\n    input RESET,\n    input CE,\n    output reg Q,\n    output reg Q_N\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Flip-flop implementation\n    always @(posedge CLK or negedge CE) begin\n        if (CE == 0) begin\n            Q <= Q;\n            Q_N <= Q_N;\n        end else if (SET == 0) begin\n            Q <= 1'b1;\n            Q_N <= 1'b0;\n        end else if (RESET == 0) begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule",
        "module_name": "d_flip_flop",
        "module_hash": "7c645a119c39124cb809da8156126578",
        "dataset_index": 10698
      },
      "a23_multiply_29907fe6": {
        "rtl_code": "module a23_multiply (\ninput                       i_clk,\ninput                       i_fetch_stall,\n\ninput       [31:0]          i_a_in,         input       [31:0]          i_b_in,         input       [1:0]           i_function,\ninput                       i_execute,\n\noutput      [31:0]          o_out,\noutput      [1:0]           o_flags,        output reg                  o_done = 'd0    );\n\n\nwire        enable;\nwire        accumulate;\nwire [33:0] multiplier;\nwire [33:0] multiplier_bar;\nwire [33:0] sum;\nwire [33:0] sum34_b;\n\nreg  [5:0]  count = 'd0;\nreg  [5:0]  count_nxt;\nreg  [67:0] product = 'd0;\nreg  [67:0] product_nxt;\nreg  [1:0]  flags_nxt;\nwire [32:0] sum_acc1;           assign enable         = i_function[0];\nassign accumulate     = i_function[1];\n \nassign multiplier     =  { 2'd0, i_a_in} ;\nassign multiplier_bar = ~{ 2'd0, i_a_in} + 34'd1 ;\n\nassign sum34_b        =  product[1:0] == 2'b01 ? multiplier     :\n                         product[1:0] == 2'b10 ? multiplier_bar :\n                                                 34'd0          ;\n\n\n`ifdef XILINX_FPGA\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(34)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(34))  \n    `endif\n        \n        u_xx_addsub_34_sum (\n        .i_a    ( product[67:34]        ),\n        .i_b    ( sum34_b               ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum                   ),\n        .o_co   (                       )\n    );\n\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(33)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(33)) \n    `endif\n        u_xx_addsub_33_acc1 (\n        .i_a    ( {1'd0, product[32:1]} ),\n        .i_b    ( {1'd0, i_a_in}        ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum_acc1              ),\n        .o_co   (                       )\n    );\n\n`else\n \n    assign sum =  product[67:34] + sum34_b;\n     \n    assign sum_acc1 = {1'd0, product[32:1]} + {1'd0, i_a_in};\n     \n`endif\n\n\nalways @*\n    begin\n    count_nxt           = count;\n    product_nxt         = product;\n    \n    flags_nxt   = { product[32], product[32:1] == 32'd0 }; \n    \n\n    if ( count == 6'd0 )\n        product_nxt = {33'd0, 1'd0, i_b_in, 1'd0 } ;\n    else if ( count <= 6'd33 )\n        product_nxt = { sum[33], sum, product[33:1]} ;\n    else if ( count == 6'd34 && accumulate )\n        begin\n        product_nxt         = { product[64:33], sum_acc1[31:0], 1'd0}; end\n        \n    if (count == 6'd0)  count_nxt   = enable ? 6'd1 : 6'd0;\n    else if ((count == 6'd34 && !accumulate) ||  (count == 6'd35 &&  accumulate)  )  count_nxt   = 6'd0;\n    else\n        count_nxt   = count + 1'd1;\n    end\n\n\nalways @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        count           <= i_execute ? count_nxt          : count;           \n        product         <= i_execute ? product_nxt        : product;        \n        o_done          <= i_execute ? count == 6'd31     : o_done;          \n        end\n\nassign o_out   = product[32:1]; \nassign o_flags = flags_nxt;\n                     \nendmodule\n\n\n",
        "module_name": "a23_multiply",
        "module_hash": "29907fe6836ecb3efe96b1752670a682",
        "dataset_index": 25126
      },
      "dct_processor_dd5690eb": {
        "rtl_code": "\nmodule dct_processor (\n  input clk,\n  input [29:0] dct_buffer,\n  input [3:0] dct_count,\n  input test_ending,\n  input test_has_ended,\n  output [15:0] current_coefficient,\n  output [3:0] total_coefficients\n);\n\n  reg [29:0] dct_buffer_reg;\n  reg [3:0] dct_count_reg;\n  reg [15:0] current_coefficient_reg;\n  reg [3:0] total_coefficients_reg;\n  reg processing;\n  \n  always @(posedge clk) begin\n    if (test_ending == 1) begin\n      processing <= 0;\n    end else if (processing == 1 && dct_count_reg == 0) begin\n      processing <= 0;\n    end else if (processing == 0 && dct_count_reg > 0) begin\n      processing <= 1;\n    end\n  end\n  \n  always @(posedge clk) begin\n    if (processing == 1) begin\n      current_coefficient_reg <= dct_buffer_reg[15:0];\n      dct_buffer_reg <= {dct_buffer_reg[14:0], 1'b0};\n      dct_count_reg <= dct_count_reg - 1;\n      if (dct_count_reg == 0) begin\n        total_coefficients_reg <= total_coefficients_reg + 1;\n      end\n    end else begin\n      current_coefficient_reg <= 0;\n      dct_buffer_reg <= dct_buffer;\n      dct_count_reg <= dct_count;\n      total_coefficients_reg <= 0;\n    end\n  end\n  \n  assign current_coefficient = current_coefficient_reg;\n  assign total_coefficients = total_coefficients_reg;\n  \nendmodule\n",
        "module_name": "dct_processor",
        "module_hash": "dd5690eb11a5c6d8e0717c20a1610a03",
        "dataset_index": 20536
      },
      "fifo_08a5011c": {
        "rtl_code": "module fifo\n(\n    input  clk,            // bus clock\n    input  reset,          // reset\n    input  [15:0] in,      // data in\n    output reg [15:0] out, // data out\n    input  rd,             // read from fifo\n    input  wr,             // write to fifo\n    output reg empty,      // fifo is empty\n    output reg full,       // fifo is full\n    output [11:0] cnt      // number of entries in FIFO\n);\n\n    // local signals and registers\n    reg  [15:0] mem [2047:0]; // 2048 words by 16 bit wide fifo memory (for 2 MFM-encoded sectors)\n    reg  [11:0] in_ptr;       // fifo input pointer\n    reg  [11:0] out_ptr;      // fifo output pointer\n    wire equal;               // lower 11 bits of in_ptr and out_ptr are equal\n\n    // count of FIFO entries\n    assign cnt = in_ptr - out_ptr;\n\n    // main fifo memory (implemented using synchronous block ram)\n    always @(posedge clk)\n    if (wr)\n        mem[in_ptr[10:0]] <= in;\n\n    always @(posedge clk)\n    out=mem[out_ptr[10:0]];\n\n    // fifo write pointer control\n    always @(posedge clk)\n    if (reset)\n        in_ptr[11:0] <= 0;\n    else if(wr)\n        in_ptr[11:0] <= in_ptr[11:0] + 12'd1;\n\n    // fifo read pointer control\n    always @(posedge clk)\n    if (reset)\n        out_ptr[11:0] <= 0;\n    else if (rd)\n        out_ptr[11:0] <= out_ptr[11:0] + 12'd1;\n\n    // check lower 11 bits of pointer to generate equal signal\n    assign equal = (in_ptr[10:0]==out_ptr[10:0]) ? 1'b1 : 1'b0;\n\n    // assign output flags, empty is delayed by one clock to handle ram delay\n    always @(posedge clk)\n    if (equal && (in_ptr[11]==out_ptr[11]))\n        empty <= 1'b1;\n    else\n        empty <= 1'b0;\n    \n    always @(posedge clk)\n    if (equal && (in_ptr[11]!=out_ptr[11]))\n        full <= 1'b1;\n    else\n        full <= 1'b0;\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "08a5011c7dbf94f49a076cca9d2b8505",
        "dataset_index": 2199
      },
      "uart_rx_d88c1233": {
        "rtl_code": "module uart_rx (\n  input clk,\n  input reset,\n  input rxd,\n  output reg ack,\n  output reg [7:0] rx_data,\n  output reg rx_full\n);\n\n  parameter IDLE = 2'd0;\n  parameter START = 2'd1;\n  parameter DATA = 2'd2;\n  parameter STOP = 2'd3;\n  \n  reg [1:0] state;\n  reg [2:0] bit_count;\n  reg [7:0] data_bits;\n  reg stop_bit;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      bit_count <= 0;\n      data_bits <= 0;\n      stop_bit <= 1;\n      rx_full <= 0;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (!rxd) begin\n            state <= START;\n            bit_count <= 0;\n            data_bits <= 0;\n            stop_bit <= 1;\n          end\n        end\n        START: begin\n          if (bit_count == 0) begin\n            if (!rxd) begin\n              bit_count <= bit_count + 1;\n            end\n          end else if (bit_count < 9) begin\n            data_bits[bit_count-1] <= rxd;\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 9) begin\n            stop_bit <= rxd;\n            bit_count <= bit_count + 1;\n          end else begin\n            state <= DATA;\n            bit_count <= 0;\n          end\n        end\n        DATA: begin\n          if (bit_count < 8) begin\n            data_bits[bit_count] <= rxd;\n            bit_count <= bit_count + 1;\n          end else begin\n            state <= STOP;\n            bit_count <= 0;\n          end\n        end\n        STOP: begin\n          if (bit_count == 0) begin\n            if (rxd == stop_bit) begin\n              ack <= 1;\n              rx_data <= data_bits;\n              rx_full <= 1;\n            end else begin\n              ack <= 0;\n              rx_data <= 0;\n              rx_full <= 0;\n            end\n            state <= IDLE;\n          end else begin\n            bit_count <= bit_count + 1;\n          end\n        end\n      endcase\n    end\n  end\n  \nendmodule",
        "module_name": "uart_rx",
        "module_hash": "d88c12338f05d24004056d38dcd6ca62",
        "dataset_index": 3698
      },
      "initial_config_91499612": {
        "rtl_code": "`define REG_SIZE 20\nmodule initial_config(\n\niCLK, iRST_n, oINITIAL_START,\niINITIAL_ENABLE,\n);\n\n\ninput iCLK;\ninput iRST_n;\noutput oINITIAL_START;\ninput\tiINITIAL_ENABLE;\n\nwire oINITIAL_START;\nreg [`REG_SIZE-1:0] cnt;\n\nalways@(posedge iCLK or negedge iRST_n)\n\tbegin\n\t\tif (!iRST_n)\n\t\t\tbegin \n\t\t\t\tcnt <= 0;\n\t\t\tend\n\t\telse if (cnt == 20'hfffff)\n\n\t\t\tbegin\n\t\t\t\tcnt <=20'hfffff;\n\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tcnt <= cnt + 1;\t\n\t\t\tend\n\tend\n\t\n\t\nassign oINITIAL_START = ((cnt == 20'hffffe)&iINITIAL_ENABLE) ? 1'b1: 1'b0;\n\n\nendmodule\n\n\n\n\n",
        "module_name": "initial_config",
        "module_hash": "91499612e0743e8212966e70df927212",
        "dataset_index": 2774
      },
      "sky130_fd_sc_ms__o31ai_6b4963a1": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__o31ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1, A3     );\n    nand nand0 (nand0_out_Y, B1, or0_out    );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__o31ai",
        "module_hash": "6b4963a124631dc481f607e1b6b1512b",
        "dataset_index": 14099
      },
      "memory_interface_bae50a22": {
        "rtl_code": "\nmodule memory_interface(clka, wea, addra, dina, douta);\n  parameter MEM_SIZE = 2**8; // 14-bit address gives 2^14 memory locations\n  parameter MEM_WIDTH = 12; // each memory location holds 1 byte of data\n  reg [MEM_WIDTH-1:0] mem [0:MEM_SIZE-1]; // declare memory array\n\n  input clka;\n  input  wea;\n  input [7:0] addra;\n  input [MEM_WIDTH-1:0] dina;\n  output reg [MEM_WIDTH-1:0] douta;\n\n  always @(posedge clka) begin\n    if (wea == 1'b1) begin // write to memory\n      mem[addra] <= dina;\n    end\n    douta <= mem[addra];\n  end\n\nendmodule",
        "module_name": "memory_interface",
        "module_hash": "bae50a22cae35e6f983a4920962251b7",
        "dataset_index": 20204
      },
      "FrameWriter_ac8ef0da": {
        "rtl_code": "\n\nmodule FrameWriter (\n\tinput clk,\n\tinput rst,\n\n\tinput [23:0] din_data,\n\tinput din_valid,\n\toutput wire din_ready,\n\tinput wire din_sop,\n\tinput wire din_eop,\n\t\n\toutput wire [DATA_WIDTH-1:0] data_fifo_out,\n\toutput wire data_valid_fifo_out,\n\tinput wire [FIFO_DEPTH_LOG2:0] usedw_fifo_out,\n\t\n\tinput start,\n\toutput endf\n);\n\n\tparameter DATA_WIDTH = 32;\n\tparameter FIFO_DEPTH = 256;\n\tparameter FIFO_DEPTH_LOG2 = 8;\n\n\treg video_reg;\n\twire set_video;\n\twire reset_video;\n\t\n\treg [1:0] run;\n\n\talways @ (posedge clk) begin\n\t\tif (start == 1) begin\n\t\t\tvideo_reg <= 0;\n\t\tend\telse begin\n\t\t\tif (reset_video == 1) begin\n\t\t\t\tvideo_reg <= 0;\n\t\t\tend \n\t\t\tif (set_video == 1) begin\n\t\t\t\tvideo_reg <= 1;\n\t\t\tend \n\t\tend\n\tend\n\t\n\talways @ (posedge clk or posedge rst) begin\n\t\tif (rst == 1) begin\n\t\t\trun <= 0;\n\t\tend else begin\n\t\t\tif (start == 1) begin\n\t\t\t\trun <= 1;\n\t\t\tend else begin\n\t\t\t\tif (reset_video == 1) begin\n\t\t\t\t\trun <= 2;\n\t\t\t\tend\n\t\t\t\tif (endf == 1) begin\n\t\t\t\t\trun <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign set_video = (din_sop == 1) & (din_data == 0) & (din_valid == 1) & (run == 1);\n\tassign reset_video = (din_eop == 1) & (din_valid == 1) & (video_reg == 1);\n\t\n\tassign data_fifo_out = {8'd0, din_data};\n\tassign data_valid_fifo_out = (video_reg == 1) & (din_valid == 1) & (run == 1);\n\n\tassign din_ready = (usedw_fifo_out < (FIFO_DEPTH - 1));\n\t\n\tassign endf = (run == 2);\n   \nendmodule\n",
        "module_name": "FrameWriter",
        "module_hash": "ac8ef0da6efeb27e27d1f0527bb32afb",
        "dataset_index": 13027
      },
      "top_ae1b12d9": {
        "rtl_code": "\nmodule top(clk,a,b,c,set);\nparameter A_WIDTH = 6 ;\nparameter B_WIDTH = 6 ;\ninput set;\ninput clk;\ninput signed [(A_WIDTH - 1):0] a;\ninput signed [(B_WIDTH - 1):0] b;\noutput signed [(A_WIDTH + B_WIDTH - 1):0] c;\nreg [(A_WIDTH + B_WIDTH - 1):0] reg_tmp_c;\nassign c = reg_tmp_c;\nalways @(posedge clk)\nbegin\n    if(set)\n    begin\n        reg_tmp_c <= 0;\n    end\n    else\n    begin\n        reg_tmp_c <= a * b + c;\n    end\nend\nendmodule\n\nmodule top2(clk,a,b,c,hold);\nparameter A_WIDTH = 6 ;\nparameter B_WIDTH = 6 ;\ninput hold;\ninput clk;\ninput signed [(A_WIDTH - 1):0] a;\ninput signed [(B_WIDTH - 1):0] b;\noutput signed [(A_WIDTH + B_WIDTH - 1):0] c;\nreg signed [A_WIDTH-1:0] reg_a;\nreg signed [B_WIDTH-1:0] reg_b;\nreg [(A_WIDTH + B_WIDTH - 1):0] reg_tmp_c;\nassign c = reg_tmp_c;\nalways @(posedge clk)\nbegin\n    if (!hold) begin\n        reg_a <= a;\n        reg_b <= b;\n        reg_tmp_c <= reg_a * reg_b + c;\n    end\nend\nendmodule\n",
        "module_name": "top",
        "module_hash": "ae1b12d93ac1fde044e4d04e997da693",
        "dataset_index": 25343
      },
      "counter #_82a46624": {
        "rtl_code": "\nmodule counter #(\n    parameter AWIDTH = 8 // Change to a constant value\n)(\n    input clk,\n    input ce,\n    output reg [7:0] q\n);\n\n\nwire [AWIDTH-1:0] addr;\nwire ce0;\nwire [7:0] data;\n\nassign addr = q;\nassign ce0 = ce;\n\n// Instantiate the ROM module\nLoop_loop_height_jbC_rom rom (\n    .addr0(addr),\n    .ce0(ce0),\n    .q0(data),\n    .clk(clk)\n);\n\n// Update the counter value\nalways @(posedge clk) begin\n    if (ce) begin\n        q <= q + 1;\n    end\nend\n\nendmodule\nmodule Loop_loop_height_jbC_rom (\n    input [7:0] addr0,\n    input ce0,\n    output reg [7:0] q0,\n    input clk\n);\n\n    // ROM contents\n    reg [7:0] rom [0:255];\n\n   \n    always @(posedge clk) begin\n        if (ce0) begin\n            q0 <= rom[addr0];\n        end\n    end\n\nendmodule",
        "module_name": "counter #",
        "module_hash": "82a4662408611edd4e25e6dfa5b077db",
        "dataset_index": 9212
      },
      "ripple_shift_1f1580d6": {
        "rtl_code": "\nmodule ripple_shift (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    output [3:0] sum,\n    output cout,\n    output [2:0] out,\n    output [2:0] xor_result\n);\n\n    // Ripple Carry Adder\n    wire [3:0] ripple_sum;\n    wire ripple_cout;\n    ripple_adder ripple_adder_inst(.A(A), .B(B), .cin(cin), .sum(ripple_sum), .cout(ripple_cout));\n\n    // Shift Register\n    reg [2:0] shift_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 3'b0;\n        end else if (parallel_load != 3'b0) begin\n            shift_reg <= parallel_load;\n        end else if (shift) begin\n            if (control) begin\n                shift_reg <= {shift_reg[1:0], 1'b0};\n            end else begin\n                shift_reg <= {1'b0, shift_reg[2:1]};\n            end\n        end\n    end\n\n    // XOR Module\n    assign xor_result = ripple_sum ^ shift_reg;\n\n    // Output Assignments\n    assign sum = ripple_sum;\n    assign cout = ripple_cout;\n    assign out = shift_reg ^ ripple_sum;\n\nendmodule\nmodule ripple_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [3:0] full_sum;\n    wire carry1, carry2, carry3;\n\n    assign {carry1, full_sum[0]} = A[0] + B[0] + cin;\n    assign {carry2, full_sum[1]} = A[1] + B[1] + carry1;\n    assign {carry3, full_sum[2]} = A[2] + B[2] + carry2;\n    assign {cout, full_sum[3]} = A[3] + B[3] + carry3;\n\n    assign sum = full_sum;\n\nendmodule",
        "module_name": "ripple_shift",
        "module_hash": "1f1580d6cb6e7f0eb05a6040a91afa8b",
        "dataset_index": 835
      },
      "pipeline_splitter_fc581f70": {
        "rtl_code": "module pipeline_splitter (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    input wire clk\n);\n\nwire [15:0] stage1_out;\nwire [7:0] stage2_out;\n\npipeline_stage1 stage1(.in(in), .clk(clk), .out(stage1_out));\npipeline_stage2 stage2(.in(stage1_out[7:0]), .clk(clk), .out(stage2_out));\n\nassign out_hi = stage2_out;\nassign out_lo = stage1_out[15:8];\n\nendmodule\n\nmodule pipeline_stage1 (\n    input wire [15:0] in,\n    input wire clk,\n    output reg [15:0] out\n);\n\nalways @ (posedge clk) begin\n    out <= in;\nend\n\nendmodule\n\nmodule pipeline_stage2 (\n    input wire [7:0] in,\n    input wire clk,\n    output reg [7:0] out\n);\n\nalways @ (posedge clk) begin\n    out <= in;\nend\n\nendmodule",
        "module_name": "pipeline_splitter",
        "module_hash": "fc581f703c70f31954b3c669401eed78",
        "dataset_index": 851
      },
      "multiplier_30308bef": {
        "rtl_code": "module multiplier (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [7:0] result\n);\n    \n    reg [7:0] temp;\n    reg [3:0] i, j;\n    \n    always @(*) begin\n        temp = 8'b0;\n        for (i = 0; i < 4; i = i + 1) begin\n            for (j = 0; j < 4; j = j + 1) begin\n                if ((a[i] == 1) && (b[j] == 1)) begin\n                    temp[i+j] = temp[i+j] + 1;\n                end\n            end\n        end\n        \n        for (i = 0; i < 7; i = i + 1) begin\n            if (temp[i] == 2) begin\n                temp[i] = 0;\n                temp[i+1] = temp[i+1] + 1;\n            end\n        end\n    end\n    \n    always @* begin\n        result = temp;\n    end\nendmodule",
        "module_name": "multiplier",
        "module_hash": "30308befa004038a9cd70d87cd897ac0",
        "dataset_index": 7654
      },
      "sky130_fd_sc_hvl__a21oi_beb96dc1": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__a21oi",
        "module_hash": "beb96dc1fb24c285f73d198298a7aa37",
        "dataset_index": 23875
      },
      "comparator_4bit_f8c81419": {
        "rtl_code": "module comparator_4bit (\n    input [3:0] in_a,\n    input [3:0] in_b,\n    input clk,\n    output eq,\n    output gt,\n    output lt\n);\n\nreg [3:0] a_reg, b_reg;\nreg eq_reg, gt_reg, lt_reg;\n\nalways @(posedge clk) begin\n    a_reg <= in_a;\n    b_reg <= in_b;\nend\n\nalways @(posedge clk) begin\n    if (a_reg == b_reg) begin\n        eq_reg <= 1'b1;\n        gt_reg <= 1'b0;\n        lt_reg <= 1'b0;\n    end else if (a_reg > b_reg) begin\n        eq_reg <= 1'b0;\n        gt_reg <= 1'b1;\n        lt_reg <= 1'b0;\n    end else begin\n        eq_reg <= 1'b0;\n        gt_reg <= 1'b0;\n        lt_reg <= 1'b1;\n    end\nend\n\nassign eq = eq_reg;\nassign gt = gt_reg;\nassign lt = lt_reg;\n\nendmodule",
        "module_name": "comparator_4bit",
        "module_hash": "f8c8141926f09573dd7b1d228a19c63f",
        "dataset_index": 3194
      },
      "karnaugh_map_ef45779b": {
        "rtl_code": "module karnaugh_map(\n  input wire A, B, C, D, E,\n  output reg F\n);\n\nalways @(*) begin\n  case ({A,B,C,D,E})\n    5'b00000: F = 1;\n    5'b00001: F = 0;\n    5'b00011: F = 0;\n    5'b00010: F = 0;\n    5'b00110: F = 0;\n    5'b00111: F = 1;\n    5'b00101: F = 1;\n    5'b00100: F = 0;\n    5'b01100: F = 0;\n    5'b01101: F = 1;\n    5'b01111: F = 1;\n    5'b01110: F = 1;\n    5'b01010: F = 1;\n    5'b01011: F = 1;\n    5'b01001: F = 1;\n    5'b01000: F = 0;\n    5'b11000: F = 1;\n    5'b11001: F = 0;\n    5'b11011: F = 0;\n    5'b11010: F = 0;\n    5'b11110: F = 1;\n    5'b11111: F = 1;\n    5'b11101: F = 0;\n    5'b11100: F = 0;\n    5'b10100: F = 0;\n    5'b10101: F = 0;\n    5'b10111: F = 0;\n    5'b10110: F = 0;\n    5'b10010: F = 1;\n    5'b10011: F = 1;\n    5'b10001: F = 0;\n    5'b10000: F = 0;\n    default: F = 0;\n  endcase\nend\n\nendmodule",
        "module_name": "karnaugh_map",
        "module_hash": "ef45779bff30d6a85d4b39b18587784e",
        "dataset_index": 722
      },
      "and_gate_86929f13": {
        "rtl_code": "module and_gate (\n  input a,\n  input b,\n  input rst,\n  output out\n);\n\n  reg out_reg;\n\n  always @(a, b, rst) begin\n    if (rst == 1'b0) begin\n      out_reg <= 1'b0;\n    end else begin\n      out_reg <= a & b;\n    end\n  end\n\n  assign out = out_reg;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "86929f13460f9b0d9316ce712c8669b1",
        "dataset_index": 6804
      },
      "DispScan_f031f7bb": {
        "rtl_code": "module DispScan\n(\n\tinput clk,en,\n\tinput [3:0]in0,in1,in2,in3,\n\tinput indip,\n\toutput reg [3:0]select,out,\n\toutput reg outdip\n);\n\n\treg\t\t[1:0]state;\n\n\tlocalparam S0 = 0, S1 = 1, S2 = 2, S3 = 3;\n\n\talways @ (state or en) \n\tbegin\n\t\tif (en)\n\t\t\tbegin\n\t\t\tcase (state)\n\t\t\t\tS0:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b0001;\n\t\t\t\t\t\tout[3:0] <= in0[3:0];\n\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\n\t\t\t\tS1:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b0010;\n\t\t\t\t\t\tout[3:0] <= in1[3:0];\n\t\t\t\t\t\tif(indip)\n\t\t\t\t\t\t   outdip <= 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\t\n\t\t\t\tS2:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b0100;\n\t\t\t\t\t\tout[3:0] <= in2[3:0];\n\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\n\t\t\t\tS3:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b1000;\n\t\t\t\t\t\tout[3:0] <= in3[3:0];\n\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\n\t\t\t\tdefault:\n\t\t\t\t\t{out, outdip} = 5'b00000;\n\t\t\tendcase\n\t\t\tend\n\t\telse\n\t\t\t{select, outdip} <= 5'b00000;\n\tend\n\n\talways @ (posedge clk) begin\n\t\tcase (state)\n\t\t\tS0:\n\t\t\t\tstate <= S1;\n\t\t\tS1:\n\t\t\t\tstate <= S2;\n\t\t\tS2:\n\t\t\t\tstate <= S3;\n\t\t\tS3:\n\t\t\t\tstate <= S0;\n\t\tendcase\n\tend\nendmodule\n",
        "module_name": "DispScan",
        "module_hash": "f031f7bb213c17e2ed933f440e692780",
        "dataset_index": 23743
      },
      "sky130_fd_sc_ls__o2111a_f0a3eba5": {
        "rtl_code": "module sky130_fd_sc_ls__o2111a (\n    //# {{data|Data Signals}}\n    input  A1,\n    input  A2,\n    input  B1,\n    input  C1,\n    input  D1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Intermediate signals\n    wire and1_out;\n    wire and2_out;\n    wire and3_out;\n    wire and4_out;\n    wire or1_out;\n\n    // AND gates\n    and and1 (and1_out, A1, A2);\n    and and2 (and2_out, B1, C1);\n    and and3 (and3_out, C1, D1);\n    and and4 (and4_out, and1_out, and2_out, and3_out);\n\n    // OR gate\n    or or1 (X, and4_out);\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__o2111a",
        "module_hash": "f0a3eba5fa0bbf95c58dcec5d9961c5f",
        "dataset_index": 3422
      },
      "aurora_201_CHANNEL_ERROR_DETECT_fabbd8c9": {
        "rtl_code": "\n\nmodule aurora_201_CHANNEL_ERROR_DETECT\n(\n    SOFT_ERROR,\n    HARD_ERROR,\n    LANE_UP,\n\n\n    USER_CLK,\n    POWER_DOWN,\n\n    CHANNEL_SOFT_ERROR,\n    CHANNEL_HARD_ERROR,\n\n\n    RESET_CHANNEL\n);\n\n`define DLY #1\n\n\ninput              SOFT_ERROR;\n    input              HARD_ERROR;\n    input              LANE_UP;\n\n\n    input              USER_CLK;\n    input              POWER_DOWN;\n\n    output             CHANNEL_SOFT_ERROR;\n    output             CHANNEL_HARD_ERROR;\n\n\n    output             RESET_CHANNEL;\n\n\nreg                CHANNEL_SOFT_ERROR;\n    reg                CHANNEL_HARD_ERROR;\n    reg                RESET_CHANNEL;\n\n\nreg                soft_error_r;\n    reg                hard_error_r;\n\n\nwire               channel_soft_error_c;\n    wire               channel_hard_error_c;\n    wire               reset_channel_c;\n\n\nalways @(posedge USER_CLK)\n    begin\n        soft_error_r    <=  `DLY    SOFT_ERROR;\n        hard_error_r    <=  `DLY    HARD_ERROR;\n    end\n\n\n\n    initial\n        CHANNEL_SOFT_ERROR = 1'b1;\n\n    assign channel_soft_error_c = soft_error_r;\n\n    always @(posedge USER_CLK)\n        CHANNEL_SOFT_ERROR  <=  `DLY    channel_soft_error_c;\n\n\n\n    initial\n        CHANNEL_HARD_ERROR = 1'b1;\n\n    assign channel_hard_error_c = hard_error_r;\n\n    always @(posedge USER_CLK)\n        CHANNEL_HARD_ERROR  <=  `DLY    channel_hard_error_c;\n\n\n\n\n    initial\n        RESET_CHANNEL   =  1'b1;\n\n    assign reset_channel_c = !LANE_UP;\n\n    always @(posedge USER_CLK)\n        RESET_CHANNEL    <=  `DLY    reset_channel_c | POWER_DOWN;\n\nendmodule\n",
        "module_name": "aurora_201_CHANNEL_ERROR_DETECT",
        "module_hash": "fabbd8c9754fbdf1207d78bc72277cfb",
        "dataset_index": 23828
      },
      "binary_counter_545dccbb": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "545dccbb3e032c47a24d2273aeabfd67",
        "dataset_index": 3846
      },
      "DelayLoop_c898e7ac": {
        "rtl_code": "module DelayLoop(Clear, Timeout, CLOCK);\n    input Clear, CLOCK;\n    output reg Timeout;\n    parameter COUNT_MAX = 100; //change this value to change the delay time\n    \n    reg [7:0] count;\n    \n    always @(posedge CLOCK) begin\n        if(Clear) begin\n            count <= 0;\n            Timeout <= 0;\n        end\n        else begin\n            if(count == COUNT_MAX) begin\n                count <= 0;\n                Timeout <= 1;\n            end\n            else begin\n                count <= count + 1;\n                Timeout <= 0;\n            end\n        end\n    end\nendmodule",
        "module_name": "DelayLoop",
        "module_hash": "c898e7ac7756568f160c328b49b6d378",
        "dataset_index": 10059
      },
      "my_logic_gate_21de8a3a": {
        "rtl_code": "\nmodule my_logic_gate (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1 \n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n\n\n    wire and1;\n    wire and2;\n    wire or1;\n\n    and base(\n        .Y(and1),\n        .A(A1),\n        .B(A2),\n        .C(B1),\n        .D(C1),\n        .E(D1)\n    );\n\n    and and_gate1(\n        .Y(and2),\n        .A(B1),\n        .B(C1),\n        .C(D1)\n    );\n\n    or or_gate1(\n        .Y(Y),\n        .A(and1),\n        .B(and2)\n    );\n\nendmodule",
        "module_name": "my_logic_gate",
        "module_hash": "21de8a3ad1a26003e6c3219a4d49a808",
        "dataset_index": 2935
      },
      "modbus_7723d332": {
        "rtl_code": "module modbus (\n  input clk,\n  input rst,\n  input en,\n  input [7:0] addr,\n  input [7:0] data_in,\n  output [7:0] data_out,\n  output done\n);\n\nparameter is_master = 1; // set to 1 for master and 0 for slave\n\nreg [7:0] reg_addr;\nreg [7:0] reg_data;\nreg [7:0] request;\nreg [7:0] response;\nreg [2:0] state;\nreg done;\n\nassign data_out = response;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    state <= 0;\n    done <= 0;\n  end else if (en) begin\n    case (state)\n      0: begin // idle\n        if (is_master) begin\n          state <= 1;\n          request <= {addr, 0, reg_addr, reg_data}; // read holding register\n        end else begin\n          if (addr == request[0]) begin\n            case (request[1])\n              3: begin // read holding register\n                state <= 1;\n              end\n              default: begin\n                state <= 0;\n              end\n            endcase\n          end\n        end\n      end\n      1: begin // send request\n        if (is_master) begin\n          state <= 2;\n        end else begin\n          response <= {addr, request[1], reg_data};\n          state <= 0;\n          done <= 1;\n        end\n      end\n      2: begin // wait for response\n        if (is_master) begin\n          state <= 3;\n        end else begin\n          state <= 0;\n        end\n      end\n      3: begin // receive response\n        if (is_master) begin\n          response <= data_in;\n          state <= 0;\n          done <= 1;\n        end else begin\n          reg_data <= data_in;\n          response <= {addr, request[1], reg_data};\n          state <= 0;\n          done <= 1;\n        end\n      end\n      default: begin\n        state <= 0;\n      end\n    endcase\n  end\nend\n\nendmodule",
        "module_name": "modbus",
        "module_hash": "7723d3327e3e03761b9e9417ea56cd81",
        "dataset_index": 12445
      },
      "top_module_be4c1188": {
        "rtl_code": "module top_module(\n    input [4:0] in,\n    input select,\n    output out_and,\n    output out_or,\n    output out_nor\n);\n\nwire [3:0] decoder_out;\nwire en_and, en_or, en_nor;\n\ndecoder_2to4_with_enable dec(\n    .in(in[1:0]),\n    .enable(select),\n    .out(decoder_out)\n);\n\nand_gate_5input and_gate(\n    .in(in),\n    .enable(en_and),\n    .out(out_and)\n);\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(en_or),\n    .out(out_or)\n);\n\nnor_gate_5input nor_gate(\n    .in(in),\n    .enable(en_nor),\n    .out(out_nor)\n);\n\nassign en_and = decoder_out[0];\nassign en_or = decoder_out[1];\nassign en_nor = decoder_out[2];\n\nendmodule\n\nmodule decoder_2to4_with_enable(\n    input [1:0] in,\n    input enable,\n    output [3:0] out\n);\n\nwire [3:0] dec_out;\n\ndecoder_2to4 dec(\n    .in(in),\n    .out(dec_out)\n);\n\nassign out = enable ? dec_out : 4'b0000;\n\nendmodule\n\nmodule decoder_2to4(\n    input [1:0] in,\n    output [3:0] out\n);\n\nassign out = 4'b0001 << in;\n\nendmodule\n\nmodule and_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] & in[1] & in[2] & in[3] & in[4]) : 1'b0;\n\nendmodule\n\nmodule or_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] | in[1] | in[2] | in[3] | in[4]) : 1'b0;\n\nendmodule\n\nmodule nor_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nwire or_out;\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(enable),\n    .out(or_out)\n);\n\nassign out = ~or_out;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "be4c1188e2ee86cdd6397ce1d1cfa386",
        "dataset_index": 9081
      },
      "SUB_1 #_6512f9ce": {
        "rtl_code": "\nmodule SUB_1 #(parameter N = 32)(\n    input [N-1:0] A, B,\n    output [N:0] D\n);\n\n    wire CO;\n\n    assign D[N] = ~CO;\n\n    ADD #(\n        .N(N)\n    )\n    ADD_\n    (\n        .A(A),\n        .B(~B),\n        .CI(1'b1),\n        .S(D[N-1:0]), \n        .CO(CO)\n    );\n\nendmodule\nmodule ADD #(parameter N = 32)(\n    input [N-1:0] A, B,\n    input CI,\n    output [N-1:0] S,\n    output CO\n);\n\n    assign {CO, S} = A + B + CI;\n\nendmodule",
        "module_name": "SUB_1 #",
        "module_hash": "6512f9ce17fc6e5e1e46d9aa6bcc12af",
        "dataset_index": 20067
      },
      "audio_shifter_2e1514dd": {
        "rtl_code": "module audio_shifter(\n  input  wire           clk,    //32MHz\n  input  wire           nreset,\n  input  wire           mix,\n  input  wire [ 15-1:0] rdata,\n  input  wire [ 15-1:0] ldata,\n  input  wire           exchan,\n  output wire           aud_bclk,\n  output wire           aud_daclrck,\n  output wire           aud_dacdat,\n  output wire           aud_xck\n);\n\n  // L-R mixer\n  wire [ 16-1:0] rdata_mix;\n  wire [ 16-1:0] ldata_mix;\n\n  assign rdata_mix = {rdata[14], rdata} + {{2{ldata[14]}}, ldata[14:1]};\n  assign ldata_mix = {ldata[14], ldata} + {{2{rdata[14]}}, rdata[14:1]};\n\n  // data mux\n  reg [16-1:0] rdata_mux;\n  reg [16-1:0] ldata_mux;\n\n  always @ (posedge clk) begin\n    rdata_mux <= mix ? rdata_mix : {rdata, rdata[13]};\n    ldata_mux <= mix ? ldata_mix : {ldata, ldata[13]};\n  end\n\n  // audio output shifter\n  reg  [  9-1:0] shiftcnt;\n  reg  [ 16-1:0] shift;\n\n  always @(posedge clk, negedge nreset) begin\n    if(~nreset)\n      shiftcnt <= 9'd0;\n    else\n      shiftcnt <= shiftcnt - 9'd1;\n  end\n\n  always @ (posedge clk) begin\n    if(~|shiftcnt[2:0]) begin\n      if (~|shiftcnt[6:3])\n        shift <= {shift[14:0], rdata_mux[0]} ^ (exchan ? 17'b10000000000000000 : 17'b00000000000000000);\n      else\n        shift <= {shift[14:0], 1'b0};\n    end\n  end\n\n  // output\n  assign aud_daclrck = shiftcnt[7];\n  assign aud_bclk    = ~shiftcnt[2];\n  assign aud_xck     = shiftcnt[0];\n  assign aud_dacdat  = shift[15];\n\nendmodule",
        "module_name": "audio_shifter",
        "module_hash": "2e1514ddf51c6f8b193443f4d91e4083",
        "dataset_index": 8664
      },
      "my_uart_rx8to8_8629a30e": {
        "rtl_code": "\nmodule my_uart_rx8to8(\n\tclk,\n\trst_n,\n\tuart_ctl,\n\trs_rx,\n\t\n\tdata_in,\n\tdata_sign\n    );\n\t\n\tinput \tclk;\n\tinput\trst_n;\n\tinput\t[2:0]\tuart_ctl;\n\tinput\trs_rx;\n\t\n\toutput [7:0]\tdata_in;\n\toutput data_sign;\n\t\n\tparameter \tbps9600_2 \t= 13'd2604,\n\t\t\t\tbps19200_2\t= 13'd1301,\n\t\t\t\tbps38400_2\t= 13'd650,\n\t\t\t\tbps57600_2\t= 13'd433,\n\t\t\t\tbps115200_2 = 13'd217,  \n\t\t\t\tbps256000_2 = 13'd97; \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tparameter\tIDLE = 2'b01,\n\t\t\t\tTRAN = 2'b10;\n\t\t\t\t\n\t\n\treg\t[1:0]\tstate;\n\t\n\treg\t\t\tbps_sel, sign_sel;\n\t\n\treg\t[12:0]\tcnt;\n\t\n\treg\t[4:0]\ttran_cnt;\n\t\n\treg\t[7:0]\tdata_in;\n\treg\t\t\tdata_sign;\n\t\n\twire\t\trecv_comp;\n\t\n\tassign recv_comp = (tran_cnt == 19 && bps_sel);\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tstate <= IDLE;\n\t\tend\n\t\telse begin\n\t\t\t\n\t\t\tcase(state)\n\t\t\t\tIDLE :  state <= ~rs_rx ? TRAN : IDLE;\n\t\t\t\tTRAN :  state <= recv_comp ? IDLE : TRAN;\n\t\t\t\tdefault: state <= IDLE;\n\t\t\tendcase\n\t\t\t\n\t\t\t\n\t\tend\n\tend\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tbps_sel <= 1'b0;\n\t\t\tsign_sel <= 1'b0;\n\t\t\tcnt <= 'h0;\n\t\t\ttran_cnt <= 'h0;\n\t\tend\n\t\telse begin\n\t\t\tif(state == TRAN ) begin\n\t\t\t\tcase(uart_ctl)\n\t\t\t\t\t3'h0: if(cnt == bps9600_2) begin \n\t\t\t\t\t       cnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\t bps_sel <= ~sign_sel; \n\t\t\t\t\t\t\t sign_sel <= ~sign_sel; \n\t\t\t\t\t\t\t tran_cnt <=  tran_cnt + 1'b1;  \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t3'h1: if(cnt == bps19200_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1;  \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t3'h2: if(cnt == bps38400_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t  cnt <=  cnt + 1'b1; \n\t\t\t\t\t\t  bps_sel <= 1'b0; \n\t\t\t\t\t\t  end\n\t\t\t\t\t3'h3: if(cnt == bps57600_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse \tbegin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t3'h4: if(cnt == bps115200_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; end\n\t\t\t\t\t3'h5: if(cnt == bps256000_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t  cnt <=  cnt + 1'b1; \n\t\t\t\t\t\t  bps_sel <= 1'b0; \n\t\t\t\t\t\t  end\n\t\t\t\t\tdefault: begin \n\t\t\t\t\t\t\t\tcnt <= 'h0; \n\t\t\t\t\t\t\t\ttran_cnt <=  0; \n\t\t\t\t\t\t\t\tbps_sel <= 'h0; \n\t\t\t\t\t\t\t\tsign_sel <= 'h0; \n\t\t\t\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\telse  begin \n\t\t\t\tcnt <= 'h0; \n\t\t\t\tsign_sel <= 'h0; \n\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\ttran_cnt <= 'h0; \n\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\tend\n\t\t\t\n\t\tend\n\tend\n\t\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdata_in <= 'h0;\n\t\t\tdata_sign <= 'h0;\n\t\tend\n\t\telse begin\n\t\t\tif(bps_sel)begin\n\t\t\t\tif(tran_cnt > 2 && tran_cnt <= 18) data_in[tran_cnt[4:1] - 1] <= rs_rx;\n\t\t\t\t data_sign <= (tran_cnt == 19 ) ? 1'b1 : 1'b0;\n\t\t\tend\n\t\t\telse \tdata_sign <= 1'b0;\n\t\t\t\n\t\tend\n\tend\n\t\n\t\n\t\n\nendmodule\n",
        "module_name": "my_uart_rx8to8",
        "module_hash": "8629a30e9f4230ea37429f4385b6f05a",
        "dataset_index": 22639
      },
      "multiplier_block_70df4e14": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w32,\n    w31,\n    w256,\n    w257,\n    w2056,\n    w2025;\n\n  assign w1 = i_data0;\n  assign w32 = w1 << 5;\n  assign w31 = w32 - w1;\n  assign w256 = w1 << 8;\n  assign w257 = w1 + w256;\n  assign w2056 = w257 << 3;\n  assign w2025 = w2056 - w31;\n\n  assign o_data0 = w2025;\n\n  //multiplier_block area estimate = 5631.59510674265;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "70df4e14ba1bf6f672d4a76bbc4e3694",
        "dataset_index": 12215
      },
      "dcr_if_4c4ee117": {
        "rtl_code": "\n\nmodule dcr_if(\n  clk,           rst,           DCR_ABus,      DCR_DBusIn,    DCR_Read,      DCR_Write,     DCR_Ack,       DCR_DBusOut,   tft_base_addr, tft_dps_reg,   tft_on_reg     );\n\ninput         clk;\n  input         rst;\n  input  [0:9]  DCR_ABus;\n  input  [0:31] DCR_DBusIn;\n  input         DCR_Read;\n  input         DCR_Write;\n  output        DCR_Ack;\n  output [0:31] DCR_DBusOut;\n  output [0:10] tft_base_addr;\n  output        tft_dps_reg;\n  output        tft_on_reg;\n  wire   [0:31] DCR_DBusOut;\n  reg           DCR_Ack;\n\nparameter C_DCR_BASE_ADDR = 10'b00_0000_0000;\n  parameter C_DEFAULT_TFT_BASE_ADDR = 31'b0000_0000_0000_0000_0000_0000_0000_0000;\n  parameter C_DPS_INIT = 1'b1;\n  parameter C_ON_INIT = 1'b1;\n\nwire        dcr_addr_hit;\n  wire [0:9]  dcr_base_addr;\n  reg         dcr_read_access;\n  reg  [0:31] read_data;\n  reg  [0:10] tft_base_addr;\n  reg         tft_dps_reg;\n  reg         tft_on_reg;\n\nassign dcr_base_addr = C_DCR_BASE_ADDR;\n  assign dcr_addr_hit  = (DCR_ABus[0:8] == dcr_base_addr[0:8]);\n\n  always @(posedge clk)\n  begin\n    dcr_read_access <=  DCR_Read              & dcr_addr_hit;\n    DCR_Ack         <= (DCR_Read | DCR_Write) & dcr_addr_hit;\n  end\n\n  always @(posedge clk)\n    if (rst)\n      tft_base_addr <= C_DEFAULT_TFT_BASE_ADDR[31:21]; \n    else if (DCR_Write & ~DCR_Ack & dcr_addr_hit & (DCR_ABus[9] == 1'b0))\n      tft_base_addr <= DCR_DBusIn[0:10];\n\n  always @(posedge clk)\n    if (rst) begin\n      tft_dps_reg <= C_DPS_INIT;\n      tft_on_reg  <= C_ON_INIT;\n    end\n    else if (DCR_Write & ~DCR_Ack & dcr_addr_hit & (DCR_ABus[9] == 1'b1)) begin\n      tft_dps_reg <= DCR_DBusIn[30];\n      tft_on_reg  <= DCR_DBusIn[31];\n    end\n\n  always @(posedge clk)\n    if (DCR_Read & dcr_addr_hit & ~DCR_Ack)\n      read_data <= (DCR_ABus[9] == 1'b0)? {tft_base_addr, 21'b0} :\n                                          {30'b0, tft_dps_reg, tft_on_reg};\n\n  assign DCR_DBusOut = (dcr_read_access)? read_data : DCR_DBusIn;\n\nendmodule\n",
        "module_name": "dcr_if",
        "module_hash": "4c4ee1170f51f3413531f4ed36aac5a4",
        "dataset_index": 24213
      },
      "barrel_shift_3bit_reg_and_gate_f5acda99": {
        "rtl_code": "module barrel_shift_3bit_reg_and_gate (\n    input clk,\n    input [3:0] data_in,\n    input [1:0] shift_amount,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    output [2:0] out\n);\n\n    // 4-bit Barrel Shifter\n    reg [3:0] shifted_data;\n    always @(*) begin\n        case(shift_amount)\n            2'b00: shifted_data = data_in;\n            2'b01: shifted_data = {data_in[3], data_in[0:2]};\n            2'b10: shifted_data = {data_in[2:3], data_in[0:1]};\n            2'b11: shifted_data = {data_in[1:3], data_in[0]};\n            default: shifted_data = 4'b0000;\n        endcase\n    end\n\n    // 3-bit Shift Register\n    reg [2:0] reg_data;\n    always @(posedge clk) begin\n        if(shift) begin\n            if(control) reg_data <= {reg_data[1:0], 1'b0};\n            else reg_data <= {1'b0, reg_data[2:1]};\n        end\n        else if(parallel_load != 3'b111) begin\n            reg_data <= parallel_load;\n        end\n    end\n\n    // AND Gate\n    assign out = shifted_data & reg_data;\n\nendmodule",
        "module_name": "barrel_shift_3bit_reg_and_gate",
        "module_hash": "f5acda993b5c8836025a1af792f67870",
        "dataset_index": 8578
      },
      "debouncer_115c1999": {
        "rtl_code": "module debouncer (\n  input clock,\n  input signal_in,\n  output reg signal_out\n);\n\nparameter debounce_time = 10; // time (in clock cycles) to debounce input signal\n\nreg [debounce_time-1:0] stable_count; // counter to track stable input signal\n\nalways @(posedge clock) begin\n  if (signal_in == signal_out) begin\n    stable_count <= stable_count + 1;\n    if (stable_count == debounce_time) begin\n      signal_out <= signal_in;\n      stable_count <= 0;\n    end\n  end else begin\n    signal_out <= signal_in;\n    stable_count <= 0;\n  end\nend\n\nendmodule",
        "module_name": "debouncer",
        "module_hash": "115c1999278ad8d15a3635f5236aad4d",
        "dataset_index": 16225
      },
      "NOR4X0_8df7bf1e": {
        "rtl_code": "module NOR4X0 (input IN1, IN2, IN3, IN4, output QN, input VDD, VSS);\n\n  wire n1, n2, n3;\n\n  assign n1 = ~(IN1 | IN2);\n  assign n2 = ~(IN3 | IN4);\n  assign n3 = ~(n1 | n2);\n\n  assign QN = n3;\n\nendmodule",
        "module_name": "NOR4X0",
        "module_hash": "8df7bf1e8bf3df0ebd6dda923c7db89e",
        "dataset_index": 4954
      },
      "xor_const_f37f87ae": {
        "rtl_code": "module xor_const(\n    input [31:0] in,\n    output [31:0] out\n);\n\nparameter CONST = 32'hAAAAAAAA;\n\nassign out = in ^ CONST;\n\nendmodule",
        "module_name": "xor_const",
        "module_hash": "f37f87ae2d63a16f7705316cf08d9614",
        "dataset_index": 9522
      },
      "bitwise_or_logical_or_b44b3d8a": {
        "rtl_code": "\nmodule bitwise_or_logical_or(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = (a != 0) || (b != 0);\n    assign out_not = ~{a, b};\n\nendmodule\nmodule and_or_xor(\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    wire [49:0] and_out;\n    wire [49:0] or_out;\n    wire [98:0] xor_out;\n\n    genvar i;\n    generate\n        for (i = 0; i < 50; i = i + 1) \n            and_gate and_inst(\n            .a(in[i*2]),\n            .b(in[i*2+1]),\n            .y(and_out[i])\n        );\n\n        for (i = 0; i < 50; i = i + 1) \n            or_gate or_inst(\n            .a(in[i*2]),\n            .b(in[i*2+1]),\n            .y(or_out[i])\n        );\n\n        for (i = 0; i < 99; i = i + 1) \n            xor_gate xor_inst(\n            .a(in[i]),\n            .b(in[i+1]),\n            .y(xor_out[i])\n        );\n    endgenerate\n\n    assign out_and = &and_out;\n    assign out_or = |or_out;\n    assign out_xor = ^xor_out;\n\nendmodule\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output [2:0] final_output\n);\n\n    bitwise_or_logical_or bitwise_or_logical_or_inst(\n        .a(a),\n        .b(b),\n        .out_or_bitwise(out_or_bitwise),\n        .out_or_logical(out_or_logical),\n        .out_not(out_not)\n    );\n\n    and_or_xor and_or_xor_inst(\n        .in(in),\n        .out_and(out_and),\n        .out_or(out_or),\n        .out_xor(out_xor)\n    );\n\n    assign final_output = out_or_bitwise + out_or_bitwise;\n\nendmodule\nmodule and_gate(\n    input a,\n    input b,\n    output y\n);\n\n    assign y = a & b;\n\nendmodule\nmodule or_gate(\n    input a,\n    input b,\n    output y\n);\n\n    assign y = a | b;\n\nendmodule\nmodule xor_gate(\n    input a,\n    input b,\n    output y\n);\n\n    assign y = a ^ b;\n\nendmodule",
        "module_name": "bitwise_or_logical_or",
        "module_hash": "b44b3d8a9e1a41a2781fb3d92626b310",
        "dataset_index": 14640
      },
      "full_adder_eb704757": {
        "rtl_code": "\nmodule full_adder(a, b, c_in, s, c_out);\n  input a, b, c_in;\n  output s, c_out;\n  assign s = a ^ b ^ c_in;\n  assign c_out = (a & b) | (b & c_in) | (c_in & a);\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n  input [3:0] A, B;\n  input C_in;\n  output [3:0] S;\n  output C_out;\n\n  wire c1, c2, c3;\n\n  full_adder adder0(A[0], B[0], C_in, S[0], c1);\n  full_adder adder1(A[1], B[1], c1, S[1], c2);\n  full_adder adder2(A[2], B[2], c2, S[2], c3);\n  full_adder adder3(A[3], B[3], c3, S[3], C_out);\nendmodule\n",
        "module_name": "full_adder",
        "module_hash": "eb7047572df4546dff70c500fdbb8016",
        "dataset_index": 17494
      },
      "counter_e4f60940": {
        "rtl_code": "module counter (\n  input clk,\n  input areset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (areset) begin\n      count <= 4'b0;\n    end\n    else if (enable) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "counter",
        "module_hash": "e4f609402e3ad888bec7732be29ebb38",
        "dataset_index": 20383
      },
      "uart_tx_3155e5ab": {
        "rtl_code": "module uart_tx\n  #(\n    parameter DBIT = 8,\t\t\t\t// Number of data bits to receive\n    SB_TICK = 16\t\t\t// Number of ticks for the stop bit. 16 ticks=1 stop bit, 24=1.5 and 32=2.\n  )\n  ( \n    input wire clk,\n    input wire reset,\n    input wire [7:0] data_in,\n    input wire s_tick,\n    input wire tx_start,\n    output reg tx_done_tick,\n    output wire  data_out\n  );\n\n  // state declaration for the FSM\n  localparam [1:0]\n\t\tidle  = 2'b00,\n\t\tstart = 2'b01,\n\t\tdata  = 2'b10,\n\t\tstop  = 2'b11;\n\n  //\tsignal declaration\n  reg [1:0] state_reg, state_next;\n  reg [3:0] cnt_15_reg, cnt_15_next;\n  reg [2:0] cnt_8_reg, cnt_8_next;\n  reg [7:0] shift_out_reg, shift_out_next;\n  reg tx_reg, tx_next;\n\n  //\tbody\n  //\tFSM state & data registers\n  always@(posedge clk, posedge reset)\n    if (reset)\n      begin\n        state_reg <= idle;\n        cnt_15_reg <= 0;\n        cnt_8_reg <= 0;\n        shift_out_reg <= 0;\n        tx_reg <= 0;\n      end\n  else\n    begin\n      state_reg <= state_next;\n      cnt_15_reg <= cnt_15_next;\n      cnt_8_reg <= cnt_8_next;\n      shift_out_reg <= shift_out_next;\n      tx_reg <= tx_next;\n    end\n\n  //\tFSM next-state logic\n  always@*\n    begin\n      state_next = state_reg ;\n      cnt_15_next = cnt_15_reg;\n      cnt_8_next = cnt_8_reg;\n      shift_out_next = shift_out_reg;\n      tx_next = tx_reg;\n      tx_done_tick = 1'b0;\n\t\t\n      case (state_reg)\n\t\t\n        idle:\n\t\t\t begin\n\t\t\t\t tx_next = 1'b1;\n\t\t\t\t if(tx_start)\n\t\t\t\t\tbegin\n\t\t\t\t\t  state_next = start;\n\t\t\t\t\t  cnt_15_next = 0;\n\t\t\t\t\t  shift_out_next = data_in;\n\t\t\t\t\tend\n\t\t\t end\n\t\t\t\t\n        start:\n\t\t\t begin\n\t\t\t\t tx_next = 1'b0;\n\t\t\t\t if (s_tick)\n\t\t\t\t\t if(cnt_15_reg==15)\n\t\t\t\t\t   begin\n\t\t\t\t\t\t state_next=data;\n\t\t\t\t\t\t cnt_15_next=0;\n\t\t\t\t\t\t cnt_8_next=0;\n\t\t\t\t\t   end\n\t\t\t\t\t else\n\t\t\t\t\t   cnt_15_next = cnt_15_reg+1'b1;\n\t\t\t end\n\t\t\t \n        data:\n\t\t\t begin\n\t\t\t\t tx_next = shift_out_reg[0];\n\t\t\t\t if(s_tick)\n\t\t\t\t\t if(cnt_15_reg==15)\n\t\t\t\t\t   begin\n\t\t\t\t\t\t cnt_15_next=0;\n\t\t\t\t\t\t shift_out_next = shift_out_reg >> 1;\n\t\t\t\t\t\t if(cnt_8_reg==(DBIT-1))\n\t\t\t\t\t\t\t if (SB_TICK == 16)\n\t\t\t\t\t\t\t   begin\n\t\t\t\t\t\t\t\t  state_next=stop;\n\t\t\t\t\t\t\t\t  cnt_15_next=0;\n\t\t\t\t\t\t\t   end\n\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t   state_next = idle;\n\t\t\t\t\t\t else\n\t\t\t\t\t\t\tcnt_8_next=cnt_8_reg+1'b1;\n\t\t\t\t\t   end\n\t\t\t\t\t else\n\t\t\t\t\t   cnt_15_next=cnt_15_reg+1'b1;\n\t\t\t end\n\t\t\t \n        stop:\n\t\t\t begin\n\t\t\t\t tx_next = 1'b1;\n\t\t\t\t if(s_tick)\n\t\t\t\t\t if(cnt_15_reg==(SB_TICK-1))\n\t\t\t\t\t   begin\n\t\t\t\t\t\t state_next=idle;\n\t\t\t\t\t\t tx_done_tick=1'b1;\n\t\t\t\t\t   end\n\t\t\t\t\t else\n\t\t\t\t\t   cnt_15_next = cnt_15_reg+1'b1;\n\t\t\t end\n      endcase\n    end\n\n    //output\n    assign data_out = tx_reg;\n\nendmodule",
        "module_name": "uart_tx",
        "module_hash": "3155e5ab4021698e96682005813f97a4",
        "dataset_index": 915
      },
      "top__b55206de": {
        "rtl_code": "\nmodule top_module (\n    input [31:0] A,\n    input [31:0] B,\n    input [3:0] S,\n    input [2:0] OPCODE,\n    input CIN,\n    output reg COUT,\n    output reg [31:0] Y\n);\n\nreg [32:0] alu_output;\n\nalways @(*) begin\n    case(OPCODE)\n        3'b000: alu_output = A + B + CIN;\n        3'b001: alu_output = A - B - (~CIN);\n        3'b010: alu_output = A & B;\n        3'b011: alu_output = A | B;\n        3'b100: alu_output = A ^ B;\n        3'b101: alu_output = (S == 0) ? A : (A << S[3:1]);\n        3'b110: alu_output = (S == 0) ? B : (B << S[3:1]);\n        default: alu_output = 0;\n    endcase\nend\n\nalways @(*) begin\n    case(OPCODE)\n        3'b000: Y = alu_output[31:0];\n        3'b001: Y = alu_output[31:0];\n        3'b010: Y = alu_output[31:0];\n        3'b011: Y = alu_output[31:0];\n        3'b100: Y = alu_output[31:0];\n        3'b101: Y = alu_output[31:0];\n        3'b110: Y = alu_output[31:0];\n        default: Y = 0;\n    endcase\nend\n\nalways @(*) begin\n    case(OPCODE)\n        3'b000: COUT = (alu_output[32] == 1);\n        3'b001: COUT = (alu_output[32] == 0);\n        3'b010: COUT = 0;\n        3'b011: COUT = 0;\n        3'b100: COUT = 0;\n        3'b101: COUT = (S != 0) ? (B[32 - S[3:1]] == 1) : (B[S[3:1] - 1] == 1);\n        3'b110: COUT = (S != 0) ? (B[32 - S[3:1]] == 1) : (B[S[3:1] - 1] == 1);\n        default: COUT = 0;\n    endcase\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "b55206defb8a250faa0a8b414b57b143",
        "dataset_index": 20445
      },
      "add_sub_369372eb": {
        "rtl_code": "module add_sub (\n    input [15:0] A,\n    input [15:0] B,\n    input CTRL,\n    output [15:0] SUM_DIFF,\n    output CARRY_OUT_BORROW_OUT\n);\n\nreg [15:0] A_reg, B_reg, SUM_DIFF_reg;\nreg CTRL_reg;\nreg CARRY_IN_reg, BORROW_IN_reg;\nwire CARRY_OUT, BORROW_OUT;\n\nassign CARRY_OUT_BORROW_OUT = (CTRL == 0) ? CARRY_OUT : BORROW_OUT;\n\npipeline_stage1 stage1 (\n    .A(A),\n    .B(B),\n    .CTRL(CTRL),\n    .A_reg(A_reg),\n    .B_reg(B_reg),\n    .CTRL_reg(CTRL_reg),\n    .CARRY_IN_reg(CARRY_IN_reg),\n    .BORROW_IN_reg(BORROW_IN_reg)\n);\n\npipeline_stage2 stage2 (\n    .A_reg(A_reg),\n    .B_reg(B_reg),\n    .CTRL_reg(CTRL_reg),\n    .CARRY_IN_reg(CARRY_IN_reg),\n    .BORROW_IN_reg(BORROW_IN_reg),\n    .SUM_DIFF_reg(SUM_DIFF_reg),\n    .CARRY_OUT(CARRY_OUT),\n    .BORROW_OUT(BORROW_OUT)\n);\n\npipeline_stage3 stage3 (\n    .SUM_DIFF_reg(SUM_DIFF_reg),\n    .CARRY_OUT(CARRY_OUT),\n    .BORROW_OUT(BORROW_OUT),\n    .SUM_DIFF(SUM_DIFF)\n);\n\nendmodule\n\nmodule pipeline_stage1 (\n    input [15:0] A,\n    input [15:0] B,\n    input CTRL,\n    output reg [15:0] A_reg,\n    output reg [15:0] B_reg,\n    output reg CTRL_reg,\n    output reg CARRY_IN_reg,\n    output reg BORROW_IN_reg\n);\n\nalways @(A, B, CTRL) begin\n    A_reg <= A;\n    B_reg <= B;\n    CTRL_reg <= CTRL;\n    CARRY_IN_reg <= 1'b0;\n    BORROW_IN_reg <= 1'b0;\nend\n\nendmodule\n\nmodule pipeline_stage2 (\n    input [15:0] A_reg,\n    input [15:0] B_reg,\n    input CTRL_reg,\n    input CARRY_IN_reg,\n    input BORROW_IN_reg,\n    output reg [15:0] SUM_DIFF_reg,\n    output reg CARRY_OUT,\n    output reg BORROW_OUT\n);\n\nalways @(A_reg, B_reg, CTRL_reg, CARRY_IN_reg, BORROW_IN_reg) begin\n    if (CTRL_reg == 0) begin\n        {CARRY_OUT, SUM_DIFF_reg} <= A_reg + B_reg + CARRY_IN_reg;\n        BORROW_OUT <= (A_reg < B_reg) || ((A_reg == B_reg) && (CARRY_IN_reg == 1'b1));\n    end else begin\n        {BORROW_OUT, SUM_DIFF_reg} <= A_reg - B_reg - BORROW_IN_reg;\n        CARRY_OUT <= (A_reg >= B_reg) && ((A_reg != B_reg) || (BORROW_IN_reg == 1'b1));\n    end\nend\n\nendmodule\n\nmodule pipeline_stage3 (\n    input [15:0] SUM_DIFF_reg,\n    input CARRY_OUT,\n    input BORROW_OUT,\n    output [15:0] SUM_DIFF\n);\n\nassign SUM_DIFF = SUM_DIFF_reg;\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "369372ebf92e3168fd97ca6ab052e4ec",
        "dataset_index": 11825
      },
      "wb_bridge_16_32_3b7fd990": {
        "rtl_code": "module wb_bridge_16_32\n  #(parameter AWIDTH=16)\n    (input wb_clk, input wb_rst,\n     input A_cyc_i, input A_stb_i, input A_we_i, input [3:0] A_sel_i,\n     input [AWIDTH-1:0] A_adr_i, input [31:0] A_dat_i, output [31:0] A_dat_o, output A_ack_o,\n     output B_cyc_o, output B_stb_o, output B_we_o, output [1:0] B_sel_o,\n     output [AWIDTH-1:0] B_adr_o, output [15:0] B_dat_o, input [15:0] B_dat_i, input B_ack_i\n     );\n\n   reg [15:0] \t\t holding;\n   reg \t\t\t phase;\n   \n   assign \t\t B_adr_o = {A_adr_i[AWIDTH-1:2],phase,1'b0};\n   assign \t\t B_cyc_o = A_cyc_i;\n   assign \t\t B_stb_o = A_stb_i;\n   assign \t\t B_we_o = A_we_i;\n\n   assign \t\t B_dat_o = ~phase ? A_dat_i[15:0] : A_dat_i[31:16];\n   assign \t\t B_sel_o = ~phase ? A_sel_i[1:0] : A_sel_i[3:2];\n\n   assign \t\t A_dat_o = {B_dat_i,holding};\n   assign \t\t A_ack_o = phase & B_ack_i;\n\n   always @(posedge wb_clk)\n     if(wb_rst)\n       phase <= 0;\n     else if(B_ack_i)\n       phase <= ~phase;\n\n   always @(posedge wb_clk)\n     if(~phase & B_ack_i)\n       holding <= B_dat_i;\n   \nendmodule",
        "module_name": "wb_bridge_16_32",
        "module_hash": "3b7fd990722d0a02211046c50bd52013",
        "dataset_index": 12344
      },
      "priority_encoder_aab724d8": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @* begin\n    case(in)\n        8'b00000001: pos = 3'b000;\n        8'b00000010: pos = 3'b001;\n        8'b00000100: pos = 3'b010;\n        8'b00001000: pos = 3'b011;\n        8'b00010000: pos = 3'b100;\n        8'b00100000: pos = 3'b101;\n        8'b01000000: pos = 3'b110;\n        8'b10000000: pos = 3'b111;\n        default: pos = 3'b000;\n    endcase;\nend\n\nendmodule\nmodule barrel_shifter_mux (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\nmodule top_module (\n    input [7:0] in,\n    output [2:0] pos,\n    input wire [15:0] in2,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    input enable,\n    output reg [15:0] out_sum\n);\n\nwire [2:0] pos_wire;\n\npriority_encoder pe(\n    .in(in),\n    .pos(pos_wire)\n);\n\nbarrel_shifter_mux bsm(\n    .in(in2),\n    .out_hi(out_hi),\n    .out_lo(out_lo)\n);\n\nalways @(posedge enable) begin\n    out_sum <= {pos_wire, 3'b000} + {out_hi, out_lo};\nend\n\nassign pos = pos_wire;\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "aab724d88e62cc6ace6cec429429973d",
        "dataset_index": 13086
      },
      "split_16bit_input_3d0b441d": {
        "rtl_code": "module split_16bit_input(\n    input wire [15:0] in,\n    input wire clk,\n    output reg [7:0] out_hi,\n    output reg [7:0] out_lo\n);\n\n    reg [15:0] input_reg;\n    reg [7:0] upper_byte_reg;\n    reg [7:0] lower_byte_reg;\n\n    always @(posedge clk) begin\n        input_reg <= in;\n        upper_byte_reg <= input_reg[15:8];\n        lower_byte_reg <= input_reg[7:0];\n    end\n\n    always @* begin\n        out_hi = upper_byte_reg;\n        out_lo = lower_byte_reg;\n    end\n\nendmodule",
        "module_name": "split_16bit_input",
        "module_hash": "3d0b441d3a37de49e9a09eb816aa7da4",
        "dataset_index": 11627
      },
      "top__a951bb31": {
        "rtl_code": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] final_result\n);\n\n    // Multiplication module\n    wire [15:0] mult_result;\n    wire mult_sign;\n    multiplier_module mult_inst (\n        .a(a),\n        .b(b),\n        .result(mult_result),\n        .sign(mult_sign)\n    );\n    \n    // Ripple carry adder module\n    wire [3:0] adder_result;\n    ripple_carry_adder adder_inst (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .carry_in(1'b0),\n        .sum(adder_result)\n    );\n    \n    // Additional functional module\n    wire [4:0] sum_abs;\n    absolute_value_module abs_inst (\n        .input_sum({mult_result[15], adder_result}),\n        .output_abs(sum_abs)\n    );\n    \n    // Output final result\n    always @(*) begin\n        if (mult_sign) begin\n            final_result = -{sum_abs, 4'b0};\n        end else begin\n            final_result = {sum_abs, 4'b0};\n        end\n    end\n\nendmodule\n\n\nmodule multiplier_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg sign\n);\n\n    always @(*) begin\n        if ((a[7] == 1) && (b[7] == 1)) begin\n            result = ~(a*b) + 1;\n            sign = 1;\n        end else if ((a[7] == 0) && (b[7] == 0)) begin\n            result = a*b;\n            sign = 0;\n        end else begin\n            result = a*b;\n            sign = 1;\n        end\n    end\n\nendmodule\n\n\nmodule ripple_carry_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input carry_in,\n    output reg [3:0] sum\n);\n\n    reg carry_out;\n    \n    always @(*) begin\n        sum = a + b + carry_in;\n        carry_out = (sum > 4'b1111);\n        sum = sum & 4'b1111;\n    end\n\nendmodule\n\n\nmodule absolute_value_module (\n    input [4:0] input_sum,\n    output reg [4:0] output_abs\n);\n\n    always @(*) begin\n        if (input_sum[4] == 1) begin\n            output_abs = ~input_sum + 1;\n        end else begin\n            output_abs = input_sum;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "a951bb31141e0e0da010d98b0ecea8cd",
        "dataset_index": 11479
      },
      "up_down_counter_7485b2cf": {
        "rtl_code": "\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    output reg [3:0] count\n);\n    always @(posedge clk) begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nendmodule\nmodule binary_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\nmodule shift_and_sum (\n    input [3:0] A,\n    input [3:0] B,\n    input clk,\n    input up_down,\n    output [7:0] out\n);\n    wire [3:0] counter1_out;\n    wire [3:0] counter2_out;\n    wire [3:0] binary_adder_out;\n\n    up_down_counter counter1 (.clk(clk), .up_down(up_down), .count(counter1_out));\n    up_down_counter counter2 (.clk(clk), .up_down(up_down), .count(counter2_out));\n\n    binary_adder adder (.A(counter1_out), .B(counter2_out), .sum(binary_adder_out));\n\n    assign out = {A >> B, binary_adder_out};\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "7485b2cfc96dd5ff353dc90e7480d54c",
        "dataset_index": 9191
      },
      "Multiplexer #_560808b2": {
        "rtl_code": "module Multiplexer #(parameter INIT_VALUE = 8'hB8)\n   (input ctrl,\n    input [0:0] D0,\n    input [0:0] D1,\n    output reg [0:0] S);\n\n  wire [0:0] D0_wire;\n  wire [0:0] D1_wire;\n  wire S_wire;\n\n  assign D0_wire = D0;\n  assign D1_wire = D1;\n\n  always @*\n  begin\n    case(ctrl)\n      1'b0: S = D0_wire;\n      1'b1: S = D1_wire;\n    endcase\n  end\n\nendmodule",
        "module_name": "Multiplexer #",
        "module_hash": "560808b2ce8a84b24376746179b238e8",
        "dataset_index": 3626
      },
      "crosshair_1b074ad9": {
        "rtl_code": "\nmodule crosshair(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] hdmi_r,\n    input wire [7:0] hdmi_g,\n    input wire [7:0] hdmi_b,\n    input wire hdmi_de,\n    input wire hdmi_hs,\n    input wire hdmi_vs,\n    output reg [7:0] out_r,\n    output reg [7:0] out_g,\n    output reg [7:0] out_b,\n    output reg out_de,\n    output reg out_hs,\n    output reg out_vs\n);\n\nwire [9:0] centr_x;\nwire [9:0] centr_y;\n\nassign centr_x = 32;\nassign centr_y = 32;\n\nalways @ (posedge clk) begin\n    if (hdmi_de) begin\n        // Add crosshair overlay\n        if (centr_x == 32) begin\n            out_r <= 8'hFF;\n            out_g <= 8'h00;\n            out_b <= 8'h00;\n        end else if (centr_y == 32) begin\n            out_r <= 8'h00;\n            out_g <= 8'hFF;\n            out_b <= 8'h00;\n        end else begin\n            out_r <= hdmi_r;\n            out_g <= hdmi_g;\n            out_b <= hdmi_b;\n        end\n        out_de <= hdmi_de;\n        out_hs <= hdmi_hs;\n        out_vs <= hdmi_vs;\n    end else begin\n        // Blank output when DE is low\n        out_r <= 8'h00;\n        out_g <= 8'h00;\n        out_b <= 8'h00;\n        out_de <= 1'b0;\n        out_hs <= 1'b0;\n        out_vs <= 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "crosshair",
        "module_hash": "1b074ad9a6f73ad78c3f8a619db2a0c4",
        "dataset_index": 11104
      },
      "comparator_2bit_fc48eaa5": {
        "rtl_code": "module comparator_2bit (\n    input [1:0] A,\n    input [1:0] B,\n    output [1:0] C\n);\n\n    assign C[1] = (A[1] > B[1]) ? 1 : 0; //compare MSBs\n    assign C[0] = (A[1] == B[1]) ? ((A[0] >= B[0]) ? 1 : 0) : ((C[1] == 1) ? 0 : 1); //compare LSBs\n\nendmodule",
        "module_name": "comparator_2bit",
        "module_hash": "fc48eaa5d3e7c9efb1b32dd292295182",
        "dataset_index": 14616
      },
      "bmu_b1242a3b": {
        "rtl_code": "module bmu (cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7);\n\n   output [1:0] bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;\n\n   input  \tcx0, cx1;\n\n   reg [1:0] \tbm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;\n\n   always@ (cx0 or cx1)\n\t begin\n\t    if (cx0==0 && cx1==0)\n\t      begin\n\t        bm0 <= 2'd0; bm1 <= 2'd2; bm2 <= 2'd2; bm3 <= 2'd0; bm4 <= 2'd1; bm5 <= 2'd1; bm6 <= 2'd1; bm7 <= 2'd1; end\n\t    else if (cx0==0 && cx1==1)\n\t      begin\n\t        bm0 <= 2'd1; bm1 <= 2'd1; bm2 <= 2'd1; bm3 <= 2'd1; bm4 <= 2'd2; bm5 <= 2'd0; bm6 <= 2'd0; bm7 <= 2'd2; end\n\t    else if (cx0==1 && cx1==0)\n\t      begin\n\t        bm0 <= 2'd1; bm1 <= 2'd1; bm2 <= 2'd1; bm3 <= 2'd1; bm4 <= 2'd0; bm5 <= 2'd2; bm6 <= 2'd2; bm7 <= 2'd0; end\n\t    else begin\n\t        bm0 <= 2'd2; bm1 <= 2'd0; bm2 <= 2'd0; bm3 <= 2'd2; bm4 <= 2'd1; bm5 <= 2'd1; bm6 <= 2'd1; bm7 <= 2'd1; end\n\n\t end endmodule\n",
        "module_name": "bmu",
        "module_hash": "b1242a3bf4d3c523dde0d57b7bdbf3cc",
        "dataset_index": 924
      },
      "d_ff_ce_clr_81f3c1ec": {
        "rtl_code": "module d_ff_ce_clr(clk, d, ce, clr, q);\ninput clk, d, ce, clr;\noutput q;\nreg q;\n\nalways @(posedge clk) begin\n  if (clr) begin\n    q <= 1'b0;\n  end else if (ce) begin\n    q <= d;\n  end\nend\n\nendmodule",
        "module_name": "d_ff_ce_clr",
        "module_hash": "81f3c1ec9d7c43e0a17937a5a8ac1eeb",
        "dataset_index": 2711
      },
      "four_bit_adder_1412c61e": {
        "rtl_code": "module four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input clk,\n  output [3:0] S,\n  output Cout\n);\n\n  assign S = A + B + Cin;\n  assign Cout = (A[3] & B[3]) | (A[3] & Cin) | (B[3] & Cin);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "1412c61eb0dfd59b5fb83f50e38f6aa5",
        "dataset_index": 9447
      },
      "db_lut_tc_677498a5": {
        "rtl_code": "module db_lut_tc( qp_i,mb_type_i,tc_o );\n\ninput  [5:0] qp_i\t\t;\ninput        mb_type_i\t;\n\noutput [4:0] tc_o\t\t; \nreg    [4:0] tc_o\t\t;\n\nwire [5:0] qp_w = qp_i + {mb_type_i,1'b0};\n\nalways @(qp_w) begin\n    case(qp_w)\n\t\t'd18: tc_o  =  5'd1 ;\n        'd19: tc_o  =  5'd1 ;\n\t\t'd20: tc_o  =  5'd1;\n\t\t'd21: tc_o  =  5'd1;\n\t\t'd22: tc_o  =  5'd1;\n\t\t'd23: tc_o  =  5'd1;\n\t\t'd24: tc_o  =  5'd1;\n\t\t'd25: tc_o  =  5'd1;\n\t\t'd26: tc_o  =  5'd1;\n\t\t'd27: tc_o  =  5'd2;\n\t\t'd28: tc_o  =  5'd2;\n\t\t'd29: tc_o  =  5'd2;\t\t\n\t\t'd30: tc_o  =  5'd2;\n\t\t'd31: tc_o  =  5'd3;\n\t\t'd32: tc_o  =  5'd3;\n\t\t'd33: tc_o  =  5'd3;\n\t\t'd34: tc_o  =  5'd3;\n\t\t'd35: tc_o  =  5'd4;\n\t\t'd36: tc_o  =  5'd4;\n\t\t'd37: tc_o  =  5'd4;\n\t\t'd38: tc_o  =  5'd5;\n\t\t'd39: tc_o  =  5'd5;\t\t\n\t\t'd40: tc_o  =  5'd6;\n\t\t'd41: tc_o  =  5'd6;\n\t\t'd42: tc_o  =  5'd7;\n\t\t'd43: tc_o  =  5'd8;\n\t\t'd44: tc_o  =  5'd9;\n\t\t'd45: tc_o  =  5'd10;\n\t\t'd46: tc_o  =  5'd11;\n\t\t'd47: tc_o  =  5'd13;\n\t\t'd48: tc_o  =  5'd14;\n\t\t'd49: tc_o  =  5'd16;\n\t\t'd50: tc_o  =  5'd18;\n\t\t'd51: tc_o  =  5'd20;\n\t\t'd52: tc_o  =  5'd22;\n\t\t'd53: tc_o  =  5'd24;\n\t  default: tc_o =  5'd0 ;\n\tendcase\t\t\nend\n\nendmodule\n",
        "module_name": "db_lut_tc",
        "module_hash": "677498a5371fe2f18e71107c9ad91358",
        "dataset_index": 21975
      },
      "shift_register_e15f043d": {
        "rtl_code": "module shift_register (\n    input clk,\n    input reset,\n    input enable,\n    input shift,\n    input [7:0] parallel_in,\n    output reg [7:0] parallel_out\n);\n\nreg [7:0] pipeline_reg [0:2];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        pipeline_reg[0] <= 8'b0;\n        pipeline_reg[1] <= 8'b0;\n        pipeline_reg[2] <= 8'b0;\n    end\n    else begin\n        pipeline_reg[0] <= enable ? {pipeline_reg[1][6:0], pipeline_reg[2][7]} : pipeline_reg[0];\n        pipeline_reg[1] <= enable ? {pipeline_reg[2][6:0], pipeline_reg[0][7]} : pipeline_reg[1];\n        pipeline_reg[2] <= enable ? {shift ? parallel_in : pipeline_reg[1][6:0], pipeline_reg[2][7:1]} : pipeline_reg[2];\n    end\nend\n\nalways @* begin\n    parallel_out = pipeline_reg[0];\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "e15f043d1033400a6276c50445c0a3a8",
        "dataset_index": 5268
      },
      "top__9f6bf957": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // 8-bit input for the register\n    output [3:0] counter_out, // 4-bit output from the counter\n    output [7:0] register_out, // 8-bit output from the register\n    output [7:0] final_out // Sum of the counter and register outputs\n);\n\n    wire [3:0] counter_out_wire;\n    wire [7:0] register_out_wire;\n    wire [7:0] final_out_wire;\n\n    counter_module counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .q(counter_out_wire)\n    );\n\n    register_module register_inst (\n        .clk(clk),\n        .reset(reset),\n        .d(d),\n        .q(register_out_wire)\n    );\n\n    functional_module functional_inst (\n        .counter_in(counter_out_wire),\n        .register_in(register_out_wire),\n        .final_out(final_out_wire)\n    );\n\n    assign counter_out = counter_out_wire;\n    assign register_out = register_out_wire;\n    assign final_out = final_out_wire;\n\nendmodule\n\nmodule counter_module (\n    input clk,\n    input reset,\n    output reg [3:0] q // 4-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\n\nmodule register_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output reg [7:0] q // 8-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'h34;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n\nmodule functional_module (\n    input [3:0] counter_in,\n    input [7:0] register_in,\n    output reg [7:0] final_out // Sum of the counter and register inputs\n);\n\n    always @(*) begin\n        final_out = counter_in + register_in;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "9f6bf957ac62a380454376e35837412f",
        "dataset_index": 13661
      },
      "velocityControlHdl_Reset_Delay_fe335553": {
        "rtl_code": "module velocityControlHdl_Reset_Delay\n(\n    CLK_IN,\n    reset,\n    enb_1_2000_0,\n    Reset_1,\n    In,\n    Out\n);\n\ninput CLK_IN;\ninput reset;\ninput enb_1_2000_0;\ninput Reset_1;\ninput signed [31:0] In;\noutput signed [31:0] Out;\n\nwire signed [31:0] Constant1_out1;\nwire signed [31:0] Reset_Switch1_out1;\nreg signed [31:0] In_Delay_out1;\nwire signed [31:0] Constant_out1;\nwire signed [31:0] Reset_Switch_out1;\n\n// Constant1\nassign Constant1_out1 = 32'sb00000000000000000000000000000000;\n\n// Reset_Switch1\nassign Reset_Switch1_out1 = (Reset_1 == 1'b0 ? In : Constant1_out1);\n\n// In_Delay\nalways @(posedge CLK_IN)\nbegin : In_Delay_process\n    if (reset == 1'b1)\n    begin\n        In_Delay_out1 <= 32'sb00000000000000000000000000000000;\n    end\n    else if (enb_1_2000_0)\n    begin\n        In_Delay_out1 <= Reset_Switch1_out1;\n    end\nend\n\n// Constant\nassign Constant_out1 = 32'sb00000000000000000000000000000000;\n\n// Reset_Switch\nassign Reset_Switch_out1 = (Reset_1 == 1'b0 ? In_Delay_out1 : Constant_out1);\n\nassign Out = Reset_Switch_out1;\n\nendmodule",
        "module_name": "velocityControlHdl_Reset_Delay",
        "module_hash": "fe335553fdcd95a4434dcbbc3fffe4a7",
        "dataset_index": 11777
      },
      "mux4_diff_9f660468": {
        "rtl_code": "\nmodule mux4_diff (\n    input [3:0] I,\n    input [1:0] S,\n    output reg O,\n    output reg OB\n);\n\n    // 4:1 MUX implementation\n    always @(*) begin\n        case (S)\n            2'b00: begin\n                O = I[0];\n                OB = ~I[0];\n            end\n            2'b01: begin\n                O = I[1];\n                OB = ~I[1];\n            end\n            2'b10: begin\n                O = I[2];\n                OB = ~I[2];\n            end\n            2'b11: begin\n                O = I[3];\n                OB = ~I[3];\n            end\n        endcase\n    end\n\nendmodule",
        "module_name": "mux4_diff",
        "module_hash": "9f66046877fb3049d91a36a7929202d8",
        "dataset_index": 11786
      },
      "sky130_fd_sc_lp__a2bb2o_1a9f448a": {
        "rtl_code": "module sky130_fd_sc_lp__a2bb2o (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    // Module ports\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Local signals\n    wire and0_out ;\n    wire nor0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , B1, B2            );\n    nor nor0 (nor0_out , A1_N, A2_N        );\n    or  or0  (or0_out_X, nor0_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a2bb2o",
        "module_hash": "1a9f448a7ed4495d26295c3b1db2bd53",
        "dataset_index": 7534
      },
      "up_down_counter_15ca33ae": {
        "rtl_code": "module up_down_counter (\n    input CLK,\n    input LOAD,\n    input [2:0] LOAD_VAL,\n    input UP_DOWN,\n    input CARRY_IN,\n    output reg [2:0] Q\n);\n\nreg [2:0] Q_reg1, Q_reg2, Q_reg3;\n\nalways @(posedge CLK) begin\n    Q_reg1 <= Q;\nend\n\nalways @(posedge CLK) begin\n    Q_reg2 <= Q_reg1;\nend\n\nalways @(posedge CLK) begin\n    Q_reg3 <= Q_reg2;\nend\n\nalways @(posedge CLK) begin\n    if (LOAD) begin\n        Q <= LOAD_VAL;\n    end else begin\n        if (UP_DOWN) begin\n            Q <= Q_reg1 + CARRY_IN;\n        end else begin\n            Q <= Q_reg1 - CARRY_IN;\n        end\n    end\nend\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "15ca33ae223e8401c608bff3e459f5e3",
        "dataset_index": 867
      },
      "calculator_75917128": {
        "rtl_code": "module calculator(clk, rst, op, a, b, result);\n   input clk, rst, op;\n   input [3:0] a, b;\n   output [3:0] result;\n\n   reg [3:0] reg_a;\n   reg [3:0] reg_b;\n   reg [3:0] reg_result;\n\n   always @(posedge clk) begin\n      if (rst) begin\n         reg_a <= 4'b0;\n         reg_b <= 4'b0;\n         reg_result <= 4'b0;\n      end else begin\n         reg_a <= a;\n         reg_b <= b;\n         case(op)\n            2'b00: reg_result <= reg_a + reg_b;\n            2'b01: reg_result <= reg_a - reg_b;\n            2'b10: reg_result <= reg_a * reg_b;\n            2'b11: reg_result <= reg_a / reg_b;\n         endcase\n      end\n   end\n\n   assign result = reg_result;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "75917128f1c1827768426a4a93e15295",
        "dataset_index": 18316
      },
      "barrel_shifter_acd7789e": {
        "rtl_code": "module barrel_shifter (\n  input clk,\n  input reset,\n  input [31:0] data,\n  input [31:0] shift_amount,\n  output reg [31:0] shifted_data\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shifted_data <= 0;\n    end else begin\n      if (shift_amount == 0) begin\n        shifted_data <= data;\n      end else if (shift_amount > 0) begin\n        shifted_data <= data << shift_amount;\n      end else begin\n        shifted_data <= data >> (-shift_amount);\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "acd7789e0c78ff531718fa9af073e3fd",
        "dataset_index": 13136
      },
      "sky130_fd_sc_hd__lpflow_inputiso0n_e1b1563b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__lpflow_inputiso0n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    and and0 (X     , A, SLEEP_B     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__lpflow_inputiso0n",
        "module_hash": "e1b1563bb77c328a28aee6ba2c3efced",
        "dataset_index": 12968
      },
      "VerificadorSentidoMovimiento_c3d98c05": {
        "rtl_code": "\nmodule VerificadorSentidoMovimiento(\n\t\t_clk_,\n\t\tFSM_ready_in,\n\t\tpiso_actual, \n\t\tsolicitud_ps,\n\t\tsolicitud_p1,\n\t\tsolicitud_p2,\n\t\tsolicitud_p3,\n\t\tsolicitud_p4,\n\t\taccion\n\t\t);\n\t\t\n\t\tinput [2:0] piso_actual;\n\t\tinput [1:0] solicitud_ps, solicitud_p1, solicitud_p2, solicitud_p3, solicitud_p4;\n\t\tinput _clk_, FSM_ready_in;\n\t\toutput reg [1:0] accion;\n\t\t\n\t\talways @(posedge _clk_)\n\t\t\tbegin\n\t\t\t\t//acciones para el sotano\n\t\t\t\tif (piso_actual == 3'b000)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_ps == 2'bx1) //No realiza accion\n\t\t\t\t\t\t\taccion <= 2'b00;\n\t\t\t\t\t\tif (solicitud_ps == 2'bx0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p1 == 2'bx0 | solicitud_p2 == 2'bx0 | solicitud_p3 == 2'bx0 | solicitud_p4 == 2'bx0)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t//acciones para el piso1\n\t\t\t\telse if (piso_actual == 3'b001)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p1 == 2'bxx)\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\tif (solicitud_ps == 2'bx1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p2 == 2'b1x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p3 == 2'b1x | solicitud_p4 == 2'b1x)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\telse if (solicitud_p3 == 2'bx1 | solicitud_p4 == 2'bx1)\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t//acciones para el piso2\n\t\t\t\telse if (piso_actual == 3'b010)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p2 == 2'bxx)\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\tif (solicitud_p1 == 2'bx1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p3 == 2'b1x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_ps == 2'b1x | solicitud_p3 == 2'b1x)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\telse if (solicitud_ps == 2'bx1 | solicitud_p3 == 2'bx1)\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x | solicitud_p1 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\t//acciones para el piso3\n\t\t\t\telse if (piso_actual == 3'b011)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p3 == 2'bxx)\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\tif (solicitud_p2 == 2'bx1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p4 == 2'b1x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_ps == 2'b1x | solicitud_p1 == 2'b1x)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\telse if (solicitud_ps == 2'bx1 | solicitud_p1 == 2'bx1)\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x | solicitud_p1 == 2'b0x | solicitud_p2 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\t//acciones para el piso 4\n\t\t\t\telse if (piso_actual == 3'b100)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p4 == 2'b1x) //No realiza accion\n\t\t\t\t\t\t\taccion <= 2'b00;\n\t\t\t\t\t\tif (solicitud_p4 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x | solicitud_p1 == 2'b0x | solicitud_p2 == 2'b0x | solicitud_p3 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\tend\n\t \n\t \n\t \n\t \nendmodule\n",
        "module_name": "VerificadorSentidoMovimiento",
        "module_hash": "c3d98c052587c0e3d60473a35d7f6d4b",
        "dataset_index": 3207
      },
      "Calculator_Full_Adder_2397f55c": {
        "rtl_code": "\nmodule Calculator_Full_Adder\n#(\n\tparameter WIDTH = 4\n)\n(\n\tinput  [WIDTH-1:0] A,\n\tinput  [WIDTH-1:0] B,\n\tinput              CIN,\n\t\n\toutput [WIDTH-1:0] RES,\n\toutput             COUT\n);\n\n\twire signed [WIDTH:0] op_a; \n\twire signed [WIDTH:0] op_b;\n\t\n\t\n\tassign op_a = { A[WIDTH-1], A };\n\tassign op_b = { B[WIDTH-1], B };\n\n\t\n\tassign { COUT, RES } = op_a + op_b + CIN;\n\t\nendmodule\n",
        "module_name": "Calculator_Full_Adder",
        "module_hash": "2397f55c4ea3d0afaa19906a61fb62f6",
        "dataset_index": 23167
      },
      "mux_2_to_1_96b5fcc6": {
        "rtl_code": "module mux_2_to_1 (\n    select,\n    data_0,\n    data_1,\n    out\n);\n\n    input select;\n    input data_0;\n    input data_1;\n    output out;\n\n    assign out = select ? data_1 : data_0;\n\nendmodule",
        "module_name": "mux_2_to_1",
        "module_hash": "96b5fcc66b622b5dfb672df6eb306c38",
        "dataset_index": 13121
      },
      "parity_generator_6c2a8c12": {
        "rtl_code": "\nmodule parity_generator (\n    input [7:0] data_in,\n    output reg parity_out\n);\n\n    always @(*) begin\n        case (data_in)\n            8'b00000001, 8'b00000011, 8'b00000101, 8'b00000111,\n            8'b00001001, 8'b00001011, 8'b00001101, 8'b00001111,\n            8'b00010001, 8'b00010011, 8'b00010101, 8'b00010111,\n            8'b00011001, 8'b00011011, 8'b00011101, 8'b00011111,\n            8'b00100001, 8'b00100011, 8'b00100101, 8'b00100111,\n            8'b00101001, 8'b00101011, 8'b00101101, 8'b00101111,\n            8'b00110001, 8'b00110011, 8'b00110101, 8'b00110111,\n            8'b00111001, 8'b00111011, 8'b00111101, 8'b00111111,\n            8'b01000001, 8'b01000011, 8'b01000101, 8'b01000111,\n            8'b01001001, 8'b01001011, 8'b01001101, 8'b01001111,\n            8'b01010001, 8'b01010011, 8'b01010101, 8'b01010111,\n            8'b01011001, 8'b01011011, 8'b01011101, 8'b01011111,\n            8'b01100001, 8'b01100011, 8'b01100101, 8'b01100111,\n            8'b01101001, 8'b01101011, 8'b01101101, 8'b01101111,\n            8'b01110001, 8'b01110011, 8'b01110101, 8'b01110111,\n            8'b01111001, 8'b01111011, 8'b01111101, 8'b01111111,\n            8'b10000001, 8'b10000011, 8'b10000101, 8'b10000111,\n            8'b10001001, 8'b10001011, 8'b10001101, 8'b10001111,\n            8'b10010001, 8'b10010011, 8'b10010101, 8'b10010111,\n            8'b10011001, 8'b10011011, 8'b10011101, 8'b10011111,\n            8'b10100001, 8'b10100011, 8'b10100101, 8'b10100111,\n            8'b10101001, 8'b10101011, 8'b10101101, 8'b10101111,\n            8'b10110001, 8'b10110011, 8'b10110101, 8'b10110111,\n            8'b10111001, 8'b10111011, 8'b10111101, 8'b10111111,\n            8'b11000001, 8'b11000011, 8'b11000101, 8'b11000111,\n            8'b11001001, 8'b11001011, 8'b11001101, 8'b11001111,\n            8'b11010001, 8'b11010011, 8'b11010101, 8'b11010111,\n            8'b11011001, 8'b11011011, 8'b11011101, 8'b11011111,\n            8'b11100001, 8'b11100011, 8'b11100101, 8'b11100111,\n            8'b11101001, 8'b11101011, 8'b11101101, 8'b11101111,\n            8'b11110001, 8'b11110011, 8'b11110101, 8'b11110111,\n            8'b11111001, 8'b11111011, 8'b11111101, 8'b11111111:\n                parity_out = 1;\n            default:\n                parity_out = 0;\n        endcase\n    end\n\nendmodule\n\nmodule parity_byte (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input sel_b1,\n    input sel_b2,\n    output reg [8:0] out_byte\n);\n\n    reg [7:0] data_in;\n    wire parity_out;\n\n    // 2-to-1 mux to select between a and b\n    always @(*) begin\n        if (sel_b1 == 1 && sel_b2 == 0) begin\n            data_in = a;\n        end else if (sel_b1 == 0 && sel_b2 == 1) begin\n            data_in = b;\n        end else begin\n            data_in = 8'b0;\n        end\n    end\n\n    // Priority encoder to generate parity bit\n    parity_generator parity (\n        .data_in(data_in),\n        .parity_out(parity_out)\n    );\n\n    // Multiplexer to combine parity bit and original 8 data bits\n    always @(*) begin\n        out_byte = {parity_out, data_in};\n    end\n\nendmodule\n",
        "module_name": "parity_generator",
        "module_hash": "6c2a8c12e55ac55b5390e088447cc6d2",
        "dataset_index": 6813
      },
      "full_adder_decaa3e0": {
        "rtl_code": "module full_adder (\n  input A,\n  input B,\n  input Cin,\n  output reg S,\n  output reg Cout\n);\n\n  always @ (A, B, Cin) begin\n    S = A ^ B ^ Cin;\n    Cout = (A & B) | (Cin & (A ^ B));\n  end\n\nendmodule\n\n\nmodule four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire c1, c2, c3;\n  full_adder fa1(A[0], B[0], Cin, S[0], c1);\n  full_adder fa2(A[1], B[1], c1, S[1], c2);\n  full_adder fa3(A[2], B[2], c2, S[2], c3);\n  full_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "decaa3e05f3ad21f3f04871417f29bc1",
        "dataset_index": 6188
      },
      "controllerHdl_MATLAB_Function_block3_new_bc7ab63f": {
        "rtl_code": "module controllerHdl_MATLAB_Function_block3_new\n          (\n           CLK_IN,\n           reset,\n           enb_1_2000_0,\n           u,\n           y\n          );\n\n\n  input   CLK_IN;\n  input   reset;\n  input   enb_1_2000_0;\n  input   signed [18:0] u;  // sfix19_En14\n  output  signed [18:0] y;  // sfix19_En14\n\n  wire signed [18:0] u_n1;  // sfix19\n  assign u_n1 = {1'b0, u[18:1]};\n\n  assign y = (u + u_n1) >> 1;\n\nendmodule",
        "module_name": "controllerHdl_MATLAB_Function_block3_new",
        "module_hash": "bc7ab63f715972a18f012ac8522e8ed9",
        "dataset_index": 11958
      },
      "jt10_adpcm_dt_ddafa320": {
        "rtl_code": "\n\nmodule jt10_adpcm_dt(\n    input           rst_n,\n    input           clk,        input           cen,        input   [3:0]   data,\n    input           chon,       output signed [15:0] pcm\n);\n\nlocalparam stepw = 15;\n\nreg signed [15:0] x1, x2, x3, x4, x5, x6;\nreg [stepw-1:0] step1, step2, step6;\nreg [stepw+1:0] step3, step4, step5;\nassign pcm = x2;\n\nreg  [18:0] d2l;\nreg  [15:0] d3,d4;\nreg  [3:0]  d2;\nreg         sign2, sign3, sign4, sign5;\nreg  [7:0]  step_val;\nreg  [22:0] step2l;\n\nalways @(*) begin\n    casez( d2[3:1] )\n        3'b0_??: step_val = 8'd57;\n        3'b1_00: step_val = 8'd77;\n        3'b1_01: step_val = 8'd102;\n        3'b1_10: step_val = 8'd128;\n        3'b1_11: step_val = 8'd153;\n    endcase d2l    = d2 * step2; step2l = step_val * step2; end\n\nreg chon2, chon3, chon4, chon5;\nreg signEqu4, signEqu5;\nreg [3:0] data2;\n\nalways @( posedge clk or negedge rst_n )\n    if( ! rst_n ) begin\n        x1 <= 'd0; step1 <= 'd127; \n        x2 <= 'd0; step2 <= 'd127;\n        x3 <= 'd0; step3 <= 'd127;\n        x4 <= 'd0; step4 <= 'd127;\n        x5 <= 'd0; step5 <= 'd127;\n        x6 <= 'd0; step6 <= 'd127;\n        d2 <= 'd0; d3 <= 'd0; d4 <= 'd0;\n        sign2 <= 'b0;\n        sign3 <= 'b0;\n        sign4 <= 'b0; sign5 <= 'b0;\n        chon2 <= 'b0;   chon3 <= 'b0;   chon4 <= 'b0; chon5 <= 1'b0;\n    end else if(cen) begin\n        d2        <= {data[2:0],1'b1};\n        sign2     <= data[3];\n        data2     <= data;\n        x2        <= x1;\n        step2     <= step1;\n        chon2     <= chon;\n        d3        <= d2l[18:3]; sign3     <= sign2;\n        x3        <= x2;\n        step3     <= step2l[22:6];\n        chon3     <= chon2;\n        d4        <= sign3 ? ~d3+16'b1 : d3;\n        sign4     <= sign3;\n        signEqu4  <= sign3 == x3[15];\n        x4        <= x3;\n        step4     <= step3;\n        chon4     <= chon3;\n        x5        <= x4+d4;\n        sign5     <= sign4;\n        signEqu5  <= signEqu4;\n        step5     <= step4;\n        chon5     <= chon4;\n        if( chon5 ) begin\n            if( signEqu5 && (sign5!=x5[15]) )\n                x6 <= sign5 ? 16'h8000 : 16'h7FFF;\n            else\n                x6 <= x5;\n\n            if( step5 < 127 )\n                step6  <= 15'd127;\n            else if( step5 > 24576 )\n                step6  <= 15'd24576;\n            else\n                step6 <= step5[14:0];\n        end else begin\n            x6      <= 'd0;\n            step6   <= 'd127;\n        end\n        x1    <= x6;\n        step1 <= step6;\n    end\n\n\nendmodule // jt10_adpcm    ",
        "module_name": "jt10_adpcm_dt",
        "module_hash": "ddafa32078eeb1710ada892b649c777b",
        "dataset_index": 23685
      },
      "mealy_fsm_4bit_sequence_detection_8cebb570": {
        "rtl_code": "module mealy_fsm_4bit_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  output reg match\n);\n\n  parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n  reg [1:0] state, next_state;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= S0;\n      match <= 1'b0;\n    end else begin\n      state <= next_state;\n      match <= 1'b0;\n      case (state)\n        S0: begin\n          if (data == 1'b1) begin\n            next_state <= S1;\n          end else begin\n            next_state <= S0;\n          end\n        end\n        S1: begin\n          if (data == 1'b0) begin\n            next_state <= S2;\n          end else begin\n            next_state <= S0;\n          end\n        end\n        S2: begin\n          if (data == 1'b1) begin\n            next_state <= S0;\n            match <= 1'b1;\n          end else begin\n            next_state <= S0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "mealy_fsm_4bit_sequence_detection",
        "module_hash": "8cebb570fec636578d2e3c62cd29811b",
        "dataset_index": 496
      },
      "decoder_4to16_7430f24e": {
        "rtl_code": "\nmodule decoder_4to16 (\n    input enable,\n    input [3:0] select,\n    output [15:0] out\n);\n\n    assign out[0] = (enable && (select == 4'b0000)) ? 1'b1 : 1'b0;\n    assign out[1] = (enable && (select == 4'b0001)) ? 1'b1 : 1'b0;\n    assign out[2] = (enable && (select == 4'b0010)) ? 1'b1 : 1'b0;\n    assign out[3] = (enable && (select == 4'b0011)) ? 1'b1 : 1'b0;\n    assign out[4] = (enable && (select == 4'b0100)) ? 1'b1 : 1'b0;\n    assign out[5] = (enable && (select == 4'b0101)) ? 1'b1 : 1'b0;\n    assign out[6] = (enable && (select == 4'b0110)) ? 1'b1 : 1'b0;\n    assign out[7] = (enable && (select == 4'b0111)) ? 1'b1 : 1'b0;\n    assign out[8] = (enable && (select == 4'b1000)) ? 1'b1 : 1'b0;\n    assign out[9] = (enable && (select == 4'b1001)) ? 1'b1 : 1'b0;\n    assign out[10] = (enable && (select == 4'b1010)) ? 1'b1 : 1'b0;\n    assign out[11] = (enable && (select == 4'b1011)) ? 1'b1 : 1'b0;\n    assign out[12] = (enable && (select == 4'b1100)) ? 1'b1 : 1'b0;\n    assign out[13] = (enable && (select == 4'b1101)) ? 1'b1 : 1'b0;\n    assign out[14] = (enable && (select == 4'b1110)) ? 1'b1 : 1'b0;\n    assign out[15] = (enable && (select == 4'b1111)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "decoder_4to16",
        "module_hash": "7430f24ebd3e91a1b73e750bbd243a01",
        "dataset_index": 6351
      },
      "start_for_CvtColowdI_shiftReg_258cba5f": {
        "rtl_code": "module start_for_CvtColowdI_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 32'd1;\nparameter ADDR_WIDTH = 32'd2;\nparameter DEPTH = 32'd3;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\n    begin\n        if (ce)\n        begin\n            for (i=0;i<DEPTH-1;i=i+1)\n                SRL_SIG[i+1] <= SRL_SIG[i];\n            SRL_SIG[0] <= data;\n        end\n    end\n\nassign q = SRL_SIG[a];\n\nendmodule",
        "module_name": "start_for_CvtColowdI_shiftReg",
        "module_hash": "258cba5fa0036ebcd45209458498402e",
        "dataset_index": 20154
      },
      "sky130_fd_sc_ls__xor2_9cee41eb": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__xor2 (\n    X,\n    A,\n    B\n);\n\n    output X;\n    input  A;\n    input  B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xor0_out_X;\n\n    xor xor0 (xor0_out_X, B, A           );\n    buf buf0 (X         , xor0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__xor2",
        "module_hash": "9cee41ebaa77ed1e8d6a2e843e69837b",
        "dataset_index": 9125
      },
      "mux_2_to_1_24895509": {
        "rtl_code": "module mux_2_to_1 (\n    output reg Y,\n    input A,\n    input B,\n    input S\n);\n\nalways @(*) begin\n    if (S == 0) begin\n        Y = A;\n    end else begin\n        Y = B;\n    end\nend\n\nendmodule",
        "module_name": "mux_2_to_1",
        "module_hash": "24895509e3db6800ae7ff5e1e272c6c6",
        "dataset_index": 5665
      },
      "vga_stripes_50458d0e": {
        "rtl_code": "\nmodule vga_stripes(\n\tVIDON,\n\tHC,\n\tVC,\n\tR,\n\tG,\n\tB,\n\tSW\n\t);\n\ninput VIDON;\ninput [9:0] HC;\ninput [9:0] VC;\noutput [7:0] R;\noutput [7:0] G;\noutput [7:0] B;\n\ninput [17:0] SW;\t\n\n\n\n\nreg [7:0] Rr, Gg, Bb;\nassign R = Rr;\nassign G = Gg;\nassign B = Bb;\n\nalways @ (VIDON, VC)\nbegin\n\tRr <= 8'b00000000;\n\tGg <= 8'b00000000;\n\tBb <= 8'b00000000;\n\t\n\tif( VIDON == 1'b1 )\n\tbegin\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tGg <= VC;\n\t\tRr <= HC;\n\t\tBb <= VC;\n\tend\nend\n\t\nendmodule\n\n",
        "module_name": "vga_stripes",
        "module_hash": "50458d0e40a7f7ce3d35467c1eb59064",
        "dataset_index": 5466
      },
      "encrypt_module_34427737": {
        "rtl_code": "module encrypt_module(\n  input [15:0] input_data,\n  output [15:0] encrypted_output\n);\n\n  wire [7:0] A;\n  wire [7:0] B;\n\n  assign A = input_data[15:8];\n  assign B = input_data[7:0];\n\n  wire [7:0] A_mult;\n  wire [7:0] B_mult;\n\n  assign A_mult = A * 3;\n  assign B_mult = B * 5;\n\n  wire [7:0] A_plus_B_mult;\n  wire [7:0] B_plus_A_mult;\n\n  assign A_plus_B_mult = A_mult + B;\n  assign B_plus_A_mult = B_mult + A;\n\n  assign encrypted_output = {A_plus_B_mult, B_plus_A_mult};\n\nendmodule",
        "module_name": "encrypt_module",
        "module_hash": "34427737183692f2cc303527b1d8cd6d",
        "dataset_index": 990
      },
      "sram_byte_en_824efe13": {
        "rtl_code": "module sram_byte_en\n#(\nparameter DATA_WIDTH    = 128,\nparameter ADDRESS_WIDTH = 7\n)\n(\n    input                           i_clk,\n    input      [DATA_WIDTH-1:0]     i_write_data,\n    input                           i_write_enable,\n    input      [ADDRESS_WIDTH-1:0]  i_address,\n    input      [DATA_WIDTH/8-1:0]   i_byte_enable,\n    output reg [DATA_WIDTH-1:0]     o_read_data\n);\n\n    reg [DATA_WIDTH-1:0]   mem  [0:2**ADDRESS_WIDTH-1];\n    integer i;\n\n    always @(posedge i_clk) begin\n        // read\n        o_read_data <= i_write_enable ? {DATA_WIDTH{1'd0}} : mem[i_address];\n\n        // write\n        if (i_write_enable) begin\n            for (i=0; i<DATA_WIDTH/8; i=i+1) begin\n                mem[i_address][i*8+0] <= i_byte_enable[i] ? i_write_data[i*8+0] : mem[i_address][i*8+0] ;\n                mem[i_address][i*8+1] <= i_byte_enable[i] ? i_write_data[i*8+1] : mem[i_address][i*8+1] ;\n                mem[i_address][i*8+2] <= i_byte_enable[i] ? i_write_data[i*8+2] : mem[i_address][i*8+2] ;\n                mem[i_address][i*8+3] <= i_byte_enable[i] ? i_write_data[i*8+3] : mem[i_address][i*8+3] ;\n                mem[i_address][i*8+4] <= i_byte_enable[i] ? i_write_data[i*8+4] : mem[i_address][i*8+4] ;\n                mem[i_address][i*8+5] <= i_byte_enable[i] ? i_write_data[i*8+5] : mem[i_address][i*8+5] ;\n                mem[i_address][i*8+6] <= i_byte_enable[i] ? i_write_data[i*8+6] : mem[i_address][i*8+6] ;\n                mem[i_address][i*8+7] <= i_byte_enable[i] ? i_write_data[i*8+7] : mem[i_address][i*8+7] ;\n            end\n        end\n    end\nendmodule",
        "module_name": "sram_byte_en",
        "module_hash": "824efe13e4b5f88ca111009bfa6214c1",
        "dataset_index": 10340
      },
      "johnson_counter_72f174ca": {
        "rtl_code": "module johnson_counter (\n  input clk,\n  output [n-1:0] out\n);\n\n  parameter n = 4; // number of output signals\n\n  reg [n-1:0] state;\n  wire [n-1:0] next_state;\n\n  assign out = state;\n\n  always @ (posedge clk) begin\n    state <= next_state;\n  end\n\n  assign next_state[0] = state[n-1] ^ state[0];\n  assign next_state[1] = state[0] ^ state[1];\n  assign next_state[2] = state[1] ^ state[2];\n  assign next_state[3] = state[2] ^ state[3];\n\nendmodule",
        "module_name": "johnson_counter",
        "module_hash": "72f174ca64cdf7591222ff43bb8c9d16",
        "dataset_index": 16181
      },
      "assert_change_assert_b334859e": {
        "rtl_code": "module assert_change_assert (\n  input clk, reset_n, start_event, xzcheck_enable,\n  input [width-1:0] test_expr,\n  input [31:0] window,\n  input ignore_new_start, reset_on_new_start, error_on_new_start,\n  output pass\n);\n  parameter width = 8;\n  parameter num_cks = 2;\n  reg [width-1:0] test_expr_reg;\n  reg [31:0] window_count;\n  reg [31:0] start_event_count;\n  reg [31:0] reset_event_count;\n  reg [31:0] error_event_count;\n  reg [31:0] xzcheck_event_count;\n  reg [31:0] xz_error_count;\n  reg [31:0] xz_ignore_count;\n  reg [31:0] xz_pass_count;\n  reg [31:0] xz_reset_count;\n  reg [1:0] state;\n  reg [1:0] xz_state;\n  reg [width-1:0] xz_value;\n  reg [width-1:0] xz_mask;\n  reg [width-1:0] xz_error_mask;\n  reg [width-1:0] xz_ignore_mask;\n  reg [width-1:0] xz_pass_mask;\n  reg [width-1:0] xz_reset_mask;\n  assign pass = (state == 2'b10);\n  \n  always @(posedge clk) begin\n    if (!reset_n) begin\n      state <= 2'b00;\n      xz_state <= 2'b00;\n      test_expr_reg <= 0;\n      window_count <= 0;\n      start_event_count <= 0;\n      reset_event_count <= 0;\n      error_event_count <= 0;\n      xzcheck_event_count <= 0;\n      xz_error_count <= 0;\n      xz_ignore_count <= 0;\n      xz_pass_count <= 0;\n      xz_reset_count <= 0;\n      xz_value <= 0;\n      xz_mask <= 0;\n      xz_error_mask <= 0;\n      xz_ignore_mask <= 0;\n      xz_pass_mask <= 0;\n      xz_reset_mask <= 0;\n    end else begin\n      case (state)\n        2'b00: begin // IDLE\n          test_expr_reg <= test_expr;\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (ignore_new_start) begin\n              state <= 2'b01; // IGNORE\n            end else begin\n              state <= 2'b10; // CHECK\n            end\n          end\n        end\n        2'b01: begin // IGNORE\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (reset_on_new_start) begin\n              reset_event_count <= reset_event_count + 1;\n              state <= 2'b00; // IDLE\n            end else if (error_on_new_start) begin\n              error_event_count <= error_event_count + 1;\n              state <= 2'b11; // ERROR\n            end\n          end else begin\n            window_count <= window_count + 1;\n            if (window_count >= window) begin\n              state <= 2'b00; // IDLE\n            end\n          end\n        end\n        2'b10: begin // CHECK\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (reset_on_new_start) begin\n              reset_event_count <= reset_event_count + 1;\n              state <= 2'b00; // IDLE\n            end else if (error_on_new_start) begin\n              error_event_count <= error_event_count + 1;\n              state <= 2'b11; // ERROR\n            end\n          end else begin\n            window_count <= window_count + 1;\n            if (window_count >= window) begin\n              state <= 2'b00; // IDLE\n            end else begin\n              if (xzcheck_enable) begin\n                case (xz_state)\n                  2'b00: begin // IDLE\n                    if (test_expr_reg[xzcheck_event_count]) begin\n                      xz_value <= test_expr_reg;\n                      xz_mask <= (1 << xzcheck_event_count);\n                      xz_state <= 2'b01; // ERROR_MASK\n                    end else begin\n                      xz_state <= 2'b00; // IDLE\n                      xzcheck_event_count <= xzcheck_event_count + 1;\n                      if (xzcheck_event_count >= width) begin\n                        xz_pass_count <= xz_pass_count + 1;\n                        xz_state <= 2'b10; // PASS\n                      end\n                    end\n                  end\n                  2'b01: begin // ERROR_MASK\n                    if (test_expr_reg[xzcheck_event_count]) begin\n                      xz_error_mask <= xz_error_mask | (1 << xzcheck_event_count);\n                    end else begin\n                      xz_ignore_mask <= xz_ignore_mask | (1 << xzcheck_event_count);\n                    end\n                    xzcheck_event_count <= xzcheck_event_count + 1;\n                    if (xzcheck_event_count >= width) begin\n                      xz_state <= 2'b10; // PASS\n                    end else if (test_expr_reg[xzcheck_event_count]) begin\n                      xz_value <= test_expr_reg;\n                      xz_mask <= (1 << xzcheck_event_count);\n                      xz_state <= 2'b01; // ERROR_MASK\n                    end else begin\n                      xz_state <= 2'b00; // IDLE\n                    end\n                  end\n                  2'b10: begin // PASS\n                    if (test_expr_reg[xzcheck_event_count]) begin\n                      if (xz_value[xzcheck_event_count] !== test_expr_reg[xzcheck_event_count]) begin\n                        xz_error_count <= xz_error_count + 1;\n                        xz_error_mask <= xz_error_mask | (1 << xzcheck_event_count);\n                      end else begin\n                        xz_pass_mask <= xz_pass_mask | (1 << xzcheck_event_count);\n                      end\n                      xz_reset_mask <= xz_reset_mask | (1 << xzcheck_event_count);\n                      xz_reset_count <= xz_reset_count + 1;\n                      xz_state <= 2'b00; // IDLE\n                      xzcheck_event_count <= xzcheck_event_count + 1;\n                      if (xzcheck_event_count >= width) begin\n                        xz_pass_count <= xz_pass_count + 1;\n                        xz_state <= 2'b10; // PASS\n                      end\n                    end else begin\n                      xz_state <= 2'b00; // IDLE\n                      xzcheck_event_count <= xzcheck_event_count + 1;\n                      if (xzcheck_event_count >= width) begin\n                        xz_pass_count <= xz_pass_count + 1;\n                        xz_state <= 2'b10; // PASS\n                      end\n                    end\n                  end\n                endcase\n              end else begin\n                if (test_expr_reg === 0) begin\n                  state <= 2'b11; // ERROR\n                end\n              end\n            end\n          end\n        end\n        2'b11: begin // ERROR\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (reset_on_new_start) begin\n              reset_event_count <= reset_event_count + 1;\n              state <= 2'b00; // IDLE\n            end else if (error_on_new_start) begin\n              error_event_count <= error_event_count + 1;\n              state <= 2'b11; // ERROR\n            end\n          end else begin\n            window_count <= window_count + 1;\n            if (window_count >= window) begin\n              state <= 2'b00; // IDLE\n            end\n          end\n        end\n      endcase\n    end\n  end\nendmodule",
        "module_name": "assert_change_assert",
        "module_hash": "b334859ea99ce2446d29fc8163a0a5c6",
        "dataset_index": 13485
      },
      "fourBitAdder_2460be75": {
        "rtl_code": "\nmodule fourBitAdder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[3:0];\n    assign Cout = temp_sum[4];\n\nendmodule",
        "module_name": "fourBitAdder",
        "module_hash": "2460be758b1467ea076f8403f56d0522",
        "dataset_index": 17439
      },
      "tfr_mem_6f90f1f2": {
        "rtl_code": "\n\nmodule tfr_mem ( \n\tinput wire memclk_i,\n\toutput reg [23:0]\tbus_A_o,\n\toutput reg [7:0] bus_D_o,\n\toutput reg [31:0] romflags_o,\n\tinput busclk_i,\tinput nreset_i,\n\tinput [3:0] A_i,\tinput [7:0] D_i,\n\toutput reg [7:0] D_o,\n\tinput nWR_i,\n\tinput nRD_i\t\n\t);\n\n\treg [23:0] addr_io;\n\t\n\tfunction [7:0] lookup_register( input [3:0] a );\n\t\tcase( a )\n\t\t\t4'h0: lookup_register = addr_io[7:0];\n\t\t\t4'h1: lookup_register = addr_io[15:8];\n\t\t\t4'h2: lookup_register = addr_io[23:16];\n\t\t\t4'h4: lookup_register = romflags_o[7:0];\n\t\t\t4'h5: lookup_register = romflags_o[15:8];\n\t\t\t4'h6: lookup_register = romflags_o[23:16];\n\t\t\t4'h7: lookup_register = romflags_o[31:24];\n\t\t\tdefault: lookup_register = 8'hff;\n\t\tendcase\n\tendfunction\n\t\n\ttask write_register(\n\t\tinput [3:0] a,\n\t\tinput [7:0] d\n\t);\t\t\n\t\tcase( a )\n\t\t\t4'h0: addr_io[7:0] <= d;\n\t\t\t4'h1: addr_io[15:8] <= d;\n\t\t\t4'h2: addr_io[23:16] <= d;\n\t\t\t4'h4: romflags_o[d[4:0]] <= d[7];\n\t\t\t4'hf: bus_D_o <= d;\n\t\t\tdefault: ;\n\t\tendcase\n\tendtask\n\t\n\talways @(posedge busclk_i)\n\tbegin\n\t\tif( !nreset_i ) begin\n\t\t\taddr_io <= 24'd0;\n\t\t\tbus_D_o <= 8'd0;\n\t\t\tromflags_o <= 32'd0;\n\t\tend\n\t\telse begin\n\t\t\tif( !nRD_i ) D_o <= lookup_register(A_i);\n\t\t\tif( !nWR_i ) begin\n\t\t\t\twrite_register(A_i,D_i);\n\t\t\t\tif( A_i == 4'hf ) addr_io <= addr_io + 1'b1;\n\t\t\tend\n\t\tend\n\tend\n\t\n\talways @(posedge memclk_i)\n\tbegin\n\t\tbus_A_o <= (addr_io -1'b1);\tend\n\t\nendmodule\n\t\n",
        "module_name": "tfr_mem",
        "module_hash": "6f90f1f2f8ced7ba0e9822cd2b44e0a7",
        "dataset_index": 12496
      },
      "RAM_65ebb8f1": {
        "rtl_code": "module RAM(\n    input wire clka,\n    input wire wea,\n    input wire [6:0] addra,\n    input wire [31:0] dina,\n    output reg [31:0] douta\n);\n\nreg [31:0] memory[0:127];\n\nalways @(posedge clka) begin\n    if(wea) begin\n        memory[addra] <= dina;\n    end\n    douta <= memory[addra];\nend\n\nendmodule",
        "module_name": "RAM",
        "module_hash": "65ebb8f1fdd68f040bb14c7adeedb2db",
        "dataset_index": 1474
      },
      "anteconmutador_9e571a59": {
        "rtl_code": "module anteconmutador (\n    input clk,\n    input [7:0] count,\n    input calculate,\n    output reg [3:0] centenas,\n    output reg [3:0] decenas,\n    output reg [3:0] unidades,\n    output reg C,\n    output reg De,\n    output reg U\n);\n\n    reg [7:0] digitT;\n    reg i;\n\n    always @(posedge clk) begin\n        if (calculate) begin\n            if (i) begin\n                digitT = count;\n                i = 0;\n            end\n            if (digitT > 7'b1100011) begin\n                digitT = digitT - 7'b1100100;\n                centenas = centenas + 1;\n            end\n            else begin\n                if (digitT > 7'b0001001) begin\n                    digitT = digitT - 7'b0001010;\n                    decenas = decenas + 1;\n                end\n                else begin\n                    unidades = {digitT[3:0]};\n                    if (centenas >= 1) begin\n                        C = 1;\n                    end\n                    if (decenas >= 1) begin\n                        De = 1;\n                    end\n                    if (unidades >= 1) begin\n                        U = 1;\n                    end\n                end\n            end\n        end\n        else begin\n            digitT = 0;\n            C = 0;\n            De = 0;\n            U = 0;\n            i = 1;\n            centenas = 0;\n            decenas = 0;\n            unidades = 0;\n        end\n    end\nendmodule",
        "module_name": "anteconmutador",
        "module_hash": "9e571a594a4945096f80d1b38e4ba7fc",
        "dataset_index": 19752
      },
      "ripple_addsub_ef8f153a": {
        "rtl_code": "\nmodule ripple_addsub (\n    input [7:0] A,\n    input [7:0] B,\n    input SUB,\n    input CLK,\n    output reg [7:0] SUM,\n    output reg CARRY_OUT\n);\n\n    reg [7:0] temp_sum;\n    reg carry_in;\n\n    always @(posedge CLK) begin\n        if(SUB) begin\n            temp_sum <= A - B - carry_in;\n            CARRY_OUT <= ~((~A[7] & B[7]) | (~B[7] & temp_sum[6]) | (temp_sum[6] & ~A[7]));\n        end else begin\n            temp_sum <= A + B + carry_in;\n            CARRY_OUT <= (temp_sum[7] == 1);\n        end\n        SUM <= temp_sum[7:0];\n        carry_in <= CARRY_OUT;\n    end\n\nendmodule",
        "module_name": "ripple_addsub",
        "module_hash": "ef8f153ae412ccce1dc27b4fca4f6e10",
        "dataset_index": 15886
      },
      "debouncer_d848b498": {
        "rtl_code": "module debouncer(clk, signal_in, debounce_time, signal_out);\n  input clk;\n  input signal_in;\n  input [31:0] debounce_time;\n  output signal_out;\n\n  reg [31:0] debounce_counter;\n  reg signal_out_reg;\n  reg signal_in_reg;\n\n  always @(posedge clk) begin\n    if (signal_in != signal_in_reg) begin\n      debounce_counter <= debounce_time;\n      signal_in_reg <= signal_in;\n    end else if (debounce_counter > 0) begin\n      debounce_counter <= debounce_counter - 1;\n    end else begin\n      debounce_counter <= debounce_time;\n      signal_out_reg <= signal_in;\n    end\n  end\n\n  assign signal_out = signal_out_reg;\n\nendmodule",
        "module_name": "debouncer",
        "module_hash": "d848b498fa6455a2750693a4c342abb0",
        "dataset_index": 2377
      },
      "square_wave_generator_fac2c546": {
        "rtl_code": "module square_wave_generator (\n    input clk,\n    output reg square_wave\n);\n\n    reg [31:0] counter;\n\n    always @(posedge clk) begin\n        counter <= counter + 1;\n        if (counter == 499_999) begin\n            counter <= 0;\n            square_wave <= ~square_wave;\n        end\n    end\n\nendmodule",
        "module_name": "square_wave_generator",
        "module_hash": "fac2c5461ad5e0a930ec8539bf206fad",
        "dataset_index": 17740
      },
      "axis_alex_c1f7584f": {
        "rtl_code": "\n\nmodule axis_alex\n(\n  input  wire        aclk,\n  input  wire        aresetn,\n\n  output wire [3:0]  alex_data,\n\n  output wire        s_axis_tready,\n  input  wire [31:0] s_axis_tdata,\n  input  wire        s_axis_tvalid\n);\n\n  reg [15:0] int_data_reg, int_data_next;\n  reg [11:0] int_cntr_reg, int_cntr_next;\n  reg [1:0] int_load_reg, int_load_next;\n  reg int_enbl_reg, int_enbl_next;\n  reg int_tready_reg, int_tready_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_data_reg <= 16'd0;\n      int_cntr_reg <= 12'd0;\n      int_load_reg <= 2'd0;\n      int_enbl_reg <= 1'b0;\n      int_tready_reg <= 1'b0;\n    end\n    else\n    begin\n      int_data_reg <= int_data_next;\n      int_cntr_reg <= int_cntr_next;\n      int_load_reg <= int_load_next;\n      int_enbl_reg <= int_enbl_next;\n      int_tready_reg <= int_tready_next;\n    end\n  end\n\n  always @*\n  begin\n    int_data_next = int_data_reg;\n    int_cntr_next = int_cntr_reg;\n    int_load_next = int_load_reg;\n    int_enbl_next = int_enbl_reg;\n    int_tready_next = int_tready_reg;\n\n    if(s_axis_tvalid & ~int_enbl_reg)\n    begin\n      int_data_next = s_axis_tdata[15:0];\n      int_load_next = s_axis_tdata[17:16];\n      int_enbl_next = 1'b1;\n      int_tready_next = 1'b1;\n    end\n\n    if(int_tready_reg)\n    begin\n      int_tready_next = 1'b0;\n    end\n\n    if(int_enbl_reg)\n    begin\n      int_cntr_next = int_cntr_reg + 1'b1;\n    end\n\n    if(&int_cntr_reg[6:0])\n    begin\n      int_data_next = {int_data_reg[14:0], 1'b0};\n    end\n\n    if(int_cntr_reg[7] & int_cntr_reg[11])\n    begin\n      int_cntr_next = 12'd0;\n      int_load_next = 2'd0;\n      int_enbl_next = 1'b0;\n    end\n\n  end\n\n  assign s_axis_tready = int_tready_reg;\n\n  assign alex_data[0] = int_data_reg[15];\n  assign alex_data[1] = int_cntr_reg[6] & ~int_cntr_reg[11];\n  assign alex_data[2] = int_load_reg[0] & int_cntr_reg[6] & int_cntr_reg[11];\n  assign alex_data[3] = int_load_reg[1] & int_cntr_reg[6] & int_cntr_reg[11];\n\nendmodule\n",
        "module_name": "axis_alex",
        "module_hash": "c1f7584f798fb0e6cf5f0772ac449e9b",
        "dataset_index": 23807
      },
      "mag_comp_d4f19ce2": {
        "rtl_code": "module mag_comp(\n    input [3:0] A,\n    input [3:0] B,\n    output EQ,\n    output GT,\n    output LT\n);\n\n    reg EQ, GT, LT;\n\n    always @(*) begin\n        case(A > B)\n            1'b0: begin\n                EQ = (A == B);\n                GT = 1'b0;\n                LT = 1'b1;\n            end\n            1'b1: begin\n                EQ = 1'b0;\n                GT = 1'b1;\n                LT = 1'b0;\n            end\n        endcase\n    end\n\nendmodule",
        "module_name": "mag_comp",
        "module_hash": "d4f19ce2d9f700017911d4af5796486f",
        "dataset_index": 14646
      },
      "joypad_controller_142cb3dd": {
        "rtl_code": "\n\n\nmodule joypad_controller(\n  input  wire        clock,\n  input  wire        reset,\n  input  wire        int_ack,  \n  output reg         int_req,\n  input  wire [15:0] A,\n  input  wire  [7:0] Di,\n  output wire  [7:0] Do,\n  input  wire        rd_n,\n  input  wire        wr_n,\n  input  wire        cs,\n  output reg   [1:0] button_sel,\n  input  wire  [3:0] button_data\n);\n  \n  always @(posedge clock) begin\n    if (reset)\n      int_req <= 0;\n    else begin\n      if (!wr_n) begin\n        if (A == 16'hFF00)\n          button_sel <= Di[5:4];\n      end\n    end\n  end\n\n  assign Do = (cs) ? { 2'b11, button_sel[1:0], button_data[3:0] } : 8'hFF;\n\nendmodule\n",
        "module_name": "joypad_controller",
        "module_hash": "142cb3dda15faebb78fa9a09955990ec",
        "dataset_index": 12584
      },
      "AregInexactSlice_c58c3731": {
        "rtl_code": "\nmodule AregInexactSlice (\ninput [31:0] AM,\noutput notAM31_3,\noutput notAM2_0\n);\n\nwire [11:4] notAORed;\n\nnand (notAM31_3, AM[31], AM[30], AM[29], AM[28], AM[27], AM[26], AM[25], AM[24], AM[23], AM[22], AM[21], AM[20], AM[19]); // Fixed AM[19], AM[20], AM[21], AM[22], AM[23], AM[24], AM[25], AM[26], AM[27], AM[28], AM[29], AM[30], AM[31] to AM[31], AM[30], AM[29], AM[28], AM[27], AM[26], AM[25], AM[24], AM[23], AM[22], AM[21], AM[20], AM[19] //\nnand (notAM2_0, AM[2], AM[1], AM[0]); // Fixed AM[1], AM[2], AM[0] to AM[2], AM[1], AM[0] //\n\nendmodule",
        "module_name": "AregInexactSlice",
        "module_hash": "c58c3731acfe5375261e7ae0b268371e",
        "dataset_index": 20826
      },
      "small_fifo_cntr_a581fc60": {
        "rtl_code": "\nmodule small_fifo_cntr (\n    input aclr,       // Asynchronous clear input\n    input clock,      // Clock input\n    input cnt_en,     // Counter enable input\n    input updown,     // Up/down counter select input\n    output [2:0] q,   // Counter output\n    input sclr        // Synchronous clear input\n);\n\n    // Internal registers\n    reg [2:0] q_reg;\n\n    // Counter logic\n    always @ (posedge clock or posedge aclr) begin\n        if (aclr) begin\n            q_reg <= 3'b0;\n        end else if (sclr) begin\n            q_reg <= 3'b0;\n        end else if (cnt_en) begin\n            if (updown) begin\n                q_reg <= q_reg + 1'b1;\n            end else begin\n                q_reg <= q_reg - 1'b1;\n            end\n        end\n    end\n\n    // Output assignment\n    assign q = q_reg;\n\nendmodule\n",
        "module_name": "small_fifo_cntr",
        "module_hash": "a581fc60f6d25b504678231088598b74",
        "dataset_index": 14323
      },
      "fifo_buffer_ee46e342": {
        "rtl_code": "\nmodule fifo_buffer (\n    input clk,\n    input reset,\n    output reg if_empty_n,\n    input if_read_ce,\n    input if_read,\n    output reg [7:0] if_dout,\n    output reg if_full_n,\n    input if_write_ce,\n    input if_write,\n    input [7:0] if_din\n);\n\nparameter ADDR_WIDTH = 1;\nparameter DEPTH = 2;\n\nreg [ADDR_WIDTH:0] wr_ptr = 0;\nreg [ADDR_WIDTH:0] rd_ptr = 0;\nreg [7:0] mem [0:DEPTH-1];\nreg [ADDR_WIDTH:0] count = 0;\n\nalways @(posedge clk) begin\n    if (reset == 1) begin\n        wr_ptr <= 0;\n        rd_ptr <= 0;\n        count <= 0;\n    end else begin\n        if (if_write & if_write_ce & if_full_n) begin\n            mem[wr_ptr] <= if_din;\n            wr_ptr <= wr_ptr + 1;\n            count <= count + 1;\n            if (wr_ptr == DEPTH) begin\n                wr_ptr <= 0;\n            end\n        end\n        if (if_read & if_read_ce & if_empty_n) begin\n            if_dout <= mem[rd_ptr];\n            rd_ptr <= rd_ptr + 1;\n            count <= count - 1;\n            if (rd_ptr == DEPTH) begin\n                rd_ptr <= 0;\n            end\n        end\n    end\n    if_empty_n <= (count > 0);\n    if_full_n <= (count < DEPTH);\nend\n\nendmodule\n",
        "module_name": "fifo_buffer",
        "module_hash": "ee46e3421b1e0cd5beda13f8c41161a8",
        "dataset_index": 8079
      },
      "bitwise_or_8bab9e5e": {
        "rtl_code": "\nmodule bitwise_or (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Stage 1\nwire [3:0] stage1_out;\nassign stage1_out = a | b;\n\n// Stage 2\nalways @(*) begin\n    out <= stage1_out;\nend\n\nendmodule",
        "module_name": "bitwise_or",
        "module_hash": "8bab9e5e99c61f843eee60766654efbf",
        "dataset_index": 19969
      },
      "xor_inverter_0503aeaf": {
        "rtl_code": "module xor_inverter (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output [7:0] out\n);\n\n    assign out = ctrl ? ~(a ^ b) : (a ^ b);\n\nendmodule",
        "module_name": "xor_inverter",
        "module_hash": "0503aeaf6d41cc9c6b9a3921eee98e2e",
        "dataset_index": 18265
      },
      "fifo_5e014959": {
        "rtl_code": "module fifo(\n  input clk,\n  input rst,\n  input [7:0] din,\n  input wr_en,\n  input rd_en,\n  output reg [7:0] dout,\n  output reg full,\n  output reg empty\n);\n\nparameter DEPTH = 16;\n\nreg [7:0] mem [0:DEPTH-1];\nreg [3:0] wr_ptr = 0;\nreg [3:0] rd_ptr = 0;\nreg [3:0] count = 0;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    wr_ptr <= 0;\n    rd_ptr <= 0;\n    count <= 0;\n  end else begin\n    if (wr_en && !full) begin\n      mem[wr_ptr] <= din;\n      wr_ptr <= wr_ptr + 1;\n      count <= count + 1;\n    end\n    if (rd_en && !empty) begin\n      dout <= mem[rd_ptr];\n      rd_ptr <= rd_ptr + 1;\n      count <= count - 1;\n    end\n  end\nend\n\nalways @* begin\n  full = (count == DEPTH);\n  empty = (count == 0);\nend\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "5e01495984c0163786f7ddb96fe95465",
        "dataset_index": 9102
      },
      "top__8a9e8138": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,          // Synchronous active-high reset\n    input [9:0] d,        // 10-bit input for the shift register\n    output [9:0] q,       // 10-bit output from the active module\n    output [9:0] count_out // 10-bit output from the binary counter\n);\n\n    // Shift register using ring counter architecture\n    reg [9:0] shift_reg [0:9];\n    reg [3:0] shift_sel = 4'b0001;\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_sel <= 4'b0001;\n        end\n        else begin\n            shift_reg[shift_sel] <= d;\n            shift_sel <= (shift_sel == 4'b1000) ? 4'b0001 : (shift_sel + 1);\n        end\n    end\n    assign q = shift_reg[shift_sel];\n\n    // Binary counter\n    reg [9:0] binary_counter = 10'b0;\n    always @(posedge clk) begin\n        if (reset) begin\n            binary_counter <= 10'b0;\n        end\n        else begin\n            binary_counter <= (binary_counter == 10'b1111111111) ? 10'b0 : binary_counter + 1;\n        end\n    end\n    assign count_out = binary_counter;\n\n    // Functional unit\n    reg [19:0] mult_out = 20'b0;\n    reg select = 1'b0;\n    always @(posedge clk) begin\n        if(reset) begin\n            mult_out <= 20'b0;\n            select <= 1'b0;\n        end\n        else begin\n            if(select)begin\n                mult_out <= shift_reg[shift_sel] * count_out;\n            end\n            else begin\n                mult_out <= count_out * shift_reg[shift_sel];\n            end\n        end\n    end\n\n    // Control logic\n    always @(posedge clk) begin\n        if(reset) begin\n            select <= 1'b0;\n        end\n        else begin\n            select <= (binary_counter == 10'b1111111111) ? 1'b1 : select;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "8a9e8138f5f481336eb5340fdd3deac6",
        "dataset_index": 16495
      },
      "top__8e0e969f": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] in,\n    output reg [7:0] anyedge,\n    output [7:0] final_out\n); // RTL will be here\n\n    reg [7:0] last_in;\n    wire [7:0] xor_out;\n    \n    xor_detector u1 (\n        .in(in),\n        .last_in(last_in),\n        .anyedge(xor_out)\n    );\n    \n    always @(posedge clk or posedge reset) begin // RTL will be here\n        if (reset) begin\n            last_in <= 8'b0;\n            anyedge <= 8'b0;\n        end else begin\n            last_in <= in;\n            anyedge <= xor_out;\n        end\n    end\n    \n    assign final_out = xor_out | anyedge;\n    \nendmodule\nmodule xor_detector (\n    input [7:0] in,\n    input [7:0] last_in,\n    output [7:0] anyedge\n);\n    \n    assign anyedge = in ^ last_in;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "8e0e969f85f3796658f266c1158ac871",
        "dataset_index": 2271
      },
      "shift_register_2af8bb4b": {
        "rtl_code": "module shift_register (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [3:0] d,\n    input enable,\n    output [3:0] q\n);\n\nreg [3:0] q_reg1, q_reg2, q_reg3, q_reg4;\n\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        q_reg1 <= 1'b0;\n        q_reg2 <= 1'b0;\n        q_reg3 <= 1'b0;\n        q_reg4 <= 1'b0;\n    end else begin\n        q_reg1 <= enable ? d[0] : q_reg1;\n        q_reg2 <= enable ? q_reg1 : q_reg2;\n        q_reg3 <= enable ? q_reg2 : q_reg3;\n        q_reg4 <= enable ? q_reg3 : q_reg4;\n    end\nend\n\nassign q = q_reg4;\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "2af8bb4bb60619a804bc82c590b98674",
        "dataset_index": 14690
      },
      "rcn_filter_8c2be3eb": {
        "rtl_code": "\n\n\nmodule rcn_filter\n(\n    input clk,\n    input rst,\n\n    input [68:0] rcn_in,\n    output [68:0] rcn_out,\n    \n    output reg filtered\n);\n    parameter START_0 = 1;\n    parameter END_0 = 0;\n    parameter START_1 = 1;\n    parameter END_1 = 0;\n    parameter START_2 = 1;\n    parameter END_2 = 0;\n    parameter START_3 = 1;\n    parameter END_3 = 0;\n\n    reg [68:0] rin;\n    reg [68:0] rout;\n    \n    assign rcn_out = rout;\n    \n    wire [23:0] addr_start_0 = START_0;\n    wire [23:0] addr_end_0 = END_0;\n    wire filter_0 = (rin[55:34] >= addr_start_0) && (rin[55:34] <= addr_end_0);\n    \n    wire [23:0] addr_start_1 = START_1;\n    wire [23:0] addr_end_1 = END_1;\n    wire filter_1 = (rin[55:34] >= addr_start_1) && (rin[55:34] <= addr_end_1);\n    \n    wire [23:0] addr_start_2 = START_2;\n    wire [23:0] addr_end_2 = END_2;\n    wire filter_2 = (rin[55:34] >= addr_start_2) && (rin[55:34] <= addr_end_2);\n    \n    wire [23:0] addr_start_3 = START_3;\n    wire [23:0] addr_end_3 = END_3;\n    wire filter_3 = (rin[55:34] >= addr_start_3) && (rin[55:34] <= addr_end_3);\n    \n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rout <= 69'd0;\n            filtered <= 1'b0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rout <= (filter_0 || filter_1 || filter_2 || filter_3) ? 69'd0 : rcn_in;\n            filtered <= (filter_0 || filter_1 || filter_2 || filter_3);\n        end\n    \n\nendmodule\n",
        "module_name": "rcn_filter",
        "module_hash": "8c2be3eb25ec361e01efb38b7f4e9e52",
        "dataset_index": 23416
      },
      "adder_AXI_CTRL_s_axi_3371b9fa": {
        "rtl_code": "\nmodule adder_AXI_CTRL_s_axi\n#(parameter\n    C_ADDR_WIDTH = 6,\n    C_DATA_WIDTH = 32\n)(\n    input  wire                      ACLK,\n    input  wire                      ARESET,\n    input  wire                      ACLK_EN,\n    input  wire [C_ADDR_WIDTH-1:0]   AWADDR,\n    input  wire                      AWVALID,\n    output wire                      AWREADY,\n    input  wire [C_DATA_WIDTH-1:0]   WDATA,\n    input  wire [C_DATA_WIDTH/8-1:0] WSTRB,\n    input  wire                      WVALID,\n    output wire                      WREADY,\n    output wire [1:0]                BRESP,\n    output wire                      BVALID,\n    input  wire                      BREADY,\n    input  wire [C_ADDR_WIDTH-1:0]   ARADDR,\n    input  wire                      ARVALID,\n    output wire                      ARREADY,\n    output wire [C_DATA_WIDTH-1:0]   RDATA,\n    output wire [1:0]                RRESP,\n    output wire                      RVALID,\n    input  wire                      RREADY,\n    output wire                      interrupt,\n    output wire                      ap_start,\n    input  wire                      ap_done,\n    input  wire                      ap_ready,\n    input  wire                      ap_idle,\n    output wire [31:0]               a,\n    output wire [31:0]               b,\n    input  wire [31:0]               c,\n    input  wire                      c_ap_vld\n);\nlocalparam\n    ADDR_BITS = 6;\n\nlocalparam\n    ADDR_AP_CTRL  = 6'h00,\n    ADDR_GIE      = 6'h04,\n    ADDR_IER      = 6'h08,\n    ADDR_ISR      = 6'h0c,\n    ADDR_A_DATA_0 = 6'h10,\n    ADDR_A_CTRL   = 6'h14,\n    ADDR_B_DATA_0 = 6'h18,\n    ADDR_B_CTRL   = 6'h1c,\n    ADDR_C_DATA_0 = 6'h20,\n    ADDR_C_CTRL   = 6'h24;\n\nlocalparam\n    WRIDLE = 2'd0,\n    WRDATA = 2'd1,\n    WRRESP = 2'd2;\n\nlocalparam\n    RDIDLE = 2'd0,\n    RDDATA = 2'd1;\n\nreg  [1:0]           wstate;\nreg  [1:0]           wnext;\nreg  [ADDR_BITS-1:0] waddr;\nwire [31:0]          wmask;\nwire                 aw_hs;\nwire                 w_hs;\nreg  [1:0]           rstate;\nreg  [1:0]           rnext;\nreg  [31:0]          rdata;\nwire                 ar_hs;\nwire [ADDR_BITS-1:0] raddr;\nwire                 int_ap_idle;\nwire                 int_ap_ready;\nreg                  int_ap_done;\nreg                  int_ap_start;\nreg                  int_auto_restart;\nreg                  int_gie;\nreg                  int_ier;\nreg                  int_isr;\nreg  [31:0]          int_a;\nreg  [31:0]          int_b;\nreg  [31:0]          int_c;\nreg                  int_c_ap_vld;\n\nassign AWREADY = (wstate == WRIDLE);\nassign WREADY  = (wstate == WRDATA);\nassign BRESP   = 2'b00;  assign BVALID  = (wstate == WRRESP);\nassign wmask   = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} };\nassign aw_hs   = AWVALID & AWREADY;\nassign w_hs    = WVALID & WREADY;\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ARESET)\n            wstate <= WRIDLE;\n        else\n            wstate <= wnext;\n    end\nend\n\nalways @(*) begin\n    case (wstate)\n        WRIDLE:\n            if (AWVALID)\n                wnext = WRDATA;\n            else\n                wnext = WRIDLE;\n        WRDATA:\n            if (WVALID)\n                wnext = WRRESP;\n            else\n                wnext = WRDATA;\n        WRRESP:\n            if (BREADY)\n                wnext = WRIDLE;\n            else\n                wnext = WRRESP;\n        default:\n            wnext = WRIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (aw_hs)\n            waddr <= AWADDR[ADDR_BITS-1:0];\n    end\nend\nassign ARREADY = (rstate == RDIDLE);\nassign RDATA   = rdata;\nassign RRESP   = 2'b00;  assign RVALID  = (rstate == RDDATA);\nassign ar_hs   = ARVALID & ARREADY;\nassign raddr   = ARADDR[ADDR_BITS-1:0];\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ARESET)\n            rstate <= RDIDLE;\n        else\n            rstate <= rnext;\n    end\nend\n\nalways @(*) begin\n    case (rstate)\n        RDIDLE:\n            if (ARVALID)\n                rnext = RDDATA;\n            else\n                rnext = RDIDLE;\n        RDDATA:\n            if (RREADY & RVALID)\n                rnext = RDIDLE;\n            else\n                rnext = RDDATA;\n        default:\n            rnext = RDIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ar_hs) begin\n            rdata <= 1'b0;\n            case (raddr)\n                ADDR_AP_CTRL: begin\n                    rdata[0] <= int_ap_start;\n                    rdata[1] <= int_ap_done;\n                    rdata[2] <= int_ap_idle;\n                    rdata[3] <= int_ap_ready;\n                    rdata[7] <= int_auto_restart;\n                end\n                ADDR_GIE: begin\n                    rdata <= int_gie;\n                end\n                ADDR_IER: begin\n                    rdata <= int_ier;\n                end\n                ADDR_ISR: begin\n                    rdata <= int_isr;\n                end\n                ADDR_A_DATA_0: begin\n                    rdata <= int_a[31:0];\n                end\n                ADDR_B_DATA_0: begin\n                    rdata <= int_b[31:0];\n                end\n                ADDR_C_DATA_0: begin\n                    rdata <= int_c[31:0];\n                end\n                ADDR_C_CTRL: begin\n                    rdata[0] <= int_c_ap_vld;\n                end\n            endcase\n        end\n    end\nend\nassign interrupt    = int_gie & (|int_isr);\nassign ap_start     = int_ap_start;\nassign int_ap_idle  = ap_idle;\nassign int_ap_ready = ap_ready;\nassign a            = int_a;\nassign b            = int_b;\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_start <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0])\n            int_ap_start <= 1'b1;\n        else if (ap_done & int_auto_restart)\n            int_ap_start <= 1'b1; else\n            int_ap_start <= 1'b0; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_done <= 1'b0;\n    else if (ACLK_EN) begin\n        if (ap_done)\n            int_ap_done <= 1'b1;\n        else if (ar_hs && raddr == ADDR_AP_CTRL)\n            int_ap_done <= 1'b0; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_auto_restart <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0])\n            int_auto_restart <=  WDATA[7];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_gie <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_GIE && WSTRB[0])\n            int_gie <= WDATA[0];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ier <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_IER && WSTRB[0])\n            int_ier <= WDATA[0];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_isr <= 1'b0;\n    else if (ACLK_EN) begin\n        if (int_ier & ap_done)\n            int_isr <= 1'b1;\n        else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n            int_isr <= int_isr ^ WDATA[0]; end\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_A_DATA_0)\n            int_a[31:0] <= (WDATA[31:0] & wmask) | (int_a[31:0] & ~wmask);\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_B_DATA_0)\n            int_b[31:0] <= (WDATA[31:0] & wmask) | (int_b[31:0] & ~wmask);\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_c <= 0;\n    else if (ACLK_EN) begin\n        if (c_ap_vld)\n            int_c <= c;\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_c_ap_vld <= 1'b0;\n    else if (ACLK_EN) begin\n        if (c_ap_vld)\n            int_c_ap_vld <= 1'b1;\n        else if (ar_hs && raddr == ADDR_C_CTRL)\n            int_c_ap_vld <= 1'b0; end\nend\n\nendmodule\n",
        "module_name": "adder_AXI_CTRL_s_axi",
        "module_hash": "3371b9fa46a53c00a756281b3a5fcff3",
        "dataset_index": 24703
      },
      "d_flip_flop_2e450d9d": {
        "rtl_code": "module d_flip_flop(input D, VPWR, VGND, VPB, VNB, CLK, output Q, Q_N);\n  // Create a set/reset latch for Q and Q_N\n  reg Q_SR, Q_N_SR;\n  assign Q = Q_SR;\n  assign Q_N = Q_N_SR;\n\n  // Create a clocked SR latch for Q and Q_N\n  reg Q_SR_CLK, Q_N_SR_CLK;\n  always @(posedge CLK)\n  begin\n    Q_SR_CLK <= Q_SR;\n    Q_N_SR_CLK <= Q_N_SR;\n    Q_SR <= D;\n    Q_N_SR <= D;\n  end\n\n  // Ensure that the outputs are initially x\n  initial\n  begin\n    Q_SR = 1'bX;\n    Q_N_SR = 1'bX;\n  end\nendmodule",
        "module_name": "d_flip_flop",
        "module_hash": "2e450d9dde964b86271cdccd344a1718",
        "dataset_index": 18802
      },
      "add_sub_mux_976a3485": {
        "rtl_code": "\nmodule add_sub_mux(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] result\n);\n\n    wire [31:0] adder_out;\n    wire mux_out;\n    \n    adder adder_inst(\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .sum(adder_out[31:16])\n    );\n    \n    assign adder_out[15:0] = a[15:0] + b[15:0];\n    \n    assign mux_out = sub ? ~adder_out[0] : adder_out[0];\n    \n    assign result[31:16] = adder_out[31:16] + mux_out;\n    assign result[15:0] = a[15:0] + b[15:0];\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] sum\n);\n\n    always @ (a or b) begin\n        sum <= a + b;\n    end\n\nendmodule\n",
        "module_name": "add_sub_mux",
        "module_hash": "976a3485b2298fc0df35328476547558",
        "dataset_index": 13891
      },
      "shift_register_7ac2acf3": {
        "rtl_code": "module shift_register ( input clk, input d, output q );\n  reg [2:0] reg_q;\n  always @(posedge clk) begin\n    reg_q <= {reg_q[1:0], d};\n  end\n  assign q = reg_q[2];\nendmodule",
        "module_name": "shift_register",
        "module_hash": "7ac2acf3b8967dfbaf2532ae07b60875",
        "dataset_index": 4952
      },
      "and_gate_70290513": {
        "rtl_code": "\nmodule and_gate (\n    input A, B,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    and (Y, A, B); // gate output\n\nendmodule\n",
        "module_name": "and_gate",
        "module_hash": "7029051392f9aae3c0901698898c9dba",
        "dataset_index": 18519
      },
      "top__c895c625": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    input enable,     // Asynchronous counter enable\n    input [3:0] A,    // 4-bit input for the adder-subtractor circuit\n    input [3:0] B,    // 4-bit input for the adder-subtractor circuit\n    input sub,        // Selects between addition and subtraction\n    input select,     // Selects between counter and adder-subtractor circuit output\n    output [3:0] Q    // Final output from the active module\n);\n\n    // Counter module with asynchronous reset and enable\n    reg [3:0] counter;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else if (enable) begin\n            counter <= counter + 1;\n        end\n    end\n    \n    // Adder-subtractor module\n    wire [3:0] sum;\n    assign sum = sub ? A - B : A + B;\n    \n    // Functional module to select maximum value\n    reg [3:0] max_value;\n    always @(*) begin\n        if (select) begin\n            max_value = counter > sum ? counter : sum;\n        end else begin\n            max_value = counter;\n        end\n    end\n    \n    // Output\n    assign Q = max_value;\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "c895c62576a321bf4dbb46c1e352836b",
        "dataset_index": 7712
      },
      "dff__76d4aa61": {
        "rtl_code": "module dff_module (\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(negedge clk) begin\n    q <= d;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nwire [7:0] q_internal;\n\ndff_module dff0(clk, d[0], q_internal[0]);\ndff_module dff1(clk, d[1], q_internal[1]);\ndff_module dff2(clk, d[2], q_internal[2]);\ndff_module dff3(clk, d[3], q_internal[3]);\ndff_module dff4(clk, d[4], q_internal[4]);\ndff_module dff5(clk, d[5], q_internal[5]);\ndff_module dff6(clk, d[6], q_internal[6]);\ndff_module dff7(clk, d[7], q_internal[7]);\n\nassign q = q_internal;\n\nendmodule",
        "module_name": "dff_",
        "module_hash": "76d4aa618f648daa65f2ba328f3d311f",
        "dataset_index": 17354
      },
      "calculator_9559b1ef": {
        "rtl_code": "module calculator(input [7:0] a, input [7:0] b, input [2:0] op, output reg [15:0] res);\n\n    always @(*) begin\n        case(op)\n            3'b000: res = a + b; // Addition\n            3'b001: res = a - b; // Subtraction\n            3'b010: res = a * b; // Multiplication\n            3'b011: res = a / b; // Division\n            default: res = 16'b0; // Default value\n        endcase\n    end\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "9559b1efcc7e67910b1a378164906724",
        "dataset_index": 6565
      },
      "EXMEMreg_897ab87c": {
        "rtl_code": "\n\nmodule EXMEMreg(clk,Rtin,Rdin,PCplusin,ALUresultin,DatabusBin,RegDstin,RegWrin,MemWrin,MemRdin,MemtoRegin,\nRtout,Rdout,PCplusout,ALUresultout,DatabusBout,RegDstout,RegWrout,MemWrout,MemRdout,MemtoRegout);\n\ninput clk;\ninput [4:0] Rtin;\ninput [4:0] Rdin;\ninput [31:0] PCplusin;\ninput [31:0] ALUresultin;\ninput [31:0] DatabusBin;\ninput [1:0] RegDstin;\ninput RegWrin;\ninput MemWrin;\ninput MemRdin;\ninput [1:0] MemtoRegin;\noutput [4:0] Rtout;\nreg [4:0] Rtout;\noutput [4:0] Rdout;\nreg [4:0] Rdout;\noutput [31:0] PCplusout;\nreg [31:0] PCplusout;\noutput [31:0] ALUresultout;\nreg [31:0] ALUresultout;\noutput [31:0] DatabusBout;\nreg [31:0] DatabusBout;\noutput [1:0] RegDstout;\nreg [1:0] RegDstout;\noutput RegWrout;\nreg RegWrout;\noutput MemWrout;\nreg MemWrout;\noutput MemRdout;\nreg MemRdout;\noutput [1:0] MemtoRegout;\nreg [1:0] MemtoRegout;\n\nalways @(posedge clk)\nbegin\n  Rtout <= Rtin;\n  Rdout <= Rdin;\n  PCplusout <= PCplusin;\n  ALUresultout <= ALUresultin;\n  DatabusBout <= DatabusBin;\n  RegDstout <= RegDstin;\n  RegWrout <= RegWrin;\n  MemWrout <= MemWrin;\n  MemRdout <= MemRdin;\n  MemtoRegout <= MemtoRegin;\nend\n\nendmodule\n",
        "module_name": "EXMEMreg",
        "module_hash": "897ab87cb516a52dfe63796e743acf4e",
        "dataset_index": 23705
      },
      "unknown_module_4f8a1ae8": {
        "rtl_code": "\nmodule\tprefetch(i_clk, i_rst, i_new_pc, i_clear_cache, i_stalled_n, i_pc,\n\t\t\to_i, o_pc, o_valid, o_illegal,\n\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,\n\t\t\ti_wb_ack, i_wb_stall, i_wb_err, i_wb_data);\n\tparameter\t\tADDRESS_WIDTH=32;\n\tlocalparam\t\tAW=ADDRESS_WIDTH;\n\tinput\twire\t\t\ti_clk, i_rst, i_new_pc, i_clear_cache,\n\t\t\t\t\ti_stalled_n;\n\tinput\twire\t[(AW-1):0]\ti_pc;\n\toutput\treg\t[31:0]\t\to_i;\n\toutput\twire\t[(AW-1):0]\to_pc;\n\toutput\treg\t\t\to_valid;\n\toutput\treg\t\t\to_wb_cyc, o_wb_stb;\n\toutput\twire\t\t\to_wb_we;\n\toutput\treg\t[(AW-1):0]\to_wb_addr;\n\toutput\twire\t[31:0]\t\to_wb_data;\n\tinput\twire\t\t\ti_wb_ack, i_wb_stall, i_wb_err;\n\tinput\twire\t[31:0]\t\ti_wb_data;\n\toutput\treg\t\t\to_illegal;\n\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = 32'h0000;\n\n\tinitial\to_wb_cyc = 1'b0;\n\tinitial\to_wb_stb = 1'b0;\n\tinitial\to_wb_addr= 0;\n\talways @(posedge i_clk)\n\t\tif ((i_rst)||(i_wb_ack)||(i_wb_err))\n\t\tbegin\n\t\t\to_wb_cyc <= 1'b0;\n\t\t\to_wb_stb <= 1'b0;\n\t\tend else if ((!o_wb_cyc)&&((i_stalled_n)||(!o_valid)||(i_new_pc)))\n\t\tbegin o_wb_cyc <= 1'b1;\n\t\t\to_wb_stb <= 1'b1;\n\t\tend else if (o_wb_cyc) begin\n\t\t\tif (!i_wb_stall)\n\t\t\t\to_wb_stb <= 1'b0;\n\t\tend\n\n\treg\tinvalid;\n\tinitial\tinvalid = 1'b0;\n\talways @(posedge i_clk)\n\t\tif (!o_wb_cyc)\n\t\t\tinvalid <= 1'b0;\n\t\telse if ((i_new_pc)||(i_clear_cache))\n\t\t\tinvalid <= 1'b1;\n\n\talways @(posedge i_clk)\n\t\tif (i_new_pc)\n\t\t\to_wb_addr <= i_pc;\n\t\telse if ((!o_wb_cyc)&&(i_stalled_n)&&(!invalid))\n\t\t\to_wb_addr <= o_wb_addr + 1'b1;\n\n\talways @(posedge i_clk)\n\t\tif ((o_wb_cyc)&&(i_wb_ack))\n\t\t\to_i <= i_wb_data;\n\n\tinitial o_valid   = 1'b0;\n\tinitial o_illegal = 1'b0;\n\talways @(posedge i_clk)\n\t\tif ((i_rst)||(i_new_pc))\n\t\tbegin\n\t\t\to_valid   <= 1'b0;\n\t\t\to_illegal <= 1'b0;\n\t\tend else if ((o_wb_cyc)&&((i_wb_ack)||(i_wb_err)))\n\t\tbegin\n\t\t\to_valid   <= (!invalid);\n\t\t\to_illegal <= ( i_wb_err)&&(!invalid);\n\t\tend else if ((i_stalled_n)||(i_clear_cache)||(i_new_pc))\n\t\tbegin\n\t\t\to_valid <= 1'b0;\n\t\t\to_illegal <= 1'b0;\n\t\tend\n\n\tassign\to_pc = o_wb_addr;\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "4f8a1ae8a463b5452b567ab4df3d020d",
        "dataset_index": 5587
      },
      "dffe_bce037d1": {
        "rtl_code": "\nmodule dffe (\n   Q,\n   CLK,\n   ENA,\n   D,\n   CLRN,\n   PRN\n);\n   input D;\n   input CLK;\n   input CLRN, PRN;\n   input ENA;\n   output Q;\n\n   reg Q_reg = 1'b0;\n\n   always @(posedge CLK) begin\n      if (CLRN == 1'b0) begin\n         Q_reg <= 1'b0;\n      end\n      else if (PRN == 1'b0) begin\n         Q_reg <= 1'b1;\n      end\n      else if (ENA) begin\n         Q_reg <= D;\n      end\n   end\n\n   assign Q = Q_reg;\nendmodule",
        "module_name": "dffe",
        "module_hash": "bce037d1cbb72caa24a5791233397a42",
        "dataset_index": 3294
      },
      "clock_gate_d3bed2fb": {
        "rtl_code": "module clock_gate(\n    input CLK,\n    input EN,\n    input TE,\n    output reg ENCLK\n);\n\nreg gated_clk;\n\nalways @ (posedge CLK) begin\n    if (EN & !TE) begin\n        gated_clk <= 1'b1;\n    end else begin\n        gated_clk <= 1'b0;\n    end\nend\n\nalways @ (*) begin\n    if (TE) begin\n        ENCLK = CLK;\n    end else begin\n        ENCLK = gated_clk ? CLK : ENCLK;\n    end\nend\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "d3bed2fbd3bc62de1d5a889547f15d13",
        "dataset_index": 11464
      },
      "sky130_fd_sc_hdll__and4_009b1791": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__and4",
        "module_hash": "009b17912958bb3ca07cc5d0719e8706",
        "dataset_index": 14342
      },
      "binary_max_9f95a0f7": {
        "rtl_code": "module binary_max (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] max,\n    output reg max_sel\n);\n\nalways @(posedge clk) begin\n    if (A > B) begin\n        max <= A;\n        max_sel <= 1;\n    end else begin\n        max <= B;\n        max_sel <= 0;\n    end\nend\n\nendmodule",
        "module_name": "binary_max",
        "module_hash": "9f95a0f704b540f7c8bdbe6430ed765d",
        "dataset_index": 1419
      },
      "tg68_ram #_869f481c": {
        "rtl_code": "module tg68_ram #(\n  parameter MS = 512\n)(\n  input  wire           clk,\n  input  wire           tg68_as,\n  input  wire [ 32-1:0] tg68_adr,\n  input  wire           tg68_rw,\n  input  wire           tg68_lds,\n  input  wire           tg68_uds,\n  input  wire [ 16-1:0] tg68_dat_out,\n  output wire [ 16-1:0] tg68_dat_in,\n  output wire           tg68_dtack\n);\n\nreg  [8-1:0] mem0 [0:MS-1];\nreg  [8-1:0] mem1 [0:MS-1];\n\nreg  [16-1:0] mem_do = 0;\nreg           trn = 1;\nreg           ack = 1;\n\ninteger i;\ninitial begin\n  for (i=0; i<MS; i=i+1) begin\n    mem1[i] = 0;\n    mem0[i] = 0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && tg68_rw) mem_do <= #1 {mem1[tg68_adr[31:1]], mem0[tg68_adr[31:1]]};\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && !tg68_rw) begin\n    if (!tg68_uds) mem1[tg68_adr[31:1]] <= #1 tg68_dat_out[15:8];\n    if (!tg68_lds) mem0[tg68_adr[31:1]] <= #1 tg68_dat_out[7:0];\n  end\nend\n\nalways @ (posedge clk) begin\n  trn <= #1 tg68_as;\n  ack <= #1 trn;\nend\n\nassign tg68_dat_in = mem_do;\nassign tg68_dtack = ack || tg68_as; task load;\n  input [1024*8-1:0] file;\n  reg [16-1:0] memory[0:MS-1];\n  reg [16-1:0] dat;\n  integer i;\nbegin\n  $readmemh(file, memory);\n  for (i=0; i<MS; i=i+1) begin\n    dat = memory[i];\n    mem1[i] = dat[15:8];\n    mem0[i] = dat[7:0];\n  end\nend\nendtask\n\n\nendmodule\n\n",
        "module_name": "tg68_ram #",
        "module_hash": "869f481c926886592c7ca9657325ac16",
        "dataset_index": 2336
      },
      "top__28ab274b": {
        "rtl_code": "module top_module (\n    input Clk,\n    input reset,\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    reg [7:0] johnson_out;\n    wire [2:0] comp_out;\n\n    comparator comp(.a(a), .b(b), .gt(comp_out[2]), .lt(comp_out[1]), .eq(comp_out[0]));\n    johnson_counter johnson(.Clk(Clk), .Y(johnson_out));\n\n    always @(posedge Clk) begin\n        if (reset) begin\n            gt <= 0;\n            lt <= 0;\n            eq <= 0;\n            johnson_out <= 8'b00000001;\n        end else begin\n            case (comp_out)\n                3'b000: begin // a < Y < b\n                    gt <= 0;\n                    lt <= 0;\n                    eq <= 0;\n                end\n                3'b001: begin // Y = b\n                    gt <= 0;\n                    lt <= 0;\n                    eq <= 1;\n                end\n                3'b010: begin // a < Y\n                    gt <= 1;\n                    lt <= 0;\n                    eq <= 0;\n                end\n                3'b011: begin // Y > b\n                    gt <= 1;\n                    lt <= 0;\n                    eq <= 1;\n                end\n                3'b100: begin // Y = a\n                    gt <= 0;\n                    lt <= 1;\n                    eq <= 0;\n                end\n                3'b101: begin // Y < a\n                    gt <= 0;\n                    lt <= 1;\n                    eq <= 1;\n                end\n                3'b110: begin // Y < a or Y > b\n                    gt <= 1;\n                    lt <= 1;\n                    eq <= 0;\n                end\n                3'b111: begin // Y < a or Y > b or Y = b\n                    gt <= 1;\n                    lt <= 1;\n                    eq <= 1;\n                end\n            endcase\n\n            if (johnson_out == 8'b10000000) begin\n                johnson_out <= 8'b00000001;\n            end else begin\n                johnson_out <= johnson_out << 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if (a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end else if (a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule\n\nmodule johnson_counter (\n    input Clk,\n    output reg [7:0] Y\n);\n\n    always @(posedge Clk) begin\n        if (Y == 8'b10000000) begin\n            Y <= 8'b00000001;\n        end else begin\n            Y <= Y << 1;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "28ab274bdf621cd1fffb5ad6c85c6f6e",
        "dataset_index": 10620
      },
      "floating_point_arithmetic_cc2100f5": {
        "rtl_code": "module floating_point_arithmetic (\n  input [31:0] a,\n  input [31:0] b,\n  input [1:0] ctrl,\n  output reg [31:0] result\n);\n\nparameter EXPONENT_WIDTH = 8;\nparameter MANTISSA_WIDTH = 23;\n\n// Define input and output formats as per IEEE 754 standard\nwire [EXPONENT_WIDTH-1:0] a_exp, b_exp;\nwire [MANTISSA_WIDTH-1:0] a_mant, b_mant;\nwire a_sign, b_sign;\nassign a_sign = a[31];\nassign a_exp = a[30:23];\nassign a_mant = a[22:0];\nassign b_sign = b[31];\nassign b_exp = b[30:23];\nassign b_mant = b[22:0];\n\n// Implement addition, subtraction, multiplication, and division using Verilog code\nwire [31:0] add_result, sub_result, mul_result, div_result;\nadder add(.a(a), .b(b), .result(add_result));\nsubtractor sub(.a(a), .b(b), .result(sub_result));\nmultiplier mul(.a(a), .b(b), .result(mul_result));\ndivider div(.a(a), .b(b), .result(div_result));\n\n// Select the operation based on the control signal\nalways @(*) begin\n  case (ctrl)\n    2'b00: result <= add_result;\n    2'b01: result <= sub_result;\n    2'b10: result <= mul_result;\n    2'b11: result <= div_result;\n    default: result <= 32'b0;\n  endcase\nend\n\nendmodule\n\nmodule adder (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a + b;\nend\nendmodule\n\nmodule subtractor (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a - b;\nend\nendmodule\n\nmodule multiplier (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a * b;\nend\nendmodule\n\nmodule divider (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a / b;\nend\nendmodule",
        "module_name": "floating_point_arithmetic",
        "module_hash": "cc2100f59a67ac194173fa5744120b82",
        "dataset_index": 11822
      },
      "shift_register_e917d6f2": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input reset,\n    input data_in,\n    output reg [2:0] q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 3'b0;\n        end else begin\n            q <= {q[1:0], data_in};\n        end\n    end\n\nendmodule\nmodule d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\nmodule functional_module (\n    input [2:0] shift_register_out,\n    input d_flip_flop_out,\n    output reg [2:0] or_out\n);\n\n    always @(*) begin\n        or_out = shift_register_out | d_flip_flop_out;\n    end\n\nendmodule\nmodule control_logic (\n    input select,\n    input [2:0] shift_register_out,\n    input d_flip_flop_out,\n    input [2:0] functional_out,\n    output reg [2:0] q\n);\n\n    always @(*) begin\n        if (select) begin\n            q = functional_out;\n        end else begin\n            q = shift_register_out;\n        end\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input d,\n    input select,\n    output q\n);\n\n    wire [2:0] shift_register_out;\n    wire d_flip_flop_out;\n    wire [2:0] functional_out;\n    wire [2:0] ctrl_logic_out;\n\n    shift_register shift_reg(clk, reset, d, shift_register_out);\n    d_flip_flop d_ff(clk, reset, d, d_flip_flop_out);\n    functional_module func_mod(shift_register_out, d_flip_flop_out, functional_out);\n    control_logic ctrl_logic(select, shift_register_out, d_flip_flop_out, functional_out, ctrl_logic_out);\n    assign q = ctrl_logic_out[2];\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "e917d6f2bb37c3ab3e759eedc1638bf0",
        "dataset_index": 13696
      }
    }
  },
  "created_at": "2025-11-11T16:41:38.359494"
}