{
  "batch_ids": [
    "batch_6916506322448190ae721ac6708cf7e4",
    "batch_69165064f5148190b95041bdf104062a",
    "batch_69165067c6bc81909af52c66a6ad26d8",
    "batch_69165069ed808190b064abc2fe41f9bb",
    "batch_6916506b29e081908f17aaf3dd27f886"
  ],
  "metadata": {
    "batch_6916506322448190ae721ac6708cf7e4": {
      "pipelined_4bit_adder_64d47a4c": {
        "rtl_code": "module pipelined_4bit_adder (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input clk,\n    output signed [3:0] sum,\n    output carry_out\n);\n\nreg signed [3:0] stage1_sum;\nreg stage1_carry_out;\nreg signed [3:0] stage2_sum;\nreg stage2_carry_out;\n\nassign sum = stage2_sum;\nassign carry_out = stage2_carry_out;\n\nalways @(*) begin\n    stage1_sum = A + B;\n    stage1_carry_out = (A[3] & B[3]) | (A[3] & ~stage1_sum[3]) | (B[3] & ~stage1_sum[3]);\nend\n\nalways @(posedge clk) begin\n    stage2_sum <= stage1_sum;\n    stage2_carry_out <= stage1_carry_out;\nend\n\nendmodule",
        "module_name": "pipelined_4bit_adder",
        "module_hash": "64d47a4c79e0f229450a0f6bce65966b",
        "dataset_index": 3586
      },
      "cclk_detector #_9bc5a9c4": {
        "rtl_code": "module cclk_detector #(\n    parameter CLK_RATE = 50000000\n    )(\n    input clk,\n    input rst,\n    input cclk,\n    output ready\n);\n\n    parameter CTR_SIZE = $clog2(CLK_RATE/50000);\n\n    reg [CTR_SIZE-1:0] ctr_d, ctr_q;\n    reg ready_d, ready_q;\n\n    assign ready = ready_q;\n\n    always @(ctr_q or cclk) begin\n        ready_d = 1'b0;\n        if (cclk == 1'b0) begin ctr_d = 1'b0;\n        end else if (ctr_q != {CTR_SIZE{1'b1}}) begin\n            ctr_d = ctr_q + 1'b1; end else begin\n            ctr_d = ctr_q;\n            ready_d = 1'b1; end\n\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            ctr_q <= 1'b0;\n            ready_q <= 1'b0;\n        end else begin\n            ctr_q <= ctr_d;\n            ready_q <= ready_d;\n        end\n    end\nendmodule\n",
        "module_name": "cclk_detector #",
        "module_hash": "9bc5a9c45f8d25b539f66b1ab2da9491",
        "dataset_index": 25811
      },
      "twos_complement_adder_63797ff9": {
        "rtl_code": "\nmodule twos_complement_adder (\n  input clk,\n  input reset,\n  input signed [3:0] A,\n  input signed [3:0] B,\n  output reg signed [4:0] C,\n  output reg overflow\n);\n\nreg signed [3:0] sum;\nreg carry;\n\nalways @(posedge clk, posedge reset) begin\n  if (reset) begin\n    sum <= 4'b0;\n    carry <= 1'b0;\n    C <= 5'b0;\n    overflow <= 1'b0;\n  end else begin\n    sum <= A + B + carry;\n    carry <= (sum[3] == 1);\n    C <= {carry, sum};\n    overflow <= ((A[3] == B[3]) && (A[3] != sum[3]));\n  end\nend\n\nendmodule",
        "module_name": "twos_complement_adder",
        "module_hash": "63797ff9d45c61934c068f7f35f5966b",
        "dataset_index": 18542
      },
      "hi_iso14443a_9ce25c54": {
        "rtl_code": "module hi_iso14443a(\n    pck0, ck_1356meg, ck_1356megb,\n    pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4,\n    adc_d, adc_clk,\n    ssp_frame, ssp_din, ssp_dout, ssp_clk,\n    cross_hi, cross_lo,\n    dbg,\n    mod_type\n);\n    input pck0, ck_1356meg, ck_1356megb;\n    output pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4;\n    input [7:0] adc_d;\n    output adc_clk;\n    input ssp_dout;\n    output ssp_frame, ssp_din, ssp_clk;\n    input cross_hi, cross_lo;\n    output dbg;\n    input [2:0] mod_type;\n\nreg ssp_clk;\nreg ssp_frame;\n\nreg fc_div_2;\nalways @(posedge ck_1356meg)\n    fc_div_2 = ~fc_div_2;\n\nwire adc_clk;\nassign adc_clk = ck_1356meg;\n\nreg after_hysteresis, after_hysteresis_prev1, after_hysteresis_prev2, after_hysteresis_prev3;\nreg [11:0] has_been_low_for;\nreg [8:0] saw_deep_modulation;\nreg [2:0] deep_counter;\nreg deep_modulation;\nalways @(negedge adc_clk)\nbegin\n\tif(& adc_d[7:6]) after_hysteresis <= 1'b1;\t\t\telse if(~(| adc_d[7:4])) after_hysteresis <= 1'b0;  if(~(| adc_d[7:0]))\n\tbegin\n\t\tif(deep_counter == 3'd7)\n\t\tbegin\n\t\t\tdeep_modulation <= 1'b1;\n\t\t\tsaw_deep_modulation <= 8'd0;\n\t\tend\n\t\telse\n\t\t\tdeep_counter <= deep_counter + 1;\n\tend\n\telse\n\tbegin\n\t\tdeep_counter <= 3'd0;\n\t\tif(saw_deep_modulation == 8'd255)\n\t\t\tdeep_modulation <= 1'b0;\n\t\telse\n\t\t\tsaw_deep_modulation <= saw_deep_modulation + 1;\n\tend\n\t\n\tif(after_hysteresis)\n    begin\n        has_been_low_for <= 7'b0;\n    end\n    else\n    begin\n        if(has_been_low_for == 12'd4095)\n        begin\n            has_been_low_for <= 12'd0;\n            after_hysteresis <= 1'b1;\n        end\n        else\n            has_been_low_for <= has_been_low_for + 1;\n    end\nend\n\nreg [5:0] negedge_cnt;\nreg bit1, bit2, bit3;\nreg [3:0] count_ones;\nreg [3:0] count_zeros;\nreg [7:0] rx_mod_edge_threshold;\nreg curbit;\nreg [7:0] adc_d_1;\nreg [7:0] adc_d_2;\nreg [7:0] adc_d_3;\nreg [7:0] adc_d_4;\n\nwire signed [10:0] adc_d_filtered;\nassign adc_d_filtered = (adc_d_4 << 1) + adc_d_3 - adc_d_1 - (adc_d << 1);\n\nreg [7:0] rx_mod_falling_edge_max;\nreg [7:0] rx_mod_rising_edge_max;\n\nreg signed [7:0] to_arm;\n\n\nreg bit_to_arm;\nreg fdt_indicator, fdt_elapsed;\nreg [10:0] fdt_counter;\nreg [47:0] mod_sig_buf;\nwire mod_sig_buf_empty;\nreg [5:0] mod_sig_ptr;\nreg [3:0] mod_sig_flip;\nreg mod_sig, mod_sig_coil;\nreg temp_buffer_reset;\nreg sendbit;\n\nassign mod_sig_buf_empty = ~(|mod_sig_buf[47:0]);\nreg [2:0] ssp_frame_counter;\n\nalways @(negedge adc_clk)\nbegin\n\tif(fdt_counter == 11'd740) fdt_indicator = 1'b1; \tif(fdt_counter == 11'd1148) begin\n\t\tif(fdt_elapsed)\n\t\tbegin\n\t\t\tif(negedge_cnt[3:0] == mod_sig_flip[3:0]) mod_sig_coil <= mod_sig; end\n\t\telse\n\t\tbegin\n\t\t\tmod_sig_flip[3:0] <= negedge_cnt[3:0];\t\tmod_sig_coil <= mod_sig;\t\t\t\t\tfdt_elapsed = 1'b1;\n\t\t\tfdt_indicator = 1'b0;\n\n\t\t\tif(~(| mod_sig_ptr[5:0])) mod_sig_ptr <= 6'b001001;  \telse temp_buffer_reset = 1'b1; \t\t\t\t\t\t\tend\n\tend\n\telse\n\tbegin\n\t\tfdt_counter <= fdt_counter + 1; end\n\t\n\t\n\tif (adc_d_filtered > 0)\n\t\tbegin\n\t\tif (adc_d_filtered > rx_mod_falling_edge_max)\n\t\t\trx_mod_falling_edge_max <= adc_d_filtered;\n\t\tend\n\telse\n\t\tbegin\n\t\tif (-adc_d_filtered > rx_mod_rising_edge_max)\n\t\t\trx_mod_rising_edge_max <= -adc_d_filtered;\n\t\tend\n\t\t\n\tadc_d_4 <= adc_d_3;\n\tadc_d_3 <= adc_d_2;\n\tadc_d_2 <= adc_d_1;\n\tadc_d_1 <= adc_d;\n\n\t\t\n\n\tif(& negedge_cnt[3:0])  begin\n\t\tif(~after_hysteresis && mod_sig_buf_empty && ~((mod_type == 3'b100) || (mod_type == 3'b011) || (mod_type == 3'b010))) begin\n\t\t\tfdt_counter <= 11'd0;\n\t\t\tfdt_elapsed = 1'b0;\n\t\t\tfdt_indicator = 1'b0;\n\t\t\ttemp_buffer_reset = 1'b0;\n\t\t\tmod_sig_ptr <= 6'b000000;\n\t\tend\n\t\t\n\t\tif (rx_mod_falling_edge_max > 6 && rx_mod_rising_edge_max > 6)\n\t\t\t\tcurbit = 1'b1;\telse\n\t\t\t\tcurbit = 1'b0;\trx_mod_rising_edge_max <= 0;\n\t\trx_mod_falling_edge_max <= 0;\n\t\n\t\n\t\tif(mod_type == 3'b001) sendbit = after_hysteresis;\t\telse if(mod_type == 3'b010)\t\t\t\t\t\t\t\tbegin\n\t\t\tif(fdt_counter > 11'd772) sendbit = mod_sig_coil;\n\t\t\telse sendbit = fdt_indicator;\n\t\tend\n\t\telse if(mod_type == 3'b011) sendbit = curbit;\t\t\telse sendbit = 1'b0;\t\t\t\t\t\t\t\t\tend\n\n\tif(negedge_cnt == 7'd63)\n    begin\n\t\tif(deep_modulation)\n\t\tbegin\n\t\t\tto_arm <= {after_hysteresis_prev1,after_hysteresis_prev2,after_hysteresis_prev3,after_hysteresis,1'b0,1'b0,1'b0,1'b0};\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tto_arm <= {after_hysteresis_prev1,after_hysteresis_prev2,after_hysteresis_prev3,after_hysteresis,bit1,bit2,bit3,curbit};\n\t\tend\n\n        negedge_cnt <= 0;\n\t\n\tend\n    else\n    begin\n        negedge_cnt <= negedge_cnt + 1;\n    end\n\n    if(negedge_cnt == 6'd15)\n\tbegin\n        after_hysteresis_prev1 <= after_hysteresis;\n\t\tbit1 <= curbit;\n\tend\n    if(negedge_cnt == 6'd31)\n\tbegin\n        after_hysteresis_prev2 <= after_hysteresis;\n\t\tbit2 <= curbit;\n\tend\n    if(negedge_cnt == 6'd47)\n\tbegin\n        after_hysteresis_prev3 <= after_hysteresis;\n\t\tbit3 <= curbit;\n\tend\n\t\n\tif(mod_type != 3'b000)\t\t\tbegin\n\t\tif(negedge_cnt[3:0] == 4'b1000) begin\n\t\t\tmod_sig_buf[47:0] <= {mod_sig_buf[46:1], ssp_dout, 1'b0};  \t\t\tif((ssp_dout || (| mod_sig_ptr[5:0])) && ~fdt_elapsed)\t\t\t\tif(mod_sig_ptr == 6'b101110)\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\tmod_sig_ptr <= 6'b000000;\n\t\t\t\tend\n\t\t\t\telse mod_sig_ptr <= mod_sig_ptr + 1;\t\t\t\t\t\t\telse if(fdt_elapsed && ~temp_buffer_reset)\t\t\t\t\t\t\t\n\t\t\tbegin\n\t\t\t\tif(ssp_dout) temp_buffer_reset = 1'b1;\t\t\t\t\t\t\t\n\t\t\t\tif(mod_sig_ptr == 6'b000010) mod_sig_ptr <= 6'b001001;\t\t\telse mod_sig_ptr <= mod_sig_ptr - 1;\t\t\t\t\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(~mod_sig_buf[mod_sig_ptr-1] && ~mod_sig_buf[mod_sig_ptr+1]) mod_sig = 1'b0;\n\t\t\t\telse mod_sig = mod_sig_buf[mod_sig_ptr] & fdt_elapsed;\n\t\t\tend\n\t\tend\n\tend\n\t\n\tif(mod_type == 3'b000)\n\tbegin\n\t\tif(negedge_cnt[2:0] == 3'b100)\n\t\t\tssp_clk <= 1'b0;\n\t\t\t\n\t\tif(negedge_cnt[2:0] == 3'b000)\n\t\tbegin\n\t\t\tssp_clk <= 1'b1;\n\t\t\tif(negedge_cnt != 7'd0)\n\t\t\tbegin\n\t\t\t\tto_arm[7:1] <= to_arm[6:0];\n\t\t\tend\n\t\tend\n\n\t\tif(negedge_cnt[5:4] == 2'b00)\n\t\t\tssp_frame = 1'b1;\n\t\telse\n\t\t\tssp_frame = 1'b0;\n\t\t\n\t\tbit_to_arm = to_arm[7];\n\tend\n\telse\n\tbegin\n\t\tif(negedge_cnt[3:0] == 4'b1000) ssp_clk <= 1'b0;\n\n\t\tif(negedge_cnt[3:0] == 4'b0111)\n\t\tbegin\n\t\t\tif(ssp_frame_counter == 3'd7) ssp_frame_counter <= 3'd0;\n\t\t\telse ssp_frame_counter <= ssp_frame_counter + 1;\n\t\tend\n\n\t\tif(negedge_cnt[3:0] == 4'b0000)\n\t\tbegin\n\t\t\tssp_clk <= 1'b1;\n\t\tend\n\t\t\n\t\tssp_frame = (ssp_frame_counter == 3'd7);\n\t\n\t\tbit_to_arm = sendbit;\n\tend\n\t\nend\n\nassign ssp_din = bit_to_arm;\n\n\nwire modulating_carrier;\nassign modulating_carrier = (mod_sig_coil & negedge_cnt[3] & (mod_type == 3'b010));\t\t\t\t\tassign pwr_hi = (ck_1356megb & (((mod_type == 3'b100) & ~mod_sig_coil) || (mod_type == 3'b011)));\t\n\n\nassign pwr_oe1 = 1'b0;\nassign pwr_oe3 = 1'b0;\n\nassign pwr_oe4 = modulating_carrier;\n\nassign pwr_oe2 = 1'b0;\nassign pwr_lo = 1'b0;\n\n\nassign dbg = negedge_cnt[3];\n\nendmodule\n",
        "module_name": "hi_iso14443a",
        "module_hash": "9ce25c54563e5809202ef7664073c985",
        "dataset_index": 7681
      },
      "xor_gate_21c582a2": {
        "rtl_code": "module xor_gate (\n    input A,\n    input B,\n    output X\n);\n\n    assign X = A ^ B;\n\nendmodule",
        "module_name": "xor_gate",
        "module_hash": "21c582a26946732d0b5e4447827d0e19",
        "dataset_index": 4932
      },
      "four_bit_adder_5ebde6c8": {
        "rtl_code": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "5ebde6c87521acbc65c1a64a05c39cba",
        "dataset_index": 4158
      },
      "my__ceea9704": {
        "rtl_code": "module my_module (\n    input clk,\n    input reset,\n    output reg [3:0] output1,\n    output reg [3:0] output2\n);\n\n    wire VPWR;\n    wire VGND;\n    //sky130_fd_sc_hs__tapvgnd my_tapvgnd (\n    //    .VPWR(VPWR),\n    //    .VGND(VGND)\n    //);\n\n    integer count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    always @* begin\n        output1 = count;\n        output2 = ~count;\n    end\n\nendmodule",
        "module_name": "my_",
        "module_hash": "ceea9704436357c28beb037a1d4b4db2",
        "dataset_index": 4873
      },
      "profibus_master_c9e9f911": {
        "rtl_code": "\nmodule profibus_master (\n  input clk,\n  input reset,\n  input tx_en,\n  input [7:0] tx_data,\n  output tx_busy,\n  output reg tx_complete,\n  output reg [7:0] rx_data,\n  input rx_complete,\n  output reg rx_en = 0\n);\n\n  // Define states for the state machine\n  parameter IDLE = 0;\n  parameter TX_START = 1;\n  parameter TX_DATA = 2;\n  parameter RX_START = 3;\n  parameter RX_DATA = 4;\n\n  // Define variables for the state machine\n  reg [2:0] state = IDLE;\n  reg [7:0] tx_buffer;\n  reg [7:0] rx_buffer;\n  reg tx_busy_int = 0;\n  reg rx_en_int = 0;\n\n  // Define timing parameters\n  parameter BIT_TIME = 10; // 10 clock cycles per bit\n  parameter START_DELAY = 5; // 5 bit times before start bit\n  parameter STOP_DELAY = 2; // 2 bit times after stop bit\n\n  // Define counter for timing\n  reg [3:0] bit_counter = 0;\n\n  // Define output signals\n  assign tx_busy = tx_busy_int;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      tx_busy_int <= 0;\n      tx_complete <= 0;\n      rx_data <= 0;\n      bit_counter <= 0;\n    end\n    else begin\n      case (state)\n        IDLE: begin\n          if (tx_en) begin\n            tx_buffer <= tx_data;\n            tx_busy_int <= 1;\n            state <= TX_START;\n          end\n          else if (rx_complete) begin\n            rx_data <= rx_buffer;\n          end\n        end\n        TX_START: begin\n          if (bit_counter == 0) begin\n            rx_en_int <= 1;\n          end\n          else if (bit_counter == START_DELAY) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            state <= TX_DATA;\n          end\n        end\n        TX_DATA: begin\n          if (bit_counter == 0) begin\n            rx_en_int <= 1;\n            tx_buffer <= {1'b0, tx_buffer[7:1]};\n            bit_counter <= 1;\n          end\n          else if (bit_counter == BIT_TIME) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            if (tx_buffer == 0) begin\n              state <= RX_START;\n            end\n            else begin\n              state <= TX_DATA;\n            end\n          end\n        end\n        RX_START: begin\n          if (bit_counter == 0) begin\n            rx_en_int <= 1;\n          end\n          else if (bit_counter == START_DELAY) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            state <= RX_DATA;\n          end\n        end\n        RX_DATA: begin\n          if (bit_counter == 0) begin\n            rx_buffer <= {rx_buffer[6:0], rx_en_int};\n            bit_counter <= 1;\n          end\n          else if (bit_counter == BIT_TIME) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            if (rx_buffer[7]) begin\n              rx_en_int <= 0;\n              state <= IDLE;\n            end\n            else begin\n              state <= RX_DATA;\n            end\n          end\n        end\n      endcase\n      if (tx_busy_int && state == IDLE) begin\n        tx_busy_int <= 0;\n        tx_complete <= 1;\n      end\n      bit_counter <= bit_counter + 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "profibus_master",
        "module_hash": "c9e9f911f7ec6e7caf9c57797a5abc4c",
        "dataset_index": 20228
      },
      "wire_recorder_b5c506d7": {
        "rtl_code": "module wire_recorder(\n    input wire clk,\n    input wire reset,\n    input wire [156:0] input_vector,\n    input wire [129:0] output_vector,\n    output reg [156:0] input_vector_reg,\n    output reg [129:0] output_vector_reg,\n    output reg clk_start\n);\n\n\nalways @(posedge clk) begin\n    if(reset) begin\n        input_vector_reg <= 0;\n        output_vector_reg <= 0;\n        clk_start <= 1'b0;\n    end else begin\n        input_vector_reg <= input_vector;\n        output_vector_reg <= output_vector;\n        clk_start <= (output_vector_reg[0] == 1'b1) ? 1'b1 : clk_start; \n    end\nend\n\nendmodule\n",
        "module_name": "wire_recorder",
        "module_hash": "b5c506d7c644c14ce81c5aad9da6c922",
        "dataset_index": 6814
      },
      "mux_4to1_d39fbdb5": {
        "rtl_code": "module mux_4to1(\n    input a,\n    input b,\n    input c,\n    input d,\n    input sel_1,\n    input sel_0,\n    output reg out_always\n);\n\nalways @(*) begin\n    if(sel_1 == 0 && sel_0 == 0) begin\n        out_always = a;\n    end\n    else if(sel_1 == 0 && sel_0 == 1) begin\n        out_always = b;\n    end\n    else if(sel_1 == 1 && sel_0 == 0) begin\n        out_always = c;\n    end\n    else begin\n        out_always = d;\n    end\nend\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "d39fbdb5ed61a9b9f19d2927d834a15c",
        "dataset_index": 15724
      },
      "sky130_fd_sc_ms__nand4_a618fc4a": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, D, C, B, A     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__nand4",
        "module_hash": "a618fc4a10b3a7daa58dff327216f57d",
        "dataset_index": 8786
      },
      "up_counter_6b5b551e": {
        "rtl_code": "module up_counter(\n    input clk,\n    input reset_n,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "6b5b551e74705842696172c2da1659ac",
        "dataset_index": 1002
      },
      "top__ac010738": {
        "rtl_code": "module top_module (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] a, b, c, d,     // Input ports for the minimum circuit\n    input wire [7:0] in_hi,          // Input port for the combinational circuit\n    input wire [7:0] in_lo,          // Input port for the combinational circuit\n    input wire select,               // Select input to choose between the two given modules\n    output wire [7:0] min_out,       // Output port from the minimum circuit\n    output wire [15:0] comb_out,     // Output port from the combinational circuit\n    output wire [15:0] final_out     // Final output from the functional module\n);\n\n// Instantiate the minimum circuit module\nminimum_circuit min_circuit(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .out(min_out)\n);\n\n// Instantiate the combinational circuit module\ncombinational_circuit comb_circuit(\n    .in_hi(in_hi),\n    .in_lo(in_lo),\n    .out(comb_out)\n);\n\n// Instantiate the addictive control logic module\nadditive_control_logic add_control(\n    .select(select),\n    .min_out(min_out),\n    .comb_out(comb_out),\n    .final_out(final_out)\n);\n\nendmodule\n\n// Define the minimum circuit module\nmodule minimum_circuit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire [7:0] c,\n    input wire [7:0] d,\n    output wire [7:0] out\n);\n\n// Find the minimum value of the four input values\nassign out = (a < b) ? ((a < c) ? ((a < d) ? a : d) : ((c < d) ? c : d)) : ((b < c) ? ((b < d) ? b : d) : ((c < d) ? c : d));\n\nendmodule\n\n// Define the combinational circuit module\nmodule combinational_circuit (\n    input wire [7:0] in_hi,\n    input wire [7:0] in_lo,\n    output wire [15:0] out\n);\n\n// Combine the two input bytes into a half-word\nassign out = {in_hi, in_lo};\n\nendmodule\n\n// Define the addictive control logic module\nmodule additive_control_logic (\n    input wire select,\n    input wire [7:0] min_out,\n    input wire [15:0] comb_out,\n    output wire [15:0] final_out\n);\n\n// Choose between the two given modules based on the select input and compute the final output\nassign final_out = (select == 1'b0) ? (min_out + comb_out) : (min_out - comb_out);\n\nendmodule",
        "module_name": "top_",
        "module_hash": "ac01073821bcfd81bb70eb1accef58c3",
        "dataset_index": 8411
      },
      "priority_encoder_cbbf1b38": {
        "rtl_code": "module priority_encoder (\n  input clk, rst,\n  input [3:0] in,\n  output reg [1:0] out\n);\n\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      out <= 2'b00;\n    end else begin\n      casez(in)\n        4'b0001: out <= 2'b00;\n        4'b0010: out <= 2'b01;\n        4'b0100: out <= 2'b10;\n        4'b1000: out <= 2'b11;\n        default: out <= 2'b00;\n      endcase\n    end\n  end\n  \nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "cbbf1b386bfc9f2bc8ffecf03044a0fb",
        "dataset_index": 19334
      },
      "rca_top_0e911f0c": {
        "rtl_code": "module rca_top(\n    output reg [15:0] final_output,\n    output reg carry_output,\n    input [15:0]input1, input2\n    );\n\nreg carry_in;\t\ttask CRAFA_module(\n    output reg sum,carry,\n    input in1,in2,carry_in\n    );\n\nreg intermediate, gen, propagate;\nbegin\npropagate = in1 ^ in2;\nsum = propagate ^ carry_in;\ngen = in1 & in2;\nintermediate = propagate & carry_in;\ncarry = intermediate | gen;\nend\nendtask\n\ntask CRA4bit(\n    output reg [3:0] cra_sum,\n    output reg cra_carry_out,\n    input [3:0] in1,in2,\n    input carry_in\n    );\nreg carry1,carry2,carry3;\nbegin\nCRAFA_module \t(cra_sum[0],carry1,in1[0],in2[0],carry_in);\nCRAFA_module\t(cra_sum[1],carry2,in1[1],in2[1],carry1);\nCRAFA_module\t(cra_sum[2],carry3,in1[2],in2[2],carry2);\nCRAFA_module\t(cra_sum[3],cra_carry_out,in1[3],in2[3],carry3);\nend\nendtask\n\t \t \ntask CRA16bit(\n    output reg [15:0] cra_sum,\n    output reg cra_carry_out,\n    input [15:0] in1,in2,\n    input carry_in\n    );\nreg carry1,carry2,carry3;\nbegin\nCRA4bit\t(cra_sum[3:0],carry1,in1[3:0],in2[3:0],carry_in);\nCRA4bit\t(cra_sum[7:4],carry2,in1[7:4],in2[7:4],carry1);\nCRA4bit\t(cra_sum[11:8],carry3,in1[11:8],in2[11:8],carry2);\nCRA4bit\t(cra_sum[15:12],cra_carry_out,in1[15:12],in2[15:12],carry3);\nend\nendtask\n\nalways@*\nbegin\n\tcarry_in = 1'b0;\n\tCRA16bit(final_output, carry_output, input1, input2, carry_in);\n\nend\t\nendmodule\n",
        "module_name": "rca_top",
        "module_hash": "0e911f0c4edb20d11f30a1285f1f4d4f",
        "dataset_index": 22934
      },
      "barrel_shifter_16bit_df34a5b6": {
        "rtl_code": "module barrel_shifter_16bit (\n    input [15:0] data,\n    input [3:0] shift_amount,\n    output reg [15:0] out\n);\n\nreg [15:0] stage1_out;\nreg [15:0] stage2_out;\n\nalways @(*) begin\n    stage1_out = (shift_amount[3]) ? data << 8 : data;\nend\n\nalways @(*) begin\n    stage2_out = (shift_amount[2]) ? stage1_out << 4 : stage1_out;\nend\n\nalways @(*) begin\n    out = (shift_amount[1]) ? stage2_out << 2 : stage2_out;\nend\n\nendmodule",
        "module_name": "barrel_shifter_16bit",
        "module_hash": "df34a5b612bde513803d24f8b6ae3dad",
        "dataset_index": 2423
      },
      "sky130_fd_sc_hd__nor2_4cf1203e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B           );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nor2",
        "module_hash": "4cf1203e0094e94cb866cbb5d246c60f",
        "dataset_index": 10867
      },
      "opModule_fef43f1c": {
        "rtl_code": "\nmodule opModule (clk, iA, iB, iC, oResult);\n    input clk;\n    input [3:0] iA;\n    input [3:0] iB;\n    input iC;\n    output [3:0] oResult;\n\n    reg [3:0] oResult_reg; // Declare oResult as a register\n\n    always @(posedge clk) begin\n        if (iC == 0) begin\n            oResult_reg <= iA & iB;\n        end else begin\n            oResult_reg <= iA | iB;\n        end\n    end\n\n    assign oResult = oResult_reg; // Assign the value of oResult_reg to oResult\nendmodule\n",
        "module_name": "opModule",
        "module_hash": "fef43f1c1317e605a8f9de8f92db3132",
        "dataset_index": 13964
      },
      "nand_gate_5d2340e8": {
        "rtl_code": "module nand_gate (\n    input A,\n    input B,\n    output X\n);\n\n    assign X = ~(A & B);\n\nendmodule\n\nmodule and_gate (\n    input A,\n    input B,\n    output X\n);\n\n    wire nand1_out;\n    wire nand2_out;\n\n    nand_gate nand1(.A(A), .B(A), .X(nand1_out));\n    nand_gate nand2(.A(B), .B(B), .X(nand2_out));\n    nand_gate nand3(.A(nand1_out), .B(nand2_out), .X(X));\n\nendmodule",
        "module_name": "nand_gate",
        "module_hash": "5d2340e8357f1ca2ea9be4be3839a0ae",
        "dataset_index": 980
      },
      "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W32_0_7_8f1b8548": {
        "rtl_code": "module SNPS_CLOCK_GATE_HIGH_RegisterAdd_W32_0_7 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  wire E, SE, CK, ECK;\n\n  assign E = TE;\n  assign SE = EN;\n  assign CK = CLK;\n  assign ENCLK = EN ? ECK : 1'b0;\n\n  TLATNTSCAX2TS latch ( .E(E), .SE(SE), .CK(CK), .ECK(ECK) );\n\nendmodule\n\nmodule TLATNTSCAX2TS ( E, SE, CK, ECK );\n  input E, SE, CK;\n  output reg ECK;\n\n  always @(posedge CK) begin\n    if (SE) ECK <= E;\n  end\nendmodule",
        "module_name": "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W32_0_7",
        "module_hash": "8f1b854897dba1a4ae26368afd8b0ffd",
        "dataset_index": 6164
      },
      "top__3639af79": {
        "rtl_code": "module top_module (\n    input [1:0] decoder_in,\n    input [3:0] alu_A,\n    input [3:0] alu_B,\n    input [2:0] alu_OP,\n    output reg [3:0] final_output\n);\n\n    wire [3:0] alu_output;\n    wire [3:0] decoder_out;\n\n    decoder_2to4 decoder(\n        .in(decoder_in),\n        .out(decoder_out)\n    );\n\n    alu_4bit alu(\n        .A(alu_A),\n        .B(alu_B),\n        .OP(alu_OP),\n        .out(alu_output)\n    );\n\n    always @(*) begin\n        case(decoder_out)\n            4'b0001: final_output = alu_output[0];\n            4'b0010: final_output = alu_output[1];\n            4'b0100: final_output = alu_output[2];\n            4'b1000: final_output = alu_output[3];\n            default: final_output = 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule decoder_2to4 (\n    input [1:0] in,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(in)\n            2'b00: out = 4'b0001;\n            2'b01: out = 4'b0010;\n            2'b10: out = 4'b0100;\n            2'b11: out = 4'b1000;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule alu_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] OP,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(OP)\n            3'b000: out = A + B;\n            3'b001: out = A - B;\n            3'b010: out = A & B;\n            3'b011: out = A | B;\n            3'b100: out = A ^ B;\n            3'b101: out = ~A;\n            3'b110: out = ~B;\n            3'b111: out = 4'b0000;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "3639af79c96f160fa7aebe1f2bed0c68",
        "dataset_index": 15103
      },
      "ring_counter #_545356dd": {
        "rtl_code": "module ring_counter #(\n  parameter n = 4 // number of output signals\n)(\n  input clk,\n  output [n-1:0] out\n);\n\nreg [n-1:0] counter;\n\nalways @(posedge clk) begin\n  counter <= {counter[n-2:0], counter[n-1]};\nend\n\nassign out = counter;\n\nendmodule",
        "module_name": "ring_counter #",
        "module_hash": "545356dd537dccb817314f91f6f0401a",
        "dataset_index": 11199
      },
      "exercise_8_10_8aa4c0cf": {
        "rtl_code": "module exercise_8_10 (output reg [1:0] state, input x, y, Clk);\n    initial state = 2'b00;\n    always @ (posedge Clk) begin\n        case ({x,y})\n            2'b00: begin if (state == 2'b00) state <= state; \n                else if (state == 2'b01) state <= 2'b10; \n                else if (state == 2'b10) state <= 2'b00; \n                else state <= 2'b10;\n                end\n            2'b01: begin if (state == 2'b00) state <= state;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b00;\n                    else state <= state;\n                    end\n            2'b10: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b10;\n                    else if (state == 2'b10) state <= state;\n                    else state <= 2'b00;\n                    end\n            2'b11: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b11;\n                    else state <= 2'b00;\n                    end\n        endcase\n    end\nendmodule",
        "module_name": "exercise_8_10",
        "module_hash": "8aa4c0cf4ab29c6adff385ab6f3d8463",
        "dataset_index": 20539
      },
      "r_DEVICE_CAPABILITIES_2_HIGH_4aec6f44": {
        "rtl_code": "\nmodule r_DEVICE_CAPABILITIES_2_HIGH(output reg [7:0] reg_0x2A, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk, input wire select);\n\treg [7:0] reg_0x25;\n\t\n\tr_DEVICE_CAPABILITIES_1_HIGH r_device_capabilities_1_high_inst( .reg_0x25(reg_0x25), .reset(reset), .wenb(wenb), .in_data(in_data), .clk(clk));\n\t\n\talways@(posedge clk)\n\tbegin\n\t\tif(reset==1)\n\t\t\treg_0x2A<=8'h00;\n\t\telse if(select==0)\n\t\tbegin\n\t\t\tif(wenb==0)\n\t\t\t\treg_0x2A<=in_data;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(wenb==0)\n\t\t\t\treg_0x2A<=reg_0x25;\n\t\tend\n\tend\nendmodule\nmodule r_DEVICE_CAPABILITIES_1_HIGH(output reg [7:0] reg_0x25, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n\n\talways@(posedge clk)\n\tbegin\n\t\tif(reset==1)\n\t\t\treg_0x25<=8'h00;\n\t\telse if(wenb==0)\n\t\t\treg_0x25<=in_data;\n\tend\nendmodule",
        "module_name": "r_DEVICE_CAPABILITIES_2_HIGH",
        "module_hash": "4aec6f443fcf9648ab8e86a40d0c31ff",
        "dataset_index": 8238
      },
      "signal_combiner_04e0bd74": {
        "rtl_code": "module signal_combiner (\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  B2  ,\n    input  C1  ,\n    output Y   ,\n    input  VPWR,\n    input  VGND\n);\n\n    assign Y = (A1 & A2) | (B1 & B2) | C1;\n\nendmodule",
        "module_name": "signal_combiner",
        "module_hash": "04e0bd7416e528eb80582b8302811198",
        "dataset_index": 9303
      },
      "chatgpt_generate_edge_detect_5981dd4d": {
        "rtl_code": "module chatgpt_generate_edge_detect(\n  input               clk,\n  input               rst_n,\n  input               a,\n  input               select,\n  output reg          rise,\n  output reg          fall\n);\n\n  // State definitions\n  parameter IDLE = 2'b00;\n  parameter RISE_DETECT = 2'b01;\n  parameter FALL_DETECT = 2'b10;\n\n  // State register and next state logic\n  reg [1:0] state, next_state;\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Output register and logic\n  reg active_edge;\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      active_edge <= 1'b0;\n    end else begin\n      case (state)\n        IDLE: begin\n          active_edge <= 1'b0;\n        end\n        RISE_DETECT: begin\n          active_edge <= 1'b1;\n        end\n        FALL_DETECT: begin\n          active_edge <= 1'b0;\n        end\n      endcase\n    end\n  end\n\n  // State transition logic\n  always @(*) begin\n    case (state)\n      IDLE: begin\n        if (select) begin\n          if (a) begin\n            next_state = RISE_DETECT;\n          end else begin\n            next_state = FALL_DETECT;\n          end\n        end else begin\n          next_state = IDLE;\n        end\n      end\n      RISE_DETECT: begin\n        if (~a) begin\n          next_state = IDLE;\n        end else begin\n          next_state = RISE_DETECT;\n        end\n      end\n      FALL_DETECT: begin\n        if (a) begin\n          next_state = IDLE;\n        end else begin\n          next_state = FALL_DETECT;\n        end\n      end\n    endcase\n  end\n\n  // Output logic\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      rise <= 1'b0;\n      fall <= 1'b0;\n    end else begin\n      case (state)\n        IDLE: begin\n          rise <= 1'b0;\n          fall <= 1'b0;\n        end\n        RISE_DETECT: begin\n          rise <= 1'b1;\n          fall <= 1'b0;\n        end\n        FALL_DETECT: begin\n          rise <= 1'b0;\n          fall <= 1'b1;\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "chatgpt_generate_edge_detect",
        "module_hash": "5981dd4d766e236229d38bbec898982e",
        "dataset_index": 1497
      },
      "calculator_f76a5b6b": {
        "rtl_code": "module calculator(\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] opcode,\n    output reg [3:0] result\n);\n\nalways @(*) begin\n    case(opcode)\n        2'b00: result = A + B;\n        2'b01: result = A - B;\n        2'b10: result = A * B;\n        2'b11: result = A / B;\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "f76a5b6b7f25bdc052485758516943f4",
        "dataset_index": 9479
      },
      "mux4to1_117f4c8f": {
        "rtl_code": "\nmodule mux4to1(\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            2'b00: out = in0;\n            2'b01: out = in1;\n            2'b10: out = in1;  // Fix the issue here: changing 2'b10 to 2'b11\n            2'b11: out = in1;\n        endcase\n    end\n    \nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "117f4c8f362a0ea4c2793296b716204d",
        "dataset_index": 18106
      },
      "xcvr_ctrl_883c0c8c": {
        "rtl_code": "\n\n`resetall\n\n\n\n\nmodule xcvr_ctrl (\n    input  wire        reconfig_clk,\n    input  wire        reconfig_rst,\n\n    input  wire        pll_locked_in,\n\n    output wire [18:0] xcvr_reconfig_address,\n    output wire        xcvr_reconfig_read,\n    output wire        xcvr_reconfig_write,\n    input  wire [7:0]  xcvr_reconfig_readdata,\n    output wire [7:0]  xcvr_reconfig_writedata,\n    input  wire        xcvr_reconfig_waitrequest\n);\n\nlocalparam [3:0]\n    STATE_IDLE = 4'd0,\n    STATE_LOAD_PMA_1 = 4'd1,\n    STATE_LOAD_PMA_2 = 4'd2,\n    STATE_INIT_ADAPT_1 = 4'd3,\n    STATE_INIT_ADAPT_2 = 4'd4,\n    STATE_INIT_ADAPT_3 = 4'd5,\n    STATE_INIT_ADAPT_4 = 4'd6,\n    STATE_CONT_ADAPT_1 = 4'd7,\n    STATE_CONT_ADAPT_2 = 4'd8,\n    STATE_CONT_ADAPT_3 = 4'd9,\n    STATE_CONT_ADAPT_4 = 4'd10,\n    STATE_DONE = 4'd11;\n\nreg [3:0] state_reg = STATE_IDLE, state_next;\n\nreg [18:0] xcvr_reconfig_address_reg = 19'd0, xcvr_reconfig_address_next;\nreg xcvr_reconfig_read_reg = 1'b0, xcvr_reconfig_read_next;\nreg xcvr_reconfig_write_reg = 1'b0, xcvr_reconfig_write_next;\nreg [7:0] xcvr_reconfig_writedata_reg = 8'd0, xcvr_reconfig_writedata_next;\n\nreg [7:0] read_data_reg = 8'd0, read_data_next;\nreg read_data_valid_reg = 1'b0, read_data_valid_next;\n\nreg [15:0] delay_count_reg = 0, delay_count_next;\n\nreg pll_locked_sync_1_reg = 0;\nreg pll_locked_sync_2_reg = 0;\nreg pll_locked_sync_3_reg = 0;\n\nassign xcvr_reconfig_address = xcvr_reconfig_address_reg;\nassign xcvr_reconfig_read = xcvr_reconfig_read_reg;\nassign xcvr_reconfig_write = xcvr_reconfig_write_reg;\nassign xcvr_reconfig_writedata = xcvr_reconfig_writedata_reg;\n\nalways @(posedge reconfig_clk) begin\n    pll_locked_sync_1_reg <= pll_locked_in;\n    pll_locked_sync_2_reg <= pll_locked_sync_1_reg;\n    pll_locked_sync_3_reg <= pll_locked_sync_2_reg;\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    xcvr_reconfig_address_next = xcvr_reconfig_address_reg;\n    xcvr_reconfig_read_next = 1'b0;\n    xcvr_reconfig_write_next = 1'b0;\n    xcvr_reconfig_writedata_next = xcvr_reconfig_writedata_reg;\n\n    read_data_next = read_data_reg;\n    read_data_valid_next = read_data_valid_reg;\n\n    delay_count_next = delay_count_reg;\n\n    if (xcvr_reconfig_read_reg || xcvr_reconfig_write_reg) begin\n        if (xcvr_reconfig_waitrequest) begin\n            xcvr_reconfig_read_next = xcvr_reconfig_read_reg;\n            xcvr_reconfig_write_next = xcvr_reconfig_write_reg;\n        end else begin\n            xcvr_reconfig_read_next = 1'b0;\n            xcvr_reconfig_write_next = 1'b0;\n\n            if (xcvr_reconfig_read_reg) begin\n                read_data_next = xcvr_reconfig_readdata;\n                read_data_valid_next = 1'b1;\n            end\n        end\n        state_next = state_reg;\n    end else if (delay_count_reg != 0) begin\n        delay_count_next = delay_count_reg - 1;\n        state_next = state_reg;\n    end else begin\n        read_data_valid_next = 1'b0;\n\n        case (state_reg)\n            STATE_IDLE: begin\n                if (pll_locked_sync_3_reg) begin\n                    delay_count_next = 16'hffff;\n                    state_next = STATE_LOAD_PMA_1;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_LOAD_PMA_1: begin\n                xcvr_reconfig_address_next = 19'h40143;\n                xcvr_reconfig_writedata_next = 8'h80;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_LOAD_PMA_2;\n            end\n            STATE_LOAD_PMA_2: begin\n                if (read_data_valid_reg && read_data_reg[0]) begin\n                    xcvr_reconfig_address_next = 19'h200;\n                    xcvr_reconfig_writedata_next = 8'hD2;\n                    xcvr_reconfig_write_next = 1'b1;\n                    state_next = STATE_INIT_ADAPT_1;\n                end else begin\n                    xcvr_reconfig_address_next = 19'h40144;\n                    xcvr_reconfig_read_next = 1'b1;\n                    state_next = STATE_LOAD_PMA_2;\n                end\n            end\n            STATE_INIT_ADAPT_1: begin\n                xcvr_reconfig_address_next = 19'h201;\n                xcvr_reconfig_writedata_next = 8'h02;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_INIT_ADAPT_2;\n            end\n            STATE_INIT_ADAPT_2: begin\n                xcvr_reconfig_address_next = 19'h202;\n                xcvr_reconfig_writedata_next = 8'h01;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_INIT_ADAPT_3;\n            end\n            STATE_INIT_ADAPT_3: begin\n                xcvr_reconfig_address_next = 19'h203;\n                xcvr_reconfig_writedata_next = 8'h96;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_INIT_ADAPT_4;\n            end\n            STATE_INIT_ADAPT_4: begin\n                if (read_data_valid_reg && read_data_reg == 8'h80) begin\n                    xcvr_reconfig_address_next = 19'h200;\n                    xcvr_reconfig_writedata_next = 8'hF6;\n                    xcvr_reconfig_write_next = 1'b1;\n                    state_next = STATE_CONT_ADAPT_1;\n                end else begin\n                    xcvr_reconfig_address_next = 19'h207;\n                    xcvr_reconfig_read_next = 1'b1;\n                    state_next = STATE_INIT_ADAPT_4;\n                end\n            end\n            STATE_CONT_ADAPT_1: begin\n                xcvr_reconfig_address_next = 19'h201;\n                xcvr_reconfig_writedata_next = 8'h01;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_CONT_ADAPT_2;\n            end\n            STATE_CONT_ADAPT_2: begin\n                xcvr_reconfig_address_next = 19'h202;\n                xcvr_reconfig_writedata_next = 8'h03;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_CONT_ADAPT_3;\n            end\n            STATE_CONT_ADAPT_3: begin\n                xcvr_reconfig_address_next = 19'h203;\n                xcvr_reconfig_writedata_next = 8'h96;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_CONT_ADAPT_4;\n            end\n            STATE_CONT_ADAPT_4: begin\n                if (read_data_valid_reg && read_data_reg == 8'h80) begin\n                    state_next = STATE_DONE;\n                end else begin\n                    xcvr_reconfig_address_next = 19'h207;\n                    xcvr_reconfig_read_next = 1'b1;\n                    state_next = STATE_CONT_ADAPT_4;\n                end\n            end\n            STATE_DONE: begin\n                state_next = STATE_DONE;\n            end\n        endcase\n    end\n\n    if (!pll_locked_sync_3_reg) begin\n        state_next = STATE_IDLE;\n    end\nend\n\nalways @(posedge reconfig_clk) begin\n    state_reg <= state_next;\n\n    xcvr_reconfig_address_reg <= xcvr_reconfig_address_next;\n    xcvr_reconfig_read_reg <= xcvr_reconfig_read_next;\n    xcvr_reconfig_write_reg <= xcvr_reconfig_write_next;\n    xcvr_reconfig_writedata_reg <= xcvr_reconfig_writedata_next;\n\n    read_data_reg <= read_data_next;\n    read_data_valid_reg <= read_data_valid_next;\n\n    delay_count_reg <= delay_count_next;\n\n    if (reconfig_rst) begin\n        state_reg <= STATE_IDLE;\n\n        xcvr_reconfig_read_reg <= 1'b0;\n        xcvr_reconfig_write_reg <= 1'b0;\n\n        read_data_valid_reg <= 1'b0;\n\n        delay_count_reg <= 0;\n    end\nend\n\nendmodule\n\n`resetall\n",
        "module_name": "xcvr_ctrl",
        "module_hash": "883c0c8c2f9072a31c12c6785c374f17",
        "dataset_index": 21890
      },
      "unknown_module_3d3ce9be": {
        "rtl_code": "module\tanteconmutador\t(\n\t\t\t\t\tinput\t\t\tclk,\n\t\t\t\t\tinput\t\t[7:0]\tcount,\n\t\t\t\t\tinput\t\t\tcalculate,\n\t\t\t\t\toutput\treg\t[3:0]\tcentenas,\n\t\t\t\t\toutput\treg\t[3:0]\tdecenas,\n\t\t\t\t\toutput\treg\t[3:0]\tunidades,\n\t\t\t\t\toutput\treg\t\tC,\n\t\t\t\t\toutput\treg\t\tDe,\n\t\t\t\t\toutput\treg\t\tU\n\t\t\t);\n\treg\t[7:0]\tdigitT;\n\treg\t\ti;\n\t\n\tinitial\n\tbegin\n\t\tdigitT = 0;\n\t\tC = 0;\n\t\tDe = 0;\n\t\tU = 0;\n\t\tcentenas = 0;\n\t\tdecenas\t = 0;\n\t\tunidades = 0;\n\t\ti = 1;\n\tend\n\talways@(posedge clk)\n\tbegin\t\n\t\tif(calculate)\n\t\tbegin\n\t\t\tif(i)\n\t\t\tbegin\n\t\t\t\tdigitT = count;\n\t\t\t\ti = 0;\n\t\t\tend\n\t\t\tif(digitT>7'b1100011)\n\t\t\tbegin\n\t\t\t\tdigitT\t = digitT - 7'b1100100;\n\t\t\t\tcentenas = centenas + 1;\n\t\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(digitT>7'b0001001)\n\t\t\t\tbegin\n\t\t\t\t\tdigitT\t= digitT - 7'b0001010;\n\t\t\t\t\tdecenas\t= decenas + 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tunidades = {digitT[3:0]};\n\t\t\t\t\tif(centenas >= 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tC = 1;\n\t\t\t\t\tend\n\t\t\t\t\tif(decenas  >= 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tDe = 1;\n\t\t\t\t\tend\n\t\t\t\t\tif(unidades >= 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tU = 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(!calculate)\n\t\t\tbegin\n\t\t\t\tdigitT = 0;\n\t\t\t\tC = 0;\n\t\t\t\tDe = 0;\n\t\t\t\tU = 0;\n\t\t\t\ti = 1;\n\t\t\t\tcentenas = 0;\n\t\t\t\tdecenas\t = 0;\n\t\t\t\tunidades = 0;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "3d3ce9bed2910464be6c6a340a57d9ba",
        "dataset_index": 9686
      },
      "soc_design_SystemID_c0166723": {
        "rtl_code": "module soc_design_SystemID (\n  input [31:0] address,\n  input clock,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  always @(posedge clock) begin\n    if (!reset_n) begin\n      readdata <= 32'h00000000;\n    end else begin\n      case (address)\n        32'h0: readdata <= 32'hDEADBEEF;\n        32'h4: readdata <= 32'hCAFEBABE;\n        default: readdata <= 32'h00000000;\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "soc_design_SystemID",
        "module_hash": "c0166723bc6a8d50e5040ff7f949602c",
        "dataset_index": 3253
      },
      "clock_control_6858bd69": {
        "rtl_code": "module clock_control(\n    input inclk,\n    input ena,\n    output outclk\n);\n\nreg [1:0] state;\nreg filtered_clk;\n\nalways @(posedge inclk) begin\n    if (ena) begin\n        state <= {state[0], inclk};\n        if (state == 2'b01) begin\n            filtered_clk <= 1'b1;\n        end else if (state == 2'b10) begin\n            filtered_clk <= 1'b0;\n        end\n    end else begin\n        filtered_clk <= 1'b0;\n    end\nend\n\nassign outclk = filtered_clk;\n\nendmodule",
        "module_name": "clock_control",
        "module_hash": "6858bd690241a52c9cec7e5992646180",
        "dataset_index": 629
      },
      "control_ascci_7e7dd4ab": {
        "rtl_code": "\nmodule control_ascci(\n\tinput clk,\n\tinput top_ascci,\n\tinput top_col,\n\tinput new_string,\n\tinput done,\n\toutput reg add_dirram,\n\toutput reg reset_dirram,\n\toutput reg add_col,\n   \toutput reg reset_col,\n\toutput reg add_ascci,\n\toutput reg reset_ascci,\n\toutput reg init,\n\toutput reg leer_rom,\n\toutput reg leer_ram,\t\n\toutput reg run_efect );\n\treg [6:0] current_state;\n\treg [6:0] next_state;\n\t\n\tparameter start=7'b0000000, state_1=7'b0000001, state_2=7'b0000010, state_3=7'b0000011, state_4=7'b0000100, state_5=7'b0000101,check=7'b0000110,state_1p=7'b0000111; \n\n\talways @(top_ascci or done or top_col  or new_string or current_state)begin\n\t\tcase(current_state)\n     \t\tstart: \tbegin\t\t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b1;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b1;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\t\n\t\t\t\t\t\t\t\tleer_ram=1'b1;\n\n\t\t\t\t\t\t\t\tinit=0;    run_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif (new_string==1'b1 ) next_state<=state_1p;\n\t\t\t\t\t\telse next_state<=start;\n\t\t\t\t\tend\n\t\t\tstate_1p:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b1;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=1;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext_state<=state_1;\n\t\t\t\t\tend\n\t\t\tstate_1:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=1;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext_state<=state_2;\n\t\t\t\t\tend\n\t\t\tstate_2:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif(done==1'b1) next_state<=state_3;\n\t\t\t\t\telse next_state<=state_2;\n\t\t\t\t\tend\n\t\t\t\n\t\t\tstate_3:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\n\t\t\t\t\t\tnext_state<=state_4;\n\t\t\t\t\tend\n\t\t\tstate_4:\tbegin\t\tadd_dirram=1'b1;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b1;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif (top_col == 1'b1) next_state<=state_5;\n\t\t\t\t\t\telse next_state<=state_3;\n\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\tstate_5:\tbegin\t\tadd_dirram=1'b1;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b1;\n\t\t\t\t\t\t\t\tadd_ascci=1'b1;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif (top_ascci==1'b1)next_state<=check;\n\t\t\t\t\t\telse next_state<=state_1;\n\n\t\t\t\t\tend\n\t\t\tcheck: \tbegin\t\t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\t\n\t\t\t\t\t\t\t\tleer_ram=1'b1;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b1;\n\t\t\t\t\t\t\t\n\n\t\t\t\n\t\t\t\t\t\tif (new_string==1'b1) next_state<=start;\n\t\t\t\t\t\telse next_state<=check;\n\t\t\t\t\tend\n\t\t\t\n\t\t\tdefault:\n\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tnext_state<=start;\n\t\t\t\t\tend\n\t\tendcase\n\tend\t\n\n\talways @(negedge clk) begin\n\t    current_state<=next_state;\t\n\tend\nendmodule\n",
        "module_name": "control_ascci",
        "module_hash": "7e7dd4abb145206d823606e6ddaac52d",
        "dataset_index": 21685
      },
      "d_ff_6739875f": {
        "rtl_code": "\nmodule d_ff (\n    input clk,\n    input reset,\n    input set,\n    input enable,\n    input test,\n    input d,\n    output reg q\n);\n\n    // Voltage supply signals\n    supply1 vpwr;\n    supply0 vgnd;\n\n    // Internal signals\n    wire test_mux_out;\n    wire set_mux_out;\n    wire inv_out;\n    reg dff_in;\n\n    // Test Mux\n    assign test_mux_out = test ? d : 1'b0;\n\n    // Set Mux\n    assign set_mux_out = set ? 1'b1 : test_mux_out;\n\n    // Inverter\n    assign inv_out = ~set_mux_out;\n\n    // D Flip-Flop\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            dff_in <= 1'b0;\n        end else if (enable) begin\n            dff_in <= inv_out;\n        end\n    end\n\n    // Output Register\n    always @* begin\n        q <= dff_in;\n    end\n\nendmodule\n",
        "module_name": "d_ff",
        "module_hash": "6739875f1dc2fc33c237fb170c25eb7e",
        "dataset_index": 17560
      },
      "top__1c4af05d": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output out\n);\n\n    // Declare signals\n    wire transition_detected;\n    wire equal_a_b;\n\n    // Instantiate the transition detector module\n    transition_detector td (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .transition_detected(transition_detected)\n    );\n\n    // Instantiate the 4-bit comparator module\n    four_bit_comparator fbc (\n        .a(in[31:28]),\n        .b(in[27:24]),\n        .equal(equal_a_b)\n    );\n\n    // Instantiate the functional module\n    functional_module fm (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .equal(equal_a_b),\n        .out(out)\n    );\n\nendmodule\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg transition_detected\n);\n\n    reg [31:0] prev_in;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            prev_in <= 0;\n            transition_detected <= 0;\n        end else begin\n            if ((~prev_in[31] && in[31]) || (prev_in[31] && ~in[31])) begin\n                transition_detected <= 1;\n            end else begin\n                transition_detected <= 0;\n            end\n            prev_in <= in;\n        end\n    end\n\nendmodule\nmodule four_bit_comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg equal\n);\n\n    always @ (*) begin\n        if (a == b) begin\n            equal <= 1;\n        end else begin\n            equal <= 0;\n        end\n    end\n\nendmodule\nmodule functional_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    input equal,\n    output out\n);\n\n    reg [127:0] pattern = 128'h0000FFFF0000FFFF0000FFFF0000FFFF;\n    reg [31:0] pattern_index;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            pattern_index <= 0;\n        end else begin\n            if (equal) begin\n                pattern_index <= pattern_index + 1;\n            end\n            if (pattern_index == 31) begin\n                pattern_index <= 0;\n            end\n        end\n    end\n\n    assign out = pattern[pattern_index];\n\nendmodule",
        "module_name": "top_",
        "module_hash": "1c4af05d27adce25fdc9bf10f53b6d14",
        "dataset_index": 15387
      },
      "cf_mul_58393abf": {
        "rtl_code": "\n\nmodule cf_mul (\n\n  clk,\n  data_a,\n  data_b,\n  data_p,\n\n  ddata_in,\n  ddata_out);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input           clk;\n  input   [16:0]  data_a;\n  input   [ 7:0]  data_b;\n  output  [24:0]  data_p;\n  input   [DW:0]  ddata_in;\n  output  [DW:0]  ddata_out;\n\n  reg             p1_sign = 'd0;\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [23:0]  p1_data_p_0 = 'd0;\n  reg     [23:0]  p1_data_p_1 = 'd0;\n  reg     [23:0]  p1_data_p_2 = 'd0;\n  reg     [23:0]  p1_data_p_3 = 'd0;\n  reg     [23:0]  p1_data_p_4 = 'd0;\n  reg             p2_sign = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [23:0]  p2_data_p_0 = 'd0;\n  reg     [23:0]  p2_data_p_1 = 'd0;\n  reg             p3_sign = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [23:0]  p3_data_p_0 = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [24:0]  data_p = 'd0;\n\n  wire    [16:0]  p1_data_a_1p_17_s;\n  wire    [16:0]  p1_data_a_1n_17_s;\n  wire    [23:0]  p1_data_a_1p_s;\n  wire    [23:0]  p1_data_a_1n_s;\n  wire    [23:0]  p1_data_a_2p_s;\n  wire    [23:0]  p1_data_a_2n_s;\n\n  assign p1_data_a_1p_17_s = {1'b0, data_a[15:0]};\n  assign p1_data_a_1n_17_s = ~p1_data_a_1p_17_s + 1'b1;\n\n  assign p1_data_a_1p_s = {{7{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s};\n  assign p1_data_a_1n_s = {{7{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s};\n  assign p1_data_a_2p_s = {{6{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s, 1'b0};\n  assign p1_data_a_2n_s = {{6{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s, 1'b0};\n\n  always @(posedge clk) begin\n    p1_sign <= data_a[16];\n    p1_ddata <= ddata_in;\n    case (data_b[1:0])\n      2'b11: p1_data_p_0 <= p1_data_a_1n_s;\n      2'b10: p1_data_p_0 <= p1_data_a_2n_s;\n      2'b01: p1_data_p_0 <= p1_data_a_1p_s;\n      default: p1_data_p_0 <= 24'd0;\n    endcase\n    case (data_b[3:1])\n      3'b011: p1_data_p_1 <= {p1_data_a_2p_s[21:0], 2'd0};\n      3'b100: p1_data_p_1 <= {p1_data_a_2n_s[21:0], 2'd0};\n      3'b001: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b010: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b101: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      3'b110: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      default: p1_data_p_1 <= 24'd0;\n    endcase\n    case (data_b[5:3])\n      3'b011: p1_data_p_2 <= {p1_data_a_2p_s[19:0], 4'd0};\n      3'b100: p1_data_p_2 <= {p1_data_a_2n_s[19:0], 4'd0};\n      3'b001: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b010: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b101: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      3'b110: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      default: p1_data_p_2 <= 24'd0;\n    endcase\n    case (data_b[7:5])\n      3'b011: p1_data_p_3 <= {p1_data_a_2p_s[17:0], 6'd0};\n      3'b100: p1_data_p_3 <= {p1_data_a_2n_s[17:0], 6'd0};\n      3'b001: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b010: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b101: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      3'b110: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      default: p1_data_p_3 <= 24'd0;\n    endcase\n    case (data_b[7])\n      1'b1: p1_data_p_4 <= {p1_data_a_1p_s[15:0], 8'd0};\n      default: p1_data_p_4 <= 24'd0;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    p2_sign <= p1_sign;\n    p2_ddata <= p1_ddata;\n    p2_data_p_0 <= p1_data_p_0 + p1_data_p_1 + p1_data_p_4;\n    p2_data_p_1 <= p1_data_p_2 + p1_data_p_3;\n  end\n\n  always @(posedge clk) begin\n    p3_sign <= p2_sign;\n    p3_ddata <= p2_ddata;\n    p3_data_p_0 <= p2_data_p_0 + p2_data_p_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    data_p <= {p3_sign, p3_data_p_0};\n  end\n\nendmodule\n\n",
        "module_name": "cf_mul",
        "module_hash": "58393abfa91a97ed41bd2c927c1dcd95",
        "dataset_index": 18089
      },
      "booth_shift_reg_2ccb52fc": {
        "rtl_code": "module booth_shift_reg (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    input load,\n    input shift_left,\n    input shift_right,\n    input select,\n    output [7:0] P,\n    output [7:0] P_shifted\n);\n\nreg [7:0] P_reg;\nreg [3:0] A_reg;\nreg [3:0] B_reg;\nreg [2:0] count;\nreg [3:0] B_shifted;\nreg [1:0] shift_count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        P_reg <= 8'b0;\n        A_reg <= 4'b0;\n        B_reg <= 4'b0;\n        count <= 3'b0;\n        B_shifted <= 4'b0;\n        shift_count <= 2'b0;\n    end else begin\n        if (load) begin\n            P_reg <= 8'b0;\n            A_reg <= A;\n            B_reg <= B;\n            count <= 3'b0;\n            B_shifted <= {B[3], B};\n            shift_count <= 2'b0;\n        end else begin\n            case (count)\n                3'b000: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 4);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b001: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 4);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n                3'b010: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 3);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b011: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 3);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n                3'b100: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 2);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b101: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 2);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n                3'b110: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 1);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b111: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 1);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n            endcase\n            count <= count + 1;\n        end\n    end\nend\n\nassign P = select ? P_reg : {P_reg[6:0], 1'b0};\nassign P_shifted = select ? {P_reg[6:0], 1'b0} : {P_reg[5:0], 2'b0};\n\nendmodule",
        "module_name": "booth_shift_reg",
        "module_hash": "2ccb52fc5dde0b9ae3b028d1800fc0ac",
        "dataset_index": 1000
      },
      "i2s_shift_in_66a3e198": {
        "rtl_code": "\nmodule i2s_shift_in (\n\tinput\t\t\t\tclk,\t\t\t\tinput\t\t\t\treset_n,\t\t\toutput reg\t[31:0]\tfifo_right_data,\toutput reg\t[31:0]\tfifo_left_data,\t\tinput\t\t\t\tfifo_ready,\t\t\toutput reg\t\t\tfifo_write,\t\t\tinput\t\t\t\tenable,\t\t\t\tinput\t\t\t\tbclk,\t\t\t\tinput\t\t\t\tlrclk,\t\t\t\tinput\t\t\t\tdata_in\t\t\t\t);\n\n\treg bclk_delayed;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tbclk_delayed <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tbclk_delayed <= bclk;\n\t\tend\n\tend\n\twire bclk_rising_edge = bclk & ~bclk_delayed;\n\twire bclk_falling_edge = ~bclk & bclk_delayed;\n\t\t\n\treg lrclk_delayed;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tlrclk_delayed <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tlrclk_delayed <= lrclk;\n\t\tend\n\tend\n\twire lrclk_rising_edge = lrclk & ~lrclk_delayed;\n\twire lrclk_falling_edge = ~lrclk & lrclk_delayed;\n\n\treg [1:0] first_bclk_falling_after_lrclk_rising_r;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (lrclk_rising_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b01;\n\t\t\telse if (first_bclk_falling_after_lrclk_rising_r == 2'b01 && bclk_rising_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b10;\n\t\t\telse if (first_bclk_falling_after_lrclk_rising_r == 2'b10 && bclk_falling_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b11;\n\t\t\telse if (first_bclk_falling_after_lrclk_rising_r == 2'b11)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b00;\n\t\tend\n\tend\n\twire first_bclk_falling_after_lrclk_rising = first_bclk_falling_after_lrclk_rising_r == 2'b11;\n\t\n\treg [1:0] first_bclk_falling_after_lrclk_falling_r;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (lrclk_falling_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b01;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling_r == 2'b01 && bclk_rising_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b10;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling_r == 2'b10 && bclk_falling_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b11;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling_r == 2'b11)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b00;\n\t\tend\n\tend\n\twire first_bclk_falling_after_lrclk_falling = first_bclk_falling_after_lrclk_falling_r == 2'b11;\n\t\n\treg [31:0] shift_register;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tshift_register <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (~enable)\n\t\t\t\tshift_register <= 0;\n\t\t\telse if (bclk_rising_edge)\n\t\t\t\tshift_register <= {shift_register[30:0], data_in};\n\t\tend\n\tend\n\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfifo_right_data <= 0;\n\t\t\tfifo_left_data <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (~enable)\n\t\t\tbegin\n\t\t\t\tfifo_right_data <= 0;\n\t\t\t\tfifo_left_data <= 0;\n\t\t\tend\n\t\t\telse if (first_bclk_falling_after_lrclk_rising)\n\t\t\t\tfifo_left_data <= shift_register;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling)\n\t\t\t\tfifo_right_data <= shift_register;\n\t\tend\t\t\t\t\n\tend\n\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfifo_write <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (~enable | ~fifo_ready)\n\t\t\t\tfifo_write <= 0;\n\t\t\telse\n\t\t\t\tfifo_write <= first_bclk_falling_after_lrclk_falling;\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "i2s_shift_in",
        "module_hash": "66a3e19835c4acbce78eba1d2fc22dec",
        "dataset_index": 15628
      },
      "FA_106_19768e23": {
        "rtl_code": "module FA_106 (input A, B, Ci, output S, Co);\n  wire n9, n10, n11;\n\n  assign n11 = ~(A ^ B);\n  assign S = ~(Ci ^ n11);\n  assign n10 = ~(A & B & Ci);\n  assign n9 = ~(A & B);\n  assign Co = ~(n10 & n9);\nendmodule",
        "module_name": "FA_106",
        "module_hash": "19768e234c895ec0351109b6711632e2",
        "dataset_index": 5381
      },
      "up_counter_7a50be20": {
        "rtl_code": "module up_counter(\n  input clk,\n  input rst,\n  input en,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      count <= 4'b0000;\n    end else if(en) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "7a50be20516e9702c241981e489f09fc",
        "dataset_index": 14814
      },
      "multi_io__a4b9602e": {
        "rtl_code": "module multi_io_module (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input enable,\n  input [3:0] addr,\n  output reg [7:0] data_out,\n  output reg valid,\n  output reg done,\n  output reg error\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      data_out <= 8'b0;\n      valid <= 1'b0;\n      done <= 1'b0;\n      error <= 1'b0;\n    end else if (enable) begin\n      case (addr)\n        4'h0: begin\n          data_out <= data_in;\n          valid <= 1'b1;\n          done <= 1'b0;\n          error <= 1'b0;\n        end\n        4'h1: begin\n          data_out <= data_in;\n          valid <= 1'b1;\n          done <= 1'b0;\n          error <= 1'b1;\n        end\n        4'h2: begin\n          data_out <= data_in;\n          valid <= 1'b0;\n          done <= 1'b1;\n          error <= 1'b0;\n        end\n        4'h3: begin\n          data_out <= data_in;\n          valid <= 1'b0;\n          done <= 1'b1;\n          error <= 1'b1;\n        end\n        default: begin\n          data_out <= data_in;\n          valid <= 1'b0;\n          done <= 1'b0;\n          error <= 1'b0;\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "multi_io_",
        "module_hash": "a4b9602ecf85d928e42b566ed0dae2e0",
        "dataset_index": 862
      },
      "add_sub_4bit_340e57e0": {
        "rtl_code": "module add_sub_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  input mode,\n  output [3:0] Y,\n  output COUT,\n  output BOUT\n);\n\n  wire [3:0] B_comp;\n  assign B_comp = ~B + 1; // Two's complement of B\n\n  wire [4:0] Y_temp;\n  assign Y_temp = A + (mode ? B_comp : B); // Perform addition or subtraction based on mode input\n\n  assign Y = Y_temp[3:0]; // Output the result\n  assign COUT = Y_temp[4]; // Output carry-out for addition\n  assign BOUT = Y_temp[4] ^ mode; // Output borrow-out for subtraction\n\nendmodule\n",
        "module_name": "add_sub_4bit",
        "module_hash": "340e57e081edb9f7fe8eed1ffcfa9bcb",
        "dataset_index": 16679
      },
      "ballcollisions_df67c69c": {
        "rtl_code": "module ballcollisions(\n\tclk,\n\treset,\n\tp1_y,\n\tp2_y,\n\tball_x,\n\tball_y,\n\tdir_x,\n\tdir_y,\n\toob\n);\n\ninput clk, reset;\ninput [10:0] p1_y, p2_y, ball_x, ball_y;\noutput reg dir_x, dir_y, oob;\n\n// Constants\nlocalparam hc = 512;\nlocalparam va = 0;\nlocalparam vc = 480;\nlocalparam batwidth = 10;\nlocalparam batheight = 80;\nlocalparam ballsize = 10;\n\n// Initial values\nreg ball_x_reg, ball_y_reg;\nreg dir_x_reg, dir_y_reg;\nreg oob_reg;\ninitial begin\n\tball_x_reg = hc;\n\tball_y_reg = vc/2;\n\tdir_x_reg = 0;\n\tdir_y_reg = 1;\n\toob_reg = 0;\nend\n\n// Logic for direction changes\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tdir_x_reg <= ~dir_x_reg;\n\t\tdir_y_reg <= 1;\n\t\toob_reg <= 0;\n\t\tball_x_reg <= hc;\n\t\tball_y_reg <= vc/2;\n\tend\n\telse begin\n\t\t// out of bounds (i.e. one of the players missed the ball)\n\t\tif (ball_x_reg <= 0 || ball_x_reg >= hc) begin\n\t\t\toob_reg <= 1;\n\t\tend\n\t\telse begin\n\t\t\toob_reg <= 0;\n\t\tend\n\t\t\n\t\t// collision with top & bottom walls\n\t\tif (ball_y_reg <= va + ballsize) begin\n\t\t\tdir_y_reg <= 1;\n\t\tend\n\t\tif (ball_y_reg >= vc - ballsize) begin\n\t\t\tdir_y_reg <= 0;\n\t\tend\n\t\t\n\t\t// collision with P1 bat\n\t\tif (ball_x_reg <= batwidth && ball_y_reg + ballsize >= p1_y && ball_y_reg <= p1_y + batheight) begin\n\t\t\tdir_x_reg <= 1;\n\t\t\tif (ball_y_reg + ballsize <= p1_y + (batheight / 2)) begin\n\t\t\t\tdir_y_reg <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tdir_y_reg <= 1;\n\t\t\tend\n\t\tend\n\t\t// collision with P2 bat\n\t\telse if (ball_x_reg >= hc - batwidth - ballsize && ball_y_reg + ballsize <= p2_y + batheight && ball_y_reg >= p2_y) begin\n\t\t\tdir_x_reg <= 0;\n\t\t\tif (ball_y_reg + ballsize <= p2_y + (batheight / 2)) begin\n\t\t\t\tdir_y_reg <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tdir_y_reg <= 1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t// Move ball based on direction\n\t\tif (dir_x_reg) begin\n\t\t\tball_x_reg <= ball_x_reg + 1;\n\t\tend\n\t\telse begin\n\t\t\tball_x_reg <= ball_x_reg - 1;\n\t\tend\n\t\t\n\t\tif (dir_y_reg) begin\n\t\t\tball_y_reg <= ball_y_reg + 1;\n\t\tend\n\t\telse begin\n\t\t\tball_y_reg <= ball_y_reg - 1;\n\t\tend\n\tend\nend\n\n// Assign output signals to registered values\nalways @* begin\n\tdir_x = dir_x_reg;\n\tdir_y = dir_y_reg;\n\toob = oob_reg;\nend\n\nendmodule",
        "module_name": "ballcollisions",
        "module_hash": "df67c69c8640a5870f8e1a5694fd0769",
        "dataset_index": 7961
      },
      "adder_tree_top_af78b97a": {
        "rtl_code": "`define ADDER_WIDTH 016\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "af78b97adde73d8afd0f83ac9553a0fb",
        "dataset_index": 24656
      },
      "control_52a33e25": {
        "rtl_code": "module control (\n    input [5:0] op,\n    output [1:0] alu_op,\n    output regDst, aluSrc, memToReg, regWrite,\n    output memRead, memWrite, branch\n  );\n\n  // Generate complement of op bits\n  wire [5:0] op_bar;\n  assign op_bar = ~op;\n\n  // Generate control signals\n  assign alu_op[0] = op_bar[0] & op_bar[1] & op_bar[2] & op[2] & op_bar[4] & op_bar[5];\n  assign alu_op[1] = op_bar[0] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5];\n  assign regDst = op_bar[0] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5];\n  assign memToReg = op[0] & op_bar[1] & op_bar[2] & op_bar[3] & op[4] & op[5];\n  assign regWrite = (op[0] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5]) | (op[5] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5]);\n  assign memRead = op[0] & op_bar[1] & op_bar[2] & op_bar[3] & op[4] & op_bar[5];\n  assign memWrite = op[0] & op_bar[1] & op_bar[3] & op_bar[4] & op_bar[5];\n  assign branch = op_bar[0] & op_bar[1] & op_bar[2] & op[2] & op_bar[4] & op_bar[5];\n  assign aluSrc = op[5] & op_bar[1] & op_bar[2] & op[4] & op[3];\n\nendmodule",
        "module_name": "control",
        "module_hash": "52a33e2516852b061ad661137300e51c",
        "dataset_index": 10911
      },
      "zet_mux8_1_f03a6d56": {
        "rtl_code": "\n\nmodule zet_mux8_1(sel, in0, in1, in2, in3, in4, in5, in6, in7, out);\n  input  [2:0]  sel;\n  input  in0, in1, in2, in3, in4, in5, in6, in7;\n  output out;\n\n  reg    out;\n\n  always @(sel or in0 or in1 or in2 or in3 or in4 or in5 or in6 or in7)\n    case(sel)\n     3'd0:  out = in0;\n     3'd1:  out = in1;\n     3'd2:  out = in2;\n     3'd3:  out = in3;\n     3'd4:  out = in4;\n     3'd5:  out = in5;\n     3'd6:  out = in6;\n     3'd7:  out = in7;\n    endcase\nendmodule\n",
        "module_name": "zet_mux8_1",
        "module_hash": "f03a6d565e4e30b8e8bdf4ae97cb7e2b",
        "dataset_index": 25244
      },
      "regfile_333da0c6": {
        "rtl_code": "\nmodule regfile(\n    input             clk,\n    input             wen,\n    input      [4 :0] raddr1,\n    input      [4 :0] raddr2,\n    input      [4 :0] waddr,\n    input      [31:0] wdata,\n    output reg [31:0] rdata1,\n    output reg [31:0] rdata2,\n    input      [4 :0] test_addr,\n    output reg [31:0] test_data,\n    input             resetn\n    );\n    reg [31:0] rf[31:0];\n     \n    always @(posedge clk)\n    begin\n        if (wen) \n        begin\n            rf[waddr] <= wdata;\n        end\n        if(!resetn) begin\n            rf[0] <= 0;\n            rf[1] <= 0;\n            rf[2] <= 0;\n            rf[3] <= 0;\n            rf[4] <= 0;\n            rf[5] <= 0;\n            rf[6] <= 0;\n            rf[7] <= 0;\n            rf[8] <= 0;\n            rf[9] <= 0;\n            rf[10] <= 0;\n            rf[11] <= 0;\n            rf[12] <= 0;\n            rf[13] <= 0;\n            rf[14] <= 0;\n            rf[15] <= 0;\n            rf[16] <= 0;\n            rf[17] <= 0;\n            rf[18] <= 0;\n            rf[19] <= 0;\n            rf[20] <= 0;\n            rf[21] <= 0;\n            rf[22] <= 0;\n            rf[23] <= 0;\n            rf[24] <= 0;\n            rf[25] <= 0;\n            rf[26] <= 0;\n            rf[27] <= 0;\n            rf[28] <= 0;\n            rf[29] <= 0;\n            rf[30] <= 0;\n            rf[31] <= 0;          \n        end\n    end\n     \n    always @(*)\n    begin\n        case (raddr1)\n            5'd1 : rdata1 <= rf[1 ];\n            5'd2 : rdata1 <= rf[2 ];\n            5'd3 : rdata1 <= rf[3 ];\n            5'd4 : rdata1 <= rf[4 ];\n            5'd5 : rdata1 <= rf[5 ];\n            5'd6 : rdata1 <= rf[6 ];\n            5'd7 : rdata1 <= rf[7 ];\n            5'd8 : rdata1 <= rf[8 ];\n            5'd9 : rdata1 <= rf[9 ];\n            5'd10: rdata1 <= rf[10];\n            5'd11: rdata1 <= rf[11];\n            5'd12: rdata1 <= rf[12];\n            5'd13: rdata1 <= rf[13];\n            5'd14: rdata1 <= rf[14];\n            5'd15: rdata1 <= rf[15];\n            5'd16: rdata1 <= rf[16];\n            5'd17: rdata1 <= rf[17];\n            5'd18: rdata1 <= rf[18];\n            5'd19: rdata1 <= rf[19];\n            5'd20: rdata1 <= rf[20];\n            5'd21: rdata1 <= rf[21];\n            5'd22: rdata1 <= rf[22];\n            5'd23: rdata1 <= rf[23];\n            5'd24: rdata1 <= rf[24];\n            5'd25: rdata1 <= rf[25];\n            5'd26: rdata1 <= rf[26];\n            5'd27: rdata1 <= rf[27];\n            5'd28: rdata1 <= rf[28];\n            5'd29: rdata1 <= rf[29];\n            5'd30: rdata1 <= rf[30];\n            5'd31: rdata1 <= rf[31];\n            default : rdata1 <= 32'd0;\n        endcase\n    end\n    always @(*)\n    begin\n        case (raddr2)\n            5'd1 : rdata2 <= rf[1 ];\n            5'd2 : rdata2 <= rf[2 ];\n            5'd3 : rdata2 <= rf[3 ];\n            5'd4 : rdata2 <= rf[4 ];\n            5'd5 : rdata2 <= rf[5 ];\n            5'd6 : rdata2 <= rf[6 ];\n            5'd7 : rdata2 <= rf[7 ];\n            5'd8 : rdata2 <= rf[8 ];\n            5'd9 : rdata2 <= rf[9 ];\n            5'd10: rdata2 <= rf[10];\n            5'd11: rdata2 <= rf[11];\n            5'd12: rdata2 <= rf[12];\n            5'd13: rdata2 <= rf[13];\n            5'd14: rdata2 <= rf[14];\n            5'd15: rdata2 <= rf[15];\n            5'd16: rdata2 <= rf[16];\n            5'd17: rdata2 <= rf[17];\n            5'd18: rdata2 <= rf[18];\n            5'd19: rdata2 <= rf[19];\n            5'd20: rdata2 <= rf[20];\n            5'd21: rdata2 <= rf[21];\n            5'd22: rdata2 <= rf[22];\n            5'd23: rdata2 <= rf[23];\n            5'd24: rdata2 <= rf[24];\n            5'd25: rdata2 <= rf[25];\n            5'd26: rdata2 <= rf[26];\n            5'd27: rdata2 <= rf[27];\n            5'd28: rdata2 <= rf[28];\n            5'd29: rdata2 <= rf[29];\n            5'd30: rdata2 <= rf[30];\n            5'd31: rdata2 <= rf[31];\n            default : rdata2 <= 32'd0;\n        endcase\n    end\n     always @(*)\n    begin\n        case (test_addr)\n            5'd1 : test_data <= rf[1 ];\n            5'd2 : test_data <= rf[2 ];\n            5'd3 : test_data <= rf[3 ];\n            5'd4 : test_data <= rf[4 ];\n            5'd5 : test_data <= rf[5 ];\n            5'd6 : test_data <= rf[6 ];\n            5'd7 : test_data <= rf[7 ];\n            5'd8 : test_data <= rf[8 ];\n            5'd9 : test_data <= rf[9 ];\n            5'd10: test_data <= rf[10];\n            5'd11: test_data <= rf[11];\n            5'd12: test_data <= rf[12];\n            5'd13: test_data <= rf[13];\n            5'd14: test_data <= rf[14];\n            5'd15: test_data <= rf[15];\n            5'd16: test_data <= rf[16];\n            5'd17: test_data <= rf[17];\n            5'd18: test_data <= rf[18];\n            5'd19: test_data <= rf[19];\n            5'd20: test_data <= rf[20];\n            5'd21: test_data <= rf[21];\n            5'd22: test_data <= rf[22];\n            5'd23: test_data <= rf[23];\n            5'd24: test_data <= rf[24];\n            5'd25: test_data <= rf[25];\n            5'd26: test_data <= rf[26];\n            5'd27: test_data <= rf[27];\n            5'd28: test_data <= rf[28];\n            5'd29: test_data <= rf[29];\n            5'd30: test_data <= rf[30];\n            5'd31: test_data <= rf[31];\n            default : test_data <= 32'd0;\n        endcase\n    end\nendmodule\n",
        "module_name": "regfile",
        "module_hash": "333da0c6b1a8f9f1fd1e58deacf01496",
        "dataset_index": 23009
      },
      "and_gate_577a2dc8": {
        "rtl_code": "module and_gate(\n    input a, \n    input b,\n    output reg out\n);\n\n    always @(*) begin\n        out = (a & b) ? 1'b1 : 1'b0;\n    end\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "577a2dc8030b1dd96315463361afb302",
        "dataset_index": 4744
      },
      "Delay_Block_dbb08f2b": {
        "rtl_code": "module Delay_Block (\n  input in,\n  output out,\n  input clk // Clock signal\n);\n\nparameter delay = 2; // Amount of delay in number of clock cycles.\n\nreg [delay-1:0] delay_reg; // Register to hold input signal for delay cycles\n\nalways @(posedge clk) begin\n  delay_reg <= {delay_reg[delay-2:0], in}; // Shift input signal into register\nend\n\nassign out = delay_reg[delay-1]; // Output delayed signal\n\nendmodule",
        "module_name": "Delay_Block",
        "module_hash": "dbb08f2b62a972dd64a1cf110b0d79ed",
        "dataset_index": 1259
      },
      "rotator_fa4a254c": {
        "rtl_code": "\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b00: q <= {q[98:0], q[99]};\n                2'b01: q <= {q[99], q[98:0]};\n                default: q <= q;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output wire [99:0] q);\n\n    rotator rotator_inst(\n        .clk(clk),\n        .load(load),\n        .ena(ena),\n        .data(data),\n        .q(q)\n    );\n\nendmodule\n",
        "module_name": "rotator",
        "module_hash": "fa4a254cd4733de8c8ced42665083052",
        "dataset_index": 19118
      },
      "flip_flop_881cfdce": {
        "rtl_code": "module flip_flop (\n    Q,\n    Q_N,\n    CLK,\n    D,\n    SCD,\n    SCE\n);\n\n    output Q;\n    output Q_N;\n    input CLK;\n    input D;\n    input SCD;\n    input SCE;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    reg Q;\n    assign Q_N = ~Q;\n\n    always @(posedge CLK) begin\n        if (SCD) begin\n            Q <= 0;\n        end else if (SCE) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "flip_flop",
        "module_hash": "881cfdce61bf8bec6a4459ac3e0cc2e0",
        "dataset_index": 7293
      },
      "calculator_8a190079": {
        "rtl_code": "module calculator(\n    input clk,\n    input reset,\n    input [1:0] op,\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] out,\n    output reg valid\n);\n\n    reg [15:0] result;\n    \n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            result <= 0;\n            out <= 0;\n            valid <= 0;\n        end else begin\n            case(op)\n                2'b00: result <= in1 + in2; // addition\n                2'b01: result <= in1 - in2; // subtraction\n                2'b10: result <= in1 * in2; // multiplication\n                2'b11: result <= in1 / in2; // division\n            endcase\n            \n            out <= result[7:0];\n            valid <= 1;\n        end\n    end\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "8a19007917685f04a04269c02e8e500e",
        "dataset_index": 18729
      },
      "taxicab_distance #_38c46277": {
        "rtl_code": "\nmodule taxicab_distance #(parameter N = 32)(\n\tinput [N-1:0] x1, y1, x2, y2,\n\toutput [N+1:0] dist\n);\n\nwire signed [N:0] dist_x12, dist_x21, dist_xabs, dist_y12, dist_y21, dist_yabs;\n\n// Calculate the absolute difference between x1 and x2\nassign dist_x12 = x1 - x2;\n// Calculate the absolute difference between x2 and x1\nassign dist_x21 = x2 - x1;\n\n// Select the absolute difference between x1 and x2 if x1 > x2, otherwise select the absolute difference between x2 and x1\nassign dist_xabs = (x1 > x2) ? dist_x12 : dist_x21;\n\n// Calculate the absolute difference between y1 and y2\nassign dist_y12 = y1 - y2;\n// Calculate the absolute difference between y2 and y1\nassign dist_y21 = y2 - y1;\n\n// Select the absolute difference between y1 and y2 if y1 > y2, otherwise select the absolute difference between y2 and y1\nassign dist_yabs = (y1 > y2) ? dist_y12 : dist_y21;\n\n// Calculate the taxicab distance by adding the absolute differences of x and y coordinates\nassign dist = dist_xabs + dist_yabs;\n\nendmodule",
        "module_name": "taxicab_distance #",
        "module_hash": "38c46277633fc6880552ab7f7e1fa3db",
        "dataset_index": 21365
      },
      "calculator_0b32051c": {
        "rtl_code": "module calculator(\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] opcode,\n    output reg [7:0] result\n    );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            result <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= a + b;\n                2'b01: result <= a - b;\n                2'b10: result <= a * b;\n                2'b11: result <= a / b;\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "0b32051c81bdac440b44a420d7b4ade6",
        "dataset_index": 6214
      },
      "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W55_0_2_335c742d": {
        "rtl_code": "\nmodule SNPS_CLOCK_GATE_HIGH_RegisterAdd_W55_0_2 (input CLK, EN, TE, output ENCLK);\n  assign ENCLK = EN ? CLK : 1'b0;\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .ECK(ENCLK) );\n\nendmodule\nmodule TLATNTSCAX2TS (input E, SE, CK, ECK);\n  // Add your TLATNTSCAX2TS module implementation here\nendmodule",
        "module_name": "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W55_0_2",
        "module_hash": "335c742d8bb6ad94734bbe1edc416938",
        "dataset_index": 13476
      },
      "four_bit_adder_3ac0e6b3": {
        "rtl_code": "module four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] sum;\n  wire [3:0] carry;\n  \n  // First bit of sum and carry\n  full_adder fa0(A[0], B[0], Cin, sum[0], carry[0]);\n  \n  // Subsequent bits of sum and carry\n  full_adder fa1(A[1], B[1], carry[0], sum[1], carry[1]);\n  full_adder fa2(A[2], B[2], carry[1], sum[2], carry[2]);\n  full_adder fa3(A[3], B[3], carry[2], sum[3], Cout);\n\n  assign S = sum;\n\nendmodule\n\nmodule full_adder(\n  input A,\n  input B,\n  input Cin,\n  output S,\n  output Cout\n);\n\n  wire s1, s2, c1, c2;\n  \n  // First stage\n  xor(s1, A, B);\n  xor(S, s1, Cin);\n  \n  // Second stage\n  and(c1, A, B);\n  and(c2, s1, Cin);\n  or(Cout, c1, c2);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "3ac0e6b31a0495a08d3d1fe1f2dd5289",
        "dataset_index": 19231
      },
      "adder_subtractor_0e226a0d": {
        "rtl_code": "module adder_subtractor (\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput subtract,\n\toutput reg [3:0] result\n);\n\n\talways @(*) begin\n\t\tif (subtract == 1) begin\n\t\t\tresult <= A - B;\n\t\tend else begin\n\t\t\tresult <= A + B;\n\t\tend\n\tend\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "0e226a0d6d5797cc49f1edb2f4107d71",
        "dataset_index": 19453
      },
      "adder_tree_top_b0677317": {
        "rtl_code": "`define ADDER_WIDTH 005\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "b06773173eeff5b6d21c62c368940bc1",
        "dataset_index": 24996
      },
      "six_input_one_output_2e30a5eb": {
        "rtl_code": "module six_input_one_output (\n    input  A1,\n    input  A2,\n    input  B1,\n    input  B2,\n    input  C1,\n    input  C2,\n    output Y\n);\n\n    assign Y = (A1 & A2) | (B1 & B2) | (C1 & C2);\n\nendmodule",
        "module_name": "six_input_one_output",
        "module_hash": "2e30a5eb82261946df884a1b7178ab8b",
        "dataset_index": 4770
      },
      "my__02d3ff3b": {
        "rtl_code": "\nmodule my_module (\n    output Y,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    input  VPWR,\n    input  VGND,\n    input  VPB,\n    input  VNB\n);\n\n    wire xor1, xor2;\n\n    assign xor1 = A1 ^ A2;\n    assign xor2 = A3 ^ A4;\n\n    assign Y = (B1 & ~VPWR) ? xor1 : ((~B1) ? 0 : xor2);\n\nendmodule\nmodule sky130_fd_sc_lp__o41ai (\n    output Y,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    input  VPWR,\n    input  VGND,\n    input  VPB,\n    input  VNB\n);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "02d3ff3b690d1a76dfacf89aba94aed3",
        "dataset_index": 4942
      },
      "pixel_faf60af0": {
        "rtl_code": "module pixel(clk, pixclk, attcode,\n             pixel, blank, hsync_in, vsync_in, blink,\n             hsync, vsync, r, g, b);\n    input clk;\n    input pixclk;\n    input [7:0] attcode;\n    input pixel;\n    input blank;\n    input hsync_in;\n    input vsync_in;\n    input blink;\n    output reg hsync;\n    output reg vsync;\n    output reg [2:0] r;\n    output reg [2:0] g;\n    output reg [2:0] b;\n\n  wire blink_bit;\n  wire bg_red;\n  wire bg_green;\n  wire bg_blue;\n  wire inten_bit;\n  wire fg_red;\n  wire fg_green;\n  wire fg_blue;\n  wire foreground;\n  wire intensify;\n  wire red;\n  wire green;\n  wire blue;\n\n  assign blink_bit = attcode[7];\n  assign bg_red = attcode[6];\n  assign bg_green = attcode[5];\n  assign bg_blue = attcode[4];\n  assign inten_bit = attcode[3];\n  assign fg_red = attcode[2];\n  assign fg_green = attcode[1];\n  assign fg_blue = attcode[0];\n\n  assign foreground = pixel & ~(blink_bit & blink);\n  assign intensify = foreground & inten_bit;\n\n  assign red = (foreground ? fg_red : bg_red);\n  assign green = (foreground ? fg_green : bg_green);\n  assign blue = (foreground ? fg_blue : bg_blue);\n\n  always @(posedge clk) begin\n    if (pixclk == 1) begin\n      hsync <= hsync_in;\n      vsync <= vsync_in;\n      r[2] <= blank & red;\n      r[1] <= blank & intensify;\n      r[0] <= blank & red & intensify;\n      g[2] <= blank & green;\n      g[1] <= blank & intensify;\n      g[0] <= blank & green & intensify;\n      b[2] <= blank & blue;\n      b[1] <= blank & intensify;\n      b[0] <= blank & blue & intensify;\n    end\n  end\n\nendmodule",
        "module_name": "pixel",
        "module_hash": "faf60af0a5d868c42f63ab02e3bf5ed8",
        "dataset_index": 11913
      },
      "coordinate_cordic_c0ae1266": {
        "rtl_code": "module coordinate_cordic\n(\n\trealIn,\n\timagIn,\n\tclk,\n\tamplitude,\n\tangle,\n\ttest1,\n\ttest2\n);\n\ninput signed [INWIDTH-1:0]realIn,imagIn;\ninput clk;\noutput signed [OUTWIDTH-1:0]amplitude;\noutput signed [ANGLEWIDTH-1:0]angle;\n\ninput  [9:0] test1;\noutput  [9:0] test2;\nassign  test2 = {11{test1}};\nparameter INWIDTH = 18,  OUTWIDTH = 20, MIDWIDTH = 21, ANGLEWIDTH =15;parameter ARCTANG_0  = 12'b10_01110_00100,ARCTANG_1  = 11'b1_01110_00100,ARCTANG_2  = 10'b11000_01100,ARCTANG_3  = 9'b1100_01100,ARCTANG_4  = 8'b110_00111,ARCTANG_5  = 7'b11_00011,ARCTANG_6  = 6'b1_10010,ARCTANG_7  = 5'b11001,ARCTANG_8  = 4'b1100,ARCTANG_9  = 3'b110,ARCTANG_10 = 2'b11,ARCTANG_11 = 2'b10;parameter HALFPI = 13'b100_11100_01000;reg signed [MIDWIDTH-1:0]xData1,xData2,xData3,xData4,xData5,xData6,\n                         xData7,xData8,xData9,xData10,xData11,xData12,\n                         xData13,xData14,xData15,xData16,\n\t\t\t\t         yData1,yData2,yData3,yData4,yData5,yData6,\n\t\t\t\t         yData7,yData8,yData9,yData10,yData11,yData12,\n\t\t\t\t         yData13,yData14,yData15,yData16;\n\nreg signed [ANGLEWIDTH-1:0]angle1,angle2,angle3,angle4,angle5,angle6,\n\t\t\t\t\t       angle7,angle8,angle9,angle10,angle11,angle12,\n\t\t\t\t\t       angle13,angle14,angle15,angle16;\n\n\nwire signed [MIDWIDTH-1:0]reIn,imIn;\nwire signed [ANGLEWIDTH-1:0]ang;\nassign reIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-imagIn:imagIn):realIn;\nassign imIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?realIn:-realIn):imagIn;\nassign ang = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-HALFPI:HALFPI):1'b0;\n\n\nassign amplitude = {xData12[MIDWIDTH-1],xData12[MIDWIDTH-3:0]};\nassign angle = angle12;\n\n\n\nalways@(posedge clk)\nbegin\n    xData1 <= imIn[MIDWIDTH-1]?(reIn - imIn):(reIn + imIn);\n\tyData1 <= imIn[MIDWIDTH-1]?(imIn + reIn):(imIn - reIn);\n\tangle1 <= imIn[MIDWIDTH-1]?(ang - ARCTANG_0):(ang + ARCTANG_0);\n\n    xData2 <= yData1[MIDWIDTH-1]?(xData1 - {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]}):(xData1 + {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]});\n\tyData2 <= yData1[MIDWIDTH-1]?(yData1 + {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]}):(yData1 - {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]});\n\tangle2 <= yData1[MIDWIDTH-1]?(angle1 - ARCTANG_1):(angle1 + ARCTANG_1);\n\n    xData3 <= yData2[MIDWIDTH-1]?(xData2 - {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]}):(xData2 + {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]});\n\tyData3 <= yData2[MIDWIDTH-1]?(yData2 + {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]}):(yData2 - {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]});\n\tangle3 <= yData2[MIDWIDTH-1]?(angle2 - ARCTANG_2):(angle2 + ARCTANG_2);\n\n    xData4 <= yData3[MIDWIDTH-1]?(xData3 - {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]}):(xData3 + {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]});\n\tyData4 <= yData3[MIDWIDTH-1]?(yData3 + {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]}):(yData3 - {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]});\n\tangle4 <= yData3[MIDWIDTH-1]?(angle3 - ARCTANG_3):(angle3 + ARCTANG_3);\n\n    xData5 <= yData4[MIDWIDTH-1]?(xData4 - {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]}):(xData4 + {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]});\n\tyData5 <= yData4[MIDWIDTH-1]?(yData4 + {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]}):(yData4 - {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]});\n\tangle5 <= yData4[MIDWIDTH-1]?(angle4 - ARCTANG_4):(angle4 + ARCTANG_4);\n\n    xData6 <= yData5[MIDWIDTH-1]?(xData5 - {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]}):(xData5 + {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]});\n\tyData6 <= yData5[MIDWIDTH-1]?(yData5 + {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]}):(yData5 - {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]});\n\tangle6 <= yData5[MIDWIDTH-1]?(angle5 - ARCTANG_5):(angle5 + ARCTANG_5);\n\n    xData7 <= yData6[MIDWIDTH-1]?(xData6 - {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]}):(xData6 + {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]});\n\tyData7 <= yData6[MIDWIDTH-1]?(yData6 + {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]}):(yData6 - {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]});\n\tangle7 <= yData6[MIDWIDTH-1]?(angle6 - ARCTANG_6):(angle6 + ARCTANG_6);\n\n    xData8 <= yData7[MIDWIDTH-1]?(xData7 - {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]}):(xData7 + {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]});\n\tyData8 <= yData7[MIDWIDTH-1]?(yData7 + {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]}):(yData7 - {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]});\n\tangle8 <= yData7[MIDWIDTH-1]?(angle7 - ARCTANG_7):(angle7 + ARCTANG_7);\n\n    xData9 <= yData8[MIDWIDTH-1]?(xData8 - {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]}):(xData8 + {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]});\n\tyData9 <= yData8[MIDWIDTH-1]?(yData8 + {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]}):(yData8 - {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]});\n\tangle9 <= yData8[MIDWIDTH-1]?(angle8 - ARCTANG_8):(angle8 + ARCTANG_8);\n\n    xData10 <= yData9[MIDWIDTH-1]?(xData9 - {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]}):(xData9 + {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]});\n\tyData10 <= yData9[MIDWIDTH-1]?(yData9 + {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]}):(yData9 - {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]});\n\tangle10 <= yData9[MIDWIDTH-1]?(angle9 - ARCTANG_9):(angle9 + ARCTANG_9);\n\n    xData11 <= yData10[MIDWIDTH-1]?(xData10 - {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]}):(xData10 + {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]});\n\tyData11 <= yData10[MIDWIDTH-1]?(yData10 + {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]}):(yData10 - {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]});\n\tangle11 <= yData10[MIDWIDTH-1]?(angle10 - ARCTANG_10):(angle10 + ARCTANG_10);\n\n    xData12 <= yData11[MIDWIDTH-1]?(xData11 - {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]}):(xData11 + {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]});\n\tyData12 <= yData11[MIDWIDTH-1]?(yData11 + {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]}):(yData11 - {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]});\n\tangle12 <= yData11[MIDWIDTH-1]?(angle11 - ARCTANG_11):(angle11 + ARCTANG_11);\n\t\n   \n\t\nend\t\nendmodule\n",
        "module_name": "coordinate_cordic",
        "module_hash": "c0ae12669b232d79c7ea79ef9348add2",
        "dataset_index": 5476
      },
      "lifo_memory_afebca68": {
        "rtl_code": "\nmodule lifo_memory (\n  input clk,\n  input wr_en,\n  input [7:0] data_in,\n  input rst,\n  output reg [7:0] data_out\n);\n\nparameter depth = 8; // number of data items that can be stored in the memory block\n\nreg [7:0] memory [0:depth-1]; // memory array\nreg [2:0] pointer = 0; // pointer to last data item written into the memory block\n\nalways @(posedge clk) begin\n  if (rst) begin\n    pointer <= 0; // reset pointer\n    data_out <= 0; // output 0\n  end\n  else begin\n    case ({wr_en, pointer})\n      2'b01: begin // write data_in to memory\n        memory[pointer] <= data_in;\n        pointer <= pointer + 1;\n      end\n      2'b10: begin // read last data item written to memory\n        data_out <= memory[pointer-1];\n        pointer <= pointer - 1;\n      end\n      default: data_out <= data_out; // do nothing\n    endcase\n  end\nend\n\nendmodule\n",
        "module_name": "lifo_memory",
        "module_hash": "afebca68779c46b6d2ae4e6531f0775d",
        "dataset_index": 18904
      },
      "mux_buffer_3daeb070": {
        "rtl_code": "\nmodule mux_buffer (\n    input wire I0,\n    input wire I1,\n    input wire S,\n    output wire O\n);\n\n    assign O = S ? I0: I1;\n\nendmodule",
        "module_name": "mux_buffer",
        "module_hash": "3daeb0704c443e7998f7ea7f34b56dce",
        "dataset_index": 10992
      },
      "sky130_fd_sc_lp__a32oi_2221bb53": {
        "rtl_code": "\nmodule sky130_fd_sc_lp__a32oi (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    B2  ,\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  B2  ;\n\n    // Local signals\n    wire nand0_out        ;\n    wire nand1_out        ;\n    wire and0_out_Y       ;\n\n    //                                 Name         Output             Other arguments\n    nand                               nand0       (nand0_out        , A3, A2, A1            );\n    nand                               nand1       (nand1_out        , B2, B1                );\n    and                                and0        (and0_out_Y       , nand0_out, nand1_out  );\n    buf                                buf0        (Y                , and0_out_Y          );\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a32oi",
        "module_hash": "2221bb53793b5bc24e50178295ccbce5",
        "dataset_index": 11274
      },
      "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W17_4352e1bc": {
        "rtl_code": "module SNPS_CLOCK_GATE_HIGH_RegisterAdd_W17 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .ECK(ENCLK) );\n  \nendmodule\n\nmodule TLATNTSCAX2TS ( E, SE, CK, ECK );\n  input E, SE, CK;\n  output reg ECK;\n\n  always @ (posedge CK)\n    if (E) ECK <= SE;\n\nendmodule",
        "module_name": "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W17",
        "module_hash": "4352e1bc0271c91b7ea68796550f3450",
        "dataset_index": 21100
      },
      "magnitude_comparator_selector_decoder_d7fd1375": {
        "rtl_code": "module magnitude_comparator_selector_decoder (\n    input clk,\n    input [2:0] a, b,\n    input [1:0] select,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg [2:0] comparison_result,\n    output reg [1:0] input_selected,\n    output reg [1:0] final_output\n);\n\nreg [2:0] magnitude_result;\nreg [2:0] a_mag;\nreg [2:0] b_mag;\n\n// Magnitude Comparator Module\nalways @ (posedge clk) begin\n    if (a > b) begin\n        magnitude_result <= 3'b001;\n        a_mag <= a;\n        b_mag <= 3'b000;\n    end else if (a < b) begin\n        magnitude_result <= 3'b010;\n        a_mag <= 3'b000;\n        b_mag <= b;\n    end else begin\n        magnitude_result <= 3'b100;\n        a_mag <= 3'b000;\n        b_mag <= 3'b000;\n    end\nend\n\n// Selector Module\nalways @ (posedge clk) begin\n    case (select)\n        2'b00: begin\n            comparison_result <= magnitude_result;\n            input_selected <= 2'b00;\n        end\n        2'b01: begin\n            comparison_result <= magnitude_result;\n            input_selected <= 2'b01;\n        end\n        2'b10: begin\n            comparison_result <= 3'b000;\n            input_selected <= 2'b00;\n        end\n        2'b11: begin\n            comparison_result <= 3'b000;\n            input_selected <= 2'b01;\n        end\n    endcase\nend\n\n// Decoder Module\nalways @ (posedge clk) begin\n    case (comparison_result)\n        3'b001: begin\n            Y0 <= 1'b0;\n            Y1 <= 1'b0;\n            Y2 <= 1'b0;\n            Y3 <= 1'b1;\n        end\n        3'b010: begin\n            Y0 <= 1'b0;\n            Y1 <= 1'b0;\n            Y2 <= 1'b1;\n            Y3 <= 1'b0;\n        end\n        3'b100: begin\n            Y0 <= 1'b0;\n            Y1 <= 1'b1;\n            Y2 <= 1'b0;\n            Y3 <= 1'b0;\n        end\n        default: begin\n            Y0 <= 1'b1;\n            Y1 <= 1'b0;\n            Y2 <= 1'b0;\n            Y3 <= 1'b0;\n        end\n    endcase\nend\n\n// Final Output Module\nalways @ (posedge clk) begin\n    final_output <= {Y3, Y2};\nend\n\nendmodule",
        "module_name": "magnitude_comparator_selector_decoder",
        "module_hash": "d7fd1375de2cf7ae942a632cdeecb12f",
        "dataset_index": 12234
      },
      "one_hot_state_machine_d7a49ff4": {
        "rtl_code": "module one_hot_state_machine (\n  input clk, // clock signal\n  input rst, // reset signal\n  input [n-1:0] in, // n-bit input signal\n  output [n-1:0] out // n-bit output signal\n);\n\nparameter n = 4; // number of bits in the input and output signals\n\n// define the states as unique one-hot binary codes\nparameter STATE0 = 4'b0001;\nparameter STATE1 = 4'b0010;\nparameter STATE2 = 4'b0100;\nparameter STATE3 = 4'b1000;\n\n// define the state register\nreg [n-1:0] state;\n\n// define the next state logic\nalways @ (posedge clk, posedge rst)\nbegin\n  if (rst) // reset the state to STATE0\n    state <= STATE0;\n  else // determine the next state based on the input signal and the current state\n    case (state)\n      STATE0: state <= (in == 0) ? STATE0 : STATE1;\n      STATE1: state <= (in == 0) ? STATE2 : STATE3;\n      STATE2: state <= (in == 0) ? STATE0 : STATE1;\n      STATE3: state <= (in == 0) ? STATE2 : STATE3;\n    endcase\nend\n\n// define the output logic\nassign out = state;\n\nendmodule",
        "module_name": "one_hot_state_machine",
        "module_hash": "d7a49ff4e940c5bce3d6b5d49100e67e",
        "dataset_index": 18640
      },
      "ALU #_69e5acec": {
        "rtl_code": "\nmodule ALU #(\n        parameter DATA_WIDTH            = 32            ,\n        parameter HIGH                  = 1'b1          ,\n        parameter LOW                   = 1'b0          ,\n        \n        parameter ALU_NOP               = 5'b00000      ,\n        parameter ALU_ADD               = 5'b00001      ,\n        parameter ALU_SUB               = 5'b00010      ,\n        parameter ALU_SLL               = 5'b00011      ,\n        parameter ALU_SLT               = 5'b00100      ,\n        parameter ALU_SLTU              = 5'b00101      ,\n        parameter ALU_XOR               = 5'b00110      ,\n        parameter ALU_SRL               = 5'b00111      ,\n        parameter ALU_SRA               = 5'b01000      ,\n        parameter ALU_OR                = 5'b01001      ,\n        parameter ALU_AND               = 5'b01010      ,\n        parameter ALU_SLLI              = 5'b01011      ,\n        parameter ALU_SRLI              = 5'b01100      ,\n        parameter ALU_SRAI              = 5'b01101      ,\n        parameter ALU_JAL               = 5'b01110      ,\n        parameter ALU_JALR              = 5'b01111      ,\n        parameter ALU_BEQ               = 5'b10000      ,\n        parameter ALU_BNE               = 5'b10001      ,\n        parameter ALU_BLT               = 5'b10010      ,\n        parameter ALU_BGE               = 5'b10011      ,\n        parameter ALU_BLTU              = 5'b10100      ,\n        parameter ALU_BGEU              = 5'b10101      \n    ) (\n        input   [DATA_WIDTH - 1  : 0]   ALU_IN1           ,\n        input   [DATA_WIDTH - 1  : 0]   ALU_IN2           ,\n        input   [DATA_WIDTH - 1  : 0]   PC_IN             ,\n        input   [4               : 0]   ALU_INSTRUCTION   ,\n        output  [DATA_WIDTH - 1  : 0]   ALU_OUT           ,\n        output                          BRANCH_TAKEN\n    );\n   \n    reg  [DATA_WIDTH - 1  : 0]  alu_out_reg         ;\n    reg                         branch_taken_reg    ;\n    \n    always@(*)\n    begin\n        case(ALU_INSTRUCTION)\n            ALU_NOP:\n            begin\n                alu_out_reg         = 32'b0;\n                branch_taken_reg    = LOW;\n            end\n            ALU_ADD:\n            begin\n                alu_out_reg         = $signed(ALU_IN1) + $signed(ALU_IN2);\n                branch_taken_reg    = LOW;\n            end\n            ALU_SUB:\n            begin\n                alu_out_reg         = $signed(ALU_IN1) - $signed(ALU_IN2);\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLL:\n            begin\n                alu_out_reg         = ALU_IN1 << ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLT:\n            begin\n                if(ALU_IN1 < ALU_IN2)\n                begin\n                    alu_out_reg         = 32'b1;\n                end\n                else\n                begin\n                    alu_out_reg         = 32'b0;\n                end\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLTU:\n            begin\n                if($signed(ALU_IN1) < $signed(ALU_IN2))\n                begin\n                    alu_out_reg         = 32'b1;\n                end\n                else\n                begin\n                    alu_out_reg         = 32'b0;\n                end\n                branch_taken_reg    = LOW;\n            end\n            ALU_XOR:\n            begin\n                alu_out_reg         = ALU_IN1 ^ ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRL:\n            begin\n                alu_out_reg         = ALU_IN1 >> ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRA:\n            begin\n                alu_out_reg         = ALU_IN1 >>> ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_OR:\n            begin\n                alu_out_reg         = ALU_IN1 | ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_AND:\n            begin\n                alu_out_reg         = ALU_IN1 & ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLLI:\n            begin\n                alu_out_reg         = ALU_IN1 << ALU_IN2[4:0];\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRLI:\n            begin\n                alu_out_reg         = ALU_IN1 >> ALU_IN2[4:0];\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRAI:\n            begin\n                alu_out_reg         = ALU_IN1 >>> ALU_IN2[4:0];\n                branch_taken_reg    = LOW;\n            end\n            ALU_JAL:\n            begin\n                alu_out_reg         = ALU_IN1 + 4;\n                branch_taken_reg    = LOW;\n            end\n            ALU_JALR:\n            begin\n                alu_out_reg         = PC_IN + 4;\n                branch_taken_reg    = LOW;\n            end\n            ALU_BEQ:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 == ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BNE:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 != ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BLT:\n            begin\n                alu_out_reg         = 32'b0;\n                if($signed(ALU_IN1) < $signed(ALU_IN2))\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BGE:\n            begin\n                alu_out_reg         = 32'b0;\n                if($signed(ALU_IN1) >= $signed(ALU_IN2))\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BLTU:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 == ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BGEU:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 >= ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end      \n            default:\n            begin\n                alu_out_reg         = 32'b0;\n                branch_taken_reg    = LOW;\n            end\n        endcase\n    end\n    \n    assign  ALU_OUT         = alu_out_reg       ;\n    assign  BRANCH_TAKEN    = branch_taken_reg  ;\n    \nendmodule\n",
        "module_name": "ALU #",
        "module_hash": "69e5acec21f3ea1d4586caab5c3edcc1",
        "dataset_index": 22070
      },
      "sky130_fd_sc_hd__a221o_446f80b4": {
        "rtl_code": "\nmodule sky130_fd_sc_hd__a221o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2                );\n    and and1 (and1_out , A1, A2                );\n    or  or0  (or0_out_X, and1_out, and0_out, C1);\n    buf buf0 (X        , or0_out_X             );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a221o",
        "module_hash": "446f80b4b304e2405b8466e3a0449a98",
        "dataset_index": 8200
      },
      "binary_adder_42bbb554": {
        "rtl_code": "module binary_adder(\n    input [3:0] in1,\n    input [3:0] in2,\n    input ctrl,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] temp_sum;\n    assign temp_sum = {1'b0, in1} + {1'b0, in2};\n\n    assign sum = (ctrl == 1'b0) ? temp_sum[3:0] : temp_sum[4];\n    assign cout = temp_sum[4];\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "42bbb554b9fc8a309ea5cc7312036da0",
        "dataset_index": 831
      },
      "mux_4to1_aa905083": {
        "rtl_code": "module mux_4to1 (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input sel0,\n  input sel1,\n  output reg out\n);\n\nalways @(*) begin\n  if (sel0 == 0 && sel1 == 0) begin\n    out = in0;\n  end else if (sel0 == 1 && sel1 == 0) begin\n    out = in1;\n  end else if (sel0 == 0 && sel1 == 1) begin\n    out = in2;\n  end else if (sel0 == 1 && sel1 == 1) begin\n    out = in3;\n  end\nend\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "aa9050838c2183acb6884d57d328a482",
        "dataset_index": 17415
      },
      "crossbar36_f8bbce5c": {
        "rtl_code": "module crossbar36\n  (input clk, input reset, input clear,\n   input cross,\n   input [35:0] data0_i, input src0_rdy_i, output dst0_rdy_o,\n   input [35:0] data1_i, input src1_rdy_i, output dst1_rdy_o,\n   output [35:0] data0_o, output src0_rdy_o, input dst0_rdy_i,\n   output [35:0] data1_o, output src1_rdy_o, input dst1_rdy_i);\n\n   reg \t\t cross_int, active0, active1;\n   wire active0_next = (src0_rdy_i & dst0_rdy_o)? ~data0_i[33] : active0;\n   wire active1_next = (src1_rdy_i & dst1_rdy_o)? ~data1_i[33] : active1;\n\n   assign data0_o = cross_int ? data1_i : data0_i;\n   assign data1_o = cross_int ? data0_i : data1_i;\n\n   assign src0_rdy_o = cross_int ? src1_rdy_i : src0_rdy_i;\n   assign src1_rdy_o = cross_int ? src0_rdy_i : src1_rdy_i;\n\n   assign dst0_rdy_o = cross_int ? dst1_rdy_i : dst0_rdy_i;\n   assign dst1_rdy_o = cross_int ? dst0_rdy_i : dst1_rdy_i;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active0 <= 0;\n     else\n       active0 <= active0_next;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active1 <= 0;\n     else\n       active1 <= active1_next;\n\n   always @(posedge clk)\n     if(reset | clear)\n       cross_int <= 0;\n     else if(~active0_next & ~active1_next)\n       cross_int <= cross;\n   \nendmodule ",
        "module_name": "crossbar36",
        "module_hash": "f8bbce5cc44740e4627f900042633232",
        "dataset_index": 24411
      },
      "top_module_13594c07": {
        "rtl_code": "\nmodule top_module(\n    input [3:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    input [1:0] select,\n    output [1:0] pos,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    output [2:0] out\n);\n    functional_module fm(.in(in), .a(a), .b(b), .select(select), .pos(pos), .out_or_bitwise(out_or_bitwise), .out_or_logical(out_or_logical), .out_not(out_not), .out(out));\nendmodule\n\nmodule functional_module(\n    input [3:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    input [1:0] select, // Added the select input port\n    output [1:0] pos,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    output [2:0] out\n);\n    priority_encoder pe(.in(in), .pos(pos));\n    binary_module bm(.a(a), .b(b), .out_or_bitwise(out_or_bitwise), .out_or_logical(out_or_logical), .out_not(out_not));\n    assign out = (select == 0) ? pos :\n                 (select == 1) ? {out_or_bitwise, out_or_logical, out_not[5:3]} :\n                                 {out_or_bitwise & out_not[2:0], out_or_logical & out_not[2:0]};\nendmodule\n\nmodule priority_encoder(\n    input [3:0] in,\n    output [1:0] pos\n);\n    assign pos = (in[3]) ? 2'b11 :\n                 (in[2]) ? 2'b10 :\n                 (in[1]) ? 2'b01 :\n                 (in[0]) ? 2'b00 :\n                           2'b00 ;\nendmodule\n\nmodule binary_module(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = (a || b);\n    assign out_not = ~{a, b};\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "13594c07de2ccf17755486fdfb3fda82",
        "dataset_index": 13868
      },
      "READ_ROM32_d64f6702": {
        "rtl_code": "\nmodule READ_ROM32 ( input[4:0] ADDR ,output[31:0] DATA_RE,output[31:0] DATA_IM);\nreg [31:0] re[0:31];\ninitial  begin\nre[0] = 32'h00000000;re[1] = 32'hFFE4CC88;re[2] = 32'h002DA5B3;re[3] = 32'hFFCE9932;\nre[4] = 32'h00254173;re[5] = 32'hFFF2E19A;re[6] = 32'hFFF0C26D;re[7] = 32'h0026B1CD;\nre[8] = 32'hFFCE4E3A;re[9] = 32'h002CB328;re[10] = 32'hFFE6AE85;re[11] = 32'hFFFDC9B2;\nre[12] = 32'h001D07D3;re[13] = 32'hFFD17EA5;re[14] = 32'h00310311;re[15] = 32'hFFDC4195;\nre[16] = 32'h000AF8A5;re[17] = 32'h0011551D;re[18] = 32'hFFD7F13F;re[19] = 32'h0031E3D5;\nre[20] = 32'hFFD455CB;re[21] = 32'h001762CC;re[22] = 32'h00046B81;re[23] = 32'hFFE13261;\nre[24] = 32'h002F45B3;re[25] = 32'hFFCF793E;re[26] = 32'h00222978;re[27] = 32'hFFF7329D;\nre[28] = 32'hFFEC9C0A;re[29] = 32'h002957A0;re[30] = 32'hFFCE0320;re[31] = 32'h002A8B5D;\nend\nreg [31:0] im[0:31];\ninitial  begin\nim[0] = 32'h00000000;im[1] = 32'h00000000;im[2] = 32'h00000000;im[3] = 32'h00000000;\nim[4] = 32'h00000000;im[5] = 32'h00000000;im[6] = 32'h00000000;im[7] = 32'h00000000;\nim[8] = 32'h00000000;im[9] = 32'h00000000;im[10] = 32'h00000000;im[11] = 32'h00000000;\nim[12] = 32'h00000000;im[13] = 32'h00000000;im[14] = 32'h00000000;im[15] = 32'h00000000;\nim[16] = 32'h00000000;im[17] = 32'h00000000;im[18] = 32'h00000000;im[19] = 32'h00000000;\nim[20] = 32'h00000000;im[21] = 32'h00000000;im[22] = 32'h00000000;im[23] = 32'h00000000;\nim[24] = 32'h00000000;im[25] = 32'h00000000;im[26] = 32'h00000000;im[27] = 32'h00000000;\nim[28] = 32'h00000000;im[29] = 32'h00000000;im[30] = 32'h00000000;im[31] = 32'h00000000;\nend\nassign DATA_RE = re[ADDR];\nassign DATA_IM = im[ADDR];\nendmodule",
        "module_name": "READ_ROM32",
        "module_hash": "d64f6702b06afa2f2cb94f8e1de65336",
        "dataset_index": 3070
      },
      "top__2510f05b": {
        "rtl_code": "module top_module (\n    input clk,\n    input [7:0] d,\n    input sel,\n    output [7:0] q\n);\n\nreg [7:0] q_int;\nreg [3:0] dff_sel;\n\nalways @(negedge clk) begin\n    q_int <= {q_int[6:0], d[0]};\n    dff_sel <= sel ? dff_sel + 1 : dff_sel - 1;\nend\n\nassign q = (dff_sel[3]) ? {q_int[7:4], q_int[3:0]} : {q_int[3:0], q_int[7:4]};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "2510f05ba3a886365370cbfe7f536b8a",
        "dataset_index": 20741
      },
      "bitwise_operations_with_adder_b2b044b9": {
        "rtl_code": "module bitwise_operations_with_adder (\n  input [31:0] a,\n  input [31:0] b,\n  input [1:0] operation_select,\n  input [4:0] shift_amount,\n  input [15:0] adder_input,\n  input select, \n  output reg [31:0] bitwise_result,\n  output reg [31:0] adder_result\n);\n\n  // Bitwise operations module\n  wire [31:0] and_result = a & b;\n  wire [31:0] or_result = a | b;\n  wire [31:0] xor_result = a ^ b;\n  wire [31:0] shift_left_result = a << shift_amount;\n\n  // Functional module\n  wire [31:0] functional_result = and_result;\n  always @(*) begin\n    adder_result = functional_result + adder_input;\n  end\n\n  // Control logic module\n  always @* begin\n    case(operation_select)\n      2'b00: bitwise_result = and_result;\n      2'b01: bitwise_result = or_result;\n      2'b10: bitwise_result = xor_result;\n      2'b11: bitwise_result = shift_left_result;\n    endcase\n\n    if(select) begin\n      bitwise_result = functional_result;\n    end\n  end\n\nendmodule",
        "module_name": "bitwise_operations_with_adder",
        "module_hash": "b2b044b9dd8b98495dbe6a2875602dbf",
        "dataset_index": 11369
      },
      "spi2_7fe2cc96": {
        "rtl_code": "\n\n\nmodule spi2(\n\n\tclock, sck,   sdo,   sdi,   bsync, start, rdy,   speed, din,  dout  );\n\n\tinput clock;\n\n\n\toutput sck;\n\twire   sck;\n\n\toutput sdo;\n\n\tinput sdi;\n\n\toutput reg bsync;\n\n\tinput start;\n\n\toutput rdy;\n\n\n\tinput [1:0] speed;\n\n\tinput [7:0] din;\n\n\toutput reg [7:0] dout;\n\n\n\n\treg [4:0] counter; wire enable_n; reg [6:0] shiftin; reg [7:0] shiftout; wire ena_shout_load; wire g_ena;\n\treg [2:0] wcnt;\n\n\n\tinitial begin\n\t\tcounter = 5'b10000;\n\t\tshiftout = 8'd0;\n\t\tshiftout = 7'd0;\n\t\tbsync = 1'd0;\n\t\tdout = 1'b0;\n\tend\n\n\n\tassign rdy = enable_n;\n\n\tassign sck = counter[0];\n\n\tassign enable_n = counter[4];\n\n\tassign sdo = shiftout[7];\n\n\tassign ena_shout_load = (start | sck) & g_ena;\n\n\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( g_ena )\n\t\tbegin\n\t\t\tif( start )\n\t\t\tbegin\n\t\t\t\tcounter <= 5'b00000; bsync <= 1'b1; end\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif( !sck ) begin\n      \t                  shiftin[6:0] <= { shiftin[5:0], sdi };\n\n\t\t\t\t\tif( (&counter[3:1]) && (!enable_n) )\n\t\t\t\t\t\tdout <= { shiftin[6:0], sdi }; end\n\t\t\t\telse begin\n\t\t\t\t\tbsync <= 1'b0;\n\t\t\t\tend\n\n\t\t\t\tif( !enable_n )\n\t\t\t\t\tcounter <= counter + 5'd1;\n\t\t\tend\n\t\tend\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( ena_shout_load )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\tshiftout <= din;\n\t\t\telse shiftout[7:0] <= { shiftout[6:0], shiftout[0] }; end\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( speed!=2'b00 )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\twcnt <= 3'b001;\n\t\t\telse if( enable_n )\n\t\t\t\twcnt <= 3'b000;\n\t\t\telse\n\t\t\t\twcnt <= wcnt + 3'd1;\n\t\tend\n\t\telse\n\t\t\twcnt <= 3'b000;\n\tend\n\n\tassign g_ena = (speed==2'b00) ? 1'b1 :\n\t               (speed==2'b01) ? (wcnt[0]  == 1'b0   ) :\n\t               (speed==2'b10) ? (wcnt[1:0]== 2'b00  ) :\n\t                                (wcnt[2:0]== 3'b000 ) ;\n\n\nendmodule\n\n",
        "module_name": "spi2",
        "module_hash": "7fe2cc9680a40dfebe3158b6319e29a1",
        "dataset_index": 24983
      },
      "my_nor4_580247e6": {
        "rtl_code": "module my_nor4 (\n    Y  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    wire AB, CD, ABCD;\n    \n    assign AB = ~(A | B);\n    assign CD = ~(C | D_N);\n    assign ABCD = ~(AB | CD);\n    \n    assign Y = ABCD;\n\nendmodule",
        "module_name": "my_nor4",
        "module_hash": "580247e604e2121aa61dc993e5daf30e",
        "dataset_index": 14641
      },
      "Update_Count_From_AB_d2dba0d1": {
        "rtl_code": "\n\nmodule Update_Count_From_AB\n          (\n           CLK_IN,\n           reset,\n           enb,\n           A,\n           B,\n           index,\n           count_max,\n           count\n          );\n\n\n  input   CLK_IN;\n  input   reset;\n  input   enb;\n  input   A;\n  input   B;\n  input   index;\n  input   signed [15:0] count_max;  output  signed [15:0] count;  parameter IN_NO_ACTIVE_CHILD = 0, IN_A0_B0 = 1, IN_A0_B1 = 2, IN_A1_B0 = 3, IN_A1_B1 = 4;\n  parameter IN_INDEX = 0, IN_INIT = 1;\n\n  reg [1:0] is_libEncoderPeripheralHdl_c7_Update_Count_From_AB;  reg [2:0] is_INDEX;  reg signed [15:0] count_reg;  reg [1:0] is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next;  reg [2:0] is_INDEX_next;  reg signed [15:0] count_reg_next;  always @(posedge CLK_IN)\n    begin : libEncoderPeripheralHdl_c7_Update_Count_From_AB_process\n      if (reset == 1'b1) begin\n        is_INDEX <= IN_NO_ACTIVE_CHILD;\n        count_reg <= 16'sd0;\n        is_libEncoderPeripheralHdl_c7_Update_Count_From_AB <= IN_INIT;\n      end\n      else if (enb) begin\n        is_libEncoderPeripheralHdl_c7_Update_Count_From_AB <= is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next;\n        is_INDEX <= is_INDEX_next;\n        count_reg <= count_reg_next;\n      end\n    end\n\n  always @(is_libEncoderPeripheralHdl_c7_Update_Count_From_AB, is_INDEX, A, B, index,\n       count_max, count_reg) begin\n    count_reg_next = count_reg;\n    is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next = is_libEncoderPeripheralHdl_c7_Update_Count_From_AB;\n    is_INDEX_next = is_INDEX;\n    case ( is_libEncoderPeripheralHdl_c7_Update_Count_From_AB)\n      IN_INDEX :\n        begin\n          if (index == 1'b1) begin\n            count_reg_next = 16'sd0;\n            is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next = IN_INDEX;\n            is_INDEX_next = IN_A0_B0;\n          end\n          else begin\n\n            case ( is_INDEX)\n              IN_A0_B0 :\n                begin\n                  if (A && ( ~ B)) begin\n                    count_reg_next = count_reg + 1;\n                    if ((count_reg + 16'sd1) > count_max) begin\n                      count_reg_next = 16'sd0;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A1_B0;\n                  end\n                  else if (( ~ A) && B) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A0_B1;\n                  end\n                end\n              IN_A0_B1 :\n                begin\n                  if (A && B) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A1_B1;\n                  end\n                  else begin\n                    if (( ~ A) && ( ~ B)) begin\n                      count_reg_next = count_reg + 1;\n                      if ((count_reg + 16'sd1) > count_max) begin\n                        count_reg_next = 16'sd0;\n                        end\n                      else begin\n                        end\n                      is_INDEX_next = IN_A0_B0;\n                    end\n                  end\n                end\n              IN_A1_B0 :\n                begin\n                  if (( ~ A) && ( ~ B)) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A0_B0;\n                  end\n                  else begin\n                    if (A && B) begin\n                      count_reg_next = count_reg + 1;\n                      if ((count_reg + 16'sd1) > count_max) begin\n                        count_reg_next = 16'sd0;\n                        end\n                      else begin\n                        end\n                      is_INDEX_next = IN_A1_B1;\n                    end\n                  end\n                end\n              default :\n                begin\n                  if (( ~ A) && B) begin\n                    count_reg_next = count_reg + 1;\n                    if ((count_reg + 16'sd1) > count_max) begin\n                      count_reg_next = 16'sd0;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A0_B1;\n                  end\n                  else if (A && ( ~ B)) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A1_B0;\n                  end\n                end\n            endcase\n\n          end\n        end\n      default :\n        begin\n          count_reg_next = 16'sd0;\n          is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next = IN_INDEX;\n          is_INDEX_next = IN_A0_B0;\n        end\n    endcase\n\n  end\n\n  assign count = count_reg_next;\n\n\n\nendmodule  ",
        "module_name": "Update_Count_From_AB",
        "module_hash": "d2dba0d1f6cecf5373be76397a2dd54f",
        "dataset_index": 21795
      },
      "video_timing_gen_32cd4b9e": {
        "rtl_code": "module video_timing_gen (\n  input aclk, rst,\n  input axis_tready, axis_tvalid,\n  input [23:0] axis_video,\n  input axis_eol, axis_sof,\n  input [1:0] fid,\n  input [11:0] active_pixels,\n  input [11:0] active_lines,\n  output reg video_clk, ce,\n  output [11:0] total_lines,\n  output [11:0] vsync_start, vsync_end,\n  output [11:0] total_pixels,\n  output [11:0] hsync_start, hsync_end,\n  output reg vtg_hsync, vtg_vsync, vtg_vblank, vtg_hblank, vtg_act_vid,\n  output reg [1:0] vtg_field_id\n);\n\n  // Constants\n  parameter H_SYNC_WIDTH = 96;\n  parameter H_BLANK_WIDTH = 208;\n  parameter V_SYNC_WIDTH = 2;\n  parameter V_BLANK_WIDTH = 35;\n\n  // Internal signals\n  reg [11:0] line_count = 0;\n  reg [11:0] pixel_count = 0;\n  reg [11:0] vsync_start_time = 0;\n  reg [11:0] vsync_end_time = 0;\n  reg [11:0] hsync_start_time = 0;\n  reg [11:0] hsync_end_time = 0;\n  reg [11:0] total_pixels_reg = 0;\n  reg [11:0] total_lines_reg = 0;\n  reg [1:0] field_id_reg = 0;\n\n  // Video data input\n  reg [7:0] r, g, b;\n\n  always @(posedge aclk) begin\n    if (rst) begin\n      video_clk <= 0;\n      ce <= 0;\n      line_count <= 0;\n      pixel_count <= 0;\n      vsync_start_time <= 0;\n      vsync_end_time <= 0;\n      hsync_start_time <= 0;\n      hsync_end_time <= 0;\n      total_pixels_reg <= 0;\n      total_lines_reg <= 0;\n      field_id_reg <= 0;\n      vtg_hsync <= 0;\n      vtg_vsync <= 0;\n      vtg_vblank <= 0;\n      vtg_hblank <= 0;\n      vtg_act_vid <= 0;\n      vtg_field_id <= 0;\n    end else begin\n      // Video timing generator\n      if (line_count < active_lines) begin\n        vtg_act_vid <= 1;\n      end else begin\n        vtg_act_vid <= 0;\n      end\n      if (line_count < active_lines + V_SYNC_WIDTH) begin\n        vtg_vsync <= 0;\n      end else if (line_count < active_lines + V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vtg_vsync <= 1;\n        vtg_vblank <= 1;\n      end else if (line_count < 2*active_lines + V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vtg_vsync <= 0;\n        vtg_vblank <= 0;\n      end else if (line_count < 2*active_lines + 2*V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vtg_vsync <= 1;\n        vtg_vblank <= 1;\n      end else begin\n        vtg_vsync <= 0;\n        vtg_vblank <= 0;\n      end\n      if (pixel_count < active_pixels) begin\n        vtg_hsync <= 1;\n        vtg_hblank <= 0;\n        vtg_field_id <= field_id_reg;\n      end else if (pixel_count < active_pixels + H_SYNC_WIDTH) begin\n        vtg_hsync <= 0;\n        vtg_hblank <= 0;\n      end else if (pixel_count < active_pixels + H_SYNC_WIDTH + H_BLANK_WIDTH) begin\n        vtg_hsync <= 0;\n        vtg_hblank <= 1;\n      end else begin\n        vtg_hsync <= 0;\n        vtg_hblank <= 0;\n        pixel_count <= 0;\n        line_count <= line_count + 1;\n        if (line_count >= 2*active_lines + 2*V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n          line_count <= 0;\n          total_lines_reg <= total_lines_reg + 1;\n          field_id_reg <= ~field_id_reg;\n        end\n      end\n\n      // Video clock generator\n      if (pixel_count == active_pixels - 1) begin\n        video_clk <= 1;\n        total_pixels_reg <= total_pixels_reg + active_pixels;\n        pixel_count <= 0;\n        ce <= 1;\n      end else begin\n        video_clk <= 0;\n        pixel_count <= pixel_count + 1;\n        ce <= 0;\n      end\n\n      // Video data input\n      if (axis_tvalid && axis_tready) begin\n        r <= axis_video[23:16];\n        g <= axis_video[15:8];\n        b <= axis_video[7:0];\n      end\n\n      // Vertical sync pulse timing\n      if (line_count == active_lines + V_SYNC_WIDTH) begin\n        vsync_start_time <= total_pixels_reg + pixel_count;\n      end\n      if (line_count == active_lines + V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vsync_end_time <= total_pixels_reg + pixel_count;\n      end\n\n      // Horizontal sync pulse timing\n      if (pixel_count == active_pixels + H_SYNC_WIDTH) begin\n        hsync_start_time <= total_pixels_reg + pixel_count;\n      end\n      if (pixel_count == active_pixels + H_SYNC_WIDTH + H_BLANK_WIDTH) begin\n        hsync_end_time <= total_pixels_reg + pixel_count;\n      end\n    end\n  end\n\n  assign total_pixels = total_pixels_reg;\n  assign total_lines = total_lines_reg;\n  assign vsync_start = vsync_start_time;\n  assign vsync_end = vsync_end_time;\n  assign hsync_start = hsync_start_time;\n  assign hsync_end = hsync_end_time;\n\nendmodule",
        "module_name": "video_timing_gen",
        "module_hash": "32cd4b9e34c27e3abd2344b1452c55d8",
        "dataset_index": 2883
      },
      "airplane_8bca4180": {
        "rtl_code": "module airplane(\n\tinput clk,\n\tinput rst,\n\tinput [10:0] x,\n\tinput [10:0] y,\n\tinput [10:0] poX,\n\tinput [10:0] poY,\n\toutput reg wing,\n\toutput reg body\n);\n\nparameter pL = 40;\nparameter pW = 10;\nparameter wL = 15;\nparameter wW = 15;\nparameter wP = 15;\n\n// body\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) body <= 0;\n\telse begin\n\t\tif(x < poX+pL && x > poX && y < poY+wL+pW && y >poY+wL) body <= 1;\n\t\telse body <= 0;\n\tend\nend\n\n// wing\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) wing <= 0;\n\telse begin\n\t\tif(x < poX+wP+wW && x > poX+wP && y < poY+wL && y > poY && x-y-poX+poY < wP) wing <= 1;\n\t\telse if(x < poX+wP+wW && x > poX+wP && y > poY+wL+pW && y < poY+wL+wL+pW && x-poX+y-poY < wP+pL) wing <= 1;\n\t\telse wing <= 0;\n\tend\nend\n\nendmodule",
        "module_name": "airplane",
        "module_hash": "8bca41801db31116170b7b86a0ca620b",
        "dataset_index": 13375
      },
      "my_4input_nand_469c6b70": {
        "rtl_code": "\nmodule my_4input_nand (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D   \n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    \n    wire nand1_out;\n    wire nand2_out;\n    wire nand3_out;\n    \n    nand (\n        nand1_out,\n        A,\n        B,\n        C,\n        D\n    );\n    \n    nand (\n        nand2_out,\n        nand1_out,\n        nand1_out\n    );\n    \n    not (\n        nand3_out,\n        nand2_out\n    );\n    \n    assign Y = nand3_out;\n\nendmodule\n",
        "module_name": "my_4input_nand",
        "module_hash": "469c6b70463157f5cb534dffd1e5b83b",
        "dataset_index": 16889
      },
      "message_formatter #_05a4738f": {
        "rtl_code": "\n\nmodule message_formatter #\n(\nparameter WIDTH = 24,       parameter COUNT = 2,        parameter TX_INTERVAL = 4   )\n(\ninput  wire CLK,\ninput  wire RST,\n\ninput  wire I_STB,\ninput  wire [(WIDTH*COUNT)-1:0] I_DAT,\n\noutput wire O_STB,\noutput wire [7:0] O_DAT\n);\n\nlocalparam TOTAL_WIDTH = WIDTH * COUNT;\n\ninteger fsm;\n\nlocalparam FSM_IDLE     = 'h00;\nlocalparam FSM_TX_HEX   = 'h11;\nlocalparam FSM_TX_CR    = 'h21;\nlocalparam FSM_TX_LF    = 'h22;\nlocalparam FSM_TX_SEP   = 'h31;\n\nreg [24:0]  tx_dly_cnt;\nreg         tx_req;\nwire        tx_rdy;\n\nalways @(posedge CLK)\n    if (RST)\n        tx_dly_cnt <= -1;\n    else if (!tx_rdy)\n        tx_dly_cnt <= tx_dly_cnt  - 1;\n    else if ( tx_rdy && tx_req)\n        tx_dly_cnt <= TX_INTERVAL - 2;\n\nassign tx_rdy = tx_dly_cnt[24];\n\nalways @(posedge CLK)\n    if (RST)\n        tx_req <= 1'b0;\n    else case (fsm)\n\n    FSM_TX_HEX: tx_req <= 1'b1;\n    FSM_TX_SEP: tx_req <= 1'b1;\n    FSM_TX_CR:  tx_req <= 1'b1;\n    FSM_TX_LF:  tx_req <= 1'b1;\n\n    default:    tx_req <= 1'b0;\n\n    endcase\n\nreg  [7:0] char_cnt;\nreg  [7:0] word_cnt;\n\nalways @(posedge CLK)\n    if (fsm == FSM_IDLE || fsm == FSM_TX_SEP)\n        char_cnt <= (WIDTH/4) - 1;\n    else if (tx_rdy && fsm == FSM_TX_HEX)\n        char_cnt <= char_cnt - 1;\n\nalways @(posedge CLK)\n    if (fsm == FSM_IDLE)\n        word_cnt <= COUNT - 1;\n    else if (tx_rdy && fsm == FSM_TX_SEP)\n        word_cnt <= word_cnt - 1;\n\nreg  [TOTAL_WIDTH-1:0] sr_reg;\nwire [3:0] sr_dat;\n\nalways @(posedge CLK)\n    if (fsm == FSM_IDLE && I_STB)\n        sr_reg <= I_DAT;\n    else if (fsm == FSM_TX_HEX && tx_rdy)\n        sr_reg <= sr_reg << 4;\n\nassign sr_dat = sr_reg[TOTAL_WIDTH-1:TOTAL_WIDTH-4];\n\nalways @(posedge CLK)\n    if (RST)\n        fsm <= FSM_IDLE;\n    else case (fsm)\n\n    FSM_IDLE:   if (I_STB) fsm <= FSM_TX_HEX;\n\n    FSM_TX_HEX:\n                if (tx_rdy && (char_cnt == 0) && (word_cnt == 0))\n                    fsm <= FSM_TX_CR;\n                else if (tx_rdy && (char_cnt == 0)) fsm <= FSM_TX_SEP;\n                else if (tx_rdy && (char_cnt != 0)) fsm <= FSM_TX_HEX;\n\n    FSM_TX_SEP: if (tx_rdy) fsm <= FSM_TX_HEX;\n    FSM_TX_CR:  if (tx_rdy) fsm <= FSM_TX_LF;\n    FSM_TX_LF:  if (tx_rdy) fsm <= FSM_IDLE;\n\n    endcase\n\nreg        o_stb;\nreg  [7:0] o_dat;\n\nalways @(posedge CLK or posedge RST)\n    if (RST)\n        o_stb <= 1'd0;\n    else\n        o_stb <= tx_req & tx_rdy;\n\nalways @(posedge CLK)\n    if      (fsm == FSM_TX_CR)\n        o_dat <= 8'h0D;\n    else if (fsm == FSM_TX_LF)\n        o_dat <= 8'h0A;\n    else if (fsm == FSM_TX_SEP)\n        o_dat <= \"_\";\n    else if (fsm == FSM_TX_HEX) case (sr_dat)\n        4'h0: o_dat <= \"0\";\n        4'h1: o_dat <= \"1\";\n        4'h2: o_dat <= \"2\";\n        4'h3: o_dat <= \"3\";\n        4'h4: o_dat <= \"4\";\n        4'h5: o_dat <= \"5\";\n        4'h6: o_dat <= \"6\";\n        4'h7: o_dat <= \"7\";\n        4'h8: o_dat <= \"8\";\n        4'h9: o_dat <= \"9\";\n        4'hA: o_dat <= \"A\";\n        4'hB: o_dat <= \"B\";\n        4'hC: o_dat <= \"C\";\n        4'hD: o_dat <= \"D\";\n        4'hE: o_dat <= \"E\";\n        4'hF: o_dat <= \"F\";\n    endcase\n\nassign O_STB = o_stb;\nassign O_DAT = o_dat;\n\nendmodule\n",
        "module_name": "message_formatter #",
        "module_hash": "05a4738f9ed7f309682ef62f4b5b0395",
        "dataset_index": 8554
      },
      "dataprocessor_e81e36d7": {
        "rtl_code": "module dataprocessor(\n    input wire [9:0] datain,\n    input wire clk,\n    input wire reset,\n    output reg [9:0] dataout,\n    output reg validout\n);\n\nalways @(posedge clk) begin\n    if (reset == 1'b1) begin\n        dataout <= 0;\n        validout <= 0;\n    end else begin\n        if (datain >= 10'd100) begin\n            dataout <= datain;\n            validout <= 1;\n        end else begin\n            dataout <= 0;\n            validout <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "dataprocessor",
        "module_hash": "e81e36d74c4a5352a2a5d5633425f117",
        "dataset_index": 6523
      },
      "cycloneii_mac_sign_ext_bc6d7a1e": {
        "rtl_code": "module cycloneii_mac_sign_ext (\n  input clk,\n  input signed [15:0] data_in_a,\n  input signed [15:0] data_in_b,\n  input enable,\n  output signed [31:0] result\n);\n\n  wire [31:0] mult_result;\n  wire [31:0] sign_ext_result;\n  reg signed [31:0] accum_result;\n\n  // Perform signed multiplication of input data\n  assign mult_result = data_in_a * data_in_b;\n\n  // Sign-extend the multiplication result to 32 bits\n  assign sign_ext_result = {{16{mult_result[15]}}, mult_result[15:0]};\n\n  // Update the accumulator result on the rising edge of the clock if enable is high\n  always @(posedge clk) begin\n    if (enable) begin\n      accum_result <= accum_result + sign_ext_result;\n    end\n  end\n\n  // Assign the accumulator result to the output\n  assign result = accum_result;\n\nendmodule",
        "module_name": "cycloneii_mac_sign_ext",
        "module_hash": "bc6d7a1e4b94c575d6dc1bd71c0a0ec9",
        "dataset_index": 17030
      },
      "sample_generator_9ae3a4eb": {
        "rtl_code": "module sample_generator (\n  input wire [7:0] FrameSize,\n  input wire En,\n  input wire AXI_En,\n  output wire [31:0] m_axis_tdata,\n  output wire [3:0] m_axis_tstrb,\n  output wire m_axis_tlast,\n  output wire m_axis_tvalid,\n  input wire m_axis_tready,\n  input wire m_axis_aclk,\n  input wire m_axis_aresetn,\n  input wire [31:0] s_axis_tdata,\n  input wire [3:0] s_axis_tstrb,\n  input wire s_axis_tlast,\n  input wire s_axis_tvalid,\n  output wire s_axis_tready,\n  input wire s_axis_aclk,\n  input wire s_axis_aresetn\n);\n\n  // Local parameters\n  localparam IDLE = 0, START = 1, DATA = 2, END = 3;\n  \n  // Local variables\n  reg [7:0] frame_count = 0;\n  reg [31:0] data_count = 0;\n  reg [31:0] data = 0;\n  reg [3:0] strb = 0;\n  reg [1:0] state = IDLE;\n  reg valid = 0;\n  reg last = 0;\n  \n  // AXI4Stream interface\n  assign s_axis_tready = (state == DATA) ? m_axis_tready : 1'b0;\n  assign m_axis_tdata = data;\n  assign m_axis_tstrb = strb;\n  assign m_axis_tlast = last;\n  assign m_axis_tvalid = valid;\n  \n  // State machine\n  always @(posedge m_axis_aclk) begin\n    if (!m_axis_aresetn) begin\n      frame_count <= 0;\n      data_count <= 0;\n      data <= 0;\n      strb <= 0;\n      state <= IDLE;\n      valid <= 0;\n      last <= 0;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (En && AXI_En) begin\n            frame_count <= frame_count + 1;\n            data_count <= 0;\n            state <= START;\n          end\n        end\n        START: begin\n          valid <= 1;\n          if (s_axis_tready) begin\n            state <= DATA;\n          end\n        end\n        DATA: begin\n          valid <= 1;\n          data_count <= data_count + 4;\n          data <= data_count;\n          strb <= 4'b1111;\n          if (data_count + 4 >= FrameSize) begin\n            last <= 1;\n            state <= END;\n          end\n        end\n        END: begin\n          valid <= 1;\n          if (s_axis_tready) begin\n            last <= 0;\n            if (frame_count == 255) begin\n              state <= IDLE;\n            end else begin\n              state <= START;\n            end\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "sample_generator",
        "module_hash": "9ae3a4eb0ae0deb8e4b4ce1f86b9e467",
        "dataset_index": 6457
      },
      "adder4_f7c73eeb": {
        "rtl_code": "module adder4 (\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] temp_sum;\n  wire c1, c2, c3;\n\n  // First stage of addition\n  full_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(temp_sum[0]), .cout(c1));\n\n  // Second stage of addition\n  full_adder fa2(.a(a[1]), .b(b[1]), .cin(c1), .sum(temp_sum[1]), .cout(c2));\n\n  // Third stage of addition\n  full_adder fa3(.a(a[2]), .b(b[2]), .cin(c2), .sum(temp_sum[2]), .cout(c3));\n\n  // Fourth stage of addition\n  full_adder fa4(.a(a[3]), .b(b[3]), .cin(c3), .sum(temp_sum[3]), .cout(cout));\n\n  assign sum = temp_sum;\n\nendmodule\n\nmodule full_adder (\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (cin & a) | (cin & b);\n\nendmodule",
        "module_name": "adder4",
        "module_hash": "f7c73eebc2e499f9f7610b46777b3993",
        "dataset_index": 17470
      },
      "output_signal__7f1df17d": {
        "rtl_code": "module output_signal_module (\n  input        clk,\n  input        reset,\n  input  [15:0] input_signal,\n  output [3:0] output_signal\n);\n\n  reg [3:0] output_reg;\n\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      output_reg <= 4'b0;\n    end else begin\n      output_reg <= input_signal[15:12];\n    end\n  end\n\n  assign output_signal = output_reg;\n\nendmodule",
        "module_name": "output_signal_",
        "module_hash": "7f1df17d578ba495870ea68959c180dd",
        "dataset_index": 7873
      },
      "map_table_e99c0b3a": {
        "rtl_code": "module map_table(\n    output [5:0] p_rs, p_rt,\n    output p_rs_v, p_rt_v,\n    output [5:0] PR_old_rd,\n    \n    input clk, rst,\n    \n    input hazard_stall, input isDispatch,\n    input [4:0] l_rs, l_rt, l_rd,\n    input RegDest,\n    input [5:0] p_rd_new,\n\n    input [4:0] recover_rd,\n    input [5:0] p_rd_flush,\n    input recover,\n    input RegDest_ROB,\n    \n    input [5:0] p_rd_compl,\n    input complete,\n    input RegDest_compl  \n);\n\nreg [5:0] mt [0:31];\nreg [63:0] PR_valid;  wire write_new_rd;\ninteger i;\n\nassign write_new_rd = isDispatch && RegDest && !hazard_stall && !recover;\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin                             for (i = 0; i < 32; i = i + 1) begin\n            mt[i] <= i;\n        end\n    end\n    else if (write_new_rd)\n        mt[l_rd] <= p_rd_new;\n    else if (RegDest_ROB && recover) \n        mt[recover_rd] <= p_rd_flush;     \nend\n\nassign p_rs = mt[l_rs];\nassign p_rt = mt[l_rt];\nassign PR_old_rd = mt[l_rd];  \nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        PR_valid <= 64'hFFFFFFFFFFFFFFFF;\n    end\n    else begin\n        if (write_new_rd)\n            PR_valid[p_rd_new] <= 1'b0;  \n        if (complete && RegDest_compl)  PR_valid[p_rd_compl] <= 1'b1; end\nend\n\nassign p_rs_v = PR_valid[p_rs];\nassign p_rt_v = PR_valid[p_rt];     \n\nendmodule\n",
        "module_name": "map_table",
        "module_hash": "e99c0b3a162125268f9bdf22d5a6cb33",
        "dataset_index": 13225
      },
      "memory_to_color_023f8aea": {
        "rtl_code": "module memory_to_color(\n  input  [1:0]  color_depth_i,\n  input  [31:0] mem_i,\n  input  [1:0]  mem_lsb_i,\n  output [31:0] color_o,\n  output [3:0]  sel_o\n);\n\n  assign sel_o = (color_depth_i == 2'b00) ? // 8-bit\n                  (mem_lsb_i == 2'b00) ? 4'b0001 : // least significant byte\n                  (mem_lsb_i == 2'b01) ? 4'b0010 : // second least significant byte\n                  (mem_lsb_i == 2'b10) ? 4'b0100 : // third least significant byte\n                  (mem_lsb_i == 2'b11) ? 4'b1000 : // most significant byte\n                  4'bxxxx : // error\n                (color_depth_i == 2'b01) ? // 16-bit\n                  (mem_lsb_i == 2'b0) ? 4'b0011 : // low word\n                  (mem_lsb_i == 2'b1) ? 4'b1100 : // high word\n                  4'bxxxx : // error\n                (color_depth_i == 2'b10) ? 4'b1111 : // 32-bit\n                  4'bxxxx; // error\n\n  assign color_o = (color_depth_i == 2'b00) ? // 8-bit\n                  (mem_lsb_i == 2'b00) ? {mem_i[31:24], 8'h00, 8'h00} : // least significant byte\n                  (mem_lsb_i == 2'b01) ? {8'h00, mem_i[23:16], 8'h00} : // second least significant byte\n                  (mem_lsb_i == 2'b10) ? {8'h00, 8'h00, mem_i[15:8]} : // third least significant byte\n                  (mem_lsb_i == 2'b11) ? {8'h00, 8'h00, 8'h00, mem_i[7:0]} : // most significant byte\n                  32'hxxxxxxxx : // error\n                (color_depth_i == 2'b01) ? // 16-bit\n                  (mem_lsb_i == 2'b0) ? {mem_i[31:16], 16'h0000} : // low word\n                  (mem_lsb_i == 2'b1) ? {16'h0000, mem_i[15:0]} : // high word\n                  32'hxxxxxxxx : // error\n                (color_depth_i == 2'b10) ? // 32-bit\n                  mem_i : // use entire memory data\n                  32'hxxxxxxxx; // error\n\nendmodule",
        "module_name": "memory_to_color",
        "module_hash": "023f8aeaf2e35cfa9736d85333c16bce",
        "dataset_index": 9308
      },
      "sync_counter_9083b652": {
        "rtl_code": "module sync_counter (\n    input clk,\n    input reset,\n    output reg [3:0] out\n);\n\nreg [3:0] state = 4'b0000;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 4'b0000;\n        out <= 4'b0000;\n    end else begin\n        case (state)\n            4'b0000: begin\n                state <= 4'b0001;\n                out <= 4'b0000;\n            end\n            4'b0001: begin\n                state <= 4'b0010;\n                out <= 4'b0001;\n            end\n            4'b0010: begin\n                state <= 4'b0011;\n                out <= 4'b0010;\n            end\n            4'b0011: begin\n                state <= 4'b0100;\n                out <= 4'b0011;\n            end\n            4'b0100: begin\n                state <= 4'b0101;\n                out <= 4'b0100;\n            end\n            4'b0101: begin\n                state <= 4'b0110;\n                out <= 4'b0101;\n            end\n            4'b0110: begin\n                state <= 4'b0111;\n                out <= 4'b0110;\n            end\n            4'b0111: begin\n                state <= 4'b1000;\n                out <= 4'b0111;\n            end\n            4'b1000: begin\n                state <= 4'b0000;\n                out <= 4'b1000;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "sync_counter",
        "module_hash": "9083b652447c14bac919eaf20db4566d",
        "dataset_index": 2175
      },
      "BIU_bb8701d2": {
        "rtl_code": "\n\nmodule BIU(\ninput wire clk,\ninput wire rst,\n\n input  wire      wb_d_ack_i, input  wire      wb_d_err_i, input  wire      wb_d_rty_i, input  wire [31:0]       wb_d_dat_i, output reg      wb_d_cyc_o, output reg [31:0]      wb_d_adr_o, output reg      wb_d_stb_o, output reg      wb_d_we_o,  output reg [3:0]       wb_d_sel_o, output reg [31:0]      wb_d_dat_o, input  wire      wb_c_ack_i, input  wire      wb_c_err_i, input  wire      wb_c_rty_i, input  wire [7:0]       wb_c_dat_i, output reg [31:0]      wb_c_adr_o, output reg      wb_c_stb_o, output reg      wb_c_we_o,  output reg [7:0]      wb_c_dat_o, input wire Cpu_mem_w_i,\ninput wire [31:0] Cpu_data2bus_i,                                   input wire Cpu_req_i,\ninput wire [31:0] Cpu_addr_bus_i,\noutput reg [31:0] Cpu_data4bus_o,\noutput reg Cpu_ready_o,\n\noutput reg MIO_mem_w_o,\noutput reg [31:0] MIO_data2bus_o,                                   output reg [31:0] MIO_addr_bus_o,\ninput wire [31:0] MIO_data4bus_i,\ninput wire MIO_ready_i,\n\noutput reg txt_ena,\noutput reg txt_wea,\noutput reg [12:0] txt_addra,\ninput wire [15:0] txt_dina,\noutput reg [15:0] txt_douta,\n\noutput reg [31:0] gpu_status\n    );\n\nalways @(*) begin\n    MIO_data2bus_o   <= Cpu_data2bus_i;\n    wb_d_dat_o       <= Cpu_data2bus_i;\n    wb_c_dat_o       <= Cpu_data2bus_i;\n    txt_douta        <= Cpu_data2bus_i;\n\n    MIO_addr_bus_o   <= Cpu_addr_bus_i;\n    wb_d_adr_o       <= Cpu_addr_bus_i;\n    wb_c_adr_o       <= Cpu_addr_bus_i;\n    txt_addra        <= Cpu_addr_bus_i;\nend\n\nalways @(*) begin\n    wb_d_sel_o <= 4'b1111;\nend\n\nalways @(*) begin\n    MIO_mem_w_o      <= 0;\n    wb_d_we_o        <= 0;\n    wb_c_we_o        <= 0;\n    txt_wea          <= 0;\n\n    wb_d_cyc_o       <= 0;\n    wb_d_stb_o       <= 0;\n    wb_c_stb_o       <= 0;\n    txt_ena          <= 0;\n\n    Cpu_data4bus_o <= 0;\n    Cpu_ready_o    <= 0;\n\n    case(Cpu_addr_bus_i[31:28])\n        4'h3: begin\n            wb_d_we_o        <= Cpu_mem_w_i;\n            Cpu_data4bus_o   <= wb_d_dat_i;\n            Cpu_ready_o      <= wb_d_ack_i;\n            wb_d_cyc_o       <= Cpu_req_i;\n            wb_d_stb_o       <= Cpu_req_i;\n        end\n        4'hb: if (Cpu_addr_bus_i[27]) begin\n            Cpu_data4bus_o   <= gpu_status;\n            Cpu_ready_o      <= 1'b1;\n        end else begin\n            txt_wea          <= Cpu_mem_w_i;\n            Cpu_data4bus_o   <= txt_dina;\n            Cpu_ready_o      <= 1'b1;\n            txt_ena          <= Cpu_req_i;\n        end\n        4'hc: begin\n            wb_c_we_o        <= Cpu_mem_w_i;\n            Cpu_data4bus_o   <= wb_c_dat_i;\n            Cpu_ready_o      <= wb_c_ack_i;\n            wb_c_stb_o       <= Cpu_req_i;\n        end\n        default: begin\n            MIO_mem_w_o    <= Cpu_mem_w_i;\n            Cpu_data4bus_o <= MIO_data4bus_i;\n            Cpu_ready_o    <= MIO_ready_i;\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        gpu_status <= 0;\n    end else if(Cpu_addr_bus_i[31:28] == 4'hb && Cpu_addr_bus_i[27] && Cpu_req_i && Cpu_mem_w_i) begin\n        gpu_status <= Cpu_data2bus_i;\n    end\nend\n\nendmodule\n",
        "module_name": "BIU",
        "module_hash": "bb8701d2a8c31541038791db95ae5017",
        "dataset_index": 21962
      },
      "nand4_eacf6a5f": {
        "rtl_code": "module nand4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\n    wire nand1_out, nand2_out;\n\n    nand2 nand1(.A(A), .B(B), .Y(nand1_out));\n    nand2 nand2(.A(C), .B(D), .Y(nand2_out));\n    nand2 nand3(.A(nand1_out), .B(nand2_out), .Y(Y)); \n\nendmodule\n\nmodule nand2(\n    input A,\n    input B,\n    output Y\n);\n\nassign Y = ~(A & B);\n\nendmodule\n",
        "module_name": "nand4",
        "module_hash": "eacf6a5f3fa9ac1230e6ccd89f132f63",
        "dataset_index": 134
      },
      "top__3ad1500a": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input valid_in,\n    output reg ready_out,\n    output [3:0] seq_length_out\n);\n\nreg [3:0] seq_length_current;\nreg [3:0] seq_length_max;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        seq_length_current <= 4'b0;\n        seq_length_max <= 4'b0;\n        ready_out <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (data_in[0]) begin\n                seq_length_current <= seq_length_current + 1;\n            end else begin\n                seq_length_current <= 4'b0;\n            end\n            if (seq_length_current > seq_length_max) begin\n                seq_length_max <= seq_length_current;\n            end\n            ready_out <= 1'b1;\n        end else begin\n            ready_out <= 1'b0;\n        end\n    end\nend\n\nreg [3:0] seq_length_out_reg;\n\nalways @(posedge clk) begin\n    if (valid_in) begin\n        seq_length_out_reg <= seq_length_max;\n    end\nend\n\nassign seq_length_out = seq_length_out_reg;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "3ad1500a695c8e3c7cd8e95db803d2b9",
        "dataset_index": 14841
      },
      "unknown_module_b02e39c1": {
        "rtl_code": "\n\n\t\t\t\t\t\t\tparameter\n\t\t\t\t\t\t\tRESET_PERIOD\t=\t4\n\t\t\t\t\t\t\t)\n(\ninput\t\twire\t\tCLK_I,\ninput\t\twire\t\tRST_I,\noutput\twire\t\tSRST_O\n);\n\nreg \t[RESET_PERIOD:0]\tRstQ;\n\ninitial\n\t\tbegin\n\t\t\tRstQ[RESET_PERIOD:1]={RESET_PERIOD{1'b1}};\n\t\t\tRstQ[0]=1'b0;\n\t\tend\n\nalways\nRstQ[0] = 1'b0;\n\n\ngenvar i;\n\n\t\tgenerate\n\t\t\tfor(i=1;i<RESET_PERIOD+1;i=i+1)\n\t\t\t\talways@(posedge CLK_I)\n\t\t\t\t\tif(RST_I)\n\t\t\t\t\tRstQ[i]\t<=\t1;\n\t\t\t\t\telse\n\t\t\t\t\tRstQ[i]\t<=\tRstQ[i-1];\n\t\tendgenerate\n\n\tassign SRST_O\t=\tRstQ[RESET_PERIOD];\n\n\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "b02e39c1c132b3b8611e2c7b9a278625",
        "dataset_index": 22633
      },
      "mux_min_xor_c6bbfe60": {
        "rtl_code": "\nmodule mux_min_xor (\n    input [2:0] sel, // Select input for the 6-to-1 mux\n    input [3:0] data0, // Input 0 for the 6-to-1 mux\n    input [3:0] data1, // Input 1 for the 6-to-1 mux\n    input [3:0] data2, // Input 2 for the 6-to-1 mux\n    input [3:0] data3, // Input 3 for the 6-to-1 mux\n    input [3:0] data4, // Input 4 for the 6-to-1 mux\n    input [3:0] data5, // Input 5 for the 6-to-1 mux\n    input [7:0] a, b, c, d, // Inputs for the 4-way minimum circuit\n    output [7:0] out // Output of the functional module\n);\n\n// 6-to-1 multiplexer\nwire [3:0] mux_out;\nassign mux_out = (sel == 3'b000) ? data0 :\n                 (sel == 3'b001) ? data1 :\n                 (sel == 3'b010) ? data2 :\n                 (sel == 3'b011) ? data3 :\n                 (sel == 3'b100) ? data4 :\n                 (sel == 3'b101) ? data5 :\n                 4'b0000;\n\n\n// 4-way minimum circuit\n\nwire [7:0] min_out;\nassign min_out[7:0] = {a[7]&b[7],a[7]&c[7],a[7]&d[7],\n                       b[7]&c[7],b[7]&d[7],\n                       c[7]&d[7],\n                       a[6:0] < b[6:0] ? a[6:0] : b[6:0],\n                       a[6:0] < c[6:0] ? a[6:0] : c[6:0],\n                       a[6:0] < d[6:0] ? a[6:0] : d[6:0],\n                       b[6:0] < c[6:0] ? b[6:0] : c[6:0],\n                       b[6:0] < d[6:0] ? b[6:0] : d[6:0],\n                       c[6:0] < d[6:0] ? c[6:0] : d[6:0]};\n\n// XOR output\nassign out = mux_out ^ min_out;\n\nendmodule",
        "module_name": "mux_min_xor",
        "module_hash": "c6bbfe60eb63115a21d1e1fdfd64d82e",
        "dataset_index": 1321
      },
      "bitwise_operation_ee22b455": {
        "rtl_code": "\nmodule bitwise_operation(x, y, out);\n  // IO ports\n  input  [15:0] x, y;\n  output [15:0] out;\n\n  // Net declarations\n  wire [15:0] and_n, or_n, not_n, xor_n;\n  wire [2:0] func;\n\n  // Assignments\n  assign func = 3'b010; // Select NOT operation\n  assign and_n  = x & y;\n  assign or_n   = x | y;\n  assign not_n  = ~x;\n  assign xor_n  = x ^ y;\n  assign out = not_n;\n\nendmodule",
        "module_name": "bitwise_operation",
        "module_hash": "ee22b4555a1e742c55e529d844cd0be6",
        "dataset_index": 9377
      },
      "pulse_generator #_8ee7ce74": {
        "rtl_code": "module pulse_generator #(\n  parameter WIDTH=8\n) (\n  input clock,\n  input reset,\n  input enable,\n  input [WIDTH-1:0] rate,\n  input strobe_fast,\n  output reg strobe_slow\n);\n\n  reg [WIDTH-1:0] counter;\n  wire now = (counter == 1);\n  \n  always @(posedge clock)\n    if(reset)\n      counter <= 0; \n    else if (~enable)\n      counter <= rate;\n    else if(strobe_fast)\n    begin\n      if(now)\n        counter <= rate;\n      else \n        counter <= counter - 1;\n    end\n\n  always @*\n    strobe_slow = now && enable && strobe_fast;\n\nendmodule",
        "module_name": "pulse_generator #",
        "module_hash": "8ee7ce740cc788e8c083e76cfc4cd8e4",
        "dataset_index": 7169
      },
      "sky130_fd_sc_ms__nand4bb_c25ddeb6": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__nand4bb (\n    Y  ,\n    A_N,\n    B_N,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B_N;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out;\n    wire or0_out_Y;\n\n    nand nand0 (nand0_out, D, C               );\n    or   or0   (or0_out_Y, B_N, A_N, nand0_out);\n    buf  buf0  (Y        , or0_out_Y          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__nand4bb",
        "module_hash": "c25ddeb6156bc47e57e3097c6640dc1a",
        "dataset_index": 12056
      },
      "decoder_3to8_58379113": {
        "rtl_code": "module decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output [7:0] Y\n);\n\nassign Y[0] = (~A) & (~B) & (~C);\nassign Y[1] = (~A) & (~B) & C;\nassign Y[2] = (~A) & B & (~C);\nassign Y[3] = (~A) & B & C;\nassign Y[4] = A & (~B) & (~C);\nassign Y[5] = A & (~B) & C;\nassign Y[6] = A & B & (~C);\nassign Y[7] = A & B & C;\n\nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "58379113445f224dcb626eea09bdb9f6",
        "dataset_index": 18795
      },
      "priority_encoder #_f706f808": {
        "rtl_code": "module priority_encoder #(\n  parameter n=4,\n  parameter m=2\n) (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\n\nreg [m-1:0] out_reg; // register to hold the output binary code\n\nalways @(*) begin\n  casez(in) // scan the input signals from highest to lowest priority\n    4'b1110: out_reg = 2'b00; // highest priority input signal is in[3]\n    4'b1101: out_reg = 2'b01; // highest priority input signal is in[2]\n    4'b1011: out_reg = 2'b10; // highest priority input signal is in[1]\n    4'b0111: out_reg = 2'b11; // highest priority input signal is in[0]\n    default: out_reg = 2'b00; // default output if no input signals are high\n  endcase\nend\n\nassign out = out_reg; // assign the output to the output register\n\nendmodule",
        "module_name": "priority_encoder #",
        "module_hash": "f706f808add10e374782edb71d4a5d72",
        "dataset_index": 14872
      },
      "pipeline_f3fbfabd": {
        "rtl_code": "\nmodule pipeline (\n  input clk,\n  input reset,\n  input [31:0] data1,\n  input [31:0] data2,\n  input [7:0] instruction,\n  input [2:0] stage,\n  input [3:0] rs1,\n  input [3:0] rs2,\n  input [3:0] rd,\n  output [31:0] regfile_0,\n  output [31:0] regfile_1,\n  output [31:0] regfile_2,\n  output [31:0] regfile_3,\n  output [31:0] regfile_4,\n  output [31:0] regfile_5,\n  output [31:0] regfile_6,\n  output [31:0] regfile_7,\n  output [31:0] regfile_8,\n  output [31:0] regfile_9,\n  output [31:0] regfile_10,\n  output [31:0] regfile_11,\n  output [31:0] regfile_12,\n  output [31:0] regfile_13,\n  output [31:0] regfile_14,\n  output [31:0] regfile_15\n);\n\nreg [31:0] pc;\nreg [31:0] instruction_reg;\nreg [31:0] alu_result;\nreg [31:0] data2_reg;\nreg [4:0] rs1_reg;\nreg [4:0] rs2_reg;\nreg [4:0] rd_reg;\nreg [1:0] stage_reg;\n\nassign regfile_0 = regfile[0];\nassign regfile_1 = regfile[1];\nassign regfile_2 = regfile[2];\nassign regfile_3 = regfile[3];\nassign regfile_4 = regfile[4];\nassign regfile_5 = regfile[5];\nassign regfile_6 = regfile[6];\nassign regfile_7 = regfile[7];\nassign regfile_8 = regfile[8];\nassign regfile_9 = regfile[9];\nassign regfile_10 = regfile[10];\nassign regfile_11 = regfile[11];\nassign regfile_12 = regfile[12];\nassign regfile_13 = regfile[13];\nassign regfile_14 = regfile[14];\nassign regfile_15 = regfile[15];\n\nreg [31:0] regfile [15:0];\n\nalways @(posedge clk) begin\n  if (reset) begin\n    pc <= 0;\n    instruction_reg <= 0;\n    alu_result <= 0;\n    data2_reg <= 0;\n    rs1_reg <= 0;\n    rs2_reg <= 0;\n    rd_reg <= 0;\n    stage_reg <= 0;\n  end else begin\n    case (stage_reg)\n      0: begin // Instruction Fetch\n        instruction_reg <= instruction;\n        pc <= pc + 1;\n        stage_reg <= 1;\n      end\n      1: begin // Instruction Decode and Execution\n        rs1_reg <= rs1;\n        rs2_reg <= rs2;\n        rd_reg <= rd;\n        data2_reg <= data2;\n        case (instruction_reg[7:0])\n          8'h00: alu_result <= data1 + data2_reg; // ADD\n          8'h01: alu_result <= data1 - data2_reg; // SUB\n          8'h02: alu_result <= data1 & data2_reg; // AND\n          8'h03: alu_result <= data1 | data2_reg; // OR\n          8'h04: alu_result <= data1 ^ data2_reg; // XOR\n          8'h05: alu_result <= ~data1; // NOT\n          8'h06: alu_result <= data1 << data2_reg; // SLL\n          8'h07: alu_result <= data1 >> data2_reg; // SRL\n          default: alu_result <= 0;\n        endcase\n        stage_reg <= 2;\n      end\n      2: begin // Write Back\n        regfile[rd_reg] <= alu_result;\n        stage_reg <= 0;\n      end\n      default: stage_reg <= 0;\n    endcase\n  end\nend\n\nendmodule",
        "module_name": "pipeline",
        "module_hash": "f3fbfabd2b993d9a7f6cca8feec303d4",
        "dataset_index": 9205
      },
      "register_adder_clock_gate_390ae2ee": {
        "rtl_code": "module register_adder_clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n\n  reg gated_clk;\n\n  always @(posedge CLK) begin\n    if (EN && !TE) begin\n      gated_clk <= 1'b1;\n    end else begin\n      gated_clk <= 1'b0;\n    end\n  end\n\n  assign ENCLK = gated_clk & CLK;\n\nendmodule",
        "module_name": "register_adder_clock_gate",
        "module_hash": "390ae2eef454713eddf212c0e9d99729",
        "dataset_index": 4064
      },
      "pipelined_multiplier_fd935880": {
        "rtl_code": "module pipelined_multiplier (\n    input [15:0] A,\n    input [15:0] B,\n    input clk,\n    output reg [31:0] P\n);\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [15:0] pp1_reg;\nreg [15:0] pp2_reg;\nreg [15:0] pp3_reg;\nreg [15:0] pp4_reg;\n\nalways @(posedge clk) begin\n    a_reg <= A;\n    b_reg <= B;\nend\n\n// Stage 1\nwire [15:0] pp1;\nassign pp1 = a_reg[0] ? b_reg : 0;\nalways @(posedge clk) begin\n    pp1_reg <= pp1;\nend\n\n// Stage 2\nwire [15:0] pp2;\nassign pp2 = a_reg[1] ? {b_reg[14:0], 1'b0} : 0;\nalways @(posedge clk) begin\n    pp2_reg <= pp2;\nend\n\n// Stage 3\nwire [15:0] pp3;\nassign pp3 = a_reg[2] ? {b_reg[13:0], 2'b00} : 0;\nalways @(posedge clk) begin\n    pp3_reg <= pp3;\nend\n\n// Stage 4\nwire [15:0] pp4;\nassign pp4 = a_reg[3] ? {b_reg[12:0], 3'b000} : 0;\nalways @(posedge clk) begin\n    pp4_reg <= pp4;\nend\n\nalways @(posedge clk) begin\n    P <= pp1_reg + pp2_reg + pp3_reg + pp4_reg;\nend\n\nendmodule",
        "module_name": "pipelined_multiplier",
        "module_hash": "fd935880654ae58d6050b9c5e95e2b34",
        "dataset_index": 11140
      },
      "counter_7c6ab013": {
        "rtl_code": "module counter\n(\n    input clk,\n    input rst,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or posedge rst)\n    begin\n        if (rst)\n            out <= 4'b0;\n        else if (out == 4'hF)\n            out <= 4'b0;\n        else\n            out <= out + 1;\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "7c6ab013cf2f4a246d2296f655ed239b",
        "dataset_index": 16157
      },
      "shipping__041a919a": {
        "rtl_code": "module shipping_module (A, B, C, D, E, F, G, H, I, J, K, L, M, N, valid);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M, N;\n    output valid;\n\n    wire [7:0] min_value = 8'd120;\n    wire [7:0] max_weight = 8'd60;\n    wire [7:0] max_volume = 8'd60;\n\n    wire [7:0]  total_value = \n        A * 8'd4\n      + B * 8'd8\n      + C * 8'd0\n      + D * 8'd20\n      + E * 8'd10\n      + F * 8'd12\n      + G * 8'd18\n      + H * 8'd14\n      + I * 8'd6\n      + J * 8'd15\n      + K * 8'd30\n      + L * 8'd8\n      + M * 8'd16\n      + N * 8'd18;\n\n    wire [7:0]  total_weight = \n        A * 8'd28\n      + B * 8'd8\n      + C * 8'd27\n      + D * 8'd18\n      + E * 8'd27\n      + F * 8'd28\n      + G * 8'd6\n      + H * 8'd1\n      + I * 8'd20\n      + J * 8'd0\n      + K * 8'd5\n      + L * 8'd13\n      + M * 8'd8\n      + N * 8'd14;\n\n    wire [7:0]  total_volume = \n        A * 8'd27\n      + B * 8'd27\n      + C * 8'd4\n      + D * 8'd4\n      + E * 8'd0\n      + F * 8'd24\n      + G * 8'd4\n      + H * 8'd20\n      + I * 8'd12\n      + J * 8'd15\n      + K * 8'd5\n      + L * 8'd2\n      + M * 8'd9\n      + N * 8'd28;\n\n    assign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume));\nendmodule",
        "module_name": "shipping_",
        "module_hash": "041a919a126864821f7e151067be9819",
        "dataset_index": 5247
      },
      "up_down_counter_55be4182": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input reset,\n    input control,\n    output reg [2:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 3'b0;\n        end else if (control) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "55be41824bc3b3f832787f8e7ee1175e",
        "dataset_index": 8236
      },
      "my_dff_c3cce94f": {
        "rtl_code": "module my_dff ( \n    input clk, \n    input d, \n    output reg q \n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n\nmodule shift_register_adder ( \n    input clk, \n    input [3:0] adder_input, \n    input d, \n    output reg [6:0] sum \n);\n\n    reg [3:0] shift_reg;\n    reg [4:0] shifted_input;\n    reg [4:0] adder_output;\n    wire q;\n\n    my_dff dff_inst (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    always @* begin\n        shifted_input = {shift_reg[2], shift_reg[1], shift_reg[0], 1'b0};\n        adder_output = adder_input + shifted_input;\n        shift_reg <= {shifted_input[3:1], d};\n    end\n\n    always @* begin\n        sum = {adder_output, shift_reg};\n    end\n\nendmodule",
        "module_name": "my_dff",
        "module_hash": "c3cce94f6baaba404f41a22a3243cc8d",
        "dataset_index": 2226
      },
      "bcd_converter_c611afff": {
        "rtl_code": "module bcd_converter (\n    input [3:0] data_in,\n    output reg [7:0] bcd_out\n);\n\nalways @(*) begin\n    case(data_in)\n        4'b0000: bcd_out = 8'b00000001;\n        4'b0001: bcd_out = 8'b00000010;\n        4'b0010: bcd_out = 8'b00000100;\n        4'b0011: bcd_out = 8'b00000110;\n        4'b0100: bcd_out = 8'b00001000;\n        4'b0101: bcd_out = 8'b00001001;\n        4'b0110: bcd_out = 8'b00001100;\n        4'b0111: bcd_out = 8'b00001110;\n        4'b1000: bcd_out = 8'b00010000;\n        4'b1001: bcd_out = 8'b00010001;\n        default: bcd_out = 8'b00000000;\n    endcase\nend\n\nendmodule",
        "module_name": "bcd_converter",
        "module_hash": "c611affff3895b5240e2d437eebfdc6e",
        "dataset_index": 1533
      },
      "pipelined_xor_gate_c2efb0f1": {
        "rtl_code": "module pipelined_xor_gate(input a, b, output out_assign, input clk);\n\n  reg a_reg, b_reg;\n  wire xor_out;\n  reg out_assign_reg;\n\n  assign xor_out = a_reg ^ b_reg;\n  assign out_assign = out_assign_reg;\n\n  always @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\n  end\n\n  always @(posedge clk) begin\n    out_assign_reg <= xor_out;\n  end\n\nendmodule\n\nmodule pipeline_stage_1(input a, b, output reg a_reg, output reg b_reg, input clk);\n\n  always @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\n  end\n\nendmodule\n\nmodule pipeline_stage_2(input xor_out, output reg out_assign_reg, input clk);\n\n  always @(posedge clk) begin\n    out_assign_reg <= xor_out;\n  end\n\nendmodule",
        "module_name": "pipelined_xor_gate",
        "module_hash": "c2efb0f1e4bb15267732147dba53ae70",
        "dataset_index": 3301
      },
      "AGC_3eb55fef": {
        "rtl_code": "module AGC (\n  input clk,\n  input in,\n  output out\n);\n\nparameter target_level = 100; // desired output signal level\nparameter step_size = 1; // amount to adjust gain on each clock cycle\n\nreg [7:0] gain = 128; // initial gain value\nreg [15:0] sum = 0; // sum of input signal over time\n\nalways @(posedge clk) begin\n  sum <= sum + in; // accumulate input signal over time\n  if (sum > target_level) begin\n    gain <= gain - step_size; // decrease gain\n  end else if (sum < target_level) begin\n    gain <= gain + step_size; // increase gain\n  end\n  sum <= 0; // reset sum for next cycle\nend\n\nassign out = in * gain; // compute output signal\n\nendmodule",
        "module_name": "AGC",
        "module_hash": "3eb55fefa6d52a7c3606cc6cc056cbe5",
        "dataset_index": 12319
      },
      "wifi_transceiver_1f99ac22": {
        "rtl_code": "\nmodule wifi_transceiver (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  output [99:0] rx_packet,\n  output [31:0] data_out,\n  output [99:0] tx_packet,\n  output tx_busy\n);\n\n  reg [31:0] data_buffer;\n  reg [99:0] tx_packet_reg;\n  reg tx_busy_reg;\n  reg [31:0] rx_data;\n  reg [31:0] rx_checksum;\n  reg [31:0] calculated_checksum;\n\n  assign tx_packet = tx_packet_reg;\n  assign tx_busy = tx_busy_reg;\n  assign data_out = rx_data;\n  assign rx_packet[99:96] = 4'hF;\n  assign rx_packet[95:64] = data_in ^ 32'hAAAAAAAA;\n  assign rx_packet[63:32] = ~data_in;\n  assign rx_packet[31:0] = data_in;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      data_buffer <= 32'h0;\n      tx_packet_reg <= 100'h0;\n      tx_busy_reg <= 1'b0;\n    end else begin\n      if (!tx_busy_reg) begin\n        data_buffer <= data_in;\n        tx_packet_reg[31:0] <= data_in;\n        tx_packet_reg[63:32] <= ~data_in;\n        tx_packet_reg[95:64] <= data_in ^ 32'hAAAAAAAA;\n        tx_packet_reg[99:96] <= 4'hF;\n        tx_busy_reg <= 1'b1;\n      end else begin\n        tx_busy_reg <= 1'b0;\n      end\n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      rx_data <= 32'h0;\n      rx_checksum <= 32'h0;\n    end else begin\n      rx_data <= rx_packet[31:0];\n      rx_checksum <= rx_packet[63:32];\n      calculated_checksum <= rx_data ^ rx_packet[95:64] ^ 32'hAAAAAAAA;\n    end\n  end\n\nendmodule",
        "module_name": "wifi_transceiver",
        "module_hash": "1f99ac22f2c962177dc0430304f672ca",
        "dataset_index": 17867
      },
      "ripple_carry_adder_239058ea": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C\n);\n\nreg carry_out;\nreg [3:0] carry_in; \n\nalways @* begin\n    {carry_out, S[0]} = A[0] + B[0];\n    {carry_in[1], S[1]} = A[1] + B[1] + carry_out;\n    {carry_in[2], S[2]} = A[2] + B[2] + carry_in[1];\n    {C, S[3]} = A[3] + B[3] + carry_in[2];\nend\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "239058ea7ebf39db0e2ded38a05f592e",
        "dataset_index": 12256
      },
      "booth_encoder_5_dbd09429": {
        "rtl_code": "module booth_encoder_5(\n  input [2:0] B_in,\n  output [2:0] A_out\n);\n\nassign A_out = (B_in[2] ^ B_in[1] ^ B_in[0]) ? 3'b001 : \n               (B_in[2] ^ B_in[0]) ? 3'b010 :\n               (B_in[2] ^ B_in[1]) ? 3'b011 :\n               (B_in[1] ^ B_in[0]) ? 3'b100 :\n               (B_in[2]) ? 3'b101 :\n               (B_in[1]) ? 3'b110 :\n               (B_in[0]) ? 3'b111 :\n               3'b000;\n\nendmodule",
        "module_name": "booth_encoder_5",
        "module_hash": "dbd0942912595b5d3100f865b22a8977",
        "dataset_index": 919
      },
      "top__22395dff": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    output reg [127:0] final_output\n);\n\n    reg d;\n    wire [127:0] jc_output;\n    wire [15:0] jc_input;\n    wire [127:0] dff_output;\n    \n    DFF_module dff_inst (\n        .clk(clk),\n        .d(d),\n        .q(dff_output)\n    );\n    \n    chatgpt_generate_JC_counter jc_inst (\n        .clk(clk),\n        .rst_n(reset),\n        .Q(jc_output)\n    );\n    \n    assign jc_input[0] = dff_output;\n    assign jc_input[1] = jc_output[0];\n    assign jc_input[2] = jc_output[1];\n    assign jc_input[3] = jc_output[2];\n    assign jc_input[4] = jc_output[3];\n    assign jc_input[5] = jc_output[4];\n    assign jc_input[6] = jc_output[5];\n    assign jc_input[7] = jc_output[6];\n    assign jc_input[8] = jc_output[7];\n    assign jc_input[9] = jc_output[8];\n    assign jc_input[10] = jc_output[9];\n    assign jc_input[11] = jc_output[10];\n    assign jc_input[12] = jc_output[11];\n    assign jc_input[13] = jc_output[12];\n    assign jc_input[14] = jc_output[13];\n    assign jc_input[15] = jc_output[14];\n    \n    always @* begin\n        final_output = {dff_output, jc_output} << 112;\n    end\n\nendmodule\n\nmodule DFF_module (\n    input clk,\n    input d,\n    output reg [127:0] q\n);\n    \n    always @(posedge clk) begin\n        q <= {127{d}};\n    end\n    \nendmodule\n\nmodule chatgpt_generate_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [127:0]    Q\n);\n  \n  reg [15:0] jc_reg;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      jc_reg <= 16'h0001;\n    end else begin\n      jc_reg <= {jc_reg[14:0], ~(jc_reg[14] ^ jc_reg[15])};\n    end\n  end\n  \n  always @*\n    Q = jc_reg;\n  \nendmodule",
        "module_name": "top_",
        "module_hash": "22395dff70b207f7491078ecc8f8037c",
        "dataset_index": 2923
      },
      "soft_clock_9e7704a4": {
        "rtl_code": "\n\nmodule soft_clock\n#(parameter\n\tC_SIPIF_DWIDTH = 32\n)\n(\n\tinput                                   Bus2IP_Reset     ,\n\tinput                                   Bus2IP_Clk       ,\n\tinput                                   Bus2IP_WrCE      ,\n\tinput      [0:C_SIPIF_DWIDTH-1]         Bus2IP_Data      ,\n\tinput      [0:(C_SIPIF_DWIDTH/8)-1]     Bus2IP_BE        ,\n\t\n\toutput                                  Clk2IP_Clk       ,\n\t\n\toutput                                  Clk2Bus_WrAck    ,\n\toutput                                  Clk2Bus_Error    ,\n\toutput                                  Clk2Bus_ToutSup  \n\t\n);\n\n\tlocalparam [0:3] CLOCK_ENABLE  = 4'b1010;\n\tlocalparam [0:3] CLOCK_DISABLE = 4'b0101;\n\n\t\n\twire isc_enable_match  = (Bus2IP_Data[C_SIPIF_DWIDTH-4:C_SIPIF_DWIDTH-1] == CLOCK_ENABLE);\n\twire isc_disable_match = (Bus2IP_Data[C_SIPIF_DWIDTH-4:C_SIPIF_DWIDTH-1] == CLOCK_DISABLE);\n\twire isc_match    = isc_enable_match | isc_disable_match;\n\twire isc_mismatch = ~(isc_enable_match | isc_disable_match);\n\twire isc_be_match = (Bus2IP_BE[(C_SIPIF_DWIDTH/8)-1:(C_SIPIF_DWIDTH/8)-1] == 1'b1);\n\n\t\n\treg isr_ce;\n\talways @(posedge Bus2IP_Clk or posedge Bus2IP_Reset) begin\n\t\tif (Bus2IP_Reset) begin \n\t\t\tisr_ce <= 1'b1;\n\t\tend else begin \n\t\t\tif (Bus2IP_WrCE && isc_be_match) begin\n\t\t\t\tisr_ce <= \n\t\t\t\t\tisc_enable_match?  1'b1: \n\t\t\t\t\tisc_disable_match? 1'b0: isr_ce;\n\t\t\tend\n\t\tend\n\tend\n\t\n\treg isr_error;\n\talways @(posedge Bus2IP_Clk or posedge Bus2IP_Reset) begin\n\t\tif (Bus2IP_Reset) begin \n\t\t\tisr_error <= 1'b0;\n\t\tend else begin \n\t\t\tif (Bus2IP_WrCE) begin\n\t\t\t\tisr_error <= isc_mismatch? 1'b1: 1'b0;\n\t\t\tend\n\t\tend\n\tend\n\t\n\t\n\tassign Clk2IP_Clk = Bus2IP_Clk & isr_ce;\n\t\n\t\n\tassign Clk2Bus_WrAck   = isc_match & Bus2IP_WrCE & isc_be_match;\n\tassign Clk2Bus_Error   = isc_mismatch & Bus2IP_WrCE & isc_be_match;\n\tassign Clk2Bus_ToutSup = Bus2IP_Reset;\n\t\nendmodule\n",
        "module_name": "soft_clock",
        "module_hash": "9e7704a42dad53d4edb20dcfcbab76da",
        "dataset_index": 24689
      },
      "parity_checker_fa519987": {
        "rtl_code": "module parity_checker (\n  input [3:0] data,\n  output reg parity\n);\n\n  always @* begin\n    parity = ^data; // XOR all bits in data\n  end\n\nendmodule",
        "module_name": "parity_checker",
        "module_hash": "fa519987f2e4180deef9d17a93cd68cf",
        "dataset_index": 9391
      },
      "manchester_encoder_de1eb977": {
        "rtl_code": "module manchester_encoder (\n  input clk,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter freq = 100; // clock frequency in MHz\nparameter data_rate = 10; // data rate in Mbps\n\n// implementation of Manchester encoder\nreg [n-1:0] prev_in;\nalways @(posedge clk) begin\n  prev_in <= in;\nend\n\nassign out = (prev_in ^ in) ? {1'b1, 1'b0} : {1'b0, 1'b1};\n\nendmodule\n\nmodule manchester_decoder (\n  input clk,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter freq = 100; // clock frequency in MHz\nparameter data_rate = 10; // data rate in Mbps\n\n// implementation of Manchester decoder\nreg [n-1:0] prev_in;\nalways @(posedge clk) begin\n  prev_in <= in;\nend\n\nassign out = (prev_in ^ in) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "manchester_encoder",
        "module_hash": "de1eb9772c5a783c9ef3eac12e4841cc",
        "dataset_index": 12877
      },
      "ui_cmd #_bc3c38fe": {
        "rtl_code": "\n\nmodule ui_cmd #\n  (\n   parameter TCQ = 100,\n   parameter ADDR_WIDTH         = 33,\n   parameter BANK_WIDTH         = 3,\n   parameter COL_WIDTH          = 12,\n   parameter RANK_WIDTH         = 2,\n   parameter ROW_WIDTH          = 16,\n   parameter RANKS              = 4\n  )\n  (\n  app_rdy, use_addr, rank, bank, row, col, size, cmd, hi_priority,\n  rd_accepted, wr_accepted, data_buf_addr,\n  rst, clk, accept_ns, rd_buf_full, wr_req_16, app_addr, app_cmd,\n  app_sz, app_hi_pri, app_en, wr_data_buf_addr, rd_data_buf_addr_r\n  );\n\n  input rst;\n  input clk;\n\n  input accept_ns;\n  input rd_buf_full;\n  input wr_req_16;\n  wire app_rdy_ns = accept_ns && ~rd_buf_full && ~wr_req_16;\n  reg app_rdy_r;\n  always @(posedge clk) app_rdy_r <= #TCQ app_rdy_ns;\n  output wire app_rdy;\n  assign app_rdy = app_rdy_r;\n\n  input [ADDR_WIDTH-1:0] app_addr;\n  input [2:0] app_cmd;\n  input app_sz;\n  input app_hi_pri;\n  input app_en;\n\n  reg [ADDR_WIDTH-1:0] app_addr_r1;\n  reg [ADDR_WIDTH-1:0] app_addr_r2;\n  reg [2:0] app_cmd_r1;\n  reg [2:0] app_cmd_r2;\n  reg app_sz_r1;\n  reg app_sz_r2;\n  reg app_hi_pri_r1;\n  reg app_hi_pri_r2;\n  reg app_en_r1;\n  reg app_en_r2;\n\n  wire [ADDR_WIDTH-1:0] app_addr_ns1 = app_rdy_r ? app_addr : app_addr_r1;\n  wire [ADDR_WIDTH-1:0] app_addr_ns2 = app_rdy_r ? app_addr_r1 : app_addr_r2;\n  wire [2:0] app_cmd_ns1 = app_rdy_r ? app_cmd : app_cmd_r1;\n  wire [2:0] app_cmd_ns2 = app_rdy_r ? app_cmd_r1 : app_cmd_r2;\n  wire app_sz_ns1 = app_rdy_r ? app_sz : app_sz_r1;\n  wire app_sz_ns2 = app_rdy_r ? app_sz_r1 : app_sz_r2;\n  wire app_hi_pri_ns1 = app_rdy_r ? app_hi_pri : app_hi_pri_r1;\n  wire app_hi_pri_ns2 = app_rdy_r ? app_hi_pri_r1 : app_hi_pri_r2;\n  wire app_en_ns1 = ~rst && (app_rdy_r ? app_en : app_en_r1);\n  wire app_en_ns2 = ~rst && (app_rdy_r ? app_en_r1 : app_en_r2);\n\n  always @(posedge clk) begin\n    app_addr_r1 <= #TCQ app_addr_ns1;\n    app_addr_r2 <= #TCQ app_addr_ns2;\n    app_cmd_r1 <= #TCQ app_cmd_ns1;\n    app_cmd_r2 <= #TCQ app_cmd_ns2;\n    app_sz_r1 <= #TCQ app_sz_ns1;\n    app_sz_r2 <= #TCQ app_sz_ns2;\n    app_hi_pri_r1 <= #TCQ app_hi_pri_ns1;\n    app_hi_pri_r2 <= #TCQ app_hi_pri_ns2;\n    app_en_r1 <= #TCQ app_en_ns1;\n    app_en_r2 <= #TCQ app_en_ns2;\n  end wire use_addr_lcl = app_en_r2 && app_rdy_r;\n  output wire use_addr;\n  assign use_addr = use_addr_lcl;\n\n  output wire [RANK_WIDTH-1:0] rank;\n  output wire [BANK_WIDTH-1:0] bank;\n  output wire [ROW_WIDTH-1:0] row;\n  output wire [COL_WIDTH-1:0] col;\n  output wire size;\n  output wire [2:0] cmd;\n  output wire hi_priority;\n\n  assign col = app_rdy_r\n                 ? app_addr_r1[0+:COL_WIDTH]\n                 : app_addr_r2[0+:COL_WIDTH];\n  assign row = app_rdy_r\n                 ? app_addr_r1[COL_WIDTH+:ROW_WIDTH]\n                 : app_addr_r2[COL_WIDTH+:ROW_WIDTH];\n  assign bank = app_rdy_r\n                  ? app_addr_r1[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH]\n                  : app_addr_r2[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH];\n  assign rank = (RANKS == 1)\n                  ? 1'b0\n                  : app_rdy_r\n                    ? app_addr_r1[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH]\n                    : app_addr_r2[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH];\n  assign size = app_rdy_r\n                  ? app_sz_r1\n                  : app_sz_r2;\n  assign cmd = app_rdy_r\n                 ? app_cmd_r1\n                 : app_cmd_r2;\n  assign hi_priority = app_rdy_r\n                         ? app_hi_pri_r1\n                         : app_hi_pri_r2;\n\n  wire request_accepted = use_addr_lcl && app_rdy_r;\n  wire rd = app_cmd_r2[1:0] == 2'b01;\n  wire wr = app_cmd_r2[1:0] == 2'b00;\n  wire wr_bytes = app_cmd_r2[1:0] == 2'b11;\n  wire write = wr || wr_bytes;\n  output wire rd_accepted;\n  assign rd_accepted = request_accepted && rd;\n  output wire wr_accepted;\n  assign wr_accepted = request_accepted && write;\n\n  input [3:0] wr_data_buf_addr;\n  input [3:0] rd_data_buf_addr_r;\n  output wire [3:0] data_buf_addr;\n\n  assign data_buf_addr = ~write ? rd_data_buf_addr_r : wr_data_buf_addr;\n\nendmodule ",
        "module_name": "ui_cmd #",
        "module_hash": "bc3c38fe0e9b20e030f7beceba398b32",
        "dataset_index": 24073
      },
      "pcie_7x_v1_11_0_axi_basic_tx_pipeline #_c0c4a60e": {
        "rtl_code": "\n\nmodule pcie_7x_v1_11_0_axi_basic_tx_pipeline #(\n  parameter C_DATA_WIDTH = 128,           parameter C_PM_PRIORITY = \"FALSE\",      parameter TCQ = 1,                      parameter REM_WIDTH  = (C_DATA_WIDTH == 128) ? 2 : 1, parameter KEEP_WIDTH = C_DATA_WIDTH / 8               ) (\n  input      [C_DATA_WIDTH-1:0] s_axis_tx_tdata,     input                         s_axis_tx_tvalid,    output                        s_axis_tx_tready,    input        [KEEP_WIDTH-1:0] s_axis_tx_tkeep,     input                         s_axis_tx_tlast,     input                   [3:0] s_axis_tx_tuser,     output     [C_DATA_WIDTH-1:0] trn_td,              output                        trn_tsof,            output                        trn_teof,            output                        trn_tsrc_rdy,        input                         trn_tdst_rdy,        output                        trn_tsrc_dsc,        output        [REM_WIDTH-1:0] trn_trem,            output                        trn_terrfwd,         output                        trn_tstr,            output                        trn_tecrc_gen,       input                         trn_lnk_up,          input                         tready_thrtl,        input                         user_clk,            input                         user_rst             );\n\n\nreg  [C_DATA_WIDTH-1:0] reg_tdata;\nreg                     reg_tvalid;\nreg    [KEEP_WIDTH-1:0] reg_tkeep;\nreg               [3:0] reg_tuser;\nreg                     reg_tlast;\nreg                     reg_tready;\n\nreg                     trn_in_packet;\nreg                     axi_in_packet;\nreg                     flush_axi;\nwire                    disable_trn;\nreg                     reg_disable_trn;\n\nwire                    axi_beat_live  = s_axis_tx_tvalid && s_axis_tx_tready;\nwire                    axi_end_packet = axi_beat_live && s_axis_tx_tlast;\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : td_DW_swap_128\n    assign trn_td = {reg_tdata[31:0],\n                     reg_tdata[63:32],\n                     reg_tdata[95:64],\n                     reg_tdata[127:96]};\n  end\n  else if(C_DATA_WIDTH == 64) begin : td_DW_swap_64\n    assign trn_td = {reg_tdata[31:0], reg_tdata[63:32]};\n  end\n  else begin : td_DW_swap_32\n    assign trn_td = reg_tdata;\n  end\nendgenerate\n\n\nassign trn_tsof = reg_tvalid && !trn_in_packet;\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    trn_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(trn_tsof && trn_tsrc_rdy && trn_tdst_rdy && !trn_teof) begin\n      trn_in_packet <= #TCQ 1'b1;\n    end\n    else if((trn_in_packet && trn_teof && trn_tsrc_rdy) || !trn_lnk_up) begin\n      trn_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    axi_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(axi_beat_live && !s_axis_tx_tlast) begin\n      axi_in_packet <= #TCQ 1'b1;\n    end\n    else if(axi_beat_live) begin\n      axi_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\ngenerate\n  if(C_PM_PRIORITY == \"TRUE\") begin : pm_priority_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b1;\n      end\n      else begin\n        if(!trn_lnk_up)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(!flush_axi && s_axis_tx_tready) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn;\n  end\n\n  else begin : thrtl_ctl_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b0;\n      end\n      else begin\n        if(axi_in_packet && !trn_lnk_up && !axi_end_packet)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(axi_end_packet) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn || !trn_lnk_up;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : tkeep_to_trem_128\n    wire   axi_DW_1    = reg_tkeep[7];\n    wire   axi_DW_2    = reg_tkeep[11];\n    wire   axi_DW_3    = reg_tkeep[15];\n    assign trn_trem[1] = axi_DW_2;\n    assign trn_trem[0] = axi_DW_3 || (axi_DW_1 && !axi_DW_2);\n  end\n  else if(C_DATA_WIDTH == 64) begin : tkeep_to_trem_64\n    assign trn_trem    = reg_tkeep[7];\n  end\n  else begin : tkeep_to_trem_32\n    assign trn_trem    = 1'b0;\n  end\nendgenerate\n\n\nassign trn_teof      = reg_tlast;\nassign trn_tecrc_gen = reg_tuser[0];\nassign trn_terrfwd   = reg_tuser[1];\nassign trn_tstr      = reg_tuser[2];\nassign trn_tsrc_dsc  = reg_tuser[3];\n\n\ngenerate\n  reg reg_tsrc_rdy;\n\n  if(C_PM_PRIORITY == \"FALSE\") begin : throttle_ctl_pipeline\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata        <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid       <= #TCQ 1'b0;\n        reg_tkeep        <= #TCQ {KEEP_WIDTH{1'b0}};\n        reg_tlast        <= #TCQ 1'b0;\n        reg_tuser        <= #TCQ 4'h0;\n        reg_tsrc_rdy     <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdata        <= #TCQ s_axis_tx_tdata;\n        reg_tvalid       <= #TCQ s_axis_tx_tvalid;\n        reg_tkeep        <= #TCQ s_axis_tx_tkeep;\n        reg_tlast        <= #TCQ s_axis_tx_tlast;\n        reg_tuser        <= #TCQ s_axis_tx_tuser;\n\n        reg_tsrc_rdy     <= #TCQ axi_beat_live && !disable_trn;\n      end\n    end\n\n    assign trn_tsrc_rdy = reg_tsrc_rdy;\n\n    assign s_axis_tx_tready = tready_thrtl;\n  end\n\n  else begin : pm_prioity_pipeline\n    reg  [C_DATA_WIDTH-1:0] tdata_prev;\n    reg                     tvalid_prev;\n    reg    [KEEP_WIDTH-1:0] tkeep_prev;\n    reg                     tlast_prev;\n    reg               [3:0] tuser_prev;\n    reg                     reg_tdst_rdy;\n\n    wire                    data_hold;\n    reg                     data_prev;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        tdata_prev   <= #TCQ {C_DATA_WIDTH{1'b0}};\n        tvalid_prev  <= #TCQ 1'b0;\n        tkeep_prev   <= #TCQ {KEEP_WIDTH{1'b0}};\n        tlast_prev   <= #TCQ 1'b0;\n        tuser_prev   <= #TCQ 4'h 0;\n      end\n      else begin\n        if(!s_axis_tx_tready) begin\n          tdata_prev   <= #TCQ tdata_prev;\n          tvalid_prev  <= #TCQ tvalid_prev;\n          tkeep_prev   <= #TCQ tkeep_prev;\n          tlast_prev   <= #TCQ tlast_prev;\n          tuser_prev   <= #TCQ tuser_prev;\n        end\n        else begin\n          tdata_prev   <= #TCQ s_axis_tx_tdata;\n          tvalid_prev  <= #TCQ s_axis_tx_tvalid;\n          tkeep_prev   <= #TCQ s_axis_tx_tkeep;\n          tlast_prev   <= #TCQ s_axis_tx_tlast;\n          tuser_prev   <= #TCQ s_axis_tx_tuser;\n        end\n      end\n    end\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata  <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid <= #TCQ 1'b0;\n        reg_tkeep  <= #TCQ {KEEP_WIDTH{1'b0}};\n        reg_tlast  <= #TCQ 1'b0;\n        reg_tuser  <= #TCQ 4'h0;\n\n        reg_tdst_rdy <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdst_rdy <= #TCQ trn_tdst_rdy;\n\n        if(!data_hold) begin\n          if(data_prev) begin\n            reg_tdata  <= #TCQ tdata_prev;\n            reg_tvalid <= #TCQ tvalid_prev;\n            reg_tkeep  <= #TCQ tkeep_prev;\n            reg_tlast  <= #TCQ tlast_prev;\n            reg_tuser  <= #TCQ tuser_prev;\n          end\n\n          else begin\n            reg_tdata  <= #TCQ s_axis_tx_tdata;\n            reg_tvalid <= #TCQ s_axis_tx_tvalid;\n            reg_tkeep  <= #TCQ s_axis_tx_tkeep;\n            reg_tlast  <= #TCQ s_axis_tx_tlast;\n            reg_tuser  <= #TCQ s_axis_tx_tuser;\n          end\n        end\n        end\n    end\n\n\n    assign data_hold = trn_tsrc_rdy && !trn_tdst_rdy;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        data_prev <= #TCQ 1'b0;\n      end\n      else begin\n        data_prev <= #TCQ data_hold;\n      end\n    end\n\n\n    assign trn_tsrc_rdy = reg_tvalid && !disable_trn;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tready <= #TCQ 1'b0;\n      end\n      else begin\n        if(flush_axi && !axi_end_packet) begin\n          reg_tready <= #TCQ 1'b1;\n        end\n\n        else if(trn_lnk_up) begin\n          reg_tready <= #TCQ trn_tdst_rdy || !trn_tsrc_rdy;\n        end\n\n        else begin\n          reg_tready <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign s_axis_tx_tready = reg_tready;\n  end\n\n\n  always @(posedge user_clk) begin\n    if(user_rst) begin\n      flush_axi    <= #TCQ 1'b0;\n    end\n    else begin\n      if(axi_in_packet && !trn_lnk_up && !axi_end_packet) begin\n        flush_axi <= #TCQ 1'b1;\n      end\n\n      else if(axi_end_packet) begin\n        flush_axi <= #TCQ 1'b0;\n      end\n    end\n  end\nendgenerate\n\nendmodule\n",
        "module_name": "pcie_7x_v1_11_0_axi_basic_tx_pipeline #",
        "module_hash": "c0c4a60ee0b9a3e3e822bf0ace73f0cc",
        "dataset_index": 17294
      },
      "SpecialAdd_6a84f187": {
        "rtl_code": "\nmodule SpecialAdd(\n\tinput [31:0] cin_Special,\n\tinput [31:0] zin_Special,\n\tinput reset,\n\tinput clock,\n\toutput reg idle_Special = 1'b0,\n\toutput reg [7:0] difference_Special,\n\toutput reg [35:0] cout_Special,\n\toutput reg [35:0] zout_Special,\n\toutput reg [31:0] sout_Special\n   );\n\t\nwire z_sign;\nwire [7:0] z_exponent;\nwire [26:0] z_mantissa;\n\nwire c_sign;\nwire [7:0] c_exponent;\nwire [26:0] c_mantissa;\n\nassign c_sign = cin_Special[31];\nassign c_exponent = {cin_Special[30:23] - 127};\nassign c_mantissa = {cin_Special[22:0],3'd0};\n\nassign z_sign = {zin_Special[31]};\nassign z_exponent = {zin_Special[30:23] - 127};\nassign z_mantissa = {zin_Special[22:0],3'd0};\n\nparameter no_idle = 1'b0,\n\t\t\t put_idle = 1'b1;\n\nalways @ (posedge clock)\nbegin\n\n\tif (reset == 1'b1) begin\n\t\tidle_Special <= 1'b0;\n\tend\n\t\n\telse begin\n\tif ($signed(z_exponent) > $signed(c_exponent)) begin\n\t\tdifference_Special <= z_exponent - c_exponent;\n\tend\n\telse if ($signed(z_exponent) <= $signed(c_exponent)) begin\n\t\tdifference_Special <= c_exponent - z_exponent;\n\tend\t\n\t\n\tif ((c_exponent == 128 && c_mantissa != 0) || (z_exponent == 128 && z_mantissa != 0)) begin\n      sout_Special[31] <= 1;\n      sout_Special[30:23] <= 255;\n      sout_Special[22] <= 1;\n      sout_Special[21:0] <= 0;\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n\t\tidle_Special <= put_idle;\n    end else if (c_exponent == 128) begin\n      sout_Special[31] <= c_sign;\n      sout_Special[30:23] <= 255;\n      sout_Special[22:0] <= 0;\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n\t\tidle_Special <= put_idle;\t\t\n    end else if (z_exponent == 128) begin\n      sout_Special[31] <= z_sign;\n      sout_Special[30:23] <= 255;\n      sout_Special[22:0] <= 0;\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n\t\tidle_Special <= put_idle;\t\t\n    end else if ((($signed(c_exponent) == -127) && (c_mantissa == 0)) && (($signed(z_exponent) == -127) && (z_mantissa == 0))) begin\n      sout_Special[31] <= c_sign & z_sign;\n      sout_Special[30:23] <= z_exponent[7:0] + 127;\n      sout_Special[22:0] <= z_mantissa[26:3];\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n      idle_Special <= put_idle;\t\t\t\t\t\t\t\n    end else if (($signed(c_exponent) == -127) && (c_mantissa == 0)) begin\n      sout_Special[31] <= z_sign;\n      sout_Special[30:23] <= z_exponent[7:0] + 127;\n      sout_Special[22:0] <= z_mantissa[26:3];\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n      idle_Special <= put_idle;\t\t\t\t\t\t\t\t\n    end else if (($signed(z_exponent) == -127) && (z_mantissa == 0)) begin\n      sout_Special[31] <= c_sign;\n      sout_Special[30:23] <= c_exponent[7:0] + 127;\n      sout_Special[22:0] <= c_mantissa[26:3];\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n      idle_Special <= put_idle;\t\t\t\t\t\t\t\n    end else begin\n\t\tsout_Special <= 0;\n      if ($signed(c_exponent) == -127) begin\n         cout_Special[34:27] <= -126;\n\t\t\tcout_Special[35] <= c_sign;\n\t\t\tcout_Special[26:0] <= c_mantissa;\n      end else begin\n\t\t\tcout_Special[34:27] <= c_exponent + 127;\n\t\t\tcout_Special[35] <= c_sign;\n         cout_Special[26] <= 1;\n\t\t\tcout_Special[25:0] <= c_mantissa[25:0];\n\t\t\tidle_Special <= no_idle;\n      end\n      if ($signed(z_exponent) == -127) begin\n\t\t\tzout_Special[35] <= z_sign;\n         zout_Special[34:27] <= -126;\n\t\t\tzout_Special[26:0] <= z_mantissa;\n      end else begin\n\t\t\tzout_Special[35] <= z_sign;\n         zout_Special[34:27] <= z_exponent + 127;\n\t\t\tzout_Special[25:0] <= z_mantissa[25:0];\n         zout_Special[26] <= 1;\n\t\t\tidle_Special <= no_idle;\n      end\n\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "SpecialAdd",
        "module_hash": "6a84f187f73951319c56fd7620df4d39",
        "dataset_index": 17433
      },
      "fsm_4state_sequence_detection_2b3802f0": {
        "rtl_code": "\nmodule fsm_4state_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  input enable,\n  output match\n);\n\n// Define the four states using one-hot encoding\nparameter A = 4'b0001;\nparameter B = 4'b0010;\nparameter C = 4'b0100;\nparameter D = 4'b1000;\n\n// Define the state register and initialize it to state A\nreg [3:0] state_reg = A;\n\n// Define the output register and initialize it to 0\nreg output_reg = 1'b0;\n\n// State transition and output logic equations\nalways @ (posedge clk) begin\n  if (reset) begin\n    state_reg <= A;\n    output_reg <= 1'b0;\n  end\n  else if (enable) begin\n    case (state_reg)\n      A: begin\n        if (data) state_reg <= B;\n        else state_reg <= A;\n      end\n      B: begin\n        if (!data) state_reg <= C;\n        else state_reg <= B;\n      end\n      C: begin\n        if (data) state_reg <= D;\n        else state_reg <= A;\n      end\n      D: begin\n        if (!data) begin\n          state_reg <= A;\n          output_reg <= 1'b1;\n        end\n        else state_reg <= B;\n      end\n    endcase\n  end\nend\n\n// Assign the output to the output wire\nassign match = output_reg;\n\nendmodule",
        "module_name": "fsm_4state_sequence_detection",
        "module_hash": "2b3802f07db097b06eeeb758cc07d8de",
        "dataset_index": 12245
      },
      "crc_16_940207c2": {
        "rtl_code": "\nmodule crc_16(start, clk, rst, data_in, data_out, done);\n\n\t//inputs y outputs\n\n\tinput start;\n\tinput clk;\n\tinput rst;\n\tinput [31:0] data_in;\n\toutput [15:0] data_out;\n\toutput done;\n\n\t//parametros \n\n\tlocalparam datawidth = 32, crcorder = 16;//tama\u00f1o del dato a operar, orden del polinomio crc\n\n\tlocalparam polinomio = 17'b10001000000100001 ; //polinomio para crc\n\t\n\treg rdone; \t\t\t\t//registro done\n\treg [31:0] r_data;\t\t//registro data\n\treg [16:0] proceso;\t\t//proceso o resultado temporal de xor\n\tinitial begin\n\t\trdone = 1'b0;\t\t\t//inicializa done en 0\n\tend\n\n\t//estados\n\t\n\tlocalparam INIT = 3'd0, GET = 3'd1, COMP = 3'd2, XOR = 3'd3, CORRER = 3'd4, SEND = 3'd5; \n\treg[2:0] state;\n\tinitial state = INIT; // se inicializa en el estado init\n\t\n\treg[6:0] cont; // contador de corrimientos\n\t\n\tassign data_out = proceso; //se asigna la salida de crc\n\tassign done = rdone; // se asigna done a la salida\n\t\n\n\t\n\talways @(posedge clk) begin\n\t\t\t\n\t\t//reset\t\t\n\t\n\t\tif(rst)begin\n\t\t\trdone <= 0;\n\t\t\tcont <= 0;\n\t\t\tproceso <= 0;\n\t\t\tstate <= INIT;\n\t\tend\n\n\t\telse begin \n\n\t\t//Maquina de Estados\n\n\t\t\tcase(state)\n\t\t\n\t\t\t\tINIT : begin   \t\t\t\t//estado init\n\t\t\t\t\tcont <= 6'd0;\t\t\t//contador en 0\n\t\t\t\t\trdone <= 1'b0; \t\t\t//done en 0\n\t\t\t\t\tif (start) begin\n\t\t\t\t\t\tr_data <= data_in;\t//se coloca en rdata el dato a operar\n\t\t\t\t\t\tstate <= GET;\t\t//cambio de estado\n\t\t\t\t\tend\t\n\t\t\t\tend\n\t\t\t\n\t\t\t\tGET : begin\t\t\t\t\t\t\t\t//estado get\n\t\t\t\t\tproceso <= r_data[(31):(31)-(crcorder)];\t//a proceso entran los \n\t\t\t\t\t\t\t\t\t\t\t\t\t//primeros crcorder bits \n\t\t\t\t\tstate <= COMP;\t\t\t\t\t\t\t//cambio de estado\n\t\t\t\tend\n\t\t\t\n\t\t\t\tCOMP : begin\t\t\t\t//estado comp \n\t\t\t\t\n\t\t\t\t\tcont <= cont + 1'b1;\t\t//aumenta el contador \n\t\t\t\t\tif(proceso[crcorder])\t\t//verifia si el primer bit de proceso es 1\n\t\t\t\t\t\tstate <= XOR;\t\t//si es 1 cambia a estado XOR\n\t\t\t\t\telse\n\t\t\t\t\t\tstate <= CORRER;\t\t//si es 0 cambia a estado correr\n\t\t\t\tend\n\t\t\t\n\t\t\t\tXOR : begin\t\t\t\t\t//estado xor\n\t\t\t\t\tproceso <= proceso ^ polinomio;\t//xor entre proceso y polinomio de crc\n\t\t\t\t\tstate <= CORRER;\t\t\t\t//cambio de estado \t\n\t\t\t\tend\n\t\t\t\n\t\t\t\tCORRER : begin\t\t\t\t//estado correr\n\t\t\t\t\tr_data <= {proceso[crcorder:0], r_data[(31)-crcorder-1:0], 1'b0}; \n\t\t\t\t\t\t\t\t\t//se coloca proceso concatenado con el resto de rdata \"anterior\"\n\t\t\t\t\tif (cont == datawidth)\n\t\t\t\t\t\tstate <= SEND;\t\t//si ya se hicieron datawidh corrimientos cambia a send\n\t\t\t\t\telse\n\t\t\t\t\t\tstate <= GET;\t\t//si no, vuelve a get \n\t\t\t\tend\n\t\t\t\n\t\t\t\tSEND : begin\t\t\t\t//estado send\n\t\t\t\t\trdone <= 1'b1;\t\t\t//done activo\n\t\t\t\t\tstate <= INIT;\t\t\t//vuelve a estado inicial\n\t\t\t\tend\n\t\t\t\n\t\t\tendcase\n\t\tend\n\n\tend\n\t\nendmodule",
        "module_name": "crc_16",
        "module_hash": "940207c27a4efda500cb35ac5b336352",
        "dataset_index": 7124
      },
      "VGA_DRIVER_5087c117": {
        "rtl_code": "`define TOTAL_SCREEN_WIDTH 795\n`define TOTAL_SCREEN_HEIGHT 525\n`define VISIBLE_SCREEN_WIDTH 640\n`define VISIBLE_SCREEN_HEIGHT 480\n\nmodule VGA_DRIVER (\n\tRESET,\n\tCLOCK,\n\tPIXEL_COLOR_IN,\n\tPIXEL_X,\n\tPIXEL_Y,\n\tPIXEL_COLOR_OUT,\n\tH_SYNC_NEG,\n\tV_SYNC_NEG\n);\n\n\n\ninput CLOCK; input RESET;\ninput  [7:0] PIXEL_COLOR_IN; output [9:0] PIXEL_X; output [9:0] PIXEL_Y; output [7:0] PIXEL_COLOR_OUT; output       H_SYNC_NEG; output       V_SYNC_NEG; \n\nreg  [9:0] pixel_count;\nreg  [9:0] line_count;\n\n\nassign PIXEL_X    = pixel_count;\nassign PIXEL_Y    = line_count;\n\nassign PIXEL_COLOR_OUT = (pixel_count<(`VISIBLE_SCREEN_WIDTH) )\n\t\t\t\t\t\t\t\t\t? (PIXEL_COLOR_IN) : (8'b00000000) ; assign H_SYNC_NEG = (pixel_count>=656 && pixel_count<752) ? (1'b0) : (1'b1); assign V_SYNC_NEG = (line_count>=490 && line_count<492) ? (1'b0) : (1'b1); always @(posedge CLOCK) begin\n\tif (RESET) begin\n\t\tpixel_count <= 10'b0;\n\t\tline_count <= 10'b0;\n\tend\n\telse if (pixel_count == (`TOTAL_SCREEN_WIDTH-1)) begin\n\t\tpixel_count <= 0;\n\t\tif (line_count == (`TOTAL_SCREEN_HEIGHT-1)) begin\n\t\tline_count <= 0;\n\t\tend \n\t\telse begin\n\t\tline_count <= line_count + 1;\n\t\tend\n\tend \n\telse begin\n\t\tpixel_count <= pixel_count + 1;\n\t\tline_count <= line_count;\n\tend\nend\n\nendmodule\n",
        "module_name": "VGA_DRIVER",
        "module_hash": "5087c117c234f76904ae407bfb29c97b",
        "dataset_index": 24475
      },
      "RS232TX_51291691": {
        "rtl_code": "module RS232TX (\n\tinput clk,\n\tinput Tx_start,\n\tinput [23:0] dbuffer,\n\toutput Tx,\n\toutput Tx_busy\n);\n\nwire bittick;\n\nwire[7:0] Tx_data = dbuffer[7:0];\n\nRS232Baud baud(\n\t.clk(clk),\n\t.enable(Tx_busy),\n\t.tick(bittick)\n);\n\nreg[3:0] Tx_state = 0;\nwire Tx_ready = (Tx_state==0);\nassign Tx_busy = ~Tx_ready;\n\nreg[7:0] Tx_shift = 0;\nalways @(posedge clk)\nbegin\n\tif (Tx_ready & Tx_start)\n\t\tTx_shift <= Tx_data;\n\telse\n\t\tif (Tx_state[3] & bittick)\n\t\t\tTx_shift <= (Tx_shift >> 1);\n\t\t\t\n\tcase(Tx_state)\n\t\t4'b0000: if(Tx_start) Tx_state <= 4'b0100;  4'b0100: if (bittick) Tx_state <= 4'b1000;  4'b1000: if (bittick) Tx_state <= 4'b1001;  4'b1001: if (bittick) Tx_state <= 4'b1010;  4'b1010: if (bittick) Tx_state <= 4'b1011;  4'b1011: if (bittick) Tx_state <= 4'b1100;  4'b1100: if (bittick) Tx_state <= 4'b1101;  4'b1101: if (bittick) Tx_state <= 4'b1110;  4'b1110: if (bittick) Tx_state <= 4'b1111;  4'b1111: if (bittick) Tx_state <= 4'b0010;  4'b0010: if (bittick) Tx_state <= 4'b0011;  4'b0011: if (bittick) Tx_state <= 4'b0000;  default: if (bittick) Tx_state <= 4'b0000;\n\tendcase\t\t\nend\n\nassign Tx = (Tx_state < 4) | (Tx_state[3] & Tx_shift[0]);\nendmodule\n\nmodule RS232Baud(\n\tinput clk,\n\tinput enable,\n\toutput tick\n);\n\nparameter ClkFrequency = 50000000;\nparameter Baud = 115200;\nparameter Oversampling = 1;\n\nfunction integer log2(input integer v); begin log2=0; while(v>>log2) log2=log2+1; end endfunction\nlocalparam AccWidth = log2(ClkFrequency/Baud)+8;  reg [AccWidth:0] Acc = 0;\nlocalparam ShiftLimiter = log2(Baud*Oversampling >> (31-AccWidth));  localparam Inc = ((Baud*Oversampling << (AccWidth-ShiftLimiter))+(ClkFrequency>>(ShiftLimiter+1)))/(ClkFrequency>>ShiftLimiter);\nalways @(posedge clk) if(enable) Acc <= Acc[AccWidth-1:0] + Inc[AccWidth:0]; else Acc <= Inc[AccWidth:0];\nassign tick = Acc[AccWidth];\n\nendmodule",
        "module_name": "RS232TX",
        "module_hash": "51291691e32614861fdd1807194f1965",
        "dataset_index": 22034
      },
      "top__b08440f7": {
        "rtl_code": "module top_module (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    input [7:0] in,\n    output [7:0] final_output);\n\n    wire [3:0] counter_output;\n    wire [7:0] edge_output;\n\n    decade_counter counter (\n        .clk(clk),\n        .pause(pause),\n        .resume(resume),\n        .reset(reset),\n        .q(counter_output)\n    );\n\n    edge_detection edge_det (\n        .clk(clk),\n        .in(in),\n        .anyedge(edge_output)\n    );\n\n    functional_module func_mod (\n        .counter_output(counter_output),\n        .edge_output(edge_output),\n        .final_output(final_output)\n    );\n\nendmodule\n\nmodule decade_counter (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    output [3:0] q\n);\n    reg [3:0] count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (!pause || resume) begin\n            count <= (count == 4'b1001) ? 4'b0000 : count + 4'b0001;\n        end\n    end\n\n    assign q = count;\nendmodule\n\nmodule edge_detection (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n    reg [7:0] prev_in;\n    reg [7:0] edge_count;\n\n    always @(posedge clk) begin\n        prev_in <= in;\n        edge_count <= edge_count + (in & ~prev_in);\n    end\n\n    assign anyedge = edge_count;\nendmodule\n\nmodule functional_module (\n    input [3:0] counter_output,\n    input [7:0] edge_output,\n    output [7:0] final_output\n);\n    assign final_output = counter_output + edge_output;\nendmodule",
        "module_name": "top_",
        "module_hash": "b08440f72e16920f45864169f9b63faa",
        "dataset_index": 4066
      },
      "counter_4bit_f93c6350": {
        "rtl_code": "module counter_4bit (\n    input clk,\n    input rst,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            out <= 4'd0;\n        end else begin\n            if (out == 4'd15) begin\n                out <= 4'd0;\n            end else begin\n                out <= out + 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "f93c635094c59b96a6df090a2b46a2b6",
        "dataset_index": 6740
      },
      "my_RAM64X1D2_top_2690ee5b": {
        "rtl_code": "module my_RAM64X1D2_top (\n    input clk,\n    input [7:0] din,\n    input we,\n    input [5:0] addr,\n    output [7:0] dout\n);\n\nwire [7:0] dout_a, dout_b;\nwire [5:0] addr_a, addr_b;\n\nassign addr_a = addr[5:0];\nassign addr_b = {1'b0, addr[5:1]};\n\nmy_RAM64X1D2  ram_b (\n    .clk(clk),\n    .din(din),\n    .dout(dout_b),\n    .we(we),\n    .addr(addr_b)\n);\n\nmy_RAM64X1D2 ram_a (\n    .clk(clk),\n    .din(din),\n    .dout(dout_a),\n    .we(we),\n    .addr(addr_a)\n);\n\nassign dout = {dout_a[0], dout_b[0]};\n\nendmodule\n\nmodule my_RAM64X1D2 (\n    input clk,\n    input [7:0] din,\n    output reg [7:0] dout,\n    input we,\n    input [5:0] addr\n);\n\nreg [7:0] mem [0:63];\n\nalways @(posedge clk) begin\n    if (we) begin\n        mem[addr] <= din;\n    end\n    dout <= mem[addr];\nend\n\nendmodule",
        "module_name": "my_RAM64X1D2_top",
        "module_hash": "2690ee5b5060d84dd56dc061c4445b63",
        "dataset_index": 5477
      },
      "sky130_fd_sc_lp__o221ai_d85b242d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o221ai",
        "module_hash": "d85b242d2ce560f795e36563555ca972",
        "dataset_index": 22787
      },
      "PulseGenerator_dcfa68c8": {
        "rtl_code": "module PulseGenerator(\n    input clk,\n    input rst,\n    input [31:0] N,\n    output reg out\n);\n\n    reg [31:0] counter;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            out <= 0;\n        end\n        else begin\n            if (counter == N-1) begin\n                counter <= 0;\n                out <= 1;\n            end\n            else begin\n                counter <= counter + 1;\n                out <= 0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "PulseGenerator",
        "module_hash": "dcfa68c8f5ec6e5edb9ec99206562722",
        "dataset_index": 19912
      },
      "NPCG_Toggle_SCC_PI_reset_cd605c2a": {
        "rtl_code": "\n\nmodule NPCG_Toggle_SCC_PI_reset\n#\n(\n    parameter NumberOfWays    =   4\n)\n(\n    iSystemClock,\n    iReset      ,\n    iOpcode     ,\n    iTargetID   ,\n    iSourceID   ,\n    iCMDValid   ,\n    oCMDReady   ,\n    oStart      ,\n    oLastStep   ,\n    iPM_Ready   ,\n    iPM_LastStep,\n    oPM_PCommand\n);\n    input           iSystemClock    ;\n    input           iReset          ;\n    input   [5:0]   iOpcode         ;\n    input   [4:0]   iTargetID       ;\n    input   [4:0]   iSourceID       ;\n    input           iCMDValid       ;\n    output          oCMDReady       ;\n    output          oStart          ;\n    output          oLastStep       ;\n    input   [7:0]   iPM_Ready       ;\n    input   [7:0]   iPM_LastStep    ;\n    output  [7:0]   oPM_PCommand    ;\n\n    wire            wModuleTriggered;\n\n    localparam  State_Idle          = 3'b000;\n    localparam  State_PIResetIssue  = 3'b001;\n    localparam  State_PIWait        = 3'b011;\n    reg [2:0]   rCurState   ;\n    reg [2:0]   rNextState  ;\n    \n    wire wPIResetTrig;\n\n    always @ (posedge iSystemClock)\n        if (iReset)\n            rCurState <= State_Idle;\n        else\n            rCurState <= rNextState;\n\n    always @ (*)\n        case (rCurState)\n        State_Idle:\n            rNextState <= (wModuleTriggered)?State_PIResetIssue:State_Idle;\n        State_PIResetIssue:\n            rNextState <= (iPM_Ready)?State_PIWait:State_PIResetIssue;\n        State_PIWait:\n            rNextState <= (oLastStep)?State_Idle:State_PIWait;\n        default:\n            rNextState <= State_Idle;\n        endcase\n    \n    assign wModuleTriggered     = (iCMDValid && iTargetID == 5'b00101 && iOpcode == 6'b110010);\n    assign oCMDReady            = (rCurState == State_Idle);\n    \n    assign wPIResetTrig         = (rCurState == State_PIResetIssue);\n    \n    assign oStart               = wModuleTriggered;\n    assign oLastStep            = (rCurState == State_PIWait) & iPM_LastStep[4];\n    \n    assign oPM_PCommand[7:0]    = {1'b0, 1'b0, 1'b0, wPIResetTrig, 1'b0, 1'b0, 1'b0, 1'b0};\n\n\nendmodule\n",
        "module_name": "NPCG_Toggle_SCC_PI_reset",
        "module_hash": "cd605c2a9a6730d298ebaaf191f36946",
        "dataset_index": 25614
      },
      "selem_ca7b5494": {
        "rtl_code": "\nmodule selem (\n  input sreq_0n,\n  input sreq_1n,\n  output activateOut_0r,\n  output activateOut_0a\n);\n\n  assign activateOut_0r = sreq_0n & sreq_1n;\n  assign activateOut_0a = sreq_0n | sreq_1n;\n\nendmodule\n",
        "module_name": "selem",
        "module_hash": "ca7b54946172daee86f163b584233b23",
        "dataset_index": 18514
      },
      "axi_hdmi_tx_vdma_be3ab0af": {
        "rtl_code": "module axi_hdmi_tx_vdma (\n\n  hdmi_fs_toggle,\n  hdmi_raddr_g,\n\n  vdma_clk,\n  vdma_rst,\n  vdma_fs,\n  vdma_fs_ret,\n  vdma_valid,\n  vdma_data,\n  vdma_ready,\n  vdma_wr,\n  vdma_waddr,\n  vdma_wdata,\n  vdma_fs_ret_toggle,\n  vdma_fs_waddr,\n  vdma_tpm_oos,\n  vdma_ovf,\n  vdma_unf);\n\n  localparam      BUF_THRESHOLD_LO = 9'd3;\n  localparam      BUF_THRESHOLD_HI = 9'd509;\n  localparam      RDY_THRESHOLD_LO = 9'd450;\n  localparam      RDY_THRESHOLD_HI = 9'd500;\n\n  input           hdmi_fs_toggle;\n  input   [ 8:0]  hdmi_raddr_g;\n\n  input           vdma_clk;\n  input           vdma_rst;\n  output          vdma_fs;\n  input           vdma_fs_ret;\n  input           vdma_valid;\n  input   [63:0]  vdma_data;\n  output          vdma_ready;\n  output          vdma_wr;\n  output  [ 8:0]  vdma_waddr;\n  output  [47:0]  vdma_wdata;\n  output          vdma_fs_ret_toggle;\n  output  [ 8:0]  vdma_fs_waddr;\n  output          vdma_tpm_oos;\n  output          vdma_ovf;\n  output          vdma_unf;\n\n  reg             vdma_fs_toggle_m1 = 'd0;\n  reg             vdma_fs_toggle_m2 = 'd0;\n  reg             vdma_fs_toggle_m3 = 'd0;\n  reg             vdma_fs = 'd0;\n  reg     [ 8:0]  vdma_fs_waddr = 'd0;\n  reg             vdma_fs_ret_toggle = 'd0;\n  reg             vdma_wr = 'd0;\n  reg     [ 8:0]  vdma_waddr = 'd0;\n  reg     [47:0]  vdma_wdata = 'd0;\n  reg     [22:0]  vdma_tpm_data = 'd0;\n  reg             vdma_tpm_oos = 'd0;\n  reg     [ 8:0]  vdma_raddr_g_m1 = 'd0;\n  reg     [ 8:0]  vdma_raddr_g_m2 = 'd0;\n  reg     [ 8:0]  vdma_raddr = 'd0;\n  reg     [ 8:0]  vdma_addr_diff = 'd0;\n  reg             vdma_ready = 'd0;\n  reg             vdma_almost_full = 'd0;\n  reg             vdma_almost_empty = 'd0;\n  reg             vdma_ovf = 'd0;\n  reg             vdma_unf = 'd0;\n\n  wire    [47:0]  vdma_tpm_data_s;\n  wire            vdma_tpm_oos_s;\n  wire    [ 9:0]  vdma_addr_diff_s;\n  wire            vdma_ovf_s;\n  wire            vdma_unf_s;\n\n  function [8:0] g2b;\n    input [8:0] g;\n    reg   [8:0] b;\n    begin\n      b[8] = g[8];\n      b[7] = b[8] ^ g[7];\n      b[6] = b[7] ^ g[6];\n      b[5] = b[6] ^ g[5];\n      b[4] = b[5] ^ g[4];\n      b[3] = b[4] ^ g[3];\n      b[2] = b[3] ^ g[2];\n      b[1] = b[2] ^ g[1];\n      b[0] = b[1] ^ g[0];\n      g2b = b;\n    end\n  endfunction\n\n  always @(posedge vdma_clk or posedge vdma_rst) begin\n    if (vdma_rst == 1'b1) begin\n      vdma_fs_toggle_m1 <= 'd0;\n      vdma_fs_toggle_m2 <= 'd0;\n      vdma_fs_toggle_m3 <= 'd0;\n    end else begin\n      vdma_fs_toggle_m1 <= hdmi_fs_toggle;\n      vdma_fs_toggle_m2 <= vdma_fs_toggle_m1;\n      vdma_fs_toggle_m3 <= vdma_fs_toggle_m2;\n    end\n  end\n\n  always @(posedge vdma_clk) begin\n    vdma_fs <= vdma_fs_toggle_m2 ^ vdma_fs_toggle_m3;\n    if (vdma_fs_ret == 1'b1) begin\n      vdma_fs_waddr <= vdma_waddr;\n      vdma_fs_ret_toggle <= ~vdma_fs_ret_toggle;\n    end\n  end\n\n  always @(posedge vdma_clk) begin\n    vdma_wr <= vdma_valid & vdma_ready;\n    if (vdma_rst == 1'b1) begin\n      vdma_waddr <= 9'd0;\n    end else if (vdma_wr == 1'b1) begin\n      vdma_waddr <= vdma_waddr + 1'b1;\n    end\n    vdma_wdata <= {vdma_data[55:32], vdma_data[23:0]};\n  end\n\n  assign vdma_tpm_data_s = {vdma_tpm_data, 1'b1, vdma_tpm_data, 1'b0};\n  assign vdma_tpm_oos_s = (vdma_wdata == vdma_tpm_data_s) ? 1'b0 : vdma_wr;\n\n  always @(posedge vdma_clk) begin\n    if ((vdma_rst == 1'b1) || (vdma_fs_ret == 1'b1)) begin\n      vdma_tpm_data <= 23'd0;\n      vdma_tpm_oos <= 1'd0;\n    end else if (vdma_wr == 1'b1) begin\n      vdma_tpm_data <= vdma_tpm_data + 1'b1;\n      vdma_tpm_oos <= vdma_tpm_oos_s;\n    end\n  end\n\n  assign vdma_addr_diff_s = {1'b1, vdma_waddr} - vdma_raddr;\n  assign vdma_ovf_s = (vdma_addr_diff < BUF_THRESHOLD_LO) ? vdma_almost_full : 1'b0;\n  assign vdma_unf_s = (vdma_addr_diff > BUF_THRESHOLD_HI) ? vdma_almost_empty : 1'b0;\n\n  always @(posedge vdma_clk or posedge vdma_rst) begin\n    if (vdma_rst == 1'b1) begin\n      vdma_raddr_g_m1 <= 9'd0;\n      vdma_raddr_g_m2 <= 9'd0;\n    end else begin\n      vdma_raddr_g_m1 <= hdmi_raddr_g;\n      vdma_raddr_g_m2 <= vdma_raddr_g_m1;\n    end\n  end\n\n  always @(posedge vdma_clk) begin\n    vdma_raddr <= g2b(vdma_raddr_g_m2);\n    vdma_addr_diff <= vdma_addr_diff_s[8:0];\n    if (vdma_addr_diff >= RDY_THRESHOLD_HI) begin\n      vdma_ready <= 1'b0;\n    end else if (vdma_addr_diff <= RDY_THRESHOLD_LO) begin\n      vdma_ready <= 1'b1;\n    end\n    if (vdma_addr_diff > BUF_THRESHOLD_HI) begin\n      vdma_almost_full <= 1'b1;\n    end else begin\n      vdma_almost_full <= 1'b0;\n    end\n    if (vdma_addr_diff < BUF_THRESHOLD_LO) begin\n      vdma_almost_empty <= 1'b1;\n    end else begin\n      vdma_almost_empty <= 1'b0;\n    end\n    vdma_ovf <= vdma_ovf_s;\n    vdma_unf <= vdma_unf_s;\n  end\n\nendmodule\n\n",
        "module_name": "axi_hdmi_tx_vdma",
        "module_hash": "be3ab0afac69b9d8acc5e5f44025a1d6",
        "dataset_index": 6021
      },
      "Decodificador_e03c0ce9": {
        "rtl_code": "module Decodificador(\n   input [6:0] Cuenta,\n   output reg [7:0] catodo1,\n   output reg [7:0] catodo2,\n   output reg [7:0] catodo3,\n   output reg [7:0] catodo4\n);\n\n   always @(*)\n   begin\n      case (Cuenta)\n         7'b0000000: begin\n                        catodo1 <= 8'b00000011;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000001: begin\n                        catodo1 <= 8'b10011111;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011; \n                     end \n         7'b0000010: begin\n                        catodo1 <= 8'b00100101;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000011: begin\n                        catodo1 <= 8'b00001101;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000100: begin\n                        catodo1 <= 8'b10011001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000101: begin\n                        catodo1 <= 8'b01001001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000110: begin\n                        catodo1 <= 8'b01000001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000111: begin\n                        catodo1 <= 8'b00011111;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001000: begin\n                        catodo1 <= 8'b00000001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001001: begin\n                        catodo1 <= 8'b00011001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001010: begin\n                        catodo1 <= 8'b00000011;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001011: begin\n                        catodo1 <= 8'b10011111;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001100: begin\n                        catodo1 <= 8'b00100101;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001101: begin\n                        catodo1 <= 8'b00001101;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001110: begin\n                        catodo1 <= 8'b10011001;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001111: begin\n                        catodo1 <= 8'b01001001;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         default:    begin\n                        catodo1 <= 8'b10011111;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b10011111; \n                        catodo4 <= 8'b10011111;\n                     end \t\n      endcase\t\t\n   end\t \n   \nendmodule",
        "module_name": "Decodificador",
        "module_hash": "e03c0ce9a9d1da698c7f3cb7fb4aef14",
        "dataset_index": 7072
      },
      "priority_mux_35557212": {
        "rtl_code": "module priority_mux (\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output reg Y, Z\n);\n\nalways @(*) begin\n    case(S)\n        2'b00: begin\n            if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n        2'b01: begin\n            if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n        2'b10: begin\n            if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n        2'b11: begin\n            if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "priority_mux",
        "module_hash": "355572127337a99c8180d3277b5fe006",
        "dataset_index": 4580
      },
      "and_gate_with_inverter_e5b69817": {
        "rtl_code": "\nmodule and_gate_with_inverter (\n    output Y,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  B1,\n    input  C1\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    wire B1_inv;\n    assign B1_inv = ~B1;\n\n    wire and_gate_output;\n    and (and_gate_output, A1, A2, A3);\n\n    assign Y = (C1 == 1'b1) ? 1'b0 : (and_gate_output & B1_inv);\n\nendmodule\n",
        "module_name": "and_gate_with_inverter",
        "module_hash": "e5b698179d2adb50b01fe6e693194f77",
        "dataset_index": 17720
      },
      "zet_rxr16_ffa258a3": {
        "rtl_code": "\n\nmodule zet_rxr16 (\n    input      [15:0] x,\n    input             ci,\n    input      [ 4:0] y,\n    input             e,\n    output reg [15:0] w,\n    output reg        co\n  );\n\n  always @(x or ci or y or e)\n    case (y)\n      default: {co,w} <= {ci,x};\n      5'd01: {co,w} <= e ? {x[0], ci, x[15:1]} : {ci, x[0], x[15:1]};\n      5'd02: {co,w} <= e ? {x[ 1:0], ci, x[15: 2]} : {ci, x[ 1:0], x[15: 2]};\n      5'd03: {co,w} <= e ? {x[ 2:0], ci, x[15: 3]} : {ci, x[ 2:0], x[15: 3]};\n      5'd04: {co,w} <= e ? {x[ 3:0], ci, x[15: 4]} : {ci, x[ 3:0], x[15: 4]};\n      5'd05: {co,w} <= e ? {x[ 4:0], ci, x[15: 5]} : {ci, x[ 4:0], x[15: 5]};\n      5'd06: {co,w} <= e ? {x[ 5:0], ci, x[15: 6]} : {ci, x[ 5:0], x[15: 6]};\n      5'd07: {co,w} <= e ? {x[ 6:0], ci, x[15: 7]} : {ci, x[ 6:0], x[15: 7]};\n      5'd08: {co,w} <= e ? {x[ 7:0], ci, x[15: 8]} : {ci, x[ 7:0], x[15: 8]};\n      5'd09: {co,w} <= e ? {x[ 8:0], ci, x[15: 9]} : {ci, x[ 8:0], x[15: 9]};\n      5'd10: {co,w} <= e ? {x[ 9:0], ci, x[15:10]} : {ci, x[ 9:0], x[15:10]};\n      5'd11: {co,w} <= e ? {x[10:0], ci, x[15:11]} : {ci, x[10:0], x[15:11]};\n      5'd12: {co,w} <= e ? {x[11:0], ci, x[15:12]} : {ci, x[11:0], x[15:12]};\n      5'd13: {co,w} <= e ? {x[12:0], ci, x[15:13]} : {ci, x[12:0], x[15:13]};\n      5'd14: {co,w} <= e ? {x[13:0], ci, x[15:14]} : {ci, x[13:0], x[15:14]};\n      5'd15: {co,w} <= e ? {x[14:0], ci, x[15]} : {ci, x[14:0], x[15]};\n      5'd16: {co,w} <= {x,ci};\n    endcase\nendmodule\n",
        "module_name": "zet_rxr16",
        "module_hash": "ffa258a396e2d88d5edff29dfd23ff2d",
        "dataset_index": 25438
      },
      "BUFG_cbfde447": {
        "rtl_code": "\n\nmodule BUFG(I,O);\ninput I;\noutput O;\nassign #1 O=I;\nendmodule\n\n\nmodule BUFGMUX(O,I0,I1,S);\ninput I0,I1,S;\noutput O;\nassign #1 O = (S) ? I1 : I0;\nendmodule\n\n\nmodule DCM(CLKIN,PSCLK,PSEN,PSINCDEC,RST,CLK2X,CLK0,CLKFB);\ninput CLKIN, PSCLK, PSEN, PSINCDEC, RST, CLKFB;\noutput CLK2X, CLK0;\n\nassign #1 CLK0 = CLKIN;\n\nreg CLK2X;\ninitial CLK2X=0;\nalways @(posedge CLK0)\nbegin\n  CLK2X = 1'b1;\n  #5;\n  CLK2X = 1'b0;\n  #5;\n  CLK2X = 1'b1;\n  #5;\n  CLK2X = 1'b0;\nend\nendmodule\n\n\nmodule ODDR2(Q,D0,D1,C0,C1);\ninput D0,D1,C0,C1;\noutput Q;\nreg Q;\ninitial Q=0;\nalways @(posedge C0) Q=D0;\nalways @(posedge C1) Q=D1;\nendmodule\n\n\nmodule RAMB16_S9(CLK, ADDR, DI, DIP, DO, DOP, EN, SSR, WE);\ninput CLK, EN, SSR, WE;\ninput [10:0] ADDR;\ninput [7:0] DI;\ninput DIP;\noutput [7:0] DO;\noutput DOP;\n\nparameter WRITE_MODE = 0;\n\nwire [10:0] #1 dly_ADDR = ADDR;\nwire [8:0] #1 dly_DATA = {DIP,DI};\nwire #1 dly_EN = EN;\nwire #1 dly_WE = WE;\n\nreg [8:0] mem[0:2047];\n\nreg [7:0] DO;\nreg DOP;\n\nreg sampled_EN;\nreg [8:0] rddata;\n\ninteger i;\ninitial\nbegin\n  for (i=0; i<2048; i=i+1) mem[i] = 9'h15A;\nend\n\nalways @(posedge CLK)\nbegin\n  if (dly_EN && dly_WE) mem[dly_ADDR] = dly_DATA;\n  rddata = mem[dly_ADDR];\n  sampled_EN = dly_EN;\n  #1;\n  if (sampled_EN) {DOP,DO} = rddata; \nend\nendmodule\n\n\nmodule RAM16X1S (A0,A1,A2,A3,WCLK,WE,D,O);\ninput A0,A1,A2,A3,WCLK,WE,D;\noutput O;\n\nreg mem[0:15];\n\nwire #1 dly_WE = WE;\nwire #1 dly_D = D;\nwire [3:0] addr = {A3,A2,A1,A0};\nwire [3:0] #1 dly_addr = addr;\n\nalways @(posedge WCLK)\nbegin\n  if (dly_WE) mem[dly_addr] = dly_D;\nend\n\nreg [3:0] rdaddr;\nreg O;\nalways @*\nbegin\n  rdaddr = dly_addr;\n  #1;\n  O = mem[rdaddr];\nend\nendmodule\n\n\nmodule RAM16X4S (A0,A1,A2,A3,WCLK,WE,D0,D1,D2,D3,O0,O1,O2,O3);\ninput A0,A1,A2,A3,WCLK,WE,D0,D1,D2,D3;\noutput O0,O1,O2,O3;\nRAM16X1S bit0 (A0,A1,A2,A3,WCLK,WE,D0,O0);\nRAM16X1S bit1 (A0,A1,A2,A3,WCLK,WE,D1,O1);\nRAM16X1S bit2 (A0,A1,A2,A3,WCLK,WE,D2,O2);\nRAM16X1S bit3 (A0,A1,A2,A3,WCLK,WE,D3,O3);\nendmodule\n\n\nmodule SRLC16E (A0,A1,A2,A3,CLK,CE,D,Q15,Q);\ninput A0,A1,A2,A3,CLK,CE,D;\noutput Q15,Q;\n\nreg [15:0] mem;\n\nwire #1 dly_CE = CE;\nwire #1 dly_D = D;\nwire [3:0] addr = {A3,A2,A1,A0};\nwire [3:0] #1 dly_addr = addr;\n\nassign Q15 = mem[15];\n\nalways @(posedge CLK)\nbegin\n  if (dly_CE) mem = {mem,dly_D};\nend\n\nreg [3:0] rdaddr;\nreg Q;\nalways @*\nbegin\n  rdaddr = dly_addr;\n  #1;\n  Q = mem[rdaddr];\nend\nendmodule\n\n\nmodule MUXCY (S,CI,DI,O);\ninput S,CI,DI;\noutput O;\nreg O;\nalways @* begin #0.1; O = (S) ? CI : DI; end\nendmodule\n\n\n\n",
        "module_name": "BUFG",
        "module_hash": "cbfde4470223c060d484daeebc703e77",
        "dataset_index": 11132
      },
      "counter_4bit_bb0297e0": {
        "rtl_code": "module counter_4bit (\n    clk,\n    rst,\n    count\n);\n\ninput clk;\ninput rst;\noutput reg [3:0] count;\n\nalways @(posedge clk, posedge rst) begin\n    if (rst) begin\n        count <= 4'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "bb0297e0d9a40aad49e0476432b5df8a",
        "dataset_index": 4581
      },
      "SDP_RAM_ae47d411": {
        "rtl_code": "module SDP_RAM(\n    input clk,\n    input rce,\n    input [9:0] ra,\n    input wce,\n    input [9:0] wa,\n    input [15:0] wd,\n    output [15:0] rq\n);\n\nreg [15:0] memory [0:15];\n\nalways @(posedge clk) begin\n    if (wce) begin\n        memory[wa] <= wd;\n    end\nend\n\nassign rq = (rce) ? memory[ra] : 16'b0;\n\nendmodule",
        "module_name": "SDP_RAM",
        "module_hash": "ae47d4112210e3d7161cda3a07b2b0a3",
        "dataset_index": 13541
      },
      "dff_en #_f0ca4f7d": {
        "rtl_code": "module dff_en #(parameter width_p = 1, harden_p = 1, strength_p = 1)\n  (input clock_i,\n   input [width_p-1:0] data_i,\n   input en_i,\n   output reg [width_p-1:0] data_o);\n\n  reg [width_p-1:0] data_r;\n\n  always @(posedge clock_i) begin\n    if (en_i) begin\n      data_r <= data_i;\n    end\n  end\n\n  always @* begin\n    data_o <= data_r;\n  end\n\nendmodule",
        "module_name": "dff_en #",
        "module_hash": "f0ca4f7d24b65551d236dcea9b57a65a",
        "dataset_index": 7579
      },
      "Synchro_6fac82b5": {
        "rtl_code": "module Synchro(dato, clk, ds);\ninput dato, clk;\noutput ds;\n\nreg ds_reg;\n\nalways @(posedge clk) begin\n    ds_reg <= dato;\nend\n\nassign ds = ds_reg;\n\nendmodule\n\nmodule Sincronizador(\n    incambiarfuncion, incambiarsalida, inrst, inbtup, inbtdown, \n    outcambiarfuncion, outcambiarsalida, outrst, outbtup, outbtdown, clk\n);\ninput incambiarfuncion, incambiarsalida, inrst, inbtup, inbtdown, clk;\noutput outcambiarfuncion, outcambiarsalida, outrst, outbtup, outbtdown;\n\nSynchro S1 (\n    .dato(incambiarfuncion), \n    .clk(clk), \n    .ds(outcambiarfuncion)\n);\n\t \nSynchro S2 (\n    .dato(incambiarsalida), \n    .clk(clk), \n    .ds(outcambiarsalida)\n);\nSynchro S3 (\n    .dato(inrst), \n    .clk(clk), \n    .ds(outrst) \n);\nSynchro S4 (\n    .dato(inbtup), \n    .clk(clk), \n    .ds(outbtup)\n);\nSynchro S5 (\n    .dato(inbtdown), \n    .clk(clk), \n    .ds(outbtdown)\n);\n\nendmodule",
        "module_name": "Synchro",
        "module_hash": "6fac82b5fb7ea2a1968b14beddb8e91a",
        "dataset_index": 10664
      },
      "audio_fifo_a9a2e977": {
        "rtl_code": "module audio_fifo(\n    input clk,\n    input rst,\n    input en,\n    input [1:0] mode,\n    input [31:0] din,\n    input we,\n    input re,\n    output [19:0] dout,\n    output [1:0] status,\n    output full,\n    output empty\n);\n\nreg [31:0] mem [0:7]; // 8-word deep memory\nreg [2:0] wp; // write pointer\nreg [3:0] rp; // read pointer\nreg [1:0] status_reg; // status register\nreg [19:0] dout_reg; // output data register\nreg empty_reg; // empty register\n\nassign dout = dout_reg;\nassign status = status_reg;\nassign empty = empty_reg;\nassign full = (wp == rp) & we;\n\nwire [2:0] wp_p1 = wp + 1;\nwire [3:0] rp_p1 = rp + 1;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wp <= 3'h0;\n        rp <= 4'h0;\n        status_reg <= 2'h0;\n        dout_reg <= 20'h0;\n        empty_reg <= 1'b1;\n    end else if (en) begin\n        if (we) begin\n            mem[wp] <= din;\n            wp <= wp_p1;\n        end\n        if (re) begin\n            case (mode)\n                2'h0: dout_reg <= {mem[rp][15:0], 4'h0};\n                2'h1: dout_reg <= {mem[rp][17:0], 2'h0};\n                2'h2: dout_reg <= mem[rp];\n            endcase\n            rp <= (mode == 2'h0) ? rp_p1 : rp + 2;\n        end\n        status_reg <= (wp - rp) - 2'h1;\n        empty_reg <= (rp == wp) & (mode == 2'h0 ? 1'b1 : we);\n    end\nend\n\nendmodule",
        "module_name": "audio_fifo",
        "module_hash": "a9a2e977debc2d21a92fae14b1408ba5",
        "dataset_index": 3089
      },
      "mig_7series_v4_0_axi_mc_simple_fifo #_740c0bae": {
        "rtl_code": "\n\n\nmodule mig_7series_v4_0_axi_mc_simple_fifo #\n(\n  parameter C_WIDTH  = 8,\n  parameter C_AWIDTH = 4,\n  parameter C_DEPTH  = 16\n)\n(\n  input  wire               clk,       input  wire               rst,       input  wire               wr_en,     input  wire               rd_en,     input  wire [C_WIDTH-1:0] din,       output wire [C_WIDTH-1:0] dout,      output wire               a_full,\n  output wire               full,      output wire               a_empty,\n  output wire               empty      );\n\nlocalparam [C_AWIDTH-1:0] C_EMPTY = ~(0);\nlocalparam [C_AWIDTH-1:0] C_EMPTY_PRE =  (0);\nlocalparam [C_AWIDTH-1:0] C_FULL  = C_EMPTY-1;\nlocalparam [C_AWIDTH-1:0] C_FULL_PRE  = (C_DEPTH < 8) ? C_FULL-1 : C_FULL-(C_DEPTH/8);\n \nreg [C_WIDTH-1:0]  memory [C_DEPTH-1:0];\nreg [C_AWIDTH-1:0] cnt_read;\n\n\nalways @(posedge clk) begin : BLKSRL\ninteger i;\n  if (wr_en) begin\n    for (i = 0; i < C_DEPTH-1; i = i + 1) begin\n      memory[i+1] <= memory[i];\n    end\n    memory[0] <= din;\n  end\nend\n\nalways @(posedge clk) begin\n  if (rst) cnt_read <= C_EMPTY;\n  else if ( wr_en & !rd_en) cnt_read <= cnt_read + 1'b1;\n  else if (!wr_en &  rd_en) cnt_read <= cnt_read - 1'b1;\nend\n\nassign full  = (cnt_read == C_FULL);\nassign empty = (cnt_read == C_EMPTY);\nassign a_full  = ((cnt_read >= C_FULL_PRE) && (cnt_read != C_EMPTY));\nassign a_empty = (cnt_read == C_EMPTY_PRE);\n\nassign dout  = (C_DEPTH == 1) ? memory[0] : memory[cnt_read];\n\nendmodule `default_nettype wire\n",
        "module_name": "mig_7series_v4_0_axi_mc_simple_fifo #",
        "module_hash": "740c0bae04687d276175198be9057dc8",
        "dataset_index": 25192
      },
      "traffic_light_fsm_69cefee5": {
        "rtl_code": "\nmodule traffic_light_fsm (\n  input clk,\n  input reset,\n  output reg red,\n  output reg green,\n  output reg yellow\n);\n\n  parameter RED = 2'b00, GREEN = 2'b01, YELLOW = 2'b10;\n  reg [1:0] state, next_state;\n  reg [3:0] count;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= RED;\n      count <= 0;\n    end else begin\n      state <= next_state;\n      count <= count + 1;\n    end\n  end\n\n  always @(*) begin\n    case (state)\n      RED: begin\n        red <= 1;\n        green <= 0;\n        yellow <= 0;\n        if (count == 5) begin\n          next_state = GREEN;\n        end else begin\n          next_state = RED;\n        end\n      end\n\n      GREEN: begin\n        red <= 0;\n        green <= 1;\n        yellow <= 0;\n        if (count == 10) begin\n          next_state = YELLOW;\n        end else begin\n          next_state = GREEN;\n        end\n      end\n\n      YELLOW: begin\n        red <= 0;\n        green <= 0;\n        yellow <= 1;\n        if (count == 2) begin\n          next_state = RED;\n        end else begin\n          next_state = YELLOW;\n        end\n      end\n\n      default: begin\n        red <= 0;\n        green <= 0;\n        yellow <= 0;\n        next_state = RED;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "traffic_light_fsm",
        "module_hash": "69cefee5411d4bf821e204122bea86df",
        "dataset_index": 3574
      },
      "address_filter_049dcaef": {
        "rtl_code": "module address_filter\n  (input clk,\n   input reset,\n   input go,\n   input [7:0] data,\n   output match,\n   output done);\n\n   reg [2:0] af_state;\n\n   always @(posedge clk)\n     if(reset)\n       af_state <= 0;\n     else if(go)\n       if(data[0] == 1'b0)\n         af_state <= 1'b0;\n       else\n         af_state <= 3'b001;\n     else\n       case(af_state)\n         3'b001: af_state <= 3'b010;\n         3'b010: af_state <= 3'b011;\n         3'b011: af_state <= 3'b100;\n         3'b100: af_state <= 3'b101;\n         3'b101: af_state <= 3'b110;\n         3'b110: af_state <= 3'b000;\n         default: af_state <= 3'b000;\n       endcase\n\n   assign match = (af_state == 3'b110);\n   assign done = (af_state == 3'b110) || (af_state == 3'b000);\n   \nendmodule",
        "module_name": "address_filter",
        "module_hash": "049dcaefedc163757642def89f671e8d",
        "dataset_index": 16020
      },
      "ch_pcma_9f711d92": {
        "rtl_code": "module ch_pcma(\n\tinput CLK,\n\tinput CLK_SAMP,\n\tinput nRESET,\n\tinput FLAGMASK,\n\toutput reg END_FLAG,\n\tinput KEYON, KEYOFF,\n\t\n\tinput [11:0] JEDI_DOUT,\n\tinput [15:0] ADDR_START,\n\tinput [15:0] ADDR_STOP,\n\tinput [7:0] VOLPAN,\t\t\t\toutput [21:0] ROM_ADDR,\n\toutput reg [3:0] DATA,\n\toutput reg [9:0] ADPCM_STEP,\tinput [7:0] ROM_DATA,\n\toutput reg [15:0] SAMPLE_OUT\n);\n\n\treg RUN;\n\treg [1:0] ROM_BANK;\n\treg [19:0] ADDR_CNT;\n\treg NIBBLE;\n\treg [11:0] ADPCM_ACC;\n\t\n\treg SET_FLAG;\n\treg PREV_FLAGMASK;\n\t\n\tassign ROM_ADDR = { ROM_BANK, ADDR_CNT };\n\t\n\talways @(posedge CLK)\n\tbegin\n\t\tif (!nRESET)\n\t\tbegin\n\t\t\tSET_FLAG <= 0;\t\t\tPREV_FLAGMASK <= 0;\tRUN <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\n\t\t\tif (KEYON)\n\t\t\tbegin\n\t\t\t\tADDR_CNT <= { ADDR_START[11:0], 8'h0 };\n\t\t\t\tROM_BANK <= ADDR_START[13:12];\tEND_FLAG <= 0;\n\t\t\t\tNIBBLE <= 0;\t\tADPCM_ACC <= 0;\n\t\t\t\tADPCM_STEP <= 0;\n\t\t\t\tRUN <= 1;\n\t\t\tend\n\t\t\t\n\t\t\tif (KEYOFF)\n\t\t\t\tRUN <= 0;\n\t\t\t\n\t\t\tif (RUN && CLK_SAMP)\n\t\t\tbegin\n\t\t\t\tif ((FLAGMASK == 1) && (PREV_FLAGMASK == 0))\n\t\t\t\t\tEND_FLAG <= 0;\n\t\t\t\t\n\t\t\t\tPREV_FLAGMASK <= FLAGMASK;\n\t\t\t\t\n\t\t\t\tif (ADDR_CNT[19:8] == ADDR_STOP[11:0])\n\t\t\t\tbegin\n\t\t\t\t\tif (SET_FLAG == 0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tSET_FLAG <= 1;\n\t\t\t\t\t\tEND_FLAG <= ~FLAGMASK;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tSET_FLAG <= 0;\n\t\t\t\t\n\t\t\t\t\tif (NIBBLE)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tDATA <= ROM_DATA[3:0];\n\t\t\t\t\t\tADDR_CNT <= ADDR_CNT + 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tDATA <= ROM_DATA[7:4];\n\t\t\t\t\t\n\t\t\t\t\tADPCM_ACC <= ADPCM_ACC + JEDI_DOUT;\n\t\t\t\t\t\n\t\t\t\t\tcase (DATA[2:0])\n\t\t\t\t\t\t0, 1, 2, 3 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP >= 16)\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP - 10'd16;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t4 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 32))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd32;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t5 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 80))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd80;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t6 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 112))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd112;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t7 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 144))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd144;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tSAMPLE_OUT <= ADPCM_ACC[11] ? { 4'b1111, ADPCM_ACC } : { 4'b0000, ADPCM_ACC };\n\t\t\t\t\t\n\t\t\t\t\tNIBBLE <= ~NIBBLE;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "ch_pcma",
        "module_hash": "9f711d92be584d59dd5fcf3b806796f3",
        "dataset_index": 23203
      },
      "XORCY_c5861657": {
        "rtl_code": "\nmodule XORCY (O, CI, LI);\n\n\n`ifdef XIL_TIMING\n\n    parameter LOC = \"UNPLACED\";\n\n`endif\n\n    \n    output O;\n\n    input  CI, LI;\n\n\txor X1 (O, CI, LI);\n\n`ifdef XIL_TIMING\n\n    specify\n        \n        (CI => O) = (0:0:0, 0:0:0);\n        (LI => O) = (0:0:0, 0:0:0);\n        specparam PATHPULSE$ = 0;\n        \n    endspecify\n\n`endif\n    \nendmodule\n",
        "module_name": "XORCY",
        "module_hash": "c5861657f7d55ee007b573fe12e91871",
        "dataset_index": 23631
      },
      "delay_calc_37e06a7e": {
        "rtl_code": "module delay_calc (\n\tclk40,\n\trst,\n\tdata_offset_delay,\n\tdelay_modifier,\n\tscan_delay,\n\tstrb,\n\tadc_clock_delay,\n\tadc_data_delay,\n\tadc_drdy_delay,\n\tsaturated\n);\n\ninput clk40;\ninput rst;\ninput [6:0] data_offset_delay;\ninput [6:0] delay_modifier;\ninput [5:0] scan_delay;\ninput strb;\n\noutput [5:0] adc_clock_delay;\noutput [5:0] adc_data_delay;\noutput [5:0] adc_drdy_delay;\noutput saturated;\n\nreg [5:0] adc_clock_delay;\nreg [7:0] adc_data_delay_2s;\nreg [7:0] adc_drdy_delay_2s;\n\nalways @(posedge clk40) begin\n\tif (rst) begin\n\t\tadc_clock_delay <= 0;\n\t\tadc_data_delay_2s <= 0;\n\t\tadc_drdy_delay_2s <= 0;\n\tend else begin\n\t\tif (strb) begin\n\t\t\tadc_data_delay_2s <= 8'd32 + {data_offset_delay[6],data_offset_delay} + {delay_modifier[6],delay_modifier} + (8'b1 + ~scan_delay);\n\t\t\tadc_drdy_delay_2s <= 8'd32 + {delay_modifier[6],delay_modifier} + (8'b1 + ~scan_delay);\n\t\t\tadc_clock_delay <= scan_delay;\n\t\tend\n\tend\nend\n\nassign adc_data_delay = (adc_data_delay_2s[7] ? 6'b0 : ( (adc_data_delay_2s[6:0] > 6'd63) ? 6'd63 : adc_data_delay_2s[5:0]));\nassign adc_drdy_delay = (adc_drdy_delay_2s[7] ? 6'b0 : ( (adc_drdy_delay_2s[6:0] > 6'd63) ? 6'd63 : adc_drdy_delay_2s[5:0]));\nassign saturated = ( (adc_data_delay_2s[7] ? 1 : ( (adc_data_delay_2s[6:0] > 6'd63) ? 1 : 0)) ||\n\t\t\t\t\t\t\t(adc_drdy_delay_2s[7] ? 1 : ( (adc_drdy_delay_2s[6:0] > 6'd63) ? 1 : 0)) );\n\nendmodule",
        "module_name": "delay_calc",
        "module_hash": "37e06a7ed086b14f60678693b0b76f50",
        "dataset_index": 22990
      },
      "decoder_2to4_f0c5e93b": {
        "rtl_code": "module decoder_2to4 (\n  input [1:0] in,\n  output [3:0] out\n);\n\n  assign out[0] = (in == 2'b00) ? 1'b1 : 1'b0;\n  assign out[1] = (in == 2'b01) ? 1'b1 : 1'b0;\n  assign out[2] = (in == 2'b10) ? 1'b1 : 1'b0;\n  assign out[3] = (in == 2'b11) ? 1'b1 : 1'b0;\n\nendmodule\n",
        "module_name": "decoder_2to4",
        "module_hash": "f0c5e93b8a2c6e7f641d720216848aab",
        "dataset_index": 6186
      },
      "select_logic_3e7f0f34": {
        "rtl_code": "module select_logic(i1, i2, i3, i4, i5, i6, i7, i8, s1, s2, s3, a1);\n  input i1, i2, i3, i4, i5, i6, i7, i8, s1, s2, s3;\n  output a1;\n\n  assign a1 = (i1 & (!s1) & (!s2) & (!s3)) |\n              (i2 & (!s1) & (!s2) & (s3)) |\n              (i3 & (!s1) & (s2) & (!s3)) |\n              (i4 & (!s1) & (s2) & (s3)) |\n              (i5 & (s1) & (!s2) & (!s3)) |\n              (i6 & (s1) & (!s2) & (s3)) |\n              (i7 & (s1) & (s2) & (!s3)) |\n              (i8 & (s1) & (s2) & (s3));\n\nendmodule",
        "module_name": "select_logic",
        "module_hash": "3e7f0f341910900ee8bfa922b2196ea4",
        "dataset_index": 11739
      },
      "longest_sequence_detection_1bf6e5a7": {
        "rtl_code": "\nmodule longest_sequence_detection (\n  input clk,\n  input reset,\n  input [15:0] data,\n  output [3:0] length,\n  output [3:0] start_index\n);\n\nreg [3:0] count; // counter for current sequence length\nreg [3:0] max_count; // counter for longest sequence length\nreg [3:0] index; // counter for current sequence starting index\nreg [3:0] max_index; // counter for starting index of longest sequence\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 0;\n    max_count <= 0;\n    index <= 0;\n    max_index <= 0;\n  end else begin\n    if (data == 16'hFFFF) begin // all 1's case\n      count <= 16;\n      max_count <= 16;\n      index <= 0;\n      max_index <= 0;\n    end else if (data == 16'h0000) begin // all 0's case\n      count <= 0;\n      max_count <= 0;\n      index <= 0;\n      max_index <= 0;\n    end else begin // normal case\n      if (data[0] == 1) begin\n        if (count == 0) begin\n          index <= 0;\n        end\n        count <= count + 1;\n      end else begin\n        if (count > max_count) begin\n          max_count <= count;\n          max_index <= index;\n        end\n        count <= 0;\n        index <= index + count + 1;\n      end\n    end\n  end\nend\n\n\nwire [3:0] length_int = max_count;\n\nwire [3:0] start_index_int = max_index;\n\nassign length = length_int;\nassign start_index = start_index_int;\n\nendmodule",
        "module_name": "longest_sequence_detection",
        "module_hash": "1bf6e5a72820b7f1bacaa769e841268b",
        "dataset_index": 445
      },
      "constant_enable_5609970f": {
        "rtl_code": "module constant_enable (\n  input clk,\n  input reset,\n  input enable,\n  output reg out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      out <= 0;\n    end else if (enable) begin\n      out <= 1;\n    end else begin\n      out <= 0;\n    end\n  end\n  \nendmodule\n",
        "module_name": "constant_enable",
        "module_hash": "5609970f47afb9761edded4b5fd9316d",
        "dataset_index": 14550
      },
      "mux4to1_4bit_923a09bd": {
        "rtl_code": "module mux4to1_4bit(Y, A, B, C, D, S0, S1);\n\n    input [3:0] A, B, C, D;\n    input S0, S1;\n    output [3:0] Y;\n    \n    wire [3:0] AB, CD, Y_temp;\n    \n    assign AB = (S0 & ~S1) ? B : A;\n    assign CD = (S0 & S1) ? D : C;\n    assign Y_temp = (S0 | S1) ? CD : AB;\n    assign Y = Y_temp;\n    \nendmodule",
        "module_name": "mux4to1_4bit",
        "module_hash": "923a09bd946f2c0b034352b4116bf8cf",
        "dataset_index": 18300
      },
      "full_adder_a20165d2": {
        "rtl_code": "\nmodule full_adder (\n  input A,\n  input B,\n  input C_in,\n  output S,\n  output C_out\n);\n\nassign S = A ^ B ^ C_in;\nassign C_out = (A & B) | (A & C_in) | (B & C_in);\n\nendmodule\nmodule ripple_carry_adder #(\n  parameter n = 4 // number of bits in A and B\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output [n:0] C\n);\n\nwire [n:0] carry; // carry signals for each bit position\n\n// generate carry signals\ngenvar i;\ngenerate\n  for (i = 0; i < n; i = i + 1) begin : carry_gen\n    full_adder fa(\n      .A(A[i]),\n      .B(B[i]),\n      .C_in(carry[i]),\n      .S(C[i]),\n      .C_out(carry[i+1])\n    );\n  end\nendgenerate\n\n// set carry-in for least significant bit\nassign carry[0] = 1'b0;\n\n// assign output\nassign C[n] = carry[n];\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "a20165d25c7cdec0d340bbb35e15b7f4",
        "dataset_index": 17897
      },
      "register16_1d6292ac": {
        "rtl_code": "`ifndef _REGISTER\n`define _REGISTER\n\nmodule register16(clk, out, in, write, reset);  output reg [15:0] out;\n\tinput      [15:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 16'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register4(clk, out, in, write, reset);  output reg [3:0] out;\n\tinput      [3:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 4'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\nmodule register3(clk, out, in, write, reset);  output reg [2:0] out;\n\tinput      [2:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 3'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register2(clk, out, in, write, reset);  output reg [1:0] out;\n\tinput      [1:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 2'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register1(clk, out, in, write, reset);  output reg out;\n\tinput      in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 1'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n`endif\n",
        "module_name": "register16",
        "module_hash": "1d6292ace0642a1fa080fb1d416fa5b4",
        "dataset_index": 12760
      },
      "touch_sensor_bd165690": {
        "rtl_code": "\nmodule touch_sensor (\n  input wire touch_in,\n  output reg touch_out\n);\n\n  reg touch_detected;\n\n  always @(posedge touch_in) begin\n    touch_detected <= #1 touch_in;  // Delay the assignment by 1 time unit to avoid multiple edge sensitive events\n  end\n\n  always @(*) begin\n    touch_out = touch_detected;\n  end\n\nendmodule",
        "module_name": "touch_sensor",
        "module_hash": "bd165690e20fed3b64b39785764f3eb8",
        "dataset_index": 10887
      },
      "queue #_5ccc165c": {
        "rtl_code": "\nmodule queue #\n    (\n    parameter integer WIDTH = 108,\n    parameter integer LENGTH = 4\n    )\n    (\n    input wire GCLK,\n    input wire RES,\n    input wire get,\n    input wire put,\n    output reg full = 1'b0,\n    output reg empty = 1'b1,\n    input wire [WIDTH-1:0] DIN,\n    output reg [WIDTH-1:0] DOUT\n    );\n    \n    reg [WIDTH-1:0] q[0:LENGTH-1];\n    reg [63:0] head = 64'd0; reg get_release = 1'b1;\n    reg put_release = 1'b1;\n    \n    wire to_get;\n    wire to_put;\n    assign to_get = get & get_release;\n    assign to_put = put & put_release;\n\n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            get_release <= 1'b1;\n        end\n        else if (get == 1'b0) begin\n            get_release <= 1'b1;\n        end\n        else if (to_get == 1'b1) begin\n            get_release <= 1'b0;\n        end\n        \n        if (RES == 1'b1) begin\n            put_release <= 1'b1;\n        end\n        else if (put == 1'b0) begin\n            put_release <= 1'b1;\n        end\n        else if (to_put == 1'b1) begin\n            put_release <= 1'b0;\n        end\n    end\n\n    integer i = 0;\n    always @(posedge GCLK) begin\n        if (to_put & !to_get) begin\n            for (i = LENGTH - 1; i > 0; i = i - 1) begin\n                q[i] <= q[i - 1];\n            end\n            q[0] <= DIN;\n        end\n        \n        if (to_get &  !to_put & !empty) begin\n            DOUT <= q[head - 64'd1];\n        end\n        else if (to_get & to_put) begin\n            DOUT <= DIN;\n        end\n    end\n    \n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            head <= 64'd0;\n            full <= 1'b0;\n            empty <= 1'b1;\n        end\n        else if (!full & to_put & !to_get) begin\n            head <= head + 64'd1;\n            empty <= 1'b0; if (head == LENGTH - 1) begin\n                full <= 1'b1;\n            end\n        end\n        else if (!empty & to_get & !to_put) begin\n            head <= head - 64'd1;\n            full <= 1'b0; if (head == 64'd1) begin\n                empty <= 1'b1;\n            end\n        end\n        else begin\n            head <= head;\n            full <= full;\n            empty <= empty;\n        end\n    end\n    \n    \nendmodule\n",
        "module_name": "queue #",
        "module_hash": "5ccc165c2458eb5b3f0f007b17c80901",
        "dataset_index": 19882
      },
      "sky130_fd_sc_hvl__einvp_f48c6b19": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__einvp (\n    Z ,\n    A ,\n    TE\n);\n\n    output Z ;\n    input  A ;\n    input  TE;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    notif1 notif10 (Z     , A, TE          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__einvp",
        "module_hash": "f48c6b19bc0ddd181f77759d75bca5ac",
        "dataset_index": 5972
      },
      "lsu_wb_router_067ecd6b": {
        "rtl_code": "module lsu_wb_router \n(\n   out_sgpr_dest_addr, out_sgpr_dest_data, out_sgpr_dest_wr_en,\n   out_sgpr_instr_done, out_sgpr_instr_done_wfid, out_vgpr_dest_addr,\n   out_vgpr_dest_data, out_vgpr_dest_wr_en, out_vgpr_dest_wr_mask,\n   out_vgpr_instr_done, out_vgpr_instr_done_wfid,\n   out_tracemon_retire_pc, out_gm_or_lds, out_rfa_dest_wr_req,\n   in_rd_data, in_wftag_resp, in_ack, in_exec_value,\n   in_lddst_stsrc_addr, in_reg_wr_en, in_instr_pc, in_gm_or_lds\n   );\n\ninput [8191:0] in_rd_data;\ninput [6:0] in_wftag_resp;\ninput in_ack;\ninput [63:0] in_exec_value;\ninput [11:0] in_lddst_stsrc_addr;\ninput [3:0] in_reg_wr_en;\ninput [31:0] in_instr_pc;\ninput in_gm_or_lds;\n\noutput [8:0] out_sgpr_dest_addr;\noutput [127:0] out_sgpr_dest_data;\noutput [3:0] out_sgpr_dest_wr_en;\noutput out_sgpr_instr_done;\noutput [5:0] out_sgpr_instr_done_wfid;\n\noutput [9:0] out_vgpr_dest_addr;\noutput [8191:0] out_vgpr_dest_data;\noutput [3:0] out_vgpr_dest_wr_en;\noutput [63:0] out_vgpr_dest_wr_mask;\noutput out_vgpr_instr_done;\noutput [5:0] out_vgpr_instr_done_wfid;\n\noutput [31:0] out_tracemon_retire_pc;\noutput out_gm_or_lds;\n   output \t  out_rfa_dest_wr_req;\n\nreg [3:0] out_sgpr_dest_wr_en;\nreg [3:0] out_vgpr_dest_wr_en;\n   \nreg out_sgpr_instr_done;\nreg out_vgpr_instr_done;\n\nassign out_sgpr_dest_addr = in_lddst_stsrc_addr[8:0];\nassign out_sgpr_dest_data = in_rd_data[127:0];\nassign out_sgpr_instr_done_wfid = in_wftag_resp[6:1];\n\nassign out_vgpr_dest_addr = in_lddst_stsrc_addr[9:0];\nassign out_vgpr_dest_data = in_rd_data;\nassign out_vgpr_dest_wr_mask = in_exec_value;\nassign out_vgpr_instr_done_wfid = in_wftag_resp[6:1];\n\nassign out_tracemon_retire_pc = in_instr_pc;\nassign out_gm_or_lds = in_gm_or_lds;\n\nalways @* begin\n   casex({in_ack, in_wftag_resp[0], in_lddst_stsrc_addr[11:10]})\n   4'b0_?_??:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   4'b1_1_10:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= in_reg_wr_en;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b1;\n      end\n   4'b1_1_11:\n      begin\n         out_sgpr_dest_wr_en <= in_reg_wr_en;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b1;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   4'b1_0_10:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b1;\n      end\n   4'b1_0_11:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b1;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   4'b1_?_0?:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   default:\n      begin\n         out_sgpr_dest_wr_en <= 4'bx;\n         out_vgpr_dest_wr_en <= 4'bx;\n         out_sgpr_instr_done <= 1'bx;\n         out_vgpr_instr_done <= 1'bx;\n      end\n   endcase\nend\n\n   assign out_rfa_dest_wr_req = (|out_vgpr_dest_wr_en) | (|out_sgpr_dest_wr_en);\n\nendmodule\n",
        "module_name": "lsu_wb_router",
        "module_hash": "067ecd6bdc6395823b63ee541c9eeba0",
        "dataset_index": 25314
      },
      "and_or_xnor_vector_39243d83": {
        "rtl_code": "module and_or_xnor_vector (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [3:0] in,   // 4-bit input vector\n    input select,     // Select input to choose between AND/OR/XNOR gate and input vector splitter\n    output out_and,   // Output of the 4-input AND gate\n    output out_or,    // Output of the 4-input OR gate\n    output out_xnor,  // Output of the 4-input XNOR gate\n    output [2:0] outv // 3-bit vector that represents the input vector's positions 0, 1, and 2, respectively\n);\n\nwire [2:0] in_split;\nwire [3:0] and_or_xnor_in;\n\nand_or_xnor and_or_xnor_inst (\n    .in(and_or_xnor_in),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xnor(out_xnor)\n);\n\ninput_vector_splitter input_vector_splitter_inst (\n    .in(in),\n    .out(in_split)\n);\n\nassign and_or_xnor_in = select ? {in_split[2], in_split[1], in_split[0], in_split[0]} : {in[3], in[2], in[1], in[0]};\n\nassign outv[0] = in[0] & in[1] & in[2];\nassign outv[1] = ~in[0] & ~in[1] & ~in[2];\nassign outv[2] = {in[2], in[1], in[0]};\n\nendmodule\n\nmodule and_or_xnor (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xnor\n);\n\nassign out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xnor = ~(in[0] ^ in[1] ^ in[2] ^ in[3]);\n\nendmodule\n\nmodule input_vector_splitter (\n    input [3:0] in,\n    output [2:0] out\n);\n\nassign out[0] = in[0];\nassign out[1] = in[1];\nassign out[2] = in[2];\n\nendmodule",
        "module_name": "and_or_xnor_vector",
        "module_hash": "39243d83cb87774d51feab06fcaba471",
        "dataset_index": 1577
      },
      "fsm_sequence_detection_4ac8dead": {
        "rtl_code": "module fsm_sequence_detection (\n  input clk,\n  input reset,\n  input [7:0] data,\n  output reg match\n);\n\n  parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n  reg [1:0] state, next_state;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= S0;\n      match <= 1'b0;\n    end\n    else begin\n      state <= next_state;\n      match <= (state == S3);\n    end\n  end\n\n  always @(*) begin\n    next_state = state;\n    case(state)\n      S0: if (data[7:4] == 4'b1010) next_state = S1;\n      S1: if (data[7:4] == 4'b1010) next_state = S2;\n          else next_state = S0;\n      S2: if (data[7:4] == 4'b1010) next_state = S3;\n          else next_state = S0;\n      S3: next_state = S0;\n    endcase\n  end\n\nendmodule\n",
        "module_name": "fsm_sequence_detection",
        "module_hash": "4ac8dead00feb1cef194ed3f1904e83c",
        "dataset_index": 8131
      },
      "mux4_lut16_01bef06a": {
        "rtl_code": "module mux4_lut16 (\n    input I0,\n    input I1,\n    input I2,\n    input I3,\n    input S0,\n    input S1,\n    output reg O\n);\n\n    reg [15:0] lut;\n\n    always @* begin\n        case ({S1, S0})\n            2'b00: O = lut[0];\n            2'b01: O = lut[1];\n            2'b10: O = lut[2];\n            2'b11: O = lut[3];\n        endcase\n    end\n\n    always @* begin\n        lut[0] = I0;\n        lut[1] = I1;\n        lut[2] = I2;\n        lut[3] = I3;\n        lut[4] = I0;\n        lut[5] = I1;\n        lut[6] = I2;\n        lut[7] = I3;\n        lut[8] = I0;\n        lut[9] = I1;\n        lut[10] = I2;\n        lut[11] = I3;\n        lut[12] = I0;\n        lut[13] = I1;\n        lut[14] = I2;\n        lut[15] = I3;\n    end\n\nendmodule",
        "module_name": "mux4_lut16",
        "module_hash": "01bef06aded93278aba6865d595443d7",
        "dataset_index": 6564
      },
      "eth_rcr_unpack #_5d89ab97": {
        "rtl_code": "module eth_rcr_unpack #(parameter unpack_dst_addr = 48'hAABBCCDDEEFF)(\ninput    \t      i_axi_rx_clk,\ninput    \t      i_axi_rx_rst_n,\ninput    \t      i_rx_axis_fifo_tvalid,\ninput  [7:0]      i_rx_axis_fifo_tdata,\ninput             i_rx_axis_fifo_tlast,\noutput            o_rx_axis_fifo_tready,\noutput            o_axi_rx_clk,\noutput            o_axi_rx_rst_n,\noutput reg [7:0]  o_axi_rx_tdata,\noutput reg        o_axi_rx_data_tvalid,\ninput             i_axi_rx_data_tready,\noutput reg        o_axi_rx_data_tlast,\ninput             loop_back\n);\n\nassign o_axi_rx_clk   =   i_axi_rx_clk;\nassign o_axi_rx_rst_n =   i_axi_rx_rst_n;\nassign o_rx_axis_fifo_tready = i_axi_rx_data_tready;\n\nreg [3:0] pkt_len_cntr;\nreg [7:0] dest_addr [5:0];\nreg [47:0] destination_addr;\nreg state;\nreg no_filter;\n\nparameter idle       = 1'b0,\n          stream_pkt = 1'b1;\n \nalways @(posedge i_axi_rx_clk)\nbegin\n    if(~i_axi_rx_rst_n)\n\tbegin\n\t    o_axi_rx_data_tvalid   <=    1'b0;\n\t\tstate                  <=    idle;\n\t\tpkt_len_cntr           <=    4'd0;\n        o_axi_rx_tdata         <=    8'd0;\n        no_filter              <=    1'b0;\n        dest_addr[0]           <=    8'd0;\n        dest_addr[1]           <=    8'd0;\n        dest_addr[2]           <=    8'd0;\n        dest_addr[3]           <=    8'd0;\n        dest_addr[4]           <=    8'd0;\n        dest_addr[5]           <=    8'd0;\n        \n\tend\n\telse\n\tbegin\n\t    case(state)\n\t        idle:begin\n\t\t\t     o_axi_rx_data_tvalid <= 1'b0;\n\t\t\t\t  o_axi_rx_data_tlast  <= 1'b0;\n\t           if(i_rx_axis_fifo_tvalid & i_axi_rx_data_tready) begin\n\t\t            pkt_len_cntr <= pkt_len_cntr+1'b1;  if(pkt_len_cntr == 'd13)            begin\n                        if (((~loop_back) && (destination_addr == unpack_dst_addr)) || loop_back)\n\t\t\t\t            no_filter   <= 1'b1;\n                        else\n                            no_filter   <= 1'b0;\n\t\t\t\t        pkt_len_cntr <= 0;\t\n                        state <= stream_pkt;\n\t\t\t\t    end\t\n                    if(pkt_len_cntr < 'd6)\n                        dest_addr[pkt_len_cntr] <= i_rx_axis_fifo_tdata; end\n            end\n\t\t\tstream_pkt:begin\n\t\t\t   o_axi_rx_data_tvalid    <=    i_rx_axis_fifo_tvalid & no_filter;\n\t\t\t\to_axi_rx_tdata          <=    i_rx_axis_fifo_tdata;\n\t\t\t\to_axi_rx_data_tlast     <=    i_rx_axis_fifo_tlast & no_filter;\n\t\t\t\tif(i_rx_axis_fifo_tlast)\n\t\t\t\tbegin\n\t\t\t\t\tstate                  <=  idle;\n\t\t\t\tend\t\n\t\t\tend\n\t    endcase\n\tend\nend\n\nalways @(posedge i_axi_rx_clk)\nbegin\n    destination_addr <= {dest_addr[0],dest_addr[1],dest_addr[2],dest_addr[3],dest_addr[4],dest_addr[5]};\nend\t \n\nendmodule\n",
        "module_name": "eth_rcr_unpack #",
        "module_hash": "5d89ab97524fdd83c051271c08391c48",
        "dataset_index": 23991
      },
      "sparc_ifu_cmp35_5e09d448": {
        "rtl_code": "\nmodule sparc_ifu_cmp35(\n   hit, \n   a, b, valid\n   );\n\n   input [34:0] a, b;\n   input \tvalid;\n   \n   output \thit;\n\n   reg \t\thit;\n   wire \tvalid;\n   wire [34:0] \ta, b;\n\n   always @ (a or b or valid)\n     begin\n\tif ((a==b) & valid)\n\t  hit = 1'b1;\n\telse\n\t  hit = 1'b0;\n     end endmodule ",
        "module_name": "sparc_ifu_cmp35",
        "module_hash": "5e09d448075be3664defcec7cbe78ecd",
        "dataset_index": 19726
      },
      "sky130_fd_sc_hs__nand4bb_5bcf9a22": {
        "rtl_code": "\nmodule sky130_fd_sc_hs__nand4bb (\n    Y,\n    A_N,\n    B_N,\n    C,\n    D\n);\n\n    output Y;\n    input A_N;\n    input B_N;\n    input C;\n    input D;\n\n    assign Y = ~(A_N & B_N & C & D);\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hs__nand4bb",
        "module_hash": "5bcf9a22b3b3d8448f449a2a5b132aae",
        "dataset_index": 18580
      },
      "binary_counter_10d1591a": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count_out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_out <= 4'b0000;\n    end\n    else if (enable) begin\n      count_out <= count_out + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "10d1591a04adc136daf5212dc882a7ea",
        "dataset_index": 18888
      },
      "SPI_01d54bad": {
        "rtl_code": "\nmodule SPI\n( input Clk,\n  output reg MOSI,\n  input MISO,\n  output reg SCLK,\n  output reg SCE,\n  input Enable,\n  input Speed,             input [7:0] SendData,\n  input SendReq,\n  output reg SendAck,\n  output reg [7:0] RecvData,\n  output reg RecvAdv,\n  input RecvAck\n);\n\n  parameter real ClkPeriod = 20.0;\n  `define LO_SPEED_TICKS_UP\t$rtoi(((1.00 / 400000.00) / (ClkPeriod * 1.0E-9)) / 2.00)  \n  `define LO_SPEED_TICKS_DW\t($rtoi((1.00 / 400000.00) / (ClkPeriod * 1.0E-9)) - `LO_SPEED_TICKS_UP)\n  `define HI_SPEED_TICKS_UP\t$rtoi(((1.00 / 5000000.00) / (ClkPeriod * 1.0E-9)) / 2.00)  \n  `define HI_SPEED_TICKS_DW\t($rtoi((1.00 / 5000000.00) / (ClkPeriod * 1.0E-9)) - `HI_SPEED_TICKS_UP)\n\n  integer ClkCounter;\n  integer ClkStatus;\n  integer Counter;\n  reg [7:0] ShiftReg;\n\n  initial\n    begin\n\t   ClkCounter = 0;\n\t\tClkStatus = 0;\n\t\tMOSI = 1;\n\t\tSCLK = 0;\n\t\tSCE = 1;\n\t\tSendAck = 0;\n\t\tShiftReg = 8'hFF;\n\t end\n\t \n  always @(posedge Clk)\n    begin\n\t\tif (SendReq == 1) SendAck = 1; else begin end\n      if (RecvAck == 1) RecvAdv = 0; else begin end \n\t\tif (Enable == 0) SCE = 1; else begin end\n\t   case(ClkStatus)\n\t\t  0: begin\n\t\t       ClkCounter = 0;\n\t\t\t\t SCLK = 0;\n\t\t\t\t ClkStatus = 2;\n\t\t     end\n\t\t  1: begin\n\t\t       if (ClkCounter > 1) ClkCounter = ClkCounter - 1;\n\t\t\t    else begin\n\t\t\t\t        ClkCounter = (Speed == 0) ? `LO_SPEED_TICKS_DW : `HI_SPEED_TICKS_DW;\n\t\t\t\t\t\t  SCLK = 0;\n\t\t\t\t\t\t  ClkStatus = 2;\n\t\t\t\t\t\t  if (Enable == 1)\n\t\t\t\t\t\t    begin\n\t\t\t\t\t\t      if (SCE == 1)\n\t\t\t\t\t\t        begin\n\t\t\t\t\t\t\t       SCE = 0;\n\t\t\t\t\t\t\t\t    if (SendAck == 1)\n                              begin\n\t\t\t\t\t\t\t\t\t     ShiftReg = {SendData[6:0],1'b0};\n\t\t\t\t\t\t\t\t\t\t  MOSI = SendData[7];\n\t\t\t\t\t\t\t\t        SendAck = 0;\n                              end\n                            else \n\t\t\t\t\t\t\t\t\t   begin\n\t\t\t\t\t\t\t\t\t     ShiftReg = 8'b11111111;\n\t\t\t\t\t\t\t\t\t\t  MOSI = 1;\n\t\t\t\t\t\t\t\t\t\tend\n                            Counter = 7;\n\t\t\t\t\t\t\t     end\n\t\t\t\t\t\t      else\n\t\t\t\t\t\t        begin\n\t\t\t\t\t\t\t       if (Counter > 0) \n\t\t\t\t\t\t\t\t      begin\n\t\t\t\t\t\t\t\t        Counter = Counter - 1;\n\t\t\t\t\t\t\t\t\t     MOSI = ShiftReg[7];\n\t\t\t\t\t\t\t\t\t\t  ShiftReg = {ShiftReg[6:0],1'b0};\n\t\t\t\t\t\t\t\t      end\n\t\t\t\t\t\t\t\t    else\n\t\t\t\t\t\t\t\t      begin\n\t\t\t\t\t\t\t\t        if (SendAck == 1)\n                                  begin\n\t\t\t\t\t\t\t\t\t         ShiftReg = {SendData[6:0],1'b0};\n\t\t\t\t\t\t\t\t\t\t\t\tMOSI = SendData[7];\n\t\t\t\t\t\t\t\t            SendAck = 0;\n                                  end\n                                else\n                                  begin\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\t      ShiftReg = 8'b11111111;\n\t\t\t\t\t\t\t\t\t\t\t\tMOSI = 1;\n\t\t\t\t\t\t\t\t\t\t\t end\n                                Counter = 7;\n\t\t\t\t\t\t\t\t      end\n\t\t\t\t\t\t\t     end\n\t\t\t\t\t\t\t end\n                    else MOSI = 1;\t\t\t\t\t\t\t \n\t\t\t\t      end\n\t\t     end\n\t\t  2: begin\n\t\t       if (ClkCounter > 1) ClkCounter = ClkCounter - 1;\n\t\t\t    else begin\n\t\t\t\t        ClkCounter = (Speed == 0) ? `LO_SPEED_TICKS_UP : `HI_SPEED_TICKS_UP;\n\t\t\t\t\t\t  SCLK = 1;\n\t\t\t\t\t\t  ClkStatus = 1;\n  \t\t\t\t\t     if (SCE == 0) \n\t\t\t\t\t\t    begin\n\t\t\t\t\t\t\t   ShiftReg[0] = MISO;\n\t\t\t\t\t\t\t\tif (Counter == 0)\n\t\t\t\t\t\t\t\t  begin\n\t\t\t\t\t\t\t\t    RecvData = ShiftReg;\n\t\t\t\t\t\t\t\t\t RecvAdv = 1;\n\t\t\t\t\t\t\t\t  end\n\t\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\t     end\n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t  else begin\n\t\t\t\t\t\t       end\n\t\t\t\t      end\n\t\t     end\n\t\tendcase\n\t end\n\nendmodule\n",
        "module_name": "SPI",
        "module_hash": "01d54badf87ceb098d24e312c2a5ea12",
        "dataset_index": 21666
      },
      "clock_divider_c16cb311": {
        "rtl_code": "module clock_divider(input clk, input rst, output reg clk_out);\n\n\t//Lleva la cuenta de los ciclos de reloj transcurridos\n   reg [25:0] counter;\n\t\t\n\tinitial \n\t\tbegin\n\t\t\tcounter <= 26'd0;\n\t\t\tclk_out <= 1'b1;\n\t\tend\n\t\t\t\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tbegin\n\t\t\t\tcounter <= 26'd0;\n\t\t\t\tclk_out <= 1'b1; //reset output clock to 1\n\t\t\tend\t\n\t\telse\n\t\t\tif(counter == 26'd25000000) //convert 50 MHz to 1 Hz\n\t\t\t\tbegin\n\t\t\t\t\tcounter <= 26'd0;\n\t\t\t\t\tclk_out <= ~clk_out; //toggle output clock\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tcounter <= counter+1;\n\t\t\t\tend\n\tend\t\nendmodule",
        "module_name": "clock_divider",
        "module_hash": "c16cb311debea2ade7a5ff0e64a5dacc",
        "dataset_index": 9446
      },
      "k580wi53_114ad77c": {
        "rtl_code": "module k580wi53(input clk,\n\tinput c0, input c1, input c2,\n\tinput g0, input g1, input g2,\n\toutput out0, output out1, output out2,\n\tinput[1:0] addr, input rd, input we_n, input[7:0] idata, output reg[7:0] odata);\n\nwire[7:0] odata0;\nwire[7:0] odata1;\nwire[7:0] odata2;\n\nalways @(*)\n\tcase (addr)\n\t2'b00: odata = odata0;\n\t2'b01: odata = odata1;\n\t2'b10: odata = odata2;\n\t2'b11: odata = 0;\n\tendcase\n\nk580wi53channel ch0(.clk(clk), .c(c0), .gate(g0), .cout(out0), .addr(&addr), .rd(rd && addr==2'b00), .we_n(we_n || (addr!=2'b00 && (addr!=2'b11 || idata[7:6]!=2'b00))), .idata(idata), .odata(odata0));\nk580wi53channel ch1(.clk(clk), .c(c1), .gate(g1), .cout(out1), .addr(&addr), .rd(rd && addr==2'b01), .we_n(we_n || (addr!=2'b01 && (addr!=2'b11 || idata[7:6]!=2'b01))), .idata(idata), .odata(odata1));\nk580wi53channel ch2(.clk(clk), .c(c2), .gate(g2), .cout(out2), .addr(&addr), .rd(rd && addr==2'b10), .we_n(we_n || (addr!=2'b10 && (addr!=2'b11 || idata[7:6]!=2'b10))), .idata(idata), .odata(odata2));\n\nendmodule\n\nmodule k580wi53channel(input clk, input c, input gate, output reg cout,\n\tinput addr, input rd, input we_n, input[7:0] idata, output reg[7:0] odata);\n\nreg[5:0]  mode;\nreg[15:0] init;\nreg[15:0] cntlatch;\nreg[15:0] counter;\nreg[15:0] sub1;\nreg[15:0] sub2;\nreg enabled;\nreg latched;\nreg loaded;\nreg ff;\nreg first;\nreg done;\nreg exc;\nreg exgate;\nreg exrd;\nreg exwe_n;\n\nalways @(*)\n\tcase ({latched,ff})\n\t2'b00: odata = counter[7:0];\n\t2'b01: odata = counter[15:8];\n\t2'b10: odata = cntlatch[7:0];\n\t2'b11: odata = cntlatch[15:8];\n\tendcase\n\nalways @(*)\n\tcasex ({mode[0],|counter[15:12],|counter[11:8],|counter[7:4],|counter[3:0]})\n\t5'b10000: sub1 = 16'h9999;\n\t5'b11000: sub1 = 16'hF999;\n\t5'b1x100: sub1 = 16'hFF99;\n\t5'b1xx10: sub1 = 16'hFFF9;\n\tdefault:  sub1 = 16'hFFFF;\n\tendcase\n\nalways @(*)\n\tcasex ({mode[0],|counter[15:12],|counter[11:8],|counter[7:4],|counter[3:1]})\n\t5'b10000: sub2 = 16'h9998;\n\t5'b11000: sub2 = 16'hF998;\n\t5'b1x100: sub2 = 16'hFF98;\n\t5'b1xx10: sub2 = 16'hFFF8;\n\tdefault:  sub2 = 16'hFFFE;\n\tendcase\n\nwire[15:0] new1 = counter + (first|~&mode[2:1]?sub1:sub2);\nwire[15:0] newvalue = {new1[15:1],new1[0]&~&mode[2:1]};\n\nalways @(posedge clk)\nbegin\n\texc <= c; exgate <= gate; exrd <= rd; exwe_n <= we_n;\n\tif (enabled & c & ~exc) begin\n\t\tif (loaded) begin\n\t\t\tif (mode[2]==1'b1 && newvalue==0) begin\n\t\t\t\tcounter <= init;\n\t\t\t\tfirst <= init[0]&~cout;\n\t\t\tend else begin\n\t\t\t\tcounter <= newvalue;\n\t\t\t\tfirst <= 0;\n\t\t\tend\n\t\t\tif (newvalue[15:1]==0 && ~done) begin\n\t\t\t\tcasex ({mode[3:1],newvalue[0]})\n\t\t\t\t4'b0000: {cout,done} <= 2'b11;\n\t\t\t\t4'b0010: {cout,done} <= 2'b11;\n\t\t\t\t4'bx100: cout <= 1'b1;\n\t\t\t\t4'bx101: cout <= 0;\n\t\t\t\t4'bx11x: cout <= ~cout;\n\t\t\t\t4'b1000: {cout,done} <= 2'b11;\n\t\t\t\t4'b1001: cout <= 0;\n\t\t\t\t4'b1010: {cout,done} <= 2'b11;\n\t\t\t\t4'b1011: cout <= 0;\n\t\t\t\tendcase\n\t\t\tend\n\t\tend else begin\n\t\t\tcounter <= init; loaded <= 1'b1; first <= 1'b1; done <= 0;\n\t\t\tif (mode[3:2]==0) cout <= 0;\n\t\tend\n\tend\n\tif (exgate ^ gate) begin\n\t\tif (mode[2:1]!=2'b01) enabled <= gate;\n\t\telse if (gate) begin loaded <= 0; enabled <= 1; end\n\tend\n\tif (exrd & ~rd) begin\n\t\tif (mode[5:4]==2'b11) ff <= ~ff;\n\t\tif (mode[5:4]!=2'b11 || ff) latched <= 0;\n\tend else\n\tif (exwe_n & ~we_n) begin\n\t\tif (addr) begin\n\t\t\tif (idata[5:4]==0) begin\n\t\t\t\tcntlatch <= counter; latched <= 1;\n\t\t\tend else begin\n\t\t\t\tmode <= idata[5:0]; enabled <= 0; loaded <= 0; done <= 1'b1;\n\t\t\t\tlatched <= 0; cout <= idata[3:1]!=0;\n\t\t\tend\n\t\t\tff <= idata[5:4]==2'b10;\n\t\tend else begin\n\t\t\tcasex ({mode[5:4],ff})\n\t\t\t3'b01x: begin init <= {8'h00,idata}; enabled <= gate; ff <= 0; end\n\t\t\t3'b10x: begin init <= {idata,8'h00}; enabled <= gate; ff <= 1; end\n\t\t\t3'b110: begin init[7:0] <= idata; enabled <= 0; ff <= 1; end\n\t\t\t3'b111: begin init[15:8] <= idata; enabled <= gate; ff <= 0; end\n\t\t\tendcase\n\t\t\tloaded <= mode[2:1]!=0 & ~done;\n\t\t\tcout <= mode[3:1]!=0||(mode[5:4]==2'b01&&idata==8'b1);\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "k580wi53",
        "module_hash": "114ad77c781ede44dd7599385a2c3490",
        "dataset_index": 24214
      },
      "xor_8bit_cb32c49b": {
        "rtl_code": "module xor_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [7:0] C\n);\n\n  always @(*) begin\n    C[0] = A[0] ^ B[0];\n    C[1] = A[1] ^ B[1];\n    C[2] = A[2] ^ B[2];\n    C[3] = A[3] ^ B[3];\n    C[4] = A[4] ^ B[4];\n    C[5] = A[5] ^ B[5];\n    C[6] = A[6] ^ B[6];\n    C[7] = A[7] ^ B[7];\n  end\n\nendmodule",
        "module_name": "xor_8bit",
        "module_hash": "cb32c49bac3326b9d3e1edd79b720dbf",
        "dataset_index": 15964
      },
      "clock_gate_d_ff_en_W32_0_6_f7be7a94": {
        "rtl_code": "module clock_gate_d_ff_en_W32_0_6 (\n  input CLK, \n  input EN, \n  input TE, \n  input [31:0] DATA, \n  output reg ENCLK\n);\n\n  reg D;\n  always @(posedge CLK) begin\n    if (EN & !TE) begin\n      D <= DATA;\n    end\n  end\n\n  always @(posedge CLK) begin\n    if (TE) begin\n      ENCLK <= 0;\n    end else if (EN) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= 0;\n    end\n  end\n\nendmodule",
        "module_name": "clock_gate_d_ff_en_W32_0_6",
        "module_hash": "f7be7a9490487ee9c8d4d93df823da01",
        "dataset_index": 13423
      },
      "alu_d5e921e2": {
        "rtl_code": "module alu (A, B, BI, X, CO);\n  parameter A_SIGNED = 0;\n  parameter B_SIGNED = 0;\n  parameter A_WIDTH  = 1;\n  parameter B_WIDTH  = 1;\n  parameter Y_WIDTH  = 1;\n\n  input [A_WIDTH-1:0] A;\n  input [B_WIDTH-1:0] B;\n  input BI;\n  output [Y_WIDTH-1:0] X, CO;\n\n  wire [Y_WIDTH-1:0] sum = A + B;\n  wire [Y_WIDTH-1:0] diff = A - B;\n\n  assign X = BI ? diff : sum;\n\n  // Carry-out for addition\n  wire [Y_WIDTH:0] add_carry = {1'b0, sum};\n  assign CO = add_carry[Y_WIDTH];\n\n  // Borrow-out for subtraction\n  wire [Y_WIDTH:0] sub_borrow = {1'b0, diff};\n  assign CO = BI ? sub_borrow[Y_WIDTH] : CO;\nendmodule",
        "module_name": "alu",
        "module_hash": "d5e921e2d782f9b80ca19f398cd692b3",
        "dataset_index": 12739
      },
      "add_4bit_sat_73855c6f": {
        "rtl_code": "module add_4bit_sat (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Y\n);\n    \n    always @ (A or B) begin\n        Y = A + B;\n        if(Y > 4'b1111) begin\n            Y = 4'b1111;\n        end\n    end\n    \nendmodule",
        "module_name": "add_4bit_sat",
        "module_hash": "73855c6fb4a9958ed04ffe9527a77e7c",
        "dataset_index": 16169
      },
      "clock_divider_sim #_d0717966": {
        "rtl_code": "\nmodule clock_divider_sim #(\n    parameter DIVISOR = 2\n) (\n    input wire CLK,\n    output reg CLOCK\n);\n\ninteger cnt;\ninitial cnt = 0;\n\nwire [31:0] DIV;\nassign DIV = DIVISOR;\n\nalways @(posedge CLK)\n    if(cnt == DIVISOR -1)\n        cnt <= 0;\n    else\n        cnt <= cnt + 1;\n\ninitial CLOCK = 0;\n\nalways @(posedge CLK) begin\n    if (DIVISOR % 2 == 0) begin\n        if(cnt == DIVISOR/2-1) // posedge\n            CLOCK <= ~CLOCK;\n    end else begin\n        if(cnt == DIVISOR/2 && DIV[0] == 1) // posedge\n            CLOCK <= ~CLOCK;\n    end\n\n    if(cnt == DIVISOR-1) // posedge\n        CLOCK <= ~CLOCK;\nend\n\nendmodule",
        "module_name": "clock_divider_sim #",
        "module_hash": "d0717966178283f88bbf9ed8882f1aa5",
        "dataset_index": 10313
      },
      "RAM_DUAL_READ_PORT #_51e7b998": {
        "rtl_code": "\n\nmodule RAM_DUAL_READ_PORT # ( parameter DATA_WIDTH= 16, parameter ADDR_WIDTH=8, parameter MEM_SIZE=8 )\n(\n\tinput wire\t\t\t\t\t\tClock,\n\tinput wire\t\t\t\t\t\tiWriteEnable,\n\tinput wire[ADDR_WIDTH-1:0]\tiReadAddress0,\n\tinput wire[ADDR_WIDTH-1:0]\tiReadAddress1,\n\tinput wire[ADDR_WIDTH-1:0]\tiWriteAddress,\n\tinput wire[DATA_WIDTH-1:0]\t\t \tiDataIn,\n\toutput reg [DATA_WIDTH-1:0] \t\toDataOut0,\n\toutput reg [DATA_WIDTH-1:0] \t\toDataOut1\n);\n\nreg [DATA_WIDTH-1:0] Ram [MEM_SIZE:0];\t\t\n\nalways @(posedge Clock) \nbegin \n\t\n\t\tif (iWriteEnable) \n\t\t\tRam[iWriteAddress] <= iDataIn; \n\t\t\t\n\t\n\t\t\toDataOut0 <= Ram[iReadAddress0]; \n\t\t\toDataOut1 <= Ram[iReadAddress1]; \n\t\t\nend \nendmodule\n\nmodule RAM_SINGLE_READ_PORT # ( parameter DATA_WIDTH= 16, parameter ADDR_WIDTH=8, parameter MEM_SIZE=8 )\n(\n\tinput wire\t\t\t\t\t\tClock,\n\tinput wire\t\t\t\t\t\tiWriteEnable,\n\tinput wire[ADDR_WIDTH-1:0]\tiReadAddress,\n\tinput wire[ADDR_WIDTH-1:0]\tiWriteAddress,\n\tinput wire[DATA_WIDTH-1:0]\t\t \tiDataIn,\n\toutput reg [DATA_WIDTH-1:0] \t\toDataOut\n);\n\nreg [DATA_WIDTH-1:0] Ram [MEM_SIZE:0];\t\t\n\nalways @(posedge Clock) \nbegin \n\t\n\t\tif (iWriteEnable) \n\t\t\tRam[iWriteAddress] <= iDataIn; \n\t\t\t\n\t\n\t\t\toDataOut <= Ram[iReadAddress];\n\t\t\nend \nendmodule\n",
        "module_name": "RAM_DUAL_READ_PORT #",
        "module_hash": "51e7b9985185f1d7463aa18d7e2417e9",
        "dataset_index": 24330
      },
      "serial_tx #_f347dfeb": {
        "rtl_code": "module serial_tx #(\n        parameter CLK_PER_BIT = 50\n    )(\n        input clk,\n        input rst,\n        output tx,\n        input block,\n        output busy,\n        input [7:0] data,\n        input new_data\n    );\n\n    parameter CTR_SIZE = $clog2(CLK_PER_BIT);\n\n    localparam STATE_SIZE = 2;\n    localparam IDLE = 2'd0,\n    START_BIT = 2'd1,\n    DATA = 2'd2,\n    STOP_BIT = 2'd3;\n\n    reg [CTR_SIZE-1:0] ctr_d, ctr_q;\n    reg [2:0] bit_ctr_d, bit_ctr_q;\n    reg [7:0] data_d, data_q;\n    reg [STATE_SIZE-1:0] state_d, state_q = IDLE;\n    reg tx_d, tx_q;\n    reg busy_d, busy_q;\n    reg block_d, block_q;\n\n    assign tx = tx_q;\n    assign busy = busy_q;\n\n    always @(*) begin\n        block_d = block;\n        ctr_d = ctr_q;\n        bit_ctr_d = bit_ctr_q;\n        data_d = data_q;\n        state_d = state_q;\n        busy_d = busy_q;\n\n        case (state_q)\n            IDLE: begin\n                if (block_q) begin\n                    busy_d = 1'b1;\n                    tx_d = 1'b1;\n                end else begin\n                    busy_d = 1'b0;\n                    tx_d = 1'b1;\n                    bit_ctr_d = 3'b0;\n                    ctr_d = 1'b0;\n                    if (new_data) begin\n                        data_d = data;\n                        state_d = START_BIT;\n                        busy_d = 1'b1;\n                    end\n                end\n            end\n            START_BIT: begin\n                busy_d = 1'b1;\n                ctr_d = ctr_q + 1'b1;\n                tx_d = 1'b0;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    ctr_d = 1'b0;\n                    state_d = DATA;\n                end\n            end\n            DATA: begin\n                busy_d = 1'b1;\n                tx_d = data_q[bit_ctr_q];\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    ctr_d = 1'b0;\n                    bit_ctr_d = bit_ctr_q + 1'b1;\n                    if (bit_ctr_q == 7) begin\n                        state_d = STOP_BIT;\n                    end\n                end\n            end\n            STOP_BIT: begin\n                busy_d = 1'b1;\n                tx_d = 1'b1;\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    state_d = IDLE;\n                end\n            end\n            default: begin\n                state_d = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state_q <= IDLE;\n            tx_q <= 1'b1;\n        end else begin\n            state_q <= state_d;\n            tx_q <= tx_d;\n        end\n\n        block_q <= block_d;\n        data_q <= data_d;\n        bit_ctr_q <= bit_ctr_d;\n        ctr_q <= ctr_d;\n        busy_q <= busy_d;\n    end\n\nendmodule",
        "module_name": "serial_tx #",
        "module_hash": "f347dfeb745281e838119fe3f4bec357",
        "dataset_index": 25827
      },
      "divide_by12_2d8a779b": {
        "rtl_code": "\nmodule divide_by12(\n  input [5:0] numer,\n  output [2:0] quotient,\n  output [3:0] remain\n);\n\n  reg [2:0] quotient;\n  reg [3:0] remain_bit3_bit2;\n\n  assign remain = {remain_bit3_bit2, numer[1:0]}; // the first 2 bits are copied through\n\n  always @(numer[5:2]) // and just do a divide by \"3\" on the remaining bits\n    case(numer[5:2])\n      0: begin quotient=0; remain_bit3_bit2=0; end\n      1: begin quotient=0; remain_bit3_bit2=1; end\n      2: begin quotient=0; remain_bit3_bit2=2; end\n      3: begin quotient=1; remain_bit3_bit2=0; end\n      4: begin quotient=1; remain_bit3_bit2=1; end\n      5: begin quotient=1; remain_bit3_bit2=2; end\n      6: begin quotient=2; remain_bit3_bit2=0; end\n      7: begin quotient=2; remain_bit3_bit2=1; end\n      8: begin quotient=2; remain_bit3_bit2=2; end\n      9: begin quotient=3; remain_bit3_bit2=0; end\n      10: begin quotient=3; remain_bit3_bit2=1; end\n      11: begin quotient=3; remain_bit3_bit2=2; end\n      12: begin quotient=4; remain_bit3_bit2=0; end\n      13: begin quotient=4; remain_bit3_bit2=1; end\n      14: begin quotient=4; remain_bit3_bit2=2; end\n      15: begin quotient=5; remain_bit3_bit2=0; end\n    endcase\nendmodule",
        "module_name": "divide_by12",
        "module_hash": "2d8a779bad731d6ad4ce940465ab6835",
        "dataset_index": 8867
      },
      "TwosComplement_46a1f2e9": {
        "rtl_code": "module TwosComplement(input_num, twos_comp);\n\n   input [3:0] input_num;\n   output [3:0] twos_comp;\n\n   assign twos_comp = ~input_num + 1;\n\nendmodule",
        "module_name": "TwosComplement",
        "module_hash": "46a1f2e941f7aa2ad35dab268f8fac6b",
        "dataset_index": 7309
      },
      "tmu2_fifo64to256 #_945859c3": {
        "rtl_code": "\n\nmodule tmu2_fifo64to256 #(\n\tparameter depth = 2 \n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\toutput w8avail,\n\tinput we,\n\tinput [63:0] wd,\n\t\n\toutput ravail,\n\tinput re,\n\toutput [255:0] rd\n);\n\nreg [63:0] storage1[0:(1 << depth)-1];\nreg [63:0] storage2[0:(1 << depth)-1];\nreg [63:0] storage3[0:(1 << depth)-1];\nreg [63:0] storage4[0:(1 << depth)-1];\n\nreg [depth+2:0] level;\nreg [depth+1:0] produce;\nreg [depth-1:0] consume;\n\nwire wavail = ~level[depth+2];\nassign w8avail = level < ((1 << (depth + 2)) - 8);\nassign ravail = |(level[depth+2:2]);\n\nwire read = re & ravail;\nwire write = we & wavail;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tlevel <= 0;\n\t\tproduce <= 0;\n\t\tconsume <= 0;\n\tend else begin\n\t\tif(read)\n\t\t\tconsume <= consume + 1;\n\t\tif(write) begin\n\t\t\tproduce <= produce + 1;\n\t\t\tcase(produce[1:0])\n\t\t\t\t2'd0: storage1[produce[depth+1:2]] <= wd;\n\t\t\t\t2'd1: storage2[produce[depth+1:2]] <= wd;\n\t\t\t\t2'd2: storage3[produce[depth+1:2]] <= wd;\n\t\t\t\t2'd3: storage4[produce[depth+1:2]] <= wd;\n\t\t\tendcase\n\t\tend\n\t\tcase({read, write})\n\t\t\t2'b10: level <= level - 4;\n\t\t\t2'b01: level <= level + 1;\n\t\t\t2'b11: level <= level - 3;\n\t\tendcase\n\tend\nend\n\nassign rd = {storage1[consume], storage2[consume], storage3[consume], storage4[consume]};\n\nendmodule\n",
        "module_name": "tmu2_fifo64to256 #",
        "module_hash": "945859c3510fe45d5ca65c8388f33e5f",
        "dataset_index": 24286
      },
      "binary_counter_dc69b239": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input rst,\n    input en,\n    input ld,\n    input [3:0] load_data,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'b0000;\n        end else if (en) begin\n            if (ld) begin\n                count <= load_data;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "dc69b239e03610c2568822bcb5bdc561",
        "dataset_index": 717
      },
      "johnson_counter_936ef2c2": {
        "rtl_code": "\nmodule johnson_counter (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-low reset\n    output reg [3:0] out    // 4-bit output\n);\n\nreg [2:0] state = 3'b000;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b000;\n    end else begin\n        case (state)\n            3'b000: state <= 3'b100;\n            3'b100: state <= 3'b110;\n            3'b110: state <= 3'b111;\n            3'b111: state <= 3'b011;\n            3'b011: state <= 3'b001;\n            3'b001: state <= 3'b000;\n            default: state <= 3'b000;\n        endcase\n    end\n    out <= {state[2], state[1], state[0], out[3]};\nend\n\nendmodule\nmodule half_word_comb (\n    input [7:0] in_hi,      // Upper byte input\n    input [7:0] in_lo,      // Lower byte input\n    output reg [15:0] out   // 16-bit output\n);\n\nalways @(*) begin\n    out = {in_hi, in_lo};\nend\n\nendmodule\nmodule top_module (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-low reset\n    input [7:0] in_hi,      // Upper byte input\n    input [7:0] in_lo,      // Lower byte input\n    output reg [79:0] out   // 80-bit output\n);\n\nwire [3:0] johnson_out;\nwire [15:0] half_word_out;\n\njohnson_counter jc (\n    .clk(clk),\n    .reset(reset),\n    .out(johnson_out)\n);\n\nhalf_word_comb hw (\n    .in_hi(in_hi),\n    .in_lo(in_lo),\n    .out(half_word_out)\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 80'b0;\n    end else begin\n        out <= {half_word_out, johnson_out};\n    end\nend\n\nendmodule",
        "module_name": "johnson_counter",
        "module_hash": "936ef2c23f937cf3749dbfd76f62b1c7",
        "dataset_index": 14836
      },
      "top__9a42c0a3": {
        "rtl_code": "\nmodule top_module (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output signed [3:0] out,\n    output eq,\n    output gt,\n    output lt,\n    output overflow\n);\n\n    wire signed [3:0] sum;\n    wire overflow_adder;\n    signed_comparator comp(A, B, eq, gt, lt);\n    signed_adder adder(A, B, sum, overflow_adder);\n\n    assign overflow = overflow_adder;\n\n    assign out = (eq) ? sum : (gt) ? A : B;\n\nendmodule\n\nmodule signed_adder (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output signed [3:0] out,\n    output overflow\n);\n\n    wire [3:0] sum;\n    wire carry;\n\n    assign overflow = (A[3] == B[3] && sum[3] != A[3]) ? 1 : 0;\n\n    assign {carry, sum} = A + B;\n\n    assign out = {overflow, sum};\n\nendmodule\n\nmodule signed_comparator (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output eq,\n    output gt,\n    output lt\n);\n\n    assign eq = (A == B);\n\n    assign gt = (A > B);\n\n    assign lt = (A < B);\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "9a42c0a3aeba6fd5bca9c0e7b7f18ff0",
        "dataset_index": 3450
      },
      "gray_code_state_machine_1befa46b": {
        "rtl_code": "\nmodule gray_code_state_machine (\n  input [n-1:0] state,\n  input clk,\n  output [n-1:0] next_state\n);\n\nparameter n = 3; // number of bits in the state\n\n// Define the Gray code states\nreg [n-1:0] gray_states [0:2**n-1];\ninteger i;\ninitial begin\n  for (i = 0; i < 2**n; i = i + 1) begin\n    gray_states[i] = i ^ (i >> 1);\n  end\nend\n\n// Define the Gray code state transition table\nreg [n-1:0] gray_transition_table [0:2**n-1][0:1];\ninitial begin\n  gray_transition_table[0][0] = 'h1;\n  gray_transition_table[0][1] = 'h2;\n  gray_transition_table[1][0] = 'h3;\n  gray_transition_table[1][1] = 'h0;\n  gray_transition_table[2][0] = 'h6;\n  gray_transition_table[2][1] = 'h7;\n  gray_transition_table[3][0] = 'h5;\n  gray_transition_table[3][1] = 'h4;\n  gray_transition_table[4][0] = 'h4;\n  gray_transition_table[4][1] = 'h5;\n  gray_transition_table[5][0] = 'h7;\n  gray_transition_table[5][1] = 'h6;\n  gray_transition_table[6][0] = 'h2;\n  gray_transition_table[6][1] = 'h1;\n  gray_transition_table[7][0] = 'h0;\n  gray_transition_table[7][1] = 'h3;\nend\n\n// Compute the next state based on the current state and the clock signal\nreg [n-1:0] next_state_reg;\nalways @(posedge clk) begin\n  next_state_reg <= gray_transition_table[state][1];\nend\n\n// Assign the output to the next state register\nassign next_state = next_state_reg;\n\nendmodule",
        "module_name": "gray_code_state_machine",
        "module_hash": "1befa46b9821f551c330df6748d6fcb1",
        "dataset_index": 10932
      },
      "line_reader #_8a177b38": {
        "rtl_code": "\n\nmodule line_reader #\n(\n\tparameter integer C_IMG_WBITS\t= 12,\n\tparameter integer C_WRITE_INDEX_BITS = 10,\n\n\tparameter integer C_M_AXI_BURST_LEN\t= 16,\n\tparameter integer C_M_AXI_ADDR_WIDTH\t= 32,\n\tparameter integer C_M_AXI_DATA_WIDTH\t= 32\n)\n(\n\tinput wire [C_IMG_WBITS-1:0] img_width,\n\n\tinput wire sol,\n\tinput wire [C_M_AXI_ADDR_WIDTH-1 : 0] line_addr,\n\n\toutput wire end_of_line_pulse,\n\toutput wire [C_M_AXI_DATA_WIDTH-1 : 0] wr_data,\n\toutput wire [C_WRITE_INDEX_BITS-1 : 0] wr_addr,\n\toutput wire wr_en,\n\n\tinput wire  M_AXI_ACLK,\n\tinput wire  M_AXI_ARESETN,\n\n\toutput wire [C_M_AXI_ADDR_WIDTH-1 : 0] M_AXI_ARADDR,\n\toutput wire [7 : 0] M_AXI_ARLEN,\n\toutput wire [2 : 0] M_AXI_ARSIZE,\n\toutput wire [1 : 0] M_AXI_ARBURST,\n\toutput wire  M_AXI_ARLOCK,\n\toutput wire [3 : 0] M_AXI_ARCACHE,\n\toutput wire [2 : 0] M_AXI_ARPROT,\n\toutput wire [3 : 0] M_AXI_ARQOS,\n\toutput wire  M_AXI_ARVALID,\n\tinput wire  M_AXI_ARREADY,\n\n\tinput wire [C_M_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA,\n\tinput wire [1 : 0] M_AXI_RRESP,\n\tinput wire  M_AXI_RLAST,\n\tinput wire  M_AXI_RVALID,\n\toutput wire  M_AXI_RREADY\n);\n\n\tfunction integer clogb2 (input integer bit_depth);\n\tbegin\n\t\tfor(clogb2=0; bit_depth>0; clogb2=clogb2+1)\n\t\t\tbit_depth = bit_depth >> 1;\n\tend\n\tendfunction\n\n\tlocalparam integer C_ADATA_PIXELS = 2**(C_IMG_WBITS - C_WRITE_INDEX_BITS);\n\tlocalparam integer C_TRANSACTIONS_NUM = clogb2(C_M_AXI_BURST_LEN-1);\n\tlocalparam integer C_BURST_SIZE_BYTES\t= C_M_AXI_BURST_LEN * C_M_AXI_DATA_WIDTH/8;\n\n\treg [C_M_AXI_ADDR_WIDTH-1 : 0] \taxi_araddr;\n\treg  \taxi_arvalid;\n\treg  \tstart_burst_pulse;\n\treg  \tburst_read_active;\n\treg [C_TRANSACTIONS_NUM-1:0] next_burst_len;\n\twire\tburst_done;\n\twire  \tread_resp_error;\n\twire  \trnext;\n\n\treg\tsol_d1;\n\treg\tlining;\n\treg\tr_eol;\n\treg [C_IMG_WBITS-1 : 0] r_img_col_idx;\n\treg [C_WRITE_INDEX_BITS-1 : 0] r_wr_addr;\n\n\tassign wr_data\t\t= M_AXI_RDATA;\n\tassign rnext \t\t= M_AXI_RVALID && M_AXI_RREADY;\n\tassign wr_en\t\t= rnext;\n\tassign wr_addr\t\t= r_wr_addr;\n\n\tassign M_AXI_ARADDR\t= axi_araddr;\n\tassign M_AXI_ARLEN\t= next_burst_len;\n\tassign M_AXI_ARSIZE\t= clogb2((C_M_AXI_DATA_WIDTH/8)-1);\n\tassign M_AXI_ARBURST\t= 2'b01;\n\tassign M_AXI_ARLOCK\t= 1'b0;\n\tassign M_AXI_ARCACHE\t= 4'b0000;\n\tassign M_AXI_ARPROT\t= 3'h0;\n\tassign M_AXI_ARQOS\t= 4'h0;\n\tassign M_AXI_ARVALID\t= axi_arvalid;\n\tassign M_AXI_RREADY\t= burst_read_active;\n\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\taxi_arvalid <= 1'b0;\n\t\tend\n\t\telse if (start_burst_pulse) begin\n\t\t\taxi_arvalid <= 1'b1;\n\t\tend\n\t\telse if (M_AXI_ARREADY) begin\n\t\t\taxi_arvalid <= 1'b0;\n\t\tend\n\tend\n\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\taxi_araddr <= 'b0;\n\t\tend\n\t\telse if (sol) begin\n\t\t\taxi_araddr <= line_addr;\n\t\tend\n\t\telse if (burst_done) begin\n\t\t\taxi_araddr <= axi_araddr + C_BURST_SIZE_BYTES;\n\t\tend\n\tend\n\n\n\tassign read_resp_error = M_AXI_RREADY & M_AXI_RVALID & M_AXI_RRESP[1];\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 1'b0)\n\t\t\tstart_burst_pulse <= 1'b0;\n\t\telse if (start_burst_pulse)\n\t\t\tstart_burst_pulse <= 0;\n\t\telse if (lining && ~burst_read_active)\n\t\t\tstart_burst_pulse <= 1'b1;\n\tend\n\n\tassign burst_done = (rnext && M_AXI_RLAST);\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0)\n\t\t\tburst_read_active <= 1'b0;\n\t\telse if (start_burst_pulse)\n\t\t\tburst_read_active <= 1'b1;\n\t\telse if (burst_done)\n\t\t\tburst_read_active <= 0;\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 1'b0) begin\n\t\t\tnext_burst_len <= 0;\n\t\tend\n\t\telse if (sol_d1 || burst_done) begin\n\t\t\tif (r_img_col_idx >= C_M_AXI_BURST_LEN * C_ADATA_PIXELS)\n\t\t\t\tnext_burst_len <= C_M_AXI_BURST_LEN - 1;\n\t\t\telse\n\t\t\t\tnext_burst_len <= r_img_col_idx / C_ADATA_PIXELS - 1;\n\t\tend\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tr_img_col_idx <= 0;\n\t\tend\n\t\telse if (sol) begin\n\t\t\tr_img_col_idx <= img_width - C_ADATA_PIXELS;\n\t\tend\n\t\telse if (rnext) begin\n\t\t\tif (!r_eol) begin\n\t\t\t\tr_img_col_idx <= r_img_col_idx - C_ADATA_PIXELS;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tr_wr_addr <= 0;\n\t\tend\n\t\telse if (sol) begin\n\t\t\tr_wr_addr <= 0;\n\t\tend\n\t\telse if (rnext) begin\n\t\t\tr_wr_addr <= r_wr_addr + 1;\n\t\tend\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tsol_d1 <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tsol_d1 <= sol;\n\t\tend\n\tend\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tlining <= 0;\n\t\tend\n\t\telse if (sol_d1) begin\n\t\t\tlining <= 1;\n\t\tend\n\t\telse if (burst_done && r_eol) begin\n\t\t\tlining <= 0;\n\t\tend\n\tend\n\treg lining_d1;\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0)\n\t\t\tlining_d1 <= 0;\n\t\telse\n\t\t\tlining_d1 <= lining;\n\tend\n\tassign end_of_line_pulse = (lining_d1 && ~lining);\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tr_eol <= 1'b1;\n\t\tend\n\t\telse if (sol) begin\n\t\t\tr_eol <= 1'b0;\n\t\tend\n\t\telse if (rnext) begin\n\t\t\tif (r_img_col_idx == C_ADATA_PIXELS) begin\n\t\t\t\tr_eol <= 1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "line_reader #",
        "module_hash": "8a177b38d1d05b39b568d7b4627ad4ac",
        "dataset_index": 22908
      },
      "sync_reset #_b37e8213": {
        "rtl_code": "\n\n\nmodule sync_reset #\n(\n    parameter N = 2\n)\n(\n    input  wire clk,\n    input  wire rst,\n    output wire out\n);\n\n\nreg [N-1:0] sync_reg = {N{1'b1}};\n\nassign out = sync_reg[N-1];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sync_reg <= {N{1'b1}};\n    end else begin\n        sync_reg <= {sync_reg[N-2:0], 1'b0};\n    end\nend\n\nendmodule\n",
        "module_name": "sync_reset #",
        "module_hash": "b37e821355e003b14bdaae13615c4465",
        "dataset_index": 11112
      },
      "mux_2to1_62a7dd75": {
        "rtl_code": "module mux_2to1 (\n    input A,\n    input B,\n    input SEL,\n    output Y,\n    input VPWR,\n    input VGND\n);\n\n    wire not_sel;\n    wire and1_out;\n    wire and2_out;\n\n    sky130_fd_sc_lp__not_1 not_gate_inst(\n        .A(SEL),\n        .X(not_sel),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\n    sky130_fd_sc_lp__and2_1 and1_gate_inst(\n        .A(A),\n        .B(not_sel),\n        .X(and1_out),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\n    sky130_fd_sc_lp__and2_1 and2_gate_inst(\n        .A(B),\n        .B(SEL),\n        .X(and2_out),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\n    assign Y = and1_out | and2_out;\n\nendmodule\n\nmodule sky130_fd_sc_lp__not_1 (\n    input A,\n    output X,\n    input VPWR,\n    input VGND\n);\n\n    assign X = ~A;\n\nendmodule\n\nmodule sky130_fd_sc_lp__and2_1 (\n    input A,\n    input B,\n    output X,\n    input VPWR,\n    input VGND\n);\n\n    assign X = A & B;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "62a7dd7575765452f3cc0a070c593ad9",
        "dataset_index": 5570
      },
      "sky130_fd_sc_ms__xor3_df9eac30": {
        "rtl_code": "module sky130_fd_sc_ms__xor3 (\n  input A,\n  input B,\n  input C,\n  output X\n);\n\n  wire wire1;\n  wire wire2;\n  \n  assign wire1 = A ^ B;\n  assign wire2 = wire1 ^ C;\n  assign X = ~wire2;\n\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__xor3",
        "module_hash": "df9eac304feb87ce79731cbf92ef6fdd",
        "dataset_index": 16859
      },
      "feedforward_p_uOut_ram_1f5c6b58": {
        "rtl_code": "\nmodule feedforward_p_uOut_ram (addr0, ce0, d0, we0, q0, addr1, ce1, q1,  clk);\n\nparameter DWIDTH = 64;\nparameter AWIDTH = 8;\nparameter MEM_SIZE = 140;\n\ninput[AWIDTH-1:0] addr0;\ninput ce0;\ninput[DWIDTH-1:0] d0;\ninput we0;\noutput reg[DWIDTH-1:0] q0;\ninput[AWIDTH-1:0] addr1;\ninput ce1;\noutput reg[DWIDTH-1:0] q1;\ninput clk;\n\nreg [DWIDTH-1:0] ram[MEM_SIZE-1:0];\n\n\n\n\nalways @(posedge clk)  \nbegin \n    if (ce0) \n    begin\n        if (we0) \n        begin \n            ram[addr0] <= d0; \n            q0 <= d0;\n        end \n        else \n            q0 <= ram[addr0];\n    end\nend\n\n\nalways @(posedge clk)  \nbegin \n    if (ce1) \n    begin\n            q1 <= ram[addr1];\n    end\nend\n\n\nendmodule\n\nmodule feedforward_p_uOut(\n    reset,\n    clk,\n    address0,\n    ce0,\n    we0,\n    d0,\n    q0,\n    address1,\n    ce1,\n    q1);\n\nparameter DataWidth = 32'd64;\nparameter AddressRange = 32'd140;\nparameter AddressWidth = 32'd8;\ninput reset;\ninput clk;\ninput[AddressWidth - 1:0] address0;\ninput ce0;\ninput we0;\ninput[DataWidth - 1:0] d0;\noutput[DataWidth - 1:0] q0;\ninput[AddressWidth - 1:0] address1;\ninput ce1;\noutput[DataWidth - 1:0] q1;\n\n\n\nfeedforward_p_uOut_ram feedforward_p_uOut_ram_U(\n    .clk( clk ),\n    .addr0( address0 ),\n    .ce0( ce0 ),\n    .d0( d0 ),\n    .we0( we0 ),\n    .q0( q0 ),\n    .addr1( address1 ),\n    .ce1( ce1 ),\n    .q1( q1 ));\n\nendmodule\n\n",
        "module_name": "feedforward_p_uOut_ram",
        "module_hash": "1f5c6b589c1e6ea8c8d7d10f31eb2d11",
        "dataset_index": 24002
      },
      "pcie_rx_req #_af6329cc": {
        "rtl_code": "\n\nmodule pcie_rx_req # (\n\tparameter\tP_PCIE_DATA_WIDTH\t\t\t= 128,\n\tparameter\tC_PCIE_ADDR_WIDTH\t\t\t= 36\n)\n(\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\n\tinput\t[2:0]\t\t\t\t\t\t\tpcie_max_read_req_size,\n\n\toutput\t\t\t\t\t\t\t\t\tpcie_rx_cmd_rd_en,\n\tinput\t[33:0]\t\t\t\t\t\t\tpcie_rx_cmd_rd_data,\n\tinput\t\t\t\t\t\t\t\t\tpcie_rx_cmd_empty_n,\n\n\toutput\t\t\t\t\t\t\t\t\tpcie_tag_alloc,\n\toutput\t[7:0]\t\t\t\t\t\t\tpcie_alloc_tag,\n\toutput\t[9:4]\t\t\t\t\t\t\tpcie_tag_alloc_len,\n\tinput\t\t\t\t\t\t\t\t\tpcie_tag_full_n,\n\tinput\t\t\t\t\t\t\t\t\tpcie_rx_fifo_full_n,\n\n\toutput\t\t\t\t\t\t\t\t\ttx_dma_mrd_req,\n\toutput\t[7:0]\t\t\t\t\t\t\ttx_dma_mrd_tag,\n\toutput\t[11:2]\t\t\t\t\t\t\ttx_dma_mrd_len,\n\toutput\t[C_PCIE_ADDR_WIDTH-1:2]\t\t\ttx_dma_mrd_addr,\n\tinput\t\t\t\t\t\t\t\t\ttx_dma_mrd_req_ack\n);\n\nlocalparam\tLP_PCIE_TAG_PREFIX\t\t\t\t= 4'b0001;\nlocalparam\tLP_PCIE_MRD_DELAY\t\t\t\t= 8;\n\nlocalparam\tS_IDLE\t\t\t\t\t\t\t= 9'b000000001;\nlocalparam\tS_PCIE_RX_CMD_0\t\t\t\t\t= 9'b000000010;\nlocalparam\tS_PCIE_RX_CMD_1\t\t\t\t\t= 9'b000000100;\nlocalparam\tS_PCIE_CHK_NUM_MRD\t\t\t\t= 9'b000001000;\nlocalparam\tS_PCIE_MRD_REQ\t\t\t\t\t= 9'b000010000;\nlocalparam\tS_PCIE_MRD_ACK\t\t\t\t\t= 9'b000100000;\nlocalparam\tS_PCIE_MRD_DONE\t\t\t\t\t= 9'b001000000;\nlocalparam\tS_PCIE_MRD_DELAY\t\t\t\t= 9'b010000000;\nlocalparam\tS_PCIE_MRD_NEXT\t\t\t\t\t= 9'b100000000;\n\n\nreg\t\t[8:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[8:0]\t\t\t\t\t\t\t\tnext_state;\n\nreg\t\t[2:0]\t\t\t\t\t\t\t\tr_pcie_max_read_req_size;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_rx_cmd_rd_en;\n\nreg\t\t[12:2]\t\t\t\t\t\t\t\tr_pcie_rx_len;\nreg\t\t[9:2]\t\t\t\t\t\t\t\tr_pcie_rx_cur_len;\nreg\t\t[C_PCIE_ADDR_WIDTH-1:2]\t\t\t\tr_pcie_addr;\nreg\t\t[3:0]\t\t\t\t\t\t\t\tr_pcie_rx_tag;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_rx_tag_update;\nreg\t\t[5:0]\t\t\t\t\t\t\t\tr_pcie_mrd_delay;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_tag_alloc;\nreg\t\t\t\t\t\t\t\t\t\t\tr_tx_dma_mrd_req;\n\nassign pcie_rx_cmd_rd_en = r_pcie_rx_cmd_rd_en;\n\nassign pcie_tag_alloc = r_pcie_tag_alloc;\nassign pcie_alloc_tag = {LP_PCIE_TAG_PREFIX, r_pcie_rx_tag};\nassign pcie_tag_alloc_len = r_pcie_rx_cur_len[9:4];\n\nassign tx_dma_mrd_req = r_tx_dma_mrd_req;\nassign tx_dma_mrd_tag = {LP_PCIE_TAG_PREFIX, r_pcie_rx_tag};\nassign tx_dma_mrd_len = {2'b0, r_pcie_rx_cur_len};\nassign tx_dma_mrd_addr = r_pcie_addr;\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0)\n\t\tcur_state <= S_IDLE;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tif(pcie_rx_cmd_empty_n == 1)\n\t\t\t\tnext_state <= S_PCIE_RX_CMD_0;\n\t\t\telse\n\t\t\t\tnext_state <= S_IDLE;\n\t\tend\n\t\tS_PCIE_RX_CMD_0: begin\n\t\t\tnext_state <= S_PCIE_RX_CMD_1;\n\t\tend\n\t\tS_PCIE_RX_CMD_1: begin\n\t\t\tnext_state <= S_PCIE_CHK_NUM_MRD;\n\t\tend\n\t\tS_PCIE_CHK_NUM_MRD: begin\n\t\t\tif(pcie_rx_fifo_full_n == 1 && pcie_tag_full_n == 1)\n\t\t\t\tnext_state <= S_PCIE_MRD_REQ;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_CHK_NUM_MRD;\n\t\tend\n\t\tS_PCIE_MRD_REQ: begin\n\t\t\tnext_state <= S_PCIE_MRD_ACK;\n\t\tend\n\t\tS_PCIE_MRD_ACK: begin\n\t\t\tif(tx_dma_mrd_req_ack == 1)\n\t\t\t\tnext_state <= S_PCIE_MRD_DONE;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_MRD_ACK;\n\t\tend\n\t\tS_PCIE_MRD_DONE: begin\n\t\t\tnext_state <= S_PCIE_MRD_DELAY;\n\t\tend\n\t\tS_PCIE_MRD_DELAY: begin\n\t\t\tif(r_pcie_mrd_delay == 0)\n\t\t\t\tnext_state <= S_PCIE_MRD_NEXT;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_MRD_DELAY;\n\t\tend\n\t\tS_PCIE_MRD_NEXT: begin\n\t\t\tif(r_pcie_rx_len == 0)\n\t\t\t\tnext_state <= S_IDLE;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_CHK_NUM_MRD;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_IDLE;\n\t\tend\n\tendcase\nend\n\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_pcie_rx_tag <= 0;\n\tend\n\telse begin\n\t\tif(r_pcie_rx_tag_update == 1)\n\t\t\tr_pcie_rx_tag <= r_pcie_rx_tag + 1;\n\tend\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_pcie_max_read_req_size <= pcie_max_read_req_size;\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\n\t\tend\n\t\tS_PCIE_RX_CMD_0: begin\n\t\t\tr_pcie_rx_len <= {pcie_rx_cmd_rd_data[10:2], 2'b0};\n\t\tend\n\t\tS_PCIE_RX_CMD_1: begin\n\t\t\tcase(r_pcie_max_read_req_size)\n\t\t\t\t3'b010: begin\n\t\t\t\t\tif(r_pcie_rx_len[8:7] == 0 && r_pcie_rx_len[6:2] == 0)\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b100;\n\t\t\t\t\telse\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= {1'b0, r_pcie_rx_len[8:7]};\n\t\t\t\tend\n\t\t\t\t3'b001: begin\n\t\t\t\t\tif(r_pcie_rx_len[7] == 0 && r_pcie_rx_len[6:2] == 0)\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b010;\n\t\t\t\t\telse\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= {2'b0, r_pcie_rx_len[7]};\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tif(r_pcie_rx_len[6:2] == 0)\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b001;\n\t\t\t\t\telse\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b000;\n\t\t\t\tend\n\t\t\tendcase\n\n\t\t\tr_pcie_rx_cur_len[6:2] <= r_pcie_rx_len[6:2];\n\t\t\tr_pcie_addr <= {pcie_rx_cmd_rd_data[33:2], 2'b0};\n\t\tend\n\t\tS_PCIE_CHK_NUM_MRD: begin\n\n\t\tend\n\t\tS_PCIE_MRD_REQ: begin\n\n\t\tend\n\t\tS_PCIE_MRD_ACK: begin\n\n\t\tend\n\t\tS_PCIE_MRD_DONE: begin\n\t\t\tr_pcie_addr <= r_pcie_addr + r_pcie_rx_cur_len;\n\t\t\tr_pcie_rx_len <= r_pcie_rx_len - r_pcie_rx_cur_len;\n\n\t\t\tcase(r_pcie_max_read_req_size)\n\t\t\t\t3'b010: r_pcie_rx_cur_len <= 8'h80;\n\t\t\t\t3'b001: r_pcie_rx_cur_len <= 8'h40;\n\t\t\t\tdefault: r_pcie_rx_cur_len <= 8'h20;\n\t\t\tendcase\n\t\t\t\n\t\t\tr_pcie_mrd_delay <= LP_PCIE_MRD_DELAY;\n\t\tend\n\t\tS_PCIE_MRD_DELAY: begin\n\t\t\tr_pcie_mrd_delay <= r_pcie_mrd_delay - 1'b1;\n\t\tend\n\t\tS_PCIE_MRD_NEXT: begin\n\n\t\tend\n\t\tdefault: begin\n\n\t\tend\n\tendcase\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_RX_CMD_0: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 1;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_RX_CMD_1: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 1;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_CHK_NUM_MRD: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_REQ: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 1;\n\t\t\tr_tx_dma_mrd_req <= 1;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_ACK: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_DONE: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 1;\n\t\tend\n\t\tS_PCIE_MRD_DELAY: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_NEXT: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "pcie_rx_req #",
        "module_hash": "af6329cc6a47b1e773a45a94376cfe84",
        "dataset_index": 25840
      },
      "sky130_fd_sc_lp__a311oi_821f5b85": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a311oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2      );\n    nor nor0 (nor0_out_Y, and0_out, B1, C1);\n    buf buf0 (Y         , nor0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a311oi",
        "module_hash": "821f5b85bad9b48e9f3098575e55743c",
        "dataset_index": 22187
      },
      "mux #_ca42b6fc": {
        "rtl_code": "\nmodule mux #(\n    parameter WIDTH = 1\n)(\n  input ctrl,\n  input [WIDTH-1:0] D0,\n  input [WIDTH-1:0] D1,\n  output reg [WIDTH-1:0] S\n);\n\n  // Specify the width of the data signals as a generic argument\n\n  always @(*) begin\n    case (ctrl)\n      1'b0: S = D0;\n      1'b1: S = D1;\n      default: S = 0; // Fixed the default case to output 0.\n    endcase\n  end\n\nendmodule\n",
        "module_name": "mux #",
        "module_hash": "ca42b6fcb674846c68ed9fb8fb529f9c",
        "dataset_index": 21017
      },
      "CONFIG_REGS_5664668a": {
        "rtl_code": "module CONFIG_REGS ( BCLK, BRESET, WREN, LD_OUT, OPCODE, SRC1, WRADR, PC_ARCHI, USER, PCMATCH, DBG_HIT, READ,\n\t\t\t\t\t CFG, MCR, PTB_WR, PTB_SEL, IVAR, CINV, Y_INIT, DSR, DBG_TRAPS, DBG_IN );\n\n\tinput\t\t\tBCLK,BRESET;\n\tinput\t\t\tWREN,LD_OUT;\n\tinput\t [7:0]\tOPCODE;\n\tinput\t[31:0]\tSRC1;\n\tinput\t [5:0]\tWRADR;\n\tinput\t[31:0]\tPC_ARCHI;\n\tinput\t\t\tUSER;\n\tinput\t\t\tPCMATCH;\n\tinput\t\t\tDBG_HIT;\n\tinput\t\t\tREAD;\n\t\n\toutput\t[12:0]\tCFG;\n\toutput\t [3:0]\tMCR;\n\toutput\t\t\tPTB_WR;\n\toutput\t\t\tPTB_SEL;\n\toutput\t [1:0]\tIVAR;\n\toutput\t [3:0]\tCINV;\n\toutput\t\t\tY_INIT;\n\toutput\t [3:0]\tDSR;\n\toutput\t [2:0]\tDBG_TRAPS;\n\toutput\t[40:2]\tDBG_IN;\n\t\n\treg\t\t [3:0]\tMCR;\n\treg\t\t[12:0]\tCFG;\n\treg\t\t [1:0]\told_cfg;\n\treg\t\t\t\tPTB_WR,PTB_SEL;\n\treg\t\t\t\tivarreg;\n\treg\t\t [1:0]\tci_all,ci_line;\n\treg\t\t\t\tcheck_y;\n\n\twire\t\t\tld_cfg,ld_mcr,do_cinv;\n\twire\t\t\tinit_ic,init_dc;\n\twire\t\t\top_ok;\n\n\tassign op_ok = (OPCODE == 8'h6A);\tassign ld_cfg  = op_ok & (WRADR == 6'h1C)\t   & WREN;\n\tassign ld_mcr  = op_ok & (WRADR == 6'd9)\t   & WREN;\n\tassign do_cinv = op_ok & (WRADR[5:4] == 2'b11) & WREN;\n\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) CFG <= 13'h0;\n\t\t\telse if (ld_cfg) CFG <= SRC1[12:0];\n\t\t\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) MCR <= 4'h0;\n\t\t\telse if (ld_mcr) MCR <= SRC1[3:0];\n\n\talways @(posedge BCLK) ivarreg <= op_ok & (WRADR[5:1] == 5'd7) & WREN;\tassign IVAR = {ivarreg,PTB_SEL};\n\t\n\talways @(posedge BCLK) PTB_WR  <= op_ok & (WRADR[5:1] == 5'd6) & WREN;\talways @(posedge BCLK) PTB_SEL <= WRADR[0];\n\t\n\talways @(posedge BCLK) old_cfg <= {CFG[11],CFG[9]};\n\t\n\talways @(posedge BCLK) ci_all  <= do_cinv &  WRADR[2] ? WRADR[1:0] : 2'b0;\talways @(posedge BCLK) ci_line <= do_cinv & ~WRADR[2] ? WRADR[1:0] : 2'b0;\tassign init_ic = old_cfg[1] & (~CFG[11] | ci_all[1]);\n\tassign init_dc = old_cfg[0] & (~CFG[9]  | ci_all[0]);\n\t\n\tassign CINV = {init_ic,ci_line[1],init_dc,ci_line[0]};\n\t\n\talways @(posedge BCLK) check_y <= ld_cfg | do_cinv;\n\tassign Y_INIT = check_y & ~init_ic & ~init_dc;\treg\t\t [3:0]\tDSR;\n\treg\t\t[12:0]\tdcr;\n\treg\t\t[31:0]\tbpc;\n\treg\t\t[31:2]\tcar;\n\t\n\twire\t\t\top_dbg,ld_dcr,ld_bpc,ld_dsr,ld_car;\n\twire\t\t\tenable;\n\t\n\tassign op_dbg = (OPCODE == 8'h76);\n\t\n\tassign ld_dcr = op_dbg & (WRADR == 6'h11) & WREN;\n\tassign ld_bpc = op_dbg & (WRADR == 6'h12) & WREN;\n\tassign ld_dsr = op_dbg & (WRADR == 6'h13) & WREN;\n\tassign ld_car = op_dbg & (WRADR == 6'h14) & WREN;\n\n\tassign enable = dcr[12] & (USER ? dcr[10] : dcr[11]);\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) dcr <= 13'd0;\n\t\t\telse if (ld_dcr) dcr <= {SRC1[23:19],SRC1[7:0]};\n\t\t\t\n\talways @(posedge BCLK) if (ld_bpc) bpc <= SRC1;\n\talways @(posedge BCLK) if (ld_car) car <= SRC1[31:2];\n\t\n\tassign DBG_IN = {(dcr[12] & dcr[11]),(dcr[12] & dcr[10]),(dcr[7] & dcr[6]),(dcr[7] & dcr[5]),dcr[4:0],car};\n\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) DSR <= 4'd0;\n\t\t  else\n\t\t\tif (ld_dsr) DSR <= SRC1[31:28];\n\t\t\t  else\n\t\t\t\tbegin\n\t\t\t\t  DSR[3] <= DBG_HIT ? READ : DSR[3];\n\t\t\t\t  DSR[2] <= DSR[2] | PCMATCH;\n\t\t\t\t  DSR[1] <= DSR[1];\n\t\t\t\t  DSR[0] <= DSR[0] | DBG_HIT;\n\t\t\t\tend\n\n\tassign DBG_TRAPS[0] = enable & dcr[9] & (PC_ARCHI == bpc);\tassign DBG_TRAPS[1] = DBG_HIT;\tassign DBG_TRAPS[2] = dcr[8];\tendmodule\n\nmodule FP_STAT_REG ( BCLK, BRESET, LFSR, UP_SP, UP_DP, TT_SP, TT_DP, WREN, WRADR, DIN, FSR, TWREN, FPU_TRAP, SAVE_PC);\n\t\n\tinput\t\t\tBCLK;\n\tinput\t\t\tBRESET;\n\tinput\t\t\tLFSR;\tinput\t\t\tUP_SP,UP_DP;\tinput \t [4:0]\tTT_SP,TT_DP;\n\tinput\t\t\tWREN;\tinput\t [5:4]\tWRADR;\n\tinput \t[16:0] \tDIN;\toutput\t[31:0] \tFSR;\n\toutput\t\t\tTWREN;\n\toutput\treg\t\tFPU_TRAP;\n\toutput\t\t\tSAVE_PC;\n\t\n\treg\t\t [4:3]\ttrap_d;\n\treg\t\t\t\tupdate_d;\n\treg\t\t\t\tset_rm_d;\n\treg\t\t[10:0]\tset_bits;\n\treg\t\t [4:0]\tflags;\n\treg\t\t\t\trm_bit;\n\t\n\twire\t\t\tload_fsr;\n\twire\t\t\tupdate,update_i;\n\twire\t [4:0]\ttrap;\n\twire\t\t\tuflag,iflag,rmflag;\n\n\tassign load_fsr = LFSR & WREN;\n\t\n\tassign trap = UP_SP ? TT_SP : TT_DP;\n\t\n\tassign TWREN = ~((UP_SP & (TT_SP[2:0] != 3'b0)) | (UP_DP & (TT_DP[2:0] != 3'b0)));\n\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) FPU_TRAP <= 1'b0;\n\t\t  else FPU_TRAP <= ~FPU_TRAP & ~TWREN;\tassign update_i = (UP_SP | UP_DP) & ~FPU_TRAP;\talways @(posedge BCLK) update_d\t<= update_i;\n\talways @(posedge BCLK) trap_d\t<= trap[4:3];\n\talways @(posedge BCLK) set_rm_d\t<= WREN & (WRADR == 2'b10);\n\tassign update = update_d & ~FPU_TRAP;\n\t\n\tassign iflag  = (update & trap_d[4]) | flags[4];\tassign uflag  = (update & trap_d[3]) | flags[3];\tassign rmflag = (set_rm_d & ~FPU_TRAP) | rm_bit;\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) flags[4:3] <= 2'b0;\telse\n\t\t  begin\n\t\t\tif (load_fsr) flags[4:3] <= {DIN[6],DIN[4]};\n\t\t\t  else\n\t\t\t\tif (update) flags[4:3] <= {iflag,uflag};\n\t\t  end\n\t\t  \n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) flags[2:0] <= 3'b0;\telse\n\t\t  begin\n\t\t\tif (load_fsr) flags[2:0] <= DIN[2:0];\n\t\t\t  else\n\t\t\t\tif (update_i) flags[2:0] <= trap[2:0];\n\t\t  end\n\t\t  \n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) rm_bit <= 1'b0;\telse\n\t\t  begin\n\t\t\tif (load_fsr) rm_bit <= DIN[16];\n\t\t\t  else\n\t\t\t\tif (set_rm_d & ~FPU_TRAP) rm_bit <= 1'b1;\tend\n\t\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) set_bits <= 11'b0;\telse\n\t\t\tif (load_fsr) set_bits <= {DIN[15:7],DIN[5],DIN[3]};\n\n\tassign FSR = {15'h0,rmflag,set_bits[10:2],iflag,set_bits[1],uflag,set_bits[0],flags[2:0]};\n\t\n\tassign SAVE_PC = (UP_SP | UP_DP) & ~FPU_TRAP;\tendmodule\n\nmodule REGISTER( BCLK, ENWR, DOWR, BYDIN, DIN, RADR, WADR, WMASKE, DOUT, SELI );\n\ninput\t\t\tBCLK;\ninput\t\t\tDOWR,ENWR;\ninput\t[31:0]\tBYDIN,DIN;\ninput\t [7:0]\tRADR;\ninput\t [5:0]\tWADR;\ninput\t [1:0]\tWMASKE;\n\noutput\t[31:0]\tDOUT;\noutput reg \t\tSELI;\n\nreg\t \t [2:0] \tMX;\n\nwire\t [3:0]\tBE;\nwire\t\t\teq_rw;\n\nreg\t \t [7:0]\tREGFILE_D [0:63];\nreg\t \t [7:0]\tREGFILE_C [0:63];\nreg\t \t [7:0]\tREGFILE_B [0:63];\nreg\t \t [7:0]\tREGFILE_A [0:63];\nreg\t\t[31:0]\tRF;\n\nassign\tBE = {WMASKE[1],WMASKE[1],(WMASKE[1] | WMASKE[0]),1'b1};\n\nassign\teq_rw = ENWR & (RADR[5:0] == WADR);\n\nalways @(posedge BCLK) if (RADR[7]) MX[2:0] <= BE[2:0] & {{3{eq_rw}}};\n\nalways @(posedge BCLK) if (RADR[7]) SELI <= RADR[6];\n\nassign DOUT[31:16] = MX[2] ? BYDIN[31:16] : RF[31:16];\nassign DOUT[15:8]  = MX[1] ? BYDIN[15:8]  : RF[15:8];\nassign DOUT[7:0]   = MX[0] ? BYDIN[7:0]   : RF[7:0];\n\t\nalways @(posedge BCLK)\n\tif (RADR[7])\n\t\tbegin\n\t\t\tRF[31:24] <= REGFILE_D[RADR[5:0]];\n\t\t\tRF[23:16] <= REGFILE_C[RADR[5:0]];\n\t\t\tRF[15:8]  <= REGFILE_B[RADR[5:0]];\n\t\t\tRF[7:0]   <= REGFILE_A[RADR[5:0]];\n\t\tend\n\nalways @(posedge BCLK)\n\tif (DOWR)\n\t\tbegin\n\t\t\tif (BE[3]) REGFILE_D[WADR] <= DIN[31:24];\n\t\t\tif (BE[2]) REGFILE_C[WADR] <= DIN[23:16];\n\t\t\tif (BE[1]) REGFILE_B[WADR] <= DIN[15:8];\n\t\t\tif (BE[0]) REGFILE_A[WADR] <= DIN[7:0];\n\t\tend\n\nendmodule\n\n",
        "module_name": "CONFIG_REGS",
        "module_hash": "5664668a4a02ef8d5d2b2abc81fb60aa",
        "dataset_index": 16844
      },
      "mig_7series_v4_0_ddr_phy_ck_addr_cmd_delay #_1b9579b6": {
        "rtl_code": "\n\nmodule mig_7series_v4_0_ddr_phy_ck_addr_cmd_delay #\n  (\n   parameter TCQ            = 100,\n   parameter tCK            = 3636,\n   parameter DQS_CNT_WIDTH  = 3,\n   parameter N_CTL_LANES    = 3,\n   parameter SIM_CAL_OPTION = \"NONE\"\n   )\n  (\n   input                        clk,\n   input                        rst,\n   input                        cmd_delay_start,\n   output reg [N_CTL_LANES-1:0] ctl_lane_cnt,\n   output reg       po_stg2_f_incdec,\n   output reg       po_en_stg2_f,\n   output reg       po_stg2_c_incdec,\n   output reg       po_en_stg2_c,\n   output           po_ck_addr_cmd_delay_done\n   );\n\n   localparam TAP_CNT_LIMIT = 63;\n\n   localparam FREQ_REF_DIV           = (tCK > 5000 ? 4 :\n                                        tCK > 2500 ? 2 : 1);\n\n   localparam integer PHASER_TAP_RES = ((tCK/2)/64);\n\n   localparam CALC_TAP_CNT = (tCK >= 1250) ? 350 : 300;\n\n   localparam TAP_CNT = 0;\n   localparam TAP_DEC = (SIM_CAL_OPTION == \"FAST_CAL\") ? 0 : 29;\n\n\n\n\n   reg       delay_dec_done;\n   reg       delay_done_r1;\n   reg       delay_done_r2;\n   reg       delay_done_r3;\n   reg       delay_done_r4 ;\n   reg [5:0] delay_cnt_r;\n   reg [5:0] delaydec_cnt_r;\n   reg       po_cnt_inc;\n   reg       po_cnt_dec;\n   reg [3:0] wait_cnt_r;\n\n   assign po_ck_addr_cmd_delay_done = ((TAP_CNT == 0) && (TAP_DEC == 0)) ? 1'b1 : delay_done_r4;\n\n   always @(posedge clk) begin\n     if (rst || po_cnt_dec || po_cnt_inc)\n       wait_cnt_r <= #TCQ 'd8;\n     else if (cmd_delay_start && (wait_cnt_r > 'd0))\n       wait_cnt_r <= #TCQ wait_cnt_r - 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || (delaydec_cnt_r > 6'd0) || (delay_cnt_r == 'd0) || (TAP_DEC == 0))\n       po_cnt_inc      <= #TCQ 1'b0;\n     else if ((delay_cnt_r > 'd0) && (wait_cnt_r == 'd1))\n       po_cnt_inc      <= #TCQ 1'b1;\n     else\n       po_cnt_inc      <= #TCQ 1'b0;\n   end\n\n   always @(posedge clk) begin\n     if (rst || (delaydec_cnt_r == 'd0))\n       po_cnt_dec      <= #TCQ 1'b0;\n     else if (cmd_delay_start && (delaydec_cnt_r > 'd0) && (wait_cnt_r == 'd1))\n       po_cnt_dec      <= #TCQ 1'b1;\n     else\n       po_cnt_dec      <= #TCQ 1'b0;\n   end\n\n   always @(posedge clk) begin\n     if (rst) begin\n       po_stg2_f_incdec <= #TCQ 1'b0;\n       po_en_stg2_f     <= #TCQ 1'b0;\n       po_stg2_c_incdec <= #TCQ 1'b0;\n       po_en_stg2_c     <= #TCQ 1'b0;\n     end else begin\n       if (po_cnt_dec) begin\n         po_stg2_f_incdec <= #TCQ 1'b0;\n         po_en_stg2_f     <= #TCQ 1'b1;\n       end else begin\n         po_stg2_f_incdec <= #TCQ 1'b0;\n         po_en_stg2_f     <= #TCQ 1'b0;\n       end\n       if (po_cnt_inc) begin\n         po_stg2_c_incdec <= #TCQ 1'b1;\n         po_en_stg2_c     <= #TCQ 1'b1;\n       end else begin\n         po_stg2_c_incdec <= #TCQ 1'b0;\n         po_en_stg2_c     <= #TCQ 1'b0;\n       end\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (tCK >= 2500) || (SIM_CAL_OPTION == \"FAST_CAL\"))\n       delay_cnt_r  <= #TCQ 'd0;\n     else if ((delaydec_cnt_r > 6'd0) ||((delay_cnt_r == 6'd0) && (ctl_lane_cnt != N_CTL_LANES-1)))\n       delay_cnt_r  <= #TCQ 'd1;\n     else if (po_cnt_inc && (delay_cnt_r > 6'd0))\n       delay_cnt_r  <= #TCQ delay_cnt_r - 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start ||((delaydec_cnt_r == 6'd0) && (delay_cnt_r == 6'd0) && (ctl_lane_cnt != N_CTL_LANES-1)))\n       delaydec_cnt_r  <= #TCQ TAP_DEC;\n     else if (po_cnt_dec && (delaydec_cnt_r > 6'd0))\n       delaydec_cnt_r  <= #TCQ delaydec_cnt_r - 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start )\n       ctl_lane_cnt <= #TCQ 6'b0;\n     else if (~delay_dec_done && (ctl_lane_cnt == N_CTL_LANES-1) && (delaydec_cnt_r == 6'd1))\n       ctl_lane_cnt <= #TCQ ctl_lane_cnt;\n     else if ((ctl_lane_cnt != N_CTL_LANES-1) && (delaydec_cnt_r == 6'd0) && (delay_cnt_r == 'd0))\n       ctl_lane_cnt <= #TCQ ctl_lane_cnt + 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start)  begin\n       delay_dec_done    <= #TCQ 1'b0;\n     end else if (((TAP_CNT == 0) && (TAP_DEC == 0)) ||\n                 ((delaydec_cnt_r == 6'd0) && (delay_cnt_r == 'd0) && (ctl_lane_cnt == N_CTL_LANES-1))) begin\n       delay_dec_done    <= #TCQ 1'b1;\n     end\n   end\n\n\n\n   always @(posedge clk) begin\n     delay_done_r1 <= #TCQ delay_dec_done;\n     delay_done_r2 <= #TCQ delay_done_r1;\n     delay_done_r3 <= #TCQ delay_done_r2;\n     delay_done_r4 <= #TCQ delay_done_r3;\n   end\n\nendmodule\n",
        "module_name": "mig_7series_v4_0_ddr_phy_ck_addr_cmd_delay #",
        "module_hash": "1b9579b62391da0da60ea79aafd60f59",
        "dataset_index": 25421
      },
      "adder_with_multiplexer_97cf2eec": {
        "rtl_code": "module adder_with_multiplexer (\n  input [3:0] A,\n  input [3:0] B,\n  input sel,\n  output [3:0] sum,\n  output carry_out,\n  output greater_than_7\n);\n\n  wire [3:0] mux_out;\n  wire c1, c2, c3;\n  \n  assign mux_out = sel ? B : A;\n  \n  assign {carry_out, sum} = A + mux_out;\n  \n  assign c1 = A[0] & mux_out[0];\n  assign c2 = A[0] ^ mux_out[0];\n  assign c3 = sum[0] ^ c2;\n  \n  assign greater_than_7 = c1 | c3;\n  \nendmodule",
        "module_name": "adder_with_multiplexer",
        "module_hash": "97cf2eecca044555881971700540ae63",
        "dataset_index": 599
      },
      "soc_system_jtag_uart_sim_scfifo_w_4b1c1415": {
        "rtl_code": "module soc_system_jtag_uart_sim_scfifo_w (\n  // inputs:\n  input clk,\n  input [7:0] fifo_wdata,\n  input fifo_wr,\n\n  // outputs:\n  output reg fifo_FF,\n  output reg [7:0] r_dat,\n  output reg wfifo_empty,\n  output reg [5:0] wfifo_used\n);\n\n  reg [7:0] fifo [63:0];\n  reg [5:0] head;\n  reg [5:0] tail;\n  reg [6:0] count;\n  wire full = (count == 64);\n  wire empty = (count == 0);\n\n  always @(posedge clk) begin\n    if (fifo_wr && !full) begin\n      fifo[head] <= fifo_wdata;\n      head <= head + 1;\n      count <= count + 1;\n    end\n    if (!empty) begin\n      r_dat <= fifo[tail];\n      tail <= tail + 1;\n      count <= count - 1;\n    end\n  end\n\n  always @* begin\n    wfifo_used <= count;\n    fifo_FF = full;\n    wfifo_empty = empty;\n  end\n\nendmodule",
        "module_name": "soc_system_jtag_uart_sim_scfifo_w",
        "module_hash": "4b1c141513efda55cdbe595b6a763262",
        "dataset_index": 4579
      },
      "axis_averager #_0ace2e0f": {
        "rtl_code": "\n\n\nmodule axis_averager #\n(\n  parameter integer AXIS_TDATA_WIDTH = 32,\n  parameter integer BRAM_DATA_WIDTH = 32,\n  parameter integer BRAM_ADDR_WIDTH = 16,  parameter integer AVERAGES_WIDTH = 32\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n  \n  input  wire\t\t\t\t\t\t trig,\n  input  wire \t\t\t\t\t\t user_reset,\n  input  wire [15:0]\t\t\t\t nsamples,\n  input  wire [AVERAGES_WIDTH-1:0] \t naverages,\n  output wire \t\t\t\t\t\t finished,\n  output wire [AVERAGES_WIDTH-1:0] \t averages_out,\n  \n  output wire                        s_axis_tready,\n  input  wire [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,\n  input  wire                        s_axis_tvalid,\n\n  output wire                        bram_porta_clk,\n  output wire                        bram_porta_rst,\n  output wire [BRAM_ADDR_WIDTH-1:0]  bram_porta_addr,\n  output wire [BRAM_DATA_WIDTH-1:0]  bram_porta_wrdata,\n  input  wire [BRAM_DATA_WIDTH-1:0]  bram_porta_rddata,\n  output wire                        bram_porta_we,\n  \n  output wire                        bram_portb_clk,\n  output wire                        bram_portb_rst,\n  output wire [BRAM_ADDR_WIDTH-1:0]  bram_portb_addr,\n  output wire [BRAM_DATA_WIDTH-1:0]  bram_portb_wrdata,\n  input  wire [BRAM_DATA_WIDTH-1:0]  bram_portb_rddata,\n  output wire                        bram_portb_we\n);\n\n\n  reg [BRAM_ADDR_WIDTH-1:0] int_addrA_reg, int_addrA_next;\n  reg [BRAM_ADDR_WIDTH-1:0] int_addrB_reg, int_addrB_next;\n  reg [2:0] int_case_reg, int_case_next;\n  reg int_wren_reg, int_wren_next;\n  reg [AVERAGES_WIDTH-1:0] int_averages_reg, int_averages_next;\n  reg int_finished_reg, int_finished_next;\n  reg [BRAM_DATA_WIDTH-1:0] int_data_reg, int_data_next;\n  reg d_trig;\n  wire trigger;  \n  \n  \n  assign s_axis_tready = 1;\n  assign finished = int_finished_reg;\n  assign averages_out = int_averages_reg;\n  \n  assign bram_porta_clk = aclk;\n  assign bram_porta_rst = ~aresetn;\n  assign bram_porta_addr = int_addrA_reg;\n  assign bram_porta_wrdata = int_data_reg;\n  assign bram_porta_we = int_wren_reg;\n   \n  assign bram_portb_clk = aclk;\n  assign bram_portb_rst = ~aresetn;\n  assign bram_portb_addr = int_addrB_reg;\n  assign bram_portb_wrdata = {(BRAM_DATA_WIDTH){1'b0}};\n  assign bram_portb_we = 1'b0;\n  \n  \n  always@(posedge aclk) begin\n\t if (user_reset) d_trig <= 0;\n\t else d_trig <= trig;\n  end\n  assign trigger = (trig == 1) && (d_trig == 0) ? 1 : 0;\n\n  \n  always @(posedge aclk)\n  begin\n    if(~aresetn || user_reset)\n    begin\n      int_addrA_reg <= {(BRAM_ADDR_WIDTH){1'b0}};\n\t  int_addrB_reg <= {(BRAM_ADDR_WIDTH){1'b0}};\n      int_case_reg <= 3'd0;\n\t  int_averages_reg <= {(AVERAGES_WIDTH){1'b0}};\n      int_wren_reg <= 1'b0;\n      int_data_reg <= {(BRAM_DATA_WIDTH){1'b0}};\n      int_finished_reg <= 1'b0;\n    end\n    else\n    begin\n      int_addrA_reg <= int_addrA_next;\n      int_addrB_reg <= int_addrB_next;\n      int_case_reg <= int_case_next;\n      int_wren_reg <= int_wren_next;\n\t  int_averages_reg <= int_averages_next;\n\t  int_data_reg <= int_data_next;\n\t  int_finished_reg <= int_finished_next;\n    end\n  end\n\n  \n  always @*\n  begin\n    int_addrA_next = int_addrA_reg;\n\tint_addrB_next = int_addrB_reg;\n    int_case_next = int_case_reg;\n    int_wren_next = int_wren_reg;\n\tint_averages_next = int_averages_reg;\n\tint_data_next = int_data_reg;\n\tint_finished_next = int_finished_reg;\n\t\n    case(int_case_reg)\n      0:    begin\n        int_addrA_next = {(BRAM_ADDR_WIDTH){1'b0}};\n\t\tint_addrB_next = {(BRAM_ADDR_WIDTH){1'b0}};\n\t\tint_averages_next = {(AVERAGES_WIDTH){1'b0}};\n\t\tint_case_next = 3'd1;\n\t\tint_wren_next = 1'b1;\n\t\tint_finished_next = 1'b0;\n\t\tint_data_next = {(BRAM_DATA_WIDTH){1'b0}};\n      end\n      1:    begin\n        int_addrA_next = int_addrA_reg + 1'b1;\n        if(int_addrA_reg == nsamples-1) begin\n          int_case_next = 3'd2;\n\t\t  int_wren_next = 1'b0;\n        end\n      end\n      2:    begin\n        int_addrA_next = -2;\n        int_addrB_next = 0;\n        int_wren_next = 1'b0;\n        if(trigger)\n        begin\n\t\t  int_averages_next = int_averages_reg + 1;\n\t\t  if (int_averages_reg == naverages)\n\t\t\t int_case_next = 3'd4;\n\t\t  else\n\t\t\t int_case_next = 3'd3;          \n        end\n      end\n\t  3:    begin\n        if(s_axis_tvalid)\n        begin\n          int_addrA_next = int_addrA_reg + 1;\n\t\t  int_addrB_next = int_addrB_reg + 1;\n\t\t  int_data_next = bram_portb_rddata + s_axis_tdata;\n\t\t  int_wren_next = 1'b1;\n\t\t  if (int_addrA_reg == nsamples-2)\n\t\t\t int_case_next = 3'd2;\n        end\n\t\telse\n\t\t  int_wren_next = 1'b0;\n      end\n      4:\tbegin\n        int_finished_next = 1;\n      end\n\n    endcase\n  end\n\n\n\nendmodule\n",
        "module_name": "axis_averager #",
        "module_hash": "0ace2e0f171833cb7a062f9f858b0303",
        "dataset_index": 18277
      },
      "mux_2to1_757a37d4": {
        "rtl_code": "module mux_2to1 (\n    sel,\n    data_in_0,\n    data_in_1,\n    out\n);\n\n    // Module ports\n    input  sel;\n    input  data_in_0;\n    input  data_in_1;\n    output out;\n\n    // Local signals\n    wire and0_out;\n    wire and1_out;\n    wire not_sel;\n\n    //  Name  Output     Other arguments\n    not not0 (not_sel, sel);\n    and and0 (and0_out, data_in_0, not_sel);\n    and and1 (and1_out, data_in_1, sel);\n    or  or0  (out     , and0_out, and1_out);\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "757a37d481f60baed8af48d7d7cb1a7b",
        "dataset_index": 2251
      },
      "my_inverter_18d1f636": {
        "rtl_code": "\nmodule my_inverter (\n    output Y, // output\n    input  A  // input\n);\n\n    not (Y, A);\nendmodule",
        "module_name": "my_inverter",
        "module_hash": "18d1f636f0fd896989a16c8b426816b5",
        "dataset_index": 21235
      },
      "hub_core_7b1d3676": {
        "rtl_code": "module hub_core (uart_clk, new_nonces, golden_nonce, serial_send, serial_busy, slave_nonces);\n   parameter SLAVES = 2;\n\n   input uart_clk;\n   \n   input [SLAVES-1:0] new_nonces;\n   input [SLAVES*32-1:0] slave_nonces;\n   output [31:0] \t golden_nonce;\n   output \t\t serial_send;\n   input \t\t serial_busy;\n\n   reg \t\t\t serial_send_reg = 0;\n   assign serial_send = serial_send_reg;\n  \n   reg [SLAVES-1:0] \tnew_nonces_flag = 0;\n   \n   function integer clog2;\t\tinput integer value;\n      begin\n      value = value-1;\n      for (clog2=0; value>0; clog2=clog2+1)\n      value = value>>1;\n      end\n   endfunction\n\n   reg [clog2(SLAVES)+1:0] port_counter = 0;\n   reg [SLAVES*32-1:0] \t    slave_nonces_shifted = 0;\n   assign golden_nonce = slave_nonces_shifted[31:0];\n\n   reg [SLAVES-1:0] \t    clear_nonces = 0;\n   \n   always @(posedge uart_clk)\n     begin\n\tnew_nonces_flag <= (new_nonces_flag & ~clear_nonces) | new_nonces;\n\n\tif (port_counter == SLAVES-1)\n\t  port_counter <= 0;\n\telse\n\t  port_counter <= port_counter + 1;\n\t\n\tif (!serial_busy && new_nonces_flag[port_counter])\n\t  begin\n\t     slave_nonces_shifted <= slave_nonces >> port_counter*32;\n\t     serial_send_reg <= 1;\n\t     clear_nonces[port_counter] <= 1;\n\t  end\n\telse \n\t  begin\n\t     serial_send_reg <= 0;\n\t     clear_nonces <= 0;\n\t  end\n     end\n\nendmodule ",
        "module_name": "hub_core",
        "module_hash": "7b1d3676577b1a3f7dc8e25b5f6bbd8e",
        "dataset_index": 25094
      },
      "dffsi_9_5571cd9c": {
        "rtl_code": "module dffsi_9 (\n    input clk,\n    input reset,\n    input [8:0] init,\n    input [8:0] d,\n    output reg [8:0] q\n);\n\n    // Synthesis Attribute to keep hierarchy\n     \n\n    // Random initialization\n    `ifdef RANDOM_INIT\n        initial $random_init(q);\n    `endif\n\n    // Assertion for checking reset signal\n    `ifdef CHK_RESET_EOS\n        assert_quiescent_state #(0,1,0, \"***ERROR ASSERT: reset still asserted at end of simulation\")\n            a0(.clk(clk), .reset_n(1'b1), .state_expr(reset), .check_value(1'b0), .sample_event(1'b0));\n    `endif\n\n    always @(posedge clk) begin\n        if (!reset) begin\n            q <= init;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule",
        "module_name": "dffsi_9",
        "module_hash": "5571cd9c5aaef2fdf0afb9a7c5fa4820",
        "dataset_index": 2959
      },
      "mux8_d2ca808c": {
        "rtl_code": "\nmodule mux8\n  #(parameter WIDTH=32, parameter DISABLED=0)\n    (input en,\n     input [2:0] sel,\n     input [WIDTH-1:0] i0,\n     input [WIDTH-1:0] i1,\n     input [WIDTH-1:0] i2,\n     input [WIDTH-1:0] i3,\n     input [WIDTH-1:0] i4,\n     input [WIDTH-1:0] i5,\n     input [WIDTH-1:0] i6,\n     input [WIDTH-1:0] i7,\n     output [WIDTH-1:0] o);\n\n   reg [WIDTH-1:0] _o;\n\n   always @(*) begin\n      case(sel)\n         3'b000: _o = i0;\n         3'b001: _o = i1;\n         3'b010: _o = i2;\n         3'b011: _o = i3;\n         3'b100: _o = i4;\n         3'b101: _o = i5;\n         3'b110: _o = i6;\n         3'b111: _o = i7;\n         default: _o = DISABLED;\n      endcase\n   end\n\n   assign o = en ? _o : DISABLED;\n\nendmodule",
        "module_name": "mux8",
        "module_hash": "d2ca808c057ef78bf5fec7d52c7f9495",
        "dataset_index": 18854
      },
      "add_sub_4bit_a91d9d89": {
        "rtl_code": "module add_sub_4bit (\n  input signed [3:0] A,\n  input signed [3:0] B,\n  input mode,\n  output reg signed [3:0] result\n);\n\n  wire [3:0] twos_comp_B;\n  assign twos_comp_B = (~B) + 1;\n\n  always @* begin\n    if (mode) begin\n      result <= A + B;\n    end else begin\n      result <= A + twos_comp_B;\n    end\n  end\n\nendmodule",
        "module_name": "add_sub_4bit",
        "module_hash": "a91d9d89816e8985a63e78cdeb86e1d7",
        "dataset_index": 6769
      },
      "bcdtoseg_0cd58b4d": {
        "rtl_code": "module bcdtoseg(nLT, nRBI, A3, A2, A1, A0, nBI,\n\t\t\t\tnRBO, nA, nB, nC, nD, nE, nF, nG);\n\n\tinput  nLT, nRBI, A3, A2, A1, A0, nBI;\n\toutput nRBO, nA, nB, nC, nD, nE, nF, nG;\n\n\twire  [3:0] SEGIN;\n\t\n\treg   [6:0] nSEGOUT;\n\n\tassign   SEGIN[3] = A3;\n\tassign   SEGIN[2] = A2;\n\tassign   SEGIN[1] = A1;\n\tassign   SEGIN[0] = A0;\n\n\tassign   nA = nSEGOUT[6];\n\tassign   nB = nSEGOUT[5];\n\tassign   nC = nSEGOUT[4];\n\tassign   nD = nSEGOUT[3];\n\tassign   nE = nSEGOUT[2];\n\tassign   nF = nSEGOUT[1];\n\tassign   nG = nSEGOUT[0];\n\n\tassign nRBO = ~(~nBI || (~nRBI && (SEGIN == 4'd0) && nLT));\n\t\n\talways @ (nRBO or nLT or SEGIN) begin\n\t\tif (~nRBO) begin\n\t\t\tnSEGOUT = ~7'b0000000; \n\t\tend else if (~nLT) begin\n\t\t\tnSEGOUT = ~7'b1111111; \n\t\tend else begin \n\t\t\tcase (SEGIN)\n\t\t\t\t4'd0:     nSEGOUT = ~7'b1111110; \n\t\t\t\t4'd1:     nSEGOUT = ~7'b0110000;\n\t\t\t\t4'd2:     nSEGOUT = ~7'b1101101;\n\t\t\t\t4'd3:     nSEGOUT = ~7'b1111001;\n\t\t\t\t4'd4:     nSEGOUT = ~7'b0110011;\n\t\t\t\t4'd5:     nSEGOUT = ~7'b1011011;\n\t\t\t\t4'd6:     nSEGOUT = ~7'b1011111;\n\t\t\t\t4'd7:     nSEGOUT = ~7'b1110000;\n\t\t\t\t4'd8:     nSEGOUT = ~7'b1111111;\n\t\t\t\t4'd9:     nSEGOUT = ~7'b1111011;\n\t\t\t\t4'hF:\t\t nSEGOUT = ~7'b1100111;\tdefault:  nSEGOUT = ~7'b0000000;\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "bcdtoseg",
        "module_hash": "0cd58b4d6dbdd4eb0eaf3d8c7d5a9ef1",
        "dataset_index": 23259
      },
      "mux_parity_e3798134": {
        "rtl_code": "\nmodule mux_parity (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output [3:0] out,\n  output parity\n);\n\n  wire [3:0] mux_out [0:5];\n  wire [2:0] sel_dec [0:7];\n  \n  // Generate intermediate signals for each input data\n  assign mux_out[0] = (sel_dec[0]) ? data0 : 4'b0;\n  assign mux_out[1] = (sel_dec[1]) ? data1 : 4'b0;\n  assign mux_out[2] = (sel_dec[2]) ? data2 : 4'b0;\n  assign mux_out[3] = (sel_dec[3]) ? data3 : 4'b0;\n  assign mux_out[4] = (sel_dec[4]) ? data4 : 4'b0;\n  assign mux_out[5] = (sel_dec[5]) ? data5 : 4'b0;\n  \n  // Generate select signals using a 3-to-8 decoder\n  assign sel_dec[0] = (sel == 3'b000);\n  assign sel_dec[1] = (sel == 3'b001);\n  assign sel_dec[2] = (sel == 3'b010);\n  assign sel_dec[3] = (sel == 3'b011);\n  assign sel_dec[4] = (sel == 3'b100);\n  assign sel_dec[5] = (sel == 3'b101);\n  assign sel_dec[6] = 1'b0;\n  assign sel_dec[7] = 1'b0;\n  \n  // Select the active input data using an 8-input OR gate\n  assign out = mux_out[0] | mux_out[1] | mux_out[2] | mux_out[3] | mux_out[4] | mux_out[5];\n  \n  // Generate the parity bit using an XOR gate\n  assign parity = out[0] ^ out[1] ^ out[2] ^ out[3];\n  \nendmodule\n",
        "module_name": "mux_parity",
        "module_hash": "e379813483d2485423d50ab53ccc8e21",
        "dataset_index": 18214
      },
      "cross_domain_sync_0ba979cf": {
        "rtl_code": "module cross_domain_sync (\n    input capturetrig1, // input trigger signal from other clock domain\n    input  read_Mux_In, // input data signal from other clock domain\n    input s_axi_aclk, // local clock signal\n    output reg captureTrig1_d0 // synchronized output data signal\n);\n\n  // Declare internal wires\n  wire CaptureTrig1_int;\n  wire s_level_out_d1_cdc_to;\n  wire s_level_out_d2;\n  wire s_level_out_d3;\n\n  // Instantiate FDRE primitive components for cross-domain synchronization\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_IN_cdc_to \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(capturetrig1),\n        .Q(s_level_out_d1_cdc_to),\n        .R(1'b0));\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_s_level_out_d2 \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(s_level_out_d1_cdc_to),\n        .Q(s_level_out_d2),\n        .R(1'b0));\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_s_level_out_d3 \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(s_level_out_d2),\n        .Q(s_level_out_d3),\n        .R(1'b0));\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_s_level_out_d4 \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(s_level_out_d3),\n        .Q(CaptureTrig1_int),\n        .R(1'b0));\n\n\n  always @(posedge s_axi_aclk) begin\n    if (CaptureTrig1_int) begin\n      captureTrig1_d0 <= read_Mux_In;\n    end\n  end\n\n\nendmodule\n\nmodule FDRE(\n    input D,     \n    input C,    \n    input CE,    \n    input R,     \n    output reg Q \n);\n\nalways @(posedge C) begin\n    if (R) begin\n        Q <= 1'b0; \n    end\n    else if (CE) begin\n        Q <= D; \n    end\nend\n\nendmodule\n",
        "module_name": "cross_domain_sync",
        "module_hash": "0ba979cf9a8dd00315ffdd0055d2e502",
        "dataset_index": 13704
      },
      "sky130_fd_sc_ls__o221a_a6348043": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o221a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , B2, B1              );\n    or  or1  (or1_out   , A2, A1              );\n    and and0 (and0_out_X, or0_out, or1_out, C1);\n    buf buf0 (X         , and0_out_X          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o221a",
        "module_hash": "a6348043f53a2a9053dd8e03959c83c8",
        "dataset_index": 9887
      },
      "ddr3_eim_cs1_15c7b5b7": {
        "rtl_code": "module ddr3_eim_cs1(\n\t\t    input wire clk,\n\t\t    \n\t\t    input wire [63:0] ctl, \n\t\t    input wire ctl_stb,  output wire [63:0] burst_rd,\n\t\t    input wire rd_stb,   output wire [63:0] status,\n\n\t\t    output wire [2:0] ddr3_rd_cmd,\n\t\t    output wire [5:0] ddr3_rd_bl,\n\t\t    output wire [29:0] ddr3_rd_adr,\n\t\t    output wire ddr3_rd_cmd_en,\n\t\t    input wire ddr3_rd_cmd_empty,\n\t\t    input wire ddr3_rd_cmd_full,\n\n\t\t    input wire [31:0] ddr3_rd_data,\n\t\t    input wire [6:0] ddr3_rd_count,\n\t\t    input wire ddr3_rd_empty,\n\t\t    input wire ddr3_rd_full,\n\t\t    output reg ddr3_rd_en,\n\t\t    \n\t\t    input wire reset\n\t\t    );\n\n   reg [29:0] \t\t cmd_adr;\n   reg [4:0] \t\t num_pkts; reg [4:0] \t\t outstanding;\n\n   reg [63:0] \t\t rd_cache;\n\n   reg \t\t\t cmd_go;\n\n   reg \t\t\t reset_errors;\n   reg \t\t\t cmd_err;\n\n   reg [7:0] \t\t readcount;\n   \n   assign burst_rd[63:0] = rd_cache[63:0];\n   \n   \n   assign status = {readcount,\n\t\t    3'b0,cmd_err, \n\t\t    ddr3_rd_cmd_empty, ddr3_rd_cmd_full, ddr3_rd_empty, ddr3_rd_full, \n\t\t    1'b0, ddr3_rd_count[6:0]};\n\n   always @(posedge clk) begin\n      if( ctl_stb ) begin\n\t readcount <= 8'b0;\n      end else if( rd_stb ) begin\n\t readcount <= readcount + 8'b1;\n      end else begin\n\t readcount <= readcount;\n      end\n   end\n\n   always @(posedge clk) begin\n      if( ctl_stb ) begin\n\t cmd_adr <= ctl[29:0];\n\t num_pkts <= ctl[36:32]; end else begin\n\t cmd_adr <= cmd_adr;\n\t num_pkts <= num_pkts;\n      end\n      \n      cmd_go <= ctl_stb && (ctl[36:32] != 5'b0);\n   end\n\n   assign ddr3_rd_cmd = 3'b001; assign ddr3_rd_adr = {cmd_adr[29:2],2'b00}; assign ddr3_rd_bl[5:0] = {num_pkts[4:0],1'b0} - 6'b1;\n   assign ddr3_rd_cmd_en = cmd_go; parameter READ_IDLE        = 6'b1 << 0;\n   parameter READ_PENDING     = 6'b1 << 1;\n   parameter READ_FETCH       = 6'b1 << 2;\n   parameter READ_UPDATE_LSB  = 6'b1 << 3;\n   parameter READ_UPDATE_MSB  = 6'b1 << 4;\n   parameter READ_WAIT        = 6'b1 << 5;\n\n   parameter READ_nSTATES = 6;\n   reg [(READ_nSTATES - 1):0] \t\t cstate;\n   reg [(READ_nSTATES - 1):0] \t\t nstate;\n\n   always @(posedge clk) begin\n      cstate <= nstate;\n   end\n\n   always @(*) begin\n      case(cstate)\n\tREAD_IDLE: begin\n\t   if( cmd_go ) begin\n\t      nstate <= READ_PENDING;\n\t   end else begin\n\t      nstate <= READ_IDLE;\n\t   end\n\tend\n\tREAD_PENDING: begin\n\t   if( outstanding != 5'b0 ) begin\n\t      if( ddr3_rd_count[6:0] < 7'b10 ) begin\n\t\t nstate <= READ_PENDING;\n\t      end else begin\n\t\t nstate <= READ_FETCH;\n\t      end\n\t   end else begin\n\t      nstate <= READ_IDLE;\n\t   end\n\tend READ_FETCH: begin\n\t   nstate <= READ_UPDATE_LSB;\n\tend\n\tREAD_UPDATE_LSB: begin\n\t   nstate <= READ_UPDATE_MSB;\n\tend\n\tREAD_UPDATE_MSB: begin\n\t   nstate <= READ_WAIT;\n\tend\n\tREAD_WAIT: begin\n\t   if( rd_stb ) begin  nstate <= READ_PENDING;\n\t   end else begin\n\t      nstate <= READ_WAIT;\n\t   end\n\tend\n\tdefault: begin\n\t   nstate <= READ_IDLE;\n\tend\n      endcase end always @(posedge clk) begin\n      case(cstate)\n\tREAD_IDLE: begin\n\t   outstanding[4:0] <= num_pkts[4:0];\n\t   rd_cache <= rd_cache;\n\t   if( ddr3_rd_count[6:0] > 7'b0 ) begin\n\t      ddr3_rd_en <= 1'b1; end else begin\n\t      ddr3_rd_en <= 1'b0;\n\t   end\n\tend\n\tREAD_PENDING: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b0;\n\tend\n\tREAD_FETCH: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b1;\n\tend\n\tREAD_UPDATE_LSB: begin\n\t   outstanding <= outstanding;\n\t   rd_cache[63:0] <= {rd_cache[63:32],ddr3_rd_data[31:0]};\n\t   ddr3_rd_en <= 1'b1;\n\tend\n\tREAD_UPDATE_MSB: begin\n\t   outstanding <= outstanding - 5'b1;\n\t   rd_cache[63:0] <= {ddr3_rd_data[31:0],rd_cache[31:0]};\nddr3_rd_en <= 1'b0;\n\tend\n\tREAD_WAIT: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b0;\n\tend\n\tdefault: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b0;\n\tend\n      endcase end\n   \n   \n   always @(posedge clk) begin\n      reset_errors <= ctl[63];\n      if( reset_errors ) begin\n\t cmd_err <= 1'b0;\n      end else begin\n\t if( cmd_go && ddr3_rd_cmd_full ) begin\n\t    cmd_err <= 1'b1;\n\t end else begin\n\t    cmd_err <= cmd_err;\n\t end\n      end\n   end endmodule ",
        "module_name": "ddr3_eim_cs1",
        "module_hash": "15c7b5b7fe44b59b130dc20c6658f542",
        "dataset_index": 24622
      },
      "handshake_92363779": {
        "rtl_code": "module handshake(error, clk, req, ack, reset);\n\noutput reg error;\n\ninput clk, req, ack, reset;\n\nreg [2:0] state;\n\ninitial\nbegin\n\tstate = 3'b000;\n\terror = 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tcase (state)\n\t\t3'b000: \n\t\tbegin\n\t\t\tif (~req && ~ack)\n\t\t\t\tstate = 3'b000;\n\t\t\telse if (req && ~ack)\n\t\t\t\tstate = 3'b001;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b001:\n\t\tbegin\n\t\t\tif (req && ~ack)\n\t\t\t\tstate = 3'b001;\n\t\t\telse if (req && ack)\n\t\t\t\tstate = 3'b010;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b010:\n\t\tbegin\n\t\t\tif (req && ack)\n\t\t\t\tstate = 3'b010;\n\t\t\telse if (~req && ack)\n\t\t\t\tstate = 3'b011;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b011:\n\t\tbegin\n\t\t\tif (~req && ack)\n\t\t\t\tstate = 3'b011;\n\t\t\telse if (~req && ~ack)\n\t\t\t\tstate = 3'b000;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b100:\n\t\tbegin\n\t\t\tif (reset)\n\t\t\tbegin\n\t\t\t\tstate = 3'b000;\n\t\t\t\terror = 1'b0;\n\t\t\tend\n\t\tend\n\t\t\n\t\tdefault:\n\t\tbegin\n\t\t\tstate = 3'b100;\n\t\t\terror = 1'b1;\n\t\tend\n\tendcase\nend\n\nendmodule",
        "module_name": "handshake",
        "module_hash": "9236377922f7a4294a8f7212462bda6f",
        "dataset_index": 4038
      },
      "barrel_shifter_82d8a358": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        if (B >= 0) begin\n            result = A << B;\n        end else begin\n            result = A >> $signed(B);\n        end\n    end\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "82d8a35857338cce2fb37dd3ce9efb93",
        "dataset_index": 12672
      },
      "top__5934ab97": {
        "rtl_code": "module top_module (\n    input clk,\n    input load,\n    input up_down,\n    input [3:0] D,\n    output [3:0] OUT\n);\n\nreg [3:0] up_counter;\nreg [3:0] down_counter;\nwire [3:0] xor_output;\n\n// Up counter\nalways @(posedge clk) begin\n    if (load) begin\n        up_counter <= D;\n    end else if (up_down) begin\n        if (up_counter == 4'b1111) begin\n            up_counter <= 4'b0;\n        end else begin\n            up_counter <= up_counter + 1;\n        end\n    end\nend\n\n// Down counter\nalways @(posedge clk) begin\n    if (load) begin\n        down_counter <= D;\n    end else if (!up_down) begin\n        if (down_counter == 4'b0000) begin\n            down_counter <= 4'b1111;\n        end else begin\n            down_counter <= down_counter - 1;\n        end\n    end\nend\n\n// XOR module\nassign xor_output = up_counter ^ down_counter;\n\n// Output\nassign OUT = xor_output;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "5934ab9790f0bb27ac413674bd950881",
        "dataset_index": 17777
      },
      "fifo_top_ee99d231": {
        "rtl_code": "\n\n`define READ\t\t\t2'b01\n`define WRITE\t\t\t2'b10\n`define DO_NOTHING\t2'b00\n`define INVALID\t\t2'b11\n\n`define DATA_VALID\t1'b1\n`define DATA_INVALID\t1'b0\n\n`define FIFO_FULL\t\t\t1'b1\n`define FIFO_NOT_FULL\t1'b0\n\n`define FIFO_EMPTY\t\t1'b1\n`define FIFO_NOT_EMPTY\t1'b0\n\n`define LOG2(width) \t(width<=2)?1:\\\n\t\t\t\t\t\t\t(width<=4)?2:\\\n\t\t\t\t\t\t\t(width<=8)?3:\\\n\t\t\t\t\t\t\t(width<=16)?4:\\\n\t\t\t\t\t\t\t(width<=32)?5:\\\n\t\t\t\t\t\t\t(width<=64)?6:\\\n\t\t\t\t\t\t\t(width<=128)?7:\\\n\t\t\t\t\t\t\t(width<=256)?8:\\\n\t\t\t\t\t\t\t-1\t\t\t\t\t\t\t\nmodule fifo_top(\n    data_out, empty_flag, full_flag,\n    vector_in, reset,\n    clk\n    );\nparameter DATA_WIDTH = 4;\nparameter NUM_ENTRIES = 4;\nparameter OPCODE_WIDTH = 2;\nparameter LINE_WIDTH = DATA_WIDTH+OPCODE_WIDTH; parameter INITIAL_VALUE = 'b0; \nparameter NUM_ENTRIES_BIT = `LOG2(NUM_ENTRIES); \n\noutput reg [DATA_WIDTH-1:0]data_out;\noutput reg empty_flag;\noutput reg full_flag;\ninput [OPCODE_WIDTH+DATA_WIDTH-1:0]vector_in;\ninput reset;\ninput clk;\n\nreg [DATA_WIDTH-1:0]fifo_data[NUM_ENTRIES-1:0];\nreg [NUM_ENTRIES-1:0]fifo_valid_invalid_bit;\n\nreg [OPCODE_WIDTH-1:0]control_in;\treg [DATA_WIDTH-1:0]data_in;\t\t\treg [NUM_ENTRIES_BIT-1:0]fifo_head_pos;\nreg [NUM_ENTRIES_BIT-1:0]fifo_tail_pos;\n\nreg [NUM_ENTRIES_BIT-1:0]loop_variable;\n\nalways@(posedge clk)\nbegin\t\n\tif(reset)\n\tbegin\n\t\tdata_out = INITIAL_VALUE;\n\t\tfifo_head_pos = INITIAL_VALUE;\n\t\tfifo_tail_pos = INITIAL_VALUE;\n\t\tloop_variable = INITIAL_VALUE;\n\t\tcontrol_in = INITIAL_VALUE;\n\t\tdata_in = INITIAL_VALUE;\n\t\tfifo_valid_invalid_bit = INITIAL_VALUE;\n\t\tempty_flag = `FIFO_NOT_EMPTY;\n\t\tfull_flag = `FIFO_NOT_FULL;\n\tend else\n\t\tbegin\n\t\t\tif(fifo_tail_pos == fifo_head_pos)begin\n\t\t\t\tif(fifo_valid_invalid_bit[fifo_tail_pos] == `DATA_INVALID && fifo_valid_invalid_bit[fifo_head_pos] == `DATA_INVALID)\n\t\t\t\t\tbegin\n\t\t\t\t\tempty_flag = `FIFO_EMPTY;\n\t\t\t\t\tfull_flag = `FIFO_NOT_FULL;\n\t\t\t\tend else\n\t\t\t\t\tbegin\n\t\t\t\t\t\tempty_flag = `FIFO_NOT_EMPTY;\n\t\t\t\t\t\tfull_flag = `FIFO_FULL;\t\t\t\t\t\n\t\t\t\t\tend\t\n\t\t\tend else \t\t\t\t\n\t\t\t\tbegin\n\t\t\t\t\tempty_flag = `FIFO_EMPTY;\n\t\t\t\t\tfull_flag = `FIFO_NOT_FULL;\n\t\t\t\tend\t\t\t\t\n\t\t\tcontrol_in = vector_in[LINE_WIDTH-1:LINE_WIDTH-OPCODE_WIDTH];\t\n\t\t\tdata_in = vector_in[LINE_WIDTH-OPCODE_WIDTH-1:LINE_WIDTH-OPCODE_WIDTH-DATA_WIDTH];\n\t\t\tcase(control_in)\t\t\t\n\t\t\t\t\t`READ: \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(fifo_valid_invalid_bit[fifo_tail_pos] == `DATA_VALID)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tdata_out = fifo_data[fifo_tail_pos];\n\t\t\t\t\t\t\t\t\tfifo_valid_invalid_bit[fifo_tail_pos] = `DATA_INVALID;\n\t\t\t\t\t\t\t\t\tfifo_tail_pos = fifo_tail_pos + 1'b1;\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tend else\n\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\tdata_out = 'bx;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\t\n\t\t\t\t\t`WRITE: \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(empty_flag == `FIFO_EMPTY && full_flag == `FIFO_NOT_FULL)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tfifo_data[fifo_head_pos] = data_in;\n\t\t\t\t\t\t\t\t\tfifo_valid_invalid_bit[fifo_head_pos] = `DATA_VALID;\n\t\t\t\t\t\t\t\t\tif(fifo_head_pos == NUM_ENTRIES-1)\n\t\t\t\t\t\t\t\t\t\tfifo_head_pos = 0;\n\t\t\t\t\t\t\t\t\telse\t\n\t\t\t\t\t\t\t\t\t\tfifo_head_pos = fifo_head_pos + 1'b1;\n\t\t\t\t\t\t\t\tend \nend\n\t\t\t\t\tdefault: data_out = 'bx;\n\t\t\t\tendcase\n\t\tend\t\t\nend\nendmodule\n",
        "module_name": "fifo_top",
        "module_hash": "ee99d2313313355b1fc5ddc0a1fcaca9",
        "dataset_index": 22574
      },
      "d_ff_asr_75a76c07": {
        "rtl_code": "module d_ff_asr (\n    input D,\n    input S,\n    input R,\n    input CLK,\n    output Q\n);\n\n    reg Q_int;\n\n    always @(posedge CLK) begin\n        if (S) begin\n            Q_int <= 1;\n        end else if (R) begin\n            Q_int <= 0;\n        end else begin\n            Q_int <= D;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule",
        "module_name": "d_ff_asr",
        "module_hash": "75a76c074cc40b78a6256c3a6d476530",
        "dataset_index": 2228
      },
      "unknown_module_83195eab": {
        "rtl_code": "module\n\ttimer#(\n\t\tparameter\n\t\tCOUNTER_WIDTH = 25,\n\t\tCEILING_WIDTH = 4\n\t)(\n\t\tinput  wire                    clk_in,\n\t\tinput  wire[CEILING_WIDTH-1:0] ceiling_in,\n\t\toutput reg                     tick_out\n\t);\n\n\tlocalparam TOP_BIT = 2**CEILING_WIDTH - 1;\n\tfunction[TOP_BIT:0] reverse(input[COUNTER_WIDTH:0] fwd);\n\t\tinteger i;\n\t\tfor ( i = 0; i <= TOP_BIT; i = i + 1 )\n\t\t\treverse[i] = fwd[COUNTER_WIDTH-i];\n\tendfunction\n\treg[COUNTER_WIDTH:0] count_next, count = 0;\n\twire[TOP_BIT:0] revCount;\n\n\talways @(posedge clk_in)\n\t\tcount <= count_next;\n\n\tassign revCount = reverse(count);\n\t\n\talways @*\n\tbegin\n\t\tif ( revCount[ceiling_in] == 1'b0 )\n\t\t\tbegin\n\t\t\t\tcount_next = count + 1'b1;\n\t\t\t\ttick_out = 1'b0;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tcount_next = 0;\n\t\t\t\ttick_out = 1'b1;\n\t\t\tend\n\tend\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "83195eab5b5f0a1662a660bf1b2fd2fb",
        "dataset_index": 24086
      },
      "MaquinaDeControl_7d3cdf47": {
        "rtl_code": "module MaquinaDeControl(\n    input Clock,\n    input Reset,\n    input NewScanCode,\n    input NewAscii,\n    output reg LoadDato,\n    output reg LoadChar,\n    output reg ScanCodeType\n);\n\nreg [1:0] state;\nparameter Sleep = 3'h0;\nparameter Recibido = 3'h1;\nparameter Type = 3'h3;\nparameter New = 3'h2;\n\nalways @(posedge Clock or negedge Reset) begin\n    if (!Reset) begin\n        state <= Sleep;\n    end else begin\n        case (state)\n            Sleep: begin\n                if (NewScanCode) begin\n                    state <= Recibido;\n                end else begin\n                    state <= Sleep;\n                end\n            end\n            Recibido: begin\n                state <= Type;\n            end\n            Type: begin\n                if (NewAscii && !Reset) begin\n                    state <= New;\n                end else if (!NewAscii || Reset) begin\n                    state <= Sleep;\n                end\n            end\n            New: begin\n                state <= Sleep;\n            end\n            default: begin\n                state <= Sleep;\n            end\n        endcase\n    end\nend\n\nalways @(state) begin\n    case (state)\n        Sleep: begin\n            LoadDato <= 0;\n            LoadChar <= 0;\n            ScanCodeType <= 0;\n        end\n        Recibido: begin\n            LoadDato <= 1;\n            LoadChar <= 0;\n            ScanCodeType <= 0;\n        end\n        Type: begin\n            LoadDato <= 0;\n            LoadChar <= 0;\n            ScanCodeType <= 1;\n        end\n        New: begin\n            LoadDato <= 0;\n            LoadChar <= 1;\n            ScanCodeType <= 0;\n        end\n        default: begin\n            LoadDato <= 0;\n            LoadChar <= 0;\n            ScanCodeType <= 0;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "MaquinaDeControl",
        "module_hash": "7d3cdf478177ac38b843d06b2783790f",
        "dataset_index": 7419
      },
      "pipelined_ripple_carry_adder_674e4871": {
        "rtl_code": "module pipelined_ripple_carry_adder (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] S,\n    output reg V\n);\n\nreg [3:0] P1_S, P2_S, P3_S;\nreg P1_C, P2_C, P3_C;\n\nalways @(posedge clk) begin\n    // Pipeline stage 1\n    P1_S <= A + B + Cin;\n    P1_C <= (A[0] & B[0]) | ((A[0] | B[0]) & Cin);\n    \n    // Pipeline stage 2\n    P2_S <= P1_S;\n    P2_C <= (P1_S[0] & P1_C) | ((P1_S[0] | P1_C) & P1_S[1]);\n    \n    // Pipeline stage 3\n    P3_S <= P2_S;\n    P3_C <= (P2_S[1] & P2_C) | ((P2_S[1] | P2_C) & P2_S[2]);\n    \n    // Output stage\n    S <= P3_S;\n    V <= P3_C;\nend\n\nendmodule",
        "module_name": "pipelined_ripple_carry_adder",
        "module_hash": "674e4871334197cb3a14a2584f2800e9",
        "dataset_index": 9239
      },
      "FSM_Bola_86fbf6d3": {
        "rtl_code": "\nmodule FSM_Bola(clock, reset, start_ball, busy_ball,actualizar_bola,revisar_bordes_bola);\n\t\n\tinput clock, reset, start_ball;\n\toutput busy_ball;\n\toutput reg actualizar_bola, revisar_bordes_bola;\n\t\n\treg [2:0] state;\n\t\n\tparameter STATE_0 = 0;\n\tparameter STATE_1 = 1;\n\tparameter STATE_2 = 2;\n\tparameter STATE_3 = 3;\n\t\n\tinitial\n\t\tbegin\n\t\t\tstate <= STATE_0;\n\t\t\tactualizar_bola <= 1'b0;\n\t\t\trevisar_bordes_bola <= 1'b0;\n\t\tend\n\t\n\talways@(posedge clock or posedge reset)\n\tbegin\n\t\tif(reset)\n\t\t\tbegin\n\t\t\t\tstate <= STATE_0;\n\t\t\t\tactualizar_bola <= 1'b0;\n\t\t\t\trevisar_bordes_bola <= 1'b0;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tcase(state)STATE_0: begin\n\t\t\t\t\t\t\tif (start_ball)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tstate <= STATE_1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tSTATE_1: begin\n\t\t\t\t\t\t\tactualizar_bola <= 1'b1;\n\t\t\t\t\t\t\tstate <= STATE_2;\n\t\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tSTATE_2: begin\t\t\t\n\t\t\t\t\t\t\tactualizar_bola <= 1'b0;\n\t\t\t\t\t\t\trevisar_bordes_bola <= 1'b1;\n\t\t\t\t\t\t\tstate <= STATE_3;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\tSTATE_3:\n\t\t\t\t\t\tbegin\t\t\t\n\t\t\t\t\t\t\trevisar_bordes_bola <= 1'b0;\n\t\t\t\t\t\t\tstate <= STATE_0;\n\t\t\t\t\t\tend\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tstate <= STATE_0;\n\t\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\tend\n\t\n\tassign busy_ball = !(state == STATE_0);\n\t\nendmodule\n",
        "module_name": "FSM_Bola",
        "module_hash": "86fbf6d38cccab23e98d8caa0b48e5f2",
        "dataset_index": 22876
      },
      "fifo_5440a7a4": {
        "rtl_code": "module fifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    empty,\n    full,\n    q,\n    usedw\n);\n\ninput aclr;\ninput clock;\ninput [29:0] data;\ninput rdreq;\ninput wrreq;\noutput empty;\noutput full;\noutput [29:0] q;\noutput [4:0] usedw;\n\nreg [29:0] mem [31:0];\nreg [4:0] usedw_reg;\nreg empty_reg;\nreg full_reg;\nreg [29:0] q_reg;\nreg [4:0] write_ptr_reg;\nreg [4:0] read_ptr_reg;\n\nalways @(posedge clock) begin\n    if (aclr == 1'b0) begin\n        // Asynchronous clear\n        empty_reg <= 1'b1;\n        full_reg <= 1'b0;\n        usedw_reg <= 5'b00000;\n        q_reg <= 30'b0;\n        write_ptr_reg <= 5'b00000;\n        read_ptr_reg <= 5'b00000;\n    end else begin\n        // Write operation\n        if (wrreq == 1'b1 && full_reg == 1'b0) begin\n            mem[write_ptr_reg] <= data;\n            write_ptr_reg <= write_ptr_reg + 1;\n            usedw_reg <= usedw_reg + 1;\n            if (write_ptr_reg == 5'b11111) begin\n                write_ptr_reg <= 5'b00000;\n            end\n            if (usedw_reg == 5'b10000) begin\n                full_reg <= 1'b1;\n            end\n            empty_reg <= 1'b0;\n        end\n        // Read operation\n        if (rdreq == 1'b1 && empty_reg == 1'b0) begin\n            q_reg <= mem[read_ptr_reg];\n            read_ptr_reg <= read_ptr_reg + 1;\n            usedw_reg <= usedw_reg - 1;\n            if (read_ptr_reg == 5'b11111) begin\n                read_ptr_reg <= 5'b00000;\n            end\n            if (usedw_reg == 5'b00000) begin\n                empty_reg <= 1'b1;\n            end\n            full_reg <= 1'b0;\n        end\n    end\nend\n\nassign empty = empty_reg;\nassign full = full_reg;\nassign q = q_reg;\nassign usedw = usedw_reg;\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "5440a7a4b78bd8bda6e6ebae9edfddb8",
        "dataset_index": 5480
      },
      "barrel_shifter_a2156aea": {
        "rtl_code": "module barrel_shifter(\n    input [7:0] in,\n    input [2:0] shift,\n    output [7:0] out\n);\n\nwire [7:0] shifted;\n\nassign shifted = (shift[2]) ? 8'b0 : (shift[1]) ? {in[0], in[7:1]} : (shift[0]) ? {in[1:0], in[7:2]} : {in[2:0], in[7:3]};\n\nassign out = shifted;\n\nendmodule\n\n\nmodule binary_tree_adder(\n    input [7:0] in,\n    output [7:0] out\n);\n\nwire [7:0] sum;\n\nassign sum[0] = in[0];\n\nassign sum[1] = in[0] + in[1];\n\nassign sum[2] = in[2] + in[3];\n\nassign sum[3] = in[0] + in[1] + in[2] + in[3];\n\nassign sum[4] = in[4] + in[5];\n\nassign sum[5] = in[4] + in[5] + in[6] + in[7];\n\nassign sum[6] = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7];\n\nassign out = sum[6];\n\nendmodule\n\n\nmodule addictive_control_logic(\n    input [7:0] in,\n    input select,\n    output [7:0] out\n);\n\nwire [7:0] shifted;\nwire [7:0] sum;\n\nbarrel_shifter bs(\n    .in(in),\n    .shift({select, 2'b00}),\n    .out(shifted)\n);\n\nbinary_tree_adder bta(\n    .in(in),\n    .out(sum)\n);\n\nassign out = (select) ? sum : shifted;\n\nendmodule\n\n\nmodule top_module( \n    input [7:0] in,\n    input select,\n    output [7:0] out\n);\n\naddictive_control_logic acl(\n    .in(in),\n    .select(select),\n    .out(out)\n);\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "a2156aeac6b106c15b1055d790ca5317",
        "dataset_index": 14460
      },
      "PIO_TO_CTRL_b7ee329a": {
        "rtl_code": "\n\nmodule PIO_TO_CTRL    (\n\n                        clk,\n                        rst_n,\n\n                        req_compl_i,\n                        compl_done_i,\n\n                        cfg_to_turnoff,\n                        cfg_turnoff_ok\n\n                        );\n\n    input               clk;\n    input               rst_n;\n\n    input               req_compl_i;\n    input               compl_done_i;\n\n    input               cfg_to_turnoff;\n    output              cfg_turnoff_ok;\n\n    reg                 trn_pending;\n    reg                 cfg_turnoff_ok;\n\n\n   always @ ( posedge clk or negedge rst_n ) begin\n\n        if (!rst_n ) begin\n\n          trn_pending <= 0;\n\n        end else begin\n\n          if (!trn_pending && req_compl_i)\n\n            trn_pending <= 1'b1;\n\n          else if (compl_done_i)\n\n            trn_pending <= 1'b0;\n\n        end\n\n    end\n\n    always @ ( posedge clk or negedge rst_n ) begin\n\n      if (!rst_n ) begin\n\n        cfg_turnoff_ok <= 1'b0;\n\n      end else begin\n\n        if ( cfg_to_turnoff  && !trn_pending)\n          cfg_turnoff_ok <= 1'b1;\n        else\n          cfg_turnoff_ok <= 1'b0;\n\n      end\n\n    end\n\n\nendmodule ",
        "module_name": "PIO_TO_CTRL",
        "module_hash": "b7ee329a107de51692420247dc76a1dc",
        "dataset_index": 5941
      },
      "FIFO_image_filter_img_4_cols_V_shiftReg_ce4ba415": {
        "rtl_code": "module FIFO_image_filter_img_4_cols_V_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 32'd12;\nparameter ADDR_WIDTH = 32'd2;\nparameter DEPTH = 32'd3;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\n    begin\n        if (ce)\n        begin\n            for (i=0;i<DEPTH-1;i=i+1)\n                SRL_SIG[i+1] <= SRL_SIG[i];\n            SRL_SIG[0] <= data;\n        end\n    end\n\nassign q = SRL_SIG[a];\n\nendmodule",
        "module_name": "FIFO_image_filter_img_4_cols_V_shiftReg",
        "module_hash": "ce4ba4158e67c27899258c9cca971910",
        "dataset_index": 21051
      },
      "FSM_INPUT_ENABLE_4ab1e80a": {
        "rtl_code": "\n\n\n\nmodule FSM_INPUT_ENABLE(\n\tinput wire clk,\n\tinput wire rst,\n\tinput wire init_OPERATION,\n\n\toutput reg enable_input_internal,\n\toutput wire enable_Pipeline_input,\n\toutput reg enable_shift_reg\n\n    );\n\n\nparameter [3:0] State0 = 3'd0,\n\n\tState1 = 3'd1,\n\n\tState2 = 3'd2,\n\n\tState3 = 3'd3,\n\n\tState4 = 3'd4,\n\n\tState5= 3'd5,\n\n\tState6 = 3'd6,\n\n\tState7 = 3'd7;\n\n\nreg [2:0] state_reg, state_next;\n\nalways @(posedge clk, posedge rst)\n\tif(rst)\n\t\tstate_reg <= State0;\n\telse\n\t\tstate_reg <= state_next;\n\nalways @*\n\tbegin\n\t\t\tstate_next = state_reg; enable_input_internal=1; enable_shift_reg = 0;\n\tcase(state_reg)\n\n\t\tState0:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=1;\n\t\t\t\tenable_shift_reg = 0;\n\t\t\t\tif(init_OPERATION)\n\t\t\t\t\tstate_next = State1; else begin\n\t\t\t\t\tstate_next = State0; end\n\n\t\t\tend\n\n\t\tState1:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=1;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State2;\n\t\t\tend\n\n\t\tState2:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=1;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State3;\n\t\t\tend\n\n\t\tState3:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=0;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State4;\n\t\t\tend\n\n\t\tState4:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=0;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State5;\n\t\t\tend\n\n\t\tState5:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=0;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State0;\n\t\t\tend\n\n\t\tdefault:\n\t\t\tbegin\n\t\t\t\tstate_next =State0;\n\n\t\t\tend\n\tendcase\nend\n\n\nassign  enable_Pipeline_input = enable_input_internal & init_OPERATION;\n\nendmodule\n",
        "module_name": "FSM_INPUT_ENABLE",
        "module_hash": "4ab1e80a5d32eb287cad6ad35f37bd55",
        "dataset_index": 25445
      },
      "alupipe_6190c0c7": {
        "rtl_code": "\n\nmodule alupipe(S, abus, bbus, clk, Cin, dbus);\n  input [31:0] abus;\n  input [31:0] bbus;\n  input clk;\n  input [2:0] S;\n  input Cin;\n  output [31:0] dbus;\n  wire [31:0] aInput;wire [31:0] bInput;wire [31:0] dInput;alu32 ALU(.a(aInput), .b(bInput), .Cin(Cin), .d(dInput), .S(S));\n  DflipFlop AFF(.dataIn(abus), .dataOut(aInput), .clk(clk));\n  DflipFlop BFF(.dataIn(bbus), .dataOut(bInput), .clk(clk));\n  DflipFlop DFF(.dataIn(dInput), .dataOut(dbus), .clk(clk));\n  \nendmodule\nmodule DflipFlop(dataIn, clk, dataOut);\n  input [31:0] dataIn;\n  input clk;\n  output [31:0] dataOut;\n  reg [31:0] dataOut;\n  always @(posedge clk) begin\n    dataOut = dataIn;\n  end\nendmodule\n\nmodule alu32 (d, Cout, V, a, b, Cin, S);\n  output[31:0] d;output Cout, V;input [31:0] a, b;input Cin;input [2:0] S;wire [31:0] c, g, p;\n  wire gout, pout;\n  \n  alu_cell mycell[31:0] (\n     .d(d),\n     .g(g),\n     .p(p),\n     .a(a),\n     .b(b),\n     .c(c),\n     .S(S)\n  );\n  \n  lac5 lac(\n     .c(c),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(g),\n     .p(p)\n  );\n  \n  overflow ov(\n     .Cout(Cout),\n     .V(V),\n     .g(gout),\n     .p(pout),\n     .c31(c[31]),\n     .Cin(Cin)\n  );\nendmodule\n\nmodule alu_cell (d, g, p, a, b, c, S);\n  output d, g, p;\n  input a, b, c;\n  input [2:0] S;\n  reg g,p,d,cint,bint;\n  \n  always @(a,b,c,S,p,g) begin \n    bint = S[0] ^ b;\n    g = a & bint;\n    p = a ^ bint;\n    cint = S[1] & c;\n   \n  if(S[2]==0)\n    begin\n      d = p ^ cint;\n    end\n    \n  else if(S[2]==1)\n    begin\n      if((S[1]==0) & (S[0]==0)) begin\n        d = a | b;\n      end\n      else if ((S[1]==0) & (S[0]==1)) begin\n        d = ~(a|b);\n      end\n      else if ((S[1]==1) & (S[0]==0)) begin\n        d = a&b;\n      end\n      else\n        d = 1;\n      end\n    end\nendmodule\n\nmodule overflow (Cout, V, g, p, c31, Cin);\n  output Cout, V;\n  input g, p, c31, Cin;\n  \n  assign Cout = g|(p&Cin);\n  assign V = Cout^c31;\nendmodule\n\nmodule lac(c, gout, pout, Cin, g, p);\n  output [1:0] c;\n  output gout;\n  output pout;\n  input Cin;\n  input [1:0] g;\n  input [1:0] p;\n\n  assign c[0] = Cin;\n  assign c[1] = g[0] | ( p[0] & Cin );\n  assign gout = g[1] | ( p[1] & g[0] );\n  assign pout = p[1] & p[0];\n  \nendmodule\n\nmodule lac2 (c, gout, pout, Cin, g, p);\n  output [3:0] c;\n  output gout, pout;\n  input Cin;\n  input [3:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac leaf0(\n     .c(c[1:0]),\n     .gout(gint[0]),\n     .pout(pint[0]),\n     .Cin(cint[0]),\n     .g(g[1:0]),\n     .p(p[1:0])\n  );\n  \n  lac leaf1(\n     .c(c[3:2]),\n     .gout(gint[1]),\n     .pout(pint[1]),\n     .Cin(cint[1]),\n     .g(g[3:2]),\n     .p(p[3:2])\n  );\n  \n  lac root(\n     .c(cint),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(gint),\n     .p(pint)\n  );\nendmodule\n\nmodule lac3 (c, gout, pout, Cin, g, p);\n  output [7:0] c;\n  output gout, pout;\n  input Cin;\n  input [7:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac2 leaf0(\n     .c(c[3:0]),\n     .gout(gint[0]),\n     .pout(pint[0]),\n     .Cin(cint[0]),\n     .g(g[3:0]),\n     .p(p[3:0])\n  );\n  \n  lac2 leaf1(\n     .c(c[7:4]),\n     .gout(gint[1]),\n     .pout(pint[1]),\n     .Cin(cint[1]),\n     .g(g[7:4]),\n     .p(p[7:4])\n  );\n  \n  lac root(\n     .c(cint),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(gint),\n     .p(pint)\n  );\nendmodule\n\nmodule lac4 (c, gout, pout, Cin, g, p);\n  output [15:0] c;\n  output gout, pout;\n  input Cin;\n  input [15:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac3 leaf0(\n      .c(c[7:0]),\n      .gout(gint[0]),\n      .pout(pint[0]),\n      .Cin(cint[0]),\n      .g(g[7:0]),\n      .p(p[7:0])\n  );\n  \n  lac3 leaf1(\n      .c(c[15:8]),\n      .gout(gint[1]),\n      .pout(pint[1]),\n      .Cin(cint[1]),\n      .g(g[15:8]),\n      .p(p[15:8])\n  );\n  \n  lac root(\n  .c(cint),\n  .gout(gout),\n  .pout(pout),\n  .Cin(Cin),\n  .g(gint),\n  .p(pint)\n  );\nendmodule\n\nmodule lac5 (c, gout, pout, Cin, g, p);\n  output [31:0] c;\n  output gout, pout;\n  input Cin;\n  input [31:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac4 leaf0(\n      .c(c[15:0]),\n      .gout(gint[0]),\n      .pout(pint[0]),\n      .Cin(cint[0]),\n      .g(g[15:0]),\n      .p(p[15:0])\n  );\n  \n  lac4 leaf1(\n      .c(c[31:16]),\n      .gout(gint[1]),\n      .pout(pint[1]),\n      .Cin(cint[1]),\n      .g(g[31:16]),\n      .p(p[31:16])\n  );\n  \n  lac root(\n     .c(cint),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(gint),\n     .p(pint)\n  );\nendmodule\n",
        "module_name": "alupipe",
        "module_hash": "6190c0c71a2b47eada25eb7dfc596aa6",
        "dataset_index": 21986
      },
      "sky130_fd_sc_ms__a21bo_b2f1f06e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__a21bo (\n    X   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    wire nand0_out  ;\n    wire nand1_out_X;\n\n    nand nand0 (nand0_out  , A2, A1         );\n    nand nand1 (nand1_out_X, B1_N, nand0_out);\n    buf  buf0  (X          , nand1_out_X    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__a21bo",
        "module_hash": "b2f1f06e07aaf8e31ea762e3fb6f27e2",
        "dataset_index": 21843
      },
      "cmac_padding_a4b4175f": {
        "rtl_code": "\nmodule cmac_padding(\n  input [6:0] length,\n  input [127:0] block_in,\n  output [127:0] block_out\n);\n\n  reg [127:0] mask;\n  reg [127:0] masked_data;\n  reg [127:0] padded_data;\n\n  // Generate bitmask used to add zeros to part of block not being data.\n  always @(*)\n  begin\n    mask = 127'b0;\n    if (length[0])\n      mask = {1'b1, mask[127:1]};\n    if (length[1])\n      mask = {2'h3, mask[127:2]};\n    if (length[2])\n      mask = {4'hf, mask[127:4]};\n    if (length[3])\n      mask = {8'hff, mask[127:8]};\n    if (length[4])\n      mask = {16'hffff, mask[127:16]};\n    if (length[5])\n      mask = {32'hffffffff, mask[127:32]};\n    if (length[6])\n      mask = {64'hffffffff_ffffffff, mask[127:64]};\n  end\n\n  // Pad the block by setting the first non-data bit after the data to 1.\n  always @(*)\n  begin\n    masked_data = block_in & mask;\n    padded_data = masked_data;\n    padded_data[(127 - length)] = 1'b1;\n  end\n\n  assign block_out = padded_data;\n\nendmodule",
        "module_name": "cmac_padding",
        "module_hash": "a4b4175f3b4dcba45ba1362c5a7b71a6",
        "dataset_index": 20947
      },
      "sky130_fd_sc_hs__nand4_3d9c6b6f": {
        "rtl_code": "module sky130_fd_sc_hs__nand4(\n    input A,\n    input B,\n    input C,\n    input D,\n    input VPWR,\n    input VGND,\n    output Y\n);\n\n    // Create internal signals\n    wire nand1;\n    wire nand2;\n    wire nand3;\n\n    // Implement NAND gate\n    assign nand1 = ~(A & B);\n    assign nand2 = ~(C & D);\n    assign nand3 = ~(nand1 & nand2);\n    assign Y = nand3;\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__nand4",
        "module_hash": "3d9c6b6f571088f09d89a4900efdb97e",
        "dataset_index": 3197
      },
      "comparator_bc3f7fd6": {
        "rtl_code": "module comparator (\n    input [15:0] A,\n    input [15:0] B,\n    output reg out\n);\n\n    always @(*) begin\n        if (A > B) begin\n            out = 1'b1;\n        end else if (A < B) begin\n            out = 1'b0;\n        end else begin\n            out = 1'b0;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "bc3f7fd60da28f280e2e4ce8578a7f99",
        "dataset_index": 21014
      },
      "FB_RejectArmController_039ae765": {
        "rtl_code": "`define STATE_Clear 0\n`define STATE_AwaitCanister 1\n`define STATE_GoReject 2\n\n\nmodule FB_RejectArmController \n\n(\n\t\tinput wire clk,\n\t\t\n\t\tinput wire RejectCanister_eI,\n\t\tinput wire LasersChanged_eI,\n\t\t\n\t\toutput wire GoRejectArm_eO,\n\t\t\n\t\tinput wire  RejectSiteLaser_I,\n\t\t\n\t\t\n\n\t\tinput reset\n);\n\n\nwire RejectCanister;\nassign RejectCanister = RejectCanister_eI;\nwire LasersChanged;\nassign LasersChanged = LasersChanged_eI;\n\nreg GoRejectArm;\nassign GoRejectArm_eO = GoRejectArm;\n\nreg  RejectSiteLaser ;\n\n\nreg [1:0] state = `STATE_Clear;\nreg entered = 1'b0;\nalways@(posedge clk) begin\n\n\tif(reset) begin\n\t\tstate = `STATE_Clear;\n\n\t\tGoRejectArm = 1'b0;\n\t\t\n\t\tRejectSiteLaser = 0;\n\t\t\n\t\tend else begin\n\n\t\tGoRejectArm = 1'b0;\n\t\t\n\t\tif(LasersChanged) begin \n\t\t\tRejectSiteLaser = RejectSiteLaser_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tentered = 1'b0;\n\t\tcase(state) \n\t\t\t`STATE_Clear: begin\n\t\t\t\tif(RejectCanister) begin\n\t\t\t\t\tstate = `STATE_AwaitCanister;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\t`STATE_AwaitCanister: begin\n\t\t\t\tif(LasersChanged && RejectSiteLaser) begin\n\t\t\t\t\tstate = `STATE_GoReject;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\t`STATE_GoReject: begin\n\t\t\t\tif(RejectCanister) begin\n\t\t\t\t\tstate = `STATE_AwaitCanister;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\tdefault: begin\n\t\t\t\tstate = 0;\n\t\t\tend\n\t\tendcase\n\t\tif(entered) begin\n\t\t\tcase(state)\n\t\t\t\t`STATE_Clear: begin\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\t`STATE_AwaitCanister: begin\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\t`STATE_GoReject: begin\n\t\t\t\t\tGoRejectArm = 1'b1;\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\tdefault: begin\n\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\tend\nend\nendmodule",
        "module_name": "FB_RejectArmController",
        "module_hash": "039ae765684530144d67d3881929bcf4",
        "dataset_index": 22023
      },
      "i2s_tx #_7e585892": {
        "rtl_code": "module i2s_tx #(parameter DATA_WIDTH = 16\n\t\t\t\t) (clk, left_chan, right_chan, sdata, lrclk, mck, sck);\n\ninput wire clk; input wire [DATA_WIDTH-1:0] left_chan;\ninput wire [DATA_WIDTH-1:0] right_chan;\noutput reg sdata; initial sdata <= 1'b0;\n\noutput wire mck, sck, lrclk;\nreg [9:0]  mck_div; initial mck_div<=10'd0;\n\n\n\nparameter LR_BIT = 7; parameter SCK_BIT = LR_BIT - 6; parameter MCK_BIT = 0;\n\n\nassign mck   = mck_div[MCK_BIT];\nassign lrclk = mck_div[LR_BIT];\nassign sck   = mck_div[SCK_BIT];\n\nreg lrclk_prev; initial lrclk_prev <= 1'b1;\nwire lrclk_change = ~(lrclk_prev == lrclk);\nreg [DATA_WIDTH-1:0] ch_data; initial ch_data <= {DATA_WIDTH{1'b0}};\nreg sck_prev; initial sck_prev <= 1'b0;\nwire sck_neg = (sck_prev==1'b1 && sck==1'b0);\n\nreg [31:0] fake_data; initial fake_data <= 32'd0;\nwire [31:0] sgnd_data = fake_data - 32'b10000000000000000000000000000000;always @(posedge clk) begin\n\tmck_div <= mck_div + 1'b1;\n\tlrclk_prev <= lrclk;\n\tsck_prev <= sck;\n\t\n\tif (sck_neg) begin\n\t\tif (lrclk_change) begin\n\t\t\tch_data <= sgnd_data;\n\t\t\tfake_data <= fake_data + 32'd178956972; end else begin\n\t\t\tch_data <= ch_data << 1;\n\t\tend\n\t\tsdata <= ch_data[DATA_WIDTH-1];\n\tend\n\t\n\t\nend\n\nendmodule\n",
        "module_name": "i2s_tx #",
        "module_hash": "7e5858925029f489b1283a10106a85db",
        "dataset_index": 24435
      },
      "Concat_1883d4cf": {
        "rtl_code": "module Concat(\n    input clock,\n    input ready,\n\n\toutput reg  listA_req,\n    input       listA_ack,\n    input [7:0] listA_value,\n    input       listA_value_valid,\n\n\toutput reg  listB_req,\n    input       listB_ack,\n    input [7:0] listB_value,\n    input       listB_value_valid,\n\n\tinput            req,\n\toutput reg       ack,\n\toutput reg [7:0] value,\n\toutput reg       value_valid\n    );\n\n    reg lastSelectA;\n    wire selectA;\n    assign selectA = lastSelectA & (listA_ack ? listA_value_valid : 1'b1);\n\n    always @(posedge clock) begin\n        if(ready)\n            lastSelectA <= selectA;\n        else\n            lastSelectA <= 1;\n    end\n\n    always @(*) begin\n        if(selectA) begin\n            listA_req = req;\n            ack = listA_ack;\n            value = listA_value;\n            value_valid = listA_value_valid;\n            listB_req = 0;\n\n        end else begin\n            listB_req = req;\n            ack = listB_ack;\n            value = listB_value;\n            value_valid = listB_value_valid;\n            listA_req = 0;\n        end\n    end\nendmodule\n\nmodule Cons(\n    input clock,\n    input ready,\n    input [7:0] head,\n\n\toutput reg  tail_req,\n    input       tail_ack,\n    input [7:0] tail_value,\n    input       tail_value_valid,\n\n\tinput            req,\n\toutput reg       ack,\n\toutput reg [7:0] value,\n    output reg       value_valid\n    );\n\n    reg headShown;\n    reg selectHead;\n    reg lastReq;\n    reg headAck;\n\n    always @(posedge clock) begin\n        lastReq <= req;\n\n        if(ready) begin\n            if(~lastReq & req) begin\n                headAck <= 1;\n                headShown <= 1;\n\n                if(headShown)\n                    selectHead <= 0;\n\n            end else begin\n                headAck <= 0;\n            end\n\n        end else begin\n            headShown <= 0;\n            selectHead <= 1;\n            headAck <= 0;\n        end\n    end\n\n    always @(*) begin\n        if(selectHead) begin\n            ack = headAck;\n            value = head;\n            value_valid = 1;\n            tail_req = 0;\n\n        end else begin\n            tail_req = req;\n            ack = tail_ack;\n            value = tail_value;\n            value_valid = tail_value_valid;\n        end\n    end\nendmodule\n\nmodule Hold(\n    input clock,\n    input ready,\n    input x,\n    output reg y\n    );\n\n    always @(posedge clock)\n        y <= ready ? y | x : 0;\nendmodule\n\nmodule ListMux(\n    input ready,\n    input cond,\n    input            out_req,\n    output reg       out_ack,\n    output reg [7:0] out_value,\n    output reg       out_value_valid,\n\n    output reg       true_req,\n    input            true_ack,\n    input [7:0]      true_value,\n    input            true_value_valid,\n\n    output reg       false_req,\n    input            false_ack,\n    input [7:0]      false_value,\n    input            false_value_valid\n    );\n\n    always @(*) begin\n        if(~ready) begin\n            true_req = 1'b0;\n            false_req = 1'b0;\n            out_ack = 1'b0;\n            out_value = 8'hFF;\n            out_value_valid = 1'b0;\n\n        end else if(cond) begin\n            true_req = out_req;\n            out_ack = true_ack;\n            out_value = true_value;\n            out_value_valid = true_value_valid;\n\n            false_req = 1'b0;\n\n        end else begin\n            false_req = out_req;\n            out_ack = false_ack;\n            out_value = false_value;\n            out_value_valid = false_value_valid;\n\n            true_req = 1'b0;\n        end\n    end\nendmodule\n\nmodule Decons(\n    input clock,\n    input ready,\n    output reg  done,\n\n\toutput reg  list_req,\n    input       list_ack,\n    input [7:0] list_value,\n    input       list_value_valid,\n\n    output reg [7:0] head,\n    output reg       head_valid,\n\n\tinput            tail_req,\n\toutput reg       tail_ack,\n\toutput reg [7:0] tail_value,\n    output reg       tail_value_valid\n    );\n\n    reg nextDone;\n\n    always @(posedge clock) begin\n        if(ready) begin\n            done <= done | nextDone;\n\n            if(~done & list_ack) begin\n                nextDone <= 1'b1;\n                head <= list_value;\n                head_valid <= list_value_valid;\n            end else begin\n                nextDone <= 1'b0;\n            end\n\n        end else begin\n            done <= 1'b0;\n            nextDone <= 1'b0;\n            head <= 8'hFF;\n            head_valid = 1'b0;\n        end\n    end\n\n    always @(*) begin\n        list_req = ready & ~done;\n\n        if(done) begin\n            list_req = tail_req;\n            tail_ack = list_ack;\n            tail_value = list_value;\n            tail_value_valid = list_value_valid;\n        end else begin\n            list_req = ready & ~nextDone;\n            tail_ack = 1'b0;\n            tail_value = 8'hFF;\n            tail_value_valid = 1'b0;\n        end\n    end\nendmodule\n",
        "module_name": "Concat",
        "module_hash": "1883d4cf8cd09d85daa8c93c730a0103",
        "dataset_index": 22288
      },
      "decoder_de40ece4": {
        "rtl_code": "module decoder (\n    input [1:0] SEL,\n    output reg [15:0] OUT\n);\n\n    always @(*) begin\n        case(SEL)\n            2'b00: OUT = 16'b0000000000000001;\n            2'b01: OUT = 16'b0000000000000010;\n            2'b10: OUT = 16'b0000000000000100;\n            2'b11: OUT = 16'b0000000000001000;\n        endcase\n    end\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "de40ece4f8bd1250dc2e07506feff7d1",
        "dataset_index": 7529
      },
      "AGC_9b609e7b": {
        "rtl_code": "module AGC (\n  input [15:0] input_signal,\n  input [7:0] control_signal,\n  output [15:0] output_signal\n);\n\nparameter gain_bits = 8; // number of bits used to represent the gain value\n\nreg [gain_bits-1:0] gain_value; // binary value representing the gain\nreg [15:0] adjusted_signal; // signal with constant output level\n\n// Function to adjust the gain based on the control signal\nfunction [gain_bits-1:0] adjust_gain;\n  input [7:0] control;\n  begin\n    case (control)\n      8'h00: adjust_gain = 8'h00; // no gain adjustment\n      8'h01: adjust_gain = 8'h01; // small gain increase\n      8'h02: adjust_gain = 8'h02;\n      8'h03: adjust_gain = 8'h03;\n      8'h04: adjust_gain = 8'h04;\n      8'h05: adjust_gain = 8'h05;\n      8'h06: adjust_gain = 8'h06;\n      8'h07: adjust_gain = 8'h07;\n      8'h08: adjust_gain = 8'h08; // maximum gain increase\n      8'h09: adjust_gain = 8'h09; // no gain adjustment\n      8'h0A: adjust_gain = 8'h0A;\n      8'h0B: adjust_gain = 8'h0B;\n      8'h0C: adjust_gain = 8'h0C;\n      8'h0D: adjust_gain = 8'h0D;\n      8'h0E: adjust_gain = 8'h0E;\n      8'h0F: adjust_gain = 8'h0F;\n      8'h10: adjust_gain = 8'h10; // maximum gain reduction\n      8'h11: adjust_gain = 8'h11; // no gain adjustment\n      8'h12: adjust_gain = 8'h12;\n      8'h13: adjust_gain = 8'h13;\n      8'h14: adjust_gain = 8'h14;\n      8'h15: adjust_gain = 8'h15;\n      8'h16: adjust_gain = 8'h16;\n      8'h17: adjust_gain = 8'h17;\n      8'h18: adjust_gain = 8'h18; // small gain reduction\n      default: adjust_gain = 8'h00; // no gain adjustment\n    endcase\n  end\nendfunction\n\n// Assign the gain value based on the control signal\nalways @ (control_signal) begin\n  gain_value = adjust_gain(control_signal);\nend\n\n// Compute the adjusted signal with constant output level\nalways @ (input_signal, gain_value) begin\n  adjusted_signal = input_signal * gain_value;\nend\n\n// Assign the output signal\nassign output_signal = adjusted_signal;\n\nendmodule",
        "module_name": "AGC",
        "module_hash": "9b609e7bef60b6ef2ba3aa26a7a5fa35",
        "dataset_index": 342
      },
      "dffr_a7bbd5c3": {
        "rtl_code": "module dffr (din, clk, rst, q, se, si, so);\n\nparameter SIZE = 1;\n\ninput\t[SIZE-1:0]\tdin ;\t// data in\ninput\t\t\tclk ;\t// clk or scan clk\ninput\t\t\trst ;\t// reset\n\noutput\t[SIZE-1:0]\tq ;\t// output\n\ninput\t\t\tse ;\t// scan-enable\ninput\t[SIZE-1:0]\tsi ;\t// scan-input\noutput\t[SIZE-1:0]\tso ;\t// scan-output\n\nreg \t[SIZE-1:0]\tq ;\n\nalways @ (posedge clk)\n\tif (se) begin\n\t\tq[SIZE-1:0] <= si[SIZE-1:0];\n\tend else begin\n\t\tif (rst) begin\n\t\t\tq[SIZE-1:0] <= {SIZE{1'b0}};\n\t\tend else begin\n\t\t\tq[SIZE-1:0] <= din[SIZE-1:0];\n\t\tend\n\tend\n\nassign so[SIZE-1:0] = q[SIZE-1:0] ;\n\nendmodule",
        "module_name": "dffr",
        "module_hash": "a7bbd5c313300a2369d68d85a6c7e654",
        "dataset_index": 16446
      },
      "top__a50802c2": {
        "rtl_code": "\nmodule top_module (\n    input clk, // Clock input\n    input reset, // Synchronous active-high reset\n    input ce, // Clock enable for the counter\n    input ctrl, // Control signal for the counter\n    output reg [11:0] out // 12-bit output from the combined modules\n);\n\nwire [3:0] counter_out;\nwire [15:0] decoder_out;\n\ncounter cnt (\n    .clk(clk),\n    .rst_n(reset),\n    .ce(ce),\n    .ctrl(ctrl),\n    .count(counter_out)\n);\n\ndecoder dec (\n    .SEL(counter_out[1:0]),\n    .OUT(decoder_out)\n);\n\nalways @(*) begin\n    out <= decoder_out[11:0];\nend\n\nendmodule\nmodule counter (\n    input clk,\n    input rst_n,\n    input ce,\n    input ctrl,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge rst_n) begin\n    if (rst_n) begin\n        count <= 4'b0;\n    end else if (ce) begin\n        if (ctrl) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule\nmodule decoder (\n    input [1:0] SEL,\n    output reg [15:0] OUT\n);\n\nalways @(*) begin\n    case (SEL)\n        2'b00: OUT = 16'b0000_0000_0000_0001;\n        2'b01: OUT = 16'b0000_0000_0000_0010;\n        2'b10: OUT = 16'b0000_0000_0000_0100;\n        2'b11: OUT = 16'b0000_0000_0000_1000;\n        default: OUT = 16'b0000_0000_0000_0000;\n    endcase\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "a50802c2c1d34c23139219c1ae77b906",
        "dataset_index": 10839
      },
      "shift_register_with_parallel_load_e4c6fd7b": {
        "rtl_code": "module shift_register_with_parallel_load (\n  input clk,\n  input load,\n  input direction,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      q <= data;\n    end else begin\n      if (direction) begin\n        q <= {1'b0, q[511:1]};\n      end else begin\n        q <= {q[510:0], 1'b0};\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "shift_register_with_parallel_load",
        "module_hash": "e4c6fd7b642ca87f6cf15012a6ce53a4",
        "dataset_index": 19175
      },
      "uart_tx_e0975592": {
        "rtl_code": "module uart_tx(\n  input clk,\n  input reset_n,\n  input clk_en,\n  input begintransfer,\n  input tx_wr_strobe,\n  input status_wr_strobe,\n  input do_force_break,\n  input [7:0] tx_data,\n  input [15:0] baud_divisor,\n  output tx_overrun,\n  output tx_ready,\n  output tx_shift_empty,\n  output txd\n);\n\n  reg baud_clk_en;\n  reg [15:0] baud_rate_counter;\n  wire baud_rate_counter_is_zero;\n  reg do_load_shifter;\n  wire do_shift;\n  reg pre_txd;\n  wire shift_done;\n  wire [9:0] tx_load_val;\n  reg tx_overrun;\n  reg tx_ready;\n  reg tx_shift_empty;\n  wire tx_shift_reg_out;\n  wire [9:0] tx_shift_register_contents;\n  wire tx_wr_strobe_onset;\n  reg txd;\n  reg [9:0] unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out;\n  wire [9:0] unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_in;\n\n  assign tx_wr_strobe_onset = tx_wr_strobe && begintransfer;\n  assign tx_load_val = {{1 {1'b1}}, tx_data, 1'b0};\n  assign shift_done = ~(|tx_shift_register_contents);\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      do_load_shifter <= 0;\n    end else if (clk_en) begin\n      do_load_shifter <= (~tx_ready) && shift_done;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      tx_ready <= 1'b1;\n    end else if (clk_en) begin\n      if (tx_wr_strobe_onset) begin\n        tx_ready <= 0;\n      end else if (do_load_shifter) begin\n        tx_ready <= -1;\n      end\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      tx_overrun <= 0;\n    end else if (clk_en) begin\n      if (status_wr_strobe) begin\n        tx_overrun <= 0;\n      end else if (~tx_ready && tx_wr_strobe_onset) begin\n        tx_overrun <= -1;\n      end\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      tx_shift_empty <= 1'b1;\n    end else if (clk_en) begin\n      tx_shift_empty <= tx_ready && shift_done;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      baud_rate_counter <= 0;\n    end else if (clk_en) begin\n      if (baud_rate_counter_is_zero || do_load_shifter) begin\n        baud_rate_counter <= baud_divisor;\n      end else begin\n        baud_rate_counter <= baud_rate_counter - 1;\n      end\n    end\n  end\n\n  assign baud_rate_counter_is_zero = baud_rate_counter == 0;\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      baud_clk_en <= 0;\n    end else if (clk_en) begin\n      baud_clk_en <= baud_rate_counter_is_zero;\n    end\n  end\n\n  assign do_shift = baud_clk_en  && (~shift_done) && (~do_load_shifter);\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      pre_txd <= 1;\n    end else if (~shift_done) begin\n      pre_txd <= tx_shift_reg_out;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      txd <= 1;\n    end else if (clk_en) begin\n      txd <= pre_txd & ~do_force_break;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out <= 0;\n    end else if (clk_en) begin\n      unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out <= unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_in;\n    end\n  end\n\n  assign unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_in = (do_load_shifter)? tx_load_val : (do_shift)? {1'b0, unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out[9 : 1]} : unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out;\n  assign tx_shift_register_contents = unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out;\n  assign tx_shift_reg_out = unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out[0];\n\nendmodule",
        "module_name": "uart_tx",
        "module_hash": "e09755920f72023cc84ffba2f8a98fad",
        "dataset_index": 11730
      },
      "nios_system_keys_978f0470": {
        "rtl_code": "module nios_system_keys (\n                          // inputs:\n                           address,\n                           clk,\n                           in_port,\n                           reset_n,\n\n                          // outputs:\n                           readdata\n                        )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  3: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  3: 0] data_in;\n  wire    [  3: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {4 {(address == 0)}} & data_in;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "nios_system_keys",
        "module_hash": "978f0470f46aeb8ac6fc609a4a2753f2",
        "dataset_index": 11939
      },
      "control_95e7038f": {
        "rtl_code": "module control(OP, CISEL, BSEL, OSEL, SHIFT_LA, SHIFT_LR, LOGICAL_OP); input  [2:0]  OP;\n\n  output        CISEL;\n\n  output \t\t BSEL;\n\n  output [1:0]\t OSEL;\n\n  output \t\t SHIFT_LA;\n\n  output \t\t SHIFT_LR;\n\n  output \t    LOGICAL_OP;\n\n\n  reg [1:0] OSEL;\n\n  reg SHIFT_LA;\n\n  reg SHIFT_LR;\n\n  reg LOGICAL_OP;\n\n  \n\n  localparam ADD = 3'b000;\n\n  localparam SUB = 3'b001;\n\n  localparam SRA = 3'b010;\n\n  localparam SRL = 3'b011;\n\n  localparam SLL = 3'b100;\n\n  localparam AND = 3'b101;\n\n  localparam OR = 3'b110;\n\n  \n\n  \n\n  assign CISEL = (OP == 3'b001) ? 1'b1 : 1'b0;\n\n  assign BSEL = (OP == 3'b001) ? 1'b1 : 1'b0;\n\n  \n\n  always @(*) begin\n\n\tcase (OP)\n\n\t\tADD: begin \n\n\t\t\t  OSEL = 2'b0;\n\n\t\t\t  SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSUB: begin\n\n\t\t\t  OSEL = 2'b0;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSRA: begin \n\n\t\t     OSEL = 2'b01;\n\n\t\t     SHIFT_LA = 1'b1;\n\n\t\t\t  SHIFT_LR = 1'b1;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSRL: begin \n\n\t\t\t  OSEL = 2'b01;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b1;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSLL: begin \n\n\t\t\t  OSEL = 2'b01;\n\n\t\t     SHIFT_LA = 1'b1;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tAND: begin \n\n\t\t     OSEL = 2'b10;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b1;\n\n\t\tend\n\n\t\tOR:  begin \n\n\t\t\t  OSEL = 2'b10;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tdefault: begin \n\n\t\t\t  OSEL = 2'b11;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\tendcase\n\n  end\n\n  \n\nendmodule\n",
        "module_name": "control",
        "module_hash": "95e7038ffb52943c98d996235305415a",
        "dataset_index": 13325
      },
      "decoder_4to16_ffc28ef4": {
        "rtl_code": "module decoder_4to16 (\n    input [3:0] ABCD,\n    output reg [15:0] Y\n);\n\nalways @(*) begin\n    case (ABCD)\n        4'b0000: Y = 16'b1111_1111_1111_1110;\n        4'b0001: Y = 16'b1111_1111_1111_1101;\n        4'b0010: Y = 16'b1111_1111_1111_1011;\n        4'b0011: Y = 16'b1111_1111_1111_0111;\n        4'b0100: Y = 16'b1111_1111_1110_1111;\n        4'b0101: Y = 16'b1111_1111_1101_1111;\n        4'b0110: Y = 16'b1111_1111_1011_1111;\n        4'b0111: Y = 16'b1111_1111_0111_1111;\n        4'b1000: Y = 16'b1111_1110_1111_1111;\n        4'b1001: Y = 16'b1111_1101_1111_1111;\n        4'b1010: Y = 16'b1111_1011_1111_1111;\n        4'b1011: Y = 16'b1111_0111_1111_1111;\n        4'b1100: Y = 16'b1110_1111_1111_1111;\n        4'b1101: Y = 16'b1101_1111_1111_1111;\n        4'b1110: Y = 16'b1011_1111_1111_1111;\n        4'b1111: Y = 16'b0111_1111_1111_1111;\n        default: Y = 16'b1111_1111_1111_1111;\n    endcase\nend\n\nendmodule",
        "module_name": "decoder_4to16",
        "module_hash": "ffc28ef465f19ad6b0010d1ec600ce5f",
        "dataset_index": 10280
      },
      "t_order_a_caaee7c1": {
        "rtl_code": "module t_order_a (\n   m_from_clk_lev1_r, n_from_clk_lev2, o_from_com_levs11,\n   o_from_comandclk_levs12,\n   clk, a_to_clk_levm3, b_to_clk_levm1, c_com_levs10, d_to_clk_levm2, one\n   );\n\n   input clk;\n   input [7:0] a_to_clk_levm3;\n   input [7:0] b_to_clk_levm1;\n   input [7:0] c_com_levs10;\n   input [7:0] d_to_clk_levm2;\n   input [7:0] one;\n   output [7:0] m_from_clk_lev1_r;\n   output [7:0] n_from_clk_lev2;\n   output [7:0] o_from_com_levs11;\n   output [7:0] o_from_comandclk_levs12;\n\n   \n   reg [7:0]            m_from_clk_lev1_r;\n   wire [7:0] a_to_clk_levm1;\n   wire [7:0] a_to_clk_levm2;\n   wire [7:0] c_com_levs11;\n   reg [7:0]  o_from_comandclk_levs12;\n   wire [7:0]  n_from_clk_lev2;\n   wire [7:0]  n_from_clk_lev3;\n\n   assign     a_to_clk_levm1 = a_to_clk_levm2 + d_to_clk_levm2;\n   assign     a_to_clk_levm2 = a_to_clk_levm3 + 0;\n\n   always @ (posedge clk) begin\n      m_from_clk_lev1_r <= a_to_clk_levm1 + b_to_clk_levm1;\n   end\n\n   assign c_com_levs11 = c_com_levs10 + one;\n   always @ (c_com_levs11 or n_from_clk_lev3) o_from_comandclk_levs12 = c_com_levs11 + n_from_clk_lev3;\n   assign n_from_clk_lev2 = m_from_clk_lev1_r;\n   assign n_from_clk_lev3 = n_from_clk_lev2;\n   wire [7:0] o_from_com_levs11 = c_com_levs10 + 1;\n\nendmodule\n",
        "module_name": "t_order_a",
        "module_hash": "caaee7c16509f713552ffbf5f32dc07e",
        "dataset_index": 19524
      },
      "simple_adder_e5dce54c": {
        "rtl_code": "module simple_adder (\n  input [3:0] a,\n  input [3:0] b,\n  output [4:0] sum\n);\n\n  assign sum = {1'b0, a} + {1'b0, b};\n\nendmodule",
        "module_name": "simple_adder",
        "module_hash": "e5dce54c6c4253c30066c3050eb5339b",
        "dataset_index": 9590
      },
      "ram_control_d7fb52a3": {
        "rtl_code": "\nmodule ram_control(\n    input clk,\n    input enable,\n    input [11:0] addrA,\n    input [11:0] addrB,\n    input [11:0] addrW,\n    input [8:0] dataIn,\n    output reg [8:0] dataOutA,\n    output reg [8:0] dataOutB\n);\n\nreg [8:0] dataOutA_reg;\nreg [8:0] dataOutB_reg;\n\nreg [8:0] ram [4095:0];\n\nalways @(posedge clk) begin\n    if (enable) begin\n        dataOutA <= ram[addrA];\n        dataOutB <= ram[addrB];\n        ram[addrW] <= dataIn;\n    end\nend\n\nendmodule",
        "module_name": "ram_control",
        "module_hash": "d7fb52a38e2017985dfad91aa202bf9e",
        "dataset_index": 16516
      },
      "mux_f7d19a27": {
        "rtl_code": "module mux (\n    input [3:0] D,\n    input EN,\n    input [1:0] SEL,\n    output reg Y\n);\n\nalways @ (SEL or D or EN) begin\n    if (EN) begin\n        case (SEL)\n            2'b00: Y = D[0];\n            2'b01: Y = D[1];\n            2'b10: Y = D[2];\n            2'b11: Y = D[3];\n        endcase\n    end else begin\n        Y = 0;\n    end\nend\n\nendmodule",
        "module_name": "mux",
        "module_hash": "f7d19a27e4692f136d25fa2907ba6c8e",
        "dataset_index": 13174
      },
      "mod_operator_57cde7eb": {
        "rtl_code": "\nmodule mod_operator (\n  input [31:0] A,\n  input [31:0] B,\n  output reg [31:0] result\n);\n\n  always @(*) begin\n    if (B == 0) begin\n      result = 0;\n    end else if (A < B) begin\n      result = A;\n    end else begin\n      result = A - (A / B) * B;\n    end\n  end\n\nendmodule",
        "module_name": "mod_operator",
        "module_hash": "57cde7ebdd30c665da904045bb0673ca",
        "dataset_index": 1344
      },
      "memory_aac0570a": {
        "rtl_code": "module memory (remapping_memory, full, rd_data, rd_clk, rd_en, rd_addr, reset);\n\n  parameter RD_DATA_WIDTH = 1;\n  parameter RD_ADDR_WIDTH = 2;\n  parameter MEM_DEPTH = 4;\n  \n  input wire [MEM_DEPTH-1:0] remapping_memory;\n  input wire full;\n  output reg [RD_DATA_WIDTH-1:0] rd_data;\n  input wire rd_clk, rd_en;\n  input wire [RD_ADDR_WIDTH-1:0] rd_addr;\n  input wire reset;\n  \n  reg [RD_DATA_WIDTH-1:0] memory [0:MEM_DEPTH-1];\n  integer i;\n  \n  always @(posedge full, posedge reset) begin\n    if(reset) begin\n      for(i=0; i<MEM_DEPTH; i=i+1) begin\n        memory[i] <= 0;\n      end\n    end else begin\n      for(i=0; i<MEM_DEPTH; i=i+1) begin\n        memory[i] <= remapping_memory[i];\n      end\n    end\n  end\n  \n  always @(posedge rd_clk, posedge reset) begin\n    if(reset) begin\n      rd_data <= 0;\n    end else begin\n      if(rd_en) begin\n        rd_data <= memory[rd_addr];\n      end\n    end\n  end\n  \nendmodule",
        "module_name": "memory",
        "module_hash": "aac0570ae0bf0ef1fd8bba8bd9fbbe20",
        "dataset_index": 16839
      },
      "min_max_tracker_619ed604": {
        "rtl_code": "module min_max_tracker(input clk, input [7:0] adc_d, input [7:0] threshold,\n\toutput [7:0] min, output [7:0] max);\n\n\treg [7:0] min_val = 255;\n\treg [7:0] max_val = 0;\n\treg [7:0] cur_min_val = 255;\n\treg [7:0] cur_max_val = 0;\n\treg [1:0] state = 0;\n\n\talways @(posedge clk)\n\tbegin\n\t\tcase (state)\n\t\t0:\n\t\t\tbegin\n\t\t\t\tif (cur_max_val >= ({1'b0, adc_d} + threshold))\n\t\t\t\t\tstate <= 2;\n\t\t\t\telse if (adc_d >= ({1'b0, cur_min_val} + threshold))\n\t\t\t\t\tstate <= 1;\n\t\t\t\tif (cur_max_val <= adc_d)\n\t\t\t\t\tcur_max_val <= adc_d;\n\t\t\t\telse if (adc_d <= cur_min_val)\n\t\t\t\t\tcur_min_val <= adc_d;\t\t\t\t\t\n\t\t\tend\n\t\t1:\n\t\t\tbegin\n\t\t\t\tif (cur_max_val <= adc_d)\n\t\t\t\t\tcur_max_val <= adc_d;\n\t\t\t\telse if (({1'b0, adc_d} + threshold) <= cur_max_val) begin\n\t\t\t\t\tstate <= 2;\n\t\t\t\t\tcur_min_val <= adc_d;\n\t\t\t\t\tmax_val <= cur_max_val;\n\t\t\t\tend\n\t\t\tend\n\t\t2:\n\t\t\tbegin\n\t\t\t\tif (adc_d <= cur_min_val)\n\t\t\t\t\tcur_min_val <= adc_d;\t\t\t\t\t\n\t\t\t\telse if (adc_d >= ({1'b0, cur_min_val} + threshold)) begin\n\t\t\t\t\tstate <= 1;\n\t\t\t\t\tcur_max_val <= adc_d;\n\t\t\t\t\tmin_val <= cur_min_val;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\tassign min = min_val;\n\tassign max = max_val;\n\nendmodule\n",
        "module_name": "min_max_tracker",
        "module_hash": "619ed60459986b97f62285e16da16eae",
        "dataset_index": 25539
      },
      "crc #_428f1820": {
        "rtl_code": "module crc #(\n  parameter data_size = 8, // size of input data message in bits\n  parameter poly_size = 4, // size of generator polynomial in bits\n  parameter crc_size = poly_size - 1 // size of checksum in bits\n\n) (\n  input clk,\n  input reset,\n  input [data_size-1:0] data_in,\n  input [data_size-1:0] poly,\n  input [data_size-1:0] crc_in,\n  input crc_enable,\n  input check_enable,\n  output [data_size-1:0] crc_out,\n  output match\n);\n\n\nreg [data_size-1:0] data_reg;\nreg [crc_size-1:0] crc_reg;\nreg [crc_size-1:0] crc_calc;\nreg [data_size-1:0] poly_reg;\nreg [crc_size-1:0] crc_check;\n\nwire [crc_size-1:0] crc_remainder;\nwire [crc_size-1:0] crc_check_remainder;\n\nassign crc_remainder = crc_calc[crc_size-1:0] ^ crc_reg;\nassign crc_check_remainder = data_reg[crc_size-1:0] ^ crc_check;\n\nassign crc_out = {data_in, crc_calc};\nassign match = (crc_check_remainder == crc_in);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    data_reg <= 0;\n    crc_reg <= 0;\n    crc_calc <= 0;\n    poly_reg <= poly;\n    crc_check <= crc_in;\n  end else begin\n    data_reg <= data_in;\n    if (crc_enable) begin\n      crc_reg <= crc_calc;\n      crc_calc <= {crc_calc[crc_size-2:0], data_reg, 1'b0} ^ (poly_reg & {crc_calc[crc_size-2:0], 1'b0});\n    end\n    if (check_enable) begin\n      crc_check <= {crc_check[crc_size-2:0], data_reg, 1'b0} ^ (poly_reg & {crc_check[crc_size-2:0], 1'b0});\n    end\n  end\nend\n\nendmodule",
        "module_name": "crc #",
        "module_hash": "428f1820e5873966d14ce4b38016fc78",
        "dataset_index": 8752
      },
      "up_down_counter_4fb3e6a9": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input rst,\n    input up_down,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0000;\n    end else begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule\n\nmodule seven_segment_display (\n    input [3:0] D_in,\n    output A,\n    output B,\n    output C,\n    output D,\n    output E,\n    output F,\n    output G,\n    output reg [6:0] seg_display\n);\n\nalways @(*) begin\n    case (D_in)\n        4'b0000: seg_display = 7'b1111110; // 0\n        4'b0001: seg_display = 7'b0110000; // 1\n        4'b0010: seg_display = 7'b1101101; // 2\n        4'b0011: seg_display = 7'b1111001; // 3\n        4'b0100: seg_display = 7'b0110011; // 4\n        4'b0101: seg_display = 7'b1011011; // 5\n        4'b0110: seg_display = 7'b1011111; // 6\n        4'b0111: seg_display = 7'b1110000; // 7\n        4'b1000: seg_display = 7'b1111111; // 8\n        4'b1001: seg_display = 7'b1111011; // 9\n        default: seg_display = 7'b0000001; // Error\n    endcase\nend\n\nassign {A, B, C, D, E, F, G} = seg_display;\n\nendmodule\n\nmodule bitwise_or (\n    input [3:0] count,\n    input [6:0] seg_display,\n    output reg [6:0] final_output\n);\n\nalways @(*) begin\n    final_output = count | seg_display;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input rst,\n    input up_down,\n    output A,\n    output B,\n    output C,\n    output D,\n    output E,\n    output F,\n    output G,\n    output  [3:0] count,\n    output  [6:0] seg_display,\n    output  [6:0] final_output\n);\n\nup_down_counter counter (.clk(clk), .rst(rst), .up_down(up_down), .count(count));\nseven_segment_display display (.D_in(count), .A(A), .B(B), .C(C), .D(D), .E(E), .F(F), .G(G), .seg_display(seg_display));\nbitwise_or or_gate (.count(count), .seg_display(seg_display), .final_output(final_output));\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "4fb3e6a96776d05586fcbb0110374e32",
        "dataset_index": 387
      },
      "adder_4bit_3afb890e": {
        "rtl_code": "module adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] S,\n    output reg Cout\n);\n\nreg [4:0] Sum;\n\nalways @* begin\n    Sum = {1'b0, A} + {1'b0, B} + Cin;\n    S = Sum[3:0];\n    Cout = Sum[4];\nend\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "3afb890e9de5ec5bfab0d5716321e5af",
        "dataset_index": 13056
      },
      "Timer_83debca3": {
        "rtl_code": "module Timer (\n      input   io_tick,\n      input   io_clear,\n      input  [15:0] io_limit,\n      output  io_full,\n      output [15:0] io_value,\n      input   io_mainClk,\n      input   resetCtrl_systemReset);\n  \n  reg [15:0] counter;\n  wire limitHit;\n  reg inhibitFull;\n  \n  assign limitHit = (counter == io_limit);\n  assign io_full = ((limitHit && io_tick) && (! inhibitFull));\n  assign io_value = counter;\n  \n  always @ (posedge io_mainClk or posedge resetCtrl_systemReset) begin\n    if (resetCtrl_systemReset) begin\n      counter <= 16'b0;\n      inhibitFull <= 1'b0;\n    end else begin\n      if (io_clear) begin\n        counter <= 16'b0;\n        inhibitFull <= 1'b0;\n      end else begin\n        if (io_tick) begin\n          counter <= counter + 1;\n          inhibitFull <= limitHit;\n        end\n      end\n    end\n  end\n\nendmodule",
        "module_name": "Timer",
        "module_hash": "83debca38c72d752309d87cc06c7f587",
        "dataset_index": 19753
      },
      "register__24217209": {
        "rtl_code": "module register_module (\n    input wire [31:0] interface_from_core_fp,\n    input wire mb_reg_rwn,\n    input wire [15:0] mb_reg_select,\n    output reg [31:0] mb_reg_output\n);\n\n    parameter NUMBER_INTERFACE_REGS = 16;\n    parameter MB_REG_START = 3;\n    parameter CMD_REG_0_ADDR = MB_REG_START;\n    parameter CMD_REG_1_ADDR = MB_REG_START+1;\n    parameter CMD_REG_2_ADDR = MB_REG_START+2;\n    parameter CMD_REG_3_ADDR = MB_REG_START+3;\n    parameter CMD_REG_4_ADDR = MB_REG_START+4;\n    parameter CMD_REG_5_ADDR = MB_REG_START+5;\n    parameter CMD_REG_6_ADDR = MB_REG_START+6;\n    parameter CMD_REG_7_ADDR = MB_REG_START+7;\n    parameter CMD_REG_8_ADDR = MB_REG_START+8;\n    parameter CMD_REG_9_ADDR = MB_REG_START+9;\n    parameter CMD_REG_10_ADDR = MB_REG_START+10;\n    parameter MODE_REG_0_ADDR = CMD_REG_8_ADDR;\n    parameter CMD_REG_14_ADDR = 14;\n    parameter CRC_ERROR_REG_ADDR = CMD_REG_14_ADDR;\n    parameter VERSION_REG_ADDR = 15;\n\n    reg [NUMBER_INTERFACE_REGS-1:MB_REG_START] mb_reg_wr;\n    reg [NUMBER_INTERFACE_REGS-1:MB_REG_START] mb_reg_rd;\n    reg [31:0] mb_reg_out_w [NUMBER_INTERFACE_REGS-1:MB_REG_START];\n\n    integer mb_loop;\n    always @(interface_from_core_fp or mb_reg_rwn or mb_reg_select)\n    begin\n        mb_reg_wr <= 'h0;\n        mb_reg_rd <= 'h0;\n        mb_reg_output <= interface_from_core_fp;\n\n        for (mb_loop = MB_REG_START; mb_loop < NUMBER_INTERFACE_REGS; mb_loop = mb_loop + 1)\n        begin\n            if (mb_reg_select[mb_loop] == 1'b1)\n            begin\n                mb_reg_rd[mb_loop] <= mb_reg_select[mb_loop] & mb_reg_rwn;\n                mb_reg_wr[mb_loop] <= mb_reg_select[mb_loop] & !mb_reg_rwn;\n                if (mb_reg_rwn)\n                begin\n                    mb_reg_out_w[mb_loop] <= interface_from_core_fp;\n                end\n                else\n                begin\n                    mb_reg_output <= mb_reg_out_w[mb_loop];\n                end\n            end\n        end\n    end\n\nendmodule",
        "module_name": "register_",
        "module_hash": "242172090b371ff6092963b065249de9",
        "dataset_index": 6282
      },
      "four_to_one_b76f895f": {
        "rtl_code": "module four_to_one (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    output reg out\n);\n\nalways @(*) begin\n    if (in0 == 0 && in1 == 0 && in2 == 0 && in3 == 0) begin\n        out = 0;\n    end else if (in0 == 1 && in1 == 1 && in2 == 1 && in3 == 1) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule",
        "module_name": "four_to_one",
        "module_hash": "b76f895febc5f8219ca35596bc552d4f",
        "dataset_index": 4002
      },
      "adder_810c8794": {
        "rtl_code": "module adder (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            sum <= 8'b0;\n        end else begin\n            sum <= a + b;\n        end\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input select,\n    output [7:0] sum\n);\n\n    wire [7:0] sum1, sum2;\n\n    adder adder1 (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .sum(sum1)\n    );\n\n    adder adder2 (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .sum(sum2)\n    );\n\n    assign sum = select ? sum2 : sum1;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "810c879477eaf0898e370957caf1264b",
        "dataset_index": 12599
      },
      "clock_gate_d58eccea": {
        "rtl_code": "\nmodule clock_gate (\n    input clk,\n    input en,\n    input te,\n    output reg enclk\n);\n\n    TLATNTSCAX2TS latch (\n        .E(en),\n        .SE(te),\n        .CK(clk),\n        .ECK(enclk)\n    );\n\nendmodule\nmodule TLATNTSCAX2TS (\n    input E,\n    input SE,\n    input CK,\n    output reg ECK\n);\n\nalways @(posedge CK) begin\n    if (E) begin\n        ECK <= SE;\n    end else begin\n        ECK <= ECK; // Hold the previous value\n    end\nend\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "d58eccea6bb6f79c48f99d0334620b0a",
        "dataset_index": 353
      },
      "axi_data_mover_0cdec9c7": {
        "rtl_code": "\nmodule axi_data_mover (\n  input clk,\n  input resetn,\n\n  input [2:0] request_id,\n  output [2:0] response_id,\n  input sync_id,\n  input eot,\n\n  input enable,\n  output reg enabled,\n\n  output xfer_req,\n\n  output s_axi_ready,\n  input s_axi_valid,\n  input [63:0] s_axi_data,\n\n  input m_axi_ready,\n  output m_axi_valid,\n  output [63:0] m_axi_data,\n  output m_axi_last,\n\n  input req_valid,\n  output reg req_ready,\n  input [3:0] req_last_burst_length\n);\n\nparameter MAX_BEATS_PER_BURST = 16;\n\nreg [3:0] last_burst_length = 0;\nreg [3:0] beat_counter = 0;\nreg [2:0] id = 0;\nreg [2:0] id_next = 0;\n\nreg pending_burst = 0;\nreg active = 0;\nreg last_eot = 0;\nreg last_non_eot = 0;\n\nwire last_load;\nwire last;\n\nassign xfer_req = active;\n\nassign response_id = id;\n\nassign last = eot ? last_eot : last_non_eot;\n\nassign s_axi_ready = m_axi_ready & pending_burst & active;\nassign m_axi_valid = s_axi_valid & pending_burst & active;\nassign m_axi_data = s_axi_data;\nassign m_axi_last = last;\n\nassign last_load = (m_axi_ready & s_axi_valid & active) & (last_eot | last_non_eot);\n\n// fixed to drive req_ready\nalways @( posedge clk )\n  if ( req_valid & ~active )\n    req_ready <= 1'b0;\n  else\n    req_ready <= 1'b1;\n\nalways @(posedge clk) begin\n  if (resetn == 1'b0) begin\n    enabled <= 1'b0;\n  end else begin\n    if (enable) begin\n      enabled <= 1'b1;\n    end else begin\n      enabled <= 1'b0;\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if (req_valid && ~active) begin\n    id_next <= id + 1;\n    beat_counter <= 1;\n    last_burst_length <= req_last_burst_length;\n    pending_burst <= 1;\n    active <= 1;\n  end else if (s_axi_ready && s_axi_valid && active) begin\n    beat_counter <= beat_counter + 1;\n    if (beat_counter == last_burst_length) begin\n      last_eot <= 1;\n      last_non_eot <= 0;\n    end else if (beat_counter == MAX_BEATS_PER_BURST - 1) begin\n      last_eot <= 0;\n      last_non_eot <= 1;\n    end else begin\n      last_eot <= 0;\n      last_non_eot <= 0;\n    end\n  end else if (last_load) begin\n    active <= 0;\n    pending_burst <= 0;\n  end\nend\n\nalways @(posedge clk) begin\n  if (resetn == 1'b0) begin\n    id <= 0;\n  end else begin\n    id <= id_next;\n  end\nend\n\nendmodule",
        "module_name": "axi_data_mover",
        "module_hash": "0cdec9c7c9d7abe1fde4872d9c46185a",
        "dataset_index": 1172
      },
      "emesh_if_e05214bf": {
        "rtl_code": "module emesh_if (\n   cmesh_ready_out, cmesh_access_out, cmesh_packet_out,\n   rmesh_ready_out, rmesh_access_out, rmesh_packet_out,\n   xmesh_ready_out, xmesh_access_out, xmesh_packet_out,\n   emesh_ready_out, emesh_access_out, emesh_packet_out,\n   cmesh_access_in, cmesh_packet_in, cmesh_ready_in, rmesh_access_in,\n   rmesh_packet_in, rmesh_ready_in, xmesh_access_in, xmesh_packet_in,\n   xmesh_ready_in, emesh_access_in, emesh_packet_in, emesh_ready_in\n   );\n\n   parameter AW   = 32;   \n   parameter PW   = 2*AW+40; \n\n   input \t   cmesh_access_in;\n   input [PW-1:0]  cmesh_packet_in;\n   output \t   cmesh_ready_out;\n   output \t   cmesh_access_out;\n   output [PW-1:0] cmesh_packet_out;\n   input \t   cmesh_ready_in;\n      \n   input \t   rmesh_access_in;\n   input [PW-1:0]  rmesh_packet_in;\n   output \t   rmesh_ready_out;\n   output \t   rmesh_access_out;\n   output [PW-1:0] rmesh_packet_out;\n   input \t   rmesh_ready_in;\n   \n   input \t   xmesh_access_in;\n   input [PW-1:0]  xmesh_packet_in;\n   output \t   xmesh_ready_out;  \n   output \t   xmesh_access_out;\n   output [PW-1:0] xmesh_packet_out;\n   input \t   xmesh_ready_in;\n   \n   input \t   emesh_access_in;\n   input [PW-1:0]  emesh_packet_in;\n   output \t   emesh_ready_out;\n   \n   output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n   input \t   emesh_ready_in;\n      \n   assign cmesh_access_out = emesh_access_in & emesh_packet_in[0];\n\n   assign rmesh_access_out = emesh_access_in & ~emesh_packet_in[0];\n\n   assign xmesh_access_out = 1'b0;\n      \n   assign cmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\t \n   assign rmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\t \n   assign xmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\n\n\n   assign emesh_ready_out = cmesh_ready_in &\n\t\t\t    rmesh_ready_in &\n\t\t\t    xmesh_ready_in;\n  \t \t \n   assign emesh_access_out = cmesh_access_in &\n\t\t\t     rmesh_access_in &\n\t\t\t     xmesh_access_in;\n   \n\n   assign emesh_packet_out[PW-1:0] = cmesh_access_in ? cmesh_packet_in[PW-1:0] :\n\t\t\t\t     rmesh_access_in ? rmesh_packet_in[PW-1:0] :\n\t\t\t\t                       xmesh_packet_in[PW-1:0];\n   \n   assign cmesh_ready_out = ~(cmesh_access_in & ~emesh_ready_in);\n   \n\n   assign rmesh_ready_out = ~(rmesh_access_in & \n\t\t\t    (~emesh_ready_in | ~cmesh_ready_in));\n\n   assign xmesh_ready_out = ~(xmesh_access_in & \n\t\t\t      (~emesh_ready_in | ~cmesh_access_in | ~rmesh_access_in));\n   \n\t\t\t\t     \nendmodule ",
        "module_name": "emesh_if",
        "module_hash": "e05214bf04141331fa9be80c7f8c3ce2",
        "dataset_index": 22607
      },
      "flip_flop_de052940": {
        "rtl_code": "module flip_flop (\n    Q   ,\n    CLK ,\n    D   ,\n    DE  ,\n    SCD ,\n    SCE ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Q   ;\n    input  CLK ;\n    input  D   ;\n    input  DE  ;\n    input  SCD ;\n    input  SCE ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Scan chain enable/disable\n    wire scan_en = SCE & ~SCD;\n\n    // D flip-flop\n    reg Q_reg;\n    always @(posedge CLK) begin\n        if (scan_en & DE) begin\n            Q_reg <= D;\n        end\n    end\n\n    // Output\n    assign Q = scan_en ? Q_reg : 1'b0;\n\n    // Power and ground connections\n    assign VPWR = 1'b1;\n    assign VGND = 1'b0;\n    assign VPB = 1'b1;\n    assign VNB = 1'b0;\n\nendmodule",
        "module_name": "flip_flop",
        "module_hash": "de052940fc57e4a872aa035b1e6b43ac",
        "dataset_index": 12046
      },
      "mux2to1_ca4e5a97": {
        "rtl_code": "module mux2to1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = (sel == 0) ? a : b;\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "ca4e5a97b815c9ed0f1c8d29ed66cf13",
        "dataset_index": 15657
      },
      "barrel_shift_mux_1ceb692a": {
        "rtl_code": "\nmodule barrel_shift_mux (\n    input [7:0] data_in0,\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    input [7:0] data_in3,\n    input [1:0] select,\n    input shift_left,\n    input shift_right,\n    input rotate_right,\n    output reg [7:0] data_out // Changed wire to reg to fix the issue\n);\n\nreg [7:0] shifted_data;\n\n// Barrel Shifter Module\nalways @(*) begin\n    case ({shift_left, shift_right, rotate_right})\n        3'b001: shifted_data = {data_in0[6:0], 1'b0};\n        3'b010: shifted_data = {1'b0, data_in0[7:1]};\n        3'b100: shifted_data = {data_in0[0], data_in0[7:1]};\n        default: shifted_data = data_in0;\n    endcase\nend\n\n// Multiplexer Module\nalways @(*) begin\n    case (select)\n        2'b00: data_out = shifted_data;\n        2'b01: data_out = data_in1;\n        2'b10: data_out = data_in2;\n        2'b11: data_out = data_in3;\n    endcase\nend\n\nendmodule\n",
        "module_name": "barrel_shift_mux",
        "module_hash": "1ceb692a8ab2d9f79864be220a87fa10",
        "dataset_index": 15486
      },
      "blk_mem_gen_1blk_mem_gen_prim_wrapper_33226759": {
        "rtl_code": "\nmodule blk_mem_gen_1blk_mem_gen_prim_wrapper\n       (addra,\n        addrb,\n        clka,\n        clkb,\n        dina,\n        doutb,\n        enb,\n        wea);\n\n  parameter WIDTH = 32;\n  parameter DEPTH = 1024;\n\n  input [WIDTH-1:0] addra;\n  input [WIDTH-1:0] addrb;\n  input clka;\n  input clkb;\n  input [WIDTH-1:0] dina;\n  output reg [WIDTH-1:0] doutb;\n  input enb;\n  input wea;\n\n  reg [WIDTH-1:0] mem [0:DEPTH-1];\n\n  integer i;\n\n  always @(posedge clka) begin\n    if (enb) begin\n        mem[addra] <= dina; \n    end\n  end\n\n  always @(posedge clkb) begin\n    if (wea) begin\n      doutb <= mem[addrb]; \n    end\n  end\n\n  initial begin\n    for (i = 0; i < DEPTH; i = i + 1) begin\n      mem[i] <= 0;\n    end\n  end\n\nendmodule",
        "module_name": "blk_mem_gen_1blk_mem_gen_prim_wrapper",
        "module_hash": "332267594763f49f50c0b8b88cb24e83",
        "dataset_index": 13791
      },
      "preprocess_control_d4120528": {
        "rtl_code": "module preprocess_control\n    #(parameter DATA_WIDTH = 64,\n      parameter CTRL_WIDTH = DATA_WIDTH/8\n      )\n   (input  [DATA_WIDTH-1:0]            in_data,\n    input  [CTRL_WIDTH-1:0]            in_ctrl,\n    input                              in_wr,\n\n    output reg                         word_MAC_DA_HI,\n    output reg                         word_MAC_DASA,\n    output reg                         word_MAC_SA_LO,\n    output reg                         word_ETH_IP_VER,\n    output reg                         word_IP_LEN_ID,\n    output reg                         word_IP_FRAG_TTL_PROTO,\n    output reg                         word_IP_CHECKSUM_SRC_HI,\n    output reg                         word_IP_SRC_DST,\n    output reg                         word_IP_DST_LO,\n\n    input                              reset,\n    input                              clk\n   );\n\n   function integer log2;\n      input integer number;\n      begin\n         log2=0;\n         while(2**log2<number) begin\n            log2=log2+1;\n         end\n      end\n   endfunction localparam SKIP_MODULE_HDRS = 1;\n   localparam WORD_1           = 2;\n   localparam WORD_2           = 4;\n   localparam WORD_3           = 8;\n   localparam WORD_4           = 16;\n   localparam WORD_5           = 32;\n   localparam WAIT_EOP         = 64;\n\n   reg [6:0]                            state, state_next;\n       \n   always @(*) begin\n      state_next = state;\n      word_MAC_DA_HI = 0;\n      word_MAC_DASA  = 0;\n      word_MAC_SA_LO = 0;\n      word_ETH_IP_VER = 0;\n      word_IP_LEN_ID = 0;\n      word_IP_FRAG_TTL_PROTO = 0;\n      word_IP_CHECKSUM_SRC_HI = 0;\n      word_IP_SRC_DST = 0;\n      word_IP_DST_LO = 0;\n      \n      case(state)\n        SKIP_MODULE_HDRS: begin\n           if(in_ctrl==0 && in_wr) begin\n              word_MAC_DA_HI = 1;\n              word_MAC_DASA  = 1;\n              state_next     = WORD_1;\n           end\n        end\n\n        WORD_1: begin\n           if(in_wr) begin\n              word_MAC_SA_LO = 1;\n              word_ETH_IP_VER = 1;\n              state_next = WORD_2;\n           end\n        end\n\n        WORD_2: begin\n           if(in_wr) begin\n              word_IP_LEN_ID = 1;\n              word_IP_FRAG_TTL_PROTO = 1;\n              state_next = WORD_3;\n           end\n        end\n\n        WORD_3: begin\n           if(in_wr) begin\n              word_IP_CHECKSUM_SRC_HI = 1;\n              word_IP_SRC_DST = 1;\n              state_next = WORD_4;\n           end\n        end\n\n        WORD_4: begin\n           if(in_wr) begin\n              word_IP_DST_LO = 1;\n              state_next = WAIT_EOP;\n           end\n        end\n\n        WAIT_EOP: begin\n           if(in_ctrl!=0 & in_wr) begin\n              state_next = SKIP_MODULE_HDRS;\n           end\n        end\n      endcase end always@(posedge clk) begin\n      if(reset) begin\n         state <= SKIP_MODULE_HDRS;\n      end\n      else begin\n         state <= state_next;\n      end\n   end\n\nendmodule\n",
        "module_name": "preprocess_control",
        "module_hash": "d41205285b3da167638f8a39cec89692",
        "dataset_index": 22501
      },
      "FSM_split_81f4f3f2": {
        "rtl_code": "\nmodule FSM_split (\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter s = 8; // number of states in the original FSM\nparameter k = 2; // number of states in each smaller FSM\n\n// Define states and transitions in the original FSM\nparameter STATE0 = 3'b000;\nparameter STATE1 = 3'b001;\nparameter STATE2 = 3'b010;\nparameter STATE3 = 3'b011;\nparameter STATE4 = 3'b100;\nparameter STATE5 = 3'b101;\nparameter STATE6 = 3'b110;\nparameter STATE7 = 3'b111;\n\nreg [2:0] state;\nalways @ (posedge clk) begin\n  case (state)\n    STATE0: if (in == 4'b0000) state <= STATE1; else state <= STATE0;\n    STATE1: if (in == 4'b0001) state <= STATE2; else state <= STATE0;\n    STATE2: if (in == 4'b0010) state <= STATE3; else state <= STATE0;\n    STATE3: if (in == 4'b0011) state <= STATE4; else state <= STATE0;\n    STATE4: if (in == 4'b0100) state <= STATE5; else state <= STATE0;\n    STATE5: if (in == 4'b0101) state <= STATE6; else state <= STATE0;\n    STATE6: if (in == 4'b0110) state <= STATE7; else state <= STATE0;\n    STATE7: if (in == 4'b0111) state <= STATE0; else state <= STATE0;\n  endcase\nend\n\n// Split the FSM into smaller FSMs\nreg [1:0] state1, state2;\nalways @ (posedge clk) begin\n  case (state)\n    STATE0, STATE1: state1 <= state[1:0];\n    STATE2, STATE3: state1 <= state[1:0] - 2;\n    STATE4, STATE5: state1 <= state[1:0] - 4;\n    STATE6, STATE7: state1 <= state[1:0] - 6;\n  endcase\nend\n\n// Define transitions and output functions for the smaller FSMs\nalways @ (posedge clk) begin\n  case (state1)\n    2'b00: if (in == 4'b0000) state2 <= 2'b01; else state2 <= 2'b00;\n    2'b01: if (in == 4'b0001) state2 <= 2'b10; else state2 <= 2'b00;\n    2'b10: if (in == 4'b0010) state2 <= 2'b11; else state2 <= 2'b00;\n    2'b11: if (in == 4'b0011) state2 <= 2'b00; else state2 <= 2'b00;\n  endcase\nend\n\nassign out = {state2[1], state2[0]};\n\nendmodule\n",
        "module_name": "FSM_split",
        "module_hash": "81f4f3f2f8f5d1d1e9cdbcb0431ea30e",
        "dataset_index": 16002
      },
      "switch_module_77b738be": {
        "rtl_code": "module switch_module\n#(parameter     addr = 4'b0010)\n(   \n    input       [7:0] port0_i,\n    input       [7:0] port1_i,\n    input       [7:0] port0_local_i,\n    input       [7:0] port1_local_i,\n    output      [7:0] port0_o,\n    output      [7:0] port1_o,\n    output      portl0_ack,\n    output      portl1_ack,\n    input       clk,\n    input       rst\n);\n\n    // inputs\n    wire [7:0] port0_0, port1_0, port0_local_0, port1_local_0;\n\n    assign port0_0 = (rst) ? 8'd0 : port0_i;\n    assign port1_0 = (rst) ? 8'd0 : port1_i;\n    assign port0_local_0 = (rst) ? 8'd0 : port0_local_i;\n    assign port1_local_0 = (rst) ? 8'd0 : port1_local_i;\n\n    \t\n\t\n    reg [7:0] port0_0_r, port1_0_r;\n    always @(posedge clk) begin\n        port0_0_r <= port0_0;\n        port1_0_r <= port1_0;\n    end\n\n\twire ej_0 = port0_0_r[3:0] == addr && port0_0_r[4];\n\twire ej_1 = port1_0_r[3:0] == addr && port1_0_r[4];\n\n    assign port0_o = (ej_0) ? port0_0_r[7:0] : port0_local_0;\n    assign port1_o = (ej_1) ? port1_0_r[7:0] : port1_local_0;\n\n    wire valid0 = (ej_0) ? 0 : port0_0_r[4];\n    wire valid1 = (ej_1) ? 0 : port1_0_r[4];\n\n    assign portl0_ack = ~valid0 & (ej_0 | (port0_local_0[4] && ~ej_1));\n    assign portl1_ack = ~valid1 & (ej_1 | (port1_local_0[4] && ~ej_0));\n\nendmodule",
        "module_name": "switch_module",
        "module_hash": "77b738be7fa829c7fd6fd9820eab08cb",
        "dataset_index": 3502
      },
      "twos_comp_873e5214": {
        "rtl_code": "module twos_comp (\n    input [3:0] in,\n    output [3:0] out\n);\n\n    assign out = ~in + 4'b1;\n\nendmodule",
        "module_name": "twos_comp",
        "module_hash": "873e521437afe3cfdd8923bd381a6d31",
        "dataset_index": 6128
      },
      "inverter_37dbe476": {
        "rtl_code": "module inverter (\n    input A,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    // Define internal signals\n    wire A_valid;\n    wire A_low;\n    wire A_high;\n\n    // Check if A is a valid logic level\n    assign A_valid = (A == 0 || A == 1);\n\n    // Check if A is low or high\n    assign A_low = (A == 0);\n    assign A_high = (A == 1);\n\n    // Define the inverter logic\n    assign Y = A_valid ? ~A : 1'bx;\n\nendmodule",
        "module_name": "inverter",
        "module_hash": "37dbe476d21cc4afd168e7fccbdcf8d6",
        "dataset_index": 18934
      },
      "multi_input__598e08ee": {
        "rtl_code": "module multi_input_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    input f,\n    input g,\n    input h,\n    input i,\n    output out\n);\n\n    wire ab_high;\n    wire cd_high;\n    wire ef_low;\n    wire g_high;\n    wire h_low;\n    wire i_high;\n\n    assign ab_high = a & b;\n    assign cd_high = c | d;\n    assign ef_low = ~(e | f);\n    assign g_high = g;\n    assign h_low = ~h;\n    assign i_high = i;\n\n    assign out = ab_high | cd_high | ef_low | g_high | h_low | i_high;\n\nendmodule",
        "module_name": "multi_input_",
        "module_hash": "598e08eec736b192aabc8f69fecf0159",
        "dataset_index": 12473
      },
      "nand_gate_pipeline_76b9abbd": {
        "rtl_code": "module nand_gate_pipeline(\n    input a,\n    input b,\n    output reg out\n);\n\nreg [1:0] stage1;\nreg stage2;\n\nalways @(a, b) begin\n    stage1[0] <= a & b;\n    stage1[1] <= #1 ~stage1[0];\n    stage2 <= #1 ~stage1[1];\n    out <= #1 ~stage2;\nend\n\nendmodule\n\nmodule decoder_2to4(\n    input [1:0] in,\n    output reg [3:0] out\n);\n\nwire nand1, nand2, nand3, nand4;\n\nnand_gate_pipeline nand_gate1(.a(in[0]), .b(in[1]), .out(nand1));\nnand_gate_pipeline nand_gate2(.a(~in[0]), .b(in[1]), .out(nand2));\nnand_gate_pipeline nand_gate3(.a(in[0]), .b(~in[1]), .out(nand3));\nnand_gate_pipeline nand_gate4(.a(~in[0]), .b(~in[1]), .out(nand4));\n\nalways @(in) begin\n    out[0] <= #1 nand1;\n    out[1] <= #1 nand2;\n    out[2] <= #1 nand3;\n    out[3] <= #1 nand4;\nend\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    output reg [3:0] out\n);\n\nwire [1:0] in;\nassign in = {a, b};\n\ndecoder_2to4 decoder(.in(in), .out(out));\n\nendmodule",
        "module_name": "nand_gate_pipeline",
        "module_hash": "76b9abbdb84f0049575c208f3b9fd160",
        "dataset_index": 5925
      },
      "sky130_fd_sc_ls__nand4_d76ea618": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, D, C, B, A     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__nand4",
        "module_hash": "d76ea618a792654c2c72f07566a56e1a",
        "dataset_index": 21318
      },
      "nor_logic_7df22390": {
        "rtl_code": "module nor_logic(\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    wire [3:0] neg_in;\n    assign neg_in = ~in;\n\n    // Output for AND operation\n    assign out_and = ~(neg_in[0] | neg_in[1] | neg_in[2] | neg_in[3]);\n\n    // Output for OR operation\n    assign out_or = ~(in[0] | in[1] | in[2] | in[3]);\n\n    // Output for XOR operation\n    assign out_xor = ~(in[0] ^ neg_in[0] ^ in[1] ^ neg_in[1] ^ in[2] ^ neg_in[2] ^ in[3] ^ neg_in[3]);\n\nendmodule\n\nmodule control_logic(\n    input select,\n    output [1:0] active_output\n);\n\n    // Output selection logic\n    assign active_output = (select == 1'b0) ? 2'b10 : 2'b01;\n\nendmodule\n\nmodule top_module( \n    input [3:0] in,\n    input select,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output [1:0] active_output\n);\n\n    wire out_and_nor, out_or_nor, out_xor_nor;\n\n    // NOR logic module instantiation\n    nor_logic nor_inst(\n        .in(in),\n        .out_and(out_and_nor),\n        .out_or(out_or_nor),\n        .out_xor(out_xor_nor)\n    );\n\n    // Control logic module instantiation\n    control_logic control_inst(\n        .select(select),\n        .active_output(active_output)\n    );\n\n    // Output selection logic\n    assign {out_and, out_or, out_xor} = (active_output == 2'b10) ? {out_and_nor, 1'b0, 1'b0} : {1'b0, out_or_nor, out_xor_nor};\n\nendmodule",
        "module_name": "nor_logic",
        "module_hash": "7df2239008e2d142254efb993ea2047f",
        "dataset_index": 18176
      },
      "ahb_lite_memory_interface_40535488": {
        "rtl_code": "module ahb_lite_memory_interface (\n    input         hclk,       // AHB-Lite System Clock\n    input         hresetn,    // AHB-Lite System Reset, active low\n    input  [31:0] haddr,      // AHB-Lite Address bus\n    input  [31:0] hwdata,     // AHB-Lite Write-data bus\n    output [31:0] hrdata,     // AHB-Lite Read-data bus\n    input         hwrite,     // AHB-Lite Write control signal\n    input   [2:0] hsize,      // AHB-Lite Size of the transfer\n    input   [1:0] htrans,     // AHB-Lite Transfer type\n    input         hsel,       // AHB-Lite Slave select\n    output        hready,     // AHB-Lite Transfer ready signal\n    output  [1:0] hresp       // AHB-Lite Transfer response\n);\n\n    // Local parameters for AHB transfer types\n    localparam IDLE  = 2'b00;\n    localparam BUSY  = 2'b01;\n    localparam NONSEQ = 2'b10;\n    localparam SEQ   = 2'b11;\n\n    // Memory array\n    reg [31:0] memory [0:255]; // Example memory size is 256 words\n\n    // Internal signals\n    reg [31:0] internal_hrdata;\n    reg        internal_hready;\n    reg [1:0]  internal_hresp;\n\n    // AHB-Lite Read/Write Logic\n    always @(posedge hclk or negedge hresetn) begin\n        if (!hresetn) begin\n            internal_hrdata <= 32'b0;\n            internal_hready <= 1'b1;\n            internal_hresp <= 2'b00; // OKAY response\n        end else begin\n            if (hsel && htrans != IDLE && hready) begin\n                if (hwrite) begin\n                    // Write operation\n                    memory[haddr[31:2]] <= hwdata; // Word aligned address\n                end else begin\n                    // Read operation\n                    internal_hrdata <= memory[haddr[31:2]]; // Word aligned address\n                end\n                internal_hready <= 1'b1;\n            end else begin\n                internal_hready <= 1'b1;\n            end\n        end\n    end\n\n    // Output assignments\n    assign hrdata = internal_hrdata;\n    assign hready = internal_hready;\n    assign hresp = internal_hresp;\n\nendmodule\n",
        "module_name": "ahb_lite_memory_interface",
        "module_hash": "405354885a65867842da40b00eb85f2c",
        "dataset_index": 10956
      },
      "sky130_fd_sc_hvl__nor2_d132820e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__nor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B           );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__nor2",
        "module_hash": "d132820e9f727f2b90ef4ce9b487ce0a",
        "dataset_index": 1329
      },
      "hls_contrast_streibs_DSP48_6_31314668": {
        "rtl_code": "module hls_contrast_streibs_DSP48_6(\n    input  [8 - 1:0] in0,\n    input  [23 - 1:0] in1,\n    input  [32 - 1:0] in2,\n    output [32 - 1:0]  dout);\n\nwire signed [25 - 1:0]     a;\nwire signed [18 - 1:0]     b;\nwire signed [48 - 1:0]     c;\nwire signed [43 - 1:0]     m;\nwire signed [48 - 1:0]     p;\n\nassign a  = $signed(in1);\nassign b  = $signed(in0);\nassign c  = $signed(in2);\n\nassign m  = a * b;\nassign p  = m + c;\n\nassign dout = p;\n\nendmodule",
        "module_name": "hls_contrast_streibs_DSP48_6",
        "module_hash": "31314668489317dfd7f5bc1d89b6a8cb",
        "dataset_index": 141
      },
      "shift_register_1d28a49f": {
        "rtl_code": "module shift_register (\n  input clk,\n  input shift_enable,\n  input parallel_load_enable,\n  input [15:0] data_in,\n  output [15:0] data_out\n);\n\n  reg [15:0] register;\n\n  always @(posedge clk) begin\n    if (parallel_load_enable) begin\n      register <= data_in;\n    end else if (shift_enable) begin\n      register <= {register[14:0], 1'b0};\n    end\n  end\n\n  assign data_out = register;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "1d28a49f90219508442dc8f509caf2d2",
        "dataset_index": 13316
      },
      "led_controller_937d4d10": {
        "rtl_code": "module led_controller (\n  input clk,\n  input rst,\n  output reg [3:0] leds_0,\n  output reg [3:0] leds_1,\n  output reg [3:0] leds_2,\n  output reg [3:0] leds_3\n);\n\n  reg [26:0] counter;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      counter <= 0;\n      leds_0 <= 0;\n      leds_1 <= 0;\n      leds_2 <= 0;\n      leds_3 <= 0;\n    end else begin\n      counter <= counter + 1;\n      if (counter == 0) begin\n        leds_0 <= 15;\n      end else if (counter == 25000000) begin\n        leds_0 <= 0;\n      end else if (counter == 50000000) begin\n        leds_1 <= 15;\n      end else if (counter == 100000000) begin\n        leds_1 <= 0;\n      end else if (counter == 200000000) begin\n        leds_2 <= 15;\n      end else if (counter == 400000000) begin\n        leds_2 <= 0;\n      end else if (counter == 800000000) begin\n        leds_3 <= 15;\n      end else if (counter == 1600000000) begin\n        leds_3 <= 0;\n        counter <= 0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "led_controller",
        "module_hash": "937d4d10867d29861d5f3dfef41cf1d7",
        "dataset_index": 12996
      },
      "wb_adapter_0a8ea5a8": {
        "rtl_code": "\nmodule wb_adapter (\n    input clk,\n    input rst,\n    input [31:0] wbm_adr_i,\n    input [31:0] wbm_dat_i,\n    output reg [31:0] wbm_dat_o,\n    input wbm_we_i,\n    input [3:0] wbm_sel_i,\n    input wbm_stb_i,\n    output reg wbm_ack_o,\n    output reg wbm_err_o,\n    output reg wbm_rty_o,\n    input [31:0] wbs_dat_i,\n    output reg [31:0] wbs_adr_o,\n    output reg [31:0] wbs_dat_o,\n    output reg wbs_we_o,\n    output reg [3:0] wbs_sel_o,\n    output reg wbs_stb_o,\n    input wbs_ack_i,\n    input wbs_err_i,\n    input wbs_rty_i,\n    output reg wbs_cyc_o\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wbm_dat_o <= 32'b0;\n        wbm_ack_o <= 1'b0;\n        wbm_err_o <= 1'b0;\n        wbm_rty_o <= 1'b0;\n        wbs_adr_o <= 32'b0;\n        wbs_dat_o <= 32'b0;\n        wbs_we_o <= 1'b0;\n        wbs_sel_o <= 4'b0;\n        wbs_stb_o <= 1'b0;\n        wbs_cyc_o <= 1'b0;\n    end else begin\n        wbm_dat_o <= wbs_dat_i;\n        wbm_ack_o <= wbs_ack_i;\n        wbm_err_o <= wbs_err_i;\n        wbm_rty_o <= wbs_rty_i;\n        wbs_adr_o <= wbm_adr_i;\n        wbs_dat_o <= wbm_dat_i;\n        wbs_we_o <= wbm_we_i;\n        wbs_sel_o <= wbm_sel_i;\n        wbs_stb_o <= wbm_stb_i;\n        wbs_cyc_o <= wbm_stb_i;\n    end\nend\n\nendmodule",
        "module_name": "wb_adapter",
        "module_hash": "0a8ea5a88f9226419f633ca3b03a2e54",
        "dataset_index": 17186
      },
      "binary_adder_8aeb1038": {
        "rtl_code": "module binary_adder\n  (\n    input signed [3:0] a,\n    input signed [3:0] b,\n    input signed cin,\n    output signed [3:0] sum,\n    output signed cout\n  );\n  \n  assign {cout, sum} = a + b + cin;\n  \nendmodule",
        "module_name": "binary_adder",
        "module_hash": "8aeb1038425e46f9a591c3011d191679",
        "dataset_index": 10412
      },
      "adder_subtractor_867da251": {
        "rtl_code": "module adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    input clk,\n    output reg [3:0] Q\n);\n\nreg [3:0] A_reg, B_reg, Q_reg;\nreg mode_reg;\n\nalways @ (posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    mode_reg <= mode;\n    \n    if (mode_reg == 0) begin\n        Q_reg <= A_reg + B_reg;\n    end else begin\n        Q_reg <= A_reg - B_reg;\n    end\nend\n\nalways @*\nbegin\n    Q = Q_reg;\nend\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "867da2518094f3eec1abea89aabc27a0",
        "dataset_index": 9285
      },
      "adder_321c11e9": {
        "rtl_code": "\nmodule adder(input [3:0] A, input [3:0] B, input Cin, output [3:0] S, output Cout);\n\n  wire C1, C2, C3;\n  wire S0, S1, S2, S3;\n  \n  // 1st bit\n  full_adder FA1(A[0], B[0], Cin, S0, C1);\n  \n  // 2nd bit\n  full_adder FA2(A[1], B[1], C1, S1, C2);\n  \n  // 3rd bit\n  full_adder FA3(A[2], B[2], C2, S2, C3);\n  \n  // 4th bit\n  full_adder FA4(A[3], B[3], C3, S3, Cout);\n  \n  assign S = {S3, S2, S1, S0};\n  \nendmodule\nmodule full_adder(input A, input B, input Cin, output S, output Cout);\n  \n  wire X, Y, G, P;\n  \n  // First stage\n  xor (X, A, B);\n  and (Y, A, B);\n  \n  // Second stage\n  xor (S, X, Cin);\n  and (G, X, Cin);\n  \n  // Third stage\n  and (P, Y, Cin);\n  or (Cout, G, P);\n  \nendmodule",
        "module_name": "adder",
        "module_hash": "321c11e9828348d13606fea65023ecba",
        "dataset_index": 14219
      },
      "top__951cd1ba": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] q\n);\n\n    wire greater_than;\n    wire equal;\n    wire enable;\n    wire [3:0] count;\n    wire [7:0] sum;\n\n    // Instantiate the 8-bit comparator module\n    comparator_module comparator_inst(\n        .a(a),\n        .b(b),\n        .greater_than(greater_than)\n    );\n    \n    // Instantiate the 4-bit binary counter module\n    counter_module counter_inst(\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .count(count)\n    );\n    \n    // Instantiate the control logic module\n    control_logic_module control_inst(\n        .a(a),\n        .b(b),\n        .greater_than(greater_than),\n        .equal(equal),\n        .enable(enable)\n    );\n    \n    // Instantiate the additional functional module\n    functional_module functional_inst(\n        .a(a[0]),\n        .b(count),\n        .sum(sum)\n    );\n    \n    // Output the appropriate value based on the control logic\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0;\n        end else if (greater_than) begin\n            q <= count;\n        end else if (equal) begin\n            q <= sum;\n        end else begin\n            q <= a;\n        end\n    end\n    \nendmodule\nmodule comparator_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg greater_than\n);\n    \n    always @(*) begin\n        if (a > b) begin\n            greater_than = 1;\n        end else begin\n            greater_than = 0;\n        end\n    end\n    \nendmodule\nmodule counter_module (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n    \nendmodule\nmodule control_logic_module (\n    input [7:0] a,\n    input [7:0] b,\n    input greater_than,\n    output reg equal,\n    output reg enable\n);\n    \n    always @(*) begin\n        if (a > b) begin\n            equal = 0;\n            enable = 1;\n        end else if (a < b) begin\n            equal = 0;\n            enable = 0;\n        end else begin\n            equal = 1;\n            enable = 1;\n        end\n    end\n    \nendmodule\nmodule functional_module (\n    input a,\n    input [3:0] b,\n    output reg [7:0] sum\n);\n    \n    always @(*) begin\n        sum = {7'b0, a} + b;\n    end\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "951cd1ba5fe02c0c3265916af26a7dbe",
        "dataset_index": 12196
      },
      "MUX_4to1_599c7b07": {
        "rtl_code": "module MUX_4to1 (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input sel,\n  input en,\n  output out\n);\n\n  reg selected;\n\n  always @(*) begin\n    if (sel == 2'b00) begin\n      selected = in0;\n    end else if (sel == 2'b01) begin\n      selected = in1;\n    end else if (sel == 2'b10) begin\n      selected = in2;\n    end else begin\n      selected = in3;\n    end\n  end\n\n  assign out = en ? selected : 1'b0;\n\nendmodule",
        "module_name": "MUX_4to1",
        "module_hash": "599c7b0740c74bbd68bc7b76998da0f9",
        "dataset_index": 18905
      },
      "binary_multiplier_cc45fb4b": {
        "rtl_code": "module binary_multiplier (\n  input [3:0] a,\n  input [3:0] b,\n  output [7:0] p,\n  output sign\n);\n\n  wire [7:0] temp_p;\n  wire a_sign, b_sign, p_sign;\n  \n  assign a_sign = a[3];\n  assign b_sign = b[3];\n  \n  assign temp_p[0] = a[0] & b;\n  assign temp_p[1] = a[1] & b;\n  assign temp_p[2] = a[2] & b;\n  assign temp_p[3] = a[3] & b;\n  assign temp_p[4] = 4'b0;\n  assign temp_p[5] = 4'b0;\n  assign temp_p[6] = 4'b0;\n  assign temp_p[7] = 4'b0;\n  \n  assign p_sign = a_sign ^ b_sign;\n  \n  assign sign = p_sign;\n  \n  assign p = (p_sign) ? (~temp_p + 1) : temp_p;\n  \nendmodule",
        "module_name": "binary_multiplier",
        "module_hash": "cc45fb4b25c59c494e2deef9e4c9bd6a",
        "dataset_index": 10523
      },
      "priority_encoder_cedccb1c": {
        "rtl_code": "module priority_encoder (\n    input [3:0] I,\n    output [15:0] O\n);\n\n    assign O = (I == 4'h0) ? 16'b0000000000000001 :\n               (I == 4'h1) ? 16'b0000000000000010 :\n               (I == 4'h2) ? 16'b0000000000000100 :\n               (I == 4'h3) ? 16'b0000000000001000 :\n               (I == 4'h4) ? 16'b0000000000010000 :\n               (I == 4'h5) ? 16'b0000000000100000 :\n               (I == 4'h6) ? 16'b0000000001000000 :\n               (I == 4'h7) ? 16'b0000000010000000 :\n               (I == 4'h8) ? 16'b0000000100000000 :\n               (I == 4'h9) ? 16'b0000001000000000 :\n               (I == 4'ha) ? 16'b0000010000000000 :\n               (I == 4'hb) ? 16'b0000100000000000 :\n               (I == 4'hc) ? 16'b0001000000000000 :\n               (I == 4'hd) ? 16'b0010000000000000 :\n               (I == 4'he) ? 16'b0100000000000000 :\n                             16'b1000000000000000 ;\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "cedccb1ccddb0d18219ba2eb763e5b2f",
        "dataset_index": 21255
      },
      "seven_seg_decoder_3c5d74f0": {
        "rtl_code": "\nmodule seven_seg_decoder(\n\t\tnum_in,\n\t\tcontrol,\n\t\tseg_out,\n\t\tdisplay_sel\n);\n\ninput [3:0]  num_in;\n\t\t\tinput [1:0]  control;\n\t\t\toutput [6:0] seg_out;\n\t\t\tinput        display_sel;\n   \n   \nwire [6:0]   seg_out_bcd;\n\t\t\twire [6:0]   seg_out_hex;\n\t\t\twire [6:0]   seg_out_buf;\n   \nassign seg_out = (control == 2'b11 & display_sel == 1'b0) ? 7'b0001001 : seg_out_buf;\n\t\t\t\n\t\t\tassign seg_out_buf = (display_sel == 1'b1) ? seg_out_bcd : seg_out_hex;\n\t\t\t\n\t\t\tassign seg_out_bcd = (num_in == 4'b0000) ? 7'b1000000 : \t\t(num_in == 4'b0001) ? 7'b1111001 : \t\t(num_in == 4'b0010) ? 7'b0100100 : \t\t(num_in == 4'b0011) ? 7'b0110000 : \t\t(num_in == 4'b0100) ? 7'b0011001 : \t\t(num_in == 4'b0101) ? 7'b0010010 : \t\t(num_in == 4'b0110) ? 7'b0000010 : \t\t(num_in == 4'b0111) ? 7'b1111000 : \t\t(num_in == 4'b1000) ? 7'b0000000 : \t\t(num_in == 4'b1001) ? 7'b0010000 : \t\t(num_in == 4'b1010) ? 7'b1111111 : \t\t(num_in == 4'b1011) ? 7'b1000110 : \t\t7'b0111111;\t\t\t\t\t\t\t\t\t\tassign seg_out_hex = (num_in == 4'b0000) ? 7'b1000000 : \t\t(num_in == 4'b0001) ? 7'b1111001 : \t\t(num_in == 4'b0010) ? 7'b0100100 : \t\t(num_in == 4'b0011) ? 7'b0110000 : \t\t(num_in == 4'b0100) ? 7'b0011001 : \t\t(num_in == 4'b0101) ? 7'b0010010 : \t\t(num_in == 4'b0110) ? 7'b0000010 : \t\t(num_in == 4'b0111) ? 7'b1111000 : \t\t(num_in == 4'b1000) ? 7'b0000000 : \t\t(num_in == 4'b1001) ? 7'b0010000 : \t\t(num_in == 4'b1010) ? 7'b0001000 : \t\t(num_in == 4'b1011) ? 7'b0000011 : \t\t(num_in == 4'b1100) ? 7'b1000110 : \t\t(num_in == 4'b1101) ? 7'b0100001 : \t\t(num_in == 4'b1110) ? 7'b0000110 : \t\t7'b0001110;\t\t\t\t\t\t\t\t\t\tendmodule\n",
        "module_name": "seven_seg_decoder",
        "module_hash": "3c5d74f0ddf172a96d1bcd0c13988e88",
        "dataset_index": 10853
      },
      "freq_synthesizer_ade60c03": {
        "rtl_code": "\nmodule freq_synthesizer (\n  input ref_clk,\n  input [n-1:0] ctrl,\n  output reg syn_clk\n);\n\nparameter n = 4; // number of control signals\nparameter m = 8; // number of output signals\nparameter f_out = 100000000; // desired output frequency (100 MHz)\nparameter f_ref = 25000000; // frequency of reference clock signal (25 MHz)\n\nreg [m-1:0] counter;\nreg [n-1:0] divider;\nreg [n-1:0] phase;\nreg [n-1:0] phase_accumulator;\nreg [n-1:0] phase_increment;\nreg [n-1:0] phase_accumulator_next;\n\nwire [n-1:0] ctrl_scaled;\nwire [n-1:0] ctrl_scaled_inv;\nwire [n-1:0] ctrl_scaled_int;\nwire [n-1:0] ctrl_scaled_frac;\n\n// Calculate scaled control signals\nassign ctrl_scaled = $signed(ctrl) * ($signed(f_out) / $signed(f_ref));\nassign ctrl_scaled_inv = ($signed(f_out) / $signed(f_ref)) - ctrl_scaled;\nassign ctrl_scaled_int = ctrl_scaled[n-1:0];\nassign ctrl_scaled_frac = ctrl_scaled - ctrl_scaled_int;\n\n// Clock divider\nalways @ (posedge ref_clk) begin\n  if (counter == 0) begin\n    phase_accumulator <= phase_accumulator_next;\n    counter <= divider;\n  end else begin\n    counter <= counter - 1;\n  end\nend\n\n// Phase increment calculation\nalways @ (posedge ref_clk) begin\n  phase_increment <= ctrl_scaled_int + (ctrl_scaled_frac > phase_accumulator);\nend\n\n// Phase accumulator\nalways @ (posedge ref_clk) begin\n  phase_accumulator_next <= phase_accumulator + phase_increment;\nend\n\n// Output clock generation\nalways @ (posedge ref_clk) begin\n  if (phase_accumulator_next >= (f_out / f_ref)) begin\n    syn_clk <= ~syn_clk;\n  end\nend\n\n// Divider calculation\nalways @ (ctrl_scaled_int, ctrl_scaled_frac) begin\n  divider <= (f_out / f_ref) / (ctrl_scaled_int + ctrl_scaled_frac);\nend\n\nendmodule",
        "module_name": "freq_synthesizer",
        "module_hash": "ade60c03eaa95da704aed7db729343af",
        "dataset_index": 12504
      },
      "shift_register_e623fd33": {
        "rtl_code": "module shift_register (\n  input clk,\n  input load,\n  input [7:0] in,\n  input shift,\n  output reg [7:0] out\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      out <= in;\n    end else if (shift) begin\n      out <= {out[6:0], 1'b0};\n    end\n  end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "e623fd33163e6891ba48e7d7918ed88c",
        "dataset_index": 477
      },
      "v89d234 #_fa4e225b": {
        "rtl_code": "module v89d234 #(\n parameter v422d28 = 0\n) (\n input v41eb95,\n input [7:0] v39f831,\n input vf892a0,\n output [7:0] vb1c024\n);\n localparam p0 = v422d28;\n wire [0:7] w1;\n wire [0:7] w2;\n wire w3;\n wire w4;\n assign vb1c024 = w1;\n assign w2 = v39f831;\n assign w3 = vf892a0;\n assign w4 = v41eb95;\n v89d234_v9148cb #(\n  .INI(p0)\n ) v9148cb (\n  .q(w1),\n  .d(w2),\n  .load(w3),\n  .clk(w4)\n );\nendmodule\n\nmodule v89d234_v9148cb #(\n parameter INI = 0\n) (\n output reg [7:0] q,\n input [7:0] d,\n input load,\n input clk\n);\n always @(posedge clk) begin\n  if (load) begin\n   q <= d;\n  end\n end\nendmodule",
        "module_name": "v89d234 #",
        "module_hash": "fa4e225b2ad26bd79a410d7e1f4e3a48",
        "dataset_index": 11658
      },
      "top__2ffb625e": {
        "rtl_code": "module top_module (\n    input [3:0] A, // 4-bit input to be shifted and multiplied by 3\n    input [1:0] shift_type, // 2-bit control signal to select the type of shift operation\n    input select, // 1-bit control signal to select between multiplication and shift operation\n    output reg [3:0] B // 4-bit output of the active module\n);\n\n    // Multiplication module\n    wire [6:0] mul_output;\n    assign mul_output = A * 3;\n\n    // Barrel shifter module\n    wire [3:0] shift_output;\n    barrel_shifter barrel_shifter_inst(\n        .in(A),\n        .out(shift_output),\n        .shift_type(shift_type)\n    );\n\n    // Additive control logic\n    always @(*) begin\n        if (select == 0) begin\n            B <= mul_output[3:0];\n        end else begin\n            B <= shift_output;\n        end\n    end\n\nendmodule\n\n// Barrel shifter module\nmodule barrel_shifter (\n    input [3:0] in, // 4-bit input to be shifted\n    output reg [3:0] out, // 4-bit output of the shift operation\n    input [1:0] shift_type // 2-bit control signal to select the type of shift operation\n);\n\n    always @(*) begin\n        case (shift_type)\n            2'b00: out = in << 1; // Logical left shift\n            2'b01: out = in >> 1; // Logical right shift\n            2'b10: out = {in[2], in[3], in[3], in[3]}; // Arithmetic left shift\n            2'b11: out = {in[0], in[0], in[0], in[1]}; // Arithmetic right shift\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "2ffb625eda09615807e9a73790a992f7",
        "dataset_index": 356
      },
      "Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Video_Stream_Merger_eb18483f": {
        "rtl_code": "\n\nmodule Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Video_Stream_Merger (\n\tclk,\n\treset,\n\n\tsync_data,\n\tsync_valid,\n\n\tstream_in_data_0,\n\tstream_in_startofpacket_0,\n\tstream_in_endofpacket_0,\n\tstream_in_empty_0,\n\tstream_in_valid_0,\n\n\tstream_in_data_1,\n\tstream_in_startofpacket_1,\n\tstream_in_endofpacket_1,\n\tstream_in_empty_1,\n\tstream_in_valid_1,\n\n\tstream_out_ready,\n\n\tsync_ready,\n\n\tstream_in_ready_0,\n\n\tstream_in_ready_1,\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_empty,\n\tstream_out_valid\n);\n\n\n\nparameter DW = 23; parameter EW = 1; \n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t\t\t\tsync_data;\ninput\t\t\t\t\t\tsync_valid;\n\ninput\t\t\t[DW: 0]\tstream_in_data_0;\ninput\t\t\t\t\t\tstream_in_startofpacket_0;\ninput\t\t\t\t\t\tstream_in_endofpacket_0;\ninput\t\t\t[EW: 0]\tstream_in_empty_0;\ninput\t\t\t\t\t\tstream_in_valid_0;\n\ninput\t\t\t[DW: 0]\tstream_in_data_1;\ninput\t\t\t\t\t\tstream_in_startofpacket_1;\ninput\t\t\t\t\t\tstream_in_endofpacket_1;\ninput\t\t\t[EW: 0]\tstream_in_empty_1;\ninput\t\t\t\t\t\tstream_in_valid_1;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tsync_ready;\n\noutput\t\t\t\t\tstream_in_ready_0;\n\noutput\t\t\t\t\tstream_in_ready_1;\n\noutput reg\t[DW: 0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t[EW: 0]\tstream_out_empty;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire\t\t\t\t\t\tenable_setting_stream_select;\n\nreg\t\t\t\t\t\tbetween_frames;\nreg\t\t\t\t\t\tstream_select_reg;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'h0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_empty\t\t\t\t<=  'h0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (stream_in_ready_0)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= stream_in_data_0;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket_0;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket_0;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty_0;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid_0;\n\tend\n\telse if (stream_in_ready_1)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= stream_in_data_1;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket_1;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket_1;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty_1;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid_1;\n\tend\n\telse if (stream_out_ready)\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tbetween_frames <= 1'b1;\n\telse if (stream_in_ready_0 & stream_in_endofpacket_0)\n\t\tbetween_frames <= 1'b1;\n\telse if (stream_in_ready_1 & stream_in_endofpacket_1)\n\t\tbetween_frames <= 1'b1;\n\telse if (stream_in_ready_0 & stream_in_startofpacket_0)\n\t\tbetween_frames <= 1'b0;\n\telse if (stream_in_ready_1 & stream_in_startofpacket_1)\n\t\tbetween_frames <= 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tstream_select_reg <= 1'b0;\n\telse if (enable_setting_stream_select & sync_valid)\n\t\tstream_select_reg <= sync_data;\nend\n\n\n\nassign sync_ready\t\t\t\t= enable_setting_stream_select;\n\nassign stream_in_ready_0\t= (stream_select_reg) ? \n\t\t1'b0 : stream_in_valid_0 & (~stream_out_valid | stream_out_ready);\n\nassign stream_in_ready_1\t= (stream_select_reg) ? \n\t\tstream_in_valid_1 & (~stream_out_valid | stream_out_ready) : 1'b0;\n\nassign enable_setting_stream_select = \n\t\t  (stream_in_ready_0 & stream_in_endofpacket_0) |\n\t\t  (stream_in_ready_1 & stream_in_endofpacket_1) |\n\t\t(~(stream_in_ready_0 & stream_in_startofpacket_0) & between_frames) |\n\t\t(~(stream_in_ready_1 & stream_in_startofpacket_1) & between_frames);\n\n\n\n\nendmodule\n\n",
        "module_name": "Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Video_Stream_Merger",
        "module_hash": "eb18483f19495c12a955bc0cb64e221c",
        "dataset_index": 24729
      },
      "vending_machine_a52d338a": {
        "rtl_code": "module vending_machine(\n    input clk,\n    input rst,\n    input nickel,\n    input dime,\n    input quarter,\n    input select_A,\n    input select_B,\n    input select_C,\n    output dispense,\n    output change_10,\n    output change_25,\n    output product_A,\n    output product_B,\n    output product_C\n);\n\nreg [7:0] total_amount;\nreg [1:0] product_selected;\nreg [1:0] change_returned;\nwire [7:0] cost = 50;\n\nassign dispense = (total_amount >= cost) & (select_A | select_B | select_C);\nassign change_10 = (change_returned == 2'b10);\nassign change_25 = (change_returned == 2'b01);\nassign product_A = (product_selected == 2'b01);\nassign product_B = (product_selected == 2'b10);\nassign product_C = (product_selected == 2'b11);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        total_amount <= 0;\n        product_selected <= 0;\n        change_returned <= 0;\n    end else begin\n        if (nickel) begin\n            total_amount <= total_amount + 5;\n            change_returned <= 2'b00;\n        end\n        if (dime) begin\n            total_amount <= total_amount + 10;\n            change_returned <= 2'b00;\n        end\n        if (quarter) begin\n            total_amount <= total_amount + 25;\n            change_returned <= 2'b00;\n        end\n        if (select_A) begin\n            if (total_amount >= cost) begin\n                product_selected <= 2'b01;\n                total_amount <= total_amount - cost;\n                change_returned <= total_amount;\n            end else begin\n                product_selected <= 0;\n                total_amount <= 0;\n                change_returned <= 0;\n            end\n        end\n        if (select_B) begin\n            if (total_amount >= cost) begin\n                product_selected <= 2'b10;\n                total_amount <= total_amount - cost;\n                change_returned <= total_amount;\n            end else begin\n                product_selected <= 0;\n                total_amount <= 0;\n                change_returned <= 0;\n            end\n        end\n        if (select_C) begin\n            if (total_amount >= cost) begin\n                product_selected <= 2'b11;\n                total_amount <= total_amount - cost;\n                change_returned <= total_amount;\n            end else begin\n                product_selected <= 0;\n                total_amount <= 0;\n                change_returned <= 0;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "a52d338accc8d0da5aa99b9d11927125",
        "dataset_index": 15957
      },
      "bitwise_operations_38e894cb": {
        "rtl_code": "module bitwise_operations(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and_bitwise,\n    output [2:0] out_xor_bitwise,\n    output [2:0] out_nor_bitwise,\n    output [5:0] out_not\n);\n\n    // Bitwise AND\n    assign out_and_bitwise = a & b;\n\n    // Bitwise XOR\n    assign out_xor_bitwise = a ^ b;\n\n    // Bitwise NOR\n    assign out_nor_bitwise = ~(a | b);\n\n    // NOT of both vectors\n    assign out_not[5:3] = ~b;\n    assign out_not[2:0] = ~a;\n\nendmodule\n\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and_bitwise,\n    output [2:0] out_xor_bitwise,\n    output [2:0] out_nor_bitwise,\n    output [5:0] out_not\n);\n\n    bitwise_operations bitwise_ops(.a(a), .b(b), .out_and_bitwise(out_and_bitwise), .out_xor_bitwise(out_xor_bitwise), .out_nor_bitwise(out_nor_bitwise), .out_not(out_not));\n\nendmodule",
        "module_name": "bitwise_operations",
        "module_hash": "38e894cb63d84e2d1dc0bcd6f36dbd72",
        "dataset_index": 1960
      },
      "hapara_axis_id_generator_v1_0_S00_AXI #_9bd24314": {
        "rtl_code": "\n\n    module hapara_axis_id_generator_v1_0_S00_AXI #\n    (\n        parameter integer C_S_AXI_DATA_WIDTH    = 32,\n        parameter integer C_S_AXI_ADDR_WIDTH    = 4\n    )\n    (\n        input wire Finish,\n        output wire En,\n\n        output wire [C_S_AXI_DATA_WIDTH - 1 : 0] org,\n        output wire [C_S_AXI_DATA_WIDTH - 1 : 0] len,\n        output wire [C_S_AXI_DATA_WIDTH - 1 : 0] numOfSlv,\n\n        input wire  S_AXI_ACLK,\n        input wire  S_AXI_ARESETN,\n        input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,\n        input wire [2 : 0] S_AXI_AWPROT,\n        input wire  S_AXI_AWVALID,\n        output wire  S_AXI_AWREADY,\n        input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,\n        input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,\n        input wire  S_AXI_WVALID,\n        output wire  S_AXI_WREADY,\n        output wire [1 : 0] S_AXI_BRESP,\n        output wire  S_AXI_BVALID,\n        input wire  S_AXI_BREADY,\n        input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,\n        input wire [2 : 0] S_AXI_ARPROT,\n        input wire  S_AXI_ARVALID,\n        output wire  S_AXI_ARREADY,\n        output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,\n        output wire [1 : 0] S_AXI_RRESP,\n        output wire  S_AXI_RVALID,\n        input wire  S_AXI_RREADY\n    );\n\n    reg [C_S_AXI_ADDR_WIDTH-1 : 0]     axi_awaddr;\n    reg      axi_awready;\n    reg      axi_wready;\n    reg [1 : 0]     axi_bresp;\n    reg      axi_bvalid;\n    reg [C_S_AXI_ADDR_WIDTH-1 : 0]     axi_araddr;\n    reg      axi_arready;\n    reg [C_S_AXI_DATA_WIDTH-1 : 0]     axi_rdata;\n    reg [1 : 0]     axi_rresp;\n    reg      axi_rvalid;\n\n    localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;\n    localparam integer OPT_MEM_ADDR_BITS = 1;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg0;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg1;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg2;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg3;\n    wire     slv_reg_rden;\n    wire     slv_reg_wren;\n    reg [C_S_AXI_DATA_WIDTH-1:0]     reg_data_out;\n    integer     byte_index;\n\n    assign S_AXI_AWREADY    = axi_awready;\n    assign S_AXI_WREADY    = axi_wready;\n    assign S_AXI_BRESP    = axi_bresp;\n    assign S_AXI_BVALID    = axi_bvalid;\n    assign S_AXI_ARREADY    = axi_arready;\n    assign S_AXI_RDATA    = axi_rdata;\n    assign S_AXI_RRESP    = axi_rresp;\n    assign S_AXI_RVALID    = axi_rvalid;\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awready <= 1'b0;\n        end\n      else\n        begin\n          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n            begin\n              axi_awready <= 1'b1;\n            end\n          else\n            begin\n              axi_awready <= 1'b0;\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awaddr <= 0;\n        end\n      else\n        begin\n          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n            begin\n              axi_awaddr <= S_AXI_AWADDR;\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_wready <= 1'b0;\n        end\n      else\n        begin\n          if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)\n            begin\n              axi_wready <= 1'b1;\n            end\n          else\n            begin\n              axi_wready <= 1'b0;\n            end\n        end\n    end\n\n    assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 || curr_state == counting)\n        begin\n          slv_reg0 <= 0;\n          slv_reg1 <= 0;\n          slv_reg2 <= 0;\n          end\n      else begin\n        if (slv_reg_wren)\n          begin\n            case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )\n              2'h0:\n                for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )\n                  if ( S_AXI_WSTRB[byte_index] == 1 ) begin\n                    slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];\n                  end\n              2'h1:\n                for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )\n                  if ( S_AXI_WSTRB[byte_index] == 1 ) begin\n                    slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];\n                  end\n              2'h2:\n                for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )\n                  if ( S_AXI_WSTRB[byte_index] == 1 ) begin\n                    slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];\n                  end\n              default : begin\n                          slv_reg0 <= slv_reg0;\n                          slv_reg1 <= slv_reg1;\n                          slv_reg2 <= slv_reg2;\n                          end\n            endcase\n          end\n      end\n    end\n\n    always @(posedge S_AXI_ACLK) begin\n      if (!S_AXI_ARESETN || curr_state == reset || curr_state == counting) begin\n        slv_reg3 <= 0;\n      end\n      else if (curr_state == finish) begin\n        slv_reg3 <= 1;\n      end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_bvalid  <= 0;\n          axi_bresp   <= 2'b0;\n        end\n      else\n        begin\n          if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)\n            begin\n              axi_bvalid <= 1'b1;\n              axi_bresp  <= 2'b0; end                   else\n            begin\n              if (S_AXI_BREADY && axi_bvalid)\n                begin\n                  axi_bvalid <= 1'b0;\n                end\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_arready <= 1'b0;\n          axi_araddr  <= 32'b0;\n        end\n      else\n        begin\n          if (~axi_arready && S_AXI_ARVALID)\n            begin\n              axi_arready <= 1'b1;\n              axi_araddr  <= S_AXI_ARADDR;\n            end\n          else\n            begin\n              axi_arready <= 1'b0;\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rvalid <= 0;\n          axi_rresp  <= 0;\n        end\n      else\n        begin\n          if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)\n            begin\n              axi_rvalid <= 1'b1;\n              axi_rresp  <= 2'b0; end\n          else if (axi_rvalid && S_AXI_RREADY)\n            begin\n              axi_rvalid <= 1'b0;\n            end\n        end\n    end\n\n    assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;\n    always @(*)\n    begin\n          case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )\n            2'h0   : reg_data_out <= slv_reg0;\n            2'h1   : reg_data_out <= slv_reg1;\n            2'h2   : reg_data_out <= slv_reg2;\n            2'h3   : reg_data_out <= slv_reg3;\n            default : reg_data_out <= 0;\n          endcase\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rdata  <= 0;\n        end\n      else\n        begin\n          if (slv_reg_rden)\n            begin\n              axi_rdata <= reg_data_out;     end\n        end\n    end\n\n    reg [C_S_AXI_DATA_WIDTH - 1 : 0] reg_org;\n    reg [C_S_AXI_DATA_WIDTH - 1 : 0] reg_len;\n    reg [C_S_AXI_DATA_WIDTH - 1 : 0] reg_numOfSlv;\n\n    localparam LENGTH   = C_S_AXI_DATA_WIDTH / 2;\n\n    localparam reset    = 3'b001;\n    localparam counting = 3'b010;\n    localparam finish   = 3'b100;\n\n    reg [2 : 0] next_state;\n    reg [2 : 0] curr_state;\n\n    always @(posedge S_AXI_ACLK or negedge S_AXI_ARESETN) begin\n        if (!S_AXI_ARESETN) begin\n            reg_org       <= 0;\n            reg_len       <= 0;\n            reg_numOfSlv  <= 0;\n        end\n        else begin\n            if (curr_state == reset) begin\n                reg_org       <= slv_reg0;\n                reg_len       <= slv_reg1;\n                reg_numOfSlv  <= slv_reg2;\n            end\n            else begin\n                reg_org       <= reg_org;\n                reg_len       <= reg_len;\n                reg_numOfSlv  <= reg_numOfSlv;\n            end\n        end\n    end\n\n    always @(posedge S_AXI_ACLK or negedge S_AXI_ARESETN) begin\n        if (!S_AXI_ARESETN) begin\n            curr_state <= reset;\n        end\n        else begin\n            curr_state <= next_state;\n        end\n    end\n\n    wire data_ready;\n    assign data_ready = \n              (slv_reg1[C_S_AXI_DATA_WIDTH - 1 : LENGTH] != {LENGTH{1'b0}}) &&\n              (slv_reg1[LENGTH - 1 : 0] != {LENGTH{1'b0}});\n\n    always @(curr_state or data_ready or Finish) begin\n        case(curr_state)\n            reset:\n                if (data_ready) begin\n                    next_state = counting;\n                end\n                else begin\n                    next_state = reset;\n                end\n            counting:\n                if (Finish) begin\n                    next_state = finish;\n                end\n                else begin\n                    next_state = counting;\n                end\n            finish:\n                if (data_ready) begin\n                    next_state = reset;\n                end\n                else begin\n                    next_state = finish;\n                end\n            default :\n                next_state = 3'bxxx;\n        endcase\n    end\n\n    assign En = curr_state == counting;\n\n    assign org      = reg_org;\n    assign len      = reg_len;\n    assign numOfSlv = reg_numOfSlv;\n\n\n    endmodule\n",
        "module_name": "hapara_axis_id_generator_v1_0_S00_AXI #",
        "module_hash": "9bd24314f94790024176804908729350",
        "dataset_index": 16014
      },
      "mux4to1_ba773431": {
        "rtl_code": "\nmodule mux4to1 (\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output Y\n);\n\n    wire Y_int;\n    wire not_s0 = ~S0;\n    wire not_s1 = ~S1;\n\n    assign Y_int = (A & not_s1 & not_s0) | (B & not_s1 & S0) | (C & S1 & not_s0) | (D & S1 & S0);\n    assign Y = Y_int;\n\nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "ba773431bf944595e0e37a9da4b2b481",
        "dataset_index": 20444
      },
      "clock_divider_582bb8d0": {
        "rtl_code": "module clock_divider (\n    input CLK,\n    input reset,\n    output reg CLK_div\n);\n\n    reg [3:0] counter;\n\n    always @ (posedge CLK or posedge reset) begin\n        if (reset) begin\n            counter <= 0;\n            CLK_div <= 0;\n        end\n        else begin\n            counter <= counter + 1;\n            if (counter == 4) begin\n                counter <= 0;\n                CLK_div <= ~CLK_div;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "clock_divider",
        "module_hash": "582bb8d0384948aaf099188179f1f251",
        "dataset_index": 10772
      },
      "RetimeWrapper_580_34e4afd5": {
        "rtl_code": "module RetimeWrapper_580(\n  input         clock,\n  input         reset,\n  input  [39:0] io_in,\n  output [39:0] io_out\n);\n  wire [39:0] sr_out;\n  wire [39:0] sr_in;\n  wire  sr_flow;\n  wire  sr_reset;\n  wire  sr_clock;\n  \n  RetimeShiftRegister #(.WIDTH(40), .STAGES(1)) sr (\n    .out(sr_out),\n    .in(sr_in),\n    .flow(sr_flow),\n    .reset(sr_reset),\n    .clock(sr_clock)\n  );\n\n  assign io_out = sr_out;\n  assign sr_in = io_in;\n  assign sr_flow = 1'b1;\n  assign sr_reset = reset;\n  assign sr_clock = clock;\nendmodule\n\nmodule RetimeShiftRegister #(\n  parameter WIDTH = 8,\n  parameter STAGES = 1\n)(\n  output reg [WIDTH-1:0] out,\n  input [WIDTH-1:0] in,\n  input flow,\n  input reset,\n  input clock\n);\n  \n  always @ (posedge clock or posedge reset) begin\n    if (reset) begin\n      out <= 0;\n    end else if (flow) begin\n      out <= in;\n    end\n  end\nendmodule",
        "module_name": "RetimeWrapper_580",
        "module_hash": "34e4afd5a14646a8e3aacbeba2a632df",
        "dataset_index": 7275
      },
      "fifo_43dd9c88": {
        "rtl_code": "module fifo\n(\n    input clk,\n    input rst,\n    input [15:0] din,\n    input wr_en,\n    input rd_en,\n    output reg [15:0] dout,\n    output reg empty,\n    output reg full\n);\n\nreg [15:0] mem [0:7];\nreg [2:0] wr_ptr = 0;\nreg [2:0] rd_ptr = 0;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wr_ptr <= 0;\n        rd_ptr <= 0;\n        empty <= 1;\n        full <= 0;\n    end else begin\n        if (wr_en && !full) begin\n            mem[wr_ptr] <= din;\n            wr_ptr <= wr_ptr + 1;\n            if (wr_ptr == 7) begin\n                wr_ptr <= 0;\n            end\n            empty <= 0;\n            if (wr_ptr == rd_ptr) begin\n                full <= 1;\n            end\n        end\n        if (rd_en && !empty) begin\n            dout <= mem[rd_ptr];\n            rd_ptr <= rd_ptr + 1;\n            if (rd_ptr == 7) begin\n                rd_ptr <= 0;\n            end\n            full <= 0;\n            if (rd_ptr == wr_ptr) begin\n                empty <= 1;\n            end\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "fifo",
        "module_hash": "43dd9c884c1c041d9ac3620e4608f5c7",
        "dataset_index": 6539
      },
      "decoder_fa00d960": {
        "rtl_code": "module decoder (\n  input [1:0] in,\n  input enable,\n  output [3:0] out\n);\n  \n  assign out[0] = ~(in[1] | in[0] | enable);\n  assign out[1] = ~(in[1] | ~in[0] | enable);\n  assign out[2] = ~(~in[1] | in[0] | enable);\n  assign out[3] = ~(~in[1] | ~in[0] | enable);\n  \nendmodule",
        "module_name": "decoder",
        "module_hash": "fa00d9602dc3039bb5d83b2e8c7abb58",
        "dataset_index": 7790
      },
      "niosII_system_switches_280ea208": {
        "rtl_code": "module niosII_system_switches (\n                                // inputs:\n                                 address,\n                                 clk,\n                                 in_port,\n                                 reset_n,\n\n                                // outputs:\n                                 readdata\n                              )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  7: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  7: 0] data_in;\n  wire    [  7: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  \n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {8 {(address == 0)}} & data_in;\n  \n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en) begin\n          case (address)\n            2'b00: readdata <= {24'b0, data_in};\n            2'b01: readdata <= {24'b0, data_in};\n            2'b10: readdata <= {24'b0, data_in};\n            2'b11: readdata <= {data_in, data_in, data_in, data_in};\n            default: readdata <= 0;\n          endcase\n      end\n    end\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "niosII_system_switches",
        "module_hash": "280ea2088de62714d37cfd704d379fb7",
        "dataset_index": 13578
      },
      "debnce_ed986e61": {
        "rtl_code": "\n\nmodule debnce\n  (\n  input  wire        sync,\n  input  wire        clk,\n  output reg         event_on,\n  output reg         event_off\n  );\n\n  reg         [15:0] ctr;\n  reg                dly;\n  wire               sat;\n\n  assign sat = (ctr == 16'hffff);\n\n  always @(posedge clk)\n  begin : saturating_counter\n    case ({sync, sat})\n      0: ctr <= 0;\n      1: ctr <= 0;\n      2: ctr <= ctr + 1;\n    endcase\n    dly <= sat;\n    event_on  <= !dly && sat;\n    event_off <= !sat && dly;\n  end\n\n  endmodule",
        "module_name": "debnce",
        "module_hash": "ed986e61a668fb1ab20a6169d654c030",
        "dataset_index": 23922
      },
      "mux4_0cd01457": {
        "rtl_code": "module mux4(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = in2;\n        2'b11: out = in3;\n    endcase\nend\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "0cd01457f5825a0295b83c0480f0c2dd",
        "dataset_index": 4148
      },
      "ConvolutionalEncoderAndViterbiDecoder #_2eba92c8": {
        "rtl_code": "module ConvolutionalEncoderAndViterbiDecoder #(\n  parameter n = 4, // number of input bits\n  parameter m = 8 // number of output bits\n) (\n  input [n-1:0] in,\n  input clk,\n  output [m-1:0] out\n);\n\n\n// Convolutional Encoder\nreg [n-1:0] shift_reg;\nwire [m-1:0] encoded_bits;\n\nassign encoded_bits[0] = shift_reg[0] ^ shift_reg[1] ^ shift_reg[2] ^ shift_reg[3];\nassign encoded_bits[1] = shift_reg[0] ^ shift_reg[1] ^ shift_reg[3];\nassign encoded_bits[2] = shift_reg[0] ^ shift_reg[2] ^ shift_reg[3];\nassign encoded_bits[3] = shift_reg[1] ^ shift_reg[2] ^ shift_reg[3];\nassign encoded_bits[4] = shift_reg[0] ^ shift_reg[1] ^ shift_reg[2];\nassign encoded_bits[5] = shift_reg[0] ^ shift_reg[2];\nassign encoded_bits[6] = shift_reg[1] ^ shift_reg[3];\nassign encoded_bits[7] = shift_reg[2] ^ shift_reg[3];\n\nalways @(posedge clk) begin\n  shift_reg <= {shift_reg[n-1:0], in};\nend\n\n// Viterbi Decoder\nreg [n-1:0] state;\nreg [n-1:0] next_state;\nreg [n-1:0] decoded_bits;\n\nalways @(posedge clk) begin\n  state <= next_state;\n  decoded_bits <= state;\nend\n\nalways @(*) begin\n  case (state)\n    4'b0000: next_state = {state[2:0], encoded_bits[0]};\n    4'b0001: next_state = {state[2:0], encoded_bits[1]};\n    4'b0010: next_state = {state[2:0], encoded_bits[2]};\n    4'b0011: next_state = {state[2:0], encoded_bits[3]};\n    4'b0100: next_state = {state[2:0], encoded_bits[4]};\n    4'b0101: next_state = {state[2:0], encoded_bits[5]};\n    4'b0110: next_state = {state[2:0], encoded_bits[6]};\n    4'b0111: next_state = {state[2:0], encoded_bits[7]};\n    default: next_state = state;\n  endcase\nend\n\nassign out = decoded_bits;\n\nendmodule",
        "module_name": "ConvolutionalEncoderAndViterbiDecoder #",
        "module_hash": "2eba92c816ec4f274b34abd397ac022d",
        "dataset_index": 8458
      },
      "bcd_ctr_72cfac93": {
        "rtl_code": "\n\n\nmodule bcd_ctr(clk, en, ar, dig1, dig2, dig3);\n  \n\n  \n  input clk, ar, en;\n  output reg  [3:0]  dig1, dig2, dig3;\n\n  \n  wire dig1_carry, dig2_carry, dig3_carry;\n\n  \n  assign dig1_carry = (dig1 == 4'd9); assign dig2_carry = dig1_carry&(dig2 == 4'd9); assign dig3_carry = dig2_carry&(dig3 == 4'd9); \n  always @ (posedge clk or negedge ar)\n  begin\n    if(~ar) begin\n      dig1 <= 4'd0;\n      dig2 <= 4'd0;\n      dig3 <= 4'd0;\n    end else if(~dig3_carry&en) begin\n      if(dig2_carry) begin\n        dig3 <= dig3 + 1; dig2 <= 0; dig1 <= 0;\n\n      end else if(dig1_carry) begin\n        dig2 <= dig2 + 1; dig1 <= 0; end else begin\n        dig1 <= dig1 + 1; end\n    end\n  end\n\n  endmodule",
        "module_name": "bcd_ctr",
        "module_hash": "72cfac93643195ed3115e614532a1eae",
        "dataset_index": 15618
      },
      "opcode_decoder_85da0f30": {
        "rtl_code": "module opcode_decoder(CCLK, rst, instr, IF);\n\tinput CCLK, rst;\n\tinput [31:0] instr;\n\toutput reg [7:0] IF;\n\n\talways @(posedge CCLK)\n\tbegin\n\t\tif (rst)\n\t\t\tIF = 8'd0;\n\t\telse\n\t\tbegin\n\t\t\tcase (instr[31:26])\n\t\t\t\t6'b000000:\n\t\t\t\tbegin \n\t\t\t\t\tcase (instr[5:0])\n\t\t\t\t\t\t6'b100000:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tIF = (|instr[15:11]) ? 8'd1 : 8'd0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t6'b100010: IF = 8'd2;\n\t\t\t\t\t\t6'b100100: IF = 8'd3;\n\t\t\t\t\t\t6'b100101: IF = 8'd4;\n\t\t\t\t\t\t6'b000000: IF = 8'd5;\n\t\t\t\t\t\t6'b000010: IF = 8'd6;\n\t\t\t\t\t\t6'b000011: IF = 8'd7;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\t6'b001000: IF = 8'd8;\n\t\t\t\t6'b001100: IF = 8'd9;\n\t\t\t\t6'b001101: IF = 8'd10;\n\t\t\t\t6'b100011: IF = 8'd11;\n\t\t\t\t6'b101011: IF = 8'd12;\n\t\t\t\t6'b000100: IF = 8'd13;\n\t\t\t\t6'b000101: IF = 8'd14;\n\t\t\t\t6'b000010: IF = 8'd15;\n\t\t\t\tdefault: IF = 8'd0;\n\t\t\tendcase\n\t\tend\n\tend\nendmodule",
        "module_name": "opcode_decoder",
        "module_hash": "85da0f308dcdc5f4d5ac84474d14588b",
        "dataset_index": 9756
      },
      "binary_counter_a25a2953": {
        "rtl_code": "module binary_counter (\n    input CLK,\n    input RST,\n    output [3:0] Q\n);\n\n    // Local signals\n    wire [3:0] Q_next;\n\n    // D flip-flops\n    reg [3:0] Q_reg;\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q_reg <= 4'b0000;\n        end else begin\n            Q_reg <= Q_next;\n        end\n    end\n\n    // Combinational logic\n    assign Q_next = (Q_reg == 4'b1111) ? 4'b0000 : Q_reg + 1'b1;\n    assign Q = Q_reg;\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "a25a2953950b1cde3349a79dbbccd801",
        "dataset_index": 14305
      },
      "pcieCore_gtp_pipe_rate #_76bfde46": {
        "rtl_code": "\n\n\n\nmodule pcieCore_gtp_pipe_rate #\n(\n\n    parameter PCIE_SIM_SPEEDUP = \"FALSE\",                   parameter TXDATA_WAIT_MAX  = 4'd15                      )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_DRP_DONE,\n    input               RATE_RXPMARESETDONE,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output              RATE_DRP_START,\n    output              RATE_DRP_X16,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [ 4:0]  RATE_FSM\n\n);\n\n        reg         [ 1:0]  rate_in_reg1;\n    reg                 drp_done_reg1;\n    reg                 rxpmaresetdone_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg         [ 1:0]  rate_in_reg2;\n    reg                 drp_done_reg2;\n    reg                 rxpmaresetdone_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel =  1'd0; \n    reg         [ 2:0]  rate_out =  3'd0; \n    reg         [ 3:0]  fsm      =  0;                 \n   \n    localparam          FSM_IDLE           = 0; \n    localparam          FSM_TXDATA_WAIT    = 1;           \n    localparam          FSM_PCLK_SEL       = 2; \n    localparam          FSM_DRP_X16_START  = 3;\n    localparam          FSM_DRP_X16_DONE   = 4;   \n    localparam          FSM_RATE_SEL       = 5;\n    localparam          FSM_RXPMARESETDONE = 6; \n    localparam          FSM_DRP_X20_START  = 7;\n    localparam          FSM_DRP_X20_DONE   = 8;   \n    localparam          FSM_RATE_DONE      = 9;\n    localparam          FSM_TXSYNC_START   = 10;\n    localparam          FSM_TXSYNC_DONE    = 11;             \n    localparam          FSM_DONE           = 12; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rate_in_reg1        <= 2'd0;\n        drp_done_reg1       <= 1'd0;\n        rxpmaresetdone_reg1 <= 1'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        drp_done_reg2       <= 1'd0;\n        rxpmaresetdone_reg2 <= 1'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rate_in_reg1        <= RATE_RATE_IN;\n        drp_done_reg1       <= RATE_DRP_DONE;\n        rxpmaresetdone_reg1 <= RATE_RXPMARESETDONE;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rate_in_reg2        <= rate_in_reg1;\n        drp_done_reg2       <= drp_done_reg1;\n        rxpmaresetdone_reg2 <= rxpmaresetdone_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if ((fsm == FSM_RATE_DONE) || (fsm == FSM_RXPMARESETDONE) || (fsm == FSM_DRP_X20_START) || (fsm == FSM_DRP_X20_DONE))\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm      <= FSM_IDLE;\n        pclk_sel <= 1'd0; \n        rate_out <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm      <= FSM_TXDATA_WAIT;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            else\n                begin\n                fsm      <= FSM_IDLE;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            end \n            \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm      <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_SEL : FSM_DRP_X16_START;    \n            pclk_sel <= (rate_in_reg2 == 2'd1);\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X16_DONE : FSM_DRP_X16_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_SEL : FSM_DRP_X16_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_DONE : FSM_RXPMARESETDONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate;                               end    \n            \n        FSM_RXPMARESETDONE :\n        \n            begin\n            fsm      <= (!rxpmaresetdone_reg2) ? FSM_DRP_X20_START : FSM_RXPMARESETDONE;  \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end  \n            \n        FSM_DRP_X20_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X20_DONE : FSM_DRP_X20_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X20_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_DONE : FSM_DRP_X20_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone) \n                fsm <= FSM_TXSYNC_START;\n            else      \n                fsm <= FSM_RATE_DONE;\n            \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm      <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm      <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm      <= FSM_IDLE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm      <= FSM_IDLE;\n            pclk_sel <= 1'd0; \n            rate_out <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL     = pclk_sel;\nassign RATE_DRP_START    = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X20_START); \nassign RATE_DRP_X16      = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X16_DONE);\nassign RATE_RATE_OUT     = rate_out;\nassign RATE_TXSYNC_START = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE         = (fsm == FSM_DONE);\nassign RATE_IDLE         = (fsm == FSM_IDLE);\nassign RATE_FSM          = {1'd0, fsm};   \n\n\n\nendmodule\n",
        "module_name": "pcieCore_gtp_pipe_rate #",
        "module_hash": "76bfde46fbe374c08b07b8ba68c5a4c4",
        "dataset_index": 20669
      },
      "log2_table_5c624209": {
        "rtl_code": "\n\nmodule log2_table\n\t(\n\tinput\t     \tclk,\t\t\tinput\t\ttrilinear_en, \t\tinput\t[31:0]\tval, \t\t\toutput\t[9:0]\tlog2\n\t);\n\n\n\treg\t[3:0]\tint_mm_no;\n\treg\t[5:0]\tlod_fract;\n\n\twire\t\t over_flow;\n\twire\t[9:0]\t log_in;\n\n\tassign log_in = val[17:8];\n\tassign over_flow = |val[31:18];\n\n\n\nalways @(posedge clk) begin\n\tcasex ({over_flow, log_in})\n\t\t11'b0_10xxxxxxx_x, 11'b0_011xxxxxx_x:\tbegin if(trilinear_en && log_in[9]) begin\n\t\t\t\tint_mm_no <= 4'h9; \n\t\t\t\tlod_fract <= val[16:11];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h8;\n\t\t\t\tlod_fract <= val[15:10];\n\t\t\tend\n\t\tend\t\n\t\t11'b0_010xxxxxx_x, 11'b0_0011xxxxx_x: begin if(trilinear_en && log_in[8]) begin\n\t\t\t\tint_mm_no <= 4'h8; \n\t\t\t\tlod_fract <= val[15:10];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h7;\n\t\t\t\tlod_fract <= val[14:9];\n\t\t\tend\n\t\tend\n\t\t11'b0_0010xxxxx_x, 11'b0_00011xxxx_x:\tbegin if(trilinear_en && log_in[7]) begin\n\t\t\t\tint_mm_no <= 4'h7; \n\t\t\t\tlod_fract <= val[14:9];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h6;\n\t\t\t\tlod_fract <= val[13:8];\n\t\t\tend\n\t\tend\n\t\t11'b0_00010xxxx_x, 11'b0_000011xxx_x:\tbegin if(trilinear_en && log_in[6]) begin\n\t\t\t\tint_mm_no <= 4'h6; \n\t\t\t\tlod_fract <= val[13:8];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h5;\n\t\t\t\tlod_fract <= val[12:7];\n\t\t\tend\n\t\tend\n\t\t11'b0_000010xxx_x, 11'b0_0000011xx_x:\tbegin if(trilinear_en && log_in[5]) begin\n\t\t\t\tint_mm_no <= 4'h5; \n\t\t\t\tlod_fract <= val[12:7];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h4;\n\t\t\t\tlod_fract <= val[11:6];\n\t\t\tend\n\t\tend\n\t\t11'b0_0000010xx_x, 11'b0_00000011x_x:\tbegin if(trilinear_en && log_in[4]) begin\n\t\t\t\tint_mm_no <= 4'h4; \n\t\t\t\tlod_fract <= val[11:6];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h3;\n\t\t\t\tlod_fract <= val[10:5];\n\t\t\tend\n\t\tend\n\t\t11'b0_00000010x_x, 11'b0_000000011_x:\tbegin if(trilinear_en && log_in[3]) begin\n\t\t\t\tint_mm_no <= 4'h3; \n\t\t\t\tlod_fract <= val[10:5];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h2;\n\t\t\t\tlod_fract <= val[9:4];\n\t\t\tend\n\t\tend\n\t\t11'b0_000000010_x, 11'b0_000000001_1:\tbegin if(trilinear_en && log_in[2]) begin\n\t\t\t\tint_mm_no <= 4'h2; \n\t\t\t\tlod_fract <= val[9:4];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h1;\n\t\t\t\tlod_fract <= val[8:3];\n\t\t\tend\n\t\tend\n\t\t11'b0_000000001_0, 11'b0_000000000_x:\tbegin if(trilinear_en && log_in[1]) begin\n\t\t\t\tint_mm_no <= 4'h1; \n\t\t\t\tlod_fract <= val[8:3];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h0;\n\t\t\t\tlod_fract <= val[7:2];\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\t\tint_mm_no <= 4'h9; \n\t\t\t\tlod_fract <= val[16:11];\n\t\tend\n\tendcase\nend\n\nassign log2 = {int_mm_no, lod_fract};\n\n\nendmodule\n",
        "module_name": "log2_table",
        "module_hash": "5c624209da85d89ce7c831792a0adedb",
        "dataset_index": 956
      },
      "full_adder_988343a1": {
        "rtl_code": "module full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\nassign S = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire c1, c2, c3;\n\nfull_adder fa1(\n    .A(A[0]),\n    .B(B[0]),\n    .Cin(Cin),\n    .S(S[0]),\n    .Cout(c1)\n);\n\nfull_adder fa2(\n    .A(A[1]),\n    .B(B[1]),\n    .Cin(c1),\n    .S(S[1]),\n    .Cout(c2)\n);\n\nfull_adder fa3(\n    .A(A[2]),\n    .B(B[2]),\n    .Cin(c2),\n    .S(S[2]),\n    .Cout(c3)\n);\n\nfull_adder fa4(\n    .A(A[3]),\n    .B(B[3]),\n    .Cin(c3),\n    .S(S[3]),\n    .Cout(Cout)\n);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "988343a12052f5588ef70e70e1ada8f5",
        "dataset_index": 14181
      },
      "and_gate_93527bb3": {
        "rtl_code": "module and_gate (\n    input A,\n    input B,\n    output X\n);\n\n\n   assign X = A & B;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "93527bb364069183e4a7d84dd3321c5c",
        "dataset_index": 16262
      },
      "TLATNTSCAX2TS_a98c49f8": {
        "rtl_code": "module TLATNTSCAX2TS ( E, SE, CK, ECK );\n  input E, SE, CK;\n  output ECK;\n\n  reg ECK;\n\n  always @(posedge CK) begin\n    if (SE) begin\n      ECK <= 1'b1;\n    end else if (E) begin\n      ECK <= 1'b0;\n    end\n  end\nendmodule",
        "module_name": "TLATNTSCAX2TS",
        "module_hash": "a98c49f83774c0abb212c148b251a4e6",
        "dataset_index": 18915
      },
      "five_to_one_6eae0b9d": {
        "rtl_code": "module five_to_one (\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  B1  ,\n    input  B2  ,\n    output X   ,\n\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    wire A_high = A1 & A2 & A3;\n    wire B_low = ~B1 & ~B2;\n    wire B_high = B1 & B2;\n\n    assign X = (A_high & B_low) | (~A_high & B_high);\n\nendmodule",
        "module_name": "five_to_one",
        "module_hash": "6eae0b9dc5aaa8cf0f2714b5494c164c",
        "dataset_index": 8769
      },
      "data_generator_590bc676": {
        "rtl_code": "module data_generator(\n    input  wire CLK,\n    input  wire CE,\n    output wire D1,\n    output wire D2\n);\n\n    reg [254:0] ring1;\n    initial ring1 <= 255'b010100110101100010111100101101010010011100001110110010000001011011011111011000101110100111001101101100110111101100001111100110000001011011010000111011000010001010101000101111101110110111100110110000001100101111111011010111100001101100001101111111001110111;\n\n    reg [255:0] ring2;\n    initial ring2 <= 256'b1010101100101110000100100101010000100000101110111011110111011111000111101101010101110111010011011101100100011111111101101000111110110110100010011011001001000011100011001001110001110101000001010011011001100101000001011111011101010000110011101111110100110010;\n\n    reg [256:0] ring3;\n    initial ring3 <= 257'b10000001100111000110101001001111100011011001100011011111000100110100110001011101100111110101101111101011000101110100100110110010000111100011111101010000000100101000100100110101011111011000100100001001100110101011111101101011011100010101000111110010110011110;\n\n    always @(posedge CLK)\n        if (CE) ring1 <= {ring1[0], ring1[254:1]};\n    always @(posedge CLK)\n        if (CE) ring2 <= {ring2[0], ring2[255:1]};\n    always @(posedge CLK)\n        if (CE) ring3 <= {ring3[0], ring3[256:1]};\n\n    assign D1 = ring1[0] ^ ring2[0];\n    assign D2 = ring2[0] ^ ring3[0];\n\nendmodule\n",
        "module_name": "data_generator",
        "module_hash": "590bc676fe50f8036a34525bf73e6a37",
        "dataset_index": 22081
      },
      "trafficLightController_9cad11dc": {
        "rtl_code": "\nmodule trafficLightController (\ninput wire clk ,\ninput wire clr ,\noutput reg [5:0] lights\n);\nreg [2:0] state;\nreg [3:0] count;\nparameter S0 = 3'b000, S1 =3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101;\nparameter SEC5 = 4'b0101, SEC1 = 4'b0001; always @(posedge clk or posedge clr)\n begin\n if (clr == 1)\n begin\n state = S0;\n count = 0;\n end\n else\n case(state)\n S0: if(count < SEC5)\n begin\n state = S0;\n count = count + 1'b1;\n end\n else\n begin\n state = S1;\n count = 0;\n end\n S1: if(count < SEC1)\n begin\n state = S1;\n count = count + 1'b1;\n end\n else\n begin\n state = S2;\n count = 0;\n end\n S2: if(count < SEC1)\n begin\n state = S2;\n count = count + 1'b1;\n end\n else\n begin\n state = S3;\n count = 0;\n end \nS3: if(count < SEC5)\n begin\n state = S3;\n count = count + 1'b1;\n end\n else\n begin\n state = S4;\n count = 0;\n end\n S4: if(count < SEC1)\n begin\n state = S4;\n count = count + 1'b1;\n end\n else\n begin\n state = S5;\n count = 0;\n end\n S5: if(count < SEC1)\n begin\n state = S5;\n count = count + 1'b1;\n end\n else\n begin\n state = S0;\n count = 0;\n end\ndefault state = S0;\n endcase\n end\nalways @(*)\n begin\n case(state)\n S0: lights = 6'b100001;\n S1: lights = 6'b100010;\n S2: lights = 6'b100100;\n S3: lights = 6'b001100;\n S4: lights = 6'b010100;\n S5: lights = 6'b100100;\n default lights = 6'b100001;\n endcase\n end\nendmodule\n\n",
        "module_name": "trafficLightController",
        "module_hash": "9cad11dc578cd0bcf2f4b6339a9f73f1",
        "dataset_index": 18084
      },
      "decoder_87eee71c": {
        "rtl_code": "module decoder (\n    input sel2,\n    input sel1,\n    input sel0,\n    input clk,\n    output reg [63:0] out\n);\n\nreg [63:0] stage1_out;\nreg [63:0] stage2_out;\n\nalways @(*) begin\n    if(sel2 == 0 && sel1 == 0 && sel0 == 0) begin\n        stage1_out[0] <= 1'b1;\n        stage1_out[63:1] <= 64'b0;\n    end\n    else if(sel2 == 1 && sel1 == 0 && sel0 == 0) begin\n        stage1_out[8] <= 1'b1;\n        stage1_out[63:9] <= 56'b0;\n        stage1_out[7:0] <= 8'b0;\n    end\n    else if(sel2 == 0 && sel1 == 1 && sel0 == 1) begin\n        stage1_out[56] <= 1'b1;\n        stage1_out[63:57] <= 56'b0;\n    end\n    else if(sel2 == 1 && sel1 == 1 && sel0 == 0) begin\n        stage1_out[60] <= 1'b1;\n        stage1_out[63:61] <= 3'b0;\n        stage1_out[60:0] <= 60'b0;\n    end\n    else if(sel2 == 0 && sel1 == 1 && sel0 == 1) begin\n        stage1_out[48] <= 1'b1;\n        stage1_out[63:49] <= 15'b0;\n        stage1_out[48:0] <= 48'b0;\n    end\n    else begin\n        stage1_out[63:48] <= 16'b0;\n        stage1_out[47:0] <= 48'b0;\n    end\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\nend\n\nalways @* begin\n    out = stage2_out;\nend\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "87eee71c1c0e1ee0e16f9e28f23293d2",
        "dataset_index": 12025
      },
      "long_to_double_03e9b678": {
        "rtl_code": "module long_to_double(\n        input_a,\n        input_a_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [63:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  output    [63:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [63:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [2:0] state;\n  parameter get_a         = 3'd0,\n            convert_0     = 3'd1,\n            convert_1     = 3'd2,\n            convert_2     = 3'd3,\n            round         = 3'd4,\n            pack          = 3'd5,\n            put_z         = 3'd6;\n\n  reg [63:0] a, z, value;\n  reg [52:0] z_m;\n  reg [10:0] z_r;\n  reg [10:0] z_e;\n  reg z_s;\n  reg guard, round_bit, sticky;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= convert_0;\n        end\n      end\n\n      convert_0:\n      begin\n        if ( a == 0 ) begin\n          z_s <= 0;\n          z_m <= 0;\n          z_e <= -1023;\n          state <= pack;\n        end else begin\n          value <= a[63] ? -a : a;\n          z_s <= a[63];\n          state <= convert_1;\n        end\n      end\n\n      convert_1:\n      begin\n        z_e <= 63;\n        z_m <= value[63:11];\n        z_r <= value[10:0];\n        state <= convert_2;\n      end\n\n      convert_2:\n      begin\n        if (!z_m[52]) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= z_r[10];\n          z_r <= z_r << 1;\n        end else begin\n          guard <= z_r[10];\n          round_bit <= z_r[9];\n          sticky <= z_r[8:0] != 0;\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit || sticky || z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 53'h1fffffffffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[51 : 0] <= z_m[51:0];\n        z[62 : 52] <= z_e + 1023;\n        z[63] <= z_s;\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n",
        "module_name": "long_to_double",
        "module_hash": "03e9b678f70c6bb3ff35c6248cbdce7d",
        "dataset_index": 20221
      },
      "tmu2_mask_3c653f2f": {
        "rtl_code": "\n\nmodule tmu2_mask(\n\tinput sys_clk,\n\tinput sys_rst,\n\n\toutput busy,\n\n\tinput pipe_stb_i,\n\toutput pipe_ack_o,\n\tinput signed [11:0] dx,\n\tinput signed [11:0] dy,\n\tinput signed [17:0] tx,\n\tinput signed [17:0] ty,\n\n\tinput [17:0] tex_hmask,\n\tinput [17:0] tex_vmask,\n\n\toutput reg pipe_stb_o,\n\tinput pipe_ack_i,\n\toutput reg signed [11:0] dx_f,\n\toutput reg signed [11:0] dy_f,\n\toutput reg signed [17:0] tx_m,\n\toutput reg signed [17:0] ty_m\n);\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tpipe_stb_o <= 1'b0;\n\telse begin\n\t\tif(pipe_ack_i)\n\t\t\tpipe_stb_o <= 1'b0;\n\t\tif(pipe_stb_i & pipe_ack_o) begin\n\t\t\tpipe_stb_o <= 1'b1;\n\t\t\tdx_f <= dx;\n\t\t\tdy_f <= dy;\n\t\t\ttx_m <= tx & tex_hmask;\n\t\t\tty_m <= ty & tex_vmask;\n\t\tend\n\tend\nend\n\nassign pipe_ack_o = ~pipe_stb_o | pipe_ack_i;\n\nassign busy = pipe_stb_o;\n\nendmodule\n",
        "module_name": "tmu2_mask",
        "module_hash": "3c653f2fded86a24cddad07f07e70033",
        "dataset_index": 23405
      },
      "mux_1bit_a75f320e": {
        "rtl_code": "module mux_1bit (\n  input ctrl,\n  input [0:0] D0,\n  input [0:0] D1,\n  output reg [0:0] S\n);\n\n  always @(*) begin\n    case(ctrl)\n      1'b0: S = D0;\n      1'b1: S = D1;\n    endcase\n  end\n\nendmodule",
        "module_name": "mux_1bit",
        "module_hash": "a75f320ec15f3ea54de1f3043d1f5062",
        "dataset_index": 7339
      },
      "calculator_ca780195": {
        "rtl_code": "\nmodule calculator (\n    input [3:0] num1,\n    input [3:0] num2,\n    input [1:0] op_type,\n    output [7:0] result,\n    output overflow\n);\n\n    wire [7:0] adder_out;\n    wire [7:0] multiplier_out;\n    wire [7:0] num1_extended;\n    wire [7:0] num2_extended;\n    wire [3:0] highest_bit_num1;\n    wire [3:0] highest_bit_num2;\n    wire [3:0] highest_bit;\n    wire [7:0] zero;\n    assign zero = 8'b0;\n    assign overflow = (adder_out[7] == adder_out[6] && adder_out[6] != op_type[0]);\n\n    // Convert 4-bit numbers to 8-bit numbers\n    assign num1_extended = {4'b0, num1};\n    assign num2_extended = {4'b0, num2};\n\n    // Priority encoder to detect highest bit\n    assign highest_bit_num1 = (num1_extended[7]) ? 4'b1000 :\n                             (num1_extended[6]) ? 4'b0100 :\n                             (num1_extended[5]) ? 4'b0010 :\n                             (num1_extended[4]) ? 4'b0001 :\n                             4'b0000;\n    assign highest_bit_num2 = (num2_extended[7]) ? 4'b1000 :\n                             (num2_extended[6]) ? 4'b0100 :\n                             (num2_extended[5]) ? 4'b0010 :\n                             (num2_extended[4]) ? 4'b0001 :\n                             4'b0000;\n    assign highest_bit = (highest_bit_num1 > highest_bit_num2) ? highest_bit_num1 : highest_bit_num2;\n\n    // Carry-lookahead adder for addition and subtraction\n    CLA_adder adder(\n        .A(num1_extended),\n        .B(num2_extended),\n        .Cin(op_type[0]),\n        .Sum(adder_out),\n        .Cout()\n    );\n\n    // Repeated addition for multiplication\n    assign multiplier_out = (op_type[1]) ? num1_extended * num2_extended : 8'b0;\n\n    // Select final output based on operation type\n    assign result = (op_type == 2'b00) ? adder_out :\n                    (op_type == 2'b01) ? adder_out :\n                    multiplier_out;\n\nendmodule\nmodule CLA_adder (\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    wire [7:0] P;\n    wire [7:0] G;\n    wire [7:0] C;\n    wire [7:0] C_propagate;\n    wire [7:0] C_generate;\n\n    assign P = A ^ B;\n    assign G = A & B;\n    assign C_propagate[0] = Cin;\n    assign C_generate[0] = G[0];\n    generate\n        genvar i;\n        for (i = 1; i < 8; i = i + 1) begin : generate_CLA\n            assign C_propagate[i] = P[i-1];\n            assign C_generate[i] = G[i] | (P[i] & C_generate[i-1]);\n        end\n    endgenerate\n\n    assign C = C_propagate | C_generate;\n    assign Sum = P ^ Cin;\n    assign Cout = C[7];\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "ca78019500fc8e2d33ab8162546922f1",
        "dataset_index": 9951
      },
      "robotic_arm_controller_c295b48a": {
        "rtl_code": "module robotic_arm_controller (\n    input clk,\n    input btn,\n    output reg [0:0] X\n);\n\n    reg [1:0] pos = 2'b00; // initialize arm position to 0\n\n    always @(posedge clk) begin\n        if (btn) begin\n            // move arm to next position in sequence\n            pos <= pos + 1;\n            if (pos == 2'b10) // reset to position 0\n                pos <= 2'b00;\n        end\n    end\n\n    always @(*) begin\n        X = pos[0];\n    end\n    \nendmodule\n\nmodule sky130_fd_sc_hd__o21ba_1 (\n    input X,\n    input A1,\n    input A2,\n    input B1_N\n);\n\n    // Implement the functionality of the arm module\n\nendmodule",
        "module_name": "robotic_arm_controller",
        "module_hash": "c295b48ad38a3772c0346a742767a252",
        "dataset_index": 5955
      },
      "cordic_demod_5e29e978": {
        "rtl_code": "module cordic_demod (\n\tinput clk,\n\tinput resetn,\n\n\tinput s_axis_valid,\n\toutput s_axis_ready,\n\tinput [63:0] s_axis_data,\n\n\toutput m_axis_valid,\n\tinput m_axis_ready,\n\toutput [63:0] m_axis_data\n);\n\nreg [4:0] step_counter;\nreg [4:0] shift_counter;\nreg [30:0] phase;\nreg [2:0] state;\n\nreg [32:0] i;\nreg [32:0] q;\nreg [32:0] i_shift;\nreg [32:0] q_shift;\n\nassign s_axis_ready = state == STATE_IDLE;\nassign m_axis_data = {q[32:1],i[32:1]};\nassign m_axis_valid = state == STATE_DONE;\n\nlocalparam STATE_IDLE = 0;\nlocalparam STATE_SHIFT_LOAD = 1;\nlocalparam STATE_SHIFT = 2;\nlocalparam STATE_ADD = 3;\nlocalparam STATE_DONE = 4;\n\nreg [31:0] angle[0:30];\n\ninitial begin\n\tangle[0] = 32'h20000000;\n\tangle[1] = 32'h12e4051e;\n\tangle[2] = 32'h09fb385b;\n\tangle[3] = 32'h051111d4;\n\tangle[4] = 32'h028b0d43;\n\tangle[5] = 32'h0145d7e1;\n\tangle[6] = 32'h00a2f61e;\n\tangle[7] = 32'h00517c55;\n\tangle[8] = 32'h0028be53;\n\tangle[9] = 32'h00145f2f;\n\tangle[10] = 32'h000a2f98;\n\tangle[11] = 32'h000517cc;\n\tangle[12] = 32'h00028be6;\n\tangle[13] = 32'h000145f3;\n\tangle[14] = 32'h0000a2fa;\n\tangle[15] = 32'h0000517d;\n\tangle[16] = 32'h000028be;\n\tangle[17] = 32'h0000145f;\n\tangle[18] = 32'h00000a30;\n\tangle[19] = 32'h00000518;\n\tangle[20] = 32'h0000028c;\n\tangle[21] = 32'h00000146;\n\tangle[22] = 32'h000000a3;\n\tangle[23] = 32'h00000051;\n\tangle[24] = 32'h00000029;\n\tangle[25] = 32'h00000014;\n\tangle[26] = 32'h0000000a;\n\tangle[27] = 32'h00000005;\n\tangle[28] = 32'h00000003;\n\tangle[29] = 32'h00000001;\n\tangle[30] = 32'h00000001;\nend\n\nalways @(posedge clk) begin\n\tif (resetn == 1'b0) begin\n\t\tstate <= STATE_IDLE;\n\tend else begin\n\t\tcase (state)\n\t\tSTATE_IDLE: begin\n\t\t\tif (s_axis_valid == 1'b1) begin\n\t\t\t\tstate <= STATE_SHIFT_LOAD;\n\t\t\tend\n\t\tend\n\t\tSTATE_SHIFT_LOAD: begin\n\t\t\tif (step_counter == 'h00) begin\n\t\t\t\tstate <= STATE_ADD;\n\t\t\tend else begin\n\t\t\t\tstate <= STATE_SHIFT;\n\t\t\tend\n\t\tend\n\t\tSTATE_SHIFT: begin\n\t\t\tif (shift_counter == 'h01) begin\n\t\t\t\tstate <= STATE_ADD;\n\t\t\tend\n\t\tend\n\t\tSTATE_ADD: begin\n\t\t\tif (step_counter == 'd30) begin\n\t\t\t\tstate <= STATE_DONE;\n\t\t\tend else begin\n\t\t\t\tstate <= STATE_SHIFT_LOAD;\n\t\t\tend\n\t\tend\n\t\tSTATE_DONE: begin\n\t\t\tif (m_axis_ready == 1'b1)\n\t\t\t\tstate <= STATE_IDLE;\n\t\tend\n\t\tendcase\n\tend\nend\n\nalways @(posedge clk) begin\n\tcase(state)\n\tSTATE_SHIFT_LOAD: begin\n\t\tshift_counter <= step_counter;\n\tend\n\tSTATE_SHIFT: begin\n\t\tshift_counter <= shift_counter - 1'b1;\n\tend\n\tendcase\nend\n\nalways @(posedge clk)\nbegin\n\tcase(state)\n\tSTATE_IDLE:\n\t\tif (s_axis_valid == 1'b1) begin\n\t\t\tstep_counter <= 'h00;\n\t\t\tphase <= {1'b0,s_axis_data[61:32]};\n\t\t\tstep_counter <= 'h00;\n\t\t\tcase (s_axis_data[63:62])\n\t\t\t2'b00: begin\n\t\t\t\ti <= {s_axis_data[31],s_axis_data[31:0]};\n\t\t\t\tq <= 'h00;\n\t\t\tend\n\t\t\t2'b01: begin\n\t\t\t\ti <= 'h00;\n\t\t\t\tq <= ~{s_axis_data[31],s_axis_data[31:0]};\n\t\t\tend\n\t\t\t2'b10: begin\n\t\t\t\ti <= ~{s_axis_data[31],s_axis_data[31:0]};\n\t\t\t\tq <= 'h00;\n\t\t\tend\n\t\t\t2'b11: begin\n\t\t\t\ti <= 'h00;\n\t\t\t\tq <= {s_axis_data[31],s_axis_data[31:0]};\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\tSTATE_SHIFT_LOAD: begin\n\t\ti_shift <= i;\n\t\tq_shift <= q;\n\tend\n\tSTATE_SHIFT: begin\n\t\ti_shift <= {i_shift[32],i_shift[32:1]};\n\t\tq_shift <= {q_shift[32],q_shift[32:1]};\n\tend\n\tSTATE_ADD: begin\n\t\tif (phase[30] == 1'b0) begin\n\t\t\ti <= i + q_shift;\n\t\t\tq <= q - i_shift;\n\t\t\tphase <= phase - angle[step_counter];\n\t\tend else begin\n\t\t\ti <= i - q_shift;\n\t\t\tq <= q + i_shift;\n\t\t\tphase <= phase + angle[step_counter];\n\t\tend\n\t\tstep_counter <= step_counter + 1'b1;\n\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "cordic_demod",
        "module_hash": "5e29e97878586bc9dc13222cac11dfa8",
        "dataset_index": 21656
      },
      "edgedetect_005731c1": {
        "rtl_code": "module edgedetect (\n    input iCLK      ,\n    input iRST      ,\n    input iSIG      ,\n    output wire oRE ,\n    output wire oFE ,\n    output wire oRFE\n);\n\nparameter registered = \"FALSE\";\n\nreg delay;\n\nwire re;\nwire fe;\nwire rfe;\n\n\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        delay <= 1'b0;\n    end\n    else\n    begin\n        delay <= iSIG;\n    end\nend\n\n\n// Edge detect logic\nassign re   = (iSIG && !delay) ? 1'b1 : 1'b0;\nassign fe   = (!iSIG && delay) ? 1'b1 : 1'b0;\nassign rfe  = ((iSIG && !delay) || (!iSIG && delay)) ? 1'b1 : 1'b0;\n\n\n// Register edge detect pulses\nreg re_reg, fe_reg, rfe_reg;\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        re_reg     <= 1'b0;\n        fe_reg     <= 1'b0;\n        rfe_reg    <= 1'b0;\n    end\n    else\n    begin\n        re_reg     <= re;\n        fe_reg     <= fe;\n        rfe_reg    <= rfe;\n    end\nend\n\n\n// MUX either the combination or registered edge detect pulses to the outputs\nassign oRE =    (registered == \"TRUE\") ? re_reg  : re ;\nassign oFE =    (registered == \"TRUE\") ? fe_reg  : fe ;\nassign oRFE =   (registered == \"TRUE\") ? rfe_reg : rfe;\n\n\nendmodule",
        "module_name": "edgedetect",
        "module_hash": "005731c19df8595eec8688a117066513",
        "dataset_index": 3451
      },
      "freq_divider #_b13f2218": {
        "rtl_code": "module freq_divider #(\n  parameter width = 8 // width of the output signal\n)(\n  input clk,\n  input rst,\n  input [7:0] div,\n  output reg [width-1:0] out\n);\n\n\nreg [7:0] count;\nreg toggle;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    count <= 0;\n    out <= 0;\n    toggle <= 0;\n  end else begin\n    count <= count + 1;\n    if (count == div) begin\n      toggle <= ~toggle;\n      count <= 0;\n    end\n    out <= toggle;\n  end\nend\n\nendmodule",
        "module_name": "freq_divider #",
        "module_hash": "b13f2218253af14673cdf758970504db",
        "dataset_index": 3684
      },
      "top__32ae27f1": {
        "rtl_code": "module top_module (\n    input [15:0] in,\n    input [3:0] sel,\n    input EN,\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] op,\n    output reg [3:0] out,\n    output reg valid\n);\n\nreg [3:0] mux_out;\nreg [3:0] alu_out;\n\n// 16-to-1 multiplexer\nalways @(*) begin\n    case(sel)\n        4'd0: mux_out = in[3:0];\n        4'd1: mux_out = in[7:4];\n        4'd2: mux_out = in[11:8];\n        4'd3: mux_out = in[15:12];\n        default: mux_out = 4'b0;\n    endcase\nend\n\n// 4-bit ALU\nalways @(*) begin\n    case(op)\n        3'b000: alu_out = A + B;\n        3'b001: alu_out = A - B;\n        3'b010: alu_out = A & B;\n        3'b011: alu_out = A | B;\n        3'b100: alu_out = A ^ B;\n        default: alu_out = 4'b0;\n    endcase\nend\n\n// Final output module\nalways @(*) begin\n    if(valid) begin\n        out = alu_out;\n    end else if(EN) begin\n        out = mux_out;\n    end else begin\n        out = 4'b0;\n    end\n    \n    valid = (op != 3'b101);\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "32ae27f1665f1e08e166be071be1adba",
        "dataset_index": 16421
      },
      "xadc_data_demux_8964d56d": {
        "rtl_code": "\n\nmodule xadc_data_demux \n    (\n     input             clk,\n     input             reset,\n\n     input [15:0]      xadc_data,\n     input             xadc_data_ready,\n     input [4:0]       channel,\n     output reg [15:0] xadc_vaux0_data,\n     output reg        xadc_vaux0_ready,\n     output reg [15:0] xadc_vaux8_data,\n     output reg        xadc_vaux8_ready\n     );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            xadc_vaux0_data  <= 16'd0;\n            xadc_vaux0_ready <= 1'b0;\n        end\n        else\n            if (xadc_data_ready && (channel == 5'h10)) begin\n                xadc_vaux0_data  <= xadc_data;\n                xadc_vaux0_ready <= 1'b1;\n            end \n            else\n                xadc_vaux0_ready <= 1'b0;\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            xadc_vaux8_data  <= 16'd0;\n            xadc_vaux8_ready <= 1'b0;\n        end\n        else\n            if (xadc_data_ready && (channel == 5'h18)) begin\n                xadc_vaux8_data  <= xadc_data;\n                xadc_vaux8_ready <= 1'b1;\n            end\n            else\n                xadc_vaux8_ready <= 1'b0;\n    end\n    \nendmodule\n\n                \n            \n\n    \n    \n    \n",
        "module_name": "xadc_data_demux",
        "module_hash": "8964d56de6b138ea57578c8957486769",
        "dataset_index": 6738
      },
      "ECC_memory_block#_bcabed1d": {
        "rtl_code": "\nmodule ECC_memory_block#(\n    parameter n=8,\n    parameter m=4\n)(\n    input [n-1:0] data_in,\n    input we,\n    output [n-1:0] data_out,\n    input re\n);\n\nreg [n+m-1:0] memory_block;\nreg [n-1:0] corrected_data;\nreg read_enable;\n\nfunction [n+m-1:0] hamming_encode;\n    input [n-1:0] data;\n        integer i, j, parity_pos;\n        begin\n            for(i=0;i<n;i=i+1)\n                begin\n                    hamming_encode[i+m]=data[i];\n                end\n            for(i=0;i<m;i=i+1)\n                begin\n                    parity_pos=2**i;\n                    hamming_encode[parity_pos-1]=0;\n                    for(j=0;j<n+m;j=j+1)\n                        begin\n                            if((j+1)&parity_pos)\n                                begin\n                                    hamming_encode[parity_pos-1]=hamming_encode[parity_pos-1]^hamming_encode[j]; \n                                end\n                        end\n                end\n        end\nendfunction\n\nfunction [n-1:0] hamming_decode;\n     input [n+m-1:0] encoded_data;\n         integer i,j,parity_pos,error_pos;\n         reg [n+m-1:0] corrected_encoded_data;\n         begin\n             error_pos=0;\n             for(i=0;i<m;i=i+1)\n                begin\n                    parity_pos=2**i;\n                    for(j=0;j<n+m;j=j+1)\n                    begin\n                        if((j+1)&parity_pos)\n                            begin\n                                if(encoded_data[j])\n                                    begin\n                                        error_pos=error_pos^(j+1);\n                                    end\n                            end\n                    end\n                end\n            corrected_encoded_data=encoded_data;\n            if(error_pos)\n            begin\n                corrected_encoded_data[error_pos-1]=~corrected_encoded_data[error_pos-1];\n            end\n            for(i=0;i<n;i=i+1)\n                begin\n                    hamming_decode[i]=corrected_encoded_data[i+m];\n                end\n        end\nendfunction\n\nalways @(posedge we or negedge we)\n    begin\n        if(!we)\n            begin\n                memory_block<=hamming_encode(data_in);\n            end\n    end\n\nalways @(*)\n    begin\n        if(re)\n        begin\n            read_enable<=1'b1;\n            corrected_data<=hamming_decode(memory_block);\n        end\n        else\n            begin\n                read_enable<=1'b0;\n                corrected_data<=8'd0;\n            end\n    end\n\nassign data_out=read_enable?corrected_data:8'd0;\n\nendmodule",
        "module_name": "ECC_memory_block#",
        "module_hash": "bcabed1dc68d01f43b42e812f8072021",
        "dataset_index": 18991
      },
      "custom__8905dd08": {
        "rtl_code": "module custom_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign Y = (A1 && !A2 && A3 && B1 && !B2) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "custom_",
        "module_hash": "8905dd080086b77822ae2b174faece83",
        "dataset_index": 11980
      },
      "iddr #_448b20d0": {
        "rtl_code": "\n\n`resetall\n\n\n\n\nmodule iddr #\n(\n    parameter TARGET = \"GENERIC\",\n    parameter IODDR_STYLE = \"IODDR2\",\n    parameter WIDTH = 1\n)\n(\n    input  wire             clk,\n\n    input  wire [WIDTH-1:0] d,\n\n    output wire [WIDTH-1:0] q1,\n    output wire [WIDTH-1:0] q2\n);\n\n\n\ngenvar n;\n\ngenerate\n\nif (TARGET == \"XILINX\") begin\n    for (n = 0; n < WIDTH; n = n + 1) begin : iddr\n        if (IODDR_STYLE == \"IODDR\") begin\n            IDDR #(\n                .DDR_CLK_EDGE(\"SAME_EDGE_PIPELINED\"),\n                .SRTYPE(\"ASYNC\")\n            )\n            iddr_inst (\n                .Q1(q1[n]),\n                .Q2(q2[n]),\n                .C(clk),\n                .CE(1'b1),\n                .D(d[n]),\n                .R(1'b0),\n                .S(1'b0)\n            );\n        end else if (IODDR_STYLE == \"IODDR2\") begin\n            IDDR2 #(\n                .DDR_ALIGNMENT(\"C0\")\n            )\n            iddr_inst (\n                .Q0(q1[n]),\n                .Q1(q2[n]),\n                .C0(clk),\n                .C1(~clk),\n                .CE(1'b1),\n                .D(d[n]),\n                .R(1'b0),\n                .S(1'b0)\n            );\n        end\n    end\nend else if (TARGET == \"ALTERA\") begin\n    wire [WIDTH-1:0] q1_int;\n    reg [WIDTH-1:0] q1_delay;\n\n    altddio_in #(\n        .WIDTH(WIDTH),\n        .POWER_UP_HIGH(\"OFF\")\n    )\n    altddio_in_inst (\n        .aset(1'b0),\n        .datain(d),\n        .inclocken(1'b1),\n        .inclock(clk),\n        .aclr(1'b0),\n        .dataout_h(q1_int),\n        .dataout_l(q2)\n    );\n\n    always @(posedge clk) begin\n        q1_delay <= q1_int;\n    end\n\n    assign q1 = q1_delay;\nend else begin\n    reg [WIDTH-1:0] d_reg_1 = {WIDTH{1'b0}};\n    reg [WIDTH-1:0] d_reg_2 = {WIDTH{1'b0}};\n\n    reg [WIDTH-1:0] q_reg_1 = {WIDTH{1'b0}};\n    reg [WIDTH-1:0] q_reg_2 = {WIDTH{1'b0}};\n\n    always @(posedge clk) begin\n        d_reg_1 <= d;\n    end\n\n    always @(negedge clk) begin\n        d_reg_2 <= d;\n    end\n\n    always @(posedge clk) begin\n        q_reg_1 <= d_reg_1;\n        q_reg_2 <= d_reg_2;\n    end\n\n    assign q1 = q_reg_1;\n    assign q2 = q_reg_2;\nend\n\nendgenerate\n\nendmodule\n\n`resetall\n",
        "module_name": "iddr #",
        "module_hash": "448b20d01b0c38cad6a96e76b619b0e7",
        "dataset_index": 22336
      },
      "deserializer_e2531279": {
        "rtl_code": "module deserializer(\n\tclk, \t\t//serialized data proper clock\n\tenable, \t//suspend while enable on low\n\treset, \t\t//set output to zero and reset counter to 0 on high\n\tframesize, \t//number of bits to be deserialized\n\tin, \t\t//serialized data\n\tout, \t\t//deserialized data\n\tcomplete\t//reset counter to 0 and hold out's data while high\n);\n\n\tparameter BITS = 32;\t\t//size of deserializer\n\tparameter BITS_COUNTER = 8;\t//size of counter, must be at least log2(BITS)\n\n\tinput clk, enable, reset, in;\n\tinput [BITS_COUNTER-1:0] framesize;\n\n\toutput reg complete;\n\toutput reg [BITS-1:0] out;\n\treg [BITS_COUNTER-1:0] counter;\t//we need to know which array item (out) to write on\n\n\n\talways@(posedge clk) begin\n\n\t\tif (reset==1'b1) begin\n\t\t\tout <= 32'b00000000000000000000000000000000;\n\t\t\tcounter <= 8'b00000000;\n\t\t\tcomplete <= 1'b0;\n\t\tend\n\t\telse if (enable==1'b1) begin\n\t\t\tif (complete==1'b0) begin\n\t\t\t\tout[counter] <= in;\n\t\t\t\tcounter  <= counter + 1;\t//next item\n\t\t\tend\n\t\t\tif (counter==framesize) begin\n\t\t\t\tcomplete <= 1'b1;\n\t\t\tend\n\t\tend\n\t\telse begin\n\t\t\tcomplete <= 1'b0;\n\t\tend\n\tend\n\nendmodule",
        "module_name": "deserializer",
        "module_hash": "e2531279e5aa10275cb0e899503dfd60",
        "dataset_index": 7031
      },
      "mux_2to1_51bde008": {
        "rtl_code": "module mux_2to1 (\n  input a,\n  input b,\n  input sel,\n  output out\n);\n\n  assign out = (sel == 1'b0) ? a : b;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "51bde00846a90ce02925fa20e9564f91",
        "dataset_index": 10649
      },
      "adapter_block_fifo_2_axi_stream #_1d0a6c61": {
        "rtl_code": "\n\nmodule adapter_block_fifo_2_axi_stream #(\n  parameter                                     DATA_WIDTH          = 24,\n  parameter                                     STROBE_WIDTH        = DATA_WIDTH / 8,\n  parameter                                     USE_KEEP            = 0,\n  parameter                                     USER_IN_DATA   = 1\n)(\n  input                                         rst,\n\n  input                                         i_block_fifo_rdy,\n  output  reg                                   o_block_fifo_act,\n  input       [23:0]                            i_block_fifo_size,\n  input       [(DATA_WIDTH + 1) - 1:0]          i_block_fifo_data,\n  output                                        o_block_fifo_stb,\n  input       [3:0]                             i_axi_user,\n\n  input                                         i_axi_clk,\n  output      [3:0]                             o_axi_user,\n  input                                         i_axi_ready,\n  output      [DATA_WIDTH - 1:0]                o_axi_data,\n  output                                        o_axi_last,\n  output  reg                                   o_axi_valid,\n\n  output      [31:0]                            o_debug\n);\n\nlocalparam      IDLE        = 0;\nlocalparam      READY       = 1;\nlocalparam      RELEASE     = 2;\n\nreg     [3:0]               state;\nreg     [23:0]              r_count;\n\nassign  o_axi_data      = i_block_fifo_data[DATA_WIDTH - 1: 0];\nassign  o_block_fifo_stb= (i_axi_ready & o_axi_valid);\n\nif (USER_IN_DATA) begin\n  assign  o_axi_user[0]   = (r_count < i_block_fifo_size) ? i_block_fifo_data[DATA_WIDTH] : 1'b0;\n  assign  o_axi_user[3:1] = 3'h0;\nend\nelse begin\n  assign  o_axi_user      = i_axi_user;\nend\n\nassign  o_axi_last      = ((r_count + 1) >= i_block_fifo_size) & o_block_fifo_act  & o_axi_valid;\nassign  o_debug[3:0]    = state;\nassign  o_debug[4]      = (r_count < i_block_fifo_size) ? i_block_fifo_data[DATA_WIDTH]: 1'b0;\nassign  o_debug[5]      = o_block_fifo_act;\nassign  o_debug[6]      = i_block_fifo_rdy;\nassign  o_debug[7]      = (r_count > 0);\nassign  o_debug[8]      = (i_block_fifo_size > 0);\nassign  o_debug[9]      = (r_count == i_block_fifo_size);\nassign  o_debug[15:10]  = 0;\nassign  o_debug[23:16]  = r_count[7:0];\nassign  o_debug[31:24]  = 0;\n\nalways @ (posedge i_axi_clk) begin\n  o_axi_valid           <=  0;\n\n  if (rst) begin\n    state               <=  IDLE;\n    o_block_fifo_act    <=  0;\n    r_count             <=  0;\n  end\n  else begin\n    case (state)\n      IDLE: begin\n        o_block_fifo_act    <=  0;\n        if (i_block_fifo_rdy && !o_block_fifo_act) begin\n          r_count       <=  0;\n          o_block_fifo_act  <=  1;\n          state         <=  READY;\n        end\n      end\n      READY: begin\n        if (r_count < i_block_fifo_size) begin\n          o_axi_valid         <=  1;\n          if (i_axi_ready && o_axi_valid) begin\n            r_count         <= r_count + 1;\n            if ((r_count + 1) >= i_block_fifo_size) begin\n              o_axi_valid     <=  0;\n            end\n          end\n        end\n        else begin\n          o_block_fifo_act  <=  0;\n          state             <=  RELEASE;\n        end\n      end\n      RELEASE: begin\n        state               <=  IDLE;\n      end\n      default: begin\n      end\n    endcase\n  end\nend\n\nendmodule\n",
        "module_name": "adapter_block_fifo_2_axi_stream #",
        "module_hash": "1d0a6c61b13b5af1767c1dc6b4608cff",
        "dataset_index": 23294
      },
      "my__92210f8f": {
        "rtl_code": "module my_module (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  C1  \n);\n\n    // Local signals\n    wire and0_out;\n    wire or0_out_X;\n\n    // Name Output Other arguments\n    and and0 (and0_out, A1, A2);\n    or or0 (or0_out_X, and0_out, C1, B1);\n    buf buf0 (X, or0_out_X);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "92210f8f31686e896b5582b5ae184f78",
        "dataset_index": 7680
      },
      "MUX41X1_e33a77f3": {
        "rtl_code": "\nmodule MUX41X1 (IN1,IN2,IN3,IN4,S0,S1,Q);\n\n input IN1,IN2,IN3,IN4,S0,S1;\n output Q;\n\n wire t1,t2;\n\n assign t1 = (S1 & IN1) | (~S1 & IN2);\n assign t2 = (S1 & IN3) | (~S1 & IN4);\n assign Q = (S0 & t1) | (~S0 & t2);\n\nendmodule\n",
        "module_name": "MUX41X1",
        "module_hash": "e33a77f3778f3998e4fbde74d300a354",
        "dataset_index": 3695
      },
      "digit_state_machine_36259936": {
        "rtl_code": "module digit_state_machine(\n\t\n\tinput clk,\n\tinput reset_n,\n\tinput [3:0] units,\n\tinput [3:0] tens,\n\tinput [3:0] hundreds,\n\tinput [3:0] thousands,\n\t\n\toutput reg [2:0] digit_select,\n\toutput reg [3:0] data,\n\toutput reg decimal_point\n\t);\n\t\n\treg [1:0] state;\n\treg [1:0] state_n;\n\t\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\tparameter S3 = 2'b11;\n\t\n\talways @ (posedge clk, negedge reset_n)\n\t\tbegin\n\t\t\tif(!reset_n)\n\t\t\t\tstate <= S0;\n\t\t\telse\n\t\t\t\tstate <= state_n;\n\t\tend\n\t\t\n\t\talways @ (*)\n\t\t\tbegin\n\t\t\t\tcase(state)\n\t\t\t\t\tS0: state_n = S1;\n\t\t\t\t\tS1: state_n = S2;\n\t\t\t\t\tS2: state_n = S3;\n\t\t\t\t\tS3:\tstate_n = S0;\n\t\t\t\t\t\n\t\t\t\t\tdefault: state_n = S0;\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t\n\t\talways @ (*)\n\t\t\tbegin\n\t\t\t\tcase(state)\n\t\t\t\tS0: begin\n\t\t\t\t\tdecimal_point = 1;\n\t\t\t\t\tdigit_select = 3'b000;\n\t\t\t\t\tdata = units;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tS1: begin\n\t\t\t\t\tdecimal_point = 1;\n\t\t\t\t\tdigit_select = 3'b001;\n\t\t\t\t\tdata = tens;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tS2: begin\n\t\t\t\t\tdecimal_point = 1;\n\t\t\t\t\tdigit_select = 3'b011;\n\t\t\t\t\tdata = hundreds;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tS3: begin\n\t\t\t\t\tdecimal_point = 0;\n\t\t\t\t\tdigit_select = 3'b100;\n\t\t\t\t\tdata = thousands;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\nendmodule",
        "module_name": "digit_state_machine",
        "module_hash": "362599362727df8f1e727f2ec07bd7bf",
        "dataset_index": 21547
      },
      "dff_async_reset_2660d03d": {
        "rtl_code": "module dff_async_reset (\n    input CLK,\n    input D,\n    input RST,\n    output reg Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "dff_async_reset",
        "module_hash": "2660d03d11dcd458ff5e7d2d736fa3fc",
        "dataset_index": 3469
      },
      "Profibus_5be60331": {
        "rtl_code": "\nmodule Profibus (\n  input wire clk,\n  input wire rst,\n  input wire [7:0] data_in,\n  output wire [7:0] data_out,\n  output wire enable,\n  output wire busy\n);\n\n// Master block\nwire [7:0] master_data_out;\nwire [7:0] master_data_in;\nwire master_enable;\nwire master_busy;\n\n// Slave block\nwire [7:0] slave_data_in;\nwire [7:0] slave_data_out;\nwire slave_enable;\nwire slave_busy;\n\n// Communication protocol\nreg [1:0] state;\nparameter IDLE = 2'b00,\n          SEND = 2'b01,\n          RECEIVE = 2'b10;\nassign enable = master_enable;\nassign busy = master_busy;\nassign data_out = slave_data_out;\n\n// State machine\nalways @(posedge clk) begin\n  if(rst) begin\n    state <= IDLE;\n  end else begin\n    case(state)\n      IDLE: begin if (enable) begin state <= SEND; end end\n      SEND: begin if (~master_busy) begin state <= RECEIVE; end end\n      RECEIVE: begin if (~slave_busy) begin state <= IDLE; end end\n    endcase\n  end\nend\n\n// Master block\nassign master_data_out = (state == SEND) ? data_in : 8'b0;\nassign master_enable = (state == SEND);\nassign master_busy = (state == SEND || state == RECEIVE);\nassign slave_data_in = master_data_out;\n\n// Slave block\nassign slave_data_out = (state == RECEIVE) ? master_data_out : 8'b0;\nassign slave_enable = (state == RECEIVE);\nassign slave_busy = (state == SEND || state == RECEIVE);\n\nendmodule",
        "module_name": "Profibus",
        "module_hash": "5be603314d9fc45130ebad236c21d3b0",
        "dataset_index": 8887
      },
      "RegisterFile_98a849f1": {
        "rtl_code": "module RegisterFile(input clk,\n    input [1:0] io_rs1_thread,\n    input [4:0] io_rs1_addr,\n    output[31:0] io_rs1_data,\n    input [1:0] io_rs2_thread,\n    input [4:0] io_rs2_addr,\n    output[31:0] io_rs2_data,\n    input [1:0] io_rd_thread,\n    input [4:0] io_rd_addr,\n    input [31:0] io_rd_data,\n    input  io_rd_enable\n);\n\n  reg [31:0] dout2;\n  wire[31:0] T0;\n  wire[31:0] T1;\n  reg [31:0] regfile [127:0];\n  wire[31:0] T2;\n  wire[6:0] T3;\n  wire[6:0] T4;\n  wire T5;\n  reg [31:0] dout1;\n  wire[31:0] T6;\n  wire[31:0] T7;\n  wire[6:0] T8;\n  wire T9;\n\n  // Read data from the register file based on the thread identifier and address inputs of each read port\n  assign io_rs2_data = dout2;\n  assign T0 = T5 ? 32'h0 : T1;\n  assign T1 = regfile[T4];\n  assign T3 = {io_rd_addr, io_rd_thread};\n  assign T4 = {io_rs2_addr, io_rs2_thread};\n  assign T5 = io_rs2_addr == 5'h0;\n  assign io_rs1_data = dout1;\n  assign T6 = T9 ? 32'h0 : T7;\n  assign T7 = regfile[T8];\n  assign T8 = {io_rs1_addr, io_rs1_thread};\n  assign T9 = io_rs1_addr == 5'h0;\n\n  // Write data to the register file based on the thread identifier, address, data inputs, and write enable signal of the write port\n  always @(posedge clk) begin\n    if(T5) begin\n      dout2 <= 32'h0;\n    end else begin\n      dout2 <= T1;\n    end\n    if (io_rd_enable)\n      regfile[T3] <= io_rd_data;\n    if(T9) begin\n      dout1 <= 32'h0;\n    end else begin\n      dout1 <= T7;\n    end\n    if (io_rd_enable && io_rd_thread == 2'b00)\n      regfile[io_rd_addr] <= io_rd_data;\n    if (io_rd_enable && io_rd_thread == 2'b01)\n      regfile[io_rd_addr+32] <= io_rd_data;\n    if (io_rd_enable && io_rd_thread == 2'b10)\n      regfile[io_rd_addr+64] <= io_rd_data;\n  end\nendmodule",
        "module_name": "RegisterFile",
        "module_hash": "98a849f1d60e99cc3933d1f89b8dbab0",
        "dataset_index": 18599
      },
      "calculator_e4263e46": {
        "rtl_code": "module calculator (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input [1:0] op,\n    output reg signed [7:0] result\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = a + b;\n        2'b01: result = a - b;\n        2'b10: result = a * b;\n        2'b11: begin\n            if(b == 0) begin\n                result = 8'hFF; // division by zero error code\n            end else begin\n                result = a / b;\n            end\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "e4263e469bbf9ccd9e76cd501155214b",
        "dataset_index": 7634
      },
      "my_nor2_99b08adc": {
        "rtl_code": "module my_nor2 (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = ~(A | B_N);\n\nendmodule",
        "module_name": "my_nor2",
        "module_hash": "99b08adca4d995eaaea4c313366d30a6",
        "dataset_index": 14969
      },
      "mux4 #_4401027c": {
        "rtl_code": "module mux4 #(parameter WIDTH = 8)\n             (input  [WIDTH-1:0] d0, d1, d2, d3, \n              input  [1:0] sel, \n              output [WIDTH-1:0] y);\n\n  wire [WIDTH-1:0] s0, s1;\n  assign s0 = sel[0] ? d2 : d0;\n  assign s1 = sel[0] ? d3 : d1;\n  assign y = sel[1] ? s1 : s0;\n\nendmodule",
        "module_name": "mux4 #",
        "module_hash": "4401027c1dd1eb4817fe8f87987be4b1",
        "dataset_index": 5144
      },
      "simple_adder_6c4b96ed": {
        "rtl_code": "module simple_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] C\n);\n\nalways @ (A, B) begin\n    C = A + B;\nend\n\nendmodule",
        "module_name": "simple_adder",
        "module_hash": "6c4b96edce7a4f598db10e8557bd18c2",
        "dataset_index": 11342
      },
      "sky130_fd_sc_hd__nand4_23b3fe90": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, D, C, B, A     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nand4",
        "module_hash": "23b3fe903e89441e9eaf69c41141065b",
        "dataset_index": 18929
      },
      "data_deal_45058c79": {
        "rtl_code": "\nmodule data_deal(\n\tclk,\n\trst_n,\n\tdata_in,\n\tdata_in_sign,\n\t\n\tdata_out,\n\tdata_out_sign,\n\tdata_valid,\n\tdata_ok\n    );\n\t\n\t\n\t\n\tinput \tclk;\n\tinput \trst_n;\n\tinput \t[6:0]\tdata_in;\n\tinput \tdata_in_sign;\n\t\n\toutput\t[6:0]\tdata_out;\n\toutput\tdata_out_sign;\n\tinput \tdata_valid;\n\toutput\tdata_ok;\n\t\n\t\n\t\n\treg\t\t[6:0]\tdata_reg;\n\treg\t\t\t\tdata_ok;\n\t\n\treg\t\t[6:0]\tdata_out;\n\treg\t\t\t\tdata_out_sign;\n\treg\t\t\t\tdata_in_sign_reg;\n\t\n\t\n\talways @(posedge  clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdata_reg <= 7'h0;\n\t\t\tdata_ok <= 1'h0;\n\t\t\tdata_in_sign_reg <= 1'b0;\n\t\tend\n\t\telse begin\t\n\t\t\tdata_in_sign_reg <= data_in_sign;\n\t\t\tdata_reg <= data_in_sign ? data_reg + 1'b1 : data_reg;\n\t\t\tdata_ok <= data_in_sign_reg ? &(data_reg ~^ data_in) : data_ok;\n\t\tend\n\tend\n\t\n\t\n\talways @(posedge  clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdata_out_sign <= 1'b0;\n\t\t\tdata_out <= 'h0;\n\t\tend\n\t\telse begin\t\n\t\t\tif(~data_out_sign & data_valid)\t\tdata_out_sign <= 1'b1;\n\t\t\telse \t\t\t\t\t\t\t\tdata_out_sign <= 1'b0;\n\t\t\tdata_out <= ~data_out_sign & data_valid ? data_out + 1'b1 : data_out;\n\t\tend\n\tend\n\t\n\n\nendmodule\n",
        "module_name": "data_deal",
        "module_hash": "45058c79200d9e70a40dd147e998ebae",
        "dataset_index": 21587
      },
      "acl_fp_convert_from_long_119dc670": {
        "rtl_code": "module acl_fp_convert_from_long(clock, resetn, dataa, result, enable, valid_in, valid_out, stall_in, stall_out);\n\tparameter UNSIGNED = 0;\n\tparameter HIGH_CAPACITY = 1;\n\tparameter ROUNDING_MODE = 0;\t\n    input clock, resetn;\n\tinput [63:0] dataa;\n\toutput [31:0] result;\n\tinput enable, valid_in, stall_in;\n\toutput valid_out, stall_out;\n\t\n\treg c1_valid;\n\twire c1_stall;\n\twire c1_enable;\n\treg c2_valid;\n\twire c2_stall;\n\twire c2_enable;\n\treg c3_valid;\n\twire c3_stall;\n\twire c3_enable;\n\treg c4_valid;\n\twire c4_stall;\n\twire c4_enable;\n\treg c5_valid;\n\twire c5_stall;\n\twire c5_enable;\t\n\t\n\treg [63:0] c1_value_to_convert;\n\treg c1_sign;\n\tassign c1_enable = (HIGH_CAPACITY == 1) ? (~c1_valid | ~c1_stall) : enable;\n\tassign stall_out = c1_valid & c1_stall;\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc1_valid <= 1'b0;\n\t\t\tc1_sign <= 1'bx;\n\t\t\tc1_value_to_convert <= 64'dx;\n\t\tend\n\t\telse if (c1_enable)\n\t\tbegin\n\t\t\tc1_valid <= valid_in;\n\t\t\t\n\t\t\tif (UNSIGNED == 1)\n\t\t\tbegin\n\t\t\t\tc1_sign <= 1'b0;\n\t\t\t\tc1_value_to_convert <= dataa;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tc1_sign <= dataa[63];\n\t\t\t\tc1_value_to_convert <= (dataa ^ {64{dataa[63]}}) + {1'b0, dataa[63]};\n\t\t\tend\n\t\tend\n\tend\n\t\n\treg [63:0] c2_value_to_convert;\n\treg [7:0] c2_exponent;\n\treg c2_sign, c2_done;\n\tassign c2_enable = (HIGH_CAPACITY == 1) ? (~c2_valid | ~c2_stall) : enable;\n\tassign c1_stall = c2_valid & c2_stall;\t\n\t\n\twire top_bits_0 = ~(|c1_value_to_convert[63:32]);\n\twire top_bits_half_0 = ~(|c1_value_to_convert[63:48]);\n\twire bottom_bits_0 = ~(|c1_value_to_convert[31:0]);\n\twire bottom_bits_half_0 = ~(|c1_value_to_convert[31:16]);\n\t\n\treg [1:0] c2_shift_value;\n\talways@(*)\n\tbegin\n\t\tc2_shift_value[1] = top_bits_0;\n\t\tc2_shift_value[0] = top_bits_0 & bottom_bits_half_0 | ~top_bits_0 & top_bits_half_0;\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc2_valid <= 1'b0;\n\t\t\tc2_value_to_convert <= 64'dx;\n\t\t\tc2_exponent <= 8'dx;\n\t\t\tc2_sign <= 1'bx;\n\t\t\tc2_done <= 1'bx;\n\t\tend\n\t\telse if (c2_enable)\n\t\tbegin\n\t\t\tc2_valid <= c1_valid;\n\t\t\tc2_sign <= c1_sign;\n   \t\tc2_done <= top_bits_0 & bottom_bits_0;\t\t\t\n\t\t\tif (top_bits_0 & bottom_bits_0)\n\t\t\tbegin\n\t\t\t\tc2_exponent <= 8'd0;\n\t\t\t\tc2_value_to_convert <= c1_value_to_convert;\n\t\t\tend\n\t\t\telse \n\t\t\tbegin\n\t\t\t\tc2_exponent <= 8'd190 - {1'b0, c2_shift_value, 4'd0}; case(c2_shift_value)\n\t\t\t\t  2'b11: c2_value_to_convert <= {c1_value_to_convert[15:0], 48'd0};\n\t\t\t\t  2'b10: c2_value_to_convert <= {c1_value_to_convert[31:0], 32'd0};\n\t\t\t\t  2'b01: c2_value_to_convert <= {c1_value_to_convert[47:0], 16'd0};\n\t\t\t\t  2'b00: c2_value_to_convert <= c1_value_to_convert;\n\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\tend\n\t\n\treg [63:0] c3_value_to_convert;\n\treg [7:0] c3_exponent;\n\treg c3_sign, c3_done;\n\tassign c3_enable = (HIGH_CAPACITY == 1) ? (~c3_valid | ~c3_stall) : enable;\n\tassign c2_stall = c3_valid & c3_stall;\t\n\t\n\twire top_12bits_0 = ~(|c2_value_to_convert[63:52]);\n\twire top_8bits_0 = ~(|c2_value_to_convert[63:56]);\n\twire top_4bits_0 = ~(|c2_value_to_convert[63:60]);\n\t\n\treg [1:0] c3_exp_adjust;\n\talways@(*)\n\tbegin\n\t\tif (top_12bits_0 & ~c2_done)\n\t\t\tc3_exp_adjust = 2'd3;\n\t\telse if (top_8bits_0 & ~c2_done)\n\t\t\tc3_exp_adjust = 2'd2;\n\t\telse if (top_4bits_0 & ~c2_done)\n\t\t\tc3_exp_adjust = 2'd1;\n\t\telse\n\t\t\tc3_exp_adjust = 2'd0;\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc3_valid <= 1'b0;\n\t\t\tc3_value_to_convert <= 64'dx;\n\t\t\tc3_exponent <= 8'dx;\n\t\t\tc3_sign <= 1'bx;\n\t\t\tc3_done <= 1'bx;\n\t\tend\n\t\telse if (c3_enable)\n\t\tbegin\n\t\t\tc3_valid <= c2_valid;\n\t\t\tc3_sign <= c2_sign;\n\t\t\tc3_done <= c2_done;\n\t\t\tc3_exponent <= c2_exponent - {1'b0, c3_exp_adjust, 2'd0};\n\t\t\tcase (c3_exp_adjust)\n\t\t\t\t2'b11: c3_value_to_convert <= {c2_value_to_convert[51:0], 12'd0};\n\t\t\t\t2'b10: c3_value_to_convert <= {c2_value_to_convert[55:0], 8'd0};\n\t\t\t\t2'b01: c3_value_to_convert <= {c2_value_to_convert[59:0], 4'd0};\n\t\t\t\t2'b00: c3_value_to_convert <= c2_value_to_convert;\n\t\t\tendcase\n\t\tend\n\tend\t\n\n\treg [63:0] c4_value_to_convert;\n\treg [7:0] c4_exponent;\n\treg c4_sign;\n\tassign c4_enable = (HIGH_CAPACITY == 1) ? (~c4_valid | ~c4_stall) : enable;\n\tassign c3_stall = c4_valid & c4_stall;\t\n\t\n\twire top_3bits_0 = ~(|c3_value_to_convert[63:61]);\n\twire top_2bits_0 = ~(|c3_value_to_convert[63:62]);\n\twire top_1bits_0 = ~(c3_value_to_convert[63]);\n\t\n\treg [1:0] c4_exp_adjust;\n\talways@(*)\n\tbegin\n\t\tif (top_3bits_0 & ~c3_done)\n\t\t\tc4_exp_adjust = 2'd3;\n\t\telse if (top_2bits_0 & ~c3_done)\n\t\t\tc4_exp_adjust = 2'd2;\n\t\telse if (top_1bits_0 & ~c3_done)\n\t\t\tc4_exp_adjust = 2'd1;\n\t\telse\n\t\t\tc4_exp_adjust = 2'd0;\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc4_valid <= 1'b0;\n\t\t\tc4_value_to_convert <= 64'dx;\n\t\t\tc4_exponent <= 8'dx;\n\t\t\tc4_sign <= 1'bx;\n\t\tend\n\t\telse if (c4_enable)\n\t\tbegin\n\t\t\tc4_valid <= c3_valid;\n\t\t\tc4_sign <= c3_sign;\n\t\t\tc4_exponent <= c3_exponent - {1'b0, c4_exp_adjust};\n\t\t\tcase (c4_exp_adjust)\n\t\t\t\t2'b11: c4_value_to_convert <= {c3_value_to_convert[60:0], 3'd0};\n\t\t\t\t2'b10: c4_value_to_convert <= {c3_value_to_convert[61:0], 2'd0};\n\t\t\t\t2'b01: c4_value_to_convert <= {c3_value_to_convert[62:0], 1'd0};\n\t\t\t\t2'b00: c4_value_to_convert <= c3_value_to_convert;\n\t\t\tendcase\n\t\tend\n\tend\t\n\t\n\treg [22:0] c5_mantissa;\n\treg [7:0] c5_exponent;\n\treg c5_sign;\n\t\n\tassign c5_enable = (HIGH_CAPACITY == 1) ? (~c5_valid | ~c5_stall) : enable;\n\tassign c4_stall = c5_valid & c5_stall;\t\n\twire [3:0] c5_bottom_4 = {c4_value_to_convert[40:38], |c4_value_to_convert[37:0]};\n\treg [24:0] c5_temp_mantissa;\n    always@(*)\n\tbegin\n\t\tcase (ROUNDING_MODE)\n\t\t\t4: begin\n\t\t\t\tif (UNSIGNED == 1)\n\t\t\t\tbegin\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\t\t\n\t\t\t\t\tif (|c5_bottom_4[2:0] & c4_sign)\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\tend\n\t\t\n\t\t\t3: begin\n\t\t\t\tif (UNSIGNED == 1)\n\t\t\t\tbegin\n\t\t\t\t\tif (|c5_bottom_4[2:0])\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\t\t\n\t\t\t\t\tif (|c5_bottom_4[2:0] & ~c4_sign)\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\tend\n\n   \t\t2: begin\n\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\tend\n\t\t\t\n\t\t\t1: begin\n\t\t\t\tif (c5_bottom_4[2])\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\tend\n\n  \t\t   default: begin\n\t\t\t\tif ((&c5_bottom_4[3:2]) || (c5_bottom_4[2] & |c5_bottom_4[1:0]))\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\tend\n\t\tendcase\t\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc5_valid <= 1'b0;\n\t\t\tc5_mantissa <= 32'dx;\n\t\t\tc5_exponent <= 8'dx;\n\t\t\tc5_sign <= 1'bx;\n\t\tend\n\t\telse if (c5_enable)\n\t\tbegin\n\t\t\tc5_valid <= c4_valid;\n\t\t\tc5_sign <= c4_sign;\n\t\t\tc5_exponent <= c4_exponent + c5_temp_mantissa[24];\n\t\t\tc5_mantissa <= c5_temp_mantissa[24] ? c5_temp_mantissa[23:1] :  c5_temp_mantissa[22:0];\n\t\tend\n\tend\t\n\n\tassign c5_stall = stall_in;\n\tassign result = {c5_sign, c5_exponent, c5_mantissa};\n\tassign valid_out = c5_valid;\nendmodule\n\n",
        "module_name": "acl_fp_convert_from_long",
        "module_hash": "119dc6708ce8084d84ec0f1b16fb412a",
        "dataset_index": 25568
      },
      "axi_protocol_converter_v2_1_8_b2s_wr_cmd_fsm_5bf4e5e9": {
        "rtl_code": "\n\n\n \nmodule axi_protocol_converter_v2_1_8_b2s_wr_cmd_fsm (\ninput  wire                                 clk           ,\n  input  wire                                 reset         ,\n  output wire                                 s_awready       ,\n  input  wire                                 s_awvalid       ,\n  output wire                                 m_awvalid        ,\n  input  wire                                 m_awready      ,\n  output wire                                 next          ,\n  input  wire                                 next_pending  ,\n  output wire                                 b_push        ,\n  input  wire                                 b_full        ,\n  output wire                                 a_push\n);\n\nlocalparam SM_IDLE                = 2'b00;\nlocalparam SM_CMD_EN              = 2'b01;\nlocalparam SM_CMD_ACCEPTED        = 2'b10;\nlocalparam SM_DONE_WAIT           = 2'b11;\n\nreg [1:0]       state;\nreg [1:0]       next_state;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    state <= SM_IDLE;\n  end else begin\n    state <= next_state;\n  end\nend\n\nalways @( * )\nbegin\n  next_state = state;\n  case (state)\n    SM_IDLE:\n      if (s_awvalid) begin\n        next_state = SM_CMD_EN;\n      end else\n        next_state = state;\n\n    SM_CMD_EN:\n      if (m_awready & next_pending)\n        next_state = SM_CMD_ACCEPTED;\n      else if (m_awready & ~next_pending & b_full)\n        next_state = SM_DONE_WAIT;\n      else if (m_awready & ~next_pending & ~b_full)\n        next_state = SM_IDLE;\n      else\n        next_state = state;\n\n    SM_CMD_ACCEPTED:\n      next_state = SM_CMD_EN;\n\n    SM_DONE_WAIT:\n      if (!b_full)\n        next_state = SM_IDLE;\n      else\n        next_state = state;\n\n      default:\n        next_state = SM_IDLE;\n  endcase\nend\n\nassign m_awvalid  = (state == SM_CMD_EN);\n\nassign next    = ((state == SM_CMD_ACCEPTED)\n                 | (((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE))) ;\n\nassign a_push  = (state == SM_IDLE);\nassign s_awready = ((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE);\nassign b_push  = ((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE);\n\nendmodule\n\n\n\n",
        "module_name": "axi_protocol_converter_v2_1_8_b2s_wr_cmd_fsm",
        "module_hash": "5bf4e5e988dc9d4198579ded622f6b3a",
        "dataset_index": 25268
      },
      "KEY2INST_fbdac6ad": {
        "rtl_code": "module KEY2INST(\n\tinput clk,\n\tinput[15:0] button,\n\tinput[31:0] inst_a,\n\toutput[31:0] inst_do,\n\toutput clrn\n);\n\n\t//CMD\n\tparameter [2:0]\n\t\tcmd_add = 3'b000,\n\t\tcmd_sub = 3'b001,\n\t\tcmd_and = 3'b010,\n\t\tcmd_or = 3'b011,\n\t\tcmd_xor = 3'b100,\n\t\tcmd_sll = 3'b101,\n\t\tcmd_srl = 3'b110,\n\t\tcmd_sra = 3'b111;\n\n\t//Select\n\tparameter [1:0]\n\t\tsl_al = 2'b00,\n\t\tsl_ah = 2'b01,\n\t\tsl_bl = 2'b10,\n\t\tsl_bh = 2'b11;\n\n\t//State\n\tparameter [4:0]\n\t\tst_idle = 5'b00001,\n\t\tst_load = 5'b00010,\n\t\tst_run = 5'b00100,\n\t\tst_wrom = 5'b01000,\n\t\tst_reset = 5'b10000;\n\n\t//func\n\tparameter [5:0]\n\tfunc_add = 6'b100000,\n\tfunc_sub = 6'b100010,\n\tfunc_and = 6'b100100,\n\tfunc_or = 6'b100101,\n\tfunc_xor = 6'b100110,\n\tfunc_sll = 6'b000000,\n\tfunc_srl = 6'b000010,\n\tfunc_sra = 6'b000011;\n\n\treg[31:0] inst_rom[31:0];\n\twire rst_n;\n\twire run;\n\twire load;\n\twire[2:0] cmd;\n\twire[1:0] select;\n\twire[7:0] data;\n\treg[4:0] st;\n\treg r_clrn;\n\n\t//ah,al,bh,bl\n\treg[7:0] data_now[3:0];\n\treg[25:0] cmd_do;\n\n\tassign rst_n = button[15];\n\tassign run = button[14];\n\tassign load = button[13];\n\tassign cmd = button[12:10];\n\tassign select = button[9:8];\n\tassign data = button[7:0];\n\n\tassign clrn = r_clrn;\n\tassign inst_do = inst_rom[inst_a[6:2]];\n\n\tinteger i;\n\tinitial begin\n\t\tst <= st_idle;\n\t\tfor(i=0;i<4;i=i+1)\n\t\t\tdata_now[i] <= 8'b0;\n\t\tfor(i=0;i<32;i=i+1)\n\t\t\tinst_rom[i] <= 32'b0;\n\tend\n\n\t//Cmd_do\n\talways @(*) begin \n\t\tcase (cmd)\n\t\t\tcmd_add : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_add};\n\t\t\tcmd_sub : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_sub};\n\t\t\tcmd_and : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_and};\n\t\t\tcmd_or : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_or};\n\t\t\tcmd_xor : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_xor};\n\t\t\tcmd_sll : cmd_do <= {5'b0,5'b00001,5'b00011,data_now[3][4:0],func_sll};\n\t\t\tcmd_srl : cmd_do <= {5'b0,5'b00001,5'b00011,data_now[3][4:0],func_srl};\n\t\t\tcmd_sra : cmd_do <= {5'b0,5'b00001,5'b00011,data_now[3][4:0],func_sra};\n\t\t\tdefault : cmd_do <= 26'b0;\n\t\tendcase\n\t\n\tend\n\n\t//State machine\n\talways @(posedge clk or negedge rst_n) begin\n\t\tif(~rst_n) st <= st_reset;\n\t\telse begin\n\t\t\tcase (st)\n\t\t\t\tst_idle : begin \n\t\t\t\t\tcase ({run,load})\n\t\t\t\t\t\t//2'b1x : st <= st_wrom;\n\t\t\t\t\t\t2'b10 : st <= st_wrom;\n\t\t\t\t\t\t2'b11 : st <= st_wrom;\n\t\t\t\t\t\t2'b01 : st <= st_load;\n\t\t\t\t\t\tdefault : st <= st;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\tst_wrom : st <= st_run;\n\t\t\t\tst_run : st <= run ? st : st_idle;\n\t\t\t\tst_reset : st <= st_idle;\n\t\t\t\tst_load : st <= st_idle;\n\t\t\t\tdefault : st <= st_reset;\n\t\t\tendcase\n\t\tend\n\tend\n\n\t//Work\n\talways @(posedge clk) begin\n\t\tcase (st)\n\t\t\tst_reset : begin\n\t\t\t\tr_clrn <= 1'b0;\n\t\t\t\tfor(i=0;i<4;i=i+1)\n\t\t\t\t\tdata_now[i] <= 8'b0;\n\t\t\tend\n\t\t\tst_load : data_now[select] <= data;\n\t\t\tst_wrom : begin \n\t\t\t\t//Clear all regs, set pc to 0;\n\t\t\t\tr_clrn <= 1'b0;\n\t\t\t\t//r1 = r0(0) + a;\n\t\t\t\tinst_rom[0] <= {6'b001000,5'b00000,5'b00001,data_now[0],data_now[1]};\n\t\t\t\t//r2 = r0(0) + b;\n\t\t\t\tinst_rom[1] <= {6'b001000,5'b00000,5'b00010,data_now[2],data_now[3]};\n\t\t\t\t//r3 = r1 (cmd) r2;\n\t\t\t\tinst_rom[2] <= {6'b0,cmd_do};\n\t\t\t\t//loop(j 26'd4)\n\t\t\t\tinst_rom[3] <= {6'b000010,26'd3};\n\t\t\tend\n\t\t\tst_run : r_clrn <= 1'b1;\n\t\t\tdefault : ;\n\t\tendcase\n\tend\n\nendmodule",
        "module_name": "KEY2INST",
        "module_hash": "fbdac6adf7c2b77aadd3a18d2ba41aa6",
        "dataset_index": 7017
      },
      "mux2to1_52fd3468": {
        "rtl_code": "module mux2to1(\n    input A, B, sel, reset, clk,\n    output reg out\n);\n\nalways @(posedge clk, negedge reset) begin\n    if(!reset) begin\n        out <= 0;\n    end else begin\n        if(sel == 0) begin\n            out <= A;\n        end else begin\n            out <= B;\n        end\n    end\nend\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "52fd34685cdf9c2ab8f8c4ac114c8fc8",
        "dataset_index": 17841
      },
      "qmem_decoder #_d6b5da09": {
        "rtl_code": "\n\nmodule qmem_decoder #(\n  parameter QAW = 32,     parameter QDW = 32,     parameter QSW = QDW/8,  parameter SN  = 2       )(\n  input  wire              clk,\n  input  wire              rst,\n  input  wire              qm_cs,\n  input  wire              qm_we,\n  input  wire    [QAW-1:0] qm_adr,\n  input  wire    [QSW-1:0] qm_sel,\n  input  wire    [QDW-1:0] qm_dat_w,\n  output wire    [QDW-1:0] qm_dat_r,\n  output wire              qm_ack,\n  output wire              qm_err,\n  output wire [SN    -1:0] qs_cs,\n  output wire [SN    -1:0] qs_we,\n  output wire [SN*QAW-1:0] qs_adr,\n  output wire [SN*QSW-1:0] qs_sel,\n  output wire [SN*QDW-1:0] qs_dat_w,\n  input  wire [SN*QDW-1:0] qs_dat_r,\n  input  wire [SN    -1:0] qs_ack,\n  input  wire [SN    -1:0] qs_err,\n  input  wire [SN    -1:0] ss\n);\n\n\nwire [7:0] ss_a;\nreg  [7:0] ss_r;\n\ngenerate if (SN == 1) assign ss_a =                                                         0; endgenerate\ngenerate if (SN == 2) assign ss_a =                                                 ss[1]?1:0; endgenerate\ngenerate if (SN == 3) assign ss_a =                                         ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 4) assign ss_a =                                 ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 5) assign ss_a =                         ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 6) assign ss_a =                 ss[5]?5:ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 7) assign ss_a =         ss[6]?6:ss[5]?5:ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 8) assign ss_a = ss[7]?7:ss[6]?6:ss[5]?5:ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\n\nalways @ (posedge clk)\nif (qm_cs & (qm_ack | qm_err) & ~qm_we)  ss_r <= #1 ss_a;\n\ngenvar i;\n\ngenerate for (i=0; i<SN; i=i+1) begin : loop_select\n  assign qs_cs    [     i                   ] = qm_cs & ss [i];\n  assign qs_we    [     i                   ] = qm_we;\n  assign qs_adr   [QAW*(i+1)-1:QAW*(i+1)-QAW] = qm_adr;\n  assign qs_sel   [QSW*(i+1)-1:QSW*(i+1)-QSW] = qm_sel;\n  assign qs_dat_w [QDW*(i+1)-1:QDW*(i+1)-QDW] = qm_dat_w;\nend endgenerate\n\nassign qm_dat_r = qs_dat_r >> (QDW*ss_r);\nassign qm_ack   = qs_ack   >>      ss_a ;\nassign qm_err   = qs_err   >>      ss_a ;\n\n\nendmodule\n\n",
        "module_name": "qmem_decoder #",
        "module_hash": "d6b5da09c4f38b5c206fd8c30cae0ba2",
        "dataset_index": 24906
      },
      "simple_calculator_723cd7a6": {
        "rtl_code": "module simple_calculator(input [7:0] a, b, input [3:0] control, output reg [7:0] result);\n\nalways @(*) begin\n    case(control)\n        4'b0000: result = a + b;\n        4'b0001: result = a - b;\n        4'b0010: result = a * b;\n        4'b0011: result = a / b;\n        default: result = 8'b00000000;\n    endcase\nend\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "723cd7a6a95451e23fdbd6d9e1766dbb",
        "dataset_index": 1874
      },
      "MUX_30521fe1": {
        "rtl_code": "module MUX (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input sel0,\n  input sel1,\n  output out\n);\n\n  // Selection logic\n  wire sel_00 = ~(sel0 | sel1);\n  wire sel_01 = ~sel0 & sel1;\n  wire sel_10 = sel0 & ~sel1;\n  wire sel_11 = sel0 & sel1;\n\n  // Output selection\n  assign out = sel_00 ? in0 : sel_01 ? in1 : sel_10 ? in2 : in3;\n\nendmodule",
        "module_name": "MUX",
        "module_hash": "30521fe10274b7503ad6b17e9f879c47",
        "dataset_index": 17188
      },
      "synth_arb_b126110b": {
        "rtl_code": "module synth_arb (\n  clk,\n  reset_n, \n  memadrs, \n  memdata, \n  wreq, \n  synth_ctrl,\n  synth_data,\n  fifo_full);\n  \n  input   wire        clk, reset_n, wreq, fifo_full;\n  input   wire  [7:0] memadrs, memdata;\n  output  reg   [7:0] synth_ctrl, synth_data;\n  \n  reg   [7:0] state_reg;\n  reg   [3:0] wait_cnt;\n  reg         wreq_inter, w_done;\n          \n  always @(posedge wreq, posedge w_done, negedge reset_n)\n  begin\n    if(reset_n == 0) wreq_inter <= 0;\n    else if(w_done == 1) wreq_inter <= 0;\n    else if(wreq == 1 && w_done != 1) wreq_inter <= 1;\n  end\n          \n  always @(posedge clk, negedge reset_n)\n  begin\n    if(!reset_n)\n    begin\n      state_reg <= 0;\n      synth_ctrl <= 0;\n      synth_data <= 0;\n      wait_cnt <= 0;\n      w_done <= 0;\n    end\n    else\n    begin\n      case(state_reg)\n        8'D0    : state_reg <= state_reg + 1;\n                                                                          //recovery reset while 16count\n        8'D1    : begin\n                    if(wait_cnt != 4'b1111) wait_cnt <= wait_cnt + 1;\n                    else  state_reg <= state_reg + 1;\n                  end\n                                                                          //step phase, operator 1\n        8'D2    : begin\n                    state_reg <= state_reg + 1;\n                    synth_ctrl <= 8'b00000001;\n                  end\n                                                                          //fifo full check, operator stall\n        8'D3    : begin\n                    synth_ctrl <= 8'b00000000;\n                    if(fifo_full != 1) state_reg <= state_reg + 1;\n                    else state_reg <= state_reg; \n                  end\n                                                                          //write req to fifo, operator 1\n        8'D4    : begin\n                    state_reg <= state_reg + 1;\n                    synth_ctrl <= 8'b10000001;\n                  end\n                                                                          //write wait\n        8'D5    : begin\n                    state_reg <= state_reg + 1;\n                    synth_ctrl <= 8'b00000000;\n                  end\n                                                                          //jump to state 2 if write strobe is not active\n        8'D6    : begin\n                    if(wreq_inter == 1) state_reg <= state_reg + 1;\n                    else state_reg <= 2;\n                  end\n                                                                          //get recieve data and command, write data\n        8'D7    : begin\n                    synth_data <= memdata;\n                    synth_ctrl <= d2ctrl_synth(memadrs);\n                    state_reg <= state_reg + 1;\n                    w_done <= 1;\n                  end\n                                                                          //finishing write data\n        8'D8    : begin\n                    state_reg <= 2;\n                    synth_ctrl <= 8'b00000000;\n                    w_done <= 0;\n                  end\n                 \n        default : state_reg <= 0;     \n      endcase\n    end\n  end\n  \n  function  [7:0] d2ctrl_synth;\n    input [7:0] adrs;\n    begin\n      casex(adrs)\n        8'b00000001 : d2ctrl_synth = 8'b01000001;                 \n        8'b00010001 : d2ctrl_synth = 8'b00010001;\n        8'b00100001 : d2ctrl_synth = 8'b01010001;\n        8'b1000xxxx : d2ctrl_synth = 8'b00100000;\n        default     : d2ctrl_synth = 0;\n      endcase\n    end\n  endfunction\n  \nendmodule",
        "module_name": "synth_arb",
        "module_hash": "b126110ba46846ff4a60bd46a45b8226",
        "dataset_index": 3119
      },
      "rotator_98b1b1ba": {
        "rtl_code": "\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nreg [99:0] stage1_data;\nreg [99:0] stage2_data;\nreg [99:0] stage3_data;\n\nalways @(posedge clk) begin\n    if(load) begin\n        stage1_data <= data;\n        stage2_data <= stage1_data;\n        stage3_data <= stage2_data;\n    end else if(ena == 2'b01) begin // left rotation\n        stage1_data <= {stage1_data[98:0], stage1_data[99]};\n        stage2_data <= {stage2_data[97:0], stage2_data[99:98]};\n        stage3_data <= {stage3_data[96:0], stage3_data[99:97]};\n    end else if(ena == 2'b10) begin // right rotation\n        stage1_data <= {stage1_data[1:99], stage1_data[0]};\n        stage2_data <= {stage2_data[2:99], stage2_data[1:0]};\n        stage3_data <= {stage3_data[3:99], stage3_data[2:0]};\n    end\nend\n\nassign q = ena == 2'b00 ? data : ena == 2'b01 ? stage1_data : ena == 2'b10 ? stage2_data : stage3_data;\n\nendmodule\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nrotator rotator_inst(\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(q)\n);\n\nendmodule",
        "module_name": "rotator",
        "module_hash": "98b1b1ba36e5e34c288e971f7c9717c6",
        "dataset_index": 6513
      },
      "bcd_to_binary_ae9babea": {
        "rtl_code": "module bcd_to_binary (\n  input [3:0] bcd0,\n  input [3:0] bcd1,\n  input [3:0] bcd2,\n  input [3:0] bcd3,\n  output reg [3:0] bin\n);\n\n  always @* begin\n    bin = (bcd3 * 1000) + (bcd2 * 100) + (bcd1 * 10) + bcd0;\n  end\n\nendmodule",
        "module_name": "bcd_to_binary",
        "module_hash": "ae9babea7230da6d4ed000381fa741d1",
        "dataset_index": 13406
      },
      "blockram_spool_602e2c65": {
        "rtl_code": "\n\n\nmodule blockram_spool (\n\tinput wire clk_i,\n\tinput wire areset_i,\n\toutput reg [15:0] address_o,\n\toutput reg [7:0]\tdata_o,\n\tinput wire [7:0]\tq_i,\n\toutput reg\t\t\twren_o,\n\tinput wire [3:0]\tA_i,\n\tinput wire [7:0]\tD_i,\n\toutput reg [7:0]\tD_o,\n\tinput wire \t\t\trd_i,\n\tinput wire\t\t\twr_i\n\t);\n\n\tparameter \tIDLE = 4'd0, \n\t\t\t\t\tPRE_READ = 4'd1, READ_READY = 4'd2, READ_CAPTURE = 4'd4, WAIT_READ = 4'd5,\n\t\t\t\t\tWRITE_WAIT = 4'd6, WRITE_NEXT = 4'd7;\n\t\n\twire rd_sig, wr_sig, abort_sig;\n\twire read_trigger, write_trigger;\n\t\n\treg [15:0] A;\n\treg cpu_rd, cpu_wr, fsm_rd, fsm_wr, cpu_abort, fsm_abort;\n\treg [3:0] state;\n\treg [7:0] rd_buffer;\n\t\n\tassign rd_sig = (cpu_rd != fsm_rd);\n\tassign wr_sig = (cpu_wr != fsm_wr);\n\tassign abort_sig = (cpu_abort != fsm_abort);\n\tassign read_trigger = (A_i == 4'd8) && rd_i;\n\tassign write_trigger = (A_i == 4'd8) && wr_i;\n\t\n\talways @(posedge clk_i or posedge areset_i)\n\tif( areset_i )\n\tbegin\n\t\tD_o <= 8'd0;\n\t\tcpu_rd <= 1'b0;\n\t\tcpu_wr <= 1'b0;\n\t\tcpu_abort <= 1'b0;\n\tend else if( rd_i | wr_i ) begin\t\tcase(A_i)\n\t\t\t4'd0:\tbegin\n\t\t\t\tif( wr_i ) A[7:0] <= D_i; else D_o <= A[7:0];\n\t\t\tend\n\t\t\t4'd1:\tbegin\n\t\t\t\tif( wr_i ) A[15:8] <= D_i; else D_o <= A[15:8];\n\t\t\tend\n\t\t\t4'd8: begin\n\t\t\t\tif( rd_i ) D_o <= rd_buffer;\n\t\t\tend\n\t\t\t4'd15: begin\n\t\t\t\tif( wr_i ) begin\n\t\t\t\t\tif( D_i[0] ) if( ~rd_sig) cpu_rd <= ~cpu_rd;\n\t\t\t\t\tif( D_i[1] ) if( ~wr_sig) cpu_wr <= ~cpu_wr;\n\t\t\t\t\tif( D_i[7] ) if( ~abort_sig ) cpu_abort <= ~cpu_abort;\n\t\t\t\tend else begin\n\t\t\t\t\tD_o <= {8'b0};\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk_i or posedge areset_i)\n\tif( areset_i )\n\tbegin\n\t\tfsm_rd <= 1'b0;\n\t\tfsm_wr <= 1'b0;\n\t\tfsm_abort <= 1'b0;\n\t\taddress_o <= 16'd0;\n\t\tdata_o <= 8'd0;\n\t\twren_o <= 1'b0;\t\t\n\t\tstate <= IDLE;\n\tend else begin\n\t\tcase( state )\n\t\t\tIDLE: begin\n\t\t\t\taddress_o <= A;\n\t\t\t\tif( rd_sig )\n\t\t\t\tbegin\n\t\t\t\t\tfsm_rd <= ~fsm_rd;\n\t\t\t\t\tstate <= PRE_READ;\n\t\t\t\tend else if( wr_sig )\n\t\t\t\tbegin\n\t\t\t\t\tdata_o <= D_i;\t\t\tfsm_wr <= ~fsm_wr;\n\t\t\t\t\tstate <= WRITE_WAIT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tPRE_READ: begin\n\t\t\t\tstate <= READ_READY;\n\t\t\tend\n\t\t\tREAD_READY: begin\n\t\t\t\taddress_o <= address_o + 1'b1;\n\t\t\t\tstate <= READ_CAPTURE;\n\t\t\tend\n\t\t\tREAD_CAPTURE: begin\n\t\t\t\trd_buffer <= q_i;\n\t\t\t\tstate <= WAIT_READ;\n\t\t\tend\n\t\t\tWAIT_READ: begin\n\t\t\t\tif( abort_sig ) \n\t\t\t\tbegin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tfsm_abort <= ~fsm_abort;\n\t\t\t\tend else\n\t\t\t\tif( (A_i == 4'd8) && rd_i ) state <= READ_READY;\n\t\t\tend\n\t\t\tWRITE_WAIT: begin\n\t\t\t\tif( abort_sig )\n\t\t\t\tbegin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tfsm_abort <= ~fsm_abort;\n\t\t\t\tend else\n\t\t\t\tif( write_trigger ) begin\n\t\t\t\t\twren_o <= 1'b1;\n\t\t\t\t\tstate <= WRITE_NEXT;\n\t\t\t\tend\n\t\t\t\tdata_o <= D_i;\n\t\t\tend\n\t\t\tWRITE_NEXT: begin\n\t\t\t\taddress_o <= address_o + 1'b1;\n\t\t\t\twren_o <= 1'b0;\n\t\t\t\tstate <= WRITE_WAIT;\n\t\t\tend\n\t\tendcase\n\t\t\n\tend\nendmodule\n",
        "module_name": "blockram_spool",
        "module_hash": "602e2c65be3401b80b4f333aeb9ea68c",
        "dataset_index": 15909
      },
      "ripple_adder_189ce555": {
        "rtl_code": "\nmodule ripple_adder(\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\n    wire [15:0] a_lo = a[15:0];\n    wire [15:0] a_hi = a[31:16];\n    wire [15:0] b_lo = b[15:0];\n    wire [15:0] b_hi = b[31:16];\n    wire [15:0] sum_lo;\n    wire [15:0] sum_hi;\n    wire cout;\n\n    // First 16-bit adder\n    ripple_adder adder_lo(\n        .a(a_lo),\n        .b(sub ? ~b_lo : b_lo),\n        .cin(sub),\n        .sum(sum_lo),\n        .cout(cout)\n    );\n\n    // Second 16-bit adder\n    ripple_adder adder_hi(\n        .a(a_hi),\n        .b(sub ? ~b_hi : b_hi),\n        .cin(cout),\n        .sum(sum_hi),\n        .cout()\n    );\n\n    // 32-bit XOR gate\n    assign sum = {sum_hi, sum_lo} ^ (sub ? -1 : 0);\n\nendmodule",
        "module_name": "ripple_adder",
        "module_hash": "189ce555f4ab3a71db026587c6b1fba6",
        "dataset_index": 244
      },
      "Timer_876954c0": {
        "rtl_code": "\nmodule Timer(\n\t\toutput reg [3:0]ten,\n\t\toutput reg [3:0]one,\n\t\toutput isFinished,\n\t\tinput clk,\n\t\tinput rst_n\n    );\n\n\treg [3:0] next_ten, next_one;\n\talways @(posedge clk or negedge rst_n) begin\n\t\tif (!rst_n) begin\n\t\t\tten <= 4'd3;\n\t\t\tone <= 4'd0;\n\t\tend else begin\n\t\t\tten <= next_ten;\n\t\t\tone <= next_one;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tif (ten == 4'd0 && one == 4'd0) begin\n\t\t\tnext_ten = 4'd0;\n\t\t\tnext_one = 4'd0;\n\t\tend else begin\n\t\t\tif (one == 4'd0) begin\n\t\t\t\tnext_ten = ten - 4'd1;\n\t\t\t\tnext_one = 4'd9;\n\t\t\tend else begin\n\t\t\t\tnext_ten = ten;\n\t\t\t\tnext_one = one - 4'd1;\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign isFinished = (ten == 4'd0 && one == 4'd0)?1:0;\nendmodule\n",
        "module_name": "Timer",
        "module_hash": "876954c0307f08268cfc2a443ba4ea2d",
        "dataset_index": 23443
      },
      "flip_flop_c0808892": {
        "rtl_code": "module flip_flop (\n    input CLK,\n    input D,\n    input SET_B,\n    input CLR_B,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK) begin\n        if (SET_B == 1'b0) begin\n            Q <= 1'b1;\n            Q_N <= 1'b0;\n        end else if (CLR_B == 1'b0) begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule",
        "module_name": "flip_flop",
        "module_hash": "c080889210c711c13815419e8e9c0a20",
        "dataset_index": 18864
      },
      "ecc_dec_fix_b7b23d66": {
        "rtl_code": "\n\nmodule ecc_dec_fix\n  #(\n    parameter TCQ = 100,\n    parameter PAYLOAD_WIDTH      = 64,\n    parameter CODE_WIDTH         = 72,\n    parameter DATA_WIDTH         = 64,\n    parameter DQ_WIDTH           = 72,\n    parameter ECC_WIDTH          = 8,\n    parameter nCK_PER_CLK         = 4\n   )\n   (\n    \n  rd_data, ecc_single, ecc_multiple,\n  clk, rst, h_rows, phy_rddata, correct_en, ecc_status_valid\n  );\n\n  input clk;\n  input rst;\n\n  input [CODE_WIDTH*ECC_WIDTH-1:0] h_rows;\n  input [2*nCK_PER_CLK*DQ_WIDTH-1:0] phy_rddata;\n  wire [2*nCK_PER_CLK*ECC_WIDTH-1:0] syndrome_ns;\n  genvar k;\n  genvar m;\n  generate\n    for (k=0; k<2*nCK_PER_CLK; k=k+1) begin : ecc_word\n      for (m=0; m<ECC_WIDTH; m=m+1) begin : ecc_bit\n        assign syndrome_ns[k*ECC_WIDTH+m] =\n   ^(phy_rddata[k*DQ_WIDTH+:CODE_WIDTH] & h_rows[m*CODE_WIDTH+:CODE_WIDTH]);\n      end\n    end\n  endgenerate\n  reg [2*nCK_PER_CLK*ECC_WIDTH-1:0] syndrome_r;\n  always @(posedge clk) syndrome_r <= #TCQ syndrome_ns;\n\n  wire [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] ecc_rddata_ns;\n  genvar i;\n  generate\n    for (i=0; i<2*nCK_PER_CLK; i=i+1) begin : extract_payload\n      assign ecc_rddata_ns[i*PAYLOAD_WIDTH+:PAYLOAD_WIDTH] =\n               phy_rddata[i*DQ_WIDTH+:PAYLOAD_WIDTH];\n    end\n  endgenerate\n  reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] ecc_rddata_r;\n  always @(posedge clk) ecc_rddata_r <= #TCQ ecc_rddata_ns;\n\n  genvar n;\n  genvar p;\n  wire [ECC_WIDTH-1:0] h_matrix [DATA_WIDTH-1:0];\n  generate\n    for (n=0; n<DATA_WIDTH; n=n+1) begin : h_col\n      for (p=0; p<ECC_WIDTH; p=p+1) begin : h_bit\n        assign h_matrix [n][p] = h_rows [p*CODE_WIDTH+n];\n      end\n    end\n  endgenerate             \n      \n  wire [2*nCK_PER_CLK*DATA_WIDTH-1:0] flip_bits;\n  genvar q;\n  genvar r;\n  generate\n    for (q=0; q<2*nCK_PER_CLK; q=q+1) begin : flip_word\n      for (r=0; r<DATA_WIDTH; r=r+1) begin : flip_bit\n        assign flip_bits[q*DATA_WIDTH+r] = \n          h_matrix[r] == syndrome_r[q*ECC_WIDTH+:ECC_WIDTH];\n      end\n    end\n  endgenerate\n\n  output reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] rd_data;\n  input correct_en;\n  integer s;\n  always @(correct_en or ecc_rddata_r or flip_bits)\n    for (s=0; s<2*nCK_PER_CLK; s=s+1)\n      if (correct_en)\n        rd_data[s*PAYLOAD_WIDTH+:DATA_WIDTH] = \n          ecc_rddata_r[s*PAYLOAD_WIDTH+:DATA_WIDTH] ^ \n              flip_bits[s*DATA_WIDTH+:DATA_WIDTH];\n      else rd_data[s*PAYLOAD_WIDTH+:DATA_WIDTH] = \n           ecc_rddata_r[s*PAYLOAD_WIDTH+:DATA_WIDTH];\n\n  localparam RAW_BIT_WIDTH = PAYLOAD_WIDTH - DATA_WIDTH;\n  genvar t;\n  generate\n    if (RAW_BIT_WIDTH > 0)\n      for (t=0; t<2*nCK_PER_CLK; t=t+1) begin : copy_raw_bits\n        always @(ecc_rddata_r)\n          rd_data[(t+1)*PAYLOAD_WIDTH-1-:RAW_BIT_WIDTH] =\n            ecc_rddata_r[(t+1)*PAYLOAD_WIDTH-1-:RAW_BIT_WIDTH];\n      end\n  endgenerate\n\n  input ecc_status_valid;\n  output wire [2*nCK_PER_CLK-1:0] ecc_single;\n  output wire [2*nCK_PER_CLK-1:0] ecc_multiple;\n  genvar v;\n  generate\n    for (v=0; v<2*nCK_PER_CLK; v=v+1) begin : compute_status\n      wire zero = ~|syndrome_r[v*ECC_WIDTH+:ECC_WIDTH];\n      wire odd = ^syndrome_r[v*ECC_WIDTH+:ECC_WIDTH];\n      assign ecc_single[v] = ecc_status_valid && ~zero && odd;\n      assign ecc_multiple[v] = ecc_status_valid && ~zero && ~odd;\n    end\n  endgenerate\n\nendmodule\n\n",
        "module_name": "ecc_dec_fix",
        "module_hash": "b7b23d6612ed31b5215cf8e8c1095ae5",
        "dataset_index": 24062
      },
      "flt_fx_24p8_5589b308": {
        "rtl_code": "\n\nmodule flt_fx_24p8\n\t(\n\tinput\t[31:0]\tfp_in,         output reg [31:0] int_out      );\nwire    [7:0]   bias_exp;       \nwire    [7:0]   bias_exp2;      \nwire    [39:0]  fixed_out2;     \nwire    [47:0]  bias_mant;      \nreg     [47:0]  int_fixed_out;\n\nreg    [31:0]  fixed_out;\n\nassign bias_mant = {25'h0001, fp_in[22:0]};\nassign bias_exp = fp_in[30:23] - 8'd127;\nassign bias_exp2 = ~bias_exp + 8'h1;\n\nalways @* begin\n\tif (fp_in[30:0] == 31'b0) int_fixed_out = 0;\n  \telse if (bias_exp[7]) int_fixed_out = bias_mant >> bias_exp2;\n  \telse int_fixed_out = bias_mant << bias_exp;\n\n\tfixed_out = int_fixed_out[46:15];\n\tint_out = (fp_in[31]) ? ~fixed_out + 1 : fixed_out;\nend\n\nendmodule\n\n\n\n",
        "module_name": "flt_fx_24p8",
        "module_hash": "5589b3085897e5ce1f9c68874abdd40a",
        "dataset_index": 17467
      },
      "final_output_b1be6538": {
        "rtl_code": "\nmodule final_output (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [7:0] anyedge,\n  output [7:0] count,\n  output [7:0] result\n);\n\n  // Shift register to detect bit transitions\n  reg [7:0] sr;\n  always @(posedge clk) begin\n    if (reset) begin\n      sr <= 8'b0;\n    end else begin\n      sr <= {in, sr[7:1]};\n    end\n  end\n  assign anyedge = in ^ sr;\n\n  // Population count circuit\n  function integer popcount;\n    input [7:0] data;\n    integer i;\n    begin\n      popcount = 0;\n      for (i = 0; i < 8; i = i + 1) begin\n        if (data[i]) begin\n          popcount = popcount + 1;\n        end\n      end\n    end\n  endfunction\n\n  // Final output generation\n  assign count = popcount(in);\n  assign result = count + {anyedge[0], anyedge[7:1]};\n\nendmodule",
        "module_name": "final_output",
        "module_hash": "b1be6538864f35abcab25e762f48e94a",
        "dataset_index": 14972
      },
      "conmutacion_1c8958b7": {
        "rtl_code": "module conmutacion\t(\n\t\t\t\tinput\t\t[3:0]\tcentenas,\n\t\t\t\tinput\t\t[3:0]\tdecenas,\n\t\t\t\tinput\t\t[3:0]\tunidades,\n\t\t\t\tinput\t\t\tC,\n\t\t\t\tinput\t\t\tDe,\n\t\t\t\tinput\t\t\tU,\n\t\t\t\tinput\t\t\tCLKOUTseg,\n\t\t\t\toutput\treg\t[1:0]\tmostrar,\n\t\t\t\toutput\treg\t[3:0]\tdigito\n\t\t\t);\n\n\n\treg\t\tlogic0;\n\treg\t[1:0]\ttitileo;\n\tinitial\n\tbegin\n\t\ttitileo = 0;\n\tend\n\talways@(posedge CLKOUTseg)\n\tbegin\n\t\tif(C && De && U)\n\t\tbegin\n\t\t\t\n\t\t\ttitileo\t<= titileo + 1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(De && U)\n\t\t\tbegin\n\t\t\t\t\n\t\t\t\ttitileo\t<= titileo + 1;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(U)\n\t\t\t\tbegin\n\t\t\t\t\ttitileo\t<= 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\ttitileo <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\talways@(posedge CLKOUTseg)\n\tbegin\n\t\t\tcase(titileo)\n\t\t\t\t2'b00:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b01;\n\t\t\t\t\tdigito\t= 0;\n\t\t\t\tend\n\t\t\t\t2'b01:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b01;\n\t\t\t\t\tdigito\t= unidades;\n\t\t\t\tend\n\t\t\t\t2'b10:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b10;\n\t\t\t\t\tdigito\t= decenas; \n\t\t\t\tend\n\t\t\t\t2'b11:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b11;\n\t\t\t\t\tdigito\t= centenas;\n\t\t\t\tend\n\t\t\tendcase\t\n\tend\n\n\nendmodule\n",
        "module_name": "conmutacion",
        "module_hash": "1c8958b768ad93b439c66b6028269998",
        "dataset_index": 23660
      },
      "xlslice_2d176f5a": {
        "rtl_code": "module xlslice (\n  input wire [23:0] Din,\n  output wire [8:0] Dout\n);\n\n  wire [15:0] sliced_signal;\n  wire [15:0] inverted_signal;\n  wire [8:0] shifted_signal;\n\n  assign sliced_signal = Din[22:7];\n  assign inverted_signal = ~sliced_signal;\n  assign shifted_signal = inverted_signal >> 8;\n\n  assign Dout = shifted_signal;\n\nendmodule",
        "module_name": "xlslice",
        "module_hash": "2d176f5a78a4af51db7240ea4364b896",
        "dataset_index": 1303
      },
      "sleep_control_a75c9fbf": {
        "rtl_code": "module sleep_control (\n    output reg MBC_ISOLATE,\n    output MBC_ISOLATE_B,\n    output reg MBC_RESET,\n    output MBC_RESET_B,\n    output MBC_SLEEP,\n    output MBC_SLEEP_B,\n    output SYSTEM_ACTIVE,\n    output WAKEUP_REQ_ORED,\n    input CLK,\n    input MBUS_DIN,\n    input RESETn,\n    input SLEEP_REQ,\n    input WAKEUP_REQ0,\n    input WAKEUP_REQ1,\n    input WAKEUP_REQ2\n);\n\n    reg set_tran_to_wake;\n    reg rst_tran_to_wake;\n    reg MBC_SLEEP_int;\n    reg tran_to_wake;\n    wire tran_to_wake_r;\n\n    assign MBC_ISOLATE_B = ~MBC_ISOLATE;\n    assign MBC_RESET_B = ~MBC_RESET;\n    assign MBC_SLEEP_B = ~MBC_SLEEP;\n    assign SYSTEM_ACTIVE = MBC_SLEEP_B | MBC_ISOLATE_B;\n    assign WAKEUP_REQ_ORED = WAKEUP_REQ0 | WAKEUP_REQ1 | WAKEUP_REQ2;\n\n    always @* begin\n        if (RESETn & (WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN))) begin\n            set_tran_to_wake = 1'b1;\n        end else begin\n            set_tran_to_wake = 1'b0;\n        end\n    end\n\n    always @* begin\n        if ((~RESETn) | (WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN) | ~SLEEP_REQ)) begin\n            rst_tran_to_wake <= 1'b1;\n        end else begin\n            rst_tran_to_wake <= 1'b0;\n        end\n    end\n\n    always @ (negedge tran_to_wake_r or posedge set_tran_to_wake) begin\n        if (~tran_to_wake_r) begin\n            tran_to_wake <= 1'b0;\n        end else begin\n            tran_to_wake <= 1'b1;\n        end\n    end\n\n    assign tran_to_wake_r = RESETn & rst_tran_to_wake;\n\n    always @ (negedge RESETn or posedge CLK) begin\n        if (~RESETn) begin\n            MBC_ISOLATE <= 1'b1;\n        end else begin\n            MBC_ISOLATE <= (MBC_SLEEP_int | (~tran_to_wake));\n        end\n    end\n\n    always @ (negedge RESETn or posedge CLK) begin\n        if (~RESETn) begin\n            MBC_SLEEP_int <= 1'b1;\n        end else begin\n            MBC_SLEEP_int <= (MBC_ISOLATE & (~tran_to_wake));\n        end\n    end\n\n    assign MBC_SLEEP = MBC_SLEEP_int & ~(WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN));\n\n    always @ (negedge RESETn or posedge CLK) begin\n        if (~RESETn) begin\n            MBC_RESET <= 1'b1;\n        end else begin\n            MBC_RESET <= MBC_ISOLATE;\n        end\n    end\n\nendmodule",
        "module_name": "sleep_control",
        "module_hash": "a75c9fbfe01f311f9d23f5d73d147803",
        "dataset_index": 14100
      },
      "Multiplexer_140d7c52": {
        "rtl_code": "module Multiplexer (\n  input ctrl,\n  input D0,\n  input D1,\n  output S\n);\n\n  assign S = ctrl ? D1 : D0;\n\nendmodule",
        "module_name": "Multiplexer",
        "module_hash": "140d7c5276a1cb4389a676575f284445",
        "dataset_index": 3652
      },
      "bitwise_operation_42a7d101": {
        "rtl_code": "\nmodule bitwise_operation(\n    input [7:0] a_in,\n    input [7:0] b_in,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out[7:2] = a_in[7:2];\n        out[1] = ~(a_in[1] ^ b_in[1]);\n        out[0] = a_in[0] ^ b_in[0];\n    end\n\nendmodule\n",
        "module_name": "bitwise_operation",
        "module_hash": "42a7d10147df7abfb7bd0273fea1a799",
        "dataset_index": 19497
      },
      "agnus_audiodma_f338faa9": {
        "rtl_code": "module agnus_audiodma\n(\n  input  wire           clk,              input  wire           clk7_en,          output wire           dma,              input  wire [  4-1:0] audio_dmal,       input  wire [  4-1:0] audio_dmas,       input  wire [  9-1:0] hpos,             input  wire [  9-1:1] reg_address_in,   output reg  [  9-1:1] reg_address_out,  input  wire [ 16-1:0] data_in,          output wire [ 21-1:1] address_out       );\n\n\nparameter AUD0DAT_REG = 9'h0AA;\nparameter AUD1DAT_REG = 9'h0BA;\nparameter AUD2DAT_REG = 9'h0CA;\nparameter AUD3DAT_REG = 9'h0DA;\n\nwire          audlcena;     wire [  1: 0] audlcsel;     reg  [ 20:16] audlch [3:0]; reg  [ 15: 1] audlcl [3:0]; wire [ 20: 1] audlcout;     reg  [ 20: 1] audpt [3:0];  wire [ 20: 1] audptout;     reg  [  1: 0] channel;      reg           dmal;\nreg           dmas;\n\nassign audlcena = ~reg_address_in[8] & reg_address_in[7] & (reg_address_in[6]^reg_address_in[5]) & ~reg_address_in[3] & ~reg_address_in[2];\n\nassign audlcsel = {~reg_address_in[5],reg_address_in[4]};\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (audlcena & ~reg_address_in[1]) audlch[audlcsel] <= #1 data_in[4:0];\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (audlcena & reg_address_in[1]) audlcl[audlcsel] <= #1 data_in[15:1];\n  end\nend\n\nassign audlcout = {audlch[channel],audlcl[channel]};\n\nalways @ (*) begin\n  case (hpos)\n    9'b0001_0010_1 : dmal = audio_dmal[0]; 9'b0001_0100_1 : dmal = audio_dmal[1]; 9'b0001_0110_1 : dmal = audio_dmal[2]; 9'b0001_1000_1 : dmal = audio_dmal[3]; default        : dmal = 0;\n  endcase\nend\n\nassign dma = dmal;\n\nalways @ (*) begin\n  case (hpos)\n    9'b0001_0010_1 : dmas = audio_dmas[0]; 9'b0001_0100_1 : dmas = audio_dmas[1]; 9'b0001_0110_1 : dmas = audio_dmas[2]; 9'b0001_1000_1 : dmas = audio_dmas[3]; default        : dmas = 0;\n  endcase\nend\n\nalways @ (*) begin\n  case (hpos[3:2])\n    2'b01 : channel = 0; 2'b10 : channel = 1; 2'b11 : channel = 2; 2'b00 : channel = 3; endcase\nend\n\nassign address_out[20:1] = audptout[20:1];\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (dmal)\n      audpt[channel] <= #1 dmas ? audlcout[20:1] : audptout[20:1] + 1'b1;\n  end\nend\n\nassign audptout[20:1] = audpt[channel];\n\nalways @ (*) begin\n  case (channel)\n    0 : reg_address_out[8:1] = AUD0DAT_REG[8:1];\n    1 : reg_address_out[8:1] = AUD1DAT_REG[8:1];\n    2 : reg_address_out[8:1] = AUD2DAT_REG[8:1];\n    3 : reg_address_out[8:1] = AUD3DAT_REG[8:1];\n  endcase\nend\n\n\nendmodule\n\n",
        "module_name": "agnus_audiodma",
        "module_hash": "f338faa9827324c5fc64575295ded412",
        "dataset_index": 23653
      },
      "comparator_8116503c": {
        "rtl_code": "module comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if (a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end else if (a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "8116503cba15a7a21f4896e927b9d4c6",
        "dataset_index": 18167
      },
      "mult_16x16_0016276d": {
        "rtl_code": "\nmodule mult_16x16 (\n    input [15:0] Amult, // o\n    input [15:0] Bmult, // o\n    input [1:0] Valid_mult, // o\n    output [31:0] Cmult // i\n);\n\n    wire [31:0] Amult_int;\n    wire [31:0] Bmult_int;\n    wire [63:0] Cmult_int;\n\n    assign Amult_int = {16'b0, Amult};\n    assign Bmult_int = {16'b0, Bmult};\n\n    MULT #(.WIDTH(32)) mult_inst (\n        .Amult(Amult_int), // i\n        .Bmult(Bmult_int), // i\n        .Valid_mult(Valid_mult), // i\n        .Cmult(Cmult_int), // o\n        .sel_mul_32x32(1'b1) // i\n    );\n\n    assign Cmult = Cmult_int[31:0];\n\nendmodule\nmodule MULT #(\n    parameter WIDTH = 32\n) (\n    input [WIDTH-1:0] Amult, // i\n    input [WIDTH-1:0] Bmult, // i\n    input [1:0] Valid_mult, // i\n    output [2*WIDTH-1:0] Cmult, // o\n    input sel_mul_32x32 // i\n);\n\n    reg [2*WIDTH-1:0] Cmult_reg;\n    reg [WIDTH-1:0] Amult_reg;\n    reg [WIDTH-1:0] Bmult_reg;\n    reg [1:0] Valid_mult_reg;\n\n    always @(posedge Valid_mult[0]) begin\n        Amult_reg <= Amult;\n        Bmult_reg <= Bmult;\n        Valid_mult_reg <= Valid_mult;\n    end\n\n    always @(posedge Valid_mult[0]) begin\n        if (sel_mul_32x32) begin\n            Cmult_reg <= Amult_reg * Bmult_reg;\n        end else begin\n            Cmult_reg <= {WIDTH{1'b0}};\n        end\n    end\n\n    assign Cmult = Cmult_reg;\n\nendmodule",
        "module_name": "mult_16x16",
        "module_hash": "0016276d68c20ee716f0fa076899d490",
        "dataset_index": 18623
      },
      "top__2b07e306": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input shift_left, // Control input to shift register to the left\n    input shift_right,// Control input to shift register to the right\n    output [3:0] q    // 4-bit output from the functional module\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] shift_register_out;\n    wire [3:0] functional_out;\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .count(counter_out)\n    );\n\n    shift_register shift_register_inst (\n        .clk(clk),\n        .reset(reset),\n        .shift_left(shift_left),\n        .shift_right(shift_right),\n        .data_in(counter_out), // Updated to select 4 bits\n        .data_out(shift_register_out)\n    );\n\n    functional_module functional_inst (\n        .counter_in(counter_out),\n        .shift_register_in(shift_register_out),\n        .functional_out(functional_out)\n    );\n\n    assign q = functional_out;\n\nendmodule\nmodule counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin // Updated sensitivity list\n        if (reset) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 4'b0001; // Updated to add 4-bit value\n        end\n    end\nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input shift_left,\n    input shift_right,\n    input [3:0] data_in, // Updated input data width\n    output reg [3:0] data_out\n);\n    always @(posedge clk or posedge reset) begin // Updated sensitivity list\n        if (reset) begin\n            data_out <= 4'b0000;\n        end else begin\n            if (shift_left) begin\n                data_out <= {data_out[2:0], data_in[3]};\n            end else if (shift_right) begin\n                data_out <= {data_in[0], data_out[3:1]};\n            end\n        end\n    end\nendmodule\nmodule functional_module (\n    input [3:0] counter_in,\n    input [3:0] shift_register_in,\n    output reg [3:0] functional_out\n);\n    always @(*) begin\n        functional_out = (counter_in + shift_register_in) ^ 4'b1010;\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "2b07e306dc1301e7204a22c65c458c79",
        "dataset_index": 8196
      },
      "bitwise_module_518a5bf8": {
        "rtl_code": "module bitwise_module(\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output out\n);\n\nwire and1, and2, or1, xor1, or2;\n\nassign and1 = A1 & A2;\nassign and2 = A3 & B1;\nassign or1 = and1 | and2;\nassign xor1 = VPWR ^ VGND;\nassign or2 = VPB | VNB;\n\nassign out = or1 & xor1 & or2;\n\nendmodule",
        "module_name": "bitwise_module",
        "module_hash": "518a5bf86e9d65bf87c95b2797d680e8",
        "dataset_index": 15384
      },
      "counter_module_1a5c987c": {
        "rtl_code": "module counter_module(\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0000;\n    end else if (en) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter_module",
        "module_hash": "1a5c987cad800ea74cdef012957d6c7e",
        "dataset_index": 352
      },
      "top__0483a611": {
        "rtl_code": "\nmodule top_module (\n    input [3:0] in,\n    input [3:0] A,\n    input [3:0] B,\n    output [5:0] final_output\n); \n\nwire [1:0] priority_output;\nwire [3:0] ripple_sum;\nwire carry;\n\npriority_encoder pe(\n    .in(in),\n    .out(priority_output)\n);\n\nripple_carry_adder rca(\n    .A(A),\n    .B(B),\n    .SUM(ripple_sum),\n    .CARRY(carry)\n);\n\nfunctional_module fm(\n    .priority_output(priority_output),\n    .ripple_sum(ripple_sum),\n    .final_output(final_output)\n);\n\nendmodule\n\nmodule priority_encoder (\n    input [3:0] in,\n    output [1:0] out\n);\nassign out = (in == 4'b0001) ? 2'b00 :\n              (in == 4'b0010) ? 2'b01 :\n              (in == 4'b0100) ? 2'b10 :\n              (in == 4'b1000) ? 2'b11 : 2'b11;\nendmodule\n\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM,\n    output CARRY\n);\nassign {CARRY, SUM} = A + B;\nendmodule\n\nmodule functional_module (\n    input [1:0] priority_output,\n    input [3:0] ripple_sum,\n    output [5:0] final_output\n);\nassign final_output = {priority_output, ripple_sum};\nendmodule\n",
        "module_name": "top_",
        "module_hash": "0483a61104e11b98d1d81cded98f8de7",
        "dataset_index": 7722
      },
      "top__184cb18c": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input [11:0] in,\n    output [7:0] out\n);\n\n    // Split the 12-bit input into lower, middle, and upper bytes\n    wire [3:0] lower = in[3:0];\n    wire [3:0] middle = in[7:4];\n    wire [3:0] upper = in[11:8];\n\n    // Create a 3-bit shift register using master-slave flip-flops\n    reg [2:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[1:0], lower};\n    end\n\n    // Perform a left rotation on the lower byte using the shift register\n    wire [3:0] rotated_lower = {shift_reg[2], shift_reg[1], shift_reg[0]};\n\n    // Combine the rotated lower byte, middle byte, and upper byte using a barrel shifter\n    wire [11:0] shifted_in = {rotated_lower, middle, upper};\n    wire [11:0] and_out;\n\n    // Perform a bitwise AND operation between the shifted input and the original input\n    assign and_out = shifted_in & in;\n\n    // Output the result of the AND operation\n    assign out = and_out[7:0];\n\nendmodule\nmodule barrel_shifter (\n    input [11:0] in,\n    input [1:0] shift,\n    output [11:0] out\n);\n\n    assign out = (shift[1]) ? ({in[7:0], in[11:8], in[3:0]}) :\n                             ({in[3:0], in[7:4], in[11:8], in[10:4] >> shift[0]});\n\nendmodule\nmodule and_gate (\n    input [11:0] in1,\n    input [11:0] in2,\n    output [11:0] out\n);\n\n    assign out = in1 & in2;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "184cb18c6c3504e42523b1c75282a0af",
        "dataset_index": 5648
      },
      "binary_counter_fbdf3326": {
        "rtl_code": "module binary_counter (\n   // Inputs\n   clk,\n   rst,\n   count\n   // Outputs\n   );\n   input clk, rst;\n   output reg [3:0] count;\n\n   always @(posedge clk) begin\n      if (rst) begin\n         count <= 4'b0;\n      end\n      else begin\n         count <= count + 1;\n      end\n   end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "fbdf332677dded7783be1265b264b3b7",
        "dataset_index": 12364
      },
      "OR_gate_dc9af561": {
        "rtl_code": "module OR_gate (\n  input a,\n  input b,\n  output reg out\n);\n\n  always @ (a or b) begin\n    if (a || b) begin\n      out = 1'b1;\n    end\n    else begin\n      out = 1'b0;\n    end\n  end\n\nendmodule\n",
        "module_name": "OR_gate",
        "module_hash": "dc9af561ec2b65cf391b4632e7570e2b",
        "dataset_index": 16130
      },
      "rotate_a42981b4": {
        "rtl_code": "\n\nmodule rotate (\n    input  [15:0] x,\n    input  [ 4:0] y,\n    input  [ 1:0] func,  input         cfi,\n    input         word_op,\n    output [15:0] out,\n    output        cfo,\n    input         ofi,\n    output        ofo\n  );\n\n  wire [4:0] ror16, rol16, rcr16, rcl16, rot16;\n  wire [3:0] ror8, rol8, rcr8, rcl8, rot8;\n  wire [7:0] out8;\n  wire [15:0] out16;\n  wire co8, co16;\n  wire unchanged;\n\n  rxr8 rxr8_0 (\n    .x  (x[7:0]),\n    .ci (cfi),\n    .y  (rot8),\n    .e  (func[1]),\n    .w  (out8),\n    .co (co8)\n  );\n\n  rxr16 rxr16_0 (\n    .x  (x),\n    .ci (cfi),\n    .y  (rot16),\n    .e  (func[1]),\n    .w  (out16),\n    .co (co16)\n  );\n\n  assign unchanged = word_op ? (y==5'b0) : (y[3:0]==4'b0);\n  assign ror16 = { 1'b0, y[3:0] };\n  assign rol16 = { 1'b0, -y[3:0] };\n  assign ror8  = { 1'b0, y[2:0] };\n  assign rol8  = { 1'b0, -y[2:0] };\n\n  assign rcr16 = (y <= 5'd16) ? y : { 1'b0, y[3:0] - 4'b1 };\n  assign rcl16 = (y <= 5'd17) ? 5'd17 - y : 6'd34 - y;\n  assign rcr8  = y[3:0] <= 4'd8 ? y[3:0] : { 1'b0, y[2:0] - 3'b1 };\n  assign rcl8  = y[3:0] <= 4'd9 ? 4'd9 - y[3:0] : 5'd18 - y[3:0];\n\n  assign rot8 = func[1] ? (func[0] ? rcl8 : rcr8 )\n                        : (func[0] ? rol8 : ror8 );\n  assign rot16 = func[1] ? (func[0] ? rcl16 : rcr16 )\n                         : (func[0] ? rol16 : ror16 );\n\n  assign out = word_op ? out16 : { x[15:8], out8 };\n  assign cfo = unchanged ? cfi : (func[1] ? (word_op ? co16 : co8)\n                                          : (func[0] ? out[0]\n                                            : (word_op ? out[15] : out[7])));\n  assign ofo = unchanged ? ofi : (func[0] ? (word_op ? cfo^out[15] : cfo^out[7])\n                       : (word_op ? out[15]^out[14] : out[7]^out[6]));\nendmodule\n\nmodule rxr16 (\n    input      [15:0] x,\n    input             ci,\n    input      [ 4:0] y,\n    input             e,\n    output reg [15:0] w,\n    output reg        co\n  );\n\n  always @(x or ci or y or e)\n    case (y)\n      default: {co,w} <= {ci,x};\n      5'd01: {co,w} <= e ? {x[0], ci, x[15:1]} : {ci, x[0], x[15:1]};\n      5'd02: {co,w} <= e ? {x[ 1:0], ci, x[15: 2]} : {ci, x[ 1:0], x[15: 2]};\n      5'd03: {co,w} <= e ? {x[ 2:0], ci, x[15: 3]} : {ci, x[ 2:0], x[15: 3]};\n      5'd04: {co,w} <= e ? {x[ 3:0], ci, x[15: 4]} : {ci, x[ 3:0], x[15: 4]};\n      5'd05: {co,w} <= e ? {x[ 4:0], ci, x[15: 5]} : {ci, x[ 4:0], x[15: 5]};\n      5'd06: {co,w} <= e ? {x[ 5:0], ci, x[15: 6]} : {ci, x[ 5:0], x[15: 6]};\n      5'd07: {co,w} <= e ? {x[ 6:0], ci, x[15: 7]} : {ci, x[ 6:0], x[15: 7]};\n      5'd08: {co,w} <= e ? {x[ 7:0], ci, x[15: 8]} : {ci, x[ 7:0], x[15: 8]};\n      5'd09: {co,w} <= e ? {x[ 8:0], ci, x[15: 9]} : {ci, x[ 8:0], x[15: 9]};\n      5'd10: {co,w} <= e ? {x[ 9:0], ci, x[15:10]} : {ci, x[ 9:0], x[15:10]};\n      5'd11: {co,w} <= e ? {x[10:0], ci, x[15:11]} : {ci, x[10:0], x[15:11]};\n      5'd12: {co,w} <= e ? {x[11:0], ci, x[15:12]} : {ci, x[11:0], x[15:12]};\n      5'd13: {co,w} <= e ? {x[12:0], ci, x[15:13]} : {ci, x[12:0], x[15:13]};\n      5'd14: {co,w} <= e ? {x[13:0], ci, x[15:14]} : {ci, x[13:0], x[15:14]};\n      5'd15: {co,w} <= e ? {x[14:0], ci, x[15]} : {ci, x[14:0], x[15]};\n      5'd16: {co,w} <= {x,ci};\n    endcase\nendmodule\n\nmodule rxr8 (\n    input      [7:0] x,\n    input            ci,\n    input      [3:0] y,\n    input            e,\n    output reg [7:0] w,\n    output reg       co\n  );\n\n  always @(x or ci or y or e)\n    case (y)\n      default: {co,w} <= {ci,x};\n      5'd01: {co,w} <= e ? {x[0], ci, x[7:1]} : {ci, x[0], x[7:1]};\n      5'd02: {co,w} <= e ? {x[1:0], ci, x[7:2]} : {ci, x[1:0], x[7:2]};\n      5'd03: {co,w} <= e ? {x[2:0], ci, x[7:3]} : {ci, x[2:0], x[7:3]};\n      5'd04: {co,w} <= e ? {x[3:0], ci, x[7:4]} : {ci, x[3:0], x[7:4]};\n      5'd05: {co,w} <= e ? {x[4:0], ci, x[7:5]} : {ci, x[4:0], x[7:5]};\n      5'd06: {co,w} <= e ? {x[5:0], ci, x[7:6]} : {ci, x[5:0], x[7:6]};\n      5'd07: {co,w} <= e ? {x[6:0], ci, x[7]} : {ci, x[6:0], x[7]};\n      5'd08: {co,w} <= {x,ci};\n    endcase\nendmodule\n",
        "module_name": "rotate",
        "module_hash": "a42981b494e91275d90766bf77e3ee66",
        "dataset_index": 13120
      },
      "jcarrylookaheadadder_0dd07b32": {
        "rtl_code": "module jcarrylookaheadadder(Y,carryout,A,B,carryin);\n  output [3:0]Y;\n  output carryout;\n  input [3:0]A,B;\n  input carryin;\n\n  wire [3:0]g,p;wire [4:0]c;assign c[0] = carryin; assign Y[0] = A[0] ^ B[0] ^ c[0];\n  assign c[1] = ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) );\n  \n  assign Y[1] = A[1] ^ B[1] ^ c[1];\n  assign c[2] = ( ( A[1] & B[1] ) | ( ( A[1] ^ B[1] ) & ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) ) ) ); assign Y[2] = A[2] ^ B[2] ^ c[2];\n  assign c[3] = ( ( A[2] & B[2] ) | ( ( A[2] ^ B[2] ) & ( ( A[1] & B[1] ) | ( ( A[1] ^ B[1] ) & ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) ) ) ) ) );\n  \n  assign Y[3] = A[3] ^ B[3] ^ c[3];\n  assign c[4] = ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & ( ( A[2] & B[2] ) | ( ( A[2] ^ B[2] ) & ( ( A[1] & B[1] ) | ( ( A[1] ^ B[1] ) & ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) ) ) ) ) ) ) );  \n  \n\n  assign carryout = c[4];\n\n  \nendmodule\n\n",
        "module_name": "jcarrylookaheadadder",
        "module_hash": "0dd07b32dc36aa01201d12ab9945f46a",
        "dataset_index": 10374
      },
      "parity_checker_1c0e58d2": {
        "rtl_code": "module parity_checker (\n  input [2:0] data,\n  output reg parity\n);\n  \n  always @(*) begin\n    parity = (data[0] ^ data[1] ^ data[2]);\n  end\n  \nendmodule\n",
        "module_name": "parity_checker",
        "module_hash": "1c0e58d27e263566964f141e3e6791b9",
        "dataset_index": 7816
      },
      "bit_counter_0f6a2b26": {
        "rtl_code": "\nmodule bit_counter (\n    input [15:0] D,\n    output [3:0] count,\n    input clk // Added the clock input\n);\n\n// Create a 4-bit parallel prefix adder\nwire [3:0] P[0:3];\nassign P[0] = D[3:0];\nassign P[1] = P[0] + D[7:4];\nassign P[2] = P[1] + D[11:8];\nassign P[3] = P[2] + D[15:12];\n\n// Register the count\nreg [3:0] count_reg;\nalways @(posedge clk) begin\n    count_reg <= P[3]; // Corrected typo here\nend\n\n// Output the count\nassign count = count_reg;\n\nendmodule\n",
        "module_name": "bit_counter",
        "module_hash": "0f6a2b26ec8974bc8d55f99ee7a879cb",
        "dataset_index": 16111
      },
      "adder_4bit_carry_eff6c232": {
        "rtl_code": "module adder_4bit_carry (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] full_sum;\n    assign full_sum = {1'b0, a} + {1'b0, b} + {1'b0, cin};\n\n    assign sum = full_sum[3:0];\n    assign cout = full_sum[4];\n\nendmodule",
        "module_name": "adder_4bit_carry",
        "module_hash": "eff6c232b2cee23a5ca7b65d8e10e3ef",
        "dataset_index": 4916
      },
      "pg_to_PG_6331fac9": {
        "rtl_code": "\nmodule pg_to_PG(\n    input [15:0] p,\n    input [15:0] g,\n    output [3:0] bp,\n    output [3:0] bg\n    );\n\nassign bg[0]=g[3 ]|p[3 ]&g[2 ]|p[3 ]&p[2 ]&g[1 ]|p[3 ]&p[2 ]&p[1 ]&g[0 ],\n       bg[1]=g[7 ]|p[7 ]&g[6 ]|p[7 ]&p[6 ]&g[5 ]|p[7 ]&p[6 ]&p[5 ]&g[4 ], \n       bg[2]=g[11]|p[11]&g[10]|p[11]&p[10]&g[9 ]|p[11]&p[10]&p[9 ]&g[8 ], \n       bg[3]=g[15]|p[15]&g[14]|p[15]&p[14]&g[13]|p[15]&p[14]&p[13]&g[12];\n\t\t \nassign\tbp[0]=p[3]&p[2]&p[1]&p[0],\n\t\t\tbp[1]=p[7]&p[6]&p[5]&p[4],\n\t\t\tbp[2]=p[11]&p[10]&p[9]&p[8],\n\t\t\tbp[3]=p[15]&p[14]&p[13]&p[12];\n\nendmodule\n\n",
        "module_name": "pg_to_PG",
        "module_hash": "6331fac9ee93a2d4cbebf4a97552b787",
        "dataset_index": 4748
      },
      "SSEG_Driver_cd12b54e": {
        "rtl_code": "module SSEG_Driver( clk, reset, data, sseg, an );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ninput  wire clk;\ninput  wire reset;\ninput  wire[15:0] data;\noutput reg[6:0] sseg;\noutput reg[3:0] an;\n\n\nwire[3:0] hex3,hex2,hex1,hex0;\t\n\nassign hex3 = data[15:12];\nassign hex2 = data[11:8];\nassign hex1 = data[7:4];\nassign hex0 = data[3:0];\n\nlocalparam N = 18;\n\nreg[N-1:0] q_reg;\nwire[N-1:0] q_next;\nreg[3:0] hex_in;\n\nalways@( posedge clk or posedge reset )\n\tif( reset )\n\t\tq_reg <= 0;\n\telse\n\t\tq_reg <= q_next;\n\t\t\nassign q_next = q_reg + 1;\n\nalways@( * )\n\tcase( q_reg[N-1:N-2] )\n\t\t2'b00:\n\t\tbegin\n\t\t\tan = 4'b1110;\n\t\t\thex_in = hex0;\n\t\tend\n\t\t\n\t\t2'b01:\n\t\tbegin\n\t\t\tan = 4'b1101;\n\t\t\thex_in = hex1;\n\t\tend\t\n\n\t\t2'b10:\n\t\tbegin\n\t\t\tan = 4'b1011;\n\t\t\thex_in = hex2;\n\t\tend\t\t\n\t\t\n\t\t2'b11:\n\t\tbegin\n\t\t\tan = 4'b0111;\n\t\t\thex_in = hex3;\n\t\tend\n\tendcase\n\t\n\talways@( * )\n\tbegin\n\t\tcase( hex_in )\n\t\t\t\t0 : sseg[6:0] = 7'b1000000;  1 : sseg[6:0] = 7'b1111001;  2 : sseg[6:0] = 7'b0100100;  3 : sseg[6:0] = 7'b0110000;  4 : sseg[6:0] = 7'b0011001;  5 : sseg[6:0] = 7'b0010010;  6 : sseg[6:0] = 7'b0000010;  7 : sseg[6:0] = 7'b1111000;  8 : sseg[6:0] = 7'b0000000;  9 : sseg[6:0] = 7'b0010000;  'hA : sseg[6:0] = 7'b0001000;  'hB : sseg[6:0] = 7'b0000011;  'hC : sseg[6:0] = 7'b1000110;  'hD : sseg[6:0] = 7'b0100001;  'hE : sseg[6:0] = 7'b0000110;  'hF : sseg[6:0] = 7'b0001110;  default : sseg[6:0] = 7'b1111111;\n\t\tendcase\n\tend\n\nendmodule\n",
        "module_name": "SSEG_Driver",
        "module_hash": "cd12b54e9132dd0624378c2f5e59e484",
        "dataset_index": 12214
      },
      "nand2_4a870628": {
        "rtl_code": "\nmodule nand2 (\n    input A,\n    input B,\n    output Y\n);\n\n    assign Y = ~(A & B);\n\nendmodule\nmodule and2 (\n    input A,\n    input B,\n    output Y\n);\n\n    assign Y = A & B;\n\nendmodule\nmodule nand_gate (\n    input A,\n    input B,\n    input VPWR,\n    input VGND,\n    input KAPWR,\n    output Y\n);\n\n    wire nand_out;\n\n    nand2 nand_gate_inst (\n        .A(A),\n        .B(B),\n        .Y(nand_out)\n    );\n\n    and2 and_gate_inst (\n        .A(nand_out),\n        .B(KAPWR),\n        .Y(Y)\n    );\n\nendmodule",
        "module_name": "nand2",
        "module_hash": "4a87062890f06e520ace97cf0669472e",
        "dataset_index": 8003
      },
      "fifo_counter_bd82e1ac": {
        "rtl_code": "module fifo_counter (\n  input empty,\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [4:0] fifo_cnt_inc\n);\n\n  always @(*) begin\n    if (empty) begin\n      fifo_cnt_inc = input_tm_cnt[1:0];\n    end\n    else if (ge3_free && (input_tm_cnt == 2'b11)) begin\n      fifo_cnt_inc = 2;\n    end\n    else if (ge2_free && (input_tm_cnt >= 2)) begin\n      fifo_cnt_inc = 1;\n    end\n    else if (input_tm_cnt >= 1) begin\n      fifo_cnt_inc = 0;\n    end\n    else begin\n      fifo_cnt_inc = 31;\n    end\n  end\n\nendmodule",
        "module_name": "fifo_counter",
        "module_hash": "bd82e1ac3ef2f2941be921c8d4bd24da",
        "dataset_index": 18545
      },
      "accumulator #_11859ee3": {
        "rtl_code": "module accumulator #(\n  parameter n = 8 // number of bits in binary numbers\n)(\n  input [n-1:0] data,\n  input clk,\n  input rst,\n  output reg [n-1:0] sum\n);\n\n\nreg [n-1:0] prev_sum; // flip-flop to store previous sum\n\nalways @(posedge clk) begin\n  if (rst) begin\n    sum <= 0; // reset sum to 0\n    prev_sum <= 0; // reset previous sum to 0\n  end else begin\n    prev_sum <= sum; // store previous sum\n    sum <= data + prev_sum; // update sum with current data and previous sum\n  end\nend\n\nendmodule",
        "module_name": "accumulator #",
        "module_hash": "11859ee3b2bc7db0b94e8896b65a8d53",
        "dataset_index": 7392
      },
      "pwmregister_8556525d": {
        "rtl_code": "module pwmregister(\n  output reg [7:0] pwmval,\n  input clk,\n  input pwmldce,\n  input [7:0] wrtdata);\n  \n  always@(posedge clk) begin\n    if(pwmldce) begin\n      pwmval <= wrtdata;\n    end\n  end \nendmodule",
        "module_name": "pwmregister",
        "module_hash": "8556525d6cf3e8f454eec9a52589d11a",
        "dataset_index": 8883
      },
      "ac97commands_da1af954": {
        "rtl_code": "module ac97commands (\n  input wire clock,\n  input wire ready,\n  output wire [7:0] command_address,\n  output wire [15:0] command_data,\n  output reg command_valid,\n  input wire [4:0] volume,\n  input wire [2:0] source\n);\n  reg [23:0] command;\n\n  reg [3:0] state;\n  initial begin\n    command <= 4'h0;\n    command_valid <= 1'b0;\n    state <= 16'h0000;\n  end\n\n  assign command_address = command[23:16];\n  assign command_data = command[15:0];\n\n  wire [4:0] vol;\n  assign vol = 31-volume;\n\n  always @(posedge clock) begin\n    if (ready) state <= state+1;\n\n    case (state)\n      4'h0: // Read ID\n        begin\n          command <= 24'h80_0000;\n          command_valid <= 1'b1;\n        end\n      4'h1: // Read ID\n        command <= 24'h80_0000;\n      4'h3: // headphone volume\n        command <= { 8'h04, 3'b000, vol, 3'b000, vol };\n      4'h5: // PCM volume\n        command <= 24'h18_0808;\n      4'h6: // Record source select\n        command <= { 8'h1A, 5'b00000, source, 5'b00000, source};\n      4'h7: // Record gain = max\n        command <= 24'h1C_0F0F;\n      4'h9: // set +20db mic gain\n        command <= 24'h0E_8048;\n      4'hA: // Set beep volume\n        command <= 24'h0A_0000;\n      4'hB: // PCM out bypass mix1\n        command <= 24'h20_8000;\n      default:\n        command <= 24'h80_0000;\n    endcase\n  end\nendmodule",
        "module_name": "ac97commands",
        "module_hash": "da1af9540ddf35cbaaffabc8b4c29883",
        "dataset_index": 1531
      },
      "iic_multiplexer #_92eabda4": {
        "rtl_code": "\nmodule iic_multiplexer #\n    (\n        parameter integer MUX_WIDTH = 2\n    ) \n    (  \n        input  wire upstream_scl_T,\n        input  wire upstream_scl_I,\n        output wire upstream_scl_O,\n        input  wire upstream_sda_T,\n        input  wire upstream_sda_I,\n        output wire upstream_sda_O,\n        \n        output wire [MUX_WIDTH - 1:0] downstream_scl_T,\n        input  wire [MUX_WIDTH - 1:0] downstream_scl_I,\n        output wire [MUX_WIDTH - 1:0] downstream_scl_O,\n        output wire [MUX_WIDTH - 1:0] downstream_sda_T,\n        input  wire [MUX_WIDTH - 1:0] downstream_sda_I,\n        output wire [MUX_WIDTH - 1:0] downstream_sda_O\n    );\n    \n    assign upstream_scl_O = &downstream_scl_I;\n    assign upstream_sda_O = &downstream_sda_I;\n    genvar k;\n    generate\n        for (k = 0; k <= MUX_WIDTH - 1; k = k + 1) begin: GEN\n            assign downstream_scl_O[k] = upstream_scl_I;\n            assign downstream_sda_O[k] = upstream_sda_I;\n            assign downstream_scl_T[k] = upstream_scl_T;\n            assign downstream_sda_T[k] = upstream_sda_T;        \n        end\n    endgenerate\n        \nendmodule\n",
        "module_name": "iic_multiplexer #",
        "module_hash": "92eabda448229e2c5ee331a904941978",
        "dataset_index": 22527
      },
      "motor_control_block_90d51896": {
        "rtl_code": "module motor_control_block (\n  input pwm_in, \n  input hbridge_ctrl, \n  input stepper_ctrl,\n  input clk, \n  output pwm_out, \n  output hbridge_out, \n  output stepper_out\n);\n\nparameter pwm_freq = 100; // PWM frequency in Hz\nparameter step_delay = 10; // Stepper motor step delay in clock cycles\n\nreg [7:0] pwm_counter;\nreg pwm_out_reg;\n\nassign pwm_out = pwm_out_reg;\nassign hbridge_out = hbridge_ctrl;\nassign stepper_out = stepper_ctrl;\n\nalways @(posedge clk) begin\n  // Implementation of PWM Controller\n  if (pwm_counter == 0) begin\n    pwm_out_reg <= 1;\n  end else if (pwm_counter == pwm_freq/2) begin\n    pwm_out_reg <= 0;\n  end\n  \n  pwm_counter <= pwm_counter + 1;\n  \n  // Implementation of Stepper Motor Controller\n  // ...\nend\n\n\nendmodule",
        "module_name": "motor_control_block",
        "module_hash": "90d51896ddf0db8aa77e502138d406fc",
        "dataset_index": 7073
      },
      "Bit_Counter_89fea09e": {
        "rtl_code": "module Bit_Counter(\n    input clk,\n    input reset,\n    input bit_clk_rising_edge,\n    input bit_clk_falling_edge,\n    input left_right_clk_rising_edge,\n    input left_right_clk_falling_edge,\n    output reg counting\n);\n\nparameter BIT_COUNTER_INIT = 5'd31;\n\nreg [4:0] bit_counter;\nwire reset_bit_counter;\n\nalways @(posedge clk) begin\n    if (reset == 1'b1) begin\n        bit_counter <= 5'h00;\n    end else if (reset_bit_counter == 1'b1) begin\n        bit_counter <= BIT_COUNTER_INIT;\n    end else if ((bit_clk_falling_edge == 1'b1) && (bit_counter != 5'h00)) begin\n        bit_counter <= bit_counter - 5'h01;\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset == 1'b1) begin\n        counting <= 1'b0;\n    end else if (reset_bit_counter == 1'b1) begin\n        counting <= 1'b1;\n    end else if ((bit_clk_falling_edge == 1'b1) && (bit_counter == 5'h00)) begin\n        counting <= 1'b0;\n    end\nend\n\nassign reset_bit_counter = left_right_clk_rising_edge | \n                            left_right_clk_falling_edge;\n\nendmodule",
        "module_name": "Bit_Counter",
        "module_hash": "89fea09ef6a82a11695c2697016293d1",
        "dataset_index": 13084
      },
      "blk_mem_gen_0blk_mem_gen_top_1f5fffb3": {
        "rtl_code": "module blk_mem_gen_0blk_mem_gen_top\n   (doutb,\n    enb,\n    clkb,\n    wea,\n    clka,\n    addrb,\n    addra,\n    dina);\n  output [63:0]doutb;\n  input enb;\n  input clkb;\n  input [0:0]wea;\n  input clka;\n  input [8:0]addrb;\n  input [8:0]addra;\n  input [63:0]dina;\n\n  reg [63:0] memory [0:511];  // 512 locations, 64 bits each\n  wire [63:0]doutb;\n  wire [8:0]addra;\n  wire [8:0]addrb;\n  wire clka;\n  wire clkb;\n  wire enb;\n  wire [0:0]wea;\n\n  assign addra = addra[8:0];  // truncate to 9 bits\n  assign addrb = addrb[8:0];  // truncate to 9 bits\n\n  always @ (posedge clka) begin\n    if (enb && wea == 1'b1) begin\n      memory[addra] <= dina;\n    end\n  end\n\n  assign doutb = memory[addrb];\n\nendmodule",
        "module_name": "blk_mem_gen_0blk_mem_gen_top",
        "module_hash": "1f5fffb335c8814b61ee1a7f803e5b50",
        "dataset_index": 2036
      },
      "sky130_fd_sc_ls__fahcin_c55d9b3f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__fahcin (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CIN\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CIN ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire ci          ;\n    wire xor0_out_SUM;\n    wire a_b         ;\n    wire a_ci        ;\n    wire b_ci        ;\n    wire or0_out_COUT;\n\n    not not0 (ci          , CIN            );\n    xor xor0 (xor0_out_SUM, A, B, ci       );\n    buf buf0 (SUM         , xor0_out_SUM   );\n    and and0 (a_b         , A, B           );\n    and and1 (a_ci        , A, ci          );\n    and and2 (b_ci        , B, ci          );\n    or  or0  (or0_out_COUT, a_b, a_ci, b_ci);\n    buf buf1 (COUT        , or0_out_COUT   );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__fahcin",
        "module_hash": "c55d9b3feec9cb4356c35efb7dd32c02",
        "dataset_index": 4252
      },
      "top__30acf77a": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input select,\n    input [15:0] in_A, \n    input [15:0] in_B,\n    output reg [7:0] out\n);\n\nreg [15:0] reg_in;\nwire [15:0] shift_out;\nwire [15:0] mux_out;\nwire [15:0] and_out;\n\n// Register module\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        reg_in <= 16'b0;\n    end else begin\n        reg_in <= in_A;\n    end\nend\n\n// Barrel shifter module\nassign shift_out = reg_in << select;\n\n// 2-to-1 multiplexer module\nreg temp_mux_out; // Use reg instead of wire\nalways @(select, in_A, in_B) begin\n    case (select)\n        1'b0: temp_mux_out <= in_A;\n        1'b1: temp_mux_out <= in_B;\n    endcase\nend\n\nassign mux_out = temp_mux_out; // Assign reg to wire\n\n// Functional module\nassign and_out = mux_out & shift_out;\n\n// Output register\nalways @(posedge clk) begin\n    out <= and_out[7:0];\nend\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "30acf77a7d49fef9616e1c6b41a97a49",
        "dataset_index": 17238
      },
      "add_sub_edge_aaa1370c": {
        "rtl_code": "\nmodule add_sub_edge (\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    input [7:0] in,\n    output [31:0] sum,\n    output [7:0] anyedge_result\n);\n\n    // Adder-Subtractor Module\n    wire [31:0] adder_out;\n    wire [31:0] inverted_b = sub ? ~b + 1 : b;\n    carry_lookahead_adder adder_inst (\n        .a(a),\n        .b(inverted_b),\n        .cin(sub),\n        .sum(adder_out)\n    );\n\n    // Edge Detection Module\n    reg [7:0] prev_in;\n    always @(posedge clk) begin\n        prev_in <= in;\n    end\n    wire [7:0] anyedge_out = (in ^ prev_in);\n\n    // Output Mux\n    assign sum = adder_out;\n    assign anyedge_result = anyedge_out ? adder_out[7:0] : 8'b0;\n\nendmodule\nmodule carry_lookahead_adder (\n    input [31:0] a,\n    input [31:0] b,\n    input cin,\n    output [31:0] sum\n);\n\n    wire [31:0] p = a + b;\n    wire [31:0] g = a & b;\n    wire [31:0] c = {cin, g[30:0]} + {g[31], p[30:0]};\n    assign sum = {c[30], p[29:0]};\n\nendmodule",
        "module_name": "add_sub_edge",
        "module_hash": "aaa1370c87b07ca77a45b636d50d9972",
        "dataset_index": 9068
      },
      "complexMultiply_cda9feb6": {
        "rtl_code": "module complexMultiply (\n    input signed [17:0] in1_re, // sfix18_En16\n    input signed [17:0] in1_im, // sfix18_En16\n    input signed [17:0] in2_re, // sfix18_En16\n    input signed [17:0] in2_im, // sfix18_En16\n    output signed [35:0] re,    // sfix36_En32\n    output signed [35:0] im     // sfix36_En32\n);\n\n    wire signed [35:0] product1; // sfix36_En32\n    wire signed [35:0] product2; // sfix36_En32\n    wire signed [35:0] add1;     // sfix36_En32\n    wire signed [35:0] product3; // sfix36_En32\n    wire signed [35:0] product4; // sfix36_En32\n    wire signed [35:0] add2;     // sfix36_En32\n\n    // Multiply the first input's real part with the second input's real part.\n    assign product1 = in1_re * in2_re;\n\n    // Multiply the first input's imaginary part with the second input's imaginary part.\n    assign product2 = in1_im * in2_im;\n\n    // Subtract the product from step 2 from the product from step 1. This is the real part of the result.\n    assign add1 = product1 - product2;\n\n    // Multiply the first input's real part with the second input's imaginary part.\n    assign product3 = in1_re * in2_im;\n\n    // Multiply the first input's imaginary part with the second input's real part.\n    assign product4 = in1_im * in2_re;\n\n    // Add the products from steps 4 and 5. This is the imaginary part of the result.\n    assign add2 = product3 + product4;\n\n    // Output the real and imaginary parts of the result.\n    assign re = add1;\n    assign im = add2;\n\nendmodule",
        "module_name": "complexMultiply",
        "module_hash": "cda9feb6b7004b14f52aef314dadf371",
        "dataset_index": 796
      },
      "fixed_point_arithmetic #_5993aade": {
        "rtl_code": "module fixed_point_arithmetic #(\n  parameter n = 16 // number of bits for fixed point representation\n) (\n  input [n-1:0] a,\n  input [n-1:0] b,\n  input [1:0] op,\n  output reg [n-1:0] c\n);\n\n\n// define the integer and fractional bits\nparameter int_bits = 8;\nparameter frac_bits = n - int_bits;\n\n// define scaling factor for fixed-point representation\nparameter scaling_factor = 2 ** frac_bits;\n\n// define maximum and minimum values for fixed-point representation\nparameter max_value = (2 ** (n - 1)) - 1;\nparameter min_value = -max_value;\n\n// define two's complement representation for negative numbers\nfunction [n-1:0] twos_complement;\n  input [n-1:0] num;\n  begin\n    if (num < 0) begin\n      twos_complement = ~(-num) + 1;\n    end\n    else begin\n      twos_complement = num;\n    end\n  end\nendfunction\n\n// perform fixed-point arithmetic operations based on control signal (op)\nalways @(*) begin\n  case (op)\n    2'b00: c = twos_complement(a) + twos_complement(b);\n    2'b01: c = twos_complement(a) - twos_complement(b);\n    2'b10: c = twos_complement(a) * twos_complement(b) / scaling_factor;\n    2'b11: begin\n      if (b == 0) begin\n        c = max_value;\n      end\n      else begin\n        c = (twos_complement(a) * scaling_factor) / twos_complement(b);\n      end\n    end\n  endcase\nend\n\nendmodule",
        "module_name": "fixed_point_arithmetic #",
        "module_hash": "5993aadebdfc864517b552dc5819f4d7",
        "dataset_index": 1198
      },
      "jt51_lfo_lfsr #_838b6ae0": {
        "rtl_code": "\n\n\n\nmodule jt51_lfo_lfsr #(parameter init=220 )(\n\tinput\trst,\n\tinput\tclk,\n\tinput\tbase,\n\toutput\tout\n);\n\nreg [18:0] bb;\nassign out = bb[18];\n\nreg last_base;\n\nalways @(posedge clk) begin : base_counter\n\tif( rst ) begin\n\t\tbb\t\t\t<= init[18:0];\n\t\tlast_base \t<= 1'b0;\n\tend\n\telse begin\n\t\tlast_base <= base;\n\t\tif( last_base != base ) begin\t\n\t\t\tbb[18:1] \t<= bb[17:0];\n\t\t\tbb[0]\t\t<= ^{bb[0],bb[1],bb[14],bb[15],bb[17],bb[18]};\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "jt51_lfo_lfsr #",
        "module_hash": "838b6ae0c2d3691d2afbe20014580d6a",
        "dataset_index": 15019
      },
      "ones_counter_7fd958c2": {
        "rtl_code": "\nmodule ones_counter (\n    input clk,\n    input [7:0] in,\n    output reg [3:0] count\n);\n\n    reg [3:0] temp_count;\n    reg [7:0] shift_reg;\n    \n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[6:0], in};\n        temp_count <= (shift_reg[7:5] == 3'b111) ? temp_count + 1 : 0;\n        count <= temp_count;\n    end\n\nendmodule\n\nmodule triple_counter (\n    input clk,\n    input [7:0] in,\n    input [3:0] ones_count,\n    output reg [2:0] triple_count\n);\n\n    reg [2:0] temp_count;\n    reg [7:0] shift_reg;\n    \n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[6:0], in};\n        temp_count <= (shift_reg[7:5] == 3'b111 && ones_count >= 3) ? temp_count + 1 : 0;\n        triple_count <= temp_count;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [3:0] ones_count,\n    output [2:0] triple_count\n);\n\n    ones_counter ones_count_inst (\n        .clk(clk),\n        .in(in),\n        .count(ones_count)\n    );\n    \n    triple_counter triple_count_inst (\n        .clk(clk),\n        .in(in),\n        .ones_count(ones_count),\n        .triple_count(triple_count)\n    );\n\nendmodule\n\nmodule DFF (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n",
        "module_name": "ones_counter",
        "module_hash": "7fd958c2daea18bf1422214741714452",
        "dataset_index": 15758
      },
      "and_gate_f155923d": {
        "rtl_code": "module and_gate(input a, b, c, output out);\n  wire and_output;\n  \n  and3_gate and3_inst(.a(a), .b(b), .c(c), .out(and_output));\n  or2_gate or2_inst(.a(and_output), .b(c), .out(out));\n  \nendmodule\n\nmodule and3_gate(input a, b, c, output out);\n  assign out = a & b & c;\nendmodule\n\nmodule or2_gate(input a, b, output out);\n  assign out = a | b;\nendmodule",
        "module_name": "and_gate",
        "module_hash": "f155923dc88ce9f3ab07068de5c723d1",
        "dataset_index": 1415
      },
      "busctrl_6c649899": {
        "rtl_code": "module busctrl(cpu_en, cpu_wr, cpu_size, cpu_addr,\n               cpu_data_out, cpu_data_in, cpu_wt,\n               ram_en, ram_wr, ram_size, ram_addr,\n               ram_data_in, ram_data_out, ram_wt,\n               rom_en, rom_wr, rom_size, rom_addr,\n               rom_data_out, rom_wt,\n               tmr0_en, tmr0_wr, tmr0_addr,\n               tmr0_data_in, tmr0_data_out, tmr0_wt,\n               tmr1_en, tmr1_wr, tmr1_addr,\n               tmr1_data_in, tmr1_data_out, tmr1_wt,\n               dsp_en, dsp_wr, dsp_addr,\n               dsp_data_in, dsp_data_out, dsp_wt,\n               kbd_en, kbd_wr, kbd_addr,\n               kbd_data_in, kbd_data_out, kbd_wt,\n               ser0_en, ser0_wr, ser0_addr,\n               ser0_data_in, ser0_data_out, ser0_wt,\n               ser1_en, ser1_wr, ser1_addr,\n               ser1_data_in, ser1_data_out, ser1_wt,\n               dsk_en, dsk_wr, dsk_addr,\n               dsk_data_in, dsk_data_out, dsk_wt);\n    input cpu_en;\n    input cpu_wr;\n    input [1:0] cpu_size;\n    input [31:0] cpu_addr;\n    input [31:0] cpu_data_out;\n    output [31:0] cpu_data_in;\n    output cpu_wt;\n    output ram_en;\n    output ram_wr;\n    output [1:0] ram_size;\n    output [24:0] ram_addr;\n    output [31:0] ram_data_in;\n    input [31:0] ram_data_out;\n    input ram_wt;\n    output rom_en;\n    output rom_wr;\n    output [1:0] rom_size;\n    output [20:0] rom_addr;\n    input [31:0] rom_data_out;\n    input rom_wt;\n    output tmr0_en;\n    output tmr0_wr;\n    output [3:2] tmr0_addr;\n    output [31:0] tmr0_data_in;\n    input [31:0] tmr0_data_out;\n    input tmr0_wt;\n    output tmr1_en;\n    output tmr1_wr;\n    output [3:2] tmr1_addr;\n    output [31:0] tmr1_data_in;\n    input [31:0] tmr1_data_out;\n    input tmr1_wt;\n    output dsp_en;\n    output dsp_wr;\n    output [13:2] dsp_addr;\n    output [15:0] dsp_data_in;\n    input [15:0] dsp_data_out;\n    input dsp_wt;\n    output kbd_en;\n    output kbd_wr;\n    output kbd_addr;\n    output [7:0] kbd_data_in;\n    input [7:0] kbd_data_out;\n    input kbd_wt;\n    output ser0_en;\n    output ser0_wr;\n    output [3:2] ser0_addr;\n    output [7:0] ser0_data_in;\n    input [7:0] ser0_data_out;\n    input ser0_wt;\n    output ser1_en;\n    output ser1_wr;\n    output [3:2] ser1_addr;\n    output [7:0] ser1_data_in;\n    input [7:0] ser1_data_out;\n    input ser1_wt;\n    output dsk_en;\n    output dsk_wr;\n    output [19:2] dsk_addr;\n    output [31:0] dsk_data_in;\n    input [31:0] dsk_data_out;\n    input dsk_wt;\n\n  wire i_o_en;\n\n  assign ram_en =\n    (cpu_en == 1 && cpu_addr[31:29] == 3'b000\n                 && cpu_addr[28:25] == 4'b0000) ? 1 : 0;\n  assign rom_en =\n    (cpu_en == 1 && cpu_addr[31:28] == 4'b0010\n                 && cpu_addr[27:21] == 7'b0000000) ? 1 : 0;\n  assign i_o_en =\n    (cpu_en == 1 && cpu_addr[31:28] == 4'b0011) ? 1 : 0;\n  assign tmr0_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h00\n                 && cpu_addr[19:12] == 8'h00) ? 1 : 0;\n  assign tmr1_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h00\n                 && cpu_addr[19:12] == 8'h01) ? 1 : 0;\n  assign dsp_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h01) ? 1 : 0;\n  assign kbd_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h02) ? 1 : 0;\n  assign ser0_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h03\n                 && cpu_addr[19:12] == 8'h00) ? 1 : 0;\n  assign ser1_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h03\n                 && cpu_addr[19:12] == 8'h01) ? 1 : 0;\n  assign dsk_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h04) ? 1 : 0;\n\n  assign cpu_wt =\n    (ram_en == 1) ? ram_wt :\n    (rom_en == 1) ? rom_wt :\n    (tmr0_en == 1) ? tmr0_wt :\n    (tmr1_en == 1) ? tmr1_wt :\n    (dsp_en == 1) ? dsp_wt :\n    (kbd_en == 1) ? kbd_wt :\n    (ser0_en == 1) ? ser0_wt :\n    (ser1_en == 1) ? ser1_wt :\n    (dsk_en == 1) ? dsk_wt :\n    1;\n  assign cpu_data_in[31:0] =\n    (ram_en == 1) ? ram_data_out[31:0] :\n    (rom_en == 1) ? rom_data_out[31:0] :\n    (tmr0_en == 1) ? tmr0_data_out[31:0] :\n    (tmr1_en == 1) ? tmr1_data_out[31:0] :\n    (dsp_en == 1) ? { 16'h0000, dsp_data_out[15:0] } :\n    (kbd_en == 1) ? { 24'h000000, kbd_data_out[7:0] } :\n    (ser0_en == 1) ? { 24'h000000, ser0_data_out[7:0] } :\n    (ser1_en == 1) ? { 24'h000000, ser1_data_out[7:0] } :\n    (dsk_en == 1) ? dsk_data_out[31:0] :\n    32'h00000000;\n\n  assign ram_wr = cpu_wr;\n  assign ram_size[1:0] = cpu_size[1:0];\n  assign ram_addr[24:0] = cpu_addr[24:0];\n  assign ram_data_in[31:0] = cpu_data_out[31:0];\n\n  assign rom_wr = cpu_wr;\n  assign rom_size[1:0] = cpu_size[1:0];\n  assign rom_addr[20:0] = cpu_addr[20:0];\n\n  assign tmr0_wr = cpu_wr;\n  assign tmr0_addr[3:2] = cpu_addr[3:2];\n  assign tmr0_data_in[31:0] = cpu_data_out[31:0];\n\n  assign tmr1_wr = cpu_wr;\n  assign tmr1_addr[3:2] = cpu_addr[3:2];\n  assign tmr1_data_in[31:0] = cpu_data_out[31:0];\n\n  assign dsp_wr = cpu_wr;\n  assign dsp_addr[13:2] = cpu_addr[13:2];\n  assign dsp_data_in[15:0] = cpu_data_out[15:0];\n\n  assign kbd_wr = cpu_wr;\n  assign kbd_addr = cpu_addr[2];\n  assign kbd_data_in[7:0] = cpu_data_out[7:0];\n\n  assign ser0_wr = cpu_wr;\n  assign ser0_addr[3:2] = cpu_addr[3:2];\n  assign ser0_data_in[7:0] = cpu_data_out[7:0];\n\n  assign ser1_wr = cpu_wr;\n  assign ser1_addr[3:2] = cpu_addr[3:2];\n  assign ser1_data_in[7:0] = cpu_data_out[7:0];\n\n  assign dsk_wr = cpu_wr;\n  assign dsk_addr[19:2] = cpu_addr[19:2];\n  assign dsk_data_in[31:0] = cpu_data_out[31:0];\n\nendmodule\n",
        "module_name": "busctrl",
        "module_hash": "6c64989912c867b616990bb8edf223d6",
        "dataset_index": 22904
      },
      "sync_w2r_e4642a4f": {
        "rtl_code": "\n\n\nmodule sync_w2r \n    \n    #(\n    parameter ASIZE = 4\n    )(\n    input  wire              rclk,\n    input  wire              rrst_n,\n    output reg  [ASIZE:0] rq2_wptr,\n    input  wire [ASIZE:0] wptr\n    );\n    \n    reg [ASIZE:0] rq1_wptr;\n    \n    always @(posedge rclk or negedge rrst_n) begin\n        \n        if (!rrst_n) \n            {rq2_wptr,rq1_wptr} <= 0;\n        else\n            {rq2_wptr,rq1_wptr} <= {rq1_wptr,wptr};\n\n    end\n\nendmodule\n\n`resetall\n",
        "module_name": "sync_w2r",
        "module_hash": "e4642a4f74e427502a71d27020ff2371",
        "dataset_index": 23394
      },
      "tmu2_burst #_7bd70675": {
        "rtl_code": "\n\nmodule tmu2_burst #(\n\tparameter fml_depth = 26\n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\tinput flush,\n\toutput reg busy,\n\t\n\tinput pipe_stb_i,\n\toutput pipe_ack_o,\n\tinput [15:0] color,\n\tinput [fml_depth-1-1:0] dadr, \n\t\n\toutput reg pipe_stb_o,\n\tinput pipe_ack_i,\n\toutput reg [fml_depth-5-1:0] burst_addr, \n\t\n\toutput reg [15:0] burst_sel,\n\toutput reg [255:0] burst_do\n);\n\nwire burst_hit = dadr[fml_depth-1-1:4] == burst_addr;\n\n\nreg [15:0] color_r;\nreg [fml_depth-1-1:0] dadr_r;\nalways @(posedge sys_clk) begin\n\tif(pipe_stb_i & pipe_ack_o) begin\n\t\tcolor_r <= color;\n\t\tdadr_r <= dadr;\n\tend\nend\n\n\nreg clear_en;\nreg write_en;\nreg use_memorized;\nwire [15:0] color_mux = use_memorized ? color_r : color;\nwire [fml_depth-1-1:0] dadr_mux = use_memorized ? dadr_r : dadr;\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tburst_sel = 16'd0;\n\telse begin\n\t\tif(clear_en)\n\t\t\tburst_sel = 16'd0;\n\t\tif(write_en) begin\n\t\t\tburst_addr = dadr_mux[fml_depth-1-1:4]; \n\t\t\tcase(dadr_mux[3:0]) \n\t\t\t\t4'd00: burst_sel = burst_sel | 16'h8000;\n\t\t\t\t4'd01: burst_sel = burst_sel | 16'h4000;\n\t\t\t\t4'd02: burst_sel = burst_sel | 16'h2000;\n\t\t\t\t4'd03: burst_sel = burst_sel | 16'h1000;\n\t\t\t\t4'd04: burst_sel = burst_sel | 16'h0800;\n\t\t\t\t4'd05: burst_sel = burst_sel | 16'h0400;\n\t\t\t\t4'd06: burst_sel = burst_sel | 16'h0200;\n\t\t\t\t4'd07: burst_sel = burst_sel | 16'h0100;\n\t\t\t\t4'd08: burst_sel = burst_sel | 16'h0080;\n\t\t\t\t4'd09: burst_sel = burst_sel | 16'h0040;\n\t\t\t\t4'd10: burst_sel = burst_sel | 16'h0020;\n\t\t\t\t4'd11: burst_sel = burst_sel | 16'h0010;\n\t\t\t\t4'd12: burst_sel = burst_sel | 16'h0008;\n\t\t\t\t4'd13: burst_sel = burst_sel | 16'h0004;\n\t\t\t\t4'd14: burst_sel = burst_sel | 16'h0002;\n\t\t\t\t4'd15: burst_sel = burst_sel | 16'h0001;\n\t\t\tendcase\n\t\t\tcase(dadr_mux[3:0]) \n\t\t\t\t4'd00: burst_do[255:240] = color_mux;\n\t\t\t\t4'd01: burst_do[239:224] = color_mux;\n\t\t\t\t4'd02: burst_do[223:208] = color_mux;\n\t\t\t\t4'd03: burst_do[207:192] = color_mux;\n\t\t\t\t4'd04: burst_do[191:176] = color_mux;\n\t\t\t\t4'd05: burst_do[175:160] = color_mux;\n\t\t\t\t4'd06: burst_do[159:144] = color_mux;\n\t\t\t\t4'd07: burst_do[143:128] = color_mux;\n\t\t\t\t4'd08: burst_do[127:112] = color_mux;\n\t\t\t\t4'd09: burst_do[111: 96] = color_mux;\n\t\t\t\t4'd10: burst_do[ 95: 80] = color_mux;\n\t\t\t\t4'd11: burst_do[ 79: 64] = color_mux;\n\t\t\t\t4'd12: burst_do[ 63: 48] = color_mux;\n\t\t\t\t4'd13: burst_do[ 47: 32] = color_mux;\n\t\t\t\t4'd14: burst_do[ 31: 16] = color_mux;\n\t\t\t\t4'd15: burst_do[ 15:  0] = color_mux;\n\t\t\tendcase\n\t\tend\n\tend\nend\n\nwire empty = (burst_sel == 16'd0);\n\nreg state;\nreg next_state;\n\nparameter RUNNING\t= 1'b0;\nparameter DOWNSTREAM\t= 1'b1;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tstate <= RUNNING;\n\telse\n\t\tstate <= next_state;\nend\n\n\n\nassign pipe_ack_o = (state == RUNNING) & (~flush | empty);\n\nalways @(*) begin\n\tnext_state = state;\n\tbusy = 1'b1;\n\tpipe_stb_o = 1'b0;\n\twrite_en = 1'b0;\n\tclear_en = 1'b0;\n\tuse_memorized = 1'b0;\n\t\n\tcase(state)\n\t\tRUNNING: begin\n\t\t\tbusy = 1'b0;\n\t\t\tif(flush & ~empty)\n\t\t\t\tnext_state = DOWNSTREAM;\n\t\t\telse begin\n\t\t\t\tif(pipe_stb_i) begin\n\t\t\t\t\tif(burst_hit | empty)\n\t\t\t\t\t\twrite_en = 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state = DOWNSTREAM;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tDOWNSTREAM: begin\n\t\t\tpipe_stb_o = 1'b1;\n\t\t\tuse_memorized = 1'b1;\n\t\t\tif(pipe_ack_i) begin\n\t\t\t\tclear_en = 1'b1;\n\t\t\t\twrite_en = 1'b1;\n\t\t\t\tnext_state = RUNNING;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "tmu2_burst #",
        "module_hash": "7bd70675245ab4835c4f26bc74635b74",
        "dataset_index": 12341
      },
      "xor_shift_registers_fixed_6e398d3c": {
        "rtl_code": "\nmodule xor_shift_registers_fixed (\n  input clk,\n  input reset,\n  input d,\n  output q\n);\n\n  reg [3:0] sr1;\n  reg [1:0] sr2;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      sr1 <= 4'b0000;\n      sr2 <= 2'b00;\n    end else begin\n      sr1 <= {sr1[2:0], sr1[3]};\n      sr2 <= {sr2[0], d};\n    end\n  end\n\n  assign q = sr1[0] ^ sr2[1];\n\nendmodule\n",
        "module_name": "xor_shift_registers_fixed",
        "module_hash": "6e398d3cad02e800826324074c7b116f",
        "dataset_index": 18596
      },
      "timer #_759244ff": {
        "rtl_code": "module timer #\n(\n    parameter WIDTH = 64,\n    parameter USE_2XCLK = 0,\n    parameter S_WIDTH_A = 2\n)\n(\n    input clk,\n    input clk2x,\n    input resetn,\n\n    // Slave port\n    input [S_WIDTH_A-1:0] slave_address,  // Word address\n    input [WIDTH-1:0] slave_writedata,\n    input slave_read,\n    input slave_write,\n    input [WIDTH/8-1:0] slave_byteenable,\n    output slave_waitrequest,\n    output [WIDTH-1:0] slave_readdata,\n    output slave_readdatavalid\n);\n\nreg [WIDTH-1:0] counter;\nreg [WIDTH-1:0] counter2x;\n\nreg clock_sel;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    clock_sel <= 1'b0;\n  else if (slave_write)\n    if (|slave_writedata)\n      clock_sel <= 1'b1;\n    else\n      clock_sel <= 1'b0;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    counter <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter <= {WIDTH{1'b0}};\n  else\n    counter <= counter + 2'b01;\n\nalways@(posedge clk2x or negedge resetn)\n  if (!resetn)\n    counter2x <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter2x <= {WIDTH{1'b0}};\n  else\n    counter2x <= counter2x + 2'b01;\n\nassign slave_waitrequest = 1'b0;\nassign slave_readdata = (USE_2XCLK && clock_sel) ? counter2x : counter;\nassign slave_readdatavalid = slave_read;\n\nendmodule",
        "module_name": "timer #",
        "module_hash": "759244ffc6967ff8b1aeeec75fb109bd",
        "dataset_index": 21223
      },
      "d_flip_flop_reset_set_81ec2d0d": {
        "rtl_code": "\nmodule d_flip_flop_reset_set (\n    input CLK,\n    input D,\n    input RESET_B,\n    input SET_B,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK) begin\n        if (!RESET_B) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (!SET_B) begin\n            Q <= 1;\n            Q_N <= 0;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule",
        "module_name": "d_flip_flop_reset_set",
        "module_hash": "81ec2d0d5fd8020f0cbd43c8d9aa3405",
        "dataset_index": 17037
      },
      "shift_register_incrementer_xor_1de258c0": {
        "rtl_code": "module shift_register_incrementer_xor (\n    input clk,\n    input reset,     // Synchronous active-high reset\n    input [7:0] d,   // 8-bit input for the shift register\n    input select,    // Select input for shifting left or right\n    output [7:0] q,  // 8-bit output from the shift register\n    output reg [3:0] ena,// Incrementer enable signal for each digit\n    output reg [3:0] c,  // Incrementer output for each digit\n    output [7:0] f    // Output from the functional module\n);\n\nreg [7:0] shift_reg;\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 8'b0;\n        counter <= 4'b0;\n    end else begin\n        if (select) begin\n            shift_reg <= {shift_reg[6:0], d};\n        end else begin\n            shift_reg <= {d, shift_reg[7:1]};\n        end\n        \n        ena <= 4'b1111;\n        c <= counter;\n        counter <= counter + 1;\n        if (counter == 4'b1111) begin\n            counter <= 4'b0;\n        end\n    end\nend\n\nassign q = shift_reg;\nassign f = shift_reg ^ {counter, counter, counter, counter};\n\nendmodule",
        "module_name": "shift_register_incrementer_xor",
        "module_hash": "1de258c0bec3dce3aa53a4e43f0369b2",
        "dataset_index": 667
      },
      "bin_to_gray_converter_b1957ba3": {
        "rtl_code": "module bin_to_gray_converter (\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[0] = binary[0];\n  assign gray[1] = binary[0] ^ binary[1];\n  assign gray[2] = binary[1] ^ binary[2];\n  assign gray[3] = binary[2] ^ binary[3];\n\nendmodule\n",
        "module_name": "bin_to_gray_converter",
        "module_hash": "b1957ba3cd354912076a184e3d359723",
        "dataset_index": 16726
      },
      "combinational_circuit_4a776bc2": {
        "rtl_code": "module combinational_circuit(\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nwire [1:0] mux_out_and;\nwire [1:0] mux_out_or;\nwire [1:0] mux_out_xor;\n\nassign mux_out_and[0] = in[0] & in[1];\nassign mux_out_and[1] = in[2] & in[3];\n\nassign mux_out_or[0] = in[0] | in[1];\nassign mux_out_or[1] = in[2] | in[3];\n\nassign mux_out_xor[0] = in[0] ^ in[1];\nassign mux_out_xor[1] = in[2] ^ in[3];\n\nassign out_and = mux_out_and[0] & mux_out_and[1];\nassign out_or = mux_out_or[0] | mux_out_or[1];\nassign out_xor = mux_out_xor[0] ^ mux_out_xor[1];\n\nendmodule\n\nmodule top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\ncombinational_circuit cc(\n    .in(in),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xor(out_xor)\n);\n\nendmodule",
        "module_name": "combinational_circuit",
        "module_hash": "4a776bc2fc94dec9cb7a3eb5d00c2b94",
        "dataset_index": 20263
      },
      "MEM_3402c592": {
        "rtl_code": "module MEM(\n\tinput clk,\n\tinput [5:0] Op,\n\tinput [2:0] Condition,\n\tinput Branch,\n\tinput MemWrite,\n\tinput RegWrite,\n\tinput [31:0] MemData,\n\tinput Less,Zero,Overflow,\n\tinput [31:0] WBData,\n\toutput [31:0] MemData_Mem,\n\toutput [3:0] Rd_write_byte_en,\n\toutput RegWriteValid,\n\toutput BranchValid,\n\toutput [3:0]Mem_write_byte_en\n);\nwire [31:0] Mem_data_in;\nwire [31:0] Mem_data_out;\nConditionCheck ConditionCheck(Condition,Branch,RegWrite,Less,Zero,Overflow,BranchValid,RegWriteValid);\nreg_shifter reg_shifter(MemData,WBData[1:0],MemWrite,Op,Mem_data_in,Mem_write_byte_en);\nMem Mem(Mem_write_byte_en,clk,Mem_data_in,WBData,Mem_data_out);\nmem_shifter mem_shifter(Mem_data_out,WBData[1:0],Op,MemData_Mem,Rd_write_byte_en);\nendmodule\n\nmodule ConditionCheck(\n\tinput [2:0] Condition,\n\tinput Branch,\n\tinput RegWrite,\n\tinput Less,Zero,Overflow,\n\toutput reg BranchValid,RegWriteValid\n);\n\nalways @(*)\nbegin\nif(Branch==0)\nBranchValid=0;\nelse\nbegin\ncase(Condition)\n3'b000:\nBranchValid=0;\n3'b001:\nBranchValid=Zero;\n3'b010:\nBranchValid=~Zero;\n3'b011:\nBranchValid=Less|Zero;3'b100:\nBranchValid=Less;3'b101:\nBranchValid=~Less;3'b110:\nBranchValid=~(Less|Zero);3'b111:\nBranchValid=0;\nendcase\nend\n\nif(RegWrite==0)\nRegWriteValid=0;\nelse if(Overflow==1)\nRegWriteValid=0;\nelse\nRegWriteValid=1;\nend\nendmodule\nmodule reg_shifter(\n\tinput [31:0] rt_out,\n\tinput\t[1:0] mem_addr_in,\n\tinput\tMemWrite,\n\tinput [5:0] IR_out,\n\toutput reg [31:0] rt_out_shift,\n\toutput reg [3:0] mem_byte_write_out\n);\nreg [3:0]mem_byte_write;\nalways @ (*)\nbegin\n\tif (IR_out == 6'b101011) begin rt_out_shift = rt_out;mem_byte_write=4'b1111;end\n\telse begin\n\t\tcase (mem_addr_in)\n\t\t\t2'b00: begin rt_out_shift = {rt_out[7:0],  24'b0};mem_byte_write=4'b1000;end\n\t\t\t2'b01: begin rt_out_shift = {rt_out[15:0], 16'b0};mem_byte_write=4'b1100;end\n\t\t\t2'b10: begin rt_out_shift = {rt_out[23:0], 8'b0};mem_byte_write=4'b1110;end\n\t\t\t2'b11: begin rt_out_shift = rt_out;mem_byte_write=4'b1111;end\n\t\tendcase\n\tend\n\tmem_byte_write_out = mem_byte_write & {4{MemWrite}};\nend\n\nendmodule\n\n\n\n\nmodule mem_shifter(\n\tinput [31:0] mem_data_out,\n\tinput\t[1:0] mem_addr_in,\n\tinput [5:0] IR_out,\n\toutput reg [31:0] mem_data_shift,\n\toutput reg [3:0] Rd_write_byte_en\n);\n\nalways @ (*)\nbegin\n\tif (IR_out == 6'b100011)begin\n\t\tmem_data_shift = mem_data_out;\n\t\tRd_write_byte_en=4'b1111;\n\tend\n\telse begin\n\t\tcase (mem_addr_in)\n\t\t\t2'b00: begin mem_data_shift = mem_data_out; Rd_write_byte_en=4'b1111;end\n\t\t\t2'b01: begin mem_data_shift = {mem_data_out[23:0], 8'b0};Rd_write_byte_en=4'b1110; end\n\t\t\t2'b10: begin mem_data_shift = {mem_data_out[15:0], 16'b0};Rd_write_byte_en=4'b1100; end\n\t\t\t2'b11: begin mem_data_shift = {mem_data_out[7:0],  24'b0};Rd_write_byte_en=4'b1000; end\n\t\tendcase\n\tend\nend\n\nendmodule\n\nmodule Mem(\n\tinput [3:0]Mem_byte_wr_in,\n\tinput clk,\n\tinput [31:0]Mem_data,\n\tinput [31:0]Mem_addr_in,\n\toutput reg [31:0]Mem_data_out\n);\nreg [31:0]addr;\ninteger i;\nreg [7:0] IR_reg [500:0];\ninitial\nbegin\nfor(i=0;i<=500;i=i+1) IR_reg[i]=8'b0;\nIR_reg[256] = 8'b10011000;\nIR_reg[257] = 8'b10010110;\nIR_reg[258] = 8'b10011100;\nIR_reg[259] = 8'b11001110;\nend\nalways@(posedge clk)\nbegin\naddr = {Mem_addr_in[31:2],2'b00};\nif(Mem_byte_wr_in[3])\n\tIR_reg[addr+3]<=Mem_data[31:24];\nif(Mem_byte_wr_in[2])\n\tIR_reg[addr+2]<=Mem_data[23:16];\nif(Mem_byte_wr_in[1])\n\tIR_reg[addr+1]<=Mem_data[15:8];\nif(Mem_byte_wr_in[0])\n\tIR_reg[addr]<=Mem_data[7:0];\nif(addr >= 496)\n\t\tMem_data_out <= 32'h00000000;\nelse begin\n\tMem_data_out[31:24]<=IR_reg[addr + 3];\n\tMem_data_out[23:16]<=IR_reg[addr+2];\n\tMem_data_out[15:8]<=IR_reg[addr+1];\n\tMem_data_out[7:0]<=IR_reg[addr];\nend\nend\nendmodule\n\n\n",
        "module_name": "MEM",
        "module_hash": "3402c59218660624a845d8568eb6d685",
        "dataset_index": 22455
      },
      "fifo_64bit_f77a41e7": {
        "rtl_code": "module fifo_64bit\n(\n    input wire clk,\n    input wire rst,\n    input wire wr_en,\n    input wire rd_en,\n    input wire [8:0] din,\n    output wire [8:0] dout,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] mem [63:0];\n    reg [5:0] wr_ptr = 0;\n    reg [5:0] rd_ptr = 0;\n    reg [5:0] count = 0;\n    wire [5:0] next_wr_ptr;\n    wire [5:0] next_rd_ptr;\n    wire [5:0] next_count;\n\n    assign full = (count == 64);\n    assign empty = (count == 0);\n    assign dout = mem[rd_ptr];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            wr_ptr <= 0;\n            rd_ptr <= 0;\n            count <= 0;\n        end else begin\n            if (wr_en && !full) begin\n                mem[wr_ptr] <= din;\n                wr_ptr <= next_wr_ptr;\n                count <= next_count;\n            end\n\n            if (rd_en && !empty) begin\n                rd_ptr <= next_rd_ptr;\n                count <= next_count;\n            end\n        end\n    end\n\n    assign next_wr_ptr = (wr_ptr == 63) ? 0 : wr_ptr + 1;\n    assign next_rd_ptr = (rd_ptr == 63) ? 0 : rd_ptr + 1;\n    assign next_count = (wr_en && !full) ? count + 1 :\n                        (rd_en && !empty) ? count - 1 :\n                        count;\n\nendmodule",
        "module_name": "fifo_64bit",
        "module_hash": "f77a41e752e3416215f871e2ba274ee2",
        "dataset_index": 12330
      },
      "FFType_546_cdab09e0": {
        "rtl_code": "\nmodule FFType_546(\n  input         clock,\n  input         reset,\n  input  [39:0] io_in,\n  output [39:0] io_out,\n  input         io_enable\n);\n\n  // Register flip-flops\n  reg [39:0] ff_reg;\n\n  // Combinational logic\n  assign io_out = (io_enable) ? ff_reg : io_in;\n\n  // Sequential logic\n  always @(posedge clock) begin\n    if (reset) begin\n      ff_reg <= 0;\n    end else begin\n      if (io_enable) begin\n        ff_reg <= io_in;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "FFType_546",
        "module_hash": "cdab09e0510899d8e39bbd74daeb0e2c",
        "dataset_index": 9598
      },
      "and4b_8fbae110": {
        "rtl_code": "module and4b (\n    X,\n    A_N,\n    B,\n    C,\n    D\n);\n\n    // Module ports\n    output X;\n    input A_N;\n    input B;\n    input C;\n    input D;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire not0_out;\n    wire and0_out;\n    wire and1_out;\n\n    //  Name  Output      Other arguments\n    not not0 (not0_out, A_N);\n    and and0 (and0_out, B, C);\n    and and1 (and1_out, not0_out, D, and0_out);\n    buf buf0 (X, and1_out);\n\nendmodule",
        "module_name": "and4b",
        "module_hash": "8fbae11000acad2df1eca28441a13d1c",
        "dataset_index": 20414
      },
      "adder_f545ac1b": {
        "rtl_code": "module adder (\n    input [15:0] A,\n    input [15:0] B,\n    input CIN,\n    output [15:0] SUM,\n    output COUT\n);\n\n    assign {COUT, SUM} = A + B + CIN;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "f545ac1bb67f4e58a0ca0043b8b5dbbe",
        "dataset_index": 12366
      },
      "fifo_counter_ef8d3f6b": {
        "rtl_code": "module fifo_counter (\n  input empty,\n  input free2,\n  input free3,\n  input [1:0] tm_count,\n  output reg [4:0] fifocount_inc\n);\n\n  always @(*) begin\n    if (empty) begin\n      fifocount_inc = tm_count[1:0];\n    end else if (free3 && (tm_count == 2'b11)) begin\n      fifocount_inc = 2;\n    end else if (free2 && (tm_count >= 2)) begin\n      fifocount_inc = 1;\n    end else if (tm_count >= 1) begin\n      fifocount_inc = 0;\n    end else begin\n      fifocount_inc = 5'b11111;\n    end\n  end\n\nendmodule",
        "module_name": "fifo_counter",
        "module_hash": "ef8d3f6bfd542dd80f8a0b4c9ed1f995",
        "dataset_index": 10989
      },
      "dual_port_ram_382c4cfe": {
        "rtl_code": "\nmodule dual_port_ram(\n    input clk,\n    input [15:0] data_in,\n    input [10:0] write_addr,\n    input write_en,\n    input [10:0] read_addr,\n    input read_en,\n    output reg [15:0] data_out\n);\n\n    // Instantiate a generic dual-port RAM model\n    reg [15:0] ram[0:2047];\n\n    always @(posedge clk) begin\n        if (write_en) begin\n            ram[write_addr] <= data_in;\n        end\n        if (read_en) begin\n            data_out <= ram[read_addr];\n        end\n    end\n\nendmodule\n",
        "module_name": "dual_port_ram",
        "module_hash": "382c4cfe9c3bd2a8781b57faf27e3190",
        "dataset_index": 18520
      },
      "smart_unit_f7d9cfab": {
        "rtl_code": "module smart_unit ( inst_out , addr_d1 , addr_d2 , addr_inst ,  \n                 W_d1 , W_d2 , Dout_d1 , Dout_d2 , apxy_CEN , inst_nxt , \n\t\t\t\t\t\t\t\t clk , rst_n , inst_in , ready_hy , hy_exe ,  \n\t\t\t\t\t\t\t\t Din_c1 , Din_c2 , Din_hy\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\nparameter inst_num = 31;\n\nparameter mov     = 5'h7;\nparameter set     = 5'h9;\nparameter jump    = 5'ha;\n\n\nparameter mode_i = 1'b0;\nparameter mode_q = 1'b1;\noutput [inst_num-1:0] inst_out ;\noutput [  4:0] addr_d1 , addr_d2;\nreg    [  4:0] addr_d1 , addr_d2;\noutput [ 15:0] addr_inst;\nreg    [ 15:0] addr_inst;\noutput [255:0] Dout_d1 , Dout_d2;\nreg    [255:0] Dout_d1 , Dout_d2;\noutput W_d1 , W_d2;\nreg    W_d1 , W_d2;\noutput apxy_CEN;\noutput [inst_num-1:0] inst_nxt;\n\ninput  clk , rst_n , ready_hy , hy_exe; \ninput  [inst_num-1:0] inst_in;\ninput  [255:0] Din_c1 , Din_c2 , Din_hy;\nreg [inst_num-1:0] inst_out_next;\nreg [inst_num-1:0] inst_1 , inst_2 , inst_1_next , inst_2_next;\nreg [15:0] addr_inst_next;\nreg [ 4:0] counter , counter_next;\nreg [ 6:0] counter_jump , counter_jump_next;\n\nwire hy_WB = inst_out[6];\nwire hy_W_bank = inst_out[5];\nwire [4:0] comp_type_1  = inst_1[30:26];\nwire [6:0] j_counter_1  = inst_1[25:19]; \nwire [4:0] hy_addr_A  = inst_out[23:19];\nwire [4:0] hy_addr_X  = inst_out[14:10];\nwire [4:0] hy_addr_WB = inst_out[4 : 0];\n\n\nwire [4:0] addr_A_in = inst_in[23:19];\nwire [4:0] addr_X_in = inst_in[14:10];\nwire [4:0] comp_type_i = inst_in[30:26];\nwire [6:0] j_counter_i = inst_in[25:19];\n\n\nwire [4:0] addr_A_1 = inst_1[23:19];\nwire [4:0] addr_X_1 = inst_1[14:10];\n\nwire [4:0] addr_A_cur = inst_2[23:19];\nwire [4:0] addr_X_cur = inst_2[14:10];\n\nwire [4:0] mov_addr_A = inst_1[24:20];\nwire [4:0] mov_addr_X = inst_1[24:20];\nwire [4:0] mov_addr_WB = inst_1[18:14];\n\nassign inst_out = inst_2;\nassign apxy_CEN = (addr_inst>5'd2 && hy_exe==1'b1 ) ? 1'b1 : 1'b0;\nassign inst_nxt = inst_1;\n\nalways @ ( posedge clk or negedge rst_n ) begin\n\tif ( rst_n==1'b0 ) begin\n\t\tinst_1   <= 31'd0;\n\t\tinst_2   <= 31'd0;\n\t\tcounter  <= 5'd0;\n\t\tcounter_jump <= 7'd0;\n\tend\n\telse begin\n\t\tinst_1   <= inst_1_next;inst_2   <= inst_2_next;counter  <= counter_next;\n\t\tcounter_jump <= counter_jump_next;\n\tend\nend\nalways @ ( negedge clk or negedge rst_n ) begin\n\tif ( rst_n==1'b0 ) begin\n\t\taddr_inst<= 16'd0;\n\tend\n\telse begin\n\t\taddr_inst<= addr_inst_next;\n\tend\nend\n\nalways @ (*) begin\n\tif (hy_exe==1'b0)\n\t\taddr_inst_next = addr_inst;\n\telse if ( comp_type_i==jump ) if (counter_jump==7'd0)\n\t\t\taddr_inst_next = addr_inst + 5'd1;\n\t\telse\n\t\t\taddr_inst_next = addr_inst - j_counter_i ;\n\telse if (ready_hy==1'b1 || addr_inst<5'd3 || comp_type_1==set)\n\t\taddr_inst_next = addr_inst + 5'd1 ;\n\telse if (comp_type_1==mov)\n\t\taddr_inst_next = (counter==5'd1) ? addr_inst+5'd1 : addr_inst;\n\telse\n\t\taddr_inst_next = addr_inst;\nend\n\nalways @ (*) begin\n\tinst_1_next = ( (ready_hy==1'b1 || addr_inst<5'd3) && hy_exe==1'b1 ) ? inst_in : inst_1;\n\tinst_2_next = ( (ready_hy==1'b1 || addr_inst<5'd3) && hy_exe==1'b1 ) ? inst_1 : inst_2;\n\tcase (comp_type_1)\n\t\tmov : begin\n\t\t\tif ( hy_WB==1'b1 && ready_hy==1'b1 ) begin\n\t\t\t\tcounter_next = counter;\n\t\t\t\tif (hy_W_bank==1'b1) begin\n\t\t\t\t\tW_d1 = 1'b1;\n\t\t\t\t\tW_d2 = 1'b0;\n\t\t\t\t\taddr_d1 = addr_A_in;\n\t\t\t\t\taddr_d2 = hy_addr_WB;\n\t\t\t\t\tDout_d1 = Din_hy;\n\t\t\t\t\tDout_d2 = Din_hy;\n\t\t\t\tend\n\t\t\t\telse begin \n\t\t\t\t\tW_d1 = 1'b0;\n\t\t\t\t\tW_d2 = 1'b1;\n\t\t\t\t\taddr_d1 = hy_addr_WB;\n\t\t\t\t\taddr_d2 = addr_X_in;\n\t\t\t\t\tDout_d1 = Din_hy;\n\t\t\t\t\tDout_d2 = Din_hy;\t\n\t\t\t\tend\t\n\t\t\tend\n\t\t\telse if (counter==5'd1) begin\n\t\t\t\tcounter_next = 5'd0;\n\t\t\t\tW_d1 = inst_1[19];\n\t\t\t\tW_d2 = ~inst_1[19];\n\t\t\t\taddr_d1 = mov_addr_WB;\n\t\t\t\taddr_d2 = mov_addr_WB;\n\t\t\t\tif (inst_1[25]) begin\n\t\t\t\t\tDout_d1 = Din_c2;\n\t\t\t\t\tDout_d2 = Din_c2;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tDout_d1 = Din_c1;\n\t\t\t\t\tDout_d2 = Din_c1;\n\t\t\t\tend\n\t\t\t\tinst_1_next = inst_in;\n\t\t\t\tinst_2_next = inst_2;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tcounter_next = 5'd1;\n\t\t\t\tW_d1 = 1'b1;\n\t\t\t\tW_d2 = 1'b1;\n\t\t\t\taddr_d1 = mov_addr_A;\n\t\t\t\taddr_d2 = mov_addr_X;\n\t\t\t\tDout_d1 = 256'd0;\n\t\t\t\tDout_d2 = 256'd0;\n\t\t\tend\n\t\t\tcounter_jump_next = counter_jump;\n\t\tend\n\t\tdefault : begin\n\t\t\tif (comp_type_1==set)\n\t\t\t\tcounter_jump_next = j_counter_1;\n\t\t\telse if (comp_type_i==jump && counter_jump!=7'd0)\n\t\t\t\tcounter_jump_next = counter_jump-7'd1;\n\t\t\telse\n\t\t\t\tcounter_jump_next = counter_jump;\n\t\t\tcounter_next = 5'd0;\n\t\t\t\n\t\t\tif (comp_type_1==set ) begin\n\t\t\t\tinst_1_next = inst_in;\n\t\t\t\tinst_2_next = 31'd0;\n\t\t\tend\n\t\t\tif (comp_type_i==jump) begin\n\t\t\t\tinst_1_next = 31'd0;\n\t\t\tend\n\t\t\t\n\t\t\t\n\t\t\tif ( hy_WB==1'b1 && ready_hy==1'b1 ) begin\n\t\t\t\tif (hy_W_bank==1'b1) begin\n\t\t\t\t\taddr_d2 = hy_addr_WB;\n\t\t\t\t\tDout_d2  = Din_hy;\n\t\t\t\t\tW_d2 = 1'b0;\n\t\t\t\t\tW_d1 = 1'b1;\n\t\t\t\t\taddr_d1 = (ready_hy==1'b1) ? addr_A_in : addr_A_1;\n\t\t\t\t\tDout_d1 = 256'd0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\taddr_d2 = (ready_hy==1'b1) ? addr_X_in : addr_X_1;\n\t\t\t\t\tDout_d2  = 256'd0;\n\t\t\t\t\tW_d2 = 1'b1;\n\t\t\t\t\tW_d1 = 1'b0;\n\t\t\t\t\taddr_d1 = hy_addr_WB;\n\t\t\t\t\tDout_d1 = Din_hy;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tend\n\t\t\telse begin\n\t\t\t\taddr_d2 = (ready_hy==1'b1) ? addr_X_in : addr_X_1;\n\t\t\t\tDout_d2  = 256'd0;\n\t\t\t\tW_d2 = 1'b1;\n\t\t\t\tW_d1 = 1'b1;\n\t\t\t\taddr_d1 = (ready_hy==1'b1) ? addr_A_in : addr_A_1;\n\t\t\t\tDout_d1 = 256'd0;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule\n\n\t\t\t\t\t\t\t",
        "module_name": "smart_unit",
        "module_hash": "f7d9cfab8b42cc166bb7537f498d1533",
        "dataset_index": 20764
      },
      "reset_sync_e8c0381b": {
        "rtl_code": "module reset_sync(\n    input reset_n,\n    input clk,\n    output [NUM_RESET_OUTPUT-1:0] reset_n_sync\n);\n\n//Global parameters\nparameter RESET_SYNC_STAGES = 4;\nparameter NUM_RESET_OUTPUT = 1;\n\nreg [RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:0] reset_reg ;\n\ngenerate\ngenvar i;\nfor (i=0; i<RESET_SYNC_STAGES+NUM_RESET_OUTPUT-1; i=i+1) begin: reset_stage\n    always @(posedge clk or negedge reset_n) begin\n        if (~reset_n) begin\n            reset_reg[i] <= 1'b0;\n        end else begin\n            if (i==0) begin\n                reset_reg[i] <= 1'b1;\n            end else if (i < RESET_SYNC_STAGES) begin\n                reset_reg[i] <= reset_reg[i-1];\n            end else begin\n                reset_reg[i] <= reset_reg[RESET_SYNC_STAGES-2];\n            end\n        end\n    end\nend\nendgenerate\n\nassign reset_n_sync = reset_reg[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:RESET_SYNC_STAGES-1];\n\nendmodule",
        "module_name": "reset_sync",
        "module_hash": "e8c0381b9d37c77b3f620fc9e6c268f1",
        "dataset_index": 17423
      },
      "add_sub_4bit_c937b91e": {
        "rtl_code": "module add_sub_4bit (A, B, sub, CK, Y, Cout);\ninput [3:0] A, B;\ninput sub, CK;\noutput [3:0] Y;\noutput Cout;\nreg [3:0] Y_reg;\nwire [3:0] B_neg;\nwire [3:0] B_sub;\nwire [4:0] Y_add;\n\n// Invert B and add 1 to obtain two's complement of B\nassign B_neg = ~B + 1;\n\n// Select either B or B_neg based on sub input\nassign B_sub = (sub) ? B_neg : B;\n\n// Add A and B_sub\nassign Y_add = {1'b0, A} + {1'b0, B_sub};\n\n// Register the sum/difference output\nalways @(posedge CK) begin\n    Y_reg <= Y_add[3:0];\nend\n\n// Output the sum/difference and carry/borrow\nassign Y = Y_reg;\nassign Cout = Y_add[4];\n\nendmodule",
        "module_name": "add_sub_4bit",
        "module_hash": "c937b91ed2270df6836b298157c767c2",
        "dataset_index": 3549
      },
      "vga_double_68ad71b7": {
        "rtl_code": "module vga_double(\n\n\tinput  wire        clk,\n\n\tinput  wire        hsync_start,\n\n\tinput  wire        scanin_start,\n\tinput  wire [ 5:0] pix_in,\n\n\tinput  wire        scanout_start,\n\toutput reg  [ 5:0] pix_out\n);\n\n\n\n\treg [9:0] ptr_in;  reg [9:0] ptr_out; reg pages; reg wr_stb;\n\n\twire [ 7:0] data_out;\n\n\n\talways @(posedge clk) if( hsync_start )\n\t\tpages <= ~pages;\n\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( scanin_start )\n\t\tbegin\n\t\t\tptr_in[9:8] <= 2'b00;\n\t\t\tptr_in[5:4] <= 2'b11;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif( ptr_in[9:8]!=2'b11 ) begin\n\t\t\t\twr_stb <= ~wr_stb;\n\t\t\t\tif( wr_stb )\n\t\t\t\tbegin\n\t\t\t\t\tptr_in <= ptr_in + 10'd1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( scanout_start )\n\t\tbegin\n\t\t\tptr_out[9:8] <= 2'b00;\n\t\t\tptr_out[5:4] <= 2'b11;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif( ptr_out[9:8]!=2'b11 )\n\t\t\tbegin\n\t\t\t\tptr_out <= ptr_out + 10'd1;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( ptr_out[9:8]!=2'b11 )\n\t\t\tpix_out <= data_out[5:0];\n\t\telse\n\t\t\tpix_out <= 6'd0;\n\tend\n\n\n\n\n\n\tmem1536 line_buf( .clk(clk),\n\n\t                  .wraddr({ptr_in[9:8], pages, ptr_in[7:0]}),\n\t                  .wrdata({2'b00,pix_in}),\n\t                  .wr_stb(wr_stb),\n\n\t                  .rdaddr({ptr_out[9:8], (~pages), ptr_out[7:0]}),\n\t                  .rddata(data_out)\n\t                );\n\n\nendmodule\n\n\n\n\nmodule mem1536(\n\n\tinput  wire        clk,\n\n\tinput  wire [10:0] wraddr,\n\tinput  wire [ 7:0] wrdata,\n\tinput  wire        wr_stb,\n\n\tinput  wire [10:0] rdaddr,\n\toutput reg  [ 7:0] rddata\n);\n\n\treg [7:0] mem [0:1535];\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( wr_stb )\n\t\tbegin\n\t\t\tmem[wraddr] <= wrdata;\n\t\tend\n\n\t\trddata <= mem[rdaddr];\n\tend\n\n\nendmodule\n\n",
        "module_name": "vga_double",
        "module_hash": "68ad71b730a8a5ae4f3246954bee555c",
        "dataset_index": 8595
      },
      "priority_encoder_mux_baf8c357": {
        "rtl_code": "module priority_encoder_mux(\n    input [7:0] in,\n    input [2047:0] mux_in,\n    input [7:0] sel,\n    input [1:0] enable,\n    output [2:0] pos,\n    output [7:0] out1,\n    output [7:0] out2,\n    output [7:0] out3,\n    output [7:0] out4\n);\n\n// Priority encoder\nwire [7:0] in_priority = ~in;\nwire [7:0] in_priority_shifted = {in_priority[6:0], 1'b0};\nwire [7:0] in_priority_or = in_priority | in_priority_shifted;\nwire [7:0] in_priority_or_shifted = {in_priority_or[5:0], 2'b0};\nwire [7:0] in_priority_or_or = in_priority_or | in_priority_or_shifted;\nwire [7:0] in_priority_or_or_shifted = {in_priority_or_or[3:0], 4'b0};\nwire [7:0] in_priority_or_or_or = in_priority_or_or | in_priority_or_or_shifted;\nwire [7:0] in_priority_or_or_or_shifted = {in_priority_or_or_or[1:0], 6'b0};\nwire [7:0] in_priority_or_or_or_or = in_priority_or_or_or | in_priority_or_or_or_shifted;\nassign pos = in_priority_or_or_or_or[7:5] - 1;\n\n// Multiplexer\nwire [7:0] mux_out;\nassign mux_out = mux_in[sel*8 +: 8];\n\n// Decoder\nwire [3:0] enable_decoded;\nassign enable_decoded = (enable == 2'b00) ? 4'b0001 :\n                       (enable == 2'b01) ? 4'b0010 :\n                       (enable == 2'b10) ? 4'b0100 :\n                       (enable == 2'b11) ? 4'b1000 : 4'b0000;\n\n// Output\nassign out1 = (enable_decoded[0]) ? mux_out : 8'b0;\nassign out2 = (enable_decoded[1]) ? mux_out : 8'b0;\nassign out3 = (enable_decoded[2]) ? mux_out : 8'b0;\nassign out4 = (enable_decoded[3]) ? mux_out : 8'b0;\n\nendmodule",
        "module_name": "priority_encoder_mux",
        "module_hash": "baf8c357cc4115baea8ad0bd8a5e0c77",
        "dataset_index": 1337
      },
      "wb_async_reg #_d4f5e160": {
        "rtl_code": "\n\n\nmodule wb_async_reg #\n(\n    parameter DATA_WIDTH = 32,                  parameter ADDR_WIDTH = 32,                  parameter SELECT_WIDTH = (DATA_WIDTH/8)     )\n(\n    input  wire                    wbm_clk,\n    input  wire                    wbm_rst,\n    input  wire [ADDR_WIDTH-1:0]   wbm_adr_i,   input  wire [DATA_WIDTH-1:0]   wbm_dat_i,   output wire [DATA_WIDTH-1:0]   wbm_dat_o,   input  wire                    wbm_we_i,    input  wire [SELECT_WIDTH-1:0] wbm_sel_i,   input  wire                    wbm_stb_i,   output wire                    wbm_ack_o,   output wire                    wbm_err_o,   output wire                    wbm_rty_o,   input  wire                    wbm_cyc_i,   input  wire                    wbs_clk,\n    input  wire                    wbs_rst,\n    output wire [ADDR_WIDTH-1:0]   wbs_adr_o,   input  wire [DATA_WIDTH-1:0]   wbs_dat_i,   output wire [DATA_WIDTH-1:0]   wbs_dat_o,   output wire                    wbs_we_o,    output wire [SELECT_WIDTH-1:0] wbs_sel_o,   output wire                    wbs_stb_o,   input  wire                    wbs_ack_i,   input  wire                    wbs_err_i,   input  wire                    wbs_rty_i,   output wire                    wbs_cyc_o    );\n\nreg [ADDR_WIDTH-1:0] wbm_adr_i_reg = 0;\nreg [DATA_WIDTH-1:0] wbm_dat_i_reg = 0;\nreg [DATA_WIDTH-1:0] wbm_dat_o_reg = 0;\nreg wbm_we_i_reg = 0;\nreg [SELECT_WIDTH-1:0] wbm_sel_i_reg = 0;\nreg wbm_stb_i_reg = 0;\nreg wbm_ack_o_reg = 0;\nreg wbm_err_o_reg = 0;\nreg wbm_rty_o_reg = 0;\nreg wbm_cyc_i_reg = 0;\n\nreg wbm_done_sync1 = 0;\nreg wbm_done_sync2 = 0;\nreg wbm_done_sync3 = 0;\n\nreg [ADDR_WIDTH-1:0] wbs_adr_o_reg = 0;\nreg [DATA_WIDTH-1:0] wbs_dat_i_reg = 0;\nreg [DATA_WIDTH-1:0] wbs_dat_o_reg = 0;\nreg wbs_we_o_reg = 0;\nreg [SELECT_WIDTH-1:0] wbs_sel_o_reg = 0;\nreg wbs_stb_o_reg = 0;\nreg wbs_ack_i_reg = 0;\nreg wbs_err_i_reg = 0;\nreg wbs_rty_i_reg = 0;\nreg wbs_cyc_o_reg = 0;\n\nreg wbs_cyc_o_sync1 = 0;\nreg wbs_cyc_o_sync2 = 0;\nreg wbs_cyc_o_sync3 = 0;\n\nreg wbs_stb_o_sync1 = 0;\nreg wbs_stb_o_sync2 = 0;\nreg wbs_stb_o_sync3 = 0;\n\nreg wbs_done_reg = 0;\n\nassign wbm_dat_o = wbm_dat_o_reg;\nassign wbm_ack_o = wbm_ack_o_reg;\nassign wbm_err_o = wbm_err_o_reg;\nassign wbm_rty_o = wbm_rty_o_reg;\n\nassign wbs_adr_o = wbs_adr_o_reg;\nassign wbs_dat_o = wbs_dat_o_reg;\nassign wbs_we_o = wbs_we_o_reg;\nassign wbs_sel_o = wbs_sel_o_reg;\nassign wbs_stb_o = wbs_stb_o_reg;\nassign wbs_cyc_o = wbs_cyc_o_reg;\n\nalways @(posedge wbm_clk) begin\n    if (wbm_rst) begin\n        wbm_adr_i_reg <= 0;\n        wbm_dat_i_reg <= 0;\n        wbm_dat_o_reg <= 0;\n        wbm_we_i_reg <= 0;\n        wbm_sel_i_reg <= 0;\n        wbm_stb_i_reg <= 0;\n        wbm_ack_o_reg <= 0;\n        wbm_err_o_reg <= 0;\n        wbm_rty_o_reg <= 0;\n        wbm_cyc_i_reg <= 0;\n    end else begin\n        if (wbm_cyc_i_reg & wbm_stb_i_reg) begin\n            if (wbm_done_sync2 & ~wbm_done_sync3) begin\n                wbm_dat_o_reg <= wbs_dat_i_reg;\n                wbm_ack_o_reg <= wbs_ack_i_reg;\n                wbm_err_o_reg <= wbs_err_i_reg;\n                wbm_rty_o_reg <= wbs_rty_i_reg;\n                wbm_we_i_reg <= 0;\n                wbm_stb_i_reg <= 0;\n            end\n        end else begin\n            wbm_adr_i_reg <= wbm_adr_i;\n            wbm_dat_i_reg <= wbm_dat_i;\n            wbm_dat_o_reg <= 0;\n            wbm_we_i_reg <= wbm_we_i & ~(wbm_ack_o | wbm_err_o | wbm_rty_o);\n            wbm_sel_i_reg <= wbm_sel_i;\n            wbm_stb_i_reg <= wbm_stb_i & ~(wbm_ack_o | wbm_err_o | wbm_rty_o);\n            wbm_ack_o_reg <= 0;\n            wbm_err_o_reg <= 0;\n            wbm_rty_o_reg <= 0;\n            wbm_cyc_i_reg <= wbm_cyc_i;\n        end\n    end\n\n    wbm_done_sync1 <= wbs_done_reg;\n    wbm_done_sync2 <= wbm_done_sync1;\n    wbm_done_sync3 <= wbm_done_sync2;\nend\n\nalways @(posedge wbs_clk) begin\n    if (wbs_rst) begin\n        wbs_adr_o_reg <= 0;\n        wbs_dat_i_reg <= 0;\n        wbs_dat_o_reg <= 0;\n        wbs_we_o_reg <= 0;\n        wbs_sel_o_reg <= 0;\n        wbs_stb_o_reg <= 0;\n        wbs_ack_i_reg <= 0;\n        wbs_err_i_reg <= 0;\n        wbs_rty_i_reg <= 0;\n        wbs_cyc_o_reg <= 0;\n        wbs_done_reg <= 0;\n    end else begin\n        if (wbs_ack_i | wbs_err_i | wbs_rty_i) begin\n            wbs_dat_i_reg <= wbs_dat_i;\n            wbs_ack_i_reg <= wbs_ack_i;\n            wbs_err_i_reg <= wbs_err_i;\n            wbs_rty_i_reg <= wbs_rty_i;\n            wbs_we_o_reg <= 0;\n            wbs_stb_o_reg <= 0;\n            wbs_done_reg <= 1;\n        end else if (wbs_stb_o_sync2 & ~wbs_stb_o_sync3) begin\n            wbs_adr_o_reg <= wbm_adr_i_reg;\n            wbs_dat_i_reg <= 0;\n            wbs_dat_o_reg <= wbm_dat_i_reg;\n            wbs_we_o_reg <= wbm_we_i_reg;\n            wbs_sel_o_reg <= wbm_sel_i_reg;\n            wbs_stb_o_reg <= wbm_stb_i_reg;\n            wbs_ack_i_reg <= 0;\n            wbs_err_i_reg <= 0;\n            wbs_rty_i_reg <= 0;\n            wbs_cyc_o_reg <= wbm_cyc_i_reg;\n            wbs_done_reg <= 0;\n        end else if (~wbs_cyc_o_sync2 & wbs_cyc_o_sync3) begin\n            wbs_adr_o_reg <= 0;\n            wbs_dat_i_reg <= 0;\n            wbs_dat_o_reg <= 0;\n            wbs_we_o_reg <= 0;\n            wbs_sel_o_reg <= 0;\n            wbs_stb_o_reg <= 0;\n            wbs_ack_i_reg <= 0;\n            wbs_err_i_reg <= 0;\n            wbs_rty_i_reg <= 0;\n            wbs_cyc_o_reg <= 0;\n            wbs_done_reg <= 0;\n        end\n    end\n\n    wbs_cyc_o_sync1 <= wbm_cyc_i_reg;\n    wbs_cyc_o_sync2 <= wbs_cyc_o_sync1;\n    wbs_cyc_o_sync3 <= wbs_cyc_o_sync2;\n\n    wbs_stb_o_sync1 <= wbm_stb_i_reg;\n    wbs_stb_o_sync2 <= wbs_stb_o_sync1;\n    wbs_stb_o_sync3 <= wbs_stb_o_sync2;\nend\n\nendmodule",
        "module_name": "wb_async_reg #",
        "module_hash": "d4f5e160294608d66cafaeecebe2b42d",
        "dataset_index": 23914
      },
      "shift_reg_d_ff_307bf550": {
        "rtl_code": "module shift_reg_d_ff (\n    input clk,\n    input reset,            // Synchronous reset\n    input [7:0] d,\n    input select,           // Control input to choose between shift register and D flip-flop\n    output [7:0] q\n);\n\n    reg [7:0] shift_reg;\n    reg [7:0] d_ff;\n\n    always @(posedge clk, negedge reset) begin\n        if (reset == 1'b0) begin\n            shift_reg <= 8'h34;\n            d_ff <= 8'h34;\n        end else begin\n            if (select == 1'b1) begin\n                shift_reg <= {shift_reg[6:0], d};\n            end else begin\n                d_ff <= d;\n            end\n        end\n    end\n\n    assign q = (select == 1'b1) ? shift_reg : d_ff;\n\nendmodule",
        "module_name": "shift_reg_d_ff",
        "module_hash": "307bf5509f600f1a8af0325243ed419b",
        "dataset_index": 8517
      },
      "tlu_prencoder16_7593d721": {
        "rtl_code": "\nmodule tlu_prencoder16 (din, dout);\n\ninput [15:0] din;\noutput [3:0] dout;\n\nwire [15:0] onehot;\n\ngenvar i;\ngenerate\n  for (i = 0; i < 16; i = i + 1) begin\n    assign onehot[i] = din[i] & ~(|din[i-1:0]);\n  end\nendgenerate\n\nassign dout[3] = |onehot[15:8];\nassign dout[2] = (|onehot[7:4]) | (|onehot[15:12]);\nassign dout[1] = (|onehot[3:2]) | (|onehot[7:6]) | (|onehot[11:10]) | (|onehot[15:14]);\nassign dout[0] = onehot[0] | onehot[1] | onehot[3] | onehot[5] | onehot[7] | onehot[9] | onehot[11] | onehot[13] | onehot[15];\n\nendmodule",
        "module_name": "tlu_prencoder16",
        "module_hash": "7593d721e54bb364faa6801023adc6ab",
        "dataset_index": 12247
      },
      "counter_8a1903c1": {
        "rtl_code": "module counter (\n  input clk,\n  input reset,\n  output reg [3:0] count,\n  output reg p,\n  output reg q\n);\n  \n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n  \n  always @(count) begin\n    p = ^count;\n    q = &count;\n  end\n  \nendmodule\n",
        "module_name": "counter",
        "module_hash": "8a1903c1c46b0d5715331e2f94789587",
        "dataset_index": 9186
      },
      "top__2b466b4b": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input slowena,\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    input [3:0] threshold,\n    output [3:0] count,\n    output high_if_count_greater_than_threshold,\n    output [3:0] final_output\n);\n\n    // Priority Encoder for select signal\n    wire [2:0] sel_priority;\n    priority_encoder pe(sel, sel_priority);\n\n    // 6-to-1 Multiplexer\n    wire [3:0] mux_output;\n    assign mux_output = (sel_priority == 0) ? data0 :\n                        (sel_priority == 1) ? data1 :\n                        (sel_priority == 2) ? data2 :\n                        (sel_priority == 3) ? data3 :\n                        (sel_priority == 4) ? data4 :\n                        (sel_priority == 5) ? data5 :\n                        4'b1; // Output 1 if select signal is outside range\n\n    // 4-bit Binary Up Counter\n    reg [3:0] count_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 4'b0;\n        end else if (slowena) begin\n            count_reg <= count_reg + 1;\n        end\n    end\n    assign count = count_reg;\n\n    // 4-bit Comparator\n    wire [3:0] threshold_value = threshold;\n    assign high_if_count_greater_than_threshold = (count_reg >= threshold_value);\n\n    // Bitwise AND module\n    wire [3:0] and_output;\n    assign and_output = mux_output & high_if_count_greater_than_threshold;\n\n    // Final output\n    assign final_output = and_output;\n\nendmodule\n\n// Priority Encoder module\nmodule priority_encoder (\n    input [2:0] in,\n    output reg [2:0] out\n);\n    always @* begin\n        case (in)\n            3'b000: out = 3'b000;\n            3'b001: out = 3'b001;\n            3'b010: out = 3'b010;\n            3'b011: out = 3'b011;\n            3'b100: out = 3'b100;\n            3'b101: out = 3'b101;\n            default: out = 3'b111; // Output 111 if input is outside range\n        endcase\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "2b466b4bfa35b1ff18acfc1b1abde34c",
        "dataset_index": 9462
      },
      "rotator_adder_36c0c1fa": {
        "rtl_code": "module rotator_adder(\n    input clk,\n    input reset,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [31:0] q\n);\n\nreg [99:0] rotated_data;\nreg [31:0] adder_out;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        rotated_data <= 0;\n        adder_out <= 0;\n    end else begin\n        if (load) begin\n            if (ena == 2'b00) begin\n                rotated_data <= data;\n            end else if (ena == 2'b01) begin\n                rotated_data <= {data[31:0], data[99:32]};\n            end else if (ena == 2'b10) begin\n                rotated_data <= {data[67:0], data[99:68]};\n            end else begin\n                rotated_data <= {data[33:0], data[99:34]};\n            end\n        end\n        \n        adder_out <= rotated_data[31:0] + 32'd12345678;\n        q <= adder_out;\n    end\nend\n\nendmodule",
        "module_name": "rotator_adder",
        "module_hash": "36c0c1fa4833d0fff71d93443a607bb4",
        "dataset_index": 2352
      },
      "dc_rep_upload_98cb2d16": {
        "rtl_code": "module   dc_rep_upload(clk,\n                          rst,\n                          dc_flits_rep,\n                          v_dc_flits_rep,\n                          flits_max,\n                          en_flits_max,\n                          rep_fifo_rdy,\n                          dc_flit_out,\n                          v_dc_flit_out,\n\t\t\t\t\t\t\t\t  dc_ctrl_out,\n                          dc_rep_upload_state\n                          );\ninput                          clk;\ninput                          rst;\ninput         [175:0]          dc_flits_rep;\ninput                          v_dc_flits_rep;\ninput         [3:0]            flits_max;\ninput                          en_flits_max;\ninput                          rep_fifo_rdy;\n                          output        [15:0]            dc_flit_out;\noutput                          v_dc_flit_out;\noutput       [1:0]              dc_ctrl_out;\noutput                          dc_rep_upload_state;\n\nparameter    dc_rep_upload_idle=1'b0;\nparameter    dc_rep_upload_busy=1'b1;\n\nreg          dc_rep_state;\nreg  [175:0]  dc_rep_flits;\nreg  [3:0]   sel_cnt;\nreg          v_dc_flit_out;\nreg          fsm_rst;\nreg          next;\nreg          en_flits_in;\nreg          inc_cnt;\nreg  [3:0]   flits_max_reg;\nreg  [1:0]   dc_ctrl_out;\nassign dc_rep_upload_state=dc_rep_state;\nalways@(*)\nbegin\n  v_dc_flit_out=1'b0;\n  inc_cnt=1'b0;\n  fsm_rst=1'b0;\n  en_flits_in=1'b0;\n  next=1'b0;\n  dc_ctrl_out=2'b00;\n  case(dc_rep_state)\n    dc_rep_upload_idle:\n       begin\n         if(v_dc_flits_rep)\n           begin\n             en_flits_in=1'b1;\n             next=1'b1;\n           end\n       end\n    dc_rep_upload_busy:\n       begin\n         if(rep_fifo_rdy)\n           begin\n             if(sel_cnt==flits_max_reg)\n\t\t\t\t  begin\n               fsm_rst=1'b1;\n\t\t\t\t\tdc_ctrl_out=2'b11;\n\t\t\t\t\tend\n\t\t\t\telse if(sel_cnt==3'b000)\n\t\t\t\t    dc_ctrl_out=2'b01;\n\t\t\t\telse \t \n\t\t\t\t    dc_ctrl_out=2'b10;\n             inc_cnt=1'b1;\n             v_dc_flit_out=1'b1;\n           end\n       end\n    endcase\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    dc_rep_state<=1'b0;\nelse if(next)\n    dc_rep_state<=1'b1;\nend\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    dc_rep_flits<=176'h0000;\n  else if(en_flits_in)\n    dc_rep_flits<=dc_flits_rep;\nend\nreg  [15:0]  dc_flit_out;\nalways@(*)\nbegin\n  case(sel_cnt)\n    4'b0000:dc_flit_out=dc_rep_flits[175:160];\n    4'b0001:dc_flit_out=dc_rep_flits[159:144];\n    4'b0010:dc_flit_out=dc_rep_flits[143:128];\n    4'b0011:dc_flit_out=dc_rep_flits[127:112];\n    4'b0100:dc_flit_out=dc_rep_flits[111:96];\n    4'b0101:dc_flit_out=dc_rep_flits[95:80];\n    4'b0110:dc_flit_out=dc_rep_flits[79:64];\n    4'b0111:dc_flit_out=dc_rep_flits[63:48];\n    4'b1000:dc_flit_out=dc_rep_flits[47:32];\n    4'b1001:dc_flit_out=dc_rep_flits[31:16];\n    4'b1010:dc_flit_out=dc_rep_flits[15:0];\n    default:dc_flit_out=dc_rep_flits[175:160];\n  endcase\nend\n\nalways@(posedge  clk)\nbegin\n  if(rst||fsm_rst)\n    flits_max_reg<=4'b0000;\n  else if(en_flits_max)\n    flits_max_reg<=flits_max;\nend\n    \nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    sel_cnt<=4'b0000;\n  else if(inc_cnt)\n    sel_cnt<=sel_cnt+4'b0001;\nend\n\nendmodule",
        "module_name": "dc_rep_upload",
        "module_hash": "98cb2d16e81819c21dc370938fac08c2",
        "dataset_index": 23198
      },
      "top__d3d7f8ea": {
        "rtl_code": "\nmodule top_module (\n    input [7:0] A,\n    input [7:0] B,\n    input enable,\n    output EQ,\n    output GT,\n    output OR\n);\n\n    wire [7:0] mux_output;\n    wire EQ_int;\n    wire GT_int;\n\n    // 2-to-1 Multiplexer module\n    mux_2to1 mux_inst (\n        .in0(A),\n        .in1(B),\n        .sel(enable),\n        .out(mux_output)\n    );\n\n    // 8-bit Comparator module\n    comp_8bit comp_inst (\n        .A(mux_output),\n        .B(B),\n        .EQ(EQ_int),\n        .GT(GT_int)\n    );\n\n    // OR gate\n    assign OR = EQ_int | GT_int;\n\n    assign EQ = EQ_int;\n    assign GT = GT_int;\n\nendmodule\n\nmodule mux_2to1 (\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if(sel == 0)\n            out = in0;\n        else\n            out = in1;\n    end\nendmodule\n\nmodule comp_8bit (\n    input [7:0] A,\n    input [7:0] B,\n    output EQ,\n    output GT\n);\n\n    assign EQ = (A == B);\n    assign GT = (A > B);\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "d3d7f8eacf80a871e49a1705b44b1c63",
        "dataset_index": 14348
      },
      "fifo_buffer_a5ee2d40": {
        "rtl_code": "\nmodule fifo_buffer(\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input write,\n    output reg [7:0] data_out,\n    input read,\n    output empty,\n    output full\n);\n\n    reg [7:0] buffer [0:15];\n    reg [3:0] head = 0;\n    reg [3:0] tail = 0;\n    reg [3:0] count = 0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            head <= 0;\n            tail <= 0;\n            count <= 0;\n        end else begin\n            if (write && !full) begin\n                buffer[head] <= data_in;\n                head <= (head == 15) ? 0 : head + 1;\n                count <= count + 1;\n            end\n            if (read && !empty) begin\n                data_out <= buffer[tail];\n                tail <= (tail == 15) ? 0 : tail + 1;\n                count <= count - 1;\n            end\n        end\n    end\n\n    assign empty = (count == 0);\n    assign full = (count == 16);\n\nendmodule\n",
        "module_name": "fifo_buffer",
        "module_hash": "a5ee2d406225a16bf837e836fe164e7a",
        "dataset_index": 14805
      },
      "ripple_carry_adder_c5e0600c": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input carry_in,\n    input clk,\n    output [3:0] sum,\n    output carry_out\n);\n\nreg [3:0] A_reg, B_reg, sum_reg;\nreg carry_in_reg, carry_out_reg;\n\nalways @(posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    carry_in_reg <= carry_in;\n    sum_reg <= A_reg + B_reg + carry_in_reg;\n    carry_out_reg <= (A_reg[3] & B_reg[3]) | (A_reg[3] & carry_in_reg) | (B_reg[3] & carry_in_reg);\nend\n\nassign sum = sum_reg;\nassign carry_out = carry_out_reg;\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "c5e0600c0a822b6ac6e4d5280fcebe52",
        "dataset_index": 17385
      },
      "shift_register_4bit_e295e3fe": {
        "rtl_code": "module shift_register_4bit (\n    input [3:0] D,\n    input LD, CLK, CLR,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK or posedge CLR) begin\n        if (CLR) begin\n            Q <= 4'b0000;\n        end else if (LD) begin\n            Q <= D;\n        end else begin\n            Q <= {Q[2:0], Q[3]};\n        end\n    end\n\nendmodule",
        "module_name": "shift_register_4bit",
        "module_hash": "e295e3fedd63de92a58736cc6e70756f",
        "dataset_index": 6477
      },
      "logic__b3f473e2": {
        "rtl_code": "module logic_module (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    output Y\n);\n\n    assign Y = (A1 & A2) | ((A1 & ~B1 & ~B2) & ~(A2 | B1 | B2)) | (~A1 & ~A2 & B1 & B2);\n\nendmodule",
        "module_name": "logic_",
        "module_hash": "b3f473e2b085941e6e151971c943c3fa",
        "dataset_index": 1276
      },
      "add3_526f21ae": {
        "rtl_code": "module add3 (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    output [4:0] S\n);\n\n    wire [4:0] sum1, sum2;\n\n    add2 a1(.A(A), .B(B), .S(sum1));\n    add2 a2(.A(sum1[3:0]), .B(C), .S(sum2));\n    assign S = {sum2[4], sum2[3:0]};\n\nendmodule\n\nmodule add2 (\n    input [3:0] A,\n    input [3:0] B,\n    output [4:0] S\n);\n\n    wire [3:0] sum;\n    wire carry;\n\n    assign sum = A + B;\n    assign carry = (sum >= 10);\n\n    assign S = {carry, sum};\n\nendmodule\n\n",
        "module_name": "add3",
        "module_hash": "526f21ae63994107f81347b1d146ac6c",
        "dataset_index": 6264
      },
      "ports_80f989f2": {
        "rtl_code": "module ports(\n\n\tdin,  dout, busin, a, iorq_n,mreq_n,rd_n,wr_n, data_port_input, data_port_output, command_port_input, data_bit_input, command_bit_input, data_bit_output, command_bit_output,\n\n\tdata_bit_wr, command_bit_wr,\n\n\n\tmode_8chans, mode_pan4ch, mode_ramro, mode_norom,\n\n\tmode_pg0, mode_pg1,\n\n\n\tclksel0, clksel1,\n\n\n\tsnd_wrtoggle, snd_datnvol,  snd_addr,     snd_data,     md_din, md_start,\n\tmd_dreq,\n\tmd_halfspeed,\n\n\tmc_ncs, mc_xrst,\n\tmc_dout,\n\tmc_din,\n\tmc_start,\n\tmc_speed,\n\tmc_rdy,\n\n\tsd_ncs, sd_dout,\n\tsd_din,\n\tsd_start,\n\tsd_det,\n\tsd_wp,\n\n\tled, led_toggle,\n\n\n\trst_n,\n\n\tcpu_clock );\n\n\n\tlocalparam MPAG      = 6'h00;\n\tlocalparam MPAGEX    = 6'h10;\n\n\tlocalparam ZXCMD     = 6'h01;\n\tlocalparam ZXDATRD   = 6'h02;\n\tlocalparam ZXDATWR   = 6'h03;\n\tlocalparam ZXSTAT    = 6'h04;\n\tlocalparam CLRCBIT   = 6'h05;\n\n\tlocalparam VOL1      = 6'h06;\n\tlocalparam VOL2      = 6'h07;\n\tlocalparam VOL3      = 6'h08;\n\tlocalparam VOL4      = 6'h09;\n\tlocalparam VOL5      = 6'h16;\n\tlocalparam VOL6      = 6'h17;\n\tlocalparam VOL7      = 6'h18;\n\tlocalparam VOL8      = 6'h19;\n\n\tlocalparam DAMNPORT1 = 6'h0a;\n\tlocalparam DAMNPORT2 = 6'h0b;\n\n\tlocalparam LEDCTR    = 6'h01;\n\n\tlocalparam GSCFG0    = 6'h0f;\n\n\tlocalparam SCTRL     = 6'h11;\n\tlocalparam SSTAT     = 6'h12;\n\n\tlocalparam SD_SEND   = 6'h13;\n\tlocalparam SD_READ   = 6'h13;\n\tlocalparam SD_RSTR   = 6'h14;\n\n\tlocalparam MD_SEND   = 6'h14; localparam MC_SEND   = 6'h15;\n\tlocalparam MC_READ   = 6'h15;\n\n\n\n\tinput      [7:0] din;\n\toutput reg [7:0] dout;\n\n\toutput reg busin; input [15:0] a;\n\n\tinput iorq_n,mreq_n,rd_n,wr_n;\n\n\tinput      [7:0] data_port_input;\n\tinput      [7:0] command_port_input;\n\toutput reg [7:0] data_port_output;\n\n\tinput data_bit_input;\n\tinput command_bit_input;\n\n\toutput reg data_bit_output;\n\n\toutput reg command_bit_output;\n\n\toutput reg data_bit_wr;\n\n\toutput reg command_bit_wr;\n\n\toutput reg mode_8chans;\n\n\toutput reg mode_pan4ch;\n\n\toutput reg mode_ramro;\n\n\toutput reg mode_norom;\n\n\toutput reg [6:0] mode_pg0;\n\toutput reg [6:0] mode_pg1;\n\n\toutput reg clksel0;\n\toutput reg clksel1;\n\n\n\toutput reg snd_wrtoggle;\n\toutput reg snd_datnvol;\n\toutput reg [2:0] snd_addr;\n\toutput reg [7:0] snd_data;\n\n\n\tinput rst_n;\n\n\tinput cpu_clock;\n\n\n\n\n\toutput [7:0] md_din; output md_start; input md_dreq; output reg md_halfspeed;\n\n\n\toutput reg mc_ncs; output reg mc_xrst; output mc_start; output reg [1:0] mc_speed;\n\t\n\tinput mc_rdy;\n\n\toutput [7:0] mc_din; input [7:0] mc_dout; output reg sd_ncs;\n\n\toutput sd_start;\n\n\toutput [7:0] sd_din;\n\n\tinput [7:0] sd_dout;\n\n\tinput sd_det;\n\n\tinput sd_wp;\n\n\noutput reg led;\n\tinput led_toggle;\n\n\n\nreg mode_expag; reg port09_bit5;\n\n\twire port_enabled; wire mem_enabled; reg volports_enabled; reg iowrn_reg; reg iordn_reg; reg merdn_reg; reg port_wr; reg port_rd;  reg memreg_rd; wire port00_wr;   wire p_ledctr_wr;\n\twire port02_rd;\n\twire port03_wr;\n\twire port05_wrrd;\n\twire port09_wr;\n\twire port0a_wrrd;\n\twire port0b_wrrd;\n\twire port0f_wr;\n\twire port10_wr;\n\n\twire p_sstat_rd;\n\twire p_sctrl_rd;\n\twire p_sctrl_wr;\n\twire p_sdsnd_wr;\n\twire p_sdrd_rd;\n\twire p_sdrst_rd;\n\twire p_mdsnd_wr;\n\twire p_mcsnd_wr;\n\twire p_mcrd_rd;\n\n\treg [2:0] volnum; assign port_enabled = ~(a[7] | a[6]); assign mem_enabled = (~a[15]) & a[14] & a[13]; always @*\n\tbegin\n\t\tif( a[5:0]==VOL1 ||\n\t\t    a[5:0]==VOL2 ||\n\t\t    a[5:0]==VOL3 ||\n\t\t    a[5:0]==VOL4 ||\n\t\t    a[5:0]==VOL5 ||\n\t\t    a[5:0]==VOL6 ||\n\t\t    a[5:0]==VOL7 ||\n\t\t    a[5:0]==VOL8 )\n\n\t\t\tvolports_enabled <= 1'b1;\n\t\telse\n\t\t\tvolports_enabled <= 1'b0;\n\tend\n\n\n\n\talways @*\n\tbegin\n\t\tif( port_enabled && (!iorq_n) && (!rd_n) )\n\t\t\tbusin <= 1'b0; else\n\t\t\tbusin <= 1'b1; end\n\n\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tiowrn_reg <= iorq_n | wr_n;\n\t\tiordn_reg <= iorq_n | rd_n;\n\n\t\tif( port_enabled && (!iorq_n) && (!wr_n) && iowrn_reg )\n\t\t\tport_wr <= 1'b1;\n\t\telse\n\t\t\tport_wr <= 1'b0;\n\n\t\tif( port_enabled && (!iorq_n) && (!rd_n) && iordn_reg )\n\t\t\tport_rd <= 1'b1;\n\t\telse\n\t\t\tport_rd <= 1'b0;\n\n\tend\n\n\talways @(negedge cpu_clock)\n\tbegin\n\t\tmerdn_reg <= mreq_n | rd_n;\n\n\t\tif( mem_enabled && (!mreq_n) && (!rd_n) && merdn_reg )\n\t\t\tmemreg_rd <= 1'b1;\n\t\telse\n\t\t\tmemreg_rd <= 1'b0;\n\n\tend\n\n\n\tassign port00_wr   = ( a[5:0]==MPAG      && port_wr            );\n\tassign port02_rd   = ( a[5:0]==ZXDATRD   && port_rd            );\n\tassign port03_wr   = ( a[5:0]==ZXDATWR   && port_wr            );\n\tassign port05_wrrd = ( a[5:0]==CLRCBIT   && (port_wr||port_rd) );\n\tassign port09_wr   = ( a[5:0]==VOL4      && port_wr            );\n\tassign port0a_wrrd = ( a[5:0]==DAMNPORT1 && (port_wr||port_rd) );\n\tassign port0b_wrrd = ( a[5:0]==DAMNPORT2 && (port_wr||port_rd) );\n\tassign port0f_wr   = ( a[5:0]==GSCFG0    && port_wr            );\n\tassign port10_wr   = ( a[5:0]==MPAGEX    && port_wr            );\n\n\n\tassign p_sctrl_rd = ( a[5:0]==SCTRL  && port_rd );\n\tassign p_sctrl_wr = ( a[5:0]==SCTRL  && port_wr );\n\tassign p_sstat_rd = ( a[5:0]==SSTAT  && port_rd );\n\tassign p_sdsnd_wr = ( a[5:0]==SD_SEND && port_wr );\n\tassign p_sdrd_rd  = ( a[5:0]==SD_READ && port_rd );\n\tassign p_sdrst_rd = ( a[5:0]==SD_RSTR && port_rd );\n\tassign p_mdsnd_wr = ( a[5:0]==MD_SEND && port_wr );\n\tassign p_mcsnd_wr = ( a[5:0]==MC_SEND && port_wr );\n\tassign p_mcrd_rd  = ( a[5:0]==MC_READ && port_rd );\n\n\tassign p_ledctr_wr = ( a[5:0]==LEDCTR && port_wr );\n\n\n\n\talways @*\n\tbegin\n\t\tcase( a[5:0] )\n\t\tZXCMD: dout <= command_port_input;\n\t\tZXDATRD: dout <= data_port_input;\n\t\tZXSTAT: dout <= { data_bit_input, 6'bXXXXXX, command_bit_input };\n\t\tGSCFG0: dout <= { 1'b0, mode_pan4ch, clksel1, clksel0, mode_expag, mode_8chans, mode_ramro, mode_norom };\n\n\t\tSSTAT:\n\t\t\tdout <= { 4'd0, mc_rdy, sd_wp, sd_det, md_dreq };\n\t\tSCTRL:\n\t\t\tdout <= { 2'd0, mc_speed[1], md_halfspeed, mc_speed[0], mc_xrst, mc_ncs, sd_ncs };\n\t\tSD_READ:\n\t\t\tdout <= sd_dout;\n\t\tSD_RSTR:\n\t\t\tdout <= sd_dout;\n\t\tMC_READ:\n\t\t\tdout <= mc_dout;\n\n\t\tdefault:\n\t\t\tdout <= 8'bXXXXXXXX;\n\t\tendcase\n\tend\n\n\n\n\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( port00_wr==1'b1 ) begin\n\t\t\tif( mode_expag==1'b0 ) mode_pg0[6:0] <= { din[5:0], 1'b0 };\n\t\t\telse mode_pg0[6:0] <= { din[5:0], din[7] };\n\t\tend\n\n\t\tif( mode_expag==1'b0 && port00_wr==1'b1 ) mode_pg1[6:0] <= { din[5:0], 1'b1 };\n\t\telse if( mode_expag==1'b1 && port10_wr==1'b1 )\n\t\t\tmode_pg1[6:0] <= { din[5:0], din[7] };\n\tend\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( port03_wr==1'b1 )\n\t\t\tdata_port_output <= din;\n\tend\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( port09_wr==1'b1 )\n\t\t\tport09_bit5 <= din[5];\n\tend\n\n\talways @(posedge cpu_clock,negedge rst_n)\n\tbegin\n\t\tif( rst_n==1'b0 ) { mode_pan4ch, clksel1, clksel0, mode_expag, mode_8chans, mode_ramro, mode_norom } <= 7'b0110000;\n\t\telse begin\n\t\t\tif( port0f_wr == 1'b1 )\n\t\t\tbegin\n\t\t\t\t{ mode_pan4ch, clksel1, clksel0, mode_expag, mode_8chans, mode_ramro, mode_norom } <= din[6:0];\n\t\t\tend\n\t\tend\n\tend\n\n\talways @*\n    begin\n\t\tcase( {port02_rd,port03_wr,port0a_wrrd} )\n\t\t3'b100:\n\t\tbegin\n\t\t\tdata_bit_output <= 1'b0;\n\t\t\tdata_bit_wr <= 1'b1;\n\t\tend\n\n\t\t3'b010:\n\t\tbegin\n\t\t\tdata_bit_output <= 1'b1; data_bit_wr <= 1'b1;\n\t\tend\n\n\t\t3'b001:\n\t\tbegin\n\t\t\tdata_bit_output <= ~mode_pg0[0];\n\t\t\tdata_bit_wr <= 1'b1;\n\t\tend\n\n\t\tdefault:\n\t\tbegin\n\t\t\tdata_bit_output <= 1'bX;\n\t\t\tdata_bit_wr <= 1'b0;\n\t\tend\n    \tendcase\n\n    end\n\n\talways @*\n\tbegin\n\t\tcasex( {port05_wrrd,port0b_wrrd} )\n\t\t2'b10:\n\t\tbegin\n\t\t\tcommand_bit_output <= 1'b0;\n\t\t\tcommand_bit_wr <= 1'b1;\n\t\tend\n\n\t\t2'b01:\n\t\tbegin\n\t\t\tcommand_bit_output <= port09_bit5;\n\t\t\tcommand_bit_wr <= 1'b1;\n\t\tend\n\n\t\tdefault:\n\t\tbegin\n\t\t\tcommand_bit_output <= 1'bX;\n\t\t\tcommand_bit_wr <= 1'b0;\n\t\tend\n\t\tendcase\n\tend\n\n\talways @*\n\tbegin\n\t\tcase( a[5:0] ) VOL1:\n\t\t\tvolnum <= 3'd0;\n\t\tVOL2:\n\t\t\tvolnum <= 3'd1;\n\t\tVOL3:\n\t\t\tvolnum <= 3'd2;\n\t\tVOL4:\n\t\t\tvolnum <= 3'd3;\n\t\tVOL5:\n\t\t\tvolnum <= 3'd4;\n\t\tVOL6:\n\t\t\tvolnum <= 3'd5;\n\t\tVOL7:\n\t\t\tvolnum <= 3'd6;\n\t\tVOL8:\n\t\t\tvolnum <= 3'd7;\n\t\tdefault:\n\t\t\tvolnum <= 3'bXXX;\n\t\tendcase\n\tend\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( memreg_rd ) begin\n\t\t\tsnd_wrtoggle <= ~snd_wrtoggle;\n\t\t\tsnd_datnvol  <= 1'b1; if( !mode_8chans ) snd_addr <= { 1'b0, a[9:8] };\n\t\t\telse snd_addr <= a[10:8];\n\n\t\t\tsnd_data <= din;\n\t\tend\n\t\telse if( volports_enabled && port_wr )\n\t\tbegin\n\t\t\tsnd_wrtoggle <= ~snd_wrtoggle;\n\t\t\tsnd_datnvol  <= 1'b0; snd_addr <= volnum;\n\t\t\tsnd_data <= din;\n\t\tend\n\tend\n\n\n\n\n\n\n\tassign sd_din = (a[5:0]==SD_RSTR) ? 8'hFF : din;\n\tassign mc_din = din;\n\tassign md_din = din;\n\n\n\tassign sd_start = p_sdsnd_wr | p_sdrst_rd;\n\tassign mc_start = p_mcsnd_wr;\n\tassign md_start = p_mdsnd_wr;\n\n\n      always @(posedge cpu_clock, negedge rst_n)\n      begin\n\t\tif( !rst_n ) begin\n\t\t\tmd_halfspeed <= 1'b0;\n\t\t\tmc_speed     <= 2'b01;\n\t\t\tmc_xrst      <= 1'b0;\n\t\t\tmc_ncs       <= 1'b1;\n\t\t\tsd_ncs       <= 1'b1;\n\t\tend\n\t\telse begin\n\t\t\tif( p_sctrl_wr )\n\t\t\tbegin\n\t\t\t\tif( din[0] )\n\t\t\t\t\tsd_ncs       <= din[7];\n\n\t\t\t\tif( din[1] )\n\t\t\t\t\tmc_ncs       <= din[7];\n\n\t\t\t\tif( din[2] )\n\t\t\t\t\tmc_xrst      <= din[7];\n\n\t\t\t\tif( din[3] )\n\t\t\t\t\tmc_speed[0]  <= din[7];\n\n\t\t\t\tif( din[4] )\n\t\t\t\t\tmd_halfspeed <= din[7];\n\t\t\t\t\n\t\t\t\tif( din[5] )\n\t\t\t\t\tmc_speed[1]  <= din[7];\n\n\t\t\tend\n\t\tend\n      end\n\n\n\n\talways @(posedge cpu_clock, negedge rst_n)\n\tbegin\n\t\tif( !rst_n )\n\t\t\tled <= 1'b0;\n\t\telse\n\t\tbegin\n\t\t\tif( p_ledctr_wr )\n\t\t\t\tled <= din[0];\n\t\t\telse if( led_toggle )\n\t\t\t\tled <= ~led;\n\t\tend\n\n\tend\n\n\n\n\n\n\nendmodule\n\n",
        "module_name": "ports",
        "module_hash": "80f989f2ae0977d93a9c62d04bae1d88",
        "dataset_index": 17847
      },
      "rw_manager_ac_ROM_reg_0e13a995": {
        "rtl_code": "\n\nmodule rw_manager_ac_ROM_reg(\n        rdaddress,\n        clock,\n        wraddress,\n        data,\n        wren,\n        q);\n\nparameter AC_ROM_DATA_WIDTH = \"\";\nparameter AC_ROM_ADDRESS_WIDTH = \"\"; \n\n\ninput   [(AC_ROM_ADDRESS_WIDTH-1):0]  rdaddress;\ninput     clock;\ninput [(AC_ROM_ADDRESS_WIDTH-1):0] wraddress;\ninput [(AC_ROM_DATA_WIDTH-1):0] data;\ninput wren;\noutput reg [(AC_ROM_DATA_WIDTH-1):0]  q;\n\nreg [(AC_ROM_DATA_WIDTH-1):0] ac_mem[(2**AC_ROM_ADDRESS_WIDTH-1):0];\n\nalways @(posedge clock)\n\nbegin\n  if(wren)\n  ac_mem[wraddress] <= data;\n  q <= ac_mem[rdaddress];\n\nend\n\n\n\nendmodule",
        "module_name": "rw_manager_ac_ROM_reg",
        "module_hash": "0e13a99568e60dfb8cc55b6457155bfb",
        "dataset_index": 25411
      },
      "MUX_4to1_2387ae10": {
        "rtl_code": "module MUX_4to1 (\n  input [3:0] in,\n  input [1:0] sel,\n  output reg out\n);\n\n  always @(*) begin\n    case(sel)\n      2'b00: out = in[0];\n      2'b01: out = in[1];\n      2'b10: out = in[2];\n      2'b11: out = in[3];\n    endcase\n  end\n\nendmodule",
        "module_name": "MUX_4to1",
        "module_hash": "2387ae10ce06291daa1a83d1c90d3ca6",
        "dataset_index": 3016
      },
      "full_adder_6631a459": {
        "rtl_code": "\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [2:0] c;\n\n    full_adder fa1(a[0], b[0], 1'b0, sum[0], c[0]);\n    full_adder fa2(a[1], b[1], c[0], sum[1], c[1]);\n    full_adder fa3(a[2], b[2], c[1], sum[2], c[2]);\n    full_adder fa4(a[3], b[3], c[2], sum[3], cout);\n\nendmodule\n\nmodule top_module (\n    input [3:0] a,\n    input [3:0] b,\n    output [4:0] sum\n);\n\n    wire [2:0] c;\n\n    four_bit_adder fa(a, b, sum[3:0], c[2]);\n    assign sum[4] = c[2];\n\nendmodule\n",
        "module_name": "full_adder",
        "module_hash": "6631a459832eca44d3ec9b94c83631b5",
        "dataset_index": 14330
      },
      "cheat_a71a56d9": {
        "rtl_code": "\nmodule cheat(\n  input clk,\n  input [7:0] SNES_PA,\n  input [23:0] SNES_ADDR,\n  input [7:0] SNES_DATA,\n  input SNES_wr_strobe,\n  input SNES_rd_strobe,\n  input SNES_reset_strobe,\n  input snescmd_enable,\n  input nmicmd_enable,\n  input return_vector_enable,\n  input reset_vector_enable,\n  input branch1_enable,\n  input branch2_enable,\n  input pad_latch,\n  input snes_ajr,\n  input SNES_cycle_start,\n  input [2:0] pgm_idx,\n  input pgm_we,\n  input [31:0] pgm_in,\n  output [7:0] data_out,\n  output cheat_hit,\n  output snescmd_unlock\n);\n\nwire snescmd_wr_strobe = snescmd_enable & SNES_wr_strobe;\n\nreg cheat_enable = 0;\nreg nmi_enable = 0;\nreg irq_enable = 0;\nreg holdoff_enable = 0; reg buttons_enable = 0;\nreg wram_present = 0;\nwire branch_wram = cheat_enable & wram_present;\n\nreg auto_nmi_enable = 1;\nreg auto_irq_enable = 0;\nreg auto_nmi_enable_sync = 0;\nreg auto_irq_enable_sync = 0;\nreg hook_enable_sync = 0;\n\nreg [1:0] sync_delay = 2'b10;\n\nreg [4:0] nmi_usage = 5'h00;\nreg [4:0] irq_usage = 5'h00;\nreg [20:0] usage_count = 21'h1fffff;\n\nreg [29:0] hook_enable_count = 0;\nreg hook_disable = 0;\n\nreg [1:0] vector_unlock_r = 0;\nwire vector_unlock = |vector_unlock_r;\n\nreg [1:0] reset_unlock_r = 2'b10;\nwire reset_unlock = |reset_unlock_r;\n\nreg [23:0] cheat_addr[5:0];\nreg [7:0] cheat_data[5:0];\nreg [5:0] cheat_enable_mask;\n\nreg snescmd_unlock_r = 0;\nassign snescmd_unlock = snescmd_unlock_r;\n\nreg [7:0] nmicmd = 0;\nreg [7:0] return_vector = 8'hea;\n\nreg [7:0] branch1_offset = 8'h00;\nreg [7:0] branch2_offset = 8'h00;\n\nreg [15:0] pad_data = 0;\n\nwire [5:0] cheat_match_bits ={(cheat_enable_mask[5] & (SNES_ADDR == cheat_addr[5])),\n                              (cheat_enable_mask[4] & (SNES_ADDR == cheat_addr[4])),\n                              (cheat_enable_mask[3] & (SNES_ADDR == cheat_addr[3])),\n                              (cheat_enable_mask[2] & (SNES_ADDR == cheat_addr[2])),\n                              (cheat_enable_mask[1] & (SNES_ADDR == cheat_addr[1])),\n                              (cheat_enable_mask[0] & (SNES_ADDR == cheat_addr[0]))};\nwire cheat_addr_match = |cheat_match_bits;\n\nwire [1:0] nmi_match_bits = {SNES_ADDR == 24'h00FFEA, SNES_ADDR == 24'h00FFEB};\nwire [1:0] irq_match_bits = {SNES_ADDR == 24'h00FFEE, SNES_ADDR == 24'h00FFEF};\nwire [1:0] rst_match_bits = {SNES_ADDR == 24'h00FFFC, SNES_ADDR == 24'h00FFFD};\n\nwire nmi_addr_match = |nmi_match_bits;\nwire irq_addr_match = |irq_match_bits;\nwire rst_addr_match = |rst_match_bits;\n\nwire hook_enable = ~|hook_enable_count;\n\nassign data_out = cheat_match_bits[0] ? cheat_data[0]\n                : cheat_match_bits[1] ? cheat_data[1]\n                : cheat_match_bits[2] ? cheat_data[2]\n                : cheat_match_bits[3] ? cheat_data[3]\n                : cheat_match_bits[4] ? cheat_data[4]\n                : cheat_match_bits[5] ? cheat_data[5]\n                : nmi_match_bits[1] ? 8'h04\n                : irq_match_bits[1] ? 8'h04\n                : rst_match_bits[1] ? 8'h6b\n                : nmicmd_enable ? nmicmd\n                : return_vector_enable ? return_vector\n                : branch1_enable ? branch1_offset\n                : branch2_enable ? branch2_offset\n                : 8'h2a;\n\nassign cheat_hit = (snescmd_unlock & hook_enable_sync & (nmicmd_enable | return_vector_enable | branch1_enable | branch2_enable))\n                   | (reset_unlock & rst_addr_match)\n                   | (cheat_enable & cheat_addr_match)\n                   | (hook_enable_sync & (((auto_nmi_enable_sync & nmi_enable) & nmi_addr_match & vector_unlock)\n                                           |((auto_irq_enable_sync & irq_enable) & irq_addr_match & vector_unlock)));\n\nreg [7:0] next_pa_addr = 0;\nreg [2:0] cpu_push_cnt = 0;\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    cpu_push_cnt <= 0;\n  end else if(SNES_wr_strobe) begin\n    cpu_push_cnt <= cpu_push_cnt + 1;\n    if(cpu_push_cnt == 3'b0) begin\n      next_pa_addr <= SNES_PA - 1;\n    end else begin\n      if(SNES_PA == next_pa_addr) begin\n         next_pa_addr <= next_pa_addr - 1;\n      end else begin\n        cpu_push_cnt <= 3'b0;\n      end\n    end\n  end else if(SNES_rd_strobe) begin\n    cpu_push_cnt <= 3'b0;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    vector_unlock_r <= 2'b00;\n  end else if(SNES_rd_strobe) begin\n    if(hook_enable_sync\n      & ((auto_nmi_enable_sync & nmi_enable & nmi_match_bits[1])\n        |(auto_irq_enable_sync & irq_enable & irq_match_bits[1]))\n      & cpu_push_cnt == 4) begin\n      vector_unlock_r <= 2'b11;\n    end else if(|vector_unlock_r) begin\n      vector_unlock_r <= vector_unlock_r - 1;\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    reset_unlock_r <= 2'b11;\n  end else if(SNES_cycle_start) begin\n    if(rst_addr_match & |reset_unlock_r) begin\n      reset_unlock_r <= reset_unlock_r - 1;\n    end\n  end\nend\n\nreg snescmd_unlock_disable_strobe = 1'b0;\nreg [6:0] snescmd_unlock_disable_countdown = 0;\nreg snescmd_unlock_disable = 0;\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    snescmd_unlock_r <= 0;\n    snescmd_unlock_disable <= 0;\n  end else begin\n    if(SNES_rd_strobe) begin\n      if(hook_enable_sync\n        & ((auto_nmi_enable_sync & nmi_enable & nmi_match_bits[1])\n          |(auto_irq_enable_sync & irq_enable & irq_match_bits[1]))\n        & cpu_push_cnt == 4) begin\n        return_vector <= SNES_ADDR[7:0];\n        snescmd_unlock_r <= 1;\n      end\n      if(rst_match_bits[1] & |reset_unlock_r) begin\n        snescmd_unlock_r <= 1;\n      end\n    end\n    if(SNES_cycle_start) begin\n      if(snescmd_unlock_disable) begin\n        if(|snescmd_unlock_disable_countdown) begin\n          snescmd_unlock_disable_countdown <= snescmd_unlock_disable_countdown - 1;\n        end else if(snescmd_unlock_disable_countdown == 0) begin\n          snescmd_unlock_r <= 0;\n          snescmd_unlock_disable <= 0;\n        end\n      end\n    end\n    if(snescmd_unlock_disable_strobe) begin\n      snescmd_unlock_disable_countdown <= 7'd72;\n      snescmd_unlock_disable <= 1;\n    end\n  end\nend\n\n\nalways @(posedge clk) usage_count <= usage_count - 1;\n\nalways @(posedge clk) begin\n  if(usage_count == 21'b0) begin\n    nmi_usage <= SNES_cycle_start & nmi_match_bits[1];\n    irq_usage <= SNES_cycle_start & irq_match_bits[1];\n    if(|nmi_usage & |irq_usage) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(irq_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(nmi_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b0;\n      auto_irq_enable <= 1'b1;\n    end\n  end else begin\n    if(SNES_cycle_start & nmi_match_bits[0]) nmi_usage <= nmi_usage + 1;\n    if(SNES_cycle_start & irq_match_bits[0]) irq_usage <= irq_usage + 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) sync_delay <= 2'b10;\n    else begin\n      if (|sync_delay) sync_delay <= sync_delay - 1;\n      if (sync_delay == 2'b00) begin\n        auto_nmi_enable_sync <= auto_nmi_enable;\n        auto_irq_enable_sync <= auto_irq_enable;\n        hook_enable_sync <= hook_enable;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if((snescmd_unlock & snescmd_wr_strobe & ~|SNES_ADDR[8:0] & (SNES_DATA == 8'h85))\n     | (holdoff_enable & SNES_reset_strobe)) begin\n    hook_enable_count <= 30'd960000000;\n  end else if (|hook_enable_count) begin\n    hook_enable_count <= hook_enable_count - 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    snescmd_unlock_disable_strobe <= 1'b0;\n  end else begin\n    snescmd_unlock_disable_strobe <= 1'b0;\n    if(snescmd_unlock & snescmd_wr_strobe) begin\n      if(~|SNES_ADDR[8:0]) begin\n        case(SNES_DATA)\n          8'h82: cheat_enable <= 1;\n          8'h83: cheat_enable <= 0;\n          8'h84: {nmi_enable, irq_enable} <= 2'b00;\n        endcase\n      end else if(SNES_ADDR[8:0] == 9'h1fd) begin\n        snescmd_unlock_disable_strobe <= 1'b1;\n      end\n    end else if(pgm_we) begin\n      if(pgm_idx < 6) begin\n        cheat_addr[pgm_idx] <= pgm_in[31:8];\n        cheat_data[pgm_idx] <= pgm_in[7:0];\n      end else if(pgm_idx == 6) begin cheat_enable_mask <= pgm_in[5:0];\n      end else if(pgm_idx == 7) begin {wram_present, buttons_enable, holdoff_enable, irq_enable, nmi_enable, cheat_enable}\n         <= ({wram_present, buttons_enable, holdoff_enable, irq_enable, nmi_enable, cheat_enable}\n          & ~pgm_in[13:8])\n          | pgm_in[5:0];\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_wr_strobe) begin\n    if(SNES_ADDR[8:0] == 9'h1f0) begin\n      pad_data[7:0] <= SNES_DATA;\n    end else if(SNES_ADDR[8:0] == 9'h1f1) begin\n      pad_data[15:8] <= SNES_DATA;\n    end\n  end\nend\n\nalways @* begin\n  case(pad_data)\n    16'h3030: nmicmd = 8'h80;\n    16'h2070: nmicmd = 8'h81;\n    16'h10b0: nmicmd = 8'h82;\n    16'h9030: nmicmd = 8'h83;\n    16'h5030: nmicmd = 8'h84;\n    16'h1070: nmicmd = 8'h85;\n    default: nmicmd = 8'h00;\n  endcase\nend\n\nalways @* begin\n  if(buttons_enable) begin\n    if(snes_ajr) begin\n      if(nmicmd) begin\n        branch1_offset = 8'h30;   end else begin\n        if(branch_wram) begin\n          branch1_offset = 8'h3a; end else begin\n          branch1_offset = 8'h3d; end\n      end\n    end else begin\n      if(pad_latch) begin\n        if(branch_wram) begin\n          branch1_offset = 8'h3a; end else begin\n          branch1_offset = 8'h3d; end\n      end else begin\n        branch1_offset = 8'h00;   end\n    end\n  end else begin\n    if(branch_wram) begin\n      branch1_offset = 8'h3a;     end else begin\n      branch1_offset = 8'h3d;     end\n  end\nend\n\nalways @* begin\n  if(nmicmd == 8'h81) begin\n    branch2_offset = 8'h0e;       end else if(branch_wram) begin\n    branch2_offset = 8'h00;       end else begin\n    branch2_offset = 8'h03;       end\nend\n\nendmodule\n",
        "module_name": "cheat",
        "module_hash": "a71a56d994881be482939685201486ec",
        "dataset_index": 25541
      },
      "uart_sync_flops_1852e02c": {
        "rtl_code": "module uart_sync_flops\n(\n  rst_i,\n  clk_i,\n  stage1_rst_i,\n  stage1_clk_en_i,\n  async_dat_i,\n  sync_dat_o\n);\n\nparameter width         = 1;\nparameter init_value    = 1'b0;\n\ninput                           rst_i;                  input                           clk_i;                  input                           stage1_rst_i;           input                           stage1_clk_en_i;        input   [width-1:0]             async_dat_i;            output  [width-1:0]             sync_dat_o;             reg     [width-1:0]             sync_dat_o;\nreg     [width-1:0]             flop_0;\n\n\nalways @ (posedge clk_i or posedge rst_i)\nbegin\n    if (rst_i)\n        flop_0 <= {width{init_value}};\n    else\n        flop_0 <= async_dat_i;    \nend\n\nalways @ (posedge clk_i or posedge rst_i)\nbegin\n    if (rst_i)\n        sync_dat_o <= {width{init_value}};\n    else if (stage1_rst_i)\n        sync_dat_o <= {width{init_value}};\n    else if (stage1_clk_en_i)\n        sync_dat_o <= flop_0;       \nend\n\nendmodule\n",
        "module_name": "uart_sync_flops",
        "module_hash": "1852e02cbb00e25db07b4d318a3ff012",
        "dataset_index": 24186
      },
      "Control_Unit_84bd7b5d": {
        "rtl_code": "module Control_Unit(output reg done, Ld_AR_BR, Div_AR_x2_CR, Mul_BR_x2_CR, Clr_CR,\n\tinput reset_b, start, AR_gt_0, AR_lt_0, clk);\n\n\treg [1:0] state;\n\n\talways @(posedge clk) begin\n\t\tif (reset_b == 0) begin\n\t\t\tLd_AR_BR = 0;\n\t\t\tMul_BR_x2_CR = 0;\n\t\t\tDiv_AR_x2_CR = 0;\n\t\t\tClr_CR = 0;\n\t\t\tdone = 0;\n\t\t\tstate <= 2'b00;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t2'b00: begin\n\t\t\t\t\tLd_AR_BR = 1;\n\t\t\t\t\tMul_BR_x2_CR = 0;\n\t\t\t\t\tDiv_AR_x2_CR = 0;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 0;\n\t\t\t\t\tif (start) begin\n\t\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b01: begin\n\t\t\t\t\tLd_AR_BR = 0;\n\t\t\t\t\tMul_BR_x2_CR = 0;\n\t\t\t\t\tDiv_AR_x2_CR = 0;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tif (AR_gt_0) begin\n\t\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\tend else if (AR_lt_0) begin\n\t\t\t\t\t\tstate <= 2'b11;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b10: begin\n\t\t\t\t\tLd_AR_BR = 0;\n\t\t\t\t\tMul_BR_x2_CR = 1;\n\t\t\t\t\tDiv_AR_x2_CR = 0;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\tend\n\t\t\t\t2'b11: begin\n\t\t\t\t\tLd_AR_BR = 0;\n\t\t\t\t\tMul_BR_x2_CR = 0;\n\t\t\t\t\tDiv_AR_x2_CR = 1;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\nendmodule",
        "module_name": "Control_Unit",
        "module_hash": "84bd7b5dcac252173c64d8349f647da2",
        "dataset_index": 3401
      },
      "fifo_36e54bca": {
        "rtl_code": "\n\nmodule fifo(\n    output [7:0] dout,\n    output indicator,  input [7:0] din,\n    input din_valid,\n    input clk,\n    input reset_n\n);\n\nparameter SIZE = 20,\n          INDEX_WIDTH = 8,\n          MAX_INDEX = SIZE * 8 - 1;\n\nlocalparam WAITING = 0,\n           RECEIVING = 1,\n           LEFT_PADDING = 2,\n           TRANSFERING = 3,\n           RIGHT_PADDING = 4;\n\nreg [2:0] state, next_state;\nreg [MAX_INDEX:0] queue, next_queue;\nreg [INDEX_WIDTH - 1:0] head, next_head;  reg [6:0] count, next_count;\n\nalways @(*) begin\n    case (state)\n        WAITING: begin\n            if (din_valid) begin\n                next_state = RECEIVING;\n                next_queue = {queue[MAX_INDEX - 8:0],\n                              din};\n                next_head = 8;\n            end else begin\n                next_state = WAITING;\n                next_queue = queue;\n                next_head = 0;\n            end\n            next_count = 0;\n        end\n\n        RECEIVING: begin\n            if (din_valid) begin\n                next_state = RECEIVING;\n                next_queue = {queue[MAX_INDEX - 8:0],\n                              din};\n                next_head = head + 8;\n            end else begin\n                next_state = LEFT_PADDING;\n                next_queue = queue;\n                next_head = head;\n            end\n            next_count = 0;\n        end\n\n        LEFT_PADDING: begin\n            if (count < 79) begin\n                next_state = LEFT_PADDING;\n                next_count = count + 1;\n            end else begin\n                next_state = TRANSFERING;\n                next_count = 0;\n            end\n            next_head = head;\n            next_queue = queue;\n        end\n\n        TRANSFERING: begin\n            if (count < 7) begin\n                next_state = TRANSFERING;\n                next_head = head;\n                next_count = count + 1;\n            end else begin\n                if (head == 8)  next_state = RIGHT_PADDING;\n                else\n                    next_state = TRANSFERING;\n                next_head = head - 8;\n                next_count = 0;\n            end\n            next_queue = queue;\n        end\n\n        RIGHT_PADDING: begin\n            if (count < 15) begin\n                next_state = RIGHT_PADDING;\n                next_count = count + 1;\n            end else begin\n                next_state = WAITING;\n                next_count = 0;\n            end\n            next_head = 0;\n            next_queue = 0;\n        end\n\n        default: begin\n            next_state = WAITING;\n            next_queue = 0;\n            next_head = 0;\n            next_count = 0;\n        end\n    endcase\nend\n\nalways @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        state <= WAITING;\n        queue <= 0;\n        head <= 0;\n        count <= 0;\n    end else begin\n        state <= next_state;\n        queue <= next_queue;\n        head <= next_head;\n        count <= next_count;\n    end\nend\n\nassign dout = (head == 0) ? 0 : queue[(head - 1)-:8],\n       indicator = (state == RECEIVING && ~din_valid) ||\n                   (state == TRANSFERING && next_state == RIGHT_PADDING);\n\nendmodule\n",
        "module_name": "fifo",
        "module_hash": "36e54bca349148ec0a792dace9db0c96",
        "dataset_index": 17513
      },
      "mux4to1_enable_e2daee25": {
        "rtl_code": "module mux4to1_enable (data0, data1, data2, data3, sel, enable, out);\ninput [3:0] data0, data1, data2, data3;\ninput [1:0] sel;\ninput enable;\noutput out;\n\nwire [1:0] sel_inv;\nassign sel_inv = ~sel;\n\nwire [3:0] mux_out;\nassign mux_out[0] = (sel_inv[1] & sel_inv[0]) ? data0 : 1'bx;\nassign mux_out[1] = (sel_inv[1] & sel[0]) ? data1 : 1'bx;\nassign mux_out[2] = (sel[1] & sel_inv[0]) ? data2 : 1'bx;\nassign mux_out[3] = (sel[1] & sel[0]) ? data3 : 1'bx;\n\nassign out = enable ? 1'b0 : mux_out[sel];\n\nendmodule",
        "module_name": "mux4to1_enable",
        "module_hash": "e2daee252b7ef2a33e693863335f19c5",
        "dataset_index": 2213
      },
      "power_supply_cf176210": {
        "rtl_code": "module power_supply (\n  input clk,\n  input rst,\n  output reg VPWR,\n  output reg VGND,\n  output reg VPB,\n  output reg VNB\n);\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      VPWR <= 0;\n      VGND <= 0;\n      VPB <= 0;\n      VNB <= 0;\n    end else begin\n      VPWR <= 1;\n      VGND <= 0;\n      VPB <= 1;\n      VNB <= 0;\n    end\n  end\nendmodule",
        "module_name": "power_supply",
        "module_hash": "cf176210c3773b566b7210b2c8972038",
        "dataset_index": 20892
      },
      "ui_cmd #_c3590f0b": {
        "rtl_code": "\n\nmodule ui_cmd #\n  (\n   parameter TCQ = 100,\n   parameter ADDR_WIDTH         = 33,\n   parameter BANK_WIDTH         = 3,\n   parameter COL_WIDTH          = 12,\n   parameter RANK_WIDTH         = 2,\n   parameter ROW_WIDTH          = 16,\n   parameter RANKS              = 4,\n   parameter MEM_ADDR_ORDER     = \"BANK_ROW_COLUMN\"\n  )\n  (\n  app_rdy, use_addr, rank, bank, row, col, size, cmd, hi_priority,\n  rd_accepted, wr_accepted, data_buf_addr,\n  rst, clk, accept_ns, rd_buf_full, wr_req_16, app_addr, app_cmd,\n  app_sz, app_hi_pri, app_en, wr_data_buf_addr, rd_data_buf_addr_r\n  );\n\n  input rst;\n  input clk;\n\n  input accept_ns;\n  input rd_buf_full;\n  input wr_req_16;\n  wire app_rdy_ns = accept_ns && ~rd_buf_full && ~wr_req_16;\n  reg app_rdy_r = 1'b0 ;\n  always @(posedge clk) app_rdy_r <= #TCQ app_rdy_ns;\n  output wire app_rdy;\n  assign app_rdy = app_rdy_r;\n\n  input [ADDR_WIDTH-1:0] app_addr;\n  input [2:0] app_cmd;\n  input app_sz;\n  input app_hi_pri;\n  input app_en;\n\n  reg [ADDR_WIDTH-1:0] app_addr_r1 = {ADDR_WIDTH{1'b0}};\n  reg [ADDR_WIDTH-1:0] app_addr_r2 = {ADDR_WIDTH{1'b0}};\n  reg [2:0] app_cmd_r1;\n  reg [2:0] app_cmd_r2;\n  reg app_sz_r1;\n  reg app_sz_r2;\n  reg app_hi_pri_r1;\n  reg app_hi_pri_r2;\n  reg app_en_r1;\n  reg app_en_r2;\n\n  wire [ADDR_WIDTH-1:0] app_addr_ns1 = app_rdy_r && app_en ? app_addr : app_addr_r1;\n  wire [ADDR_WIDTH-1:0] app_addr_ns2 = app_rdy_r ? app_addr_r1 : app_addr_r2;\n  wire [2:0] app_cmd_ns1 = app_rdy_r ? app_cmd : app_cmd_r1;\n  wire [2:0] app_cmd_ns2 = app_rdy_r ? app_cmd_r1 : app_cmd_r2;\n  wire app_sz_ns1 = app_rdy_r ? app_sz : app_sz_r1;\n  wire app_sz_ns2 = app_rdy_r ? app_sz_r1 : app_sz_r2;\n  wire app_hi_pri_ns1 = app_rdy_r ? app_hi_pri : app_hi_pri_r1;\n  wire app_hi_pri_ns2 = app_rdy_r ? app_hi_pri_r1 : app_hi_pri_r2;\n  wire app_en_ns1 = ~rst && (app_rdy_r ? app_en : app_en_r1);\n  wire app_en_ns2 = ~rst && (app_rdy_r ? app_en_r1 : app_en_r2);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      app_addr_r1 <= #TCQ {ADDR_WIDTH{1'b0}};\n      app_addr_r2 <= #TCQ {ADDR_WIDTH{1'b0}};\n    end else begin\n      app_addr_r1 <= #TCQ app_addr_ns1;\n      app_addr_r2 <= #TCQ app_addr_ns2;\n    end \n    app_cmd_r1 <= #TCQ app_cmd_ns1;\n    app_cmd_r2 <= #TCQ app_cmd_ns2;\n    app_sz_r1 <= #TCQ app_sz_ns1;\n    app_sz_r2 <= #TCQ app_sz_ns2;\n    app_hi_pri_r1 <= #TCQ app_hi_pri_ns1;\n    app_hi_pri_r2 <= #TCQ app_hi_pri_ns2;\n    app_en_r1 <= #TCQ app_en_ns1;\n    app_en_r2 <= #TCQ app_en_ns2;\n  end wire use_addr_lcl = app_en_r2 && app_rdy_r;\n  output wire use_addr;\n  assign use_addr = use_addr_lcl;\n\n  output wire [RANK_WIDTH-1:0] rank;\n  output wire [BANK_WIDTH-1:0] bank;\n  output wire [ROW_WIDTH-1:0] row;\n  output wire [COL_WIDTH-1:0] col;\n  output wire size;\n  output wire [2:0] cmd;\n  output wire hi_priority;\n\n  assign col = app_rdy_r\n                 ? app_addr_r1[0+:COL_WIDTH]\n                 : app_addr_r2[0+:COL_WIDTH];\n  generate\n    begin\n      if (MEM_ADDR_ORDER == \"ROW_BANK_COLUMN\")\n      begin\n        assign row = app_rdy_r\n                       ? app_addr_r1[COL_WIDTH+BANK_WIDTH+:ROW_WIDTH]\n                       : app_addr_r2[COL_WIDTH+BANK_WIDTH+:ROW_WIDTH];\n        assign bank = app_rdy_r\n                        ? app_addr_r1[COL_WIDTH+:BANK_WIDTH]\n                        : app_addr_r2[COL_WIDTH+:BANK_WIDTH];\n      end\n      else\n      begin\n        assign row = app_rdy_r\n                       ? app_addr_r1[COL_WIDTH+:ROW_WIDTH]\n                       : app_addr_r2[COL_WIDTH+:ROW_WIDTH];\n        assign bank = app_rdy_r\n                        ? app_addr_r1[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH]\n                        : app_addr_r2[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH];\n      end\n    end\n  endgenerate\n\n  assign rank = (RANKS == 1)\n                  ? 1'b0\n                  : app_rdy_r\n                    ? app_addr_r1[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH]\n                    : app_addr_r2[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH];\n  assign size = app_rdy_r\n                  ? app_sz_r1\n                  : app_sz_r2;\n  assign cmd = app_rdy_r\n                 ? app_cmd_r1\n                 : app_cmd_r2;\n  assign hi_priority = app_rdy_r\n                         ? app_hi_pri_r1\n                         : app_hi_pri_r2;\n\n  wire request_accepted = use_addr_lcl && app_rdy_r;\n  wire rd = app_cmd_r2[1:0] == 2'b01;\n  wire wr = app_cmd_r2[1:0] == 2'b00;\n  wire wr_bytes = app_cmd_r2[1:0] == 2'b11;\n  wire write = wr || wr_bytes;\n  output wire rd_accepted;\n  assign rd_accepted = request_accepted && rd;\n  output wire wr_accepted;\n  assign wr_accepted = request_accepted && write;\n\n  input [3:0] wr_data_buf_addr;\n  input [3:0] rd_data_buf_addr_r;\n  output wire [3:0] data_buf_addr;\n\n  assign data_buf_addr = ~write ? rd_data_buf_addr_r : wr_data_buf_addr;\n\nendmodule ",
        "module_name": "ui_cmd #",
        "module_hash": "c3590f0bbc59ba9dfcc106f348ac7ac6",
        "dataset_index": 25048
      },
      "counter #_d4ecd889": {
        "rtl_code": "module counter #(\n    parameter WIDTH = 8\n)(\n    input clk,\n    input rst,\n    input enable,\n    input [WIDTH-1:0] mod,\n    output reg [WIDTH-1:0] count,\n    output reg done\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n        done <= 0;\n    end else if (enable) begin\n        if (count == mod-1) begin\n            count <= 0;\n            done <= 1;\n        end else begin\n            count <= count + 1;\n            done <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "counter #",
        "module_hash": "d4ecd889c1008df6140e67f8b9c8947b",
        "dataset_index": 8303
      },
      "voltage_inverter_f5e6a25d": {
        "rtl_code": "module voltage_inverter (\n    output Z,\n    input A,\n    input TE\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // p-type and n-type transistors\n    //sky130_fd_sc_hdll_vnp vnp (\n    //    .D(Z),\n    //    .G(A),\n    //    .S(VPB),\n    //    .B(VNB)\n    //);\n    //sky130_fd_sc_hdll_vpp vpp (\n    //    .D(Z),\n    //    .G(A),\n    //    .S(VPB),\n    //    .B(VNB)\n    //);\n\n    // inverter logic\n    assign Z = TE ? ~A : A;\n\nendmodule",
        "module_name": "voltage_inverter",
        "module_hash": "f5e6a25de37c99f64f5b122a6d3dd2d3",
        "dataset_index": 9733
      },
      "binary_to_gray_bd811d77": {
        "rtl_code": "module binary_to_gray (\n    input [4:0] bin_in,\n    output reg [4:0] gray_out\n);\n\nreg [4:0] stage1_out;\nreg [4:0] stage2_out;\n\n// Stage 1\nalways @ (bin_in) begin\n    stage1_out[0] = bin_in[0];\n    stage1_out[1] = bin_in[0] ^ bin_in[1];\n    stage1_out[2] = bin_in[1] ^ bin_in[2];\n    stage1_out[3] = bin_in[2] ^ bin_in[3];\n    stage1_out[4] = bin_in[3] ^ bin_in[4];\nend\n\n// Stage 2\nalways @ (stage1_out) begin\n    stage2_out[0] = stage1_out[0];\n    stage2_out[1] = stage1_out[1] ^ stage1_out[0];\n    stage2_out[2] = stage1_out[2] ^ stage1_out[1];\n    stage2_out[3] = stage1_out[3] ^ stage1_out[2];\n    stage2_out[4] = stage1_out[4] ^ stage1_out[3];\nend\n\nalways @* begin\n    gray_out = stage2_out;\nend\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "bd811d77009199c0ae009c64d8e3cc24",
        "dataset_index": 8512
      },
      "openhmc_sync_fifo_reg_stage #_da6f9c29": {
        "rtl_code": "module openhmc_sync_fifo_reg_stage #(parameter DWIDTH = 8)(\n    input wire clk,\n    input wire res_n,\n    input wire [DWIDTH-1:0] d_in,\n    input wire [DWIDTH-1:0] d_in_p,\n    input wire p_full,\n    input wire n_full,\n    input wire si,\n    input wire so,\n    output reg full,\n    output reg [DWIDTH-1:0] d_out\n);\n\n    wire en, muxi;\n\n    assign en = (si & so & full)                // so and si, shift through\n                | (si & ~so & ~full && n_full)  // shift in new value\n                | (~si & so & p_full);          // shift through\n\n    assign muxi = (si & ~so) | (si & so & ~p_full & full);\n\n    always @ (posedge clk or negedge res_n) begin\n        if (!res_n) begin\n            full <= 1'b0;\n            d_out <= {DWIDTH{1'b0}};\n        end else begin\n            if (en) begin\n                if (muxi) begin\n                    d_out <= d_in;      // enter new value when enabled\n                end else begin\n                    d_out <= d_in_p;    // shift through\n                end\n            end\n\n            full <= (full & si)             // stay full while si to other stage\n                    | (full & ~si & ~so)    // hold full\n                    | (~si & so & p_full)   // keep full as long as prev stage is full\n                    | (si & ~so & n_full);  // fill this stage by si\n        end\n    end\n\nendmodule",
        "module_name": "openhmc_sync_fifo_reg_stage #",
        "module_hash": "da6f9c299f0fb13df1cd33a4a22162ed",
        "dataset_index": 16155
      },
      "ripple_carry_adder_e42c9446": {
        "rtl_code": "module ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input carry_in,\n    output [3:0] S,\n    output carry_out\n);\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    assign sum = A + B + carry_in;\n    assign carry = (A[3] & B[3]) | (A[3] & carry_in) | (B[3] & carry_in);\n\n    assign S = sum;\n    assign carry_out = carry[3];\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "e42c94469db8baaa933afdbf2fd12b70",
        "dataset_index": 6430
      },
      "output_mux_879805f7": {
        "rtl_code": "module output_mux (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign X = ((A1 & A2) ? B1 : ((A1 & ~A2) ? C1 : 1'b0));\n\nendmodule",
        "module_name": "output_mux",
        "module_hash": "879805f7c772f76b715f5911673b9e57",
        "dataset_index": 11989
      },
      "my_d_latch_6671d666": {
        "rtl_code": "module my_d_latch (\n    input  D   ,\n    output Q   ,\n    input  GATE\n);\n\nreg Q;\n\nalways @(posedge GATE)\n    Q <= D;\n\nendmodule",
        "module_name": "my_d_latch",
        "module_hash": "6671d666c02d5b9ffb37c6ca6f5ab050",
        "dataset_index": 5298
      },
      "debounce_b93d6222": {
        "rtl_code": "\n\nmodule debounce(input clk, but, output reg debounced);\n\treg [9:0] debTimer;\n\talways @(posedge clk) begin\n\t\tif (debounced == but)\n\t\t\tdebTimer <= 0;\n\t\telse if (debTimer != -10'b1)\n\t\t\tdebTimer <= debTimer+1;\n\t\telse if (debTimer == -10'b1)\n\t\t\tdebounced <= but;\n\tend\nendmodule\n\nmodule clkDiv(input clk, output divClk);\n\tparameter n = 25;\n\treg [n-1:0] count = 0;\n\tassign divClk = count[n-1];\n\t\n\talways @(posedge clk)\n\t\tcount <= count + 1;\nendmodule\n",
        "module_name": "debounce",
        "module_hash": "b93d6222029bcb9acfc9cbb0bc294204",
        "dataset_index": 24356
      },
      "sky130_fd_sc_ls__or2b_4152fb33": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__or2b (\n    X  ,\n    A  ,\n    B_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B_N;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , B_N            );\n    or  or0  (or0_out_X, not0_out, A    );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__or2b",
        "module_hash": "4152fb3393182ddee914caede5a8f21d",
        "dataset_index": 12851
      },
      "seven_segment_leds_x_8_2c22a411": {
        "rtl_code": "\nmodule seven_segment_leds_x_8(\n    input [31:0] bcd_in,\n    input [7:0] decimal_points,\n    input clk,\n    output  reg [6:0] a_to_g,\n    output reg decimal_point,\n    output reg [7:0] anode \n    );\n\nwire [2:0] counter;\nreg [3:0] digit;\nreg [20:0] clkdiv;\t\n\t \n\nassign counter = clkdiv[20:18];   always @(posedge clk)\n    case(counter)\n\t0: {digit, decimal_point} = {bcd_in[3:0], ~decimal_points[0]};\n\t1: {digit, decimal_point} = {bcd_in[7:4], ~decimal_points[1]};\n\t2: {digit, decimal_point} = {bcd_in[11:8], ~decimal_points[2]};\n\t3: {digit, decimal_point} = {bcd_in[15:12], ~decimal_points[3]};\n\t4: {digit, decimal_point} = {bcd_in[19:16], ~decimal_points[4]};\n    \t5: {digit, decimal_point} = {bcd_in[23:20], ~decimal_points[5]};\n    \t6: {digit, decimal_point} = {bcd_in[27:24], ~decimal_points[6]};\n    \t7: {digit, decimal_point} = {bcd_in[31:28], ~decimal_points[7]};\n     endcase\n\nalways @(posedge clk)\n     case(digit)\n    \t0: a_to_g = 8'b1000000;  1: a_to_g = 8'b1111001;  2: a_to_g = 8'b0100100;  3: a_to_g = 8'b0110000;  4: a_to_g = 8'b0011001;  5: a_to_g = 8'b0010010;  6: a_to_g = 8'b0000010;  7: a_to_g = 8'b1111000;  8: a_to_g = 8'b0000000;  9: a_to_g = 8'b0010000;  default: a_to_g = 8'b11111111;  endcase\n\t  \nalways @(posedge clk)\n    case(counter)\n        0: anode = 8'b11111110;\n\t1: anode = 8'b11111101;\n\t2: anode = 8'b11111011;\n\t3: anode = 8'b11110111;\n\t4: anode = 8'b11101111;\n        5: anode = 8'b11011111;\n        6: anode = 8'b10111111;\n        7: anode = 8'b01111111;\n\tdefault: anode = 8'b11111111;  endcase\n     \nalways  @ (posedge clk)\n   begin\n\tclkdiv <= clkdiv + 21'b1;\n    end \n\t  \nendmodule\n",
        "module_name": "seven_segment_leds_x_8",
        "module_hash": "2c22a411bdb6bb720602954951288da7",
        "dataset_index": 23446
      },
      "johnson_counter_and_barrel_shifter_5dd57a90": {
        "rtl_code": "module johnson_counter_and_barrel_shifter (\n    input clk,\n    input [3:0] DATA_IN,\n    input [1:0] SHIFT,\n    output reg [3:0] Q\n);\n\nreg [3:0] counter;\nreg [3:0] shifted_counter;\nreg [3:0] and_output;\n\nalways @(posedge clk) begin\n    // Johnson counter sequence\n    case(counter)\n        4'b0001: counter <= 4'b0011;\n        4'b0011: counter <= 4'b0111;\n        4'b0111: counter <= 4'b1110;\n        4'b1110: counter <= 4'b1100;\n        4'b1100: counter <= 4'b1000;\n        4'b1000: counter <= 4'b0001;\n    endcase\n    \n    // Barrel shifter\n    if (SHIFT == 2'b01) begin // Shift right\n        shifted_counter[0] <= counter[3];\n        shifted_counter[1] <= counter[0];\n        shifted_counter[2] <= counter[1];\n        shifted_counter[3] <= counter[2];\n    end\n    else if (SHIFT == 2'b10) begin // Shift left\n        shifted_counter[0] <= counter[1];\n        shifted_counter[1] <= counter[2];\n        shifted_counter[2] <= counter[3];\n        shifted_counter[3] <= counter[0];\n    end\n    else begin // No shift\n        shifted_counter <= counter;\n    end\n    \n    // Bitwise AND\n    and_output <= shifted_counter & DATA_IN;\n    \n    // Output\n    Q <= shifted_counter;\nend\n\nendmodule",
        "module_name": "johnson_counter_and_barrel_shifter",
        "module_hash": "5dd57a90e56725c732fbb2b59dd2c877",
        "dataset_index": 15333
      },
      "mealy_fsm_52dad21b": {
        "rtl_code": "module mealy_fsm (\n  input clk,\n  input reset,\n  input in1,\n  input in2,\n  output reg out,\n  output reg [2:0] state\n);\n\n  // Define the states\n  parameter A = 3'b000;\n  parameter B = 3'b001;\n  parameter C = 3'b010;\n  parameter D = 3'b011;\n  parameter E = 3'b100;\n\n  // Define the state transition table\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= A;\n      out <= 0;\n    end else begin\n      case (state)\n        A: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n        B: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n        C: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n        D: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "mealy_fsm",
        "module_hash": "52dad21bcab415e72743e7d46f4644e4",
        "dataset_index": 11209
      },
      "Multiplexer4 #_976faf10": {
        "rtl_code": "module Multiplexer4 #(parameter width = 3)(\n  input [width-1:0] i_data0,\n  input [width-1:0] i_data1,\n  input [width-1:0] i_data2,\n  input [width-1:0] i_data3,\n  input             i_select0,\n  input             i_select1,\n  input             i_select2,\n  input             i_select3,\n  output reg [width-1:0] o_data,\n  output reg            o_error\n);\n\n  always @(*) begin\n    case ({i_select3, i_select2, i_select1, i_select0})\n      4'b0000: o_data = i_data0;\n      4'b0001: o_data = i_data1;\n      4'b0010: o_data = i_data2;\n      4'b0011: o_data = i_data3;\n      default: begin\n        o_data = 0;\n        o_error = 1;\n      end\n    endcase\n  end\nendmodule",
        "module_name": "Multiplexer4 #",
        "module_hash": "976faf10b976884149d24d4e2a2aba68",
        "dataset_index": 8846
      },
      "RegisterBanc_36694281": {
        "rtl_code": "\n\nmodule RegisterBanc(ReadData1, ReadData2, WriteData,ReadAddr1, ReadAddr2, WriteAddr, RegWrite, clk , ro);\n    output [31:0] ReadData1, ReadData2;\n    input [31:0] WriteData;\n    input [4:0] ReadAddr1, ReadAddr2, WriteAddr;\n    input [0:0] RegWrite, clk;\n\t output [31:0] ro;\n\n\n    reg [31:0] Register [0:31];\n\t \n\t \n    initial begin \n      Register[0] = 32'd0;\n\t\tRegister[1] = 32'd0;\n\t\tRegister[2] = 32'd0;\n\t\tRegister[3] = 32'd0;\n\t\tRegister[4] = 32'd0;\n\t\tRegister[5] = 32'd0;\n\t\tRegister[6] = 32'd0;\n\t\tRegister[7] = 32'd0;\n\t\tRegister[8] = 32'd0;\n\t\tRegister[9] = 32'd0;\n\t\tRegister[10] = 32'd0;\n\t\tRegister[11] = 32'd0;\n\t\tRegister[12] = 32'd0;\n\t\tRegister[13] = 32'd0;\n\t\tRegister[14] = 32'd0;\n\t\tRegister[15] = 32'd0;\n\t\tRegister[16] = 32'd0;\n\t\tRegister[17] = 32'd0;\n\t\tRegister[18] = 32'd0;\n\t\tRegister[19] = 32'd0;\n\t\tRegister[20] = 32'd0;\n\t\tRegister[21] = 32'd0;\n\t\tRegister[22] = 32'd0;\n\t\tRegister[23] = 32'd0;\n\t\tRegister[24] = 32'd0;\n\t\tRegister[25] = 32'd0;\n\t\tRegister[26] = 32'd0;\n\t\tRegister[27] = 32'd0;\n\t\tRegister[28] = 32'd0;\n\t\tRegister[29] = 32'd0;\n\t\tRegister[30] = 32'd0;\n\t\tRegister[31] = 32'd0;\n    end\n\t \n\t \n    always @ (posedge clk) begin\n        if (RegWrite) begin\n            Register[WriteAddr] <= WriteData; \n        end\n\n    end\n    \n    assign ReadData1 = Register[ReadAddr1];\n    assign ReadData2 = Register[ReadAddr2];\n\t assign ro=Register[4'd2];\n\nendmodule",
        "module_name": "RegisterBanc",
        "module_hash": "36694281c4679d642414d910bace7556",
        "dataset_index": 15730
      },
      "altera_up_video_scaler_shrink_51868d6d": {
        "rtl_code": "\n\n\n\nmodule altera_up_video_scaler_shrink (\n\tclk,\n\treset,\n\n\tstream_in_data,\n\tstream_in_startofpacket,\n\tstream_in_endofpacket,\n\tstream_in_valid,\n\n\tstream_out_ready,\n\t\n\tstream_in_ready,\n\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_valid\n);\n\n\n\nparameter DW\t\t\t\t\t=  15; parameter WW\t\t\t\t\t=   9; parameter HW\t\t\t\t\t=   9; parameter WIDTH_IN\t\t\t= 640; parameter WIDTH_DROP_MASK\t= 4'b0101;\nparameter HEIGHT_DROP_MASK\t= 4'b0000;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[DW: 0]\tstream_in_data;\ninput\t\t\t\t\t\tstream_in_startofpacket;\ninput\t\t\t\t\t\tstream_in_endofpacket;\ninput\t\t\t\t\t\tstream_in_valid;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tstream_in_ready;\n\noutput reg\t[DW: 0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire \t\t\t\t\t\tdrop;\n\nwire\t\t\t\t\t\tcapture_inputs;\n\nwire\t\t\t\t\t\ttransfer_data;\n\nreg\t\t\t\t\t\tsaved_startofpacket;\n\nreg\t\t\t[DW: 0]\tdata;\nreg\t\t\t\t\t\tstartofpacket;\nreg\t\t\t\t\t\tendofpacket;\nreg\t\t\t\t\t\tvalid;\n\nreg\t\t\t[WW: 0]\twidth_counter;\nreg\t\t\t[HW: 0]\theight_counter;\nreg\t\t\t[ 3: 0]\tdrop_pixel;\nreg\t\t\t[ 3: 0]\tdrop_line;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'h0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (transfer_data)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= data;\n\t\tstream_out_startofpacket\t<= startofpacket;\n\t\tstream_out_endofpacket\t\t<= endofpacket;\n\t\tstream_out_valid\t\t\t\t<= valid;\n\tend\n\telse if (stream_out_ready & stream_out_valid)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'h0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\nend\n\nalways @(posedge clk)\n\tif (reset)\n\t\tsaved_startofpacket\t<= 1'b0;\n\telse if (capture_inputs)\n\t\tsaved_startofpacket\t<= 1'b0;\n\telse if (stream_in_ready)\n\t\tsaved_startofpacket\t<= saved_startofpacket | stream_in_startofpacket;\n\t\t\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tdata\t\t\t\t<=  'h0;\n\t\tstartofpacket\t<= 1'b0;\n\t\tendofpacket\t\t<= 1'b0;\n\t\tvalid\t\t\t\t<= 1'b0;\n\tend\n\telse if (capture_inputs)\n\tbegin\n\t\tdata\t\t\t\t<= stream_in_data;\n\t\tstartofpacket\t<= stream_in_startofpacket | saved_startofpacket;\n\t\tendofpacket\t\t<= stream_in_endofpacket;\n\t\tvalid\t\t\t\t<= stream_in_valid;\n\tend\n\telse if (stream_in_ready)\n\t\tendofpacket\t\t<= endofpacket | stream_in_endofpacket;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\twidth_counter\t\t<= 'h0;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket | (width_counter == (WIDTH_IN - 1)))\n\t\t\twidth_counter\t<= 'h0;\n\t\telse\n\t\t\twidth_counter\t<= width_counter + 1;\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\theight_counter\t\t<= 'h0;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket)\n\t\t\theight_counter\t<= 'h0;\n\t\telse if (width_counter == (WIDTH_IN - 1))\n\t\t\theight_counter\t<= height_counter + 1;\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tdrop_pixel\t\t<= 4'b0000;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket)\n\t\t\tdrop_pixel\t<= WIDTH_DROP_MASK;\n\t\telse if (width_counter == (WIDTH_IN - 1))\n\t\t\tdrop_pixel\t<= WIDTH_DROP_MASK;\n\t\telse\n\t\t\tdrop_pixel\t<= {drop_pixel[2:0], drop_pixel[3]};\t\t\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tdrop_line\t\t<= 4'b0000;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket)\n\t\t\tdrop_line\t<= HEIGHT_DROP_MASK;\n\t\telse if (width_counter == (WIDTH_IN - 1))\n\t\t\tdrop_line\t<= {drop_line[2:0], drop_line[3]};\n\tend\nend\n\n\n\nassign stream_in_ready\t= stream_in_valid & (drop | ~valid | transfer_data);\n\nassign drop\t\t\t\t\t= drop_pixel[0] | drop_line[0];\n\nassign capture_inputs\t= stream_in_ready & ~drop;\n\nassign transfer_data\t\t= ~stream_out_valid & stream_in_valid & ~drop;\n\n\n\n\nendmodule\n\n",
        "module_name": "altera_up_video_scaler_shrink",
        "module_hash": "51868d6d66b0577741224355d6640eef",
        "dataset_index": 25528
      },
      "bin_adder_46530fef": {
        "rtl_code": "module bin_adder (\n    A,\n    B,\n    CI,\n    SUM,\n    COUT_N\n);\n\n    input A;\n    input B;\n    input CI;\n    output SUM;\n    output COUT_N;\n\n    wire S1;\n    wire C1;\n    wire C2;\n\n    assign S1 = A ^ B;\n    assign SUM = S1 ^ CI;\n    assign C1 = A & B;\n    assign C2 = CI & S1;\n    assign COUT_N = C1 | C2;\n\nendmodule",
        "module_name": "bin_adder",
        "module_hash": "46530fef5c4bc9b8cab2ae61065eaaea",
        "dataset_index": 18787
      },
      "hpdmc_busif #_206a096f": {
        "rtl_code": "\n\n\n\nmodule hpdmc_busif #(\n\tparameter sdram_depth = 23\n) (\n\tinput sys_clk,\n\tinput sdram_rst,\n\t\n\tinput [sdram_depth-1:0] fml_adr,\n\tinput fml_stb,\n\tinput fml_we,\n\toutput fml_ack,\n\t\n\toutput mgmt_stb,\n\toutput mgmt_we,\n\toutput [sdram_depth-1-1:0] mgmt_address, \n\tinput mgmt_ack,\n\t\n\tinput data_ack\n);\n\nreg mgmt_stb_en;\n\nassign mgmt_stb = fml_stb & mgmt_stb_en;\nassign mgmt_we = fml_we;\nassign mgmt_address = fml_adr[sdram_depth-1:1];\n\nassign fml_ack = data_ack;\n\nalways @(posedge sys_clk) begin\n\tif(sdram_rst)\n\t\tmgmt_stb_en = 1'b1;\n\telse begin\n\t\tif(mgmt_ack)\n\t\t\tmgmt_stb_en = 1'b0;\n\t\tif(data_ack)\n\t\t\tmgmt_stb_en = 1'b1;\n\tend\nend\n\nendmodule\n",
        "module_name": "hpdmc_busif #",
        "module_hash": "206a096f8581d05686c44551cadd6497",
        "dataset_index": 25085
      },
      "counter_4bit_e9471292": {
        "rtl_code": "module counter_4bit(\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      count <= 4'b0;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "e9471292d17825e3b6ce43720701f863",
        "dataset_index": 15047
      },
      "calculator_2439475d": {
        "rtl_code": "module calculator (\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] OP,\n    output [3:0] RESULT\n);\n\nparameter NUM_OPERATIONS = 4;\n\nreg [3:0] result;\n\nalways @(*) begin\n    case (OP)\n        2'b00: result = A + B;\n        2'b01: result = A - B;\n        2'b10: result = A * B;\n        2'b11: result = A / B;\n    endcase\nend\n\nassign RESULT = result;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "2439475dbf61653c36eb6c99a9addd70",
        "dataset_index": 566
      },
      "quick_spi_hard #_2485c299": {
        "rtl_code": "\n\n`define LSB_FIRST 0\n`define MSB_FIRST 1\n`define LITTLE_ENDIAN 0\n`define BIG_ENDIAN 1\n\n`define MAX_DATA_WIDTH 64\n\nmodule quick_spi_hard #\n(\n    parameter NUMBER_OF_SLAVES = 2,\n\tparameter INCOMING_DATA_WIDTH = 8,\n    parameter OUTGOING_DATA_WIDTH = 16,\n\tparameter BITS_ORDER = `MSB_FIRST,\n\tparameter BYTES_ORDER = `LITTLE_ENDIAN,\n\tparameter EXTRA_WRITE_SCLK_TOGGLES = 6,\n    parameter EXTRA_READ_SCLK_TOGGLES = 4,\n\tparameter CPOL = 0,\n    parameter CPHA = 0,\n\tparameter MOSI_IDLE_VALUE = 1'b0\n)\n(\n    input wire clk,\n    input wire reset_n,\n    input wire enable,\n    input wire start_transaction,\n    input wire[NUMBER_OF_SLAVES-1:0] slave,\n    input wire operation,\n    output reg end_of_transaction,\n    output reg[INCOMING_DATA_WIDTH-1:0] incoming_data,\n    input wire[OUTGOING_DATA_WIDTH-1:0] outgoing_data,\n    output reg mosi,\n    input wire miso,\n    output reg sclk,\n    output reg[NUMBER_OF_SLAVES-1:0] ss_n);\n\nlocalparam READ = 1'b0;\nlocalparam WRITE = 1'b1;\n\nlocalparam READ_SCLK_TOGGLES = (INCOMING_DATA_WIDTH * 2) + 2;\nlocalparam ALL_READ_TOGGLES = EXTRA_READ_SCLK_TOGGLES + READ_SCLK_TOGGLES;\n\nlocalparam NUMBER_OF_FULL_BYTES = OUTGOING_DATA_WIDTH > 1 ? (OUTGOING_DATA_WIDTH / 8) : 0;\nlocalparam NUMBER_OF_PARTICULAR_BITS = OUTGOING_DATA_WIDTH > (NUMBER_OF_FULL_BYTES * 8) ? 1 : 0;\nlocalparam NUMBER_OF_BYTES = NUMBER_OF_FULL_BYTES + NUMBER_OF_PARTICULAR_BITS;\nlocalparam MAX_BYTES_INDEX = NUMBER_OF_BYTES - 1;\n\ninteger sclk_toggle_count;\ninteger transaction_toggles;\n\nreg spi_clock_phase;\nreg[1:0] state;\n\nlocalparam IDLE = 2'b00;\nlocalparam ACTIVE = 2'b01;\nlocalparam WAIT = 2'b10;\n\nreg[INCOMING_DATA_WIDTH - 1:0] incoming_data_buffer;\nreg[OUTGOING_DATA_WIDTH - 1:0] outgoing_data_buffer;\nreg[`MAX_DATA_WIDTH - 1:0] intermediate_buffer;\n\nreg[2:0] bit_counter;\nreg[3:0] byte_counter;\n    \nalways @ (posedge clk) \nbegin\n    if(!reset_n) \n\tbegin\n        end_of_transaction <= 1'b0;\n        mosi <= MOSI_IDLE_VALUE;\n        sclk <= CPOL;\n        ss_n <= {NUMBER_OF_SLAVES{1'b1}};\n        sclk_toggle_count <= 0;\n        transaction_toggles <= 0;\n        spi_clock_phase <= ~CPHA;\n        incoming_data <= {INCOMING_DATA_WIDTH{1'b0}};\n        incoming_data_buffer <= {INCOMING_DATA_WIDTH{1'b0}};\n        outgoing_data_buffer <= {OUTGOING_DATA_WIDTH{1'b0}};\n        state <= IDLE;\n        bit_counter <= 0;\n        byte_counter <= 0;\n    end\n    \n    else begin\n        case(state)\n            IDLE: \n\t\t\tbegin                \n                if(enable) \n\t\t\t\tbegin\n\t\t\t\t    bit_counter <= 0;\n                    byte_counter <= 0;\n                    if(start_transaction) \n\t\t\t\t\tbegin\n                        transaction_toggles <= (operation == READ) ? ALL_READ_TOGGLES : EXTRA_WRITE_SCLK_TOGGLES;\n\t\t\t\t\t\tintermediate_buffer = put_data(outgoing_data, BYTES_ORDER);\n\t\t\t\t        outgoing_data_buffer <= intermediate_buffer[15:0];\n                        state <= ACTIVE;\n                    end\n                end\n            end\n            \n            ACTIVE: \n\t\t\tbegin\n                ss_n[slave] <= 1'b0;\n                spi_clock_phase <= ~spi_clock_phase;\n                \n                if(ss_n[slave] == 1'b0) \n\t\t\t\tbegin\n                    if(sclk_toggle_count < (OUTGOING_DATA_WIDTH * 2) + transaction_toggles) \n\t\t\t\t\tbegin\n                        sclk <= ~sclk;\n                        sclk_toggle_count <= sclk_toggle_count + 1;\n                    end\n                end\n                \n                if(spi_clock_phase == 1'b0) \n\t\t\t\tbegin\n                    if(operation == READ) \n\t\t\t\t\tbegin\n                        if(sclk_toggle_count > ((OUTGOING_DATA_WIDTH * 2) + EXTRA_READ_SCLK_TOGGLES)-1) \n\t\t\t\t\t\tbegin\n                            incoming_data_buffer <= incoming_data_buffer >> 1;\n                            incoming_data_buffer[INCOMING_DATA_WIDTH-1] <=  miso;\n                        end\n                    end\n                end\n                \n                else \n\t\t\t\tbegin \n                    if(sclk_toggle_count < (OUTGOING_DATA_WIDTH * 2) - 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t    if(BITS_ORDER == `LSB_FIRST)\n\t\t\t\t\t    begin                  \n                            mosi <= outgoing_data_buffer[0]; outgoing_data_buffer <= outgoing_data_buffer >> 1;\n                        end\n                        else\n                        begin\n                            bit_counter <= bit_counter + 1;\n                            mosi <= outgoing_data_buffer[7 - bit_counter];\n                            if(bit_counter == 7)\n                                outgoing_data_buffer <= outgoing_data_buffer >> 8;   \n                        end\n                    end\n                end\n                \n                if(sclk_toggle_count == (OUTGOING_DATA_WIDTH * 2) + transaction_toggles) \n\t\t\t\tbegin\n                    ss_n[slave] <= 1'b1;\n                    mosi <= MOSI_IDLE_VALUE;\n                    incoming_data <= incoming_data_buffer;\n                    incoming_data_buffer <= {INCOMING_DATA_WIDTH{1'b0}};\n                    outgoing_data_buffer <= {OUTGOING_DATA_WIDTH{1'b0}};\n                    sclk <= CPOL;\n                    spi_clock_phase <= ~CPHA;\n                    sclk_toggle_count <= 0;\n                    end_of_transaction <= 1'b1;\n                    state <= WAIT;\n                end\n            end\n            \n            WAIT: \n\t\t\tbegin\n                incoming_data <= {INCOMING_DATA_WIDTH{1'b0}};\n                end_of_transaction <= 1'b0;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nfunction [`MAX_DATA_WIDTH - 1:0] put_data(input reg [`MAX_DATA_WIDTH - 1 : 0] data, input reg order);\n    reg [`MAX_DATA_WIDTH - 1:0] result;\n    reg[7:0] shift;   \nbegin\n    shift = `MAX_DATA_WIDTH - NUMBER_OF_BYTES * 8;\n\tif (order == `BIG_ENDIAN)begin\n\t      result = {data[7:0], data[15:8], data[23:16], data[31:24], data[39:32], data[47:40], data[55:48], data[63:56]};    \n\t\t if(shift > 0)\n\t\t     put_data = result >> shift;\n\t\t     else put_data = result;\n\tend\n\telse if (order == `LITTLE_ENDIAN)begin\n\t    put_data = data;\n\tend\nend\nendfunction\n\nendmodule\n",
        "module_name": "quick_spi_hard #",
        "module_hash": "2485c2990c652dd28b224441761426b7",
        "dataset_index": 23034
      },
      "top_module_4b7c29e9": {
        "rtl_code": "module top_module(\n    input [99:0] a, b, // Input ports for 100-bit binary numbers\n    input cin, // Carry-in input for 100-bit binary adder\n    input clk, // Clock input for 4-bit binary counter\n    input reset, // Synchronous active-high reset input for 4-bit binary counter\n    output [99:0] sum // Output port for final 100-bit sum\n);\n\n    wire [99:0] adder_out;\n    wire [3:0] counter_out;\n    wire [99:0] final_sum;\n\n    // Instantiate the 100-bit binary adder\n    binary_adder adder_inst(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(adder_out),\n        .cout()\n    );\n\n    // Instantiate the 4-bit binary counter\n    binary_counter counter_inst(\n        .clk(clk),\n        .reset(reset),\n        .out(counter_out)\n    );\n\n    // Instantiate the functional module that adds the output of the adder to the counter value\n    functional_module func_inst(\n        .adder_out(adder_out),\n        .counter_out(counter_out),\n        .final_sum(final_sum)\n    );\n\n    // Assign the final sum to the output port\n    assign sum = final_sum;\n\nendmodule\n\n// 100-bit binary adder module\nmodule binary_adder(\n    input [99:0] a, b, // Input ports for 100-bit binary numbers\n    input cin, // Carry-in input\n    output reg [99:0] sum, // Output port for sum\n    output reg cout // Output port for carry-out\n);\n\n    always @(*) begin\n        {cout, sum} = a + b + cin;\n    end\n\nendmodule\n\n// 4-bit binary counter module\nmodule binary_counter(\n    input clk, // Clock input\n    input reset, // Synchronous active-high reset input\n    output reg [3:0] out // Output port for counter value\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0;\n        end else begin\n            out <= out + 1;\n        end\n    end\n\nendmodule\n\n// Functional module that adds the output of the adder to the counter value\nmodule functional_module(\n    input [99:0] adder_out, // Input port for output of 100-bit binary adder\n    input [3:0] counter_out, // Input port for output of 4-bit binary counter\n    output reg [99:0] final_sum // Output port for final sum\n);\n\n    always @(*) begin\n        final_sum = adder_out + {96'b0, counter_out};\n    end\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "4b7c29e9440479cf0ea54eb09199390b",
        "dataset_index": 13811
      },
      "tone_generator_56dae1f4": {
        "rtl_code": "\nmodule tone_generator (\n  input clk,\n  input reset,\n  input [1:0] mode,\n  input [7:0] freq,\n  output reg signed [N-1:0] tone\n);\n\nparameter fs = 100000; // sampling frequency\nparameter N = 8; // number of bits used to represent the amplitude of the tone signal\n\nreg [31:0] phase_acc;\nreg [31:0] phase_inc;\n\nalways @ (posedge clk) begin\n  if (reset) begin\n    phase_acc <= 0;\n    tone <= 0;\n  end else begin\n    phase_acc <= phase_acc + phase_inc;\n    case (mode)\n      2'b00: begin // DTMF\n        case (freq)\n          8'h11: phase_inc <= 32'd3486784;\n          8'h12: phase_inc <= 32'd3853932;\n          8'h13: phase_inc <= 32'd4261416;\n          8'h14: phase_inc <= 32'd4706164;\n          8'h21: phase_inc <= 32'd6048840;\n          8'h22: phase_inc <= 32'd6684096;\n          8'h23: phase_inc <= 32'd7389128;\n          8'h24: phase_inc <= 32'd8165376;\n        endcase\n        tone <= $signed({{(N-1){phase_acc[31]}}, (phase_acc[31:0]) * 2**(N-1)})>>>0;\n      end\n      2'b01: begin // sine wave\n        phase_inc <= 32'd1572864 * freq;\n        tone <= $signed({{(N-1){phase_acc[31]}}, (phase_acc[31:0]) * 2**(N-1)})>>>0;\n      end\n      2'b10: begin // square wave\n        phase_inc <= 32'd1572864 * freq;\n        if (phase_acc[31]) begin\n          tone <= (N-1);\n        end else begin\n          tone <= -(N-1);\n        end\n      end\n    endcase\n  end\nend\n\nendmodule",
        "module_name": "tone_generator",
        "module_hash": "56dae1f490d031d8941cc5c76f58c9ce",
        "dataset_index": 2679
      },
      "priority_encoder #_7ecb53cf": {
        "rtl_code": "\n\n\nmodule priority_encoder #\n(\n    parameter WIDTH = 4,\n    parameter LSB_HIGH_PRIORITY = 0\n)\n(\n    input  wire [WIDTH-1:0]         input_unencoded,\n    output wire                     output_valid,\n    output wire [$clog2(WIDTH)-1:0] output_encoded,\n    output wire [WIDTH-1:0]         output_unencoded\n);\n\nparameter LEVELS = WIDTH > 2 ? $clog2(WIDTH) : 1;\nparameter W = 2**LEVELS;\n\nwire [W-1:0] input_padded = {{W-WIDTH{1'b0}}, input_unencoded};\n\nwire [W/2-1:0] stage_valid[LEVELS-1:0];\nwire [W/2-1:0] stage_enc[LEVELS-1:0];\n\ngenerate\n    genvar l, n;\n\n    for (n = 0; n < W/2; n = n + 1) begin : loop_in\n        assign stage_valid[0][n] = |input_padded[n*2+1:n*2];\n        if (LSB_HIGH_PRIORITY) begin\n            assign stage_enc[0][n] = !input_padded[n*2+0];\n        end else begin\n            assign stage_enc[0][n] = input_padded[n*2+1];\n        end\n    end\n\n    for (l = 1; l < LEVELS; l = l + 1) begin : loop_levels\n        for (n = 0; n < W/(2*2**l); n = n + 1) begin : loop_compress\n            assign stage_valid[l][n] = |stage_valid[l-1][n*2+1:n*2];\n            if (LSB_HIGH_PRIORITY) begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+0] ? {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]} : {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]};\n            end else begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+1] ? {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]} : {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]};\n            end\n        end\n    end\nendgenerate\n\nassign output_valid = stage_valid[LEVELS-1];\nassign output_encoded = stage_enc[LEVELS-1];\nassign output_unencoded = 1 << output_encoded;\n\nendmodule\n",
        "module_name": "priority_encoder #",
        "module_hash": "7ecb53cf5b3fe3aaa9df3c5484e63f12",
        "dataset_index": 24978
      },
      "inverter_d8427f65": {
        "rtl_code": "module inverter (\n  input [(1 - 1):0] ip,\n  output [(1 - 1):0] op,\n  input clk,\n  input ce,\n  input clr);\n\n  reg [(1 - 1):0] op_reg;\n\n  always @(posedge clk) begin\n    if (ce) begin\n      op_reg <= ~ip;\n    end\n  end\n\n  assign op = clr ? 1'b0 : op_reg;\n\nendmodule",
        "module_name": "inverter",
        "module_hash": "d8427f6544413783e9d973b5e996d22a",
        "dataset_index": 11781
      },
      "calculator_ccfa0038": {
        "rtl_code": "module calculator(a, b, op, result);\n\ninput [7:0] a;\ninput [7:0] b;\ninput [1:0] op;\noutput reg [7:0] result;\n\nalways @(*) begin\n    case (op)\n        2'b00: result = a + b; // addition\n        2'b01: result = a - b; // subtraction\n        2'b10: result = a * b; // multiplication\n        2'b11: begin // division\n            if (b == 0) begin\n                result = 8'h00; // division by zero\n            end else begin\n                result = a / b; // quotient\n                result = result << 8; // shift quotient to MSB\n                result = result | (a % b); // add remainder to LSB\n            end\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "ccfa0038a9c747c3b97b45d068c16576",
        "dataset_index": 6910
      },
      "mig_7series_v1_9_ddr_prbs_gen #_f0cec6f8": {
        "rtl_code": "\n\nmodule mig_7series_v1_9_ddr_prbs_gen #\n  (\n   parameter TCQ         = 100,        parameter PRBS_WIDTH  = 64          )\n  (\n   input                      clk_i,          input                      clk_en_i,       input                      rst_i,          input [PRBS_WIDTH-1:0]     prbs_seed_i,    input                      phy_if_empty,   input                      prbs_rdlvl_start, output [PRBS_WIDTH-1:0]    prbs_o );\n\n  function integer clogb2 (input integer size);\n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n        size = size >> 1;\n    end\n  endfunction\n  \n  localparam PRBS_SEQ_LEN_CYCLES = 128;\n  localparam PRBS_SEQ_LEN_CYCLES_BITS = clogb2(PRBS_SEQ_LEN_CYCLES);\n  \n  reg                                 phy_if_empty_r;\n  reg                                 reseed_prbs_r;\n  reg [PRBS_SEQ_LEN_CYCLES_BITS-1:0]  sample_cnt_r;\n  reg [PRBS_WIDTH - 1 :0]             prbs;  \n  reg [PRBS_WIDTH :1]                 lfsr_q;\n  \n  always @(posedge clk_i) begin\n    phy_if_empty_r <= #TCQ phy_if_empty;\n  end\n\n  always @(posedge clk_i)\n  begin\n    if (rst_i || ~clk_en_i) begin\n      sample_cnt_r    <= #TCQ 'b0;\n      reseed_prbs_r   <= #TCQ 1'b0;\n    end else if (clk_en_i && (~phy_if_empty_r || ~prbs_rdlvl_start)) begin\n      sample_cnt_r    <= #TCQ sample_cnt_r + 1;\n      if (sample_cnt_r == PRBS_SEQ_LEN_CYCLES - 2)\n        reseed_prbs_r <= #TCQ 1'b1;\n      else\n        reseed_prbs_r <= #TCQ 1'b0;\n    end\n  end\n\n  always @ (posedge clk_i)\n  begin\nif ((reseed_prbs_r && clk_en_i) || rst_i || ~clk_en_i) begin\n      lfsr_q[4:1]          <= #TCQ prbs_seed_i[3:0] | 4'h5;\n      lfsr_q[PRBS_WIDTH:5] <= #TCQ prbs_seed_i[PRBS_WIDTH-1:4];\n    end\n    else if (clk_en_i && (~phy_if_empty_r || ~prbs_rdlvl_start)) begin\n      lfsr_q[PRBS_WIDTH:31] <= #TCQ lfsr_q[PRBS_WIDTH-1:30];\n      lfsr_q[30]            <= #TCQ lfsr_q[16] ^ lfsr_q[13] ^ lfsr_q[5]  ^ lfsr_q[1];\n      lfsr_q[29:9]          <= #TCQ lfsr_q[28:8];\n      lfsr_q[8]             <= #TCQ lfsr_q[32] ^ lfsr_q[7];\n      lfsr_q[7]             <= #TCQ lfsr_q[32] ^ lfsr_q[6];\n      lfsr_q[6:4]           <= #TCQ lfsr_q[5:3];\n      lfsr_q[3]             <= #TCQ lfsr_q[32] ^ lfsr_q[2];\n      lfsr_q[2]             <= #TCQ lfsr_q[1] ;\n      lfsr_q[1]             <= #TCQ lfsr_q[32];\n    end\n  end\n \n  always @ (lfsr_q[PRBS_WIDTH:1]) begin\n    prbs = lfsr_q[PRBS_WIDTH:1];\n  end\n\n  assign prbs_o = prbs;\n\nendmodule\n   \n         \n",
        "module_name": "mig_7series_v1_9_ddr_prbs_gen #",
        "module_hash": "f0cec6f811660ff6efabc637bd17e608",
        "dataset_index": 25735
      },
      "Convolutional_Encoder_Viterbi_Decoder #_96a533d9": {
        "rtl_code": "module Convolutional_Encoder_Viterbi_Decoder #(\n  parameter k = 1, // number of input bits in each group\n  parameter n = 2, // number of output bits in each group\n  parameter p = 2, // number of bits in the encoder's shift register\n  parameter m = 2 // number of bits in the decoder's shift register\n)(\n  input [k-1:0] in,\n  output reg [n-1:0] enc_out,\n  output reg [k-1:0] dec_out\n);\n\nreg [p-1:0] shift_reg; // encoder's shift register\nreg [m-1:0] dec_reg; // decoder's shift register\n\n// Encoder mapping function\nfunction [n-1:0] encode;\n  input [k-1:0] data;\n  begin\n    case (data)\n      0: encode = {1'b1, 1'b0};\n      1: encode = {1'b0, 1'b1};\n      2: encode = {1'b1, 1'b1};\n      3: encode = {1'b0, 1'b0};\n    endcase\n  end\nendfunction\n\n// Decoder decoding algorithm\nfunction [k-1:0] decode;\n  input [n-1:0] data;\n  begin\n    if (data == {1'b1, 1'b0}) decode = 1'b0;\n    else if (data == {1'b0, 1'b1}) decode = 1'b1;\n    else if (data == {1'b1, 1'b1}) decode = 2'b10;\n    else if (data == {1'b0, 1'b0}) decode = 2'b11;\n  end\nendfunction\n\n// Encoder process\nalways @(in) begin\n  shift_reg = {in, shift_reg[p-1:1]}; // shift in new input bit\n  enc_out = encode(shift_reg); // encode input data\nend\n\n// Decoder process\nalways @(enc_out) begin\n  dec_reg = {enc_out, dec_reg[m-1:1]}; // shift in new encoded bit\n  dec_out = decode(dec_reg); // decode encoded data\nend\n\nendmodule",
        "module_name": "Convolutional_Encoder_Viterbi_Decoder #",
        "module_hash": "96a533d9e72e869877f85409417157d7",
        "dataset_index": 511
      },
      "calculator_5e9bdb44": {
        "rtl_code": "module calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input [7:0] num1,\n    input [7:0] num2,\n    output reg [7:0] result,\n    output reg overflow,\n    output reg divide_by_zero\n);\n\nreg [15:0] product;\nreg [15:0] quotient;\nreg [15:0] dividend;\nreg [7:0] divisor;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 8'b0;\n        overflow <= 1'b0;\n        divide_by_zero <= 1'b0;\n    end\n    else begin\n        case (op)\n            2'b00: begin // addition\n                result <= num1 + num2;\n                overflow <= (result[7] != num1[7]) && (result[7] != num2[7]);\n                divide_by_zero <= 1'b0;\n            end\n            2'b01: begin // subtraction\n                result <= num1 - num2;\n                overflow <= (result[7] != num1[7]) && (result[7] == num2[7]);\n                divide_by_zero <= 1'b0;\n            end\n            2'b10: begin // multiplication\n                product <= num1 * num2;\n                if (product[15:8] != 8'b0) begin // overflow\n                    overflow <= 1'b1;\n                    result <= 8'b0;\n                end\n                else begin\n                    overflow <= 1'b0;\n                    result <= product[7:0];\n                end\n                divide_by_zero <= 1'b0;\n            end\n            2'b11: begin // division\n                if (num2 == 8'b0) begin // divide by zero\n                    divide_by_zero <= 1'b1;\n                    result <= 8'b0;\n                end\n                else begin\n                    divide_by_zero <= 1'b0;\n                    dividend <= {num1, 8'b0};\n                    divisor <= {num2, 8'b0};\n                    quotient <= dividend / divisor;\n                    if (quotient[15:8] != 8'b0) begin // overflow\n                        overflow <= 1'b1;\n                        result <= 8'b0;\n                    end\n                    else begin\n                        overflow <= 1'b0;\n                        result <= quotient[7:0];\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "5e9bdb445cc8cf6b664594a5f31dc9ab",
        "dataset_index": 5590
      },
      "axi_dwidth_converter_v2_1_7_b_downsizer #_cb6abe21": {
        "rtl_code": "\n\n \nmodule axi_dwidth_converter_v2_1_7_b_downsizer #\n  (\n   parameter         C_FAMILY                         = \"none\", \n                       parameter integer C_AXI_ID_WIDTH                   = 1\n                       )\n  (\n   input  wire                                                    ARESET,\n   input  wire                                                    ACLK,\n\n   input  wire                              cmd_valid,\n   input  wire                              cmd_split,\n   input  wire [8-1:0]                      cmd_repeat,\n   output wire                              cmd_ready,\n   input  wire [C_AXI_ID_WIDTH-1:0]         cmd_id,\n   \n   output wire [C_AXI_ID_WIDTH-1:0]           S_AXI_BID,\n   output wire [2-1:0]                          S_AXI_BRESP,\n   output wire                                                    S_AXI_BVALID,\n   input  wire                                                    S_AXI_BREADY,\n\n   input  wire [2-1:0]                         M_AXI_BRESP,\n   input  wire                                                   M_AXI_BVALID,\n   output wire                                                   M_AXI_BREADY\n   );\n  \n  \n  localparam [2-1:0] C_RESP_OKAY        = 2'b00;\n  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;\n  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;\n  localparam [2-1:0] C_RESP_DECERR      = 2'b11;\n  \n  \n  wire                            cmd_ready_i;\n  wire                            pop_mi_data;\n  wire                            mi_stalling;\n  \n  reg  [8-1:0]                    repeat_cnt_pre;\n  reg  [8-1:0]                    repeat_cnt;\n  wire [8-1:0]                    next_repeat_cnt;\n  reg                             first_mi_word;\n  wire                            last_word;\n  \n  wire                            load_bresp;\n  wire                            need_to_update_bresp;\n  reg  [2-1:0]                    S_AXI_BRESP_ACC;\n  \n  wire                            M_AXI_BREADY_I;\n  \n  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_BID_I;\n  reg  [2-1:0]                    S_AXI_BRESP_I;\n  wire                            S_AXI_BVALID_I;\n  wire                            S_AXI_BREADY_I;\n  \n  \n  assign M_AXI_BREADY_I = ~mi_stalling;\n  assign M_AXI_BREADY   = M_AXI_BREADY_I;\n  \n  assign S_AXI_BVALID_I = M_AXI_BVALID & last_word;\n  \n  assign pop_mi_data    = M_AXI_BVALID & M_AXI_BREADY_I;\n  \n  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;\n  assign cmd_ready      = cmd_ready_i;\n  \n  assign mi_stalling    = (~S_AXI_BREADY_I & last_word);\n                          \n  \n  assign load_bresp           = (cmd_split & first_mi_word);\n  \n  assign need_to_update_bresp = ( M_AXI_BRESP > S_AXI_BRESP_ACC );\n  \n  always @ *\n  begin\n    if ( cmd_split ) begin\n      if ( load_bresp || need_to_update_bresp ) begin\n        S_AXI_BRESP_I = M_AXI_BRESP;\n      end else begin\n        S_AXI_BRESP_I = S_AXI_BRESP_ACC;\n      end\n    end else begin\n      S_AXI_BRESP_I = M_AXI_BRESP;\n    end\n  end\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      S_AXI_BRESP_ACC <= C_RESP_OKAY;\n    end else begin\n      if ( pop_mi_data ) begin\n        S_AXI_BRESP_ACC <= S_AXI_BRESP_I;\n      end\n    end\n  end\n  \n  \n  assign last_word  = ( ( repeat_cnt == 8'b0 ) & ~first_mi_word ) | \n                      ~cmd_split;\n  \n  always @ *\n  begin\n    if ( first_mi_word ) begin\n      repeat_cnt_pre  =  cmd_repeat;\n    end else begin\n      repeat_cnt_pre  =  repeat_cnt;\n    end\n  end\n  \n  assign next_repeat_cnt  = repeat_cnt_pre - 2'b01;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      repeat_cnt    <= 8'b0;\n      first_mi_word <= 1'b1;\n    end else begin\n      if ( pop_mi_data ) begin\n        repeat_cnt    <= next_repeat_cnt;\n        first_mi_word <= last_word;\n      end\n    end\n  end\n  \n  \n  assign S_AXI_BID_I  = cmd_id;\n  \n    assign S_AXI_BID      = S_AXI_BID_I;\n  assign S_AXI_BRESP    = S_AXI_BRESP_I;\n  assign S_AXI_BVALID   = S_AXI_BVALID_I;\n  assign S_AXI_BREADY_I = S_AXI_BREADY;\n  \n  \nendmodule\n",
        "module_name": "axi_dwidth_converter_v2_1_7_b_downsizer #",
        "module_hash": "cb6abe2105e436f717da82433c0eda11",
        "dataset_index": 24288
      },
      "camera_fd7833b0": {
        "rtl_code": "\n\nmodule camera \n(\n\tinput refclk,\n\tinput reset_n,\n\n\toutput pixclk,\n\toutput vsync,\n\toutput hsync,\n\toutput [7:0] data\n\n);\n\nreg [12:0] hs_counter = 0;\nreg [9:0] vs_counter = 0;\n\nassign pixclk = refclk;\n\nalways @(negedge refclk)\nbegin\n\tif(reset_n == 0)\n\t\tbegin\n\t\t\ths_counter = 0;\n\t\t\tvs_counter = 0;\n\t\tend\n\telse\n\t\tbegin\n\t\t\tif(hs_counter == 1567)\n\t\t\tbegin\n\t\t\t\ths_counter <= 0;\n\t\t\t\t\n\t\t\t\tif(vs_counter == 510)\n\t\t\t\t\tvs_counter <= 0;\n\t\t\t\telse\n\t\t\t\t\tvs_counter <= vs_counter + 1;\n\t\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\ths_counter <= hs_counter + 1;\n\t\tend\n\t\t\nend\n\nreg clk2 = 0;\n\nalways@(negedge refclk)\nclk2 <= !clk2;\n\nreg [16:0] pixel_counter = 0;\n\nalways@(posedge clk2)\nbegin\n\tif(hs_counter == 1566)\n\t\tpixel_counter <= 0;\n\telse\n\t\tpixel_counter <= pixel_counter + 1;\nend\n\nreg [7:0] temp_data;\n\nwire [15:0] line_counter;\n\nreg [15:0] line_counter_2;\n\nreg data_part = 0;\n\nalways@(negedge refclk)\nbegin\nif(reset_n == 0)\n\tbegin\n\t\tdata_part <= 0;\n\t\ttemp_data <= 0;\n\tend\nelse\nbegin\n\tif(!clk2)\n\t\ttemp_data[7:0] <= pixel_counter[15:8];\n\telse\n\t\ttemp_data[7:0] <= pixel_counter[7:0];\n\nend\n\nend\n\nassign data = temp_data;\n\nassign vsync = vs_counter < 3 && reset_n != 0 ? 1 : 0;\nassign hsync = vs_counter > 19 && vs_counter < 500 && hs_counter < 1280 && reset_n != 0 ? 1 : 0;\n\nendmodule\n\n",
        "module_name": "camera",
        "module_hash": "fd7833b0b65159a7614f7e27b9b845ed",
        "dataset_index": 19709
      },
      "limbus_cpu_cpu_nios2_oci_dtrace_74dc13e0": {
        "rtl_code": "module limbus_cpu_cpu_nios2_oci_dtrace (\n  // inputs:\n  input clk,\n  input [21:0] cpu_d_address,\n  input cpu_d_read,\n  input [31:0] cpu_d_readdata,\n  input cpu_d_wait,\n  input cpu_d_write,\n  input [31:0] cpu_d_writedata,\n  input jrst_n,\n  input [15:0] trc_ctrl,\n\n  // outputs:\n  output reg [35:0] atm,\n  output reg [35:0] dtm\n);\n\n  wire [31:0] cpu_d_address_0_padded;\n  wire [31:0] cpu_d_readdata_0_padded;\n  wire [31:0] cpu_d_writedata_0_padded;\n  wire dummy_tie_off;\n  wire record_load_addr;\n  wire record_load_data;\n  wire record_store_addr;\n  wire record_store_data;\n  wire [3:0] td_mode_trc_ctrl;\n\n  assign cpu_d_writedata_0_padded = {cpu_d_writedata, 32'b0};\n  assign cpu_d_readdata_0_padded = {cpu_d_readdata, 32'b0};\n  assign cpu_d_address_0_padded = {cpu_d_address, 32'b0};\n\n  //limbus_cpu_cpu_nios2_oci_trc_ctrl_td_mode, which is an e_instance\n  //limbus_cpu_cpu_nios2_oci_td_mode limbus_cpu_cpu_nios2_oci_trc_ctrl_td_mode\n  //  (\n  //    .ctrl    (trc_ctrl[8 : 0]),\n  //    .td_mode (td_mode_trc_ctrl)\n  //  );\n\n  assign {record_load_addr, record_store_addr,\n         record_load_data, record_store_data} = td_mode_trc_ctrl;\n\n  always @ (posedge clk or negedge jrst_n) begin\n    if (jrst_n == 0) begin\n      atm <= 0;\n      dtm <= 0;\n    end else begin\n      if (cpu_d_read) begin\n        atm <= cpu_d_address;\n        dtm <= cpu_d_readdata;\n      end else if (cpu_d_write) begin\n        atm <= cpu_d_address;\n        dtm <= cpu_d_writedata;\n      end else if (cpu_d_wait) begin\n        atm <= 0;\n        dtm <= 0;\n      end\n    end\n  end\n\n  assign dummy_tie_off = cpu_d_wait | cpu_d_read | cpu_d_write;\n\nendmodule",
        "module_name": "limbus_cpu_cpu_nios2_oci_dtrace",
        "module_hash": "74dc13e0ac1db2951a1a1e0e6efef55e",
        "dataset_index": 9565
      },
      "clock_gate_5e55771e": {
        "rtl_code": "module clock_gate(\n  input CLK, // clock signal\n  input EN, // enable signal\n  input TE, // test enable signal\n  output ENCLK // gated clock signal\n);\n\n  reg gated_clk;\n  \n  always @(*) begin\n    if (TE) begin\n      gated_clk = 1;\n    end else if (EN) begin\n      gated_clk = CLK;\n    end else begin\n      gated_clk = 0;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "5e55771e7689ebef032b03ebbb465655",
        "dataset_index": 9503
      },
      "alu_f304fc95": {
        "rtl_code": "\nmodule alu(\n    output reg [31:0] ALUResult,\n    output reg Zero,\n    input [31:0] A,\n    input [31:0] B,\n    input [2:0] control\n);\n    wire [31:0] notB, muxBout, S, andResult, orResult, SLT;\n\n    wire Cout;\n\n    assign notB = ~B;\n\n    assign muxBout = (control[2]) ? notB : B;\n\n    assign {Cout, S} = muxBout + A + control[2]; assign andResult = A & muxBout;\n    assign orResult = A | muxBout;\n    assign SLT = {{31{1'b0}}, {S[31]}}; always @ (control[1:0] or andResult or orResult or S or SLT or ALUResult) begin\n        case(control[1:0])\n            2'b00: ALUResult = andResult;\n            2'b01: ALUResult = orResult;\n            2'b10: ALUResult = S;\n            2'b11: ALUResult = SLT;\n        endcase\n\n        if (ALUResult == 32'h00000000) begin\n            Zero <= 1;\n        end else begin\n            Zero <= 0;\n        end\n    end\n\nendmodule\n",
        "module_name": "alu",
        "module_hash": "f304fc95f0993bfd6f746d0a7c86fe64",
        "dataset_index": 23501
      },
      "data_transfer_4fe337b3": {
        "rtl_code": "\nmodule data_transfer(\n  input CLK,\n  input RESET_L,\n  input writeRead_Regs_DATA,\n  input [3:0] blockCount_Regs_DATA,\n  input multipleData_Regs_DATA,\n  input timeout_Enable_Regs_DATA,\n  input [15:0] timeout_Reg_Regs_DATA,\n  input new_DAT_DMA_DATA,\n  input serial_Ready_Phy_DATA,\n  output reg timeout_Phy_DATA,\n  output reg complete_Phy_DATA,\n  input ack_IN_Phy_DATA,\n  input fifo_OK_FIFO_DATA,\n  output reg ack_OUT_DATA_Phy,\n  output reg [3:0] blocks_DATA_Phy,\n  output reg idle_out_DATA_Phy,\n  output reg multiple_DATA_Phy,\n  output reg strobe_OUT_DATA_Phy,\n  output reg [15:0] timeout_value_DATA_Phy,\n  output reg transfer_complete_DATA_DMA,\n  output reg writeReadPhysical_DATA_Phy\n);\n\n  reg [15:0] timeout_counter;\n  reg [3:0] block_count;\n  reg timeout_enable;\n  reg multiple_data;\n  reg write_read;\n\n  always @(posedge CLK) begin\n    if (RESET_L == 0) begin\n      timeout_counter <= 0;\n      block_count <= 0;\n      timeout_enable <= 0;\n      multiple_data <= 0;\n      write_read <= 0;\n      ack_OUT_DATA_Phy <= 0;\n      blocks_DATA_Phy <= 0;\n      idle_out_DATA_Phy <= 1;\n      strobe_OUT_DATA_Phy <= 0;\n      transfer_complete_DATA_DMA <= 0;\n      writeReadPhysical_DATA_Phy <= 0;\n      multiple_DATA_Phy <= 0;\n    end else begin\n      if (timeout_enable) begin\n        if (timeout_counter < timeout_Reg_Regs_DATA) begin\n          timeout_counter <= timeout_counter + 1;\n        end else begin\n          timeout_counter <= 0;\n          timeout_enable <= 0;\n          timeout_Phy_DATA <= 1'b1;\n        end\n      end\n      if (new_DAT_DMA_DATA && serial_Ready_Phy_DATA && !timeout_enable && !transfer_complete_DATA_DMA) begin\n        timeout_counter <= 0;\n        timeout_enable <= timeout_Enable_Regs_DATA;\n        write_read <= writeRead_Regs_DATA;\n        block_count <= blockCount_Regs_DATA;\n        multiple_data <= multipleData_Regs_DATA;\n        writeReadPhysical_DATA_Phy <= writeRead_Regs_DATA;\n        blocks_DATA_Phy <= blockCount_Regs_DATA;\n        idle_out_DATA_Phy <= 1'b0;\n        strobe_OUT_DATA_Phy <= 1'b1;\n        multiple_DATA_Phy <= 1'b1;\n      end\n      if (ack_IN_Phy_DATA && !timeout_enable && !transfer_complete_DATA_DMA) begin\n        if (block_count == 0) begin\n          transfer_complete_DATA_DMA <= 1'b1;\n          idle_out_DATA_Phy <= 1'b1;\n        end else begin\n          block_count <= block_count - 1;\n          blocks_DATA_Phy <= block_count - 1;\n          strobe_OUT_DATA_Phy <= 1'b1;\n        end\n        multiple_DATA_Phy <= 1'b0;\n      end\n      if (fifo_OK_FIFO_DATA && !timeout_enable && !transfer_complete_DATA_DMA) begin\n        ack_OUT_DATA_Phy <= 1'b1;\n      end\n      if (transfer_complete_DATA_DMA) begin\n        complete_Phy_DATA <= 1'b1;\n      end\n      timeout_value_DATA_Phy <= timeout_counter;\n    end\n  end\n\nendmodule",
        "module_name": "data_transfer",
        "module_hash": "4fe337b39237fe84924b21e7b51a31dd",
        "dataset_index": 18050
      },
      "byte_reverse_a3284e11": {
        "rtl_code": "module byte_reverse (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n\nmodule top_module (\n    input [31:0] in,\n    input [2:0] sel, \n    input [7:0] data0,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    input [7:0] data4,\n    input [7:0] data5,\n    output [7:0] out\n);\n\n    wire [31:0] reversed_in;\n    byte_reverse byte_reverse_inst (\n        .in(in),\n        .out(reversed_in)\n    );\n\n    wire [7:0] and_output;\n    assign and_output = data0[1:0] & data1[1:0] & data2[1:0] & data3[1:0] & data4[1:0] & data5[1:0];\n\n    wire [7:0] mux_output;\n    assign mux_output = (sel == 0) ? data0 :\n                        (sel == 1) ? data1 :\n                        (sel == 2) ? data2 :\n                        (sel == 3) ? data3 :\n                        (sel == 4) ? data4 :\n                        (sel == 5) ? data5 :\n                        (sel == 6 || sel == 7) ? and_output :\n                        8'b0;\n\n    wire [7:0] add_output;\n    assign add_output = reversed_in[7:0] + mux_output;\n\n    assign out = add_output;\n\nendmodule",
        "module_name": "byte_reverse",
        "module_hash": "a3284e117a6d25081c33960be47af442",
        "dataset_index": 4023
      },
      "clk_div_e797b0b4": {
        "rtl_code": "module clk_div(\n\tinput wire clk,\n\tinput wire rst,\n\tinput wire SW2,\n\toutput reg [31:0] clkdiv,\n\toutput wire Clk_CPU\n);\n\n\tinitial clkdiv <= 0;\n\talways @ (posedge clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\tclkdiv <= 0;\n\t\tend else begin\n\t\t\tclkdiv <= clkdiv + 1'b1;\n\t\tend\n\tend\n\tassign Clk_CPU = SW2 ? clkdiv[22] : clkdiv[1];\n\nendmodule",
        "module_name": "clk_div",
        "module_hash": "e797b0b4118d6ca87d41e5bd22578a6f",
        "dataset_index": 11879
      },
      "sky130_fd_sc_lp__a41oi_5ce3d454": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a41oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2, A3, A4 );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a41oi",
        "module_hash": "5ce3d454c0b6730ccfbdf78557b1569a",
        "dataset_index": 5495
      },
      "top__5da720a9": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input [31:0] in,\n    output [15:0] q,\n    output [3:0] ena\n);\n\nwire [31:0] transition_detected;\nwire [15:0] bcd_counter;\n\n// Detect 1 to 0 transitions\ntransition_detector td (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(transition_detected)\n);\n\n// BCD counter\nbcd_counter bc (\n    .clk(clk),\n    .reset(reset),\n    .ena(ena[3]),\n    .out(bcd_counter)\n);\n\n// Max value selector\nmax_value_selector mvs (\n    .in1(transition_detected),\n    .in2(bcd_counter),\n    .out(q)\n);\n\nassign ena = 4'b0; // Fix the undriven wires\n\nendmodule\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nreg [31:0] in_prev;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        in_prev <= 32'b0;\n    end else begin\n        in_prev <= in;\n    end\nend\n\nassign out = in_prev & ~in;\n\nendmodule\nmodule bcd_counter (\n    input clk,\n    input reset,\n    input ena,\n    output [15:0] out\n);\n\nreg [15:0] count;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'b0;\n    end else if (ena) begin\n        count <= count + 1'b1;\n        if (count == 16'h9999) begin\n            count <= 16'b0;\n        end\n    end\nend\n\nassign out = count;\n\nendmodule\nmodule max_value_selector (\n    input [31:0] in1,\n    input [15:0] in2,\n    output [15:0] out\n);\n\nassign out = (in1 > in2) ? in1[15:0] : in2;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "5da720a9ac080f258c95b0372220a33f",
        "dataset_index": 13853
      },
      "expand_message_36ddb5c6": {
        "rtl_code": "\nmodule expand_message (\n\tinput clk,\n\tinput [56-1:0] rx_fixed_data,\n\tinput [59:0] rx_nonce,\n\toutput reg [511:0] tx_expanded_message\n);\n\n\tparameter IDX_0 = 56'd0;\n\tparameter IDX_1 = 56'd1;\n\tparameter IDX_2 = 56'd2;\n\tparameter IDX_3 = 56'd3;\n\tparameter IDX_4 = 56'd4;\n\tparameter IDX_5 = 56'd5;\n\tparameter IDX_6 = 56'd6;\n\n\tparameter IDX4_0 = 60'd0;\n\tparameter IDX4_1 = 60'd1;\n\tparameter IDX4_2 = 60'd2;\n\tparameter IDX4_3 = 60'd3;\n\tparameter IDX4_4 = 60'd4;\n\tparameter IDX4_5 = 60'd5;\n\tparameter IDX4_6 = 60'd6;\n\tparameter IDX4_7 = 60'd7;\n\tparameter IDX4_8 = 60'd8;\n\tparameter IDX4_9 = 60'd9;\n\tparameter IDX4_10 = 60'd10;\n\tparameter IDX4_11 = 60'd11;\n\tparameter IDX4_12 = 60'd12;\n\tparameter IDX4_13 = 60'd13;\n\tparameter IDX4_14 = 60'd14;\n\n\talways @ (posedge clk)\n\tbegin\n\t\ttx_expanded_message <= {32'd192, 32'h0, 224'h0, 32'h80000000, rx_fixed_data[IDX_2], rx_fixed_data[IDX_1], rx_fixed_data[IDX_0], 8'h00, rx_fixed_data[IDX_6], rx_fixed_data[IDX_5], rx_fixed_data[IDX_4], rx_fixed_data[IDX_3], {4'b0,rx_nonce[IDX4_2]}, {4'b0,rx_nonce[IDX4_1]}, {4'b0,rx_nonce[IDX4_0]}, 8'h00, {4'b0,rx_nonce[IDX4_6]}, {4'b0,rx_nonce[IDX4_5]}, {4'b0,rx_nonce[IDX4_4]}, {4'b0,rx_nonce[IDX4_3]}, {4'b0,rx_nonce[IDX4_10]}, {4'b0,rx_nonce[IDX4_9]}, {4'b0,rx_nonce[IDX4_8]}, {4'b0,rx_nonce[IDX4_7]}, {4'b0,rx_nonce[IDX4_14]}, {4'b0,rx_nonce[IDX4_13]}, {4'b0,rx_nonce[IDX4_12]}, {4'b0,rx_nonce[IDX4_11]}};\n\tend\n\nendmodule",
        "module_name": "expand_message",
        "module_hash": "36ddb5c633d6b126c344d2098096ff29",
        "dataset_index": 5449
      },
      "my__dd7cccb8": {
        "rtl_code": "\nmodule my_module (\n   input in,\n   input clk,\n   output reg fr_a,\n   output reg fr_b,\n   output reg fr_chk\n   );\n\n   always @(posedge clk) begin\n      fr_a <= in;\n      fr_b <= in;\n      fr_chk <= in + 1;\n   end\n\nendmodule",
        "module_name": "my_",
        "module_hash": "dd7cccb8cdc7863b447a627e4eaf80c5",
        "dataset_index": 13357
      },
      "parity_checker_6747afaf": {
        "rtl_code": "\nmodule parity_checker (\n  input clk,\n  input [3:0] data,\n  output reg parity\n);\n\n  reg [1:0] stage1_data [0:1];\n  wire [1:0] stage2_data [0:1];\n  \n  always @ (posedge clk) begin\n    stage1_data[1] <= stage1_data[0];\n    stage1_data[0] <= data;\n  end\n  \n  assign stage2_data[1] = stage1_data[1] ^ stage1_data[0];\n  assign stage2_data[0] = 2'b00;\n  \n  always @ (posedge clk) begin\n    parity <= stage2_data[1][0] ^ stage2_data[1][1];\n  end\n  \nendmodule\n",
        "module_name": "parity_checker",
        "module_hash": "6747afaf75fbe1b5fd032d567d076511",
        "dataset_index": 17092
      },
      "xor_nand_ceb83d7b": {
        "rtl_code": "\nmodule xor_nand (\n    input a,\n    input b,\n    output out\n);\n\n    wire nand1;\n\n    assign nand1 = ~(a & b);\n    assign out = ~nand1;\n\nendmodule\n",
        "module_name": "xor_nand",
        "module_hash": "ceb83d7bd969b6c4ef58a009157fa0d9",
        "dataset_index": 17722
      },
      "td_mode__3f2039b4": {
        "rtl_code": "module td_mode_module (\n  input [8:0] ctrl,\n  output reg [3:0] td_mode\n);\n\n  wire [2:0] ctrl_bits_for_mux;\n  assign ctrl_bits_for_mux = ctrl[7:5];\n\n  always @(*) begin\n    case (ctrl_bits_for_mux)\n      3'b000: td_mode = 4'b0000;\n      3'b001: td_mode = 4'b1000;\n      3'b010: td_mode = 4'b0100;\n      3'b011: td_mode = 4'b1100;\n      3'b100: td_mode = 4'b0010;\n      3'b101: td_mode = 4'b1010;\n      3'b110: td_mode = 4'b0101;\n      3'b111: td_mode = 4'b1111;\n    endcase\n  end\n  \nendmodule",
        "module_name": "td_mode_",
        "module_hash": "3f2039b4dd643dac3d0239c52a0d4184",
        "dataset_index": 9694
      },
      "altera_mem_if_ddr3_phy_0001_hr_to_fr_9663c9fe": {
        "rtl_code": "module altera_mem_if_ddr3_phy_0001_hr_to_fr(\n    clk,\n    d_h0,\n    d_h1,\n    d_l0,\n    d_l1,\n    q0,\n    q1\n);\n\ninput   clk;\ninput   d_h0;\ninput   d_h1;\ninput   d_l0;\ninput   d_l1;\noutput  q0;\noutput  q1;\n\nreg q_h0;\nreg q_h1;\nreg q_l0;\nreg q_l1;\nreg q_l0_neg;\nreg q_l1_neg;\n\nalways @(posedge clk)\nbegin\n    q_h0 <= d_h0;\n    q_l0 <= d_l0;\n    q_h1 <= d_h1;\n    q_l1 <= d_l1;\nend\n\nalways @(negedge clk)\nbegin\n    q_l0_neg <= ~q_l0;\n    q_l1_neg <= ~q_l1;\nend\n\nassign q0 = clk ? q_l0_neg : q_h0;\nassign q1 = clk ? q_l1_neg : q_h1;\n\nendmodule",
        "module_name": "altera_mem_if_ddr3_phy_0001_hr_to_fr",
        "module_hash": "9663c9feb0e4fe75d5d69ad65d247ba2",
        "dataset_index": 11949
      },
      "sequencer_3c58b7f8": {
        "rtl_code": "\n\nmodule sequencer\n  (\n   input \t\t  clock,\n   input \t\t  reset,\n   output \t\t  fpc_read,\n   input \t\t  fpc_valid,\n   input [63:0] \t  fpc_data,\n   input \t\t  tpc_ready,\n   output \t\t  tpc_write,\n   output [63:0] \t  tpc_data,\n   output reg \t\t  rvalid = 0,\n   output reg \t\t  wvalid = 0,\n   output reg [ABITS-1:0] address = 0,\n   output reg [DBITS-1:0] wdata = 0,\n   input [DBITS-1:0] \t  rdata,\n   input [SBITS-1:0] \t  status\n   );\n\n   parameter RPIPE = 2; parameter ABITS = 16; parameter DBITS = 64; parameter SBITS = 16; parameter CBITS = 24; reg [CBITS-1:0] \t  count = 32'hDEADBEEF;\n   reg [1:0] \t\t  state = 0;\n   reg \t\t\t  inc = 0;\n\n   wire \t\t  rvalid_next = (state == 3) && tpc_ready;\n   wire \t\t  wvalid_next = (state == 2) && fpc_read;\n\n   assign fpc_read = fpc_valid && ((state == 0) || (state == 2));\n\n   always @ (posedge clock)\n     begin\n\trvalid <= rvalid_next;\n\twvalid <= wvalid_next;\n\taddress <= (state == 0) ? fpc_data[ABITS-1:0] :\n\t\t   address + (inc && (rvalid || wvalid));\n\twdata <= fpc_data[DBITS-1:0];\n\tinc <= (state == 0) ? fpc_data[61] : inc;\n\tcase(state)\n\t  0: count <= fpc_data[CBITS+31:32];\n\t  1: count <= count - 1'b1;\n\t  2: count <= count - wvalid_next;\n\t  3: count <= count - rvalid_next;\n\tendcase\n\tif(reset)\n\t  state <= 2'd0;\n\telse\n\t  begin\n\t     case(state)\n\t       0: state <= fpc_read ? fpc_data[63:62] : 2'd0; default: state <= (count[CBITS-1:1] == 0) ? 2'd0 : state;\n\t     endcase\n\t  end\n     end\n   delay_n #(.N(RPIPE)) delay_tpc_write\n     (.clock(clock), .in(rvalid), .out(tpc_write));\n   assign tpc_data = rdata;\n\nendmodule\n\nmodule delay_n\n  (\n   input  clock,\n   input  in,\n   output out\n   );\n\n   parameter N = 2;\n\n   reg [N-1:0] sreg = 0;\n\n   assign out = sreg[N-1];\n\n   always @ (posedge clock)\n     sreg <= {sreg[N-2:0],in};\n\nendmodule\n",
        "module_name": "sequencer",
        "module_hash": "3c58b7f8eaea1a3c021669cf91d8fcea",
        "dataset_index": 6957
      },
      "gray_code_counter_83b8baed": {
        "rtl_code": "module gray_code_counter (\n    input CLK,\n    input RST,\n    output reg [7:0] count_gray\n);\n\n    reg [7:0] count_binary;\n    \n    always @(posedge CLK or negedge RST) begin\n        if (RST == 0) begin\n            count_binary <= 8'b00000000;\n            count_gray <= 8'b00000000;\n        end\n        else begin\n            count_binary <= count_binary + 1;\n            count_gray <= count_binary ^ (count_binary >> 1);\n        end\n    end\n    \nendmodule",
        "module_name": "gray_code_counter",
        "module_hash": "83b8baed51e5808411dba33110dda2d8",
        "dataset_index": 9176
      },
      "dff_preset_clear_d93572bf": {
        "rtl_code": "\nmodule dff_preset_clear (\n    input wire D,\n    input wire CLK,\n    input wire PRE,  // Preset\n    input wire CLR,  // Clear\n    output wire Q,\n    output wire Q_N\n);\n\n    reg [0:0] _Q;\n    assign Q = _Q[0];\n    assign Q_N = ~_Q[0];\n\n    always @(posedge CLK) begin\n        if (CLR) begin // Clear\n            _Q[0] <= 0;\n        end else if (PRE) begin // Preset\n            _Q[0] <= 1;\n        end else begin // Normal Operation\n            _Q[0] <= D;\n        end\n    end\n\nendmodule",
        "module_name": "dff_preset_clear",
        "module_hash": "d93572bf94268c6beb5d8353b376788a",
        "dataset_index": 4895
      },
      "binary_latch_with_reset_a9ef4b04": {
        "rtl_code": "module binary_latch_with_reset(\n    input CLK,\n    input RST,\n    input D,\n    output reg Q\n);\n\nalways @(posedge CLK) begin\n    if (RST == 1) begin\n        Q <= 0;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule",
        "module_name": "binary_latch_with_reset",
        "module_hash": "a9ef4b0401da2fb8ab83dbe60dae8b94",
        "dataset_index": 21094
      },
      "freq_divider_0cee4d79": {
        "rtl_code": "module freq_divider (\n  input clk_in,\n  output reg clk_out\n);\n\n  parameter n = 2; // division factor\n  \n  reg [31:0] count;\n  \n  always @(posedge clk_in) begin\n    if (count == n-1) begin\n      clk_out <= ~clk_out;\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n  \nendmodule",
        "module_name": "freq_divider",
        "module_hash": "0cee4d790da956cffc28ab143c780771",
        "dataset_index": 6332
      },
      "AND4_51a046bb": {
        "rtl_code": "\nmodule AND4(out1, in1, in2, in3, in4);\n\n  parameter gate_delay = 1; // Define gate delay parameter\n\n  input in1, in2, in3, in4;\n  output out1;\n\n  wire and1, and2;\n\n  and #(gate_delay) and1 (and2, in1, in2);\n  and #(gate_delay) and2 (out1, and2, in3, in4);\n\nendmodule",
        "module_name": "AND4",
        "module_hash": "51a046bb11ac1d6982503182b3038f6a",
        "dataset_index": 15945
      },
      "sky130_fd_sc_ls__nand4b_c8ee56c6": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__nand4b (\n    Y  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N              );\n    nand nand0 (nand0_out_Y, D, C, B, not0_out);\n    buf  buf0  (Y          , nand0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__nand4b",
        "module_hash": "c8ee56c6e3d90fc04e3b994cd0a9a70e",
        "dataset_index": 21572
      },
      "selector_module_89524ceb": {
        "rtl_code": "module selector_module(\n    input [1:0] SEL,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] OUT\n);\n\n    wire [7:0] sum, diff, prod, quo;\n    \n    assign sum = A + B;\n    assign diff = A - B;\n    assign prod = A * B;\n    assign quo = A / B;\n    \n    always @* begin\n        case (SEL)\n            2'b00: OUT = sum;\n            2'b01: OUT = diff;\n            2'b10: OUT = prod;\n            2'b11: OUT = quo;\n        endcase\n    end\n\nendmodule",
        "module_name": "selector_module",
        "module_hash": "89524ceb49980cc687353644befe94cc",
        "dataset_index": 12140
      },
      "karnaugh_map_bf0d6f7b": {
        "rtl_code": "module karnaugh_map(\n  input wire A, B, C,\n  output reg F\n);\n\n  always @(*) begin\n    case ({A,B,C})\n      3'b000: F = 1'b0;\n      3'b001: F = 1'b1;\n      3'b010: F = 1'b1;\n      3'b011: F = 1'b0;\n      3'b100: F = 1'b1;\n      3'b101: F = 1'b0;\n      3'b110: F = 1'b0;\n      3'b111: F = 1'b1;\n      default: F = 1'b0;\n    endcase\n  end\n\nendmodule",
        "module_name": "karnaugh_map",
        "module_hash": "bf0d6f7b7e9f1c49117f1adb5c6da966",
        "dataset_index": 9632
      },
      "sky130_fd_sc_hd__a31oi_9694d61d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__a31oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2     );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a31oi",
        "module_hash": "9694d61d1f1f281f0b7b5cd1943d5e52",
        "dataset_index": 5415
      },
      "flt_frac_test_1d3431aa": {
        "rtl_code": "\n\nmodule flt_frac_test\n\t(\n\tinput\t      \tclk,\n\tinput\t      \trstn,\n\tinput\t[31:0]\tafl,\n\toutput reg\tfrac_flag\n\t);\n\n\treg [47:0]\tmant;\n\talways @* begin\n\t\tif(afl[30]) mant = {1'b1, afl[22:0]} << (afl[30:23] - 127);\n\t\telse        mant = {1'b1, afl[22:0]} >> (127 - afl[30:23]);\n\tend\n\n\talways @(posedge clk, negedge rstn) begin\n\t\tif(!rstn) frac_flag <= 1'b0;\n\t\telse begin\n\t\t\tif(|mant[23:0]) frac_flag <= 1'b1;\n\t\t\telse frac_flag <= 1'b0;\n\t\t\t\n\t\t\t\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "flt_frac_test",
        "module_hash": "1d3431aad2764a782b7f33375a136363",
        "dataset_index": 23627
      },
      "arbitro_88b74814": {
        "rtl_code": "\nmodule arbitro (\n\n  input wire [2:0] pe_request_bundle,\n    input wire [2:0] north_request_bundle,\n    input wire [2:0] east_request_bundle,\n\noutput reg [1:0] pe_cfg_bundle,\n    output reg [2:0] south_cfg_bundle,\n    output reg [2:0] west_cfg_bundle,\n\noutput reg      r2pe_ack\n  );\n\nlocalparam  MUX_EAST  = 3'b111;\n  localparam  MUX_NORTH = 3'b101;\n  localparam  MUX_PE    = 3'b001;\n  localparam  MUX_NULL  = 3'b000;\n  localparam  PE_NULL   = 2'b00;\n\nwire [2:0] request_vector;\n\n  assign request_vector = {east_request_bundle[0], north_request_bundle[0], pe_request_bundle[0]};\n\nalways @(*)\n  begin\n\n  west_cfg_bundle  = MUX_NULL;\n  south_cfg_bundle = MUX_NULL;\n  pe_cfg_bundle    = PE_NULL;\n\n  r2pe_ack         = 1'b0;\n\n    case (request_vector)\n      3'b000: begin\n          end\n\n\n      3'b001: begin\n          r2pe_ack = 1'b1;\n          case (pe_request_bundle[2:1])\n            2'b00:  west_cfg_bundle  = MUX_PE;    2'b01:  west_cfg_bundle  = MUX_PE;    2'b10:  south_cfg_bundle = MUX_PE;    2'b11:\n              begin\n                r2pe_ack = 1'b0;\n                south_cfg_bundle = MUX_NULL;  end\n          endcase\n        end\n\n\n      3'b010: case (north_request_bundle[2:1])\n          2'b00:  west_cfg_bundle  = MUX_NORTH; 2'b01:  west_cfg_bundle  = MUX_NORTH; 2'b10:  south_cfg_bundle = MUX_NORTH; 2'b11:  pe_cfg_bundle    = 2'b01;     endcase\n\n\n      3'b011: begin\n          r2pe_ack = 1'b1;\n          case (north_request_bundle[2:1])\n              2'b00:\n                begin\n                  west_cfg_bundle  = MUX_NORTH; south_cfg_bundle = MUX_PE;    end\n            2'b01:\n              begin\n                west_cfg_bundle  = MUX_NORTH; south_cfg_bundle = MUX_PE;    end\n            2'b10:\n              begin\n                south_cfg_bundle = MUX_NORTH; west_cfg_bundle  = MUX_PE;    end\n            2'b11:\n              begin\n                west_cfg_bundle = MUX_PE;    pe_cfg_bundle   = 2'b01;     end\n          endcase\n        end\n\n\n      3'b100: case (east_request_bundle[2:1])\n          2'b00:  west_cfg_bundle  = MUX_EAST; 2'b01:  west_cfg_bundle  = MUX_EAST; 2'b10:  south_cfg_bundle = MUX_EAST; 2'b11:  pe_cfg_bundle    = 2'b11;  endcase\n\n\n      3'b101: begin\n          r2pe_ack = 1'b1;\n          case (east_request_bundle[2:1])\n            2'b00:\n              begin\n                west_cfg_bundle  = MUX_EAST; south_cfg_bundle = MUX_PE;   end\n\n            2'b01:\n              begin\n                west_cfg_bundle  = MUX_EAST; south_cfg_bundle = MUX_PE;   end\n            2'b10:\n              begin\n                south_cfg_bundle = MUX_EAST; west_cfg_bundle  = MUX_PE;   end\n            2'b11:\n              begin\n                west_cfg_bundle = MUX_PE;  pe_cfg_bundle   = 2'b11;   end\n          endcase\n        end\n\n\n      3'b110: case (east_request_bundle[2:1])\n          2'b00:\n            begin\n              west_cfg_bundle  = MUX_EAST;  south_cfg_bundle = MUX_NORTH; end\n\n          2'b01:\n            begin\n              west_cfg_bundle  = MUX_EAST;  south_cfg_bundle = MUX_NORTH; end\n          2'b10:\n            begin\n              south_cfg_bundle = MUX_EAST;  west_cfg_bundle  = MUX_NORTH; end\n          2'b11:\n            begin\n              west_cfg_bundle  = MUX_NORTH; pe_cfg_bundle   = 2'b11;      end\n        endcase\n\n\n      3'b111: case (east_request_bundle[2:1])\n          2'b00:\n            begin\n              west_cfg_bundle  = MUX_EAST;  south_cfg_bundle = MUX_NORTH; end\n\n          2'b01:\n            begin\n              west_cfg_bundle  = MUX_EAST;  if (north_request_bundle[2:1] == 2'b11)\n                begin\n                  south_cfg_bundle  = MUX_PE; pe_cfg_bundle     = 2'b01;  r2pe_ack          = 1'b1;\n                end\n              else\n                  south_cfg_bundle = MUX_NORTH; end\n          2'b10:\n            begin\n              west_cfg_bundle  = MUX_NORTH; if (north_request_bundle[2:1] == 2'b11)\n                begin\n                  west_cfg_bundle = MUX_PE; pe_cfg_bundle   = 2'b01;  r2pe_ack        = 1'b1;\n                end\n              else\n                south_cfg_bundle = MUX_EAST;  end\n          2'b11:\n            begin\n              if (north_request_bundle[2:1] == 2'b01)\n                begin\n                  west_cfg_bundle  = MUX_NORTH; south_cfg_bundle = MUX_PE;    end\n              else\n                begin\n                  west_cfg_bundle  = MUX_PE;    south_cfg_bundle = MUX_NORTH;  end\n              pe_cfg_bundle   = 2'b11;      r2pe_ack        = 1'b1;\n            end\n        endcase\n\n\n    endcase end endmodule\n",
        "module_name": "arbitro",
        "module_hash": "88b748144ec3a1f66dc10054aa5738fd",
        "dataset_index": 8728
      },
      "nor4_5e864d61": {
        "rtl_code": "\nmodule nor4 (\n    A,\n    B,\n    C,\n    D,\n    Y\n);\n\n    input A, B, C, D;\n    output Y;\n\n    wire temp1, temp2;\n\n    // First NOR gate\n    nor_gate nor1 (\n        .Y(temp1),\n        .A(A),\n        .B(B)\n    );\n\n    // Second NOR gate\n    nor_gate nor2 (\n        .Y(temp2),\n        .A(C),\n        .B(D)\n    );\n\n    // Final NOR gate\n    nor_gate nor3 (\n        .Y(Y),\n        .A(temp1),\n        .B(temp2)\n    );\n\nendmodule\n\nmodule nor_gate (\n    Y,\n    A,\n    B\n);\n\n    input A, B;\n    output Y;\n\n    assign Y = ~(A | B);\n\nendmodule\n",
        "module_name": "nor4",
        "module_hash": "5e864d61df09e46e0923b4fd554f055f",
        "dataset_index": 19902
      },
      "fifo_fwft_adapter #_dbe67983": {
        "rtl_code": "module fifo_fwft_adapter # (\n\tparameter DATA_WIDTH = 0\n) (\n\tinput  wire                  clk,\n\tinput  wire                  rst,\n\tinput  wire                  rd_en,\n\tinput  wire                  fifo_empty,\n\toutput wire                  fifo_rd_en,\n\tinput  wire [DATA_WIDTH-1:0] fifo_dout,\n\toutput reg  [DATA_WIDTH-1:0] dout,\n\toutput wire                  empty,\n\toutput wire                  valid\n);\n\n\treg \t\t     fifo_valid, middle_valid, dout_valid;\n\treg [DATA_WIDTH-1:0] middle_dout;\n\treg [DATA_WIDTH-1:0] last_dout;\n\n\tassign fifo_rd_en = (!fifo_empty) && !(middle_valid && dout_valid && fifo_valid);\n\tassign empty      = !dout_valid;\n\tassign valid      = dout_valid;\n\n\twire next_dout;\n\tassign next_dout = (rd_en || !dout_valid);\n\n\talways @(posedge clk) begin\n\t\tif (rst) begin\n\t\t\tfifo_valid   <= 0;\n\t\t\tmiddle_valid <= 0;\n\t\t\tmiddle_dout  <= 0;\n\t\t\tdout_valid   <= 0;\n\t\t\tdout         <= 0;\n\t\t\tlast_dout    <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (fifo_rd_en)\n\t\t\t\tfifo_valid <= 1;\n\t\t\telse if (!middle_valid || next_dout)\n\t\t\t\tfifo_valid <= 0;\n\n\t\t\tif (middle_valid == next_dout) begin\n\t\t\t\tmiddle_valid <= fifo_valid;\n\t\t\t\tmiddle_dout  <= fifo_dout;\n\t\t\tend\n\n\t\t\tif (next_dout) begin\n\t\t\t\tdout_valid <= (fifo_valid || middle_valid);\n\t\t\t\tif (fifo_valid) begin\n\t\t\t\t\tdout <= fifo_dout;\n\t\t\t\t\tlast_dout <= fifo_dout;\n\t\t\t\tend\n\t\t\t\telse if (middle_valid) begin\n\t\t\t\t\tdout <= middle_dout;\n\t\t\t\t\tlast_dout <= middle_dout;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tif (!dout_valid)\n\t\t\tdout <= last_dout;\n\tend\n\nendmodule",
        "module_name": "fifo_fwft_adapter #",
        "module_hash": "dbe67983e179b1fed8709d3e12284685",
        "dataset_index": 9537
      }
    },
    "batch_69165064f5148190b95041bdf104062a": {
      "altera_up_av_config_auto_init_d5m_26c809dc": {
        "rtl_code": "\n\n\n\nmodule altera_up_av_config_auto_init_d5m (\n\trom_address,\n\n\texposure,\n\n\trom_data\n);\n\n\n\nparameter D5M_COLUMN_SIZE\t= 16'd2591;\nparameter D5M_ROW_SIZE\t\t= 16'd1943;\nparameter D5M_COLUMN_BIN\t= 16'h0000;\nparameter D5M_ROW_BIN\t\t= 16'h0000;\n\n\ninput\t\t\t[ 4: 0]\trom_address;\n\ninput\t\t\t[15: 0]\texposure;\n\noutput\t\t[35: 0]\trom_data;\n\n\n\n\nreg\t\t\t[31: 0]\tdata;\n\n\n\n\n\n\n\n\nassign rom_data = {data[31:24], 1'b0, \n\t\t\t\t\t\tdata[23:16], 1'b0, \n\t\t\t\t\t\tdata[15: 8], 1'b0, \n\t\t\t\t\t\tdata[ 7: 0], 1'b0};\n\nalways @(*)\nbegin\n\tcase (rom_address)\n\t0\t\t:\tdata\t<= {8'hBA, 8'h00, 16'h0000};\n\t1\t\t:\tdata\t<= {8'hBA, 8'h20, 16'hc000}; 2\t\t:\tdata\t<= {8'hBA, 8'h09, exposure}; 3\t\t:\tdata\t<= {8'hBA, 8'h05, 16'h0000}; 4\t\t:\tdata\t<= {8'hBA, 8'h06, 16'h0019}; 5\t\t:\tdata\t<= {8'hBA, 8'h0A, 16'h8000}; 6\t\t:\tdata\t<= {8'hBA, 8'h2B, 16'h000b}; 7\t\t:\tdata\t<= {8'hBA, 8'h2C, 16'h000f}; 8\t\t:\tdata\t<= {8'hBA, 8'h2D, 16'h000f}; 9\t\t:\tdata\t<= {8'hBA, 8'h2E, 16'h000b}; 10\t\t:\tdata\t<= {8'hBA, 8'h10, 16'h0051}; 11\t\t:\tdata\t<= {8'hBA, 8'h11, 16'h1807}; 12\t\t:\tdata\t<= {8'hBA, 8'h12, 16'h0002}; 13\t\t:\tdata\t<= {8'hBA, 8'h10, 16'h0053}; 14\t\t:\tdata\t<= {8'hBA, 8'h98, 16'h0000}; `ifdef ENABLE_TEST_PATTERN\n\t15\t\t:\tdata\t<= {8'hBA, 8'hA0, 16'h0001}; 16\t\t:\tdata\t<= {8'hBA, 8'hA1, 16'h0123}; 17\t\t:\tdata\t<= {8'hBA, 8'hA2, 16'h0456}; `else\n\t15\t\t:\tdata\t<= {8'hBA, 8'hA0, 16'h0000}; 16\t\t:\tdata\t<= {8'hBA, 8'hA1, 16'h0000}; 17\t\t:\tdata\t<= {8'hBA, 8'hA2, 16'h0FFF}; `endif\n\t18\t\t:\tdata\t<= {8'hBA, 8'h01, 16'h0036}; 19\t\t:\tdata\t<= {8'hBA, 8'h02, 16'h0010}; 20\t\t:\tdata\t<= {8'hBA, 8'h03, D5M_ROW_SIZE}; 21\t\t:\tdata\t<= {8'hBA, 8'h04, D5M_COLUMN_SIZE}; 22\t\t:\tdata\t<= {8'hBA, 8'h22, D5M_ROW_BIN}; 23\t\t:\tdata\t<= {8'hBA, 8'h23, D5M_COLUMN_BIN}; 24\t\t:\tdata\t<= {8'hBA, 8'h49, 16'h01A8}; default\t:\tdata\t<= {8'h00, 8'h00, 16'h0000};\n\tendcase\nend\n\n\n\n\nendmodule\n\n",
        "module_name": "altera_up_av_config_auto_init_d5m",
        "module_hash": "26c809dc2d2dcf879d1df61ea69b7c16",
        "dataset_index": 22692
      },
      "d_ff_jk_with_async_set_reset_dc6fe4ff": {
        "rtl_code": "module d_ff_jk_with_async_set_reset (\n    input clk,    // Clocks are used in sequential circuits\n    input d,\n    input aset,\n    input areset,\n    output reg q );\n\n    reg j, k;\n\n    always @ (posedge clk) begin\n        if (aset) begin\n            q <= 1;\n        end else if (areset) begin\n            q <= 0;\n        end else begin\n            j <= d;\n            k <= ~d;\n            q <= j ^ q & ~k;\n        end\n    end\nendmodule",
        "module_name": "d_ff_jk_with_async_set_reset",
        "module_hash": "dc6fe4ff40f406e33961f2e990e0ec80",
        "dataset_index": 2522
      },
      "wb_ram_block #_a0742dae": {
        "rtl_code": "module wb_ram_block #\n  (parameter AWIDTH=9)\n   (input clk_i,\n    input stb_i,\n    input we_i,\n    input [AWIDTH-1:0] adr_i,\n    input [31:0] dat_i,\n    output reg [31:0] dat_o,\n    output reg ack_o);\n\n  reg [31:0] distram [0:(1<<AWIDTH)-1];\n\n  always @(posedge clk_i)\n    begin\n      if(stb_i & we_i)\n        distram[adr_i] <= dat_i;\n      dat_o <= distram[adr_i];\n    end\n\n  reg stb_d1, ack_d1;\n  always @(posedge clk_i)\n    stb_d1 <= stb_i;\n  \n  always @(posedge clk_i)\n    ack_d1 <= ack_o;\n  \n  always @(*)\n    ack_o = stb_i & (we_i | (stb_d1 & ~ack_d1));\nendmodule",
        "module_name": "wb_ram_block #",
        "module_hash": "a0742dae7fe935ffb95fe33187cb1dd0",
        "dataset_index": 3774
      },
      "decoder_dc42185b": {
        "rtl_code": "\nmodule decoder (\n    input clk,\n    input [3:0] ABCD,\n    output [15:0] out\n);\n\nreg [15:0] stage1_out;\nreg [15:0] stage2_out;\n\nalways @ (posedge clk) begin\n    stage1_out <= {~ABCD[0], ~ABCD[1], ~ABCD[2], ~ABCD[3]};\nend\n\nalways @ (posedge clk) begin\n    stage2_out <= {stage1_out[0], stage1_out[1], stage1_out[2], stage1_out[3], stage1_out[4], stage1_out[5], stage1_out[6], stage1_out[7], stage1_out[8], stage1_out[9], stage1_out[10], stage1_out[11], stage1_out[12], stage1_out[13], stage1_out[14], stage1_out[15]};\nend\n\nassign out = ~stage2_out;\n\nendmodule\n",
        "module_name": "decoder",
        "module_hash": "dc42185b71b6984a35d45731da90bdbf",
        "dataset_index": 14919
      },
      "mux4_a7d03e70": {
        "rtl_code": "module mux4(\n    input [3:0] data_in,\n    input [1:0] sel,\n    output data_out\n);\n\n    wire sel_0_bar;\n    wire sel_1_bar;\n\n    assign sel_0_bar = ~sel[0];\n    assign sel_1_bar = ~sel[1];\n\n    wire and_1;\n    wire and_2;\n    wire and_3;\n    wire and_4;\n    wire or_1;\n    wire or_2;\n\n    assign and_1 = data_in[0] & sel_0_bar & sel_1_bar;\n    assign and_2 = data_in[1] & sel_0_bar & sel[1];\n    assign and_3 = data_in[2] & sel[0] & sel_1_bar;\n    assign and_4 = data_in[3] & sel[0] & sel[1];\n\n    assign or_1 = and_1 | and_2;\n    assign or_2 = and_3 | and_4;\n\n    assign data_out = or_1 | or_2;\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "a7d03e70a22609481ef80715b9249022",
        "dataset_index": 2260
      },
      "adder_99779bbb": {
        "rtl_code": "\nmodule adder (\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] out\n);\n\nreg [7:0] carry;\n\nalways @(*) begin\n    carry = (data1 + data2 > 255) ? 1 : 0;\n    out = data1 + data2 + carry;\nend\n\nendmodule",
        "module_name": "adder",
        "module_hash": "99779bbbb31ad34c409224ac87ba7f81",
        "dataset_index": 15502
      },
      "ripple_carry_adder_5d37a3eb": {
        "rtl_code": "\nmodule ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    assign S[0] = A[0] ^ B[0] ^ Cin;\n    assign S[1] = A[1] ^ B[1] ^ (S[0] & 1'b1);\n    assign S[2] = A[2] ^ B[2] ^ (S[1] & 1'b1);\n    assign S[3] = A[3] ^ B[3] ^ (S[2] & 1'b1);\n    assign Cout = (A[3] & B[3]) | ((A[3] | B[3]) & Cin);\n\nendmodule\n",
        "module_name": "ripple_carry_adder",
        "module_hash": "5d37a3ebc8de0b220a0cad56237c64b3",
        "dataset_index": 1828
      },
      "sky130_fd_sc_ms__or4b_1_8113c8e9": {
        "rtl_code": "\nmodule sky130_fd_sc_ms__or4b_1 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output X\n);\n\n    assign X = A | B | C | D;\n\nendmodule\n\nmodule or4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output X\n);\n\n    wire [3:0] or_inputs;\n    assign or_inputs = {A, B, C, ~D};\n\n    sky130_fd_sc_ms__or4b_1 or_gate (\n        .X(X),\n        .A(or_inputs[0]),\n        .B(or_inputs[1]),\n        .C(or_inputs[2]),\n        .D(or_inputs[3])\n    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__or4b_1",
        "module_hash": "8113c8e9860e1086878b0ee7c12bed18",
        "dataset_index": 14362
      },
      "traffic_controller_442db440": {
        "rtl_code": "\nmodule traffic_controller(\n    input clk, //clock signal\n    input reset, //reset signal\n    input pedestrian_button, //pedestrian crossing button\n    output reg [1:0] traffic_light, //traffic light output (0 for red, 1 for yellow, 2 for green)\n    output reg pedestrian_crossing //pedestrian crossing output (0 for not active, 1 for active)\n);\n\nreg [3:0] state; //state machine variable\nreg [3:0] counter; //counter variable\nparameter GREEN_TIME = 10; //green state time\nparameter YELLOW_TIME = 2; //yellow state time\nparameter RED_TIME = 8; //red state time\nparameter CROSSING_TIME = 15; //pedestrian crossing time\n\n//initialize state and counter variables\ninitial begin\n    state = 4'b0100; //initial state is green for both lanes\n    counter = 4'b0000; //initial counter value is 0\nend\n\n//state machine\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        state <= 4'b0100; //reset state to green for both lanes\n        counter <= 4'b0000; //reset counter to 0\n    end else begin\n        case(state)\n            4'b0100: begin //green state\n                if(counter == GREEN_TIME) begin //green time is 10 seconds\n                    state <= 4'b0010; //switch to yellow state\n                    counter <= 4'b0000; //reset counter\n                end else begin\n                    counter <= counter + 1; //increment counter\n                end\n            end\n            4'b0010: begin //yellow state\n                if(counter == YELLOW_TIME) begin //yellow time is 2 seconds\n                    state <= 4'b1000; //switch to red state\n                    counter <= 4'b0000; //reset counter\n                end else begin\n                    counter <= counter + 1; //increment counter\n                end\n            end\n            4'b1000: begin //red state\n                if(counter == RED_TIME) begin //red time is 8 seconds\n                    state <= 4'b0101; //switch to green state for other lane\n                    counter <= 4'b0000; //reset counter\n                end else if (pedestrian_button) begin //if pedestrian button is pressed, switch to pedestrian crossing state\n                    state <= 4'b1001;\n                    counter <= 4'b0000;\n                end else begin //otherwise, increment counter\n                    counter <= counter + 1;\n                end\n            end\n            4'b0101: begin //green state for other lane\n                if(counter == GREEN_TIME) begin //green time is 10 seconds\n                    state <= 4'b0011; //switch to yellow state for other lane\n                    counter <= 4'b0000; //reset counter\n                end else begin\n                    counter <= counter + 1; //increment counter\n                end\n            end\n            4'b0011: begin //yellow state for other lane\n                if(counter == YELLOW_TIME) begin //yellow time is 2 seconds\n                    state <= 4'b1000; //switch to red state\n                    counter <= 4'b0000; //reset counter\n                end else begin\n                    counter <= counter + 1; //increment counter\n                end\n            end\n            4'b1001: begin //pedestrian crossing state\n                if(counter == CROSSING_TIME) begin //pedestrian crossing time is 15 seconds\n                    state <= 4'b1000; //switch back to red state\n                    counter <= 4'b0000; //reset counter\n                end else begin\n                    counter <= counter + 1; //increment counter\n                end\n            end\n        endcase\n    end\nend\n\n//traffic light output\nalways @(state) begin\n    case(state)\n        4'b0100, 4'b1001: traffic_light <= 2'b10; //green state for lane 1, red state for lane 2\n        4'b0010, 4'b0011: traffic_light <= 2'b01; //yellow state for both lanes\n        4'b1000, 4'b0101: traffic_light <= 2'b00; //red state for lane 1, green state for lane 2\n    endcase\nend\n\n//pedestrian crossing output\nalways @(state) begin\n    case(state)\n        4'b1001: pedestrian_crossing <= 1'b1; //active\n        default: pedestrian_crossing <= 1'b0; //not active\n    endcase\nend\n\nendmodule",
        "module_name": "traffic_controller",
        "module_hash": "442db4407716b42b15405bea58646082",
        "dataset_index": 9419
      },
      "is2vid_control_73bd5c8c": {
        "rtl_code": "module is2vid_control\n    #(parameter\n        USE_CONTROL = 1,\n        NO_OF_MODES_INT = 1,\n        USED_WORDS_WIDTH = 15)\n    (\n    input   wire rst,\n    input   wire clk,\n    \n    // From mode registers\n    input   wire av_write_ack,\n    input   wire mode_change,\n    input   wire [NO_OF_MODES_INT-1:0] mode_match,\n    \n    // From FIFO\n    input   wire [USED_WORDS_WIDTH-1:0] usedw,\n    input   wire underflow_sticky,\n    input   wire enable_resync, // from the outgoing state machine\n    input   wire genlocked,\n    \n    // IS2Vid control signals\n    output  wire enable,\n    output  wire clear_underflow_sticky,\n    output  wire write_trigger,\n    output  wire write_trigger_ack,\n    output  wire [1:0] genlock_enable,\n    \n    // Aavalon-MM slave port\n    input   wire [7:0] av_address,\n    input   wire av_read,\n    output  wire [15:0] av_readdata,\n    input   wire av_write,\n    input   wire [15:0] av_writedata,\n    output  wire av_waitrequest,\n    \n    output  wire status_update_int);\n\ngenerate\n    if(USE_CONTROL) begin\n        reg enable_reg;\n        reg write_trigger_ack_reg;\n        \n        wire is_side_registers;\n        reg [1:0] interrupt_enable;\n        reg status_update_int_reg;\n        reg genlocked_reg;\n        reg genlocked_int_reg;\n        reg [1:0] genlock_enable_reg;\n        \n        wire [15:0] usedw_output;\n        wire [15:0] is_mode_match_output;\n        \n        reg [NO_OF_MODES_INT-1:0] is_mode_match;\n        wire clear_interrupts;\n        \n        reg clear_underflow_sticky_reg;\n        \n        wire mode_write;\n        \n        if(USED_WORDS_WIDTH >= 16)\n            assign usedw_output = usedw[15:0];\n        else\n            assign usedw_output = {{16-USED_WORDS_WIDTH{1'b0}}, usedw};\n        \n        if(NO_OF_MODES_INT >= 16) begin\n            assign is_mode_match_output = is_mode_match[15:0];\n        end else begin\n            assign is_mode_match_output = {{16-NO_OF_MODES_INT{1'b0}}, is_mode_match};\n        end\n        \n        assign enable = enable_reg;\n        assign av_readdata = (av_address == 8'd1) ? {{12{1'b0}}, genlocked,\n                                                                 underflow_sticky,\n                                                                 1'b0,\n                                                                 enable_resync} :\n                             (av_address == 8'd2) ? {{13{1'b0}}, genlocked_int_reg,\n                                                                 status_update_int_reg,\n                                                                 1'b0} :\n                             (av_address == 8'd3) ? usedw_output :\n                             (av_address == 8'd4) ? is_mode_match_output :\n                             {{11{1'b0}}, genlock_enable, interrupt_enable, enable_reg};\n        assign av_waitrequest = av_write & ~(av_write_ack | is_side_registers);\n        assign is_side_registers = av_address <= 8'd4;\n        assign write_trigger = av_write & ~is_side_registers;\n        assign write_trigger_ack = write_trigger_ack_reg;\n        assign status_update_int = status_update_int_reg | genlocked_int_reg;\n        assign clear_interrupts = av_write && av_address == 8'd2;\n        assign clear_underflow_sticky = clear_underflow_sticky_reg;\n        assign genlock_enable = genlock_enable_reg;\n        \n        always @ (posedge rst or posedge clk) begin\n            if (rst) begin\n                genlock_enable_reg <= 2'b0;\n                interrupt_enable <= 2'b0;\n                enable_reg <= 1'b0;\n                status_update_int_reg <= 1'b0;\n                genlocked_int_reg <= 1'b0;\n                \n                is_mode_match <= {NO_OF_MODES_INT{1'b0}};\n                genlocked_reg <= 1'b0;\n                clear_underflow_sticky_reg <= 1'b0;\n                write_trigger_ack_reg <= 1'b0;\n            end else begin\n                {genlock_enable_reg, interrupt_enable, enable_reg} <= (av_write && av_address == 8'd0) ? av_writedata[4:0] : {genlock_enable_reg, interrupt_enable, enable_reg};\n                status_update_int_reg <= (mode_change | status_update_int_reg) & ~(clear_interrupts & av_writedata[1]) & interrupt_enable[0];\n                genlocked_int_reg <= ((genlocked ^ genlocked_reg) | genlocked_int_reg) & ~(clear_interrupts & av_writedata[2]) & interrupt_enable[1];\n                \n                is_mode_match <= (mode_change) ? mode_match : is_mode_match;\n                genlocked_reg <= genlocked;\n                clear_underflow_sticky_reg <= ((av_write && av_address == 8'd1 && av_writedata[2]) | clear_underflow_sticky_reg) & underflow_sticky;\n                write_trigger_ack_reg <= av_write_ack;\n            end\n        end\n    end else begin\n        assign enable = 1'b1;\n        assign status_update_int = 1'b0;\n        assign clear_underflow_sticky = 1'b0;\n        assign write_trigger = 1'b0;\n        assign write_trigger_ack = 1'b0;\n        assign genlock_enable = 2'b00;\n        assign av_readdata = 16'b0;\n        assign av_waitrequest = 1'b0;\n    end\nendgenerate\n\nendmodule",
        "module_name": "is2vid_control",
        "module_hash": "73bd5c8c761b0357f276196b11c689b4",
        "dataset_index": 15942
      },
      "multiplier_a1b3c2ec": {
        "rtl_code": "\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [2:0] select,\n    output reg [15:0] out\n);\n\nwire [7:0] shifted_in2;\nreg [15:0] product;\n\nreg [7:0] temp_in2;\n\nassign shifted_in2 = temp_in2 << select;\n\nbarrel_shifter barrel_shifter_inst( // instantiated the barrel shifter module\n    .in(in2),\n    .select(select),\n    .shifted_out(temp_in2)\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        out <= 16'b0;\n    end else begin\n        if (in1 != in1_prev || in2 != in2_prev) begin\n            product <= in1 * shifted_in2; // calculated the product\n            out <= product;\n        end\n    end\nend\n\nreg [7:0] in1_prev;\nreg [7:0] in2_prev;\n\nalways @(posedge clk) begin\n    in1_prev <= in1;\n    in2_prev <= in2;\nend\n\nendmodule\nmodule barrel_shifter(\n    input [7:0] in,\n    output reg [7:0] shifted_out,\n    input [2:0] select\n);\n\nalways @(*) begin\n    case (select)\n        3'b000: shifted_out = in;\n        3'b001: shifted_out = {in[6:0], 1'b0};\n        3'b010: shifted_out = {in[5:0], 2'b00};\n        3'b011: shifted_out = {in[4:0], 3'b000};\n        3'b100: shifted_out = {in[3:0], 4'b0000};\n        3'b101: shifted_out = {in[2:0], 5'b00000};\n        3'b110: shifted_out = {in[1:0], 6'b000000};\n        3'b111: shifted_out = {in[0], 7'b0000000};\n    endcase\nend\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "a1b3c2ec97175d16de457ac3a9f32dff",
        "dataset_index": 2229
      },
      "edge_detector_426e23e4": {
        "rtl_code": "module edge_detector (\n  input clk,\n  input reset,\n  input in,\n  output reg rising_edge,\n  output reg falling_edge\n);\n\n  reg prev_in;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      rising_edge <= 1'b0;\n      falling_edge <= 1'b0;\n      prev_in <= 1'b0;\n    end else begin\n      if (in != prev_in) begin\n        if (in > prev_in) begin\n          rising_edge <= 1'b1;\n          falling_edge <= 1'b0;\n        end else begin\n          rising_edge <= 1'b0;\n          falling_edge <= 1'b1;\n        end\n      end else begin\n        rising_edge <= 1'b0;\n        falling_edge <= 1'b0;\n      end\n      prev_in <= in;\n    end\n  end\n\nendmodule",
        "module_name": "edge_detector",
        "module_hash": "426e23e449f58737d1e36312efe5a1b9",
        "dataset_index": 9028
      },
      "inverter_e51fa235": {
        "rtl_code": "module inverter(\n    input din,\n    output dout\n);\n\nassign dout = ~din;\n\nendmodule",
        "module_name": "inverter",
        "module_hash": "e51fa235acc154cd41cfc06bd8e82971",
        "dataset_index": 16871
      },
      "simple_calc_a22be5fb": {
        "rtl_code": "\nmodule simple_calc(\n    input [7:0] a,\n    input [7:0] b,\n    input op,\n    output reg [7:0] sum,\n    output reg [7:0] diff\n);\n\nreg [8:0] temp_diff;\nreg [8:0] temp_sum;\n\nalways @(*) begin\n    if(op) begin\n        temp_diff = a - b;\n        temp_sum = a + b;\n    end\n    else begin\n        temp_diff = b - a;\n        temp_sum = a + b;\n    end\nend\n\nalways @* begin\n    diff = temp_diff[7:0];\n    sum = temp_sum[7:0];\nend\n\nendmodule",
        "module_name": "simple_calc",
        "module_hash": "a22be5fbf71f35e94e3bc64b67a59480",
        "dataset_index": 7174
      },
      "Traductor_c40110a9": {
        "rtl_code": "\nmodule Traductor(in,out,clk,rst);\ninput wire clk,rst;\ninput wire [3:0]in;\noutput reg [10:0]out;\n\n\nalways@(posedge clk, posedge rst)\n\tif (rst)\n\t\tbegin\n\t\tout <= 11'd0;\n\t\tend\n\telse\n\t\tcase(in)\n\t\t\t4'b0000: out <= 11'd1666;\n\t\t\t4'b0001: out <= 11'd999;\n\t\t\t4'b0010: out <= 11'd666;\n\t\t\t4'b0011: out <= 11'd499;\n\t\t\t4'b0100: out <= 11'd399;\n\t\t\t4'b0101: out <= 11'd332;\n\t\t\t4'b0110: out <= 116'd285;\n\t\t\t4'b0111: out <= 11'd249;\n\t\t\t4'b1000: out <= 11'd221;\n\t\t\t4'b1001: out <= 11'd199;\n\t\t\t4'b1010: out <= 11'd181;\n\t\t\t4'b1011: out <= 11'd165;\n\t\t\t4'b1100: out <= 11'd152;\n\t\t\t4'b1101: out <= 11'd141;\n\t\t\t4'b1110: out <= 11'd132;\n\t\t\t4'b1111: out <= 11'd124;\n\t\t\tdefault out <= 11'd0;\n\t\tendcase\nendmodule\n",
        "module_name": "Traductor",
        "module_hash": "c40110a9c683abc909f397de0cfe7993",
        "dataset_index": 23498
      },
      "progmem_d4b41f45": {
        "rtl_code": "\n\n\nmodule progmem(\n\t\tinput wire\t\t[ 7 : 0]\tpc,\n\t\toutput reg\t\t[15 : 0]\tinstruction\n    );\n\n\t\n\talways @(pc) begin\n\t\tcase(pc)\n\t\t\t8'h00:\tinstruction = 16'h7f00;\t\n\t\t\t8'h01:\tinstruction = 16'h0100;\t\n\t\t\t8'h02:\tinstruction = 16'h0101;\t\n\t\t\t8'h03:\tinstruction = 16'h7200;\t\n\t\t\t8'h04:\tinstruction = 16'h74ff;\t\n\t\t\t8'h05:\tinstruction = 16'h0a0c;\t\n\t\t\t8'h06:\tinstruction = 16'h0101;\t\n\t\t\t8'h07:\tinstruction = 16'h0000;\t\n\t\t\t8'h08:\tinstruction = 16'h0100;\t\n\t\t\t8'h09:\tinstruction = 16'h01ff;\t\n\t\t\t8'h0a:\tinstruction = 16'h0201;\t\n\t\t\t8'h0b:\tinstruction = 16'h0303;\t\n\t\t\t8'h0c:\tinstruction = 16'h030c;\t\n\t\t\tdefault:\n\t\t\t\tbegin\n\t\t\t\t\tinstruction = 16'hffff;\t\n\t\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n\n",
        "module_name": "progmem",
        "module_hash": "d4b41f457987af94780ac1e24bf42840",
        "dataset_index": 22587
      },
      "digitalfilter_d2f30a2c": {
        "rtl_code": "\n\n\nmodule digitalfilter(output out, input clk, input ce, input in);\n  \n  reg [5:0] taps = 6'b000000;\n  reg result = 0;\n  \n  assign out = result;\n  \n \n  always @(posedge clk)\n  begin\n    if(ce)\n      begin\n        taps[5] <= taps[4];\n        taps[4] <= taps[3];\n    \ttaps[3] <= taps[2];\n    \ttaps[2] <= taps[1];\n    \ttaps[1] <= taps[0];\n        taps[0] <= in;\n      end\n    if(taps[2] & taps[3] & taps[4] & taps[5])\n      result <= 1;\n    if(~taps[2] & ~taps[3] & ~taps[4] & ~taps[5])\n      result <= 0;\n  end\n\n \n  \nendmodule\n\n\nmodule graycode2(\n  output up,\n  output down,\n  input clk,\n  input freeze,\n  input [1:0] tach);\n  \n  reg [1:0] last = 0;\n  reg u = 0;\n  reg d = 0;\n  \n  \n  wire [3:0] encodedstate; \n  \n  \n  assign encodedstate = {tach, last};\n  assign up = u;\n  assign down = d;\n  \n  always @(posedge clk) begin\n    u <= 0;\n    d <= 0;\n    if(~freeze) begin\n      case(encodedstate) \n        4'b0000, 4'b1111,\n        4'b1010,\n        4'b0101:\n          begin\n          end\n        4'b0100, 4'b1101,\n        4'b1011,\n        4'b0010:\n          begin\n            last <= tach;\n            u <= 1;\n            d <= 0;  \n          end\n        4'b0001, 4'b0111,\n        4'b1110,\n        4'b1000:\n          begin\n            last <= tach;\n          \tu <= 0;\n            d <= 1;\n          end\n        4'b0011, 4'b1100,\n        4'b0110,\n        4'b1001:\n          begin\n          end \n        \n        default: begin\n          \tu <= 1'bx;\n          \td <= 1'bx;\n          end\n      endcase    \n    end  \n  end\n  \n  \nendmodule\n\nmodule udcounter16(\n  output [15:0] counter,\n  input clk,\n  input up,\n  input down);\n  \n  reg [15:0] result = 16'h0000;\n  \n  \n  assign counter = result;\n  \n  always@(posedge clk) begin\n    if(up) begin\n      result <= result + 1;\n    end\n    if(down) begin\n        result <= result - 1;\n    end\n  end\nendmodule\n \nmodule qc16(\n  output [7:0] counth, \n  output [7:0] countl, \n  input [1:0] tach, \n  input clk,\n  input freeze,\n  input invphase);\n \n  wire [15:0] counter;\n  wire up;\n  wire down;\n  reg [1:0] adjtach;\n  \n  always @(*) begin\n    if(invphase) begin\n      adjtach[0] = tach[1];\n      adjtach[1] = tach[0];\n    end\n    else begin\n      adjtach[0] = tach[0];\n      adjtach[1] = tach[1];\n    end\n  end\n  \n  \n  graycode2 gc2(\n    .clk(clk), \n    .freeze(freeze),\n    .up(up), \n    .down(down), \n    .tach(adjtach));\n    \n  udcounter16 udc16(\n    .clk(clk),\n    .up(up),\n    .down(down),\n    .counter(counter));\n  \n  assign counth = counter[15:8];\n  assign countl = counter[7:0];\n \nendmodule\n\n\nmodule tachcounter(\n    output [7:0] countl,\n\toutput [7:0] counth,\n    input clk,\n    input filterce,\n    input freeze,\n    input invphase,\n    input [1:0] tach);\n  \n  wire [1:0] filttach;\n  \n  qc16 q16(\n    .clk(clk),\n    .tach(filttach),\n    .freeze(freeze),\n    .invphase(invphase),\n    .countl(countl),\n    .counth(counth));\n  \n  digitalfilter filterph0(\n    .clk(clk),\n    .ce(filterce),\n    .in(tach[0]),\n    .out(filttach[0]));\n  \n  digitalfilter filterph1(\n    .clk(clk),\n    .ce(filterce),\n    .in(tach[1]),\n    .out(filttach[1]));\n  \nendmodule   \n\n",
        "module_name": "digitalfilter",
        "module_hash": "d2f30a2c6e43c30c65fcd498ce3740cb",
        "dataset_index": 21631
      },
      "priority_encoder_3272ffcf": {
        "rtl_code": "module priority_encoder (\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] priority_output\n);\n\n    assign priority_output = (in1 > in2) ? in1 : in2;\n\nendmodule\n\nmodule final_output_generator (\n    input [3:0] in1,\n    input [3:0] in2,\n    output reg [3:0] final_output\n);\n\n    wire [3:0] priority_output;\n    priority_encoder encoder(in1, in2, priority_output);\n\n    always @* begin\n        case (priority_output)\n            4'b0001: final_output = in1;\n            4'b0010: final_output = in2;\n            4'b0100: final_output = {in1[3:1], in2[0]};\n            4'b1000: final_output = {in2[3:1], in1[0]};\n            default: final_output = 4'b0000;\n        endcase\n    end\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "3272ffcfaa6eb2dcc4b984b5d7d7fbdf",
        "dataset_index": 11552
      },
      "Gpio_265c685e": {
        "rtl_code": "\nmodule Gpio(clk, strobe, rw, reset, addr, data_i, data_o, gpio);\n\n    parameter COUNT = 32;\n    localparam SIZE = 4;\n\n    input  wire            clk, strobe, rw, reset;\n    input  wire[31:0]      addr, data_i;\n    output reg [31:0]      data_o;\n    output wire [COUNT-1:0] gpio;\n\n    localparam EN = 0, RW = 1, RS = 2, WS = 3;\n\n    reg [COUNT-1:0] state[SIZE-1:0];\n\n    integer k;\n    initial for (k = 0; k < SIZE; k = k + 1) state[k] = 0;\n\n    genvar i;\n    generate for (i = 0; i < COUNT; i = i + 1)\n        assign gpio[i] = (state[EN][i] & state[RW][i]) ? state[WS][i] : 0;\n    endgenerate\n\n    always @(posedge clk) begin\n        state[RS] <= state[EN] & ~state[RW] & gpio;\n        if (reset) begin\n            for (k = 0; k < SIZE; k = k + 1)\n                state[k] <= 0;\n        end else if (strobe) begin\n            if (rw)\n                state[addr] <= data_i[COUNT-1:0];\n            else\n                data_o <= {{32-COUNT{1'b0}},state[addr]};\n        end\n    end\n\nendmodule",
        "module_name": "Gpio",
        "module_hash": "265c685eaa90a8b42e8f86d32dc28cea",
        "dataset_index": 1050
      },
      "nand2_532fa4b9": {
        "rtl_code": "module nand2 (\n    input A,\n    input B,\n    output Y\n);\n\n    assign Y = ~(A & B);\n\nendmodule\n\nmodule nand4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y,\n    input VPB,\n    input VPWR,\n    input VGND,\n    input VNB\n);\n\n    wire nand1_out, nand2_out, nand3_out, nand4_out;\n\n    nand2 nand1 (\n        .A(A),\n        .B(B),\n        .Y(nand1_out)\n    );\n\n    nand2 nand2 (\n        .A(C),\n        .B(D),\n        .Y(nand2_out)\n    );\n\n    nand2 nand3 (\n        .A(nand1_out),\n        .B(nand2_out),\n        .Y(nand3_out)\n    );\n\n    nand2 nand4 (\n        .A(nand3_out),\n        .B(nand3_out),\n        .Y(Y)\n    );\n\nendmodule",
        "module_name": "nand2",
        "module_hash": "532fa4b9a279400a1594b6295511dc65",
        "dataset_index": 6818
      },
      "top__a411ea55": {
        "rtl_code": "\nmodule top_module (\n    input CLK, RESET, UP_DOWN, SELECT,\n    input [3:0] in,\n    output reg [3:0] Q,\n    output parity\n);\n\nreg [3:0] count;\nreg parity_bit;\n\nalways @(posedge CLK) begin\n    if(RESET) begin\n        count <= 4'b0000;\n        parity_bit <= 1'b0;\n    end\n    else begin\n        if(UP_DOWN) begin\n            count <= count + 1;\n        end\n        else begin\n            count <= count - 1;\n        end\n        \n        parity_bit <= ^count;\n    end\nend\n\nalways @(posedge CLK) begin\n    if(RESET) begin\n        Q <= 4'b0000;\n    end\n    else begin\n        if(SELECT) begin\n            Q <= count;\n        end\n        else begin\n            Q <= {3'b000, parity_bit};\n        end\n    end\nend\n\nassign parity = parity_bit;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "a411ea551c657a72f1ebf5b59f9ef370",
        "dataset_index": 9282
      },
      "four_bit_adder_bafd28f3": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] c;\n    full_adder fa0 (.a(A[0]), .b(B[0]), .cin(1'b0), .sum(S[0]), .cout(c[0]));\n    full_adder fa1 (.a(A[1]), .b(B[1]), .cin(c[0]), .sum(S[1]), .cout(c[1]));\n    full_adder fa2 (.a(A[2]), .b(B[2]), .cin(c[1]), .sum(S[2]), .cout(c[2]));\n    full_adder fa3 (.a(A[3]), .b(B[3]), .cin(c[2]), .sum(S[3]), .cout(Cout));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "bafd28f3b5864fce973bffc8e5e55c84",
        "dataset_index": 3613
      },
      "connection_module_0ed07432": {
        "rtl_code": "module connection_module(\n    input a, b, c,\n    input select,\n    output w, x, y, z\n);\n\n    assign w = a;\n    assign z = c;\n\n    // 2:1 MUX to select between b and c\n    assign x = (select == 1'b0) ? b : c;\n    assign y = (select == 1'b1) ? b : c;\n\nendmodule",
        "module_name": "connection_module",
        "module_hash": "0ed0743264a652db67a1a128ad5a9df4",
        "dataset_index": 12121
      },
      "sparc_exu_ecc_dec_48d0c084": {
        "rtl_code": "\nmodule sparc_exu_ecc_dec (\n   e, \n   q\n   ) ; \n   input [6:0] q;\n   output [63:0] e;\n\n   assign e[0] = ~q[6] & ~q[5] & ~q[4] & ~q[3] & ~q[2] & q[1] & q[0];\n   assign e[1] = ~q[6] & ~q[5] & ~q[4] & ~q[3] & q[2] & ~q[1] & q[0];\n   assign e[2] = ~q[6] & ~q[5] & ~q[4] & ~q[3] & q[2] & q[1] & ~q[0];\n   assign e[3] = ~q[6] & ~q[5] & ~q[4] & ~q[3] & q[2] & q[1] & q[0];\n   assign e[4] = ~q[6] & ~q[5] & ~q[4] & q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[5] = ~q[6] & ~q[5] & ~q[4] & q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[6] = ~q[6] & ~q[5] & ~q[4] & q[3] & ~q[2] & q[1] & q[0];\n   assign e[7] = ~q[6] & ~q[5] & ~q[4] & q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[8] = ~q[6] & ~q[5] & ~q[4] & q[3] & q[2] & ~q[1] & q[0];\n   assign e[9] = ~q[6] & ~q[5] & ~q[4] & q[3] & q[2] & q[1] & ~q[0];\n   assign e[10] = ~q[6] & ~q[5] & ~q[4] & q[3] & q[2] & q[1] & q[0];\n   assign e[11] = ~q[6] & ~q[5] & q[4] & ~q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[12] = ~q[6] & ~q[5] & q[4] & ~q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[13] = ~q[6] & ~q[5] & q[4] & ~q[3] & ~q[2] & q[1] & q[0];\n   assign e[14] = ~q[6] & ~q[5] & q[4] & ~q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[15] = ~q[6] & ~q[5] & q[4] & ~q[3] & q[2] & ~q[1] & q[0];\n   assign e[16] = ~q[6] & ~q[5] & q[4] & ~q[3] & q[2] & q[1] & ~q[0];\n   assign e[17] = ~q[6] & ~q[5] & q[4] & ~q[3] & q[2] & q[1] & q[0];\n   assign e[18] = ~q[6] & ~q[5] & q[4] & q[3] & ~q[2] & ~q[1] & ~q[0];\n   assign e[19] = ~q[6] & ~q[5] & q[4] & q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[20] = ~q[6] & ~q[5] & q[4] & q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[21] = ~q[6] & ~q[5] & q[4] & q[3] & ~q[2] & q[1] & q[0];\n   assign e[22] = ~q[6] & ~q[5] & q[4] & q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[23] = ~q[6] & ~q[5] & q[4] & q[3] & q[2] & ~q[1] & q[0];\n   assign e[24] = ~q[6] & ~q[5] & q[4] & q[3] & q[2] & q[1] & ~q[0];\n   assign e[25] = ~q[6] & ~q[5] & q[4] & q[3] & q[2] & q[1] & q[0];\n   assign e[26] = ~q[6] & q[5] & ~q[4] & ~q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[27] = ~q[6] & q[5] & ~q[4] & ~q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[28] = ~q[6] & q[5] & ~q[4] & ~q[3] & ~q[2] & q[1] & q[0];\n   assign e[29] = ~q[6] & q[5] & ~q[4] & ~q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[30] = ~q[6] & q[5] & ~q[4] & ~q[3] & q[2] & ~q[1] & q[0];\n   assign e[31] = ~q[6] & q[5] & ~q[4] & ~q[3] & q[2] & q[1] & ~q[0];\n   assign e[32] = ~q[6] & q[5] & ~q[4] & ~q[3] & q[2] & q[1] & q[0];\n   assign e[33] = ~q[6] & q[5] & ~q[4] & q[3] & ~q[2] & ~q[1] & ~q[0];\n   assign e[34] = ~q[6] & q[5] & ~q[4] & q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[35] = ~q[6] & q[5] & ~q[4] & q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[36] = ~q[6] & q[5] & ~q[4] & q[3] & ~q[2] & q[1] & q[0];\n   assign e[37] = ~q[6] & q[5] & ~q[4] & q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[38] = ~q[6] & q[5] & ~q[4] & q[3] & q[2] & ~q[1] & q[0];\n   assign e[39] = ~q[6] & q[5] & ~q[4] & q[3] & q[2] & q[1] & ~q[0];\n   assign e[40] = ~q[6] & q[5] & ~q[4] & q[3] & q[2] & q[1] & q[0];\n   assign e[41] = ~q[6] & q[5] & q[4] & ~q[3] & ~q[2] & ~q[1] & ~q[0];\n   assign e[42] = ~q[6] & q[5] & q[4] & ~q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[43] = ~q[6] & q[5] & q[4] & ~q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[44] = ~q[6] & q[5] & q[4] & ~q[3] & ~q[2] & q[1] & q[0];\n   assign e[45] = ~q[6] & q[5] & q[4] & ~q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[46] = ~q[6] & q[5] & q[4] & ~q[3] & q[2] & ~q[1] & q[0];\n   assign e[47] = ~q[6] & q[5] & q[4] & ~q[3] & q[2] & q[1] & ~q[0];\n   assign e[48] = ~q[6] & q[5] & q[4] & ~q[3] & q[2] & q[1] & q[0];\n   assign e[49] = ~q[6] & q[5] & q[4] & q[3] & ~q[2] & ~q[1] & ~q[0];\n   assign e[50] = ~q[6] & q[5] & q[4] & q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[51] = ~q[6] & q[5] & q[4] & q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[52] = ~q[6] & q[5] & q[4] & q[3] & ~q[2] & q[1] & q[0];\n   assign e[53] = ~q[6] & q[5] & q[4] & q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[54] = ~q[6] & q[5] & q[4] & q[3] & q[2] & ~q[1] & q[0];\n   assign e[55] = ~q[6] & q[5] & q[4] & q[3] & q[2] & q[1] & ~q[0];\n   assign e[56] = ~q[6] & q[5] & q[4] & q[3] & q[2] & q[1] & q[0];\n   assign e[57] = q[6] & ~q[5] & ~q[4] & ~q[3] & ~q[2] & ~q[1] & q[0];\n   assign e[58] = q[6] & ~q[5] & ~q[4] & ~q[3] & ~q[2] & q[1] & ~q[0];\n   assign e[59] = q[6] & ~q[5] & ~q[4] & ~q[3] & ~q[2] & q[1] & q[0];\n   assign e[60] = q[6] & ~q[5] & ~q[4] & ~q[3] & q[2] & ~q[1] & ~q[0];\n   assign e[61] = q[6] & ~q[5] & ~q[4] & ~q[3] & q[2] & ~q[1] & q[0];\n   assign e[62] = q[6] & ~q[5] & ~q[4] & ~q[3] & q[2] & q[1] & ~q[0];\n   assign e[63] = q[6] & ~q[5] & ~q[4] & ~q[3] & q[2] & q[1] & q[0];\n   \nendmodule ",
        "module_name": "sparc_exu_ecc_dec",
        "module_hash": "48d0c0843010cb7074b2b9155e2f8e6b",
        "dataset_index": 4863
      },
      "fifo_write_ptr_inc_6a9341b2": {
        "rtl_code": "module fifo_write_ptr_inc (\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [3:0] fifo_wrptr_inc\n);\n\n  always @*\n    case ({ge3_free, input_tm_cnt})\n      2'b11: fifo_wrptr_inc = 3;\n      2'b10: if (ge2_free) fifo_wrptr_inc = 2;\n              else fifo_wrptr_inc = 1;\n      2'b01: fifo_wrptr_inc = 1;\n      default: fifo_wrptr_inc = 0;\n    endcase\n\nendmodule",
        "module_name": "fifo_write_ptr_inc",
        "module_hash": "6a9341b2ebfb69e8a51668a8bafeaf4b",
        "dataset_index": 11298
      },
      "dna_sequencer #_4df71ca3": {
        "rtl_code": "module dna_sequencer #(\n  parameter [95:0] SIM_DNA_VALUE = 96'h000000000000000000000000\n)(\n  output DOUT,\n\n  input CLK,\n  input DIN,\n  input READ,\n  input SHIFT\n);\n   \n   localparam MAX_DNA_BITS = 96;\n   localparam MSB_DNA_BITS = MAX_DNA_BITS - 1;\n   \n   reg [MSB_DNA_BITS:0] dna_val = SIM_DNA_VALUE;\n   reg dout_out;\n\n   always @(posedge CLK) begin\n      if(READ == 1'b1) begin\n         dna_val = SIM_DNA_VALUE;\n\t dout_out = SIM_DNA_VALUE[0];\n      end // READ == 1'b1\n      else if(READ == 1'b0)\n        if(SHIFT == 1'b1) begin\n\t   dna_val = {DIN, dna_val[MSB_DNA_BITS : 1]};\n\t   dout_out = dna_val[0];\n        end  // SHIFT == 1'b1\n   end // always @ (posedge CLK)\n\n   assign DOUT = dout_out;\n      \nendmodule",
        "module_name": "dna_sequencer #",
        "module_hash": "4df71ca32fae378d0143f44ce3138cfd",
        "dataset_index": 904
      },
      "barrel_shifter_d698f365": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] DATA,\n    input [1:0] SHIFT,\n    output [3:0] OUT\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\nreg [3:0] stage3_out;\n\nalways @(*) begin\n    case(SHIFT)\n        2'b00: stage1_out = DATA;\n        2'b01: stage1_out = {DATA[2:0], 1'b0};\n        2'b10: stage1_out = {DATA[1:0], 2'b00};\n        2'b11: stage1_out = {DATA[0], 3'b000};\n    endcase\nend\n\nalways @(*) begin\n    case(SHIFT)\n        2'b00: stage2_out = stage1_out;\n        2'b01: stage2_out = {stage1_out[1:0], 2'b00};\n        2'b10: stage2_out = {stage1_out[0], 3'b000};\n        2'b11: stage2_out = {3'b000, stage1_out[3]};\n    endcase\nend\n\nalways @(*) begin\n    case(SHIFT)\n        2'b00: stage3_out = stage2_out;\n        2'b01: stage3_out = {stage2_out[2:0], 1'b0};\n        2'b10: stage3_out = {stage2_out[1:0], 2'b00};\n        2'b11: stage3_out = {stage2_out[0], 3'b000};\n    endcase\nend\n\nassign OUT = stage3_out;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "d698f365af82e7d0688d8fa3d772f3ce",
        "dataset_index": 5464
      },
      "fifo_counter_765a2349": {
        "rtl_code": "module fifo_counter (\n    input up_count,\n    input down_count,\n    input reset,\n    input clk,\n    output reg [2:0] num_entries\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        num_entries <= 3'b0;\n    end else if (up_count) begin\n        num_entries <= num_entries + 1;\n    end else if (down_count) begin\n        num_entries <= num_entries - 1;\n    end\nend\n\nendmodule",
        "module_name": "fifo_counter",
        "module_hash": "765a234948aaccac5f1659dcabdbde89",
        "dataset_index": 11895
      },
      "bridge_17848781": {
        "rtl_code": "\n\nmodule bridge(\n\tinput\t\tf_signed_i,\n\tinput\t[1:0]\tf_siz_i,\n\tinput\t[2:0]\tf_adr_i,\n\tinput\t[63:0]\tf_dat_i,\n\toutput\t[63:0]\tf_dat_o,\n\n\toutput\t[7:0]\twb_sel_o,\n\toutput\t[63:0]\twb_dat_o,\n\tinput\t[63:0]\twb_dat_i\n);\n\twire size_byte = (f_siz_i == 2'b00);\n\twire size_hword = (f_siz_i == 2'b01);\n\twire size_word = (f_siz_i == 2'b10);\n\twire size_dword = (f_siz_i == 2'b11);\n\n\twire ab7 = f_adr_i[2:0] == 3'b111;\n\twire ab6 = f_adr_i[2:0] == 3'b110;\n\twire ab5 = f_adr_i[2:0] == 3'b101;\n\twire ab4 = f_adr_i[2:0] == 3'b100;\n\twire ab3 = f_adr_i[2:0] == 3'b011;\n\twire ab2 = f_adr_i[2:0] == 3'b010;\n\twire ab1 = f_adr_i[2:0] == 3'b001;\n\twire ab0 = f_adr_i[2:0] == 3'b000;\n\n\twire ah3 = f_adr_i[2:1] == 2'b11;\n\twire ah2 = f_adr_i[2:1] == 2'b10;\n\twire ah1 = f_adr_i[2:1] == 2'b01;\n\twire ah0 = f_adr_i[2:1] == 2'b00;\n\n\twire aw1 = f_adr_i[2] == 1'b1;\n\twire aw0 = f_adr_i[2] == 1'b0;\n\n\twire den = size_dword;\n\twire wen1 = size_word & aw1;\n\twire wen0 = size_word & aw0;\n\twire hen3 = size_hword & ah3;\n\twire hen2 = size_hword & ah2;\n\twire hen1 = size_hword & ah1;\n\twire hen0 = size_hword & ah0;\n\twire ben7 = size_byte & ab7;\n\twire ben6 = size_byte & ab6;\n\twire ben5 = size_byte & ab5;\n\twire ben4 = size_byte & ab4;\n\twire ben3 = size_byte & ab3;\n\twire ben2 = size_byte & ab2;\n\twire ben1 = size_byte & ab1;\n\twire ben0 = size_byte & ab0;\n\n\twire sel7 = den | wen1 | hen3 | ben7;\n\twire sel6 = den | wen1 | hen3 | ben6;\n\twire sel5 = den | wen1 | hen2 | ben5;\n\twire sel4 = den | wen1 | hen2 | ben4;\n\twire sel3 = den | wen0 | hen1 | ben3;\n\twire sel2 = den | wen0 | hen1 | ben2;\n\twire sel1 = den | wen0 | hen0 | ben1;\n\twire sel0 = den | wen0 | hen0 | ben0;\n\n\tassign wb_sel_o = {sel7, sel6, sel5, sel4, sel3, sel2, sel1, sel0};\n\n\twire [7:0] od7 =\n\t\t(size_byte ? f_dat_i[7:0] : 0) |\n\t\t(size_hword ? f_dat_i[15:8] : 0) |\n\t\t(size_word ? f_dat_i[31:24] : 0) |\n\t\t(size_dword ? f_dat_i[63:56] : 0);\n\n\twire [7:0] od6 =\n\t\t(size_byte ? f_dat_i[7:0] : 0) |\n\t\t(size_hword ? f_dat_i[7:0] : 0) |\n\t\t(size_word ? f_dat_i[23:16] : 0) |\n\t\t(size_dword ? f_dat_i[55:48] : 0);\n\n\twire [7:0] od5 =\n\t\t(size_byte ? f_dat_i[7:0] : 0) |\n\t\t(size_hword ? f_dat_i[15:8] : 0) |\n\t\t(size_word ? f_dat_i[15:8] : 0) |\n\t\t(size_dword ? f_dat_i[47:40] : 0);\n\n\twire [7:0] od4 =\n\t\t(size_byte ? f_dat_i[7:0] : 0) |\n\t\t(size_hword ? f_dat_i[7:0] : 0) |\n\t\t(size_word ? f_dat_i[7:0] : 0) |\n\t\t(size_dword ? f_dat_i[39:32] : 0);\n\n\twire [7:0] od3 =\n\t\t(size_byte ? f_dat_i[7:0] : 0) |\n\t\t(size_hword ? f_dat_i[15:8] : 0) |\n\t\t(size_word ? f_dat_i[31:24] : 0) |\n\t\t(size_dword ? f_dat_i[31:24] : 0);\n\n\twire [7:0] od2 =\n\t\t(size_byte ? f_dat_i[7:0] : 0) |\n\t\t(size_hword ? f_dat_i[7:0] : 0) |\n\t\t(size_word ? f_dat_i[23:16] : 0) |\n\t\t(size_dword ? f_dat_i[23:16] : 0);\n\n\twire [7:0] od1 =\n\t\t(size_byte ? f_dat_i[7:0] : 0) |\n\t\t(size_hword ? f_dat_i[15:8] : 0) |\n\t\t(size_word ? f_dat_i[15:8] : 0) |\n\t\t(size_dword ? f_dat_i[15:8] : 0);\n\n\twire [7:0] od0 = f_dat_i[7:0];\n\n\tassign wb_dat_o = {od7, od6, od5, od4, od3, od2, od1, od0};\n\n\twire [31:0] id2 =\n\t\t\t(wen1 ? wb_dat_i[63:32] : 0) |\n\t\t\t(wen0 ? wb_dat_i[31:0] : 0);\n\twire [15:0] id1 =\n\t\t\t(hen3 ? wb_dat_i[63:48] : 0) |\n\t\t\t(hen2 ? wb_dat_i[47:32] : 0) |\n\t\t\t(hen1 ? wb_dat_i[31:16] : 0) |\n\t\t\t(hen0 ? wb_dat_i[15:0] : 0);\n\twire [7:0] id0 =\n\t\t\t(ben7 ? wb_dat_i[63:56] : 0) |\n\t\t\t(ben6 ? wb_dat_i[55:48] : 0) |\n\t\t\t(ben5 ? wb_dat_i[47:40] : 0) |\n\t\t\t(ben4 ? wb_dat_i[39:32] : 0) |\n\t\t\t(ben3 ? wb_dat_i[31:24] : 0) |\n\t\t\t(ben2 ? wb_dat_i[23:16] : 0) |\n\t\t\t(ben1 ? wb_dat_i[15:8] : 0) |\n\t\t\t(ben0 ? wb_dat_i[7:0] : 0);\n\twire [63:32] id2s = (f_signed_i ? {32{id2[31]}} : 32'd0);\n\twire [63:16] id1s = (f_signed_i ? {48{id1[15]}} : 48'd0);\n\twire [63:8] id0s = (f_signed_i ? {56{id0[7]}} : 56'd0);\n\n\tassign f_dat_o =\n\t\t(size_dword ? wb_dat_i : 0) |\n\t\t(size_word ? {id2s, id2} : 0) |\n\t\t(size_hword ? {id1s, id1} : 0) |\n\t\t(size_byte ? {id0s, id0} : 0);\nendmodule\n\n",
        "module_name": "bridge",
        "module_hash": "17848781363996f0f5a17a6ae013f819",
        "dataset_index": 25405
      },
      "num_operation_31c580ef": {
        "rtl_code": "module num_operation(\ninput wire clk,\ninput wire [3:0] num_a,\ninput wire [3:0] num_b,\ninput wire ctrl,\noutput reg [3:0] out\n);\n\nalways @(posedge clk) begin\n\tif(ctrl == 0) begin\n\t\tout <= num_a + num_b;\n\tend\n\telse begin\n\t\tout <= num_a - num_b;\n\tend\nend\n\nendmodule",
        "module_name": "num_operation",
        "module_hash": "31c580ef11312b208e5bc2a2ad181b0b",
        "dataset_index": 5738
      },
      "ctr_fsm_d4a150ef": {
        "rtl_code": "\n\n\nmodule ctr_fsm(clk, ar, start, stop, ctr_en, ctr_ar);\n  \n  parameter [1:0] IDLE=2'b00, PRERUN=2'b01, RUN=2'b10, STOPPED=2'b11;\n\n  parameter start_assert = 1'b1; parameter stop_assert = 1'b0; \n  input clk, ar, start, stop;\n  output ctr_en, ctr_ar;\n\n  \n  reg [1:0] state;\n\n  \n  assign ctr_en = (state==RUN); assign ctr_ar = ~(state==PRERUN|state==IDLE); \n  always @ (posedge clk or negedge ar)\n  begin\n    if(~ar)\n    begin\n      state <= IDLE; end else\n    begin\n      case(state)\n        IDLE:begin\n          if(start==start_assert) begin\n            state<=PRERUN;\n          end else\n          begin\n            state<=IDLE;\n          end\n        end\n        PRERUN:begin\n          if(stop==stop_assert)\n          begin\n            state<=STOPPED; end else\n          begin\n            state<=RUN; end\n        end\n        RUN:begin if(stop==stop_assert) begin\n            state<=STOPPED;\n          end\n\t\t\t else begin\n            state<=RUN;\n          end\n        end\n\t\t  default:begin if(start==~start_assert) begin\n            state<=IDLE;\n          end else\n          begin\n            state<=STOPPED; end\n        end\n      endcase\n    end\n  end\n\n  endmodule",
        "module_name": "ctr_fsm",
        "module_hash": "d4a150ef67a235e1cc2c861e67a90cc7",
        "dataset_index": 22882
      },
      "max_value_dd13227f": {
        "rtl_code": "\nmodule max_value (\n    input [4:0] a,\n    input [4:0] b,\n    output [4:0] result\n);\n\n    assign result = (a >= b) ? a : b;\n\nendmodule",
        "module_name": "max_value",
        "module_hash": "dd13227f5288e208665917790f922385",
        "dataset_index": 15313
      },
      "comparator_be64b929": {
        "rtl_code": "module comparator (\n    A,\n    B,\n    EQ\n);\n\n    input [1:0] A;\n    input [1:0] B;\n    output reg EQ;\n\n    always @(*) begin\n        if (A == B) begin\n            EQ = 1;\n        end else begin\n            EQ = 0;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "be64b929667606d6d5a566da9e83fbf0",
        "dataset_index": 20671
      },
      "schmitt_trigger_2a6d2394": {
        "rtl_code": "module schmitt_trigger (\n  input in,\n  input Vt_high,\n  input Vt_low,\n  input Vdd,\n  output out\n);\n\n  reg out_reg;\n  reg prev_out_reg;\n  \n  always @ (in or prev_out_reg)\n  begin\n    if (prev_out_reg == 1'b0 && in >= Vt_high)\n      out_reg = 1'b1;\n    else if (prev_out_reg == 1'b1 && in <= Vt_low)\n      out_reg = 1'b0;\n    else\n      out_reg = prev_out_reg;\n  end\n  \n  assign out = out_reg;\n  \n  always @ (posedge Vdd)\n  begin\n    prev_out_reg <= out_reg;\n  end\n  \nendmodule",
        "module_name": "schmitt_trigger",
        "module_hash": "2a6d2394b32de0cd5b527f5bbaac811e",
        "dataset_index": 9132
      },
      "HEXto7Segment_6541a1a1": {
        "rtl_code": "\nmodule HEXto7Segment(HEXnumber,Segments);\n\tinput [3:0] HEXnumber;\n\toutput reg [7:0] Segments;\n\n\talways @ (HEXnumber)\n\t\tcase (HEXnumber)\n\t\t0:\tSegments <= 8'B11000000;\n\t\t1:\tSegments <= 8'B11111001;\n\t\t2:\tSegments <= 8'B10100100;\n\t\t3:\tSegments <= 8'B10110000;\n\t\t4:\tSegments <= 8'B10011001;\n\t\t5:\tSegments <= 8'B10010010;\n\t\t6:\tSegments <= 8'B10000010;\n\t\t7:\tSegments <= 8'B11111000;\n\t\t8:\tSegments <= 8'B10000000;\n\t\t9:\tSegments <= 8'B10010000;\n\t\t10: Segments <= 8'B10001000;\n\t\t11: Segments <= 8'B10000011;\n\t\t12: Segments <= 8'B11000110;\n\t\t13: Segments <= 8'B10100001;\n\t\t14: Segments <= 8'B10000110;\n\t\t15: Segments <= 8'B10001110;\n\t\tdefault:\tSegments <= 8'B00000000;\n\t\tendcase\n\nendmodule\n",
        "module_name": "HEXto7Segment",
        "module_hash": "6541a1a19e473b29c6886cce5a4eaded",
        "dataset_index": 22121
      },
      "up_counter_925a9d1d": {
        "rtl_code": "module up_counter (\n    input clk,\n    input reset,\n    output reg [2:0] out\n  );\n\n  always @(posedge clk) begin\n    if (reset) begin\n      out <= 0;\n    end else begin\n      out <= out + 1;\n    end\n  end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "925a9d1d8b3da860390bf15d005af62f",
        "dataset_index": 12993
      },
      "ag6502_phase_shift_a081c7ab": {
        "rtl_code": "\nmodule ag6502_phase_shift(input baseclk, input phi_0, output reg phi_1);\n    parameter DELAY = 1; // delay in waves of baseclk\n    initial phi_1 = 0;\n    integer cnt = 0;\n    reg delayed_clk = 0;\n\n    always @(posedge baseclk) begin\n        if (phi_0 != phi_1) begin\n            if (!cnt) begin\n                delayed_clk <= 1'b1;\n                cnt <= DELAY;\n            end\n            else cnt <= cnt - 1;\n        end\n        else begin\n            if (cnt) begin\n                cnt <= cnt - 1;\n            end\n            else\n                delayed_clk <= 1'b0;\n        end\n    end\n\n    always @(posedge baseclk) begin\n        if (cnt) phi_1 <= phi_1;\n        else if (delayed_clk) phi_1 <= ~phi_1;\n        else phi_1 <= phi_0;\n    end\nendmodule",
        "module_name": "ag6502_phase_shift",
        "module_hash": "a081c7abb45b58fabe6a3b4236d1d03b",
        "dataset_index": 11521
      },
      "functional__c16c11f2": {
        "rtl_code": "\nmodule functional_module (\n    input [7:0] dff_out,\n    input xnor_out,\n    output reg [7:0] xor_out\n);\n    always @(*) begin\n        xor_out = dff_out ^ xnor_out;\n    end\nendmodule\n",
        "module_name": "functional_",
        "module_hash": "c16c11f27714980d43ca32d5fdad24f4",
        "dataset_index": 17517
      },
      "ad_csc_1 #_90d28b13": {
        "rtl_code": "module ad_csc_1 #(\n  parameter  DELAY_DATA_WIDTH = 16,\n  parameter  DW = DELAY_DATA_WIDTH - 1\n)(\n  input           clk,\n  input   [DW:0]  sync,\n  input   [23:0]  data,\n  input   [16:0]  C1,\n  input   [16:0]  C2,\n  input   [16:0]  C3,\n  input   [24:0]  C4,\n  output  [DW:0]  csc_sync_1,\n  output  [7:0]   csc_data_1\n);\n\n\n  reg [23:0]   delayed_data;\n  reg          delayed_sync;\n\n  always @(posedge clk) begin\n    delayed_data <= data;\n    delayed_sync <= sync;\n  end\n\n  reg [23:0]   CrYCb_data;\n  reg          CrYCb_sync;\n\n  always @(posedge clk) begin\n    if (delayed_sync) begin\n      CrYCb_sync <= 1'b1;\n      CrYCb_data <= 0;\n    end else begin\n      CrYCb_sync <= 1'b0;\n      CrYCb_data <= {CrYCb_data[7:0], csc_data_1};\n    end\n  end\n\n  reg [31:0]   CrYCb_calc;\n  reg [15:0]   CrYCb_calc_trunc;\n\n  always @(*) begin\n    CrYCb_calc = (C1 * delayed_data[23:16]) + (C2 * delayed_data[15:8]) + (C3 * delayed_data[7:0]) + C4;\n    CrYCb_calc_trunc = CrYCb_calc[23:8];\n  end\n\n  assign csc_sync_1 = CrYCb_sync;\n  assign csc_data_1 = CrYCb_calc_trunc;\n\nendmodule",
        "module_name": "ad_csc_1 #",
        "module_hash": "90d28b1360555567ee9cee6851b60440",
        "dataset_index": 230
      },
      "dual_port_ram_ecbe70cd": {
        "rtl_code": "module dual_port_ram (\n    input clk,\n    input rst_n,\n    input [1:0] write_en_0,\n    input [3:0] write_addr_0,\n    input [15:0] write_data_0,\n    input [1:0] write_en_1,\n    input [3:0] write_addr_1,\n    input [15:0] write_data_1,\n    input [1:0] read_en_0,\n    input [3:0] read_addr_0,\n    output reg [15:0] read_data_0,\n    input [1:0] read_en_1,\n    input [3:0] read_addr_1,\n    output reg [15:0] read_data_1\n);\n\nreg [15:0] mem [0:15];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        read_data_0 <= 16'b0;\n        read_data_1 <= 16'b0;\n    end else begin\n        if (write_en_0) begin\n            mem[write_addr_0] <= write_data_0;\n        end\n\n        if (write_en_1) begin\n            mem[write_addr_1] <= write_data_1;\n        end\n\n        if (read_en_0) begin\n            read_data_0 <= mem[read_addr_0];\n        end\n\n        if (read_en_1) begin\n            read_data_1 <= mem[read_addr_1];\n        end\n    end\nend\n\nendmodule",
        "module_name": "dual_port_ram",
        "module_hash": "ecbe70cd967a02a4adde2290a9816bac",
        "dataset_index": 4179
      },
      "rotator_8060c421": {
        "rtl_code": "\nmodule rotator (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q);\n\n    reg [99:0] shift_reg;\n    wire [99:0] shifted_data;\n\n    assign shifted_data = {shift_reg[0], shift_reg[99:1]};\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else begin\n            case (ena)\n                2'b00: shift_reg <= shifted_data;\n                2'b01: shift_reg <= {shift_reg[99], shift_reg[99:1]};\n                2'b10: shift_reg <= {shift_reg[0], shift_reg[99:1]};\n                2'b11: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    assign q = shift_reg;\nendmodule\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q);\n\n    rotator rotator_inst(\n        .clk(clk),\n        .load(load),\n        .ena(ena),\n        .data(data),\n        .q(q)\n    );\n\nendmodule",
        "module_name": "rotator",
        "module_hash": "8060c421c70b8b44d54dad486dfac136",
        "dataset_index": 10356
      },
      "top_module_12484c9a": {
        "rtl_code": "\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n); \n\n    wire [7:0] or_bitwise;\n    wire or_logical;\n    wire [2:0] not_a;\n    wire [2:0] not_b;\n\n    assign or_bitwise = a | b; // Fixed the instantiation of decoder_module\n    assign or_logical = a ^ b; // Fixed the instantiation of xor_module\n    assign not_a = ~a; // Fixed the instantiation of not_decoder\n    assign not_b = ~b; // Fixed the instantiation of not_decoder2\n\n    assign out_or_bitwise = or_bitwise[2:0];\n    assign out_or_logical = or_logical;\n    assign out_not = {not_b, not_a};\n\nendmodule\n\nmodule decoder_module(\n    input [2:0] in,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        case(in)\n            3'b000: out = 8'b00000001;\n            3'b001: out = 8'b00000010;\n            3'b010: out = 8'b00000100;\n            3'b011: out = 8'b00001000;\n            3'b100: out = 8'b00010000;\n            3'b101: out = 8'b00100000;\n            3'b110: out = 8'b01000000;\n            3'b111: out = 8'b10000000;\n            default: out = 8'b00000000;\n        endcase\n    end\n\nendmodule\n\nmodule xor_module(\n    input a,\n    input b,\n    output reg out\n);\n\n    always @(a, b) begin\n        out = a ^ b;\n    end\n\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "12484c9ae3d5b91eaf7a3ebc4a7686fa",
        "dataset_index": 14084
      },
      "mux4to1_e8b475d0": {
        "rtl_code": "module mux4to1 (\n    Y,\n    A0,\n    A1,\n    A2,\n    A3,\n    S0,\n    S1\n);\n\n    // Module ports\n    output Y;\n    input A0;\n    input A1;\n    input A2;\n    input A3;\n    input S0;\n    input S1;\n\n    // Local signals\n    wire not_S0;\n    wire not_S1;\n    wire and_0_out;\n    wire and_1_out;\n    wire and_2_out;\n    wire and_3_out;\n    wire or_0_out;\n\n    // Invert S0 and S1\n    not not_S0_inst (not_S0, S0);\n    not not_S1_inst (not_S1, S1);\n\n    // AND gates\n    and and_0_inst (and_0_out, A0, not_S0, not_S1);\n    and and_1_inst (and_1_out, A1, not_S0, S1);\n    and and_2_inst (and_2_out, A2, S0, not_S1);\n    and and_3_inst (and_3_out, A3, S0, S1);\n\n    // OR gate\n    or or_0_inst (or_0_out, and_0_out, and_1_out, and_2_out, and_3_out);\n\n    // Output\n    assign Y = or_0_out;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "e8b475d025e2bdb1e5288f568eedf3d5",
        "dataset_index": 14073
      },
      "fifo4_cd17a7ed": {
        "rtl_code": "module fifo4(clk, rst, clr,  din, we, dout, re, full, empty);\n\nparameter dw = 8;           input\t\tclk, rst;\ninput\t\tclr;\ninput   [dw:1]\tdin;\ninput\t\twe;             output  [dw:1]\tdout;\ninput\t\tre;             output\t\tfull, empty;\n\n\nreg     [dw:1]\tmem[0:3];\nreg     [1:0]   wp;         reg     [1:0]   rp;         wire    [1:0]   wp_p1;      wire    [1:0]   rp_p1;      wire\t\tfull, empty;\nreg\t\tgb;\n\nalways @(posedge clk or negedge rst)\n        if(!rst)\twp <= #1 2'h0;\n        else\n        if(clr)\t\twp <= #1 2'h0;\n        else\n        if(we)\t\twp <= #1 wp_p1;\n\nassign wp_p1 = wp + 2'h1;\n\nalways @(posedge clk or negedge rst)\n        if(!rst)\trp <= #1 2'h0;\n        else\n        if(clr)\t\trp <= #1 2'h0;\n        else\n        if(re)\t\trp <= #1 rp_p1;\n\nassign rp_p1 = rp + 2'h1;\n\nassign  dout = mem[ rp ];\n\nalways @(posedge clk)\n        if(we)\tmem[ wp ] <= #1 din;\n\nassign empty = (wp == rp) & !gb;\nassign full  = (wp == rp) &  gb;\n\nalways @(posedge clk)\n\tif(!rst)\t\t\tgb <= #1 1'b0;\n\telse\n\tif(clr)\t\t\t\tgb <= #1 1'b0;\n\telse\n\tif((wp_p1 == rp) & we)\t\tgb <= #1 1'b1;\n\telse\n\tif(re)\t\t\t\tgb <= #1 1'b0;\n\nendmodule\n",
        "module_name": "fifo4",
        "module_hash": "cd17a7edc6e7c45ed69c4c79afa124f5",
        "dataset_index": 15828
      },
      "xor_splitter_b4cfbba8": {
        "rtl_code": "module xor_splitter (\n  input wire [15:0] in,\n  input wire a,\n  input wire b,\n  output wire [7:0] out_xor\n);\n\n  wire [7:0] upper_byte;\n  wire [7:0] lower_byte;\n\n  // instantiate the half-word splitter module\n  splitter16 splitter_inst (\n    .in(in),\n    .a(a),\n    .b(b),\n    .upper(upper_byte),\n    .lower(lower_byte)\n  );\n\n  // instantiate the XOR gate module\n  xor_gate xor_inst (\n    .in1(upper_byte),\n    .in2(lower_byte),\n    .out(out_xor)\n  );\n\nendmodule\n\nmodule splitter16 (\n  input wire [15:0] in,\n  input wire a,\n  input wire b,\n  output wire [7:0] upper,\n  output wire [7:0] lower\n);\n\n  assign upper = (a == 1'b0) ? in[7:0] : in[15:8];\n  assign lower = (b == 1'b0) ? in[7:0] : in[15:8];\n\nendmodule\n\nmodule xor_gate (\n  input wire [7:0] in1,\n  input wire [7:0] in2,\n  output wire [7:0] out\n);\n\n  assign out = in1 ^ in2;\n\nendmodule",
        "module_name": "xor_splitter",
        "module_hash": "b4cfbba8c33bd999c348bfd977bc48fe",
        "dataset_index": 6573
      },
      "bcd_counter_8ae30ed2": {
        "rtl_code": "\nmodule bcd_counter (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            case (q)\n                4'b0000: q <= 4'b0001;\n                4'b0001: q <= 4'b0010;\n                4'b0010: q <= 4'b0011;\n                4'b0011: q <= 4'b0100;\n                4'b0100: q <= 4'b0101;\n                4'b0101: q <= 4'b0110;\n                4'b0110: q <= 4'b0111;\n                4'b0111: q <= 4'b1000;\n                4'b1000: q <= 4'b1001;\n                4'b1001: q <= 4'b0000;\n                default: q <= 4'b0000;\n            endcase\n        end\n    end\n\nendmodule\nmodule priority_encoder (\n    input [3:0] in,\n    output reg [1:0] out\n);\n\n    always @(*) begin\n        out[1] = |in[3:2];\n        out[0] = |in[1:0];\n    end\n\nendmodule\nmodule multiplier (\n    input [3:0] in,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out = in << 4;\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output reg [3:0] ena,\n    output reg [7:0] q\n);\n\n    wire [1:0] ena_wire;\n    wire [3:0] bcd_out;\n    wire [7:0] mult_out;\n\n    bcd_counter counter(clk, reset, bcd_out);\n    priority_encoder encoder(bcd_out, ena_wire);\n    multiplier mult(bcd_out, mult_out);\n\n    always @(*) begin\n        ena = ena_wire;\n        q = mult_out;\n    end\n\nendmodule",
        "module_name": "bcd_counter",
        "module_hash": "8ae30ed2da762d0d73d669b32dbef6f6",
        "dataset_index": 7620
      },
      "clock_divider_cd5796b8": {
        "rtl_code": "module clock_divider (\n  input     clkin,\n  input     reset,\n  output    clkoutp,\n  output    clkoutn\n);\n\n  parameter clkdiv = 2;\n\n  reg       clkbase;\n  reg [6:0] clkcnt;\n\n  assign clkoutp = ~clkbase;\n  assign clkoutn = clkbase;\n\n  always @(posedge clkin or negedge reset) begin\n    if (~reset) begin\n      clkcnt  <= 0;\n      clkbase <= 0;\n    end else begin\n      if (clkcnt == clkdiv-1) begin\n        clkcnt  <= 0;\n        clkbase <= ~clkbase;\n      end else begin\n        clkcnt <= clkcnt + 1;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "clock_divider",
        "module_hash": "cd5796b80c952393c3b8c8280023b9a2",
        "dataset_index": 3232
      },
      "BOR_636bbca0": {
        "rtl_code": "\nmodule BOR (\n  input wire vcc,\n  input wire clk,\n  output reg rst,\n  input wire vth // voltage threshold\n);\n\nparameter vcc_min = 1.2; // minimum voltage level of power supply\nparameter t_reset = 10; // duration of reset signal in clock cycles. \n\nreg [7:0] counter; // 8-bit counter to keep track of reset duration\n\nalways @(posedge clk) begin\n  if (vcc < vth) begin\n    rst <= 1'b1; // assert reset signal if voltage is below threshold\n    counter <= counter + 1; // increment counter\n  end else begin\n    if (counter >= t_reset) begin\n      rst <= 1'b0; // de-assert reset signal if duration is over\n      counter <= 8'd0; // reset counter\n    end else begin\n      counter <= counter + 1; // increment counter\n    end\n  end\nend\n\nendmodule",
        "module_name": "BOR",
        "module_hash": "636bbca08a95d0956cda179d99e8aed4",
        "dataset_index": 13712
      },
      "sky130_fd_sc_ls__o41ai_56920ee9": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__o41ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A4, A3, A2, A1 );\n    nand nand0 (nand0_out_Y, B1, or0_out    );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__o41ai",
        "module_hash": "56920ee90c2464ba59efed867ba328a5",
        "dataset_index": 23251
      },
      "counter__f2cb0574": {
        "rtl_code": "\nmodule counter_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    output [5:0] q, // 6-bit output from the functional module\n    output reg [3:0] out1, out2 // Outputs from the two given 4-bit counters\n);\n\nreg [3:0] counter1 = 4'b0000; // First 4-bit counter\nreg [3:0] counter2 = 4'b0000; // Second 4-bit counter\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter1 <= 4'b0000;\n        counter2 <= 4'b0000;\n    end else begin\n        counter1 <= counter1 + 1;\n        counter2 <= counter2 + 1;\n    end\n    out1 <= counter1;\n    out2 <= counter2;\nend\n\nassign q = {counter2, counter1}; // Concatenation of the two counters\n\nendmodule",
        "module_name": "counter_",
        "module_hash": "f2cb0574f5c0e17323376ede8eaf5ae3",
        "dataset_index": 11380
      },
      "reset_synchronizer #_27afc232": {
        "rtl_code": "module reset_synchronizer #(\n    parameter NUM_RESET_OUTPUT = 1,\n    parameter RESET_SYNC_STAGES = 4\n) (\n    input reset_n,\n    input clk,\n    output [NUM_RESET_OUTPUT-1:0] reset_n_sync\n);\n\n\nreg [RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:0] reset_reg ;\n\ngenerate\ngenvar i;\n    for (i=0; i<RESET_SYNC_STAGES+NUM_RESET_OUTPUT-1; i=i+1) begin: reset_stage\n        always @(posedge clk or negedge reset_n) begin\n            if (~reset_n) begin\n                reset_reg[i] <= 1'b0;\n            end else begin\n                if (i==0) begin\n                    reset_reg[i] <= 1'b1;\n                end else if (i < RESET_SYNC_STAGES) begin\n                    reset_reg[i] <= reset_reg[i-1];\n                end else begin\n                    reset_reg[i] <= reset_reg[RESET_SYNC_STAGES-2];\n                end\n            end\n        end\n    end\nendgenerate\n\nassign reset_n_sync = reset_reg[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:RESET_SYNC_STAGES-1];\n\nendmodule",
        "module_name": "reset_synchronizer #",
        "module_hash": "27afc232231420e43f8aaa9e2226b421",
        "dataset_index": 8422
      },
      "fscmos #_514a1a17": {
        "rtl_code": "\nmodule fscmos #\n(\n\tparameter integer C_IN_WIDTH\t= 8,\n\tparameter integer C_OUT_WIDTH\t= 8\n)\n(\n\tinput wire\t\tcmos_pclk,\n\n\tinput wire\t\tcmos_vsync,\n\tinput wire\t\tcmos_href,\n\tinput wire [C_IN_WIDTH-1:0]\tcmos_data,\n\n\toutput wire\t\tvid_active_video,\n\toutput wire[C_OUT_WIDTH-1:0]\tvid_data,\n\toutput wire\t\tvid_hblank,\n\toutput wire\t\tvid_hsync,\n\toutput wire\t\tvid_vblank,\n\toutput wire\t\tvid_vsync\n);\n\tassign vid_active_video= (cmos_href && ~cmos_vsync);\n\n\tassign vid_hblank = ~cmos_href;\n\tassign vid_hsync = vid_hblank;\n\n\tassign vid_vsync = vid_vblank;\n\tassign vid_vblank = ~cmos_vsync;\ngenerate\nif (C_IN_WIDTH < C_OUT_WIDTH) begin: in_lt_out\n\tassign vid_data = {cmos_data, {(C_OUT_WIDTH - C_IN_WIDTH){1'b0}}};\nend\nelse begin: in_ge_out\n\tassign vid_data = cmos_data[C_IN_WIDTH-1:C_IN_WIDTH-C_OUT_WIDTH];\nend\nendgenerate\nendmodule\n",
        "module_name": "fscmos #",
        "module_hash": "514a1a178189a119e654d89df0e46b56",
        "dataset_index": 23586
      },
      "feedforward_mux_4to1_sel2_8_1 #_46017762": {
        "rtl_code": "\n\nmodule feedforward_mux_4to1_sel2_8_1 #(\nparameter\n    ID                = 0,\n    NUM_STAGE         = 1,\n    din1_WIDTH       = 32,\n    din2_WIDTH       = 32,\n    din3_WIDTH       = 32,\n    din4_WIDTH       = 32,\n    din5_WIDTH         = 32,\n    dout_WIDTH            = 32\n)(\n    input  [7 : 0]     din1,\n    input  [7 : 0]     din2,\n    input  [7 : 0]     din3,\n    input  [7 : 0]     din4,\n    input  [1 : 0]    din5,\n    output [7 : 0]   dout);\n\nwire [1 : 0]     sel;\nwire [7 : 0]         mux_1_0;\nwire [7 : 0]         mux_1_1;\nwire [7 : 0]         mux_2_0;\n\nassign sel = din5;\n\nassign mux_1_0 = (sel[0] == 0)? din1 : din2;\nassign mux_1_1 = (sel[0] == 0)? din3 : din4;\n\nassign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;\n\nassign dout = mux_2_0;\n\nendmodule\n",
        "module_name": "feedforward_mux_4to1_sel2_8_1 #",
        "module_hash": "460177627f9cce4aac8920d397e9b966",
        "dataset_index": 24709
      },
      "sky130_fd_sc_ls__or3b_80103c8f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__or3b (\n    X  ,\n    A  ,\n    B  ,\n    C_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , C_N            );\n    or  or0  (or0_out_X, B, A, not0_out );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__or3b",
        "module_hash": "80103c8f4b3af2a8348c0385ae2d2372",
        "dataset_index": 7161
      },
      "adder_4bit_f6ab4454": {
        "rtl_code": "module adder_4bit(A, B, S, Cout);\ninput [3:0] A;\ninput [3:0] B;\noutput [3:0] S;\noutput Cout;\n\nwire [4:0] temp_sum;\nassign temp_sum = A + B;\n\nassign Cout = temp_sum[4];\nassign S = temp_sum[3:0];\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "f6ab4454012aada06056e992255529d4",
        "dataset_index": 11067
      },
      "comb_logic_4c7dc475": {
        "rtl_code": "module comb_logic (\n  input a,\n  input b,\n  output q\n);\n\n  assign q = (a & b);\n\nendmodule\n",
        "module_name": "comb_logic",
        "module_hash": "4c7dc4755308b57f37cfd48d17a7b736",
        "dataset_index": 7576
      },
      "spi_device_04ce31ee": {
        "rtl_code": "module spi_device (\n    input reset,\n    input clk,\n    input [7:0] data_in,\n    output reg mosi,\n    input miso,\n    output reg ready\n);\n\n    reg [7:0] buffer;\n    reg [2:0] cnt;\n    reg [7:0] data;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            buffer <= 8'h00;\n            cnt <= 3'h0;\n            data <= 8'h00;\n            mosi <= 1'b0;\n            ready <= 1'b0;\n        end else begin\n            if (cnt == 3'h0) begin\n                buffer <= data_in;\n                mosi <= buffer[7];\n                cnt <= 3'h1;\n            end else if (cnt == 3'h7) begin\n                buffer <= {buffer[6:0], miso};\n                cnt <= 3'h0;\n                data <= data + 8'h01;\n                if (data == 8'hff) begin\n                    ready <= 1'b1;\n                end\n            end else begin\n                buffer <= {buffer[6:0], mosi};\n                mosi <= buffer[7];\n                cnt <= cnt + 3'h1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "spi_device",
        "module_hash": "04ce31eed8d02573c996965159a7523a",
        "dataset_index": 2884
      },
      "my_module_989474f7": {
        "rtl_code": "\nmodule my_module(clk, data_in, data_out, in0, in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12);\n\n  parameter WIDTH = 64;\n\n  input clk;\n  input [WIDTH-1:0] data_in;\n  output [WIDTH-1:0] data_out;\n  input [12:0] in0, in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12;\n  \n  reg [WIDTH-1:0] probe0;\n  reg [WIDTH-1:0] probe1;\n  reg [12:0] inv_in;\n\n  assign data_out = probe1;  // Corrected the line to assign data_out\n\n  always @(posedge clk) begin\n    probe0 <= data_in;\n    inv_in <= ~{in12, in11, in10, in9, in8, in7, in6, in5, in4, in3, in2, in1, in0};\n  end\n\n  always @(negedge clk) begin\n    probe1 <= probe0;\n  end\n\nendmodule\n",
        "module_name": "my_module",
        "module_hash": "989474f7909daf4dca30c3634b9d8b2d",
        "dataset_index": 6195
      },
      "parity_generator_5602ac4c": {
        "rtl_code": "module parity_generator (\n  input clk,\n  input [7:0] in,\n  output reg parity_bit\n);\n\n  integer i;\n  reg [7:0] in_reg;\n  reg parity_calculated;\n  \n  always @(posedge clk) begin\n    in_reg <= in;\n    parity_calculated <= 1'b0;\n    for (i = 0; i < 8; i = i + 1) begin\n      parity_calculated <= parity_calculated ^ in_reg[i];\n    end\n    parity_bit <= parity_calculated;\n  end\n  \nendmodule\n",
        "module_name": "parity_generator",
        "module_hash": "5602ac4c57353d24746438bf9b3d67ea",
        "dataset_index": 17647
      },
      "RC_Oscillator_a7430ea7": {
        "rtl_code": "module RC_Oscillator (\n  output reg out,\n  input clk\n);\n\nparameter real r = 100; // value of the resistor in ohms\nparameter real c = 1e-6; // value of the capacitor in farads\nparameter real f = 1000; // desired frequency of the output waveform in Hz\n\nreg [31:0] count = 0; // counter for generating the waveform\nreg state = 0; // state variable for the oscillator\n\nalways @ (posedge clk) begin\n  if (count == 0) begin\n    state <= ~state; // toggle the state variable\n  end\n  count <= count + 1; // increment the counter\nend\n\nalways @ (*) begin\n  out <= state; // output the state variable as the waveform\nend\n\nendmodule",
        "module_name": "RC_Oscillator",
        "module_hash": "a7430ea71c4f18c88c0b1fe2d7efb463",
        "dataset_index": 5740
      },
      "opening_detector_885f8a16": {
        "rtl_code": "\nmodule opening_detector(\n    input wire rx_pclk,\n    input wire rx_de,\n    input wire rx_hsync,\n    input wire rx_vsync,\n    input wire [7:0] rx_red,\n    input wire [7:0] rx_green,\n    input wire [7:0] rx_blue,\n    output wire tx_de,\n    output wire tx_hsync,\n    output wire tx_vsync,\n    output wire [7:0] tx_red,\n    output wire [7:0] tx_green,\n    output wire [7:0] tx_blue\n);\n\nwire opening;\nwire opening_de;\nwire opening_vsync;\nwire opening_hsync;\n\nopening3x3 open3(\n    .clk(rx_pclk),\n    .ce(1'b1),\n    .rst(1'b0),\n    .mask((rx_red == 8'hFF) ? 1'b1 : 1'b0),\n    .in_de(rx_de),\n    .in_vsync(rx_vsync),\n    .in_hsync(rx_hsync),\n    .opened(opening),\n    .out_de(opening_de),\n    .out_vsync(opening_vsync),\n    .out_hsync(opening_hsync)\n);\n\nreg [7:0] opening_r;\nreg [7:0] opening_g;\nreg [7:0] opening_b;\n\nalways @(posedge rx_pclk) begin\n    opening_r <= (opening) ? 8'hFF : rx_red;\n    opening_g <= (opening) ? 8'hFF : rx_green;\n    opening_b <= (opening) ? 8'hFF : rx_blue;\nend\n\nassign tx_de        = opening_de;\nassign tx_hsync     = opening_hsync;\nassign tx_vsync     = opening_vsync;\nassign tx_red       = opening_r;\nassign tx_green     = opening_g;\nassign tx_blue      = opening_b;\n\nendmodule\nmodule opening3x3(\n    input wire clk,\n    input wire ce,\n    input wire rst,\n    input wire mask,\n    input wire in_de,\n    input wire in_vsync,\n    input wire in_hsync,\n    output reg opened,\n    output reg out_de,\n    output reg out_vsync,\n    output reg out_hsync\n);\n\nparameter STATE_IDLE = 0,\n          STATE_SEARCH = 1,\n          STATE_FOUND = 2;\n\nreg [1:0] state;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state    <= STATE_IDLE;\n        opened   <= 0;\n        out_de   <= 0;\n        out_vsync<= 0;\n        out_hsync<= 0;\n    end else if (ce) begin\n        case (state)\n            STATE_IDLE: begin\n                if (mask)\n                    state = STATE_SEARCH;\n                else\n                    state = STATE_IDLE;\n            end\n            STATE_SEARCH: begin\n                if (!mask) begin\n                    state = STATE_IDLE;\n                    opened = 0;\n                end else if (in_de) begin\n                    state = STATE_FOUND;\n                    opened = 1;\n                end\n            end\n            STATE_FOUND: begin\n                if (!in_de) begin\n                    state = STATE_IDLE;\n                    opened = 0;\n                end\n            end\n        endcase\n\n        out_de = in_de;\n        out_vsync = in_vsync;\n        out_hsync = in_hsync;\n    end\nend\n\nendmodule",
        "module_name": "opening_detector",
        "module_hash": "885f8a16b824a0af3efffdf6ec40153f",
        "dataset_index": 11514
      },
      "mux2_a341b709": {
        "rtl_code": "module mux2(\n    input wire clk,   // clock signal\n    input wire sel,   // select signal\n    input wire in1,   // input signal 1\n    input wire in2,   // input signal 2\n    output reg out   // output signal\n);\n    always @(posedge clk) begin\n        if(sel == 1'b0) begin\n            out <= in1;\n        end else begin\n            out <= in2;\n        end\n    end\nendmodule",
        "module_name": "mux2",
        "module_hash": "a341b7098cf23fcf7a3a1ab4331a4812",
        "dataset_index": 13631
      },
      "mult_16bit_signed_94c48f52": {
        "rtl_code": "module mult_16bit_signed (\n    input signed [15:0] M,\n    input signed [15:0] N,\n    output reg signed [31:0] P\n);\n\n    always @(*) begin\n        P = M * N;\n    end\n\nendmodule",
        "module_name": "mult_16bit_signed",
        "module_hash": "94c48f52747318db587c8d6350c736bd",
        "dataset_index": 6057
      },
      "comparator_df0000d2": {
        "rtl_code": "module comparator (\n    input [1:0] A,\n    input [1:0] B,\n    output equal,\n    output greater_than,\n    output less_than\n);\n\n    assign equal = (A == B);\n    assign greater_than = (A > B);\n    assign less_than = (A < B);\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "df0000d205810065efe2e21feaa1791c",
        "dataset_index": 4769
      },
      "imuldiv_IntMulVariable_5b4eb99e": {
        "rtl_code": "`ifndef PARC_INT_MUL_VARIABLE_V\n`define PARC_INT_MUL_VARIABLE_V\n\nmodule imuldiv_IntMulVariable\n(\n  input         clk,\n  input         reset,\n\n  input  [31:0] mulreq_msg_a,\n  input  [31:0] mulreq_msg_b,\n  input         mulreq_val,\n  output        mulreq_rdy,\n\n  output [31:0] mulresp_msg_result,\n  output        mulresp_val,\n  input         mulresp_rdy\n);\n\n  wire          sign;\n  wire   [31:0] b_data;\n  wire          sign_en;\n  wire          result_en;\n  wire          a_mux_sel;\n  wire          b_mux_sel;\n  wire    [4:0] op_shamt;\n  wire          result_mux_sel;\n  wire          add_mux_sel;\n  wire          sign_mux_sel;\n\n  wire   [63:0] dpath_out;\n  assign mulresp_msg_result = dpath_out[31:0];\n\n  imuldiv_IntMulVariableDpath dpath\n  (\n    .clk                (clk),\n    .reset              (reset),\n    .mulreq_msg_a       (mulreq_msg_a),\n    .mulreq_msg_b       (mulreq_msg_b),\n    .mulresp_msg_result (dpath_out),\n    .sign               (sign),\n    .b_data             (b_data),\n    .sign_en            (sign_en),\n    .result_en          (result_en),\n    .a_mux_sel          (a_mux_sel),\n    .b_mux_sel          (b_mux_sel),\n    .op_shamt           (op_shamt),\n    .result_mux_sel     (result_mux_sel),\n    .add_mux_sel        (add_mux_sel),\n    .sign_mux_sel       (sign_mux_sel)\n  );\n\n  imuldiv_IntMulVariableCtrl ctrl\n  (\n    .clk            (clk),\n    .reset          (reset),\n    .mulreq_val     (mulreq_val),\n    .mulreq_rdy     (mulreq_rdy),\n    .mulresp_val    (mulresp_val),\n    .mulresp_rdy    (mulresp_rdy),\n    .sign           (sign),\n    .b_data         (b_data),\n    .sign_en        (sign_en),\n    .result_en      (result_en),\n    .a_mux_sel      (a_mux_sel),\n    .b_mux_sel      (b_mux_sel),\n    .op_shamt       (op_shamt),\n    .result_mux_sel (result_mux_sel),\n    .add_mux_sel    (add_mux_sel),\n    .sign_mux_sel   (sign_mux_sel)\n  );\n\nendmodule\n\nmodule imuldiv_IntMulVariableDpath\n(\n  input                clk,\n  input                reset,\n\n  input  [31:0] mulreq_msg_a,\n  input  [31:0] mulreq_msg_b,\n  output [63:0] mulresp_msg_result,\n\n  output        sign,\n  output [31:0] b_data,\n\n  input         sign_en,\n  input         result_en,\n  input         a_mux_sel,\n  input         b_mux_sel,\n  input   [4:0] op_shamt,\n  input         result_mux_sel,\n  input         add_mux_sel,\n  input         sign_mux_sel\n);\n\n  localparam op_x     = 1'dx;\n  localparam op_load  = 1'd0;\n  localparam op_next  = 1'd1;\n\n  localparam add_x    = 1'dx;\n  localparam add_old  = 1'd0;\n  localparam add_next = 1'd1;\n\n  localparam sign_x   = 1'dx;\n  localparam sign_u   = 1'd0;\n  localparam sign_s   = 1'd1;\n\n  reg         sign_reg;\n  wire [63:0] a_shift_out;\n  wire [31:0] b_shift_out;\n  wire [63:0] result_mux_out;\n  wire [63:0] signed_result_mux_out;\n\n  wire   sign_next = mulreq_msg_a[31] ^ mulreq_msg_b[31];\n\n  assign sign      = sign_reg;\n\n  wire [31:0] unsigned_a\n    = ( mulreq_msg_a[31] ) ? ~mulreq_msg_a + 1'b1\n    :                         mulreq_msg_a;\n\n  wire [31:0] unsigned_b\n    = ( mulreq_msg_b[31] ) ? ~mulreq_msg_b + 1'b1\n    :                         mulreq_msg_b;\n\n  wire [63:0] a_mux_out\n    = ( a_mux_sel == op_load ) ? { 32'b0, unsigned_a }\n    : ( a_mux_sel == op_next ) ? a_shift_out\n    :                            64'bx;\n\n  wire [31:0]   b_mux_out\n    = ( b_mux_sel == op_load ) ? unsigned_b\n    : ( b_mux_sel == op_next ) ? b_shift_out\n    :                            32'bx;\n\n  reg [63:0] a_reg;\n  reg [31:0] b_reg;\n  reg [63:0] result_reg;\n\n  always @ ( posedge clk ) begin\n    if ( sign_en ) begin\n      sign_reg   <= sign_next;\n    end\n\n    if ( result_en ) begin\n      result_reg <= result_mux_out;\n    end\n\n    a_reg        <= a_mux_out;\n    b_reg        <= b_mux_out;\n  end\n\n  assign b_data = b_reg;\n\n  assign a_shift_out = a_reg << op_shamt;\n\n  assign b_shift_out = b_reg >> op_shamt;\n\n  wire [63:0] add_out = result_reg + a_reg;\n\n  wire [63:0] add_mux_out\n    = ( add_mux_sel == add_old )  ? result_reg\n    : ( add_mux_sel == add_next ) ? add_out\n    :                               64'bx;\n\n  assign result_mux_out\n    = ( result_mux_sel == op_load ) ? 64'b0\n    : ( result_mux_sel == op_next ) ? add_mux_out\n    :                                 64'bx;\n\n  assign signed_result_mux_out\n    = ( sign_mux_sel == sign_u ) ? result_reg\n    : ( sign_mux_sel == sign_s ) ? ~result_reg + 1'b1\n    :                              64'bx;\n\n  assign mulresp_msg_result = signed_result_mux_out;\n\nendmodule\n\nmodule imuldiv_IntMulVariableCtrl\n(\n  input        clk,\n  input        reset,\n\n  input        mulreq_val,\n  output       mulreq_rdy,\n\n  output       mulresp_val,\n  input        mulresp_rdy,\n\n  input        sign,\n  input [31:0] b_data,\n\n  output       sign_en,\n  output       result_en,\n  output       a_mux_sel,\n  output       b_mux_sel,\n  output [4:0] op_shamt,\n  output       result_mux_sel,\n  output       add_mux_sel,\n  output       sign_mux_sel\n);\n\n  localparam STATE_IDLE = 2'd0;\n  localparam STATE_CALC = 2'd1;\n  localparam STATE_SIGN = 2'd2;\n\n  reg [1:0] state_reg;\n  reg [1:0] state_next;\n\n  always @ ( posedge clk ) begin\n    if ( reset ) begin\n      state_reg <= STATE_IDLE;\n    end\n    else begin\n      state_reg <= state_next;\n    end\n  end\n\n  wire mulreq_go;\n  wire mulresp_go;\n  wire is_calc_done;\n\n  always @ ( * ) begin\n\n    state_next = state_reg;\n\n    case ( state_reg )\n\n      STATE_IDLE:\n        if ( mulreq_go ) begin\n          state_next = STATE_CALC;\n        end\n\n      STATE_CALC:\n        if ( is_calc_done ) begin\n          state_next = STATE_SIGN;\n        end\n\n      STATE_SIGN:\n        if ( mulresp_go ) begin\n          state_next = STATE_IDLE;\n        end\n\n    endcase\n\n  end\n\n  localparam n = 1'd0;\n  localparam y = 1'd1;\n\n  localparam op_x    = 1'dx;\n  localparam op_load = 1'd0;\n  localparam op_next = 1'd1;\n\n  localparam cs_size = 7;\n  reg [cs_size-1:0] cs;\n\n  always @ ( * ) begin\n\n    cs = 7'b0;\n\n    case ( state_reg )\n\n      STATE_IDLE: cs = { y,     n,      y,   y,     op_load, op_load, op_load };\n      STATE_CALC: cs = { n,     n,      n,   y,     op_next, op_next, op_next };\n      STATE_SIGN: cs = { n,     y,      n,   n,     op_x,    op_x,    op_x    };\n\n    endcase\n\n  end\n\n  wire b_lsb = b_data[0];\n\n  assign mulreq_rdy     = cs[6];\n  assign mulresp_val    = cs[5];\n  assign sign_en        = cs[4];\n  assign result_en      = cs[3];\n  assign a_mux_sel      = cs[2];\n  assign b_mux_sel      = cs[1];\n  assign result_mux_sel = cs[0];\n  assign add_mux_sel    = b_lsb;\n  assign sign_mux_sel   = sign;\n\n  wire [31:0] in_bits = b_data >> 1;\n  wire        out_val;\n  wire [4:0]  out_bits;\n\n  vc_32_5_ReversePriorityEncoder encoder\n  (\n    .in_bits  (in_bits),\n    .out_val  (out_val),\n    .out_bits (out_bits)\n  );\n\n  assign op_shamt = out_bits + 5'b1;\n\n  assign mulreq_go     = mulreq_val && mulreq_rdy;\n  assign mulresp_go    = mulresp_val && mulresp_rdy;\n\n  assign is_calc_done  = ( ( b_data >> 1 ) == 32'b0 );\n\nendmodule\n\nmodule vc_32_5_ReversePriorityEncoder\n(\n  input  [31:0] in_bits,\n  output        out_val,\n  output  [4:0] out_bits\n);\n\n  assign out_val = ( in_bits != 32'b0 );\n\n  assign out_bits =\n    ( in_bits[ 0] ) ? 5'b00000\n  : ( in_bits[ 1] ) ? 5'b00001\n  : ( in_bits[ 2] ) ? 5'b00010\n  : ( in_bits[ 3] ) ? 5'b00011\n  : ( in_bits[ 4] ) ? 5'b00100\n  : ( in_bits[ 5] ) ? 5'b00101\n  : ( in_bits[ 6] ) ? 5'b00110\n  : ( in_bits[ 7] ) ? 5'b00111\n  : ( in_bits[ 8] ) ? 5'b01000\n  : ( in_bits[ 9] ) ? 5'b01001\n  : ( in_bits[10] ) ? 5'b01010\n  : ( in_bits[11] ) ? 5'b01011\n  : ( in_bits[12] ) ? 5'b01100\n  : ( in_bits[13] ) ? 5'b01101\n  : ( in_bits[14] ) ? 5'b01110\n  : ( in_bits[15] ) ? 5'b01111\n  : ( in_bits[16] ) ? 5'b10000\n  : ( in_bits[17] ) ? 5'b10001\n  : ( in_bits[18] ) ? 5'b10010\n  : ( in_bits[19] ) ? 5'b10011\n  : ( in_bits[20] ) ? 5'b10100\n  : ( in_bits[21] ) ? 5'b10101\n  : ( in_bits[22] ) ? 5'b10110\n  : ( in_bits[23] ) ? 5'b10111\n  : ( in_bits[24] ) ? 5'b11000\n  : ( in_bits[25] ) ? 5'b11001\n  : ( in_bits[26] ) ? 5'b11010\n  : ( in_bits[27] ) ? 5'b11011\n  : ( in_bits[28] ) ? 5'b11100\n  : ( in_bits[29] ) ? 5'b11101\n  : ( in_bits[30] ) ? 5'b11110\n  : ( in_bits[31] ) ? 5'b11111\n  :                   5'b00000;\n\nendmodule\n\n\n`endif\n",
        "module_name": "imuldiv_IntMulVariable",
        "module_hash": "5b4eb99e807b97909c97c3a2c8e5902a",
        "dataset_index": 20831
      },
      "ram_block_dual_read_single_write_85e733ba": {
        "rtl_code": "module ram_block_dual_read_single_write (\n    input [8:0] d0,\n    input [8:0] addr0,\n    input ce0,\n    input we0,\n    output reg [8:0] q0,\n    input [8:0] addr1,\n    input ce1,\n    output reg [8:0] q1,\n    input clk\n);\n\n    parameter DWIDTH = 8;\n    parameter AWIDTH = 9;\n    parameter MEM_SIZE = 512;\n\n    reg [DWIDTH-1:0] ram [MEM_SIZE-1:0];\n\n    always @(posedge clk) begin\n        if (ce0) begin\n            if (we0) begin\n                ram[addr0] <= d0;\n            end\n            q0 <= ram[addr0];\n        end\n        if (ce1) begin\n            q1 <= ram[addr1];\n        end\n    end\n\nendmodule",
        "module_name": "ram_block_dual_read_single_write",
        "module_hash": "85e733ba9e7622acf5eaceb6ed6e381d",
        "dataset_index": 20513
      },
      "binary_to_gray_4f5adf48": {
        "rtl_code": "\nmodule binary_to_gray (\n    input [3:0] binary,\n    output [3:0] gray\n);\n\n    // Intermediate signals\n    wire [3:0] xor_out;\n    wire [3:0] and_out;\n    wire [3:0] not_out;\n\n    // XOR gates\n    xor (xor_out[1], binary[0], binary[1]);\n    xor (xor_out[3], binary[2], binary[3]);\n    xor (xor_out[2], xor_out[1], xor_out[3]);\n    xor (xor_out[0], binary[1], binary[2]);\n\n    // AND gates\n    and (and_out[1], binary[0], binary[1]);\n    and (and_out[3], binary[2], binary[3]);\n    and (and_out[2], xor_out[1], xor_out[3]);\n    and (and_out[0], binary[1], binary[2]);\n\n    // NOT gates\n    not (not_out[0], binary[0]);\n    not (not_out[1], binary[1]);\n    not (not_out[2], binary[2]);\n    not (not_out[3], binary[3]);\n\n    // Gray code output\n    assign gray[0] = binary[0];\n    assign gray[1] = xor_out[1];\n    assign gray[2] = xor_out[2];\n    assign gray[3] = xor_out[3];\n\nendmodule\n",
        "module_name": "binary_to_gray",
        "module_hash": "4f5adf48ebcb7d9f7b232f46dae6bd8d",
        "dataset_index": 19261
      },
      "and_gate_ecbc50dd": {
        "rtl_code": "module and_gate(\n    input a,\n    input b,\n    output out\n);\n\nwire nand_out;\nwire inv_out;\n\nnand_gate nand1(a, b, nand_out);\ninverter inv1(nand_out, inv_out);\nassign out = inv_out;\n\nendmodule\n\nmodule nand_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a & b);\n\nendmodule\n\nmodule inverter(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "ecbc50dd4ac92192637430eee5f9ee41",
        "dataset_index": 14212
      },
      "custom_or3_8ffe196d": {
        "rtl_code": "module custom_or3 (\n    input A,\n    input B,\n    input C_N,\n    output X\n);\n\n    wire w1, w2, w3, w4, w5, w6, w7, w8;\n\n    or or1 (\n        X,\n        A,\n        B,\n        C_N\n    );\n\n    or or2 (\n        w2,\n        A,\n        w1,\n        C_N\n    );\n\n    or or3 (\n        w3,\n        w1,\n        B,\n        C_N\n    );\n\n    or or4 (\n        w4,\n        w1,\n        w1,\n        C_N\n    );\n\n    or or5 (\n        w5,\n        A,\n        B,\n        w1\n    );\n\n    or or6 (\n        w6,\n        A,\n        w1,\n        w1\n    );\n\n    or or7 (\n        w7,\n        w1,\n        B,\n        w1\n    );\n\n    or or8 (\n        w8,\n        w1,\n        w1,\n        w1\n    );\n\n    assign X = w8;\n\nendmodule",
        "module_name": "custom_or3",
        "module_hash": "8ffe196d0c7fb4fd9d5cc166391e62ba",
        "dataset_index": 5797
      },
      "sky130_fd_sc_hd__lpflow_inputiso1p_7bd45169": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__lpflow_inputiso1p (\n    X    ,\n    A    ,\n    SLEEP\n);\n\n    output X    ;\n    input  A    ;\n    input  SLEEP;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__lpflow_inputiso1p",
        "module_hash": "7bd451699c35547bcd923433140cfc44",
        "dataset_index": 15165
      },
      "jt12_lfo_03868c1a": {
        "rtl_code": "\n\n\n\n\nmodule jt12_lfo(\n\tinput\t\t\t \trst,\n\tinput\t\t\t \tclk,\n\tinput\t\t\t\tclk_en,\n\tinput\t\t\t\tzero,\n\tinput\t\t\t\tlfo_rst,\n\tinput\t\t\t\tlfo_en,\n\tinput\t\t[2:0]\tlfo_freq,\n\toutput\treg\t[6:0]\tlfo_mod\t\t);\n\nreg [6:0] cnt, limit;\n\nalways @(*)\n\tcase( lfo_freq )\t3'd0: limit = 7'd108;\n\t\t3'd1: limit = 7'd77;\n\t\t3'd2: limit = 7'd71;\n\t\t3'd3: limit = 7'd67;\n\t\t3'd4: limit = 7'd62;\n\t\t3'd5: limit = 7'd44;\n\t\t3'd6: limit = 7'd8;\n\t\t3'd7: limit = 7'd5;\n\tendcase\n\nalways @(posedge clk) \n\tif( rst || !lfo_en )\n\t\t{ lfo_mod, cnt } <= 14'd0;\n\telse if( clk_en && zero) begin\n\t\tif( cnt == limit ) begin\n\t\t\tcnt <= 7'd0;\n\t\t\tlfo_mod <= lfo_mod + 1'b1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 1'b1;\n\t\tend\n\tend\n\t\nendmodule\n",
        "module_name": "jt12_lfo",
        "module_hash": "03868c1a64c901d804810f9d209bfa02",
        "dataset_index": 10177
      },
      "any_edge_detection_pipeline_466d138d": {
        "rtl_code": "module any_edge_detection_pipeline (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nreg [7:0] reg1, reg2, reg3;\n\nalways @(posedge clk) begin\n    reg1 <= in;\nend\n\nalways @(posedge clk) begin\n    reg2 <= reg1;\nend\n\nalways @(posedge clk) begin\n    reg3 <= reg2;\nend\n\nassign anyedge = (reg1 ^ reg2) & ~reg1 & reg3;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nany_edge_detection_pipeline pipeline1(\n    .clk(clk),\n    .in(in),\n    .anyedge(anyedge)\n);\n\nendmodule",
        "module_name": "any_edge_detection_pipeline",
        "module_hash": "466d138dd145189dc08dd1601784e295",
        "dataset_index": 12379
      },
      "mux_2to1_21ffa921": {
        "rtl_code": "module mux_2to1 (\n    input A,\n    input B,\n    input S,\n    output Y\n);\n\n    assign Y = (S == 0) ? A : B;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "21ffa921d5c02c47afdcf8898edf6b58",
        "dataset_index": 3965
      },
      "barrel_shifter_cb51c7ee": {
        "rtl_code": "module barrel_shifter (\n    input [15:0] data,\n    input [3:0] shift_amount,\n    input direction,\n    output reg [15:0] q\n);\n\n    always @(*) begin\n        if (direction == 1) begin // left shift\n            case(shift_amount)\n                4'b0000: q = data;\n                4'b0001: q = {data[14:0], data[15]};\n                4'b0010: q = {data[13:0], data[15:14]};\n                4'b0011: q = {data[12:0], data[15:13]};\n                4'b0100: q = {data[11:0], data[15:12]};\n                4'b0101: q = {data[10:0], data[15:11]};\n                4'b0110: q = {data[9:0], data[15:10]};\n                4'b0111: q = {data[8:0], data[15:9]};\n                4'b1000: q = {data[7:0], data[15:8]};\n                4'b1001: q = {data[6:0], data[15:7]};\n                4'b1010: q = {data[5:0], data[15:6]};\n                4'b1011: q = {data[4:0], data[15:5]};\n                4'b1100: q = {data[3:0], data[15:4]};\n                4'b1101: q = {data[2:0], data[15:3]};\n                4'b1110: q = {data[1:0], data[15:2]};\n                4'b1111: q = {data[0], data[15:1]};\n            endcase\n        end else begin // right shift\n            case(shift_amount)\n                4'b0000: q = data;\n                4'b0001: q = {data[0], data[15:1]};\n                4'b0010: q = {data[1:0], data[15:2]};\n                4'b0011: q = {data[2:0], data[15:3]};\n                4'b0100: q = {data[3:0], data[15:4]};\n                4'b0101: q = {data[4:0], data[15:5]};\n                4'b0110: q = {data[5:0], data[15:6]};\n                4'b0111: q = {data[6:0], data[15:7]};\n                4'b1000: q = {data[7:0], data[15:8]};\n                4'b1001: q = {data[8:0], data[15:9]};\n                4'b1010: q = {data[9:0], data[15:10]};\n                4'b1011: q = {data[10:0], data[15:11]};\n                4'b1100: q = {data[11:0], data[15:12]};\n                4'b1101: q = {data[12:0], data[15:13]};\n                4'b1110: q = {data[13:0], data[15:14]};\n                4'b1111: q = {data[14:0], data[15]};\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "cb51c7ee184d349c2d2c1d9129e1c356",
        "dataset_index": 8955
      },
      "address_filter_049dcaef": {
        "rtl_code": "module address_filter\n  (input clk,\n   input reset,\n   input go,\n   input [7:0] data,\n   output match,\n   output done);\n\n   reg [2:0] af_state;\n\n   always @(posedge clk)\n     if(reset)\n       af_state <= 0;\n     else if(go)\n       if(data[0] == 1'b0)\n         af_state <= 1'b0;\n       else\n         af_state <= 3'b001;\n     else\n       case(af_state)\n         3'b001: af_state <= 3'b010;\n         3'b010: af_state <= 3'b011;\n         3'b011: af_state <= 3'b100;\n         3'b100: af_state <= 3'b101;\n         3'b101: af_state <= 3'b110;\n         3'b110: af_state <= 3'b000;\n         default: af_state <= 3'b000;\n       endcase\n\n   assign match = (af_state == 3'b110);\n   assign done = (af_state == 3'b110) || (af_state == 3'b000);\n   \nendmodule",
        "module_name": "address_filter",
        "module_hash": "049dcaefedc163757642def89f671e8d",
        "dataset_index": 16020
      },
      "non_posted_pkt_slicer_02f2c51d": {
        "rtl_code": "\n\nmodule non_posted_pkt_slicer(\n    input         clk,\n    input         rst,\n    input         transferstart,\t \n    input         rd_dma_start,\n    input [31:0]  dmarad,\n    input [31:0]  dmarxs,\n    input [63:0]  dmaras,\n    input [2:0]   read_req_size,input         rd_TX_des_start_one,\n\t input [63:0]  TX_des_addr,\n\t output reg    isDes,\n    input         ack,\n    output reg    go,\n    output reg [31:0] dmarad_reg,\n    output reg [63:0] dmaras_reg,\n    output [9:0]  length\n);\n    \n    localparam IDLE = 4'h0; \n    localparam IDLE_WAIT = 4'h1;\n    localparam START = 4'h2; \n    localparam NORMAL = 4'h3; \n    localparam CROSS = 4'h4; \n    localparam LAST = 4'h5;\n    localparam WAIT_FOR_ACK = 4'h6;\n    localparam REGISTER_DMA_REG = 4'h7;\n\t localparam START_TX_DES_REQ = 4'h8;\n\n        reg [31:0]  dmarad_new,dmarad_reg2;\n        reg [31:0]  dmarxs_new,dmarxs_reg,\n                                                        dmarxs_reg2;\n        reg [63:0]  dmaras_new,dmaras_reg2;\n    wire [31:0] dmarad_add, dmarad_term;\n    wire [31:0] dmarxs_sub, dmarxs_term;\n    wire [63:0] dmaras_add, dmaras_term;\n    reg [3:0]   state;\n    reg         update_dma_reg;\n    reg         stay_2x; reg [12:0]   length_byte;\n    wire [63:0] dmaras_temp;\n    wire        four_kb_cross;     reg [12:0] four_kb_xfer, \n                                                       four_kb_xfer2;\n    wire        less_than_rrs;wire [12:0] read_req_size_bytes;\n    reg         last_flag;\n    reg   rst_reg;\n\n    always@(posedge clk) rst_reg <= rst;\n \n\nassign read_req_size_bytes =13'h0001<<(read_req_size+7);\n\nassign dmaras_temp = dmaras_reg + read_req_size_bytes;\nassign four_kb_cross = (dmaras_temp[12] == dmaras_reg2[12]) ? 1'b0 : 1'b1;\n\nassign less_than_rrs = (dmarxs_reg <= read_req_size_bytes) ? 1'b1 : 1'b0; \n\nalways@(posedge clk)begin\n    four_kb_xfer[12:0] = 13'h1000 - dmaras_reg[11:0]; \n    four_kb_xfer2[12:0] = 13'h1000 - dmaras_reg2[11:0]; \nend\n\nalways @ (posedge clk) begin\n  if (rst_reg | (~transferstart)) begin\n      state <= IDLE;\n      update_dma_reg <= 0;\n      stay_2x <= 1'b0;\n      go <= 0;\n      last_flag <= 1'b0;\n  end else begin\n      case (state)\n        IDLE : begin\n           update_dma_reg <= 0;\n           stay_2x <= 1'b0;\n           go <= 0;\n           last_flag <= 1'b0;\n           if(rd_dma_start) \n             state <= IDLE_WAIT;\n           else if(rd_TX_des_start_one)    state <= START_TX_DES_REQ;    else                            \n             state <= IDLE;\n           end\n         IDLE_WAIT: begin state <= START;\n         end\n\t\t\t\n\t\t\tSTART_TX_DES_REQ: begin\n\t\t\t  go <= 1;  if(stay_2x == 1'b0)begin\n              state <= START_TX_DES_REQ;\n              stay_2x <= 1'b1;\n           end else begin\n\t\t\t     last_flag <= 1;\n              stay_2x <= 1'b0; \n              state <= WAIT_FOR_ACK;\n           end\n\t\t\tend\n\t\t\t\n         START : begin        update_dma_reg <= 0;\n           stay_2x <= 1'b0;\n           go <= 0;\n           case ({four_kb_cross, less_than_rrs})\n               2'b00:\n                  state <= NORMAL;\n               2'b01:\n                  state <= LAST;\n               2'b10:\n                  state <= CROSS;\n               2'b11:if(dmarxs_reg > four_kb_xfer)\n                  state <= CROSS;\n                 else\n                  state <= LAST;\n            endcase      \n         end\n   \n         NORMAL : begin go <= 1;  if(stay_2x == 1'b0)begin\n              state <= NORMAL;\n              stay_2x <= 1'b1;\n           end else begin\n              stay_2x <= 1'b0; \n              state <= WAIT_FOR_ACK;\n           end\n          end\n         CROSS : begin go <= 1;           \n           if(stay_2x == 1'b0)begin\n              state <= CROSS;\n              stay_2x <= 1'b1;\n           end else begin\n              stay_2x <= 1'b0; \n              state <= WAIT_FOR_ACK;\n           end\n         end\n         LAST : begin go <= 1;          \n           last_flag <= 1'b1;           \n           if(stay_2x == 1'b0)begin\n              state <= LAST;\n              stay_2x <= 1'b1;\n           end else begin\n              stay_2x <= 1'b0; \n              state <= WAIT_FOR_ACK;\n           end\n          end\n\n         WAIT_FOR_ACK : begin\n           if(ack)begin\n             update_dma_reg <= 1'b1;\n             go <= 1'b0;\n             if(last_flag)begin\n               state <= IDLE;\n             end else begin\n               state <= REGISTER_DMA_REG;\n             end\n           end else begin \n             update_dma_reg <= 1'b0;\n             go <= 1'b1;\n             state <= WAIT_FOR_ACK;\n           end\n         end\n\n         REGISTER_DMA_REG: begin\n           update_dma_reg <= 1'b0;\n           state <= IDLE_WAIT;\n         end\n\n         default : begin\n           update_dma_reg <= 0;\n           go <= 0;\n           state <= IDLE;\n         end\n      endcase   \n     end\n    end\n\nassign dmarad_term = (state == NORMAL) ? read_req_size_bytes : \n                     (state == CROSS)  ? four_kb_xfer : \n                     (state == LAST)   ? dmarxs_reg : \n                                         read_req_size_bytes;\n                                                                                assign dmarad_add = dmarad_reg2 + dmarad_term;\n\nassign dmaras_term = (state == NORMAL) ? read_req_size_bytes : \n                     (state == CROSS)  ? four_kb_xfer2 : \n                     (state == LAST)   ? dmarxs_reg : \n                                         read_req_size_bytes;\n                                                                                assign dmaras_add = dmaras_reg2 + dmaras_term;\n\nassign dmarxs_term = (state == NORMAL) ? read_req_size_bytes : \n                     (state == CROSS)  ? four_kb_xfer2 : \n                     (state == LAST)   ? dmarxs_reg : \n                                         read_req_size_bytes;\nassign dmarxs_sub = dmarxs_reg2 - dmarxs_term;\n\nalways@(posedge clk)begin\n   if(stay_2x)begin\n           dmarad_new <= dmarad_add;\n           dmaras_new <= dmaras_add;\n           dmarxs_new <= dmarxs_sub;\n   end\nend\n\nalways@(posedge clk)begin\n   if(rst_reg)begin\n      dmarad_reg <= 32'h0000_0000;\n      dmarxs_reg <= 32'h0000_0000;\n      dmaras_reg <= 64'h0000_0000_0000_0000;\n      dmarad_reg2 <= 32'h0000_0000;\n      dmarxs_reg2 <= 32'h0000_0000;\n      dmaras_reg2 <= 64'h0000_0000_0000_0000;      \n   end else if(rd_dma_start)begin\n      dmarad_reg <= dmarad;\n      dmarxs_reg <= dmarxs;\n      dmaras_reg <= dmaras;\n      dmarad_reg2 <= dmarad;\n      dmarxs_reg2 <= dmarxs;\n      dmaras_reg2 <= dmaras;      \n   end else if(update_dma_reg)begin\n      dmarad_reg <= dmarad_new; \n      dmarxs_reg <= dmarxs_new;\n      dmaras_reg <= dmaras_new;   \n      dmarad_reg2 <= dmarad_new; \n      dmarxs_reg2 <= dmarxs_new;\n      dmaras_reg2 <= dmaras_new;      \n   end else if(rd_TX_des_start_one)begin    dmaras_reg <= TX_des_addr;            end\nend   \n\nalways@(posedge clk)begin\n   if(rst_reg)\n      length_byte[12:0] <= 0;\n   else if(state == NORMAL)\n      length_byte[12:0] <= read_req_size_bytes[12:0];\n   else if (state == LAST)\n      length_byte[12:0] <= dmarxs_reg2[12:0];\n   else if (state == CROSS)\n      length_byte[12:0] <= four_kb_xfer2[12:0];\n   else if (state == START_TX_DES_REQ)      length_byte[12:0] <= 13'h0020;        else\n      length_byte <= length_byte;\nend\n\nassign length[9:0] = length_byte[11:2];  \n\nalways@ (posedge clk)begin\n   if(rst_reg)\n\t   isDes <= 0;\n\telse if ((state == NORMAL) | (state == LAST) | (state == CROSS))\n\t   isDes <= 0;\n\telse if (state == START_TX_DES_REQ)\n\t   isDes <= 1;\n\telse\n\t   isDes <= isDes;\nend \n\nendmodule\n",
        "module_name": "non_posted_pkt_slicer",
        "module_hash": "02f2c51d3533e572aa157da7c61a942a",
        "dataset_index": 25525
      },
      "mux_2to1_69d355d2": {
        "rtl_code": "module mux_2to1(\n    input A, B, S,\n    output reg Y\n);\n\n    always @ (A, B, S)\n    begin\n        if (S == 1'b1)\n            Y = A;\n        else\n            Y = B;\n    end\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "69d355d2e974d38686e4028dd106a7b0",
        "dataset_index": 6802
      },
      "up_down_counter_a1333df0": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input reset,\n    input up_down,\n    output reg [3:0] q\n);\n\n    parameter CNT_MAX = 4'b1111;\n    parameter CNT_MIN = 4'b0000;\n\n    reg [3:0] cnt_next;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= CNT_MIN;\n        end\n        else begin\n            if (up_down) begin\n                cnt_next <= q + 1;\n            end\n            else begin\n                cnt_next <= q - 1;\n            end\n\n            if (cnt_next > CNT_MAX) begin\n                q <= CNT_MIN;\n            end\n            else if (cnt_next < CNT_MIN) begin\n                q <= CNT_MAX;\n            end\n            else begin\n                q <= cnt_next;\n            end\n        end\n    end\n\nendmodule\n\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [3:0] q,\n    output reg transition\n);\n\n    reg [3:0] q_prev;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q_prev <= 4'b0000;\n            transition <= 1'b0;\n        end\n        else begin\n            if (q != q_prev) begin\n                transition <= 1'b1;\n            end\n            else begin\n                transition <= 1'b0;\n            end\n            q_prev <= q;\n        end\n    end\n\nendmodule\n\nmodule and_module (\n    input transition,\n    input [3:0] q,\n    output reg [3:0] out\n);\n\n    always @(transition or q) begin\n        if (transition) begin\n            out <= q;\n        end\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [3:0] q\n);\n\n    wire transition;\n    wire [3:0] cnt_out;\n\n    up_down_counter counter (\n        .clk(clk),\n        .reset(reset),\n        .up_down(in[0]),\n        .q(cnt_out)\n    );\n\n    transition_detector detector (\n        .clk(clk),\n        .reset(reset),\n        .q(cnt_out),\n        .transition(transition)\n    );\n\n    and_module and_gate (\n        .transition(transition),\n        .q(cnt_out),\n        .out(q)\n    );\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "a1333df0ec73f4b9d5c193156c3aea58",
        "dataset_index": 12854
      },
      "tg_prbs_gen #_ee153452": {
        "rtl_code": "\n\nmodule tg_prbs_gen #\n  (\n    parameter PRBS_WIDTH = 64,          parameter START_ADDR  = 32'h00000000,\n    parameter DMODE = \"READ\",\n    parameter PRBS_OFFSET = 0, \n    parameter [PRBS_WIDTH-1:0] TAPS= 32'h80200003 )\n  (\n   input           clk_i,\n   input           clk_en,\n   input           rst,\ninput [PRBS_WIDTH-1:0]    prbs_seed_i,\n   output                    initialize_done,\n   output  [PRBS_WIDTH-1:0]  prbs_o,     output reg [3:0] prbs_shift_value,\n   output [31:0] ReSeedcounter_o\n  );\n  \n  \nwire  prbs_seed_ld;\nreg [PRBS_WIDTH - 1:0] Next_LFSR_Reg;\nreg [PRBS_WIDTH - 1:0] LFSR_Reg;\nreg [PRBS_WIDTH-1:0] counterA;\nreg Bits0_9_zero, Feedback;\ninteger i;\nreg [PRBS_WIDTH - 1:0] ReSeedcounter;\nreg [10:0] freerun_counters;\nreg init_setup;\nwire prbs_clk_en1;\nwire prbs_clk_en2;\nalways @ (posedge clk_i)\nbegin\n   if (rst)\n     freerun_counters <= 'b0;\n   else if (freerun_counters <= 128 || init_setup)\n     freerun_counters <= freerun_counters + 1'b1;\nend\n\n\nalways @ (posedge clk_i)\nbegin\n   if (rst)\n     counterA <= 'b0;\nelse if (prbs_clk_en1)\n\n     counterA <= counterA + 1'b1;\nend\n\n\n\n\nassign initialize_done = ~init_setup;\nalways @ (posedge clk_i)\nbegin\n   if (rst)\n     init_setup <= 'b0;\n   else if ( freerun_counters <= PRBS_OFFSET + 255 )\n     init_setup <= 1'b1;\n   else\n     init_setup <= 1'b0;\n    \nend\n\n\n\nassign ReSeedcounter_o = {{(32-PRBS_WIDTH){1'b0}},ReSeedcounter};\nalways @ (posedge clk_i)\nbegin\n   if (rst)\n     ReSeedcounter <= 'b0;\n   else if (prbs_clk_en1)\n     if (ReSeedcounter == {PRBS_WIDTH {1'b1}})\n         ReSeedcounter <= 'b0;\n     else\n         ReSeedcounter <= ReSeedcounter + 1'b1;\nend\n\n\nassign prbs_clk_en1 = clk_en | init_setup ;\nassign prbs_clk_en2 = clk_en | init_setup ;\n\nalways @ (posedge clk_i)\nbegin\n   if (rst  ) begin\n        LFSR_Reg[3:0] <=  prbs_seed_i[3:0] | 4'h5;\n        LFSR_Reg[PRBS_WIDTH-1:4] <= prbs_seed_i[PRBS_WIDTH-1:4];\n    end\n   else if (prbs_clk_en2) begin\n     LFSR_Reg <= Next_LFSR_Reg;\n        prbs_shift_value <= {prbs_shift_value[2:0],LFSR_Reg[PRBS_WIDTH-1]};\n        end\nend\n\n   \n\nalways @ (LFSR_Reg)\nbegin :LFSR_Feedback\n   Bits0_9_zero = ~| LFSR_Reg[PRBS_WIDTH-2:0];\n   Feedback = LFSR_Reg[PRBS_WIDTH-1]^Bits0_9_zero; \nfor (i = PRBS_WIDTH - 1; i >= 1 ; i = i-1)\n\n      if (TAPS[i - 1] == 1)\n         Next_LFSR_Reg[i]= LFSR_Reg[i-1] ^ Feedback  ;\n      else\n         Next_LFSR_Reg[i] = LFSR_Reg[i-1];\n         \n   Next_LFSR_Reg[0] = Feedback  ;end\nassign prbs_o = LFSR_Reg;\n\n\n\nendmodule\n   \n         \n",
        "module_name": "tg_prbs_gen #",
        "module_hash": "ee153452fa3b652ddfd3d23551d37e67",
        "dataset_index": 9996
      },
      "sky130_fd_sc_lp__a21oi_7f5adb54": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a21oi",
        "module_hash": "7f5adb5485fbc959781326b50285c9af",
        "dataset_index": 9338
      },
      "led_blink #_a3190202": {
        "rtl_code": "\n\n`ifndef LED_BLINK_MOD_V_\n`define LED_BLINK_MOD_V_\n\n\nmodule led_blink #(\n\tparameter BLINK_ON_CLKS\t\t= 1024,\n\tparameter BLINK_OFF_CLKS\t= 1024,\n) (\n\tinput clk,\n\tinput n_reset,\n\tinput enable,\n\toutput reg led,\n);\n\treg [31:0] led_on_count;\n\treg [31:0] led_off_count;\n\n\tinitial begin\n\t\tled <= 0;\n\t\tled_on_count <= 0;\n\t\tled_off_count <= 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (n_reset) begin\n\t\t\tif (led) begin\n\t\t\t\tif (led_on_count == 0) begin\n\t\t\t\t\tled <= 0;\n\t\t\t\t\tled_off_count <= BLINK_OFF_CLKS;\n\t\t\t\tend else begin\n\t\t\t\t\tled_on_count <= led_on_count - 1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tif (led_off_count == 0) begin\n\t\t\t\t\tif (enable) begin\n\t\t\t\t\t\tled <= 1;\n\t\t\t\t\t\tled_on_count <= BLINK_ON_CLKS;\n\t\t\t\t\tend\n\t\t\t\tend else begin\n\t\t\t\t\tled_off_count <= led_off_count - 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend else begin\n\t\t\tled <= 0;\n\t\t\tled_on_count <= 0;\n\t\t\tled_off_count <= 0;\n\t\tend\n\tend\nendmodule\n\n`endif \n",
        "module_name": "led_blink #",
        "module_hash": "a3190202f570f6912f4dd1986e22569b",
        "dataset_index": 22543
      },
      "pipelined_ripple_carry_adder_4bit_aa2a2949": {
        "rtl_code": "module pipelined_ripple_carry_adder_4bit (\n    input clk,                // Correct position for the clock input\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] Sum,\n    output reg Cout\n);\n\nreg [3:0] A_reg, B_reg;\nreg Cin_reg, Cout_reg1, Cout_reg2, Cout_reg3; // Use separate registers for each carry-out\n\n// Pipeline stage 1\nalways @(posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    Cin_reg <= Cin;\nend\n\n// Pipeline stage 2\nalways @(posedge clk) begin\n    // Full adder for bit 0\n    {Cout_reg1, Sum[0]} = A_reg[0] + B_reg[0] + Cin_reg;\n    \n    // Full adder for bit 1\n    {Cout_reg2, Sum[1]} = A_reg[1] + B_reg[1] + Cout_reg1;\n    \n    // Full adder for bit 2\n    {Cout_reg3, Sum[2]} = A_reg[2] + B_reg[2] + Cout_reg2;\n    \n    // Full adder for bit 3\n    {Cout, Sum[3]} = A_reg[3] + B_reg[3] + Cout_reg3;\nend\n\n\nendmodule\n",
        "module_name": "pipelined_ripple_carry_adder_4bit",
        "module_hash": "aa2a2949c1a895bd567b2bd45728b782",
        "dataset_index": 1467
      },
      "shift_register_2ef155fa": {
        "rtl_code": "module shift_register (\n  input clk, load, shift,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n  if (load) begin\n    shift_reg <= data_in;\n  end else if (shift) begin\n    shift_reg <= {shift_reg[2:0], 1'b0};\n  end\nend\n\nassign data_out = shift_reg;\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "2ef155faf83b0fa1a40f0bfc8f79a911",
        "dataset_index": 1988
      },
      "control_576eb62c": {
        "rtl_code": "\n\nmodule control( input [5:0]      opcode,\n\t\t\t input [5:0]      special,\n                input            branch_eq,       output reg [1:0] if_pc_source,\n                output           id_rt_is_source, output           ex_imm_command,\n                output reg       ex_alu_src_b,\n\t\t\t output reg       ex_alu_rslt_src, output reg [1:0] ex_dst_reg_sel,\n                output reg [1:0] ex_alu_op,\n                output reg       mem_read,\n                output reg       mem_write,\n                output reg       wb_mem_to_reg,\n                output reg       wb_reg_write );\n\n     localparam     LW    = 6'b100011, \n                    SW    = 6'b101011, \n                    BEQ   = 6'b000100, \n                    RTYPE = 6'b000000, \n                    J     = 6'b000010,\n                    JAL   = 6'b000011,\t\t\t\t\t\t\n                    ADDI  = 6'b001000, \t\n                    ANDI  = 6'b001100, \n                    ORI   = 6'b001101, \n                    XORI  = 6'b001110, \n                    SLTI  = 6'b001010,\n\t\t\t\t\n\tJR    = 6'b001000;\t\n     reg memory_op;\n     reg r_type_op;\n     reg immediate_op;\n     reg branch_op;\n     reg jump_op;\n   \n     assign ex_imm_command = immediate_op;\n     assign id_rt_is_source = (r_type_op | branch_op | opcode == SW);\n                         \n     always @* begin\n     if_pc_source    = 0;\n          ex_alu_src_b  \t = 0;\n\t\tex_alu_rslt_src = 0;\n          ex_dst_reg_sel  = 0;\n          ex_alu_op       = 0;\n          mem_read        = 0;\n          mem_write       = 0;\n          wb_mem_to_reg   = 0;\n          wb_reg_write    = 0;\n\n          memory_op    = ( (opcode == LW) | (opcode == SW) );\n          r_type_op    = ( opcode == RTYPE );\n          branch_op    = ( opcode == BEQ );\n          immediate_op = ( (opcode == ADDI) | (opcode == ANDI) | (opcode == ORI) | (opcode == XORI) | (opcode == SLTI) );\n          jump_op      = ( (opcode == J) | (opcode == JAL));\n        \n          if (memory_op) begin\n               ex_alu_src_b   = 1'b1;  ex_dst_reg_sel = 2'b00; ex_alu_op      = 2'b00; wb_mem_to_reg  = 1'b1;  if ( opcode == LW ) begin\n                    mem_read = 1'b1;\n                    wb_reg_write = 1'b1;              \n               end\n               else \n                    mem_write = 1'b1;       end\n          else if (r_type_op) begin\n               ex_alu_src_b = 1'b0;    ex_dst_reg_sel = 2'b01; ex_alu_op = 2'b10;      wb_mem_to_reg = 1'b0;   wb_reg_write  = 1'b1;   end\n          else if (immediate_op) begin\n               ex_alu_src_b = 1'b1;    ex_dst_reg_sel = 2'b00; ex_alu_op = 2'b10;      wb_mem_to_reg = 1'b0;   wb_reg_write = 1'b1;           \n          end\n          else if (branch_op) begin\n               if (branch_eq) \n                    if_pc_source = 2'b01; else \n                    if_pc_source = 2'b00;\n           \n          end\n          else if (jump_op)\n               if_pc_source = 2'b10;  if( opcode == JAL ) begin\n\t\t\t\tex_dst_reg_sel = 2'b10;\n\t\t\t\tex_alu_rslt_src = 1'b1;\twb_reg_write  = 1'b1;\n\t\t\tend\n          else if (~|opcode) begin\n\t\t\tif(special == JR) begin\n\t\t\t\tif_pc_source = 2'b11;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tend\n          end\n\t\telse begin\n\t\t\tend\n     end\n   \nendmodule\n",
        "module_name": "control",
        "module_hash": "576eb62c281ed40101f23cbc072ecf61",
        "dataset_index": 22405
      },
      "counter_4bit_36abff31": {
        "rtl_code": "module counter_4bit (\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            count <= 4'b0;\n        end else if (en) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "36abff3125751bb637e62a88c0a4b3d8",
        "dataset_index": 17881
      },
      "mux4to1_73a76c44": {
        "rtl_code": "module mux4to1 (\n  input [7:0] data0,\n  input [7:0] data1,\n  input [7:0] data2,\n  input [7:0] data3,\n  input sel0,\n  input sel1,\n  output reg [7:0] out\n);\n\n  always @(*) begin\n    case ({sel1, sel0})\n      2'b00: out = data0;\n      2'b01: out = data1;\n      2'b10: out = data2;\n      2'b11: out = data3;\n    endcase\n  end\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "73a76c44ab7cffab612960062fcfb6ae",
        "dataset_index": 13452
      },
      "mod_add16_d57252d2": {
        "rtl_code": "\nmodule mod_add16(\n    input  [3:0] a,\n    input  [3:0] b,\n    input  rst,\n    input  clk,\n    output  [3:0] out\n);\n\n    reg [3:0] out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 4'b0;\n        end else begin\n            out <= (a + b) % 16;\n            if (out >= 16) begin\n                out <= out - 16;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "mod_add16",
        "module_hash": "d57252d2d636d06e257491dd6f9fbc84",
        "dataset_index": 18895
      },
      "top__1498bc1f": {
        "rtl_code": "module top_module (\n    input A, B, C, D, // Inputs for priority encoder and multiplexer\n    output reg [1:0] X, // Output from priority encoder\n    output reg Y, // Output from priority encoder\n    output reg Z // Output from multiplexer and functional module\n);\n\n// Priority encoder\nalways @ (A or B or C or D) begin\n    if (A) begin\n        X = 0;\n        Y = 1;\n    end else if (B) begin\n        X = 1;\n        Y = 1;\n    end else if (C) begin\n        X = 2;\n        Y = 1;\n    end else if (D) begin\n        X = 3;\n        Y = 1;\n    end else begin\n        X = 0;\n        Y = 0;\n    end\nend\n\n// Multiplexer\nalways @ (A or B or C or D) begin\n    if (A) begin\n        Z = A;\n    end else if (B) begin\n        Z = B;\n    end else if (C) begin\n        Z = C;\n    end else if (D) begin\n        Z = D;\n    end else begin\n        Z = 0;\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "1498bc1fc840d7b4ef146ee7c79cf6a1",
        "dataset_index": 21178
      },
      "Counter_2f957574": {
        "rtl_code": "module Counter(\n  input   clock,\n  input   reset,\n  input   [31:0] max_val,\n  output  reg [31:0] count\n);\n  \n  always @(posedge clock or posedge reset) begin\n    if (reset) begin\n      count <= 0;\n    end\n    else begin\n      if (count == max_val) begin\n        count <= 0;\n      end\n      else begin\n        count <= count + 1;\n      end\n    end\n  end\n  \nendmodule",
        "module_name": "Counter",
        "module_hash": "2f95757438b835edc5a350a9a3f2cc2e",
        "dataset_index": 10319
      },
      "oh_clockmux #_f1800971": {
        "rtl_code": "module oh_clockmux #(parameter N    = 1)    (\n    input [N-1:0] en, input [N-1:0] clkin,output \t  clkout \n    );\n\n`ifdef CFG_ASIC\n    generate\n       if((N==2))\n\t begin : asic\n\t    asic_clockmux2 imux (.clkin(clkin[N-1:0]),\n\t\t\t\t .en(en[N-1:0]),\n\t\t\t\t .clkout(clkout));\n\t end\n       else if((N==4))\n\t begin : asic\n\t    asic_clockmux4 imux (.clkin(clkin[N-1:0]),\n\t\t\t\t .en(en[N-1:0]),\n\t\t\t\t .clkout(clkout));\n\t end\n    endgenerate\n`else assign clkout = |(clkin[N-1:0] & en[N-1:0]);\n`endif\n       \nendmodule ",
        "module_name": "oh_clockmux #",
        "module_hash": "f1800971731912bcc08c39b4e070c477",
        "dataset_index": 11129
      },
      "three_input_gate_504c739f": {
        "rtl_code": "module three_input_gate (\n    input clk,\n    input A1,\n    input A2,\n    input B1,\n    output reg Y\n);\n\n    always @(posedge clk) begin\n        if (A1 && A2) begin\n            Y <= 0;\n        end else if (!A1 && A2) begin\n            Y <= 1;\n        end else if (A1 && !A2) begin\n            Y <= B1;\n        end else begin\n            Y <= 1;\n        end\n    end\n\nendmodule",
        "module_name": "three_input_gate",
        "module_hash": "504c739f94b9df05fe8e7985737e2ce3",
        "dataset_index": 14062
      },
      "spi_core_a74ed195": {
        "rtl_code": "\n\nmodule spi_core (\n   o_sdo, o_drvb, o_spi_active, o_rx_valid, vo_byte_num, vo_data_rx,\n   i_rstb, i_cs, i_sck, i_sdi, i_epol, i_cpol, i_cpha, vi_data_tx\n   );\n   parameter BITS_IN_BYTE = 8;\n   parameter NBIT_BIT_CTR = 3;\n   parameter NBIT_BYTE_CTR = 3;\n   \n   input \t\t      i_rstb;\n   input \t\t      i_cs; input \t\t      i_sck; input \t\t      i_sdi; output \t\t      o_sdo; output \t\t      o_drvb; input \t\t      i_epol; input \t\t      i_cpol; input \t\t      i_cpha;\n   output \t\t      o_spi_active; output \t\t      o_rx_valid; output [NBIT_BYTE_CTR-1:0] vo_byte_num; input [BITS_IN_BYTE-1:0]   vi_data_tx; output [BITS_IN_BYTE-1:0]  vo_data_rx; reg \t\t\t      o_rx_valid;\n   reg [NBIT_BYTE_CTR-1:0]    vo_byte_num;\n\n   \n   wire \t\t      chip_select; \n   wire \t\t      sck_core; \n   assign chip_select = i_rstb && (i_epol ^ i_cs);\n   assign o_spi_active = chip_select;\n   assign sck_core = i_cpha ^ i_cpol ^ i_sck;\n   assign o_drvb = !chip_select;\n   \n   reg [BITS_IN_BYTE-1:0]     rv_tx;\n   reg [NBIT_BIT_CTR-1:0]     rv_tx_ptr;\n   always @( negedge sck_core or negedge chip_select ) begin : tx_fsm\n      if ( !chip_select ) begin\n\t rv_tx_ptr <= $unsigned(BITS_IN_BYTE - 1);\n\t vo_byte_num <= 0;\n\t rv_tx <= 0;\n      end else begin\n\t if ( 0 == rv_tx_ptr ) begin\n\t    rv_tx <= vi_data_tx;\n\t    rv_tx_ptr <= $unsigned(BITS_IN_BYTE - 1);\n\t    vo_byte_num <= vo_byte_num + 1;\n\t end else begin\n\t    rv_tx_ptr <= rv_tx_ptr - 1;\n\t end\n      end end assign o_sdo = rv_tx[rv_tx_ptr];\n   \n   reg [BITS_IN_BYTE-2:0]     rv_rx;\n   always @( posedge sck_core or negedge chip_select ) begin : rx_fsm\n      if ( !chip_select ) begin\n\t rv_rx <= 0;\n         o_rx_valid <= 0;\n      end else begin\n\t if ( 0 == rv_tx_ptr ) begin\n\t    o_rx_valid <= 1;   \n\t end else begin\n\t    o_rx_valid <= 0;\n            rv_rx[BITS_IN_BYTE-2:1] <= rv_rx[BITS_IN_BYTE-3:0];\n\t    rv_rx[0] <= i_sdi;\n\t end end end assign vo_data_rx = {rv_rx,i_sdi};\nendmodule\n",
        "module_name": "spi_core",
        "module_hash": "a74ed195b8b4e0e03e237d30d39870a7",
        "dataset_index": 11915
      },
      "sky130_fd_sc_lp__a21o_c70bcc60": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a21o (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A1, A2         );\n    or  or0  (or0_out_X, and0_out, B1   );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a21o",
        "module_hash": "c70bcc608d8621759ae317405fb1bc69",
        "dataset_index": 6776
      },
      "relojes_b19456a9": {
        "rtl_code": "\nmodule relojes (\n    input wire CLK_IN1,\n    // Clock out ports\n    output wire CLK_OUT1,\n    output wire CLK_OUT2,\n    output wire CLK_OUT3,\n    output wire CLK_OUT4\n);\n\n    // Internal registers and wires\n    reg [7:0] count1;\n    reg [7:0] count2;\n    reg [7:0] count3;\n    reg [7:0] count4;\n\n    // Clock division logic\n    always @(posedge CLK_IN1) begin\n        count1 <= count1 + 1;\n        if (count1 == 8'd24) begin\n            count1 <= 0;\n            count2 <= count2 + 1;\n        end\n        if (count2 == 8'd12) begin\n            count2 <= 0;\n            count3 <= count3 + 1;\n        end\n        if (count3 == 8'd6) begin\n            count3 <= 0;\n            count4 <= count4 + 1;\n        end\n    end\n\n    // Clock outputs\n    assign CLK_OUT1 = count1[0];\n    assign CLK_OUT2 = count2[0];\n    assign CLK_OUT3 = count3[0];\n    assign CLK_OUT4 = count4[0];\n\nendmodule\n",
        "module_name": "relojes",
        "module_hash": "b19456a926b563512027c8c0aa1c4bce",
        "dataset_index": 20931
      },
      "five_input_gate_57f5115f": {
        "rtl_code": "module five_input_gate (\n    X,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X;\n    input A1, A2, B1, B2, C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    assign X = (A1) ? 1 : ((A2) ? 0 : ((B1 & B2) ? 1 : (!C1)));\n\nendmodule",
        "module_name": "five_input_gate",
        "module_hash": "57f5115fa6bee20b7d7cf07963e7bf7d",
        "dataset_index": 4272
      },
      "dual_edge_triggered_ff_670b8e8b": {
        "rtl_code": "module dual_edge_triggered_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= q1;\nend\n\nassign q = q2;\n\nendmodule",
        "module_name": "dual_edge_triggered_ff",
        "module_hash": "670b8e8bbf882e2547d24561983e1535",
        "dataset_index": 19222
      },
      "sky130_fd_sc_hd__a311o_8a57ed4d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__a311o (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A3, A1, A2      );\n    or  or0  (or0_out_X, and0_out, C1, B1);\n    buf buf0 (X        , or0_out_X       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a311o",
        "module_hash": "8a57ed4d58b97dfa0c66427b0deb9ec5",
        "dataset_index": 21929
      },
      "my_logic_ffe0c70a": {
        "rtl_code": "module my_logic (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    assign X = (A1_N & A2_N) ? 1'b0 :\n               (A1_N & ~A2_N & B1 & ~B2) ? 1'b1 :\n               (A2_N & ~A1_N & ~B1 & B2) ? 1'b1 :\n               (A1_N & ~A2_N & (~B1 | B2)) ? 1'b0 :\n               1'b0;\n\nendmodule",
        "module_name": "my_logic",
        "module_hash": "ffe0c70a8da6aab0c9bccc09c86704d2",
        "dataset_index": 16700
      },
      "binary_search_7814351b": {
        "rtl_code": "\nmodule binary_search (\n    input wire clk,\n    input wire reset,\n    input wire start,\n    input wire [31:0] array,\n    input wire [7:0] array_len,\n    input wire [31:0] target,\n    output reg found,\n    output reg [7:0] index\n);\n\nreg [31:0] low, high, mid;\nreg [7:0] i;\nreg done;\n\nalways @(posedge clk or negedge reset) begin\n    if (!reset) begin\n        low <= 0;\n        high <= 0;\n        mid <= 0;\n        i <= 0;\n        done <= 0;\n    end else begin\n        if (start && !done) begin\n            low <= 0;\n            high <= array_len - 1;\n            done <= 0;\n            i <= 0;\n        end else if (i < array_len && !done) begin\n            mid <= (low + high) / 2;\n            if (array[mid] == target) begin\n                found <= 1;\n                index <= mid;\n                done <= 1;\n            end else if (array[mid] > target) begin\n                high <= mid - 1;\n            end else begin\n                low <= mid + 1;\n            end\n            i <= i + 1;\n        end else if (i >= array_len && !done) begin\n            found <= 0;\n            index <= -1;\n            done <= 1;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "binary_search",
        "module_hash": "7814351b47d31c9521bd85721d664c7e",
        "dataset_index": 4694
      },
      "mig_7series_v1_9_bank_compare #_c71a751e": {
        "rtl_code": "\n\nmodule mig_7series_v1_9_bank_compare #\n  (parameter BANK_WIDTH               = 3,\n   parameter TCQ = 100,\n   parameter BURST_MODE               = \"8\",\n   parameter COL_WIDTH                = 12,\n   parameter DATA_BUF_ADDR_WIDTH      = 8,\n   parameter ECC                      = \"OFF\",\n   parameter RANK_WIDTH               = 2,\n   parameter RANKS                    = 4,\n   parameter ROW_WIDTH                = 16)\n  (\n  req_data_buf_addr_r, req_periodic_rd_r, req_size_r, rd_wr_r,\n  req_rank_r, req_bank_r, req_row_r, req_wr_r, req_priority_r,\n  rb_hit_busy_r, rb_hit_busy_ns, row_hit_r, maint_hit, col_addr,\n  req_ras, req_cas, row_cmd_wr, row_addr, rank_busy_r,\n  clk, idle_ns, idle_r, data_buf_addr, periodic_rd_insert, size, cmd,\n  sending_col, rank, periodic_rd_rank_r, bank, row, col, hi_priority,\n  maint_rank_r, maint_zq_r, maint_sre_r, auto_pre_r, rd_half_rmw, act_wait_r\n  );\n\n  input clk;\n\n  input idle_ns;\n  input idle_r;\n\n  input [DATA_BUF_ADDR_WIDTH-1:0]data_buf_addr;\n  output reg [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_r;\n  wire [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_ns =\n                                   idle_r\n                                     ? data_buf_addr\n                                     : req_data_buf_addr_r;\n  always @(posedge clk) req_data_buf_addr_r <= #TCQ req_data_buf_addr_ns;\n\n  input periodic_rd_insert;\n\n  reg req_periodic_rd_r_lcl;\n  wire req_periodic_rd_ns = idle_ns\n                             ? periodic_rd_insert\n                             : req_periodic_rd_r_lcl;\n  always @(posedge clk) req_periodic_rd_r_lcl <= #TCQ req_periodic_rd_ns;\n  output wire req_periodic_rd_r;\n  assign req_periodic_rd_r = req_periodic_rd_r_lcl;\n\n  input size;\n  wire req_size_r_lcl;\n  generate\n    if (BURST_MODE == \"4\") begin : burst_mode_4\n      assign req_size_r_lcl = 1'b0;\n    end\n    else\n      if (BURST_MODE == \"8\") begin : burst_mode_8\n        assign req_size_r_lcl = 1'b1;\n      end\n      else\n        if (BURST_MODE == \"OTF\") begin : burst_mode_otf\n          reg req_size;\n          wire req_size_ns = idle_ns\n                                 ? (periodic_rd_insert || size)\n                                 : req_size;\n          always @(posedge clk) req_size <= #TCQ req_size_ns;\n          assign req_size_r_lcl = req_size;\n        end\n  endgenerate\n  output wire req_size_r;\n  assign req_size_r = req_size_r_lcl;\n\n\n\n  input [2:0] cmd;\n  reg [2:0] req_cmd_r;\n  wire [2:0] req_cmd_ns = idle_ns\n                            ? (periodic_rd_insert ? 3'b001 : cmd)\n                            : req_cmd_r;\n   \n  always @(posedge clk) req_cmd_r <= #TCQ req_cmd_ns;\n\n`ifdef MC_SVA\n  rd_wr_only_wo_ecc: assert property\n    (@(posedge clk) ((ECC != \"OFF\") || idle_ns || ~|req_cmd_ns[2:1]));\n`endif\n  \n  input sending_col;\n  reg rd_wr_r_lcl;\n  wire rd_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || req_cmd_ns[0])\n                    : ~sending_col && rd_wr_r_lcl;\n  always @(posedge clk) rd_wr_r_lcl <= #TCQ rd_wr_ns;\n  output wire rd_wr_r;\n  assign rd_wr_r = rd_wr_r_lcl;\n\n  input [RANK_WIDTH-1:0] rank;\n  input [RANK_WIDTH-1:0] periodic_rd_rank_r;\n  reg [RANK_WIDTH-1:0] req_rank_r_lcl = {RANK_WIDTH{1'b0}};\n  reg [RANK_WIDTH-1:0] req_rank_ns = {RANK_WIDTH{1'b0}};\n  generate\n    if (RANKS != 1) begin\n      always @(idle_ns or periodic_rd_insert\n               or periodic_rd_rank_r or rank or req_rank_r_lcl) req_rank_ns = idle_ns\n                                  ? periodic_rd_insert\n                                      ? periodic_rd_rank_r\n                                      : rank\n                                  : req_rank_r_lcl;\n      always @(posedge clk) req_rank_r_lcl <= #TCQ req_rank_ns;\n    end\n  endgenerate\n  output wire [RANK_WIDTH-1:0] req_rank_r;\n  assign req_rank_r = req_rank_r_lcl;\n\n  input [BANK_WIDTH-1:0] bank;\n  reg [BANK_WIDTH-1:0] req_bank_r_lcl;\n  wire [BANK_WIDTH-1:0] req_bank_ns = idle_ns ? bank : req_bank_r_lcl;\n  always @(posedge clk) req_bank_r_lcl <= #TCQ req_bank_ns;\n  output wire[BANK_WIDTH-1:0] req_bank_r;\n  assign req_bank_r = req_bank_r_lcl;\n\n  input [ROW_WIDTH-1:0] row;\n  reg [ROW_WIDTH-1:0] req_row_r_lcl;\n  wire [ROW_WIDTH-1:0] req_row_ns = idle_ns ? row : req_row_r_lcl;\n  always @(posedge clk) req_row_r_lcl <= #TCQ req_row_ns;\n  output wire [ROW_WIDTH-1:0] req_row_r;\n  assign req_row_r = req_row_r_lcl;\n\n  input [COL_WIDTH-1:0] col;\n  reg [15:0] req_col_r = 16'b0;\n  wire [COL_WIDTH-1:0] req_col_ns = idle_ns ? col : req_col_r[COL_WIDTH-1:0];\n  always @(posedge clk) req_col_r[COL_WIDTH-1:0] <= #TCQ req_col_ns;\n\n  reg req_wr_r_lcl;\n  wire req_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || ~req_cmd_ns[0])\n                    : req_wr_r_lcl;\n  always @(posedge clk) req_wr_r_lcl <= #TCQ req_wr_ns;\n  output wire req_wr_r;\n  assign req_wr_r = req_wr_r_lcl;\n\n  input hi_priority;\n  output reg req_priority_r;\n  wire req_priority_ns = idle_ns ? hi_priority : req_priority_r;\n  always @(posedge clk) req_priority_r <= #TCQ req_priority_ns;\n\n  wire rank_hit = (req_rank_r_lcl == (periodic_rd_insert\n                                       ? periodic_rd_rank_r\n                                       : rank));\n  wire bank_hit = (req_bank_r_lcl == bank);\n  wire rank_bank_hit = rank_hit && bank_hit;\n\n  output reg rb_hit_busy_r;       wire  rb_hit_busy_ns_lcl;\n  assign rb_hit_busy_ns_lcl = rank_bank_hit && ~idle_ns;\n  output wire  rb_hit_busy_ns;\n  assign rb_hit_busy_ns = rb_hit_busy_ns_lcl;\n\n  wire row_hit_ns = (req_row_r_lcl == row);\n  output reg row_hit_r;\n\n  always @(posedge clk) rb_hit_busy_r <= #TCQ rb_hit_busy_ns_lcl;\n  always @(posedge clk) row_hit_r <= #TCQ row_hit_ns;\n\n  input [RANK_WIDTH-1:0] maint_rank_r;\n  input maint_zq_r;\n  input maint_sre_r;\n  output wire maint_hit;\n  assign maint_hit = (req_rank_r_lcl == maint_rank_r) || maint_zq_r || maint_sre_r;\n\ninput auto_pre_r;\n  input rd_half_rmw;\n  reg [15:0] col_addr_template = 16'b0;\n  always @(auto_pre_r or rd_half_rmw or req_col_r\n           or req_size_r_lcl) begin\n    col_addr_template = req_col_r;\n    col_addr_template[10] = auto_pre_r && ~rd_half_rmw;\n    col_addr_template[11] = req_col_r[10];\n    col_addr_template[12] = req_size_r_lcl;\n    col_addr_template[13] = req_col_r[11];\n  end\n  output wire [ROW_WIDTH-1:0] col_addr;\n  assign col_addr = col_addr_template[ROW_WIDTH-1:0];\n\n  output wire req_ras;\n  output wire req_cas;\n  output wire row_cmd_wr;\n  input act_wait_r;\n  assign req_ras = 1'b0;\n  assign req_cas = 1'b1;\n  assign row_cmd_wr = act_wait_r;\n\n  output reg [ROW_WIDTH-1:0] row_addr;\n  always @(act_wait_r or req_row_r_lcl) begin\n    row_addr = req_row_r_lcl;\nif (~act_wait_r) row_addr[10] = 1'b0;\n  end\n\nlocalparam ONE = 1;\n  output reg [RANKS-1:0] rank_busy_r;\n  wire [RANKS-1:0] rank_busy_ns = {RANKS{~idle_ns}} & (ONE[RANKS-1:0] << req_rank_ns);\n  always @(posedge clk) rank_busy_r <= #TCQ rank_busy_ns;\n\nendmodule ",
        "module_name": "mig_7series_v1_9_bank_compare #",
        "module_hash": "c71a751e0f6011c1e0eb3ea8d5c0683d",
        "dataset_index": 25693
      },
      "ADDER4_bef2100c": {
        "rtl_code": "module ADDER4 (\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output [3:0] SUM,\n    output COUT\n);\n\n    assign {COUT, SUM} = A + B + CIN;\n\nendmodule",
        "module_name": "ADDER4",
        "module_hash": "bef2100cbf0f64ec401a235565ed7bc9",
        "dataset_index": 8987
      },
      "encode_8b10b_5df95070": {
        "rtl_code": "module encode_8b10b (datain, dispin, dataout, dispout) ;\n  input [8:0]   datain ;\n  input \tdispin ;  output [9:0]\tdataout ;\n  output\tdispout ;\n\n\n  wire ai = datain[0] ;\n  wire bi = datain[1] ;\n  wire ci = datain[2] ;\n  wire di = datain[3] ;\n  wire ei = datain[4] ;\n  wire fi = datain[5] ;\n  wire gi = datain[6] ;\n  wire hi = datain[7] ;\n  wire ki = datain[8] ;\n\n  wire aeqb = (ai & bi) | (!ai & !bi) ;\n  wire ceqd = (ci & di) | (!ci & !di) ;\n  wire l22 = (ai & bi & !ci & !di) |\n\t     (ci & di & !ai & !bi) |\n\t     ( !aeqb & !ceqd) ;\n  wire l40 = ai & bi & ci & di ;\n  wire l04 = !ai & !bi & !ci & !di ;\n  wire l13 = ( !aeqb & !ci & !di) |\n\t     ( !ceqd & !ai & !bi) ;\n  wire l31 = ( !aeqb & ci & di) |\n\t     ( !ceqd & ai & bi) ;\n\n  wire ao = ai ;\n  wire bo = (bi & !l40) | l04 ;\n  wire co = l04 | ci | (ei & di & !ci & !bi & !ai) ;\n  wire do = di & ! (ai & bi & ci) ;\n  wire eo = (ei | l13) & ! (ei & di & !ci & !bi & !ai) ;\n  wire io = (l22 & !ei) |\n\t    (ei & !di & !ci & !(ai&bi)) |  (ei & l40) |\n\t    (ki & ei & di & ci & !bi & !ai) | (ei & !di & ci & !bi & !ai) ;\n\n  wire pd1s6 = (ei & di & !ci & !bi & !ai) | (!ei & !l22 & !l31) ;\n  wire nd1s6 = ki | (ei & !l22 & !l13) | (!ei & !di & ci & bi & ai) ;\n\n  wire ndos6 = pd1s6 ;\n  wire pdos6 = ki | (ei & !l22 & !l13) ;\n\n\n  wire alt7 = fi & gi & hi & (ki | \n\t\t\t      (dispin ? (!ei & di & l31) : (ei & !di & l13))) ;\n\n   \n  wire fo = fi & ! alt7 ;\n  wire go = gi | (!fi & !gi & !hi) ;\n  wire ho = hi ;\n  wire jo = (!hi & (gi ^ fi)) | alt7 ;\n\n  wire nd1s4 = fi & gi ;\n  wire pd1s4 = (!fi & !gi) | (ki & ((fi & !gi) | (!fi & gi))) ;\n\n  wire ndos4 = (!fi & !gi) ;\n  wire pdos4 = fi & gi & hi ;\n\n  wire illegalk = ki & \n\t\t  (ai | bi | !ci | !di | !ei) & (!fi | !gi | !hi | !ei | !l31) ; wire compls6 = (pd1s6 & !dispin) | (nd1s6 & dispin) ;\n\n  wire disp6 = dispin ^ (ndos6 | pdos6) ;\n\n  wire compls4 = (pd1s4 & !disp6) | (nd1s4 & disp6) ;\n  assign dispout = disp6 ^ (ndos4 | pdos4) ;\n\n  assign dataout = {(jo ^ compls4), (ho ^ compls4),\n\t\t    (go ^ compls4), (fo ^ compls4),\n\t\t    (io ^ compls6), (eo ^ compls6),\n\t\t    (do ^ compls6), (co ^ compls6),\n\t\t    (bo ^ compls6), (ao ^ compls6)} ;\n\nendmodule\n",
        "module_name": "encode_8b10b",
        "module_hash": "5df95070539d9f69472f9fbfecc3bdfe",
        "dataset_index": 23981
      },
      "divider_0d18629d": {
        "rtl_code": "module divider(\n        input_a,\n        input_b,\n        input_a_stb,\n        input_b_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack,\n        input_b_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [31:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  input     [31:0] input_b;\n  input     input_b_stb;\n  output    input_b_ack;\n\n  output    [31:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [31:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [3:0] state;\n  parameter get_a         = 4'd0,\n            get_b         = 4'd1,\n            unpack        = 4'd2,\n            special_cases = 4'd3,\n            normalise_a   = 4'd4,\n            normalise_b   = 4'd5,\n            divide_0      = 4'd6,\n            divide_1      = 4'd7,\n            divide_2      = 4'd8,\n            divide_3      = 4'd9,\n            normalise_1   = 4'd10,\n            normalise_2   = 4'd11,\n            round         = 4'd12,\n            pack          = 4'd13,\n            put_z         = 4'd14;\n\n  reg       [31:0] a, b, z;\n  reg       [23:0] a_m, b_m, z_m;\n  reg       [9:0] a_e, b_e, z_e;\n  reg       a_s, b_s, z_s;\n  reg       guard, round_bit, sticky;\n  reg       [50:0] quotient, divisor, dividend, remainder;\n  reg       [5:0] count;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= get_b;\n        end\n      end\n\n      get_b:\n      begin\n        s_input_b_ack <= 1;\n        if (s_input_b_ack && input_b_stb) begin\n          b <= input_b;\n          s_input_b_ack <= 0;\n          state <= unpack;\n        end\n      end\n\n      unpack:\n      begin\n        a_m <= a[22 : 0];\n        b_m <= b[22 : 0];\n        a_e <= a[30 : 23] - 127;\n        b_e <= b[30 : 23] - 127;\n        a_s <= a[31];\n        b_s <= b[31];\n        state <= special_cases;\n      end\n\n      special_cases:\n      begin\n        if ((a_e == 128 && a_m != 0) || (b_e == 128 && b_m != 0)) begin\n          z[31] <= 1;\n          z[30:23] <= 255;\n          z[22] <= 1;\n          z[21:0] <= 0;\n          state <= put_z;\n          end else if ((a_e == 128) && (b_e == 128)) begin\n          z[31] <= 1;\n          z[30:23] <= 255;\n          z[22] <= 1;\n          z[21:0] <= 0;\n          state <= put_z;\n        end else if (a_e == 128) begin\n          z[31] <= a_s ^ b_s;\n          z[30:23] <= 255;\n          z[22:0] <= 0;\n          state <= put_z;\n           if ($signed(b_e == -127) && (b_m == 0)) begin\n            z[31] <= 1;\n            z[30:23] <= 255;\n            z[22] <= 1;\n            z[21:0] <= 0;\n            state <= put_z;\n          end\n        end else if (b_e == 128) begin\n          z[31] <= a_s ^ b_s;\n          z[30:23] <= 0;\n          z[22:0] <= 0;\n          state <= put_z;\n        end else if (($signed(a_e) == -127) && (a_m == 0)) begin\n          z[31] <= a_s ^ b_s;\n          z[30:23] <= 0;\n          z[22:0] <= 0;\n          state <= put_z;\n           if (($signed(b_e) == -127) && (b_m == 0)) begin\n            z[31] <= 1;\n            z[30:23] <= 255;\n            z[22] <= 1;\n            z[21:0] <= 0;\n            state <= put_z;\n          end\n        end else if (($signed(b_e) == -127) && (b_m == 0)) begin\n          z[31] <= a_s ^ b_s;\n          z[30:23] <= 255;\n          z[22:0] <= 0;\n          state <= put_z;\n        end else begin\n          if ($signed(a_e) == -127) begin\n            a_e <= -126;\n          end else begin\n            a_m[23] <= 1;\n          end\n          if ($signed(b_e) == -127) begin\n            b_e <= -126;\n          end else begin\n            b_m[23] <= 1;\n          end\n          state <= normalise_a;\n        end\n      end\n\n      normalise_a:\n      begin\n        if (a_m[23]) begin\n          state <= normalise_b;\n        end else begin\n          a_m <= a_m << 1;\n          a_e <= a_e - 1;\n        end\n      end\n\n      normalise_b:\n      begin\n        if (b_m[23]) begin\n          state <= divide_0;\n        end else begin\n          b_m <= b_m << 1;\n          b_e <= b_e - 1;\n        end\n      end\n\n      divide_0:\n      begin\n        z_s <= a_s ^ b_s;\n        z_e <= a_e - b_e;\n        quotient <= 0;\n        remainder <= 0;\n        count <= 0;\n        dividend <= a_m << 27;\n        divisor <= b_m;\n        state <= divide_1;\n      end\n\n      divide_1:\n      begin\n        quotient <= quotient << 1;\n        remainder <= remainder << 1;\n        remainder[0] <= dividend[50];\n        dividend <= dividend << 1;\n        state <= divide_2;\n      end\n\n      divide_2:\n      begin\n        if (remainder >= divisor) begin\n          quotient[0] <= 1;\n          remainder <= remainder - divisor;\n        end\n        if (count == 49) begin\n          state <= divide_3;\n        end else begin\n          count <= count + 1;\n          state <= divide_1;\n        end\n      end\n\n      divide_3:\n      begin\n        z_m <= quotient[26:3];\n        guard <= quotient[2];\n        round_bit <= quotient[1];\n        sticky <= quotient[0] | (remainder != 0);\n        state <= normalise_1;\n      end\n\n      normalise_1:\n      begin\n        if (z_m[23] == 0 && $signed(z_e) > -126) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= guard;\n          guard <= round_bit;\n          round_bit <= 0;\n        end else begin\n          state <= normalise_2;\n        end\n      end\n\n      normalise_2:\n      begin\n        if ($signed(z_e) < -126) begin\n          z_e <= z_e + 1;\n          z_m <= z_m >> 1;\n          guard <= z_m[0];\n          round_bit <= guard;\n          sticky <= sticky | round_bit;\n        end else begin\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit | sticky | z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 24'hffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[22 : 0] <= z_m[22:0];\n        z[30 : 23] <= z_e[7:0] + 127;\n        z[31] <= z_s;\n        if ($signed(z_e) == -126 && z_m[23] == 0) begin\n          z[30 : 23] <= 0;\n        end\n        if ($signed(z_e) > 127) begin\n          z[22 : 0] <= 0;\n          z[30 : 23] <= 255;\n          z[31] <= z_s;\n        end\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_input_b_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign input_b_ack = s_input_b_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n",
        "module_name": "divider",
        "module_hash": "0d18629d7ed5a07c6ca350164fb3e45e",
        "dataset_index": 13739
      },
      "sevenseg_657b98e7": {
        "rtl_code": "\nmodule sevenseg\n(\n\tinput wire        clk,\n\tinput wire        rstn,\n\tinput wire  [7:0] display_0,\n\tinput wire  [7:0] display_1,\n\tinput wire  [7:0] display_2,\n\tinput wire  [7:0] display_3,\n\tinput wire  [1:0] decplace,\n\toutput reg  [7:0] seg,\n\toutput reg  [3:0] an\n);\n\nlocalparam NUM_0     = 8'b11000000;\nlocalparam NUM_1     = 8'b11111001;\nlocalparam NUM_2     = 8'b10100100;\nlocalparam NUM_3     = 8'b10110000;\nlocalparam NUM_4     = 8'b10011001;\nlocalparam NUM_5     = 8'b10010010;\nlocalparam NUM_6     = 8'b10000010;\nlocalparam NUM_7     = 8'b11111000;\nlocalparam NUM_8     = 8'b10000000;\nlocalparam NUM_9     = 8'b10010000;\nlocalparam CHAR_A    = 8'b10001000;\nlocalparam CHAR_B    = 8'b10000011;\nlocalparam CHAR_C    = 8'b11000110;\nlocalparam CHAR_D    = 8'b10100001;\nlocalparam CHAR_E    = 8'b10000110;\nlocalparam CHAR_F    = 8'b10001110;\nlocalparam CHAR_G    = 8'b10000010; localparam CHAR_H    = 8'b10001001;\nlocalparam CHAR_K    = 8'b10001111;\nlocalparam CHAR_L    = 8'b11000111;\nlocalparam CHAR_o    = 8'b10100011;\nlocalparam CHAR_S    = 8'b10010010; localparam CHAR_T    = 8'b11111000; localparam CHAR_P    = 8'b10001100;\nlocalparam SPACE     = 8'b11111111;\nlocalparam HYPHEN    = 8'b10111111;\nlocalparam UNDERLINE = 8'b11110111;\nlocalparam OVERRLINE = 8'b11111110;\n\n\nreg  [16:0] cnt;\nreg  [7:0]  digit;\n\nalways @(cnt[16:15]) begin\n\tcase (cnt[16:15])\n\t\t2'b11:   an <= 4'b1110;\n\t\t2'b10:   an <= 4'b1101;\n\t\t2'b01:   an <= 4'b1011;\n\t\tdefault: an <= 4'b0111;\n\tendcase\nend\n\nalways @(cnt[16:15] or display_0 or display_1 or display_2 or display_3) begin\n\tcase (cnt[16:15])\n\t\t2'b00:   digit <= display_0;\n\t\t2'b01:   digit <= display_1;\n\t\t2'b10:   digit <= display_2;\n\t\tdefault: digit <= display_3;\n\tendcase\n\n\tcase (digit)\n\t\t8'h20: seg <= SPACE;\n\t\t8'h2d: seg <= HYPHEN;\n\t\t8'h30: seg <= NUM_0;\n\t\t8'h31: seg <= NUM_1;\n\t\t8'h32: seg <= NUM_2;\n\t\t8'h33: seg <= NUM_3;\n\t\t8'h34: seg <= NUM_4;\n\t\t8'h35: seg <= NUM_5;\n\t\t8'h36: seg <= NUM_6;\n\t\t8'h37: seg <= NUM_7;\n\t\t8'h38: seg <= NUM_8;\n\t\t8'h39: seg <= NUM_9;\n\t\t8'h41: seg <= CHAR_A;\n\t\t8'h43: seg <= CHAR_C;\n\t\t8'h45: seg <= CHAR_E;\n\t\t8'h47: seg <= CHAR_G;\n\t\t8'h48: seg <= CHAR_H;\n\t\t8'h4b: seg <= CHAR_K;\n\t\t8'h4c: seg <= CHAR_L;\n\t\t8'h50: seg <= CHAR_P;\n\t\t8'h53: seg <= CHAR_S;\n\t\t8'h5f: seg <= UNDERLINE;\n\t\t8'h6f: seg <= CHAR_o;\n\t\tdefault: seg <= OVERRLINE;\n\tendcase\nend\n\nalways @(posedge clk or negedge rstn) begin\n\tif (!rstn) begin\n\t\tcnt <= 0;\n\tend\n\telse\n\t\tcnt <= cnt + 1;\nend\n\nendmodule\n",
        "module_name": "sevenseg",
        "module_hash": "657b98e767cb68451cd593e93a646ac9",
        "dataset_index": 19241
      },
      "tx_data_send_d3a4ca01": {
        "rtl_code": "module tx_data_send(\n\t\t\tinput pclk_tx,\n\t\t\tinput send_null_tx,\n\t\t\tinput enable_tx,\n\n\t\t\tinput get_data,\n\t\t\tinput get_data_0,\n\n\t\t\tinput [7:0] timecode_tx_i,\n\t\t\tinput tickin_tx,\n\n\t\t\tinput [8:0] data_tx_i,\n\t\t\tinput txwrite_tx,\n\t\t\t\n\t\t\tinput fct_counter_p,\n\n\t\t\toutput reg [8:0]  tx_data_in,\n\t\t\toutput reg [8:0]  tx_data_in_0,\n\n\t\t\toutput reg process_data,\n\t\t\toutput reg process_data_0,\n\n\t\t\toutput reg [7:0]  tx_tcode_in,\n\t\t\toutput reg tcode_rdy_trnsp\n\n\t\t   );\n\n\twire process_data_en;\n\n\tassign process_data_en = (txwrite_tx & fct_counter_p)?1'b1:1'b0;\n\nalways@(posedge pclk_tx or negedge enable_tx)\nbegin\n\n\tif(!enable_tx)\n\tbegin\n\t\tprocess_data   <= 1'b0;\n\t\tprocess_data_0 <= 1'b0;\n\t\n\t\ttcode_rdy_trnsp <= 1'b0;\n\n\t\ttx_data_in      <= 9'd0;\n\t\ttx_data_in_0    <= 9'd0;\n\t\ttx_tcode_in     <= 8'd0;\n\tend\n\telse if(send_null_tx)\n\tbegin\n\n\t\tif(tickin_tx)\n\t\tbegin\n\t\t\ttx_tcode_in    <= timecode_tx_i;\n\t\t\ttcode_rdy_trnsp <= 1'b1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttx_tcode_in    <= tx_tcode_in;\n\t\t\ttcode_rdy_trnsp <= 1'b0;\n\t\tend\n\n\t\tif(!txwrite_tx)\n\t\tbegin\n\t\t\tprocess_data   <= 1'b0;\t\n\t\t\tprocess_data_0 <= 1'b0;\t\n\t\tend\n\t\telse if(get_data && process_data_en)\n\t\tbegin\n\t\t\ttx_data_in     <= data_tx_i;\n\t\t\tprocess_data   <= 1'b1;\t\n\t\t\tprocess_data_0 <= 1'b0;\t\t\n\t\tend\n\t\telse if(get_data_0 && process_data_en)\n\t\tbegin\n\t\t\ttx_data_in_0   <= data_tx_i;\n\t\t\tprocess_data   <= 1'b0;\t\n\t\t\tprocess_data_0 <= 1'b1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttx_data_in_0   <= tx_data_in_0;\n\t\t\ttx_data_in     <= tx_data_in;\n\t\t\tprocess_data   <= process_data;\t\n\t\t\tprocess_data_0 <= process_data_0;\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "tx_data_send",
        "module_hash": "d3a4ca0116b7bcdd6c16cbfb6e7f8aa2",
        "dataset_index": 24047
      },
      "top_module_ef9a19e9": {
        "rtl_code": "\nmodule top_module(\n  input              clk,\n  input              reset,      // Synchronous active-high reset\n  input  [7:0]       sel,        // Select input to choose between multiplexer and counter\n  input  [1023:0]    in,         // 1024-bit input vector for the multiplexer\n  output [3:0]       out,        // 4-bit output of the multiplexer\n  output reg [15:0]  Q          // 16-bit output of the Johnson counter\n);\n\n  // 256-to-1 multiplexer\n  wire [3:0] mux_out;\n  assign mux_out = in[sel*4 +: 4];\n  assign out = mux_out;\n\n  // 16-bit Johnson counter\n  reg [15:0] Q_next;\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      Q_next <= 16'b0000000000000000;\n    end else begin\n      Q_next <= {Q[14:0], Q[15] ^ Q[14]};\n    end\n  end\n  always @(posedge clk) begin\n    Q <= Q_next;\n  end\n\n  // Functional module\n  reg [3:0] mux_out_delayed; // Changed from wire to reg\n  reg [15:0] Q_delayed;\n  always @(posedge clk) begin\n    mux_out_delayed <= mux_out;\n    Q_delayed <= Q;\n  end\n  reg [19:0] final_output; // Changed from assign \n  always @(*) begin\n    final_output = {mux_out_delayed, Q_delayed};\n  end // Fixed RTL\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "ef9a19e90308e79f90e7419ebdfa01a3",
        "dataset_index": 12208
      },
      "uart_transceiver_d4050d69": {
        "rtl_code": "\n\nmodule uart_transceiver(\n\tinput sys_rst,\n\tinput sys_clk,\n\n\tinput uart_rx,\n\toutput reg uart_tx,\n\n\tinput [15:0] divisor,\n\n\toutput reg [7:0] rx_data,\n\toutput reg rx_done,\n\n\tinput [7:0] tx_data,\n\tinput tx_wr,\n\toutput reg tx_done,\n\n\toutput reg break\n);\n\nreg [15:0] enable16_counter;\n\nwire enable16;\nassign enable16 = (enable16_counter == 16'd0);\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tenable16_counter <= divisor - 16'b1;\n\telse begin\n\t\tenable16_counter <= enable16_counter - 16'd1;\n\t\tif(enable16)\n\t\t\tenable16_counter <= divisor - 16'b1;\n\tend\nend\n\nreg uart_rx1;\nreg uart_rx2;\n\nalways @(posedge sys_clk) begin\n\tuart_rx1 <= uart_rx;\n\tuart_rx2 <= uart_rx1;\nend\n\nreg rx_busy;\nreg uart_rx_r;\nreg [3:0] rx_count16;\nreg [3:0] rx_bitcount;\nreg [7:0] rx_reg;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\trx_done <= 1'b0;\n\t\trx_busy <= 1'b0;\n\t\trx_count16  <= 4'd0;\n\t\trx_bitcount <= 4'd0;\n\t\tbreak <= 1'b0;\n\t\tuart_rx_r <= 1'b0;\n\tend else begin\n\t\trx_done <= 1'b0;\n\t\tbreak <= 1'b0;\n\n\t\tif(enable16) begin\n\t\t\tuart_rx_r <= uart_rx2;\n\t\t\tif(~rx_busy) begin if(~uart_rx2 & uart_rx_r) begin rx_busy <= 1'b1;\n\t\t\t\t\trx_count16 <= 4'd7;\n\t\t\t\t\trx_bitcount <= 4'd0;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\trx_count16 <= rx_count16 + 4'd1;\n\n\t\t\t\tif(rx_count16 == 4'd0) begin rx_bitcount <= rx_bitcount + 4'd1;\n\n\t\t\t\t\tif(rx_bitcount == 4'd0) begin if(uart_rx2)\n\t\t\t\t\t\t\trx_busy <= 1'b0;\n\t\t\t\t\tend else if(rx_bitcount == 4'd9) begin\n\t\t\t\t\t\trx_busy <= 1'b0;\n\t\t\t\t\t\tif(uart_rx2) begin rx_data <= rx_reg;\n\t\t\t\t\t\t\trx_done <= 1'b1;\n\t\t\t\t\t\tend else if(rx_reg == 8'h00) break <= 1'b1;\n\t\t\t\t\tend else\n\t\t\t\t\t\trx_reg <= {uart_rx2, rx_reg[7:1]};\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nreg tx_busy;\nreg [3:0] tx_bitcount;\nreg [3:0] tx_count16;\nreg [7:0] tx_reg;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\ttx_done <= 1'b0;\n\t\ttx_busy <= 1'b0;\n\t\tuart_tx <= 1'b1;\n\tend else begin\n\t\ttx_done <= 1'b0;\n\t\tif(tx_wr) begin\n\t\t\ttx_reg <= tx_data;\n\t\t\ttx_bitcount <= 4'd0;\n\t\t\ttx_count16 <= 4'd1;\n\t\t\ttx_busy <= 1'b1;\n\t\t\tuart_tx <= 1'b0;\n`ifdef SIMULATION\n\t\t\t$display(\"UART:\u00a0%c\", tx_data);\n`endif\n\t\tend else if(enable16 && tx_busy) begin\n\t\t\ttx_count16  <= tx_count16 + 4'd1;\n\n\t\t\tif(tx_count16 == 4'd0) begin\n\t\t\t\ttx_bitcount <= tx_bitcount + 4'd1;\n\t\t\t\t\n\t\t\t\tif(tx_bitcount == 4'd8) begin\n\t\t\t\t\tuart_tx <= 1'b1;\n\t\t\t\tend else if(tx_bitcount == 4'd9) begin\n\t\t\t\t\tuart_tx <= 1'b1;\n\t\t\t\t\ttx_busy <= 1'b0;\n\t\t\t\t\ttx_done <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tuart_tx <= tx_reg[0];\n\t\t\t\t\ttx_reg <= {1'b0, tx_reg[7:1]};\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "uart_transceiver",
        "module_hash": "d4050d697064e3b886acff277f2cae60",
        "dataset_index": 24182
      },
      "sky130_fd_sc_dff_02ee0902": {
        "rtl_code": "\nmodule sky130_fd_sc_dff (\n    Q      , //output\n    CLK_N  , //input \n    D      , //input \n    RESET_B, //input \n    VPWR   , //input \n    VGND   , //input \n    VPB    , //input \n    VNB    //input \n);\n\n    output Q      ;\n    input  CLK_N  ;\n    input  D      ;\n    input  RESET_B;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    reg Q_int; //internal register\n\n    assign Q = Q_int; // assign the output to the internal wire\n\n    // Define the D-flip-flop using Verilog primitives\n    always @(posedge CLK_N or negedge RESET_B) begin\n        if (!RESET_B)\n            Q_int <= 1'b0; // set Q to 0 when reset is active\n        else\n            Q_int <= D;    //otherwise set Q to D\n    end\n\nendmodule\n\nmodule asynchronous_reset_flip_flop (\n    Q      , //output\n    CLK_N  , //input \n    D      , //input \n    RESET_B, //input \n    VPWR   , //input \n    VGND   , //input \n    VPB    , //input \n    VNB    //input \n);\n\n    output Q      ;\n    input  CLK_N  ;\n    input  D      ;\n    input  RESET_B;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    wire Q_next; //internal wire\n\n    assign Q = Q_next; // assign the output to the internal wire\n\n    sky130_fd_sc_dff dff (\n        .Q      (Q_next), //connect internal wire of DFF to internal wire of this module\n        .CLK_N  (CLK_N),\n        .D      (D),\n        .RESET_B(RESET_B),\n        .VPWR   (VPWR),\n        .VGND   (VGND),\n        .VPB    (VPB),\n        .VNB    (VNB)\n    );\nendmodule\n",
        "module_name": "sky130_fd_sc_dff",
        "module_hash": "02ee09027778a3c6df13256235ada0f3",
        "dataset_index": 18468
      },
      "sig_337p_121cae50": {
        "rtl_code": "\n\nmodule sig_337p(\n\ninput [6:0] t,\noutput reg [7:0] y\n\n);\n\nreg [6:0] temp;\nreg [7:0] s;\nreg [26:0] p;\n\n\nalways@(*) begin\n\n\tif(t[6] == 1)\n\t\ttemp = ~t + 1'b1;\n\telse\n\t\ttemp = t;\n\t\n\tp[0]  =  temp[5] &  temp[2];\n\tp[1]  =  temp[5] &  temp[4];\n\tp[2]  =  temp[5];\n\tp[3]  =  temp[5] &  temp[3];\n\tp[4]  =  temp[4] & ~temp[3] & ~temp[2] & ~temp[1] & ~temp[0];\n\tp[5]  = ~temp[4] &  temp[3] & ~temp[2] & ~temp[1] & ~temp[0];\n\tp[6]  = ~temp[4] & ~temp[3] &  temp[2] &  temp[1] & ~temp[0];\n\tp[7]  =  temp[3] & ~temp[2] &  temp[1] & ~temp[0];\n\tp[8]  =  temp[4] &  temp[3] &  temp[1] &  temp[0];\n\tp[9]  =  temp[4] & ~temp[3] &  temp[1] &  temp[0];\n\tp[10] =  temp[4] &  temp[2] &  temp[1];\n\tp[11] = ~temp[4] &  temp[3] &  temp[1] &  temp[0];\n\tp[12] =  temp[3] &  temp[2] &  temp[1];\n\tp[13] =  temp[3] & ~temp[1] &  temp[0];\n\tp[14] =  temp[4] &  temp[2] &  temp[0];\n\tp[15] =  temp[4] & ~temp[3] & ~temp[2] & temp[1];\n\tp[16] = ~temp[4] & ~temp[3] & ~temp[2] & temp[1];\n\tp[17] = ~temp[4] &  temp[3] &  temp[2];\n\tp[18] =  temp[4] &  temp[3] &  temp[2];\n\tp[19] = ~temp[3] &  temp[2];\n\tp[20] = ~temp[4] &  temp[2] &  temp[1] &  temp[0];\n\tp[21] = ~temp[4] &  temp[2] & ~temp[1] &  temp[0];\n\tp[22] =  temp[4] & ~temp[3] &  temp[2] & ~temp[1];\n\tp[23] =  temp[4] & ~temp[2] & ~temp[1] &  temp[0];\n\tp[24] = ~temp[4] & ~temp[3] & ~temp[2] &  temp[0];\n\tp[25] =  temp[4] &  temp[3];\n\tp[26] =  temp[4] &  temp[3] & ~temp[2] & ~temp[0];\n\t\n\ts[7] = 1'b0;\n\ts[6] = 1'b1;\n\ts[5] = p[2] | p[4] | p[7] | p[9] | p[10] | p[11] | p[12] | p[13] |\n\t\t\t p[14] | p[15] | p[17] | p[22] |  p[23] | p[25];\n\ts[4] = p[2] | p[4] | p[5] | p[9] | p[10] | p[14] | p[15] | p[19] |\n\t\t\t p[23] | p[25];\n\ts[3] = p[2] | p[5] | p[10] | p[12] | p[16] | p[17] | p[20] | p[25];\n\ts[2] = p[2] | p[5] | p[6] | p[8] | p[11] | p[12] | p[15] | p[18] |\n\t\t\t p[22] | p[24];\n\ts[1] = p[2] | p[5] | p[6] | p[7] | p[11] | p[20] | p[21] | p[22] |\n\t\t\t p[23] | p[26];\n\ts[0] = p[0] | p[1] | p[3] | p[4] | p[6] | p[7] | p[9] | p[12] |\n\t\t\t p[13] | p[14] | p[17] | p[21];\n\t\t\t \n\tif(t[6] == 1)\n\t\ty = 8'b10000000 - s;\n\telse\n\t\ty = s;\n\t\n\t\nend\n\nendmodule\n",
        "module_name": "sig_337p",
        "module_hash": "121cae503f46f00d55d0740d5c2f19a1",
        "dataset_index": 21866
      },
      "GrayCodeConverter #_3d2805d9": {
        "rtl_code": "module GrayCodeConverter #(\n  parameter n = 4 // number of bits\n)(\n  input [n-1:0] bin,\n  input [n-1:0] gray,\n  output [n-1:0] gray_out,\n  output [n-1:0] bin_out\n);\n\n\nassign gray_out = bin ^ (bin >> 1);\nassign bin_out = gray ^ (gray >> 1);\n\nendmodule",
        "module_name": "GrayCodeConverter #",
        "module_hash": "3d2805d97ee8c52469cd7357b1c242eb",
        "dataset_index": 1519
      },
      "four_bit_adder_be751d3c": {
        "rtl_code": "module four_bit_adder(a, b, sum);\ninput [3:0] a;\ninput [3:0] b;\noutput [3:0] sum;\n\nassign sum = a + b;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "be751d3cfae9207c74d8446e4ab4c2f6",
        "dataset_index": 14759
      },
      "fsm_sequence_detection_5f562f3e": {
        "rtl_code": "module fsm_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  output reg match\n);\n\n  // Define the states\n  parameter S0 = 2'b00;\n  parameter S1 = 2'b01;\n  parameter S2 = 2'b10;\n  \n  // Define the state register and next state logic\n  reg [1:0] state, next_state;\n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= S0;\n    end else begin\n      state <= next_state;\n    end\n  end\n  \n  // Define the output logic\n  always @ (state, data) begin\n    if (state == S2 && data == 1'b1) begin\n      match <= 1'b1;\n    end else begin\n      match <= 1'b0;\n    end\n  end\n  \n  // Define the next state logic\n  always @ (state, data) begin\n    case (state)\n      S0: begin\n        if (data == 1'b1) begin\n          next_state = S1;\n        end else begin\n          next_state = S0;\n        end\n      end\n      S1: begin\n        if (data == 1'b0) begin\n          next_state = S0;\n        end else if (data == 1'b1) begin\n          next_state = S2;\n        end else begin\n          next_state = S1;\n        end\n      end\n      S2: begin\n        next_state = S0;\n      end\n      default: next_state = S0;\n    endcase\n  end\n  \nendmodule\n",
        "module_name": "fsm_sequence_detection",
        "module_hash": "5f562f3e174a28a8909a1f24457ca900",
        "dataset_index": 15834
      },
      "adder_54d2decf": {
        "rtl_code": "module adder(\n  input [7:0] A, B,\n  output reg [7:0] sum,\n  output reg carry_out\n);\n\n  always @(*) begin\n    sum = A + B;\n    carry_out = (sum > 8'hFF);\n  end\n\nendmodule",
        "module_name": "adder",
        "module_hash": "54d2decf2dec43c2a3d6b9eacf67fa3b",
        "dataset_index": 18368
      },
      "mux_2to1_d07c2b01": {
        "rtl_code": "module mux_2to1 (\n    out,\n    in0,\n    in1,\n    sel\n);\n\n    output out;\n    input in0;\n    input in1;\n    input sel;\n\n    assign out = (sel == 1'b0) ? in0 : in1;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "d07c2b01914e2f8faed896a20b6a4759",
        "dataset_index": 13523
      },
      "DFF_11ed6ab8": {
        "rtl_code": "\nmodule DFF(input D, CLK, EN, output reg Q); // positive-edge triggered DFF\n  always@(posedge CLK)\n    if (EN)\n      Q <= D;\nendmodule\nmodule TLATCH(input D, E, TE, output reg Q); // transparent latch\n  always@(posedge E, posedge TE)\n    if (!TE)\n      Q <= D;\n    else\n      Q <= 1'b0;\nendmodule",
        "module_name": "DFF",
        "module_hash": "11ed6ab8e85f78da2dccc6570c988767",
        "dataset_index": 2166
      },
      "reset_and_status_9ca38934": {
        "rtl_code": "module reset_and_status \n#( \n  parameter PIO_WIDTH=32\n)\n(\n   input clk,\n   input resetn,\n\n   output reg [PIO_WIDTH-1 : 0 ]  pio_in,\n   input      [PIO_WIDTH-1 : 0 ]  pio_out,\n\n   input  lock_kernel_pll,\n   input  fixedclk_locked,          input  mem0_local_cal_success,\n   input  mem0_local_cal_fail,\n   input  mem0_local_init_done,\n\n   input  mem1_local_cal_success,\n   input  mem1_local_cal_fail,\n   input  mem1_local_init_done,\n\n   output reg [1:0] mem_organization,\n   output     [1:0] mem_organization_export,\n   output           pll_reset,\n   output reg       sw_reset_n_out\n);\n\nreg   [1:0] pio_out_ddr_mode;\nreg  pio_out_pll_reset;\nreg  pio_out_sw_reset;\n\n\nreg [9:0] reset_count;\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    reset_count <= 10'b0;\n  else if (pio_out_sw_reset)\n    reset_count <= 10'b0;\n  else if (!reset_count[9])\n    reset_count <= reset_count + 2'b01;\n\n\n\nalways@(posedge clk)\nbegin\n  pio_out_ddr_mode = pio_out[9:8];\n  pio_out_pll_reset = pio_out[30];\n  pio_out_sw_reset = pio_out[31];\nend\n\n\nalways@(posedge clk)\nbegin\n  pio_in = {\n            lock_kernel_pll,\n            fixedclk_locked,\n            1'b0,\n            1'b0,\n            mem1_local_cal_fail,\n            mem0_local_cal_fail,\n            mem1_local_cal_success,\n            mem1_local_init_done,\n            mem0_local_cal_success,\n            mem0_local_init_done};\nend\n\n\nalways@(posedge clk)\n  mem_organization = pio_out_ddr_mode;\n\nassign mem_organization_export = mem_organization;\n\nassign pll_reset = pio_out_pll_reset;\n\nalways@(posedge clk)\n  sw_reset_n_out = !(!reset_count[9] && (reset_count[8:0] != 0));\n\nendmodule\n\n",
        "module_name": "reset_and_status",
        "module_hash": "9ca389340640b8278027760ed09c08fb",
        "dataset_index": 25808
      },
      "fifo_822d3c3d": {
        "rtl_code": "\nmodule fifo (\n       input  [7:0] io_dataIn,\n       output [7:0] io_dataOut,\n       input   io_read,\n       input   io_write,\n       output  io_full,\n       output  io_empty,\n       input   clk,\n       input   reset\n     );\n     \n     localparam DEPTH = 32;\n     \n     reg [7:0] mem [0:DEPTH-1];\n     reg [4:0] head, tail;\n     reg [4:0] next_head, next_tail;\n     reg full, empty;\n     \n     assign io_full = full;\n     assign io_empty = empty;\n     \n     always @(posedge clk) begin\n         if (reset) begin\n             tail <= 0;\n             head <= 0;\n             empty <= 1;\n             full <= 0;\n         end else begin\n             if (io_write & ~full) begin\n                 mem[head] <= io_dataIn;\n                 head <= next_head;\n             end \n             if (io_read & ~empty) begin\n                 tail <= next_tail;\n             end\n             \n             if (next_head == next_tail) begin  \n                 full <= io_write;\n                 empty <= io_write ? 0 : empty;\n             end else begin\n                 full <= 0;\n                 empty <= (head == tail) ? io_write : empty;\n             end\n             \n             next_head <= head + io_write;\n             next_tail <= tail + io_read;\n         end\n     end\n     \n     assign io_dataOut = empty ? 0 : mem[tail];\n     \n endmodule",
        "module_name": "fifo",
        "module_hash": "822d3c3d1fbdc50632e9ba9094705a0a",
        "dataset_index": 14314
      },
      "accu_e2480e28": {
        "rtl_code": "\nmodule accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n \n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [9:0]   data_out\n);\n\n    reg [7:0] acc_reg;\n    reg [2:0] count_reg;\n    reg [9:0] pipe_reg;\n    wire [2:0] next_count;\n    wire [9:0] next_pipe;\n    \n    assign next_count = (count_reg == 3'b111) ? 3'b000 : count_reg + 1'b1;\n    assign next_pipe = (count_reg == 3'b111) ? {2'b00, acc_reg} : {pipe_reg[7:0], acc_reg};\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            acc_reg <= 8'b0;\n            count_reg <= 3'b0;\n            pipe_reg <= 10'b0;\n            valid_b <= 1'b0;\n            data_out <= 10'b0;\n        end\n        else begin\n            acc_reg <= (valid_a) ? acc_reg + data_in : acc_reg;\n            count_reg <= (valid_a) ? next_count : count_reg;\n            pipe_reg <= next_pipe;\n            valid_b <= (count_reg == 3'b111) ? 1'b1 : 1'b0;\n            data_out <= (count_reg == 3'b111) ? pipe_reg : 10'b0;\n        end\n    end\n    \n    assign ready_a = ~valid_b & ready_b;\n    \nendmodule",
        "module_name": "accu",
        "module_hash": "e2480e28befd029f318b9bb3e55681db",
        "dataset_index": 3241
      },
      "Clock_Gate_a3515a64": {
        "rtl_code": "module Clock_Gate (\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  always @ (posedge CLK) begin\n    if (EN) begin\n      ENCLK <= CLK;\n    end\n    else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "Clock_Gate",
        "module_hash": "a3515a641bfa6b7aaf7262364827a887",
        "dataset_index": 12221
      },
      "up_counter_4bit_d25635d0": {
        "rtl_code": "module up_counter_4bit (\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (rst == 0) begin\n        count <= 4'b0000;\n    end else if (en == 1) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "up_counter_4bit",
        "module_hash": "d25635d0e0c89e6c7acee22fa366d3ae",
        "dataset_index": 16846
      },
      "ycbcr_to_rgb_3eaaa86e": {
        "rtl_code": "module ycbcr_to_rgb (\n    y, cb, cr,\n    red, green, blue,\n    clk\n);\n\ninput clk;\n\ninput [7:0] y, cb, cr;\noutput reg [7:0] red, green, blue;\n\n// offset the inputs\nreg signed [8:0] adj_y, adj_cb, adj_cr;\nalways @(posedge clk) begin\n    adj_y <= y;\n    adj_cr <= cr - 8'd128;\n    adj_cb <= cb - 8'd128;\nend\n\nwire signed [8:0] const0 = 9'd128; // 1 * 128\nwire signed [8:0] const1 = 9'd179; // 1.402 * 128\nwire signed [8:0] const2 = - 9'd91; // 0.714136 * 128 \nwire signed [8:0] const3 = - 9'd44; // 0.344136 * 128\nwire signed [8:0] const4 = 9'd227; // 1.772 * 128\n\n// multipliers - 9x9 is a natural building block\nreg signed [17:0] product_a, product_b, product_c, \n    product_d, product_e;\nalways @(posedge clk) begin\n    product_a <= const0 * adj_y;\n    product_b <= const1 * adj_cr;\n    product_c <= const2 * adj_cr;\n    product_d <= const3 * adj_cb;\n    product_e <= const4 * adj_cb;\nend\n\n// summation - 17 selected by simulation\nreg signed [17:0] sum_red, sum_green, sum_blue;\nalways @(posedge clk) begin\n    sum_red <= product_a + product_b;\n    sum_green <= product_a + product_c + product_d;\n    sum_blue <= product_a + product_e;\nend\n\n// saturation\nalways @(posedge clk) begin\n    if (sum_red[17] == 1) begin\n        red <= 8'h0;\n    end else if (sum_red[16:15] == 2'b11) begin\n        red <= 8'hff;\n    end else begin\n        red <= sum_red[14:7];\n    end\n\n    if (sum_green[17] == 1) begin\n        green <= 8'h0;\n    end else if (sum_green[16:15] == 2'b11) begin\n        green <= 8'hff;\n    end else begin\n        green <= sum_green[14:7];\n    end\n\n    if (sum_blue[17] == 1) begin\n        blue <= 8'h0;\n    end else if (sum_blue[16:15] == 2'b11) begin\n        blue <= 8'hff;\n    end else begin\n        blue <= sum_blue[14:7];\n    end\nend\n\nendmodule",
        "module_name": "ycbcr_to_rgb",
        "module_hash": "3eaaa86e30ff7b217b3aa5611669ebee",
        "dataset_index": 5429
      },
      "decoder_d68f4ea5": {
        "rtl_code": "module decoder (\n    input [2:0] in,\n    output [7:0] out\n);\n    \n    assign out = {(~in[2] & ~in[1] & ~in[0]), (~in[2] & ~in[1] & in[0]), (~in[2] & in[1] & ~in[0]), (~in[2] & in[1] & in[0]), (in[2] & ~in[1] & ~in[0]), (in[2] & ~in[1] & in[0]), (in[2] & in[1] & ~in[0]), (in[2] & in[1] & in[0])};\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "d68f4ea5a600ec2e0487b7824e63b6ab",
        "dataset_index": 9888
      },
      "mips_pipeline_5342486a": {
        "rtl_code": "\nmodule mips_pipeline    (\n                        input             clk,\n                        input             rst,\n\n                        input             pl_stall_mem,\n                        input             pl_stall_branch,\n                        input             pl_stall_multdiv,\n                        input             pl_stall_eret,\n                        input             exception,\n\n                        output[5:0]       ifield_fstage_opcode,\n                        output[4:0]       ifield_fstage_d,\n                        output[4:0]       ifield_fstage_t,\n                        output[4:0]       ifield_fstage_s,\n                        output[4:0]       ifield_fstage_shift,\n                        output[5:0]       ifield_fstage_func,\n\n                        input             pmem_cmdok,\n                        input[31:0]       pmem_cmd,\n                        input             pmem_branch_ended,\n\n                        input             alu_multdiv_ready,\n\n                        output reg        pl_cause_bd,\n                        output reg        pl_pcpause\n                        );\n\n\n\n\n  reg[31:0]   pl_instr_fstage;\n  reg[31:0]   pl_instr_fstage_d;\n  reg[1:0]    cpu_state;\n  reg[1:0]    cpu_state_d;\n\n  reg         pl_pcpause_d;\n  reg         instr_next;\n  reg         instr_next_d;\n  reg         pl_branch_excpt;\n  reg         pl_branch_excpt_d;\n  reg         branch_stall_was;\n  reg         branch_stall_was_d;\n  localparam  NORMAL=         2'b00,\n              STALL_BRANCH=   2'b01,\n              STALL_MEM=      2'b10,\n              STALL_MULTDIV=  2'b11;\n\n\n\n\n  assign ifield_fstage_opcode= pl_instr_fstage_d[31:26];\n  assign ifield_fstage_s= pl_instr_fstage_d[25:21];\n  assign ifield_fstage_t= pl_instr_fstage_d[20:16];\n  assign ifield_fstage_d= pl_instr_fstage_d[15:11];\n  assign ifield_fstage_shift= pl_instr_fstage_d[10:6];\n  assign ifield_fstage_func= pl_instr_fstage_d[5:0];\n\n  always @*\n  begin\n  pl_instr_fstage= pmem_cmd;\n  cpu_state= NORMAL;\n  instr_next= instr_next_d;\n  pl_pcpause= pl_pcpause_d;\n  branch_stall_was= branch_stall_was_d;\n  pl_cause_bd= 1'b0;\n  pl_branch_excpt= pl_branch_excpt_d;\n\n  case(cpu_state_d)\n  NORMAL:\n    begin\n    pl_pcpause= 1'b0;\n    branch_stall_was= 1'b0;\n    if(exception | ((pl_stall_eret | pl_stall_branch) & !pl_stall_mem))\n      begin\n      instr_next= !pmem_cmdok & !(pl_stall_eret | exception);\n                  pl_instr_fstage= pl_stall_eret | exception | !pmem_cmdok ? 32'd0 :\n                       pmem_cmd;\n      cpu_state= STALL_BRANCH;\n      end\n    else if(pl_stall_mem | pl_stall_multdiv)\n      begin\n      pl_pcpause= 1'b1;\n      pl_instr_fstage= pl_instr_fstage_d;\n      cpu_state= pl_stall_mem ? STALL_MEM : STALL_MULTDIV;\n      end\n    else if(!pmem_cmdok) pl_instr_fstage= 32'd0;\n    end\n  STALL_BRANCH:\n    begin\n    branch_stall_was= 1'b1;\n    if(pmem_cmdok)\n      begin\n      instr_next= 1'b0;\n      pl_branch_excpt= 1'b0;\n      end\n\n    if(exception | ((pl_stall_eret | pl_stall_branch) & !pl_stall_mem))\n      begin\n      pl_instr_fstage= 32'd0;\n      pl_cause_bd= 1'b1;\n      pl_branch_excpt= 1'b1;\n      cpu_state= STALL_BRANCH;\n      end\n    else if(pl_stall_mem | pl_stall_multdiv)\n      begin\n      pl_pcpause= 1'b1;\n      pl_instr_fstage= pl_instr_fstage_d;\n      cpu_state= pl_stall_mem ? STALL_MEM : STALL_MULTDIV;\n      end\n    else\n      begin\n      pl_instr_fstage= (instr_next_d | pmem_branch_ended) &\n                       pmem_cmdok  & !pl_branch_excpt_d ? pmem_cmd : 32'd0;\n      cpu_state= pmem_branch_ended & !pl_branch_excpt_d ? NORMAL : STALL_BRANCH;\n      end\n    end\n  STALL_MEM:\n    begin\n    if(exception | ((pl_stall_eret | pl_stall_branch) & !pl_stall_mem))\n      begin\n      pl_pcpause= 1'b0;\n      if(branch_stall_was_d) pl_cause_bd= 1'b1;\n      instr_next= !pmem_cmdok & !(pl_stall_eret | exception);\n                  pl_instr_fstage= pl_stall_eret | exception | !pmem_cmdok ? 32'd0 :\n                       pmem_cmd;\n      cpu_state= STALL_BRANCH;\n      end\n    else if(pl_stall_mem | pl_stall_multdiv)\n      begin\n      pl_pcpause= 1'b1;\n      pl_instr_fstage= pl_instr_fstage_d;\n      cpu_state= pl_stall_mem ? STALL_MEM : STALL_MULTDIV;\n      end\n    else\n      begin\n      pl_pcpause= 1'b0;\n      pl_instr_fstage= pmem_cmdok ? pmem_cmd : 32'd0;\n      end\n    end\n  STALL_MULTDIV:\n    begin\n    if(exception)\n      begin\n      if(branch_stall_was_d) pl_cause_bd= 1'b1;\n      instr_next= !pmem_cmdok & !(pl_stall_eret | exception);\n                  pl_instr_fstage= pl_stall_eret | exception | !pmem_cmdok ? 32'd0 :\n                       pmem_cmd;\n      cpu_state= STALL_BRANCH;\n      end\n    else\n      begin\n      if(!alu_multdiv_ready)\n        begin\n        pl_pcpause= 1'b1;\n        pl_instr_fstage= pl_instr_fstage_d;\n        cpu_state= STALL_MULTDIV;\n        end\n      else\n        begin\n        pl_pcpause= 1'b0;\n        pl_instr_fstage= pmem_cmdok ? pmem_cmd : 32'd0;\n        end\n      end\n    end\n  endcase\n  end\n\n  always @(posedge clk)\n  begin\n  if(rst)\n    begin\n    instr_next_d<= 1'b0;\n    pl_pcpause_d<= 1'b0;\n    pl_branch_excpt_d<= 1'b0;\n    branch_stall_was_d<= 1'b0;\n    pl_instr_fstage_d<= 32'd0;\n    cpu_state_d<= NORMAL;\n    end\n  else\n    begin\n    instr_next_d<= instr_next;\n    pl_pcpause_d<= pl_pcpause;\n    pl_branch_excpt_d<= pl_branch_excpt;\n    branch_stall_was_d<= branch_stall_was;\n    pl_instr_fstage_d<= pl_instr_fstage;\n    cpu_state_d<= cpu_state;\n    end\n  end\n\n\n\n\nendmodule\n",
        "module_name": "mips_pipeline",
        "module_hash": "5342486a63504a7c9fd4bc8628630669",
        "dataset_index": 1324
      },
      "top__990bf144": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input up_down,\n    input [3:0] load,\n    input SUB,\n    output reg [3:0] Q\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] add_sub_out;\n    \n    up_down_counter udc (\n        .clk(clk),\n        .up_down(up_down),\n        .load(load),\n        .Q(counter_out)\n    );\n    \n    adder_subtractor add_sub (\n        .A(counter_out),\n        .B(load),\n        .SUB(SUB),\n        .Q(add_sub_out)\n    );\n    \n    always @(posedge clk) begin\n        if (load) begin\n            Q <= load;\n        end else begin\n            if (SUB) begin\n                Q <= add_sub_out;\n            end else begin\n                Q <= counter_out;\n            end\n        end\n    end\n    \nendmodule\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    input [3:0] load,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            Q <= load;\n        end else begin\n            if (up_down) begin\n                Q <= Q + 1;\n            end else begin\n                Q <= Q - 1;\n            end\n        end\n    end\n    \nendmodule\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output reg [3:0] Q\n);\n\n    always @(A, B, SUB) begin\n        if (SUB) begin\n            Q <= A - B;\n        end else begin\n            Q <= A + B;\n        end\n    end\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "990bf1447c2ceb1e6a696b5e1c133e20",
        "dataset_index": 19363
      },
      "mig_7series_v2_3_ddr_phy_ocd_mux #_854300f3": {
        "rtl_code": "\n\nmodule mig_7series_v2_3_ddr_phy_ocd_mux #\n  (parameter DQS_CNT_WIDTH   = 3,\n   parameter DQS_WIDTH       = 8,\n   parameter TCQ             = 100)\n  (\n  ktap_at_left_edge, ktap_at_right_edge, mmcm_edge_detect_rdy,\n  po_stg3_incdec, po_en_stg3, po_en_stg23, po_stg23_sel,\n  po_stg23_incdec, po_rdy, wl_po_fine_cnt_sel, oclk_prech_req,\n  clk, rst, ocd_ktap_right, ocd_ktap_left, lim2poc_ktap_right,\n  lim2poc_rdy, ocd_edge_detect_rdy, lim2stg2_inc, lim2stg2_dec,\n  lim2stg3_inc, lim2stg3_dec, ocd2stg2_inc, ocd2stg2_dec,\n  ocd_cntlr2stg2_dec, ocd2stg3_inc, ocd2stg3_dec, wl_po_fine_cnt,\n  oclkdelay_calib_cnt, lim2init_prech_req, ocd_prech_req\n  );\n\n  function integer clogb2 (input integer size); begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction localparam PO_WAIT = 15;\n  localparam POW_WIDTH = clogb2(PO_WAIT);\n  localparam ONE = 1;\n  localparam TWO = 2;\n\n  input clk;\n  input rst;\n\n  input ocd_ktap_right, ocd_ktap_left;\n  input lim2poc_ktap_right;\n  output ktap_at_left_edge, ktap_at_right_edge;\n  assign ktap_at_left_edge = ocd_ktap_left;\n  assign ktap_at_right_edge = lim2poc_ktap_right || ocd_ktap_right;\n  \n  input lim2poc_rdy;\n  input ocd_edge_detect_rdy;\n  output mmcm_edge_detect_rdy;\n  assign mmcm_edge_detect_rdy = lim2poc_rdy || ocd_edge_detect_rdy;\n  \n  output po_stg3_incdec;\n  output po_en_stg3;\n  assign po_stg3_incdec = 1'b0;\n  assign po_en_stg3 = 1'b0;\n\n\n  reg [1:0] po_setup_ns, po_setup_r;\n  always @(posedge clk) po_setup_r <= #TCQ po_setup_ns;\n\n  input lim2stg2_inc;\n  input lim2stg2_dec;\n\n  input lim2stg3_inc;\n  input lim2stg3_dec;\n\n  input ocd2stg2_inc;\n  input ocd2stg2_dec;\n  input ocd_cntlr2stg2_dec;\n  \n  input ocd2stg3_inc;\n  input ocd2stg3_dec;\n\n  wire setup_po = \n       lim2stg2_inc || lim2stg2_dec || lim2stg3_inc || lim2stg3_dec ||\n       ocd2stg2_inc || ocd2stg2_dec || ocd2stg3_inc || ocd2stg3_dec || ocd_cntlr2stg2_dec;\n\n  always @(*) begin\n    po_setup_ns = po_setup_r;\n    if (rst) po_setup_ns = 2'b00;\n    else if (setup_po) po_setup_ns = 2'b11;\n    else if (|po_setup_r) po_setup_ns = po_setup_r - 2'b01;\n  end\n\n  reg po_en_stg23_r;\n  wire po_en_stg23_ns = ~rst && po_setup_r == 2'b01;\n  always @(posedge clk) po_en_stg23_r <= #TCQ po_en_stg23_ns;\n  output po_en_stg23;\n  assign po_en_stg23 = po_en_stg23_r; \n\n  wire sel_stg3 = lim2stg3_inc || lim2stg3_dec || ocd2stg3_inc || ocd2stg3_dec;\n\n  reg [POW_WIDTH-1:0] po_wait_r, po_wait_ns;\n  reg po_stg23_sel_r;\n  wire po_stg23_sel_ns = ~rst && (setup_po \n                                    ? sel_stg3\n                                       ? 1'b1 \n                                       : 1'b0 \n                                    : po_stg23_sel_r && !(po_wait_r == ONE[POW_WIDTH-1:0]));\n  always @(posedge clk) po_stg23_sel_r <= #TCQ po_stg23_sel_ns;\n  output po_stg23_sel;\n  assign po_stg23_sel = po_stg23_sel_r;\n\n  wire po_inc = lim2stg2_inc || lim2stg3_inc || ocd2stg2_inc || ocd2stg3_inc;\n\n  reg po_stg23_incdec_r;\n  wire po_stg23_incdec_ns = ~rst && (setup_po ? po_inc ? 1'b1 : 1'b0 : po_stg23_incdec_r);\n  always @(posedge clk) po_stg23_incdec_r <= #TCQ po_stg23_incdec_ns;\n  output po_stg23_incdec;\n  assign po_stg23_incdec = po_stg23_incdec_r;\n\n\n  always @(posedge clk) po_wait_r <= #TCQ po_wait_ns;\n  always @(*) begin\n    po_wait_ns = po_wait_r;\n    if (rst) po_wait_ns = {POW_WIDTH{1'b0}};\n    else if (po_en_stg23_r) po_wait_ns = PO_WAIT[POW_WIDTH-1:0] - ONE[POW_WIDTH-1:0];\n    else if (po_wait_r != {POW_WIDTH{1'b0}}) po_wait_ns = po_wait_r - ONE[POW_WIDTH-1:0];\t   \n  end\n  \n  wire po_rdy_ns = ~(setup_po || |po_setup_r || |po_wait_ns);\n  reg po_rdy_r;\n  always @(posedge clk) po_rdy_r <= #TCQ po_rdy_ns;\n  \n  output po_rdy;\n  assign po_rdy = po_rdy_r;\n\n  input [6*DQS_WIDTH-1:0] wl_po_fine_cnt;\n  input [DQS_CNT_WIDTH:0] oclkdelay_calib_cnt;\n  wire [6*DQS_WIDTH-1:0] wl_po_fine_shifted = wl_po_fine_cnt >> oclkdelay_calib_cnt*6;\n  output [5:0] wl_po_fine_cnt_sel;\n  assign wl_po_fine_cnt_sel = wl_po_fine_shifted[5:0];\n\n  input lim2init_prech_req;\n  input ocd_prech_req;\n  output oclk_prech_req;\n  assign oclk_prech_req = ocd_prech_req || lim2init_prech_req;\n\t\nendmodule ",
        "module_name": "mig_7series_v2_3_ddr_phy_ocd_mux #",
        "module_hash": "854300f3a27d9d14bbae57b852ae189a",
        "dataset_index": 25857
      },
      "toggle__5373fe90": {
        "rtl_code": "\nmodule toggle_module (\n   input clk,\n   input toggle,\n   input [7:0] cyc_copy,\n   output reg toggle_up\n);\n\n   reg [7:0] cyc_count;\n   reg [7:0] cyc_copy_reg;\n\n   always @(posedge clk) begin\n      if (toggle) begin\n         cyc_count <= 0;\n         cyc_copy_reg <= cyc_copy;\n      end else begin\n         if (cyc_count == cyc_copy_reg) begin\n            toggle_up <= ~toggle_up;\n            cyc_count <= 0;\n         end else begin\n            cyc_count <= cyc_count + 1;\n            cyc_copy_reg <= cyc_copy;\n         end\n      end\n   end\n\nendmodule",
        "module_name": "toggle_",
        "module_hash": "5373fe903f21d7bc3d602f8fa9d4c032",
        "dataset_index": 18252
      },
      "IBUF_IBUFDISABLE_4f47e20d": {
        "rtl_code": "\nmodule IBUF_IBUFDISABLE (O, I, IBUFDISABLE);\n\n    parameter IBUF_LOW_PWR = \"TRUE\";\n    parameter IOSTANDARD = \"DEFAULT\";\n    parameter SIM_DEVICE = \"7SERIES\";\n    parameter USE_IBUFDISABLE = \"TRUE\";\n`ifdef XIL_TIMING\n    parameter LOC = \"UNPLACED\";\n`endif output O;\n\n    input  I;\n    input  IBUFDISABLE;\n\nlocalparam MODULE_NAME = \"IBUF_IBUFDISABLE\";\n\n   wire out_val;\n    initial begin\n\t\n\n        case (IBUF_LOW_PWR)\n\n            \"FALSE\", \"TRUE\" : ;\n            default : begin\n                          $display(\"Attribute Syntax Error : The attribute IBUF_LOW_PWR on IBUF_IBUFDISABLE instance %m is set to %s.  Legal values for this attribute are TRUE or FALSE.\", IBUF_LOW_PWR);\n                          #1 $finish;\n                      end\n\n        endcase\n       if ((SIM_DEVICE != \"7SERIES\") &&\n         (SIM_DEVICE != \"ULTRASCALE\") &&\n         (SIM_DEVICE != \"VERSAL_AI_CORE\") &&\n         (SIM_DEVICE != \"VERSAL_AI_CORE_ES1\") &&\n         (SIM_DEVICE != \"VERSAL_AI_CORE_ES2\") &&\n         (SIM_DEVICE != \"VERSAL_AI_EDGE\") &&\n         (SIM_DEVICE != \"VERSAL_AI_EDGE_ES1\") &&\n         (SIM_DEVICE != \"VERSAL_AI_EDGE_ES2\") &&\n         (SIM_DEVICE != \"VERSAL_AI_RF\") &&\n         (SIM_DEVICE != \"VERSAL_AI_RF_ES1\") &&\n         (SIM_DEVICE != \"VERSAL_AI_RF_ES2\") &&\n         (SIM_DEVICE != \"VERSAL_HBM\") &&\n         (SIM_DEVICE != \"VERSAL_HBM_ES1\") &&\n         (SIM_DEVICE != \"VERSAL_HBM_ES2\") &&\n         (SIM_DEVICE != \"VERSAL_PREMIUM\") &&\n         (SIM_DEVICE != \"VERSAL_PREMIUM_ES1\") &&\n         (SIM_DEVICE != \"VERSAL_PREMIUM_ES2\") &&\n         (SIM_DEVICE != \"VERSAL_PRIME\") &&\n         (SIM_DEVICE != \"VERSAL_PRIME_ES1\") &&\n         (SIM_DEVICE != \"VERSAL_PRIME_ES2\")) begin\n      $display(\"Error: [Unisim %s-104] SIM_DEVICE attribute is set to %s.  Legal values for this attribute are 7SERIES, ULTRASCALE, VERSAL_AI_CORE, VERSAL_AI_CORE_ES1, VERSAL_AI_CORE_ES2, VERSAL_AI_EDGE, VERSAL_AI_EDGE_ES1, VERSAL_AI_EDGE_ES2, VERSAL_AI_RF, VERSAL_AI_RF_ES1, VERSAL_AI_RF_ES2, VERSAL_HBM, VERSAL_HBM_ES1, VERSAL_HBM_ES2, VERSAL_PREMIUM, VERSAL_PREMIUM_ES1, VERSAL_PREMIUM_ES2, VERSAL_PRIME, VERSAL_PRIME_ES1 or VERSAL_PRIME_ES2. Instance: %m\", MODULE_NAME, SIM_DEVICE);\n       #1 $finish;\n    end\n    end\n   generate\n       case (SIM_DEVICE)\n         \"7SERIES\" : begin\n                        assign out_val = 1'b1;\n                     end\n         default : begin\n                        assign out_val = 1'b0;\n                     end\n        endcase\n   endgenerate\n\n    generate\n       case (USE_IBUFDISABLE)\n          \"TRUE\" :  begin\n                        assign O = (IBUFDISABLE == 0)? I : (IBUFDISABLE == 1)? out_val  : 1'bx;\n                    end\n          \"FALSE\" : begin\n                        assign O = I;\n                    end\n       endcase\n    endgenerate\n\n`ifdef XIL_TIMING\n    specify\n\n        (I => O) \t\t= (0:0:0,  0:0:0);\n        (IBUFDISABLE => O)\t= (0:0:0,  0:0:0);\n\n        specparam PATHPULSE$ = 0;\n\n    endspecify\n`endif endmodule\n",
        "module_name": "IBUF_IBUFDISABLE",
        "module_hash": "4f47e20d3844318ce07d91a6cb522d9d",
        "dataset_index": 23411
      },
      "digital_lock_51883203": {
        "rtl_code": "\nmodule digital_lock (\n    input [3:0] code, // 4-digit binary code input\n    output reg open // Output signal indicating whether the lock is open or not\n);\n\n    // Define the stored password\n    reg [3:0] password = 4'b0001;\n\n    // Define the control logic\n    reg state = 1'b0;\n    always @ (code) begin\n        if (code == 4'b0000) state <= ~state;\n    end\n\n    // Define the decoder and multiplexer module\n    wire password_bit;\n    assign password_bit = (state) ? password[0] : password[1];\n\n    // Define the 8-bit adder module\n    reg [7:0] sum;\n    always @ (*) begin\n        sum = {4'b0, code} + {4'b0, password_bit};\n    end\n\n    // Define the output logic\n    always @ (sum) begin\n        if (sum == 8'b00000000) open <= 1'b1;\n        else open <= 1'b0;\n    end\n\nendmodule",
        "module_name": "digital_lock",
        "module_hash": "51883203b6389c649be2259289e01507",
        "dataset_index": 1047
      },
      "dlatch_reset_bfd48760": {
        "rtl_code": "module dlatch_reset (\n    input D,\n    input RESET_B,\n    input GATE,\n    input CLK,\n    output Q,\n    output Q_N\n);\n\n    wire AND1_out;\n    wire AND2_out;\n    wire OR1_out;\n    wire NOT1_out;\n    wire NOT2_out;\n\n    // AND1 gate for GATE and CLK\n    assign AND1_out = GATE & CLK;\n\n    // AND2 gate for NOT GATE and CLK\n    assign AND2_out = ~GATE & CLK;\n\n    // OR1 gate for AND1_out and NOT RESET_B\n    assign OR1_out = AND1_out | ~RESET_B;\n\n    // NOT1 gate for OR1_out\n    assign NOT1_out = ~OR1_out;\n\n    // NOT2 gate for AND2_out\n    assign NOT2_out = ~AND2_out;\n\n    // D-latch with reset behavior\n    reg Q;\n    reg Q_N;\n  \n    always @(posedge CLK or negedge RESET_B)\n    begin\n        if (~RESET_B)\n        begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end\n        else\n        begin\n            Q <= D & GATE;\n            Q_N <= ~(D & GATE);\n        end\n    end\n\nendmodule",
        "module_name": "dlatch_reset",
        "module_hash": "bfd48760bd9fbf8aa0ea8783b28118ac",
        "dataset_index": 5980
      },
      "uart_tx_e076fcd0": {
        "rtl_code": "\n\n\nmodule uart_tx (\n\tinput reset,\n\tinput clk,\n\tinput [1:0] baud_rate,\n\tinput ld_tx_data,\n\tinput [7:0] tx_data,\n\tinput tx_enable,\n\t output reg tx_out,\n\toutput reg tx_empty\n);\n\nparameter ML505 = 0; reg [7:0] tx_reg;\nreg [3:0] tx_cnt;\nreg [9:0] baud_cnt;\nreg baud_clk;\n\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tbaud_clk <= 1'b0;\n\t\tbaud_cnt <= 10'b0;\n\t\ttx_reg        <= 8'd0;\n\t\ttx_empty      <= 1'b1;\n\t\ttx_out        <= 1'b1;\n\t\ttx_cnt        <= 4'd0;\n\tend else begin if (ML505) begin\n\t\t\tif (baud_cnt == 10'd868) begin\n\t\t\t\tbaud_clk <= 1'b1;\n\t\t\t\tbaud_cnt <= 10'd0;\n\t\t\tend else begin\n\t\t\t\tbaud_clk <= 1'b0;\n\t\t\t\tbaud_cnt <= baud_cnt + 1;\n\t\t\tend \n\t\tend else begin\n\t\t\tcase(baud_rate)\n\t\t\t\t2'd0: begin if (baud_cnt == 10'd347) begin\n\t\t\t\t\t\tbaud_clk <= 1'b1;\n\t\t\t\t\t\tbaud_cnt <= 10'd0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tbaud_clk <= 1'b0;\n\t\t\t\t\t\tbaud_cnt <= baud_cnt + 1;\n\t\t\t\t\tend \n\t\t\t\tend\n\t\t\t\t2'd1: begin\n\t\t\t\t\tif (baud_cnt == 10'd174) begin baud_clk <= 1'b1;\n\t\t\t\t\t\tbaud_cnt <= 10'd0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tbaud_clk <= 1'b0;\n\t\t\t\t\t\tbaud_cnt <= baud_cnt + 1;\n\t\t\t\t\tend \n\t\t\t\tend\n\t\t\t\t2'd2: begin\t\n\t\t\t\t\tif (baud_cnt == 10'd87) begin baud_clk <= 1'b1;\n\t\t\t\t\t\tbaud_cnt <= 10'd0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tbaud_clk <= 1'b0;\n\t\t\t\t\t\tbaud_cnt <= baud_cnt + 1;\n\t\t\t\t\tend \n\t\t\t\tend\n\t\t\t\tdefault: begin if (baud_cnt == 10'd347) begin\n\t\t\t\t\t\tbaud_clk <= 1'b1;\n\t\t\t\t\t\tbaud_cnt <= 10'd0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tbaud_clk <= 1'b0;\n\t\t\t\t\t\tbaud_cnt <= baud_cnt + 1;\n\t\t\t\t\tend \n\t\t\t\tend\n\t\t\tendcase\n\t\tend if (tx_enable && baud_clk) begin\n\t\t\tif (ld_tx_data && tx_empty) begin\n\t\t\t\ttx_reg   <= tx_data;\n\t\t\t\ttx_empty <= 1'b0;\n\t\t\t\ttx_out <= 1'b0; tx_cnt <= tx_cnt;\n\t\t\t  end else if (!tx_empty) begin\n\t\t\t\ttx_reg <= tx_reg;\n\t\t\t\tif (tx_cnt == 4'd8) begin\n\t\t\t\t\ttx_cnt <= 4'd0;\n\t\t\t\t\ttx_out <= 1'b1;\n\t\t\t\t\ttx_empty <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\ttx_cnt <= tx_cnt + 1;\n\t\t\t\t\ttx_out <= tx_reg[tx_cnt];\n\t\t\t\t\ttx_empty <= tx_empty;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\ttx_reg <= tx_reg;\n\t\t\t\ttx_cnt <= tx_cnt;\n\t\t\t\ttx_out <= tx_out;\n\t\t\t\ttx_empty <= tx_empty;\n\t\t\tend\n\t\tend else begin\n\t\t\ttx_reg <= tx_reg;\n\t\t\ttx_cnt <= tx_cnt;\n\t\t\ttx_out <= tx_out;\n\t\t\ttx_empty <= tx_empty;\n\t\tend end end endmodule\n",
        "module_name": "uart_tx",
        "module_hash": "e076fcd022bfb11050fce3bf07fc35ab",
        "dataset_index": 11225
      },
      "dff_asr_e8a86942": {
        "rtl_code": "\nmodule dff_asr (\n    input  D,\n    input  CLK,\n    input  SET_B,\n    input  RESET_B,\n    output Q,\n    output Q_N\n);\n\n    reg  Q;\n    assign Q_N = ~Q;\n\n    always @(posedge CLK) begin\n        if (!SET_B) begin\n            Q <= 1'b1;\n        end else if (!RESET_B) begin\n            Q <= 1'b0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "dff_asr",
        "module_hash": "e8a86942063d3ac9f589527fd489c5d4",
        "dataset_index": 13461
      },
      "dectohexstr24_d43eafb6": {
        "rtl_code": "\nmodule dectohexstr24(\n    input [23:0] in,\n    output [127:0] out\n    );\n\n    assign out[127:48] = \"          \";\n    dectohexstr8 dectohexstr8lo\n        (\n        .in(in[7:0]),\n        .out(out[15:0])\n        );\n    dectohexstr8 dectohexstr8mi\n        (\n        .in(in[15:8]),\n        .out(out[31:16])\n        );\n    dectohexstr8 dectohexstr8hi\n        (\n        .in(in[23:16]),\n        .out(out[47:32])\n        );\n        \nendmodule\n\nmodule dectohexstr8(\n    input [7:0] in,\n    output [15:0] out\n    );\n    wire[3:0] inlo;\n    wire[7:4] inhi;\n    assign inlo = in[3:0];\n    assign inhi = in[7:4];\n    \n    assign out[7:0] = (inlo == 4'd0) ? \"0\" :\n                      (inlo == 4'd1) ? \"1\" :\n                      (inlo == 4'd2) ? \"2\" :\n                      (inlo == 4'd3) ? \"3\" :\n                      (inlo == 4'd4) ? \"4\" :\n                      (inlo == 4'd5) ? \"5\" :\n                      (inlo == 4'd6) ? \"6\" :\n                      (inlo == 4'd7) ? \"7\" :\n                      (inlo == 4'd8) ? \"8\" :\n                      (inlo == 4'd9) ? \"9\" :\n                      (inlo == 4'd10) ? \"A\" :\n                      (inlo == 4'd11) ? \"B\" :\n                      (inlo == 4'd12) ? \"C\" :\n                      (inlo == 4'd13) ? \"D\" :\n                      (inlo == 4'd14) ? \"E\" : \"F\";\n\n    assign out[15:8]= (inhi == 4'd0) ? \"0\" :\n                      (inhi == 4'd1) ? \"1\" :\n                      (inhi == 4'd2) ? \"2\" :\n                      (inhi == 4'd3) ? \"3\" :\n                      (inhi == 4'd4) ? \"4\" :\n                      (inhi == 4'd5) ? \"5\" :\n                      (inhi == 4'd6) ? \"6\" :\n                      (inhi == 4'd7) ? \"7\" :\n                      (inhi == 4'd8) ? \"8\" :\n                      (inhi == 4'd9) ? \"9\" :\n                      (inhi == 4'd10) ? \"A\" :\n                      (inhi == 4'd11) ? \"B\" :\n                      (inhi == 4'd12) ? \"C\" :\n                      (inhi == 4'd13) ? \"D\" :\n                      (inhi == 4'd14) ? \"E\" : \"F\";\nendmodule\n",
        "module_name": "dectohexstr24",
        "module_hash": "d43eafb65e928af41d8cf59331c927a5",
        "dataset_index": 18538
      },
      "fifo_buffer_276915d5": {
        "rtl_code": "module fifo_buffer (\n    input clk,\n    input rst,\n    input wr_en,\n    input rd_en,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    output empty,\n    output full,\n    output reg [3:0] count\n);\n\nparameter DEPTH = 16;\nreg [15:0] buffer [0:DEPTH-1];\nreg [3:0] head = 4'b0000;\nreg [3:0] tail = 4'b0000;\nreg [3:0] next_head;\nreg [3:0] next_tail;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        head <= 4'b0000;\n        tail <= 4'b0000;\n        count <= 4'b0000;\n    end else begin\n        next_head = head;\n        next_tail = tail;\n        if (wr_en & ~full) begin\n            buffer[head] <= data_in;\n            next_head = (head == DEPTH-1) ? 4'b0000 : head + 1;\n            count <= count + 1;\n        end\n        if (rd_en & ~empty) begin\n            data_out <= buffer[tail];\n            next_tail = (tail == DEPTH-1) ? 4'b0000 : tail + 1;\n            count <= count - 1;\n        end\n        head <= next_head;\n        tail <= next_tail;\n    end\nend\n\nassign empty = (count == 0);\nassign full = (count == DEPTH);\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "276915d5779f91a56af9cd8c7ee9ae81",
        "dataset_index": 12475
      },
      "SRAM_1R1W_BE #_f3d3ca99": {
        "rtl_code": "module SRAM_1R1W_BE #(\n    parameter ADDR_SZ = 9,\n    parameter DATA_SZ_BYTES = 8,\n    parameter MEM_SZ = 512\n)(\n    input clk,\n    input write_en,\n    input [DATA_SZ_BYTES-1:0] write_bytes,\n    input [ADDR_SZ-1:0] write_addr,\n    input [(DATA_SZ_BYTES*8)-1:0] write_data,\n    input read_en,\n    input [ADDR_SZ-1:0] read_addr,\n    output [(DATA_SZ_BYTES*8)-1:0] read_data\n);\n\n    reg [(DATA_SZ_BYTES*8)-1:0] ram_block [MEM_SZ-1:0];\n    reg [(DATA_SZ_BYTES*8)-1:0] read_data_reg;\n\n    generate\n        genvar i;\n        for (i = 0 ; i < DATA_SZ_BYTES ; i = i+1) begin\n            always @ (posedge clk) begin\n                if (write_en == 1) begin\n                    if (write_bytes[i] == 1) begin\n                        ram_block[write_addr][(i+1)*8-1:i*8] <= write_data[(i+1)*8-1:i*8];\n                    end\n                end\n                if (read_en == 1) begin\n                    read_data_reg[(i+1)*8-1:i*8] <= ram_block[read_addr][(i+1)*8-1:i*8];\n                end\n            end\n        end\n    endgenerate\n\n    assign read_data = read_data_reg;\nendmodule",
        "module_name": "SRAM_1R1W_BE #",
        "module_hash": "f3d3ca994e769ef6fed393cc1876f691",
        "dataset_index": 17607
      },
      "select_internal_bank_address_subfield #_a2f1ff10": {
        "rtl_code": "module select_internal_bank_address_subfield #(\n    parameter NumBnks = 4 // Define NumBnks parameter\n)(\n  input lio_buscfg_brstlen2_sr,\n  input lio_buscfg_brstlen4_sr,\n  input [NumBnks-1:0] m_cdq_haddr_sr,\n  output reg [NumBnks-1:0] ibnk_sel_s\n);\n\n\n  // Define ranges for bank address subfield based on burst length\n  `define DMC_AG_HADDR_BADDR_BST2_RNG 1:0\n  `define DMC_AG_HADDR_BADDR_BST4_RNG 2:1\n  `define DMC_AG_HADDR_BADDR_BST8_RNG 3:2\n\n  // Select internal bank address subfield based on burst length\n  always @*\n    case ({lio_buscfg_brstlen4_sr, lio_buscfg_brstlen2_sr})\n      2'b01: // 2-burst\n        ibnk_sel_s = m_cdq_haddr_sr[`DMC_AG_HADDR_BADDR_BST2_RNG];\n      2'b10: // 4-burst\n        ibnk_sel_s = m_cdq_haddr_sr[`DMC_AG_HADDR_BADDR_BST4_RNG];\n      default: // 8-burst\n        ibnk_sel_s = m_cdq_haddr_sr[`DMC_AG_HADDR_BADDR_BST8_RNG];\n    endcase\n\nendmodule",
        "module_name": "select_internal_bank_address_subfield #",
        "module_hash": "a2f1ff10ee29663023f9bea4a290a8bd",
        "dataset_index": 4646
      },
      "counter_51a2a90c": {
        "rtl_code": "module counter (\n    input CLK,\n    input RST,\n    input UP_DOWN,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 4'b0000;\n        end else begin\n            if (UP_DOWN) begin\n                Q <= Q + 4'b0001;\n            end else begin\n                Q <= Q - 4'b0001;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "51a2a90c4fa221e676d28d8f63c08d38",
        "dataset_index": 10213
      },
      "add4bit_40aa46ac": {
        "rtl_code": "module add4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [4:0] SUM\n);\n\nalways @(*) begin\n    SUM = A + B;\n    if (SUM > 15) begin\n        SUM = SUM + 16;\n        SUM[4] = 1;\n    end else begin\n        SUM[4] = 0;\n    end\nend\n\nendmodule",
        "module_name": "add4bit",
        "module_hash": "40aa46ac5a4c127247c7797477ce738a",
        "dataset_index": 17997
      },
      "crossbar_6a255b14": {
        "rtl_code": "module crossbar (\n  input [3:0] in1,\n  input [3:0] in2,\n  input [3:0] in3,\n  input [3:0] in4,\n  input [1:0] sel1,\n  input [1:0] sel2,\n  output [3:0] out1,\n  output [3:0] out2,\n  output [3:0] out3,\n  output [3:0] out4\n);\n\nassign out1 = {sel1[0] == 0 ? in1 : in2, sel2[0] == 0 ? in3 : in4};\nassign out2 = {sel1[0] == 1 ? in1 : in2, sel2[0] == 1 ? in3 : in4};\nassign out3 = {sel1[1] == 0 ? in1 : in2, sel2[1] == 0 ? in3 : in4};\nassign out4 = {sel1[1] == 1 ? in1 : in2, sel2[1] == 1 ? in3 : in4};\n\nendmodule\n",
        "module_name": "crossbar",
        "module_hash": "6a255b1433f193ab1e0f5c164f839ef6",
        "dataset_index": 19177
      },
      "top__a50802c2": {
        "rtl_code": "\nmodule top_module (\n    input clk, // Clock input\n    input reset, // Synchronous active-high reset\n    input ce, // Clock enable for the counter\n    input ctrl, // Control signal for the counter\n    output reg [11:0] out // 12-bit output from the combined modules\n);\n\nwire [3:0] counter_out;\nwire [15:0] decoder_out;\n\ncounter cnt (\n    .clk(clk),\n    .rst_n(reset),\n    .ce(ce),\n    .ctrl(ctrl),\n    .count(counter_out)\n);\n\ndecoder dec (\n    .SEL(counter_out[1:0]),\n    .OUT(decoder_out)\n);\n\nalways @(*) begin\n    out <= decoder_out[11:0];\nend\n\nendmodule\nmodule counter (\n    input clk,\n    input rst_n,\n    input ce,\n    input ctrl,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge rst_n) begin\n    if (rst_n) begin\n        count <= 4'b0;\n    end else if (ce) begin\n        if (ctrl) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule\nmodule decoder (\n    input [1:0] SEL,\n    output reg [15:0] OUT\n);\n\nalways @(*) begin\n    case (SEL)\n        2'b00: OUT = 16'b0000_0000_0000_0001;\n        2'b01: OUT = 16'b0000_0000_0000_0010;\n        2'b10: OUT = 16'b0000_0000_0000_0100;\n        2'b11: OUT = 16'b0000_0000_0000_1000;\n        default: OUT = 16'b0000_0000_0000_0000;\n    endcase\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "a50802c2c1d34c23139219c1ae77b906",
        "dataset_index": 10839
      },
      "ShiftLeft_e256c9a1": {
        "rtl_code": "module ShiftLeft (\n    input clk,\n    input reset,\n    input [3:0] InVec,\n    input load,\n    input start,\n    output done,\n    output [3:0] OutVec\n);\n\nreg [3:0] reg_InVec;\nreg [1:0] shift_count;\nwire [3:0] shifted_value;\n\nassign done = (shift_count == 2);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        reg_InVec <= 4'b0;\n        shift_count <= 2'b0;\n    end else if (load) begin\n        reg_InVec <= InVec;\n        shift_count <= 2'b0;\n    end else if (start && (shift_count < 2)) begin\n        reg_InVec <= shifted_value;\n        shift_count <= shift_count + 1;\n    end\nend\n\nassign shifted_value = {reg_InVec[1:0], 2'b0};\n\nassign OutVec = (shift_count == 2) ? shifted_value : reg_InVec;\n\nendmodule",
        "module_name": "ShiftLeft",
        "module_hash": "e256c9a1b3a2fae1b648f0a886cd114b",
        "dataset_index": 12268
      },
      "adder_3c878d1a": {
        "rtl_code": "module adder (\n    input [3:0] a,\n    input [3:0] b,\n    input enable,\n    input reset,\n    input clk,\n    output reg [3:0] sum\n);\n\n    reg [3:0] carry;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            sum <= 4'b0;\n            carry <= 4'b0;\n        end\n        else if (enable) begin\n            {carry, sum} <= a + b + carry;\n        end\n        else begin\n            sum <= 4'b0;\n            carry <= 4'b0;\n        end\n    end\n\nendmodule",
        "module_name": "adder",
        "module_hash": "3c878d1a0b00198911b83779a85c4734",
        "dataset_index": 11446
      },
      "word_ee5b22af": {
        "rtl_code": "module word(\n\tinput [4:0] row, col,\n\tinput [1:0] select,\n\toutput word\n);\nreg [19:0] data;\nalways @(row,col,select,data[19:0])\nbegin \n\tcase (select)\n\t\t2'b00: case(row) 5'b00000: data = 20'b00000000000000000000;\n\t\t\t\t5'b00001: data = 20'b00000111111111100000;\n\t\t\t\t5'b00010: data = 20'b00011000000000011000;\n\t\t\t\t5'b00011: data = 20'b00100000000000000100;\n\t\t\t\t5'b00100: data = 20'b01000111000011100010;\n\t\t\t\t5'b00101: data = 20'b01001000100100010010;\n\t\t\t\t5'b00110: data = 20'b01000000000000000010;\n\t\t\t\t5'b00111: data = 20'b01000100000000100010;\n\t\t\t\t5'b01000: data = 20'b00100011111111000100;\n\t\t\t\t5'b01001: data = 20'b00011000000000011000;\n\t\t\t\t5'b01010: data = 20'b00000111111111100000;\n\t\t\t\t5'b01011: data = 20'b00000000000000000000;\n\t\t\t\t5'b01100: data = 20'b00000000000000000000;\n\t\t\t\t5'b01101: data = 20'b00011111000011110000;\n\t\t\t\t5'b01110: data = 20'b00100000000100001000;\n\t\t\t\t5'b01111: data = 20'b00100000001000000100;\n\t\t\t\t5'b10000: data = 20'b00100111101000000100;\n\t\t\t\t5'b10001: data = 20'b00100011000100001000;\n\t\t\t\t5'b10010: data = 20'b00011110000011110000;\n\t\t\t\t5'b10011: data = 20'b00000000000000000000;\n\t\t\t\tdefault: data = 20'bxxxxxxxxxxxxxxxxxxxx;\n\t\t\tendcase\n\t\t2'b01: case(row) 5'b00000: data = 20'b00000000000000000000;\n\t\t\t\t5'b00001: data = 20'b00100011101110111000;\n\t\t\t\t5'b00010: data = 20'b00100010101000100000;\n\t\t\t\t5'b00011: data = 20'b00100010101110111000;\n\t\t\t\t5'b00100: data = 20'b00100010100010100000;\n\t\t\t\t5'b00101: data = 20'b00111011101110111000;\n\t\t\t\t5'b00110: data = 20'b00000000000000000000;\n\t\t\t\t5'b00111: data = 20'b00001110000001110000;\n\t\t\t\t5'b01000: data = 20'b00011111000011111000;\n\t\t\t\t5'b01001: data = 20'b00011111110001111000;\n\t\t\t\t5'b01010: data = 20'b00001111100111110000;\n\t\t\t\t5'b01011: data = 20'b00000011110001100000;\n\t\t\t\t5'b01100: data = 20'b00000001100001000000;\n\t\t\t\t5'b01101: data = 20'b00000000100000000000;\n\t\t\t\t5'b01110: data = 20'b00011110000000000000;\n\t\t\t\t5'b01111: data = 20'b00100000111100100100;\n\t\t\t\t5'b10000: data = 20'b00011100100010100100;\n\t\t\t\t5'b10001: data = 20'b00000010111100011100;\n\t\t\t\t5'b10010: data = 20'b00000010100010000100;\n\t\t\t\t5'b10011: data = 20'b00111100100010011000;\n\t\t\t\tdefault: data = 20'bxxxxxxxxxxxxxxxxxxxx;\n\t\t\tendcase\n\t\t2'b10: case(row) default: data = 20'bxxxxxxxxxxxxxxxxxxxx;\n\t\t       endcase\n\t\t2'b11: case(row) 5'b00000: data = 20'b00000000000000101010;\n\t\t\t\t5'b00001: data = 20'b00001000010000101010;\n\t\t\t\t5'b00010: data = 20'b00111100111100110110;\n\t\t\t\t5'b00011: data = 20'b01100111100110000000;\n\t\t\t\t5'b00100: data = 20'b01000011000110011100;\n\t\t\t\t5'b00101: data = 20'b00110000001100001000;\n\t\t\t\t5'b00110: data = 20'b00011100111000011100;\n\t\t\t\t5'b00111: data = 20'b00000111100000000000;\n\t\t\t\t5'b01000: data = 20'b00000011000000110100;\n\t\t\t\t5'b01001: data = 20'b00000010000000101100;\n\t\t\t\t5'b01010: data = 20'b00000000000000100100;\n\t\t\t\t5'b01011: data = 20'b00111000001110000001;\n\t\t\t\t5'b01100: data = 20'b01000100010001000001;\n\t\t\t\t5'b01101: data = 20'b01000100010001000010;\n\t\t\t\t5'b01110: data = 20'b01000100010001000010;\n\t\t\t\t5'b01111: data = 20'b01000100010001000100;\n\t\t\t\t5'b10000: data = 20'b01000100010001000100;\n\t\t\t\t5'b10001: data = 20'b01000100010001001000;\n\t\t\t\t5'b10010: data = 20'b01000100010001001000;\n\t\t\t\t5'b10011: data = 20'b00111001001110010000;\n\n\n\t\t\t\tdefault: data = 20'bxxxxxxxxxxxxxxxxxxxx;\n\t\t       endcase\n\t\tdefault: data = 20'bxxxxxxxxxxxxxxxxxxxx;\n\tendcase\nend\n\nassign word = data[19-col];\n\nendmodule\n",
        "module_name": "word",
        "module_hash": "ee5b22afca869802f7c445d047696409",
        "dataset_index": 7493
      },
      "priority_encoder_3f9be840": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casex(in)  \n            8'b00000001: pos = 0;\n            8'b00000010: pos = 1;\n            8'b00000100: pos = 2;\n            8'b00001000: pos = 3;\n            8'b00010000: pos = 4;\n            8'b00100000: pos = 5;\n            8'b01000000: pos = 6;\n            8'b10000000: pos = 7;\n            default: pos = 3'b111;\n        endcase\n    end\nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input d,\n    output reg [3:0] q \n);\n    always @(posedge clk or negedge reset) begin\n        if (reset == 1'b0) begin\n            q <= 4'b0000;\n        end else begin\n            q <= {q[2:0], d};\n        end\n    end\nendmodule\nmodule functional_module (\n    input [2:0] pos,\n    input [3:0] shift_reg, \n    output reg out\n);\n    always @(*) begin\n        out = (pos == shift_reg[3:1]); \n    end\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [2:0] pos,\n    input d,\n    output reg [3:0] q, \n    output out\n);\n    priority_encoder pe(in, pos);\n    shift_register sr(clk, reset, d, q);\n    functional_module fm(pos, q, out); \nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "3f9be84027a4112d1b0c83e451ea908e",
        "dataset_index": 6722
      },
      "LUT3_0e136521": {
        "rtl_code": "module LUT3 (\n    input I0,\n    input I1,\n    input I2,\n    output O\n);\n\n    assign O = ~(I0 & I1 & I2);\n\nendmodule\n\nmodule mux (\n    input ctrl,\n    input D0,\n    input D1,\n    output S\n);\n\n    wire [2:0] lut_input;\n    wire lut_output;\n\n    assign lut_input[0] = D1;\n    assign lut_input[1] = ctrl;\n    assign lut_input[2] = D0;\n\n    LUT3 lut (\n        .I0(lut_input[0]),\n        .I1(lut_input[1]),\n        .I2(lut_input[2]),\n        .O(lut_output)\n    );\n\n    assign S = lut_output;\n\nendmodule",
        "module_name": "LUT3",
        "module_hash": "0e136521386b7eb5dac1913d127766b0",
        "dataset_index": 1512
      },
      "module1_32f7ed9a": {
        "rtl_code": "\nmodule module1 (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q1\n);\n\n// Register for storing the input data\nreg [7:0] d_r;\n\n// Register for storing the output data\nreg [7:0] q1_r;\n\n// Register for storing the reversed output data\nreg [7:0] q1_reversed;\n\nalways @(negedge clk) begin\n    // Trigger the control logic module on the negative edge of clk\n    if (reset) begin\n        d_r <= 8'b0;\n        q1_r <= 8'b0;\n        q1_reversed <= 8'b0;\n    end else begin\n        d_r <= d;\n        q1_r <= {q1_r[6], q1_r[5], q1_r[4], q1_r[3], q1_r[2], q1_r[1], q1_r[0], d_r[7]};\n        q1_reversed <= {q1_r[7], q1_r[6], q1_r[5], q1_r[4], q1_r[3], q1_r[2], q1_r[1], q1_r[0]};\n    end\nend\n\n// Output the reversed output data\nassign q1 = q1_reversed;\n\nendmodule\n\nmodule module2 (\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [7:0] q2\n);\n\n// Register for storing the input data\nreg [7:0] in_r;\n\n// Register for storing the output data\nreg [7:0] q2_r;\n\nalways @(negedge clk) begin\n    // Trigger the control logic module on the negative edge of clk\n    if (reset) begin\n        in_r <= 8'b0;\n        q2_r <= 8'b0;\n    end else begin\n        in_r <= in;\n        q2_r <= {q2_r[6], q2_r[5], q2_r[4], q2_r[3], q2_r[2], q2_r[1], q2_r[0], in_r[7]};\n    end\nend\n\n// Output the output data\nassign q2 = q2_r;\n\nendmodule\n",
        "module_name": "module1",
        "module_hash": "32f7ed9a1e5230b896a39452ea72d960",
        "dataset_index": 19496
      },
      "my_logic_e5f82bf2": {
        "rtl_code": "module my_logic (\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n\n    always @(*) begin\n        case (data_in)\n            4'b0000: data_out = 4'b0000;\n            4'b0001: data_out = 4'b1111;\n            4'b0010: data_out = 4'b0101;\n            4'b0011: data_out = 4'b1010;\n            4'b0100: data_out = 4'b0011;\n            4'b0101: data_out = 4'b1100;\n            4'b0110: data_out = 4'b0110;\n            4'b0111: data_out = 4'b1001;\n            4'b1000: data_out = 4'b1110;\n            4'b1001: data_out = 4'b0001;\n            4'b1010: data_out = 4'b1101;\n            4'b1011: data_out = 4'b0010;\n            4'b1100: data_out = 4'b1000;\n            4'b1101: data_out = 4'b0111;\n            4'b1110: data_out = 4'b1011;\n            4'b1111: data_out = 4'b0100;\n            default: data_out = 4'bxxxx;\n        endcase\n    end\n\nendmodule",
        "module_name": "my_logic",
        "module_hash": "e5f82bf235b55f03b2fe828d943011c7",
        "dataset_index": 9351
      },
      "up_down_counter_4bit_8f19fb29": {
        "rtl_code": "module up_down_counter_4bit (\n    input clk,\n    input Up,\n    input Down,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (Up) begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end else if (Down) begin\n            if (Q == 4'b0000) begin\n                Q <= 4'b1111;\n            end else begin\n                Q <= Q - 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter_4bit",
        "module_hash": "8f19fb299ebe5d832d838d85449af4f1",
        "dataset_index": 17838
      },
      "PWM_f0d6d617": {
        "rtl_code": "\nmodule PWM (\n  input clk,\n  input [7:0] ctrl,\n  input [15:0] period,\n  output reg pwm_out\n);\n\n  reg [15:0] count;\n  reg [7:0] duty_cycle;\n\n  always @(posedge clk) begin\n    count <= count + 1;\n    if (count >= period) begin\n      count <= 0;\n    end\n    pwm_out <= (count < duty_cycle);\n  end\n\n  always @(posedge clk) begin\n    duty_cycle <= ctrl;\n  end\n\nendmodule\n",
        "module_name": "PWM",
        "module_hash": "f0d6d6173dc54e58a4d48bdaf176f5ec",
        "dataset_index": 15232
      },
      "four_bit_adder_8d0f08e0": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S\n);\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B + Cin;\n\n    assign S = temp_sum[3:0];\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "8d0f08e0170f9b6809826da11bb8444f",
        "dataset_index": 1494
      },
      "top__c4aecf0f": {
        "rtl_code": "module top_module (\n    input clk,\n    input rst_n,\n    input write_en,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] final_output\n);\n\nreg [3:0] ram [7:0];\nreg [7:0] write_ptr;\nreg [7:0] read_ptr;\nreg [3:0] ram_out1;\nreg [3:0] ram_out2;\nreg [3:0] mux_out;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        write_ptr <= 0;\n        read_ptr <= 0;\n    end else begin\n        if (write_en) begin\n            ram[write_addr] <= write_data;\n            write_ptr <= write_ptr + 1;\n        end\n        if (read_en) begin\n            ram_out1 <= ram[read_addr];\n            read_ptr <= read_ptr + 1;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    case (sel)\n        3'b000: mux_out <= data0;\n        3'b001: mux_out <= data1;\n        3'b010: mux_out <= data2;\n        3'b011: mux_out <= data3;\n        3'b100: mux_out <= data4;\n        3'b101: mux_out <= data5;\n        default: mux_out <= (data0 & 3'b11) & (data1 & 3'b11) & (data2 & 3'b11) & (data3 & 3'b11) & (data4 & 3'b11) & (data5 & 3'b11);\n    endcase\nend\n\nalways @(posedge clk) begin\n    ram_out2 <= ram[read_ptr];\n    final_output <= ram_out1 | ram_out2 | mux_out;\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "c4aecf0ff9d130469b6c56e7547868a0",
        "dataset_index": 9835
      },
      "GrayCounter_74cf5071": {
        "rtl_code": "\nmodule GrayCounter(\n    input clk,\n    input incdec,\n    input stop,\n    input rst,\n    output [7:0] gray,\n    output [7:0] normal\n);\n\n    parameter CLK_DIV = 17_000_000;\n    reg [31:0] clkDiv = 32'd0;\n\n    reg [7:0] curGray;\n    reg [7:0] curNum;\n\n    assign gray = curGray;\n    assign normal = curNum;\n\n    always @(posedge clk)\n    begin\n        // increment the clock divider\n        clkDiv = clkDiv + 1;\n\n        // reset and run control\n        if (rst == 1) begin\n            clkDiv <= 0;\n            curNum <= 0;\n        end else if (stop == 1)\n            clkDiv <= clkDiv - 1;\n        else if (clkDiv == CLK_DIV)\n        begin\n            // first, reset the clock divider\n            clkDiv <= 0;\n\n            // use the inc/dec input\n            if (incdec == 1)\n                curNum <= curNum + 1;\n            else\n                curNum <= curNum - 1;\n        end\n\n        curGray <= curNum ^ (curNum >> 1);\n    end\n\nendmodule\n",
        "module_name": "GrayCounter",
        "module_hash": "74cf5071ab1d819e8d6a5916dbf93232",
        "dataset_index": 20736
      },
      "up_down_counter_4bit_03085f2a": {
        "rtl_code": "module up_down_counter_4bit (\n    input clk,\n    input up_down,\n    input load,\n    input en,\n    input [3:0] data_in,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (en) begin\n            if (load) begin\n                out <= data_in;\n            end else begin\n                if (up_down) begin\n                    out <= out + 1;\n                end else begin\n                    out <= out - 1;\n                end\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter_4bit",
        "module_hash": "03085f2a148fc4e7edebdd236cf0caf9",
        "dataset_index": 17575
      },
      "bitwise_logic_02c19705": {
        "rtl_code": "module bitwise_logic (\n  input A,\n  input B,\n  input [1:0] SEL,\n  output C\n);\n\n  // Define logical operators based on SEL input signal\n  wire AND = A & B;\n  wire OR = A | B;\n  wire XOR = A ^ B;\n  wire NOT = ~A;\n\n  // Compute output signal C based on input signals A and B and SEL control signal\n  assign C = (SEL == 0) ? AND :\n            (SEL == 1) ? OR :\n            (SEL == 2) ? XOR :\n            (SEL == 3) ? NOT :\n            1'bx; // default value for invalid SEL input\n\nendmodule",
        "module_name": "bitwise_logic",
        "module_hash": "02c197054b640f95c0bc56f0ed722a28",
        "dataset_index": 12989
      },
      "tone_detection_generation_086b03a8": {
        "rtl_code": "module tone_detection_generation (\n  input clk,\n  input reset,\n  input in,\n  input freq,\n  output reg det,\n  output reg gen\n);\n\n  reg [31:0] phase_acc = 0;\n  reg [31:0] phase_inc = 0;\n  reg [31:0] tone = 0;\n  reg [31:0] threshold = 0;\n  reg [31:0] sample_count = 0;\n  reg [31:0] sample_rate = 48000;\n  reg [31:0] sample_period = 0;\n  reg [31:0] sample_threshold = 0;\n  reg det_flag = 0;\n  reg gen_flag = 0;\n  reg gen_en = 0;\n  reg [31:0] in_sample = 0;\n  reg [31:0] gen_sample = 0;\n\n  always @ (posedge clk) begin\n    if (reset) begin\n      phase_acc <= 0;\n      phase_inc <= 0;\n      tone <= 0;\n      threshold <= 0;\n      sample_count <= 0;\n      sample_period <= 0;\n      sample_threshold <= 0;\n      det_flag <= 0;\n      gen_flag <= 0;\n      gen_en <= 0;\n    end else begin\n      in_sample <= in;\n\n      if (freq > 0) begin\n        phase_inc <= ((freq << 32) / sample_rate);\n        tone <= $unsigned($signed(phase_acc[31]) ? ~32'h0 : 32'h0);\n        phase_acc <= phase_acc + phase_inc;\n      end else begin\n        phase_acc <= 0;\n        tone <= 0;\n      end\n\n      if (det_flag) begin\n        if (in_sample > threshold) begin\n          sample_count <= sample_count + 1;\n        end else begin\n          sample_count <= 0;\n        end\n\n        if (sample_count >= sample_period) begin\n          det_flag <= 0;\n          det <= 1;\n        end else begin\n          det <= 0;\n        end\n      end else begin\n        if (in_sample > threshold) begin\n          sample_count <= sample_count + 1;\n        end else begin\n          sample_count <= 0;\n        end\n\n        if (sample_count >= sample_threshold) begin\n          det_flag <= 1;\n          sample_period <= sample_count;\n          sample_count <= 0;\n          threshold <= in_sample;\n        end\n      end\n\n      if (gen_flag) begin\n        if (gen_en) begin\n          gen_sample <= tone;\n        end else begin\n          gen_sample <= 0;\n        end\n      end else begin\n        gen_sample <= 0;\n      end\n\n      if (freq > 0) begin\n        gen_en <= 1;\n      end else begin\n        gen_en <= 0;\n      end\n\n      if (gen_en) begin\n        tone <= $unsigned($signed(phase_acc[31]) ? ~32'h0 : 32'h0);\n        phase_acc <= phase_acc + phase_inc;\n      end else begin\n        tone <= 0;\n        phase_acc <= 0;\n      end\n\n      if (gen_en) begin\n        gen_flag <= 1;\n        gen <= gen_sample;\n      end else begin\n        gen_flag <= 0;\n        gen <= 0;\n      end\n    end\n  end\nendmodule",
        "module_name": "tone_detection_generation",
        "module_hash": "086b03a83402614bdea6e10b078be85e",
        "dataset_index": 7838
      },
      "altpcie_pclk_align_ef3dc3a9": {
        "rtl_code": "module altpcie_pclk_align\n(\nrst,\nclock,\noffset,\nonestep,\nonestep_dir,\nPCLK_Master,\nPCLK_Slave,\nPhaseUpDown,\nPhaseStep,\nPhaseDone,\nAlignLock,\nPhaseDone_reg,\ncompout_reg,\npcie_sw_in,\npcie_sw_out\n\n);\n\n\ninput rst;\ninput clock;\ninput [7:0] offset;\ninput \t    onestep;\ninput \t    onestep_dir;\ninput PCLK_Master;\ninput PCLK_Slave;\ninput PhaseDone;\noutput PhaseUpDown;\noutput PhaseStep;\noutput AlignLock;\noutput PhaseDone_reg;\noutput compout_reg;\ninput  pcie_sw_in;\noutput pcie_sw_out;\n\nreg    PhaseUpDown;\nreg    PhaseStep;\nreg    AlignLock;\n\nwire   PhaseDone_reg = 0;\nwire   compout_reg = 0;\n\n\nlocalparam DREG_SIZE = 128;\nlocalparam BIAS_ONE = 1;\n\n\nreg [3:0] align_sm;\nlocalparam INIT = 0;\nlocalparam EVAL = 1;\nlocalparam ADVC = 2;\nlocalparam DELY = 3;\nlocalparam BACK = 4;\nlocalparam ERR = 5;\nlocalparam DONE = 6;\nlocalparam MNUL = 7;\nreg [4 * 8 -1 :0] align_sm_txt;\nalways@(align_sm)\n  case(align_sm)\n  INIT: align_sm_txt = \"init\";\n  EVAL: align_sm_txt = \"eval\";\n  ADVC: align_sm_txt = \"advc\";\n  DELY: align_sm_txt = \"dely\";\n  BACK: align_sm_txt = \"back\";\n  ERR: align_sm_txt = \"err\";\n  DONE: align_sm_txt = \"done\";\n  MNUL: align_sm_txt = \"mnul\";\n  endcase\n\n\nreg [DREG_SIZE-1: 0] delay_reg;\ninteger \t     i;\nreg \t\t     all_zero;\nreg \t\t     all_one;\nreg \t\t     chk_req;\nwire \t\t     chk_ack;\nreg [7:0] \t     chk_cnt;\nreg \t\t     chk_ack_r;\nreg \t\t     chk_ack_rr;\nreg \t\t     chk_ok;\n\nreg \t\t     found_zero; reg \t\t     found_meta; reg \t\t     found_one; reg [7:0] \t     window_cnt; reg \t\t     clr_window_cnt;\nreg \t\t     inc_window_cnt;\nreg \t\t     dec_window_cnt;\nreg \t\t     half_window_cnt;\nreg [1:0]\t     retrain_cnt;\nreg \t\t     pcie_sw_r;\nreg \t\t     pcie_sw_rr;\nreg \t\t     pcie_sw_out;\n\nassign \t\t     chk_ack = chk_cnt[7];\n\nalways @ (posedge PCLK_Master or posedge rst)\n  begin\n  if (rst)\n    begin\n    delay_reg <= {DREG_SIZE{1'b0}};\n    all_zero <= 1'b1;\n    all_one <= 1'b0;\n    chk_cnt <= 0;\n    end\n  \n  else\n    begin\n    delay_reg[0] <= PCLK_Slave;\n    for (i = 1; i < DREG_SIZE; i = i + 1)\n      delay_reg[i] <= delay_reg[i-1];\n\n    if (chk_cnt == 8'h80)\n      begin\n      all_zero <= ~|delay_reg[DREG_SIZE-1:2];\n      all_one <= &delay_reg[DREG_SIZE-1:2];\n      end\n\n\n    if (chk_req & (chk_cnt == 8'h8f))\n      chk_cnt <= 0;\n\telse if (chk_cnt == 8'h8f)\n      chk_cnt <= chk_cnt;\n    else\n      chk_cnt <= chk_cnt + 1;\n\n    end\n  end\n\n\nalways @ (posedge clock or posedge rst)\n  begin\n  if (rst)\n    begin\n    align_sm <= INIT;\n    chk_req <= 0;\n    chk_ack_r <= 0;\n    chk_ack_rr <= 0;\n    chk_ok <= 0;\n    found_zero <= 0;\n    found_meta <= 0;\n    found_one <= 0;\n    PhaseUpDown <= 0;\n    PhaseStep <= 0;\n    window_cnt <= 8'h00;\n    clr_window_cnt <= 0;\n    inc_window_cnt <= 0;\n    dec_window_cnt <= 0;\n    half_window_cnt <= 0;\n    AlignLock <= 0;\n    retrain_cnt <= 0;\n    end\n  else\n    begin\n\n    chk_ack_r <= chk_ack;\n    chk_ack_rr <= chk_ack_r;\n\n    if ((chk_ack_rr == 0) & (chk_ack_r == 1))\n      chk_ok <= 1;\n    else\n      chk_ok <= 0;\n\n    if (align_sm == DONE)\n      AlignLock <= 1'b1;\n\n    if (clr_window_cnt)\n      window_cnt <= offset;\n    else if (window_cnt == 8'hff)\n      window_cnt <= window_cnt;\n    else if (inc_window_cnt)\n      window_cnt <=  window_cnt + 1;\n    else if (dec_window_cnt & (window_cnt > 0))\n      window_cnt <=  window_cnt - 1;\n    else if (half_window_cnt)\n      window_cnt <= {1'b0,window_cnt[7:1]};\n\n    if (retrain_cnt == 2'b11)\n      retrain_cnt <= retrain_cnt;\n    else if (align_sm == ERR)\n      retrain_cnt <= retrain_cnt + 1;\n\n    case (align_sm)\n\n    INIT:\n      begin\n      chk_req <= 1;\n      align_sm <= EVAL;\n      clr_window_cnt <= 1;\n\t  \n\t  found_zero <= 0;\n      found_meta <= 0;\n      found_one <= 0;\n      end\n\n    EVAL:\n      if (chk_ok)\n\tbegin\n\tchk_req <= 0;\n\tclr_window_cnt <= 0;\n\tcasex ({found_zero,found_meta,found_one})\n\t3'b000 : begin\n\t  if (all_zero)\n\t    begin\n\t    found_zero <= 1;\n\t    PhaseUpDown <= 0;\n\t    PhaseStep <= 1;\n\t    align_sm <= ADVC;\n\t    end\n\t  else if (all_one)\n\t    begin\n\t    found_one <= 1;\n\t    PhaseUpDown <= 1;\n\t    PhaseStep <= 1;\n\t    align_sm <= DELY;\n\t    end\n\t  else\n\t    begin\n\t    found_meta <= 1;\n\t    PhaseUpDown <= 0;\n\t    PhaseStep <= 1;\n\t    align_sm <= ADVC;\n\t    end\n\t  end\n\n\t3'b010 : begin\n\t  if (all_zero)\n\t    begin\n\t    found_zero <= 1;\t\n\t\tPhaseUpDown <= 0;\n\t    PhaseStep <= 0;\n\t    align_sm <= INIT;\n\t    inc_window_cnt <= 0;\n\t    end\n\t  else\n\t    begin\n\t    PhaseUpDown <= 1;\n\t    PhaseStep <= 1;\n\t    align_sm <= DELY;\n\t    end\n\t  end\n\n\t3'b110 : begin\n\t  if (all_one)\n\t    begin\n\t    found_one <= 1;\n\t    PhaseStep <= 1;\n\t    align_sm <= BACK;\n\t    if (BIAS_ONE)\n\t      begin\n\t      clr_window_cnt <= 1;\n\t      PhaseUpDown <= 0;\n\t      end\n\t    else\n\t      begin\n\t      PhaseUpDown <= 1;\n\t      half_window_cnt <= 1;\n\t      end\n\t    end\n\t  else\n\t    begin\n\t    PhaseUpDown <= 0;\n\t    PhaseStep <= 1;\n\t    align_sm <= ADVC;\n\t    inc_window_cnt <= 1;\n\t    end\n\t  end\n\n\t3'b100 : begin\n\t  PhaseUpDown <= 0;\n\t  PhaseStep <= 1;\n\t  align_sm <= ADVC;\n\t  if (all_zero == 0) begin\n\t    found_meta <= 1;\n\t    inc_window_cnt <= 1;\t    \n\t    end\n\t  end\n\n\t3'b001 : begin\n\t  PhaseUpDown <= 1;\n\t  PhaseStep <= 1;\n\t  align_sm <= DELY;\n\t  if (all_one == 0) begin\n\t    found_meta <= 1;\n\t    inc_window_cnt <= 1;\t    \n\t    end\n\t  end\n\n\n\t3'b011 : begin\n\t  if (all_zero)\n\t    begin\n\t    found_zero <= 1;\n\t\tPhaseStep <= 0;\n\t    PhaseUpDown <= 0;\n\t    align_sm <= INIT;\n\t\t\n\t    if (BIAS_ONE == 0) half_window_cnt <= 1;\n\t    else\n\t      inc_window_cnt <= 1;\n\t    end\n\t  else\n\t    begin\n\t    PhaseUpDown <= 1;\n\t    PhaseStep <= 1;\n\t    align_sm <= DELY;\n\t    inc_window_cnt <= 1;\n\t    end\n\t  end\n\n\t3'b111 : begin\n\t  if (window_cnt > 0)\n\t    begin\n\t    PhaseStep <= 1;\n\t    align_sm <= BACK;\n\t    dec_window_cnt <= 1;\n\t    end\n\t  else\n\t    align_sm <= DONE;\n\n\t  end\n\n\t3'b101 : begin\n\t  align_sm <= ERR;\n\t  clr_window_cnt <= 1;\n\t  found_zero <= 0;\n\t  found_one <= 0;\n\t  found_meta <= 0;\n\t  end\n\n\tendcase\n\tend\n\n    ADVC:\n      begin\n      inc_window_cnt <= 0;\n      if (PhaseDone == 0)\n\tbegin\n\tPhaseStep <= 0;\n\tchk_req <= 1;\n\talign_sm <= EVAL;\n\tend\n      end\n\n    DELY:\n      begin\n      inc_window_cnt <= 0;\n      if (PhaseDone == 0)\n\tbegin\n\tPhaseStep <= 0;\n\tchk_req <= 1;\n\talign_sm <= EVAL;\n\tend\n      end\n\n\n    BACK:\n      begin\n      half_window_cnt <= 0;\n      dec_window_cnt <= 0;\n      inc_window_cnt <= 0;\n      clr_window_cnt <= 0;\n      if (PhaseDone == 0)\n\tbegin\n\tPhaseStep <= 0;\n\tchk_req <= 1;\n\talign_sm <= EVAL;\n\tend\n      end\n\n    DONE:\n      begin\n\t  if (chk_ok)\n\t\tchk_req <= 0;\n\t\t\t\t\n      if (onestep) begin\n\talign_sm <= MNUL;\n\tPhaseStep <= 1;\n\tPhaseUpDown <= onestep_dir;\n\tend\n      end\n\n    MNUL:\n      if (PhaseDone == 0)\n\tbegin\n\tPhaseStep <= 0;\n\tchk_req <= 1;\n\talign_sm <= DONE;\n\tend\n      \n    ERR:\n      begin\n      clr_window_cnt <= 0;\n      align_sm <= INIT;\n      end\n\n    default:\n      align_sm <= INIT;\n\n    endcase\n    end\n  end\n\nalways @ (posedge PCLK_Master or posedge rst)\n  begin\n  if (rst)\n    begin\n    pcie_sw_r <= 0;\n    pcie_sw_rr <= 0;\n    pcie_sw_out <= 0;\n    end\n  else\n    begin\n    pcie_sw_r <= pcie_sw_in;\n    pcie_sw_rr <= pcie_sw_r;\n    pcie_sw_out <= pcie_sw_rr;\n    end\n  end\nendmodule\n",
        "module_name": "altpcie_pclk_align",
        "module_hash": "ef3dc3a94000f4273f58383185e5a162",
        "dataset_index": 24792
      },
      "half_full_adder_13fbf472": {
        "rtl_code": "\nmodule half_full_adder (\n  input A,\n  input B,\n  input carry_in,\n  output sum,\n  output carry_out\n);\n\n  // Instantiate Half Adder\n  wire sum_int;\n  wire carry_int;\n  half_adder HA (\n    .A(A),\n    .B(B),\n    .sum(sum_int),\n    .carry(carry_int)\n  );\n\n  // Instantiate Full Adder\n  assign sum = sum_int ^ carry_in;\n  assign carry_out = carry_int | (sum_int & carry_in);\n\nendmodule\nmodule half_adder (\n  input A,\n  input B,\n  output sum,\n  output carry\n);\n\n  assign sum = A ^ B;\n  assign carry = A & B;\n\nendmodule\nmodule full_adder (\n  input A,\n  input B,\n  input carry_in,\n  output sum,\n  output carry_out\n);\n\n  assign sum = A ^ B ^ carry_in;\n  assign carry_out = (A & B) | (B & carry_in) | (A & carry_in);\n\nendmodule",
        "module_name": "half_full_adder",
        "module_hash": "13fbf472c24481504a86ebb563253f55",
        "dataset_index": 15234
      },
      "ERROR_OUTPUT_LOGIC #_4dd9229e": {
        "rtl_code": "module ERROR_OUTPUT_LOGIC #(\n    parameter [7:0] DATA_WIDTH = 1,\n    parameter [7:0] ADDR_WIDTH = 6\n) (\n    input rst,\n    input clk,\n\n    input loop_complete,\n    input error_detected,\n    input [7:0] error_state,\n    input [ADDR_WIDTH-1:0] error_address,\n    input [DATA_WIDTH-1:0] expected_data,\n    input [DATA_WIDTH-1:0] actual_data,\n\n    input tx_data_accepted,\n    output reg tx_data_ready,\n    output reg [7:0] tx_data\n);\n    reg reg_error_detected;\n    reg [7:0] reg_error_state;\n    reg [ADDR_WIDTH-1:0] reg_error_address;\n    reg [DATA_WIDTH-1:0] reg_expected_data;\n    reg [DATA_WIDTH-1:0] reg_actual_data;\n\n    reg [7:0] error_count;\n    reg [7:0] output_shift;\n\n    wire [7:0] next_output_shift = output_shift + 8;\n    wire count_shift_done = next_output_shift >= 8'd16;\n    wire address_shift_done = next_output_shift >= ADDR_WIDTH;\n    wire data_shift_done = next_output_shift >= DATA_WIDTH;\n\n    reg loop_ready;\n    reg [7:0] latched_error_count;\n\n    reg [7:0] errors;\n    reg [10:0] state;\n    reg [15:0] loop_count;\n    reg [15:0] latched_loop_count;\n\n    localparam START = (1 << 0),\n        ERROR_COUNT_HEADER = (1 << 1),\n        ERROR_COUNT_COUNT = (1 << 2),\n        CR = (1 << 3),\n        LF = (1 << 4),\n        ERROR_HEADER = (1 << 5),\n        ERROR_STATE = (1 << 6),\n        ERROR_ADDRESS = (1 << 7),\n        ERROR_EXPECTED_DATA = (1 << 8),\n        ERROR_ACTUAL_DATA = (1 << 9),\n        LOOP_COUNT = (1 << 10);\n\n    initial begin\n        tx_data_ready <= 1'b0;\n        tx_data <= 8'b0;\n        state <= START;\n        reg_error_detected <= 1'b0;\n    end\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state <= START;\n            error_count <= 0;\n            reg_error_detected <= 0;\n            tx_data_ready <= 0;\n            tx_data <= 8'b0;\n            loop_count <= 0;\n            loop_ready <= 0;\n        end else begin\n\n            if(error_detected) begin\n                if(error_count < 255) begin\n                    error_count <= error_count + 1;\n                end\n\n                if(!reg_error_detected) begin\n                    reg_error_detected <= 1;\n                    reg_error_state <= error_state;\n                    reg_error_address <= error_address;\n                    reg_expected_data <= expected_data;\n                    reg_actual_data <= actual_data;\n                end\n            end\n\n            if(tx_data_accepted) begin\n                tx_data_ready <= 0;\n            end\n\n            if(loop_complete) begin\n                loop_count <= loop_count + 1;\n                if(!loop_ready) begin\n                    loop_ready <= 1;\n                    latched_error_count <= error_count;\n                    latched_loop_count <= loop_count;\n                    error_count <= 0;\n                end\n            end\n\n            case(state)\n                START: begin\n                    if(reg_error_detected) begin\n                        state <= ERROR_HEADER;\n                    end else if(loop_ready) begin\n                        state <= ERROR_COUNT_HEADER;\n                    end\n                end\n                ERROR_COUNT_HEADER: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= \"L\";\n                        tx_data_ready <= 1;\n                        state <= ERROR_COUNT_COUNT;\n                    end\n                end\n                ERROR_COUNT_COUNT: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= latched_error_count;\n                        tx_data_ready <= 1;\n                        output_shift <= 0;\n                        state <= LOOP_COUNT;\n                    end\n                end\n                LOOP_COUNT: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (latched_loop_count >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(count_shift_done) begin\n                            output_shift <= 0;\n                            loop_ready <= 0;\n                            state <= CR;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                CR: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= 8'h0D; tx_data_ready <= 1;\n                        state <= LF;\n                    end\n                end\n                LF: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= 8'h0A; tx_data_ready <= 1;\n                        state <= START;\n                    end\n                end\n                ERROR_HEADER: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= \"E\";\n                        tx_data_ready <= 1;\n                        state <= ERROR_STATE;\n                    end\n                end\n                ERROR_STATE: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= reg_error_state;\n                        tx_data_ready <= 1;\n                        output_shift <= 0;\n                        state <= ERROR_ADDRESS;\n                    end\n                end\n                ERROR_ADDRESS: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_error_address >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(address_shift_done) begin\n                            output_shift <= 0;\n                            state <= ERROR_EXPECTED_DATA;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                ERROR_EXPECTED_DATA: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_expected_data >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(data_shift_done) begin\n                            output_shift <= 0;\n                            state <= ERROR_ACTUAL_DATA;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                ERROR_ACTUAL_DATA: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_actual_data >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(data_shift_done) begin\n                            state <= CR;\n                            reg_error_detected <= 0;\n                        end else begin\n                            output_shift <= output_shift + 8;\n                        end\n                    end\n                end\n                default: begin\n                    state <= START;\n                end\n            endcase\n        end\n    end\nendmodule\n",
        "module_name": "ERROR_OUTPUT_LOGIC #",
        "module_hash": "4dd9229e9530d9095add8533bbbc8cbe",
        "dataset_index": 22935
      },
      "axis_demux #_87751e1c": {
        "rtl_code": "\n\n\nmodule axis_demux #\n(\n    parameter M_COUNT = 4,\n    parameter DATA_WIDTH = 8,\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    parameter KEEP_WIDTH = (DATA_WIDTH/8),\n    parameter ID_ENABLE = 0,\n    parameter ID_WIDTH = 8,\n    parameter DEST_ENABLE = 0,\n    parameter DEST_WIDTH = 8,\n    parameter USER_ENABLE = 1,\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                          clk,\n    input  wire                          rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]         s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]         s_axis_tkeep,\n    input  wire                          s_axis_tvalid,\n    output wire                          s_axis_tready,\n    input  wire                          s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]           s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]         s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]         s_axis_tuser,\n\n    \n    output wire [M_COUNT*DATA_WIDTH-1:0] m_axis_tdata,\n    output wire [M_COUNT*KEEP_WIDTH-1:0] m_axis_tkeep,\n    output wire [M_COUNT-1:0]            m_axis_tvalid,\n    input  wire [M_COUNT-1:0]            m_axis_tready,\n    output wire [M_COUNT-1:0]            m_axis_tlast,\n    output wire [M_COUNT*ID_WIDTH-1:0]   m_axis_tid,\n    output wire [M_COUNT*DEST_WIDTH-1:0] m_axis_tdest,\n    output wire [M_COUNT*USER_WIDTH-1:0] m_axis_tuser,\n\n    \n    input  wire                          enable,\n    input  wire                          drop,\n    input  wire [$clog2(M_COUNT)-1:0]    select\n);\n\nparameter CL_M_COUNT = $clog2(M_COUNT);\n\nreg [CL_M_COUNT-1:0] select_reg = {CL_M_COUNT{1'b0}}, select_ctl, select_next;\nreg drop_reg = 1'b0, drop_ctl, drop_next;\nreg frame_reg = 1'b0, frame_ctl, frame_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nreg  [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg  [KEEP_WIDTH-1:0] m_axis_tkeep_int;\nreg  [M_COUNT-1:0]    m_axis_tvalid_int;\nreg                   m_axis_tready_int_reg = 1'b0;\nreg                   m_axis_tlast_int;\nreg  [ID_WIDTH-1:0]   m_axis_tid_int;\nreg  [DEST_WIDTH-1:0] m_axis_tdest_int;\nreg  [USER_WIDTH-1:0] m_axis_tuser_int;\nwire                  m_axis_tready_int_early;\n\nassign s_axis_tready = s_axis_tready_reg && enable;\n\nalways @* begin\n    select_next = select_reg;\n    select_ctl = select_reg;\n    drop_next = drop_reg;\n    drop_ctl = drop_reg;\n    frame_next = frame_reg;\n    frame_ctl = frame_reg;\n\n    s_axis_tready_next = 1'b0;\n\n    if (s_axis_tvalid && s_axis_tready) begin\n        if (s_axis_tlast) begin\n            frame_next = 1'b0;\n            drop_next = 1'b0;\n        end\n    end\n\n    if (!frame_reg && s_axis_tvalid && s_axis_tready) begin\n        select_ctl = select;\n        drop_ctl = drop;\n        frame_ctl = 1'b1;\n        if (!(s_axis_tready && s_axis_tvalid && s_axis_tlast)) begin\n            select_next = select_ctl;\n            drop_next = drop_ctl;\n            frame_next = 1'b1;\n        end\n    end\n\n    s_axis_tready_next = (m_axis_tready_int_early || drop_ctl);\n\n    m_axis_tdata_int  = s_axis_tdata;\n    m_axis_tkeep_int  = s_axis_tkeep;\n    m_axis_tvalid_int = (s_axis_tvalid && s_axis_tready && !drop_ctl) << select_ctl;\n    m_axis_tlast_int  = s_axis_tlast;\n    m_axis_tid_int    = s_axis_tid;\n    m_axis_tdest_int  = s_axis_tdest;\n    m_axis_tuser_int  = s_axis_tuser; \nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 2'd0;\n        drop_reg <= 1'b0;\n        frame_reg <= 1'b0;\n        s_axis_tready_reg <= 1'b0;\n    end else begin\n        select_reg <= select_next;\n        drop_reg <= drop_next;\n        frame_reg <= frame_next;\n        s_axis_tready_reg <= s_axis_tready_next;\n    end\nend\n\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg [M_COUNT-1:0]    m_axis_tvalid_reg = {M_COUNT{1'b0}}, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg  = {DATA_WIDTH{1'b0}};\nreg [KEEP_WIDTH-1:0] temp_m_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};\nreg [M_COUNT-1:0]    temp_m_axis_tvalid_reg = {M_COUNT{1'b0}}, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg  = 1'b0;\nreg [ID_WIDTH-1:0]   temp_m_axis_tid_reg    = {ID_WIDTH{1'b0}};\nreg [DEST_WIDTH-1:0] temp_m_axis_tdest_reg  = {DEST_WIDTH{1'b0}};\nreg [USER_WIDTH-1:0] temp_m_axis_tuser_reg  = {USER_WIDTH{1'b0}};\n\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata  = {M_COUNT{m_axis_tdata_reg}};\nassign m_axis_tkeep  = KEEP_ENABLE ? {M_COUNT{m_axis_tkeep_reg}} : {M_COUNT*KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = {M_COUNT{m_axis_tlast_reg}};\nassign m_axis_tid    = ID_ENABLE   ? {M_COUNT{m_axis_tid_reg}}   : {M_COUNT*ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? {M_COUNT{m_axis_tdest_reg}} : {M_COUNT*DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? {M_COUNT{m_axis_tuser_reg}} : {M_COUNT*USER_WIDTH{1'b0}};\n\nassign m_axis_tready_int_early = (m_axis_tready & m_axis_tvalid) || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid || !m_axis_tvalid_int));\n\nalways @* begin\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        if ((m_axis_tready & m_axis_tvalid) || !m_axis_tvalid) begin\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready & m_axis_tvalid) begin\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = {M_COUNT{1'b0}};\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        m_axis_tvalid_reg <= {M_COUNT{1'b0}};\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= {M_COUNT{1'b0}};\n    end else begin\n        m_axis_tvalid_reg <= m_axis_tvalid_next;\n        m_axis_tready_int_reg <= m_axis_tready_int_early;\n        temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n    end\n\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tkeep_reg <= m_axis_tkeep_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tid_reg   <= m_axis_tid_int;\n        m_axis_tdest_reg <= m_axis_tdest_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tkeep_reg <= temp_m_axis_tkeep_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tid_reg   <= temp_m_axis_tid_reg;\n        m_axis_tdest_reg <= temp_m_axis_tdest_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tkeep_reg <= m_axis_tkeep_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tid_reg   <= m_axis_tid_int;\n        temp_m_axis_tdest_reg <= m_axis_tdest_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\nend\n\nendmodule\n",
        "module_name": "axis_demux #",
        "module_hash": "87751e1c018eaa7e26351ccc7fd11bed",
        "dataset_index": 23311
      },
      "moore_state_machine_1609e3dc": {
        "rtl_code": "module moore_state_machine (\n  input wire clk,\n  input wire reset,\n  input wire input_bit,\n  output reg [1:0] state\n);\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      state <= 2'b00; // reset to state C\n    end else begin\n      case (state)\n        2'b00: begin // state C\n          if (input_bit == 0) begin\n            state <= 2'b01; // transition to state B\n          end else begin\n            state <= 2'b00; // stay in state C\n          end\n        end\n        2'b01: begin // state B\n          if (input_bit == 0) begin\n            state <= 2'b10; // transition to state C\n          end else begin\n            state <= 2'b01; // stay in state B\n          end\n        end\n        2'b10: begin // state A\n          if (input_bit == 0) begin\n            state <= 2'b01; // transition to state B\n          end else begin\n            state <= 2'b10; // stay in state A\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "moore_state_machine",
        "module_hash": "1609e3dc8889ded2c3cb87885040d78c",
        "dataset_index": 6173
      },
      "my__78bb5b11": {
        "rtl_code": "module my_module (\n    output X,\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    // Module ports\n    // output X;\n    // input A1;\n    // input A2;\n    // input A3;\n    // input B1;\n    // input VPWR;\n    // input VGND;\n    // input VPB;\n    // input VNB;\n\n    // Local signals\n    wire and0_out;\n    wire or0_out_X;\n    wire pwrgood_pp0_out_X;\n\n    and and0 (and0_out, A3, A1, A2);\n    or or0 (or0_out_X, and0_out, B1);\n    // sky130_fd_sc_ms__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);\n    buf buf0 (X, or0_out_X);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "78bb5b11c889691db816fa1067c5bf3b",
        "dataset_index": 2142
      },
      "comb_logic_00f6ede5": {
        "rtl_code": "\nmodule comb_logic (\n    output Y,\n    input  A,\n    input  B,\n    input  C\n);\n\n    // Output\n    wire Y;\n\n    // Inputs\n    wire A;\n    wire B;\n    wire C;\n\n    // Internal wires\n    wire not_C;\n    wire and_AB;\n\n    // Instantiate NOT gate for C\n    not (not_C, C);\n\n    // Instantiate AND gate for A and B\n    and (and_AB, A, B);\n\n    // Instantiate OR gate for and_AB and not_C\n    or (Y, and_AB, not_C);\n\nendmodule\n",
        "module_name": "comb_logic",
        "module_hash": "00f6ede5d6e7bb79d2856244bb552a97",
        "dataset_index": 5136
      },
      "soc_system_hps_only_master_b2p_adapter_f5ce16ed": {
        "rtl_code": "\nmodule soc_system_hps_only_master_b2p_adapter (\n    \n      input              clk,\n      input              reset_n,\n      output reg         in_ready,\n      input              in_valid,\n      input      [ 7: 0] in_data,\n      input      [ 7: 0] in_channel,\n      input              in_startofpacket,\n      input              in_endofpacket,\n      input              out_ready,\n      output reg         out_valid,\n      output reg [ 7: 0] out_data,\n      output reg         out_startofpacket,\n      output reg         out_endofpacket\n);\n\n\n   reg          out_channel;\n\n   always @* begin\n      in_ready = out_ready;\n      out_valid = in_valid;\n      out_data = in_data;\n      out_startofpacket = in_startofpacket;\n      out_endofpacket = in_endofpacket;\n\n      out_channel = in_channel       ;\n      if (in_channel > 0) begin\n         out_valid = 0;\n         end\n   end\n\nendmodule\n\n",
        "module_name": "soc_system_hps_only_master_b2p_adapter",
        "module_hash": "f5ce16edb6558f863cfdfb644c8c50ef",
        "dataset_index": 11432
      },
      "fifo_2618754c": {
        "rtl_code": "module fifo(datain, rd, wr, rst, clk, full, empty, led_n, wei);\n\ninput [3:0] datain;\ninput rd, wr, rst, clk;\n\noutput [6:0] led_n;\noutput full, empty, wei;\n\nreg [3:0] dataout;\nreg full_in, empty_in, wei_in, div;\nreg [3:0] mem [15:0];\nreg [23:0] cnt;\nreg [3:0] rp, wp;\nreg [6:0] led_n;\n\nassign full = full_in;\nassign empty = empty_in;\nassign wei = wei_in;\n\nparameter\n    reg0 = 7'b0000001,\n    reg1 = 7'b1001111,\n    reg2 = 7'b0010010,\n    reg3 = 7'b0000110,\n    reg4 = 7'b1001100,\n    reg5 = 7'b0100100,\n    reg6 = 7'b0100000,\n    reg7 = 7'b0001101,\n    reg8 = 7'b0000000,\n    reg9 = 7'b0000100,\n    rega = 7'b0001000,\n    regb = 7'b1100000,\n    regc = 7'b0110001,\n    regd = 7'b1000010,\n    rege = 7'b0110000,\n    regf = 7'b0111000;\n\n// memory read out\nalways @(posedge clk) begin\n    if (~rd && ~empty_in) begin\n        dataout <= mem[rp];\n        case (dataout)\n            4'h0: led_n <= reg0;\n            4'h1: led_n <= reg1;\n            4'h2: led_n <= reg2;\n            4'h3: led_n <= reg3;\n            4'h4: led_n <= reg4;\n            4'h5: led_n <= reg5;\n            4'h6: led_n <= reg6;\n            4'h7: led_n <= reg7;\n            4'h8: led_n <= reg8;\n            4'h9: led_n <= reg9;\n            4'ha: led_n <= rega;\n            4'hb: led_n <= regb;\n            4'hc: led_n <= regc;\n            4'hd: led_n <= regd;\n            4'he: led_n <= rege;\n            4'hf: led_n <= regf;\n            default:;\n        endcase\n    end\nend\n\n// memory write in\nalways @(posedge div) begin\n    if (~wr && ~full_in) begin\n        mem[wp] <= datain;\n        wei_in <= 1'b1;\n    end\nend\n\n// memory write pointer increment\nalways @(posedge div) begin\n    if (!rst) begin\n        wp <= 0;\n    end else begin\n        if (~wr && ~full_in) begin\n            wp <= wp + 1'b1;\n        end\n    end\nend\n\n// memory read pointer increment\nalways @(posedge div) begin\n    if (!rst) begin\n        rp <= 0;\n    end else begin\n        if (~rd && ~empty_in) begin\n            rp <= rp + 1'b1;\n        end\n    end\nend\n\n// Full signal generate\nalways @(posedge div) begin\n    if (!rst) begin\n        full_in <= 1'b0;\n    end else begin\n        if (rd && ~wr) begin\n            if ((wp == rp - 1) || (rp == 4'h0 && wp == 4'hf)) begin\n                full_in <= 1'b1;\n            end\n        end else if (full_in && ~rd) begin\n            full_in <= 1'b0;\n        end\n    end\nend\n\n// Empty signal generate\nalways @(posedge div) begin\n    if (!rst) begin\n        empty_in <= 1'b1;\n    end else begin\n        if (~rd && wr) begin\n            if ((rp == wp - 1) || (rp == 4'hf && wp == 4'h0)) begin\n                empty_in <= 1'b1;\n            end\n        end else if (empty_in && ~wr) begin\n            empty_in <= 1'b0;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (cnt == 24'b111111111111111111111111) begin\n        div <= ~div;\n        cnt <= 0;\n    end else begin\n        cnt <= cnt + 1;\n    end\nend\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "2618754c451c4d0f88492c96ac56e456",
        "dataset_index": 20830
      },
      "serial_tx #_6f094cfb": {
        "rtl_code": "module serial_tx #(\n\t\tparameter CLK_PER_BIT = 50,\n\t\tparameter CTR_SIZE = 6\n\t)(\n\t\tinput clk,\n\t\tinput rst,\n\t\toutput tx,\n\t\tinput block,\n\t\toutput busy,\n\t\tinput [7:0] data,\n\t\tinput new_data\n\t);\n\t\n\tlocalparam STATE_SIZE = 2;\n\tlocalparam IDLE = 2'd0,\n\t\tSTART_BIT = 2'd1,\n\t\tDATA = 2'd2,\n\t\tSTOP_BIT = 2'd3;\n\t\n\treg [CTR_SIZE-1:0] ctr_d, ctr_q;\n\treg [2:0] bit_ctr_d, bit_ctr_q;\n\treg [7:0] data_d, data_q;\n\treg [STATE_SIZE-1:0] state_d, state_q = IDLE;\n\treg tx_d, tx_q;\n\treg busy_d, busy_q;\n\treg block_d, block_q;\n\t\n\tassign tx = tx_q;\n\tassign busy = busy_q;\n\t\n\talways @(*) begin\n\t\tblock_d = block;\n\t\tctr_d = ctr_q;\n\t\tbit_ctr_d = bit_ctr_q;\n\t\tdata_d = data_q;\n\t\tstate_d = state_q;\n\t\tbusy_d = busy_q;\n\t\t\n\t\tcase (state_q)\n\t\t\tIDLE: begin\n\t\t\t\tif (block_q) begin\n\t\t\t\t\tbusy_d = 1'b1;\n\t\t\t\t\ttx_d = 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tbusy_d = 1'b0;\n\t\t\t\t\ttx_d = 1'b1;\n\t\t\t\t\tbit_ctr_d = 3'b0;\n\t\t\t\t\tctr_d = 1'b0;\n\t\t\t\t\tif (new_data) begin\n\t\t\t\t\t\tdata_d = data;\n\t\t\t\t\t\tstate_d = START_BIT;\n\t\t\t\t\t\tbusy_d = 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTART_BIT: begin\n\t\t\t\tbusy_d = 1'b1;\n\t\t\t\tctr_d = ctr_q + 1'b1;\n\t\t\t\ttx_d = 1'b0;\n\t\t\t\tif (ctr_q == CLK_PER_BIT - 1) begin\n\t\t\t\t\tctr_d = 1'b0;\n\t\t\t\t\tstate_d = DATA;\n\t\t\t\tend\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tbusy_d = 1'b1;\n\t\t\t\ttx_d = data_q[bit_ctr_q];\n\t\t\t\tctr_d = ctr_q + 1'b1;\n\t\t\t\tif (ctr_q == CLK_PER_BIT - 1) begin\n\t\t\t\t\tctr_d = 1'b0;\n\t\t\t\t\tbit_ctr_d = bit_ctr_q + 1'b1;\n\t\t\t\t\tif (bit_ctr_q == 7) begin\n\t\t\t\t\t\tstate_d = STOP_BIT;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP_BIT: begin\n\t\t\t\tbusy_d = 1'b1;\n\t\t\t\ttx_d = 1'b1;\n\t\t\t\tctr_d = ctr_q + 1'b1;\n\t\t\t\tif (ctr_q == CLK_PER_BIT - 1) begin\n\t\t\t\t\tstate_d = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tstate_d = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (rst) begin\n\t\t\tstate_q <= IDLE;\n\t\t\ttx_q <= 1'b1;\n\t\tend else begin\n\t\t\tstate_q <= state_d;\n\t\t\ttx_q <= tx_d;\n\t\tend\n\t\t\n\t\tblock_q <= block_d;\n\t\tdata_q <= data_d;\n\t\tbit_ctr_q <= bit_ctr_d;\n\t\tctr_q <= ctr_d;\n\t\tbusy_q <= busy_d;\n\tend\n\t\nendmodule",
        "module_name": "serial_tx #",
        "module_hash": "6f094cfb389db5897f622e7d5ad4cd34",
        "dataset_index": 24363
      },
      "counter_dff98e53": {
        "rtl_code": "module counter(\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "dff98e53fd5ab397d64e28c377c20c7a",
        "dataset_index": 1016
      },
      "sky130_fd_sc_lp__nand2_1b445bb8": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__nand2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A           );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__nand2",
        "module_hash": "1b445bb8fb7a05b5c5f4dd1bfcb34eee",
        "dataset_index": 3891
      },
      "my__d16659d9": {
        "rtl_code": "module my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire and_wire;\n    wire or_wire;\n    wire xor_wire;\n    wire power_wire;\n\n    assign and_wire = A1 & A2 & A3;\n    assign or_wire = B1 | C1;\n    assign xor_wire = VPB ^ VNB;\n    assign power_wire = VPWR & VGND;\n\n    assign X = and_wire | or_wire | xor_wire | power_wire;\n\nendmodule",
        "module_name": "my_",
        "module_hash": "d16659d9d1d57bbf1e6173d91ade69b9",
        "dataset_index": 15255
      },
      "parity_checker_6747afaf": {
        "rtl_code": "\nmodule parity_checker (\n  input clk,\n  input [3:0] data,\n  output reg parity\n);\n\n  reg [1:0] stage1_data [0:1];\n  wire [1:0] stage2_data [0:1];\n  \n  always @ (posedge clk) begin\n    stage1_data[1] <= stage1_data[0];\n    stage1_data[0] <= data;\n  end\n  \n  assign stage2_data[1] = stage1_data[1] ^ stage1_data[0];\n  assign stage2_data[0] = 2'b00;\n  \n  always @ (posedge clk) begin\n    parity <= stage2_data[1][0] ^ stage2_data[1][1];\n  end\n  \nendmodule\n",
        "module_name": "parity_checker",
        "module_hash": "6747afaf75fbe1b5fd032d567d076511",
        "dataset_index": 17092
      },
      "HalfAdder_23801b1c": {
        "rtl_code": "module HalfAdder(\n\tA,\n\tCin,\n\tCout,\n\tSum\n);\n\n\ninput wire\tA;\ninput wire\tCin;\noutput wire\tCout;\noutput wire\tSum;\n\n\n\n\n\nassign\tCout = A & Cin;\n\nassign\tSum = A ^ Cin;\n\n\nendmodule\n",
        "module_name": "HalfAdder",
        "module_hash": "23801b1ce7da06c39631d33781036bd7",
        "dataset_index": 12431
      },
      "top__f44890c9": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [3:0] data_in,\n    input [3:0] A,\n    input [3:0] B,\n    output [7:0] out,\n    input load\n);\n\n    wire GT, EQ;\n    wire [3:0] counter_out;\n    \n    // Instantiate the magnitude comparator\n    comparator comp_inst (\n        .A(A),\n        .B(B),\n        .GT(GT),\n        .EQ(EQ)\n    );\n    \n    // Instantiate the binary counter\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .data_in(data_in),\n        .load(load),\n        .out(counter_out)\n    );\n    \n    // Logic for selecting output\n    assign out = (GT) ? {4'b0000, A} : (EQ) ? {4'b0000, B} : {4'b0000, counter_out};\n    \nendmodule\n\n// 4-bit magnitude comparator module\nmodule comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output GT,\n    output EQ\n);\n\n    assign GT = (A > B);\n    assign EQ = (A == B);\n    \nendmodule\n\n// 4-bit binary counter module\nmodule counter (\n    input clk,\n    input reset,\n    input [3:0] data_in,\n    input load,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else if (load) begin\n            out <= data_in;\n        end else begin\n            out <= out + 1;\n        end\n    end\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "f44890c90bd3c4ee182efa590b41be44",
        "dataset_index": 5141
      },
      "sw_reset_0e2b2bfc": {
        "rtl_code": "module sw_reset\n#( \n  parameter WIDTH=32,\n  parameter LOG2_RESET_CYCLES=8\n)\n(\n   input clk,\n   input resetn,\n\n   input slave_address,  input [WIDTH-1:0] slave_writedata,\n   input slave_read,\n   input slave_write,\n   input [WIDTH/8-1:0] slave_byteenable,\n   output slave_readdata,\n   output slave_waitrequest,\n\n   output reg       sw_reset_n_out\n);\n\nreg       sw_reset_n_out_r;\nreg       sw_reset_n_out_r2;\n\nreg [LOG2_RESET_CYCLES:0] reset_count;\ninitial  reset_count <= {LOG2_RESET_CYCLES+1{1'b0}};\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    reset_count <= {LOG2_RESET_CYCLES+1{1'b0}};\n  else if (slave_write)\n    reset_count <= {LOG2_RESET_CYCLES+1{1'b0}};\n  else if (!reset_count[LOG2_RESET_CYCLES])\n    reset_count <= reset_count + 2'b01;\n\nalways@(posedge clk)\n  sw_reset_n_out = sw_reset_n_out_r;\n\nalways@(posedge clk) sw_reset_n_out_r2 = reset_count[LOG2_RESET_CYCLES];\nalways@(posedge clk) sw_reset_n_out_r = sw_reset_n_out_r2;\n\nassign slave_waitrequest = !reset_count[LOG2_RESET_CYCLES];\nassign slave_readdata = sw_reset_n_out;\n  \nendmodule\n\n",
        "module_name": "sw_reset",
        "module_hash": "0e2b2bfcdaf802eeff2fa448b1ab9ad0",
        "dataset_index": 25636
      },
      "mod_96426c05": {
        "rtl_code": "\nmodule mod ( A, Z );\n  input [7:0] A;\n  output Z;\n\n  mod5 U98 ( .Z(Z), .A(A[4:0]) );\n\nendmodule\nmodule mod5 ( A, Z );\n  input [4:0] A;\n  output Z;\n\n  assign Z = (A % 5 == 0) ? 1 : 0;\n\nendmodule",
        "module_name": "mod",
        "module_hash": "96426c0574a49fc4f3de7089b16ba616",
        "dataset_index": 21258
      },
      "nand4bb_ff34aa51": {
        "rtl_code": "module nand4bb (\n    input  A_N ,\n    input  B_N ,\n    input  C   ,\n    input  D   ,\n    output Y   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n    // Define internal signals\n    wire  AB_N;\n    wire  CD_N;\n    wire  Y_N;\n\n    // Implement the NAND gate\n    assign AB_N = ~(A_N & B_N);\n    assign CD_N = ~(C & D);\n    assign Y_N  = ~(AB_N & CD_N);\n    assign Y    = Y_N;\n\nendmodule",
        "module_name": "nand4bb",
        "module_hash": "ff34aa51a9ffce9285b728a2f66775d0",
        "dataset_index": 9128
      },
      "deserializer #_ab0dfca6": {
        "rtl_code": "module deserializer #(\n        parameter   WIDTH = 8\n    )(\n        input                   rxd,\n        input                   rst,\n        input                   clk,\n        output [WIDTH - 1:0]    data,\n        output                  received\n    );\n    localparam s0 = 2'b00;\n    localparam s1 = 2'b01;\n    localparam s2 = 2'b11;\n    localparam s3 = 2'b10;\n    \n    reg [1:0]           state           = s0;\n    reg [7:0]           bit_index       = 0;\n    reg [WIDTH - 1:0]   data_buf        = 0;\n    reg                 received_buf    = 0;\n    \n    assign              data = data_buf;\n    assign              received = received_buf;\n    \n    always@(posedge clk)\n    begin\n        if(rst)\n        begin\n            state = s0;\n            bit_index = 0;\n            data_buf = 0;\n            received_buf = 0;\n        end\n        else\n        begin\n            case(state)\n            s0:\n            begin\n                if(rxd)\n                begin\n                    state = s1;\n                    bit_index = 0;\n                end\n            end\n            s1:\n            begin\n                if(bit_index < WIDTH)\n                begin\n                    data_buf[bit_index] = rxd;\n                    bit_index = bit_index + 1;\n                end\n                else\n                begin\n                    state = s2;\n                    received_buf = 1;\n                end\n            end\n            s2:\n            begin\n                state = s3;\n            end\n            s3:\n            begin\n                state = s0;\n                bit_index = 0;\n                data_buf = 0;\n                received_buf = 0;\n            end\n            endcase\n        end\n    end\nendmodule",
        "module_name": "deserializer #",
        "module_hash": "ab0dfca60214c877b2709875f92bb119",
        "dataset_index": 15627
      },
      "mix_columns_5793bdc1": {
        "rtl_code": "module mix_columns\n(\n\t// OUTPUTS\n\toutput [31:0] mix_out_enc,\n\toutput [31:0] mix_out_dec,\n\t// INPUTS\n\tinput  [31:0] mix_in\n);\n\nlocalparam integer SIZE      = 32;\nlocalparam integer WORD_SIZE = 8;\nlocalparam integer NUM_WORDS = 4;\n\nwire [WORD_SIZE - 1 : 0] col  [0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] sum_p[0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] y    [0 : NUM_WORDS - 2];\n\nfunction [7:0] aes_mult_02;\n  input [7:0] data_in;\n  begin\n    aes_mult_02 = (data_in << 1) ^ {8{data_in[7]}} & 8'h1b;\n  end\nendfunction\n\nfunction [7:0] aes_mult_04;\n  input [7:0] data_in;\n  begin\n    aes_mult_04 = ((data_in << 2) ^ {8{data_in[6]}} & 8'h1b) ^ {8{data_in[7]}} & 8'h36;\n  end\nendfunction\n\ngenerate\n\tgenvar i;\n\tfor(i = 0 ; i < NUM_WORDS; i = i + 1)\n\tbegin:WBT\n\t\tassign col[i] = mix_in[WORD_SIZE*(i + 1) - 1: WORD_SIZE*i];\n\tend\nendgenerate\n\ngenerate\n\tgenvar j;\n\tfor(j = 0; j < NUM_WORDS; j = j + 1)\n\tbegin:DMCO\n\t\tassign sum_p[j] = col[(j + 1)%NUM_WORDS] ^ col[(j + 2)%NUM_WORDS] ^ col[(j + 3)%NUM_WORDS];\n\t\tassign mix_out_enc[ WORD_SIZE*(j + 1) - 1 : WORD_SIZE*j] = aes_mult_02(col[j] ^ col[(j + NUM_WORDS - 1)%NUM_WORDS]) ^ sum_p[j];\n\tend\nendgenerate\n\nassign y[0] = aes_mult_04(col[2] ^ col[0]); \nassign y[1] = aes_mult_04(col[3] ^ col[1]);\nassign y[2] = aes_mult_02(  y[1] ^   y[0]);  \nassign mix_out_dec = mix_out_enc ^ {2{y[2] ^ y[1], y[2] ^ y[0]}};\n\nendmodule",
        "module_name": "mix_columns",
        "module_hash": "5793bdc1f1925842a97ab0d4e5fe81fd",
        "dataset_index": 3635
      },
      "decoder_3to8_149803ef": {
        "rtl_code": "module decoder_3to8 (\n    input [2:0] in,\n    output reg [7:0] out\n);\n\n    always @(*)\n    begin\n        case(in)\n            3'b000: out = 8'b00000001;\n            3'b001: out = 8'b00000010;\n            3'b010: out = 8'b00000100;\n            3'b011: out = 8'b00001000;\n            3'b100: out = 8'b00010000;\n            3'b101: out = 8'b00100000;\n            3'b110: out = 8'b01000000;\n            3'b111: out = 8'b10000000;\n            default: out = 8'b00000000;\n        endcase\n    end\n\nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "149803eff0dde402ddd8874ae6960519",
        "dataset_index": 7485
      },
      "traffic_light_controller_caf8e49a": {
        "rtl_code": "module traffic_light_controller(\n    input clk,\n    input pedestrian_button,\n    output reg red_light,\n    output reg yellow_light,\n    output reg green_light\n);\n\nreg [5:0] counter = 0; // 6-bit counter for 1 Hz clock\nreg [3:0] pedestrian_counter = 0; // 4-bit counter for pedestrian crossing\n\nalways @(posedge clk) begin\n    counter <= counter + 1;\n\n    if (pedestrian_button) begin\n        // Pedestrian crossing mode\n        if (pedestrian_counter < 10) begin\n            red_light <= 0;\n            yellow_light <= 0;\n            green_light <= 0;\n            pedestrian_counter <= pedestrian_counter + 1;\n        end else begin\n            pedestrian_counter <= 0;\n        end\n    end else begin\n        // Standard traffic light pattern\n        if (counter < 20) begin\n            red_light <= 0;\n            yellow_light <= 0;\n            green_light <= 1;\n        end else if (counter < 25) begin\n            red_light <= 0;\n            yellow_light <= 1;\n            green_light <= 0;\n        end else if (counter < 45) begin\n            red_light <= 1;\n            yellow_light <= 0;\n            green_light <= 0;\n        end else begin\n            counter <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "traffic_light_controller",
        "module_hash": "caf8e49a21df9339852e9ef4b2795235",
        "dataset_index": 9505
      },
      "my_alu #_32d6d1cf": {
        "rtl_code": "\nmodule my_alu #(\n    parameter N = 8 // Parameter to define the number of bits\n)(\n    input signed [N-1:0] a,\n    input signed [N-1:0] b,\n    input [3:0] op,\n    output signed [N-1:0] result,\n    output carry\n);\n\n\nreg signed [N-1:0] result_reg;\nreg carry_reg;\n\nalways @* begin\n    case(op)\n        4'b0000: begin // a + b\n            result_reg = a + b;\n            carry_reg = (result_reg[N-1] == a[N-1] && result_reg[N-1] == b[N-1]) ? 1 : 0;\n        end\n        4'b0001: begin // a - b\n            result_reg = a - b;\n            carry_reg = (result_reg[N-1] == a[N-1] && result_reg[N-1] != b[N-1]) ? 1 : 0;\n        end\n        4'b0010: begin // a & b\n            result_reg = a & b;\n            carry_reg = 0;\n        end\n        4'b0011: begin // a | b\n            result_reg = a | b;\n            carry_reg = 0;\n        end\n        4'b0100: begin // a ^ b\n            result_reg = a ^ b;\n            carry_reg = 0;\n        end\n        4'b0101: begin // ~a\n            result_reg = ~a;\n            carry_reg = 0;\n        end\n        4'b0110: begin // ~b\n            result_reg = ~b;\n            carry_reg = 0;\n        end\n        4'b0111: begin // 0\n            result_reg = 0;\n            carry_reg = 0;\n        end\n        4'b1000: begin // a << b\n            result_reg = a << b;\n            carry_reg = (result_reg[N-1] == 1) ? 1 : 0;\n        end\n        4'b1001: begin // a >> b\n            result_reg = a >> b;\n            carry_reg = (result_reg[0] == 1) ? 1 : 0;\n        end\n        4'b1010: begin // a >>> b\n            result_reg = $signed({a[N-1], a}) >>> b;\n            carry_reg = (result_reg[0] == 1) ? 1 : 0;\n        end\n        4'b1011: begin // a == b\n            result_reg = (a == b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1100: begin // a != b\n            result_reg = (a != b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1101: begin // a > b\n            result_reg = (a > b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1110: begin // a >= b\n            result_reg = (a >= b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1111: begin // a < b\n            result_reg = (a < b) ? 1 : 0;\n            carry_reg = 0;\n        end\n    endcase\nend\n\nassign result = result_reg;\nassign carry = carry_reg;\n\nendmodule\n",
        "module_name": "my_alu #",
        "module_hash": "32d6d1cfc957a741e0250c08f42a0104",
        "dataset_index": 17258
      },
      "logicblock_counter_c8b6c280": {
        "rtl_code": "module logicblock_counter(clock, resetn, i_start, i_size, \n  o_dataout, o_dataout_valid, i_dataout_stall, i_counter_reset);\n\nparameter DATA_WIDTH = 32;\n  \n  input clock, resetn;\n  input i_start;\n  input [DATA_WIDTH-1:0] i_size;\n  output [DATA_WIDTH-1:0] o_dataout;\n  output o_dataout_valid;\n  input i_dataout_stall;\n  input i_counter_reset;\n  \n  reg [DATA_WIDTH-1:0] counter;\n  \n  always @(posedge clock or negedge resetn)\n  begin\n    if (~resetn)\n    begin\n      counter <= 32'h00000000;\n    end\n    else\n    begin\n      if (i_counter_reset)\n      begin\n        counter <= {DATA_WIDTH{1'b0}};\n      end\n      else if (i_start && ~i_dataout_stall && counter < i_size)\n      begin\n        counter <= counter + 1;\n      end\n    end\n  end\n  \n  assign o_dataout = counter;\n  assign o_dataout_valid = i_start && !i_counter_reset && (counter < i_size);\n \nendmodule\n",
        "module_name": "logicblock_counter",
        "module_hash": "c8b6c2802bebba9186c713acf4d624f2",
        "dataset_index": 25655
      },
      "memory_mux_2ffceadf": {
        "rtl_code": "\n\nmodule memory_mux (\n\tinput select,\n\n\tinput enable_0,\n\tinput command_0,\n\tinput [31:0] address_0,\n\tinput [31:0] write_data_0,\n\tinput [3:0]  write_mask_0,\n\toutput [31:0] read_data_0,\n\toutput valid_0,\n\t\n\tinput enable_1,\n\tinput command_1,\n\tinput [31:0] address_1,\n\tinput [31:0] write_data_1,\n\tinput [3:0]  write_mask_1,\n\toutput [31:0] read_data_1,\n\toutput valid_1,\n\n\toutput enable,\n\toutput command,\n\toutput [31:0] address,\n\toutput [31:0] write_data,\n\toutput [3:0] write_mask,\n\tinput [31:0] read_data,\n\tinput valid\n);\n\n\tassign enable = select ? enable_1 : enable_0;\n\tassign command = select ? command_1 : command_0;\n\tassign address = select ? address_1 : address_0;\n\tassign write_data = select ? write_data_1 : write_data_0;\n\tassign write_mask = select ? write_mask_1 : write_mask_0;\n\tassign read_data_1 = read_data;\n\tassign read_data_0 = read_data;\n\tassign valid_1 =  select ? valid : 1'b0;\n\tassign valid_0 = !select ? valid : 1'b0;\n\nendmodule\n\t\n",
        "module_name": "memory_mux",
        "module_hash": "2ffceadfb1bc845f18f42b0f2b7e3e8b",
        "dataset_index": 5227
      },
      "FSM_7f2362a7": {
        "rtl_code": "\nmodule FSM (\n  input clk,\n  input rst,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 2; // number of input signals\nparameter m = 1; // number of output signals\nparameter s = 3; // number of states in the reduced FSM\n\nreg [s-1:0] state; // current state\nreg [m-1:0] output_reg; // output register\n\n// Define the reduced FSM and its transitions\nalways @ (posedge clk) begin\n  if (rst) begin\n    state <= 0;\n  end else begin\n    case (state)\n      0: begin\n        if (in == 2'b00) begin\n          state <= 0;\n        end else if (in == 2'b01) begin\n          state <= 1;\n        end\n      end\n      1: begin\n        if (in == 2'b00) begin\n          state <= 2;\n        end else if (in == 2'b01) begin\n          state <= 1;\n        end\n      end\n      2: begin\n        if (in == 2'b00) begin\n          state <= 0;\n        end else if (in == 2'b01) begin\n          state <= 1;\n        end\n      end\n    endcase\n  end\nend\n\n// Define the output signals\nalways @ (state) begin\n  case (state)\n    0: output_reg <= 0;\n    1: output_reg <= 1;\n    2: output_reg <= 0;\n  endcase\nend\n\nassign out = output_reg;\n\nendmodule",
        "module_name": "FSM",
        "module_hash": "7f2362a740380ea20c593bafe7df90b7",
        "dataset_index": 12636
      },
      "top__1e7f4261": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input select, // Select input to choose between addition and shifting\n    output [31:0] result\n);\n\n    wire [3:0] adder_out;\n    wire [31:0] shifted_out;\n    wire mode_select;\n\n    // Instantiate the ripple carry adder module\n    ripple_carry_adder adder_inst (\n        .clk(clk),\n        .reset(reset),\n        .A(A),\n        .B(B),\n        .sum(adder_out)\n    );\n\n    // Instantiate the barrel shifter module\n    barrel_shifter shifter_inst (\n        .data_in(data_in), // Fixed the port width mismatch\n        .shift_amt(shift_amt),\n        .shifted_out(shifted_out)\n    );\n\n    // Control logic to select between addition and shifting modes\n    assign mode_select = select;\n\n    // Output the result based on the selected mode\n    assign result = (mode_select == 0) ? adder_out : shifted_out;\n\nendmodule\n\nmodule ripple_carry_adder (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] sum\n);\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            sum <= 4'b0;\n        end else begin\n            sum <= A + B;\n        end\n    end\n\nendmodule\n\nmodule barrel_shifter (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    output [31:0] shifted_out\n);\n\n    assign shifted_out = (shift_amt[4]) ? {32{data_in[31]}} :\n                        (shift_amt[3]) ? {data_in[31], data_in[31:1]} :\n                        (shift_amt[2]) ? {data_in[31:2], data_in[1:0]} :\n                        (shift_amt[1]) ? {data_in[31:3], data_in[2:0]} :\n                        {data_in[31:4], data_in[3:0]};\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "1e7f4261b308e2419f63ec119c456df1",
        "dataset_index": 20161
      },
      "lpm_inv_01319a76": {
        "rtl_code": "module lpm_inv ( \n    data,   // Data input to the lpm_inv. (Required)\n    result  // Inverted result. (Required)\n);\n\n// GLOBAL PARAMETER DECLARATION\n    parameter lpm_width = 1; // Width of the data[] and result[] ports. (Required)\n    parameter lpm_type = \"lpm_inv\";    \n    parameter lpm_hint = \"UNUSED\";\n\n// INPUT PORT DECLARATION  \n    input  [lpm_width-1:0] data;\n\n// OUTPUT PORT DECLARATION\n    output [lpm_width-1:0] result;\n\n// INTERNAL REGISTERS DECLARATION\n    reg    [lpm_width-1:0] result;\n\n// INITIAL CONSTRUCT BLOCK\n    initial\n    begin\n        if (lpm_width <= 0)\n        begin\n            $display(\"Value of lpm_width parameter must be greater than 0 (ERROR)\");\n            $display(\"Time: %0t  Instance: %m\", $time);\n            $finish;\n        end\n    end\n    \n// ALWAYS CONSTRUCT BLOCK\n    always @(data)\n        result = ~data;\n\nendmodule",
        "module_name": "lpm_inv",
        "module_hash": "01319a76e99d073cbebd6453e60152c2",
        "dataset_index": 15170
      },
      "sync_seq_circuit_8eac0925": {
        "rtl_code": "module sync_seq_circuit (\n    Q      ,\n    CLK_N  ,\n    D      ,\n    RESET_B\n);\n\n    output Q      ;\n    input  CLK_N  ;\n    input  D      ;\n    input  RESET_B;\n\n    reg Q;\n\n    always @ (posedge CLK_N or negedge RESET_B) begin\n        if (!RESET_B) begin\n            Q <= 0;\n        end else begin\n            if (D) begin\n                Q <= 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "sync_seq_circuit",
        "module_hash": "8eac0925700671757008d41e05c0793b",
        "dataset_index": 9198
      },
      "binary_counter_0d4d52d3": {
        "rtl_code": "module binary_counter(\n    input iCLK,\n    input iRST,\n    output reg [3:0] oCOUNT\n);\n\n    always @(posedge iCLK) begin\n        if (iRST) begin\n            oCOUNT <= 4'b0000;\n        end else begin\n            oCOUNT <= oCOUNT + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "0d4d52d3a8443381a9750f13c7dc8922",
        "dataset_index": 19096
      },
      "rgb_led_688785af": {
        "rtl_code": "module rgb_led\n(\n\tpclk,\n\tnreset,\n\tbus_write_en, \n\tbus_read_en,\n\tbus_addr,\n\tbus_write_data,\n\tbus_read_data,\n    pwm_r, pwm_g, pwm_b\n);\n\nparameter HZ_PER_COLOR_DIVISION = 3921;\nparameter PWM_PERIOD = 1000000;\n\n// bus lines\t\ninput pclk, nreset, bus_write_en, bus_read_en;\ninput [7:0] bus_addr;\ninput [31:0] bus_write_data;\noutput reg [31:0] bus_read_data;\noutput reg pwm_r, pwm_g, pwm_b;\n\n// counts to PWM_PERIOD\nreg [31:0] duty_cycle_counter;\n\nreg [31:0] brightness;\nreg [31:0] brightness_factor;\nreg [7:0]  delta_brightness;\n\n\nreg [31:0] led_control;\n\n// 0x En (Enabled bit) P (pulse_rate) RR GG BB\nreg [31:0] pending_led_state_1;\nreg [31:0] pending_led_state_2;\n\nreg [31:0] led_state_1;\nreg [31:0] led_state_2;\n\n// which led state are we in?\nreg [31:0] current_state;\n\nreg enabled;\nreg pulse;\nreg red;\nreg green;\nreg blue;\n\nalways@(posedge pclk)\nif(~nreset)\n  begin\n\tpending_led_state_1 <= 32'h00000000;\n    pending_led_state_2 <= 32'h00000000;\n  end\nelse begin\n\tif(bus_write_en) begin : WRITE\n\t\tcase(bus_addr[3:2])\n\t\t\t2'b00: // led_control\n                begin \n\t\t\t\tled_control <= bus_write_data;\n                end\n            2'b01: // pending_led_state_1\n                begin\n                pending_led_state_1 <= bus_write_data;\n                end\n            2'b10: // pending_led_state_2\n                begin \n                pending_led_state_2 <= bus_write_data;\n                end\n        endcase\n    end\n\telse if(bus_read_en) begin : READ\n        case(bus_addr[3:2])\n\t        2'b00: // led_control\n                begin \n\t\t        bus_read_data <= led_control;\n\t\t\t\tend\n            2'b01: // pending_led_state_1\n                begin \n                bus_read_data <= pending_led_state_1;\n\t\t\t\tend\n            2'b10: // pending_led_state_2\n                begin \n                bus_read_data <= pending_led_state_2;\n\t\t\t    end\n        endcase\n     end\nend\n\nalways@(posedge pclk) begin\n    enabled <= current_state[31];\n    pulse   <= current_state[30:24];\n    red \t<= current_state[23:16];\n    green \t<= current_state[15:8];\n    blue\t<= current_state[7:0];\nend\n\n// changing global brightness\nalways@(posedge pclk) begin\n\tif(brightness == 32'd100000000) begin\n    \tdelta_brightness = -1;\n    end\n    else begin\n\t\tif(brightness == 32'd0) begin\n\t\t\tdelta_brightness = 1;\n\t\tend\n\t\telse begin\n\t\t\tbrightness = brightness + delta_brightness;\n\t\tend\n    end\n\tbrightness_factor <= ((HZ_PER_COLOR_DIVISION * brightness) / 32'd100000000);\nend\n\n// pulsing colors based on global brightness\nalways@(posedge pclk) begin\nif(~nreset)begin\n    led_state_1 <= 32'h00000000;\n    led_state_2 <= 32'h00000000;\n\tpwm_r <= 0;\n    pwm_g <= 0;\n    pwm_b <= 0;\nend\nelse begin\n\tduty_cycle_counter <= duty_cycle_counter + 1;\n\tif(duty_cycle_counter == PWM_PERIOD) begin\n    \tduty_cycle_counter <= 0;\n    end\n    else begin\n       //turn off signals that have reached their duty cycle\n\t\tif(red * brightness_factor == duty_cycle_counter) begin\n\t\t\tpwm_r <= 0;\n\t\tend\n\t\tif(blue * brightness_factor == duty_cycle_counter) begin\n\t\t\tpwm_b <= 0;\n\t\tend\n\t\tif(green * brightness_factor == duty_cycle_counter) begin\n\t\t\tpwm_g <= 0;\n\t\tend\n    end\n\n\t// \"overflow\" of the pwm counter, so start a new duty cycle\n    if(duty_cycle_counter == 0)begin\n\t\t// toggle state\n\t\tif(current_state == led_state_1)begin\n\t\t\tcurrent_state <= led_state_2;\n\t\tend\n\t\telse begin\n\t\t\tcurrent_state <= led_state_1;\n\t\tend\n\n\t\tled_state_1 <= pending_led_state_1;\n\t\tled_state_2 <= pending_led_state_2;\n\n    \t//turn on all pwm signals\n\t\t//TODO only if they are non-zero values\n\t\tpwm_r <= 1;\n        pwm_g <= 1;\n        pwm_b <= 1;\n    end\nend\nend\n\nendmodule",
        "module_name": "rgb_led",
        "module_hash": "688785afb0bc0177ef9f86b24ff91cd3",
        "dataset_index": 6086
      },
      "divider_408a6932": {
        "rtl_code": "\nmodule divider(\n\n    input [7:0] div, input [7:0] dvr, input clk,\n\t \n    output [7:0] quotient, output [7:0] remainder );\n\ninteger i;\nreg [7:0] diff; reg [7:0] qu;reg [7:0] rem;always @(posedge clk) begin\n\nrem [7:0] = 8'b0; qu [7:0] = div[7:0]; for (i=0;i<=7;i=i+1) begin\nrem = rem<<1;rem[0] = qu[7];qu = qu<<1;qu[0] = 1'b0;if ( rem >= dvr) begin\n\t\nrem = rem-dvr;\nqu[0] = 1'b1;\n\n\t\t\t\t\t\tend\n\n\t\n\t\t\tend\n\t\nend \n\nassign remainder [7:0] = rem[7:0];\nassign quotient [7:0] = qu[7:0];\n\n\nendmodule\n  ",
        "module_name": "divider",
        "module_hash": "408a69328d2345302fe3c5c06f83a226",
        "dataset_index": 14968
      },
      "alt_ctl_56461214": {
        "rtl_code": "\nmodule alt_ctl(op,func,aluc\n    );\n\tinput [5:0] op,func;\n\toutput reg [4:0] aluc;\n\talways @* \n\tbegin\n\t\tcase(op)\n\t\t\t6'b000000 : begin case(func)6'b100000 : aluc =  0;\t6'b100001 : aluc =  1;\t6'b100010 : aluc =  2;\t6'b100011 : aluc =  3;\t6'b100100 : aluc =  4;\t6'b100101 : aluc =  5;\t6'b100110 : aluc =  6;\t6'b100111 : aluc =  7; 6'b101010 : aluc =  8;\t6'b101011 : aluc =  9;\t6'b000000 : aluc = 10;\t6'b000010 : aluc = 11;\t6'b000011 : aluc = 12;\t6'b000100 : aluc = 10;\t6'b000110 : aluc = 11;\t6'b000111 : aluc = 12;\t6'b000001 : aluc = 13;\t6'b000010 : aluc = 13;\tdefault   : aluc =  0;\n\t\t\t\tendcase\n\t\t\tend 6'b001000 : aluc =  0;\t6'b001001 : aluc =  1;\t6'b001100 : aluc =  4;\t6'b001101 : aluc =  5;\t6'b001101 : aluc =  6;\t6'b001010 : aluc =  8;\t6'b001101 : aluc =  9;\t6'b001111 : aluc =  14;default : aluc = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n",
        "module_name": "alt_ctl",
        "module_hash": "56461214e23f24a16ffd3a00424dd4ad",
        "dataset_index": 5376
      },
      "Mux_3x1_bv2 #_93e14cc5": {
        "rtl_code": "module Mux_3x1_bv2 #(parameter W=32)\n(\n//Input Signals\ninput wire [1:0] select,\ninput wire [W-1:0] ch_0,\ninput wire [W-1:0] ch_1,\ninput wire [W-1:0] ch_2,\n//Output Signals\noutput reg [W-1:0] data_out\n);\n    always @*\n        begin\n            case(select)\n                2'b00: data_out <= {W{1'b0}};\n                2'b01: data_out <= ch_0;\n                2'b10: data_out <= ch_1;\n                2'b11: data_out <= ch_2;\n                default : data_out <= ch_0;\n            endcase\n        end\nendmodule",
        "module_name": "Mux_3x1_bv2 #",
        "module_hash": "93e14cc55e3454c57c1ee220c3513937",
        "dataset_index": 10099
      },
      "ripple_add_sub_04b32259": {
        "rtl_code": "module ripple_add_sub (\n    input clk,\n    input reset,\n    input [15:0] A,\n    input [15:0] B,\n    input select,\n    output reg [15:0] S,\n    output reg O\n);\n\nwire [15:0] B_complement;\nwire [16:0] sum_subtract;\nwire [16:0] sum_add;\n\nassign B_complement = select ? ~B + 1'b1 : B; \nassign sum_add = {1'b0, A} + {1'b0, B_complement}; // Include initial carry 0\nassign sum_subtract = {1'b0, A} + {1'b0, B_complement} + (select ? 16'b0 : 1'b1); // Add extra 1 only in addition mode\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        S <= 16'b0;\n        O <= 1'b0;\n    end else begin\n        if (select) begin // subtraction mode\n            S <= sum_subtract[15:0];\n            O <= sum_subtract[16] ^ sum_subtract[15]; \n        end else begin // addition mode\n            S <= sum_add[15:0];\n            O <= sum_add[16]; // Carry out for addition\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "ripple_add_sub",
        "module_hash": "04b3225998516c48f866b83b07f30321",
        "dataset_index": 20322
      },
      "and3_52b2d17f": {
        "rtl_code": "module and3 (\n    input a,\n    input b,\n    input c,\n    output y\n);\n\n    wire and1_out;\n    wire and2_out;\n    wire and3_out;\n\n    and2 and1(.a(a), .b(b), .y(and1_out));\n    and2 and2(.a(and1_out), .b(c), .y(and2_out));\n    and2 and3(.a(and2_out), .b(and1_out), .y(y));\n\nendmodule\n\nmodule and2(a, b, y);\ninput a, b;\noutput y;\n\nassign y = a&b;\n\nendmodule",
        "module_name": "and3",
        "module_hash": "52b2d17f97aaacf66d19498a1bba7313",
        "dataset_index": 9982
      },
      "sum_first_last_16_bits_be5c2c87": {
        "rtl_code": "module sum_first_last_16_bits (\n    input [31:0] in_signal,\n    output [15:0] out_signal\n);\n\n    wire [15:0] first_16_bits;\n    wire [15:0] last_16_bits;\n\n    assign first_16_bits = in_signal[31:16];\n    assign last_16_bits = in_signal[15:0];\n\n    assign out_signal = first_16_bits + last_16_bits;\n\nendmodule",
        "module_name": "sum_first_last_16_bits",
        "module_hash": "be5c2c87a3a7af5768bb544ef89db449",
        "dataset_index": 19864
      },
      "two_bit_encoder_dbe177f5": {
        "rtl_code": "module two_bit_encoder(\n    input [1:0] data,\n    output reg q,\n    output reg zero\n);\n\nalways @(*) begin\n    q = ~data[0];\n    zero = ~(data[0] | data[1]);\nend\n\nendmodule",
        "module_name": "two_bit_encoder",
        "module_hash": "dbe177f56157853243ad80bd478cc72f",
        "dataset_index": 2924
      },
      "note2dds_3st_gen_01935805": {
        "rtl_code": "module note2dds_3st_gen(CLK, NOTE, ADDER);\n\ninput wire CLK;\ninput wire [6:0] NOTE;\noutput [31:0] ADDER;\n\nreg [31:0] ADDER_tbl [15:0];\nreg [3:0] addr;\nreg [3:0] divider;\n\ninitial begin\n   addr <= 4'd012;\n\tdivider <= 4'd0;\n\tADDER_tbl[ 4'd0] <= 32'd0359575;\n\tADDER_tbl[ 4'd1] <= 32'd0380957;\n\tADDER_tbl[ 4'd2] <= 32'd0403610;\n\tADDER_tbl[ 4'd3] <= 32'd0427610;\n\tADDER_tbl[ 4'd4] <= 32'd0453037;\n\tADDER_tbl[ 4'd5] <= 32'd0479976;\n\tADDER_tbl[ 4'd6] <= 32'd0508516;\n\tADDER_tbl[ 4'd7] <= 32'd0538754;\n\tADDER_tbl[ 4'd8] <= 32'd0570790;\n\tADDER_tbl[ 4'd9] <= 32'd0604731;\n\tADDER_tbl[4'd10] <= 32'd0640691;\n\tADDER_tbl[4'd11] <= 32'd0678788;\n\tADDER_tbl[4'd12] <= 32'd0;\n\tADDER_tbl[4'd13] <= 32'd0;\n\tADDER_tbl[4'd14] <= 32'd0;\n\tADDER_tbl[4'd15] <= 32'd0;\nend\n\nassign ADDER = ADDER_tbl[addr] >> divider;\n\n\nwire [6:0] note_a = (NOTE <  12) ? NOTE :\n\t\t\t\t\t     (NOTE <  24) ? NOTE - 7'd012 :\n\t\t\t\t\t     (NOTE <  36) ? NOTE - 7'd024 :\n\t\t\t\t\t     (NOTE <  48) ? NOTE - 7'd036 :\n\t\t\t\t\t     (NOTE <  60) ? NOTE - 7'd048 :\n\t\t\t\t\t     (NOTE <  72) ? NOTE - 7'd060 :\n\t\t\t\t\t     (NOTE <  84) ? NOTE - 7'd072 :\n\t\t\t\t\t     (NOTE <  96) ? NOTE - 7'd084 :\n\t\t\t\t\t     (NOTE < 108) ? NOTE - 7'd096 :\n\t\t\t\t\t     (NOTE < 120) ? NOTE - 7'd0108 : NOTE - 7'd0120 ;\n\nwire [3:0] div_val = (NOTE <  12) ? 4'd010 :\n\t\t\t\t\t     (NOTE <  24) ? 4'd09 :\n\t\t\t\t\t     (NOTE <  36) ? 4'd08 :\n\t\t\t\t\t     (NOTE <  48) ? 4'd07 :\n\t\t\t\t\t     (NOTE <  60) ? 4'd06 :\n\t\t\t\t\t     (NOTE <  72) ? 4'd05 :\n\t\t\t\t\t     (NOTE <  84) ? 4'd04 :\n\t\t\t\t\t     (NOTE <  96) ? 4'd03 :\n\t\t\t\t\t     (NOTE < 108) ? 4'd02 :\n\t\t\t\t\t     (NOTE < 120) ? 4'd01 : 4'd00 ;\n\n\t\t\t\t\t\t  \nalways @ (posedge CLK) begin\n\taddr <= note_a[3:0];\n\tdivider <= div_val;\nend\n\nendmodule\n",
        "module_name": "note2dds_3st_gen",
        "module_hash": "01935805530352ce6bc7336585ea1642",
        "dataset_index": 24217
      },
      "mux_multiply_e463755c": {
        "rtl_code": "\nmodule mux_multiply (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    input sel,\n    output [7:0] out\n);\n\n    wire [3:0] selected_input;\n    wire [7:0] product;\n\n    // 2-to-1 multiplexer\n    mux2to1 mux (\n        .in_0(in_0),\n        .in_1(in_1),\n        .sel(sel),\n        .out(selected_input)\n    );\n\n    // Arithmetic module for multiplication\n    multiplier mult (\n        .in_0(selected_input),\n        .in_1(selected_input),\n        .out(product)\n    );\n\n    assign out = product;\n\nendmodule\nmodule mux2to1 (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    input sel,\n    output [3:0] out\n);\n\n    assign out = sel ? in_1 : in_0;\n\nendmodule\nmodule multiplier (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    output [7:0] out\n);\n\n    assign out = in_0 * in_1;\n\nendmodule",
        "module_name": "mux_multiply",
        "module_hash": "e463755cfd442e8e8343739a23b08a0b",
        "dataset_index": 1947
      },
      "instr_buffer_143a4f37": {
        "rtl_code": "module instr_buffer(\n      fetch_rd_en,\n      fetch_addr,\n      fetch_tag,\n      fetchwave_ack,\n      wave_instr,\n      wave_tag,\n      clk,\n      rst\n );\n\nparameter NUMOFCU = 1;\n\ninput clk;\n\ninput rst;\n\ninput [(NUMOFCU - 1):0] fetch_rd_en;\ninput [(NUMOFCU*32 - 1):0] fetch_addr;\ninput [(NUMOFCU*39 - 1):0] fetch_tag;\n\noutput [(NUMOFCU - 1):0] fetchwave_ack;\noutput [(NUMOFCU*32 - 1):0] wave_instr;\noutput [(NUMOFCU*39 - 1):0] wave_tag;\n\nreg [(NUMOFCU - 1):0] fetchwave_ack;\nreg [(NUMOFCU*32 - 1):0] wave_instr;\nreg [(NUMOFCU*39 - 1):0] wave_tag;\n\nreg [7:0] instr_memory[10000];\n\ninteger i;\n\nalways @ (posedge clk)\n\tfor(i = 0; i < NUMOFCU; i++) begin\n\t\tif (~rst & fetch_rd_en[i]) begin\n\t\t\twave_instr[(i*32 + 7)-:8] = instr_memory[fetch_addr[(i*32 + 31)-:32]];\n\t\t\twave_instr[(i*32 + 15)-:8] = instr_memory[fetch_addr[(i*32 + 31)-:32] + 1];\n\t\t\twave_instr[(i*32 + 23)-:8] = instr_memory[fetch_addr[(i*32 + 31)-:32] + 2];\n\t\t\twave_instr[(i*32 + 31)-:8] = instr_memory[fetch_addr[(i*32 + 31)-:32] + 3];\n\n\t\t\twave_tag[(i*39 + 38)-:39] = fetch_tag[(i*39 + 38)-:39];\n\t\t\tfetchwave_ack[i] = 1'b1;\n\t\tend\n\t\telse begin\n\t\t\twave_tag[(i*39 + 38)-:39] = 39'bx;\n\t\t\tfetchwave_ack[i] = 1'b0;\n\t\tend\n\tend\n\nendmodule\n\n",
        "module_name": "instr_buffer",
        "module_hash": "143a4f37e4e35bdfd6a65d69fe187460",
        "dataset_index": 25728
      },
      "motor_controller_5fd78527": {
        "rtl_code": "module motor_controller (\n  input clk,\n  input [7:0] pwm_width,\n  input dir,\n  output pwm,\n  output hbridge_out1,\n  output hbridge_out2\n);\n\nparameter pwm_freq = 100000; // PWM frequency in Hz\nparameter max_pwm_width = 255; // maximum PWM width\nparameter hbridge_deadband = 10; // deadband time for the H-bridge circuit in ns\n\nreg [7:0] pwm_counter;\nreg pwm_out;\nreg hbridge_dir;\n\nalways @(posedge clk) begin\n  // PWM counter\n  if (pwm_counter == max_pwm_width) begin\n    pwm_counter <= 0;\n    pwm_out <= 0;\n  end else if (pwm_counter < pwm_width) begin\n    pwm_counter <= pwm_counter + 1;\n    pwm_out <= 1;\n  end else begin\n    pwm_counter <= pwm_counter + 1;\n    pwm_out <= 0;\n  end\n  \n  // H-bridge direction\n  if (dir == 0) begin\n    hbridge_dir <= 1;\n  end else begin\n    hbridge_dir <= 0;\n  end\nend\n\nassign pwm = pwm_out;\nassign hbridge_out1 = hbridge_dir;\nassign hbridge_out2 = ~hbridge_dir;\n\nendmodule",
        "module_name": "motor_controller",
        "module_hash": "5fd7852710b294b3ef80a53891ebcd86",
        "dataset_index": 2129
      },
      "D_posedge_async_1074b64d": {
        "rtl_code": "module D_posedge_async(output Q, Qn, input rst_l, input D, input clk);\n\n  reg Q_reg, Qn_reg;\n\n  always @ (posedge clk) begin\n    if (!rst_l) begin\n      Q_reg <= 0;\n      Qn_reg <= 1;\n    end\n    else begin\n      Q_reg <= D;\n      Qn_reg <= ~D;\n    end\n  end\n\n  assign Q = Q_reg;\n  assign Qn = Qn_reg;\n\nendmodule",
        "module_name": "D_posedge_async",
        "module_hash": "1074b64dafb4c626d80e093bc4000f8a",
        "dataset_index": 3331
      },
      "mealy_state_machine_1f52754f": {
        "rtl_code": "module mealy_state_machine (\n  input clk,\n  input reset,\n  input a,\n  input b,\n  output reg x,\n  output reg y\n);\n\n  parameter S0 = 3'b001;\n  parameter S1 = 3'b010;\n  parameter S2 = 3'b100;\n\n  reg [2:0] state, next_state;\n\n  always @(*) begin\n    case(state)\n      S0: begin\n        if(a == 1) next_state = S1;\n        else next_state = S0;\n      end\n      S1: begin\n        if(b == 0) next_state = S2;\n        else next_state = S0;\n      end\n      S2: begin\n        if(a == 1) next_state = S1;\n        else next_state = S2;\n      end\n    endcase\n  end\n\n  always @(*) begin\n    case(state)\n      S0: begin\n        x = 0;\n        y = 0;\n      end\n      S1: begin\n        x = 1;\n        y = 0;\n      end\n      S2: begin\n        x = 0;\n        y = 1;\n      end\n    endcase\n  end\n\n  always @(posedge clk, posedge reset) begin\n    if(reset) state <= S0;\n    else state <= next_state;\n  end\n\nendmodule\n",
        "module_name": "mealy_state_machine",
        "module_hash": "1f52754f1f961667f2579d24ddc582f3",
        "dataset_index": 13840
      },
      "shifter_5a50bf47": {
        "rtl_code": "\nmodule shifter (\n    input [31:0] data_in,\n    input [4:0] shift_amount,\n    input [1:0] shift_direction,\n    output [31:0] result,\n    output zero\n);\n\nreg [31:0] stage1_out, stage2_out, stage3_out;\n\nalways @(*) begin\n    case (shift_direction)\n        2'b00: stage1_out = data_in >> shift_amount; // logical right shift\n        2'b01: stage1_out = data_in << shift_amount; // logical left shift\n        2'b10: stage1_out = { {32{data_in[31]}}, data_in[31:shift_amount] }; // arithmetic right shift\n        default: stage1_out = 0;\n    endcase\nend\n\nalways @(*) begin\n    stage2_out = stage1_out;\nend\n\nalways @(*) begin\n    stage3_out = stage2_out;\nend\n\nassign result = stage3_out;\nassign zero = (result == 0);\n\nendmodule",
        "module_name": "shifter",
        "module_hash": "5a50bf47a368c8415962284ba18f35db",
        "dataset_index": 11491
      },
      "fsm_module_65dd1044": {
        "rtl_code": "module fsm_module(\n  input div_clock,\n  input reset,\n  output enable_cuenta,\n  output write_enable,\n  output write_value_reg_en,\n  output read_value_reg_en,\n  output led_write,\n  output led_read,\n  output [3:0] estado\n);\n\n  // Define the states of the FSM\n  parameter STATE_0 = 0;\n  parameter STATE_1 = 1;\n  parameter STATE_2 = 2;\n  parameter STATE_3 = 3;\n  parameter STATE_4 = 4;\n\n  // Define the current state of the FSM\n  reg [3:0] state;\n\n  // Set the initial state of the FSM\n  initial begin\n    state <= -1;\n  end\n\n  // Advance the FSM on the rising edge of div_clock or reset\n  always @(posedge div_clock or posedge reset) begin\n    if (reset) begin\n      state <= -1;\n    end else begin\n      case (state)\n        STATE_0: begin\n          state <= STATE_1;\n        end\n        STATE_1: begin\n          state <= STATE_2;\n        end\n        STATE_2: begin\n          state <= STATE_3;\n        end\n        STATE_3: begin\n          state <= STATE_4;\n        end\n        STATE_4: begin\n          state <= STATE_0;\n        end\n        default: begin\n          state <= STATE_0;\n        end\n      endcase\n    end\n  end\n\n  // Define the outputs of the FSM\n  assign estado = state;\n  assign enable_cuenta = (state == STATE_4);\n  assign write_enable = ~(state == STATE_1);\n  assign write_value_reg_en = (state == STATE_1);\n  assign read_value_reg_en = (state == STATE_3);\n  assign led_write = (state == STATE_0) || (state == STATE_1) || (state == STATE_2);\n  assign led_read = (state == STATE_3) || (state == STATE_4);\n\nendmodule",
        "module_name": "fsm_module",
        "module_hash": "65dd1044b53d28e6a6a6cc8a112f7a17",
        "dataset_index": 10741
      },
      "vga_16ec459d": {
        "rtl_code": "module vga(\n    clk,\n    reset,\n\n    h_counter_next,\n    h_sync,\n\n    v_counter_next,\n    v_sync,\n\n    will_display\n);\n    parameter HORIZONTAL_SYNC_POLARITY = 1'b0;\n    parameter TIME_HORIZONTAL_VIDEO = 640;\n    parameter TIME_HORIZONTAL_FRONT_PORCH = 16;\n    parameter TIME_HORIZONTAL_SYNC_PULSE = 96;\n    parameter TIME_HORIZONTAL_BACK_PORCH = 48;\n    parameter TIME_HORIZONTAL =\n        TIME_HORIZONTAL_VIDEO +\n        TIME_HORIZONTAL_FRONT_PORCH +\n        TIME_HORIZONTAL_SYNC_PULSE +\n        TIME_HORIZONTAL_BACK_PORCH;\n\n    parameter VERTICAL_SYNC_POLARITY = 1'b0;\n    parameter TIME_VERTICAL_VIDEO = 480;\n    parameter TIME_VERTICAL_FRONT_PORCH = 10;\n    parameter TIME_VERTICAL_SYNC_PULSE = 2;\n    parameter TIME_VERTICAL_BACK_PORCH = 33;\n    parameter TIME_VERTICAL =\n        TIME_VERTICAL_VIDEO +\n        TIME_VERTICAL_FRONT_PORCH +\n        TIME_VERTICAL_SYNC_PULSE +\n        TIME_VERTICAL_BACK_PORCH;\n\n    parameter HORIZONTAL_COUNTER_WIDTH = 10;\n    parameter VERTICAL_COUNTER_WIDTH = 10;\n\n\n    input clk, reset;\n    output reg [HORIZONTAL_COUNTER_WIDTH-1:0] h_counter_next;\n    output h_sync;\n    output reg [VERTICAL_COUNTER_WIDTH-1:0] v_counter_next;\n    output v_sync;\n    output will_display;\n\n    reg [HORIZONTAL_COUNTER_WIDTH-1:0] h_counter;\n    reg [VERTICAL_COUNTER_WIDTH-1:0] v_counter;\n\n    assign h_sync =\n        ((h_counter >= (TIME_HORIZONTAL_VIDEO + TIME_HORIZONTAL_FRONT_PORCH)) &&\n            (h_counter < (TIME_HORIZONTAL_VIDEO + TIME_HORIZONTAL_FRONT_PORCH + TIME_HORIZONTAL_SYNC_PULSE))) ?\n        HORIZONTAL_SYNC_POLARITY : ~HORIZONTAL_SYNC_POLARITY;\n\n    assign v_sync =\n        ((v_counter >= (TIME_VERTICAL_VIDEO + TIME_VERTICAL_FRONT_PORCH)) &&\n            (v_counter < (TIME_VERTICAL_VIDEO + TIME_VERTICAL_FRONT_PORCH + TIME_VERTICAL_SYNC_PULSE))) ?\n        VERTICAL_SYNC_POLARITY : ~VERTICAL_SYNC_POLARITY;\n\n    assign will_display = h_counter_next < TIME_HORIZONTAL_VIDEO && v_counter_next < TIME_VERTICAL_VIDEO;\n\n    always @* begin\n        if (reset) begin\n            h_counter_next = 0;\n            v_counter_next = 0;\n        end else begin\n            if (h_counter == TIME_HORIZONTAL - 1) begin\n                h_counter_next = 0;\n                if (v_counter == TIME_VERTICAL - 1)\n                    v_counter_next = 0;\n                else\n                    v_counter_next = v_counter + 1;\n            end else\n                h_counter_next = h_counter + 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        h_counter <= h_counter_next;\n        v_counter <= v_counter_next;\n    end\nendmodule\n",
        "module_name": "vga",
        "module_hash": "16ec459de1961f9ed7957501ab208be9",
        "dataset_index": 10959
      },
      "bcd_counter_and_gate_bc0cae57": {
        "rtl_code": "\nmodule bcd_counter_and_gate(\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input a, \n    input b,\n    output reg [3:0] ena,\n    output reg [15:0] q\n);\n\nreg [3:0] count;\nwire and_result;\nwire [3:0] bcd_out;\n\n// Modulo-10 counter for each digit\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        if (ena[3]) begin\n            count[3] <= count[3] + 1;\n        end\n        if (ena[2]) begin\n            count[2] <= count[2] + 1;\n        end\n        if (ena[1]) begin\n            count[1] <= count[1] + 1;\n        end\n        if (ena[0]) begin\n            count[0] <= count[0] + 1;\n        end\n    end\nend\n\n// Combinational circuit to convert binary to BCD\nassign bcd_out = {count[3], count[2], count[1], count[0]} + (count[3] >= 5 || count[2] >= 5 || count[1] >= 5 || count[0] >= 5 ? 4'b0110 : 4'b0000);\n\n// AND gate module\nand_gate and_gate_inst(\n    .a(a),\n    .b(b),\n    .out(and_result)\n);\n\n// Final output module\nalways @(*) begin\n  q = bcd_out & {4{and_result}};\n  ena = 4'b1111;\nend\n\nendmodule\nmodule and_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule",
        "module_name": "bcd_counter_and_gate",
        "module_hash": "bc0cae573b0fbe5878c4d15f62d82a08",
        "dataset_index": 14844
      },
      "operation_block_8cca89ed": {
        "rtl_code": "module operation_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0] o_data0;\n\n  // Wires:\n  wire [31:0]\n    w1,\n    w2048,\n    w2047,\n    w4,\n    w2043,\n    w32,\n    w2011,\n    w32176,\n    w30165;\n\n  // Operations:\n  assign w1 = i_data0 << 11;\n  assign w2048 = i_data0 * 2048;\n  assign w4 = i_data0 << 2;\n  assign w2047 = w2048 - w1;\n  assign w2043 = w2047 - w4;\n  assign w32 = i_data0 << 5;\n  assign w2011 = w2043 - w32;\n  assign w32176 = w2011 << 4;\n  assign w30165 = w32176 - w2011;\n\n  // Output:\n  assign o_data0 = w30165;\n\nendmodule",
        "module_name": "operation_block",
        "module_hash": "8cca89ed358ece92b1a6f56f84a909e8",
        "dataset_index": 6763
      },
      "top__86a427c5": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input [1:0] shift_direction,\n    input load,\n    input slowena,\n    output [11:0] output_sum\n);\n\n    reg [7:0] shift_reg;\n    reg [3:0] johnson_counter;\n    reg [11:0] sum;\n\n    always @(negedge clk or posedge reset) begin\n        if (reset) begin\n            shift_reg <= 8'b00110100;\n            johnson_counter <= 4'b0000;\n            sum <= 12'b0;\n        end else begin\n            if (load) begin\n                shift_reg <= data_in;\n            end else begin\n                if (shift_direction == 2'b00) begin\n                    shift_reg <= {shift_reg[6:0], shift_reg[7]};\n                end else if (shift_direction == 2'b01) begin\n                    shift_reg <= {shift_reg[0], shift_reg[7:1]};\n                end\n            end\n\n            if (slowena) begin\n                johnson_counter <= johnson_counter + 1;\n            end\n\n            sum <= {shift_reg, johnson_counter};\n        end\n    end\n\n    assign output_sum = sum;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "86a427c5b2bf3bb81f2cccf8a1a090f2",
        "dataset_index": 4396
      },
      "signed_gte_4bit_4b4611a4": {
        "rtl_code": "module signed_gte_4bit (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input clk,\n    output reg GTE\n);\n\nreg signed [3:0] A_reg, B_reg;\nreg [1:0] stage;\n\nalways @(posedge clk) begin\n    case(stage)\n        2'b00: begin\n            A_reg <= A;\n            B_reg <= B;\n            stage <= 2'b01;\n        end\n        2'b01: begin\n            if (A_reg >= B_reg)\n                GTE <= 1;\n            else\n                GTE <= 0;\n            stage <= 2'b00;\n        end\n    endcase;\nend\n\nendmodule",
        "module_name": "signed_gte_4bit",
        "module_hash": "4b4611a4e1a100944534143a20a85d63",
        "dataset_index": 6387
      },
      "adder_4bit_fa24311d": {
        "rtl_code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [3:0] carry;\nassign carry[0] = cin;\nassign carry[1] = a[0] & b[0] | a[0] & cin | b[0] & cin;\nassign carry[2] = a[1] & b[1] | a[1] & carry[1] | b[1] & carry[1];\nassign carry[3] = a[2] & b[2] | a[2] & carry[2] | b[2] & carry[2];\n\nassign sum[0] = a[0] ^ b[0] ^ cin;\nassign sum[1] = a[1] ^ b[1] ^ carry[1];\nassign sum[2] = a[2] ^ b[2] ^ carry[2];\nassign sum[3] = a[3] ^ b[3] ^ carry[3];\n\nassign cout = carry[3];\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "fa24311d3c254fd78000c7fbac5d6ffc",
        "dataset_index": 8017
      },
      "arithmetic_unit_00e072a8": {
        "rtl_code": "module arithmetic_unit(\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op,\n    output [31:0] result\n);\n\n    wire [15:0] sum;\n    wire [15:0] diff;\n    wire [15:0] and_result;\n\n    assign sum = a + b;\n    assign diff = a - b;\n    assign and_result = a & b;\n\n    // Priority Encoder to select operation based on op input\n    wire [1:0] op_priority;\n    assign op_priority = op == 2'b10 ? 2'b10 : op == 2'b01 ? 2'b01 : 2'b00;\n\n    // Multiplexer to select appropriate operation\n    wire [31:0] mux_result;\n    assign mux_result = op_priority == 2'b10 ? {16'd0, and_result} : op_priority == 2'b01 ? {16'd0, diff} : {16'd0, sum};\n\n    // Output result\n    assign result = mux_result;\n\nendmodule\n\nmodule top_module(\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op,\n    output [31:0] result\n);\n\n    arithmetic_unit au(\n        .a(a),\n        .b(b),\n        .op(op),\n        .result(result)\n    );\n\nendmodule",
        "module_name": "arithmetic_unit",
        "module_hash": "00e072a8ad0fe3039d40d255efcb795c",
        "dataset_index": 2659
      },
      "Mux4_1_3_0634f7fb": {
        "rtl_code": "module Mux4_1_3(\ninput  [2:0]Data0,Data1,Data2,Data3,\ninput [1:0] Sel,\noutput [2:0]Data\n);\n\nassign Data = (Sel[1] == 1'b0)?((Sel[0] == 1'b0)?(Data0):(Data1)):((Sel[0] == 1'b0)?(Data2):(Data3));\n\nendmodule\n\nmodule HazardControl(\ninput EX_MEM_Branch,\ninput Jump,\ninput MemWBSrc,input RsRead,RtRead,input[4:0] Rs_From_IF_ID,Rt_From_IF_ID,\ninput[4:0] Rt_From_ID_EX,\noutput IF_ID_stall,ID_EX_stall,EX_MEM_stall,MEM_WB_stall,\noutput  IF_ID_flush,ID_EX_flush,EX_MEM_flush,MEM_WB_flush,\noutput [2:0]PCSrc\n);\nwire LoadUse;\nassign LoadUse = ((RsRead === 1'b1 && Rt_From_ID_EX === Rs_From_IF_ID )||(RtRead === 1'b1 && Rt_From_ID_EX === Rt_From_IF_ID)) && (MemWBSrc === 1'b1);\n\nMux4_1_3 mux_PCSrc(3'b000,3'b010,3'b001,3'b010,{(Jump === 1'b1),(EX_MEM_Branch === 1'b1)},PCSrc);\nassign IF_ID_stall = (LoadUse)?1'b1:1'b0;\nassign ID_EX_stall = 1'b0;\nassign EX_MEM_stall = 1'b0;\nassign MEM_WB_stall = 1'b0;\nassign IF_ID_flush = 1'b0;\nassign ID_EX_flush = ((Jump === 1'b1)|(EX_MEM_Branch === 1'b1)|LoadUse)?1'b1:1'b0;\nassign EX_MEM_flush = (EX_MEM_Branch === 1'b1)?1'b1:1'b0;\nassign MEM_WB_flush = 1'b0;\n\nendmodule\n//1539704193",
        "module_name": "Mux4_1_3",
        "module_hash": "0634f7fb11ff1da0cad13731b16e4a53",
        "dataset_index": 23682
      },
      "barrel_shifter_610bbfc2": {
        "rtl_code": "module barrel_shifter (\n  input clk,\n  input reset,\n  input [15:0] data,\n  input [3:0] shift_amount,\n  input load,\n  input ena,\n  output reg [15:0] q\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      q <= 16'b0;\n    end else if (load) begin\n      q <= data;\n    end else if (ena) begin\n      case (shift_amount)\n        4'b0001: q <= {q[14:0], 1'b0};\n        4'b0010: q <= {q[13:0], 2'b00};\n        4'b0011: q <= {q[12:0], 3'b000};\n        4'b0100: q <= {q[11:0], 4'b0000};\n        4'b0101: q <= {q[10:0], 5'b00000};\n        4'b0110: q <= {q[9:0], 6'b000000};\n        4'b0111: q <= {q[8:0], 7'b0000000};\n        4'b1000: q <= {q[7:0], 8'b00000000};\n        4'b1001: q <= {q[6:0], 9'b000000000};\n        4'b1010: q <= {q[5:0], 10'b0000000000};\n        4'b1011: q <= {q[4:0], 11'b00000000000};\n        4'b1100: q <= {q[3:0], 12'b000000000000};\n        4'b1101: q <= {q[2:0], 13'b0000000000000};\n        4'b1110: q <= {q[1:0], 14'b00000000000000};\n        4'b1111: q <= {q[0], 15'b000000000000000};\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "610bbfc2c2ac9afcb9efde222be5a0d2",
        "dataset_index": 17477
      },
      "dma_access_d8630ddd": {
        "rtl_code": "module dma_access(\n\n\tinput            clk,\n\n\tinput            rst_n,\n\n\n\tinput            dma_req,  input     [21:0] dma_addr, input            dma_rnw,  input      [7:0] dma_wd,   output reg [7:0] dma_rd,   output reg       dma_busynready, output reg       dma_ack, output reg       dma_end, output wire        mem_dma_bus,  output wire [21:0] mem_dma_addr, output wire  [7:0] mem_dma_wd,   input        [7:0] mem_dma_rd,   output wire        mem_dma_rnw,  output reg         mem_dma_oe,   output reg         mem_dma_we,   output reg       busrq_n, input            busak_n  );\n\n\treg dma_bus;\n\n\treg [21:0] int_dma_addr;\n\treg        int_dma_rnw;\n\treg  [7:0] int_dma_wd;\n\twire [7:0] int_dma_rd;\n\n\tassign mem_dma_bus  = dma_bus;\n\tassign mem_dma_addr = int_dma_addr;\n\tassign mem_dma_wd   = int_dma_wd;\n\tassign mem_dma_rnw  = int_dma_rnw;\n\tassign int_dma_rd   = mem_dma_rd;\n\n\n\n\tlocalparam IDLE     = 0;\n\tlocalparam START    = 1;\n\tlocalparam WACK     = 2;\n\tlocalparam READ1    = 3;\n\tlocalparam READ2    = 4;\n\tlocalparam WRITE1   = 5;\n\tlocalparam WRITE2   = 6;\n\n\n\treg [3:0] state;\n\treg [3:0] next_state;\n\n\n\n\n\tinitial\n\tbegin\n\t\tstate       <= IDLE;\n\t\tbusrq_n     <= 1'b1;\n\t\tmem_dma_oe  <= 1'b1;\n\t\tmem_dma_we  <= 1'b1;\n\tend\n\n\nalways @(posedge clk, negedge rst_n)\n\tbegin\n\t\tif( !rst_n )\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\n\talways @*\n\tbegin\n\t\tcase( state )\nIDLE:\n\t\tbegin\n\t\t\tif( dma_req==1'b1 )\n\t\t\t\tnext_state <= START;\n\t\t\telse\n\t\t\t\tnext_state <= IDLE;\n\t\tend\nSTART:\n\t\tbegin\n\t\t\tnext_state <= WACK;\n\t\tend\nWACK:\n\t\tbegin\n\t\t\tif( busak_n == 1'b1 ) next_state <= WACK;\n\t\t\telse begin\n\t\t\t\tif( int_dma_rnw == 1'b1 ) next_state <= READ1;\n\t\t\t\telse next_state <= WRITE1;\n\t\t\tend\n\t\tend\nREAD1:\n\t\tbegin\n\t\t\tnext_state <= READ2;\n\t\tend\nREAD2:\n\t\tbegin\n\t\t\tif( dma_req == 1'b0 )\n\t\t\t\tnext_state <= IDLE;\n\t\t\telse begin\n\t\t\t\tif( dma_rnw == 1'b1 ) next_state <= READ1;\n\t\t\t\telse next_state <= WRITE1;\n\t\t\tend\n\t\tend\nWRITE1:\n\t\tbegin\n\t\t\tnext_state <= WRITE2;\n\t\tend\nWRITE2:\n\t\tbegin\n\t\t\tif( dma_req == 1'b0 )\n\t\t\t\tnext_state <= IDLE;\n\t\t\telse begin\n\t\t\t\tif( dma_rnw == 1'b1 ) next_state <= READ1;\n\t\t\t\telse next_state <= WRITE1;\n\t\t\tend\n\t\tend\nendcase\n\tend\n\n\n\talways @(posedge clk, negedge rst_n)\n\tbegin\n\t\tif( !rst_n )\n\t\tbegin\n\t\t\tbusrq_n        <= 1'b1;\n\t\t\tdma_busynready <= 1'b0;\n\t\t\tdma_ack        <= 1'b0;\n\t\t\tdma_end        <= 1'b0;\n\t\t\tdma_bus        <= 1'b0;\n\t\t\tmem_dma_oe     <= 1'b1;\n\t\tend\n\t\telse case( next_state )\nIDLE:\n\t\tbegin\n\t\t\tdma_end        <= 1'b0;\n\n\t\t\tbusrq_n        <= 1'b1;\n\t\t\tdma_bus        <= 1'b0;\n\t\t\tmem_dma_oe     <= 1'b1;\n\t\tend\nSTART:\n\t\tbegin\nbusrq_n        <= 1'b0;\n\n\t\t\tdma_busynready <= 1'b1;\n\t\t\tdma_ack        <= 1'b1;\n\n\t\t\tint_dma_rnw    <= dma_rnw;\n\t\t\tint_dma_addr   <= dma_addr;\n\t\t\tint_dma_wd     <= dma_wd;\n\t\tend\nWACK:\n\t\tbegin\n\t\t\tdma_ack <= 1'b0;\n\t\tend\nREAD1:\n\t\tbegin\n\t\t\tdma_bus    <= 1'b1; mem_dma_oe <= 1'b0;\n\t\t\tif( dma_busynready == 1'b0 ) begin\n\t\t\t\tdma_busynready <= 1'b1;\n\t\t\t\tdma_ack        <= 1'b1;\n\t\t\t\tdma_end        <= 1'b0;\n\t\t\t\tint_dma_rnw    <= 1'b1;\n\t\t\t\tint_dma_addr   <= dma_addr;\n\t\t\tend\n\t\tend\nREAD2:\n\t\tbegin\n\t\t\tdma_busynready <= 1'b0;\n\t\t\tdma_ack        <= 1'b0;\n\t\t\tdma_end        <= 1'b1;\n\t\t\tdma_rd <= int_dma_rd;\n\t\tend\nWRITE1:\n\t\tbegin\n\t\t\tdma_bus    <= 1'b1; mem_dma_oe <= 1'b1;\n\n\t\t\tif( dma_busynready == 1'b0 ) begin\n\t\t\t\tdma_busynready <= 1'b1;\n\t\t\t\tdma_ack        <= 1'b1;\n\t\t\t\tdma_end        <= 1'b0;\n\t\t\t\tint_dma_rnw    <= 1'b0;\n\t\t\t\tint_dma_addr   <= dma_addr;\n\t\t\t\tint_dma_wd     <= dma_wd;\n\t\t\tend\n\t\tend\nWRITE2:\n\t\tbegin\n\t\t\tdma_busynready <= 1'b0;\n\t\t\tdma_ack        <= 1'b0;\n\t\t\tdma_end        <= 1'b1;\n\t\tend\nendcase\n\tend\n\n\n\n\nalways @(negedge clk,negedge rst_n)\n\tbegin\n\t\tif( !rst_n )\n\t\t\tmem_dma_we <= 1'b1;\n\t\telse\n\t\tbegin\n\t\t\tif( dma_bus )\n\t\t\tbegin\n\t\t\t\tif( !int_dma_rnw )\n\t\t\t\t\tmem_dma_we <= ~mem_dma_we;\n\t\t\tend\n\t\t\telse\n\t\t\t\tmem_dma_we <= 1'b1;\n\t\tend\n\tend\n\n\nendmodule\n\n",
        "module_name": "dma_access",
        "module_hash": "d8630dddf5ea44e83ba2be6f4167306d",
        "dataset_index": 10767
      },
      "mux4to1_8825ad14": {
        "rtl_code": "module mux4to1(out, in0, in1, sel);\n    output [3:0] out;\n    input [3:0] in0, in1;\n    input [1:0] sel;\n\n    assign out = (sel == 2'b00) ? in0 :\n                 (sel == 2'b01) ? in1 :\n                 (sel == 2'b10) ? in0 :\n                                  in1;\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "8825ad14115b629a4680b3fadea3301b",
        "dataset_index": 13104
      },
      "dff_async_reset_set_enable_84cdc437": {
        "rtl_code": "\nmodule dff_async_reset_set_enable(\n    input D,\n    input CLK,\n    input RESET,\n    input SET,\n    input EN,\n    output reg Q,\n    output reg QBAR\n);\n\n    reg R = 0;\n\n    always @(posedge CLK) begin\n        if (RESET) begin\n            R <= 1'b1;\n            Q <= 1'b0;\n            QBAR <= 1'b1;\n        end \n        else if (SET) begin\n            R <= 1'b1;\n            Q <= 1'b1;\n            QBAR <= 1'b0;\n        end \n        else if (EN & ~R) begin\n            Q <= D;\n            QBAR <= ~D;\n        end\n        R <= 0;\n    end\n\nendmodule",
        "module_name": "dff_async_reset_set_enable",
        "module_hash": "84cdc437743a08b89240a1b89e32589d",
        "dataset_index": 583
      },
      "cdc_pulse_sync_e389ac46": {
        "rtl_code": "\n\n\nmodule cdc_pulse_sync (\n    input wire clk_in,\n    input wire pulse_in,\n    input wire clk_out,\n    output wire pulse_out\n);\n\nwire aq_sync;\n\nreg [1:0] in_pre_sync;\nalways@(posedge clk_in) begin\n    in_pre_sync[0] <= pulse_in;\n    in_pre_sync[1] <= in_pre_sync[0];\nend\n\nreg in_sync_pulse;\ninitial in_sync_pulse = 0; always@(posedge clk_in) begin\n    if (aq_sync)\n        in_sync_pulse <= 0;\n    else if (!in_pre_sync[1] && in_pre_sync[0])\n        in_sync_pulse <= 1;\nend\n\nreg [2:0] out_sync;\nalways@(posedge clk_out) begin\n    out_sync[0] <= in_sync_pulse;\n    out_sync[1] <= out_sync[0];\n    out_sync[2] <= out_sync[1];\nend\n\nassign pulse_out = !out_sync[2] && out_sync[1];\t\n    \nreg [1:0] aq_sync_ff;\nalways@(posedge clk_in) begin\n    aq_sync_ff[0] <= out_sync[2];\n    aq_sync_ff[1] <= aq_sync_ff[0];\nend\n\nassign aq_sync = aq_sync_ff[1];\n\nendmodule\n",
        "module_name": "cdc_pulse_sync",
        "module_hash": "e389ac46075d5d2a4a1fc9c37d6a1cb0",
        "dataset_index": 22196
      },
      "arithmetic_module_5b99750a": {
        "rtl_code": "module arithmetic_module(\n  input [7:0] A,\n  input [7:0] B,\n  input operation,\n  input reset,\n  output reg [7:0] C\n);\n\n  integer result;\n\n  always @(*) begin\n    if (reset) begin\n      C <= 8'b0;\n    end else if (operation) begin\n      result = A - B;\n      C <= result;\n    end else begin\n      result = A + B;\n      C <= result;\n    end\n  end\n\nendmodule",
        "module_name": "arithmetic_module",
        "module_hash": "5b99750ab702a1f70b1dba454fef7ed0",
        "dataset_index": 2555
      },
      "top__88b9db56": {
        "rtl_code": "\nmodule top_module (\n    input [7:0] in,\n    input clk,\n    output reg [8:0] out\n);\n\n    // Odd parity bit generator\n    reg [7:0] data_in;\n    reg parity;\n    \n    always @(posedge clk) begin\n        data_in <= in;\n        parity <= ~(^data_in); // Calculate the parity bit\n    end\n\n    // Priority encoder\n    wire [2:0] position;\n    assign position = (in == 8'b00000000) ? 3'b000 :\n                      (in == 8'b00000001) ? 3'b001 :\n                      (in == 8'b00000010) ? 3'b010 :\n                      (in == 8'b00000100) ? 3'b011 :\n                      (in == 8'b00001000) ? 3'b100 :\n                      (in == 8'b00010000) ? 3'b101 :\n                      (in == 8'b00100000) ? 3'b110 :\n                      (in == 8'b01000000) ? 3'b111 : 3'bxxx; // Handle the case when input is not a valid 8-bit number\n\n    // Final output\n    always @(posedge clk) begin\n        out[8] <= parity; // Assign the parity bit\n        out[7:5] <= position; // Assign the position of the first '1' bit\n        out[4:0] <= 5'b0; // Zero-pad the rest of the output\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "88b9db5686f25988b125212bb49ccddc",
        "dataset_index": 18028
      },
      "debounce_switch  #_504fe2f2": {
        "rtl_code": "\n\n`resetall\n\n\n\n\nmodule debounce_switch  #(\n    parameter WIDTH=1, parameter N=3, parameter RATE=125000 )(\n    input wire clk,\n    input wire rst,\n    input wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\n\nreg [23:0] cnt_reg = 24'd0;\n\nreg [N-1:0] debounce_reg[WIDTH-1:0];\n\nreg [WIDTH-1:0] state;\n\n\nassign out = state;\n\ninteger k;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        cnt_reg <= 0;\n        state <= 0;\n\n        for (k = 0; k < WIDTH; k = k + 1) begin\n            debounce_reg[k] <= 0;\n        end\n    end else begin\n        if (cnt_reg < RATE) begin\n            cnt_reg <= cnt_reg + 24'd1;\n        end else begin\n            cnt_reg <= 24'd0;\n        end\n\n        if (cnt_reg == 24'd0) begin\n            for (k = 0; k < WIDTH; k = k + 1) begin\n                debounce_reg[k] <= {debounce_reg[k][N-2:0], in[k]};\n            end\n        end\n\n        for (k = 0; k < WIDTH; k = k + 1) begin\n            if (|debounce_reg[k] == 0) begin\n                state[k] <= 0;\n            end else if (&debounce_reg[k] == 1) begin\n                state[k] <= 1;\n            end else begin\n                state[k] <= state[k];\n            end\n        end\n    end\nend\n\nendmodule\n\n`resetall\n",
        "module_name": "debounce_switch  #",
        "module_hash": "504fe2f2eb4b3176b1cb766874c94819",
        "dataset_index": 22102
      },
      "ripple_carry_adder_2e51d535": {
        "rtl_code": "module ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] OUT\n);\n\n    always @(*) begin\n        OUT = A + B;\n    end\n\nendmodule\n\nmodule barrel_shifter (\n    input [15:0] data,\n    input [3:0] shift_amount,\n    input direction,\n    output reg [15:0] q\n);\n\n    always @(*) begin\n        if (direction == 1'b0) begin // shift left\n            q = data << shift_amount;\n        end else begin // shift right\n            q = data >> shift_amount;\n        end\n    end\n\nendmodule\n\nmodule top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input [15:0] data,\n    input [3:0] shift_amount,\n    input direction,\n    output reg [15:0] q\n);\n\n    wire [3:0] adder_out;\n    wire [15:0] shifted_data;\n\n    ripple_carry_adder adder_inst (\n        .A(A),\n        .B(B),\n        .OUT(adder_out)\n    );\n\n    barrel_shifter shifter_inst (\n        .data(data),\n        .shift_amount(shift_amount),\n        .direction(direction),\n        .q(shifted_data)\n    );\n\n    always @(*) begin\n        q = adder_out + shifted_data;\n    end\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "2e51d53518d75cf278769167a727e861",
        "dataset_index": 17586
      },
      "TrafficSignalController_cbe810ab": {
        "rtl_code": "\nmodule TrafficSignalController(\n  input clk,\n  input NS_VEHICLE_DETECT,\n  input EW_VEHICLE_DETECT,\n  output reg NS_RED,\n  output reg NS_YELLOW,\n  output reg NS_GREEN,\n  output reg EW_RED,\n  output reg EW_YELLOW,\n  output reg EW_GREEN\n);\n\n  // Counters\n  reg[4:0] count1;\n  reg[3:0] count2;\n  reg[1:0] count3;\n\n  // Counter Modules\n  always @(posedge clk) begin\n    if (count1 == 31) count1 <= 0;\n    else count1 <= count1 + 1;\n  end\n\n  always @(posedge clk) begin\n    if (count2 == 15) count2 <= 0;\n    else if (EW_VEHICLE_DETECT) count2 <= count2 - 6;\n      else count2 <= count2 + 1;\n  end\n\n  always @(posedge clk) begin\n    if (count3 == 3) count3 <= 0;\n    else count3 <= count3 + 1;\n  end\n\n  // Main Traffic Module\n  always @(posedge clk) begin\n    if (count3 == 3) begin\n      // Yellow light\n      NS_YELLOW <= 1'b1;\n      EW_YELLOW <= 1'b1;\n      NS_GREEN <= 1'b0;\n      EW_GREEN <= 1'b0;\n      NS_RED <= 1'b0;\n      EW_RED <= 1'b0;\n    end\n    else if (count2 == 15) begin\n      // EW green light\n      NS_YELLOW <= 1'b0;\n      EW_YELLOW <= 1'b0;\n      NS_GREEN <= 1'b0;\n      EW_GREEN <= 1'b1;\n      NS_RED <= 1'b1;\n      EW_RED <= 1'b0;\n    end\n    else if (count1 == 31) begin\n      // NS green light\n      NS_YELLOW <= 1'b0;\n      EW_YELLOW <= 1'b0;\n      NS_GREEN <= 1'b1;\n      EW_GREEN <= 1'b0;\n      NS_RED <= 1'b0;\n      EW_RED <= 1'b1;\n    end\n    else begin\n      // Red light\n      NS_YELLOW <= 1'b0;\n      EW_YELLOW <= 1'b0;\n      NS_GREEN <= 1'b0;\n      EW_GREEN <= 1'b0;\n      NS_RED <= 1'b1;\n      EW_RED <= 1'b1;\n    end\n  end\n\nendmodule",
        "module_name": "TrafficSignalController",
        "module_hash": "cbe810abf92a0f0ccefd32e02ff2a8a1",
        "dataset_index": 3560
      },
      "ad_axis_inf_rx_b58568a9": {
        "rtl_code": "\n\nmodule ad_axis_inf_rx (\n\n  clk,\n  rst,\n  valid,\n  last,\n  data,\n\n  inf_valid,\n  inf_last,\n  inf_data,\n  inf_ready);\n\n  parameter   DATA_WIDTH = 16;\n  localparam  DW = DATA_WIDTH - 1;\n\n  input           clk;\n  input           rst;\n  input           valid;\n  input           last;\n  input   [DW:0]  data;\n\n  output          inf_valid;\n  output          inf_last;\n  output  [DW:0]  inf_data;\n  input           inf_ready;\n\n  reg     [ 2:0]  wcnt = 'd0;\n  reg             wlast_0 = 'd0;\n  reg     [DW:0]  wdata_0 = 'd0;\n  reg             wlast_1 = 'd0;\n  reg     [DW:0]  wdata_1 = 'd0;\n  reg             wlast_2 = 'd0;\n  reg     [DW:0]  wdata_2 = 'd0;\n  reg             wlast_3 = 'd0;\n  reg     [DW:0]  wdata_3 = 'd0;\n  reg             wlast_4 = 'd0;\n  reg     [DW:0]  wdata_4 = 'd0;\n  reg             wlast_5 = 'd0;\n  reg     [DW:0]  wdata_5 = 'd0;\n  reg             wlast_6 = 'd0;\n  reg     [DW:0]  wdata_6 = 'd0;\n  reg             wlast_7 = 'd0;\n  reg     [DW:0]  wdata_7 = 'd0;\n  reg     [ 2:0]  rcnt    = 'd0;\n  reg             inf_valid = 'd0;\n  reg             inf_last = 'd0;\n  reg     [DW:0]  inf_data = 'd0;\n\n  wire            inf_ready_s;\n  reg             inf_last_s;\n  reg     [DW:0]  inf_data_s;\n\n  always @(posedge clk) begin\n    if (rst == 1'b1) begin\n      wcnt <= 'd0;\n    end else if (valid == 1'b1) begin\n      wcnt <= wcnt + 1'b1;\n    end\n    if ((wcnt == 3'd0) && (valid == 1'b1)) begin\n      wlast_0 <= last;\n      wdata_0 <= data;\n    end\n    if ((wcnt == 3'd1) && (valid == 1'b1)) begin\n      wlast_1 <= last;\n      wdata_1 <= data;\n    end\n    if ((wcnt == 3'd2) && (valid == 1'b1)) begin\n      wlast_2 <= last;\n      wdata_2 <= data;\n    end\n    if ((wcnt == 3'd3) && (valid == 1'b1)) begin\n      wlast_3 <= last;\n      wdata_3 <= data;\n    end\n    if ((wcnt == 3'd4) && (valid == 1'b1)) begin\n      wlast_4 <= last;\n      wdata_4 <= data;\n    end\n    if ((wcnt == 3'd5) && (valid == 1'b1)) begin\n      wlast_5 <= last;\n      wdata_5 <= data;\n    end\n    if ((wcnt == 3'd6) && (valid == 1'b1)) begin\n      wlast_6 <= last;\n      wdata_6 <= data;\n    end\n    if ((wcnt == 3'd7) && (valid == 1'b1)) begin\n      wlast_7 <= last;\n      wdata_7 <= data;\n    end\n  end\n\n  assign inf_ready_s = inf_ready | ~inf_valid;\n\n  always @(rcnt or wlast_0 or wdata_0 or wlast_1 or wdata_1 or\n    wlast_2 or wdata_2 or wlast_3 or wdata_3 or wlast_4 or wdata_4 or\n    wlast_5 or wdata_5 or wlast_6 or wdata_6 or wlast_7 or wdata_7) begin\n    case (rcnt)\n      3'd0: begin\n        inf_last_s = wlast_0;\n        inf_data_s = wdata_0;\n      end\n      3'd1: begin\n        inf_last_s = wlast_1;\n        inf_data_s = wdata_1;\n      end\n      3'd2: begin\n        inf_last_s = wlast_2;\n        inf_data_s = wdata_2;\n      end\n      3'd3: begin\n        inf_last_s = wlast_3;\n        inf_data_s = wdata_3;\n      end\n      3'd4: begin\n        inf_last_s = wlast_4;\n        inf_data_s = wdata_4;\n      end\n      3'd5: begin\n        inf_last_s = wlast_5;\n        inf_data_s = wdata_5;\n      end\n      3'd6: begin\n        inf_last_s = wlast_6;\n        inf_data_s = wdata_6;\n      end\n      default: begin\n        inf_last_s = wlast_7;\n        inf_data_s = wdata_7;\n      end\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (rst == 1'b1) begin\n      rcnt <= 'd0;\n      inf_valid <= 'd0;\n      inf_last <= 'b0;\n      inf_data <= 'd0;\n    end else if (inf_ready_s == 1'b1) begin\n      if (rcnt == wcnt) begin\n        rcnt <= rcnt;\n        inf_valid <= 1'd0;\n        inf_last <= 1'b0;\n        inf_data <= 'd0;\n      end else begin\n        rcnt <= rcnt + 1'b1;\n        inf_valid <= 1'b1;\n        inf_last <= inf_last_s;\n        inf_data <= inf_data_s;\n      end\n    end\n  end\n\nendmodule\n\n",
        "module_name": "ad_axis_inf_rx",
        "module_hash": "b58568a982c0b85c05111997367c2c17",
        "dataset_index": 24359
      },
      "axis_infrastructure_v1_1_clock_synchronizer #_6aa083d9": {
        "rtl_code": "module axis_infrastructure_v1_1_clock_synchronizer # (\n  parameter integer C_NUM_STAGES              = 4\n)     \n(\n  input  wire                               clk,\n  input  wire                               synch_in ,\n  output wire                               synch_out\n);\n\nlocalparam integer P_SYNCH_D_WIDTH = (C_NUM_STAGES > 0) ? C_NUM_STAGES : 1;\n reg [P_SYNCH_D_WIDTH-1:0] synch_d = 'b0;\n\n  generate \n  if (C_NUM_STAGES > 0) begin : gen_synchronizer\n    genvar i;\n\n    always @(posedge clk) begin\n      synch_d[0] <= synch_in;\n    end\n\n    for (i = 1; i < C_NUM_STAGES ; i = i + 1) begin : gen_stage\n      always @(posedge clk) begin\n        synch_d[i] <= synch_d[i-1];\n      end\n    end\n\n    assign synch_out = synch_d[C_NUM_STAGES-1];\n  end\n  else begin : gen_no_synchronizer\n    assign synch_out = synch_in;\n  end\n  endgenerate\n\nendmodule",
        "module_name": "axis_infrastructure_v1_1_clock_synchronizer #",
        "module_hash": "6aa083d9861feecd63008eb368d32491",
        "dataset_index": 10466
      },
      "tiny_memory_80a5ea6b": {
        "rtl_code": "module tiny_memory(\n    input clk,\n    input reset,\n    input sel,\n    input [5:0] addr,\n    input w,\n    input [197:0] data,\n    output reg [197:0] out,\n    output reg done\n);\n\nreg [197:0] mem[63:0];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        done <= 0;\n        out <= 0;\n    end else begin\n        if (sel) begin\n            if (w) begin\n                mem[addr] <= data;\n                done <= 1;\n            end else begin\n                out <= mem[addr];\n                done <= 1;\n            end\n        end else begin\n            done <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "tiny_memory",
        "module_hash": "80a5ea6b5df0e995d34600828d8f5d8d",
        "dataset_index": 12233
      },
      "up_counter_51634cca": {
        "rtl_code": "module up_counter (\n    input CLK,\n    input CLR,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (CLR) begin\n            Q <= 4'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "51634ccab9125f4e4f95cd6ca819cde6",
        "dataset_index": 20887
      },
      "red_pitaya_iq_hpf_block #_f8ede580": {
        "rtl_code": "\n\n\nmodule red_pitaya_iq_hpf_block #(\n    parameter     ALPHABITS = 25,\n    parameter     HIGHESTALPHABIT = 18,\n    parameter     LPFBITS   = 14\n)\n(\n    input clk_i,\n    input reset_i  ,\n    input signed [HIGHESTALPHABIT-1:0] alpha_i, \n\n    input signed [LPFBITS-1:0] signal_i,\n    output signed [LPFBITS-1:0] signal_o\n);\n\nreg  signed [LPFBITS+ALPHABITS-1:0]    y;\nreg  signed [LPFBITS+ALPHABITS-1:0]    delta;   wire signed [LPFBITS+1-1:0] diff;\nreg  signed [LPFBITS-1:0]  delta_out;\nwire signed [LPFBITS-1:0]  y_out;\n\nassign y_out = y[ALPHABITS+LPFBITS-1:ALPHABITS];\nassign diff = signal_i-y_out;  \n\nalways @(posedge clk_i) begin\nif (reset_i == 1'b1) begin\n        y <=            {ALPHABITS+LPFBITS{1'b0}};\n        delta <=        {ALPHABITS+LPFBITS{1'b0}};\n        delta_out <=    {LPFBITS{1'b0}};\n    end\n    else begin\n        delta <= diff * alpha_i;\n        y <= y + delta;\n        if (diff[LPFBITS:LPFBITS-1] == 2'b01)\n            delta_out <= {1'b0,{LPFBITS-1{1'b1}}};\n        else if (diff[LPFBITS:LPFBITS-1] == 2'b10)\n            delta_out <= {1'b1,{LPFBITS-1{1'b0}}};\n        else\n            delta_out <= diff[LPFBITS-1:0];\n    end\nend\n\nassign signal_o = delta_out;\n\nendmodule\n",
        "module_name": "red_pitaya_iq_hpf_block #",
        "module_hash": "f8ede58096042835c4bfa423288cb23b",
        "dataset_index": 14665
      },
      "mux4to1_7bd08d8d": {
        "rtl_code": "module mux4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    output reg out\n);\n\nalways @(*) begin\n    case ({sel[1], sel[0]})\n        2'b00: out = in[0];\n        2'b01: out = in[1];\n        2'b10: out = in[2];\n        2'b11: out = in[3];\n    endcase\nend\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "7bd08d8d2d670040bd3440dca37aa20f",
        "dataset_index": 18586
      },
      "logic_function_5dc2b0a7": {
        "rtl_code": "module logic_function (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    input C2,\n    output reg X\n);\n\n    always @(*) begin\n        X = (A1 & A2) | (B1 & B2) | (C1 & C2);\n    end\n\nendmodule",
        "module_name": "logic_function",
        "module_hash": "5dc2b0a7235ac3241455432e51df84bd",
        "dataset_index": 3861
      },
      "diffeq_f_systemC_d72d52e6": {
        "rtl_code": "\n\nmodule diffeq_f_systemC(clk, reset, aport, dxport, xport, yport, uport);\n\ninput clk;\ninput reset;\ninput [31:0]aport;\ninput [31:0]dxport;\noutput [31:0]xport;\noutput [31:0]yport;\noutput [31:0]uport;\nreg [31:0]xport;\nreg [31:0]yport;\nreg [31:0]uport;\nwire [31:0]temp;\n\nassign temp = uport * dxport;\nalways @(posedge clk )\nbegin\n\tif (reset == 1'b1)\n\tbegin\n\t\txport <= 0;\n\t\typort <= 0;\n\t\tuport <= 0;\n\tend\nelse\n  \tif (xport < aport)\n\tbegin\n\t\txport <= xport + dxport;\n\t\typort <= yport + temp;uport <= (uport - (temp * (5 * xport))) - (dxport * (3 * yport));\n\tend\nend\nendmodule\n",
        "module_name": "diffeq_f_systemC",
        "module_hash": "d72d52e63f9264ecec6f1452b40ef346",
        "dataset_index": 4426
      },
      "dual_port_RAM_e476c3e6": {
        "rtl_code": "module dual_port_RAM (\n    input clk,\n    input rst_n,\n    input write_en,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    output reg [3:0] read_data\n);\n\nreg [3:0] mem [0:7];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        read_data <= 4'b0000;\n    end else begin\n        if (read_en) begin\n            read_data <= mem[read_addr];\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (write_en) begin\n        mem[write_addr] <= write_data;\n    end\nend\n\nendmodule",
        "module_name": "dual_port_RAM",
        "module_hash": "e476c3e6a41f4bdb7b52689c498aef8e",
        "dataset_index": 20572
      },
      "two_input__a0bc3b66": {
        "rtl_code": "module two_input_module (\n    input input1,\n    input input2,\n    input input3,\n    input input4,\n    input input5,\n    input input6,\n    input input7,\n    output reg output1\n);\n\nalways @(*) begin\n    if (input1 && input2) begin\n        output1 = 1;\n    end else if (input3 && input4) begin\n        output1 = 1;\n    end else if (input5 && input6) begin\n        output1 = 1;\n    end else if (input7) begin\n        output1 = 0;\n    end else begin\n        output1 = 0;\n    end\nend\n\nendmodule",
        "module_name": "two_input_",
        "module_hash": "a0bc3b66515f6c1e5daa30adfc3f9b55",
        "dataset_index": 13531
      },
      "fifo#_053d228a": {
        "rtl_code": "\nmodule fifo#(\n    parameter DATA_WIDTH = 8,                   // 8-bits data (default)\n    parameter ADDR_WIDTH = 8                    // 8-bits address (default)\n    )(\n    input                           clk,\n    input                           rst,\n    input                           enqueue,          // Insert data\n    input                           dequeue,          // Remove data\n    input       [(DATA_WIDTH-1):0]  data_i,           // Input data\n    output      [(DATA_WIDTH-1):0]  data_o,           // Output data\n    output reg  [(ADDR_WIDTH):0]    count,            // How many elements are in the FIFO (0->256)\n    output                          empty,            // Empty flag\n    output                          full              // Full flag\n    );\n\n    //--------------------------------------------------------------------------\n    // wires\n    //--------------------------------------------------------------------------\n    wire w_enqueue;\n    wire w_dequeue;\n    wire [(DATA_WIDTH-1):0] w_data_o;\n\n    //--------------------------------------------------------------------------\n    // registers\n    //--------------------------------------------------------------------------\n    reg [(ADDR_WIDTH-1):0] enqueue_ptr;     // Addresses for reading from and writing to internal memory\n    reg [(ADDR_WIDTH-1):0] dequeue_ptr;     // Addresses for reading from and writing to internal memory\n\n    //--------------------------------------------------------------------------\n    // Assignments\n    //--------------------------------------------------------------------------\n    assign empty     = (count == 0);\n    assign full      = (count == (1 << ADDR_WIDTH));\n    assign w_enqueue = (full)  ? 1'b0                                                   : enqueue;   // Ignore if full\n    assign w_dequeue = (empty) ? 1'b0                                                   : dequeue;   // Ignore if empty\n    assign data_o    = (empty) ? ((enqueue & dequeue) ? data_i : { DATA_WIDTH {1'b0} }) : w_data_o;  // Read description\n\n    always @(posedge clk) begin\n        if (rst) begin\n            enqueue_ptr <= 0;\n            dequeue_ptr <= 0;\n            count       <= 0;\n        end\n        else begin\n            enqueue_ptr <= (w_enqueue)              ? enqueue_ptr + 1'b1 : enqueue_ptr;\n            dequeue_ptr <= (w_dequeue)              ? dequeue_ptr + 1'b1 : dequeue_ptr;\n            count       <= (w_enqueue ~^ w_dequeue) ? count              : ((w_enqueue) ? count + 1'b1 : count - 1'b1); // Read description\n        end\n    end\n\n    ram #(DATA_WIDTH, ADDR_WIDTH) RAM(\n            .clk           (clk),\n            .we            (w_enqueue),\n            .read_address  (dequeue_ptr),\n            .write_address (enqueue_ptr),\n            .data_i        (data_i),\n            .data_o        (w_data_o)\n            );\nendmodule\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 8\n    )(\n    input                           clk,\n    input                           we,\n    input       [(ADDR_WIDTH-1):0]  read_address,\n    input       [(ADDR_WIDTH-1):0]  write_address,\n    input       [(DATA_WIDTH-1):0]  data_i,\n    output reg  [(DATA_WIDTH-1):0]  data_o\n    );\n\n    reg [DATA_WIDTH-1:0] ram_array [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (we) begin\n            ram_array[write_address] <= data_i;\n        end\n        data_o <= ram_array[read_address];\n    end\nendmodule",
        "module_name": "fifo#",
        "module_hash": "053d228a1fee362d869b8d663a275804",
        "dataset_index": 13788
      },
      "fifo_buffer #_0947aca7": {
        "rtl_code": "module fifo_buffer #(\n  parameter DATA_WIDTH = 8,\n  parameter ADDRESS_WIDTH = 8,\n  parameter FIFO_DEPTH = (1 << ADDRESS_WIDTH)\n)\n(\n  // Reading port\n  output reg [DATA_WIDTH-1:0] Data_out, \n  output reg Empty_out,\n  input wire ReadEn_in,\n  input wire RClk,        \n  // Writing port\t \n  input wire [DATA_WIDTH-1:0] Data_in,  \n  output reg Full_out,\n  input wire WriteEn_in,\n  input wire WClk,\n  input wire Clear_in\n);\n\n  // Internal connections & variables\n  reg [DATA_WIDTH-1:0] Mem [0:FIFO_DEPTH-1]; \n  reg [ADDRESS_WIDTH-1:0] pNextWordToWrite, pNextWordToRead;\n  wire EqualAddresses, NextWriteAddressEn, NextReadAddressEn;\n  wire Set_Status, Rst_Status;\n  reg Status;\n  wire PresetFull, PresetEmpty;\n\n  // Data ports logic\n  always @ (posedge RClk) begin\n    if (ReadEn_in && !Empty_out) begin\n      Data_out <= Mem[pNextWordToRead];\n    end\n  end\n  \n  always @ (posedge WClk) begin\n    if (WriteEn_in && !Full_out) begin\n      Mem[pNextWordToWrite] <= Data_in;\n    end\n  end\n\n  // FIFO addresses support logic\n  assign NextWriteAddressEn = WriteEn_in && ~Full_out;\n  assign NextReadAddressEn = ReadEn_in && ~Empty_out;\n\n  // Addresses (Gray counters) logic\n  always @ (posedge WClk) begin\n    if (NextWriteAddressEn) begin\n      pNextWordToWrite <= pNextWordToWrite + 1;\n    end\n  end\n\n  always @ (posedge RClk) begin\n    if (NextReadAddressEn) begin\n      pNextWordToRead <= pNextWordToRead + 1;\n    end\n  end\n\n  // 'EqualAddresses' logic\n  assign EqualAddresses = (pNextWordToWrite == pNextWordToRead);\n\n  // 'Quadrant selectors' logic\n  assign Set_Status = (pNextWordToWrite[ADDRESS_WIDTH-2] ^ pNextWordToRead[ADDRESS_WIDTH-1]) &&\n                      (pNextWordToWrite[ADDRESS_WIDTH-1] ^ pNextWordToRead[ADDRESS_WIDTH-2]);\n  assign Rst_Status = (pNextWordToWrite[ADDRESS_WIDTH-2] ^ pNextWordToRead[ADDRESS_WIDTH-1]) &&\n                      (pNextWordToWrite[ADDRESS_WIDTH-1] ^ pNextWordToRead[ADDRESS_WIDTH-2]);\n\n  // 'Status' latch logic\n  always @ (Set_Status, Rst_Status, Clear_in) begin\n    if (Rst_Status || Clear_in) begin\n      Status <= 0;\n    end else if (Set_Status) begin\n      Status <= 1;\n    end\n  end\n\n  // 'Full_out' logic for the writing port\n  assign PresetFull = Status && EqualAddresses;\n\n  always @ (posedge WClk) begin\n    if (PresetFull) begin\n      Full_out <= 1;\n    end else begin\n      Full_out <= 0;\n    end\n  end\n  \n  // 'Empty_out' logic for the reading port\n  assign PresetEmpty = ~Status && EqualAddresses;\n\n  always @ (posedge RClk) begin\n    if (PresetEmpty) begin\n      Empty_out <= 1;\n    end else begin\n      Empty_out <= 0;\n    end\n  end\n\nendmodule\n\nmodule GrayCounter #(parameter WIDTH = 8) (\n  output reg [WIDTH-1:0] GrayCount_out,\n  input wire Enable_in,\n  input wire Clear_in,\n  input wire Clk\n);\n\n  always @ (posedge Clk) begin\n    if (Clear_in) begin\n      GrayCount_out <= 0;\n    end else if (Enable_in) begin\n      GrayCount_out <= GrayCount_out + 1;\n    end\n  end\n\nendmodule",
        "module_name": "fifo_buffer #",
        "module_hash": "0947aca7e61b2f7ac2eba6b450d6e6dc",
        "dataset_index": 4448
      },
      "fadder_ff564d89": {
        "rtl_code": "\n\nmodule fadder(\n  input [WIDTH-1 : 0] a,\n  input [WIDTH - 1 : 0] b,\n  input sub_enable,\n  input carry_in,\n  output [WIDTH - 1 : 0] res,\n  output carry_out);\n\n  parameter WIDTH = 8;\n  wire [WIDTH - 1 : 0] carry;\n  wire [WIDTH - 1 : 0] b_in;\n\n  assign carry_out = carry[WIDTH-1];\n  assign b_in = sub_enable ? ~(b) : b;\n\n  genvar i;\n  generate\n    for (i = 0; i < WIDTH; i = i + 1) begin\n      if (i == 0) begin\n        assign res[i] = (a[i] ^ b_in[i]) ^ carry_in;\n        assign carry[i] = ((a[i] ^ b_in[i]) & carry_in) | (a[i] & b_in[i]);\n      end else begin\n        assign res[i] = (a[i] ^ b_in[i]) ^ carry[i-1];\n        assign carry[i] = ((a[i] ^ b_in[i]) & carry[i-1]) | (a[i] & b_in[i]);\n      end\n    end\n  endgenerate\n\nendmodule\n",
        "module_name": "fadder",
        "module_hash": "ff564d89100ae4d36a9e2e381df53880",
        "dataset_index": 4353
      },
      "mem_interface #_c434f867": {
        "rtl_code": "module mem_interface #(\n  parameter data_width = 32, // data bus width\n  parameter addr_width = 16 // address bus width\n)(\n  input clk, // clock signal\n  input rst, // reset signal\n  input en, // enable signal\n  input [addr_width-1:0] addr, // address signal\n  input wr_en, // write enable signal\n  input [data_width-1:0] data_in, // data input signal\n  output [data_width-1:0] data_out // data output signal\n);\n\n\n// Define internal signals\nreg [data_width-1:0] mem_data; // Memory data\nreg [addr_width-1:0] mem_addr; // Memory address\nreg mem_wr_en; // Memory write enable\nreg mem_rd_en; // Memory read enable\n\n// Synchronous memory read/write\nalways @(posedge clk) begin\n  if (rst) begin\n    mem_wr_en <= 0;\n    mem_rd_en <= 0;\n    mem_addr <= 0;\n    mem_data <= 0;\n  end\n  else begin\n    if (en) begin\n      mem_addr <= addr;\n      if (wr_en) begin\n        mem_wr_en <= 1;\n        mem_data <= data_in;\n      end\n      else begin\n        mem_wr_en <= 0;\n        mem_data <= 0;\n        mem_rd_en <= 1;\n      end\n    end\n    else begin\n      mem_wr_en <= 0;\n      mem_rd_en <= 0;\n      mem_data <= 0;\n    end\n  end\nend\n\n// Assign memory output to data_out\nassign data_out = mem_data;\n\nendmodule",
        "module_name": "mem_interface #",
        "module_hash": "c434f867faa3ed4ebf8b69a925c6dc13",
        "dataset_index": 982
      },
      "top_module_ce214b39": {
        "rtl_code": "\nmodule top_module(\n    input clk,\n    input reset,\n    input [7:0] d,\n    input [3:0] sel,  // Changed from [7:0] to [3:0]\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] out,\n    output [8:0] sum\n);\n\n    // 4-to-1 Multiplexer\n    wire [7:0] mux_out;\n    mux_4to1 mux_inst(\n        .d0(d),\n        .d1(a),\n        .d2(b),\n        .d3(8'h00),\n        .sel(sel[3:0]),  // Changed from sel to sel[3:0]\n        .out(mux_out)\n    );\n    \n    // 2-bit Adder\n    wire [8:0] add_out;\n    adder_2bit add_inst(\n        .a(a),\n        .b(b),\n        .out(add_out)\n    );\n    \n    // Sum Calculation\n    wire [8:0] sum_temp;\n    assign sum_temp = add_out + 9'h34;\n    \n    // Output Assignment\n    assign out = mux_out;\n    assign sum = sum_temp[8:1];\n    \nendmodule\n\nmodule mux_4to1(\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    input [3:0] sel,\n    output reg [7:0] out\n);\n\n    always @(sel or d0 or d1 or d2 or d3) begin\n        case(sel)\n            4'b0000: out <= d0;\n            4'b0001: out <= d1;\n            4'b0010: out <= d2;\n            4'b0011: out <= d3;\n            default: out <= 8'h00;\n        endcase\n    end\nendmodule\n\nmodule adder_2bit(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [8:0] out\n);\n\n    always @(a or b) begin\n        out <= {1'b0, a} + {1'b0, b};\n    end\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "ce214b3928103bd90d9cfb3e35ae8021",
        "dataset_index": 5947
      },
      "contador_AD_HH_2dig_b7a2e331": {
        "rtl_code": "\nmodule contador_AD_HH_2dig\n(\ninput wire clk, \ninput wire reset,\ninput wire [3:0]en_count,\ninput wire enUP,\ninput wire enDOWN,\noutput wire [7:0] data_HH);                             \n\n\nlocalparam N = 5; reg [N-1:0] q_act, q_next;\nwire [N-1:0] count_data;\nreg [3:0] digit1, digit0;\n\nalways@(posedge clk, posedge reset)\nbegin\t\n\t\n\tif(reset)\n\tbegin\n\t\tq_act <= 5'b0;\n\tend\n\t\n\telse\n\tbegin\n\t\tq_act <= q_next;\n\tend\nend\n\n\nalways@*\nbegin\n\n\tif (en_count == 3)\n\tbegin\n\t\tif (enUP)\n\t\tbegin\n\t\t\tif (q_act >= 5'd23) q_next = 5'd0;\n\t\t\telse q_next = q_act + 5'd1;\n\t\tend\n\t\t\n\t\telse if (enDOWN)\n\t\tbegin\n\t\t\tif (q_act == 5'd0) q_next = 5'd23;\n\t\t\telse q_next = q_act - 5'd1;\n\t\tend\n\t\telse q_next = q_act;\n\tend\n\telse q_next = q_act;\n\t\nend\n\nassign count_data = q_act;\n\nalways@*\nbegin\n\tcase(count_data)\n\t\t5'd0: begin digit1 = 4'b0000; digit0 = 4'b0000; end\n\t\t5'd1: begin digit1 = 4'b0000; digit0 = 4'b0001; end\n\t\t5'd2: begin digit1 = 4'b0000; digit0 = 4'b0010; end\n\t\t5'd3: begin digit1 = 4'b0000; digit0 = 4'b0011; end\n\t\t5'd4: begin digit1 = 4'b0000; digit0 = 4'b0100; end\n\t\t5'd5: begin digit1 = 4'b0000; digit0 = 4'b0101; end\n\t\t5'd6: begin digit1 = 4'b0000; digit0 = 4'b0110; end\n\t\t5'd7: begin digit1 = 4'b0000; digit0 = 4'b0111; end\n\t\t5'd8: begin digit1 = 4'b0000; digit0 = 4'b1000; end\n\t\t5'd9: begin digit1 = 4'b0000; digit0 = 4'b1001; end\n\n\t\t5'd10: begin digit1 = 4'b0001; digit0 = 4'b0000; end\n\t\t5'd11: begin digit1 = 4'b0001; digit0 = 4'b0001; end\n\t\t5'd12: begin digit1 = 4'b0001; digit0 = 4'b0010; end\n\t\t5'd13: begin digit1 = 4'b0001; digit0 = 4'b0011; end\n\t\t5'd14: begin digit1 = 4'b0001; digit0 = 4'b0100; end\n\t\t5'd15: begin digit1 = 4'b0001; digit0 = 4'b0101; end\n\t\t5'd16: begin digit1 = 4'b0001; digit0 = 4'b0110; end\n\t\t5'd17: begin digit1 = 4'b0001; digit0 = 4'b0111; end\n\t\t5'd18: begin digit1 = 4'b0001; digit0 = 4'b1000; end\n\t\t5'd19: begin digit1 = 4'b0001; digit0 = 4'b1001; end\n\n\t\t5'd20: begin digit1 = 4'b0010; digit0 = 4'b0000; end\n\t\t5'd21: begin digit1 = 4'b0010; digit0 = 4'b0001; end\n\t\t5'd22: begin digit1 = 4'b0010; digit0 = 4'b0010; end\n\t\t5'd23: begin digit1 = 4'b0010; digit0 = 4'b0011; end\n\t\tdefault:  begin digit1 = 0; digit0 = 0; end\n\tendcase\t\nend\n\nassign data_HH = {digit1,digit0};\n\nendmodule\n",
        "module_name": "contador_AD_HH_2dig",
        "module_hash": "b7a2e331ebdee414307957ef93e4b1ef",
        "dataset_index": 8557
      },
      "Span12Mux_v11_38a48c1e": {
        "rtl_code": "module Span12Mux_v11(I, O);\n  input [11:0] I;\n  output O;\n  \n  assign O = I[11] ? I[10] : I[11];\nendmodule",
        "module_name": "Span12Mux_v11",
        "module_hash": "38a48c1e2615ea1df9ec6975440f5926",
        "dataset_index": 16189
      },
      "MUX_4to1_2387ae10": {
        "rtl_code": "module MUX_4to1 (\n  input [3:0] in,\n  input [1:0] sel,\n  output reg out\n);\n\n  always @(*) begin\n    case(sel)\n      2'b00: out = in[0];\n      2'b01: out = in[1];\n      2'b10: out = in[2];\n      2'b11: out = in[3];\n    endcase\n  end\n\nendmodule",
        "module_name": "MUX_4to1",
        "module_hash": "2387ae10ce06291daa1a83d1c90d3ca6",
        "dataset_index": 3016
      },
      "clk_select_5008891b": {
        "rtl_code": "\nmodule clk_select(\n    input [3:0] inclk,\n    input [1:0] clkselect,\n    output reg outclk\n);\n\nwire [3:0] sel_inclk;\nassign sel_inclk[0] = inclk[0];\nassign sel_inclk[1] = inclk[1];\nassign sel_inclk[2] = inclk[2];\nassign sel_inclk[3] = inclk[3];\n\nalways @(*) begin\n    case(clkselect)\n        2'b00: outclk = sel_inclk[0];\n        2'b01: outclk = sel_inclk[1];\n        2'b10: outclk = sel_inclk[2];\n        2'b11: outclk = sel_inclk[3];\n        default: outclk = 1'b0;\n    endcase\nend\n\nendmodule\n",
        "module_name": "clk_select",
        "module_hash": "5008891bf10908ee305961c54fbc6022",
        "dataset_index": 18746
      },
      "top__7a8fbdd3": {
        "rtl_code": "module top_module ( \n    input [2:0] sel, \n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    input select, // Select input to choose between priority encoder and decoder\n    output reg [3:0] out   );\n\n    wire [5:0] enc_out;\n    wire [7:0] dec_out;\n    wire [3:0] mux_out;\n\n    priority_encoder pe (\n        .in({data0[3], data1[3], data2[3], data3[3], data4[3], data5[3]}),\n        .out(enc_out)\n    );\n\n    decoder dec (\n        .in(sel),\n        .out(dec_out)\n    );\n\n    assign mux_out = select ? dec_out[sel*4 +: 4] : data0[sel] ? data0 : data1[sel] ? data1 : data2[sel] ? data2 : data3[sel] ? data3 : data4[sel] ? data4 : data5;\n\n    always @(*) begin\n        out = mux_out;\n    end\n\nendmodule\n\nmodule priority_encoder (\n    input [5:0] in,\n    output reg [5:0] out\n);\n\n    always @(*) begin\n        casez(in)\n            6'b100000: out = 6'b000001;\n            6'b010000: out = 6'b000010;\n            6'b001000: out = 6'b000100;\n            6'b000100: out = 6'b001000;\n            6'b000010: out = 6'b010000;\n            6'b000001: out = 6'b100000;\n            default: out = 6'b000000;\n        endcase\n    end\n\nendmodule\n\nmodule decoder (\n    input [2:0] in,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        case(in)\n            3'b000: out = 8'b00000001;\n            3'b001: out = 8'b00000010;\n            3'b010: out = 8'b00000100;\n            3'b011: out = 8'b00001000;\n            3'b100: out = 8'b00010000;\n            3'b101: out = 8'b00100000;\n            3'b110: out = 8'b01000000;\n            3'b111: out = 8'b10000000;\n            default: out = 8'b00000000;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "7a8fbdd3b47b4f34c7f0d461ebc0fe0f",
        "dataset_index": 3644
      },
      "mig_7series_v2_0_ecc_merge_enc_b15d561e": {
        "rtl_code": "\n\nmodule mig_7series_v2_0_ecc_merge_enc\n  #(\n    parameter TCQ = 100,\n    parameter PAYLOAD_WIDTH         = 64,\n    parameter CODE_WIDTH            = 72,\n    parameter DATA_BUF_ADDR_WIDTH   = 4,\n    parameter DATA_BUF_OFFSET_WIDTH = 1,\n    parameter DATA_WIDTH            = 64,\n    parameter DQ_WIDTH              = 72,\n    parameter ECC_WIDTH             = 8,\n    parameter nCK_PER_CLK           = 4\n   )\n   (\n    \n  mc_wrdata, mc_wrdata_mask,\n  clk, rst, wr_data, wr_data_mask, rd_merge_data, h_rows, raw_not_ecc\n  );\n\n  input clk;\n  input rst;\n\n  input [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data;\n  input [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask;\n  input [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data;\n  \n  reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data_r;\n  reg [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask_r;\n  reg [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data_r;\n\n  always @(posedge clk) wr_data_r <= #TCQ wr_data;\n  always @(posedge clk) wr_data_mask_r <= #TCQ wr_data_mask;\n  always @(posedge clk) rd_merge_data_r <= #TCQ rd_merge_data;\n  \n  wire [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] merged_data;\n  genvar h;\n  genvar i;\n  generate\n    for (h=0; h<2*nCK_PER_CLK; h=h+1) begin : merge_data_outer\n      for (i=0; i<DATA_WIDTH/8; i=i+1) begin : merge_data_inner\n        assign merged_data[h*PAYLOAD_WIDTH+i*8+:8] =  \n                wr_data_mask[h*DATA_WIDTH/8+i]\n                  ? rd_merge_data[h*DATA_WIDTH+i*8+:8]               \n                  : wr_data[h*PAYLOAD_WIDTH+i*8+:8];\n      end\n      if (PAYLOAD_WIDTH > DATA_WIDTH)\n        assign merged_data[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH]=\n                      wr_data[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH];\n                                                                   \n    end\n  endgenerate\n\n  input [CODE_WIDTH*ECC_WIDTH-1:0] h_rows;\n  input [2*nCK_PER_CLK-1:0] raw_not_ecc;\n  reg [2*nCK_PER_CLK-1:0] raw_not_ecc_r;\n  always @(posedge clk) raw_not_ecc_r <= #TCQ raw_not_ecc;\n  output reg [2*nCK_PER_CLK*DQ_WIDTH-1:0] mc_wrdata;\n  reg [2*nCK_PER_CLK*DQ_WIDTH-1:0] mc_wrdata_c;\n  genvar j;\n  integer k;\n  generate\n    for (j=0; j<2*nCK_PER_CLK; j=j+1) begin : ecc_word\n      always @(h_rows or merged_data or raw_not_ecc_r) begin\n        mc_wrdata_c[j*DQ_WIDTH+:DQ_WIDTH] =\n          {{DQ_WIDTH-PAYLOAD_WIDTH{1'b0}},\n           merged_data[j*PAYLOAD_WIDTH+:PAYLOAD_WIDTH]};\n        for (k=0; k<ECC_WIDTH; k=k+1)\n          if (~raw_not_ecc_r[j])\n            mc_wrdata_c[j*DQ_WIDTH+CODE_WIDTH-k-1] =\n              ^(merged_data[j*PAYLOAD_WIDTH+:DATA_WIDTH] & \n                h_rows[k*CODE_WIDTH+:DATA_WIDTH]);\n      end\n    end\n  endgenerate\nalways @(posedge clk) mc_wrdata <= mc_wrdata_c;\n\n  output wire[2*nCK_PER_CLK*DQ_WIDTH/8-1:0] mc_wrdata_mask;\n  assign mc_wrdata_mask = {2*nCK_PER_CLK*DQ_WIDTH/8{1'b0}};\n\nendmodule\n",
        "module_name": "mig_7series_v2_0_ecc_merge_enc",
        "module_hash": "b15d561e77b8766532c39e1ccb7f2246",
        "dataset_index": 20750
      },
      "fifo_generator_54e60322": {
        "rtl_code": "\nmodule fifo_generator(\n    input s_axi_aclk,\n    input Rst0,\n    input E,\n    input [0:0]DIA,\n    input [3:0]D,\n    input fifo_tx_en,\n    output [3:0]Q,\n    output out,\n    output txfifo_empty\n);\n\n// Register and wire declarations\nreg [3:0] mem [0:7];\nreg [2:0] wr_ptr;\nreg [2:0] rd_ptr;\nreg [2:0] next_wr_ptr;\nreg [2:0] next_rd_ptr;\nreg [3:0] next_wr_data;\nwire [3:0] rd_data;\nreg empty;\nreg [2:0] count;\nreg [2:0] next_count;\nreg [1:0] wr_enable;\nreg [1:0] rd_enable;\n\n// Counter logic\nalways @(posedge s_axi_aclk) begin\n    if (Rst0) begin\n        count <= 0;\n    end else begin\n        count <= next_count;\n    end\nend\n\nalways @(*) begin\n    if (count == 0) begin\n        empty <= 1'b1;\n    end else begin\n        empty <= 1'b0;\n    end\nend\n\nalways @(*) begin\n    next_count = count;\n    if (wr_enable[0]) begin\n        next_count = count + 1;\n    end\n    if (rd_enable[0]) begin\n        next_count = count - 1;\n    end\nend\n\n// Write pointer logic\nalways @(posedge s_axi_aclk) begin\n    if (Rst0) begin\n        wr_ptr <= 0;\n    end else begin\n        wr_ptr <= next_wr_ptr;\n    end\nend\n\nalways @(*) begin\n    next_wr_data = {DIA, D};\n    next_wr_ptr = wr_ptr;\n    wr_enable = 0;\n    if (E) begin\n        wr_enable[0] = 1;\n        next_wr_ptr = wr_ptr + 1;\n        if (wr_ptr == 7) begin\n            next_wr_ptr = 0;\n        end\n    end\nend\n\n// Read pointer logic\nalways @(posedge s_axi_aclk) begin\n    if (Rst0) begin\n        rd_ptr <= 0;\n    end else begin\n        rd_ptr <= next_rd_ptr;\n    end\nend\n\nalways @(*) begin\n    rd_enable = 0;\n    if (fifo_tx_en && !empty) begin\n        rd_enable[0] = 1;\n        next_rd_ptr = rd_ptr + 1;\n        if (rd_ptr == 7) begin\n            next_rd_ptr = 0;\n        end\n    end\nend\n\n// Data memory\nalways @(posedge s_axi_aclk) begin\n    if (wr_enable[0]) begin\n        mem[wr_ptr] <= next_wr_data;\n    end\nend\n\n// Output logic\nassign rd_data = mem[rd_ptr];\nassign Q = rd_data;\nassign out = empty;\nassign txfifo_empty = empty && !wr_enable[0];\n\nendmodule",
        "module_name": "fifo_generator",
        "module_hash": "54e603227928db5e345f37673cbece86",
        "dataset_index": 10914
      },
      "hpdmc_busif #_46a6ed20": {
        "rtl_code": "module hpdmc_busif #(\n\tparameter sdram_depth = 23\n) (\n\tinput sys_clk,\n\tinput sdram_rst,\n\t\n\tinput [sdram_depth-1:0] fml_adr,\n\tinput fml_stb,\n\tinput fml_we,\n\toutput fml_ack,\n\t\n\toutput mgmt_stb,\n\toutput mgmt_we,\n\toutput [sdram_depth-1-1:0] mgmt_address, \n\tinput mgmt_ack,\n\t\n\tinput data_ack\n);\n\nreg mgmt_stb_en;\n\nassign mgmt_stb = fml_stb & mgmt_stb_en;\nassign mgmt_we = fml_we;\nassign mgmt_address = fml_adr[sdram_depth-1:1];\n\nassign fml_ack = data_ack;\n\nalways @(posedge sys_clk) begin\n\tif(sdram_rst)\n\t\tmgmt_stb_en = 1'b1;\n\telse begin\n\t\tif(mgmt_ack)\n\t\t\tmgmt_stb_en = 1'b0;\n\t\tif(data_ack)\n\t\t\tmgmt_stb_en = 1'b1;\n\tend\nend\n\nendmodule",
        "module_name": "hpdmc_busif #",
        "module_hash": "46a6ed20eaf9cc15aa4a2d918836e06f",
        "dataset_index": 15242
      },
      "shift_register_f3b7c0df": {
        "rtl_code": "\nmodule shift_register (\n    input [3:0] data_in,\n    input shift_en,\n    input load_en,\n    output [3:0] data_out,\n    output empty\n);\n\nreg [3:0] register;\n\nassign empty = ~|register;\nassign data_out = register;\n\nalways @(posedge shift_en) begin\n  \n    if (load_en ) begin\n        register <= {data_in[2:0], 1'b0};\n        \n    end else if (shift_en ) begin\n        register <= ( {register[2:0], 1'b0} ); \n    end\nend\nendmodule",
        "module_name": "shift_register",
        "module_hash": "f3b7c0df24d92e6d17894cb1665f369d",
        "dataset_index": 673
      },
      "gray_code_0ae047de": {
        "rtl_code": "module gray_code (\n    input [7:0] data_in,\n    output reg [7:0] gray_out\n);\n\n    always @(*) begin\n        gray_out[0] = data_in[0];\n        gray_out[1] = data_in[0] ^ data_in[1];\n        gray_out[2] = data_in[1] ^ data_in[2];\n        gray_out[3] = data_in[2] ^ data_in[3];\n        gray_out[4] = data_in[3] ^ data_in[4];\n        gray_out[5] = data_in[4] ^ data_in[5];\n        gray_out[6] = data_in[5] ^ data_in[6];\n        gray_out[7] = data_in[6] ^ data_in[7];\n    end\n\nendmodule",
        "module_name": "gray_code",
        "module_hash": "0ae047def51c5e2932e6c1920a3b2fb4",
        "dataset_index": 18361
      },
      "sky130_fd_sc_ms__clkdlyinv5sd2_863c1367": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__clkdlyinv5sd2 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__clkdlyinv5sd2",
        "module_hash": "863c1367f8cb6a6777f7438ac7a7462d",
        "dataset_index": 21633
      },
      "add_overflow_detection_fbf2cc1f": {
        "rtl_code": "module add_overflow_detection (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] s,\n    output reg overflow\n);\n\n    reg [8:0] temp; // temporary variable to hold the sum\n    \n    always @(*) begin\n        temp = a + b;\n        if (temp > 127 || temp < -128) // check for signed overflow\n            overflow <= 1;\n        else\n            overflow <= 0;\n        s <= temp[7:0]; // truncate to 8 bits\n    end\n    \nendmodule",
        "module_name": "add_overflow_detection",
        "module_hash": "fbf2cc1febb6787fd1d8574984885bd7",
        "dataset_index": 12975
      },
      "sky130_fd_sc_ls__clkdlyinv5sd1_f829721a": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__clkdlyinv5sd1 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__clkdlyinv5sd1",
        "module_hash": "f829721abe9a972c136880b9682e396a",
        "dataset_index": 9949
      },
      "vga_linear_9b530eb4": {
        "rtl_code": "\n\nmodule vga_linear (\n    input clk,\n    input rst,\n\n    output [17:1] csr_adr_o,\n    input  [15:0] csr_dat_i,\n    output        csr_stb_o,\n\n    input [9:0] h_count,\n    input [9:0] v_count,\n    input       horiz_sync_i,\n    input       video_on_h_i,\n    output      video_on_h_o,\n\n    output [7:0] color,\n    output       horiz_sync_o\n  );\n\n  reg [ 9:0] row_addr;\n  reg [ 6:0] col_addr;\n  reg [14:1] word_offset;\n  reg [ 1:0] plane_addr;\n  reg [ 1:0] plane_addr0;\n  reg [ 7:0] color_l;\n\n  reg [4:0] video_on_h;\n  reg [4:0] horiz_sync;\n  reg [5:0] pipe;\n  reg [15:0] word_color;\n\n  assign csr_adr_o = { word_offset, plane_addr, 1'b0 };\n  assign csr_stb_o = pipe[1];\n\n  assign color = pipe[4] ? csr_dat_i[7:0] : color_l;\n\n  assign video_on_h_o = video_on_h[4];\n  assign horiz_sync_o = horiz_sync[4];\n\n  always @(posedge clk)\n    pipe <= rst ? 6'b0 : { pipe[4:0], ~h_count[0] };\n\n  always @(posedge clk)\n    video_on_h <= rst ? 5'b0 : { video_on_h[3:0], video_on_h_i };\n\n  always @(posedge clk)\n    horiz_sync <= rst ? 5'b0 : { horiz_sync[3:0], horiz_sync_i };\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        row_addr    <= 10'h0;\n        col_addr    <= 7'h0;\n        plane_addr0 <= 2'b00;\n        word_offset <= 14'h0;\n        plane_addr  <= 2'b00;\n      end\n    else\n      begin\n        row_addr    <= { v_count[8:1], 2'b00 } + v_count[8:1];\n        col_addr    <= h_count[9:3];\n        plane_addr0 <= h_count[2:1];\n\n        word_offset <= { row_addr + col_addr[6:4], col_addr[3:0] };\n        plane_addr  <= plane_addr0;\n      end\n\n  always @(posedge clk)\n    color_l <= rst ? 8'h0 : (pipe[4] ? csr_dat_i[7:0] : color_l);\n\nendmodule\n",
        "module_name": "vga_linear",
        "module_hash": "9b530eb41671eed92653d396defbc80e",
        "dataset_index": 25149
      },
      "PP_NEW_bad07753": {
        "rtl_code": "module PP_NEW ( ONEPOS, ONENEG, TWOPOS, TWONEG, INA, INB, INC, IND, PPBIT );\n    input  ONEPOS;\n    input  ONENEG;\n    input  TWOPOS;\n    input  TWONEG;\n    input  INA;\n    input  INB;\n    input  INC;\n    input  IND;\n    output PPBIT;\n\n    wire A, B, C, D, E;\n\n    assign A = ~(INA & TWOPOS);\n    assign B = ~(INB & TWONEG);\n    assign C = ~(INC & ONEPOS);\n    assign D = ~(IND & ONENEG);\n    assign E = A & B & C & D;\n    assign PPBIT = ~E;\n\nendmodule",
        "module_name": "PP_NEW",
        "module_hash": "bad07753c8d23220283628bbfbbd5cdd",
        "dataset_index": 20778
      },
      "bcd_to_7segment_decoder_44cbbd4e": {
        "rtl_code": "\nmodule bcd_to_7segment_decoder(input [3:0] x, output [3:0] an, output [6:0] seg);\n\tassign an = 4'b0001;\n\tassign  seg[0] = (~x[0] & ~x[1] & x[2]) | (x[0] & ~x[1] & ~x[2] & ~x[3]); assign  seg[1] = (x[0] ^ x[1]) & x[2]; assign  seg[2] = ~x[0] & x[1] & ~x[2]; assign  seg[3] = (~x[0] & ~x[1] & x[2]) | (x[0] & ~x[1] & ~x[2] & ~x[3]) | (x[0] & x[1] & x[2]); assign  seg[4] = (x[0] ) | (~x[0] & ~x[1] & x[2]); assign  seg[5] = (x[0] & x[1]) | (x[1] & ~x[2]) | (x[0] & ~x[2] & ~x[3]); assign  seg[6] = (x[0] & x[1] & x[2]) | (~x[1] & ~x[2] & ~x[3]); endmodule\n\n",
        "module_name": "bcd_to_7segment_decoder",
        "module_hash": "44cbbd4e12db2b52e6d8a2b077d17dce",
        "dataset_index": 20740
      },
      "bcd_counter_4845347a": {
        "rtl_code": "module bcd_counter (\n    input clk,\n    input reset,\n    output [2:0] ena,\n    output reg [15:0] q\n);\n\nreg [3:0] count;\nreg [3:0] bcd_count;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 0;\n        bcd_count <= 0;\n    end else begin\n        count <= count + 1;\n        if (count == 4'b1010) begin\n            count <= 0;\n            bcd_count <= bcd_count + 1;\n        end\n    end\nend\n\nassign ena = bcd_count[2:0];\n\nalways @* begin\n    case (count)\n        4'b0000: q = {4'b0000, bcd_count};\n        4'b0001: q = {4'b0001, bcd_count};\n        4'b0010: q = {4'b0010, bcd_count};\n        4'b0011: q = {4'b0011, bcd_count};\n        4'b0100: q = {4'b0100, bcd_count};\n        4'b0101: q = {4'b0101, bcd_count};\n        4'b0110: q = {4'b0110, bcd_count};\n        4'b0111: q = {4'b0111, bcd_count};\n        4'b1000: q = {4'b1000, bcd_count};\n        4'b1001: q = {4'b1001, bcd_count};\n        default: q = 16'b0;\n    endcase\nend\n\nendmodule",
        "module_name": "bcd_counter",
        "module_hash": "4845347ab76b97824ae70cce68c39410",
        "dataset_index": 8369
      },
      "GenPP_32Bits_672e630c": {
        "rtl_code": "\n\nmodule GenPP_32Bits(PP15,PP14,PP13,PP12,PP11,PP10,PP9,PP8,\n                    PP7,PP6,PP5,PP4,PP3,PP2,PP1,PP0,iso_X,iso_Y,iso_in);\n  `define nBits 32\n\n  output [`nBits:0]      PP15;                   output [`nBits:0]      PP14;                   output [`nBits:0]      PP13;                   output [`nBits:0]      PP12;                   output [`nBits:0]      PP11;                   output [`nBits:0]      PP10;                   output [`nBits:0]      PP9;                    output [`nBits:0]      PP8;                    output [`nBits:0]      PP7;                    output [`nBits:0]      PP6;                    output [`nBits:0]      PP5;                    output [`nBits:0]      PP4;                    output [`nBits:0]      PP3;                    output [`nBits:0]      PP2;                    output [`nBits:0]      PP1;                    output [`nBits:0]      PP0;                    input  [`nBits-1:0]    iso_X;                      input  [`nBits-1:0]    iso_Y;                      input                iso_in;\n  wire                 iso_in_N;\n  wire [`nBits-1:0]    X;\n  wire [`nBits-1:0]    Y;\n\n  wire [2:0] Seg15 = Y[31:29];           wire [2:0] Seg14 = Y[29:27];           wire [2:0] Seg13 = Y[27:25];           wire [2:0] Seg12 = Y[25:23];           wire [2:0] Seg11 = Y[23:21];           wire [2:0] Seg10 = Y[21:19];           wire [2:0] Seg9  = Y[19:17];           wire [2:0] Seg8  = Y[17:15];           wire [2:0] Seg7  = Y[15:13];           wire [2:0] Seg6  = Y[13:11];           wire [2:0] Seg5  = Y[11:9];            wire [2:0] Seg4  = Y[9:7];             wire [2:0] Seg3  = Y[7:5];             wire [2:0] Seg2  = Y[5:3];             wire [2:0] Seg1  = Y[3:1];             wire [2:0] Seg0  = {Y[1:0], 1'b0};     assign X = iso_X;\n  assign Y = iso_Y;\n\n  assign PP15[`nBits:0] = BoothDecode(Seg15[2:0],X[`nBits-1:0]);\n  assign PP14[`nBits:0] = BoothDecode(Seg14[2:0],X[`nBits-1:0]);\n  assign PP13[`nBits:0] = BoothDecode(Seg13[2:0],X[`nBits-1:0]);\n  assign PP12[`nBits:0] = BoothDecode(Seg12[2:0],X[`nBits-1:0]);\n  assign PP11[`nBits:0] = BoothDecode(Seg11[2:0],X[`nBits-1:0]);\n  assign PP10[`nBits:0] = BoothDecode(Seg10[2:0],X[`nBits-1:0]);\n  assign PP9[`nBits:0] = BoothDecode(Seg9[2:0],X[`nBits-1:0]);\n  assign PP8[`nBits:0] = BoothDecode(Seg8[2:0],X[`nBits-1:0]);\n  assign PP7[`nBits:0] = BoothDecode(Seg7[2:0],X[`nBits-1:0]);\n  assign PP6[`nBits:0] = BoothDecode(Seg6[2:0],X[`nBits-1:0]);\n  assign PP5[`nBits:0] = BoothDecode(Seg5[2:0],X[`nBits-1:0]);\n  assign PP4[`nBits:0] = BoothDecode(Seg4[2:0],X[`nBits-1:0]);\n  assign PP3[`nBits:0] = BoothDecode(Seg3[2:0],X[`nBits-1:0]);\n  assign PP2[`nBits:0] = BoothDecode(Seg2[2:0],X[`nBits-1:0]);\n  assign PP1[`nBits:0] = BoothDecode(Seg1[2:0],X[`nBits-1:0]);\n  assign PP0[`nBits:0] = BoothDecode(Seg0[2:0],X[`nBits-1:0]);\n\n  function [`nBits:0] BoothDecode;\n    input [2:0] Segment;\n    input [`nBits:0] X;\n    case ( Segment[2:0] )\n         3'b000  :  BoothDecode = 33'h000000000;                    3'b001,\n         3'b010  :  BoothDecode = { X[`nBits-1], X[`nBits-1:0] }  ; 3'b011  :  BoothDecode = { X[`nBits-1:0], 1'b0  }  ;       3'b100  :  BoothDecode = { ~X[`nBits-1:0], 1'b1  }  ;      3'b101,\n         3'b110  :  BoothDecode = { ~X[`nBits-1], ~X[`nBits-1:0] } ;3'b111  :  BoothDecode = 33'h1FFFFFFFF;                    endcase\n  endfunction\nendmodule\n",
        "module_name": "GenPP_32Bits",
        "module_hash": "672e630c4dc711e0b61d5561241cd39d",
        "dataset_index": 22798
      },
      "XORCY_c5861657": {
        "rtl_code": "\nmodule XORCY (O, CI, LI);\n\n\n`ifdef XIL_TIMING\n\n    parameter LOC = \"UNPLACED\";\n\n`endif\n\n    \n    output O;\n\n    input  CI, LI;\n\n\txor X1 (O, CI, LI);\n\n`ifdef XIL_TIMING\n\n    specify\n        \n        (CI => O) = (0:0:0, 0:0:0);\n        (LI => O) = (0:0:0, 0:0:0);\n        specparam PATHPULSE$ = 0;\n        \n    endspecify\n\n`endif\n    \nendmodule\n",
        "module_name": "XORCY",
        "module_hash": "c5861657f7d55ee007b573fe12e91871",
        "dataset_index": 23631
      },
      "shift_register_ab55bcaa": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input rst,\n    input ena,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\nreg [15:0] pipeline_reg [1:2];\n\nalways @(posedge clk) begin\n    if (rst) begin\n        pipeline_reg[1] <= 16'b0;\n        pipeline_reg[2] <= 16'b0;\n    end\n    else if (ena) begin\n        pipeline_reg[1] <= data_in;\n        pipeline_reg[2] <= pipeline_reg[1];\n    end\n    else begin\n        pipeline_reg[1] <= pipeline_reg[2];\n        pipeline_reg[2] <= pipeline_reg[1] << 1;\n    end\nend\n\nassign data_out = pipeline_reg[2]; // Fix the output assignment\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "ab55bcaa742aac7815f48b0a904dc519",
        "dataset_index": 19586
      },
      "shift_register_4bit_79031646": {
        "rtl_code": "module shift_register_4bit(\n    input clk,\n    input rst,\n    input load,\n    input [3:0] data_in,\n    input shift,\n    output reg [3:0] data_out\n);\n\nalways @ (posedge clk or negedge rst) begin\n    if (~rst) begin\n        data_out <= 0;\n    end else if (load) begin\n        data_out <= data_in;\n    end else if (shift) begin\n        data_out <= {data_out[2:0], 1'b0};\n    end\nend\n\nendmodule",
        "module_name": "shift_register_4bit",
        "module_hash": "7903164647d1bca648d168904c8543d8",
        "dataset_index": 18761
      },
      "binary_counter_bc7e4b26": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "bc7e4b2641b32bf35c4050bfdfa0bc87",
        "dataset_index": 3751
      },
      "t2_ab6f7355": {
        "rtl_code": "\nmodule t2(\n    input [1:0] clks,\n    input c0,\n    input c1,\n    input check,\n    output reg o_check\n);\n\n    reg [1:0] state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n    \n    always @(posedge clks[0]) begin\n        case(state)\n            S0: begin\n                if(c0 && !c1)\n                    state <= S1;\n                else if(!c0 && c1)\n                    state <= S2;\n            end\n            S1: begin\n                if(c0 && !c1)\n                    state <= S3;\n                else if(!c0 && !c1)\n                    state <= S0;\n            end\n            S2: begin\n                if(!c0 && c1)\n                    state <= S3;\n                else if(c0 && !c1)\n                    state <= S0;\n            end\n            S3: begin\n                if(!c0 && !c1)\n                    state <= S2;\n                else if(c0 && c1)\n                    state <= S1;\n            end\n        endcase\n    end\n    \n    always @(posedge clks[1]) begin\n        if(state == S3 && check)\n            o_check <= 1;\n        else\n            o_check <= 0;\n    end\n    \n    initial state <= S0;\n    \nendmodule",
        "module_name": "t2",
        "module_hash": "ab6f735562c223cc968e3a3a21dd6da6",
        "dataset_index": 17361
      },
      "mux4to1_c0cf4393": {
        "rtl_code": "\nmodule mux4to1(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output [3:0] out\n);\n\n    wire [3:0] mux1_out0, mux1_out1;\n\n    // First level MUXes\n    mux2to1 mux1_0(\n        .in0(in0),\n        .in1(in1),\n        .sel(sel[0]),\n        .out(mux1_out0)\n    );\n    mux2to1 mux1_1(\n        .in0(in2),\n        .in1(in3),\n        .sel(sel[0]),\n        .out(mux1_out1)\n    );\n\n    // Second level MUX\n    mux2to1 mux2(\n        .in0(mux1_out0),\n        .in1(mux1_out1),\n        .sel(sel[1]),\n        .out(out)\n    );\n\nendmodule\n\nmodule mux2to1(\n    input [3:0] in0,\n    input [3:0] in1,\n    input sel,\n    output [3:0] out\n);\n\n    assign out = sel ? in1 : in0;\n\nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "c0cf43937c69d2dafa35ad8a79d7d72c",
        "dataset_index": 14327
      },
      "axi_arbiter_b2391926": {
        "rtl_code": "\nmodule axi_arbiter (\n  input rstn,\n  input sw_clk,\n  input [2:0] qos1,\n  input [2:0] qos2,\n  input prt_dv1,\n  input prt_dv2,\n  input [7:0] prt_data1,\n  input [7:0] prt_data2,\n  input [14:0] prt_addr1,\n  input [14:0] prt_addr2,\n  input [6:0] prt_bytes1,\n  input [6:0] prt_bytes2,\n  output reg prt_ack1,\n  output reg prt_ack2,\n  output reg prt_req,\n  output reg [7:0] prt_data,\n  output reg [14:0] prt_addr,\n  output reg [6:0] prt_bytes,\n  output reg [2:0] prt_qos\n);\n\n  parameter wait_req = 2'b00, serv_req1 = 2'b01, serv_req2 = 2'b10, wait_ack_low = 2'b11;\n  reg [1:0] state, temp_state;\n\n  always @(posedge sw_clk or negedge rstn) begin\n    if (!rstn) begin\n      state = wait_req;\n      prt_req = 1'b0;\n      prt_ack1 = 1'b0;\n      prt_ack2 = 1'b0;\n      prt_qos = 0;\n    end else begin\n      case (state)\n        wait_req: begin\n          state = wait_req;\n          prt_ack1 = 1'b0;\n          prt_ack2 = 1'b0;\n          prt_req = 1'b0;\n          if (prt_dv1 && !prt_dv2) begin\n            state = serv_req1;\n            prt_req = 1;\n            prt_data = prt_data1;\n            prt_addr = prt_addr1;\n            prt_bytes = prt_bytes1;\n            prt_qos = qos1;\n          end else if (!prt_dv1 && prt_dv2) begin\n            state = serv_req2;\n            prt_req = 1;\n            prt_qos = qos2;\n            prt_data = prt_data2;\n            prt_addr = prt_addr2;\n            prt_bytes = prt_bytes2;\n          end else if (prt_dv1 && prt_dv2) begin\n            if (qos1 > qos2) begin\n              prt_req = 1;\n              prt_qos = qos1;\n              prt_data = prt_data1;\n              prt_addr = prt_addr1;\n              prt_bytes = prt_bytes1;\n              state = serv_req1;\n            end else if (qos1 < qos2) begin\n              prt_req = 1;\n              prt_qos = qos2;\n              prt_data = prt_data2;\n              prt_addr = prt_addr2;\n              prt_bytes = prt_bytes2;\n              state = serv_req2;\n            end else begin\n              if (temp_state == serv_req1) begin\n                prt_req = 1;\n                prt_qos = qos2;\n                prt_data = prt_data2;\n                prt_addr = prt_addr2;\n                prt_bytes = prt_bytes2;\n                state = serv_req2;\n              end else begin\n                prt_req = 1;\n                prt_qos = qos1;\n                prt_data = prt_data1;\n                prt_addr = prt_addr1;\n                prt_bytes = prt_bytes1;\n                state = serv_req1;\n              end\n            end\n          end\n        end\n        serv_req1: begin\n          state = serv_req1;\n          prt_ack2 = 1'b0;\n          if (prt_ack1) begin\n            prt_ack1 = 1'b1;\n            prt_req = 0;\n            if (prt_dv2) begin\n              prt_req = 1;\n              prt_qos = qos2;\n              prt_data = prt_data2;\n              prt_addr = prt_addr2;\n              prt_bytes = prt_bytes2;\n              state = serv_req2;\n            end else begin\n              temp_state = state;\n              state = wait_ack_low;\n            end\n          end\n        end\n        serv_req2: begin\n          state = serv_req2;\n          prt_ack1 = 1'b0;\n          if (prt_ack2) begin\n            prt_ack2 = 1'b1;\n            prt_req = 0;\n            if (prt_dv1) begin\n              prt_req = 1;\n              prt_qos = qos1;\n              prt_data = prt_data1;\n              prt_addr = prt_addr1;\n              prt_bytes = prt_bytes1;\n              state = serv_req1;\n            end else begin\n              temp_state = state;\n              state = wait_ack_low;\n            end\n          end\n        end\n        wait_ack_low: begin\n          prt_ack1 = 1'b0;\n          prt_ack2 = 1'b0;\n          state = wait_ack_low;\n          if (!prt_ack1 && !prt_ack2) begin\n            state = wait_req;\n          end\n        end\n      endcase\n    end\n  end\nendmodule",
        "module_name": "axi_arbiter",
        "module_hash": "b2391926394a68c2fdeb32963a62e545",
        "dataset_index": 11750
      },
      "sky130_fd_sc_ls__clkdlyinv3sd1_27015520": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__clkdlyinv3sd1 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__clkdlyinv3sd1",
        "module_hash": "27015520eca7e5b19debee87dd4fead2",
        "dataset_index": 10762
      },
      "top__9b7ad065": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // 8-bit input for the shift register\n    output [7:0] q    // 8-bit output from the shift register\n);\n    \n    wire [3:0] johnson_out;\n    wire [7:0] xor_out;\n    \n    johnson_counter jc(\n        .clk(clk),\n        .reset(reset),\n        .q(johnson_out)\n    );\n    \n    xor_module xm(\n        .in1(q),\n        .in2(johnson_out),\n        .out(xor_out)\n    );\n    \n    reg [7:0] shift_reg;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'h34;\n        end else begin\n            shift_reg <= {shift_reg[6:0], d};\n        end\n    end\n    \n    assign q = xor_out;\n    \nendmodule\n\nmodule johnson_counter (\n    input clk, \n    input reset,      // Asynchronous active-low reset\n    output reg [3:0] q // 4-bit Johnson counter output\n);\n    \n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            q <= 4'b0000;\n        end else begin\n            case (q)\n                4'b0000: q <= 4'b1000;\n                4'b1000: q <= 4'b1100;\n                4'b1100: q <= 4'b1110;\n                4'b1110: q <= 4'b1111;\n                4'b1111: q <= 4'b0111;\n                4'b0111: q <= 4'b0011;\n                4'b0011: q <= 4'b0001;\n                4'b0001: q <= 4'b0000;\n            endcase\n        end\n    end\n    \nendmodule\n\nmodule xor_module (\n    input [7:0] in1,  // 8-bit input from shift register\n    input [3:0] in2,  // 4-bit input from Johnson counter\n    output reg [7:0] out // 8-bit output after XOR operation\n);\n    \n    always @(*) begin\n        case (in2)\n            4'b0000: out = in1 ^ 8'h00;\n            4'b1000: out = in1 ^ 8'h08;\n            4'b1100: out = in1 ^ 8'h0C;\n            4'b1110: out = in1 ^ 8'h0E;\n            4'b1111: out = in1 ^ 8'h0F;\n            4'b0111: out = in1 ^ 8'h07;\n            4'b0011: out = in1 ^ 8'h03;\n            4'b0001: out = in1 ^ 8'h01;\n        endcase\n    end\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "9b7ad0655758eef04332f874f42fd80a",
        "dataset_index": 15396
      },
      "and4_a18ab845": {
        "rtl_code": "module and4 (\n    output Y,\n    input A, B, C, D\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire w1, w2, w3;\n    \n    and u1 (w1, A, B);\n    and u2 (w2, C, D);\n    and u3 (w3, w1, w2);\n    \n    assign Y = w3;\n\nendmodule",
        "module_name": "and4",
        "module_hash": "a18ab845e3376790ab4466115abdc09a",
        "dataset_index": 6151
      },
      "barrel_shifter_a709ac76": {
        "rtl_code": "module barrel_shifter (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [2:0] shift_amount,\n  input shift_direction, // 0: right shift, 1: left shift\n  output [7:0] data_out\n);\n\n  reg [7:0] temp_data;\n\n  always @ (posedge clk or posedge reset) begin\n    if (reset) begin\n      temp_data <= 8'h00;\n    end else begin\n      if (shift_direction == 1) begin // left shift\n        temp_data[7:shift_amount] <= data_in[7-shift_amount:0];\n        temp_data[shift_amount-1:0] <= 8'h00;\n      end else begin // right shift\n        temp_data[0:7-shift_amount] <= data_in[shift_amount-1:0];\n        temp_data[7-shift_amount:7] <= 8'h00;\n      end\n    end\n  end\n\n  assign data_out = temp_data;\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "a709ac76968864649b52d2d7380283df",
        "dataset_index": 1400
      },
      "multiplier #_477903e4": {
        "rtl_code": "module multiplier #(\n  parameter n = 4 // number of bits for A and B\n) (\n  input [n-1:0] A,\n  input [n-1:0] B,\n  input mode,\n  output reg signed [2*n-1:0] P\n);\n\n\nreg signed [2*n-1:0] A_signed, B_signed;\n\nalways @(*) begin\n  if (mode) begin\n    // Signed multiplication\n    A_signed = $signed(A);\n    B_signed = $signed(B);\n    P = A_signed * B_signed;\n  end else begin\n    // Unsigned multiplication\n    P = A * B;\n  end\nend\n\nendmodule",
        "module_name": "multiplier #",
        "module_hash": "477903e4fc21f165c1f354c6524fc4ba",
        "dataset_index": 2830
      },
      "dffsi_9_5571cd9c": {
        "rtl_code": "module dffsi_9 (\n    input clk,\n    input reset,\n    input [8:0] init,\n    input [8:0] d,\n    output reg [8:0] q\n);\n\n    // Synthesis Attribute to keep hierarchy\n     \n\n    // Random initialization\n    `ifdef RANDOM_INIT\n        initial $random_init(q);\n    `endif\n\n    // Assertion for checking reset signal\n    `ifdef CHK_RESET_EOS\n        assert_quiescent_state #(0,1,0, \"***ERROR ASSERT: reset still asserted at end of simulation\")\n            a0(.clk(clk), .reset_n(1'b1), .state_expr(reset), .check_value(1'b0), .sample_event(1'b0));\n    `endif\n\n    always @(posedge clk) begin\n        if (!reset) begin\n            q <= init;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule",
        "module_name": "dffsi_9",
        "module_hash": "5571cd9c5aaef2fdf0afb9a7c5fa4820",
        "dataset_index": 2959
      },
      "SPIFSM #_a18466a7": {
        "rtl_code": "\n\nmodule SPIFSM #(\n  parameter SPPRWidth = 4,\n  parameter SPRWidth  = 4,\n  parameter DataWidth = 8\n) (\n  input                  Reset_n_i,\n  input                  Clk_i,\n  input                  Start_i,\n  output reg             Done_o,\n  output reg [DataWidth-1:0] Byte0_o,\n  output reg [DataWidth-1:0] Byte1_o,\n  input                  SPI_Transmission_i,\n  output reg                 SPI_Write_o,\n  output reg                 SPI_ReadNext_o,\n  output reg [DataWidth-1:0] SPI_Data_o,\n  input  [DataWidth-1:0] SPI_Data_i,\n  input                  SPI_FIFOFull_i,\n  input                  SPI_FIFOEmpty_i,\n  output reg             ADT7310CS_n_o,\n  input [15:0]           ParamCounterPreset_i\n);\n\n  localparam stIdle       = 4'b0000;\n  localparam stWriteValue = 4'b0001;\n  localparam stWaitSent   = 4'b0010;\n  localparam stConsume1   = 4'b0011;\n  localparam stWait       = 4'b0100;\n  localparam stWriteDummy1= 4'b0101;\n  localparam stWriteDummy2= 4'b0110;\n  localparam stRead1      = 4'b0111;\n  localparam stRead2      = 4'b1000;\n  localparam stRead3      = 4'b1001;\n  localparam stPause      = 4'b1010;\n  reg  [3:0]             SPI_FSM_State;\n  reg  [3:0]             SPI_FSM_NextState;\n  wire                   SPI_FSM_TimerOvfl;\n  reg                    SPI_FSM_TimerPreset;\n  reg                    SPI_FSM_TimerEnable;\n  reg                    SPI_FSM_Wr1;\n  reg                    SPI_FSM_Wr0;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SPI_FSM_State <= stIdle;\n    end\n    else\n    begin\n      SPI_FSM_State <= SPI_FSM_NextState;\n    end  \n  end\n\n  always @(SPI_FSM_State, Start_i, SPI_Transmission_i, SPI_FSM_TimerOvfl)\n  begin  SPI_FSM_NextState = SPI_FSM_State;\n    ADT7310CS_n_o       = 1'b1;\n    SPI_Data_o          = 8'bxxxxxxxx; SPI_Write_o         = 1'b0;\n    SPI_ReadNext_o      = 1'b0;\n    SPI_FSM_TimerPreset = 1'b0;\n    SPI_FSM_TimerEnable = 1'b0;\n    SPI_FSM_Wr1         = 1'b0;\n    SPI_FSM_Wr0         = 1'b0;\n    Done_o              = 1'b1;\n    case (SPI_FSM_State)\n      stIdle: begin\n        if (Start_i == 1'b1)\n        begin\n          SPI_FSM_NextState = stWriteValue;\n          ADT7310CS_n_o     = 1'b0;\n          SPI_Data_o        = 8'h08;\n          SPI_Write_o       = 1'b1;\n          Done_o            = 1'b0;\n        end\n      end\n      stWriteValue: begin\n        SPI_FSM_NextState   = stWaitSent;\n        ADT7310CS_n_o       = 1'b0;\n        SPI_Data_o          = 8'h20;\n        SPI_Write_o         = 1'b1;\n        Done_o              = 1'b0;\n      end\n      stWaitSent: begin\n        ADT7310CS_n_o       = 1'b0;\n        Done_o              = 1'b0;\n        if (SPI_Transmission_i == 1'b0)\n        begin\n          SPI_FSM_NextState   = stConsume1;\n          SPI_ReadNext_o      = 1'b1;       SPI_FSM_TimerPreset = 1'b1;\n        end\n      end\n      stConsume1: begin\n        SPI_FSM_NextState   = stWait;\n        ADT7310CS_n_o       = 1'b0;\n        Done_o              = 1'b0;\n        SPI_ReadNext_o      = 1'b1;       SPI_FSM_TimerEnable = 1'b1;  end\n      stWait: begin\n        ADT7310CS_n_o       = 1'b1;\n        Done_o              = 1'b0;\n        if (SPI_FSM_TimerOvfl == 1'b0)\n        begin\n          SPI_FSM_TimerEnable = 1'b1;  end\n        else\n        begin\n          ADT7310CS_n_o       = 1'b0;\n          SPI_FSM_NextState   = stWriteDummy1;\n          SPI_Data_o          = 8'h50;\n          SPI_Write_o         = 1'b1;\n        end\n      end\n      stWriteDummy1: begin\n        SPI_FSM_NextState   = stWriteDummy2;\n        ADT7310CS_n_o       = 1'b0;\n        Done_o              = 1'b0;\n          SPI_Data_o          = 8'hFF;\n          SPI_Write_o         = 1'b1;\n        end\n      stWriteDummy2: begin\n        SPI_FSM_NextState   = stRead1;\n        ADT7310CS_n_o       = 1'b0;\n        Done_o              = 1'b0;\n        SPI_Data_o          = 8'hFF;\n        SPI_Write_o         = 1'b1;\n      end\n      stRead1: begin\n        ADT7310CS_n_o       = 1'b0;\n        Done_o              = 1'b0;\n        if (SPI_Transmission_i == 1'b0) begin\n          SPI_FSM_NextState = stRead2;\n          SPI_ReadNext_o    = 1'b1;\n        end\n      end\n      stRead2: begin\n        Done_o              = 1'b0;\n        SPI_ReadNext_o      = 1'b1;\n        SPI_FSM_Wr1         = 1'b1;\n        SPI_FSM_NextState   = stRead3;\n      end\n      stRead3: begin\n        Done_o              = 1'b0;\n        SPI_ReadNext_o      = 1'b1;\n        SPI_FSM_Wr0         = 1'b1;\n        SPI_FSM_NextState   = stPause;\n      end\n      stPause: begin\n        SPI_FSM_NextState = stIdle;\n      end\n      default: begin\n      end\n    endcase\n  end\n\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Byte0_o <= 8'd0;\n      Byte1_o <= 8'd0;\n    end\n    else\n    begin\n      if (SPI_FSM_Wr0)\n      begin\n        Byte0_o <= SPI_Data_i;\n      end\n      if (SPI_FSM_Wr1)\n      begin\n        Byte1_o <= SPI_Data_i;\n      end\n    end  \n  end\n\n  reg [15:0] SPI_FSM_Timer;\n  \n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SPI_FSM_Timer <= 16'd0;\n    end\n    else\n    begin\n      if (SPI_FSM_TimerPreset)\n      begin\n        SPI_FSM_Timer <= ParamCounterPreset_i;\n      end\n      else if (SPI_FSM_TimerEnable)\n      begin\n        SPI_FSM_Timer <= SPI_FSM_Timer - 1'b1;\n      end\n    end  \n  end\n\n  assign SPI_FSM_TimerOvfl = (SPI_FSM_Timer == 0) ? 1'b1 : 1'b0;\n\nendmodule ",
        "module_name": "SPIFSM #",
        "module_hash": "a18466a74d7cef69d576cb2c9ddff235",
        "dataset_index": 25051
      },
      "alu_ef811c14": {
        "rtl_code": "module alu (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] op,\n    input clk,\n    output reg [3:0] result,\n    output reg valid\n);\n\nreg [3:0] a_reg;\nreg [3:0] b_reg;\nreg [3:0] result_reg;\nreg valid_reg;\n\nalways @(posedge clk) begin\n    a_reg <= A;\n    b_reg <= B;\n    valid_reg <= 1'b0;\n    \n    case(op)\n        3'b000: result_reg <= a_reg + b_reg;\n        3'b001: result_reg <= a_reg - b_reg;\n        3'b010: result_reg <= a_reg & b_reg;\n        3'b011: result_reg <= a_reg | b_reg;\n        3'b100: result_reg <= a_reg ^ b_reg;\n        default: result_reg <= 4'b0;\n    endcase\n    \n    valid_reg <= 1'b1;\nend\n\nalways @(*) begin\n    result = result_reg;\n    valid = valid_reg;\nend\n\nendmodule",
        "module_name": "alu",
        "module_hash": "ef811c14df5add0133bbdd1ce0d54833",
        "dataset_index": 13167
      },
      "mult4_31bc9a26": {
        "rtl_code": "module mult4(\n\ta0,a1,a2,a3,\n\tb0,b1,b2,b3,\n\tz0,z1,z2,z3,z4,z5,z6,z7);\ninput a0,a1,a2,a3,b0,b1,b2,b3;\noutput z0,z1,z2,z3,z4,z5,z6,z7;\nwire x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17;\n\nassign z0 = a0&b0;\nassign z1 = (a1&b0)^(a0&b1);\nassign x1 = (a1&b0)&(a0&b1);\nassign x2 = (a1&b2)^(a0&b2)^x1;\nassign x3 = ((a1&b2)&(a0&b2)) | ((a1&b2)&x1) | ((a0&b2)&x1);\nassign x4 = (a1&b2)^(a0&b3)^x3;\nassign x5 = ((a1&b2)&(a0&b3)) | ((a1&b2)&x3) | ((a0&b3)&x3);\nassign x6 = (a1&b3)^x5;\nassign x7 = (a1&b3)&x5;\nassign z2 = x2^(a2&b0);\nassign x15 = x2&(a2&b0);\nassign x14 = x4^(a2&b1)^x15;\nassign x16 = (x4&(a2&b1)) | (x4&x15) | ((a2&b1)&x15);\nassign x13 = x6^(a2&b1)^x15;\nassign x17 = (x6&(a2&b1)) | (x6&x15) | ((a2&b1)&x15);\nassign x9 = x7^(a2&b3)^x17;\nassign x8 = (x7&(a2&b3)) | (x7&x17) | ((a2&b3)&x17);\nassign z3 = x14^(a3&b0);\nassign x12 = x14&(a3&b0);\nassign z4 = x13^(a3&b1)^x12;\nassign x11 = (x13&(a3&b1)) | (x13&x12) | ((a3&b1)&x12);\nassign z5 = x9^(a3&b2)^x11;\nassign x10 = (x9&(a3&b2)) | (x9&x11) | ((a3&b2)&x11);\nassign z6 = x8^(a3&b3)^x10;\nassign z7 = (x8&(a3&b3)) | (x8&x10) | ((a3&b3)&x10);\n\nendmodule\n\n\n",
        "module_name": "mult4",
        "module_hash": "31bc9a26b74a5bad8257fa6ab75575fd",
        "dataset_index": 14501
      },
      "full_adder_32_bdde2cc8": {
        "rtl_code": "module full_adder_32(\n    input [31:0] A,\n    input [31:0] B,\n    input [31:0] Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] c;\n    wire [31:0] s;\n\n    assign c[0] = Cin;\n    genvar i;\n    generate\n        for (i = 0; i < 31; i = i + 1) begin\n            assign s[i] = A[i] ^ B[i] ^ c[i];\n            assign c[i+1] = (A[i] & B[i]) | (A[i] & c[i]) | (B[i] & c[i]);\n        end\n    endgenerate\n\n    assign s[31] = A[31] ^ B[31] ^ c[31];\n    assign Cout = (A[31] & B[31]) | (A[31] & c[31]) | (B[31] & c[31]);\n\n    assign Sum = s;\n\nendmodule",
        "module_name": "full_adder_32",
        "module_hash": "bdde2cc87f1d477af9cc04a3a33f6fd3",
        "dataset_index": 17100
      },
      "jFIFO_d3bf6635": {
        "rtl_code": "module jFIFO(DATAOUT, full, empty, clock, reset, wn, rn, DATAIN);\n  output reg [7:0] DATAOUT;\n  output full, empty;\n  input [7:0] DATAIN;\n  input clock, reset, wn, rn; reg [2:0] wptr, rptr; reg [7:0] memory [7:0]; assign full = ( (wptr == 3'b111) & (rptr == 3'b000) ? 1 : 0 );\n  assign empty = (wptr == rptr) ? 1 : 0;\n  \n  always @(posedge clock)\n  begin\n    if (reset)\n      begin\n        memory[0] <= 0; memory[1] <= 0; memory[2] <= 0; memory[3] <= 0;\n        memory[4] <= 0; memory[5] <= 0; memory[6] <= 0; memory[7] <= 0;\n        DATAOUT <= 0; wptr <= 0; rptr <= 0;\n      end\n    else if (wn & !full)\n      begin\n        memory[wptr] <= DATAIN;\n        wptr <= wptr + 1;\n      end\n    else if (rn & !empty)\n      begin\n        DATAOUT <= memory[rptr];\n        rptr <= rptr + 1;\n      end\n  end\nendmodule\n",
        "module_name": "jFIFO",
        "module_hash": "d3bf66358fdf32bf1483a626b4807aa3",
        "dataset_index": 22691
      },
      "touch_sensor_interface_12ad1c26": {
        "rtl_code": "\nmodule touch_sensor_interface (\n  input sensor_type,\n  input touch,\n  output reg touched\n);\n\n  // Capacitive sensing algorithm\n  reg cap_sense;\n  always @ (posedge touch) begin\n    if (sensor_type == 1'b1) begin\n      cap_sense <= !cap_sense;\n    end\n  end\n\n  // Resistive sensing algorithm\n  reg res_sense;\n  always @ (posedge touch) begin\n    if (sensor_type == 1'b0) begin\n      res_sense <= !res_sense;\n    end\n  end\n\n  // Output signal\n  always @ (*) begin\n    if (sensor_type == 1'b1) begin\n      touched = cap_sense;\n    end else begin\n      touched = res_sense;\n    end\n  end\n\nendmodule\n",
        "module_name": "touch_sensor_interface",
        "module_hash": "12ad1c264656fe6ac639a3adce6f15bd",
        "dataset_index": 14833
      },
      "ds8dac1_b7b7a670": {
        "rtl_code": "module ds8dac1(clk, PWM_in, PWM_out);\ninput clk;\ninput [7:0] PWM_in;\noutput reg PWM_out;\nreg [8:0] PWM_accumulator;\n\nreg [7:0] PWM_add;\n\ninitial\nbegin\n\tPWM_accumulator <= 0;\n\tPWM_add <=0;\nend\n\nalways @(posedge clk) begin\n\tPWM_accumulator <= PWM_accumulator[7:0] + PWM_add;\n\tPWM_add <= PWM_in;\nend\n\nalways @(negedge clk) begin\n\tPWM_out <= PWM_accumulator[8];\nend\n\nendmodule\n\n",
        "module_name": "ds8dac1",
        "module_hash": "b7b7a6708a29ce48805533864c0a5a15",
        "dataset_index": 20985
      },
      "rotator_pipeline_a20824da": {
        "rtl_code": "module rotator_pipeline(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nreg [99:0] pipeline_reg1, pipeline_reg2, pipeline_reg3;\n\nalways @(posedge clk) begin\n    if (load) begin\n        pipeline_reg1 <= data;\n        pipeline_reg2 <= pipeline_reg1;\n        pipeline_reg3 <= pipeline_reg2;\n    end else begin\n        pipeline_reg1 <= pipeline_reg3;\n        pipeline_reg2 <= pipeline_reg1;\n        pipeline_reg3 <= pipeline_reg2;\n    end\nend\n\nalways @* begin\n    case (ena)\n        2'b00: q = pipeline_reg3;\n        2'b01: q = {pipeline_reg3[99], pipeline_reg3[98:0]};\n        2'b10: q = {pipeline_reg3[99:1], pipeline_reg3[0]};\n        2'b11: q = pipeline_reg3;\n    endcase\nend\n\nendmodule",
        "module_name": "rotator_pipeline",
        "module_hash": "a20824dadc925dd6d543cd6b9b2ebbba",
        "dataset_index": 6869
      },
      "mult4_0d7bf4d4": {
        "rtl_code": "module mult4 ( \n    a0, a1, a2, a3, b0, b1, b2, b3,\n    z0, z1, z2, z3, z4, z5, z6, z7  );\n  input  a0, a1, a2, a3, b0, b1, b2, b3;\n  output z0, z1, z2, z3, z4, z5, z6, z7;\n  wire n18, n19, n20, n21, n23, n24, n25, n26, n27, n28, n29, n30, n31, n32,\n    n33, n34, n36, n37, n38, n39, n40, n41, n42, n43, n44, n45, n46, n47,\n    n48, n49, n50, n51, n52, n53, n54, n55, n56, n57, n58, n60, n61, n62,\n    n63, n64, n65, n66, n67, n68, n69, n70, n71, n72, n73, n74, n75, n76,\n    n77, n78, n79, n80, n81, n83, n84, n85, n86, n87, n88, n89, n90, n91,\n    n92, n93, n94, n95, n96, n97, n98, n99, n100, n101, n102, n103, n104,\n    n105, n106, n108, n109, n110, n111, n112, n113, n114, n115, n116, n117,\n    n118, n119, n120, n121, n122, n123, n125, n126, n127, n128;\n  assign z0 = a0 & b0;\n  assign n18 = a1 & b0;\n  assign n19 = a0 & b1;\n  assign n20 = ~n18 & n19;\n  assign n21 = n18 & ~n19;\n  assign z1 = n20 | n21;\n  assign n23 = n18 & n19;\n  assign n24 = a1 & b2;\n  assign n25 = a0 & b2;\n  assign n26 = ~n24 & n25;\n  assign n27 = n24 & ~n25;\n  assign n28 = ~n26 & ~n27;\n  assign n29 = n23 & n28;\n  assign n30 = ~n23 & ~n28;\n  assign n31 = ~n29 & ~n30;\n  assign n32 = a2 & b0;\n  assign n33 = n31 & n32;\n  assign n34 = ~n31 & ~n32;\n  assign z2 = n33 | n34;\n  assign n36 = n24 & n25;\n  assign n37 = n23 & n24;\n  assign n38 = ~n36 & ~n37;\n  assign n39 = n23 & n25;\n  assign n40 = n38 & ~n39;\n  assign n41 = a0 & b3;\n  assign n42 = ~n24 & n41;\n  assign n43 = n24 & ~n41;\n  assign n44 = ~n42 & ~n43;\n  assign n45 = ~n40 & n44;\n  assign n46 = n40 & ~n44;\n  assign n47 = ~n45 & ~n46;\n  assign n48 = ~n31 & n32;\n  assign n49 = a2 & b1;\n  assign n50 = n47 & n49;\n  assign n51 = ~n47 & ~n49;\n  assign n52 = ~n50 & ~n51;\n  assign n53 = n48 & n52;\n  assign n54 = ~n48 & ~n52;\n  assign n55 = ~n53 & ~n54;\n  assign n56 = a3 & b0;\n  assign n57 = n55 & n56;\n  assign n58 = ~n55 & ~n56;\n  assign z3 = n57 | n58;\n  assign n60 = n24 & n41;\n  assign n61 = n24 & ~n40;\n  assign n62 = ~n60 & ~n61;\n  assign n63 = ~n40 & n41;\n  assign n64 = n62 & ~n63;\n  assign n65 = a1 & b3;\n  assign n66 = ~n64 & ~n65;\n  assign n67 = n64 & n65;\n  assign n68 = ~n66 & ~n67;\n  assign n69 = n49 & n68;\n  assign n70 = ~n49 & ~n68;\n  assign n71 = ~n69 & ~n70;\n  assign n72 = n48 & n71;\n  assign n73 = ~n48 & ~n71;\n  assign n74 = ~n72 & ~n73;\n  assign n75 = ~n55 & n56;\n  assign n76 = a3 & b1;\n  assign n77 = n74 & n76;\n  assign n78 = ~n74 & ~n76;\n  assign n79 = ~n77 & ~n78;\n  assign n80 = n75 & n79;\n  assign n81 = ~n75 & ~n79;\n  assign z4 = n80 | n81;\n  assign n83 = ~n64 & n65;\n  assign n84 = n48 & n49;\n  assign n85 = n49 & ~n68;\n  assign n86 = n48 & ~n68;\n  assign n87 = ~n85 & ~n86;\n  assign n88 = ~n84 & n87;\n  assign n89 = a2 & b3;\n  assign n90 = ~n83 & n89;\n  assign n91 = n83 & ~n89;\n  assign n92 = ~n90 & ~n91;\n  assign n93 = ~n88 & n92;\n  assign n94 = n88 & ~n92;\n  assign n95 = ~n93 & ~n94;\n  assign n96 = n75 & n76;\n  assign n97 = ~n74 & n76;\n  assign n98 = ~n74 & n75;\n  assign n99 = ~n97 & ~n98;\n  assign n100 = ~n96 & n99;\n  assign n101 = a3 & b2;\n  assign n102 = n95 & n101;\n  assign n103 = ~n95 & ~n101;\n  assign n104 = ~n102 & ~n103;\n  assign n105 = ~n100 & n104;\n  assign n106 = n100 & ~n104;\n  assign z5 = n105 | n106;\n  assign n108 = ~n88 & n89;\n  assign n109 = n83 & n89;\n  assign n110 = n83 & ~n88;\n  assign n111 = ~n109 & ~n110;\n  assign n112 = ~n108 & n111;\n  assign n113 = ~n100 & n101;\n  assign n114 = ~n95 & n101;\n  assign n115 = ~n95 & ~n100;\n  assign n116 = ~n114 & ~n115;\n  assign n117 = ~n113 & n116;\n  assign n118 = a3 & b3;\n  assign n119 = n112 & n118;\n  assign n120 = ~n112 & ~n118;\n  assign n121 = ~n119 & ~n120;\n  assign n122 = ~n117 & n121;\n  assign n123 = n117 & ~n121;\n  assign z6 = n122 | n123;\n  assign n125 = ~n117 & n118;\n  assign n126 = ~n112 & n118;\n  assign n127 = ~n112 & ~n117;\n  assign n128 = ~n126 & ~n127;\n  assign z7 = n125 | ~n128;\nendmodule\n\n\n",
        "module_name": "mult4",
        "module_hash": "0d7bf4d44e328477486e71151571bec7",
        "dataset_index": 21731
      },
      "bm_stmt_compare_padding_cd31d451": {
        "rtl_code": "module bm_stmt_compare_padding(\n    input clock,\n    input reset_n,\n    input [2:0] a_in,\n    input [1:0] b_in,\n    output reg [3:0] out0,\n    output reg out1,\n    output reg out5,\n    output reg [3:0] out6,\n    output reg out7,\n    output reg [3:0] out8\n    );\n    \n    always @(posedge clock) begin\n        case(a_in)\n            3'b000: out0 <= 4'b1111;\n            3'b001: out0 <= 4'b1110;\n            3'b010: out0 <= 4'b1101;\n            3'b011: out0 <= 4'b1100;\n            3'b100: out0 <= 4'b1011;\n            3'b101: out0 <= 4'b1010;\n            3'b110: out0 <= 4'b1001;\n            3'b111: out0 <= 4'b1000;\n            default: out0 <= 4'b0000;\n        endcase\n    end\n    \n    always @(posedge clock) begin\n        case(b_in)\n            2'b00: out1 <= 1'b1;\n            default: out1 <= 1'b0;\n        endcase\n    end\n    \n    always @(posedge clock) begin\n        if(b_in == 2'b00) begin\n            out5 <= 1'b1;\n            out6 <= 4'b0001;\n        end else begin\n            out5 <= 1'b0;\n            out6 <= 4'b0000;\n        end\n    end\n    \n    always @(posedge clock) begin\n        case(a_in)\n            1'b0, 3'bxxx: out7 <= 1'b1;\n            3'b000: out7 <= 1'b0;\n            default: out7 <= 1'b1;\n        endcase\n        \n        case(a_in)\n            1'b0: out8 <= 4'b0001;\n            3'b000: out8 <= 4'b0100;\n            default: out8 <= 4'b0000;\n        endcase\n    end\n    \nendmodule",
        "module_name": "bm_stmt_compare_padding",
        "module_hash": "cd31d451bcf92fcdcbc3fb5de918183e",
        "dataset_index": 4783
      },
      "nios_system_charToTransmitter_e2c0eb1b": {
        "rtl_code": "module nios_system_charToTransmitter (\n  // inputs:\n  address,\n  clk,\n  in_port,\n  reset_n,\n\n  // outputs:\n  readdata\n);\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  7: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  7: 0] data_in;\n  wire    [  7: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  \n  // create a wire that is high when the clock is enabled\n  assign clk_en = 1;\n  \n  // create a wire that connects to the input data\n  assign data_in = in_port;\n  \n  // create a multiplexer that selects the data input if the address is 0, and otherwise selects 0\n  assign read_mux_out = {8 {(address == 0)}} & data_in;\n  \n  // create a register that is updated on the positive edge of the clock when clk_en is high\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      readdata <= 0;\n    end else if (clk_en) begin\n      readdata <= {32'b0, read_mux_out};\n    end\n  end\n  \nendmodule",
        "module_name": "nios_system_charToTransmitter",
        "module_hash": "e2c0eb1b8aacbdaa41be6cbc0d67f044",
        "dataset_index": 2777
      },
      "ripple_carry_adder_2419a5b0": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output [3:0] SUM,\n    output COUT\n);\n\n    wire [3:0] carry;\n    assign carry[0] = CIN;\n    \n    genvar i;\n    generate\n        for (i = 0; i < 3; i = i + 1) begin : adder\n            full_adder fa(\n                .A(A[i]),\n                .B(B[i]),\n                .CIN(carry[i]),\n                .SUM(SUM[i]),\n                .COUT(carry[i+1])\n            );\n        end\n    endgenerate\n    \n    assign SUM[3] = A[3] ^ B[3] ^ carry[3];\n    assign COUT = carry[3];\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\n    assign SUM = A ^ B ^ CIN;\n    assign COUT = (A & B) | (A & CIN) | (B & CIN);\n\nendmodule\n",
        "module_name": "ripple_carry_adder",
        "module_hash": "2419a5b0bef94862e01e6f5c4194b8b9",
        "dataset_index": 17497
      },
      "memoryaccess_95c46686": {
        "rtl_code": "module memoryaccess(\n    output reg [31:0] ReadDataM, ALUResultOut, PCBranchM2,\n    output reg [4:0] WriteRegM2, \n    output reg RegWriteM2, MemToRegM2, PCSrcM,\n    input [31:0] WriteDataM, ALUResultIn, PCBranchM1,\n    input [4:0] WriteRegM1,\n    input BranchM, MemWriteM, MemToRegM1, RegWriteM1, ZerowireM, clk\n);\n\n    reg [31:0] mem[0:1023];\n\n    always @(posedge clk) begin\n        if (MemWriteM) begin\n            mem[ALUResultIn[9:2]] <= WriteDataM;\n        end\n        if (MemToRegM1) begin\n            ReadDataM <= mem[ALUResultIn[9:2]];\n        end\n        if (RegWriteM1) begin\n            WriteRegM2 <= WriteRegM1;\n        end\n        RegWriteM2 <= RegWriteM1;\n        MemToRegM2 <= MemToRegM1;\n        ALUResultOut <= ALUResultIn;\n        PCBranchM2 <= PCBranchM1;\n        WriteRegM2 <= WriteRegM1;\n        if (BranchM & ZerowireM) begin\n            PCSrcM <= 1;\n            PCBranchM2 <= PCBranchM1 + ALUResultIn;\n        end else begin\n            PCSrcM <= 0;\n        end\n    end\n\nendmodule",
        "module_name": "memoryaccess",
        "module_hash": "95c46686f2ea6ea76ee94155c89f4591",
        "dataset_index": 19056
      },
      "bt_44529de1": {
        "rtl_code": "module bt (\n   out,\n   in\n   );\n   input [7:0] in;\n   output [7:0] out;\n\n   wire [7:0] \tout = ~in;\nendmodule module top (\n   outgo,\n   incom\n   );\n   input [31:0] incom;\n   output [31:0] outgo;\n\n   \n\n   bt BT0 (\n\t   .out\t\t\t\t(outgo[7:0]),\t\t .in\t\t\t\t(incom[7:0]));\t\t bt BT1 (\n\t   .out\t\t\t\t(outgo[15:8]),\t\t .in\t\t\t\t(incom[15:8]));\t\t bt BT2 (\n\t   .out\t\t\t\t(outgo[23:16]),\t\t .in\t\t\t\t(incom[23:16]));\t\t bt BT3 (\n\t   .out\t\t\t\t(outgo[31:24]),\t\t .in\t\t\t\t(incom[31:24]));\t\t endmodule ",
        "module_name": "bt",
        "module_hash": "44529de1bcdb44b9d750cdb62a70cc28",
        "dataset_index": 25370
      },
      "addsub_16bit_576b9748": {
        "rtl_code": "\nmodule addsub_16bit (\n    input [15:0] in0,\n    input [15:0] in1,\n    input control,\n    output reg [15:0] out\n);\n\n    always @ (in0 or in1 or control) begin\n        if (control) begin\n            out = in0 + in1;\n        end else begin\n            out = in0 - in1;\n        end\n    end\n\nendmodule\nmodule comparator_4bit (\n    input [3:0] in0,\n    input [3:0] in1,\n    output reg [3:0] out\n);\n\n    always @ (in0 or in1) begin\n        if (in0 > in1) begin\n            out = 4'b0001;\n        end else if (in0 < in1) begin\n            out = 4'b0010;\n        end else begin\n            out = 4'b0111;\n        end\n    end\n\nendmodule\nmodule top_module (\n    input [15:0] in0,\n    input [15:0] in1,\n    input control,\n    output reg [1:0] OUT\n);\n\n    wire [15:0] addsub_out;\n    wire [3:0] comp_out;\n\n    addsub_16bit addsub_inst (\n        .in0(in0),\n        .in1(in1),\n        .control(control),\n        .out(addsub_out)\n    );\n\n    comparator_4bit comp_inst (\n        .in0(addsub_out[3:0]),\n        .in1(in0[3:0]),\n        .out(comp_out)\n    );\n\n    always @ (addsub_out or comp_out) begin\n        if (comp_out == 4'b0001) begin\n            OUT <= 2'b01; // in0 > addsub_out\n        end else if (comp_out == 4'b0010) begin\n            OUT <= 2'b10; // in0 < addsub_out\n        end else begin\n            OUT <= 2'b11; // in0 == addsub_out\n        end\n    end\n\nendmodule",
        "module_name": "addsub_16bit",
        "module_hash": "576b97488b4ab16c4e12198732df96bb",
        "dataset_index": 14679
      },
      "register_addition_889be9c4": {
        "rtl_code": "module register_addition (\n  input CLK,\n  input AR,\n  input [1:0] Q_reg_0,\n  input [29:0] Q_reg_30,\n  output reg [7:0] Q\n);\n\n  reg [7:0] reg_bank [0:7];\n  integer i;\n  \n  always @(posedge CLK or posedge AR) begin\n    if (AR) begin\n      for (i = 0; i < 8; i = i + 1) begin\n        reg_bank[i] <= 8'b0;\n      end\n    end else begin\n      case (Q_reg_0)\n        2'b00: reg_bank[0] <= reg_bank[0] + Q_reg_30;\n        2'b01: reg_bank[1] <= reg_bank[1] + Q_reg_30;\n        2'b10: reg_bank[2] <= reg_bank[2] + Q_reg_30;\n        2'b11: reg_bank[3] <= reg_bank[3] + Q_reg_30;\n      endcase\n      Q <= reg_bank[Q_reg_0];\n    end\n  end\n  \nendmodule",
        "module_name": "register_addition",
        "module_hash": "889be9c45b9f9bf48d7dfda5cea93de5",
        "dataset_index": 20761
      },
      "barrel_shifter_4a724281": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [3:0] in,\n    input [1:0] ctrl,\n    output reg [3:0] out,\n    input clk  // Added clock input\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @(posedge clk) begin \n    case(ctrl)\n        2'b00: stage1_out = {in[2:0], 1'b0};\n        2'b01: stage1_out = {in[1:0], 2'b0};\n        2'b10: stage1_out = {1'b0, in[3:1]};\n        2'b11: stage1_out = {2'b0, in[3:2]};\n        default: stage1_out = 4'b0;\n    endcase\nend\n\nalways @(posedge clk) begin  \n    stage2_out <= stage1_out;\n    out <= stage2_out;       \nend\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "4a72428166429ffd3cd9106150407d44",
        "dataset_index": 21472
      },
      "sub_c92596ff": {
        "rtl_code": "module sub (\n  input subsig1,\n  input subsig2,\n  output subout\n);\n\n  // If subsig1 is 1 and subsig2 is 0, set subout to 1\n  assign subout = (subsig1 == 1 && subsig2 == 0) ? 1 :\n                  // If subsig1 is 0 and subsig2 is 1, set subout to 0\n                  (subsig1 == 0 && subsig2 == 1) ? 0 :\n                  // If both subsig1 and subsig2 are 1, set subout to 0\n                  (subsig1 == 1 && subsig2 == 1) ? 0 :\n                  // If both subsig1 and subsig2 are 0, set subout to 1\n                  1;\nendmodule",
        "module_name": "sub",
        "module_hash": "c92596ffd15489be2f45e5fc7fa2c183",
        "dataset_index": 17503
      },
      "mag_comp_9485e3d4": {
        "rtl_code": "module mag_comp (\n    input [3:0] A,\n    input [3:0] B,\n    output equal,\n    output greater\n);\n\n    assign equal = (A == B) ? 1'b1 : 1'b0;\n    assign greater = (A > B) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "mag_comp",
        "module_hash": "9485e3d404de0025ceca3dc5a9164ea6",
        "dataset_index": 17522
      },
      "axi_write_controller#_2a801015": {
        "rtl_code": "\nmodule axi_write_controller# (\n  parameter TCQ                        = 1, \n  parameter M_AXI_TDATA_WIDTH          = 32,\n  parameter M_AXI_ADDR_WIDTH           = 32,\n  parameter M_AXI_IDWIDTH              = 5,\n  parameter  BAR0AXI                   = 64'h00000000,\n  parameter  BAR1AXI                   = 64'h00000000,\n  parameter  BAR2AXI                   = 64'h00000000,\n  parameter  BAR3AXI                   = 64'h00000000,\n  parameter  BAR4AXI                   = 64'h00000000,\n  parameter  BAR5AXI                   = 64'h00000000, \n  parameter  BAR0SIZE                  = 12,\n  parameter  BAR1SIZE                  = 12,\n  parameter  BAR2SIZE                  = 12,\n  parameter  BAR3SIZE                  = 12,\n  parameter  BAR4SIZE                  = 12,\n  parameter  BAR5SIZE                  = 12\n ) (\n\n  input                                 m_axi_aclk,\n  input                                 m_axi_aresetn,\n \n  \n  output [M_AXI_ADDR_WIDTH-1 : 0]       m_axi_awaddr,\n  output [2 : 0]                        m_axi_awprot,\n  output                                m_axi_awvalid,\n  input                                 m_axi_awready,\n    \n  output [M_AXI_TDATA_WIDTH-1 : 0]      m_axi_wdata,\n  output [M_AXI_TDATA_WIDTH/8-1 : 0]    m_axi_wstrb,\n  output                                m_axi_wvalid,\n  input                                 m_axi_wready,\n    \n  input  [1 : 0]                        m_axi_bresp,\n  input                                 m_axi_bvalid,\n  output                                m_axi_bready,\n  \n  input                                 mem_req_valid,\n  output                                mem_req_ready,\n  input [2:0]                           mem_req_bar_hit,\n  input [31:0]                          mem_req_pcie_address,\n  input [3:0]                           mem_req_byte_enable,\n  input                                 mem_req_write_readn,\n  input                                 mem_req_phys_func,\n  input [31:0]                          mem_req_write_data\n  \n  );\n  \n  localparam IDLE       = 4'b0001;\n  localparam WRITE_REQ  = 4'b0010;\n  localparam WRITE_DATA = 4'b0100;\n \n  reg [3:0] aximm_wr_sm = IDLE;\n  \n  reg                 mem_req_ready_r;\n  reg                 m_axi_awvalid_r;\n  reg                 m_axi_wvalid_r;\n  reg [31:0]          m_axi_addr_c;\n  \n  reg [3:0]           mem_req_byte_enable_r;\n  reg [2:0]           mem_req_bar_hit_r;\n  reg [31:0]          mem_req_pcie_address_r;\n  reg [31:0]          mem_req_write_data_r;\n  \n \n  always @(posedge m_axi_aclk)\n     if ( !m_axi_aresetn ) begin\n        aximm_wr_sm     <= #TCQ IDLE;\n        mem_req_ready_r <= #TCQ 1'b0;\n        m_axi_awvalid_r <= #TCQ 1'b0;\n        m_axi_wvalid_r  <= #TCQ 1'b0;\n     end else\n        case (aximm_wr_sm)\n           IDLE : begin\n              if ( mem_req_valid & mem_req_write_readn ) begin\n                aximm_wr_sm     <= #TCQ WRITE_REQ;\n                m_axi_awvalid_r <= #TCQ 1'b1;\n                mem_req_ready_r <= #TCQ 1'b0;\n              end else begin\n                m_axi_awvalid_r <= #TCQ 1'b0;\n                mem_req_ready_r <= #TCQ 1'b1;\n              end\n           end\n           WRITE_REQ : begin\n              if (m_axi_awready) begin\n                aximm_wr_sm     <= #TCQ WRITE_DATA;\n                m_axi_awvalid_r <= #TCQ 1'b0;\n                m_axi_wvalid_r  <= #TCQ 1'b1;\n              end \n           end\n           WRITE_DATA : begin\n              if (m_axi_wready) begin\n                aximm_wr_sm   <= #TCQ IDLE;\n                m_axi_wvalid_r <= #TCQ 1'b0;\n                mem_req_ready_r <= #TCQ 1'b1;\n              end \n           end\n           default : begin  aximm_wr_sm <= #TCQ IDLE;\n           end   \n        endcase  \n        \n  assign mem_req_ready = mem_req_ready_r;      \n  \n  assign m_axi_awaddr  = m_axi_addr_c;\n  assign m_axi_awprot  = 0;\n  assign m_axi_awvalid = m_axi_awvalid_r;\n        \n  assign m_axi_wdata  = mem_req_write_data_r;\n  assign m_axi_wstrb  = mem_req_byte_enable_r;\n  assign m_axi_wvalid = m_axi_wvalid_r;\n        \n  assign m_axi_bready = 1'b1; \n  \n  always @(posedge m_axi_aclk) begin\n    if ( mem_req_valid & mem_req_ready & mem_req_write_readn ) begin\n      mem_req_byte_enable_r   <= mem_req_byte_enable;\n      mem_req_bar_hit_r       <= mem_req_bar_hit;\n      mem_req_pcie_address_r  <= mem_req_pcie_address;\n      mem_req_write_data_r    <= mem_req_write_data;\n    end\n  end\n  \n  always @( mem_req_bar_hit_r, mem_req_pcie_address_r )    \n     case ( mem_req_bar_hit_r )\n        3'b000: m_axi_addr_c <= { BAR0AXI[M_AXI_ADDR_WIDTH-1:BAR0SIZE], mem_req_pcie_address_r[BAR0SIZE-1:2],2'b00};\n        3'b001: m_axi_addr_c <= { BAR1AXI[M_AXI_ADDR_WIDTH-1:BAR1SIZE], mem_req_pcie_address_r[BAR1SIZE-1:2],2'b00};\n        3'b010: m_axi_addr_c <= { BAR2AXI[M_AXI_ADDR_WIDTH-1:BAR2SIZE], mem_req_pcie_address_r[BAR2SIZE-1:2],2'b00};\n        3'b011: m_axi_addr_c <= { BAR3AXI[M_AXI_ADDR_WIDTH-1:BAR3SIZE], mem_req_pcie_address_r[BAR3SIZE-1:2],2'b00};\n        3'b100: m_axi_addr_c <= { BAR4AXI[M_AXI_ADDR_WIDTH-1:BAR4SIZE], mem_req_pcie_address_r[BAR4SIZE-1:2],2'b00};\n        3'b101: m_axi_addr_c <= { BAR5AXI[M_AXI_ADDR_WIDTH-1:BAR5SIZE], mem_req_pcie_address_r[BAR5SIZE-1:2],2'b00};\n        3'b110: m_axi_addr_c <= 32'd0;\n        3'b111: m_axi_addr_c <= 32'd0;\n     endcase  \n  \n  \nendmodule\n",
        "module_name": "axi_write_controller#",
        "module_hash": "2a801015b2d171673a7f99efbb1eb618",
        "dataset_index": 24053
      },
      "barrel_shifter_ee0bfb5d": {
        "rtl_code": "module barrel_shifter (\n    input wire [15:0] in,\n    input wire [3:0] shift_amount,\n    output wire [15:0] out,\n    input wire clk // Added clock input\n);\n\n// Register Declarations\nreg [15:0] in_reg = 16'b0; // Initialize to 0\nreg [3:0] shift_amount_reg = 4'b0; // Initialize to 0\nreg [15:0] out_reg = 16'b0; // Initialize to 0\n\n// Clock Edge-Triggered Registers\nalways @(posedge clk) begin\n    in_reg <= in;\n    shift_amount_reg <= shift_amount;\nend\n\n// Barrel Shifter Logic\nalways @(posedge clk) begin\n    case (shift_amount_reg)\n        4'b0000: out_reg <= in_reg;\n        4'b0001: out_reg <= {in_reg[14:0], in_reg[15]};\n        4'b0010: out_reg <= {in_reg[13:0], in_reg[15:14]};\n        4'b0011: out_reg <= {in_reg[12:0], in_reg[15:13]};\n        4'b0100: out_reg <= {in_reg[11:0], in_reg[15:12]};\n        4'b0101: out_reg <= {in_reg[10:0], in_reg[15:11]};\n        4'b0110: out_reg <= {in_reg[9:0], in_reg[15:10]};\n        4'b0111: out_reg <= {in_reg[8:0], in_reg[15:9]};\n        4'b1000: out_reg <= {in_reg[7:0], in_reg[15:8]};\n        4'b1001: out_reg <= {in_reg[6:0], in_reg[15:7]};\n        4'b1010: out_reg <= {in_reg[5:0], in_reg[15:6]};\n        4'b1011: out_reg <= {in_reg[4:0], in_reg[15:5]};\n        4'b1100: out_reg <= {in_reg[3:0], in_reg[15:4]};\n        4'b1101: out_reg <= {in_reg[2:0], in_reg[15:3]};\n        4'b1110: out_reg <= {in_reg[1:0], in_reg[15:2]};\n        4'b1111: out_reg <= {in_reg[0], in_reg[15:1]};\n        default: out_reg <= 16'b0; // Handle the default case\n    endcase\nend\n\n// Output Assignment\nassign out = out_reg;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "ee0bfb5d54be4ef4a6e330ca0380dee0",
        "dataset_index": 704
      },
      "adder_tree_top_1b42de38": {
        "rtl_code": "`define ADDER_WIDTH 032\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "1b42de38687183b43df9b6331ff5418c",
        "dataset_index": 24840
      },
      "three_to_one_b41b0476": {
        "rtl_code": "module three_to_one (\n    input  A,\n    input  B,\n    input  C,\n    output X\n);\n\n    wire AB = A & B;\n    wire AC = A & C;\n    wire BC = B & C;\n\n    assign X = AB | AC | BC;\n\nendmodule",
        "module_name": "three_to_one",
        "module_hash": "b41b047603d54de82845f44f470bd869",
        "dataset_index": 11905
      },
      "RisingEdgeDetector_66a8c1f4": {
        "rtl_code": "module RisingEdgeDetector(\n    input in,\n    output reg out,\n    input clk\n);\n\n    reg prev_in;\n    \n    always @(posedge clk) begin\n        if (in && !prev_in) begin\n            out <= 1'b1;\n        end else begin\n            out <= 1'b0;\n        end\n        prev_in <= in;\n    end\n    \nendmodule",
        "module_name": "RisingEdgeDetector",
        "module_hash": "66a8c1f4c2d046823aceaa5499a39e7e",
        "dataset_index": 10021
      },
      "ControlUnit_b7df52a0": {
        "rtl_code": "\nmodule ControlUnit(\n\t\tinput [5:0] Special,\n\t\tinput [5:0] instructionCode,\n\t\toutput reg RegDst,\n\t\toutput reg Branch,\n\t\toutput reg BranchType,\n\t\toutput reg MemtoReg,\n\t\toutput reg [3:0]MemWrite,\n\t\toutput reg ALUSrc,\n\t\toutput reg ALUShiftImm,\n\t\toutput reg RegWrite,\n\t\toutput reg LoadImm,\n\t\toutput reg ZeroEx,\n\t\toutput reg EOP,\n\t\toutput reg [1:0] memReadWidth, output reg [3:0] aluOperation\n    );\n\nalways @* begin\n\n\tcase (Special)\n\t\t'b100000:begin\t\tEOP\t\t\t<= 0; \n\t\t\tRegDst \t\t<= 0; \n\t\t\tBranch \t\t<= 0;\n\t\t\tBranchType \t<= 0;\n\t\t\tMemtoReg\t\t<= 1;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t \t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 2;\n\t\tend\t\t\n\t\t'b100001:begin\t\tEOP\t\t\t<= 0; \n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<=\t0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 1;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 1;\n\t\tend\n\t\t'b100011:begin\t\tEOP\t\t\t<= 0; \n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 1;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b100111:begin\t\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 1;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm  \t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b100100:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 1;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 2;\n\t\tend\n\t\t'b100101:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 1;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 1;\n\t\tend\n\t\t'b101000:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 4'd1;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 0;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b101001:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 4'b0011;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 0;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b101011:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 4'b1111;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 0;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b001000:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 3;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b001100:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 1;\n\t\t\taluOperation<= 5;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b001101:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 1;\n\t\t\taluOperation<= 6;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b001110:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 1;\n\t\t\taluOperation<= 7;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b001010:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 9;\n\t\t\tmemReadWidth<= 0;\n\t\tend\t\n\t   'b001111:begin\tEOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 1;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 0;\n\t\t\tmemReadWidth<= 0;\n\t\tend\t\n\t\t'b000100:begin EOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<=\t0;\n\t\t\tBranch\t\t<= 1;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 0;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 0;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<= 4;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b000101:begin EOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 1;\n\t\t\tBranchType\t<= 1;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 0;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 0;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\taluOperation<=\t4;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\t'b111111:begin EOP\t\t\t<= 1;\n\t\t\tRegDst\t\t<= 0;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 1;\n\t\t\tALUShiftImm\t<= 0;\n\t\t\tRegWrite\t\t<= 0;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 1;\n\t\t\taluOperation<= 6;\n\t\t\tmemReadWidth<= 0;\n\t\tend\n\t\tdefault:begin EOP\t\t\t<= 0;\n\t\t\tRegDst\t\t<= 1;\n\t\t\tBranch\t\t<= 0;\n\t\t\tBranchType\t<= 0;\n\t\t\tMemtoReg\t\t<= 0;\n\t\t\tMemWrite\t\t<= 0;\n\t\t\tALUSrc\t\t<= 0;\n\t\t\tALUShiftImm <=((instructionCode==0) ||(instructionCode==2)||(instructionCode==3));\n\t\t\tRegWrite\t\t<= 1;\n\t\t\tLoadImm\t\t<= 0;\n\t\t\tZeroEx\t\t<= 0;\n\t\t\tmemReadWidth<= 0;\n\t\t\tcase(instructionCode)\n\t\t\t\t6'b000000: aluOperation <= 0; 6'b000010: aluOperation <= 1; 6'b000011: aluOperation <= 2; 6'b000110: aluOperation <= 1; 6'b000111: aluOperation <= 2; 6'b000100: aluOperation <= 0; 6'b100000: aluOperation <= 3; 6'b100010: aluOperation <= 4; 6'b100100: aluOperation <= 5; 6'b100101: aluOperation <= 6; 6'b100110: aluOperation <= 7; 6'b100111: aluOperation <= 8; 6'b101010: aluOperation <= 9; default: aluOperation\t<= 'hF;\n\t\t\tendcase\n\t\tend\n\t\t\n\tendcase;\nend\n\n\nendmodule\n",
        "module_name": "ControlUnit",
        "module_hash": "b7df52a0bbc9ded5cfa8865925e10aed",
        "dataset_index": 10479
      },
      "reg_file_187d3f91": {
        "rtl_code": "\nmodule reg_file(\n  input clk,\n  input wr_en,\n  input rd_en,\n  input [4:0] addr1,\n  input [4:0] addr2,\n  input [7:0] data_in,\n  output [7:0] data1,\n  output [7:0] data2\n);\n\nparameter n = 8; // number of registers\nparameter w = 8; // width of each register\n\nreg [w-1:0] registers [0:n-1];\n\nalways @(posedge clk) begin\n  if (wr_en) begin\n    registers[addr1] <= data_in;\n  end\nend\n\nassign data1 = rd_en ? registers[addr1] : 0;\nassign data2 = rd_en ? registers[addr2] : 0;\n\nendmodule\n",
        "module_name": "reg_file",
        "module_hash": "187d3f917d314455088990b9698f41e7",
        "dataset_index": 17787
      },
      "axi_protocol_converter_v2_1_7_w_axi3_conv #_86acf095": {
        "rtl_code": "\n\n \nmodule axi_protocol_converter_v2_1_7_w_axi3_conv #\n  (\n   parameter C_FAMILY                            = \"none\",\n   parameter integer C_AXI_ID_WIDTH              = 1,\n   parameter integer C_AXI_ADDR_WIDTH            = 32,\n   parameter integer C_AXI_DATA_WIDTH            = 32,\n   parameter integer C_AXI_SUPPORTS_USER_SIGNALS = 0,\n   parameter integer C_AXI_WUSER_WIDTH           = 1,\n   parameter integer C_SUPPORT_SPLITTING              = 1,\n                       parameter integer C_SUPPORT_BURSTS                 = 1\n                       )\n  (\n   input wire ACLK,\n   input wire ARESET,\n\n   input  wire                              cmd_valid,\n   input  wire [C_AXI_ID_WIDTH-1:0]         cmd_id,\n   input  wire [4-1:0]                      cmd_length,\n   output wire                              cmd_ready,\n   \n   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,\n   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,\n   input  wire                          S_AXI_WLAST,\n   input  wire [C_AXI_WUSER_WIDTH-1:0]  S_AXI_WUSER,\n   input  wire                          S_AXI_WVALID,\n   output wire                          S_AXI_WREADY,\n   \n   output wire [C_AXI_ID_WIDTH-1:0]     M_AXI_WID,\n   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,\n   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,\n   output wire                          M_AXI_WLAST,\n   output wire [C_AXI_WUSER_WIDTH-1:0]  M_AXI_WUSER,\n   output wire                          M_AXI_WVALID,\n   input  wire                          M_AXI_WREADY\n   );\n\n   \n  reg                             first_mi_word;\n  reg  [8-1:0]                    length_counter_1;\n  reg  [8-1:0]                    length_counter;\n  wire [8-1:0]                    next_length_counter;\n  wire                            last_beat;\n  wire                            last_word;\n  \n  wire                            cmd_ready_i;\n  wire                            pop_mi_data;\n  wire                            mi_stalling;\n  \n  wire                            S_AXI_WREADY_I;\n  \n  wire [C_AXI_ID_WIDTH-1:0]       M_AXI_WID_I;\n  wire [C_AXI_DATA_WIDTH-1:0]     M_AXI_WDATA_I;\n  wire [C_AXI_DATA_WIDTH/8-1:0]   M_AXI_WSTRB_I;\n  wire                            M_AXI_WLAST_I;\n  wire [C_AXI_WUSER_WIDTH-1:0]    M_AXI_WUSER_I;\n  wire                            M_AXI_WVALID_I;\n  wire                            M_AXI_WREADY_I;\n  \n  \n  assign S_AXI_WREADY_I = S_AXI_WVALID & cmd_valid & ~mi_stalling;\n  assign S_AXI_WREADY   = S_AXI_WREADY_I;\n  \n  assign M_AXI_WVALID_I = S_AXI_WVALID & cmd_valid;\n  \n  assign pop_mi_data    = M_AXI_WVALID_I & M_AXI_WREADY_I;\n  \n  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;\n  assign cmd_ready      = cmd_ready_i;\n  \n  assign mi_stalling    = M_AXI_WVALID_I & ~M_AXI_WREADY_I;\n  \n  \n  always @ *\n  begin\n    if ( first_mi_word )\n      length_counter = cmd_length;\n    else\n      length_counter = length_counter_1;\n  end\n  \n  assign next_length_counter = length_counter - 1'b1;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      first_mi_word    <= 1'b1;\n      length_counter_1 <= 4'b0;\n    end else begin\n      if ( pop_mi_data ) begin\n        if ( M_AXI_WLAST_I ) begin\n          first_mi_word    <= 1'b1;\n        end else begin\n          first_mi_word    <= 1'b0;\n        end\n      \n        length_counter_1 <= next_length_counter;\n      end\n    end\n  end\n  \n  assign last_beat = ( length_counter == 4'b0 );\n  \n  assign last_word = ( last_beat ) |\n                     ( C_SUPPORT_BURSTS == 0 );\n  \n  \n  assign M_AXI_WUSER_I  = ( C_AXI_SUPPORTS_USER_SIGNALS ) ? S_AXI_WUSER : {C_AXI_WUSER_WIDTH{1'b0}};\n  \n  assign M_AXI_WDATA_I  = S_AXI_WDATA;\n  assign M_AXI_WSTRB_I  = S_AXI_WSTRB;\n  \n  assign M_AXI_WID_I    = cmd_id;\n  \n  assign M_AXI_WLAST_I  = last_word;\n  \n  \n  assign M_AXI_WID      = M_AXI_WID_I;\n  assign M_AXI_WDATA    = M_AXI_WDATA_I;\n  assign M_AXI_WSTRB    = M_AXI_WSTRB_I;\n  assign M_AXI_WLAST    = M_AXI_WLAST_I;\n  assign M_AXI_WUSER    = M_AXI_WUSER_I;\n  assign M_AXI_WVALID   = M_AXI_WVALID_I;\n  assign M_AXI_WREADY_I = M_AXI_WREADY;\n  \n  \nendmodule\n",
        "module_name": "axi_protocol_converter_v2_1_7_w_axi3_conv #",
        "module_hash": "86acf095dacd0f16a4dafe4d55d68fb4",
        "dataset_index": 25281
      },
      "BUFG_cbfde447": {
        "rtl_code": "\n\nmodule BUFG(I,O);\ninput I;\noutput O;\nassign #1 O=I;\nendmodule\n\n\nmodule BUFGMUX(O,I0,I1,S);\ninput I0,I1,S;\noutput O;\nassign #1 O = (S) ? I1 : I0;\nendmodule\n\n\nmodule DCM(CLKIN,PSCLK,PSEN,PSINCDEC,RST,CLK2X,CLK0,CLKFB);\ninput CLKIN, PSCLK, PSEN, PSINCDEC, RST, CLKFB;\noutput CLK2X, CLK0;\n\nassign #1 CLK0 = CLKIN;\n\nreg CLK2X;\ninitial CLK2X=0;\nalways @(posedge CLK0)\nbegin\n  CLK2X = 1'b1;\n  #5;\n  CLK2X = 1'b0;\n  #5;\n  CLK2X = 1'b1;\n  #5;\n  CLK2X = 1'b0;\nend\nendmodule\n\n\nmodule ODDR2(Q,D0,D1,C0,C1);\ninput D0,D1,C0,C1;\noutput Q;\nreg Q;\ninitial Q=0;\nalways @(posedge C0) Q=D0;\nalways @(posedge C1) Q=D1;\nendmodule\n\n\nmodule RAMB16_S9(CLK, ADDR, DI, DIP, DO, DOP, EN, SSR, WE);\ninput CLK, EN, SSR, WE;\ninput [10:0] ADDR;\ninput [7:0] DI;\ninput DIP;\noutput [7:0] DO;\noutput DOP;\n\nparameter WRITE_MODE = 0;\n\nwire [10:0] #1 dly_ADDR = ADDR;\nwire [8:0] #1 dly_DATA = {DIP,DI};\nwire #1 dly_EN = EN;\nwire #1 dly_WE = WE;\n\nreg [8:0] mem[0:2047];\n\nreg [7:0] DO;\nreg DOP;\n\nreg sampled_EN;\nreg [8:0] rddata;\n\ninteger i;\ninitial\nbegin\n  for (i=0; i<2048; i=i+1) mem[i] = 9'h15A;\nend\n\nalways @(posedge CLK)\nbegin\n  if (dly_EN && dly_WE) mem[dly_ADDR] = dly_DATA;\n  rddata = mem[dly_ADDR];\n  sampled_EN = dly_EN;\n  #1;\n  if (sampled_EN) {DOP,DO} = rddata; \nend\nendmodule\n\n\nmodule RAM16X1S (A0,A1,A2,A3,WCLK,WE,D,O);\ninput A0,A1,A2,A3,WCLK,WE,D;\noutput O;\n\nreg mem[0:15];\n\nwire #1 dly_WE = WE;\nwire #1 dly_D = D;\nwire [3:0] addr = {A3,A2,A1,A0};\nwire [3:0] #1 dly_addr = addr;\n\nalways @(posedge WCLK)\nbegin\n  if (dly_WE) mem[dly_addr] = dly_D;\nend\n\nreg [3:0] rdaddr;\nreg O;\nalways @*\nbegin\n  rdaddr = dly_addr;\n  #1;\n  O = mem[rdaddr];\nend\nendmodule\n\n\nmodule RAM16X4S (A0,A1,A2,A3,WCLK,WE,D0,D1,D2,D3,O0,O1,O2,O3);\ninput A0,A1,A2,A3,WCLK,WE,D0,D1,D2,D3;\noutput O0,O1,O2,O3;\nRAM16X1S bit0 (A0,A1,A2,A3,WCLK,WE,D0,O0);\nRAM16X1S bit1 (A0,A1,A2,A3,WCLK,WE,D1,O1);\nRAM16X1S bit2 (A0,A1,A2,A3,WCLK,WE,D2,O2);\nRAM16X1S bit3 (A0,A1,A2,A3,WCLK,WE,D3,O3);\nendmodule\n\n\nmodule SRLC16E (A0,A1,A2,A3,CLK,CE,D,Q15,Q);\ninput A0,A1,A2,A3,CLK,CE,D;\noutput Q15,Q;\n\nreg [15:0] mem;\n\nwire #1 dly_CE = CE;\nwire #1 dly_D = D;\nwire [3:0] addr = {A3,A2,A1,A0};\nwire [3:0] #1 dly_addr = addr;\n\nassign Q15 = mem[15];\n\nalways @(posedge CLK)\nbegin\n  if (dly_CE) mem = {mem,dly_D};\nend\n\nreg [3:0] rdaddr;\nreg Q;\nalways @*\nbegin\n  rdaddr = dly_addr;\n  #1;\n  Q = mem[rdaddr];\nend\nendmodule\n\n\nmodule MUXCY (S,CI,DI,O);\ninput S,CI,DI;\noutput O;\nreg O;\nalways @* begin #0.1; O = (S) ? CI : DI; end\nendmodule\n\n\n\n",
        "module_name": "BUFG",
        "module_hash": "cbfde4470223c060d484daeebc703e77",
        "dataset_index": 11132
      },
      "ripple_adder_304c8e79": {
        "rtl_code": "module ripple_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [3:0] Xor_out, And_out;\n  wire Cin_and_Xor_out;\n\n  // Implement XOR logic\n  assign Xor_out = A ^ B;\n\n  // Implement AND logic\n  assign And_out = A & B;\n\n  // Implement Cin AND (A XOR B) logic\n  assign Cin_and_Xor_out = Cin & Xor_out;\n\n  // Implement Sum output\n  assign Sum = Xor_out ^ Cin;\n\n  // Implement Cout output\n  assign Cout = Cin_and_Xor_out | And_out;\n\nendmodule",
        "module_name": "ripple_adder",
        "module_hash": "304c8e793e9b6497ecb761b380895356",
        "dataset_index": 10764
      },
      "traffic_light_control_228dea3f": {
        "rtl_code": "module traffic_light_control (\n  input clk,\n  input reset,\n  output reg red,\n  output reg yellow,\n  output reg green\n);\n\n  parameter GREEN_TIME = 30;\n  parameter YELLOW_TIME = 5;\n  parameter RED_TIME = 25;\n  \n  reg [3:0] state;\n  reg [5:0] counter;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= 3'b001;\n      counter <= 0;\n    end else begin\n      case (state)\n        3'b001: begin // Green state\n          green <= 1;\n          yellow <= 0;\n          red <= 0;\n          if (counter == GREEN_TIME * 2) begin\n            state <= 3'b010;\n            counter <= 0;\n          end else begin\n            counter <= counter + 1;\n          end\n        end\n        3'b010: begin // Yellow state\n          green <= 0;\n          yellow <= 1;\n          red <= 0;\n          if (counter == YELLOW_TIME * 2) begin\n            state <= 3'b100;\n            counter <= 0;\n          end else begin\n            counter <= counter + 1;\n          end\n        end\n        3'b100: begin // Red state\n          green <= 0;\n          yellow <= 0;\n          red <= 1;\n          if (counter == RED_TIME * 2) begin\n            state <= 3'b001;\n            counter <= 0;\n          end else begin\n            counter <= counter + 1;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "traffic_light_control",
        "module_hash": "228dea3f0ea1ed8fc04eddc4289b3d50",
        "dataset_index": 19823
      },
      "add_sub_139992b0": {
        "rtl_code": "module add_sub (\n    input [7:0] a,\n    input [7:0] b,\n    input add_sub_ctrl,\n    output reg [7:0] result,\n    output reg overflow\n);\n\n    reg [8:0] temp; // temporary register for overflow detection\n\n    always @(*) begin\n        if (add_sub_ctrl) begin // subtraction\n            temp = {1'b0, a} - {1'b1, b}; // 2's complement subtraction\n            result = temp[7:0];\n            overflow <= temp[8] ^ temp[7]; // overflow if MSB of temp is not equal to MSB of result\n        end else begin // addition\n            temp = a + b;\n            result = temp[7:0];\n            overflow <= temp[8]; // overflow if MSB of temp is 1\n        end\n    end\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "139992b0982466d58f5c1d39e22adfd8",
        "dataset_index": 11028
      },
      "synchronizer_64d05ce6": {
        "rtl_code": "module synchronizer (\n  input data_in,\n  input clk_in,\n  input rst,\n  output data_out,\n  output clk_out\n);\n\nparameter n = 3; // number of synchronizer stages\n\nreg [n-1:0] sync_data;\nreg [n-1:0] sync_clk;\n\nalways @(posedge clk_in or negedge rst) begin\n  if (~rst) begin\n    sync_data <= {n{1'b0}};\n    sync_clk <= {n{1'b0}};\n  end\n  else begin\n    sync_data <= {sync_data[n-2:0], data_in};\n    sync_clk <= {sync_clk[n-2:0], clk_in};\n  end\nend\n\nassign data_out = sync_data[n-1];\nassign clk_out = sync_clk[n-1];\n\nendmodule\n\nmodule synchronizer_reverse (\n  input data_in,\n  input clk_in,\n  input rst,\n  output data_out,\n  output clk_out\n);\n\nparameter n = 3; // number of synchronizer stages\n\nreg [n-1:0] sync_data;\nreg [n-1:0] sync_clk;\n\nalways @(posedge clk_in or negedge rst) begin\n  if (~rst) begin\n    sync_data <= {n{1'b0}};\n    sync_clk <= {n{1'b0}};\n  end\n  else begin\n    sync_data <= {sync_data[n-2:0], data_in};\n    sync_clk <= {sync_clk[n-2:0], clk_in};\n  end\nend\n\nassign data_out = sync_data[n-1];\nassign clk_out = sync_clk[n-1];\n\nendmodule",
        "module_name": "synchronizer",
        "module_hash": "64d05ce62b05e5502edbcfaff443fa4b",
        "dataset_index": 1254
      },
      "nor4b_0672d10c": {
        "rtl_code": "module nor4b (\n    Y  ,\n    Y_N,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    // Module ports\n    output Y  ;\n    output Y_N;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    // Local signals\n    wire not0_out  ;\n    wire nor0_out_Y;\n\n    // Implement NOT gate using built-in \"not\" primitive\n    not not0 (not0_out, D_N);\n\n    // Implement NOR gate using built-in \"nor\" primitive\n    nor nor0 (nor0_out_Y, A, B, C, not0_out);\n\n    // Implement buffer to invert output of NOR gate\n    buf buf0 (Y, nor0_out_Y);\n    not not1 (Y_N, Y);\n\nendmodule",
        "module_name": "nor4b",
        "module_hash": "0672d10c023fd93301c64ed8aeb416f1",
        "dataset_index": 7543
      },
      "lsu_dc_parity_gen_f139e1e1": {
        "rtl_code": "module lsu_dc_parity_gen (parity_out, data_in);\n\nparameter WIDTH = 8 ;\nparameter NUM = 16 ;\n\ninput\t[WIDTH * NUM - 1 : 0]\tdata_in ; output\t[NUM - 1 : 0]\t\tparity_out ; reg\t[NUM - 1 : 0]\t\tparity ; integer i ;\ninteger j ;\n\nalways @(data_in)\n    for (i = 0; i <= NUM - 1 ; i = i + 1) begin\n\t    parity[i] = 1'b0 ;\n        for (j = WIDTH * i; j <= WIDTH * (i + 1) - 1 ; j = j + 1) begin\n            parity[i] = parity[i] ^ data_in[j] ;\n        end\n    end\n\nassign parity_out[NUM - 1 : 0] = parity[NUM - 1 : 0];\n\nendmodule\n",
        "module_name": "lsu_dc_parity_gen",
        "module_hash": "f139e1e100571297771efaa014202537",
        "dataset_index": 12511
      },
      "top__bbef69e5": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\n    // Define internal wires and registers\n    wire [31:0] adder1_out;\n    wire [31:0] adder2_out;\n    reg [31:0] selected_out;\n\n    // Instantiate the two ripple carry adders\n    ripple_carry_adder adder1(.clk(clk), .a(a), .b(b), .sum(adder1_out));\n    ripple_carry_adder adder2(.clk(clk), .a(a), .b(b), .sum(adder2_out));\n\n    // Define control logic to select which adder output to use\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            selected_out <= 0;\n        end else begin\n            if (adder1_out > adder2_out) begin\n                selected_out <= adder1_out;\n            end else begin\n                selected_out <= adder2_out;\n            end\n        end\n    end\n\n    // Assign the selected output to the sum output port\n    assign sum = selected_out;\n\nendmodule\nmodule ripple_carry_adder (\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\n    // Define internal wires and registers\n    wire [31:0] carry;\n    reg [31:0] sum_reg;\n\n    // Implement the ripple carry adder logic\n    assign carry[0] = 1'b0;\n    genvar i;\n    generate\n        for (i = 0; i < 31; i = i + 1) begin\n            assign carry[i+1] = (sum_reg[i] + a[i] + b[i]) > 1;\n            assign sum[i] = sum_reg[i] ^ a[i] ^ b[i] ^ carry[i];\n        end\n        assign sum[31] = sum_reg[31] ^ a[31] ^ b[31] ^ carry[31];\n    endgenerate\n\n    // Instantiate the register for the sum output\n    always @ (posedge clk) begin\n        sum_reg <= sum;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "bbef69e57f758ee8a14dedd0d3627f8e",
        "dataset_index": 6277
      },
      "mux4_23f79ae5": {
        "rtl_code": "module mux4(\n   // Outputs\n   output reg [DW-1:0] out,\n   // Inputs\n   input [DW-1:0]  in0,\n   input [DW-1:0]  in1,\n   input [DW-1:0]  in2,\n   input [DW-1:0]  in3,\n   input           sel0,\n   input           sel1,\n   input           sel2,\n   input           sel3\n   );\n\n   parameter DW=99;\n  \n   always @(*) begin\n      out = ({(DW){sel0}} & in0 |\n             {(DW){sel1}} & in1 |\n             {(DW){sel2}} & in2 |\n             {(DW){sel3}} & in3);\n   end\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "23f79ae59c6b0a336ecd720fed1d8a04",
        "dataset_index": 4075
      },
      "nand_gate_ebf0bd74": {
        "rtl_code": "module nand_gate (\n    Z,\n    A,\n    B\n);\n\n    output Z;\n    input A;\n    input B;\n\n    assign Z = ~(A & B);\n\nendmodule",
        "module_name": "nand_gate",
        "module_hash": "ebf0bd7474b9ec76d29847d2b09980b2",
        "dataset_index": 7454
      },
      "top__d7af0994": {
        "rtl_code": "module top_module (\n  input clk,\n  input reset, // Synchronous active-high reset\n  input [7:0] d, // 8-bit input for the shift registers\n  input select, // Select input to choose between the original and modified input value\n  output reg [3:0] q // 4-bit output from the XOR operation module\n);\n\n  // Shift and OR operation module\n  reg [7:0] shifted_value;\n  always @ (posedge clk) begin\n    if (reset) begin\n      shifted_value <= 0;\n    end else begin\n      shifted_value <= {d[1:0], 4'b0} | 4'b1100;\n    end\n  end\n\n  // 2-to-1 MUX module\n  reg [7:0] mux_output;\n  always @ (*) begin\n    if (select) begin\n      mux_output = shifted_value;\n    end else begin\n      mux_output = d;\n    end\n  end\n\n  // Shift register module\n  wire [3:0] shift_reg1_out;\n  wire [3:0] shift_reg2_out;\n  my_dff dff1 (.clk(clk), .reset(reset), .d(mux_output[3]), .q(shift_reg1_out[0]));\n  my_dff dff2 (.clk(clk), .reset(reset), .d(mux_output[2]), .q(shift_reg1_out[1]));\n  my_dff dff3 (.clk(clk), .reset(reset), .d(mux_output[1]), .q(shift_reg1_out[2]));\n  my_dff dff4 (.clk(clk), .reset(reset), .d(mux_output[0]), .q(shift_reg1_out[3]));\n  my_dff dff5 (.clk(clk), .reset(reset), .d(mux_output[7]), .q(shift_reg2_out[0]));\n  my_dff dff6 (.clk(clk), .reset(reset), .d(mux_output[6]), .q(shift_reg2_out[1]));\n  my_dff dff7 (.clk(clk), .reset(reset), .d(mux_output[5]), .q(shift_reg2_out[2]));\n  my_dff dff8 (.clk(clk), .reset(reset), .d(mux_output[4]), .q(shift_reg2_out[3]));\n\n  // XOR operation module\n  always @ (*) begin\n    q = shift_reg1_out ^ shift_reg2_out;\n  end\n\nendmodule\n\nmodule my_dff (\n  input clk,\n  input reset,\n  input d,\n  output reg q\n);\n  always @ (posedge clk) begin\n    if (reset) begin\n      q <= 0;\n    end else begin\n      q <= d;\n    end\n  end\nendmodule",
        "module_name": "top_",
        "module_hash": "d7af09945a0e36012c0a4fa0c9687dd4",
        "dataset_index": 12442
      },
      "my__a45e1933": {
        "rtl_code": "\nmodule my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n\n    wire not_A1, not_A2, not_B1, not_C1, A1_and_not_B1, A2_and_not_C1;\n\n    // Invert inputs\n    not (not_A1, A1);\n    not (not_A2, A2);\n    not (not_B1, B1);\n    not (not_C1, C1);\n\n    // Calculate A1 AND NOT B1\n    and (A1_and_not_B1, A1, not_B1);\n\n    // Calculate A2 AND NOT C1\n    and (A2_and_not_C1, A2, not_C1);\n\n    // Calculate output\n    or (X, A1_and_not_B1, A2_and_not_C1);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "a45e1933cee699291344fbb9b9fb43b8",
        "dataset_index": 17166
      },
      "calc_b3b3db6e": {
        "rtl_code": "module calc(\n    input [3:0] num1,\n    input [3:0] num2,\n    input op,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        if(op == 0) begin // addition\n            result <= num1 + num2;\n        end else begin // subtraction\n            result <= num1 - num2;\n        end\n    end\n\nendmodule",
        "module_name": "calc",
        "module_hash": "b3b3db6ede19a6e2910862ebffa958ce",
        "dataset_index": 6899
      },
      "mux_parity_add_85396265": {
        "rtl_code": "module mux_parity_add (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output reg [3:0] out,\n  output reg parity\n);\n\n  reg [3:0] selected_data;\n  reg [1:0] add_result;\n\n  always @(*) begin\n    case (sel)\n      3'b000: selected_data = data0;\n      3'b001: selected_data = data1;\n      3'b010: selected_data = data2;\n      3'b011: selected_data = data3;\n      3'b100: selected_data = data4;\n      3'b101: selected_data = data5;\n      default: selected_data = 4'b0000;\n    endcase\n  end\n\n  always @(*) begin\n    add_result = selected_data[1:0] - selected_data[3:2];\n  end\n\n  always @(*) begin\n    out = {add_result, selected_data[3:2]};\n    parity = ~^out;\n  end\n\nendmodule",
        "module_name": "mux_parity_add",
        "module_hash": "853962658a45a376a1f8c355f8e6aeaa",
        "dataset_index": 14140
      },
      "icache_tag_ram_2f247008": {
        "rtl_code": "module icache_tag_ram\n(\n    input           clk_i\n    ,input           rst_i\n    ,input  [  7:0]  addr_i\n    ,input  [ 19:0]  data_i\n    ,input           wr_i\n\n    ,output [ 19:0]  data_o\n);\n\n\n\n\nreg [19:0]   ram [255:0] ;\nreg [19:0]   ram_read_q;\n\nalways @ (posedge clk_i)\nbegin\n    if (wr_i)\n        ram[addr_i] <= data_i;\n    ram_read_q <= ram[addr_i];\nend\n\nassign data_o = ram_read_q;\n\n\n\nendmodule\n",
        "module_name": "icache_tag_ram",
        "module_hash": "2f247008d9409597b296184053f163a5",
        "dataset_index": 23158
      },
      "light_up_3c2fd812": {
        "rtl_code": "module light_up\n(\n    clk,\n    header,\n    counter,\n    tachy_pin,\n    brady_pin,\n    normal_pin\n);\n\ninput clk;\ninput [7:0] header;\ninput [31:0] counter;\noutput tachy_pin;\noutput brady_pin;\noutput normal_pin;\n\nparameter FAST_BEAT = 32'd750;\nparameter SLOW_BEAT = 32'd1800;\nparameter CORRECT_HEAD1 = 8'd4;\nparameter CORRECT_HEAD2 = 8'd6;\n\nreg brady_flash;\nreg tachy_flash;\nreg [31:0] counter_previous;\n\nwire [31:0] difference;\nwire correct_header;\nwire too_fast;\nwire too_slow;\n\nassign correct_header = (header == CORRECT_HEAD1 || header == CORRECT_HEAD2);\nassign difference = counter - counter_previous;\nassign too_fast = difference <= FAST_BEAT;\nassign too_slow = difference >= SLOW_BEAT;\n\nalways @(posedge clk) begin\n    if (correct_header) begin\n        tachy_flash <= too_fast;\n        brady_flash <= too_slow;\n        counter_previous <= counter;\n    end\nend\n\nled_flasher tachy_flasher (\n    .clk(clk),\n    .LED_flash(tachy_flash),\n    .LED_out(tachy_pin)\n);\n\nled_flasher brady_flasher (\n    .clk(clk),\n    .LED_flash(brady_flash),\n    .LED_out(brady_pin)\n);\n\nassign normal_pin = !tachy_flash && !brady_flash;\n\nendmodule\n\nmodule led_flasher (\n    input clk,\n    input LED_flash,\n    output LED_out\n);\n\nreg [31:0] counter;\n\nalways @(posedge clk) begin\n    if (LED_flash) begin\n        counter <= counter + 1;\n    end else begin\n        counter <= 0;\n    end\nend\n\nassign LED_out = (counter >= 16'd8);\n\nendmodule",
        "module_name": "light_up",
        "module_hash": "3c2fd8128a3dae4f826375da6b08be82",
        "dataset_index": 11033
      },
      "uart_rx_514ef1e6": {
        "rtl_code": "module uart_rx(\n    input             clk,\n    input             rst,\n    input             RxD,              input             uart_tick_16x,    output reg [7:0]  RxD_data = 0,     output            ready             );\n\n    localparam [3:0] IDLE=0;        localparam [3:0] START=1;       localparam [3:0] BIT_0=2;       localparam [3:0] BIT_1=3;       localparam [3:0] BIT_2=4;       localparam [3:0] BIT_3=5;       localparam [3:0] BIT_4=6;       localparam [3:0] BIT_5=7;       localparam [3:0] BIT_6=8;       localparam [3:0] BIT_7=9;       localparam [3:0] STOP=10;       reg [3:0] state       = IDLE;\n    reg       clk_lock    = 0;\n    reg [3:0] bit_spacing = 4'b1110;   wire capture;\n    wire next_bit;\n\n    assign capture  = (uart_tick_16x & next_bit & (state!=IDLE) & (state!=STOP));\n    assign next_bit = (bit_spacing == 4'b1111);\n\n\n    reg [1:0] RxD_sync = 2'b11; always @(posedge clk) begin\n        RxD_sync <= (uart_tick_16x) ? {RxD_sync[0], RxD} : RxD_sync;\n    end\n\n    reg [1:0] RxD_cnt = 0;\n    reg RxD_bit       = 1; always @(posedge clk) begin\n        if (uart_tick_16x) begin\n            case (RxD_sync[1])\n                0:  RxD_cnt <= (RxD_cnt == 2'b11) ? RxD_cnt : RxD_cnt + 2'b1;\n                1:  RxD_cnt <= (RxD_cnt == 2'b00) ? RxD_cnt : RxD_cnt - 2'b1;\n            endcase\n            RxD_bit <= (RxD_cnt == 2'b11) ? 1'b0 : ((RxD_cnt == 2'b00) ? 1'b1 : RxD_bit);\n        end\n        else begin\n            RxD_cnt <= RxD_cnt;\n            RxD_bit <= RxD_bit;\n        end\n    end\n\n    always @(posedge clk) begin\n       if (uart_tick_16x) begin\n            if (~clk_lock)\n                clk_lock <= ~RxD_bit; else\n                clk_lock <= ((state == IDLE) && (RxD_bit == 1'b1)) ? 1'b0 : clk_lock;\n            bit_spacing <= (clk_lock) ? bit_spacing + 4'b1 : 4'b1110;\n       end\n       else begin\n            clk_lock    <= clk_lock;\n            bit_spacing <= bit_spacing;\n       end\n    end\n\n    always @(posedge clk) begin\n        if (rst)\n            state <= IDLE;\n        else if (uart_tick_16x) begin\n            case (state)\n                IDLE:   state <= (next_bit & (RxD_bit == 1'b0)) ? BIT_0 : IDLE;  BIT_0:  state <= (next_bit) ? BIT_1 : BIT_0;\n                BIT_1:  state <= (next_bit) ? BIT_2 : BIT_1;\n                BIT_2:  state <= (next_bit) ? BIT_3 : BIT_2;\n                BIT_3:  state <= (next_bit) ? BIT_4 : BIT_3;\n                BIT_4:  state <= (next_bit) ? BIT_5 : BIT_4;\n                BIT_5:  state <= (next_bit) ? BIT_6 : BIT_5;\n                BIT_6:  state <= (next_bit) ? BIT_7 : BIT_6;\n                BIT_7:  state <= (next_bit) ? STOP  : BIT_7;\n                STOP:   state <= (next_bit) ? IDLE  : STOP;\n                default: state <= 4'bxxxx;\n            endcase\n        end\n        else state <= state;\n    end\n\n    always @(posedge clk) begin\n        RxD_data <= (capture) ? {RxD_bit, RxD_data[7:1]} : RxD_data[7:0];\n    end\n\n    assign ready = (uart_tick_16x & next_bit & (state==STOP));\nendmodule\n",
        "module_name": "uart_rx",
        "module_hash": "514ef1e6fdaca558316b246c62fb29d1",
        "dataset_index": 21321
      },
      "bit_counter_0f6a2b26": {
        "rtl_code": "\nmodule bit_counter (\n    input [15:0] D,\n    output [3:0] count,\n    input clk // Added the clock input\n);\n\n// Create a 4-bit parallel prefix adder\nwire [3:0] P[0:3];\nassign P[0] = D[3:0];\nassign P[1] = P[0] + D[7:4];\nassign P[2] = P[1] + D[11:8];\nassign P[3] = P[2] + D[15:12];\n\n// Register the count\nreg [3:0] count_reg;\nalways @(posedge clk) begin\n    count_reg <= P[3]; // Corrected typo here\nend\n\n// Output the count\nassign count = count_reg;\n\nendmodule\n",
        "module_name": "bit_counter",
        "module_hash": "0f6a2b26ec8974bc8d55f99ee7a879cb",
        "dataset_index": 16111
      },
      "sky130_fd_sc_hvl__o22ai_1206aa6d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hvl__o22ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out ;\n    wire nor1_out ;\n    wire or0_out_Y;\n\n    nor nor0 (nor0_out , B1, B2            );\n    nor nor1 (nor1_out , A1, A2            );\n    or  or0  (or0_out_Y, nor1_out, nor0_out);\n    buf buf0 (Y        , or0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hvl__o22ai",
        "module_hash": "1206aa6d899353eaee4a11eccbe94e15",
        "dataset_index": 13389
      },
      "vga_bsprite_fdd46af8": {
        "rtl_code": "\nmodule vga_bsprite(\n\tinput wire vidon,\n\tinput wire [9:0]hc,\n\tinput wire [9:0]vc,\n\tinput wire [7:0]M,\n\tinput wire [3:0]posx,\n\tinput wire [3:0]posy,\n\tinput wire [7:0]face,\n\toutput wire [9:0]rom_addr26,\n\toutput wire [7:0]rom_addr16,\n\toutput reg[2:0]red,\n\toutput reg[2:0]green,\n\toutput reg[1:0]blue,\n\toutput wire [3:0]C1,\n\toutput wire [3:0]R1\n    );\n\t \n\tparameter hbp=10'b0010010000;\n\tparameter vbp=10'b0000011111;\n\tparameter W=16;\n\tparameter H=16;\n\t\n\twire [3:0]xpix,ypix;\n\treg spriteon;wire [9:0]fx,fy;\n\treg faceon;\n\twire [19:0]addrface;\n\t\n\tassign C1=(hc-hbp-240)>>4;\n\tassign R1=(vc-vbp-200)>>4;\n\tassign ypix=vc-vbp-200-(R1<<4);\n\tassign xpix=hc-hbp-240-(C1<<4);\n\tassign rom_addr16={ypix,xpix};\n\tassign fx=hc-hbp-307;\n\tassign fy=vc-vbp-174;\n\tassign addrface={1'b0,fy,4'b0000}+{2'b0,fy,3'b000}+{4'b0000,fy,1'b0}+{5'b00000,fx};\n\tassign rom_addr26=addrface[9:0];always@(*)\n\t\tbegin\n\t\t\tif (hc-hbp>=240 && hc-hbp<400 && vc-vbp>=200 && vc-vbp<360)spriteon=1;\n\t\t\telse\n\t\t\t\tspriteon=0;\n\t\tend\n\t\t\n\talways@(*)\n\tbegin\n\t\tif(hc-hbp>=307 && hc-hbp<333 && vc-vbp>=174 && vc-vbp<200)\n\t\t\tfaceon=1;\n\t\telse\n\t\t\tfaceon=0;\n\tend\n\t\t\n\talways@(*)\n\tbegin\n\tred=0;\n\tgreen=0;\n\tblue=0;\n\tif((spriteon==1)&&(vidon==1))\n\t\tbegin\n\t\t\tred=M[7:5];\n\t\t\tgreen=M[4:2];\n\t\t\tblue=M[1:0];\n\t\t\t\n\t\t\tif(R1==posy && C1==posx)\n\t\t\tbegin\n\t\t\t\tred=(red<7)?red+1:red;\n\t\t\t\tend\n\t\tend\n\telse if( (faceon==1) && (vidon==1) )\n\tbegin\n\t\tred=face[7:5];\n\t\tgreen=face[4:2];\n\t\tblue=face[1:0];\n\tend\nend\nendmodule\n",
        "module_name": "vga_bsprite",
        "module_hash": "fdd46af8482c5619b4bef926e92557d5",
        "dataset_index": 22110
      },
      "regfile_1fb55019": {
        "rtl_code": "module regfile(\n  input clk,\n  input we,\n  input [3:0] wa,\n  input [7:0] wd,\n  input [3:0] ra,\n  output [7:0] rd,\n  output [3:0] out\n);\n\n  reg [7:0] data [0:15];\n  reg [3:0] addr;\n  \n  always @(posedge clk) begin\n    if (we) begin\n      data[wa] <= wd;\n    end\n    addr <= ra;\n  end\n  \n  assign rd = data[addr];\n  assign out = addr;\n  \nendmodule",
        "module_name": "regfile",
        "module_hash": "1fb550195dceb24f901db7d9f0f5f407",
        "dataset_index": 530
      },
      "calculator_fb14e80d": {
        "rtl_code": "module calculator(\n    input [7:0] input1,\n    input [7:0] input2,\n    input [2:0] opcode,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    case(opcode)\n        3'b000: result = input1 + input2;\n        3'b001: result = input1 - input2;\n        3'b010: result = input1 * input2;\n        3'b011: result = input1 / input2;\n        3'b100: result = input1 & input2;\n        3'b101: result = input1 | input2;\n        3'b110: result = input1 ^ input2;\n        3'b111: result = ~input1;\n        default: result = 8'b0;\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "fb14e80dd1259f91d7bcfa4162fba78d",
        "dataset_index": 5795
      },
      "four_bit_adder_484ecca3": {
        "rtl_code": "\nmodule four_bit_adder (\n    A,\n    B,\n    Cin,\n    Sum,\n    Cout\n);\n\n    input [3:0] A;\n    input [3:0] B;\n    input Cin;\n    output [3:0] Sum;\n    output Cout;\n\n    wire [3:0] Xor1;\n    wire [3:0] Xor2;\n    wire [3:0] And1;\n    wire [3:0] And2;\n    wire [3:0] Or1;\n    wire [3:0] Or2;\n    wire [3:0] Or3;\n    wire [3:0] Not1;\n    wire [3:0] Not2;\n\n    assign Xor1 = A ^ B;\n    assign And1 = A & B;\n    assign Xor2 = Xor1 ^ Cin;\n    assign And2 = Xor1 & Cin;\n    assign Sum = Xor2;\n    assign Cout = And1 | And2;\n\nendmodule\n",
        "module_name": "four_bit_adder",
        "module_hash": "484ecca36be6829ed652bfc1763adce2",
        "dataset_index": 3820
      },
      "bcd_converter_9c7f9bb3": {
        "rtl_code": "module bcd_converter (\n    input [3:0] D,\n    output reg [7:0] BCD\n);\n\n    always @(*) begin\n        case(D)\n            4'b0000: BCD = 8'b00000000;\n            4'b0001: BCD = 8'b00000001;\n            4'b0010: BCD = 8'b00000010;\n            4'b0011: BCD = 8'b00000011;\n            4'b0100: BCD = 8'b00000100;\n            4'b0101: BCD = 8'b00000101;\n            4'b0110: BCD = 8'b00000110;\n            4'b0111: BCD = 8'b00000111;\n            4'b1000: BCD = 8'b00001000;\n            4'b1001: BCD = 8'b00001001;\n            4'b1010: BCD = 8'b00010000;\n            4'b1011: BCD = 8'b00010001;\n            4'b1100: BCD = 8'b00010010;\n            4'b1101: BCD = 8'b00010011;\n            4'b1110: BCD = 8'b00010100;\n            4'b1111: BCD = 8'b00010101;\n        endcase\n    end\n\nendmodule",
        "module_name": "bcd_converter",
        "module_hash": "9c7f9bb31cf98509398cb12496441cda",
        "dataset_index": 21383
      },
      "Test_fd6d7cfc": {
        "rtl_code": "module Test (\n   // Outputs\n   out, mask,\n   // Inputs\n   clk, in\n   );\n\n   input clk;\n   input [6:0] in;\t// Note much wider than any index\n   output reg [3:0] out;\n   output reg [3:0] mask;\n   localparam [15:5] p = 11'h1ac;\n\n   always @(posedge clk) begin\n      // Calculate the value of out\n      out <= p[15 + in -: 5];\n\n      // Calculate the value of mask\n      mask[3] <= ((15 + in - 5) < 12);\n      mask[2] <= ((15 + in - 5) < 13);\n      mask[1] <= ((15 + in - 5) < 14);\n      mask[0] <= ((15 + in - 5) < 15);\n   end\n\nendmodule",
        "module_name": "Test",
        "module_hash": "fd6d7cfc5335839be6a152f3c8b9f48c",
        "dataset_index": 9274
      },
      "FSM #_91ded8bc": {
        "rtl_code": "module FSM #(\n  parameter n = 2, // number of output signals\n  parameter m = 2, // number of input signals\n  parameter s = 4 // number of states in the original FSM\n)(\n  input clk, // clock signal\n  input rst, // reset signal\n  input [m-1:0] in, // input signals\n  output reg [n-1:0] out // output signals\n);\n\n\nreg [s-1:0] state; // current state of the FSM\n\n// define the states of the FSM\nparameter STATE_0 = 2'b00;\nparameter STATE_1 = 2'b01;\nparameter STATE_2 = 2'b10;\nparameter STATE_3 = 2'b11;\n\n// define the sub-states of STATE_0\nparameter STATE_0_SUB_0 = 3'b000;\nparameter STATE_0_SUB_1 = 3'b001;\n\n// define the sub-states of STATE_1\nparameter STATE_1_SUB_0 = 3'b010;\nparameter STATE_1_SUB_1 = 3'b011;\n\n// define the sub-states of STATE_2\nparameter STATE_2_SUB_0 = 3'b100;\nparameter STATE_2_SUB_1 = 3'b101;\n\n// define the sub-states of STATE_3\nparameter STATE_3_SUB_0 = 3'b110;\nparameter STATE_3_SUB_1 = 3'b111;\n\n// define the next state logic for each state and sub-state\nalways @(posedge clk, posedge rst) begin\n  if (rst) begin\n    state <= STATE_0;\n  end else begin\n    case (state)\n      STATE_0: begin\n        if (in[0] && in[1]) begin\n          state <= STATE_1_SUB_0;\n        end else if (in[0]) begin\n          state <= STATE_0_SUB_1;\n        end else begin\n          state <= STATE_0_SUB_0;\n        end\n      end\n      STATE_1_SUB_0: begin\n        if (in[1]) begin\n          state <= STATE_2_SUB_0;\n        end else begin\n          state <= STATE_1_SUB_1;\n        end\n      end\n      STATE_1_SUB_1: begin\n        if (in[0]) begin\n          state <= STATE_0_SUB_0;\n        end else begin\n          state <= STATE_1_SUB_0;\n        end\n      end\n      STATE_2_SUB_0: begin\n        if (in[0] && in[1]) begin\n          state <= STATE_3_SUB_0;\n        end else if (in[1]) begin\n          state <= STATE_2_SUB_1;\n        end else begin\n          state <= STATE_2_SUB_0;\n        end\n      end\n      STATE_2_SUB_1: begin\n        if (in[0]) begin\n          state <= STATE_1_SUB_1;\n        end else begin\n          state <= STATE_2_SUB_0;\n        end\n      end\n      STATE_3_SUB_0: begin\n        if (in[0]) begin\n          state <= STATE_0_SUB_1;\n        end else if (in[1]) begin\n          state <= STATE_3_SUB_1;\n        end else begin\n          state <= STATE_3_SUB_0;\n        end\n      end\n      STATE_3_SUB_1: begin\n        if (in[0] && in[1]) begin\n          state <= STATE_1_SUB_0;\n        end else begin\n          state <= STATE_3_SUB_0;\n        end\n      end\n    endcase\n  end\nend\n\n// define the output logic for each state and sub-state\nalways @* begin\n  case (state)\n    STATE_0_SUB_0: begin\n      out[0] <= 1'b0;\n      out[1] <= 1'b0;\n    end\n    STATE_0_SUB_1: begin\n      out[0] <= 1'b0;\n      out[1] <= 1'b1;\n    end\n    STATE_1_SUB_0: begin\n      out[0] <= 1'b1;\n      out[1] <= 1'b0;\n    end\n    STATE_1_SUB_1: begin\n      out[0] <= 1'b1;\n      out[1] <= 1'b1;\n    end\n    STATE_2_SUB_0: begin\n      out[0] <= 1'b0;\n      out[1] <= 1'b1;\n    end\n    STATE_2_SUB_1: begin\n      out[0] <= 1'b1;\n      out[1] <= 1'b0;\n    end\n    STATE_3_SUB_0: begin\n      out[0] <= 1'b1;\n      out[1] <= 1'b1;\n    end\n    STATE_3_SUB_1: begin\n      out[0] <= 1'b0;\n      out[1] <= 1'b0;\n    end\n  endcase\nend\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "91ded8bca0c6db029643b5e5defed693",
        "dataset_index": 5120
      },
      "ACA_I_N32_Q8_c8e29cf6": {
        "rtl_code": "\nmodule ACA_I_N32_Q8(\n    input [31:0] in1,\n    input [31:0] in2,\n    output [32:0] res\n    );\n\nwire [8:0] temp1,temp2,temp3,temp4,temp5,temp6,temp7,temp8,temp9,temp10;\nwire [8:0] temp11,temp12,temp13,temp14,temp15,temp16,temp17,temp18,temp19;\nwire [8:0] temp20,temp21,temp22,temp23,temp24,temp25;\n\nassign temp1[8:0] = in1[7:0] + in2[7:0];\nassign temp2[8:0] = in1[8:1] + in2[8:1];\nassign temp3[8:0] = in1[9:2] + in2[9:2];\nassign temp4[8:0] = in1[10:3] + in2[10:3];\nassign temp5[8:0] = in1[11:4] + in2[11:4];\nassign temp6[8:0] = in1[12:5] + in2[12:5];\nassign temp7[8:0] = in1[13:6] + in2[13:6];\nassign temp8[8:0] = in1[14:7] + in2[14:7];\nassign temp9[8:0] = in1[15:8] + in2[15:8];\nassign temp10[8:0] = in1[16:9] + in2[16:9];\nassign temp11[8:0] = in1[17:10] + in2[17:10];\nassign temp12[8:0] = in1[18:11] + in2[18:11];\nassign temp13[8:0] = in1[19:12] + in2[19:12];\nassign temp14[8:0] = in1[20:13] + in2[20:13];\nassign temp15[8:0] = in1[21:14] + in2[21:14];\nassign temp16[8:0] = in1[22:15] + in2[22:15];\nassign temp17[8:0] = in1[23:16] + in2[23:16];\nassign temp18[8:0] = in1[24:17] + in2[24:17];\nassign temp19[8:0] = in1[25:18] + in2[25:18];\nassign temp20[8:0] = in1[26:19] + in2[26:19];\nassign temp21[8:0] = in1[27:20] + in2[27:20];\nassign temp22[8:0] = in1[28:21] + in2[28:21];\nassign temp23[8:0] = in1[29:22] + in2[29:22];\nassign temp24[8:0] = in1[30:23] + in2[30:23];\nassign temp25[8:0] = in1[31:24] + in2[31:24];\n\nassign res[32:0] = {temp25[8:7],temp24[7],temp23[7],temp22[7],temp21[7],temp20[7],temp19[7],temp18[7],temp17[7],temp16[7],temp15[7],temp14[7],temp13[7],temp12[7],temp11[7],temp10[7],temp9[7],temp8[7],temp7[7],temp6[7],temp5[7],temp4[7],temp3[7],temp2[7],temp1[7:0]};\n\nendmodule\n",
        "module_name": "ACA_I_N32_Q8",
        "module_hash": "c8e29cf6c93347c6773da184a2522975",
        "dataset_index": 24600
      },
      "csr#_f158ed0a": {
        "rtl_code": "module csr#(\n    parameter NUM_CH = 8,\n    parameter NUM_SPDIF_IN = 3,\n    parameter NUM_RATE = 5,\n\n    parameter VOL_WIDTH = NUM_CH*32,\n    parameter NKMDDBG_WIDTH = 16*8,\n    parameter RATE_WIDTH = NUM_SPDIF_IN*NUM_RATE,\n    parameter UDATA_WIDTH = NUM_SPDIF_IN*192,\n    parameter CDATA_WIDTH = UDATA_WIDTH\n)(\n    input wire clk,\n    input wire rst,\n\n    input wire [11:0] addr_i,\n\n    input wire ack_i,\n    input wire [7:0] data_i,\n\n    output wire [7:0] data_o,\n\n    output wire [(VOL_WIDTH-1):0] vol_o, output wire nkmd_rst_o, input wire [(NKMDDBG_WIDTH-1):0] nkmd_dbgout_i, output wire [(NKMDDBG_WIDTH-1):0] nkmd_dbgin_o, input wire [(RATE_WIDTH-1):0] rate_i,  input wire [(UDATA_WIDTH-1):0] udata_i,  input wire [(CDATA_WIDTH-1):0] cdata_i  );\n\nreg [7:0] data_o_ff;\nreg ack_o_ff;\n\nwire [3:0] addr_tag = addr_i[11:8];\nwire [7:0] addr_offset = addr_i[7:0];\n\nreg [(VOL_WIDTH-1):0] vol_ff;\nassign vol_o = vol_ff;\n\nreg nkmd_rst_ff;\nassign nkmd_rst_o = nkmd_rst_ff;\nreg [(NKMDDBG_WIDTH-1):0] nkmd_dbgin_ff;\nassign nkmd_dbgin_o = nkmd_dbgin_ff;\n\ninteger i;\nalways @(posedge clk) begin\n    if(rst) begin\n        vol_ff <= {(NUM_CH*2){16'h00ff}};\n        nkmd_rst_ff <= 1'b1;\n        nkmd_dbgin_ff <= {(NKMDDBG_WIDTH){1'b0}};\n    end else if(ack_i) begin\n        case(addr_tag)\n            4'h0: begin\n                for(i = 0; i < 8; i = i + 1)\n                    vol_ff[(addr_offset*8 + i)] <= data_i[i];\n            end\n            4'h4: begin\n                nkmd_rst_ff <= data_i[0];\n            end\n            4'h6: begin\n                for(i = 0; i < 8; i = i + 1)\n                    nkmd_dbgin_ff[(addr_offset*8 + i)] <= data_i[i];\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    case(addr_tag)\n        4'h0:\n            data_o_ff <= vol_ff[(addr_offset*8) +: 8];\n        4'h4:\n            data_o_ff <= {7'b0000_000, nkmd_rst_ff};\n        4'h5:\n            data_o_ff <= nkmd_dbgout_i[(addr_offset*8) +: 8];\n        4'h6:\n            data_o_ff <= nkmd_dbgin_ff[(addr_offset*8) +: 8];\n        4'h8:\n            data_o_ff <= rate_i[(addr_offset*NUM_RATE) +: NUM_RATE];\n        4'h9:\n            data_o_ff <= udata_i[(addr_offset*8) +: 8];\n        4'ha:\n            data_o_ff <= cdata_i[(addr_offset*8) +: 8];\n        default:\n            data_o_ff <= 0;\n    endcase\nend\nassign data_o = data_o_ff;\n\nendmodule\n",
        "module_name": "csr#",
        "module_hash": "f158ed0a40c5afaa7344f38e1de26daf",
        "dataset_index": 17945
      },
      "my__35b1a70d": {
        "rtl_code": "module my_module (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    // Module ports\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    // Local signals\n    wire nand0_out ;\n    wire nand1_out ;\n    wire and0_out_Y;\n    wire and1_out_Y;\n\n    // Implementing the required logic\n    nand nand0 (nand0_out , A2, A1              );\n    nand nand1 (nand1_out , B2, B1              );\n    and  and0  (and0_out_Y, nand0_out, nand1_out);\n    not  not0  (and1_out_Y, and0_out_Y          );\n    buf  buf0  (Y         , and1_out_Y          );\n\nendmodule",
        "module_name": "my_",
        "module_hash": "35b1a70df46a7e7b5e8a9de629ae6d48",
        "dataset_index": 15450
      },
      "pm_clk_real_39899570": {
        "rtl_code": "module pm_clk_real(\n    input             clk,\n    input             rst,\n    input             real_speed,\n    input             rst_counter,\n    input             irq_n,\n    input             uart_speed,\n    output reg        ym_pm,\n    output reg [31:0] pm_counter\n);\n\nparameter stop=5'd07;\nreg [4:0] div_cnt, cambio0, cambio1; \n\n// Multiplexer for selecting clock speed\nalways @(posedge clk or posedge rst) begin : speed_mux\n    if (rst) begin\n        cambio0 <= 5'd2;\n        cambio1 <= 5'd4;\n    end else begin\n        if (real_speed) begin\n            cambio0 <= 5'd2;\n            cambio1 <= 5'd4;\n        end else begin\n            if (uart_speed) begin\n                cambio0 <= 5'd4;\n                cambio1 <= 5'd8;\n            end else begin\n                cambio0 <= 5'd7;\n                cambio1 <= 5'd15;\n            end\n        end\n    end\nend\n\n// Flip-flop for generating ym_pm signal\nalways @(posedge clk or posedge rst) begin : ym_pm_ff\n    if (rst) begin\n        div_cnt <= 5'd0;\n        ym_pm <= 1'b0;\n    end else begin    \n        if (div_cnt >= cambio1) begin\n            ym_pm <= 1'b1;\n            div_cnt <= 5'd0;\n        end else begin\n            if (div_cnt == cambio0) begin\n                ym_pm <= 1'b0;\n            end\n            div_cnt <= div_cnt + 1'b1;\n        end\n    end\nend\n\n// Flip-flop for generating pm_counter signal\nreg ultpm;\nalways @(posedge clk or posedge rst) begin : pm_counter_ff\n    if (rst) begin\n        pm_counter <= 32'd0;\n        ultpm <= 1'b0;\n    end else begin\n        ultpm <= ym_pm;\n        if (rst_counter) begin\n            pm_counter <= 32'd0;\n        end else begin\n            if (irq_n && ym_pm && !ultpm) begin\n                pm_counter <= pm_counter + 1'd1;        \n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "pm_clk_real",
        "module_hash": "3989957045e47377fa807dc469a656a3",
        "dataset_index": 17947
      },
      "ROM_A_e89c2681": {
        "rtl_code": "module ROM_A(\n    input [31:0] addr,\n    output [31:0] inst\n);\n\n    reg [31:0]instructions[128:0];\n    \n    initial begin\n        // Initialize ROM with instructions\n        instructions[0] = 32'h00000026;\n        instructions[1] = 32'h00210826;\n        instructions[2] = 32'h00421026;\n        instructions[3] = 32'h00631826;\n        instructions[4] = 32'h00842026;\n        instructions[5] = 32'h00a52826;\n        instructions[6] = 32'h00c63026;\n        instructions[7] = 32'h00e73826;\n        instructions[8] = 32'h01084026;\n        instructions[9] = 32'h01294826;\n        instructions[10] = 32'h014a5026;\n        instructions[11] = 32'h016b5826;\n        instructions[12] = 32'h018c6026;\n        instructions[13] = 32'h01ad6826;\n        instructions[14] = 32'h01ce7026;\n        instructions[15] = 32'h01ef7826;\n        instructions[16] = 32'h02108026;\n        instructions[17] = 32'h02318826;\n        instructions[18] = 32'h02529026;\n        instructions[19] = 32'h02739826;\n        instructions[20] = 32'h0294a026;\n        instructions[21] = 32'h02b5a826;\n        instructions[22] = 32'h02d6b026;\n        instructions[23] = 32'h02f7b826;\n        instructions[24] = 32'h0318c026;\n        instructions[25] = 32'h0339c826;\n        instructions[26] = 32'h035ad026;\n        instructions[27] = 32'h037bd826;\n        instructions[28] = 32'h039ce026;\n        instructions[29] = 32'h03bde826;\n        instructions[30] = 32'h03def026;\n        instructions[31] = 32'h03fff826;\n        instructions[32] = 32'h2108000a;\n        instructions[33] = 32'h21290001;\n        instructions[34] = 32'h214a0002;\n        instructions[35] = 32'h216b0003;\n        instructions[36] = 32'h218c0004;\n        instructions[37] = 32'h21ad000a;\n        instructions[38] = 32'h21ce000a;\n        instructions[39] = 32'h21ef000a;\n        instructions[40] = 32'h00892020;\n        instructions[41] = 32'h00aa2820;\n        instructions[42] = 32'h00cb3020;\n        instructions[43] = 32'h00ec3820;\n        instructions[44] = 32'h1488fffb;\n        instructions[45] = 32'h22100001;\n        instructions[46] = 32'h3c088000;\n        instructions[47] = 32'h00008827;\n        instructions[48] = 32'h00084042;\n        instructions[49] = 32'h02119024;\n        instructions[50] = 32'h01119825;\n        instructions[51] = 32'h0111a026;\n        instructions[52] = 32'h1408fffb;\n        instructions[53] = 32'h3c1500ff;\n        instructions[54] = 32'h22b500ff;\n        instructions[55] = 32'hac150320;\n        instructions[56] = 32'h8c160320;\n        instructions[57] = 32'h12b60000;\n        instructions[58] = 32'h00892022;\n        instructions[59] = 32'h00aa2822;\n        instructions[60] = 32'h00cb3022;\n        instructions[61] = 32'h00ec3822;\n        instructions[62] = 32'h00c0402a;\n        instructions[63] = 32'h1008fffa;\n        instructions[64] = 32'h0c000042;\n        instructions[65] = 32'h08000000;\n        instructions[66] = 32'h03e00008;\n    end\n    \n    // Output the instruction at the specified address\n    assign inst = instructions[addr];   \n\nendmodule",
        "module_name": "ROM_A",
        "module_hash": "e89c2681e2069e455d2dade87eacf1dd",
        "dataset_index": 6022
      },
      "fifo_async_4bit_wr_logic_8e0b7a63": {
        "rtl_code": "module fifo_async_4bit_wr_logic\n   (full,\n    prog_full,\n    Q,\n    O2,\n    E,\n    O3,\n    wr_clk,\n    rst_d2,\n    wr_en,\n    O1,\n    I1,\n    I2,\n    rst_full_gen_i,\n    I3,\n    D);\n  output full;\n  output prog_full;\n  output [2:0]Q;\n  output [2:0]O2;\n  output [0:0]E;\n  output [3:0]O3;\n  input wr_clk;\n  input rst_d2;\n  input wr_en;\n  input [3:0]O1;\n  input I1;\n  input I2;\n  input rst_full_gen_i;\n  input [0:0]I3;\n  input [0:0]D;\n\n  reg [2:0] count;\n  reg [2:0] count_next;\n  reg [3:0] ram [0:7];\n  reg [2:0] wr_ptr;\n  reg [2:0] rd_ptr;\n  reg full;\n  reg prog_full;\n  reg empty;\n  reg [3:0] data_out;\n\n  always @(posedge wr_clk) begin\n    if (rst_d2) begin\n      count <= 0;\n      wr_ptr <= 0;\n      rd_ptr <= 0;\n      full <= 0;\n      prog_full <= 0;\n      empty <= 1;\n    end else begin\n      if (wr_en && !full) begin\n        ram[wr_ptr] <= O1;\n        wr_ptr <= wr_ptr + 1;\n        count_next <= count + 1;\n      end else begin\n        count_next <= count;\n      end\n      \n      if (I1 && !full) begin\n        full <= (count_next == 8);\n        prog_full <= (count_next == 7);\n        count <= count_next;\n      end else if (I2 && !empty) begin\n        empty <= (count_next == 1);\n        rd_ptr <= rd_ptr + 1;\n        count <= count_next - 1;\n      end else if (I3) begin\n        count <= 0;\n        wr_ptr <= 0;\n        rd_ptr <= 0;\n        full <= 0;\n        prog_full <= 0;\n        empty <= 1;\n      end else begin\n        count <= count_next;\n      end\n    end\n  end\n\n  assign Q = count;\n  assign O2 = {count[2], count[1], 0};\n  assign E = empty;\n  assign O3 = data_out;\n\n  always @(*) begin\n    data_out = ram[rd_ptr];\n  end\n\nendmodule",
        "module_name": "fifo_async_4bit_wr_logic",
        "module_hash": "8e0b7a63e43ee37d8ae54589280d7c5f",
        "dataset_index": 138
      },
      "and_gate_09d57e5e": {
        "rtl_code": "module and_gate (\n    output Y ,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    // Implementing the 4-input AND gate with an additional input signal B1\n    assign Y = (A1 & A2 & A3 & A4 & B1);\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "09d57e5e694517b94c8003cafbde03cd",
        "dataset_index": 15696
      },
      "top__bc2d5b16": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [7:0] in1,\n    input [7:0] in2,\n    input select,\n    output reg [7:0] out\n);\n\n    wire [7:0] sum;\n    wire [7:0] diff;\n\n    adder add_inst (\n        .a(in1),\n        .b(in2),\n        .sum(sum)\n    );\n\n    subtractor sub_inst (\n        .a(in1),\n        .b(in2),\n        .diff(diff)\n    );\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            out <= 8'b0;\n        end else begin\n            if (select) begin\n                out <= diff;\n            end else begin\n                out <= sum;\n            end\n        end\n    end\n\nendmodule\n\nmodule adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "bc2d5b1648b4d28a863673b1e76997cd",
        "dataset_index": 5286
      },
      "RF_cda883c1": {
        "rtl_code": "module RF(\n\ti_op             ,   \n\t\n\ti_rsk            ,   \n\n\ti_rf_in          ,  \n\t\n\ti_rf_final       ,  \n\n\to_rf_out          \n);\n\n\ninput        i_op           ;  \n\ninput[31:0]  i_rsk          ;  \n\ninput[63:0]  i_rf_in        ;  \n\t\ninput        i_rf_final     ;  \n\noutput[63:0] o_rf_out       ;  \n\n\nwire[63:0]  w_rf_out     ;  \nwire[7:0]  w_rf_out7     ;  \nwire[7:0]  w_rf_out6     ;  \nwire[7:0]  w_rf_out5     ;  \nwire[7:0]  w_rf_out4     ;  \nwire[7:0]  w_rf_out3     ;  \nwire[7:0]  w_rf_out2     ;  \nwire[7:0]  w_rf_out1     ;  \nwire[7:0]  w_rf_out0     ;  \nwire[7:0] w_f0_6   ;  \nwire[7:0] w_f1_4   ;\nwire[7:0] w_f0_2   ;\nwire[7:0] w_f1_0   ;\nwire[7:0] w_rf_mv[0:3]; \nassign w_f0_6 = {i_rf_in[54:48],i_rf_in[55]}    ^ \n                {i_rf_in[53:48],i_rf_in[55:54]} ^ \n                {i_rf_in[48]   ,i_rf_in[55:49]};\nassign w_f1_4 = {i_rf_in[36:32],i_rf_in[39:37]} ^ \n                {i_rf_in[35:32],i_rf_in[39:36]} ^ \n                {i_rf_in[33:32],i_rf_in[39:34]};\nassign w_f0_2 = {i_rf_in[22:16],i_rf_in[23]}    ^ \n                {i_rf_in[21:16],i_rf_in[23:22]} ^ \n                {i_rf_in[16]   ,i_rf_in[23:17]};\nassign w_f1_0 = {i_rf_in[4:0]  ,i_rf_in[7:5]} ^ \n                {i_rf_in[3:0]  ,i_rf_in[7:4]} ^ \n                {i_rf_in[1:0]  ,i_rf_in[7:2]}; \n\nassign w_rf_mv[3] = (i_op == 0) ? i_rf_in[63:56] ^ (w_f0_6 + i_rsk[31:24]):\n                                  i_rf_in[63:56] ^ (w_f0_6 + i_rsk[7:0]); \n\nassign w_rf_mv[2] = (i_op == 0) ? i_rf_in[47:40] + (w_f1_4 ^ i_rsk[23:16]): \n                                  i_rf_in[47:40] - (w_f1_4 ^ i_rsk[15:8]);                        \n\nassign w_rf_mv[1] = (i_op == 0) ? i_rf_in[31:24] ^ (w_f0_2 + i_rsk[15:8]):\n                                  i_rf_in[31:24] ^ (w_f0_2 + i_rsk[23:16]); \n\nassign w_rf_mv[0] = (i_op == 0) ? i_rf_in[15:8] + (w_f1_0 ^ i_rsk[7:0]): \n                                  i_rf_in[15:8] - (w_f1_0 ^ i_rsk[31:24]); \n\nassign w_rf_out7 = (i_rf_final == 1) ? w_rf_mv[3] : \n                                      (i_op == 0) ? i_rf_in[55:48] : \n                                                    i_rf_in[7:0];\nassign w_rf_out6 = (i_rf_final == 1) ? i_rf_in[55:48] : \n                                      (i_op == 0) ? w_rf_mv[2] :\n                                                    w_rf_mv[3];\nassign w_rf_out5 = (i_rf_final == 1) ? w_rf_mv[2] : \n                                      (i_op == 0) ? i_rf_in[39:32] :  \n                                                    i_rf_in[55:48];\nassign w_rf_out4 = (i_rf_final == 1) ? i_rf_in[39:32] :\n                                      (i_op == 0) ? w_rf_mv[1] :\n                                                    w_rf_mv[2];\nassign w_rf_out3 = (i_rf_final == 1) ? w_rf_mv[1] : \n                                      (i_op == 0) ? i_rf_in[23:16] :\n                                                    i_rf_in[39:32];\nassign w_rf_out2 = (i_rf_final == 1) ? i_rf_in[23:16] :\n                                      (i_op == 0) ? w_rf_mv[0] :\n                                                    w_rf_mv[1];\n\nassign w_rf_out1 = (i_rf_final == 1) ? w_rf_mv[0] :             \n                                      (i_op == 0) ? i_rf_in[7:0] : \n                                                    i_rf_in[23:16];\n\nassign w_rf_out0 = (i_rf_final == 1) ? i_rf_in[7:0] :\n                                      (i_op == 0) ? w_rf_mv[3] : \n                                                    w_rf_mv[0];\n                   \nassign w_rf_out = {w_rf_out7, w_rf_out6, w_rf_out5, w_rf_out4, w_rf_out3, w_rf_out2, w_rf_out1, w_rf_out0}; \nassign o_rf_out = w_rf_out;\n\n\nendmodule\n\n\n",
        "module_name": "RF",
        "module_hash": "cda883c15f1ed8b717a813a49796fe7c",
        "dataset_index": 23476
      },
      "sky130_fd_sc_hdll__or4b_5a3574cc": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__or4b (\n    X  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , D_N              );\n    or  or0  (or0_out_X, not0_out, C, B, A);\n    buf buf0 (X        , or0_out_X        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__or4b",
        "module_hash": "5a3574cc4f485ccc8baaedfd952722e8",
        "dataset_index": 5756
      },
      "binary_counter_47ebf57e": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'b0;\n        end else if (en) begin\n            if (count == 4'b1111) begin\n                count <= 4'b0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "47ebf57efdf617520ca8ae0fd7c61964",
        "dataset_index": 8114
      },
      "serial_wb_parport_d01761b1": {
        "rtl_code": "\nmodule serial_wb_parport( \n\t\t  \n\t\t  parport_o, data_o, parport_readstrobe_o,parport_writestrobe_o,\n\t\t  clk_i, rst_i, parport_i, writestrobe_i, readstrobe_i,data_i, address_i\n\t\t  );\n\n\n\n   output [31:0] parport_o;\n   \n   output [7:0]  data_o;\n   input         clk_i;\n   input         rst_i;\n   input [31:0]  parport_i;\n   \n   input         writestrobe_i;\n   input [7:0] \t data_i;\n   input [1:0] \t address_i;\n   input         readstrobe_i;\n\n   output \t parport_writestrobe_o;\n   output \t parport_readstrobe_o;\n\n   reg [31:0] parport_o;\n   reg [7:0] \t data_o;\n   wire \t clk_i;\n   wire \t rst_i;\n   wire \t writestrobe_i;\n   wire [31:0]  parport_i;\n   wire [7:0] \t data_i;\n   wire [1:0] \t address_i;\n   wire \t readstrobe_i;\n\n\n   reg [23:0]\t outputreg_r;\n   reg [23:0]\t inputreg_r;\n\n   reg \t\t parport_readstrobe_o;\n   reg \t\t parport_writestrobe_o;\n   \n\n\n   always @(*) begin\n      data_o = parport_i[7:0];\n      case(address_i)\n\t 2'b01: data_o = inputreg_r[7:0];\n\t 2'b10: data_o = inputreg_r[15:8];\n\t 2'b11: data_o = inputreg_r[23:16];\n      endcase parport_readstrobe_o = 0;\n      if((address_i == 2'b00) && readstrobe_i) begin\n\t parport_readstrobe_o = 1;\n      end\n   end\n\n   always @(posedge clk_i) begin\n      parport_writestrobe_o <= 0;\n      if(rst_i) begin\n\t parport_o <= 0;\n\t outputreg_r <= 0;\n\t parport_writestrobe_o <= 0;\n      end else if(writestrobe_i) begin\n\t parport_writestrobe_o <= 0;\n\t case(address_i)\n\t   2'b00: outputreg_r[7:0] <= data_i;\n\t   2'b01: outputreg_r[15:8] <= data_i;\n\t   2'b10: outputreg_r[23:16] <= data_i;\n\t   2'b11: begin\n\t      parport_o <= {data_i[7:0],outputreg_r[23:0]};\n\t      parport_writestrobe_o <= 1;\n\t   end\n\t   \n\t endcase end else if(readstrobe_i) begin\n\t if(address_i == 2'b00) begin\n\t    inputreg_r <= parport_i[31:8];\n\t end\n      end\n   end\n\nendmodule ",
        "module_name": "serial_wb_parport",
        "module_hash": "d01761b155f979c30eafe0871ef74dd0",
        "dataset_index": 22232
      },
      "gated_d_latch_b3bd1f55": {
        "rtl_code": "module gated_d_latch (\n    input d,\n    input clk,\n    input en,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (en) begin\n            q <= d;\n        end\n    end\n\nendmodule",
        "module_name": "gated_d_latch",
        "module_hash": "b3bd1f559f88de884aa2ac3abdbebacd",
        "dataset_index": 7688
      },
      "sync2r_1_678c23bc": {
        "rtl_code": "module sync2r_1 ( clk, preset, d, q );\n    input clk;\n    input preset;\n    input d;\n    output q;\n\n    reg q1, q2; // two registers\n\n    always @(posedge clk or posedge preset) begin\n        if (preset) begin\n            q1 <= 1'b0; // reset to known state\n            q2 <= 1'b0;\n        end else begin\n            q1 <= d; // first register triggered by rising edge\n            q2 <= q1; // second register triggered by falling edge\n        end\n    end\n\n    assign q = q2; // output synchronized data signal\nendmodule",
        "module_name": "sync2r_1",
        "module_hash": "678c23bcdfd92b061ec04d82bc983497",
        "dataset_index": 16316
      },
      "var18_multi_e6ed0a60": {
        "rtl_code": "\nmodule var18_multi (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, valid);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R;\n    output valid;\n\n    wire [8:0] min_value = 9'd120;\n    wire [8:0] max_weight = 9'd60;\n    wire [8:0] max_volume = 9'd60;\nwire [8:0]  total_value = \n        A * 9'd4\n      + B * 9'd8\n      + C * 9'd0\n      + D * 9'd20\n      + E * 9'd10\n      + F * 9'd12\n      + G * 9'd18\n      + H * 9'd14\n      + I * 9'd6\n      + J * 9'd15\n      + K * 9'd30\n      + L * 9'd8\n      + M * 9'd16\n      + N * 9'd18\n      + O * 9'd18\n      + P * 9'd14\n      + Q * 9'd7\n      + R * 9'd7;\n\n    wire [8:0]  total_weight = \n        A * 9'd28\n      + B * 9'd8\n      + C * 9'd27\n      + D * 9'd18\n      + E * 9'd27\n      + F * 9'd28\n      + G * 9'd6\n      + H * 9'd1\n      + I * 9'd20\n      + J * 9'd0\n      + K * 9'd5\n      + L * 9'd13\n      + M * 9'd8\n      + N * 9'd14\n      + O * 9'd22\n      + P * 9'd12\n      + Q * 9'd23\n      + R * 9'd26;\n\n    wire [8:0]  total_volume = \n        A * 9'd27\n      + B * 9'd27\n      + C * 9'd4\n      + D * 9'd4\n      + E * 9'd0\n      + F * 9'd24\n      + G * 9'd4\n      + H * 9'd20\n      + I * 9'd12\n      + J * 9'd15\n      + K * 9'd5\n      + L * 9'd2\n      + M * 9'd9\n      + N * 9'd28\n      + O * 9'd19\n      + P * 9'd18\n      + Q * 9'd30\n      + R * 9'd12;\n\nassign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume));\nendmodule\n",
        "module_name": "var18_multi",
        "module_hash": "e6ed0a604b1b53e284133cfb90471e12",
        "dataset_index": 9630
      },
      "vga_dac_regs_c5ee8186": {
        "rtl_code": "\n\nmodule vga_dac_regs (\n    input clk,\n\n    input      [7:0] index,\n    output reg [3:0] red,\n    output reg [3:0] green,\n    output reg [3:0] blue,\n\n    input       write,\n\n    input      [1:0] read_data_cycle,\n    input      [7:0] read_data_register,\n    output reg [3:0] read_data,\n\n    input [1:0] write_data_cycle,\n    input [7:0] write_data_register,\n    input [3:0] write_data\n  );\n\n  reg [3:0] red_dac   [0:255];\n  reg [3:0] green_dac [0:255];\n  reg [3:0] blue_dac  [0:255];\n\n  always @(posedge clk)\n    begin\n      red   <= red_dac[index];\n      green <= green_dac[index];\n      blue  <= blue_dac[index];\n    end\n\n  always @(posedge clk)\n    case (read_data_cycle)\n      2'b00:   read_data <= red_dac[read_data_register];\n      2'b01:   read_data <= green_dac[read_data_register];\n      2'b10:   read_data <= blue_dac[read_data_register];\n      default: read_data <= 4'h0;\n    endcase\n\n  always @(posedge clk)\n    if (write)\n      case (write_data_cycle)\n        2'b00:   red_dac[write_data_register]   <= write_data;\n        2'b01:   green_dac[write_data_register] <= write_data;\n        2'b10:   blue_dac[write_data_register]  <= write_data;\n      endcase\n\nendmodule\n",
        "module_name": "vga_dac_regs",
        "module_hash": "c5ee8186169e586af3251c73b152cd58",
        "dataset_index": 25262
      },
      "speed_neg_control_e55be956": {
        "rtl_code": "\n\n\nmodule speed_neg_control (\n\n  input  wire        clk,        input  wire        reset,      input  wire        link_reset,\n  output reg         mgt_reset,  input  wire        linkup,     output reg   [6:0] daddr,      output reg         den,        output reg  [15:0] di,         input  wire [15:0] do,         input  wire        drdy,       output reg         dwe,        input  wire        gtp_lock,   output wire  [4:0] state_out,\n  output reg         gen_value  \n);\n\t\n\n\tparameter\t[4:0] \tIDLE\t\t= 5'h00;\n\tparameter\t[4:0] \tREAD_GEN2  \t= 5'h01;\n\tparameter\t[4:0] \tWRITE_GEN2  \t= 5'h02;\n\tparameter\t[4:0] \tCOMPLETE_GEN2  \t= 5'h03;\n\tparameter\t[4:0] \tPAUSE1_GEN2  \t= 5'h04;\n\tparameter\t[4:0] \tREAD1_GEN2  \t= 5'h05;\n\tparameter\t[4:0] \tWRITE1_GEN2  \t= 5'h06;\n\tparameter\t[4:0] \tCOMPLETE1_GEN2  = 5'h07;\n\tparameter\t[4:0] \tRESET \t \t= 5'h08;\n\tparameter\t[4:0] \tWAIT_GEN2   \t= 5'h09;\n\tparameter\t[4:0] \tREAD_GEN1  \t= 5'h0A;\n\tparameter\t[4:0] \tWRITE_GEN1  \t= 5'h0B;\n\tparameter\t[4:0] \tCOMPLETE_GEN1  \t= 5'h0C;\n\tparameter\t[4:0] \tPAUSE_GEN1 \t= 5'h0D;\n\tparameter\t[4:0] \tREAD1_GEN1  \t= 5'h0E;\n\tparameter\t[4:0] \tWRITE1_GEN1  \t= 5'h0F;\n\tparameter\t[4:0] \tCOMPLETE1_GEN1  = 5'h10;\n\tparameter\t[4:0] \tRESET_GEN1  \t= 5'h11;\n\tparameter\t[4:0] \tWAIT_GEN1   \t= 5'h12;\n\tparameter\t[4:0] \tLINKUP \t\t= 5'h13;\n\n\n\treg  [4:0] state;\n\treg [31:0] linkup_cnt;\n\treg [15:0] drp_reg;\n\treg [15:0] reset_cnt;\n\treg  [3:0] pause_cnt;\n\nassign state_out = state;\n\nalways @ (posedge clk or posedge reset)\nbegin\n  if(reset)\n  begin\n    state <= IDLE;\n    daddr <= 7'b0;\n    di    <= 8'b0;\n    den   <= 1'b0;\n    dwe   <= 1'b0;\n    drp_reg <= 16'b0;\n    linkup_cnt <= 32'h0;\n    gen_value <= 1'b1;\n    reset_cnt <= 16'b0000000000000000;\n    mgt_reset <= 1'b0;\n    pause_cnt <= 4'b0000;\n\n  end\n  else\n  begin\n  \tcase(state)\n      \tIDLE:  begin\n              \tif(gtp_lock)\n\t\t\tbegin\n\t\t\tdaddr <= 7'h46;\n                \tden   <= 1'b1;\n                \tgen_value    <= 1'b1; state      <= READ_GEN2;        \n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t    state <= IDLE;\n\t\t\tend\n             end\n      READ_GEN2: begin\n               if(drdy)\n               begin\n                 drp_reg <= do;\n                 den   <= 1'b0;\n                 state <= WRITE_GEN2;\n               end\n               else\n               begin\n                 state <= READ_GEN2;\n               end\n             end\n      WRITE_GEN2: begin\n               di  <= drp_reg ;  di[2] <= 1'b0;\n               den <= 1'b1;\n               dwe <= 1'b1;\n               state <= COMPLETE_GEN2;\n             end\n      COMPLETE_GEN2: begin\n               if(drdy)\n               begin\n                 dwe   <= 1'b0;\n                 den   <= 1'b0;\n                 state <= PAUSE1_GEN2;\n               end\n               else\n               begin\n                 state <= COMPLETE_GEN2;\n               end\n             end\n      PAUSE1_GEN2: begin\n               if(pause_cnt == 4'b1111)\n               begin\n                 dwe   <= 1'b0;\n                 den   <= 1'b1;\n                 daddr <= 7'h45;\n                 pause_cnt <= 4'b0000;\n                 state <= READ1_GEN2;\n               end\n               else\n               begin\n                 pause_cnt <= pause_cnt + 1'b1;\n                 state <= PAUSE1_GEN2;\n               end\n             end           \n      READ1_GEN2: begin\n               if(drdy)\n               begin\n                 drp_reg <= do;\n                 den   <= 1'b0;\n                 state <= WRITE1_GEN2;\n               end\n               else\n               begin\n                 state <= READ1_GEN2;\n               end\n             end\n      WRITE1_GEN2: begin\n               di  <= drp_reg;  \n               di[15] <= 1'b0;\n               den <= 1'b1;\n               dwe <= 1'b1;\n               state <= COMPLETE1_GEN2;\n             end\n      COMPLETE1_GEN2: begin\n               if(drdy)\n               begin\n                 dwe   <= 1'b0;\n                 den   <= 1'b0;\n                 state <= RESET;\n               \n               end\n               else\n               begin\n                 state <= COMPLETE1_GEN2;\n               end\n             end\n     \n      RESET: begin\n               if(reset_cnt == 16'b00001111)\n               begin\n                 reset_cnt <= reset_cnt + 1'b1;\n                 state <= RESET;\n                 mgt_reset <= 1'b1;\n               end\n               else if(reset_cnt == 16'b0000000000011111)\n               begin\n                 reset_cnt <= 16'b00000000;\n                 mgt_reset <= 1'b0;\n                 state <= WAIT_GEN2;\n               end\n               else\n               begin\n                 reset_cnt <= reset_cnt + 1'b1;\n                 state <= RESET;\n               end\n             end\n      WAIT_GEN2:  begin if(linkup)\n               begin\n                 linkup_cnt <= 32'h0;\n                 state <= LINKUP;\n               end\n               else\n               begin\n\t\tif(gtp_lock)\n\t\tbegin\n\t\t`ifdef SIM \n\t\t   if(linkup_cnt == 32'h000007FF) `else\t\t\t\t\t  \n                   if(linkup_cnt == 32'h00080EB4) `endif \n                   begin\n                     linkup_cnt <= 32'h0;\n                     daddr <= 7'h46;\n                     den   <= 1'b1;\n                     gen_value <= 1'b0; state      <= READ_GEN1;\n\t\t\t  end\n                   else\n                   begin\n                     linkup_cnt <= linkup_cnt + 1'b1;\n                     state <= WAIT_GEN2;\n                   end\n\t\t\t\t\t  end\n\t\t\t\t\t  else\n\t\t\t\t\t  begin\n\t\t\t\t\t    state <= WAIT_GEN2;\n\t\t\t\t\t  end\n               end\n\n             end\n      READ_GEN1: begin\n               if(drdy)\n               begin\n                 drp_reg <= do;\n                 den   <= 1'b0;\n                 state <= WRITE_GEN1;\n               end\n               else\n               begin\n                 state <= READ_GEN1;\n               end\n             end\n      WRITE_GEN1: begin\n               di  <= drp_reg;  di[2] <=  1'b1;\n               den <= 1'b1;\n               dwe <= 1'b1;\n               state <= COMPLETE_GEN1;\n             end\n      COMPLETE_GEN1: begin\n               if(drdy)\n               begin\n                 dwe   <= 1'b0;\n                 den   <= 1'b0;\n                 state <= PAUSE_GEN1;\n               end\n               else\n               begin\n                 state <= COMPLETE_GEN1;\n               end\n             end\n     PAUSE_GEN1: begin\n               if(pause_cnt == 4'b1111)\n               begin\n                 dwe   <= 1'b0;\n                 den   <= 1'b1;\n                 daddr <= 7'h45;\n                 pause_cnt <= 4'b0000;\n                 state <= READ1_GEN1;\n               end\n               else\n               begin\n                 pause_cnt <= pause_cnt + 1'b1;\n                 state <= PAUSE_GEN1;\n               end\n             end \n      READ1_GEN1: begin\n               if(drdy)\n               begin\n                 drp_reg <= do;\n                 den   <= 1'b0;\n                 state <= WRITE1_GEN1;\n               end\n               else\n               begin\n                 state <= READ1_GEN1;\n               end\n             end\n      WRITE1_GEN1: begin\n               di  <= drp_reg;  di[15] <= 1'b1;\n               den <= 1'b1;\n               dwe <= 1'b1;\n               state <= COMPLETE1_GEN1;\n             end\n      COMPLETE1_GEN1: begin\n               if(drdy)\n               begin\n                 dwe   <= 1'b0;\n                 den   <= 1'b0;\n                 state <= RESET_GEN1;\n               \n               end\n               else\n               begin\n                 state <= COMPLETE1_GEN1;\n               end\n             end\n     \n      RESET_GEN1: begin\n               if(reset_cnt == 16'b00001111)\n               begin\n                 reset_cnt <= reset_cnt + 1'b1;\n                 state <= RESET_GEN1;\n                 mgt_reset <= 1'b1;\n               end\n               else if(reset_cnt == 16'h001F)\n               begin\n                 reset_cnt <= 16'b00000000;\n                 mgt_reset <= 1'b0;\n                 state <= WAIT_GEN1;\n               end\n               else\n               begin\n                 reset_cnt <= reset_cnt + 1'b1;\n                 state <= RESET_GEN1;\n               end\n             end\n      WAIT_GEN1:  begin\n               if(linkup)\n               begin\n                 linkup_cnt <= 32'h0;\n                 state <= LINKUP;\n               end\n               else\n               begin\n\t\tif(gtp_lock)\n\t\tbegin\n\t\t`ifdef SIM \n\t\t   if(linkup_cnt == 32'h000007FF) `else\t\t\t\t\t  \n                   if(linkup_cnt == 32'h00080EB4) `endif \n                   begin\n                     linkup_cnt <= 32'h0;\n                     daddr <= 7'h46;\n                     den   <= 1'b1;\n                     state <= READ_GEN2; end\n                   else\n                   begin\n                     linkup_cnt <= linkup_cnt + 1'b1;\n                     state <= WAIT_GEN1;\n                   end\n\t\t end\n\t\t else\n\t\t  begin\n\t\t    state <= WAIT_GEN1;\n\t\t  end\n               end\n\n             end                         \n     LINKUP: begin\n     \t\tif (linkup)\n               \t\tstate <= LINKUP;\n               \telse\n                   begin\n                     linkup_cnt <= 32'h0;\n                     daddr <= 7'h46;\n                     den   <= 1'b1;\n                     state <= READ_GEN2; end               \t\t\n             end \n\n     default: begin\n                state <= IDLE;\n                daddr <= 7'b0;\n                di    <= 8'b0;\n                den   <= 1'b0;\n                dwe   <= 1'b0;\n                drp_reg <= 16'b0;\n                linkup_cnt <= 32'h0;\n                gen_value <= 1'b1;\n                reset_cnt <= 8'b00000000;\n                mgt_reset <= 1'b0;\n                pause_cnt <= 4'b0000;\n              end \n    endcase\n  end\n\nend\n\nendmodule\n",
        "module_name": "speed_neg_control",
        "module_hash": "e55be95609d472f04692c59133b5fb6b",
        "dataset_index": 22470
      },
      "d_ff_set_6890c159": {
        "rtl_code": "module d_ff_set(\n    input clk,\n    input [3:0] d,\n    input set_b,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (set_b) begin\n        q <= d;\n    end else begin\n        q <= q;\n    end\nend\n\nendmodule",
        "module_name": "d_ff_set",
        "module_hash": "6890c159c39083ed65c5fb1b4d1330ac",
        "dataset_index": 9290
      },
      "my_module_4327577b": {
        "rtl_code": "\nmodule my_module(\n   input                sgmii_refclk_p,\n   input                sgmii_refclk_n,\n   input [3:0]          sgmii_rxn,\n   input [3:0]          sgmii_rxp,\n   input                pl_btn,\n   output [3:0]         sgmii_txn,\n   output [3:0]         sgmii_txp,\n   output               mdio_mdc,\n   output [1:0]         pl_led,\n   output [1:0]         pl_pmod\n);\n\n\n   reg [23:0] cnt_0;\n   reg [23:0] cnt_1;\n   reg [23:0] cnt_2;\n   reg [23:0] cnt_3;\n\n   always @(posedge sgmii_refclk_p) begin\n     cnt_0 <= cnt_0 + 1'b1;\n   end\n   always @(posedge sgmii_refclk_p) begin\n     cnt_1 <= cnt_1 + 1'b1;\n   end\n   always @(posedge sgmii_refclk_p) begin\n     cnt_2 <= cnt_2 + 1'b1;\n   end\n   always @(posedge sgmii_refclk_p) begin\n     cnt_3 <= cnt_3 + 1'b1;\n   end\n\n\n   assign pl_led[0]  = cnt_0[23];\n   assign pl_led[1]  = cnt_1[23];\n   assign pl_pmod[0] = cnt_3[23];\n   assign pl_pmod[1] = pl_btn;\n\n   assign sgmii_txn = sgmii_rxn ^ 4'b1111;\n   assign sgmii_txp = sgmii_rxp ^ 4'b1111;\n\n   assign mdio_mdc = pl_btn;\n\nendmodule",
        "module_name": "my_module",
        "module_hash": "4327577b98ddc5948ca664e2cdb7c284",
        "dataset_index": 21072
      },
      "pcieCore_qpll_reset #_cb55b972": {
        "rtl_code": "\n\n\n\nmodule pcieCore_qpll_reset #\n(\n\n    parameter PCIE_PLL_SEL       = \"CPLL\",                  parameter PCIE_POWER_SAVING  = \"TRUE\",                  parameter PCIE_LANE          = 1,                       parameter BYPASS_COARSE_OVRD = 1                        )\n\n(\n\n    input                           QRST_CLK,\n    input                           QRST_RST_N,\n    input                           QRST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     QRST_CPLLLOCK,\n    input       [(PCIE_LANE-1)>>2:0]QRST_DRP_DONE,\n    input       [(PCIE_LANE-1)>>2:0]QRST_QPLLLOCK,\n    input       [ 1:0]              QRST_RATE,\n    input       [PCIE_LANE-1:0]     QRST_QPLLRESET_IN,\n    input       [PCIE_LANE-1:0]     QRST_QPLLPD_IN,\n    \n    output                          QRST_OVRD,\n    output                          QRST_DRP_START,\n    output                          QRST_QPLLRESET_OUT,\n    output                          QRST_QPLLPD_OUT,\n    output                          QRST_IDLE,\n    output      [ 3:0]              QRST_FSM\n\n);\n\n        reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     cplllock_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg1;\n    reg         [ 1:0]              rate_reg1;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg1;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg1;\n\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     cplllock_reg2;  \n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg2;\n    reg         [ 1:0]              rate_reg2;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg2;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg2;\n    \n    reg                             ovrd              =  1'd0;\n    reg                             qpllreset         =  1'd1;\n    reg                             qpllpd            =  1'd0;\n    reg         [ 3:0]              fsm               =  2;                 \n   \n    localparam                      FSM_IDLE          = 1; \n    localparam                      FSM_WAIT_LOCK     = 2;\n    localparam                      FSM_MMCM_LOCK     = 3;   \n    localparam                      FSM_DRP_START_NOM = 4;\n    localparam                      FSM_DRP_DONE_NOM  = 5;\n    localparam                      FSM_QPLLLOCK      = 6;\n    localparam                      FSM_DRP_START_OPT = 7;                            \n    localparam                      FSM_DRP_DONE_OPT  = 8;\n    localparam                      FSM_QPLL_RESET    = 9;                                                         \n    localparam                      FSM_QPLLLOCK2     = 10;\n    localparam                      FSM_QPLL_PDRESET  = 11;\n    localparam                      FSM_QPLL_PD       = 12;                                         \n \n \n    \nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin    \n        mmcm_lock_reg1    <=  1'd0;\n        cplllock_reg1     <= {PCIE_LANE{1'd1}}; \n        drp_done_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};     \n        qplllock_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg1         <=  2'd0; \n        qpllreset_in_reg1 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg1    <= {PCIE_LANE{1'd0}}; \n        mmcm_lock_reg2    <=  1'd0;\n        cplllock_reg2     <= {PCIE_LANE{1'd1}};\n        drp_done_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        qplllock_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg2         <=  2'd0;\n        qpllreset_in_reg2 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg2    <= {PCIE_LANE{1'd0}};  \n        end\n    else\n        begin  \n        mmcm_lock_reg1    <= QRST_MMCM_LOCK;   \n        cplllock_reg1     <= QRST_CPLLLOCK; \n        drp_done_reg1     <= QRST_DRP_DONE; \n        qplllock_reg1     <= QRST_QPLLLOCK;\n        rate_reg1         <= QRST_RATE; \n        qpllreset_in_reg1 <= QRST_QPLLRESET_IN;\n        qpllpd_in_reg1    <= QRST_QPLLPD_IN;\n        mmcm_lock_reg2    <= mmcm_lock_reg1;\n        cplllock_reg2     <= cplllock_reg1;\n        drp_done_reg2     <= drp_done_reg1; \n        qplllock_reg2     <= qplllock_reg1;\n        rate_reg2         <= rate_reg1;\n        qpllreset_in_reg2 <= qpllreset_in_reg1;\n        qpllpd_in_reg2    <= qpllpd_in_reg1;\n        end\n        \nend    \n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        fsm       <= FSM_WAIT_LOCK;\n        ovrd      <= 1'd0;\n        qpllreset <= 1'd1;\n        qpllpd    <= 1'd0;\n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (!QRST_RST_N)\n                begin\n                fsm       <= FSM_WAIT_LOCK;\n                ovrd      <= 1'd0;\n                qpllreset <= 1'd1;\n                qpllpd    <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                ovrd      <= ovrd;\n                qpllreset <= &qpllreset_in_reg2;\n                qpllpd    <= &qpllpd_in_reg2;\n                end\n            end  \n            \n        FSM_WAIT_LOCK :\n        \n            begin\n            fsm       <= ((&(~cplllock_reg2)) && (&(~qplllock_reg2)) ? FSM_MMCM_LOCK : FSM_WAIT_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_MMCM_LOCK :\n        \n            begin\n            fsm       <= ((mmcm_lock_reg2 && (&cplllock_reg2)) ? FSM_DRP_START_NOM : FSM_MMCM_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_DRP_START_NOM:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_NOM : FSM_DRP_START_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_NOM :\n        \n            begin\n            fsm       <= (&drp_done_reg2 ? FSM_QPLLLOCK : FSM_DRP_DONE_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end \n            \n        FSM_QPLLLOCK :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? ((BYPASS_COARSE_OVRD == 1) ? FSM_QPLL_PDRESET : FSM_DRP_START_OPT) : FSM_QPLLLOCK);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_DRP_START_OPT:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_OPT : FSM_DRP_START_OPT);\n            ovrd      <= 1'd1;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_OPT :\n        \n            begin\n            if (&drp_done_reg2)\n                begin\n                fsm       <= ((PCIE_PLL_SEL == \"QPLL\") ? FSM_QPLL_RESET : FSM_QPLL_PDRESET);\n                ovrd      <= ovrd;\n                qpllreset <= (PCIE_PLL_SEL == \"QPLL\");\n                qpllpd    <= qpllpd;\n                end\n            else\n                begin\n                fsm       <= FSM_DRP_DONE_OPT;\n                ovrd      <= ovrd;\n                qpllreset <= qpllreset;\n                qpllpd    <= qpllpd;\n                end\n            end \n            \n        FSM_QPLL_RESET :\n            \n            begin\n            fsm       <= (&(~qplllock_reg2) ? FSM_QPLLLOCK2 : FSM_QPLL_RESET);  \n            ovrd      <= ovrd;\n            qpllreset <= 1'd1;\n            qpllpd    <= 1'd0;\n            end     \n            \n        FSM_QPLLLOCK2 :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK2);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n            \n        FSM_QPLL_PDRESET :\n        \n            begin\n            fsm       <= FSM_QPLL_PD;\n            ovrd      <= ovrd;\n            qpllreset <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_QPLL_PD :\n        \n            begin\n            fsm       <= FSM_IDLE;\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            end \n                \n        default :\n        \n            begin\n            fsm       <= FSM_WAIT_LOCK;\n            ovrd      <= 1'd0;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        endcase\n        \n        end\n        \nend\n\n\n\nassign QRST_OVRD          = ovrd;\nassign QRST_DRP_START     = (fsm == FSM_DRP_START_NOM) || (fsm == FSM_DRP_START_OPT); \nassign QRST_QPLLRESET_OUT = qpllreset;\nassign QRST_QPLLPD_OUT    = ((PCIE_POWER_SAVING == \"FALSE\") ? 1'd0 : qpllpd);  \nassign QRST_IDLE          = (fsm == FSM_IDLE);\nassign QRST_FSM           = fsm;                   \n\n\n\nendmodule\n",
        "module_name": "pcieCore_qpll_reset #",
        "module_hash": "cb55b972f5f1d25d07fa398915dca04f",
        "dataset_index": 10627
      },
      "d_latch_520f43d2": {
        "rtl_code": "module d_latch (\n    input D,\n    input S,\n    input R,\n    input CLK,\n    output Q\n);\n\nreg Q;\n\nalways @(posedge CLK) begin\n    if (R) begin\n        Q <= 0;\n    end else if (S) begin\n        Q <= 1;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule",
        "module_name": "d_latch",
        "module_hash": "520f43d22da264689e83a945ca097a31",
        "dataset_index": 8949
      },
      "comparator #_844cae53": {
        "rtl_code": "\n\nmodule comparator #\n(\nparameter WIDTH = 8,\nparameter ERROR_COUNT = 8,\nparameter ERROR_HOLD = 2500000\n)\n(\ninput  wire CLK,\ninput  wire RST,\n\ninput  wire             TX_STB,\ninput  wire [WIDTH-1:0] TX_DAT,\n\ninput  wire             RX_STB,\ninput  wire [WIDTH-1:0] RX_DAT,\noutput wire             RX_BITSLIP,\n\noutput wire             O_ERROR\n);\n\nreg [WIDTH-1:0] tx_dat;\nreg             tx_valid;\n\nreg [WIDTH-1:0] rx_dat;\nreg             rx_valid;\n\nwire i_rdy = rx_valid && rx_valid;\n\nalways @(posedge CLK)\n    if (!tx_valid && TX_STB)\n        tx_dat <= TX_DAT;\n\nalways @(posedge CLK)\n    if (RST)\n        tx_valid <= 1'b0;\n    else if (i_rdy)\n        tx_valid <= 1'b0;\n    else if (TX_STB)\n        tx_valid <= 1'b1;\n\nalways @(posedge CLK)\n    if (!rx_valid && RX_STB)\n        rx_dat <= RX_DAT;\n\nalways @(posedge CLK)\n    if (RST)\n        rx_valid <= 1'b0;\n    else if (i_rdy)\n        rx_valid <= 1'b0;\n    else if (RX_STB)\n        rx_valid <= 1'b1;\n\n\nreg x_stb;\nreg x_error;\n\nalways @(posedge CLK)\n    if (RST)\n        x_stb <= 1'b0;\n    else if(!x_stb && i_rdy)\n        x_stb <= 1'b1;\n    else if( x_stb)\n        x_stb <= 1'b0;\n\nalways @(posedge CLK)\n    if (i_rdy)\n        x_error <= (rx_dat != tx_dat);\n\nreg [31:0] count_err;\nreg        o_bitslip;\n\nalways @(posedge CLK)\n    if (RST)\n        count_err <= 0;\n    else if (x_stb && x_error)\n        count_err <= count_err + 1;\n    else if (o_bitslip)\n        count_err <= 0;\n\nalways @(posedge CLK)\n    if (RST)\n        o_bitslip <= 1'b0;\n    else if (!o_bitslip && (count_err >= ERROR_COUNT))\n        o_bitslip <= 1'b1;\n    else if ( o_bitslip)\n        o_bitslip <= 1'b0;\n\nassign RX_BITSLIP = o_bitslip;\n\nreg [32:0]  o_cnt;\n\nalways @(posedge CLK)\n    if (RST)\n        o_cnt <= 0;\n    else if (x_stb && x_error)\n        o_cnt <= ERROR_HOLD;\n    else\n        o_cnt <= (o_cnt[32]) ? o_cnt : (o_cnt - 1);\n\nassign O_ERROR = !o_cnt[32];\n\nendmodule\n",
        "module_name": "comparator #",
        "module_hash": "844cae53ffe6de7e1bb3e832607eca11",
        "dataset_index": 8421
      },
      "divider_2e1671d4": {
        "rtl_code": "module divider(\n    input wire clk,\n    input wire rst,\n    input wire signed_div_i,\n    input wire [31:0] opdata1_i,\n    input wire [31:0] opdata2_i,\n    input wire start_i,\n    input wire annul_i,\n    output reg [63:0] result_o,\n    output reg ready_o\n);\n\n    reg [63:0] quotient;\n    reg [31:0] dividend;\n    reg [31:0] divisor;\n    reg [5:0] counter;\n    reg [1:0] state;\n    \n    always @(posedge clk) begin\n        if (rst == 1) begin\n            state <= 0;\n            ready_o <= 0;\n            result_o <= 0;\n        end else begin\n            case (state)\n                0: begin // Idle state\n                    if (start_i) begin\n                        if (opdata2_i == 0) begin\n                            state <= 3; // Division by zero\n                        end else begin\n                            state <= 1; // Start division\n                            counter <= 0;\n                            dividend <= opdata1_i;\n                            divisor <= opdata2_i;\n                            quotient <= 0;\n                        end\n                    end\n                end\n                1: begin // Division state\n                    if (annul_i) begin\n                        state <= 0; // Stop division\n                    end else if (counter == 32) begin\n                        state <= 2; // End division\n                    end else begin\n                        if (dividend[31]) begin\n                            dividend <= {dividend[30:0], 1'b0};\n                            quotient <= {quotient[62:0], 1'b1};\n                        end else begin\n                            dividend <= {dividend[30:0], 1'b0};\n                            quotient <= quotient << 1;\n                        end\n                        counter <= counter + 1;\n                    end\n                end\n                2: begin // End division state\n                    if (signed_div_i && opdata1_i[31] != opdata2_i[31]) begin\n                        quotient <= ~quotient + 1; // Fix sign of quotient\n                    end\n                    result_o <= quotient;\n                    ready_o <= 1;\n                    state <= 0; // Return to idle state\n                end\n                3: begin // Division by zero state\n                    result_o <= 0;\n                    ready_o <= 1;\n                    state <= 0; // Return to idle state\n                end\n            endcase\n        end\n    end\nendmodule",
        "module_name": "divider",
        "module_hash": "2e1671d45ca18447559ce680521c9fdd",
        "dataset_index": 15791
      },
      "mux4to1_58b1b121": {
        "rtl_code": "module mux4to1 (\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    S0  ,\n    S1  ,\n    Y   \n);\n\n    // Module ports\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n    input  S0 ;\n    input  S1 ;\n    output Y  ;\n\n    // Local signals\n    wire not_S0_out  ;\n    wire not_S1_out  ;\n    wire and1_out    ;\n    wire and2_out    ;\n    wire and3_out    ;\n    wire and4_out    ;\n    wire or1_out     ;\n\n    //                                 Name        Output             Other arguments\n    not                                not_S0     (not_S0_out        , S0                    );\n    not                                not_S1     (not_S1_out        , S1                    );\n    and                                and1       (and1_out          , A, not_S0_out, not_S1_out);\n    and                                and2       (and2_out          , B, not_S0_out, S1       );\n    and                                and3       (and3_out          , C, S0, not_S1_out       );\n    and                                and4       (and4_out          , D, S0, S1              );\n    or                                 or1        (Y                 , and1_out, and2_out, and3_out, and4_out);\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "58b1b121649ddc59dd368a3e848ece90",
        "dataset_index": 20756
      },
      "top_module_6615efb2": {
        "rtl_code": "\nmodule top_module(\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    output wire [15:0] final_out\n);\n\nreg [3:0] counter;\nreg [15:0] input_num;\n\nsplitter splitter_inst(\n    .input_num(input_num),\n    .out_hi(out_hi),\n    .out_lo(out_lo)\n);\n\ncombiner combiner_inst(\n    .out_hi(out_hi),\n    .out_lo(out_lo),\n    .final_out(final_out)\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 4'd0;\n        input_num <= 16'd0;\n    end else begin\n        counter <= counter + 1;\n        input_num <= input_num + 1;\n    end\nend\n\nendmodule\n\nmodule splitter(\n    input [15:0] input_num,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n\nassign out_hi = input_num[15:8];\nassign out_lo = input_num[7:0];\n\nendmodule\n\nmodule combiner(\n    input [7:0] out_hi,\n    input [7:0] out_lo,\n    output wire [15:0] final_out\n);\n\nassign final_out = {out_hi, out_lo};\n\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "6615efb2b8230e4c38f21bb065d8a45e",
        "dataset_index": 13735
      },
      "nor_gate_3dacdc0a": {
        "rtl_code": "\nmodule nor_gate (\n    input a,\n    input b,\n    output out\n);\n    assign out = !(a & b);\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    wire g, p;\n    assign sum = a ^ b ^ cin;\n    assign g = a & b;\n    assign p = a & cin;\n    assign cout = g | p;\nendmodule\n\nmodule bitwise_and (\n    input [1:0] a,\n    input [1:0] b,\n    output [1:0] out\n);\n    assign out = {1'b0, a[0] & b[0]}; // Fix the bit widths\nendmodule\n\nmodule top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum,\n    output [1:0] final_output\n);\n    wire nor_out;\n    nor_gate n1 (.a(a), .b(b), .out(nor_out));\n    full_adder fa1 (.a(a), .b(b), .cin(cin), .cout(cout), .sum(sum));\n    bitwise_and ba1 (.a({1'b0, nor_out}), .b({1'b0, sum}), .out(final_output)); // Fix the bit widths\nendmodule\n",
        "module_name": "nor_gate",
        "module_hash": "3dacdc0a5d374acfc179e777c78756ea",
        "dataset_index": 3231
      },
      "WhacAMole_7f602b96": {
        "rtl_code": "\nmodule WhacAMole(BCD1, BCD0, mole_position, random, mallet_position, timesup, PRESS_VALID, reset, clk_1us);\n\n\tinput PRESS_VALID, reset, clk_1us;\n\tinput [3:0] random;\n\tinput [3:0] mallet_position;\n\tinput timesup;\n\n\toutput [3:0] BCD1, BCD0;\n\toutput [4:0] mole_position;\n\t\n\treg [4:0] mole_position;\n\twire [4:0] next_mole;\n\treg [3:0] BCD0, BCD1;\n\twire [3:0] next_BCD0, next_BCD1;\n\treg[19:0] counter500000, next_counter500000;\treg [1:0] state, next_state;\n\treg generatenewmole, next_generatenewmole;\n\twire hit;\n\tparameter status0 = 2'h0;\n\tparameter status1 = 2'h1;\n\tparameter status2 = 2'h2;\n\t\n\t\n\talways @(posedge clk_1us or negedge reset)begin\n\t\tif(!reset)begin\n\t\t\tmole_position <= 5'd0;\n\t\t\tstate <= 2'd0;\n\t\t\tBCD0 <= 4'd0;\n\t\t\tBCD1 <= 4'd0;\n\t\t\tcounter500000 <= 20'd0;\n\t\t\tgeneratenewmole <= 0;\n\t\tend else begin\n\t\t\tmole_position <= next_mole;\n\t\t\tstate <= next_state;\n\t\t\tBCD0 <= next_BCD0;\n\t\t\tBCD1 <= next_BCD1;\n\t\t\tcounter500000 <= next_counter500000;\n\t\t\tgeneratenewmole <= next_generatenewmole;\n\t\tend\n\tend\n\t \n\t \n\t\n\talways @(*)\tbegin\n\t\tcase (state)\n\t\t\n\t\t\tstatus0: begin\n\t\t\t\tif(hit) begin\n\t\t\t\t\tnext_state = status2;\n\t\t\t\t\tnext_counter500000 = 20'd0;\n\t\t\t\tend else if(counter500000==20'd500000) begin\n\t\t\t\t\tnext_state = status1;\n\t\t\t\t\tnext_counter500000 = 20'd0;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = state;\n\t\t\t\t\tnext_counter500000 = counter500000 + 20'd1;\n\t\t\t\tend\n\t\t\t\tnext_generatenewmole = 0;\n\t\t\tend\n\t\t\t\n\t\t\tstatus1: begin\n\t\t\t\tif(hit) begin\n\t\t\t\t\tnext_state = status2;\n\t\t\t\t\tnext_counter500000 = 20'd0;\n\t\t\t\tend else if(counter500000==20'd500000) begin\n\t\t\t\t\tnext_state = status2;\n\t\t\t\t\tnext_counter500000 = 20'd0;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = state;\n\t\t\t\t\tnext_counter500000 = counter500000 + 20'd1;\n\t\t\t\tend\n\t\t\t\tnext_generatenewmole = 0;\n\t\t\tend\n\t\t\t\n\t\t\tstatus2: begin\n\t\t\t\tif(counter500000==20'd500000) begin\n\t\t\t\t\tnext_state = status0;\n\t\t\t\t\tnext_counter500000 = 20'd0;\n\t\t\t\t\tnext_generatenewmole = 1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = state;\n\t\t\t\t\tnext_counter500000 = counter500000 + 20'd1;\n\t\t\t\t\tnext_generatenewmole = 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\tnext_state = 2'd0;\n\t\t\t\tnext_counter500000 = 20'd0;\n\t\t\t\tnext_generatenewmole = 1;\n\t\t\tend\n\t\t\t\n\t\tendcase\n\tend\n\t\n\tassign next_BCD0 = (hit==4'd1) ? ( (BCD0==4'd9) ? 4'd0 : (BCD0+4'd1) ) : BCD0;\n\tassign next_BCD1 = (hit==4'd1) ? ( (BCD0==4'd9) ? (BCD1+4'd1) : BCD1 ) : BCD1;\n\tassign hit = ((mallet_position == mole_position[3:0])&&(!timesup)&&(PRESS_VALID)) ? 1'd1 : 1'd0;\n\t\n\tassign next_mole = (hit) ? 5'b10000 : ((state==status2) ? 5'b10000 : ((generatenewmole && !timesup) ? random : mole_position));\t\n\t \n\t\n\t\nendmodule\n",
        "module_name": "WhacAMole",
        "module_hash": "7f602b963ff2085c8c503c613a9e819f",
        "dataset_index": 22049
      },
      "initiator_c2c56dda": {
        "rtl_code": "module initiator\n  (input  wire        clk,\n   input  wire        rst,\n   output reg  req,\n   output reg valid,\n   input  wire        res);\n\n   reg [31:0] counter;\n   reg [31:0] dataExpect;\n   reg        dataValid;\n\n   always @(posedge clk)\n     if (rst) begin\n        counter <= 0;\n        req     <= 0;\n        dataValid <= 0;\n        dataExpect <= 0;\n     end else begin\n        dataValid <= req & ~res;\n        if (dataValid) begin\n           if (dataExpect != res) begin\n               valid <= 1'b0;\n           end\n           else begin\n               valid <= 1'b0;\n           end\n        end\n\n        if (~res) begin\n           req   <= 1;\n           req   <= counter;\n           dataExpect <= req;\n           counter <= counter + 1;\n        end\n     end\nendmodule",
        "module_name": "initiator",
        "module_hash": "c2c56ddaa04ca8d33b8ec2d455c3a286",
        "dataset_index": 10057
      },
      "FSM_Mult_Function_84b140fe": {
        "rtl_code": "\nmodule FSM_Mult_Function(\n\tinput wire clk,\n\tinput wire rst,\n\tinput wire beg_FSM, input wire ack_FSM, input wire zero_flag_i,\n\t\n\tinput wire Mult_shift_i,\n\t\n\tinput wire round_flag_i,\n\t\n\tinput wire Add_Overflow_i,\n\n\toutput reg load_0_o, \n\n\t\n\toutput reg load_1_o, \n\n\toutput reg load_2_o, \n\t\n\toutput reg load_3_o, \n\t\n\toutput reg load_4_o,\n\t\n\toutput reg load_5_o,\n\n\toutput reg load_6_o,\n\t\n\n\toutput reg ctrl_select_a_o,\n\toutput reg ctrl_select_b_o,\n\toutput reg [1:0] selector_b_o,\n\toutput reg ctrl_select_c_o,\n\t\n\n\toutput reg exp_op_o,\n\n\toutput reg shift_value_o,\n\n\toutput reg rst_int,\n\t\toutput reg ready\n    );\n\n\nparameter [3:0] start = 4'd0,load_operands = 4'd1, extra64_1 = 4'd2,\n\nadd_exp = 4'd3, subt_bias = 4'd4, mult_overf= 4'd5, mult_norn = 4'd6, mult_no_norn = 4'd7, round_case = 4'd8, adder_round =  4'd9, round_norm = 4'd10, final_load = 4'd11, ready_flag = 4'd12; reg [3:0] state_reg, state_next;\n\nalways @(posedge clk, posedge rst)\n\tif(rst)\n\t\tstate_reg <= start;\n\telse\n\t\tstate_reg <= state_next;\n\nalways @*\n\tbegin\n\tstate_next = state_reg; load_0_o=0;\n\n\t\n\t load_1_o=0;\n\n\tload_2_o=0; \n\t\n\tload_3_o=0; \n\t\n\tload_4_o=0;\n\t\n\tload_5_o=0;\n\n\t load_6_o=0;\n\t \n\tctrl_select_a_o=0;\n\t ctrl_select_b_o=0;\n\t selector_b_o=2'b0;\n\t ctrl_select_c_o=0;\n\t\n\n\texp_op_o=0;\n\n\tshift_value_o=0;\n\n\trst_int=0;\n\t\tready=0;\n\t\n\tcase(state_reg)\n\t\tstart:\n\t\tbegin\n\t\t\trst_int = 1;\n\t\t\tif(beg_FSM)\n\t\t\t\tstate_next = load_operands; end\n\t\tload_operands:\n\t\tbegin\n\t\t\tload_0_o = 1;\n\t\t\tstate_next = extra64_1;\n\t\tend\n\t\t\n\t\textra64_1:\n\t\tbegin\n\t\t  state_next = add_exp;\n        end\n\t\t\n\t\tadd_exp:\n\t\tbegin\n\t\t\tload_1_o = 1;\n\t\t\tload_2_o = 1;\n\t\t\tctrl_select_a_o = 1;\n\t\t\tctrl_select_b_o = 1;\n\t\t\tselector_b_o = 2'b01;\n\t\t\tstate_next = subt_bias;\n\t\tend\n\t\tsubt_bias:\n\t\tbegin\n\t\t\tload_2_o = 1;\n\t\t\tload_3_o = 1;\n\t\t\texp_op_o = 1;\n\n\t\t\tif(zero_flag_i)\n\t\t\t\tstate_next = ready_flag;\n\t\t\telse\n\t\t\t\tstate_next = mult_overf;\n\n\t\tend\n\t\tmult_overf:\n\t\tbegin\n\t\t\tif(Mult_shift_i) begin\n\t\t\t\tctrl_select_b_o =1;\n\t\t\t\tselector_b_o =2'b10;\n\t\t\t\tstate_next = mult_norn;\n\t\t\tend\n\t\t\telse\n\t\t\t\tstate_next = mult_no_norn;\n\t\tend\n\t\tmult_norn:\n\t\tbegin\n\t\t\tshift_value_o =1;\n\t\t\tload_6_o = 1;\n\t\t\tload_2_o = 1;\n\t\t\tload_3_o = 1;\n\t\t\tstate_next = round_case;\n\t\tend\n\t\tmult_no_norn:\n\t\tbegin\n\t\t\tshift_value_o =0;\n\t\t\tload_6_o = 1;\n\t\t\tstate_next = round_case;\n\t\tend\n\t\tround_case:\n\t\tbegin\n\t\t\tif(round_flag_i) begin\n\t\t\t\tctrl_select_c_o =1;\n\t\t\t\tstate_next = adder_round;\n\t\t\tend\n\t\t\telse\n\t\t\t\tstate_next = final_load;\n\t\tend\n\t\tadder_round:\n\t\tbegin\n\t\t\tload_4_o = 1;\n\t\t\tctrl_select_b_o = 1;\n\t\t\tselector_b_o = 2'b01;\n\t\t\tstate_next = round_norm;\n\t\tend\n\t\tround_norm:\n\t\tbegin\n\t\t\tload_6_o = 1;\n\t\t\tif(Add_Overflow_i)begin\n\t\t\t\tshift_value_o =1;\n\t\t\t\tload_2_o = 1;\n\t\t\t\tload_3_o = 1;\n\t\t\t\tstate_next = final_load;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tshift_value_o =0;\n\t\t\t\tstate_next = final_load;\n\t\t\tend\n\t\tend\n\t\t\n\t\tfinal_load: \n\t\tbegin\n\t\t\tload_5_o =1;\n\t\t\tstate_next = ready_flag;\n\t\tend\n\t\tready_flag:\n\t\tbegin\n\t\t\tready = 1;\n\t\t\t\tif(ack_FSM) begin\n\t\t\t\t\tstate_next = start;end\n\t\tend\n\t\t\n\t\tdefault:\n\t\tbegin\n\t\t\tstate_next =start;end\n\tendcase\nend\n\t\t\t\t\n\t\t\nendmodule\n",
        "module_name": "FSM_Mult_Function",
        "module_hash": "84b140fecd815ab5d7ef38103ba21ede",
        "dataset_index": 25829
      },
      "barrel_shifter_c847dc27": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [15:0] A, // 16-bit input\n    input [3:0] B, // 4-bit shift amount\n    output reg [15:0] Y // 16-bit output\n);\n\nreg [15:0] stage1_out;\nreg [15:0] stage2_out;\nreg [15:0] stage3_out;\n\nalways @(*) begin\n    case (B)\n        4'b0000: begin // No shift\n            Y = A;\n        end\n        4'b0001: begin // Shift right by 1 bit\n            stage1_out = {16{A[15]}};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0010: begin // Shift right by 2 bits\n            stage1_out = {16{A[15]}};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0011: begin // Shift right by 3 bits\n            stage1_out = {16{A[15]}};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0100: begin // Shift right by 4 bits\n            stage1_out = {A[11:0], A[15:12]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0101: begin // Shift right by 5 bits\n            stage1_out = {A[10:0], A[15:11]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0110: begin // Shift right by 6 bits\n            stage1_out = {A[9:0], A[15:10]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0111: begin // Shift right by 7 bits\n            stage1_out = {A[8:0], A[15:9]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1000: begin // Shift right by 8 bits\n            stage1_out = {A[7:0], A[15:8]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1001: begin // Shift right by 9 bits\n            stage1_out = {A[6:0], A[15:7]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1010: begin // Shift right by 10 bits\n            stage1_out = {A[5:0], A[15:6]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1011: begin // Shift right by 11 bits\n            stage1_out = {A[4:0], A[15:5]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1100: begin // Shift right by 12 bits\n            stage1_out = {A[3:0], A[15:4]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1101: begin // Shift right by 13 bits\n            stage1_out = {A[2:0], A[15:3]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1110: begin // Shift right by 14 bits\n            stage1_out = {A[1:0], A[15:2]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1111: begin // Shift right by 15 bits\n            stage1_out = {A[0], A[15:1]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "c847dc2751069daf4f315fa8f5d0dbe6",
        "dataset_index": 17540
      },
      "xgmii_baser_enc_64_f65ef0ed": {
        "rtl_code": "\nmodule xgmii_baser_enc_64 (\n    input clk,\n    input rst,\n    input [7:0] current_test,\n    input [63:0] xgmii_txd,\n    input [7:0] xgmii_txc,\n    output reg [63:0] encoded_tx_data,\n    output reg [1:0] encoded_tx_hdr\n);\n\n// Parameters\nparameter DATA_WIDTH = 64;\nparameter CTRL_WIDTH = (DATA_WIDTH/8);\nparameter HDR_WIDTH = 2;\nparameter DATA_MSB = DATA_WIDTH - 1;\n\n// Internal signals\nreg [DATA_MSB:0] data_reg = 0;\nreg [1:0] header_reg = 2'b00;\n\n// Encoding logic\nalways @(posedge clk ) begin\n    if (rst) begin\n        data_reg <= 0;\n        header_reg <= 2'b00;\n    end else begin\n        data_reg <= {xgmii_txd[DATA_MSB-7:0], xgmii_txc};\n        header_reg <= {xgmii_txd[DATA_MSB-1], xgmii_txd[DATA_MSB]};\n    end\nend\n\n// Output assignments\nalways @(posedge clk ) begin\n    encoded_tx_data <= data_reg;\n    encoded_tx_hdr <= header_reg;\nend\n\nendmodule",
        "module_name": "xgmii_baser_enc_64",
        "module_hash": "f65ef0ed95aa2d7885246b64a395caf8",
        "dataset_index": 12481
      },
      "binary_splitter_and_full_adder_74de7a07": {
        "rtl_code": "module binary_splitter_and_full_adder (\n    input wire [2:0] in_vec,\n    output wire [2:0] out_vec,\n    output wire o2,\n    output wire o1,\n    output wire o0,\n    input a, b, cin,\n    output cout,\n    output sum,\n    output wire [4:0] final_output\n);\n\n    // Binary splitter module\n    assign out_vec = in_vec;\n    assign o2 = in_vec[2];\n    assign o1 = in_vec[1];\n    assign o0 = in_vec[0];\n\n    // Full adder module\n    wire w1, w2, w3;\n    assign w1 = a ^ b;\n    assign w2 = w1 ^ cin;\n    assign sum = w2;\n    assign w3 = (a & b) | (cin & w1);\n    assign cout = w3;\n\n    // Functional module\n    wire and_out, or_out;\n    assign and_out = o2 & o1;\n    assign or_out = o2 | o1;\n    assign final_output[4] = and_out;\n    assign final_output[3] = and_out;\n    assign final_output[2] = or_out;\n    assign final_output[1] = or_out;\n    assign final_output[0] = sum;\n\nendmodule",
        "module_name": "binary_splitter_and_full_adder",
        "module_hash": "74de7a07198a950701d3ab5857c36577",
        "dataset_index": 1490
      },
      "lmcnt_e752ed6b": {
        "rtl_code": "module lmcnt\n  (\n   input \t    CLK,\n   input \t    RESET_X,\n\n   input \t    SOFT_RESET,\n   input \t    START,\n   output reg \t    FINISH,\n   input [1:0] \t    MSEL_INPUTA_SEL,\n   input [1:0] \t    MSEL_INPUTB_SEL,\n   input [1:0] \t    MSEL_OUTPUTC_SEL,\n   input [9:0] \t    M1POS,\n   input [9:0] \t    M1SIZE,\n   input [9:0] \t    M2POS,\n   input [9:0] \t    M3POS,\n  \n   input [7:0] \t    M0_RDATA,\n\n   output \t    M1_WR,\n   output [9:0]     M1_WADR,\n   output [7:0]     M1_WDATA,\n   output [9:0]     M1_RADR,\n   input [7:0] \t    M1_RDATA,\n\n   output \t    M2_WR,\n   output [9:0]     M2_WADR,\n   output [7:0]     M2_WDATA,\n   output [9:0]     M2_RADR,\n   input [7:0] \t    M2_RDATA,\n\n   output \t    M3_WR,\n   output [9:0]     M3_WADR,\n   output [7:0]     M3_WDATA,\n   output [9:0]     M3_RADR,\n   input [7:0] \t    M3_RDATA,\n\n   \n   output reg \t    NPU_EN,\n   output reg [7:0] A_RDATA,\n   output reg [7:0] B_RDATA,\n\n   input \t    LM_EN,\n   input [7:0] \t    C_WDATA\n   );\n\n   wire \t    rst_x;\n   assign rst_x = RESET_X & ~SOFT_RESET;\n\n   reg \t\t    npu_en_r;\n   wire \t    npu_en_w;\n   \n   assign npu_en_w = START | npu_en_r;\n   \n   \n   reg [9:0] \t    rcnt;\n   reg [9:0] \t    wcnt;\n   \n   always @ (posedge CLK or negedge rst_x)begin\n      if (rst_x == 0)begin\n\t rcnt <= 0;\n      end else begin\n\t if ((rcnt == 0) && (START == 1))begin\n\t    rcnt <= 1;\n\t end else if((rcnt != 0) && (rcnt != 10'h3FF))begin\n\t    rcnt <= rcnt + 1;\n\t end\n      end\n   end \n\n   always @ (posedge CLK or negedge rst_x)begin\n      if (rst_x == 0)begin\n\t NPU_EN <= 0;\n\t npu_en_r <= 0;\n      end else begin\n\t NPU_EN <= npu_en_w; \n\t if (START == 1)begin\n\t    npu_en_r <= 1;\n\t end else if(rcnt == 10'h3FF)begin\n\t    npu_en_r <= 0;\n\t end\n      end\n   end \n\n   always @ (posedge CLK or negedge rst_x)begin\n      if (rst_x == 0)begin\n\t wcnt <= 0;\n      end else begin\n\t if(LM_EN)begin\n\t    wcnt <= wcnt + 1;\n\t end\n      end\n   end \n\n   always @ (posedge CLK or negedge rst_x)begin\n      if (rst_x == 0)begin\n\t FINISH <= 0;\n      end else begin\n\t if(wcnt == 10'h3FF)begin\n\t    FINISH <= 1;\n\t end\n      end\n   end \n\n   assign M1_RADR = rcnt;\n   assign M2_RADR = rcnt;\n   assign M3_RADR = rcnt;\n\n   always @ (posedge CLK or negedge rst_x)begin\n      if (rst_x == 0)begin\n\t A_RDATA <= 0;\n      end else begin\n\t case (MSEL_INPUTA_SEL)\n\t   2'b00: A_RDATA <= M0_RDATA;\n\t   2'b01: A_RDATA <= M1_RDATA;\n\t   2'b10: A_RDATA <= M2_RDATA;\n\t   2'b11: A_RDATA <= M3_RDATA;\n\t endcase end\n   end \n\n   always @ (posedge CLK or negedge rst_x)begin\n      if (rst_x == 0)begin\n\t B_RDATA <= 0;\n      end else begin\n\t case (MSEL_INPUTB_SEL)\n\t   2'b00: B_RDATA <= M0_RDATA;\n\t   2'b01: B_RDATA <= M1_RDATA;\n\t   2'b10: B_RDATA <= M2_RDATA;\n\t   2'b11: B_RDATA <= M3_RDATA;\n\t endcase end\n   end \n\n   assign M1_WR = (MSEL_OUTPUTC_SEL == 2'b01) ? LM_EN : 0;\n   assign M2_WR = (MSEL_OUTPUTC_SEL == 2'b10) ? LM_EN : 0;   \n   assign M3_WR = (MSEL_OUTPUTC_SEL == 2'b11) ? LM_EN : 0;\n\n   assign M1_WADR = wcnt;\n   assign M2_WADR = wcnt;\n   assign M3_WADR = wcnt;\n\n   assign M1_WDATA = C_WDATA;\n   assign M2_WDATA = C_WDATA;\n   assign M3_WDATA = C_WDATA;\n   \nendmodule ",
        "module_name": "lmcnt",
        "module_hash": "e752ed6b9ed7d02b90e284645c91d3fe",
        "dataset_index": 3874
      },
      "mux4to1_e2ef4f15": {
        "rtl_code": "module mux4to1 (\n    // Inputs\n    input [1:0] sel,\n    input data0,\n    input data1,\n    input data2,\n    input data3,\n    // Outputs\n    output out\n);\n\n    // Wires\n    wire mux_out0;\n    wire mux_out1;\n\n    // Multiplexer\n    assign mux_out0 = (sel == 2'b00) ? data0 : data1;\n    assign mux_out1 = (sel == 2'b01) ? data2 : data3;\n    assign out = (sel == 2'b10) ? mux_out0 : mux_out1;\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "e2ef4f1516837ae4f1b62cf9e7095bf5",
        "dataset_index": 20896
      },
      "tb_axil_slave_model_0976071a": {
        "rtl_code": "module tb_axil_slave_model\n  (\n   input            ARESETN,\n   input            ACLK,\n\n   input [31:0]     M_AXI_AWADDR,\n   input [3:0]      M_AXI_AWCACHE,\n   input [2:0]      M_AXI_AWPROT,\n   input            M_AXI_AWVALID,\n   output reg       M_AXI_AWREADY,\n\n   input [31:0]     M_AXI_WDATA,\n   input [3:0]      M_AXI_WSTRB,\n   input            M_AXI_WVALID,\n   output reg       M_AXI_WREADY,\n\n   output reg [1:0] M_AXI_BRESP,\n   output           M_AXI_BVALID,\n   input            M_AXI_BREADY,\n\n   input [31:0]     M_AXI_ARADDR,\n   input [3:0]      M_AXI_ARCACHE,\n   input [2:0]      M_AXI_ARPROT,\n   input            M_AXI_ARVALID,\n   output reg       M_AXI_ARREADY,\n\n   output [31:0]    M_AXI_RDATA,\n   output reg [1:0] M_AXI_RRESP,\n   output           M_AXI_RVALID,\n   input            M_AXI_RREADY\n   );\n\n   initial begin\n      M_AXI_AWREADY  = 1;\n      M_AXI_WREADY   = 1;\n      M_AXI_BRESP    = 0;\n      M_AXI_RRESP    = 0;\n      M_AXI_ARREADY  = 1;\n   end\n\n   reg axi_rena;\n   reg [7:0]  axi_length;\n   always @(posedge ACLK or negedge ARESETN) begin\n      if(!ARESETN) begin\n         axi_rena <= 0;\n         axi_length <= 0;\n      end else begin\n         if(M_AXI_RVALID & M_AXI_RREADY) begin\n            axi_rena <= 0;\n         end else if(M_AXI_ARVALID) begin\n            axi_rena <= 1;\n         end\n      end\n   end\n   assign M_AXI_RDATA  = M_AXI_ARADDR;\n   assign M_AXI_RVALID = axi_rena & M_AXI_RREADY;\n\n   reg axi_wvalid;\n   always @(posedge ACLK or negedge ARESETN)begin\n      if(!ARESETN) begin\n         axi_wvalid <= 0;\n      end else begin\n         if(M_AXI_BREADY) begin\n            axi_wvalid <= 0;\n         end else if (M_AXI_WVALID) begin\n            axi_wvalid <= 1;\n         end\n      end\n   end\n\n   assign M_AXI_BVALID  = axi_wvalid;\n\nendmodule\n",
        "module_name": "tb_axil_slave_model",
        "module_hash": "0976071a941cfd9d6048d3fb40db8488",
        "dataset_index": 22352
      },
      "nand2_ec3c762c": {
        "rtl_code": "\nmodule nand2 (\n    Y,\n    A,\n    B\n);\n\n    // Module ports\n    output Y;\n    input  A;\n    input  B;\n\n    // Local signals\n    wire and0_out_Y;\n    wire nand0_out_Y;\n\n    //  Name    Output      Other arguments\n    nand nand0 (nand0_out_Y, A, B);\n    nand nand1 (Y,          nand0_out_Y);\n\nendmodule",
        "module_name": "nand2",
        "module_hash": "ec3c762c4df4bf543bf10864859732c4",
        "dataset_index": 14764
      },
      "Multiplexer_AC__parameterized36_db4d5841": {
        "rtl_code": "\nmodule Multiplexer_AC__parameterized36\n   (ctrl,\n    D0,\n    D1,\n    D2,\n    D3,\n    S);\n  input [1:0] ctrl;\n  input [0:0] D0;\n  input [0:0] D1;\n  input [0:0] D2;\n  input [0:0] D3;\n  output [0:0] S;\n\n  wire [0:0] S;\n\n  assign S = (ctrl == 2'b00) ? D0 :\n             (ctrl == 2'b01) ? D1 :\n             (ctrl == 2'b10) ? D2 :\n             (ctrl == 2'b11) ? D3 :\n             1'bx;\nendmodule",
        "module_name": "Multiplexer_AC__parameterized36",
        "module_hash": "db4d584126fa7357f392eee6c7e98acc",
        "dataset_index": 8148
      },
      "four_bit_adder_0093cd97": {
        "rtl_code": "\nmodule four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] carry;\n\n  // Full adder for bit 0\n  full_adder fa0 (.a(A[0]), .b(B[0]), .cin(Cin), .sum(S[0]), .cout(carry[0]));\n  \n  // Full adder for bit 1\n  full_adder fa1 (.a(A[1]), .b(B[1]), .cin(carry[0]), .sum(S[1]), .cout(carry[1]));\n  \n  // Full adder for bit 2\n  full_adder fa2 (.a(A[2]), .b(B[2]), .cin(carry[1]), .sum(S[2]), .cout(carry[2]));\n  \n  // Full adder for bit 3\n  full_adder fa3 (.a(A[3]), .b(B[3]), .cin(carry[2]), .sum(S[3]), .cout(Cout));\n\nendmodule\nmodule full_adder(\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign {cout, sum} = a + b + cin;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "0093cd97d813ec5797eb9d7882a2c40b",
        "dataset_index": 14585
      },
      "mem_protect #_99d03d3c": {
        "rtl_code": "module mem_protect #(\n  parameter n = 10,\n  parameter m = 2\n)(\n  input [n-1:0] addr,\n  input [m-1:0] ctrl,\n  output mem_en\n);\n\n\nparameter memory_size = 1024; // size of the memory block to be protected.\n\nreg mem_en;\n\nalways @(*) begin\n  if (addr < memory_size && ctrl[0] && !ctrl[1]) begin\n    mem_en = 1;\n  end else begin\n    mem_en = 0;\n  end\nend\n\nendmodule",
        "module_name": "mem_protect #",
        "module_hash": "99d03d3cd540e225f55ce325684d329c",
        "dataset_index": 18989
      },
      "KeyBoardController_3bd6b755": {
        "rtl_code": "module KeyBoardController(\n  input wire clk,\n  input wire PS2C,\n  input wire PS2D,\n  input wire InteAccept,\n  output reg[15:0] scanCode,\n  output reg KeyBoardInte\n);\n\n  reg[7:0] buffer[15:0]; // buffer to store scan codes\n  reg[3:0] put, get; // put and get pointers for buffer\n  reg[3:0] state; // state machine state\n  reg[22:0] count; // counter for PS2 clock\n  reg PS2Cf, PS2Df; // filtered PS2 signals\n  reg [7:0] ps2c_filter, ps2d_filter; // PS2 signal filters\n  reg [10:0] shift1, shift2; // shift registers for PS2 data\n  reg new; // flag for new scan code\n\n  initial begin\n    put <= 0; \n    get <= 0;\n    ps2c_filter <= 0;\n    ps2d_filter <= 0;\n    PS2Cf <= 1;\n    PS2Df <= 1;\n    shift1 <= 0;\n    shift2 <= 0;\n    state <= 0;\n    count <= 0;\n    new <= 0;\n    KeyBoardInte <= 0;\n  end\n\n  always @(posedge clk) begin\n    // filter PS2 signals and count clock cycles\n    ps2c_filter[7] <= PS2C;\n    ps2c_filter[6:0] <= ps2c_filter[7:1];\n    ps2d_filter[7] <= PS2D;\n    ps2d_filter[6:0] <= ps2d_filter[7:1];\n    if (ps2c_filter == 8'b11111111)\n      PS2Cf <= 1;\n    else begin\n      if (ps2c_filter == 8'b00000000)\n        PS2Cf <= 0;\n    end\n\n    if (ps2d_filter == 8'b11111111)\n      PS2Df <= 1;\n    else begin\n      if (ps2d_filter == 8'b00000000)\n        PS2Df <= 0;\n    end\n    if (PS2Df) begin\n      count <= count + 1;\n    end\n    else begin\n      count <= 1;\n    end\n    if (state == 10) begin\n      new <= 1;\n    end\n    if ((state == 0) && new) begin\n      if (put != get-1) begin\n        buffer[put] <= shift1[8:1];\n        put <= put+1;\n        new <= 0;\n      end\n    end\n    if ((get == put) | InteAccept) begin\n      KeyBoardInte <= 0;\n    end\n    else begin\n      if (KeyBoardInte == 0) begin\n        scanCode <= buffer[get];\n        KeyBoardInte <= 1;\n      end\n    end\n    if (InteAccept & (get != put)) begin\n      get <= get + 1;\n    end\n  end\n\n  wire rst;\n  assign rst = (count == 0);\n\n  // state machine for PS2 data\n  always @(negedge PS2Cf or posedge rst) begin\n    if (rst) begin\n      state <= 0;\n    end\n    else begin\n      shift1 <= {PS2Df, shift1[10:1]};\n      shift2 <= {shift1[0], shift2[10:1]}; // send high byte first, then low byte\n\n      if (state == 0 && PS2Df == 0) begin\n        state <= 1;\n      end\n      else if (state == 10) begin\n        state <= 0;\n      end\n      else begin\n        state <= state + 1;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "KeyBoardController",
        "module_hash": "3bd6b755f041298d34ce76e66e96c698",
        "dataset_index": 8384
      },
      "counter_3bit_34fcc122": {
        "rtl_code": "module counter_3bit(\n\tinput clk,\n\tinput reset,\n\tinput enable,\n\toutput reg [2:0] count\n);\n\n\talways @(posedge clk or negedge reset) begin\n\t\tif(!reset) begin\n\t\t\tcount <= 3'b0;\n\t\tend else if(enable) begin\n\t\t\tcount <= count + 1;\n\t\tend\n\tend\n\nendmodule",
        "module_name": "counter_3bit",
        "module_hash": "34fcc122ad0fa2382ea18d17bfdad7c8",
        "dataset_index": 18308
      },
      "controllerHdl_Detect_Change_337ca585": {
        "rtl_code": "\n\nmodule controllerHdl_Detect_Change\n          (\n           CLK_IN,\n           reset,\n           enb_1_2000_0,\n           x,\n           y\n          );\n\n\n  input   CLK_IN;\n  input   reset;\n  input   enb_1_2000_0;\n  input   signed [17:0] x;  output  y;\n\n\n  reg signed [17:0] Delay_out1;  wire signed [18:0] Add_sub_cast;  wire signed [18:0] Add_sub_cast_1;  wire signed [18:0] Add_out1;  wire Compare_To_Zero2_out1;\n\n\n  always @(posedge CLK_IN)\n    begin : Delay_process\n      if (reset == 1'b1) begin\n        Delay_out1 <= 18'sb000000000000000000;\n      end\n      else if (enb_1_2000_0) begin\n        Delay_out1 <= x;\n      end\n    end\n\n\n\n  assign Add_sub_cast = x;\n  assign Add_sub_cast_1 = Delay_out1;\n  assign Add_out1 = Add_sub_cast - Add_sub_cast_1;\n\n\n\n  assign Compare_To_Zero2_out1 = (Add_out1 != 19'sb0000000000000000000 ? 1'b1 :\n              1'b0);\n\n\n\n  assign y = Compare_To_Zero2_out1;\n\nendmodule  ",
        "module_name": "controllerHdl_Detect_Change",
        "module_hash": "337ca58523d29cc53d069b4ce78e183c",
        "dataset_index": 22148
      },
      "dmi_jtag_to_core_sync_8112afc5": {
        "rtl_code": "module dmi_jtag_to_core_sync (\n   input                       rd_en,       input                       wr_en,       input                       rst_n,       input                       clk,         output                      reg_en,      output                      reg_wr_en    );\n\n\n  \n  wire                         c_rd_en;\n  wire                         c_wr_en;\n   \n\n  assign reg_en = c_wr_en | c_rd_en;\n  assign reg_wr_en = c_wr_en;\n\n  reg [2:0] rden, wren;\n\nalways @ ( posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        rden <= 3'b0;\n        wren <= 3'b0;\n    end\n    else begin\n        rden <= {rden[1:0], rd_en};\n        wren <= {wren[1:0], wr_en};\n    end\nend\n\nassign c_rd_en = rden[1] & ~rden[2];\nassign c_wr_en = wren[1] & ~wren[2];\n \n\n\nendmodule\n",
        "module_name": "dmi_jtag_to_core_sync",
        "module_hash": "8112afc53e0a158505efff5a17df3721",
        "dataset_index": 18166
      },
      "decoder_fa00d960": {
        "rtl_code": "module decoder (\n  input [1:0] in,\n  input enable,\n  output [3:0] out\n);\n  \n  assign out[0] = ~(in[1] | in[0] | enable);\n  assign out[1] = ~(in[1] | ~in[0] | enable);\n  assign out[2] = ~(~in[1] | in[0] | enable);\n  assign out[3] = ~(~in[1] | ~in[0] | enable);\n  \nendmodule",
        "module_name": "decoder",
        "module_hash": "fa00d9602dc3039bb5d83b2e8c7abb58",
        "dataset_index": 7790
      },
      "dmac_2d_transfer #_058f7669": {
        "rtl_code": "\n\nmodule dmac_2d_transfer #(\n\n  parameter DMA_AXI_ADDR_WIDTH = 32,\n  parameter DMA_LENGTH_WIDTH = 24,\n  parameter BYTES_PER_BURST_WIDTH = 7,\n  parameter BYTES_PER_BEAT_WIDTH_SRC = 3,\n  parameter BYTES_PER_BEAT_WIDTH_DEST = 3)(\n\n  input req_aclk,\n  input req_aresetn,\n\n  input req_valid,\n  output reg req_ready,\n\n  input [DMA_AXI_ADDR_WIDTH-1:BYTES_PER_BEAT_WIDTH_DEST] req_dest_address,\n  input [DMA_AXI_ADDR_WIDTH-1:BYTES_PER_BEAT_WIDTH_SRC] req_src_address,\n  input [DMA_LENGTH_WIDTH-1:0] req_x_length,\n  input [DMA_LENGTH_WIDTH-1:0] req_y_length,\n  input [DMA_LENGTH_WIDTH-1:0] req_dest_stride,\n  input [DMA_LENGTH_WIDTH-1:0] req_src_stride,\n  input req_sync_transfer_start,\n  input req_last,\n\n  output reg req_eot,\n  output reg [BYTES_PER_BURST_WIDTH-1:0] req_measured_burst_length,\n  output reg req_response_partial,\n  output reg req_response_valid,\n  input req_response_ready,\n\n  input out_abort_req,\n\n  output reg out_req_valid,\n  input out_req_ready,\n  output [DMA_AXI_ADDR_WIDTH-1:BYTES_PER_BEAT_WIDTH_DEST] out_req_dest_address,\n  output [DMA_AXI_ADDR_WIDTH-1:BYTES_PER_BEAT_WIDTH_SRC] out_req_src_address,\n  output [DMA_LENGTH_WIDTH-1:0] out_req_length,\n  output reg out_req_sync_transfer_start,\n  output out_req_last,\n\n  input out_eot,\n  input [BYTES_PER_BURST_WIDTH-1:0] out_measured_burst_length,\n  input out_response_partial,\n  input out_response_valid,\n  output reg out_response_ready = 1'b1\n\n);\n\nreg [DMA_AXI_ADDR_WIDTH-1:BYTES_PER_BEAT_WIDTH_DEST] dest_address = 'h00;\nreg [DMA_AXI_ADDR_WIDTH-1:BYTES_PER_BEAT_WIDTH_SRC] src_address = 'h00;\nreg [DMA_LENGTH_WIDTH-1:0] x_length = 'h00;\nreg [DMA_LENGTH_WIDTH-1:0] y_length = 'h00;\nreg [DMA_LENGTH_WIDTH-1:0] dest_stride = 'h0;\nreg [DMA_LENGTH_WIDTH-1:0] src_stride = 'h00;\n\nreg gen_last = 'h0;\n\nreg [1:0] req_id = 'h00;\nreg [1:0] eot_id = 'h00;\nreg [3:0] last_req = 'h00;\n\nwire out_last;\n\nassign out_req_dest_address = dest_address;\nassign out_req_src_address = src_address;\nassign out_req_length = x_length;\nassign out_last = y_length == 'h00;\n\nalways @(posedge req_aclk) begin\n  if (req_aresetn == 1'b0) begin\n    req_id <= 2'b0;\n    eot_id <= 2'b0;\n    req_eot <= 1'b0;\n  end else begin\n    if (out_req_valid == 1'b1 && out_req_ready == 1'b1) begin\n      req_id <= req_id + 1'b1;\n    end\n\n    if (out_eot == 1'b1 && out_response_valid == 1'b1 && out_response_ready == 1'b1) begin\n      eot_id <= eot_id + 1'b1;\n      req_eot <= last_req[eot_id];\n    end else begin\n      req_eot <= 1'b0;\n    end\n  end\nend\n\nalways @(posedge req_aclk) begin\n  if (out_req_valid == 1'b1 && out_req_ready == 1'b1) begin\n    last_req[req_id] <= out_last;\n  end\nend\n\nalways @(posedge req_aclk) begin\n  if (out_response_valid == 1'b1 && out_response_ready == 1'b1) begin\n    req_measured_burst_length <= out_measured_burst_length;\n    req_response_partial <= out_response_partial;\n  end\nend\n\nalways @(posedge req_aclk) begin\n  if (out_response_valid == 1'b1 && out_response_ready == 1'b1) begin\n    req_response_valid <= 1'b1;\n  end else if (req_response_ready == 1'b1) begin\n    req_response_valid <= 1'b0;\n  end\nend\n\nalways @(posedge req_aclk) begin\n  if (req_aresetn == 1'b0) begin\n    out_response_ready <= 1'b1;\n  end else if (out_response_ready == 1'b1) begin\n    out_response_ready <= ~out_response_valid;\n  end else if (req_response_ready == 1'b1) begin\n    out_response_ready <= 1'b1;\n  end\nend\n\nalways @(posedge req_aclk) begin\n  if (req_ready == 1'b1 && req_valid == 1'b1) begin\n    dest_address <= req_dest_address;\n    src_address <= req_src_address;\n    x_length <= req_x_length;\n    y_length <= req_y_length;\n    dest_stride <= req_dest_stride;\n    src_stride <= req_src_stride;\n    out_req_sync_transfer_start <= req_sync_transfer_start;\n    gen_last <= req_last;\n  end else if (out_abort_req == 1'b1) begin\n    y_length <= 0;\n  end else if (out_req_valid == 1'b1 && out_req_ready == 1'b1) begin\n    dest_address <= dest_address + dest_stride[DMA_LENGTH_WIDTH-1:BYTES_PER_BEAT_WIDTH_DEST];\n    src_address <= src_address + src_stride[DMA_LENGTH_WIDTH-1:BYTES_PER_BEAT_WIDTH_SRC];\n    y_length <= y_length - 1'b1;\n    out_req_sync_transfer_start <= 1'b0;\n  end\nend\n\nalways @(posedge req_aclk) begin\n  if (req_aresetn == 1'b0) begin\n    req_ready <= 1'b1;\n    out_req_valid <= 1'b0;\n  end else begin\n    if (req_ready == 1'b1 && req_valid == 1'b1) begin\n      req_ready <= 1'b0;\n      out_req_valid <= 1'b1;\n    end else if (out_req_valid == 1'b1 && out_req_ready == 1'b1 &&\n                 out_last == 1'b1) begin\n      out_req_valid <= 1'b0;\n      req_ready <= 1'b1;\n    end\n  end\nend\n\nassign out_req_last = out_last & gen_last;\n\nendmodule\n",
        "module_name": "dmac_2d_transfer #",
        "module_hash": "058f76694de90a97c69002718d379e03",
        "dataset_index": 22788
      },
      "xnor_gate_b0a383b1": {
        "rtl_code": "\nmodule xnor_gate(\n    input A,\n    input B,\n    input VPWR,\n    input VGND,\n    output Y\n);\n\n    reg [3:0] state = 4'b0000;\n    reg [1:0] input_state = 2'b00;\n    wire [1:0] xnor_out;\n\n    assign xnor_out = {~A ^ ~B, ~A ^ ~B};\n    assign Y = input_state == 2'b00 ? xnor_out[0] :\n               input_state == 2'b01 ? xnor_out[1] :\n               input_state == 2'b10 ? xnor_out[0] & xnor_out[1] :\n               ~xnor_out[0] & ~xnor_out[1];\n\nendmodule",
        "module_name": "xnor_gate",
        "module_hash": "b0a383b1f52eba772a7b429e432b0048",
        "dataset_index": 13654
      },
      "rcv_af38f487": {
        "rtl_code": "module rcv(clk, reset, full, parallel_out, serial_in);\n    input clk;\n    input reset;\n    output reg full;\n    output [7:0] parallel_out;\n    input serial_in;\n\n  reg serial_p;\n  reg serial_s;\n  reg [3:0] state;\n  reg [8:0] shift;\n  reg [10:0] count;\n\n  assign parallel_out[7:0] = shift[7:0];\n\n  always @(posedge clk) begin\n    serial_p <= serial_in;\n    serial_s <= serial_p;\n  end\n\n  always @(posedge clk) begin\n    if (reset == 1) begin\n      state <= 4'h0;\n      full <= 0;\n    end else begin\n      if (state == 4'h0) begin\n        full <= 0;\n        if (serial_s == 0) begin\n          state <= 4'h1;\n          count <= 651;\n        end\n      end else\n      if (state == 4'hb) begin\n        state <= 4'h0;\n        full <= 1;\n      end else begin\n        if (count == 0) begin\n          state <= state + 1;\n          shift[8:0] <= { serial_s, shift[8:1] };\n          count <= 1302;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "rcv",
        "module_hash": "af38f487b4c36f4fe4f7eb424f2ca67d",
        "dataset_index": 8988
      },
      "clock_generator_d5da93af": {
        "rtl_code": "module clock_generator (\n    input clk_in,\n    input reset,\n    output reg clk_out_1,\n    output reg clk_out_2\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk_in or posedge reset) begin\n        if (reset) begin\n            clk_out_1 <= 1'b0;\n            clk_out_2 <= 1'b0;\n            count <= 2'b00;\n        end else begin\n            count <= count + 1;\n            if (count == 2'b01) begin\n                clk_out_1 <= ~clk_out_1;\n            end else if (count == 2'b10) begin\n                clk_out_2 <= ~clk_out_2;\n                count <= 2'b00;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "clock_generator",
        "module_hash": "d5da93afa5197d84b8271208fd225d8a",
        "dataset_index": 13371
      },
      "motor_control_4b0eea8e": {
        "rtl_code": "module motor_control (\n  input clk,\n  input dir,\n  input [7:0] pwm,\n  input [7:0] duty_cycle,\n  output h_bridge_out1,\n  output h_bridge_out2\n);\n\n  reg [7:0] counter;\n  reg pwm_out;\n  \n  always @(posedge clk) begin\n    counter <= counter + 1;\n    if (counter >= duty_cycle) begin\n      pwm_out <= 0;\n    end else begin\n      pwm_out <= 1;\n    end\n  end\n  \n  assign h_bridge_out1 = (dir == 1) ? pwm_out : 0;\n  assign h_bridge_out2 = (dir == 0) ? pwm_out : 0;\n\nendmodule",
        "module_name": "motor_control",
        "module_hash": "4b0eea8e1453bbde56b51229155ed584",
        "dataset_index": 878
      },
      "up_down_counter_bcd_392659e1": {
        "rtl_code": "module up_down_counter_bcd (\n    input Up,\n    input Down,\n    input Clk,\n    input reset,\n    output reg [3:0] Count,\n    output reg [3:0] BCD1,\n    output reg [3:0] BCD0,\n    output reg [7:0] BCD_output\n);\n\nreg [3:0] BCD_count;\n\n// Up/Down Counter\nalways @(posedge Clk or posedge reset) begin\n    if (reset) begin\n        Count <= 4'b0000;\n    end else if (Up) begin\n        Count <= Count + 1;\n    end else if (Down) begin\n        Count <= Count - 1;\n    end\nend\n\n// Binary to BCD Converter\nalways @(Count) begin\n    case (Count)\n        4'b0000: begin\n            BCD_count = 4'b0000;\n        end\n        4'b0001: begin\n            BCD_count = 4'b0001;\n        end\n        4'b0010: begin\n            BCD_count = 4'b0010;\n        end\n        4'b0011: begin\n            BCD_count = 4'b0011;\n        end\n        4'b0100: begin\n            BCD_count = 4'b0100;\n        end\n        4'b0101: begin\n            BCD_count = 4'b0101;\n        end\n        4'b0110: begin\n            BCD_count = 4'b0110;\n        end\n        4'b0111: begin\n            BCD_count = 4'b0111;\n        end\n        4'b1000: begin\n            BCD_count = 4'b1000;\n        end\n        4'b1001: begin\n            BCD_count = 4'b1001;\n        end\n        4'b1010: begin\n            BCD_count = 4'b0001;\n            BCD1 = 4'b0001;\n        end\n        4'b1011: begin\n            BCD_count = 4'b0001;\n            BCD1 = 4'b0001;\n            BCD0 = 4'b0001;\n        end\n        4'b1100: begin\n            BCD_count = 4'b0001;\n            BCD0 = 4'b0001;\n        end\n        4'b1101: begin\n            BCD_count = 4'b0010;\n        end\n        4'b1110: begin\n            BCD_count = 4'b0011;\n        end\n        4'b1111: begin\n            BCD_count = 4'b0100;\n        end\n    endcase\nend\n\n// BCD Output\nalways @(BCD1, BCD0) begin\n    BCD_output = {BCD1, BCD0, BCD_count};\nend\n\nendmodule",
        "module_name": "up_down_counter_bcd",
        "module_hash": "392659e18fea207bc4b034da8f11d085",
        "dataset_index": 9968
      },
      "fsm_longest_sequence_detection_c5666b0f": {
        "rtl_code": "module fsm_longest_sequence_detection (\n  input clk,\n  input reset,\n  input [7:0] data,\n  output reg [2:0] longest_sequence\n);\n\n  parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n  reg [2:0] state, next_state;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= S0;\n      longest_sequence <= 3'b000;\n    end\n    else begin\n      state <= next_state;\n      case (state)\n        S0: begin\n          if (data == 8'b00000000)\n            next_state = S0;\n          else if (data[7] == 1)\n            next_state = S1;\n          else\n            next_state = S0;\n        end\n        S1: begin\n          if (data == 8'b11111111) begin\n            next_state = S4;\n            longest_sequence <= 3'b111;\n          end\n          else if (data[7] == 1)\n            next_state = S2;\n          else\n            next_state = S0;\n        end\n        S2: begin\n          if (data == 8'b11111111) begin\n            next_state = S4;\n            longest_sequence <= 3'b111;\n          end\n          else if (data[7:6] == 2'b11)\n            next_state = S3;\n          else if (data[7] == 0)\n            next_state = S0;\n          else\n            next_state = S2;\n        end\n        S3: begin\n          if (data == 8'b11111111) begin\n            next_state = S4;\n            longest_sequence <= 3'b111;\n          end\n          else if (data[7] == 0)\n            next_state = S0;\n          else\n            next_state = S3;\n        end\n        S4: begin\n          if (data == 8'b11111111)\n            next_state = S4;\n          else\n            next_state = S0;\n        end\n      endcase\n    end\n  end\n  \nendmodule\n",
        "module_name": "fsm_longest_sequence_detection",
        "module_hash": "c5666b0ff98acbb9e16c2cf57ff0a7a1",
        "dataset_index": 5496
      },
      "xor3_74989207": {
        "rtl_code": "module xor3 (\n    input a,\n    input b,\n    input c,\n    output x\n);\n\n    wire not_a;\n    wire not_b;\n    wire not_c;\n    wire a_and_b;\n    wire b_and_c;\n    wire c_and_a;\n    wire xor1;\n    wire xor2;\n\n    // Invert input bits\n    not not_a (not_a, a);\n    not not_b (not_b, b);\n    not not_c (not_c, c);\n\n    // Compute ANDs\n    and a_and_b (a_and_b, a, b);\n    and b_and_c (b_and_c, b, c);\n    and c_and_a (c_and_a, c, a);\n\n    // Compute XORs\n    xor xor1 (xor1, not_a, b_and_c);\n    xor xor2 (xor2, a_and_b, not_c);\n\n    // Compute final XOR\n    xor x (x, xor1, xor2);\n\nendmodule",
        "module_name": "xor3",
        "module_hash": "749892076c21d3923566b09321f8c1cf",
        "dataset_index": 5705
      },
      "crc__01257c84": {
        "rtl_code": "module crc_module (\n  input clk,\n  input [31:0] data_in,\n  output reg [15:0] crc_out\n);\n\n  reg [15:0] crc_reg = 16'hFFFF;\n  reg [31:0] data_reg;\n  reg [3:0] i;\n\n  always @(posedge clk) begin\n    data_reg <= data_in;\n    crc_reg <= crc_reg ^ data_reg;\n    for (i = 0; i < 32; i = i + 1) begin\n      if (crc_reg[15] == 1) begin\n        crc_reg <= {crc_reg[14:0], crc_reg[15]} ^ 16'hA001;\n      end else begin\n        crc_reg <= {crc_reg[14:0], crc_reg[15]};\n      end\n    end\n    crc_out <= crc_reg;\n  end\n\nendmodule",
        "module_name": "crc_",
        "module_hash": "01257c846f3d1b4d6550c5da75d9eaf1",
        "dataset_index": 17173
      },
      "signed_adder_overflow_detection_b0fa4bf7": {
        "rtl_code": "module signed_adder_overflow_detection(\n  input clk,\n  input reset,\n  input signed [7:0] a,\n  input signed [7:0] b,\n  output reg signed [7:0] s,\n  output reg ov\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      s <= 0;\n      ov <= 0;\n    end else begin\n      s <= a + b;\n      if ((a[7] == b[7]) && (a[7] != s[7])) begin\n        ov <= 1;\n      end else begin\n        ov <= 0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "signed_adder_overflow_detection",
        "module_hash": "b0fa4bf7f486fbe7019bc93708f56fa3",
        "dataset_index": 8011
      },
      "ripple_carry_adder_6fda2713": {
        "rtl_code": "\nmodule ripple_carry_adder(\n    input [31:0] a,\n    input [31:0] b,\n    input cin,\n    output [31:0] sum,\n    output cout\n);\n\nwire [31:0] s;\nwire [31:0] c;\n\nassign s = a ^ b ^ cin;\nassign c = (a & b) | (a & cin) | (b & cin);\n\nassign sum = s;\nassign cout = c[31];\n\nendmodule\nmodule carry_save_adder(\n    input [31:0] a,\n    input [31:0] b,\n    input cin,\n    output [31:0] sum,\n    output carry\n);\n\nwire [31:0] s1;\nwire c1, c2;\n\nripple_carry_adder rca1(.a(a), .b(b), .cin(1'b0), .sum(s1), .cout(c1));\nripple_carry_adder rca2(.a(s1), .b({31'b0, cin}), .cin(c1), .sum(sum), .cout(c2));\n\nassign carry = c2;\n\nendmodule\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\nwire [31:0] b_inverted;\nwire cin;\n\nassign b_inverted = sub ? ~b : b;\nassign cin = sub ? 1'b1 : 1'b0;\n\ncarry_save_adder csa(.a(a), .b(b_inverted), .cin(cin), .sum(sum), .carry());\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "6fda271353bdf8248a4b0559cbcc7d6b",
        "dataset_index": 19663
      },
      "Divider #_51ce5bb7": {
        "rtl_code": "module Divider #(\n  parameter n = 8 // number of bits in the input and output signals\n)(\n  input [n-1:0] dividend,\n  input [n-1:0] divisor,\n  output [n-1:0] quotient,\n  output [n-1:0] remainder\n);\n\n\nreg [n-1:0] dividend_reg;\nreg [n-1:0] divisor_reg;\nreg [n-1:0] quotient_reg;\nreg [n-1:0] remainder_reg;\nreg signed [n-1:0] dividend_signed;\nreg signed [n-1:0] divisor_signed;\nreg signed [n-1:0] quotient_signed;\nreg signed [n-1:0] remainder_signed;\nreg [n:0] dividend_abs;\nreg [n:0] divisor_abs;\nreg [n:0] quotient_abs;\nreg [n:0] remainder_abs;\nreg [n:0] temp_abs;\n\nassign quotient = quotient_signed;\nassign remainder = remainder_signed;\n\nalways @(*) begin\n  dividend_reg = dividend;\n  divisor_reg = divisor;\n  dividend_signed = $signed(dividend_reg);\n  divisor_signed = $signed(divisor_reg);\n  dividend_abs = dividend_signed >= 0 ? dividend_signed : -dividend_signed;\n  divisor_abs = divisor_signed >= 0 ? divisor_signed : -divisor_signed;\n  quotient_signed = dividend_signed / divisor_signed;\n  remainder_signed = dividend_signed % divisor_signed;\n  quotient_abs = dividend_abs / divisor_abs;\n  remainder_abs = dividend_abs % divisor_abs;\n  temp_abs = remainder_abs << 1;\n  if (temp_abs >= divisor_abs) begin\n    quotient_abs = quotient_abs + 1;\n    remainder_abs = temp_abs - divisor_abs;\n  end\n  if (dividend_signed < 0 && divisor_signed > 0 || dividend_signed > 0 && divisor_signed < 0) begin\n    quotient_signed = -quotient_signed;\n    remainder_signed = -remainder_signed;\n  end\n  quotient_reg = quotient_abs;\n  remainder_reg = remainder_abs;\nend\n\nendmodule",
        "module_name": "Divider #",
        "module_hash": "51ce5bb7b347a2e34090dce168892c5d",
        "dataset_index": 16830
      },
      "seven_segment_controller_32104fbf": {
        "rtl_code": "module seven_segment_controller(\n    input wire clk, reset, button,\n    output reg [6:0] leds\n);\n\nreg [3:0] digit = 0;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        digit <= 0;\n        leds <= 7'b0000001;\n    end else if (button) begin\n        digit <= digit + 1;\n        case (digit)\n            4'b0000: leds <= 7'b0000001; // 0\n            4'b0001: leds <= 7'b1001111; // 1\n            4'b0010: leds <= 7'b0010010; // 2\n            4'b0011: leds <= 7'b0000110; // 3\n            4'b0100: leds <= 7'b1001100; // 4\n            4'b0101: leds <= 7'b0100100; // 5\n            4'b0110: leds <= 7'b0100000; // 6\n            4'b0111: leds <= 7'b0001111; // 7\n            4'b1000: leds <= 7'b0000000; // 8\n            4'b1001: leds <= 7'b0000100; // 9\n            default: leds <= 7'b1111111; // default to all LEDs on\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "seven_segment_controller",
        "module_hash": "32104fbfbdad221f449f174b61b8570e",
        "dataset_index": 9789
      },
      "alu_4bit_aca77929": {
        "rtl_code": "module alu_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] OP,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        case (OP)\n            3'b000: result = A + B; // Addition\n            3'b001: result = A - B; // Subtraction\n            3'b010: result = A & B; // Bitwise AND\n            3'b011: result = A | B; // Bitwise OR\n            3'b100: result = A ^ B; // Bitwise XOR\n            3'b101: result = A << 1; // Arithmetic Shift Left\n            default: result = 4'bxxxx; // Invalid OP code\n        endcase\n    end\n\nendmodule",
        "module_name": "alu_4bit",
        "module_hash": "aca779296f0ca0f4ad86506c5870ac0e",
        "dataset_index": 1230
      },
      "reset_module_52b9e1e7": {
        "rtl_code": "module reset_module(\n  input slowest_clk,\n  input ext_reset,\n  input aux_reset,\n  input dcm_locked,\n  input debug_sys_rst,\n  output reg sys_reset,\n  output reg [0:0]bus_struct_reset,\n  output reg [0:0]peripheral_reset,\n  output reg [0:0]interconnect_reset,\n  output reg [0:0]peripheral_aresetn\n);\n\n  reg [1:0] reset_state;\n  reg [1:0] sync_reset_state;\n\n  always @(posedge slowest_clk) begin\n    // Synchronize reset signals to slowest clock\n    sync_reset_state <= reset_state;\n    if (dcm_locked) begin\n      reset_state[0] <= ~ext_reset;\n      reset_state[1] <= reset_state[0] & (~aux_reset | sync_reset_state[1]);\n    end\n  end\n\n  // System reset\n  always @(posedge slowest_clk) begin\n    if (debug_sys_rst) begin\n      sys_reset <= 1'b1;\n    end else if (sync_reset_state[1]) begin\n      sys_reset <= 1'b1;\n    end else begin\n      sys_reset <= 1'b0;\n    end\n  end\n\n  // Bus structure reset\n  always @(posedge slowest_clk) begin\n    if (sync_reset_state[1]) begin\n      bus_struct_reset <= 1'b1;\n    end else begin\n      bus_struct_reset <= 1'b0;\n    end\n  end\n\n  // Peripheral reset\n  always @(posedge slowest_clk) begin\n    if (sync_reset_state[1]) begin\n      peripheral_reset <= 1'b1;\n    end else begin\n      peripheral_reset <= 1'b0;\n    end\n  end\n\n  // Interconnect reset\n  always @(posedge slowest_clk) begin\n    if (sync_reset_state[1]) begin\n      interconnect_reset <= 1'b1;\n    end else begin\n      interconnect_reset <= 1'b0;\n    end\n  end\n\n  // Peripheral active reset\n  always @(posedge slowest_clk) begin\n    if (sync_reset_state[1]) begin\n      peripheral_aresetn <= 1'b0;\n    end else begin\n      peripheral_aresetn <= 1'b1;\n    end\n  end\n\nendmodule",
        "module_name": "reset_module",
        "module_hash": "52b9e1e77f69f6d27f4a9da282ee76a2",
        "dataset_index": 8380
      },
      "frequency_synthesizer_d7b02237": {
        "rtl_code": "\nmodule frequency_synthesizer (\n  input ref_clk,\n  input ctrl,\n  input [11:0] freq_word,\n  input [15:0] phase_acc,\n  output [15:0] out\n);\n\nparameter pll_mult = 10;\nparameter pll_div = 1;\nparameter clk_freq = 50e6;\nparameter dds_clk_freq = 100e6;\n\nreg [15:0] phase_accumulator;\nreg [15:0] dds_clk_divider;\nreg [15:0] pll_clk_divider;\nreg [15:0] out_reg;\n\nalways @(posedge ref_clk) begin\n  if (ctrl) begin // DDS mode\n    dds_clk_divider <= dds_clk_divider + 1;\n    if (dds_clk_divider == freq_word) begin\n      dds_clk_divider <= 0;\n      phase_accumulator <= phase_accumulator + phase_acc;\n      out_reg <= phase_accumulator[15:0];\n    end\n  end else begin // PLL mode\n    pll_clk_divider <= pll_clk_divider + 1;\n    if (pll_clk_divider == pll_div) begin\n      pll_clk_divider <= 0;\n      out_reg <= out_reg + 1'b1;\n    end\n  end\nend\n\nassign out = out_reg;\n\nendmodule",
        "module_name": "frequency_synthesizer",
        "module_hash": "d7b022370b204a723bb59dee66dc2729",
        "dataset_index": 19003
      },
      "compare_data_32c5600f": {
        "rtl_code": "module compare_data (\n  input clk,\n  input rst,\n  input [7:0] data1,\n  input [7:0] data2,\n  output reg eq,\n  output reg done\n);\n\n  reg [7:0] data1_reg;\n  reg [7:0] data2_reg;\n  reg [3:0] byte_cnt;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      eq <= 0;\n      done <= 0;\n      byte_cnt <= 0;\n      data1_reg <= 0;\n      data2_reg <= 0;\n    end\n    else begin\n      if (byte_cnt == 0) begin\n        data1_reg <= data1;\n        data2_reg <= data2;\n        byte_cnt <= 1;\n      end\n      else if (byte_cnt < 7) begin\n        byte_cnt <= byte_cnt + 1;\n      end\n      else begin\n        if (data1_reg == data2_reg) begin\n          eq <= 1;\n        end\n        else begin\n          eq <= 0;\n        end\n        done <= 1;\n        byte_cnt <= 0;\n      end\n    end\n  end\n  \nendmodule",
        "module_name": "compare_data",
        "module_hash": "32c5600fc730c4251504b8bc3285c55f",
        "dataset_index": 3411
      },
      "MULTIPLEXER_4_TO_1 #_e64756ef": {
        "rtl_code": "\nmodule MULTIPLEXER_4_TO_1 #(\n        parameter BUS_WIDTH     = 32          \n    ) (\n        input   [BUS_WIDTH - 1 : 0] IN1     ,\n        input   [BUS_WIDTH - 1 : 0] IN2     ,\n        input   [BUS_WIDTH - 1 : 0] IN3     ,\n        input   [BUS_WIDTH - 1 : 0] IN4     ,\n        input   [1             : 0] SELECT  ,\n        output  [BUS_WIDTH - 1 : 0] OUT     \n    );\n    \n    reg [BUS_WIDTH - 1 : 0] out_reg;\n    \n    always@(*)\n    begin\n        case(SELECT)\n            2'b00:\n            begin\n                out_reg = IN1;\n            end \n            2'b01:\n            begin\n                out_reg = IN2;\n            end \n            2'b10:\n            begin\n                out_reg = IN3;\n            end \n            2'b11:\n            begin\n                out_reg = IN4;\n            end \n        endcase\n    end\n    \n   assign OUT = out_reg;\n    \nendmodule\n",
        "module_name": "MULTIPLEXER_4_TO_1 #",
        "module_hash": "e64756ef3386c3644b439913e8c24eb4",
        "dataset_index": 6265
      },
      "binary_counter_0af31521": {
        "rtl_code": "module binary_counter(clk, reset, count);\n\n  input clk, reset;\n  output reg [7:0] count;\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "0af31521c8f69e880f0644fc54a91e98",
        "dataset_index": 11824
      },
      "Zigbee_226886b0": {
        "rtl_code": "\nmodule Zigbee (\n  input [7:0] data_in,\n  input [3:0] channel,\n  input TX_EN,\n  input RX_EN,\n  input [7:0] RX_IN,\n  output reg [7:0] data_out,\n  output reg TX_OUT\n);\n\n  // Zigbee protocol implementation for modulation and demodulation\n  // ...\n\n  parameter RX_CHANNEL = 4'b0000; // Define the receiver channel\n\n  // Transmitter module\n  always @(posedge TX_EN) begin\n    // Modulate the input data using the Zigbee protocol\n    // ...\n\n    // Transmit the modulated signal on the specified channel\n    // ...\n    TX_OUT <= modulated_signal;\n  end\n\n  // Receiver module\n  always @(posedge RX_EN) begin\n    // Demodulate the input signal using the Zigbee protocol\n    // ...\n\n    // Output the demodulated data when valid data is received on the specified channel\n    if (channel == RX_CHANNEL && valid_data_received) begin\n      data_out <= demodulated_data;\n    end\n  end\n\n  reg [7:0] demodulated_data;\n  reg valid_data_received;\n  reg [7:0] modulated_signal;\n\n  // RTL changes to fix continuous assignment warnings\n  always @(*) begin\n    modulated_signal <= data_in;\n    demodulated_data <= RX_IN;\n    valid_data_received <= 1'b1;\n  end\n\nendmodule",
        "module_name": "Zigbee",
        "module_hash": "226886b086e38fb23bf3eeea67d99f7c",
        "dataset_index": 15300
      },
      "cross_domain_signal_3d84c03d": {
        "rtl_code": "\nmodule cross_domain_signal (\n    input CLK_A,        // Clock for domain A\n    input CLK_A_SEND,   // Signal from domain A to domain B\n    output CLK_A_RECV,  // Signal from domain B received in domain A \n    input CLK_B,        // Clock for domain B\n    output CLK_B_RECV,  // Signal from domain A received in domain B\n    output ERR          // Error output\n);\n\n    reg a_send_sync = 0;\n    reg b_send_sync = 0;\n    reg a_send_sync_ff;\n    reg b_send_sync_ff;\n\n    assign CLK_A_RECV = b_send_sync_ff;\n    assign CLK_B_RECV = a_send_sync_ff;\n\n    always @(posedge CLK_A) begin\n        a_send_sync <= CLK_A_SEND;\n    end\n\n    always @(posedge CLK_B) begin\n        b_send_sync <= CLK_A_SEND;\n    end\n\n    always @(posedge CLK_A) begin\n        b_send_sync_ff <= b_send_sync;\n    end\n\n    always @(posedge CLK_B) begin\n        a_send_sync_ff <= a_send_sync;\n    end\n\n    assign ERR = (a_send_sync & b_send_sync) | (~a_send_sync & ~b_send_sync);\n\nendmodule",
        "module_name": "cross_domain_signal",
        "module_hash": "3d84c03d98e3fadfe1e6ea01def4e3be",
        "dataset_index": 10006
      },
      "MIB_DDR_SDRAM #_626b1b92": {
        "rtl_code": "\nmodule MIB_DDR_SDRAM #(\n  parameter DATA_WIDTH = 32, // width of the data bus\n  parameter ADDR_WIDTH = 8 // width of the address bus\n)(\n  input clk,\n  input rst,\n  input we,\n  input [ADDR_WIDTH-1:0] addr,\n  input [DATA_WIDTH-1:0] din,\n  output reg [DATA_WIDTH-1:0] dout\n);\n\n  reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      dout <= 0;\n    end else begin\n      if (we) begin\n        mem[addr] <= din;\n      end else begin\n        dout <= mem[addr];\n      end\n    end\n  end\n\nendmodule",
        "module_name": "MIB_DDR_SDRAM #",
        "module_hash": "626b1b92c5afeffe8706c7a6561cd9a2",
        "dataset_index": 2062
      },
      "arbiter_2_masters_9510d099": {
        "rtl_code": "\n\nmodule arbiter_2_masters (\n  input           clk,\n  input           rst,\n\n  input           i_m0_we,\n  input           i_m0_cyc,\n  input           i_m0_stb,\n  input   [3:0]   i_m0_sel,\n  output          o_m0_ack,\n  input   [31:0]  i_m0_dat,\n  output  [31:0]  o_m0_dat,\n  input   [31:0]  i_m0_adr,\n  output          o_m0_int,\n\n  input           i_m1_we,\n  input           i_m1_cyc,\n  input           i_m1_stb,\n  input   [3:0]   i_m1_sel,\n  output          o_m1_ack,\n  input   [31:0]  i_m1_dat,\n  output  [31:0]  o_m1_dat,\n  input   [31:0]  i_m1_adr,\n  output          o_m1_int,\n\n\n  output          o_s_we,\n  output          o_s_stb,\n  output          o_s_cyc,\n  output  [3:0]   o_s_sel,\n  output  [31:0]  o_s_adr,\n  output  [31:0]  o_s_dat,\n  input   [31:0]  i_s_dat,\n  input           i_s_ack,\n  input           i_s_int\n);\n\nlocalparam        MASTER_COUNT = 2;\n\nreg [7:0]         master_select;\nreg [7:0]         priority_select;\n\n\nwire              o_master_we  [MASTER_COUNT - 1:0];\nwire              o_master_stb [MASTER_COUNT - 1:0];\nwire              o_master_cyc [MASTER_COUNT - 1:0];\nwire  [3:0]       o_master_sel [MASTER_COUNT - 1:0];\nwire  [31:0]      o_master_adr [MASTER_COUNT - 1:0];\nwire  [31:0]      o_master_dat [MASTER_COUNT - 1:0];\n\n\nlocalparam        MASTER_NO_SEL   = 8'hFF;\nlocalparam        MASTER_0     = 0;\nlocalparam        MASTER_1     = 1;\n\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    master_select <= MASTER_NO_SEL;\n  end\n  else begin\n    case (master_select)\n      MASTER_0: begin\n        if (~i_m0_cyc && ~i_s_ack) begin\n          master_select <= MASTER_NO_SEL;\n        end\n      end\n      MASTER_1: begin\n        if (~i_m1_cyc && ~i_s_ack) begin\n          master_select <= MASTER_NO_SEL;\n        end\n      end\n      default: begin\n        if (i_m0_cyc) begin\n          master_select <= MASTER_0;\n        end\n        else if (i_m1_cyc) begin\n          master_select <= MASTER_1;\n        end\n      end\n    endcase\n    if ((master_select != MASTER_NO_SEL) && (priority_select < master_select) && (!o_s_stb && !i_s_ack))begin\n      master_select  <=  MASTER_NO_SEL;\n    end\n  end\nend\n\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    priority_select <= MASTER_NO_SEL;\n  end\n  else begin\n    if (i_m0_cyc) begin\n      priority_select  <= MASTER_0;\n    end\n    else if (i_m1_cyc) begin\n      priority_select  <= MASTER_1;\n    end\n    else begin\n      priority_select  <= MASTER_NO_SEL;\n    end\n  end\nend\n\n\n\n\nassign  o_s_we  = (master_select != MASTER_NO_SEL) ? o_master_we[master_select]  : 0;\nassign  o_s_stb = (master_select != MASTER_NO_SEL) ? o_master_stb[master_select] : 0;\nassign  o_s_cyc = (master_select != MASTER_NO_SEL) ? o_master_cyc[master_select] : 0;\nassign  o_s_sel = (master_select != MASTER_NO_SEL) ? o_master_sel[master_select] : 0;\nassign  o_s_adr = (master_select != MASTER_NO_SEL) ? o_master_adr[master_select] : 0;\nassign  o_s_dat = (master_select != MASTER_NO_SEL) ? o_master_dat[master_select] : 0;\n\n\nassign o_master_we[MASTER_0] = i_m0_we;\nassign o_master_we[MASTER_1] = i_m1_we;\n\n\n\nassign o_master_stb[MASTER_0] = i_m0_stb;\nassign o_master_stb[MASTER_1] = i_m1_stb;\n\n\n\nassign o_master_cyc[MASTER_0] = i_m0_cyc;\nassign o_master_cyc[MASTER_1] = i_m1_cyc;\n\n\n\nassign o_master_sel[MASTER_0] = i_m0_sel;\nassign o_master_sel[MASTER_1] = i_m1_sel;\n\n\n\nassign o_master_adr[MASTER_0] = i_m0_adr;\nassign o_master_adr[MASTER_1] = i_m1_adr;\n\n\n\nassign o_master_dat[MASTER_0] = i_m0_dat;\nassign o_master_dat[MASTER_1] = i_m1_dat;\n\n\n\n\nassign o_m0_ack = (master_select == MASTER_0) ? i_s_ack : 0;\nassign o_m0_dat = i_s_dat;\nassign o_m0_int = (master_select == MASTER_0) ? i_s_int : 0;\n\nassign o_m1_ack = (master_select == MASTER_1) ? i_s_ack : 0;\nassign o_m1_dat = i_s_dat;\nassign o_m1_int = (master_select == MASTER_1) ? i_s_int : 0;\n\n\n\nendmodule\n",
        "module_name": "arbiter_2_masters",
        "module_hash": "9510d099c25d1a35d2cfba9c07bbb109",
        "dataset_index": 25734
      },
      "delay__c1efc5e1": {
        "rtl_code": "module delay_module (\n    input clk,\n    input reset,\n    input in_signal,\n    output reg out_signal\n);\n\n    reg [2:0] buffer [0:2];\n\n    always @(posedge clk) begin\n        if (reset) begin\n            buffer[0] <= 1'b0;\n            buffer[1] <= 1'b0;\n            buffer[2] <= 1'b0;\n            out_signal <= 1'b0;\n        end else begin\n            buffer[0] <= in_signal;\n            buffer[1] <= buffer[0];\n            buffer[2] <= buffer[1];\n            out_signal <= buffer[2];\n        end\n    end\n\nendmodule",
        "module_name": "delay_",
        "module_hash": "c1efc5e160bfea491cb4a421d606cc7b",
        "dataset_index": 8461
      },
      "shifter_a94c99bd": {
        "rtl_code": "\nmodule shifter (\n    input [3:0] data_in,\n    input select,\n    output [4:0] data_out\n);\n\n    assign data_out = select ? {data_in[3], data_in[2:0]} : {data_in[1:0], data_in[3:2]};\n    \nendmodule\nmodule next_power_of_two (\n    input [4:0] data_in,\n    output [4:0] data_out\n);\n\n    assign data_out = (data_in == 5'b00001) ? 5'b00010 :\n                      (data_in <= 5'b00010) ? 5'b00100 :\n                      (data_in <= 5'b00100) ? 5'b01000 :\n                      (data_in <= 5'b01000) ? 5'b10000 :\n                      5'b10000;\n    \nendmodule\nmodule top_module (\n    input [3:0] data,\n    input rotate,\n    input select,\n    output [4:0] result\n);\n\n    wire [4:0] shifted_data;\n    wire [4:0] next_power;\n    \n    shifter shifter_inst (\n        .data_in(data),\n        .select(rotate),\n        .data_out(shifted_data)\n    );\n    \n    next_power_of_two next_power_inst (\n        .data_in(shifted_data),\n        .data_out(next_power)\n    );\n    \n    assign result = next_power;\n    \nendmodule",
        "module_name": "shifter",
        "module_hash": "a94c99bdd557ba26f419afdb8c2135fb",
        "dataset_index": 2479
      },
      "simpleuart_8787b4fc": {
        "rtl_code": "\n\nmodule simpleuart (\n\tinput clk,\n\tinput resetn,\n\n\toutput ser_tx,\n\tinput  ser_rx,\n\n\tinput   [3:0] reg_div_we,\n\tinput  [31:0] reg_div_di,\n\toutput [31:0] reg_div_do,\n\n\tinput         reg_dat_we,\n\tinput         reg_dat_re,\n\tinput  [31:0] reg_dat_di,\n\toutput [31:0] reg_dat_do,\n\toutput        reg_dat_wait\n);\n\treg [31:0] cfg_divider;\n\n\treg [3:0] recv_state;\n\treg [31:0] recv_divcnt;\n\treg [7:0] recv_pattern;\n\treg [7:0] recv_buf_data;\n\treg recv_buf_valid;\n\n\treg [9:0] send_pattern;\n\treg [3:0] send_bitcnt;\n\treg [31:0] send_divcnt;\n\treg send_dummy;\n\n\tassign reg_div_do = cfg_divider;\n\n\tassign reg_dat_wait = reg_dat_we && (send_bitcnt || send_dummy);\n\tassign reg_dat_do = recv_buf_valid ? recv_buf_data : ~0;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tcfg_divider <= 1;\n\t\tend else begin\n\t\t\tif (reg_div_we[0]) cfg_divider[ 7: 0] <= reg_div_di[ 7: 0];\n\t\t\tif (reg_div_we[1]) cfg_divider[15: 8] <= reg_div_di[15: 8];\n\t\t\tif (reg_div_we[2]) cfg_divider[23:16] <= reg_div_di[23:16];\n\t\t\tif (reg_div_we[3]) cfg_divider[31:24] <= reg_div_di[31:24];\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\trecv_state <= 0;\n\t\t\trecv_divcnt <= 0;\n\t\t\trecv_pattern <= 0;\n\t\t\trecv_buf_data <= 0;\n\t\t\trecv_buf_valid <= 0;\n\t\tend else begin\n\t\t\trecv_divcnt <= recv_divcnt + 1;\n\t\t\tif (reg_dat_re)\n\t\t\t\trecv_buf_valid <= 0;\n\t\t\tcase (recv_state)\n\t\t\t\t0: begin\n\t\t\t\t\tif (!ser_rx)\n\t\t\t\t\t\trecv_state <= 1;\n\t\t\t\t\trecv_divcnt <= 0;\n\t\t\t\tend\n\t\t\t\t1: begin\n\t\t\t\t\tif (2*recv_divcnt > cfg_divider) begin\n\t\t\t\t\t\trecv_state <= 2;\n\t\t\t\t\t\trecv_divcnt <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t10: begin\n\t\t\t\t\tif (recv_divcnt > cfg_divider) begin\n\t\t\t\t\t\trecv_buf_data <= recv_pattern;\n\t\t\t\t\t\trecv_buf_valid <= 1;\n\t\t\t\t\t\trecv_state <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tif (recv_divcnt > cfg_divider) begin\n\t\t\t\t\t\trecv_pattern <= {ser_rx, recv_pattern[7:1]};\n\t\t\t\t\t\trecv_state <= recv_state + 1;\n\t\t\t\t\t\trecv_divcnt <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign ser_tx = send_pattern[0];\n\n\talways @(posedge clk) begin\n\t\tif (reg_div_we)\n\t\t\tsend_dummy <= 1;\n\t\tsend_divcnt <= send_divcnt + 1;\n\t\tif (!resetn) begin\n\t\t\tsend_pattern <= ~0;\n\t\t\tsend_bitcnt <= 0;\n\t\t\tsend_divcnt <= 0;\n\t\t\tsend_dummy <= 1;\n\t\tend else begin\n\t\t\tif (send_dummy && !send_bitcnt) begin\n\t\t\t\tsend_pattern <= ~0;\n\t\t\t\tsend_bitcnt <= 15;\n\t\t\t\tsend_divcnt <= 0;\n\t\t\t\tsend_dummy <= 0;\n\t\t\tend else\n\t\t\tif (reg_dat_we && !send_bitcnt) begin\n\t\t\t\tsend_pattern <= {1'b1, reg_dat_di[7:0], 1'b0};\n\t\t\t\tsend_bitcnt <= 10;\n\t\t\t\tsend_divcnt <= 0;\n\t\t\tend else\n\t\t\tif (send_divcnt > cfg_divider && send_bitcnt) begin\n\t\t\t\tsend_pattern <= {1'b1, send_pattern[9:1]};\n\t\t\t\tsend_bitcnt <= send_bitcnt - 1;\n\t\t\t\tsend_divcnt <= 0;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n",
        "module_name": "simpleuart",
        "module_hash": "8787b4fc0b6ee6205ce9d121e5719543",
        "dataset_index": 24032
      },
      "top__cd95f180": {
        "rtl_code": "module top_module (\n    input [31:0] a,\n    input [31:0] b,\n    input [7:0] ctrl,\n    output [31:0] result,\n    output overflow\n);\n\nwire [31:0] alu_output;\nwire [7:0] adder_output;\nwire overflow_adder;\n\n// Instantiate 32-bit ALU\nalu_32bit alu_inst (\n    .a(a),\n    .b(b),\n    .ctrl(ctrl[3:0]),\n    .result(alu_output)\n);\n\n// Instantiate 8-bit adder/subtractor\nadder_subtractor_8bit adder_inst (\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .ctrl(ctrl[7]),\n    .result(adder_output),\n    .overflow(overflow_adder)\n);\n\n// Bitwise AND operation\nassign result = alu_output & {24'b0, adder_output};\nassign overflow = overflow_adder;\n\nendmodule\n\nmodule alu_32bit (\n    input [31:0] a,\n    input [31:0] b,\n    input [3:0] ctrl,\n    output [31:0] result\n);\n\nreg [31:0] result_reg;\n\nalways @(*) begin\n    case(ctrl)\n        4'b0000: result_reg = a + b;\n        4'b0001: result_reg = a - b;\n        4'b0010: result_reg = a & b;\n        4'b0011: result_reg = a | b;\n        4'b0100: result_reg = a ^ b;\n        4'b0101: result_reg = a << 1;\n        4'b0110: result_reg = a >> 1;\n        default: result_reg = 32'b0;\n    endcase\nend\n\nassign result = result_reg;\n\nendmodule\n\nmodule adder_subtractor_8bit (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output [7:0] result,\n    output overflow\n);\n\nreg [7:0] result_reg;\nreg overflow_reg;\n\nalways @(*) begin\n    if (ctrl) begin\n        result_reg = a - b;\n        overflow_reg = (a[7] & ~b[7] & result_reg[7]) | (~a[7] & b[7] & ~result_reg[7]);\n    end else begin\n        result_reg = a + b;\n        overflow_reg = (a[7] & b[7] & ~result_reg[7]) | (~a[7] & ~b[7] & result_reg[7]);\n    end\nend\n\nassign result = result_reg;\nassign overflow = overflow_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "cd95f180dcbd56f6fbe8e0dd7ab712f3",
        "dataset_index": 2455
      },
      "reg_read_b6536de4": {
        "rtl_code": "module reg_read(in, readAdd1, readAdd2, regValue1, regValue2, equalValue, write, writeAdd, writeR7, inR7, clk, reset);\n\n\toutput [15:0] regValue1, regValue2;\n\toutput \t      equalValue;\n\tinput  [15:0] in, inR7;\n\tinput  [2:0]  readAdd1, readAdd2, writeAdd;\n\tinput\t      write, writeR7, clk, reset;\n\t\n\tregister_file rfile(.clk(clk), .out1(regValue1), .out2(regValue2), .readAdd1(readAdd1), .readAdd2(readAdd2), .write(write), .writeAdd(writeAdd), .writeR7(writeR7), .inR7(inR7), .in(in), .reset(reset));\n\tequal eqCheck(.in1(regValue1), .in2(regValue2), .out(equalValue));\n\nendmodule\n\nmodule register_file(clk, out1, out2, readAdd1, readAdd2, write, writeAdd, writeR7, inR7, in, reset); output [15:0] out1, out2;\n\tinput  [15:0] in, inR7;\n\tinput  [2:0]  readAdd1, readAdd2, writeAdd;\n\tinput         write, clk, reset, writeR7;\n\t\n\twire   [15:0] data0,  data1,  data2,  data3,  data4,  data5,  data6,  data7;\n\twire   [7:0]  writeLinesInit, writeLines;\n\t\n\tdecode8 dem(writeAdd, writeLinesInit);\n\tmux16x8 mux1(data0, data1, data2, data3, data4, data5, data6, data7, readAdd1, out1);\n\tmux16x8 mux2(data0, data1, data2, data3, data4, data5, data6, data7, readAdd2, out2);\n\t\n\tor a0(writeLines[0], write, ~writeLinesInit[0]);\n\tor a1(writeLines[1], write, ~writeLinesInit[1]);\n\tor a2(writeLines[2], write, ~writeLinesInit[2]);\n\tor a3(writeLines[3], write, ~writeLinesInit[3]);\n\tor a4(writeLines[4], write, ~writeLinesInit[4]);\n\tor a5(writeLines[5], write, ~writeLinesInit[5]);\n\tor a6(writeLines[6], write, ~writeLinesInit[6]);\n\tor a7(writeLines[7], writeR7, ~writeLinesInit[7]);\n\t\n\tregister16 r0(clk, data0, in, writeLines[0], reset);\n\tregister16 r1(clk, data1, in, writeLines[1], reset);\n\tregister16 r2(clk, data2, in, writeLines[2], reset);\n\tregister16 r3(clk, data3, in, writeLines[3], reset);\n\tregister16 r4(clk, data4, in, writeLines[4], reset);\n\tregister16 r5(clk, data5, in, writeLines[5], reset);\n\tregister16 r6(clk, data6, in, writeLines[6], reset);\n\tregister16 r7(clk, data7, inR7, writeLines[7], reset);\n\tendmodule\n\nmodule equal(in1, in2, out);\n\t\n\toutput out;\n\tinput [15:0] in1, in2;\n\t\n\tassign out = (in1==in2);\n\t\nendmodule\n\nmodule decode8(selectInput, out);  output reg [7:0] out;\n\tinput  [2:0] selectInput;\n\t\n\talways@(selectInput) begin\n\t\tcase(selectInput)\n\t\t\t0: out = 8'b00000001;\n\t\t\t1: out = 8'b00000010;\n\t\t\t2: out = 8'b00000100;\n\t\t\t3: out = 8'b00001000;\n\t\t\t4: out = 8'b00010000;\n\t\t\t5: out = 8'b00100000;\n\t\t\t6: out = 8'b01000000;\n\t\t\t7: out = 8'b10000000;\n\t\tendcase\n\tend\n\t\nendmodule\n\nmodule mux16x8(data0, data1, data2, data3, data4, data5, data6, data7, selectInput, out);  output reg [15:0] out;\n\tinput  [15:0] data0, data1, data2, data3, data4, data5, data6, data7;\n\tinput  [2:0] selectInput;\n\t\n\talways@(data0 or data1 or data2 or data3 or data4 or data5 or data6 or data7 or selectInput) begin\n\t\tcase(selectInput)\n\t\t\t0: out = data0;\n\t\t\t1: out = data1;\n\t\t\t2: out = data2;\n\t\t\t3: out = data3;\n\t\t\t4: out = data4;\n\t\t\t5: out = data5;\n\t\t\t6: out = data6;\n\t\t\t7: out = data7;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule mux16x4(data0, data1, data2, data3, selectInput, out);  output reg [15:0] out;\n\tinput  [15:0] data0, data1, data2, data3;\n\tinput  [1:0] selectInput;\n\t\n\talways@(data0 or data1 or data2 or data3 or selectInput) begin\n\t\tcase(selectInput)\n\t\t\t0: out = data0;\n\t\t\t1: out = data1;\n\t\t\t2: out = data2;\n\t\t\t3: out = data3;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule mux16x2(data0, data1, selectInput, out);  output reg [15:0] out;\n\tinput  [15:0] data0, data1;\n\tinput  selectInput;\n\t\n\talways@(data0 or data1 or selectInput) begin\n\t\tcase(selectInput)\n\t\t\t0: out = data0;\n\t\t\t1: out = data1;\n\t\tendcase\n\tend\n\t\nendmodule\n\nmodule register16(clk, out, in, write, reset);  output reg [15:0] out;\n\tinput      [15:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 16'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register3(clk, out, in, write, reset);  output reg [2:0] out;\n\tinput      [2:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 3'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register2(clk, out, in, write, reset);  output reg [1:0] out;\n\tinput      [1:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 2'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register1(clk, out, in, write, reset);  output reg out;\n\tinput      in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 1'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule",
        "module_name": "reg_read",
        "module_hash": "b6536de42fbf5f42c399fcee3bebca80",
        "dataset_index": 11689
      },
      "password_protected_system_ac3feae7": {
        "rtl_code": "\nmodule password_protected_system (\n    input clk,\n    input d,\n    input [255:0] password,\n    input [2:0] sel,\n    output out\n);\n\n    // Define the shift register\n    reg [2:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n    end\n\n    // Define the multiplexer for the shift register\n    wire [2:0] shift_mux_sel = {1'b0, sel[1:0]};\n    wire shift_mux_out;\n    assign shift_mux_out = shift_reg[shift_mux_sel];\n\n    // Define the multiplexer for the password\n    wire [7:0] password_mux_sel = {1'b0, sel[1:0]};\n    wire [2:0] password_mux_out;\n    assign password_mux_out = password[password_mux_sel];\n\n    // Define the comparator\n    wire [2:0] comparator_out;\n    assign comparator_out = (shift_mux_out == password_mux_out);\n\n    // Generate the shifted password\n    wire [255:0] shifted_password = password;\n    wire [2:0] constant_sel = 3'b0;\n    wire [7:0] shifted_password_mux_sel = {1'b0, constant_sel[1:0]};\n    wire [2:0] shifted_password_mux_out;\n    assign shifted_password_mux_out = shifted_password[shifted_password_mux_sel];\n\n    // Define the AND gate\n    assign out = (comparator_out & shifted_password_mux_out);\n\nendmodule\n",
        "module_name": "password_protected_system",
        "module_hash": "ac3feae79c70b5056afcd30d1a73d515",
        "dataset_index": 15467
      },
      "top__026c537d": {
        "rtl_code": "\nmodule top_module (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] control,\n    output reg [15:0] result,\n    output reg valid\n);\n\n    wire [15:0] shifted_data;\n    wire [3:0] alu_result;\n    wire [15:0] and_result;\n\n    // Instantiate barrel shifter module\n    barrel_shifter_16bit shifter(\n        .data_in(A),\n        .shift_amount(control[2:0]),\n        .mode(control[3]),\n        .shifted_out(shifted_data)\n    );\n\n    // Instantiate ALU module\n    alu alu_inst(\n        .A(B[3:0]),\n        .B(B[7:4]),\n        .op(control[1:0]),\n        .result(alu_result),\n        .valid(valid)\n    );\n\n    // Perform bitwise AND operation on shifted data and ALU result\n    assign and_result = shifted_data & alu_result;\n\n    // Assign result output\n    always @(*) begin\n        case(control[3:0])\n            4'b0000: result = A; // Pass through A\n            4'b0001: result = B; // Pass through B\n            4'b0010: result = A + B; // Add A and B\n            4'b0011: result = A - B; // Subtract B from A\n            4'b0100: result = shifted_data; // Output shifted data\n            4'b0101: result = alu_result; // Output ALU result\n            4'b0110: result = A & B; // Bitwise AND of A and B\n            4'b0111: result = A | B; // Bitwise OR of A and B\n            4'b1000: result = and_result; // Output AND result\n            default: result = 16'h0000; // Default to 0\n        endcase\n    end\n\nendmodule\nmodule barrel_shifter_16bit (\n    input [15:0] data_in,\n    input [2:0] shift_amount,\n    input mode,\n    output [15:0] shifted_out\n);\n    reg [15:0] shifted_data;\n\n    always @(*) begin\n        case(shift_amount)\n            3'b000: shifted_data = data_in; // No shift\n            3'b001: shifted_data = data_in << 1; // Shift left by 1\n            3'b010: shifted_data = data_in << 2; // Shift left by 2\n            3'b011: shifted_data = data_in << 3; // Shift left by 3\n            3'b100: shifted_data = data_in << 4; // Shift left by 4\n            3'b101: shifted_data = data_in << 5; // Shift left by 5\n            3'b110: shifted_data = data_in << 6; // Shift left by 6\n            3'b111: shifted_data = data_in << 7; // Shift left by 7\n            default: shifted_data = data_in; // Default to original data\n        endcase\n    end\n\n    assign shifted_out = mode ? shifted_data : data_in; // Output shifted data or original data based on mode input\n\nendmodule\nmodule alu (\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] op,\n    output reg [3:0] result,\n    output reg valid\n);\n    always @(*) begin\n        case(op)\n            2'b00: result = A & B; // Bitwise AND\n            2'b01: result = A | B; // Bitwise OR\n            2'b10: result = A + B; // Addition\n            2'b11: result = A - B; // Subtraction\n            default: result = 4'h0; // Default to 0\n        endcase\n        valid = 1; // Output is always valid\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "026c537dd3b8709e0633996770645d46",
        "dataset_index": 10048
      },
      "calculator_34a1d033": {
        "rtl_code": "\nmodule calculator(\n    input wire clk,\n    input wire reset,\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire [1:0] op,\n    output reg [7:0] result,\n    output reg valid\n);\n\nreg [15:0] temp_result; // Used for multiplication and division\n\nalways @ (posedge clk) begin\n    if (reset) begin\n        result <= 8'b0;\n        valid <= 1'b0;\n    end else begin\n        case (op)\n            2'b00: begin // Addition\n                temp_result <= a + b;\n                result <= temp_result[7:0];\n                valid <= 1'b1;\n            end\n            2'b01: begin // Subtraction\n                temp_result <= a - b;\n                result <= temp_result[7:0];\n                valid <= 1'b1;\n            end\n            2'b10: begin // Multiplication\n                temp_result <= a * b;\n                result <= temp_result[15:8];\n                valid <= 1'b1;\n            end\n            2'b11: begin // Division\n                if (b == 0) begin\n                    result <= 8'b0;\n                    valid <= 1'b0;\n                end else begin\n                    temp_result <= a / b;\n                    result <= temp_result[7:0];\n                    valid <= 1'b1;\n                end\n            end\n            default: begin // Invalid operation\n                result <= 8'b0;\n                valid <= 1'b0;\n            end\n        endcase\n    end\nend\n\nendmodule\n",
        "module_name": "calculator",
        "module_hash": "34a1d033616436a40ead84721598ca9a",
        "dataset_index": 17246
      },
      "ad_rst_73a7ea42": {
        "rtl_code": "\n\nmodule ad_rst (\n\n  preset,\n  clk,\n  rst);\n\n  input           preset;\n  input           clk;\n  output          rst;\n\n  reg             ad_rst_sync_m1 = 'd0 ;\n  reg             ad_rst_sync = 'd0 ;\n  reg             rst = 'd0;\n\n  always @(posedge clk) begin\n    ad_rst_sync_m1 <= preset;\n    ad_rst_sync <= ad_rst_sync_m1;\n    rst <= ad_rst_sync;\n  end\n\nendmodule\n\n",
        "module_name": "ad_rst",
        "module_hash": "73a7ea42dd6ee888678ab1e32254c433",
        "dataset_index": 22916
      },
      "pipelined_mux_abb77936": {
        "rtl_code": "\nmodule pipelined_mux(\n    input [7:0] in,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\n// Stage 1\nalways @(*) begin\n    case (sel[0])\n        1'b0: stage1_out = in[1:0];\n        1'b1: stage1_out = in[3:2];\n        default: stage1_out = in[5:4];\n    endcase\nend\n\n// Stage 2\nalways @(*) begin\n    case (sel[1])\n        1'b0: stage2_out = stage1_out[1:0];\n        1'b1: stage2_out = stage1_out[3:2];\n        default: stage2_out = stage1_out[3:2];\n    endcase\nend\n\n// Output\nalways @(*) begin\n    out = stage2_out;\nend\n\nendmodule\n\nmodule mux2to1(\n    input a,\n    input b,\n    input sel,\n    output reg out\n);\n\nalways @(*) begin\n    out = sel ? b : a;\nend\n\nendmodule\n",
        "module_name": "pipelined_mux",
        "module_hash": "abb77936222d6e0fa798057f17d1fb72",
        "dataset_index": 1910
      },
      "mig_7series_v2_3_poc_meta #_3bbb8971": {
        "rtl_code": "\n\nmodule mig_7series_v2_3_poc_meta #\n  (parameter SCANFROMRIGHT              = 0,\n   parameter TCQ                        = 100,\n   parameter TAPCNTRWIDTH               = 7,\n   parameter TAPSPERKCLK                = 112)\n  (\n  mmcm_edge_detect_done, poc_backup, mmcm_lbclk_edge_aligned,\n  rst, clk, mmcm_edge_detect_rdy, run, run_polarity, run_end,\n  rise_lead_right, rise_trail_left, rise_lead_center,\n  rise_trail_center, rise_trail_right, rise_lead_left, ninety_offsets,\n  use_noise_window, ktap_at_right_edge, ktap_at_left_edge\n  );\n\n  localparam NINETY = TAPSPERKCLK/4;\n  \n  function [TAPCNTRWIDTH-1:0] offset (input [TAPCNTRWIDTH-1:0] a, \n                                      input [1:0] b,\n                                      input integer base);\n    integer offset_ii;\n    begin\n      offset_ii = (a + b * NINETY) < base\n                     ? (a + b * NINETY) \n                     : (a + b * NINETY - base);\n      offset = offset_ii[TAPCNTRWIDTH-1:0];\n    end\n  endfunction function [TAPCNTRWIDTH-1:0] mod_sub (input [TAPCNTRWIDTH-1:0] a, \n                                       input [TAPCNTRWIDTH-1:0] b,\n                                       input integer base); \n    begin\n      mod_sub = (a>=b) ? a-b : a+base-b;\n    end\n  endfunction function [TAPCNTRWIDTH:0] center (input [TAPCNTRWIDTH-1:0] left, \n                                    input [TAPCNTRWIDTH-1:0] diff,\n                                    input integer base);\n    integer center_ii;\n    begin\n      center_ii = ({left, 1'b0} + diff < base * 2)\n                    ? {left, 1'b0} + diff + 32'h0\n\t            : {left, 1'b0} + diff - base * 2;\n      center = center_ii[TAPCNTRWIDTH:0];\n    end\n  endfunction input rst;\n  input clk;\n\n\n  input mmcm_edge_detect_rdy;\n\n  wire reset_run_ends = rst || ~mmcm_edge_detect_rdy;\n\n  input [TAPCNTRWIDTH-1:0] run;\n  \n  input run_end;\n  reg run_end_r, run_end_r1, run_end_r2, run_end_r3;\n  always @(posedge clk) run_end_r <= #TCQ run_end;\n  always @(posedge clk) run_end_r1 <= #TCQ run_end_r;\n  always @(posedge clk) run_end_r2 <= #TCQ run_end_r1;\n  always @(posedge clk) run_end_r3 <= #TCQ run_end_r2;\n\n  input run_polarity;\n  reg run_polarity_held_ns, run_polarity_held_r;\n  always @(posedge clk) run_polarity_held_r <= #TCQ run_polarity_held_ns;\n  always @(*) run_polarity_held_ns = run_end ? run_polarity : run_polarity_held_r;\n  \n  reg [1:0] run_ends_r;\n  reg [1:0] run_ends_ns;\n  always @(posedge clk) run_ends_r <= #TCQ run_ends_ns;\n  always @(*) begin\n    run_ends_ns = run_ends_r;\n    if (reset_run_ends) run_ends_ns = 2'b0;\n    else case (run_ends_r) \n           2'b00 : run_ends_ns = run_ends_r + {1'b0, run_end_r3 && run_polarity_held_r};\n\t   2'b01, 2'b10 : run_ends_ns = run_ends_r + {1'b0, run_end_r3};\n\t  endcase end\n\n  reg done_r;\n  wire done_ns = mmcm_edge_detect_rdy && &run_ends_r;\n  always @(posedge clk) done_r <= #TCQ done_ns;\n  output mmcm_edge_detect_done;\n  assign mmcm_edge_detect_done = done_r;  \n\n  input [TAPCNTRWIDTH-1:0] rise_lead_right;\n  input [TAPCNTRWIDTH-1:0] rise_trail_left;\n  input [TAPCNTRWIDTH-1:0] rise_lead_center;\n  input [TAPCNTRWIDTH-1:0] rise_trail_center;\n  input [TAPCNTRWIDTH-1:0] rise_trail_right;\n  input [TAPCNTRWIDTH-1:0] rise_lead_left;\n\n  input [1:0] ninety_offsets;\n  wire [1:0] offsets = SCANFROMRIGHT == 1 ? ninety_offsets : 2'b00 - ninety_offsets;\n\n  wire [TAPCNTRWIDTH-1:0] rise_lead_center_offset_ns = offset(rise_lead_center, offsets, TAPSPERKCLK);\n  wire [TAPCNTRWIDTH-1:0] rise_trail_center_offset_ns = offset(rise_trail_center, offsets, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] rise_lead_center_offset_r, rise_trail_center_offset_r;\n  always @(posedge clk) rise_lead_center_offset_r <= #TCQ rise_lead_center_offset_ns;\n  always @(posedge clk) rise_trail_center_offset_r <= #TCQ rise_trail_center_offset_ns;\n\n  wire [TAPCNTRWIDTH-1:0] edge_diff_ns = mod_sub(rise_trail_center_offset_r, rise_lead_center_offset_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] edge_diff_r;\n  always @(posedge clk) edge_diff_r <= #TCQ edge_diff_ns;\n  \n  wire [TAPCNTRWIDTH:0] edge_center_ns = center(rise_lead_center_offset_r, edge_diff_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH:0] edge_center_r;\n  always @(posedge clk) edge_center_r <= #TCQ edge_center_ns;\n\n  input use_noise_window;\n  wire [TAPCNTRWIDTH-1:0] left = use_noise_window ? rise_lead_left : rise_trail_left;\n  wire [TAPCNTRWIDTH-1:0] right = use_noise_window ? rise_trail_right : rise_lead_right;\n\n  wire [TAPCNTRWIDTH-1:0] center_diff_ns = mod_sub(right, left, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] center_diff_r;\n  always @(posedge clk) center_diff_r <= #TCQ center_diff_ns;\n  \n  wire [TAPCNTRWIDTH:0] window_center_ns = center(left, center_diff_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH:0] window_center_r;\n  always @(posedge clk) window_center_r <= #TCQ window_center_ns;\n\n  localparam TAPSPERKCLKX2 = TAPSPERKCLK * 2;\n\n  wire [TAPCNTRWIDTH+1:0] left_center = {1'b0, SCANFROMRIGHT == 1 ? window_center_r : edge_center_r};\n  wire [TAPCNTRWIDTH+1:0] right_center = {1'b0, SCANFROMRIGHT == 1 ? edge_center_r : window_center_r};\n\t\t\t  \n  wire [TAPCNTRWIDTH+1:0] diff_ns = right_center >= left_center\n                                     ? right_center - left_center\n                                     : right_center + TAPSPERKCLKX2[TAPCNTRWIDTH+1:0] - left_center;\n  \n  reg [TAPCNTRWIDTH+1:0] diff_r;\n  always @(posedge clk) diff_r <= #TCQ diff_ns;\n\n  wire [TAPCNTRWIDTH+1:0] abs_diff = diff_r > TAPSPERKCLKX2[TAPCNTRWIDTH+1:0]/2\n                                       ? TAPSPERKCLKX2[TAPCNTRWIDTH+1:0] - diff_r\n                                       : diff_r;\n\n  reg [TAPCNTRWIDTH+1:0] prev_ns, prev_r;\n  always @(posedge clk) prev_r <= #TCQ prev_ns;\n  always @(*) prev_ns = done_ns ? diff_r : prev_r;\n\n  input ktap_at_right_edge;\n  input ktap_at_left_edge;\n  \n  wire centering = !(ktap_at_right_edge || ktap_at_left_edge);\n  wire diffs_eq = abs_diff == diff_r;\n  reg diffs_eq_ns, diffs_eq_r;\n  always @(*) diffs_eq_ns = centering && ((done_r && done_ns) ? diffs_eq : diffs_eq_r);\n  always @(posedge clk) diffs_eq_r <= #TCQ diffs_eq_ns;\n\n  reg edge_aligned_r;\n  reg prev_valid_ns, prev_valid_r;\n  always @(posedge clk) prev_valid_r <= #TCQ prev_valid_ns;\n  always @(*) prev_valid_ns = (~rst && ~ktap_at_right_edge && ~ktap_at_left_edge && ~edge_aligned_r) && prev_valid_r | done_ns;\n\n  wire indicate_alignment = ~rst && centering && done_ns;\n  wire edge_aligned_ns = indicate_alignment && (~|diff_r || ~diffs_eq & diffs_eq_r);\n  always @(posedge clk) edge_aligned_r <= #TCQ edge_aligned_ns;\n\n  reg poc_backup_r;\n  wire poc_backup_ns = edge_aligned_ns && abs_diff > prev_r;\n  always @(posedge clk) poc_backup_r <= #TCQ poc_backup_ns;\n  output poc_backup;\n  assign poc_backup = poc_backup_r;\n\n  output mmcm_lbclk_edge_aligned;\n  assign mmcm_lbclk_edge_aligned = edge_aligned_r;\n  \nendmodule ",
        "module_name": "mig_7series_v2_3_poc_meta #",
        "module_hash": "3bbb897199f46faaf0776f8a266c1247",
        "dataset_index": 25861
      },
      "SensorFSM #_930bf3ea": {
        "rtl_code": "\n\nmodule SensorFSM #(\n  parameter DataWidth = 8\n) (\n  input                        Reset_n_i,\n  input                        Clk_i,\n  input                        Enable_i,\n  output reg                   CpuIntr_o,\n  output     [2*DataWidth-1:0] SensorValue_o,\n  output reg                   MeasureFSM_Start_o,\n  input                        MeasureFSM_Done_i,\n  input                        MeasureFSM_Error_i,\n  input     [DataWidth-1:0]    MeasureFSM_Byte0_i,\n  input     [DataWidth-1:0]    MeasureFSM_Byte1_i,\n  input [2*DataWidth-1:0]      ParamThreshold_i,\n  input [2*DataWidth-1:0]      ParamCounterPresetH_i,\n  input [2*DataWidth-1:0]      ParamCounterPresetL_i\n);\n\n  localparam stDisabled   = 3'b000;\n  localparam stIdle       = 3'b001;\n  localparam stXfer       = 3'b010;\n  localparam stNotify     = 3'b011;\n  localparam stError      = 3'b100;\n  reg  [2:0]             SensorFSM_State;\n  reg  [2:0]             SensorFSM_NextState;\n  wire                   SensorFSM_TimerOvfl;\n  reg                    SensorFSM_TimerPreset;\n  reg                    SensorFSM_TimerEnable;\n  wire                   SensorFSM_DiffTooLarge;\n  reg                    SensorFSM_StoreNewValue;\n  wire [2*DataWidth-1:0] SensorValue;\n  reg  [2*DataWidth-1:0] Word0;\n  wire [2*DataWidth-1:0] AbsDiffResult;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SensorFSM_State <= stDisabled;\n    end\n    else\n    begin\n      SensorFSM_State <= SensorFSM_NextState;\n    end  \n  end\n\n  always @(SensorFSM_State, Enable_i, SensorFSM_TimerOvfl, MeasureFSM_Done_i, MeasureFSM_Error_i, SensorFSM_DiffTooLarge)\n  begin  SensorFSM_NextState     = SensorFSM_State;\n    SensorFSM_TimerPreset   = 1'b1;\n    SensorFSM_TimerEnable   = 1'b0;\n    MeasureFSM_Start_o      = 1'b0;\n    SensorFSM_StoreNewValue = 1'b0;\n    CpuIntr_o               = 1'b0;\n    case (SensorFSM_State)\n      stDisabled: begin\n        if (Enable_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stIdle;\n          SensorFSM_TimerPreset   = 1'b0;\n          SensorFSM_TimerEnable   = 1'b1;  end\n      end\n      stIdle: begin\n        SensorFSM_TimerPreset   = 1'b0;\n        SensorFSM_TimerEnable   = 1'b1;  if (Enable_i == 1'b0)\n        begin\n          SensorFSM_NextState     = stDisabled;\n        end\n        else\n        if (SensorFSM_TimerOvfl == 1'b1)\n        begin\n          SensorFSM_NextState     = stXfer;\n          MeasureFSM_Start_o      = 1'b1;\n        end\n      end\n      stXfer: begin\n        if (MeasureFSM_Error_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stError;\n          CpuIntr_o               = 1'b1;  end\n        else if (MeasureFSM_Done_i == 1'b1)\n        begin\n          if (SensorFSM_DiffTooLarge == 1'b1)\n          begin\n            SensorFSM_NextState     = stNotify;\n            SensorFSM_TimerPreset   = 1'b0;\n            SensorFSM_TimerEnable   = 1'b1;  SensorFSM_StoreNewValue = 1'b1;  end\n          else\n          begin\n            SensorFSM_NextState     = stIdle;\n          end\n        end\n      end\n      stNotify: begin\n        SensorFSM_TimerPreset   = 1'b1;\n        SensorFSM_TimerEnable   = 1'b0;  SensorFSM_NextState     = stIdle;\n        CpuIntr_o               = 1'b1;  end\n      stError: begin\n        if (Enable_i == 1'b0)\n        begin\n          SensorFSM_NextState     = stDisabled;\n        end\n      end\n      default: begin\n      end\n    endcase\n  end \n\n  reg [31:0] SensorFSM_Timer;\n  \n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SensorFSM_Timer <= 32'd0;\n    end\n    else\n    begin\n      if (SensorFSM_TimerPreset)\n      begin\n        SensorFSM_Timer <= {ParamCounterPresetH_i, ParamCounterPresetL_i};\n      end\n      else if (SensorFSM_TimerEnable)\n      begin\n        SensorFSM_Timer <= SensorFSM_Timer - 1'b1;\n      end\n    end  \n  end\n\n  assign SensorFSM_TimerOvfl = (SensorFSM_Timer == 0) ? 1'b1 : 1'b0;\n\n  assign SensorValue = {MeasureFSM_Byte1_i, MeasureFSM_Byte0_i};\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Word0 <= 16'd0;\n    end\n    else\n    begin\n      if (SensorFSM_StoreNewValue)\n      begin\n        Word0 <= SensorValue;\n      end\n    end  \n  end\n\n  wire [2*DataWidth   : 0] DiffAB;\n  wire [2*DataWidth-1 : 0] DiffBA;\n  assign DiffAB = {1'b0, SensorValue} - {1'b0, Word0};\n  assign DiffBA =        Word0        -        SensorValue;\n  assign AbsDiffResult = DiffAB[2*DataWidth] ? DiffBA : DiffAB[2*DataWidth-1 : 0];\n\n  assign SensorFSM_DiffTooLarge = (AbsDiffResult > ParamThreshold_i) ? 1'b1 : 1'b0;\n\n  assign SensorValue_o = Word0;\n\nendmodule ",
        "module_name": "SensorFSM #",
        "module_hash": "930bf3ea790ceae1fa72aa4ec0276a4e",
        "dataset_index": 10806
      },
      "pcieInterface_b9d24562": {
        "rtl_code": "module pcieInterface(\n  input  wire        sys_clkp,     // System Clock +\n  input  wire        sys_clkn,     // System Clock -\n  input  wire        pci_clkp,     // PCIe Clock +\n  input  wire        pci_clkn,     // PCIe Clock -\n  input  wire        pci_reset_n,  // PCIe Reset\n  input  wire [7:0]  pci_rxp,      // PCIe receive lane positive\n  input  wire [7:0]  pci_rxn,      // PCIe receive lane negative\n  input  wire        pps_in,      // PPS input signal\n  output wire [7:0]  pci_txp,     // PCIe transmit lane positive\n  output wire [7:0]  pci_txn,     // PCIe transmit lane negative\n  output wire [2:0]  led,         // LED control signal\n  output wire        pps_out      // PPS output signal\n);\n\nreg [7:0] pci_txp_reg;\nreg [7:0] pci_txn_reg;\nreg [2:0] led_reg;\nreg        pps_out_reg;\n\nalways @(posedge sys_clkp) begin\n  // PPS output signal is synchronized to the system clock\n  pps_out_reg <= pps_in;\nend\n\nalways @(posedge pci_clkp) begin\n  if (!pci_reset_n) begin\n    // Reset all output signals\n    pci_txp_reg <= 8'b0;\n    pci_txn_reg <= 8'b0;\n    led_reg <= 3'b0;\n  end else begin\n    // Transmit received data\n    pci_txp_reg <= pci_rxp;\n    pci_txn_reg <= pci_rxn;\n    \n    // Control LEDs based on received data\n    case (pci_rxp[2:0])\n      3'b000: led_reg <= 3'b000;\n      3'b001: led_reg <= 3'b001;\n      3'b010: led_reg <= 3'b010;\n      3'b011: led_reg <= 3'b011;\n      3'b100: led_reg <= 3'b100;\n      3'b101: led_reg <= 3'b101;\n      3'b110: led_reg <= 3'b110;\n      3'b111: led_reg <= 3'b111;\n    endcase\n  end\nend\n\nassign pci_txp = pci_txp_reg;\nassign pci_txn = pci_txn_reg;\nassign led = led_reg;\nassign pps_out = pps_out_reg;\n\nendmodule",
        "module_name": "pcieInterface",
        "module_hash": "b9d2456288d2b087c967e38fef5d1aee",
        "dataset_index": 17432
      },
      "led_controller_62e972df": {
        "rtl_code": "module led_controller(\n    input SW_0,\n    input SW_1,\n    input SW_2,\n    input SW_3,\n    output LED_0,\n    output LED_1,\n    output LED_2,\n    output LED_3\n);\n\nreg LED_0_state;\nreg LED_1_state;\nreg LED_2_state;\nreg LED_3_state;\n\nalways @(*) begin\n    if (SW_0 == 0) LED_0_state = 1;\n    else LED_0_state = 0;\n    \n    if (SW_1 == 0) LED_1_state = 1;\n    else LED_1_state = 0;\n    \n    if (SW_2 == 0) LED_2_state = 1;\n    else LED_2_state = 0;\n    \n    if (SW_3 == 0) LED_3_state = 1;\n    else LED_3_state = 0;\nend\n\nassign LED_0 = LED_0_state;\nassign LED_1 = LED_1_state;\nassign LED_2 = LED_2_state;\nassign LED_3 = LED_3_state;\n\nendmodule",
        "module_name": "led_controller",
        "module_hash": "62e972dfb0b687ca02d11248deeca548",
        "dataset_index": 4562
      },
      "binary_counter_4322e4e5": {
        "rtl_code": "module binary_counter(clk, rst, count);\n  input clk, rst;\n  output reg [3:0] count;\n  \n  always @(posedge clk) begin\n    if(rst) begin\n      count <= 4'b0000;\n    end else if(count == 4'b1111) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "4322e4e5761e06128f04a31c95681c35",
        "dataset_index": 2612
      },
      "fifo_buffer #_1667323a": {
        "rtl_code": "\nmodule fifo_buffer #(\n  parameter DATA_WIDTH          = 32,\n  parameter FIFO_WIDTH          = 8\n)(\n  input                             rst,\n  input       [31:0]                test_id,\n\n  //write side\n  input                             WR_CLK,\n  output                            WR_RDY,\n  input                             WR_ACT,\n  output      [23:0]                WR_SIZE,\n  input                             WR_STB,\n  input       [DATA_WIDTH - 1: 0]   WR_DATA,\n  output                            WR_STARVED,\n\n  //read side\n  input                             RD_CLK,\n  input                             RD_STB,\n  output                            RD_RDY,\n  input                             RD_ACT,\n  output      [23:0]                RD_SIZE,\n  output      [DATA_WIDTH - 1: 0]   RD_DATA,\n\n  output                            RD_INACTIVE\n);\n\n//Local Parameters\nlocalparam ADDR_WIDTH = FIFO_WIDTH;\nlocalparam ADDR_MASK  = (1 << ADDR_WIDTH) - 1;\n\n//Registers/Wires\nreg       [ADDR_WIDTH-1:0] wr_ptr = 0;\nreg       [ADDR_WIDTH-1:0] rd_ptr = 0;\nreg       [ADDR_WIDTH-1:0] count = 0;\nreg                      wr_starved = 0;\nreg                      rd_inactive = 1;\nreg                      r_rst;\n\n//Submodules\nblock_mem #(\n  .DATA_WIDTH      (DATA_WIDTH),\n  .ADDRESS_WIDTH   (ADDR_WIDTH)\n) mem (\n  .clk             (WR_CLK),\n  .we              (WR_STB & WR_ACT & WR_RDY),\n  .addr            (wr_ptr),\n  .data            (WR_DATA),\n  .q               (),\n  .oe              (RD_STB & RD_ACT & RD_RDY),\n  .oe_addr         (rd_ptr),\n  .oe_data         (RD_DATA)\n);\n\n//Asynchronous Logic\nalways @ (*) r_rst = rst;\n\n//Synchronous Logic\nalways @(posedge WR_CLK) begin\n  if (r_rst) begin\n    wr_ptr <= 0;\n    rd_ptr <= 0;\n    count <= 0;\n    wr_starved <= 0;\n    rd_inactive <= 1;\n  end else begin\n    if (WR_STB & WR_ACT & WR_RDY) begin\n      wr_ptr <= wr_ptr + 1;\n      count <= count + 1;\n      rd_inactive <= 0;\n      if (count == ADDR_MASK + 1) begin\n        wr_starved <= 1;\n      end\n    end\n\n    if (RD_STB & RD_ACT & RD_RDY) begin\n      rd_ptr <= rd_ptr + 1;\n      count <= count - 1;\n      wr_starved <= 0;\n      if (count == 0) begin\n        rd_inactive <= 1;\n      end\n    end\n  end\nend\n\n//Output Mux\nassign WR_RDY = ~wr_starved;\nassign RD_RDY = ~rd_inactive;\nassign RD_INACTIVE = rd_inactive;\nassign WR_STARVED = wr_starved;\nassign WR_SIZE = ADDR_MASK + 1;\nassign RD_SIZE = ADDR_MASK + 1 - count;\n\nendmodule\nmodule block_mem #(\n  parameter DATA_WIDTH      = 32,\n  parameter ADDRESS_WIDTH   = 8\n)(\n  input                             clk,\n  input                             we,\n  input       [ADDRESS_WIDTH-1:0] addr,\n  input       [DATA_WIDTH - 1: 0] data,\n  output      [DATA_WIDTH - 1: 0] q,\n  input                             oe,\n  input       [ADDRESS_WIDTH-1:0] oe_addr,\n  output      [DATA_WIDTH - 1: 0] oe_data\n);\n\n//Registers/Wires\nreg       [DATA_WIDTH - 1: 0]   mem [0:(1 << ADDRESS_WIDTH) - 1];\nreg       [DATA_WIDTH - 1: 0]   q_reg;\nreg       [DATA_WIDTH - 1: 0]   oe_data_reg;\n\n//Write Logic\nalways @(posedge clk) begin\n  if (we) begin\n    mem[addr] <= data;\n  end\nend\n\n//Read Logic\nalways @(*) begin\n  q_reg = mem[addr];\nend\n\n//Output Logic\nassign q = q_reg;\n\n//Output Enable Logic\nalways @(*) begin\n  if (oe) begin\n    oe_data_reg = mem[oe_addr];\n  end else begin\n    oe_data_reg = 0;\n  end\nend\n\nassign oe_data = oe_data_reg;\n\nendmodule",
        "module_name": "fifo_buffer #",
        "module_hash": "1667323a5d904dbc8b35d7eea22c2f85",
        "dataset_index": 10965
      },
      "comparator_3bit_76f17241": {
        "rtl_code": "module comparator_3bit (\n  input [2:0] A,\n  input [2:0] B,\n  output EQ\n);\n\n  assign EQ = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n",
        "module_name": "comparator_3bit",
        "module_hash": "76f17241aeba918f2ea389a4dbe72e6b",
        "dataset_index": 454
      },
      "axis_async_frame_fifo_64_52415907": {
        "rtl_code": "\nmodule axis_async_frame_fifo_64 (\n  input input_clk,\n  input input_rst,\n  input [63:0] input_axis_tdata,\n  input [7:0] input_axis_tkeep,\n  input input_axis_tvalid,\n  input input_axis_tlast,\n  input input_axis_tuser,\n  output reg input_axis_tready,\n  input output_clk,\n  input output_rst,\n  output reg [63:0] output_axis_tdata,\n  output reg [7:0] output_axis_tkeep,\n  output reg output_axis_tvalid,\n  output reg output_axis_tlast,\n  output output_axis_tready\n);\n\n  localparam DEPTH = 64;\n  localparam ADDR_WIDTH = 6;\n  localparam DATA_WIDTH = 64;\n\n  reg [DATA_WIDTH - 1:0] buffer [DEPTH - 1:0];\n  reg [ADDR_WIDTH - 1:0] write_ptr = 0, read_ptr = 0;\n\n  always @(posedge input_clk) begin\n    if (input_rst) begin\n      write_ptr <= 0;\n      input_axis_tready <= 1'b1; // Ready to accept data after reset\n    end else if (input_axis_tvalid && input_axis_tready) begin\n      buffer[write_ptr] <= input_axis_tdata; // Write data to buffer\n      write_ptr <= write_ptr + 1'b1; // Increment write pointer\n    end\n  end\n\n  always @(posedge output_clk) begin\n    if (output_rst) begin\n      read_ptr <= 0;\n      output_axis_tvalid <= 1'b0; // Output not valid after reset\n    end else if (!output_axis_tvalid || (output_axis_tvalid && output_axis_tready)) begin\n      output_axis_tdata <= buffer[read_ptr]; // Read data from buffer\n      output_axis_tkeep <= input_axis_tkeep;\n      output_axis_tlast <= input_axis_tlast;\n      read_ptr <= read_ptr + 1'b1; // Increment read pointer\n      output_axis_tvalid <= 1'b1; // Mark output as valid\n    end\n  end\n\n  assign output_axis_tready = (read_ptr == write_ptr) ? 1'b0 : 1'b1; // Assert tready when FIFO is not full\n\nendmodule",
        "module_name": "axis_async_frame_fifo_64",
        "module_hash": "524159079992719c9cf8aa6734c27424",
        "dataset_index": 1450
      },
      "sky130_fd_sc_ms__o221a_1796a78e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__o221a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , B2, B1              );\n    or  or1  (or1_out   , A2, A1              );\n    and and0 (and0_out_X, or0_out, or1_out, C1);\n    buf buf0 (X         , and0_out_X          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__o221a",
        "module_hash": "1796a78e6ce1b22d9d89122529bd10e8",
        "dataset_index": 9118
      },
      "amm_master_qsys_with_pcie_video_rgb_resampler_0_538f4cb4": {
        "rtl_code": "\n\nmodule amm_master_qsys_with_pcie_video_rgb_resampler_0 (\n\tclk,\n\treset,\n\n\tstream_in_data,\n\tstream_in_startofpacket,\n\tstream_in_endofpacket,\n\tstream_in_empty,\n\tstream_in_valid,\n\n\tstream_out_ready,\n\t\n\tstream_in_ready,\n\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_empty,\n\tstream_out_valid\n);\n\n\n\nparameter IDW\t\t= 23;\nparameter ODW\t\t= 29;\n\nparameter IEW\t\t= 1;\nparameter OEW\t\t= 1;\n\nparameter ALPHA\t= 10'h3FF;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[IDW:0]\tstream_in_data;\ninput\t\t\t\t\t\tstream_in_startofpacket;\ninput\t\t\t\t\t\tstream_in_endofpacket;\ninput\t\t\t[IEW:0]\tstream_in_empty;\ninput\t\t\t\t\t\tstream_in_valid;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tstream_in_ready;\n\noutput reg\t[ODW:0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t[OEW:0]\tstream_out_empty;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire\t\t[ 9: 0]\tr;\nwire\t\t[ 9: 0]\tg;\nwire\t\t[ 9: 0]\tb;\nwire\t\t[ 9: 0]\ta;\n\n\nwire\t\t[ODW:0]\tconverted_data;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'b0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_empty\t\t\t\t<=  'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (stream_out_ready | ~stream_out_valid)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= converted_data;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid;\n\tend\nend\n\n\n\nassign stream_in_ready = stream_out_ready | ~stream_out_valid;\n\nassign r = {stream_in_data[23:16], stream_in_data[23:22]};\nassign g = {stream_in_data[15: 8], stream_in_data[15:14]};\nassign b = {stream_in_data[ 7: 0], stream_in_data[ 7: 6]};\n\nassign a = ALPHA;\n\nassign converted_data[29:20] = r[ 9: 0];\nassign converted_data[19:10] = g[ 9: 0];\nassign converted_data[ 9: 0] = b[ 9: 0];\n\n\n\n\nendmodule\n\n",
        "module_name": "amm_master_qsys_with_pcie_video_rgb_resampler_0",
        "module_hash": "538f4cb49524ccfd601397cd4978bf50",
        "dataset_index": 21777
      },
      "Comparator #_45b01389": {
        "rtl_code": "module Comparator #(\n  parameter n = 4 // number of bits in each input value\n)(\n  input [n-1:0] in1,\n  input [n-1:0] in2,\n  output reg [1:0] out\n);\n\n\nalways @(*) begin\n  if (in1 > in2) begin\n    out = 2'b01;\n  end else if (in1 == in2) begin\n    out = 2'b00;\n  end else begin\n    out = 2'b10;\n  end\nend\n\nendmodule",
        "module_name": "Comparator #",
        "module_hash": "45b01389b023fd51a13989ec528d4b08",
        "dataset_index": 20525
      },
      "d_ff_reset_709cdc9e": {
        "rtl_code": "\nmodule d_ff_reset (\n    input D,\n    input RESET_B,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    input CLK_N,\n    output reg Q\n);\n\n    wire D_valid;\n    wire RESET_B_valid;\n    wire VPWR_valid;\n    wire VGND_valid;\n    wire VPB_valid;\n    wire VNB_valid;\n\n    assign D_valid = (VPWR == 1'b1) && (VGND == 1'b0);\n    assign RESET_B_valid = (VPWR == 1'b1) && (VGND == 1'b0);\n    assign VPWR_valid = (VPWR == 1'b1) && (VGND == 1'b0);\n    assign VGND_valid = (VPWR == 1'b1) && (VGND == 1'b0);\n    assign VPB_valid = (VPB == 1'b1) && (VNB == 32'b11111111111111111111111111111111);\n    assign VNB_valid = (VPB == 1'b1) && (VNB == 32'b11111111111111111111111111111111);\n\n    always @(posedge CLK_N) begin\n        if (RESET_B_valid && !RESET_B) begin\n            Q <= 1'b0;\n        end else if (D_valid) begin\n            Q <= D;\n        end\n    end\n\nendmodule\n",
        "module_name": "d_ff_reset",
        "module_hash": "709cdc9e298f9ef7208ae7d71c088512",
        "dataset_index": 519
      },
      "four_input__9f43ec5e": {
        "rtl_code": "module four_input_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    VPWR,\n    VGND\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n\n    wire A1_high;\n    wire A2_high;\n    wire A3_high;\n    wire B1_high;\n\n    assign A1_high = (A1 == 1'b1);\n    assign A2_high = (A2 == 1'b1);\n    assign A3_high = (A3 == 1'b1);\n    assign B1_high = (B1 == 1'b1);\n\n    assign Y = (A1_high | (!A1_high & A2_high) | (!A1_high & !A2_high & A3_high) | (!A1_high & !A2_high & !A3_high & B1_high)) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "four_input_",
        "module_hash": "9f43ec5e62a908345b3c6c6cc9e27f83",
        "dataset_index": 10203
      },
      "up_down_counter_fa0ea8bf": {
        "rtl_code": "\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    input [3:0] load,\n    output [7:0] count\n);\n\nreg [7:0] count;\n\nalways @(posedge clk) begin\n    if (load != 0) begin\n        count <= load;\n    end else if (up_down == 1) begin\n        count <= count + 1;\n    end else begin\n        count <= count - 1;\n    end\nend\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "fa0ea8bf5fc38820d72442fc6d4742d9",
        "dataset_index": 19230
      },
      "binary_to_onehot_71e70bb2": {
        "rtl_code": "module binary_to_onehot (\n    input [2:0] B,\n    output reg [7:0] Y\n);\n\nalways @(*) begin\n    case(B)\n        3'b000: Y = 8'b00000001;\n        3'b001: Y = 8'b00000010;\n        3'b010: Y = 8'b00000100;\n        3'b011: Y = 8'b00001000;\n        3'b100: Y = 8'b00010000;\n        3'b101: Y = 8'b00100000;\n        3'b110: Y = 8'b01000000;\n        3'b111: Y = 8'b10000000;\n    endcase\nend\n\nendmodule\n\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input Up,\n    input Down,\n    input Load,\n    input [7:0] D,\n    output reg [7:0] Q\n);\n\nreg [7:0] next_Q;\n\nalways @(posedge clk) begin\n    if(reset) begin\n        Q <= 8'b00000000;\n    end else if(Load) begin\n        Q <= D;\n    end else if(Up) begin\n        next_Q = Q + 1;\n        Q <= next_Q;\n    end else if(Down) begin\n        next_Q = Q - 1;\n        Q <= next_Q;\n    end\nend\n\nendmodule\n\nmodule one_hot_counter (\n    input clk,\n    input reset,\n    input [2:0] B,\n    input Up,\n    input Down,\n    input Load,\n    output reg [7:0] Q\n);\n\nwire [7:0] onehot;\nwire [7:0] next_onehot;\n\nbinary_to_onehot converter(\n    .B(B),\n    .Y(onehot)\n);\n\nup_down_counter counter(\n    .clk(clk),\n    .reset(reset),\n    .Up(Up),\n    .Down(Down),\n    .Load(Load),\n    .D(onehot),\n    .Q(next_onehot)\n);\n\nalways @(posedge clk) begin\n    if(reset) begin\n        Q <= 8'b00000000;\n    end else begin\n        Q <= next_onehot;\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [2:0] B,\n    input Up,\n    input Down,\n    input Load,\n    output reg [7:0] Q\n);\n\none_hot_counter counter(\n    .clk(clk),\n    .reset(reset),\n    .B(B),\n    .Up(Up),\n    .Down(Down),\n    .Load(Load),\n    .Q(Q)\n);\n\nendmodule",
        "module_name": "binary_to_onehot",
        "module_hash": "71e70bb2d17f3bf3117fd0c4ad5d17dc",
        "dataset_index": 10150
      },
      "carry_select_adder_32bit_dfc45e53": {
        "rtl_code": "module carry_select_adder_32bit (\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] S,\n    output Cout\n);\n\nwire [31:0] C1, C2, P, G, D, E;\nwire [31:0] S1, S2;\n\nassign {C1, S1} = A + B;\nassign {C2, S2} = S1 + Cin;\n\nassign P = S1 ^ Cin;\nassign G = C1 & Cin;\nassign D = C2 & S1;\nassign E = G | D;\n\nassign S = E ^ Cin;\nassign Cout = E;\n\nendmodule",
        "module_name": "carry_select_adder_32bit",
        "module_hash": "dfc45e536f0eda00eb31153dc23e7afa",
        "dataset_index": 9641
      },
      "amm_master_qsys_with_pcie_sgdma_command_grabber_ae28e063": {
        "rtl_code": "\nmodule amm_master_qsys_with_pcie_sgdma_command_grabber (\n    // inputs:\n    clk,\n    command_fifo_empty,\n    command_fifo_q,\n    m_read_waitrequest,\n    m_write_waitrequest,\n    read_go,\n    reset_n,\n    write_go,\n\n    // outputs:\n    command_fifo_rdreq,\n    read_command_data,\n    read_command_valid,\n    write_command_data,\n    write_command_valid\n);\n\n  output           command_fifo_rdreq;\n  output  [ 58: 0] read_command_data;\n  output           read_command_valid;\n  output  [ 56: 0] write_command_data;\n  output           write_command_valid;\n  input            clk;\n  input            command_fifo_empty;\n  input   [103: 0] command_fifo_q;\n  input            m_read_waitrequest;\n  input            m_write_waitrequest;\n  input            read_go;\n  input            reset_n;\n  input            write_go;\n\n  wire    [  3: 0] atlantic_channel;\n  wire    [ 15: 0] bytes_to_transfer;\n  wire             command_fifo_rdreq;\n  wire             command_fifo_rdreq_in;\n  reg              command_fifo_rdreq_reg;\n  reg              command_valid;\n  wire    [  7: 0] control;\n  reg              delay1_command_valid;\n  wire             generate_eop;\n  wire    [ 31: 0] read_address;\n  wire    [  7: 0] read_burst;\n  reg     [ 58: 0] read_command_data_reg;\n  wire             read_command_valid;\n  wire             read_fixed_address;\n  wire    [ 31: 0] write_address;\n  wire    [  7: 0] write_burst;\n  reg     [ 56: 0] write_command_data_reg;\n  wire             write_command_valid;\n  wire             write_fixed_address;\n  //Descriptor components\n  assign read_address = command_fifo_q[31 : 0];\n  assign write_address = command_fifo_q[63 : 32];\n  assign bytes_to_transfer = command_fifo_q[79 : 64];\n  assign read_burst = command_fifo_q[87 : 80];\n  assign write_burst = command_fifo_q[95 : 88];\n  assign control = command_fifo_q[103 : 96];\n  //control bits\n  assign generate_eop = control[0];\n  assign read_fixed_address = control[1];\n  assign write_fixed_address = control[2];\n  assign atlantic_channel = control[6 : 3];\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          read_command_data_reg <= 0;\n      else \n        read_command_data_reg <= {write_fixed_address, generate_eop, ~read_fixed_address, read_burst, bytes_to_transfer, read_address};\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          write_command_data_reg <= 0;\n      else \n        write_command_data_reg <= {~write_fixed_address, write_burst, bytes_to_transfer, write_address};\n    end\n\n\n  assign read_command_data = read_command_data_reg;\n  assign write_command_data = write_command_data_reg;\n  assign read_command_valid = command_valid;\n  assign write_command_valid = command_valid;\n  //command_fifo_rdreq register\n  assign command_fifo_rdreq_in = (command_fifo_rdreq_reg || command_valid) ? 1'b0 : (~read_go && ~write_go && ~m_read_waitrequest && ~m_write_waitrequest);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          command_fifo_rdreq_reg <= 0;\n      else if (~command_fifo_empty)\n          command_fifo_rdreq_reg <= command_fifo_rdreq_in;\n    end\n\n\n  assign command_fifo_rdreq = command_fifo_rdreq_reg;\n  //command_valid register\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          delay1_command_valid <= 0;\n      else \n        delay1_command_valid <= command_fifo_rdreq_reg;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          command_valid <= 0;\n      else \n        command_valid <= delay1_command_valid;\n    end\nendmodule\n",
        "module_name": "amm_master_qsys_with_pcie_sgdma_command_grabber",
        "module_hash": "ae28e0631147f43138cd937c55c121df",
        "dataset_index": 6100
      },
      "counter_0447281f": {
        "rtl_code": "module counter (\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "0447281f4e514e30f202d28699e2a8a0",
        "dataset_index": 7312
      },
      "acl_fp_ceil_d6ab5ccc": {
        "rtl_code": "module acl_fp_ceil(clock, resetn, enable, dataa, result);\n\tinput clock, resetn, enable;\n\tinput [31:0] dataa;\n\toutput [31:0] result;\n\t\n\treg sign_in;\n\treg [7:0] exp_in;\n\treg [22:0] man_in;\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tsign_in <= 1'b0;\n\t\t\texp_in <= 8'd0;\n\t\t\tman_in <= 23'd0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\tsign_in <= dataa[31];\n\t\t\texp_in <= dataa[30:23];\n\t\t\tman_in <= dataa[22:0];\t\t\t\n\t\tend\n\tend\n\t\n\treg sign_1;\n\treg [7:0] exp_1;\n\treg [24:0] man_1;\n\treg is_fraction;\n\treg zero_exponent;\n\treg [24:0] addition;\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tsign_1 <= 1'b0;\n\t\t\texp_1 <= 8'd0;\n\t\t\tman_1 <= 25'd0;\n\t\t\tis_fraction <= 1'b0;\n\t\t\tzero_exponent <= 1'b0;\n\t\t\taddition <= 25'd0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\tsign_1 <= sign_in;\n\t\t\texp_1 <= exp_in;\n\t\t\tzero_exponent <= 1'b0;\n\t\t\tman_1[24:23] <= {1'b0, |exp_in};\n\t\t\tcase (exp_in)\n\t\t\t\t8'd127 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[22:0]);\n\t\t\t\t\t\t\t\taddition <= 25'h0800000;\n\t\t\t\t\t\t\t\tman_1[22:0] <= 23'd0;\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd128 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[21:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22], 22'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0400000;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd129 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[20:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:21], 21'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0200000;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd130 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[19:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:20], 20'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0100000;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd131 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[18:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:19], 19'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0080000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd132 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[17:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:18], 18'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0040000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd133 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[16:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:17], 17'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0020000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd134 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[15:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:16], 16'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0010000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd135 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[14:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:15], 15'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0008000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd136 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[13:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:14], 14'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0004000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd137 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[12:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:13], 13'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0002000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd138 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[11:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:12], 12'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0001000;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd139 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[10:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:11], 11'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000800;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd140 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[9:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:10], 10'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000400;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd141 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[8:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:9], 9'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000200;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd142 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[7:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:8], 8'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000100;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd143 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[6:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:7], 7'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000080;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd144 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[5:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:6], 6'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000040;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd145 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[4:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:5], 5'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000020;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd146 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[3:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:4], 4'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000010;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd147 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[2:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:3], 3'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000008;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd148 : begin\n\t\t\t\t\t\t\t\tis_fraction <= |(man_in[1:0]);\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:2], 2'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000004;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd149 : begin\n\t\t\t\t\t\t\t\tis_fraction <= man_in[0];\n\t\t\t\t\t\t\t\tman_1[22:0] <= {man_in[22:1], 1'd0};\n\t\t\t\t\t\t\t\taddition <= 25'h0000002;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\t8'd150 : begin\n\t\t\t\t\t\t\t\tis_fraction <= 1'b0;\n\t\t\t\t\t\t\t\tman_1[22:0] <= man_in;\n\t\t\t\t\t\t\t\taddition <= 25'h0000001;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tend\n\t\t\t\tdefault:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (exp_in > 8'd150)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tis_fraction <= 1'b0;\n\t\t\t\t\t\t\t\tman_1[22:0] <= man_in;\n\t\t\t\t\t\t\t\tzero_exponent <= 1'b0;\n\t\t\t\t\t\t\t\taddition <= 25'h0000000;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tis_fraction <= (|man_in) | (|exp_in);\n\t\t\t\t\t\t\t\taddition <= 25'h0800000;\n\t\t\t\t\t\t\t\tzero_exponent <= 1'b1;\n\t\t\t\t\t\t\t\tman_1[22:0] <= 23'd0; \n\t\t\t\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\treg sign_2;\n\treg [7:0] exp_2;\n\treg [24:0] man_2;\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tsign_2 <= 1'b0;\n\t\t\texp_2 <= 8'd0;\n\t\t\tman_2 <= 25'd0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\tif (zero_exponent)\n\t\t\tbegin\n\t\t\t\tsign_2 <= 1'b0;\t\t\t\t\n\t\t\t\tif (sign_1 | ~is_fraction)\n\t\t\t\tbegin\n\t\t\t\t   exp_2 <= 8'd0;\n\t\t\t\t\tman_2 <= 25'h0000000;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t   exp_2 <= 8'd127;\n\t\t\t\t\tman_2 <= 25'h0800000;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t   sign_2 <= sign_1;\n\t\t\t   exp_2 <= exp_1;\n\t\t\t   if (is_fraction & ~sign_1)\n\t\t\t\t\tman_2 <= man_1 + addition;\n\t\t\t\telse\n\t\t\t\t\tman_2 <= man_1;\n\t\t\tend\n\t\tend\n\tend\n\n\treg sign_3;\n\treg [7:0] exp_3;\n\treg [22:0] man_3;\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tsign_3 <= 1'b0;\n\t\t\texp_3 <= 8'd0;\n\t\t\tman_3 <= 23'd0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\tsign_3 <= sign_2;\n\t\t\tif (man_2[24])\n\t\t\tbegin\n\t\t\t\tman_3 <= man_2[23:1];\n\t\t\t\texp_3 <= exp_2 + 1'b1;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tman_3 <= man_2[22:0];\n\t\t\t\tif (man_2[23] && (exp_2 == 8'd0))\n\t\t\t\t\texp_3 <= 8'd1;\n\t\t\t\telse\n\t\t\t\t\texp_3 <= exp_2;\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign result = {sign_3, exp_3, man_3};\n\t\nendmodule\n",
        "module_name": "acl_fp_ceil",
        "module_hash": "d6ab5ccca7b775dabd2fe51c01c60480",
        "dataset_index": 25705
      },
      "ballscan_05c15c12": {
        "rtl_code": "module ballscan(clk, screenx, screeny, ball_x, ball_y, ball_scan);\n\tparameter BALLSIZE=8;\n\tinput clk;\n\tinput [9:0] screenx;\n\tinput [9:0] screeny;\n\tinput [9:0] ball_x;\n\tinput [9:0] ball_y;\n\toutput ball_scan;\n\n\treg [3:0] ballscanX;\n\treg \t  ballscanY;\n\n\talways @(posedge clk) begin\n\t\tif (screenx == ball_x-BALLSIZE/2)\n\t\t\tballscanX = 12;\n\t\tif (ballscanX > 0)\n\t\t\tballscanX = ballscanX - 1'b1;\n\tend\n\talways @(posedge clk) begin\n\t\tif (screeny == ball_y-BALLSIZE/2)\n\t\t\tballscanY = 1;\n\t\tif (screeny == ball_y+BALLSIZE/2)\n\t\t\tballscanY = 0;\n\tend\n\tassign ball_scan = ballscanX != 0 && ballscanY;\nendmodule\n\n",
        "module_name": "ballscan",
        "module_hash": "05c15c12cc9dc2098e3d085b06f569fa",
        "dataset_index": 22065
      },
      "fsm_4bit_binary_counter_a7955c60": {
        "rtl_code": "module fsm_4bit_binary_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  // Define the four states\n  parameter S0 = 2'b00;\n  parameter S1 = 2'b01;\n  parameter S2 = 2'b10;\n  parameter S3 = 2'b11;\n  \n  // Define the state register and initialize to S0\n  reg [1:0] state = S0;\n  \n  // Define the next state logic\n  always @ (posedge clk or posedge reset) begin\n    if (reset) begin\n      state <= S0;\n    end else begin\n      case (state)\n        S0: state <= S1;\n        S1: state <= S2;\n        S2: state <= S3;\n        S3: state <= S0;\n      endcase\n    end\n  end\n  \n  // Define the output logic\n  always @ (posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      case (state)\n        S0: count <= count + 4'b0001;\n        S1: count <= count + 4'b0001;\n        S2: count <= count + 4'b0001;\n        S3: count <= count + 4'b0001;\n      endcase\n    end\n  end\n  \nendmodule\n",
        "module_name": "fsm_4bit_binary_counter",
        "module_hash": "a7955c60962c8fd617a1d268e39a177f",
        "dataset_index": 11681
      },
      "frame_rate_0b88e5e0": {
        "rtl_code": "module frame_rate (\n    input inclk0,\n    output reg c0,\n    output reg c1,\n    output reg locked\n);\n\nreg inclk0_d; // delayed inclk0 signal\nreg locked_d; // delayed locked signal\nreg locked_dd; // doubly delayed locked signal\nreg c0_d; // delayed c0 signal\nreg c1_d; // delayed c1 signal\nreg c0_dd; // doubly delayed c0 signal\nreg c1_dd; // doubly delayed c1 signal\nreg locked_next; // next value of locked signal\nreg c0_next; // next value of c0 signal\nreg c1_next; // next value of c1 signal\n\nparameter COUNT_MAX = 2; // number of clock cycles to wait before updating output signals\n\ninteger count = 0; // counter for number of clock cycles elapsed\n\nalways @(posedge inclk0)\nbegin\n    // update delayed signals\n    inclk0_d <= inclk0;\n    c0_d <= c0_next;\n    c1_d <= c1_next;\n    locked_d <= locked_next;\n\n    // update doubly delayed signals\n    c0_dd <= c0_d;\n    c1_dd <= c1_d;\n    locked_dd <= locked_d;\n\n    // update output signals\n    if (count == COUNT_MAX)\n    begin\n        c0 <= c0_d;\n        c1 <= c1_d;\n        locked <= locked_d;\n\n        // calculate next values of output signals\n        c0_next <= ~c0_dd;\n        c1_next <= c0_dd;\n        locked_next <= (inclk0_d == locked_dd) ? 1 : 0;\n\n        count <= 0;\n    end\n    else\n    begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "frame_rate",
        "module_hash": "0b88e5e0623e1cd9092cb85a2e780950",
        "dataset_index": 13681
      },
      "hi_sniffer_244d9252": {
        "rtl_code": "module hi_sniffer(\n    ck_1356meg,\n    pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4,\n    adc_d, adc_clk,\n    ssp_frame, ssp_din, ssp_clk\n);\n    input ck_1356meg;\n    output pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4;\n    input [7:0] adc_d;\n    output adc_clk;\n    output ssp_frame, ssp_din, ssp_clk;\n\nassign pwr_hi  = 1'b0;\nassign pwr_lo  = 1'b0;\nassign pwr_oe1 = 1'b0;\nassign pwr_oe2 = 1'b0;\nassign pwr_oe3 = 1'b0;\nassign pwr_oe4 = 1'b0;\n\nreg ssp_frame;\nreg [7:0] adc_d_out = 8'd0;\nreg [2:0] ssp_cnt = 3'd0;\n\nassign adc_clk = ck_1356meg;\nassign ssp_clk = ~ck_1356meg;\n\nalways @(posedge ssp_clk)\nbegin\n    if(ssp_cnt[2:0] == 3'd7)\n        ssp_cnt[2:0] <= 3'd0;\n    else\n        ssp_cnt <= ssp_cnt + 1;\n\n    if(ssp_cnt[2:0] == 3'b000) begin\n            adc_d_out[7:0] <= adc_d;\n            ssp_frame <= 1'b1;\n        end\n    else\n        begin\n            adc_d_out[7:0] <= {1'b0, adc_d_out[7:1]};\n            ssp_frame <= 1'b0;\n        end\n\nend\n\nassign ssp_din = adc_d_out[0];\n\nendmodule\n",
        "module_name": "hi_sniffer",
        "module_hash": "244d9252c651be7a74ea075b5f86ca79",
        "dataset_index": 25379
      },
      "chatgpt_generate_edge_detect_bdef15d1": {
        "rtl_code": "module chatgpt_generate_edge_detect(\n  input               clk,\n  input               rst_n,\n  input               a,\n  output reg          rise,\n  output reg          down\n);\n\n  // Define the states for the state machine\n  parameter IDLE = 2'b00;\n  parameter RISING_EDGE = 2'b01;\n  parameter FALLING_EDGE = 2'b10;\n\n  // Define the current state and next state variables\n  reg [1:0] current_state, next_state;\n\n  // Initialize the current state to IDLE\n  initial current_state = IDLE;\n\n  // Detect rising and falling edges\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      current_state <= IDLE;\n      rise <= 1'b0;\n      down <= 1'b0;\n    end\n    else begin\n      current_state <= next_state;\n      case (current_state)\n        IDLE: begin\n          if (a == 1'b1) begin\n            next_state = RISING_EDGE;\n          end\n          else if (a == 1'b0) begin\n            next_state = FALLING_EDGE;\n          end\n          else begin\n            next_state = IDLE;\n          end\n          rise <= 1'b0;\n          down <= 1'b0;\n        end\n        RISING_EDGE: begin\n          next_state = IDLE;\n          rise <= 1'b1;\n          down <= 1'b0;\n        end\n        FALLING_EDGE: begin\n          next_state = IDLE;\n          rise <= 1'b0;\n          down <= 1'b1;\n        end\n        default: begin\n          next_state = IDLE;\n          rise <= 1'b0;\n          down <= 1'b0;\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "chatgpt_generate_edge_detect",
        "module_hash": "bdef15d158315d7f02f516d458fe906d",
        "dataset_index": 20919
      },
      "processing_system7_v5_3_w_atc #_1156b419": {
        "rtl_code": "\n\n\nmodule processing_system7_v5_3_w_atc #\n  (\n   parameter         C_FAMILY                         = \"rtl\",\n                       parameter integer C_AXI_ID_WIDTH                   = 4,\n                       parameter integer C_AXI_DATA_WIDTH                 = 64,\n                       parameter integer C_AXI_WUSER_WIDTH                = 1\n                       )\n  (\n   input  wire                                  ARESET,\n   input  wire                                  ACLK,\n\n   input  wire                                  cmd_w_valid,\n   input  wire                                  cmd_w_check,\n   input  wire [C_AXI_ID_WIDTH-1:0]             cmd_w_id,\n   output wire                                  cmd_w_ready,\n   \n   output wire                                  cmd_b_push,\n   output wire                                  cmd_b_error,\n   output reg  [C_AXI_ID_WIDTH-1:0]             cmd_b_id,\n   input  wire                                  cmd_b_full,\n   \n   input  wire [C_AXI_ID_WIDTH-1:0]             S_AXI_WID,\n   input  wire [C_AXI_DATA_WIDTH-1:0]           S_AXI_WDATA,\n   input  wire [C_AXI_DATA_WIDTH/8-1:0]         S_AXI_WSTRB,\n   input  wire                                  S_AXI_WLAST,\n   input  wire [C_AXI_WUSER_WIDTH-1:0]          S_AXI_WUSER,\n   input  wire                                  S_AXI_WVALID,\n   output wire                                  S_AXI_WREADY,\n\n   output wire [C_AXI_ID_WIDTH-1:0]             M_AXI_WID,\n   output wire [C_AXI_DATA_WIDTH-1:0]           M_AXI_WDATA,\n   output wire [C_AXI_DATA_WIDTH/8-1:0]         M_AXI_WSTRB,\n   output wire                                  M_AXI_WLAST,\n   output wire [C_AXI_WUSER_WIDTH-1:0]          M_AXI_WUSER,\n   output wire                                  M_AXI_WVALID,\n   input  wire                                  M_AXI_WREADY\n   );\n  \n  \n  wire                                any_strb_deasserted;\n  wire                                incoming_strb_issue;\n  reg                                 first_word;\n  reg                                 strb_issue;\n  \n  wire                                data_pop;\n  wire                                cmd_b_push_blocked;\n  reg                                 cmd_b_push_i;\n  \n  \n  assign any_strb_deasserted  = ( S_AXI_WSTRB != {C_AXI_DATA_WIDTH/8{1'b1}} );\n  assign incoming_strb_issue  = cmd_w_valid & S_AXI_WVALID & cmd_w_check & any_strb_deasserted;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      first_word  <= 1'b1;\n    end else if ( data_pop ) begin\n      first_word  <= S_AXI_WLAST;\n    end\n  end\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      strb_issue  <= 1'b0;\n      cmd_b_id    <= {C_AXI_ID_WIDTH{1'b0}};\n    end else if ( data_pop ) begin\n      if ( first_word ) begin\n        strb_issue  <= incoming_strb_issue;\n      end else begin\n        strb_issue  <= incoming_strb_issue | strb_issue;\n      end\n      cmd_b_id    <= cmd_w_id;\n    end\n  end\n  \n  assign cmd_b_error  = strb_issue;\n  \n  \n  assign data_pop   = S_AXI_WVALID & M_AXI_WREADY & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked; \n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      cmd_b_push_i  <= 1'b0;\n    end else begin\n      cmd_b_push_i  <= ( S_AXI_WLAST & data_pop ) | cmd_b_push_blocked;\n    end\n  end\n  \n  assign cmd_b_push_blocked = cmd_b_push_i & cmd_b_full;\n  \n  assign cmd_b_push = cmd_b_push_i & ~cmd_b_full;\n  \n  \n  assign M_AXI_WVALID   = S_AXI_WVALID & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked;\n  \n  assign S_AXI_WREADY   = M_AXI_WREADY & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked;\n  \n  assign cmd_w_ready    = S_AXI_WVALID & M_AXI_WREADY & cmd_w_valid & ~cmd_b_full & ~cmd_b_push_blocked & S_AXI_WLAST;\n  \n  \n  assign M_AXI_WID      = S_AXI_WID;\n  assign M_AXI_WDATA    = S_AXI_WDATA;\n  assign M_AXI_WSTRB    = S_AXI_WSTRB;\n  assign M_AXI_WLAST    = S_AXI_WLAST;\n  assign M_AXI_WUSER    = S_AXI_WUSER;\n  \n  \nendmodule\n",
        "module_name": "processing_system7_v5_3_w_atc #",
        "module_hash": "1156b4195857831f04d2d832ad494615",
        "dataset_index": 25453
      },
      "decoder_0_81cda828": {
        "rtl_code": "\nmodule decoder_0 (\n  input [k-1:0] in,\n  output reg [2**k-1:0] out\n);\n\nparameter k = 3; // number of control signals\n\nalways @(*) begin\n  case (in)\n    0: out = 8'b00000001;\n    1: out = 8'b00000010;\n    2: out = 8'b00000100;\n    3: out = 8'b00001000;\n    4: out = 8'b00010000;\n    5: out = 8'b00100000;\n    6: out = 8'b01000000;\n    7: out = 8'b10000000;\n    default: out = 8'b0;\n  endcase\nend\n\nendmodule\nmodule DEMUX (\n  input in,\n  input [k-1:0] c,\n  output reg [2**k-1:0] out\n);\n\nparameter k = 3; // number of control signals\n\nalways @(*) begin\n  case (c)\n    0: out = {in, 3'b000};\n    1: out = {in, 3'b001};\n    2: out = {in, 3'b010};\n    3: out = {in, 3'b011};\n    4: out = {in, 3'b100};\n    5: out = {in, 3'b101};\n    6: out = {in, 3'b110};\n    7: out = {in, 3'b111};\n    default: out = 8'b0;\n  endcase\nend\n\nendmodule\nmodule decoder_1 (\n  input [k-1:0] in,\n  output reg [2**k-1:0] out\n);\n\nparameter k = 3; // number of control signals\n\nalways @(*) begin\n  case (in)\n    0: out = 8'b00000001;\n    1: out = 8'b00000010;\n    2: out = 8'b00000100;\n    3: out = 8'b00001000;\n    4: out = 8'b00010000;\n    5: out = 8'b00100000;\n    6: out = 8'b01000000;\n    7: out = 8'b10000000;\n    default: out = 8'b0;\n  endcase\nend\n\nendmodule",
        "module_name": "decoder_0",
        "module_hash": "81cda828b992588dbe982c222fa77b3f",
        "dataset_index": 16713
      },
      "Counter_34f543bd": {
        "rtl_code": "module Counter (\n    input Clock, Reset, Set, Load, Enable,\n    input [Width-1:0] In,\n    output reg [Width-1:0] Count\n);\n\nparameter Width = 32;\nparameter Limited = 0;\nparameter Down = 0;\nparameter Initial = {Width{1'bx}};\nparameter AsyncReset = 0;\nparameter AsyncSet = 0;\n\nwire NoLimit;\n\nwire RegEnable;\nwire [Width-1:0] RegIn;\n\nassign NoLimit = !Limited;\n\nassign RegEnable = Load | (Enable & (NoLimit | (Down ? Count : ~&Count)));\nassign RegIn = Load ? In : (Down ? (Count - 1) : (Count + 1));\n\nalways @ (posedge Clock or posedge Reset)\n    if (Reset)\n        Count <= Initial;\n    else if (RegEnable)\n        Count <= RegIn;\n\nendmodule\n\nmodule Register (\n    input Clock, Reset, Set, Enable,\n    input [Width-1:0] In,\n    output reg [Width-1:0] Out\n);\n\nparameter Width = 32;\nparameter Initial = {Width{1'bx}};\nparameter AsyncReset = 0;\nparameter AsyncSet = 0;\n\nalways @ (posedge Clock or posedge Reset)\n    if (Reset)\n        Out <= Initial;\n    else if (Enable)\n        Out <= In;\n\nendmodule",
        "module_name": "Counter",
        "module_hash": "34f543bdd0904f7f510749d87ce328a3",
        "dataset_index": 11326
      },
      "AXI4LiteToRFBridgeVerilog #_e94bbf76": {
        "rtl_code": "\n\n\tmodule AXI4LiteToRFBridgeVerilog #\n\t(\n\t\tparameter integer C_S_AXI_ADDR_WIDTH\t= 32,\n\t\tparameter integer C_S_AXI_DATA_WIDTH\t= 32\n\t)\n\t(\n\t\toutput wire [C_S_AXI_ADDR_WIDTH-1 : 0] rf_raddr,\n    output wire [C_S_AXI_ADDR_WIDTH-1 : 0] rf_waddr,\n    output wire rf_wen,\n    output wire [C_S_AXI_DATA_WIDTH-1 : 0] rf_wdata,\n    input wire [C_S_AXI_DATA_WIDTH-1 : 0] rf_rdata,\n\n\t\tinput wire  S_AXI_ACLK,\n\t\tinput wire  S_AXI_ARESETN,\n\t\tinput wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,\n\t\tinput wire [2 : 0] S_AXI_AWPROT,\n\t\tinput wire  S_AXI_AWVALID,\n\t\toutput wire  S_AXI_AWREADY,\n\t\tinput wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,\n\t\tinput wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,\n\t\tinput wire  S_AXI_WVALID,\n\t\toutput wire  S_AXI_WREADY,\n\t\toutput wire [1 : 0] S_AXI_BRESP,\n\t\toutput wire  S_AXI_BVALID,\n\t\tinput wire  S_AXI_BREADY,\n\t\tinput wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,\n\t\tinput wire [2 : 0] S_AXI_ARPROT,\n\t\tinput wire  S_AXI_ARVALID,\n\t\toutput wire  S_AXI_ARREADY,\n\t\toutput wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,\n\t\toutput wire [1 : 0] S_AXI_RRESP,\n\t\toutput wire  S_AXI_RVALID,\n\t\tinput wire  S_AXI_RREADY\n\t);\n\treg [C_S_AXI_ADDR_WIDTH-1 : 0] \taxi_awaddr;\n\treg  \taxi_awready;\n\treg  \taxi_wready;\n\treg [1 : 0] \taxi_bresp;\n\treg  \taxi_bvalid;\n\treg [C_S_AXI_ADDR_WIDTH-1 : 0] \taxi_araddr;\n\treg  \taxi_arready;\n\treg [C_S_AXI_DATA_WIDTH-1 : 0] \taxi_rdata;\n\treg [1 : 0] \taxi_rresp;\n\treg  \taxi_rvalid;\n\n\tlocalparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;\n\tlocalparam integer OPT_MEM_ADDR_BITS = 16;\n\twire\t slv_reg_rden;\n\twire\t slv_reg_wren;\nassign S_AXI_AWREADY\t= axi_awready;\n\tassign S_AXI_WREADY\t= axi_wready;\n\tassign S_AXI_BRESP\t= axi_bresp;\n\tassign S_AXI_BVALID\t= axi_bvalid;\n\tassign S_AXI_ARREADY\t= axi_arready;\n\tassign S_AXI_RDATA\t= axi_rdata;\n\tassign S_AXI_RRESP\t= axi_rresp;\n\tassign S_AXI_RVALID\t= axi_rvalid;\n\talways @( posedge S_AXI_ACLK )\n\tbegin\n\t  if ( S_AXI_ARESETN == 1'b0 )\n\t    begin\n\t      axi_awready <= 1'b0;\n\t    end \n\t  else\n\t    begin    \n\t      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n\t        begin\n\t          axi_awready <= 1'b1;\n\t        end\n\t      else           \n\t        begin\n\t          axi_awready <= 1'b0;\n\t        end\n\t    end \n\tend       \n\n\talways @( posedge S_AXI_ACLK )\n\tbegin\n\t  if ( S_AXI_ARESETN == 1'b0 )\n\t    begin\n\t      axi_awaddr <= 0;\n\t    end \n\t  else\n\t    begin    \n\t      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n\t        begin\n\t          axi_awaddr <= S_AXI_AWADDR;\n\t        end\n\t    end \n\tend       \n\n\talways @( posedge S_AXI_ACLK )\n\tbegin\n\t  if ( S_AXI_ARESETN == 1'b0 )\n\t    begin\n\t      axi_wready <= 1'b0;\n\t    end \n\t  else\n\t    begin    \n\t      if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)\n\t        begin\n\t          axi_wready <= 1'b1;\n\t        end\n\t      else\n\t        begin\n\t          axi_wready <= 1'b0;\n\t        end\n\t    end \n\tend       \n\n\tassign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;\n\n  assign rf_wen = slv_reg_wren;\n  assign rf_waddr = axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB];\n  assign rf_wdata = S_AXI_WDATA;\n\nalways @( posedge S_AXI_ACLK )\n\tbegin\n\t  if ( S_AXI_ARESETN == 1'b0 )\n\t    begin\n\t      axi_bvalid  <= 0;\n\t      axi_bresp   <= 2'b0;\n\t    end \n\t  else\n\t    begin    \n\t      if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)\n\t        begin\n\t          axi_bvalid <= 1'b1;\n\t          axi_bresp  <= 2'b0; end                   else\n\t        begin\n\t          if (S_AXI_BREADY && axi_bvalid) \n\t            begin\n\t              axi_bvalid <= 1'b0; \n\t            end  \n\t        end\n\t    end\n\tend   \n\n\talways @( posedge S_AXI_ACLK )\n\tbegin\n\t  if ( S_AXI_ARESETN == 1'b0 )\n\t    begin\n\t      axi_arready <= 1'b0;\n\t      axi_araddr  <= 32'b0;\n\t    end \n\t  else\n\t    begin    \n\t      if (~axi_arready && S_AXI_ARVALID)\n\t        begin\n\t          axi_arready <= 1'b1;\n\t          axi_araddr  <= S_AXI_ARADDR;\n\t        end\n\t      else\n\t        begin\n\t          axi_arready <= 1'b0;\n\t        end\n\t    end \n\tend       \n\n  assign rf_raddr = axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB];\n\n\talways @( posedge S_AXI_ACLK )\n\tbegin\n\t  if ( S_AXI_ARESETN == 1'b0 )\n\t    begin\n\t      axi_rvalid <= 0;\n\t      axi_rresp  <= 0;\n\t    end \n\t  else\n\t    begin    \n\t      if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)\n\t        begin\n\t          axi_rvalid <= 1'b1;\n\t          axi_rresp  <= 2'b0; end   \n\t      else if (axi_rvalid && S_AXI_RREADY)\n\t        begin\n\t          axi_rvalid <= 1'b0;\n\t        end                \n\t    end\n\tend    \n\n\tassign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;\n\n  always @( posedge S_AXI_ACLK )\n\tbegin\n\t  if ( S_AXI_ARESETN == 1'b0 )\n\t    begin\n\t      axi_rdata  <= 0;\n\t    end \n\t  else\n\t    begin    \n\t      if (slv_reg_rden)\n\t        begin\naxi_rdata <= rf_rdata;     end   \n\t    end\n\tend    \n\n\tendmodule\n",
        "module_name": "AXI4LiteToRFBridgeVerilog #",
        "module_hash": "e94bbf76af75952351ba0d66c9172992",
        "dataset_index": 7063
      },
      "cp0_bae8bf2c": {
        "rtl_code": "\n\n`define SR 5'd12\n`define CAUSE 5'd13\n`define EPC 5'd14\n`define PRID 5'd15\n\n`define EC_INT 5'b00000\n\nmodule cp0 (input         clk,\n            input         rst,\n            input [4:0]   a1,\n            input [4:0]   a2,\n            input [31:0]  din,\n            input [31:0]  pc,\n            input [6:2]   ExcCode,\n            input [5:0]   HWInt,\n            input         we,\n            input         EXLSet,\n            input         EXLClr,\n            output        IntReq,\n            output [31:0] EPC,\n            output [31:0] dout\n            );\n   reg [15:10]            im;\n   reg                    exl,ie;\n   reg [15:10]            hwint_pend;\n   reg [31:0]             _epc;\n   reg [31:0]             PrId;\n   reg [6:2]              _exccode;\n\n   always @(posedge clk or posedge rst) begin\n      if (rst) begin\n         ie<=1;\n         im<=6'b110000;\n         exl<=0;\n         hwint_pend<=0;\n         PrId<=32'h12345678;\n      end else begin\n         hwint_pend<=HWInt;\n         if (IntReq) begin\n            _exccode<=ExcCode;\n            _epc<=pc-4;\n            exl<=1'b1;\n         end else if (we) begin\n            if (a2==`SR) begin\n               {im,exl,ie}<={din[15:10],EXLClr?1'b1:din[1],din[0]};\n            end\n            else if (a2==`EPC) begin\n               _epc<=pc;\n            end\n            else if (EXLSet) begin\n               exl<=1'b1;\n            end else if (EXLClr) begin\n               exl<=1'b0;\n            end\n         end else if (EXLSet) begin\n            exl<=1'b1;\n         end else if (EXLClr) begin\n            exl<=1'b0;\n         end end\n   end\n   assign dout=(a1==`SR)?{16'b0,im,8'b0,exl,ie}:\n               (a1==`CAUSE)?{16'b0,hwint_pend,3'b0,_exccode,2'b00}:\n               (a1==`EPC)?_epc:\n               (a1==`PRID)?PrId:\n               32'h0000_0000;\n   assign EPC=_epc;\n   assign IntReq=ie&&(!exl)&&(hwint_pend[15:10]&im[15:10]);\n\n\nendmodule ",
        "module_name": "cp0",
        "module_hash": "bae8bf2c286f0f1046fe4b0c53744f29",
        "dataset_index": 22158
      },
      "fifo_9357f3ab": {
        "rtl_code": "\nmodule fifo(clk, rst, en, mode, din, we, dout, re, status, full, empty);\n\nparameter DEPTH = 16;\nparameter WIDTH = 32;\n\ninput clk, rst, en, we, re;\ninput [1:0] mode;\ninput [WIDTH-1:0] din;\noutput [WIDTH-1:0] dout;\noutput [1:0] status;\noutput full, empty;\n\nreg [WIDTH-1:0] mem [0:DEPTH-1];\nreg [4:0] wp, rp;\nreg [1:0] status_reg;\nreg [WIDTH-1:0] dout_reg;\nreg empty_reg;\n\nassign full = (wp == rp) && !empty_reg;\nassign empty = (wp == rp) && empty_reg;\n\n// write pointer logic\nalways @(posedge clk) begin\n    if (rst) begin\n        wp <= 0;\n    end\n    else if (en && we && !full) begin\n        wp <= wp + 1;\n    end\nend\n\n// read pointer logic\nalways @(posedge clk) begin\n    if (rst) begin\n        rp <= 0;\n    end\n    else if (en && re && !empty) begin\n        rp <= rp + 1;\n    end\nend\n\n// status logic\nalways @(posedge clk) begin\n    if (rst) begin\n        status_reg <= 2'b00;\n    end\n    else begin\n        if (full) begin\n            status_reg <= 2'b10;\n        end\n        else if (empty) begin\n            status_reg <= 2'b00;\n        end\n        else begin\n            status_reg <= 2'b01;\n        end\n    end\nend\n\n// empty logic\nalways @(posedge clk) begin\n    if (rst) begin\n        empty_reg <= 1'b1;\n    end\n    else if (en && we && !full) begin\n        empty_reg <= 1'b0;\n    end\n    else if (en && re && empty) begin\n        empty_reg <= 1'b1;\n    end\nend\n\n// data output logic\nalways @(posedge clk) begin\n    if (rst) begin\n        dout_reg <= 0;\n    end\n    else if (en && re && !empty) begin\n        case (mode)\n            2'b00: dout_reg <= {16'h0, mem[rp][15:0]};\n            2'b01: dout_reg <= {mem[rp][17:0], 2'h0};\n            2'b10: dout_reg <= mem[rp];\n            default: dout_reg <= 0;\n        endcase\n    end\nend\n\n// write data logic\nalways @(posedge clk) begin\n    if (rst) begin\n        mem[0] <= 0;\n    end\n    else if (en && we && !full) begin\n        mem[wp] <= din;\n    end\nend\n\nassign dout = dout_reg;\nassign status = status_reg;\n\nendmodule\n",
        "module_name": "fifo",
        "module_hash": "9357f3ab1e4cccbfc68e3b2f54b1e891",
        "dataset_index": 19897
      },
      "single__9ce1137c": {
        "rtl_code": "\nmodule single_module (T, C, E, Q);\n\tinput T, C, E;\n\toutput reg Q;\n\n\twire xorout;\n\n\tassign xorout = T ^ Q;\n\n\talways @ (posedge C) begin\n\t\tif (E) begin\n\t\t\tQ = xorout;\n\t\tend\n\tend\nendmodule",
        "module_name": "single_",
        "module_hash": "9ce1137caf8deb8e57ddcc7d5ff666a6",
        "dataset_index": 18440
      },
      "SWMaze_30e7eccd": {
        "rtl_code": "module SWMaze(clk_vga, CurrentX, CurrentY, mapData, wall);\n\n\tinput clk_vga;\n\tinput [9:0]CurrentX;\n\tinput [8:0]CurrentY;\n\tinput [7:0]wall;\n\t\n\toutput [7:0]mapData;\n\t\n\treg [7:0]mColor;\n\n\n\talways @(posedge clk_vga) begin\n\t\t\n\t\tif((CurrentY < 40) && (CurrentX >= 0))\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if((CurrentX >= 0 && CurrentX <=63) && ( \n\t\t\t(CurrentY >= 120 && CurrentY <= 359) || \n\t\t\t(CurrentY >= 441) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 64 && CurrentX <= 95) && ( \n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 441) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 96 && CurrentX <= 127) && ( \n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280) ) ) \n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 128 && CurrentX <= 159) && ( \n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280 && CurrentY <= 359) ) )\n\t\t\tmColor[7:0] <= wall;\n\n\t\telse if( (CurrentX >= 160 && CurrentX <= 191) && (\n\t\t\t(CurrentY >= 280 && CurrentY <= 359) ||\n\t\t\t(CurrentY >= 400) ) )\n\t\t\tmColor[7:0] <= wall;\n\n\t\telse if( (CurrentX >= 192 && CurrentX <= 223) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280 && CurrentY <= 359) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\t\n\t\telse if( (CurrentX >= 224 && CurrentX <= 255) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280) ) ) \n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 256 && CurrentX <= 287) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 288 && CurrentX <= 351) && (\n\t\t\t(CurrentY >= 120) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 352 && CurrentX <= 383) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 384 && CurrentX <= 415) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280) ) ) \n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 416 && CurrentX <= 447) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280 && CurrentY <= 359) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 448 && CurrentX <= 479) && (\n\t\t\t(CurrentY >= 280 && CurrentY <= 359) ||\n\t\t\t(CurrentY >= 400) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 480 && CurrentX <= 511) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280 && CurrentY <= 359) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 512 && CurrentX <= 543) && (\n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 280) ) ) \n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if( (CurrentX >= 544 && CurrentX <= 575) && ( \n\t\t\t(CurrentY >= 120 && CurrentY <= 199) || \n\t\t\t(CurrentY >= 441) ) )\n\t\t\tmColor[7:0] <= wall;\n\t\t\n\t\telse if((CurrentX >= 576 && CurrentX <= 640) && ( \n\t\t\t(CurrentY >= 120 && CurrentY <= 359) || \n\t\t\t(CurrentY >= 441) ) )\n\t\t\tmColor[7:0] <= wall;\n\n\t\telse\n\t\t\tmColor[7:0] <= 8'b10110110;\n\t\t\t\n\tend\n\t\n\t\n\tassign mapData = mColor;\n\n\nendmodule\n \n",
        "module_name": "SWMaze",
        "module_hash": "30e7eccd37cb2eb21a6abf9203d9772e",
        "dataset_index": 21997
      },
      "bcd_to_segment_a43c9546": {
        "rtl_code": "module bcd_to_segment\n(\n    input [3:0] bcd_data,\n    output reg [7:0] seg_data\n);\n\n    always @(bcd_data) begin\n        case (bcd_data)\n             4'b0000:    seg_data <= 8'b11000000;    // 0\n             4'b0001:    seg_data <= 8'b11111001;    // 1\n             4'b0010:    seg_data <= 8'b10100100;    // 2\n             4'b0011:    seg_data <= 8'b10110000;    // 3\n             4'b0100:    seg_data <= 8'b10011001;    // 4\n             4'b0101:    seg_data <= 8'b10010010;    // 5\n             4'b0110:    seg_data <= 8'b10000010;    // 6\n             4'b0111:    seg_data <= 8'b11111000;    // 7\n             4'b1000:    seg_data <= 8'b10000000;    // 8\n             4'b1001:    seg_data <= 8'b10010000;    // 9\n             4'b1010:    seg_data <= 8'b01111111;    // dp\n             default:    seg_data <= 8'b11111111;    // off\n        endcase    \n    end\n    \nendmodule",
        "module_name": "bcd_to_segment",
        "module_hash": "a43c9546d499cdb12b84ba56f5814663",
        "dataset_index": 16458
      },
      "shift_register_57ef25bb": {
        "rtl_code": "module shift_register ( input clk, input d, output q );\n\n  reg [2:0] register;\n  wire [2:0] next_register;\n\n  assign next_register = {register[1:0], d};\n\n  always @(posedge clk) begin\n    register <= next_register;\n  end\n\n  assign q = register[2];\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "57ef25bb5557a041e8c6629cf53b1d2e",
        "dataset_index": 16763
      },
      "flow_control_processing #_a21015ff": {
        "rtl_code": "module flow_control_processing #(\n    parameter SYMBOLS_PER_BEAT = 4,\n    parameter BITS_PER_SYMBOL = 8\n)(\n    input clock,\n    input reset,\n    input internal_output_is_valid,\n    input ena,\n    input ready_out,\n    output stall,\n    output valid_out,\n    output [SYMBOLS_PER_BEAT*BITS_PER_SYMBOL-1:0] data_out,\n    output eop_out,\n    output sop_out\n);\n\nreg [SYMBOLS_PER_BEAT*BITS_PER_SYMBOL-1:0] data_out_d1;\nreg sop_out_d1, eop_out_d1;\n\nassign stall = !ready_out;\nassign valid_out = internal_output_is_valid & ena;\n\nassign data_out = valid_out ? data_out_d1 : {(BITS_PER_SYMBOL * SYMBOLS_PER_BEAT){1'b0}};\nassign eop_out = valid_out ? eop_out_d1 : 1'b0;\nassign sop_out = valid_out ? sop_out_d1 : 1'b0;\n\nalways @(posedge clock or posedge reset)\n    if (reset) begin\n        data_out_d1 <= {(BITS_PER_SYMBOL * SYMBOLS_PER_BEAT){1'b0}};\n        sop_out_d1 <= 1'b0;\n        eop_out_d1 <= 1'b0;\n    end\n    else begin\n        data_out_d1 <= data_out;\n        sop_out_d1 <= sop_out;\n        eop_out_d1 <= eop_out;\n    end\n\nendmodule",
        "module_name": "flow_control_processing #",
        "module_hash": "a21015ff2c55b59d691f2695561ffca5",
        "dataset_index": 2918
      },
      "calculator_11cdbfe0": {
        "rtl_code": "module calculator (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    output [7:0] result,\n    output valid\n);\n\nreg [7:0] result_reg;\nreg valid_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result_reg <= 8'b0;\n        valid_reg <= 1'b0;\n    end else begin\n        case (op)\n            2'b00: begin // addition\n                result_reg <= a + b;\n                valid_reg <= 1'b1;\n            end\n            2'b01: begin // subtraction\n                result_reg <= a - b;\n                valid_reg <= 1'b1;\n            end\n            2'b10: begin // multiplication\n                result_reg <= a * b;\n                valid_reg <= 1'b1;\n            end\n            2'b11: begin // division\n                if (b == 0) begin\n                    result_reg <= 8'b0;\n                    valid_reg <= 1'b0;\n                end else begin\n                    result_reg <= a / b;\n                    valid_reg <= 1'b1;\n                end\n            end\n        endcase\n    end\nend\n\nassign result = result_reg;\nassign valid = valid_reg;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "11cdbfe08c710b51214c07be0f62364a",
        "dataset_index": 20950
      },
      "fsm_traffic_light_control_d4eb45ad": {
        "rtl_code": "module fsm_traffic_light_control (\n  input clock,\n  input reset,\n  input pedestrian_crossing_button,\n  output reg green_light,\n  output reg yellow_light,\n  output reg red_light\n);\n\n  parameter S0 = 2'b00;\n  parameter S1 = 2'b01;\n  parameter S2 = 2'b10;\n  parameter S3 = 2'b11;\n  \n  reg [1:0] state, next_state;\n  \n  always @(posedge clock) begin\n    if (reset) begin\n      state <= S0;\n    end else begin\n      state <= next_state;\n    end\n  end\n  \n  always @(*) begin\n    case (state)\n      S0: begin\n        green_light <= 1;\n        yellow_light <= 0;\n        red_light <= 0;\n        if (pedestrian_crossing_button) begin\n          next_state <= S1;\n        end else begin\n          next_state <= S0;\n        end\n      end\n      S1: begin\n        green_light <= 0;\n        yellow_light <= 1;\n        red_light <= 0;\n        next_state <= S2;\n      end\n      S2: begin\n        green_light <= 0;\n        yellow_light <= 0;\n        red_light <= 1;\n        next_state <= S3;\n      end\n      S3: begin\n        green_light <= 0;\n        yellow_light <= 1;\n        red_light <= 0;\n        next_state <= S0;\n      end\n      default: begin\n        green_light <= 0;\n        yellow_light <= 0;\n        red_light <= 0;\n        next_state <= S0;\n      end\n    endcase\n  end\n  \nendmodule\n",
        "module_name": "fsm_traffic_light_control",
        "module_hash": "d4eb45ada4edc4c21d2e75064ee2aa06",
        "dataset_index": 8753
      },
      "shift_register_021de8b3": {
        "rtl_code": "module shift_register (\n    input [0:0] in,\n    output reg [2:0] out,\n    input clk\n);\n\nreg [2:0] stage1_out;\nreg [2:0] stage2_out;\n\nalways @(posedge clk) begin\n    stage1_out <= in;\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\nend\n\nalways @(posedge clk) begin\n    out <= stage2_out;\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "021de8b3d805243318de3505f3172fcc",
        "dataset_index": 690
      },
      "shift_register_c7dab1d9": {
        "rtl_code": "module shift_register (\n    input clk,\n    input [3:0] DIN,\n    input LOAD,\n    input SHIFT,\n    input RESET,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (RESET) begin\n            Q <= 4'b0;\n        end else if (LOAD) begin\n            Q <= DIN;\n        end else if (SHIFT) begin\n            Q <= {Q[2:0], 1'b0};\n        end\n    end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "c7dab1d966fe31c58a26d926deb52115",
        "dataset_index": 13142
      },
      "arithmetic_operations_e8362edc": {
        "rtl_code": "\nmodule arithmetic_operations (CLK, DS, ED, MPYJ, DR, DI, DOR, DOI);\n\nparameter total_bits = 32;\n\ninput CLK;\ninput DS;\ninput ED;\ninput MPYJ;\ninput [total_bits-1:0] DR;\ninput [total_bits-1:0] DI;\n\noutput reg [total_bits:0] DOR;\noutput reg [total_bits:0] DOI;\n\nreg signed [total_bits+2:0] dx5;\nreg signed [total_bits-1:0] dx7;\nreg signed [total_bits-1:0] dii;\nreg signed [total_bits:0] dt;\nwire signed [total_bits+3:0] dx5p;\nwire signed [total_bits+3:0] dot;\nreg edd, edd2, edd3;\nreg mpyjd, mpyjd2, mpyjd3;\nreg [total_bits:0] doo;\nreg [total_bits:0] droo;\n\nassign dx5p = (dx5 << 1) + (dx7 >>> 1);\nassign dot = dx5p + (dt >>> 6) - (dx5 >>> 13);\n\nalways @(posedge CLK) begin\n    if (ED) begin\n        edd <= DS;\n        edd2 <= edd;\n        edd3 <= edd2;\n        mpyjd <= MPYJ;\n        mpyjd2 <= mpyjd;\n        mpyjd3 <= mpyjd2;\n        if (DS) begin\n            dx5 <= DR + (DR << 2);\n            dx7 <= DR - (DR >>> 3);\n            dt <= DR;\n            dii <= DI;\n        end else begin\n            dx5 <= dii + (dii << 2);\n            dx7 <= dii - (dii >>> 3);\n            dt <= dii;\n        end\n        doo <= dot >>> 3;\n        droo <= doo;\n        if (edd3) begin\n            if (mpyjd3) begin\n                DOR <= doo;\n                DOI <= -droo;\n            end else begin\n                DOR <= droo;\n                DOI <= doo;\n            end\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "arithmetic_operations",
        "module_hash": "e8362edcec8ef8ed834756242288c934",
        "dataset_index": 4851
      },
      "parity_generator_08db5b95": {
        "rtl_code": "module parity_generator (\n    input [7:0] in,\n    output parity);\n\n    assign parity = ^in;\n\nendmodule",
        "module_name": "parity_generator",
        "module_hash": "08db5b95be3f8be10b4b7281607db15f",
        "dataset_index": 8321
      },
      "xor_32_df85bb42": {
        "rtl_code": "\n\nmodule xor_32(\n\tinput [31:0] a, input [31:0] b,\n\toutput [31:0] out );\n\n\tassign out[0] \t=  a[0]  ^  b[0]; \n\tassign out[1] \t=  a[1]  ^  b[1]; \n\tassign out[2] \t=  a[2]  ^  b[2]; \n\tassign out[3] \t=  a[3]  ^  b[3]; \n\tassign out[4] \t=  a[4]  ^  b[4]; \n\tassign out[5] \t=  a[5]  ^  b[5]; \n\tassign out[6] \t=  a[6]  ^  b[6]; \n\tassign out[7] \t=  a[7]  ^  b[7]; \n\tassign out[8] \t=  a[8]  ^  b[8]; \n\tassign out[9] \t=  a[9]  ^  b[9]; \n\tassign out[10]\t=  a[10] ^  b[10]; \n\tassign out[11] \t=  a[11] ^  b[11]; \n\tassign out[12] \t=  a[12] ^  b[12]; \n\tassign out[13] \t=  a[13] ^  b[13]; \n\tassign out[14] \t=  a[14] ^  b[14]; \n\tassign out[15] \t=  a[15] ^  b[15]; \n\tassign out[16] \t=  a[16] ^  b[16]; \n\tassign out[17] \t=  a[17] ^  b[17]; \n\tassign out[18] \t=  a[18] ^  b[18]; \n\tassign out[19] \t=  a[19] ^  b[19]; \n\tassign out[20] \t=  a[20] ^  b[20]; \n\tassign out[21] \t=  a[21] ^  b[21]; \n\tassign out[22] \t=  a[22] ^  b[22]; \n\tassign out[23] \t=  a[23] ^  b[23];\n\tassign out[24] \t=  a[24] ^  b[24]; \n\tassign out[25]\t=  a[25] ^  b[25]; \n\tassign out[26] \t=  a[26] ^  b[26]; \n\tassign out[27] \t=  a[27] ^  b[27]; \n\tassign out[28] \t=  a[28] ^  b[28]; \n\tassign out[29] \t=  a[29] ^  b[29]; \n\tassign out[30] \t=  a[30] ^  b[30];\n\tassign out[31] \t=  a[31] ^  b[31];\nendmodule\n",
        "module_name": "xor_32",
        "module_hash": "df85bb42a7ad9ff840f4b84ca58c6329",
        "dataset_index": 22681
      },
      "min_shift_bbc697ea": {
        "rtl_code": "module min_shift(\n    input clk,          // Clock input\n    input reset,        // Synchronous active-high reset\n    input select,       // Select input to choose between minimum circuit and register shift module\n    input [7:0] a, b, c, d,      // Input for the minimum circuit\n    input [1:0] ena,    // Input for register shift module to choose shift direction\n    input [99:0] data,  // Input for register shift module to load data\n    output reg [7:0] min,        // Output for the minimum circuit\n    output reg [99:0] q         // Output for the register shift module\n);\n\n// 4-way minimum circuit\nreg [7:0] min1, min2, min3;\n\nalways @* begin\n    min1 = (a < b) ? a : b;\n    min2 = (c < d) ? c : d;\n    min3 = (min1 < min2) ? min1 : min2;\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        min <= 8'd0;\n    end else if (select) begin\n        min <= min3;\n    end else begin\n        // Register shift module\n        if (ena == 2'b00) begin\n            // Shift left\n            q <= {q[98:0], 1'b0};\n        end else if (ena == 2'b01) begin\n            // Shift right\n            q <= {1'b0, q[99:1]};\n        end else if (ena == 2'b10) begin\n            // Load data\n            q <= data;\n        end\n        min <= 8'd0;\n    end\nend\n\nendmodule",
        "module_name": "min_shift",
        "module_hash": "bbc697ea0092f915421aa83061114fc4",
        "dataset_index": 5238
      },
      "pfpu_fmul_51645019": {
        "rtl_code": "module pfpu_fmul(\n\tinput sys_clk,\n\tinput alu_rst,\n\t\n\tinput [31:0] a,\n\tinput [31:0] b,\n\tinput valid_i,\n\t\n\toutput reg [31:0] r,\n\toutput reg valid_o\n);\n\nwire\t\ta_sign = a[31];\nwire [7:0]\ta_expn = a[30:23];\nwire [23:0]\ta_mant = {1'b1, a[22:0]};\n\nwire\t\tb_sign = b[31];\nwire [7:0]\tb_expn = b[30:23];\nwire [23:0]\tb_mant = {1'b1, b[22:0]};\n\nreg\t\tr_zero;\nreg\t\tr_sign;\nreg [7:0]\tr_expn;\nreg [23:0]\tr_a_mant;\nreg [23:0]\tr_b_mant;\n\nreg r_valid;\n\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr_valid <= 1'b0;\n\telse\n\t\tr_valid <= valid_i;\n\tr_zero <= (a_expn == 8'd0)|(b_expn == 8'd0);\n\tr_sign <= a_sign ^ b_sign;\n\tr_expn <= a_expn + b_expn - 8'd127;\n\tr_a_mant <= a_mant;\n\tr_b_mant <= b_mant;\nend\n\n\nreg\t\tr1_zero;\nreg\t\tr1_sign;\nreg [7:0]\tr1_expn;\nreg [47:0]\tr1_mant;\n\nreg r1_valid;\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr1_valid <= 1'b0;\n\telse\n\t\tr1_valid <= r_valid;\n\tr1_zero <= r_zero;\n\tr1_sign <= r_sign;\n\tr1_expn <= r_expn;\n\tr1_mant <= r_a_mant*r_b_mant;\nend\n\n\nreg\t\tr2_zero;\nreg\t\tr2_sign;\nreg [7:0]\tr2_expn;\nreg [47:0]\tr2_mant;\n\nreg r2_valid;\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr2_valid <= 1'b0;\n\telse\n\t\tr2_valid <= r1_valid;\n\tr2_zero <= r1_zero;\n\tr2_sign <= r1_sign;\n\tr2_expn <= r1_expn;\n\tr2_mant <= r1_mant;\nend\n\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tvalid_o <= 1'b0;\n\telse\n\t\tvalid_o <= r2_valid;\n\tif(r2_zero)\n\t\tr <= {1'bx, 8'd0, 23'bx};\n\telse begin\n\t\tif(~r2_mant[47])\n\t\t\tr <= {r2_sign, r2_expn,      r2_mant[45:23]};\n\t\telse\n\t\t\tr <= {r2_sign, r2_expn+8'd1, r2_mant[46:24]};\n\tend\nend\n\nendmodule",
        "module_name": "pfpu_fmul",
        "module_hash": "516450190eca3b3209fc0bffaa2c44f3",
        "dataset_index": 1927
      },
      "mux_aa3e7e53": {
        "rtl_code": "\nmodule mux\n   #(parameter N = 1)\n   (input ctrl,\n    input [N-1:0] D0,\n    input [N-1:0] D1,\n    output [N-1:0] S);\n\n  wire [N-1:0] S;\n  assign S = (ctrl == 1'b0) ? D0 : D1;\n\nendmodule",
        "module_name": "mux",
        "module_hash": "aa3e7e538911368d7d216d93da54b40b",
        "dataset_index": 15213
      },
      "shift_register_4bit_f4cb6bb5": {
        "rtl_code": "\nmodule shift_register_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input load,\n    input clk,\n    output [3:0] Q\n);\n\nreg [3:0] Q1, Q2, Q3, Q4;\n\nalways @(posedge clk) begin\n    if (load) begin\n        Q1 <= A;\n        Q2 <= B;\n        Q3 <= C;\n        Q4 <= D;\n    end else begin\n        Q1 <= Q2;\n        Q2 <= Q3;\n        Q3 <= Q4;\n        Q4 <= Q;\n    end\nend\n\nassign Q = {Q4,Q3,Q2,Q1}; // fix: concatenate the registers to form the output\n\nendmodule",
        "module_name": "shift_register_4bit",
        "module_hash": "f4cb6bb5ef8da989e53e6076994d6252",
        "dataset_index": 910
      },
      "binary_adder_d54cdb0b": {
        "rtl_code": "module binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] S,\n    output reg C\n);\n\n    always @(*) begin\n        S = A + B;\n        C = (S > 4'b1111) ? 1 : 0;\n    end\n    \nendmodule",
        "module_name": "binary_adder",
        "module_hash": "d54cdb0b8decbdb475f1fcfda71edf8c",
        "dataset_index": 12537
      },
      "cmm_errman_cnt_nfl_en_7a3df2a9": {
        "rtl_code": "\n\n\nmodule cmm_errman_cnt_nfl_en (\n                count,                  index,                  inc_dec_b,\n                enable,\n                rst,\n                clk\n                );\n\n\n  output        count;\n\n  input         index;       input         inc_dec_b;   input         enable;      input         rst;\n  input         clk;\n \n\n  parameter FFD       = 1;        reg           reg_cnt;\n  reg           reg_extra;\n  reg           reg_inc_dec_b;\n  reg           reg_uflow;\n\n  wire          cnt;\n  wire          oflow;\n  wire          uflow;\n\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst)              {reg_extra, reg_cnt} <= #FFD 2'b00;\n    else if (~enable)     {reg_extra, reg_cnt} <= #FFD 2'b00;\n    else if (inc_dec_b)   {reg_extra, reg_cnt} <= #FFD cnt + index;\n    else                  {reg_extra, reg_cnt} <= #FFD cnt - index;\n  end\n\n  assign cnt   = oflow ? 1'b1 : (uflow ? 1'b0 : reg_cnt);\n\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst)  reg_inc_dec_b <= #FFD 1'b0;\n    else      reg_inc_dec_b <= #FFD inc_dec_b;\n  end\n  assign oflow = reg_extra & reg_inc_dec_b;\n\n\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst)\n      reg_uflow <= 1'b0;\n    else\n      reg_uflow <=  #FFD ~count & index & ~inc_dec_b;\n  end\n    \n  assign uflow = reg_uflow;\n\n\n  reg     reg_count;\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst)            reg_count <= #FFD 1'b0;\n    else if (~enable)   reg_count <= #FFD 1'b0;\n    else if (oflow)     reg_count <= #FFD 1'b1;\n    else if (uflow)     reg_count <= #FFD 1'b0;\n    else                reg_count <= #FFD cnt;\n  end\n\n  assign count = reg_count;\n\n\n  endmodule\n",
        "module_name": "cmm_errman_cnt_nfl_en",
        "module_hash": "7a3df2a99993271fa8baac54ae26011c",
        "dataset_index": 25018
      },
      "contador_AD_MES_2dig_1f583c9b": {
        "rtl_code": "\nmodule contador_AD_MES_2dig\n(\ninput wire clk,\ninput wire reset,\ninput wire [3:0] en_count,\ninput wire enUP,\ninput wire enDOWN,\noutput wire [7:0] data_MES\n);\n\nlocalparam N = 4; reg [N-1:0] q_act, q_next;\nwire [N-1:0] count_data;\nreg [3:0] digit1, digit0;\n\nalways@(posedge clk, posedge reset)\nbegin\t\n\t\n\tif(reset)\n\tbegin\n\t\tq_act <= 4'b0;\n\tend\n\t\n\telse\n\tbegin\n\t\tq_act <= q_next;\n\tend\nend\n\n\nalways@*\nbegin\n\n\tif (en_count == 5)\n\tbegin\n\t\tif (enUP)\n\t\tbegin\n\t\t\tif (q_act >= 4'd11) q_next = 4'd0;\n\t\t\telse q_next = q_act + 4'd1;\n\t\tend\n\t\t\n\t\telse if (enDOWN)\n\t\tbegin\n\t\t\tif (q_act == 4'd0) q_next = 4'd11;\n\t\t\telse q_next = q_act - 4'd1;\n\t\tend\n\t\telse q_next = q_act;\n\tend\n\telse q_next = q_act;\n\t\nend\n\nassign count_data = q_act + 1'b1;always@*\nbegin\ncase(count_data)\n\n8'd1: begin digit1 = 4'b0000; digit0 = 4'b0001; end\n8'd2: begin digit1 = 4'b0000; digit0 = 4'b0010; end\n8'd3: begin digit1 = 4'b0000; digit0 = 4'b0011; end\n8'd4: begin digit1 = 4'b0000; digit0 = 4'b0100; end\n8'd5: begin digit1 = 4'b0000; digit0 = 4'b0101; end\n8'd6: begin digit1 = 4'b0000; digit0 = 4'b0110; end\n8'd7: begin digit1 = 4'b0000; digit0 = 4'b0111; end\n8'd8: begin digit1 = 4'b0000; digit0 = 4'b1000; end\n8'd9: begin digit1 = 4'b0000; digit0 = 4'b1001; end\n\n8'd10: begin digit1 = 4'b0001; digit0 = 4'b0000; end\n8'd11: begin digit1 = 4'b0001; digit0 = 4'b0001; end\n8'd12: begin digit1 = 4'b0001; digit0 = 4'b0010; end\n\ndefault:  begin digit1 = 0; digit0 = 0; end\nendcase\nend\n\nassign data_MES = {digit1,digit0};\n\nendmodule\n",
        "module_name": "contador_AD_MES_2dig",
        "module_hash": "1f583c9bf2e74964dbf3f2db79fe9be2",
        "dataset_index": 16239
      },
      "shift_register_d893ac92": {
        "rtl_code": "\nmodule shift_register (\n    input CLK,\n    input SHIFT,\n    input LOAD,\n    input [15:0] DATA_IN,\n    input mode,\n    output [15:0] DATA_OUT\n);\n\nreg [15:0] reg1, reg2, reg3, reg4;\n\nalways @(posedge CLK) begin\n    if (LOAD) begin\n        reg1 <= DATA_IN;\n        reg2 <= reg1;\n        reg3 <= reg2;\n        reg4 <= reg3;\n    end else if (SHIFT) begin\n        if (mode == 1'b0) begin\n            reg1 <= {reg2[14:0], 1'b0};\n            reg2 <= {reg3[14:0], 1'b0};\n            reg3 <= {reg4[14:0], 1'b0};\n            reg4 <= {reg4[14:0], 1'b0};\n        end else begin\n            reg1 <= {reg2[14:0], 1'b1};\n            reg2 <= {reg3[14:0], 1'b1};\n            reg3 <= {reg4[14:0], 1'b1};\n            reg4 <= {reg4[14:0], 1'b1};\n        end\n    end\nend\n\nassign DATA_OUT = reg4;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "d893ac92f0bcd83b52d2b4c8e1261368",
        "dataset_index": 17837
      },
      "adder_subtractor_b12547cf": {
        "rtl_code": "module adder_subtractor (\n    input [3:0] in0,\n    input [3:0] in1,\n    input SUB,\n    output reg [3:0] out\n);\n\nreg [3:0] sum1, sum2;\n\nalways @ (in0, in1, SUB) begin\n    sum1 <= in0 + (SUB ? ~in1 + 1 : in1);\nend\n\nalways @ (sum1) begin\n    sum2 <= sum1;\nend\n\nalways @ (sum2) begin\n    out <= sum2;\nend\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "b12547cf6f54d47f47f7e20392c2d281",
        "dataset_index": 8651
      },
      "counter #_c5e86c82": {
        "rtl_code": "module counter #(\n  parameter n = 4 // number of bits in the counter\n) (\n  input clk,\n  input rst,\n  output reg [n-1:0] count\n);\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    count <= 0;\n  end else begin\n    count <= count + 1;\n  end\nend\n\n\nendmodule",
        "module_name": "counter #",
        "module_hash": "c5e86c82f67313c150082ea8df89078c",
        "dataset_index": 6719
      },
      "rem_charmatch_ae16fad6": {
        "rtl_code": "module rem_charmatch\n    (\n    clk,\n    rst,\n    config_valid,\n    config_char,\n    config_chained,\n    input_valid,\n    input_char,\n    prev_matched,\n    this_matched\n    );\n\n\n  input clk;\n  input rst;\n\n  input config_valid;\n  input [7:0] config_char;\n  input       config_chained;\n\n  input       input_valid;\n  input [7:0] input_char;\n\n  input       prev_matched;\n  output      this_matched;\n\n  reg         char_match;\n  reg [7:0]   char_data;\n  reg         is_chained;\n         \n\n  assign this_matched = char_match;\n  \n  always @(posedge clk)\n  begin\n    \n    if(rst) begin\n      char_data <= 0;\n      char_match <= 0;\n    end    \n    else begin      \n      \n      if (input_valid==1) begin\n        \n        if (char_data==input_char)\n          char_match <= is_chained ? prev_matched : 1;\n        else\n          char_match <= 0;               \n        \n      end\n      \n      if (config_valid==1) begin\n        char_data <= config_char;\n        is_chained <= config_chained;\n        char_match <= 0;\n      end\n      \n\n    end              \t     \n  end\n\nendmodule",
        "module_name": "rem_charmatch",
        "module_hash": "ae16fad6ad17d16954fba7c3566d3c80",
        "dataset_index": 7489
      },
      "bit_selector_7b67583f": {
        "rtl_code": "module bit_selector(\n  input [3:0] in_signal,\n  input control_signal,\n  output reg [1:0] out_signal\n);\n\n  always @ (posedge control_signal) begin\n    if(control_signal) begin\n      out_signal <= ~in_signal[3:2];\n    end\n  end\n\nendmodule",
        "module_name": "bit_selector",
        "module_hash": "7b67583fba4e86f364366f7b95204c43",
        "dataset_index": 11066
      },
      "binary_counter_81aa4594": {
        "rtl_code": "module binary_counter (\n  input clk,\n  input rst,\n  output reg [3:0] count,\n  output reg max_reached\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 4'b0;\n      max_reached <= 1'b0;\n    end\n    else if (count == 4'b1111) begin\n      count <= 4'b0;\n      max_reached <= 1'b1;\n    end\n    else begin\n      count <= count + 1;\n      max_reached <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "81aa45947012eaa85929ada350d5b878",
        "dataset_index": 16809
      },
      "cheat_53eed0b7": {
        "rtl_code": "\nmodule cheat(\n  input clk,\n  input [23:0] SNES_ADDR,\n  input [7:0] SNES_DATA,\n  input SNES_reset_strobe,\n  input snescmd_wr_strobe,\n  input SNES_cycle_start,\n  input [2:0] pgm_idx,\n  input pgm_we,\n  input [31:0] pgm_in,\n  output [7:0] data_out,\n  output cheat_hit,\n  output snescmd_unlock\n);\n\nreg cheat_enable = 0;\nreg nmi_enable = 0;\nreg irq_enable = 0;\nreg holdoff_enable = 0; reg auto_nmi_enable = 1;\nreg auto_irq_enable = 0;\nreg auto_nmi_enable_sync = 0;\nreg auto_irq_enable_sync = 0;\nreg hook_enable_sync = 0;\n\nreg [1:0] sync_delay = 2'b10;\n\nreg [4:0] nmi_usage = 5'h00;\nreg [4:0] irq_usage = 5'h00;\nreg [20:0] usage_count = 21'h1fffff;\n\nreg [29:0] hook_enable_count = 0;\nreg hook_disable = 0;\n\nreg [3:0] unlock_token = 0;\nreg [6:0] temp_unlock_delay = 0;\nreg temp_vector_unlock = 0;\n\nreg [23:0] cheat_addr[5:0];\nreg [7:0] cheat_data[5:0];\nreg [5:0] cheat_enable_mask;\nwire [5:0] cheat_match_bits ={(cheat_enable_mask[5] & (SNES_ADDR == cheat_addr[5])),\n                              (cheat_enable_mask[4] & (SNES_ADDR == cheat_addr[4])),\n                              (cheat_enable_mask[3] & (SNES_ADDR == cheat_addr[3])),\n                              (cheat_enable_mask[2] & (SNES_ADDR == cheat_addr[2])),\n                              (cheat_enable_mask[1] & (SNES_ADDR == cheat_addr[1])),\n                              (cheat_enable_mask[0] & (SNES_ADDR == cheat_addr[0]))};\nwire cheat_addr_match = |cheat_match_bits;\n\nwire [1:0] nmi_match_bits = {SNES_ADDR == 24'h00FFEA, SNES_ADDR == 24'h00FFEB};\nwire [1:0] irq_match_bits = {SNES_ADDR == 24'h00FFEE, SNES_ADDR == 24'h00FFEF};\n\nwire nmi_addr_match = |nmi_match_bits;\nwire irq_addr_match = |irq_match_bits;\n\n\nwire hook_enable = ~|hook_enable_count & ~hook_disable;\n\nassign snescmd_unlock = &unlock_token | temp_vector_unlock;\n\nassign data_out = cheat_match_bits[0] ? cheat_data[0]\n                : cheat_match_bits[1] ? cheat_data[1]\n                : cheat_match_bits[2] ? cheat_data[2]\n                : cheat_match_bits[3] ? cheat_data[3]\n                : cheat_match_bits[4] ? cheat_data[4]\n                : cheat_match_bits[5] ? cheat_data[5]\n                : nmi_match_bits[1] ? 8'hb0\n                : irq_match_bits[1] ? 8'hc4\n                : 8'h2b;\n\nassign cheat_hit = (cheat_enable & cheat_addr_match)\n                   | (hook_enable_sync & (((auto_nmi_enable_sync & nmi_enable) & nmi_addr_match)\n                                           |((auto_irq_enable_sync & irq_enable) & irq_addr_match)));\n\nalways @(posedge clk) usage_count <= usage_count - 1;\n\nalways @(posedge clk) begin\n  if(usage_count == 21'b0) begin\n    nmi_usage <= ~hook_disable & SNES_cycle_start & nmi_match_bits[1];\n    irq_usage <= ~hook_disable & SNES_cycle_start & irq_match_bits[1];\n    if(|nmi_usage & |irq_usage) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(irq_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(nmi_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b0;\n      auto_irq_enable <= 1'b1;\n    end\n  end else begin\n    if(SNES_cycle_start & nmi_match_bits[0] & ~hook_disable) nmi_usage <= nmi_usage + 1;\n    if(SNES_cycle_start & irq_match_bits[0] & ~hook_disable) irq_usage <= irq_usage + 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) begin\n      temp_unlock_delay <= 7'd72;\n      temp_vector_unlock <= 1'b1;\n    end else begin\n      if (|temp_unlock_delay) temp_unlock_delay <= temp_unlock_delay - 1;\n      if (temp_unlock_delay == 7'd0) begin\n        temp_vector_unlock <= 1'b0;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) sync_delay <= 2'b10;\n    else begin\n      if (|sync_delay) sync_delay <= sync_delay - 1;\n      if (sync_delay == 2'b00) begin\n        auto_nmi_enable_sync <= auto_nmi_enable;\n        auto_irq_enable_sync <= auto_irq_enable;\n        hook_enable_sync <= hook_enable;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_wr_strobe) begin\n    if(SNES_ADDR[8:0] == 9'h1f4 && SNES_DATA == 8'h48) unlock_token[0] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f5 && SNES_DATA == 8'h75) unlock_token[1] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f6 && SNES_DATA == 8'h72) unlock_token[2] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f7 && SNES_DATA == 8'h7a) unlock_token[3] <= 1'b1;\n    else if(SNES_ADDR[8:2] == 9'b1111101) unlock_token <= 4'b0000;\n  end else if(SNES_reset_strobe) unlock_token <= 4'b0000;\nend\n\nalways @(posedge clk) begin\n  if((snescmd_unlock & snescmd_wr_strobe & ~|SNES_ADDR[8:0] & (SNES_DATA == 8'h85))\n     | (holdoff_enable & SNES_reset_strobe)) begin\n    hook_enable_count <= 30'd880000000;\n  end else if (|hook_enable_count) begin\n    hook_enable_count <= hook_enable_count - 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_unlock & snescmd_wr_strobe) begin\n    if(~|SNES_ADDR[8:0]) begin\n      case(SNES_DATA)\n        8'h82: cheat_enable <= 1;\n        8'h83: cheat_enable <= 0;\n        8'h84: {nmi_enable, irq_enable} <= 2'b00;\n      endcase\n    end else if(SNES_ADDR[8:0] == 9'h1fd) begin\n      hook_disable <= SNES_DATA[0];\n    end\n  end else if(pgm_we) begin\n    if(pgm_idx < 6) begin\n      cheat_addr[pgm_idx] <= pgm_in[31:8];\n      cheat_data[pgm_idx] <= pgm_in[7:0];\n    end else if(pgm_idx == 6) begin cheat_enable_mask <= pgm_in[5:0];\n    end else if(pgm_idx == 7) begin {holdoff_enable, irq_enable, nmi_enable, cheat_enable} <= ({holdoff_enable, irq_enable, nmi_enable, cheat_enable} & ~pgm_in[7:4])\n                                                                 | pgm_in[3:0];\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "cheat",
        "module_hash": "53eed0b75cfd5eb7e9cd93cba205b245",
        "dataset_index": 25213
      },
      "traffic_light_652d0b2d": {
        "rtl_code": "module traffic_light(clk, reset, ped_cross, green, yellow, red, ped_red, ped_green);\n  input clk, reset, ped_cross;\n  output reg green, yellow, red, ped_red, ped_green;\n  \n  parameter GREEN_TIME = 500_000_000; // 10 seconds\n  parameter YELLOW_TIME = 100_000_000; // 2 seconds\n  parameter RED_TIME = 500_000_000; // 10 seconds\n  \n  reg [2:0] state = 3'b001; // initial state\n  \n  reg [29:0] green_count = 0; // counter for green light\n  reg [29:0] yellow_count = 0; // counter for yellow light\n  reg [29:0] red_count = 0; // counter for red light\n  reg [29:0] ped_red_count = 0; // counter for pedestrian red light\n  reg [29:0] ped_green_count = 0; // counter for pedestrian green light\n  \n  always @(posedge clk)\n  begin\n    if (reset)\n      begin\n        state <= 3'b001;\n        green_count <= 0;\n        yellow_count <= 0;\n        red_count <= 0;\n        ped_red_count <= 0;\n        ped_green_count <= 0;\n        green <= 1'b1;\n        yellow <= 1'b0;\n        red <= 1'b0;\n        ped_red <= 1'b0;\n        ped_green <= 1'b0;\n      end\n    else\n      begin\n        case (state)\n          3'b001: // green light\n            begin\n              green_count <= green_count + 1;\n              if (green_count == GREEN_TIME)\n                begin\n                  state <= 3'b010;\n                  yellow_count <= 0;\n                  green_count <= 0;\n                  green <= 1'b0;\n                  yellow <= 1'b1;\n                end\n            end\n          3'b010: // yellow light\n            begin\n              yellow_count <= yellow_count + 1;\n              if (yellow_count == YELLOW_TIME)\n                begin\n                  state <= 3'b011;\n                  red_count <= 0;\n                  yellow_count <= 0;\n                  yellow <= 1'b0;\n                  red <= 1'b1;\n                end\n            end\n          3'b011: // red light\n            begin\n              red_count <= red_count + 1;\n              if (ped_cross)\n                begin\n                  state <= 3'b101;\n                  ped_red_count <= 0;\n                  red_count <= 0;\n                  red <= 1'b0;\n                  ped_red <= 1'b1;\n                end\n              else if (red_count == RED_TIME)\n                begin\n                  state <= 3'b001;\n                  green_count <= 0;\n                  red_count <= 0;\n                  red <= 1'b0;\n                  green <= 1'b1;\n                end\n            end\n          3'b101: // pedestrian red light\n            begin\n              ped_red_count <= ped_red_count + 1;\n              if (ped_red_count == RED_TIME)\n                begin\n                  state <= 3'b110;\n                  ped_red_count <= 0;\n                  ped_green_count <= 0;\n                  ped_red <= 1'b0;\n                  ped_green <= 1'b1;\n                end\n            end\n          3'b110: // pedestrian green light\n            begin\n              ped_green_count <= ped_green_count + 1;\n              if (ped_green_count == GREEN_TIME)\n                begin\n                  state <= 3'b111;\n                  ped_green_count <= 0;\n                  ped_green <= 1'b0;\n                  ped_red <= 1'b1;\n                end\n            end\n          3'b111: // pedestrian red light\n            begin\n              ped_red_count <= ped_red_count + 1;\n              if (ped_red_count == RED_TIME)\n                begin\n                  state <= 3'b001;\n                  green_count <= 0;\n                  ped_red_count <= 0;\n                  ped_red <= 1'b0;\n                  green <= 1'b1;\n                end\n            end\n        endcase\n      end\n  end\nendmodule",
        "module_name": "traffic_light",
        "module_hash": "652d0b2dcdfe4e2314b624910755eb30",
        "dataset_index": 1137
      },
      "input_fifo_blk_mem_gen_generic_cstr #_4b83eaf3": {
        "rtl_code": "\nmodule input_fifo_blk_mem_gen_generic_cstr #(\n    parameter WIDTH = 8,\n    DEPTH = 256\n) (\n    input [WIDTH-1:0] D,\n    input clk,\n    input WEA,\n    input tmp_ram_rd_en,\n    input srst,\n    output reg [WIDTH-1:0] Q,\n    output reg [9:0] gc0_count_d1_reg,\n    input [WIDTH-1:0] din\n);\n\nlocalparam ADDR_WIDTH = $clog2(DEPTH);\n\nreg [WIDTH-1:0] mem [0:DEPTH-1];\nreg [ADDR_WIDTH-1:0] head = 0;\nreg [ADDR_WIDTH-1:0] tail = 0;\n\nalways @ (posedge clk) begin\n    if (srst) begin\n        head <= 0;\n        tail <= 0;\n    end else begin\n        if (WEA && (head != tail || gc0_count_d1_reg == 0)) begin\n            mem[head] <= WEA;\n            head <= head + 1;\n        end\n        if (tmp_ram_rd_en && head != tail) begin\n            tail <= tail + 1;\n            Q <= mem[tail-1]; // mem[tail-1] should be used instead of din here\n        end\n    end\nend\n\nalways @ (posedge clk) begin\n    if (srst) begin\n       gc0_count_d1_reg <= 0;\n    end\n    else if (WEA && (head != tail || gc0_count_d1_reg == 0)) begin\n        gc0_count_d1_reg <= gc0_count_d1_reg + 1; // Moved here\n    end\n    if (tmp_ram_rd_en && head != tail) begin\n        gc0_count_d1_reg <= gc0_count_d1_reg - 1; // Moved here\n    end\nend\n\nendmodule",
        "module_name": "input_fifo_blk_mem_gen_generic_cstr #",
        "module_hash": "4b83eaf3935fade81844d2ea61ef90cc",
        "dataset_index": 165
      },
      "alu_flags_5a127a0a": {
        "rtl_code": "\nmodule alu_flags \n#(parameter DATA_WIDTH = 32)\n(\n    input [DATA_WIDTH-1:0] srcA,\n    input [DATA_WIDTH-1:0] srcB,\n    input [3:0] aluop,\n    output zero,\n    output of,\n    output uof\n);\n\n    wire [DATA_WIDTH-1:0] sum, diff;\n    wire carry1, carry2;\n    \n    assign {carry1, sum} = srcA + srcB;    assign {carry2, diff} = srcA - srcB;    assign zero = (srcA == srcB);\n    assign of = (aluop == 4'd5) ? ((srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & ~sum[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & sum[DATA_WIDTH-1]))\n                : (aluop == 4'd6) ? ((srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & ~diff[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & diff[DATA_WIDTH-1]))\n                : 0;\n    assign uof = (aluop == 4'd5) ? (carry1)\n                : (aluop == 4'd6) ? (carry2)\n                : 0;\n    \nendmodule ",
        "module_name": "alu_flags",
        "module_hash": "5a127a0a14f95a01a4b352513b343acf",
        "dataset_index": 7672
      },
      "Arithmetic_Logic_Unit_661c2b4c": {
        "rtl_code": "module Arithmetic_Logic_Unit (\n    input [4:0] ctrl,\n    input [15:0] data_in_A,\n    input [15:0] data_in_B,\n    output reg [15:0] data_out\n    );\n\n    always @* begin\n        case(ctrl)\n            1: data_out = data_in_A + data_in_B;\n            2: data_out = data_in_A - data_in_B;\n            3: data_out = data_in_A & data_in_B;\n            4: data_out = data_in_A | data_in_B;\n            5: data_out = data_in_A ^ data_in_B;\n            6: data_out = ~data_in_A;\n            7: data_out = ~data_in_B;\n            8: data_out = data_in_A << 1;\n            9: data_out = data_in_A >> 1;\n            10: data_out = data_in_B << 1;\n            11: data_out = data_in_B >> 1;\n            12: data_out = (data_in_A == data_in_B) ? 1 : 0;\n            13: data_out = (data_in_A < data_in_B) ? 1 : 0;\n            14: data_out = (data_in_A > data_in_B) ? 1 : 0;\n            15: data_out = (data_in_A <= data_in_B) ? 1 : 0;\n            16: data_out = (data_in_A >= data_in_B) ? 1 : 0;\n            default: data_out = 0;\n        endcase\n    end\n\nendmodule",
        "module_name": "Arithmetic_Logic_Unit",
        "module_hash": "661c2b4c17ad8bab7c253ec2abcaedf0",
        "dataset_index": 12388
      },
      "binary_counter_9630d491": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input rst,\n    output reg Q1,\n    output reg Q0\n);\n\n    reg D1, D0;\n\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            D1 <= 1'b0;\n            D0 <= 1'b0;\n        end else begin\n            D1 <= Q0;\n            D0 <= ~Q0;\n        end\n    end\n\n    always @*\n    begin\n        Q1 = D1;\n        Q0 = D0;\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "9630d491f4c8563bdf5365db56e61e57",
        "dataset_index": 7087
      },
      "full_adder_bb84d585": {
        "rtl_code": "module full_adder (\n  input A,\n  input B,\n  input C_in,\n  output Sum,\n  output C_out\n);\n\n  assign Sum = A ^ B ^ C_in;\n  assign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule\n\nmodule ripple_carry_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input C_in,\n  output [3:0] Sum,\n  output C_out\n);\n\n  wire [3:0] carry;\n  full_adder fa0(A[0], B[0], C_in, Sum[0], carry[0]);\n  full_adder fa1(A[1], B[1], carry[0], Sum[1], carry[1]);\n  full_adder fa2(A[2], B[2], carry[1], Sum[2], carry[2]);\n  full_adder fa3(A[3], B[3], carry[2], Sum[3], C_out);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "bb84d5854d2ef0c4f223b3865c2c1c87",
        "dataset_index": 15744
      },
      "data_converter_831cfc66": {
        "rtl_code": "\nmodule data_converter (\n    input [3:0] data_in,\n    output [1:0] data_out\n);\n\n    assign data_out = (data_in <= 4) ? 2'b00 : \n                     (data_in <= 8) ? 2'b01 : \n                     (data_in <= 12) ? 2'b10 : 2'b11;\n\nendmodule\n",
        "module_name": "data_converter",
        "module_hash": "831cfc66f7116c8fae456aa1c03221ad",
        "dataset_index": 18126
      },
      "cur_ram_blk_94ad0456": {
        "rtl_code": "\nmodule cur_ram_blk\n    (\n    input hclk, \n    input write,\n    input [8:0] cpu_address, \n    input [7:0] cpu_data_in, \n    input pixclk,\n    input [8:0] cur_address, \n    output reg [7:0] cur_data_out, \n    output [7:0] cpu_data_out\n    );\n\n    reg [7:0] ram_data [0:511];\n\n    always @(posedge hclk) begin\n        if (write) begin\n            ram_data[cpu_address] <= cpu_data_in;\n        end\n    end\n\n    always @(posedge pixclk) begin\n        if (!write) begin\n            cur_data_out <= ram_data[cur_address];\n        end\n    end\n    \n    assign cpu_data_out = ram_data[cpu_address];\n\nendmodule",
        "module_name": "cur_ram_blk",
        "module_hash": "94ad0456f884a5b1f446eae5266d2438",
        "dataset_index": 11578
      },
      "shift_register_923e60e2": {
        "rtl_code": "module shift_register (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] data_in,\n    output reg [15:0] q\n);\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        q <= 0;\n    end else if (load) begin\n        q <= {data_in, q[15:8]};\n    end else begin\n        q <= {q[14:0], q[15]};\n    end\nend\n\nendmodule\n\nmodule d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n\nalways @(negedge clk, posedge reset) begin\n    if (reset) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n\nmodule functional_module (\n    input [15:0] shift_register_out,\n    input [0:0] d_flip_flop_out,\n    output reg [15:0] q\n);\n\nalways @(shift_register_out, d_flip_flop_out) begin\n    q <= {shift_register_out, d_flip_flop_out};\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] data_in,\n    input d,\n    output [15:0] q\n);\n\nwire [15:0] shift_register_out;\nwire [0:0] d_flip_flop_out;\n\nshift_register shift_reg(clk, reset, load, data_in, shift_register_out);\nd_flip_flop d_ff(clk, reset, d, d_flip_flop_out);\nfunctional_module func_mod(shift_register_out, d_flip_flop_out, q);\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "923e60e200d90a25c605be0cd3621f09",
        "dataset_index": 16956
      },
      "adder_subtractor_867da251": {
        "rtl_code": "module adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    input clk,\n    output reg [3:0] Q\n);\n\nreg [3:0] A_reg, B_reg, Q_reg;\nreg mode_reg;\n\nalways @ (posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    mode_reg <= mode;\n    \n    if (mode_reg == 0) begin\n        Q_reg <= A_reg + B_reg;\n    end else begin\n        Q_reg <= A_reg - B_reg;\n    end\nend\n\nalways @*\nbegin\n    Q = Q_reg;\nend\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "867da2518094f3eec1abea89aabc27a0",
        "dataset_index": 9285
      },
      "majority_3_24a3dff2": {
        "rtl_code": "module majority_3 (\n    input A,\n    input B,\n    input C,\n    output X\n);\n\n    wire AB, AC, BC;\n\n    assign AB = A & B;\n    assign AC = A & C;\n    assign BC = B & C;\n\n    assign X = (AB | AC | BC);\n\nendmodule",
        "module_name": "majority_3",
        "module_hash": "24a3dff2beb83aa80a76efd1f6998078",
        "dataset_index": 9731
      },
      "sky130_fd_sc_lp__fahcin_1dc8933f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__fahcin (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CIN\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CIN ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire ci          ;\n    wire xor0_out_SUM;\n    wire a_b         ;\n    wire a_ci        ;\n    wire b_ci        ;\n    wire or0_out_COUT;\n\n    not not0 (ci          , CIN            );\n    xor xor0 (xor0_out_SUM, A, B, ci       );\n    buf buf0 (SUM         , xor0_out_SUM   );\n    and and0 (a_b         , A, B           );\n    and and1 (a_ci        , A, ci          );\n    and and2 (b_ci        , B, ci          );\n    or  or0  (or0_out_COUT, a_b, a_ci, b_ci);\n    buf buf1 (COUT        , or0_out_COUT   );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__fahcin",
        "module_hash": "1dc8933f86a28adad9d324a293f91447",
        "dataset_index": 22978
      },
      "generic_dpram_78f07734": {
        "rtl_code": "`define VENDOR_FPGA\nmodule generic_dpram(\n\trclk, rrst, rce, oe, raddr, do,\n\twclk, wrst, wce, we, waddr, di\n);\n\n\tparameter aw = 5;  parameter dw = 16; input           rclk;  input           rrst;  input           rce;   input           oe;\t   input  [aw-1:0] raddr; output [dw-1:0] do;    input          wclk;  input          wrst;  input          wce;   input          we;    input [aw-1:0] waddr; input [dw-1:0] di;    `ifdef VENDOR_FPGA\n\treg [dw-1:0] mem [(1<<aw) -1:0]; reg [aw-1:0] ra;                 always @(posedge rclk)\n\t  if (rce)\n\t    ra <= #1 raddr;\n\n\tassign do = mem[ra];\n\n\talways@(posedge wclk)\n\t\tif (we && wce)\n\t\t\tmem[waddr] <= #1 di;\n\n`else\n\n`ifdef VENDOR_XILINX\n\txilinx_ram_dp xilinx_ram(\n\t\t.CLKA(rclk),\n\t\t.RSTA(rrst),\n\t\t.ENA(rce),\n\t\t.ADDRA(raddr),\n\t\t.DIA( {dw{1'b0}} ),\n\t\t.WEA(1'b0),\n\t\t.DOA(do),\n\n\t\t.CLKB(wclk),\n\t\t.RSTB(wrst),\n\t\t.ENB(wce),\n\t\t.ADDRB(waddr),\n\t\t.DIB(di),\n\t\t.WEB(we),\n\t\t.DOB()\n\t);\n\n\tdefparam\n\t\txilinx_ram.dwidth = dw,\n\t\txilinx_ram.awidth = aw;\n\n`else\n\n`ifdef VENDOR_ALTERA\n\taltera_ram_dp altera_ram(\n\t\t.rdclock(rclk),\n\t\t.rdclocken(rce),\n\t\t.rdaddress(raddr),\n\t\t.q(do),\n\n\t\t.wrclock(wclk),\n\t\t.wrclocken(wce),\n\t\t.wren(we),\n\t\t.wraddress(waddr),\n\t\t.data(di)\n\t);\n\n\tdefparam\n\t\taltera_ram.dwidth = dw,\n\t\taltera_ram.awidth = aw;\n\n`else\n\n`ifdef VENDOR_ARTISAN\n\n\tart_hsdp #(dw, 1<<aw, aw) artisan_sdp(\n\t\t.qa(do),\n\t\t.clka(rclk),\n\t\t.cena(~rce),\n\t\t.wena(1'b1),\n\t\t.aa(raddr),\n\t\t.da( {dw{1'b0}} ),\n\t\t.oena(~oe),\n\n\t\t.qb(),\n\t\t.clkb(wclk),\n\t\t.cenb(~wce),\n\t\t.wenb(~we),\n\t\t.ab(waddr),\n\t\t.db(di),\n\t\t.oenb(1'b1)\n\t);\n\n`else\n\n`ifdef VENDOR_AVANT\n\n\tavant_atp avant_atp(\n\t\t.web(~we),\n\t\t.reb(),\n\t\t.oeb(~oe),\n\t\t.rcsb(),\n\t\t.wcsb(),\n\t\t.ra(raddr),\n\t\t.wa(waddr),\n\t\t.di(di),\n\t\t.do(do)\n\t);\n\n`else\n\n`ifdef VENDOR_VIRAGE\n\n\tvirage_stp virage_stp(\n\t\t.CLKA(rclk),\n\t\t.MEA(rce_a),\n\t\t.ADRA(raddr),\n\t\t.DA( {dw{1'b0}} ),\n\t\t.WEA(1'b0),\n\t\t.OEA(oe),\n\t\t.QA(do),\n\n\t\t.CLKB(wclk),\n\t\t.MEB(wce),\n\t\t.ADRB(waddr),\n\t\t.DB(di),\n\t\t.WEB(we),\n\t\t.OEB(1'b1),\n\t\t.QB()\n\t);\n\n`else\n\n\treg\t[dw-1:0]\tmem [(1<<aw)-1:0]; reg\t[dw-1:0]\tdo_reg;            assign do = (oe & rce) ? do_reg : {dw{1'bz}};\n\n\talways @(posedge rclk)\n\t\tif (rce)\n          \t\tdo_reg <= #1 (we && (waddr==raddr)) ? {dw{1'b x}} : mem[raddr];\n\n\talways @(posedge wclk)\n\t\tif (wce && we)\n\t\t\tmem[waddr] <= #1 di;\n\n\n\ttask print_ram;\n\tinput [aw-1:0] start;\n\tinput [aw-1:0] finish;\n\tinteger rnum;\n  \tbegin\n    \t\tfor (rnum=start;rnum<=finish;rnum=rnum+1)\n      \t\t\t$display(\"Addr %h = %h\",rnum,mem[rnum]);\n  \tend\n\tendtask\n\n`endif `endif `endif `endif `endif `endif endmodule\n\n`ifdef VENDOR_ALTERA\n\tmodule altera_ram_dp(\n\t\tdata,\n\t\twraddress,\n\t\trdaddress,\n\t\twren,\n\t\twrclock,\n\t\twrclocken,\n\t\trdclock,\n\t\trdclocken,\n\t\tq) ;\n\n\t\tparameter awidth = 7;\n\t\tparameter dwidth = 8;\n\n\t\tinput [dwidth -1:0] data;\n\t\tinput [awidth -1:0] wraddress;\n\t\tinput [awidth -1:0] rdaddress;\n\t\tinput               wren;\n\t\tinput               wrclock;\n\t\tinput               wrclocken;\n\t\tinput               rdclock;\n\t\tinput               rdclocken;\n\t\toutput [dwidth -1:0] q;\n\n\t\tsyn_dpram_rowr #(\n\t\t\t\"UNUSED\",\n\t\t\tdwidth,\n\t\t\tawidth,\n\t\t\t1 << awidth\n\t\t)\n\t\taltera_dpram_model (\n\t\t\t.RdClock(rdclock),\n\t\t\t.RdClken(rdclocken),\n\t\t\t.RdAddress(rdaddress),\n\t\t\t.RdEn(1'b1),\n\t\t\t.Q(q),\n\n\t\t\t.WrClock(wrclock),\n\t\t\t.WrClken(wrclocken),\n\t\t\t.WrAddress(wraddress),\n\t\t\t.WrEn(wren),\n\t\t\t.Data(data)\n\t\t);\n\n\t\tendmodule\n`endif `ifdef VENDOR_XILINX\n\tmodule xilinx_ram_dp (\n\t\tADDRA,\n\t\tCLKA,\n\t\tADDRB,\n\t\tCLKB,\n\t\tDIA,\n\t\tWEA,\n\t\tDIB,\n\t\tWEB,\n\t\tENA,\n\t\tENB,\n\t\tRSTA,\n\t\tRSTB,\n\t\tDOA,\n\t\tDOB)  ;\n\n\tparameter awidth = 7;\n\tparameter dwidth = 8;\n\n\tinput               CLKA;\n\tinput               RSTA;\n\tinput               ENA;\n\tinput [awidth-1:0]  ADDRA;\n\tinput [dwidth-1:0]  DIA;\n\tinput               WEA;\n\toutput [dwidth-1:0] DOA;\n\n\tinput               CLKB;\n\tinput               RSTB;\n\tinput               ENB;\n\tinput [awidth-1:0]  ADDRB;\n\tinput [dwidth-1:0]  DIB;\n\tinput               WEB;\n\toutput [dwidth-1:0] DOB;\n\n\tC_MEM_DP_BLOCK_V1_0 #(\n\t\tawidth,\n\t\tawidth,\n\t\t1,\n\t\t1,\n\t\t\"0\",\n\t\t1 << awidth,\n\t\t1 << awidth,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t\"\",\n\t\t16,\n\t\t0,\n\t\t0,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\tdwidth,\n\t\tdwidth)\n\txilinx_dpram_model (\n\t\t.ADDRA(ADDRA),\n\t\t.CLKA(CLKA),\n\t\t.ADDRB(ADDRB),\n\t\t.CLKB(CLKB),\n\t\t.DIA(DIA),\n\t\t.WEA(WEA),\n\t\t.DIB(DIB),\n\t\t.WEB(WEB),\n\t\t.ENA(ENA),\n\t\t.ENB(ENB),\n\t\t.RSTA(RSTA),\n\t\t.RSTB(RSTB),\n\t\t.DOA(DOA),\n\t\t.DOB(DOB));\n\n\t\tendmodule\n`endif ",
        "module_name": "generic_dpram",
        "module_hash": "78f07734d7c51c81f313e50d0a414f19",
        "dataset_index": 11015
      },
      "Calculator_c8cb23a8": {
        "rtl_code": "module Calculator(input signed [7:0] a, b, input [1:0] op, output reg [7:0] result, output reg error);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = a + b;\n        2'b01: result = a - b;\n        2'b10: result = a * b;\n        2'b11: begin\n            if(b == 0) begin\n                error = 1;\n                result = 8'h00;\n            end\n            else begin\n                error = 0;\n                result = a / b;\n            end\n        end\n        default: result = 8'h00;\n    endcase\n    // check for overflow in addition and subtraction\n    if(op == 2'b00 || op == 2'b01) begin\n        if((a[7] == b[7]) && (result[7] != a[7])) begin\n            error = 1;\n        end\n        else begin\n            error = 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "Calculator",
        "module_hash": "c8cb23a8a6b49e1609e2dfc693ed0cd4",
        "dataset_index": 8222
      },
      "decoder_34197546": {
        "rtl_code": "module decoder (\n    input [2:0] in,\n    input enable,\n    output [7:0] out\n);\n\n    assign out = (enable) ? {~in[2], ~in[1], ~in[0], in[2], in[1], in[0], 1'b0, 1'b0} : 8'b0;\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "341975466e3a0d7fcf368eb36566ecad",
        "dataset_index": 9673
      },
      "shift_register_14ebba6b": {
        "rtl_code": "module shift_register(\n  input clk,\n  input load,\n  input shift,\n  input [3:0] data_in,\n  output reg [3:0] data_out\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      data_out <= data_in;\n    end else if (shift) begin\n      data_out <= {data_out[2:0], 1'b0};\n    end\n  end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "14ebba6b5005f4b83405e854db994b8c",
        "dataset_index": 16660
      },
      "binary_to_gray_88303d14": {
        "rtl_code": "module binary_to_gray(\n  input [3:0] bin,\n  output reg [3:0] gray\n);\n\n  always @(*) begin\n    gray[0] = bin[0];\n    gray[1] = bin[0] ^ bin[1];\n    gray[2] = bin[1] ^ bin[2];\n    gray[3] = bin[2] ^ bin[3];\n  end\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "88303d14d6296391f0dd858bf8522687",
        "dataset_index": 20561
      },
      "four_bit_selector_02dbe433": {
        "rtl_code": "module four_bit_selector(input [3:0] a, output reg [1:0] o);\n    wire [3:0] a_shifted;\n    assign a_shifted = a >> 2; // shift input right by 2 bits\n    \n    always @(*) begin\n        if (a < 5) begin\n            o = a[1:0]; // output 2 least significant bits of input\n        end else begin\n            o = a_shifted[3:2]; // output 2 most significant bits of shifted input\n        end\n    end\nendmodule",
        "module_name": "four_bit_selector",
        "module_hash": "02dbe43377b179a9d236eb2a53877298",
        "dataset_index": 9271
      },
      "sp_mux_4to1_sel2_7_1 #_1aa6c4da": {
        "rtl_code": "\n\nmodule sp_mux_4to1_sel2_7_1 #(\nparameter\n    ID                = 0,\n    NUM_STAGE         = 1,\n    din1_WIDTH       = 32,\n    din2_WIDTH       = 32,\n    din3_WIDTH       = 32,\n    din4_WIDTH       = 32,\n    din5_WIDTH         = 32,\n    dout_WIDTH            = 32\n)(\n    input  [6 : 0]     din1,\n    input  [6 : 0]     din2,\n    input  [6 : 0]     din3,\n    input  [6 : 0]     din4,\n    input  [1 : 0]    din5,\n    output [6 : 0]   dout);\n\nwire [1 : 0]     sel;\nwire [6 : 0]         mux_1_0;\nwire [6 : 0]         mux_1_1;\nwire [6 : 0]         mux_2_0;\n\nassign sel = din5;\n\nassign mux_1_0 = (sel[0] == 0)? din1 : din2;\nassign mux_1_1 = (sel[0] == 0)? din3 : din4;\n\nassign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;\n\nassign dout = mux_2_0;\n\nendmodule\n",
        "module_name": "sp_mux_4to1_sel2_7_1 #",
        "module_hash": "1aa6c4da3a3dc7a9e5f7b2a150ddb4cb",
        "dataset_index": 19243
      },
      "gray_code_371b0409": {
        "rtl_code": "module gray_code(\n    input clk,\n    output reg [3:0] gray_out\n);\n\nreg [3:0] binary_out;\n\ninitial begin\n    binary_out = 0;\n    gray_out = 0;\nend\n\nalways @(posedge clk) begin\n    binary_out <= binary_out + 1;\n    gray_out <= binary_out ^ (binary_out >> 1);\nend\n\nendmodule",
        "module_name": "gray_code",
        "module_hash": "371b04096917cbd65fa656e03742434e",
        "dataset_index": 2759
      },
      "i2c_master_fe805415": {
        "rtl_code": "\nmodule i2c_master (\n  input SCL,\n  input SDA_OUT,\n  output SDA_OUT_EN,\n  input SDA_IN,\n  output SDA_IN_EN,\n  output ACK\n);\n\n  reg [7:0] data_out;\n  reg [2:0] state;\n\n  assign SDA_OUT_EN = (state == 1 || state == 2 || state == 4) ? 1 : 0;\n  assign SDA_IN_EN = (state == 2 || state == 3 || state == 5) ? 1 : 0;\n\n  assign ACK = (state == 3 || state == 5) ? ~SDA_IN : 1;\n\n  always @(posedge SCL) begin\n    case (state)\n      0: begin // idle\n        if (SDA_OUT == 0) begin\n          state <= 1;\n          data_out <= 8'b10100000; // slave address + write bit\n        end\n      end\n      1: begin // start condition\n        state <= 2;\n      end\n      2: begin // send slave address\n        if (ACK == 0) begin\n          state <= 3;\n        end\n      end\n      3: begin // send data\n        if (ACK == 0) begin\n          state <= 4;\n          data_out <= 8'b11000000; // slave address + read bit\n        end\n      end\n      4: begin // repeated start condition\n        state <= 5;\n      end\n      5: begin // receive data\n        if (ACK == 0) begin\n          state <= 6;\n        end\n      end\n      6: begin // stop condition\n        state <= 0;\n      end\n    endcase\n  end\n\nendmodule\n\nmodule i2c_slave (\n  input SCL,\n  input SDA_IN,\n  output SDA_OUT,\n  output SDA_OUT_EN,\n  input SDA_IN_EN,\n  input ACK\n);\n\n  reg [7:0] data_in;\n  reg [2:0] state;\n\n  assign SDA_OUT_EN = (state == 2 || state == 4) ? 1 : 0;\n\n  always @(posedge SCL) begin\n    case (state)\n      0: begin // idle\n        if (SDA_IN == 0) begin\n          state <= 1;\n        end\n      end\n      1: begin // start condition\n        state <= 2;\n      end\n      2: begin // receive slave address\n        if (ACK == 0) begin\n          state <= 3;\n        end\n      end\n      3: begin // receive data\n        if (ACK == 0) begin\n          state <= 4;\n        end\n      end\n      4: begin // send data\n        state <= 5;\n      end\n      5: begin // stop condition\n        state <= 0;\n      end\n    endcase\n  end\n\n  always @(posedge SCL) begin\n    if (SDA_IN_EN) begin\n      data_in <= {data_in[6:0], SDA_IN};\n    end\n  end\n\n  assign SDA_OUT = data_in[7];\n\nendmodule\n",
        "module_name": "i2c_master",
        "module_hash": "fe805415fe7f18ff22461da4ca94090f",
        "dataset_index": 4726
      },
      "acl_stream_to_vector_converter_3be34f34": {
        "rtl_code": "module acl_stream_to_vector_converter(\n\t\t\tclock, clock2x, resetn,\n\t\t\tdataa, y1, y2,\n\t\t\tvalid_in, valid_out, stall_in, stall_out);\n\tparameter WIDTH = 32;\n\t\n  input clock, clock2x, resetn, valid_in, stall_in;\n\tinput [WIDTH-1:0] dataa;\n  output [WIDTH-1:0] y1;\n  output [WIDTH-1:0] y2;\n\toutput valid_out;\n\toutput stall_out;\n\n  reg [WIDTH-1:0] dataa_sr ;\n  reg sr_in_valid;\n  wire stall_sr;  \n  \n  always@(posedge clock2x or negedge resetn)\n  begin\n    if(~resetn)\n    begin\n      sr_in_valid <= 1'b0;\n      dataa_sr <= {WIDTH{1'bx}};\n    end\n    else\n    begin\n      if (~stall_sr)\n        sr_in_valid <= 1'b0;\n      else if (~sr_in_valid)\n        sr_in_valid <= valid_in;\n\n      if (~sr_in_valid)\n        dataa_sr <= dataa;\n    end\n  end\n  assign stall_out = sr_in_valid;\n  \n  reg sel, sel_ref ;\n  initial\n  begin\n    sel = 1'b0;\n\t  sel_ref = 1'b0;\n  end\n  always@(posedge clock2x)\n  begin\n\t  sel <= ~sel;\n  end\n  \n  reg [WIDTH-1:0] in_a2 ;\n  reg [WIDTH-1:0] in_a1 ;\n  reg valid_a2, valid_a1 ;\n  wire stall_shift;\n  \n  always@(posedge clock2x or negedge resetn)\n  begin\n    if (~resetn)\n\t  begin\n\t\t  valid_a2 <= 1'b0;\n\t\t  valid_a1 <= 1'b0;\n\t\t  in_a1 <= {WIDTH{1'bx}};\n\t\t  in_a2 <= {WIDTH{1'bx}};\n\t  end\n\t  else\n\t  begin\n\t    if (~valid_a2)\n\t\t  begin\n\t\t    valid_a2 <= sr_in_valid | valid_in;\n\t\t    in_a2 <= sr_in_valid ? dataa_sr : dataa;\n\t\t    valid_a1 <= 1'b0;\n\t\t  end\n\t\t  else if ((~valid_a1) & (sr_in_valid | valid_in))\n\t\t  begin\n\t\t    valid_a2 <= 1'b1;\n\t\t    in_a2 <= sr_in_valid ? dataa_sr : dataa;\t\t  \n\t\t    valid_a1 <= valid_a2;\n\t\t    in_a1 <= in_a2;\t\t  \t\t  \n\t\t  end\n      else if (valid_a1 & valid_a2 & ~stall_shift)\n      begin\n\t\t    valid_a2 <= sr_in_valid | valid_in;\n\t\t    in_a2 <= sr_in_valid ? dataa_sr : dataa;\n\t\t    valid_a1 <= 1'b0;\n      end\n\t  end\n  end\n\n  assign stall_sr = valid_a1 & stall_shift;\n  \n  reg [WIDTH-1:0] y2_r ;\n  reg [WIDTH-1:0] y1_r ;\n  reg valid_crossing ;\n  wire stall_last;\n  wire w = (sel_ref == sel); always@(posedge clock or negedge resetn)\n  begin\n    if(~resetn)\n\t  begin\n\t    sel_ref <= 1'b0;\n\t\t  valid_crossing <= 1'b0;\n\t\t  y1_r <= {WIDTH{1'bx}};\n\t\t  y2_r <= {WIDTH{1'bx}};\n\t  end\n\t  else\n\t  begin\n\t\t  if (~valid_crossing | ~stall_last)\n\t\t  begin\n\t\t    y1_r <= in_a1;\n\t\t    y2_r <= in_a2;\n\t\t    valid_crossing <= valid_a1;\n\t\t  end\n\t    sel_ref <= sel;\n\t  end\n  end\n  \n  assign stall_shift = ~w | valid_crossing & stall_last;\n  \n  reg valid_out_sr;\n  reg [WIDTH-1:0] y1_sr ;\n  reg [WIDTH-1:0] y2_sr ;\n  assign stall_last = valid_out_sr;\n  always@(posedge clock or negedge resetn)\n  begin\n    if(~resetn)\n    begin\n      valid_out_sr <= 1'b0;\n      y1_sr <= {WIDTH{1'bx}};\n      y2_sr <= {WIDTH{1'bx}};      \n    end\n    else\n    begin\n      if (~stall_in)\n        valid_out_sr <= 1'b0;\n      else if (~valid_out_sr)\n        valid_out_sr <= valid_crossing;\n      \n      if (~valid_out_sr)\n      begin\n        y1_sr <= y1_r;\n        y2_sr <= y2_r;\n      end      \n    end\n  end\n  \n  assign y1 = valid_out_sr ? y1_sr : y1_r;\n  assign y2 = valid_out_sr ? y2_sr : y2_r;\n  assign valid_out = valid_out_sr | valid_crossing;\n\t\nendmodule\n",
        "module_name": "acl_stream_to_vector_converter",
        "module_hash": "3be34f348fddee91a992cb787ef9726c",
        "dataset_index": 25703
      },
      "RCA_N4_17_74e8e3da": {
        "rtl_code": "module RCA_N4_17 ( A, B, Ci, S, Co );\n  input [3:0] A;\n  input [3:0] B;\n  output [3:0] S;\n  input Ci;\n  output Co;\n\n  wire   [3:1] CTMP;\n\n  FA_71 FAI_1 ( .A(A[0]), .B(B[0]), .Ci(Ci), .S(S[0]), .Co(CTMP[1]) );\n  FA_70 FAI_2 ( .A(A[1]), .B(B[1]), .Ci(CTMP[1]), .S(S[1]), .Co(CTMP[2]) );\n  FA_69 FAI_3 ( .A(A[2]), .B(B[2]), .Ci(CTMP[2]), .S(S[2]), .Co(CTMP[3]) );\n  FA_68 FAI_4 ( .A(A[3]), .B(B[3]), .Ci(CTMP[3]), .S(S[3]), .Co(Co) );\n  \nendmodule\n\nmodule FA_71 ( A, B, Ci, S, Co );\n  input A, B, Ci;\n  output S, Co;\n  assign S = A ^ B ^ Ci;\n  assign Co = (A & B) | (A & Ci) | (B & Ci);\nendmodule\n\nmodule FA_70 ( A, B, Ci, S, Co );\n  input A, B, Ci;\n  output S, Co;\n  assign S = A ^ B ^ Ci;\n  assign Co = (A & B) | (A & Ci) | (B & Ci);\nendmodule\n\nmodule FA_69 ( A, B, Ci, S, Co );\n  input A, B, Ci;\n  output S, Co;\n  assign S = A ^ B ^ Ci;\n  assign Co = (A & B) | (A & Ci) | (B & Ci);\nendmodule\n\nmodule FA_68 ( A, B, Ci, S, Co );\n  input A, B, Ci;\n  output S, Co;\n  assign S = A ^ B ^ Ci;\n  assign Co = (A & B) | (A & Ci) | (B & Ci);\nendmodule",
        "module_name": "RCA_N4_17",
        "module_hash": "74e8e3da4767cf04bf4e05e3126a0d8a",
        "dataset_index": 11579
      },
      "regfile_1e82dbe7": {
        "rtl_code": "module regfile (\n    input [31:0] wr_data,\n    input wr_en,\n    input [2:0] wr_addr,\n    input [2:0] rd_addr,\n    input clk,\n    output reg [31:0] rd_data,\n    output [1:0] rd_guards ,\n    output [1:0] rd_guardsok \n);\n\nreg [31:0] registers [0:7];\n\nalways @ (posedge clk) begin\n    if (wr_en) begin\n        registers[wr_addr] <= wr_data;\n    end\nend\n\nalways @ (*) begin\n    rd_data = registers[rd_addr];\nend\n\nassign rd_guards = {rd_data[0], 1'b1};\n\nassign rd_guardsok[0] = 1'b1;\nassign rd_guardsok[1] = rd_data[0];\n\nendmodule",
        "module_name": "regfile",
        "module_hash": "1e82dbe70033aa63a6596eed393ab0fd",
        "dataset_index": 4496
      },
      "sync_bits_1e8e6541": {
        "rtl_code": "\nmodule sync_bits\n(\n\tinput [NUM_OF_BITS-1:0] in,\n\tinput out_resetn,\n\tinput out_clk,\n\toutput [NUM_OF_BITS-1:0] out\n);\n\nparameter NUM_OF_BITS = 1;\nparameter ASYNC_CLK = 1;\n\nreg [NUM_OF_BITS-1:0] cdc_sync_stage1 = 'h0;\nreg [NUM_OF_BITS-1:0] cdc_sync_stage2 = 'h0;\n\nalways @(posedge out_clk)\nbegin\n\tif (out_resetn == 1'b0) begin\n\t\tcdc_sync_stage1 <= 'b0;\n\t\tcdc_sync_stage2 <= 'b0;\n\tend else begin\n\t\tcdc_sync_stage1 <= in;\n\t\tcdc_sync_stage2 <= cdc_sync_stage1;\n\tend\nend\n\nassign out = ASYNC_CLK ? cdc_sync_stage2 : in;\n\nendmodule\n",
        "module_name": "sync_bits",
        "module_hash": "1e8e65414129a951356b07eb8616e334",
        "dataset_index": 16531
      },
      "UART_TX_d399fa68": {
        "rtl_code": "module UART_TX(\n    input [7:0] RxD_par, // 8 bit data\n    input RxD_start,\n    input RTS, // USB clear to send (active high)\n    input sys_clk,\n    input BaudTick,\n    output reg TxD_ser\n    );\n\n    //State machine\n    reg [3:0] state=0;\n    reg [7:0] RxD_buff=0;\n    \n    always @(posedge sys_clk)\n    begin\n        if (RxD_start & state<2) begin\n            RxD_buff <= RxD_par; // Buffer data received\n        end else if (state[3] & BaudTick) begin\n            RxD_buff <= (RxD_buff >> 1); // Shift a bit at every baud tick during transmission\n        end\n    \n        case(state)\n            4'b0000: if(RxD_start & RTS) state <= 4'b0010;//Initiate process when data is valied and USB is ready to receive\n            4'b0010: if(BaudTick) state <= 4'b0011; // Synchronize to baudtick, \n            4'b0011: if(BaudTick) state <= 4'b1000; //start (state !< 2 , state[3]=0 ie TxD = 0)\n            4'b1000: if(BaudTick) state <= 4'b1001; //bit 0\n            4'b1001: if(BaudTick) state <= 4'b1010; //bit 1\n            4'b1010: if(BaudTick) state <= 4'b1011; //bit 2 \n            4'b1011: if(BaudTick) state <= 4'b1100; //bit 3\n            4'b1100: if(BaudTick) state <= 4'b1101; //bit 4\n            4'b1101: if(BaudTick) state <= 4'b1110; //bit 5\n            4'b1110: if(BaudTick) state <= 4'b1111; //bit 6\n            4'b1111: if(BaudTick) state <= 4'b0001; //bit 7\n            4'b0001: if(BaudTick) begin //stop\n                            if(RxD_start & RTS) begin\n                                state <= 4'b0011; // Data already synchronized to baudtick\n                            end else begin\n                                state <= 4'b0000; // (state < 2 ie TxD = 1)\n                            end\n                        end                        \n            default: if(BaudTick) state <= 4'b0000; \n        endcase\n            \n    end\n    \n    //reg TxD_ser;\n    always @(posedge sys_clk)\n    begin\n        // Filter according to state\n        TxD_ser <= (state < 3) | (state[3] & RxD_buff[0]); // Send it through a register\n    end\n\nendmodule",
        "module_name": "UART_TX",
        "module_hash": "d399fa68dd39810517dc6fbf4eecf02c",
        "dataset_index": 3779
      },
      "rx_engine  #_92d56348": {
        "rtl_code": "\n\n`define FPGA_ADDR_MIN 'h0000\n`define FPGA_ADDR_MAX 'h0400\n\n\nmodule rx_engine  #(\n  parameter C_DATA_WIDTH = 64                                    ) (\n  input                         clk_i,                           input                         rst_n,                           input  [C_DATA_WIDTH-1:0]     m_axis_rx_tdata,\n  input                         m_axis_rx_tlast,\n  input                         m_axis_rx_tvalid,\n  output reg                    m_axis_rx_tready,\n  input                         compl_done_i,                    output reg                    req_compl_wd_o,                  output reg [31:0]             tx_reg_data_o,                   output reg [2:0]              req_tc_o,                        output reg                    req_td_o,                        output reg                    req_ep_o,                        output reg [1:0]              req_attr_o,                      output reg [9:0]              req_len_o,                       output reg [15:0]             req_rid_o,                       output reg [7:0]              req_tag_o,                       output reg [6:0]              req_addr_o,                      output reg [31:0]             reg_data_o,                      output reg                    reg_data_valid_o,                output reg [9:0]              reg_addr_o,                      input                         fpga_reg_wr_ack_i,               output reg                    fpga_reg_rd_o,                   input      [31:0]             reg_data_i,                      input                         fpga_reg_rd_ack_i,               output reg [7:0]              cpld_tag_o,\n  output reg [31:0]             user_data_o,                     output reg [19:0]             user_addr_o,                     output reg                    user_wr_req_o,                   input      [31:0]             user_data_i,                     input                         user_rd_ack_i,                   output reg                    user_rd_req_o,                   output reg [63:0]             rcvd_data_o,                     output reg                    rcvd_data_valid_o                );\n\n    wire               sop;\n    reg [2:0]          state;\n\t reg                in_packet_q;\n    reg [31:0]         rx_tdata_p;\n    reg                rcv_data;\n\t reg                lock_tag;\n\t reg                user_wr_ack;\n\t \n    localparam  IDLE           = 'd0,\n\t            SEND_DATA      = 'd1,\n               WAIT_FPGA_DATA = 'd2,\n               WAIT_USR_DATA  = 'd3,\n               WAIT_TX_ACK    = 'd4,\n               WR_DATA        = 'd5,\n               RX_DATA        = 'd6;\n\t\t\t\t\t\n    localparam MEM_RD = 7'b0000000,\n               MEM_WR = 7'b1000000,\n               CPLD   = 7'b1001010;\n\t\t\t\t\t\n    assign sop            = !in_packet_q && m_axis_rx_tvalid; always@(posedge clk_i)\n    begin\n      if(!rst_n)\n        in_packet_q <= 1'b0;\n      else if (m_axis_rx_tvalid && m_axis_rx_tready && m_axis_rx_tlast)\n        in_packet_q <= 1'b0;\n      else if (sop && m_axis_rx_tready)\n        in_packet_q <= 1'b1;\n    end\n\n   \t\t\t\t\t\n    always @ ( posedge clk_i ) \n    begin\n        if (!rst_n ) begin\n            m_axis_rx_tready <=  1'b0;\n            req_compl_wd_o   <=  1'b0;\n            state            <=  IDLE;\n            user_rd_req_o    <=  1'b0;\n            user_wr_req_o    <=  1'b0;\n            rcv_data         <=  1'b0;\n            fpga_reg_rd_o    <=  1'b0;\n            reg_data_valid_o <=  1'b0;\n        end \n        else \n        begin\n            case (state)\n                IDLE : begin\n                    m_axis_rx_tready <=  1'b1;                  reg_data_valid_o <=  1'b0;\n\t\t\t\t\t\t  user_wr_req_o    <=  1'b0;\n\t\t\t\t\t\t  req_len_o        <=  m_axis_rx_tdata[9:0];  req_attr_o       <=  m_axis_rx_tdata[13:12];\n                    req_ep_o         <=  m_axis_rx_tdata[14];\n                    req_td_o         <=  m_axis_rx_tdata[15];\n                    req_tc_o         <=  m_axis_rx_tdata[22:20];\n                    req_rid_o        <=  m_axis_rx_tdata[63:48];\n                    req_tag_o        <=  m_axis_rx_tdata[47:40];\n                    if (sop) \n                    begin                                       if(m_axis_rx_tdata[30:24] == MEM_RD)      state    <=  SEND_DATA;\n\t\t\t\t\t\t      else if(m_axis_rx_tdata[30:24] == MEM_WR) state    <=  WR_DATA; \n                        else if(m_axis_rx_tdata[30:24] == CPLD)   begin\n                           state    <=  RX_DATA;\n\t\t\t\t\t\t\t\t\tlock_tag <=  1'b1;\n\t\t\t\t\t\t\t\tend\t\n                    end\n                end\n                SEND_DATA: begin\n                    if (m_axis_rx_tvalid && m_axis_rx_tlast)\n                    begin\n                        req_addr_o         <=  m_axis_rx_tdata[6:0];\n                        m_axis_rx_tready   <=  1'b0;              user_addr_o        <=  m_axis_rx_tdata[19:0];\n                        reg_addr_o         <=  m_axis_rx_tdata[9:0];\n                        if(m_axis_rx_tdata[21:0] < `FPGA_ADDR_MAX) begin\n                            state         <=  WAIT_FPGA_DATA; \n                            fpga_reg_rd_o <=  1'b1;   \n                        end\n                        else\n                        begin\n                           state         <=  WAIT_USR_DATA;\n                           user_rd_req_o <=  1'b1;\n                        end\n                    end\n                end\n                WAIT_FPGA_DATA:begin\n\t\t\t\t\t     fpga_reg_rd_o    <=  1'b0; \n                    if(fpga_reg_rd_ack_i)\n                    begin \n                        req_compl_wd_o   <=  1'b1;        tx_reg_data_o    <=  reg_data_i;\n                        state            <=  WAIT_TX_ACK; end\n                end\n                WAIT_USR_DATA:begin\n                    if(user_rd_ack_i)\n                    begin\n                        user_rd_req_o  <=  1'b0;\n                        req_compl_wd_o <=  1'b1;\n                        tx_reg_data_o  <=  user_data_i;\n                        state          <=  WAIT_TX_ACK;\n                    end\n                end\n                WAIT_TX_ACK: begin\n                    if(compl_done_i)\n                    begin\n                       state            <=  IDLE;\n                       req_compl_wd_o   <=  1'b0;\n\t\t\t\t\t\t\t  m_axis_rx_tready <=  1'b1;\n                    end\n                end\n\t\t\t\tWR_DATA:begin\n                    reg_data_valid_o <=   1'b0;\n                    user_wr_req_o    <=   1'b0;\n                    if (m_axis_rx_tvalid && m_axis_rx_tlast)\n                    begin\n\t\t\t\t\t\t      m_axis_rx_tready <=  1'b0;\n                        reg_data_o       <=   m_axis_rx_tdata[63:32];\n                        reg_addr_o       <=   m_axis_rx_tdata[9:0];\n                        user_data_o      <=   m_axis_rx_tdata[63:32];\n                        user_addr_o      <=   m_axis_rx_tdata[19:0];\n                        if(m_axis_rx_tdata[21:0] < `FPGA_ADDR_MAX)  begin  \n                            reg_data_valid_o <=   1'b1;    \n                        end\n                        else\n                        begin\n                            user_wr_req_o    <=   1'b1;\n                        end\n                    end\n                    if (fpga_reg_wr_ack_i | user_wr_ack)\n                    begin\n                        state            <=   IDLE;   \n                        m_axis_rx_tready <=   1'b1;\t\t\t\t\t\t\t\t\n                    end\n\t\t\t\tend\n            RX_DATA:begin\n\t\t\t\t    lock_tag <= 1'b0;\n                if(m_axis_rx_tvalid && m_axis_rx_tlast)\n                begin\n                    rcv_data  <=  1'b0;\n                    state     <=  IDLE;\n\t\t\t\t\tm_axis_rx_tready <=  1'b1;\n                end\n                else\n                    rcv_data  <=  1'b1;\n            end\n            endcase\n        end\n    end\n\n    always @(posedge clk_i)\n    begin\n        rx_tdata_p <= m_axis_rx_tdata[63:32];\n\t\t  user_wr_ack <= user_wr_req_o;\n        if(rcv_data & m_axis_rx_tvalid)\n        begin\n            rcvd_data_valid_o <= 1'b1;   \n            rcvd_data_o       <= {rx_tdata_p,m_axis_rx_tdata[31:0]};\n        end\n        else\n            rcvd_data_valid_o <= 1'b0;\n    end\n\t \n\t always @(posedge clk_i)\n\t begin\n\t     if(lock_tag)\n\t       cpld_tag_o <= m_axis_rx_tdata[15:8];\n\t end\n\nendmodule \n",
        "module_name": "rx_engine  #",
        "module_hash": "92d5634889d23803f57b5f304afbe1f8",
        "dataset_index": 22845
      },
      "_4bit_binary_counter_a4074364": {
        "rtl_code": "module _4bit_binary_counter(\n    input CP,\n    input M,\n    input [3:0] D,\n    input LD_n,\n    input CLR_n,\n    output reg [3:0] Q,\n    output reg Qcc_n\n);\n    always @(posedge CP) begin\n        if (CLR_n == 0) begin\n            Q <= 0;\n        end else if (LD_n == 0) begin\n            Q <= D;\n        end else if (M == 1) begin\n            Q <= Q + 1;\n        end\n        Qcc_n <= ~Q[3];\n    end\nendmodule",
        "module_name": "_4bit_binary_counter",
        "module_hash": "a40743649a33032cdadfd1c91ee797b5",
        "dataset_index": 9939
      },
      "fifo_4c86d65a": {
        "rtl_code": "module fifo (\n    input clock,\n    input [31:0] data,\n    input rdreq,\n    input wrreq,\n    output empty,\n    output full,\n    output reg [31:0] q\n);\n\nreg [31:0] memory [0:1023];\nreg [9:0] head = 0;\nreg [9:0] tail = 0;\nreg [9:0] count = 0;\n\nassign empty = (count == 0);\nassign full = (count == 1024);\n\nalways @(posedge clock) begin\n    if (wrreq && !full) begin\n        memory[head] <= data;\n        head <= (head == 1023) ? 0 : head + 1;\n        count <= count + 1;\n    end\n    if (rdreq && !empty) begin\n        q <= memory[tail];\n        tail <= (tail == 1023) ? 0 : tail + 1;\n        count <= count - 1;\n    end\nend\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "4c86d65a63bd21d45b9ac367cded6b85",
        "dataset_index": 16382
      },
      "mux_2_1_709fe3ef": {
        "rtl_code": "\nmodule mux_2_1 (\n    input A,\n    input B,\n    input SEL,\n    output reg OUT\n);\n\nalways @(*) begin\n    if (SEL == 1'b0)\n        OUT = A;\n    else\n        OUT = B;\nend\n\nendmodule",
        "module_name": "mux_2_1",
        "module_hash": "709fe3ef181feb47a30e1462cdf1f5db",
        "dataset_index": 6093
      },
      "shift_register_3e3a93a6": {
        "rtl_code": "\nmodule shift_register (\n    input wire clk,\n    input wire [3:0] inp,\n    output wire [15:0] arr_out\n);\n\n    reg [15:0] arr;\n\n    assign arr_out = {arr[15:4], inp[3:0]};\n\n    always @(posedge clk) begin\n        arr <= {arr[14:0], inp[3]}; \n    end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "3e3a93a65fb108deb9a03bcd5e789e73",
        "dataset_index": 8013
      },
      "KIA_51b1d78f": {
        "rtl_code": "\n\n`define KQSTAT\t\t0\n`define KQDATA\t\t1\n\nmodule KIA(\n\tinput CLK_I,\n\tinput RES_I,\n\tinput [0:0] ADR_I,\n\tinput WE_I,\n\tinput CYC_I,\n\tinput STB_I,\n\toutput ACK_O,\n\toutput [7:0] DAT_O,\n\n\tinput D_I,\n\tinput C_I\n);\n\n\treg [7:0] queue[0:15];\n\treg [3:0] rp;\n\treg [3:0] wp;\n\twire [3:0] next_wp = wp+1;\n\twire queue_full = (next_wp == rp);\n\twire queue_empty = (rp == wp);\n\n\treg ack;\n\tassign ACK_O = ack;\n\nalways @(posedge CLK_I) begin\n\t\tif(~RES_I) begin\n\t\t\tack <= CYC_I & STB_I;\n\t\tend else begin\n\t\t\tack <= 0;\n\t\tend\n\tend\n\nwire kqstat_addressed\t= (ADR_I == `KQSTAT) & ack & ~WE_I;\n\twire kqdata_addressed\t= (ADR_I == `KQDATA) & ack & ~WE_I;\n\twire kqpop_addressed\t\t= (ADR_I == `KQDATA) & ack & WE_I & ~queue_empty;\n\twire [7:0] kqstat_value\t= {6'h00, queue_full, queue_empty};\n\twire [7:0] kqdata_value\t= queue[rp];\n\twire [3:0] next_rp\t\t= RES_I ? 4'h0 : (kqpop_addressed ? rp+1 : rp);\n\tassign DAT_O = ({8{kqstat_addressed}} & kqstat_value) | ({8{kqdata_addressed}} & kqdata_value);\n\n\talways @(posedge CLK_I) begin\n\t\trp <= next_rp;\n\tend\n\nreg [10:0] sr;\n\treg cur_C;\n\treg prev_C;\n\treg [3:0] bits_received;\n\twire ps2clk_edge = ~cur_C && prev_C;\n\twire waiting_for_start_bit = bits_received == 0;\n\twire waiting_for_stop_bit = bits_received == 10;\n\twire is_start_bit = D_I == 0;\n\twire is_stop_bit = D_I == 1;\n\n\talways @(posedge CLK_I) begin\n\t\tif(~RES_I) begin\n\t\t\tcur_C <= C_I;\n\t\t\tif(ps2clk_edge && waiting_for_start_bit && is_start_bit) begin\n\t\t\t\tsr <= {D_I, sr[10:1]};\n\t\t\t\tbits_received <= bits_received+1;\n\t\t\tend\n\t\t\tif(ps2clk_edge && ~waiting_for_stop_bit && ~waiting_for_start_bit) begin\n\t\t\t\tsr <= {D_I, sr[10:1]};\n\t\t\t\tbits_received <= bits_received+1;\n\t\t\tend\n\t\t\tif(ps2clk_edge && waiting_for_stop_bit && is_stop_bit && ~queue_full) begin\n\t\t\t\tqueue[wp] <= sr[9:2];\n\t\t\t\twp <= next_wp;\n\t\t\t\tbits_received <= 0;\n\t\t\tend\n\t\t\tif(ps2clk_edge && waiting_for_stop_bit && is_stop_bit && queue_full) begin\n\t\t\t\tbits_received <= 0;\n\t\t\tend\n\t\t\tprev_C <= cur_C;\n\t\tend else begin\n\t\t\tsr <= 11'h7FF;\n\t\t\tprev_C <= 1;\n\t\t\tcur_C <= 1;\n\t\t\tbits_received <= 0;\n\t\t\twp <= 0;\n\t\tend\n\tend\n\n\tendmodule\n",
        "module_name": "KIA",
        "module_hash": "51b1d78f061086a8ad3badf2de202eeb",
        "dataset_index": 24589
      },
      "mux_4to1_051bc86a": {
        "rtl_code": "module mux_4to1 (\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output reg Y\n);\n\n    always @*\n        case (S)\n            2'b00: Y = A;\n            2'b01: Y = B;\n            2'b10: Y = C;\n            2'b11: Y = D;\n        endcase\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "051bc86acabf8d02582f2a3cd727c738",
        "dataset_index": 5117
      },
      "Calculator_8a3eb966": {
        "rtl_code": "module Calculator (\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    input [1:0] op,\n    output reg [7:0] result\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op)\n            2'b00: result <= A + B;\n            2'b01: result <= A - B;\n            2'b10: result <= A * B;\n            2'b11: result <= A / B;\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "Calculator",
        "module_hash": "8a3eb966a9c5ce5777ec89eec46858cc",
        "dataset_index": 20437
      },
      "Select_AB_83b65bfd": {
        "rtl_code": "\n\nmodule Select_AB\n          (\n           in_select,\n           in1,\n           in2,\n           A,\n           B\n          );\n\n\n  input   in_select;\n  input   in1;\n  input   in2;\n  output  A;\n  output  B;\n\n\n  wire Switch_out1;\n  wire Switch1_out1;\n\n\n  assign Switch_out1 = (in_select == 1'b0 ? in2 :\n              in1);\n\n\n\n  assign A = Switch_out1;\n\n  assign Switch1_out1 = (in_select == 1'b0 ? in1 :\n              in2);\n\n\n\n  assign B = Switch1_out1;\n\nendmodule  ",
        "module_name": "Select_AB",
        "module_hash": "83b65bfdf62d764ae2039a7ca7cbde31",
        "dataset_index": 15666
      },
      "Registro_Universal_e6cebc98": {
        "rtl_code": "\nmodule Registro_Universal\n\n\t(\n\t\tinput wire aumentar, input wire disminuir, input wire clk, input wire reset, input wire chip_select, output wire out_aumentar, output wire out_disminuir );\n\nreg aumentar_actual,disminuir_actual,aumentar_next,disminuir_next;\n\nalways@(posedge clk, posedge reset)\nbegin\n\tif(reset)\n\t\tbegin\n\t\taumentar_actual <= 0;\n\t\tdisminuir_actual <= 0;\n\t\tend\n\telse\n\tbegin\n\t\taumentar_actual <= aumentar_next;\n\t\tdisminuir_actual <= disminuir_next;\n\tend\nend\n\nalways@*\n\tbegin\n\t\n\tcase(chip_select)\n\t\n\t1'b0: begin\n\taumentar_next = aumentar_actual;\n\tdisminuir_next = disminuir_actual;\n\tend\n\t1'b1: begin\n\taumentar_next = aumentar;\n\tdisminuir_next = disminuir;\n\tend\n\tendcase\n\t\n\tend\n\nassign out_aumentar = aumentar_actual;\nassign out_disminuir = disminuir_actual;\n\nendmodule\n\n",
        "module_name": "Registro_Universal",
        "module_hash": "e6cebc984de11508d566f343355baa0d",
        "dataset_index": 2747
      },
      "rrab_35c73827": {
        "rtl_code": "module rrab (\n    output reg [1:0] grant,\n    input [1:0] request,\n    input clk,\n    input reset_n\n);\n    parameter S0 = 2'b00;\n    parameter S1 = 2'b01;\n    parameter S2 = 2'b10;\n    parameter S3 = 2'b11;\n    \n    \n    reg [1:0] grant_i;\n    reg last_winner, winner;\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            last_winner <= 1'b0;\n            grant       <= S0;\n        end else begin\n            last_winner <= winner;\n            grant       <= grant_i;\n        end\n    end\n\n    always @(*) begin\n        case(request) \n            S0: begin\n                grant_i = S0;\n            end\n            S1: begin\n                grant_i = S1;\n            end\n            S2: begin\n                grant_i = S2;\n            end\n            S3: begin\n                if (last_winner == 1'b0) begin\n                    grant_i = S2;\n                end else begin\n                    grant_i = S1;\n                end\n            end\n        endcase\n    end\n\n    always @(*) begin\n        if (grant_i == S0) begin\n            winner = last_winner;\n        end else begin\n            winner = grant_i[1];\n        end\n    end\nendmodule\n",
        "module_name": "rrab",
        "module_hash": "35c738274321a203eee1474220ecefc5",
        "dataset_index": 23000
      },
      "alu_1ae42d2e": {
        "rtl_code": "\nmodule alu (\n   op,\n   a,\n   b,\n   y,\n   cin,\n   cout,\n   zout\n);\n\ninput  [3:0]\top;\t// ALU Operation\ninput  [7:0]\ta;\t// 8-bit Input a\ninput  [7:0]\tb;\t// 8-bit Input b\noutput [7:0]\ty;\t// 8-bit Output\ninput\t\tcin;\noutput\t\tcout;\noutput\t\tzout;\n\n// Reg declarations for outputs\nreg\t\tcout;\nreg\t\tzout;\nreg [7:0]\ty;\n\n// Internal declarations\nreg\t\taddercout; // Carry out straight from the adder itself.\n\nparameter  ALUOP_ADD        = 4'b0000;\nparameter  ALUOP_SUB        = 4'b1000;\nparameter  ALUOP_AND        = 4'b0001;\nparameter  ALUOP_OR         = 4'b0010;\nparameter  ALUOP_XOR        = 4'b0011;\nparameter  ALUOP_COM        = 4'b0100;\nparameter  ALUOP_ROR        = 4'b0101;\nparameter  ALUOP_ROL        = 4'b0110;\nparameter  ALUOP_SWAP       = 4'b0111;\n\n\nalways @(a or b or cin or op) begin\n   case (op)\n      ALUOP_ADD:  {addercout,  y}  <= a + b;\n      ALUOP_SUB:  {addercout,  y}  <= a - b; // Carry out is really \"borrow\"\n      ALUOP_AND:  {addercout,  y}  <= {1'b0, a & b};\n      ALUOP_OR:   {addercout,  y}  <= {1'b0, a | b};\n      ALUOP_XOR:  {addercout,  y}  <= {1'b0, a ^ b};\n      ALUOP_COM:  {addercout,  y}  <= {1'b0, ~a};\n      ALUOP_ROR:  {addercout,  y}  <= {a[0], cin, a[7:1]};\n      ALUOP_ROL:  {addercout,  y}  <= {a[7], a[6:0], cin};\n      ALUOP_SWAP: {addercout,  y}  <= {1'b0, a[3:0], a[7:4]};\n      default:    {addercout,  y}  <= {1'b0, 8'h00};\n   endcase\nend\n\nalways @(y)\n   zout <= (y == 8'h00);\n\nalways @(addercout or op)\n   if (op == ALUOP_SUB) cout <= ~addercout; // Invert adder's carry to get borrow\n   else                 cout <=  addercout;\n\nendmodule",
        "module_name": "alu",
        "module_hash": "1ae42d2e94d461cf11bfa919d6c1978c",
        "dataset_index": 14423
      },
      "AvalonBusInterface_e8735ae7": {
        "rtl_code": "\nmodule AvalonBusInterface(\n   input rst, clk,\n   input [31:0] bus_addr,\n   input [3:0] bus_byte_enable,\n   input bus_read, bus_write,\n   input [31:0] bus_write_data,\n   output reg bus_ack,\n   output reg [31:0] bus_read_data\n);\n\n   reg [31:0] audio_fifo_address = 32'h00003044;\n   reg [31:0] audio_left_address = 32'h00003048;\n   reg [31:0] audio_right_address = 32'h0000304c;\n   reg [31:0] counter;\n\n   always @(posedge clk) begin\n      if (rst) begin\n         bus_read_data <= 32'b0;\n         bus_ack <= 1'b0;\n         counter <= 32'b0;\n      end\n      else begin\n         if (bus_read) begin\n            if (bus_addr == audio_fifo_address) begin\n               bus_read_data <= (8'd3 << 24) | 8'd2;\n            end\n            else if (bus_addr == audio_right_address) begin\n               counter <= counter + 1;\n               bus_read_data <= counter;\n            end\n         end\n         bus_ack <= bus_read | bus_write;\n      end\n   end\n\nendmodule",
        "module_name": "AvalonBusInterface",
        "module_hash": "e8735ae75795a06cc4726b05d73142b6",
        "dataset_index": 12844
      },
      "unknown_module_e2bfb04e": {
        "rtl_code": "module\tpsdos\t( input\t\tRx,\n\t\t\t          input\t\tCLKOUT,\n\t\t\t          output\treg\tRx_error,\n\t\t\t          output\t[7:0]\tDATA,\n\t\t        \t  output\treg\tDONE\n\t\t        );\n\treg\t[8:0]\tregis;\n\treg\t[7:0]\tregis0;\n\treg\t[3:0]\ti;\n\treg\t[3:0]\tj;\n\treg\tinit;\n\tinitial\n\tbegin\n    i=0;\n    j=0;\n    init=0;\n    regis=0;\n    regis0=0;\n    Rx_error=0;\n    DONE=0;\n  end\n\n\n\n\n  always@(posedge CLKOUT)\n  begin\n\t\t        if(!Rx&&!i)\n\t\t        begin\n\t\t\t        init<=1;\n              end\n        if(init)\n\t\t        begin\n\t\t\t              regis[i]=Rx;\n\t\t\t              i<=i+1;\n\t\t\t              if(regis[i]&&(i<8))\n\t\t\t              begin\n\t\t\t\t              j=j+1;\n\t\t\t              end\n\t\t        end\n                if(i==9)\n\t\t      begin\n\t\t\t      if((!(j%2)&&(regis[8]))||((j%2)&&(!regis[8])))\n\t\t\t      begin\n\t\t\t\t      Rx_error=0;\n\t\t\t\t      regis0={regis[7:0]};\n\t\t\t\t      DONE=1;\n\t\t\t      end\n\t\t\t      else\n\t\t\t      begin\n\t\t\t\t      Rx_error=1;\n\t\t\t\t      regis0=0;\n\t\t\t\t      DONE=0;\n\t\t\t      end\n\t\t\t      j=0;\n\t\t\t      i<=0;\n\t\t\t      init<=0;\n\t\t      end\n\tend\n\tassign\tDATA=regis0;\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "e2bfb04efe757d1073623f93ccfb50be",
        "dataset_index": 24466
      },
      "VerilogModule_a2a8f248": {
        "rtl_code": "\nmodule VerilogModule\n   (out,\n    count_d1_reg,\n    m_axi_wdata,\n    aclk,\n    s_dclk_o,\n    Q,\n    m_axi_wready,\n    burst_count_reg,\n    tx_fifo_wr,\n    tx_fifowren_reg,\n    tx_fifo_dataout_reg);\n  output [0:0]out;\n  output [7:0]count_d1_reg;\n  output [31:0]m_axi_wdata;\n  input aclk;\n  input s_dclk_o;\n  input [0:0]Q;\n  input m_axi_wready;\n  input [8:0]burst_count_reg;\n  input tx_fifo_wr;\n  input tx_fifowren_reg;\n  input [31:0]tx_fifo_dataout_reg;\n\n  reg [31:0]m_axi_wdata_reg;\n\n  assign out = 1'b0;\n\n  always @(posedge aclk) begin\n    if (m_axi_wready) begin\n      m_axi_wdata_reg <= tx_fifo_dataout_reg;\n    end\n  end\n\n  assign m_axi_wdata = m_axi_wdata_reg;\n\n  assign count_d1_reg = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n\nendmodule",
        "module_name": "VerilogModule",
        "module_hash": "a2a8f2486dcc312a4bcdfab8b3453aa5",
        "dataset_index": 14261
      },
      "up_counter_7ca2dad7": {
        "rtl_code": "module up_counter(clk, rst, count);\n  input clk;\n  input rst;\n  output reg [3:0] count;\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\nendmodule",
        "module_name": "up_counter",
        "module_hash": "7ca2dad7406b3f435181e7651de965ca",
        "dataset_index": 15095
      },
      "adder_4_2_a5063c72": {
        "rtl_code": "module adder_4_2 (\n    input [3:0] A,\n    output [1:0] Y\n);\n\n    wire [2:0] sum;\n    wire [1:0] constant = 2'b10;\n\n    assign sum = A + constant;\n    assign Y = (sum > 3) ? 2'b11 : sum[1:0];\n\nendmodule",
        "module_name": "adder_4_2",
        "module_hash": "a5063c72c60b602862419619f5702582",
        "dataset_index": 14865
      },
      "adder_8bit_23e5fe7d": {
        "rtl_code": "\nmodule adder_8bit(\n  input [7:0] A,\n  input [7:0] B,\n  output [7:0] sum\n);\n\n  wire [7:0] temp_sum;\n  wire carry_in = 1'b0;\n  wire carry_out;\n\n  assign temp_sum[0] = A[0] ^ B[0];\n  assign carry_out = A[0] & B[0];\n\n  genvar i;\n  for (i = 1; i < 8; i = i + 1) begin : adder_loop\n    assign temp_sum[i] = A[i] ^ B[i] ^ carry_in;\n    assign carry_in = (A[i] & B[i]) | (A[i] & carry_out) | (B[i] & carry_out);\n  end\n\n  assign sum = temp_sum;\n\nendmodule",
        "module_name": "adder_8bit",
        "module_hash": "23e5fe7d2c0d7b10d59a505354ed4550",
        "dataset_index": 14407
      },
      "shift_register_a9ba1821": {
        "rtl_code": "module shift_register\n  (clk, reset, load, data_in, shift, data_out);\n   \n   parameter width = 8;\n   \n   input clk;\n   input reset;\n   input load;\n   input shift;\n   input [width-1:0] data_in;\n   output [width-1:0] data_out;\n   \n   reg [width-1:0] reg_data;\n   \n   always @(posedge clk) begin\n      if (reset) begin\n         reg_data <= 0;\n      end\n      else begin\n         if (load) begin\n            reg_data <= data_in;\n         end\n         else if (shift) begin\n            reg_data <= {reg_data[width-2:0], shift ? 1'b0 : reg_data[width-1]};\n         end\n      end\n   end\n   \n   assign data_out = reg_data;\n   \nendmodule",
        "module_name": "shift_register",
        "module_hash": "a9ba18210495e5d719303fecfdbf92a9",
        "dataset_index": 15635
      },
      "top__1cacd1c8": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out,\n    input [1:0] select\n);\n\n    wire [31:0] ff_out;\n    wire [31:0] red_out;\n    wire [31:0] xor_out;\n    \n    dual_edge_ff dff_inst (\n        .clk(clk),\n        .reset(reset),\n        .d(in),\n        .q(ff_out)\n    );\n    \n    rising_edge_detector red_inst (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .out(red_out)\n    );\n    \n    xor_functional xor_inst (\n        .in1(ff_out),\n        .in2(red_out),\n        .out(xor_out)\n    );\n    \n    assign out = (select == 2'b00) ? ff_out :\n                 (select == 2'b01) ? red_out :\n                 (select == 2'b10) ? xor_out :\n                 32'b0;\n    \nendmodule\nmodule dual_edge_ff (\n    input clk,\n    input reset,\n    input [31:0] d,\n    output [31:0] q\n);\n\n    reg [31:0] q1, q2;\n\n    always @(posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            q1 <= 32'b0;\n            q2 <= 32'b0;\n        end else begin\n            q1 <= d;\n            q2 <= q1;\n        end\n    end\n\n    assign q = q2;\n\nendmodule\nmodule rising_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\n    reg [31:0] out_reg;\n\n    always @(posedge clk or negedge reset) begin\n        if (reset == 0) begin\n            out_reg <= 32'b0;\n        end else begin\n            out_reg <= (in ^ out_reg) & in;\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\nmodule xor_functional (\n    input [31:0] in1,\n    input [31:0] in2,\n    output [31:0] out\n);\n\n    assign out = in1 ^ in2;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "1cacd1c88bf0a795424a5347fe638974",
        "dataset_index": 5490
      },
      "k580wm80a_6829ed7e": {
        "rtl_code": "module k580wm80a(\n\tinput clk,\n\tinput ce,\n\tinput reset,\n\tinput intr,\n\tinput [7:0] idata,\n\toutput reg [15:0] addr,\n\toutput reg sync,\n\toutput rd,\n\toutput reg wr,\n\toutput inta,\n\toutput reg [7:0] odata);\n\nreg M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16,M17,T5;\nreg[2:0] state;\n\nwire M1n = M2|M3|M4|M5|M6|M7|M8|M9|M10|M11|M12|M13|M14|M15|M16|M17;\n\nreg[15:0] PC;\nreg[15:0] SP;\nreg[7:0] B,C,D,E,H,L,A;\nreg[7:0] W,Z,IR;\nreg[9:0] ALU;\nreg FS,FZ,FA,FP,FC;\n\nreg rd_,intproc;\nassign rd = rd_&~intproc;\nassign inta = (rd_&intproc);\n\nreg[1:0] inte;\nreg jmp,call,halt;\nreg save_alu,save_a,save_r,save_rp,read_r,read_rp;\nreg incdec,xthl,xchg,sphl,daa,ALUb4;\nreg ccc;\n\nalways @(*) begin\n\tcasex (IR[5:3])\n\t3'b00x: ALU = {1'b0,A,1'b1}+{1'b0,Z,FC&IR[3]};\n\t3'b01x: ALU = {1'b0,A,1'b0}-{1'b0,Z,FC&IR[3]};\n\t3'b100: ALU = {1'b0,A & Z,1'b0};\n\t3'b101: ALU = {1'b0,A ^ Z,1'b0};\n\t3'b110: ALU = {1'b0,A | Z,1'b0};\n\t3'b111: ALU = {1'b0,A,1'b0}-{1'b0,Z,1'b0};\n\tendcase\nend\n\nalways @(*) begin\n\tcasex (IR[5:3])\n\t3'b00x: ALUb4 = A[4]+Z[4];\n\t3'b01x: ALUb4 = A[4]-Z[4];\n\t3'b10x: ALUb4 = A[4]^Z[4];\n\t3'b110: ALUb4 = A[4]|Z[4];\n\t3'b111: ALUb4 = A[4]-Z[4];\n\tendcase\nend\n\nalways @(*) begin\n\tcase(idata[5:3])\n\t3'h0: ccc = ~FZ;\n\t3'h1: ccc = FZ;\n\t3'h2: ccc = ~FC;\n\t3'h3: ccc = FC;\n\t3'h4: ccc = ~FP;\n\t3'h5: ccc = FP;\n\t3'h6: ccc = ~FS;\n\t3'h7: ccc = FS;\n\tendcase\nend\n\nwire[7:0] F = {FS,FZ,1'b0,FA,1'b0,FP,1'b1,FC};\nwire[7:0] Z1 = incdec ? Z+{{7{IR[0]}},1'b1} : Z;\nwire[15:0] WZ1 = incdec ? {W,Z}+{{15{IR[3]}},1'b1} : {W,Z};\nwire[3:0] daaZL = FA!=0 || A[3:0] > 4'h9 ? 4'h6 : 4'h0;\nwire[3:0] daaZH = FC!=0 || A[7:4] > {3'b100, A[3:0]>4'h9 ? 1'b0 : 1'b1} ? 4'h6 : 4'h0;\n\nalways @(posedge clk or posedge reset)\nbegin\n\tif (reset) begin\n\t\t{M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16,M17} <= 0;\n\t\tstate <= 0; PC <= 0; {FS,FZ,FA,FP,FC} <= 0; {addr,odata} <= 0;\n\t\t{sync,rd_,jmp,halt,inte,save_alu,save_a,save_r,save_rp,incdec,intproc} <= 0;\n\t\twr <= 1'b0;\n\tend else if (ce) begin\n\t\tsync <= 0; rd_ <= 0; wr <= 1'b0;\n\t\tif (halt&~(M1|(intr&inte[1]))) begin\n\t\t\tsync <= 1'b1; odata <= 8'b10001010; end else\n\t\tif (M1|~M1n) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\thalt <= 0; intproc <= intr&inte[1]; inte[1] <= inte[0];\n\t\t\t\tM1 <= 1'b1;\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b1010001,intr&inte[1]}; addr <= jmp ? {W,Z} : PC;\n\t\t\t\tstate <= 3'b001;\n\t\t\t\tif (intr&inte[1]) inte <= 2'b0;\n\t\t\t\tif (save_alu) begin\n\t\t\t\t\tFS <= ALU[8];\n\t\t\t\t\tFZ <= ~|ALU[8:1];\n\t\t\t\t\tFA <= ALU[5]^ALUb4;\n\t\t\t\t\tFP <= ~^ALU[8:1];\n\t\t\t\t\tFC <= ALU[9]|(FC&daa);\n\t\t\t\t\tif (IR[5:3]!=3'b111) A <= ALU[8:1];\n\t\t\t\tend else\n\t\t\t\tif (save_a) begin\n\t\t\t\t\tA <= Z1;\n\t\t\t\tend else\n\t\t\t\tif (save_r) begin\n\t\t\t\t\tcase (IR[5:3])\n\t\t\t\t\t3'b000: B <= Z1;\n\t\t\t\t\t3'b001: C <= Z1;\n\t\t\t\t\t3'b010: D <= Z1;\n\t\t\t\t\t3'b011: E <= Z1;\n\t\t\t\t\t3'b100: H <= Z1;\n\t\t\t\t\t3'b101: L <= Z1;\n\t\t\t\t\t3'b111: A <= Z1;\n\t\t\t\t\tendcase\n\t\t\t\t\tif (incdec) begin\n\t\t\t\t\t\tFS <= Z1[7];\n\t\t\t\t\t\tFZ <= ~|Z1;\n\t\t\t\t\t\tFA <= IR[0] ? Z1[3:0]!=4'b1111 : Z1[3:0]==0;\n\t\t\t\t\t\tFP <= ~^Z1;\n\t\t\t\t\tend\n\t\t\t\tend else\n\t\t\t\tif (save_rp) begin\n\t\t\t\t\tcase (IR[5:4])\n\t\t\t\t\t2'b00: {B,C} <= WZ1;\n\t\t\t\t\t2'b01: {D,E} <= WZ1;\n\t\t\t\t\t2'b10: {H,L} <= WZ1;\n\t\t\t\t\t2'b11:\n\t\t\t\t\t\tif (sphl || !IR[7]) begin\n\t\t\t\t\t\t\tSP <= WZ1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t{A,FS,FZ,FA,FP,FC} <= {WZ1[15:8],WZ1[7],WZ1[6],WZ1[4],WZ1[2],WZ1[0]};\n\t\t\t\t\t\tend\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\trd_ <= 1'b1;\n\t\t\t\tPC <= addr+{15'b0,~intproc};\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tIR <= idata;\n\t\t\t\t{jmp,call,save_alu,save_a,save_r,save_rp,read_r,read_rp,incdec,xthl,xchg,sphl,T5,daa} <= 0;\n\t\t\t\tcasex (idata)\n\t\t\t\t8'b00xx0001: {save_rp,M2,M3} <= 3'b111;\n\t\t\t\t8'b00xx1001: {read_rp,M16,M17} <= 3'b111;\n\t\t\t\t8'b000x0010: {read_rp,M14} <= 2'b11;\n\t\t\t\t8'b00100010: {M2,M3,M14,M15} <= 4'b1111;\n\t\t\t\t8'b00110010: {M2,M3,M14} <= 3'b111;\n\t\t\t\t8'b000x1010: {read_rp,save_a,M12} <= 3'b111;\n\t\t\t\t8'b00101010: {save_rp,M2,M3,M12,M13} <= 5'b11111;\n\t\t\t\t8'b00111010: {save_a,M2,M3,M12} <= 4'b1111;\n\t\t\t\t8'b00xxx011: {read_rp,save_rp,incdec,T5} <= 4'b1111;\n\t\t\t\t8'b00xxx10x: {read_r,save_r,incdec,T5} <= {3'b111,idata[5:3]!=3'b110};\n\t\t\t\t8'b00xxx110: {save_r,M2} <= 2'b11;\n\t\t\t\t8'b00000111: {FC,A} <= {A,A[7]};\n\t\t\t\t8'b00001111: {A,FC} <= {A[0],A};\n\t\t\t\t8'b00010111: {FC,A} <= {A,FC};\n\t\t\t\t8'b00011111: {A,FC} <= {FC,A};\n\t\t\t\t8'b00100111: {daa,save_alu,IR[5:3],Z} <= {5'b11000,daaZH,daaZL};\n\t\t\t\t8'b00101111: A <= ~A;\n\t\t\t\t8'b00110111: FC <= 1'b1;\n\t\t\t\t8'b00111111: FC <= ~FC;\n\t\t\t\t8'b01xxxxxx: if (idata[5:0]==6'b110110) halt <= 1'b1; else {read_r,save_r,T5} <= {2'b11,~(idata[5:3]==3'b110||idata[2:0]==3'b110)};\n\t\t\t\t8'b10xxxxxx: {read_r,save_alu} <= 2'b11;\n\t\t\t\t8'b11xxx000: {jmp,M8,M9} <= {3{ccc}};\n\t\t\t\t8'b11xx0001: {save_rp,M8,M9} <= 3'b111;\n\t\t\t\t8'b110x1001: {jmp,M8,M9} <= 3'b111;\n\t\t\t\t8'b11101001: {read_rp,jmp,T5} <= 3'b111;\n\t\t\t\t8'b11111001: {read_rp,save_rp,T5,sphl} <= 4'b1111;\n\t\t\t\t8'b11xxx010: {jmp,M2,M3} <= {ccc,2'b11};\n\t\t\t\t8'b1100x011: {jmp,M2,M3} <= 3'b111;\n\t\t\t\t8'b11010011: {M2,M7} <= 2'b11;\n\t\t\t\t8'b11011011: {M2,M6} <= 2'b11;\n\t\t\t\t8'b11100011: {save_rp,M8,M9,M10,M11,xthl} <= 6'b111111;\n\t\t\t\t8'b11101011: {read_rp,save_rp,xchg} <= 3'b111;\n\t\t\t\t8'b1111x011: inte <= idata[3] ? 2'b1 : 2'b0;\n\t\t\t\t8'b11xxx100: {jmp,M2,M3,T5,M10,M11,call} <= {ccc,3'b111,{3{ccc}}};\n\t\t\t\t8'b11xx0101: {read_rp,T5,M10,M11} <= 4'b1111;\n\t\t\t\t8'b11xx1101: {jmp,M2,M3,T5,M10,M11,call} <= 7'b1111111;\n\t\t\t\t8'b11xxx110: {save_alu,M2} <= 2'b11;\n\t\t\t\t8'b11xxx111: {jmp,T5,M10,M11,call,W,Z} <= {5'b11111,10'b0,idata[5:3],3'b0};\n\t\t\t\tendcase\n\t\t\t\tstate <= 3'b011;\n\t\t\tend\n\t\t\t3'b011: begin\n\t\t\t\tif (read_rp) begin\n\t\t\t\t\tcase (IR[5:4])\n\t\t\t\t\t2'b00: {W,Z} <= {B,C};\n\t\t\t\t\t2'b01: {W,Z} <= {D,E};\n\t\t\t\t\t2'b10: {W,Z} <= xchg ? {D,E} : {H,L};\n\t\t\t\t\t2'b11: {W,Z} <= sphl ? {H,L} : IR[7] ? {A,F} : SP;\n\t\t\t\t\tendcase\n\t\t\t\t\tif (xchg) {D,E} <= {H,L};\n\t\t\t\tend else\n\t\t\t\tif (~(jmp|daa)) begin\n\t\t\t\t\tcase (incdec?IR[5:3]:IR[2:0])\n\t\t\t\t\t3'b000: Z <= B;\n\t\t\t\t\t3'b001: Z <= C;\n\t\t\t\t\t3'b010: Z <= D;\n\t\t\t\t\t3'b011: Z <= E;\n\t\t\t\t\t3'b100: Z <= H;\n\t\t\t\t\t3'b101: Z <= L;\n\t\t\t\t\t3'b110: M4 <= read_r;\n\t\t\t\t\t3'b111: Z <= A;\n\t\t\t\t\tendcase\n\t\t\t\t\tM5 <= save_r && IR[5:3]==3'b110;\n\t\t\t\tend\n\t\t\t\tstate <= T5 ? 3'b100 : 0;\n\t\t\t\tM1 <= T5;\n\t\t\tend\n\t\t\t3'b100: begin\n\t\t\t\tif (M10) SP <= SP-16'b1;\n\t\t\t\tstate <= 0;\n\t\t\t\tM1 <= 0;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M2 || M3) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b1000001,intproc}; addr <= PC;\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\trd_ <= 1'b1;\n\t\t\t\tPC <= addr+{15'b0,~intproc};\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (M2) begin\n\t\t\t\t\tZ <= idata;\n\t\t\t\t\tM2 <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tW <= idata;\n\t\t\t\t\tM3 <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M4) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b1000001,intproc}; addr <= {H,L};\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\trd_ <= 1'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tZ <= idata;\n\t\t\t\tM4 <= 0;\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M5) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b0000000,intproc}; addr <= {H,L};\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\todata <= Z1;\n\t\t\t\twr <= 1'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tM5 <= 0;\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M6) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b0100001,intproc}; addr <= {Z,Z};\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\trd_ <= 1'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tA <= idata;\n\t\t\t\tM6 <= 0;\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M7) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b0001000,intproc}; addr <= {Z,Z};\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\todata <= A;\n\t\t\t\twr <= 1'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tM7 <= 0;\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M8 || M9) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b1000011,intproc}; addr <= SP;\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\trd_ <= 1'b1;\n\t\t\t\tif (M8 || !xthl) SP <= SP+16'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (M8) begin\n\t\t\t\t\tZ <= idata;\n\t\t\t\t\tM8 <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tW <= idata;\n\t\t\t\t\tM9 <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M10 || M11) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b0000010,intproc}; addr <= SP;\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\tif (M10) begin\n\t\t\t\t\tSP <= SP-16'b1;\n\t\t\t\t\todata <= xthl ? H : call ? PC[15:8] : W;\n\t\t\t\tend else begin\n\t\t\t\t\todata <= xthl ? L : call ? PC[7:0] : Z;\n\t\t\t\tend\n\t\t\t\twr <= 1'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (M10) begin\n\t\t\t\t\tM10 <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tM11 <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M12 || M13) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b1000001,intproc}; addr <= M12 ? {W,Z} : addr+16'b1;\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\trd_ <= 1'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (M12) begin\n\t\t\t\t\tZ <= idata;\n\t\t\t\t\tM12 <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tW <= idata;\n\t\t\t\t\tM13 <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M14 || M15) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b0000000,intproc}; addr <= M14 ? {W,Z} : addr+16'b1;\n\t\t\t\tstate <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\tif (M14) begin\n\t\t\t\t\todata <= M15 ? L : A;\n\t\t\t\tend else begin\n\t\t\t\t\todata <= H;\n\t\t\t\tend\n\t\t\t\twr <= 1'b1;\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (M14) begin\n\t\t\t\t\tM14 <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tM15 <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend else\n\t\tif (M16 || M17) begin\n\t\t\tcase (state)\n\t\t\t3'b000: begin\n\t\t\t\tsync <= 1'b1;\n\t\t\t\todata <= {7'b0000001,intproc}; state <= 3'b001;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\tstate <= 3'b010;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (M16) begin\n\t\t\t\t\tM16 <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\t{FC,H,L} <= {1'b0,H,L}+{1'b0,W,Z};\n\t\t\t\t\tM17 <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= 3'b000;\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "k580wm80a",
        "module_hash": "6829ed7e343c24fd0d2141ee92e377d3",
        "dataset_index": 16957
      },
      "arbiter_13d2a857": {
        "rtl_code": "module arbiter (clk, rst, request, acknowledge, grant, grant_valid, grant_encoded);\n  input [3:0] acknowledge;\n  input clk;\n  output [3:0] grant;\n  output [1:0] grant_encoded;\n  output grant_valid;\n  input [3:0] request;\n  input rst;\n\n  reg [3:0] grant_reg;\n  reg [1:0] grant_encoded_reg;\n  reg grant_valid_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      grant_reg <= 4'b0000;\n      grant_encoded_reg <= 2'b00;\n      grant_valid_reg <= 1'b0;\n    end else begin\n      if (request[0] && !acknowledge[0]) begin\n        grant_reg <= 4'b0001;\n        grant_encoded_reg <= 2'b01;\n        grant_valid_reg <= 1'b1;\n      end else if (request[1] && !acknowledge[1]) begin\n        grant_reg <= 4'b0010;\n        grant_encoded_reg <= 2'b10;\n        grant_valid_reg <= 1'b1;\n      end else if (request[2] && !acknowledge[2]) begin\n        grant_reg <= 4'b0100;\n        grant_encoded_reg <= 2'b11;\n        grant_valid_reg <= 1'b1;\n      end else if (request[3] && !acknowledge[3]) begin\n        grant_reg <= 4'b1000;\n        grant_encoded_reg <= 2'b11;\n        grant_valid_reg <= 1'b1;\n      end else begin\n        grant_reg <= 4'b0000;\n        grant_encoded_reg <= 2'b00;\n        grant_valid_reg <= 1'b0;\n      end\n    end\n  end\n\n  assign grant = grant_reg;\n  assign grant_valid = grant_valid_reg;\n  assign grant_encoded = grant_encoded_reg;\n\nendmodule",
        "module_name": "arbiter",
        "module_hash": "13d2a85743a158cbb59c9508cf990919",
        "dataset_index": 13556
      },
      "opcode_decoder_85da0f30": {
        "rtl_code": "module opcode_decoder(CCLK, rst, instr, IF);\n\tinput CCLK, rst;\n\tinput [31:0] instr;\n\toutput reg [7:0] IF;\n\n\talways @(posedge CCLK)\n\tbegin\n\t\tif (rst)\n\t\t\tIF = 8'd0;\n\t\telse\n\t\tbegin\n\t\t\tcase (instr[31:26])\n\t\t\t\t6'b000000:\n\t\t\t\tbegin \n\t\t\t\t\tcase (instr[5:0])\n\t\t\t\t\t\t6'b100000:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tIF = (|instr[15:11]) ? 8'd1 : 8'd0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t6'b100010: IF = 8'd2;\n\t\t\t\t\t\t6'b100100: IF = 8'd3;\n\t\t\t\t\t\t6'b100101: IF = 8'd4;\n\t\t\t\t\t\t6'b000000: IF = 8'd5;\n\t\t\t\t\t\t6'b000010: IF = 8'd6;\n\t\t\t\t\t\t6'b000011: IF = 8'd7;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\t6'b001000: IF = 8'd8;\n\t\t\t\t6'b001100: IF = 8'd9;\n\t\t\t\t6'b001101: IF = 8'd10;\n\t\t\t\t6'b100011: IF = 8'd11;\n\t\t\t\t6'b101011: IF = 8'd12;\n\t\t\t\t6'b000100: IF = 8'd13;\n\t\t\t\t6'b000101: IF = 8'd14;\n\t\t\t\t6'b000010: IF = 8'd15;\n\t\t\t\tdefault: IF = 8'd0;\n\t\t\tendcase\n\t\tend\n\tend\nendmodule",
        "module_name": "opcode_decoder",
        "module_hash": "85da0f308dcdc5f4d5ac84474d14588b",
        "dataset_index": 9756
      }
    },
    "batch_69165067c6bc81909af52c66a6ad26d8": {
      "MMU_MATCH_38b1f4e9": {
        "rtl_code": "module MMU_MATCH (\n    input USER,\n    input READ,\n    input WRITE,\n    input RMW,\n    input [2:0] MCR_FLAGS,\n    input [31:0] MVALID,\n    input [31:12] VADR_R,\n    input [31:16] MMU_VA,\n    input [1:0] IVAR,\n    output VIRTUELL,\n    output MMU_HIT,\n    output [31:0] UPDATE,\n    output reg PROT_ERROR,\n    output CI,\n    output SEL_PTB1\n);\n\nreg [15:0] maske;\nwire adr_space, as_sorte, match, alles_ok;\nwire [15:0] val_bits, as_bits;\nwire ena_prot;\nwire zugriff;\n\nassign zugriff = READ | WRITE;\n\nalways @(VADR_R) begin\n    case (VADR_R[15:12])\n        4'h0 : maske = 16'h0001;\n        4'h1 : maske = 16'h0002;\n        4'h2 : maske = 16'h0004;\n        4'h3 : maske = 16'h0008;\n        4'h4 : maske = 16'h0010;\n        4'h5 : maske = 16'h0020;\n        4'h6 : maske = 16'h0040;\n        4'h7 : maske = 16'h0080;\n        4'h8 : maske = 16'h0100;\n        4'h9 : maske = 16'h0200;\n        4'hA : maske = 16'h0400;\n        4'hB : maske = 16'h0800;\n        4'hC : maske = 16'h1000;\n        4'hD : maske = 16'h2000;\n        4'hE : maske = 16'h4000;\n        4'hF : maske = 16'h8000;\n    endcase\nend\n\nassign VIRTUELL = USER ? MCR_FLAGS[0] : MCR_FLAGS[1];\n\nassign adr_space = IVAR[1] ? IVAR[0] : (MCR_FLAGS[2] & USER);\n\nassign as_sorte = ((MVALID[31:16] & maske) != 16'h0);\n\nassign match = (VADR_R[31:20] == MMU_VA[31:20]) & (adr_space == as_sorte) & ((MVALID[15:0] & maske) != 16'h0000);\n\nassign alles_ok = match & (~WRITE | MMU_VA[17]) & ~PROT_ERROR;\n\nassign MMU_HIT = zugriff ? (VIRTUELL ? alles_ok : 1'b1) : 1'b0;\n\nassign val_bits = IVAR[1] ? (MVALID[15:0] & (match ? ~maske : 16'hFFFF)) : (MVALID[15:0] | maske);\nassign as_bits = IVAR[1] ? MVALID[31:16] : (adr_space ? (MVALID[31:16] | maske) : (MVALID[31:16] & ~maske));\n\nassign UPDATE = {as_bits, val_bits};\n\nassign ena_prot = zugriff & VIRTUELL & match;\n\nalways @(ena_prot or MMU_VA or USER or WRITE or RMW) begin\n    case ({ena_prot, MMU_VA[19:18]})\n        3'b100 : PROT_ERROR = USER | WRITE | RMW;\n        3'b101 : PROT_ERROR = USER;\n        3'b110 : PROT_ERROR = USER & (WRITE | RMW);\n        default : PROT_ERROR = 1'b0;\n    endcase\nend\n\nassign CI = VIRTUELL & MMU_VA[16];\nassign SEL_PTB1 = adr_space;\n\nendmodule",
        "module_name": "MMU_MATCH",
        "module_hash": "38b1f4e9eaba91ac6b9c21dc80649025",
        "dataset_index": 16637
      },
      "single_port_ram_59e901cb": {
        "rtl_code": "module single_port_ram (\n  input wire clk,\n  input wire en,\n  input wire we,\n  input wire [10:0] addr,\n  input wire [7:0] din,\n  output reg [7:0] dout\n);\n\n  reg [7:0] ram [0:2047]; // 2^11 bytes\n\n  always @(posedge clk) begin\n    if (en) begin\n      if (we) begin\n        ram[addr] <= din;\n      end\n      else begin\n        dout <= ram[addr];\n      end\n    end\n  end\n\nendmodule",
        "module_name": "single_port_ram",
        "module_hash": "59e901cbd0df748b909f711ee4e9be73",
        "dataset_index": 959
      },
      "counter_a8dffda8": {
        "rtl_code": "module counter (\n    input clk,\n    input [3:0] reset,\n    input [3:0] load,\n    input [3:0] increment,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset == 4'b1111) begin\n        count <= 4'b0000;\n    end else if (load != 4'b0000) begin\n        count <= load;\n    end else begin\n        count <= count + increment;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "a8dffda8cf29de9cec79eab4ab51bb33",
        "dataset_index": 1776
      },
      "mux_4to1_case_fdeb8785": {
        "rtl_code": "module mux_4to1_case (\n    input A, B, C, D,\n    input [1:0] sel,\n    output reg Y\n);\n\n    always @(*) begin\n        case(sel)\n            2'b00: Y = A;\n            2'b01: Y = B;\n            2'b10: Y = C;\n            2'b11: Y = D;\n        endcase\n    end\n\nendmodule",
        "module_name": "mux_4to1_case",
        "module_hash": "fdeb8785653ff589a18bcd657e881131",
        "dataset_index": 3483
      },
      "voltage_supply_3b5a8098": {
        "rtl_code": "module voltage_supply (\n  input clk,\n  input rst,\n  input enable,\n  output reg VPWR,\n  output reg VGND,\n  output reg VPB,\n  output reg VNB\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      VPB <= 0;\n      VNB <= 0;\n    end else if (enable) begin\n      VPB <= #2 ~VPB;\n      VNB <= 0;\n    end else begin\n      VPB <= 0;\n      VNB <= 0;\n    end\n  end\n\n  initial begin\n    VPWR = 1;\n    VGND = 0;\n  end\n\nendmodule",
        "module_name": "voltage_supply",
        "module_hash": "3b5a80989e67820eb959d2f16dabd201",
        "dataset_index": 12853
      },
      "sky130_fd_sc_hd__o221ai_6842084d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__o221ai",
        "module_hash": "6842084db3c9cc2b665d79bbec2ddce0",
        "dataset_index": 14127
      },
      "axis_gate_controller_acb14327": {
        "rtl_code": "\n\nmodule axis_gate_controller\n(\n  input  wire         aclk,\n  input  wire         aresetn,\n\n  output wire         s_axis_tready,\n  input  wire [127:0] s_axis_tdata,\n  input  wire         s_axis_tvalid,\n\n  output wire [31:0]  poff,\n  output wire [15:0]  level,\n  output wire         dout\n);\n\n  reg int_tready_reg, int_tready_next;\n  reg int_dout_reg, int_dout_next;\n  reg int_enbl_reg, int_enbl_next;\n  reg [63:0] int_cntr_reg, int_cntr_next;\n  reg [127:0] int_data_reg, int_data_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_tready_reg <= 1'b0;\n      int_dout_reg <= 1'b0;\n      int_enbl_reg <= 1'b0;\n      int_cntr_reg <= 64'd0;\n      int_data_reg <= 128'd0;\n    end\n    else\n    begin\n      int_tready_reg <= int_tready_next;\n      int_dout_reg <= int_dout_next;\n      int_enbl_reg <= int_enbl_next;\n      int_cntr_reg <= int_cntr_next;\n      int_data_reg <= int_data_next;\n    end\n  end\n\n  always @*\n  begin\n    int_tready_next = int_tready_reg;\n    int_dout_next = int_dout_reg;\n    int_enbl_next = int_enbl_reg;\n    int_cntr_next = int_cntr_reg;\n    int_data_next = int_data_reg;\n\n    if(~int_enbl_reg & s_axis_tvalid)\n    begin\n      int_tready_next = 1'b1;\n      int_enbl_next = 1'b1;\n      int_cntr_next = 64'd0;\n      int_data_next = s_axis_tdata;\n    end\n\n    if(int_enbl_reg)\n    begin\n      int_cntr_next = int_cntr_reg + 1'b1;\n\n      if(int_cntr_reg == 64'd0)\n      begin\n        int_dout_next = |int_data_reg[111:96];\n      end\n\n      if(int_cntr_reg == int_data_reg[63:0])\n      begin\n        int_dout_next = 1'b0;\n        int_enbl_next = 1'b0;\n      end\n    end\n\n    if(int_tready_reg)\n    begin\n      int_tready_next = 1'b0;\n    end\n  end\n\n  assign s_axis_tready = int_tready_reg;\n  assign poff = int_data_reg[95:64];\n  assign level = int_data_reg[111:96];\n  assign dout = int_dout_reg;\n\nendmodule\n",
        "module_name": "axis_gate_controller",
        "module_hash": "acb143271ae1d0999c5ff0acf7a45884",
        "dataset_index": 1844
      },
      "seven_segment_display_0e3d452c": {
        "rtl_code": "module seven_segment_display\n(\n  input clk,\n  input [15:0]num_in,\n  output reg [6:0]dig,\n  output reg dp,\n  output reg neg,\n  output reg clr,\n  output reg [3:0]dig_sel\n);\n\nreg [6:0]dig1;\nreg [6:0]dig2;\nreg [6:0]dig3;\nreg [6:0]dig4;\n\nreg [19:0] clk_div;\n\nalways @(posedge clk) begin\n  clk_div = clk_div + 1;\nend\n\nalways @(posedge clk) begin\n  if (clk_div == 0)\n  begin\n    if(dig_sel == 0)\n      dig_sel <= 1;\n    else\n      dig_sel <= {dig_sel[0],dig_sel[3:1]};\n\n    case(dig_sel)\n      4'b0010: dig <= dig4;\n      4'b0100: dig <= dig3;\n      4'b1000: dig <= dig2;\n      4'b0001: dig <= dig1;\n    endcase\n  end\nend\n\nalways @(posedge clk) begin\n  case(num_in[3:0])\n    4'b0000: dig1 = 7'b1000000; //0\n    4'b0001: dig1 = 7'b1111001; //1\n    4'b0010: dig1 = 7'b0100100; //2\n    4'b0011: dig1 = 7'b0110000; //3\n    4'b0100: dig1 = 7'b0011001; //4\n    4'b0101: dig1 = 7'b0010010; //5\n    4'b0110: dig1 = 7'b0000010; //6\n    4'b0111: dig1 = 7'b1111000; //7\n    4'b1000: dig1 = 7'b0000000; //8\n    4'b1001: dig1 = 7'b0010000; //9\n    4'b1010: dig1 = 7'b0001000; //A\n    4'b1011: dig1 = 7'b0000011; //b\n    4'b1100: dig1 = 7'b1000110; //C\n    4'b1101: dig1 = 7'b0100001; //d\n    4'b1110: dig1 = 7'b0000110; //E\n    4'b1111: dig1 = 7'b0001110; //F\n  endcase\n  case(num_in[7:4])\n    4'b0000: dig2 = 7'b1000000; //0\n    4'b0001: dig2 = 7'b1111001; //1\n    4'b0010: dig2 = 7'b0100100; //2\n    4'b0011: dig2 = 7'b0110000; //3\n    4'b0100: dig2 = 7'b0011001; //4\n    4'b0101: dig2 = 7'b0010010; //5\n    4'b0110: dig2 = 7'b0000010; //6\n    4'b0111: dig2 = 7'b1111000; //7\n    4'b1000: dig2 = 7'b0000000; //8\n    4'b1001: dig2 = 7'b0010000; //9\n    4'b1010: dig2 = 7'b0001000; //A\n    4'b1011: dig2 = 7'b0000011; //b\n    4'b1100: dig2 = 7'b1000110; //C\n    4'b1101: dig2 = 7'b0100001; //d\n    4'b1110: dig2 = 7'b0000110; //E\n    4'b1111: dig2 = 7'b0001110; //F\n  endcase\n  case(num_in[11:8])\n    4'b0000: dig3 = 7'b1000000; //0\n    4'b0001: dig3 = 7'b1111001; //1\n    4'b0010: dig3 = 7'b0100100; //2\n    4'b0011: dig3 = 7'b0110000; //3\n    4'b0100: dig3 = 7'b0011001; //4\n    4'b0101: dig3 = 7'b0010010; //5\n    4'b0110: dig3 = 7'b0000010; //6\n    4'b0111: dig3 = 7'b1111000; //7\n    4'b1000: dig3 = 7'b0000000; //8\n    4'b1001: dig3 = 7'b0010000; //9\n    4'b1010: dig3 = 7'b0001000; //A\n    4'b1011: dig3 = 7'b0000011; //b\n    4'b1100: dig3 = 7'b1000110; //C\n    4'b1101: dig3 = 7'b0100001; //d\n    4'b1110: dig3 = 7'b0000110; //E\n    4'b1111: dig3 = 7'b0001110; //F\n  endcase\n  case(num_in[15:12])\n    4'b0000: dig4 = 7'b1000000; //0\n    4'b0001: dig4 = 7'b1111001; //1\n    4'b0010: dig4 = 7'b0100100; //2\n    4'b0011: dig4 = 7'b0110000; //3\n    4'b0100: dig4 = 7'b0011001; //4\n    4'b0101: dig4 = 7'b0010010; //5\n    4'b0110: dig4 = 7'b0000010; //6\n    4'b0111: dig4 = 7'b1111000; //7\n    4'b1000: dig4 = 7'b0000000; //8\n    4'b1001: dig4 = 7'b0010000; //9\n    4'b1010: dig4 = 7'b0001000; //A\n    4'b1011: dig4 = 7'b0000011; //b\n    4'b1100: dig4 = 7'b1000110; //C\n    4'b1101: dig4 = 7'b0100001; //d\n    4'b1110: dig4 = 7'b0000110; //E\n    4'b1111: dig4 = 7'b0001110; //F\n  endcase\nend\n\nalways @(posedge clk) begin\n  dp <= 0;\n  neg <= 0;\n  clr <= 0;\nend\n\nendmodule",
        "module_name": "seven_segment_display",
        "module_hash": "0e3d452c18b1f66117c322cbe557c17a",
        "dataset_index": 9002
      },
      "pcie_7x_0_core_top_qpll_reset #_8a868e8a": {
        "rtl_code": "\n\n\n\n\nmodule pcie_7x_0_core_top_qpll_reset #\n(\n\n    parameter PCIE_PLL_SEL       = \"CPLL\",                  parameter PCIE_POWER_SAVING  = \"TRUE\",                  parameter PCIE_LANE          = 1,                       parameter BYPASS_COARSE_OVRD = 1                        )\n\n(\n\n    input                           QRST_CLK,\n    input                           QRST_RST_N,\n    input                           QRST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     QRST_CPLLLOCK,\n    input       [(PCIE_LANE-1)>>2:0]QRST_DRP_DONE,\n    input       [(PCIE_LANE-1)>>2:0]QRST_QPLLLOCK,\n    input       [ 1:0]              QRST_RATE,\n    input       [PCIE_LANE-1:0]     QRST_QPLLRESET_IN,\n    input       [PCIE_LANE-1:0]     QRST_QPLLPD_IN,\n    \n    output                          QRST_OVRD,\n    output                          QRST_DRP_START,\n    output                          QRST_QPLLRESET_OUT,\n    output                          QRST_QPLLPD_OUT,\n    output                          QRST_IDLE,\n    output      [3:0]               QRST_FSM\n\n);\n\n        reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     cplllock_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg1;\n    reg         [ 1:0]              rate_reg1;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg1;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg1;\n\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     cplllock_reg2;  \n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg2;\n    reg         [ 1:0]              rate_reg2;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg2;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg2;\n    \n    reg                             ovrd              =  1'd0;\n    reg                             qpllreset         =  1'd1;\n    reg                             qpllpd            =  1'd0;\n    reg         [3:0]               fsm               =  2;                 \n   \n    localparam                      FSM_IDLE          = 1;localparam                      FSM_WAIT_LOCK     = 2;localparam                      FSM_MMCM_LOCK     = 3;localparam                      FSM_DRP_START_NOM = 4;localparam                      FSM_DRP_DONE_NOM  = 5;localparam                      FSM_QPLLLOCK      = 6;localparam                      FSM_DRP_START_OPT = 7;localparam                      FSM_DRP_DONE_OPT  = 8;localparam                      FSM_QPLL_RESET    = 9;localparam                      FSM_QPLLLOCK2     = 10;localparam                      FSM_QPLL_PDRESET  = 11;localparam                      FSM_QPLL_PD       = 12;always @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin    \n        mmcm_lock_reg1    <=  1'd0;\n        cplllock_reg1     <= {PCIE_LANE{1'd1}}; \n        drp_done_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};     \n        qplllock_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg1         <=  2'd0; \n        qpllreset_in_reg1 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg1    <= {PCIE_LANE{1'd0}}; \n        mmcm_lock_reg2    <=  1'd0;\n        cplllock_reg2     <= {PCIE_LANE{1'd1}};\n        drp_done_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        qplllock_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg2         <=  2'd0;\n        qpllreset_in_reg2 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg2    <= {PCIE_LANE{1'd0}};  \n        end\n    else\n        begin  \n        mmcm_lock_reg1    <= QRST_MMCM_LOCK;   \n        cplllock_reg1     <= QRST_CPLLLOCK; \n        drp_done_reg1     <= QRST_DRP_DONE; \n        qplllock_reg1     <= QRST_QPLLLOCK;\n        rate_reg1         <= QRST_RATE; \n        qpllreset_in_reg1 <= QRST_QPLLRESET_IN;\n        qpllpd_in_reg1    <= QRST_QPLLPD_IN;\n        mmcm_lock_reg2    <= mmcm_lock_reg1;\n        cplllock_reg2     <= cplllock_reg1;\n        drp_done_reg2     <= drp_done_reg1; \n        qplllock_reg2     <= qplllock_reg1;\n        rate_reg2         <= rate_reg1;\n        qpllreset_in_reg2 <= qpllreset_in_reg1;\n        qpllpd_in_reg2    <= qpllpd_in_reg1;\n        end\n        \nend    \n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        fsm       <= FSM_WAIT_LOCK;\n        ovrd      <= 1'd0;\n        qpllreset <= 1'd1;\n        qpllpd    <= 1'd0;\n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (!QRST_RST_N)\n                begin\n                fsm       <= FSM_WAIT_LOCK;\n                ovrd      <= 1'd0;\n                qpllreset <= 1'd1;\n                qpllpd    <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                ovrd      <= ovrd;\n                qpllreset <= &qpllreset_in_reg2;\n                qpllpd    <= &qpllpd_in_reg2;\n                end\n            end  \n            \n        FSM_WAIT_LOCK :\n        \n            begin\n            fsm       <= ((&(~cplllock_reg2)) && (&(~qplllock_reg2)) ? FSM_MMCM_LOCK : FSM_WAIT_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_MMCM_LOCK :\n        \n            begin\n            fsm       <= ((mmcm_lock_reg2 && (&cplllock_reg2)) ? FSM_DRP_START_NOM : FSM_MMCM_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_DRP_START_NOM:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_NOM : FSM_DRP_START_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_NOM :\n        \n            begin\n            fsm       <= (&drp_done_reg2 ? FSM_QPLLLOCK : FSM_DRP_DONE_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end \n            \n        FSM_QPLLLOCK :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? ((BYPASS_COARSE_OVRD == 1) ? FSM_QPLL_PDRESET : FSM_DRP_START_OPT) : FSM_QPLLLOCK);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_DRP_START_OPT:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_OPT : FSM_DRP_START_OPT);\n            ovrd      <= 1'd1;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_OPT :\n        \n            begin\n            if (&drp_done_reg2)\n                begin\n                fsm       <= ((PCIE_PLL_SEL == \"QPLL\") ? FSM_QPLL_RESET : FSM_QPLL_PDRESET);\n                ovrd      <= ovrd;\n                qpllreset <= (PCIE_PLL_SEL == \"QPLL\");\n                qpllpd    <= qpllpd;\n                end\n            else\n                begin\n                fsm       <= FSM_DRP_DONE_OPT;\n                ovrd      <= ovrd;\n                qpllreset <= qpllreset;\n                qpllpd    <= qpllpd;\n                end\n            end \n            \n        FSM_QPLL_RESET :\n            \n            begin\n            fsm       <= (&(~qplllock_reg2) ? FSM_QPLLLOCK2 : FSM_QPLL_RESET);  \n            ovrd      <= ovrd;\n            qpllreset <= 1'd1;\n            qpllpd    <= 1'd0;\n            end     \n            \n        FSM_QPLLLOCK2 :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK2);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n            \n        FSM_QPLL_PDRESET :\n        \n            begin\n            fsm       <= FSM_QPLL_PD;\n            ovrd      <= ovrd;\n            qpllreset <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_QPLL_PD :\n        \n            begin\n            fsm       <= FSM_IDLE;\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            end \n                \n        default :\n        \n            begin\n            fsm       <= FSM_WAIT_LOCK;\n            ovrd      <= 1'd0;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        endcase\n        \n        end\n        \nend\n\n\n\nassign QRST_OVRD          = ovrd;\nassign QRST_DRP_START     = (fsm == FSM_DRP_START_NOM) || (fsm == FSM_DRP_START_OPT); \nassign QRST_QPLLRESET_OUT = qpllreset;\nassign QRST_QPLLPD_OUT    = ((PCIE_POWER_SAVING == \"FALSE\") ? 1'd0 : qpllpd);  \nassign QRST_IDLE          = (fsm == FSM_IDLE);\nassign QRST_FSM           = fsm;                   \n\n\n\nendmodule\n",
        "module_name": "pcie_7x_0_core_top_qpll_reset #",
        "module_hash": "8a868e8abb1ed0f3dc5f707a81fecad7",
        "dataset_index": 25236
      },
      "decoder_3to4_d7413466": {
        "rtl_code": "module decoder_3to4(\n    input a, b, c,\n    output w, x, y, z\n    );\n    \n    assign w = ~(a & b & c);\n    assign x = ~(a & b & ~c);\n    assign y = ~(a & ~b & c);\n    assign z = ~(a & ~b & ~c);\n    \nendmodule",
        "module_name": "decoder_3to4",
        "module_hash": "d741346624d46ccae7665005e65132ba",
        "dataset_index": 2819
      },
      "MUX4X1_f8514d2e": {
        "rtl_code": "module MUX4X1 (A, B, S0, S1, Z);\ninput A;\ninput B;\ninput S0;\ninput S1;\noutput Z;\n\nwire not_S0, not_S1, not_A, not_B, A_and_not_B, not_A_and_B, not_A_and_not_B, not_B_and_A;\n\nnot (not_S0, S0);\nnot (not_S1, S1);\nnot (not_A, A);\nnot (not_B, B);\nand (A_and_not_B, A, not_B);\nand (not_A_and_B, not_A, B);\nand (not_A_and_not_B, not_A, not_B);\nand (not_B_and_A, not_B, A);\nor (Z, (A_and_not_B & ~S1 & ~S0), (not_A_and_B & S1 & ~S0), (not_A_and_not_B & S1 & S0), (not_B_and_A & ~S1 & S0));\n\nendmodule",
        "module_name": "MUX4X1",
        "module_hash": "f8514d2ed06c8fa8f53e78d0c10f8d72",
        "dataset_index": 1982
      },
      "fsm_4bit_sequence_detection_92706f25": {
        "rtl_code": "module fsm_4bit_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  output reg match\n);\n\n  parameter IDLE = 2'b00;\n  parameter S1 = 2'b01;\n  parameter S2 = 2'b10;\n  parameter S3 = 2'b11;\n  \n  reg [1:0] state;\n  reg [3:0] shift_reg;\n\n  always @(posedge clk, negedge reset) begin\n    if(!reset) begin\n      state <= IDLE;\n      shift_reg <= 4'b0000;\n      match <= 1'b0;\n    end else begin\n      case(state)\n        IDLE: begin\n          if(data == 1'b1) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= S1;\n          end else begin\n            shift_reg <= 4'b0000;\n          end\n        end\n        S1: begin\n          if(data == 1'b0) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n          end else begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= S2;\n          end\n        end\n        S2: begin\n          if(data == 1'b1) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= S3;\n          end else begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n          end\n        end\n        S3: begin\n          if(data == 1'b1) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n            match <= 1'b1;\n          end else begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n          end\n        end\n      endcase\n    end\n  end\nendmodule\n",
        "module_name": "fsm_4bit_sequence_detection",
        "module_hash": "92706f25afbdfcdfd08103720ca4a625",
        "dataset_index": 3112
      },
      "sky130_fd_sc_lp__o31a_c18531ae": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o31a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1, A3     );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o31a",
        "module_hash": "c18531ae0ffd6ee81ce359bd87b92f5f",
        "dataset_index": 10266
      },
      "adder_3eeac7bf": {
        "rtl_code": "module adder(\n    input [3:0] A,\n    output [3:0] S\n);\n\n    parameter [3:0] B = 4'hA; // Constant\n\n    assign S = A + B; // Adder\n\nendmodule",
        "module_name": "adder",
        "module_hash": "3eeac7bf7402f8c5ad2db26eb0a8e01a",
        "dataset_index": 13956
      },
      "sky130_fd_sc_ms__nor2_427c481d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__nor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B           );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__nor2",
        "module_hash": "427c481da28a138b4f078142f827519b",
        "dataset_index": 986
      },
      "Reset_Delay_7c428c9d": {
        "rtl_code": "\nmodule Reset_Delay(iRST,iCLK,oRESET);\ninput iCLK;\ninput iRST;\noutput reg oRESET;\nreg [27:0] Cont;\nalways@(posedge iCLK or negedge iRST)\nbegin\n    if(!iRST)\n    begin\n        oRESET <= 1'b0;\n        Cont <= 28'b0;\n    end\n    else\n    begin\n        Cont <= Cont + 1'b1;\n        if(Cont != 28'h4FFFFFF) // about 300ms at 50MHz\n            oRESET <= 1'b1;\n    end\nend\nendmodule",
        "module_name": "Reset_Delay",
        "module_hash": "7c428c9deaaa565c5cc12103225a8566",
        "dataset_index": 3193
      },
      "full_adder_a20165d2": {
        "rtl_code": "\nmodule full_adder (\n  input A,\n  input B,\n  input C_in,\n  output S,\n  output C_out\n);\n\nassign S = A ^ B ^ C_in;\nassign C_out = (A & B) | (A & C_in) | (B & C_in);\n\nendmodule\nmodule ripple_carry_adder #(\n  parameter n = 4 // number of bits in A and B\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output [n:0] C\n);\n\nwire [n:0] carry; // carry signals for each bit position\n\n// generate carry signals\ngenvar i;\ngenerate\n  for (i = 0; i < n; i = i + 1) begin : carry_gen\n    full_adder fa(\n      .A(A[i]),\n      .B(B[i]),\n      .C_in(carry[i]),\n      .S(C[i]),\n      .C_out(carry[i+1])\n    );\n  end\nendgenerate\n\n// set carry-in for least significant bit\nassign carry[0] = 1'b0;\n\n// assign output\nassign C[n] = carry[n];\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "a20165d25c7cdec0d340bbb35e15b7f4",
        "dataset_index": 17897
      },
      "EnergyHarvestingBlock_edcd991f": {
        "rtl_code": "\nmodule EnergyHarvestingBlock (\n  input [n-1:0] e,\n  output out\n);\n\nparameter n = 4; // number of energy sources\nparameter voltage = 150; // voltage generated by each energy source in mV\nparameter current = 50; // current generated by each energy source in mA\n\nreg [15:0] v; // voltage generated by each energy source in mV\nreg [15:0] i; // current generated by each energy source in mA\nreg [31:0] p; // power generated by each energy source in mW\nreg [31:0] w; // weight of each energy source\n\nalways @(*) begin\n  v = voltage * e;\n  i = current * e;\n  p = (v * i) / 1000;\n  w = (p * 1000) / (v + i);\nend\n\nassign out = (w * v) / (1000 * n);\n\nendmodule",
        "module_name": "EnergyHarvestingBlock",
        "module_hash": "edcd991ff9ffbd131189bc5454c3a47d",
        "dataset_index": 16853
      },
      "axis_srl_fifo_9f66845f": {
        "rtl_code": "module axis_srl_fifo(\n  input clk, rst,\n  input [7:0] input_axis_tdata,\n  input input_axis_tvalid, input_axis_tlast, input_axis_tuser,\n  output reg input_axis_tready,\n  output reg [7:0] output_axis_tdata,\n  output reg output_axis_tvalid, output_axis_tlast, output_axis_tuser,\n  input output_axis_tready,\n  output reg [2:0] count\n);\n\n  parameter DEPTH = 4;\n  parameter DATA_WIDTH = 8;\n\n  reg [DATA_WIDTH-1:0] fifo [0:DEPTH-1];\n  reg [2:0] head = 3'b0;\n  reg [2:0] tail = 3'b0;\n  reg [2:0] count_reg = 3'b0;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      head <= 3'b0;\n      tail <= 3'b0;\n      count_reg <= 3'b0;\n    end else begin\n      if (input_axis_tvalid && input_axis_tready) begin\n        fifo[head] <= input_axis_tdata;\n        head <= (head == 3'b111) ? 3'b0 : head + 1;\n        count_reg <= (count_reg == 3'b100) ? 3'b100 : count_reg + 1;\n      end\n      if (output_axis_tready && count_reg > 3'b0) begin\n        output_axis_tdata <= fifo[tail];\n        output_axis_tvalid <= 1;\n        output_axis_tlast <= (count_reg == 3'b1) && input_axis_tlast;\n        output_axis_tuser <= input_axis_tuser;\n        tail <= (tail == 3'b111) ? 3'b0 : tail + 1;\n        count_reg <= count_reg - 1;\n      end else begin\n        output_axis_tvalid <= 0;\n      end\n    end\n    input_axis_tready <= (count_reg < 3'b100) ? 1 : 0;\n    count <= count_reg;\n  end\n\nendmodule",
        "module_name": "axis_srl_fifo",
        "module_hash": "9f66845fe6c75df8548ef389cc9715ca",
        "dataset_index": 9005
      },
      "glitch_filter_ebd408f4": {
        "rtl_code": "module glitch_filter (\n  input signal_in,\n  output signal_out\n);\n\nparameter glitch_duration = 4; // minimum pulse duration\n\nreg [glitch_duration-1:0] delay_line;\nreg filtered_signal;\n\nalways @(posedge signal_in) begin\n  delay_line <= {delay_line[glitch_duration-2:0], signal_in};\n  if (delay_line[0] == 1'b1 && delay_line[glitch_duration-1] == 1'b0) begin\n    filtered_signal <= delay_line[glitch_duration-2];\n  end else begin\n    filtered_signal <= signal_in;\n  end\nend\n\nassign signal_out = filtered_signal;\n\nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "ebd408f445efe39845b32c7a149fbac3",
        "dataset_index": 19292
      },
      "assert_even_parity_assert_cdbbe4f7": {
        "rtl_code": "\nmodule assert_even_parity_assert (clk, reset_n, test_expr, xzcheck_enable, parity_result);\n  parameter width = 1;\n  input clk, reset_n;\n  input [width-1:0] test_expr;\n  input xzcheck_enable;\n  output reg parity_result;\n\n  reg [width-1:0] data;\n  reg parity;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      parity <= 1;\n      parity_result <= 0;\n    end else begin\n      data <= test_expr;\n      parity <= ^test_expr;\n      parity_result <= ~parity;\n    end\n  end\nendmodule",
        "module_name": "assert_even_parity_assert",
        "module_hash": "cdbbe4f77bfbdc7282c56d090a814819",
        "dataset_index": 12506
      },
      "FP16RMulS0Of2_1cc0225a": {
        "rtl_code": "module FP16RMulS0Of2(\n input \t       clk,\n input \t       rst,\n input [15:0]  arg_0,\n input [15:0]  arg_1,\n output        ret_0,\n output [4:0]  ret_1,\n output [4:0]  ret_2,\n output [11:0] ret_3);\n\n   wire        s0;\n   wire        s1;\n   wire [4:0]  e0;\n   wire [4:0]  e1;\n   wire [9:0]  f0;\n   wire [9:0]  f1;\n   wire [10:0] ff0;\n   wire [10:0] ff1;\n   wire [21:0] z;\n   wire [11:0] zz;\n\n   assign s0 = arg_0[15:15];\n   assign s1 = arg_1[15:15];\n   assign e0 = arg_0[14:10];\n   assign e1 = arg_1[14:10];\n   assign f0 = arg_0[9:0];\n   assign f1 = arg_1[9:0];\n\n   assign ret_0 = s0 ^ s1;\n   assign ret_1 = e0;\n   assign ret_2 = e1;\n\n   assign ff0 = {(e0 == 0 ? 1'b0 : 1'b1), f0};\n   assign ff1 = {(e1 == 0 ? 1'b0 : 1'b1), f1};\n\n   assign z = ff0 * ff1;\n   assign zz = z[21:10];\n   assign ret_3 = zz;\n\nendmodule module FP16RMulS1Of2(\n input \t       clk,\n input \t       rst,\n input \t       arg_0,\n input [4:0]   arg_1,\n input [4:0]   arg_2,\n input [11:0]  arg_3,\n output [15:0] ret_0);\n\n   wire        s;\n   wire        c;\n   wire [9:0] fc;\n   wire [9:0] uc;\n   wire [6:0]  e7;\n   wire [4:0]  e;\n   wire        underflow;\n   wire        overflow;\n   wire        infinput;\n\n   assign s = arg_0;\n   assign c = arg_3[11:11];\n   assign e7 = arg_1 + arg_2 - 15 + c;\n   assign fc = c ? arg_3[10:1] : arg_3[9:0];\n   assign infinput = (arg_1 == 31) || (arg_2 == 31);\n   assign underflow = e7[6:6];\n   assign overflow = !underflow && (e7[5:5] || e7[4:0] == 31 || infinput);\n\n   assign e = underflow ? 0 : (overflow ? 31 : e7[4:0]);\n   assign uc = (underflow || e7[4:0] == 0) ? 0 : fc;\n\n   assign ret_0 = {s, e, uc};\n\nendmodule ",
        "module_name": "FP16RMulS0Of2",
        "module_hash": "1cc0225ae92238035de620e714ae7bfb",
        "dataset_index": 9482
      },
      "uart_transmitter_60858cc0": {
        "rtl_code": "module uart_transmitter(\n  input clk, reset, din, baud_clk,\n  output tx\n);\n\nreg [7:0] shift_reg;\nreg tx_busy;\nreg tx;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    shift_reg <= 8'b0;\n    tx_busy <= 1'b0;\n    tx <= 1'b1;\n  end else begin\n    if (baud_clk) begin\n      if (!tx_busy) begin\n        shift_reg <= din;\n        tx_busy <= 1'b1;\n      end else begin\n        shift_reg <= {shift_reg[6:0], 1'b0};\n        if (shift_reg == 8'b0) begin\n          tx_busy <= 1'b0;\n        end\n      end\n      tx <= shift_reg[7];\n    end\n  end\nend\n\nendmodule\n\nmodule uart_receiver(\n  input clk, reset, rx, baud_clk,\n  output dout\n);\n\nreg [7:0] shift_reg;\nreg rx_busy;\nwire dout;\n\nassign dout = shift_reg[7];\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    shift_reg <= 8'b0;\n    rx_busy <= 1'b0;\n  end else begin\n    if (baud_clk) begin\n      if (!rx_busy) begin\n        if (rx == 1'b0) begin\n          rx_busy <= 1'b1;\n        end\n      end else begin\n        shift_reg <= {shift_reg[6:0], rx};\n        if (shift_reg == 8'b0) begin\n          rx_busy <= 1'b0;\n        end\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "uart_transmitter",
        "module_hash": "60858cc06d9a4f120db21b1174727d42",
        "dataset_index": 9701
      },
      "top__d38e06b7": {
        "rtl_code": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] c;\n    wire [7:0] g;\n    wire [7:0] p;\n    wire [7:0] carry;\n    wire [7:0] sum;\n\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .c(c)\n    );\n\n    assign g = a & b;\n    assign p = a ^ b;\n    assign carry[0] = g[0];\n    assign overflow = g[7];\n    \n    generate\n        genvar i;\n        for (i = 1; i < 8; i = i + 1) begin : carry_lookahead\n            assign carry[i] = g[i] | (p[i] & carry[i-1]);\n        end\n    endgenerate\n\n    assign sum = a + b + {1'b0, carry[6:0]};\n    assign s = sum[7:0];\n\nendmodule\n\nmodule and_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] c\n);\n\n    assign c = a & b;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "d38e06b73fd85b9dcfe67044696b8ca8",
        "dataset_index": 8194
      },
      "multiple_of_3_da384b02": {
        "rtl_code": "module multiple_of_3 (\n  input [2:0] data,\n  output reg q\n);\n  \n  always @* begin\n    case(data)\n      3'b000: q = 1'b1;\n      3'b001: q = 1'b0;\n      3'b010: q = 1'b0;\n      3'b011: q = 1'b1;\n      3'b100: q = 1'b0;\n      3'b101: q = 1'b1;\n      3'b110: q = 1'b1;\n      3'b111: q = 1'b0;\n      default: q = 1'b0;\n    endcase\n  end\n  \nendmodule\n",
        "module_name": "multiple_of_3",
        "module_hash": "da384b020b139c9e7fed70f4fd0afda5",
        "dataset_index": 16012
      },
      "mi_nios_cpu_nios2_oci_fifo_wrptr_inc_9b7f2c74": {
        "rtl_code": "module mi_nios_cpu_nios2_oci_fifo_wrptr_inc (\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [3:0] fifo_wrptr_inc\n);\n\n  always @* begin\n    if (ge3_free && (input_tm_cnt == 2'b11))\n      fifo_wrptr_inc = 4'b0011;\n    else if (ge2_free && (input_tm_cnt >= 2))\n      fifo_wrptr_inc = 4'b0010;\n    else if (input_tm_cnt >= 1)\n      fifo_wrptr_inc = 4'b0001;\n    else\n      fifo_wrptr_inc = 4'b0000;\n  end\n\nendmodule",
        "module_name": "mi_nios_cpu_nios2_oci_fifo_wrptr_inc",
        "module_hash": "9b7f2c74d7cf9c7258195f84d2f9e372",
        "dataset_index": 1202
      },
      "my_or4b_fba0d755": {
        "rtl_code": "module my_or4b (\n    X  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    // Module ports\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    // Local signals\n    wire not0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    not not0 (not0_out , D_N              );\n    or  or0  (or0_out_X, not0_out, C, B, A);\n    buf buf0 (X        , or0_out_X        );\n\nendmodule",
        "module_name": "my_or4b",
        "module_hash": "fba0d75569135239d14083f9abb98052",
        "dataset_index": 10507
      },
      "top__4306b776": {
        "rtl_code": "module top_module (\n    input clk,\n    input rst_n,\n    input a,\n    input [4:0] in,\n    output out_and,\n    output out_or,\n    output out_nor,\n    output reg final_output\n);\n\n    // Edge detection module\n    reg a_prev;\n    reg edge_detected;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            a_prev <= 1'b0;\n            edge_detected <= 1'b0;\n        end else begin\n            a_prev <= a;\n            edge_detected <= (a && ~a_prev) || (~a && a_prev);\n        end\n    end\n\n    // Combinational circuit module\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_nor = ~|in;\n\n    // Additional functional module\n    reg [1:0] decoder_out;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            final_output <= 1'b0;\n        end else begin\n            if (edge_detected && (decoder_out == 2'd2 || decoder_out == 2'd3)) begin\n                final_output <= 1'b1;\n            end else begin\n                final_output <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule decoder_2to4_with_enable (\n    input in,\n    input en,\n    output reg [1:0] out\n);\n\n    always @(*) begin\n        case ({in, en})\n            2'b00: out <= 2'b00;\n            2'b01: out <= 2'b01;\n            2'b10: out <= 2'b10;\n            2'b11: out <= 2'b11;\n            default: out <= 2'b00;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "4306b776175ad81d040f18116a2948ac",
        "dataset_index": 7078
      },
      "nand_gate_ebf0bd74": {
        "rtl_code": "module nand_gate (\n    Z,\n    A,\n    B\n);\n\n    output Z;\n    input A;\n    input B;\n\n    assign Z = ~(A & B);\n\nendmodule",
        "module_name": "nand_gate",
        "module_hash": "ebf0bd7474b9ec76d29847d2b09980b2",
        "dataset_index": 7454
      },
      "Mux_3x1_bv2 #_93e14cc5": {
        "rtl_code": "module Mux_3x1_bv2 #(parameter W=32)\n(\n//Input Signals\ninput wire [1:0] select,\ninput wire [W-1:0] ch_0,\ninput wire [W-1:0] ch_1,\ninput wire [W-1:0] ch_2,\n//Output Signals\noutput reg [W-1:0] data_out\n);\n    always @*\n        begin\n            case(select)\n                2'b00: data_out <= {W{1'b0}};\n                2'b01: data_out <= ch_0;\n                2'b10: data_out <= ch_1;\n                2'b11: data_out <= ch_2;\n                default : data_out <= ch_0;\n            endcase\n        end\nendmodule",
        "module_name": "Mux_3x1_bv2 #",
        "module_hash": "93e14cc55e3454c57c1ee220c3513937",
        "dataset_index": 10099
      },
      "joy_control_f50bc21c": {
        "rtl_code": "module joy_control(\n\tinput CLK,\n\tinput sndRec,\n\tinput BUSY,\n\tinput [7:0] RxData,\n    output SS,\n\toutput reg getByte,\n\toutput reg [39:0] DOUT\n);\n\nreg SS = 1;\nreg [2:0] pState = 0;\nreg [2:0] byteCnt = 0;\nreg [39:0] tmpSR = 0;\n\nalways @(negedge CLK)\nbegin\t\n\tcase(pState)\n\t\t0 : begin\n            SS <= 1;\n\t\t\tgetByte <= 0;\n\t\t\ttmpSR <= 0;\n\t\t\tbyteCnt <= 0;\n\t\t\tpState <= sndRec ? 1 : 0;\t\t\t\t\t\t\n\t\tend\n\n\t\t1 : begin\n            SS <= 0;\n\t\t\tgetByte <= 1;\n\t\t\tif(BUSY)\n\t\t\tbegin\n\t\t\t\tpState <= 2;\n\t\t\t\tbyteCnt <= byteCnt + 1;\n\t\t\tend\n\t\t\telse\n\t\t\t\tpState <= 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\tend\n\n\t\t2 : begin\n            SS <= 0;\n\t\t\tgetByte <= 0;\n\t\t\tpState <= BUSY ? 2 : 3;\n\t\tend\n\n\t\t3 : begin\n            SS <= 0;\n\t\t\tgetByte <= 0;\n\t\t\ttmpSR <= {tmpSR[31:0], RxData};\n\t\t\tpState <= byteCnt == 5 ? 4 : 1;\n\t\tend\n\n\t\t4 : begin\n            SS <= 1;\n\t\t\tgetByte <= 0;\n\t\t\tDOUT[39:0] <= tmpSR[39:0];\n\t\t\tpState <= sndRec ? 4 : 0;\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "joy_control",
        "module_hash": "f50bc21cefe5944ab75990673c4463eb",
        "dataset_index": 23352
      },
      "squarer_f3ec2a4f": {
        "rtl_code": "`ifndef __POW_2P1__\n`define __POW_2P1__\nmodule squarer(a, d);\n\ninput wire [232:0] a;\noutput wire [232:0] d;\n\nassign d[0] = a[0] ^ a[196];\nassign d[1] = a[117];\nassign d[2] = a[1] ^ a[197];\nassign d[3] = a[118];\nassign d[4] = a[2] ^ a[198];\nassign d[5] = a[119];\nassign d[6] = a[3] ^ a[199];\nassign d[7] = a[120];\nassign d[8] = a[4] ^ a[200];\nassign d[9] = a[121];\nassign d[10] = a[5] ^ a[201];\nassign d[11] = a[122];\nassign d[12] = a[6] ^ a[202];\nassign d[13] = a[123];\nassign d[14] = a[7] ^ a[203];\nassign d[15] = a[124];\nassign d[16] = a[8] ^ a[204];\nassign d[17] = a[125];\nassign d[18] = a[9] ^ a[205];\nassign d[19] = a[126];\nassign d[20] = a[10] ^ a[206];\nassign d[21] = a[127];\nassign d[22] = a[11] ^ a[207];\nassign d[23] = a[128];\nassign d[24] = a[12] ^ a[208];\nassign d[25] = a[129];\nassign d[26] = a[13] ^ a[209];\nassign d[27] = a[130];\nassign d[28] = a[14] ^ a[210];\nassign d[29] = a[131];\nassign d[30] = a[15] ^ a[211];\nassign d[31] = a[132];\nassign d[32] = a[16] ^ a[212];\nassign d[33] = a[133];\nassign d[34] = a[17] ^ a[213];\nassign d[35] = a[134];\nassign d[36] = a[18] ^ a[214];\nassign d[37] = a[135];\nassign d[38] = a[19] ^ a[215];\nassign d[39] = a[136];\nassign d[40] = a[20] ^ a[216];\nassign d[41] = a[137];\nassign d[42] = a[21] ^ a[217];\nassign d[43] = a[138];\nassign d[44] = a[22] ^ a[218];\nassign d[45] = a[139];\nassign d[46] = a[23] ^ a[219];\nassign d[47] = a[140];\nassign d[48] = a[24] ^ a[220];\nassign d[49] = a[141];\nassign d[50] = a[25] ^ a[221];\nassign d[51] = a[142];\nassign d[52] = a[26] ^ a[222];\nassign d[53] = a[143];\nassign d[54] = a[27] ^ a[223];\nassign d[55] = a[144];\nassign d[56] = a[28] ^ a[224];\nassign d[57] = a[145];\nassign d[58] = a[29] ^ a[225];\nassign d[59] = a[146];\nassign d[60] = a[30] ^ a[226];\nassign d[61] = a[147];\nassign d[62] = a[31] ^ a[227];\nassign d[63] = a[148];\nassign d[64] = a[32] ^ a[228];\nassign d[65] = a[149];\nassign d[66] = a[33] ^ a[229];\nassign d[67] = a[150];\nassign d[68] = a[34] ^ a[230];\nassign d[69] = a[151];\nassign d[70] = a[35] ^ a[231];\nassign d[71] = a[152];\nassign d[72] = a[36] ^ a[232];\nassign d[73] = a[153];\nassign d[74] = a[37] ^ a[196];\nassign d[75] = a[117] ^ a[154];\nassign d[76] = a[38] ^ a[197];\nassign d[77] = a[118] ^ a[155];\nassign d[78] = a[39] ^ a[198];\nassign d[79] = a[119] ^ a[156];\nassign d[80] = a[40] ^ a[199];\nassign d[81] = a[120] ^ a[157];\nassign d[82] = a[41] ^ a[200];\nassign d[83] = a[121] ^ a[158];\nassign d[84] = a[42] ^ a[201];\nassign d[85] = a[122] ^ a[159];\nassign d[86] = a[43] ^ a[202];\nassign d[87] = a[123] ^ a[160];\nassign d[88] = a[44] ^ a[203];\nassign d[89] = a[124] ^ a[161];\nassign d[90] = a[45] ^ a[204];\nassign d[91] = a[125] ^ a[162];\nassign d[92] = a[46] ^ a[205];\nassign d[93] = a[126] ^ a[163];\nassign d[94] = a[47] ^ a[206];\nassign d[95] = a[127] ^ a[164];\nassign d[96] = a[48] ^ a[207];\nassign d[97] = a[128] ^ a[165];\nassign d[98] = a[49] ^ a[208];\nassign d[99] = a[129] ^ a[166];\nassign d[100] = a[50] ^ a[209];\nassign d[101] = a[130] ^ a[167];\nassign d[102] = a[51] ^ a[210];\nassign d[103] = a[131] ^ a[168];\nassign d[104] = a[52] ^ a[211];\nassign d[105] = a[132] ^ a[169];\nassign d[106] = a[53] ^ a[212];\nassign d[107] = a[133] ^ a[170];\nassign d[108] = a[54] ^ a[213];\nassign d[109] = a[134] ^ a[171];\nassign d[110] = a[55] ^ a[214];\nassign d[111] = a[135] ^ a[172];\nassign d[112] = a[56] ^ a[215];\nassign d[113] = a[136] ^ a[173];\nassign d[114] = a[57] ^ a[216];\nassign d[115] = a[137] ^ a[174];\nassign d[116] = a[58] ^ a[217];\nassign d[117] = a[138] ^ a[175];\nassign d[118] = a[59] ^ a[218];\nassign d[119] = a[139] ^ a[176];\nassign d[120] = a[60] ^ a[219];\nassign d[121] = a[140] ^ a[177];\nassign d[122] = a[61] ^ a[220];\nassign d[123] = a[141] ^ a[178];\nassign d[124] = a[62] ^ a[221];\nassign d[125] = a[142] ^ a[179];\nassign d[126] = a[63] ^ a[222];\nassign d[127] = a[143] ^ a[180];\nassign d[128] = a[64] ^ a[223];\nassign d[129] = a[144] ^ a[181];\nassign d[130] = a[65] ^ a[224];\nassign d[131] = a[145] ^ a[182];\nassign d[132] = a[66] ^ a[225];\nassign d[133] = a[146] ^ a[183];\nassign d[134] = a[67] ^ a[226];\nassign d[135] = a[147] ^ a[184];\nassign d[136] = a[68] ^ a[227];\nassign d[137] = a[148] ^ a[185];\nassign d[138] = a[69] ^ a[228];\nassign d[139] = a[149] ^ a[186];\nassign d[140] = a[70] ^ a[229];\nassign d[141] = a[150] ^ a[187];\nassign d[142] = a[71] ^ a[230];\nassign d[143] = a[151] ^ a[188];\nassign d[144] = a[72] ^ a[231];\nassign d[145] = a[152] ^ a[189];\nassign d[146] = a[73] ^ a[232];\nassign d[147] = a[153] ^ a[190];\nassign d[148] = a[74];\nassign d[149] = a[154] ^ a[191];\nassign d[150] = a[75];\nassign d[151] = a[155] ^ a[192];\nassign d[152] = a[76];\nassign d[153] = a[156] ^ a[193];\nassign d[154] = a[77];\nassign d[155] = a[157] ^ a[194];\nassign d[156] = a[78];\nassign d[157] = a[158] ^ a[195];\nassign d[158] = a[79];\nassign d[159] = a[159] ^ a[196];\nassign d[160] = a[80];\nassign d[161] = a[160] ^ a[197];\nassign d[162] = a[81];\nassign d[163] = a[161] ^ a[198];\nassign d[164] = a[82];\nassign d[165] = a[162] ^ a[199];\nassign d[166] = a[83];\nassign d[167] = a[163] ^ a[200];\nassign d[168] = a[84];\nassign d[169] = a[164] ^ a[201];\nassign d[170] = a[85];\nassign d[171] = a[165] ^ a[202];\nassign d[172] = a[86];\nassign d[173] = a[166] ^ a[203];\nassign d[174] = a[87];\nassign d[175] = a[167] ^ a[204];\nassign d[176] = a[88];\nassign d[177] = a[168] ^ a[205];\nassign d[178] = a[89];\nassign d[179] = a[169] ^ a[206];\nassign d[180] = a[90];\nassign d[181] = a[170] ^ a[207];\nassign d[182] = a[91];\nassign d[183] = a[171] ^ a[208];\nassign d[184] = a[92];\nassign d[185] = a[172] ^ a[209];\nassign d[186] = a[93];\nassign d[187] = a[173] ^ a[210];\nassign d[188] = a[94];\nassign d[189] = a[174] ^ a[211];\nassign d[190] = a[95];\nassign d[191] = a[175] ^ a[212];\nassign d[192] = a[96];\nassign d[193] = a[176] ^ a[213];\nassign d[194] = a[97];\nassign d[195] = a[177] ^ a[214];\nassign d[196] = a[98];\nassign d[197] = a[178] ^ a[215];\nassign d[198] = a[99];\nassign d[199] = a[179] ^ a[216];\nassign d[200] = a[100];\nassign d[201] = a[180] ^ a[217];\nassign d[202] = a[101];\nassign d[203] = a[181] ^ a[218];\nassign d[204] = a[102];\nassign d[205] = a[182] ^ a[219];\nassign d[206] = a[103];\nassign d[207] = a[183] ^ a[220];\nassign d[208] = a[104];\nassign d[209] = a[184] ^ a[221];\nassign d[210] = a[105];\nassign d[211] = a[185] ^ a[222];\nassign d[212] = a[106];\nassign d[213] = a[186] ^ a[223];\nassign d[214] = a[107];\nassign d[215] = a[187] ^ a[224];\nassign d[216] = a[108];\nassign d[217] = a[188] ^ a[225];\nassign d[218] = a[109];\nassign d[219] = a[189] ^ a[226];\nassign d[220] = a[110];\nassign d[221] = a[190] ^ a[227];\nassign d[222] = a[111];\nassign d[223] = a[191] ^ a[228];\nassign d[224] = a[112];\nassign d[225] = a[192] ^ a[229];\nassign d[226] = a[113];\nassign d[227] = a[193] ^ a[230];\nassign d[228] = a[114];\nassign d[229] = a[194] ^ a[231];\nassign d[230] = a[115];\nassign d[231] = a[195] ^ a[232];\nassign d[232] = a[116];\nendmodule\n`endif\n",
        "module_name": "squarer",
        "module_hash": "f3ec2a4f1408cc2ca0a8060edc874da8",
        "dataset_index": 13527
      },
      "lookahead_42e1ed45": {
        "rtl_code": "\n module lookahead(c_in, c_out, c, p, g, P, G);\n   input [3:0] p, g;\n   input c_in;\n   \n   output [2:0] c;\n   output c_out;\n   output P, G;\n   \n   assign  c[0] = g[0] | (p[0] & c_in); \n   assign  c[1] = g[1] | (g[0] & p[1]) | (p[1] & p[0] & c_in); \n   assign  c[2] = g[2] | (g[1] & p[2]) | (g[0] & p[1] & p[2]) | (p[2] & p[1] & p[0] & c_in); \n   assign  c_out = g[3] | (g[2] & p[3]) | (g[1] & p[2] & p[3]) | (g[0] & p[1] & p[2] & p[3]) | (p[3] & p[2] & p[1] & p[0] & c_in);  \n   \n   assign  G = g[3] | (g[2] & p[3]) | (g[1] & p[2] & p[3]) | (p[3] & p[2] & p[1] & g[0]);\n   assign  P = p[3] & p[2] & p[1] & p[0];\n   \nendmodule",
        "module_name": "lookahead",
        "module_hash": "42e1ed4593877838a0495f85cca2d1f0",
        "dataset_index": 22129
      },
      "crc_3b5d82f2": {
        "rtl_code": "module crc(\n  input [15:0] data_in,\n  input crc_en,\n  output reg [15:0] crc_out,\n  input rst,\n  input clk\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      crc_out <= 16'h0000;\n    end else if (crc_en) begin\n      crc_out <= data_in + 16'hA001;\n    end\n  end\n\nendmodule\n",
        "module_name": "crc",
        "module_hash": "3b5d82f2fb15c70a3b40a4572c07d953",
        "dataset_index": 3079
      },
      "binary_to_bcd_265d2873": {
        "rtl_code": "module binary_to_bcd (\n    input [3:0] binary_in,\n    output [7:0] bcd_out,\n    output overflow\n);\n\n    wire [3:0] digit;\n    wire [3:0] carry;\n    wire [7:0] bcd;\n\n    assign digit[0] = binary_in[0];\n    assign digit[1] = binary_in[1];\n    assign digit[2] = binary_in[2];\n    assign digit[3] = binary_in[3];\n\n    assign bcd[0] = digit[0] + digit[1]*2 + digit[2]*4 + digit[3]*8;\n    assign bcd[1] = digit[0]*2 + digit[1]*4 + digit[2]*8;\n    assign bcd[2] = digit[0]*4 + digit[1]*8;\n    assign bcd[3] = digit[0]*8;\n\n    assign carry[0] = (bcd[0] > 9);\n    assign carry[1] = (bcd[1] > 9);\n    assign carry[2] = (bcd[2] > 9);\n    assign carry[3] = (bcd[3] > 9);\n\n    assign bcd_out[0] = bcd[0];\n    assign bcd_out[1] = bcd[1];\n    assign bcd_out[2] = bcd[2];\n    assign bcd_out[3] = bcd[3];\n    assign bcd_out[4] = carry[0];\n    assign bcd_out[5] = carry[1];\n    assign bcd_out[6] = carry[2];\n    assign bcd_out[7] = carry[3];\n\n    assign overflow = (carry[3] == 1);\n\nendmodule\n\nmodule binary_to_excess3 (\n    input [3:0] binary_in,\n    output [3:0] excess3_out\n);\n\n    assign excess3_out[0] = binary_in[0] ^ 1 ^ 1 ^ 1;\n    assign excess3_out[1] = binary_in[1] ^ 1 ^ 1 ^ 1;\n    assign excess3_out[2] = binary_in[2] ^ 1 ^ 1 ^ 1;\n    assign excess3_out[3] = binary_in[3] ^ 1 ^ 1 ^ 1;\n\nendmodule\n\nmodule top_module (\n    input [3:0] B,\n    output [7:0] bcd_out,\n    output overflow,\n    output reg [3:0] E,\n    output reg [3:0] sum\n);\n\n    wire [3:0] binary_out;\n    wire [3:0] excess3_out;\n\n    binary_to_excess3 bin2ex3(.binary_in(B), .excess3_out(excess3_out));\n    binary_to_bcd bin2bcd(.binary_in(excess3_out), .bcd_out(bcd_out), .overflow(overflow));\n\n    always @* begin\n        E = excess3_out;\n        sum = B + E;\n    end\n\nendmodule",
        "module_name": "binary_to_bcd",
        "module_hash": "265d287344efc004327915a12ab2fc1a",
        "dataset_index": 20447
      },
      "top__ea482bac": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input a,          // Input signal to the first XOR gate\n    input b,          // Input signal to the first XOR gate\n    input c,          // Input signal to the second XOR gate\n    input d,          // Input signal to the second XOR gate\n    input control,    // Control signal for the tri-state buffer\n    output [2:0] q // 3-bit output from the system\n);\n\nreg [3:0] counter;\nwire [3:0] counter_out;\nwire [1:0] xor_out;\nwire mult_out;\n\n// Counter module\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Output module\nassign counter_out = counter[2:0];\nassign xor_out = {a^b, c^d};\nassign mult_out = (xor_out[0] & counter_out) ^ (xor_out[1] & counter_out);\n\n// Tri-state buffer module\nreg [2:0] q_reg;\nalways@(control or mult_out) begin\n    if(control) begin\n        q_reg = mult_out;\n    end\nend\nassign q = q_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "ea482bac0db186fa326419e86378a032",
        "dataset_index": 11852
      },
      "ptp_tag_insert #_c20ed24e": {
        "rtl_code": "\n\n`resetall\n\n\n\n\nmodule ptp_tag_insert #\n(\n    parameter DATA_WIDTH = 64,\n    parameter KEEP_WIDTH = DATA_WIDTH/8,\n    parameter TAG_WIDTH = 16,\n    parameter TAG_OFFSET = 1,\n    parameter USER_WIDTH = TAG_WIDTH+TAG_OFFSET\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    \n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    \n    input  wire [TAG_WIDTH-1:0]   s_axis_tag,\n    input  wire                   s_axis_tag_valid,\n    output wire                   s_axis_tag_ready\n);\n\nreg [TAG_WIDTH-1:0] tag_reg = {TAG_WIDTH{1'b0}};\nreg tag_valid_reg = 1'b0;\n\nreg [USER_WIDTH-1:0] user;\n\nassign s_axis_tready = m_axis_tready && tag_valid_reg;\n\nassign m_axis_tdata  = s_axis_tdata;\nassign m_axis_tkeep  = s_axis_tkeep;\nassign m_axis_tvalid = s_axis_tvalid && tag_valid_reg;\nassign m_axis_tlast  = s_axis_tlast;\nassign m_axis_tuser  = user;\n\nassign s_axis_tag_ready = !tag_valid_reg;\n\nalways @* begin\n    user = s_axis_tuser;\n    user[TAG_OFFSET +: TAG_WIDTH] = tag_reg;\nend\n\nalways @(posedge clk) begin\n    if (tag_valid_reg) begin\n        if (s_axis_tvalid && s_axis_tready && s_axis_tlast) begin\n            tag_valid_reg <= 1'b0;\n        end\n    end else begin\n        tag_reg <= s_axis_tag;\n        tag_valid_reg <= s_axis_tag_valid;\n    end\n\n    if (rst) begin\n        tag_valid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n",
        "module_name": "ptp_tag_insert #",
        "module_hash": "c20ed24eb0563eee909cb720c8786316",
        "dataset_index": 5850
      },
      "dmem_f68cc6e2": {
        "rtl_code": "\nmodule dmem(\n    output  [31:0] RD,\n    input   [31:0] A, WD,\n    input   WE, clk\n    );\n\n    reg [31:0] RAM [0:255];\n\n    assign RD = (A != 0) ? RAM[A[7:0]] : 0;\n\n    always @ (posedge clk)\n        if (WE)\n            RAM[A[7:0]] <= WD;\n            endmodule\n",
        "module_name": "dmem",
        "module_hash": "f68cc6e244151de8a494670c0e0e298f",
        "dataset_index": 11661
      },
      "barrel_shifter_bd3a6404": {
        "rtl_code": "module barrel_shifter (\n    input [15:0] DATA,\n    input [3:0] SHIFT,\n    input [1:0] CTRL,\n    output reg [15:0] out\n);\n\nreg [15:0] shift_reg1, shift_reg2, shift_reg3;\n\nalways @(*) begin\n    shift_reg1 = DATA;\n    shift_reg2 = (CTRL == 2'b00) ? {DATA[14:0], 1'b0} :\n                 (CTRL == 2'b01) ? {1'b0, DATA[15:1]} :\n                 (CTRL == 2'b10) ? {{DATA[15], DATA[15:1]}, DATA[15]} :\n                                   {DATA[0], DATA[15:1]};\n    shift_reg3 = (SHIFT[3] == 1'b1) ? shift_reg2 :\n                 (SHIFT[2] == 1'b1) ? shift_reg2 >> 2 :\n                 (SHIFT[1] == 1'b1) ? shift_reg2 >> 4 :\n                                      shift_reg2 >> 8;\n    out = (SHIFT[0] == 1'b1) ? shift_reg3 :\n          (SHIFT[1:0] == 2'b01) ? {shift_reg3[0], shift_reg3[15:1]} :\n          (SHIFT[1:0] == 2'b10) ? {{shift_reg3[15], shift_reg3[15:1]}, shift_reg3[15]} :\n                                   {shift_reg3[14:0], shift_reg3[0]};\nend\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "bd3a6404914dc9353250f69d3e77af53",
        "dataset_index": 10323
      },
      "test_stub_scan_c0b6dfe6": {
        "rtl_code": "module test_stub_scan (\nmux_drive_disable, mem_write_disable, sehold, se, testmode_l, \nmem_bypass, so_0, so_1, so_2, \nctu_tst_pre_grst_l, arst_l, global_shift_enable, \nctu_tst_scan_disable, ctu_tst_scanmode, ctu_tst_macrotest, \nctu_tst_short_chain, long_chain_so_0, short_chain_so_0, \nlong_chain_so_1, short_chain_so_1, long_chain_so_2, short_chain_so_2\n);\n\n   input        ctu_tst_pre_grst_l;\n   input        arst_l;                input        global_shift_enable;\n   input        ctu_tst_scan_disable;  input        ctu_tst_scanmode;\n   input \tctu_tst_macrotest;\n   input \tctu_tst_short_chain;\n   input \tlong_chain_so_0;\n   input \tshort_chain_so_0;\n   input \tlong_chain_so_1;\n   input \tshort_chain_so_1;\n   input \tlong_chain_so_2;\n   input \tshort_chain_so_2;\n   \n   output \tmux_drive_disable;\n   output \tmem_write_disable;\n   output \tsehold;\n   output \tse;\n   output \ttestmode_l;\n   output \tmem_bypass;\n   output \tso_0;\n   output \tso_1;\n   output \tso_2;\n\n   wire         pin_based_scan;\n   wire         short_chain_en;\n   wire         short_chain_select;\n\n   assign  mux_drive_disable  = ~ctu_tst_pre_grst_l | short_chain_select | se;\n   assign  mem_write_disable  = ~ctu_tst_pre_grst_l | se;\n   assign  sehold             = ctu_tst_macrotest & ~se;\n   assign  se                 = global_shift_enable;\n   assign  testmode_l         = ~ctu_tst_scanmode;\n   assign  mem_bypass         = ~ctu_tst_macrotest & ~testmode_l;\n   assign  pin_based_scan     = ctu_tst_scan_disable;\n   assign  short_chain_en     = ~(pin_based_scan & se);\n   assign  short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;\n   assign  so_0               = short_chain_select ? short_chain_so_0 : long_chain_so_0;\n   assign  so_1               = short_chain_select ? short_chain_so_1 : long_chain_so_1;\n   assign  so_2               = short_chain_select ? short_chain_so_2 : long_chain_so_2;\n   \nendmodule ",
        "module_name": "test_stub_scan",
        "module_hash": "c0b6dfe6fdc8375e2b30e5dd20470ffd",
        "dataset_index": 23972
      },
      "comparator_264a743e": {
        "rtl_code": "module comparator(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [1:0] C\n);\n\n// Comparing A and B\nalways @(*) begin\n    if(A == B) begin\n        C = 2'b00;\n    end\n    else if(A > B) begin\n        C = 2'b01;\n    end\n    else begin\n        C = 2'b10;\n    end\nend\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "264a743ed02dead87e733a0c67773cc7",
        "dataset_index": 21518
      },
      "ASYNC_TO_SYNC_d5e9ff36": {
        "rtl_code": "module ASYNC_TO_SYNC (\n  input in,\n  input clk,\n  input rst,\n  output reg out\n);\n\nparameter n = 3; // number of synchronizer stages\n\nreg [n-1:0] sync_reg; // register chain for synchronizer\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    sync_reg <= {n{1'b0}}; // reset register chain\n    out <= 1'b0; // reset output signal\n  end else begin\n    sync_reg <= {sync_reg[n-2:0], in}; // shift input signal through register chain\n    out <= sync_reg[n-1]; // output final synchronized signal\n  end\nend\n\nendmodule\n\nmodule SYNC_TO_ASYNC (\n  input clk,\n  input rst,\n  input in,\n  output reg out\n);\n\nparameter n = 4; // number of synchronizer stages\n\nreg [n-1:0] sync_reg; // register chain for synchronizer\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    sync_reg <= {n{1'b0}}; // reset register chain\n    out <= 1'b0; // reset output signal\n  end else begin\n    sync_reg <= {sync_reg[n-2:0], in}; // shift input signal through register chain\n    out <= sync_reg[n-1]; // output final synchronized signal\n  end\nend\n\nendmodule",
        "module_name": "ASYNC_TO_SYNC",
        "module_hash": "d5e9ff36856194ce0f442a9760268708",
        "dataset_index": 10504
      },
      "Depulser_4faf8127": {
        "rtl_code": "module Depulser(\n  input   wire clock,\n  input   wire reset,\n  input   wire io_in,\n  input   wire io_rst,\n  output  reg  io_out\n);\n  wire  r_clock;\n  wire  r_reset;\n  wire  r_io_in;\n  wire  r_io_init;\n  reg   r_io_out;\n  wire  r_io_enable;\n  wire  _T_9;\n  wire  _T_11;\n  \n  reg [1:0] state = 2'b00; // Initialize state to 0\n  wire pulse;\n  \n  assign pulse = (r_io_in == 1'b1) && (state == 2'b00); // Detect a pulse\n  \n  always @(posedge r_clock or posedge r_reset) begin\n    if (r_reset == 1'b1) begin // Reset output to 0\n      r_io_out <= 1'b0;\n      state <= 2'b00;\n    end else if (pulse) begin // Hold output high for one clock cycle\n      r_io_out <= 1'b1;\n      state <= 2'b01;\n    end else if (state == 2'b01) begin // Return output to 0\n      r_io_out <= 1'b0;\n      state <= 2'b10;\n    end else begin // Pass input to output\n      r_io_out <= r_io_in;\n      state <= 2'b00;\n    end\n  end\n  \n  always @* begin\n    io_out = r_io_out;\n  end\n  \n  assign r_clock = clock;\n  assign r_reset = reset;\n  assign r_io_in = _T_9;\n  assign r_io_init = 1'h0;\n  assign r_io_enable = _T_11;\n  assign _T_9 = io_rst ? 1'h0 : io_in;\n  assign _T_11 = io_in | io_rst;\nendmodule",
        "module_name": "Depulser",
        "module_hash": "4faf81271cd4c211ece84ce63e1217e8",
        "dataset_index": 10792
      },
      "gray_counter_28c55fe4": {
        "rtl_code": "\nmodule gray_counter (\n    input clk,\n    input reset,\n    input ena,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (ena) begin\n            q <= q ^ (q >> 1);\n        end else begin\n            q <= q ^ (q << 1);\n        end\n    end\n\nendmodule\nmodule barrel_shifter (\n    input [3:0] a,\n    input [1:0] b,\n    output [3:0] q\n);\n\n    assign q = (b[1]) ? (b[0]) ? {a[1:0], 2'b00} : {2'b00, a[3:2]} : (b[0]) ? {a[0], a[3:1]} : {a[2:0], a[3]};\n\nendmodule\nmodule and_gate (\n    input [3:0] a,\n    output [3:0] q\n);\n\n    assign q = a & 4'b1100;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input ena,\n    input [1:0] select, // Fixed the width of 'select' port to 2 bits\n    output [3:0] q\n);\n\n    wire [3:0] gray_out;\n    wire [3:0] shift_out;\n    wire [3:0] and_out;\n\n    gray_counter gc (\n        .clk(clk),\n        .reset(reset),\n        .ena(ena),\n        .q(gray_out)\n    );\n\n    barrel_shifter bs (\n        .a(gray_out),\n        .b(select),\n        .q(shift_out)\n    );\n\n    and_gate ag (\n        .a(shift_out),\n        .q(and_out)\n    );\n\n    assign q = and_out;\n\nendmodule",
        "module_name": "gray_counter",
        "module_hash": "28c55fe401b1e66e707f5177e21b1238",
        "dataset_index": 12905
      },
      "up_down_counter_5098fbf3": {
        "rtl_code": "module up_down_counter (\n  input clk,\n  input reset,\n  input up_down,\n  input enable,\n  output reg [8:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    q <= 0;\n  end else if (enable) begin\n    if (up_down) begin\n      q <= q + 1;\n    end else begin\n      q <= q - 1;\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "up_down_counter",
        "module_hash": "5098fbf3d8d654c3e50f15054a02b2b4",
        "dataset_index": 15248
      },
      "VerilogModule_d06a5965": {
        "rtl_code": "\nmodule VerilogModule (\n    input CLOCK_27,\n    input CLOCK_50,\n    input [3:0] KEY,\n    input [17:0] SW,\n    output [6:0] HEX0,\n    output [6:0] HEX1,\n    output [6:0] HEX2,\n    output [6:0] HEX3,\n    output [6:0] HEX4,\n    output [6:0] HEX5,\n    output [6:0] HEX6,\n    output [6:0] HEX7,\n    output [8:0] LEDG,\n    output [17:0] LEDR,\n    output UART_TXD,\n    input UART_RXD,\n    inout [7:0] LCD_DATA,\n    output LCD_ON,\n    output LCD_BLON,\n    output LCD_RW,\n    output LCD_EN,\n    output LCD_RS,\n    inout [35:0] GPIO_0,\n    inout [35:0] GPIO_1\n);\n\n    reg [15:0] d0, d1, d2, d3, d4;\n    reg [17:0] LEDR;\n    reg [8:0] LEDG;\n\n    // Store values of DPDT switch in registers\n    always @(posedge KEY[2]) begin\n        case(SW[17:16])\n            0: d0 <= SW[15:0];\n            1: d1 <= SW[15:0];\n            2: d2 <= SW[15:0];\n            default: d3 <= SW[15:0];\n        endcase\n    end\n\n    // Add value of d0 to d4 when push button is pressed\n    always @(posedge CLOCK_27) begin\n        if(!KEY[0]) begin\n            d4 <= 0;\n        end else begin\n            d4 <= d4 + d0;\n        end\n    end\n\n    // Output values of d0, d1, d2, d3, and d4 to 7-segment display\n    assign HEX0 = d0;\n    assign HEX1 = d1;\n    assign HEX2 = d2;\n    assign HEX3 = d3;\n    assign HEX4 = d4;\n    assign HEX5 = 7'b1111111;\n    assign HEX6 = 7'b1111111;\n    assign HEX7 = 7'b1111111;\n\n    // Output values of d0, d1, d2, d3, and d4 to UART transmitter\n    assign UART_TXD = {d0, d1, d2, d3, d4};\n\n    // Display values of d0, d1, d2, d3, and d4 on LCD module\n    assign LCD_ON = 1'b1;\n    assign LCD_BLON = 1'b1;\n    assign LCD_RW = 1'b0;\n    assign LCD_EN = 1'b1;\n    assign LCD_RS = 1'b1;\n\n    // Drive LEDR\n    always @(posedge CLOCK_27) begin\n        LEDR <= d0;\n    end\n\n    // Drive LEDG\n    always @(posedge CLOCK_27) begin\n        LEDG <= 9'b111111111;\n    end\n\nendmodule",
        "module_name": "VerilogModule",
        "module_hash": "d06a59653ca61b8cdd570cc9f7177844",
        "dataset_index": 4714
      },
      "counter16_25b83848": {
        "rtl_code": "module counter16(\n  input clk, // input clock signal\n  input rst, // synchronous reset signal\n  output reg [15:0] count // output count value\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n    end else if (count == 65535) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter16",
        "module_hash": "25b8384838412ea70273fabd225d9a84",
        "dataset_index": 16289
      },
      "mux4to1_78117a99": {
        "rtl_code": "module mux4to1 (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input sel0,\n    input sel1,\n    input clk,\n    output reg out\n);\n    \n    always @(posedge clk) begin\n        if (sel1 == 0 && sel0 == 0) begin\n            out <= in0;\n        end else if (sel1 == 0 && sel0 == 1) begin\n            out <= in1;\n        end else if (sel1 == 1 && sel0 == 0) begin\n            out <= in2;\n        end else begin\n            out <= in3;\n        end\n    end\n    \nendmodule",
        "module_name": "mux4to1",
        "module_hash": "78117a99e046391f2af841aada4206d7",
        "dataset_index": 946
      },
      "dual_edge_ff_db1214ff": {
        "rtl_code": "module dual_edge_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q1, q2;\n\n// First D flip-flop captures data on rising edge of clock\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\n// Second D flip-flop captures output of first flip-flop on falling edge of clock\nalways @(negedge clk) begin\n    q2 <= q1;\nend\n\n// Output of second flip-flop is the output of the module\nassign q = q2;\n\nendmodule",
        "module_name": "dual_edge_ff",
        "module_hash": "db1214ffddb21220d598a41576f1f4c9",
        "dataset_index": 3036
      },
      "my_and_nor_b4b17328": {
        "rtl_code": "module my_and_nor (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire b         ;\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    //  Name  Output      Other arguments\n    not not0 (b         , B1_N           );\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, b, and0_out    );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule",
        "module_name": "my_and_nor",
        "module_hash": "b4b1732837e05c9808ad0ffdd16cd3d6",
        "dataset_index": 12635
      },
      "sum_diff_842612f0": {
        "rtl_code": "module sum_diff (\n  input [7:0] A,\n  input [7:0] B,\n  output [7:0] S,\n  output [7:0] D\n);\n\n\n  assign S = A + B;\n  assign D = A - B;\n\nendmodule",
        "module_name": "sum_diff",
        "module_hash": "842612f0de491911a88cf0914afba6d8",
        "dataset_index": 7591
      },
      "openhmc_counter48 #_57a62d3a": {
        "rtl_code": "\n\nmodule openhmc_counter48 #(\n        parameter DATASIZE  = 16    ) (\n        input wire                  clk,\n        input wire                  res_n,\n        input wire                  increment,\n        input wire                  load_enable,\n        output wire [DATASIZE-1:0]  value\n);\n\n    reg [DATASIZE-1:0]  value_reg;\n    reg                 load_enable_reg;\n\n    assign value    = value_reg;\n\n    `ifdef ASYNC_RES\n    always @(posedge clk or negedge res_n) `else\n    always @(posedge clk) `endif\n    begin\n        if(!res_n) begin\n            value_reg               <= {DATASIZE{1'b0}};\n            load_enable_reg         <= 1'b0;\n        end else begin\n            load_enable_reg         <= load_enable;\n            case ({load_enable_reg,increment})\n                    2'b00:\n                        value_reg   <= value_reg;\n                    2'b01:\n                        value_reg   <= (value_reg + 1'b1);\n                    2'b10:\n                        value_reg   <= {DATASIZE{1'b0}};\n                    2'b11:\n                        value_reg   <= {DATASIZE{1'b0}} + 1'b1;\n            endcase\n        end\n    end\n\nendmodule\n",
        "module_name": "openhmc_counter48 #",
        "module_hash": "57a62d3aa1e839b481c8f39f47b0374c",
        "dataset_index": 23129
      },
      "NPCG_Toggle_BNC_P_read_DT00h_c178a4b5": {
        "rtl_code": "\n\nmodule NPCG_Toggle_BNC_P_read_DT00h\n#\n(\n    parameter NumberOfWays    =   4\n)\n(\n    iSystemClock        ,\n    iReset              ,\n    iOpcode             ,\n    iTargetID           ,\n    iSourceID           ,\n    iLength             ,\n    iCMDValid           ,\n    oCMDReady           ,\n    oReadData           ,\n    oReadLast           ,\n    oReadValid          ,\n    iReadReady          ,\n    iWaySelect          ,\n    iColAddress         ,\n    iRowAddress         ,\n    oStart              ,\n    oLastStep           ,\n    iPM_Ready           ,\n    iPM_LastStep        ,\n    oPM_PCommand        ,\n    oPM_PCommandOption  ,\n    oPM_TargetWay       ,\n    oPM_NumOfData       ,\n    oPM_CASelect        ,\n    oPM_CAData          ,\n    iPM_ReadData        ,\n    iPM_ReadLast        ,\n    iPM_ReadValid       ,\n    oPM_ReadReady\n);\n    input                           iSystemClock        ;\n    input                           iReset              ;\n    input   [5:0]                   iOpcode             ;\n    input   [4:0]                   iTargetID           ;\n    input   [4:0]                   iSourceID           ;\n    input   [15:0]                  iLength             ;\n    input                           iCMDValid           ;\n    output                          oCMDReady           ;\n    output  [31:0]                  oReadData           ;\n    output                          oReadLast           ;\n    output                          oReadValid          ;\n    input                           iReadReady          ;\n    input  [NumberOfWays - 1:0]     iWaySelect          ;\n    input   [15:0]                  iColAddress             ;\n    input   [23:0]                  iRowAddress             ;\n    output                          oStart              ;\n    output                          oLastStep           ;\n    input   [7:0]                   iPM_Ready           ;\n    input   [7:0]                   iPM_LastStep        ;\n    output  [7:0]                   oPM_PCommand        ;\n    output  [2:0]                   oPM_PCommandOption  ;\n    output  [NumberOfWays - 1:0]    oPM_TargetWay       ;\n    output  [15:0]                  oPM_NumOfData       ;\n    output                          oPM_CASelect        ;\n    output  [7:0]                   oPM_CAData          ;\n    input   [31:0]                  iPM_ReadData        ;\n    input                           iPM_ReadLast        ;\n    input                           iPM_ReadValid       ;\n    output                          oPM_ReadReady       ;\n\n    reg [NumberOfWays - 1:0]    rTargetWay  ;\n    reg [15:0]                  rColAddress ;\n    reg [23:0]                  rRowAddress ;\n    wire                        wModuleTriggered;\n    \n    reg [7:0]                   rPMTrigger  ;\n    reg [2:0]                   rPCommandOption ;\n    reg [15:0]                  rPMLength   ;\n    reg [15:0]                  rTrfLength  ;\n    \n    reg [7:0]                   rCAData     ;\n    reg                         rPMCommandOrAddress ;\n\n    localparam  State_Idle          = 4'b0000   ;\n    localparam  State_NPBRIssue     = 4'b0001   ;\n    localparam  State_NCmdIssue     = 4'b0011   ;\n    localparam  State_NCmdWrite0    = 4'b0010   ;\n    localparam  State_NCmdWrite1    = 4'b0110   ;\n    localparam  State_NCmdWrite2    = 4'b0111   ;\n    localparam  State_NCmdWrite3    = 4'b0101   ;\n    localparam  State_NTimer1Issue  = 4'b0100   ;\n    localparam  State_DIIssue       = 4'b1100   ;\n    localparam  State_NTimer2Issue  = 4'b1101   ;\n    localparam  State_WaitDone      = 4'b1111   ;\n    \n    reg [3:0]   rCurState   ;\n    reg [3:0]   rNextState  ;\n\n    always @ (posedge iSystemClock)\n        if (iReset)\n            rCurState <= State_Idle;\n        else\n            rCurState <= rNextState;\n\n    always @ (*)\n        case (rCurState)\n        State_Idle:\n            rNextState <= (wModuleTriggered)?State_NPBRIssue:State_Idle;\n        State_NPBRIssue:\n            rNextState <= (iPM_Ready)?State_NCmdIssue:State_NPBRIssue;\n        State_NCmdIssue:\n            rNextState <= (iPM_LastStep[6])? State_NCmdWrite0:State_NCmdIssue;\n        State_NCmdWrite0:\n            rNextState <= State_NCmdWrite1;\n        State_NCmdWrite1:\n            rNextState <= State_NCmdWrite2;\n        State_NCmdWrite2:\n            rNextState <= State_NCmdWrite3;\n        State_NCmdWrite3:\n            rNextState <= State_NTimer1Issue;\n        State_NTimer1Issue:\n            rNextState <= (iPM_LastStep[3])? State_DIIssue:State_NTimer1Issue;\n        State_DIIssue:\n            rNextState <= (iPM_LastStep[0])? State_NTimer2Issue:State_DIIssue;\n        State_NTimer2Issue:\n            rNextState <= (iPM_LastStep[1])? State_WaitDone:State_NTimer2Issue;\n        State_WaitDone:\n            rNextState <= (oLastStep)?State_Idle:State_WaitDone;\n        default:\n            rNextState <= State_Idle;\n        endcase\n    \n    assign wModuleTriggered = (iCMDValid && iTargetID == 5'b00101 && iOpcode == 6'b000011);\n    assign oCMDReady = (rCurState == State_Idle);\n    \n    always @ (posedge iSystemClock)\n        if (iReset)\n        begin\n            rTargetWay <= {(NumberOfWays){1'b0}};\n            rTrfLength  <= 16'b0;\n            rColAddress <= 16'b0;\n            rRowAddress <= 24'b0;\n        end\n        else\n            if (wModuleTriggered && (rCurState == State_Idle))\n            begin\n                rTargetWay  <= iWaySelect   ;\n                rTrfLength  <= iLength      ;\n                rColAddress <= iColAddress  ;\n                rRowAddress <= iRowAddress  ;\n            end\n    \n    always @ (*)\n        case (rCurState)\n        State_NPBRIssue:\n            rPMTrigger <= 8'b0100_0000;\n        State_NCmdIssue:\n            rPMTrigger <= 8'b0000_1000;\n        State_NTimer1Issue:\n            rPMTrigger <= 8'b0000_0001;\n        State_DIIssue:\n            rPMTrigger <= 8'b0000_0010;\n        State_NTimer2Issue:\n            rPMTrigger <= 8'b0000_0001;\n        default:\n            rPMTrigger <= 8'b0000_0000;\n        endcase\n    \n    always @ (*)\n        case (rCurState)\n        State_NTimer1Issue:\n            rPCommandOption[2:0] <= 3'b001; State_DIIssue:\n            rPCommandOption[2:0] <= 3'b001; State_NTimer2Issue:\n            rPCommandOption[2:0] <= 3'b100;\n        default:\n            rPCommandOption[2:0] <= 0;\n        endcase\n    \n    always @ (*)\n        if (iReset)\n            rPMLength <= 0;\n        else\n            case (rCurState)\n            State_NCmdIssue:\n                rPMLength <= 16'd3;\n            State_NTimer1Issue:\n                rPMLength <= 16'd33; State_DIIssue:\n                rPMLength <= rTrfLength;\n            State_NTimer2Issue:\n                rPMLength <= 16'd3; default:\n                rPMLength <= 0;\n            endcase\n        \n    always @ (*)\n        case (rCurState)\n        State_NCmdWrite0:\n            rPMCommandOrAddress <= 1'b0;\n        State_NCmdWrite1:\n            rPMCommandOrAddress <= 1'b1;\n        State_NCmdWrite2:\n            rPMCommandOrAddress <= 1'b1;\n        State_NCmdWrite3:\n            rPMCommandOrAddress <= 1'b0;\n        default:\n            rPMCommandOrAddress <= 1'b0;\n        endcase\n    \n    always @ (*)\n        if (iReset)\n            rCAData <= 0;\n        else\n            case (rCurState)\n            State_NCmdWrite0:\n                rCAData <= 8'h05;\n            State_NCmdWrite1:\n                rCAData <= rColAddress[7:0];\n            State_NCmdWrite2:\n                rCAData <= rColAddress[15:8];\n            State_NCmdWrite3:\n                rCAData <= 8'hE0;\n            default:\n                rCAData <= 0;\n            endcase\n    \n    assign oStart = wModuleTriggered;\n    assign oLastStep            = (rCurState == State_WaitDone) & iPM_LastStep[0];\n    \n    assign oReadData            = iPM_ReadData;\n    assign oReadLast            = iPM_ReadLast;\n    assign oReadValid           = iPM_ReadValid;\n    assign oPM_ReadReady        = iReadReady;\n    \n    assign oPM_PCommand         = rPMTrigger;\n    assign oPM_PCommandOption   = rPCommandOption; assign oPM_TargetWay        = rTargetWay;\n    assign oPM_NumOfData        = rPMLength ;\n    assign oPM_CASelect         = rPMCommandOrAddress;\n    assign oPM_CAData           = rCAData;\n    \nendmodule\n",
        "module_name": "NPCG_Toggle_BNC_P_read_DT00h",
        "module_hash": "c178a4b545e5d565444431c4310bf7ee",
        "dataset_index": 25598
      },
      "var20_multi_c906ec5f": {
        "rtl_code": "\nmodule var20_multi (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, valid);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T;\n    output valid;\n\n    wire [8:0] min_value = 9'd120;\n    wire [8:0] max_weight = 9'd60;\n    wire [8:0] max_volume = 9'd60;\nwire [8:0]  total_value = \n        A * 9'd4\n      + B * 9'd8\n      + C * 9'd0\n      + D * 9'd20\n      + E * 9'd10\n      + F * 9'd12\n      + G * 9'd18\n      + H * 9'd14\n      + I * 9'd6\n      + J * 9'd15\n      + K * 9'd30\n      + L * 9'd8\n      + M * 9'd16\n      + N * 9'd18\n      + O * 9'd18\n      + P * 9'd14\n      + Q * 9'd7\n      + R * 9'd7\n      + S * 9'd29\n      + T * 9'd23;\n\n    wire [8:0]  total_weight = \n        A * 9'd28\n      + B * 9'd8\n      + C * 9'd27\n      + D * 9'd18\n      + E * 9'd27\n      + F * 9'd28\n      + G * 9'd6\n      + H * 9'd1\n      + I * 9'd20\n      + J * 9'd0\n      + K * 9'd5\n      + L * 9'd13\n      + M * 9'd8\n      + N * 9'd14\n      + O * 9'd22\n      + P * 9'd12\n      + Q * 9'd23\n      + R * 9'd26\n      + S * 9'd1\n      + T * 9'd22;\n\n    wire [8:0]  total_volume = \n        A * 9'd27\n      + B * 9'd27\n      + C * 9'd4\n      + D * 9'd4\n      + E * 9'd0\n      + F * 9'd24\n      + G * 9'd4\n      + H * 9'd20\n      + I * 9'd12\n      + J * 9'd15\n      + K * 9'd5\n      + L * 9'd2\n      + M * 9'd9\n      + N * 9'd28\n      + O * 9'd19\n      + P * 9'd18\n      + Q * 9'd30\n      + R * 9'd12\n      + S * 9'd28\n      + T * 9'd13;\n\nassign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume));\nendmodule\n",
        "module_name": "var20_multi",
        "module_hash": "c906ec5f2991d90055d40bcbc226d98c",
        "dataset_index": 7308
      },
      "top__6a955f49": {
        "rtl_code": "module top_module (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    input [31:0] in,\n    output reg [7:0] sum\n);\n\n// Rotator module with synchronous load input\nreg [99:0] rot_data;\nreg [31:0] rot_in;\nreg [31:0] rot_out;\nreg [4:0] rot_amt;\n\nalways @(posedge clk) begin\n    if (load) begin\n        rot_data <= data;\n        rot_in <= in;\n        rot_amt <= rot_in[4:0];\n    end else if (ena[0]) begin\n        rot_data <= {rot_data[99-rot_amt:0], rot_data[99:99-rot_amt]};\n    end else if (ena[1]) begin\n        rot_data <= {rot_data[99-rot_amt:0], rot_data[99:99-rot_amt]};\n        rot_out <= {rot_data[31:24], rot_data[23:16], rot_data[15:8], rot_data[7:0]};\n    end\nend\n\n// Byte ordering module\nreg [31:0] byte_in;\nreg [31:0] byte_out;\n\nalways @(posedge clk) begin\n    if (ena[1]) begin\n        byte_in <= rot_out;\n        byte_out <= {byte_in[7:0], byte_in[15:8], byte_in[23:16], byte_in[31:24]};\n    end\nend\n\n// Functional module to calculate sum of bytes\nalways @(posedge clk) begin\n    if (ena[1]) begin\n        sum <= byte_out[7:0] + byte_out[15:8] + byte_out[23:16] + byte_out[31:24];\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "6a955f49f4989f852dceaff346ab5065",
        "dataset_index": 10532
      },
      "dff_async_set_reset_e2bcf0a7": {
        "rtl_code": "module dff_async_set_reset (\n    input wire D,\n    input wire SET_B,\n    input wire RESET_B,\n    input wire CLK,\n    output reg Q,\n    output reg Q_B\n    );\n    \n    always @(posedge CLK) begin\n        if (!RESET_B) begin\n            Q <= 1'b0;\n            Q_B <= 1'b1;\n        end else if (!SET_B) begin\n            Q <= 1'b1;\n            Q_B <= 1'b0;\n        end else begin\n            Q <= D;\n            Q_B <= ~D;\n        end\n    end\n    \nendmodule",
        "module_name": "dff_async_set_reset",
        "module_hash": "e2bcf0a7bfb31aae21dbfcb668b6ab26",
        "dataset_index": 14531
      },
      "PmodDA4_Control_228575b2": {
        "rtl_code": "module PmodDA4_Control (\n  input clk,\n  input rst,\n  input [11:0] value, output reg SYNC,    output DATA,        output SCLK         );\n\nlocalparam stIDLE = 3'd0,\n           stINIT_irv = 3'd1,\n           stTRAN_irv = 3'd2,\n           stINIT = 3'd3,\n           stTRAN = 3'd4;\n\nwire [31:0] temp;\nreg [2:0] state;\nreg [4:0] index;\n\nassign temp = ((state == stINIT_irv) || (state == stTRAN_irv)) ? {8'h8, 24'h1} : {12'h3F, value, 8'h0};\nassign DATA = temp[index];\nassign SCLK = clk;\n\nalways @(negedge clk) begin\n  if (rst) begin\n    state <= stIDLE;\n    index <= 5'd31;\n    SYNC <= 1'b0;\n  end else begin\n    case (state)\n      stIDLE: begin\n        state <= stINIT_irv;\n        index <= 5'd31;\n        SYNC <= 1'b1;\n      end\n      stINIT_irv: begin\n        state <= stTRAN_irv;\n        index <= 5'd31;\n        SYNC <= 1'b0;\n      end\n      stTRAN_irv: begin\n        state <= (index == 0) ? stINIT : stTRAN_irv;\n        index <= index - 1'b1;\n        SYNC <= (index == 0) ? 1'b1 : 1'b0;\n      end\n      stINIT: begin\n        state <= stTRAN;\n        index <= 5'd31;\n        SYNC <= 1'b0;\n      end\n      stTRAN: begin\n        state <= (index == 0) ? stINIT : stTRAN;\n        index <= index - 1'b1;\n        SYNC <= (index == 0) ? 1'b1 : 1'b0;\n      end\n      default: begin\n        state <= stIDLE;\n        index <= 5'd31;\n        SYNC <= 1'b1;\n      end \n    endcase\n  end\nend\n\nendmodule",
        "module_name": "PmodDA4_Control",
        "module_hash": "228575b286992d1091eba4f4376e843f",
        "dataset_index": 17371
      },
      "shift_register_378acb50": {
        "rtl_code": "module shift_register(\n    input clk, \n    input shift, \n    input in,\n    output reg out\n);\n  reg [3:0] reg_out;\n\n  always @(posedge clk) begin\n    if (shift) begin\n      reg_out <= {reg_out[2:0], in};\n    end else begin\n      reg_out <= {in, reg_out[3:1]};\n    end\n  end\n\n  always @*\n    out = reg_out[0];\nendmodule",
        "module_name": "shift_register",
        "module_hash": "378acb509d7f4f8d9cd0aed1d2490b62",
        "dataset_index": 6447
      },
      "spi_core_a74ed195": {
        "rtl_code": "\n\nmodule spi_core (\n   o_sdo, o_drvb, o_spi_active, o_rx_valid, vo_byte_num, vo_data_rx,\n   i_rstb, i_cs, i_sck, i_sdi, i_epol, i_cpol, i_cpha, vi_data_tx\n   );\n   parameter BITS_IN_BYTE = 8;\n   parameter NBIT_BIT_CTR = 3;\n   parameter NBIT_BYTE_CTR = 3;\n   \n   input \t\t      i_rstb;\n   input \t\t      i_cs; input \t\t      i_sck; input \t\t      i_sdi; output \t\t      o_sdo; output \t\t      o_drvb; input \t\t      i_epol; input \t\t      i_cpol; input \t\t      i_cpha;\n   output \t\t      o_spi_active; output \t\t      o_rx_valid; output [NBIT_BYTE_CTR-1:0] vo_byte_num; input [BITS_IN_BYTE-1:0]   vi_data_tx; output [BITS_IN_BYTE-1:0]  vo_data_rx; reg \t\t\t      o_rx_valid;\n   reg [NBIT_BYTE_CTR-1:0]    vo_byte_num;\n\n   \n   wire \t\t      chip_select; \n   wire \t\t      sck_core; \n   assign chip_select = i_rstb && (i_epol ^ i_cs);\n   assign o_spi_active = chip_select;\n   assign sck_core = i_cpha ^ i_cpol ^ i_sck;\n   assign o_drvb = !chip_select;\n   \n   reg [BITS_IN_BYTE-1:0]     rv_tx;\n   reg [NBIT_BIT_CTR-1:0]     rv_tx_ptr;\n   always @( negedge sck_core or negedge chip_select ) begin : tx_fsm\n      if ( !chip_select ) begin\n\t rv_tx_ptr <= $unsigned(BITS_IN_BYTE - 1);\n\t vo_byte_num <= 0;\n\t rv_tx <= 0;\n      end else begin\n\t if ( 0 == rv_tx_ptr ) begin\n\t    rv_tx <= vi_data_tx;\n\t    rv_tx_ptr <= $unsigned(BITS_IN_BYTE - 1);\n\t    vo_byte_num <= vo_byte_num + 1;\n\t end else begin\n\t    rv_tx_ptr <= rv_tx_ptr - 1;\n\t end\n      end end assign o_sdo = rv_tx[rv_tx_ptr];\n   \n   reg [BITS_IN_BYTE-2:0]     rv_rx;\n   always @( posedge sck_core or negedge chip_select ) begin : rx_fsm\n      if ( !chip_select ) begin\n\t rv_rx <= 0;\n         o_rx_valid <= 0;\n      end else begin\n\t if ( 0 == rv_tx_ptr ) begin\n\t    o_rx_valid <= 1;   \n\t end else begin\n\t    o_rx_valid <= 0;\n            rv_rx[BITS_IN_BYTE-2:1] <= rv_rx[BITS_IN_BYTE-3:0];\n\t    rv_rx[0] <= i_sdi;\n\t end end end assign vo_data_rx = {rv_rx,i_sdi};\nendmodule\n",
        "module_name": "spi_core",
        "module_hash": "a74ed195b8b4e0e03e237d30d39870a7",
        "dataset_index": 11915
      },
      "sha512_w_mem_07e2a8a8": {
        "rtl_code": "\n\nmodule sha512_w_mem(\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire [1023 : 0] block,\n\n                    input wire            init,\n                    input wire            next,\n                    output wire [63 : 0]  w\n                   );\n\n\n  reg [63 : 0] w_mem [0 : 15];\n  reg [63 : 0] w_mem00_new;\n  reg [63 : 0] w_mem01_new;\n  reg [63 : 0] w_mem02_new;\n  reg [63 : 0] w_mem03_new;\n  reg [63 : 0] w_mem04_new;\n  reg [63 : 0] w_mem05_new;\n  reg [63 : 0] w_mem06_new;\n  reg [63 : 0] w_mem07_new;\n  reg [63 : 0] w_mem08_new;\n  reg [63 : 0] w_mem09_new;\n  reg [63 : 0] w_mem10_new;\n  reg [63 : 0] w_mem11_new;\n  reg [63 : 0] w_mem12_new;\n  reg [63 : 0] w_mem13_new;\n  reg [63 : 0] w_mem14_new;\n  reg [63 : 0] w_mem15_new;\n  reg          w_mem_we;\n\n  reg [6 : 0] w_ctr_reg;\n  reg [6 : 0] w_ctr_new;\n  reg         w_ctr_we;\n\n\n  reg [63 : 0] w_tmp;\n  reg [63 : 0] w_new;\n\n\n  assign w = w_tmp;\n\n\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0; i < 16; i = i + 1)\n            w_mem[i] <= 64'h0;\n\n          w_ctr_reg <= 7'h0;\n        end\n      else\n        begin\n          if (w_mem_we)\n            begin\n              w_mem[00] <= w_mem00_new;\n              w_mem[01] <= w_mem01_new;\n              w_mem[02] <= w_mem02_new;\n              w_mem[03] <= w_mem03_new;\n              w_mem[04] <= w_mem04_new;\n              w_mem[05] <= w_mem05_new;\n              w_mem[06] <= w_mem06_new;\n              w_mem[07] <= w_mem07_new;\n              w_mem[08] <= w_mem08_new;\n              w_mem[09] <= w_mem09_new;\n              w_mem[10] <= w_mem10_new;\n              w_mem[11] <= w_mem11_new;\n              w_mem[12] <= w_mem12_new;\n              w_mem[13] <= w_mem13_new;\n              w_mem[14] <= w_mem14_new;\n              w_mem[15] <= w_mem15_new;\n            end\n\n          if (w_ctr_we)\n              w_ctr_reg <= w_ctr_new;\n        end\n    end always @*\n    begin : select_w\n      if (w_ctr_reg < 16)\n        w_tmp = w_mem[w_ctr_reg[3 : 0]];\n      else\n        w_tmp = w_new;\n    end always @*\n    begin : w_mem_update_logic\n      reg [63 : 0] w_0;\n      reg [63 : 0] w_1;\n      reg [63 : 0] w_9;\n      reg [63 : 0] w_14;\n      reg [63 : 0] d0;\n      reg [63 : 0] d1;\n\n      w_mem00_new = 64'h0;\n      w_mem01_new = 64'h0;\n      w_mem02_new = 64'h0;\n      w_mem03_new = 64'h0;\n      w_mem04_new = 64'h0;\n      w_mem05_new = 64'h0;\n      w_mem06_new = 64'h0;\n      w_mem07_new = 64'h0;\n      w_mem08_new = 64'h0;\n      w_mem09_new = 64'h0;\n      w_mem10_new = 64'h0;\n      w_mem11_new = 64'h0;\n      w_mem12_new = 64'h0;\n      w_mem13_new = 64'h0;\n      w_mem14_new = 64'h0;\n      w_mem15_new = 64'h0;\n      w_mem_we    = 0;\n\n      w_0  = w_mem[0];\n      w_1  = w_mem[1];\n      w_9  = w_mem[9];\n      w_14 = w_mem[14];\n\n      d0 = {w_1[0],     w_1[63 : 1]} ^ {w_1[7 : 0], w_1[63 : 8]} ^ {7'b0000000, w_1[63 : 7]};  d1 = {w_14[18 : 0], w_14[63 : 19]} ^ {w_14[60 : 0], w_14[63 : 61]} ^ {6'b000000,    w_14[63 : 6]};   w_new = w_0 + d0 + w_9 + d1;\n\n      if (init)\n        begin\n          w_mem00_new = block[1023 : 960];\n          w_mem01_new = block[959  : 896];\n          w_mem02_new = block[895  : 832];\n          w_mem03_new = block[831  : 768];\n          w_mem04_new = block[767  : 704];\n          w_mem05_new = block[703  : 640];\n          w_mem06_new = block[639  : 576];\n          w_mem07_new = block[575  : 512];\n          w_mem08_new = block[511  : 448];\n          w_mem09_new = block[447  : 384];\n          w_mem10_new = block[383  : 320];\n          w_mem11_new = block[319  : 256];\n          w_mem12_new = block[255  : 192];\n          w_mem13_new = block[191  : 128];\n          w_mem14_new = block[127  :  64];\n          w_mem15_new = block[63   :   0];\n          w_mem_we    = 1;\n        end\n\n      if (next && (w_ctr_reg > 15))\n        begin\n          w_mem00_new = w_mem[01];\n          w_mem01_new = w_mem[02];\n          w_mem02_new = w_mem[03];\n          w_mem03_new = w_mem[04];\n          w_mem04_new = w_mem[05];\n          w_mem05_new = w_mem[06];\n          w_mem06_new = w_mem[07];\n          w_mem07_new = w_mem[08];\n          w_mem08_new = w_mem[09];\n          w_mem09_new = w_mem[10];\n          w_mem10_new = w_mem[11];\n          w_mem11_new = w_mem[12];\n          w_mem12_new = w_mem[13];\n          w_mem13_new = w_mem[14];\n          w_mem14_new = w_mem[15];\n          w_mem15_new = w_new;\n          w_mem_we    = 1;\n        end\n    end always @*\n    begin : w_ctr\n      w_ctr_new = 7'h0;\n      w_ctr_we  = 1'h0;\n\n      if (init)\n        begin\n          w_ctr_new = 7'h00;\n          w_ctr_we  = 1'h1;\n        end\n\n      if (next)\n        begin\n          w_ctr_new = w_ctr_reg + 7'h01;\n          w_ctr_we  = 1'h1;\n        end\n    end endmodule ",
        "module_name": "sha512_w_mem",
        "module_hash": "07e2a8a802c807180777980eba24accb",
        "dataset_index": 15955
      },
      "comparator_mux_57b07ab3": {
        "rtl_code": "\nmodule comparator_mux (\n    input [1:0] comp_in1, // 2-bit input for the comparator\n    input [1:0] comp_in2, // 2-bit input for the comparator\n    input [7:0] mux_in, // 4 2-bit inputs for the multiplexer\n    input [1:0] select, // 2-bit select input for the multiplexer\n    input control, // Control input to choose between the comparator and the multiplexer\n    output [1:0] out // 2-bit output from the selected module\n);\n\n    // Comparator module\n    wire [1:0] comp_out;\n    // comparator comp(\n    //     .in1(comp_in1),\n    //     .in2(comp_in2),\n    //     .out(comp_out)\n    // );\n\n    // Multiplexer module\n    wire [1:0] mux_out;\n    // mux4to1 mux(\n    //     .in0(mux_in[1:0]),\n    //     .in1(mux_in[3:2]),\n    //     .in2(mux_in[5:4]),\n    //     .in3(mux_in[7:6]),\n    //     .sel(select),\n    //     .out(mux_out)\n    // );\n\n    // Output selection based on control input\n    assign out = control ? mux_out : comp_out;\n\nendmodule\nmodule comparator (\n    input [1:0] in1, // 2-bit input 1\n    input [1:0] in2, // 2-bit input 2\n    output [1:0] out // 2-bit output\n);\n\n    assign out[0] = (in1[0] > in2[0]) ? 1'b1 : 1'b0;\n    assign out[1] = (in1[1] > in2[1]) ? 1'b1 : 1'b0;\n    assign out = (in1 == in2) ? 2'b11 : out;\n\nendmodule\nmodule mux4to1 (\n    input [1:0] in0, // 2-bit input 0\n    input [1:0] in1, // 2-bit input 1\n    input [1:0] in2, // 2-bit input 2\n    input [1:0] in3, // 2-bit input 3\n    input [1:0] sel, // 2-bit select input\n    output [1:0] out // 2-bit output\n);\n\n    assign out = (sel == 2'b00) ? in0 :\n                 (sel == 2'b01) ? in1 :\n                 (sel == 2'b10) ? in2 :\n                                  in3;\n\nendmodule",
        "module_name": "comparator_mux",
        "module_hash": "57b07ab3314d0b9692f43d9e2f034406",
        "dataset_index": 19880
      },
      "asr_a59647e7": {
        "rtl_code": "module asr(value1, value2, shift_hex, value_out, EN);\n\tinput [31:0] value1, value2;\n\tinput [3:0] shift_hex;\n\toutput [31:0] value_out;\n\tinput EN;\n\n\twire or_unary = |value2[31:5];\n\twire value2_shrink = value2[4:0];\n\n\twire [4:0] shift_amt = (value2_shrink== 32'b0) ? \n\t\t( {1'b0, shift_hex} + 5'b1) : (value2_shrink + {1'b0, shift_hex});\n\n\tassign value_out = (or_unary==1'b1) ? 32'b0 : (\n\t\t(shift_amt == 5'b00000) ? value1[31:0] :\n\t\t(shift_amt == 5'b00001) ? {{01{value1[31]}}, value1[31:01]} :\n\t\t(shift_amt == 5'b00010) ? {{02{value1[31]}}, value1[31:02]} :\n\t\t(shift_amt == 5'b00011) ? {{03{value1[31]}}, value1[31:03]} :\n\t\t(shift_amt == 5'b00100) ? {{04{value1[31]}}, value1[31:04]} :\n\t\t(shift_amt == 5'b00101) ? {{05{value1[31]}}, value1[31:05]} :\n\t\t(shift_amt == 5'b00110) ? {{06{value1[31]}}, value1[31:06]} :\n\t\t(shift_amt == 5'b00111) ? {{07{value1[31]}}, value1[31:07]} :\n\t\t(shift_amt == 5'b01000) ? {{08{value1[31]}}, value1[31:08]} :\n\t\t(shift_amt == 5'b01001) ? {{09{value1[31]}}, value1[31:09]} :\n\t\t(shift_amt == 5'b01010) ? {{10{value1[31]}}, value1[31:10]} :\n\t\t(shift_amt == 5'b01011) ? {{11{value1[31]}}, value1[31:11]} :\n\t\t(shift_amt == 5'b01100) ? {{12{value1[31]}}, value1[31:12]} :\n\t\t(shift_amt == 5'b01101) ? {{13{value1[31]}}, value1[31:13]} :\n\t\t(shift_amt == 5'b01110) ? {{14{value1[31]}}, value1[31:14]} :\n\t\t(shift_amt == 5'b01111) ? {{15{value1[31]}}, value1[31:15]} :\n\t\t(shift_amt == 5'b10000) ? {{16{value1[31]}}, value1[31:16]} :\n\t\t(shift_amt == 5'b10001) ? {{17{value1[31]}}, value1[31:17]} :\n\t\t(shift_amt == 5'b10010) ? {{18{value1[31]}}, value1[31:18]} :\n\t\t(shift_amt == 5'b10011) ? {{19{value1[31]}}, value1[31:19]} :\n\t\t(shift_amt == 5'b10100) ? {{20{value1[31]}}, value1[31:20]} :\n\t\t(shift_amt == 5'b10101) ? {{21{value1[31]}}, value1[31:21]} :\n\t\t(shift_amt == 5'b10110) ? {{22{value1[31]}}, value1[31:22]} :\n\t\t(shift_amt == 5'b10111) ? {{23{value1[31]}}, value1[31:23]} :\n\t\t(shift_amt == 5'b11000) ? {{24{value1[31]}}, value1[31:24]} :\n\t\t(shift_amt == 5'b11001) ? {{25{value1[31]}}, value1[31:25]} :\n\t\t(shift_amt == 5'b11010) ? {{26{value1[31]}}, value1[31:26]} :\n\t\t(shift_amt == 5'b11011) ? {{27{value1[31]}}, value1[31:27]} :\n\t\t(shift_amt == 5'b11100) ? {{28{value1[31]}}, value1[31:28]} :\n\t\t(shift_amt == 5'b11101) ? {{29{value1[31]}}, value1[31:29]} :\n\t\t(shift_amt == 5'b11110) ? {{30{value1[31]}}, value1[31:30]} :\n\t\t(shift_amt == 5'b11111) ? {{31{value1[31]}}, value1[31]} : 32'b0);\nendmodule",
        "module_name": "asr",
        "module_hash": "a59647e7c7e14312941f9aa12313a3cb",
        "dataset_index": 15219
      },
      "dff_ar_1d05d5aa": {
        "rtl_code": "module dff_ar (\n  input clk, rst, d,\n  output reg q\n);\n\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      q <= 0;\n    end else begin\n      q <= d;\n    end\n  end\n\nendmodule",
        "module_name": "dff_ar",
        "module_hash": "1d05d5aaa6abcb23e5012bc776c7ce39",
        "dataset_index": 12297
      },
      "SRFF_sp_68454588": {
        "rtl_code": "module SRFF_sp(\n  input   clock,\n  input   reset,\n  input   io_input_set,\n  input   io_input_reset,\n  input   io_input_asyn_reset,\n  output  io_output_data\n);\n  reg  _T_14;\n  reg [31:0] _GEN_0;\n  wire  _T_18;\n  wire  _T_19;\n  wire  _T_20;\n  wire  _T_22;\n  assign io_output_data = _T_22;\n  assign _T_18 = io_input_reset ? 1'h0 : _T_14;\n  assign _T_19 = io_input_set ? 1'h1 : _T_18;\n  assign _T_20 = io_input_asyn_reset ? 1'h0 : _T_19;\n  assign _T_22 = io_input_asyn_reset ? 1'h0 : _T_14;\n`ifdef RANDOMIZE\n  integer initvar;\n  initial begin\n    `ifndef verilator\n      #0.002 begin end\n    `endif\n  `ifdef RANDOMIZE_REG_INIT\n  _GEN_0 = {1{$random}};\n  _T_14 = _GEN_0[0:0];\n  `endif\n  end\n`endif\n  always @(posedge clock) begin\n    if (reset) begin\n      _T_14 <= 1'h0;\n    end else begin\n      if (io_input_asyn_reset) begin\n        _T_14 <= 1'h0;\n      end else begin\n        if (io_input_set) begin\n          _T_14 <= 1'h1;\n        end else begin\n          if (io_input_reset) begin\n            _T_14 <= 1'h0;\n          end\n        end\n      end\n    end\n  end\nendmodule",
        "module_name": "SRFF_sp",
        "module_hash": "684545887bf5f0347fae8e7f89835260",
        "dataset_index": 14628
      },
      "mux4_1_6e1f4fe3": {
        "rtl_code": "module mux4_1 (\n    X ,\n    A0,\n    A1,\n    A2,\n    A3,\n    S0,\n    S1\n);\n\n    output X ;\n    input  A0;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  S0;\n    input  S1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire [3:0] data;\n    \n    assign data[0] = A0;\n    assign data[1] = A1;\n    assign data[2] = A2;\n    assign data[3] = A3;\n    \n    assign X = (S1 & S0 == 2'b00) ? data[0] :\n               (S1 & S0 == 2'b01) ? data[1] :\n               (S1 & S0 == 2'b10) ? data[2] :\n               (S1 & S0 == 2'b11) ? data[3] : 1'bx;\n\nendmodule",
        "module_name": "mux4_1",
        "module_hash": "6e1f4fe30c0a071ca2a53d82af927d32",
        "dataset_index": 15610
      },
      "regfile_f664440c": {
        "rtl_code": "\nmodule regfile(clk, raddr1, dout1, raddr2, dout2, wr, waddr, din, R1, R2, nrst);\n    input           clk;\n    input           wr;\n    input   [4:0]   raddr1, raddr2, waddr;\n    input   [31:0]  din;\n    output  [31:0]  dout1, dout2;\n    output  [7:0]   R2;\n    output  [2:0]   R1;\n    input           nrst;\n\n    reg [31:0] mem[0:31];\n    reg [31:0] dout1_reg, dout2_reg;\n    reg [2:0]  R1_reg;\n    reg [7:0]  R2_reg;\n\n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            mem[5'b00001] <= 32'b0;\n        end else begin\n            if (wr) begin\n                mem[waddr] <= din;\n            end\n            dout1_reg <= mem[raddr1];\n            dout2_reg <= mem[raddr2];\n            R1_reg <= mem[5'b00001][31:29];\n            R2_reg <= mem[4'b0010][7:0];\n        end\n    end\n\n    assign dout1 = (raddr1 == 5'b0) ? 32'b0 : dout1_reg;\n    assign dout2 = (raddr2 == 5'b0) ? 32'b0 : dout2_reg;\n    assign R1 = R1_reg;\n    assign R2 = R2_reg;\n\nendmodule",
        "module_name": "regfile",
        "module_hash": "f664440cf20960add6bfe1ec378b4b8c",
        "dataset_index": 19763
      },
      "glitch_free_mux #_ec74aca5": {
        "rtl_code": "\nmodule glitch_free_mux #(\n  parameter n = 4 // number of clock signals\n) (\n  input [n-1:0] clk,\n  input sel,\n  output reg sys_clk \n);\n\nreg [n-1:0] prev_clk; // previous clock signal\nreg [n-1:0] cur_clk; // current clock signal\n\nalways @ (posedge clk[0]) begin // Use a single edge-sensitive clock for the first always block\n  if (sel) begin\n    prev_clk <= cur_clk;\n    cur_clk <= clk;\n  end\nend\n\nalways @* begin // Use an always block to assign `sys_clk`\n  sys_clk = (cur_clk == prev_clk) ? cur_clk : prev_clk;\nend\n\nendmodule",
        "module_name": "glitch_free_mux #",
        "module_hash": "ec74aca5b949eba0ebdf6a1631d05e07",
        "dataset_index": 17422
      },
      "memory_module_94befad5": {
        "rtl_code": "\nmodule memory_module(\n    input cpu_clock,\n    input memreg_rd,\n    input [10:0] a,\n    input din,\n    input volports_enabled,\n    input port_wr,\n    output reg snd_wrtoggle,\n    output reg snd_datnvol,\n    output reg [2:0] snd_addr,\n    output reg [7:0] snd_data,\n    input [2:0] volnum\n);\n\nreg mode_8chans;\n\ninitial begin\n    // Initialize the outputs\n    snd_wrtoggle <= 1'b0;\n    snd_datnvol <= 1'b1;\n    mode_8chans <= 0; // Initialize mode to 4 channels\nend\n\nalways @ (posedge cpu_clock) begin\n    if (memreg_rd) begin\n        // Update the outputs on a memory read\n        snd_wrtoggle <= ~snd_wrtoggle;\n        snd_datnvol <= 1'b1;\n        if (!mode_8chans) begin\n            snd_addr <= {1'b0, a[9:8]};\n        end else begin\n            snd_addr <= a[10:8];\n        end\n        snd_data <= din;\n    end else if (volports_enabled && port_wr) begin\n        // Update the outputs on a volume port write\n        snd_wrtoggle <= ~snd_wrtoggle;\n        snd_datnvol <= 1'b0;\n        snd_addr <= volnum;\n        snd_data <= din;\n    end\nend\n\nendmodule",
        "module_name": "memory_module",
        "module_hash": "94befad52f8fcae004cb9a0e44ac7cb3",
        "dataset_index": 1381
      },
      "queue #_5ccc165c": {
        "rtl_code": "\nmodule queue #\n    (\n    parameter integer WIDTH = 108,\n    parameter integer LENGTH = 4\n    )\n    (\n    input wire GCLK,\n    input wire RES,\n    input wire get,\n    input wire put,\n    output reg full = 1'b0,\n    output reg empty = 1'b1,\n    input wire [WIDTH-1:0] DIN,\n    output reg [WIDTH-1:0] DOUT\n    );\n    \n    reg [WIDTH-1:0] q[0:LENGTH-1];\n    reg [63:0] head = 64'd0; reg get_release = 1'b1;\n    reg put_release = 1'b1;\n    \n    wire to_get;\n    wire to_put;\n    assign to_get = get & get_release;\n    assign to_put = put & put_release;\n\n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            get_release <= 1'b1;\n        end\n        else if (get == 1'b0) begin\n            get_release <= 1'b1;\n        end\n        else if (to_get == 1'b1) begin\n            get_release <= 1'b0;\n        end\n        \n        if (RES == 1'b1) begin\n            put_release <= 1'b1;\n        end\n        else if (put == 1'b0) begin\n            put_release <= 1'b1;\n        end\n        else if (to_put == 1'b1) begin\n            put_release <= 1'b0;\n        end\n    end\n\n    integer i = 0;\n    always @(posedge GCLK) begin\n        if (to_put & !to_get) begin\n            for (i = LENGTH - 1; i > 0; i = i - 1) begin\n                q[i] <= q[i - 1];\n            end\n            q[0] <= DIN;\n        end\n        \n        if (to_get &  !to_put & !empty) begin\n            DOUT <= q[head - 64'd1];\n        end\n        else if (to_get & to_put) begin\n            DOUT <= DIN;\n        end\n    end\n    \n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            head <= 64'd0;\n            full <= 1'b0;\n            empty <= 1'b1;\n        end\n        else if (!full & to_put & !to_get) begin\n            head <= head + 64'd1;\n            empty <= 1'b0; if (head == LENGTH - 1) begin\n                full <= 1'b1;\n            end\n        end\n        else if (!empty & to_get & !to_put) begin\n            head <= head - 64'd1;\n            full <= 1'b0; if (head == 64'd1) begin\n                empty <= 1'b1;\n            end\n        end\n        else begin\n            head <= head;\n            full <= full;\n            empty <= empty;\n        end\n    end\n    \n    \nendmodule\n",
        "module_name": "queue #",
        "module_hash": "5ccc165c2458eb5b3f0f007b17c80901",
        "dataset_index": 19882
      },
      "sky130_fd_sc_hd__lpflow_inputiso1p_284111c1": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__lpflow_inputiso1p (\n    X    ,\n    A    ,\n    SLEEP\n);\n\n    output X    ;\n    input  A    ;\n    input  SLEEP;\n\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__lpflow_inputiso1p",
        "module_hash": "284111c11624526beb912c091622fb49",
        "dataset_index": 6610
      },
      "DTR_3dbf2758": {
        "rtl_code": "\nmodule DTR(\n    input STARTPULSE,\n    output reg DTROUT7, DTROUT6, DTROUT5, DTROUT4, DTROUT3, DTROUT2, DTROUT1, DTROUT0\n);\n\nreg [2:0] counter;\n\nalways @(posedge STARTPULSE) begin\n    counter <= counter + 1;\n    if (counter == 3) begin\n        {DTROUT7, DTROUT6, DTROUT5, DTROUT4, DTROUT3, DTROUT2, DTROUT1, DTROUT0} <= {8{1'b0}};\n        DTROUT7 <= 1;\n    end else if (counter == 2) begin\n        DTROUT6 <= 1;\n    end else if (counter == 1) begin\n        DTROUT5 <= 1;\n    end else if (counter == 0) begin\n        DTROUT4 <= 1;\n        DTROUT3 <= 1;\n        DTROUT2 <= 1;\n        DTROUT1 <= 1;\n        DTROUT0 <= 1;\n    end\nend\n\nendmodule\n",
        "module_name": "DTR",
        "module_hash": "3dbf27582073d2064f539b765385c2b4",
        "dataset_index": 13718
      },
      "sky130_fd_sc_hd__a221o_bfbfe197": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__a221o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2                );\n    and and1 (and1_out , A1, A2                );\n    or  or0  (or0_out_X, and1_out, and0_out, C1);\n    buf buf0 (X        , or0_out_X             );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a221o",
        "module_hash": "bfbfe1977806da41d97eeafa4a3a881d",
        "dataset_index": 14631
      },
      "top__1e58b2e6": {
        "rtl_code": "module top_module (\n    input [3:0] D,\n    input SEL,\n    input clk,\n    output reg [3:0] OUT\n);\n\n    wire [3:0] Y;\n    wire [3:0] C;\n    wire [3:0] ADD_OUT;\n\n    decoder_2to4_with_enable decoder (\n        .D(SEL),\n        .E(D[3]),\n        .Y(Y)\n    );\n\n    twos_comp_converter twos_comp (\n        .D(D),\n        .C(C)\n    );\n\n    adder_4bit adder (\n        .A(Y),\n        .B(C),\n        .CIN(1'b0),\n        .S(ADD_OUT)\n    );\n\n    always @(posedge clk) begin\n        if (SEL == 0) begin\n            OUT <= Y[D[1:0]];\n        end else begin\n            OUT <= ADD_OUT;\n        end\n    end\n\nendmodule\n\nmodule decoder_2to4_with_enable (\n    input D,\n    input E,\n    output reg [3:0] Y\n);\n\n    always @* begin\n        case ({E, D})\n            2'b00: Y = 4'b0001;\n            2'b01: Y = 4'b0010;\n            2'b10: Y = 4'b0100;\n            2'b11: Y = 4'b1000;\n            default: Y = 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule twos_comp_converter (\n    input [3:0] D,\n    output reg [3:0] C\n);\n\n    always @* begin\n        C = ~D + 4'b1;\n    end\n\nendmodule\n\nmodule adder_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output reg [3:0] S\n);\n\n    always @* begin\n        S = A + B + CIN;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "1e58b2e6dc3b87cc11f96f93d6e11f00",
        "dataset_index": 13248
      },
      "constant_voltage_driver_63040ac0": {
        "rtl_code": "\nmodule constant_voltage_driver (\n  input clk,\n  input rst,\n  input ctrl,\n  output reg vout\n);\n\nparameter voltage_level = 1800; // desired voltage level of the output signal in mV\nparameter rise_time = 10; // time required for the output signal to rise to the desired voltage level in ns\nparameter fall_time = 20; // time required for the output signal to fall from the desired voltage level in ns\n\nreg [31:0] rise_counter;\nreg [31:0] fall_counter;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    vout <= 0;\n    rise_counter <= 0;\n    fall_counter <= 0;\n  end\n  else begin\n    if (ctrl) begin\n      if (rise_counter < rise_time) begin\n        rise_counter <= rise_counter + 1;\n        vout <= (rise_counter * voltage_level) / rise_time;\n      end\n      else begin\n        vout <= voltage_level;\n      end\n      fall_counter <= 0;\n    end\n    else begin\n      if (fall_counter < fall_time) begin\n        fall_counter <= fall_counter + 1;\n        vout <= voltage_level - ((fall_counter * voltage_level) / fall_time);\n      end\n      else begin\n        vout <= 0;\n      end\n      rise_counter <= 0;\n    end\n  end\nend\n\nendmodule",
        "module_name": "constant_voltage_driver",
        "module_hash": "63040ac0867a70bd62861851fafb917e",
        "dataset_index": 2660
      },
      "read_304043fc": {
        "rtl_code": "\n\nmodule read(reset, readbitclk, readbitout, readbitdone, \n           read_sample_ctl, read_sample_clk, read_sample_datain, \n           handle);\ninput  reset, readbitclk;\noutput readbitout, readbitdone;\ninput  read_sample_datain;\noutput read_sample_ctl, read_sample_clk;\ninput [15:0] handle;\n  \nwire [32:0] packet;\nassign packet[32]    = 1'b0;\nassign packet[31:16] = 16'h0000;\nassign packet[15:0]  = handle[15:0];\n\nreg [5:0] bitoutcounter;\nreg read_sample_ctl;\n\nwire read_sample_clk, readbitout, readbitdone;\n\nassign read_sample_clk = readbitclk & (bitoutcounter > 15);\nassign readbitout = (bitoutcounter!=32 && bitoutcounter>15) ? read_sample_datain : packet[bitoutcounter];\nassign readbitdone = (bitoutcounter == 0);\nreg    initialized;\n\nalways @ (posedge readbitclk or posedge reset) begin\n  if (reset) begin\n    bitoutcounter   <= 0;\n    initialized     <= 0;\n    read_sample_ctl <= 0;\n  end else if (!initialized) begin\n    initialized     <= 1;\n    read_sample_ctl <= 1;\n    bitoutcounter   <= 32;\n  end else if (!readbitdone) begin\n    bitoutcounter <= bitoutcounter - 4'd1;\n    if (bitoutcounter >= 15) read_sample_ctl <= 1;\n    else                     read_sample_ctl <= 0;\n  end else begin\n    read_sample_ctl<= 0;\n  end end endmodule\n\n",
        "module_name": "read",
        "module_hash": "304043fc388e4ad6574df2331d1aa0e7",
        "dataset_index": 11907
      },
      "address_generator_3036b658": {
        "rtl_code": "module address_generator (\n    clk,\n    rst_n,\n    strand_offset,\n    strand_idx,\n    strand_length,\n    addr\n);\n\n    parameter MEM_ADDR_WIDTH = 24;\n    parameter STRAND_PARAM_WIDTH = 16;\n\n    input clk;\n    input rst_n;\n\n    // The active strand will drive these three buses\n    input [STRAND_PARAM_WIDTH-1:0] strand_offset;\n    input [STRAND_PARAM_WIDTH-1:0] strand_idx;\n    input [STRAND_PARAM_WIDTH-1:0] strand_length;\n\n    output reg [MEM_ADDR_WIDTH-1:0] addr;\n\n    // Address generation process\n    always @(posedge clk) begin\n        if (rst_n == 1'b0) begin\n            addr <= { MEM_ADDR_WIDTH {1'b0} };\n        end\n        else begin\n            // address of memory is given by \n            // strand_offset[current] + (strand_idx[current] % strand_length[current])\n            if (strand_idx >= strand_length) begin\n                addr <= strand_offset + (strand_idx - strand_length);\n            end\n            else begin\n                addr <= strand_offset + strand_idx;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "address_generator",
        "module_hash": "3036b6581867ab0171505b7d33411a65",
        "dataset_index": 3935
      },
      "clk_generator_f4a8ce8b": {
        "rtl_code": "\nmodule clk_generator(\n    input clk,\n    input en,\n    input rst,\n    input [31:0] limit,\n    input [31:0] count,\n    output reg clk_0,\n    output reg done\n);\n\n    reg [31:0] ndCount;\n    reg [31:0] initCount;\n    \n    initial begin\n        clk_0 <= 1'b0;\n        ndCount <= 32'h00000000;\n        initCount <= count;\n    end\n    \n    always @(posedge clk or negedge rst) begin \n        if(~rst) begin\n            clk_0 <= 1'b0;\n            ndCount <= 32'h00000000;\n            done <= 1'b0;\n        end\n        else if(en) begin \n            if(ndCount < limit) begin\n                ndCount <= ndCount + 1;\n                clk_0 <= (ndCount == limit) ? ~clk_0 : clk_0;\n                done <= (ndCount == limit) ? 1'b1 : 1'b0;\n            end\n            else begin\n                ndCount <= initCount;\n                clk_0 <= 1'b0;\n                done <= 1'b1;\n            end\n        end\n        else begin\n            ndCount <= initCount;\n            clk_0 <= 1'b0;\n            done <= 1'b0;\n        end\n    end\n\nendmodule",
        "module_name": "clk_generator",
        "module_hash": "f4a8ce8beb8d506db91332b496f34550",
        "dataset_index": 7483
      },
      "barrel_shifter_4bit_6b50be8e": {
        "rtl_code": "module barrel_shifter_4bit (\n    input [3:0] in,\n    input [1:0] shift,\n    input clk,\n    output reg [3:0] out\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @(*) begin\n    case(shift)\n        2'b00: stage1_out = in << 1; // logical left shift\n        2'b01: stage1_out = in >> 1; // logical right shift\n        2'b10: stage1_out = {in[1:0], in[3:2]}; // arithmetic left shift\n        2'b11: stage1_out = {in[3:2], in[0]}; // arithmetic right shift\n    endcase\n    stage2_out <= stage1_out;\nend\n\nalways @(posedge clk) begin\n    out <= stage2_out;\nend\n\nendmodule",
        "module_name": "barrel_shifter_4bit",
        "module_hash": "6b50be8e475e4b97933fc058b1204043",
        "dataset_index": 6983
      },
      "calculator_abd66b7c": {
        "rtl_code": "module calculator(\n    input [7:0] in1,\n    input [7:0] in2,\n    input [1:0] opcode,\n    output reg [7:0] result,\n    output reg overflow\n);\n\nreg [8:0] temp;\n\nalways @(*)\nbegin\n    overflow <= 0;\n    case (opcode)\n        2'b00: // addition\n        begin\n            temp = in1 + in2;\n        end\n        2'b01: // subtraction\n        begin\n            temp = in1 - in2;\n        end\n        2'b10: // multiplication\n        begin\n            temp = in1 * in2;\n        end\n        2'b11: // division\n        begin\n            if (in2 == 0)\n            begin\n                temp = 0;\n                overflow <= 1;\n            end\n            else\n            begin\n                temp = in1 / in2;\n            end\n        end\n        default: // invalid opcode\n        begin\n            temp = 0;\n            overflow <= 1;\n        end\n    endcase\n    if (temp > 255 || temp < -256)\n        overflow <= 1;\n    result <= temp[7:0];\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "abd66b7c917012c12a1f1c9d2b2091a2",
        "dataset_index": 1369
      },
      "jt51_noise_lfsr #_bf5bec03": {
        "rtl_code": "\n\n\n\nmodule jt51_noise_lfsr #(parameter init=14220 )(\n\tinput\trst,\n\tinput\tclk,\n\tinput\tbase,\n\toutput\tout\n);\n\nreg [16:0] bb;\nassign out = bb[16];\n\nalways @(posedge clk) begin : base_counter\n\tif( rst ) begin\n\t\tbb\t\t\t<= init[16:0];\n\tend\n\telse begin\n\t\tif(  base ) begin\t\n\t\t\tbb[16:1] \t<= bb[15:0];\n\t\t\tbb[0]\t\t<= ~(bb[16]^bb[13]);\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "jt51_noise_lfsr #",
        "module_hash": "bf5bec03d491753c7edbbca5d0cc2791",
        "dataset_index": 24051
      },
      "CryptoBlock_5b7d4331": {
        "rtl_code": "module CryptoBlock (\n  input [m-1:0] plaintext,\n  input [k-1:0] key,\n  input [m-1:0] ciphertext,\n  input [m-1:0] message,\n  output [m-1:0] ciphertext_out,\n  output [m-1:0] plaintext_out,\n  output [n-1:0] hash_out\n);\n\nparameter k = 128; // length of secret key in bits\nparameter m = 256; // length of message in bits\nparameter n = 256; // length of hash in bits\n\nassign ciphertext_out = plaintext ^ key;\n\nassign plaintext_out = ciphertext ^ key;\n\nassign hash_out = message;\n\nendmodule",
        "module_name": "CryptoBlock",
        "module_hash": "5b7d4331b8a943f47e114b0864b08634",
        "dataset_index": 19157
      },
      "sync_counter_cf03a475": {
        "rtl_code": "module sync_counter(\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      out <= 4'b0;\n    end else if (enable) begin\n      out <= out + 1;\n    end\n  end\n\nendmodule",
        "module_name": "sync_counter",
        "module_hash": "cf03a4757154bfb6b2f2c648cf11881f",
        "dataset_index": 16240
      },
      "pipelined_adder_3c9fd382": {
        "rtl_code": "\nmodule pipelined_adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] p, g, c;\n\n    assign p[0] = a[0] ^ b[0];\n    assign g[0] = a[0] & b[0];\n    assign c[0] = g[0];\n\n    genvar i;\n    generate\n        for (i = 1; i < 8; i = i + 1) begin\n            assign p[i] = a[i] ^ b[i] ^ c[i-1];\n            assign g[i] = (a[i] & b[i]) | (a[i] & c[i-1]) | (b[i] & c[i-1]);\n            assign c[i] = (a[i] & b[i]) | (g[i] & c[i-1]);\n        end\n    endgenerate\n\n    assign s = p ^ c;\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] p, g, c;\n    wire [7:0] p1, g1, c1;\n\n    pipelined_adder adder1(.a(a), .b(b), .s(p1), .overflow(overflow));\n    pipelined_adder adder2(.a(p1), .b(8'b0), .s(s), .overflow()); // 'overflow' is unconnected, this should not cause an error\n\nendmodule",
        "module_name": "pipelined_adder",
        "module_hash": "3c9fd3824b0234eff1c82e203f728cbf",
        "dataset_index": 4903
      },
      "ROM_A_e89c2681": {
        "rtl_code": "module ROM_A(\n    input [31:0] addr,\n    output [31:0] inst\n);\n\n    reg [31:0]instructions[128:0];\n    \n    initial begin\n        // Initialize ROM with instructions\n        instructions[0] = 32'h00000026;\n        instructions[1] = 32'h00210826;\n        instructions[2] = 32'h00421026;\n        instructions[3] = 32'h00631826;\n        instructions[4] = 32'h00842026;\n        instructions[5] = 32'h00a52826;\n        instructions[6] = 32'h00c63026;\n        instructions[7] = 32'h00e73826;\n        instructions[8] = 32'h01084026;\n        instructions[9] = 32'h01294826;\n        instructions[10] = 32'h014a5026;\n        instructions[11] = 32'h016b5826;\n        instructions[12] = 32'h018c6026;\n        instructions[13] = 32'h01ad6826;\n        instructions[14] = 32'h01ce7026;\n        instructions[15] = 32'h01ef7826;\n        instructions[16] = 32'h02108026;\n        instructions[17] = 32'h02318826;\n        instructions[18] = 32'h02529026;\n        instructions[19] = 32'h02739826;\n        instructions[20] = 32'h0294a026;\n        instructions[21] = 32'h02b5a826;\n        instructions[22] = 32'h02d6b026;\n        instructions[23] = 32'h02f7b826;\n        instructions[24] = 32'h0318c026;\n        instructions[25] = 32'h0339c826;\n        instructions[26] = 32'h035ad026;\n        instructions[27] = 32'h037bd826;\n        instructions[28] = 32'h039ce026;\n        instructions[29] = 32'h03bde826;\n        instructions[30] = 32'h03def026;\n        instructions[31] = 32'h03fff826;\n        instructions[32] = 32'h2108000a;\n        instructions[33] = 32'h21290001;\n        instructions[34] = 32'h214a0002;\n        instructions[35] = 32'h216b0003;\n        instructions[36] = 32'h218c0004;\n        instructions[37] = 32'h21ad000a;\n        instructions[38] = 32'h21ce000a;\n        instructions[39] = 32'h21ef000a;\n        instructions[40] = 32'h00892020;\n        instructions[41] = 32'h00aa2820;\n        instructions[42] = 32'h00cb3020;\n        instructions[43] = 32'h00ec3820;\n        instructions[44] = 32'h1488fffb;\n        instructions[45] = 32'h22100001;\n        instructions[46] = 32'h3c088000;\n        instructions[47] = 32'h00008827;\n        instructions[48] = 32'h00084042;\n        instructions[49] = 32'h02119024;\n        instructions[50] = 32'h01119825;\n        instructions[51] = 32'h0111a026;\n        instructions[52] = 32'h1408fffb;\n        instructions[53] = 32'h3c1500ff;\n        instructions[54] = 32'h22b500ff;\n        instructions[55] = 32'hac150320;\n        instructions[56] = 32'h8c160320;\n        instructions[57] = 32'h12b60000;\n        instructions[58] = 32'h00892022;\n        instructions[59] = 32'h00aa2822;\n        instructions[60] = 32'h00cb3022;\n        instructions[61] = 32'h00ec3822;\n        instructions[62] = 32'h00c0402a;\n        instructions[63] = 32'h1008fffa;\n        instructions[64] = 32'h0c000042;\n        instructions[65] = 32'h08000000;\n        instructions[66] = 32'h03e00008;\n    end\n    \n    // Output the instruction at the specified address\n    assign inst = instructions[addr];   \n\nendmodule",
        "module_name": "ROM_A",
        "module_hash": "e89c2681e2069e455d2dade87eacf1dd",
        "dataset_index": 6022
      },
      "johnson_counter #_ea2b2851": {
        "rtl_code": "module johnson_counter #(\n  parameter n = 16 // number of output signals\n)(\n  input clk,\n  output [n-1:0] out\n);\n\n\nreg [n-1:0] state; // register to hold current state\nwire [n-1:0] next_state; // wire to hold next state\n\n// define the flip-flops and their connections\nalways @(posedge clk) begin\n  state <= next_state;\nend\n\n// define the logic that generates the sequence of binary numbers\nassign next_state = {state[n-2:0], ~state[n-1] ^ state[n-2]};\n\n// use the output signals to indicate the current state of the Johnson counter\nassign out = state;\n\nendmodule",
        "module_name": "johnson_counter #",
        "module_hash": "ea2b2851b8ee99d61fb8490900d38b8a",
        "dataset_index": 21316
      },
      "priority_encoder #_7ecb53cf": {
        "rtl_code": "\n\n\nmodule priority_encoder #\n(\n    parameter WIDTH = 4,\n    parameter LSB_HIGH_PRIORITY = 0\n)\n(\n    input  wire [WIDTH-1:0]         input_unencoded,\n    output wire                     output_valid,\n    output wire [$clog2(WIDTH)-1:0] output_encoded,\n    output wire [WIDTH-1:0]         output_unencoded\n);\n\nparameter LEVELS = WIDTH > 2 ? $clog2(WIDTH) : 1;\nparameter W = 2**LEVELS;\n\nwire [W-1:0] input_padded = {{W-WIDTH{1'b0}}, input_unencoded};\n\nwire [W/2-1:0] stage_valid[LEVELS-1:0];\nwire [W/2-1:0] stage_enc[LEVELS-1:0];\n\ngenerate\n    genvar l, n;\n\n    for (n = 0; n < W/2; n = n + 1) begin : loop_in\n        assign stage_valid[0][n] = |input_padded[n*2+1:n*2];\n        if (LSB_HIGH_PRIORITY) begin\n            assign stage_enc[0][n] = !input_padded[n*2+0];\n        end else begin\n            assign stage_enc[0][n] = input_padded[n*2+1];\n        end\n    end\n\n    for (l = 1; l < LEVELS; l = l + 1) begin : loop_levels\n        for (n = 0; n < W/(2*2**l); n = n + 1) begin : loop_compress\n            assign stage_valid[l][n] = |stage_valid[l-1][n*2+1:n*2];\n            if (LSB_HIGH_PRIORITY) begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+0] ? {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]} : {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]};\n            end else begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+1] ? {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]} : {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]};\n            end\n        end\n    end\nendgenerate\n\nassign output_valid = stage_valid[LEVELS-1];\nassign output_encoded = stage_enc[LEVELS-1];\nassign output_unencoded = 1 << output_encoded;\n\nendmodule\n",
        "module_name": "priority_encoder #",
        "module_hash": "7ecb53cf5b3fe3aaa9df3c5484e63f12",
        "dataset_index": 24978
      },
      "my__dc16982d": {
        "rtl_code": "module my_module (\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    output reg valid\n);\n\nreg [15:0] prev_data_in;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out <= 16'h0000;\n        valid <= 1'b0;\n        prev_data_in <= data_in;\n    end\n    else if (data_in !== prev_data_in) begin\n        data_out <= ~data_in;\n        valid <= 1'b1;\n        prev_data_in <= data_in;\n    end\n    else begin\n        data_out <= data_out;\n        valid <= valid;\n    end\nend\n\nendmodule",
        "module_name": "my_",
        "module_hash": "dc16982d9d564bac8012adada6b52163",
        "dataset_index": 17562
      },
      "NPM_Toggle_PHY_B_Reset_2d25baee": {
        "rtl_code": "\n\nmodule NPM_Toggle_PHY_B_Reset\n(\n    iSystemClock            ,\n    iReset                  ,\n    oReady                  ,\n    oLastStep               ,\n    iStart                  ,\n    oPI_BUFF_Reset          ,\n    oPI_BUFF_RE             ,\n    oPI_BUFF_WE             ,\n    oPO_DQStrobe            ,\n    oDQSOutEnable            \n);\n    input                           iSystemClock            ;\n    input                           iReset                  ;\n    output                          oReady                  ;\n    output                          oLastStep               ;\n    input                           iStart                  ;\n    output                          oPI_BUFF_Reset          ;\n    output                          oPI_BUFF_RE             ;\n    output                          oPI_BUFF_WE             ;\n    output  [7:0]                   oPO_DQStrobe            ;\n    output                          oDQSOutEnable           ;\n    \n    parameter PBR_FSM_BIT = 4;\n    parameter PBR_RESET = 4'b0001;\n    parameter PBR_READY = 4'b0010;\n    parameter PBR_RFRST = 4'b0100; parameter PBR_RLOOP = 4'b1000; reg     [PBR_FSM_BIT-1:0]       rPBR_cur_state          ;\n    reg     [PBR_FSM_BIT-1:0]       rPBR_nxt_state          ;\n    \n    \n    \n    reg                             rReady                  ;\n    \n    reg     [3:0]                   rTimer                  ;\n    \n    wire                            wJOBDone                ;\n    \n    reg                             rPI_BUFF_Reset          ;\n    reg                             rPI_BUFF_RE             ;\n    reg                             rPI_BUFF_WE             ;\n    reg     [7:0]                   rPO_DQStrobe            ;\n    reg                             rDQSOutEnable           ;\n    \n    \n    \n    assign wJOBDone = (4'b1010 == rTimer[3:0]);\n    always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rPBR_cur_state <= PBR_RESET;\n        end else begin\n            rPBR_cur_state <= rPBR_nxt_state;\n        end\n    end\n    \n    always @ ( * ) begin\n        case (rPBR_cur_state)\n            PBR_RESET: begin\n                rPBR_nxt_state <= PBR_READY;\n            end\n            PBR_READY: begin\n                rPBR_nxt_state <= (iStart)? PBR_RFRST:PBR_READY;\n            end\n            PBR_RFRST: begin\n                rPBR_nxt_state <= PBR_RLOOP;\n            end\n            PBR_RLOOP: begin\n                rPBR_nxt_state <= (wJOBDone)? ((iStart)? PBR_RFRST:PBR_READY):PBR_RLOOP;\n            end\n            default:\n                rPBR_nxt_state <= PBR_READY;\n        endcase\n    end\n    \n    always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rReady              <= 0;\n            \n            rTimer[3:0]         <= 0;\n            \n            rPI_BUFF_Reset      <= 0;\n            rPI_BUFF_RE         <= 0;\n            rPI_BUFF_WE         <= 0;\n            rPO_DQStrobe[7:0]   <= 0;\n            rDQSOutEnable       <= 0;\n        end else begin\n            case (rPBR_nxt_state)\n                PBR_RESET: begin\n                    rReady              <= 0;\n                    \n                    rTimer[3:0]         <= 0;\n                    \n                    rPI_BUFF_Reset      <= 0;\n                    rPI_BUFF_RE         <= 0;\n                    rPI_BUFF_WE         <= 0;\n                    rPO_DQStrobe[7:0]   <= 0;\n                    rDQSOutEnable       <= 0;\n                end\n                PBR_READY: begin\n                    rReady              <= 1;\n                    \n                    rTimer[3:0]         <= 0;\n                    \n                    rPI_BUFF_Reset      <= 0;\n                    rPI_BUFF_RE         <= 0;\n                    rPI_BUFF_WE         <= 0;\n                    rPO_DQStrobe[7:0]   <= 0;\n                    rDQSOutEnable       <= 0;\n                end\n                PBR_RFRST: begin\n                    rReady              <= 0;\n                    \n                    rTimer[3:0]         <= 4'b0000;\n                    \n                    rPI_BUFF_Reset      <= 1'b1;\n                    rPI_BUFF_RE         <= 1'b0;\n                    rPI_BUFF_WE         <= 1'b0;\n                    rPO_DQStrobe[7:0]   <= 8'b0101_0101;\n                    rDQSOutEnable       <= 1'b1;\n                end\n                PBR_RLOOP: begin\n                    rReady              <= 0;\n                    \n                    rTimer[3:0]         <= rTimer[3:0] + 1'b1;\n                    \n                    rPI_BUFF_Reset      <= 1'b1;\n                    rPI_BUFF_RE         <= 1'b0;\n                    rPI_BUFF_WE         <= 1'b0;\n                    rPO_DQStrobe[7:0]   <= 8'b0101_0101;\n                    rDQSOutEnable       <= 1'b1;\n                end\n            endcase\n        end\n    end\n    \n    \n    \n    assign oReady           = rReady | wJOBDone ;\n    assign oLastStep        = wJOBDone         ;\n    \n    assign oPI_BUFF_Reset   = rPI_BUFF_Reset    ;\n    assign oPI_BUFF_RE      = rPI_BUFF_RE       ;\n    assign oPI_BUFF_WE      = rPI_BUFF_WE       ;\n    assign oPO_DQStrobe     = rPO_DQStrobe      ;\n    assign oDQSOutEnable    = rDQSOutEnable     ;\n    \nendmodule\n",
        "module_name": "NPM_Toggle_PHY_B_Reset",
        "module_hash": "2d25baee238d635ecdcf6544ff3f52c6",
        "dataset_index": 25619
      },
      "binary_multiplier_a8ba7dc3": {
        "rtl_code": "\nmodule binary_multiplier(clk, reset, a, b, result);\n\ninput clk, reset;\ninput [7:0] a, b;\noutput reg [15:0] result;\nreg [3:0] i;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        result <= 0;\n    end else begin\n        for (i = 0; i < 8; i = i + 1) begin\n            if (a[i]) begin\n                result <= result + (b << i);\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "binary_multiplier",
        "module_hash": "a8ba7dc3c9e1e36faad3e5ea95b47cc6",
        "dataset_index": 10545
      },
      "r4_adder_909fe565": {
        "rtl_code": "module r4_adder(output [3:0] S, output Cout, input [3:0] A, B, input Cin);\n\n    wire c1, c2, c3;\n\n    full_adder a1(.S(S[0]), .Cout(c1), .A(A[0]), .B(B[0]), .Cin(Cin)),\n               a2(.S(S[1]), .Cout(c2), .A(A[1]), .B(B[1]), .Cin(c1)),\n               a3(.S(S[2]), .Cout(c3), .A(A[2]), .B(B[2]), .Cin(c2)),\n               a4(.S(S[3]), .Cout(Cout), .A(A[3]), .B(B[3]), .Cin(c3));\n\nendmodule\n\nmodule full_adder(output S, output Cout, input A, B, input Cin);\n    assign {Cout, S} = A + B + Cin;\nendmodule",
        "module_name": "r4_adder",
        "module_hash": "909fe5651b5e9aff9fc0b73f35683f31",
        "dataset_index": 8684
      },
      "sky130_fd_sc_ms__fah_6cc96034": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__fah (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CI\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CI  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xor0_out_SUM;\n    wire a_b         ;\n    wire a_ci        ;\n    wire b_ci        ;\n    wire or0_out_COUT;\n\n    xor xor0 (xor0_out_SUM, A, B, CI       );\n    buf buf0 (SUM         , xor0_out_SUM   );\n    and and0 (a_b         , A, B           );\n    and and1 (a_ci        , A, CI          );\n    and and2 (b_ci        , B, CI          );\n    or  or0  (or0_out_COUT, a_b, a_ci, b_ci);\n    buf buf1 (COUT        , or0_out_COUT   );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__fah",
        "module_hash": "6cc96034f12a22f611c66142194c67b9",
        "dataset_index": 22109
      },
      "comparator_b7d809f1": {
        "rtl_code": "module comparator(A, B, Z);\n  input [1:0] A;\n  input [1:0] B;\n  output Z;\n  wire eq, gt;\n\n  assign eq = (A == B);\n  assign gt = (A > B);\n\n  assign Z = (gt | eq);\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "b7d809f142b9604edb8e187f00e17bbd",
        "dataset_index": 8815
      },
      "serdes_fc_tx_5d21039a": {
        "rtl_code": "module serdes_fc_tx\n  (input clk, input rst,\n   input xon_rcvd, input xoff_rcvd, output reg inhibit_tx);\n\n   reg [15:0] state;\n   always @(posedge clk)\n     if(rst)\n       state <= 0;\n     else if(xoff_rcvd)\n       state <= 255;\n     else if(xon_rcvd)\n       state <= 0;\n     else if(state !=0)\n       state <= state - 1;\n\n   always @(posedge clk)\n     inhibit_tx <= (state != 0);\n   \nendmodule ",
        "module_name": "serdes_fc_tx",
        "module_hash": "5d21039a361993861074da3696fb5796",
        "dataset_index": 24001
      },
      "Ramifier_111e2d48": {
        "rtl_code": "module Ramifier\n#(\n    parameter BRANCH_CONDITION_WIDTH = 4\n)(\n  input [(BRANCH_CONDITION_WIDTH - 1):0] condition,\n  input negative_flag, zero_flag, carry_flag, overflow_flag,\n  output reg take\n);\n\n\n    always @ ( * ) begin\n        case (condition)\n            0:begin take = zero_flag;\n            end\n            1:begin take = !zero_flag;\n            end\n            2:begin take = carry_flag;\n            end\n            3:begin take = !carry_flag;\n            end\n            4:begin   take = negative_flag;\n            end\n            5:begin   take = !(negative_flag);\n            end\n            6:begin   take = overflow_flag;\n            end\n            7:begin   take = !(overflow_flag);\n            end\n            8:begin   take = (carry_flag) && (!zero_flag);\n            end\n            9:begin   take = (!carry_flag) || (zero_flag);\n            end\n            10:begin    take =  (negative_flag ^~ overflow_flag) ;\n            end\n            11:begin    take = (negative_flag ^ overflow_flag);\n            end\n            12:begin    take = (!zero_flag) && (negative_flag ^~ overflow_flag);\n            end\n            13:begin     take = (zero_flag) || (negative_flag ^ overflow_flag);\n            end\n            14:begin  take = 1;\n            end\n            default: begin\n                take = 0; end\n        endcase\n    end\n\nendmodule\n",
        "module_name": "Ramifier",
        "module_hash": "111e2d488464a2c4a3ce6f52714e97c6",
        "dataset_index": 22899
      },
      "dff_async_reset_02930510": {
        "rtl_code": "module dff_async_reset (\n    input D,\n    input CLK,\n    input RESET,\n    output reg Q\n);\n\nalways @(posedge CLK, posedge RESET) begin\n    if (RESET == 1'b1) begin\n        Q <= 1'b0;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule",
        "module_name": "dff_async_reset",
        "module_hash": "0293051082e59980dbe07f2cc066c9c6",
        "dataset_index": 2350
      },
      "bit_counter_79ef9a60": {
        "rtl_code": "module bit_counter (\n    input CLK,\n    input RST,\n    input [31:0] data_in,\n    output reg [4:0] count_set_bits\n);\n\n    reg [31:0] shift_reg;\n    integer i;\n\n    always @(posedge CLK or negedge RST) begin\n        if (RST == 0) begin\n            shift_reg <= 0;\n            count_set_bits <= 0;\n        end\n        else begin\n            shift_reg <= data_in;\n            count_set_bits <= 0;\n            for (i = 0; i < 32; i = i + 1) begin\n                if (shift_reg[i] == 1) begin\n                    count_set_bits <= count_set_bits + 1;\n                end\n            end\n        end\n    end\n\nendmodule",
        "module_name": "bit_counter",
        "module_hash": "79ef9a606c20d925af19f102b37a8320",
        "dataset_index": 10624
      },
      "memory_3589031a": {
        "rtl_code": "\nmodule memory(clk, mem_read, mem_write, address, data_in, data_out);\n  input  clk, mem_read, mem_write;\n  input  [31:0] address, data_in;\n  output [31:0] data_out;\n\n  parameter BASE_ADDRESS = 25'd0; // address that applies to this memory - change if desired\n\n  reg [31:0] mem_array [0:31];\n  wire [4:0] mem_offset;\n  wire address_select;\n\n  assign mem_offset = address[6:2];  // drop 2 LSBs to get word offset\n\n  assign address_select = (address[31:7] == BASE_ADDRESS);  // address decoding\n\n  assign data_out = (mem_read == 1'b1 && address_select == 1'b1) ? mem_array[mem_offset] : 32'hxxxxxxxx;\n\n  // for WRITE operations\n  always @(posedge clk)\n  begin\n    if (mem_write == 1'b1 && address_select == 1'b1)\n    begin\n      mem_array[mem_offset] <= data_in;\n    end\n  end\n\n  // initialize with some arbitrary values\n\n  integer i;\n  initial begin\n    for (i=0; i<32; i=i+1) mem_array[i] = i*4;\n  end\nendmodule",
        "module_name": "memory",
        "module_hash": "3589031a2c03779d7ebdd61a61c47575",
        "dataset_index": 13390
      },
      "full_adder_50d230f4": {
        "rtl_code": "module full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\nwire w1, w2, w3;\n\nassign w1 = A ^ B;\nassign w2 = w1 ^ Cin;\nassign S = w2;\nassign w3 = A & B;\nassign Cout = w3 | (w1 & Cin);\n\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire c1, c2, c3;\n\nfull_adder fa0(A[0], B[0], Cin, S[0], c1);\nfull_adder fa1(A[1], B[1], c1, S[1], c2);\nfull_adder fa2(A[2], B[2], c2, S[2], c3);\nfull_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "50d230f4a62159c85303a374bd59523d",
        "dataset_index": 20710
      },
      "debounce_push_button_525b1435": {
        "rtl_code": "module debounce_push_button (\n  input clk,\n  input button,\n  output reg debounced_button\n);\n\nparameter IDLE = 2'b00, PRE_DEBOUNCE = 2'b01, DEBOUNCE = 2'b10;\nreg [1:0] state, next_state;\nreg [9:0] debounce_counter;\n\nalways @(posedge clk) begin\n  state <= next_state;\n  case(state)\n    IDLE: begin\n      if(button) next_state <= PRE_DEBOUNCE;\n      else next_state <= IDLE;\n    end\n    PRE_DEBOUNCE: begin\n      if(button) next_state <= PRE_DEBOUNCE;\n      else begin\n        next_state <= DEBOUNCE;\n        debounce_counter <= 0;\n      end\n    end\n    DEBOUNCE: begin\n      if(button && debounce_counter < 9) begin\n        debounce_counter <= debounce_counter + 1;\n        next_state <= DEBOUNCE;\n      end\n      else begin\n        debounced_button <= button;\n        next_state <= IDLE;\n      end\n    end\n  endcase\nend\n\nendmodule\n",
        "module_name": "debounce_push_button",
        "module_hash": "525b14355004ab4582c65af7ed987cff",
        "dataset_index": 21457
      },
      "simple_calculator_a0fc0def": {
        "rtl_code": "module simple_calculator(\n    clk,\n    reset,\n    ce,\n    a,\n    b,\n    op,\n    result);\n\nparameter ADD = 2'b00;\nparameter SUB = 2'b01;\n\ninput clk;\ninput reset;\ninput ce;\ninput [7:0] a;\ninput [7:0] b;\ninput [1:0] op;\noutput [7:0] result;\n\nreg [7:0] result_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        result_reg <= 8'b0;\n    end else if (ce) begin\n        case (op)\n            ADD: result_reg <= a + b;\n            SUB: result_reg <= a - b;\n        endcase\n    end\nend\n\nassign result = result_reg;\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "a0fc0def72dc1eac5d849efe0e08e998",
        "dataset_index": 296
      },
      "sky130_fd_sc_lp__inv_6a3794f3": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__inv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__inv",
        "module_hash": "6a3794f3ffe97ab56e09725a073b1bc1",
        "dataset_index": 7916
      },
      "top__48ff15da": {
        "rtl_code": "module top_module (\n    input clk,      // Clock input\n    input reset,    // Synchronous active-high reset\n    input [7:0] d,  // 8-bit input for the shift register\n    input [31:0] in, // 32-bit input for the rising edge capture module\n    output [31:0] out // 32-bit output from the functional module\n);\n\n// Declare an array of 4 registers for the shift register\nreg [7:0] shift_reg [3:0]; // 4-stage shift register\n\nreg [31:0] capture_reg; // Rising edge capture register\nreg [31:0] product; // Product of shift register and capture register\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset all registers to 0\n        shift_reg[0] <= 0;\n        shift_reg[1] <= 0;\n        shift_reg[2] <= 0;\n        shift_reg[3] <= 0;\n        capture_reg <= 0;\n        product <= 0;\n    end else begin\n        // Shift register\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        shift_reg[3] <= shift_reg[2];\n\n        // Rising edge capture\n        if (in[31] && !capture_reg[31]) begin\n            capture_reg <= in;\n        end\n\n        // Functional module: multiply shift register and capture register\n        product <= shift_reg[3] * capture_reg;\n    end\nend\n\nassign out = product;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "48ff15da1f7447e71c3bd6b5f115a16d",
        "dataset_index": 2937
      },
      "adder_tree_top_40aca10b": {
        "rtl_code": "`define ADDER_WIDTH 006\n`define DUMMY_WIDTH 128\n\n`define 2_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "40aca10b2dbd42ae6cd0bc36e017b231",
        "dataset_index": 25256
      },
      "johnson_counter_cc0de567": {
        "rtl_code": "module johnson_counter(\n  input clk,\n  output out1,\n  output out2\n);\n\nparameter n = 4; // number of bits in the counter\n\nreg [n-1:0] state; // register to hold current state\n\n// define sequence of states as a function of current state and clock signal\nalways @(posedge clk) begin\n  state <= {state[n-2:0], ~state[n-1]};\nend\n\n// connect current state to output signals\nassign out1 = state[0];\nassign out2 = ~state[0];\n\nendmodule",
        "module_name": "johnson_counter",
        "module_hash": "cc0de5679287b2347bf41306347243b5",
        "dataset_index": 11971
      },
      "cla_4bit_adder_7f6b2dcc": {
        "rtl_code": "module cla_4bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] Y\n);\n\n    wire [3:0] P;\n    wire [3:0] G;\n    wire [3:0] C;\n    wire [3:0] C_prop;\n    wire [3:0] C_gen;\n    wire [3:0] C_out;\n\n    assign P = A ^ B;\n    assign G = A & B;\n    assign C_prop[0] = G[0];\n    assign C_prop[1] = G[1] + (P[1] & G[0]);\n    assign C_prop[2] = G[2] + (P[2] & G[1]) + (P[2] & P[1] & G[0]);\n    assign C_prop[3] = G[3] + (P[3] & G[2]) + (P[3] & P[2] & G[1]) + (P[3] & P[2] & P[1] & G[0]);\n    assign C_gen[0] = G[0];\n    assign C_gen[1] = P[1] & G[0];\n    assign C_gen[2] = P[2] & G[1] | P[2] & P[1] & G[0];\n    assign C_gen[3] = P[3] & G[2] | P[3] & P[2] & G[1] | P[3] & P[2] & P[1] & G[0];\n    assign C_out[0] = C_prop[0];\n    assign C_out[1] = C_prop[1] | C_gen[1] & C_prop[0];\n    assign C_out[2] = C_prop[2] | C_gen[2] & C_prop[1] | C_gen[2] & C_gen[1] & C_prop[0];\n    assign C_out[3] = C_prop[3] | C_gen[3] & C_prop[2] | C_gen[3] & C_gen[2] & C_prop[1] | C_gen[3] & C_gen[2] & C_gen[1] & C_prop[0];\n    assign Y = P ^ C_out;\n\nendmodule",
        "module_name": "cla_4bit_adder",
        "module_hash": "7f6b2dccc86b4dcdb5c4528c6fe316d7",
        "dataset_index": 691
      },
      "dffc_64_afc0793d": {
        "rtl_code": "module dffc_64 ( clk, reset, d, q );\n    input clk;\n    input reset;\n    input [63:0] d;\n    output reg [63:0] q;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 64'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule",
        "module_name": "dffc_64",
        "module_hash": "afc0793d6a272816dc7c3238124ff4d6",
        "dataset_index": 3523
      },
      "_90_pmux2_ecec23fc": {
        "rtl_code": "module _90_pmux2 (A, B, S, Y);\n\tparameter WIDTH = 1;\n\tparameter S_WIDTH = 1;\n\n\tinput [WIDTH-1:0] A;\n\tinput [WIDTH*S_WIDTH-1:0] B;\n\tinput [S_WIDTH-1:0] S;\n\toutput [WIDTH-1:0] Y;\n\n\twire [S_WIDTH-1:0] S_NOT;\n\twire [WIDTH*S_WIDTH-1:0] B_NOT;\n\n\tassign S_NOT = ~S;\n\tassign B_NOT = ~B;\n\n\twire [WIDTH-1:0] A_AND_S_NOT;\n\twire [WIDTH*S_WIDTH-1:0] B_AND_S;\n\n\tassign A_AND_S_NOT = A & {WIDTH{S_NOT}};\n\tassign B_AND_S = B & {WIDTH*S_WIDTH{S_NOT}};\n\n\twire [WIDTH-1:0] Y_B_AND_S_NOT;\n\twire [S_WIDTH-1:0] Y_B_AND_S_NOT_OR;\n\n\tassign Y_B_AND_S_NOT = |B_AND_S;\n\tassign Y_B_AND_S_NOT_OR = |{S_WIDTH{Y_B_AND_S_NOT}};\n\n\tassign Y = S ? Y_B_AND_S_NOT_OR : A_AND_S_NOT;\nendmodule",
        "module_name": "_90_pmux2",
        "module_hash": "ecec23fcdc8ee351b277e8331a90ed49",
        "dataset_index": 7810
      },
      "mux_2to1_enable_4267c2d2": {
        "rtl_code": "module mux_2to1_enable (\n  input A,\n  input B,\n  input E,\n  output Y\n);\n\n  assign Y = E ? A : B;\n\nendmodule",
        "module_name": "mux_2to1_enable",
        "module_hash": "4267c2d29ec060d0908e220244863edb",
        "dataset_index": 18730
      },
      "tone_generator_885ae611": {
        "rtl_code": "\nmodule tone_generator (\n  input clk,\n  input rst,\n  input [1:0] tone,\n  output audio_out\n);\n\nparameter f_clk = 50_000_000; // frequency of the clock signal\nparameter f_tone = 440; // frequency of the selected tone (default: A4)\nparameter t_duration = 1; // duration of the tone in seconds (default: 1 second)\n\nreg [31:0] tone_counter = 0;\nreg [31:0] tone_duration = 0;\nreg [31:0] sample_counter = 0;\nreg [31:0] sample_period = 0;\nreg [1:0] tone_type = 2'b00; // default: sine wave\n\nwire tone_signal;\n\n// DTMF tone generation\nalways @ (posedge clk) begin\n  if (rst) begin\n    tone_counter <= 0;\n    tone_duration <= 0;\n    sample_counter <= 0;\n    sample_period <= 0;\n    tone_type <= 2'b00;\n  end else begin\n    // Check if tone is selected\n    if (tone != 2'b00) begin\n      // A new tone is selected\n      if (tone != tone_type) begin\n        tone_counter <= 0;\n        tone_duration <= t_duration * f_clk;\n        sample_counter <= 0;\n        sample_period <= f_clk / f_tone;\n        tone_type <= tone;\n      end else begin // Same tone is selected\n        // Check if tone duration is reached\n        if (tone_counter >= tone_duration) begin\n          tone_counter <= 0;\n          tone_duration <= 0;\n          sample_counter <= 0;\n          sample_period <= 0;\n          tone_type <= 2'b00;\n        end else begin\n          tone_counter <= tone_counter + 1;\n          sample_counter <= sample_counter + 1;\n          // Check if a new sample is needed\n          if (sample_counter >= sample_period) begin\n            sample_counter <= 0;\n          end\n        end\n      end\n    end else begin // No tone is selected\n      tone_counter <= 0;\n      tone_duration <= 0;\n      sample_counter <= 0;\n      sample_period <= 0;\n      tone_type <= 2'b00;\n    end\n  end\nend\n\n// Sine wave generation\nassign tone_signal = (tone_counter >= (f_clk / (2 * f_tone))) ? 1'b1 : 1'b0;\n\n// Audio output\nassign audio_out = tone_signal;\n\nendmodule",
        "module_name": "tone_generator",
        "module_hash": "885ae611854a4e1c7b5c01e78f09306e",
        "dataset_index": 15146
      },
      "axi_timer #_baa3f5a1": {
        "rtl_code": "\nmodule axi_timer #(\n  parameter WIDTH = 8,\n  parameter MAX_VALUE = 256\n)(\n  input clk,\n  input rst,\n  input load,\n  input [WIDTH-1:0] value,\n  input enable,\n  output reg timer_expired,\n  output wire [WIDTH-1:0] current_value\n);\n\n  reg [WIDTH-1:0] count;\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n      timer_expired <= 0;\n    end else if (load) begin\n      count <= value;\n    end else if (enable) begin\n      if (count == 0) begin\n        timer_expired <= 1;\n        count <= MAX_VALUE;\n      end else begin\n        count <= count - 1;\n        timer_expired <= 0;\n      end\n    end\n  end\n\n  assign current_value = count;\n\nendmodule",
        "module_name": "axi_timer #",
        "module_hash": "baa3f5a162585c705ec69f59aa65c8c7",
        "dataset_index": 20972
      },
      "addsub_212158e2": {
        "rtl_code": "module addsub (S, Cout, A, B, C);\n    output [3:0] S;\n    output Cout;\n    input [3:0] A, B;\n    input C;\n\n    wire [3:0] B_neg;\n\n    // invert B bits when C is high to implement subtraction\n    assign B_neg = ~B + 1;\n    wire [3:0] B_sel = C ? B_neg : B;\n\n    // implement 4-bit adder\n    wire [3:0] S_add;\n    wire C_add;\n    assign {C_add, S_add} = A + B_sel;\n\n    // set output values\n    assign S = S_add;\n    assign Cout = C_add;\n\nendmodule",
        "module_name": "addsub",
        "module_hash": "212158e21b8d8a4bb997a6d1e4dd5327",
        "dataset_index": 1493
      },
      "sequence_detector_30309173": {
        "rtl_code": "module sequence_detector (\n    input clk,\n    input reset,\n    input [3:0] in,\n    output reg [6:0] seg_out\n);\n\n    reg [3:0] shift_reg;\n    reg [3:0] seq = 4'b1100;\n    reg [3:0] seq_detect;\n    reg detect;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n            detect <= 0;\n            seq_detect <= 4'b0000;\n            seg_out <= 7'b0000000;\n        end\n        else begin\n            shift_reg <= {in, shift_reg[3:1]};\n            seq_detect <= {shift_reg[2:0], in};\n            if (seq_detect == seq) begin\n                detect <= 1;\n            end\n            if (detect) begin\n                seg_out <= 7'b0110000; // Display \"1\"\n            end\n            else begin\n                seg_out <= 7'b0000000; // Display \"0\"\n            end\n        end\n    end\n\nendmodule",
        "module_name": "sequence_detector",
        "module_hash": "303091736d41b1e1c4c12f4ae394e8ea",
        "dataset_index": 10948
      },
      "top__c2486810": {
        "rtl_code": "\nmodule top_module (\n    input clk, // Clock signal\n    input reset, // Synchronous active-high reset\n    input [7:0] a, b, // 8-bit input values\n    output [7:0] result // 8-bit output representing the multiplication result\n);\n\n    reg [7:0] product; // 8-bit register to store the product\n    reg [7:0] quotient; // 8-bit register to store the quotient\n    \n    // Multiplication module\n    always @(posedge clk) begin\n        if (reset) begin\n            product <= 8'b0; // Reset the product register\n        end else begin\n            product <= a * b; // Perform multiplication\n        end\n    end\n    \n    // Division by 2 module\n    always @(posedge clk) begin\n        if (reset) begin\n            quotient <= 8'b0; // Reset the quotient register\n        end else begin\n            quotient <= product >> 1; // Perform division by 2\n        end\n    end\n    \n    // Assign output\n    assign result = quotient;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "c2486810efda0bde3a6c4602cb5cacb3",
        "dataset_index": 20600
      },
      "alt_vipvfr131_vfr_controller_a2085159": {
        "rtl_code": "module alt_vipvfr131_vfr_controller\n\t(\t\n\t\tclock,\n\t\treset,\n\t\t\n\t\tmaster_address,\n\t\tmaster_write,\n\t\tmaster_writedata,\n\t\tmaster_interrupt_recieve,\n\t\t\n\t\tgo_bit,\n\t\trunning,\n\t\tframe_complete,\t\t\n\t\tnext_bank,\n\t\t\n\t\tctrl_packet_width_bank0,\n\t\tctrl_packet_height_bank0,\n\t\tctrl_packet_interlaced_bank0,\n\t\t\n\t\tvid_packet_base_address_bank0,\n\t\tvid_packet_samples_bank0,\n\t\tvid_packet_words_bank0,\n\t\t\n\t\tctrl_packet_width_bank1,\n\t\tctrl_packet_height_bank1,\n\t\tctrl_packet_interlaced_bank1,\n\t\t\n\t\tvid_packet_base_address_bank1,\n\t\tvid_packet_samples_bank1,\n\t\tvid_packet_words_bank1,\n\t\t\n\t\twidth_of_next_vid_packet,\n\t\theight_of_next_vid_packet,\n\t\tinterlaced_of_next_vid_packet,\n\t\tdo_control_packet\n\t);\n\n\tlocalparam MASTER_ADDRESS_WIDTH\t= \t32;\t\n\tlocalparam MASTER_DATA_WIDTH \t\t=\t\t32;\n\t\n\tparameter CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH = 16;\n\tparameter CONTROL_PACKET_INTERLACED_REQUIREDWIDTH = 4;\n\tparameter PACKET_ADDRESS_WIDTH = 32;\n\tparameter PACKET_SAMPLES_WIDTH = 32;\n\tparameter PACKET_WORDS_WIDTH = 32;\n\t\n\tinput\t\tclock;\n\tinput\t\treset;\n\t\n\toutput reg [MASTER_ADDRESS_WIDTH-1 :0] master_address;\n\toutput reg master_write;\n\toutput reg [MASTER_DATA_WIDTH-1 :0] master_writedata;\n\tinput master_interrupt_recieve;\n\t\n\tinput go_bit;\n\toutput reg running;\n\toutput reg frame_complete;\n\tinput next_bank;\n\t\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_width_bank0;\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_height_bank0;\n\tinput [CONTROL_PACKET_INTERLACED_REQUIREDWIDTH-1:0] ctrl_packet_interlaced_bank0;\n\t\n\tinput [PACKET_ADDRESS_WIDTH-1:0] \tvid_packet_base_address_bank0;\n\tinput [PACKET_SAMPLES_WIDTH-1:0] \tvid_packet_samples_bank0;\n\tinput [PACKET_WORDS_WIDTH-1:0] \t\tvid_packet_words_bank0;\n\t\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_width_bank1;\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_height_bank1;\n\tinput [CONTROL_PACKET_INTERLACED_REQUIREDWIDTH-1:0] ctrl_packet_interlaced_bank1;\n\t\n\tinput [PACKET_ADDRESS_WIDTH-1:0] \tvid_packet_base_address_bank1;\n\tinput [PACKET_SAMPLES_WIDTH-1:0] \tvid_packet_samples_bank1;\n\tinput [PACKET_WORDS_WIDTH-1:0] \t\tvid_packet_words_bank1;\n\t\n\toutput reg [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] width_of_next_vid_packet;\n\toutput reg [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] height_of_next_vid_packet;\n\toutput reg [CONTROL_PACKET_INTERLACED_REQUIREDWIDTH-1:0] interlaced_of_next_vid_packet;\n\toutput reg do_control_packet;\n\t\n\t\n\tlocalparam PACKET_READER_GO_ADDRESS = 0;\n\tlocalparam PACKET_READER_STATUS_ADDRESS = 1;\n\tlocalparam PACKET_READER_INTERRUPT_ADDRESS = 2;\n\tlocalparam PACKET_READER_PACKET_ADDRESS_ADDRESS = 3;\n\tlocalparam PACKET_READER_PACKET_TYPE_ADDRESS = 4;\n\tlocalparam PACKET_READER_PACKET_SAMPLES_ADDRESS = 5;\n\tlocalparam PACKET_READER_PACKET_WORDS_ADDRESS = 6;\n\t\n\tlocalparam [2:0] IDLE            \t\t= 3'd0;\n\tlocalparam [2:0] SENDING_ADDRESS \t\t= 3'd1;\n\tlocalparam [2:0] SENDING_SAMPLES \t\t= 3'd2;\n\tlocalparam [2:0] SENDING_WORDS   \t\t= 3'd3;\n\tlocalparam [2:0] SENDING_TYPE   \t\t= 3'd4;\n\tlocalparam [2:0] SENDING_GO_AND_ENABLE_INTERRUPT      \t\t= 3'd5;\n\tlocalparam [2:0] WAITING_END_FRAME \t= 3'd6;\n\treg [2:0] state;\n\treg bank_to_read;\n\t\t\n\t\talways @(posedge clock or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\t\t\n\t\t\tbank_to_read <= 0;\n\t\t\tmaster_write <= 0;\n\t\t\tmaster_writedata <= 0;\n\t\t\tmaster_address <= 0;\n\t\t\tdo_control_packet <= 0;\n\t\t\twidth_of_next_vid_packet <=0;\n\t\t\theight_of_next_vid_packet <=0;\n\t\t\tinterlaced_of_next_vid_packet <=0;\n\t\t\trunning<=0;\n\t\t\tframe_complete<=0;\n\t\t\t\n\t\tend\telse begin\n\t\t\tcase (state)\n\t\t\t\t\n\t\t\t\tIDLE :\tbegin\n\t\t\t\t\tmaster_write<=0;\n\t\t\t\t\t\n\t\t\t\t\tframe_complete<=0;\n\t\t\t\t\tif(go_bit) begin\n\t\t\t\t\t\tstate <= SENDING_ADDRESS;\n\t\t\t\t\t\tbank_to_read <= next_bank;\n\t\t\t\t\t\trunning<=1;\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_ADDRESS :\tbegin \n\t\t\t\t\tstate <= SENDING_SAMPLES;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_ADDRESS_ADDRESS;\n\t\t\t\t\tmaster_write <= 1;\n\t\t\t\t\tdo_control_packet <= 1;\n\t\t\t\t\tif(bank_to_read==0) begin\t\t\t\t\t\n\t\t\t\t\t\tmaster_writedata <= vid_packet_base_address_bank0;\n\t\t\t\t\t\twidth_of_next_vid_packet <= ctrl_packet_width_bank0;\n\t\t\t\t\t\theight_of_next_vid_packet <= ctrl_packet_height_bank0;\n\t\t\t\t\t\tinterlaced_of_next_vid_packet <= ctrl_packet_interlaced_bank0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tmaster_writedata <= vid_packet_base_address_bank1;\n\t\t\t\t\t\twidth_of_next_vid_packet <= ctrl_packet_width_bank1;\n\t\t\t\t\t\theight_of_next_vid_packet <= ctrl_packet_height_bank1;\n\t\t\t\t\t\tinterlaced_of_next_vid_packet <= ctrl_packet_interlaced_bank1;\n\t\t\t\t\tend\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_SAMPLES :\tbegin \n\t\t\t\t\tstate <= SENDING_WORDS;\n\t\t\t\t\tdo_control_packet <= 0;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_SAMPLES_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; if(bank_to_read==0) begin\t\t\t\t\t\n\t\t\t\t\t\tmaster_writedata <= vid_packet_samples_bank0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tmaster_writedata <= vid_packet_samples_bank1;\n\t\t\t\t\tend\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_WORDS :\tbegin \n\t\t\t\t\tstate <= SENDING_TYPE;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_WORDS_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; if(bank_to_read==0) begin\t\t\t\t\t\n\t\t\t\t\t\tmaster_writedata <= vid_packet_words_bank0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tmaster_writedata <= vid_packet_words_bank1;\n\t\t\t\t\tend\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_TYPE :\tbegin \n\t\t\t\t\tstate <= SENDING_GO_AND_ENABLE_INTERRUPT;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_TYPE_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; master_writedata <= 0; end\n\t\t\t\t\n\t\t\t\tSENDING_GO_AND_ENABLE_INTERRUPT :\tbegin \n\t\t\t\t\tstate <= WAITING_END_FRAME;\n\t\t\t\t\tmaster_address <= PACKET_READER_GO_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; master_writedata <= 3; end\n\t\t\t\t\n\t\t\t\tWAITING_END_FRAME\t: begin\n\t\t\t\t\tmaster_address <= PACKET_READER_INTERRUPT_ADDRESS;\n\t\t\t\t\tmaster_writedata <= 2;\n\t\t\t\t\tmaster_write <= 0; if(master_interrupt_recieve) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\trunning <= 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tframe_complete <=1;\n\t\t\t\t\t\tmaster_write <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\t\nendmodule\n",
        "module_name": "alt_vipvfr131_vfr_controller",
        "module_hash": "a2085159f618dae201328f630ecd2b6a",
        "dataset_index": 23937
      },
      "add_subtract_display_e5ee408c": {
        "rtl_code": "module add_subtract_display (\n  input clk,\n  input reset,\n  input [3:0] a,\n  input [3:0] b,\n  input op,\n  output reg [6:0] seg\n);\n\n  // Adder module\n  wire [3:0] add_out;\n  adder add_inst (.a(a), .b(b), .sum(add_out));\n\n  // Subtractor module\n  wire [3:0] sub_out;\n  subtractor sub_inst (.a(a), .b(b), .diff(sub_out));\n\n  // Shift register for adder output\n  reg [6:0] add_shift_reg = 7'b0000000;\n  always @(posedge clk) begin\n    if (reset) begin\n      add_shift_reg <= 7'b0000000;\n    end else begin\n      add_shift_reg <= {add_shift_reg[5:0], add_out[3]};\n    end\n  end\n\n  // Shift register for subtractor output\n  reg [6:0] sub_shift_reg = 7'b0000000;\n  always @(posedge clk) begin\n    if (reset) begin\n      sub_shift_reg <= 7'b0000000;\n    end else begin\n      sub_shift_reg <= {sub_shift_reg[5:0], sub_out[3]};\n    end\n  end\n\n  // Output selection logic\n  reg [6:0] display_out = 7'b0000000;\n  always @(posedge clk) begin\n    if (reset) begin\n      display_out <= 7'b0000000;\n    end else begin\n      if (op == 0) begin\n        display_out <= add_shift_reg;\n      end else begin\n        display_out <= sub_shift_reg;\n      end\n    end\n  end\n\n  // 7-segment display decoder\n  always @(*) begin\n    case (display_out)\n      7'b0000000: seg = 7'b1111110; // 0\n      7'b0000001: seg = 7'b0110000; // 1\n      7'b0000010: seg = 7'b1101101; // 2\n      7'b0000011: seg = 7'b1111001; // 3\n      7'b0000100: seg = 7'b0110011; // 4\n      7'b0000101: seg = 7'b1011011; // 5\n      7'b0000110: seg = 7'b1011111; // 6\n      7'b0000111: seg = 7'b1110000; // 7\n      7'b0001000: seg = 7'b1111111; // 8\n      7'b0001001: seg = 7'b1110011; // 9\n      default: seg = 7'b0000001; // Error (display \"-\")\n    endcase\n  end\n\nendmodule\n\n// Adder module\nmodule adder (\n  input [3:0] a,\n  input [3:0] b,\n  output reg [3:0] sum\n);\n  always @(*) begin\n    sum = a + b;\n  end\nendmodule\n\n// Subtractor module\nmodule subtractor (\n  input [3:0] a,\n  input [3:0] b,\n  output reg [3:0] diff\n);\n  always @(*) begin\n    diff = a - b;\n  end\nendmodule",
        "module_name": "add_subtract_display",
        "module_hash": "e5ee408c2f837fe60c2e353bc91c3447",
        "dataset_index": 11293
      },
      "digital_circuit__a65b3b43": {
        "rtl_code": "\nmodule digital_circuit_module (\n    output reg Y   ,\n    input  A1  ,\n    input  A2  ,\n    input  B1_N,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    wire Y1;\n    wire Y2;\n    wire c;\n\n    assign Y1 = (A1 & A2 & B1_N);\n    assign Y2 = ~(A1 & A2 & B1_N);\n    assign c = ~VPWR;\n\n    always @* begin\n        Y = c ? Y2 : Y1;\n    end\n\nendmodule",
        "module_name": "digital_circuit_",
        "module_hash": "a65b3b431a6c0f6ed49c42dcd0f77f1a",
        "dataset_index": 8776
      },
      "and_gate_d7194aa7": {
        "rtl_code": "module and_gate(input a, b, clk, output reg out);\n  wire mux_out;\n  reg d_ff_out;\n  \n  // Multiplexer implementation\n  assign mux_out = (a & b);\n  \n  // D flip-flop implementation\n  always @(posedge clk) begin\n    d_ff_out <= mux_out;\n  end\n  \n  always @* begin\n    out = d_ff_out;\n  end\nendmodule",
        "module_name": "and_gate",
        "module_hash": "d7194aa73f775d874897e2f4913d5b13",
        "dataset_index": 7568
      },
      "calculator_c410c584": {
        "rtl_code": "module calculator(\n    input clk,\n    input rst,\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input [2:0] op,\n    output reg signed [7:0] result,\n    output reg of\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 0;\n        of <= 0;\n    end else begin\n        case (op)\n            3'b000: begin // addition\n                if ((b > 0 && a > (127 - b)) || (b < 0 && a < (-128 - b))) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a + b;\n            end\n            3'b001: begin // subtraction\n                if ((b < 0 && a > (127 + b)) || (b > 0 && a < (-128 + b))) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a - b;\n            end\n            3'b010: begin // multiplication\n                if ((a == -128 && b == -1) || (b == -128 && a == -1)) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a * b;\n            end\n            3'b011: begin // division\n                if (b == 0) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a / b;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "c410c58400690301dfadddd2340a3644",
        "dataset_index": 7165
      },
      "nor_gate_b5c53890": {
        "rtl_code": "module nor_gate(input a, b, output out);\n    wire temp1, temp2, temp3;\n    \n    nand gate1(temp1, a, a);\n    nand gate2(temp2, b, b);\n    nand gate3(temp3, temp1, temp2);\n    nand gate4(out, temp3, temp3);\nendmodule",
        "module_name": "nor_gate",
        "module_hash": "b5c53890cf65dc8d7076f98b4671a7e5",
        "dataset_index": 12688
      },
      "half_adder_1790b3da": {
        "rtl_code": "\nmodule half_adder(\n    input A,\n    input B,\n    output S,\n    output C\n);\n\nassign {C, S} = A + B;\n\nendmodule\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\nassign {Cout, S} = A + B + Cin;\n\nendmodule\nmodule adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] C;\nwire [2:0] S1;\n\nhalf_adder HA0(A[0], B[0], S[0], C[0]);\nfull_adder FA1(A[1], B[1], C[0], S1[0], C[1]);\nfull_adder FA2(A[2], B[2], C[1], S1[1], C[2]);\nfull_adder FA3(A[3], B[3], C[2], S[3], Cout);\n\nassign S = {S[3], S1, S[0]};\n\nendmodule",
        "module_name": "half_adder",
        "module_hash": "1790b3da0b4791bef0bdf7340d1e50d5",
        "dataset_index": 9051
      },
      "spiral_16_fcb28c97": {
        "rtl_code": "module spiral_16(\n          i_data,\n          \n        o_data_4,\n        o_data_13,\n        o_data_22,\n        o_data_31,\n        o_data_38,\n        o_data_46,\n        o_data_54,\n        o_data_61,\n        o_data_67,\n        o_data_73,\n        o_data_78,\n        o_data_82,\n        o_data_85,\n        o_data_88,\n        o_data_90\n);\n\ninput  signed [16:0]   i_data;\noutput signed [16+7:0] o_data_4;\noutput signed [16+7:0] o_data_13;\noutput signed [16+7:0] o_data_22;\noutput signed [16+7:0] o_data_31;\noutput signed [16+7:0] o_data_38;\noutput signed [16+7:0] o_data_46;\noutput signed [16+7:0] o_data_54;\noutput signed [16+7:0] o_data_61;\noutput signed [16+7:0] o_data_67;\noutput signed [16+7:0] o_data_73;\noutput signed [16+7:0] o_data_78;\noutput signed [16+7:0] o_data_82;\noutput signed [16+7:0] o_data_85;\noutput signed [16+7:0] o_data_88;\noutput signed [16+7:0] o_data_90;\nwire signed [23:0] w1,\n                    w32,\n                    w31,\n                    w8,\n                    w23,\n                    w4,\n                    w27,\n                    w39,\n                    w62,\n                    w61,\n                    w9,\n                    w2,\n                    w11,\n                    w13,\n                    w18,\n                    w19,\n                    w41,\n                    w36,\n                    w45,\n                    w67,\n                    w64,\n                    w73,\n                    w16,\n                    w17,\n                    w68,\n                    w85,\n                    w22,\n                    w38,\n                    w46,\n                    w54,\n                    w78,\n                    w82,\n                    w88,\n                    w90;\nassign w1 = i_data;\nassign w32 = w1 << 5;\nassign w31 = w32 - w1;\nassign w8 = w1 << 3;\nassign w23 = w31 - w8;\nassign w4 = w1 << 2;\nassign w27 = w31 - w4;\nassign w39 = w31 + w8;\nassign w62 = w31 << 1;\nassign w61 = w62 - w1;\nassign w9 = w1 + w8;\nassign w2 = w1 << 1;\nassign w11 = w9 + w2;\nassign w13 = w9 + w4;\nassign w18 = w9 << 1;\nassign w19 = w1 + w18;\nassign w41 = w9 + w32;\nassign w36 = w9 << 2;\nassign w45 = w9 + w36;\nassign w67 = w31 + w36;\nassign w64 = w1 << 6;\nassign w73 = w9 + w64;\nassign w16 = w1 << 4;\nassign w17 = w1 + w16;\nassign w68 = w17 << 2;\nassign w85 = w17 + w68;\nassign w22 = w11 << 1;\nassign w38 = w19 << 1;\nassign w46 = w23 << 1;\nassign w54 = w27 << 1;\nassign w78 = w39 << 1;\nassign w82 = w41 << 1;\nassign w88 = w11 << 3;\nassign w90 = w45 << 1;    \n\nassign  o_data_4= w4;\nassign  o_data_13=w13;\nassign  o_data_22=w22;\nassign  o_data_31=w31;\nassign  o_data_38=w38;\nassign  o_data_46=w46;\nassign  o_data_54=w54;\nassign  o_data_61=w61;\nassign  o_data_67=w67;\nassign  o_data_73=w73;\nassign  o_data_78=w78;\nassign  o_data_82=w82;\nassign  o_data_85=w85;\nassign  o_data_88=w88;\nassign  o_data_90=w90;\n\nendmodule",
        "module_name": "spiral_16",
        "module_hash": "fcb28c97084103da7986da06018dbd83",
        "dataset_index": 6407
      },
      "fpga_4bf3b8f7": {
        "rtl_code": "module fpga (\n    \n    input  wire       clk_125mhz,\n    input  wire       rst_125mhz,\n    \n    input  wire       btnu,\n    input  wire       btnl,\n    input  wire       btnd,\n    input  wire       btnr,\n    input  wire       btnc,\n    input  wire [7:0] sw,\n    output wire       ledu,\n    output wire       ledl,\n    output wire       ledd,\n    output wire       ledr,\n    output wire       ledc,\n    output wire [7:0] led,\n    \n    output wire       uart_rxd,\n    input  wire       uart_txd,\n    input  wire       uart_rts,\n    output wire       uart_cts\n);\n\n// LED control\nreg [4:0] led_state;\n\nalways @ (posedge clk_125mhz) begin\n    if (rst_125mhz) begin\n        led_state <= 5'b00000;\n    end else begin\n        led_state <= {btnc, btnr, btnd, btnl, btnu};\n    end\nend\n\nassign ledu = led_state[0];\nassign ledl = led_state[1];\nassign ledd = led_state[2];\nassign ledr = led_state[3];\nassign ledc = led_state[4];\nassign led = 8'h00;\n\n// UART control\nreg [7:0] uart_data;\n\nalways @ (posedge clk_125mhz) begin\n    if (rst_125mhz) begin\n        uart_data <= 8'h00;\n    end else if (uart_rxd) begin\n        uart_data <= uart_txd;\n    end\nend\n\nassign uart_rxd = uart_data[0];\nassign uart_cts = uart_data[1];\n\nendmodule",
        "module_name": "fpga",
        "module_hash": "4bf3b8f73d41274c9abd40c59ad269df",
        "dataset_index": 2066
      },
      "FSM_aa7c0943": {
        "rtl_code": "\nmodule FSM(\n    input [31:0] x,\t\t\t\t\tinput [31:0] y,\t\t\t\t\tinput [31:0] z,\t\t\t\t\tinput [31:0] k,\t\t\t\t\tinput [31:0] kappa_LUTRot, \n\t input [31:0] theta_LUTRot, \n\t input [31:0] delta_LUTRot,\n\t input [31:0] kappa_LUTVec, \n\t input [31:0] theta_LUTVec, \n\t input [31:0] delta_LUTVec,\n    input [31:0] theta_LUT,\t\tinput [31:0] kappa_LUT,\t\tinput [31:0] delta_LUT,\t\tinput [1:0] mode,\t\t\t\tinput operation,\t\t\t\t\tinput clock,\n\t input done_LUTRot,\n\t input done_LUTVec,\n\t input done_LUT,\t\t\t\t\toutput reg enable_LUT,\t\t\toutput reg [7:0] address,\t\toutput reg [31:0] theta_out,\toutput reg [31:0] kappa_out,\toutput reg [31:0] delta_out,\toutput reg done_FSM,\n\t output reg [31:0] x_final,\n\t output reg [31:0] y_final,\n\t output reg [31:0] z_final,\n\t output reg [31:0] k_final,\n\t input done_ALU\n    );\n\nreg [7:0] exponent;\nreg converge;\n\nalways @ (*)\nbegin\n\t\n\tif (operation == 1'b1)\t\n\tbegin\n\t\texponent <= 8'b01111111 - z[30:23];\n\tend\n\t\n\telse if (operation == 1'b0)\n\tbegin\n\t\texponent <= x[30:23] - y[30:23];\n\tend\n\t\n\nend\n\nalways @ (posedge clock)\nbegin\n\t\n\t\tif ((done_LUT == 1'b1 || done_LUTRot == 1'b1 || done_LUTVec == 1'b1) && enable_LUT == 1'b1)\n\tbegin\n\t\t\n\t\tif ((operation == 1'b0) && (mode == 2'b00 || (exponent <= 8'b11110011 && exponent > 8'b10000000)))\n\t\tbegin\n\t\t\tdelta_out <= delta_LUT;\n\t\t\tdelta_out[30:23] <= exponent + 8'b01111111;\n\t\t\ttheta_out <= theta_LUT;\n\t\t\ttheta_out[30:23] <= exponent + 8'b01111111;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (operation == 1'b1)\n\t\tbegin\n\t\t\ttheta_out[31] <= ~z[31];\n\t\t\tdelta_out[31] <= ~z[31];\n\t\t\ttheta_out[30:0] <= theta_LUTRot[30:0];\n\t\t\tdelta_out[30:0] <= delta_LUTRot[30:0];\n\t\t\tkappa_out <= kappa_LUTRot;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse\n\t\tbegin\n\t\t\ttheta_out <= theta_LUTVec;\n\t\t\tdelta_out <= delta_LUTVec;\n\t\t\tkappa_out <= kappa_LUTVec;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\n\tif (done_ALU == 1'b1)\n\tbegin\n\t\tdone_FSM <= 1'b0;\n\tend\n\t\n\tif (operation == 1'b1)\t\t\t\t\t\t\t\t\t\t\t\t\n\tbegin\n\t\t\n\t\tif (z[30:23] <= 8'b01110000)\n\t\tbegin\n\t\t\tconverge <= 1'b1;\n\t\t\tx_final <= x;\n\t\t\ty_final <= y;\n\t\t\tz_final <= z;\n\t\t\tk_final <= k;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b00)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tbegin\n\t\t\ttheta_out[30:0] <= z[30:0];\n\t\t\tdelta_out[30:0] <= z[30:0];\n\t\t\ttheta_out[31]\t<= ~z[31];\n\t\t\tdelta_out[31]\t<= ~z[31];\n\t\t\tkappa_out <= 32'h3F800000;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b11 && z[30:23] >= 8'b01111111)\n\t\tbegin\n\t\t\ttheta_out <= 32'hBF800000;\n\t\t\tdelta_out <= 32'hBF42F7D6;\n\t\t\tkappa_out <= 32'h3FC583AB;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b01 && z[30:23] >= 8'b01111111)\t\t\n\t\tbegin\n\t\t\ttheta_out <= 32'hBF800000;\n\t\t\tdelta_out <= 32'hBFC75923;\n\t\t\tkappa_out <= 32'h3FECE788;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\n\t\telse if (mode != 2'b00 && z[30:23] < 8'b01111111 && z[30:23] > 8'b01110011) \t\t\t\n\t\tbegin\n\t\t\taddress[7:4] <= exponent[3:0];\n\t\t\taddress[3:0] <= z[22:19];\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\t\n\t\t\n\t\telse if (mode != 2'b00 && z[30:23] <= 8'b01110011)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tbegin\n\t\t\ttheta_out[30:0] <= z[30:0];\n\t\t\tdelta_out[30:0] <= z[30:0];\n\t\t\ttheta_out[31]\t<= ~z[31];\n\t\t\tdelta_out[31]\t<= ~z[31];\n\t\t\tkappa_out <= 32'h3F800000;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\n\telse if (operation == 1'b0)\t\t\t\t\t\n\tbegin\n\t\t\n\t\tif (z[30:23] <= 8'b01110000)\n\t\tbegin\n\t\t\tconverge <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b00)\n\t\tbegin\n\t\t\taddress[7:4] <= x[22:19];\n\t\t\taddress[3:0] <= y[22:19];\n\t\t\tkappa_out <= 32'h3F8;\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode != 2'b00 && exponent > 8'b11110011 && exponent <= 8'b11111111) \t\n\t\tbegin\n\t\t\taddress[7:4] <= exponent[3:0];\n\t\t\taddress[3:2] <= x[22:21];\n\t\t\taddress[1:0] <= y[22:21];\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\t\n\t\t\n\t\telse if (mode != 2'b00 && exponent <= 8'b11110011 && exponent > 8'b10000000)\n\t\tbegin\n\t\t\taddress[7:4] <= x[22:19];\n\t\t\taddress[3:0] <= y[22:19];\n\t\t\tkappa_out <= 32'h3F8;\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b11 && exponent <= 8'b10000000)\n\t\tbegin\n\t\t\tdelta_out <= 32'h3F733333;\n\t\t\ttheta_out <= 32'h3FEA77CB;\n\t\t\tkappa_out <= 32'h3E9FDF38;\t\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\t\t\n\t\telse if (mode == 2'b01 && exponent <= 8'b10000000)\n\t\tbegin\n\t\t\tdelta_out <= 32'h3F8;\t\t\t\t\ttheta_out <= 32'h3F490FDB;\n\t\t\tkappa_out <= 32'h3FB504F4;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\nend\nendmodule\n",
        "module_name": "FSM",
        "module_hash": "aa7c0943a5c7ae661f0c573c56e41b1a",
        "dataset_index": 12505
      },
      "sky130_fd_sc_ms__o211a_4_beb01043": {
        "rtl_code": "module sky130_fd_sc_ms__o211a_4 (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    assign X = (A1 & A2 & B1 & C1 & VPWR & !VGND & VPB & !VNB);\n\nendmodule",
        "module_name": "sky130_fd_sc_ms__o211a_4",
        "module_hash": "beb01043653b1a779d0b63da01be2fc5",
        "dataset_index": 5242
      },
      "fifo_buffer_85d2a208": {
        "rtl_code": "\nmodule fifo_buffer(\n    input clock,\n    input ready,\n    input [7:0] head,\n\n    input tail_req, //RTL\n    input tail_ack,\n    input [7:0] tail_value,\n    input tail_value_valid,\n\n    input req,\n    output reg ack,\n    output reg [7:0] value,\n    output reg value_valid\n);\n\nreg [7:0] buffer [0:255];\nreg [7:0] read_pointer;\nreg [7:0] write_pointer;\nreg write_data;\nreg [7:0] write_pointer_next;\nreg [7:0] read_pointer_next;\nreg [7:0] read_data;\nreg [7:0] tail_data;\nreg [7:0] tail_pointer;\nreg [7:0] tail_pointer_next;\nreg [7:0] head_pointer;\nreg [7:0] head_pointer_next;\nreg [7:0] buffer_size;\nreg [7:0] buffer_size_next;\nreg tail_full;\nreg head_full;\nreg tail_empty;\nreg head_empty;\n\nalways @(posedge clock) begin\n\n    if (ready) begin\n\n        // Write data to the head\n        if (!head_full && head_pointer == write_pointer) begin\n            buffer[write_pointer] <= head;\n            write_pointer_next <= write_pointer + 1;\n            if (write_pointer_next == 256) begin\n                write_pointer_next <= 0;\n            end\n            head_full <= (write_pointer_next == read_pointer);\n        end else begin\n            write_pointer_next <= write_pointer;\n            head_full <= 0;\n        end\n\n        // Read data from the head\n        if (req && !head_empty && read_pointer == head_pointer) begin\n            read_data <= buffer[read_pointer];\n            read_pointer_next <= read_pointer + 1;\n            if (read_pointer_next == 256) begin\n                read_pointer_next <= 0;\n            end\n            head_empty <= (read_pointer_next == write_pointer);\n        end else begin\n            read_pointer_next <= read_pointer;\n            head_empty <= 1;\n        end\n\n        // Write data to the tail\n        if (!tail_full && tail_pointer == write_pointer && tail_req) begin\n            buffer[tail_pointer] <= tail_data;\n            tail_pointer_next <= tail_pointer - 1;\n            if (tail_pointer_next == -1) begin\n                tail_pointer_next <= 255;\n            end\n            tail_full <= (tail_pointer_next == write_pointer);\n        end else begin\n            tail_pointer_next <= tail_pointer;\n            tail_full <= 0;\n        end\n\n        // Read data from the tail\n        if (tail_value_valid && !tail_empty && tail_pointer == read_pointer) begin\n            tail_data <= tail_value;\n            tail_pointer_next <= tail_pointer - 1;\n            if (tail_pointer_next == -1) begin\n                tail_pointer_next <= 255;\n            end\n            tail_empty <= (tail_pointer_next == write_pointer);\n        end else begin\n            tail_pointer_next <= tail_pointer;\n            tail_empty <= 1;\n        end\n\n        // Update buffer size\n        if (head_pointer <= tail_pointer) begin\n            buffer_size_next <= tail_pointer - head_pointer;\n        end else begin\n            buffer_size_next <= 256 - head_pointer + tail_pointer;\n        end\n\n        // Update head pointer\n        if (!head_empty) begin\n            head_pointer_next <= read_pointer_next;\n        end else begin\n            head_pointer_next <= head_pointer;\n        end\n\n        // Update tail pointer\n        if (!tail_full && tail_req) begin\n            tail_pointer_next <= tail_pointer_next;\n        end else begin\n            tail_pointer_next <= tail_pointer;\n        end\n\n    end else begin\n        write_pointer_next <= write_pointer;\n        read_pointer_next <= read_pointer;\n        head_pointer_next <= head_pointer;\n        tail_pointer_next <= tail_pointer;\n        tail_data <= tail_data;\n        buffer_size_next <= buffer_size;\n    end\nend\n\nalways @(*) begin\n    write_pointer <= write_pointer_next;\n    read_pointer <= read_pointer_next;\n    head_pointer <= head_pointer_next;\n    tail_pointer <= tail_pointer_next;\n    buffer_size <= buffer_size_next;\n\n    if (!head_empty && head_pointer == read_pointer) begin\n        value <= read_data;\n        ack <= tail_ack ; //Fix\n        value_valid <= tail_value_valid;\n    end else begin\n        value <= 0;\n        ack <= 0;\n        value_valid <= 0;\n    end\n\nend\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "85d2a208d382058a9b0e5e68667e414d",
        "dataset_index": 14223
      },
      "antares_shifter_54fa325b": {
        "rtl_code": "module antares_shifter (\n                        input [31:0]  shift_input_data,  input [4:0]   shift_shamnt,      input         shift_direction,   input         shift_sign_extend, output [31:0] shift_result       );\n\n    reg [31:0]    input_inv;          reg [31:0]    result_shift_temp;  reg [31:0]    result_inv;         wire          sign;\n    wire [31:0]   operand;\n\n    assign sign         = (shift_sign_extend) ? shift_input_data[31] : 1'b0;\n    assign operand      = (shift_direction) ? input_inv : shift_input_data;\n    assign shift_result = (shift_direction) ? result_inv : result_shift_temp;\n\n    integer       index0;\n    integer       index1;\n    always @ (*) begin\n        for (index0 = 0; index0 < 32; index0 = index0 + 1) begin\n            input_inv[31 - index0] = shift_input_data[index0];\n        end\n    end\n    always @(*) begin\n        for (index1 = 0; index1 < 32; index1 = index1 + 1)\n          result_inv[31 - index1] = result_shift_temp[index1];\n    end\n\n    always @(*) begin\n        case(shift_shamnt)\n            5'd0    : result_shift_temp =               operand[31:0];\n            5'd1    : result_shift_temp = { {1 {sign}}, operand[31:1] };\n            5'd2    : result_shift_temp = { {2 {sign}}, operand[31:2] };\n            5'd3    : result_shift_temp = { {3 {sign}}, operand[31:3] };\n            5'd4    : result_shift_temp = { {4 {sign}}, operand[31:4] };\n            5'd5    : result_shift_temp = { {5 {sign}}, operand[31:5] };\n            5'd6    : result_shift_temp = { {6 {sign}}, operand[31:6] };\n            5'd7    : result_shift_temp = { {7 {sign}}, operand[31:7] };\n            5'd8    : result_shift_temp = { {8 {sign}}, operand[31:8] };\n            5'd9    : result_shift_temp = { {9 {sign}}, operand[31:9] };\n            5'd10   : result_shift_temp = { {10{sign}}, operand[31:10] };\n            5'd11   : result_shift_temp = { {11{sign}}, operand[31:11] };\n            5'd12   : result_shift_temp = { {12{sign}}, operand[31:12] };\n            5'd13   : result_shift_temp = { {13{sign}}, operand[31:13] };\n            5'd14   : result_shift_temp = { {14{sign}}, operand[31:14] };\n            5'd15   : result_shift_temp = { {15{sign}}, operand[31:15] };\n            5'd16   : result_shift_temp = { {16{sign}}, operand[31:16] };\n            5'd17   : result_shift_temp = { {17{sign}}, operand[31:17] };\n            5'd18   : result_shift_temp = { {18{sign}}, operand[31:18] };\n            5'd19   : result_shift_temp = { {19{sign}}, operand[31:19] };\n            5'd20   : result_shift_temp = { {20{sign}}, operand[31:20] };\n            5'd21   : result_shift_temp = { {21{sign}}, operand[31:21] };\n            5'd22   : result_shift_temp = { {22{sign}}, operand[31:22] };\n            5'd23   : result_shift_temp = { {23{sign}}, operand[31:23] };\n            5'd24   : result_shift_temp = { {24{sign}}, operand[31:24] };\n            5'd25   : result_shift_temp = { {25{sign}}, operand[31:25] };\n            5'd26   : result_shift_temp = { {26{sign}}, operand[31:26] };\n            5'd27   : result_shift_temp = { {27{sign}}, operand[31:27] };\n            5'd28   : result_shift_temp = { {28{sign}}, operand[31:28] };\n            5'd29   : result_shift_temp = { {29{sign}}, operand[31:29] };\n            5'd30   : result_shift_temp = { {30{sign}}, operand[31:30] };\n            5'd31   : result_shift_temp = { {31{sign}}, operand[31:31] };\n            default : result_shift_temp = 32'bx;\n        endcase\n    end\n\nendmodule ",
        "module_name": "antares_shifter",
        "module_hash": "54fa325b845eb42e0783001d6c2e9596",
        "dataset_index": 16892
      },
      "multiplier_block_f72fa94c": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0] o_data0;\n\n  // Multipliers:\n  wire [31:0] w1, w256, w257, w4, w32, w229, w261, w29312;\n\n  assign w1 = i_data0;\n  assign w256 = i_data0 << 8;\n  assign w257 = w1 + w256;\n  assign w4 = i_data0 << 2;\n  assign w32 = i_data0 << 5;\n  assign w261 = w257 + w4;\n  assign w229 = w261 - w32;\n  assign w29312 = w229 << 7;\n\n  assign o_data0 = w29312;\n\n  // Multiplier block area estimate = 4204.56962668382;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "f72fa94cc0415cbafbfc754e6cf46de3",
        "dataset_index": 13529
      },
      "fifo_memory_3fceec07": {
        "rtl_code": "\nmodule fifo_memory(\n    input clk,\n    input wr_en,\n    input rd_en,\n    input [7:0] data_in,\n    output reg empty,\n    output reg full,\n    output reg [7:0] data_out\n);\n\n    parameter SIZE = 8;\n    reg [7:0] memory [SIZE-1:0];\n    reg [2:0] head, tail;\n    reg [2:0] next_tail;\n    reg [2:0] next_head;\n    \n    always @(posedge clk) begin\n        if(wr_en && !full) begin\n            memory[tail] <= data_in;\n            tail <= next_tail;\n        end\n    end\n    \n    always @(posedge clk) begin\n        if(rd_en && !empty) begin\n            data_out <= memory[head];\n            head <= next_head;\n        end\n    end\n    \n    always @(*) begin\n        next_tail = (tail + 1) % SIZE;\n        next_head = (head + 1) % SIZE;\n        empty = (head == tail) ? 1'b1 : 1'b0;\n        full = ((next_tail == head) && (head != tail)) ? 1'b1 : 1'b0;\n    end\n    \nendmodule",
        "module_name": "fifo_memory",
        "module_hash": "3fceec0782bfc673075cad22cd005161",
        "dataset_index": 11076
      },
      "sky130_fd_sc_hs__dlygate4sd2_4ec31e05": {
        "rtl_code": "module sky130_fd_sc_hs__dlygate4sd2 (\n    input A,\n    input VPWR,\n    input VGND,\n    output reg X\n);\n\nreg [3:0] delay_count;\n\nalways @(posedge VPWR or negedge VGND)\nbegin\n    if (VGND == 1'b0)\n        X <= 1'b0;\n    else if (A == 1'b1)\n    begin\n        delay_count <= 4'b1111;\n        X <= 1'b0;\n    end\n    else if (delay_count != 0)\n        delay_count <= delay_count - 1;\n    else\n        X <= 1'b1;\nend\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__dlygate4sd2",
        "module_hash": "4ec31e05937963a84f79c85e5d22c335",
        "dataset_index": 3692
      },
      "RIPPLE_CARRY_ADDER_04093841": {
        "rtl_code": "module RIPPLE_CARRY_ADDER (\ninput wire [3:0] wA,\ninput wire [3:0] wB,\ninput wire wCi,\noutput wire [3:0] wR,\noutput wire wCo\n);\n\nwire [3:0] c;\n\nFULL_ADDER fa0(wA[0], wB[0], wCi, wR[0], c[0]);\nFULL_ADDER fa1(wA[1], wB[1], c[0], wR[1], c[1]);\nFULL_ADDER fa2(wA[2], wB[2], c[1], wR[2], c[2]);\nFULL_ADDER fa3(wA[3], wB[3], c[2], wR[3], wCo);\n\nendmodule\n\nmodule FULL_ADDER (\ninput wire  wA,wB,wCi,\noutput wire  wR ,\noutput wire wCo\n);\n\nassign {wCo,wR} = wA + wB + wCi;\nendmodule",
        "module_name": "RIPPLE_CARRY_ADDER",
        "module_hash": "04093841b7e6da69ccd3788819c782e6",
        "dataset_index": 1879
      },
      "mig_7series_v2_0_bank_compare #_dc16eee6": {
        "rtl_code": "\n\nmodule mig_7series_v2_0_bank_compare #\n  (parameter BANK_WIDTH               = 3,\n   parameter TCQ = 100,\n   parameter BURST_MODE               = \"8\",\n   parameter COL_WIDTH                = 12,\n   parameter DATA_BUF_ADDR_WIDTH      = 8,\n   parameter ECC                      = \"OFF\",\n   parameter RANK_WIDTH               = 2,\n   parameter RANKS                    = 4,\n   parameter ROW_WIDTH                = 16)\n  (\n  req_data_buf_addr_r, req_periodic_rd_r, req_size_r, rd_wr_r,\n  req_rank_r, req_bank_r, req_row_r, req_wr_r, req_priority_r,\n  rb_hit_busy_r, rb_hit_busy_ns, row_hit_r, maint_hit, col_addr,\n  req_ras, req_cas, row_cmd_wr, row_addr, rank_busy_r,\n  clk, idle_ns, idle_r, data_buf_addr, periodic_rd_insert, size, cmd,\n  sending_col, rank, periodic_rd_rank_r, bank, row, col, hi_priority,\n  maint_rank_r, maint_zq_r, maint_sre_r, auto_pre_r, rd_half_rmw, act_wait_r\n  );\n\n  input clk;\n\n  input idle_ns;\n  input idle_r;\n\n  input [DATA_BUF_ADDR_WIDTH-1:0]data_buf_addr;\n  output reg [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_r;\n  wire [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_ns =\n                                   idle_r\n                                     ? data_buf_addr\n                                     : req_data_buf_addr_r;\n  always @(posedge clk) req_data_buf_addr_r <= #TCQ req_data_buf_addr_ns;\n\n  input periodic_rd_insert;\n\n  reg req_periodic_rd_r_lcl;\n  wire req_periodic_rd_ns = idle_ns\n                             ? periodic_rd_insert\n                             : req_periodic_rd_r_lcl;\n  always @(posedge clk) req_periodic_rd_r_lcl <= #TCQ req_periodic_rd_ns;\n  output wire req_periodic_rd_r;\n  assign req_periodic_rd_r = req_periodic_rd_r_lcl;\n\n  input size;\n  wire req_size_r_lcl;\n  generate\n    if (BURST_MODE == \"4\") begin : burst_mode_4\n      assign req_size_r_lcl = 1'b0;\n    end\n    else\n      if (BURST_MODE == \"8\") begin : burst_mode_8\n        assign req_size_r_lcl = 1'b1;\n      end\n      else\n        if (BURST_MODE == \"OTF\") begin : burst_mode_otf\n          reg req_size;\n          wire req_size_ns = idle_ns\n                                 ? (periodic_rd_insert || size)\n                                 : req_size;\n          always @(posedge clk) req_size <= #TCQ req_size_ns;\n          assign req_size_r_lcl = req_size;\n        end\n  endgenerate\n  output wire req_size_r;\n  assign req_size_r = req_size_r_lcl;\n\n\n\n  input [2:0] cmd;\n  reg [2:0] req_cmd_r;\n  wire [2:0] req_cmd_ns = idle_ns\n                            ? (periodic_rd_insert ? 3'b001 : cmd)\n                            : req_cmd_r;\n   \n  always @(posedge clk) req_cmd_r <= #TCQ req_cmd_ns;\n\n`ifdef MC_SVA\n  rd_wr_only_wo_ecc: assert property\n    (@(posedge clk) ((ECC != \"OFF\") || idle_ns || ~|req_cmd_ns[2:1]));\n`endif\n  \n  input sending_col;\n  reg rd_wr_r_lcl;\n  wire rd_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || req_cmd_ns[0])\n                    : ~sending_col && rd_wr_r_lcl;\n  always @(posedge clk) rd_wr_r_lcl <= #TCQ rd_wr_ns;\n  output wire rd_wr_r;\n  assign rd_wr_r = rd_wr_r_lcl;\n\n  input [RANK_WIDTH-1:0] rank;\n  input [RANK_WIDTH-1:0] periodic_rd_rank_r;\n  reg [RANK_WIDTH-1:0] req_rank_r_lcl = {RANK_WIDTH{1'b0}};\n  reg [RANK_WIDTH-1:0] req_rank_ns = {RANK_WIDTH{1'b0}};\n  generate\n    if (RANKS != 1) begin\n      always @(idle_ns or periodic_rd_insert\n               or periodic_rd_rank_r or rank or req_rank_r_lcl) req_rank_ns = idle_ns\n                                  ? periodic_rd_insert\n                                      ? periodic_rd_rank_r\n                                      : rank\n                                  : req_rank_r_lcl;\n      always @(posedge clk) req_rank_r_lcl <= #TCQ req_rank_ns;\n    end\n  endgenerate\n  output wire [RANK_WIDTH-1:0] req_rank_r;\n  assign req_rank_r = req_rank_r_lcl;\n\n  input [BANK_WIDTH-1:0] bank;\n  reg [BANK_WIDTH-1:0] req_bank_r_lcl;\n  wire [BANK_WIDTH-1:0] req_bank_ns = idle_ns ? bank : req_bank_r_lcl;\n  always @(posedge clk) req_bank_r_lcl <= #TCQ req_bank_ns;\n  output wire[BANK_WIDTH-1:0] req_bank_r;\n  assign req_bank_r = req_bank_r_lcl;\n\n  input [ROW_WIDTH-1:0] row;\n  reg [ROW_WIDTH-1:0] req_row_r_lcl;\n  wire [ROW_WIDTH-1:0] req_row_ns = idle_ns ? row : req_row_r_lcl;\n  always @(posedge clk) req_row_r_lcl <= #TCQ req_row_ns;\n  output wire [ROW_WIDTH-1:0] req_row_r;\n  assign req_row_r = req_row_r_lcl;\n\n  input [COL_WIDTH-1:0] col;\n  reg [15:0] req_col_r = 16'b0;\n  wire [COL_WIDTH-1:0] req_col_ns = idle_ns ? col : req_col_r[COL_WIDTH-1:0];\n  always @(posedge clk) req_col_r[COL_WIDTH-1:0] <= #TCQ req_col_ns;\n\n  reg req_wr_r_lcl;\n  wire req_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || ~req_cmd_ns[0])\n                    : req_wr_r_lcl;\n  always @(posedge clk) req_wr_r_lcl <= #TCQ req_wr_ns;\n  output wire req_wr_r;\n  assign req_wr_r = req_wr_r_lcl;\n\n  input hi_priority;\n  output reg req_priority_r;\n  wire req_priority_ns = idle_ns ? hi_priority : req_priority_r;\n  always @(posedge clk) req_priority_r <= #TCQ req_priority_ns;\n\n  wire rank_hit = (req_rank_r_lcl == (periodic_rd_insert\n                                       ? periodic_rd_rank_r\n                                       : rank));\n  wire bank_hit = (req_bank_r_lcl == bank);\n  wire rank_bank_hit = rank_hit && bank_hit;\n\n  output reg rb_hit_busy_r;       wire  rb_hit_busy_ns_lcl;\n  assign rb_hit_busy_ns_lcl = rank_bank_hit && ~idle_ns;\n  output wire  rb_hit_busy_ns;\n  assign rb_hit_busy_ns = rb_hit_busy_ns_lcl;\n\n  wire row_hit_ns = (req_row_r_lcl == row);\n  output reg row_hit_r;\n\n  always @(posedge clk) rb_hit_busy_r <= #TCQ rb_hit_busy_ns_lcl;\n  always @(posedge clk) row_hit_r <= #TCQ row_hit_ns;\n\n  input [RANK_WIDTH-1:0] maint_rank_r;\n  input maint_zq_r;\n  input maint_sre_r;\n  output wire maint_hit;\n  assign maint_hit = (req_rank_r_lcl == maint_rank_r) || maint_zq_r || maint_sre_r;\n\ninput auto_pre_r;\n  input rd_half_rmw;\n  reg [15:0] col_addr_template = 16'b0;\n  always @(auto_pre_r or rd_half_rmw or req_col_r\n           or req_size_r_lcl) begin\n    col_addr_template = req_col_r;\n    col_addr_template[10] = auto_pre_r && ~rd_half_rmw;\n    col_addr_template[11] = req_col_r[10];\n    col_addr_template[12] = req_size_r_lcl;\n    col_addr_template[13] = req_col_r[11];\n  end\n  output wire [ROW_WIDTH-1:0] col_addr;\n  assign col_addr = col_addr_template[ROW_WIDTH-1:0];\n\n  output wire req_ras;\n  output wire req_cas;\n  output wire row_cmd_wr;\n  input act_wait_r;\n  assign req_ras = 1'b0;\n  assign req_cas = 1'b1;\n  assign row_cmd_wr = act_wait_r;\n\n  output reg [ROW_WIDTH-1:0] row_addr;\n  always @(act_wait_r or req_row_r_lcl) begin\n    row_addr = req_row_r_lcl;\nif (~act_wait_r) row_addr[10] = 1'b0;\n  end\n\nlocalparam ONE = 1;\n  output reg [RANKS-1:0] rank_busy_r;\n  wire [RANKS-1:0] rank_busy_ns = {RANKS{~idle_ns}} & (ONE[RANKS-1:0] << req_rank_ns);\n  always @(posedge clk) rank_busy_r <= #TCQ rank_busy_ns;\n\nendmodule ",
        "module_name": "mig_7series_v2_0_bank_compare #",
        "module_hash": "dc16eee6a9641473051ddd26d9ccddbe",
        "dataset_index": 22238
      },
      "and_gate_c1a945cf": {
        "rtl_code": "module and_gate (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    assign Y = (A & B & C);\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "c1a945cf0617d22e13ef1606644d468d",
        "dataset_index": 543
      },
      "touch_sensor_bd165690": {
        "rtl_code": "\nmodule touch_sensor (\n  input wire touch_in,\n  output reg touch_out\n);\n\n  reg touch_detected;\n\n  always @(posedge touch_in) begin\n    touch_detected <= #1 touch_in;  // Delay the assignment by 1 time unit to avoid multiple edge sensitive events\n  end\n\n  always @(*) begin\n    touch_out = touch_detected;\n  end\n\nendmodule",
        "module_name": "touch_sensor",
        "module_hash": "bd165690e20fed3b64b39785764f3eb8",
        "dataset_index": 10887
      },
      "sky130_fd_sc_hd__or4b_f0d70516": {
        "rtl_code": "module sky130_fd_sc_hd__or4b (\n    input A,\n    input B,\n    input C,\n    input D_N,\n    output X\n);\n\n    assign X = ~(A & B & C & D_N);\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__or4b",
        "module_hash": "f0d7051655a81723178f8d111c08ce1f",
        "dataset_index": 5018
      },
      "robotic_arm_controller_edd23895": {
        "rtl_code": "module robotic_arm_controller(\n    input [7:0] servo1_angle,\n    input [7:0] servo2_angle,\n    input [7:0] servo3_angle,\n    input [7:0] servo4_angle,\n    input [7:0] servo5_angle,\n    output reg [11:0] servo1_pwm,\n    output reg [11:0] servo2_pwm,\n    output reg [11:0] servo3_pwm,\n    output reg [11:0] servo4_pwm,\n    output reg [11:0] servo5_pwm\n);\n\n    always @(*) begin\n        servo1_pwm = (servo1_angle * 11) + 500;\n        servo2_pwm = (servo2_angle * 11) + 500;\n        servo3_pwm = (servo3_angle * 11) + 500;\n        servo4_pwm = (servo4_angle * 11) + 500;\n        servo5_pwm = (servo5_angle * 11) + 500;\n    end\n\nendmodule",
        "module_name": "robotic_arm_controller",
        "module_hash": "edd238951b7d7fad8dfaf694abd16da4",
        "dataset_index": 2834
      },
      "full_adder_5f35ee9d": {
        "rtl_code": "module full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    \n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule\n\nmodule adder4(A, B, S, Cout);\n    input [3:0] A, B;\n    output [3:0] S;\n    output Cout;\n    \n    wire C1, C2, C3;\n    full_adder FA1(A[0], B[0], 1'b0, S[0], C1);\n    full_adder FA2(A[1], B[1], C1, S[1], C2);\n    full_adder FA3(A[2], B[2], C2, S[2], C3);\n    full_adder FA4(A[3], B[3], C3, S[3], Cout);\nendmodule",
        "module_name": "full_adder",
        "module_hash": "5f35ee9dbcf8d92cd280706c26abfddf",
        "dataset_index": 2103
      },
      "decode38_c1e3e73d": {
        "rtl_code": "\n\nmodule decode38(en, din, dout);\n    input en;\n    input [2:0] din;\n    output reg [7:0] dout;\n    \n    always @(*) begin\n        if (~en) begin\n            dout <= 8'b0;\n        end else begin\n            dout <= 8'b1 << din;\n        end\n    end\nendmodule\n\nmodule regxb(nrst, clk, en, din, regout);\n    parameter bits = 1;\n    input nrst;\n    input clk;\n    input en;\n    input [bits-1:0] din;\n    output reg [bits-1:0] regout;\n    \n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            regout <= 0;\n        end else if (en) begin\n            regout <= din;\n        end\n    end\nendmodule\n\nmodule dso_regw(nrst, clk, addr, din, we, sel,\n    reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7);\n    \n    input nrst;\n    input clk;\n    input [2:0] addr;\n    input [7:0] din;\n    input we;\n    output [7:0] sel;\n    output [7:0] reg0;\n    output [7:0] reg1;\n    output [7:0] reg2;\n    output [7:0] reg3;\n    output [7:0] reg4;\n    output [7:0] reg5;\n    output [7:0] reg6;\n    output [7:0] reg7;\n    wire [7:0] addr_dec;\n    \n    decode38 dec(.en(we), .din(addr), .dout(addr_dec));\n    assign sel = addr_dec;\n    \n    regxb #(8) r0(.nrst(nrst), .clk(clk), .en(addr_dec[0]), .din(din), .regout(reg0));\n    regxb #(8) r1(.nrst(nrst), .clk(clk), .en(addr_dec[1]), .din(din), .regout(reg1));\n    regxb #(8) r2(.nrst(nrst), .clk(clk), .en(addr_dec[2]), .din(din), .regout(reg2));\n    regxb #(8) r3(.nrst(nrst), .clk(clk), .en(addr_dec[3]), .din(din), .regout(reg3));\n    regxb #(8) r4(.nrst(nrst), .clk(clk), .en(addr_dec[4]), .din(din), .regout(reg4));\n    regxb #(8) r5(.nrst(nrst), .clk(clk), .en(addr_dec[5]), .din(din), .regout(reg5));\n    regxb #(8) r6(.nrst(nrst), .clk(clk), .en(addr_dec[6]), .din(din), .regout(reg6));\n    regxb #(8) r7(.nrst(nrst), .clk(clk), .en(addr_dec[7]), .din(din), .regout(reg7));\nendmodule\n\nmodule dso_regr(addr, dout, \n    reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7);\n    \n    input [2:0] addr;\n    output reg [7:0] dout;\n    input [7:0] reg0;\n    input [7:0] reg1;\n    input [7:0] reg2;\n    input [7:0] reg3;\n    input [7:0] reg4;\n    input [7:0] reg5;\n    input [7:0] reg6;\n    input [7:0] reg7;\n    \n    always @(*) begin\n        case (addr)\n        3'h0: dout <= reg0;\n        3'h1: dout <= reg1;\n        3'h2: dout <= reg2;\n        3'h3: dout <= reg3;\n        3'h4: dout <= reg4;\n        3'h5: dout <= reg5;\n        3'h6: dout <= reg6;\n        3'h7: dout <= reg7;\n        default: dout <= 8'b0;\n        endcase\n    end\nendmodule\n",
        "module_name": "decode38",
        "module_hash": "c1e3e73dd8eccb635bb6a36ab7a3baec",
        "dataset_index": 20116
      },
      "async_reset_release_114f8a29": {
        "rtl_code": "module async_reset_release (\n  input rst,\n  input clk,\n  input enable,\n  output reg rst_release\n);\n\nparameter delay_count = 10;\n\nreg [7:0] delay_counter;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    rst_release <= 0;\n    delay_counter <= 0;\n  end else if (enable) begin\n    if (delay_counter < delay_count) begin\n      delay_counter <= delay_counter + 1;\n    end else begin\n      rst_release <= 1;\n    end\n  end\nend\n\nendmodule",
        "module_name": "async_reset_release",
        "module_hash": "114f8a2904a214b87cea9fbfcfab7356",
        "dataset_index": 5151
      },
      "priority_encoder_0a46cd30": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] in,\n    output [3:0] pos\n);\n\n// Assign the position of the highest priority input to 'pos'\nassign pos = (in[0] ? 3'b000 :\n            in[1] ? 3'b001 :\n            in[2] ? 3'b010 :\n            in[3] ? 3'b011 :\n            in[4] ? 3'b100 :\n            in[5] ? 3'b101 :\n            in[6] ? 3'b110 : 3'b111);\n\nendmodule\n\nmodule subtractor (\n    input [3:0] in,\n    output [3:0] out\n);\n\n// Subtract 4'b0101 from the input\nassign out = in - 4'b0101;\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    output [3:0] out\n);\n\nwire [3:0] pos;\npriority_encoder pe(\n    .in(in),\n    .pos(pos)\n);\n\nsubtractor sub(\n    .in(pos),\n    .out(out)\n);\n\nendmodule\n",
        "module_name": "priority_encoder",
        "module_hash": "0a46cd30575efc930cab22dce17ab2e0",
        "dataset_index": 1659
      },
      "adder_16bit_signed_unsigned_9b57df62": {
        "rtl_code": "module adder_16bit_signed_unsigned (\n    input signed [15:0] a,\n    input signed [15:0] b,\n    input cin,\n    output signed [15:0] sum,\n    output cout\n);\n    wire [15:0] unsigned_sum;\n    wire unsigned_cout;\n\n    assign unsigned_sum = a + b + cin;\n    assign cout = (a[15] & b[15]) | ((a[15] | b[15]) & ~unsigned_sum[15]);\n    assign sum = (a[15] == b[15]) ? unsigned_sum : (a > b) ? a + b : b + a;\n\nendmodule",
        "module_name": "adder_16bit_signed_unsigned",
        "module_hash": "9b57df625e2cb305120c9e9745ca63ab",
        "dataset_index": 17043
      },
      "up_down_counter_26499a16": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input clear,\n    input load,\n    input up_down,\n    input [3:0] data,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk) begin\n        if (clear) begin\n            count <= 4'b0;\n        end else if (load) begin\n            count <= data;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "26499a16e6ffe838c0ac997bc25ab9c0",
        "dataset_index": 17536
      },
      "nukv_Read #_4997784c": {
        "rtl_code": "\nmodule nukv_Read #(\n\tparameter KEY_WIDTH = 128,\n\tparameter META_WIDTH = 96,\n\tparameter HASHADDR_WIDTH = 32,\n    parameter MEMADDR_WIDTH = 20\n\t)\n    (\n\t// Clock\n\tinput wire         clk,\n\tinput wire         rst,\n\n\tinput  wire [KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:0] input_data,\n\tinput  wire         input_valid,\n\toutput wire         input_ready,\n\n\tinput  wire [KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:0] feedback_data,\n\tinput  wire         feedback_valid,\n\toutput wire         feedback_ready,\n\n\toutput reg [KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:0] output_data,\n\toutput reg         output_valid,\n\tinput  wire         output_ready,\n\n\toutput reg [31:0] rdcmd_data,\n\toutput reg         rdcmd_valid,\n\tinput  wire         rdcmd_ready,\n\n\tinput  wire [31:0] mem_data,\n\toutput reg         mem_valid\n);\n\n    reg selectInputNext;\n    reg selectInput; //1 == input, 0==feedback\n\n\tlocalparam [2:0]\n\t\tST_IDLE   = 0,\n\t\tST_ISSUE_READ = 3,\n\t\tST_OUTPUT_KEY  = 4;\n\treg [2:0] state;    \n\n    wire[HASHADDR_WIDTH+KEY_WIDTH+META_WIDTH-1:0] in_data;\n    wire in_valid;\n    reg in_ready;\n    wire[31:0] hash_data;\n\n\n    assign in_data = (selectInput==1) ? input_data : feedback_data;\n    assign in_valid = (selectInput==1) ? input_valid : feedback_valid;\n    assign input_ready = (selectInput==1) ? in_ready : 0;\n    assign feedback_ready = (selectInput==1) ? 0 : in_ready;\n\n    assign hash_data = (selectInput==1) ? input_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH] : feedback_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH];    \n\n    wire[MEMADDR_WIDTH-1:0] addr;    \n\n    assign addr = hash_data[31:32 - MEMADDR_WIDTH] ^ hash_data[MEMADDR_WIDTH-1:0];\n\n    reg [7:0] cache [0:31];\n\n    always @(posedge clk) begin\n    \tif (rst) begin\n    \t\tselectInput <= 1;\n    \t\tselectInputNext <= 0;    \t\t\n    \t\tstate <= ST_IDLE;\n    \t\tin_ready <= 0;\n    \t\trdcmd_valid <= 0;\n    \t\toutput_valid <= 0;\n            mem_valid <= 0;\n    \tend\n    \telse begin\n\n    \t\tif (rdcmd_ready==1 && rdcmd_valid==1) begin\n    \t\t\trdcmd_valid <= 0;\n    \t\tend\n\n    \t\tif (output_ready==1 && output_valid==1) begin\n    \t\t\toutput_valid <= 0;\n    \t\tend\n\n            in_ready <= 0;\n\n\n    \t\tcase (state)    \t\t\n    \t\t\tST_IDLE : begin\n    \t\t\t\tif (output_ready==1 && rdcmd_ready==1) begin\n    \t\t\t\t\tselectInput <= selectInputNext;\n    \t\t\t\t\tselectInputNext <= ~selectInputNext;\n\n    \t\t\t\t\tif (selectInputNext==1 && input_valid==0 && feedback_valid==1) begin\n    \t\t\t\t\t\tselectInput <= 0;\n    \t\t\t\t\t\tselectInputNext <= 1;    \t\t\t\t\t\t\n    \t\t\t\t\tend\n\n    \t\t\t\t\tif (selectInputNext==0 && input_valid==1 && feedback_valid==0) begin\n    \t\t\t\t\t\tselectInput <= 1;\n    \t\t\t\t\t\tselectInputNext <= 0;    \t\t\t\t\t\t\n    \t\t\t\t\tend\n\n    \t\t\t\t\tif (selectInput==1 && input_valid==1) begin\n    \t\t\t\t\t\tstate <= ST_ISSUE_READ;    \t\t\t\t\t\t\n    \t\t\t\t\tend\n\n\t\t\t\t\t\tif (selectInput==0 && feedback_valid==1) begin\n    \t\t\t\t\t\tstate <= ST_ISSUE_READ;    \t\t\t\t\t\t\n    \t\t\t\t\tend    \t\t\t\t\t\n\n    \t\t\t\tend\n    \t\t\tend\n\n    \t\t\tST_ISSUE_READ: begin    \t\t\t\n                    if (in_data[KEY_WIDTH+META_WIDTH-4]==1) begin\n                        // ignore this and don't send read!\n\n                    end else begin\t\t\t                        \n                        if (cache[addr[4:0]] == mem_data) begin\n                            // data is present in cache\n                            output_data <= cache[addr[4:0]];\n                            output_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH] <= addr;\n                            output_valid <= 1;\n                            mem_valid <= 0;\n                        end else begin\n                            // data is not present in cache\n            \t\t\t\trdcmd_data <= addr;\n            \t\t\t\trdcmd_valid <= 1;\n                            rdcmd_data[31:MEMADDR_WIDTH] <= 0;\n            \t\t\t\tstate <= ST_OUTPUT_KEY;                      \n                            in_ready <= 1;\n                        end\n                    end\n    \t\t\tend\n\n    \t\t\tST_OUTPUT_KEY: begin\n    \t\t\t\tif (output_ready==1) begin\n                        cache[addr[4:0]] <= mem_data;\n                        output_data <= mem_data;\n                        output_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH] <= addr;\n                        output_valid <= 1;\n                        mem_valid <= 0;\n                        state <= ST_IDLE;\n    \t\t\t\tend\n    \t\t\tend\n\n\n    \t\tendcase\n    \tend\n    end\n        \nendmodule",
        "module_name": "nukv_Read #",
        "module_hash": "4997784c4c01adcf26547b286f90d884",
        "dataset_index": 12820
      },
      "uart_light_tx_ctrl_20f797f5": {
        "rtl_code": "module uart_light_tx_ctrl\n#(\n\tparameter STATE_COUNT = 2,\n\tparameter IDLE = 2'b00,\n\tparameter LOAD = 2'b01,\n\tparameter TRANSMITTING = 2'b10\n)(\n\tinput  wire reset,\n\tinput  wire clk_tx,\n\n\t//Interfaces zum SPMC\n\tinput  wire word_ready,\n\toutput wire fifo_tx_full,\n\toutput wire fifo_tx_empty,\n\t\n\t//Interfaces zum Datenpfad-Module, welche durch clk_tx getrieben werden\n\tinput  wire frame_done,\n\toutput reg  transmit,\n\toutput reg  clear,\n\toutput reg  fifo_read_enable,\n\t\n\t//Interfaces zum Datenpfad-Module, welche durch clk_peri getrieben werden\n\tinput wire  fifo_full,\n\tinput wire  fifo_empty,\n\toutput wire fifo_write_enable\n\n    );\n\n\treg [STATE_COUNT-1:0] state_cur, state_next;\n\t\n\tassign fifo_tx_full      = fifo_full;\n\tassign fifo_tx_empty     = fifo_empty;\n \tassign fifo_write_enable = word_ready & (~fifo_full);\n\t\n\talways @(*) begin\n\t\ttransmit         = 1'b0;\n\t\tclear            = 1'b0;\n\t\tfifo_read_enable = 1'b0;\n\t\tstate_next       = IDLE;\n\t\t\n\t\tcase(state_cur)\n\t\t\tIDLE:\n\t\t\t\tif (fifo_empty == 1'b0) begin\n\t\t\t\t\tstate_next       = LOAD;\n\t\t\t\tend\n\t\t\tLOAD:\n\t\t\t\tbegin\n\t\t\t\t\tfifo_read_enable = 1'b1;\n\t\t\t\t\tstate_next\t = TRANSMITTING;\n\t\t\t\tend\n\t\t\tTRANSMITTING:\n\t\t\t\tif(frame_done) begin\n\t\t\t\t\tclear      = 1'b1;\n\t\t\t\t\tstate_next = IDLE;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\ttransmit   = 1'b1;\n\t\t\t\t\tstate_next = TRANSMITTING;\n\t\t\t\tend\n\t\t\tdefault: state_next = IDLE;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk_tx, posedge reset) begin\n\t\tif(reset) begin\n\t\t\tstate_cur <= IDLE;\n\t\tend\n\t\telse begin \n\t\t\tstate_cur <= state_next;\n\t\tend\n\tend\n\t\nendmodule",
        "module_name": "uart_light_tx_ctrl",
        "module_hash": "20f797f5a6138268438dfc7759441921",
        "dataset_index": 1088
      },
      "mkSoC_Map_4feb9d06": {
        "rtl_code": "`ifdef BSV_ASSIGNMENT_DELAY\n`else\n  `define BSV_ASSIGNMENT_DELAY\n`endif\n\n`ifdef BSV_POSITIVE_RESET\n  `define BSV_RESET_VALUE 1'b1\n  `define BSV_RESET_EDGE posedge\n`else\n  `define BSV_RESET_VALUE 1'b0\n  `define BSV_RESET_EDGE negedge\n`endif\n\nmodule mkSoC_Map(CLK,\n\t\t RST_N,\n\n\t\t m_near_mem_io_addr_base,\n\n\t\t m_near_mem_io_addr_size,\n\n\t\t m_near_mem_io_addr_lim,\n\n\t\t m_plic_addr_base,\n\n\t\t m_plic_addr_size,\n\n\t\t m_plic_addr_lim,\n\n\t\t m_uart0_addr_base,\n\n\t\t m_uart0_addr_size,\n\n\t\t m_uart0_addr_lim,\n\n\t\t m_boot_rom_addr_base,\n\n\t\t m_boot_rom_addr_size,\n\n\t\t m_boot_rom_addr_lim,\n\n\t\t m_mem0_controller_addr_base,\n\n\t\t m_mem0_controller_addr_size,\n\n\t\t m_mem0_controller_addr_lim,\n\n\t\t m_tcm_addr_base,\n\n\t\t m_tcm_addr_size,\n\n\t\t m_tcm_addr_lim,\n\n\t\t m_is_mem_addr_addr,\n\t\t m_is_mem_addr,\n\n\t\t m_is_IO_addr_addr,\n\t\t m_is_IO_addr,\n\n\t\t m_is_near_mem_IO_addr_addr,\n\t\t m_is_near_mem_IO_addr,\n\n\t\t m_pc_reset_value,\n\n\t\t m_mtvec_reset_value,\n\n\t\t m_nmivec_reset_value);\n  input  CLK;\n  input  RST_N;\n\n  output [63 : 0] m_near_mem_io_addr_base;\n\n  output [63 : 0] m_near_mem_io_addr_size;\n\n  output [63 : 0] m_near_mem_io_addr_lim;\n\n  output [63 : 0] m_plic_addr_base;\n\n  output [63 : 0] m_plic_addr_size;\n\n  output [63 : 0] m_plic_addr_lim;\n\n  output [63 : 0] m_uart0_addr_base;\n\n  output [63 : 0] m_uart0_addr_size;\n\n  output [63 : 0] m_uart0_addr_lim;\n\n  output [63 : 0] m_boot_rom_addr_base;\n\n  output [63 : 0] m_boot_rom_addr_size;\n\n  output [63 : 0] m_boot_rom_addr_lim;\n\n  output [63 : 0] m_mem0_controller_addr_base;\n\n  output [63 : 0] m_mem0_controller_addr_size;\n\n  output [63 : 0] m_mem0_controller_addr_lim;\n\n  output [63 : 0] m_tcm_addr_base;\n\n  output [63 : 0] m_tcm_addr_size;\n\n  output [63 : 0] m_tcm_addr_lim;\n\n  input  [63 : 0] m_is_mem_addr_addr;\n  output m_is_mem_addr;\n\n  input  [63 : 0] m_is_IO_addr_addr;\n  output m_is_IO_addr;\n\n  input  [63 : 0] m_is_near_mem_IO_addr_addr;\n  output m_is_near_mem_IO_addr;\n\n  output [63 : 0] m_pc_reset_value;\n\n  output [63 : 0] m_mtvec_reset_value;\n\n  output [63 : 0] m_nmivec_reset_value;\n\n  wire [63 : 0] m_boot_rom_addr_base,\n\t\tm_boot_rom_addr_lim,\n\t\tm_boot_rom_addr_size,\n\t\tm_mem0_controller_addr_base,\n\t\tm_mem0_controller_addr_lim,\n\t\tm_mem0_controller_addr_size,\n\t\tm_mtvec_reset_value,\n\t\tm_near_mem_io_addr_base,\n\t\tm_near_mem_io_addr_lim,\n\t\tm_near_mem_io_addr_size,\n\t\tm_nmivec_reset_value,\n\t\tm_pc_reset_value,\n\t\tm_plic_addr_base,\n\t\tm_plic_addr_lim,\n\t\tm_plic_addr_size,\n\t\tm_tcm_addr_base,\n\t\tm_tcm_addr_lim,\n\t\tm_tcm_addr_size,\n\t\tm_uart0_addr_base,\n\t\tm_uart0_addr_lim,\n\t\tm_uart0_addr_size;\n  wire m_is_IO_addr, m_is_mem_addr, m_is_near_mem_IO_addr;\n\n  assign m_near_mem_io_addr_base = 64'h0000000002000000 ;\n\n  assign m_near_mem_io_addr_size = 64'h000000000000C000 ;\n\n  assign m_near_mem_io_addr_lim = 64'd33603584 ;\n\n  assign m_plic_addr_base = 64'h000000000C000000 ;\n\n  assign m_plic_addr_size = 64'h0000000000400000 ;\n\n  assign m_plic_addr_lim = 64'd205520896 ;\n\n  assign m_uart0_addr_base = 64'h00000000C0000000 ;\n\n  assign m_uart0_addr_size = 64'h0000000000000080 ;\n\n  assign m_uart0_addr_lim = 64'h00000000C0000080 ;\n\n  assign m_boot_rom_addr_base = 64'h0000000000001000 ;\n\n  assign m_boot_rom_addr_size = 64'h0000000000001000 ;\n\n  assign m_boot_rom_addr_lim = 64'd8192 ;\n\n  assign m_mem0_controller_addr_base = 64'h0000000080000000 ;\n\n  assign m_mem0_controller_addr_size = 64'h0000000010000000 ;\n\n  assign m_mem0_controller_addr_lim = 64'h0000000090000000 ;\n\n  assign m_tcm_addr_base = 64'h0 ;\n\n  assign m_tcm_addr_size = 64'd0 ;\n\n  assign m_tcm_addr_lim = 64'd0 ;\n\n  assign m_is_mem_addr =\n\t     m_is_mem_addr_addr >= 64'h0000000000001000 &&\n\t     m_is_mem_addr_addr < 64'd8192 ||\n\t     m_is_mem_addr_addr >= 64'h0000000080000000 &&\n\t     m_is_mem_addr_addr < 64'h0000000090000000 ;\n\n  assign m_is_IO_addr =\n\t     m_is_IO_addr_addr >= 64'h0000000002000000 &&\n\t     m_is_IO_addr_addr < 64'd33603584 ||\n\t     m_is_IO_addr_addr >= 64'h000000000C000000 &&\n\t     m_is_IO_addr_addr < 64'd205520896 ||\n\t     m_is_IO_addr_addr >= 64'h00000000C0000000 &&\n\t     m_is_IO_addr_addr < 64'h00000000C0000080 ;\n\n  assign m_is_near_mem_IO_addr =\n\t     m_is_near_mem_IO_addr_addr >= 64'h0000000002000000 &&\n\t     m_is_near_mem_IO_addr_addr < 64'd33603584 ;\n\n  assign m_pc_reset_value = 64'h0000000000001000 ;\n\n  assign m_mtvec_reset_value = 64'h0000000000001000 ;\n\n  assign m_nmivec_reset_value = 64'hAAAAAAAAAAAAAAAA ;\nendmodule  ",
        "module_name": "mkSoC_Map",
        "module_hash": "4feb9d06ec791f06e6dd3fde2488b850",
        "dataset_index": 24097
      },
      "and_en_cd74722e": {
        "rtl_code": "module and_en(\n    input [2:0] a, b, c,\n    input en,\n    output y\n);\n\n    wire [2:0] and_result;\n    assign and_result = a & b & c;\n    \n    assign y = en ? and_result[0] & and_result[1] & and_result[2] : 1'b0;\n\nendmodule",
        "module_name": "and_en",
        "module_hash": "cd74722e0b30ad66d2401226b8dd6b94",
        "dataset_index": 12708
      },
      "full_adder_2dc2d92a": {
        "rtl_code": "module full_adder(\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule four_bit_adder(\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire c1, c2, c3;\n  full_adder fa1(a[0], b[0], cin, sum[0], c1);\n  full_adder fa2(a[1], b[1], c1, sum[1], c2);\n  full_adder fa3(a[2], b[2], c2, sum[2], c3);\n  full_adder fa4(a[3], b[3], c3, sum[3], cout);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "2dc2d92a4b009ffa69e17c9f27dda32c",
        "dataset_index": 8499
      },
      "karnaugh_map_a96bec34": {
        "rtl_code": "module karnaugh_map(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @*\n    case ({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0010: F = 1'b1;\n      4'b0011: F = 1'b0;\n      4'b0100: F = 1'b1;\n      4'b0101: F = 1'b0;\n      4'b0110: F = 1'b0;\n      4'b0111: F = 1'b1;\n      4'b1000: F = 1'b0;\n      4'b1001: F = 1'b1;\n      4'b1010: F = 1'b1;\n      4'b1011: F = 1'b0;\n      4'b1100: F = 1'b1;\n      4'b1101: F = 1'b0;\n      4'b1110: F = 1'b0;\n      4'b1111: F = 1'b1;\n    endcase\n\nendmodule",
        "module_name": "karnaugh_map",
        "module_hash": "a96bec34afcffe72db2ad416396a6cad",
        "dataset_index": 721
      },
      "CLS_LED_Output_Multiplexer_b7c6ea58": {
        "rtl_code": "\nmodule CLS_LED_Output_Multiplexer\n(\n\tinput [9:0]\t\tPWM_CHANNEL_SIGS,\n\tinput \t\t\tPWM_TIMER_TICK,\n\tinput \t\t\tSRT_TICK,\n\toutput reg [9:0] \tLEDR,\n\tinput \t\t\tCLK\n);\n\t\n\treg [4:0] frame_pos;\n\treg [4:0] next_frame_pos;\n\treg [4:0] frame_pos_sync;\n\twire [9:0] pchs = PWM_CHANNEL_SIGS;\n\t\n\tinitial\n\tbegin\n\t\tframe_pos = 5'h0;\n\t\tnext_frame_pos = 5'h0;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tcase (frame_pos)\n\t\t\t5'b00000 : next_frame_pos <= 5'b00001;\n\t\t\t5'b00001 : next_frame_pos <= 5'b00011;\n\t\t\t5'b00011 : next_frame_pos <= 5'b00010;\n\t\t\t5'b00010 : next_frame_pos <= 5'b00110;\n\t\t\t5'b00110 : next_frame_pos <= 5'b00111;\n\t\t\t5'b00111 : next_frame_pos <= 5'b00101;\n\t\t\t5'b00101 : next_frame_pos <= 5'b00100;\n\t\t\t5'b00100 : next_frame_pos <= 5'b01100;\n\t\t\t5'b01100 : next_frame_pos <= 5'b11100;\n\t\t\t5'b11100 : next_frame_pos <= 5'b10100;\n\t\t\t5'b10100 : next_frame_pos <= 5'b10101;\n\t\t\t5'b10101 : next_frame_pos <= 5'b10111;\n\t\t\t5'b10111 : next_frame_pos <= 5'b10110;\n\t\t\t5'b10110 : next_frame_pos <= 5'b10010;\n\t\t\t5'b10010 : next_frame_pos <= 5'b10011;\n\t\t\t5'b10011 : next_frame_pos <= 5'b10001;\n\t\t\t5'b10001 : next_frame_pos <= 5'b10000;\n\t\t\t5'b10000 : next_frame_pos <= 5'b00000;\n\t\t\tdefault : next_frame_pos <= 5'b00000;\n\t\tendcase\n\tend\t\n\t\n\talways @(posedge SRT_TICK)\n\tbegin\n\t\tframe_pos <= next_frame_pos;\n\tend\n\t\n\talways @(posedge PWM_TIMER_TICK)\n\tbegin\n\t\tframe_pos_sync <= frame_pos;\n\tend\n\t\n\talways @*\n\tbegin\n\t\tcase (frame_pos_sync)\n\t\t\t5'b00000 : LEDR <= { pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0] };\n\t\t\t5'b00001 : LEDR <= { pchs[8], pchs[9], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0], pchs[0] };\n\t\t\t5'b00011 : LEDR <= { pchs[7], pchs[8], pchs[9], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00010 : LEDR <= { pchs[6], pchs[7], pchs[8], pchs[9], pchs[2], pchs[1], pchs[0], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00110 : LEDR <= { pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00111 : LEDR <= { pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00101 : LEDR <= { pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00100 : LEDR <= { pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0] };\n\t\t\t5'b01100 : LEDR <= { pchs[1], pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0] };\n\t\t\t5'b11100 : LEDR <= { pchs[0], pchs[1], pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9] };\n\t\t\t5'b10100 : LEDR <= { pchs[0], pchs[0], pchs[1], pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[9], pchs[8] };\n\t\t\t5'b10101 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[1], pchs[2], pchs[3], pchs[4], pchs[9], pchs[8], pchs[7] };\n\t\t\t5'b10111 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[0], pchs[1], pchs[2], pchs[9], pchs[8], pchs[7], pchs[6] };\n\t\t\t5'b10110 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5] };\n\t\t\t5'b10010 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4] };\n\t\t\t5'b10011 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3] };\n\t\t\t5'b10001 : LEDR <= { pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2] };\n\t\t\t5'b10000 : LEDR <= { pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1] };\n\t\t\tdefault  : LEDR <= { pchs[0], pchs[9], pchs[8], pchs[7], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0] };\n\t\tendcase\n\tend\n\t\n\nendmodule",
        "module_name": "CLS_LED_Output_Multiplexer",
        "module_hash": "b7c6ea5861c706ddfc2a591f7f59dcce",
        "dataset_index": 23292
      },
      "vga640x480_a15bb799": {
        "rtl_code": "\nmodule vga640x480(\n\tCLK,\n\tCLR,\n\tHSYNC,\n\tVSYNC,\n\tHC,\n\tVC,\n\tVIDON\n);\n\ninput CLK;  input CLR;  output HSYNC; output VSYNC; output [9:0] HC; output [9:0] VC; output VIDON;    localparam hpixels = 800 , vlines = 521 , hbp = 144 , hfp = 784 , vbp = 31  , vfp = 511 ; reg [9:0] HCS, VCS; reg VSenable;\t\t  assign HC    = HCS;\nassign VC    = VCS;\nassign HSYNC = (HCS < 128) ? 1'b0 : 1'b1; assign VSYNC = (VCS < 2)   ? 1'b0 : 1'b1; assign VIDON = (((HCS < hfp) && (HCS >= hbp)) && ((VCS < vfp) && (VCS >= vbp))) ? 1'b1 : 1'b0;\n\n\nalways @ (posedge CLK)\nbegin\n\tif(CLR == 1'b1)\n\t\tHCS <= 10'b0000000000;\n\t\n\telse if(CLK == 1'b1) \n\tbegin\n\t\tif(HCS < (hpixels - 1'b1) )\n\t\tbegin\n\t\t\tHCS <= HCS + 1'b1;\n\t\t\tVSenable <= 1'b0;  end\n\t\telse\n\t\tbegin\t\n\t\t\tHCS <= 10'b0000000000; VSenable <= 1'b1; \t  end\t\n\tend\nend\n\n\n\nalways @ (posedge CLK)\nbegin\n\tif(CLR == 1'b1)\n\t\tVCS <= 10'b0000000000;\n\t\t\n\telse if(CLK == 1'b1 && VSenable == 1'b1)\n\tbegin\n\t\tif( VCS < (vlines - 1'b1) )\n\t\tbegin\n\t\t\tVCS <= VCS + 1'b1; end\n\t\telse\n\t\tbegin\n\t\t\tVCS <= 10'b0000000000; \n\t\tend\n\tend\nend\n\nendmodule\n\n",
        "module_name": "vga640x480",
        "module_hash": "a15bb79947b49bf1025be59e086270d3",
        "dataset_index": 22220
      },
      "alu_flags_5a127a0a": {
        "rtl_code": "\nmodule alu_flags \n#(parameter DATA_WIDTH = 32)\n(\n    input [DATA_WIDTH-1:0] srcA,\n    input [DATA_WIDTH-1:0] srcB,\n    input [3:0] aluop,\n    output zero,\n    output of,\n    output uof\n);\n\n    wire [DATA_WIDTH-1:0] sum, diff;\n    wire carry1, carry2;\n    \n    assign {carry1, sum} = srcA + srcB;    assign {carry2, diff} = srcA - srcB;    assign zero = (srcA == srcB);\n    assign of = (aluop == 4'd5) ? ((srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & ~sum[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & sum[DATA_WIDTH-1]))\n                : (aluop == 4'd6) ? ((srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & ~diff[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & diff[DATA_WIDTH-1]))\n                : 0;\n    assign uof = (aluop == 4'd5) ? (carry1)\n                : (aluop == 4'd6) ? (carry2)\n                : 0;\n    \nendmodule ",
        "module_name": "alu_flags",
        "module_hash": "5a127a0a14f95a01a4b352513b343acf",
        "dataset_index": 7672
      },
      "antares_divider_d649f153": {
        "rtl_code": "module antares_divider (\n                        input         clk,\n                        input         rst,\n                        input         op_divs,\n                        input         op_divu,\n                        input [31:0]  dividend,\n                        input [31:0]  divisor,\n                        output [31:0] quotient,\n                        output [31:0] remainder,\n                        output        div_stall\n                        );\n\n    reg           active;          reg           neg_result;      reg           neg_remainder;   reg [4:0]     cycle;           reg [31:0]    result;          reg [31:0]    denominator;     reg [31:0]    residual;        wire [32:0]   partial_sub;        assign quotient    = !neg_result ? result : -result;\n    assign remainder   = !neg_remainder ? residual : -residual;\n    assign div_stall   = active;\n    assign partial_sub = {residual[30:0], result[31]} - denominator;            always @(posedge clk) begin\n        if (rst) begin\n            \n            active <= 1'h0;\n            cycle <= 5'h0;\n            denominator <= 32'h0;\n            neg_result <= 1'h0;\n            neg_remainder <= 1'h0;\n            residual <= 32'h0;\n            result <= 32'h0;\n            end\n        else begin\n            if(op_divs) begin\n                cycle         <= 5'd31;\n                result        <= (dividend[31] == 1'b0) ? dividend : -dividend;\n                denominator   <= (divisor[31] == 1'b0) ? divisor : -divisor;\n                residual      <= 32'b0;\n                neg_result    <= dividend[31] ^ divisor[31];\n                neg_remainder <= dividend[31];\n                active        <= 1'b1;\n            end\n            else if (op_divu) begin\n                cycle         <= 5'd31;\n                result        <= dividend;\n                denominator   <= divisor;\n                residual      <= 32'b0;\n                neg_result    <= 1'b0;\n                neg_remainder <= 1'h0;\n                active        <= 1'b1;\n            end\n            else if (active) begin\n                if(partial_sub[32] == 1'b0) begin\n                    residual <= partial_sub[31:0];\n                    result   <= {result[30:0], 1'b1};\n                end\n                else begin\n                    residual <= {residual[30:0], result[31]};\n                    result   <= {result[30:0], 1'b0};\n                end\n\n                if (cycle == 5'b0) begin\n                    active <= 1'b0;\n                end\n\n                cycle <= cycle - 5'd1;\n            end\n        end\n    end\n\nendmodule ",
        "module_name": "antares_divider",
        "module_hash": "d649f153c596a5c1a513eceab50cc8d2",
        "dataset_index": 18613
      },
      "multiplier_block_e4168024": {
        "rtl_code": "module multiplier_block (\n    input [31:0] i_data0,\n    output [31:0] o_data0\n);\n\n  wire [31:0]\n    w1,\n    w512,\n    w511,\n    w64,\n    w575,\n    w2300,\n    w2875;\n\n  assign w1 = i_data0;\n  assign w512 = w1 << 9;\n  assign w64 = w1 << 6;\n  assign w511 = w512 - w1;\n  assign w575 = w511 + w64;\n  assign w2300 = w575 << 2;\n  assign w2875 = w575 + w2300;\n  assign o_data0 = w2875;\n\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "e41680246b2ba351a61440cf3d765ac9",
        "dataset_index": 14708
      },
      "four_bit_adder_8515edcf": {
        "rtl_code": "module four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    // Define internal signals\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    // Generate the sum and carry signals\n    full_adder fa0(A[0], B[0], Cin, sum[0], carry[0]);\n    full_adder fa1(A[1], B[1], carry[0], sum[1], carry[1]);\n    full_adder fa2(A[2], B[2], carry[1], sum[2], carry[2]);\n    full_adder fa3(A[3], B[3], carry[2], sum[3], Cout);\n\n    // Assign the sum signal to the output port\n    assign S = sum;\n\nendmodule\n\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    // Define internal signals\n    wire sum;\n    wire Cout1;\n    wire Cout2;\n\n    // Generate the sum and carry signals\n    xor(sum, A, B);\n    xor(S, sum, Cin);\n    and(Cout1, A, B);\n    and(Cout2, sum, Cin);\n    or(Cout, Cout1, Cout2);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "8515edcf573f6750bf1eeb0cfdff9432",
        "dataset_index": 3526
      },
      "timer #_759244ff": {
        "rtl_code": "module timer #\n(\n    parameter WIDTH = 64,\n    parameter USE_2XCLK = 0,\n    parameter S_WIDTH_A = 2\n)\n(\n    input clk,\n    input clk2x,\n    input resetn,\n\n    // Slave port\n    input [S_WIDTH_A-1:0] slave_address,  // Word address\n    input [WIDTH-1:0] slave_writedata,\n    input slave_read,\n    input slave_write,\n    input [WIDTH/8-1:0] slave_byteenable,\n    output slave_waitrequest,\n    output [WIDTH-1:0] slave_readdata,\n    output slave_readdatavalid\n);\n\nreg [WIDTH-1:0] counter;\nreg [WIDTH-1:0] counter2x;\n\nreg clock_sel;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    clock_sel <= 1'b0;\n  else if (slave_write)\n    if (|slave_writedata)\n      clock_sel <= 1'b1;\n    else\n      clock_sel <= 1'b0;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    counter <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter <= {WIDTH{1'b0}};\n  else\n    counter <= counter + 2'b01;\n\nalways@(posedge clk2x or negedge resetn)\n  if (!resetn)\n    counter2x <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter2x <= {WIDTH{1'b0}};\n  else\n    counter2x <= counter2x + 2'b01;\n\nassign slave_waitrequest = 1'b0;\nassign slave_readdata = (USE_2XCLK && clock_sel) ? counter2x : counter;\nassign slave_readdatavalid = slave_read;\n\nendmodule",
        "module_name": "timer #",
        "module_hash": "759244ffc6967ff8b1aeeec75fb109bd",
        "dataset_index": 21223
      },
      "Test_02a85421": {
        "rtl_code": "module Test (\n    input clk, \n    input rstn, \n    input clken, \n    input [3:0] in, \n    output [3:0] ff_out, \n    output [3:0] fg_out, \n    output [3:0] fh_out\n);\n\n    reg [3:0] in_reg;\n    reg [3:0] ff_out_reg;\n    reg [3:0] fg_out_reg;\n    reg [3:0] fh_out_reg;\n\n    always @(posedge clk) begin\n        if (rstn == 0) begin\n            in_reg <= 0;\n            ff_out_reg <= 0;\n            fg_out_reg <= 0;\n            fh_out_reg <= 0;\n        end\n        else if (clken == 1) begin\n            in_reg <= in;\n            ff_out_reg <= in_reg * 2;\n            fg_out_reg <= in_reg * 3;\n            fh_out_reg <= in_reg * 4;\n        end\n    end\n\n    assign ff_out = ff_out_reg;\n    assign fg_out = fg_out_reg;\n    assign fh_out = fh_out_reg;\n\nendmodule",
        "module_name": "Test",
        "module_hash": "02a8542142a880f4b898ef77582ed9cc",
        "dataset_index": 11725
      },
      "adder_2bit_c177ea70": {
        "rtl_code": "\nmodule adder_2bit(input [1:0] A, B, S, output [1:0] O);\n\n  wire [1:0] sum;\n  wire [1:0] diff;\n\n  wire s_not;\n  not (s_not, S);\n\n  // Calculate sum and difference\n  assign sum = A + B;\n  assign diff = {A[1] ^ B[1], A[0] ^ B[0]} + {~B[1], ~B[0], 1'b0};\n\n  // Use mux2to1 to select output based on S\n  assign O = s_not ? sum : diff;\n\nendmodule\n",
        "module_name": "adder_2bit",
        "module_hash": "c177ea70dde53b31869f33825fc4df47",
        "dataset_index": 19861
      },
      "jt12_eg_ctrl_38fea812": {
        "rtl_code": "\n\nmodule jt12_eg_ctrl(\n\tinput\t\t\t\tkeyon_now,\n\tinput\t\t\t\tkeyoff_now,\n\tinput\t\t[2:0]\tstate_in,\n\tinput\t\t[9:0]\teg,\n\tinput\t\t[4:0]\tarate, input\t\t[4:0]\trate1, input\t\t[4:0]\trate2, input\t\t[3:0]\trrate,\n\tinput\t\t[3:0]\tsl,   input\t\t\t\tssg_en,\n\tinput\t\t[2:0]\tssg_eg,\n\tinput\t\t\t\tssg_inv_in,\n\toutput reg\t\t\tssg_inv_out,\n\n\toutput reg\t[4:0]\tbase_rate,\n\toutput reg\t[2:0]\tstate_next,\n\toutput reg\t\t\tpg_rst\n);\n\nlocalparam \tATTACK = 3'b001,\n\t\t\tDECAY  = 3'b010,\n\t\t\tHOLD   = 3'b100,\n\t\t\tRELEASE= 3'b000; reg\t\t[4:0]\tsustain;\n\nalways @(*)\n\tif( sl == 4'd15 )\n\t\tsustain = 5'h1f; else\n\t\tsustain = {1'b0, sl};\n\nwire\tssg_en_out;\nreg\t\tssg_en_in, ssg_pg_rst;\n\nwire ssg_att  = ssg_eg[2];\nwire ssg_alt  = ssg_eg[1];\nwire ssg_hold = ssg_eg[0] & ssg_en;\n\nreg ssg_over;\n\n\nalways @(*) begin\n\tssg_over = ssg_en && eg[9]; ssg_pg_rst = ssg_over && !( ssg_alt || ssg_hold );\n\tpg_rst = keyon_now | ssg_pg_rst;\nend\n\nalways @(*)\n\tcasez ( { keyoff_now, keyon_now, state_in} )\n\t\t5'b01_???: begin base_rate\t= arate;\n\t\t\tstate_next\t= ATTACK;\n\t\t\tssg_inv_out\t= ssg_att & ssg_en;\n\t\tend\n\t\t{2'b00, ATTACK}:\n\t\t\tif( eg==10'd0 ) begin\n\t\t\t\tbase_rate\t= rate1;\n\t\t\t\tstate_next\t= DECAY;\n\t\t\t\tssg_inv_out\t= ssg_inv_in;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tbase_rate\t= arate;\n\t\t\t\tstate_next\t= ATTACK;\n\t\t\t\tssg_inv_out\t= ssg_inv_in;\n\t\t\tend\n\t\t{2'b00, DECAY}: begin\n\t\t\tif( ssg_over ) begin\n\t\t\t\tbase_rate\t= ssg_hold ? 5'd0 : arate;\n\t\t\t\tstate_next\t= ssg_hold ? HOLD : ATTACK;\n\t\t\t\tssg_inv_out\t= ssg_en & (ssg_alt ^ ssg_inv_in);\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tbase_rate\t=  eg[9:5] >= sustain ? rate2 : rate1; state_next\t= DECAY;\n\t\t\t\tssg_inv_out = ssg_inv_in;\n\t\t\tend\n\t\tend\n\t\t{2'b00, HOLD}: begin\n\t\t\tbase_rate\t= 5'd0;\n\t\t\tstate_next\t= HOLD;\n\t\t\tssg_inv_out\t= ssg_inv_in;\n\t\tend\n\t\tdefault: begin base_rate\t= { rrate, 1'b1 };\n\t\t\tstate_next\t= RELEASE;\tssg_inv_out\t= 1'b0; end\n\tendcase\n\n\nendmodule // jt12_eg_ctrl",
        "module_name": "jt12_eg_ctrl",
        "module_hash": "38fea8120864ef25b769835962bca662",
        "dataset_index": 21369
      },
      "decoder_4to16_pipeline_49eb95c3": {
        "rtl_code": "\nmodule decoder_4to16_pipeline (\n    input A, B,\n    output reg [15:0] Y\n);\n\nreg [1:0] stage1_A, stage1_B;\nreg [3:0] stage2_A, stage2_B;\nreg [7:0] stage3_A, stage3_B;\n\nalways @(A or B) begin\n    stage1_A <= A;\n    stage1_B <= B;\nend\n\nalways @(stage1_A or stage1_B) begin\n    stage2_A <= stage1_A;\n    stage2_B <= stage1_B;\nend\n\nalways @(stage2_A or stage2_B) begin\n    stage3_A <= stage2_A;\n    stage3_B <= stage2_B;\nend\n\nalways @(stage3_A or stage3_B) begin\n    if (stage3_A == 2'b00) begin\n        Y <= 16'b0000000000000001;\n    end else if (stage3_A == 2'b01) begin\n        Y <= 16'b0000000000000010;\n    end else if (stage3_A == 2'b10) begin\n        Y <= 16'b0000000000000100;\n    end else if (stage3_A == 2'b11) begin\n        Y <= 16'b1000000000000000;\n    end\nend\n\nendmodule",
        "module_name": "decoder_4to16_pipeline",
        "module_hash": "49eb95c38f60ecacea6714bc7ecaf109",
        "dataset_index": 9188
      },
      "adder_subtractor_c9bd1d6f": {
        "rtl_code": "module adder_subtractor(A, B, mode, result);\ninput [3:0] A, B;\ninput mode;\noutput reg [3:0] result;\n\nalways @(*) begin\n\tif(mode == 0)\n\t\tresult <= A + B;\n\telse\n\t\tresult <= A - B;\nend\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "c9bd1d6f77c1db1237d3456f223855c9",
        "dataset_index": 126
      },
      "AGC_9b609e7b": {
        "rtl_code": "module AGC (\n  input [15:0] input_signal,\n  input [7:0] control_signal,\n  output [15:0] output_signal\n);\n\nparameter gain_bits = 8; // number of bits used to represent the gain value\n\nreg [gain_bits-1:0] gain_value; // binary value representing the gain\nreg [15:0] adjusted_signal; // signal with constant output level\n\n// Function to adjust the gain based on the control signal\nfunction [gain_bits-1:0] adjust_gain;\n  input [7:0] control;\n  begin\n    case (control)\n      8'h00: adjust_gain = 8'h00; // no gain adjustment\n      8'h01: adjust_gain = 8'h01; // small gain increase\n      8'h02: adjust_gain = 8'h02;\n      8'h03: adjust_gain = 8'h03;\n      8'h04: adjust_gain = 8'h04;\n      8'h05: adjust_gain = 8'h05;\n      8'h06: adjust_gain = 8'h06;\n      8'h07: adjust_gain = 8'h07;\n      8'h08: adjust_gain = 8'h08; // maximum gain increase\n      8'h09: adjust_gain = 8'h09; // no gain adjustment\n      8'h0A: adjust_gain = 8'h0A;\n      8'h0B: adjust_gain = 8'h0B;\n      8'h0C: adjust_gain = 8'h0C;\n      8'h0D: adjust_gain = 8'h0D;\n      8'h0E: adjust_gain = 8'h0E;\n      8'h0F: adjust_gain = 8'h0F;\n      8'h10: adjust_gain = 8'h10; // maximum gain reduction\n      8'h11: adjust_gain = 8'h11; // no gain adjustment\n      8'h12: adjust_gain = 8'h12;\n      8'h13: adjust_gain = 8'h13;\n      8'h14: adjust_gain = 8'h14;\n      8'h15: adjust_gain = 8'h15;\n      8'h16: adjust_gain = 8'h16;\n      8'h17: adjust_gain = 8'h17;\n      8'h18: adjust_gain = 8'h18; // small gain reduction\n      default: adjust_gain = 8'h00; // no gain adjustment\n    endcase\n  end\nendfunction\n\n// Assign the gain value based on the control signal\nalways @ (control_signal) begin\n  gain_value = adjust_gain(control_signal);\nend\n\n// Compute the adjusted signal with constant output level\nalways @ (input_signal, gain_value) begin\n  adjusted_signal = input_signal * gain_value;\nend\n\n// Assign the output signal\nassign output_signal = adjusted_signal;\n\nendmodule",
        "module_name": "AGC",
        "module_hash": "9b609e7bef60b6ef2ba3aa26a7a5fa35",
        "dataset_index": 342
      },
      "EHRU_6_b8b37591": {
        "rtl_code": "module EHRU_6 (\n    CLK,\n    read_0,\n    write_0,\n    EN_write_0,\n    read_1,\n    write_1,\n    EN_write_1,\n    read_2,\n    write_2,\n    EN_write_2,\n    read_3,\n    write_3,\n    EN_write_3,\n    read_4,\n    write_4,\n    EN_write_4,\n    read_5,\n    write_5,\n    EN_write_5\n);\n    parameter            DATA_SZ = 1;\n    parameter            RESET_VAL = 0;\n\n    input                CLK;\n    output [DATA_SZ-1:0] read_0;\n    input  [DATA_SZ-1:0] write_0;\n    input                EN_write_0;\n    output [DATA_SZ-1:0] read_1;\n    input  [DATA_SZ-1:0] write_1;\n    input                EN_write_1;\n    output [DATA_SZ-1:0] read_2;\n    input  [DATA_SZ-1:0] write_2;\n    input                EN_write_2;\n    output [DATA_SZ-1:0] read_3;\n    input  [DATA_SZ-1:0] write_3;\n    input                EN_write_3;\n    output [DATA_SZ-1:0] read_4;\n    input  [DATA_SZ-1:0] write_4;\n    input                EN_write_4;\n    output [DATA_SZ-1:0] read_5;\n    input  [DATA_SZ-1:0] write_5;\n    input                EN_write_5;\n\n    reg    [DATA_SZ-1:0] r;\n    wire   [DATA_SZ-1:0] wire_0;\n    wire   [DATA_SZ-1:0] wire_1;\n    wire   [DATA_SZ-1:0] wire_2;\n    wire   [DATA_SZ-1:0] wire_3;\n    wire   [DATA_SZ-1:0] wire_4;\n    wire   [DATA_SZ-1:0] wire_5;\n    wire   [DATA_SZ-1:0] wire_6;\n\n    assign wire_0 = r;\n    assign wire_1 = EN_write_0 ? write_0 : wire_0;\n    assign wire_2 = EN_write_1 ? write_1 : wire_1;\n    assign wire_3 = EN_write_2 ? write_2 : wire_2;\n    assign wire_4 = EN_write_3 ? write_3 : wire_3;\n    assign wire_5 = EN_write_4 ? write_4 : wire_4;\n    assign wire_6 = EN_write_5 ? write_5 : wire_5;\n\n    assign read_0 = wire_0;\n    assign read_1 = wire_1;\n    assign read_2 = wire_2;\n    assign read_3 = wire_3;\n    assign read_4 = wire_4;\n    assign read_5 = wire_5;\n\n    always @(posedge CLK) begin\n        r <= wire_6;\n    end\nendmodule\n",
        "module_name": "EHRU_6",
        "module_hash": "b8b37591afa39151b960903c93c10cb2",
        "dataset_index": 23665
      },
      "mux4_0cd01457": {
        "rtl_code": "module mux4(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = in2;\n        2'b11: out = in3;\n    endcase\nend\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "0cd01457f5825a0295b83c0480f0c2dd",
        "dataset_index": 4148
      },
      "mux_multiply_e463755c": {
        "rtl_code": "\nmodule mux_multiply (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    input sel,\n    output [7:0] out\n);\n\n    wire [3:0] selected_input;\n    wire [7:0] product;\n\n    // 2-to-1 multiplexer\n    mux2to1 mux (\n        .in_0(in_0),\n        .in_1(in_1),\n        .sel(sel),\n        .out(selected_input)\n    );\n\n    // Arithmetic module for multiplication\n    multiplier mult (\n        .in_0(selected_input),\n        .in_1(selected_input),\n        .out(product)\n    );\n\n    assign out = product;\n\nendmodule\nmodule mux2to1 (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    input sel,\n    output [3:0] out\n);\n\n    assign out = sel ? in_1 : in_0;\n\nendmodule\nmodule multiplier (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    output [7:0] out\n);\n\n    assign out = in_0 * in_1;\n\nendmodule",
        "module_name": "mux_multiply",
        "module_hash": "e463755cfd442e8e8343739a23b08a0b",
        "dataset_index": 1947
      },
      "i2s_tx #_d94efff3": {
        "rtl_code": "module i2s_tx #(\n    parameter WIDTH = 16\n)(\n    input clk,\n    input rst,\n    input [WIDTH-1:0] input_l_tdata,\n    input [WIDTH-1:0] input_r_tdata,\n    input input_tvalid,\n    output reg input_tready,\n    output reg sck,\n    output reg ws,\n    output reg sd\n);\n\n\nreg [WIDTH-1:0] l_data;\nreg [WIDTH-1:0] r_data;\nreg [3:0] bit_count;\nreg [1:0] channel_count;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        input_tready <= 1'b0;\n        sck <= 1'b0;\n        ws <= 1'b0;\n        sd <= 1'b0;\n        l_data <= {WIDTH{1'b0}};\n        r_data <= {WIDTH{1'b0}};\n        bit_count <= 4'd0;\n        channel_count <= 2'd0;\n    end else begin\n        if (input_tvalid && input_tready) begin\n            input_tready <= 1'b0;\n            l_data <= input_l_tdata;\n            r_data <= input_r_tdata;\n            bit_count <= 4'd0;\n            channel_count <= 2'd0;\n        end else if (sck && ws) begin\n            if (bit_count == WIDTH-1) begin\n                if (channel_count == 2'd0) begin\n                    sd <= l_data[WIDTH-1-bit_count];\n                    channel_count <= 2'd1;\n                end else begin\n                    sd <= r_data[WIDTH-1-bit_count];\n                    channel_count <= 2'd0;\n                end\n                bit_count <= 4'd0;\n            end else begin\n                bit_count <= bit_count + 1;\n                sd <= 1'b0;\n            end\n        end\n        if (!input_tvalid) begin\n            input_tready <= 1'b1;\n        end\n        sck <= ~sck;\n        ws <= (bit_count == WIDTH-1) ? ~ws : ws;\n    end\nend\n\nendmodule",
        "module_name": "i2s_tx #",
        "module_hash": "d94efff3f0d69c54372bbfe49a889696",
        "dataset_index": 2465
      },
      "mm_09c8a385": {
        "rtl_code": "\n\n\n\n\n\n\n\n\nmodule mm(addr, mod, eff_addr);\n\tinput [31:0] addr; \n\toutput [7:0] mod; \n\toutput [31:0] eff_addr; \n\n\tassign mod = (addr[31:20] == 12'h000) ? 0 : \n\t\t     (addr[31:24] ==   8'h10) ? 1 : \n\t\t     (addr[31:20] == 12'hf00) ? 2 : \n\t\t     (addr[31:20] == 12'hf01) ? 3 : \n\t\t     (addr[31:20] == 12'hf02) ? 4 : \n\t\t     (addr[31:20] == 12'hf03) ? 5 : \n\t\t     (addr[31:20] == 12'hf04) ? 6 : \n\t\t     (addr[31:20] == 12'hf05) ? 7 : \n\t\t     (addr[31:20] == 12'hf06) ? 8 : \n\t\t     (addr[31:20] == 12'hf07) ? 10 : \n\t\t     (addr[31:20] == 12'hf08) ? 11 : \n\t\t     (addr[31:20] == 12'hf0a) ? 9 : \n\t\t     0;\n\tassign eff_addr = (mod == 8'h01) ? {8'h00,addr[23:0]} : {12'h000,addr[19:0]};\nendmodule\n",
        "module_name": "mm",
        "module_hash": "09c8a385b4f6111574e703f5238be833",
        "dataset_index": 24799
      },
      "ripple_carry_adder_0ec67702": {
        "rtl_code": "module ripple_carry_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] carry;\n  \n  full_adder fa0(A[0], B[0], Cin, S[0], carry[0]);\n  full_adder fa1(A[1], B[1], carry[0], S[1], carry[1]);\n  full_adder fa2(A[2], B[2], carry[1], S[2], carry[2]);\n  full_adder fa3(A[3], B[3], carry[2], S[3], Cout);\n\nendmodule\nmodule full_adder (\n  input A,\n  input B,\n  input Cin,\n  output S,\n  output Cout\n);\n\n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule\n",
        "module_name": "ripple_carry_adder",
        "module_hash": "0ec677020dc6fc07c920409f7ff9d621",
        "dataset_index": 12482
      },
      "reset_test_gate_c3cec98f": {
        "rtl_code": "\nmodule reset_test_gate (clk, reset, ctrl, din, sel, dout);\n   input wire clk;\n   input wire reset;\n   input wire [4:0] ctrl;\n   input wire [1:0] din;\n   input wire [0:0] sel;\n   output reg [31:0] dout;\n   reg [1:0] \t     i;\n   wire [0:0] \t     rval;\n   assign rval = {reset, 1'b0 };\n   always @(posedge clk)\n     begin\n        case (|(reset))\n          1'b 1:\n            begin\n               case (({(0)*(rval)})+(0))\n                 0:\n                   dout[31:0] <= 57005;\n                 1:\n                   dout[31:1] <= 57005;\n                 2:\n                   dout[31:2] <= 57005;\n                 3:\n                   dout[31:3] <= 57005;\n                 4:\n                   dout[31:4] <= 57005;\n                 5:\n                   dout[31:5] <= 57005;\n                 6:\n                   dout[31:6] <= 57005;\n                 7:\n                   dout[31:7] <= 57005;\n                 8:\n                   dout[31:8] <= 57005;\n                 9:\n                   dout[31:9] <= 57005;\n                 10:\n                   dout[31:10] <= 57005;\n                 11:\n                   dout[31:11] <= 57005;\n                 12:\n                   dout[31:12] <= 57005;\n                 13:\n                   dout[31:13] <= 57005;\n                 14:\n                   dout[31:14] <= 57005;\n                 15:\n                   dout[31:15] <= 57005;\n                 16:\n                   dout[31:16] <= 57005;\n                 17:\n                   dout[31:17] <= 57005;\n                 18:\n                   dout[31:18] <= 57005;\n                 19:\n                   dout[31:19] <= 57005;\n                 20:\n                   dout[31:20] <= 57005;\n                 21:\n                   dout[31:21] <= 57005;\n                 22:\n                   dout[31:22] <= 57005;\n                 23:\n                   dout[31:23] <= 57005;\n                 24:\n                   dout[31:24] <= 57005;\n                 25:\n                   dout[31:25] <= 57005;\n                 26:\n                   dout[31:26] <= 57005;\n                 27:\n                   dout[31:27] <= 57005;\n                 28:\n                   dout[31:28] <= 57005;\n                 29:\n                   dout[31:29] <= 57005;\n                 30:\n                   dout[31:30] <= 57005;\n                 31:\n                   dout[31:31] <= 57005;\n               endcase\n               i = 1;\n            end\n        endcase\n        case (({(ctrl)*(sel)})+(0))\n          0:\n            dout[31:0] <= din;\n          1:\n            dout[31:1] <= din;\n          2:\n            dout[31:2] <= din;\n          3:\n            dout[31:3] <= din;\n          4:\n            dout[31:4] <= din;\n          5:\n            dout[31:5] <= din;\n          6:\n            dout[31:6] <= din;\n          7:\n            dout[31:7] <= din;\n          8:\n            dout[31:8] <= din;\n          9:\n            dout[31:9] <= din;\n          10:\n            dout[31:10] <= din;\n          11:\n            dout[31:11] <= din;\n          12:\n            dout[31:12] <= din;\n          13:\n            dout[31:13] <= din;\n          14:\n            dout[31:14] <= din;\n          15:\n            dout[31:15] <= din;\n          16:\n            dout[31:16] <= din;\n          17:\n            dout[31:17] <= din;\n          18:\n            dout[31:18] <= din;\n          19:\n            dout[31:19] <= din;\n          20:\n            dout[31:20] <= din;\n          21:\n            dout[31:21] <= din;\n          22:\n            dout[31:22] <= din;\n          23:\n            dout[31:23] <= din;\n          24:\n            dout[31:24] <= din;\n          25:\n            dout[31:25] <= din;\n          26:\n            dout[31:26] <= din;\n          27:\n            dout[31:27] <= din;\n          28:\n            dout[31:28] <= din;\n          29:\n            dout[31:29] <= din;\n          30:\n            dout[31:30] <= din;\n          31:\n            dout[31:31] <= din;\n        endcase\n     end\nendmodule\n",
        "module_name": "reset_test_gate",
        "module_hash": "c3cec98fd303e75604ce94878e6f2ee9",
        "dataset_index": 25427
      },
      "spi_slave_simpler2_7c6b43cf": {
        "rtl_code": "module spi_slave_simpler2(clk, cs, mosi, miso, sck, done, din, dout);\n\tparameter bc=8;\tinput clk;\n\tinput cs;\tinput mosi;\n\toutput miso;\n\tinput sck;\n\toutput reg done;\n\tinput [bc-1:0] din;\n\toutput reg [bc-1:0] dout;\n\t\n\treg [bc-1:0] shift_reg;\n\treg prev_cs, prev_sck;\n\treg mosi_sample;\n\treg [7:0] shift_count;\n\t\n\tassign miso = shift_reg[bc-1];\n\n\talways @(posedge clk) begin\n\t\tif (~cs) begin\n\t\t\tif (prev_cs) begin\n\t\t\t\tdone <= 0;\n\t\t\t\tshift_reg[bc-1:0] <= 8'h23; shift_count <= 0;\n\t\t\tend else begin\n\t\t\t\tif (~prev_sck && sck) begin\n\t\t\t\t\tmosi_sample <= mosi;\n\t\t\t\t\tif (shift_count == bc-1) begin\n\t\t\t\t\t\tdout <= {shift_reg[bc-2:0], mosi};\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend \n\t\t\t\tif (prev_sck && ~sck) begin\n\t\t\t\t\tshift_reg[bc-1:0] <= {shift_reg[bc-2:0], mosi_sample};\n\t\t\t\t\tshift_count <= shift_count + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend else begin\n\t\t\tdone <= 1;\n\t\tend\n\t\tprev_cs <= cs;\n\t\tprev_sck <= sck;\n\tend\nendmodule\n",
        "module_name": "spi_slave_simpler2",
        "module_hash": "7c6b43cf752e10d1f054f546d7fefba7",
        "dataset_index": 22198
      },
      "barrel_shifter_4893a4ab": {
        "rtl_code": "\nmodule barrel_shifter (\n  input [31:0] data_in,\n  input [4:0] shift_amount,\n  output reg [31:0] data_out,\n  output reg zero_flag,\n  input clk, // Added clock input port\n  input reset // Added reset port\n);\n\n  reg [31:0] reg_file [0:4];\n  reg [4:0] stage;\n  reg [31:0] shifted_data;\n  reg zero;\n\n  always @(posedge clk) begin // Connect the clock to the always block\n    if (reset) begin\n      stage <= 0;\n      zero_flag <= 0;\n    end else begin\n      if (stage == 5) begin\n        stage <= 0;\n        zero_flag <= zero;\n      end else begin\n        stage <= stage + 1;\n      end\n    end\n  end\n\n  always @(*) begin\n    case (stage)\n      0: begin\n        reg_file[0] = data_in;\n        shifted_data = data_in;\n      end\n      1: begin\n        reg_file[1] = shifted_data;\n        shifted_data = reg_file[0] << shift_amount;\n      end\n      2: begin\n        reg_file[2] = shifted_data;\n        shifted_data = reg_file[1] << shift_amount;\n      end\n      3: begin\n        reg_file[3] = shifted_data;\n        shifted_data = reg_file[2] << shift_amount;\n      end\n      4: begin\n        reg_file[4] = shifted_data;\n        shifted_data = reg_file[3] << shift_amount;\n      end\n      5: begin\n        data_out = shifted_data;\n        zero = (shifted_data == 0);\n      end\n    endcase\n  end\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "4893a4ab432d2ec19c21369b34c86043",
        "dataset_index": 16852
      },
      "pwm_generator_772a42dd": {
        "rtl_code": "module pwm_generator(\n    input clk,\n    input rst,\n    input input_signal,\n    output reg pwm_signal\n);\n\nreg [6:0] duty_cycle;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        pwm_signal <= 1'b0;\n        duty_cycle <= 7'b0000000;\n    end else begin\n        if (duty_cycle == 7'b1111111) begin\n            pwm_signal <= 1'b1;\n        end else begin\n            pwm_signal <= 1'b1;\n            if (duty_cycle < 7'b1111111) begin\n                duty_cycle <= duty_cycle + 1;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "pwm_generator",
        "module_hash": "772a42dd400bb62205bf1fe45010cd18",
        "dataset_index": 7288
      },
      "a221o_2_ae175f17": {
        "rtl_code": "\nmodule a221o_2 (\n    input X,\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    output Y\n);\n\n    assign Y = (A1 & B1 & C1) | (A2 & B2 & C1);\n\nendmodule\n",
        "module_name": "a221o_2",
        "module_hash": "ae175f1704dd17e57d269261f8f99201",
        "dataset_index": 4520
      },
      "shift_reg_c70b0d6b": {
        "rtl_code": "\nmodule shift_reg (\n    input clk,\n    input rst,\n    input serial_in,\n    input parallel_in,\n    output serial_out\n);\n\nparameter WIDTH = 4;\n\nreg [WIDTH-1:0] reg_data;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        reg_data <= {WIDTH{1'b0}};\n    end else begin\n        if (parallel_in) begin\n            reg_data <= {serial_in, reg_data[WIDTH-2:0]};\n        end else begin\n            reg_data <= {reg_data[WIDTH-2:0], serial_in};\n        end\n    end\nend\n\nassign serial_out = reg_data[WIDTH-1];\n\nendmodule",
        "module_name": "shift_reg",
        "module_hash": "c70b0d6bfd2851569dde613f96d02bf0",
        "dataset_index": 14990
      },
      "shift_register_c7dab1d9": {
        "rtl_code": "module shift_register (\n    input clk,\n    input [3:0] DIN,\n    input LOAD,\n    input SHIFT,\n    input RESET,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (RESET) begin\n            Q <= 4'b0;\n        end else if (LOAD) begin\n            Q <= DIN;\n        end else if (SHIFT) begin\n            Q <= {Q[2:0], 1'b0};\n        end\n    end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "c7dab1d966fe31c58a26d926deb52115",
        "dataset_index": 13142
      },
      "alt_ddrx_clock_and_reset #_6b484909": {
        "rtl_code": "\nmodule alt_ddrx_clock_and_reset #\n    ( parameter\n        CTL_RESET_SYNC_STAGES      = 4,\n        CTL_NUM_RESET_OUTPUT       = 1,\n        CTL_HALF_RESET_SYNC_STAGES = 4,\n        CTL_HALF_NUM_RESET_OUTPUT  = 1\n    )\n    (\n        ctl_clk,\n        ctl_reset_n,\n        ctl_half_clk,\n        ctl_half_clk_reset_n,\n        \n        resynced_ctl_reset_n,\n        resynced_ctl_half_clk_reset_n\n    );\n\ninput  ctl_clk;\ninput  ctl_reset_n;\ninput  ctl_half_clk;\ninput  ctl_half_clk_reset_n;\n\noutput [CTL_NUM_RESET_OUTPUT      - 1 : 0] resynced_ctl_reset_n;\noutput [CTL_HALF_NUM_RESET_OUTPUT - 1 : 0] resynced_ctl_half_clk_reset_n;\n\nalt_ddrx_reset_sync #(\n    .RESET_SYNC_STAGES (CTL_RESET_SYNC_STAGES),\n    .NUM_RESET_OUTPUT  (CTL_NUM_RESET_OUTPUT)\n) reset_sync_inst (\n\t.reset_n           (ctl_reset_n),\n\t.clk               (ctl_clk),\n\t.reset_n_sync      (resynced_ctl_reset_n)\n);\n\nalt_ddrx_reset_sync #(\n    .RESET_SYNC_STAGES (CTL_HALF_RESET_SYNC_STAGES),\n    .NUM_RESET_OUTPUT  (CTL_HALF_NUM_RESET_OUTPUT)\n) half_reset_sync_inst (\n\t.reset_n           (ctl_half_clk_reset_n),\n\t.clk               (ctl_half_clk),\n\t.reset_n_sync      (resynced_ctl_half_clk_reset_n)\n);\n\n\nendmodule\n\nmodule alt_ddrx_reset_sync #\n    ( parameter\n        RESET_SYNC_STAGES = 4,\n        NUM_RESET_OUTPUT  = 1\n    )\n    (\n    \treset_n,\n    \tclk,\n    \treset_n_sync\n    );\n\ninput\treset_n;\ninput\tclk;\noutput\t[NUM_RESET_OUTPUT-1:0] reset_n_sync;\n\n reg\t[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:0] reset_reg ;\n\ngenerate\ngenvar i;\n\tfor (i=0; i<RESET_SYNC_STAGES+NUM_RESET_OUTPUT-1; i=i+1)\n\tbegin: reset_stage\n\t\talways @(posedge clk or negedge reset_n)\n\t\tbegin\n\t\t\tif (~reset_n)\n\t\t\t\treset_reg[i] <= 1'b0;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif (i==0)\n\t\t\t\t\treset_reg[i] <= 1'b1;\n\t\t\t\telse if (i < RESET_SYNC_STAGES)\n\t\t\t\t\treset_reg[i] <= reset_reg[i-1];\n\t\t\t\telse\n\t\t\t\t\treset_reg[i] <= reset_reg[RESET_SYNC_STAGES-2];\n\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendgenerate\n\n\tassign reset_n_sync = reset_reg[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:RESET_SYNC_STAGES-1];\n\nendmodule\n\n",
        "module_name": "alt_ddrx_clock_and_reset #",
        "module_hash": "6b48490987130b0d0141115ddbd7d4f7",
        "dataset_index": 25348
      },
      "decoder_3to8_03050243": {
        "rtl_code": "module decoder_3to8 (\n    input wire clk,\n    input wire [2:0] abc,\n    output reg [7:0] y\n);\n\n    always @(posedge clk) begin\n        y <= 8'b00000001 << abc;\n    end\n\nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "030502432f54a76b9dd7e4497c6b701f",
        "dataset_index": 2494
      },
      "hybrid_pwm_sd_30fbd0bb": {
        "rtl_code": "module hybrid_pwm_sd\n(\n\tinput clk,\n\tinput n_reset,\n\tinput [15:0] din,\n\toutput dout\n);\n\nreg [4:0] pwmcounter;\nreg [4:0] pwmthreshold;\nreg [33:0] scaledin;\nreg [15:0] sigma;\nreg out;\n\nassign dout=out;\n\nalways @(posedge clk, negedge n_reset) begin\n\tif(!n_reset)\n\tbegin\n\t\tsigma<=16'b00000100_00000000;\n\t\tpwmthreshold<=5'b10000;\n        pwmcounter<=5'd0;\n        scaledin<=34'd0;\n\tend\n\telse\n\tbegin\n\t\tpwmcounter<=pwmcounter+1;\n\n\t\tif(pwmcounter==pwmthreshold)\n\t\t\tout<=1'b0;\n\n\t\tif(pwmcounter==5'b11111) begin\n\t\t\tscaledin<=33'd134217728 +({1'b0,din}*61440); sigma<=scaledin[31:16]+{5'b000000,sigma[10:0]};\tpwmthreshold<=sigma[15:11]; out<=1'b1;\n\t\tend\n\n\tend\nend\n\nendmodule\n",
        "module_name": "hybrid_pwm_sd",
        "module_hash": "30fbd0bbc0f4345c8fffd09ab457fca1",
        "dataset_index": 7121
      },
      "decoder_3to8_60333da6": {
        "rtl_code": "module decoder_3to8 (\n    input [2:0] in,\n    output [7:0] out\n);\n\nassign out = 8'b00000001 << in;\n\nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "60333da61ca4945c2ca955eeae5c9ba0",
        "dataset_index": 9070
      },
      "adder_fced0c2f": {
        "rtl_code": "module adder (\n  input [7:0] A,\n  input [7:0] B,\n  output [7:0] sum\n);\n\n  assign sum = A + B;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "fced0c2f43ea34b64f0c57e957d08ad6",
        "dataset_index": 466
      },
      "CHANNEL_ERROR_DETECT_f2f8a481": {
        "rtl_code": "\n\nmodule CHANNEL_ERROR_DETECT\n(\n    SOFT_ERROR,\n    HARD_ERROR,\n    LANE_UP,\n\n\n    USER_CLK,\n    POWER_DOWN,\n\n    CHANNEL_SOFT_ERROR,\n    CHANNEL_HARD_ERROR,\n\n\n    RESET_CHANNEL\n);\n\n`define DLY #1\n\n\ninput   [0:1]      SOFT_ERROR;\n    input              HARD_ERROR;\n    input              LANE_UP;\n\n\n    input              USER_CLK;\n    input              POWER_DOWN;\n\n    output             CHANNEL_SOFT_ERROR;\n    output             CHANNEL_HARD_ERROR;\n\n\n    output             RESET_CHANNEL;\n\n\nreg                CHANNEL_SOFT_ERROR;\n    reg                CHANNEL_HARD_ERROR;\n    reg                RESET_CHANNEL;\n\n\nreg     [0:1]      soft_error_r;\n    reg                hard_error_r;\n\n\nwire               channel_soft_error_c;\n    wire               channel_hard_error_c;\n    wire               reset_channel_c;\n\n\nalways @(posedge USER_CLK)\n    begin\n        soft_error_r    <=  `DLY    SOFT_ERROR;\n        hard_error_r    <=  `DLY    HARD_ERROR;\n    end\n\n\n\n    initial\n        CHANNEL_SOFT_ERROR = 1'b1;\n\n    assign channel_soft_error_c = soft_error_r[0] |\n                                  soft_error_r[1];\n\n    always @(posedge USER_CLK)\n        CHANNEL_SOFT_ERROR  <=  `DLY    channel_soft_error_c;\n\n\n\n    initial\n        CHANNEL_HARD_ERROR = 1'b1;\n\n    assign channel_hard_error_c = hard_error_r;\n\n    always @(posedge USER_CLK)\n        CHANNEL_HARD_ERROR  <=  `DLY    channel_hard_error_c;\n\n\n\n\n    initial\n        RESET_CHANNEL   =  1'b1;\n\n    assign reset_channel_c = !LANE_UP;\n\n    always @(posedge USER_CLK)\n        RESET_CHANNEL    <=  `DLY    reset_channel_c | POWER_DOWN;\n\nendmodule\n",
        "module_name": "CHANNEL_ERROR_DETECT",
        "module_hash": "f2f8a48171e41a3ecdc9ae0d667b7f4e",
        "dataset_index": 24571
      },
      "t2_ab6f7355": {
        "rtl_code": "\nmodule t2(\n    input [1:0] clks,\n    input c0,\n    input c1,\n    input check,\n    output reg o_check\n);\n\n    reg [1:0] state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n    \n    always @(posedge clks[0]) begin\n        case(state)\n            S0: begin\n                if(c0 && !c1)\n                    state <= S1;\n                else if(!c0 && c1)\n                    state <= S2;\n            end\n            S1: begin\n                if(c0 && !c1)\n                    state <= S3;\n                else if(!c0 && !c1)\n                    state <= S0;\n            end\n            S2: begin\n                if(!c0 && c1)\n                    state <= S3;\n                else if(c0 && !c1)\n                    state <= S0;\n            end\n            S3: begin\n                if(!c0 && !c1)\n                    state <= S2;\n                else if(c0 && c1)\n                    state <= S1;\n            end\n        endcase\n    end\n    \n    always @(posedge clks[1]) begin\n        if(state == S3 && check)\n            o_check <= 1;\n        else\n            o_check <= 0;\n    end\n    \n    initial state <= S0;\n    \nendmodule",
        "module_name": "t2",
        "module_hash": "ab6f735562c223cc968e3a3a21dd6da6",
        "dataset_index": 17361
      },
      "shift_adder_f3752e87": {
        "rtl_code": "\nmodule shift_adder (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    input [15:0] A,\n    input [15:0] B,\n    output [15:0] SUM\n);\n\nwire [3:0] shift_reg;\nwire [15:0] signed_sum;\n\n// Shift register module\nshift_reg_mod shift_reg_inst (\n    .CLK(CLK),\n    .RST(RST),\n    .LD(LD),\n    .D(D),\n    .OUT(shift_reg)\n);\n\n// Signed magnitude adder module\nsigned_adder signed_adder_inst (\n    .A(A),\n    .B(B),\n    .SUM(signed_sum)\n);\n\n// Functional module that adds the output of shift register and signed magnitude adder\nassign SUM = shift_reg + signed_sum;\n\nendmodule\nmodule shift_reg_mod (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    output reg [3:0] OUT\n);\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        OUT <= 4'b0;\n    end else if (LD) begin\n        OUT <= D;\n    end else begin\n        OUT <= {OUT[2:0], 1'b0};\n    end\nend\n\nendmodule\nmodule signed_adder (\n    input [15:0] A,\n    input [15:0] B,\n    output reg [15:0] SUM\n);\n\nwire [15:0] abs_A;\nwire [15:0] abs_B;\nwire [15:0] signed_sum;\n\nassign abs_A = (A[15]) ? ~A + 1 : A;\nassign abs_B = (B[15]) ? ~B + 1 : B;\n\nassign signed_sum = (A[15] == B[15]) ? {A[15], abs_A + abs_B} :\n                    (abs_A > abs_B) ? {A[15], abs_A - abs_B} :\n                    {B[15], abs_B - abs_A};\n\nalways @(signed_sum) begin\n    SUM <= signed_sum;\nend\n\nendmodule",
        "module_name": "shift_adder",
        "module_hash": "f3752e875fa9089095a702db5c5eb004",
        "dataset_index": 14669
      },
      "util_delay #_208a5ab3": {
        "rtl_code": "\n\nmodule util_delay #(\n\n  parameter DATA_WIDTH = 1,\n  parameter DELAY_CYCLES = 1) (\n\n  input                             clk,\n  input                             reset,\n  input                             din,\n  output  [DATA_WIDTH-1:0]          dout);\n\n  reg     [DATA_WIDTH-1:0]          dbuf[0:(DELAY_CYCLES-1)];\n\n  always @(posedge clk) begin\n    if (reset) begin\n      dbuf[0] <= 0;\n    end else begin\n      dbuf[0] <= din;\n    end\n  end\n\n  generate\n  genvar i;\n    for (i = 1; i < DELAY_CYCLES; i=i+1) begin:register_pipe\n      always @(posedge clk) begin\n        if (reset) begin\n          dbuf[i] <= 0;\n        end else begin\n          dbuf[i] <= dbuf[i-1];\n        end\n      end\n    end\n  endgenerate\n\n  assign dout = dbuf[(DELAY_CYCLES-1)];\n\nendmodule\n",
        "module_name": "util_delay #",
        "module_hash": "208a5ab3b7ef4564c91b02408a9f1e7a",
        "dataset_index": 23175
      },
      "add_sub_bd90aca0": {
        "rtl_code": "module add_sub (\n    input [3:0] a,\n    input [3:0] b,\n    input sub, // 0 for addition, 1 for subtraction\n    input cin, // carry in\n    output reg cout, // carry out\n    output reg overflow, // overflow flag\n    output reg [3:0] sum // sum result\n);\n\nreg [3:0] a_reg, b_reg; // Register to hold input values\nreg sub_reg, cin_reg; // Register to hold sub and cin signals\n\n// Wires to connect adders\nwire [4:0] add_out;\nwire [3:0] sub_out;\n\n// Instantiate adders\nassign add_out = a_reg + b_reg + cin_reg; // Adder for addition\nassign sub_out = a_reg - b_reg - cin_reg; // Subtractor for subtraction\n\n// Always block to update registers\nalways @(*) begin\n    a_reg <= a; // Register input a\n    b_reg <= b; // Register input b\n    sub_reg <= sub; // Register sub signal\n    cin_reg <= cin; // Register cin signal\nend\n\n// Always block to calculate sum and overflow\nalways @(*) begin\n    if (sub_reg) begin // If subtraction is selected\n        sum <= sub_out; // Store subtraction result in sum register\n    end else begin // If addition is selected\n        sum <= add_out; // Store addition result in sum register\n    end\n\n    // Check for overflow\n    if (sum > 4'b1111 || sum < 4'b0000) begin\n        overflow <= 1; // Set overflow flag\n    end else begin\n        overflow <= 0; // Clear overflow flag\n    end\nend\n\n// Always block to calculate carry out\nalways @(*) begin\n    // Check for carry out\n    if (sum > 4'b1111 || sum < 4'b0000) begin\n        cout <= 1; // Set carry out\n    end else begin\n        cout <= add_out[4]; // Carry out is the MSB of addition result\n    end\nend\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "bd90aca09f7b953829ce6a53dc7d1aef",
        "dataset_index": 1732
      },
      "top__348b440c": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output [3:0] q,\n    output reg [2:0] count_ones\n);\n\n    reg [3:0] counter;\n    \n    // Binary counter\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n    \n    // Count the number of '1's in the binary representation of the count value\n    always @(counter) begin\n        count_ones <= {counter[0], counter[1], counter[2], counter[3]} \n                        - ((counter[0] & counter[1]) | (counter[0] & counter[2]) | (counter[0] & counter[3]) | (counter[1] & counter[2]) | (counter[1] & counter[3]) | (counter[2] & counter[3]));\n    end\n    \n    assign q = counter;\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "348b440c5b6354c79035d50fa28c935f",
        "dataset_index": 12492
      },
      "win_blk_mem_gen_prim_width_4ce0f71c": {
        "rtl_code": "module win_blk_mem_gen_prim_width\n   (output reg [0:0] douta,\n    input clka,\n    input [13:0] addra,\n    input [0:0] dina,\n    input [0:0] wea);\n\n  reg [0:0] mem [0:16383]; // 14-bit addressable memory block\n\n  always @(posedge clka) begin\n    if (wea[0]) begin // write operation\n      mem[addra] <= dina;\n    end else begin // read operation\n      douta <= mem[addra];\n    end\n  end\nendmodule",
        "module_name": "win_blk_mem_gen_prim_width",
        "module_hash": "4ce0f71c999695756155ab914573d346",
        "dataset_index": 11782
      },
      "eproto_tx_ce6f9714": {
        "rtl_code": "\n\n\n\nmodule eproto_tx (\n   emtx_rd_wait, emtx_wr_wait, emtx_ack, txframe_p, txdata_p,\n   reset, emtx_access, emtx_write, emtx_datamode, emtx_ctrlmode,\n   emtx_dstaddr, emtx_srcaddr, emtx_data, txlclk_p, tx_rd_wait,\n   tx_wr_wait\n   );\n\n   input         reset;\n\n   input         emtx_access;\n   input         emtx_write;\n   input [1:0]   emtx_datamode;\n   input [3:0]   emtx_ctrlmode;\n   input [31:0]  emtx_dstaddr;\n   input [31:0]  emtx_srcaddr;\n   input [31:0]  emtx_data;\n   output        emtx_rd_wait;\n   output        emtx_wr_wait;\n   output        emtx_ack;\n   \n   input         txlclk_p; output [7:0]  txframe_p;\n   output [63:0] txdata_p;\n   input         tx_rd_wait;  input         tx_wr_wait;  reg           emtx_ack;  reg [7:0]     txframe_p;\n   reg [63:0]    txdata_p;\n   \n   always @( posedge txlclk_p or posedge reset ) begin\n\n      if( reset ) begin\n\n         emtx_ack    <= 1'b0;\n         txframe_p   <= 'd0;\n         txdata_p    <= 'd0;\n\n      end else begin\n\n         if( emtx_access & ~emtx_ack ) begin\n\n            emtx_ack  <= 1'b1;\n            txframe_p <= 8'h3F;\n            txdata_p  <=\n               { 8'd0,  8'd0,\n                 ~emtx_write, 7'd0,   emtx_ctrlmode, emtx_dstaddr[31:28], emtx_dstaddr[27:4],  emtx_dstaddr[3:0], emtx_datamode, emtx_write, emtx_access };\n         end else if( emtx_ack ) begin emtx_ack  <= 1'b0;\n            txframe_p <= 8'hFF;\n            txdata_p  <= { emtx_data, emtx_srcaddr };\n            \n         end else begin\n\n            emtx_ack    <= 1'b0;\n            txframe_p <= 8'h00;\n            txdata_p  <= 64'd0;\n\n         end\n\n      end end reg     rd_wait_sync;\n   reg     wr_wait_sync;\n   reg     emtx_rd_wait;\n   reg     emtx_wr_wait;\n   \n   always @( posedge txlclk_p ) begin\n      rd_wait_sync <= tx_rd_wait;\n      emtx_rd_wait <= rd_wait_sync;\n      wr_wait_sync <= tx_wr_wait;\n      emtx_wr_wait <= wr_wait_sync;\n   end\n            \nendmodule ",
        "module_name": "eproto_tx",
        "module_hash": "ce6f971453cd671418273b0d76952d98",
        "dataset_index": 24755
      },
      "byte_reverse_pipeline_0ddf171b": {
        "rtl_code": "\nmodule byte_reverse_pipeline(\n    input [31:0] in,\n    output [31:0] out,\n    input clk,\n    input reset\n);\n\nreg [7:0] shift_reg [3:0];\nreg [1:0] stage;\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        stage <= 0;\n        shift_reg[0] <= 0;\n        shift_reg[1] <= 0;\n        shift_reg[2] <= 0;\n        shift_reg[3] <= 0;\n    end else begin\n        case(stage)\n            0: begin\n                shift_reg[0] <= in[7:0];\n                shift_reg[1] <= in[15:8];\n                shift_reg[2] <= in[23:16];\n                shift_reg[3] <= in[31:24];\n                stage <= 1;\n            end\n            1: begin\n                shift_reg[0] <= shift_reg[2];\n                shift_reg[1] <= shift_reg[3];\n                shift_reg[2] <= shift_reg[0];\n                shift_reg[3] <= shift_reg[1];\n                stage <= 2;\n            end\n            default: begin\n                stage <= 0;\n                shift_reg[0] <= 0;\n                shift_reg[1] <= 0;\n                shift_reg[2] <= 0;\n                shift_reg[3] <= 0;\n            end\n        endcase\n    end\nend\n\nassign out = {shift_reg[3], shift_reg[2], shift_reg[1], shift_reg[0]};\n\nendmodule",
        "module_name": "byte_reverse_pipeline",
        "module_hash": "0ddf171b07ffec0751870fbebaafad58",
        "dataset_index": 16290
      },
      "four_to_sixteen_decoder_675fc49e": {
        "rtl_code": "module four_to_sixteen_decoder (\n    input [1:0] sel,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            2'b00: out = 16'b0000000000000001;\n            2'b01: out = 16'b0000000000000010;\n            2'b10: out = 16'b0000000000000100;\n            2'b11: out = 16'b0000000000001000;\n            default: out = 16'b0000000000000000;\n        endcase\n    end\n\nendmodule",
        "module_name": "four_to_sixteen_decoder",
        "module_hash": "675fc49eae347aba83b8a13052f5a54c",
        "dataset_index": 21145
      },
      "mux4to1_6df1de6a": {
        "rtl_code": "\nmodule mux4to1 (\n    //# {{data|Data Signals}}\n    input  A,\n    input  B,\n    input  C,\n    input  D,\n    output reg X, // Changed from wire to reg\n\n    //# {{control|Control Signals}}\n    input  S0,\n    input  S1\n);\n\n    always @(*) begin\n        if (S1 == 0 && S0 == 0) begin\n            X = A;\n        end else if (S1 == 0 && S0 == 1) begin\n            X = B;\n        end else if (S1 == 1 && S0 == 0) begin\n            X = C;\n        end else if (S1 == 1 && S0 == 1) begin\n            X = D;\n        end\n    end\n\nendmodule\n",
        "module_name": "mux4to1",
        "module_hash": "6df1de6a77eacc95cfd0cfe7a781cb99",
        "dataset_index": 19857
      },
      "four_bit_complement_22f04d3a": {
        "rtl_code": "module four_bit_complement\n  (output reg [3:0] Y, input [3:0] A, input S);\n  \n  always @(*) begin\n    if(S == 0) begin\n      Y = ~A + 4'b1;\n    end\n    else begin\n      Y = ~A;\n    end\n  end\n  \nendmodule",
        "module_name": "four_bit_complement",
        "module_hash": "22f04d3acdc6497d408ef1b558694a8f",
        "dataset_index": 6659
      },
      "gray_code_4ae321de": {
        "rtl_code": "module gray_code (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @ (in) begin\n        out[3] = in[3];\n        out[2] = in[3] ^ in[2];\n        out[1] = in[2] ^ in[1];\n        out[0] = in[1] ^ in[0];\n    end\n\nendmodule",
        "module_name": "gray_code",
        "module_hash": "4ae321dea63e2ce169bcef80f1d742ea",
        "dataset_index": 13336
      },
      "scrambler #_2811234c": {
        "rtl_code": "\n\nmodule scrambler #(\n    parameter DATA_BYTE_WIDTH = 4\n)\n(\n    input   wire                                clk,\n    input   wire                                rst,\n\n    input   wire                                val_in,\n    input   wire    [DATA_BYTE_WIDTH*8 - 1:0]   data_in,\n    output  wire    [DATA_BYTE_WIDTH*8 - 1:0]   data_out\n);\n\nreg [15:0]  now;\nreg [31:0]  next;\n\nalways @ (posedge clk)\n    now <= rst ? 16'hf0f6 : val_in ? next[31:16] : now;\n\nassign  data_out = val_in ? data_in ^ next : data_in;\n\nalways @ (*)\n\n    begin\n        next[31] = now[12] ^ now[10] ^ now[7] ^ now[3] ^ now[1] ^ now[0];\n        next[30] = now[15] ^ now[14] ^ now[12] ^ now[11] ^ now[9] ^ now[6] ^ now[3] ^ now[2] ^ now[0];\n        next[29] = now[15] ^ now[13] ^ now[12] ^ now[11] ^ now[10] ^ now[8] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[28] = now[14] ^ now[12] ^ now[11] ^ now[10] ^ now[9] ^ now[7] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[27] = now[15] ^ now[14] ^ now[13] ^ now[12] ^ now[11] ^ now[10] ^ now[9] ^ now[8] ^ now[6] ^ now[1] ^ now[0];\n        next[26] = now[15] ^ now[13] ^ now[11] ^ now[10] ^ now[9] ^ now[8] ^ now[7] ^ now[5] ^ now[3] ^ now[0];\n        next[25] = now[15] ^ now[10] ^ now[9] ^ now[8] ^ now[7] ^ now[6] ^ now[4] ^ now[3] ^ now[2];\n        next[24] = now[14] ^ now[9] ^ now[8] ^ now[7] ^ now[6] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[23] = now[13] ^ now[8] ^ now[7] ^ now[6] ^ now[5] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[22] = now[15] ^ now[14] ^ now[7] ^ now[6] ^ now[5] ^ now[4] ^ now[1] ^ now[0];\n        next[21] = now[15] ^ now[13] ^ now[12] ^ now[6] ^ now[5] ^ now[4] ^ now[0];\n        next[20] = now[15] ^ now[11] ^ now[5] ^ now[4];\n        next[19] = now[14] ^ now[10] ^ now[4] ^ now[3];\n        next[18] = now[13] ^ now[9] ^ now[3] ^ now[2];\n        next[17] = now[12] ^ now[8] ^ now[2] ^ now[1];\n        next[16] = now[11] ^ now[7] ^ now[1] ^ now[0];\n\n        next[15] = now[15] ^ now[14] ^ now[12] ^ now[10] ^ now[6] ^ now[3] ^ now[0];\n        next[14] = now[15] ^ now[13] ^ now[12] ^ now[11] ^ now[9] ^ now[5] ^ now[3] ^ now[2];\n        next[13] = now[14] ^ now[12] ^ now[11] ^ now[10] ^ now[8] ^ now[4] ^ now[2] ^ now[1];\n        next[12] = now[13] ^ now[11] ^ now[10] ^ now[9] ^ now[7] ^ now[3] ^ now[1] ^ now[0];\n        next[11] = now[15] ^ now[14] ^ now[10] ^ now[9] ^ now[8] ^ now[6] ^ now[3] ^ now[2] ^ now[0];\n        next[10] = now[15] ^ now[13] ^ now[12] ^ now[9] ^ now[8] ^ now[7] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[9] = now[14] ^ now[12] ^ now[11] ^ now[8] ^ now[7] ^ now[6] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[8] = now[15] ^ now[14] ^ now[13] ^ now[12] ^ now[11] ^ now[10] ^ now[7] ^ now[6] ^ now[5] ^ now[1] ^ now[0];\n        next[7] = now[15] ^ now[13] ^ now[11] ^ now[10] ^ now[9] ^ now[6] ^ now[5] ^ now[4] ^ now[3] ^ now[0];\n        next[6] = now[15] ^ now[10] ^ now[9] ^ now[8] ^ now[5] ^ now[4] ^ now[2];\n        next[5] = now[14] ^ now[9] ^ now[8] ^ now[7] ^ now[4] ^ now[3] ^ now[1];\n        next[4] = now[13] ^ now[8] ^ now[7] ^ now[6] ^ now[3] ^ now[2] ^ now[0];\n        next[3] = now[15] ^ now[14] ^ now[7] ^ now[6] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[2] = now[14] ^ now[13] ^ now[6] ^ now[5] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[1] = now[15] ^ now[14] ^ now[13] ^ now[5] ^ now[4] ^ now[1] ^ now[0];\n        next[0] = now[15] ^ now[13] ^ now[4] ^ now[0];\n    end\n\n\nendmodule\n",
        "module_name": "scrambler #",
        "module_hash": "2811234c9604ee61b796cb3125491664",
        "dataset_index": 17491
      },
      "shifter_d36f6b27": {
        "rtl_code": "module shifter(\ninput [31:0] A, input [31:0] B, input aluc1,input aluc0,output  [31:0] Result,output Zero,\noutput Carry,\noutput Negative,\noutput Overflow\n);\nreg [31:0] Result_temp;\nreg Zero_temp;\nreg Carry_temp;\nreg Nagative_temp;\nreg Overflow_temp;\nreg [4:0] shift_amount;\n\n\nassign Zero     = Zero_temp;\nassign Carry    = Carry_temp;\nassign Negative = Nagative_temp;\nassign Overflow = Overflow_temp;\nassign Result   = Result_temp;\n\nalways @(*) begin\n    if( aluc1 == 0 && aluc0 == 0 )begin shift_amount = A[4:0];\n        Result_temp = $signed(B)>>>shift_amount;\n        if( Result_temp == 0 ) \n            Zero_temp = 1;\n        else \n            Zero_temp = 0;\n        Nagative_temp = B[31];\n        if ( shift_amount == 0) \n            Carry_temp = 0;\n        else \n            Carry_temp = B[shift_amount -1];\n        Overflow_temp = 0;\n        Nagative_temp=Result_temp[31];\n    end\n    else if( aluc1 == 0 && aluc0 == 1 )begin shift_amount = A[4:0];\n        Result_temp = B >> shift_amount;\n        if(Result_temp==0) \n            Zero_temp=1;\n        else \n            Zero_temp=0;\n        if(shift_amount==0)\n            Carry_temp=0;\n        else\n        Carry_temp=B[shift_amount-1];\n        Overflow_temp=0;\n        Nagative_temp = Result_temp[31];\n    end\n    else if( aluc1 == 1 && aluc0 == 0 )begin  shift_amount = A[4:0];\n        Result_temp = B<<shift_amount;\n        if ( Result_temp == 0)\n            Zero_temp = 1;\n        else \n            Zero_temp = 0;\n        if ( shift_amount ==0)\n            Carry_temp = 0;\n        else \n            Carry_temp=B[32-shift_amount]; \n        Overflow_temp = 0;  \n        Nagative_temp = Result_temp[31];\n    end\n    else if( aluc1 == 1 && aluc0 == 1 )begin shift_amount = A[4:0];\n        Result_temp=B<<shift_amount;\n        if (Result_temp == 0)\n            Zero_temp = 1;\n        else Zero_temp = 0;\n        if (shift_amount ==0)\n          Carry_temp = 0;\n        else \n        Carry_temp=B[32-shift_amount];\n        Overflow_temp = 0;\n        Nagative_temp = Result_temp[31];\n    end\nend\nendmodule   ",
        "module_name": "shifter",
        "module_hash": "d36f6b271f24dacb93e4ca8cc7688bb5",
        "dataset_index": 23804
      },
      "binary_gray_comparator_87c43577": {
        "rtl_code": "module binary_gray_comparator(\n    input [3:0] binary_in, // 4-bit binary input for binary-to-Gray code converter module\n    input [3:0] comp_in_1, // 4-bit input 1 for comparator module\n    input [3:0] comp_in_2, // 4-bit input 2 for comparator module\n    output [3:0] gray_out, // 4-bit Gray code output from binary-to-Gray code converter module\n    output comp_out, // 1-bit output from comparator module\n    output [3:0] shift_out // 4-bit output from functional module\n);\n\nassign gray_out[0] = binary_in[0];\nassign gray_out[1] = binary_in[0] ^ binary_in[1];\nassign gray_out[2] = binary_in[1] ^ binary_in[2];\nassign gray_out[3] = binary_in[2] ^ binary_in[3];\n\nassign comp_out = (comp_in_1[3] == comp_in_2[3]) ? \n                    ((comp_in_1[2] == comp_in_2[2]) ? \n                        ((comp_in_1[1] == comp_in_2[1]) ? \n                            (comp_in_1[0] >= comp_in_2[0]) : \n                        (comp_in_1[1] > comp_in_2[1])) : \n                    (comp_in_1[2] > comp_in_2[2])) : \n                (comp_in_1[3] > comp_in_2[3]);\n\nassign shift_out = (comp_out == 1) ? (gray_out << 1) : (gray_out >> 1);\n\nendmodule",
        "module_name": "binary_gray_comparator",
        "module_hash": "87c4357741eb179cdb6f4ecdae61c448",
        "dataset_index": 4676
      },
      "priority_encoder_418a77c6": {
        "rtl_code": "module priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @* begin\n    if (in[7]) pos = 3'b111; // MSB is high\n    else if (in[6]) pos = 3'b110; // Bit 6 is high\n    else if (in[5]) pos = 3'b101; // Bit 5 is high\n    else if (in[4]) pos = 3'b100; // Bit 4 is high\n    else if (in[3]) pos = 3'b011; // Bit 3 is high\n    else if (in[2]) pos = 3'b010; // Bit 2 is high\n    else if (in[1]) pos = 3'b001; // Bit 1 is high\n    else pos = 3'b000; // No bits are high\nend\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    output [2:0] pos\n);\n\nwire [2:0] pe_pos;\n\npriority_encoder pe(\n    .in(in),\n    .pos(pe_pos)\n);\n\nassign pos = pe_pos;\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "418a77c6291a10adbed6169b19029cbf",
        "dataset_index": 3150
      },
      "edge_detect_mux_cc074530": {
        "rtl_code": "\nmodule edge_detect_mux (\n    input clk,\n    input rst_n,\n    input a, b, c,\n    input select,\n    output reg rise,\n    output reg fall,\n    output reg w,\n    output reg x,\n    output reg y,\n    output reg z\n);\n\n    // State definitions\n    localparam [1:0]\n        IDLE = 2'b00,\n        RISING_EDGE = 2'b01,\n        FALLING_EDGE = 2'b10,\n        MUX_SELECT = 2'b11;\n\n    // State register and next state logic\n    reg [1:0] state, next_state;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output register and combinational logic\n    reg [2:0] mux_out;\n    always @(*) begin\n        case (select)\n            0: mux_out = {a, 2'b00};\n            1: mux_out = {b, 2'b00};\n            2: mux_out = {c, 2'b00};\n            default: mux_out = 3'b000; // Added a default case to break the logic loop\n        endcase\n        w = select;\n        x = mux_out[2];\n        y = mux_out[1];\n        z = mux_out[0];\n    end\n\n    // State machine\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                rise <= 1'b0;\n                fall <= 1'b0;\n                next_state = RISING_EDGE;\n            end\n            RISING_EDGE: begin\n                rise <= a; // Fixed the edge detection logic for the rising edge\n                fall <= 1'b0;\n                next_state = FALLING_EDGE;\n            end\n            FALLING_EDGE: begin\n                rise <= 1'b0;\n                fall <= ~a; // Fixed the edge detection logic for the falling edge\n                next_state = MUX_SELECT;\n            end\n            MUX_SELECT: begin\n                rise <= 1'b0;\n                fall <= 1'b0;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule",
        "module_name": "edge_detect_mux",
        "module_hash": "cc0745309e7114524699e5ebc82f5d29",
        "dataset_index": 12478
      },
      "axis_rate_limit_64 #_3e94238c": {
        "rtl_code": "\n\n\nmodule axis_rate_limit_64 #\n(\n    parameter DATA_WIDTH = 64,\n    parameter KEEP_WIDTH = (DATA_WIDTH/8)\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]  input_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  input_axis_tkeep,\n    input  wire                   input_axis_tvalid,\n    output wire                   input_axis_tready,\n    input  wire                   input_axis_tlast,\n    input  wire                   input_axis_tuser,\n\n    \n    output wire [DATA_WIDTH-1:0]  output_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  output_axis_tkeep,\n    output wire                   output_axis_tvalid,\n    input  wire                   output_axis_tready,\n    output wire                   output_axis_tlast,\n    output wire                   output_axis_tuser,\n\n    \n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\nreg [DATA_WIDTH-1:0] output_axis_tdata_int;\nreg [KEEP_WIDTH-1:0] output_axis_tkeep_int;\nreg                  output_axis_tvalid_int;\nreg                  output_axis_tready_int = 0;\nreg                  output_axis_tlast_int;\nreg                  output_axis_tuser_int;\nwire                 output_axis_tready_int_early;\n\nreg [23:0] acc_reg = 0, acc_next;\nreg pause;\nreg frame_reg = 0, frame_next;\n\nreg input_axis_tready_reg = 0, input_axis_tready_next;\nassign input_axis_tready = input_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 0;\n    frame_next = frame_reg & ~input_axis_tlast;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (input_axis_tready & input_axis_tvalid) begin\n        frame_next = ~input_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (rate_by_frame) begin\n            pause = ~frame_next;\n        end else begin\n            pause = 1;\n        end\n    end\n\n    input_axis_tready_next = output_axis_tready_int_early & ~pause;\n\n    output_axis_tdata_int = input_axis_tdata;\n    output_axis_tkeep_int = input_axis_tkeep;\n    output_axis_tvalid_int = input_axis_tvalid & input_axis_tready;\n    output_axis_tlast_int = input_axis_tlast;\n    output_axis_tuser_int = input_axis_tuser;\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        acc_reg <= 0;\n        frame_reg <= 0;\n        input_axis_tready_reg <= 0;\n    end else begin\n        acc_reg <= acc_next;\n        frame_reg <= frame_next;\n        input_axis_tready_reg <= input_axis_tready_next;\n    end\nend\n\nreg [DATA_WIDTH-1:0] output_axis_tdata_reg = 0;\nreg [KEEP_WIDTH-1:0] output_axis_tkeep_reg = 0;\nreg                  output_axis_tvalid_reg = 0;\nreg                  output_axis_tlast_reg = 0;\nreg                  output_axis_tuser_reg = 0;\n\nreg [DATA_WIDTH-1:0] temp_axis_tdata_reg = 0;\nreg [KEEP_WIDTH-1:0] temp_axis_tkeep_reg = 0;\nreg                  temp_axis_tvalid_reg = 0;\nreg                  temp_axis_tlast_reg = 0;\nreg                  temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tkeep_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tkeep_reg <= output_axis_tkeep_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tkeep_reg <= output_axis_tkeep_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tkeep_reg <= temp_axis_tkeep_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tkeep_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "axis_rate_limit_64 #",
        "module_hash": "3e94238cbd4666aa8e130c2d5626e264",
        "dataset_index": 8137
      },
      "_4bit_binary_multiplier_c871007a": {
        "rtl_code": "\nmodule _4bit_binary_multiplier(\n\n    input start, clk,\n    input [3:0] multiplier_address, multiplicand_address,\n    output [7:0] p,\n    output reg done\n    \n    );\n\n    reg [3:0] multiplier, multiplicand;\n    reg [7:0] product;\n    reg [3:0] counter;\n    reg [3:0] adder_input;\n    reg [7:0] adder_output;\n    reg [3:0] shift_input;\n    reg [3:0] shift_output;\n    reg [3:0] shift_reg [0:3];\n    reg [7:0] shift_reg_output;\n    \n    integer i;\n    \n    always @(posedge clk) begin\n        if (start) begin\n            multiplier <= multiplier_address;\n            multiplicand <= multiplicand_address;\n            counter <= 4'b0000;\n            product <= 8'b00000000;\n            done <= 0;\n        end else begin\n            if (counter == 4'b0000) begin\n                adder_input <= 4'b0000;\n                shift_input <= multiplicand;\n            end else begin\n                adder_input <= {shift_output, multiplier[counter-1]};\n                shift_input <= shift_reg_output;\n            end\n            adder_output <= adder_input + shift_input;\n            shift_output <= shift_reg[3];\n            for (i = 3; i > 0; i = i - 1) begin\n                shift_reg[i] <= shift_reg[i-1];\n            end\n            shift_reg[0] <= adder_output[3:0];\n            shift_reg_output <= {shift_reg[3], shift_reg[2], shift_reg[1], shift_reg[0]};\n            product <= {shift_reg_output, adder_output[7:4]};\n            counter <= counter + 1;\n            if (counter == 4'b0100) begin\n                done <= 1;\n            end\n        end\n    end\n    \n    assign p = product;\n    \nendmodule",
        "module_name": "_4bit_binary_multiplier",
        "module_hash": "c871007ae4f98a9358584e4d6c5d36f8",
        "dataset_index": 13164
      },
      "simple_calculator_6c317151": {
        "rtl_code": "module simple_calculator(\n    input [1:0] operation,\n    input signed [63:0] operands,\n    output signed [31:0] result\n);\n\nreg signed [31:0] op1;\nreg signed [31:0] op2;\nreg signed [31:0] res;\n\nalways @(*) begin\n    op1 = operands[31:0];\n    op2 = operands[63:32];\n    case(operation)\n        2'b00: res = op1 + op2; // Addition\n        2'b01: res = op1 - op2; // Subtraction\n        2'b10: res = op1 * op2; // Multiplication\n        2'b11: res = op1 / op2; // Division\n    endcase\nend\n\nassign result = res;\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "6c317151b4989b3661cc06edc5b0707c",
        "dataset_index": 4627
      },
      "d_ff_en_clk_gate_f4bfa6c9": {
        "rtl_code": "\nmodule d_ff_en_clk_gate (\n  input CLK,\n  input EN,\n  input TE,\n  input [31:0] DATA_IN,\n  output reg DATA_OUT\n);\n\n  reg d_ff_en;\n  wire ENCLK;\n\nendmodule\n\nmodule TLATNTSCAX2TS (\n    input E,\n    input SE,\n    input CK,\n    output ECK\n);\n\n    assign ECK = E & SE & CK;\n\nendmodule\n",
        "module_name": "d_ff_en_clk_gate",
        "module_hash": "f4bfa6c953689d83a73620ac1f849a98",
        "dataset_index": 21330
      },
      "scp_sender_7a99c464": {
        "rtl_code": "module scp_sender(\n    input CHANNEL_UP,\n    input USER_CLK,\n    output reg rst_r,\n    output reg start_r,\n    output reg run_r\n);\n\n    //Control state machine state registers\n    always @(posedge USER_CLK)\n        if(!CHANNEL_UP) \n        begin\n            rst_r       <=  1'b1;\n            start_r     <=  1'b0;\n            run_r       <=  1'b0;\n        end\n        else\n        begin\n            rst_r       <=  1'b0;\n            start_r     <=  next_start_c;\n            run_r       <=  next_run_c;\n        end\n\n\n    //Nextstate logic\n    \n    wire next_start_c, next_run_c;\n    // After reset, send the SCP character to open the infinite \n    // frame \n    assign  next_start_c    =   rst_r;\n\n    \n    // After the start state, go to normal operation \n    assign  next_run_c      =   start_r ||\n                                run_r;\n      \nendmodule",
        "module_name": "scp_sender",
        "module_hash": "7a99c464f8e8150a283c3441486d0822",
        "dataset_index": 11286
      },
      "PWM32_05349def": {
        "rtl_code": "module PWM32 (\n    input wire clk,\n    input wire rst,\n    input wire [31:0] PRE,\n    input wire [31:0] TMRCMP1,\n    input wire [31:0] TMRCMP2,\n    input wire \t\t\t\tTMREN,\n    output reg pwm\n);\n\n\treg [31:0]\tTMR;\n\treg [31:0] \tclkdiv;\n\twire \t\ttimer_clk = (clkdiv==PRE) ;\n\twire \t\ttmrov = (TMR == TMRCMP1);\n\twire \t\tpwmov = (TMR == TMRCMP2);\n\n\t// Prescalar\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tclkdiv <= 32'd0;\n\t\telse if(timer_clk)\n\t\t\tclkdiv <= 32'd0;\n\t\telse if(TMREN)\n\t\t\tclkdiv <= clkdiv + 32'd1;\n\tend\n\n\t// Timer\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tTMR <= 32'd0;\n\t\telse if(tmrov)\n\t\t\tTMR <= 32'd0;\n\t\telse if(timer_clk)\n\t\t\tTMR <= TMR + 32'd1;\n\tend\n\n\t// PWM Output\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tpwm <= 1'd0;\n\t\telse if(pwmov)\n\t\t\tpwm <= 1'd1;\n\t\telse if (tmrov)\n\t\t\tpwm <= 1'd0;\n\tend\n\nendmodule",
        "module_name": "PWM32",
        "module_hash": "05349def6a331b4d565de811fa2b6250",
        "dataset_index": 70
      },
      "adder_tree_top_e6e9123d": {
        "rtl_code": "`define ADDER_WIDTH 022\n`define DUMMY_WIDTH 128\n\n`define 2_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "e6e9123d1722e260f4048b2171f2ea20",
        "dataset_index": 24903
      },
      "PWMModule_3f581661": {
        "rtl_code": "module PWMModule (\n    input clock,\n    input reset,\n    input [7:0] dutyCycle,\n    output reg pwm,\n    output reg done\n);\n\n    reg [23:0] counter = 0;\n    reg [7:0] threshold = 0;\n    reg [7:0] duty = 0;\n\n    always @(posedge clock) begin\n        if (reset) begin\n            counter <= 0;\n            threshold <= 0;\n            duty <= 0;\n            pwm <= 0;\n            done <= 0;\n        end else begin\n            // calculate threshold based on duty cycle\n            duty <= dutyCycle;\n            threshold <= (256 * (duty / 100)) - 1;\n            \n            // increment counter and reset at end of cycle\n            if (counter == 999) begin\n                counter <= 0;\n                done <= 1;\n            end else begin\n                counter <= counter + 1;\n                done <= 0;\n            end\n            \n            // set pwm value based on counter and threshold\n            if (counter < threshold) begin\n                pwm <= 1;\n            end else begin\n                pwm <= 0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "PWMModule",
        "module_hash": "3f5816618647f95e0ef8f954cf2b4de7",
        "dataset_index": 14377
      },
      "mux_16to1_d21c5cd1": {
        "rtl_code": "module mux_16to1 (\n  input [15:0] in0,\n  input [15:0] in1,\n  input [15:0] in2,\n  input [15:0] in3,\n  input [15:0] in4,\n  input [15:0] in5,\n  input [15:0] in6,\n  input [15:0] in7,\n  input [15:0] in8,\n  input [15:0] in9,\n  input [15:0] in10,\n  input [15:0] in11,\n  input [15:0] in12,\n  input [15:0] in13,\n  input [15:0] in14,\n  input [15:0] in15,\n  input [4:0] sel,\n  output reg [31:0] out\n);\n\n  always @(*) begin\n    case (sel)\n      5'b00000: out = in0;\n      5'b00001: out = in1;\n      5'b00010: out = in2;\n      5'b00011: out = in3;\n      5'b00100: out = in4;\n      5'b00101: out = in5;\n      5'b00110: out = in6;\n      5'b00111: out = in7;\n      5'b01000: out = in8;\n      5'b01001: out = in9;\n      5'b01010: out = in10;\n      5'b01011: out = in11;\n      5'b01100: out = in12;\n      5'b01101: out = in13;\n      5'b01110: out = in14;\n      5'b01111: out = in15;\n      default: out = 32'b0;\n    endcase\n  end\n\nendmodule\n",
        "module_name": "mux_16to1",
        "module_hash": "d21c5cd1697affe24113060acdd5bed6",
        "dataset_index": 8703
      },
      "clk_divider_cfd723e7": {
        "rtl_code": "module clk_divider(\n    input inclk,\n    input ena,\n    output enaout,\n    output reg outclk\n);\n\nparameter clock_type = \"auto\";\nparameter ena_register_mode = \"always enabled\";\nparameter lpm_type = \"cyclone10gx_clkena\";\nparameter ena_register_power_up = \"high\";\nparameter disable_mode = \"low\";\nparameter test_syn = \"high\";\n\nreg ena_reg;\n\nalways @ (posedge inclk) begin\n    if (ena_register_mode == \"always enabled\") begin\n        ena_reg <= 1'b1;\n    end else if (ena_register_mode == \"synchronous\") begin\n        ena_reg <= ena;\n    end else if (ena_register_mode == \"asynchronous\") begin\n        ena_reg <= ena_reg | ena;\n    end\nend\n\nassign enaout = ena_reg;\n\nalways @ (posedge inclk) begin\n    if (ena == 1'b1) begin\n        outclk <= ~outclk;\n    end else begin\n        outclk <= 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "clk_divider",
        "module_hash": "cfd723e7a544428d95358cabac0dab4d",
        "dataset_index": 7036
      },
      "clk_gen #_aa71cf0d": {
        "rtl_code": "\n\nmodule clk_gen #(\n    parameter res    = 20,    parameter phase  =  1     )(\n    input      clk_i, input      rst_i,\n    output     clk_o  );\n\n  reg [res-1:0] cnt;\n\n  assign clk_o = cnt[res-1];\n\n  always @(posedge clk_i)\n    cnt <= rst_i ? {res{1'b0}} : (cnt + phase);\n\nendmodule\n",
        "module_name": "clk_gen #",
        "module_hash": "aa71cf0d7c17e10118224deac52cb4aa",
        "dataset_index": 25407
      },
      "fsm_vending_machine_2c16ed3d": {
        "rtl_code": "module fsm_vending_machine (\n  input clk,\n  input reset,\n  input coin_inserted,\n  input [1:0] item_selected,\n  input item_dispensed,\n  output reg dispense_item,\n  output reg return_coin\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter ITEM_SELECTED = 2'b01;\n  parameter ITEM_DISPENSED = 2'b10;\n\n  // Define the current state\n  reg [1:0] state;\n\n  // Define the next state\n  reg [1:0] next_state;\n\n  // Define the state transition logic\n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Define the state output logic\n  always @ (state, coin_inserted, item_selected, item_dispensed) begin\n    case (state)\n      IDLE: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        if (coin_inserted && item_selected != 2'b00) begin\n          next_state <= ITEM_SELECTED;\n        end else begin\n          next_state <= IDLE;\n        end\n      end\n      ITEM_SELECTED: begin\n        dispense_item <= 1;\n        return_coin <= 0;\n        if (item_dispensed) begin\n          next_state <= ITEM_DISPENSED;\n        end else begin\n          next_state <= ITEM_SELECTED;\n        end\n      end\n      ITEM_DISPENSED: begin\n        dispense_item <= 0;\n        return_coin <= 1;\n        next_state <= IDLE;\n      end\n      default: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        next_state <= IDLE;\n      end\n    endcase\n  end\n\nendmodule\n",
        "module_name": "fsm_vending_machine",
        "module_hash": "2c16ed3ddb375fb5fb4658d9246495c8",
        "dataset_index": 3717
      },
      "POR_d00ac407": {
        "rtl_code": "module POR (\n  input vdd, // power supply signal\n  input clk, // clock signal\n  output reg rst // reset signal\n);\n\n  reg [23:0] counter; // 24-bit counter for delay time\n  \n  always @(posedge clk) begin\n    if (vdd == 1'b0) begin // power removed\n      rst <= 1'b1; // set reset signal high\n      counter <= 0; // reset counter\n    end\n    else if (counter == 24'd100000) begin // delay time elapsed\n      rst <= 1'b0; // set reset signal low\n    end\n    else begin // count up\n      counter <= counter + 1;\n    end\n  end\n  \nendmodule",
        "module_name": "POR",
        "module_hash": "d00ac40752e033cae880ad49985b6c8f",
        "dataset_index": 1717
      },
      "sky130_fd_sc_hdll__xnor2_6a5dfdc5": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__xnor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire xnor0_out_Y;\n\n    xnor xnor0 (xnor0_out_Y, A, B           );\n    buf  buf0  (Y          , xnor0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__xnor2",
        "module_hash": "6a5dfdc51124b89bb94a03d117032823",
        "dataset_index": 15000
      },
      "dffr_9_c64204f0": {
        "rtl_code": "module dffr_9 ( clk, reset, d, q );\n\t// synthesis attribute keep_hierarchy dffr_9 \"true\";\n\tinput clk;\n\tinput reset;\n\tinput [8:0] d;\n\toutput [8:0] q;\n\treg [8:0] q;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 9'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule",
        "module_name": "dffr_9",
        "module_hash": "c64204f007155abded45043987f26048",
        "dataset_index": 11874
      },
      "regfile_1fb55019": {
        "rtl_code": "module regfile(\n  input clk,\n  input we,\n  input [3:0] wa,\n  input [7:0] wd,\n  input [3:0] ra,\n  output [7:0] rd,\n  output [3:0] out\n);\n\n  reg [7:0] data [0:15];\n  reg [3:0] addr;\n  \n  always @(posedge clk) begin\n    if (we) begin\n      data[wa] <= wd;\n    end\n    addr <= ra;\n  end\n  \n  assign rd = data[addr];\n  assign out = addr;\n  \nendmodule",
        "module_name": "regfile",
        "module_hash": "1fb550195dceb24f901db7d9f0f5f407",
        "dataset_index": 530
      },
      "trigger_output_c5947d1a": {
        "rtl_code": "module trigger_output (\n    input [4:0] src_async,\n    input [4:0] src_sync,\n    input [4:0] src_single,\n    input [4:0] src_gen,\n    input [4:0] src_pg,\n    input sel_async,\n    input sel_sync,\n    input sel_single,\n    input sel_gen,\n    input sel_pg,\n    input sel_chain,\n    input sel_dir_async,\n    input sel_dir_sync,\n    input sel_dir_single,\n    input sel_dir_gen,\n    input sel_dir_pg,\n    output [4:0] dst_tbm,\n    output [4:0] dst_sync,\n    output [4:0] dst_tbm_pos,\n    output [4:0] dst_sync_direct,\n    output [4:0] dst_dir\n);\n\n    localparam SYN = 0;\n    localparam TRG = 1;\n    localparam RSR = 2;\n    localparam RST = 3;\n    localparam CAL = 4;\n\n    // switch\n    wire [4:0] src_async_gated = {5{sel_async}} & src_async;\n    wire [4:0] src_sync_gated = {5{sel_sync}} & src_sync;\n    wire [4:0] src_single_gated = {5{sel_single}} & src_single;\n    wire [4:0] src_gen_gated = {5{sel_gen}} & src_gen;\n    wire [4:0] src_pg_gated = {5{sel_pg}} & src_pg;\n\n    wire [4:0] sum = src_async_gated | src_sync_gated | src_single_gated | src_gen_gated | src_pg_gated;\n\n    assign dst_sync_direct = sel_chain & src_sync;\n\n    assign dst_tbm = sum;\n    assign dst_sync = {5{sel_sync}} & (!sel_chain & sum);\n\n    assign dst_tbm_pos = {src_async[1], src_async_gated[1], src_async_gated[1], src_async_gated[1], src_async_gated[1]};\n\n    // dir\n    wire [4:0] src_dir_async_gated = {5{sel_dir_async}} & src_async;\n    wire [4:0] src_dir_sync_gated = {5{sel_dir_sync}} & src_sync;\n    wire [4:0] src_dir_single_gated = {5{sel_dir_single}} & src_single;\n    wire [4:0] src_dir_gen_gated = {5{sel_dir_gen}} & src_gen;\n    wire [4:0] src_dir_pg_gated = {5{sel_dir_pg}} & src_pg;\n\n    wire [4:0] sum_dir = src_dir_async_gated | src_dir_sync_gated | src_dir_single_gated | src_dir_gen_gated | src_dir_pg_gated;\n\n    assign dst_dir = sum_dir;\n\nendmodule",
        "module_name": "trigger_output",
        "module_hash": "c5947d1a2cc8a522c576f54c66cb0345",
        "dataset_index": 13235
      },
      "ps2_rx_4bfe9ee6": {
        "rtl_code": "module ps2_rx\n   (\n    input wire clk, reset,\n    inout wire ps2d, ps2c, \n\t input wire rx_en,\n    output reg rx_done_tick,\n    output wire [7:0] dout\n   );\n\n   localparam [1:0]\n      idle = 2'b00,\n      dps  = 2'b01,\n      load = 2'b10;\n\n   reg [1:0] state_reg, state_next;\n   reg [7:0] filter_reg;\n   wire [7:0] filter_next;\n   reg f_ps2c_reg;\n   wire f_ps2c_next;\n   reg [3:0] n_reg, n_next;\n   reg [10:0] b_reg, b_next;\n   wire fall_edge;\n\n   always @(posedge clk, posedge reset)\n   if (reset)\n      begin\n         filter_reg <= 0;\n         f_ps2c_reg <= 0;\n      end\n   else\n      begin\n         filter_reg <= filter_next;\n         f_ps2c_reg <= f_ps2c_next;\n      end\n\n   assign filter_next = {ps2c, filter_reg[7:1]};\n   assign f_ps2c_next = (filter_reg==8'b11111111) ? 1'b1 :\n                        (filter_reg==8'b00000000) ? 1'b0 :\n                         f_ps2c_reg;\n   assign fall_edge = f_ps2c_reg & ~f_ps2c_next;\n\n   always @(posedge clk, posedge reset)\n      if (reset)\n         begin\n            state_reg <= idle;\n            n_reg <= 0;\n            b_reg <= 0;\n         end\n      else\n         begin\n            state_reg <= state_next;\n            n_reg <= n_next;\n            b_reg <= b_next;\n         end\n   always @*\n   begin\n      state_next = state_reg;\n      rx_done_tick = 1'b0;\n      n_next = n_reg;\n      b_next = b_reg;\n      case (state_reg)\n         idle:\n            if (fall_edge & rx_en)\n               begin\n                  b_next = {ps2d, b_reg[10:1]};\n                  n_next = 4'b1001;\n                  state_next = dps;\n               end\n         dps: if (fall_edge)\n               begin\n                  b_next = {ps2d, b_reg[10:1]};\n                  if (n_reg==0)\n                     state_next = load;\n                  else\n                     n_next = n_reg - 1'b1;\n               end\n         load: begin\n               state_next = idle;\n               rx_done_tick = 1'b1;\n            end\n      endcase\n   end\n   assign dout = b_reg[8:1]; endmodule",
        "module_name": "ps2_rx",
        "module_hash": "4bfe9ee68cf3383ab39ecdbcd60bb76f",
        "dataset_index": 4887
      },
      "sparc_exu_aluor32_9052fb26": {
        "rtl_code": "\n\n\nmodule sparc_exu_aluor32\n  (\n   out, \n   in\n   );\n\n   input [31:0] in;         output       out;       wire         nor1_1;\n   wire         nor1_2;\n   wire         nor1_3;\n   wire         nor1_4;\n   wire         nor1_5;\n   wire         nor1_6;\n   wire         nor1_7;\n   wire         nor1_8;\n   wire         nor1_9;\n   wire         nor1_10;\n   wire         nor1_11;\n   wire         nor1_12;\n   wire         nor1_13;\n   wire         nor1_14;\n   wire         nor1_15;\n   wire         nor1_16;\n   wire         nand2_1;\n   wire         nand2_2;\n   wire         nand2_3;\n   wire         nand2_4;\n   wire         inv3_1;\n   wire         inv3_2;\n   wire         inv3_3;\n   wire         inv3_4;\n\n   assign       nor1_1 = ~(in[1] | in[0]);\n   assign       nor1_2 = ~(in[3] | in[2]);\n   assign       nor1_3 = ~(in[5] | in[4]);\n   assign       nor1_4 = ~(in[7] | in[6]);\n   assign       nor1_5 = ~(in[9] | in[8]);\n   assign       nor1_6 = ~(in[11] | in[10]);\n   assign       nor1_7 = ~(in[13] | in[12]);\n   assign       nor1_8 = ~(in[15] | in[14]);\n   assign       nor1_9 = ~(in[17] | in[16]);\n   assign       nor1_10 = ~(in[19] | in[18]);\n   assign       nor1_11 = ~(in[21] | in[20]);\n   assign       nor1_12 = ~(in[23] | in[22]);\n   assign       nor1_13 = ~(in[25] | in[24]);\n   assign       nor1_14 = ~(in[27] | in[26]);\n   assign       nor1_15 = ~(in[29] | in[28]);\n   assign       nor1_16 = ~(in[31] | in[30]);\n\n   assign       nand2_1 = ~(nor1_1 & nor1_2 & nor1_3 & nor1_4);\n   assign       nand2_2 = ~(nor1_5 & nor1_6 & nor1_7 & nor1_8);\n   assign       nand2_3 = ~(nor1_9 & nor1_10 & nor1_11 & nor1_12);\n   assign       nand2_4 = ~(nor1_13 & nor1_14 & nor1_15 & nor1_16);\n\n   assign       inv3_1 = ~nand2_1;\n   assign       inv3_2 = ~nand2_2;\n   assign       inv3_3 = ~nand2_3;\n   assign       inv3_4 = ~nand2_4;\n\n   assign       out = ~(inv3_1 & inv3_2 & inv3_3 & inv3_4);\n\nendmodule ",
        "module_name": "sparc_exu_aluor32",
        "module_hash": "9052fb26422be4801a6131903b7c5dcc",
        "dataset_index": 12656
      },
      "my__b380152a": {
        "rtl_code": "module my_module (g, p, g_prec, p_prec, g_out, p_out);\n  input g, p, g_prec, p_prec;\n  output g_out, p_out;\n  wire n5;\n\n  // AOI21 gate implementation\n  assign n5 = ~(g_prec & p | ~g & p);\n\n  // AND2 gate implementation\n  assign p_out = p & p_prec;\n\n  // Inverter implementation\n  assign g_out = ~n5;\nendmodule",
        "module_name": "my_",
        "module_hash": "b380152a62112597fecb7bd0f09e4b9a",
        "dataset_index": 872
      },
      "twos_complement_ab779fb2": {
        "rtl_code": "module twos_complement (\n    input [3:0] A,\n    output reg [3:0] OUT\n);\n\n    always @ (A) begin\n        OUT <= ~A + 1;\n    end\n\nendmodule",
        "module_name": "twos_complement",
        "module_hash": "ab779fb2566dc7fefab97ff661644d73",
        "dataset_index": 1459
      },
      "PCIeGen2x8If128_gtp_pipe_rate #_f3b94775": {
        "rtl_code": "\n\n\n\n\nmodule PCIeGen2x8If128_gtp_pipe_rate #\n(\n\n    parameter PCIE_SIM_SPEEDUP = \"FALSE\",                   parameter TXDATA_WAIT_MAX  = 4'd15                      )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_DRP_DONE,\n    input               RATE_RXPMARESETDONE,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output              RATE_DRP_START,\n    output              RATE_DRP_X16,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [ 4:0]  RATE_FSM\n\n);\n\n        reg         [ 1:0]  rate_in_reg1;\n    reg                 drp_done_reg1;\n    reg                 rxpmaresetdone_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg         [ 1:0]  rate_in_reg2;\n    reg                 drp_done_reg2;\n    reg                 rxpmaresetdone_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel =  1'd0; \n    reg         [ 2:0]  rate_out =  3'd0; \n    reg         [ 3:0]  fsm      =  0;                 \n   \n    localparam          FSM_IDLE           = 0; \n    localparam          FSM_TXDATA_WAIT    = 1;           \n    localparam          FSM_PCLK_SEL       = 2; \n    localparam          FSM_DRP_X16_START  = 3;\n    localparam          FSM_DRP_X16_DONE   = 4;   \n    localparam          FSM_RATE_SEL       = 5;\n    localparam          FSM_RXPMARESETDONE = 6; \n    localparam          FSM_DRP_X20_START  = 7;\n    localparam          FSM_DRP_X20_DONE   = 8;   \n    localparam          FSM_RATE_DONE      = 9;\n    localparam          FSM_TXSYNC_START   = 10;\n    localparam          FSM_TXSYNC_DONE    = 11;             \n    localparam          FSM_DONE           = 12; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rate_in_reg1        <= 2'd0;\n        drp_done_reg1       <= 1'd0;\n        rxpmaresetdone_reg1 <= 1'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        drp_done_reg2       <= 1'd0;\n        rxpmaresetdone_reg2 <= 1'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rate_in_reg1        <= RATE_RATE_IN;\n        drp_done_reg1       <= RATE_DRP_DONE;\n        rxpmaresetdone_reg1 <= RATE_RXPMARESETDONE;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rate_in_reg2        <= rate_in_reg1;\n        drp_done_reg2       <= drp_done_reg1;\n        rxpmaresetdone_reg2 <= rxpmaresetdone_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if ((fsm == FSM_RATE_DONE) || (fsm == FSM_RXPMARESETDONE) || (fsm == FSM_DRP_X20_START) || (fsm == FSM_DRP_X20_DONE))\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm      <= FSM_IDLE;\n        pclk_sel <= 1'd0; \n        rate_out <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm      <= FSM_TXDATA_WAIT;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            else\n                begin\n                fsm      <= FSM_IDLE;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            end \n            \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm      <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_SEL : FSM_DRP_X16_START;    \n            pclk_sel <= (rate_in_reg2 == 2'd1);\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X16_DONE : FSM_DRP_X16_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_SEL : FSM_DRP_X16_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_DONE : FSM_RXPMARESETDONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate;                               end    \n            \n        FSM_RXPMARESETDONE :\n        \n            begin\n            fsm      <= (!rxpmaresetdone_reg2) ? FSM_DRP_X20_START : FSM_RXPMARESETDONE;  \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end  \n            \n        FSM_DRP_X20_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X20_DONE : FSM_DRP_X20_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X20_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_DONE : FSM_DRP_X20_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone) \n                fsm <= FSM_TXSYNC_START;\n            else      \n                fsm <= FSM_RATE_DONE;\n            \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm      <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm      <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm      <= FSM_IDLE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm      <= FSM_IDLE;\n            pclk_sel <= 1'd0; \n            rate_out <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL     = pclk_sel;\nassign RATE_DRP_START    = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X20_START); \nassign RATE_DRP_X16      = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X16_DONE);\nassign RATE_RATE_OUT     = rate_out;\nassign RATE_TXSYNC_START = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE         = (fsm == FSM_DONE);\nassign RATE_IDLE         = (fsm == FSM_IDLE);\nassign RATE_FSM          = {1'd0, fsm};   \n\n\n\nendmodule\n",
        "module_name": "PCIeGen2x8If128_gtp_pipe_rate #",
        "module_hash": "f3b94775765d279959e507f60f357b9e",
        "dataset_index": 25474
      },
      "Serial_in_parallel_out_enable_behavior_0605622c": {
        "rtl_code": "\nmodule Serial_in_parallel_out_enable_behavior(\n\n    input Clk, ShiftIn, reset, ShiftEn,\n    output wire ShiftOut,\n    output wire [3:0] ParallelOut\n    );\n\n    reg [15:0] ShiftReg;\n    reg [3:0] ParallelReg;\n\n    always @(posedge Clk) begin\n        if (reset) begin\n            ShiftReg <= 16'h0000;\n        end\n        else if (ShiftEn) begin\n            ShiftReg <= {ShiftReg[14:0], ShiftIn};\n        end\n    end\n\n    always @(posedge Clk) begin\n        if (reset) begin\n            ParallelReg <= 4'b0000;\n        end\n        else if (ShiftEn) begin\n            ParallelReg[0] <= ShiftReg[3:0];\n            ParallelReg[1] <= ShiftReg[7:4];\n            ParallelReg[2] <= ShiftReg[11:8];\n            ParallelReg[3] <= ShiftReg[15:12];\n        end\n    end\n\n    assign ShiftOut = ShiftReg[15];\n    assign ParallelOut = ParallelReg;\n\nendmodule\n",
        "module_name": "Serial_in_parallel_out_enable_behavior",
        "module_hash": "0605622c56f23911683f02c672f8a3a7",
        "dataset_index": 18705
      },
      "three_input_gate_955ff18e": {
        "rtl_code": "module three_input_gate (\n    input  A1,\n    input  A2,\n    input  B1,\n    output Y\n);\n\n    assign Y = (A1 & A2) | B1;\n\nendmodule",
        "module_name": "three_input_gate",
        "module_hash": "955ff18e0d19d7ed9cd51ad609bbd797",
        "dataset_index": 18733
      },
      "counter_c9f4e5d7": {
        "rtl_code": "module counter (\n  input clk,\n  input rst,\n  input up_down,\n  output reg [7:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 8'd0;\n    end else if (up_down) begin\n      if (count == 8'd255) begin\n        count <= 8'd0;\n      end else begin\n        count <= count + 1;\n      end\n    end else begin\n      if (count == 8'd0) begin\n        count <= 8'd255;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "c9f4e5d76b1d6d067b3ec03f02555238",
        "dataset_index": 220
      },
      "adder_b5eeb7f6": {
        "rtl_code": "module adder(A, B, sum);\n  input [3:0] A, B;\n  output reg [4:0] sum;\n  \n  always @* begin\n    sum = A + B;\n    if (sum > 15) begin\n      sum = sum[3:0];\n    end\n  end\nendmodule\n\n",
        "module_name": "adder",
        "module_hash": "b5eeb7f6daa7898285df7573034f2d57",
        "dataset_index": 538
      },
      "priority_encoder_4f4a5428": {
        "rtl_code": "\nmodule priority_encoder (\n    input A, B, C, D, // Inputs for the priority encoder\n    output reg [1:0] Y // 2-bit output from the priority encoder\n);\n\nalways @* begin\n    if ({A, B, C, D}==4'b1110) Y = 2'b11;\n    else if ({A, B, C, D}==4'b1101) Y = 2'b10;\n    else if ({A, B, C, D}==4'b1011) Y = 2'b01;\n    else if ({A, B, C, D}==4'b0111) Y = 2'b00;\n    else Y = 2'b00;\nend\n\nendmodule\nmodule barrel_shifter (\n    input [3:0] data, // 4-bit input for the barrel shifter\n    input [1:0] shift, // 2-bit input for the barrel shifter\n    output reg [3:0] q // 4-bit output from the barrel shifter\n);\n\nalways @* begin\n    case (shift)\n        2'b00: q = data;\n        2'b01: q = {data[3:1], data[0]};\n        2'b10: q = {data[2:0], data[3]};\n        2'b11: q = {data[1:0], data[3:2]};\n        default: q = data;\n    endcase\nend\n\nendmodule\nmodule functional_module (\n    input [1:0] Y, // 2-bit input from the priority encoder\n    input [3:0] data, // 4-bit input from the barrel shifter\n    output [3:0] q // 4-bit output from the functional module\n);\n\nassign q = (Y | data);\n\nendmodule\nmodule top_module (\n    input A, B, C, D, // Inputs for the priority encoder\n    input [3:0] data, // 4-bit input for the barrel shifter\n    input [1:0] shift, // 2-bit input for the barrel shifter\n    output [3:0] q // 4-bit output from the functional module\n);\n\nwire [1:0] Y;\npriority_encoder pe(A, B, C, D, Y);\nbarrel_shifter bs(data, shift, q);\nfunctional_module fm(Y, q);\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "4f4a542813038daff63987d383395905",
        "dataset_index": 539
      },
      "twos_comp_addsub_1d15f1fc": {
        "rtl_code": "module twos_comp_addsub (\n    input signed [15:0] a,\n    input signed [15:0] b,\n    input sub,\n    output reg signed [15:0] result,\n    output reg overflow\n);\n\n    always @(*) begin\n        if (sub) begin\n            result = a - b;\n            overflow = ((a < 0) & (b > 0) & (result > 0)) | ((a > 0) & (b < 0) & (result < 0));\n        end else begin\n            result = a + b;\n            overflow = ((a > 0) & (b > 0) & (result < 0)) | ((a < 0) & (b < 0) & (result > 0));\n        end\n    end\n\nendmodule",
        "module_name": "twos_comp_addsub",
        "module_hash": "1d15f1fc5c0915197a6cad316b20c2c1",
        "dataset_index": 1091
      },
      "parity_generator_f79037c4": {
        "rtl_code": "module parity_generator (\n  input in1,\n  input in2,\n  input in3,\n  input in4,\n  output reg parity\n);\n\n  always @ (in1, in2, in3, in4) begin\n    if ((in1 + in2 + in3 + in4) % 2 == 0)\n      parity <= 0;\n    else\n      parity <= 1;\n  end\n\nendmodule\n",
        "module_name": "parity_generator",
        "module_hash": "f79037c45fa5ea76745eb9c218106d76",
        "dataset_index": 8014
      },
      "long_to_double_03e9b678": {
        "rtl_code": "module long_to_double(\n        input_a,\n        input_a_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [63:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  output    [63:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [63:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [2:0] state;\n  parameter get_a         = 3'd0,\n            convert_0     = 3'd1,\n            convert_1     = 3'd2,\n            convert_2     = 3'd3,\n            round         = 3'd4,\n            pack          = 3'd5,\n            put_z         = 3'd6;\n\n  reg [63:0] a, z, value;\n  reg [52:0] z_m;\n  reg [10:0] z_r;\n  reg [10:0] z_e;\n  reg z_s;\n  reg guard, round_bit, sticky;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= convert_0;\n        end\n      end\n\n      convert_0:\n      begin\n        if ( a == 0 ) begin\n          z_s <= 0;\n          z_m <= 0;\n          z_e <= -1023;\n          state <= pack;\n        end else begin\n          value <= a[63] ? -a : a;\n          z_s <= a[63];\n          state <= convert_1;\n        end\n      end\n\n      convert_1:\n      begin\n        z_e <= 63;\n        z_m <= value[63:11];\n        z_r <= value[10:0];\n        state <= convert_2;\n      end\n\n      convert_2:\n      begin\n        if (!z_m[52]) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= z_r[10];\n          z_r <= z_r << 1;\n        end else begin\n          guard <= z_r[10];\n          round_bit <= z_r[9];\n          sticky <= z_r[8:0] != 0;\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit || sticky || z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 53'h1fffffffffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[51 : 0] <= z_m[51:0];\n        z[62 : 52] <= z_e + 1023;\n        z[63] <= z_s;\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n",
        "module_name": "long_to_double",
        "module_hash": "03e9b678f70c6bb3ff35c6248cbdce7d",
        "dataset_index": 20221
      },
      "hpdmc_banktimer_72eaae80": {
        "rtl_code": "\n\nmodule hpdmc_banktimer(\n\tinput sys_clk,\n\tinput sdram_rst,\n\t\n\tinput tim_cas,\n\tinput [1:0] tim_wr,\n\t\n\tinput read,\n\tinput write,\n\toutput reg precharge_safe\n);\n\nreg [2:0] counter;\nalways @(posedge sys_clk) begin\n\tif(sdram_rst) begin\n\t\tcounter <= 3'd0;\n\t\tprecharge_safe <= 1'b1;\n\tend else begin\n\t\tif(read) begin\n\t\t\t\n\t\t\tcounter <= 3'd4;\n\t\t\tprecharge_safe <= 1'b0;\n\t\tend else if(write) begin\n\t\t\tcounter <= {1'b1, tim_wr};\n\t\t\tprecharge_safe <= 1'b0;\n\t\tend else begin\n\t\t\tif(counter == 3'b1)\n\t\t\t\tprecharge_safe <= 1'b1;\n\t\t\tif(~precharge_safe)\n\t\t\t\tcounter <= counter - 3'b1;\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "hpdmc_banktimer",
        "module_hash": "72eaae8098603a8246c8c25c8e2a2f16",
        "dataset_index": 15570
      },
      "top__80aa7a85": {
        "rtl_code": "\nmodule top_module (\n    input               clk         ,\n    input               rst_n       ,\n    input       [7:0]   data_in_1   ,\n    input       [7:0]   data_in_2   ,\n    input               valid_a     ,\n    input               ready_b     ,\n    output              ready_a     ,\n    output              valid_b     ,\n    output      [8:0]   data_out\n);\n\nwire [8:0] sum;\nwire carry;\n\n adder8 adder_inst (\n    .a(data_in_1),\n    .b(data_in_2),\n    .sum(sum)\n);\n\nassign carry = (data_in_1+data_in_2) > 255 ? 1'b1 : 1'b0;\n\nreg [8:0] sum2;\nreg [8:0] data_out_r;\nreg valid_b_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        sum2 <= 0;\n        data_out_r <= 0;\n        valid_b_r <= 0;\n    end else begin\n        sum2 <= sum + sum2;\n        data_out_r <= sum;\n        valid_b_r <= valid_a;\n    end\nend\n\nassign data_out = data_out_r;\nassign valid_b = valid_b_r;\nassign ready_a = !valid_b || ready_b;\n\nendmodule\nmodule adder8 (\n    input       [7:0]   a           ,\n    input       [7:0]   b           ,\n    output reg  [8:0]   sum\n);\n\nalways @(*) begin\n    sum = a + b;\nend\n\nendmodule\nmodule carry_out (\n    input       [7:0]   a           ,\n    input       [7:0]   b           ,\n    output reg          cout\n);\n\nalways @(*) begin\n    cout = (a+b) > 255 ? 1'b1 : 1'b0;\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "80aa7a85728078711abad392d45c191d",
        "dataset_index": 9455
      },
      "PWM_d4664876": {
        "rtl_code": "\nmodule PWM (\n  input clk,\n  input [7:0] in,\n  output out\n);\n\nparameter clk_freq = 50000000; // 50 MHz\nparameter pwm_freq = 1000; // 1 kHz\n\nreg [31:0] counter = 0;\nreg [7:0] threshold = 0;\n\nassign out = (counter < threshold);\n\nalways @(posedge clk) begin\n  counter <= counter + 1;\n  if (counter >= (clk_freq / pwm_freq)) begin\n    counter <= 0;\n    threshold <= in;\n  end\nend\n\nendmodule\n",
        "module_name": "PWM",
        "module_hash": "d46648769fe47ba9ed4b132b6a38336e",
        "dataset_index": 16413
      },
      "up_counter_3caf2f28": {
        "rtl_code": "module up_counter (\n  input clk,\n  input reset,\n  output reg [2:0] count_out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_out <= 3'b0;\n    end\n    else begin\n      count_out <= count_out + 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "up_counter",
        "module_hash": "3caf2f28806d104640e941e2e3d2cfef",
        "dataset_index": 12773
      },
      "sky130_fd_sc_lp__dfxtp_f68500ea": {
        "rtl_code": "module sky130_fd_sc_lp__dfxtp (\n    //# {{data|Data Signals}}\n    input  D   ,\n    output Q   ,\n\n    //# {{clocks|Clocking}}\n    input  CLK ,\n\n    //# {{power|Power}}\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n    reg Q_reg;\n\n    always @(posedge CLK)\n        Q_reg <= D;\n    \n    assign Q = Q_reg;\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__dfxtp",
        "module_hash": "f68500ead286e52337d5d18ac6d1cf63",
        "dataset_index": 8610
      },
      "reset_resync #_4d75c72e": {
        "rtl_code": "`ifdef INCL_RESET_RESYNC\n`else\n`define INCL_RESET_RESYNC\n\nmodule reset_resync #(\n\t\tparameter VALUE_DURING_RESET = 1\n) (\n  input       rst_in,\n  input       clk_in,\n\n  input       clk_out,\n    output reg  rst_out\n);\n\n reg rst_in_dly;\n\nalways @(posedge clk_in or posedge rst_in) begin\n  if (rst_in) begin\n    rst_in_dly <= 1'b1;\n  end else begin\n    rst_in_dly <= 1'b0;\n  end\nend\n\n\ninitial begin\n\trst_out = VALUE_DURING_RESET;\nend\n\nalways @(posedge clk_out or posedge rst_in_dly) begin\n  if (rst_in_dly) begin\n    rst_out <= VALUE_DURING_RESET;\n  end else begin\n    rst_out <= ~VALUE_DURING_RESET;\n  end\nend\n\nendmodule\n\n`endif ",
        "module_name": "reset_resync #",
        "module_hash": "4d75c72e7d625c58ee52163af9fb009b",
        "dataset_index": 21687
      },
      "vending_machine_b74ad102": {
        "rtl_code": "\nmodule vending_machine (\n  input btnA,\n  input btnB,\n  input btnC,\n  input clk,\n  output reg dispenseBar,\n  output reg dispenseChips,\n  output reg dispenseSoda\n);\n\n  reg [1:0] state;\n\n  parameter IDLE = 2'b00;\n  parameter DISPENSING = 2'b01;\n  parameter RESET = 2'b10;\n\n  always @(posedge clk) begin\n    case(state)\n      IDLE: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        if(btnA) begin\n          dispenseBar = 1;\n          state = DISPENSING;\n        end else if(btnB) begin\n          dispenseChips = 1;\n          state = DISPENSING;\n        end else if(btnC) begin\n          dispenseSoda = 1;\n          state = DISPENSING;\n        end else begin\n          state = IDLE;\n        end\n      end\n      DISPENSING: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        state = RESET;\n      end\n      RESET: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        state = IDLE;\n      end\n      default: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        state = IDLE;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "b74ad10206fbf106b37d14f31f0389ce",
        "dataset_index": 20714
      },
      "ic_download_c98061de": {
        "rtl_code": "module  ic_download(clk,\n                    rst,\n                    rep_flit_ic,\n                    v_rep_flit_ic,\n                    rep_ctrl_ic,\n                    mem_flits_ic,\n                    v_mem_flits_ic,\n                    ic_download_state,\n                    inst_word_ic,\n                    v_inst_word\n                    );\ninput                    clk;\ninput                    rst;\ninput      [15:0]        rep_flit_ic;\ninput                    v_rep_flit_ic;\ninput      [1:0]         rep_ctrl_ic;\ninput      [127:0]        mem_flits_ic;\ninput                    v_mem_flits_ic;\noutput     [1:0]         ic_download_state;\noutput     [127:0]       inst_word_ic;\noutput                   v_inst_word;\n\nreg [127:0]  inst_word ;\nreg [1:0]    ic_download_nstate;\nreg [1:0]    ic_download_cstate;\nparameter    ic_download_idle=2'b00;\nparameter    ic_download_busy=2'b01;\nparameter    ic_download_rdy=2'b10;\n\nassign ic_download_state=ic_download_cstate;\nassign inst_word_ic=inst_word;\n\nreg             v_inst_word;\nreg             en_mem_flits_ic;\nreg             en_rep_flit_ic;\nreg             inc_cnt;\nreg             fsm_rst;\nreg   [127:0]   inst_word_in;\nalways@(*)\nbegin\n  ic_download_nstate=ic_download_cstate;\n  v_inst_word=1'b0;\n  en_mem_flits_ic=1'b0;\n  en_rep_flit_ic=1'b0;\n  inc_cnt=1'b0;\n  fsm_rst=1'b0;\n  inst_word_in=128'h0000;\n  case(ic_download_cstate)\n    ic_download_idle:\n      begin\n        if(v_mem_flits_ic)\n          begin\n            ic_download_nstate=ic_download_rdy;\n            inst_word_in=mem_flits_ic;\n            en_mem_flits_ic=1'b1;\n          end\n      else if(v_rep_flit_ic)\n          begin\n            ic_download_nstate=ic_download_busy;\n            en_rep_flit_ic=1'b1;\n          end\n      end\n    ic_download_busy:\n      begin\n        if(rep_ctrl_ic==2'b11)\n           begin\n             en_rep_flit_ic=1'b1;\n            ic_download_nstate=ic_download_rdy;\n           end\n        else if(rep_ctrl_ic==2'b10)\n          begin\n            en_rep_flit_ic=1'b1;\n            inc_cnt=1'b1;\n          end\n      end\n    ic_download_rdy:\n      begin\n        v_inst_word=1'b1;\n        ic_download_nstate=ic_download_idle;\n        fsm_rst=1'b1;\n      end\n    endcase\nend\n\nreg [2:0] cnt;\nreg  [7:0]  en_instword;\nalways@(*)\nbegin\n  case(cnt)\n    3'b000:en_instword=8'b00000001;\n    3'b001:en_instword=8'b00000010;\n    3'b010:en_instword=8'b00000100;\n    3'b011:en_instword=8'b00001000;\n    3'b100:en_instword=8'b00010000;\n    3'b101:en_instword=8'b00100001;\n    3'b110:en_instword=8'b01000001;\n    3'b111:en_instword=8'b10000001;\n    default:en_instword=8'b00000000;\n  endcase\n end\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[15:0]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[15:0]<=inst_word_in[15:0];\n  else if(en_rep_flit_ic&&en_instword[0])\n      inst_word[15:0]<=inst_word_in[15:0];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[31:16]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[31:16]<=inst_word_in[31:16];\n  else if(en_rep_flit_ic&&en_instword[1])\n      inst_word[31:16]<=inst_word_in[31:16];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[47:32]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[47:32]<=inst_word_in[47:32];\n  else if(en_rep_flit_ic&&en_instword[2])\n      inst_word[47:32]<=inst_word_in[47:32];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[63:48]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[63:48]<=inst_word_in[63:48];\n  else if(en_rep_flit_ic&&en_instword[3])\n      inst_word[63:48]<=inst_word_in[63:48];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[79:64]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[79:64]<=inst_word_in[79:64];\n  else if(en_rep_flit_ic&&en_instword[4])\n      inst_word[79:64]<=inst_word_in[79:64];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[95:80]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[95:80]<=inst_word_in[95:80];\n  else if(en_rep_flit_ic&&en_instword[5])\n      inst_word[95:80]<=inst_word_in[95:80];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[111:96]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[111:96]<=inst_word_in[111:96];\n  else if(en_rep_flit_ic&&en_instword[6])\n      inst_word[111:96]<=inst_word_in[111:96];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[127:112]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[127:112]<=inst_word_in[127:112];\n  else if(en_rep_flit_ic&&en_instword[7])\n      inst_word[127:112]<=inst_word_in[127:112];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst)\n    ic_download_cstate<=2'b00;\n  else\n    ic_download_cstate<=ic_download_nstate;\nend\n\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    cnt<=3'b000;\n  else if(inc_cnt)\n    cnt<=cnt+3'b001;\nend\n\nendmodule\n\n",
        "module_name": "ic_download",
        "module_hash": "c98061de8c00c0ebd2bea25d3afe1d93",
        "dataset_index": 22524
      },
      "fifo_a1801204": {
        "rtl_code": "\nmodule fifo\n\t#(\n\tparameter B=8,\n\tW=4\n\t)\n(\ninput wire clk, reset,\ninput wire rd, wr,\ninput wire [B-1:0] w_data,\noutput wire empty, full,\noutput wire [B-1:0] r_data\n);\nreg [B-1:0] array_reg [2**W-1:0]; reg [W-1:0] w_ptr_reg, w_ptr_next, w_ptr_succ;\nreg [W-1:0] r_ptr_reg, r_ptr_next, r_ptr_succ;\nreg full_reg, empty_reg, full_next, empty_next;\nwire wr_en;\n\nalways @(posedge clk)\n\tif (wr_en)\n\t\tarray_reg [w_ptr_reg] <= w_data;\nassign r_data = array_reg[r_ptr_reg];\nassign wr_en = wr & ~full_reg;\nalways @(posedge clk)\nif (reset)\n\tbegin\n\tw_ptr_reg <= 0;\n\tr_ptr_reg <= 0;\n\tfull_reg <= 1'b0;\n\tempty_reg <= 1'b1;\n\tend\nelse\n\tbegin\n\tw_ptr_reg <= w_ptr_next;\n\tr_ptr_reg <= r_ptr_next;\n\tfull_reg <= full_next;\n\tempty_reg <= empty_next;\n\tend\nalways @*\n\tbegin\n\tw_ptr_succ = w_ptr_reg + 1;\n\tr_ptr_succ = r_ptr_reg + 1;\n\tw_ptr_next = w_ptr_reg;\n\tr_ptr_next = r_ptr_reg;\n\tfull_next = full_reg;\n\tempty_next = empty_reg;\n\tcase ({wr, rd})\n\t2'b01: if (~empty_reg) begin\n\t\t\tr_ptr_next = r_ptr_succ;\n\t\t\tfull_next = 1'b0;\n\t\t\tif (r_ptr_succ==w_ptr_reg)\n\t\t\t\tempty_next = 1'b1;\n\t\t\tend\n\t\t2'b10: if (~full_reg) begin\n\t\t\tw_ptr_next = w_ptr_succ ;\n\t\t\tempty_next = 1'b0;\n\t\t\tif (w_ptr_succ==r_ptr_reg)\n\t\t\t\tfull_next = 1'b1;\n\t\t\tend\n\t\t2'b11: begin\n\t\t\tw_ptr_next = w_ptr_succ;\n\t\t\tr_ptr_next = r_ptr_succ;\n\t\t\tend\n\tendcase\nend\nassign full = full_reg;\nassign empty = empty_reg;\nendmodule\n",
        "module_name": "fifo",
        "module_hash": "a1801204d2686389933a299b97016e6e",
        "dataset_index": 23301
      },
      "POR_a153912a": {
        "rtl_code": "module POR (\n  input clk,\n  input pwr,\n  output reg rst\n);\n\nparameter rst_time = 10; // duration for which the reset signal should be asserted\n\nreg pwr_prev; // previous value of power signal\nreg [3:0] rst_count; // counter for reset signal duration\n\nalways @(posedge clk) begin\n  if (pwr && !pwr_prev) begin // power has just been applied\n    rst <= 1;\n    rst_count <= 0;\n  end else if (rst_count < rst_time) begin // reset signal is still being asserted\n    rst <= 1;\n    rst_count <= rst_count + 1;\n  end else begin // reset signal has been de-asserted\n    rst <= 0;\n  end\n  \n  pwr_prev <= pwr;\nend\n\nendmodule",
        "module_name": "POR",
        "module_hash": "a153912a4c8f701e4731ce1a0a0a9ad6",
        "dataset_index": 11550
      },
      "fifo #_51550143": {
        "rtl_code": "module fifo #(\n    parameter MEM_STYLE = \"auto\",\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 1,\n    parameter DEPTH = 2\n) (\n    input clk,\n    input reset,\n    input if_write_ce,\n    input [DATA_WIDTH-1:0] if_write,\n    input if_read_ce,\n    output reg if_empty_n,\n    output reg [DATA_WIDTH-1:0] if_dout,\n    output reg if_full_n\n);\n\nreg [ADDR_WIDTH:0] write_ptr = 0;\nreg [ADDR_WIDTH:0] read_ptr = 0;\nreg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        write_ptr <= 0;\n        read_ptr <= 0;\n        if_empty_n <= 0;\n        if_full_n <= 1;\n    end else begin\n        if (if_write_ce) begin\n            mem[write_ptr] <= if_write;\n            write_ptr <= write_ptr + 1;\n            if (write_ptr == DEPTH) begin\n                write_ptr <= 0;\n            end\n            if_empty_n <= 1;\n            if (write_ptr == read_ptr) begin\n                if_full_n <= 0;\n            end\n        end\n        if (if_read_ce) begin\n            if_dout <= mem[read_ptr];\n            read_ptr <= read_ptr + 1;\n            if (read_ptr == DEPTH) begin\n                read_ptr <= 0;\n            end\n            if_full_n <= 1;\n            if (read_ptr == write_ptr) begin\n                if_empty_n <= 0;\n            end\n        end\n    end\nend\n\nendmodule",
        "module_name": "fifo #",
        "module_hash": "51550143e785b9be5ee4c9c44bac849a",
        "dataset_index": 17313
      },
      "four_to_one_a444afb1": {
        "rtl_code": "module four_to_one (\n    input [3:0] in,\n    output out\n);\n\n    assign out = |in;\n\nendmodule",
        "module_name": "four_to_one",
        "module_hash": "a444afb198afe264d14b7cdef1ea16e3",
        "dataset_index": 10780
      },
      "wifi #_87860769": {
        "rtl_code": "module wifi #(\n  parameter n = 8, // number of input signals\n  parameter m = 8 // number of output signals\n\n)(\n  input [n-1:0] in,\n  input clk,\n  input rst,\n  input start,\n  output valid,\n  output [m-1:0] out,\n  output done\n);\n\n\n// Encoding scheme\nwire [m-1:0] encoded;\nassign encoded[0] = in[0] ^ in[1] ^ in[3] ^ in[4] ^ in[6];\nassign encoded[1] = in[0] ^ in[2] ^ in[3] ^ in[5] ^ in[6];\nassign encoded[2] = in[1] ^ in[2] ^ in[3] ^ in[7];\nassign encoded[3] = in[4] ^ in[5] ^ in[6] ^ in[7];\nassign encoded[4] = in[0] ^ in[1] ^ in[2] ^ in[4] ^ in[5];\nassign encoded[5] = in[0] ^ in[1] ^ in[3] ^ in[4] ^ in[7];\nassign encoded[6] = in[1] ^ in[2] ^ in[4] ^ in[5] ^ in[7];\nassign encoded[7] = in[0] ^ in[2] ^ in[3] ^ in[6] ^ in[7];\n\n// Decoding scheme\nwire [n-1:0] decoded;\nassign decoded[0] = encoded[0] ^ encoded[1] ^ encoded[3] ^ encoded[4] ^ encoded[6];\nassign decoded[1] = encoded[0] ^ encoded[2] ^ encoded[3] ^ encoded[5] ^ encoded[6];\nassign decoded[2] = encoded[1] ^ encoded[2] ^ encoded[3] ^ encoded[7];\nassign decoded[3] = encoded[4] ^ encoded[5] ^ encoded[6] ^ encoded[7];\nassign decoded[4] = encoded[0] ^ encoded[1] ^ encoded[2] ^ encoded[4] ^ encoded[5];\nassign decoded[5] = encoded[0] ^ encoded[1] ^ encoded[3] ^ encoded[4] ^ encoded[7];\nassign decoded[6] = encoded[1] ^ encoded[2] ^ encoded[4] ^ encoded[5] ^ encoded[7];\nassign decoded[7] = encoded[0] ^ encoded[2] ^ encoded[3] ^ encoded[6] ^ encoded[7];\n\n// Transmitter block\nreg [n-1:0] input_reg;\nreg [m-1:0] encoded_reg;\nreg valid_reg;\nalways @(posedge clk, posedge rst) begin\n  if (rst) begin\n    input_reg <= 0;\n    encoded_reg <= 0;\n    valid_reg <= 0;\n  end else begin\n    if (start) begin\n      input_reg <= in;\n      encoded_reg <= encoded;\n      valid_reg <= 1;\n    end else if (valid_reg) begin\n      valid_reg <= 0;\n    end\n  end\nend\n\n// Receiver block\nreg [m-1:0] encoded_reg2;\nreg [n-1:0] decoded_reg;\nreg done_reg;\nalways @(posedge clk, posedge rst) begin\n  if (rst) begin\n    encoded_reg2 <= 0;\n    decoded_reg <= 0;\n    done_reg <= 0;\n  end else begin\n    if (valid_reg) begin\n      encoded_reg2 <= encoded_reg;\n      done_reg <= 0;\n    end else if (encoded_reg2 != 0) begin\n      decoded_reg <= decoded;\n      done_reg <= 1;\n    end\n  end\nend\n\n// Output signals\nassign valid = valid_reg;\nassign out = encoded_reg;\nassign done = done_reg;\n\nendmodule",
        "module_name": "wifi #",
        "module_hash": "8786076910ed0de93b6617e2345d684c",
        "dataset_index": 3988
      },
      "mux2to1_bb5f3345": {
        "rtl_code": "module mux2to1 (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    assign out = (sel == 1'b1) ? a : b;\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "bb5f3345e03449673c814d9078aa1d1a",
        "dataset_index": 12394
      },
      "acl_fp_fptosi_6df6899a": {
        "rtl_code": "module acl_fp_fptosi( clock, enable, resetn, dataa, result);\n    input clock;    \n    input enable, resetn;\n    input [31:0] dataa;\n    output [31:0] result;\n\n    wire sign_0;\n    wire [7:0] exp_0;\n    wire [22:0] man_0;\n    wire [23:0] implied_man_0;\n\n    assign {sign_0, exp_0, man_0} = dataa;\n    assign implied_man_0 = {1'b1, man_0};\n\n    reg sign_1;\n    reg [30:0] man_1;\n    reg [7:0] shift_amount_1;\n\n    always @( posedge clock or negedge resetn)\n    begin\n        if( ~resetn ) begin\n            sign_1 <= 1'b0;\n            man_1 <= 31'd0;\n            shift_amount_1 <= 8'd0;\n        end\n        else if (enable)\n\t      begin\n            sign_1 <= sign_0;\n\n            if( exp_0 < 8'd127 )\n            begin\n                man_1 <= 31'd0;\n                shift_amount_1 <= 8'd0;\n            end\n            else\n            begin\n                man_1 <= {implied_man_0, 7'd0};\n                shift_amount_1 <= exp_0 - 8'd127;\n            end\n        end\n    end\n\n    reg sign_2;\n    reg [30:0] result_2;\n\n    always @( posedge clock or negedge resetn)\n    begin\n\t      if (~resetn)\n\t      begin\n\t\t        sign_2 <= 1'b0;\n\t\t        result_2 <= 31'd0;\n\t      end\n\t      else if (enable)\n        begin\n            sign_2 <= sign_1;\n\n            case( shift_amount_1 )\n                8'd00: result_2 <= man_1[30:30];\n                8'd01: result_2 <= man_1[30:29];\n                8'd02: result_2 <= man_1[30:28];\n                8'd03: result_2 <= man_1[30:27];\n                8'd04: result_2 <= man_1[30:26];\n                8'd05: result_2 <= man_1[30:25];\n                8'd06: result_2 <= man_1[30:24];\n                8'd07: result_2 <= man_1[30:23];\n                8'd08: result_2 <= man_1[30:22];\n                8'd09: result_2 <= man_1[30:21];\n                8'd10: result_2 <= man_1[30:20];\n                8'd11: result_2 <= man_1[30:19];\n                8'd12: result_2 <= man_1[30:18];\n                8'd13: result_2 <= man_1[30:17];\n                8'd14: result_2 <= man_1[30:16];\n                8'd15: result_2 <= man_1[30:15];\n                8'd16: result_2 <= man_1[30:14];\n                8'd17: result_2 <= man_1[30:13];\n                8'd18: result_2 <= man_1[30:12];\n                8'd19: result_2 <= man_1[30:11];\n                8'd20: result_2 <= man_1[30:10];\n                8'd21: result_2 <= man_1[30:9];\n                8'd22: result_2 <= man_1[30:8];\n                8'd23: result_2 <= man_1[30:7];\n                8'd24: result_2 <= man_1[30:6];\n                8'd25: result_2 <= man_1[30:5];\n                8'd26: result_2 <= man_1[30:4];\n                8'd27: result_2 <= man_1[30:3];\n                8'd28: result_2 <= man_1[30:2];\n                8'd29: result_2 <= man_1[30:1];\n                8'd30: result_2 <= man_1[30:0];\n                default: result_2 <= {31{1'b1}};    endcase\n        end\n    end\n\n    reg [31:0] result_3;\n\n    always @( posedge clock or negedge resetn)\n    begin\n        if (~resetn)\n\t\t        result_3 <= 32'd0;\n\t      else if (enable)\n\t      begin\n            if( sign_2 )\n                result_3 <= ~({1'b0, result_2}) + 32'd1;\n            else\n                result_3 <= {1'b0, result_2};\n        end\n    end\n\n    assign result = result_3;\nendmodule\n\n",
        "module_name": "acl_fp_fptosi",
        "module_hash": "6df6899a9a55f144b46114976b09f6f6",
        "dataset_index": 25684
      },
      "top__445035f6": {
        "rtl_code": "module top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input select,\n    input subtract,\n    output eq,\n    output gt,\n    output [3:0] result\n);\n\n    wire [3:0] adder_out;\n    wire [3:0] comparator_out;\n    wire [3:0] final_result;\n\n    // Instantiate adder/subtractor module\n    adder_subtractor add_sub (\n        .A(A),\n        .B(B),\n        .subtract(subtract),\n        .result(adder_out)\n    );\n\n    // Instantiate magnitude comparator module\n    magnitude_comparator mag_comp (\n        .A(A),\n        .B(B),\n        .eq(eq),\n        .gt(gt),\n        .result(comparator_out)\n    );\n\n    // Functional module to select output\n    assign final_result = select ? comparator_out : adder_out;\n\n    // Output signals\n    assign result = final_result;\n\nendmodule\n\n// Adder/Subtractor module\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input subtract,\n    output [3:0] result\n);\n\n    assign result = subtract ? A - B : A + B;\n\nendmodule\n\n// Magnitude Comparator module\nmodule magnitude_comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output eq,\n    output gt,\n    output [3:0] result\n);\n\n    assign eq = (A == B);\n    assign gt = (A > B);\n    assign result = {gt, eq};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "445035f6383228fc1abf8181fb5f7d31",
        "dataset_index": 6270
      },
      "SSCG_93b99a5e": {
        "rtl_code": "\nmodule SSCG (\n  input clk_in, // input clock signal\n  input clk_en, // SSCG enable signal\n  input [31:0] sscg_freq, // frequency deviation parameter\n  output clk_out // output clock signal\n);\n\n  reg [31:0] fm_accumulator;\n  reg [31:0] fm_increment;\n  reg [31:0] fm_modulation;\n  reg clk_output;\n\n  always @ (posedge clk_in) begin\n    if (clk_en) begin\n      fm_accumulator <= fm_accumulator + fm_increment;\n      fm_modulation <= sscg_freq >> 1; // fix: remove $urandom\n      clk_output <= (fm_accumulator + fm_modulation) >> 1;\n    end else begin\n      clk_output <= clk_in;\n    end\n  end\n\n  assign clk_out = clk_output;\n\n  parameter PERIOD = (2**32 / 1000) * 100; // 100 kHz\n\n  initial begin\n    fm_accumulator <= 0;\n    fm_increment <= PERIOD; // 100 kHz\n    fm_modulation <= 0;\n    clk_output <= 0;\n  end\n\nendmodule",
        "module_name": "SSCG",
        "module_hash": "93b99a5ebb175f2977fc7740ced9c1f4",
        "dataset_index": 9275
      },
      "top__35acc4fe": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input [15:0] in, // 16 inputs for the multiplexer\n    input [3:0] sel, // 4-bit select input for the multiplexer\n    output q // Output of the final logical operation module\n);\n\n    reg [15:0] mux_out; // Output of the multiplexer\n    reg d_ff_out; // Output of the dual-edge triggered flip-flop\n    reg d_ff_out_r; // Registered version of d_ff_out\n    wire [15:0] or_in; // Input to the logical operation module\n\n    // Multiplexer implementation\n    always @(*) begin\n        case (sel)\n            4'b0000: mux_out = in[0];\n            4'b0001: mux_out = in[1];\n            4'b0010: mux_out = in[2];\n            4'b0011: mux_out = in[3];\n            4'b0100: mux_out = in[4];\n            4'b0101: mux_out = in[5];\n            4'b0110: mux_out = in[6];\n            4'b0111: mux_out = in[7];\n            4'b1000: mux_out = in[8];\n            4'b1001: mux_out = in[9];\n            4'b1010: mux_out = in[10];\n            4'b1011: mux_out = in[11];\n            4'b1100: mux_out = in[12];\n            4'b1101: mux_out = in[13];\n            4'b1110: mux_out = in[14];\n            4'b1111: mux_out = in[15];\n        endcase\n    end\n\n    // Dual-edge triggered flip-flop implementation\n    always @(posedge clk) begin\n        d_ff_out <= mux_out;\n    end\n\n    always @(negedge clk) begin\n        d_ff_out_r <= d_ff_out;\n    end\n\n    // Logical operation module implementation\n    assign or_in = {16{d_ff_out_r}} | in;\n    assign q = |or_in;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "35acc4fec2fa35f96e100557ffa1eb51",
        "dataset_index": 3310
      },
      "acciones_to_bcd_9280ef31": {
        "rtl_code": "\nmodule acciones_to_bcd(\n\t input clk,\n\t input rst,\n\t input [1:0] piso, input [1:0] accion, input puertas, output reg [3:0] BCD1,\n\t output reg [3:0] BCD2,\n\t output reg [3:0] BCD3,\n\t output reg [3:0] BCD4\n    );\n\ninitial begin\n\tBCD4 = 1;\n\tBCD3 = 9;\n\tBCD2 = 6;\n\tBCD1 = 0;\nend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD4 = 4'b1110;\n\t\t\t\t#10 BCD4 = 4'b0001;\n\t\t\t\tBCD3 = 4'b0110;\n\t\t\t\t#10 BCD3 = 4'b1001;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (piso == 2'b00)\n\t\t\t\t\tBCD4 = 4'b0001;\n\t\t\t\telse if (piso == 2'b01)\n\t\t\t\t\tBCD4 = 4'b0010;\n\t\t\t\telse if (piso == 2'b10)\n\t\t\t\t\tBCD4 = 4'b0011;\n\t\t\t\telse\n\t\t\t\t\tBCD4 = 4'b0100;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD1 = 4'b1111;\n\t\t\t\t#10 BCD1 = 4'b0000;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (accion == 2'b00)\n\t\t\t\t\tBCD1 = 4'b0000;\n\t\t\t\telse if (accion == 2'b01)\n\t\t\t\t\tBCD1 = 4'b0101;\n\t\t\t\telse if (accion == 2'b10)\n\t\t\t\t\tBCD1 = 4'b1000;\n\t\t\t\telse\n\t\t\t\t\tBCD1 = 0;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD2 = 4'b1001;\n\t\t\t\t#10 BCD2 = 4'b0110;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (puertas == 1'b0)\n\t\t\t\t\tBCD2 = 4'b0111;\n\t\t\t\telse\n\t\t\t\t\tBCD2 = 4'b0110;\n\t\t\tend\n\tend\n\nendmodule\n",
        "module_name": "acciones_to_bcd",
        "module_hash": "9280ef315bdc6ea7c22ddf593b23fb5c",
        "dataset_index": 22006
      },
      "pcie_core_axi_basic_rx_null_gen #_974318d4": {
        "rtl_code": "\n\nmodule pcie_core_axi_basic_rx_null_gen # (\n  parameter C_DATA_WIDTH = 128,           parameter TCQ = 1,                      parameter KEEP_WIDTH = C_DATA_WIDTH / 8            ) (\n\n  input      [C_DATA_WIDTH-1:0] m_axis_rx_tdata,     input                         m_axis_rx_tvalid,    input                         m_axis_rx_tready,    input                         m_axis_rx_tlast,     input                  [21:0] m_axis_rx_tuser,     output                        null_rx_tvalid,      output                        null_rx_tlast,       output       [KEEP_WIDTH-1:0] null_rx_tkeep,       output                        null_rdst_rdy,       output reg              [4:0] null_is_eof,         input                         user_clk,            input                         user_rst             );\n\n\nlocalparam INTERFACE_WIDTH_DWORDS = (C_DATA_WIDTH == 128) ? 11'd4 :\n                                           (C_DATA_WIDTH == 64) ? 11'd2 : 11'd1;\n\nlocalparam            IDLE      = 0;\nlocalparam            IN_PACKET = 1;\nreg                   cur_state;\nreg                   next_state;\n\nreg            [11:0] reg_pkt_len_counter;\nreg            [11:0] pkt_len_counter;\nwire           [11:0] pkt_len_counter_dec;\nwire                  pkt_done;\n\nwire           [11:0] new_pkt_len;\nwire            [9:0] payload_len;\nwire            [1:0] packet_fmt;\nwire                  packet_td;\nreg             [3:0] packet_overhead;\n\nwire [KEEP_WIDTH-1:0] eof_tkeep;\nwire                  straddle_sof;\nwire                  eof;\n\n\nassign eof = m_axis_rx_tuser[21];\ngenerate\n  if(C_DATA_WIDTH == 128) begin : sof_eof_128\n    assign straddle_sof = (m_axis_rx_tuser[14:13] == 2'b11);\n  end\n  else begin : sof_eof_64_32\n    assign straddle_sof = 1'b0;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : len_calc_128\n    assign packet_fmt  = straddle_sof ?\n                                m_axis_rx_tdata[94:93] : m_axis_rx_tdata[30:29];\n    assign packet_td   = straddle_sof ?\n                                      m_axis_rx_tdata[79] : m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ?\n         (straddle_sof ? m_axis_rx_tdata[73:64] : m_axis_rx_tdata[9:0]) : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td, straddle_sof})\n        3'b0_0_0: packet_overhead = 4'd3 + 4'd0 - 4'd4;\n        3'b0_0_1: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        3'b0_1_0: packet_overhead = 4'd3 + 4'd1 - 4'd4;\n        3'b0_1_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        3'b1_0_0: packet_overhead = 4'd4 + 4'd0 - 4'd4;\n        3'b1_0_1: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        3'b1_1_0: packet_overhead = 4'd4 + 4'd1 - 4'd4;\n        3'b1_1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else if(C_DATA_WIDTH == 64) begin : len_calc_64\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else begin : len_calc_32\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd1;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd1;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd1;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd1;\n      endcase\n    end\n  end\nendgenerate\n\nassign new_pkt_len =\n         {{9{packet_overhead[3]}}, packet_overhead[2:0]} + {2'b0, payload_len};\n\n\nassign pkt_len_counter_dec = reg_pkt_len_counter - INTERFACE_WIDTH_DWORDS;\nassign pkt_done = (reg_pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\n\nalways @(*) begin\n  case (cur_state)\n\n    IDLE: begin\n      if(m_axis_rx_tvalid && m_axis_rx_tready && !eof) begin\n        next_state = IN_PACKET;\n      end\n      else begin\n        next_state = IDLE;\n      end\n\n      pkt_len_counter = new_pkt_len;\n    end\n\n    IN_PACKET: begin\n      if((C_DATA_WIDTH == 128) && straddle_sof && m_axis_rx_tvalid) begin\n        pkt_len_counter = new_pkt_len;\n        next_state = IN_PACKET;\n      end\n\n      else if(m_axis_rx_tready && pkt_done)\n      begin\n        pkt_len_counter = new_pkt_len;\n        next_state      = IDLE;\n      end\n\n      else begin\n        if(m_axis_rx_tready) begin\n          pkt_len_counter = pkt_len_counter_dec;\n        end\n        else begin\n          pkt_len_counter = reg_pkt_len_counter;\n        end\n\n        next_state = IN_PACKET;\n      end\n    end\n\n    default: begin\n      pkt_len_counter = reg_pkt_len_counter;\n      next_state      = IDLE;\n    end\n  endcase\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    cur_state           <= #TCQ IDLE;\n    reg_pkt_len_counter <= #TCQ 12'h0;\n  end\n  else begin\n    cur_state           <= #TCQ next_state;\n    reg_pkt_len_counter <= #TCQ pkt_len_counter;\n  end\nend\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : strb_calc_128\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        10'd3:   null_is_eof = 5'b11011;\n        10'd4:   null_is_eof = 5'b11111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = {KEEP_WIDTH{1'b0}};\n  end\n  else if(C_DATA_WIDTH == 64) begin : strb_calc_64\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = { ((pkt_len_counter == 12'd2) ? 4'hF:4'h0), 4'hF };\n  end\n  else begin : strb_calc_32\n    always @(*) begin\n      if(pkt_len_counter == 12'd1) begin\n        null_is_eof = 5'b10011;\n      end\n      else begin\n        null_is_eof = 5'b00011;\n      end\n    end\n\n    assign eof_tkeep = 4'hF;\n  end\nendgenerate\n\n\nassign null_rx_tvalid = 1'b1;\nassign null_rx_tlast  = (pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\nassign null_rx_tkeep  = null_rx_tlast ? eof_tkeep : {KEEP_WIDTH{1'b1}};\nassign null_rdst_rdy  = null_rx_tlast;\n\nendmodule\n",
        "module_name": "pcie_core_axi_basic_rx_null_gen #",
        "module_hash": "974318d4bc7ebd7d515c7e2cd24f465b",
        "dataset_index": 24575
      },
      "four_bit_adder_ef4b8cb7": {
        "rtl_code": "module four_bit_adder (A, B, Cin, S, Cout);\n\n  input [3:0] A, B;\n  input Cin;\n  output [3:0] S;\n  output Cout;\n  \n  wire [3:0] C;\n  \n  // Instantiate full-adder modules\n  full_adder FA0(.A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(C[0]));\n  full_adder FA1(.A(A[1]), .B(B[1]), .Cin(C[0]), .S(S[1]), .Cout(C[1]));\n  full_adder FA2(.A(A[2]), .B(B[2]), .Cin(C[1]), .S(S[2]), .Cout(C[2]));\n  full_adder FA3(.A(A[3]), .B(B[3]), .Cin(C[2]), .S(S[3]), .Cout(Cout));\n  \nendmodule\n\nmodule full_adder (A, B, Cin, S, Cout);\n\n  input A, B, Cin;\n  output S, Cout;\n  \n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (Cin & (A ^ B));\n  \nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "ef4b8cb7be1fe5a28de992366d0c268d",
        "dataset_index": 12722
      },
      "FSM #_64da639d": {
        "rtl_code": "module FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  input clk,\n  output reg [m-1:0] out\n);\n\nparameter s = 8; // number of states\n\nreg [s-1:0] state; // current state\nreg [s-1:0] next_state; // next state\nreg [m-1:0] output_reg; // output register\n\n// transition table\nfunction [s-1:0] transition_table;\n  input [n-1:0] input_signals;\n  begin\n    case (input_signals)\n      4'b0000: transition_table = 3'b000;\n      4'b0001: transition_table = 3'b001;\n      4'b0010: transition_table = 3'b010;\n      4'b0011: transition_table = 3'b011;\n      4'b0100: transition_table = 3'b100;\n      4'b0101: transition_table = 3'b101;\n      4'b0110: transition_table = 3'b110;\n      4'b0111: transition_table = 3'b111;\n      4'b1000: transition_table = 3'b000;\n      4'b1001: transition_table = 3'b001;\n      4'b1010: transition_table = 3'b010;\n      4'b1011: transition_table = 3'b011;\n      4'b1100: transition_table = 3'b100;\n      4'b1101: transition_table = 3'b101;\n      4'b1110: transition_table = 3'b110;\n      4'b1111: transition_table = 3'b111;\n    endcase\n  end\nendfunction\n\n// output table\nfunction [m-1:0] output_table;\n  input [n-1:0] input_signals;\n  begin\n    case (input_signals)\n      4'b0000: output_table = 2'b00;\n      4'b0001: output_table = 2'b01;\n      4'b0010: output_table = 2'b10;\n      4'b0011: output_table = 2'b11;\n      4'b0100: output_table = 2'b00;\n      4'b0101: output_table = 2'b01;\n      4'b0110: output_table = 2'b10;\n      4'b0111: output_table = 2'b11;\n      4'b1000: output_table = 2'b00;\n      4'b1001: output_table = 2'b01;\n      4'b1010: output_table = 2'b10;\n      4'b1011: output_table = 2'b11;\n      4'b1100: output_table = 2'b00;\n      4'b1101: output_table = 2'b01;\n      4'b1110: output_table = 2'b10;\n      4'b1111: output_table = 2'b11;\n    endcase\n  end\nendfunction\n\n// compute next state and output\nalways @(*) begin\n  next_state = transition_table(in);\n  output_reg = output_table(in);\nend\n\n// assign output and update state\nalways @(posedge clk) begin\n  state <= next_state;\n  out <= output_reg;\nend\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "64da639dc4da839883e716db9ad735cb",
        "dataset_index": 7171
      },
      "jt51_lfo_lfsr #_838b6ae0": {
        "rtl_code": "\n\n\n\nmodule jt51_lfo_lfsr #(parameter init=220 )(\n\tinput\trst,\n\tinput\tclk,\n\tinput\tbase,\n\toutput\tout\n);\n\nreg [18:0] bb;\nassign out = bb[18];\n\nreg last_base;\n\nalways @(posedge clk) begin : base_counter\n\tif( rst ) begin\n\t\tbb\t\t\t<= init[18:0];\n\t\tlast_base \t<= 1'b0;\n\tend\n\telse begin\n\t\tlast_base <= base;\n\t\tif( last_base != base ) begin\t\n\t\t\tbb[18:1] \t<= bb[17:0];\n\t\t\tbb[0]\t\t<= ^{bb[0],bb[1],bb[14],bb[15],bb[17],bb[18]};\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "jt51_lfo_lfsr #",
        "module_hash": "838b6ae0c2d3691d2afbe20014580d6a",
        "dataset_index": 15019
      },
      "sequencDetector_9ca72116": {
        "rtl_code": "\nmodule sequencDetector(\n    input in,\n    input reset,\n    input clock,\n    output reg out\n    );\n\nreg [2:0] state;\nparameter s0 = 3'b000, s1 = 3'b001, s2 = 3'b010, s3 = 3'b011, s4 = 3'b100, s5 = 3'b101;\n\nalways @(posedge clock)\nbegin\n\t if (reset)\n    begin\n      state <= s0;\n      out  <= 0 ;\n    end\n  else\n      case(state)\n              s0 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s0; out <= 0 ; end\n              s1 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s2; out <= 0 ; end\n              s2 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s3; out <= 0 ; end\n              s3 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s4; out <= 0 ; end\n              s4 : if (in)  begin state <= s5; out <= 1 ; end\n                    else    begin state <= s0; out <= 0 ; end\n              s5 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s2; out <= 0 ; end\n        default:   if (in)  begin state <= s0; out <= 0 ; end\n                    else    begin state <= s0; out <= 0 ; end\n      endcase\n\nend\n\nendmodule\n",
        "module_name": "sequencDetector",
        "module_hash": "9ca72116ea0e8436b82a1a163f2fdabc",
        "dataset_index": 23526
      },
      "custom__05066fc5": {
        "rtl_code": "\nmodule custom_module (\n    A1,\n    A2,\n    A3,\n    A4,\n    B1,\n    X\n);\n\n    input A1;\n    input A2;\n    input A3;\n    input A4;\n    input B1;\n    output X;\n\n    wire X1;\n    wire X2;\n\n    and (X1, A1, A2);\n    and (X2, A3, A4);\n    nor (X, X1, X2, B1);\n\nendmodule",
        "module_name": "custom_",
        "module_hash": "05066fc59cd4ee2132ec6158c86c9f47",
        "dataset_index": 21144
      },
      "binary_search_2f4f2f14": {
        "rtl_code": "\nmodule binary_search (\n    input [15:0] array, // Assuming 8 2-bit elements packed into a 16-bit vector\n    input [1:0] search_key, // Adjusting search_key width to match array element width\n    output reg [2:0] index // 3 bits wide to represent indexes 0-7 or an invalid index\n);\n\n    parameter N = 8; // Number of array elements\n\n    integer i;\n    reg found;\n\n    always @(*) begin\n        index = N; // Initializing index to invalid value\n        found = 0;\n        for (i = 0; i < N; i = i + 1) begin \n            if (array[(i*2)+:2] == search_key) begin // Slicing array to match 2-bit elements\n                index = i;\n                found = 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "binary_search",
        "module_hash": "2f4f2f14a617eeab7cae7994a681d8c5",
        "dataset_index": 700
      },
      "counter_cc474c08": {
        "rtl_code": "module counter (\n   // Inputs\n   clk,\n   // Outputs\n   count\n   );\n\n   input clk;\n   output reg [9:0] count;\n\n   always @ (posedge clk) begin\n      if (count == 999) begin\n         count <= 0;\n      end\n      else begin\n         count <= count + 1;\n      end\n   end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "cc474c087be4909e7d6e9fbfe62bea85",
        "dataset_index": 18721
      },
      "reverse_parity_d4b3491d": {
        "rtl_code": "\nmodule reverse_parity (\n  input [2:0] in_vec,\n  output [3:0] out_vec,\n  output even_parity\n);\n\n  assign out_vec = {in_vec[2], in_vec[1], in_vec[0], ~^in_vec};\n  assign even_parity = (^in_vec);\n\nendmodule\n\nmodule shift_register (\n  input clk,\n  input reset,\n  input load,\n  input [2:0] load_data,\n  output serial_out\n);\n\n  reg [2:0] reg_data;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      reg_data <= 3'b0;\n    end else if (load) begin\n      reg_data <= load_data;\n    end else begin\n      reg_data <= {reg_data[1:0], 1'b0};\n    end\n  end\n\n  assign serial_out = reg_data[0];\n\nendmodule\n\nmodule top_module (\n  input clk,\n  input reset,\n  input [3:0] in_vec,\n  input select,\n  input load,\n  input [2:0] load_data,\n  output [3:0] out_vec,\n  output even_parity,\n  output serial_out\n);\n\n  wire [3:0] reverse_out_vec;\n  wire reverse_even_parity;\n  wire shift_serial_out;\n\n  reverse_parity reverse_parity_inst (\n    .in_vec(in_vec[2:0]),\n    .out_vec(reverse_out_vec),\n    .even_parity(reverse_even_parity)\n  );\n\n  shift_register shift_register_inst (\n    .clk(clk),\n    .reset(reset),\n    .load(load),\n    .load_data(load_data),\n    .serial_out(shift_serial_out)\n  );\n\n  assign out_vec = select ? reverse_out_vec : 4'b0;\n  assign even_parity = select ? reverse_even_parity : (^in_vec);\n  assign serial_out = select ? 1'b0 : shift_serial_out;\n\nendmodule\n",
        "module_name": "reverse_parity",
        "module_hash": "d4b3491d47a08585c0d4b07f47da8817",
        "dataset_index": 2078
      },
      "counter_306e11f2": {
        "rtl_code": "module counter(\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end else begin\n        if (count == 15) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "306e11f2495d5543ca99de0c07d5a8ea",
        "dataset_index": 17890
      },
      "top__ca914fc5": {
        "rtl_code": "\nmodule top_module (\n    input  [31:0] a,\n    input  [31:0] b,\n    input         select, //Select input to choose between adder and multiplexer\n    output [31:0] sum\n); \n\nwire [31:0] adder_out;\nwire  mux_out;\n\nadder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(adder_out)\n);\n\nmux mux_inst (\n    .a(a),\n    .b(b),\n    .c(select),\n    .w(mux_out)\n);\n\nassign sum = (select == 1'b1) ? adder_out : {31'b0, mux_out};\n\nendmodule\nmodule adder (\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum\n);\n\ngenvar i;\n\ngenerate\n    for (i = 0; i < 32; i = i + 1) begin : adder_loop\n        full_adder full_adder_inst (\n            .a(a[i]),\n            .b(b[i]),\n            .cin(0), //Assuming there is no carry in\n            .sum(sum[i])\n        );\n    end\nendgenerate\n\nendmodule\nmodule mux (\n    input [31:0] a,\n    input [31:0] b,\n    input c,\n    output w\n);\n\nassign w = c ? b[0] : a[0];\n\nendmodule\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule",
        "module_name": "top_",
        "module_hash": "ca914fc56d7c15d1da1c1039be5b2789",
        "dataset_index": 17712
      },
      "transition_detector_a32e6074": {
        "rtl_code": "module transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg out\n);\n\nreg [31:0] in_reg;\nreg [31:0] in_reg_prev;\nreg [31:0] in_xor;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        in_reg <= 0;\n        in_reg_prev <= 0;\n        in_xor <= 0;\n        out <= 0;\n    end else begin\n        in_reg <= in;\n        in_reg_prev <= in_reg;\n        in_xor <= in_reg ^ in_reg_prev;\n        if (in_xor != 0) begin\n            out <= 1;\n        end\n    end\nend\n\nendmodule\n\nmodule bitwise_operations (\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and,\n    output [2:0] out_xor,\n    output [2:0] out_nor,\n    output reg [2:0] a_not,\n    output reg [2:0] b_not\n);\n\nassign out_and = a & b;\nassign out_xor = a ^ b;\nassign out_nor = ~(a | b);\n\nalways @* begin\n    a_not = ~a;\n    b_not = ~b;\nend\n\nendmodule\n\nmodule functional_module (\n    input clk,\n    input reset,\n    input transition_detect,\n    input [2:0] bitwise_and,\n    output reg [2:0] out_and\n);\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        out_and <= 0;\n    end else begin\n        if (transition_detect == 1) begin\n            out_and <= bitwise_and;\n        end\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and_bitwise,\n    output [5:0] out_not\n);\n\nwire transition_detect;\nwire [2:0] bitwise_and;\nwire [2:0] bitwise_xor;\nwire [2:0] bitwise_nor;\nwire [2:0] a_not;\nwire [2:0] b_not;\n\ntransition_detector td(clk, reset, in, transition_detect);\nbitwise_operations bo(a, b, bitwise_and, bitwise_xor, bitwise_nor, a_not, b_not);\nfunctional_module fm(clk, reset, transition_detect, bitwise_and, out_and_bitwise);\n\nassign out_not = {b_not, a_not};\n\nendmodule",
        "module_name": "transition_detector",
        "module_hash": "a32e60743ec28be5692394c12ba2698c",
        "dataset_index": 20054
      },
      "clock_gate_c063c40a": {
        "rtl_code": "module clock_gate (\n  input CLK, EN, TE,\n  input [31:0] W,\n  output reg ENCLK,\n  output reg [31:0] Y\n);\n\n  always @ (posedge CLK) begin\n    if (TE) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= EN ? CLK : 1'b0;\n    end\n  end\n\n  always @ (posedge ENCLK) begin\n    Y <= W;\n  end\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "c063c40a5446be7b8241e5cf425986f2",
        "dataset_index": 13945
      },
      "decoder_4to16_1b78253a": {
        "rtl_code": "module decoder_4to16 (\n    input [3:0] in,\n    output [15:0] out\n);\n\nassign out[0] = ~(in[3] | in[2] | in[1] | in[0]);\nassign out[1] = ~(in[3] | in[2] | in[1] | ~in[0]);\nassign out[2] = ~(in[3] | in[2] | ~in[1] | in[0]);\nassign out[3] = ~(in[3] | in[2] | ~in[1] | ~in[0]);\nassign out[4] = ~(in[3] | ~in[2] | in[1] | in[0]);\nassign out[5] = ~(in[3] | ~in[2] | in[1] | ~in[0]);\nassign out[6] = ~(in[3] | ~in[2] | ~in[1] | in[0]);\nassign out[7] = ~(in[3] | ~in[2] | ~in[1] | ~in[0]);\nassign out[8] = ~(~in[3] | in[2] | in[1] | in[0]);\nassign out[9] = ~(~in[3] | in[2] | in[1] | ~in[0]);\nassign out[10] = ~(~in[3] | in[2] | ~in[1] | in[0]);\nassign out[11] = ~(~in[3] | in[2] | ~in[1] | ~in[0]);\nassign out[12] = ~(~in[3] | ~in[2] | in[1] | in[0]);\nassign out[13] = ~(~in[3] | ~in[2] | in[1] | ~in[0]);\nassign out[14] = ~(~in[3] | ~in[2] | ~in[1] | in[0]);\nassign out[15] = ~(~in[3] | ~in[2] | ~in[1] | ~in[0]);\n\nendmodule",
        "module_name": "decoder_4to16",
        "module_hash": "1b78253a13584716116ff17e1e478c28",
        "dataset_index": 9741
      },
      "ERROR_OUTPUT_LOGIC #_4dd9229e": {
        "rtl_code": "module ERROR_OUTPUT_LOGIC #(\n    parameter [7:0] DATA_WIDTH = 1,\n    parameter [7:0] ADDR_WIDTH = 6\n) (\n    input rst,\n    input clk,\n\n    input loop_complete,\n    input error_detected,\n    input [7:0] error_state,\n    input [ADDR_WIDTH-1:0] error_address,\n    input [DATA_WIDTH-1:0] expected_data,\n    input [DATA_WIDTH-1:0] actual_data,\n\n    input tx_data_accepted,\n    output reg tx_data_ready,\n    output reg [7:0] tx_data\n);\n    reg reg_error_detected;\n    reg [7:0] reg_error_state;\n    reg [ADDR_WIDTH-1:0] reg_error_address;\n    reg [DATA_WIDTH-1:0] reg_expected_data;\n    reg [DATA_WIDTH-1:0] reg_actual_data;\n\n    reg [7:0] error_count;\n    reg [7:0] output_shift;\n\n    wire [7:0] next_output_shift = output_shift + 8;\n    wire count_shift_done = next_output_shift >= 8'd16;\n    wire address_shift_done = next_output_shift >= ADDR_WIDTH;\n    wire data_shift_done = next_output_shift >= DATA_WIDTH;\n\n    reg loop_ready;\n    reg [7:0] latched_error_count;\n\n    reg [7:0] errors;\n    reg [10:0] state;\n    reg [15:0] loop_count;\n    reg [15:0] latched_loop_count;\n\n    localparam START = (1 << 0),\n        ERROR_COUNT_HEADER = (1 << 1),\n        ERROR_COUNT_COUNT = (1 << 2),\n        CR = (1 << 3),\n        LF = (1 << 4),\n        ERROR_HEADER = (1 << 5),\n        ERROR_STATE = (1 << 6),\n        ERROR_ADDRESS = (1 << 7),\n        ERROR_EXPECTED_DATA = (1 << 8),\n        ERROR_ACTUAL_DATA = (1 << 9),\n        LOOP_COUNT = (1 << 10);\n\n    initial begin\n        tx_data_ready <= 1'b0;\n        tx_data <= 8'b0;\n        state <= START;\n        reg_error_detected <= 1'b0;\n    end\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state <= START;\n            error_count <= 0;\n            reg_error_detected <= 0;\n            tx_data_ready <= 0;\n            tx_data <= 8'b0;\n            loop_count <= 0;\n            loop_ready <= 0;\n        end else begin\n\n            if(error_detected) begin\n                if(error_count < 255) begin\n                    error_count <= error_count + 1;\n                end\n\n                if(!reg_error_detected) begin\n                    reg_error_detected <= 1;\n                    reg_error_state <= error_state;\n                    reg_error_address <= error_address;\n                    reg_expected_data <= expected_data;\n                    reg_actual_data <= actual_data;\n                end\n            end\n\n            if(tx_data_accepted) begin\n                tx_data_ready <= 0;\n            end\n\n            if(loop_complete) begin\n                loop_count <= loop_count + 1;\n                if(!loop_ready) begin\n                    loop_ready <= 1;\n                    latched_error_count <= error_count;\n                    latched_loop_count <= loop_count;\n                    error_count <= 0;\n                end\n            end\n\n            case(state)\n                START: begin\n                    if(reg_error_detected) begin\n                        state <= ERROR_HEADER;\n                    end else if(loop_ready) begin\n                        state <= ERROR_COUNT_HEADER;\n                    end\n                end\n                ERROR_COUNT_HEADER: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= \"L\";\n                        tx_data_ready <= 1;\n                        state <= ERROR_COUNT_COUNT;\n                    end\n                end\n                ERROR_COUNT_COUNT: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= latched_error_count;\n                        tx_data_ready <= 1;\n                        output_shift <= 0;\n                        state <= LOOP_COUNT;\n                    end\n                end\n                LOOP_COUNT: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (latched_loop_count >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(count_shift_done) begin\n                            output_shift <= 0;\n                            loop_ready <= 0;\n                            state <= CR;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                CR: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= 8'h0D; tx_data_ready <= 1;\n                        state <= LF;\n                    end\n                end\n                LF: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= 8'h0A; tx_data_ready <= 1;\n                        state <= START;\n                    end\n                end\n                ERROR_HEADER: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= \"E\";\n                        tx_data_ready <= 1;\n                        state <= ERROR_STATE;\n                    end\n                end\n                ERROR_STATE: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= reg_error_state;\n                        tx_data_ready <= 1;\n                        output_shift <= 0;\n                        state <= ERROR_ADDRESS;\n                    end\n                end\n                ERROR_ADDRESS: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_error_address >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(address_shift_done) begin\n                            output_shift <= 0;\n                            state <= ERROR_EXPECTED_DATA;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                ERROR_EXPECTED_DATA: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_expected_data >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(data_shift_done) begin\n                            output_shift <= 0;\n                            state <= ERROR_ACTUAL_DATA;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                ERROR_ACTUAL_DATA: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_actual_data >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(data_shift_done) begin\n                            state <= CR;\n                            reg_error_detected <= 0;\n                        end else begin\n                            output_shift <= output_shift + 8;\n                        end\n                    end\n                end\n                default: begin\n                    state <= START;\n                end\n            endcase\n        end\n    end\nendmodule\n",
        "module_name": "ERROR_OUTPUT_LOGIC #",
        "module_hash": "4dd9229e9530d9095add8533bbbc8cbe",
        "dataset_index": 22935
      },
      "bitwise_operations_df4aa65b": {
        "rtl_code": "module bitwise_operations (\n  input [31:0] a,\n  input [31:0] b,\n  input [1:0] operation_select,\n  input [4:0] shift_amount,\n  output reg [31:0] result\n);\n\n  // AND operation\n  wire [31:0] and_result;\n  assign and_result = a & b;\n\n  // OR operation\n  wire [31:0] or_result;\n  assign or_result = a | b;\n\n  // XOR operation\n  wire [31:0] xor_result;\n  assign xor_result = a ^ b;\n\n  // Shift-left operation\n  wire [31:0] shift_result;\n  assign shift_result = a << shift_amount;\n\n  // Select operation based on operation_select input\n  always @* begin\n    case (operation_select)\n      2'b00: result = and_result;\n      2'b01: result = or_result;\n      2'b10: result = xor_result;\n      2'b11: result = shift_result;\n    endcase\n  end\n\nendmodule",
        "module_name": "bitwise_operations",
        "module_hash": "df4aa65ba09b17674410e3791e316f59",
        "dataset_index": 4413
      },
      "top_module_f899f224": {
        "rtl_code": "module top_module(\n    input clk,\n    input areset,   // async active-high reset to zero\n    input [7:0] d,\n    input sel,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [7:0] q\n);\n\n    // First module with 8 D flip-flops triggered by negative edge of clk\n    reg [7:0] dff_q;\n    always @(negedge clk or posedge areset) begin\n        if (areset) begin\n            dff_q <= 8'b0;\n        end else begin\n            dff_q <= {dff_q[3:0], dff_q[7:4]};\n        end\n    end\n    \n    // Multiplexer to select output of first 4 DFFs or last 4 DFFs based on select input\n    wire [3:0] first_half = dff_q[3:0];\n    wire [3:0] second_half = dff_q[7:4];\n    wire [3:0] mux_out;\n    assign mux_out = (sel == 1'b0) ? first_half : second_half;\n    \n    // Second module with 4-bit shift register with asynchronous reset, synchronous load, and enable\n    reg [3:0] shift_reg;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            shift_reg <= 4'b0;\n        end else if (load) begin\n            shift_reg <= data;\n        end else if (ena) begin\n            shift_reg <= {1'b0, shift_reg[3:1]};\n        end\n    end\n    \n    // XOR module to combine outputs of the two given modules\n    wire [7:0] xor_out;\n    assign xor_out = shift_reg ^ mux_out;\n    \n    // Output of the top module\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 8'b0;\n        end else begin\n            q <= xor_out;\n        end\n    end\n    \nendmodule",
        "module_name": "top_module",
        "module_hash": "f899f224f3b5c4995c15fcf8bf0a7c50",
        "dataset_index": 8585
      },
      "gci_std_display_device_special_memory_6912b225": {
        "rtl_code": "module gci_std_display_device_special_memory\n\t#(\n\t\tparameter USEMEMSIZE = 32'h00000000,\n\t\tparameter PRIORITY = 32'h00000000,\n\t\tparameter DEVICECAT = 32'h00000000\n\t)(\t\t\t\t\t\t\t\n\t\t//System\n\t\tinput wire iCLOCK,\n\t\tinput wire inRESET,\n\t\t//Special Addr Access\n\t\tinput wire iSPECIAL_REQ,\n\t\tinput wire iSPECIAL_RW,\n\t\tinput wire [7:0] iSPECIAL_ADDR,\n\t\tinput wire [31:0] iSPECIAL_DATA,\n\t\toutput wire [31:0] oSPECIAL_DATA\n\t);\n\t\n\tinteger\ti;\n\t\n\treg [31:0] b_mem[0:255];\t\n\talways@(posedge iCLOCK or negedge inRESET)begin\n\t\tif(!inRESET)begin\n\t\t\tfor(i = 0; i < 256; i = i + 1)begin\n\t\t\t\tif(i == 0)begin\n\t\t\t\t\t//USEMEMSIZE\n\t\t\t\t\tb_mem[i] <= USEMEMSIZE;\n\t\t\t\tend\n\t\t\t\telse if(i == 1)begin\n\t\t\t\t\t//PRIORITY\n\t\t\t\t\tb_mem[i] <= PRIORITY;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\t//Other\n\t\t\t\t\tb_mem[i] <= 32'h00000000;\n\t\t\t\tend\n\t\t\tend\t\t\n\t\tend\n\t\telse begin\n\t\t\tif(iSPECIAL_REQ && iSPECIAL_RW)begin\n\t\t\t\tb_mem [iSPECIAL_ADDR] <= iSPECIAL_DATA;\n\t\t\tend\t\n\t\tend\n\tend //always\n\t\n\tassign oSPECIAL_DATA = b_mem[iSPECIAL_ADDR];\n\t\nendmodule",
        "module_name": "gci_std_display_device_special_memory",
        "module_hash": "6912b225a9c04ef9656c633c7dc172d8",
        "dataset_index": 5666
      },
      "traffic_light_controller_b7924223": {
        "rtl_code": "module traffic_light_controller (\n  input clk,\n  input reset,\n  output reg green,\n  output reg yellow,\n  output reg red\n);\n\n  // define the states\n  localparam [1:0] GREEN = 2'b00;\n  localparam [1:0] YELLOW = 2'b01;\n  localparam [1:0] RED = 2'b10;\n  \n  // define the state register and initialize to GREEN\n  reg [1:0] state_reg = GREEN;\n  \n  // define the counter for each state\n  reg [3:0] green_counter = 4'd0;\n  reg [3:0] yellow_counter = 4'd0;\n  reg [3:0] red_counter = 4'd0;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state_reg <= GREEN;\n      green_counter <= 4'd0;\n      yellow_counter <= 4'd0;\n      red_counter <= 4'd0;\n      green <= 1'b1;\n      yellow <= 1'b0;\n      red <= 1'b0;\n    end\n    else begin\n      case (state_reg)\n        GREEN: begin\n          green_counter <= green_counter + 1;\n          if (green_counter == 4'd9) begin\n            state_reg <= YELLOW;\n            green_counter <= 4'd0;\n            yellow <= 1'b1;\n            green <= 1'b0;\n          end\n        end\n        YELLOW: begin\n          yellow_counter <= yellow_counter + 1;\n          if (yellow_counter == 4'd1) begin\n            state_reg <= RED;\n            yellow_counter <= 4'd0;\n            red <= 1'b1;\n            yellow <= 1'b0;\n          end\n        end\n        RED: begin\n          red_counter <= red_counter + 1;\n          if (red_counter == 4'd7) begin\n            state_reg <= GREEN;\n            red_counter <= 4'd0;\n            green <= 1'b1;\n            red <= 1'b0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "traffic_light_controller",
        "module_hash": "b7924223b44f98ae6f7cc9038c6f8564",
        "dataset_index": 12533
      },
      "up_down_counter_c7384320": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input reset,\n    input up_down,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else if (up_down) begin\n            q <= q + 1;\n        end else begin\n            q <= q - 1;\n        end\n    end\nendmodule\n\nmodule left_rotator (\n    input [3:0] D,\n    output reg [3:0] q\n);\n    always @* begin\n        q[0] = D[1];\n        q[1] = D[2];\n        q[2] = D[3];\n        q[3] = D[0];\n    end\nendmodule\n\nmodule functional_module (\n    input [7:0] up_down_out,\n    input [3:0] left_rotator_out,\n    input select,\n    output reg [7:0] q\n);\n    always @* begin\n        if (select) begin\n            q <= up_down_out;\n        end else begin\n            q <= {left_rotator_out, 4'b0};\n        end\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input up_down,\n    input [3:0] D,\n    input select,\n    output [7:0] q\n);\n    wire [7:0] up_down_out;\n    wire [3:0] left_rotator_out;\n\n    up_down_counter udc (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .q(up_down_out)\n    );\n\n    left_rotator lr (\n        .D(D),\n        .q(left_rotator_out)\n    );\n\n    functional_module fm (\n        .up_down_out(up_down_out),\n        .left_rotator_out(left_rotator_out),\n        .select(select),\n        .q(q)\n    );\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "c7384320dd74d1acd0c3ed9ce128cc08",
        "dataset_index": 9379
      },
      "div_module_45d0fa33": {
        "rtl_code": "module div_module(\n  input clk,\n  input reset,\n  input [7:0] in1,\n  input [7:0] in2,\n  output [15:0] out,\n  output [7:0] remainder\n);\n\n  reg [15:0] quotient_reg;\n  reg [7:0] remainder_reg;\n  reg [7:0] in2_reg;\n  reg [7:0] count_reg;\n  wire [7:0] in1_reg;\n\n  assign in1_reg = (count_reg == 0) ? in1 : quotient_reg[7:0];\n  assign out = quotient_reg;\n  assign remainder = remainder_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      quotient_reg <= 16'd0;\n      remainder_reg <= 8'd0;\n      in2_reg <= 8'd0;\n      count_reg <= 8'd0;\n    end else begin\n      if (count_reg == 0) begin\n        in2_reg <= in2;\n        quotient_reg[15:8] <= in1;\n        quotient_reg[7:0] <= 8'd0;\n        remainder_reg <= 8'd0;\n      end else begin\n        {quotient_reg[15:1], quotient_reg[0]} <= {quotient_reg[14:0], in1_reg[7]};\n        remainder_reg <= {remainder_reg[6:0], in1_reg[7]} - in2_reg;\n      end\n      count_reg <= count_reg + 1;\n    end\n  end\n\nendmodule",
        "module_name": "div_module",
        "module_hash": "45d0fa33c36a8fc53a9164495c501ad5",
        "dataset_index": 17304
      },
      "pipelined_nor_gate_f0b53823": {
        "rtl_code": "\nmodule pipelined_nor_gate(\n    input a,\n    input b,\n    output out\n);\n\nreg pipe1, pipe2;\n\nalways @(a or b) begin\n    pipe1 <= ~(a & b);\nend\n\nalways @(pipe1) begin\n    pipe2 <= ~pipe1;\nend\n\nassign out = pipe2;\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    output out\n);\n\nwire pipe1, pipe2;\npipelined_nor_gate g1(a, b, pipe1);\npipelined_nor_gate g2(pipe1, pipe1, pipe2);\npipelined_nor_gate g3(pipe2, pipe2, out);\n\nendmodule\n",
        "module_name": "pipelined_nor_gate",
        "module_hash": "f0b53823999f77aaa5e1f9892e6e86ba",
        "dataset_index": 17264
      },
      "d_ff_async_reset_set_52a0aeba": {
        "rtl_code": "\nmodule d_ff_async_reset_set (\n  input CLK,\n  input D,\n  input Reset,\n  input Set,\n  output reg Q\n);\n\n  wire next_q, q_next_r, q_next_s;\n\n  assign q_next_s = Set;\n  assign q_next_r = Reset;\n  assign next_q = (q_next_s | (~q_next_r & ~q_next_s & D)) ^ Q;\n\n  always @(posedge CLK)\n    Q <= next_q;\n\nendmodule",
        "module_name": "d_ff_async_reset_set",
        "module_hash": "52a0aeba8c3e3c972ac617cbaa1a77d6",
        "dataset_index": 5951
      },
      "binary_counter_d3afccb2": {
        "rtl_code": "module binary_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else if (count == 4'b1111) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "binary_counter",
        "module_hash": "d3afccb2f1a5780a00e48b0c082e8699",
        "dataset_index": 3703
      },
      "bit_reversal_43fea43d": {
        "rtl_code": "`define size ((DATA_SIZE/4) * (2 ** (type - 1)))\n\nmodule bit_reversal\n#(\n\tparameter DATA_SIZE = 32\n)\n(\n\toutput [DATA_SIZE - 1 : 0] data_out,\n\tinput  [DATA_SIZE - 1 : 0] data_in,\n\tinput  [1 : 0] rev_type\n);\n\n\nlocalparam NO_REVERSE = 2'b00; \nlocalparam BYTE       = 2'b01;\nlocalparam HALF_WORD  = 2'b10;\nlocalparam WORD       = 2'b11;\n\nlocalparam TYPES = 4;\n\nwire [DATA_SIZE - 1 : 0] data_reversed[0 : 3];\n\n\nassign data_reversed[NO_REVERSE] = data_in; generate\n\tgenvar i, type;\n\tfor(type = 1 ; type < TYPES; type = type + 1)\n\t\tfor(i = 0; i < DATA_SIZE; i = i + 1)\n\t\t\tbegin\n\t\t\t\tif(i < `size)\n\t\t\t\t\tassign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - i];\n\t\t\t\telse\n\t\t\t\t\tassign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - (i%(`size*(i/`size)))];\n\t\t\tend\nendgenerate\n\nassign data_out = data_reversed[rev_type];\n\nendmodule\n",
        "module_name": "bit_reversal",
        "module_hash": "43fea43db3428faa867c6760b4ca4db6",
        "dataset_index": 23967
      },
      "bin2gray_eaaab218": {
        "rtl_code": "module bin2gray(\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[3] = binary[3];\n  assign gray[2] = binary[3] ^ binary[2];\n  assign gray[1] = binary[2] ^ binary[1];\n  assign gray[0] = binary[1] ^ binary[0];\n\nendmodule",
        "module_name": "bin2gray",
        "module_hash": "eaaab218fff02eaa2eafb2cb29c8e775",
        "dataset_index": 6517
      },
      "spi_2dda26f2": {
        "rtl_code": "module spi(\n\n\tclock, sck,   sdo,   sdi,   bsync, start, halfspeed, din,  dout  );\n\n\tinput clock;\n\n\n\toutput sck;\n\twire   sck;\n\n\toutput sdo;\n\n\tinput sdi;\n\n\toutput reg bsync;\n\n\tinput start;\n\n\tinput halfspeed;\n\n\tinput [7:0] din;\n\n\toutput reg [7:0] dout;\n\n\n\n\treg [4:0] counter; wire enable_n; reg [6:0] shiftin; reg [7:0] shiftout; wire ena_shout_load; reg g_ena;\n\n\n\tinitial begin\n\t\tcounter = 5'b10000;\n\t\tshiftout = 8'd0;\n\t\tshiftout = 7'd0;\n\t\tbsync = 1'd0;\n\t\tdout <= 1'b0;\n\tend\n\n\n\n\n\tassign sck = counter[0];\n\n\tassign enable_n = counter[4];\n\n\tassign sdo = shiftout[7];\n\n\tassign ena_shout_load = (start | sck) & g_ena;\n\n\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( g_ena )\n\t\tbegin\n\t\t\tif( start )\n\t\t\tbegin\n\t\t\t\tcounter <= 5'b00000; bsync <= 1'b1; end\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif( !sck ) begin\n      \t                  shiftin[6:0] <= { shiftin[5:0], sdi };\n\n\t\t\t\t\tif( (&counter[3:1]) && (!enable_n) )\n\t\t\t\t\t\tdout <= { shiftin[6:0], sdi }; end\n\t\t\t\telse begin\n\t\t\t\t\tbsync <= 1'b0;\n\t\t\t\tend\n\n\t\t\t\tif( !enable_n )\n\t\t\t\t\tcounter <= counter + 5'd1;\n\t\t\tend\n\t\tend\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( ena_shout_load )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\tshiftout <= din;\n\t\t\telse shiftout[7:0] <= { shiftout[6:0], shiftout[0] }; end\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( halfspeed )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\tg_ena <= 1'b0;\n\t\t\telse if( enable_n )\n\t\t\t\tg_ena <= 1'b1;\n\t\t\telse\n\t\t\t\tg_ena <= ~g_ena;\n\t\tend\n\t\telse\n\t\t\tg_ena <= 1'b1;\n\tend\n\n\n\nendmodule\n",
        "module_name": "spi",
        "module_hash": "2dda26f2aff98bdbbda2aa33ef14c901",
        "dataset_index": 22156
      },
      "fifo_21899280": {
        "rtl_code": "\nmodule fifo (\n   // Outputs\n   out0, out1,\n   // Inputs\n   clk, wr0a, wr0b, wr1a, wr1b, inData\n);\n\n   input         clk;\n   input         wr0a;\n   input         wr0b;\n   input         wr1a;\n   input         wr1b;\n   input [15:0]  inData;\n\n   output [15:0] out0;\n   output [15:0] out1;\n\n   reg [15:0]    mem [1:0];\n\n\n   assign        out0 = mem[0];\n   assign        out1 = mem[1];\n\n   always @(posedge clk) begin\n      // These mem assignments must be done in order after processing\n      if (wr0a) begin\n         mem[0] <=  inData;\n      end\n      if (wr0b) begin\n         mem[0] <= ~inData;\n      end\n      if (wr1a) begin\n         mem[1] <=  inData;\n      end\n      if (wr1b) begin\n         mem[1] <= ~inData;\n      end\n   end\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "218992805ee4ddd0840ad59ead637545",
        "dataset_index": 8818
      },
      "power_check_efde2a94": {
        "rtl_code": "\nmodule power_check (\n    input  VPWR,\n    input  VGND,\n    input  VPB,\n    input  VNB,\n    output reg power_ok\n);\n\n    wire w_power_ok;\n\n    assign w_power_ok = (VPWR && VPB);\n    always @(*) begin\n        power_ok <= w_power_ok;\n    end\n\nendmodule\n",
        "module_name": "power_check",
        "module_hash": "efde2a9497d9b2c57758adbf3e708f50",
        "dataset_index": 19493
      },
      "Multiplexer_AC__parameterized33_b80dc38d": {
        "rtl_code": "\nmodule Multiplexer_AC__parameterized33\n   (ctrl,\n    D0,\n    D1,\n    D2,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  input [0:0]D2;\n  output [0:0]S;\n\n  wire [0:0]S;\n  wire [2:0]sel;\n\n  assign sel = {ctrl, ctrl};\n\n  assign S = (sel == 3'b000) ? D0 : \n             (sel == 3'b001) ? D1 : \n             (sel == 3'b010) ? D2 : 0;\n\nendmodule\n",
        "module_name": "Multiplexer_AC__parameterized33",
        "module_hash": "b80dc38d0b24c495777ae00550a8b9bd",
        "dataset_index": 14151
      },
      "addition_module_640184ad": {
        "rtl_code": "module addition_module(\n\tinput [7:0] A,\n\tinput [7:0] B,\n\tinput reset,\n\tinput clk,\n\toutput reg [15:0] C\n);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tC <= 16'b0;\n\t\tend else begin\n\t\t\tC <= A + B;\n\t\tend\n\tend\n\nendmodule",
        "module_name": "addition_module",
        "module_hash": "640184ad1ea0c2279e6f08dc7f5e3f1b",
        "dataset_index": 11897
      },
      "top__45ae4e64": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    input A, B,\n    output reg [15:0] Y\n);\n\nreg [2:0] shift_reg;\nreg [15:0] decoder_out;\n\nalways @(posedge clk) begin\n    if (control == 1'b0) begin\n        // Shift right\n        shift_reg <= {shift_reg[0], shift_reg[2:1]};\n    end else begin\n        // Shift left\n        shift_reg <= {shift_reg[2:0], shift_reg[1]};\n    end\n\n    if (shift == 1'b1) begin\n        // Shift in parallel_load value\n        shift_reg <= parallel_load;\n    end\n\n    decoder_out <= 16'b0;\n    case ({A, B})\n        2'b00: decoder_out[shift_reg] <= 1'b1;\n        2'b01: decoder_out[shift_reg >> 1] <= 1'b1;\n        2'b10: decoder_out[shift_reg >> 2] <= 1'b1;\n        2'b11: decoder_out[shift_reg >> 3] <= 1'b1;\n    endcase\n\n    Y <= decoder_out;\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "45ae4e64ad33b97d1e6a016f673ca94e",
        "dataset_index": 5162
      },
      "stratixii_lvds_rx_deser #_992a3c88": {
        "rtl_code": "\nmodule stratixii_lvds_rx_deser #(\n    parameter channel_width = 10\n)(\n    input clk,\n    input datain,\n    input devclrn,\n    input devpor,\n    output [channel_width-1:0] dataout\n);\n\n\nreg [channel_width-1:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (devclrn || devpor) begin\n        shift_reg <= 0;\n    end else begin\n        shift_reg <= {shift_reg[channel_width-2:0], datain};\n    end\nend\n\nassign dataout = shift_reg;\n\nendmodule\n",
        "module_name": "stratixii_lvds_rx_deser #",
        "module_hash": "992a3c88e239a9446133aac0859a78cc",
        "dataset_index": 17628
      },
      "nand4bb_b64f116a": {
        "rtl_code": "module nand4bb (\n    input  A_N,\n    input  B_N,\n    input  C  ,\n    input  D  ,\n    output Y\n);\n\n    assign Y = ~(A_N & B_N & C & D);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule",
        "module_name": "nand4bb",
        "module_hash": "b64f116a63771e8a399c72b971834585",
        "dataset_index": 11600
      },
      "sky130_fd_sc_hd__and3_b29e1836": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__and3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, C, A, B        );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__and3",
        "module_hash": "b29e1836e1166fa1ff0b854188c467b0",
        "dataset_index": 22868
      },
      "VCO_interface_34ab74f8": {
        "rtl_code": "module VCO_interface (\n  input in,\n  input [7:0] vctrl,\n  output reg out\n);\n\nparameter fmin = 1; // minimum frequency of the VCO\nparameter fmax = 1000; // maximum frequency of the VCO\nparameter vmin = 0; // minimum voltage of the VCO\nparameter vmax = 255; // maximum voltage of the VCO\n\nreg [31:0] count;\nreg [31:0] freq;\n\nalways @ (posedge in) begin\n  count <= count + 1;\n  if (count >= freq) begin\n    out <= ~out;\n    count <= 0;\n  end\nend\n\nalways @ (vctrl) begin\n  freq <= (vctrl - vmin) * (fmax - fmin) / (vmax - vmin) + fmin;\nend\n\nendmodule",
        "module_name": "VCO_interface",
        "module_hash": "34ab74f8359871c0749b3b84eb5b515a",
        "dataset_index": 2140
      },
      "TDC_e10d6804": {
        "rtl_code": "module TDC (\n  input clk,\n  input in1,\n  input in2,\n  output reg [15:0] out\n);\n\nparameter resolution = 1; // resolution of the TDC in picoseconds\n\nreg in1_prev, in2_prev;\nreg [15:0] count;\n\nalways @(posedge clk) begin\n  if (in1 && !in1_prev) begin\n    count <= 0;\n  end else if (in2 && !in2_prev) begin\n    out <= count * resolution;\n  end else begin\n    count <= count + 1;\n  end\n  in1_prev <= in1;\n  in2_prev <= in2;\nend\n\nendmodule",
        "module_name": "TDC",
        "module_hash": "e10d6804885b60776154b771ba4282ca",
        "dataset_index": 1532
      },
      "sky130_fd_sc_hs__o21a_079ff496": {
        "rtl_code": "module sky130_fd_sc_hs__o21a (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    VPWR,\n    VGND\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n\n    assign X = (A1 & A2 & B1 & VPWR & VGND);\n\nendmodule",
        "module_name": "sky130_fd_sc_hs__o21a",
        "module_hash": "079ff49687fd5e1f8c2b1debb2dab153",
        "dataset_index": 4607
      },
      "rc4_df95660a": {
        "rtl_code": "module rc4(\n  input clk,\n  input rst_n,\n  input control_in,\n  input write,\n  input read,\n  input [7:0] keylength,\n  input [7:0] keydata,\n  output control_out,\n  output reg [7:0] streamvalue\n);\n\nreg [7:0] state [0:255];\nreg [7:0] key [0:255];\nreg [7:0] i, j;\nreg [7:0] keystream [0:255];\nreg [7:0] plaintext [0:255];\nreg [7:0] ciphertext [0:255];\nreg [7:0] count;\nreg [7:0] temp;\n\nassign control_out = count == keylength;\n\nalways @(posedge clk) begin\n  if (!rst_n) begin\n    i <= 0;\n    j <= 0;\n    count <= 0;\n    streamvalue <= 0;\n  end else begin\n    if (write) begin\n      key[count] <= keydata;\n      count <= count + 1;\n    end\n    if (control_in) begin\n      if (count == keylength) begin\n        for (i = 0; i < 256; i = i + 1) begin\n          state[i] <= i;\n          keystream[i] <= 0;\n        end\n        j <= 0;\n        for (i = 0; i < 256; i = i + 1) begin\n          j <= (j + state[i] + key[i % keylength]) & 255;\n          temp <= state[i];\n          state[i] <= state[j];\n          state[j] <= temp;\n        end\n        i <= 0;\n        j <= 0;\n        count <= 0;\n      end\n    end else begin\n      if (read) begin\n        streamvalue <= keystream[i] ^ plaintext[i];\n        i <= i + 1;\n      end else begin\n        plaintext[i] <= streamvalue;\n        keystream[i] <= state[i];\n        ciphertext[i] <= keystream[i] ^ plaintext[i];\n        i <= i + 1;\n        j <= (j + state[i] + key[i % keylength]) & 255;\n        temp <= state[i];\n        state[i] <= state[j];\n        state[j] <= temp;\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "rc4",
        "module_hash": "df95660a2eff1ab7056068bbf20e7fa0",
        "dataset_index": 3134
      },
      "my__84b806e5": {
        "rtl_code": "module my_module (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    wire a_and;\n    wire b_not;\n\n    // AND gate to check if A1, A2, and A3 are all high\n    and gate_a(a_and, A1, A2, A3);\n\n    // NOT gate to invert B1 signal\n    not gate_b(b_not, B1);\n\n    // AND gate to combine a_and and b_not signals\n    and gate_x(X, a_and, b_not);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "84b806e5868dee3fd1e860ed5bca81ec",
        "dataset_index": 19836
      },
      "rotator_shift_register_669bf39c": {
        "rtl_code": "module rotator_shift_register (\n    input clk,                 // Clock for the rotator\n    input load,                // Synchronous load for the rotator\n    input [1:0] ena,           // Enable for the rotator\n    input [99:0] data,         // Input data for the rotator\n    input d,                   // Serial input for the shift register\n    output reg [2:0] q         // Output from the functional module\n);\n\n    // Rotator module\n    reg [99:0] rotator_out;\n    always @(posedge clk) begin\n        if (load) rotator_out <= data;\n        else if (ena[1]) rotator_out <= {rotator_out[0], rotator_out[99:1]};\n        else if (ena[0]) rotator_out <= {rotator_out[98:0], rotator_out[99]};\n    end\n    \n    // Shift register module\n    reg [2:0] shift_reg_out;\n    reg [2:0] shift_reg_in;\n    always @(posedge clk) begin\n        shift_reg_in <= {shift_reg_in[1:0], d};\n        shift_reg_out <= {shift_reg_out[1:0], shift_reg_in[2]};\n    end\n    \n    // Functional module\n    always @* begin\n        q[0] = rotator_out[0] | shift_reg_out[0];\n        q[1] = rotator_out[50] | shift_reg_out[1];\n        q[2] = rotator_out[99] | shift_reg_out[2];\n    end\n\nendmodule",
        "module_name": "rotator_shift_register",
        "module_hash": "669bf39c1ab1190d199f5e9010e5ea0f",
        "dataset_index": 10679
      },
      "top__b2347322": {
        "rtl_code": "module top_module (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    input [3:0] in,\n    input [1:0] sel,\n    input enable,\n    output [3:0] OUT\n);\n\nwire [3:0] mux_out;\nwire [3:0] shift_reg_out;\n\nmux_4to1 mux_inst (\n    .in(in),\n    .sel(sel),\n    .enable(enable),\n    .out(mux_out)\n);\n\nshift_register shift_reg_inst (\n    .CLK(CLK),\n    .RST(RST),\n    .LD(LD),\n    .D(D),\n    .Q(shift_reg_out)\n);\n\nassign OUT = mux_out & shift_reg_out;\n\nendmodule\n\nmodule mux_4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    input enable,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\n\nalways @(*) begin\n    if (enable) begin\n        case (sel)\n            2'b00: out_reg = in[0];\n            2'b01: out_reg = in[1];\n            2'b10: out_reg = in[2];\n            2'b11: out_reg = in[3];\n            default: out_reg = 4'b0;\n        endcase\n    end else begin\n        out_reg = 4'b0;\n    end\nend\n\nassign out = out_reg;\n\nendmodule\n\nmodule shift_register (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    output [3:0] Q\n);\n\nreg [3:0] Q_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        Q_reg <= 4'b0;\n    end else begin\n        if (LD) begin\n            Q_reg <= D;\n        end else begin\n            Q_reg <= {Q_reg[2:0], Q_reg[3]};\n        end\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "b2347322fc9d15ca95759eb848b638fe",
        "dataset_index": 20773
      },
      "binary_stack_1ec8375f": {
        "rtl_code": "module binary_stack\n(\n    input clk,\n    input rst,\n    input push_i,\n    input pop_i,\n    input [dw-1:0] data_i,\n    output [dw-1:0] data_o,\n    output empty_o\n);\n\nparameter dw = 8;\nparameter stack_size = 8;\n\nreg [dw-1:0] stack [0:stack_size-1];\nreg top = 0;\n\nalways @(posedge clk)\nbegin\n    if (rst)\n        top <= 0;\n    else if (push_i && (top < stack_size))\n    begin\n        stack[top] <= data_i;\n        top <= top + 1;\n    end\n    else if (pop_i && (top > 0))\n        top <= top - 1;\nend\n\nassign data_o = (top > 0) ? stack[top-1] : 0;\nassign empty_o = (top == 0);\n\nendmodule",
        "module_name": "binary_stack",
        "module_hash": "1ec8375f92a3bb84bf48df6f8a0b6f51",
        "dataset_index": 15890
      },
      "acl_fp_custom_add_op_1be634a7": {
        "rtl_code": "module acl_fp_custom_add_op(\tclock, resetn, left_mantissa, right_mantissa, left_sign, right_sign, common_exponent,\n\t\t\t\t\t\t\t\t\t\tresulting_mantissa, resulting_exponent, resulting_sign,\n\t\t\t\t\t\t\t\t\t\tvalid_in, valid_out, stall_in, stall_out, enable);\n\n\tparameter HIGH_CAPACITY = 1;\n\t\n\tinput clock, resetn, left_sign, right_sign;\n\tinput [26:0] left_mantissa;\n\tinput [26:0] right_mantissa;\n\tinput [8:0] common_exponent;\n\tinput valid_in, stall_in, enable;\n\t output reg [27:0] resulting_mantissa;\n\t output reg [8:0] resulting_exponent;\n\t output reg resulting_sign;\n\t output reg valid_out;\n\toutput stall_out;\n\t\n\twire enable_add = (HIGH_CAPACITY==1) ? (~valid_out | ~stall_in) : enable;\n\twire do_subtraction = right_sign ^ left_sign;\n\tassign stall_out = valid_out & stall_in;\n\twire [27:0] op_ab = left_mantissa + ({28{do_subtraction}} ^ right_mantissa) + do_subtraction;\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tresulting_mantissa <= 28'bxxxxxxxxxxxxxxxxxxxxxxxxxxxx;\n\t\t\tresulting_exponent <= 9'bxxxxxxxx;\n\t\t\tresulting_sign <= 1'bx;\n\t\t\tvalid_out <= 1'b0;\n\t\tend\n\t\telse if (enable_add)\n\t\tbegin\n\t\t\tvalid_out <= valid_in;\n\t\t\tresulting_mantissa <= op_ab;\n\t\t\tresulting_exponent <= common_exponent;\n\t\t\tresulting_sign <= left_sign;\n\t\tend\n\tend\n\t\nendmodule\n\n",
        "module_name": "acl_fp_custom_add_op",
        "module_hash": "1be634a7cf804c3aa361f42973ad03b7",
        "dataset_index": 25667
      },
      "sky130_fd_sc_lp__iso1p_ec7ba452": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__iso1p (\n    X    ,\n    A    ,\n    SLEEP\n);\n\n    output X    ;\n    input  A    ;\n    input  SLEEP;\n\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__iso1p",
        "module_hash": "ec7ba4529513d9e4ea631e302d45f9c2",
        "dataset_index": 22733
      },
      "counter_32ae02eb": {
        "rtl_code": "\nmodule counter (\n    input CLK,\n    input RESET,\n    input LOAD,\n    input [3:0] LOAD_VAL,\n    output [3:0] Q\n);\n    reg [3:0] Q;\n\n    always @(posedge CLK, posedge RESET) begin\n        if (RESET) begin\n            Q <= 4'b0;\n        end else if (LOAD) begin\n            Q <= LOAD_VAL;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nendmodule\nmodule priority_mux (\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output Y, Z\n);\n    wire Y, Z;\n\n    assign Y = (S == 2'b01) ? A :\n              (S == 2'b10) ? B :\n              (S == 2'b11) ? ((D) ? D : (C) ? C : (B) ? B : A) :\n              1'b0;\n\n    assign Z = (S == 2'b01) ? ~A :\n              (S == 2'b10) ? ~B :\n              (S == 2'b11) ? ((D) ? ~D : (C) ? ~C : (B) ? ~B : ~A) :\n              1'b0;\nendmodule\nmodule final_output_module (\n    input [3:0] Q,\n    input Y,\n    output final_output\n);\n    wire final_output;\n\n    assign final_output = (Q[0] == 1) && Y;\nendmodule\nmodule top_module (\n    input CLK,\n    input RESET,\n    input LOAD,\n    input [3:0] LOAD_VAL,\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output [3:0] Q,\n    output Y, Z,\n    output final_output\n);\n    counter counter_inst (\n        .CLK(CLK),\n        .RESET(RESET),\n        .LOAD(LOAD),\n        .LOAD_VAL(LOAD_VAL),\n        .Q(Q)\n    );\n\n    priority_mux priority_mux_inst (\n        .A(A),\n        .B(B),\n        .C(C),\n        .D(D),\n        .S(S),\n        .Y(Y),\n        .Z(Z)\n    );\n\n    final_output_module final_output_inst (\n        .Q(Q),\n        .Y(Y),\n        .final_output(final_output)\n    );\nendmodule",
        "module_name": "counter",
        "module_hash": "32ae02eb84e06b0cc5a9f4d8fbfa6531",
        "dataset_index": 8508
      },
      "d_ff_reset_enable_f4e4ff16": {
        "rtl_code": "\nmodule d_ff_reset_enable (\n    input CLK,\n    input D,\n    input RESET_N,\n    input ENABLE,\n    output reg Q,\n    output Q_N\n);\n\nalways @(posedge CLK or negedge RESET_N) begin\n    if (~RESET_N) begin\n        Q <= 0;\n    end else if (ENABLE) begin\n        Q <= D;\n    end\nend\n\nassign Q_N = ~Q;\n\nendmodule\n",
        "module_name": "d_ff_reset_enable",
        "module_hash": "f4e4ff162a09f4ee63fa232bad4d1226",
        "dataset_index": 18810
      },
      "Multiplexer_4to1_e1c9d17d": {
        "rtl_code": "module Multiplexer_4to1 (\n    input ctrl0, ctrl1,\n    input [0:0] D0, D1, D2, D3,\n    output reg [0:0] S\n);\n\n  always @* begin\n    case ({ctrl1, ctrl0})\n      2'b00: S = D0;\n      2'b01: S = D1;\n      2'b10: S = D2;\n      2'b11: S = D3;\n    endcase\n  end\n\nendmodule\n\nmodule LUT4 (\n    input [3:0] I,\n    output reg O\n);\n\n  always @* begin\n    case (I)\n      4'b0000: O = 1'b1;\n      4'b0001: O = 1'b0;\n      4'b0010: O = 1'b1;\n      4'b0011: O = 1'b0;\n      4'b0100: O = 1'b1;\n      4'b0101: O = 1'b0;\n      4'b0110: O = 1'b1;\n      4'b0111: O = 1'b0;\n      4'b1000: O = 1'b0;\n      4'b1001: O = 1'b1;\n      4'b1010: O = 1'b0;\n      4'b1011: O = 1'b1;\n      4'b1100: O = 1'b0;\n      4'b1101: O = 1'b1;\n      4'b1110: O = 1'b0;\n      4'b1111: O = 1'b1;\n    endcase\n  end\n\nendmodule",
        "module_name": "Multiplexer_4to1",
        "module_hash": "e1c9d17de4bceb3c48bc5675b26a8fa4",
        "dataset_index": 6896
      },
      "async_fifo_d1317c79": {
        "rtl_code": "\nmodule async_fifo(\n\ti_push,\n\ti_pop,\n\ti_reset,\n\ti_wclk,\n\ti_rclk,\n\ti_wdata,\n\to_rdata,\n\to_full,\n\to_empty\n    );\n\nparameter F_WIDTH = 4;\nparameter F_SIZE = 1 << F_WIDTH;\nparameter F_MAX = 32; input i_reset;\ninput i_rclk;\ninput i_wclk;\ninput i_push;\ninput i_pop;\ninput [65:0] i_wdata;\noutput reg [65:0] o_rdata;\noutput reg o_empty;\noutput reg o_full;\n\nreg [F_WIDTH-1:0] read_pos;\nreg [F_WIDTH-1:0] write_pos;\nreg [65:0] memory[F_SIZE -1 : 0];\nreg [7:0] total_count; reg [7:0] read_counter;\nreg [7:0] write_counter;\n\nalways @(*) begin\n\ttotal_count = write_counter - read_counter;\n   o_empty = (total_count == 0);\n   o_full = (total_count == F_MAX);\nend\n\nalways @(posedge i_wclk) begin\n\tif(i_reset) begin\n\t\twrite_counter <= 0;\n\t\twrite_pos <= 0;\n\tend\n\telse if(!o_full && i_push) begin\n\t\tmemory[write_pos] <= i_wdata;\n\t\twrite_pos <= write_pos + 1'b1;\n\t\twrite_counter <= write_counter + 1'b1;\n\tend\nend\n\nalways @(posedge i_rclk) begin\n\tif(i_reset) begin\n\t\tread_counter <= 0;\n\t\tread_pos <= 0;\n\tend\n\telse if(!o_empty && i_pop) begin\n\t\to_rdata <= memory[read_pos];\n\t\tread_pos <= read_pos + 1'b1;\n\t\tread_counter <= read_counter + 1'b1;\n\tend\nend\n\n\nendmodule\n\n",
        "module_name": "async_fifo",
        "module_hash": "d1317c79840ace497a1b96800b234d7b",
        "dataset_index": 7597
      },
      "priority_encoder_69ed1f35": {
        "rtl_code": "module priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nreg [7:0] gray;\nreg [2:0] binary;\n\n// Binary-to-Gray code converter\nalways @(*) begin\n    gray[0] = in[0];\n    gray[1] = in[0] ^ in[1];\n    gray[2] = in[1] ^ in[2];\n    gray[3] = in[2] ^ in[3];\n    gray[4] = in[3] ^ in[4];\n    gray[5] = in[4] ^ in[5];\n    gray[6] = in[5] ^ in[6];\n    gray[7] = in[6] ^ in[7];\nend\n\n// Gray-to-binary code converter\nalways @(*) begin\n    binary[2] = gray[7];\n    binary[1] = binary[2] ^ gray[6];\n    binary[0] = binary[1] ^ gray[5];\nend\n\n// Priority encoder\nalways @(*) begin\n    if (binary[2]) pos = 3;\n    else if (binary[1]) pos = 2;\n    else if (binary[0]) pos = 1;\n    else pos = 0;\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "69ed1f3560bf7c2327b6af9d5d04920c",
        "dataset_index": 2732
      },
      "seven_seg_edfdb228": {
        "rtl_code": "\nmodule seven_seg (\n                    clk,\n                    clr,\n                    disp_num,   \n                    Scanning,   \n                    SW,\n                    AN,     \n                    SEGMENT     \n                    );\n\n    input wire          clk, clr;\n    input wire  [ 1: 0] Scanning;       \n    input wire  [ 1: 0] SW;\n    input wire  [31: 0] disp_num;       \n    \n    output reg  [ 3: 0] AN;             \n    output wire [ 7: 0] SEGMENT;     \n\n    reg         [ 3: 0] digit       = 4'h0;\n    reg         [ 7: 0] temp_seg    = 8'h0, \n                        digit_seg   = 8'h0;\n    wire        [15: 0] disp_current;\n\n    assign SEGMENT = SW[0] ? digit_seg : temp_seg;                  assign disp_current = SW[1] ? disp_num[31:16] : disp_num[15:0]; always @(posedge clk)begin\n        case (digit)\n            4'h0:     digit_seg = 8'b10000001; \n\t\t    4'h1:     digit_seg = 8'b11001111; \n\t\t    4'h2:     digit_seg = 8'b10010010; \n\t\t    4'h3:     digit_seg = 8'b10000110; \n\t\t    4'h4:     digit_seg = 8'b11001100; \n\t\t    4'h5:     digit_seg = 8'b10100100; \n\t\t    4'h6:     digit_seg = 8'b10100000; \n\t\t    4'h7:     digit_seg = 8'b10001111; \n\t\t    4'h8:     digit_seg = 8'b10000000; \n\t\t    4'h9:     digit_seg = 8'b10000100; \n\t\t    4'hA:     digit_seg = 8'b10001000; \n\t\t    4'hB:     digit_seg = 8'b11100000; \n\t\t    4'hC:     digit_seg = 8'b10110001; \n\t\t    4'hD:     digit_seg = 8'b11000010; \n\t\t    4'hE:     digit_seg = 8'b10110000; \n\t\t    4'hF:     digit_seg = 8'b10111000;\n            default:  digit_seg = 8'b00000000;\n    endcase\n   end\n    \n    always @(posedge clk)begin\n        case (Scanning)             0: begin digit       = disp_current[ 3: 0]; temp_seg    = { disp_num[24], disp_num[ 0], disp_num[ 4], disp_num[16],\n                                    disp_num[25], disp_num[17], disp_num[ 5], disp_num[12]};\n                    AN          = 4'b1110;\n                end\n                1: begin digit       = disp_current[ 7: 4]; temp_seg    = { disp_num[26], disp_num[ 1], disp_num[ 6], disp_num[18],\n\t\t\t\t\t\t\t\t\tdisp_num[27], disp_num[19], disp_num[ 7], disp_num[13]};\n                    AN          = 4'b1101;\n                end\n                2: begin digit       = disp_current[11: 8];   temp_seg    = { disp_num[28], disp_num[ 2], disp_num[ 8], disp_num[20],\n\t\t\t\t\t\t\t\t\tdisp_num[29], disp_num[21], disp_num[ 9], disp_num[14]};\n                    AN          = 4'b1011;\n                end\n                3: begin digit       = disp_current[15:12];  temp_seg    = { disp_num[30], disp_num[ 3], disp_num[10], disp_num[22],\n\t\t\t\t\t\t\t\t\tdisp_num[31], disp_num[23], disp_num[11], disp_num[15]};\n                    AN          = 4'b0111;\n               end\n     endcase\n    end  \n    \n\n \nendmodule\n",
        "module_name": "seven_seg",
        "module_hash": "edfdb2281c536f5de253d5f9e3779931",
        "dataset_index": 11830
      },
      "four_bit_adder_9d9bdf98": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire c1, c2, c3;\n\n    full_adder fa0 (.a(A[0]), .b(B[0]), .cin(Cin), .sum(sum[0]), .cout(c1));\n    full_adder fa1 (.a(A[1]), .b(B[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2 (.a(A[2]), .b(B[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3 (.a(A[3]), .b(B[3]), .cin(c3), .sum(sum[3]), .cout(Cout));\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "9d9bdf9807b341af6d1d35a962d26ee3",
        "dataset_index": 2850
      },
      "register_file_4b59095a": {
        "rtl_code": "module register_file(\n    input [1:0] read_register_port_0,\n    input [1:0] read_register_port_1,\n    input [1:0] write_register,\n    input [31:0] write_data,\n    input write_enable,\n    output reg [31:0] read_data_port_0,\n    output reg [31:0] read_data_port_1\n);\n\nreg [31:0] registers [0:3];\n\nalways @(*)\nbegin\n    read_data_port_0 = registers[read_register_port_0];\n    read_data_port_1 = registers[read_register_port_1];\nend\n\nalways @(posedge write_enable)\nbegin\n    if (write_enable)\n        registers[write_register] <= write_data;\nend\n\nendmodule",
        "module_name": "register_file",
        "module_hash": "4b59095a38a9b2b0ef48e8607a4658cf",
        "dataset_index": 5937
      },
      "ibex_load_store_unit_82b97506": {
        "rtl_code": "module ibex_load_store_unit (\n\tclk_i,\n\trst_ni,\n\tdata_req_o,\n\tdata_gnt_i,\n\tdata_rvalid_i,\n\tdata_err_i,\n\tdata_pmp_err_i,\n\tdata_addr_o,\n\tdata_we_o,\n\tdata_be_o,\n\tdata_wdata_o,\n\tdata_rdata_i,\n\tdata_we_ex_i,\n\tdata_type_ex_i,\n\tdata_wdata_ex_i,\n\tdata_sign_ext_ex_i,\n\tdata_rdata_ex_o,\n\tdata_req_ex_i,\n\tadder_result_ex_i,\n\taddr_incr_req_o,\n\taddr_last_o,\n\tdata_valid_o,\n\tload_err_o,\n\tstore_err_o,\n\tbusy_o,\n\tillegal_insn_id_i,\n\tinstr_valid_id_i\n);\n\tlocalparam [2:0] IDLE = 0;\n\tlocalparam [2:0] WAIT_GNT_MIS = 1;\n\tlocalparam [2:0] WAIT_RVALID_MIS = 2;\n\tlocalparam [2:0] WAIT_GNT = 3;\n\tlocalparam [2:0] WAIT_RVALID = 4;\n\tlocalparam [2:0] WAIT_RVALID_DONE = 5;\n\tinput wire clk_i;\n\tinput wire rst_ni;\n\toutput reg data_req_o;\n\tinput wire data_gnt_i;\n\tinput wire data_rvalid_i;\n\tinput wire data_err_i;\n\tinput wire data_pmp_err_i;\n\toutput wire [31:0] data_addr_o;\n\toutput wire data_we_o;\n\toutput wire [3:0] data_be_o;\n\toutput wire [31:0] data_wdata_o;\n\tinput wire [31:0] data_rdata_i;\n\tinput wire data_we_ex_i;\n\tinput wire [1:0] data_type_ex_i;\n\tinput wire [31:0] data_wdata_ex_i;\n\tinput wire data_sign_ext_ex_i;\n\toutput wire [31:0] data_rdata_ex_o;\n\tinput wire data_req_ex_i;\n\tinput wire [31:0] adder_result_ex_i;\n\toutput reg addr_incr_req_o;\n\toutput wire [31:0] addr_last_o;\n\toutput reg data_valid_o;\n\toutput wire load_err_o;\n\toutput wire store_err_o;\n\toutput wire busy_o;\n\tinput wire illegal_insn_id_i;\n\tinput wire instr_valid_id_i;\n\twire [31:0] data_addr;\n\twire [31:0] data_addr_w_aligned;\n\treg [31:0] addr_last_q;\n\treg addr_update;\n\treg ctrl_update;\n\treg rdata_update;\n\treg [31:8] rdata_q;\n\treg [1:0] rdata_offset_q;\n\treg [1:0] data_type_q;\n\treg data_sign_ext_q;\n\treg data_we_q;\n\twire [1:0] data_offset;\n\treg [3:0] data_be;\n\treg [31:0] data_wdata;\n\treg [31:0] data_rdata_ext;\n\treg [31:0] rdata_w_ext;\n\treg [31:0] rdata_h_ext;\n\treg [31:0] rdata_b_ext;\n\twire split_misaligned_access;\n\treg handle_misaligned_q;\n\treg handle_misaligned_d;\n\treg pmp_err_q;\n\treg pmp_err_d;\n\treg lsu_err_q;\n\treg lsu_err_d;\n\treg data_or_pmp_err;\n\treg [2:0] ls_fsm_cs;\n\treg [2:0] ls_fsm_ns;\n\tassign data_addr = adder_result_ex_i;\n\tassign data_offset = data_addr[1:0];\n\talways @(*)\n\t\tcase (data_type_ex_i)\n\t\t\t2'b00:\n\t\t\t\tif (!handle_misaligned_q)\n\t\t\t\t\tcase (data_offset)\n\t\t\t\t\t\t2'b00: data_be = 4'b1111;\n\t\t\t\t\t\t2'b01: data_be = 4'b1110;\n\t\t\t\t\t\t2'b10: data_be = 4'b1100;\n\t\t\t\t\t\t2'b11: data_be = 4'b1000;\n\t\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\t\tendcase\n\t\t\t\telse\n\t\t\t\t\tcase (data_offset)\n\t\t\t\t\t\t2'b00: data_be = 4'b0000;\n\t\t\t\t\t\t2'b01: data_be = 4'b0001;\n\t\t\t\t\t\t2'b10: data_be = 4'b0011;\n\t\t\t\t\t\t2'b11: data_be = 4'b0111;\n\t\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\t\tendcase\n\t\t\t2'b01:\n\t\t\t\tif (!handle_misaligned_q)\n\t\t\t\t\tcase (data_offset)\n\t\t\t\t\t\t2'b00: data_be = 4'b0011;\n\t\t\t\t\t\t2'b01: data_be = 4'b0110;\n\t\t\t\t\t\t2'b10: data_be = 4'b1100;\n\t\t\t\t\t\t2'b11: data_be = 4'b1000;\n\t\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\t\tendcase\n\t\t\t\telse\n\t\t\t\t\tdata_be = 4'b0001;\n\t\t\t2'b10, 2'b11:\n\t\t\t\tcase (data_offset)\n\t\t\t\t\t2'b00: data_be = 4'b0001;\n\t\t\t\t\t2'b01: data_be = 4'b0010;\n\t\t\t\t\t2'b10: data_be = 4'b0100;\n\t\t\t\t\t2'b11: data_be = 4'b1000;\n\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\tendcase\n\t\t\tdefault: data_be = 4'b1111;\n\t\tendcase\n\talways @(*)\n\t\tcase (data_offset)\n\t\t\t2'b00: data_wdata = data_wdata_ex_i[31:0];\n\t\t\t2'b01: data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};\n\t\t\t2'b10: data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};\n\t\t\t2'b11: data_wdata = {data_wdata_ex_i[7:0], data_wdata_ex_i[31:8]};\n\t\t\tdefault: data_wdata = data_wdata_ex_i[31:0];\n\t\tendcase\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni)\n\t\t\trdata_q <= 1'sb0;\n\t\telse if (rdata_update)\n\t\t\trdata_q <= data_rdata_i[31:8];\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni) begin\n\t\t\trdata_offset_q <= 2'h0;\n\t\t\tdata_type_q <= 2'h0;\n\t\t\tdata_sign_ext_q <= 1'b0;\n\t\t\tdata_we_q <= 1'b0;\n\t\tend\n\t\telse if (ctrl_update) begin\n\t\t\trdata_offset_q <= data_offset;\n\t\t\tdata_type_q <= data_type_ex_i;\n\t\t\tdata_sign_ext_q <= data_sign_ext_ex_i;\n\t\t\tdata_we_q <= data_we_ex_i;\n\t\tend\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni)\n\t\t\taddr_last_q <= 1'sb0;\n\t\telse if (addr_update)\n\t\t\taddr_last_q <= data_addr;\n\talways @(*)\n\t\tcase (rdata_offset_q)\n\t\t\t2'b00: rdata_w_ext = data_rdata_i[31:0];\n\t\t\t2'b01: rdata_w_ext = {data_rdata_i[7:0], rdata_q[31:8]};\n\t\t\t2'b10: rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};\n\t\t\t2'b11: rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};\n\t\t\tdefault: rdata_w_ext = data_rdata_i[31:0];\n\t\tendcase\n\talways @(*)\n\t\tcase (rdata_offset_q)\n\t\t\t2'b00:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[15:0]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[15]}}, data_rdata_i[15:0]};\n\t\t\t2'b01:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[23:8]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[23]}}, data_rdata_i[23:8]};\n\t\t\t2'b10:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[31:16]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[31]}}, data_rdata_i[31:16]};\n\t\t\t2'b11:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};\n\t\t\tdefault: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};\n\t\tendcase\n\talways @(*)\n\t\tcase (rdata_offset_q)\n\t\t\t2'b00:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[7]}}, data_rdata_i[7:0]};\n\t\t\t2'b01:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[15]}}, data_rdata_i[15:8]};\n\t\t\t2'b10:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[23]}}, data_rdata_i[23:16]};\n\t\t\t2'b11:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[31]}}, data_rdata_i[31:24]};\n\t\t\tdefault: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};\n\t\tendcase\n\talways @(*)\n\t\tcase (data_type_q)\n\t\t\t2'b00: data_rdata_ext = rdata_w_ext;\n\t\t\t2'b01: data_rdata_ext = rdata_h_ext;\n\t\t\t2'b10, 2'b11: data_rdata_ext = rdata_b_ext;\n\t\t\tdefault: data_rdata_ext = rdata_w_ext;\n\t\tendcase\n\tassign split_misaligned_access = (((data_type_ex_i == 2'b00) && (data_offset != 2'b00)) || ((data_type_ex_i == 2'b01) && (data_offset == 2'b11)));\n\talways @(*) begin\n\t\tls_fsm_ns = ls_fsm_cs;\n\t\tdata_req_o = 1'b0;\n\t\tdata_valid_o = 1'b0;\n\t\taddr_incr_req_o = 1'b0;\n\t\thandle_misaligned_d = handle_misaligned_q;\n\t\tdata_or_pmp_err = 1'b0;\n\t\tpmp_err_d = pmp_err_q;\n\t\tlsu_err_d = lsu_err_q;\n\t\taddr_update = 1'b0;\n\t\tctrl_update = 1'b0;\n\t\trdata_update = 1'b0;\n\t\tcase (ls_fsm_cs)\n\t\t\tIDLE:\n\t\t\t\tif (data_req_ex_i) begin\n\t\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\t\tpmp_err_d = data_pmp_err_i;\n\t\t\t\t\tlsu_err_d = 1'b0;\n\t\t\t\t\tif (data_gnt_i) begin\n\t\t\t\t\t\tctrl_update = 1'b1;\n\t\t\t\t\t\taddr_update = 1'b1;\n\t\t\t\t\t\thandle_misaligned_d = split_misaligned_access;\n\t\t\t\t\t\tls_fsm_ns = (split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID);\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tls_fsm_ns = (split_misaligned_access ? WAIT_GNT_MIS : WAIT_GNT);\n\t\t\t\tend\n\t\t\tWAIT_GNT_MIS: begin\n\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\tif ((data_gnt_i || pmp_err_q)) begin\n\t\t\t\t\taddr_update = 1'b1;\n\t\t\t\t\tctrl_update = 1'b1;\n\t\t\t\t\thandle_misaligned_d = 1'b1;\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID_MIS;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWAIT_RVALID_MIS: begin\n\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\taddr_incr_req_o = 1'b1;\n\t\t\t\tif ((data_rvalid_i || pmp_err_q)) begin\n\t\t\t\t\tpmp_err_d = data_pmp_err_i;\n\t\t\t\t\tlsu_err_d = (data_err_i | pmp_err_q);\n\t\t\t\t\trdata_update = ~data_we_q;\n\t\t\t\t\tls_fsm_ns = (data_gnt_i ? WAIT_RVALID : WAIT_GNT);\n\t\t\t\t\taddr_update = (data_gnt_i & ~(data_err_i | pmp_err_q));\n\t\t\t\tend\n\t\t\t\telse if (data_gnt_i)\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID_DONE;\n\t\t\tend\n\t\t\tWAIT_GNT: begin\n\t\t\t\taddr_incr_req_o = handle_misaligned_q;\n\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\tif ((data_gnt_i || pmp_err_q)) begin\n\t\t\t\t\tctrl_update = 1'b1;\n\t\t\t\t\taddr_update = ~lsu_err_q;\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWAIT_RVALID:\n\t\t\t\tif ((data_rvalid_i || pmp_err_q)) begin\n\t\t\t\t\tdata_valid_o = 1'b1;\n\t\t\t\t\tdata_or_pmp_err = ((lsu_err_q | data_err_i) | pmp_err_q);\n\t\t\t\t\thandle_misaligned_d = 1'b0;\n\t\t\t\t\tls_fsm_ns = IDLE;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID;\n\t\t\tWAIT_RVALID_DONE: begin\n\t\t\t\taddr_incr_req_o = 1'b1;\n\t\t\t\tif (data_rvalid_i) begin\n\t\t\t\t\tpmp_err_d = data_pmp_err_i;\n\t\t\t\t\tlsu_err_d = data_err_i;\n\t\t\t\t\taddr_update = ~data_err_i;\n\t\t\t\t\trdata_update = ~data_we_q;\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: ls_fsm_ns = IDLE;\n\t\tendcase\n\tend\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni) begin\n\t\t\tls_fsm_cs <= IDLE;\n\t\t\thandle_misaligned_q <= 1'sb0;\n\t\t\tpmp_err_q <= 1'sb0;\n\t\t\tlsu_err_q <= 1'sb0;\n\t\tend\n\t\telse begin\n\t\t\tls_fsm_cs <= ls_fsm_ns;\n\t\t\thandle_misaligned_q <= handle_misaligned_d;\n\t\t\tpmp_err_q <= pmp_err_d;\n\t\t\tlsu_err_q <= lsu_err_d;\n\t\tend\n\tassign data_rdata_ex_o = data_rdata_ext;\n\tassign data_addr_w_aligned = {data_addr[31:2], 2'b00};\n\tassign data_addr_o = data_addr_w_aligned;\n\tassign data_wdata_o = data_wdata;\n\tassign data_we_o = data_we_ex_i;\n\tassign data_be_o = data_be;\n\tassign addr_last_o = addr_last_q;\n\tassign load_err_o = (data_or_pmp_err & ~data_we_q);\n\tassign store_err_o = (data_or_pmp_err & data_we_q);\n\tassign busy_o = (ls_fsm_cs != IDLE);\n\twire unused_instr_valid_id;\n\twire unused_illegal_insn_id;\n\tassign unused_instr_valid_id = instr_valid_id_i;\n\tassign unused_illegal_insn_id = illegal_insn_id_i;\nendmodule\n",
        "module_name": "ibex_load_store_unit",
        "module_hash": "82b975060420e4ae8dc27069daf373c8",
        "dataset_index": 12615
      },
      "top_module_2f0be4b7": {
        "rtl_code": "module top_module(\n    input [3:0] a1,\n    input [3:0] a2,\n    input [3:0] b1,\n    input [3:0] b2,\n    input sel1,\n    input sel2,\n    input select,\n    output [3:0] out\n);\n\n    // First 2-to-1 multiplexer\n    wire [3:0] mux1_out;\n    mux2to1 mux1(\n        .a(a1),\n        .b(b1),\n        .sel(sel1),\n        .out(mux1_out)\n    );\n    \n    // Second 2-to-1 multiplexer\n    wire [3:0] mux2_out;\n    mux2to1 mux2(\n        .a(a2),\n        .b(b2),\n        .sel(sel2),\n        .out(mux2_out)\n    );\n    \n    // Control logic to select active multiplexer\n    wire [3:0] active_mux_out;\n    assign active_mux_out = select ? mux2_out : mux1_out;\n    \n    // Functional module to sum the outputs of the two multiplexers\n    wire [7:0] sum;\n    adder add(\n        .a(active_mux_out),\n        .b(mux2_out),\n        .sum(sum)\n    );\n    \n    // Output the sum of the active multiplexer's values\n    assign out = sum[3:0];\n    \nendmodule\n\nmodule mux2to1(\n    input [3:0] a,\n    input [3:0] b,\n    input sel,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        if(sel) begin\n            out = b;\n        end else begin\n            out = a;\n        end\n    end\n    \nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [7:0] sum\n);\n\n    always @(*) begin\n        sum = {4'b0, a} + {4'b0, b};\n    end\n    \nendmodule",
        "module_name": "top_module",
        "module_hash": "2f0be4b74a304c2ccbfaf39592a23131",
        "dataset_index": 10093
      },
      "soc_system_pio_aliveTest_cpu_s0_8efb5854": {
        "rtl_code": "module soc_system_pio_aliveTest_cpu_s0 (\n  // inputs:\n  address,\n  chipselect,\n  clk,\n  reset_n,\n  write_n,\n  writedata,\n\n  // outputs:\n  out_port,\n  readdata\n);\n\n  output  [  1: 0] out_port;\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            chipselect;\n  input            clk;\n  input            reset_n;\n  input            write_n;\n  input   [ 31: 0] writedata;\n\n  wire             clk_en;\n  reg     [  1: 0] data_out;\n  wire    [  1: 0] out_port;\n  wire    [  1: 0] read_mux_out;\n  wire    [ 31: 0] readdata;\n  assign clk_en = 1;\n\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {2 {(address == 0)}} & data_out;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      data_out <= 0;\n    end else if (chipselect && ~write_n && (address == 0)) begin\n      data_out <= writedata[1 : 0];\n    end\n  end\n\n  assign readdata = {30'b0, read_mux_out};\n\n  assign out_port = data_out;\n\nendmodule",
        "module_name": "soc_system_pio_aliveTest_cpu_s0",
        "module_hash": "8efb5854b6134a4e118cc3077b694e9b",
        "dataset_index": 15933
      },
      "multiplier_block_910a835e": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w2048,\n    w2049,\n    w8196,\n    w6147,\n    w64,\n    w6211,\n    w24844;\n\n  assign w1 = i_data0;\n  assign w2048 = w1 << 11;\n  assign w2049 = w1 + w2048;\n  assign w64 = w1 << 6;\n  assign w8196 = w2049 << 2;\n  assign w6147 = w8196 - w2049;\n  assign w6211 = w6147 + w64;\n  assign w24844 = w6211 << 2;\n\n  assign o_data0 = w24844;\n\n  //multiplier_block area estimate = 4886.48160088529;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "910a835eb1dc874f0f3e5f55accf9f31",
        "dataset_index": 8833
      },
      "my_module_d353e620": {
        "rtl_code": "module my_module(\n    input dataa,\n    input clk,\n    input aclr,\n    input ena,\n    input devclrn,\n    input devpor,\n    output reg dataout\n);\n\nparameter output_clock = \"none\";\n\nreg [1:0] state;\n\ninitial begin\n    state = 2'b00;\nend\n\nalways @(posedge clk or negedge aclr) begin\n    if (!aclr) begin\n        state <= 2'b00;\n        dataout <= 1'b0;\n    end\n    else begin\n        case (state)\n            2'b00: begin\n                if (ena) begin\n                    dataout <= dataa;\n                    state <= 2'b01;\n                end\n                else begin\n                    dataout <= 1'b0;\n                end\n            end\n            2'b01: begin\n                if (output_clock != \"none\") begin\n                    state <= 2'b10;\n                end\n                else begin\n                    state <= 2'b00;\n                end\n            end\n            2'b10: begin\n                dataout <= dataa;\n                state <= 2'b11;\n            end\n            2'b11: begin\n                dataout <= 1'b0;\n                state <= 2'b00;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "my_module",
        "module_hash": "d353e620d8762f70267a1cb1d85e7c0b",
        "dataset_index": 18999
      },
      "vending_machine_controller_901dea74": {
        "rtl_code": "module vending_machine_controller(\n    input clk,\n    input rst,\n    input button_A,\n    input button_B,\n    input button_C,\n    input coin,\n    output reg dispense_X,\n    output reg dispense_Y,\n    output reg dispense_Z,\n    output reg [23:0] display,\n    output reg button_A_enable,\n    output reg button_B_enable,\n    output reg button_C_enable\n);\n\n    // Define constants\n    parameter PRICE = 150; // Price of each product in cents\n    parameter MAX_STOCK = 5; // Maximum stock of each product\n    \n    // Define state variables\n    reg [1:0] state;\n    reg [2:0] inventory;\n    reg [23:0] total_money;\n    \n    // Define state machine states\n    parameter [1:0] IDLE = 2'b00;\n    parameter [1:0] DISPENSING = 2'b01;\n    parameter [1:0] COIN_INSERTED = 2'b10;\n    \n    // Define state machine transitions and actions\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            inventory <= {MAX_STOCK, MAX_STOCK, MAX_STOCK};\n            total_money <= 0;\n            dispense_X <= 0;\n            dispense_Y <= 0;\n            dispense_Z <= 0;\n            button_A_enable <= 1;\n            button_B_enable <= 1;\n            button_C_enable <= 1;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (button_A && inventory[0] > 0) begin\n                        state <= DISPENSING;\n                        dispense_X <= 1;\n                        inventory[0] <= inventory[0] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_B && inventory[1] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Y <= 1;\n                        inventory[1] <= inventory[1] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_C && inventory[2] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Z <= 1;\n                        inventory[2] <= inventory[2] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (coin) begin\n                        state <= COIN_INSERTED;\n                        total_money <= total_money + 100; // Add coin value to total money\n                    end\n                end\n                DISPENSING: begin\n                    if (!button_A && !button_B && !button_C) begin\n                        state <= IDLE;\n                        dispense_X <= 0;\n                        dispense_Y <= 0;\n                        dispense_Z <= 0;\n                    end\n                end\n                COIN_INSERTED: begin\n                    if (button_A && inventory[0] > 0) begin\n                        state <= DISPENSING;\n                        dispense_X <= 1;\n                        inventory[0] <= inventory[0] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_B && inventory[1] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Y <= 1;\n                        inventory[1] <= inventory[1] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_C && inventory[2] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Z <= 1;\n                        inventory[2] <= inventory[2] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (!coin) begin\n                        state <= IDLE;\n                    end\n                end\n            endcase\n            \n            // Update button enable signals based on inventory levels\n            button_A_enable <= (inventory[0] > 0);\n            button_B_enable <= (inventory[1] > 0);\n            button_C_enable <= (inventory[2] > 0);\n            \n            // Update display output\n            display <= {7'b1111110, 7'b1111110, 7'b1111110}; // Default to showing \"888\"\n            if (state == COIN_INSERTED) begin\n                display <= {7'b0000110, 7'b0000000, 7'b0000000} + (total_money / 10); // Show total money in dollars\n            end else begin\n                display[0] <= 7'b1110000 - (inventory[0] * 7); // Show inventory level for product X\n                display[1] <= 7'b1110000 - (inventory[1] * 7); // Show inventory level for product Y\n                display[2] <= 7'b1110000 - (inventory[2] * 7); // Show inventory level for product Z\n            end\n        end\n    end\n    \nendmodule",
        "module_name": "vending_machine_controller",
        "module_hash": "901dea74da0482c4264de480174eec17",
        "dataset_index": 6571
      },
      "Altera_UP_PS2_Data_In_62d7eaba": {
        "rtl_code": "\n\n\nmodule Altera_UP_PS2_Data_In (\n    clk,\n    reset,\n\n    wait_for_incoming_data,\n    start_receiving_data,\n\n    ps2_clk_posedge,\n    ps2_clk_negedge,\n    ps2_data,\n\n    received_data,\n    received_data_en            );\n\n\n\n\n\n\ninput               clk;\ninput               reset;\n\ninput               wait_for_incoming_data;\ninput               start_receiving_data;\n\ninput               ps2_clk_posedge;\ninput               ps2_clk_negedge;\ninput               ps2_data;\n\noutput reg  [7:0]   received_data;\n\noutput reg          received_data_en;\n\n\nlocalparam  PS2_STATE_0_IDLE            = 3'h0,\n            PS2_STATE_1_WAIT_FOR_DATA   = 3'h1,\n            PS2_STATE_2_DATA_IN         = 3'h2,\n            PS2_STATE_3_PARITY_IN       = 3'h3,\n            PS2_STATE_4_STOP_IN         = 3'h4;\n\n\nreg         [3:0]   data_count;\nreg         [7:0]   data_shift_reg;\n\nreg         [2:0]   ns_ps2_receiver;\nreg         [2:0]   s_ps2_receiver;\n\n\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        s_ps2_receiver <= PS2_STATE_0_IDLE;\n    else\n        s_ps2_receiver <= ns_ps2_receiver;\nend\n\nalways @(*)\nbegin\n    ns_ps2_receiver = PS2_STATE_0_IDLE;\n\n    case (s_ps2_receiver)\n    PS2_STATE_0_IDLE:\n        begin\n            if ((wait_for_incoming_data == 1'b1) && \n                    (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n            else if ((start_receiving_data == 1'b1) && \n                    (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    PS2_STATE_1_WAIT_FOR_DATA:\n        begin\n            if ((ps2_data == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else if (wait_for_incoming_data == 1'b0)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n        end\n    PS2_STATE_2_DATA_IN:\n        begin\n            if ((data_count == 3'h7) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n        end\n    PS2_STATE_3_PARITY_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n        end\n    PS2_STATE_4_STOP_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n        end\n    default:\n        begin\n            ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    endcase\nend\n\n\n\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1) \n        data_count  <= 3'h0;\n    else if ((s_ps2_receiver == PS2_STATE_2_DATA_IN) && \n            (ps2_clk_posedge == 1'b1))\n        data_count  <= data_count + 3'h1;\n    else if (s_ps2_receiver != PS2_STATE_2_DATA_IN)\n        data_count  <= 3'h0;\nend\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        data_shift_reg          <= 8'h00;\n    else if ((s_ps2_receiver == PS2_STATE_2_DATA_IN) && \n            (ps2_clk_posedge == 1'b1))\n        data_shift_reg  <= {ps2_data, data_shift_reg[7:1]};\nend\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        received_data       <= 8'h00;\n    else if (s_ps2_receiver == PS2_STATE_4_STOP_IN)\n        received_data   <= data_shift_reg;\nend\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        received_data_en        <= 1'b0;\n    else if ((s_ps2_receiver == PS2_STATE_4_STOP_IN) &&\n            (ps2_clk_posedge == 1'b1))\n        received_data_en    <= 1'b1;\n    else\n        received_data_en    <= 1'b0;\nend\n\n\n\n\n\n\n\nendmodule\n\n",
        "module_name": "Altera_UP_PS2_Data_In",
        "module_hash": "62d7eaba9d7f27554b6cbb0a291fad2d",
        "dataset_index": 17641
      },
      "PWM #_c26c6d53": {
        "rtl_code": "module PWM #(\n  parameter p = 8 // number of bits used to represent the modulation signal\n)(\n  input clk,\n  input rst,\n  input [p-1:0] mod,\n  output pwm\n);\n\n\nreg [p-1:0] counter;\nreg pwm_reg;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    counter <= 0;\n    pwm_reg <= 0;\n  end else begin\n    counter <= counter + 1;\n    if (counter >= 2**p) begin\n      counter <= 0;\n    end\n    if (counter < mod) begin\n      pwm_reg <= 1;\n    end else begin\n      pwm_reg <= 0;\n    end\n  end\nend\n\nassign pwm = pwm_reg;\n\nendmodule",
        "module_name": "PWM #",
        "module_hash": "c26c6d53182ba3a7d8966bcc3de473fe",
        "dataset_index": 17810
      },
      "gpio_wb #_93b87e14": {
        "rtl_code": "module gpio_wb #(parameter BASE_ADDR = 32'h00000400) (\n    \n    // system signals\n    input clk_i, \n    input rst_i,\n    \n    // wb signals\n    input      [31:0] dat_i, \n    output reg [31:0] dat_o, \n    input      [31:0] adr_i, \n    input      we_i, \n    input      [3:0] sel_i, \n    input      cyc_i, \n    input      stb_i, \n    output reg ack_o,\n    \n    // func signals\n    input [15:0] sw_bi,\n    output reg [15:0] gpio_bo\n);\n\nlocalparam IDLE = 0;\nlocalparam ACK  = 1;\n\nwire read  = cyc_i & stb_i & !we_i;\nwire write = cyc_i & stb_i & we_i;\n    \nreg state_r;\n    \nalways@(posedge clk_i, posedge rst_i)\n    if(rst_i) begin\n        state_r  <= 0;\n        ack_o    <= 1'b0;\n        gpio_bo  <= 0;\n        dat_o    <= 0;\n    end else begin\n    \n        ack_o <= 1'b0;\n        \n        case(state_r)\n            IDLE: \n                begin\n                    if(write) begin\n                        if(adr_i == BASE_ADDR)\n                            gpio_bo <= dat_i[15:0];\n                        ack_o   <= 1'b1;\n                        state_r <= ACK; \n                    end else if(read) begin\n                        dat_o <= (adr_i == BASE_ADDR)? sw_bi: 0;\n                        state_r <= ACK;\n                    end\n                end\n            ACK:\n                begin\n                    ack_o   <= 1'b1;\n                    state_r <= IDLE;\n                end\n        endcase\n    end\n\n\nendmodule",
        "module_name": "gpio_wb #",
        "module_hash": "93b87e148ad8c2b7ce49810ac573d37b",
        "dataset_index": 5885
      },
      "stack_f228f844": {
        "rtl_code": "\nmodule stack(\n    input reset,\n    input clock,\n    input nip,\n    input dup,\n    input we,\n    input [7:0] data_in,\n    output [7:0] tos_out,\n    output [7:0] nos_out\n);\n\n    parameter DEPTH = 16;\n    parameter PTR = $clog2(DEPTH);\n\n    reg [7:0] cells [DEPTH-1:0];\n    reg [PTR-1:0] sp;\n    reg [PTR-1:0] nsp;\n    reg [7:0] tos;\n    reg [7:0] nos;\n\n    always @(*) begin\n        nsp = sp - 1;\n    end\n\n    assign tos_out = cells[sp];\n    assign nos_out = cells[nsp];\n\n    always @(posedge clock) begin\n        if (reset) begin\n            sp <= 4'b0000;\n            cells[sp] <= 8'b0;\n            tos <= 8'b0;\n            nos <= 8'b0;\n        end\n\n        tos <= cells[sp];\n        nos <= cells[nsp];\n\n        if (nip && !dup) begin\n            sp <= sp - 1;\n        end\n\n        if (dup && !nip) begin\n            sp <= sp + 1;\n        end\n\n        if (dup && nip) begin\n            cells[nsp] <= tos;\n            tos <= nos;\n        end\n\n        if (we) begin\n            tos <= data_in;\n        end\n\n        cells[sp] <= tos;\n    end\n\nendmodule",
        "module_name": "stack",
        "module_hash": "f228f844941826676c9a6a4e63c02291",
        "dataset_index": 3287
      },
      "adder32_31debaac": {
        "rtl_code": "module adder32 (cout,\n\ts0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,\n\ta0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,\n\tb0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15);\n   \n   input a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15;\n   input b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15;\n   output s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15;\n   output cout;         wire c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15;\n\nassign s0 = a0 ^ b0 ^ 1'b0;\nassign c1 = (a0&b0);\nassign c2 = (a1&b1)|(a1&c1)|(b1&c1);\nassign s1 = a1 ^ b1 ^ c1;\nassign c3 = (a2&b2)|(a2&c2)|(b2&c2);\n\nassign s2 = a2 ^ b2 ^ c2;\nassign c4 = (a3&b3)|(a3&c3)|(b3&c3);\n\nassign s3 = a3 ^ b3 ^ c3;\nassign c5 = (a4&b4)|(a4&c4)|(b4&c4);\n\nassign s4 = a4 ^ b4 ^ c4;\nassign c6 = (a5&b5)|(a5&c5)|(b5&c5);\n\nassign s5 = a5 ^ b5 ^ c5;\nassign c7 = (a6&b6)|(a6&c6)|(b6&c6);\n\nassign s6 = a6 ^ b6 ^ c6;\nassign c8 = (a7&b7)|(a7&c7)|(b7&c7);\n\nassign s7 = a7 ^ b7 ^ c7;\nassign c9 = (a8&b8)|(a8&c8)|(b8&c8);\n\nassign s8 = a8 ^ b8 ^ c8;\nassign c10 = (a9&b9)|(a9&c9)|(b9&c9);\n\nassign s9 = a9 ^ b9 ^ c9;\nassign c11 = (a10&b10)|(a10&c10)|(b10&c10);\n\nassign s10 = a10 ^ b10 ^ c10;\nassign c12 = (a11&b11)|(a11&c11)|(b11&c11);\n\nassign s11 = a11 ^ b11 ^ c11;\nassign c13 = (a12&b12)|(a12&c12)|(b12&c12);\n\nassign s12 = a12 ^ b12 ^ c12;\nassign c14 = (a13&b13)|(a13&c13)|(b13&c13);\n\nassign s13 = a13 ^ b13 ^ c13;\nassign c15 = (a14&b14)|(a14&c14)|(b14&c14);\n\nassign s14 = a14 ^ b14 ^ c14;\nassign cout = (a15&b15)|(a15&c15)|(b15&c15);\n\nassign s15 = a15 ^ b15 ^ c15;\n\nendmodule\n",
        "module_name": "adder32",
        "module_hash": "31debaac98d0dff3a48d8a4f7fedda5b",
        "dataset_index": 22742
      },
      "slow_clk_2a116244": {
        "rtl_code": "\nmodule slow_clk(input clk, output slow_clk);\n    parameter TICKS = 27'd49_999_999;\n\n    reg [31:0] count = 0;\n    reg sig_reg = 0;\n\n    always @(posedge clk) begin\n        if (count == TICKS) begin\n            sig_reg <= ~sig_reg;\n            count <= 0;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\n    assign slow_clk = sig_reg;\nendmodule\n",
        "module_name": "slow_clk",
        "module_hash": "2a1162442e5c07c04ddbf0fbbeb2acf6",
        "dataset_index": 22365
      },
      "FSM #_fb24a176": {
        "rtl_code": "module FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  input clk,\n  output reg [m-1:0] out\n);\n\nparameter s_new = 1; // new state encoding\n\n// Define the states using the original state encoding\nparameter STATE_A = 2'b00;\nparameter STATE_B = 2'b01;\nparameter STATE_C = 2'b10;\nparameter STATE_D = 2'b11;\n\nreg [1:0] current_state, next_state;\nalways @* begin\n  next_state = (current_state == STATE_A && in[0]) ? STATE_B :\n               (current_state == STATE_A && !in[0]) ? STATE_C :\n               (current_state == STATE_B && in[1]) ? STATE_D :\n               (current_state == STATE_B && !in[1]) ? STATE_A :\n               (current_state == STATE_C && in[2]) ? STATE_A :\n               (current_state == STATE_C && !in[2]) ? STATE_D :\n               (current_state == STATE_D && in[3]) ? STATE_C :\n               (current_state == STATE_D && !in[3]) ? STATE_B :\n               current_state;\nend\n\n// Define the outputs based on the current state and the new state encoding\nalways @* begin\n  case (current_state)\n    STATE_A: out = {s_new == 1 ? 1'b1 : 2'b01, s_new == 1 ? 1'b0 : 2'b10};\n    STATE_B: out = {s_new == 1 ? 1'b0 : 2'b10, s_new == 1 ? 1'b1 : 2'b01};\n    STATE_C: out = {s_new == 1 ? 1'b1 : 2'b10, s_new == 1 ? 1'b1 : 2'b10};\n    STATE_D: out = {s_new == 1 ? 1'b0 : 2'b10, s_new == 1 ? 1'b0 : 2'b10};\n  endcase\nend\n\n// Define the state register and the next state logic\nalways @ (posedge clk) begin\n  current_state <= next_state;\nend\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "fb24a176dcb75a2b5073a818e71d6812",
        "dataset_index": 8121
      },
      "ResetEither_d00b7265": {
        "rtl_code": "\n`ifdef BSV_ASSIGNMENT_DELAY\n`else\n`define BSV_ASSIGNMENT_DELAY\n`endif\n\nmodule ResetEither(A_RST,\n                   B_RST,\n                   RST_OUT\n                  ) ;\n\n   input            A_RST;\n   input            B_RST;\n\n   output           RST_OUT;\n\n   assign RST_OUT = A_RST & B_RST ;\n\nendmodule                \n",
        "module_name": "ResetEither",
        "module_hash": "d00b7265fd16cb5af37aa8a195c51b5d",
        "dataset_index": 13421
      },
      "and_gate_b1_0dd99b4d": {
        "rtl_code": "module and_gate_b1 (\n    Y,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input A4;\n    input B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign Y = (A1 & A2 & A3 & A4 & ~B1);\n\nendmodule",
        "module_name": "and_gate_b1",
        "module_hash": "0dd99b4d7d9de5a33fd81a7f9cdb54b5",
        "dataset_index": 7679
      },
      "sky130_fd_sc_hd__nor4_0de53e50": {
        "rtl_code": "\nmodule sky130_fd_sc_hd__nor4 (\n    output Y,\n    input A,\n    input B,\n    input C,\n    input D,\n    inout VPWR,\n    inout VGND,\n    inout VPB,\n    inout VNB\n);\n    assign Y = ~((A ~^ B) ~| (C ~^ D));\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nor4",
        "module_hash": "0de53e5000cc37f35ca5eee8c7951c78",
        "dataset_index": 14166
      },
      "comparator_8a5d7a08": {
        "rtl_code": "module comparator(\n  input [3:0] A,\n  input [3:0] B,\n  output reg [3:0] Y\n);\n\n  always @(*) begin\n    if (A >= B) begin\n      Y = A - B;\n    end\n    else begin\n      Y = B - A;\n    end\n    if (A == B) begin\n      Y = 0;\n    end\n  end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "8a5d7a08305aab6fc168b74082a3473c",
        "dataset_index": 10541
      },
      "regfile_fda37169": {
        "rtl_code": "`define N 32 \n`define K 32\nmodule regfile (\n    input clk,\n    input ld,\n    input [`K-1:0] d,\n    input [`N-1:0] sa,\n    input [`N-1:0] sb,\n    output reg [`N-1:0] a,\n    output reg [`N-1:0] b,\n    output reg [`K-1:0] x\n);\n\nreg [`K-1:0] regfile [`N-1:0];\n\nalways @(posedge clk) begin\n    if (ld) begin\n        regfile[d] <= d;\n        x <= regfile[sa];\n    end\n    a <= regfile[sa];\n    b <= regfile[sb];\nend\n\nendmodule",
        "module_name": "regfile",
        "module_hash": "fda3716905c996f10846544b12eab219",
        "dataset_index": 6781
      },
      "accumulator_63f90cc9": {
        "rtl_code": "\nmodule accumulator (\n  input clk,\n  input rst,\n  input [n-1:0] in,\n  output [n-1:0] out\n);\n\nparameter n = 8; // number of bits in the input and output signals\n\nreg [n-1:0] sum; // register to store the accumulated sum\n\nalways @(posedge clk) begin\n  if (rst) begin\n    sum <= 0; // reset the accumulated sum to zero\n  end else begin\n    sum <= sum + in; // add the input signal to the accumulated sum\n  end\nend\n\nassign out = rst ? 0 : sum; // select between the accumulated sum and zero based on the reset signal\n\nendmodule\n",
        "module_name": "accumulator",
        "module_hash": "63f90cc901141cb548b06b7607972294",
        "dataset_index": 16371
      },
      "frame_detector_355bf09b": {
        "rtl_code": "\n\n\nmodule frame_detector\n(\n\tinput clk400,\n\tinput clk80,\n\tinput reset,\n\tinput enable,\n\t\n\tinput sdata,\n\toutput reg [4:0]pdata,\n\toutput reg error\n);\n\treg [5:0]s;  reg detect;  reg [2:0]c;  wire sync = c[2]; reg [4:0]p;  reg e;       always @(posedge clk400 or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\ts <= 0;\n\t\t\tdetect <= 0;\n\t\t\tc <= 0;\n\t\t\tp <= 0;\n\t\t\te <= 0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\ts <= {s[4:0],sdata};\n\t\t\tdetect <= (s[5:0] == 6'b100000) || (s[5:0] == 6'b011111);\n\t\t\tif (sync || detect) c <= 3'd0; else c <= c + 3'd1;\n\t\t\tif (sync) p <= s[5:1];\n\t\t\tif (sync) e <= 0; else if (detect) e <= 1;\n\t\tend\n\tend\n\n\talways @(posedge clk80 or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tpdata <= 5'd0;\n\t\t\terror <= 0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\tpdata <= p;\n\t\t\terror <= e;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tpdata <= 5'd0;\n\t\t\terror <= 0;\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "frame_detector",
        "module_hash": "355bf09b0e2c1a67f387464c9f25364e",
        "dataset_index": 5487
      },
      "block_ram #_5876ec52": {
        "rtl_code": "\nmodule block_ram #(parameter DATA_WIDTH=4, ADDRESS_WIDTH=10)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n   reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule `default_nettype none\nmodule distributed_ram #(parameter DATA_WIDTH=8, ADDRESS_WIDTH=4)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n   reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule `default_nettype none\nmodule distributed_ram_manual #(parameter DATA_WIDTH=8, ADDRESS_WIDTH=4)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n    reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule `default_nettype none\nmodule distributed_ram_manual_syn #(parameter DATA_WIDTH=8, ADDRESS_WIDTH=4)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n    reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule ",
        "module_name": "block_ram #",
        "module_hash": "5876ec52e0949c3696a6dc59141fa13b",
        "dataset_index": 25442
      },
      "reset_sync_379fc1f6": {
        "rtl_code": "module reset_sync (\n  input rst,\n  input clk,\n  output reg rst_sync\n);\n\n  reg [1:0] rst_sync_reg;\n\n  always @(posedge clk) begin\n    rst_sync_reg <= {rst_sync_reg[0], rst};\n  end\n\n  always @(*) begin\n    rst_sync = ~rst_sync_reg[1];\n  end\n\nendmodule",
        "module_name": "reset_sync",
        "module_hash": "379fc1f6d1acc93678b79926fea7e243",
        "dataset_index": 9173
      },
      "inicial_d1927743": {
        "rtl_code": "module inicial ( giro, entrada, saida, metais, ledVerde, ledVermelho, display, clock );\n\tinput giro, entrada, saida, metais, clock;\n\toutput [1:0] ledVerde, ledVermelho;\n\toutput [6:0] display;\n\n\treg [2:0] estado;\n\treg [3:0] tmp;\n\treg [1:0] tmpLedVerde, tmpLedVermelho;\n\treg [6:0] tmpDisplay;\n\n\tparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\n\tinitial estado = A;\n\n\talways @( posedge clock ) begin\n\t\t\ttmp = { giro, entrada, saida, metais }; \n\n          \tcase( estado )\n          \t\t\tA: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b00;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b00;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b1111001;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1101 | tmp == 4'b1111 )\n\t\t\t\t\t\t\t\t\testado = C;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1110 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 )\n\t\t\t\t\t\t\t\t\testado = E;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tB: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b01;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b00;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0100100;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1101 )\n\t\t\t\t\t\t\t\t\testado = C;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1110 | tmp == 4'b1111 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 | tmp == 4'b1011 )\n\t\t\t\t\t\t\t\t\testado = E;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tC: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b00;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b01;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0110000;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0100 | tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0110 | tmp == 4'b1110 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 )\n\t\t\t\t\t\t\t\t\testado = E;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tD: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b10;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b10;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0011001;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0111 | tmp == 4'b1111 )\n\t\t\t\t\t\t\t\t\testado = C;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 )\n\t\t\t\t\t\t\t\t\testado = E;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\n\t\t\t\t\t\t\tend\n\n\t\t\t\t\t\tE: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b00;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b00;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0010010;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0110 | tmp == 4'b1110 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1101 )\n\t\t\t\t\t\t\t\t\testado = C;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tdefault: estado = A;\n\n          \tendcase\n\tend\n\n\tassign ledVerde = tmpLedVerde;\n\tassign ledVermelho = tmpLedVermelho;\n\tassign display = tmpDisplay;\n\nendmodule\n\nmodule projetoPessoal ( SW,LEDG, LEDR, HEX0, CLK );\n\tinput [3:0] SW;\n\tinput CLK;\n\toutput [1:0] LEDG, LEDR;\n\toutput [6:0] HEX0;\n\n\tinicial a( SW[3], SW[2], SW[1], SW[0], LEDG, LEDR, HEX0, CLK );\nendmodule\n",
        "module_name": "inicial",
        "module_hash": "d192774332995655b351aae8495513f2",
        "dataset_index": 24011
      },
      "nand_gate_27a7a204": {
        "rtl_code": "\nmodule nand_gate(\n    input a,\n    input b,\n    output reg y\n);\n\nalways @ (a, b) begin\n    y = ~(a & b);\nend\n\nendmodule\nmodule decoder_2to4(\n    input [1:0] in,\n    output [3:0] out\n);\n\nwire n1, n2;\n\nnand_gate nand1(\n    .a(in[0]), \n    .b(in[1]), \n    .y(n1)\n);\n\nnand_gate nand2(\n    .a(in[0]), \n    .b(~in[1]), \n    .y(n2)\n);\n\nassign out = {~n1 & ~n2, ~n1 & n2, n1 & ~n2, n1 & n2};\n\nendmodule",
        "module_name": "nand_gate",
        "module_hash": "27a7a204e410ddacc1d5208a913c1506",
        "dataset_index": 9972
      },
      "XC2COrArray_0c3a26a5": {
        "rtl_code": "\n\nmodule XC2COrArray(pterms_in, config_bits, or_out);\n\n\tinput wire[55:0]\t\t\tpterms_in;\n\tinput wire[16*56 - 1 : 0]\tconfig_bits;\n\toutput reg[15:0]\t\t\tor_out;\n\n\tinteger nout;\n\tinteger nterm;\n\n\treg[55:0] or_config[15:0];\n\talways @(*) begin\n\t\tfor(nterm=0; nterm<56; nterm=nterm+1) begin\n\t\t\tfor(nout=0; nout<16; nout=nout + 1)\n\t\t\t\tor_config[nout][nterm]\t\t<= config_bits[nout*56 + nterm];\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tfor(nout=0; nout<16; nout = nout+1) begin\n\t\t\tor_out[nout] = 0;\t\tfor(nterm=0; nterm<56; nterm=nterm+1) begin\n\t\t\t\tif(!or_config[nout][nterm])\n\t\t\t\t\tor_out[nout] = or_out[nout] | pterms_in[nterm];\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "XC2COrArray",
        "module_hash": "0c3a26a5d669ab5bd957a3c63b54375c",
        "dataset_index": 23605
      },
      "ring_delay_556eaadb": {
        "rtl_code": "\nmodule ring_delay (\n    input clk,\n    input d,\n    input [3:0] delay,\n    output reg q\n);\n\nreg [2:0] shift_reg;\nreg [3:0] delay_counter;\n\nalways @(posedge clk) begin\n    // Shift the register\n    shift_reg <= {shift_reg[1:0], d};\n\n    // Update the delay counter\n    if (delay_counter == delay) begin\n        // Output the delayed value\n        q <= shift_reg[2];\n        delay_counter <= 0;\n    end else begin\n        delay_counter <= delay_counter + 1;\n    end\nend\n\nendmodule\n",
        "module_name": "ring_delay",
        "module_hash": "556eaadbec4d09fcd62a767970c2d868",
        "dataset_index": 16987
      },
      "mem_wb_reg_8360db9f": {
        "rtl_code": "module mem_wb_reg\n#(\n   parameter DATA_WIDTH = 32,\n   parameter INSTRUCTION_WIDTH = 32,\n   parameter REG_ADDR_WIDTH = 5\n  )\n(\n   input clk,\n   input rst_n,\n   input en,\n   input write_back_mux_sel_in,\n   input [DATA_WIDTH-1:0] alu_data_in,\n   input [DATA_WIDTH-1:0] hi_data_in,\ninput [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_in,\n   input [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_in,\n   input reg_a_wr_en_in,\n   input reg_b_wr_en_in,\n   input [INSTRUCTION_WIDTH-1:0] instruction_in,\n\n   output reg write_back_mux_sel_out,\n   output reg [DATA_WIDTH-1:0] alu_data_out,\n   output reg [DATA_WIDTH-1:0] hi_data_out,\noutput reg [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_out,\n   output reg [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_out,\n   output reg reg_a_wr_en_out,\n   output reg reg_b_wr_en_out,\n   output reg [INSTRUCTION_WIDTH-1:0] instruction_out\n);\n\n\n\nalways@(posedge clk or negedge rst_n) begin\n   if(~rst_n) begin\n      write_back_mux_sel_out <= 0;\n      alu_data_out <= 0;\n      hi_data_out <= 0;\nreg_a_wr_addr_out <= 0;\n      reg_b_wr_addr_out <= 0;\n      reg_a_wr_en_out <= 0;\n      reg_b_wr_en_out <= 0;\n      instruction_out <= 0;\n   end\n   else if(en) begin\n      write_back_mux_sel_out <= write_back_mux_sel_in;\n      alu_data_out <= alu_data_in;\n      hi_data_out <= hi_data_in;\nreg_a_wr_addr_out <= reg_a_wr_addr_in;\n      reg_b_wr_addr_out <= reg_b_wr_addr_in;\n      reg_a_wr_en_out <= reg_a_wr_en_in;\n      reg_b_wr_en_out <= reg_b_wr_en_in;\n      instruction_out <= instruction_in;\n   end\nend\n\nendmodule\n",
        "module_name": "mem_wb_reg",
        "module_hash": "8360db9fd607d701419ba153a057fa77",
        "dataset_index": 23442
      },
      "four_bit_adder_85443240": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input CI,\n    output [3:0] SUM,\n    output CO\n);\n\n    wire C1, C2, C3;\n\n    // Instantiate 4-bit full adder cells\n    full_adder FA0(A[0], B[0], CI, SUM[0], C1);\n    full_adder FA1(A[1], B[1], C1, SUM[1], C2);\n    full_adder FA2(A[2], B[2], C2, SUM[2], C3);\n    full_adder FA3(A[3], B[3], C3, SUM[3], CO);\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input CI,\n    output SUM,\n    output CO\n);\n\n    // Assign Sum and Carry Out using XOR and AND gates\n    assign SUM = A ^ B ^ CI;\n    assign CO = (A & B) | (B & CI) | (A & CI);\n\nendmodule\n",
        "module_name": "four_bit_adder",
        "module_hash": "85443240b73447d032544282783cf0ad",
        "dataset_index": 17736
      },
      "gray_to_binary_d52bd042": {
        "rtl_code": "module gray_to_binary (\n    input [3:0] G,\n    output reg [3:0] B\n);\n\nalways @* begin\n    B[3] = G[3];\n    B[2] = G[3] ^ G[2];\n    B[1] = G[2] ^ G[1];\n    B[0] = G[1] ^ G[0];\nend\n\nendmodule",
        "module_name": "gray_to_binary",
        "module_hash": "d52bd042d3f26dfa874e495a6240c09f",
        "dataset_index": 14656
      },
      "parallel_load_shift_98bc7a21": {
        "rtl_code": "\nmodule parallel_load_shift (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [2:0] shift_amount,\n  output reg [7:0] shift_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      shift_out <= 8'b0;\n    end else begin\n      shift_out <= {shift_out[7-shift_amount:0], data_in};\n    end\n  end\n\nendmodule\nmodule combinational_circuit (\n  input [49:0] in,\n  output wire out_nand,\n  output wire out_nor,\n  output wire out_xnor\n);\n\n  assign out_nand = ~(&in);\n  assign out_nor = ~(|in);\n  assign out_xnor = ~(^in);\n\nendmodule\nmodule functional_module (\n  input [7:0] shift_out,\n  input [49:0] in,\n  output reg [49:0] final_output\n);\n\n  always @(*) begin\n    final_output = shift_out & in;\n  end\n\nendmodule\nmodule top_module (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [2:0] shift_amount,\n  input [49:0] in,\n  input select,\n  output [7:0] shift_out,\n  output wire out_nand,\n  output wire out_nor,\n  output wire out_xnor,\n  output reg [49:0] final_output\n);\n\n  wire [7:0] shift_out_wire;\n  wire [49:0] in_wire;\n\n  parallel_load_shift shift_module (\n    .clk(clk),\n    .reset(reset),\n    .data_in(data_in),\n    .shift_amount(shift_amount),\n    .shift_out(shift_out_wire)\n  );\n\n  combinational_circuit comb_module (\n    .in(in),\n    .out_nand(out_nand),\n    .out_nor(out_nor),\n    .out_xnor(out_xnor)\n  );\n\n  functional_module func_module (\n    .shift_out(shift_out_wire),\n    .in(in_wire),\n    .final_output(final_output)\n  );\n\n  assign in_wire = select ? 50'b0 : in;\n  assign shift_out = shift_out_wire;\n\nendmodule",
        "module_name": "parallel_load_shift",
        "module_hash": "98bc7a21c54275639987ccfa851214b9",
        "dataset_index": 5728
      },
      "srlc32e_10ed3958": {
        "rtl_code": "\nmodule srlc32e(\n    input [31:0] D,\n    input CLK,\n    input CE,\n    input A,\n    output Q\n);\n\n    reg [31:0] Q_reg;\n\n    always @(posedge CLK) begin\n        if (CE) begin\n            Q_reg <= D;\n        end\n    end\n\n    assign Q = Q_reg[A];\n\nendmodule",
        "module_name": "srlc32e",
        "module_hash": "10ed3958be6bc25e577fa9970e121df5",
        "dataset_index": 13395
      },
      "byte_en_reg_98891828": {
        "rtl_code": "module byte_en_reg (\n    clk,\n    rst,\n    we,\n    en,\n    d,\n    q\n    );\n\nparameter DATA_W = 32;\nparameter INIT_VAL = {DATA_W{1'b0}};\n\ninput clk;\ninput rst;\ninput we;\ninput [(DATA_W-1)/8:0] en;\ninput [DATA_W-1:0] d;\noutput reg [DATA_W-1:0] q;\n\ninteger i;\n\nalways @(posedge clk or posedge rst)\nbegin\n    if (rst == 1)\n        q <= INIT_VAL;\n    else\n        for (i = 0; i < DATA_W; i = i + 1)\n            if (we && en[i/8])\n                q[i] <= d[i];\nend\n\nendmodule\n",
        "module_name": "byte_en_reg",
        "module_hash": "988918286a9d127fd4dbe4f53329a350",
        "dataset_index": 16153
      },
      "top__aa0ee660": {
        "rtl_code": "module top_module (\n  input clk,\n  input reset,\n  output reg [3:0] binary_number\n);\n\n  reg [3:0] binary_num_reg;\n  reg [2:0] ones_count_reg;\n  \n  binary_ones_counter ones_counter(.binary_in(binary_num_reg), .clk(clk), .reset(reset), .ones_count(ones_count_reg));\n  \n  always @(posedge clk) begin\n    binary_num_reg <= binary_num_reg + 1;\n  end\n  \n  always @(posedge clk) begin\n    if (ones_count_reg > binary_num_reg) begin\n      binary_number <= ones_count_reg;\n    end else begin\n      binary_number <= binary_num_reg;\n    end\n  end\n  \nendmodule\n\nmodule binary_ones_counter (\n  input [3:0] binary_in,\n  input clk,\n  input reset,\n  output reg [2:0] ones_count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      ones_count <= 0;\n    end else begin\n      case (binary_in)\n        4'b0000: ones_count <= 0;\n        4'b0001: ones_count <= 1;\n        4'b0010: ones_count <= 1;\n        4'b0011: ones_count <= 2;\n        4'b0100: ones_count <= 1;\n        4'b0101: ones_count <= 2;\n        4'b0110: ones_count <= 2;\n        4'b0111: ones_count <= 3;\n        4'b1000: ones_count <= 1;\n        4'b1001: ones_count <= 2;\n        4'b1010: ones_count <= 2;\n        4'b1011: ones_count <= 3;\n        4'b1100: ones_count <= 2;\n        4'b1101: ones_count <= 3;\n        4'b1110: ones_count <= 3;\n        4'b1111: ones_count <= 4;\n      endcase\n    end\n  end\n  \nendmodule",
        "module_name": "top_",
        "module_hash": "aa0ee660fc321f4653f549b8d780b3b9",
        "dataset_index": 2730
      },
      "LUT #_de6150d9": {
        "rtl_code": "module LUT # (parameter SIZE=8)\n(\n input wire [SIZE-1:0] A,\n input wire [1:0] B,\n output reg [SIZE+1:0] Result\n);\n\nwire [SIZE+1:0] wD0, wD1, wD2, wD3;\n\nassign wD1 = {2'b0, A};\nassign wD0 = wD1 ^ wD1; // Esto siempre es cero, de la longitud adecuada.\nassign wD2 = {1'b0, A, 1'b0}; \nassign wD3 = {2'b0, A, 2'b0};\n\nalways @ (A, B)\nbegin\n\tcase (B)\n\t//-------------------------------------\t\n\t2'b00:\n\tbegin\n\t\tResult <= wD0;\n\tend\n\t//-------------------------------------\t\n\t2'b01:\n\tbegin\n\t\tResult <= wD1;\n\tend\n\t//-------------------------------------\t\n\t2'b10:\n\tbegin\n\t\tResult <= wD2;\n\tend\n\t//-------------------------------------\t\n\t2'b11:\n\tbegin\n\t\tResult <= wD3;\n\tend\n\t//-------------------------------------\t\n\tendcase\nend\n\nendmodule",
        "module_name": "LUT #",
        "module_hash": "de6150d9aae3b89c3c689bfee73d3ee2",
        "dataset_index": 7089
      },
      "comparator_58eb7a65": {
        "rtl_code": "\nmodule comparator (\n    input [3:0] in0,\n    input [3:0] in1,\n    output reg [1:0] result\n);\n\nreg [3:0] in0_reg;\nreg [3:0] in1_reg;\n\n\nalways @(in0, in1) begin\n    in0_reg <= in0;\n    in1_reg <= in1;\n\n    if (in0_reg > in1_reg) begin\n        result <= 2'b01;\n    end else if (in0_reg < in1_reg) begin\n        result <= 2'b10;\n    end else begin\n        result <= 2'b00;\n    end\nend\n\nendmodule\n",
        "module_name": "comparator",
        "module_hash": "58eb7a656f956361c27bf407967bbf4c",
        "dataset_index": 16401
      },
      "tri_light_svetofor_67aa3d5d": {
        "rtl_code": "module tri_light_svetofor (\tinput wire time_signal,\n\t\tinput wire reset,\n\t\toutput wire red,\n\t\toutput wire yellow,\n\t\toutput wire green\t\t\n\t\t);\n\tparameter green_time = 8'd26 * 8'd2,  red_time = 8'd84 * 8'd2,\n\tyellow_time = 8'd3 * 8'd2,\n\tblnk_time = 8'd4 * 8'd2,\n\ttril_time = green_time + blnk_time + red_time + yellow_time * 8'd2;\n\t\n\treg [7:0] timer; \treg [2:0] sel_color; assign red = sel_color[0];\n\tassign yellow = sel_color[1];\n\tassign green = sel_color[2];\n\t\n\talways @(posedge time_signal or negedge reset)\n\tbegin\n\t\tif (!reset) begin\t\t\t\t\t\t\ttimer <= 8'd0;\n\t\t\t\tsel_color <= 3'b110; end\n\t\telse begin if (timer < tril_time)\ttimer <= timer + 8'd1; else\n\t\t\t\t\ttimer <= 8'd0; \tif (timer <= red_time) sel_color <= 3'b110; if (timer > red_time && timer <= red_time + yellow_time) sel_color <= 3'b100; if (timer > red_time + yellow_time && timer <= red_time + yellow_time + green_time) sel_color <= 3'b011; if (timer > red_time + yellow_time + green_time && timer <= red_time + yellow_time + green_time + blnk_time)\n\t\t\t\t\tif (sel_color == 3'b011)\n\t\t\t\t\t\tsel_color <= 3'b111; else\n\t\t\t\t\t\tsel_color <= 3'b011; if\t(timer > red_time + yellow_time + green_time + blnk_time)\n\t\t\t\t\tsel_color <= 3'b101; end\n\t\t\n\tend\t\n\t\t\nendmodule",
        "module_name": "tri_light_svetofor",
        "module_hash": "67aa3d5d7767e50a4b64aae4193bd7fc",
        "dataset_index": 13300
      },
      "mux_stall_be4beb75": {
        "rtl_code": "\nmodule mux_stall (\n\tcw_from_cu, \n\tmux_op, \n\tcw_from_mux);\n   input [22:0] cw_from_cu;\n   input mux_op;\n   output [22:0] cw_from_mux;\n\n   // Internal wires\n   wire n2;\n\n   // Generate n2\n   assign n2 = mux_op; // fixed the polarity\n\n   // Implement the multiplexing logic\n   assign cw_from_mux[0] = cw_from_cu[0] & n2;\n   assign cw_from_mux[1] = cw_from_cu[1] & n2;\n   assign cw_from_mux[2] = cw_from_cu[2] & n2;\n   assign cw_from_mux[3] = cw_from_cu[3] & n2;\n   assign cw_from_mux[4] = cw_from_cu[4] & n2;\n   assign cw_from_mux[5] = cw_from_cu[5] & n2;\n   assign cw_from_mux[6] = cw_from_cu[6] & n2;\n   assign cw_from_mux[7] = cw_from_cu[7] & n2;\n   assign cw_from_mux[8] = cw_from_cu[8] & n2;\n   assign cw_from_mux[9] = cw_from_cu[9] & n2;\n   assign cw_from_mux[10] = cw_from_cu[10] & n2;\n   assign cw_from_mux[11] = cw_from_cu[11] & n2;\n   assign cw_from_mux[12] = cw_from_cu[12] & n2;\n   assign cw_from_mux[13] = cw_from_cu[13] & n2;\n   assign cw_from_mux[14] = cw_from_cu[14] & n2;\n   assign cw_from_mux[15] = cw_from_cu[15] & n2;\n   assign cw_from_mux[16] = cw_from_cu[16] & n2;\n   assign cw_from_mux[17] = cw_from_cu[17] & n2;\n   assign cw_from_mux[18] = cw_from_cu[18] & n2;\n   assign cw_from_mux[19] = cw_from_cu[19] & n2;\n   assign cw_from_mux[20] = cw_from_cu[20] & n2;\n   assign cw_from_mux[21] = cw_from_cu[21] & n2;\n   assign cw_from_mux[22] = cw_from_cu[22] & n2;\n\n   // Select between the two inputs based on the mux_op value\n   assign cw_from_mux = cw_from_mux; // fixed the extra mux_op in the assignment\nendmodule",
        "module_name": "mux_stall",
        "module_hash": "be4beb7503fe7df0bb31521b978fa036",
        "dataset_index": 19612
      },
      "encoder_dbc2bbbc": {
        "rtl_code": "module encoder(in,out);\ninput [39:0] in;\noutput [5:0] out;\n\nassign out =  (in[0]==1'b1)?6'd0:\n              (in[1]==1'b1)?6'd1:\n\t\t\t  (in[2]==1'b1)?6'd2:\n\t\t\t  (in[3]==1'b1)?6'd3:\n\t\t\t  (in[4]==1'b1)?6'd4:\n\t\t\t  (in[5]==1'b1)?6'd5:\n\t\t\t  (in[6]==1'b1)?6'd6:\n\t\t\t  (in[7]==1'b1)?6'd7:\n\t\t\t  (in[8]==1'b1)?6'd8:\n\t\t\t  (in[9]==1'b1)?6'd9:\n\t\t\t  (in[10]==1'b1)?6'd10:\n\t\t\t  (in[11]==1'b1)?6'd11:\n\t\t\t  (in[12]==1'b1)?6'd12:\n\t\t\t  (in[13]==1'b1)?6'd13:\n\t\t\t  (in[14]==1'b1)?6'd14:\n\t\t\t  (in[15]==1'b1)?6'd15:\n\t\t\t  (in[16]==1'b1)?6'd16:\n\t\t\t  (in[17]==1'b1)?6'd17:\n\t\t\t  (in[18]==1'b1)?6'd18:\n\t\t\t  (in[19]==1'b1)?6'd19:\n\t\t\t  (in[20]==1'b1)?6'd20:\n\t\t\t  (in[21]==1'b1)?6'd21:\n\t\t\t  (in[22]==1'b1)?6'd22:\n\t\t\t  (in[23]==1'b1)?6'd23:\n\t\t\t  (in[24]==1'b1)?6'd24:\n\t\t\t  (in[25]==1'b1)?6'd25:\n\t\t\t  (in[26]==1'b1)?6'd26:\n\t\t\t  (in[27]==1'b1)?6'd27:\n\t\t\t  (in[28]==1'b1)?6'd28:\n\t\t\t  (in[29]==1'b1)?6'd29:\n\t\t\t  (in[30]==1'b1)?6'd30:\n\t\t\t  (in[31]==1'b1)?6'd31:\n\t\t\t  (in[32]==1'b1)?6'd32:\n\t\t\t  (in[33]==1'b1)?6'd33:\n\t\t\t  (in[34]==1'b1)?6'd34:\n\t\t\t  (in[35]==1'b1)?6'd35:\n\t\t\t  (in[36]==1'b1)?6'd36:\n\t\t\t  (in[37]==1'b1)?6'd37:\n\t\t\t  (in[38]==1'b1)?6'd38:\n\t\t\t  (in[39]==1'b1)?6'd39:\n\t\t\t  6'b000000;\nendmodule\n",
        "module_name": "encoder",
        "module_hash": "dbc2bbbc98eefdf57fc97ba16d482167",
        "dataset_index": 977
      },
      "spi_shift_9e701e4d": {
        "rtl_code": "\nmodule spi_shift (\n  input clk, rst, go, pos_edge, neg_edge, rx_negedge, tx_negedge, lsb, s_clk,\n  input [17:0] p_in,\n  input [7:0] len,\n  output reg tip, \n  output last, //reg last; cannot be driven by primitives or continuous assignment.\n  output reg [17:0] p_out,\n  output reg s_out\n);\n\n  parameter Tp = 1;\n  parameter SPI_CHAR_LEN_BITS = 8;\n  parameter SPI_MAX_CHAR = 18;\n\n  reg [SPI_CHAR_LEN_BITS:0] cnt;\n  reg [SPI_MAX_CHAR-1:0] data;\n  wire [SPI_CHAR_LEN_BITS:0] tx_bit_pos;\n  wire [SPI_CHAR_LEN_BITS:0] rx_bit_pos;\n  wire rx_clk;\n  wire tx_clk;\n\n  assign tx_bit_pos = lsb ? {!(|len), len} - cnt : cnt - {{SPI_CHAR_LEN_BITS{1'b0}},1'b1};\n  assign rx_bit_pos = lsb ? {!(|len), len} - (rx_negedge ? cnt + {{SPI_CHAR_LEN_BITS{1'b0}},1'b1} : cnt) :\n                            (rx_negedge ? cnt : cnt - {{SPI_CHAR_LEN_BITS{1'b0}},1'b1});\n\n  //assign last = !(|cnt);\n  reg last_int;\n  always @(posedge clk or posedge rst) begin\n    if(rst) last_int <= #Tp 1'b0;\n    else last_int <= #Tp !(|cnt);\n  end\n  assign last = last_int;\n\n  assign rx_clk = (rx_negedge ? neg_edge : pos_edge) && (!last || s_clk);\n  assign tx_clk = (tx_negedge ? neg_edge : pos_edge) && !last;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) cnt <= #Tp {SPI_CHAR_LEN_BITS+1{1'b0}};\n    else begin\n      if(tip) cnt <= #Tp pos_edge ? (cnt - {{SPI_CHAR_LEN_BITS{1'b0}}, 1'b1}) : cnt;\n      else cnt <= #Tp !(|len) ? {1'b1, {SPI_CHAR_LEN_BITS{1'b0}}} : {1'b0, len};\n    end\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) s_out <= #Tp 1'b0;\n    else s_out <= #Tp (tx_clk || !tip) ? data[tx_bit_pos[SPI_CHAR_LEN_BITS-1:0]] : s_out;\n  end\n\n  always @(posedge s_clk or posedge rst) begin\n    if (rst) data <= #Tp {SPI_MAX_CHAR{1'b0}};\n    else data <= #Tp {data[SPI_MAX_CHAR-2:0], p_in};\n  end\n\n  always @(posedge s_clk or posedge rst) begin\n    if (rst) p_out <= #Tp {18{1'b0}};\n    else p_out <= #Tp {data[17:0], 1'b0};\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) tip <= #Tp 1'b0;\n    else if (go && ~tip) tip <= #Tp 1'b1;\n    else if (tip && last && pos_edge) tip <= #Tp 1'b0;\n  end\n\nendmodule",
        "module_name": "spi_shift",
        "module_hash": "9e701e4ddb2cd11e7cf2e58fd88ad8b5",
        "dataset_index": 12002
      },
      "gray_counter_b5145ac4": {
        "rtl_code": "module gray_counter (\n    input clk,\n    input rst,\n    input ena,\n    output reg [3:0] q\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            q <= 4'b0000;\n        end\n        else if (ena) begin\n            q <= q ^ (q >> 1);\n        end\n        else begin\n            q <= q ^ (q >> 1) ^ 4'b0001;\n        end\n    end\n\nendmodule",
        "module_name": "gray_counter",
        "module_hash": "b5145ac4cd316885f2806e89f124083f",
        "dataset_index": 4530
      },
      "binary_counter_e722fb84": {
        "rtl_code": "module binary_counter (\n  input clk,\n  input reset,\n  output [3:0] count\n);\n\nreg [3:0] temp_count;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    temp_count <= 4'b0000;\n  end\n  else begin\n    if (temp_count == 4'b0111) begin\n      temp_count <= 4'b0000;\n    end\n    else begin\n      temp_count <= temp_count + 1;\n    end\n  end\nend\n\nassign count = temp_count;\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "e722fb84c49a227fb84e4395302a12b3",
        "dataset_index": 2141
      },
      "half_adder_11018023": {
        "rtl_code": "module half_adder(\n    input a, b,\n    output sum, cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule",
        "module_name": "half_adder",
        "module_hash": "110180237ccd462968bbf382cb840fcc",
        "dataset_index": 12718
      },
      "add_sub_module_73611294": {
        "rtl_code": "module add_sub_module(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\n    wire [31:0] inverted_b;\n    wire [31:0] carry_out;\n    wire [31:0] temp_sum;\n\n    assign inverted_b = ~b;\n\n    // Adder module\n    adder_module adder(\n        .a(a),\n        .b(inverted_b),\n        .carry_in(sub),\n        .sum(temp_sum),\n        .carry_out(carry_out)\n    );\n\n    // XOR gate\n    assign sum = (sub) ? temp_sum + 1 : temp_sum;\n\nendmodule\n\nmodule adder_module(\n    input [31:0] a,\n    input [31:0] b,\n    input carry_in,\n    output [31:0] sum,\n    output [31:0] carry_out\n);\n\n    assign {carry_out, sum} = a + b + carry_in;\n\nendmodule",
        "module_name": "add_sub_module",
        "module_hash": "7361129473c5760cdcc7830447b38225",
        "dataset_index": 5538
      },
      "pulse_generator_8e18a231": {
        "rtl_code": "\nmodule pulse_generator(\n    input clk,\n    input reset,\n    input in,\n    output reg p,\n    output reg l\n);\n\n    reg [18:0] r;\n    reg [1:0] state;\n    parameter IDLE = 2'b00, COUNTING = 2'b01, PULSE = 2'b10;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            r <= 0;\n            l <= 0;\n            state <= IDLE;\n        end else begin\n            case(state)\n                IDLE: begin\n                    if (in) begin\n                        state <= COUNTING;\n                        r <= 0;\n                        l <= 1;\n                    end else begin\n                        l <= 0;\n                    end\n                end\n                COUNTING: begin\n                    if (r == 250000) begin\n                        state <= PULSE;\n                        r <= 0;\n                        p <= 1;\n                    end else begin\n                        r <= r + 1;\n                        l <= 1;\n                        p <= 0;\n                    end\n                end\n                PULSE: begin\n                    if (in) begin\n                        state <= COUNTING;\n                        r <= 0;\n                        p <= 0;\n                        l <= 1;\n                    end else begin\n                        l <= 0;\n                        p <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "pulse_generator",
        "module_hash": "8e18a2317a53fbf7c841b579987ab44c",
        "dataset_index": 19296
      },
      "binary_adder_42bbb554": {
        "rtl_code": "module binary_adder(\n    input [3:0] in1,\n    input [3:0] in2,\n    input ctrl,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] temp_sum;\n    assign temp_sum = {1'b0, in1} + {1'b0, in2};\n\n    assign sum = (ctrl == 1'b0) ? temp_sum[3:0] : temp_sum[4];\n    assign cout = temp_sum[4];\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "42bbb554b9fc8a309ea5cc7312036da0",
        "dataset_index": 831
      },
      "rj_memory_c15048fe": {
        "rtl_code": "module rj_memory (input wr_en, rd_en, Sclk,\n\t\t\t\t\t\tinput [3:0] rj_wr_addr, rj_rd_addr,\n\t\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\t\toutput [15:0] rj_data);\n\n\treg [15:0] rj_mem [0:15];\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\trj_mem[rj_wr_addr] = data_in;\n\t\telse\n\t\t\trj_mem[rj_wr_addr] = rj_mem[rj_wr_addr];\t\t\n\tend\n\n\tassign rj_data = (rd_en) ? rj_mem[rj_rd_addr] : 16'd0;\nendmodule",
        "module_name": "rj_memory",
        "module_hash": "c15048fe085943bcb88621ec7b995af7",
        "dataset_index": 11221
      },
      "burst_counter_27618158": {
        "rtl_code": "module burst_counter(\n    input wire bclk,\n    input wire [15:0] bus_ad,\n    input wire [2:0] bus_a,\n    input wire adv,\n    input wire rw,\n    input wire cs,\n    output reg [15:0] measured_burst\n);\n\n    reg [15:0] burstcnt;   // counts the number of burst cycles\n    reg [15:0] finalcnt;   // stores the number of burst cycles from the previous memory access operation\n    reg activated;         // indicates whether the memory access operation is occurring\n    reg activated_d;       // stores the value of activated from the previous clock cycle\n    reg [15:0] bus_ad_r;   // stores the value of bus_ad from the previous clock cycle\n    reg [2:0] bus_a_r;     // stores the value of bus_a from the previous clock cycle\n    reg cs_r;              // stores the value of cs from the previous clock cycle\n    reg rw_r;              // stores the value of rw from the previous clock cycle\n    reg adv_r;             // stores the value of adv from the previous clock cycle\n    \n    always @(posedge bclk) begin\n        // store the values of the input signals from the previous clock cycle\n        bus_ad_r <= bus_ad;\n        bus_a_r <= bus_a;\n        cs_r <= cs;\n        rw_r <= rw;\n        adv_r <= adv;\n        \n        // check if the memory access operation is occurring\n        if (cs_r && adv_r && ({bus_a_r, bus_ad_r[15:12]} == 7'h4_F)) begin\n            activated <= 1'b1;\n        end else if (!cs_r) begin\n            activated <= 1'b0;\n        end else begin\n            activated <= activated;\n        end\n        \n        // count the number of burst cycles during the memory access operation\n        if (!activated) begin\n            finalcnt <= burstcnt;\n            burstcnt <= 16'h0;\n        end else begin\n            burstcnt <= burstcnt + 16'h1;\n            finalcnt <= finalcnt;\n        end\n        \n        // output the number of burst cycles on the falling edge of activated\n        activated_d <= activated;\n        if (activated_d & !activated) begin\n            measured_burst <= finalcnt + 1'b1;\n        end else begin\n            measured_burst <= measured_burst;\n        end\n    end\n    \nendmodule",
        "module_name": "burst_counter",
        "module_hash": "27618158d0916ced2950640838f3d47b",
        "dataset_index": 5774
      },
      "sky130_fd_sc_hd__bufinv_43db5357": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__bufinv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__bufinv",
        "module_hash": "43db53571a7f4fe5fbca78d57be34545",
        "dataset_index": 22677
      },
      "divider #_dcd19fdd": {
        "rtl_code": "module divider #(\n  parameter n = 8 // number of bits in dividend and divisor\n) (\n  input signed [n-1:0] dividend,\n  input signed [n-1:0] divisor,\n  output signed [n-1:0] quotient,\n  output signed [n-1:0] remainder\n);\n\nparameter signed_div = 1; // 1 for signed division, 0 for unsigned division\n\nreg signed [n-1:0] dividend_reg;\nreg signed [n-1:0] divisor_reg;\nreg signed [n-1:0] quotient_reg;\nreg signed [n-1:0] remainder_reg;\nreg signed [n-1:0] dividend_abs;\nreg signed [n-1:0] divisor_abs;\nreg signed [n-1:0] quotient_abs;\nreg signed [n-1:0] remainder_abs;\nreg signed [n-1:0] dividend_sign;\nreg signed [n-1:0] divisor_sign;\nreg signed [n-1:0] quotient_sign;\n\nalways @(*) begin\n  // Absolute value of dividend and divisor\n  if (dividend < 0) begin\n    dividend_abs = -dividend;\n    dividend_sign = -1;\n  end else begin\n    dividend_abs = dividend;\n    dividend_sign = 1;\n  end\n  \n  if (divisor < 0) begin\n    divisor_abs = -divisor;\n    divisor_sign = -1;\n  end else begin\n    divisor_abs = divisor;\n    divisor_sign = 1;\n  end\n  \n  // Perform division\n  if (divisor == 0) begin\n    quotient_reg = 'bx;\n    remainder_reg = 'bx;\n  end else if (signed_div) begin\n    // Signed division\n    if (dividend_sign == divisor_sign) begin\n      quotient_abs = dividend_abs / divisor_abs;\n      remainder_abs = dividend_abs % divisor_abs;\n      quotient_sign = dividend_sign;\n    end else begin\n      quotient_abs = (dividend_abs + divisor_abs - 1) / divisor_abs;\n      remainder_abs = dividend_abs - quotient_abs * divisor_abs;\n      quotient_sign = -dividend_sign;\n    end\n  end else begin\n    // Unsigned division\n    quotient_abs = dividend_abs / divisor_abs;\n    remainder_abs = dividend_abs % divisor_abs;\n    quotient_sign = 1;\n  end\n  \n  // Apply sign to quotient and remainder\n  quotient_reg = quotient_abs * quotient_sign;\n  remainder_reg = remainder_abs * dividend_sign;\nend\n\nassign quotient = quotient_reg;\nassign remainder = remainder_reg;\n\nendmodule",
        "module_name": "divider #",
        "module_hash": "dcd19fdda26b4f7d9c0ef793fe366440",
        "dataset_index": 15065
      },
      "register_ctrl_top_98d78aa2": {
        "rtl_code": "module register_ctrl_top(\n    input                             I_sys_clk           , \n    input                             I_sys_rst           ,\n    output                            O_usb_uart_tx_req   ,\n    output   [7 : 0]                  O_usb_uart_tx_data  ,\n    input                             I_usb_uart_tx_full  ,\n    \n    output                            O_usb_uart_rx_req   ,\n    input    [7 : 0]                  I_usb_uart_rx_data  ,\n    input                             I_usb_uart_rx_empty ,    \n    output                            O_usb_dir           ,\n\t \n    output                            O_motor_start       ,\n    \n    output                            tp                  ,\n\t \n    input                             I_key_start\n);\nreg                                   R_usb_uart_rx_req     ;\nreg                                   R_usb_uart_rx_req_d1  ;\n\nreg                                   R_tx_en       ;\nreg          [7 : 0]                  R_tx_data     ;\n\nreg                                   R_rx_en       ;\nreg          [7 : 0]                  R_rx_data     ;\n\nreg                                   R_usb_dir     ;\n\nreg                                   R_motor_start ;\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_usb_uart_rx_req     <= 1'd0     ;\n        end\n    else if(I_usb_uart_rx_empty == 1'b0)       begin\n            R_usb_uart_rx_req     <= 1'd1     ;\n        end\n    else\n        begin\n            R_usb_uart_rx_req     <= 1'd0     ;\n        end\n        \n    R_usb_uart_rx_req_d1          <= R_usb_uart_rx_req;\nend\n\n\n\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_rx_en       <= 1'd0   ;\n            R_rx_data     <= 8'd0  ;\n        end\n    else if(R_usb_uart_rx_req_d1 == 1'b1)\n        begin\n            R_rx_en       <= 1'd1   ;\n            R_rx_data     <= I_usb_uart_rx_data  ;\n        end\n    else\n        begin\n            R_rx_en       <= 1'd0   ;\n        end\nend\n\n\n\n\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_tx_en       <= 1'd0   ;\n            R_tx_data     <= 8'd0  ;\n        end\n    else if(I_usb_uart_tx_full==1'b0)           begin\n            if(I_key_start==1'b1)\n                begin\n                    R_tx_en       <= 1'b1  ;R_tx_data     <= 8'h55 ;end\n            else\n                begin\n                    R_tx_en       <= 1'b0  ;end\n        end\n    else\n        begin\n            R_tx_en       <= 1'b0  ;\n        end\nend \n\n\n \n\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_usb_dir       <= 1'd0;                    R_motor_start   <= 1'b0;\n        end\n    else if(R_rx_en)\n        begin\n            case(R_rx_data)\n                8'h00:\n                    begin\n                        R_usb_dir       <= 1'b0;      end\n                8'hff:\n                    begin\n                        R_usb_dir       <= 1'b1;     end\n                8'h02:\n                    begin\n                        R_motor_start   <= 1'b1;    end\n            endcase\n        end\n    else\n        begin\n            R_motor_start   <= 1'b0;\n        end\n        \nend\n\n\n\n\nassign O_usb_uart_rx_req   = R_usb_uart_rx_req;\n\nassign O_usb_uart_tx_req   = R_tx_en  ;\n\nassign O_usb_uart_tx_data  = R_tx_data;\n\nassign O_usb_dir           = R_usb_dir  ;\n\nassign O_motor_start       = R_motor_start;\n\nassign  tp                 = R_rx_en & (&R_rx_data) & O_motor_start & O_usb_dir;\n\n\n\n\nendmodule",
        "module_name": "register_ctrl_top",
        "module_hash": "98d78aa2630cb00f336f67944b9d37ed",
        "dataset_index": 3185
      },
      "unknown_module_c473b84c": {
        "rtl_code": "module\tHardRegister(Clock, Reset, Set, Enable, In, Out) ;\n\tparameter\t\t\t\tWidth = \t\t\t\t32,\n\t\t\t\t\t\t\tInitial =\t\t\t\t{Width{1'bx}},\n\t\t\t\t\t\t\tAsyncReset =\t\t\t0,\n\t\t\t\t\t\t\tAsyncSet =\t\t\t\t0,\n\t\t\t\t\t\t\tResetValue =\t\t\t{Width{1'b0}},\n\t\t\t\t\t\t\tSetValue =\t\t\t\t{Width{1'b1}};\n\tinput\t\t\t\t\tClock, Enable, Reset, Set;\n\tinput\t[Width-1:0]\t\tIn;\n\toutput reg [Width-1:0]\tOut =\t\t\t\t\tInitial ;\n\tgenerate if (AsyncReset) begin:AR\n\t\tif (AsyncSet) begin:AS\n\t\t\talways @ (posedge Clock or posedge Reset or posedge Set) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend else begin:SS\n\t\t\talways @ (posedge Clock or posedge Reset) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend\n\tend else begin:SR\n\t\tif (AsyncSet) begin:AS\n\t\t\talways @ (posedge Clock or posedge Set) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend else begin:SS\n\t\t\talways @ (posedge Clock) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend\n\tend endgenerate\n\tendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "c473b84c6164527d90033a657d560438",
        "dataset_index": 24457
      },
      "qrs_refinement1_94a5fa22": {
        "rtl_code": "\nmodule qrs_refinement1(\n    output [15:0] q_begin_ref,\n    output [15:0] s_end_ref,\n    output [15:0] q_begin_l3_temp,\n    output [15:0] s_end_l3_temp,\n    input [15:0] q_begin_l3,\n    input [15:0] s_end_l3,\n    input swindow1_full,\n    input qwindow1_full,\n    input s_end_l3_flag,\n    input q_begin_l3_flag,\n    input [3:0] count1,\n    input [8:0] count2,\n    input clk,\n    input nReset\n);\n\nreg signed [15:0] q_begin_ref;\nreg signed [15:0] s_end_ref;\nreg signed [15:0] q_begin_l3_temp;\nreg signed [15:0] s_end_l3_temp;\n\nwire clk;\nwire nReset;\n\nalways @(posedge clk or negedge nReset) begin\n    if (!nReset) begin\n        q_begin_ref <= 0;\n        s_end_ref <= 0;\n        q_begin_l3_temp <= 0;\n        s_end_l3_temp <= 0;\n    end else begin\n        if (count1 == 2 && count2 == 1) begin\n            if (qwindow1_full == 1) begin\n                if (q_begin_l3_flag == 1) begin\n                    q_begin_l3_temp <= q_begin_l3 - 1;\n                end else begin\n                    q_begin_l3_temp <= q_begin_l3_temp;\n                end\n            end else begin\n                q_begin_l3_temp <= q_begin_l3_temp;\n            end\n\n            q_begin_ref <= q_begin_l3_temp << 3;\n\n            if (swindow1_full == 1) begin\n                if (s_end_l3_flag == 1) begin\n                    s_end_l3_temp <= s_end_l3 + 2;\n                end else begin\n                    s_end_l3_temp <= s_end_l3_temp;\n                end\n            end else begin\n                s_end_l3_temp <= s_end_l3_temp;\n            end\n\n            s_end_ref <= s_end_l3_temp << 3;\n        end else begin\n            q_begin_ref <= q_begin_ref;\n            s_end_ref <= s_end_ref;\n            q_begin_l3_temp <= q_begin_l3_temp;\n            s_end_l3_temp <= s_end_l3_temp;\n        end\n    end\nend\n\nendmodule",
        "module_name": "qrs_refinement1",
        "module_hash": "94a5fa22efc7cc1a450856d1ae5e71c5",
        "dataset_index": 4325
      },
      "UnorderedSet #_27c0d753": {
        "rtl_code": "\n\n\n\n\nmodule UnorderedSet #(\n\tparameter DEPTH\t\t\t= 16,\tparameter ITER_SIZE\t\t= 4,\tparameter KEY_SIZE\t\t= 16\t) (\n\tinput wire\t\t\t\t\tclk,\n\n\tinput wire\t\t\t\t\tinsert_en,\t\tinput wire[KEY_SIZE-1:0]\tinsert_key,\t\toutput reg\t\t\t\t\tinsert_ok = 0,\tinput wire\t\t\t\t\titer_inc,\t\tinput wire\t\t\t\t\titer_begin,\t\tinput wire[ITER_SIZE-1:0]\titer_in,\t\toutput reg\t\t\t\t\titer_end = 0,\toutput reg[ITER_SIZE-1:0]\titer_next = 0,\toutput reg[KEY_SIZE-1:0]\titer_key = 0,\tinput wire\t\t\t\t\tremove_en,\t\tinput wire[ITER_SIZE-1:0]\tremove_iter\t\t);\n\n\tinteger i;\n\n\treg\t\t\t\t\tslot_valid[DEPTH-1:0];\n\treg[KEY_SIZE-1:0]\tslot_key[DEPTH-1:0];\n\n\tinitial begin\n\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\tslot_valid[i]\t<= 0;\n\t\t\tslot_key[i]\t\t<= 0;\n\t\tend\n\tend\n\n\treg\t\thit = 0;\n\n\talways @(*) begin\n\n\t\titer_end\t\t<= 1;\t\titer_next\t\t<= 0;\n\n\t\thit\t\t\t\t= 0;\n\n\t\tif(iter_begin) begin\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(slot_valid[i] && !hit) begin\n\t\t\t\t\thit\t\t\t= 1;\n\t\t\t\t\titer_end\t<= 0;\n\t\t\t\t\titer_next\t<= i;\n\t\t\t\t\titer_key\t<= slot_key[i];\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\telse if(iter_inc) begin\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(slot_valid[i] && !hit && (i > iter_in) ) begin\n\t\t\t\t\thit\t\t\t= 1;\n\t\t\t\t\titer_end\t<= 0;\n\t\t\t\t\titer_next\t<= i;\n\t\t\t\t\titer_key\t<= slot_key[i];\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\tend\n\n\talways @(posedge clk) begin\n\n\t\tinsert_ok\t\t= 0;\n\n\t\tif(insert_en) begin\n\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(slot_valid[i] && (slot_key[i] == insert_key) ) begin\n\t\t\t\t\tinsert_ok\t\t= 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(!slot_valid[i] && !insert_ok) begin\n\t\t\t\t\tinsert_ok\t\t= 1;\n\t\t\t\t\tslot_valid[i]\t<= 1;\n\t\t\t\t\tslot_key[i]\t\t<= insert_key;\n\t\t\t\tend\n\t\t\tend\n\n\t\tend\n\n\t\tif(remove_en)\n\t\t\tslot_valid[remove_iter]\t<= 0;\n\n\tend\n\n\nendmodule\n",
        "module_name": "UnorderedSet #",
        "module_hash": "27c0d753e3e4a93dd0c17e065f6a598a",
        "dataset_index": 12111
      },
      "mux4to1_6982417b": {
        "rtl_code": "module mux4to1 (D0, D1, S, Y);\n    input [3:0] D0;\n    input [3:0] D1;\n    input [1:0] S;\n    output [3:0] Y;\n    \n    assign Y = (S == 2'b00) ? D0 :\n               (S == 2'b01) ? D1 :\n               (S == 2'b10) ? 4'b0100 :\n                              4'b0111 ;\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "6982417bbad1ce70885b37dbe5384b64",
        "dataset_index": 17941
      },
      "sky130_fd_sc_hd__nand4b_5c013ccd": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nand4b (\n    Y  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N              );\n    nand nand0 (nand0_out_Y, D, C, B, not0_out);\n    buf  buf0  (Y          , nand0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nand4b",
        "module_hash": "5c013ccd9451f2a16265d88c78beb931",
        "dataset_index": 11105
      },
      "LogicProbe_3e14da4f": {
        "rtl_code": "\n\nmodule LogicProbe(clock, reset, trigger, sample, channels, serial_out);\n    input clock;\n    input reset;\n    input trigger;\n    input sample;\n    input [127:0] channels;\n    output serial_out;\n\n  wire full;\n  reg [12:0] rdaddr;\n  wire [7:0] data;\n  reg write;\n  wire ready;\n  reg done;\n  reg state;\n\n  LogicProbe_sampler\n    sampler(clock, reset, trigger, sample, channels, full, rdaddr, data);\n\n  LogicProbe_xmtbuf\n    xmtbuf(clock, reset, write, ready, data, serial_out);\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      rdaddr <= 13'd0;\n      write <= 0;\n      done <= 0;\n      state <= 0;\n    end else begin\n      if (full == 1 && done == 0) begin\n        if (state == 0) begin\n          if (ready == 1) begin\n            state <= 1;\n            write <= 1;\n          end\n        end else begin\n          if (rdaddr == 13'd8191) begin\n            done <= 1;\n          end\n          state <= 0;\n          write <= 0;\n          rdaddr <= rdaddr + 1;\n        end\n      end\n    end\n  end\n\nendmodule\n\n\nmodule LogicProbe_sampler(clock, reset, trigger, sample,\n                          data_in, full, rdaddr, data_out);\n    input clock;\n    input reset;\n    input trigger;\n    input sample;\n    input [127:0] data_in;\n    output reg full;\n    input [12:0] rdaddr;\n    output reg [7:0] data_out;\n\n  reg [31:0] mem3[0:511];\n  reg [31:0] mem2[0:511];\n  reg [31:0] mem1[0:511];\n  reg [31:0] mem0[0:511];\n\n  reg [8:0] wraddr;\n  wire [8:0] addr;\n  reg [31:0] data3;\n  reg [31:0] data2;\n  reg [31:0] data1;\n  reg [31:0] data0;\n\n  reg [3:0] muxctrl;\n  reg triggered;\n\n  assign addr = (full == 0) ? wraddr: rdaddr[12:4];\n\n  always @(posedge clock) begin\n    muxctrl <= rdaddr[3:0];\n  end\n\n  always @(*) begin\n    case (muxctrl)\n      4'h0: data_out = data3[31:24];\n      4'h1: data_out = data3[23:16];\n      4'h2: data_out = data3[15: 8];\n      4'h3: data_out = data3[ 7: 0];\n      4'h4: data_out = data2[31:24];\n      4'h5: data_out = data2[23:16];\n      4'h6: data_out = data2[15: 8];\n      4'h7: data_out = data2[ 7: 0];\n      4'h8: data_out = data1[31:24];\n      4'h9: data_out = data1[23:16];\n      4'hA: data_out = data1[15: 8];\n      4'hB: data_out = data1[ 7: 0];\n      4'hC: data_out = data0[31:24];\n      4'hD: data_out = data0[23:16];\n      4'hE: data_out = data0[15: 8];\n      4'hF: data_out = data0[ 7: 0];\n    endcase\n  end\n\n  always @(posedge clock) begin\n    if (full == 0) begin\n      mem3[addr] <= data_in[127:96];\n      mem2[addr] <= data_in[ 95:64];\n      mem1[addr] <= data_in[ 63:32];\n      mem0[addr] <= data_in[ 31: 0];\n    end\n    data3 <= mem3[addr];\n    data2 <= mem2[addr];\n    data1 <= mem1[addr];\n    data0 <= mem0[addr];\n  end\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      wraddr <= 9'd0;\n      triggered <= 0;\n      full <= 0;\n    end else begin\n      if (triggered == 1) begin\n        if (sample == 1) begin\n          if (wraddr == 9'd511) begin\n            full <= 1;\n          end else begin\n            wraddr <= wraddr + 1;\n          end\n        end\n      end else begin\n        if (trigger == 1) begin\n          triggered <= 1;\n          if (sample == 1) begin\n            wraddr <= wraddr + 1;\n          end\n        end\n      end\n    end\n  end\n\nendmodule\n\n\nmodule LogicProbe_xmtbuf(clock, reset, write, ready, data_in, serial_out);\n    input clock;\n    input reset;\n    input write;\n    output reg ready;\n    input [7:0] data_in;\n    output serial_out;\n\n  reg [1:0] state;\n  reg [7:0] data_hold;\n  reg load;\n  wire empty;\n\n  LogicProbe_xmt xmt(clock, reset, load, empty, data_hold, serial_out);\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      state <= 2'b00;\n      ready <= 1;\n      load <= 0;\n    end else begin\n      case (state)\n        2'b00:\n          begin\n            if (write == 1) begin\n              state <= 2'b01;\n              data_hold <= data_in;\n              ready <= 0;\n              load <= 1;\n            end\n          end\n        2'b01:\n          begin\n            state <= 2'b10;\n            ready <= 1;\n            load <= 0;\n          end\n        2'b10:\n          begin\n            if (empty == 1 && write == 0) begin\n              state <= 2'b00;\n              ready <= 1;\n              load <= 0;\n            end else\n            if (empty == 1 && write == 1) begin\n              state <= 2'b01;\n              data_hold <= data_in;\n              ready <= 0;\n              load <= 1;\n            end else\n            if (empty == 0 && write == 1) begin\n              state <= 2'b11;\n              data_hold <= data_in;\n              ready <= 0;\n              load <= 0;\n            end\n          end\n        2'b11:\n          begin\n            if (empty == 1) begin\n              state <= 2'b01;\n              ready <= 0;\n              load <= 1;\n            end\n          end\n      endcase\n    end\n  end\n\nendmodule\n\n\nmodule LogicProbe_xmt(clock, reset, load, empty, parallel_in, serial_out);\n    input clock;\n    input reset;\n    input load;\n    output reg empty;\n    input [7:0] parallel_in;\n    output serial_out;\n\n  reg [3:0] state;\n  reg [8:0] shift;\n  reg [10:0] count;\n\n  assign serial_out = shift[0];\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      state <= 4'h0;\n      shift <= 9'b111111111;\n      empty <= 1;\n    end else begin\n      if (state == 4'h0) begin\n        if (load == 1) begin\n          state <= 4'h1;\n          shift <= { parallel_in, 1'b0 };\n          count <= 1302;\n          empty <= 0;\n        end\n      end else\n      if (state == 4'hb) begin\n        state <= 4'h0;\n        empty <= 1;\n      end else begin\n        if (count == 0) begin\n          state <= state + 1;\n          shift[8:0] <= { 1'b1, shift[8:1] };\n          count <= 1302;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "LogicProbe",
        "module_hash": "3e14da4f053f250028a3b0aec57804aa",
        "dataset_index": 15520
      },
      "nfa_accept_samples_generic_hw_start_indices_ram_3a536a2e": {
        "rtl_code": "\nmodule nfa_accept_samples_generic_hw_start_indices_ram (addr0, ce0, d0, we0, q0,  clk);\n\nparameter DWIDTH = 32;\nparameter AWIDTH = 4;\nparameter MEM_SIZE = 16;\n\ninput[AWIDTH-1:0] addr0;\ninput ce0;\ninput[DWIDTH-1:0] d0;\ninput we0;\noutput reg[DWIDTH-1:0] q0;\ninput clk;\n\nreg [DWIDTH-1:0] ram[MEM_SIZE-1:0];\n\n\n\n\nalways @(posedge clk)  \nbegin \n    if (ce0) \n    begin\n        if (we0) \n        begin \n            ram[addr0] <= d0; \n            q0 <= d0;\n        end \n        else \n            q0 <= ram[addr0];\n    end\nend\n\n\nendmodule\n\nmodule nfa_accept_samples_generic_hw_start_indices(\n    reset,\n    clk,\n    address0,\n    ce0,\n    we0,\n    d0,\n    q0);\n\nparameter DataWidth = 32'd32;\nparameter AddressRange = 32'd16;\nparameter AddressWidth = 32'd4;\ninput reset;\ninput clk;\ninput[AddressWidth - 1:0] address0;\ninput ce0;\ninput we0;\ninput[DataWidth - 1:0] d0;\noutput[DataWidth - 1:0] q0;\n\n\n\n\nnfa_accept_samples_generic_hw_start_indices_ram nfa_accept_samples_generic_hw_start_indices_ram_U(\n    .clk( clk ),\n    .addr0( address0 ),\n    .ce0( ce0 ),\n    .d0( d0 ),\n    .we0( we0 ),\n    .q0( q0 ));\n\nendmodule\n\n",
        "module_name": "nfa_accept_samples_generic_hw_start_indices_ram",
        "module_hash": "3a536a2e8c1533f09f7a54181a47462f",
        "dataset_index": 23669
      },
      "du_0e06137b": {
        "rtl_code": "module du(clk, rst, deposit, select, price, ldRdeposit, ldRselect, ldRprice,\n\t\t\tldA, ldRproduct, ldRchange, ldRpurchase, ldMprice, ldMquantity,\n\t\t\tclrRdeposit, clrRselect, clrRprice, clrA, clrRproduct, clrRchange,\n\t\t\tclrRpurchase, purchase, refund, product, change);\n\tinput\tclk, rst;\n\tinput\t[9:0] deposit, price;\n\tinput\t[4:0] select;\n\tinput\tldRdeposit, ldRselect, ldRprice, ldA, ldRproduct, ldRchange;\n\tinput\tldRpurchase, ldMprice, ldMquantity, clrRdeposit, clrRselect;\n\tinput\tclrRprice, clrA, clrRproduct, clrRchange, clrRpurchase;\n\toutput reg\tpurchase, refund;\n\toutput reg\t[4:0] product;\n\toutput reg\t[9:0] change;\n\treg\t[9:0] Rdeposit, Rprice, Adeposit;\n\treg\t[4:0] Rselect;\n\treg\t[15:0] mem [0:31];\n\tinteger\ti;\n\n\tinitial begin\n\t\tfor (i=0;i<32;i=i+1) begin\n\t\t\tmem[i] = 16'h2864;\n\t\tend\n\t\tmem[0] = 16'b0000_0000_0011_0010; mem[1] = 16'b0010_1001_1001_0000; end\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tRdeposit <= 0;\n\t\telse if (ldRdeposit)\tRdeposit <= deposit;\n\t\telse if (clrRdeposit)\tRdeposit <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tRselect <= 0;\n\t\telse if (ldRselect)\t\tRselect <= select;\n\t\telse if (clrRselect)\tRselect <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\tRprice <= 0;\n\t\telse if (ldRprice)\tRprice <= price;\n\t\telse if (clrRprice)\tRprice <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\tAdeposit <= 0;\n\t\telse if (ldA)\tAdeposit <= Adeposit + Rdeposit;\n\t\telse if (clrA)\tAdeposit <= 0;\n\t\telse if (refund)\tAdeposit <= Adeposit - Rdeposit;\n\tend\n\n\talways @ (Adeposit) begin\n\t\tif (Adeposit > 500)\trefund = 1;\n\t\telse\t\t\t\trefund = 0;\n\tend\n\n\talways @ (Adeposit) begin\n\t\tfor (i=0; i<32;i=i+1) begin\n\t\t\tif (0 < mem[i][13:10] && Adeposit >= mem[i][9:0])\n\t\t\t\t\tmem[i][15] = 1;\n\t\t\telse\tmem[i][15] = 0;\n\t\tend\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\t\tpurchase <= 0;\n\t\telse if (ldRpurchase)\n\t\t\tif (mem[Rselect][15])\tpurchase <= 1;\n\t\t\telse\t\t\t\t\tpurchase <= 0;\n\t\telse if (clrRpurchase)\t\tpurchase <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tchange <= 0;\n\t\telse if (ldRchange)\t\tchange <= Adeposit - mem[Rselect][9:0];\n\t\telse if (clrRchange)\tchange <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tproduct <= 0;\n\t\telse if (ldRproduct)\tproduct <= Rselect;\n\t\telse if (clrRproduct)\tproduct <= 0;\n\tend\n\n\talways @ (posedge clk) begin\n\t\tif (ldMquantity)\tmem[Rselect][13:10]\t<= mem[Rselect][13:10] - 1'b1;\n\t\tif (ldMprice)\t\tmem[Rselect][9:0]\t<= Rprice;\t\t\n\tend\nendmodule\n\n",
        "module_name": "du",
        "module_hash": "0e06137be0748263517e2e06c3c3680f",
        "dataset_index": 5837
      },
      "my_nor4_dae3e5b5": {
        "rtl_code": "\nmodule my_nor4 (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    VPWR,\n    VGND\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n    \n    wire n1, n2, n3, n4;\n\n    nor (n1, A, B);\n    nor (n2, C, D);\n    nor (n3, n1, n2);\n    nor (n4, n3, n3);\n    nor (Y, n4, n4);\n\nendmodule\n",
        "module_name": "my_nor4",
        "module_hash": "dae3e5b55fedef7c3550494155037f05",
        "dataset_index": 14673
      },
      "cdc_syncfifo #_07d30700": {
        "rtl_code": "\n\n \n\nmodule cdc_syncfifo #(\n    parameter DSIZE = 34,\n    parameter ASIZE = 2\n) (\n    output wire [DSIZE-1:0] rdata,\n    output wire wfull,\n    output wire rempty,\n    input wire [DSIZE-1:0] wdata,\n    input wire winc, wclk, wrst,\n    input wire rinc, rclk, rrst\n);\n    \nwire [ASIZE-1:0] waddr, raddr;\nwire [ASIZE:0] wptr, rptr, wq2_rptr, rq2_wptr;\n\ncdc_sync_r2w #(.ADDRSIZE(ASIZE)) sync_r2w_inst (.wq2_rptr(wq2_rptr), .rptr(rptr),\n    .wclk(wclk), .wrst(wrst));\n\ncdc_sync_w2r #(.ADDRSIZE(ASIZE)) sync_w2r_inst (.rq2_wptr(rq2_wptr), .wptr(wptr),\n    .rclk(rclk), .rrst(rrst));\n\ncdc_fifomem #(.DATASIZE(DSIZE), .ADDRSIZE(ASIZE)) cdc_fifomem_inst\n(.rdata(rdata), .wdata(wdata),\n    .waddr(waddr), .raddr(raddr),\n    .wclken(winc), .wfull(wfull),\n    .wclk(wclk));\n\nrptr_empty #(.ADDRSIZE(ASIZE)) rptr_empty_inst\n(.rempty(rempty),\n    .raddr(raddr),\n    .rptr(rptr), .rq2_wptr(rq2_wptr),\n    .rinc(rinc), .rclk(rclk),\n    .rrst(rrst));\n\nwptr_full #(.ADDRSIZE(ASIZE)) wptr_full_inst\n(.wfull(wfull), .waddr(waddr),\n    .wptr(wptr), .wq2_rptr(wq2_rptr),\n    .winc(winc), .wclk(wclk),\n    .wrst(wrst));\n\nendmodule\n\nmodule cdc_fifomem #(\nparameter DATASIZE = 34, parameter ADDRSIZE = 2 ) (\n    output wire [DATASIZE-1:0] rdata,\n    input wire [DATASIZE-1:0] wdata,\n    input wire [ADDRSIZE-1:0] waddr, raddr,\n    input wire wclken, wfull, wclk\n);\n        \n        \nlocalparam DEPTH = 1<<ADDRSIZE;\nreg [DATASIZE-1:0] cdc_mem [0:DEPTH-1];\n\n\nassign rdata = cdc_mem[raddr];\nalways @(posedge wclk)\n    if (wclken && !wfull) cdc_mem[waddr] <= wdata;\n        \nendmodule\n\n\n\nmodule rptr_empty #(\n    parameter ADDRSIZE = 2\n) (\n    output reg rempty,\n    output wire [ADDRSIZE-1:0] raddr,\n    output reg [ADDRSIZE :0] rptr,\n    input wire [ADDRSIZE :0] rq2_wptr,\n    input wire rinc, rclk, rrst\n);\n    \nreg [ADDRSIZE:0] rbin;\nwire [ADDRSIZE:0] rgraynext, rbinnext;\nalways @(posedge rclk)\n    if (rrst) {rbin, rptr} <= 0;\n    else {rbin, rptr} <= {rbinnext, rgraynext};\n    \nassign raddr = rbin[ADDRSIZE-1:0];\nassign rbinnext = rbin + (rinc & ~rempty);\nassign rgraynext = (rbinnext>>1) ^ rbinnext;\nwire rempty_val;\nassign rempty_val = (rgraynext == rq2_wptr);\nalways @(posedge rclk)\n    if (rrst) rempty <= 1'b1;\n    else rempty <= rempty_val;\n        \nendmodule\n\nmodule wptr_full #(\n    parameter ADDRSIZE = 2\n) (\n    output reg wfull,\n    output wire [ADDRSIZE-1:0] waddr,\n    output reg [ADDRSIZE :0] wptr,\n    input wire [ADDRSIZE :0] wq2_rptr,\n    input wire winc, wclk, wrst\n);\n\nreg [ADDRSIZE:0] wbin;\nwire [ADDRSIZE:0] wgraynext, wbinnext;\nalways @(posedge wclk)\n    if (wrst) {wbin, wptr} <= 0;\n    else {wbin, wptr} <= {wbinnext, wgraynext};\nassign waddr = wbin[ADDRSIZE-1:0];\nassign wbinnext = wbin + (winc & ~wfull);\nassign wgraynext = (wbinnext>>1) ^ wbinnext;\nwire wfull_val;\nassign wfull_val = (wgraynext=={~wq2_rptr[ADDRSIZE:ADDRSIZE-1], wq2_rptr[ADDRSIZE-2:0]});\nalways @(posedge wclk)\n    if (wrst) wfull <= 1'b0;\n    else wfull <= wfull_val;\n        \nendmodule\n\nmodule cdc_sync_r2w #(\n    parameter ADDRSIZE = 2\n) (\n    output reg [ADDRSIZE:0] wq2_rptr,\n    input wire [ADDRSIZE:0] rptr,\n    input wire wclk, wrst\n);\n\nreg [ADDRSIZE:0] cdc_sync_wq1_rptr;\nalways @(posedge wclk)\n    if (wrst) {wq2_rptr,cdc_sync_wq1_rptr} <= 0;\n    else {wq2_rptr,cdc_sync_wq1_rptr} <= {cdc_sync_wq1_rptr,rptr};\n        \nendmodule\n\nmodule cdc_sync_w2r #(\n    parameter ADDRSIZE = 2\n) (\n    output reg [ADDRSIZE:0] rq2_wptr,\n    input wire [ADDRSIZE:0] wptr,\n    input wire rclk, rrst\n);\n\nreg [ADDRSIZE:0] cdc_sync_rq1_wptr;\nalways @(posedge rclk)\n    if (rrst) {rq2_wptr,cdc_sync_rq1_wptr} <= 0;\n    else {rq2_wptr,cdc_sync_rq1_wptr} <= {cdc_sync_rq1_wptr,wptr};\n\nendmodule\n",
        "module_name": "cdc_syncfifo #",
        "module_hash": "07d30700f2236ef2da8af6008906eae4",
        "dataset_index": 23510
      },
      "tkg_c3_aa6cf913": {
        "rtl_code": "module tkg_c3 (output o, input i0, i1, i2);\n\tC3 I0 (o, i0, i1, i2);\nendmodule\n\nmodule C3 (output o, input i0, i1, i2);\n\twire a, b, c, d, e;\n\t\n\tand (a, i0, i1);\n\tand (b, i0, i2);\n\tand (c, i1, i2);\n\tor (d, a, b);\n\tor (e, d, c);\n\t\n\tassign o = e;\nendmodule",
        "module_name": "tkg_c3",
        "module_hash": "aa6cf9134ff29c7fe7c15f2025df63f1",
        "dataset_index": 19789
      },
      "spi_84aa3f1c": {
        "rtl_code": "module spi (\n\t    input wire \t      clk,\n\t    input wire \t      resn,\n\t    input wire \t      trig,\n\t    output wire       done,\n\t    output reg [15:0] rdData,\n\t    input wire [15:0] wrData,\n\n\t    output reg \t      SCLK,\n\t    output reg \t      SS,\n\t    output reg \t      MOSI,\n\t    input wire \t      MISO\n\t    );\n   reg [3:0] \t\t      state;\n   reg [15:0] \t\t      bitCount;\n   reg [15:0] \t\t      clkCounter;\n\n   always @ (posedge clk) begin\n      clkCounter = clkCounter + 1;\n      if (clkCounter == 33) begin\n         SCLK <= !SCLK;\n      end\n   end\n\n   always @ (SCLK) begin\n      if (!resn) begin\n         SS <= 1;\n         MOSI <= 0;\n         state <= 0;\n         bitCount <= 0;\n      end else begin\n         case (state)\n           0: begin\n              if (trig) begin\n                 if (SCLK == 0) begin\n                    SS <= 0;\n                    state <= 1;\n                    bitCount <= 15;\n                 end\n              end\n           end\n\n           1: begin\n              if (SCLK == 0) begin\n                 MOSI <= wrData[bitCount];\n                 bitCount <= bitCount - 1;\n                 if (bitCount == 0) begin\n                    state <= 2;\n                 end\n              end else begin\n                 rdData[bitCount] <= MISO;\n              end\n           end\n\n           2: begin\n              if (SCLK == 1) begin\n                 SS <= 1;\n                 MOSI <= 0;\n                 state <= 0;\n                 bitCount <= 0;\n              end\n           end\n\n           default: ;\n         endcase\n      end\n   end\n\n   assign done = SS;\nendmodule\n",
        "module_name": "spi",
        "module_hash": "84aa3f1ce720381622c7fa1a3509c092",
        "dataset_index": 16979
      },
      "fir_mul_32s_32s_3bkb_MulnS_0_20d32a81": {
        "rtl_code": "module fir_mul_32s_32s_3bkb_MulnS_0 (\n    clk,\n    reset,\n    ce,\n    a,\n    b,\n    p\n);\n\nparameter WIDTH = 32;\n\ninput clk;\ninput reset;\ninput ce;\ninput signed [WIDTH-1:0] a;\ninput signed [WIDTH-1:0] b;\noutput signed [WIDTH-1:0] p;\n\nreg signed [WIDTH-1:0] a_reg;\nreg signed [WIDTH-1:0] b_reg;\nreg signed [WIDTH-1:0] p_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        a_reg <= 0;\n        b_reg <= 0;\n        p_reg <= 0;\n    end else if (ce) begin\n        a_reg <= a;\n        b_reg <= b;\n        p_reg <= a_reg * b_reg;\n    end\nend\n\nassign p = p_reg;\n\nendmodule",
        "module_name": "fir_mul_32s_32s_3bkb_MulnS_0",
        "module_hash": "20d32a81c5e9c2de06c407c58098ff10",
        "dataset_index": 11287
      },
      "db_sao_cal_diff_6140d763": {
        "rtl_code": "module db_sao_cal_diff(\n                   dp_i          ,\n                   op_i          , \n\t\t\t\t   data_valid_i  ,\n                   ominusdp_o    ,\n\t\t\t\t   index_o\n                ); \ninput           [  7:0 ]       dp_i              ;\ninput           [  7:0 ]       op_i              ;\ninput                          data_valid_i      ;\noutput          [287:0 ]       ominusdp_o        ;\noutput          [ 31:0 ]       index_o           ;\n\nwire  signed    [  8:0 ]       ominusdp_w        ;\nreg             [287:0 ]       ominusdp_t        ;\n\nreg             [ 31:0]        index_r           ;\n\nassign          ominusdp_w   =    op_i  -  dp_i  ;\n\n\nalways @* begin \n    case(dp_i[7:3])\n        5'd0 : begin ominusdp_t  = {279'b0,ominusdp_w       }; index_r = 32'b00000000000000000000000000000001 ; end \n        5'd1 : begin ominusdp_t  = {270'b0,ominusdp_w,  9'd0}; index_r = 32'b00000000000000000000000000000010 ; end \n        5'd2 : begin ominusdp_t  = {261'b0,ominusdp_w, 18'd0}; index_r = 32'b00000000000000000000000000000100 ; end \n        5'd3 : begin ominusdp_t  = {252'b0,ominusdp_w, 27'd0}; index_r = 32'b00000000000000000000000000001000 ; end \n        5'd4 : begin ominusdp_t  = {243'b0,ominusdp_w, 36'd0}; index_r = 32'b00000000000000000000000000010000 ; end \n        5'd5 : begin ominusdp_t  = {234'b0,ominusdp_w, 45'd0}; index_r = 32'b00000000000000000000000000100000 ; end \n        5'd6 : begin ominusdp_t  = {225'b0,ominusdp_w, 54'd0}; index_r = 32'b00000000000000000000000001000000 ; end \n        5'd7 : begin ominusdp_t  = {216'b0,ominusdp_w, 63'd0}; index_r = 32'b00000000000000000000000010000000 ; end \n        5'd8 : begin ominusdp_t  = {207'b0,ominusdp_w, 72'd0}; index_r = 32'b00000000000000000000000100000000 ; end \n        5'd9 : begin ominusdp_t  = {198'b0,ominusdp_w, 81'd0}; index_r = 32'b00000000000000000000001000000000 ; end \n\t\t5'd10: begin ominusdp_t  = {189'b0,ominusdp_w, 90'd0}; index_r = 32'b00000000000000000000010000000000 ; end \n\t\t5'd11: begin ominusdp_t  = {180'b0,ominusdp_w, 99'd0}; index_r = 32'b00000000000000000000100000000000 ; end \n\t\t5'd12: begin ominusdp_t  = {171'b0,ominusdp_w,108'd0}; index_r = 32'b00000000000000000001000000000000 ; end \n\t\t5'd13: begin ominusdp_t  = {162'b0,ominusdp_w,117'd0}; index_r = 32'b00000000000000000010000000000000 ; end \n\t\t5'd14: begin ominusdp_t  = {153'b0,ominusdp_w,126'd0}; index_r = 32'b00000000000000000100000000000000 ; end \n\t\t5'd15: begin ominusdp_t  = {144'b0,ominusdp_w,135'd0}; index_r = 32'b00000000000000001000000000000000 ; end \n\t\t5'd16: begin ominusdp_t  = {135'b0,ominusdp_w,144'd0}; index_r = 32'b00000000000000010000000000000000 ; end \n\t\t5'd17: begin ominusdp_t  = {126'b0,ominusdp_w,153'd0}; index_r = 32'b00000000000000100000000000000000 ; end \n\t\t5'd18: begin ominusdp_t  = {117'b0,ominusdp_w,162'd0}; index_r = 32'b00000000000001000000000000000000 ; end \n\t\t5'd19: begin ominusdp_t  = {108'b0,ominusdp_w,171'd0}; index_r = 32'b00000000000010000000000000000000 ; end \n\t\t5'd20: begin ominusdp_t  = { 99'b0,ominusdp_w,180'd0}; index_r = 32'b00000000000100000000000000000000 ; end \n\t\t5'd21: begin ominusdp_t  = { 90'b0,ominusdp_w,189'd0}; index_r = 32'b00000000001000000000000000000000 ; end \n\t\t5'd22: begin ominusdp_t  = { 81'b0,ominusdp_w,198'd0}; index_r = 32'b00000000010000000000000000000000 ; end \n\t\t5'd23: begin ominusdp_t  = { 72'b0,ominusdp_w,207'd0}; index_r = 32'b00000000100000000000000000000000 ; end \n\t\t5'd24: begin ominusdp_t  = { 63'b0,ominusdp_w,216'd0}; index_r = 32'b00000001000000000000000000000000 ; end \n\t\t5'd25: begin ominusdp_t  = { 54'b0,ominusdp_w,225'd0}; index_r = 32'b00000010000000000000000000000000 ; end \n\t\t5'd26: begin ominusdp_t  = { 45'b0,ominusdp_w,234'd0}; index_r = 32'b00000100000000000000000000000000 ; end \n\t\t5'd27: begin ominusdp_t  = { 36'b0,ominusdp_w,243'd0}; index_r = 32'b00001000000000000000000000000000 ; end \n\t\t5'd28: begin ominusdp_t  = { 27'b0,ominusdp_w,252'd0}; index_r = 32'b00010000000000000000000000000000 ; end \n\t\t5'd29: begin ominusdp_t  = { 18'b0,ominusdp_w,261'd0}; index_r = 32'b00100000000000000000000000000000 ; end \n\t\t5'd30: begin ominusdp_t  = {  9'b0,ominusdp_w,270'd0}; index_r = 32'b01000000000000000000000000000000 ; end \n\t\t5'd31: begin ominusdp_t  = {       ominusdp_w,279'd0}; index_r = 32'b10000000000000000000000000000000 ; end \n    endcase \nend \n\nassign   ominusdp_o = data_valid_i ? 287'd0 : ominusdp_t;\nassign   index_o    = data_valid_i ? 32'd0  : index_r   ;\n\n\nendmodule \n",
        "module_name": "db_sao_cal_diff",
        "module_hash": "6140d763c84a502977b76962744dcf52",
        "dataset_index": 17904
      },
      "add16_41048f84": {
        "rtl_code": "\nmodule add16(\n    input [15:0] a,   // First 16-bit input\n    input [15:0] b,   // Second 16-bit input\n    output [15:0] sum // 16-bit output sum\n);\n\n    assign sum = a + b;   // Add the two inputs and assign the result to the output\n\nendmodule\nmodule top_module(\n    input [31:0] a,       // First 32-bit input\n    input [31:0] b,       // Second 32-bit input\n    input [1:0] select,   // Select input to choose between inputs\n    input clk,            // Clock input\n    output [31:0] sum     // 32-bit output sum\n);\n\n    wire [15:0] adder1_out, adder2_out;  // Intermediate outputs of the 16-bit adders\n    wire [31:0] mux_out;                                        // Output of the 2:1 multiplexer\n\n    // Instantiate two 16-bit adders\n    add16 adder1(.a(a[15:0]), .b(b[15:0]), .sum(adder1_out));\n    add16 adder2(.a(a[31:16]), .b(b[31:16]), .sum(adder2_out));\n\n    // Implement the 2:1 multiplexer using combinational logic\n    assign mux_out = (select == 2'b0) ? a[31:0] : b[31:0];\n\n    // Combine the outputs of the adders and the multiplexer to get the final output\n    assign sum = {adder2_out, adder1_out} + mux_out;\n\nendmodule",
        "module_name": "add16",
        "module_hash": "41048f84682d55506f86716006bdece9",
        "dataset_index": 21377
      },
      "sync_resettable_latch_780956c4": {
        "rtl_code": "\nmodule sync_resettable_latch(\n    input [3:0] D,\n    input EN,\n    input RST,\n    input CLK,\n    output reg [3:0] Q\n);\n\nalways @(posedge CLK) begin\n    if (EN) begin\n        Q <= D;\n    end else if (RST) begin\n        Q <= 4'b0;\n    end\nend\n\nendmodule",
        "module_name": "sync_resettable_latch",
        "module_hash": "780956c4d35a23653536857ba05fa862",
        "dataset_index": 13226
      },
      "simple_calculator_083cfdb5": {
        "rtl_code": "\nmodule simple_calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    input clk,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: out = a + b;\n        2'b01: out = a - b;\n        2'b10: out = a & b;\n        2'b11: out = a | b;\n    endcase\nend\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "083cfdb50b51462ef0826118c7a90931",
        "dataset_index": 4230
      },
      "three_input__64e58e80": {
        "rtl_code": "module three_input_module (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire C1;\n    wire C2;\n\n    assign C1 = (A1 & A2) ? ~B1 : (A1 | A2);\n    assign C2 = (A1 & A2) ? C1 : B1;\n    assign X = (A1 & A2) ? C2 : (A1 & ~A2) ? ~B1 : (A1 | A2) ? B1 : 0;\n\nendmodule",
        "module_name": "three_input_",
        "module_hash": "64e58e80bea3e0677296ad447ff157a4",
        "dataset_index": 9215
      },
      "Cfu_5106013a": {
        "rtl_code": "module Cfu (\n  input               cmd_valid,\n  output              cmd_ready,\n  input      [9:0]    cmd_payload_function_id,\n  input      [31:0]   cmd_payload_inputs_0,\n  input      [31:0]   cmd_payload_inputs_1,\n  output              rsp_valid,\n  input               rsp_ready,\n  output     [31:0]   rsp_payload_outputs_0,\n  input               reset,\n  input               clk\n);\n\n  assign rsp_valid = cmd_valid;\n  assign cmd_ready = rsp_ready;\n\n  assign rsp_payload_outputs_0 = cmd_payload_function_id[0] ? \n                                           cmd_payload_inputs_1 :\n                                           cmd_payload_inputs_0 ;\n\n\nendmodule\n",
        "module_name": "Cfu",
        "module_hash": "5106013a9de98e073503d1f0bac98afd",
        "dataset_index": 1508
      },
      "four_bit_adder_751539f8": {
        "rtl_code": "\nmodule four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] s,\n    output cout\n);\n\n    wire [3:0] sum;\n    wire cout0, cout1, cout2;\n    \n    // full adder for least significant bit\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .s(sum[0]),\n        .cout(cout0)\n    );\n    \n    // full adder for second least significant bit\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(cout0),\n        .s(sum[1]),\n        .cout(cout1)\n    );\n    \n    // full adder for third least significant bit\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(cout1),\n        .s(sum[2]),\n        .cout(cout2)\n    );\n    \n    // full adder for most significant bit\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(cout2),\n        .s(sum[3]),\n        .cout(cout)\n    );\n    \n    assign s = sum;\n\nendmodule\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output s,\n    output cout\n);\n\n    wire sum1, sum2, sum3;\n    \n    // XOR gates to calculate sum\n    assign sum1 = a ^ b;\n    assign s = sum1 ^ cin;\n    \n    // AND gates to calculate carry out\n    assign sum2 = a & b;\n    assign sum3 = cin & sum1;\n    assign cout = sum2 | sum3;\n    \nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "751539f8d753335c608a270570722afe",
        "dataset_index": 7070
      },
      "top__6326cc3e": {
        "rtl_code": "\nmodule top_module (\n    input [31:0] a, // 32-bit input for adder\n    input [31:0] b, // 32-bit input for adder\n    input select, // Select input to choose between decoder and functional module\n    output [7:0] out // 8-bit output from the active module\n);\n\n    wire [31:0] sum; // 32-bit sum output from the adder\n    wire [7:0] upper_byte; // 8-bit upper byte output from the decoder\n    wire [7:0] lower_byte; // 8-bit lower byte output from the decoder\n    wire [7:0] product; // 8-bit product output from the functional module\n\n    carry_select_adder adder(.a(a), .b(b), .sum(sum)); // Instantiate the carry select adder module\n    decoder_mux_16bit decoder(.in(sum[15:0]), .upper_byte(upper_byte), .lower_byte(lower_byte)); // Instantiate the decoder and multiplexer module\n    functional_module func(.a(upper_byte), .b(lower_byte), .out(product)); // Instantiate the functional module\n\n    assign out = select ? product : {upper_byte, lower_byte}; // Multiplexer to select between decoder and functional module based on select input\n\nendmodule\nmodule carry_select_adder (\n    input [31:0] a, // 32-bit input A\n    input [31:0] b, // 32-bit input B\n    output [31:0] sum // 32-bit sum output\n);\n\n    wire [15:0] sum_low, sum_high; // 16-bit lower and upper parts of the sum\n    wire carry_out_low, carry_out_high; // Carry outputs from the lower and upper adders\n\n    ripple_adder adder_low(.a(a[15:0]), .b(b[15:0]), .sum(sum_low), .carry_out(carry_out_low)); // Lower 16-bit adder\n    ripple_adder adder_high(.a(a[31:16]), .b(b[31:16]), .sum(sum_high), .carry_out(carry_out_high)); // Upper 16-bit adder\n\n    assign sum[15:0] = carry_out_low ? sum_high : sum_low; // Select the correct lower 16 bits of the sum\n    assign sum[31:16] = carry_out_high ? sum_high + 1 : sum_high; // Select the correct upper 16 bits of the sum\n\nendmodule\nmodule ripple_adder (\n    input [15:0] a, // 16-bit input A\n    input [15:0] b, // 16-bit input B\n    output [15:0] sum, // 16-bit sum output\n    output carry_out // Carry output\n);\n\n    assign {carry_out, sum} = a + b;\n\nendmodule\nmodule decoder_mux_16bit (\n    input [15:0] in, // 16-bit input\n    output [7:0] upper_byte, // 8-bit upper byte output\n    output [7:0] lower_byte // 8-bit lower byte output\n);\n\n    assign upper_byte = in[15:8];\n    assign lower_byte = in[7:0];\n\nendmodule\nmodule functional_module (\n    input [7:0] a, // 8-bit input A\n    input [7:0] b, // 8-bit input B\n    output [7:0] out // 8-bit product output\n);\n\n    assign out = a * b;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "6326cc3e9ff6f4bc7a0be890057d9833",
        "dataset_index": 20666
      },
      "dff_async_reset_edb6119f": {
        "rtl_code": "module dff_async_reset (\n  input clk,\n  input reset,\n  input d,\n  output reg q\n);\n\n  always @(posedge clk) begin\n    if (reset == 1'b0) begin\n      q <= 1'b0;\n    end else begin\n      q <= d;\n    end\n  end\n\nendmodule",
        "module_name": "dff_async_reset",
        "module_hash": "edb6119f5ee3c6e5681b6c2f61f5f07a",
        "dataset_index": 12029
      },
      "restoring_division_16bit_67383084": {
        "rtl_code": "\nmodule restoring_division_16bit (\n    input signed [15:0] dividend,\n    input signed [15:0] divisor,\n    output reg signed [15:0] quotient,\n    output reg signed [15:0] remainder\n);\n\nreg signed [15:0] remainder_reg;\nreg signed [15:0] divisor_reg;\nreg signed [15:0] quotient_reg;\nreg signed [15:0] dividend_reg;\nreg [4:0] count;\n\nalways @(*) begin\n    count = 0;\n    remainder_reg = dividend;\n    divisor_reg = divisor;\n    quotient_reg = 0;\n    dividend_reg = dividend;\n\n    if (dividend[15] == 1) begin\n        remainder_reg = -dividend;\n        dividend_reg = -dividend;\n    end\n\n    if (divisor[15] == 1) begin\n        divisor_reg = -divisor;\n    end\n\n    for (count = 0; count < 16; count = count + 1) begin\n        remainder_reg = remainder_reg << 1;\n        quotient_reg = quotient_reg << 1;\n        remainder_reg[0] = dividend_reg[15];\n        dividend_reg = dividend_reg << 1;\n\n        remainder_reg = remainder_reg - divisor_reg;\n\n        if (remainder_reg[15] == 1) begin\n            remainder_reg = remainder_reg + divisor_reg;\n        end else begin\n            quotient_reg[0] = 1;\n        end\n\n        count = count + 1;\n    end\n\n    if (dividend[15] == 1 && divisor[15] == 1) begin\n        quotient = quotient_reg;\n        remainder = -remainder_reg;\n    end else if (dividend[15] == 1 || divisor[15] == 1) begin\n        quotient = -quotient_reg;\n        remainder = remainder_reg;\n    end else begin\n        quotient = quotient_reg;\n        remainder = remainder_reg;\n    end\nend\n\nendmodule",
        "module_name": "restoring_division_16bit",
        "module_hash": "673830844f0865c25a06ad260414a389",
        "dataset_index": 1581
      },
      "shift_register_3f531c75": {
        "rtl_code": "module shift_register (\n  input clk,\n  input load,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\n  reg [3:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (load) begin\n      shift_reg <= data_in;\n    end else begin\n      shift_reg <= {shift_reg[2:0], shift_reg[3]};\n    end\n  end\n\n  assign data_out = shift_reg;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "3f531c7518a5e93aa5014821f6f2a9e0",
        "dataset_index": 16054
      },
      "adder4_8ccc56fe": {
        "rtl_code": "module adder4 (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire [3:1] carry;\n\n    // Full adder for bit 0\n    full_adder FA0(A[0], B[0], Cin, sum[0], carry[1]);\n\n    // Full adder for bit 1\n    full_adder FA1(A[1], B[1], carry[1], sum[1], carry[2]);\n\n    // Full adder for bit 2\n    full_adder FA2(A[2], B[2], carry[2], sum[2], carry[3]);\n\n    // Full adder for bit 3\n    full_adder FA3(A[3], B[3], carry[3], sum[3], Cout);\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule",
        "module_name": "adder4",
        "module_hash": "8ccc56feda3cbd356e1ce51de5c129d8",
        "dataset_index": 4161
      },
      "jt12_dac2 #_45f57fbb": {
        "rtl_code": "\n\n\n\nmodule jt12_dac2 #(parameter width=12)\n(\n\tinput\tclk,\n    input\trst,\n    input\tsigned [width-1:0] din,\n    output\treg dout\n);\n\nlocalparam int_w = width+5;\n\nreg [int_w-1:0] y, error, error_1, error_2;\n\nwire [width-1:0] undin = { ~din[width-1], din[width-2:0] };\n\nalways @(*) begin\n\ty = undin + { error_1, 1'b0} - error_2;\n\tdout = ~y[int_w-1];\n\terror = y - {dout, {width{1'b0}}};\nend\n\nalways @(posedge clk)\n\tif( rst ) begin\n\t\terror_1 <= {int_w{1'b0}};\n\t\terror_2 <= {int_w{1'b0}};\n\tend else begin\n\t\terror_1 <= error;\n\t\terror_2 <= error_1;\n\tend\n\nendmodule\n",
        "module_name": "jt12_dac2 #",
        "module_hash": "45f57fbbe0e165577214aa9ebdd0f38a",
        "dataset_index": 8415
      },
      "clock_gate_65bde813": {
        "rtl_code": "module clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  always @(posedge CLK) begin\n    if (EN == 1'b0) begin\n      ENCLK <= 1'b0;\n    end else begin\n      if (TE == 1'b1) begin\n        ENCLK <= CLK;\n      end else begin\n        ENCLK <= 1'b0;\n      end\n    end\n  end\n  \nendmodule",
        "module_name": "clock_gate",
        "module_hash": "65bde813ed2191ef83d9a7adfb0b192e",
        "dataset_index": 16210
      },
      "buf_interm_disable_77f1d0c6": {
        "rtl_code": "module buf_interm_disable(\n    input I,\n    input IBUFDISABLE,\n    input INTERMDISABLE,\n    output O\n);\n\n    parameter IBUF_LOW_PWR = \"TRUE\";\n    parameter IOSTANDARD = \"DEFAULT\";\n    parameter SIM_DEVICE = \"7SERIES\";\n    parameter USE_IBUFDISABLE = \"TRUE\";\n\n    wire out_val;\n\n    assign out_val = (SIM_DEVICE == \"7SERIES\") ? 1'b1 : 1'b0;\n\n    assign O = (USE_IBUFDISABLE == \"TRUE\") ? \n        ((IBUFDISABLE == 0) ? I : ((IBUFDISABLE == 1) ? out_val : 1'bx)) : I;\n\nendmodule",
        "module_name": "buf_interm_disable",
        "module_hash": "77f1d0c66fbd4aca0c672d13f7d8934e",
        "dataset_index": 20766
      },
      "encode_ctl_6756a0cd": {
        "rtl_code": "\nmodule encode_ctl(\n   hraddr, cnt_output_enable, cnt_len, cnt_output,\n   cnt_finish,\n   clk, rst, data_valid, data_empty, hash_data, hash_data1,\n   data_d1, data_d2, hash_ref, iidx, hdata, data, hash_d1,\n   hash_data_d1\n   );\n   parameter LZF_WIDTH = 20;\n\n   input     clk, rst;\n   input     data_valid;\n   input     data_empty;\n   \n   input [7:0] hash_data, hash_data1, data_d1, data_d2;\n   input [LZF_WIDTH-1:0] hash_ref, iidx;\n   \n   input [7:0] \t\t hdata, data, hash_d1;\n   output [10:0] \t hraddr;\n   input \t\t hash_data_d1;\n   \n   \n\n   reg \t\t\toff_valid;\n   reg \t\t\tiidx_window;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  iidx_window <= #1 0;\n\telse if (iidx[11]) \n\t  iidx_window <= #1 1;\n     end\n   \n   reg [LZF_WIDTH-1:0] \tmin_off, max_off;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  min_off <= #1 0;\n\telse if (data_valid && iidx_window)\n\t  min_off <= #1 min_off + 1;\n     end\n\n   always @(posedge clk)\n     begin\n\tif (data_valid)\n\t  max_off <= #1 iidx;\n     end\n   \n   always @(hash_ref or max_off or min_off)\n     begin\n\tif (hash_ref > min_off && hash_ref < max_off)\n\t  off_valid = 1;\n\telse\n\t  off_valid = 0;\n     end\n\n   reg [10:0] off;\n   always @(hash_ref or max_off)\n     begin\n\toff = max_off - hash_ref;\n     end\n   \n   parameter [2:0]\n\t\tS_IDLE   = 3'h0,\n\t\tS_SEARCH = 3'h1,\n\t\tS_TR     = 3'h2,\n\t\tS_MATCH  = 3'h3,\n\t\tS_DELAY  = 3'h4,\n\t\tS_END    = 3'h5,\n\t\tS_DONE   = 3'h6,\n\t\tS_STOP   = 3'h7;\n\n   reg [2:0] \t  state, state_next;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  state <= #1 S_IDLE;\n\telse\n\t  state <= #1 state_next;\n     end\n\n   reg [3:0] cnt, cnt_next;\n   always @(posedge clk)\n     begin\n\t  cnt <= #1 cnt_next;\n     end\n\n   reg cnt_count, cnt_load;\n   reg rallow;\n   reg [10:0] raddr_plus_one;\n   reg [10:0] raddr_reg;\n   \n   assign hraddr = rallow ? raddr_plus_one : raddr_reg;\n   \n   always @(cnt_count or cnt_load)\n     begin\n\tif (cnt_load || cnt_count)\n\t  rallow = 1;\n\telse\n\t  rallow = 0;\n     end\n\n   reg [LZF_WIDTH-1:0] hash_ref_plus_one;\n   always @(hash_ref)\n     hash_ref_plus_one = hash_ref + 1'b1;\n   \n   always @(posedge clk)\n     begin\n\tif (cnt_load)\n\t  raddr_plus_one <= #1 hash_ref_plus_one + 1'b1;\n\telse if (cnt_count)\n\t  raddr_plus_one <= #1 raddr_plus_one + 1'b1;\n     end\n\n   always @(posedge clk)\n     begin\n\tif (cnt_load)\n\t  raddr_reg <= #1 hash_ref_plus_one;\n\telse if (cnt_count)\n\t  raddr_reg <= #1 raddr_plus_one;\n     end\n   \n   reg cnt_big7, cnt_big7_next;\n   always @(posedge clk)\n     begin\n\t  cnt_big7 <= #1 cnt_big7_next;\n     end\n   \n\n   always @(cnt or cnt_big7 or cnt_count or cnt_load)\n     begin\n\tcnt_next = 0;\n\tcnt_big7_next = 0;\n\t\n\tif (cnt_load) begin\n\t   cnt_next = 2;\n\t   cnt_big7_next = 0;\n\tend else if (cnt_count) begin\n\t   cnt_next = cnt + 1;\n\t   if (cnt_big7 == 0) begin\n\t      if (cnt == 4'h7) begin\n\t\t cnt_big7_next = 1;\n\t\t cnt_next = 0;\n\t      end else\n\t\tcnt_big7_next = 0;\n\t   end else begin\n\t      cnt_big7_next = 1;\n\t   end\n\t   if (cnt == 4'hf)\n\t     cnt_next = 1;\n\tend else begin\n\t   cnt_next = cnt;\n\t   cnt_big7_next = cnt_big7;\n\tend\n     end output cnt_output_enable;\n   output [3:0] cnt_len;\n   output [12:0] cnt_output;\n   output \t cnt_finish;\n\n   reg [2:0] \t dummy_cnt;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  dummy_cnt <= #1 0;\n\telse if (state == S_DONE)\n\t  dummy_cnt <= #1 dummy_cnt + 1'b1;\n     end\n   \n   reg \t\t cnt_finish;\n   reg \t\t cnt_output_enable, cnt_output_enable_next;\n   reg [12:0] \t cnt_output, cnt_output_next;\n   reg [3:0] \t cnt_len, cnt_len_next;\n   \n   always @(cnt or cnt_big7 or data_d1 or data_d2\n\t    or data_empty or data_valid or dummy_cnt\n\t    or hash_data or hash_data_d1 or hdata\n\t    or off_valid or state)\n     begin\n\tstate_next = S_IDLE;         cnt_output_enable_next = 0;  cnt_load = 0;\n\tcnt_count = 0;\n\n\tcase (state)\n\t  S_IDLE: begin\n\t     if (data_valid) \n\t       state_next = S_DELAY;\n\t     else\n\t       state_next = S_IDLE;\n\t  end\n\n\t  S_DELAY: begin\n\t     if (data_valid) \n\t       state_next = S_SEARCH;\n\t     else\n\t       state_next = S_DELAY;\n\t  end\n\t  \n\t  S_SEARCH: begin \n\t     if (data_valid) begin\n\t\tif (data_d2 == hash_data && off_valid) begin\n\t\t   state_next = S_TR;\n\t\t   cnt_load = 1;\n\t\t   cnt_output_enable_next = 1;\n\t\tend else begin\n\t\t   cnt_output_enable_next = 1;\n\t\t   state_next = S_SEARCH;\n\t\tend\n\t     end else if (data_empty) begin\n\t\tcnt_output_enable_next = 1;\n\t\tstate_next = S_END;\n\t     end else\n\t       state_next = S_SEARCH;\n\t  end S_TR: begin if (data_valid && hash_data_d1) begin\n\t\tcnt_count = 1;\n\t\tstate_next = S_MATCH;\n\t     end else if (data_valid) begin\n\t\tstate_next = S_SEARCH;\n\t\tcnt_output_enable_next = 1;\n\t     end else if (data_empty) begin\n\t\tcnt_output_enable_next = 1;\n\t\tstate_next = S_END;\n\t     end else begin\n\t\tstate_next = S_TR;\n\t     end\n\t  end\n\t  \n\t  S_MATCH: begin \n\t     if (data_valid) begin\n\t\tif (data_d1 == hdata) begin\n\t\t   state_next = S_MATCH;\n\t\t   cnt_count = 1;\n\t\t   if (cnt == 4'h7 && cnt_big7 == 0)\n\t\t     cnt_output_enable_next = 1;\n\t\t   else if (cnt == 4'hf)\n\t\t     cnt_output_enable_next = 1;\n\t\tend else begin state_next = S_SEARCH;\n\t\t   cnt_output_enable_next = 1;\n\t\tend\n\t     end else if (data_empty) begin state_next = S_END;\n\t\tcnt_output_enable_next = 1;\n\t     end else \n\t\tstate_next = S_MATCH;\n\t  end S_END: begin \n\t     state_next = S_DONE;\n\t     cnt_output_enable_next = 1;\n\t  end\n\n\t  S_DONE: begin \n\t     state_next = S_DONE;\n\t     cnt_output_enable_next = 1;\n\t     if (&dummy_cnt) \n\t       state_next = S_STOP;\n\t  end\n\n\t  S_STOP: begin\n\t     state_next = S_STOP;\n\t  end\n\tendcase end always @(posedge clk)\n     begin\n\tcnt_output <= #1 cnt_output_next;\n\tcnt_len    <= #1 cnt_len_next;\n     end\n   \n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  cnt_output_enable <= #1 0;\n\telse\n\t  cnt_output_enable <= #1 cnt_output_enable_next;\n     end\n\n   always @(state)\n     cnt_finish = state == S_STOP;\n   \n   \n   reg [3:0] encode_len_s;\n   reg [12:0] encode_data_s;\n   \n   reg [3:0]  encode_len_m;\n   reg [12:0] encode_data_m;\n   \n   reg [3:0]  encode_len;\n   reg [12:0] encode_data;\n   \n   always @(cnt_output_enable_next or encode_data_m\n\t    or encode_data_s or encode_len_m or encode_len_s\n\t    or state)\n     begin\n\tcnt_output_next = 0;\n\tcnt_len_next= 0;\n\t\n\tif (cnt_output_enable_next && state == S_SEARCH) begin\n\t   \n\t   cnt_output_next = encode_data_s;\n\t   cnt_len_next = encode_len_s;\n\tend else if (cnt_output_enable_next && state == S_END) begin\n\t   \n\t   cnt_output_next = 9'b110000000;\n\t   cnt_len_next    = 4'h9;\n\tend else if (cnt_output_enable_next && state == S_DONE) begin\n\t   \n\t   cnt_output_next = 9'b000000000;\n\t   cnt_len_next    = 4'hf;\n\tend else begin\n\t   cnt_output_next = encode_data_m;\n\t   cnt_len_next = encode_len_m;\n\tend\n     end always @(cnt or cnt_big7 or cnt_count\n\t    or encode_data or encode_len)\n     begin\n\tif (cnt_big7 == 0) begin\n\t   if (cnt_count) begin\n\t      encode_data_m = 4'hf;\n\t      encode_len_m = 4'h4;\n\t   end else begin\n\t      encode_data_m = encode_data;\n\t      encode_len_m = encode_len;\n\t   end\n\tend else begin\n\t   if (cnt == 4'hf && cnt_count == 0) begin\n\t      encode_data_m = {4'hf, 4'h0};\n\t      encode_len_m = 4'h8;\n\t   end else begin\n\t      encode_data_m = cnt;\n\t      encode_len_m = 4'h4;\n\t   end\n\tend end\n   \n   always @(cnt_load or data_d2 or off)\n     begin\n\tencode_len_s = 0;\n\tencode_data_s = 0;\n\n\tif (cnt_load) begin \n\t   if (off[10:07] == 0) begin \n\t      encode_len_s = 4'h9;\n\t      encode_data_s = {2'b11, off[6:0]};\n\t   end else begin\n\t      encode_len_s = 4'hd;\n\t      encode_data_s = {2'b10, off[10:0]};\n\t   end\n\tend else begin\n\t   encode_len_s = 4'h9;\n\t   encode_data_s = data_d2;\n\tend end\n   \n   always @(cnt)\n     begin\n\tencode_len = 0;\n\tencode_data = 0;\n\t\n\tcase (cnt[2:0])\n\t  3'h2: {encode_data, encode_len} = {2'b00, 4'h2};\n\t  3'h3: {encode_data, encode_len} = {2'b01, 4'h2};\n\t  3'h4: {encode_data, encode_len} = {2'b10, 4'h2};\n\t  3'h5: {encode_data, encode_len} = {2'b11, 2'b00, 4'h4};\n\t  3'h6: {encode_data, encode_len} = {2'b11, 2'b01, 4'h4};\n\t  3'h7: {encode_data, encode_len} = {2'b11, 2'b10, 4'h4};\n\tendcase\n     end \nendmodule ",
        "module_name": "encode_ctl",
        "module_hash": "6756a0cda29b7a336b490ccd5716b370",
        "dataset_index": 1486
      },
      "filter_310c3864": {
        "rtl_code": "module filter(\n    input clk, resetn, din_valid,\n    input [7:0] din00, din01, din02,\n    input [7:0] din10, din11, din12,\n    input [7:0] din20, din21, din22,\n    output reg [7:0] dout,\n    output reg dout_valid\n    );\n\n    reg [7:0] sum;\n    reg [3:0] count;\n    \n    always @(posedge clk, negedge resetn) begin\n        if (!resetn) begin\n            dout_valid <= 0;\n            dout <= 0;\n            sum <= 0;\n            count <= 0;\n        end else begin\n            if (din_valid) begin\n                sum <= din00 + din01 + din02 + din10 + din11 + din12 + din20 + din21 + din22;\n                count <= 9;\n                dout <= sum / count;\n                dout_valid <= 1;\n            end else begin\n                dout_valid <= 0;\n                dout <= 0;\n                sum <= 0;\n                count <= 0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "filter",
        "module_hash": "310c386408a6b2ef0cd1612c5f6ef29e",
        "dataset_index": 13829
      },
      "shift_register_145960f2": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] d, // Input for the shift register\n    output [7:0] q // Output of the shift register\n);\n\n    reg [7:0] shift_reg = 0; // 8-bit shift register\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            shift_reg <= 8'b0;\n        end else begin\n            shift_reg <= {shift_reg[6:0], d[0]};\n        end\n    end\n\n    assign q = shift_reg;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "145960f272ca2fe08c9cb2dc81365b79",
        "dataset_index": 20003
      },
      "dff_mux_1a0c6fd0": {
        "rtl_code": "\nmodule dff_mux (\n    input clk,\n    input [7:0] d,\n    input [2:0] sel,\n    output reg [7:0] q\n);\n\nreg [7:0] q_int;\nreg [7:0] d_int;\n\nalways @(posedge clk) begin\n    q_int <= d_int;\n    d_int <= d;\nend\n\nalways @(*) begin\n    case (sel)\n        3'b000: q = q_int[7];\n        3'b001: q = q_int[6];\n        3'b010: q = q_int[5];\n        3'b011: q = q_int[4];\n        3'b100: q = q_int[3];\n        3'b101: q = q_int[2];\n        3'b110: q = q_int[1];\n        3'b111: q = q_int[0];\n    endcase\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nwire [2:0] sel;\nreg [7:0] d_int;\n\ndff_mux mux_inst (\n    .clk(clk),\n    .d(d_int),\n    .sel(sel),\n    .q(q)\n);\n\nassign sel[2:0] = d[2:0]; \n\nalways @(posedge clk) begin\n    d_int <= d;\nend\n\nendmodule",
        "module_name": "dff_mux",
        "module_hash": "1a0c6fd0400b78b48324146809ace8cc",
        "dataset_index": 20223
      },
      "sp_mux_5to1_sel3_4_1 #_b394c031": {
        "rtl_code": "\n\nmodule sp_mux_5to1_sel3_4_1 #(\nparameter\n    ID                = 0,\n    NUM_STAGE         = 1,\n    din1_WIDTH       = 32,\n    din2_WIDTH       = 32,\n    din3_WIDTH       = 32,\n    din4_WIDTH       = 32,\n    din5_WIDTH       = 32,\n    din6_WIDTH         = 32,\n    dout_WIDTH            = 32\n)(\n    input  [3 : 0]     din1,\n    input  [3 : 0]     din2,\n    input  [3 : 0]     din3,\n    input  [3 : 0]     din4,\n    input  [3 : 0]     din5,\n    input  [2 : 0]    din6,\n    output [3 : 0]   dout);\n\nwire [2 : 0]     sel;\nwire [3 : 0]         mux_1_0;\nwire [3 : 0]         mux_1_1;\nwire [3 : 0]         mux_1_2;\nwire [3 : 0]         mux_2_0;\nwire [3 : 0]         mux_2_1;\nwire [3 : 0]         mux_3_0;\n\nassign sel = din6;\n\nassign mux_1_0 = (sel[0] == 0)? din1 : din2;\nassign mux_1_1 = (sel[0] == 0)? din3 : din4;\nassign mux_1_2 = din5;\n\nassign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;\nassign mux_2_1 = mux_1_2;\n\nassign mux_3_0 = (sel[2] == 0)? mux_2_0 : mux_2_1;\n\nassign dout = mux_3_0;\n\nendmodule\n",
        "module_name": "sp_mux_5to1_sel3_4_1 #",
        "module_hash": "b394c03104bfec1485397ad809c07286",
        "dataset_index": 19273
      },
      "shift_reg_LED_ed774dce": {
        "rtl_code": "module shift_reg_LED (\n    input clk,\n    input [7:0] data,\n    output reg [2:0] LED\n);\n\nreg [7:0] shift_reg;\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[6:0], data};\n    counter <= counter + 1;\n    if (counter == 7) begin\n        counter <= 0;\n        LED <= {shift_reg[7], shift_reg[3], shift_reg[0]};\n    end\nend\n\nendmodule",
        "module_name": "shift_reg_LED",
        "module_hash": "ed774dce49ea0293c760f8597fbfbe07",
        "dataset_index": 9486
      },
      "multiplier_1d7ab242": {
        "rtl_code": "module multiplier(\n    input clk,\n    input [12:0] A,\n    input [12:0] B,\n    output [26:0] Y,\n    output [26:0] Z\n);\n\nreg [25:0] Y_reg;\nreg [25:0] Z_reg;\nreg [12:0] A_reg;\nreg [12:0] B_reg;\nreg [10:0] i;\n\nalways @(posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    if(i == 0) begin\n        Y_reg <= 0;\n        Z_reg <= 0;\n    end\n    else begin\n        if(B_reg[0] == 1) begin\n            Y_reg <= Y_reg + (A_reg << (i-1));\n            Z_reg <= Z_reg + ((~A_reg + 1) << (i-1));\n        end\n    end\n    i <= i + 1;\nend\n\nassign Y = Y_reg;\nassign Z = Z_reg;\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "1d7ab2423a8f1f7840e9933e95e73c0e",
        "dataset_index": 18273
      },
      "excess_3_converter_fe8e1758": {
        "rtl_code": "module excess_3_converter (\n    input [3:0] binary,\n    output reg [7:0] excess_3\n);\n\nalways @(*) begin\n    case (binary)\n        4'd0: excess_3 = 8'b0011_0011;\n        4'd1: excess_3 = 8'b0011_0100;\n        4'd2: excess_3 = 8'b0011_0101;\n        4'd3: excess_3 = 8'b0011_0110;\n        4'd4: excess_3 = 8'b0011_0111;\n        4'd5: excess_3 = 8'b0011_1000;\n        4'd6: excess_3 = 8'b0011_1001;\n        4'd7: excess_3 = 8'b0011_1010;\n        4'd8: excess_3 = 8'b0011_1011;\n        4'd9: excess_3 = 8'b0011_1100;\n        4'd10: excess_3 = 8'b0011_1101;\n        4'd11: excess_3 = 8'b0011_1110;\n        4'd12: excess_3 = 8'b0011_1111;\n        4'd13: excess_3 = 8'b0100_0000;\n        4'd14: excess_3 = 8'b0100_0001;\n        4'd15: excess_3 = 8'b0100_0010;\n        default: excess_3 = 8'b0000_0000;\n    endcase\nend\n\nendmodule",
        "module_name": "excess_3_converter",
        "module_hash": "fe8e17586c8eec3536aebaca90f6c060",
        "dataset_index": 9262
      },
      "my_fifo_6551d797": {
        "rtl_code": "\nmodule my_fifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    q,\n    usedw\n);\n\n    input aclr;\n    input clock;\n    input [33:0] data;\n    input rdreq;\n    input wrreq;\n    output [33:0] q;\n    output [9:0] usedw;\n\n    wire [9:0] sub_wire0;\n    wire [33:0] sub_wire1;\n\n    scfifo scfifo_component (\n        .aclr(aclr),\n        .clock(clock),\n        .data(data),\n        .rdreq(rdreq),\n        .wrreq(wrreq),\n        .q(sub_wire1),\n        .usedw(sub_wire0)\n    );\n\n    assign q = sub_wire1;\n    assign usedw = sub_wire0;\n\nendmodule\nmodule scfifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    q,\n    usedw\n);\n\n    input aclr;\n    input clock;\n    input [33:0] data;\n    input rdreq;\n    input wrreq;\n    output [33:0] q;\n    output [9:0] usedw;\n\n    reg [33:0] q_reg;\n    reg [9:0] usedw_reg;\n\n    assign q = q_reg;\n    assign usedw = usedw_reg;\n\n    always @(posedge clock or posedge aclr) begin\n        if (aclr) begin\n            q_reg <= 0;\n            usedw_reg <= 0;\n        end else begin\n            if (wrreq) begin\n                q_reg <= data;\n                usedw_reg <= usedw_reg + 1;\n            end\n\n            if (rdreq) begin\n                q_reg <= 0;\n                usedw_reg <= usedw_reg - 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "my_fifo",
        "module_hash": "6551d797888d29f208e96707810e6e90",
        "dataset_index": 298
      },
      "control_digitos_1_2a83f468": {
        "rtl_code": "\nmodule control_digitos_1\n\t(\n\tinput  [7:0] estado,\n\tinput  [3:0]RG1_Dec,\n   input  [3:0]RG2_Dec,\n   input  [3:0]RG3_Dec,\n\tinput escribiendo,\n\tinput en_out,\n\tinput wire clk,\n\tinput wire [3:0] dig0_Dec,\n\tinput [3:0] direccion,\n\toutput reg [3:0] dig_Dec_Ho, dig_Dec_min, dig_Dec_seg, dig_Dec_mes, dig_Dec_dia, dig_Dec_an, dig_Dec_Ho_Ti, dig_Dec_min_Ti, dig_Dec_seg_Ti\n\t\n\t);\n\t\n\t\n\talways @(posedge clk)\n\t\n\tif (~escribiendo)\n\t\tif (en_out)\n\t\t\tcase (direccion)\n\t\t\t\t4'b0000:dig_Dec_Ho<=dig0_Dec;\t\t\n\t\t\t\t\t\t\n\t\t\t\t4'b0001:dig_Dec_min<=dig0_Dec;\t\n\n\t\t\t\t4'b0010:dig_Dec_seg<=dig0_Dec;\t\t\n\n\t\t\t\t4'b0011:dig_Dec_mes<=dig0_Dec;\t\t\n\n\t\t\t\t4'b0100:dig_Dec_dia<=dig0_Dec;\t\t\n\n\t\t\t\t4'b0101:dig_Dec_an<=dig0_Dec;\t\n\n\t\t\t\t4'b0110:begin\n\t\t\t\t\t\t\t\tif (dig0_Dec==4'b1111)\n\t\t\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=4'b0000;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig0_Dec;\n\t\t\t\t\t\t\tend\t\t\t\t\n\t\t\t\t4'b0111:dig_Dec_min_Ti<=dig0_Dec;\t\t\t\t\t\n\t\t\t\t4'b1000: dig_Dec_seg_Ti<=dig0_Dec;\n\t\t\t\tdefault:\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\t\n\t\t\t\t\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\t\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\t\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\t\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\t\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\t\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\t\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\tendcase\n\t\telse\n\t\t\tbegin\n\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\n\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\tend\n\telse \n\t\tcase (estado)\n\t\t\t8'h7d:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (direccion==4'b0011)\n\t\t\t\t\t\t\tdig_Dec_mes<=RG2_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0100)\n\t\t\t\t\t\t\tdig_Dec_dia<=RG1_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0101)\n\t\t\t\t\t\t\tdig_Dec_an<=RG3_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t8'h6c:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (direccion==4'b0000)\n\t\t\t\t\t\t\tdig_Dec_Ho<=RG3_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0001)\n\t\t\t\t\t\t\tdig_Dec_min<=RG2_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0010)\n\t\t\t\t\t\t\tdig_Dec_seg<=RG1_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\n\t\t\t\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t8'h75:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (direccion==4'b0110)\n\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=RG3_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0111)\n\t\t\t\t\t\t\tdig_Dec_min_Ti<=RG2_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b1000)\n\t\t\t\t\t\t\tdig_Dec_seg_Ti<=RG1_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\tdefault:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\n\t\t\t\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\t\t\t\tend\n\t\tendcase\n\t\t\nendmodule\n",
        "module_name": "control_digitos_1",
        "module_hash": "2a83f46853082e3a7c48f241ccfba266",
        "dataset_index": 21742
      },
      "CORDIC_FSM_v2_537c4092": {
        "rtl_code": "\n\nmodule CORDIC_FSM_v2\n(\ninput wire clk,\t\t\t\t\t\t\t\t\t\t\tinput wire reset,\t\t\t\t\t\t\t\t\t\tinput wire beg_FSM_CORDIC,\t\t\t\t\t\t\t\tinput wire ACK_FSM_CORDIC,\t\t\t\t\t\t\t\tinput wire operation,\t\t\t\t\t\t\t\t\tinput wire exception,\ninput wire [1:0] shift_region_flag,\t\t\t\t\t\tinput wire [1:0] cont_var,\t\t\t\t\t\t\t\tinput wire ready_add_subt,\t\t\t\t\t\t\t\tinput wire max_tick_iter, min_tick_iter,\t\t\t\tinput wire max_tick_var, min_tick_var,\t\t\t\t\toutput reg reset_reg_cordic,\noutput reg ready_CORDIC,\t\t\t\t\t\t\t\toutput reg beg_add_subt,\t\t\t\t\t\t\t\toutput reg ack_add_subt,\t\t\t\t\t\t\t\toutput reg sel_mux_1, sel_mux_3,\t\t\t\t\t\toutput reg [1:0] sel_mux_2,\t\t\t\t\t\t\t\toutput reg enab_cont_iter, load_cont_iter,\t\t\t\toutput reg enab_cont_var,  load_cont_var,\t\t\t\toutput reg enab_RB1, enab_RB2,\t\t\t\t\t\t\toutput reg enab_d_ff_Xn, enab_d_ff_Yn, enab_d_ff_Zn,\toutput reg enab_d_ff_out,enab_dff_5,\t\t\t\t\toutput reg enab_RB3,\noutput reg enab_reg_sel_mux1,enab_reg_sel_mux2,enab_reg_sel_mux3\n);\n\nlocalparam [3:0]    est0 = 4'b0000,\n                    est1 = 4'b0001,\n                    est2 = 4'b0010,\n                    est3 = 4'b0011,\n                    est4 = 4'b0100,\n                    est5 = 4'b0101, \n                    est6 = 4'b0110,\n                    est7 = 4'b0111,\n                    est8 = 4'b1000,\n                    est9 = 4'b1001,\n                    est10 = 4'b1010,\n                    est11 = 4'b1011,\n\t\t\t\t\test12 = 4'b1100,\n\t\t\t\t\test13 = 4'b1101;\n\t\t\t\t\t\n\nreg [3:0] state_reg, state_next;\talways @( posedge clk, posedge reset)\n    begin\n        if(reset)\tstate_reg <= est0;\n        else\t\tstate_reg <= state_next;\n    end\n\nalways @*\n    begin\n    state_next = state_reg; ready_CORDIC = 1'b0;\n    beg_add_subt = 1'b0;\n    ack_add_subt = 1'b0;\n    sel_mux_1 = 1'b0;\n    sel_mux_2 = 2'b00;\n    sel_mux_3 = 1'b0;\n    enab_cont_iter = 1'b0;\n    load_cont_iter = 1'b0;\n    enab_cont_var = 1'b0;\n    load_cont_var = 1'b0;\n    enab_RB1 = 1'b0;\n    enab_RB2 = 1'b0;\n    enab_RB3 = 1'b0;\n    enab_d_ff_Xn = 1'b0;\n    enab_d_ff_Yn = 1'b0;\n    enab_d_ff_Zn = 1'b0;\n    enab_d_ff_out = 1'b0;\n    reset_reg_cordic = 1'b0;\n    enab_dff_5 = 1'b0;\n    enab_reg_sel_mux1 = 1'b0;\n    enab_reg_sel_mux2 = 1'b0;\n    enab_reg_sel_mux3 = 1'b0;\n    \n        case(state_reg)\n        est0:\n        begin\n\t\t\treset_reg_cordic = 1'b1;\n\t\t\tenab_reg_sel_mux1 = 1'b1;\n            enab_reg_sel_mux2 = 1'b1;\n            enab_reg_sel_mux3 = 1'b1;\n\t\t\tstate_next = est1;\n        end\n\n\t\test1:\n        begin\n\t\t\tif(beg_FSM_CORDIC)\n\t\t\tbegin\n\t\t\t\tstate_next = est2;\n\t\t\tend\n\t\t\telse\n\t\t\t\tstate_next = est1;\n\t\tend\n\n\t\test2:\n\t\tbegin\n\t\t\tenab_RB1 = 1'b1;\n\t\t\tenab_cont_iter = 1'b1;\n\t\t\tload_cont_iter = 1'b1;\n\t\t\tstate_next = est3;\n\t\tend\n\n        est3:\n        begin\n            if(min_tick_iter)\n\t\t\t\tsel_mux_1 =\t1'b0;\n\t\t\telse\n\t\t\t\tsel_mux_1 = 1'b1;\n\t\t\tenab_reg_sel_mux1 = 1'b1;\n\t\t\t\t\t\t\n\t\t\tstate_next = est4;\n        end\n\n        est4:\n        begin\n\t\t\tif(exception)\n\t\t\t\tstate_next = est0;\n\t\t\telse\n\t\t\t\tstate_next = est5;\n            enab_RB2 = 1'b1;\n        end\n\n        est5:\n        begin\n\t\t\tenab_RB3 = 1'b1;\n\t\t\tenab_cont_var = 1'b1;\n\t\t\tload_cont_var = 1'b1;\n\t\t\tstate_next = est6;\n        end\n\n        est6:\n        begin            \n\t\t\tif(max_tick_iter)\n\t\t\tbegin\n\t\t\t\tif(operation == 1'b0)\n\t\t\t\tbegin\n\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\telse\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\tenab_reg_sel_mux2 = 1'b1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\telse\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\tenab_reg_sel_mux2 = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\telse\n\t\t\t\tsel_mux_2 = cont_var;\n\t\t\t\n\t\t\tenab_reg_sel_mux2 = 1'b1;\t\n\t\t\tstate_next = est7;\t\n        end        \n        \n        est7:\n        begin            \n\t\t\tbeg_add_subt = 1'b1;\n\t\t\tstate_next = est8;\n        end\n\n        est8:\n        begin\n\t\t\tif(ready_add_subt)\n\t\t\tbegin\n\t\t\t\tif(max_tick_iter)\n\t\t\t\tbegin\n\t\t\t\t\tif(operation == 1'b0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif(min_tick_var)\n\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\telse if(max_tick_var)\n\t\t\t\t\t\tenab_d_ff_Zn = 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\tend\n\t\t\t\tstate_next = est9;\n\t\t\tend\n\t\t\t\n\t\t\telse\n\t\t\t\tstate_next = est8;\n        end\n\n        est9:\n        begin\n\t\t\tack_add_subt = 1'b1;\n\t\t\tif(max_tick_iter)\n\t\t\tbegin\n\t\t\t\tstate_next = est10;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(max_tick_var)\n\t\t\t\tbegin\n\t\t\t\t\tenab_cont_iter = 1'b1;\n\t\t\t\t\tstate_next = est3;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tenab_cont_var = 1'b1;\n\t\t\t\t\tstate_next = est6;\n\t\t\t\tend\n\t\t\tend\n        end\n\n        est10:\n        begin            \n\t\t\tif(operation == 1'b0)\n\t\t\tbegin\n\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\telse\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\tenab_reg_sel_mux3 = 1'b1;\n\t\t\tend\n\t\t\t\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\telse\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\tenab_reg_sel_mux3 = 1'b1;\n\t\t\tend\n\t\t\t\n\t\t\tenab_reg_sel_mux3 = 1'b1;\n\t\t\tstate_next = est11;\n\t\tend\t\n\n\t\test11:\n\t\tbegin\t    \n\t\t\tenab_dff_5 = 1'b1;\n\t\t\tstate_next = est12;\n\t\tend\n\t\t\n\t\test12:\n\t\tbegin\n\t\t\tenab_d_ff_out = 1'b1;\n\t\t\tstate_next = est13;\n\t\tend\n\n\t\test13:\n\t\tbegin\n\t\t\tready_CORDIC = 1'b1;\n\t\t\tif(ACK_FSM_CORDIC)\n\t\t\t\tstate_next = est0;\n\t\t\telse\n\t\t\t\tstate_next = est13;\n\t\tend\n        \n        default : state_next = est0;\n        endcase\n    end\nendmodule\n",
        "module_name": "CORDIC_FSM_v2",
        "module_hash": "537c409238752a5cc05f66dac3a18b22",
        "dataset_index": 22855
      },
      "memory_protection_block #_572290ee": {
        "rtl_code": "module memory_protection_block #(\n  parameter n = 8, // number of address signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] addr,\n  input we,\n  output rd,\n  output wr\n);\n\n// Define memory protection rules here\nreg [n-1:0] protected_addr;\ninitial begin\n  protected_addr = {n{1'b0}}; // initialize all addresses to unprotected\n  protected_addr[3:0] = 4'b1010; // protect addresses 0xA0 to 0xAF\n  protected_addr[7:4] = 4'b0011; // protect addresses 0x30 to 0x3F\nend\n\n// Define read and write signals based on memory protection rules\nassign rd = 1'b1; // always allow reads\nassign wr = (we & ~protected_addr[addr]); // allow writes only if address is unprotected\n\n// Use read and write signals to control memory access\n\nendmodule",
        "module_name": "memory_protection_block #",
        "module_hash": "572290ee5490f4b4ad6b7070383bcd13",
        "dataset_index": 7519
      },
      "AddReg_81776afc": {
        "rtl_code": "module AddReg (\n  input clk, rst, load,\n  input [0:0] D,\n  output reg [0:0] Q\n);\n\n  wire [0:0] Q_next;\n  wire [0:0] Q_reset;\n\n  assign Q_reset = 1'b0;\n  assign Q_next = Q + D;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      Q <= Q_reset;\n    end else if (load) begin\n      Q <= D;\n    end else begin\n      Q <= Q_next;\n    end\n  end\n\nendmodule",
        "module_name": "AddReg",
        "module_hash": "81776afcfd7c99ccc54f9d8345bc79bf",
        "dataset_index": 11636
      },
      "task_func_test01_e1499318": {
        "rtl_code": "\nmodule task_func_test01(clk, a, b, c, x, y, z, w);\n\ninput clk;\ninput [7:0] a, b, c;\noutput reg [7:0] x, y, z, w;\n\nfunction [7:0] sum_shift;\ninput [3:0] s1, s2, s3;\nsum_shift = s1 + (s2 << 2) + (s3 << 4);\nendfunction\n\ntask reset_w;\nw = 0;\nendtask\n\ntask add_to;\noutput [7:0] out;\ninput [7:0] in;\nout = out + in;\nendtask\n\nalways @(posedge clk) begin\n\tx = sum_shift(a, b, c);\n\ty = sum_shift(a[7:4], b[5:2], c[3:0]);\n\tz = sum_shift(a[0], b[5:4], c >> 5) ^ sum_shift(1, 2, 3);\n\n\treset_w;\n\tadd_to(w, x);\n\tadd_to(w, y);\n\tadd_to(w, z);\nend\n\nendmodule\n\nmodule task_func_test02(clk, a, b, c, x, y, z, w);\n\ninput clk;\ninput [7:0] a, b, c;\noutput reg [7:0] x, y, z, w;\n\nfunction [7:0] sum_shift(input [3:0] s1, s2, s3);\nsum_shift = s1 + (s2 << 2) + (s3 << 4);\nendfunction\n\ntask reset_w;\nw = 0;\nendtask\n\ntask add_to(output [7:0] out, input [7:0] in);\nout = out + in;\nendtask\n\nalways @(posedge clk) begin\n\tx = sum_shift(a, b, c);\n\ty = sum_shift(a[7:4], b[5:2], c[3:0]);\n\tz = sum_shift(a[0], b[5:4], c >> 5) ^ sum_shift(1, 2, 3);\n\n\treset_w;\n\tadd_to(w, x);\n\tadd_to(w, y);\n\tadd_to(w, z);\nend\n\nendmodule\n\nmodule task_func_test03(input [7:0] din_a, input [7:0] din_b, output [7:0] dout_a);\n\tassign dout_a = test(din_a,din_b);\n\tfunction [7:0] test;\n\t\tinput [7:0] a;\n\t\tinput [7:0] b;\n\t\tbegin : TEST\n\t\t\tinteger i;\n\t\t\tfor (i = 0; i <= 7; i = i + 1)\n\t\t\t\ttest[i] = a[i] & b[i];\n\t\tend\n\tendfunction\nendmodule\n\nmodule task_func_test04(input [7:0] in, output [7:0] out1, out2, out3, out4);\n\tparameter p = 23;\n\tparameter px = 42;\n\tfunction [7:0] test1;\n\t\tinput [7:0] i;\n\t\tparameter p = 42;\n\t\tbegin\n\t\t\ttest1 = i + p;\n\t\tend\n\tendfunction\n\tfunction [7:0] test2;\n\t\tinput [7:0] i;\n\t\tparameter p2 = p+42;\n\t\tbegin\n\t\t\ttest2 = i + p2;\n\t\tend\n\tendfunction\n\tfunction [7:0] test3;\n\t\tinput [7:0] i;\n\t\tbegin\n\t\t\ttest3 = i + p;\n\t\tend\n\tendfunction\n\tfunction [7:0] test4;\n\t\tinput [7:0] i;\n\t\tparameter px = p + 13;\n\t\tparameter p3 = px - 37;\n\t\tparameter p4 = p3 ^ px;\n\t\tbegin\n\t\t\ttest4 = i + p4;\n\t\tend\n\tendfunction\n\tassign out1 = test1(in);\n\tassign out2 = test2(in);\n\tassign out3 = test3(in);\n\tassign out4 = test4(in);\nendmodule\n\nmodule task_func_test05(data_in,data_out,clk);\n\toutput reg data_out;\n\tinput data_in;\n\tinput clk;\n\n\ttask myTask;\n\t\toutput out;\n\t\tinput in;\n\t\tout = in;\n\tendtask\n\n\talways @(posedge clk) begin\n\t\tmyTask(data_out,data_in);\n\tend\nendmodule\n",
        "module_name": "task_func_test01",
        "module_hash": "e1499318e9080eed42665f5b45ded01a",
        "dataset_index": 25347
      },
      "uart_tx_067db156": {
        "rtl_code": "module uart_tx\n   #(\n     parameter DBIT = 8,     SB_tck = 16  )\n   (\n    input wire clk, reset,\n    input wire tx_start, s_tck,\n    input wire [7:0] din,\n    output reg tx_done_tck,\n    output wire tx\n   );\n\n   \n   localparam [1:0]init_state  = 2'b00,start = 2'b01,data  = 2'b10,stop  = 2'b11;\n\n   \n   reg [1:0] state, state_next;\n   reg [3:0] s, s_next;\n   reg [2:0] n, n_next;\n   reg [7:0] b, b_next;\n   reg tx_reg, tx_next;\n\n   \n   always @(posedge clk)\n      if (reset)\n         begin\n            state <= init_state;\n            s <= 0;\n            n <= 0;\n            b <= 0;\n            tx_reg <= 1'b1;\n         end\n      else\n         begin\n            state <= state_next;\n            s <= s_next;\n            n <= n_next;\n            b <= b_next;\n            tx_reg <= tx_next;\n         end\n\n  \n   always @*\n   begin\n      state_next = state;\n      tx_done_tck = 1'b0;\n      s_next = s;\n      n_next = n;\n      b_next = b;\n      tx_next = tx_reg ;\n      if(state==init_state)\n            begin\n               tx_next = 1'b1;\n               if (tx_start)\n                  begin\n                     state_next = start;\n                     s_next = 0;\n                     b_next = din;\n                  end\n            end\n        else if(state==start)\n            begin\n               tx_next = 1'b0;\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        state_next = data;\n                        s_next = 0;\n                        n_next = 0;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==data)\n            begin\n               tx_next = b[0];\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        s_next = 0;\n                        b_next = b >> 1;\n                        if (n==(DBIT-1))\n                           state_next = stop ;\n                        else\n                           n_next = n + 1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==stop)\n            begin\n               tx_next = 1'b1;\n               if (s_tck)\n                  if (s==(SB_tck-1))\n                     begin\n                        state_next = init_state;\n                        tx_done_tck = 1'b1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n   end\n\n   assign tx = tx_reg;\n\nendmodule\n",
        "module_name": "uart_tx",
        "module_hash": "067db156b0b401d4e89dd50d4bd32bac",
        "dataset_index": 24723
      },
      "rxuart #_c724f79f": {
        "rtl_code": "\nmodule rxuart #(\n\t\tparameter [30:0] INITIAL_SETUP = 31'd868,\n\t\tlocalparam [3:0]\tRXU_BIT_ZERO    = 4'h0,\n\t\t\t\t\tRXU_BIT_ONE     = 4'h1,\n\t\t\t\t\tRXU_BIT_TWO     = 4'h2,\n\t\t\t\t\tRXU_BIT_THREE   =  4'h3,\n\t\t\t\t\tRXU_BIT_SEVEN   = 4'h7,\n\t\t\t\t\tRXU_PARITY      = 4'h8,\n\t\t\t\t\tRXU_STOP        = 4'h9,\n\t\t\t\t\tRXU_SECOND_STOP = 4'ha,\n\t\t\t\t\tRXU_BREAK       = 4'hd,\n\t\t\t\t\tRXU_RESET_IDLE  = 4'he,\n\t\t\t\t\tRXU_IDLE        = 4'hf\n\t\t) (\n\t\tinput\twire\t\ti_clk, i_reset,\n\t\t\n\t\tinput\twire\t[30:0]\ti_setup,\n\t\t\n\t\tinput\twire\t\ti_uart_rx,\n\t\toutput\treg\t\to_wr,\n\t\toutput\treg\t[7:0]\to_data,\n\t\toutput\treg\t\to_break,\n\t\toutput\treg\t\to_parity_err, o_frame_err,\n\t\toutput\twire\t\to_ck_uart\n\t\t);\n\n\twire\t[27:0]\tclocks_per_baud, break_condition, half_baud;\n\twire\t[1:0]\tdata_bits;\n\twire\t\tuse_parity, parity_even, dblstop, fixd_parity;\n\treg\t[29:0]\tr_setup;\n\treg\t[3:0]\tstate;\n\n\treg\t[27:0]\tbaud_counter;\n\treg\t\tzero_baud_counter;\n\treg\t\tq_uart, qq_uart, ck_uart;\n\treg\t[27:0]\tchg_counter;\n\treg\t\tline_synch;\n\treg\t\thalf_baud_time;\n\treg\t[7:0]\tdata_reg;\n\treg\t\tcalc_parity;\n\treg\t\tpre_wr;\n\n\tassign\tclocks_per_baud = { 4'h0, r_setup[23:0] };\n\tassign\tdata_bits   = r_setup[29:28];\n\tassign\tdblstop     = r_setup[27];\n\tassign\tuse_parity  = r_setup[26];\n\tassign\tfixd_parity = r_setup[25];\n\tassign\tparity_even = r_setup[24];\n\tassign\tbreak_condition = { r_setup[23:0], 4'h0 };\n\tassign\thalf_baud = { 5'h00, r_setup[23:1] }-28'h1;\n\n\tinitial\tq_uart  = 1'b0;\n\tinitial\tqq_uart = 1'b0;\n\tinitial\tck_uart = 1'b0;\n\talways @(posedge i_clk)\n\tbegin\n\t\tq_uart <= i_uart_rx;\n\t\tqq_uart <= q_uart;\n\t\tck_uart <= qq_uart;\n\tend\n\tassign\to_ck_uart = ck_uart;\n\tinitial\tchg_counter = 28'h00;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tchg_counter <= 28'h00;\n\telse if (qq_uart != ck_uart)\n\t\tchg_counter <= 28'h00;\n\telse if (chg_counter < break_condition)\n\t\tchg_counter <= chg_counter + 1;\n\tinitial\to_break    = 1'b0;\n\talways @(posedge i_clk)\n\t\to_break <= ((chg_counter >= break_condition)&&(~ck_uart))? 1'b1:1'b0;\n\tinitial\tline_synch = 1'b0;\n\talways @(posedge i_clk)\n\t\tline_synch <= ((chg_counter >= break_condition)&&(ck_uart));\n\tinitial\thalf_baud_time = 0;\n\talways @(posedge i_clk)\n\t\thalf_baud_time <= (~ck_uart)&&(chg_counter >= half_baud);\n\tinitial\tr_setup     = INITIAL_SETUP[29:0];\n\talways @(posedge i_clk)\n\tif (state >= RXU_RESET_IDLE)\n\t\tr_setup <= i_setup[29:0];\n\tinitial\tstate = RXU_RESET_IDLE;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tstate <= RXU_RESET_IDLE;\n\telse if (state == RXU_RESET_IDLE)\n\tbegin\n\t\tif (line_synch)\n\t\t\tstate <= RXU_IDLE;\n\t\telse state <= RXU_RESET_IDLE;\n\t\tend else if (o_break)\n\tbegin state <= RXU_BREAK;\n\tend else if (state == RXU_BREAK)\n\tbegin if (ck_uart)\n\t\t\tstate <= RXU_IDLE;\n\t\telse\n\t\t\tstate <= RXU_BREAK;\n\t\tend else if (state == RXU_IDLE)\n\tbegin if ((~ck_uart)&&(half_baud_time))\n\t\t\tbegin\n\t\t\t\tcase (data_bits)\n\t\t\t\t2'b00: state <= RXU_BIT_ZERO;\n\t\t\t\t2'b01: state <= RXU_BIT_ONE;\n\t\t\t\t2'b10: state <= RXU_BIT_TWO;\n\t\t\t\t2'b11: state <= RXU_BIT_THREE;\n\t\t\t\tendcase\n\t\t\tend else state <= RXU_IDLE;\n\t\t\tend else if (zero_baud_counter)\n\tbegin\n\t\tif (state < RXU_BIT_SEVEN)\n\t\t\tstate <= state + 1;\n\t\telse if (state == RXU_BIT_SEVEN)\n\t\t\tstate <= (use_parity) ? RXU_PARITY:RXU_STOP;\n\t\telse if (state == RXU_PARITY)\n\t\t\tstate <= RXU_STOP;\n\t\telse if (state == RXU_STOP)\n\t\tbegin if (~ck_uart) state <= RXU_RESET_IDLE;\n\t\t\telse if (dblstop)\n\t\t\t\tstate <= RXU_SECOND_STOP;\n\t\t\telse\n\t\t\t\tstate <= RXU_IDLE;\n\t\tend else begin\n\t\t\tif (~ck_uart) state <= RXU_RESET_IDLE;\n\t\t\telse\n\t\t\t\tstate <= RXU_IDLE;\n\t\tend\n\t\tend\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)&&(state != RXU_PARITY))\n\t\tdata_reg <= { ck_uart, data_reg[7:1] };\n\talways @(posedge i_clk)\n\tif (state == RXU_IDLE)\n\t\tcalc_parity <= 0;\n\telse if (zero_baud_counter)\n\t\tcalc_parity <= calc_parity ^ ck_uart;\n\tinitial\to_parity_err = 1'b0;\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)&&(state == RXU_PARITY))\n\tbegin\n\t\tif (fixd_parity)\n\t\t\to_parity_err <= (ck_uart ^ parity_even);\n\t\telse if (parity_even)\n\t\t\to_parity_err <= (calc_parity != ck_uart);\n\t\telse\n\t\t\to_parity_err <= (calc_parity == ck_uart);\n\tend else if (state >= RXU_BREAK)\n\t\to_parity_err <= 1'b0;\n\tinitial\to_frame_err  = 1'b0;\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)&&((state == RXU_STOP)\n\t\t\t\t\t||(state == RXU_SECOND_STOP)))\n\t\to_frame_err <= (o_frame_err)||(~ck_uart);\n\telse if ((zero_baud_counter)||(state >= RXU_BREAK))\n\t\to_frame_err <= 1'b0;\n\tinitial\to_data = 8'h00;\n\tinitial\tpre_wr = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\tpre_wr <= 1'b0;\n\t\to_data <= 8'h00;\n\tend else if ((zero_baud_counter)&&(state == RXU_STOP))\n\tbegin\n\t\tpre_wr <= 1'b1;\n\t\tcase (data_bits)\n\t\t2'b00: o_data <= data_reg;\n\t\t2'b01: o_data <= { 1'b0, data_reg[7:1] };\n\t\t2'b10: o_data <= { 2'b0, data_reg[7:2] };\n\t\t2'b11: o_data <= { 3'b0, data_reg[7:3] };\n\t\tendcase\n\tend else if ((zero_baud_counter)||(state == RXU_IDLE))\n\t\tpre_wr <= 1'b0;\n\tinitial\to_wr   = 1'b0;\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)||(state == RXU_IDLE))\n\t\to_wr <= (pre_wr)&&(!i_reset);\n\telse\n\t\to_wr <= 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tbaud_counter <= clocks_per_baud-28'h01;\n\telse if (zero_baud_counter)\n\t\tbaud_counter <= clocks_per_baud-28'h01;\n\telse case(state)\n\t\tRXU_RESET_IDLE:baud_counter <= clocks_per_baud-28'h01;\n\t\tRXU_BREAK:\tbaud_counter <= clocks_per_baud-28'h01;\n\t\tRXU_IDLE:\tbaud_counter <= clocks_per_baud-28'h01;\n\t\tdefault:\tbaud_counter <= baud_counter-28'h01;\n\tendcase\n\tinitial\tzero_baud_counter = 1'b0;\n\talways @(posedge i_clk)\n\tif (state == RXU_IDLE)\n\t\tzero_baud_counter <= 1'b0;\n\telse\n\t\tzero_baud_counter <= (baud_counter == 28'h01);\n\tendmodule\n\n\n",
        "module_name": "rxuart #",
        "module_hash": "c724f79fed19f4b6bf33379dd86dcfa7",
        "dataset_index": 17005
      },
      "and_or_not_a8baa343": {
        "rtl_code": "module and_or_not(\n    output y,\n    input a, b, rsb\n);\n\nreg yi;\n\nalways @ (a or b or rsb) begin\n    if (rsb == 0) begin\n        yi <= 1;\n    end\n    else if (a & b) begin\n        yi <= 1;\n    end\n    else if (a == 0 & b == 0) begin\n        yi <= 0;\n    end\n    else begin\n        yi <= a & b;\n    end\nend\n\nassign #1 y = yi;\n\nendmodule",
        "module_name": "and_or_not",
        "module_hash": "a8baa343d0e5751782d9f80e1ac2c373",
        "dataset_index": 13030
      },
      "sync_counter_ed853aa5": {
        "rtl_code": "module sync_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "sync_counter",
        "module_hash": "ed853aa5553178991a654d52412c5602",
        "dataset_index": 1725
      },
      "binary_counter #_cbcbb5ad": {
        "rtl_code": "\nmodule binary_counter #(\n  parameter WIDTH = 4\n) (\n  // Input signals\n  input clk,\n  input reset, // Active low reset\n  input count_up, // Active high count up input\n  input count_down, // Active high count down input\n  // Output signals\n  output reg [WIDTH-1:0] count_out\n);\n\n  // State definition\n  localparam INIT = 2'b00;\n  localparam COUNT_UP = 2'b01;\n  localparam COUNT_DOWN = 2'b10;\n  localparam RESET = 2'b11;\n\n  // State register and next state logic\n  reg [1:0] state_reg, state_next;\n  always @(posedge clk, negedge reset) begin\n    if (!reset) begin\n      state_reg <= INIT;\n    end else begin\n      state_reg <= state_next;\n    end\n  end\n\n  // Output logic\n  always @(posedge clk) begin\n    case (state_reg)\n      INIT: count_out <= {WIDTH{1'b0}};\n      COUNT_UP: count_out <= count_out + 1'b1;\n      COUNT_DOWN: count_out <= count_out - 1'b1;\n      RESET: count_out <= {WIDTH{1'b0}};\n    endcase\n  end\n\n  // Next state logic\n  always @(*) begin\n    case (state_reg)\n      INIT: begin\n        if (count_up) begin\n          state_next = COUNT_UP;\n        end else if (count_down) begin\n          state_next = COUNT_DOWN;\n        end else begin\n          state_next = INIT;\n        end\n      end\n      COUNT_UP: begin\n        if (count_up) begin\n          state_next = COUNT_UP;\n        end else if (count_out == {WIDTH{1'b1}}) begin\n          state_next = INIT;\n        end else begin\n          state_next = COUNT_UP;\n        end\n      end\n      COUNT_DOWN: begin\n        if (count_down) begin\n          state_next = COUNT_DOWN;\n        end else if (count_out == {WIDTH{1'b0}}) begin\n          state_next = INIT;\n        end else begin\n          state_next = COUNT_DOWN;\n        end\n      end\n      RESET: begin\n        state_next = RESET;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "binary_counter #",
        "module_hash": "cbcbb5ad089af11b73c0b9d45401566c",
        "dataset_index": 21018
      },
      "mult_srst_ena_0fd68567": {
        "rtl_code": "\nmodule mult_srst_ena (\n    input  wire        CLK,\n    input  wire        RST,\n    input  wire        ENA,\n    input  wire [ 8:0] A,\n    input  wire [ 8:0] B,\n    output wire [17:0] Z\n);\n\n    reg [8:0] ra;\n    always @(posedge CLK)\n        if (RST)      ra <= 0;\n        else if (ENA) ra <= A;\n\n    MULT9X9 mult (\n        .A (ra),\n        .B (B),\n        .Z (Z)\n    );\n\nendmodule\nmodule MULT9X9 (\n    input  wire [8:0] A,\n    input  wire [8:0] B,\n    output wire [17:0] Z\n);\n\n    wire [17:0] mult_out;\n    assign mult_out = A * B;\n\n    assign Z = mult_out;\n\nendmodule",
        "module_name": "mult_srst_ena",
        "module_hash": "0fd6856739d9bae7d8f53b5f816fd019",
        "dataset_index": 5592
      },
      "barrel_shifter_5de615e4": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] result\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nwire [3:0] abs_B;\n\nassign abs_B = (B[3] == 1'b1) ? ~B + 1'b1 : B;\n\nalways @(*) begin\n    stage1_out = (B[3] == 1'b0) ? (A << B) : (A >> abs_B);\nend\n\nalways @(*) begin\n    stage2_out = stage1_out;\nend\n\nassign result = stage2_out;\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "5de615e43c4546ac33b8619a20e51b85",
        "dataset_index": 16566
      },
      "dly_signal_06f60318": {
        "rtl_code": "\nmodule dly_signal (clk, indata, outdata);\nparameter WIDTH = 1;\ninput clk;\ninput [WIDTH-1:0] indata;\noutput [WIDTH-1:0] outdata;\nreg [WIDTH-1:0] outdata, next_outdata;\nalways @(posedge clk) outdata = next_outdata;\nalways @*\nbegin\n  #1;\n  next_outdata = indata;\nend\nendmodule\n\n\n\nmodule pipeline_stall (clk, reset, datain, dataout);\nparameter WIDTH = 1;\nparameter DELAY = 1;\ninput clk, reset;\ninput [WIDTH-1:0] datain;\noutput [WIDTH-1:0] dataout;\nreg [(WIDTH*DELAY)-1:0] dly_datain, next_dly_datain;\nassign dataout = dly_datain[(WIDTH*DELAY)-1 : WIDTH*(DELAY-1)];\ninitial dly_datain = 0;\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset)\n    dly_datain = 0;\n  else dly_datain = next_dly_datain;\nend\nalways @*\nbegin\n  #1;\n  next_dly_datain = {dly_datain, datain};\nend\nendmodule\n\n\n\nmodule full_synchronizer (clk, reset, datain, dataout);\nparameter WIDTH = 1;\ninput clk, reset;\ninput [WIDTH-1:0] datain;\noutput [WIDTH-1:0] dataout;\npipeline_stall #(WIDTH,2) sync (clk, reset, datain, dataout);\nendmodule\n\n\nmodule reset_sync (clk, hardreset, reset);\ninput clk, hardreset;\noutput reset;\n\nreg [3:0] reset_reg, next_reset_reg;\nassign reset = reset_reg[3];\n\ninitial reset_reg = 4'hF;\nalways @ (posedge clk or posedge hardreset)\nbegin\n  if (hardreset)\n    reset_reg = 4'hF;\n  else reset_reg = next_reset_reg;\nend\n\nalways @*\nbegin\n  next_reset_reg = {reset_reg,1'b0};\nend\nendmodule\n\n\n",
        "module_name": "dly_signal",
        "module_hash": "06f603184ff47081302a1ea312b08cd1",
        "dataset_index": 10568
      },
      "top__3ab762d5": {
        "rtl_code": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    input clk,\n    input [2:0] sel, \n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [7:0] sum_out\n);\n\nreg out_2to1_mux;\nwire [3:0] out_6to1_mux;\n\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2)\n        out_2to1_mux <= b;\n    else\n        out_2to1_mux <= a;\nend\n\nmux_6to1 mux_inst (\n    .sel(sel),\n    .data0(data0),\n    .data1(data1),\n    .data2(data2),\n    .data3(data3),\n    .data4(data4),\n    .data5(data5),\n    .out(out_6to1_mux)\n);\n\nalways @(posedge clk) begin\n    sum_out <= out_2to1_mux + out_6to1_mux;\nend\n\nendmodule\n\nmodule mux_6to1 (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = data0;\n    endcase\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "3ab762d515776b2e6296dcc264ff6acb",
        "dataset_index": 16883
      },
      "top_module_bca7520c": {
        "rtl_code": "\nmodule top_module(\n    input a,\n    input b,\n    input sel_xor,\n    input sel_mux,\n    output wire out_always\n);\n\nwire xor_out;\nwire mux_out;\n\nxor_gate xor_inst(\n    .a(a),\n    .b(b),\n    .out(xor_out)\n);\n\nmux_2to1 mux_inst(\n    .a(a),\n    .b(b),\n    .sel(sel_mux),\n    .out(mux_out)\n);\n\nassign out_always = (sel_xor & ~sel_mux) ? xor_out :\n                    (sel_mux & ~sel_xor) ? mux_out :\n                    (sel_mux & sel_xor) ? 1'b1 : 1'b0;\n\nendmodule\nmodule xor_gate(\n    input a,\n    input b,\n    output wire out\n);\n\nassign out = a ^ b;\n\nendmodule\nmodule mux_2to1(\n    input a,\n    input b,\n    input sel,\n    output wire out\n);\n\nassign out = sel ? b : a;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "bca7520c5b1235e0bc6e1f3d4e2f2932",
        "dataset_index": 8300
      },
      "arithshiftbidir_1a127d3f": {
        "rtl_code": "\nmodule arithshiftbidir(distance,\n                       data,\n                       direction,\n                       result);\n\n   parameter             lpm_type = \"LPM_CLSHIFT\";\n   parameter             lpm_shifttype = \"ARITHMETIC\";\n   parameter             lpm_width = 32;\n   parameter             lpm_widthdist = 5;\n   \n   input  wire [lpm_widthdist-1:0] distance;\n   input  signed [lpm_width-1    :0] data;\n   input  wire                     direction;\n   output wire [lpm_width-1    :0] result;\n\n   wire   [lpm_width-1    :0] lsh    = data << distance;\n   wire   [lpm_width-1    :0] rsh    = data >> distance;\n   wire   [lpm_width-1    :0] rshN   = ~(~data >> distance);\n   wire   [lpm_width-1    :0] arsh   = data[lpm_width-1] ? rshN : rsh;\n   assign                     result = direction ? arsh : lsh;\n   \nendmodule\n\n`ifdef TEST_ARITHSHIFTBIDIR\nmodule test_arithshiftbidir();\n   reg  [31:0] data;\n   reg  [ 4:0] dist;\n   reg         dir;\n   wire [31:0] resulta, resultl;\n   \n   arithshiftbidir a(dist, data, dir, resulta);\n   defparam    a.lpm_shifttype = \"ARITHMETIC\";\n   \n   initial begin\n      #0 data = 48; dir = 0; dist = 0;\n      $monitor(\"dir %d dist %2d A %8x\", dir, dist, resulta);\n      repeat (2) begin\n         repeat (32)\n           #1 dist = dist + 1;\n         data = 32'h98765432;\n         dir = ~dir;\n      end      \n      dir = 1;\n      data = 32'h08765432;\n      repeat (32)\n        #1 dist = dist + 1;\n   end   \nendmodule\n`endif\n",
        "module_name": "arithshiftbidir",
        "module_hash": "1a127d3f2a4303587380d0a463b6dce2",
        "dataset_index": 10939
      },
      "wasca_external_sdram_controller_input_efifo__9f22c86e": {
        "rtl_code": "module wasca_external_sdram_controller_input_efifo_module (\n  // inputs:\n  clk,\n  rd,\n  reset_n,\n  wr,\n  wr_data,\n\n  // outputs:\n  almost_empty,\n  almost_full,\n  empty,\n  full,\n  rd_data\n);\n\n  output almost_empty;\n  output almost_full;\n  output empty;\n  output full;\n  output [42:0] rd_data;\n  input clk;\n  input rd;\n  input reset_n;\n  input wr;\n  input [42:0] wr_data;\n\n  wire almost_empty;\n  wire almost_full;\n  wire empty;\n  reg [1:0] entries;\n  reg [42:0] entry_0;\n  reg [42:0] entry_1;\n  wire full;\n  reg rd_address;\n  reg [42:0] rd_data;\n  wire [1:0] rdwr;\n  reg wr_address;\n  assign rdwr = {rd, wr};\n  assign full = entries == 2;\n  assign almost_full = entries >= 1;\n  assign empty = entries == 0;\n  assign almost_empty = entries <= 1;\n  \n  always @(entry_0 or entry_1 or rd_address) begin\n    case (rd_address)\n      1'd0: rd_data = entry_0;\n      1'd1: rd_data = entry_1;\n      default: rd_data = 0;\n    endcase\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      wr_address <= 0;\n      rd_address <= 0;\n      entries <= 0;\n    end else begin\n      case (rdwr)\n        2'd1: begin\n          // Write data\n          if (!full) begin\n            entries <= entries + 1;\n            wr_address <= (wr_address == 1) ? 0 : (wr_address + 1);\n          end\n        end\n        2'd2: begin\n          // Read data\n          if (!empty) begin\n            entries <= entries - 1;\n            rd_address <= (rd_address == 1) ? 0 : (rd_address + 1);\n          end\n        end\n        2'd3: begin\n          wr_address <= (wr_address == 1) ? 0 : (wr_address + 1);\n          rd_address <= (rd_address == 1) ? 0 : (rd_address + 1);\n        end\n        default: begin\n        end\n      endcase\n    end\n  end\n\n  always @(posedge clk) begin\n    //Write data\n    if (wr & !full) begin\n      case (wr_address)\n        1'd0: entry_0 <= wr_data;\n        1'd1: entry_1 <= wr_data;\n        default: begin\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "wasca_external_sdram_controller_input_efifo_",
        "module_hash": "9f22c86e033f31a764ee6863da198a1e",
        "dataset_index": 12693
      },
      "MUX4_29188fab": {
        "rtl_code": "module MUX4 (\n    A,\n    B,\n    C,\n    D,\n    S0,\n    S1,\n    Y\n);\n  input A, B, C, D, S0, S1;\n  output Y;\n  \n  wire MUX0_out, MUX1_out;\n  \n  // Instantiating 2-to-1 multiplexers\n  MUX2x1 MUX0 (\n      .A (A),\n      .B (B),\n      .S (S0),\n      .Q (MUX0_out)\n  );\n  \n  MUX2x1 MUX1 (\n      .A (C),\n      .B (D),\n      .S (S0),\n      .Q (MUX1_out)\n  );\n  \n  // Final 2-to-1 multiplexer\n  MUX2x1 MUX2 (\n      .A (MUX0_out),\n      .B (MUX1_out),\n      .S (S1),\n      .Q (Y)\n  );\n  \nendmodule\n\n// 2-to-1 multiplexer building block\nmodule MUX2x1 (\n    A,\n    B,\n    S,\n    Q\n);\n  input A, B, S;\n  output Q;\n  \n  assign Q = (S == 1'b0) ? A : B;\n  \nendmodule",
        "module_name": "MUX4",
        "module_hash": "29188fabaed762dfa27e3c7f4c56f8f6",
        "dataset_index": 14200
      },
      "my__44065fca": {
        "rtl_code": "\nmodule my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire or0_out          ;\n    wire nand0_out_Y      ;\n\n    //                                 Name         Output             Other arguments\n    or                                 or0         (or0_out          , A2, A1, A3             );\n    nand                               nand0       (nand0_out_Y      , B1, or0_out            );\n    buf                               buf0        (Y                , nand0_out_Y, VPWR, VGND, VPB, VNB  ); // Changed the buffer type\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "44065fca70dd63958707cf1cee54a5da",
        "dataset_index": 19514
      },
      "johnson_counter_3f5735c0": {
        "rtl_code": "module johnson_counter (\n  input clock,\n  output [n-1:0] out\n);\n\nparameter n = 4; // number of output signals\n\nreg [n-1:0] shift_reg;\nwire [n-1:0] next_state;\n\nassign next_state[0] = shift_reg[n-1] ^ shift_reg[n-2];\nassign next_state[n-1] = shift_reg[n-2] ^ shift_reg[n-3];\n\ngenvar i;\ngenerate\n  for (i = 1; i < n-1; i = i+1) begin\n    assign next_state[i] = shift_reg[i-1] ^ shift_reg[i] ^ shift_reg[i+1];\n  end\nendgenerate\n\nalways @(posedge clock) begin\n  shift_reg <= next_state;\nend\n\nassign out = shift_reg;\n\nendmodule",
        "module_name": "johnson_counter",
        "module_hash": "3f5735c030bf1256a3de6459abbf8e64",
        "dataset_index": 8957
      },
      "mux_16to1_sel4_7_1 #_7611abd4": {
        "rtl_code": "\nmodule mux_16to1_sel4_7_1 #(\n    parameter ID = 0,\n    parameter NUM_STAGE = 1,\n    parameter din1_WIDTH = 7,\n    parameter din2_WIDTH = 7,\n    parameter din3_WIDTH = 7,\n    parameter din4_WIDTH = 7,\n    parameter din5_WIDTH = 7,\n    parameter din6_WIDTH = 7,\n    parameter din7_WIDTH = 7,\n    parameter din8_WIDTH = 7,\n    parameter din9_WIDTH = 7,\n    parameter din10_WIDTH = 7,\n    parameter din11_WIDTH = 7,\n    parameter din12_WIDTH = 7,\n    parameter din13_WIDTH = 7,\n    parameter din14_WIDTH = 7,\n    parameter din15_WIDTH = 7,\n    parameter din16_WIDTH = 7,\n    parameter din17_WIDTH = 4,\n    parameter dout_WIDTH = 7\n)(\n    input [din1_WIDTH-1:0] din1,\n    input [din2_WIDTH-1:0] din2,\n    input [din3_WIDTH-1:0] din3,\n    input [din4_WIDTH-1:0] din4,\n    input [din5_WIDTH-1:0] din5,\n    input [din6_WIDTH-1:0] din6,\n    input [din7_WIDTH-1:0] din7,\n    input [din8_WIDTH-1:0] din8,\n    input [din9_WIDTH-1:0] din9,\n    input [din10_WIDTH-1:0] din10,\n    input [din11_WIDTH-1:0] din11,\n    input [din12_WIDTH-1:0] din12,\n    input [din13_WIDTH-1:0] din13,\n    input [din14_WIDTH-1:0] din14,\n    input [din15_WIDTH-1:0] din15,\n    input [din16_WIDTH-1:0] din16,\n    input [din17_WIDTH-1:0] din17,\n    input [3:0] sel,\n    output [dout_WIDTH-1:0] dout\n);\n\n// Internal wires\nwire [din1_WIDTH-1:0] mux_1_0, mux_1_1, mux_1_2, mux_1_3, mux_1_4, mux_1_5, mux_1_6, mux_1_7;\nwire [din1_WIDTH-1:0] mux_2_0, mux_2_1, mux_2_2, mux_2_3;\nwire [din1_WIDTH-1:0] mux_3_0, mux_3_1;\nwire [din1_WIDTH-1:0] mux_4_0;\n\n// Generate level 1 logic\nassign mux_1_0 = (sel[0] == 0) ? din1 : din2;\nassign mux_1_1 = (sel[0] == 0) ? din3 : din4;\nassign mux_1_2 = (sel[0] == 0) ? din5 : din6;\nassign mux_1_3 = (sel[0] == 0) ? din7 : din8;\nassign mux_1_4 = (sel[0] == 0) ? din9 : din10;\nassign mux_1_5 = (sel[0] == 0) ? din11 : din12;\nassign mux_1_6 = (sel[0] == 0) ? din13 : din14;\nassign mux_1_7 = (sel[0] == 0) ? din15 : din16;\n\n// Generate level 2 logic\nassign mux_2_0 = (sel[1] == 0) ? mux_1_0 : mux_1_1;\nassign mux_2_1 = (sel[1] == 0) ? mux_1_2 : mux_1_3;\nassign mux_2_2 = (sel[1] == 0) ? mux_1_4 : mux_1_5;\nassign mux_2_3 = (sel[1] == 0) ? mux_1_6 : mux_1_7;\n\n// Generate level 3 logic\nassign mux_3_0 = (sel[2] == 0) ? mux_2_0 : mux_2_1;\nassign mux_3_1 = (sel[2] == 0) ? mux_2_2 : mux_2_3;\n\n// Generate level 4 logic\nassign mux_4_0 = (sel[3] == 0) ? mux_3_0 : mux_3_1;\n\n// Output logic\nassign dout = mux_4_0;\n\nendmodule",
        "module_name": "mux_16to1_sel4_7_1 #",
        "module_hash": "7611abd498268d9e4a861f18cbab555a",
        "dataset_index": 3328
      },
      "up_down_counter_5f1ecdd0": {
        "rtl_code": "module up_down_counter (\n    input CLK,\n    input UD,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (UD == 1'b0) begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end else begin\n            if (Q == 4'b0000) begin\n                Q <= 4'b1111;\n            end else begin\n                Q <= Q - 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "5f1ecdd0ba73f56891edf134e524415a",
        "dataset_index": 1265
      },
      "nios_system_alu_control_9633994c": {
        "rtl_code": "module nios_system_alu_control (\n                                 // inputs:\n                                  address,\n                                  chipselect,\n                                  clk,\n                                  reset_n,\n                                  write_n,\n                                  writedata,\n\n                                 // outputs:\n                                  out_port,\n                                  readdata\n                               )\n;\n\n  output  [  2: 0] out_port;\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            chipselect;\n  input            clk;\n  input            reset_n;\n  input            write_n;\n  input   [ 31: 0] writedata;\n\n  wire             clk_en;\n  reg     [  2: 0] data_out;\n  wire    [  2: 0] out_port;\n  wire    [  2: 0] read_mux_out;\n  wire    [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {3 {(address == 0)}} & data_out;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          data_out <= 0;\n      else if (chipselect && ~write_n && (address == 0))\n          data_out <= writedata[2 : 0];\n    end\n\n\n  assign readdata = {32'b0 | read_mux_out};\n  assign out_port = data_out;\n\nendmodule",
        "module_name": "nios_system_alu_control",
        "module_hash": "9633994cec42a74f2bd9be50cbeb8853",
        "dataset_index": 8058
      },
      "sequence_detector_b4f39860": {
        "rtl_code": "\nmodule sequence_detector (\n  input in,\n  output out,\n  input clk,\n  input reset\n);\n\n  // define your inputs and outputs here\n  reg [1:0] state;\n  parameter START = 2'b00;\n  parameter FINAL = 2'b01;\n  \n  // define your states and transitions here\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      state <= START;\n    end else begin\n      case(state)\n        START: begin\n          if (in == 1'b1) begin\n            state <= FINAL;\n          end else begin\n            state <= START;\n          end\n        end\n        FINAL: begin\n          if (in == 1'b0) begin\n            state <= START;\n          end else begin\n            state <= FINAL;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // define your combinational logic circuit here\n  assign out = (state == FINAL);\nendmodule",
        "module_name": "sequence_detector",
        "module_hash": "b4f39860c10a6776ba3554cb0fafad0c",
        "dataset_index": 6365
      },
      "voltage_supply_circuit_24957fd3": {
        "rtl_code": "\nmodule voltage_supply_circuit (\n    X,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n    input C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Instantiate the gates\n    wire X_int;\n    nand3 U1 (A1, A2, A3, X_int);\n    nand2 U2 (B1, C1, X);\n\nendmodule\n\nmodule nand3 (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    assign Y = ~(A & B & C);\nendmodule\n\nmodule nand2 (\n    input A,\n    input B,\n    output Y\n);\n\n    assign Y = ~(A & B);\nendmodule\n",
        "module_name": "voltage_supply_circuit",
        "module_hash": "24957fd37c6f31f5fd1d0515835550ea",
        "dataset_index": 20453
      },
      "mux_6to1_14002446": {
        "rtl_code": "\nmodule mux_6to1 (\n    input [2:0] sel,\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [3:0] in4,\n    input [3:0] in5,\n    output [3:0] out\n);\n\n    // Using a variable to store the internal output\n    reg [3:0] mux_out_int;\n\n    always @(*) begin\n        case (sel)\n            3'b000: mux_out_int = in0;\n            3'b001: mux_out_int = in1;\n            3'b010: mux_out_int = in2;\n            3'b011: mux_out_int = in3;\n            3'b100: mux_out_int = in4;\n            3'b101: mux_out_int = in5;\n            default: mux_out_int = 4'b0000;\n        endcase\n    end\n\n    // Assign the internal output to the external output\n    assign out = mux_out_int;\n\nendmodule\n",
        "module_name": "mux_6to1",
        "module_hash": "140024468d132fde36eb9d34e85273e4",
        "dataset_index": 16454
      },
      "value_buffer_4d09df54": {
        "rtl_code": "module value_buffer(\n\tclk,\n\tc0_in,\n\tc1_in,\n\tc2_in,\n\tc3_in,\n\tc0_up,\n\tc1_up,\n\tc2_up,\n\tc3_up,\n\tc0_down,\n\tc1_down,\n\tc2_down,\n\tc3_down\n);\n\t\ninput  clk;\ninput  [63:0] c0_in;\ninput  [63:0] c1_in;\ninput  [63:0] c2_in;\ninput  [63:0] c3_in;\n\noutput [63:0] c0_up;\noutput [63:0] c1_up;\noutput [63:0] c2_up;\noutput [63:0] c3_up;\n\noutput [63:0] c0_down;\noutput [63:0] c1_down;\noutput [63:0] c2_down;\noutput [63:0] c3_down;\n\nreg [63:0] buffer0;\nreg [63:0] buffer1;\nreg [63:0] buffer2;\nreg [63:0] buffer3;\n\nalways@(posedge clk) begin\n  buffer0 <= c0_in;\n  buffer1 <= c1_in;\n  buffer2 <= c2_in;\n  buffer3 <= c3_in; \n  end\n\nassign c0_down = buffer0;\nassign c1_down = buffer1;\nassign c2_down = buffer2;\nassign c3_down = buffer3;\n\nassign c0_up = buffer1;\nassign c1_up = buffer2;\nassign c2_up = buffer3;\nassign c3_up = c0_in;\n  \nendmodule\n",
        "module_name": "value_buffer",
        "module_hash": "4d09df54154448a1de412b8ca7b95e70",
        "dataset_index": 22408
      },
      "clock_divider_fe29fd7c": {
        "rtl_code": "module clock_divider (\n    input wire CLK,\n    input wire RESET,\n    input wire CE,\n    output reg CLOCK\n);\n\n    parameter DIVISOR = 8;\n    reg [DIVISOR-1:0] counter;\n    \n    always @(posedge CLK or negedge RESET) begin\n        if (!RESET) begin\n            counter <= 0;\n            CLOCK <= 0;\n        end else if (CE) begin\n            counter <= counter + 1;\n            if (counter == DIVISOR-1) begin\n                counter <= 0;\n                CLOCK <= ~CLOCK;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "clock_divider",
        "module_hash": "fe29fd7cbe1a3f97cdb5b915010b3538",
        "dataset_index": 12593
      },
      "axi_protocol_converter_v2_1_b2s_incr_cmd #_8d8daa4f": {
        "rtl_code": "\n\n\n \nmodule axi_protocol_converter_v2_1_b2s_incr_cmd #\n(\nparameter integer C_AXI_ADDR_WIDTH            = 32\n)\n(\ninput  wire                                 clk           ,\n  input  wire                                 reset         ,\n  input  wire [C_AXI_ADDR_WIDTH-1:0]          axaddr        ,\n  input  wire [7:0]                           axlen         ,\n  input  wire [2:0]                           axsize        ,\n  input  wire                                 axhandshake   ,\n  output wire [C_AXI_ADDR_WIDTH-1:0]          cmd_byte_addr ,\n  input  wire                                 next          ,\n  output reg                                  next_pending\n\n);\nreg                           sel_first;\nreg  [11:0]                   axaddr_incr;\nreg  [8:0]                    axlen_cnt;\nreg                           next_pending_r;\nwire [3:0]                    axsize_shift;\nwire [11:0]                   axsize_mask;\n\nlocalparam    L_AXI_ADDR_LOW_BIT = (C_AXI_ADDR_WIDTH >= 12) ? 12 : 11;\n\ngenerate\n  if (C_AXI_ADDR_WIDTH > 12) begin : ADDR_GT_4K\n    assign cmd_byte_addr = (sel_first) ? axaddr : {axaddr[C_AXI_ADDR_WIDTH-1:L_AXI_ADDR_LOW_BIT],axaddr_incr[11:0]};\n  end else begin : ADDR_4K\n    assign cmd_byte_addr = (sel_first) ? axaddr : axaddr_incr[11:0];\n  end\nendgenerate\n\nassign axsize_shift = (1 << axsize[1:0]);\nassign axsize_mask  = ~(axsize_shift - 1'b1);\n\nalways @(posedge clk) begin\n  if (sel_first) begin\n    if(~next) begin\n      axaddr_incr <= axaddr[11:0] & axsize_mask;\n    end else begin\n      axaddr_incr <= (axaddr[11:0] & axsize_mask) + axsize_shift;\n    end\n  end else if (next) begin\n    axaddr_incr <= axaddr_incr + axsize_shift;\n  end\nend\n\nalways @(posedge clk) begin\n  if (axhandshake)begin\n     axlen_cnt <= axlen;\n     next_pending_r <= (axlen >= 1);\n  end else if (next) begin\n    if (axlen_cnt > 1) begin\n      axlen_cnt <= axlen_cnt - 1;\n      next_pending_r <= ((axlen_cnt - 1) >= 1);\n    end else begin\n      axlen_cnt <= 9'd0;\n      next_pending_r <= 1'b0;\n    end\n  end\nend\n\nalways @( * ) begin\n  if (axhandshake)begin\n     next_pending = (axlen >= 1);\n  end else if (next) begin\n    if (axlen_cnt > 1) begin\n      next_pending = ((axlen_cnt - 1) >= 1);\n    end else begin\n      next_pending = 1'b0;\n    end\n  end else begin\n    next_pending = next_pending_r;\n  end\nend\n\nalways @(posedge clk) begin\n  if (reset | axhandshake) begin\n    sel_first <= 1'b1;\n  end else if (next) begin\n    sel_first <= 1'b0;\n  end\nend\n\nendmodule\n\n",
        "module_name": "axi_protocol_converter_v2_1_b2s_incr_cmd #",
        "module_hash": "8d8daa4f0ceae6ac38f0abeb48a81638",
        "dataset_index": 3612
      },
      "nor_gate_9bd74f71": {
        "rtl_code": "\nmodule nor_gate(\n    input a,\n    input b,\n    output out\n);\n    wire temp1, temp2;\n    not_gate not1(a, temp1);\n    not_gate not2(b, temp2);\n    and_gate and1(temp1, temp2, out);\nendmodule\nmodule shift_register(\n    input clk,\n    input rst,\n    input data,\n    output reg [2:0] out\n);\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            out <= 3'b0;\n        end else begin\n            out[2:1] <= out[1:0];\n            out[0] <= data;\n        end\n    end\nendmodule\nmodule or_module(\n    input a,\n    input [2:0] b,\n    output out\n);\n    wire temp1, temp2;\n    nor_gate nor1(a, b[0], temp1);\n    nor_gate nor2(temp1, b[1], temp2);\n    nor_gate nor3(temp2, b[2], out);\nendmodule\nmodule top_module(\n    input a,\n    input b,\n    input clk,\n    input rst,\n    input data,\n    output out\n);\n    wire [2:0] shift_out;\n    shift_register shift_reg(clk, rst, data, shift_out);\n    or_module or_mod(a, shift_out, out);\nendmodule\nmodule not_gate(\n    input in,\n    output out\n);\n    assign out = !in;\nendmodule\nmodule and_gate(\n    input a,\n    input b,\n    output out\n);\n    assign out = a && b;\nendmodule\nmodule nor_gate_level(\n    input a,\n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule",
        "module_name": "nor_gate",
        "module_hash": "9bd74f71b9f1c5dc53c231cefe18c39a",
        "dataset_index": 14595
      },
      "asfifo_graycounter #_7c16239c": {
        "rtl_code": "\n\n\n\nmodule asfifo_graycounter #(\n\tparameter width = 2\n) (\n\toutput reg [width-1:0] gray_count,\n\tinput ce,\n\tinput rst,\n\tinput clk\n);\n\nreg [width-1:0] binary_count;\n\nalways @(posedge clk, posedge rst) begin\n\tif(rst) begin\n\t\tbinary_count <= {width{1'b0}} + 1;\n\t\tgray_count <= {width{1'b0}};\n\tend else if(ce) begin\n\t\tbinary_count <= binary_count + 1;\n\t\tgray_count <= {binary_count[width-1],\n\t\t\t\tbinary_count[width-2:0] ^ binary_count[width-1:1]};\n\tend\nend\n\nendmodule\n",
        "module_name": "asfifo_graycounter #",
        "module_hash": "7c16239c89625908c4d26d36c3c15cd2",
        "dataset_index": 24747
      },
      "etx_cfg_28ede952": {
        "rtl_code": "module etx_cfg (\n   input reset,\n   input clk,\n   input mi_en,\n   input mi_we,\n   input [6:0] mi_addr,\n   input [31:0] mi_din,\n   input [15:0] tx_status,\n   output [31:0] mi_dout,\n   output tx_enable,\n   output mmu_enable,\n   output gpio_enable,\n   output remap_enable,\n   output [8:0] gpio_data,\n   output [3:0] ctrlmode,\n   output ctrlmode_bypass\n);\n\n   // Compile-time parameters\n   parameter PW = 104;\n   parameter RFAW = 6;\n   parameter DEFAULT_VERSION = 16'h0000;\n\n   // Registers\n   reg [15:0] ecfg_version_reg;\n   reg [10:0] ecfg_tx_config_reg;\n   reg [8:0] ecfg_tx_gpio_reg;\n   reg [2:0] ecfg_tx_status_reg;\n   reg [31:0] mi_dout;\n   reg ecfg_access;\n\n   // Wires\n   wire ecfg_read;\n   wire ecfg_write;\n   wire ecfg_version_write;\n   wire ecfg_tx_config_write;\n   wire ecfg_tx_gpio_write;\n   wire ecfg_tx_status_write;\n   wire loop_mode;\n\n   // Address decode logic\n   assign ecfg_write = mi_en & mi_we;\n   assign ecfg_read = mi_en & ~mi_we;\n   assign ecfg_version_write = ecfg_write & (mi_addr[6:2] == 5'b00000);\n   assign ecfg_tx_config_write = ecfg_write & (mi_addr[6:2] == 5'b00010);\n   assign ecfg_tx_status_write = ecfg_write & (mi_addr[6:2] == 5'b00011);\n   assign ecfg_tx_gpio_write = ecfg_write & (mi_addr[6:2] == 5'b00100);\n\n   // Version register\n   always @(posedge clk) begin\n      if (reset) begin\n         ecfg_version_reg <= DEFAULT_VERSION;\n      end else if (ecfg_version_write) begin\n         ecfg_version_reg <= mi_din[15:0];\n      end\n   end\n\n   // Configuration register\n   always @(posedge clk) begin\n      if (reset) begin\n         ecfg_tx_config_reg <= 11'b0;\n      end else if (ecfg_tx_config_write) begin\n         ecfg_tx_config_reg <= mi_din[10:0];\n      end\n   end\n\n   // Status register\n   always @(posedge clk) begin\n      if (reset) begin\n         ecfg_tx_status_reg <= 3'b0;\n      end else if (ecfg_tx_status_write) begin\n         ecfg_tx_status_reg <= {3'b0, tx_status[2:0]};\n      end\n   end\n\n   // GPIO data register\n   always @(posedge clk) begin\n      if (ecfg_tx_gpio_write) begin\n         ecfg_tx_gpio_reg <= mi_din[8:0];\n      end\n   end\n\n   // Data readback mux\n   always @(posedge clk) begin\n      if (ecfg_read) begin\n         case (mi_addr[6:2])\n            5'b00000: mi_dout <= {16'b0, ecfg_version_reg};\n            5'b00010: mi_dout <= {21'b0, ecfg_tx_config_reg};\n            5'b00011: mi_dout <= {16'b0, tx_status[15:3], ecfg_tx_status_reg};\n            5'b00100: mi_dout <= {23'b0, ecfg_tx_gpio_reg};\n            default: mi_dout <= 32'd0;\n         endcase\n      end else begin\n         mi_dout <= 32'd0;\n      end\n   end\n\n   // Control signals\n   assign tx_enable = 1'b1;\n   assign mmu_enable = ecfg_tx_config_reg[1];\n   assign remap_enable = ecfg_tx_config_reg[3:2] == 2'b01;\n   assign ctrlmode[3:0] = ecfg_tx_config_reg[7:4];\n   assign ctrlmode_bypass = ecfg_tx_config_reg[8];\n   assign gpio_enable = (ecfg_tx_config_reg[10:9] == 2'b01);\n   assign gpio_data[8:0] = ecfg_tx_gpio_reg[8:0];\n\nendmodule",
        "module_name": "etx_cfg",
        "module_hash": "28ede952659b134967dcdd21dd5fd782",
        "dataset_index": 12550
      },
      "rj45_led_controller_d63b2e77": {
        "rtl_code": "module rj45_led_controller(\n  input  wire         clk,  // 150 MHz\n  input  wire         reset,\n\n  //--------------------------------------------------------------------------\n  //------------------------CONTROL INTERFACE---------------------------------\n  //--------------------------------------------------------------------------\n  input  wire        write_req,\n  input  wire        read_req,\n  input  wire [31:0] data_write,\n  output reg  [31:0] data_read,\n  input  wire [25:0] address,\n  output wire        busy,\n\n  //--------------------------------------------------------------------------\n  //---------------------------HW INTERFACE-----------------------------------\n  //--------------------------------------------------------------------------\n  output wire         rj45_led_sck,\n  output wire         rj45_led_sin,\n  output wire         rj45_led_lat,\n  output wire         rj45_led_blk\n);\n\nlocalparam IDLE   = 3'd0,\n           READ   = 3'd1,\n           WRITE  = 4'd2;\nlocalparam CLK_DIV = 3;\n\nwire update_out;\n\nreg [CLK_DIV:0] clk_div1;\nreg [CLK_DIV:0] clk_div2;\nreg             clk_enable;\nreg [15:0]      output_shifter;\nreg [4:0]       write_counter;\nreg             latch;\n\nreg [2:0]       state;\nreg             busy_int;\nreg [31:0]      value_cache;\n\nassign rj45_led_sck = clk_div2[CLK_DIV] & clk_enable;\nassign rj45_led_sin = output_shifter[15];\nassign rj45_led_lat = latch;\nassign rj45_led_blk = 0;\n\nassign update_out = ~clk_div1[CLK_DIV] & clk_div2[CLK_DIV]; // negedge serial clock\nassign busy = busy_int | read_req | write_req;\n\nalways @( posedge clk ) begin\n  if ( reset ) begin\n    clk_div1 <= 0;\n    clk_div2 <= 0;\n  end\n  else begin\n    clk_div2 <= clk_div1;\n    clk_div1 <= clk_div1 + 1;\n  end\nend\n\nalways @( posedge clk ) begin\n  if ( reset ) begin\n    state <= IDLE;\n    clk_enable <= 0;\n    output_shifter <= 16'h0000;\n    write_counter <= 5'h00;\n    latch <= 0;\n    busy_int <= 1;\n    value_cache <= 32'd0;\n  end\n  else begin\n    case ( state )\n      IDLE: begin\n        data_read <= 32'd0;\n        if ( write_req ) begin\n          state <= WRITE;\n          busy_int <= 1;\n          output_shifter <= {1'b0, data_write[0], 1'b0, data_write[1],\n                             1'b0, data_write[2], 1'b0, data_write[3],\n                             1'b0, data_write[4], 1'b0, data_write[5],\n                             1'b0, data_write[6], 1'b0, data_write[7]};\n          value_cache <= {24'd0, data_write[7:0]};\n          write_counter <= 0;\n\n        end\n        else if ( read_req ) begin\n          state <= READ;\n          busy_int <= 1;\n        end\n        else begin\n          busy_int <= 0;\n        end\n      end\n      WRITE: begin\n        if ( update_out ) begin\n          write_counter <= write_counter + 5'd1;\n          if ( write_counter == 0 ) begin\n            clk_enable <= 1;\n          end\n          else if ( write_counter < 5'd16) begin\n            output_shifter <= {output_shifter[14:0], 1'b0};\n          end\n          else if ( write_counter == 5'd16 ) begin\n            clk_enable <= 0;\n            latch <= 1;\n          end\n          else begin\n            state <= IDLE;\n            latch <= 0;\n            busy_int <= 0;\n          end\n        end\n      end\n      READ: begin\n        state <= IDLE;\n        busy_int <= 0;\n        data_read <= value_cache;\n      end\n    endcase\n  end\nend\n\nendmodule",
        "module_name": "rj45_led_controller",
        "module_hash": "d63b2e77acab1c9710b43781c40619e8",
        "dataset_index": 17249
      },
      "ClockGenerator_75d1d648": {
        "rtl_code": "module ClockGenerator (\n    input clk_in,\n    output reg clk_out\n);\n\n    // Clock period in ps\n    localparam PER = 20;\n\n    // Number of cycles for a 50 MHz clock\n    localparam COUNT_50MHZ = 100;\n\n    // Number of cycles for a 100 MHz clock\n    localparam COUNT_100MHZ = 50;\n\n    // Counter to keep track of the number of cycles\n    reg [7:0] counter = 0;\n\n    // Flip-flop to toggle the clock signal\n    always @(posedge clk_in) begin\n        counter <= counter + 1;\n        if (counter == COUNT_100MHZ) begin\n            counter <= 0;\n            clk_out <= ~clk_out;\n        end\n    end\n\n    // Frequency checker\n    reg [31:0] count = 0;\n    reg [31:0] expected_count = 0;\n    reg locked = 0;\n\n    always @(posedge clk_out) begin\n        count <= count + 1;\n        if (count == COUNT_50MHZ) begin\n            count <= 0;\n            if (expected_count == 0) begin\n                expected_count <= COUNT_50MHZ;\n            end else if (expected_count == COUNT_50MHZ) begin\n                expected_count <= COUNT_100MHZ;\n            end else if (expected_count == COUNT_100MHZ) begin\n                expected_count <= COUNT_50MHZ;\n            end\n\n            if (count == expected_count) begin\n                locked <= 1;\n            end else begin\n                locked <= 0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "ClockGenerator",
        "module_hash": "75d1d6482d5da43ea953b58c48dbd807",
        "dataset_index": 2992
      },
      "Floating_Point_Arithmetic_189ca2d3": {
        "rtl_code": "\nmodule Floating_Point_Arithmetic (\n  input [31:0] operand1,\n  input [31:0] operand2,\n  input [1:0] operation,\n  output reg [31:0] result\n);\n\nparameter mantissa_width = 23; // width of the mantissa in bits\nparameter exponent_width = 8; // width of the exponent in bits\nparameter bias = 127; // bias of the exponent field\n\nreg [31:0] add_result, sub_result, mul_result, div_result;\nreg [31:0] operand2_neg;\n\n// Negate operand2 for subtraction\nalways @(*) begin\n  operand2_neg = {operand2[31], ~operand2[30:0] + 1'b1};\nend\n\n// Floating-point addition\nalways @(*) begin\n  add_result = operand1 + operand2;\nend\n\n// Floating-point subtraction\nalways @(*) begin\n  sub_result = operand1 - operand2_neg;\nend\n\n// Floating-point multiplication\nalways @(*) begin\n  mul_result = operand1 * operand2;\nend\n\n// Floating-point division\nalways @(*) begin\n  div_result = operand1 / operand2;\nend\n\n// Select the result based on the operation\nalways @(*) begin\n  case (operation)\n    2'b00: result = add_result;\n    2'b01: result = sub_result;\n    2'b10: result = mul_result;\n    2'b11: result = div_result;\n    default: result = 32'b0;\n  endcase\nend\n\nendmodule",
        "module_name": "Floating_Point_Arithmetic",
        "module_hash": "189ca2d31e6d6a053d7d102d76c6cf09",
        "dataset_index": 3670
      },
      "DPR16X4C_63b9b180": {
        "rtl_code": "\nmodule DPR16X4C (\n    input [3:0] DI,\n    input WCK, WRE,\n    input [3:0] RAD,\n    input [3:0] WAD,\n    output [3:0] DO\n);\n\n    reg [3:0] ram[0:15];\n    integer i;\n\n    function [63:0] convert_initval;\n        input [143:0] hex_initval;\n        reg done;\n        reg [63:0] temp;\n        reg [7:0] char;\n        integer i;\n        begin\n            done = 1'b0;\n            temp = 0;\n            for (i = 0; i < 16; i = i + 1) begin\n                if (!done) begin\n                    char = hex_initval[8*i +: 8];\n                    if (char == \"x\") begin\n                        done = 1'b1;\n                    end else begin\n                        if (char >= \"0\" && char <= \"9\")\n                            temp[4*i +: 4] = char - \"0\";\n                        else if (char >= \"A\" && char <= \"F\")\n                            temp[4*i +: 4] = 10 + char - \"A\";\n                        else if (char >= \"a\" && char <= \"f\")\n                            temp[4*i +: 4] = 10 + char - \"a\";\n                    end\n                end\n            end\n            convert_initval = temp;\n        end\n    endfunction\n\n    localparam conv_initval = convert_initval(\"1011111000001111101111100000111111011110000011111110111000001111\");\n\n    initial begin\n        for (i = 0; i < 15; i = i + 1) begin\n            ram[i] <= conv_initval[4*i +: 4];\n        end\n    end\n\n    always @(posedge WCK) begin\n        if (WRE) begin\n            ram[WAD] <= DI;\n        end\n    end\n\n    assign DO = (RAD > 15) ? 0 : ram[RAD];\n\nendmodule\n",
        "module_name": "DPR16X4C",
        "module_hash": "63b9b180882b7dcfdd44a621148987d7",
        "dataset_index": 5526
      },
      "_4bit_binary_counter_a4074364": {
        "rtl_code": "module _4bit_binary_counter(\n    input CP,\n    input M,\n    input [3:0] D,\n    input LD_n,\n    input CLR_n,\n    output reg [3:0] Q,\n    output reg Qcc_n\n);\n    always @(posedge CP) begin\n        if (CLR_n == 0) begin\n            Q <= 0;\n        end else if (LD_n == 0) begin\n            Q <= D;\n        end else if (M == 1) begin\n            Q <= Q + 1;\n        end\n        Qcc_n <= ~Q[3];\n    end\nendmodule",
        "module_name": "_4bit_binary_counter",
        "module_hash": "a40743649a33032cdadfd1c91ee797b5",
        "dataset_index": 9939
      },
      "dual_port_ram_158b3163": {
        "rtl_code": "module dual_port_ram (\n  input clock,\n  input [31:0] data_a,\n  input wren_a,\n  input [4:0] address_a,\n  input [31:0] data_b,\n  input wren_b,\n  input [4:0] address_b,\n  input rd_en_a,\n  input rd_en_b,\n  output reg [31:0] q_a,\n  output reg [31:0] q_b\n);\n\n  reg [31:0] mem [0:31];\n\n  always @(posedge clock) begin\n    if (wren_a) mem[address_a] <= data_a;\n    if (wren_b) mem[address_b] <= data_b;\n    if (rd_en_a) q_a <= mem[address_a];\n    if (rd_en_b) q_b <= mem[address_b];\n  end\n\nendmodule",
        "module_name": "dual_port_ram",
        "module_hash": "158b3163ebca1edb7aac7935bc9c3a68",
        "dataset_index": 17349
      },
      "uart51_tx_c989dae1": {
        "rtl_code": "module uart51_tx (\n    input BAUD_CLK,\n    input RESET_N,\n    output reg TX_DATA,\n    input TX_START,\n    output reg TX_DONE,\n    input TX_STOP,\n    input [1:0] TX_WORD,\n    input TX_PAR_DIS,\n    input [1:0] TX_PARITY,\n    input CTS,\n    input [7:0] TX_BUFFER\n);\n\n    reg [6:0] STATE;\n    reg [2:0] BIT;\n    wire PARITY;\n    reg TX_START0;\n    reg TX_START1;\n\n    assign PARITY = (~TX_PARITY[1] & ((TX_BUFFER[0] ^ TX_BUFFER[1]) ^ (TX_BUFFER[2] ^ TX_BUFFER[3])) ^ (TX_BUFFER[4] ^ (TX_BUFFER[5] & (TX_WORD != 2'b00))) ^ ((TX_BUFFER[6] & (TX_WORD[1] == 1'b1)) ^ (TX_BUFFER[7] & (TX_WORD == 2'b11)))) ^ ~TX_PARITY[0];\n\n    always @ (negedge BAUD_CLK or negedge RESET_N) begin\n        if (!RESET_N) begin\n            STATE <= 7'b0000000;\n            TX_DATA <= 1'b1;\n            TX_DONE <= 1'b1;\n            BIT <= 3'b000;\n            TX_START0 <= 1'b0;\n            TX_START1 <= 1'b0;\n        end else begin\n            TX_START0 <= TX_START;\n            TX_START1 <= TX_START0;\n            case (STATE)\n                7'b0000000: begin\n                    BIT <= 3'b000;\n                    TX_DATA <= 1'b1;\n                    if (TX_START1 == 1'b1) begin\n                        TX_DONE <= 1'b0;\n                        STATE <= 7'b0000001;\n                    end\n                end\n                7'b0000001: begin // Start bit\n                    TX_DATA <= 1'b0;\n                    STATE <= 7'b0000010;\n                end\n                7'b0010001: begin\n                    TX_DATA <= TX_BUFFER[BIT];\n                    STATE <= 7'b0010010;\n                end\n                7'b0100000: begin\n                    BIT <= BIT + 1'b1;\n                    if ((TX_WORD == 2'b00) && (BIT != 3'b111)) begin\n                        STATE <= 7'b0010001;\n                    end else begin\n                        if ((TX_WORD == 2'b01) && (BIT != 3'b110)) begin\n                            STATE <= 7'b0010001;\n                        end else begin\n                            if ((TX_WORD == 2'b10) && (BIT != 3'b101)) begin\n                                STATE <= 7'b0010001;\n                            end else begin\n                                if ((TX_WORD == 2'b11) && (BIT != 3'b100)) begin\n                                    STATE <= 7'b0010001;\n                                end else begin\n                                    if (!TX_PAR_DIS) begin\n                                        STATE <= 7'b0100001; // do parity\n                                    end else begin\n                                        STATE <= 7'b0110001; // do stop\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n                // Start parity bit\n                7'b0100001: begin\n                    TX_DATA <= PARITY;\n                    STATE <= 7'b0100010;\n                end\n                // start stop\n                7'b0110001: begin\n                    TX_DONE <= 1'b1;\n                    TX_DATA <= 1'b1;\n                    STATE <= 7'b0110010;\n                end\n                // end of first stop bit-1\n                7'b0111111: begin\n                    if (!TX_STOP) begin\n                        STATE <= 7'b1001111; // go check for CTS\n                    end else begin\n                        STATE <= 7'b1000000;\n                    end\n                end\n                7'b1001111: begin\n                    if (!CTS) begin // this is not correct for a 6551\n                        STATE <= 7'b0000000;\n                    end\n                end\n                default: STATE <= STATE + 1'b1;\n            endcase\n        end\n    end\nendmodule",
        "module_name": "uart51_tx",
        "module_hash": "c989dae1e313347ebac8f900b1638ed0",
        "dataset_index": 9008
      },
      "fp_add_a5d30ac0": {
        "rtl_code": "\nmodule fp_add (\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  wire [31:0] a_mantissa;\n  wire [31:0] b_mantissa;\n  wire [7:0] a_exponent;\n  wire [7:0] b_exponent;\n  wire a_sign;\n  wire b_sign;\n  wire c_sign;\n  wire [7:0] c_exponent;\n  wire [31:0] c_mantissa;\n  wire carry;\n  wire [31:0] temp;\n\n  assign a_mantissa = {1'b1, a[22:0]};\n  assign b_mantissa = {1'b1, b[22:0]};\n  assign a_exponent = a[30:23];\n  assign b_exponent = b[30:23];\n  assign a_sign = a[31];\n  assign b_sign = b[31];\n\n  assign {c_sign, c_exponent, c_mantissa, carry} =\n    a_sign == b_sign ?\n    {a_sign, a_exponent, a_mantissa + b_mantissa, 1'b0} :\n    {a_mantissa > b_mantissa ? a_sign : b_sign,\n     a_exponent > b_exponent ? a_exponent : b_exponent,\n     a_mantissa > b_mantissa ? a_mantissa - b_mantissa : b_mantissa - a_mantissa,\n     a_mantissa > b_mantissa ? 1'b0 : 1'b1};\n\n  assign c = {c_sign, c_exponent, c_mantissa[22:0]};\n\nendmodule\nmodule fp_sub (\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  wire [31:0] a_mantissa;\n  wire [31:0] b_mantissa;\n  wire [7:0] a_exponent;\n  wire [7:0] b_exponent;\n  wire a_sign;\n  wire b_sign;\n  wire c_sign;\n  wire [7:0] c_exponent;\n  wire [31:0] c_mantissa;\n  wire borrow;\n  wire [31:0] temp;\n\n  assign a_mantissa = {1'b1, a[22:0]};\n  assign b_mantissa = {1'b1, b[22:0]};\n  assign a_exponent = a[30:23];\n  assign b_exponent = b[30:23];\n  assign a_sign = a[31];\n  assign b_sign = b[31];\n\n  assign {c_sign, c_exponent, c_mantissa, borrow} =\n    a_sign == b_sign ?\n    {a_sign, a_exponent, a_mantissa + b_mantissa, 1'b0} :\n    {a_mantissa > b_mantissa ? a_sign : !b_sign,\n     a_exponent > b_exponent ? a_exponent : b_exponent,\n     a_mantissa > b_mantissa ? a_mantissa - b_mantissa : b_mantissa - a_mantissa,\n     a_mantissa > b_mantissa ? 1'b0 : 1'b1};\n\n  assign c = {c_sign, c_exponent, c_mantissa[22:0]};\n\nendmodule\nmodule fp_mul (\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  wire [31:0] a_mantissa;\n  wire [31:0] b_mantissa;\n  wire [7:0] a_exponent;\n  wire [7:0] b_exponent;\n  wire a_sign;\n  wire b_sign;\n  wire c_sign;\n  wire [7:0] c_exponent;\n  wire [63:0] temp;\n\n  assign a_mantissa = {1'b1, a[22:0]};\n  assign b_mantissa = {1'b1, b[22:0]};\n  assign a_exponent = a[30:23];\n  assign b_exponent = b[30:23];\n  assign a_sign = a[31];\n  assign b_sign = b[31];\n  assign temp = a_mantissa * b_mantissa;\n\n  assign c_sign = a_sign ^ b_sign;\n  assign c_exponent = a_exponent + b_exponent - 127;\n  assign c = {c_sign, c_exponent, temp[54:23]};\n\nendmodule",
        "module_name": "fp_add",
        "module_hash": "a5d30ac06d10b028a1d6a3f200fb7ffe",
        "dataset_index": 13645
      },
      "mux_2to1_aa91dbdc": {
        "rtl_code": "module mux_2to1(\n    input a, b, c, d,\n    output x, y, z\n);\n\nassign x = c ? a : b;\nassign y = c ? b : a;\nassign z = c ? d : b;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "aa91dbdc03631433ae38a0ccde233eea",
        "dataset_index": 3117
      },
      "binary_counter_6097dd5e": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\n    reg [3:0] next_count;\n    reg [3:0] curr_count;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            curr_count <= 4'b0000;\n            count <= curr_count;\n        end else begin\n            next_count <= curr_count + 4'b0001;\n            curr_count <= next_count;\n            count <= curr_count;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "6097dd5e1bbea7fbd4697f8780957c0f",
        "dataset_index": 20226
      },
      "coordinate_cordic_c0ae1266": {
        "rtl_code": "module coordinate_cordic\n(\n\trealIn,\n\timagIn,\n\tclk,\n\tamplitude,\n\tangle,\n\ttest1,\n\ttest2\n);\n\ninput signed [INWIDTH-1:0]realIn,imagIn;\ninput clk;\noutput signed [OUTWIDTH-1:0]amplitude;\noutput signed [ANGLEWIDTH-1:0]angle;\n\ninput  [9:0] test1;\noutput  [9:0] test2;\nassign  test2 = {11{test1}};\nparameter INWIDTH = 18,  OUTWIDTH = 20, MIDWIDTH = 21, ANGLEWIDTH =15;parameter ARCTANG_0  = 12'b10_01110_00100,ARCTANG_1  = 11'b1_01110_00100,ARCTANG_2  = 10'b11000_01100,ARCTANG_3  = 9'b1100_01100,ARCTANG_4  = 8'b110_00111,ARCTANG_5  = 7'b11_00011,ARCTANG_6  = 6'b1_10010,ARCTANG_7  = 5'b11001,ARCTANG_8  = 4'b1100,ARCTANG_9  = 3'b110,ARCTANG_10 = 2'b11,ARCTANG_11 = 2'b10;parameter HALFPI = 13'b100_11100_01000;reg signed [MIDWIDTH-1:0]xData1,xData2,xData3,xData4,xData5,xData6,\n                         xData7,xData8,xData9,xData10,xData11,xData12,\n                         xData13,xData14,xData15,xData16,\n\t\t\t\t         yData1,yData2,yData3,yData4,yData5,yData6,\n\t\t\t\t         yData7,yData8,yData9,yData10,yData11,yData12,\n\t\t\t\t         yData13,yData14,yData15,yData16;\n\nreg signed [ANGLEWIDTH-1:0]angle1,angle2,angle3,angle4,angle5,angle6,\n\t\t\t\t\t       angle7,angle8,angle9,angle10,angle11,angle12,\n\t\t\t\t\t       angle13,angle14,angle15,angle16;\n\n\nwire signed [MIDWIDTH-1:0]reIn,imIn;\nwire signed [ANGLEWIDTH-1:0]ang;\nassign reIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-imagIn:imagIn):realIn;\nassign imIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?realIn:-realIn):imagIn;\nassign ang = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-HALFPI:HALFPI):1'b0;\n\n\nassign amplitude = {xData12[MIDWIDTH-1],xData12[MIDWIDTH-3:0]};\nassign angle = angle12;\n\n\n\nalways@(posedge clk)\nbegin\n    xData1 <= imIn[MIDWIDTH-1]?(reIn - imIn):(reIn + imIn);\n\tyData1 <= imIn[MIDWIDTH-1]?(imIn + reIn):(imIn - reIn);\n\tangle1 <= imIn[MIDWIDTH-1]?(ang - ARCTANG_0):(ang + ARCTANG_0);\n\n    xData2 <= yData1[MIDWIDTH-1]?(xData1 - {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]}):(xData1 + {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]});\n\tyData2 <= yData1[MIDWIDTH-1]?(yData1 + {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]}):(yData1 - {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]});\n\tangle2 <= yData1[MIDWIDTH-1]?(angle1 - ARCTANG_1):(angle1 + ARCTANG_1);\n\n    xData3 <= yData2[MIDWIDTH-1]?(xData2 - {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]}):(xData2 + {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]});\n\tyData3 <= yData2[MIDWIDTH-1]?(yData2 + {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]}):(yData2 - {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]});\n\tangle3 <= yData2[MIDWIDTH-1]?(angle2 - ARCTANG_2):(angle2 + ARCTANG_2);\n\n    xData4 <= yData3[MIDWIDTH-1]?(xData3 - {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]}):(xData3 + {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]});\n\tyData4 <= yData3[MIDWIDTH-1]?(yData3 + {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]}):(yData3 - {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]});\n\tangle4 <= yData3[MIDWIDTH-1]?(angle3 - ARCTANG_3):(angle3 + ARCTANG_3);\n\n    xData5 <= yData4[MIDWIDTH-1]?(xData4 - {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]}):(xData4 + {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]});\n\tyData5 <= yData4[MIDWIDTH-1]?(yData4 + {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]}):(yData4 - {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]});\n\tangle5 <= yData4[MIDWIDTH-1]?(angle4 - ARCTANG_4):(angle4 + ARCTANG_4);\n\n    xData6 <= yData5[MIDWIDTH-1]?(xData5 - {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]}):(xData5 + {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]});\n\tyData6 <= yData5[MIDWIDTH-1]?(yData5 + {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]}):(yData5 - {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]});\n\tangle6 <= yData5[MIDWIDTH-1]?(angle5 - ARCTANG_5):(angle5 + ARCTANG_5);\n\n    xData7 <= yData6[MIDWIDTH-1]?(xData6 - {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]}):(xData6 + {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]});\n\tyData7 <= yData6[MIDWIDTH-1]?(yData6 + {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]}):(yData6 - {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]});\n\tangle7 <= yData6[MIDWIDTH-1]?(angle6 - ARCTANG_6):(angle6 + ARCTANG_6);\n\n    xData8 <= yData7[MIDWIDTH-1]?(xData7 - {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]}):(xData7 + {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]});\n\tyData8 <= yData7[MIDWIDTH-1]?(yData7 + {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]}):(yData7 - {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]});\n\tangle8 <= yData7[MIDWIDTH-1]?(angle7 - ARCTANG_7):(angle7 + ARCTANG_7);\n\n    xData9 <= yData8[MIDWIDTH-1]?(xData8 - {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]}):(xData8 + {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]});\n\tyData9 <= yData8[MIDWIDTH-1]?(yData8 + {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]}):(yData8 - {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]});\n\tangle9 <= yData8[MIDWIDTH-1]?(angle8 - ARCTANG_8):(angle8 + ARCTANG_8);\n\n    xData10 <= yData9[MIDWIDTH-1]?(xData9 - {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]}):(xData9 + {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]});\n\tyData10 <= yData9[MIDWIDTH-1]?(yData9 + {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]}):(yData9 - {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]});\n\tangle10 <= yData9[MIDWIDTH-1]?(angle9 - ARCTANG_9):(angle9 + ARCTANG_9);\n\n    xData11 <= yData10[MIDWIDTH-1]?(xData10 - {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]}):(xData10 + {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]});\n\tyData11 <= yData10[MIDWIDTH-1]?(yData10 + {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]}):(yData10 - {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]});\n\tangle11 <= yData10[MIDWIDTH-1]?(angle10 - ARCTANG_10):(angle10 + ARCTANG_10);\n\n    xData12 <= yData11[MIDWIDTH-1]?(xData11 - {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]}):(xData11 + {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]});\n\tyData12 <= yData11[MIDWIDTH-1]?(yData11 + {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]}):(yData11 - {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]});\n\tangle12 <= yData11[MIDWIDTH-1]?(angle11 - ARCTANG_11):(angle11 + ARCTANG_11);\n\t\n   \n\t\nend\t\nendmodule\n",
        "module_name": "coordinate_cordic",
        "module_hash": "c0ae12669b232d79c7ea79ef9348add2",
        "dataset_index": 5476
      },
      "up_down_counter_4bit_03085f2a": {
        "rtl_code": "module up_down_counter_4bit (\n    input clk,\n    input up_down,\n    input load,\n    input en,\n    input [3:0] data_in,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (en) begin\n            if (load) begin\n                out <= data_in;\n            end else begin\n                if (up_down) begin\n                    out <= out + 1;\n                end else begin\n                    out <= out - 1;\n                end\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter_4bit",
        "module_hash": "03085f2a148fc4e7edebdd236cf0caf9",
        "dataset_index": 17575
      },
      "modulator_1d48bc64": {
        "rtl_code": "module modulator(\n    input adc_clk,\n    input [3:0] mod_type,\n    input [8:0] ssp_clk_divider,\n    input after_hysteresis,\n    output reg ssp_frame,\n    output reg ssp_din,\n    output reg modulating_carrier,\n    output reg pwr_oe1,\n    output reg pwr_oe3,\n    output reg pwr_oe4\n);\n\n// Synchronize up the ssp_frame signal\nalways @(negedge adc_clk) begin\n    if (mod_type == 4'b0100) begin\n        if (ssp_clk_divider[8:5] == 4'b0001)\n            ssp_frame <= 1'b1;\n        if (ssp_clk_divider[8:5] == 4'b0101)\n            ssp_frame <= 1'b0;\n    end\n    else begin\n        if (ssp_clk_divider[7:4] == 4'b0001)\n            ssp_frame <= 1'b1;\n        if (ssp_clk_divider[7:4] == 4'b0101)\n            ssp_frame <= 1'b0;\n    end\nend\n\n// Synchronize up the after-hysteresis signal, to produce DIN.\nalways @(posedge adc_clk) begin\n    ssp_din <= after_hysteresis;\nend\n\n// Modulating carrier frequency is fc/64 (212kHz) to fc/16 (848kHz). Reuse ssp_clk divider for that.\nalways @(*) begin\n    case (mod_type)\n        4'b0000: modulating_carrier <= 1'b0; // no modulation\n        4'b0001: modulating_carrier <= ssp_din ^ ssp_clk_divider[3]; // XOR means BPSK\n        4'b0100: modulating_carrier <= ssp_din & ssp_clk_divider[5]; // switch 212kHz subcarrier on/off\n        4'b0101, 4'b0110: modulating_carrier <= ssp_din & ssp_clk_divider[4]; // switch 424kHz modulation on/off\n        default: modulating_carrier <= 1'b0; // yet unused\n    endcase\nend\n\nalways @*\nbegin\n    pwr_oe1 <= 1'b0; // 33 Ohms Load\n    pwr_oe4 <= modulating_carrier; // 33 Ohms Load\n    pwr_oe3 <= 1'b0; // 10k Load\nend\n\nendmodule",
        "module_name": "modulator",
        "module_hash": "1d48bc646933d6a8dbf26d4b71dab2e3",
        "dataset_index": 146
      },
      "power_supply_24c4cee7": {
        "rtl_code": "module power_supply(\n    input clk,\n    output reg VPB,\n    output reg VNB\n);\n\nreg [1:0] state;\n\nalways @(posedge clk) begin\n    case(state)\n        2'b00: begin\n            VPB <= 1;\n            VNB <= 0;\n            state <= 2'b01;\n        end\n        2'b01: begin\n            VPB <= 0;\n            VNB <= 1;\n            state <= 2'b10;\n        end\n        2'b10: begin\n            VPB <= 1;\n            VNB <= 0;\n            state <= 2'b11;\n        end\n        2'b11: begin\n            VPB <= 0;\n            VNB <= 1;\n            state <= 2'b00;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "power_supply",
        "module_hash": "24c4cee7f031f04ca93d4a0e368dc815",
        "dataset_index": 15422
      },
      "signal_combiner_12172fdc": {
        "rtl_code": "\nmodule signal_combiner (\n    input [3:0] input_signals,\n    output output_signal\n);\n\nwire[1:0] input_sum;\n\nassign input_sum[0] = input_signals[0] ^ input_signals[1];\nassign input_sum[1] = input_signals[2] ^ input_signals[3];\n\nassign output_signal = input_sum[0] ^ input_sum[1];\n\nendmodule",
        "module_name": "signal_combiner",
        "module_hash": "12172fdc2a4c186a6c36ed2f0ad0cffe",
        "dataset_index": 13050
      },
      "xor_module_bb689d68": {
        "rtl_code": "module xor_module(a, b, o);\n   input [7:0] a;\n   input [7:0] b;\n   output [7:0] o;\n   \n   assign o = a ^ b;\nendmodule",
        "module_name": "xor_module",
        "module_hash": "bb689d68664252fd08226415456b056d",
        "dataset_index": 14623
      },
      "mux_2to1_4ca759e8": {
        "rtl_code": "module mux_2to1 (\n    input sel,\n    input in0,\n    input in1,\n    output out\n);\n\n    assign out = sel ? in1 : in0;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "4ca759e87a849843ba65d59831f48c9a",
        "dataset_index": 11551
      },
      "nios_system_alu_carry_out_299aaf88": {
        "rtl_code": "module nios_system_alu_carry_out (\n  input [1:0] address,\n  input clk,\n  input in_port,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  wire clk_en = 1;\n  wire data_in = in_port;\n  wire read_mux_out = (address == 0) ? data_in : 32'b0;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      readdata <= 0;\n    end else if (clk_en) begin\n      readdata <= {32'b0, read_mux_out};\n    end\n  end\n\nendmodule",
        "module_name": "nios_system_alu_carry_out",
        "module_hash": "299aaf88b9d79b211758c289a3621e2b",
        "dataset_index": 13833
      },
      "flt_fx_24p8_5589b308": {
        "rtl_code": "\n\nmodule flt_fx_24p8\n\t(\n\tinput\t[31:0]\tfp_in,         output reg [31:0] int_out      );\nwire    [7:0]   bias_exp;       \nwire    [7:0]   bias_exp2;      \nwire    [39:0]  fixed_out2;     \nwire    [47:0]  bias_mant;      \nreg     [47:0]  int_fixed_out;\n\nreg    [31:0]  fixed_out;\n\nassign bias_mant = {25'h0001, fp_in[22:0]};\nassign bias_exp = fp_in[30:23] - 8'd127;\nassign bias_exp2 = ~bias_exp + 8'h1;\n\nalways @* begin\n\tif (fp_in[30:0] == 31'b0) int_fixed_out = 0;\n  \telse if (bias_exp[7]) int_fixed_out = bias_mant >> bias_exp2;\n  \telse int_fixed_out = bias_mant << bias_exp;\n\n\tfixed_out = int_fixed_out[46:15];\n\tint_out = (fp_in[31]) ? ~fixed_out + 1 : fixed_out;\nend\n\nendmodule\n\n\n\n",
        "module_name": "flt_fx_24p8",
        "module_hash": "5589b3085897e5ce1f9c68874abdd40a",
        "dataset_index": 17467
      },
      "sky130_fd_sc_ms__a222oi_d6bfba0c": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__a222oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1,\n    C2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n    input  C2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out ;\n    wire nand1_out ;\n    wire nand2_out ;\n    wire and0_out_Y;\n\n    nand nand0 (nand0_out , A2, A1                         );\n    nand nand1 (nand1_out , B2, B1                         );\n    nand nand2 (nand2_out , C2, C1                         );\n    and  and0  (and0_out_Y, nand0_out, nand1_out, nand2_out);\n    buf  buf0  (Y         , and0_out_Y                     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__a222oi",
        "module_hash": "d6bfba0c805ad2124c05296daf863faf",
        "dataset_index": 22398
      },
      "pipeline__391d4395": {
        "rtl_code": "module pipeline_module (\n    input wire [2:0] vec,\n    input wire clk,\n    output wire [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nreg [2:0] reg1;\nreg [2:0] reg2;\nreg [2:0] reg3;\n\nassign outv = reg3;\nassign o2 = reg3[2];\nassign o1 = reg2[1];\nassign o0 = reg1[0];\n\nalways @(posedge clk) begin\n    reg1 <= vec;\nend\n\nalways @(posedge clk) begin\n    reg2 <= reg1;\nend\n\nalways @(posedge clk) begin\n    reg3 <= reg2;\nend\n\nendmodule",
        "module_name": "pipeline_",
        "module_hash": "391d4395dd635ca1e920c5ccc671fa2f",
        "dataset_index": 3352
      },
      "SPI_IF_accel_8ca25056": {
        "rtl_code": "\nmodule SPI_IF_accel( \n\tinput clk,\n\tinput rst,\n\tinput [6:0] mpu_address,\t\tinput [7:0] mpu_wr_data,\t\tinput mpu_rd_wr_sel,\t\t\t\tinput start,\t\t\t\t\t\toutput busy,\t\t\t\t\toutput SPI_SS_a,\t\t\t\t\t\toutput SPI_CK_a,\t\t\t\t\t\toutput SPI_DO_a,\t\t\t\t\t\tinput SPI_DI_a,\t\t\t\t\t\toutput [7:0] mpu_rd_data\t\t\t\t);\n\t \n\t reg [7:0] mpu_rd_data_buff; \t\treg [7:0] SPIstate;\n\t reg [11:0] counter;\t\treg MPUclk;\t\t\t\treg  do_reg;\t\t\t\treg  ss_reg;\t\t\t\treg  ck_reg;\t\t\t\treg busy_bf;\t\t\t\treg [4:0] i;\t\t\t\treg [4:0] j;\t\t\t\tparameter SPI_HALF_CLK = 50; parameter SPI_CLK = SPI_HALF_CLK*2;\n\nwire halfCLKpassed = (counter == SPI_HALF_CLK-1);\n\nalways@(posedge clk)\nbegin\n\tif(rst)\n\tbegin\n\t\tcounter <= 0;\n\t\tMPUclk <= 0;\n\tend\n\telse\n\tbegin\n\t\tif(start==1) begin\n\t\t\tcounter <= 0;\t\t\n\t\t\tMPUclk <= 1;\t\t\t\n\t\tend\n\t\telse if(halfCLKpassed)begin\t\t\t\n\t\t\tcounter <= 0;\t\t\n\t\t\tMPUclk <= ~MPUclk;\n\t\t\tend\n\t\telse begin\n\t\t\tcounter <= counter + 1;\n\t\tend\n\tend\nend\n\nalways @(posedge clk)\n\tbegin\n\t\tif(rst)\n\t\tbegin\n\t\t\tSPIstate = 0;\n\t\tend\n\t\telse\n\t\tbegin\t\t\n\t\t\tcase(SPIstate)\n\t\t\t\t0:if(start == 1) SPIstate = 1;\t1:SPIstate = 3;\t3:begin\n\t\t\t\t\tif(i==0 && mpu_rd_wr_sel == 1)SPIstate = 4;\t\t\t\tif(i==0 && mpu_rd_wr_sel == 0)SPIstate = 5;\t\t\t\tend\n\t\t\t\t4:if(j==0)SPIstate = 6;\t\t\t\t5:if(j==0)SPIstate = 6;\n\t\t\t\t6:if(halfCLKpassed)SPIstate = 7;\t\t\t\t7:SPIstate = 0;\t\t\tendcase\n\t\tend\n\tend\n \n \nalways @ (posedge clk)\nbegin \n\tif(rst)\n\t\tbegin\n\t\t\tdo_reg = 0;\n\t\t\tck_reg = 1;\n\t\t\tss_reg = 1;\n\t\t\tbusy_bf = 0;\n\t\t\tmpu_rd_data_buff = 0;\n\t\t\ti = 16;\n\t\t\tj = 17;\n\t\tend\n\telse\n\t\tcase(SPIstate)\n\t\t\t0:begin\t\t\t\t\tdo_reg = 0;\n\t\t\t\tss_reg = 1; \n\t\t\t\tbusy_bf = 0;\n\t\t\t   i = 16;\n\t\t\t\tj = 17;\n\t\t\t  end\n\t\t\t1:begin\t\t\t\t\tbusy_bf = 1;\n\t\t\t\t\tss_reg = 0;\n\t\t\t\t\tend\n\t\t\t3:begin\t\t\t\t\tif(halfCLKpassed)\n\t\t\t\tbegin\n\t\t\t\t\tcase (i)\n\t\t\t\t\t\t16:do_reg = mpu_rd_wr_sel;\n\t\t\t\t\t\t14:do_reg = mpu_address[6];\n\t\t\t\t\t\t12:do_reg = mpu_address[5];\n\t\t\t\t\t\t10:do_reg = mpu_address[4];\n\t\t\t\t\t\t8: do_reg = mpu_address[3];\n\t\t\t\t\t\t6: do_reg = mpu_address[2];\n\t\t\t\t\t\t4: do_reg = mpu_address[1];\n\t\t\t\t\t\t2: do_reg = mpu_address[0];\n\t\t\t\t\t\t0: do_reg = 0;\n\t\t\t\t\tendcase\n\t\t\t\t\tif(i!=0) i=i-1;\n\t\t\t\tend\n\t\t\t  end\n\t\t\t4:begin\t\t\t\tif(halfCLKpassed)\n\t\t\t\tbegin\n\t\t\t\t\tcase (j)\n\t\t\t\t\t\t16:mpu_rd_data_buff[7] = SPI_DI_a;\n\t\t\t\t\t\t14:mpu_rd_data_buff[6] = SPI_DI_a;\n\t\t\t\t\t\t12:mpu_rd_data_buff[5] = SPI_DI_a;\n\t\t\t\t\t\t10:mpu_rd_data_buff[4] = SPI_DI_a;\n\t\t\t\t\t\t8:mpu_rd_data_buff[3] = SPI_DI_a;\n\t\t\t\t\t\t6:mpu_rd_data_buff[2] = SPI_DI_a;\n\t\t\t\t\t\t4:mpu_rd_data_buff[1] = SPI_DI_a;\n\t\t\t\t\t\t2:mpu_rd_data_buff[0] = SPI_DI_a;\t\t\t\t\t\t\n\t\t\t\t\tendcase\n\t\t\t\t\tif(j!=0) j=j-1;\n\t\t\t\tend\n\t\t\tend\t\n\n\t\t\t5:begin\t\t\t\tif(halfCLKpassed)\n\t\t\t\tbegin\n\t\t\t\t\tcase (j)\n\t\t\t\t\t\t16:do_reg = mpu_wr_data[7]; \n\t\t\t\t\t\t14:do_reg = mpu_wr_data[6]; \n\t\t\t\t\t\t12:do_reg = mpu_wr_data[5]; \n\t\t\t\t\t\t10:do_reg = mpu_wr_data[4]; \n\t\t\t\t\t\t8:do_reg = mpu_wr_data[3]; \n\t\t\t\t\t\t6:do_reg = mpu_wr_data[2]; \n\t\t\t\t\t\t4:do_reg = mpu_wr_data[1]; \n\t\t\t\t\t\t2:do_reg = mpu_wr_data[0]; \n\t\t\t\t\t\t0:do_reg = 0;\n\t\t\t\t\tendcase\n\t\t\t\t\tif(j!=0) j=j-1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\t\t\t\t  \n\t\t\t6:begin\t\t\t\tck_reg =1;\n\t\t\t\tdo_reg =0;\n\t\t\t\tss_reg = 1;\n\t\t\t  end\n\t\t\t  \n\t\t\t7:begin\t\tend\n\t\t\t\n\t\tendcase\nend\n\n\nassign SPI_DO_a = do_reg;\nassign SPI_CK_a = MPUclk | ss_reg;\nassign SPI_SS_a = ss_reg;\nassign busy = busy_bf | start;\nassign mpu_rd_data = mpu_rd_data_buff;\nendmodule\n",
        "module_name": "SPI_IF_accel",
        "module_hash": "8ca2505623a5d0a111ecbd36e13c65a0",
        "dataset_index": 24376
      },
      "nor_gate_with_enable_b7cf9f50": {
        "rtl_code": "module nor_gate_with_enable (\n    input in1,\n    input in2,\n    input en,\n    output out\n);\n\nreg out_reg;\n\nalways @(*) begin\n    if (en == 1'b0) begin\n        out_reg = 1'b0;\n    end else begin\n        out_reg = ~(in1 | in2);\n    end\nend\n\nassign out = out_reg;\n\nendmodule",
        "module_name": "nor_gate_with_enable",
        "module_hash": "b7cf9f501b31174183e5b4ec198b4eb4",
        "dataset_index": 12318
      },
      "regfile_1db030a4": {
        "rtl_code": "module regfile(clk, raddr1, dout1, raddr2, dout2, wr, waddr, din, nrst, ram1, ram2, ram3);\n\tinput \t\t\tclk;\n\tinput \t\t\twr;\n\tinput\t[4:0] \traddr1, raddr2, waddr;\n\tinput\t[31:0] \tdin;\n\tinput nrst;\n\toutput\treg[31:0] \tdout1, dout2;\n\toutput wire[31:0] ram1;\n\toutput wire[31:0] ram2;\n\toutput wire[31:0] ram3;\n\treg [31:0] ram [0:31];\n\tassign ram1 = ram[5'b00001];\n\tassign ram2 = ram[5'b00010];\n\tassign ram3 = ram[5'b00011];\n\t\n\talways @(posedge clk)\n\tbegin\n\t\n\tif (wr == 1'b1)\n\t\tbegin\n\t\t\tram[waddr] = din;\n\t\tend\n\tend\n\talways @(negedge clk)\n\tbegin\n\t\tdout1 <= (raddr1 == 5'b0) ? 32'b0 : ram[raddr1];\n\t\tdout2 <= (raddr2 == 5'b0) ? 32'b0 : ram[raddr2];\n\tend\n\tendmodule\n",
        "module_name": "regfile",
        "module_hash": "1db030a4aa4a79187b95cfe3994e23cc",
        "dataset_index": 22694
      },
      "shift_register_52c94f04": {
        "rtl_code": "module shift_register (\n    input clk,\n    input load,\n    input clear,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (clear) begin\n            data_out <= 8'b0;\n        end else if (load) begin\n            data_out <= data_in;\n        end else begin\n            data_out <= {data_out[6:0], data_out[7]};\n        end\n    end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "52c94f0448b1316130f429e0ab6f28c7",
        "dataset_index": 742
      },
      "lab2_part7_dc3fd577": {
        "rtl_code": "\n\n\nmodule lab2_part7 (SW, LEDR, HEX1, HEX0);\n  input [5:0] SW;\n  output [0:6] HEX1, HEX0;\n  output [5:0] LEDR;\n\n  reg [3:0] TENS, ONES;\n\n  assign LEDR = SW;\n\n  always begin\n    if (SW[5:0] > 59) begin\n      TENS = 6;\n      ONES = SW[5:0] - 60;\n    end else if (SW[5:0] > 49) begin\n      TENS = 5;\n      ONES = SW[5:0] - 50;\n    end else if (SW[5:0] > 39) begin\n      TENS = 4;\n      ONES = SW[5:0] - 40;\n    end else if (SW[5:0] > 29) begin\n      TENS = 3;\n      ONES = SW[5:0] - 30;\n    end else if (SW[5:0] > 19) begin\n      TENS = 2;\n      ONES = SW[5:0] - 20;\n    end else if (SW[5:0] > 9) begin\n      TENS = 1;\n      ONES = SW[5:0] - 10;\n    end else begin\n      TENS = 0;\n      ONES = SW[5:0];\n    end end b2d_7seg H1 (TENS, HEX1);\n  b2d_7seg H0 (ONES, HEX0);\n\nendmodule\n\nmodule b2d_7seg (X, SSD);\n  input [3:0] X;\n  output [0:6] SSD;\n\n  assign SSD[0] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] &  X[2] & ~X[1] & ~X[0]));\n  assign SSD[1] = ((~X[3] &  X[2] & ~X[1] &  X[0]) | (~X[3] &  X[2] &  X[1] & ~X[0]));\n  assign SSD[2] =  (~X[3] & ~X[2] &  X[1] & ~X[0]);\n  assign SSD[3] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] &  X[2] & ~X[1] & ~X[0]) | (~X[3] &  X[2] & X[1] & X[0]) | (X[3] & ~X[2] & ~X[1] & X[0]));\n  assign SSD[4] = ~((~X[2] & ~X[0]) | (X[1] & ~X[0]));\n  assign SSD[5] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] & ~X[2] &  X[1] & ~X[0]) | (~X[3] & ~X[2] & X[1] & X[0]) | (~X[3] & X[2] & X[1] & X[0]));\n  assign SSD[6] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] & ~X[2] & ~X[1] & ~X[0]) | (~X[3] &  X[2] & X[1] & X[0]));\nendmodule\n",
        "module_name": "lab2_part7",
        "module_hash": "dc3fd57795569139de8d2d1a5db6e864",
        "dataset_index": 22588
      },
      "rotator_byte_reorder_98052c22": {
        "rtl_code": "module rotator_byte_reorder(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    input [31:0] in,\n    output [31:0] out);\n\n    // 100-bit left/right rotator\n    reg [99:0] rot_data;\n    always @(posedge clk) begin\n        if (load) rot_data <= data;\n        else if (ena[0]) rot_data <= {rot_data[98:0], rot_data[99]};\n        else if (ena[1]) rot_data <= {rot_data[0], rot_data[99:1]};\n    end\n\n    // Byte reordering module\n    reg [7:0] shift_reg [3:0];\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg[0] <= in[7:0];\n            shift_reg[1] <= in[15:8];\n            shift_reg[2] <= in[23:16];\n            shift_reg[3] <= in[31:24];\n        end\n        else begin\n            shift_reg[0] <= shift_reg[1];\n            shift_reg[1] <= shift_reg[2];\n            shift_reg[2] <= shift_reg[3];\n            shift_reg[3] <= in[31:24];\n        end\n    end\n    assign out = {shift_reg[3], shift_reg[2], shift_reg[1], shift_reg[0]} | rot_data[31:0];\n\nendmodule",
        "module_name": "rotator_byte_reorder",
        "module_hash": "98052c22e08734963c24e572dcd66314",
        "dataset_index": 9292
      },
      "synchronizer_ff_9945c0f1": {
        "rtl_code": "module synchronizer_ff(\n  input [3:0] D,\n  input CLK,\n  input AR,\n  output reg [3:0] Q\n);\n\n  always @(posedge CLK) begin\n    if (AR) begin\n      Q <= 4'b0000;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule",
        "module_name": "synchronizer_ff",
        "module_hash": "9945c0f1e691eb8fb2073a0dfa846368",
        "dataset_index": 16947
      },
      "altera_avalon_st_packets_to_bytes_2a1ab67e": {
        "rtl_code": "\nmodule altera_avalon_st_packets_to_bytes\n#(    parameter CHANNEL_WIDTH = 8,\n      parameter ENCODING      = 0) \n(\n      input              clk,\n      input              reset_n,\n      output reg         in_ready,\n      input              in_valid,\n      input      [7: 0]  in_data,\n      input      [CHANNEL_WIDTH-1: 0]  in_channel,\n      input              in_startofpacket,\n      input              in_endofpacket,\n\n      input              out_ready,\n      output reg         out_valid,\n      output reg [7: 0]  out_data\n);\n\n   localparam CHN_COUNT = CHANNEL_WIDTH/7;\n   reg  sent_esc, sent_sop, sent_eop;\n   reg  sent_channel_char, channel_escaped, sent_channel;\n   reg  [CHANNEL_WIDTH:0] stored_channel;\n   reg  [4:0] channel_count;\n   reg    [((CHANNEL_WIDTH/7+1)*7)-1:0] stored_varchannel;\n   reg     channel_needs_esc;\n\n\n\n   wire need_sop, need_eop, need_esc, need_channel;\n\n   assign need_esc = (in_data === 8'h7a |\n                      in_data === 8'h7b |\n                      in_data === 8'h7c |\n                      in_data === 8'h7d );\n   assign need_eop = (in_endofpacket);\n   assign need_sop = (in_startofpacket);\n\n\ngenerate\nif( CHANNEL_WIDTH > 0) begin\n   wire   channel_changed;\n   assign channel_changed = (in_channel != stored_channel);\n   assign need_channel = (need_sop | channel_changed);\n\n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n         sent_esc <= 0;\n         sent_sop <= 0;\n         sent_eop <= 0;\n         sent_channel <= 0;\n         channel_escaped <= 0;\n         sent_channel_char <= 0;\n         out_data <= 0;\n         out_valid <= 0;\n         channel_count <= 0;\n         channel_needs_esc <= 0;\n      end else begin\n\n         if (out_ready )\n           out_valid <= 0;\n\n         if ((out_ready | ~out_valid) && in_valid  )\n           out_valid <= 1;\n\n         if ((out_ready | ~out_valid) && in_valid) begin\n            if (need_channel & ~sent_channel) begin\n                 if (~sent_channel_char) begin\n                    sent_channel_char <= 1;\n                    out_data <= 8'h7c;\n                    channel_count <= CHN_COUNT[4:0];\n                    stored_varchannel <= in_channel;\n                    if (ENCODING == 0) begin\n                    channel_needs_esc <= (in_channel == 8'h7a |\n                                          in_channel == 8'h7b |\n                                          in_channel == 8'h7c |\n                                          in_channel == 8'h7d );\n                    end\n                 end else if (channel_needs_esc & ~channel_escaped) begin\n                    out_data <= 8'h7d;\n                    channel_escaped <= 1;\n                 end else if (~sent_channel) begin\n                       if (ENCODING) begin\n                            if (channel_count > 0) begin\n                                   if (channel_needs_esc) out_data <= {1'b1, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]} ^ 8'h20;\n                                   else                   out_data <= {1'b1, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]};\n                                   stored_varchannel <= stored_varchannel<<7;\n\n                                   channel_count <= channel_count - 1'b1;\n                                   if (channel_count ==1 & CHANNEL_WIDTH > 7) begin\n                                      channel_needs_esc <=\n                                         ((stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14]  == 7'h7a)|\n                                         (stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14] == 7'h7b) |\n                                         (stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14] == 7'h7c) |\n                                         (stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14] == 7'h7d) );\n                                   end\n                              end else begin\n                               if (channel_needs_esc) begin \n                                      channel_needs_esc <= 0; \n                                      out_data <= {1'b0, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]} ^ 8'h20;\n                                   end else   out_data <= {1'b0, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]};\n                                   sent_channel <= 1;\n                              end\n                       end else begin\n                            if (channel_needs_esc) begin \n                               channel_needs_esc <= 0; \n                               out_data <= in_channel ^ 8'h20; \n                            end else out_data <= in_channel;\n                            sent_channel <= 1;\n                       end\n                 end\n            end else if (need_sop & ~sent_sop) begin\n                 sent_sop <= 1;\n                 out_data <= 8'h7a;\n\n            end else if (need_eop & ~sent_eop) begin\n                 sent_eop <= 1;\n                 out_data <= 8'h7b;\n\n            end else if (need_esc & ~sent_esc) begin\n                 sent_esc <= 1;\n                 out_data <= 8'h7d;\n            end else begin\n                 if (sent_esc)    out_data <= in_data ^ 8'h20;\n                 else             out_data <= in_data;\n                 sent_esc <= 0;\n                 sent_sop <= 0;\n                 sent_eop <= 0;\n                 sent_channel <= 0;\n                 channel_escaped <= 0;\n                 sent_channel_char <= 0;\n            end\n         end\n      end\n   end\n\n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n         stored_channel <= {CHANNEL_WIDTH{1'b1}};\n      end else begin\n         if (sent_channel) stored_channel <= in_channel;\n      end\n   end\n    always @* begin\n\n      in_ready = (out_ready | !out_valid) & in_valid & (~need_esc | sent_esc)\n                 & (~need_sop | sent_sop)\n                 & (~need_eop | sent_eop)\n                 & (~need_channel | sent_channel);\n   end\n\nend else begin\n\nassign need_channel = (need_sop);\n\n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n         sent_esc <= 0;\n         sent_sop <= 0;\n         sent_eop <= 0;\n         out_data <= 0;\n         out_valid <= 0;\n         sent_channel <= 0;\n         sent_channel_char <= 0;\n      end else begin\n\n         if (out_ready )\n           out_valid <= 0;\n\n         if ((out_ready | ~out_valid) && in_valid  )\n           out_valid <= 1;\n\n         if ((out_ready | ~out_valid) && in_valid) begin\n            if (need_channel & ~sent_channel) begin\n                 if (~sent_channel_char) begin           sent_channel_char <= 1;\n                    out_data <= 8'h7c;\n                 end else if (~sent_channel) begin\n                    out_data <= 'h0;\n                    sent_channel <= 1;\n                 end\n            end else if (need_sop & ~sent_sop) begin\n                 sent_sop <= 1;\n                 out_data <= 8'h7a;\n            end else if (need_eop & ~sent_eop) begin\n                 sent_eop <= 1;\n                 out_data <= 8'h7b;\n            end else if (need_esc & ~sent_esc) begin\n                 sent_esc <= 1;\n                 out_data <= 8'h7d;\n            end else begin\n                 if (sent_esc)    out_data <= in_data ^ 8'h20;\n                 else             out_data <= in_data;\n                 sent_esc <= 0;\n                 sent_sop <= 0;\n                 sent_eop <= 0;\n            end\n         end\n     end\n   end\n   \n always @* begin\n      in_ready = (out_ready | !out_valid) & in_valid & (~need_esc | sent_esc)\n                 & (~need_sop | sent_sop)\n                 & (~need_eop | sent_eop)\n                 & (~need_channel | sent_channel);\n   end\nend\nendgenerate\n\nendmodule\n",
        "module_name": "altera_avalon_st_packets_to_bytes",
        "module_hash": "2a1ab67e06a08a527a52f810f17c8f50",
        "dataset_index": 16085
      },
      "edge_detector_caa862ab": {
        "rtl_code": "module edge_detector(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    reg [7:0] prev_in;\n    always @(posedge clk) begin\n        if (in > prev_in) begin\n            out <= in;\n        end else if (in < prev_in) begin\n            out <= in;\n        end\n        prev_in <= in;\n    end\nendmodule\n\nmodule mux(\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    input [7:0] in4,\n    input sel_b1,\n    input sel_b2,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sel_b1 == 0 && sel_b2 == 0) begin\n            out = in1;\n        end else if (sel_b1 == 0 && sel_b2 == 1) begin\n            out = in2;\n        end else if (sel_b1 == 1 && sel_b2 == 0) begin\n            out = in3;\n        end else if (sel_b1 == 1 && sel_b2 == 1) begin\n            out = in4;\n        end\n    end\nendmodule\n\nmodule top_module(\n    input clk,\n    input [7:0] in,\n    input [7:0] input1,\n    input [7:0] input2,\n    input [7:0] input3,\n    input [7:0] input4,\n    input sel_b1,\n    input sel_b2,\n    output [7:0] out\n);\n    wire [7:0] edge_detect_out;\n    edge_detector edge_detect(.clk(clk), .in(in), .out(edge_detect_out));\n    \n    wire [7:0] mux_out;\n    mux mux_inst(.in1(input1), .in2(input2), .in3(input3), .in4(input4), .sel_b1(sel_b1), .sel_b2(sel_b2), .out(mux_out));\n    \n    assign out = edge_detect_out & mux_out;\nendmodule",
        "module_name": "edge_detector",
        "module_hash": "caa862ab7dce6956604ba53d37565241",
        "dataset_index": 1832
      },
      "custom__426e67f7": {
        "rtl_code": "module custom_module (\n    output Y,\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1\n);\n\n    wire and0_out  ;\n    wire and1_out  ;\n    wire nor0_out_Y;\n\n    assign and0_out = B1 & B2;\n    assign and1_out = A1 & A2;\n    assign nor0_out_Y = ~(and0_out | and1_out | C1);\n    assign Y = nor0_out_Y;\n\nendmodule",
        "module_name": "custom_",
        "module_hash": "426e67f76ee7de101207314a6dc33628",
        "dataset_index": 6708
      },
      "nkmd_dai_rx_f427f2de": {
        "rtl_code": "module nkmd_dai_rx(\n    input wire clk,\n    input wire rst,\n\n    input wire [23:0] rx_data_i,\n    input wire rx_ack_i,\n\n    input wire [31:0] data_i,\n    output wire [31:0] data_o,\n    input wire [31:0] addr_i,\n    input wire we_i);\n\nreg [5:0] nextw_ff;\nalways @(posedge clk) begin\n    if (rst)\n        nextw_ff <= 0;\n    else if (rx_ack_i)\n        nextw_ff <= nextw_ff + 1;\nend\n\nreg [23:0] ringbuf [63:0];\nalways @(posedge clk) begin\n    if (rx_ack_i)\n        ringbuf[nextw_ff] <= rx_data_i;\nend\n\nreg [5:0] unread_ff;\nreg [5:0] shift_ff;\nwire should_shift;\nassign should_shift = we_i && addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h00;\nalways @(posedge clk) begin\n    if (rst) begin\n        unread_ff <= 0;\n        shift_ff <= 0;\n    end else if (should_shift && !rx_ack_i) begin\n        unread_ff <= unread_ff - 1;\n        shift_ff <= shift_ff + 1;\n    end else if (!should_shift && rx_ack_i) begin\n        unread_ff <= unread_ff + 1;\n    end else if (should_shift && rx_ack_i) begin\n        shift_ff <= shift_ff + 1;\n    end\nend\n\nreg [31:0] data_o_ff;\nassign data_o = data_o_ff;\n\nwire [5:0] offset_i;\nassign offset_i = addr_i[5:0];\n\nalways @(posedge clk) begin\n    if (addr_i[15:12] == 4'hf)\n        data_o_ff <= ringbuf[shift_ff + offset_i];\n    else if (addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h00)\n        data_o_ff <= unread_ff;\n    else\n        data_o_ff <= 0;\nend\n\nendmodule\n\nmodule nkmd_dai_tx(\n    input wire clk,\n    input wire rst,\n\n    output wire [23:0] tx_data_o,\n    input wire tx_pop_i,\n    output wire tx_ack_o,\n\n    input wire [31:0] data_i,\n    output wire [31:0] data_o,\n    input wire [31:0] addr_i,\n    input wire we_i);\n\nreg [5:0] queued_ff;\nreg [5:0] lastr_ff;\nreg [5:0] nextw_ff;\n\nreg [23:0] ringbuf [63:0];\nassign tx_data_o = ringbuf[lastr_ff];\n\nwire should_queue;\nassign should_queue = we_i && addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h01;\nalways @(posedge clk) begin\n    if (rst) begin\n        queued_ff <= 0;\n        lastr_ff <= 6'h3f;\n        nextw_ff <= 0;\n    end else if (should_queue && !tx_pop_i) begin\n        ringbuf[nextw_ff] <= data_i;\n        queued_ff <= queued_ff + 1;\n        nextw_ff <= nextw_ff + 1;\n    end else if (!should_queue && tx_pop_i) begin\n        if (queued_ff > 0) begin\n            queued_ff <= queued_ff - 1;\n            lastr_ff <= lastr_ff + 1;\n        end\n    end else if (should_queue && tx_pop_i) begin\n        ringbuf[nextw_ff] <= data_i;\n        if (queued_ff > 0) begin\n            lastr_ff <= lastr_ff + 1;\n        end else begin\n            queued_ff <= queued_ff + 1;\n        end\n        nextw_ff <= nextw_ff + 1;\n    end\nend\n\nreg tx_ack_ff;\nalways @(posedge clk)\n    tx_ack_ff <= tx_pop_i;\nassign tx_ack_o = tx_ack_ff;\n\nreg [31:0] data_o_ff;\nassign data_o = data_o_ff;\n\nwire [5:0] offset_i;\nassign offset_i = addr_i[5:0];\n\nalways @(posedge clk) begin\n    if (addr_i[15:12] == 4'he)\n        data_o_ff <= ringbuf[nextw_ff - 1 - offset_i];\n    else if (addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h01)\n        data_o_ff <= queued_ff;\n    else\n        data_o_ff <= 0;\nend\n\nendmodule\n",
        "module_name": "nkmd_dai_rx",
        "module_hash": "f427f2deccc99433b1150f1f0f740727",
        "dataset_index": 14659
      },
      "RFID #_ca15f8fe": {
        "rtl_code": "module RFID #(\n  parameter n = 8, // number of bits in the data signal\n  parameter k = 4 // number of bits in the transmit signal\n) (\n  input [n-1:0] data_in,\n  input clk,\n  input rst,\n  input start,\n  output reg [k-1:0] tx\n);\n\n  reg [n-1:0] data_reg;\n  reg [3:0] count;\n  reg start_reg;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n      tx <= 0;\n      start_reg <= 0;\n    end\n    else begin\n      if (start) begin\n        start_reg <= 1;\n        count <= 0;\n        data_reg <= data_in;\n        tx <= 1;\n      end\n      else if (start_reg) begin\n        if (count < k-1) begin\n          count <= count + 1;\n          tx <= 0;\n        end\n        else begin\n          count <= 0;\n          tx <= 1;\n          start_reg <= 0;\n        end\n      end\n      else begin\n        tx <= 0;\n      end\n    end\n  end\n  \nendmodule\n\n",
        "module_name": "RFID #",
        "module_hash": "ca15f8fe6cb80c2ae1c9c4a62a92461f",
        "dataset_index": 17454
      },
      "complex_5ac4e3ce": {
        "rtl_code": "\nmodule complex(\n\tinput [7:0] x,\n\tinput [7:0] y,\n\toutput out\n);\n\nwire [9:0] and_outputs;\nwire [4:0] or_outputs;\n\ngenvar i;\ngenerate\n\tfor(i = 0; i < 8; i = i + 1)\n\tbegin: and_1st_row\n\t\tassign and_outputs[i] = x[i] & y[i];\n\tend\n\t\n\tfor(i = 0; i < 4; i = i + 1)\n\tbegin: or_2nd_row\n\t\tassign or_outputs[i] = and_outputs[2 * i] | and_outputs[2 * i + 1];\n\tend\n\n\tassign and_outputs[8] = or_outputs[0] & or_outputs[1];\n\tassign and_outputs[9] = or_outputs[2] & or_outputs[3];\n\t\n\tassign or_outputs[4] = and_outputs[8] | and_outputs[9];\n\nendgenerate\n\nassign out = or_outputs[4];\nendmodule\n",
        "module_name": "complex",
        "module_hash": "5ac4e3ce9472b72377aed2e713cac492",
        "dataset_index": 24673
      },
      "BIOS_ROM_blk_mem_gen_prim_width_b9d92ed9": {
        "rtl_code": "module BIOS_ROM_blk_mem_gen_prim_width\n  (douta,\n   ena,\n   clka,\n   addra,\n   dina,\n   wea);\n\n  output [7:0] douta;\n  input ena;\n  input clka;\n  input [11:0] addra;\n  input [7:0] dina;\n  input [0:0] wea;\n\n  reg [7:0] mem [0:4095];\n  reg [7:0] douta_reg;\n  wire [11:0] addra_reg;\n  wire [7:0] dina_reg;\n  wire [0:0] wea_reg;\n\n  assign addra_reg = addra;\n  assign dina_reg = dina;\n  assign wea_reg = wea;\n\n  always @(posedge clka) begin\n    if (ena) begin\n      if (wea_reg) begin\n        mem[addra_reg] <= dina_reg;\n      end\n      douta_reg <= mem[addra_reg];\n    end\n  end\n\n  assign douta = douta_reg;\n\nendmodule",
        "module_name": "BIOS_ROM_blk_mem_gen_prim_width",
        "module_hash": "b9d92ed91571def8029a64b9e9dbcbf3",
        "dataset_index": 21381
      },
      "freq_syn_caba0f97": {
        "rtl_code": "\nmodule freq_syn (\n  input clk_ref,\n  input [7:0] ctrl,\n  output reg clk_syn\n);\n\nparameter n = 8; // number of bits in the digital control signal\nparameter f_ref = 10_000_000; // frequency of the reference clock signal (in Hz)\nparameter f_min = 1_000_000; // minimum output frequency of the synthesizer (in Hz)\nparameter f_max = 100_000_000; // maximum output frequency of the synthesizer (in Hz)\n\nreg [7:0] ctrl_reg; // register for storing the digital control signal\nreg [31:0] phase_accum; // register for storing the phase accumulator value\nreg [31:0] phase_inc; // register for storing the phase increment value\nreg [31:0] phase_err; // register for storing the phase error value\nreg [31:0] phase_err_int; // register for storing the integrated phase error value\nreg [31:0] vco_ctrl; // register for storing the VCO control voltage value\nreg [31:0] vco_freq; // register for storing the VCO frequency value\nreg [32:0] phase_syn; // register for storing the synthesized phase value\n\nwire [32:0] phase_ref; // wire for storing the reference phase value\nwire [32:0] phase_diff; // wire for storing the phase difference value\nwire [32:0] phase_err_filt; // wire for storing the filtered phase error value\nwire [32:0] phase_err_integ; // wire for storing the integrated phase error value\nwire [32:0] vco_ctrl_filt; // wire for storing the filtered VCO control voltage value\nwire [32:0] vco_freq_div; // wire for storing the divided VCO frequency value\n\n// generate the reference phase value\nassign phase_ref = (f_ref * 33'h1_0000_0000) / (2 * f_max);\n\n// generate the phase increment value\nalways @(*) begin\n  phase_inc = (ctrl_reg * (33'h1_0000_0000 - phase_ref)) / (2**n);\nend\n\n// generate the synthesized phase value\nalways @(posedge clk_ref) begin\n  phase_accum <= phase_accum + phase_inc;\n  phase_syn <= phase_accum + phase_err_int;\nend\n\n// generate the phase difference value\nassign phase_diff = phase_ref - phase_syn;\n\n\n// generate the integrated phase error value\nalways @(posedge clk_ref) begin\n  if (phase_err_int >= 0) begin\n    phase_err_int <= phase_err_int + phase_err_filt;\n  end else begin\n    phase_err_int <= phase_err_int - phase_err_filt;\n  end\nend\n\n\n// generate the divided VCO frequency value\nassign vco_freq_div = vco_freq / (2**16);\n\n// generate the synthesized clock signal\nalways @(posedge clk_ref) begin\n  vco_freq <= vco_ctrl_filt;\n  clk_syn <= ~clk_syn;\nend\n\n// register the digital control signal\nalways @(posedge clk_ref) begin\n  ctrl_reg <= ctrl;\nend\n\nendmodule",
        "module_name": "freq_syn",
        "module_hash": "caba0f970260beb8ce3f11164b600760",
        "dataset_index": 7894
      },
      "FIFO_image_filter_dmask_data_stream_0_V_shiftReg_47eaf25a": {
        "rtl_code": "module FIFO_image_filter_dmask_data_stream_0_V_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 8;\nparameter ADDR_WIDTH = 1;\nparameter DEPTH = 2;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\nbegin\n    if (ce)\n    begin\n        for (i=0;i<DEPTH-1;i=i+1)\n            SRL_SIG[i+1] <= SRL_SIG[i];\n        SRL_SIG[0] <= data;\n    end\nend\n\nassign q = SRL_SIG[a];\n\nendmodule",
        "module_name": "FIFO_image_filter_dmask_data_stream_0_V_shiftReg",
        "module_hash": "47eaf25a0815e6dfcf54aeb299e0f764",
        "dataset_index": 1102
      },
      "vending_machine_fsm_5098e74b": {
        "rtl_code": "module vending_machine_fsm(\n  input clk,\n  input reset,\n  input coin_input,\n  input button_input,\n  output reg display_output,\n  output reg product_output\n);\n\n  parameter IDLE = 2'b00;\n  parameter WAITING_FOR_COINS = 2'b01;\n  parameter DISPENSING = 2'b10;\n  \n  reg [1:0] state, next_state;\n  reg [3:0] price = 4'b0010;\n  reg [3:0] coins_inserted;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      coins_inserted <= 0;\n      display_output <= price;\n      product_output <= 0;\n    end else begin\n      state <= next_state;\n      case (state)\n        IDLE: begin\n          if (coin_input) begin\n            coins_inserted <= coins_inserted + 1;\n            next_state <= WAITING_FOR_COINS;\n          end else begin\n            next_state <= IDLE;\n          end\n        end\n        WAITING_FOR_COINS: begin\n          if (coin_input) begin\n            coins_inserted <= coins_inserted + 1;\n            next_state <= WAITING_FOR_COINS;\n          end else if (button_input && coins_inserted >= price) begin\n            coins_inserted <= coins_inserted - price;\n            next_state <= DISPENSING;\n          end else begin\n            next_state <= WAITING_FOR_COINS;\n          end\n        end\n        DISPENSING: begin\n          product_output <= 1;\n          next_state <= IDLE;\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "vending_machine_fsm",
        "module_hash": "5098e74bdb03c7c998e4bb01e514136f",
        "dataset_index": 20629
      },
      "memory #_6cf31052": {
        "rtl_code": "\nmodule memory #(\n  parameter bits = 32,\n  parameter words = 1024\n)(\n  input clk,\n  input [9:0] addr,\n  input [bits-1:0] data_in,\n  output reg [bits-1:0] mem\n);\n\n  always @(posedge clk) begin\n    if (addr < words) begin\n      mem <= data_in;\n    end\n  end\n\nendmodule",
        "module_name": "memory #",
        "module_hash": "6cf310529bf0fd4c0d1b977b531ff060",
        "dataset_index": 16835
      },
      "clk_gen_00987189": {
        "rtl_code": "module clk_gen (clk,reset,clk1,clk2,clk4,fetch,alu_clk);\ninput clk,reset;\noutput clk1,clk2,clk4,fetch,alu_clk;\nwire clk,reset;\nreg clk2,clk4,fetch,alu_clk;\nreg[7:0] state;\nparameter    S1 = 8'b00000001,\n             S2 = 8'b00000010,\n             S3 = 8'b00000100,\n             S4 = 8'b00001000,\n             S5 = 8'b00010000,\n             S6 = 8'b00100000,\n             S7 = 8'b01000000,\n             S8 = 8'b10000000,\n           idle = 8'b00000000;\n                 \nassign clk1 = ~clk;\n\nalways @(negedge clk)\n   if(reset)\n           begin\n                clk2 <= 0;\n                clk4 <= 1;\n                fetch  <= 0;\n                alu_clk <= 0;\n                state <= idle;\n           end\n   else\n           begin \n              case(state)\n                 S1:\n                      begin\n                            clk2 <= ~clk2;\n                         alu_clk <= ~alu_clk;                \n                           state <= S2;\n                      end\n                 S2:\n                      begin\n                          clk2 <= ~clk2;\n                          clk4 <= ~clk4;\n                       alu_clk <= ~alu_clk;\n                         state <= S3;\n                      end\n                 S3:\n                      begin   \n                          clk2 <= ~clk2;\n                         state <= S4;\n                      end\n                 S4:\n                      begin\n                          clk2  <= ~clk2;\n                          clk4  <= ~clk4;\n                          fetch <= ~fetch;\n                          state <= S5;\n                      end\n                 S5:\n                       begin\n                          clk2  <= ~clk2;\n                          state <= S6;\n                       end\n                 S6:\n                       begin\n                           clk2  <= ~clk2;\n                            clk4 <= ~clk4;\n                           state <= S7;\n                        end\n                 S7:\n                        begin\n                             clk2  <= ~clk2;\n                             state <=  S8;\n                        end\n                 S8:\n                        begin\n                             clk2 <= ~clk2;\n                            clk4  <= ~clk4;\n                            fetch <= ~fetch;\n                            state <= S1;\n                        end\n                idle:       state <= S1;   \n                default:    state <= idle;               \n            endcase\n     end\nendmodule\n",
        "module_name": "clk_gen",
        "module_hash": "0098718922f8c93720f9ef7a8fab01a7",
        "dataset_index": 13070
      },
      "sky130_fd_sc_lp__or2b_03bbf6ca": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__or2b (\n    X  ,\n    A  ,\n    B_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , B_N            );\n    or  or0  (or0_out_X, not0_out, A    );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__or2b",
        "module_hash": "03bbf6caec941ddcae3f4da60b6f9a98",
        "dataset_index": 23709
      },
      "sky130_fd_sc_ms__xnor3_a188499b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__xnor3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xnor0_out_X;\n\n    xnor xnor0 (xnor0_out_X, A, B, C        );\n    buf  buf0  (X          , xnor0_out_X    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__xnor3",
        "module_hash": "a188499bd1b99be501c0b1ce331b4742",
        "dataset_index": 23221
      },
      "nor_gate_e3a7cf52": {
        "rtl_code": "module nor_gate (\n    input a, b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule\n\nmodule mux_2to1 (\n    input a, b, sel,\n    output out\n);\n    wire nor_a, nor_b, nor_sel;\n\n    nor_gate nor1 (.a(a), .b(sel), .out(nor_a));\n    nor_gate nor2 (.a(b), .b(~sel), .out(nor_b));\n    nor_gate nor3 (.a(nor_a), .b(nor_b), .out(out));\nendmodule\n\nmodule subtractor (\n    input [1:0] in,\n    output [1:0] diff\n);\n    wire [1:0] sub_const = 2'b01;\n\n    assign diff = in - sub_const;\nendmodule\n\nmodule top_module (\n    input a, b,\n    input sel,\n    output [1:0] diff\n);\n    wire mux_out;\n\n    mux_2to1 mux (.a(a), .b(b), .sel(sel), .out(mux_out));\n    subtractor sub (.in({1'b0, mux_out}), .diff(diff));\nendmodule",
        "module_name": "nor_gate",
        "module_hash": "e3a7cf525811c4b667017526a35dda9a",
        "dataset_index": 2115
      },
      "ram16b_e5083dfe": {
        "rtl_code": "\n\n\nmodule ram16b(\n\tinput\t[15:0]\twdata,\n\tinput\t\twen,\n\tinput\t[4:0]\twaddr,\n\tinput\t\twclk,\n\toutput\t[15:0]\trdata,\n\tinput\t[4:0]\traddr,\n\tinput\t\trclk\n);\n`ifdef synthesis\n\tram16b_ice40 ram(\n\t\t.wdata(wdata),\n\t\t.wen(wen),\n\t\t.waddr(waddr),\n\t\t.wclk(wclk),\n\t\t.rdata(rdata),\n\t\t.raddr(raddr),\n\t\t.rclk(rclk)\n\t);\n`endif\n`ifndef synthesis\n\tram16b_sim ram(\n\t\t.wdata(wdata),\n\t\t.wen(wen),\n\t\t.waddr(waddr),\n\t\t.wclk(wclk),\n\t\t.rdata(rdata),\n\t\t.raddr(raddr),\n\t\t.rclk(rclk)\n\t);\n`endif\nendmodule\n\n`ifdef synthesis\nmodule ram16b_ice40 (\n\tinput\t[15:0]\twdata,\n\tinput\t\twen,\n\tinput\t[4:0]\twaddr,\n\tinput\t\twclk,\n\toutput\t[15:0]\trdata,\n\tinput\t[4:0]\traddr,\n\tinput\t\trclk\n);\n\tSB_RAM40_4K ram(\n\t\t.WDATA(wdata),\n\t\t.MASK({16{wen}}),\n\t\t.WADDR({3'b000, waddr}),\n\t\t.WE(wen),\n\t\t.WCLKE(1'b1),\n\t\t.WCLK(wclk),\n\n\t\t.RDATA(rdata),\n\t\t.RADDR({3'b000, raddr}),\n\t\t.RE(1'b1),\n\t\t.RCLKE(1'b1),\n\t\t.RCLK(rclk)\n\t);\nendmodule\n`endif\n\n`ifndef synthesis\nmodule ram16b_sim (\n\tinput\t[15:0]\twdata,\n\tinput\t\twen,\n\tinput\t[4:0]\twaddr,\n\tinput\t\twclk,\n\toutput\t[15:0]\trdata,\n\tinput\t[4:0]\traddr,\n\tinput\t\trclk\n);\n\treg [15:0] memory[0:31];\n\treg [4:0] raddr_r;\n\n\talways @(posedge wclk) begin\n\t\tif(wen) begin\n\t\t\tmemory[waddr] <= wdata;\n\t\tend\n\tend\n\n\talways @(posedge rclk) begin\n\t\traddr_r <= raddr;\n\tend\n\n\tassign rdata = memory[raddr_r];\nendmodule\n`endif\n\n",
        "module_name": "ram16b",
        "module_hash": "e5083dfe14002f0c16c7d97e00d5525e",
        "dataset_index": 23399
      },
      "comparator_afb1edca": {
        "rtl_code": "module comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if(a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end\n        else if(a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end\n        else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "afb1edcaed03309de33eb1c018ebcad2",
        "dataset_index": 16961
      },
      "ng_INP_159285a1": {
        "rtl_code": "module ng_INP(\n\tinput  \t\t\t\t\t\tCLK2,\t\t\t\tinput  \t\t\t\t\t\tNSA,\t\t\t\tinput  \t\t[ 4:0]\t\tKeypad,\t\t\tinput\t\t\t\t\t\t\tKeyready,\t\toutput  \t\t[15:0]\t\tINP_BUS,\t\t\toutput  \t\t\t\t\t\tKeyStrobe\t\t);\n\nassign INP_BUS   = {2'b00, !NSA, 8'h00, Keypad};\nreg [2:0] DRedge;  \nalways @(posedge CLK2) DRedge <= {DRedge[1:0], Keyready};\nwire DR_risingedge  = (DRedge[2:1] == 2'b01);      assign KeyStrobe = DR_risingedge;\n\nendmodule\n",
        "module_name": "ng_INP",
        "module_hash": "159285a15dfee6a0196608226531dc2a",
        "dataset_index": 21187
      },
      "controller_bf0b1626": {
        "rtl_code": "\n\nmodule controller (\n  input  wire        clock,\n  input  wire        reset,\n  input  wire        run,\n  input  wire        wrSize,\n  input  wire [31:0] config_data,\n  input  wire        validIn,\n  input  wire [31:0] dataIn,\n  input  wire        busy,\n  input  wire        arm,\n  output reg         send,\n  output reg  [31:0] memoryWrData,\n  output reg         memoryRead,\n  output reg         memoryWrite,\n  output reg         memoryLastWrite\n);\n\nreg [15:0] fwd; reg [15:0] bwd;\n\nreg next_send;\nreg next_memoryRead;\nreg next_memoryWrite;\nreg next_memoryLastWrite;\n\nreg [17:0] counter, next_counter; \nwire [17:0] counter_inc = counter+1'b1;\n\nalways @(posedge clock) \nmemoryWrData <= dataIn;\n\nlocalparam [2:0]\n  IDLE =     3'h0,\n  SAMPLE =   3'h1,\n  DELAY =    3'h2,\n  READ =     3'h3,\n  READWAIT = 3'h4;\n\nreg [2:0] state, next_state; \n\ninitial state = IDLE;\nalways @(posedge clock, posedge reset) \nif (reset) begin\n  state           <= IDLE;\n  memoryWrite     <= 1'b0;\n  memoryLastWrite <= 1'b0;\n  memoryRead      <= 1'b0;\nend else begin\n  state           <= next_state;\n  memoryWrite     <= next_memoryWrite;\n  memoryLastWrite <= next_memoryLastWrite;\n  memoryRead      <= next_memoryRead;\nend\n\nalways @(posedge clock)\nbegin\n  counter <= next_counter;\n  send    <= next_send;\nend\n\nalways @*\nbegin\n  next_state = state;\n  next_counter = counter;\n  next_memoryWrite = 1'b0;\n  next_memoryLastWrite = 1'b0;\n  next_memoryRead = 1'b0;\n  next_send = 1'b0;\n\n  case(state)\n    IDLE :\n      begin\n        next_counter = 0;\n        next_memoryWrite = 1;\n\tif (run) next_state = DELAY;\n\telse if (arm) next_state = SAMPLE;\n      end\n\n    SAMPLE : \n      begin\n        next_counter = 0;\n        next_memoryWrite = validIn;\n        if (run) next_state = DELAY;\n      end\n\n    DELAY : \n      begin\n\tif (validIn)\n\t  begin\n\t    next_memoryWrite = 1'b1;\n            next_counter = counter_inc;\n            if (counter == {fwd,2'b11}) \tbegin\t\t\t\tnext_memoryLastWrite = 1'b1;\tnext_counter = 0;\n\t\tnext_state = READ;\n\t      end\n\t  end\n      end\n\n    READ : \n      begin\n        next_memoryRead = 1'b1;\n        next_send = 1'b1;\n        if (counter == {bwd,2'b11}) \n\t  begin\n            next_counter = 0;\n            next_state = IDLE;\n          end\n        else \n\t  begin\n            next_counter = counter_inc;\n            next_state = READWAIT;\n          end\n      end\n\n    READWAIT : \n      begin\n        if (!busy && !send) next_state = READ;\n      end\n  endcase\nend\n\n\nalways @(posedge clock) \nif (wrSize) {fwd, bwd} <= config_data[31:0];\n\nendmodule\n",
        "module_name": "controller",
        "module_hash": "bf0b1626023d3fa37708c788d213a5c6",
        "dataset_index": 3140
      },
      "nor3__d2f0535a": {
        "rtl_code": "module nor3_module (\n    input A,\n    input B,\n    input C_N,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign Y = ~(A | B | C_N);\n\nendmodule",
        "module_name": "nor3_",
        "module_hash": "d2f0535a466f0f1aa33ea327ee6a96df",
        "dataset_index": 12147
      },
      "shift_reg_44a386a2": {
        "rtl_code": "\nmodule shift_reg (\n    input [3:0] data_in,\n    input load,\n    input clk,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if(load) begin\n        q[3] <= data_in;\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\n    else begin\n        q[3] <= q[2];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= data_in;\n    end\nend\n\nendmodule",
        "module_name": "shift_reg",
        "module_hash": "44a386a27121cd00e0b1c4c9599580d2",
        "dataset_index": 14494
      },
      "glitch_filter_8e951759": {
        "rtl_code": "\nmodule glitch_filter (\n  input in,\n  output out,\n  input clk\n);\n\n  reg delay_line;\n\n  always @(posedge clk) begin\n    delay_line <= in;\n  end\n\n  assign out = (in == delay_line) ? in : delay_line;\n\nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "8e951759d81f0a68be5185d4cb8701c7",
        "dataset_index": 14964
      },
      "top__198a9284": {
        "rtl_code": "\nmodule top_module (\n    input [1:0] in,    // Input for the 2-to-4 decoder\n    input [3:0] a,    // Input A for the adder-subtractor\n    input [3:0] b,    // Input B for the adder-subtractor\n    input sub,         // Subtraction flag for the adder-subtractor\n    output [3:0] q,    // Output from the functional module\n    output overflow   // Overflow output from the adder-subtractor\n);\n\n    // 2-to-4 decoder module\n    wire [3:0] dec_out;\n    decoder_2to4 dec(\n        .in(in),\n        .out(dec_out)\n    );\n\n    // Adder-subtractor module\n    wire [3:0] addsub_out;\n    wire addsub_overflow;\n    adder_subtractor addsub(\n        .a(a),\n        .b(b),\n        .sub(sub),\n        .q(addsub_out),\n        .overflow(addsub_overflow)\n    );\n\n    // Functional module\n    assign q = (dec_out[0] == 1'b0) ? addsub_out : 4'b0;\n    assign overflow = (dec_out[0] == 1'b0) ? addsub_overflow : (dec_out[1] || dec_out[2] || dec_out[3]);\n\nendmodule\nmodule decoder_2to4 (\n    input [1:0] in,    // Input for the 2-to-4 decoder\n    output [3:0] out   // Output from the 2-to-4 decoder\n);\n\n    assign out[0] = ~in[0] & ~in[1];\n    assign out[1] = ~in[0] &  in[1];\n    assign out[2] =  in[0] & ~in[1];\n    assign out[3] =  in[0] &  in[1];\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] a,    // Input A for the adder-subtractor\n    input [3:0] b,    // Input B for the adder-subtractor\n    input sub,         // Subtraction flag for the adder-subtractor\n    output [3:0] q,    // Output from the adder-subtractor\n    output overflow   // Overflow output from the adder-subtractor\n);\n\n    // Intermediate sum\n    wire [4:0] sum = (sub) ? (a - b) : (a + b);\n    \n    // Assign q and overflow\n    assign q = sum[3:0];\n    assign overflow = sum[4];\n\nendmodule",
        "module_name": "top_",
        "module_hash": "198a9284a6de58ce919e21d49103cf7b",
        "dataset_index": 355
      },
      "count_ones_9a001e64": {
        "rtl_code": "module count_ones(\n  input a,\n  input b,\n  input c,\n  output reg [1:0] count\n);\n\n  always @(*) begin\n    case ({a, b, c})\n      3'b000: count = 2'b00;\n      3'b001: count = 2'b01;\n      3'b010: count = 2'b01;\n      3'b011: count = 2'b10;\n      3'b100: count = 2'b01;\n      3'b101: count = 2'b10;\n      3'b110: count = 2'b10;\n      3'b111: count = 2'b11;\n    endcase\n  end\n\nendmodule",
        "module_name": "count_ones",
        "module_hash": "9a001e64944ca5319f5c9988a1ee77de",
        "dataset_index": 13660
      },
      "decoder_3to8_0499c0f6": {
        "rtl_code": "module decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg [7:0] Y\n);\n\n    always @* begin\n        case ({A,B,C})\n            3'b000: Y = 8'b00000001;\n            3'b001: Y = 8'b00000010;\n            3'b010: Y = 8'b00000100;\n            3'b011: Y = 8'b00001000;\n            3'b100: Y = 8'b00010000;\n            3'b101: Y = 8'b00100000;\n            3'b110: Y = 8'b01000000;\n            3'b111: Y = 8'b10000000;\n            default: Y = 8'b00000000;\n        endcase\n    end\n\nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "0499c0f6664754f639e629cf0bc51b07",
        "dataset_index": 20250
      },
      "counter_4295272d": {
        "rtl_code": "module counter(\n    output reg [3:0] out,\n    input clk,\n    input reset\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'd0;\n        end else begin\n            out <= out + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "4295272d0496f598638c4597cf1065aa",
        "dataset_index": 19046
      },
      "decoder_a4ee7368": {
        "rtl_code": "\nmodule decoder (\n    input sel1,\n    input sel0,\n    output [15:0] out\n);\n    \n    assign out[0]  = ~sel1 & ~sel0;\n    assign out[1]  = ~sel1 & sel0;\n    assign out[2]  = sel1 & ~sel0;\n    assign out[3]  = sel1 & sel0;\n    assign out[4]  = ~sel1 & ~sel0 & ~sel1;\n    assign out[5]  = ~sel1 & ~sel0 & sel1;\n    assign out[6]  = ~sel1 & sel0 & ~sel1;\n    assign out[7]  = ~sel1 & sel0 & sel1;\n    assign out[8]  = sel1 & ~sel0 & ~sel1;\n    assign out[9]  = sel1 & ~sel0 & sel1;\n    assign out[10] = sel1 & sel0 & ~sel1;\n    assign out[11] = sel1 & sel0 & sel1;\n    assign out[12] = ~sel1 & ~sel0 & sel1;\n    assign out[13] = ~sel1 & sel0 & sel1;\n    assign out[14] = sel1 & ~sel0 & sel1;\n    assign out[15] = sel1 & sel0 & sel1;\n\nendmodule\n",
        "module_name": "decoder",
        "module_hash": "a4ee736881b815769dc17b7bbf48173f",
        "dataset_index": 15208
      },
      "led_controller_5b25211e": {
        "rtl_code": "module led_controller(\n    input CLK,\n    input RX,\n    output reg TX,\n    output reg LED1,\n    output reg LED2,\n    output reg LED3,\n    output reg LED4,\n    output reg LED5\n);\n\n    reg [1:0] state = 0;\n\n    always @(posedge CLK) begin\n        case(state)\n            2'b00: begin\n                if(RX == 1) begin\n                    state <= 2'b01;\n                    LED1 <= 1;\n                    LED2 <= 1;\n                    LED3 <= 1;\n                    LED4 <= 1;\n                    LED5 <= 1;\n                end else if(RX == 2) begin\n                    state <= 2'b10;\n                    LED1 <= 0;\n                    LED2 <= 0;\n                    LED3 <= 0;\n                    LED4 <= 0;\n                    LED5 <= 0;\n                end else if(RX == 3) begin\n                    state <= 2'b11;\n                    LED1 <= 1;\n                    LED2 <= 1;\n                    LED3 <= 0;\n                    LED4 <= 0;\n                    LED5 <= 0;\n                end else if(RX == 4) begin\n                    state <= 2'b11;\n                    LED1 <= 0;\n                    LED2 <= 0;\n                    LED3 <= 1;\n                    LED4 <= 1;\n                    LED5 <= 0;\n                end else if(RX == 5) begin\n                    state <= 2'b11;\n                    LED1 <= 0;\n                    LED2 <= 0;\n                    LED3 <= 0;\n                    LED4 <= 0;\n                    LED5 <= 1;\n                end\n            end\n            2'b01, 2'b10: begin\n                TX <= RX;\n                state <= 2'b00;\n            end\n            2'b11: begin\n                if(RX == 1 || RX == 2 || RX == 5) begin\n                    state <= 2'b00;\n                end\n            end\n        endcase\n    end\n\nendmodule",
        "module_name": "led_controller",
        "module_hash": "5b25211eb551da3917cf5709e01a4f2e",
        "dataset_index": 15421
      },
      "sky130_fd_sc_hd__sdfrtn_d911e69e": {
        "rtl_code": "module sky130_fd_sc_hd__sdfrtn (\n    Q      ,\n    CLK_N  ,\n    D      ,\n    SCD    ,\n    SCE    ,\n    RESET_B\n);\n\n    output Q      ;\n    input  CLK_N  ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  RESET_B;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    reg Q;\n\n    always @(negedge CLK_N) begin\n        if(RESET_B == 1'b0) begin\n            Q <= 1'b0;\n        end else if(SCD == 1'b1) begin\n            Q <= 1'b0;\n        end else if(SCE == 1'b0) begin\n            Q <= Q;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__sdfrtn",
        "module_hash": "d911e69ea63a2268079dd026e4cd1436",
        "dataset_index": 1215
      },
      "counter_7a8da69d": {
        "rtl_code": "module counter(\n    input clk,\n    input rst,\n    input en,\n    input [15:0] max_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end else if (en) begin\n        if (count == max_count) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "7a8da69dfe3f442ad0e1089990a38036",
        "dataset_index": 13060
      },
      "data_mem_65ed2679": {
        "rtl_code": "\nmodule data_mem (data_out,data_in,mem_ctrl_addr,clk,dm_ctrl_sig);\n\n// Output signals...\noutput [0:127] data_out;\n\n// Input signals\ninput [0:127] data_in;\ninput [0:31] mem_ctrl_addr;\ninput clk;\ninput [0:1] dm_ctrl_sig;\n\n// Declare \"reg\" signals: \nreg [0:127] data_out;\t\t\t\t\t// 128-bit register for data output\nreg [0:127] data_mem [0:255];\t\t\t// 256 x 128-bit memory array\n\n\n// Read or write data based on control signal\nalways @(posedge clk) begin\n    case (dm_ctrl_sig)\n        2'b00: data_out <= data_mem[mem_ctrl_addr];\n        2'b01: data_mem[mem_ctrl_addr] <= data_in;\n        default: data_out <= 128'd0;\n    endcase\nend\n\nendmodule\n",
        "module_name": "data_mem",
        "module_hash": "65ed26791d6e4a46875c6f313e908c58",
        "dataset_index": 20178
      },
      "cheat_53eed0b7": {
        "rtl_code": "\nmodule cheat(\n  input clk,\n  input [23:0] SNES_ADDR,\n  input [7:0] SNES_DATA,\n  input SNES_reset_strobe,\n  input snescmd_wr_strobe,\n  input SNES_cycle_start,\n  input [2:0] pgm_idx,\n  input pgm_we,\n  input [31:0] pgm_in,\n  output [7:0] data_out,\n  output cheat_hit,\n  output snescmd_unlock\n);\n\nreg cheat_enable = 0;\nreg nmi_enable = 0;\nreg irq_enable = 0;\nreg holdoff_enable = 0; reg auto_nmi_enable = 1;\nreg auto_irq_enable = 0;\nreg auto_nmi_enable_sync = 0;\nreg auto_irq_enable_sync = 0;\nreg hook_enable_sync = 0;\n\nreg [1:0] sync_delay = 2'b10;\n\nreg [4:0] nmi_usage = 5'h00;\nreg [4:0] irq_usage = 5'h00;\nreg [20:0] usage_count = 21'h1fffff;\n\nreg [29:0] hook_enable_count = 0;\nreg hook_disable = 0;\n\nreg [3:0] unlock_token = 0;\nreg [6:0] temp_unlock_delay = 0;\nreg temp_vector_unlock = 0;\n\nreg [23:0] cheat_addr[5:0];\nreg [7:0] cheat_data[5:0];\nreg [5:0] cheat_enable_mask;\nwire [5:0] cheat_match_bits ={(cheat_enable_mask[5] & (SNES_ADDR == cheat_addr[5])),\n                              (cheat_enable_mask[4] & (SNES_ADDR == cheat_addr[4])),\n                              (cheat_enable_mask[3] & (SNES_ADDR == cheat_addr[3])),\n                              (cheat_enable_mask[2] & (SNES_ADDR == cheat_addr[2])),\n                              (cheat_enable_mask[1] & (SNES_ADDR == cheat_addr[1])),\n                              (cheat_enable_mask[0] & (SNES_ADDR == cheat_addr[0]))};\nwire cheat_addr_match = |cheat_match_bits;\n\nwire [1:0] nmi_match_bits = {SNES_ADDR == 24'h00FFEA, SNES_ADDR == 24'h00FFEB};\nwire [1:0] irq_match_bits = {SNES_ADDR == 24'h00FFEE, SNES_ADDR == 24'h00FFEF};\n\nwire nmi_addr_match = |nmi_match_bits;\nwire irq_addr_match = |irq_match_bits;\n\n\nwire hook_enable = ~|hook_enable_count & ~hook_disable;\n\nassign snescmd_unlock = &unlock_token | temp_vector_unlock;\n\nassign data_out = cheat_match_bits[0] ? cheat_data[0]\n                : cheat_match_bits[1] ? cheat_data[1]\n                : cheat_match_bits[2] ? cheat_data[2]\n                : cheat_match_bits[3] ? cheat_data[3]\n                : cheat_match_bits[4] ? cheat_data[4]\n                : cheat_match_bits[5] ? cheat_data[5]\n                : nmi_match_bits[1] ? 8'hb0\n                : irq_match_bits[1] ? 8'hc4\n                : 8'h2b;\n\nassign cheat_hit = (cheat_enable & cheat_addr_match)\n                   | (hook_enable_sync & (((auto_nmi_enable_sync & nmi_enable) & nmi_addr_match)\n                                           |((auto_irq_enable_sync & irq_enable) & irq_addr_match)));\n\nalways @(posedge clk) usage_count <= usage_count - 1;\n\nalways @(posedge clk) begin\n  if(usage_count == 21'b0) begin\n    nmi_usage <= ~hook_disable & SNES_cycle_start & nmi_match_bits[1];\n    irq_usage <= ~hook_disable & SNES_cycle_start & irq_match_bits[1];\n    if(|nmi_usage & |irq_usage) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(irq_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(nmi_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b0;\n      auto_irq_enable <= 1'b1;\n    end\n  end else begin\n    if(SNES_cycle_start & nmi_match_bits[0] & ~hook_disable) nmi_usage <= nmi_usage + 1;\n    if(SNES_cycle_start & irq_match_bits[0] & ~hook_disable) irq_usage <= irq_usage + 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) begin\n      temp_unlock_delay <= 7'd72;\n      temp_vector_unlock <= 1'b1;\n    end else begin\n      if (|temp_unlock_delay) temp_unlock_delay <= temp_unlock_delay - 1;\n      if (temp_unlock_delay == 7'd0) begin\n        temp_vector_unlock <= 1'b0;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) sync_delay <= 2'b10;\n    else begin\n      if (|sync_delay) sync_delay <= sync_delay - 1;\n      if (sync_delay == 2'b00) begin\n        auto_nmi_enable_sync <= auto_nmi_enable;\n        auto_irq_enable_sync <= auto_irq_enable;\n        hook_enable_sync <= hook_enable;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_wr_strobe) begin\n    if(SNES_ADDR[8:0] == 9'h1f4 && SNES_DATA == 8'h48) unlock_token[0] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f5 && SNES_DATA == 8'h75) unlock_token[1] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f6 && SNES_DATA == 8'h72) unlock_token[2] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f7 && SNES_DATA == 8'h7a) unlock_token[3] <= 1'b1;\n    else if(SNES_ADDR[8:2] == 9'b1111101) unlock_token <= 4'b0000;\n  end else if(SNES_reset_strobe) unlock_token <= 4'b0000;\nend\n\nalways @(posedge clk) begin\n  if((snescmd_unlock & snescmd_wr_strobe & ~|SNES_ADDR[8:0] & (SNES_DATA == 8'h85))\n     | (holdoff_enable & SNES_reset_strobe)) begin\n    hook_enable_count <= 30'd880000000;\n  end else if (|hook_enable_count) begin\n    hook_enable_count <= hook_enable_count - 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_unlock & snescmd_wr_strobe) begin\n    if(~|SNES_ADDR[8:0]) begin\n      case(SNES_DATA)\n        8'h82: cheat_enable <= 1;\n        8'h83: cheat_enable <= 0;\n        8'h84: {nmi_enable, irq_enable} <= 2'b00;\n      endcase\n    end else if(SNES_ADDR[8:0] == 9'h1fd) begin\n      hook_disable <= SNES_DATA[0];\n    end\n  end else if(pgm_we) begin\n    if(pgm_idx < 6) begin\n      cheat_addr[pgm_idx] <= pgm_in[31:8];\n      cheat_data[pgm_idx] <= pgm_in[7:0];\n    end else if(pgm_idx == 6) begin cheat_enable_mask <= pgm_in[5:0];\n    end else if(pgm_idx == 7) begin {holdoff_enable, irq_enable, nmi_enable, cheat_enable} <= ({holdoff_enable, irq_enable, nmi_enable, cheat_enable} & ~pgm_in[7:4])\n                                                                 | pgm_in[3:0];\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "cheat",
        "module_hash": "53eed0b75cfd5eb7e9cd93cba205b245",
        "dataset_index": 25213
      },
      "my__98b27d98": {
        "rtl_code": "\nmodule my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire A;\n    wire B;\n    wire C;\n    wire D;\n    wire E;\n    wire F;\n\n    assign A = A1 & A2;\n    assign B = ~A1 & ~A2;\n    assign C = B1 & C1;\n    assign D = ~B1 & ~C1;\n    assign E = A & C;\n    assign F = B & D;\n\n    assign Y = E | F;\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "98b27d98e99f40fa785412e5304080ef",
        "dataset_index": 15659
      },
      "sky130_fd_sc_ls__o221ai_98c4cb90": {
        "rtl_code": "module sky130_fd_sc_ls__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    // Module ports\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    //   Name   Output       Other arguments\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__o221ai",
        "module_hash": "98c4cb90621457d61123823ec9c3197b",
        "dataset_index": 11394
      },
      "counter_f5f4615e": {
        "rtl_code": "module counter (\n  input clk,\n  input rst,\n  input load,\n  input [7:0] data_in,\n  output reg [7:0] count,\n  output reg max_count\n);\n\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst) begin\n      count <= 8'h00;\n      max_count <= 1'b0;\n    end\n    else if (load) begin\n      count <= data_in;\n      max_count <= 1'b0;\n    end\n    else begin\n      count <= count + 1;\n      if (count == 8'hFF) begin\n        max_count <= 1'b1;\n        count <= 8'h00;\n      end\n      else begin\n        max_count <= 1'b0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "f5f4615e3c68c13cba07fcae8cd207ab",
        "dataset_index": 12019
      },
      "NIOS_SYSTEMV3_NIOS_CPU_nios2_oci_im_603d881e": {
        "rtl_code": "module NIOS_SYSTEMV3_NIOS_CPU_nios2_oci_im (\n  input clk,\n  input [37:0] jdo,\n  input jrst_n,\n  input reset_n,\n  input take_action_tracectrl,\n  input take_action_tracemem_a,\n  input take_action_tracemem_b,\n  input take_no_action_tracemem_a,\n  input [15:0] trc_ctrl,\n  input [35:0] tw,\n  output reg tracemem_on,\n  output reg [35:0] tracemem_trcdata,\n  output reg tracemem_tw,\n  output reg trc_enb,\n  output reg [6:0] trc_im_addr,\n  output reg trc_wrap,\n  output reg xbrk_wrap_traceoff\n);\n\n  wire trc_on_chip = ~trc_ctrl[8];\n  wire tw_valid = |tw[35:32];\n\n  always @(posedge clk or negedge jrst_n) begin\n    if (!jrst_n) begin\n      trc_im_addr <= 0;\n      trc_wrap <= 0;\n    end else if (!take_action_tracectrl && !take_action_tracemem_a && !take_action_tracemem_b && !take_no_action_tracemem_a) begin\n      trc_im_addr <= 0;\n      trc_wrap <= 0;\n    end else if (take_action_tracectrl && (jdo[4] | jdo[3])) begin\n      if (jdo[4]) trc_im_addr <= 0;\n      if (jdo[3]) trc_wrap <= 0;\n    end else if (trc_enb & trc_on_chip & tw_valid) begin\n      trc_im_addr <= trc_im_addr + 1;\n      if (&trc_im_addr) trc_wrap <= 1;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) trc_enb <= 0;\n    else trc_enb <= trc_ctrl[0];\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) tracemem_on <= 0;\n    else tracemem_on <= trc_enb;\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) tracemem_trcdata <= 0;\n    else tracemem_trcdata <= (trc_enb & tw_valid) ? tw : tracemem_trcdata;\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) tracemem_tw <= 0;\n    else tracemem_tw <= trc_wrap;\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) xbrk_wrap_traceoff <= 0;\n    else xbrk_wrap_traceoff <= trc_ctrl[10] & trc_wrap;\n  end\n\nendmodule",
        "module_name": "NIOS_SYSTEMV3_NIOS_CPU_nios2_oci_im",
        "module_hash": "603d881e37bb52c5acd54f387b3fb99f",
        "dataset_index": 20964
      },
      "pipeline_module_6247cd98": {
        "rtl_code": "\nmodule pipeline_module( input in, input clk, output out );\n  wire inv_in;\n  reg inv_out;\n\n  assign inv_in = ~in;\n  assign out = inv_out;\n\n  always @(posedge clk) begin\n    inv_out <= inv_in;\n  end\nendmodule\n",
        "module_name": "pipeline_module",
        "module_hash": "6247cd980fbee4823d7b8b93f2650c14",
        "dataset_index": 18391
      },
      "aq_axi_memcpy32_ctl_50d2ff81": {
        "rtl_code": "\nmodule aq_axi_memcpy32_ctl(\n\tinput\t\t\tRST_N,\n\tinput\t\t\tCLK,\n\n\tinput\t\t\tCMD_REQ,\n\toutput\t\t\tCMD_READY,\n\toutput\t\t\tCMD_DONE,\n\tinput [31:0]\tCMD_DST,\n\tinput [31:0]\tCMD_SRC,\n\tinput [31:0]\tCMD_LEN,\n\n\tinput\t\t\tCMD_CLK,\n\n\toutput\t\t\tWR_START,\n\toutput [31:0]\tWR_ADRS,\n\toutput [31:0]\tWR_COUNT,\n\tinput\t\t\tWR_READY,\n\n\toutput\t\t\tRD_START,\n\toutput [31:0]\tRD_ADRS,\n\toutput [31:0]\tRD_COUNT,\n\tinput\t\t\tRD_READY,\n\n\toutput\t\t\tFIFO_RST\n);\n\nlocalparam S_IDLE\t\t= 0;\nlocalparam S_READ_PRE\t= 1;\nlocalparam S_READ\t\t= 2;\nlocalparam S_READ_WAIT\t= 3;\nlocalparam S_WRITE_PRE\t= 4;\nlocalparam S_WRITE\t\t= 5;\nlocalparam S_WRITE_WAIT\t= 6;\n\nreg [31:0]\treg_wr_adrs, reg_rd_adrs;\nreg [31:0]\treg_wr_count, reg_rd_count;\n\nreg [2:0] state;\n\nalways @(posedge CLK or negedge RST_N) begin\n\tif(!RST_N) begin\n\t\tstate \t\t\t\t<= S_IDLE;\n\t\treg_wr_adrs[31:0]\t<= 32'd0;\n\t\treg_wr_count[31:0]\t<= 32'd0;\n\t\treg_rd_adrs[31:0]\t<= 32'd0;\n\t\treg_rd_count[31:0]\t<= 32'd0;\n\tend else begin\n\t\tcase(state)\n\t\t\tS_IDLE: begin\n\t\t\t\tif(CMD_REQ) begin\n\t\t\t\t\tstate\t<= S_READ_PRE;\n\t\t\t\t\treg_wr_adrs[31:0]\t<= CMD_DST;\n\t\t\t\t\treg_wr_count[31:0]\t<= CMD_LEN;\n\t\t\t\t\treg_rd_adrs[31:0]\t<= CMD_SRC;\n\t\t\t\t\treg_rd_count[31:0]\t<= CMD_LEN;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_READ_PRE: begin\n\t\t\t\tif(WR_READY) begin\n\t\t\t\t\tstate <= S_READ;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_READ: begin\n\t\t\t\tstate <= S_READ_WAIT;\n\t\t\tend\n\t\t\tS_READ_WAIT: begin\n\t\t\t\tif(WR_READY) begin\n\t\t\t\t\tstate <= S_WRITE_PRE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_WRITE_PRE: begin\n\t\t\t\tif(RD_READY) begin\n\t\t\t\t\tstate <= S_WRITE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_WRITE: begin\n\t\t\t\tstate <= S_WRITE_WAIT;\n\t\t\tend\n\t\t\tS_WRITE_WAIT: begin\n\t\t\t\tif(RD_READY) begin\n\t\t\t\t\tstate <= S_IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nassign WR_START\t\t\t= (state == S_WRITE)?1'b1:1'b0;\nassign WR_ADRS[31:0]\t= reg_wr_adrs[31:0];\nassign WR_COUNT[31:0]\t= reg_wr_count[31:0];\nassign RD_START\t\t\t= (state == S_READ)?1'b1:1'b0;\nassign RD_ADRS[31:0]\t= reg_rd_adrs[31:0];\nassign RD_COUNT[31:0]\t= reg_rd_count[31:0];\n\nassign CMD_READY\t\t= (state == S_IDLE)?1'b1:1'b0;\nassign CMD_DONE\t\t\t= (state == S_IDLE)?1'b1:1'b0;\n\nassign FIFO_RST\t\t\t= (state == S_IDLE)?1'b1:1'b0;\n\nendmodule\n\n",
        "module_name": "aq_axi_memcpy32_ctl",
        "module_hash": "50d2ff81978cf6c4eba0ce3d93aa2955",
        "dataset_index": 22667
      },
      "dual_port_ram_5905ae09": {
        "rtl_code": "module dual_port_ram (\n  input clk,\n  input we1, we2,\n  input [$clog2(depth)-1:0] addr1, addr2,\n  input [width-1:0] data_in1, data_in2,\n  output reg [width-1:0] data_out1, data_out2\n);\n\nparameter depth = 1024;\nparameter width = 16;\n\nreg [width-1:0] mem [0:depth-1];\n\nalways @(posedge clk) begin\n  if (we1) mem[addr1] <= data_in1;\n  if (we2) mem[addr2] <= data_in2;\n  data_out1 <= mem[addr1];\n  data_out2 <= mem[addr2];\nend\n\nendmodule",
        "module_name": "dual_port_ram",
        "module_hash": "5905ae093e5d8d209c24dbc8f8aae686",
        "dataset_index": 11575
      },
      "add4bit_40aa46ac": {
        "rtl_code": "module add4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [4:0] SUM\n);\n\nalways @(*) begin\n    SUM = A + B;\n    if (SUM > 15) begin\n        SUM = SUM + 16;\n        SUM[4] = 1;\n    end else begin\n        SUM[4] = 0;\n    end\nend\n\nendmodule",
        "module_name": "add4bit",
        "module_hash": "40aa46ac5a4c127247c7797477ce738a",
        "dataset_index": 17997
      },
      "counter_combination_f249cb56": {
        "rtl_code": "\nmodule counter_combination (\n    input wire clk,\n    input wire reset,\n    input wire [1:0] vec,\n    output reg [3:0] outv,\n    output reg o1,\n    output reg o0\n);\n\n    reg [3:0] count_reg;\n    wire [3:0] and_out;\n\n    assign and_out = count_reg & {vec, 2'b00};\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 4'b0000;\n        end\n        else begin\n            count_reg <= count_reg + 1;\n        end\n    end\n\n    always @(*) begin\n        outv <= and_out;\n        o1 <= and_out[3];\n        o0 <= and_out[2];\n    end\n\nendmodule\nmodule top_module ( \n    input wire clk,\n    input wire reset,\n    input wire [1:0] vec,\n    output wire [3:0] outv,\n    output wire o1,\n    output wire o0,\n    output wire [3:0] and_out,\n    output wire [3:0] final_out\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] combination_out;\n\n    counter_combination counter_combination_inst (\n        .clk(clk),\n        .reset(reset),\n        .vec(vec),\n        .outv(counter_out),\n        .o1(o1),\n        .o0(o0)\n    );\n\n    assign and_out = counter_out & vec;\n    assign final_out = {~and_out[3:2], and_out[1:0]};\n    assign outv = final_out;\n\nendmodule",
        "module_name": "counter_combination",
        "module_hash": "f249cb56c77f0eee446319447745aa26",
        "dataset_index": 11837
      },
      "spram_interface_c273ea9c": {
        "rtl_code": "\nmodule spram_interface (\n    input clk,\n    input [15:0] wdata,\n    output reg [15:0] rdata,\n    input [7:0] addr,\n    input WE\n);\n\n    // SPRAM instance with initial values\n    \n    reg [15:0] ram [0:255];\n\n    // Set initial values\n    initial begin\n        ram[0] = 16'h1234;\n        ram[1] = 16'h5678;\n        ram[2] = 16'habcd;\n        ram[3] = 16'h0000;\n        ram[4] = 16'hffff;\n        ram[5] = 16'hffff;\n        ram[6] = 16'hffff;\n        ram[7] = 16'hffff;\n        ram[8] = 16'h0000;\n        ram[9] = 16'h0000;\n        ram[10] = 16'h0000;\n        ram[11] = 16'h0000;\n        ram[12] = 16'h0123;\n        ram[13] = 16'h4567;\n        ram[14] = 16'h89ab;\n        ram[15] = 16'hcdef;\n    end\n\n    // Read and write operations\n    always @(posedge clk) begin\n        if (WE) begin\n            ram[addr] <= wdata;\n        end\n        rdata <= ram[addr];\n    end\n\nendmodule\n",
        "module_name": "spram_interface",
        "module_hash": "c273ea9c74cd8772b2378b2cb54074f8",
        "dataset_index": 20434
      },
      "cf_mul_67a802cd": {
        "rtl_code": "\n\nmodule cf_mul (\n\n  clk,\n  data_a,\n  data_b,\n  data_p,\n  ddata_in,\n  ddata_out);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input           clk;\n  input   [16:0]  data_a;\n  input   [ 7:0]  data_b;\n  output  [24:0]  data_p;\n  input   [DW:0]  ddata_in;\n  output  [DW:0]  ddata_out;\n\n  reg             p1_sign = 'd0;\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [23:0]  p1_data_p_0 = 'd0;\n  reg     [23:0]  p1_data_p_1 = 'd0;\n  reg     [23:0]  p1_data_p_2 = 'd0;\n  reg     [23:0]  p1_data_p_3 = 'd0;\n  reg     [23:0]  p1_data_p_4 = 'd0;\n  reg             p2_sign = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [23:0]  p2_data_p_0 = 'd0;\n  reg     [23:0]  p2_data_p_1 = 'd0;\n  reg             p3_sign = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [23:0]  p3_data_p_0 = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [24:0]  data_p = 'd0;\n\n  wire    [16:0]  p1_data_a_1p_17_s;\n  wire    [16:0]  p1_data_a_1n_17_s;\n  wire    [23:0]  p1_data_a_1p_s;\n  wire    [23:0]  p1_data_a_1n_s;\n  wire    [23:0]  p1_data_a_2p_s;\n  wire    [23:0]  p1_data_a_2n_s;\n\n  assign p1_data_a_1p_17_s = {1'b0, data_a[15:0]};\n  assign p1_data_a_1n_17_s = ~p1_data_a_1p_17_s + 1'b1;\n\n  assign p1_data_a_1p_s = {{7{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s};\n  assign p1_data_a_1n_s = {{7{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s};\n  assign p1_data_a_2p_s = {{6{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s, 1'b0};\n  assign p1_data_a_2n_s = {{6{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s, 1'b0};\n\n  always @(posedge clk) begin\n    p1_sign <= data_a[16];\n    p1_ddata <= ddata_in;\n    case (data_b[1:0])\n      2'b11: p1_data_p_0 <= p1_data_a_1n_s;\n      2'b10: p1_data_p_0 <= p1_data_a_2n_s;\n      2'b01: p1_data_p_0 <= p1_data_a_1p_s;\n      default: p1_data_p_0 <= 24'd0;\n    endcase\n    case (data_b[3:1])\n      3'b011: p1_data_p_1 <= {p1_data_a_2p_s[21:0], 2'd0};\n      3'b100: p1_data_p_1 <= {p1_data_a_2n_s[21:0], 2'd0};\n      3'b001: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b010: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b101: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      3'b110: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      default: p1_data_p_1 <= 24'd0;\n    endcase\n    case (data_b[5:3])\n      3'b011: p1_data_p_2 <= {p1_data_a_2p_s[19:0], 4'd0};\n      3'b100: p1_data_p_2 <= {p1_data_a_2n_s[19:0], 4'd0};\n      3'b001: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b010: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b101: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      3'b110: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      default: p1_data_p_2 <= 24'd0;\n    endcase\n    case (data_b[7:5])\n      3'b011: p1_data_p_3 <= {p1_data_a_2p_s[17:0], 6'd0};\n      3'b100: p1_data_p_3 <= {p1_data_a_2n_s[17:0], 6'd0};\n      3'b001: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b010: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b101: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      3'b110: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      default: p1_data_p_3 <= 24'd0;\n    endcase\n    case (data_b[7])\n      1'b1: p1_data_p_4 <= {p1_data_a_1p_s[15:0], 8'd0};\n      default: p1_data_p_4 <= 24'd0;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    p2_sign <= p1_sign;\n    p2_ddata <= p1_ddata;\n    p2_data_p_0 <= p1_data_p_0 + p1_data_p_1 + p1_data_p_4;\n    p2_data_p_1 <= p1_data_p_2 + p1_data_p_3;\n  end\n\n  always @(posedge clk) begin\n    p3_sign <= p2_sign;\n    p3_ddata <= p2_ddata;\n    p3_data_p_0 <= p2_data_p_0 + p2_data_p_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    data_p <= {p3_sign, p3_data_p_0};\n  end\n\nendmodule\n\n",
        "module_name": "cf_mul",
        "module_hash": "67a802cd4d43053ea54c217fd456419f",
        "dataset_index": 24836
      },
      "data_test2_65ec7850": {
        "rtl_code": "module data_test2 (\n  input                 rst,            input                 clk,\n\n  output  reg           din_stb,\n  input         [1:0]   din_ready,\n  output  reg   [1:0]   din_activate,\n  output  reg   [31:0]  din,\n  input         [23:0]  din_size,\n\n  input                 dout_ready,\n  output  reg           dout_activate,\n  input         [31:0]  dout,\n  output  reg           dout_stb,\n  input         [23:0]  dout_size,\n\n  output  reg           count_error,\n  output  reg           incorrect_data,\n  output  reg   [23:0]  count_detected,\n  output  reg   [31:0]  detected_value\n\n);\n\nreg             [31:0]  write_count;\nreg             [31:0]  read_count;\nalways @ (posedge clk) begin\n  if (rst) begin\n    din_stb             <=  0;\n    din_activate        <=  0;\n    din                 <=  0;\n    write_count         <=  0;\n\n    dout_activate       <=  0;\n    dout_stb            <=  0;\n    read_count          <=  0;\n\n    count_error         <=  0;\n    incorrect_data      <=  0;\n    detected_value      <=  0;\n    count_detected      <=  0;\n  end\n  else begin\n    din_stb             <=  0;\n    dout_stb            <=  0;\n    count_error         <=  0;\n    incorrect_data      <=  0;\n\n    if ((din_ready > 0) && (din_activate == 0)) begin\n      write_count       <=  0;\n      din               <=  0;\n      if (din_ready[0]) begin\n        din_activate[0] <=  1;\n      end\n      else begin\n        din_activate[1] <=  1;\n      end\n    end\n    else if (din_activate != 0) begin\n      if (write_count < din_size) begin\n        din_stb         <=  1;\n        din             <=  write_count;\n        write_count     <=  write_count + 1;\n      end\n      else begin\n        din_activate    <=  0;\n      end\n    end\n\n    if (dout_ready && !dout_activate) begin\n      read_count        <=  0;\n      dout_activate     <=  1;\n      if (dout_size != 24'h0800) begin\n        count_error     <=  1;\n        count_detected  <=  dout_size;\n      end\n    end\n    else if (dout_activate) begin\n      if (read_count < dout_size) begin\n        dout_stb        <=  1;\n        read_count      <=  read_count + 1;\n      end\n      else begin\n        dout_activate   <=  0;\n      end\n\n      if (read_count > 0) begin\n        if (dout !=  read_count - 1) begin\n          incorrect_data  <=  1;\n          count_detected  <=  read_count[23:0];\n          detected_value  <=  dout;\n        end\n      end\n      else begin\n        if (dout != 0) begin\n          incorrect_data  <=  1;\n          count_detected  <=  read_count[23:0];\n          detected_value  <=  dout;\n        end\n      end\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "data_test2",
        "module_hash": "65ec7850330aad06dd74dbbce376f3c6",
        "dataset_index": 24413
      },
      "DBLC_3_64_8fcf25f2": {
        "rtl_code": "\nmodule DBLC_3_64 ( PIN, GIN, PHI, POUT, GOUT );\ninput  [0:62] PIN;\ninput  [0:64] GIN;\ninput  PHI;\noutput [0:60] POUT;\noutput [0:64] GOUT;\n\nwire [62:0] PIN_temp;\nwire [64:0] GIN_temp;\nwire [60:0] POUT_temp;\n\nassign PIN_temp = {1'b0, PIN};\nassign GIN_temp = {1'b0, GIN};\n\nassign GOUT = GIN_temp;\nassign POUT_temp = PHI ? GIN_temp[62:2] : PIN_temp[62:2];\nassign POUT = POUT_temp[60:0];\n\nendmodule",
        "module_name": "DBLC_3_64",
        "module_hash": "8fcf25f2d54df79bdae92b21054b8707",
        "dataset_index": 20646
      },
      "flt2int_05f99755": {
        "rtl_code": "\n\nmodule flt2int\n  (\n   input \t     clk,\n   input [31:0]      afl,\n   output reg [15:0] fx_int\n   );\n\n  reg [14:0] \t     int_out;\n\n  always @* begin\n    if(afl[30:23] == 8'h7f) int_out = 16'h1;\t\telse begin\n      casex(afl[30:23])\n\t8'b0xxx_xxxx: int_out = 15'h0;\t\t\t8'b1000_0000: int_out = {14'h1, afl[22]};\t8'b1000_0001: int_out = {13'h1, afl[22:21]};\t8'b1000_0010: int_out = {12'h1, afl[22:20]};\t8'b1000_0011: int_out = {11'h1, afl[22:19]};\t8'b1000_0100: int_out = {10'h1, afl[22:18]};\t8'b1000_0101: int_out =  {9'h1, afl[22:17]};\t8'b1000_0110: int_out =  {8'h1, afl[22:16]};\t8'b1000_0111: int_out =  {7'h1, afl[22:15]};\t8'b1000_1000: int_out =  {6'h1, afl[22:14]};\t8'b1000_1001: int_out =  {5'h1, afl[22:13]};\t8'b1000_1010: int_out =  {4'h1, afl[22:12]};\t8'b1000_1011: int_out =  {3'h1, afl[22:11]};\t8'b1000_1100: int_out =  {2'h1, afl[22:10]};\t8'b1000_1101: int_out =  {1'h1, afl[22: 9]};\tdefault:      int_out = 15'h7fff;\t\tendcase\n    end\n  end\n  \n  \n  always @(posedge clk) begin\n    if(afl[31]) fx_int <= ~int_out + 16'h1;\n    else        fx_int <=  {1'b0, int_out};\n  end\n  \nendmodule\n",
        "module_name": "flt2int",
        "module_hash": "05f99755baa0b263fefc7b909d8ec80f",
        "dataset_index": 14325
      },
      "binary_to_gray_2bbb226b": {
        "rtl_code": "module binary_to_gray (\n    input [7:0] binary,\n    output [7:0] gray\n);\n\nassign gray = binary ^ {1'b0, binary[7:1]};\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "2bbb226b33502201bc9a9ed97d5c2e78",
        "dataset_index": 8737
      },
      "pipeline_aeaf94e1": {
        "rtl_code": "module pipeline (\n    input clk,\n    input clk_ena,\n    input in_stream,\n    input reset,\n    output reg pipeline_reg_0,\n    output reg pipeline_reg_1,\n    output reg pipeline_reg_2,\n    output reg pipeline_reg_3,\n    output reg pipeline_reg_4,\n    output reg pipeline_reg_5,\n    output reg pipeline_reg_6,\n    output reg pipeline_reg_7,\n    output reg pipeline_reg_8,\n    output reg pipeline_reg_9,\n    output reg pipeline_reg_10,\n    output reg pipeline_reg_11,\n    output reg pipeline_reg_12,\n    output reg pipeline_reg_13,\n    output reg pipeline_reg_14,\n    output reg pipeline_reg_15,\n    output reg pipeline_reg_16\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        pipeline_reg_0 <= 1'b0;\n        pipeline_reg_1 <= 1'b0;\n        pipeline_reg_2 <= 1'b0;\n        pipeline_reg_3 <= 1'b0;\n        pipeline_reg_4 <= 1'b0;\n        pipeline_reg_5 <= 1'b0;\n        pipeline_reg_6 <= 1'b0;\n        pipeline_reg_7 <= 1'b0;\n        pipeline_reg_8 <= 1'b0;\n        pipeline_reg_9 <= 1'b0;\n        pipeline_reg_10 <= 1'b0;\n        pipeline_reg_11 <= 1'b0;\n        pipeline_reg_12 <= 1'b0;\n        pipeline_reg_13 <= 1'b0;\n        pipeline_reg_14 <= 1'b0;\n        pipeline_reg_15 <= 1'b0;\n        pipeline_reg_16 <= 1'b0;\n    end else begin\n        if (clk_ena) begin\n            pipeline_reg_0 <= in_stream;\n            pipeline_reg_1 <= pipeline_reg_0;\n            pipeline_reg_2 <= pipeline_reg_1;\n            pipeline_reg_3 <= pipeline_reg_2;\n            pipeline_reg_4 <= pipeline_reg_3;\n            pipeline_reg_5 <= pipeline_reg_4;\n            pipeline_reg_6 <= pipeline_reg_5;\n            pipeline_reg_7 <= pipeline_reg_6;\n            pipeline_reg_8 <= pipeline_reg_7;\n            pipeline_reg_9 <= pipeline_reg_8;\n            pipeline_reg_10 <= pipeline_reg_9;\n            pipeline_reg_11 <= pipeline_reg_10;\n            pipeline_reg_12 <= pipeline_reg_11;\n            pipeline_reg_13 <= pipeline_reg_12;\n            pipeline_reg_14 <= pipeline_reg_13;\n            pipeline_reg_15 <= pipeline_reg_14;\n            pipeline_reg_16 <= pipeline_reg_15;\n        end\n    end\nend\n\nendmodule",
        "module_name": "pipeline",
        "module_hash": "aeaf94e1611f8bea619d0c5c6185c2aa",
        "dataset_index": 5680
      },
      "axi_protocol_converter_v2_1_8_axilite_conv #_2f67b555": {
        "rtl_code": "\n\n \nmodule axi_protocol_converter_v2_1_8_axilite_conv #\n  (\n   parameter         C_FAMILY                    = \"virtex6\",\n   parameter integer C_AXI_ID_WIDTH              = 1,\n   parameter integer C_AXI_ADDR_WIDTH            = 32,\n   parameter integer C_AXI_DATA_WIDTH            = 32,\n   parameter integer C_AXI_SUPPORTS_WRITE        = 1,\n   parameter integer C_AXI_SUPPORTS_READ         = 1,\n   parameter integer C_AXI_RUSER_WIDTH                = 1,\n   parameter integer C_AXI_BUSER_WIDTH                = 1\n   )\n  (\n   input  wire                          ACLK,\n   input  wire                          ARESETN,\n   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,\n   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,\n   input  wire [3-1:0]                  S_AXI_AWPROT,\n   input  wire                          S_AXI_AWVALID,\n   output wire                          S_AXI_AWREADY,\n   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,\n   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,\n   input  wire                          S_AXI_WVALID,\n   output wire                          S_AXI_WREADY,\n   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_BID,\n   output wire [2-1:0]                  S_AXI_BRESP,\n   output wire [C_AXI_BUSER_WIDTH-1:0]  S_AXI_BUSER,    output wire                          S_AXI_BVALID,\n   input  wire                          S_AXI_BREADY,\n   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,\n   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,\n   input  wire [3-1:0]                  S_AXI_ARPROT,\n   input  wire                          S_AXI_ARVALID,\n   output wire                          S_AXI_ARREADY,\n   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_RID,\n   output wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA,\n   output wire [2-1:0]                  S_AXI_RRESP,\n   output wire                          S_AXI_RLAST,    output wire [C_AXI_RUSER_WIDTH-1:0]  S_AXI_RUSER,    output wire                          S_AXI_RVALID,\n   input  wire                          S_AXI_RREADY,\n   \n   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AWADDR,\n   output wire [3-1:0]                  M_AXI_AWPROT,\n   output wire                          M_AXI_AWVALID,\n   input  wire                          M_AXI_AWREADY,\n   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,\n   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,\n   output wire                          M_AXI_WVALID,\n   input  wire                          M_AXI_WREADY,\n   input  wire [2-1:0]                  M_AXI_BRESP,\n   input  wire                          M_AXI_BVALID,\n   output wire                          M_AXI_BREADY,\n   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_ARADDR,\n   output wire [3-1:0]                  M_AXI_ARPROT,\n   output wire                          M_AXI_ARVALID,\n   input  wire                          M_AXI_ARREADY,\n   input  wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_RDATA,\n   input  wire [2-1:0]                  M_AXI_RRESP,\n   input  wire                          M_AXI_RVALID,\n   output wire                          M_AXI_RREADY\n  );\n\n  wire s_awvalid_i;\n  wire s_arvalid_i;\n  wire [C_AXI_ADDR_WIDTH-1:0] m_axaddr;\n\n  reg read_active;\n  reg write_active;\n  reg busy;\n\n  wire read_req;\n  wire write_req;\n  wire read_complete;\n  wire write_complete;\n  \n  reg [1:0] areset_d; always @(posedge ACLK) begin\n    areset_d <= {areset_d[0], ~ARESETN};\n  end\n  \n  assign s_awvalid_i = S_AXI_AWVALID & (C_AXI_SUPPORTS_WRITE != 0);\n  assign s_arvalid_i = S_AXI_ARVALID & (C_AXI_SUPPORTS_READ != 0);\n\n  assign read_req  = s_arvalid_i & ~busy & ~|areset_d & ~write_active;\n  assign write_req = s_awvalid_i & ~busy & ~|areset_d & ((~read_active & ~s_arvalid_i) | write_active);\n\n  assign read_complete  = M_AXI_RVALID & S_AXI_RREADY;\n  assign write_complete = M_AXI_BVALID & S_AXI_BREADY;\n\n  always @(posedge ACLK) begin : arbiter_read_ff\n    if (|areset_d)\n      read_active <= 1'b0;\n    else if (read_complete)\n      read_active <= 1'b0;\n    else if (read_req)\n      read_active <= 1'b1;\n  end\n\n  always @(posedge ACLK) begin : arbiter_write_ff\n    if (|areset_d)\n      write_active <= 1'b0;\n    else if (write_complete)\n      write_active <= 1'b0;\n    else if (write_req)\n      write_active <= 1'b1;\n  end\n\n  always @(posedge ACLK) begin : arbiter_busy_ff\n    if (|areset_d)\n      busy <= 1'b0;\n    else if (read_complete | write_complete)\n      busy <= 1'b0;\n    else if ((write_req & M_AXI_AWREADY) | (read_req & M_AXI_ARREADY))\n      busy <= 1'b1;\n  end\n\n  assign M_AXI_ARVALID = read_req;\n  assign S_AXI_ARREADY = M_AXI_ARREADY & read_req;\n\n  assign M_AXI_AWVALID = write_req;\n  assign S_AXI_AWREADY = M_AXI_AWREADY & write_req;\n\n  assign M_AXI_RREADY  = S_AXI_RREADY & read_active;\n  assign S_AXI_RVALID  = M_AXI_RVALID & read_active;\n\n  assign M_AXI_BREADY  = S_AXI_BREADY & write_active;\n  assign S_AXI_BVALID  = M_AXI_BVALID & write_active;\n\n  assign m_axaddr = (read_req | (C_AXI_SUPPORTS_WRITE == 0)) ? S_AXI_ARADDR : S_AXI_AWADDR;\n\n  reg [C_AXI_ID_WIDTH-1:0] s_axid;\n\n  always @(posedge ACLK) begin : axid\n    if      (read_req)  s_axid <= S_AXI_ARID;\n    else if (write_req) s_axid <= S_AXI_AWID;\n  end\n\n  assign S_AXI_BID = s_axid;\n  assign S_AXI_RID = s_axid;\n\n  assign M_AXI_AWADDR = m_axaddr;\n  assign M_AXI_ARADDR = m_axaddr;\n\n\n  assign S_AXI_WREADY   = M_AXI_WREADY & ~|areset_d;\n  assign S_AXI_BRESP    = M_AXI_BRESP;\n  assign S_AXI_RDATA    = M_AXI_RDATA;\n  assign S_AXI_RRESP    = M_AXI_RRESP;\n  assign S_AXI_RLAST    = 1'b1;\n  assign S_AXI_BUSER    = {C_AXI_BUSER_WIDTH{1'b0}};\n  assign S_AXI_RUSER    = {C_AXI_RUSER_WIDTH{1'b0}};\n\n  assign M_AXI_AWPROT   = S_AXI_AWPROT;\n  assign M_AXI_WVALID   = S_AXI_WVALID & ~|areset_d;\n  assign M_AXI_WDATA    = S_AXI_WDATA;\n  assign M_AXI_WSTRB    = S_AXI_WSTRB;\n  assign M_AXI_ARPROT   = S_AXI_ARPROT;\n\nendmodule\n",
        "module_name": "axi_protocol_converter_v2_1_8_axilite_conv #",
        "module_hash": "2f67b555d1d0f7e18bed1d320cc5c088",
        "dataset_index": 24961
      },
      "sky130_fd_sc_hd__dlrtn_4_a5a49712": {
        "rtl_code": "\nmodule sky130_fd_sc_hd__dlrtn_4 (\n    Q,\n    RESET_B,\n    D,\n    GATE_N\n);\n\n    output Q;\n    input RESET_B;\n    input D;\n    input GATE_N;\n\n    reg Q_int = 1'b0;\n    reg D_ff = 1'b0;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // D flip-flop to store input value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            D_ff <= 1'b0;\n        end else begin\n            D_ff <= D;\n        end\n    end\n\n    // Mux to select output value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            Q_int <= 1'b0;\n        end else begin\n            Q_int <= (GATE_N) ? D_ff : Q_int;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule\nmodule sky130_fd_sc_hd__dlrtn (\n    Q,\n    RESET_B,\n    D,\n    GATE_N\n);\n\n    output Q;\n    input RESET_B;\n    input [3:0] D;\n    input GATE_N;\n\n    reg [3:0] Q_int = 4'b0;\n    reg [3:0] D_ff = 4'b0;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // D flip-flop to store input value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            D_ff <= 4'b0;\n        end else begin\n            D_ff <= D;\n        end\n    end\n\n    // Mux to select output value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            Q_int <= 4'b0;\n        end else begin\n            Q_int <= (GATE_N) ? D_ff : Q_int;\n        end\n    end\n\n    assign Q = Q_int[0];\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__dlrtn_4",
        "module_hash": "a5a49712aafbc0bc3f87c24ddb95877d",
        "dataset_index": 686
      },
      "FSM #_281b9c69": {
        "rtl_code": "\nmodule FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2, // number of output signals\n  parameter s = 8 // number of states in the FSM\n)(\n  input [n-1:0] in,\n  input rst,\n  input clk,\n  output [m-1:0] out,\n  output [s-1:0] state\n);\n\nreg [s-1:0] state_reg = STATE_RESET;\nreg [m-1:0] out_reg = 2'b00;\n\n// Define the states\nparameter STATE_RESET = 3'b000;\nparameter STATE_A = 3'b001;\nparameter STATE_B = 3'b010;\nparameter STATE_C = 3'b011;\nparameter STATE_D = 3'b100;\nparameter STATE_E = 3'b101;\nparameter STATE_F = 3'b110;\nparameter STATE_G = 3'b111;\n\n// Define the outputs for each state\nalways @(*) begin\n  case (state_reg)\n    STATE_RESET: out_reg = 2'b00;\n    STATE_A: out_reg = 2'b01;\n    STATE_B: out_reg = 2'b10;\n    STATE_C: out_reg = 2'b11;\n    STATE_D: out_reg = 2'b01;\n    STATE_E: out_reg = 2'b10;\n    STATE_F: out_reg = 2'b11;\n    STATE_G: out_reg = 2'b00;\n    default: out_reg = 2'b00;\n  endcase\nend\n\n// Define the transitions between states\nalways @ (posedge clk or posedge rst) begin\n  if (rst) begin\n    state_reg <= STATE_RESET;\n  end else begin\n    case (state_reg)\n      STATE_RESET: begin\n        if (in == 4'b0000) begin\n          state_reg <= STATE_A;\n        end\n      end\n      STATE_A: begin\n        if (in == 4'b0001) begin\n          state_reg <= STATE_B;\n        end else if (in == 4'b0010) begin\n          state_reg <= STATE_C;\n        end\n      end\n      STATE_B: begin\n        if (in == 4'b0011) begin\n          state_reg <= STATE_D;\n        end else if (in == 4'b0100) begin\n          state_reg <= STATE_E;\n        end\n      end\n      STATE_C: begin\n        if (in == 4'b0101) begin\n          state_reg <= STATE_E;\n        end else if (in == 4'b0110) begin\n          state_reg <= STATE_F;\n        end\n      end\n      STATE_D: begin\n        if (in == 4'b0111) begin\n          state_reg <= STATE_G;\n        end\n      end\n      STATE_E: begin\n        if (in == 4'b1000) begin\n          state_reg <= STATE_G;\n        end\n      end\n      STATE_F: begin\n        if (in == 4'b1001) begin\n          state_reg <= STATE_G;\n        end\n      end\n      STATE_G: begin\n        if (in == 4'b1010) begin\n          state_reg <= STATE_RESET;\n        end\n      end\n    endcase\n  end\nend\n\nassign out = out_reg;\nassign state = state_reg;\n\nendmodule",
        "module_name": "FSM #",
        "module_hash": "281b9c69d502603a4b0cdc5f7453da69",
        "dataset_index": 2587
      },
      "divider_a5d7d8c8": {
        "rtl_code": "\nmodule divider(\nreset,\nout,\nclk\n);\n\noutput out;\ninput clk;\ninput reset;\n\nparameter divisor1 = 5;\nparameter divisor2 = 2;\n\nreg[31:0] cnt1;\nreg result;\nwire EN;\nwire compare1,compare2;\n\n\nalways@(posedge clk or negedge reset)\nbegin\n   if(reset == 0)\n      cnt1 <= 0;\n\telse if(cnt1 == divisor1)\n\t\tcnt1 <= 1;\n\telse\n\t\tcnt1 <= cnt1 + 1;\nend\n\nassign compare1 = (cnt1 == 5) ? 1 : 0;\n\nassign compare2 = (cnt1 == divisor2) ? 1 : 0;\n\nassign EN = compare1 | compare2;\n \nalways@(posedge clk or negedge reset)\nbegin\n\tif(reset == 0)\n\t\tresult <= 0;\n\telse if(EN) \n\tresult <= !result;\n\t\tend\n\nassign out = result;\nendmodule\n\n",
        "module_name": "divider",
        "module_hash": "a5d7d8c82334299feef07c91d72fa2d6",
        "dataset_index": 8050
      },
      "blk_mem_gen #_bc0bf91a": {
        "rtl_code": "module blk_mem_gen #(parameter DATA_WIDTH = 8, ADDR_WIDTH = 8, INIT_FILE = \"\", INIT_HEX = 0, RAM_STYLE = \"block\") (\n    input wire clk,\n    input wire rst,\n    input wire we,\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // Declare internal signals\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    // Initialize memory from file, if specified\n    initial begin\n        if (INIT_FILE != \"\") begin\n            $readmemh(INIT_FILE, mem);\n        end\n    end\n\n    // Read operation\n    always @ (posedge clk) begin\n        if (we) begin\n            mem[addr] <= din;\n        end\n        dout <= mem[addr];\n    end\n\nendmodule",
        "module_name": "blk_mem_gen #",
        "module_hash": "bc0bf91a305f989a7508563644ebfd91",
        "dataset_index": 20660
      },
      "sky130_fd_sc_ls__dlrtn_1_0fadcf1f": {
        "rtl_code": "module sky130_fd_sc_ls__dlrtn_1 (\n    Q      ,\n    RESET_B,\n    D      ,\n    GATE_N ,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE_N ;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    reg Q_int;\n\n    always @(*) begin\n        if(RESET_B == 1'b1) begin\n            Q_int = 1'b0;\n        end\n        else if(GATE_N == 1'b1) begin\n            Q_int = D;\n        end\n        else begin\n            Q_int = 1'b1;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__dlrtn_1",
        "module_hash": "0fadcf1fd54040b533888a078cb09797",
        "dataset_index": 15056
      },
      "LTZ_CDCF #_726487fd": {
        "rtl_code": "module LTZ_CDCF #(\n    parameter                WIDTH   = 1,\n    parameter  [WIDTH -1:0]  INITVAL = {WIDTH{1'b0}}\n) (\n    input                    rst_n ,\n    input                    clk   ,\n    input      [WIDTH -1:0]  din   ,\n    output reg [WIDTH -1:0]  dout\n);\n\n//\nreg  [WIDTH -1:0]  buff ;\nreg         [1:0]  state;\n\n//\nalways @(posedge clk or negedge rst_n)\nif (!rst_n)\n    buff <= INITVAL;\nelse\n    buff <= din;\n\n//\nalways @(posedge clk or negedge rst_n)\nif (!rst_n)\n    dout <= INITVAL;\nelse if (state == 2'd3)\n    dout <= buff;\n\n// filter and judger\nwire  neq = (buff != dout);\nwire   eq = (buff == din );\n\nalways @(posedge clk or negedge rst_n)\nif (!rst_n)\n    state <= 2'b0;\nelse begin\n    case (state)\n        2'd0 : if (neq) state <= 2'd1;\n        2'd1 : if ( eq) state <= 2'd2;\n        2'd2 : if ( eq) state <= 2'd3; else state <= 2'd1;\n        2'd3 : state <= 2'd0;\n    endcase\nend\n\n//\nendmodule",
        "module_name": "LTZ_CDCF #",
        "module_hash": "726487fd1ff7f45b27076ae4bf13bc19",
        "dataset_index": 5462
      }
    },
    "batch_69165069ed808190b064abc2fe41f9bb": {
      "mig_7series_v4_0_axi_mc_wr_cmd_fsm #_e9b1f386": {
        "rtl_code": "\n\n\nmodule mig_7series_v4_0_axi_mc_wr_cmd_fsm #(\nparameter integer C_MC_BURST_LEN              = 1,\n                     parameter integer C_MC_RD_INST              = 0\n  \n)\n(\ninput  wire                                 clk           , \n  input  wire                                 reset         , \n  output reg                                  axready       , \n  input  wire                                 axvalid       , \n  output wire                                 cmd_en        , \n  input  wire                                 cmd_full      , \n  output wire                                 next          , \n  input  wire                                 next_pending  ,\n  input  wire                                 data_rdy    ,\n  output wire                                 b_push        ,\n  input  wire                                 b_full        ,\n  output wire                                 cmd_en_last   \n);\n\nassign cmd_en = (~b_full & axvalid & data_rdy);\n\n    assign next = (~cmd_full & cmd_en);\n\n    assign cmd_en_last = next & ~next_pending;\n\n    assign b_push  = cmd_en_last;\n\n  always @(posedge clk) begin\n    if (reset)\n      axready <= 1'b0;\n    else\n      axready <= ~axvalid | cmd_en_last;\n  end\n\nendmodule\n\n",
        "module_name": "mig_7series_v4_0_axi_mc_wr_cmd_fsm #",
        "module_hash": "e9b1f3860fe56d7c405f6e66dc804ecf",
        "dataset_index": 25333
      },
      "stage4_memory_a815389a": {
        "rtl_code": "module stage4_memory(\n    \n    input clk_i,\n    input rst_i,\n\n    \n    input [31:0] alu_i,\n    input control_load_i,\n    input control_store_i,\n    input control_take_branch_i,\n    input do_wb_i,\n    input [4:0] wb_reg_i,\n    output stall_o,\n\n    \n    output reg do_wb_o,\n    output reg [4:0] wb_reg_o,\n    output reg [31:0] wb_val_o\n);\n\nreg [31:0] alu_r;\nreg control_load;\nreg control_store;\n\nassign stall_o = 0;\n\nalways @(posedge clk_i)\nbegin\n    if (rst_i) begin\n        alu_r <= 0;\n        control_load <= 0;\n        control_store <= 0;\n        do_wb_o <= 0;\n        wb_reg_o <= 0;\n    end else begin\n        alu_r <= alu_i;\n        control_load <= control_load_i;\n        control_store <= control_store_i;\n        do_wb_o <= do_wb_i;\n        wb_reg_o <= wb_reg_i;\n    end\nend\n\nalways @*\nbegin\n    if (control_load) begin\n        wb_val_o = 99; // XXX result of load\n    end else if (control_store) begin\n        wb_val_o = 32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;\n    end else begin\n        wb_val_o = alu_r;\n    end\nend\n\nendmodule",
        "module_name": "stage4_memory",
        "module_hash": "a815389aca22c802c0cfef55c5f9e9fe",
        "dataset_index": 2645
      },
      "my_alu #_32d6d1cf": {
        "rtl_code": "\nmodule my_alu #(\n    parameter N = 8 // Parameter to define the number of bits\n)(\n    input signed [N-1:0] a,\n    input signed [N-1:0] b,\n    input [3:0] op,\n    output signed [N-1:0] result,\n    output carry\n);\n\n\nreg signed [N-1:0] result_reg;\nreg carry_reg;\n\nalways @* begin\n    case(op)\n        4'b0000: begin // a + b\n            result_reg = a + b;\n            carry_reg = (result_reg[N-1] == a[N-1] && result_reg[N-1] == b[N-1]) ? 1 : 0;\n        end\n        4'b0001: begin // a - b\n            result_reg = a - b;\n            carry_reg = (result_reg[N-1] == a[N-1] && result_reg[N-1] != b[N-1]) ? 1 : 0;\n        end\n        4'b0010: begin // a & b\n            result_reg = a & b;\n            carry_reg = 0;\n        end\n        4'b0011: begin // a | b\n            result_reg = a | b;\n            carry_reg = 0;\n        end\n        4'b0100: begin // a ^ b\n            result_reg = a ^ b;\n            carry_reg = 0;\n        end\n        4'b0101: begin // ~a\n            result_reg = ~a;\n            carry_reg = 0;\n        end\n        4'b0110: begin // ~b\n            result_reg = ~b;\n            carry_reg = 0;\n        end\n        4'b0111: begin // 0\n            result_reg = 0;\n            carry_reg = 0;\n        end\n        4'b1000: begin // a << b\n            result_reg = a << b;\n            carry_reg = (result_reg[N-1] == 1) ? 1 : 0;\n        end\n        4'b1001: begin // a >> b\n            result_reg = a >> b;\n            carry_reg = (result_reg[0] == 1) ? 1 : 0;\n        end\n        4'b1010: begin // a >>> b\n            result_reg = $signed({a[N-1], a}) >>> b;\n            carry_reg = (result_reg[0] == 1) ? 1 : 0;\n        end\n        4'b1011: begin // a == b\n            result_reg = (a == b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1100: begin // a != b\n            result_reg = (a != b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1101: begin // a > b\n            result_reg = (a > b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1110: begin // a >= b\n            result_reg = (a >= b) ? 1 : 0;\n            carry_reg = 0;\n        end\n        4'b1111: begin // a < b\n            result_reg = (a < b) ? 1 : 0;\n            carry_reg = 0;\n        end\n    endcase\nend\n\nassign result = result_reg;\nassign carry = carry_reg;\n\nendmodule\n",
        "module_name": "my_alu #",
        "module_hash": "32d6d1cfc957a741e0250c08f42a0104",
        "dataset_index": 17258
      },
      "altera_up_rs232_counters_c5b27de0": {
        "rtl_code": "\n\n\n\nmodule altera_up_rs232_counters (\n\tclk,\n\treset,\n\t\n\treset_counters,\n\n\tbaud_clock_rising_edge,\n\tbaud_clock_falling_edge,\n\tall_bits_transmitted\n);\n\n\n\nparameter CW\t\t\t\t\t\t\t= 9;\t\tparameter BAUD_TICK_COUNT\t\t\t= 433;\nparameter HALF_BAUD_TICK_COUNT\t= 216;\n\nparameter TDW\t\t\t\t\t\t\t= 11;\t\t\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t\t\t\treset_counters;\n\noutput reg\t\t\t\tbaud_clock_rising_edge;\noutput reg\t\t\t\tbaud_clock_falling_edge;\noutput reg\t\t\t\tall_bits_transmitted;\n\n\n\n\n\nreg\t\t[(CW-1):0]\tbaud_counter;\nreg\t\t\t[ 3: 0]\tbit_counter;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tbaud_counter <= {CW{1'b0}};\n\telse if (reset_counters)\n\t\tbaud_counter <= {CW{1'b0}};\n\telse if (baud_counter == BAUD_TICK_COUNT)\n\t\tbaud_counter <= {CW{1'b0}};\n\telse\n\t\tbaud_counter <= baud_counter + 1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tbaud_clock_rising_edge <= 1'b0;\n\telse if (baud_counter == BAUD_TICK_COUNT)\n\t\tbaud_clock_rising_edge <= 1'b1;\n\telse\n\t\tbaud_clock_rising_edge <= 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tbaud_clock_falling_edge <= 1'b0;\n\telse if (baud_counter == HALF_BAUD_TICK_COUNT)\n\t\tbaud_clock_falling_edge <= 1'b1;\n\telse\n\t\tbaud_clock_falling_edge <= 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tbit_counter <= 4'h0;\n\telse if (reset_counters)\n\t\tbit_counter <= 4'h0;\n\telse if (bit_counter == TDW)\n\t\tbit_counter <= 4'h0;\n\telse if (baud_counter == BAUD_TICK_COUNT)\n\t\tbit_counter <= bit_counter + 4'h1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tall_bits_transmitted <= 1'b0;\n\telse if (bit_counter == TDW)\n\t\tall_bits_transmitted <= 1'b1;\n\telse\n\t\tall_bits_transmitted <= 1'b0;\nend\n\n\n\n\n\n\n\nendmodule\n\n",
        "module_name": "altera_up_rs232_counters",
        "module_hash": "c5b27de00ca28678d2b59b1bfb1c8095",
        "dataset_index": 23806
      },
      "shift_register #_0aa03bdf": {
        "rtl_code": "module shift_register #(\n  parameter n = 4, // number of input signals\n  parameter m = 4 // number of output signals\n)(\n  input [n-1:0] data_in,\n  input clk,\n  input reset,\n  input shift,\n  output [m-1:0] data_out\n);\n\nparameter width = 8; // width of shift register in bits\n\nreg [width-1:0] shift_reg;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    shift_reg <= 0;\n  end else if (shift) begin\n    if (shift == 1'b1) begin // shift right\n      shift_reg <= {1'b0, shift_reg[width-1:1]};\n    end else begin // shift left\n      shift_reg <= {shift_reg[width-2:0], 1'b0};\n    end\n  end else begin\n    shift_reg <= data_in;\n  end\nend\n\nassign data_out = shift_reg;\n\nendmodule",
        "module_name": "shift_register #",
        "module_hash": "0aa03bdf0eb835fdda62bd59d3757ed1",
        "dataset_index": 3464
      },
      "processor_system_reset_55be19b1": {
        "rtl_code": "module processor_system_reset(\n  input slowest_sync_clk,\n  input ext_reset_in,\n  input aux_reset_in,\n  input mb_debug_sys_rst,\n  input dcm_locked,\n  output reg mb_reset,\n  output reg [0:0]bus_struct_reset,\n  output reg [0:0]peripheral_reset,\n  output reg [0:0]interconnect_aresetn,\n  output reg [0:0]peripheral_aresetn\n);\n\n  always @(posedge slowest_sync_clk) begin\n    if(ext_reset_in || aux_reset_in || mb_debug_sys_rst || !dcm_locked) begin\n      mb_reset <= 1'b1;\n      bus_struct_reset <= 1'b1;\n      peripheral_reset <= 1'b1;\n      interconnect_aresetn <= 1'b1;\n      peripheral_aresetn <= 1'b1;\n    end else begin\n      mb_reset <= 1'b0;\n      bus_struct_reset <= 1'b0;\n      peripheral_reset <= 1'b0;\n      interconnect_aresetn <= 1'b0;\n      peripheral_aresetn <= 1'b0;\n    end\n  end\nendmodule",
        "module_name": "processor_system_reset",
        "module_hash": "55be19b166d9db1ec22fce9f901e4e83",
        "dataset_index": 9845
      },
      "comparator_2bit_3245b0f8": {
        "rtl_code": "module comparator_2bit (\n    input [1:0] A,\n    input [1:0] B,\n    output reg [1:0] EQ,\n    output reg [1:0] GT\n);\n\n    // EQ calculation\n    always @* begin\n        EQ[1] = ~(A[1] ^ B[1]);\n        EQ[0] = ~(A[0] ^ B[0]);\n    end\n\n    // GT calculation\n    always @* begin\n        if (A[1] > B[1])\n            GT[1] = 1;\n        else\n            GT[1] = 0;\n\n        if (A[0] > B[0])\n            GT[0] = 1;\n        else\n            GT[0] = 0;\n    end\n\nendmodule",
        "module_name": "comparator_2bit",
        "module_hash": "3245b0f839cc4fb1cf827c70d4f55d1a",
        "dataset_index": 8178
      },
      "and_or_gate_fd4f360e": {
        "rtl_code": "\nmodule and_or_gate(\n    input a,\n    input b,\n    output wire out\n);\n\n    wire intermediate1;\n    wire intermediate2;\n\n    and gate1(intermediate1, a, b);\n    and gate2(intermediate2, a, b);\n    or gate3(out, intermediate1, intermediate2);\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input a,\n    input b,\n    output reg out_always_ff\n);\n\n    wire and_or_out;\n\n    and_or_gate and_or_inst(a, b, and_or_out);\n\n    always @(posedge clk) begin\n        out_always_ff <= and_or_out;\n    end\n\nendmodule\n",
        "module_name": "and_or_gate",
        "module_hash": "fd4f360e07c7e993a4e46a3b2134708e",
        "dataset_index": 5366
      },
      "top__4306b776": {
        "rtl_code": "module top_module (\n    input clk,\n    input rst_n,\n    input a,\n    input [4:0] in,\n    output out_and,\n    output out_or,\n    output out_nor,\n    output reg final_output\n);\n\n    // Edge detection module\n    reg a_prev;\n    reg edge_detected;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            a_prev <= 1'b0;\n            edge_detected <= 1'b0;\n        end else begin\n            a_prev <= a;\n            edge_detected <= (a && ~a_prev) || (~a && a_prev);\n        end\n    end\n\n    // Combinational circuit module\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_nor = ~|in;\n\n    // Additional functional module\n    reg [1:0] decoder_out;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            final_output <= 1'b0;\n        end else begin\n            if (edge_detected && (decoder_out == 2'd2 || decoder_out == 2'd3)) begin\n                final_output <= 1'b1;\n            end else begin\n                final_output <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule decoder_2to4_with_enable (\n    input in,\n    input en,\n    output reg [1:0] out\n);\n\n    always @(*) begin\n        case ({in, en})\n            2'b00: out <= 2'b00;\n            2'b01: out <= 2'b01;\n            2'b10: out <= 2'b10;\n            2'b11: out <= 2'b11;\n            default: out <= 2'b00;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "4306b776175ad81d040f18116a2948ac",
        "dataset_index": 7078
      },
      "top_module_5f6c33c0": {
        "rtl_code": "module top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    wire [3:0] and_out;\n    wire [3:0] or_out;\n    wire [3:0] xor_out;\n\n    and_module and_inst(\n        .in1(in),\n        .in2(in),\n        .out(and_out)\n    );\n\n    or_module or_inst(\n        .in1(in),\n        .in2(in),\n        .out(or_out)\n    );\n\n    xor_module xor_inst(\n        .in1(in),\n        .in2(in),\n        .out(xor_out)\n    );\n\n    assign out_and = and_out[0] & and_out[1] & and_out[2] & and_out[3];\n    assign out_or = or_out[0] | or_out[1] | or_out[2] | or_out[3];\n    assign out_xor = xor_out[0] ^ xor_out[1] ^ xor_out[2] ^ xor_out[3];\n\nendmodule\n\nmodule and_module(\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out\n);\n\n    assign out = in1 & in2;\n\nendmodule\n\nmodule or_module(\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out\n);\n\n    assign out = in1 | in2;\n\nendmodule\n\nmodule xor_module(\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out\n);\n\n    assign out = in1 ^ in2;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "5f6c33c014f7066016bbca0f9635e904",
        "dataset_index": 18073
      },
      "system_auto_cc_0_rd_status_flags_as_19_49923b32": {
        "rtl_code": "module system_auto_cc_0_rd_status_flags_as_19\n  (\n   output reg out,\n   input [1:0] count_d1_reg,\n   input m_aclk,\n   input rd_rst_reg_reg\n   );\n\n  reg ram_empty_fb_i;\n  reg ram_empty_i;\n\n  always @ (posedge m_aclk)\n    begin\n      if (rd_rst_reg_reg)\n        ram_empty_fb_i <= 1'b1;\n      else\n        ram_empty_fb_i <= count_d1_reg[1];\n    end\n\n  always @ (posedge m_aclk)\n    begin\n      if (rd_rst_reg_reg)\n        ram_empty_i <= 1'b1;\n      else\n        ram_empty_i <= count_d1_reg[1];\n    end\n\n  always @ (posedge m_aclk)\n    begin\n      if (rd_rst_reg_reg)\n        out <= 1'b1;\n      else\n        out <= count_d1_reg[1];\n    end\n\nendmodule",
        "module_name": "system_auto_cc_0_rd_status_flags_as_19",
        "module_hash": "49923b326145f2e67daa97dae2d50639",
        "dataset_index": 9614
      },
      "bmod_7b8976a6": {
        "rtl_code": "\nmodule bmod\n  (input  clk,\n   input [31:0] n,\n   output [31:0] result);\n\n   cmod csub (.clk(clk), .n(n), .result(result));\n\nendmodule\n\nmodule cmod\n  (input  clk,\n   input [31:0] n,\n   output [31:0] result);\n\n  // Perform some operation on n to get result\n  assign result = n + 1;\n\nendmodule\n",
        "module_name": "bmod",
        "module_hash": "7b8976a6da7ec87dc7eafe37e8f44d09",
        "dataset_index": 15350
      },
      "MAIN_43c48ba7": {
        "rtl_code": "\nmodule MAIN(ALU_OP, AB_SW, F_LED_SW, LED\n    );\n\tinput wire [2:0] ALU_OP;\n\tinput wire [2:0] AB_SW;\n\tinput [2:0] F_LED_SW;\n\toutput reg [7:0] LED;\n\t\n\twire [31:0] F;\n\twire ZF, OF;\n\t\n\treg[31:0] A,B;\n\talways@(*)\n\tbegin\n\t\tcase(AB_SW)\n\t\t\t3'b000:begin A=32'h0000_0000; B=32'h0000_0000; end\n\t\t\t3'b001:begin A=32'h0000_0003; B=32'h0000_0607; end\n\t\t\t3'b010:begin A=32'h8000_0000; B=32'h8000_0000; end\n\t\t\t3'b011:begin A=32'h7FFF_FFFF; B=32'h7FFF_FFFF; end\n\t\t\t3'b100:begin A=32'hFFFF_FFFF; B=32'hFFFF_FFFF; end\n\t\t\t3'b101:begin A=32'h8000_0000; B=32'hFFFF_FFFF; end\n\t\t\t3'b110:begin A=32'hFFFF_FFFF; B=32'h8000_0000; end\n\t\t\t3'b111:begin A=32'h1234_5678; B=32'h3333_2222; end\n\t\t\tdefault: \n\t\t\t\tbegin A = 32'h9ABC_DEF0; B = 32'h1111_2222; end\n\t\tendcase\n\tend\n\t\n\tALU ALU (\n    .A(A), \n    .B(B), \n    .ZF(ZF), \n    .OF(OF), \n    .F(F), \n    .ALU_OP(ALU_OP)\n    );\n\t \n\t always@(*)\n\t begin\n\t\tcase(F_LED_SW)\n\t\t\t3'b000: begin LED = F[7:0]; end\n\t\t\t3'b001: begin LED = F[15:8]; end\n\t\t\t3'b010: begin LED = F[23:16]; end\n\t\t\t3'b011: begin LED = F[31:24]; end\n\t\t\tdefault:begin LED[7] = ZF; LED[0] = OF; LED[6:1] = 6'b0; end\n\t\tendcase\n\t end\n\t \nendmodule\n\n\nmodule ALU(A, B, ZF, OF, F, ALU_OP);\n\tinput [2:0] ALU_OP;\n\tinput [31:0] A, B;\n\toutput reg [31:0] F;\n\toutput reg ZF, OF;\n\treg C32;\n\talways @(*)\n\tbegin\n\t\tcase(ALU_OP)\n\t\t\t3'd0:begin F = A&B;\n\t\t\t\tOF = 0;\n\t\t\tend\n\t\t\t3'd1:begin F = A|B;\n\t\t\t\tOF = 0;\n\t\t\tend\n\t\t\t3'd2:begin F = A^B;\n\t\t\t\tOF = 0;\n\t\t\tend\n\t\t\t3'd3:begin F = ~(A|B);\n\t\t\t\tOF = 0;\n\t\t\tend\n\t\t\t3'd4:begin {C32, F} = A + B;\n\t\t\t\tOF = A[31]^B[31]^F[31]^C32;\n\t\t\tend\n\t\t\t3'd5:begin {C32, F} = A - B;\n\t\t\t\tOF = A[31]^B[31]^F[31]^C32;\n\t\t\tend\n\t\t\t3'd6:begin if (A<B)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tF = 32'd1;\n\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tbegin\n\t\t\t\t\t\tF = 32'd0;\n\t\t\t\t\tend\n\t\t\t\tOF = 0;\n\t\t\tend\n\t\t\t3'd7:begin F=B<<A;\n\t\t\t  OF=0;\n\t\t\tend\n\t\t\tdefault:begin\n\t\t\t  F=A;\n\t\t\t  OF = 0;\n\t\t\tend\n\t\t\t\n\t\tendcase\n\t\tif (F == 32'd0)\n\t\t\tbegin\n\t\t\t\tZF = 1;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tZF = 0;\n\t\t\tend\n\tend\n\t\nendmodule\n",
        "module_name": "MAIN",
        "module_hash": "43c48ba7a22d59092666564648bbc8ad",
        "dataset_index": 11213
      },
      "decoder_74138_dataflow_5319dab4": {
        "rtl_code": "\nmodule decoder_74138_dataflow(\n    input [2:0] x,\n    input g1,g2a_n,g2b_n,\n    output [7:0] y\n    );\n    assign y[0] = g2a_n|g2b_n|(~g1)|x[0]|x[1]|x[2];\n    assign y[1] = g2a_n|g2b_n|(~g1)|x[0]|x[1]|(~x[2]);\n    assign y[2] = g2a_n|g2b_n|(~g1)|x[0]|(~x[1])|x[2];\n    assign y[3] = g2a_n|g2b_n|(~g1)|x[0]|(~x[1])|(~x[2]);\n    assign  y[4] = g2a_n|g2b_n|(~g1)|(~x[0])|x[1]|x[2];\n    assign y[5] = g2a_n|g2b_n|(~g1)|(~x[0])|x[1]|(~x[2]);\n    assign y[6] = g2a_n|g2b_n|(~g1)|(~x[0])|(~x[1])|x[2];\n    assign y[7] = g2a_n|g2b_n|(~g1)|(~x[0])|(~x[1])|(~x[2]);\n   \n    \nendmodule\n",
        "module_name": "decoder_74138_dataflow",
        "module_hash": "5319dab4ccc55dae96cee72a3357a23b",
        "dataset_index": 23764
      },
      "lcd_driver_9af3e03f": {
        "rtl_code": "module lcd_driver (\n  input clk,\n  input rst,\n  input [7:0] data,\n  input rs,\n  input rw,\n  input en,\n  output busy\n);\n\n  // Define constants for LCD commands\n  parameter LCD_CLEAR_DISPLAY = 8'h01;\n  parameter LCD_RETURN_HOME = 8'h02;\n  parameter LCD_ENTRY_MODE_SET = 8'h04;\n  parameter LCD_DISPLAY_CONTROL = 8'h08;\n  parameter LCD_CURSOR_SHIFT = 8'h10;\n  parameter LCD_FUNCTION_SET = 8'h20;\n  parameter LCD_SET_CGRAM_ADDR = 8'h40;\n  parameter LCD_SET_DDRAM_ADDR = 8'h80;\n\n  // Define constants for LCD initialization\n  parameter LCD_FUNCTION_SET_8BIT = 8'h30;\n  parameter LCD_FUNCTION_SET_4BIT = 8'h20;\n  parameter LCD_DISPLAY_CONTROL_ON = 8'h0C;\n  parameter LCD_ENTRY_MODE_SET_INC = 8'h06;\n\n  // Define internal signals\n  reg [3:0] lcd_state = 0;\n  reg busy = 0;\n  reg [7:0] lcd_data = 0;\n  reg [7:0] lcd_instruction = 0;\n  reg [3:0] lcd_row = 0;\n  reg [3:0] lcd_col = 0;\n\n  // Define state machine\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      lcd_state <= 0;\n      busy <= 0;\n      lcd_data <= 0;\n      lcd_instruction <= 0;\n      lcd_row <= 0;\n      lcd_col <= 0;\n    end else begin\n      case (lcd_state)\n        0: begin // Initialization\n          lcd_instruction <= LCD_FUNCTION_SET_8BIT;\n          lcd_state <= 1;\n          busy <= 1;\n        end\n        1: begin\n          lcd_instruction <= LCD_FUNCTION_SET_8BIT;\n          lcd_state <= 2;\n        end\n        2: begin\n          lcd_instruction <= LCD_FUNCTION_SET_8BIT;\n          lcd_state <= 3;\n        end\n        3: begin\n          lcd_instruction <= LCD_FUNCTION_SET_4BIT;\n          lcd_state <= 4;\n        end\n        4: begin\n          lcd_instruction <= LCD_DISPLAY_CONTROL_ON;\n          lcd_state <= 5;\n        end\n        5: begin\n          lcd_instruction <= LCD_ENTRY_MODE_SET_INC;\n          lcd_state <= 6;\n        end\n        6: begin\n          lcd_instruction <= LCD_CLEAR_DISPLAY;\n          lcd_state <= 7;\n        end\n        7: begin\n          lcd_instruction <= LCD_RETURN_HOME;\n          lcd_state <= 8;\n        end\n        8: begin\n          busy <= 0;\n          lcd_state <= 9;\n        end\n        9: begin // Write data or instruction\n          if (en && !busy) begin\n            if (rs) begin // Data\n              lcd_instruction <= LCD_SET_DDRAM_ADDR | ((lcd_row << 6) + lcd_col);\n              lcd_data <= data;\n            end else begin // Instruction\n              lcd_instruction <= data;\n            end\n            busy <= 1;\n            lcd_state <= 10;\n          end\n        end\n        10: begin // Send data or instruction\n          if (en) begin\n            lcd_instruction <= lcd_instruction | 4'b0001;\n            lcd_state <= 11;\n          end\n        end\n        11: begin // Wait for busy signal to clear\n          if (!en) begin\n            busy <= 1;\n            lcd_state <= 12;\n          end\n        end\n        12: begin // Send data or instruction\n          if (en) begin\n            lcd_instruction <= lcd_instruction & 4'b1110;\n            if (rs) begin // Data\n              lcd_data <= 0;\n            end\n            busy <= 0;\n            lcd_state <= 9;\n            if (lcd_col == 15) begin\n              if (lcd_row == 0) begin\n                lcd_row <= 1;\n              end else begin\n                lcd_row <= 0;\n              end\n              lcd_col <= 0;\n            end else begin\n              lcd_col <= lcd_col + 1;\n            end\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "lcd_driver",
        "module_hash": "9af3e03fde8b13a237ea4f933d90cf8a",
        "dataset_index": 4421
      },
      "up_down_counter_a76c6951": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input rst,\n    input up_down,\n    output reg [2:0] count\n);\n\nreg [2:0] count_reg1;\nreg [2:0] count_reg2;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count_reg1 <= 3'b0;\n        count_reg2 <= 3'b0;\n    end\n    else begin\n        count_reg1 <= count;\n        count_reg2 <= count_reg1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 3'b0;\n    end\n    else begin\n        if (up_down) begin\n            count <= count_reg2 + 3'b1;\n        end\n        else begin\n            count <= count_reg2 - 3'b1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "a76c6951688fbbde8e87bd991e995317",
        "dataset_index": 20308
      },
      "adder_subtractor_0862759b": {
        "rtl_code": "\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input Sel,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] temp_sum;\n    wire temp_carry;\n\n    assign {temp_carry, temp_sum} = Sel ? A - B : A + B + Cin;\n\n    assign S = temp_sum[3:0];\n    assign Cout = Sel ? (A[3] ^ B[3] ^ Cin) : temp_carry;\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "0862759b4105788372416a9a08268caa",
        "dataset_index": 14092
      },
      "FourToSeven_4e3317bd": {
        "rtl_code": "\n\nmodule FourToSeven (\n    ByteIn,\n    Enable,\n    Polarity,\n    SegOut\n);\n\n\ninput [3:0] ByteIn;\ninput Enable;\ninput Polarity;\noutput [6:0] SegOut;\nreg [6:0] SegOut;\n\n\n\n\n\n\nalways @(Polarity, ByteIn, Enable) begin: FOURTOSEVEN_COMB\n    reg [7-1:0] SegBuf;\n    SegBuf = 7'h0;\n    if ((Enable == 1)) begin\n        case (ByteIn)\n            0: SegBuf = 63;\n            1: SegBuf = 6;\n            2: SegBuf = 91;\n            3: SegBuf = 79;\n            4: SegBuf = 102;\n            5: SegBuf = 109;\n            6: SegBuf = 125;\n            7: SegBuf = 7;\n            8: SegBuf = 127;\n            9: SegBuf = 111;\n            10: SegBuf = 119;\n            11: SegBuf = 124;\n            12: SegBuf = 57;\n            13: SegBuf = 94;\n            14: SegBuf = 121;\n            default: SegBuf = 113;\n        endcase\n    end\n    if ((Polarity == 0)) begin\n        SegBuf = (~SegBuf);\n    end\n    SegOut = SegBuf;\nend\n\nendmodule\n",
        "module_name": "FourToSeven",
        "module_hash": "4e3317bd715f5b0aa8b64e0908eadab7",
        "dataset_index": 21575
      },
      "ripple_adder_189ce555": {
        "rtl_code": "\nmodule ripple_adder(\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\n    wire [15:0] a_lo = a[15:0];\n    wire [15:0] a_hi = a[31:16];\n    wire [15:0] b_lo = b[15:0];\n    wire [15:0] b_hi = b[31:16];\n    wire [15:0] sum_lo;\n    wire [15:0] sum_hi;\n    wire cout;\n\n    // First 16-bit adder\n    ripple_adder adder_lo(\n        .a(a_lo),\n        .b(sub ? ~b_lo : b_lo),\n        .cin(sub),\n        .sum(sum_lo),\n        .cout(cout)\n    );\n\n    // Second 16-bit adder\n    ripple_adder adder_hi(\n        .a(a_hi),\n        .b(sub ? ~b_hi : b_hi),\n        .cin(cout),\n        .sum(sum_hi),\n        .cout()\n    );\n\n    // 32-bit XOR gate\n    assign sum = {sum_hi, sum_lo} ^ (sub ? -1 : 0);\n\nendmodule",
        "module_name": "ripple_adder",
        "module_hash": "189ce555f4ab3a71db026587c6b1fba6",
        "dataset_index": 244
      },
      "shift_register_af10c78f": {
        "rtl_code": "module shift_register (\n  input clk,\n  input reset,\n  input load,\n  input [7:0] data_in,\n  output [7:0] data_out\n);\n\nreg [7:0] shift_reg;\n\nalways @(posedge clk, negedge reset) begin\n  if (!reset) begin\n    shift_reg <= 8'b0;\n  end else if (load) begin\n    shift_reg <= data_in;\n  end else begin\n    shift_reg <= {shift_reg[6:0], shift_reg[7]};\n  end\nend\n\nassign data_out = shift_reg;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "af10c78f17146e667b062eba2c5a5934",
        "dataset_index": 14902
      },
      "binary_counter_afec5fde": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    input load,\n    input [3:0] data_in,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else if (enable) begin\n            if (load) begin\n                count <= data_in;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "afec5fde5b3929b0290f816124c64aac",
        "dataset_index": 19950
      },
      "adder_4bit_b8a75341": {
        "rtl_code": "module adder_4bit(\n  input [3:0] A,\n  input [3:0] B,\n  input S,\n  output [3:0] C\n);\n\n  assign C = S ? A - B : A + B;\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "b8a753410f5dc141ec8c49f8e6c7a2bd",
        "dataset_index": 11095
      },
      "JK_FF_c5ce2d68": {
        "rtl_code": "module JK_FF (input J, K, C, R, E, output Q, Qn);\n    reg Q, Qn;\n    always @(posedge C) begin\n        if (E == 1'b0) begin\n            Q <= 1'b0;\n            Qn <= 1'b1;\n        end else if (R == 1'b0) begin\n            Q <= 1'b0;\n            Qn <= 1'b1;\n        end else if (J == 1'b1 && K == 1'b1) begin\n            Q <= ~Q;\n            Qn <= ~Qn;\n        end else if (J == 1'b1 && K == 1'b0) begin\n            Q <= 1'b1;\n            Qn <= 1'b0;\n        end else if (J == 1'b0 && K == 1'b1) begin\n            Q <= 1'b0;\n            Qn <= 1'b1;\n        end\n    end\nendmodule",
        "module_name": "JK_FF",
        "module_hash": "c5ce2d6801a50a0385cee90bce9b30c4",
        "dataset_index": 10363
      },
      "cp0_bae8bf2c": {
        "rtl_code": "\n\n`define SR 5'd12\n`define CAUSE 5'd13\n`define EPC 5'd14\n`define PRID 5'd15\n\n`define EC_INT 5'b00000\n\nmodule cp0 (input         clk,\n            input         rst,\n            input [4:0]   a1,\n            input [4:0]   a2,\n            input [31:0]  din,\n            input [31:0]  pc,\n            input [6:2]   ExcCode,\n            input [5:0]   HWInt,\n            input         we,\n            input         EXLSet,\n            input         EXLClr,\n            output        IntReq,\n            output [31:0] EPC,\n            output [31:0] dout\n            );\n   reg [15:10]            im;\n   reg                    exl,ie;\n   reg [15:10]            hwint_pend;\n   reg [31:0]             _epc;\n   reg [31:0]             PrId;\n   reg [6:2]              _exccode;\n\n   always @(posedge clk or posedge rst) begin\n      if (rst) begin\n         ie<=1;\n         im<=6'b110000;\n         exl<=0;\n         hwint_pend<=0;\n         PrId<=32'h12345678;\n      end else begin\n         hwint_pend<=HWInt;\n         if (IntReq) begin\n            _exccode<=ExcCode;\n            _epc<=pc-4;\n            exl<=1'b1;\n         end else if (we) begin\n            if (a2==`SR) begin\n               {im,exl,ie}<={din[15:10],EXLClr?1'b1:din[1],din[0]};\n            end\n            else if (a2==`EPC) begin\n               _epc<=pc;\n            end\n            else if (EXLSet) begin\n               exl<=1'b1;\n            end else if (EXLClr) begin\n               exl<=1'b0;\n            end\n         end else if (EXLSet) begin\n            exl<=1'b1;\n         end else if (EXLClr) begin\n            exl<=1'b0;\n         end end\n   end\n   assign dout=(a1==`SR)?{16'b0,im,8'b0,exl,ie}:\n               (a1==`CAUSE)?{16'b0,hwint_pend,3'b0,_exccode,2'b00}:\n               (a1==`EPC)?_epc:\n               (a1==`PRID)?PrId:\n               32'h0000_0000;\n   assign EPC=_epc;\n   assign IntReq=ie&&(!exl)&&(hwint_pend[15:10]&im[15:10]);\n\n\nendmodule ",
        "module_name": "cp0",
        "module_hash": "bae8bf2c286f0f1046fe4b0c53744f29",
        "dataset_index": 22158
      },
      "tri_intersect_data_array_348c5b42": {
        "rtl_code": "module tri_intersect_data_array(\n    reset,\n    clk,\n    address0,\n    ce0,\n    we0,\n    d0,\n    q0,\n    address1,\n    ce1,\n    we1,\n    d1,\n    q1);\n\nparameter DataWidth = 32'd576;\nparameter AddressRange = 32'd20;\nparameter AddressWidth = 32'd5;\n\ninput reset;\ninput clk;\ninput[AddressWidth - 1:0] address0;\ninput ce0;\ninput we0;\ninput[DataWidth - 1:0] d0;\noutput[DataWidth - 1:0] q0;\ninput[AddressWidth - 1:0] address1;\ninput ce1;\ninput we1;\ninput[DataWidth - 1:0] d1;\noutput[DataWidth - 1:0] q1;\n\nreg [DataWidth-1:0] tri_intersect_array [0:AddressRange-1];\n\ninteger i;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        for (i = 0; i < AddressRange; i = i + 1) begin\n            tri_intersect_array[i] <= 0;\n        end\n    end else if (ce0 && we0) begin\n        tri_intersect_array[address0] <= d0;\n    end else if (ce1 && we1) begin\n        tri_intersect_array[address1] <= d1;\n    end\nend\n\nassign q0 = tri_intersect_array[address0] & tri_intersect_array[address1];\nassign q1 = tri_intersect_array[address0] & tri_intersect_array[address1];\n\nendmodule",
        "module_name": "tri_intersect_data_array",
        "module_hash": "348c5b4220a6cb9221115089abdfefba",
        "dataset_index": 11277
      },
      "chatgpt_generate_JC_counter_9869bc6a": {
        "rtl_code": "\nmodule chatgpt_generate_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [31:0]   Q\n);\n\n  reg [31:0] lfsr_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      lfsr_reg <= 32'h00000001;\n      Q <= 4'b0001;\n    end\n    else begin\n      lfsr_reg <= { lfsr_reg[30:0], lfsr_reg[31] ^ lfsr_reg[28] };\n      Q <= lfsr_reg[3:0];\n    end\n  end\n\nendmodule",
        "module_name": "chatgpt_generate_JC_counter",
        "module_hash": "9869bc6a895ac20976cdeda66f76fd99",
        "dataset_index": 14934
      },
      "sensor_interface_bc9c4260": {
        "rtl_code": "module sensor_interface (\n  input clk,\n  input [7:0] temp_data,\n  input [7:0] pressure_data,\n  input [7:0] humidity_data,\n  output temp_ready,\n  output pressure_ready,\n  output humidity_ready,\n  output reg [7:0] temp_out,\n  output reg [7:0] pressure_out,\n  output reg [7:0] humidity_out\n);\n\nparameter clk_freq = 100000000; // 100 MHz clock\nparameter sample_freq = 100; // sample at 100 Hz\n\nreg [31:0] sample_counter = 0;\nreg temp_ready_reg = 0;\nreg pressure_ready_reg = 0;\nreg humidity_ready_reg = 0;\n\nalways @(posedge clk) begin\n  // increment sample counter\n  sample_counter <= sample_counter + 1;\n\n  // check if it's time to sample the sensors\n  if (sample_counter == clk_freq / sample_freq) begin\n    // reset sample counter\n    sample_counter <= 0;\n\n    // sample sensor data\n    temp_out <= temp_data;\n    pressure_out <= pressure_data;\n    humidity_out <= humidity_data;\n\n    // set ready signals high for one clock cycle\n    temp_ready_reg <= 1;\n    pressure_ready_reg <= 1;\n    humidity_ready_reg <= 1;\n  end else begin\n    // set ready signals low\n    temp_ready_reg <= 0;\n    pressure_ready_reg <= 0;\n    humidity_ready_reg <= 0;\n  end\nend\n\n// assign ready signals to output ports\nassign temp_ready = temp_ready_reg;\nassign pressure_ready = pressure_ready_reg;\nassign humidity_ready = humidity_ready_reg;\n\nendmodule",
        "module_name": "sensor_interface",
        "module_hash": "bc9c42605d447bb5c626c1854132ebb5",
        "dataset_index": 17659
      },
      "concat_split_vectors_68ebf6a3": {
        "rtl_code": "module concat_split_vectors (\n  input [7:0] a,\n  input [7:0] b,\n  output reg [3:0] w,\n  output reg [3:0] x,\n  output reg [3:0] y,\n  output reg [3:0] z\n);\n\n  reg [15:0] concat;\n  \n  always @ (a or b) begin\n    concat = {a, b};\n  end\n  \n  assign {w, x, y, z} = concat + 4'b11;\n  \nendmodule\n",
        "module_name": "concat_split_vectors",
        "module_hash": "68ebf6a379f339559ee71374591cb96e",
        "dataset_index": 1362
      },
      "counter_0f4c425a": {
        "rtl_code": "module counter (\n    input CLK,\n    input CTRL,\n    input LOAD,\n    input [3:0] D,\n    output reg [3:0] Q\n);\n\nalways @(posedge CLK) begin\n    if (CTRL) begin\n        Q <= 4'b0;\n    end else if (LOAD) begin\n        Q <= D;\n    end else begin\n        Q <= Q + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "0f4c425adb8bd32973bb96dfe39576ba",
        "dataset_index": 17922
      },
      "adder_f545ac1b": {
        "rtl_code": "module adder (\n    input [15:0] A,\n    input [15:0] B,\n    input CIN,\n    output [15:0] SUM,\n    output COUT\n);\n\n    assign {COUT, SUM} = A + B + CIN;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "f545ac1bb67f4e58a0ca0043b8b5dbbe",
        "dataset_index": 12366
      },
      "and4_2e083ca8": {
        "rtl_code": "module and4 (\n    input  A,\n    input  B,\n    input  C,\n    input  D,\n    output X,\n    input  clk,\n    input  rst\n);\n\n    reg X_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            X_reg <= 1'b0;\n        end else begin\n            X_reg <= A & B & C & D;\n        end\n    end\n\n    assign X = X_reg;\n\nendmodule",
        "module_name": "and4",
        "module_hash": "2e083ca88c922d3752feaa89d68a26f7",
        "dataset_index": 3583
      },
      "rw_manager_ram_csr #_9505c6ff": {
        "rtl_code": "\n\nmodule rw_manager_ram_csr #(\n   parameter DATA_WIDTH = 32,\n   parameter ADDR_WIDTH = 2,\n   parameter NUM_WORDS = 4\n) (\n   input                         csr_clk,\n   input                         csr_ena,\n   input                         csr_din,\n\n   input                         ram_clk,\n   input                         wren,\n   input      [(DATA_WIDTH-1):0] data,\n   input      [(ADDR_WIDTH-1):0] wraddress,\n   input      [(ADDR_WIDTH-1):0] rdaddress,\n\n   output reg [(DATA_WIDTH-1):0] q,\n   output reg                    csr_dout\n);\n\n\nlocalparam integer DATA_COUNT = DATA_WIDTH*NUM_WORDS;\n\nreg  [DATA_COUNT-1:0] all_data;\nwire [DATA_COUNT-1:0] load_data;\nwire [DATA_WIDTH-1:0] row_data [NUM_WORDS-1:0];\n\nwire int_clk;\n\nassign int_clk = (~csr_ena)? csr_clk : ram_clk;\n\nalways @(posedge int_clk)\nbegin\n   if (~csr_ena)\n      all_data <= {all_data[DATA_COUNT-2:0], csr_din};\n   else if (wren)\n      all_data <= load_data;\n   else\n      all_data <= all_data;\n\n   q <= row_data[rdaddress];\nend\n\nalways @(negedge csr_clk)\nbegin\n   csr_dout <= all_data[DATA_COUNT-1];\nend\n\ngenerate\n\ngenvar i;\n\n\n   for (i = 0; i < (NUM_WORDS); i = i + 1)\n   begin: row_assign\n     assign row_data[i] = all_data[(DATA_WIDTH*(i+1)-1) : (DATA_WIDTH*i)];\n   end\n\nendgenerate\n\ngenerate\n\ngenvar j,k;\n\n   for (j = 0; j < (NUM_WORDS); j = j + 1)\n   begin: row\n     for (k = 0; k < (DATA_WIDTH); k = k + 1)\n     begin: column\n        assign load_data[(DATA_WIDTH*j)+k] = (wraddress == j)? data[k] : all_data[(DATA_WIDTH*j)+k];\n     end\n   end\nendgenerate\n\nendmodule\n",
        "module_name": "rw_manager_ram_csr #",
        "module_hash": "9505c6ff495bcc3cd6c714d4e12355c5",
        "dataset_index": 25410
      },
      "fifo_dce87962": {
        "rtl_code": "\n\nmodule fifo(clock,reset,read,write,fifo_in,fifo_out,fifo_empty,fifo_full);\n    \n    input clock,reset,read,write;       input [15:0]fifo_in;                output[15:0]fifo_out;               output fifo_empty,fifo_full;        reg [15:0]fifo_out;                         reg [15:0]ram[15:0];                        reg [3:0]read_ptr,write_ptr,counter;        wire fifo_empty,fifo_full;          always@(posedge clock)    if(reset)   begin\n                read_ptr = 0; \n                write_ptr = 0;\n                counter = 0;\n                fifo_out = 0;                    \n            end\n        else\n            case({read,write})  2'b00:  counter=counter;        \n            2'b01:  begin\n                ram[write_ptr] = fifo_in;\n                counter = counter+1;\n                write_ptr = (write_ptr == 15)?0:write_ptr + 1;\n            end\n            2'b10: begin\n                fifo_out = ram[read_ptr];\n                counter = counter - 1;\n                read_ptr = (read_ptr == 15)?0:read_ptr + 1;\n            end\n            2'b11: begin\n                if(counter == 0)\n                    fifo_out = fifo_in;\n                else\n                begin\n                    ram[write_ptr]=fifo_in;\n                    fifo_out=ram[read_ptr];\n                    write_ptr=(write_ptr==15)?0:write_ptr+1;\n                    read_ptr=(read_ptr==15)?0:write_ptr+1;\n                end\n            end\n        endcase\n        \n        assign fifo_empty = (counter == 0);    assign fifo_full = (counter == 15);\n        \nendmodule\n",
        "module_name": "fifo",
        "module_hash": "dce8796246ede4304140becdf1c70c10",
        "dataset_index": 11747
      },
      "adder_d22ac5b7": {
        "rtl_code": "module adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum,\n    output carry\n);\n\n    wire [8:0] temp_sum;\n    \n    assign temp_sum = {1'b0, a} + {1'b0, b};\n    assign sum = temp_sum[7:0];\n    assign carry = temp_sum[8];\n    \nendmodule",
        "module_name": "adder",
        "module_hash": "d22ac5b74a2655beec84e4a473b2b4ee",
        "dataset_index": 10163
      },
      "not_32_7a9aabd4": {
        "rtl_code": "module not_32(\n\tinput [31:0] a, output [31:0] out );\n\n\tassign out[0] \t=  !a[0]; \n\tassign out[1] \t=  !a[1]; \n\tassign out[2] \t=  !a[2]; \n\tassign out[3] \t=  !a[3]; \n\tassign out[4] \t=  !a[4]; \n\tassign out[5] \t=  !a[5]; \n\tassign out[6] \t=  !a[6]; \n\tassign out[7] \t=  !a[7]; \n\tassign out[8] \t=  !a[8]; \n\tassign out[9] \t=  !a[9]; \n\tassign out[10]\t=  !a[10]; \n\tassign out[11] \t=  !a[11]; \n\tassign out[12] \t=  !a[12]; \n\tassign out[13] \t=  !a[13]; \n\tassign out[14] \t=  !a[14]; \n\tassign out[15] \t=  !a[15]; \n\tassign out[16] \t=  !a[16]; \n\tassign out[17] \t=  !a[17]; \n\tassign out[18] \t=  !a[18]; \n\tassign out[19] \t=  !a[19]; \n\tassign out[20] \t=  !a[20]; \n\tassign out[21] \t=  !a[21]; \n\tassign out[22] \t=  !a[22]; \n\tassign out[23] \t=  !a[23];\n\tassign out[24] \t=  !a[24]; \n\tassign out[25]\t=  !a[25]; \n\tassign out[26] \t=  !a[26]; \n\tassign out[27] \t=  !a[27]; \n\tassign out[28] \t=  !a[28]; \n\tassign out[29] \t=  !a[29]; \n\tassign out[30] \t=  !a[30];\n\tassign out[31] \t=  !a[31];\nendmodule\n",
        "module_name": "not_32",
        "module_hash": "7a9aabd4326a4dd3ed8ec3fdc0aa1b8a",
        "dataset_index": 12033
      },
      "sky130_fd_sc_lp__a2bb2oi_842237b5": {
        "rtl_code": "module sky130_fd_sc_lp__a2bb2oi (\n    Y   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    assign Y = (A1_N & B1) | (A2_N & B2);\n\nendmodule\n\nmodule sky130_fd_sc_lp__a2bb2oi_lp (\n    Y   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_lp__a2bb2oi base (\n        .Y(Y),\n        .A1_N(A1_N),\n        .A2_N(A2_N),\n        .B1(B1),\n        .B2(B2)\n    );\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a2bb2oi",
        "module_hash": "842237b5ecd2b2542e9f6dbbc44c0312",
        "dataset_index": 6576
      },
      "mdio_master_cc1e023b": {
        "rtl_code": "\n\n`resetall\n\n\n\n\nmodule mdio_master (\n    input  wire        clk,\n    input  wire        rst,\n\n    \n    input  wire [4:0]  cmd_phy_addr,\n    input  wire [4:0]  cmd_reg_addr,\n    input  wire [15:0] cmd_data,\n    input  wire [1:0]  cmd_opcode,\n    input  wire        cmd_valid,\n    output wire        cmd_ready,\n\n    output wire [15:0] data_out,\n    output wire        data_out_valid,\n    input  wire        data_out_ready,\n\n    \n    output wire        mdc_o,\n    input  wire        mdio_i,\n    output wire        mdio_o,\n    output wire        mdio_t,\n\n    \n    output wire        busy,\n\n    \n    input  wire [7:0]  prescale\n);\n\nlocalparam [1:0]\n    STATE_IDLE = 2'd0,\n    STATE_PREAMBLE = 2'd1,\n    STATE_TRANSFER = 2'd2;\n\nreg [1:0] state_reg = STATE_IDLE, state_next;\n\nreg [16:0] count_reg = 16'd0, count_next;\nreg [6:0] bit_count_reg = 6'd0, bit_count_next;\nreg cycle_reg = 1'b0, cycle_next;\n\nreg [31:0] data_reg = 32'd0, data_next;\n\nreg [1:0] op_reg = 2'b00, op_next;\n\nreg cmd_ready_reg = 1'b0, cmd_ready_next;\n\nreg [15:0] data_out_reg = 15'd0, data_out_next;\nreg data_out_valid_reg = 1'b0, data_out_valid_next;\n\nreg mdio_i_reg = 1'b1;\n\nreg mdc_o_reg = 1'b0, mdc_o_next;\nreg mdio_o_reg = 1'b0, mdio_o_next;\nreg mdio_t_reg = 1'b1, mdio_t_next;\n\nreg busy_reg = 1'b0;\n\nassign cmd_ready = cmd_ready_reg;\n\nassign data_out = data_out_reg;\nassign data_out_valid = data_out_valid_reg;\n\nassign mdc_o = mdc_o_reg;\nassign mdio_o = mdio_o_reg;\nassign mdio_t = mdio_t_reg;\n\nassign busy = busy_reg;\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    count_next = count_reg;\n    bit_count_next = bit_count_reg;\n    cycle_next = cycle_reg;\n\n    data_next = data_reg;\n\n    op_next = op_reg;\n\n    cmd_ready_next = 1'b0;\n\n    data_out_next = data_out_reg;\n    data_out_valid_next = data_out_valid_reg & ~data_out_ready;\n\n    mdc_o_next = mdc_o_reg;\n    mdio_o_next = mdio_o_reg;\n    mdio_t_next = mdio_t_reg;\n\n    if (count_reg > 16'd0) begin\n        count_next = count_reg - 16'd1;\n        state_next = state_reg;\n    end else if (cycle_reg) begin\n        cycle_next = 1'b0;\n        mdc_o_next = 1'b1;\n        count_next = prescale;\n        state_next = state_reg;\n    end else begin\n        mdc_o_next = 1'b0;\n        case (state_reg)\n            STATE_IDLE: begin\n                cmd_ready_next = ~data_out_valid;\n\n                if (cmd_ready & cmd_valid) begin\n                    cmd_ready_next = 1'b0;\n                    data_next = {2'b01, cmd_opcode, cmd_phy_addr, cmd_reg_addr, 2'b10, cmd_data};\n                    op_next = cmd_opcode;\n                    mdio_t_next = 1'b0;\n                    mdio_o_next = 1'b1;\n                    bit_count_next = 6'd32;\n                    cycle_next = 1'b1;\n                    count_next = prescale;\n                    state_next = STATE_PREAMBLE;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_PREAMBLE: begin\n                cycle_next = 1'b1;\n                count_next = prescale;\n                if (bit_count_reg > 6'd1) begin\n                    bit_count_next = bit_count_reg - 6'd1;\n                    state_next = STATE_PREAMBLE;\n                end else begin\n                    bit_count_next = 6'd32;\n                    {mdio_o_next, data_next} = {data_reg, mdio_i_reg};\n                    state_next = STATE_TRANSFER;\n                end\n            end\n            STATE_TRANSFER: begin\n                cycle_next = 1'b1;\n                count_next = prescale;\n                if ((op_reg == 2'b10 || op_reg == 2'b11) && bit_count_reg == 6'd19) begin\n                    mdio_t_next = 1'b1;\n                end\n                if (bit_count_reg > 6'd1) begin\n                    bit_count_next = bit_count_reg - 6'd1;\n                    {mdio_o_next, data_next} = {data_reg, mdio_i_reg};\n                    state_next = STATE_TRANSFER;\n                end else begin\n                    if (op_reg == 2'b10 || op_reg == 2'b11) begin\n                        data_out_next = data_reg[15:0];\n                        data_out_valid_next = 1'b1;\n                    end\n                    mdio_t_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        count_reg <= 16'd0;\n        bit_count_reg <= 6'd0;\n        cycle_reg <= 1'b0;\n        cmd_ready_reg <= 1'b0;\n        data_out_valid_reg <= 1'b0;\n        mdc_o_reg <= 1'b0;\n        mdio_o_reg <= 1'b0;\n        mdio_t_reg <= 1'b1;\n        busy_reg <= 1'b0;\n    end else begin\n        state_reg <= state_next;\n        count_reg <= count_next;\n        bit_count_reg <= bit_count_next;\n        cycle_reg <= cycle_next;\n        cmd_ready_reg <= cmd_ready_next;\n        data_out_valid_reg <= data_out_valid_next;\n        mdc_o_reg <= mdc_o_next;\n        mdio_o_reg <= mdio_o_next;\n        mdio_t_reg <= mdio_t_next;\n        busy_reg <= (state_next != STATE_IDLE || count_reg != 0 || cycle_reg || mdc_o);\n    end\n\n    data_reg <= data_next;\n    op_reg <= op_next;\n\n    data_out_reg <= data_out_next;\n\n    mdio_i_reg <= mdio_i;\nend\n\nendmodule\n\n`resetall\n",
        "module_name": "mdio_master",
        "module_hash": "cc1e023bf8a472f26e1ac08df8d731ef",
        "dataset_index": 25207
      },
      "load_store_pipe_arbiter_8ed537d4": {
        "rtl_code": "\n\nmodule load_store_pipe_arbiter(\n\t\toutput wire oLDST_REQ,\n\t\tinput wire iLDST_BUSY,\n\t\toutput wire [1:0] oLDST_ORDER,\toutput wire [3:0] oLDST_MASK,\n\t\toutput wire oLDST_RW,\t\toutput wire [13:0] oLDST_ASID,\n\t\toutput wire [1:0] oLDST_MMUMOD,\n\t\toutput wire [2:0] oLDST_MMUPS,\n\t\toutput wire [31:0] oLDST_PDT,\n\t\toutput wire [31:0] oLDST_ADDR,\n\t\toutput wire [31:0] oLDST_DATA,\n\t\tinput wire iLDST_VALID,\n\t\tinput wire [11:0] iLDST_MMU_FLAGS,\n\t\tinput wire [31:0] iLDST_DATA,\n\t\tinput wire iUSE_SEL,\t\tinput wire iEXE_REQ,\n\t\toutput wire oEXE_BUSY,\n\t\tinput wire [1:0] iEXE_ORDER,\tinput wire [3:0] iEXE_MASK,\n\t\tinput wire iEXE_RW,\t\tinput wire [13:0] iEXE_ASID,\n\t\tinput wire [1:0] iEXE_MMUMOD,\n\t\tinput wire [2:0] iEXE_MMUPS,\n\t\tinput wire [31:0] iEXE_PDT,\n\t\tinput wire [31:0] iEXE_ADDR,\n\t\tinput wire [31:0] iEXE_DATA,\n\t\toutput wire oEXE_REQ,\n\t\toutput wire [11:0] oEXE_MMU_FLAGS,\n\t\toutput wire [31:0] oEXE_DATA,\n\t\tinput wire iEXCEPT_REQ,\n\t\toutput wire oEXCEPT_BUSY,\n\t\tinput wire [1:0] iEXCEPT_ORDER,\tinput wire iEXCEPT_RW,\t\tinput wire [13:0] iEXCEPT_ASID,\n\t\tinput wire [1:0] iEXCEPT_MMUMOD,\n\t\tinput wire [2:0] iEXCEPT_MMUPS,\n\t\tinput wire [31:0] iEXCEPT_PDT,\n\t\tinput wire [31:0] iEXCEPT_ADDR,\n\t\tinput wire [31:0] iEXCEPT_DATA,\n\t\toutput wire oEXCEPT_REQ,\n\t\toutput wire [31:0] oEXCEPT_DATA\n\t);\n\n\n\n\tassign oLDST_REQ = (iUSE_SEL)? iEXCEPT_REQ : iEXE_REQ;\n\tassign oLDST_ORDER = (iUSE_SEL)? iEXCEPT_ORDER : iEXE_ORDER;\n\tassign oLDST_MASK = (iUSE_SEL)? 4'hf : iEXE_MASK;\n\tassign oLDST_RW = (iUSE_SEL)? iEXCEPT_RW : iEXE_RW;\n\tassign oLDST_ASID = (iUSE_SEL)? iEXCEPT_ASID : iEXE_ASID;\n\tassign oLDST_MMUMOD = (iUSE_SEL)? iEXCEPT_MMUMOD : iEXE_MMUMOD;\n\tassign oLDST_MMUPS = (iUSE_SEL)? iEXCEPT_MMUPS : iEXE_MMUPS;\n\tassign oLDST_PDT = (iUSE_SEL)? iEXCEPT_PDT : iEXE_PDT;\n\tassign oLDST_ADDR = (iUSE_SEL)? iEXCEPT_ADDR : iEXE_ADDR;\n\tassign oLDST_DATA = (iUSE_SEL)? iEXCEPT_DATA : iEXE_DATA;\n\n\tassign oEXCEPT_BUSY\t= (iUSE_SEL)? iLDST_BUSY  : 1'b1;\n\tassign oEXCEPT_REQ = (iUSE_SEL)? iLDST_VALID : 1'b0;\n\tassign oEXCEPT_DATA\t= iLDST_DATA;\n\n\tassign oEXE_BUSY = (iUSE_SEL)? 1'b1 : iLDST_BUSY;\n\tassign oEXE_REQ = (iUSE_SEL)? 1'b0 : iLDST_VALID;\n\tassign oEXE_MMU_FLAGS = iLDST_MMU_FLAGS;\n\tassign oEXE_DATA = iLDST_DATA;\n\n\nendmodule\n\n",
        "module_name": "load_store_pipe_arbiter",
        "module_hash": "8ed537d4be38ac6aac5bb65c8fa89b5a",
        "dataset_index": 21073
      },
      "clock_module_dbbbb383": {
        "rtl_code": "module clock_module(input wire inclk0,\n                    output wire c0,\n                    output wire c1,\n                    output wire locked,\n                    output wire e0);\n\n    assign c0 = inclk0;\n    assign c1 = inclk0;\n    assign locked = 1;\n    assign e0 = ~inclk0;\n\nendmodule",
        "module_name": "clock_module",
        "module_hash": "dbbbb3838ea21f018618c8df1a0d4d46",
        "dataset_index": 1842
      },
      "top_module_86a64da1": {
        "rtl_code": "module top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // instantiate the logical-OR and bitwise-OR module\n    logic_or_bitwise_or_module lb_module(\n        .a(a),\n        .b(b),\n        .out(out_or_bitwise)\n    );\n\n    // instantiate the inverter module\n    inverter_module inv_module_a(\n        .in(a),\n        .out(out_not[2:0])\n    );\n\n    inverter_module inv_module_b(\n        .in(b),\n        .out(out_not[5:3])\n    );\n\n    // implement the logical-OR operation using XOR and AND gates\n    assign out_or_logical = (a | b) == 3'b111 ? 1'b1 : 1'b0;\n\nendmodule\n\n// module for logical-OR and bitwise-OR\nmodule logic_or_bitwise_or_module(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out\n);\n\n    // implement the bitwise-OR operation using OR gates\n    assign out = a | b;\n\nendmodule\n\n// module for inverter\nmodule inverter_module(\n    input [2:0] in,\n    output [2:0] out\n);\n\n    // implement the inverter using NOT gates\n    assign out = ~in;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "86a64da1e5c56c78a09afd9802f4ec5b",
        "dataset_index": 18921
      },
      "binary_counter_797c6735": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst) begin\n    if (rst == 0) begin\n      out <= 4'b0000;\n    end else begin\n      out <= out + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "797c67354e8110c10ef1d777c5714092",
        "dataset_index": 6715
      },
      "ballcollisions_df67c69c": {
        "rtl_code": "module ballcollisions(\n\tclk,\n\treset,\n\tp1_y,\n\tp2_y,\n\tball_x,\n\tball_y,\n\tdir_x,\n\tdir_y,\n\toob\n);\n\ninput clk, reset;\ninput [10:0] p1_y, p2_y, ball_x, ball_y;\noutput reg dir_x, dir_y, oob;\n\n// Constants\nlocalparam hc = 512;\nlocalparam va = 0;\nlocalparam vc = 480;\nlocalparam batwidth = 10;\nlocalparam batheight = 80;\nlocalparam ballsize = 10;\n\n// Initial values\nreg ball_x_reg, ball_y_reg;\nreg dir_x_reg, dir_y_reg;\nreg oob_reg;\ninitial begin\n\tball_x_reg = hc;\n\tball_y_reg = vc/2;\n\tdir_x_reg = 0;\n\tdir_y_reg = 1;\n\toob_reg = 0;\nend\n\n// Logic for direction changes\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tdir_x_reg <= ~dir_x_reg;\n\t\tdir_y_reg <= 1;\n\t\toob_reg <= 0;\n\t\tball_x_reg <= hc;\n\t\tball_y_reg <= vc/2;\n\tend\n\telse begin\n\t\t// out of bounds (i.e. one of the players missed the ball)\n\t\tif (ball_x_reg <= 0 || ball_x_reg >= hc) begin\n\t\t\toob_reg <= 1;\n\t\tend\n\t\telse begin\n\t\t\toob_reg <= 0;\n\t\tend\n\t\t\n\t\t// collision with top & bottom walls\n\t\tif (ball_y_reg <= va + ballsize) begin\n\t\t\tdir_y_reg <= 1;\n\t\tend\n\t\tif (ball_y_reg >= vc - ballsize) begin\n\t\t\tdir_y_reg <= 0;\n\t\tend\n\t\t\n\t\t// collision with P1 bat\n\t\tif (ball_x_reg <= batwidth && ball_y_reg + ballsize >= p1_y && ball_y_reg <= p1_y + batheight) begin\n\t\t\tdir_x_reg <= 1;\n\t\t\tif (ball_y_reg + ballsize <= p1_y + (batheight / 2)) begin\n\t\t\t\tdir_y_reg <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tdir_y_reg <= 1;\n\t\t\tend\n\t\tend\n\t\t// collision with P2 bat\n\t\telse if (ball_x_reg >= hc - batwidth - ballsize && ball_y_reg + ballsize <= p2_y + batheight && ball_y_reg >= p2_y) begin\n\t\t\tdir_x_reg <= 0;\n\t\t\tif (ball_y_reg + ballsize <= p2_y + (batheight / 2)) begin\n\t\t\t\tdir_y_reg <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tdir_y_reg <= 1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t// Move ball based on direction\n\t\tif (dir_x_reg) begin\n\t\t\tball_x_reg <= ball_x_reg + 1;\n\t\tend\n\t\telse begin\n\t\t\tball_x_reg <= ball_x_reg - 1;\n\t\tend\n\t\t\n\t\tif (dir_y_reg) begin\n\t\t\tball_y_reg <= ball_y_reg + 1;\n\t\tend\n\t\telse begin\n\t\t\tball_y_reg <= ball_y_reg - 1;\n\t\tend\n\tend\nend\n\n// Assign output signals to registered values\nalways @* begin\n\tdir_x = dir_x_reg;\n\tdir_y = dir_y_reg;\n\toob = oob_reg;\nend\n\nendmodule",
        "module_name": "ballcollisions",
        "module_hash": "df67c69c8640a5870f8e1a5694fd0769",
        "dataset_index": 7961
      },
      "counter_a2fd1fb1": {
        "rtl_code": "module counter(\n  input clk,\n  input reset,\n  output reg [15:0] count\n);\n\n  always @(posedge clk) begin\n    if(reset) begin\n      count <= 16'd0;\n    end\n    else begin\n      count <= count + 16'd1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "a2fd1fb15280e031bf3faf884d3031f7",
        "dataset_index": 16248
      },
      "priority_encoder_ec2aec35": {
        "rtl_code": "module priority_encoder (\n    input [1:0] data,\n    input clk,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= data[1];\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "ec2aec35ea30758f8f319fbb02dfa4ab",
        "dataset_index": 11904
      },
      "DFFSR_e0faa360": {
        "rtl_code": "module DFFSR (CLK, D, SET, RESET, Q, QN);\ninput CLK;\ninput D;\ninput SET;\ninput RESET;\noutput Q;\noutput QN;\n\nreg Q;\n\nalways @(posedge CLK) begin\n    if (SET) begin\n        Q <= 1'b1;\n    end else if (RESET) begin\n        Q <= 1'b0;\n    end else begin\n        Q <= D;\n    end\nend\n\nassign QN = ~Q;\n\nendmodule",
        "module_name": "DFFSR",
        "module_hash": "e0faa360b430e3c2941749a45feeebb6",
        "dataset_index": 9393
      },
      "odd_even_d0e3869b": {
        "rtl_code": "module odd_even (\n  input [2:0] input_bits,\n  output reg [1:0] output_bits\n);\n\n  always @(*) begin\n    if (input_bits[0] == 1) // check if LSB is 1\n      output_bits = 2'b01;\n    else\n      output_bits = 2'b10;\n  end\n\nendmodule\n",
        "module_name": "odd_even",
        "module_hash": "d0e3869bcd4f23922f6106f559a71857",
        "dataset_index": 9567
      },
      "sky130_fd_sc_hdll__o21a_78d1447b": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__o21a (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1         );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__o21a",
        "module_hash": "78d1447b352c82a930f869e63ba414b3",
        "dataset_index": 22073
      },
      "top__5af119e3": {
        "rtl_code": "module top_module ( \n    input wire clk, \n    input wire reset_n, \n    input wire [7:0] in, \n    output wire [15:0] out );\n\n    reg [7:0] in_reg;\n    wire [15:0] sum;\n    wire [7:0] out_vec;\n\n    sum_module sum_inst (\n        .in(in_reg),\n        .out(sum)\n    );\n\n    always @(posedge clk) begin\n        if (reset_n == 1'b0) begin\n            in_reg <= 8'b0;\n        end else begin\n            in_reg <= in;\n        end\n    end\n\n    assign out_vec = in_reg;\n    assign out = {out_vec, sum};\n\nendmodule\n\nmodule sum_module (\n    input wire [7:0] in, \n    output wire [15:0] out );\n\n    assign out = {8'b0, in} + {in, 8'b0};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "5af119e3781d613ba4e2f82ea93763d7",
        "dataset_index": 10238
      },
      "mux4to1_2d5800b6": {
        "rtl_code": "module mux4to1 (\n  input [3:0] in,\n  input [1:0] sel,\n  output reg out\n);\n\n  always @(*) begin\n    case ({sel})\n      2'b00: out <= in[0];\n      2'b01: out <= in[1];\n      2'b10: out <= in[2];\n      2'b11: out <= in[3];\n    endcase\n  end\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "2d5800b6ed6c193c8fb559e2b438ff99",
        "dataset_index": 20744
      },
      "mux4_b6b1224c": {
        "rtl_code": "module mux4 (\n  input [1:0] sel,\n  input [3:0] in0,\n  input [3:0] in1,\n  input [3:0] in2,\n  input [3:0] in3,\n  output [3:0] out\n);\n\n  wire [3:0] w1,w2,w3,w4;\n  assign w1 = (sel == 2'b00) ? in0 : 4'b0000;\n  assign w2 = (sel == 2'b01) ? in1 : 4'b0000;\n  assign w3 = (sel == 2'b10) ? in2 : 4'b0000;\n  assign w4 = (sel == 2'b11) ? in3 : 4'b0000;\n  assign out = w1 | w2 | w3 | w4;\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "b6b1224c23172cd19479f07b269320ad",
        "dataset_index": 2530
      },
      "Arithmetic_Logic_Operations_579bd1e2": {
        "rtl_code": "module Arithmetic_Logic_Operations(\n    input [7:0] a,\n    input [7:0] b,\n    input [2:0] op,\n    input sel,\n    output reg [7:0] out\n);\n\nreg [7:0] result;\n\nalways @* begin\n    case(op)\n        3'b000: result = a + b;\n        3'b001: result = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        3'b101: result = ~a;\n        3'b110: result = a << b;\n        3'b111: result = a >> b;\n        default: result = 8'h00;\n    endcase\n    \n    if(sel) begin\n        out <= result;\n    end else begin\n        out <= a;\n    end\nend\n\nendmodule",
        "module_name": "Arithmetic_Logic_Operations",
        "module_hash": "579bd1e2a7f080606327e0b43e61c61e",
        "dataset_index": 7738
      },
      "priority_encoder_fc5aa7fd": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] a, b, c, d,\n    output [2:0] index);\n\n    wire [7:0] temp;\n\n    assign temp = {a, b, c, d}; \n    assign index = 3'b000; \nendmodule\nmodule min_decade_counter (\n    input clk,\n    input reset,\n    input [7:0] a, b, c, d,\n    input clock_enable,\n    output [7:0] min,\n    output [3:0] q);\n\n    wire [2:0] index;\n    priority_encoder pe(.a(a), .b(b), .c(c), .d(d), .index(index));\n\n    reg [3:0] counter = 0;\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 0;\n        end else if (clock_enable) begin\n            counter <= (counter == 9) ? 0 : counter + 1;\n        end\n    end\n\n    assign min = (index == 3'b000) ? a :\n                 (index == 3'b001) ? b :\n                 (index == 3'b010) ? c :\n                 (index == 3'b011) ? d :\n                 8'b0 ;\n    assign q = counter;\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a, b, c, d,\n    input select,\n    input clock_enable,\n    output [7:0] min,\n    output [3:0] q);\n\n    wire [7:0] min_value;\n    wire [3:0] counter_value;\n\n    min_decade_counter mdc(.clk(clk), .reset(reset), .a(a), .b(b), .c(c), .d(d), .clock_enable(clock_enable), .min(min_value), .q(counter_value));\n\n    assign min = (select) ? min_value : 8'b0;\n    assign q = (select) ? counter_value : 4'b0;\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "fc5aa7fdf16d6f8233ad7cb0937b5ce8",
        "dataset_index": 20385
      },
      "logic__31848c0f": {
        "rtl_code": "module logic_module (a, b, g_out, p_out);\n  input a, b;\n  output g_out, p_out;\n  wire n2;\n\n  not inv1 (n2, a);\n  and (g_out, a, b);\n  xnor (p_out, b, n2);\n\nendmodule",
        "module_name": "logic_",
        "module_hash": "31848c0f5022be31ef740fce00d62396",
        "dataset_index": 2750
      },
      "baudgen_bf57b963": {
        "rtl_code": "\n\nmodule baudgen(\n  input wire clk,\n  input wire resetq,\n  input wire [31:0] baud,\n  input wire restart,\n  output wire ser_clk);\n  parameter CLKFREQ = 1000000;\n  \n  parameter RWIDTH = 25;\n\n  wire [RWIDTH-1:0] aclkfreq = CLKFREQ;\n  reg [RWIDTH-1:0] d;\n  wire [RWIDTH-1:0] dInc = d[RWIDTH-1] ? ({4'd0, baud}) : (({4'd0, baud}) - aclkfreq);\n  wire [RWIDTH-1:0] dN = restart ? 0 : (d + dInc);\n  wire fastclk = ~d[RWIDTH-1];\n  assign ser_clk = fastclk;\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      d <= 0;\n    end else begin\n      d <= dN;\n    end\n  end\nendmodule\n\n\n\nmodule uart(\n   input wire clk,\n   input wire resetq,\n\n   output wire uart_busy,       output reg uart_tx,          input wire [31:0] baud,\n   input wire uart_wr_i,        input wire [7:0] uart_dat_i\n);\n  parameter CLKFREQ = 1000000;\n\n  reg [3:0] bitcount;           reg [8:0] shifter;\n\n  assign uart_busy = |bitcount;\n  wire sending = |bitcount;\n\n  wire ser_clk;\n\n  wire starting = uart_wr_i & ~uart_busy;\n  baudgen #(.CLKFREQ(CLKFREQ)) _baudgen(\n    .clk(clk),\n    .resetq(resetq),\n    .baud(baud),\n    .restart(1'b0),\n    .ser_clk(ser_clk));\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      uart_tx <= 1;\n      bitcount <= 0;\n      shifter <= 0;\n    end else begin\n      if (starting) begin\n        shifter <= { uart_dat_i[7:0], 1'b0 };\n        bitcount <= 1 + 8 + 1;    end\n\n      if (sending & ser_clk) begin\n        { shifter, uart_tx } <= { 1'b1, shifter };\n        bitcount <= bitcount - 4'd1;\n      end\n    end\n  end\n\nendmodule\n\nmodule rxuart(\n   input wire clk,\n   input wire resetq,\n   input wire [31:0] baud,\n   input wire uart_rx,      input wire rd,           output wire valid,       output wire [7:0] data); parameter CLKFREQ = 1000000;\n\n  reg [4:0] bitcount;\n  reg [7:0] shifter;\n\n  wire idle = &bitcount;\n  wire sample;\n  reg [2:0] hh = 3'b111;\n  wire [2:0] hhN = {hh[1:0], uart_rx};\n  wire startbit = idle & (hhN[2:1] == 2'b10);\n  wire [7:0] shifterN = sample ? {hh[1], shifter[7:1]} : shifter;\n\n  wire ser_clk;\n  baudgen #(.CLKFREQ(CLKFREQ)) _baudgen(\n    .clk(clk),\n    .baud({baud[30:0], 1'b0}),\n    .resetq(resetq),\n    .restart(startbit),\n    .ser_clk(ser_clk));\n\n  assign valid = (bitcount == 18);\n  reg [4:0] bitcountN;\n  always @*\n    if (startbit)\n      bitcountN = 0;\n    else if (!idle & !valid & ser_clk)\n      bitcountN = bitcount + 5'd1;\n    else if (valid & rd)\n      bitcountN = 5'b11111;\n    else\n      bitcountN = bitcount;\n\n  assign sample = (bitcount > 2) & bitcount[0] & !valid & ser_clk;\n  assign data = shifter;\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      hh <= 3'b111;\n      bitcount <= 5'b11111;\n      shifter <= 0;\n    end else begin\n      hh <= hhN;\n      bitcount <= bitcountN;\n      shifter <= shifterN;\n    end\n  end\nendmodule\n\nmodule buart(\n   input wire clk,\n   input wire resetq,\n   input wire [31:0] baud,\n   input wire rx,           output wire tx,          input wire rd,           input wire wr,           output wire valid,       output wire busy,        input wire [7:0] tx_data,\n   output wire [7:0] rx_data );\n  parameter CLKFREQ = 1000000;\n\n  rxuart #(.CLKFREQ(CLKFREQ)) _rx (\n     .clk(clk),\n     .resetq(resetq),\n     .baud(baud),\n     .uart_rx(rx),\n     .rd(rd),\n     .valid(valid),\n     .data(rx_data));\n  uart #(.CLKFREQ(CLKFREQ)) _tx (\n     .clk(clk),\n     .resetq(resetq),\n     .baud(baud),\n     .uart_busy(busy),\n     .uart_tx(tx),\n     .uart_wr_i(wr),\n     .uart_dat_i(tx_data));\nendmodule\n",
        "module_name": "baudgen",
        "module_hash": "bf57b963214b15ab1f95242aa571fdb9",
        "dataset_index": 22213
      },
      "up_counter_51634cca": {
        "rtl_code": "module up_counter (\n    input CLK,\n    input CLR,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (CLR) begin\n            Q <= 4'b0;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "51634ccab9125f4e4f95cd6ca819cde6",
        "dataset_index": 20887
      },
      "state_machine_9b6697b0": {
        "rtl_code": "module state_machine (\n  input clk,\n  input reset,\n  input x,\n  input [5:0] y,\n  output Y2,\n  output Y4\n);\n\n  reg [5:0] state, next_state;\n  reg [5:0] Y;\n  \n  parameter A = 6'b000001;\n  parameter B = 6'b000010;\n  parameter C = 6'b000100;\n  parameter D = 6'b001000;\n  parameter E = 6'b010000;\n  parameter F = 6'b100000;\n  \n  // State transition logic\n  always @ (posedge clk) begin\n    if (reset) begin\n      state <= A;\n    end else begin\n      state <= next_state;\n    end\n  end\n  \n  always @ (state, x) begin\n    case (state)\n      A: begin\n        if (x) begin\n          next_state = B;\n        end else begin\n          next_state = C;\n        end\n      end\n      \n      B: begin\n        if (x) begin\n          next_state = C;\n        end else begin\n          next_state = D;\n        end\n      end\n      \n      C: begin\n        if (x) begin\n          next_state = D;\n        end else begin\n          next_state = E;\n        end\n      end\n      \n      D: begin\n        if (x) begin\n          next_state = E;\n        end else begin\n          next_state = F;\n        end\n      end\n      \n      E: begin\n        if (x) begin\n          next_state = F;\n        end else begin\n          next_state = A;\n        end\n      end\n      \n      F: begin\n        if (x) begin\n          next_state = A;\n        end else begin\n          next_state = B;\n        end\n      end\n    endcase\n  end\n  \n  // Output logic\n  always @ (state) begin\n    case (state)\n      A: Y = A;\n      B: Y = B;\n      C: Y = C;\n      D: Y = D;\n      E: Y = E;\n      F: Y = F;\n    endcase\n  end\n  \n  assign Y2 = Y[2];\n  assign Y4 = Y[4];\n  \nendmodule\n",
        "module_name": "state_machine",
        "module_hash": "9b6697b0f365edca6cc7c57e1d543002",
        "dataset_index": 5729
      },
      "LUT_SHIFT #_0cd58d51": {
        "rtl_code": "\nmodule LUT_SHIFT #(parameter P = 5) ( \n\ninput wire CLK, \ninput wire EN_ROM1,\ninput wire [4:0] ADRS,\noutput reg [P-1:0] O_D\n);\n   \nalways @(posedge CLK)\n      if (EN_ROM1)\n         case (ADRS)\n            5'b00000: O_D <= 5'b00001;\n            5'b00001: O_D <= 5'b00010;\n            5'b00010: O_D <= 5'b00011;\n            5'b00011: O_D <= 5'b00100;\n            5'b00100: O_D <= 5'b00100;\n            5'b00101: O_D <= 5'b00101;\n            5'b00110: O_D <= 5'b00110;\n            5'b00111: O_D <= 5'b00111;\n            5'b01000: O_D <= 5'b01000;\n            5'b01001: O_D <= 5'b01001;\n            5'b01010: O_D <= 5'b01010;\n            5'b01011: O_D <= 5'b01011;\n            5'b01100: O_D <= 5'b01100;\n            5'b01101: O_D <= 5'b01101;\n            5'b01110: O_D <= 5'b01101;\n            5'b01111: O_D <= 5'b01110;\n            5'b10000: O_D <= 5'b01111;\n            5'b10001: O_D <= 5'b10000;\n            5'b10010: O_D <= 5'b10001;\n            5'b10011: O_D <= 5'b10010;\n            5'b10100: O_D <= 5'b10011;\n            5'b10101: O_D <= 5'b10100;\n            5'b10110: O_D <= 5'b10101;\n            5'b10111: O_D <= 5'b10110;\n            5'b11000: O_D <= 5'b10111;\n            5'b11001: O_D <= 5'b11000;\n            5'b11010: O_D <= 5'b11001;\n            5'b11011: O_D <= 5'b11010;\n            5'b11100: O_D <= 5'b11011;\n            5'b11101: O_D <= 5'b11100;\n            5'b11110: O_D <= 5'b11101;\n            5'b11111: O_D <= 5'b11110;\n            default:  O_D <= 5'b00000;\n         endcase\t \n \nendmodule",
        "module_name": "LUT_SHIFT #",
        "module_hash": "0cd58d51982e09ac85e176410264e94e",
        "dataset_index": 21275
      },
      "and_gate_382d42e9": {
        "rtl_code": "module and_gate (\n    input  CLK  ,\n    input  D    ,\n    output Q    ,\n    output Q_N  ,\n    input  SCD  ,\n    input  SCE  ,\n    input  SET_B,\n    input  VPWR ,\n    input  VGND\n);\n\n    wire and_output;\n    \n    assign Q_N = ~Q;\n\n    assign and_output = D & SCD & SET_B & VPWR & VGND;\n\n    assign Q = SCE ? and_output : 1'b0;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "382d42e92358e410cefba91078aa0da0",
        "dataset_index": 6412
      },
      "TicTacToe_36f6f3b1": {
        "rtl_code": "module TicTacToe(\n    input clk,\n    input reset,\n    input player1_turn,\n    input player2_turn,\n    input [1:0] row,\n    input [1:0] column,\n    output reg game_over,\n    output reg [1:0] winner,\n    output reg tie,\n    output reg [8:0] board\n);\n\n    reg [1:0] current_player;\n    reg [8:0] game_board;\n    reg [1:0] row_index;\n    reg [1:0] col_index;\n    reg [2:0] winner_index;\n    reg [2:0] i;\n    reg [2:0] j;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            current_player <= 2'b00;\n            game_board <= 9'b000000000;\n            row_index <= 2'b00;\n            col_index <= 2'b00;\n            winner_index <= 3'b000;\n            i <= 3'b000;\n            j <= 3'b000;\n            game_over <= 1'b0;\n            winner <= 2'b00;\n            tie <= 1'b0;\n            board <= game_board;\n        end\n        else begin\n            // Update board if valid move\n            if ((player1_turn && current_player == 2'b00) || \n                (player2_turn && current_player == 2'b01)) begin\n                if (game_board[(row*3)+column] == 1'b0) begin\n                    game_board[(row*3)+column] <= current_player + 1'b1;\n                    board <= game_board;\n                end\n            end\n            \n            // Check for winner\n            for (i = 0; i < 3; i = i + 1) begin\n                // Check rows\n                winner_index <= {i, 3'b000};\n                if (game_board[(i*3)] == game_board[(i*3)+1] && \n                    game_board[(i*3)+1] == game_board[(i*3)+2] &&\n                    game_board[(i*3)] != 1'b0) begin\n                    game_over <= 1'b1;\n                    winner <= game_board[(i*3)] - 1'b1;\n                end\n                // Check columns\n                winner_index <= {3'b000, i};\n                if (game_board[i] == game_board[i+3] && \n                    game_board[i+3] == game_board[i+6] &&\n                    game_board[i] != 1'b0) begin\n                    game_over <= 1'b1;\n                    winner <= game_board[i] - 1'b1;\n                end\n            end\n            // Check diagonals\n            winner_index <= 3'b000;\n            if (game_board[0] == game_board[4] && \n                game_board[4] == game_board[8] &&\n                game_board[0] != 1'b0) begin\n                game_over <= 1'b1;\n                winner <= game_board[0] - 1'b1;\n            end\n            winner_index <= 3'b010;\n            if (game_board[2] == game_board[4] && \n                game_board[4] == game_board[6] &&\n                game_board[2] != 1'b0) begin\n                game_over <= 1'b1;\n                winner <= game_board[2] - 1'b1;\n            end\n            \n            // Check for tie\n            if (!game_over && !game_board[0] && !game_board[1] && !game_board[2] &&\n                !game_board[3] && !game_board[4] && !game_board[5] &&\n                !game_board[6] && !game_board[7] && !game_board[8]) begin\n                game_over <= 1'b1;\n                tie <= 1'b1;\n            end\n            \n            // Update current player\n            if (player1_turn && current_player == 2'b00) begin\n                current_player <= 2'b01;\n            end\n            else if (player2_turn && current_player == 2'b01) begin\n                current_player <= 2'b00;\n            end\n        end\n    end\nendmodule",
        "module_name": "TicTacToe",
        "module_hash": "36f6f3b16a5f29feb68cbd20ae427b9c",
        "dataset_index": 12982
      },
      "lo_read_a73c8777": {
        "rtl_code": "module lo_read(\n\tinput pck0, input [7:0] pck_cnt, input pck_divclk,\n\toutput pwr_lo, output pwr_hi,\n\toutput pwr_oe1, output pwr_oe2, output pwr_oe3, output pwr_oe4,\n\tinput [7:0] adc_d, output adc_clk,\n\toutput ssp_frame, output ssp_din, output ssp_clk,\n\toutput dbg,\n\tinput lf_field\n);\n\nreg [7:0] to_arm_shiftreg;\n\nalways @(posedge pck0)\nbegin\n\tif((pck_cnt == 8'd7) && !pck_divclk)\n\t\tto_arm_shiftreg <= adc_d;\n\telse begin\n\t\tto_arm_shiftreg[7:1] <= to_arm_shiftreg[6:0];\n\t\tto_arm_shiftreg[0] <= 1'b0;\n\tend\nend\n\nassign ssp_din = to_arm_shiftreg[7] && !pck_divclk;\nassign ssp_clk = pck0;\nassign ssp_frame = (pck_cnt[7:3] == 5'd1) && !pck_divclk;\nassign pwr_hi = 1'b0;\nassign pwr_oe1 = 1'b0;\nassign pwr_oe2 = 1'b0;\nassign pwr_oe3 = 1'b0;\nassign pwr_oe4 = 1'b0;\nassign pwr_lo = lf_field & pck_divclk;\nassign adc_clk = ~pck_divclk;\nassign dbg = adc_clk;\nendmodule\n",
        "module_name": "lo_read",
        "module_hash": "a73c8777c0d239a4e675e59bb6162ba4",
        "dataset_index": 25785
      },
      "xor_gate_08e6d49f": {
        "rtl_code": "\nmodule xor_gate(\n    input a,\n    input b,\n    output wire out\n);\n\n    assign out = a ^ b;\n\nendmodule\n\nmodule top_module(\n    input a, \n    input b,\n    output out_behavioral,\n    output out_structural\n);\n\n    // Behavioral approach\n    wire behavioral_out;\n    assign behavioral_out = a ^ b;\n    assign out_behavioral = behavioral_out;\n    \n    // Structural approach\n    xor_gate xor_inst(\n        .a(a),\n        .b(b),\n        .out(out_structural)\n    );\n\nendmodule\n",
        "module_name": "xor_gate",
        "module_hash": "08e6d49f6ed530b5516bec292b311eb0",
        "dataset_index": 17563
      },
      "barrel_shift_mux_41451a07": {
        "rtl_code": "module barrel_shift_mux (\n    input [31:0] A,\n    input [31:0] B,\n    input [31:0] C,\n    input [31:0] D,\n    input [4:0] shift_amount,\n    input SEL0,\n    input SEL1,\n    output reg [31:0] Y\n);\n\nreg [31:0] selected_input;\n\nalways @(*) begin\n    case ({SEL1, SEL0})\n        2'b00: selected_input = A;\n        2'b01: selected_input = B;\n        2'b10: selected_input = C;\n        2'b11: selected_input = D;\n    endcase\n    \n    if (shift_amount > 0) begin\n        Y = selected_input << shift_amount;\n    end else begin\n        Y = selected_input >> -shift_amount;\n    end\nend\n\nendmodule",
        "module_name": "barrel_shift_mux",
        "module_hash": "41451a0754be5345d8eb53ffaf0f6e82",
        "dataset_index": 2975
      },
      "binary_adder_9f3820e2": {
        "rtl_code": "module binary_adder(clk, rst_n, A, B, Cin, Sum, Cout);\n    input clk;\n    input rst_n;\n    input [15:0] A, B;\n    input Cin;\n    output [15:0] Sum;\n    output Cout;\n\n    reg [16:0] sum_reg;\n    reg Cout_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            sum_reg <= 17'd0;\n            Cout_reg <= 1'b0;\n        end\n        else begin\n            sum_reg <= A + B + Cin;\n            Cout_reg <= (sum_reg[16] == 1) ? 1'b1 : 1'b0;\n        end\n    end\n\n    assign Sum = sum_reg[16:0];\n    assign Cout = Cout_reg;\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "9f3820e268364ebadeb532c0289f2f49",
        "dataset_index": 4054
      },
      "shift_register_9aa2a06c": {
        "rtl_code": "module shift_register (\n  input clk,\n  input reset,\n  input clear,\n  input [7:0] data_in,\n  output [7:0] data_out\n);\n\n  reg [7:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shift_reg <= 8'b0;\n    end else if (clear) begin\n      shift_reg <= 8'b11111111;\n    end else begin\n      shift_reg <= {shift_reg[6:0], data_in};\n    end\n  end\n  \n  assign data_out = shift_reg;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "9aa2a06c3fe986bc0f24cf3048b98d0b",
        "dataset_index": 14962
      },
      "and_gate_f7daa1c4": {
        "rtl_code": "module and_gate(a, b, c);\n    input [3:0] a, b;\n    output [3:0] c;\n\n    assign c = a & b;\nendmodule",
        "module_name": "and_gate",
        "module_hash": "f7daa1c4118199e24a63d5f3bf3f7c67",
        "dataset_index": 16716
      },
      "mux_pipeline_505c8c07": {
        "rtl_code": "\nmodule mux_pipeline (\n    input [3:0] IN,\n    input [1:0] SEL,\n    input EN,\n    input clk,\n    output reg out\n);\n\nreg [3:0] reg_IN;\nreg [1:0] reg_SEL;\nreg reg_EN;\n\nalways @(posedge clk) begin\n    reg_IN <= IN;\n    reg_SEL <= SEL;\n    reg_EN <= EN;\nend\n\nalways @* begin\n    if (reg_EN) begin\n        case (reg_SEL)\n            2'b00: out = reg_IN[0];\n            2'b01: out = reg_IN[1];\n            2'b10: out = reg_IN[2];\n            2'b11: out = reg_IN[3];\n        endcase\n    end else begin\n        out = 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "mux_pipeline",
        "module_hash": "505c8c07e246c17631b06cff60b8763a",
        "dataset_index": 4668
      },
      "shift_register_312704fb": {
        "rtl_code": "\nmodule shift_register (\n    input CLK,\n    input SHIFT,\n    input LOAD,\n    input [15:0] DATA_IN,\n    input mode,\n    output [15:0] DATA_OUT\n);\n\n    reg [15:0] shift_reg [0:3];\n    reg [3:0] shift_cnt;\n    wire [15:0] shift_data;\n\n    assign shift_data = (mode) ? 16'hFFFF : 16'h0000;\n\n    always @(posedge CLK) begin\n        if (LOAD) begin\n            shift_reg[0] <= DATA_IN;\n            shift_reg[1] <= shift_data;\n            shift_reg[2] <= shift_data;\n            shift_reg[3] <= shift_data;\n            shift_cnt <= 0;\n        end\n        else if (SHIFT) begin\n            shift_reg[0] <= shift_reg[1];\n            shift_reg[1] <= shift_reg[2];\n            shift_reg[2] <= shift_reg[3];\n            shift_reg[3] <= shift_data;\n            shift_cnt <= shift_cnt + 1;\n        end\n    end\n\n    assign DATA_OUT = shift_reg[shift_cnt];\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "312704fbaa83524f818ea125d61fd998",
        "dataset_index": 16499
      },
      "top__7f955e15": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input wire [15:0] in,\n    input [7:0] in_edge,\n    output wire anyedge\n);\n\n    wire [7:0] upper_byte;\n    wire [7:0] lower_byte;\n    wire upper_edge;\n    wire lower_edge;\n\n    // Split input into upper and lower bytes\n    byte_splitter byte_splitter_inst (\n        .in(in),\n        .upper_byte(upper_byte),\n        .lower_byte(lower_byte)\n    );\n\n    // Detect edge transitions in upper and lower bytes\n    edge_detector edge_detector_upper_inst (\n        .clk(clk),\n        .in(upper_byte),\n        .out(upper_edge)\n    );\n\n    edge_detector edge_detector_lower_inst (\n        .clk(clk),\n        .in(lower_byte),\n        .out(lower_edge)\n    );\n\n    // Combine edge transitions from upper and lower bytes\n    or_gate or_gate_inst (\n        .in1(upper_edge),\n        .in2(lower_edge),\n        .out(anyedge)\n    );\n\n    // Output any edge transition\n    assign anyedge = anyedge;\n\nendmodule\nmodule byte_splitter (\n    input wire [15:0] in,\n    output reg [7:0] upper_byte,\n    output reg [7:0] lower_byte\n);\n\n    always @(*) begin\n        upper_byte = in[15:8];\n        lower_byte = in[7:0];\n    end\n\nendmodule\nmodule edge_detector (\n    input clk,\n    input [7:0] in,\n    output reg out\n);\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        if (in != prev_in) begin\n            out <= 1;\n        end else begin\n            out <= 0;\n        end\n        prev_in <= in;\n    end\n\nendmodule\nmodule or_gate (\n    input wire in1,\n    input wire in2,\n    output reg out\n);\n\n    always @(*) begin\n        out = in1 | in2;\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "7f955e1530ad6f423ea06fa4a14e0f95",
        "dataset_index": 19570
      },
      "top__198a9284": {
        "rtl_code": "\nmodule top_module (\n    input [1:0] in,    // Input for the 2-to-4 decoder\n    input [3:0] a,    // Input A for the adder-subtractor\n    input [3:0] b,    // Input B for the adder-subtractor\n    input sub,         // Subtraction flag for the adder-subtractor\n    output [3:0] q,    // Output from the functional module\n    output overflow   // Overflow output from the adder-subtractor\n);\n\n    // 2-to-4 decoder module\n    wire [3:0] dec_out;\n    decoder_2to4 dec(\n        .in(in),\n        .out(dec_out)\n    );\n\n    // Adder-subtractor module\n    wire [3:0] addsub_out;\n    wire addsub_overflow;\n    adder_subtractor addsub(\n        .a(a),\n        .b(b),\n        .sub(sub),\n        .q(addsub_out),\n        .overflow(addsub_overflow)\n    );\n\n    // Functional module\n    assign q = (dec_out[0] == 1'b0) ? addsub_out : 4'b0;\n    assign overflow = (dec_out[0] == 1'b0) ? addsub_overflow : (dec_out[1] || dec_out[2] || dec_out[3]);\n\nendmodule\nmodule decoder_2to4 (\n    input [1:0] in,    // Input for the 2-to-4 decoder\n    output [3:0] out   // Output from the 2-to-4 decoder\n);\n\n    assign out[0] = ~in[0] & ~in[1];\n    assign out[1] = ~in[0] &  in[1];\n    assign out[2] =  in[0] & ~in[1];\n    assign out[3] =  in[0] &  in[1];\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] a,    // Input A for the adder-subtractor\n    input [3:0] b,    // Input B for the adder-subtractor\n    input sub,         // Subtraction flag for the adder-subtractor\n    output [3:0] q,    // Output from the adder-subtractor\n    output overflow   // Overflow output from the adder-subtractor\n);\n\n    // Intermediate sum\n    wire [4:0] sum = (sub) ? (a - b) : (a + b);\n    \n    // Assign q and overflow\n    assign q = sum[3:0];\n    assign overflow = sum[4];\n\nendmodule",
        "module_name": "top_",
        "module_hash": "198a9284a6de58ce919e21d49103cf7b",
        "dataset_index": 355
      },
      "serializer #_7d5a908c": {
        "rtl_code": "\n\nmodule serializer #(\n\tparameter LOG_DWIDTH=7,\n\tparameter DWIDTH=64\n)\n(\n\tinput wire clk,\n\tinput wire fast_clk,\n\tinput wire [DWIDTH-1:0] data_in,\n\toutput wire data_out\n);\n\nreg [DWIDTH-1:0] buffer;\n\nalways @ (posedge clk)\nbegin\n\tbuffer <= data_in;\nend\n\nreg [LOG_DWIDTH-1:0] curr_bit = 'h0;\nreg clk_d1;\n\nalways @ (posedge fast_clk)\nbegin\n\tcurr_bit <= curr_bit + 1;\n\tclk_d1 <= clk;\n\tif (!clk_d1 && clk)\n\t\tcurr_bit <= 0;\nend\n\nassign data_out = buffer[curr_bit];\n\nendmodule\n\n",
        "module_name": "serializer #",
        "module_hash": "7d5a908c9903d37a6cc0156633a3d443",
        "dataset_index": 23493
      },
      "low_pass_filter_ab9bd05c": {
        "rtl_code": "module low_pass_filter(\n  input wire slowest_sync_clk,\n  input wire dcm_locked,\n  input wire ext_reset_in,\n  input wire mb_debug_sys_rst,\n  input wire aux_reset_in,\n  output reg [4:0] lpf_int\n);\n\n  // Synchronize input signals to slowest_sync_clk domain\n  reg sync_ext_reset_in, sync_mb_debug_sys_rst, sync_aux_reset_in, sync_dcm_locked;\n  always @(posedge slowest_sync_clk) begin\n    sync_ext_reset_in <= ext_reset_in;\n    sync_mb_debug_sys_rst <= mb_debug_sys_rst;\n    sync_aux_reset_in <= aux_reset_in;\n    sync_dcm_locked <= dcm_locked;\n  end\n  \n  // Combine reset signals\n  reg sync_reset;\n  always @(posedge slowest_sync_clk) begin\n    if (sync_ext_reset_in || sync_mb_debug_sys_rst || sync_aux_reset_in) begin\n      sync_reset <= 1'b1;\n    end else begin\n      sync_reset <= 1'b0;\n    end\n  end\n  \n  // Implement low-pass filter\n  reg [15:0] shift_reg;\n  reg [15:0] sum;\n  always @(posedge slowest_sync_clk) begin\n    if (sync_reset) begin\n      shift_reg <= 16'h0000;\n      sum <= 16'h0000;\n    end else begin\n      shift_reg <= {shift_reg[14:0], sync_dcm_locked};\n      sum <= sum + sync_dcm_locked - shift_reg[0];\n    end\n  end\n  always @* lpf_int = sum[4:0];\n  \nendmodule",
        "module_name": "low_pass_filter",
        "module_hash": "ab9bd05c40159513bc7f86c5d832bc72",
        "dataset_index": 9337
      },
      "rotator_2458640c": {
        "rtl_code": "\nmodule rotator (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] out\n);\n\nreg [99:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n    end else begin\n        case (ena)\n            2'b00: shift_reg <= {shift_reg[98:0], shift_reg[99]};\n            2'b01: shift_reg <= {shift_reg[1:0], shift_reg[99:2]};\n            2'b10: shift_reg <= {shift_reg[0], shift_reg[99:1]};\n            2'b11: shift_reg <= shift_reg;\n        endcase\n    end\nend\n\nassign out = shift_reg;\n\nendmodule\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg out\n);\n\nreg [31:0] in_reg;\nreg [31:0] in_delayed;\n\nalways @(posedge clk or negedge reset) begin\n    if (!reset) begin\n        in_reg <= 0;\n        in_delayed <= 0;\n        out <= 0;\n    end else begin\n        in_reg <= in;\n        in_delayed <= in_reg;\n        out <= (in_reg ^ in_delayed) & in_reg;\n    end\nend\n\nendmodule\nmodule functional_module (\n    input [99:0] rotator_out,\n    input transition_detector_out,\n    output [131:0] out\n);\n\nassign out = {rotator_out, {30{transition_detector_out}}, transition_detector_out};\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    input [31:0] in,\n    output [131:0] out\n);\n\nwire [99:0] rotator_out;\nwire transition_detector_out;\n\nrotator rotator_inst (\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .out(rotator_out)\n);\n\ntransition_detector transition_detector_inst (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(transition_detector_out)\n);\n\nfunctional_module functional_module_inst (\n    .rotator_out(rotator_out),\n    .transition_detector_out(transition_detector_out),\n    .out(out)\n);\n\nendmodule",
        "module_name": "rotator",
        "module_hash": "2458640c375b7df1d8df4baf848c346f",
        "dataset_index": 8900
      },
      "switch_bit_eb0df2dd": {
        "rtl_code": "\nmodule switch_bit(\n    input wire [3:0] gpio_sel,\n    output wire [7:0] tri_i_in,\n    input wire [7:0] tri_o_in,\n    input wire [7:0] tri_t_in,\n    input wire tri_i_out,\n    output reg tri_o_out,\n    output reg tri_t_out,\n    output wire  pwm_i_in,\n    input wire  pwm_o_in,\n    input wire  pwm_t_in,\n    output wire  cap0_i_in,\n    input wire  gen0_o_in,\n    input wire  gen0_t_in,\n    output wire  spick_i_in,\n    input wire  spick_o_in,\n    input wire  spick_t_in,\n    output wire  miso_i_in,\n    input wire  miso_o_in,\n    input wire  miso_t_in,\n    output wire  mosi_i_in,\n    input wire  mosi_o_in,\n    input wire  mosi_t_in,\n    output wire  ss_i_in,\n    input wire  ss_o_in,\n    input wire  ss_t_in,\n    output wire  sda_i_in,\n    input wire  sda_o_in,\n    input wire  sda_t_in,\n    output wire  scl_i_in,\n    input wire  scl_o_in,\n    input wire  scl_t_in\n    );\n    \n    reg [15:0] tri_i_out_demux;\n    assign {cap0_i_in,pwm_i_in,ss_i_in,mosi_i_in,miso_i_in,spick_i_in,sda_i_in,scl_i_in,tri_i_in} = tri_i_out_demux;\n\n    always @(gpio_sel, tri_o_in, scl_o_in, sda_o_in, spick_o_in, miso_o_in, mosi_o_in, ss_o_in, pwm_o_in, gen0_o_in)\n       case (gpio_sel)\n          4'h0: tri_o_out = tri_o_in[0];\n          4'h1: tri_o_out = tri_o_in[1];\n          4'h2: tri_o_out = tri_o_in[2];\n          4'h3: tri_o_out = tri_o_in[3];\n          4'h4: tri_o_out = tri_o_in[4];\n          4'h5: tri_o_out = tri_o_in[5];\n          4'h6: tri_o_out = tri_o_in[6];\n          4'h7: tri_o_out = tri_o_in[7];\n          4'h8: tri_o_out = scl_o_in;\n          4'h9: tri_o_out = sda_o_in;\n          4'hA: tri_o_out = spick_o_in;\n          4'hB: tri_o_out = miso_o_in;\n          4'hC: tri_o_out = mosi_o_in;\n          4'hD: tri_o_out = ss_o_in;\n          4'hE: tri_o_out = pwm_o_in;\n          4'hF: tri_o_out = gen0_o_in;\n          default: tri_o_out = 1'b0;\n       endcase\n\n    always @(gpio_sel, tri_i_out)\n    begin\n       tri_i_out_demux = {16{1'b0}};\n       case (gpio_sel)\n          4'h0: tri_i_out_demux[0] = tri_i_out;\n          4'h1: tri_i_out_demux[1] = tri_i_out;\n          4'h2: tri_i_out_demux[2] = tri_i_out;\n          4'h3: tri_i_out_demux[3] = tri_i_out;\n          4'h4: tri_i_out_demux[4] = tri_i_out;\n          4'h5: tri_i_out_demux[5] = tri_i_out;\n          4'h6: tri_i_out_demux[6] = tri_i_out;\n          4'h7: tri_i_out_demux[7] = tri_i_out;\n          4'h8: tri_i_out_demux[8] = tri_i_out;\n          4'h9: tri_i_out_demux[9] = tri_i_out;\n          4'hA: tri_i_out_demux[10] = tri_i_out;\n          4'hB: tri_i_out_demux[11] = tri_i_out;\n          4'hC: tri_i_out_demux[12] = tri_i_out;\n          4'hD: tri_i_out_demux[13] = tri_i_out;\n          4'hE: tri_i_out_demux[14] = tri_i_out;\n          4'hF: tri_i_out_demux[15] = tri_i_out;\n       endcase\n    end\n\n    always @(gpio_sel, tri_t_in, scl_t_in, sda_t_in, spick_t_in, miso_t_in, mosi_t_in, ss_t_in, pwm_t_in, gen0_t_in)\n       case (gpio_sel)\n          4'h0: tri_t_out = tri_t_in[0];\n          4'h1: tri_t_out = tri_t_in[1];\n          4'h2: tri_t_out = tri_t_in[2];\n          4'h3: tri_t_out = tri_t_in[3];\n          4'h4: tri_t_out = tri_t_in[4];\n          4'h5: tri_t_out = tri_t_in[5];\n          4'h6: tri_t_out = tri_t_in[6];\n          4'h7: tri_t_out = tri_t_in[7];\n          4'h8: tri_t_out = scl_t_in;\n          4'h9: tri_t_out = sda_t_in;\n          4'hA: tri_t_out = spick_t_in;\n          4'hB: tri_t_out = miso_t_in;\n          4'hC: tri_t_out = mosi_t_in;\n          4'hD: tri_t_out = ss_t_in;\n          4'hE: tri_t_out = pwm_t_in;\n          4'hF: tri_t_out = gen0_t_in;\n          default: tri_t_out = 1'b0;\n       endcase\n\nendmodule\n",
        "module_name": "switch_bit",
        "module_hash": "eb0df2dd37bfc3e7949fb3a828ec7bea",
        "dataset_index": 25167
      },
      "dc_rep_upload_98cb2d16": {
        "rtl_code": "module   dc_rep_upload(clk,\n                          rst,\n                          dc_flits_rep,\n                          v_dc_flits_rep,\n                          flits_max,\n                          en_flits_max,\n                          rep_fifo_rdy,\n                          dc_flit_out,\n                          v_dc_flit_out,\n\t\t\t\t\t\t\t\t  dc_ctrl_out,\n                          dc_rep_upload_state\n                          );\ninput                          clk;\ninput                          rst;\ninput         [175:0]          dc_flits_rep;\ninput                          v_dc_flits_rep;\ninput         [3:0]            flits_max;\ninput                          en_flits_max;\ninput                          rep_fifo_rdy;\n                          output        [15:0]            dc_flit_out;\noutput                          v_dc_flit_out;\noutput       [1:0]              dc_ctrl_out;\noutput                          dc_rep_upload_state;\n\nparameter    dc_rep_upload_idle=1'b0;\nparameter    dc_rep_upload_busy=1'b1;\n\nreg          dc_rep_state;\nreg  [175:0]  dc_rep_flits;\nreg  [3:0]   sel_cnt;\nreg          v_dc_flit_out;\nreg          fsm_rst;\nreg          next;\nreg          en_flits_in;\nreg          inc_cnt;\nreg  [3:0]   flits_max_reg;\nreg  [1:0]   dc_ctrl_out;\nassign dc_rep_upload_state=dc_rep_state;\nalways@(*)\nbegin\n  v_dc_flit_out=1'b0;\n  inc_cnt=1'b0;\n  fsm_rst=1'b0;\n  en_flits_in=1'b0;\n  next=1'b0;\n  dc_ctrl_out=2'b00;\n  case(dc_rep_state)\n    dc_rep_upload_idle:\n       begin\n         if(v_dc_flits_rep)\n           begin\n             en_flits_in=1'b1;\n             next=1'b1;\n           end\n       end\n    dc_rep_upload_busy:\n       begin\n         if(rep_fifo_rdy)\n           begin\n             if(sel_cnt==flits_max_reg)\n\t\t\t\t  begin\n               fsm_rst=1'b1;\n\t\t\t\t\tdc_ctrl_out=2'b11;\n\t\t\t\t\tend\n\t\t\t\telse if(sel_cnt==3'b000)\n\t\t\t\t    dc_ctrl_out=2'b01;\n\t\t\t\telse \t \n\t\t\t\t    dc_ctrl_out=2'b10;\n             inc_cnt=1'b1;\n             v_dc_flit_out=1'b1;\n           end\n       end\n    endcase\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    dc_rep_state<=1'b0;\nelse if(next)\n    dc_rep_state<=1'b1;\nend\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    dc_rep_flits<=176'h0000;\n  else if(en_flits_in)\n    dc_rep_flits<=dc_flits_rep;\nend\nreg  [15:0]  dc_flit_out;\nalways@(*)\nbegin\n  case(sel_cnt)\n    4'b0000:dc_flit_out=dc_rep_flits[175:160];\n    4'b0001:dc_flit_out=dc_rep_flits[159:144];\n    4'b0010:dc_flit_out=dc_rep_flits[143:128];\n    4'b0011:dc_flit_out=dc_rep_flits[127:112];\n    4'b0100:dc_flit_out=dc_rep_flits[111:96];\n    4'b0101:dc_flit_out=dc_rep_flits[95:80];\n    4'b0110:dc_flit_out=dc_rep_flits[79:64];\n    4'b0111:dc_flit_out=dc_rep_flits[63:48];\n    4'b1000:dc_flit_out=dc_rep_flits[47:32];\n    4'b1001:dc_flit_out=dc_rep_flits[31:16];\n    4'b1010:dc_flit_out=dc_rep_flits[15:0];\n    default:dc_flit_out=dc_rep_flits[175:160];\n  endcase\nend\n\nalways@(posedge  clk)\nbegin\n  if(rst||fsm_rst)\n    flits_max_reg<=4'b0000;\n  else if(en_flits_max)\n    flits_max_reg<=flits_max;\nend\n    \nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    sel_cnt<=4'b0000;\n  else if(inc_cnt)\n    sel_cnt<=sel_cnt+4'b0001;\nend\n\nendmodule",
        "module_name": "dc_rep_upload",
        "module_hash": "98cb2d16e81819c21dc370938fac08c2",
        "dataset_index": 23198
      },
      "LCD_control_cf731c0a": {
        "rtl_code": "module LCD_control(\n    input [7:0] iRed,\n    input [7:0] iGreen,\n    input [7:0] iBlue,\n    output [9:0] oCurrent_X,    output [9:0] oCurrent_Y,    output [21:0] oAddress,     output oRequest,            output reg oTopOfScreen,    output [7:0] oLCD_R,\n    output [7:0] oLCD_G,\n    output [7:0] oLCD_B,\n    output reg oLCD_HS,   output reg oLCD_VS,   output oLCD_DE,   input iCLK,\n    input iRST_N\n);\n\nreg         [10:0]  H_Cont;\nreg         [10:0]  V_Cont;\nparameter   H_FRONT =   24;\nparameter   H_SYNC  =   72;\nparameter   H_BACK  =   96;\nparameter   H_ACT   =   800;\nparameter   H_BLANK =   H_FRONT+H_SYNC+H_BACK;\nparameter   H_TOTAL =   H_FRONT+H_SYNC+H_BACK+H_ACT;\nparameter   V_FRONT =   3;\nparameter   V_SYNC  =   10;\nparameter   V_BACK  =   7;\nparameter   V_ACT   =   480;\nparameter   V_BLANK =   V_FRONT+V_SYNC+V_BACK;\nparameter   V_TOTAL =   V_FRONT+V_SYNC+V_BACK+V_ACT;\nassign  oLCD_R      =   oRequest ? iRed : 8'b0 ;\nassign  oLCD_G      =   oRequest ? iGreen : 8'b0 ;\nassign  oLCD_B      =   oRequest ? iBlue : 8'b0 ;\nassign  oAddress    =   oCurrent_Y*H_ACT + oCurrent_X;\nassign  oRequest    =   H_Cont >= H_BLANK && V_Cont >= V_BLANK;\nassign  oCurrent_X  =   (H_Cont>=H_BLANK) ? H_Cont-H_BLANK : 11'h0;\nassign  oCurrent_Y  =   (V_Cont>=V_BLANK) ? V_Cont-V_BLANK : 11'h0;\nassign  oLCD_DE     =   oRequest;\n\n\nwire oTopOfScreenNext = H_Cont == 0 && V_Cont == 0;\nalways @(posedge iCLK)\nbegin\n    oTopOfScreen <= oTopOfScreenNext;\nend\n\nalways @(posedge iCLK or negedge iRST_N)\nbegin\n    if (!iRST_N) begin\n        H_Cont <= 0;\n        oLCD_HS <= 1;\n    end else begin\n        if (H_Cont < H_TOTAL - 1) begin\n            H_Cont <= H_Cont + 1'b1;\n        end else begin\n            H_Cont <= 0;\n        end\n\n        if (H_Cont == H_FRONT - 1) begin\n            oLCD_HS <= 1'b0;\n        end\n        if (H_Cont == H_FRONT + H_SYNC - 1) begin\n            oLCD_HS <= 1'b1;\n        end\n    end\nend\n\nalways @(posedge iCLK or negedge iRST_N)\nbegin\n    if (!iRST_N) begin\n        V_Cont <= 0;\n        oLCD_VS <= 1;\n    end else if (H_Cont == 0) begin\n        if (V_Cont < V_TOTAL-1) begin\n            V_Cont <= V_Cont+1'b1;\n        end else begin\n            V_Cont <= 0;\n        end\n\n        if (V_Cont == V_FRONT - 1) begin\n            oLCD_VS <= 1'b0;\n        end\n        if (V_Cont == V_FRONT + V_SYNC - 1) begin\n            oLCD_VS <= 1'b1;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "LCD_control",
        "module_hash": "cf731c0aacfce3950e3838e0dbed0363",
        "dataset_index": 16895
      },
      "top_module_6c505f7b": {
        "rtl_code": "module top_module( \n    input a, b, c, // Three bits to be added\n    input select, // Select input to choose between two half adder modules\n    output [2:0] sum // 3-bit output from the active module\n);\n\n    wire ha1_cout, ha1_sum, ha2_cout, ha2_sum;\n    wire [1:0] ha_sel;\n\n    // Control logic module to select between two half adder modules\n    assign ha_sel = select ? 2'b10 : 2'b01;\n\n    // First half adder module to add the first two bits\n    half_adder ha1(\n        .a(a),\n        .b(b),\n        .cout(ha1_cout),\n        .sum(ha1_sum)\n    );\n\n    // Second half adder module to add the result with the third input bit\n    half_adder ha2(\n        .a(ha_sel[0] ? ha1_sum : ha1_cout),\n        .b(c),\n        .cout(ha2_cout),\n        .sum(ha2_sum)\n    );\n\n    // Final sum module to output the sum of the three bits\n    final_sum fs(\n        .cin(ha_sel[1] ? ha2_cout : ha1_cout),\n        .sum(ha2_sum),\n        .out(sum)\n    );\n\nendmodule\n\nmodule half_adder(\n    input a, b,\n    output cout, sum // Carry-out and sum outputs\n);\n\n    assign {cout, sum} = a + b;\n\nendmodule\n\nmodule final_sum(\n    input cin, sum,\n    output [2:0] out // 3-bit output\n);\n\n    assign out = {cin, sum};\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "6c505f7b02520a1d2e8b36ded7311a0b",
        "dataset_index": 7250
      },
      "gray_counter_58ab64f8": {
        "rtl_code": "module gray_counter (\n    input clk,      // Clock input\n    input reset,    // Synchronous active-low reset\n    output reg [3:0] gray_count   // 4-bit Gray counter output\n);\n\n    reg [3:0] binary_count;\n\n    always @(posedge clk, negedge reset) begin\n        if (!reset) begin\n            binary_count <= 4'b0000;\n        end else begin\n            binary_count <= binary_count + 1;\n        end\n    end\n\n    always @* begin\n        case (binary_count)\n            4'b0000: gray_count = 4'b0000;\n            4'b0001: gray_count = 4'b0001;\n            4'b0011: gray_count = 4'b0011;\n            4'b0010: gray_count = 4'b0010;\n            4'b0110: gray_count = 4'b0110;\n            4'b0111: gray_count = 4'b0111;\n            4'b0101: gray_count = 4'b0101;\n            4'b0100: gray_count = 4'b0100;\n            4'b1100: gray_count = 4'b1100;\n            4'b1101: gray_count = 4'b1101;\n            4'b1111: gray_count = 4'b1111;\n            4'b1110: gray_count = 4'b1110;\n            4'b1010: gray_count = 4'b1010;\n            4'b1011: gray_count = 4'b1011;\n            4'b1001: gray_count = 4'b1001;\n            4'b1000: gray_count = 4'b1000;\n            default: gray_count = 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule combinatorial_circuit (\n    input [7:0] in_hi,      // Upper byte input\n    input [7:0] in_lo,      // Lower byte input\n    output reg [15:0] out   // 16-bit output\n);\n\n    always @* begin\n        out = {in_hi, in_lo};\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-low reset\n    input [7:0] in_hi,      // Upper byte input\n    input [7:0] in_lo,      // Lower byte input\n    output reg [19:0] out   // 20-bit output\n);\n\n    wire [3:0] gray_count;\n    wire [15:0] comb_out;\n\n    gray_counter gray_inst (\n        .clk(clk),\n        .reset(reset),\n        .gray_count(gray_count)\n    );\n\n    combinatorial_circuit comb_inst (\n        .in_hi(in_hi),\n        .in_lo(in_lo),\n        .out(comb_out)\n    );\n\n    always @(posedge clk, negedge reset) begin\n        if (!reset) begin\n            out <= 20'b00000000000000000000;\n        end else begin\n            out <= {comb_out, gray_count};\n        end\n    end\n\nendmodule",
        "module_name": "gray_counter",
        "module_hash": "58ab64f85db6f0cd784b02123da6ad1f",
        "dataset_index": 15503
      },
      "karnaugh_map_dcfc7559": {
        "rtl_code": "module karnaugh_map(\n  input wire A, B, C, D, // 4-bit input variables\n  output reg F // 1-bit output variable\n);\n\n  always @(*) begin\n    case ({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0010: F = 1'b0;\n      4'b0011: F = 1'b1;\n      4'b0110: F = 1'b1;\n      4'b0111: F = 1'b0;\n      4'b1110: F = 1'b1;\n      4'b1111: F = 1'b0;\n      default: F = 1'b0;\n    endcase\n  end\n\nendmodule",
        "module_name": "karnaugh_map",
        "module_hash": "dcfc75596b1f7e3acf3e9afe31c1a796",
        "dataset_index": 3568
      },
      "shift_register_7f6b1376": {
        "rtl_code": "module shift_register(input clk, input d, output q);\n  reg [2:0] reg_data;\n  reg q_out;\n  \n  always @(posedge clk) begin\n    reg_data <= {reg_data[1:0], d};\n    q_out <= reg_data[2];\n  end\n  \n  assign q = q_out;\nendmodule",
        "module_name": "shift_register",
        "module_hash": "7f6b1376c6d7fc6c580e026276d695d0",
        "dataset_index": 3795
      },
      "mux_d13e9657": {
        "rtl_code": "module mux(input ctrl, input [0:0] D0, input [0:0] D1, output [0:0] S);\n  wire [0:0] D0_wire;\n  wire [0:0] D1_wire;\n  wire [0:0] S_wire;\n  wire ctrl_wire;\n\n  assign D0_wire[0] = D0[0];\n  assign D1_wire[0] = D1[0];\n\n  assign S[0] = S_wire[0];\n\n  assign ctrl_wire = ctrl;\n\n  assign S_wire[0] = (ctrl_wire) ? D1_wire[0] : D0_wire[0];\nendmodule",
        "module_name": "mux",
        "module_hash": "d13e9657b285e6140ca7738b5fabfd8e",
        "dataset_index": 13418
      },
      "pcie_7x_v1_8_gtp_pipe_reset #_74314d89": {
        "rtl_code": "\n\n\n\nmodule pcie_7x_v1_8_gtp_pipe_reset #\n(\n\n    parameter PCIE_TXBUF_EN     = \"FALSE\",                  parameter PCIE_LANE         = 1,                        parameter CFG_WAIT_MAX      = 6'd63,                    parameter BYPASS_RXCDRLOCK  = 1                         )\n\n(\n\n    input                           RST_CLK,\n    input                           RST_RXUSRCLK,\n    input                           RST_DCLK,\n    input                           RST_RST_N,\n    input                           RST_PLLLOCK,\n    input       [PCIE_LANE-1:0]     RST_RATE_IDLE,\n    input       [PCIE_LANE-1:0]     RST_RXCDRLOCK,\n    input                           RST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     RST_RESETDONE,\n    input       [PCIE_LANE-1:0]     RST_PHYSTATUS,\n    input       [PCIE_LANE-1:0]     RST_TXSYNC_DONE,\n    \n    output                          RST_CPLLRESET,\n    output                          RST_CPLLPD,\n    output                          RST_RXUSRCLK_RESET,\n    output                          RST_DCLK_RESET,\n    output                          RST_GTRESET,\n    output                          RST_USERRDY,\n    output                          RST_TXSYNC_START,\n    output                          RST_IDLE,\n    output      [10:0]              RST_FSM\n\n);\n\n    reg                             plllock_reg1;\n    reg         [PCIE_LANE-1:0]     rate_idle_reg1;\n    reg         [PCIE_LANE-1:0]     rxcdrlock_reg1;\n    reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     resetdone_reg1;\n    reg         [PCIE_LANE-1:0]     phystatus_reg1;\n    reg         [PCIE_LANE-1:0]     txsync_done_reg1;  \n    \n    reg                             plllock_reg2;\n    reg         [PCIE_LANE-1:0]     rate_idle_reg2;\n    reg         [PCIE_LANE-1:0]     rxcdrlock_reg2;\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     resetdone_reg2;\n    reg         [PCIE_LANE-1:0]     phystatus_reg2;\n    reg         [PCIE_LANE-1:0]     txsync_done_reg2;\n    \n    reg         [ 5:0]              cfg_wait_cnt      =  6'd0;\n    \n    reg                             pllreset         =  1'd0;\n    reg                             pllpd            =  1'd0;\n    reg                             rxusrclk_rst_reg1 =  1'd0;\n    reg                             rxusrclk_rst_reg2 =  1'd0;\n    reg                             dclk_rst_reg1     =  1'd0;\n    reg                             dclk_rst_reg2     =  1'd0;\n    reg                             gtreset           =  1'd0;\n    reg                             userrdy           =  1'd0;\n    reg         [10:0]              fsm               = 11'd2;                 \n   \n    localparam                      FSM_IDLE          = 9'b000000001; \n    localparam                      FSM_CFG_WAIT      = 9'b000000010;\n    localparam                      FSM_PLLRESET      = 9'b000000100;     \n    localparam                      FSM_PLLLOCK       = 9'b000001000;\n    localparam                      FSM_GTRESET       = 9'b000010000;                      \n    localparam                      FSM_MMCM_LOCK     = 9'b000100000;  \n    localparam                      FSM_RESETDONE     = 9'b001000000;  \n    localparam                      FSM_TXSYNC_START  = 9'b010000000;\n    localparam                      FSM_TXSYNC_DONE   = 9'b100000000;                                 \n\n    \n\nalways @ (posedge RST_CLK)\nbegin\n\n    if (!RST_RST_N)\n        begin    \n        plllock_reg1     <= 1'd0; \n        rate_idle_reg1   <= {PCIE_LANE{1'd0}}; \n        rxcdrlock_reg1   <= {PCIE_LANE{1'd0}}; \n        mmcm_lock_reg1   <= 1'd0; \n        resetdone_reg1   <= {PCIE_LANE{1'd0}}; \n        phystatus_reg1   <= {PCIE_LANE{1'd0}}; \n        txsync_done_reg1 <= {PCIE_LANE{1'd0}}; \n        plllock_reg2     <= 1'd0; \n        rate_idle_reg2   <= {PCIE_LANE{1'd0}}; \n        rxcdrlock_reg2   <= {PCIE_LANE{1'd0}}; \n        mmcm_lock_reg2   <= 1'd0;\n        resetdone_reg2   <= {PCIE_LANE{1'd0}}; \n        phystatus_reg2   <= {PCIE_LANE{1'd0}}; \n        txsync_done_reg2 <= {PCIE_LANE{1'd0}}; \n        end\n    else\n        begin  \n        plllock_reg1     <= RST_PLLLOCK;\n        rate_idle_reg1   <= RST_RATE_IDLE;\n        rxcdrlock_reg1   <= RST_RXCDRLOCK;\n        mmcm_lock_reg1   <= RST_MMCM_LOCK;\n        resetdone_reg1   <= RST_RESETDONE;\n        phystatus_reg1   <= RST_PHYSTATUS;\n        txsync_done_reg1 <= RST_TXSYNC_DONE;\n        plllock_reg2     <= plllock_reg1;\n        rate_idle_reg2   <= rate_idle_reg1;\n        rxcdrlock_reg2   <= rxcdrlock_reg1;\n        mmcm_lock_reg2   <= mmcm_lock_reg1;\n        resetdone_reg2   <= resetdone_reg1;\n        phystatus_reg2   <= phystatus_reg1;\n        txsync_done_reg2 <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\nalways @ (posedge RST_CLK)\nbegin\n\n    if (!RST_RST_N)\n        cfg_wait_cnt <= 6'd0;\n    else\n    \n        if ((fsm == FSM_CFG_WAIT) && (cfg_wait_cnt < CFG_WAIT_MAX))\n            cfg_wait_cnt <= cfg_wait_cnt + 6'd1;\n            \n        else if ((fsm == FSM_CFG_WAIT) && (cfg_wait_cnt == CFG_WAIT_MAX))\n            cfg_wait_cnt <= cfg_wait_cnt;\n            \n        else\n            cfg_wait_cnt <= 6'd0;\n        \nend \n\n\n\nalways @ (posedge RST_CLK)\nbegin\n\n    if (!RST_RST_N)\n        begin\n        fsm       <= FSM_CFG_WAIT;\n        pllreset <= 1'd0;\n        pllpd    <= 1'd0;\n        gtreset   <= 1'd0;\n        userrdy   <= 1'd0;\n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (!RST_RST_N)\n                begin\n                fsm       <= FSM_CFG_WAIT;\n                pllreset <= 1'd0;\n                pllpd    <= 1'd0;\n                gtreset   <= 1'd0;\n                userrdy   <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                pllreset  <= pllreset;\n                pllpd     <= pllpd;\n                gtreset   <= gtreset;\n                userrdy   <= userrdy;\n                end\n            end  \n            \n        FSM_CFG_WAIT :\n          \n            begin\n            fsm       <= ((cfg_wait_cnt == CFG_WAIT_MAX) ? FSM_PLLRESET : FSM_CFG_WAIT);\n            pllreset  <= pllreset;\n            pllpd     <= pllpd;\n            gtreset   <= gtreset;\n            userrdy   <= userrdy;\n            end \n            \n        FSM_PLLRESET :\n        \n            begin\n            fsm       <= (((~plllock_reg2) && (&(~resetdone_reg2))) ? FSM_PLLLOCK : FSM_PLLRESET);\n            pllreset  <= 1'd1;\n            pllpd     <= pllpd;\n            gtreset   <= 1'd1;\n            userrdy   <= userrdy;\n            end  \n\n        FSM_PLLLOCK :\n        \n            begin\n            fsm       <= (plllock_reg2 ? FSM_GTRESET : FSM_PLLLOCK);\n            pllreset  <= 1'd0;\n            pllpd     <= pllpd;\n            gtreset   <= gtreset;\n            userrdy   <= userrdy;\n            end\n\n        FSM_GTRESET :\n        \n            begin\n            fsm       <= FSM_MMCM_LOCK;\n            pllreset  <= pllreset;\n            pllpd     <= pllpd;\n            gtreset   <= 1'b0;\n            userrdy   <= userrdy;\n            end\n\n        FSM_MMCM_LOCK :\n        \n            begin  \n            if (mmcm_lock_reg2 && (&rxcdrlock_reg2 || (BYPASS_RXCDRLOCK == 1)))\n                begin\n                fsm       <= FSM_RESETDONE;\n                pllreset  <= pllreset;\n                pllpd     <= pllpd;\n                gtreset   <= gtreset;\n                userrdy   <= 1'd1;\n                end\n            else\n                begin\n                fsm       <= FSM_MMCM_LOCK;\n                pllreset  <= pllreset;\n                pllpd     <= pllpd;\n                gtreset   <= gtreset;\n                userrdy   <= 1'd0;\n                end\n            end\n\n        FSM_RESETDONE :\n        \n            begin\n            fsm       <= (&resetdone_reg2 && (&(~phystatus_reg2)) ? FSM_TXSYNC_START : FSM_RESETDONE);  \n            pllreset  <= pllreset;\n            pllpd     <= pllpd;\n            gtreset   <= gtreset;\n            userrdy   <= userrdy;\n            end\n            \n       FSM_TXSYNC_START :\n        \n            begin\n            fsm       <= (&(~txsync_done_reg2) ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pllreset  <= pllreset;\n            pllpd     <= pllpd;\n            gtreset   <= gtreset;\n            userrdy   <= userrdy;\n            end\n            \n        FSM_TXSYNC_DONE :\n        \n            begin\n            fsm       <= (&txsync_done_reg2 ? FSM_IDLE : FSM_TXSYNC_DONE);\n            pllreset  <= pllreset;\n            pllpd     <= pllpd;\n            gtreset   <= gtreset;\n            userrdy   <= userrdy;\n            end     \n            \n        default :\n        \n            begin\n            fsm       <= FSM_CFG_WAIT;\n            pllreset  <= 1'd0;\n            pllpd     <= 1'd0;\n            gtreset   <= 1'd0;\n            userrdy   <= 1'd0;\n            end\n\n        endcase\n        \n        end\n        \nend\n\n\n\nalways @ (posedge RST_RXUSRCLK)\nbegin\n\n    if (pllreset) \n        begin\n        rxusrclk_rst_reg1 <= 1'd1;\n        rxusrclk_rst_reg2 <= 1'd1;\n        end\n    else\n        begin\n        rxusrclk_rst_reg1 <= 1'd0;\n        rxusrclk_rst_reg2 <= rxusrclk_rst_reg1;\n        end   \n          \nend  \n\nalways @ (posedge RST_DCLK)\nbegin\n\n    if (pllreset) \n        begin\n        dclk_rst_reg1 <= 1'd1;\n        dclk_rst_reg2 <= 1'd1;\n        end\n    else\n        begin\n        dclk_rst_reg1 <= 1'd0;\n        dclk_rst_reg2 <= dclk_rst_reg1;\n        end   \n          \nend  \n\n\n\nassign RST_CPLLRESET      = pllreset;\nassign RST_CPLLPD         = pllpd;\nassign RST_RXUSRCLK_RESET = rxusrclk_rst_reg2;\nassign RST_DCLK_RESET     = dclk_rst_reg2;\nassign RST_GTRESET        = gtreset;  \nassign RST_USERRDY        = userrdy;\nassign RST_TXSYNC_START   = (fsm == FSM_TXSYNC_START);\nassign RST_IDLE           = (fsm == FSM_IDLE);\nassign RST_FSM            = fsm;                   \n\n\n\nendmodule\n",
        "module_name": "pcie_7x_v1_8_gtp_pipe_reset #",
        "module_hash": "74314d89483afd3a73a417f706029255",
        "dataset_index": 24243
      },
      "majority_counter_62d0f880": {
        "rtl_code": "module majority_counter (\n    input clk,\n    input reset,\n    input enable,\n    input A, B, C, D,\n    output reg [7:0] final_output\n);\n\n    wire Y;\n    wire [3:0] counter_out;\n    wire [1:0] counter_out_even;\n\n    majority_gate majority_gate_inst (\n        .A(A),\n        .B(B),\n        .C(C),\n        .D(D),\n        .Y(Y)\n    );\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .out(counter_out)\n    );\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            final_output <= 0;\n        end else if (enable) begin\n            if (counter_out[0] == 1) begin\n                final_output <= counter_out;\n            end else begin\n                final_output <= Y;\n            end\n        end\n    end\n\n    assign counter_out_even = counter_out[0] ? counter_out[1:0] : counter_out[2:1];\n\nendmodule\n\nmodule majority_gate (\n    input A, B, C, D,\n    output Y\n);\n\n    assign Y = (A & B & C) | (A & B & D) | (A & C & D) | (B & C & D);\n\nendmodule\n\nmodule counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] out\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 0;\n        end else if (enable) begin\n            out <= out + 1;\n        end\n    end\n\nendmodule",
        "module_name": "majority_counter",
        "module_hash": "62d0f88060b94023c23adfb424fa51ac",
        "dataset_index": 3404
      },
      "priority_encoder_4to2_8a6df830": {
        "rtl_code": "module priority_encoder_4to2 (\n    input a,\n    input b,\n    input c,\n    input d,\n    output x,\n    output y\n);\n\n    assign x = (a) ? 2'b00 : (b) ? 2'b01 : (c) ? 2'b10 : (d) ? 2'b11 : 2'b00;\n    assign y = (a) ? 2'b00 : (b) ? 2'b00 : (c) ? 2'b01 : (d) ? 2'b01 : 2'b00;\n\nendmodule",
        "module_name": "priority_encoder_4to2",
        "module_hash": "8a6df830a7e0089d2df3ba8d758b3033",
        "dataset_index": 5613
      },
      "hamming_code #_57c6a619": {
        "rtl_code": "module hamming_code #(\n  parameter n = 4, // length of data_in vector\n  parameter m = 7 // length of encoded_data vector (n + log2(n) + 1)\n)(\n  input [n-1:0] data_in,\n  output [m-1:0] encoded_data,\n  output [n-1:0] corrected_data\n);\n\n\n// Encoding\nwire [m-1:0] encoded_data_temp;\nassign encoded_data_temp[0] = data_in[0] ^ data_in[1] ^ data_in[3];\nassign encoded_data_temp[1] = data_in[0] ^ data_in[2] ^ data_in[3];\nassign encoded_data_temp[2] = data_in[0];\nassign encoded_data_temp[3] = data_in[1] ^ data_in[2] ^ data_in[3];\nassign encoded_data_temp[4] = data_in[1];\nassign encoded_data_temp[5] = data_in[2];\nassign encoded_data_temp[6] = data_in[3];\nassign encoded_data = encoded_data_temp;\n\n// Decoding\nwire [m-1:0] decoded_data_temp;\nwire error;\nwire [2:0] error_position;\nassign error = encoded_data_temp[0] ^ encoded_data_temp[1] ^ encoded_data_temp[3] ^ encoded_data_temp[4] ^ encoded_data_temp[5] ^ encoded_data_temp[6];\nassign error_position = {encoded_data_temp[0] ^ encoded_data_temp[2] ^ encoded_data_temp[4] ^ encoded_data_temp[6], encoded_data_temp[1] ^ encoded_data_temp[2] ^ encoded_data_temp[5] ^ encoded_data_temp[6], encoded_data_temp[3] ^ encoded_data_temp[4] ^ encoded_data_temp[5] ^ encoded_data_temp[6]};\nassign decoded_data_temp[0] = error ? (encoded_data_temp[2] ^ (error_position == 3'b001)) : encoded_data_temp[2];\nassign decoded_data_temp[1] = error ? (encoded_data_temp[4] ^ (error_position == 3'b010)) : encoded_data_temp[4];\nassign decoded_data_temp[2] = error ? (encoded_data_temp[5] ^ (error_position == 3'b011)) : encoded_data_temp[5];\nassign decoded_data_temp[3] = error ? (encoded_data_temp[6] ^ (error_position == 3'b100)) : encoded_data_temp[6];\nassign corrected_data = decoded_data_temp;\n\nendmodule",
        "module_name": "hamming_code #",
        "module_hash": "57c6a619bfd217212f5aa0e9d3a619d8",
        "dataset_index": 17332
      },
      "sky130_fd_sc_ls__a31o_20f87a4e": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__a31o (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A3, A1, A2     );\n    or  or0  (or0_out_X, and0_out, B1   );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__a31o",
        "module_hash": "20f87a4e3438510b2ac75347150cc882",
        "dataset_index": 17973
      },
      "and_gate_02872552": {
        "rtl_code": "module and_gate (\n    input A,\n    input B,\n    output Y\n);\n\n    wire not_A;\n    wire not_B;\n    wire or_out;\n    wire nand_out;\n\n    not not_A_inst (not_A, A);\n    not not_B_inst (not_B, B);\n    or or_inst (or_out, not_A, not_B);\n    nand nand_inst (nand_out, or_out, or_out);\n    buf buf_inst (Y, nand_out);\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "02872552f6369b1dce4b110214fba895",
        "dataset_index": 17925
      },
      "o_mux_51f28afd": {
        "rtl_code": "module o_mux(O, in0, in1, cbit, prog);\n  output O;\n  input cbit;\n  input in0;\n  input in1;\n  input prog;\n\n  wire sel;\n  assign sel = (prog & ~cbit) | (~prog & cbit);\n\n  assign O = sel ? in0 : in1;\nendmodule",
        "module_name": "o_mux",
        "module_hash": "51f28afd8702783ad32d126cb2d9aeff",
        "dataset_index": 3366
      },
      "and4_2and_06c22ccf": {
        "rtl_code": "module and4_2and (\n    input A,\n    input B,\n    input C,\n    input D,\n    output X\n);\n\n    wire AB;\n    wire CD;\n    wire ABCD;\n\n    and and1 (\n        AB,\n        A,\n        B\n    );\n\n    and and2 (\n        CD,\n        C,\n        D\n    );\n\n    and and3 (\n        ABCD,\n        AB,\n        CD\n    );\n\n    assign X = ABCD;\n\nendmodule",
        "module_name": "and4_2and",
        "module_hash": "06c22ccfcbd0fd5e8e695e62e675cd64",
        "dataset_index": 3202
      },
      "barrel_shifter_feb0cc26": {
        "rtl_code": "module barrel_shifter (\n    input [7:0] in,\n    input [2:0] shift_amount,\n    input direction,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (direction == 0) begin // left shift\n            out = in << shift_amount;\n        end else begin // right shift\n            out = in >> shift_amount;\n        end\n    end\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "feb0cc267dfd2a1f497c1ea9e65ce587",
        "dataset_index": 11265
      },
      "vending_machine_aa6b118d": {
        "rtl_code": "module vending_machine(\n    input clk,\n    input reset,\n    input [1:0] coin,\n    input [1:0] dispense,\n    output reg dispenser1,\n    output reg dispenser2,\n    output reg dispenser3,\n    output reg dispenser4,\n    output reg [1:0] change\n);\n\nparameter product_price = 2'b10; // 50 cents\nparameter coin_value = {2'b00, 2'b01, 2'b10, 2'b11}; // 5 cents, 10 cents, 25 cents, 1 dollar\n\nreg [1:0] amount_inserted; // total amount of money inserted so far\n\nalways @(posedge clk) begin\n    if (reset) begin\n        amount_inserted <= 0;\n        dispenser1 <= 0;\n        dispenser2 <= 0;\n        dispenser3 <= 0;\n        dispenser4 <= 0;\n        change <= 2'b00;\n    end else begin\n        amount_inserted <= amount_inserted + coin_value[coin];\n        if (amount_inserted >= product_price) begin\n            case (dispense)\n                2'b00: dispenser1 <= 1;\n                2'b01: dispenser2 <= 1;\n                2'b10: dispenser3 <= 1;\n                2'b11: dispenser4 <= 1;\n            endcase\n            change <= amount_inserted - product_price;\n            amount_inserted <= 0;\n        end else if (amount_inserted > 0) begin\n            change <= amount_inserted;\n            amount_inserted <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "vending_machine",
        "module_hash": "aa6b118dc51abf229213afb8b796ff25",
        "dataset_index": 7936
      },
      "and_gate_a64281f4": {
        "rtl_code": "module and_gate (\n    input A1,\n    input A2,\n    input VPWR,\n    input VGND,\n    output Y\n);\n\n    and_gate_inst and_gate_inst (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .B1(1'b1), // connect to 1 for AND gate\n        .C1(1'b0), // connect to 0 for AND gate\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(1'b0), // not used in AND gate\n        .VNB(1'b0)  // not used in AND gate\n    );\n\nendmodule\n\nmodule and_gate_inst (\n    output Y,\n    input A1,\n    input A2,\n    input B1,\n    input C1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    assign Y = (A1 & A2) & B1 & !C1;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "a64281f44d2c0fa2ca0f25303cac04dd",
        "dataset_index": 5410
      },
      "binary_counter_4dfaabd0": {
        "rtl_code": "module binary_counter (\n  input clock,\n  input reset,\n  output reg [3:0] counter_output\n);\n\n  always @(posedge clock) begin\n    if (reset) begin\n      counter_output <= 4'b0000;\n    end else begin\n      counter_output <= counter_output + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "4dfaabd01b582520d7bf83c6b2184336",
        "dataset_index": 3408
      },
      "register_addition_70b11f99": {
        "rtl_code": "module register_addition (\n  input clk, // clock signal\n  input reset, // asynchronous reset signal\n  input [1:0] mode, // 0 for unsigned, 1 for signed\n  input [29:0] a, // first 30-bit register\n  input [29:0] b, // second 30-bit register\n  output [29:0] sum, // 30-bit register containing the sum\n  output [3:0] flags // 4-bit signal indicating overflow/underflow\n);\n\n  reg signed [29:0] a_reg; // register to hold value of a\n  reg signed [29:0] b_reg; // register to hold value of b\n  reg signed [29:0] sum_reg; // register to hold value of sum\n  reg [1:0] mode_reg; // register to hold value of mode\n  reg [3:0] flags_reg; // register to hold value of flags\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      a_reg <= 0;\n      b_reg <= 0;\n      sum_reg <= 0;\n      mode_reg <= 0;\n      flags_reg <= 0;\n    end else begin\n      a_reg <= a;\n      b_reg <= b;\n      mode_reg <= mode;\n      \n      if (mode_reg == 0) begin // unsigned addition\n        sum_reg <= a_reg + b_reg;\n        if (sum_reg > 2**30 - 1) begin // overflow\n          flags_reg <= 4'b0001;\n        end else begin\n          flags_reg <= 4'b0000;\n        end\n      end else begin // signed addition\n        sum_reg <= $signed(a_reg) + $signed(b_reg);\n        if (sum_reg > 2**29 - 1 || sum_reg < -2**29) begin // overflow or underflow\n          flags_reg <= 4'b0010;\n        end else begin\n          flags_reg <= 4'b0000;\n        end\n      end\n    end\n  end\n  \n  assign sum = sum_reg;\n  assign flags = flags_reg;\n  \nendmodule",
        "module_name": "register_addition",
        "module_hash": "70b11f99c68b95fed6e6bffda1a566af",
        "dataset_index": 1517
      },
      "top_module_e7cf42d4": {
        "rtl_code": "\nmodule top_module(\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output reg [31:0] out\n);\n\n    reg [3:0] counter_out_reg;\n    wire [3:0] counter_out_next;\n\n    counter counter_inst(.clk(clk), .reset(reset), .q(counter_out_next));\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            counter_out_reg <= 0;\n        end else begin\n            counter_out_reg <= counter_out_next;\n        end\n    end\n\n    wire [31:0] selected_out;\n    demux_1to256 demux_inst(.in(out), .sel(counter_out_reg), .out(selected_out));\n\n    always @* begin\n        out = {(selected_out[15:8] & {8{selected_out[7]}}) ,selected_out[7:0]};\n    end\n\nendmodule\nmodule counter(\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output reg [3:0] q\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 0;\n        end else if (q == 15) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\nmodule demux_1to256(\n    input [31:0] in,\n    input [3:0] sel,\n    output reg [31:0] out\n);\n\n    always @* begin\n        case (sel)\n            4'b0000: out = in;\n            4'b0001: out = {in[7:0], 24'b0};\n            4'b0010: out = {in[15:0], 16'b0};\n            4'b0011: out = {in[23:0], 8'b0};\n            4'b0100: out = {in[31:24], 8'b0};\n            4'b0101: out = {in[31:20], 12'b0};\n            4'b0110: out = {in[31:16], 16'b0};\n            4'b0111: out = {in[31:12], 20'b0};\n            4'b1000: out = {in[31:8], 24'b0};\n            4'b1001: out = {in[31:4], 28'b0};\n            4'b1010: out = in;\n            4'b1011: out = 32'b0;\n            4'b1100: out = {in[7:0], 24'b0};\n            4'b1101: out = {in[15:0], 16'b0};\n            4'b1110: out = {in[23:0], 8'b0};\n            4'b1111: out = in;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "e7cf42d4830fc3da817894554c5e7691",
        "dataset_index": 4757
      },
      "mux4to1_4092281a": {
        "rtl_code": "module mux4to1 (\n  input         clock,\n  input         reset,\n  input  [7:0]  in_0,\n  input  [7:0]  in_1,\n  input  [7:0]  in_2,\n  input  [7:0]  in_3,\n  input  [1:0]  sel,\n  output [7:0]  out\n);\n  reg [7:0] selected_input;\n  \n  always @ (posedge clock or posedge reset) begin\n    if (reset) begin\n      selected_input <= 8'b0;\n    end else begin\n      case (sel)\n        2'b00: selected_input <= in_0;\n        2'b01: selected_input <= in_1;\n        2'b10: selected_input <= in_2;\n        2'b11: selected_input <= in_3;\n      endcase\n    end\n  end\n  \n  assign out = selected_input;\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "4092281af6f704320eeca0a5c73981a9",
        "dataset_index": 20439
      },
      "digital_circuit_3ee977d6": {
        "rtl_code": "module digital_circuit (\n    input D,\n    output Q,\n    input RESET_B,\n    input GATE\n);\n\n    reg Q_reg;\n\n    always @(posedge GATE) begin\n        if (RESET_B == 0) begin\n            Q_reg <= 0;\n        end else begin\n            Q_reg <= D;\n        end\n    end\n\n    assign Q = Q_reg;\n\nendmodule",
        "module_name": "digital_circuit",
        "module_hash": "3ee977d678fb25785437d52017e7b606",
        "dataset_index": 15993
      },
      "signed_non_restoring_divider_67ad9fac": {
        "rtl_code": "\nmodule signed_non_restoring_divider (\n  input signed [31:0] dividend,\n  input signed [31:0] divisor,\n  input clk,\n  output reg signed [31:0] quotient\n);\n\n  reg signed [31:0] remainder;\n  reg signed [31:0] dividend_reg;\n  reg signed [31:0] divisor_reg;\n  reg signed [31:0] quotient_reg;\n  reg signed [31:0] adder_input;\n  reg signed [31:0] adder_output;\n  reg [4:0] count;\n  reg sign;\n\n  always @(*) begin\n    dividend_reg = $signed({1'b0, {(dividend[31] ? 31'b1 : 31'b0)}, dividend[30:0]}); // Convert dividend to signed vector\n    divisor_reg = $signed({1'b0, {(divisor[31] ? 31'b1 : 31'b0)}, divisor[30:0]});   // Convert divisor to signed vector\n    sign = (dividend_reg < 0) ^ (divisor_reg < 0);\n  end\n\n  always @(posedge clk) begin\n    if (count == 0) begin\n      remainder = dividend_reg;\n      quotient_reg = 0;\n    end else begin\n      if (remainder < 0) begin\n        adder_input = divisor_reg - remainder;\n        adder_output = remainder + adder_input;\n        remainder = adder_output;\n        quotient_reg[count-1] = 0;\n      end else begin\n        adder_input = remainder - divisor_reg;\n        adder_output = remainder - adder_input;\n        remainder = adder_output;\n        quotient_reg[count-1] = 1;\n      end\n    end\n\n    if (count == 16) begin\n      quotient = $signed(quotient_reg);\n    end\n\n    count <= count + 1;\n  end\n\nendmodule\n",
        "module_name": "signed_non_restoring_divider",
        "module_hash": "67ad9fac8cc3b5571269ca58f297257d",
        "dataset_index": 14790
      },
      "Stack_5619ca7e": {
        "rtl_code": "\nmodule Stack(input clk, rst, input [1:0] stackCntrl, input [11:0] pushValue, output reg [11:0] popValue);\n\treg [2:0] stackPntr;\n\treg [11:0] data [0:7];\n\t\n\talways @ (posedge clk, posedge rst) begin\n\t\tif (rst) begin\n\t\t\tstackPntr <= 3'b000;\n\t\t\tdata[0] <= 12'd0;\n\t\t\tdata[1] <= 12'd0;\n\t\t\tdata[2] <= 12'd0;\n\t\t\tdata[3] <= 12'd0;\n\t\t\tdata[4] <= 12'd0;\n\t\t\tdata[5] <= 12'd0;\n\t\t\tdata[6] <= 12'd0;\n\t\t\tdata[7] <= 12'd0;\n\t\tend\n\t\telse begin\n\t\t\tif (stackCntrl == 2'b01) begin // push\n\t\t\t\tif (stackPntr < 3'b111) begin\n\t\t\t\t\tdata[stackPntr] <= pushValue + 12'd1;\n\t\t\t\t\tstackPntr <= stackPntr + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if (stackCntrl == 2'b10) begin // pop\n\t\t\t\tif (stackPntr > 3'b000) begin\n\t\t\t\t\tstackPntr <= stackPntr - 1;\n\t\t\t\t\tpopValue <= data[stackPntr];\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nendmodule",
        "module_name": "Stack",
        "module_hash": "5619ca7e8434439bfa4bab4ecc7b66ee",
        "dataset_index": 12188
      },
      "td_mode_mapper_9d64669a": {
        "rtl_code": "module td_mode_mapper (\n  input [2:0] ctrl,\n  output reg [3:0] td_mode\n);\n\n  always @(*) begin\n    case(ctrl)\n      3'b000: td_mode = 4'b0000;\n      3'b001: td_mode = 4'b1000;\n      3'b010: td_mode = 4'b0100;\n      3'b011: td_mode = 4'b1100;\n      3'b100: td_mode = 4'b0010;\n      3'b101: td_mode = 4'b1010;\n      3'b110: td_mode = 4'b0101;\n      3'b111: td_mode = 4'b1111;\n    endcase\n  end\n\nendmodule",
        "module_name": "td_mode_mapper",
        "module_hash": "9d64669a8aff5d4a942386b6c1e30cbe",
        "dataset_index": 8699
      },
      "ripple_carry_adder_6a69c456": {
        "rtl_code": "module ripple_carry_adder (A, B, Cin, Sum, Cout);\n\n    parameter WIDTH = 4;\n    \n    input [WIDTH-1:0] A, B;\n    input Cin;\n    output [WIDTH-1:0] Sum;\n    output Cout;\n    \n    wire [WIDTH:0] C;\n    assign C[0] = Cin;\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : gen_full_adder\n            full_adder fa(\n                .A(A[i]),\n                .B(B[i]),\n                .Cin(C[i]),\n                .Sum(Sum[i]),\n                .Cout(C[i+1])\n            );\n        end\n    endgenerate\n    \n    assign Cout = C[WIDTH];\n    \nendmodule\n\nmodule full_adder (A, B, Cin, Sum, Cout);\n\n    input A, B, Cin;\n    output Sum, Cout;\n    \n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n    \nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "6a69c456993a6ad7b431168075421222",
        "dataset_index": 4012
      },
      "processing_unit #_c83e0125": {
        "rtl_code": "\n\n\n\nmodule processing_unit #(\n\nparameter PRV_SIZE = 16,\nparameter PRV_LOOP = 1,\nparameter WEIGHT_WIDTH = 3,\nparameter FRACTION_WIDTH = 8,\nparameter REG_WIDTH = $clog2(PRV_SIZE*PRV_LOOP*3) + 8 + 1,\nparameter BIAS = 0\n\n)(\n\ninput clk_i,\ninput en_i,\ninput rst_i,\ninput [WEIGHT_WIDTH - 1:0] weight_i,\ninput\t[7:0] data_i,\noutput reg [9:0] proc_unit_o\n\n);\n\nreg [9:0] product = 0;\nreg [REG_WIDTH - 1:0] signed_product = 0;\nreg [REG_WIDTH - 1:0] sum = 0;\n\nwire positive_cap;\nwire negative_cap;\n\nassign positive_cap = sum[REG_WIDTH - 2 : 11] != 0;\nassign negative_cap = !(sum[REG_WIDTH - 2 : 11] == {(REG_WIDTH - 12){1'b1}});\n\nalways@(*)begin\n\n\t\n\t\n\t\n\t\n\tcase(weight_i[2:0])\n\t\t3'd0: product = 10'd0;\n\t\t3'd1: product = {5'd0, data_i[7:3]};\n\t\t3'd2: product = {4'd0, data_i[7:2]};\n\t\t3'd3: product = {3'd0, data_i[7:1]};\n\t\t3'd4: product = data_i[7:1] + data_i[7:2];\n\t\t3'd5: product = data_i;\n\t\t3'd6: product = data_i + data_i[7:2];\n\t\t3'd7: product = data_i + data_i[7:1];\n\tendcase\n\t\n\tif(!weight_i[WEIGHT_WIDTH - 1'b1] || product == 0)\n\t\tsigned_product = {{(REG_WIDTH - 10){1'b0}}, product};\n\telse\n\t\tsigned_product = {{(REG_WIDTH - 10){1'b1}},~product + 1'b1};\n\t\n\tif(positive_cap && !sum[REG_WIDTH - 1])\t\t\n\t\tproc_unit_o = 10'b0111111111;\n\telse if((negative_cap || sum[11:2] == 10'b1000000000) && sum[REG_WIDTH - 1])\t\n\t\tproc_unit_o = 10'b1000000001;\n\telse\n\t\tproc_unit_o = sum[11:2];\n\t\nend\n\nalways@(posedge clk_i) begin\n\t\n\tif(rst_i)\n\t\tsum <= BIAS;\n\telse if(en_i)\n\t\tsum <= sum + signed_product;\n\nend\n\nendmodule\n",
        "module_name": "processing_unit #",
        "module_hash": "c83e01253ecdf3a7bcaf54aede500fcd",
        "dataset_index": 8683
      },
      "bcd_counter_and_gate_bc0cae57": {
        "rtl_code": "\nmodule bcd_counter_and_gate(\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input a, \n    input b,\n    output reg [3:0] ena,\n    output reg [15:0] q\n);\n\nreg [3:0] count;\nwire and_result;\nwire [3:0] bcd_out;\n\n// Modulo-10 counter for each digit\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        if (ena[3]) begin\n            count[3] <= count[3] + 1;\n        end\n        if (ena[2]) begin\n            count[2] <= count[2] + 1;\n        end\n        if (ena[1]) begin\n            count[1] <= count[1] + 1;\n        end\n        if (ena[0]) begin\n            count[0] <= count[0] + 1;\n        end\n    end\nend\n\n// Combinational circuit to convert binary to BCD\nassign bcd_out = {count[3], count[2], count[1], count[0]} + (count[3] >= 5 || count[2] >= 5 || count[1] >= 5 || count[0] >= 5 ? 4'b0110 : 4'b0000);\n\n// AND gate module\nand_gate and_gate_inst(\n    .a(a),\n    .b(b),\n    .out(and_result)\n);\n\n// Final output module\nalways @(*) begin\n  q = bcd_out & {4{and_result}};\n  ena = 4'b1111;\nend\n\nendmodule\nmodule and_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule",
        "module_name": "bcd_counter_and_gate",
        "module_hash": "bc0cae573b0fbe5878c4d15f62d82a08",
        "dataset_index": 14844
      },
      "reverse_bit_order_d8fb2f0b": {
        "rtl_code": "module reverse_bit_order (\n    input clk,          // Clock input\n    input rst,          // Synchronous active-high reset\n    input [7:0] in,     // 8-bit input\n    output reg [7:0] out // 8-bit output with reverse bit ordering\n);\n\nreg [7:0] shift_reg;    // Shift register to store input bits\n\nalways @(posedge clk) begin\n    if (rst) begin\n        shift_reg <= 8'b0;   // Reset shift register to 0\n        out <= 8'b0;         // Reset output to 0\n    end else begin\n        shift_reg <= {shift_reg[6:0], in[0]}; // Shift input bit into shift register\n        out <= {out[6:0], shift_reg[0]};      // Output bit from shift register\n    end\nend\n\nendmodule",
        "module_name": "reverse_bit_order",
        "module_hash": "d8fb2f0ba9727054c9a16fc04a3a97fc",
        "dataset_index": 11718
      },
      "shift_register_bd100b0c": {
        "rtl_code": "module shift_register (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[6:0], d};\nend\n\nassign q = shift_reg;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nshift_register sr (\n    .clk(clk),\n    .d(d),\n    .q(q)\n);\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "bd100b0c66461cc33bede364a1f0d617",
        "dataset_index": 1213
      },
      "adder4_b7614cea": {
        "rtl_code": "module adder4 (sum, carry_out, wireA, wireB, carry_in);\n   input [3:0] wireA;\n   input [3:0] wireB;\n   input carry_in;\n   output [3:0] sum;\n   output carry_out;\n\n   assign {carry_out, sum} = wireA + wireB + carry_in;\nendmodule",
        "module_name": "adder4",
        "module_hash": "b7614cea425b67f128fb4ca9ecac3fe5",
        "dataset_index": 15034
      },
      "four_bit_adder_85fb9553": {
        "rtl_code": "\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] temp_sum;\n    wire [3:0] temp_carry;\n\n    // Full adder for least significant bit\n    full_adder FA0(A[0], B[0], Cin, temp_sum[0], temp_carry[0]);\n\n    // Full adder for second least significant bit\n    full_adder FA1(A[1], B[1], temp_carry[0], temp_sum[1], temp_carry[1]);\n\n    // Full adder for third least significant bit\n    full_adder FA2(A[2], B[2], temp_carry[1], temp_sum[2], temp_carry[2]);\n\n    // Full adder for most significant bit\n    full_adder FA3(A[3], B[3], temp_carry[2], temp_sum[3], Cout);\n\n    assign Sum = temp_sum;\n\nendmodule\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output Sum,\n    output Cout\n);\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "85fb9553384f60488687602769b9d4be",
        "dataset_index": 20039
      },
      "counter_aa98f8ca": {
        "rtl_code": "module counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [1:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 2'b0;\n    end else if (enable) begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "aa98f8ca5c04d24bbbf247c152d1730f",
        "dataset_index": 12579
      },
      "fifo_buffer #_1667323a": {
        "rtl_code": "\nmodule fifo_buffer #(\n  parameter DATA_WIDTH          = 32,\n  parameter FIFO_WIDTH          = 8\n)(\n  input                             rst,\n  input       [31:0]                test_id,\n\n  //write side\n  input                             WR_CLK,\n  output                            WR_RDY,\n  input                             WR_ACT,\n  output      [23:0]                WR_SIZE,\n  input                             WR_STB,\n  input       [DATA_WIDTH - 1: 0]   WR_DATA,\n  output                            WR_STARVED,\n\n  //read side\n  input                             RD_CLK,\n  input                             RD_STB,\n  output                            RD_RDY,\n  input                             RD_ACT,\n  output      [23:0]                RD_SIZE,\n  output      [DATA_WIDTH - 1: 0]   RD_DATA,\n\n  output                            RD_INACTIVE\n);\n\n//Local Parameters\nlocalparam ADDR_WIDTH = FIFO_WIDTH;\nlocalparam ADDR_MASK  = (1 << ADDR_WIDTH) - 1;\n\n//Registers/Wires\nreg       [ADDR_WIDTH-1:0] wr_ptr = 0;\nreg       [ADDR_WIDTH-1:0] rd_ptr = 0;\nreg       [ADDR_WIDTH-1:0] count = 0;\nreg                      wr_starved = 0;\nreg                      rd_inactive = 1;\nreg                      r_rst;\n\n//Submodules\nblock_mem #(\n  .DATA_WIDTH      (DATA_WIDTH),\n  .ADDRESS_WIDTH   (ADDR_WIDTH)\n) mem (\n  .clk             (WR_CLK),\n  .we              (WR_STB & WR_ACT & WR_RDY),\n  .addr            (wr_ptr),\n  .data            (WR_DATA),\n  .q               (),\n  .oe              (RD_STB & RD_ACT & RD_RDY),\n  .oe_addr         (rd_ptr),\n  .oe_data         (RD_DATA)\n);\n\n//Asynchronous Logic\nalways @ (*) r_rst = rst;\n\n//Synchronous Logic\nalways @(posedge WR_CLK) begin\n  if (r_rst) begin\n    wr_ptr <= 0;\n    rd_ptr <= 0;\n    count <= 0;\n    wr_starved <= 0;\n    rd_inactive <= 1;\n  end else begin\n    if (WR_STB & WR_ACT & WR_RDY) begin\n      wr_ptr <= wr_ptr + 1;\n      count <= count + 1;\n      rd_inactive <= 0;\n      if (count == ADDR_MASK + 1) begin\n        wr_starved <= 1;\n      end\n    end\n\n    if (RD_STB & RD_ACT & RD_RDY) begin\n      rd_ptr <= rd_ptr + 1;\n      count <= count - 1;\n      wr_starved <= 0;\n      if (count == 0) begin\n        rd_inactive <= 1;\n      end\n    end\n  end\nend\n\n//Output Mux\nassign WR_RDY = ~wr_starved;\nassign RD_RDY = ~rd_inactive;\nassign RD_INACTIVE = rd_inactive;\nassign WR_STARVED = wr_starved;\nassign WR_SIZE = ADDR_MASK + 1;\nassign RD_SIZE = ADDR_MASK + 1 - count;\n\nendmodule\nmodule block_mem #(\n  parameter DATA_WIDTH      = 32,\n  parameter ADDRESS_WIDTH   = 8\n)(\n  input                             clk,\n  input                             we,\n  input       [ADDRESS_WIDTH-1:0] addr,\n  input       [DATA_WIDTH - 1: 0] data,\n  output      [DATA_WIDTH - 1: 0] q,\n  input                             oe,\n  input       [ADDRESS_WIDTH-1:0] oe_addr,\n  output      [DATA_WIDTH - 1: 0] oe_data\n);\n\n//Registers/Wires\nreg       [DATA_WIDTH - 1: 0]   mem [0:(1 << ADDRESS_WIDTH) - 1];\nreg       [DATA_WIDTH - 1: 0]   q_reg;\nreg       [DATA_WIDTH - 1: 0]   oe_data_reg;\n\n//Write Logic\nalways @(posedge clk) begin\n  if (we) begin\n    mem[addr] <= data;\n  end\nend\n\n//Read Logic\nalways @(*) begin\n  q_reg = mem[addr];\nend\n\n//Output Logic\nassign q = q_reg;\n\n//Output Enable Logic\nalways @(*) begin\n  if (oe) begin\n    oe_data_reg = mem[oe_addr];\n  end else begin\n    oe_data_reg = 0;\n  end\nend\n\nassign oe_data = oe_data_reg;\n\nendmodule",
        "module_name": "fifo_buffer #",
        "module_hash": "1667323a5d904dbc8b35d7eea22c2f85",
        "dataset_index": 10965
      },
      "square_wave_cfbbe4c5": {
        "rtl_code": "module square_wave (\n    input clk,\n    input reset,\n    output reg out\n);\n\nreg [1:0] state;\nalways @ (posedge clk) begin\n    if (reset) begin\n        state <= 2'b00;\n        out <= 0;\n    end else begin\n        case (state)\n            2'b00: begin\n                out <= 0;\n                state <= 2'b01;\n            end\n            2'b01: begin\n                out <= 1;\n                state <= 2'b10;\n            end\n            2'b10: begin\n                out <= 1;\n                state <= 2'b11;\n            end\n            2'b11: begin\n                out <= 0;\n                state <= 2'b00;\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "square_wave",
        "module_hash": "cfbbe4c59281800da0fb187f5d492e9d",
        "dataset_index": 10060
      },
      "waveform_generator_06152f79": {
        "rtl_code": "module waveform_generator (\n    input wire X,\n    output reg [31:0] waveform\n);\n\ninteger time;\n\ninitial begin\n    waveform = 0;\n    time = 0;\nend\n\nalways @(posedge X) begin\n    waveform[time] = X;\n    time = time + 1;\nend\n\nendmodule",
        "module_name": "waveform_generator",
        "module_hash": "06152f7989f8f033861fb5d49f664267",
        "dataset_index": 13626
      },
      "mux_2_1_6a08da81": {
        "rtl_code": "module mux_2_1(\n    input A,\n    input B,\n    input SEL,\n    output Y\n);\n\n    assign Y = SEL ? B : A;\n\nendmodule",
        "module_name": "mux_2_1",
        "module_hash": "6a08da818f137daf6ccecba1a905b8a6",
        "dataset_index": 12455
      },
      "AllignAdderProcess_254f5a38": {
        "rtl_code": "\nmodule AllignAdderProcess(\n\tinput [31:0] z_postSpecial,\n\tinput [3:0] Opcode_Special,\n\tinput idle_Special,\n\tinput [35:0] cout_Special,\n\tinput [35:0] zout_Special,\n\tinput [31:0] sout_Special,\n\tinput [7:0] difference_Special,\n\tinput [7:0] InsTagSpecial,\n\tinput clock,\n\toutput reg idle_Allign,\n\toutput reg [35:0] cout_Allign,\n\toutput reg [35:0] zout_Allign,\n\toutput reg [31:0] sout_Allign,\n\toutput reg [3:0] Opcode_Allign,\n\toutput reg [31:0] z_postAllign,\n\toutput reg [7:0] InsTagAllign\n   );\n\nparameter no_idle = 1'b0,\n\t\t\t put_idle = 1'b1;\n\nwire z_sign;\nwire [7:0] z_exponent;\nwire [26:0] z_mantissa;\n\nwire c_sign;\nwire [7:0] c_exponent;\nwire [26:0] c_mantissa;\n\nassign z_sign = zout_Special[35];\nassign z_exponent = zout_Special[34:27] - 127;\nassign z_mantissa = {zout_Special[26:0]};\n\nassign c_sign = cout_Special[35];\nassign c_exponent = cout_Special[34:27] - 127;\nassign c_mantissa = {cout_Special[26:0]};\n\nparameter sin_cos\t\t= 4'd0,\n\t\t\t sinh_cosh\t= 4'd1,\n\t\t\t arctan\t\t= 4'd2,\n\t\t\t arctanh\t\t= 4'd3,\n\t\t\t exp\t\t\t= 4'd4,\n\t\t\t sqr_root   = 4'd5,\t\t\tdivision\t= 4'd6,\n\t\t\t tan\t\t\t= 4'd7,\t\t\ttanh\t\t\t= 4'd8,\t\t\tnat_log\t\t= 4'd9,\t\t\thypotenuse = 4'd10,\n\t\t\t PreProcess = 4'd11;\n\n\nalways @ (posedge clock)\nbegin\n\t\n\tInsTagAllign <= InsTagSpecial;\n\tOpcode_Allign <= Opcode_Special;\n\tz_postAllign <= z_postSpecial;\n\t\t\n\tidle_Allign <= idle_Special;\n\tsout_Allign <= sout_Special;\n\t\n\tif (idle_Special != put_idle) begin\n\t\tif ($signed(c_exponent) > $signed(z_exponent)) begin\n\t\t\tzout_Allign[35] <= zout_Special[35];\n\t\t\tzout_Allign[34:27] <= z_exponent + difference_Special + 127;\n\t\t\tzout_Allign[26:0] <= z_mantissa >> difference_Special;\n\t\t\tzout_Allign[0] <= z_mantissa[0] | z_mantissa[1];\n\t\t\tcout_Allign <= cout_Special;\n\t\tend else if ($signed(c_exponent) <= $signed(z_exponent)) begin\n\t\t\tcout_Allign[35] <= cout_Special[35];\n\t\t\tcout_Allign[34:27] <= c_exponent + difference_Special + 127;\n\t\t\tcout_Allign[26:0] <= c_mantissa >> difference_Special;\n\t\t\tcout_Allign[0] <= c_mantissa[0] | c_mantissa[1];\n\t\t\tzout_Allign <= zout_Special;\n\t\t end\t\t\n\tend\n\t\n\telse begin\n\t\tzout_Allign <= zout_Special;\n\t\tcout_Allign <= cout_Special;\n\tend\n\tend\n\nendmodule\n",
        "module_name": "AllignAdderProcess",
        "module_hash": "254f5a38426f36b7431b48f06775f02f",
        "dataset_index": 6593
      },
      "logic_circuit_189669be": {
        "rtl_code": "module logic_circuit(\n    input a,\n    input b,\n    input c,\n    output x,\n    output y,\n    output z\n    );\n\n    assign x = a;\n    assign y = (a == 1'b0 && b == 1'b1);\n    assign z = (a == 1'b0 && b == 1'b0 && c == 1'b1);\n\nendmodule",
        "module_name": "logic_circuit",
        "module_hash": "189669be9a2e96befadd128e4638eeab",
        "dataset_index": 17224
      },
      "mod4sum_8b8757c5": {
        "rtl_code": "module mod4sum(\n    input A,\n    input B,\n    input C,\n    input D,\n    output reg [1:0] Y\n);\n\n    always @ (A, B, C, D) begin\n        Y = {A, B} + {C, D};\n        if (Y >= 4) Y = Y - 4;\n    end\n\nendmodule",
        "module_name": "mod4sum",
        "module_hash": "8b8757c5866c97450f66bea615ce938b",
        "dataset_index": 19905
      },
      "fifo_generator_ef1f0c90": {
        "rtl_code": "\nmodule fifo_generator (\n  input clk,\n  input [4:0] din,\n  input s_aclk,\n  input rst,\n  input rd_en,\n  input wr_en,\n  input s_aresetn,\n  output reg [4:0] dout,\n  output empty,\n  output full\n);\n\n  // Define parameters\n  parameter WIDTH = 5;\n  parameter DEPTH = 1024;\n  parameter ADDR_WIDTH = $clog2(DEPTH);\n\n  // Define registers\n  reg [ADDR_WIDTH-1:0] wptr = 0;\n  reg [ADDR_WIDTH-1:0] rptr = 0;\n  reg [WIDTH-1:0] mem [0:DEPTH-1];\n\n  // Define wires\n  reg [ADDR_WIDTH-1:0] next_wptr;\n  reg [ADDR_WIDTH-1:0] next_rptr;\n  \n  // Define slower clock domain registers\n  reg [31:0] slow_cnt = 0;\n  reg [31:0] slow_wr_cnt = 0;\n  reg [31:0] slow_rd_cnt = 0;\n\n  // Define slower clock domain wires\n  wire slow_wr_en;\n  wire slow_rd_en;\n\n  // Synchronize signals to the slower clock domain\n  always @(posedge s_aclk) begin\n    if (~s_aresetn) begin\n      slow_cnt <= 0;\n      slow_wr_cnt <= 0;\n      slow_rd_cnt <= 0;\n    end else begin\n      slow_cnt <= slow_cnt + 1;\n      slow_wr_cnt <= slow_wr_cnt + wr_en;\n      slow_rd_cnt <= slow_rd_cnt + rd_en;\n    end\n  end\n\n  // Generate slower clock domain signals\n  assign slow_wr_en = (slow_wr_cnt >= (DEPTH/2)) ? 1'b0 : 1'b1;\n  assign slow_rd_en = (slow_rd_cnt >= (DEPTH/2)) ? 1'b0 : 1'b1;\n\n  // Synchronize read and write pointers to the slower clock domain\n  always @(posedge s_aclk) begin\n    if (~s_aresetn) begin\n      next_wptr <= 0;\n      next_rptr <= 0;\n    end else if (slow_cnt == 0) begin\n      next_wptr <= (slow_wr_en && wr_en) ? wptr + 1'b1 : wptr;\n      next_rptr <= (slow_rd_en && rd_en) ? rptr + 1'b1 : rptr;\n    end else begin\n      next_wptr <= wptr;\n      next_rptr <= rptr;\n    end\n  end\n\n  // Update read and write pointers\n  always @(posedge clk) begin\n    if (~rst) begin\n      wptr <= 0;\n      rptr <= 0;\n    end else begin\n      wptr <= next_wptr;\n      rptr <= next_rptr;\n    end\n  end\n\n  // Write data to memory\n  always @(posedge clk) begin\n    if (~rst && wr_en) begin\n      mem[wptr] <= din;\n    end\n  end\n\n  // Read data from memory\n  always @(posedge clk) begin\n    if (~rst && rd_en) begin\n      dout <= mem[rptr];\n    end\n  end\n\n  // Check if FIFO is empty or full\n  assign empty = (wptr == rptr) ? 1'b1 : 1'b0;\n  assign full = ((wptr+1'b1) == rptr) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "fifo_generator",
        "module_hash": "ef1f0c901f6bb9d5543b20ed03249658",
        "dataset_index": 7189
      },
      "ldly2us_f8af67f8": {
        "rtl_code": "module ldly2us(input clk, input reset, input in, output p, output reg l);\n\treg [7-1:0] r;\n\talways @(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t\tr <= 0;\n\t\t\tl <= 0;\n\t\tend else begin\n\t\t\tif(r)\n\t\t\t\tr <= r + 7'b1;\n\t\t\tif(in) begin\n\t\t\t\tr <= 1;\n\t\t\t\tl <= 1;\n\t\t\tend\n\t\t\tif(p) begin\n\t\t\t\tr <= 0;\n\t\t\t\tl <= 0;\n\t\t\tend\n\t\tend\n\tend\n\tassign p = r == 100;\nendmodule",
        "module_name": "ldly2us",
        "module_hash": "f8af67f8b665ff68bcd214a1444a7a91",
        "dataset_index": 17605
      },
      "sky130_fd_sc_lp__a22oi_2c0cfdd9": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__a22oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    wire nand0_out ;\n    wire nand1_out ;\n    wire and0_out_Y;\n\n    nand nand0 (nand0_out , A2, A1              );\n    nand nand1 (nand1_out , B2, B1              );\n    and  and0  (and0_out_Y, nand0_out, nand1_out);\n    buf  buf0  (Y         , and0_out_Y          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__a22oi",
        "module_hash": "2c0cfdd90e49d013ef9c89f2fe1c56da",
        "dataset_index": 18364
      },
      "comparator_fd6d30f1": {
        "rtl_code": "module comparator (\n    input [3:0] A,\n    input [3:0] B,\n    input clk,\n    output reg [1:0] OUT\n);\n\nreg [3:0] A_reg, B_reg;\nreg [1:0] OUT_reg;\n\nalways @ (posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n\n    if (A_reg > B_reg) begin\n        OUT_reg <= 2'b01;\n    end else if (A_reg < B_reg) begin\n        OUT_reg <= 2'b10;\n    end else begin\n        OUT_reg <= 2'b11;\n    end\nend\n\nalways @*\n    OUT = OUT_reg;\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "fd6d30f16a7ac22d13f399719e03344a",
        "dataset_index": 9633
      },
      "dff_en_rst_a1fdddf9": {
        "rtl_code": "module dff_en_rst (\n    input D, C, E, R,\n    output Q\n);\n\nreg Q_reg;\n\nalways @(posedge C) begin\n    if (R == 0) begin\n        Q_reg <= 0;\n    end else if (E == 1) begin\n        Q_reg <= D;\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule",
        "module_name": "dff_en_rst",
        "module_hash": "a1fdddf98111e0179638b719c0031a56",
        "dataset_index": 3324
      },
      "mul_bodec_multiplier_2f31b4f0": {
        "rtl_code": "\nmodule mul_bodec_multiplier(a_reg, b_reg, p_high, p_low);\n\ninput [15:0] a_reg, b_reg;\noutput [15:0] p_high, p_low;\n\nwire [2:0] b0, b1, b2, b3, b4, b5, b6, b7;\nwire [31:0] p;\n\nmul_bodec_16bit mul_bodec_inst (\n  .x(a_reg[0]),\n  .b(b_reg),\n  .b0(b0),\n  .b1(b1),\n  .b2(b2),\n  .b3(b3),\n  .b4(b4),\n  .b5(b5),\n  .b6(b6),\n  .b7(b7)\n);\n\nassign p[31:16] = {16'b0, b4, b5, b6, b7};\nassign p[15:0] = {b0, b1, b2, b3, 5'b0};\n\nassign p_high = p[31:16];\nassign p_low = p[15:0];\n\nendmodule\n\nmodule mul_bodec_16bit(x, b, b0, b1, b2, b3, b4, b5, b6, b7);\n\ninput x;\ninput [15:0] b;\noutput [2:0] b0, b1, b2, b3, b4, b5, b6, b7;\n\nassign b0 = x ? b[ 2: 0] : 3'b0;\nassign b1 = x ? b[ 5: 3] : 3'b0;\nassign b2 = x ? b[ 8: 6] : 3'b0;\nassign b3 = x ? b[11: 9] : 3'b0;\nassign b4 = x ? b[14:12] : 3'b0;\nassign b5 = x ? b[15]    : 1'b0;\nassign b6 = 3'b0;\nassign b7 = 3'b0;\n\nendmodule\n",
        "module_name": "mul_bodec_multiplier",
        "module_hash": "2f31b4f078c8c20e3ac54d54bf9b9f12",
        "dataset_index": 7609
      },
      "register_file_4b59095a": {
        "rtl_code": "module register_file(\n    input [1:0] read_register_port_0,\n    input [1:0] read_register_port_1,\n    input [1:0] write_register,\n    input [31:0] write_data,\n    input write_enable,\n    output reg [31:0] read_data_port_0,\n    output reg [31:0] read_data_port_1\n);\n\nreg [31:0] registers [0:3];\n\nalways @(*)\nbegin\n    read_data_port_0 = registers[read_register_port_0];\n    read_data_port_1 = registers[read_register_port_1];\nend\n\nalways @(posedge write_enable)\nbegin\n    if (write_enable)\n        registers[write_register] <= write_data;\nend\n\nendmodule",
        "module_name": "register_file",
        "module_hash": "4b59095a38a9b2b0ef48e8607a4658cf",
        "dataset_index": 5937
      },
      "shift_adder_db0c279e": {
        "rtl_code": "\nmodule shift_adder(\n    input clk,\n    input load,\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\n    reg [7:0] shift_reg;\n    wire [31:0] adder_input;\n    wire [31:0] adder_output;\n\n    // Shift register with parallel load\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= a[7:0];\n        end else begin\n            shift_reg <= {shift_reg[6:0], shift_reg[7]};\n        end\n    end\n\n    // Adder module\n    assign adder_input = {shift_reg, b};\n    assign adder_output = sub ? {32{1'b0}} - adder_input : adder_input;\n\n    // Output sum\n    assign sum = adder_output;\n\nendmodule",
        "module_name": "shift_adder",
        "module_hash": "db0c279e55ab0c4347fbf78e44d8cfbe",
        "dataset_index": 18574
      },
      "top__e75f7f6a": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [255:0] in, // Input for the 256-to-1 multiplexer\n    input [7:0] sel,  // Selection signal for the 256-to-1 multiplexer\n    output [3:0] q,   // Output from the 4-bit binary counter\n    output [3:0] out  // Final output from the functional module\n);\n\n    // 256-to-1 multiplexer\n    wire [7:0] mux_sel;\n    assign mux_sel = sel;\n    wire [7:0] mux_out;\n    assign mux_out = in[mux_sel];\n\n    // 4-bit binary counter\n    reg [3:0] counter;\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n    assign q = counter;\n\n    // Functional module\n    assign out = mux_out & q;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "e75f7f6af94ef663844e5ce2f80bdb5f",
        "dataset_index": 17154
      },
      "ABS #_a9d00cdd": {
        "rtl_code": "module ABS #(\n  parameter n = 8 // width of input and output signals\n)(\n  input signed [n-1:0] in,\n  output signed [n-1:0] out\n);\n\nassign out = (in >= 0) ? in : (~in + 1);\n\nendmodule",
        "module_name": "ABS #",
        "module_hash": "a9d00cdd55cc24cb77689c74fec115c1",
        "dataset_index": 11576
      },
      "image_filter_Block_proc_731d25a3": {
        "rtl_code": "\n\nmodule image_filter_Block_proc (\n        ap_clk,\n        ap_rst,\n        ap_start,\n        ap_done,\n        ap_continue,\n        ap_idle,\n        ap_ready,\n        rows,\n        cols,\n        ap_return_0,\n        ap_return_1,\n        ap_return_2,\n        ap_return_3\n);\n\nparameter    ap_const_logic_1 = 1'b1;\nparameter    ap_const_logic_0 = 1'b0;\nparameter    ap_ST_st1_fsm_0 = 1'b1;\nparameter    ap_const_lv32_0 = 32'b00000000000000000000000000000000;\nparameter    ap_const_lv1_1 = 1'b1;\nparameter    ap_const_lv12_0 = 12'b000000000000;\nparameter    ap_true = 1'b1;\n\ninput   ap_clk;\ninput   ap_rst;\ninput   ap_start;\noutput   ap_done;\ninput   ap_continue;\noutput   ap_idle;\noutput   ap_ready;\ninput  [31:0] rows;\ninput  [31:0] cols;\noutput  [11:0] ap_return_0;\noutput  [11:0] ap_return_1;\noutput  [11:0] ap_return_2;\noutput  [11:0] ap_return_3;\n\nreg ap_done;\nreg ap_idle;\nreg ap_ready;\nreg[11:0] ap_return_0;\nreg[11:0] ap_return_1;\nreg[11:0] ap_return_2;\nreg[11:0] ap_return_3;\nreg    ap_done_reg = 1'b0;\n reg   [0:0] ap_CS_fsm = 1'b1;\nreg    ap_sig_cseq_ST_st1_fsm_0;\nreg    ap_sig_bdd_20;\nreg    ap_sig_bdd_38;\nwire   [11:0] img_0_rows_V_fu_31_p1;\nwire   [11:0] img_0_cols_V_fu_35_p1;\nreg   [11:0] ap_return_0_preg = 12'b000000000000;\nreg   [11:0] ap_return_1_preg = 12'b000000000000;\nreg   [11:0] ap_return_2_preg = 12'b000000000000;\nreg   [11:0] ap_return_3_preg = 12'b000000000000;\nreg   [0:0] ap_NS_fsm;\n\n\n\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_CS_fsm\n    if (ap_rst == 1'b1) begin\n        ap_CS_fsm <= ap_ST_st1_fsm_0;\n    end else begin\n        ap_CS_fsm <= ap_NS_fsm;\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_done_reg\n    if (ap_rst == 1'b1) begin\n        ap_done_reg <= ap_const_logic_0;\n    end else begin\n        if ((ap_const_logic_1 == ap_continue)) begin\n            ap_done_reg <= ap_const_logic_0;\n        end else if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n            ap_done_reg <= ap_const_logic_1;\n        end\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_return_0_preg\n    if (ap_rst == 1'b1) begin\n        ap_return_0_preg <= ap_const_lv12_0;\n    end else begin\n        if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n            ap_return_0_preg <= img_0_rows_V_fu_31_p1;\n        end\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_return_1_preg\n    if (ap_rst == 1'b1) begin\n        ap_return_1_preg <= ap_const_lv12_0;\n    end else begin\n        if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n            ap_return_1_preg <= img_0_cols_V_fu_35_p1;\n        end\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_return_2_preg\n    if (ap_rst == 1'b1) begin\n        ap_return_2_preg <= ap_const_lv12_0;\n    end else begin\n        if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n            ap_return_2_preg <= img_0_rows_V_fu_31_p1;\n        end\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_return_3_preg\n    if (ap_rst == 1'b1) begin\n        ap_return_3_preg <= ap_const_lv12_0;\n    end else begin\n        if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n            ap_return_3_preg <= img_0_cols_V_fu_35_p1;\n        end\n    end\nend\n\nalways @ (ap_done_reg or ap_sig_cseq_ST_st1_fsm_0 or ap_sig_bdd_38)\nbegin\n    if (((ap_const_logic_1 == ap_done_reg) | ((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38))) begin\n        ap_done = ap_const_logic_1;\n    end else begin\n        ap_done = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_start or ap_sig_cseq_ST_st1_fsm_0)\nbegin\n    if ((~(ap_const_logic_1 == ap_start) & (ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0))) begin\n        ap_idle = ap_const_logic_1;\n    end else begin\n        ap_idle = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_sig_cseq_ST_st1_fsm_0 or ap_sig_bdd_38)\nbegin\n    if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n        ap_ready = ap_const_logic_1;\n    end else begin\n        ap_ready = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_sig_cseq_ST_st1_fsm_0 or ap_sig_bdd_38 or img_0_rows_V_fu_31_p1 or ap_return_0_preg)\nbegin\n    if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n        ap_return_0 = img_0_rows_V_fu_31_p1;\n    end else begin\n        ap_return_0 = ap_return_0_preg;\n    end\nend\n\nalways @ (ap_sig_cseq_ST_st1_fsm_0 or ap_sig_bdd_38 or img_0_cols_V_fu_35_p1 or ap_return_1_preg)\nbegin\n    if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n        ap_return_1 = img_0_cols_V_fu_35_p1;\n    end else begin\n        ap_return_1 = ap_return_1_preg;\n    end\nend\n\nalways @ (ap_sig_cseq_ST_st1_fsm_0 or ap_sig_bdd_38 or img_0_rows_V_fu_31_p1 or ap_return_2_preg)\nbegin\n    if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n        ap_return_2 = img_0_rows_V_fu_31_p1;\n    end else begin\n        ap_return_2 = ap_return_2_preg;\n    end\nend\n\nalways @ (ap_sig_cseq_ST_st1_fsm_0 or ap_sig_bdd_38 or img_0_cols_V_fu_35_p1 or ap_return_3_preg)\nbegin\n    if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~ap_sig_bdd_38)) begin\n        ap_return_3 = img_0_cols_V_fu_35_p1;\n    end else begin\n        ap_return_3 = ap_return_3_preg;\n    end\nend\n\nalways @ (ap_sig_bdd_20)\nbegin\n    if (ap_sig_bdd_20) begin\n        ap_sig_cseq_ST_st1_fsm_0 = ap_const_logic_1;\n    end else begin\n        ap_sig_cseq_ST_st1_fsm_0 = ap_const_logic_0;\n    end\nend\nalways @ (ap_CS_fsm or ap_sig_bdd_38)\nbegin\n    case (ap_CS_fsm)\n        ap_ST_st1_fsm_0 : \n        begin\n            ap_NS_fsm = ap_ST_st1_fsm_0;\n        end\n        default : \n        begin\n            ap_NS_fsm = 'bx;\n        end\n    endcase\nend\n\n\nalways @ (ap_CS_fsm)\nbegin\n    ap_sig_bdd_20 = (ap_CS_fsm[ap_const_lv32_0] == ap_const_lv1_1);\nend\n\nalways @ (ap_start or ap_done_reg)\nbegin\n    ap_sig_bdd_38 = ((ap_start == ap_const_logic_0) | (ap_done_reg == ap_const_logic_1));\nend\nassign img_0_cols_V_fu_35_p1 = cols[11:0];\nassign img_0_rows_V_fu_31_p1 = rows[11:0];\n\n\nendmodule ",
        "module_name": "image_filter_Block_proc",
        "module_hash": "731d25a3579a7b454b0138d07f952aef",
        "dataset_index": 25647
      },
      "xor_reset_a5631328": {
        "rtl_code": "module xor_reset (\n    input in1,\n    input in2,\n    input reset,\n    output reg out1\n);\n\nalways @(*) begin\n    if (reset) begin\n        out1 <= 1'b0;\n    end else begin\n        out1 <= in1 ^ in2;\n    end\nend\n\nendmodule",
        "module_name": "xor_reset",
        "module_hash": "a5631328b0ba630da12c44ab6ad23f79",
        "dataset_index": 5296
      },
      "half_adder_81b264c3": {
        "rtl_code": "\n\n\n\n\n\n\n\n\nmodule half_adder(output S, C, input A, B);\n\txor sum(S,A,B);\n\tand carry(C,A,B);\nendmodule\n\nmodule full_adder(output S, Cout, input A,B,Cin);\n\twire s1, c1, c2;\n\thalf_adder ha1(s1,c1, A ,B  ),\n\t\tha2(S ,c2, s1,Cin);\n\tor carry(Cout, c1,c2);\nendmodule\n\nmodule r4_adder(output [3:0]S, output Cout, input [3:0]A, B, input Cin);\n\twire c1, c2, c3;\n\n\tfull_adder fa1(S[0], c1,   A[0], B[0], Cin),\n\t\tfa2(S[1], c2,   A[1], B[1], c1),\n\t\tfa3(S[2], c3,   A[2], B[2], c2),\n\t\tfa4(S[3], Cout, A[3], B[3], c3);\nendmodule\n\nmodule r16_adder(output [15:0]S, output Cout, input [15:0] A, B, input Cin);\n\twire c1, c2, c3;\n\tr4_adder a1(S[ 3: 0], c1,   A[ 3: 0], B[ 3: 0], Cin),\n\t         a2(S[ 7: 4], c2,   A[ 7: 4], B[ 7: 4], c1),\n\t         a3(S[11: 8], c3,   A[11: 8], B[11: 8], c2),\n\t         a4(S[15:12], Cout, A[15:12], B[15:12], c3);\nendmodule\n\n\n\n",
        "module_name": "half_adder",
        "module_hash": "81b264c3268a467a63dfca00bc666fdc",
        "dataset_index": 8954
      },
      "my__13ff166b": {
        "rtl_code": "\nmodule my_module (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Gate level implementation.\n    wire X_int;\n    nand2 nand2_1 (\n        .A1(A1),\n        .A2(A2),\n        .Y(X_int)\n    );\n    nor2 nor2_1 (\n        .A1(B1),\n        .A2(C1),\n        .Y(X)\n    );\n\nendmodule\n\nmodule nand2 (\n    A1,\n    A2,\n    Y\n);\n\n    input A1, A2;\n    output Y;\n\n    assign Y = ~(A1 & A2);\n\nendmodule\n\nmodule nor2 (\n    A1,\n    A2,\n    Y\n);\n\n    input A1, A2;\n    output Y;\n\n    assign Y = ~(A1 | A2);\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "13ff166b545c5690241090e0fdfdc423",
        "dataset_index": 3349
      },
      "multiply_and_min_b0ed3948": {
        "rtl_code": "module multiply_and_min (\n    input clk,\n    input reset,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] a, b, c, d,\n    output [15:0] out,\n    output [7:0] out_lo,\n    output [7:0] final_out\n);\n\n    // Multiplication module\n    reg [15:0] mult_result;\n    reg [7:0] mult_lo;\n    reg [3:0] i;\n    always @ (posedge clk) begin\n        if (reset) begin\n            mult_result <= 16'b0;\n            mult_lo <= 8'b0;\n            i <= 4'b0;\n        end else begin\n            mult_result <= {8'b0, in1} * {8'b0, in2};\n            for (i = 0; i < 8; i = i + 1) begin\n                mult_result <= mult_result + (mult_lo << 8);\n                mult_lo <= mult_result[7:0];\n            end\n        end\n    end\n    assign out = mult_result;\n    assign out_lo = mult_lo;\n\n    // Minimum value module\n    reg [7:0] min_val;\n    always @ (a or b or c or d) begin\n        if (a <= b && a <= c && a <= d) begin\n            min_val <= a;\n        end else if (b <= c && b <= d) begin\n            min_val <= b;\n        end else if (c <= d) begin\n            min_val <= c;\n        end else begin\n            min_val <= d;\n        end\n    end\n    assign final_out = min_val + out_lo;\n\nendmodule",
        "module_name": "multiply_and_min",
        "module_hash": "b0ed3948d9698232724e5c9c5beab6d9",
        "dataset_index": 3969
      },
      "MODE0_36a070fe": {
        "rtl_code": "module MODE0(outR, outI, a, b);\n\ninput [15:0] a, b;\noutput signed [17:0] outR, outI;\n\nwire signed [7:0] aR, aI;\nwire signed [7:0] bR, bI;\nwire signed [17:0] r1, r2;\nwire signed [17:0] i1, i2;\n\nassign aR = a[15:8]; assign aI = a[7:0];\nassign bR = b[15:8]; assign bI = b[7:0];\nassign r1 = aR*bR; assign r2 = aI*bI;\nassign i1 = aR*bI; assign i2 = aI*bR;\n\nassign outR = r1 - r2;\nassign outI = i1 + i2;\n\nendmodule\n\nmodule Online_test2(\t\n\tclk, \n\trst_n, \n\tin_valid, \n\tin,\n\tin_mode,\t\n\tout_valid, \n\tout\n);\n\t\t\t\t\ninput              clk;\ninput              rst_n;\ninput              in_valid;\ninput \t[15:0]     in;\ninput \t           in_mode;\noutput reg         out_valid;\noutput reg [35:0]  out;\n\nreg inMod;\nreg rstState;\nreg [5:0] cnt1, cnt2;\nreg [15:0] a0, b0, a1, b1;\nreg signed [17:0] rea, img;\nreg [35:0] o0, o2, o4, o6, o8, o10;\n\nwire signed [17:0] m00R, m00I, m01R, m01I, m10R, m10I, m11R, m11I;\nwire [3:0] a01, a02, a03, a04;\nwire [3:0] a11, a12, a13, a14;\nwire [3:0] b01, b02, b03, b04;\nwire [3:0] b11, b12, b13, b14;\n\nMODE0 m00(m00R,m00I,a0,b0);\nMODE0 m01(m01R,m01I,a0,b1);\nMODE0 m10(m10R,m10I,a1,b0);\nMODE0 m11(m11R,m11I,a1,b1);\n \nassign a01 = a0[15:12]; assign a02 = a0[11:8]; assign a03 = a0[7:4]; assign a04 = a0[3:0];\nassign a11 = a1[15:12]; assign a12 = a1[11:8]; assign a13 = a1[7:4]; assign a14 = a1[3:0];\nassign b01 = b0[15:12]; assign b02 = b0[11:8]; assign b03 = b0[7:4]; assign b04 = b0[3:0];\nassign b11 = b1[15:12]; assign b12 = b1[11:8]; assign b13 = b1[7:4]; assign b14 = b1[3:0];\n\nalways@(posedge clk) begin\n\tif(in_mode == 1) inMod = 1; else;\n\tif(in_mode == 0) inMod = 0; else;\n\tif(rst_n == 1 || rstState == 1) begin\n\t\tout_valid = 0;\n\t\tout = 0;\n\t\trstState = 0;\n\t\tcnt1 = 0;\n\t\tcnt2 = 0;\n\t\to0 = 0; o2 = 0; o4 = 0; o6 = 0; o8 = 0; o10 = 0;\n\tend\n\telse;\n\tif(in_valid == 1) begin\n\t\tcnt1 = cnt1+1;\n\t\tcase(cnt1)\n\t\t\t1: a0 = in;\n\t\t\t2: a1 = in;\n\t\t\t3: b0 = in;\n\t\t\t4: b1 = in;\n\t\t\tdefault:;\n\t\tendcase\n\tend\n\telse;\n\tif(cnt1 > 0 && in_valid == 0) begin\n\t\tcnt2 = cnt2+1;\n\t\tcase(inMod)\n\t\t\t0: begin\n\t\t\t\tcase(cnt2)\n\t\t\t\t\t1: begin\n\t\t\t\t\t\tout[35:18] = m00R;\n\t\t\t\t\t\tout[17:0] = m00I;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\t2: begin\n\t\t\t\t\t\trea = m01R + m10R;\n\t\t\t\t\t\timg = m01I + m10I;\n\t\t\t\t\t\tout[35:18] = rea;\n\t\t\t\t\t\tout[17:0] = img;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\t3: begin\n\t\t\t\t\t\tout[35:18] = m11R;\n\t\t\t\t\t\tout[17:0] = m11I;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\tdefault: begin\n\t\t\t\t\t\trstState = 1;\n\t\t\t\t\t\tout_valid = 0;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t1: begin\n\t\t\t\tcase(cnt2)\n\t\t\t\t\t1: begin\n\t\t\t\t\t\tcase(a01)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a02)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a03)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a04)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a11)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a12)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a13)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a14)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b01)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b02)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b03)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b04)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b11)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b12)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b13)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(b14)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\t\tcase(a01)\n\t\t\t\t\t\t\t0: o0 = o0+1;\n\t\t\t\t\t\t\t2: o2 = o2+1;\n\t\t\t\t\t\t\t4: o4 = o4+1;\n\t\t\t\t\t\t\t6: o6 = o6+1;\n\t\t\t\t\t\t\t8: o8 = o8+1;\n\t\t\t\t\t\t\t10: o10 = o10+1;\n\t\t\t\t\t\tendcase\n\t\t\t\t\tend\n\t\t\t\t\t2: begin\n\t\t\t\t\t\tout = o0;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\t3: begin\n\t\t\t\t\t\tout = o2;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\t4: begin\n\t\t\t\t\t\tout = o4;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\t5: begin\n\t\t\t\t\t\tout = o6;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\t6: begin\n\t\t\t\t\t\tout = o8;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\t7: begin\n\t\t\t\t\t\tout = o10;\n\t\t\t\t\t\tout_valid = 1;\n\t\t\t\t\tend\n\t\t\t\t\tdefault: begin\n\t\t\t\t\t\trstState = 1;\n\t\t\t\t\t\tout_valid = 0;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\tdefault:;\n\t\tendcase\n\tend\n\telse;\nend\n\nendmodule\n",
        "module_name": "MODE0",
        "module_hash": "36a070fea15ffac6575eade671bf8bae",
        "dataset_index": 7919
      },
      "Test_53d2da77": {
        "rtl_code": "module Test (\n   input [3:0] cnt,\n   input [6:0] decr,\n   output [3:0] next\n);\n\n   // Implement the Test module here\n   reg [3:0] next_reg;\n\n   always @(*) begin\n      next_reg = cnt ^ decr[3:0];\n   end\n\n   assign next = next_reg;\n\nendmodule\n\n",
        "module_name": "Test",
        "module_hash": "53d2da771600703d7c3a1247010f50e0",
        "dataset_index": 19004
      },
      "imuldiv_IntMulVariable_5b4eb99e": {
        "rtl_code": "`ifndef PARC_INT_MUL_VARIABLE_V\n`define PARC_INT_MUL_VARIABLE_V\n\nmodule imuldiv_IntMulVariable\n(\n  input         clk,\n  input         reset,\n\n  input  [31:0] mulreq_msg_a,\n  input  [31:0] mulreq_msg_b,\n  input         mulreq_val,\n  output        mulreq_rdy,\n\n  output [31:0] mulresp_msg_result,\n  output        mulresp_val,\n  input         mulresp_rdy\n);\n\n  wire          sign;\n  wire   [31:0] b_data;\n  wire          sign_en;\n  wire          result_en;\n  wire          a_mux_sel;\n  wire          b_mux_sel;\n  wire    [4:0] op_shamt;\n  wire          result_mux_sel;\n  wire          add_mux_sel;\n  wire          sign_mux_sel;\n\n  wire   [63:0] dpath_out;\n  assign mulresp_msg_result = dpath_out[31:0];\n\n  imuldiv_IntMulVariableDpath dpath\n  (\n    .clk                (clk),\n    .reset              (reset),\n    .mulreq_msg_a       (mulreq_msg_a),\n    .mulreq_msg_b       (mulreq_msg_b),\n    .mulresp_msg_result (dpath_out),\n    .sign               (sign),\n    .b_data             (b_data),\n    .sign_en            (sign_en),\n    .result_en          (result_en),\n    .a_mux_sel          (a_mux_sel),\n    .b_mux_sel          (b_mux_sel),\n    .op_shamt           (op_shamt),\n    .result_mux_sel     (result_mux_sel),\n    .add_mux_sel        (add_mux_sel),\n    .sign_mux_sel       (sign_mux_sel)\n  );\n\n  imuldiv_IntMulVariableCtrl ctrl\n  (\n    .clk            (clk),\n    .reset          (reset),\n    .mulreq_val     (mulreq_val),\n    .mulreq_rdy     (mulreq_rdy),\n    .mulresp_val    (mulresp_val),\n    .mulresp_rdy    (mulresp_rdy),\n    .sign           (sign),\n    .b_data         (b_data),\n    .sign_en        (sign_en),\n    .result_en      (result_en),\n    .a_mux_sel      (a_mux_sel),\n    .b_mux_sel      (b_mux_sel),\n    .op_shamt       (op_shamt),\n    .result_mux_sel (result_mux_sel),\n    .add_mux_sel    (add_mux_sel),\n    .sign_mux_sel   (sign_mux_sel)\n  );\n\nendmodule\n\nmodule imuldiv_IntMulVariableDpath\n(\n  input                clk,\n  input                reset,\n\n  input  [31:0] mulreq_msg_a,\n  input  [31:0] mulreq_msg_b,\n  output [63:0] mulresp_msg_result,\n\n  output        sign,\n  output [31:0] b_data,\n\n  input         sign_en,\n  input         result_en,\n  input         a_mux_sel,\n  input         b_mux_sel,\n  input   [4:0] op_shamt,\n  input         result_mux_sel,\n  input         add_mux_sel,\n  input         sign_mux_sel\n);\n\n  localparam op_x     = 1'dx;\n  localparam op_load  = 1'd0;\n  localparam op_next  = 1'd1;\n\n  localparam add_x    = 1'dx;\n  localparam add_old  = 1'd0;\n  localparam add_next = 1'd1;\n\n  localparam sign_x   = 1'dx;\n  localparam sign_u   = 1'd0;\n  localparam sign_s   = 1'd1;\n\n  reg         sign_reg;\n  wire [63:0] a_shift_out;\n  wire [31:0] b_shift_out;\n  wire [63:0] result_mux_out;\n  wire [63:0] signed_result_mux_out;\n\n  wire   sign_next = mulreq_msg_a[31] ^ mulreq_msg_b[31];\n\n  assign sign      = sign_reg;\n\n  wire [31:0] unsigned_a\n    = ( mulreq_msg_a[31] ) ? ~mulreq_msg_a + 1'b1\n    :                         mulreq_msg_a;\n\n  wire [31:0] unsigned_b\n    = ( mulreq_msg_b[31] ) ? ~mulreq_msg_b + 1'b1\n    :                         mulreq_msg_b;\n\n  wire [63:0] a_mux_out\n    = ( a_mux_sel == op_load ) ? { 32'b0, unsigned_a }\n    : ( a_mux_sel == op_next ) ? a_shift_out\n    :                            64'bx;\n\n  wire [31:0]   b_mux_out\n    = ( b_mux_sel == op_load ) ? unsigned_b\n    : ( b_mux_sel == op_next ) ? b_shift_out\n    :                            32'bx;\n\n  reg [63:0] a_reg;\n  reg [31:0] b_reg;\n  reg [63:0] result_reg;\n\n  always @ ( posedge clk ) begin\n    if ( sign_en ) begin\n      sign_reg   <= sign_next;\n    end\n\n    if ( result_en ) begin\n      result_reg <= result_mux_out;\n    end\n\n    a_reg        <= a_mux_out;\n    b_reg        <= b_mux_out;\n  end\n\n  assign b_data = b_reg;\n\n  assign a_shift_out = a_reg << op_shamt;\n\n  assign b_shift_out = b_reg >> op_shamt;\n\n  wire [63:0] add_out = result_reg + a_reg;\n\n  wire [63:0] add_mux_out\n    = ( add_mux_sel == add_old )  ? result_reg\n    : ( add_mux_sel == add_next ) ? add_out\n    :                               64'bx;\n\n  assign result_mux_out\n    = ( result_mux_sel == op_load ) ? 64'b0\n    : ( result_mux_sel == op_next ) ? add_mux_out\n    :                                 64'bx;\n\n  assign signed_result_mux_out\n    = ( sign_mux_sel == sign_u ) ? result_reg\n    : ( sign_mux_sel == sign_s ) ? ~result_reg + 1'b1\n    :                              64'bx;\n\n  assign mulresp_msg_result = signed_result_mux_out;\n\nendmodule\n\nmodule imuldiv_IntMulVariableCtrl\n(\n  input        clk,\n  input        reset,\n\n  input        mulreq_val,\n  output       mulreq_rdy,\n\n  output       mulresp_val,\n  input        mulresp_rdy,\n\n  input        sign,\n  input [31:0] b_data,\n\n  output       sign_en,\n  output       result_en,\n  output       a_mux_sel,\n  output       b_mux_sel,\n  output [4:0] op_shamt,\n  output       result_mux_sel,\n  output       add_mux_sel,\n  output       sign_mux_sel\n);\n\n  localparam STATE_IDLE = 2'd0;\n  localparam STATE_CALC = 2'd1;\n  localparam STATE_SIGN = 2'd2;\n\n  reg [1:0] state_reg;\n  reg [1:0] state_next;\n\n  always @ ( posedge clk ) begin\n    if ( reset ) begin\n      state_reg <= STATE_IDLE;\n    end\n    else begin\n      state_reg <= state_next;\n    end\n  end\n\n  wire mulreq_go;\n  wire mulresp_go;\n  wire is_calc_done;\n\n  always @ ( * ) begin\n\n    state_next = state_reg;\n\n    case ( state_reg )\n\n      STATE_IDLE:\n        if ( mulreq_go ) begin\n          state_next = STATE_CALC;\n        end\n\n      STATE_CALC:\n        if ( is_calc_done ) begin\n          state_next = STATE_SIGN;\n        end\n\n      STATE_SIGN:\n        if ( mulresp_go ) begin\n          state_next = STATE_IDLE;\n        end\n\n    endcase\n\n  end\n\n  localparam n = 1'd0;\n  localparam y = 1'd1;\n\n  localparam op_x    = 1'dx;\n  localparam op_load = 1'd0;\n  localparam op_next = 1'd1;\n\n  localparam cs_size = 7;\n  reg [cs_size-1:0] cs;\n\n  always @ ( * ) begin\n\n    cs = 7'b0;\n\n    case ( state_reg )\n\n      STATE_IDLE: cs = { y,     n,      y,   y,     op_load, op_load, op_load };\n      STATE_CALC: cs = { n,     n,      n,   y,     op_next, op_next, op_next };\n      STATE_SIGN: cs = { n,     y,      n,   n,     op_x,    op_x,    op_x    };\n\n    endcase\n\n  end\n\n  wire b_lsb = b_data[0];\n\n  assign mulreq_rdy     = cs[6];\n  assign mulresp_val    = cs[5];\n  assign sign_en        = cs[4];\n  assign result_en      = cs[3];\n  assign a_mux_sel      = cs[2];\n  assign b_mux_sel      = cs[1];\n  assign result_mux_sel = cs[0];\n  assign add_mux_sel    = b_lsb;\n  assign sign_mux_sel   = sign;\n\n  wire [31:0] in_bits = b_data >> 1;\n  wire        out_val;\n  wire [4:0]  out_bits;\n\n  vc_32_5_ReversePriorityEncoder encoder\n  (\n    .in_bits  (in_bits),\n    .out_val  (out_val),\n    .out_bits (out_bits)\n  );\n\n  assign op_shamt = out_bits + 5'b1;\n\n  assign mulreq_go     = mulreq_val && mulreq_rdy;\n  assign mulresp_go    = mulresp_val && mulresp_rdy;\n\n  assign is_calc_done  = ( ( b_data >> 1 ) == 32'b0 );\n\nendmodule\n\nmodule vc_32_5_ReversePriorityEncoder\n(\n  input  [31:0] in_bits,\n  output        out_val,\n  output  [4:0] out_bits\n);\n\n  assign out_val = ( in_bits != 32'b0 );\n\n  assign out_bits =\n    ( in_bits[ 0] ) ? 5'b00000\n  : ( in_bits[ 1] ) ? 5'b00001\n  : ( in_bits[ 2] ) ? 5'b00010\n  : ( in_bits[ 3] ) ? 5'b00011\n  : ( in_bits[ 4] ) ? 5'b00100\n  : ( in_bits[ 5] ) ? 5'b00101\n  : ( in_bits[ 6] ) ? 5'b00110\n  : ( in_bits[ 7] ) ? 5'b00111\n  : ( in_bits[ 8] ) ? 5'b01000\n  : ( in_bits[ 9] ) ? 5'b01001\n  : ( in_bits[10] ) ? 5'b01010\n  : ( in_bits[11] ) ? 5'b01011\n  : ( in_bits[12] ) ? 5'b01100\n  : ( in_bits[13] ) ? 5'b01101\n  : ( in_bits[14] ) ? 5'b01110\n  : ( in_bits[15] ) ? 5'b01111\n  : ( in_bits[16] ) ? 5'b10000\n  : ( in_bits[17] ) ? 5'b10001\n  : ( in_bits[18] ) ? 5'b10010\n  : ( in_bits[19] ) ? 5'b10011\n  : ( in_bits[20] ) ? 5'b10100\n  : ( in_bits[21] ) ? 5'b10101\n  : ( in_bits[22] ) ? 5'b10110\n  : ( in_bits[23] ) ? 5'b10111\n  : ( in_bits[24] ) ? 5'b11000\n  : ( in_bits[25] ) ? 5'b11001\n  : ( in_bits[26] ) ? 5'b11010\n  : ( in_bits[27] ) ? 5'b11011\n  : ( in_bits[28] ) ? 5'b11100\n  : ( in_bits[29] ) ? 5'b11101\n  : ( in_bits[30] ) ? 5'b11110\n  : ( in_bits[31] ) ? 5'b11111\n  :                   5'b00000;\n\nendmodule\n\n\n`endif\n",
        "module_name": "imuldiv_IntMulVariable",
        "module_hash": "5b4eb99e807b97909c97c3a2c8e5902a",
        "dataset_index": 20831
      },
      "dual_port_mem_84af9096": {
        "rtl_code": "`define DATA_WIDTH 32 \n\nmodule dual_port_mem(\n    input clk,\n    input r_en1,\n    input [1:0] r_addr1,\n    input r_en2,\n    input [1:0] r_addr2,\n    input w_en,\n    input [1:0] w_addr,\n    input [2*(`DATA_WIDTH+1)-1:0] w_data,\n    output reg [2*(`DATA_WIDTH+1)-1:0] r_data1,\n    output reg [2*(`DATA_WIDTH+1)-1:0] r_data2\n);\n\n    reg [2*(`DATA_WIDTH+1)-1:0] mem [0:3];\n\n    always @(posedge clk) begin\n        if (r_en1 && r_en2) begin\n            r_data1 <= mem[r_addr1];\n            r_data2 <= mem[r_addr2];\n        end else if (r_en1) begin\n            r_data1 <= mem[r_addr1];\n            r_data2 <= 0;\n        end else if (r_en2) begin\n            r_data1 <= 0;\n            r_data2 <= mem[r_addr2];\n        end\n\n        if (w_en) begin\n            mem[w_addr] <= w_data;\n        end\n    end\n\nendmodule",
        "module_name": "dual_port_mem",
        "module_hash": "84af9096a52e1ac0cd823c016badde11",
        "dataset_index": 18009
      },
      "characters_cbae9639": {
        "rtl_code": "\nmodule characters(select,vec_char);\n\tinput [7:0] select ;\n\toutput reg [39:0] vec_char;\n\t\n\twire [39:0]vect_char_a;wire [39:0]vect_char_b;\n\twire [39:0]vect_char_c;\n\twire [39:0]vect_char_d;\n\twire [39:0]vect_char_e;\n\twire [39:0]vect_char_f;\n\twire [39:0]vect_char_g;\n\twire [39:0]vect_char_h;\n\twire [39:0]vect_char_i;\n\twire [39:0]vect_char_j;\n\twire [39:0]vect_char_k;\n\twire [39:0]vect_char_l;\n\twire [39:0]vect_char_m;\n\twire [39:0]vect_char_n;\n\twire [39:0]vect_char_o;\n\twire [39:0]vect_char_p;\n\twire [39:0]vect_char_q;\n\twire [39:0]vect_char_r;\n\twire [39:0]vect_char_s;\n\twire [39:0]vect_char_t;\n\twire [39:0]vect_char_u;\n\twire [39:0]vect_char_v;\n\twire [39:0]vect_char_w;\n\twire [39:0]vect_char_x;\n\twire [39:0]vect_char_y;\n\twire [39:0]vect_char_z;\nwire [39:0]vect_num_0;wire [39:0]vect_num_1;\n\twire [39:0]vect_num_2;\n\twire [39:0]vect_num_3;\n\twire [39:0]vect_num_4;\n\twire [39:0]vect_num_5;\n\twire [39:0]vect_num_6;\n\twire [39:0]vect_num_7;\n\twire [39:0]vect_num_8;\n\twire [39:0]vect_num_9;\n\twire [39:0]vect_num_p;\n\t\n\twire [39:0]vect_op_suma;\n\twire [39:0]vect_op_mult;\n\twire [39:0]vect_op_resta;\n\twire [39:0]vect_op_AND;\n\twire [39:0]vect_op_OR;\n\twire [39:0]vect_char_E;\n\twire [39:0]vect_char_X;\n\twire [39:0]vect_char_C;\n\twire [39:0]vect_char_space;\n\twire [39:0]vect_char_D;\n\twire [39:0]vect_char_H;\n\t\n\tassign vect_char_a={5'b00000,5'b11110,5'b10001,5'b11110,5'b10000,5'b01110,5'b00000,5'b00000};\n\tassign vect_char_b={5'b00000,5'b01111,5'b10001,5'b10001,5'b10011,5'b01101,5'b00001,5'b00001};\n\tassign vect_char_c={5'b00000,5'b01110,5'b10001,5'b00001,5'b00001,5'b01110,5'b00000,5'b00000};\n\tassign vect_char_d={5'b00000,5'b11110,5'b10001,5'b10001,5'b11001,5'b10110,5'b10000,5'b10000};\n\tassign vect_char_e={5'b00000,5'b01110,5'b00001,5'b11111,5'b10001,5'b01110,5'b00000,5'b00000};\n\tassign vect_char_f={5'b00000,5'b00010,5'b00010,5'b00010,5'b00111,5'b00010,5'b10010,5'b01100};\n\tassign vect_char_g={5'b00000,5'b01110,5'b10000,5'b11110,5'b10001,5'b10001,5'b11110,5'b00000};\n\tassign vect_char_h={5'b00000,5'b10001,5'b10001,5'b10001,5'b10011,5'b01101,5'b00001,5'b00001};\n\tassign vect_char_i={5'b00000,5'b01110,5'b00100,5'b00100,5'b00100,5'b00110,5'b00000,5'b00100};\n\tassign vect_char_j={5'b00000,5'b00110,5'b01001,5'b01000,5'b01000,5'b01100,5'b00000,5'b01000};\n\tassign vect_char_k={5'b00000,5'b01001,5'b00101,5'b00011,5'b00101,5'b01001,5'b00001,5'b00001};\n\tassign vect_char_l={5'b00000,5'b01110,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00110};\n\tassign vect_char_m={5'b00000,5'b10001,5'b10001,5'b10101,5'b10101,5'b01011,5'b00000,5'b00000};\n\tassign vect_char_n={5'b00000,5'b10001,5'b10001,5'b10001,5'b10011,5'b01101,5'b00000,5'b00000};\n\tassign vect_char_o={5'b00000,5'b01110,5'b10001,5'b10001,5'b10001,5'b01110,5'b00000,5'b00000};\n\tassign vect_char_p={5'b00000,5'b00001,5'b00001,5'b01111,5'b10001,5'b01111,5'b00000,5'b00000};\n\tassign vect_char_q={5'b00000,5'b10000,5'b10000,5'b11110,5'b11001,5'b10110,5'b00000,5'b00000};\n\tassign vect_char_r={5'b00000,5'b00001,5'b00001,5'b00001,5'b10011,5'b01101,5'b00000,5'b00000};\n\tassign vect_char_s={5'b00000,5'b01111,5'b10000,5'b01110,5'b00001,5'b01110,5'b00000,5'b00000};\n\tassign vect_char_t={5'b00000,5'b01100,5'b10010,5'b00010,5'b00010,5'b00111,5'b00010,5'b00010};\n\tassign vect_char_u={5'b00000,5'b10110,5'b11001,5'b10001,5'b10001,5'b10001,5'b00000,5'b00000};\n\tassign vect_char_v={5'b00000,5'b00100,5'b01010,5'b10001,5'b10001,5'b10001,5'b00000,5'b00000};\n\tassign vect_char_w={5'b00000,5'b01010,5'b10101,5'b10101,5'b10001,5'b10001,5'b00000,5'b00000};\n\tassign vect_char_x={5'b00000,5'b10001,5'b01010,5'b00100,5'b01010,5'b10001,5'b00000,5'b00000};\n\tassign vect_char_y={5'b00000,5'b01110,5'b10000,5'b11110,5'b10001,5'b10001,5'b00000,5'b00000};\n\tassign vect_char_z={5'b00000,5'b11111,5'b00010,5'b00100,5'b01000,5'b11111,5'b00000,5'b00000};\n\tassign vect_char_E={5'b00000,5'b11111,5'b00001,5'b00001,5'b01111,5'b00001,5'b00001,5'b11111};\n    assign vect_char_C={5'b00000,5'b01110,5'b10001,5'b00001,5'b00001,5'b00001,5'b10001,5'b01110};\n    assign vect_char_X={5'b00000,5'b10001,5'b10001,5'b01010,5'b00100,5'b01010,5'b10001,5'b10001};\n    assign vect_char_space={5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000};\n    assign vect_char_D={5'b00000,5'b00111,5'b01001,5'b10001,5'b10001,5'b10001,5'b01001,5'b00111};\n    assign vect_char_H={5'b00000,5'b10001,5'b10001,5'b10001,5'b11111,5'b10001,5'b10001,5'b10001};\n\n\n\tassign vect_op_AND={5'b00000,5'b10110,5'b01001,5'b10101,5'b00010,5'b00101,5'b01001,5'b00110};\n    assign vect_op_mult={5'b00000,5'b00100,5'b10101,5'b01110,5'b10101,5'b00100,5'b00000,5'b00000};\n    assign vect_op_suma={5'b00000,5'b00100,5'b00100,5'b11111,5'b00100,5'b00100,5'b00000,5'b00000};\n    assign vect_op_OR={5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100};\n    assign vect_op_resta={5'b00000,5'b00000,5'b00000,5'b11111,5'b00000,5'b00000,5'b00000,5'b00000};\n\n\tassign vect_num_0={5'b00000,5'b01110,5'b10001,5'b10011,5'b10101,5'b11001,5'b10001,5'b01110};\n\tassign vect_num_1={5'b00000,5'b01110,5'b00100,5'b00100,5'b00100,5'b00100,5'b00110,5'b00100};\n\tassign vect_num_2={5'b00000,5'b11111,5'b00010,5'b00100,5'b01000,5'b10000,5'b10001,5'b01110};\n\tassign vect_num_3={5'b00000,5'b01110,5'b10001,5'b10000,5'b01000,5'b00100,5'b01000,5'b11111};\n\tassign vect_num_4={5'b00000,5'b01000,5'b01000,5'b11111,5'b01001,5'b01010,5'b01100,5'b01000};\n\tassign vect_num_5={5'b00000,5'b0110,5'b10001,5'b10000,5'b10000,5'b01111,5'b00010,5'b11111};\n    assign vect_num_6={5'b00000,5'b01110,5'b10001,5'b10001,5'b01111,5'b00001,5'b00010,5'b01100};\n    assign vect_num_7={5'b00000,5'b00010,5'b00010,5'b00010,5'b00100,5'b01000,5'b10000,5'b11111};\n    assign vect_num_8={5'b00000,5'b01110,5'b10001,5'b10001,5'b01110,5'b10001,5'b10001,5'b01110};\n    assign vect_num_9={5'b00000,5'b00110,5'b01000,5'b10000,5'b11110,5'b10001,5'b10001,5'b01110};\n    assign vect_num_p={5'b00000,5'b00110,5'b00110,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000};\n\n\talways@(*)\n\t\tcase(select)\n\t\t\t8'd0:vec_char=vect_num_0;\n\t\t\t8'd1:vec_char=vect_num_1;\n\t\t\t8'd2:vec_char=vect_num_2;\n\t\t\t8'd3:vec_char=vect_num_3;\n\t\t\t8'd4:vec_char=vect_num_4;\n\t\t\t8'd5:vec_char=vect_num_5;\n\t\t\t8'd6:vec_char=vect_num_6;\n\t\t\t8'd7:vec_char=vect_num_7;\n\t\t\t8'd8:vec_char=vect_num_8;\n\t\t\t8'd9:vec_char=vect_num_9;\n\t\t\t8'd46:vec_char=vect_num_p;\n\t\t\t\"+\":vec_char=vect_op_suma;\n\t\t\t\"*\":vec_char=vect_op_mult;\n\t\t\t\"-\":vec_char=vect_op_resta;\n\t\t\t\"|\":vec_char=vect_op_OR;\n\t\t\t\"&\":vec_char=vect_op_AND;\n\t\t\t\" \":vec_char=vect_char_space;\n\t\t\t8'd10:vec_char=vect_char_a;\n\t\t\t8'd11:vec_char=vect_char_b;\n\t\t\t8'd12:vec_char=vect_char_c;\n\t\t\t8'd13:vec_char=vect_char_d;\n\t\t\t8'd14:vec_char=vect_char_e;\n\t\t\t8'd15:vec_char=vect_char_f;\n\t\t\t8'd103:vec_char=vect_char_g;\n\t\t\t8'd104:vec_char=vect_char_h;\n\t\t\t8'd105:vec_char=vect_char_i;\n\t\t\t8'd106:vec_char=vect_char_j;\n\t\t\t8'd107:vec_char=vect_char_k;\n\t\t\t8'd108:vec_char=vect_char_l;\n\t\t\t8'd109:vec_char=vect_char_m;\n\t\t\t8'd110:vec_char=vect_char_n;\n\t\t\t8'd111:vec_char=vect_char_o;\n\t\t\t8'd112:vec_char=vect_char_p;\n\t\t\t8'd113:vec_char=vect_char_q;\n\t\t\t8'd114:vec_char=vect_char_r;\n\t\t\t8'd115:vec_char=vect_char_s;\n\t\t\t8'd116:vec_char=vect_char_t;\n\t\t\t8'd117:vec_char=vect_char_u;\n\t\t\t8'd118:vec_char=vect_char_v;\n\t\t\t8'd119:vec_char=vect_char_w;\n\t\t\t8'd120:vec_char=vect_char_x;\n\t\t\t8'd121:vec_char=vect_char_y;\n\t\t\t8'd122:vec_char=vect_char_z;\n\t\t8'd201:vec_char=vect_char_E;\n\t\t\t8'd199:vec_char=vect_char_C;\n\t\t\t8'd220:vec_char=vect_char_X;\n\t\t\t8'd200:vec_char=vect_char_D;\n\t\t\t8'd204:vec_char=vect_char_H;\n\t\t\t\n\t\t\tdefault :vec_char=vect_num_p;endcase\nendmodule\n\n",
        "module_name": "characters",
        "module_hash": "cbae96393c5b59c239f8ab688881bf6a",
        "dataset_index": 22159
      },
      "top__0faca15a": {
        "rtl_code": "module top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nreg [7:0] pipe1, pipe2, pipe3;\n\nalways @(posedge clk) begin\n    pipe1 <= in;\nend\n\nalways @(posedge clk) begin\n    pipe2 <= pipe1;\nend\n\nalways @(posedge clk) begin\n    pipe3 <= pipe2;\nend\n\nassign anyedge = (pipe1 ^ pipe2) & pipe2 & (pipe2 ^ pipe3);\n\nendmodule",
        "module_name": "top_",
        "module_hash": "0faca15a1825f382e40bf86896abbc60",
        "dataset_index": 6771
      },
      "ones_complement_1ff485a3": {
        "rtl_code": "module ones_complement(\n    input [3:0] in,\n    output [3:0] out\n);\n\nassign out = ~in;\n\n\nendmodule",
        "module_name": "ones_complement",
        "module_hash": "1ff485a36fff30fa2f32271a46d0e662",
        "dataset_index": 18011
      },
      "my__4034581e": {
        "rtl_code": "module my_module (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    // Module ports\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    // Local signals\n    wire and0_out  ;\n    wire and1_out  ;\n    wire and2_out  ;\n    wire nor0_out_Y;\n\n    //  Name  Output      Other arguments\n    and and0 (and0_out  , A1, A2         );\n    and and1 (and1_out  , and0_out, B1   );\n    and and2 (and2_out  , A1, B1         );\n    nor nor0 (nor0_out_Y, and1_out, and2_out);\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule",
        "module_name": "my_",
        "module_hash": "4034581edc4465b2aa0ef0007916f092",
        "dataset_index": 12891
      },
      "binary_counter_126c4cb6": {
        "rtl_code": "module binary_counter (\n  input clk,\n  input rst,\n  input [15:0] max_count,\n  output reg [15:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 16'b0000000000000000;\n    end else if (count == max_count) begin\n      count <= 16'b0000000000000000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "126c4cb60ec1d2ad72f08bc1b406217d",
        "dataset_index": 12503
      },
      "NegClockedOneShot_d9a91f3a": {
        "rtl_code": "module NegClockedOneShot(InputPulse, OneShot, Reset, CLOCK, Time);\n\ninput InputPulse, Reset, CLOCK;\ninput [7:0] Time;\noutput reg OneShot;\n\nparameter State0=0, State1=1, State2=2;\nreg [1:0] State;\nreg [7:0] Counter;\n\nalways @ (posedge CLOCK) begin\n    if (Reset == 1) begin\n        State <= State0;\n        Counter <= 0;\n    end\n    else begin\n        case (State)\n            State0: begin\n                if (InputPulse == 0) begin\n                    State <= State0;\n                    Counter <= 0;\n                end\n                else begin\n                    State <= State1;\n                    Counter <= 0;\n                end\n            end\n            State1: begin\n                if (Counter < Time) begin\n                    State <= State1;\n                    Counter <= Counter + 1;\n                end\n                else begin\n                    State <= State2;\n                    Counter <= 0;\n                end\n            end\n            State2: begin\n                State <= State0;\n                Counter <= 0;\n            end\n        endcase\n    end\nend\n\nalways @ (negedge InputPulse) begin\n    if (Reset == 1) begin\n        OneShot <= 0;\n    end\n    else begin\n        if (State == State1) begin\n            OneShot <= 1;\n        end\n        else begin\n            OneShot <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "NegClockedOneShot",
        "module_hash": "d9a91f3ab3aed719610fc074edb7c9c4",
        "dataset_index": 2082
      },
      "s8_3ec9e984": {
        "rtl_code": "\nmodule s8(stage1_input,stage1_output);\ninput [5:0] stage1_input;\noutput [3:0] stage1_output;\n\nreg [3:0] stage1_output;\n\n\n\nalways @(stage1_input)\n\nbegin\n\n   case(stage1_input)\n\n        0: stage1_output = (13); \n        1: stage1_output = (1); \n        2: stage1_output = (2); \n        3: stage1_output = (15); \n        4: stage1_output = (8); \n        5: stage1_output = (13); \n        6: stage1_output = (4); \n        7: stage1_output = (8); \n        8: stage1_output = (6); \n        9: stage1_output = (10); \n        10: stage1_output = (15); \n        11: stage1_output = (3); \n        12: stage1_output = (11); \n        13: stage1_output = (7); \n        14: stage1_output = (1); \n        15: stage1_output = (4); \n        16: stage1_output = (10); \n        17: stage1_output = (12); \n        18: stage1_output = (9); \n        19: stage1_output = (5); \n        20: stage1_output = (3); \n        21: stage1_output = (6); \n        22: stage1_output = (14); \n        23: stage1_output = (11); \n        24: stage1_output = (5); \n        25: stage1_output = (0); \n        26: stage1_output = (0); \n        27: stage1_output = (14); \n        28: stage1_output = (12); \n        29: stage1_output = (9); \n        30: stage1_output = (7); \n        31: stage1_output = (2); \n        32: stage1_output = (7); \n        33: stage1_output = (2); \n        34: stage1_output = (11); \n        35: stage1_output = (1); \n        36: stage1_output = (4); \n        37: stage1_output = (14); \n        38: stage1_output = (1); \n        39: stage1_output = (7); \n        40: stage1_output = (9); \n        41: stage1_output = (4); \n        42: stage1_output = (12); \n        43: stage1_output = (10); \n        44: stage1_output = (14); \n        45: stage1_output = (8); \n        46: stage1_output = (2); \n        47: stage1_output = (13); \n        48: stage1_output = (0); \n        49: stage1_output = (15); \n        50: stage1_output = (6); \n        51: stage1_output = (12); \n        52: stage1_output = (10); \n        53: stage1_output = (9); \n        54: stage1_output = (13); \n        55: stage1_output = (0); \n        56: stage1_output = (15); \n        57: stage1_output = (3); \n        58: stage1_output = (3); \n        59: stage1_output = (5); \n        60: stage1_output = (5); \n        61: stage1_output = (6); \n        62: stage1_output = (8); \n        63: stage1_output = (11); \n\nendcase\n\n\t\n\nend\n\nendmodule\n",
        "module_name": "s8",
        "module_hash": "3ec9e98406f689e0c6823162eebe6204",
        "dataset_index": 118
      },
      "add2_and_round_dfeb2964": {
        "rtl_code": "\nmodule add2_and_round\n  #(parameter WIDTH=16)\n    (input [WIDTH-1:0] in1,\n     input [WIDTH-1:0] in2,\n     output [WIDTH-1:0] sum);\n\n   wire [WIDTH:0] sum_int;\n   wire [WIDTH-1:0] sum_half;\n  // wire [WIDTH-1:0] sum_rounded;\n\n   assign sum_int = in1 + in2;\n   assign sum_half = sum_int[WIDTH-1:0] + (sum_int[WIDTH] ? 1 : 0);\n   assign sum = sum_half;\n\nendmodule\nmodule add2_and_round_reg\n  #(parameter WIDTH=16)\n    (input clk,\n     input [WIDTH-1:0] in1,\n     input [WIDTH-1:0] in2,\n     output reg [WIDTH-1:0] sum);\n\n   wire [WIDTH-1:0] sum_int;\n   \n   add2_and_round #(.WIDTH(WIDTH)) add2_n_rnd (.in1(in1),.in2(in2),.sum(sum_int));\n\n   always @(posedge clk)\n     sum <= sum_int;\n   \nendmodule",
        "module_name": "add2_and_round",
        "module_hash": "dfeb2964cc898d1ed9c45c3134d16071",
        "dataset_index": 20564
      },
      "comparator_4bit_05bbd0a6": {
        "rtl_code": "module comparator_4bit (\n  input clk,\n  input reset,\n  input [3:0] A,\n  input [3:0] B,\n  output reg greater,\n  output reg less,\n  output reg equal\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      greater <= 0;\n      less <= 0;\n      equal <= 0;\n    end\n    else begin\n      if (A > B) begin\n        greater <= 1;\n        less <= 0;\n        equal <= 0;\n      end\n      else if (A < B) begin\n        greater <= 0;\n        less <= 1;\n        equal <= 0;\n      end\n      else begin\n        greater <= 0;\n        less <= 0;\n        equal <= 1;\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "comparator_4bit",
        "module_hash": "05bbd0a643573b3fd37dd12858901e2c",
        "dataset_index": 450
      },
      "nkmd_progrom_648eb705": {
        "rtl_code": "\n\n\nmodule nkmd_progrom(\n    input wire clk,\n\n    output wire [31:0] data_o,\n    input wire [31:0] addr_i);\n\nreg [31:0] data_ff;\n\nalways @(posedge clk) begin\n    case (addr_i)\n16'h0000: data_ff <= 32'h00000000;\n16'h0001: data_ff <= 32'h00000000;\n16'h0002: data_ff <= 32'h00000000;\n16'h0003: data_ff <= 32'h00000000;\n16'h0004: data_ff <= 32'h01010001;\n16'h0005: data_ff <= 32'h02010002;\n16'h0006: data_ff <= 32'h03010003;\n16'h0007: data_ff <= 32'h04010004;\n16'h0008: data_ff <= 32'h05000100;\n16'h0009: data_ff <= 32'h06000200;\n16'h000a: data_ff <= 32'h07000300;\n16'h000b: data_ff <= 32'h08000400;\n16'h000c: data_ff <= 32'h80010004;\n16'h000d: data_ff <= 32'h00000000;\n16'h000e: data_ff <= 32'h00000000;\n16'h000f: data_ff <= 32'h00000000;\n16'h0010: data_ff <= 32'h00000000;\n\ndefault:  data_ff <= 32'h80010001;\n    endcase\nend\n\nassign data_o = data_ff;\n\nendmodule\n\n",
        "module_name": "nkmd_progrom",
        "module_hash": "648eb70584aa04335423c6e388cc67ef",
        "dataset_index": 19234
      },
      "SmallBpf_cfbeef82": {
        "rtl_code": "module SmallBpf (\n    input clk,         // System clock\n    input rst,         // Reset, active high and synchronous\n    input en,          // Filter enable\n    input signed [WIDTH-1:0] dataIn,  // [WIDTH-1:0] Filter input\n    output reg signed [WIDTH-1:0] dataOut  // [WIDTH-1:0] Filter output\n);\n\nparameter K0_SHIFT = 5; // K0 filter term = 2^-K0_SHIFT\nparameter K1_SHIFT = 5; // K1 filter term = 2^-K1_SHIFT\nparameter WIDTH = 16;   // Width of data path\nparameter CLAMP = 1;    // Set to 1 to clamp the accumulators\n\nreg signed [WIDTH-1:0] acc0; // First accumulator\nreg signed [WIDTH-1:0] acc1; // Second accumulator\nreg signed [WIDTH-1:0] acc2; // Third accumulator\nreg signed [WIDTH-1:0] acc3; // Fourth accumulator\n\nwire signed [WIDTH-1:0] dataInK0; // dataIn * K0\nwire signed [WIDTH-1:0] dataInK1; // dataIn * K1\nwire signed [WIDTH-1:0] acc0K0;   // acc0 * K0\nwire signed [WIDTH-1:0] acc1K1;   // acc1 * K1\nwire signed [WIDTH-1:0] acc2K0;   // acc2 * K0\nwire signed [WIDTH-1:0] acc3K1;   // acc3 * K1\n\n// Multiply dataIn by K0 and K1\nassign dataInK0 = dataIn << K0_SHIFT;\nassign dataInK1 = dataIn << K1_SHIFT;\n\n// Multiply accumulators by K0 and K1\nassign acc0K0 = acc0 << K0_SHIFT;\nassign acc1K1 = acc1 << K1_SHIFT;\nassign acc2K0 = acc2 << K0_SHIFT;\nassign acc3K1 = acc3 << K1_SHIFT;\n\n// BPF equations\nalways @(posedge clk) begin\n    if (rst) begin\n        acc0 <= 0;\n        acc1 <= 0;\n        acc2 <= 0;\n        acc3 <= 0;\n        dataOut <= 0;\n    end\n    else if (en) begin\n        acc0 <= dataInK0 - acc0K0 + acc1K1;\n        acc1 <= acc0K0 + acc1K1;\n        acc2 <= acc2K0 - acc3K1 + acc1;\n        acc3 <= acc3K1 + acc1;\n        if (CLAMP) begin\n            if (acc0 > (2**(WIDTH-1))-1) acc0 <= (2**(WIDTH-1))-1;\n            if (acc0 < -(2**(WIDTH-1))) acc0 <= -(2**(WIDTH-1));\n            if (acc1 > (2**(WIDTH-1))-1) acc1 <= (2**(WIDTH-1))-1;\n            if (acc1 < -(2**(WIDTH-1))) acc1 <= -(2**(WIDTH-1));\n            if (acc2 > (2**(WIDTH-1))-1) acc2 <= (2**(WIDTH-1))-1;\n            if (acc2 < -(2**(WIDTH-1))) acc2 <= -(2**(WIDTH-1));\n            if (acc3 > (2**(WIDTH-1))-1) acc3 <= (2**(WIDTH-1))-1;\n            if (acc3 < -(2**(WIDTH-1))) acc3 <= -(2**(WIDTH-1));\n        end\n        dataOut <= acc2;\n    end\nend\n\nendmodule",
        "module_name": "SmallBpf",
        "module_hash": "cfbeef8292840fd4aede6c080fb17c74",
        "dataset_index": 16975
      },
      "sky130_fd_sc_lp__a221o_9a86b092": {
        "rtl_code": "\nmodule sky130_fd_sc_lp__a221o (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    // Module ports\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire and0_out         ;\n    wire and1_out         ;\n    wire or0_out_X        ;\n\n    //                                 Name         Output             Other arguments\n    and                                and0        (and0_out         , B1, B2                );\n    and                                and1        (and1_out         , A1, A2                );\n    or                                 or0         (or0_out_X        , and1_out, and0_out, C1);\n    buf                                buf0        (X                , or0_out_X             );\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a221o",
        "module_hash": "9a86b092e0f0de949af5cfe7b90f7da0",
        "dataset_index": 15611
      },
      "VgaTiming_8dfaf02c": {
        "rtl_code": "\nmodule VgaTiming (\n\tinput  wire pclk,\n\tinput  wire rst,\n\t  \n\toutput reg [9:0] hcount,\n\toutput reg hsync,\n\toutput reg [9:0] vcount,\n\toutput reg vsync,\n\toutput reg blnk\n\t);\n\nlocalparam H_TOTAL_TIME = 800;\n\tlocalparam H_BLNK_START = 640;\n\tlocalparam H_SYNC_START\t= 656;\n\tlocalparam H_SYNC_TIME \t= 96;\n\tlocalparam H_SYNC_POL\t= 0;\tlocalparam V_TOTAL_TIME = 525;\n\tlocalparam V_BLNK_START = 480;\n\tlocalparam V_SYNC_START\t= 490;\n\tlocalparam V_SYNC_TIME \t= 2;\n\tlocalparam V_SYNC_POL\t= 0; \treg [10:0] vcount_nxt;\n\treg vsync_nxt;\n\treg [10:0] hcount_nxt;\n\treg hsync_nxt;\n\treg vblnk, hblnk;\n\treg vblnk_nxt, hblnk_nxt;\n\n    always @(posedge pclk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\thcount  <= #1 0;\n            hsync   <= #1 0;\n\t\t\tvcount  <= #1 0;\n\t        vsync   <= #1 0;\n\t        hblnk   <= #1 0;\n\t        vblnk   <= #1 0;\n        end\n\t\telse begin\n\t\t \thcount  <= #1 hcount_nxt;\n            hsync   <= #1 hsync_nxt;\n\t\t\tvcount  <= #1 vcount_nxt;\n            vsync   <= #1 vsync_nxt;\n            hblnk   <= #1 hblnk_nxt;\n            vblnk   <= #1 vblnk_nxt;   \n        end\n    end\n    \n    always @* begin\n        blnk = ~(hblnk | vblnk);\n    end\n\n\talways @* begin\n    \tif(hcount==H_BLNK_START - 1) begin\n\t        hcount_nxt = hcount+1;\n\t        if(H_SYNC_POL) hsync_nxt=0;\n\t        else hsync_nxt = 1;\n\t        hblnk_nxt=1; \n        end\n        else if(hcount==H_SYNC_START - 1) begin\n\t        hcount_nxt = hcount+1;\n\t        if(H_SYNC_POL) hsync_nxt=1;\n\t        else hsync_nxt = 0;\n            hblnk_nxt=1;    \n        end\n        else if (hcount==H_SYNC_START + H_SYNC_TIME - 1) begin\n\t        hcount_nxt = hcount+1;\n\t        if(H_SYNC_POL) hsync_nxt=0;\n\t        else hsync_nxt = 1;\n            hblnk_nxt=1;  \n        end\n        else if (hcount==H_TOTAL_TIME - 1) begin\n\t        hcount_nxt = 0;\n            if(H_SYNC_POL) hsync_nxt=0;\n            else hsync_nxt = 1;\n            hblnk_nxt=0;  \n        end\n        else begin\n\t        hcount_nxt = hcount+1;\n            hsync_nxt = hsync;\n            hblnk_nxt = hblnk;   \n\t\tend\n\t\tif(hcount==H_TOTAL_TIME - 1) begin\n\t\t\tif(vcount==V_BLNK_START - 1) begin\n\t\t\t\tvcount_nxt = vcount+1;\n\t\t\t\tif(V_SYNC_POL) vsync_nxt=0;\n\t        \telse vsync_nxt = 1;\n           \t\tvblnk_nxt=1;             \n            end\n\t\t\telse if (vcount==V_SYNC_START - 1) begin\n\t\t\t\tvcount_nxt = vcount+1;\n\t\t\t\tif(V_SYNC_POL) vsync_nxt=1;\n\t        \telse vsync_nxt = 0;\n           \t\tvblnk_nxt = 1;    \n            end\n\t\t\telse if (vcount==V_SYNC_START + V_SYNC_TIME - 1) begin\n\t\t\t\tvcount_nxt = vcount+1;\n\t\t\t\tif(V_SYNC_POL) vsync_nxt=0;\n\t        \telse vsync_nxt = 1;\n\t\t\t\tvblnk_nxt = 1;\n            end\n\t\t\telse if (vcount==V_TOTAL_TIME - 1) begin\n\t\t\t\tvcount_nxt = 0;\n\t\t\t\tif(V_SYNC_POL) vsync_nxt=0;\n                else vsync_nxt = 1;\n\t\t\t\tvblnk_nxt = 0;\n            end\n\t\t\telse begin\n\t\t\t\tvcount_nxt = vcount+1;\n\t\t\t\tvsync_nxt = vsync;\n\t\t\t\tvblnk_nxt = vblnk;\n            end\n        end\n        else begin\n\t        vcount_nxt = vcount;\n\t        vsync_nxt = vsync;\n\t        vblnk_nxt = vblnk;   \n        end\n\tend\n\nendmodule\n",
        "module_name": "VgaTiming",
        "module_hash": "8dfaf02c9065221356ad07a7d0fd7466",
        "dataset_index": 23161
      },
      "myModule_da728dc0": {
        "rtl_code": "module myModule(input CLOCK_50, output reg signal);\n\n    reg [24:0] counter;\n\n    always @(posedge CLOCK_50) begin\n        counter <= counter + 1;\n        if (counter == 25'd10) begin\n            signal <= ~signal;\n            counter <= 0;\n        end\n    end\n\nendmodule",
        "module_name": "myModule",
        "module_hash": "da728dc021430edca566a9d04daa494e",
        "dataset_index": 2032
      },
      "Mealy_FSM_ROM_6bd06806": {
        "rtl_code": "\nmodule Mealy_FSM_ROM(\n    input clk,\n    input reset,\n    input x,\n    output reg [2:0] count\n    );\n    \n    reg [2:0] state, nextState;\n    reg [5:0] ROM [0:11];\n    \n    parameter s0 = 0, s1 = 1, s2 = 2, s3 = 3, s4 = 4, s5 = 5;\n    \n    // set up ROM\n    initial begin\n        ROM[0]  <= 6'b000010; // s0, x = 0: 000010\n        ROM[1]  <= 6'b001000; // s0, x = 1: 001000\n        ROM[2]  <= 6'b001000; // s1, x = 0: 001000\n        ROM[3]  <= 6'b010001; // s1, x = 0: 010001\n        ROM[4]  <= 6'b010001; // s2, x = 0: 010001\n        ROM[5]  <= 6'b011011; // s2, x = 0: 011011\n        ROM[6]  <= 6'b011011; // s3, x = 0: 011011\n        ROM[7]  <= 6'b100101; // s3, x = 0: 100101\n        ROM[8]  <= 6'b100101; // s4, x = 0: 100101\n        ROM[9]  <= 6'b101111; // s4, x = 0: 101111\n        ROM[10] <= 6'b101111; // s5, x = 0: 101111\n        ROM[11] <= 6'b000010; // s5, x = 0: 000010\n    end\n    \n    // update state\n    always @(posedge clk or posedge reset) begin\n        if (reset) state <= s1;\n        else state <= nextState;\n    end\n    \n    \n     \n    \n    \n    always @(x or state) begin\n        {nextState, count} <= ROM[(state * 2 + x + (!clk & !reset)) % 12];\n    end           \nendmodule",
        "module_name": "Mealy_FSM_ROM",
        "module_hash": "6bd06806e94378b438c5315187e651ac",
        "dataset_index": 6345
      },
      "InputSync_63a5feb5": {
        "rtl_code": "\n\n(\ninput \twire\t\t\t\t\tCLK_I,\ninput\t\twire\t[3:0]\t\t\tD_I,\noutput\twire\t[3:0]\t\t\tD_O\n);\n\ngenvar i;\n\n\t\tgenerate\t\t\t\t\t\t\t\n\t\t\t\tfor(i=3;i>=0;i=i-1)\n\t\t\t\tbegin\n\t\t\t\t\tInputSync input_sync_inst\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t.CLK_I\t\t(CLK_I),\n\t\t\t\t\t\t\t\t.D_I\t\t\t(D_I[i]),\n\t\t\t\t\t\t\t\t.D_O\t\t\t(D_O[i])\n\t\t\t\t\t\t\t\t);\n\t\t\t\tend\n\t\tendgenerate\n\t\t\nendmodule\n\nmodule InputSync\n(\ninput\t\twire\t\tD_I,\ninput\t\twire\t\tCLK_I,\noutput\treg\t\tD_O\n);\n\nreg \t[1:0]\t\tsreg;\n\nalways@(posedge CLK_I)\n\t\tbegin\n\t\t\tD_O\t<=\tsreg[1];\n\t\t\tsreg\t<=\t{sreg[0],D_I};\n\t\tend\n\t\t\t\nendmodule\n\n",
        "module_name": "InputSync",
        "module_hash": "63a5feb5abda5a73183be6cca31ac30e",
        "dataset_index": 11024
      },
      "control_interface #_6b0cbca4": {
        "rtl_code": "module control_interface #(\n    parameter ASIZE = 16 // Address size\n)(\n    input CLK,\n    input RESET_N,\n    input [2:0] CMD,\n    input [ASIZE-1:0] ADDR,\n    input REF_ACK,\n    input INIT_ACK,\n    input CM_ACK,\n    output NOP,\n    output READA,\n    output WRITEA,\n    output REFRESH,\n    output PRECHARGE,\n    output LOAD_MODE,\n    output [ASIZE-1:0] SADDR,\n    output REF_REQ,\n    output INIT_REQ,\n    output CMD_ACK\n);\n\n// Define parameters\nparameter REF_PER = 8192; // Refresh period\nparameter INIT_PER = 1000; // Initial period\n\n// Define internal signals\nreg NOP, READA, WRITEA, REFRESH, PRECHARGE, LOAD_MODE;\nreg [ASIZE-1:0] SADDR;\nreg REF_REQ, INIT_REQ, CMD_ACK;\nreg [15:0] timer, init_timer;\n\n// Decode command and register address\nalways @(posedge CLK or negedge RESET_N) begin\n    if (RESET_N == 0) begin\n        NOP <= 0;\n        READA <= 0;\n        WRITEA <= 0;\n        SADDR <= 0;\n    end else begin\n        SADDR <= ADDR;\n        NOP <= (CMD == 3'b000);\n        READA <= (CMD == 3'b001);\n        WRITEA <= (CMD == 3'b010);\n    end\nend\n\n// Generate CMD_ACK\nalways @(posedge CLK or negedge RESET_N) begin\n    if (RESET_N == 0) begin\n        CMD_ACK <= 0;\n    end else if ((CM_ACK == 1) & (CMD_ACK == 0)) begin\n        CMD_ACK <= 1;\n    end else begin\n        CMD_ACK <= 0;\n    end\nend\n\n// Generate refresh request\nalways @(posedge CLK or negedge RESET_N) begin\n    if (RESET_N == 0) begin\n        timer <= 0;\n        REF_REQ <= 0;\n    end else begin\n        if (REF_ACK == 1) begin\n            timer <= REF_PER;\n            REF_REQ <= 0;\n        end else if (INIT_REQ == 1) begin\n            timer <= REF_PER + 200;\n            REF_REQ <= 0;\n        end else begin\n            timer <= timer - 1'b1;\n            if (timer == 0) begin\n                REF_REQ <= 1;\n            end\n        end\n    end\nend\n\n// Generate initial request\nalways @(posedge CLK or negedge RESET_N) begin\n    if (RESET_N == 0) begin\n        init_timer <= 0;\n        REFRESH <= 0;\n        PRECHARGE <= 0;\n        LOAD_MODE <= 0;\n        INIT_REQ <= 0;\n    end else begin\n        if (init_timer < INIT_PER + 201) begin\n            init_timer <= init_timer + 1;\n        end\n        if (init_timer < INIT_PER) begin\n            REFRESH <= 0;\n            PRECHARGE <= 0;\n            LOAD_MODE <= 0;\n            INIT_REQ <= 1;\n        end else if (init_timer == INIT_PER + 20) begin\n            REFRESH <= 0;\n            PRECHARGE <= 1;\n            LOAD_MODE <= 0;\n            INIT_REQ <= 0;\n        end else if ((init_timer == INIT_PER + 40) ||\n                    (init_timer == INIT_PER + 60) ||\n                    (init_timer == INIT_PER + 80) ||\n                    (init_timer == INIT_PER + 100) ||\n                    (init_timer == INIT_PER + 120) ||\n                    (init_timer == INIT_PER + 140) ||\n                    (init_timer == INIT_PER + 160) ||\n                    (init_timer == INIT_PER + 180)) begin\n            REFRESH <= 1;\n            PRECHARGE <= 0;\n            LOAD_MODE <= 0;\n            INIT_REQ <= 0;\n        end else if (init_timer == INIT_PER + 200) begin\n            REFRESH <= 0;\n            PRECHARGE <= 0;\n            LOAD_MODE <= 1;\n            INIT_REQ <= 0;\n        end else begin\n            REFRESH <= 0;\n            PRECHARGE <= 0;\n            LOAD_MODE <= 0;\n            INIT_REQ <= 0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "control_interface #",
        "module_hash": "6b0cbca4ef0bb0f3d6737e69b38c3a65",
        "dataset_index": 1943
      },
      "nios_dut_pio_2_3eacc598": {
        "rtl_code": "module nios_dut_pio_2 (\n                        // inputs:\n                         address,\n                         clk,\n                         in_port,\n                         reset_n,\n\n                        // outputs:\n                         readdata\n                      )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [ 19: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [ 19: 0] data_in;\n  wire    [ 19: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {20 {(address == 2'b00)}} & data_in | {12'b0, in_port[19:0]} & {20 {(address == 2'b01)}};\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "nios_dut_pio_2",
        "module_hash": "3eacc59824f01bad3ce2a622fb3900e1",
        "dataset_index": 9553
      },
      "binary_to_gray_2af59874": {
        "rtl_code": "module binary_to_gray (\n    input [15:0] binary_in,\n    output [15:0] gray_out\n);\n    assign gray_out = binary_in ^ (binary_in >> 1);\nendmodule\n\nmodule barrel_shifter (\n    input [15:0] data_in,\n    input [3:0] shift_amount,\n    input control,\n    output [15:0] data_out\n);\n    reg [15:0] shifted_data;\n\n    always @(*) begin\n        if (control == 1'b0) begin\n            shifted_data = data_in << shift_amount;\n        end else begin\n            shifted_data = data_in >> shift_amount;\n        end\n    end\n\n    assign data_out = shifted_data;\nendmodule\n\nmodule final_output (\n    input [15:0] gray_in,\n    input [15:0] shifted_data_in,\n    output [15:0] data_out\n);\n    assign data_out = gray_in & shifted_data_in;\nendmodule\n\nmodule top_module (\n    input [15:0] data_in,\n    input [3:0] shift_amount,\n    input control,\n    output [15:0] data_out\n);\n    wire [15:0] gray_out;\n    wire [15:0] shifted_data_out;\n\n    binary_to_gray gray_converter(\n        .binary_in(data_in),\n        .gray_out(gray_out)\n    );\n\n    barrel_shifter shifter(\n        .data_in(gray_out),\n        .shift_amount(shift_amount),\n        .control(control),\n        .data_out(shifted_data_out)\n    );\n\n    final_output output_generator(\n        .gray_in(gray_out),\n        .shifted_data_in(shifted_data_out),\n        .data_out(data_out)\n    );\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "2af59874c01721968600082fc890af42",
        "dataset_index": 5129
      },
      "counter_3d5835db": {
        "rtl_code": "\nmodule counter(\n    input CP,\n    input CLR_,\n    input M,\n    input [7:0] RS,\n    input LD_,\n    output reg [7:0] Q,\n    output QCC_\n    );\n\t\n\treg TEMP;\n\t\n\tinitial begin\n\t\tQ = 8'b00000000;\n\tend\n\n\talways @(posedge CP)\n\tbegin\n\t\t// check if carry signal should be generated\n\t\tTEMP = ((~Q[0] & ~Q[1] & ~Q[2] & ~Q[3] & ~Q[4] & ~Q[5] & ~Q[6] & ~Q[7] & ~M) | (Q[0] & Q[1] & Q[2] & Q[3] & Q[4] & Q[5] & Q[6] & Q[7] & M)) & CLR_ & LD_;\n\tend\n\n\talways @(posedge CP) // CLR_ and LD_ are level sensitive, CP is edge sensitive.\n\tbegin\t\n\t\tif (CLR_ == 1'b0)\n\t\tbegin\n\t\t\tQ = 8'b00000000;\n\t\tend\n\t\telse if (LD_ == 1'b0)\n\t\tbegin\n\t\t\tQ = RS;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (M == 1'b1)\n\t\t\tbegin\n\t\t\t\tQ = Q+1'b1;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tQ = Q-1'b1;\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign QCC_ = TEMP & CP;\n\nendmodule",
        "module_name": "counter",
        "module_hash": "3d5835dbce6c522173990ef5ced197b9",
        "dataset_index": 11518
      },
      "four_in_one_out_43e6bbf2": {
        "rtl_code": "module four_in_one_out (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    output X\n);\n\n    wire [3:0] sum;\n    assign sum = A1 + A2 + B1 + B2;\n    \n    assign X = (A1 == 1) ? (sum[1:0] + B1 + B2) : sum[3:0];\n    \nendmodule",
        "module_name": "four_in_one_out",
        "module_hash": "43e6bbf2417d3d555bafc6c1e821a822",
        "dataset_index": 20360
      },
      "logic_expression_ae7f8a86": {
        "rtl_code": "module logic_expression(\n    input A,\n    input B,\n    input C,\n    input D,\n    input E,\n    output X\n    );\n    \n    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12;\n\n    assign w1 = ~A & ~B & ~C & D & ~E;\n    assign w2 = ~A & ~B & ~C & D & E;\n    assign w3 = ~A & ~B & C & ~D & E;\n    assign w4 = ~A & ~B & C & D & E;\n    assign w5 = ~A & B & ~C & ~D & E;\n    assign w6 = ~A & B & ~C & D & E;\n    assign w7 = ~A & B & C & ~D & E;\n    assign w8 = A & ~B & ~C & ~D & E;\n    assign w9 = A & ~B & ~C & D & E;\n    assign w10 = A & ~B & C & D & E;\n    assign w11 = A & B & C & ~D & E;\n    assign w12 = A & B & C & D & E;\n\n    assign X = w1 | w2 | w3 | w4 | w5 | w6 | w7 | w8 | w9 | w10 | w11 | w12;\n    \nendmodule",
        "module_name": "logic_expression",
        "module_hash": "ae7f8a86c74374994e5b0f789bcb8b39",
        "dataset_index": 17851
      },
      "counter_7d41d278": {
        "rtl_code": "module counter(\n\tinput clk,\n\tinput rst,\n\tinput en,\n\tinput up_down,\n\toutput reg [3:0] out\n);\n\n\talways @(posedge clk or negedge rst) begin\n\t\tif (!rst) begin\n\t\t\tout <= 4'b0000;\n\t\tend else if (en) begin\n\t\t\tif (up_down) begin\n\t\t\t\tif (out == 4'b1111) begin\n\t\t\t\t\tout <= 4'b0000;\n\t\t\t\tend else begin\n\t\t\t\t\tout <= out + 1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tif (out == 4'b0000) begin\n\t\t\t\t\tout <= 4'b1111;\n\t\t\t\tend else begin\n\t\t\t\t\tout <= out - 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "7d41d278b21bd776d5d71b0ea387c110",
        "dataset_index": 16882
      },
      "arbiter2_bfba569d": {
        "rtl_code": "module arbiter2\n#(\n\tparameter MAX_DAT_WIDTH = 32,\n\tparameter WBS_DAT_WIDTH = 32,\n\tparameter WBM0_DAT_WIDTH = 32,\n\tparameter WBM1_DAT_WIDTH = 32\n)(\n\tWBM0_ADR_O,\n\tWBM0_DAT_O,\n\tWBM0_DAT_I,\n\tWBM0_SEL_O,\n\tWBM0_WE_O,\n\tWBM0_ACK_I,\n\tWBM0_ERR_I,\n\tWBM0_RTY_I,\n\tWBM0_CTI_O,\n\tWBM0_BTE_O,\n\tWBM0_LOCK_O,\n\tWBM0_CYC_O,\n\tWBM0_STB_O,\n\tWBM1_ADR_O,\n\tWBM1_DAT_O,\n\tWBM1_DAT_I,\n\tWBM1_SEL_O,\n\tWBM1_WE_O,\n\tWBM1_ACK_I,\n\tWBM1_ERR_I,\n\tWBM1_RTY_I,\n\tWBM1_CTI_O,\n\tWBM1_BTE_O,\n\tWBM1_LOCK_O,\n\tWBM1_CYC_O,\n\tWBM1_STB_O,\n\tWBS_ADR_I,\n\tWBS_DAT_I,\n\tWBS_DAT_O,\n\tWBS_SEL_I,\n\tWBS_WE_I,\n\tWBS_ACK_O,\n\tWBS_ERR_O,\n\tWBS_RTY_O,\n\tWBS_CTI_I,\n\tWBS_BTE_I,\n\tWBS_LOCK_I,\n\tWBS_CYC_I,\n\tWBS_STB_I,\n\n\tclk,\n\treset\n);\n\ninput clk, reset;\ninput [31:0]WBM0_ADR_O;\ninput [WBM0_DAT_WIDTH-1:0] WBM0_DAT_O;\noutput [WBM0_DAT_WIDTH-1:0] WBM0_DAT_I;\ninput [WBM0_DAT_WIDTH/8-1:0] WBM0_SEL_O;\ninput  WBM0_WE_O;\noutput  WBM0_ACK_I;\noutput  WBM0_ERR_I;\noutput  WBM0_RTY_I;\ninput [2:0]WBM0_CTI_O;\ninput [1:0]WBM0_BTE_O;\ninput  WBM0_LOCK_O;\ninput  WBM0_CYC_O;\ninput  WBM0_STB_O;\ninput [31:0]WBM1_ADR_O;\ninput [WBM1_DAT_WIDTH-1:0] WBM1_DAT_O;\noutput [WBM1_DAT_WIDTH-1:0] WBM1_DAT_I;\ninput [WBM1_DAT_WIDTH/8-1:0] WBM1_SEL_O;\ninput  WBM1_WE_O;\noutput  WBM1_ACK_I;\noutput  WBM1_ERR_I;\noutput  WBM1_RTY_I;\ninput [2:0]WBM1_CTI_O;\ninput [1:0]WBM1_BTE_O;\ninput  WBM1_LOCK_O;\ninput  WBM1_CYC_O;\ninput  WBM1_STB_O;\noutput [31:0]WBS_ADR_I;\noutput [WBS_DAT_WIDTH-1:0] WBS_DAT_I;\ninput [WBS_DAT_WIDTH-1:0] WBS_DAT_O;\noutput [WBS_DAT_WIDTH/8-1:0] WBS_SEL_I;\noutput  WBS_WE_I;\ninput  WBS_ACK_O;\ninput  WBS_ERR_O;\ninput  WBS_RTY_O;\noutput [2:0]WBS_CTI_I;\noutput [1:0]WBS_BTE_I;\noutput  WBS_LOCK_I;\noutput  WBS_CYC_I;\noutput  WBS_STB_I;\n\nwire [MAX_DAT_WIDTH-1:0] WBM0_DAT_I_INT;\nwire [MAX_DAT_WIDTH-1:0] WBM0_DAT_O_INT;\nwire [MAX_DAT_WIDTH/8-1:0] WBM0_SEL_O_INT;\nwire [MAX_DAT_WIDTH-1:0] WBM1_DAT_I_INT;\nwire [MAX_DAT_WIDTH-1:0] WBM1_DAT_O_INT;\nwire [MAX_DAT_WIDTH/8-1:0] WBM1_SEL_O_INT;\nwire [MAX_DAT_WIDTH-1:0] WBS_DAT_O_INT;\nwire [MAX_DAT_WIDTH-1:0] WBS_DAT_I_INT;\nwire [MAX_DAT_WIDTH/8-1:0] WBS_SEL_I_INT;\n\ngenerate\n\tif ((WBS_DAT_WIDTH == 8) && ((WBM0_DAT_WIDTH == 32) || (WBM1_DAT_WIDTH == 32))) begin\n\t\tassign WBS_DAT_I = ((WBS_ADR_I[1:0] == 2'b00)\n\t\t\t? WBS_DAT_I_INT[31:24]\n\t\t\t: ((WBS_ADR_I[1:0] == 2'b01)\n\t\t\t? WBS_DAT_I_INT[23:16]\n\t\t\t: ((WBS_ADR_I[1:0] == 2'b10)\n\t\t\t? WBS_DAT_I_INT[15:8]\n\t\t\t: WBS_DAT_I_INT[7:0]\n\t\t\t)));\n\t\tassign WBS_SEL_I = ((WBS_ADR_I[1:0] == 2'b00)\n\t\t\t? WBS_SEL_I_INT[3]\n\t\t\t: ((WBS_ADR_I[1:0] == 2'b01)\n\t\t\t? WBS_SEL_I_INT[2]\n\t\t\t: ((WBS_ADR_I[1:0] == 2'b10)\n\t\t\t? WBS_SEL_I_INT[1]\n\t\t\t: WBS_SEL_I_INT[0]\n\t\t\t)));\n\t\tassign WBS_DAT_O_INT = {4{WBS_DAT_O}};\n\tend\n\telse begin\n\t\tassign WBS_DAT_I = WBS_DAT_I_INT;\n\t\tassign WBS_SEL_I = WBS_SEL_I_INT;\n\t\tassign WBS_DAT_O_INT = WBS_DAT_O;\n\tend\nendgenerate\n\ngenerate\n\tif ((WBS_DAT_WIDTH == 32) && (WBM0_DAT_WIDTH == 8)) begin\n\t\tassign WBM0_DAT_I = ((WBM0_ADR_O[1:0] == 2'b00)\n\t\t\t? WBM0_DAT_I_INT[31:24]\n\t\t\t: ((WBM0_ADR_O[1:0] == 2'b01)\n\t\t\t? WBM0_DAT_I_INT[23:16]\n\t\t\t: ((WBM0_ADR_O[1:0] == 2'b10)\n\t\t\t? WBM0_DAT_I_INT[15:8]\n\t\t\t: WBM0_DAT_I_INT[7:0]\n\t\t\t)));\n\t\tassign WBM0_DAT_O_INT = {4{WBM0_DAT_O}};\n\t\tassign WBM0_SEL_O_INT = ((WBM0_ADR_O[1:0] == 2'b00)\n\t\t\t? {WBM0_SEL_O, 3'b000}\n\t\t\t: ((WBM0_ADR_O[1:0] == 2'b01)\n\t\t\t? {1'b0, WBM0_SEL_O, 2'b00}\n\t\t\t: ((WBM0_ADR_O[1:0] == 2'b10)\n\t\t\t? {2'b00, WBM0_SEL_O, 1'b0}\n\t\t\t: {3'b000, WBM0_SEL_O}\n\t\t\t)));\n\tend\n\telse if ((WBS_DAT_WIDTH == 8) && (MAX_DAT_WIDTH == 32)) begin\n\t\tassign WBM0_DAT_I = WBM0_DAT_I_INT;\n\t\tassign WBM0_SEL_O_INT = {4{WBM0_SEL_O}};\n\t\tassign WBM0_DAT_O_INT = {4{WBM0_DAT_O}};\n\tend\n\telse begin\n\t\tassign WBM0_DAT_I = WBM0_DAT_I_INT;\n\t\tassign WBM0_SEL_O_INT = WBM0_SEL_O;\n\t\tassign WBM0_DAT_O_INT = WBM0_DAT_O;\n\tend\nendgenerate\n\ngenerate\n\tif ((WBS_DAT_WIDTH == 32) && (WBM1_DAT_WIDTH == 8)) begin\n\t\tassign WBM1_DAT_I = ((WBM1_ADR_O[1:0] == 2'b00)\n\t\t\t? WBM1_DAT_I_INT[31:24]\n\t\t\t: ((WBM1_ADR_O[1:0] == 2'b01)\n\t\t\t? WBM1_DAT_I_INT[23:16]\n\t\t\t: ((WBM1_ADR_O[1:0] == 2'b10)\n\t\t\t? WBM1_DAT_I_INT[15:8]\n\t\t\t: WBM1_DAT_I_INT[7:0]\n\t\t\t)));\n\t\tassign WBM1_DAT_O_INT = {4{WBM1_DAT_O}};\n\t\tassign WBM1_SEL_O_INT = ((WBM1_ADR_O[1:0] == 2'b00)\n\t\t\t? {WBM1_SEL_O, 3'b000}\n\t\t\t: ((WBM1_ADR_O[1:0] == 2'b01)\n\t\t\t? {1'b0, WBM1_SEL_O, 2'b00}\n\t\t\t: ((WBM1_ADR_O[1:0] == 2'b10)\n\t\t\t? {2'b00, WBM1_SEL_O, 1'b0}\n\t\t\t: {3'b000, WBM1_SEL_O}\n\t\t\t)));\n\tend\n\telse if ((WBS_DAT_WIDTH == 8) && (MAX_DAT_WIDTH == 32)) begin\n\t\tassign WBM1_DAT_I = WBM1_DAT_I_INT;\n\t\tassign WBM1_SEL_O_INT = {4{WBM1_SEL_O}};\n\t\tassign WBM1_DAT_O_INT = {4{WBM1_DAT_O}};\n\tend\n\telse begin\n\t\tassign WBM1_DAT_I = WBM1_DAT_I_INT;\n\t\tassign WBM1_SEL_O_INT = WBM1_SEL_O;\n\t\tassign WBM1_DAT_O_INT = WBM1_DAT_O;\n\tend\nendgenerate\n\n\nreg [2-1:0] \t\tselected; reg locked;\nalways @(posedge clk or posedge reset)\nbegin\n\tif (reset) begin\n\t\tselected <= #1 0;\n\t\tlocked   <= #1 0;\n\tend\n\telse begin\n\t\tif (selected == 0) begin\n\t\t\tif (WBM0_STB_O) begin\n\t\t\t\tselected <= #1 2'd1;\n\t\t\t\tlocked   <= #1 WBM0_LOCK_O;\n\t\t\tend\n\t\t\telse if (WBM1_STB_O) begin\n\t\t\t\tselected <= #1 2'd2;\n\t\t\t\tlocked   <= #1 WBM1_LOCK_O;\n\t\t\tend\n\t\tend\n\t\telse if (selected == 2'd1) begin\n\t\t\tif ((WBS_ACK_O || WBS_ERR_O || locked) && ((WBM0_CTI_O == 3'b000) || (WBM0_CTI_O == 3'b111) || locked) && !WBM0_LOCK_O) begin\n\t\t\t\tselected <= #1 0;\n\t\t\t\tlocked <= #1 0;\n\t\t\tend\n\t\tend\n\t\telse if (selected == 2'd2) begin\n\t\t\tif ((WBS_ACK_O || WBS_ERR_O || locked) && ((WBM1_CTI_O == 3'b000) || (WBM1_CTI_O == 3'b111) || locked) && !WBM1_LOCK_O) begin\n\t\t\t\tselected <= #1 0;\n\t\t\t\tlocked <= #1 0;\n\t\t\tend\n\t\tend\n\tend\nend\n\nassign WBS_ADR_I =\n\t(selected == 2'd1 ? WBM0_ADR_O :\n\t(selected == 2'd2 ? WBM1_ADR_O :\n\t0));\nassign WBS_DAT_I_INT =\n\t(selected == 2'd1 ? WBM0_DAT_O_INT :\n\t(selected == 2'd2 ? WBM1_DAT_O_INT :\n\t0));\nassign WBS_SEL_I_INT =\n\t(selected == 2'd1 ? WBM0_SEL_O_INT :\n\t(selected == 2'd2 ? WBM1_SEL_O_INT :\n\t0));\nassign WBS_WE_I =\n\t(selected == 2'd1 ? WBM0_WE_O :\n\t(selected == 2'd2 ? WBM1_WE_O :\n\t0));\nassign WBS_CTI_I =\n\t(selected == 2'd1 ? WBM0_CTI_O :\n\t(selected == 2'd2 ? WBM1_CTI_O :\n\t0));\nassign WBS_BTE_I =\n\t(selected == 2'd1 ? WBM0_BTE_O :\n\t(selected == 2'd2 ? WBM1_BTE_O :\n\t0));\nassign WBS_LOCK_I =\n\t(selected == 2'd1 ? WBM0_LOCK_O :\n\t(selected == 2'd2 ? WBM1_LOCK_O :\n\t0));\nassign WBS_CYC_I =\n\t(selected == 2'd1 ? WBM0_CYC_O :\n\t(selected == 2'd2 ? WBM1_CYC_O :\n\t0));\nassign WBS_STB_I =\n\t(selected == 2'd1 ? WBM0_STB_O :\n\t(selected == 2'd2 ? WBM1_STB_O :\n\t0));\n\nassign WBM0_DAT_I_INT = WBS_DAT_O_INT;\nassign WBM0_ACK_I = (selected == 2'd1 ? WBS_ACK_O : 0);\nassign WBM0_ERR_I = (selected == 2'd1 ? WBS_ERR_O : 0);\nassign WBM0_RTY_I = (selected == 2'd1 ? WBS_RTY_O : 0);\n\nassign WBM1_DAT_I_INT = WBS_DAT_O_INT;\nassign WBM1_ACK_I = (selected == 2'd2 ? WBS_ACK_O : 0);\nassign WBM1_ERR_I = (selected == 2'd2 ? WBS_ERR_O : 0);\nassign WBM1_RTY_I = (selected == 2'd2 ? WBS_RTY_O : 0);\n\nendmodule\n",
        "module_name": "arbiter2",
        "module_hash": "bfba569d3cb7e3d8ee6b47f6b43f5d3e",
        "dataset_index": 23832
      },
      "inicial_55ada1e2": {
        "rtl_code": "\nmodule inicial(SW4, SW3, SW2, SW1, SW0, LEDG, LEDR, HEX0, CLK);\n\n    input SW4, SW3, SW2, SW1, SW0, CLK;\n    output LEDG, LEDR;\n    output reg [6:0] HEX0;\n\n    assign LEDG = ~SW0;\n    assign LEDR = SW0;\n\n    always @(posedge CLK) begin\n        case ({SW4, SW3, SW2, SW1, SW0})\n            5'b00000: HEX0 = 7'b1000000; // \"0\"\n            5'b00001: HEX0 = 7'b1111001; // \"1\"\n            5'b00010: HEX0 = 7'b0100100; // \"2\"\n            5'b00011: HEX0 = 7'b0110000; // \"3\"\n            5'b00100: HEX0 = 7'b0011001; // \"4\"\n            5'b00101: HEX0 = 7'b0010010; // \"5\"\n            5'b00110: HEX0 = 7'b0000010; // \"6\"\n            5'b00111: HEX0 = 7'b1111000; // \"7\"\n            5'b01000: HEX0 = 7'b0000000; // \"8\"\n            5'b01001: HEX0 = 7'b0010000; // \"9\"\n            default: HEX0 = 7'b1001111; // \"E\"\n        endcase\n    end\n\nendmodule\n",
        "module_name": "inicial",
        "module_hash": "55ada1e2ffdc800de6dabd16803dcc61",
        "dataset_index": 18747
      },
      "eth_shiftreg_88b86362": {
        "rtl_code": "\n\n\nmodule eth_shiftreg(Clk, Reset, MdcEn_n, Mdi, Fiad, Rgad, CtrlData, WriteOp, ByteSelect, \n                    LatchByte, ShiftedBit, Prsd, LinkFail);\n\n\nparameter Tp=1;\n\ninput       Clk;              input       Reset;            input       MdcEn_n;          input       Mdi;              input [4:0] Fiad;             input [4:0] Rgad;             input [15:0]CtrlData;         input       WriteOp;          input [3:0] ByteSelect;       input [1:0] LatchByte;        output      ShiftedBit;       output[15:0]Prsd;             output      LinkFail;         reg   [7:0] ShiftReg;         reg   [15:0]Prsd;\nreg         LinkFail;\n\n\n\n\nalways @ (posedge Clk or posedge Reset) \nbegin\n  if(Reset)\n    begin\n      ShiftReg[7:0] <= #Tp 8'h0;\n      Prsd[15:0] <= #Tp 16'h0;\n      LinkFail <= #Tp 1'b0;\n    end\n  else\n    begin\n      if(MdcEn_n)\n        begin \n          if(|ByteSelect)\n            begin\n              case (ByteSelect[3:0])\n                4'h1 :    ShiftReg[7:0] <= #Tp {2'b01, ~WriteOp, WriteOp, Fiad[4:1]};\n                4'h2 :    ShiftReg[7:0] <= #Tp {Fiad[0], Rgad[4:0], 2'b10};\n                4'h4 :    ShiftReg[7:0] <= #Tp CtrlData[15:8];\n                4'h8 :    ShiftReg[7:0] <= #Tp CtrlData[7:0];\n                default : ShiftReg[7:0] <= #Tp 8'h0;\n              endcase\n            end \n          else\n            begin\n              ShiftReg[7:0] <= #Tp {ShiftReg[6:0], Mdi};\n              if(LatchByte[0])\n                begin\n                  Prsd[7:0] <= #Tp {ShiftReg[6:0], Mdi};\n                  if(Rgad == 5'h01)\n                    LinkFail <= #Tp ~ShiftReg[1];  end\n              else\n                begin\n                  if(LatchByte[1])\n                    Prsd[15:8] <= #Tp {ShiftReg[6:0], Mdi};\n                end\n            end\n        end\n    end\nend\n\n\nassign ShiftedBit = ShiftReg[7];\n\n\nendmodule\n",
        "module_name": "eth_shiftreg",
        "module_hash": "88b8636263d6bd732e07f97611f42ada",
        "dataset_index": 22011
      },
      "ECC_memory_block #_4608392a": {
        "rtl_code": "\nmodule ECC_memory_block #(\n  parameter data_width = 8, // width of the data bus (in bits)\n  parameter ecc_width = 4,// width of the error correction code (in bits)\n  parameter addr_width = 8 // width of the memory address (in bits)\n)(\n  input clk,\n  input rst,\n  input [data_width-1:0] data_in,\n  input [addr_width-1:0] addr,\n  input we,\n  output [data_width-1:0] data_out,\n  output [ecc_width-1:0] ecc\n);\n\nreg [data_width-1:0] memory [2**addr_width-1:0]; // memory array\nreg [ecc_width-1:0] ecc_reg; // error correction code register\n\n// Hamming code generation function\nfunction [ecc_width-1:0] hamming_code;\n  input [data_width-1:0] data;\n  reg [ecc_width-1:0] ecc;\n  integer i;\n  begin\n    for (i = 0; i < ecc_width; i = i + 1) begin\n      ecc[i] = data[i] ^ data[i+1] ^ data[i+3];\n    end\n    ecc[ecc_width-1] = data[0] ^ data[1] ^ data[2];\n    hamming_code = ecc;\n  end\nendfunction\n\n// Error correction function\nfunction [data_width-1:0] error_correction;\n  input [data_width-1:0] data;\n  input [ecc_width-1:0] ecc;\n  reg [data_width-1:0] corrected_data;\n  integer i;\n  begin\n    for (i = 0; i < data_width; i = i + 1) begin\n      corrected_data[i] = data[i] ^ (ecc[0] ^ ecc[1] ^ ecc[3]);\n    end\n    corrected_data[data_width-1] = data[data_width-1] ^ (ecc[0] ^ ecc[1] ^ ecc[2]);\n    error_correction = corrected_data;\n  end\nendfunction\n\nreg [ecc_width-1:0] ecc_out;\nreg [data_width-1:0] corrected_data_out;\n// Memory read and write logic\nalways @(posedge clk) begin\n  if (rst) begin\n    ecc_reg <= 0;\n    ecc_out <= 0;\n    corrected_data_out <= 0;\n  end\n  else if (we) begin\n    memory[addr] <= data_in;\n    ecc_reg <= hamming_code(data_in);\n  end\n  else begin\n    ecc_out <= hamming_code(memory[addr]);\n    corrected_data_out <= memory[addr];\n  end\nend\n\n// Error detection logic\nwire error_detected = ecc_out != ecc_reg;\n\n// Error correction logic\nassign data_out = error_detected ? error_correction(corrected_data_out, ecc_reg) : corrected_data_out;\n\nassign ecc = ecc_reg;\n\nendmodule",
        "module_name": "ECC_memory_block #",
        "module_hash": "4608392a867297e3d91039194529cf0a",
        "dataset_index": 9431
      },
      "vga_palette_regs_3a531de9": {
        "rtl_code": "\n\nmodule vga_palette_regs (\n    input clk,\n\n    input      [3:0] attr,\n    output reg [7:0] index,\n\n    input      [3:0] address,\n    input            write,\n    output reg [7:0] read_data,\n    input      [7:0] write_data\n  );\n\n  reg [7:0] palette [0:15];\n\n  always @(posedge clk) index <= palette[attr];\n\n  always @(posedge clk) read_data <= palette[address];\n\n  always @(posedge clk)\n    if (write) palette[address] <= write_data;\n\nendmodule\n",
        "module_name": "vga_palette_regs",
        "module_hash": "3a531de983f8945ed3b3e48e81b02e84",
        "dataset_index": 24492
      },
      "top__b7718868": {
        "rtl_code": "module top_module (\n    input [3:0] in, // 4-bit binary input\n    output [15:0] out // 16-bit output from the decoder\n);\n\nwire [3:0] mux_out;\nwire [15:0] decoder_out;\n\nmux_4to1 mux (\n    .in0(decoder_out[3:0]),\n    .in1(decoder_out[7:4]),\n    .in2(decoder_out[11:8]),\n    .in3(decoder_out[15:12]),\n    .select(in[3:2]),\n    .out(mux_out)\n);\n\ndecoder dec (\n    .in(in),\n    .out(decoder_out)\n);\n\nassign out = mux_out;\n\nendmodule\n\nmodule mux_4to1(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] select,\n    output reg [3:0] out\n);\n\nalways @*\nbegin\n    case (select)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = in2;\n        2'b11: out = in3;\n    endcase\nend\n\nendmodule\n\nmodule decoder (\n    input [3:0] in,\n    output [15:0] out\n);\n\nassign out = 16'b0000000000000001 << in;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "b7718868c71b4ac513bc7e20aaa22857",
        "dataset_index": 1650
      },
      "mux_parity_00579b17": {
        "rtl_code": "module mux_parity (\n    input [7:0] a, // 8-bit input a\n    input [7:0] b, // 8-bit input b\n    input [7:0] c, // 8-bit input c\n    input [7:0] d, // 8-bit input d\n    input sel_a, // Select input 1 for 4-to-1 MUX\n    input sel_b, // Select input 2 for 4-to-1 MUX\n    output reg [7:0] out, // 8-bit output with parity bit removed\n    output reg error_flag // Error flag, set to 1 if there is a parity error\n);\n\n// 4-to-1 MUX\nwire [7:0] mux_out;\nmux_4to1 mux_inst (\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .sel_a(sel_a),\n    .sel_b(sel_b),\n    .out(mux_out)\n);\n\n// Parity bit checker\nwire [7:0] data_in;\nassign data_in = mux_out;\nwire parity_bit;\nassign parity_bit = ^data_in;\nalways @* begin\n    if (parity_bit == 1'b1) begin\n        error_flag = 1'b1;\n        out = 8'b0;\n    end else begin\n        error_flag = 1'b0;\n        out = data_in;\n    end\nend\n\nendmodule\n\n// 4-to-1 MUX module\nmodule mux_4to1 (\n    input [7:0] a, // 8-bit input a\n    input [7:0] b, // 8-bit input b\n    input [7:0] c, // 8-bit input c\n    input [7:0] d, // 8-bit input d\n    input sel_a, // Select input 1 for 4-to-1 MUX\n    input sel_b, // Select input 2 for 4-to-1 MUX\n    output reg [7:0] out // 8-bit output\n);\n\nalways @* begin\n    case ({sel_a, sel_b})\n        2'b00: out = a;\n        2'b01: out = b;\n        2'b10: out = c;\n        2'b11: out = d;\n    endcase\nend\n\nendmodule",
        "module_name": "mux_parity",
        "module_hash": "00579b17e2f263d89a3727893105806b",
        "dataset_index": 8748
      },
      "shift_register_fd6c298b": {
        "rtl_code": "module shift_register (\n  input clk,\n  input reset,\n  input load,\n  input data,\n  output [7:0] q\n);\n\nreg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n  if (reset == 1'b0) begin\n    shift_reg <= 8'b0;\n  end else begin\n    if (load == 1'b1) begin\n      shift_reg <= data;\n    end else begin\n      shift_reg <= {shift_reg[6:0], data};\n    end\n  end\nend\n\nassign q = shift_reg;\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "fd6c298b9a11767750eff07c226a961b",
        "dataset_index": 5598
      },
      "synchronous_block_ram_4c5ec76d": {
        "rtl_code": "\nmodule synchronous_block_ram(\n   clk,    \n   ce, oe, we, \n   addr, di, doq\n   );    \n   \nparameter aw = 9;\nparameter dw = 32; // Define the operand width here\n\ninput   clk;\ninput   ce;\ninput   we;\ninput   oe;\t\ninput [aw-1:0]  addr;\ninput [dw-1:0]  di;\n\noutput [dw-1:0] doq;\n\nreg [dw-1:0]    mem [(1<<aw)-1:0] ;\nreg [aw-1:0]    addr_reg;\t\t\n\n\n// memory read address register for synchronous access\nalways @(posedge clk) begin\n    if (ce)\n        addr_reg <=  addr;\nend\n        \n// Data output \nassign doq = mem[addr_reg];\n\nalways @(posedge clk) begin\n    if (we && ce)\n        mem[addr] <=  di; \nend\n   \nendmodule",
        "module_name": "synchronous_block_ram",
        "module_hash": "4c5ec76da6ef7899cadf3ea102673d85",
        "dataset_index": 9228
      },
      "mux_2to1_9c26f8ba": {
        "rtl_code": "module mux_2to1 (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    assign out = (sel == 1'b0) ? a : b;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "9c26f8ba3fb943863665dda550d831e8",
        "dataset_index": 18827
      },
      "and_gate_d8eb020d": {
        "rtl_code": "module and_gate (\n    output Y,\n    input A1,\n    input A2,\n    input B1_N,\n    input B2_N\n);\n\n    assign Y = ~(A1 & A2 & B1_N & B2_N);\n\nendmodule\n\n",
        "module_name": "and_gate",
        "module_hash": "d8eb020d25365c8fae07849f69db3e83",
        "dataset_index": 5448
      },
      "vgabase_df58556e": {
        "rtl_code": "\n\nmodule vgabase(\n    input wire clk,\n    input wire clr,\n    output reg hsync,\n    output reg vsync,\n    output reg [11:0] hc,\n    output reg [11:0] vc,\n    output wire vidon\n  );\n\n\nparameter hpixels = 12'd1344;\nparameter vlines  = 12'd806;\nparameter hsp   = 12'd136;\nparameter hbp   = 12'd160;\nparameter hfp   = 12'd24;\nparameter vsp   = 12'd6;\nparameter vbp   = 12'd29;\nparameter vfp   = 12'd3;\n\n\nreg vsenable;\n\ninitial begin\n  hc <= hpixels - hsp - hbp;\n  vc <= vlines - vsp - vbp;\n  hsync <= 0;\n  vsync <= 0;\n  vsenable <= 0;\nend\n\nalways @(posedge clk or posedge clr) begin\n    if(clr == 1)\n      hc <= hpixels - hsp - hbp;\n  else begin\n      if(hc == hpixels - 1) begin\n        hc <= 0;\n      vsenable <= 1;\n    end else begin\n        hc <= hc + 1'b1;\n      vsenable <= 0;\n    end\n  end\nend\n\nalways @(*) begin\n    if(hpixels - hsp - hbp < hc && hc <= hpixels - hbp)\n      hsync = 0;\n  else\n      hsync = 1;\nend\n\nalways @(posedge clk or posedge clr) begin\n    if(clr == 1)\n      vc <= vlines - vsp - vbp;\n  else if(vsenable == 1)\n      if(vc == vlines - 1)\n        vc <= 0;\n    else\n        vc <= vc + 1'b1;\nend\n\nalways @(*) begin\n    if(vlines - vsp - vbp < vc && vc <= vlines - vbp)\n      vsync = 0;\n  else\n      vsync = 1;\nend\n\nassign vidon=(hc<hpixels-hfp-hsp-hbp)&&(vc<vlines-vfp-vsp-vbp);\n\nendmodule\n",
        "module_name": "vgabase",
        "module_hash": "df58556ea430d25a41fccffe5c196fd5",
        "dataset_index": 16869
      },
      "or_sleep_48e1dfc0": {
        "rtl_code": "module or_sleep (\n    input A,\n    input SLEEP,\n    output X\n);\n\n    wire B;\n    assign B = 1'b0;\n\n    assign X = (SLEEP == 1'b1) ? 1'b0 : (A | B);\n\nendmodule",
        "module_name": "or_sleep",
        "module_hash": "48e1dfc004cbc2c9284707e0930dc222",
        "dataset_index": 2303
      },
      "synchronous_ram_4port_93db231d": {
        "rtl_code": "module synchronous_ram_4port\n  (\n   // Generic synchronous 4-port RAM interface\n   clk, ce, we, addr, di, doq\n   );\n   \n   //\n   // Default address and data buses width\n   //\n   parameter aw = 10;\n   parameter dw = 32;\n   \n   //\n   // Generic synchronous 4-port RAM interface\n   //\n   input \t\t\t\t  clk;\t// Clock\n   input \t\t\t\t  ce;\t// Chip enable input\n   input [3:0]\t\t\t\t  we;\t// Write enable input\n   input [aw-1:0] \t\t\t  addr;\t// address bus inputs\n   input [dw-1:0] \t\t\t  di;\t// input data bus\n   output [dw-1:0] \t\t\t  doq;\t// output data bus\n   \n   //\n   // Internal wires and registers\n   //\n\n   //\n   // 4-port synchronous RAM model\n   //\n   \n   //\n   // 4-port RAM's registers and wires\n   //\n   reg [dw-1:0] \t\t\t\t  mem0 [(1<<aw)-1:0] ;\n   reg [dw-1:0] \t\t\t\t  mem1 [(1<<aw)-1:0] ;\n   reg [dw-1:0] \t\t\t\t  mem2 [(1<<aw)-1:0] ;\n   reg [dw-1:0] \t\t\t\t  mem3 [(1<<aw)-1:0] ;\n   reg [aw-1:0] \t\t\t  addr_reg;\t\t// RAM address register\n   \n   //\n   // Data output drivers\n   //\n   assign doq = {mem0[addr_reg], mem1[addr_reg], mem2[addr_reg], mem3[addr_reg]};\n   \n   //\n   // RAM read address register\n   //\n   always @(posedge clk)\n     if (ce)\n       addr_reg <=  addr;\n   \n   //\n   // RAM write - big endian selection\n   //\n   always @(posedge clk)\n     if (ce) begin\n       if (we[3])\n         mem0[addr] <=  di[31:24];\n       if (we[2])\n         mem1[addr] <=  di[23:16];\n       if (we[1])\n         mem2[addr] <=  di[15:08];\n       if (we[0])\n         mem3[addr] <=  di[07:00];\n     end\n   \nendmodule",
        "module_name": "synchronous_ram_4port",
        "module_hash": "93db231d984da7fa008757339f23f29f",
        "dataset_index": 9072
      },
      "shift_register_68392fac": {
        "rtl_code": "module shift_register (\n    input clk,\n    input [3:0] data_in,\n    input shift_right,\n    input load,\n    output reg [3:0] data_out\n);\n\nreg [3:0] register;\n\nalways @(posedge clk) begin\n    if (load) begin\n        register <= data_in;\n    end else begin\n        if (shift_right) begin\n            register <= {register[2:0], register[3]};\n        end else begin\n            register <= {register[3], register[2:0]};\n        end\n    end\nend\n\nalways @* begin\n    data_out = register;\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "68392fac5dbd3f28772267cf1fb61d67",
        "dataset_index": 202
      },
      "and_gate_871061ac": {
        "rtl_code": "\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\n    wire and_out;\n\n    and (\n        and_out,\n        a,\n        b\n    );\n    assign y = and_out;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "871061ac72cd141ab5fdc4a7ed2074dd",
        "dataset_index": 19340
      },
      "vga_sync_47c1cd4d": {
        "rtl_code": "module vga_sync(\n\ninput wire clock,\ninput wire aresetn,\n\ninput wire [2:0] color,\n\noutput wire vga_clk,\n\noutput reg [7:0] R,\noutput reg [7:0] G,\noutput reg [7:0] B,\n\noutput reg h_sync,\noutput reg v_sync,\n\noutput wire blank_n,\noutput wire sync_n\n);\n\n\n\nlocalparam\tH_FRONT\t\t  =\t56;\nlocalparam\tH_SYNC\t\t  =\t120;\nlocalparam\tH_BACK\t\t  =\t64;\nlocalparam\tH_ACT\t   \t  =\t800;\nlocalparam\tH_BLANK\t\t  =\tH_FRONT+H_SYNC+H_BACK;\nlocalparam\tH_TOTAL\t\t  =\tH_FRONT+H_SYNC+H_BACK+H_ACT;\nlocalparam  H_TOTAL_WIDTH =   10;\n\nlocalparam\tV_FRONT\t\t  =\t37;\nlocalparam\tV_SYNC\t\t  =\t6;\nlocalparam\tV_BACK\t\t  =\t23;\nlocalparam\tV_ACT\t   \t  =\t600;\nlocalparam\tV_BLANK\t\t  =\tV_FRONT+V_SYNC+V_BACK;\nlocalparam\tV_TOTAL\t\t  =\tV_FRONT+V_SYNC+V_BACK+V_ACT;\nlocalparam  V_TOTAL_WIDTH =   10;\n\nassign vga_clk = ~clock;\n\nreg [(H_TOTAL_WIDTH-1):0] hor_pos;\nreg [(V_TOTAL_WIDTH-1):0] ver_pos;\n\nalways @(posedge clock) begin\n\tif (~aresetn)\t\n\t\tbegin\n\t\t\thor_pos <= 'd0;\n\t\t\th_sync  <= 1'b0;\n\t\tend\n\telse\n\t\tbegin\n\t\t\tif (hor_pos < H_TOTAL)\thor_pos <= hor_pos + 1;\n\t\t\telse \t\t\t\t\t\t\thor_pos <= 0;\n\t\t\t\n\t\t\tif (hor_pos == H_FRONT-1) \t\t\th_sync <= 1'b1;\n\t\t\tif (hor_pos == H_FRONT+H_SYNC-1) h_sync <= 1'b0;\n\t\t\n\t\tend\nend\n\nalways @(posedge h_sync) begin\n\tif (~aresetn)\t\n\t\tbegin\n\t\t\tver_pos <= 'd0;\n\t\t\tv_sync  <= 1'b0;\n\t\tend\n\telse\n\t\tbegin\n\t\t\tif (ver_pos < V_TOTAL)\tver_pos <= ver_pos + 1;\n\t\t\telse \t\t\t\t\t\t\tver_pos <= 0;\n\t\t\t\n\t\t\tif (ver_pos == V_FRONT-1) \t\t\tv_sync <= 1'b1;\n\t\t\tif (ver_pos == V_FRONT+V_SYNC-1) v_sync <= 1'b0;\n\t\t\n\t\tend\nend\n\nalways @(posedge clock) begin\n\tif (~aresetn) \n\t\tbegin\n\t\t\tR <= 8'd0;\n\t\t\tB <= 8'd0;\n\t\t\tG <= 8'd0;\n\t\tend\n\telse if ((hor_pos < H_BLANK) | (ver_pos < V_BLANK))\n\t\tbegin\n\t\t\tR <= 8'd0;\n\t\t\tB <= 8'd0;\n\t\t\tG <= 8'd0;\t\t\n\t\tend\n\telse \n\t\tbegin\n\t\t\tif (color == 3'b100)\n\t\t\t\tbegin\n\t\t\t\t\tR <= hor_pos[7:0];\n\t\t\t\t\tG <= ver_pos[7:0];\n\t\t\t\t\tB <= hor_pos[7:0];\t\t\n\t\t\t\tend\n\t\t\telse if (color == 3'b110)\n\t\t\t\tbegin\n\t\t\t\t\tR <= 8'd255;\n\t\t\t\t\tG <= 8'd0;\n\t\t\t\t\tB <= 8'd0;\t\t\n\t\t\t\tend\t\n\t\t\telse if (color == 3'b101)\n\t\t\t\tbegin\n\t\t\t\t\tR <= 8'd0;\n\t\t\t\t\tG <= 8'd255;\n\t\t\t\t\tB <= 8'd0;\t\t\n\t\t\t\tend\t\n\t\t\telse if (color == 3'b011)\n\t\t\t\tbegin\n\t\t\t\t\tR <= 8'd0;\n\t\t\t\t\tG <= 8'd0;\n\t\t\t\t\tB <= 8'd255;\t\t\n\t\t\t\tend\t\n\t\t\telse \n\t\t\t\tbegin\n\t\t\t\t\tR <= R;\n\t\t\t\t\tG <= G;\n\t\t\t\t\tB <= B;\t\t\t\t\t\n\t\t\t\tend\n\t\tend\nend\n\nassign blank_n = ~((hor_pos < H_BLANK)||(ver_pos < V_BLANK));\n\nassign sync_n  = 1'b1; \n\nendmodule\n",
        "module_name": "vga_sync",
        "module_hash": "47c1cd4d60ee69e953ac80358f1312d2",
        "dataset_index": 8431
      },
      "binary_counter_d770aad5": {
        "rtl_code": "module binary_counter (\n    input CLK,\n    input RST,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "d770aad589bd26d8a67a33bb703a92c7",
        "dataset_index": 1705
      },
      "control_unit_6ec94dfc": {
        "rtl_code": "module control_unit(\n    input [1:0] ctrl,\n    input [3:0] data_in,\n    input load,\n    input clk,\n    output reg [3:0] data_out,\n    output reg valid\n);\n\nreg [3:0] reg_data;\n\nalways @(posedge clk) begin\n    if (load) begin\n        reg_data <= data_in;\n    end else begin\n        case(ctrl)\n            2'b00: begin\n                data_out <= reg_data;\n                valid <= 1'b1;\n            end\n            2'b01: begin\n                data_out <= ~reg_data;\n                valid <= 1'b1;\n            end\n            2'b10: begin\n                data_out <= data_in;\n                valid <= 1'b1;\n            end\n            2'b11: begin\n                data_out <= ~data_in;\n                valid <= 1'b1;\n            end\n            default: begin\n                data_out <= 4'b0;\n                valid <= 1'b0;\n            end\n        endcase\n    end\nend\n\ninitial begin\n    reg_data = 4'b0;\nend\n\nendmodule",
        "module_name": "control_unit",
        "module_hash": "6ec94dfcd9617edbccbd82543c4fd399",
        "dataset_index": 19322
      },
      "uart_tx #_d5e9aac9": {
        "rtl_code": "\n\n\nmodule uart_tx #\n(\n    parameter DATA_WIDTH = 8\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n\n    \n    output wire                   txd,\n\n    \n    output wire                   busy,\n\n    \n    input  wire [15:0]            prescale\n);\n\nreg s_axis_tready_reg = 0;\n\nreg txd_reg = 1;\n\nreg busy_reg = 0;\n\nreg [DATA_WIDTH:0] data_reg = 0;\nreg [18:0] prescale_reg = 0;\nreg [3:0] bit_cnt = 0;\n\nassign s_axis_tready = s_axis_tready_reg;\nassign txd = txd_reg;\n\nassign busy = busy_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        s_axis_tready_reg <= 0;\n        txd_reg <= 1;\n        prescale_reg <= 0;\n        bit_cnt <= 0;\n        busy_reg <= 0;\n    end else begin\n        if (prescale_reg > 0) begin\n            s_axis_tready_reg <= 0;\n            prescale_reg <= prescale_reg - 1;\n        end else if (bit_cnt == 0) begin\n            s_axis_tready_reg <= 1;\n            busy_reg <= 0;\n\n            if (s_axis_tvalid) begin\n                s_axis_tready_reg <= !s_axis_tready_reg;\n                prescale_reg <= (prescale << 3)-1;\n                bit_cnt <= DATA_WIDTH+1;\n                data_reg <= {1'b1, s_axis_tdata};\n                txd_reg <= 0;\n                busy_reg <= 1;\n            end\n        end else begin\n            if (bit_cnt > 1) begin\n                bit_cnt <= bit_cnt - 1;\n                prescale_reg <= (prescale << 3)-1;\n                {data_reg, txd_reg} <= {1'b0, data_reg};\n            end else if (bit_cnt == 1) begin\n                bit_cnt <= bit_cnt - 1;\n                prescale_reg <= (prescale << 3);\n                txd_reg <= 1;\n            end\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "uart_tx #",
        "module_hash": "d5e9aac9b244c173291f30c70068f35d",
        "dataset_index": 24325
      },
      "sync_ram_wf_x32_f488767f": {
        "rtl_code": "module sync_ram_wf_x32 (\n   // Outputs\n   dout,\n   // Inputs\n   clk, web, enb, addr, din\n   );\n   parameter ADDR_WIDTH = 10;\n\n   input clk;\n   input [3:0]web;\n   input [3:0]enb;\n   input [9:0] addr;\n   input [31:0] din;\n   output [31:0] dout;\n   reg [31:0]    RAM [(2<<ADDR_WIDTH)-1:0];\n   reg [31:0]    dout;\n\n   always @(posedge clk)\n     begin\n        if (enb[0])\n          begin\n             if (web[0])\n               begin\n                  RAM[addr][7:0] <= din[7:0];\n                  dout[7:0] <= din[7:0];\n               end\n             else begin\n                dout[7:0] <= RAM[addr][7:0];\n             end\n          end\n     end // always @ (posedge clk)\n   always @(posedge clk)\n     begin\n        if (enb[1])\n          begin\n             if (web[1])\n               begin\n                  RAM[addr][15:8] <= din[15:8];\n                  dout[15:8] <= din[15:8];\n               end\n             else begin\n                dout[15:8] <= RAM[addr][15:8];\n             end\n          end\n     end // always @ (posedge clk)\n\n   always @(posedge clk)\n     begin\n        if (enb[2])\n          begin\n             if (web[2])\n               begin\n                  RAM[addr][23:16] <= din[23:16];\n                  dout[23:16] <= din[23:16];\n               end\n             else begin\n                dout[23:16] <= RAM[addr][23:16];\n             end\n          end\n     end\n\n   always @(posedge clk)\n     begin\n        if (enb[3])\n          begin\n             if (web[3])\n               begin\n                  RAM[addr][31:24] <= din[31:24];\n                  dout[31:24] <= din[31:24];\n               end\n             else begin\n                dout[31:24] <= RAM[addr][31:24];\n             end\n          end\n     end\n\nendmodule",
        "module_name": "sync_ram_wf_x32",
        "module_hash": "f488767f1e92c7aaa18ea125971cabf1",
        "dataset_index": 16551
      },
      "counter_0081a136": {
        "rtl_code": "module counter(clk, rst, count);\n\ninput clk, rst;\noutput reg [3:0] count;\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        count <= 4'b0000;\n    end else begin\n        if(count == 4'b1111) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 4'b0001;\n        end\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "0081a136fb769f8d52445d7ee96819bc",
        "dataset_index": 2422
      },
      "counter #_f3261987": {
        "rtl_code": "module counter #(\n    parameter WIDTH = 8,\n    parameter MODULUS = 256\n)(\n    input clk,\n    input ce,\n    input clr,\n    output reg [WIDTH-1:0] out\n);\n\n    always @(posedge clk) begin\n        if (clr) begin\n            out <= 0;\n        end else if (ce) begin\n            out <= (out == MODULUS-1) ? 0 : out + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter #",
        "module_hash": "f32619879584e9a3af58e9845e142107",
        "dataset_index": 1861
      },
      "dly1_17_mod_0b38a298": {
        "rtl_code": "\nmodule dly1_17_mod (\n    input wire [16:0] i,\n    input wire rst,\n    input wire clk,\n    output wire [16:0] o,\n    output wire done\n);\n\n    reg [16:0] temp;\n    reg done_reg;\n    reg done_next;\n\n    assign o = temp;\n    assign done = done_reg;\n\n    always @(posedge rst or posedge clk)\n    begin\n        if (rst)\n        begin\n            temp <= 0;\n            done_reg <= 0;\n        end\n        else\n        begin\n            temp <= i;\n            done_next <= (temp == i);\n            done_reg <= done_next;\n        end\n    end\n\nendmodule",
        "module_name": "dly1_17_mod",
        "module_hash": "0b38a2986fc928cafc10d63046905d41",
        "dataset_index": 14780
      },
      "barrel_shifter_55edd472": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    output [31:0] data_out\n);\n\n    assign data_out = data_in >> shift_amt;\n\nendmodule\nmodule adder (\n    input [7:0] num1,\n    input [7:0] num2,\n    output [8:0] sum\n);\n\n    assign sum = num1 + num2;\n\nendmodule\nmodule functional_module (\n    input [31:0] data_in,\n    input [8:0] sum_in,\n    output [31:0] final_out\n);\n\n    assign final_out = data_in + {{23{1'b0}}, sum_in};\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input [7:0] num1,\n    input [7:0] num2,\n    output [31:0] final_out\n);\n\n    wire [31:0] shifted_data;\n    wire [8:0] sum;\n\n    barrel_shifter shifter (\n        .data_in(data_in),\n        .shift_amt(shift_amt),\n        .data_out(shifted_data)\n    );\n\n    adder add (\n        .num1(num1),\n        .num2(num2),\n        .sum(sum)\n    );\n\n    functional_module func (\n        .data_in(shifted_data),\n        .sum_in(sum),\n        .final_out(final_out)\n    );\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "55edd472e278c048947151fdbd6a55e2",
        "dataset_index": 12262
      },
      "CDR_70f69e38": {
        "rtl_code": "module CDR (\n  input data_in,\n  input clk_ref,\n  output clk_out,\n  output data_out\n);\n\n  // Internal signals\n  reg data_in_delayed;\n  reg [1:0] data_in_edge;\n  reg clk_out_delayed;\n  reg data_out_delayed;\n  \n  // Delayed data input\n  always @(posedge clk_ref) begin\n    data_in_delayed <= data_in;\n  end\n  \n  // Detect data input edges\n  always @(posedge clk_ref) begin\n    data_in_edge <= {data_in_delayed, data_in} - {data_in, data_in_delayed};\n  end\n  \n  // Generate recovered clock\n  always @(posedge clk_ref) begin\n    if (data_in_edge == 2'b01 || data_in_edge == 2'b10) begin\n      clk_out_delayed <= ~clk_out_delayed;\n    end\n  end\n  \n  // Generate recovered data\n  always @(posedge clk_out_delayed) begin\n    data_out_delayed <= data_in_delayed;\n  end\n  \n  // Output signals\n  assign clk_out = clk_out_delayed;\n  assign data_out = data_out_delayed;\n  \nendmodule",
        "module_name": "CDR",
        "module_hash": "70f69e38166f07bf372f57189bd557c7",
        "dataset_index": 14973
      },
      "shift_register_0c3b8ce8": {
        "rtl_code": "module shift_register ( input clk, input serial_in, output serial_out );\n\n  wire q0, q1, q2;\n\n  d_flip_flop dff0 ( .clk(clk), .d(serial_in), .q(q0) );\n  d_flip_flop dff1 ( .clk(clk), .d(q0), .q(q1) );\n  d_flip_flop dff2 ( .clk(clk), .d(q1), .q(q2) );\n\n  assign serial_out = q2;\n\nendmodule\n\nmodule d_flip_flop ( input clk, input d, output q );\n\n  reg q;\n\n  always @(posedge clk) begin\n    q <= d;\n  end\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "0c3b8ce8edc6109c5485ffb8a96a5b82",
        "dataset_index": 7302
      },
      "ycbcr_to_rgb_02dbae5a": {
        "rtl_code": "module ycbcr_to_rgb (\n\ty,cb,cr,\n\tred,green,blue,\n\tclk\n);\n\ninput clk;\n\ninput [7:0] y,cb,cr;\noutput reg [7:0] red,green,blue;\n\nreg signed [8:0] adj_y,adj_cb,adj_cr;\nalways @(posedge clk) begin\n\tadj_y <= y;\n\tadj_cr <= cr - 8'd128;\n\tadj_cb <= cb - 8'd128;\nend\n\nwire signed [8:0] const0 = 9'd128; wire signed [8:0] const1 = 9'd179; wire signed [8:0] const2 = - 9'd91; wire signed [8:0] const3 = - 9'd44;\twire signed [8:0] const4 = 9'd227; reg signed [17:0] product_a, product_b, product_c, \n\tproduct_d, product_e;\nalways @(posedge clk) begin\n\tproduct_a <= const0 * adj_y;\n\tproduct_b <= const1 * adj_cr;\n\tproduct_c <= const2 * adj_cr;\n\tproduct_d <= const3 * adj_cb;\n\tproduct_e <= const4 * adj_cb;\nend\n\nreg signed [17:0] sum_red, sum_green, sum_blue;\nalways @(posedge clk) begin\n\tsum_red <= product_a + product_b;\n\tsum_green <= product_a + product_c + product_d;\n\tsum_blue <= product_a + product_e;\nend\n\nalways @(posedge clk) begin\n\tred <= sum_red[17] ? 8'h0 : \n\t\t\t(sum_red[15] | sum_red[16]) ? 8'hff :\n\t\t\tsum_red [14:7];\n\tgreen <= sum_green[17] ? 8'h0 : \n\t\t\t(sum_green[15] | sum_green[16]) ? 8'hff :\n\t\t\tsum_green [14:7];\n\tblue <= sum_blue[17] ? 8'h0 : \n\t\t\t(sum_blue[15] | sum_blue[16]) ? 8'hff :\n\t\t\tsum_blue [14:7];\nend\n\nendmodule\n",
        "module_name": "ycbcr_to_rgb",
        "module_hash": "02dbae5a4e3fb8a6326e23b96c47e7f4",
        "dataset_index": 24350
      },
      "p_aoi222_34610e0b": {
        "rtl_code": "module p_aoi222(q, a, b, c, d, e, f);\n  output q;\n  input a, b, c, d, e, f;\n  wire [1:0] internal_0n;\n  wire [2:0] int_0n;\n  AN2 I0 (q, internal_0n[0], internal_0n[1]);\n  IV I1 (internal_0n[1], int_0n[2]);\n  NR2 I2 (internal_0n[0], int_0n[0], int_0n[1]);\n  AN2 I3 (int_0n[2], e, f);\n  AN2 I4 (int_0n[1], c, d);\n  AN2 I5 (int_0n[0], a, b);\nendmodule\n\nmodule AN2 (out, in1, in2);\n  output out;\n  input in1, in2;\n  assign out = in1 & in2;\nendmodule\n\nmodule IV (out, in1);\n  output out;\n  input in1;\n  assign out = ~in1;\nendmodule\n\nmodule NR2 (out, in1, in2);\n  output out;\n  input in1, in2;\n  assign out = ~(in1 | in2);\nendmodule",
        "module_name": "p_aoi222",
        "module_hash": "34610e0b8f29b13b99620acd0b04de0c",
        "dataset_index": 17638
      },
      "xor_2input_nand_991d03b0": {
        "rtl_code": "module xor_2input_nand (\n  input a,\n  input b,\n  output reg y\n);\n\n  wire w1, w2, w3, w4;\n  \n  nand(w1, a, b);\n  nand(w2, a, w1);\n  nand(w3, b, w1);\n  nand(w4, w2, w3);\n  \n  always @(w4) begin\n    y <= ~w4;\n  end\n  \nendmodule\n",
        "module_name": "xor_2input_nand",
        "module_hash": "991d03b069f90c278b046c6da97a9c47",
        "dataset_index": 14888
      },
      "HLS_accel_a_ram_74a107fd": {
        "rtl_code": "\nmodule HLS_accel_a_ram (addr0, ce0, d0, we0, q0, addr1, ce1, q1,  clk);\n\nparameter DWIDTH = 32;\nparameter AWIDTH = 10;\nparameter MEM_SIZE = 1024;\n\ninput[AWIDTH-1:0] addr0;\ninput ce0;\ninput[DWIDTH-1:0] d0;\ninput we0;\noutput reg[DWIDTH-1:0] q0;\ninput[AWIDTH-1:0] addr1;\ninput ce1;\noutput reg[DWIDTH-1:0] q1;\ninput clk;\n\nreg [DWIDTH-1:0] ram[MEM_SIZE-1:0];\n\n\n\n\nalways @(posedge clk)  \nbegin \n    if (ce0) \n    begin\n        if (we0) \n        begin \n            ram[addr0] <= d0; \n            q0 <= d0;\n        end \n        else \n            q0 <= ram[addr0];\n    end\nend\n\n\nalways @(posedge clk)  \nbegin \n    if (ce1) \n    begin\n            q1 <= ram[addr1];\n    end\nend\n\n\nendmodule\n\nmodule HLS_accel_a(\n    reset,\n    clk,\n    address0,\n    ce0,\n    we0,\n    d0,\n    q0,\n    address1,\n    ce1,\n    q1);\n\nparameter DataWidth = 32'd32;\nparameter AddressRange = 32'd1024;\nparameter AddressWidth = 32'd10;\ninput reset;\ninput clk;\ninput[AddressWidth - 1:0] address0;\ninput ce0;\ninput we0;\ninput[DataWidth - 1:0] d0;\noutput[DataWidth - 1:0] q0;\ninput[AddressWidth - 1:0] address1;\ninput ce1;\noutput[DataWidth - 1:0] q1;\n\n\n\nHLS_accel_a_ram HLS_accel_a_ram_U(\n    .clk( clk ),\n    .addr0( address0 ),\n    .ce0( ce0 ),\n    .d0( d0 ),\n    .we0( we0 ),\n    .q0( q0 ),\n    .addr1( address1 ),\n    .ce1( ce1 ),\n    .q1( q1 ));\n\nendmodule\n\n",
        "module_name": "HLS_accel_a_ram",
        "module_hash": "74a107fdd71b744641950ff874f8ad9a",
        "dataset_index": 24426
      },
      "jt12_amp_e7d595f9": {
        "rtl_code": "\n\n\nmodule jt12_amp(\n\tinput\t\t\tclk,\n\tinput\t\t\trst,\n\tinput\t\t\tsample,\n\tinput\t[2:0]\tvolume,\n\n\tinput\t\tsigned\t[13:0]\tpre,\t\n\toutput\treg signed\t[15:0]\tpost\n);\n\nwire signed [14:0] x2 = pre<<<1;\nwire signed [15:0] x3 = x2+pre;\nwire signed [15:0] x4 = pre<<<2;\nwire signed [16:0] x6 = x4+x2;\nwire signed [16:0] x8 = pre<<<3;\nwire signed [17:0] x12 = x8+x4;\nwire signed [17:0] x16 = pre<<<4;\n\nalways @(posedge clk)\nif( rst )\n\tpost <= 16'd0;\nelse\nif( sample )\n\tcase( volume ) \n\t\t3'd0: post <= { {2{pre[13]}}, pre\t};\n\t\t3'd1: post <= { x2[14], x2\t};\n\t\t3'd2: post <= { x2, 1'd0   \t};\n\t\t\t\n\t\t3'd3: post <= x4;\n\t\t\t\n\t\t3'd4: casex( x6[16:15] )\n\t\t\t\t2'b00, 2'b11: post <= x6[15:0];\n\t\t\t\t2'b0x: post <= 16'h7FFF;\n\t\t\t\t2'b1x: post <= 16'h8000;\n\t\t\tendcase\t\t\t\t\n\t\t\t\n\t\t3'd5: casex( x8[16:15] )\n\t\t\t\t2'b00, 2'b11: post <= x8[15:0];\n\t\t\t\t2'b0x: post <= 16'h7FFF;\n\t\t\t\t2'b1x: post <= 16'h8000;\n\t\t\tendcase\n\t\t3'd6: casex( x12[17:15] )\n\t\t\t\t3'b000, 3'b111: post <= x12[15:0];\n\t\t\t\t3'b0xx: post <= 16'h7FFF;\n\t\t\t\t3'b1xx: post <= 16'h8000;\t\t\t\t\n\t\t\tendcase\t\n\t\t3'd7: casex( x16[17:15] )\n\t\t\t\t3'b000, 3'b111: post <= x16[15:0];\n\t\t\t\t3'b0xx: post <= 16'h7FFF;\n\t\t\t\t3'b1xx: post <= 16'h8000;\t\t\t\t\n\t\t\tendcase\t\t\t\t\t\t\n\tendcase\n\nendmodule\n\nmodule jt12_amp_stereo(\n\tinput\t\t\tclk,\n\tinput\t\t\trst,\n\tinput\t\t\tsample,\n\n\tinput\t\t\t[ 5:0]\tpsg,\n\tinput\t\t\tenable_psg,\n\n\tinput\tsigned\t[11:0]\tfmleft,\n\tinput\tsigned\t[11:0]\tfmright,\n\tinput\t[2:0]\tvolume,\n\t\n\toutput\tsigned\t[15:0]\tpostleft,\n\toutput\tsigned\t[15:0]\tpostright\n);\n\nwire signed\t[13:0]\tpreleft;\nwire signed\t[13:0]\tpreright;\n\nwire signed [8:0] psg_dac = psg<<<3;\n\nwire signed [12:0] psg_sum = {13{enable_psg}} & { 2'b0, psg_dac, 1'b0 };\n\n\nassign preleft = {  fmleft [11], fmleft, 1'd0 } + psg_sum;\nassign preright= {  fmright[11],fmright, 1'd0 } + psg_sum;\n\njt12_amp amp_left(\n\t.clk\t( clk\t\t),\n\t.rst\t( rst\t\t),\n\t.sample\t( sample\t),\n\t.pre\t( preleft\t),\n\t.post\t( postleft\t),\n\t.volume\t( volume\t)\n);\n\njt12_amp amp_right(\n\t.clk\t( clk\t\t),\n\t.rst\t( rst\t\t),\n\t.sample\t( sample\t),\n\t.pre\t( preright\t),\n\t.post\t( postright\t),\n\t.volume\t( volume\t)\n);\n\nendmodule\n",
        "module_name": "jt12_amp",
        "module_hash": "e7d595f9ea45f61707bd6838b4ffd6d8",
        "dataset_index": 22140
      },
      "clock_divider_6e44d57c": {
        "rtl_code": "module clock_divider(\n  input wire clk,\n  input wire reset,\n  input wire enabled,\n  output reg refresh_clk,\n  output reg sys_clk\n  );\n  \n  reg [8:0] counter1; \n  reg [8:0] counter2;\n  reg [8:0] clk_divid;\n\n  always@(posedge clk or negedge reset)\n    begin\n      if( ~reset )\n        begin\n          refresh_clk <= 1;\n          sys_clk <= 0;\n          counter1 <= 0;\n          counter2 <= 63;\n          clk_divid <= 100;\n        end\n      else if( enabled )\n        begin\n          clk_divid <= clk_divid;\n          if( counter1 < clk_divid )\n            begin\n              counter1 <= counter1 + 1;\n              refresh_clk <= refresh_clk;\n            end\n          else\n            begin\n              refresh_clk <= !refresh_clk;\n              counter1 <= 0;\n            end\n          if( counter2 < clk_divid )\n            begin\n              counter2 <= counter2 + 1;\n              sys_clk <= sys_clk;\n            end\n          else\n            begin\n              sys_clk <= !sys_clk;\n              counter2 <= 0;\n            end\n        end\n    end\nendmodule\n",
        "module_name": "clock_divider",
        "module_hash": "6e44d57c8e5b08fe50575e485c1130e3",
        "dataset_index": 4486
      },
      "twos_comp_addsub_1d15f1fc": {
        "rtl_code": "module twos_comp_addsub (\n    input signed [15:0] a,\n    input signed [15:0] b,\n    input sub,\n    output reg signed [15:0] result,\n    output reg overflow\n);\n\n    always @(*) begin\n        if (sub) begin\n            result = a - b;\n            overflow = ((a < 0) & (b > 0) & (result > 0)) | ((a > 0) & (b < 0) & (result < 0));\n        end else begin\n            result = a + b;\n            overflow = ((a > 0) & (b > 0) & (result < 0)) | ((a < 0) & (b < 0) & (result > 0));\n        end\n    end\n\nendmodule",
        "module_name": "twos_comp_addsub",
        "module_hash": "1d15f1fc5c0915197a6cad316b20c2c1",
        "dataset_index": 1091
      },
      "UART_rx_93bdafdf": {
        "rtl_code": "\nmodule UART_rx(\n\tinput rx,\t\t\t\t\tinput s_tick,\t\t\t\tinput reset,\n\tinput clock,\t\t\t\toutput reg rx_done,\t\toutput reg [7:0] d_out\t);\n\tlocalparam [1:0]\tIDLE = 0,\n\t\t\t\t\t\t\tSTART = 1,\n\t\t\t\t\t\t\tDATA = 2,\n\t\t\t\t\t\t\tSTOP = 3;\n\n\tlocalparam \t\t\tD_BIT = 8,\n\t\t\t\t\t\t\tB_start= 0,\n\t\t\t\t\t\t\tB_stop= 1;\n\t\n\treg [1:0] current_state, next_state;\n\treg [3:0] s;\n\treg [3:0] n;\n\n\talways @(posedge clock, posedge reset) begin\n\t\tif(reset)\n\t\t\tcurrent_state <= IDLE ;\n\t\telse\n\t\t\tcurrent_state <= s_tick ? next_state : current_state;\n\tend\n\t\n\talways @(posedge clock) begin\n\t\tif(s_tick) begin\n\t\t\tcase(current_state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\trx_done=0;\n\t\t\t\t\ts = 0;\n\t\t\t\t\tnext_state = (rx == B_start) ? START : IDLE;\n\t\t\t\tend\n\t\t\t\tSTART: begin\n\t\t\t\t\trx_done=0;\n\t\t\t\t\tif(s >= 7) begin\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t\tn = 0;\n\t\t\t\t\t\tnext_state = DATA;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\ts = s + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tDATA: begin\n\t\t\t\t\tif(s >= 15) begin\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t\tif(n >= D_BIT) begin\n\t\t\t\t\t\t\tnext_state = STOP;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\td_out = {rx,d_out[7:1]};\n\t\t\t\t\t\t\tn = n + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\ts = s + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t   if(rx==0)begin\n\t\t\t\t\t\trx_done = 1;\n\t\t\t\t\t\tnext_state = START;\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t\tn = 0;\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\t\telse if(s >= 15) begin\n\t\t\t\t\t\trx_done = 1;\n\t\t\t\t\t\tnext_state = IDLE;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\ts = s + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\nendmodule\n",
        "module_name": "UART_rx",
        "module_hash": "93bdafdf295f3337ee64a70d1d4f0f75",
        "dataset_index": 16098
      },
      "counter_4bit_76195807": {
        "rtl_code": "module counter_4bit(clk, reset, count);\n\n   input clk, reset;\n   output reg [3:0] count;\n   \n   always @(posedge clk or negedge reset) begin\n      if (reset == 0) begin\n         count <= 0;\n      end else begin\n         count <= count + 1;\n      end\n   end\n\nendmodule",
        "module_name": "counter_4bit",
        "module_hash": "76195807f0dadb6c3642a93151395351",
        "dataset_index": 19112
      },
      "shift_add_multiplier_d5a8f94b": {
        "rtl_code": "module shift_add_multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] out\n);\n    reg [31:0] product;\n    reg [15:0] multiplicand;\n    reg [15:0] multiplier;\n    integer i;\n\n    always @(*) begin\n        product = 32'h0;\n        multiplicand = a;\n        multiplier = b;\n\n        for (i = 0; i < 16; i = i + 1) begin\n            if (multiplier[0] == 1) begin\n                product = product + (multiplicand << i);\n            end\n            multiplier = multiplier >> 1;\n        end\n    end\n\n    assign out = product;\nendmodule",
        "module_name": "shift_add_multiplier",
        "module_hash": "d5a8f94bbd5289a14f8150565b93ef4f",
        "dataset_index": 7713
      },
      "bcd_converter_8d19a822": {
        "rtl_code": "module bcd_converter (\n    input [3:0] input_val,\n    output reg [15:0] bcd_val\n);\n\nalways @(*) begin\n    case(input_val)\n        4'b0000: bcd_val = 16'b0000000000000000;\n        4'b0001: bcd_val = 16'b0000000000000001;\n        4'b0010: bcd_val = 16'b0000000000000010;\n        4'b0011: bcd_val = 16'b0000000000000011;\n        4'b0100: bcd_val = 16'b0000000000000100;\n        4'b0101: bcd_val = 16'b0000000000000101;\n        4'b0110: bcd_val = 16'b0000000000000110;\n        4'b0111: bcd_val = 16'b0000000000000111;\n        4'b1000: bcd_val = 16'b0000000000010000;\n        4'b1001: bcd_val = 16'b0000000000010001;\n        default: bcd_val = 16'b0000000000000000;\n    endcase\nend\n\nendmodule",
        "module_name": "bcd_converter",
        "module_hash": "8d19a8223c2050204328125d648eb0ca",
        "dataset_index": 6857
      },
      "fifo_6ba792ec": {
        "rtl_code": "\nmodule fifo (\n  input clk, // clock signal\n  input rst, // reset signal\n  input [7:0] data_in, // input data\n  input wr_en, // write enable signal\n  output reg [7:0] data_out, // output data\n  input rd_en, // read enable signal\n  output reg full = 0, // FIFO full signal\n  output reg empty = 1 // FIFO empty signal\n);\n\nparameter DEPTH = 8; // FIFO depth\n  \nreg [7:0] mem [DEPTH-1:0]; // internal memory array\nreg [2:0] wr_ptr = 0, rd_ptr = 0; // write and read pointers\nreg [2:0] count = 0; // number of elements in the FIFO\n\nalways @(posedge clk) begin\n  if (rst) begin\n    wr_ptr <= 0;\n    rd_ptr <= 0;\n    count <= 0;\n    empty <= 1;\n    full <= 0;\n  end else begin\n    if (wr_en & ~full) begin // Corrected the condition\n      mem[wr_ptr] <= data_in;\n      wr_ptr <= wr_ptr + 1;\n      if (wr_ptr == DEPTH) begin\n        wr_ptr <= 0;\n      end\n      count <= count + 1;\n      empty <= 0;\n      if (count == DEPTH) begin\n        full <= 1;\n      end\n    end\n    if (rd_en & ~empty) begin // Corrected the condition\n      data_out <= mem[rd_ptr];\n      rd_ptr <= rd_ptr + 1;\n      if (rd_ptr == DEPTH) begin\n        rd_ptr <= 0;\n      end\n      count <= count - 1;\n      full <= 0;\n      if (count == 0) begin\n        empty <= 1;\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "6ba792ec485571979dfc2680b8a6e2bb",
        "dataset_index": 17329
      },
      "simple_calculator_f4bd12ef": {
        "rtl_code": "module simple_calculator(\n    input [7:0] A,\n    input [7:0] B,\n    input [1:0] opcode,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    case (opcode)\n        2'b00: result = A + B; // addition\n        2'b01: result = A - B; // subtraction\n        2'b10: result = A * B; // multiplication\n        2'b11: result = A / B; // division\n    endcase\nend\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "f4bd12ef8ebe213e4ec934312445994b",
        "dataset_index": 1783
      },
      "adder_4bit_fd23b27a": {
        "rtl_code": "\nmodule adder_4bit(a, b, cin, sum, cout);\n  input [3:0] a, b;\n  input cin;\n  output [3:0] sum;\n  output cout;\n\n  wire [2:0] c;  // Carry signals\n\n  assign c[0] = cin;\n\n  assign sum[0] = a[0] ^ b[0] ^ c[0];\n  assign c[1] = (a[0] & b[0]) | (a[0] & c[0]) | (b[0] & c[0]);\n\n  assign sum[1] = a[1] ^ b[1] ^ c[1];\n  assign c[2] = (a[1] & b[1]) | (a[1] & c[1]) | (b[1] & c[1]);\n\n  assign sum[2] = a[2] ^ b[2] ^ c[2];\n  assign cout = (a[2] & b[2]) | (a[2] & c[2]) | (b[2] & c[2]);\n\n  assign sum[3] = a[3] ^ b[3] ^ cout;\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "fd23b27a00f7ec5bc27d2908a9600675",
        "dataset_index": 2270
      },
      "top__8610a1f1": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [3:0] a,\n    input [3:0] b,\n    input ctrl,\n    output [3:0] out_adder,\n    output [2:0] out_comparator\n);\n\nwire [3:0] adder_output;\nwire [2:0] comparator_output;\nwire [3:0] mux_output;\n\n// Instantiate adder module\nadder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(adder_output)\n);\n\n// Instantiate comparator module\ncomparator comparator_inst (\n    .a(a),\n    .b(b),\n    .result(comparator_output)\n);\n\n// Instantiate multiplexer module\nmux4to1 mux_inst (\n    .select(ctrl),\n    .i0(adder_output),\n    .i1(comparator_output),\n    .o(mux_output)\n);\n\nassign out_adder = mux_output[3:0];\nassign out_comparator = mux_output[2:0];\n\nendmodule\n\nmodule adder (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output [2:0] result\n);\n    assign result = (a > b) ? 3'b100 : (a == b) ? 3'b010 : 3'b001;\nendmodule\n\nmodule mux4to1 (\n    input select,\n    input [3:0] i0,\n    input [2:0] i1,\n    output [3:0] o\n);\n    assign o = select ? {1'b0, i1} : i0;\nendmodule",
        "module_name": "top_",
        "module_hash": "8610a1f1abb73c0992b840c6e5243326",
        "dataset_index": 4546
      },
      "delay_30_degrees_c5011ac3": {
        "rtl_code": "\n\nmodule delay_30_degrees\n(\n    input               clk_i,\n    input               rst_i,\n    input       [31:0]  offset_i,   input       [2:0]   position_i, output reg  [2:0]   position_o  );\n\nlocalparam MAX_SPEED_COUNT  = 32'h1000000;\nlocalparam RESET            = 6'b000001;\nlocalparam INIT             = 6'b000010;\nlocalparam CHANGE_POSITION  = 6'b000100;\nlocalparam DELAY_30_DEGREES = 6'b001000;\nlocalparam APPLY_CHANGE     = 6'b010000;\nlocalparam IDLE             = 6'b100000;\nreg [5:0]   state         = RESET;  reg [5:0]   next_state    = RESET;  reg [2:0]   position_old  = 3'h0;   reg [31:0]  speed_count   = 32'h0;  reg [31:0]  speed_divider = 32'h0;  reg [31:0]  delay_count   = 32'h0;  always @*\nbegin\n    next_state = state;\n\n    case (state)\n        RESET:\n        begin\n            next_state = INIT;\n        end\n        INIT:\n        begin\n            if (position_i != position_old)\n            begin\n                next_state = CHANGE_POSITION;\n            end\n        end\n        CHANGE_POSITION:\n        begin\n            next_state = DELAY_30_DEGREES;\n        end\n        DELAY_30_DEGREES:\n        begin\n            if( delay_count >  speed_divider)\n            begin\n                next_state          = APPLY_CHANGE;\n            end\n        end\n        APPLY_CHANGE:\n        begin\n            next_state          = IDLE;\n        end\n        IDLE:\n        begin\n            if (position_i != position_old)\n            begin\n                next_state = CHANGE_POSITION;\n            end\n        end\n        default:\n        begin\n            next_state = RESET;\n        end\n    endcase\nend\n\nalways @(posedge clk_i)\nbegin\n    case(state)\n        RESET:\n        begin\n            speed_count     <= 0;\n            speed_divider   <= 0;\n            position_o      <= 3'b1;\n        end\n        INIT:\n        begin\n            if (speed_count < MAX_SPEED_COUNT)\n            begin\n                speed_count <= speed_count + 1;\n            end\n        end\n        CHANGE_POSITION:\n        begin\n            speed_divider   <= speed_count >> 1 ;\n            speed_count     <= 0;\n            delay_count     <= 0;\n        end\n        DELAY_30_DEGREES:\n        begin\n            if (speed_count < MAX_SPEED_COUNT)\n            begin\n                speed_count <= speed_count + 1;\n            end\n            delay_count <= delay_count + 1;\n        end\n        APPLY_CHANGE:\n        begin\n            if (position_i == 3'b101)\n            begin\n                position_o <= 100;\n            end \n            if (position_i == 3'b100)\n            begin\n                position_o <= 110;\n            end \n            if (position_i == 3'b110)\n            begin\n                position_o <= 010;\n            end \n            if (position_i == 3'b010)\n            begin\n                position_o <= 011;\n            end \n            if (position_i == 3'b011)\n            begin\n                position_o <= 001;\n            end \n            if (position_i == 3'b001)\n            begin\n                position_o <= 101;\n            end \n            position_old    <= position_i;\n            if (speed_count < MAX_SPEED_COUNT)\n            begin\n                speed_count <= speed_count + 1;\n            end\n        end\n        IDLE:\n        begin\n            if (speed_count < MAX_SPEED_COUNT)\n            begin\n                speed_count <= speed_count + 1;\n            end\n        end\n    endcase\nend\n\nalways @ (posedge clk_i)\nbegin\n    if(rst_i == 1'b1)\n    begin\n        state <= RESET;\n    end\n    else\n    begin\n        state <= next_state;\n    end\nend\n\nendmodule\n\n",
        "module_name": "delay_30_degrees",
        "module_hash": "c5011ac328cae6b27ab88ecece600dce",
        "dataset_index": 23164
      },
      "pio_latency_0cb0492d": {
        "rtl_code": "module pio_latency (\n                     // inputs:\n                      address,\n                      clk,\n                      in_port,\n                      reset_n,\n\n                     // outputs:\n                      readdata\n                   )\n;\n\n  output  [ 15: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [ 15: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [ 15: 0] data_in;\n  wire    [ 15: 0] read_mux_out;\n  reg     [ 15: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {16 {(address == 0)}} & data_in;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= read_mux_out;\n    end\n\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "pio_latency",
        "module_hash": "0cb0492d4c5603441f1a9387823b5e98",
        "dataset_index": 1269
      },
      "and__1fd8a336": {
        "rtl_code": "module and_module (\n    input A,\n    input B,\n    input CLK,\n    output reg X\n);\n\n    always @(posedge CLK) begin\n        X <= A & B;\n    end\n\nendmodule",
        "module_name": "and_",
        "module_hash": "1fd8a3368a9fe91b8f50b8bda359cc93",
        "dataset_index": 15261
      },
      "mod_pmc_66f88187": {
        "rtl_code": "\n\n\n\n\nmodule mod_pmc(rst, clk, ie, de, iaddr, daddr, drw, din, iout, dout, pmc_int, pmc_cache_miss_I, pmc_cache_miss_D, pmc_cache_access_I, pmc_cache_access_D, pmc_uart_recv, pmc_uart_send);\n        input rst;\n        input clk;\n        input ie,de;\n        input [31:0] iaddr, daddr;\n        input [1:0] drw;\n        input [31:0] din;\n        output [31:0] iout, dout;\n\n\tinput pmc_int, pmc_cache_miss_I, pmc_cache_miss_D, pmc_cache_access_I, pmc_cache_access_D, pmc_uart_recv, pmc_uart_send;\n\n\t\n\treg [31:0] count_int;\n\treg [31:0] count_cache_miss_I;\n\treg [31:0] count_cache_miss_D;\n\treg [31:0] count_cache_access_I;\n\treg [31:0] count_cache_access_D;\n\treg [31:0] count_uart_recv;\n\treg [31:0] count_uart_send;\n\n\tassign iout = 0;\n\tassign dout = \n\t\tdaddr == 32'h00000000 ? count_int :\n\t\tdaddr == 32'h00000004 ? count_cache_miss_I :\n\t\tdaddr == 32'h00000008 ? count_cache_miss_D :\n\t\tdaddr == 32'h0000000c ? count_cache_access_I : \n\t\tdaddr == 32'h00000010 ? count_cache_access_D :\n\t\tdaddr == 32'h00000014 ? count_uart_recv : \n\t\tdaddr == 32'h00000018 ? count_uart_send : 0;\n\n\t\n\talways @(negedge clk) begin\n\t\tif (rst) begin\n\t\t\tcount_int <= 0;\n\t\t\tcount_cache_miss_I <= 0;\n\t\t\tcount_cache_miss_D <= 0;\n\t\t\tcount_cache_access_I <= 0;\n\t\t\tcount_cache_access_D <= 0;\n\t\t\tcount_uart_recv <= 0;\n\t\t\tcount_uart_send <= 0;\n\t\tend else begin\n\t\t\tcount_int <= count_int + pmc_int;\n\t\t\tcount_cache_miss_I <= count_cache_miss_I + pmc_cache_miss_I;\n\t\t\tcount_cache_miss_D <= count_cache_miss_D + pmc_cache_miss_D;\n\t\t\tcount_cache_access_I <= count_cache_access_I + pmc_cache_access_I;\n\t\t\tcount_cache_access_D <= count_cache_access_D + pmc_cache_access_D;\n\t\t\tcount_uart_recv <= count_uart_recv + pmc_uart_recv;\n\t\t\tcount_uart_send <= count_uart_send + pmc_uart_send;\n\t\tend\n\tend\nendmodule\n",
        "module_name": "mod_pmc",
        "module_hash": "66f88187973e8fe3a3fdefd89bf3e97a",
        "dataset_index": 25090
      },
      "ones_counter_c123ead9": {
        "rtl_code": "module ones_counter (\n    input [15:0] data_in,\n    output reg [7:0] ones_out\n);\n\n    integer i;\n    reg [3:0] count;\n\n    always @(*) begin\n        count = 0;\n        for (i = 0; i < 16; i = i + 1) begin\n            if (data_in[i] == 1'b1) begin\n                count = count + 1;\n            end\n        end\n        ones_out = count;\n    end\n\nendmodule",
        "module_name": "ones_counter",
        "module_hash": "c123ead95ce466b92d476354acd58bf2",
        "dataset_index": 20526
      },
      "denise_sprites_shifter_1ffe2c6b": {
        "rtl_code": "module denise_sprites_shifter\n(\n  input   clk,          input clk7_en,\n  input   reset,            input  aen,          input  [1:0] address,         input  [8:0] hpos,        input [15:0] fmode,\n  input shift,\n  input [48-1:0] chip48,\n  input   [15:0] data_in,     output  [1:0] sprdata,      output  reg attach        );\n\nparameter POS  = 2'b00;\nparameter CTL  = 2'b01;\nparameter DATA = 2'b10;\nparameter DATB = 2'b11;\n\nreg    [63:0] datla;    reg    [63:0] datlb;    reg    [63:0] shifta;    reg    [63:0] shiftb;    reg    [8:0] hstart;    reg    armed;        reg    load;        reg    load_del;\n\nreg  [64-1:0] spr_fmode_dat;\n\nalways @ (*) begin\n  case(fmode[3:2])\n    2'b00   : spr_fmode_dat = {data_in, 48'h000000000000};\n    2'b11   : spr_fmode_dat = {data_in, chip48[47:0]};\n    default : spr_fmode_dat = {data_in, chip48[47:32], 32'h00000000};\n  endcase\nend\n\nalways @(posedge clk)\n  if (clk7_en) begin\n    if (reset) armed <= 0;\n    else if (aen && address==CTL) armed <= 0;\n    else if (aen && address==DATA) armed <= 1;\n  end\n\nalways @(posedge clk)\n  if (clk7_en) begin\n    load <= armed && (hpos[7:0] == hstart[7:0]) && (fmode[15] || (hpos[8] == hstart[8])) ? 1'b1 : 1'b0;\n  end\n\nalways @(posedge clk)\n  if (clk7_en) begin\n    load_del <= load;\n  end\n\nalways @(posedge clk)\n  if (clk7_en) begin\n    if (aen && address==POS)\n      hstart[8:1] <= data_in[7:0];\n  end\n\nalways @(posedge clk)\n  if (clk7_en) begin\n    if (aen && address==CTL)\n      {attach,hstart[0]} <= {data_in[7],data_in[0]};\n  end\n\nalways @(posedge clk)\n  if (clk7_en) begin\n    if (aen && address==DATA)\n      datla[63:0] <= spr_fmode_dat;\n  end\n\nalways @(posedge clk)\n  if (clk7_en) begin\n    if (aen && address==DATB)\n      datlb[63:0] <= spr_fmode_dat;\n  end\n\nalways @(posedge clk)\n  if (clk7_en && load_del) begin\n    shifta[63:0] <= datla[63:0];\n    shiftb[63:0] <= datlb[63:0];\n  end\n  else if (shift)\n  begin\n    shifta[63:0] <= {shifta[62:0],1'b0};\n    shiftb[63:0] <= {shiftb[62:0],1'b0};\n  end\n\nassign sprdata[1:0] = {shiftb[63],shifta[63]};\n\nendmodule\n\n",
        "module_name": "denise_sprites_shifter",
        "module_hash": "1ffe2c6b3d54674e86b774727ac7d415",
        "dataset_index": 24046
      },
      "ac97_rst_dad0325e": {
        "rtl_code": "\n\n`include \"ac97_defines.v\"\n\nmodule ac97_rst(clk, rst, rst_force, ps_ce, ac97_rst_);\ninput\t\tclk, rst;\ninput\t\trst_force;\noutput\t\tps_ce;\noutput\t\tac97_rst_;\n\nreg\t\tac97_rst_;\nreg\t[2:0]\tcnt;\nwire\t\tce;\nwire\t\tto;\nreg\t[5:0]\tps_cnt;\nwire\t\tps_ce;\n\nalways @(posedge clk or negedge rst)\n\tif(!rst)\tac97_rst_ <= #1 0;\n\telse\n\tif(rst_force)\tac97_rst_ <= #1 0;\n\telse\n\tif(to)\t\tac97_rst_ <= #1 1;\n\nassign to = (cnt == `AC97_RST_DEL);\n\nalways @(posedge clk or negedge rst)\n\tif(!rst)\tcnt <= #1 0;\n\telse\n\tif(rst_force)\tcnt <= #1 0;\n\telse\n\tif(ce)\t\tcnt <= #1 cnt + 1;\n\nassign ce = ps_ce & (cnt != `AC97_RST_DEL);\n\nalways @(posedge clk or negedge rst)\n\tif(!rst)\t\tps_cnt <= #1 0;\n\telse\n\tif(ps_ce | rst_force)\tps_cnt <= #1 0;\n\telse\t\t\tps_cnt <= #1 ps_cnt + 1;\n\nassign ps_ce = (ps_cnt == `AC97_250_PS);\n\nendmodule\n",
        "module_name": "ac97_rst",
        "module_hash": "dad0325e1e2053e7a74c813c1912a4f8",
        "dataset_index": 205
      },
      "mutex_buffer #_9bb33bf3": {
        "rtl_code": "module mutex_buffer #\n(\n\tparameter integer C_BUFF_NUM = 4\n) (\n\tinput wire clk,\n\tinput wire resetn,\n\n\toutput wire wr_done,\n\n\tinput wire                        w_sof,\n\toutput reg [C_BUFF_NUM-1:0]       w_bmp,\n\n\tinput wire                        r0_sof,\n\toutput reg [C_BUFF_NUM-1:0]       r0_bmp,\n\n\tinput wire                        r1_sof,\n\toutput reg [C_BUFF_NUM-1:0]       r1_bmp\n);\n\n\tassign wr_done = w_sof;\n\n\treg [C_BUFF_NUM-1:0]\tlast_bmp;\n\n\t/// reader 0\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\tr0_bmp  <= 0;\n\t\tend\n\t\telse if (r0_sof) begin\n\t\t\tif (w_sof) begin\n\t\t\t\tr0_bmp  <= w_bmp;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tr0_bmp  <= last_bmp;\n\t\t\tend\n\t\tend\n\tend\n\n\t/// reader 1 (same as reader 0)\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\tr1_bmp  <= 0;\n\t\tend\n\t\telse if (r1_sof) begin\n\t\t\tif (w_sof) begin\n\t\t\t\tr1_bmp  <= w_bmp;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tr1_bmp  <= last_bmp;\n\t\t\tend\n\t\tend\n\tend\n\n\t/// last done (ready for read)\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\tlast_bmp  <= {{C_BUFF_NUM-1{1'b0}}, 1'b1};\n\t\tend\n\t\telse if (w_sof) begin\n\t\t\tlast_bmp  <= w_bmp;\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\tw_bmp  <= {{C_BUFF_NUM-1{1'b0}}, 1'b0};\n\t\tend\n\t\telse if (w_sof) begin\n\t\t\tcasez (w_bmp | r0_bmp | r1_bmp)\n\t\t\t{{C_BUFF_NUM-1{1'b?}}, 1'b0}: begin\n\t\t\t\tw_bmp\t<= {{C_BUFF_NUM-1{1'b0}}, 1'b1};\n\t\t\tend\n\t\t\t{{C_BUFF_NUM-2{1'b?}}, 1'b0, 1'b1}: begin\n\t\t\t\tw_bmp\t<= {{C_BUFF_NUM-1{1'b0}}, 1'b0, 1'b1};\n\t\t\tend\n\t\t\t{{C_BUFF_NUM-3{1'b?}}, 1'b0, 1'b1, 1'b1}: begin\n\t\t\t\tw_bmp\t<= {{C_BUFF_NUM-1{1'b0}}, 1'b0, 1'b0, 1'b1};\n\t\t\tend\n\t\t\t{{C_BUFF_NUM-4{1'b?}}, 1'b0, 1'b1, 1'b1, 1'b1}: begin\n\t\t\t\tw_bmp\t<= {{C_BUFF_NUM-1{1'b0}}, 1'b0, 1'b0, 1'b0, 1'b1};\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tw_bmp  <= {{C_BUFF_NUM-1{1'b0}}, 1'b0};\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule",
        "module_name": "mutex_buffer #",
        "module_hash": "9bb33bf317aeb7c9737433b23264ad41",
        "dataset_index": 14459
      },
      "signed_mult #_c4e9b69d": {
        "rtl_code": "module signed_mult #(\n\tparameter A_WIDTH = 0,\n\tparameter B_WIDTH = 0,\n\tparameter P_WIDTH = 0\n)(\n\tinput signed [A_WIDTH-1:0] A,\n\tinput signed [B_WIDTH-1:0] B,\n\toutput reg signed [P_WIDTH-1:0] P\n);\n\n\talways @(*)\n\tbegin\n\t\tP <= A * B;\n\tend\n\nendmodule",
        "module_name": "signed_mult #",
        "module_hash": "c4e9b69d65976b6741b16caa72c090cf",
        "dataset_index": 15126
      },
      "concat__bf004461": {
        "rtl_code": "module concat_module (\n    input clk,\n    input [89:0] in,\n    output reg [44:0] line0,\n    output reg [44:0] line1,\n    output reg [89:0] out\n);\n\n    always @(posedge clk) begin\n        line0 <= in[44:0];\n        line1 <= in[89:45];\n        out <= {line0, line1};\n    end\n\nendmodule",
        "module_name": "concat_",
        "module_hash": "bf0044610570a0ae8513941f336445bb",
        "dataset_index": 13683
      },
      "arduino_switch_digital_uart_bit_e90b5acf": {
        "rtl_code": "\nmodule arduino_switch_digital_uart_bit(\ninput gpio_sel,  input tri_i_out,   output reg tri_o_out,   output reg tri_t_out,   output tri_i_in,   input tri_o_in,    input tri_t_in,    output rx_i_in,  input tx_o_in,   input tx_t_in    );\n\n    reg [1:0] tri_i_out_demux;\n    assign {rx_i_in, tri_i_in} = tri_i_out_demux;\n\n    always @(gpio_sel, tri_o_in, tx_o_in)\n       case (gpio_sel)\n          1'h0: tri_o_out = tri_o_in;       1'h1: tri_o_out = tx_o_in;        endcase\n\n    always @(gpio_sel, tri_i_out)\n    begin\n       tri_i_out_demux = {2{1'b0}};\n       case (gpio_sel)\n          1'h0: tri_i_out_demux[0] = tri_i_out;     1'h1: tri_i_out_demux[1] = tri_i_out;     endcase\n    end\n\n    always @(gpio_sel, tri_t_in, tx_t_in)\n       case (gpio_sel)\n          1'h0: tri_t_out = tri_t_in;       1'h1: tri_t_out = tx_t_in;        endcase\n    \nendmodule\n",
        "module_name": "arduino_switch_digital_uart_bit",
        "module_hash": "e90b5acf76b67bfef3135c5dc3dfed34",
        "dataset_index": 25100
      },
      "pcie_serdes_7d5ab5be": {
        "rtl_code": "\nmodule pcie_serdes (\n  input ref_clk,\n  input reset,\n  input [31:0] tx_data,\n  input tx_valid,\n  output reg tx_ready,\n  input rx_valid,\n  output reg [31:0] rx_data,\n  output reg rx_error\n);\n\n  // transmit data when valid and ready\n  always @(posedge ref_clk) begin\n    if (reset) begin\n      tx_ready <= 1'b0;\n    end else if (tx_valid && tx_ready) begin\n      tx_ready <= 1'b0;\n    end else if (!tx_valid && !tx_ready) begin\n      tx_ready <= 1'b1;\n    end\n  end\n\n  // receive data when valid\n  always @(posedge ref_clk) begin\n    if (reset) begin\n      rx_data <= 32'b0;\n      rx_error <= 1'b0;\n    end else if (rx_valid) begin\n      rx_data <= {rx_valid, rx_data[30:0]};\n      rx_error <= rx_data[31];\n    end\n  end\n\nendmodule",
        "module_name": "pcie_serdes",
        "module_hash": "7d5ab5be72665d2dadd958d975921be6",
        "dataset_index": 15358
      },
      "my_uart_tx8to8_57401d62": {
        "rtl_code": "\nmodule my_uart_tx8to8(\n\tclk,\n\trst_n,\n\tuart_ctl,\n\tdata_out,\n\tdata_sign,\n\tdata_valid,\n\t\n\trs_tx\n\t\n    );\n\t\n\t\n\tinput\tclk;\n\tinput\trst_n;\n\tinput\t[2:0]\tuart_ctl;\n\tinput\t[7:0]\tdata_out;\n\tinput\tdata_sign;\n\toutput\tdata_valid;\n\t\n\toutput\trs_tx;\n\t\n\t\n\tparameter \tbps9600 \t= 13'd5208,\tbps19200 \t= 13'd2603,\tbps38400 \t= 13'd1301,\tbps57600 \t= 13'd867,\tbps115200\t= 13'd434,\tbps256000\t= 13'd195;\treg\t\t[12:0]\t\tcnt;\n\treg\t\t\t\t\tbps_sel;\n\treg\t\t[3:0]\t\ttran_cnt;\n\t\n\treg\t\t\t\t\trs_tx;\n\t\n\treg\t\t\t\t\tsign_delay;\n\t\n\treg\t\t\t\t\tdata_valid;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tbps_sel <= 1'b0;\n\t\t\tcnt <= 'h0;\t\n\t\tend\n\t\telse begin\t\n\t\t\tcase(uart_ctl)\n\t\t\t\t3'h0:  cnt <= (cnt == bps9600) ? 'h0 : cnt + 1'b1;\n\t\t\t\t3'h1:  cnt <= (cnt == bps19200) ? 'h0 : cnt + 1'b1;\n\t\t\t\t3'h2:  cnt <= (cnt == bps38400) ? 'h0 : cnt + 1'b1;\n\t\t\t\t3'h3:  cnt <= (cnt == bps57600) ? 'h0 : cnt + 1'b1;\n\t\t\t\t3'h4:  cnt <= (cnt == bps115200) ? 'h0 : cnt + 1'b1;\n\t\t\t\t3'h5:  cnt <= (cnt == bps256000) ? 'h0 : cnt + 1'b1;\n\t\t\t\tdefault: cnt <= (cnt == bps9600) ? 'h0 : cnt + 1'b1;\n\t\t\tendcase\n\t\t\tbps_sel <= ~|cnt;\n\t\tend\n\tend\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tsign_delay <= 1'b0;\n\t\t\tdata_valid <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tif(bps_sel)\tsign_delay <= 1'b0;\n\t\t\telse if(data_sign)\tsign_delay <= 1'b1;\n\t\t\tif(data_sign | sign_delay)\tdata_valid <= 1'b0;\n\t\t\telse if(tran_cnt== 9)\t\tdata_valid <= 1'b1;\n\t\t\t\n\t\tend\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\ttran_cnt <= 'h9;\n\t\tend\n\t\telse if (bps_sel)begin\t\n\t\t\tif(tran_cnt != 9)\ttran_cnt <= tran_cnt + 1'b1;\n\t\t\telse if (data_sign|sign_delay)\ttran_cnt <= 'h0;\n\t\t\t\n\t\tend\n\tend\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\trs_tx <= 1'b1;\n\t\tend\n\t\telse if (bps_sel) begin\t\n\t\t\tif(tran_cnt == 0)\t\trs_tx <= 1'b0 ;\n\t\t\telse if(tran_cnt == 9)\trs_tx <= 1'b1;\n\t\t\telse\t\t\t\t\trs_tx <= data_out[tran_cnt - 1];\n\t\t\t\t\n\t\tend\n\tend\n\n\nendmodule\n",
        "module_name": "my_uart_tx8to8",
        "module_hash": "57401d62993abfb9d07984408e078fe4",
        "dataset_index": 7778
      },
      "binary_counter_e132903d": {
        "rtl_code": "\nmodule binary_counter (\n  input clk,\n  input rst,\n  input ctrl,\n  input load,\n  input [n-1:0] val,\n  output [n-1:0] out\n);\n\nparameter n = 4; // number of output signals\nparameter mod = 0; // modulo value (optional)\n\nreg [n-1:0] count;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    count <= 0;\n  end else if (load) begin\n    count <= val;\n  end else if (ctrl) begin\n    count <= count + 1;\n  end else if (!ctrl) begin\n    count <= count - 1;\n  end\n  \n  if (mod != 0 && count == mod) begin\n    count <= 0;\n  end\nend\n\nassign out = count;\n\nendmodule\n",
        "module_name": "binary_counter",
        "module_hash": "e132903d242f8e9bdc2a4cbc8707d201",
        "dataset_index": 15599
      },
      "clock_multiplexer_2a0c5f61": {
        "rtl_code": "module clock_multiplexer (\n  input [3:0] clk,\n  input [1:0] control,\n  output reg clk_out\n);\n\nparameter n = 4; // number of input clock signals\n\nalways @ (posedge clk[control])\n  clk_out <= clk[control];\n\nendmodule",
        "module_name": "clock_multiplexer",
        "module_hash": "2a0c5f61e648288816e077eac9c8bea2",
        "dataset_index": 1388
      },
      "tone_lut32_e8715fa3": {
        "rtl_code": "module tone_lut32 (input [5:0] tone, output [15:0] thirty_second_period);\n\t\n\tparameter\n\t\t\t\tC3  = 16'd23890,\n\t\t\t\tC3S = 16'd22549,\n\t\t\t\tD3  = 16'd21283,\n\t\t\t\tD3S = 16'd20089,\n\t\t\t\tE3  = 16'd18961,\n\t\t\t\tF3  = 16'd17897,\n\t\t\t\tF3S = 16'd16892,\n\t\t\t\tG3  = 16'd15944,\n\t\t\t\tG3S = 16'd15050,\n\t\t\t\tA3  = 16'd14205,\n\t\t\t\tA3S = 16'd13408,\n\t\t\t\tB3  = 16'd12655,\n\t\t\t\t\n\t\t\t\tC4  = 16'd11945,\n\t\t\t\tC4S = 16'd11275,\n\t\t\t\tD4  = 16'd10642,\n\t\t\t\tD4S = 16'd10044,\n\t\t\t\tE4  = 16'd9481,\n\t\t\t\tF4  = 16'd8949,\n\t\t\t\tF4S = 16'd8446,\n\t\t\t\tG4  = 16'd7972,\n\t\t\t\tG4S = 16'd7525,\n\t\t\t\tA4  = 16'd7103,\n\t\t\t\tA4S = 16'd6704,\n\t\t\t\tB4  = 16'd6328,\n\t\t\t\t\n\t\t\t\tC5  = 16'd5973,\n\t\t\t\tC5S = 16'd5637,\n\t\t\t\tD5  = 16'd5321,\n\t\t\t\tD5S = 16'd5022,\n\t\t\t\tE5  = 16'd4740,\n\t\t\t\tF5  = 16'd4474,\n\t\t\t\tF5S = 16'd4223,\n\t\t\t\tG5  = 16'd3986,\n\t\t\t\tG5S = 16'd3763,\n\t\t\t\tA5  = 16'd3551,\n\t\t\t\tA5S = 16'd3352,\n\t\t\t\tB5  = 16'd3164,\n\t\t\t\t\n\t\t\t\tC6  = 16'd2986,\n\t\t\t\tC6S = 16'd2819,\n\t\t\t\tD6  = 16'd2661,\n\t\t\t\tD6S = 16'd2511,\n\t\t\t\tE6  = 16'd2370,\n\t\t\t\tF6  = 16'd2237,\n\t\t\t\tF6S = 16'd2112,\n\t\t\t\tG6  = 16'd1993,\n\t\t\t\tG6S = 16'd1881,\n\t\t\t\tA6  = 16'd1776,\n\t\t\t\tA6S = 16'd1676,\n\t\t\t\tB6  = 16'd1582;\n\t\t\t\t\n\tassign thirty_second_period =\n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t   (tone == 6'd1)  ? C3  :\n\t\t\t\t\t\t\t\t\t   (tone == 6'd2)  ? C3S :\n\t\t\t\t\t\t\t\t\t   (tone == 6'd3)  ? D3  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd4)  ? D3S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd5)  ? E3  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd6)  ? F3  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd7)  ? F3S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd8)  ? G3  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd9)  ? G3S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd10)  ? A3  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd11) ? A3S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd12) ? B3  :\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd13) ? C4  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd14) ? C4S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd15) ? D4  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd16) ? D4S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd17) ? E4  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd18) ? F4  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd19) ? F4S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd20) ? G4  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd21) ? G4S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd22) ? A4  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd23) ? A4S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd24) ? B4  :\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd25) ? C5  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd26) ? C5S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd27) ? D5  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd28) ? D5S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd29) ? E5  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd30) ? F5  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd31) ? F5S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd32) ? G5  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd33) ? G5S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd34) ? A5  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd35) ? A5S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd36) ? B5  :\n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t(tone == 6'd37) ? C6  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd38) ? C6S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd39) ? D6  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd40) ? D6S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd41) ? E6  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd42) ? F6  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd43) ? F6S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd44) ? G6  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd45) ? G6S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd46) ? A6  :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd47) ? A6S :\n\t\t\t\t\t\t\t\t\t\t(tone == 6'd48) ? B6  :\n\t\t\t\t\t\t\t\t\t\t  0 ;\n\nendmodule\n",
        "module_name": "tone_lut32",
        "module_hash": "e8715fa329b93a498e0837e24c4e4cc3",
        "dataset_index": 23851
      },
      "top__26546e8d": {
        "rtl_code": "module top_module (\n    input clk,\n    input slowena,\n    input reset,\n    input select,\n    input a,\n    input b,\n    output reg out\n);\n\nreg [3:0] count;\nwire xor_out;\n\n// Decade counter\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else if (slowena) begin\n        count <= count;\n    end else begin\n        count <= count + 1;\n    end\nend\n\n// XOR gate\nassign xor_out = a ^ b;\n\n// Control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 1'b0;\n    end else begin\n        if (select) begin\n            out <= xor_out;\n        end else begin\n            out <= count[3];\n        end\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "26546e8d17d5ad81d3a17f9fbc94c5f0",
        "dataset_index": 13623
      },
      "sky130_fd_sc_lp__invkapwr_44918a08": {
        "rtl_code": "\nmodule sky130_fd_sc_lp__invkapwr (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    // Voltage supply signals\n    supply1 VPWR ;\n    supply0 VGND ;\n    supply1 KAPWR;\n    supply1 VPB  ;\n    supply0 VNB  ;\n\n    // Inverter circuit\n    assign Y = ~A;\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__invkapwr",
        "module_hash": "44918a082d2729b3235f91cdca26ce09",
        "dataset_index": 8933
      },
      "binary_counter_afc17ce2": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if(rst) begin\n      count <= 4'b0000;\n    end else begin\n      if(count == 4'b1111) begin\n        count <= 4'b0000;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "afc17ce2f5db0779a5b0521b19e3592a",
        "dataset_index": 19704
      },
      "signal_modifier_b00fa5cf": {
        "rtl_code": "module signal_modifier(\n    input [15:0] in,\n    input [1:0] ctrl,\n    output [15:0] out\n);\n\nreg [15:0] temp;\n\nalways @*\nbegin\n    case (ctrl)\n        2'b00: temp = in;\n        2'b01: temp = ~in;\n        2'b10: temp = {in[13:0], 2'b00};\n        2'b11: temp = {2'b00, in[15:2]};\n    endcase\nend\n\nassign out = temp;\n\nendmodule",
        "module_name": "signal_modifier",
        "module_hash": "b00fa5cf44717b63ac86b59c70c1861a",
        "dataset_index": 20505
      },
      "pipelined_full_adder_6fcc5605": {
        "rtl_code": "module pipelined_full_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    output [3:0] sum,\n    output cout\n);\n\nreg [3:0] p1, p2, p3, g1, g2, g3;\nreg [4:0] c1, c2, c3;\n\nassign sum = p3;\nassign cout = c3[4];\n\nalways @(*) begin\n    p1 = a ^ b;\n    g1 = a & b;\n    c1 = {1'b0, g1} + c;\n\n    p2 = p1 ^ c1[3:0];\n    g2 = p1 & c1[3:0];\n    c2 = {1'b0, g2} + c1[4];\n\n    p3 = p2 ^ c2[3:0];\n    g3 = p2 & c2[3:0];\n    c3 = {1'b0, g3} + c2[4];\nend\n\nendmodule",
        "module_name": "pipelined_full_adder",
        "module_hash": "6fcc5605850d2bd894757b19d880766a",
        "dataset_index": 12487
      },
      "and4b_198a5f70": {
        "rtl_code": "module and4b (\n    input  A_N ,\n    input  B   ,\n    input  C   ,\n    input  D   ,\n    output X   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n    wire AB, CD, ABCD;\n    \n    // AND gates for AB and CD\n    and gate_AB(AB, A_N, B);\n    and gate_CD(CD, C, D);\n    \n    // AND gate for ABCD\n    and gate_ABCD(ABCD, AB, CD);\n    \n    // Inverter for X\n    not inv_X(X, ABCD);\n    \nendmodule",
        "module_name": "and4b",
        "module_hash": "198a5f70cf948799dee1e2903da9a65d",
        "dataset_index": 6346
      },
      "nor4b_with_inverting_input_de089313": {
        "rtl_code": "\nmodule nor4b_with_inverting_input (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D_N \n);\n\n    // Module ports\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D_N ;\n\n\n    // Local signals\n    wire not0_out         ;\n    wire nor0_out_Y       ;\n\n    //                                 Name         Output             Other arguments\n    not                                not0        (not0_out         , D_N                   );\n    nor                                nor0        (nor0_out_Y       , A, B, C, not0_out     );\n    buf                                buf0        (Y                , nor0_out_Y     );\n\nendmodule",
        "module_name": "nor4b_with_inverting_input",
        "module_hash": "de08931316bf32960c70e07ccf87ff0e",
        "dataset_index": 10683
      },
      "cf_ss_422to444_d2b9c9a9": {
        "rtl_code": "module cf_ss_422to444 (\n\n  clk,\n  s422_vs,\n  s422_hs,\n  s422_de,\n  s422_data,\n\n  s444_vs,\n  s444_hs,\n  s444_de,\n  s444_data,\n\n  Cr_Cb_sel_init);\n\n  input           clk;\n  input           s422_vs;\n  input           s422_hs;\n  input           s422_de;\n  input   [15:0]  s422_data;\n\n  output          s444_vs;\n  output          s444_hs;\n  output          s444_de;\n  output  [23:0]  s444_data;\n\n  input           Cr_Cb_sel_init;\n\n  reg             Cr_Cb_sel = 'd0;\n  reg             s422_vs_d = 'd0;\n  reg             s422_hs_d = 'd0;\n  reg             s422_de_d = 'd0;\n  reg     [23:0]  s422_data_d = 'd0;\n  reg             s422_vs_2d = 'd0;\n  reg             s422_hs_2d = 'd0;\n  reg             s422_de_2d = 'd0;\n  reg     [23:0]  s422_data_2d = 'd0;\n  reg             s422_vs_3d = 'd0;\n  reg             s422_hs_3d = 'd0;\n  reg             s422_de_3d = 'd0;\n  reg     [23:0]  s422_data_3d = 'd0;\n  reg     [ 7:0]  R = 'd0;\n  reg     [ 7:0]  B = 'd0;\n  reg             s444_vs = 'd0;\n  reg             s444_hs = 'd0;\n  reg             s444_de = 'd0;\n  reg     [23:0]  s444_data = 'd0;\n\n  wire    [ 9:0]  R_s;\n  wire    [ 9:0]  B_s;\n\n  always @(posedge clk) begin\n    if (s422_de == 1'b1) begin\n      Cr_Cb_sel <= ~Cr_Cb_sel;\n    end else begin\n      Cr_Cb_sel <= Cr_Cb_sel_init;\n    end\n    s422_vs_d <= s422_vs;\n    s422_hs_d <= s422_hs;\n    s422_de_d <= s422_de;\n    if (s422_de == 1'b1) begin\n      if (Cr_Cb_sel == 1'b1) begin\n        s422_data_d <= {s422_data[15:8], s422_data[7:0], s422_data_d[7:0]};\n      end else begin\n        s422_data_d <= {s422_data_d[23:16], s422_data[7:0], s422_data[15:8]};\n      end\n    end\n    s422_vs_2d <= s422_vs_d;\n    s422_hs_2d <= s422_hs_d;\n    s422_de_2d <= s422_de_d;\n    if (s422_de_d == 1'b1) begin\n      s422_data_2d <= s422_data_d;\n    end\n    s422_vs_3d <= s422_vs_2d;\n    s422_hs_3d <= s422_hs_2d;\n    s422_de_3d <= s422_de_2d;\n    if (s422_de_2d == 1'b1) begin\n      s422_data_3d <= s422_data_2d;\n    end\n  end\n\n  assign R_s = {2'd0, s422_data_d[23:16]} + {2'd0, s422_data_3d[23:16]} +\n    {1'd0, s422_data_2d[23:16], 1'd0};\n\n  assign B_s = {2'd0, s422_data_d[7:0]} + {2'd0, s422_data_3d[7:0]} +\n    {1'd0, s422_data_2d[7:0], 1'd0};\n\n  always @(posedge clk) begin\n    R <= R_s[9:2];\n    B <= B_s[9:2];\n  end\n\n  always @(posedge clk) begin\n    s444_vs <= s422_vs_3d;\n    s444_hs <= s422_hs_3d;\n    s444_de <= s422_de_3d;\n    if (s422_de_3d == 1'b0) begin\n      s444_data <= 'd0;\n    end else begin\n      s444_data <= {R, s422_data_3d[15:8], B};\n    end\n  end\n\nendmodule\n\n",
        "module_name": "cf_ss_422to444",
        "module_hash": "d2b9c9a97beaf4999cf28868359c36f8",
        "dataset_index": 21701
      },
      "emon_counter_d846084d": {
        "rtl_code": "\n\n\nmodule emon_counter (\n   emon_reg, emon_zero_flag,\n   clk, reset, emon_vector, emon_sel, reg_write, reg_data\n   );\n\n   \n   \n   \n   parameter RFAW = 6;   \n   parameter DW   = 32;   \n      \n   \n   \n   \n   input             clk;\n   input             reset;\n   \n   \n   \n   input [15:0]      emon_vector; input [3:0]       emon_sel;    \n   \n   \n   input\t     reg_write;\n   input  [DW-1:0]   reg_data;\n       \n   \n   \n    \n   output [DW-1:0]   emon_reg;      output            emon_zero_flag;\n   \n       \n   reg [DW-1:0]      emon_reg;\n   reg \t\t     emon_input; \n     \n   \n   \n   \n   always @(posedge clk)\n     emon_input <= emon_vector[emon_sel[3:0]];\n\n   \n   \n   \n   always @(posedge clk)\n     if(reset)\n       emon_reg[DW-1:0]   <= {(DW){1'b1}};    else if(reg_write) \n       emon_reg[DW-1:0]   <= reg_data[DW-1:0];else\n       emon_reg[DW-1:0]   <= emon_reg[DW-1:0] - {31'b0,emon_input};\n      \n   \n   \n   \n\n   assign emon_zero_flag   = ~(|emon_reg[DW-1:0]);\n\n      \nendmodule ",
        "module_name": "emon_counter",
        "module_hash": "d846084d809a5be31ea4776debcc5212",
        "dataset_index": 11749
      },
      "spi_3a0482c3": {
        "rtl_code": "module spi\n\t#(parameter N=8,\n\tparameter tope=500)\t\n\t( \n\tinput [N-1:0] datain,\n\tinput en,\n\tinput reset,\n\tinput clk,\n\tinput miso,\n\toutput reg [N-1:0] dataout,\n\toutput reg done,\n\toutput reg mosi,\n\toutput reg ss,\n\toutput reg sclk\n\t);\n\n\ninteger countd=0;\ninteger div=0;\nreg [N-1:0] datase=0;\nreg [N-1:0] datare=0;\nreg run=0;\n\nalways @(posedge clk)\nbegin\n\n\tif(reset)\n\t\tbegin\n\t\tcountd<=0;\n\t\tsclk<=0;\n\t\trun<=0;\n\t\tdiv<=0;\n\t\tss<=1;\n\t\tdone<=0;\n\t\tdataout<=0;\n\t\tdatase<=0;\n\t\tdatare<=0;\n\t\tend\n\n\t\n\telse if(en)\n\t\tbegin\n\t\trun<=1;\n\t\tss<=0;\n\t\tif(done)\n\t\t\tbegin\n\t\t\trun<=0;\n\t\t\tdataout<=datare;\n\t\tend\n\t\telse if(run)\n\t\t\tif(div==tope)\n\t\t\t\tbegin\n\t\t\t\tsclk<=~sclk;\n\t\t\t\tdiv<=0;\n\t\t\t\t\tif(sclk)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\tcountd<=countd+1;\n\t\t\t\t\t\tmosi<=datase[N-1];\n\t\t\t\t\t\tif(countd==7)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tcountd<=0;\n\t\t\t\t\t\t\tdone<=1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\telse if(~sclk)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\tdatare<={miso,datare[N-1:1]};\n\t\t\t\t\t\tdatase<={datase[N-2:0],1'b1};\n\t\t\t\t\t\tend\n\t\t\t\tend\t\t\n\n\t\t\telse\n\t\t\t\tdiv<=div+1;\n\t\tend\n\telse if(~en)\n\t\tbegin\n\t\tcountd<=0;\n\t\tsclk<=0;\n\t\trun<=0;\n\t\tdiv<=0;\n\t\tss<=1;\n\t\tdone<=0;\n\t\tdatase<=datain;\n\t\tmosi<=datase[N-1];\n\t\tend\n\n\t\t\n\t\t\nend\n\n\n\n\n\nendmodule\n",
        "module_name": "spi",
        "module_hash": "3a0482c3dce11d62b53f53e213db8c30",
        "dataset_index": 23792
      },
      "full_adder_410ecd46": {
        "rtl_code": "\nmodule full_adder(\n    input a,\n    input b,\n    input carry_in,\n    output sum,\n    output carry_out\n);\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (a & carry_in) | (b & carry_in);\n\nendmodule\nmodule four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum,\n    output carry_out\n);\n\n    wire [3:0] fa_sum;\n    wire [3:0] fa_carry_out;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .carry_in(1'b0),\n        .sum(fa_sum[0]),\n        .carry_out(fa_carry_out[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .carry_in(fa_carry_out[0]),\n        .sum(fa_sum[1]),\n        .carry_out(fa_carry_out[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .carry_in(fa_carry_out[1]),\n        .sum(fa_sum[2]),\n        .carry_out(fa_carry_out[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .carry_in(fa_carry_out[2]),\n        .sum(fa_sum[3]),\n        .carry_out(carry_out)\n    );\n\n    assign sum = fa_sum;\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "410ecd463b3a1863faec63e826e94696",
        "dataset_index": 20718
      },
      "OV7670Init_55519ca9": {
        "rtl_code": "\n\nmodule OV7670Init (index_i, data_o);\n\n   input       [5:0] index_i;    output reg  [16:0] data_o;    always @* begin\n       case(index_i)\n         6'd0 : data_o = {16'h1280, 1'b1};   6'd1 : data_o = {16'hf0f0, 1'b1};   6'd2 : data_o = {16'h1180, 1'b1};   6'd3 : data_o = {16'h1205, 1'b1};    \n        default: data_o = {16'hffff, 1'b1};\n      endcase\n   end\n\nendmodule\n",
        "module_name": "OV7670Init",
        "module_hash": "55519ca9300d3ddf9bdbf2f5dd2c096b",
        "dataset_index": 24593
      },
      "ALU_79d2031b": {
        "rtl_code": "\nmodule ALU(input [10:0] OP,\n           input [7:0] A,\n           input [7:0] B,\n           input CI,\n           output reg CO,\n           output reg VO,\n           output reg SO,\n           output reg ZO,\n           output reg [7:0] Result,\n           output reg [7:0] IntR);\n\n  // Declare intermediate wires\n  wire [7:0] add_out, sub_out, and_out, or_out, xor_out, inc_out, dec_out, sl_out, sr_out, rl_out, rr_out, slt_out;\n  wire [7:0] add_in_b, sub_in_b, sl_in_b, sr_in_b, rl_in_b, rr_in_b;\n  wire add_cout, sub_cout, sl_cout, sr_cout;\n  \n  // Define intermediate logic\n  assign add_in_b = B;\n  assign sub_in_b = ~B + 1;\n  assign sl_in_b = B << 1;\n  assign sr_in_b = B >> 1;\n  assign rl_in_b = {B[6:0], B[7]};\n  assign rr_in_b = {B[0], B[7:1]};\n  \n  MyAdder adder(.A(A), .B(add_in_b), .CI(CI), .S(add_out), .CO(add_cout));\n  MyAdder adder_sub(.A(A), .B(sub_in_b), .CI(CI), .S(sub_out), .CO(sub_cout));\n  assign and_out = A & B;\n  assign or_out = A | B;\n  assign xor_out = A ^ B;\n  assign inc_out = A + 1;\n  assign dec_out = A - 1;\n  assign sl_out = sl_in_b;\n  MyAdder shifter_r(.A(A), .B(sr_in_b), .CI(sr_in_b[0]), .S(sr_out), .CO(sr_cout));\n  assign rl_out = rl_in_b;\n  assign rr_out = rr_in_b;\n  assign slt_out = (A < B) ? 1 : 0;\n  \n  // Select output based on OP\n  always @(*) begin\n    case (OP)\n      11'b00_00_00_000: begin // ADD\n        IntR = add_out;\n        Result = add_out;\n        CO = add_cout;\n        VO = (A[7] == B[7] && A[7] != Result[7]) ? 1 : 0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_00_001: begin // SUB\n        IntR = sub_out;\n        Result = sub_out;\n        CO = sub_cout;\n        VO = (A[7] != B[7] && A[7] != Result[7]) ? 1 : 0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_00_010: begin // AND\n        IntR = and_out;\n        Result = and_out;\n        CO = 1'b0;\n        VO = 1'b0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_00_011: begin // OR\n        IntR = or_out;\n        Result = or_out;\n        CO = 1'b0;\n        VO = 1'b0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_00_100: begin // XOR\n        IntR = xor_out;\n        Result = xor_out;\n        CO = 1'b0;\n        VO = 1'b0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_00_101: begin // INC\n        IntR = inc_out;\n        Result = inc_out;\n        CO = (A == 8'hFF) ? 1 : 0;\n        VO = (A[7] == 1 && Result[7] == 0) ? 1 : 0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_00_110: begin // DEC\n        IntR = dec_out;\n        Result = dec_out;\n        CO = (A == 8'h00) ? 1 : 0;\n        VO = (A[7] == 0 && Result[7] == 1) ? 1 : 0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_00_111: begin // SHL\n        IntR = sl_out;\n        Result = sl_out;\n        CO = A[7];\n        VO = (A[7] != Result[7]) ? 1 : 0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_01_000: begin // SHR\n        IntR = sr_out;\n        Result = sr_out;\n        CO = A[0];\n        VO = 1'b0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_01_001: begin // ROL\n        IntR = rl_out;\n        Result = rl_out;\n        CO = A[7];\n        VO = (A[7] != Result[7]) ? 1 : 0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_01_010: begin // ROR\n        IntR = rr_out;\n        Result = rr_out;\n        CO = A[0];\n        VO = (A[0] != Result[0]) ? 1 : 0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      11'b00_00_01_011: begin // SLT\n        IntR = slt_out;\n        Result = slt_out;\n        CO = 1'b0;\n        VO = 1'b0;\n        SO = Result[7];\n        ZO = (Result == 0) ? 1 : 0;\n      end\n      default: begin // Invalid OP\n        IntR = 8'h00;\n        Result = 8'h00;\n        CO = 1'b0;\n        VO = 1'b0;\n        SO = 1'b0;\n        ZO = 1'b0;\n      end\n    endcase\n  end\nendmodule\nmodule MyAdder(input [7:0] A, B, input CI, output [7:0] S, output CO);\n  wire [8:0] sum;\n  assign sum = A + B + CI;\n  assign S = sum[7:0]; // Truncate to 8 bits\n  assign CO = sum[8];\nendmodule",
        "module_name": "ALU",
        "module_hash": "79d2031ba48d77d0db05c025d8d68694",
        "dataset_index": 5978
      },
      "add_sub_pipeline_c0feed9c": {
        "rtl_code": "\nmodule add_sub_pipeline(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    input clk,\n    output [31:0] sum\n);\n\nreg [31:0] a_reg, b_reg;\nwire [31:0] sum_reg;\nwire [31:0] carry_in, carry_out;\nwire [31:0] a_xor_b;\n\nassign a_xor_b = (sub == 1'b1) ? ~b : b;\n\nassign carry_in = sub;\n\nadder_pipeline adder_pipeline_inst(\n    .a(a_reg),\n    .b(a_xor_b),\n    .carry_in(carry_in),\n    .sum(sum_reg),\n    .carry_out(carry_out)\n);\n\nassign sum = sum_reg;\n\nalways @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\nend\n\nendmodule\n\nmodule adder_pipeline(\n    input [31:0] a,\n    input [31:0] b,\n    input [31:0] carry_in,\n    output [31:0] sum,\n    output [31:0] carry_out\n);\n\ngenvar i;\nwire [31:0] p, g;\n\ngenerate\n    for (i = 0; i < 32; i = i + 1) begin : gen_loop1\n        assign p[i] = a[i] ^ b[i];\n        assign g[i] = a[i] & b[i];\n    end\nendgenerate\n\nassign sum[0] = p[0] ^ carry_in;\nassign carry_out[0] = g[0] | (p[0] & carry_in);\n\ngenerate\n    for (i = 1; i < 32; i = i + 1) begin : gen_loop2\n        assign sum[i] = p[i] ^ carry_out[i-1];\n        assign carry_out[i] = g[i] | (p[i] & carry_out[i-1]);\n    end\nendgenerate\n\nendmodule\n",
        "module_name": "add_sub_pipeline",
        "module_hash": "c0feed9cde0cf42dd08cb4b717815fa1",
        "dataset_index": 20068
      },
      "four_bit_adder_8d0f08e0": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S\n);\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B + Cin;\n\n    assign S = temp_sum[3:0];\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "8d0f08e0170f9b6809826da11bb8444f",
        "dataset_index": 1494
      },
      "led_controller_552afae2": {
        "rtl_code": "module led_controller(\n    input CLOCK,\n    input RESET,\n    input [2:0] MODE,\n    input FAST,\n    output [7:0] LED\n);\n\nreg [7:0] brightness;\nreg [6:0] counter;\n\nalways @(posedge CLOCK) begin\n    if (RESET) begin\n        brightness <= 0;\n        counter <= 0;\n    end else begin\n        if (FAST) begin\n            if (counter == 9) begin\n                counter <= 0;\n                case (MODE)\n                    3'b000: brightness <= 0;\n                    3'b001: brightness <= 4'b1000;\n                    3'b010: brightness <= 4'b1100;\n                    3'b011: brightness <= 4'b1111;\n                    default: brightness <= 0;\n                endcase\n            end else begin\n                counter <= counter + 1;\n            end\n        end else begin\n            if (counter == 99) begin\n                counter <= 0;\n                case (MODE)\n                    3'b000: brightness <= 0;\n                    3'b001: brightness <= 4'b1000;\n                    3'b010: brightness <= 4'b1100;\n                    3'b011: brightness <= 4'b1111;\n                    default: brightness <= 0;\n                endcase\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nend\n\nassign LED = brightness; // Corrected the buffer statement to an assignment\n\nendmodule",
        "module_name": "led_controller",
        "module_hash": "552afae209e8db8451b3a54aa6e48c35",
        "dataset_index": 2606
      },
      "data_store_01d269c5": {
        "rtl_code": "module data_store(\n  input [15:0] data_in,\n  input enable,\n  input clk,\n  output reg [15:0] data_out\n);\n\nalways @(posedge clk) begin\n  if (enable) begin\n    data_out <= data_in;\n  end\nend\n\nendmodule",
        "module_name": "data_store",
        "module_hash": "01d269c50416893e60aff1c344b82802",
        "dataset_index": 11644
      },
      "comparator_d9a41b1a": {
        "rtl_code": "module comparator (\n    input [1:0] A,\n    input [1:0] B,\n    output reg [1:0] out\n);\n\n    always @(*) begin\n        if (A > B) begin\n            out = 2'b01;\n        end else if (A < B) begin\n            out = 2'b10;\n        end else begin\n            out = 2'b11;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "d9a41b1a35eb949d35d1df29db9f4171",
        "dataset_index": 20013
      },
      "UART_tx_1982b427": {
        "rtl_code": "\nmodule UART_tx (\n\tinput clock,\t\t\tinput reset,\n\tinput s_tick,\t\t\tinput tx_start,\t\tinput [7:0] data_in,\toutput reg tx,\t\t\toutput reg tx_done\t);\n\tlocalparam [1:0]\tIDLE = 0,\n\t\t\t\t\t\t\tSTART = 1,\n\t\t\t\t\t\t\tSEND = 2,\n\t\t\t\t\t\t\tSTOP = 3;\n\t\t\t\t\t\t\n\tlocalparam\t\t\tB_start=1'b0,\n\t\t\t\t\t\t\tB_stop= 1'b1;\n\t\t\t\t\t\t\n\treg [1:0] current_state, next_state;\n\treg [2:0] B_sent;\n\treg [7:0] d_in; \t\talways @(posedge clock, posedge reset)\n\tbegin\n\t\tif(reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\tend\n\t\telse \n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t\n\talways @(posedge clock) begin\n\t\tcase(current_state)\n\t\t\tIDLE: begin\t\t\n\t\t\t\ttx_done = 0;\n\t\t\t\ttx= 1;\n\t\t\t\tif(~tx_start) begin next_state = START;\n\t\t\t\tend \n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\td_in = data_in; \n\t\t\t\tB_sent = 0;\n\t\t\t\tif(s_tick) begin\n\t\t\t\t\ttx = B_start;\n\t\t\t\t\tnext_state = SEND;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSEND: begin\n\t\t\t\tif(s_tick) begin\n\t\t\t\t\ttx = d_in[B_sent];\n\t\t\t\t\tif(B_sent == 7) begin\n\t\t\t\t\t\tnext_state = STOP;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tB_sent = B_sent + 3'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tif(s_tick) begin\n\t\t\t\t\ttx = B_stop;\n\t\t\t\t\ttx_done = 1;\n\t\t\t\t\tnext_state=IDLE;\n\t\t\t\tend\n\t\t\t\telse if (tx_done==1) begin\n\t\t\t\t\ttx_done=0;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\nendmodule\n",
        "module_name": "UART_tx",
        "module_hash": "1982b42725b8a5aac3f29b3757215b7b",
        "dataset_index": 19516
      },
      "uart_transmitter_d3db512f": {
        "rtl_code": "module uart_transmitter\n(\n\tinput wire        clk,\n\tinput wire        rst,\n\tinput wire [7:0]  data,\n\toutput reg        nextch,\n\toutput reg        txd\n);\n\tparameter CLK  = 50_000_000;\n\tparameter BAUD = 9600;\n\n\tlocalparam RATE = CLK/BAUD;\n\t\n\tlocalparam INIT = 0;\n\tlocalparam TXD  = 1;\n\t\n\treg        state, next;\n\treg [31:0] cnt;\n\treg [4:0]  bitcnt;\n\treg [9:0]  rshift;\n\treg        shift, load, clear, getch, gotch;\n\t\n\talways @ (posedge clk or negedge rst) begin\n\t\tif (!rst) begin\n\t\t\tstate <= INIT;\n\t\t\tcnt <= 0;\n\t\t\tbitcnt <= 0;\n\t\t\tgotch <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (nextch) begin\n\t\t\t\tnextch <= 0;\n\t\t\t\tgotch <= 1;\n\t\t\tend\n\t\t\telse if (getch && !gotch)\n\t\t\t\tnextch <= 1;\n\n\t\t\tcnt <= cnt + 1;\n\t\t\tif (cnt >= RATE) begin\n\t\t\t\tstate <= next;\n\t\t\t\tcnt <= 0;\n\t\t\t\tif (load)\n\t\t\t\t\trshift <= {1'b1, data[7:0], 1'b0};\n\t\t\t\tif (clear) begin\n\t\t\t\t\tbitcnt <= 0;\n\t\t\t\t\tgotch <= 0;\n\t\t\t\tend\n\t\t\t\tif (shift) begin\n\t\t\t\t\trshift <= rshift >> 1;\n\t\t\t\t\tbitcnt <= bitcnt + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\talways @ (state or bitcnt or rshift) begin\n\t\tload <= 0;\n\t\tshift <= 0;\n\t\tclear <= 0;\n\t\tgetch <= 0;\n\t\ttxd <= 1;\n\n\t\tcase (state)\n\t\t\tINIT: begin\n\t\t\t\tnext <= TXD;\n\t\t\t\tload <= 1;\n\t\t\t\tshift <= 0;\n\t\t\t\tclear <= 0;\n\t\t\tend\n\t\t\t\n\t\t\tTXD: begin\n\t\t\t\tif (bitcnt >= 9) begin\n\t\t\t\t\tnext <= INIT;\n\t\t\t\t\tclear <= 1;\n\t\t\t\t\tgetch <= 1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext <= TXD;\n\t\t\t\t\tshift <= 1;\n\t\t\t\t\ttxd <= rshift[0];\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\tendcase\n\tend\nendmodule\n",
        "module_name": "uart_transmitter",
        "module_hash": "d3db512fbc015ecfe3ef0770a3abc67b",
        "dataset_index": 4777
      },
      "spi_slave #_6ec04c9f": {
        "rtl_code": "module spi_slave #(parameter msg_len = 8) (CLK, SCK, MOSI, MISO, SSEL, MSG);\n\ninput wire CLK; //master project clock (50 mhz)\n\ninput wire SCK, SSEL, MOSI;\noutput wire MISO;\noutput wire [(msg_len-1):0] MSG;\n\nassign MISO = 0;\n\n// sync SCK to the FPGA clock using a 3-bits shift register\nreg [2:0] SCKr; initial SCKr <= 3'd0;\nalways @(posedge CLK) SCKr <= {SCKr[1:0], SCK};\nwire SCK_risingedge = (SCKr[2:1]==2'b01);  // now we can detect SCK rising edges\n\n// same thing for SSEL\nreg [2:0] SSELr; initial SSELr <= 3'd0;\nalways @(posedge CLK) SSELr <= {SSELr[1:0], SSEL};\nwire SSEL_active = ~SSELr[1];  // SSEL is active low\n\n// and for MOSI\nreg [1:0] MOSIr; initial MOSIr <= 2'd0;\nalways @(posedge CLK) MOSIr <= {MOSIr[0], MOSI};\nwire MOSI_data = MOSIr[1];\n\n// we handle SPI in 8-bits format, so we need a 3 bits counter to count the bits as they come in\nreg [$clog2(msg_len+1)-1:0] bitcnt; initial bitcnt <= {($clog2(msg_len+1)-1){1'b0}};\n\nreg is_msg_received; initial is_msg_received <= 0; // high when a message has been received\nreg [(msg_len-1):0] msg_data_received; initial msg_data_received <= {(msg_len){1'b0}};\n\nalways @(posedge CLK)\nbegin\n  if(~SSEL_active)\n    bitcnt <= 3'b000;\n  else\n  if(SCK_risingedge)\n  begin\n    bitcnt <= bitcnt + 3'b001;\n\n    // implement a shift-left register (since we receive the data MSB first)\n\t//if - protect overflow data\n\tif (bitcnt<msg_len) msg_data_received <= {msg_data_received[6:0], MOSI_data};\n  end\nend\n\nalways @(posedge CLK) is_msg_received <= SSEL_active && SCK_risingedge && (bitcnt==3'b111);\n\nassign MSG = msg_data_received;\n\nendmodule",
        "module_name": "spi_slave #",
        "module_hash": "6ec04c9fd8ddac5a5c97e28de2863756",
        "dataset_index": 4110
      },
      "mux4to1_decoder_0170fa5f": {
        "rtl_code": "\nmodule mux4to1_decoder(\n  input [3:0] sel,\n  input [15:0] in,\n  output reg [15:0] out\n);\n\nalways @(*)\n  case(sel)\n    4'b0000: out = in[15:0];\n    4'b0001: out = in[14:0];\n    4'b0010: out = in[13:0];\n    4'b0011: out = in[12:0];\n    4'b0100: out = in[11:0];\n    4'b0101: out = in[10:0];\n    4'b0110: out = in[9:0];\n    4'b0111: out = in[8:0];\n    4'b1000: out = in[7:0];\n    4'b1001: out = in[6:0];\n    4'b1010: out = in[5:0];\n    4'b1011: out = in[4:0];\n    4'b1100: out = in[3:0];\n    4'b1101: out = in[2:0];\n    4'b1110: out = in[1:0];\n    4'b1111: out = in[0];\n  endcase\n\nendmodule\nmodule count_zeros(\n  input [255:0] in,\n  output reg out\n);\n\ninteger i;\nreg [7:0] count;\n\nalways @(*)\nbegin\n  count = 0;\n  for(i = 0; i < 256; i = i + 1)\n  begin\n    if(in[i] == 1'b0)\n      count = count + 1;\n  end\n  if(count % 2 == 1)\n    out = 1'b1;\n  else\n    out = 1'b0;\nend\n\nendmodule\nmodule bitwise_or(\n  input in1,\n  input in2,\n  output out\n);\n\nassign out = in1 | in2;\n\nendmodule\nmodule top_module(\n  input [255:0] in,\n  input [3:0] sel,\n  output out\n);\n\nwire [15:0] mux_out;\nwire count_out;\n\nmux4to1_decoder mux(\n   .sel(sel),\n  .in({in[3:0], in[7:4], in[11:8], in[15:12]}),\n  .out(mux_out)\n);\n\ncount_zeros count(\n  .in(in),\n  .out(count_out)\n);\n\nbitwise_or or_gate(\n  .in1(mux_out[0]),\n  .in2(count_out),\n  .out(out)\n);\n\nendmodule",
        "module_name": "mux4to1_decoder",
        "module_hash": "0170fa5fc09c8a404bbb64348cbdbc00",
        "dataset_index": 19431
      },
      "FSM_aa7c0943": {
        "rtl_code": "\nmodule FSM(\n    input [31:0] x,\t\t\t\t\tinput [31:0] y,\t\t\t\t\tinput [31:0] z,\t\t\t\t\tinput [31:0] k,\t\t\t\t\tinput [31:0] kappa_LUTRot, \n\t input [31:0] theta_LUTRot, \n\t input [31:0] delta_LUTRot,\n\t input [31:0] kappa_LUTVec, \n\t input [31:0] theta_LUTVec, \n\t input [31:0] delta_LUTVec,\n    input [31:0] theta_LUT,\t\tinput [31:0] kappa_LUT,\t\tinput [31:0] delta_LUT,\t\tinput [1:0] mode,\t\t\t\tinput operation,\t\t\t\t\tinput clock,\n\t input done_LUTRot,\n\t input done_LUTVec,\n\t input done_LUT,\t\t\t\t\toutput reg enable_LUT,\t\t\toutput reg [7:0] address,\t\toutput reg [31:0] theta_out,\toutput reg [31:0] kappa_out,\toutput reg [31:0] delta_out,\toutput reg done_FSM,\n\t output reg [31:0] x_final,\n\t output reg [31:0] y_final,\n\t output reg [31:0] z_final,\n\t output reg [31:0] k_final,\n\t input done_ALU\n    );\n\nreg [7:0] exponent;\nreg converge;\n\nalways @ (*)\nbegin\n\t\n\tif (operation == 1'b1)\t\n\tbegin\n\t\texponent <= 8'b01111111 - z[30:23];\n\tend\n\t\n\telse if (operation == 1'b0)\n\tbegin\n\t\texponent <= x[30:23] - y[30:23];\n\tend\n\t\n\nend\n\nalways @ (posedge clock)\nbegin\n\t\n\t\tif ((done_LUT == 1'b1 || done_LUTRot == 1'b1 || done_LUTVec == 1'b1) && enable_LUT == 1'b1)\n\tbegin\n\t\t\n\t\tif ((operation == 1'b0) && (mode == 2'b00 || (exponent <= 8'b11110011 && exponent > 8'b10000000)))\n\t\tbegin\n\t\t\tdelta_out <= delta_LUT;\n\t\t\tdelta_out[30:23] <= exponent + 8'b01111111;\n\t\t\ttheta_out <= theta_LUT;\n\t\t\ttheta_out[30:23] <= exponent + 8'b01111111;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (operation == 1'b1)\n\t\tbegin\n\t\t\ttheta_out[31] <= ~z[31];\n\t\t\tdelta_out[31] <= ~z[31];\n\t\t\ttheta_out[30:0] <= theta_LUTRot[30:0];\n\t\t\tdelta_out[30:0] <= delta_LUTRot[30:0];\n\t\t\tkappa_out <= kappa_LUTRot;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse\n\t\tbegin\n\t\t\ttheta_out <= theta_LUTVec;\n\t\t\tdelta_out <= delta_LUTVec;\n\t\t\tkappa_out <= kappa_LUTVec;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\n\tif (done_ALU == 1'b1)\n\tbegin\n\t\tdone_FSM <= 1'b0;\n\tend\n\t\n\tif (operation == 1'b1)\t\t\t\t\t\t\t\t\t\t\t\t\n\tbegin\n\t\t\n\t\tif (z[30:23] <= 8'b01110000)\n\t\tbegin\n\t\t\tconverge <= 1'b1;\n\t\t\tx_final <= x;\n\t\t\ty_final <= y;\n\t\t\tz_final <= z;\n\t\t\tk_final <= k;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b00)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tbegin\n\t\t\ttheta_out[30:0] <= z[30:0];\n\t\t\tdelta_out[30:0] <= z[30:0];\n\t\t\ttheta_out[31]\t<= ~z[31];\n\t\t\tdelta_out[31]\t<= ~z[31];\n\t\t\tkappa_out <= 32'h3F800000;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b11 && z[30:23] >= 8'b01111111)\n\t\tbegin\n\t\t\ttheta_out <= 32'hBF800000;\n\t\t\tdelta_out <= 32'hBF42F7D6;\n\t\t\tkappa_out <= 32'h3FC583AB;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b01 && z[30:23] >= 8'b01111111)\t\t\n\t\tbegin\n\t\t\ttheta_out <= 32'hBF800000;\n\t\t\tdelta_out <= 32'hBFC75923;\n\t\t\tkappa_out <= 32'h3FECE788;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\n\t\telse if (mode != 2'b00 && z[30:23] < 8'b01111111 && z[30:23] > 8'b01110011) \t\t\t\n\t\tbegin\n\t\t\taddress[7:4] <= exponent[3:0];\n\t\t\taddress[3:0] <= z[22:19];\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\t\n\t\t\n\t\telse if (mode != 2'b00 && z[30:23] <= 8'b01110011)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tbegin\n\t\t\ttheta_out[30:0] <= z[30:0];\n\t\t\tdelta_out[30:0] <= z[30:0];\n\t\t\ttheta_out[31]\t<= ~z[31];\n\t\t\tdelta_out[31]\t<= ~z[31];\n\t\t\tkappa_out <= 32'h3F800000;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\n\telse if (operation == 1'b0)\t\t\t\t\t\n\tbegin\n\t\t\n\t\tif (z[30:23] <= 8'b01110000)\n\t\tbegin\n\t\t\tconverge <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b00)\n\t\tbegin\n\t\t\taddress[7:4] <= x[22:19];\n\t\t\taddress[3:0] <= y[22:19];\n\t\t\tkappa_out <= 32'h3F8;\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode != 2'b00 && exponent > 8'b11110011 && exponent <= 8'b11111111) \t\n\t\tbegin\n\t\t\taddress[7:4] <= exponent[3:0];\n\t\t\taddress[3:2] <= x[22:21];\n\t\t\taddress[1:0] <= y[22:21];\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\t\n\t\t\n\t\telse if (mode != 2'b00 && exponent <= 8'b11110011 && exponent > 8'b10000000)\n\t\tbegin\n\t\t\taddress[7:4] <= x[22:19];\n\t\t\taddress[3:0] <= y[22:19];\n\t\t\tkappa_out <= 32'h3F8;\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b11 && exponent <= 8'b10000000)\n\t\tbegin\n\t\t\tdelta_out <= 32'h3F733333;\n\t\t\ttheta_out <= 32'h3FEA77CB;\n\t\t\tkappa_out <= 32'h3E9FDF38;\t\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\t\t\n\t\telse if (mode == 2'b01 && exponent <= 8'b10000000)\n\t\tbegin\n\t\t\tdelta_out <= 32'h3F8;\t\t\t\t\ttheta_out <= 32'h3F490FDB;\n\t\t\tkappa_out <= 32'h3FB504F4;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\nend\nendmodule\n",
        "module_name": "FSM",
        "module_hash": "aa7c0943a5c7ae661f0c573c56e41b1a",
        "dataset_index": 12505
      },
      "nios_dut_nios2_gen2_0_cpu_nios2_oci_td_mode_c605f269": {
        "rtl_code": "module nios_dut_nios2_gen2_0_cpu_nios2_oci_td_mode (\n                                                     // inputs:\n                                                      ctrl,\n\n                                                     // outputs:\n                                                      td_mode\n                                                   )\n;\n\n  output  [  3: 0] td_mode;\n  input   [  8: 0] ctrl;\n\n  wire    [  2: 0] ctrl_bits_for_mux;\n  reg     [  3: 0] td_mode;\n  \n  // Assigning bits 7 to 5 of ctrl to ctrl_bits_for_mux\n  assign ctrl_bits_for_mux = ctrl[7 : 5];\n  \n  always @(ctrl_bits_for_mux)\n    begin\n      case (ctrl_bits_for_mux)\n      \n          3'b000: begin\n              td_mode = 4'b0000;\n          end // 3'b000 \n      \n          3'b001: begin\n              td_mode = 4'b1000;\n          end // 3'b001 \n      \n          3'b010: begin\n              td_mode = 4'b0100;\n          end // 3'b010 \n      \n          3'b011: begin\n              td_mode = 4'b1100;\n          end // 3'b011 \n      \n          3'b100: begin\n              td_mode = 4'b0010;\n          end // 3'b100 \n      \n          3'b101: begin\n              td_mode = 4'b1010;\n          end // 3'b101 \n      \n          3'b110: begin\n              td_mode = 4'b0101;\n          end // 3'b110 \n      \n          3'b111: begin\n              td_mode = 4'b1111;\n          end // 3'b111 \n      \n      endcase // ctrl_bits_for_mux\n    end\n\n\n\nendmodule",
        "module_name": "nios_dut_nios2_gen2_0_cpu_nios2_oci_td_mode",
        "module_hash": "c605f269c7d06c94c0343bd9ee40cf75",
        "dataset_index": 13247
      },
      "prioenc #_c6696704": {
        "rtl_code": "\nmodule prioenc #(\n\t\t parameter REQ_LEN = 4,\n\t\t parameter GRANT_LEN = 2\n\t\t )\n   (\n    input wire [REQ_LEN-1:0]   in,\n    output reg [GRANT_LEN-1:0] out,\n    output reg \t\t       en\n   );\n   \n   integer \t\t      i;\n   always @ (*) begin\n      en = 0;\n      out = 0;\n      for (i = REQ_LEN-1 ; i >= 0 ; i = i - 1) begin\n\t if (~in[i]) begin\n\t    out = i;\n\t    en = 1;\n\t end\n      end\n   end\nendmodule\n\nmodule maskunit  #(\n\t\t   parameter REQ_LEN = 4,\n\t\t   parameter GRANT_LEN = 2\n\t\t   )\n   (\n    input wire [GRANT_LEN-1:0] mask,\n    input wire [REQ_LEN-1:0]   in,\n    output reg [REQ_LEN-1:0]   out\n   );\n   \n   integer \t\t      i;\n   always @ (*) begin\n      out = 0;\n      for (i = 0 ; i < REQ_LEN ; i = i+1) begin\n\t out[i] = (mask < i) ? 1'b0 : 1'b1;\n      end\n   end\nendmodule\n\nmodule allocateunit  #(\n\t\t       parameter REQ_LEN = 4,\n\t\t       parameter GRANT_LEN = 2\n\t\t       )\n   (\n    input wire [REQ_LEN-1:0] \tbusy,\n    output wire \t\ten1,\n    output wire \t\ten2,\n    output wire [GRANT_LEN-1:0] free_ent1,\n    output wire [GRANT_LEN-1:0] free_ent2,\n    input wire [1:0] \t\treqnum,\n    output wire \t\tallocatable\n   );\n   \n   wire [REQ_LEN-1:0] \t       busy_msk;\n   \n   prioenc #(REQ_LEN, GRANT_LEN) p1\n     (\n      .in(busy),\n      .out(free_ent1),\n      .en(en1)\n      );\n\n   maskunit #(REQ_LEN, GRANT_LEN) msku\n     (\n      .mask(free_ent1),\n      .in(busy),\n      .out(busy_msk)\n      );\n   \n   prioenc #(REQ_LEN, GRANT_LEN) p2\n     (\n      .in(busy | busy_msk),\n      .out(free_ent2),\n      .en(en2)\n      );\n\n   assign allocatable = (reqnum > ({1'b0,en1}+{1'b0,en2})) ? 1'b0 : 1'b1;\nendmodule\n\n",
        "module_name": "prioenc #",
        "module_hash": "c6696704da1ad7fdde84423437ef2f0c",
        "dataset_index": 23544
      },
      "adder_tree_top_9a94a363": {
        "rtl_code": "`define ADDER_WIDTH 020\n`define DUMMY_WIDTH 128\n\n`define 2_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule",
        "module_name": "adder_tree_top",
        "module_hash": "9a94a3631bfa4bdc467bbfb34ef5355a",
        "dataset_index": 24487
      },
      "counter_8dfe102b": {
        "rtl_code": "\nmodule counter(\n    input clk,\n    input reset,\n    output reg [3:0] count,\n    output reg control\n);\n\nalways @(posedge clk) begin\n    if (reset == 1) begin\n        count <= 4'b0000;\n        control <= 1'b0;\n    end\n    else begin\n        if (count == 4'b1111) begin\n            count <= 4'b0000;\n        end\n        else begin\n            count <= count + 1;\n        end\n        \n        if (count[0] == 1) begin\n            control <= 1'b1;\n        end\n        else begin\n            control <= 1'b0;\n        end\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "8dfe102bc13cecae761b59d9ce3b9207",
        "dataset_index": 12894
      },
      "top__7d89bb90": {
        "rtl_code": "\nmodule top_module (\n    input [2:0] sel,\n    input [5:0] data_in,\n    input in,\n    output [3:0] mux_out,\n    output out,\n    output [3:0] or_out\n);\n\n    // 6-to-1 Multiplexer\n    wire [5:0] mux_input;\n    assign mux_input = {data_in[sel], data_in[sel+1], data_in[sel+2], data_in[sel+3], data_in[sel+4], data_in[sel+5]};\n    mux_6to1 mux_inst (\n        .sel(sel),\n        .data_in(mux_input),\n        .data_out(mux_out)\n    );\n\n    // NOT Gate\n    wire not_input;\n    assign not_input = in;\n    not_gate not_inst (\n        .in(not_input),\n        .out(out)\n    );\n\n    // Bitwise OR\n    assign or_out = mux_out | out;\n\nendmodule\nmodule mux_6to1 (\n    input [2:0] sel,\n    input [5:0] data_in,\n    output reg [3:0] data_out\n);\n    always @*\n    begin\n        case(sel)\n            3'b000: data_out = data_in[0];\n            3'b001: data_out = data_in[1];\n            3'b010: data_out = data_in[2];\n            3'b011: data_out = data_in[3];\n            3'b100: data_out = data_in[4];\n            3'b101: data_out = data_in[5];\n            default: data_out = 4'b0000;\n        endcase\n    end\nendmodule\nmodule not_gate (\n    input in,\n    output out\n);\n    wire nand_out;\n    assign nand_out = ~(in & in);\n    assign out = nand_out;\nendmodule",
        "module_name": "top_",
        "module_hash": "7d89bb906d4c1056930d8d2b814c37b2",
        "dataset_index": 8882
      },
      "top__2e4b08e5": {
        "rtl_code": "module top_module (\n    input a,\n    input b,\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output reg out_comb // Output from the functional module that combines the XOR gate and the counter\n);\n\n// Internal wires and registers\nreg [3:0] counter;\nwire even;\nwire odd;\nwire xor_out;\nreg [3:0] next_counter;\n\n// XOR gate implementation\nassign xor_out = a ^ b;\n\n// 4-bit binary counter implementation using state machine architecture\nalways @ (posedge clk or posedge reset) begin\n    if (reset) begin\n        counter <= 4'b0;\n    end else begin\n        case (counter)\n            4'b0000: next_counter = 4'b0001;\n            4'b0001: next_counter = 4'b0010;\n            4'b0010: next_counter = 4'b0011;\n            4'b0011: next_counter = 4'b0100;\n            4'b0100: next_counter = 4'b0101;\n            4'b0101: next_counter = 4'b0110;\n            4'b0110: next_counter = 4'b0111;\n            4'b0111: next_counter = 4'b1000;\n            4'b1000: next_counter = 4'b1001;\n            4'b1001: next_counter = 4'b1010;\n            4'b1010: next_counter = 4'b1011;\n            4'b1011: next_counter = 4'b1100;\n            4'b1100: next_counter = 4'b1101;\n            4'b1101: next_counter = 4'b1110;\n            4'b1110: next_counter = 4'b1111;\n            4'b1111: next_counter = 4'b0000;\n        endcase\n        counter <= next_counter;\n    end\nend\n\n// Determine if the counter value is even or odd\nassign even = ~counter[0];\nassign odd = counter[0];\n\n// Functional module implementation\nalways @ (*) begin\n    if (even) begin\n        out_comb = xor_out;\n    end else if (odd) begin\n        out_comb = counter;\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "2e4b08e5f71f58cdc501c44256381cc0",
        "dataset_index": 1773
      },
      "adder4_8238dbec": {
        "rtl_code": "\nmodule adder4 (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [4:0] carry;\n    assign carry[0] = Cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : adder_loop\n            full_adder fa (\n                .a(A[i]),\n                .b(B[i]),\n                .cin(carry[i]),\n                .sum(Sum[i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n\n    assign Cout = carry[4];\n\nendmodule\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign {cout, sum} = (a & b) | ((a^b) & cin) | ({1'b0, a} & {1'b0, b});\n\nendmodule",
        "module_name": "adder4",
        "module_hash": "8238dbecaedc67ad44fab8728590dd50",
        "dataset_index": 13362
      },
      "baud_rate_generator_9a8a82e7": {
        "rtl_code": "\nmodule baud_rate_generator(\n    input clk, rst_n, bps_start,\n    output wire clk_baud\n);\n\nparameter BAUD_RATE = 9600;\nparameter freq = 16000000; // 16 MHz clock frequency\n\nreg [31:0] counter;\nreg toggle;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        counter <= 0;\n        toggle <= 0;\n    end\n    else if(bps_start) begin\n        counter <= counter + 1;\n        if(counter == (freq / (BAUD_RATE * 2))) begin\n            toggle <= ~toggle;\n            counter <= 0;\n        end\n    end\nend\n\nassign clk_baud = toggle;\n\nendmodule",
        "module_name": "baud_rate_generator",
        "module_hash": "9a8a82e77e4400a73902bb7b5c6ab49b",
        "dataset_index": 19735
      },
      "parallel_to_serial_137e49f8": {
        "rtl_code": "\nmodule parallel_to_serial (\n    input clk,\n    input [7:0] data_in,\n    output reg serial_out\n);\n\nreg [7:0] shift_reg;\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (counter == 0) begin\n        shift_reg <= data_in;\n        counter <= 1;\n    end else if (counter == 7) begin\n        counter <= 0;\n    end else begin\n        shift_reg <= {shift_reg[6:0], 1'b0};\n        counter <= counter + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (counter == 0) begin\n        serial_out <= shift_reg[7];\n    end else if (counter == 1) begin\n        serial_out <= shift_reg[6];\n    end else if (counter == 2) begin\n        serial_out <= shift_reg[5];\n    end else if (counter == 3) begin\n        serial_out <= shift_reg[4];\n    end else if (counter == 4) begin\n        serial_out <= shift_reg[3];\n    end else if (counter == 5) begin\n        serial_out <= shift_reg[2];\n    end else if (counter == 6) begin\n        serial_out <= shift_reg[1];\n    end else if (counter == 7) begin\n        serial_out <= shift_reg[0];\n    end\nend\n\nendmodule",
        "module_name": "parallel_to_serial",
        "module_hash": "137e49f841b8506abdf463ab28705f51",
        "dataset_index": 18474
      },
      "video_sys_Video_RGB_Resampler_5bdccddb": {
        "rtl_code": "\n\n\n\nmodule video_sys_Video_RGB_Resampler (\n\tclk,\n\treset,\n\n\tstream_in_data,\n\tstream_in_startofpacket,\n\tstream_in_endofpacket,\n\tstream_in_empty,\n\tstream_in_valid,\n\n\tstream_out_ready,\n\t\n\tstream_in_ready,\n\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_empty,\n\tstream_out_valid\n);\n\n\n\nparameter IDW\t\t= 23;\nparameter ODW\t\t= 15;\n\nparameter IEW\t\t= 1;\nparameter OEW\t\t= 0;\n\nparameter ALPHA\t= 10'h3FF;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[IDW:0]\tstream_in_data;\ninput\t\t\t\t\t\tstream_in_startofpacket;\ninput\t\t\t\t\t\tstream_in_endofpacket;\ninput\t\t\t[IEW:0]\tstream_in_empty;\ninput\t\t\t\t\t\tstream_in_valid;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tstream_in_ready;\n\noutput reg\t[ODW:0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t[OEW:0]\tstream_out_empty;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire\t\t[ 9: 0]\tr;\nwire\t\t[ 9: 0]\tg;\nwire\t\t[ 9: 0]\tb;\nwire\t\t[ 9: 0]\ta;\n\n\nwire\t\t[ODW:0]\tconverted_data;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'b0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_empty\t\t\t\t<=  'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (stream_out_ready | ~stream_out_valid)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= converted_data;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid;\n\tend\nend\n\n\n\nassign stream_in_ready = stream_out_ready | ~stream_out_valid;\n\nassign r = {stream_in_data[23:16], stream_in_data[23:22]};\nassign g = {stream_in_data[15: 8], stream_in_data[15:14]};\nassign b = {stream_in_data[ 7: 0], stream_in_data[ 7: 6]};\n\nassign a = ALPHA;\n\nassign converted_data[15:11] = r[ 9: 5];\nassign converted_data[10: 5] = g[ 9: 4];\nassign converted_data[ 4: 0] = b[ 9: 5];\n\n\n\n\nendmodule\n\n",
        "module_name": "video_sys_Video_RGB_Resampler",
        "module_hash": "5bdccddb1a251c4060dd88b778c2e953",
        "dataset_index": 24175
      },
      "custom_or_22c03339": {
        "rtl_code": "module custom_or (\n    input a,\n    input b,\n    input c,\n    output x\n);\n\n    wire ab, abc;\n\n    assign ab = a | b;\n    assign abc = ab | c;\n    assign x = abc;\n\nendmodule",
        "module_name": "custom_or",
        "module_hash": "22c033396b205c411f533310f862d436",
        "dataset_index": 8450
      },
      "rising_edge_detector_53ac709a": {
        "rtl_code": "module rising_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] pipeline_reg [0:2];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        pipeline_reg[0] <= 0;\n        pipeline_reg[1] <= 0;\n        pipeline_reg[2] <= 0;\n        out <= 0;\n    end else begin\n        pipeline_reg[0] <= in;\n        pipeline_reg[1] <= pipeline_reg[0];\n        pipeline_reg[2] <= pipeline_reg[1];\n        out <= pipeline_reg[0] & ~pipeline_reg[1] & pipeline_reg[2];\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nrising_edge_detector detector (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule",
        "module_name": "rising_edge_detector",
        "module_hash": "53ac709a8114455dc2fdf70a302d092f",
        "dataset_index": 706
      },
      "rising_edge_detector_e12d0310": {
        "rtl_code": "module rising_edge_detector (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nreg [7:0] reg1, reg2, reg3;\n\nalways @(posedge clk) begin\n    reg1 <= in;\nend\n\nalways @(posedge clk) begin\n    reg2 <= reg1;\nend\n\nalways @(posedge clk) begin\n    reg3 <= reg2;\nend\n\nassign anyedge = (reg1 ^ reg2) & reg3;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nrising_edge_detector detector(\n    .clk(clk),\n    .in(in),\n    .anyedge(anyedge)\n);\n\nendmodule",
        "module_name": "rising_edge_detector",
        "module_hash": "e12d03109f63d75a0d47e13376cd71c4",
        "dataset_index": 19318
      },
      "and_gate_1f5f6d60": {
        "rtl_code": "module and_gate (\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    output Y\n);\n\n    // Logic to check if all inputs are high\n    assign Y = A1 & A2 & A3 & A4;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "1f5f6d60a224827ef4e3ae1ebe1eb5ab",
        "dataset_index": 5603
      },
      "binary_storage_shift_37142f20": {
        "rtl_code": "module binary_storage_shift(\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] d,\n    input [1:0] shift_ctrl,\n    output reg [7:0] q,\n    output reg [7:0] q_shifted // Shifted output\n);\n\nreg [3:0] flip_flop; // 4 D flip-flops\nreg [7:0] shifted_d; // Shifted input\nwire [1:0] shift_amt; // Shift amount\n\nassign shift_amt = (shift_ctrl == 2'b00) ? 2'b00 :\n                   (shift_ctrl == 2'b01) ? 2'b01 :\n                   (shift_ctrl == 2'b10) ? 2'b10 :\n                   2'b11;\n\nalways @ (posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n        q_shifted <= 8'b0;\n        flip_flop <= 4'b0;\n    end else begin\n        flip_flop <= {flip_flop[2:0], d[7]};\n        q <= {flip_flop[3], flip_flop[2], flip_flop[1], flip_flop[0]};\n        shifted_d <= {d[5:0], 2'b00};\n        q_shifted <= shifted_d << shift_amt;\n    end\nend\n\nendmodule",
        "module_name": "binary_storage_shift",
        "module_hash": "37142f20cc26e9e4237ecbd0f55659f2",
        "dataset_index": 20569
      },
      "Multiplexer_AC__parameterized94_790d3b88": {
        "rtl_code": "\nmodule Multiplexer_AC__parameterized94\n   (ctrl,\n    D0,\n    D1,\n    S);\n  input ctrl;\n  input [0:0] D0;\n  input [0:0] D1;\n  output [0:0] S;\n\n  wire [0:0] S;\n  wire ctrl;\n  wire [0:0] D0;\n  wire [0:0] D1;\n\n  assign S = ctrl ? D1 : D0;\n\nendmodule",
        "module_name": "Multiplexer_AC__parameterized94",
        "module_hash": "790d3b885085720b4677a97ffd727ff7",
        "dataset_index": 701
      },
      "sky130_fd_sc_ls__and3b_2db1ee1f": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__and3b (\n    X  ,\n    A_N,\n    B  ,\n    C\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N            );\n    and and0 (and0_out_X, C, not0_out, B );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__and3b",
        "module_hash": "2db1ee1f8a71dc6be7d0aed4a29a9fbc",
        "dataset_index": 8564
      },
      "top__e41bd2bb": {
        "rtl_code": "module top_module (\n    input clk,                 // Clock\n    input rst_n,               // Synchronous active-low reset\n    input [7:0] data_in,       // 8-bit input data\n    output reg [7:0] q         // 8-bit output data\n);\n\n    // Internal signals\n    wire [23:0] shift_out;\n    wire [9:0] accu_out;\n    reg [7:0] shift_in;\n    reg valid_a;\n    wire ready_a;\n    reg ready_b;\n    \n    // Instantiate modules\n    shift_register shift_reg (\n        .clk(clk),\n        .d(shift_in),\n        .q(shift_out)\n    );\n    \n    accu accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(shift_out[7:0]),\n        .valid_a(valid_a),\n        .ready_b(ready_b),\n        .ready_a(ready_a),\n        .valid_b(),\n        .data_out(accu_out)\n    );\n    \n    // Assign shift_in\n    always @ (posedge clk) begin\n        if (!rst_n) begin\n            shift_in <= 8'b0;\n        end else begin\n            shift_in <= data_in;\n        end\n    end\n    \n    // Assign valid_a and ready_b\n    always @ (posedge clk) begin\n        if (!rst_n) begin\n            valid_a <= 1'b0;\n            ready_b <= 1'b0;\n        end else begin\n            valid_a <= 1'b1;\n            ready_b <= ready_a;\n        end\n    end\n    \n    // Assign q\n    always @ (posedge clk) begin\n        if (!rst_n) begin\n            q <= 8'b0;\n        end else begin\n            q <= accu_out[9:2];\n        end\n    end\n    \nendmodule\n\nmodule shift_register (\n    input clk,         // Clock\n    input [7:0] d,     // 8-bit input data\n    output [23:0] q    // 24-bit output data\n);\n    reg [23:0] shift_reg;\n    \n    always @ (posedge clk) begin\n        shift_reg <= {shift_reg[15:0], d};\n    end\n    \n    assign q = shift_reg;\n    \nendmodule\n\nmodule accu(\n    input clk,          // Clock\n    input rst_n,        // Synchronous active-low reset\n    input [7:0] data_in,// 8-bit input data\n    input valid_a,      // Valid signal for input data\n    input ready_b,      // Ready signal from downstream module\n    output ready_a,     // Ready signal for input data\n    output reg valid_b, // Valid signal for output data\n    output reg [9:0] data_out // 10-bit output data\n);\n    reg [31:0] accu_reg;\n    reg [1:0] count;\n    \n    always @ (posedge clk) begin\n        if (!rst_n) begin\n            accu_reg <= 32'b0;\n            count <= 2'b0;\n            valid_b <= 1'b0;\n        end else begin\n            if (valid_a && ready_b) begin\n                accu_reg <= accu_reg + data_in;\n                count <= count + 1;\n                if (count == 2) begin\n                    valid_b <= 1'b1;\n                    data_out <= accu_reg[31:22];\n                    accu_reg <= accu_reg[21:0];\n                    count <= 2'b0;\n                end\n            end\n        end\n    end\n    \n    assign ready_a = !valid_a || ready_b;\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "e41bd2bb21e9b22eff78e0b76b18b8a1",
        "dataset_index": 19276
      },
      "crc #_584335c0": {
        "rtl_code": "module crc #(\n    parameter CRC_WIDTH     = 32,\n    parameter DATA_WIDTH    = 8,\n    parameter POLYNOMIAL    = 32'h04C11DB7,\n    parameter SEED          = 32'hFFFFFFFF\n)(\n    input clk,\n    input rst,\n    input [DATA_WIDTH-1:0] data_in,\n    output reg [CRC_WIDTH-1:0] crc_out\n);\n\nreg [CRC_WIDTH-1:0] crc_reg;\nreg [CRC_WIDTH-1:0] polynomial;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        crc_reg <= SEED;\n    end else begin\n        crc_reg <= crc_reg << DATA_WIDTH;\n        crc_reg[DATA_WIDTH-1:0] <= crc_reg[DATA_WIDTH-1:0] ^ data_in;\n\n        if (crc_reg[CRC_WIDTH-1]) begin\n            crc_reg <= crc_reg ^ polynomial;\n        end\n    end\nend\n\nalways @* begin\n    polynomial = POLYNOMIAL;\nend\n\nalways @* begin\n    crc_out = ~crc_reg;\nend\n\nendmodule",
        "module_name": "crc #",
        "module_hash": "584335c0cd4b8645f9164b609d0fea7c",
        "dataset_index": 6678
      },
      "ppfifo_data_generator_579398cd": {
        "rtl_code": "module ppfifo_data_generator (\n  input               clk,\n  input               rst,\n  input               i_enable,\n\n  input       [1:0]   i_wr_rdy,\n  output  reg [1:0]   o_wr_act,\n  input       [23:0]  i_wr_size,\n  output  reg         o_wr_stb,\n  output  reg [31:0]  o_wr_data\n);\n\nreg   [23:0]          r_count;\nalways @ (posedge clk) begin\n  if (rst) begin\n    o_wr_act        <=  0;\n    o_wr_stb        <=  0;\n    o_wr_data       <=  0;\n    r_count         <=  0;\n  end\n  else begin\n    o_wr_stb        <= 0;\n    if (i_enable) begin\n      if ((i_wr_rdy > 0) && (o_wr_act == 0))begin\n        r_count     <=  0;\n        if (i_wr_rdy[0]) begin\n          o_wr_act[0]  <=  1;\n        end\n        else begin\n          o_wr_act[1]  <=  1;\n        end\n      end\n      else if (o_wr_act > 0) begin\n        if (r_count < i_wr_size) begin\n          r_count   <=  r_count + 1;\n          o_wr_stb  <=  1;\n          o_wr_data <=  r_count;\n        end\n        else begin\n          o_wr_act  <=  0;\n        end\n      end\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "ppfifo_data_generator",
        "module_hash": "579398cdd23eeb1c30b0c10d0f64318c",
        "dataset_index": 6963
      },
      "shift_register_counter_3d4a8811": {
        "rtl_code": "module shift_register_counter (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // 8-bit input for the register\n    input select,     // Select input to choose between register and counter\n    output [7:0] q    // 8-bit output from the AND module\n);\n\n    reg [7:0] shift_reg;\n    reg [3:0] counter;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'h5A;\n            counter <= 4'h0;\n        end else begin\n            if (select) begin\n                shift_reg <= {shift_reg[6:0], d[0]};\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n    \n    assign q = shift_reg & {4'hF, counter};\n    \nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // 8-bit input for the register\n    input select,     // Select input to choose between register and counter\n    output [7:0] q    // 8-bit output from the AND module\n);\n\n    shift_register_counter src (\n        .clk(clk),\n        .reset(reset),\n        .d(d),\n        .select(select),\n        .q(q)\n    );\n    \nendmodule",
        "module_name": "shift_register_counter",
        "module_hash": "3d4a8811391e31b2f868793479406433",
        "dataset_index": 8174
      },
      "ps2_kbd_1596c6f7": {
        "rtl_code": "\nmodule ps2_kbd (\n                clk, \n                clrn, \n                ps2_clk, \n                ps2_data, \n                rdn, \n                data, \n                ready, \n                overflow\n                );\n\n\tinput              \tclk, clrn;          input              \tps2_clk, ps2_data;  input              \trdn;                output     \t[ 7: 0] data;               output             \tready;              output reg         \toverflow;           reg        \t[ 3: 0] count;              reg        \t[ 9: 0] buffer;             reg        \t[ 7: 0] fifoo[7:0];         reg        \t[ 2: 0] w_ptr, r_ptr;       reg        \t[ 2: 0] ps2_clk_sync;       integer    \t        i;\n\n\tinitial begin \n        count    <= 0;                     \tw_ptr    <= 0;                     \tr_ptr    <= 0;                     \toverflow <= 0;                     \tfor(i = 0; i < 8; i = i + 1) fifoo[i]=0;\n\tend\n\n\n\talways @ (posedge clk) begin                       ps2_clk_sync <= {ps2_clk_sync[1:0],ps2_clk};       end                                                    wire sampling = ps2_clk_sync[2] & ~ps2_clk_sync[1];    reg [1:0] rdn_falling;\n\t\n\talways @ (posedge clk) begin\n\t\trdn_falling <= {rdn_falling[0],rdn};\n\t\tif (clrn == 0) begin\n\t\t\tcount \t\t<= 0;\n\t\t\tw_ptr \t\t<= 0;\n\t\t\tr_ptr \t\t<= 0;\n\t\t\toverflow \t<= 0;\n\t\tend else if (sampling) begin\n\t\t\tif (count == 4'd10) begin                  if ((buffer[0] == 0) && (ps2_data) && (^buffer[9:1])) begin fifoo[w_ptr] <= buffer[8:1];       w_ptr <= w_ptr + 3'b1;             overflow <= overflow | (r_ptr == (w_ptr + 3'b1));\n\t\t\t\tend\n\t\t\tcount <= 0;                                end else begin                             buffer[count]   <= ps2_data;           count           <= count + 3'b1;       end\n\t\tend\n\n\t\tif ((rdn_falling == 2'b01) && ready) begin     r_ptr    <= r_ptr + 3'b1;                  overflow <= 0;                             end\n\tend\n\n\tassign ready   = (w_ptr != r_ptr);                 assign data    = fifoo[r_ptr];                     endmodule\n\n",
        "module_name": "ps2_kbd",
        "module_hash": "1596c6f77c86e5bc7c73103060e8e7c6",
        "dataset_index": 8625
      },
      "mux_2to1_a32123fe": {
        "rtl_code": "module mux_2to1 (M, A, B, S);\n   input A, B, S;\n   output M;\n\n   assign M = (S == 1) ? B : A;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "a32123febdbeb69c674662d06d01b148",
        "dataset_index": 2333
      },
      "onchip_trace_mem_2213cb69": {
        "rtl_code": "\nmodule onchip_trace_mem (\n  input clk, reset, reset_req, clken, chipselect, write,\n  input [8:0] address, byteenable,\n  input [63:0] writedata,\n  output reg [63:0] readdata\n);\n\n  parameter INIT_FILE = \"\";\n  parameter WIDTH = 64;\n  parameter DEPTH = 512;\n  parameter ADDR_WIDTH = 9;\n  parameter BYTE_WIDTH = 8;\n\n  reg [WIDTH-1:0] mem [0:DEPTH-1];\n\n  wire wren = chipselect & write;\n\n  wire clocken0;\n  assign clocken0 = clken & ~reset_req;\n\n  initial begin\n    if (INIT_FILE != \"\") begin\n      $readmemb(INIT_FILE, mem);\n    end\n  end\n\n  always @(posedge clk) begin\n    if (wren) begin\n      mem[address] <= writedata;\n    end\n    readdata <= mem[address];\n  end\n\nendmodule",
        "module_name": "onchip_trace_mem",
        "module_hash": "2213cb6900d762f38945a55f3bf0875d",
        "dataset_index": 18389
      },
      "mux4_b7da2698": {
        "rtl_code": "module mux4(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input s0,\n    input s1,\n    output [3:0] out\n);\n\nwire [3:0] w1, w2;\n\nassign w1 = s0 ? in2 : in0;\nassign w2 = s0 ? in3 : in1;\n\nassign out = s1 ? w2 : w1;\n\nendmodule",
        "module_name": "mux4",
        "module_hash": "b7da269898b447e6a9d04b9fb3e171f1",
        "dataset_index": 14412
      },
      "sp_mux_9to1_sel4_6_1 #_2ffdee9d": {
        "rtl_code": "\n\nmodule sp_mux_9to1_sel4_6_1 #(\nparameter\n    ID                = 0,\n    NUM_STAGE         = 1,\n    din1_WIDTH       = 32,\n    din2_WIDTH       = 32,\n    din3_WIDTH       = 32,\n    din4_WIDTH       = 32,\n    din5_WIDTH       = 32,\n    din6_WIDTH       = 32,\n    din7_WIDTH       = 32,\n    din8_WIDTH       = 32,\n    din9_WIDTH       = 32,\n    din10_WIDTH         = 32,\n    dout_WIDTH            = 32\n)(\n    input  [5 : 0]     din1,\n    input  [5 : 0]     din2,\n    input  [5 : 0]     din3,\n    input  [5 : 0]     din4,\n    input  [5 : 0]     din5,\n    input  [5 : 0]     din6,\n    input  [5 : 0]     din7,\n    input  [5 : 0]     din8,\n    input  [5 : 0]     din9,\n    input  [3 : 0]    din10,\n    output [5 : 0]   dout);\n\nwire [3 : 0]     sel;\nwire [5 : 0]         mux_1_0;\nwire [5 : 0]         mux_1_1;\nwire [5 : 0]         mux_1_2;\nwire [5 : 0]         mux_1_3;\nwire [5 : 0]         mux_1_4;\nwire [5 : 0]         mux_2_0;\nwire [5 : 0]         mux_2_1;\nwire [5 : 0]         mux_2_2;\nwire [5 : 0]         mux_3_0;\nwire [5 : 0]         mux_3_1;\nwire [5 : 0]         mux_4_0;\n\nassign sel = din10;\n\nassign mux_1_0 = (sel[0] == 0)? din1 : din2;\nassign mux_1_1 = (sel[0] == 0)? din3 : din4;\nassign mux_1_2 = (sel[0] == 0)? din5 : din6;\nassign mux_1_3 = (sel[0] == 0)? din7 : din8;\nassign mux_1_4 = din9;\n\nassign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;\nassign mux_2_1 = (sel[1] == 0)? mux_1_2 : mux_1_3;\nassign mux_2_2 = mux_1_4;\n\nassign mux_3_0 = (sel[2] == 0)? mux_2_0 : mux_2_1;\nassign mux_3_1 = mux_2_2;\n\nassign mux_4_0 = (sel[3] == 0)? mux_3_0 : mux_3_1;\n\nassign dout = mux_4_0;\n\nendmodule\n",
        "module_name": "sp_mux_9to1_sel4_6_1 #",
        "module_hash": "2ffdee9d4261c3ca78143a1d6eef2fdd",
        "dataset_index": 20034
      },
      "four_input_signed_adder_083ed658": {
        "rtl_code": "module four_input_signed_adder (\n  clk,\n  data_1,\n  data_2,\n  data_3,\n  data_4,\n  data_p,\n  ddata_in,\n  ddata_out\n);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input clk;\n  input [24:0] data_1;\n  input [24:0] data_2;\n  input [24:0] data_3;\n  input [24:0] data_4;\n  output [7:0] data_p;\n  input [DW:0] ddata_in;\n  output [DW:0] ddata_out;\n\n  reg [DW:0] p1_ddata = 'd0;\n  reg [24:0] p1_data_1 = 'd0;\n  reg [24:0] p1_data_2 = 'd0;\n  reg [24:0] p1_data_3 = 'd0;\n  reg [24:0] p1_data_4 = 'd0;\n  reg [DW:0] p2_ddata = 'd0;\n  reg [24:0] p2_data_0 = 'd0;\n  reg [24:0] p2_data_1 = 'd0;\n  reg [DW:0] p3_ddata = 'd0;\n  reg [24:0] p3_data = 'd0;\n  reg [DW:0] ddata_out = 'd0;\n  reg [7:0] data_p = 'd0;\n\n  wire [24:0] p1_data_1_p_s;\n  wire [24:0] p1_data_1_n_s;\n  wire [24:0] p1_data_1_s;\n  wire [24:0] p1_data_2_p_s;\n  wire [24:0] p1_data_2_n_s;\n  wire [24:0] p1_data_2_s;\n  wire [24:0] p1_data_3_p_s;\n  wire [24:0] p1_data_3_n_s;\n  wire [24:0] p1_data_3_s;\n  wire [24:0] p1_data_4_p_s;\n  wire [24:0] p1_data_4_n_s;\n  wire [24:0] p1_data_4_s;\n\n  // pipe line stage 1, get the two's complement versions\n  assign p1_data_1_p_s = {1'b0, data_1[23:0]};\n  assign p1_data_1_n_s = ~p1_data_1_p_s + 1'b1;\n  assign p1_data_1_s = (data_1[24] == 1'b1) ? p1_data_1_n_s : p1_data_1_p_s;\n\n  assign p1_data_2_p_s = {1'b0, data_2[23:0]};\n  assign p1_data_2_n_s = ~p1_data_2_p_s + 1'b1;\n  assign p1_data_2_s = (data_2[24] == 1'b1) ? p1_data_2_n_s : p1_data_2_p_s;\n\n  assign p1_data_3_p_s = {1'b0, data_3[23:0]};\n  assign p1_data_3_n_s = ~p1_data_3_p_s + 1'b1;\n  assign p1_data_3_s = (data_3[24] == 1'b1) ? p1_data_3_n_s : p1_data_3_p_s;\n\n  assign p1_data_4_p_s = {1'b0, data_4[23:0]};\n  assign p1_data_4_n_s = ~p1_data_4_p_s + 1'b1;\n  assign p1_data_4_s = (data_4[24] == 1'b1) ? p1_data_4_n_s : p1_data_4_p_s;\n\n  always @(posedge clk) begin\n    p1_ddata <= ddata_in;\n    p1_data_1 <= p1_data_1_s;\n    p1_data_2 <= p1_data_2_s;\n    p1_data_3 <= p1_data_3_s;\n    p1_data_4 <= p1_data_4_s;\n  end\n\n  // pipe line stage 2, get the sum (intermediate, 4->2)\n  always @(posedge clk) begin\n    p2_ddata <= p1_ddata;\n    p2_data_0 <= p1_data_1 + p1_data_2;\n    p2_data_1 <= p1_data_3 + p1_data_4;\n  end\n\n  // pipe line stage 3, get the sum (final, 2->1)\n  always @(posedge clk) begin\n    p3_ddata <= p2_ddata;\n    p3_data <= p2_data_0 + p2_data_1;\n  end\n\n  // output registers, output is unsigned (0 if sum is < 0) and saturated\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    if (p3_data[24] == 1'b1) begin\n      data_p <= 8'h00;\n    end else if (p3_data[23:20] == 'd0) begin\n      data_p <= p3_data[19:12];\n    end else begin\n      data_p <= 8'hff;\n    end\n  end\n\nendmodule",
        "module_name": "four_input_signed_adder",
        "module_hash": "083ed658f271473bd8c098e097020a9b",
        "dataset_index": 18192
      },
      "mux81c_52493ba8": {
        "rtl_code": "module mux81c (\n  input [7:0] I,\n  input [2:0] S,\n  output reg Y\n);\n\n  always @*\n  begin\n    case (S)\n      3'b000: Y = I[0];\n      3'b001: Y = I[1];\n      3'b010: Y = I[2];\n      3'b011: Y = I[3];\n      3'b100: Y = I[4];\n      3'b101: Y = I[5];\n      3'b110: Y = I[6];\n      3'b111: Y = I[7];\n    endcase\n  end\n\nendmodule",
        "module_name": "mux81c",
        "module_hash": "52493ba8e8877c7a275a0f68a932b724",
        "dataset_index": 3283
      },
      "shift_register_32bit_538ee0a3": {
        "rtl_code": "\nmodule shift_register_32bit (\n    input SHIFT,\n    input DATA_IN,\n    output SHIFT_OUT,\n    output [31:0] DATA_OUT\n);\n\nreg [31:0] pipeline [0:2];\n\nalways @(posedge SHIFT) begin\n    pipeline[0] <= {pipeline[0][30:0], DATA_IN};\n    pipeline[1] <= pipeline[0];\n    pipeline[2] <= pipeline[1];\nend\n\nassign DATA_OUT = pipeline[2];\nassign SHIFT_OUT = pipeline[0][31];\n\nendmodule\n",
        "module_name": "shift_register_32bit",
        "module_hash": "538ee0a3680cd13d07d1c7e4f572a7e2",
        "dataset_index": 18788
      },
      "top__adc11db9": {
        "rtl_code": "module top_module (\n  input clk,\n  input reset,\n  input [7:0] serial_input,\n  output reg [9:0] accumulated_output\n);\n\n  reg [7:0] serial_data;\n  reg [2:0] cycle_count;\n  wire average_valid;\n\n  accu accumulator(\n    .clk(clk),\n    .rst_n(!reset),\n    .data_in(serial_data),\n    .valid_a(average_valid),\n    .ready_b(1'b1),\n    .ready_a(),\n    .valid_b(),\n    .data_out(accumulated_output)\n  );\n\n  always @(posedge clk) begin\n    if (reset) begin\n      serial_data <= 8'h00;\n      cycle_count <= 3'b0;\n    end else begin\n      serial_data <= serial_input;\n      cycle_count <= cycle_count + 1;\n    end\n  end\n\n  assign average_valid = (cycle_count == 3'b111);\n\nendmodule\n\nmodule accu(\n  input clk,\n  input rst_n,\n  input [7:0] data_in,\n  input valid_a,\n  input ready_b,\n  output reg ready_a,\n  output reg valid_b,\n  output reg [9:0] data_out\n);\n\n  reg [9:0] accumulator;\n  reg [2:0] cycle_count;\n  wire average_valid;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      accumulator <= 10'h000;\n      cycle_count <= 3'b0;\n      ready_a <= 1'b0;\n      valid_b <= 1'b0;\n    end else begin\n      if (valid_a && ready_b) begin\n        accumulator <= accumulator + data_in;\n        cycle_count <= cycle_count + 1;\n        if (cycle_count == 3'b111) begin\n          data_out <= accumulator / 6;\n          accumulator <= 10'h000;\n          cycle_count <= 3'b0;\n          ready_a <= 1'b1;\n          valid_b <= 1'b1;\n        end else begin\n          ready_a <= 1'b0;\n          valid_b <= 1'b0;\n        end\n      end else begin\n        ready_a <= 1'b0;\n        valid_b <= 1'b0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "adc11db943c046a1b76201f02713ae5d",
        "dataset_index": 948
      },
      "FIFO_WxD #_07a8f6a1": {
        "rtl_code": "\nmodule FIFO_WxD #(\n\tparameter U_FIFO_WIDTH = 24, \tparameter U_FIFO_SQ_DEPTH = 10 )(\n\tinput wire rst,\n\tinput wire [U_FIFO_WIDTH - 1:0] dataIn,\n\tinput wire wr_en,\n\tinput wire rd_en,\n\toutput wire [U_FIFO_WIDTH - 1:0] dataOut,\n\toutput wire full_flg,\n\toutput wire empty_flg\n\t);\n\n\treg [U_FIFO_WIDTH - 1:0] fifo [(2^U_FIFO_SQ_DEPTH) - 1:0];\n\t\n\treg [U_FIFO_SQ_DEPTH - 1:0] wr_ptr = 0;\n\treg [U_FIFO_SQ_DEPTH - 1:0] rd_ptr = 0;\n\t\n\talways@(posedge wr_en or negedge rst)\n\tbegin\n\t\t\n\t\tif(!rst)\twr_ptr <= 0;\n\t\telse if(!full_flg) begin\n\t\t\tfifo[wr_ptr] <= dataIn;\n\t\t\twr_ptr <= wr_ptr + 1'b1;\n\t\tend\n\tend always@(posedge rd_en or negedge rst)\n\tbegin\n\t\t\n\t\tif(!rst)\n\t\t\trd_ptr <= 0;\n\t\telse if(!empty_flg)\n\t\tbegin\n\t\t\trd_ptr <= rd_ptr + 1'b1;\n\t\tend\n\tend assign empty_flg = (wr_ptr == rd_ptr)? 1'b1 : 1'b0; \n\tassign full_flg = ((wr_ptr + {{U_FIFO_SQ_DEPTH-1{1'b0}}, 1'b1}) == rd_ptr)? 1'b1 : 1'b0; assign dataOut = (empty_flg)? {U_FIFO_WIDTH{1'b0}} : fifo[rd_ptr]; endmodule\n",
        "module_name": "FIFO_WxD #",
        "module_hash": "07a8f6a154e08d9c2e8d631a421a394f",
        "dataset_index": 24891
      },
      "aq_div32x32_c6ebd2ff": {
        "rtl_code": "\nmodule aq_div32x32(\n\tinput\t\t\tRST_N,\n\tinput\t\t\tCLK,\n\tinput [31:0]\tDINA,\n\tinput [31:0]\tDINB,\n\toutput [31:0]\tDOUT\n);\nreg [64:0] r00r;\nreg [64:0] r01r;\nreg [64:0] r02r;\nreg [64:0] r03r;\nreg [64:0] r04r;\nreg [64:0] r05r;\nreg [64:0] r06r;\nreg [64:0] r07r;\nreg [64:0] r08r;\nreg [64:0] r09r;\nreg [64:0] r10r;\nreg [64:0] r11r;\nreg [64:0] r12r;\nreg [64:0] r13r;\nreg [64:0] r14r;\nreg [64:0] r15r;\nreg [64:0] r16r;\nreg [64:0] r17r;\nreg [64:0] r18r;\nreg [64:0] r19r;\nreg [64:0] r20r;\nreg [64:0] r21r;\nreg [64:0] r22r;\nreg [64:0] r23r;\nreg [64:0] r24r;\nreg [64:0] r25r;\nreg [64:0] r26r;\nreg [64:0] r27r;\nreg [64:0] r28r;\nreg [64:0] r29r;\nreg [64:0] r30r;\nreg [64:0] r31r;\nreg [64:0] r32r;\nreg [31:0] s00r;\nreg [31:0] s01r;\nreg [31:0] s02r;\nreg [31:0] s03r;\nreg [31:0] s04r;\nreg [31:0] s05r;\nreg [31:0] s06r;\nreg [31:0] s07r;\nreg [31:0] s08r;\nreg [31:0] s09r;\nreg [31:0] s10r;\nreg [31:0] s11r;\nreg [31:0] s12r;\nreg [31:0] s13r;\nreg [31:0] s14r;\nreg [31:0] s15r;\nreg [31:0] s16r;\nreg [31:0] s17r;\nreg [31:0] s18r;\nreg [31:0] s19r;\nreg [31:0] s20r;\nreg [31:0] s21r;\nreg [31:0] s22r;\nreg [31:0] s23r;\nreg [31:0] s24r;\nreg [31:0] s25r;\nreg [31:0] s26r;\nreg [31:0] s27r;\nreg [31:0] s28r;\nreg [31:0] s29r;\nreg [31:0] s30r;\nreg [31:0] s31r;\nalways @(negedge RST_N or posedge CLK) begin\n\tif(!RST_N) begin\n\t\tr00r <= 65'd0;\n\t\tr01r <= 65'd0;\n\t\tr02r <= 65'd0;\n\t\tr03r <= 65'd0;\n\t\tr04r <= 65'd0;\n\t\tr05r <= 65'd0;\n\t\tr06r <= 65'd0;\n\t\tr07r <= 65'd0;\n\t\tr08r <= 65'd0;\n\t\tr09r <= 65'd0;\n\t\tr10r <= 65'd0;\n\t\tr11r <= 65'd0;\n\t\tr12r <= 65'd0;\n\t\tr13r <= 65'd0;\n\t\tr14r <= 65'd0;\n\t\tr15r <= 65'd0;\n\t\tr16r <= 65'd0;\n\t\tr17r <= 65'd0;\n\t\tr18r <= 65'd0;\n\t\tr19r <= 65'd0;\n\t\tr20r <= 65'd0;\n\t\tr21r <= 65'd0;\n\t\tr22r <= 65'd0;\n\t\tr23r <= 65'd0;\n\t\tr24r <= 65'd0;\n\t\tr25r <= 65'd0;\n\t\tr26r <= 65'd0;\n\t\tr27r <= 65'd0;\n\t\tr28r <= 65'd0;\n\t\tr29r <= 65'd0;\n\t\tr30r <= 65'd0;\n\t\tr31r <= 65'd0;\n\t\tr32r <= 65'd0;\n\t\ts00r <= 32'd0;\n\t\ts01r <= 32'd0;\n\t\ts02r <= 32'd0;\n\t\ts03r <= 32'd0;\n\t\ts04r <= 32'd0;\n\t\ts05r <= 32'd0;\n\t\ts06r <= 32'd0;\n\t\ts07r <= 32'd0;\n\t\ts08r <= 32'd0;\n\t\ts09r <= 32'd0;\n\t\ts10r <= 32'd0;\n\t\ts11r <= 32'd0;\n\t\ts12r <= 32'd0;\n\t\ts13r <= 32'd0;\n\t\ts14r <= 32'd0;\n\t\ts15r <= 32'd0;\n\t\ts16r <= 32'd0;\n\t\ts17r <= 32'd0;\n\t\ts18r <= 32'd0;\n\t\ts19r <= 32'd0;\n\t\ts20r <= 32'd0;\n\t\ts21r <= 32'd0;\n\t\ts22r <= 32'd0;\n\t\ts23r <= 32'd0;\n\t\ts24r <= 32'd0;\n\t\ts25r <= 32'd0;\n\t\ts26r <= 32'd0;\n\t\ts27r <= 32'd0;\n\t\ts28r <= 32'd0;\n\t\ts29r <= 32'd0;\n\t\ts30r <= 32'd0;\n\t\ts31r <= 32'd0;\n\tend else begin\n\t\tr00r[64:0]\t<= {1'b1, 32'd0, DINA};\n\t\ts00r \t\t<= DINB;\n\n\t\tr01r[64:31]\t<= ({1'b1,r00r[63:31]}) + (~{2'b00,s00r}) + 1;\n\t\tr01r[30:0]\t<= r00r[30:0] ;\n\t\ts01r <= s00r;\n\n\t\tr02r[63:30]\t<= ({r01r[64],r01r[62:30]}) + (({34{r01r[64]}}^{2'b00,s01r}) + r01r[64]);\n\t\tr02r[64:64]\t<= r01r[64:64] ;\n\t\tr02r[29:0]\t<= r01r[29:0] ;\n\t\ts02r <= s01r;\n\n\t\tr03r[62:29]\t<= ({r02r[63],r02r[61:29]}) + (({34{r02r[63]}}^{2'b00,s02r}) + r02r[63]);\n\t\tr03r[64:63]\t<= r02r[64:63] ;\n\t\tr03r[28:0]\t<= r02r[28:0] ;\n\t\ts03r <= s02r;\n\n\t\tr04r[61:28]\t<= ({r03r[62],r03r[60:28]}) + (({34{r03r[62]}}^{2'b00,s03r}) + r03r[62]);\n\t\tr04r[64:62]\t<= r03r[64:62] ;\n\t\tr04r[27:0]\t<= r03r[27:0] ;\n\t\ts04r <= s03r;\n\n\t\tr05r[60:27]\t<= ({r04r[61],r04r[59:27]}) + (({34{r04r[61]}}^{2'b00,s04r}) + r04r[61]);\n\t\tr05r[64:61]\t<= r04r[64:61] ;\n\t\tr05r[26:0]\t<= r04r[26:0] ;\n\t\ts05r <= s04r;\n\n\t\tr06r[59:26]\t<= ({r05r[60],r05r[58:26]}) + (({34{r05r[60]}}^{2'b00,s05r}) + r05r[60]);\n\t\tr06r[64:60]\t<= r05r[64:60] ;\n\t\tr06r[25:0]\t<= r05r[25:0] ;\n\t\ts06r <= s05r;\n\n\t\tr07r[58:25]\t<= ({r06r[59],r06r[57:25]}) + (({34{r06r[59]}}^{2'b00,s06r}) + r06r[59]);\n\t\tr07r[64:59]\t<= r06r[64:59] ;\n\t\tr07r[24:0]\t<= r06r[24:0] ;\n\t\ts07r <= s06r;\n\n\t\tr08r[57:24]\t<= ({r07r[58],r07r[56:24]}) + (({34{r07r[58]}}^{2'b00,s07r}) + r07r[58]);\n\t\tr08r[64:58]\t<= r07r[64:58] ;\n\t\tr08r[23:0]\t<= r07r[23:0] ;\n\t\ts08r <= s07r;\n\n\t\tr09r[56:23]\t<= ({r08r[57],r08r[55:23]}) + (({34{r08r[57]}}^{2'b00,s08r}) + r08r[57]);\n\t\tr09r[64:57]\t<= r08r[64:57] ;\n\t\tr09r[22:0]\t<= r08r[22:0] ;\n\t\ts09r <= s08r;\n\n\t\tr10r[55:22]\t<= ({r09r[56],r09r[54:22]}) + (({34{r09r[56]}}^{2'b00,s09r}) + r09r[56]);\n\t\tr10r[64:56]\t<= r09r[64:56] ;\n\t\tr10r[21:0]\t<= r09r[21:0] ;\n\t\ts10r <= s09r;\n\n\t\tr11r[54:21]\t<= ({r10r[55],r10r[53:21]}) + (({34{r10r[55]}}^{2'b00,s10r}) + r10r[55]);\n\t\tr11r[64:55]\t<= r10r[64:55] ;\n\t\tr11r[20:0]\t<= r10r[20:0] ;\n\t\ts11r <= s10r;\n\n\t\tr12r[53:20]\t<= ({r11r[54],r11r[52:20]}) + (({34{r11r[54]}}^{2'b00,s11r}) + r11r[54]);\n\t\tr12r[64:54]\t<= r11r[64:54] ;\n\t\tr12r[19:0]\t<= r11r[19:0] ;\n\t\ts12r <= s11r;\n\n\t\tr13r[52:19]\t<= ({r12r[53],r12r[51:19]}) + (({34{r12r[53]}}^{2'b00,s12r}) + r12r[53]);\n\t\tr13r[64:53]\t<= r12r[64:53] ;\n\t\tr13r[18:0]\t<= r12r[18:0] ;\n\t\ts13r <= s12r;\n\n\t\tr14r[51:18]\t<= ({r13r[52],r13r[50:18]}) + (({34{r13r[52]}}^{2'b00,s13r}) + r13r[52]);\n\t\tr14r[64:52]\t<= r13r[64:52] ;\n\t\tr14r[17:0]\t<= r13r[17:0] ;\n\t\ts14r <= s13r;\n\n\t\tr15r[50:17]\t<= ({r14r[51],r14r[49:17]}) + (({34{r14r[51]}}^{2'b00,s14r}) + r14r[51]);\n\t\tr15r[64:51]\t<= r14r[64:51] ;\n\t\tr15r[16:0]\t<= r14r[16:0] ;\n\t\ts15r <= s14r;\n\n\t\tr16r[49:16]\t<= ({r15r[50],r15r[48:16]}) + (({34{r15r[50]}}^{2'b00,s15r}) + r15r[50]);\n\t\tr16r[64:50]\t<= r15r[64:50] ;\n\t\tr16r[15:0]\t<= r15r[15:0] ;\n\t\ts16r <= s15r;\n\n\t\tr17r[48:15]\t<= ({r16r[49],r16r[47:15]}) + (({34{r16r[49]}}^{2'b00,s16r}) + r16r[49]);\n\t\tr17r[64:49]\t<= r16r[64:49] ;\n\t\tr17r[14:0]\t<= r16r[14:0] ;\n\t\ts17r <= s16r;\n\n\t\tr18r[47:14]\t<= ({r17r[48],r17r[46:14]}) + (({34{r17r[48]}}^{2'b00,s17r}) + r17r[48]);\n\t\tr18r[64:48]\t<= r17r[64:48] ;\n\t\tr18r[13:0]\t<= r17r[13:0] ;\n\t\ts18r <= s17r;\n\n\t\tr19r[46:13]\t<= ({r18r[47],r18r[45:13]}) + (({34{r18r[47]}}^{2'b00,s18r}) + r18r[47]);\n\t\tr19r[64:47]\t<= r18r[64:47] ;\n\t\tr19r[12:0]\t<= r18r[12:0] ;\n\t\ts19r <= s18r;\n\n\t\tr20r[45:12]\t<= ({r19r[46],r19r[44:12]}) + (({34{r19r[46]}}^{2'b00,s19r}) + r19r[46]);\n\t\tr20r[64:46]\t<= r19r[64:46] ;\n\t\tr20r[11:0]\t<= r19r[11:0] ;\n\t\ts20r <= s19r;\n\n\t\tr21r[44:11]\t<= ({r20r[45],r20r[43:11]}) + (({34{r20r[45]}}^{2'b00,s20r}) + r20r[45]);\n\t\tr21r[64:45]\t<= r20r[64:45] ;\n\t\tr21r[10:0]\t<= r20r[10:0] ;\n\t\ts21r <= s20r;\n\n\t\tr22r[43:10]\t<= ({r21r[44],r21r[42:10]}) + (({34{r21r[44]}}^{2'b00,s21r}) + r21r[44]);\n\t\tr22r[64:44]\t<= r21r[64:44] ;\n\t\tr22r[9:0]\t<= r21r[9:0] ;\n\t\ts22r <= s21r;\n\n\t\tr23r[42:9]\t<= ({r22r[43],r22r[41:9]}) + (({34{r22r[43]}}^{2'b00,s22r}) + r22r[43]);\n\t\tr23r[64:43]\t<= r22r[64:43] ;\n\t\tr23r[8:0]\t<= r22r[8:0] ;\n\t\ts23r <= s22r;\n\n\t\tr24r[41:8]\t<= ({r23r[42],r23r[40:8]}) + (({34{r23r[42]}}^{2'b00,s23r}) + r23r[42]);\n\t\tr24r[64:42]\t<= r23r[64:42] ;\n\t\tr24r[7:0]\t<= r23r[7:0] ;\n\t\ts24r <= s23r;\n\n\t\tr25r[40:7]\t<= ({r24r[41],r24r[39:7]}) + (({34{r24r[41]}}^{2'b00,s24r}) + r24r[41]);\n\t\tr25r[64:41]\t<= r24r[64:41] ;\n\t\tr25r[6:0]\t<= r24r[6:0] ;\n\t\ts25r <= s24r;\n\n\t\tr26r[39:6]\t<= ({r25r[40],r25r[38:6]}) + (({34{r25r[40]}}^{2'b00,s25r}) + r25r[40]);\n\t\tr26r[64:40]\t<= r25r[64:40] ;\n\t\tr26r[5:0]\t<= r25r[5:0] ;\n\t\ts26r <= s25r;\n\n\t\tr27r[38:5]\t<= ({r26r[39],r26r[37:5]}) + (({34{r26r[39]}}^{2'b00,s26r}) + r26r[39]);\n\t\tr27r[64:39]\t<= r26r[64:39] ;\n\t\tr27r[4:0]\t<= r26r[4:0] ;\n\t\ts27r <= s26r;\n\n\t\tr28r[37:4]\t<= ({r27r[38],r27r[36:4]}) + (({34{r27r[38]}}^{2'b00,s27r}) + r27r[38]);\n\t\tr28r[64:38]\t<= r27r[64:38] ;\n\t\tr28r[3:0]\t<= r27r[3:0] ;\n\t\ts28r <= s27r;\n\n\t\tr29r[36:3]\t<= ({r28r[37],r28r[35:3]}) + (({34{r28r[37]}}^{2'b00,s28r}) + r28r[37]);\n\t\tr29r[64:37]\t<= r28r[64:37] ;\n\t\tr29r[2:0]\t<= r28r[2:0] ;\n\t\ts29r <= s28r;\n\n\t\tr30r[35:2]\t<= ({r29r[36],r29r[34:2]}) + (({34{r29r[36]}}^{2'b00,s29r}) + r29r[36]);\n\t\tr30r[64:36]\t<= r29r[64:36] ;\n\t\tr30r[1:0]\t<= r29r[1:0] ;\n\t\ts30r <= s29r;\n\n\t\tr31r[34:1]\t<= ({r30r[35],r30r[33:1]}) + (({34{r30r[35]}}^{2'b00,s30r}) + r30r[35]);\n\t\tr31r[64:35]\t<= r30r[64:35] ;\n\t\tr31r[0:0]\t<= r30r[0:0] ;\n\t\ts31r <= s30r;\n\n\t\tr32r[33:0]\t<= ({r31r[34],r31r[32:0]}) + (({34{r31r[34]}}^{2'b00,s31r}) + r31r[34]);\n\t\tr32r[64:34]\t<= r31r[64:34] ;\n\n\tend\nend\nassign DOUT = r32r[64:33];\nendmodule\n",
        "module_name": "aq_div32x32",
        "module_hash": "c6ebd2ff9f8b162f744e33c8ff918f46",
        "dataset_index": 21659
      },
      "decoder_3to8_60333da6": {
        "rtl_code": "module decoder_3to8 (\n    input [2:0] in,\n    output [7:0] out\n);\n\nassign out = 8'b00000001 << in;\n\nendmodule",
        "module_name": "decoder_3to8",
        "module_hash": "60333da61ca4945c2ca955eeae5c9ba0",
        "dataset_index": 9070
      },
      "tawas_rcn_master_7f70684c": {
        "rtl_code": "\n\n\n\n\nmodule tawas_rcn_master\n(\n    input rst,\n    input clk,\n\n    input [68:0] rcn_in,\n    output [68:0] rcn_out,\n\n    input cs,\n    input [4:0] seq,\n    output busy,\n    input wr,\n    input [3:0] mask,\n    input [23:0] addr,\n    input [31:0] wdata,\n\n    output rdone,\n    output wdone,\n    output [4:0] rsp_seq,\n    output [3:0] rsp_mask,\n    output [23:0] rsp_addr,\n    output [31:0] rsp_data\n);\n    parameter MASTER_GROUP_8 = 0;\n    \n    reg [68:0] rin;\n    reg [68:0] rout;\n\n    assign rcn_out = rout;\n\n    wire [2:0] my_id = MASTER_GROUP_8;\n\n    wire my_resp = rin[68] && !rin[67] && (rin[65:63] == MASTER_GROUP_8);\n\n    wire req_valid;\n    wire [68:0] req;\n\n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rout <= 69'd0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rout <= (req_valid) ? req : (my_resp) ? 69'd0 : rin;\n        end\n\n    assign busy = rin[68] && !my_resp;\n    assign req_valid = cs && !(rin[68] && !my_resp);\n    assign req = {1'b1, 1'b1, wr, my_id, seq[4:2], mask, addr[23:2], seq[1:0], wdata};\n\n    assign rdone = my_resp && !rin[66];\n    assign wdone = my_resp && rin[66];\n    assign rsp_seq = {rin[62:60], rin[33:32]};\n    assign rsp_mask = rin[59:56];\n    assign rsp_addr = {rin[55:34], 2'd0};\n    assign rsp_data = rin[31:0];\n\nendmodule\n",
        "module_name": "tawas_rcn_master",
        "module_hash": "7f70684c2143193ec59fa671a9d18214",
        "dataset_index": 15344
      },
      "VGACtrl_58d19b05": {
        "rtl_code": "module VGACtrl(\n    input clk,\n    input reset,\n    output reg vga_h_sync,\n    output reg vga_v_sync,\n    output reg inDisplayArea,\n    output reg [9:0] CounterX,\n    output reg [9:0] CounterY\n);\n\n    // Constants for VGA timing\n    parameter H_SYNC_PERIOD = 96;\n    parameter H_SYNC_PULSE_WIDTH = 16;\n    parameter V_SYNC_PERIOD = 8000;\n    parameter V_SYNC_PULSE_WIDTH = 2;\n    parameter DISPLAY_WIDTH = 640;\n    parameter DISPLAY_HEIGHT = 480;\n\n    // Internal signals\n    reg [9:0] h_counter;\n    reg [9:0] v_counter;\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            // Reset counters and signals\n            h_counter <= 0;\n            v_counter <= 0;\n            vga_h_sync <= 0;\n            vga_v_sync <= 0;\n            inDisplayArea <= 0;\n            CounterX <= 0;\n            CounterY <= 0;\n        end else begin\n            // Update horizontal counter\n            if (h_counter == DISPLAY_WIDTH - 1) begin\n                h_counter <= 0;\n                CounterX <= h_counter;\n            end else begin\n                h_counter <= h_counter + 1;\n                CounterX <= h_counter;\n            end\n\n            // Update vertical counter\n            if (v_counter == DISPLAY_HEIGHT - 1) begin\n                v_counter <= 0;\n                CounterY <= v_counter;\n            end else begin\n                v_counter <= v_counter + 1;\n                CounterY <= v_counter;\n            end\n\n            // Update sync signals\n            if (h_counter >= DISPLAY_WIDTH - H_SYNC_PULSE_WIDTH) begin\n                vga_h_sync <= 1;\n            end else begin\n                vga_h_sync <= 0;\n            end\n\n            if (v_counter >= DISPLAY_HEIGHT - V_SYNC_PULSE_WIDTH) begin\n                vga_v_sync <= 1;\n            end else begin\n                vga_v_sync <= 0;\n            end\n\n            // Update display area signal\n            if (h_counter < DISPLAY_WIDTH && v_counter < DISPLAY_HEIGHT) begin\n                inDisplayArea <= 1;\n            end else begin\n                inDisplayArea <= 0;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "VGACtrl",
        "module_hash": "58d19b0558bba675c5260aa5e591c3dd",
        "dataset_index": 17017
      },
      "encryption_system_71c6304e": {
        "rtl_code": "module encryption_system (\n  input clk,\n  input reset,\n  input [3:0] data_in,\n  output reg [3:0] encrypted_data\n);\n\n  reg [3:0] key = 4'b1010; // Fixed key value\n  \n  reg [3:0] adder_out; // Output of the ripple carry adder\n  reg [3:0] shift_reg; // Shift register\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      adder_out <= 4'b0;\n      shift_reg <= 4'b0;\n      encrypted_data <= 4'b0;\n    end else begin\n      // Add input data and key using ripple carry adder\n      adder_out <= data_in + key;\n      \n      // Shift the output of the adder left by one bit\n      shift_reg <= {adder_out[2:0], 1'b0};\n      \n      // Output the shifted data as encrypted data\n      encrypted_data <= shift_reg;\n    end\n  end\n  \nendmodule",
        "module_name": "encryption_system",
        "module_hash": "71c6304ef408fac144c04d1da1aa2ba4",
        "dataset_index": 16140
      },
      "clock_gate_6b0da1e7": {
        "rtl_code": "module clock_gate(input CLK, input EN, input TE, output reg ENCLK);\n\nalways @(posedge CLK) begin\n    if (EN == 1'b1) begin\n        ENCLK <= 1'b0;\n    end else begin\n        ENCLK <= CLK;\n    end\nend\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "6b0da1e7dec09f3b45feb99876c530a7",
        "dataset_index": 15316
      },
      "adder_4bit_fd7dffdd": {
        "rtl_code": "module adder_4bit (\n    input [3:0] A, B,\n    output [3:0] S,\n    output C_out\n);\n\n    wire [3:0] sum; \n    wire [3:0] carry; \n    \n    // First Full Adder\n    full_adder FA1(A[0], B[0], 1'b0, sum[0], carry[0]);\n    \n    // Second Full Adder\n    full_adder FA2(A[1], B[1], carry[0], sum[1], carry[1]);\n    \n    // Third Full Adder\n    full_adder FA3(A[2], B[2], carry[1], sum[2], carry[2]);\n    \n    // Fourth Full Adder\n    full_adder FA4(A[3], B[3], carry[2], sum[3], C_out);\n    \n    assign S = sum;\n    \nendmodule\n\nmodule full_adder (\n    input A, B, Cin,\n    output S, Cout\n);\n\n    assign {Cout, S} = A + B + Cin;\n    \nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "fd7dffddf2b79c90bea6815c75759a52",
        "dataset_index": 10658
      },
      "o311ai_b80eddec": {
        "rtl_code": "module o311ai (\n  input A1,\n  input A2,\n  input A3,\n  input B1,\n  input C1,\n  output Y\n);\n\n  wire n1, n2, n3;\n\n  and and_gate1(n1, A1, B1);  // AND gate combining A1 and B1\n  or  or_gate1(n2, A2, n1);   // OR gate combining A2 and the result of the first AND gate\n  not not_gate1(n3, A3);      // NOT gate inverting A3\n  and and_gate2(Y, n2, n3, C1); // Final AND gate combining the results of the above gates and C1\n\nendmodule\n",
        "module_name": "o311ai",
        "module_hash": "b80eddec5cbbe8a787e009d1acb61807",
        "dataset_index": 20914
      },
      "invert_msb_cc22239b": {
        "rtl_code": "module invert_msb(\n    input [3:0] i_binary,\n    output reg [3:0] o_inverted\n    );\n\n    always @(*) begin\n        o_inverted = {~i_binary[3], i_binary[2:0]};\n    end\n\nendmodule",
        "module_name": "invert_msb",
        "module_hash": "cc22239ba1c7e640945a7d78fdab0dcf",
        "dataset_index": 14903
      },
      "GrayCodeStateMachine_0ccc782d": {
        "rtl_code": "module GrayCodeStateMachine (\n  input clk,\n  output reg [n-1:0] state\n);\n\nparameter n = 4; // number of state signals\n\n// Define the Gray code sequence as a set of Boolean functions\nfunction [n-1:0] grayCode;\n  input [n-1:0] binaryCode;\n  begin\n    grayCode = binaryCode ^ (binaryCode >> 1);\n  end\nendfunction\n\n// Define the initial state\nreg [n-1:0] currentState = 0;\n\n// Connect the state signals to the Gray code sequence\nalways @* begin\n  state = grayCode(currentState);\nend\n\n// Transition to the next state on each clock cycle\nalways @(posedge clk) begin\n  currentState <= currentState + 1;\nend\n\nendmodule",
        "module_name": "GrayCodeStateMachine",
        "module_hash": "0ccc782d1451f78c62d612e194b5e583",
        "dataset_index": 11133
      },
      "gray_code_conversion_7b815233": {
        "rtl_code": "module gray_code_conversion (\n  input [3:0] bin_input,\n  output reg [1:0] gray_output,\n  output reg valid\n);\n\n  always @* begin\n    case (bin_input)\n      4'b0000: gray_output = 2'b00;\n      4'b0001: gray_output = 2'b01;\n      4'b0010: gray_output = 2'b11;\n      4'b0011: gray_output = 2'b10;\n      4'b0100: gray_output = 2'b11;\n      4'b0101: gray_output = 2'b10;\n      4'b0110: gray_output = 2'b00;\n      4'b0111: gray_output = 2'b01;\n      4'b1000: gray_output = 2'b10;\n      4'b1001: gray_output = 2'b11;\n      4'b1010: gray_output = 2'b01;\n      4'b1011: gray_output = 2'b00;\n      4'b1100: gray_output = 2'b01;\n      4'b1101: gray_output = 2'b00;\n      4'b1110: gray_output = 2'b10;\n      4'b1111: gray_output = 2'b11;\n      default: gray_output = 2'b00;\n    endcase;\n  end\n\n  always @* begin\n    valid = (bin_input == 4'b0000 || bin_input == 4'b0001 || bin_input == 4'b0011 || bin_input == 4'b0111 || bin_input == 4'b1111);\n  end\n\nendmodule",
        "module_name": "gray_code_conversion",
        "module_hash": "7b81523325593d7f32447bc90e25305c",
        "dataset_index": 3977
      },
      "ewrapper_link_txo_d49efa59": {
        "rtl_code": "\nmodule ewrapper_link_txo(\n   txo_emesh_wait, tx_in,\n   reset, txo_lclk, txo_emesh_access, txo_emesh_write,\n   txo_emesh_datamode, txo_emesh_ctrlmode, txo_emesh_dstaddr,\n   txo_emesh_srcaddr, txo_emesh_data, burst_en\n   );\n\n   input          reset;     input \t  txo_lclk;  input \t  txo_emesh_access;\n   input \t  txo_emesh_write;\n   input [1:0] \t  txo_emesh_datamode;\n   input [3:0] \t  txo_emesh_ctrlmode;\n   input [31:0]   txo_emesh_dstaddr;\n   input [31:0]   txo_emesh_srcaddr;\n   input [31:0]   txo_emesh_data;   \n\n   input \t  burst_en; output \t  txo_emesh_wait;\n\n   output [71:0]  tx_in;\n   \n   \n   \n\n   reg \t\t  shadow_access;\n   reg \t\t  shadow_write;\n   reg [1:0] \t  shadow_datamode;\n   reg [3:0] \t  shadow_ctrlmode;\n   reg [31:0] \t  shadow_dstaddr;\n   reg [31:0] \t  shadow_srcaddr;\n   reg [31:0] \t  shadow_data;\n\n   reg \t\t  cycle1_access;\n   reg \t\t  cycle1_write;\n   reg [1:0] \t  cycle1_datamode;\n   reg [3:0] \t  cycle1_ctrlmode;\n   reg [31:0] \t  cycle1_dstaddr;\n   reg [31:0] \t  cycle1_srcaddr;\n   reg [31:0] \t  cycle1_data;\n\n   reg \t\t  cycle2_access;\n   reg [31:0] \t  cycle2_dstaddr;\n   reg [31:0] \t  cycle2_srcaddr;\n   reg [31:0] \t  cycle2_data;   \n\n   reg \t\t  cycle2_dbl; \n   reg [31:0] \t  cycle2_dstaddr_inc8;\n\n   reg \t\t  byte0_inc0;\n   reg \t\t  txo_emesh_wait;\n   reg [71:0] \t  tx_in;\n\n   reg \t\t  cycle1_frame_bit_del;\n   reg \t\t  inc0_match_del;\n\n   wire \t  emesh_access;\n   wire \t  emesh_write;\n   wire [1:0] \t  emesh_datamode;\n   wire [3:0] \t  emesh_ctrlmode;\n   wire [31:0] \t  emesh_dstaddr;\n   wire [31:0] \t  emesh_srcaddr;\n   wire [31:0] \t  emesh_data;   \n\n   wire \t  cycle1_dbl; wire [31:0] \t  cycle1_dstaddr_inc8; \n   wire \t  inc8_match;\n   wire \t  inc0_match;\n   wire \t  burst_tran;\n   wire \t  emesh_wait;\n\n   wire \t  cycle1_frame_bit;\n   wire \t  cycle2_frame_bit;\n   wire [7:0] \t  cycle1_frame;\n   wire [7:0] \t  cycle2_frame;\n   wire [7:0] \t  txo_frame_int;\n   wire [7:0] \t  tran_byte0;\n   wire [63:0] \t  cycle1_data_long;\n   wire [63:0] \t  cycle2_data_long;\n   wire [63:0] \t  data_long;\n\n   wire [7:0] \t  channel0;\n   wire [7:0] \t  channel1;\n   wire [7:0] \t  channel2;\n   wire [7:0] \t  channel3;\n   wire [7:0] \t  channel4;\n   wire [7:0] \t  channel5;\n   wire [7:0] \t  channel6;\n   wire [7:0] \t  channel7;\n\n   wire [71:0] \t  txo_data_int;\n   \n   always @ (posedge txo_lclk or posedge reset)\n     if (reset)\n       shadow_access <= 1'b0;\n     else if(~txo_emesh_wait)\n       shadow_access <= txo_emesh_access;\n\n   always @ (posedge txo_lclk)\n     if (~txo_emesh_wait)\n       begin\n\t  shadow_write         <= txo_emesh_write;            \n\t  shadow_datamode[1:0] <= txo_emesh_datamode[1:0];    \n\t  shadow_ctrlmode[3:0] <= txo_emesh_ctrlmode[3:0];    \n\t  shadow_dstaddr[31:0] <= txo_emesh_dstaddr[31:0];   \n\t  shadow_srcaddr[31:0] <= txo_emesh_srcaddr[31:0];   \n\t  shadow_data[31:0]    <= txo_emesh_data[31:0];\n       end\n\n   assign emesh_access = txo_emesh_wait ? shadow_access : txo_emesh_access;\n   assign emesh_write  = txo_emesh_wait ? shadow_write  : txo_emesh_write;\n\n   assign emesh_datamode[1:0] = txo_emesh_wait ? shadow_datamode[1:0] :\n\t\t\t\t                 txo_emesh_datamode[1:0];\n\n   assign emesh_ctrlmode[3:0] = txo_emesh_wait ? shadow_ctrlmode[3:0] :\n\t\t\t\t                 txo_emesh_ctrlmode[3:0];\n\n   assign emesh_dstaddr[31:0] = txo_emesh_wait ? shadow_dstaddr[31:0] :\n\t\t\t\t                 txo_emesh_dstaddr[31:0];\n\n   assign emesh_srcaddr[31:0] = txo_emesh_wait ? shadow_srcaddr[31:0] :\n\t\t\t\t                 txo_emesh_srcaddr[31:0];\n\n   assign emesh_data[31:0] = txo_emesh_wait ? shadow_data[31:0] :\n\t\t\t                      txo_emesh_data[31:0];\n\n   assign emesh_wait = cycle1_access & cycle2_access & ~burst_tran;\n\n   always @ (posedge txo_lclk or posedge reset)\n     if (reset)\n       txo_emesh_wait <= 1'b0;\n     else\n       txo_emesh_wait <= emesh_wait;\n\n   always @ (posedge txo_lclk or posedge reset)\n     if (reset)\n       cycle1_access <= 1'b0;\n     else if(~emesh_wait)\n       cycle1_access <= emesh_access;\n\n   always @ (posedge txo_lclk)\n     if (~emesh_wait)\n       begin\n\t  cycle1_write         <= emesh_write;            \n\t  cycle1_datamode[1:0] <= emesh_datamode[1:0];    \n\t  cycle1_ctrlmode[3:0] <= emesh_ctrlmode[3:0];    \n\t  cycle1_dstaddr[31:0] <= emesh_dstaddr[31:0];   \n\t  cycle1_srcaddr[31:0] <= emesh_srcaddr[31:0];   \n\t  cycle1_data[31:0]    <= emesh_data[31:0];\n       end\n\n   always @ (posedge txo_lclk or posedge reset)\n     if (reset)\n       cycle2_access <= 1'b0;\n     else if(emesh_wait)\n       cycle2_access <= 1'b0;\n     else\n       cycle2_access <= cycle1_access;\n   \n   always @ (posedge txo_lclk)\n     begin\n\tcycle2_dstaddr[31:0]      <= cycle1_dstaddr[31:0];   \n\tcycle2_srcaddr[31:0]      <= cycle1_srcaddr[31:0];   \n\tcycle2_data[31:0]         <= cycle1_data[31:0];\n\tcycle2_dbl                <= cycle1_dbl;\n\tcycle2_dstaddr_inc8[31:0] <= cycle1_dstaddr_inc8[31:0];\n     end\n   \n   always @ (posedge txo_lclk or posedge reset)\n     if(reset)\n       begin\n\t  cycle1_frame_bit_del <= 1'b0;\n\t  inc0_match_del       <= 1'b0;\n       end\n     else\n       begin\n\t  cycle1_frame_bit_del <= cycle1_frame_bit;\n\t  inc0_match_del       <= inc0_match;\n       end\n\n   always @ (posedge txo_lclk or posedge reset)\n     if(reset)\n       byte0_inc0     <= 1'b0;\n     else if(cycle1_frame_bit_del)\n       byte0_inc0     <= inc0_match_del;\n\n   assign cycle1_dbl = cycle1_access & cycle1_write & (&(cycle1_datamode[1:0]));\n   \n   assign cycle1_dstaddr_inc8[31:0] = cycle1_dstaddr[31:0] + \n\t\t\t\t      {{(28){1'b0}},4'b1000};\n\n   assign inc8_match = cycle1_dbl & cycle2_dbl & \n\t\t       (cycle1_dstaddr[31:0] == cycle2_dstaddr_inc8[31:0]);\n   assign inc0_match = cycle1_dbl & cycle2_dbl &\n\t\t       (cycle1_dstaddr[31:0] == cycle2_dstaddr[31:0]);\n\n   assign burst_tran = burst_en &\n\t\t       cycle1_dbl & cycle2_dbl &\n\t\t       ((inc8_match  & ~byte0_inc0) |  (inc0_match  &  byte0_inc0));\n\n   assign tran_byte0[7:0] = {~cycle1_write,4'b0000,byte0_inc0,2'b00};\n\n   assign cycle1_frame_bit  = cycle1_access & ~cycle2_access;\n   assign cycle2_frame_bit  = cycle2_access;\n   assign cycle1_frame[7:0] = {2'b00,{(6){cycle1_frame_bit}}};\n   assign cycle2_frame[7:0] =        {(8){cycle2_frame_bit}};\n\n   assign txo_frame_int[7:0] = cycle1_frame[7:0] | cycle2_frame[7:0];\n\n   assign cycle1_data_long[63:0] = {{(8){1'b0}},\n                                    {(8){1'b0}},\n                                    tran_byte0[7:0],\n                                    cycle1_ctrlmode[3:0],cycle1_dstaddr[31:28],\n                                    cycle1_dstaddr[27:20],\n                                    cycle1_dstaddr[19:12],\n                                    cycle1_dstaddr[11:4],\n\t  cycle1_dstaddr[3:0],cycle1_datamode[1:0],cycle1_write,cycle1_access};\n\n   assign cycle2_data_long[63:0] = {cycle2_data[31:0],cycle2_srcaddr[31:0]};\n\n   assign data_long[63:0] = cycle2_access ? cycle2_data_long[63:0] :\n\t\t\t                    cycle1_data_long[63:0];\n\n   assign channel0[7:0] = {data_long[56],data_long[48], \n\t\t\t   data_long[40],data_long[32], \n\t\t\t   data_long[24],data_long[16], \n\t\t\t   data_long[8], data_long[0]\n\t\t\t   };\n   \n   assign channel1[7:0] = {data_long[57],data_long[49], \n\t\t\t   data_long[41],data_long[33], \n\t\t\t   data_long[25],data_long[17], \n\t\t\t   data_long[9], data_long[1]\n\t\t\t   };\n   \n   assign channel2[7:0] = {data_long[58],data_long[50], \n\t\t\t   data_long[42],data_long[34], \n\t\t\t   data_long[26],data_long[18], \n\t\t\t   data_long[10],data_long[2]\n\t\t\t   };\n   \n   assign channel3[7:0] = {data_long[59],data_long[51], \n\t\t\t   data_long[43],data_long[35], \n\t\t\t   data_long[27],data_long[19], \n\t\t\t   data_long[11],data_long[3]\n\t\t\t   };\n   \n   assign channel4[7:0] = {data_long[60],data_long[52], \n\t\t\t   data_long[44],data_long[36], \n\t\t\t   data_long[28],data_long[20], \n\t\t\t   data_long[12],data_long[4]\n\t\t\t   };\n   \n   assign channel5[7:0] = {data_long[61],data_long[53], \n\t\t\t   data_long[45],data_long[37], \n\t\t\t   data_long[29],data_long[21], \n\t\t\t   data_long[13],data_long[5]\n\t\t\t   };\n   \n   assign channel6[7:0] = {data_long[62],data_long[54], \n\t\t\t   data_long[46],data_long[38], \n\t\t\t   data_long[30],data_long[22], \n\t\t\t   data_long[14],data_long[6]\n\t\t\t   };\n   \n   assign channel7[7:0] = {data_long[63],data_long[55], \n\t\t\t   data_long[47],data_long[39], \n\t\t\t   data_long[31],data_long[23], \n\t\t\t   data_long[15],data_long[7]\n\t\t\t   };\n\n   assign txo_data_int[71:0] =\n\t\t      {txo_frame_int[7:0],\n\t\t       channel7[7:0],channel6[7:0],channel5[7:0],channel4[7:0],\n\t\t       channel3[7:0],channel2[7:0],channel1[7:0],channel0[7:0]};\n\n\n   always @ (posedge txo_lclk or posedge reset)\n     if (reset)\n       tx_in[71:0] <= {(72){1'b0}};\n     else\n       tx_in[71:0] <= txo_data_int[71:0];\n\nendmodule ",
        "module_name": "ewrapper_link_txo",
        "module_hash": "d49efa59f5166b4fa39f6b82e551b635",
        "dataset_index": 18496
      },
      "binary_adder_0db2928d": {
        "rtl_code": "module binary_adder (\n    input a, b, // 2 input bits for the binary numbers\n    input carry_in, // Carry-in input for the half adder\n    output sum, // Output for the sum of the two bits\n    output carry_out // Output for the carry-out of the half adder\n);\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (carry_in & (a ^ b));\n\nendmodule\n\nmodule top_module (\n    input a1, b1, a2, b2, // 4 input bits for the two binary numbers\n    input select, // Select input to choose between carry-out of first half adder and second half adder\n    output [1:0] sum // 2-bit output for the sum of the two binary numbers\n);\n\n    wire carry1, carry2;\n    wire sum1, sum2;\n\n    binary_adder adder1(a1, b1, 1'b0, sum1, carry1);\n    binary_adder adder2(a2, b2, 1'b0, sum2, carry2);\n\n    assign sum = {select ? carry2 : carry1, sum1} + sum2;\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "0db2928d46f7b6b4a4af1426995b1f4c",
        "dataset_index": 19947
      },
      "Arithmetic_Logic_Unit_5df88581": {
        "rtl_code": "\nmodule Arithmetic_Logic_Unit (\n    input [4:0] ctrl,\n    input [15:0] data_in_A,\n    input [15:0] data_in_B,\n    output [15:0] data_out\n);\n\n// Internal register to store the result\nreg [15:0] data_out_reg;\n\n// Combinational logic to perform the operations\nalways @(*) begin\n    case (ctrl)\n        1: data_out_reg = data_in_A + data_in_B;\n        2: data_out_reg = data_in_A - data_in_B;\n        3: data_out_reg = data_in_A * data_in_B;\n        4: data_out_reg = data_in_A / data_in_B;\n        5: data_out_reg = data_in_A & data_in_B;\n        6: data_out_reg = data_in_A | data_in_B;\n        7: data_out_reg = data_in_A ^ data_in_B;\n        8: data_out_reg = ~data_in_A;\n        9: data_out_reg = data_in_A << data_in_B[3:0];\n        10: data_out_reg = data_in_A >> data_in_B[3:0];\n        11: data_out_reg = data_in_A <<< data_in_B[3:0];\n        12: data_out_reg = data_in_A >>> data_in_B[3:0];\n        default: data_out_reg = 16'b0; // Default to 0 for invalid operations\n    endcase\nend\n\n// Output assignment\nassign data_out = data_out_reg;\n\nendmodule",
        "module_name": "Arithmetic_Logic_Unit",
        "module_hash": "5df8858191fd2fdc282f220e9b008db2",
        "dataset_index": 8317
      },
      "synchronous_counter_d75effd7": {
        "rtl_code": "module synchronous_counter(\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else if (enable) begin\n            if (count_out == 4'b1001) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "synchronous_counter",
        "module_hash": "d75effd7767b11ad97fc454388d058a9",
        "dataset_index": 8992
      },
      "simple_counter_dfe343d6": {
        "rtl_code": "module simple_counter(\n    input clk,\n    input reset,\n    output reg [7:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 8'h00;\n    end else begin\n        if (count == 8'hFF) begin\n            count <= 8'h00;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "simple_counter",
        "module_hash": "dfe343d6d3f282377f7ae63f89bfff25",
        "dataset_index": 5274
      },
      "sky130_fd_sc_hd__or4_1abb73a6": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__or4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out_X;\n\n    or  or0  (or0_out_X, D, C, B, A     );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__or4",
        "module_hash": "1abb73a6e4d3672f66f1b5b8f546a1c0",
        "dataset_index": 17681
      },
      "four_bit_adder_e45de194": {
        "rtl_code": "module four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] C;\n\n  assign S = A + B;\n  assign C = {A[3], B[3], S[3]};\n\n  assign Cout = (C[2] & ~C[1]) | (~C[2] & C[0]);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "e45de194c4c5ec23080730a93523d350",
        "dataset_index": 5251
      },
      "ADCinterface_10cd5f0f": {
        "rtl_code": "\nmodule ADCinterface(\n\t\tinput reset_n,\n\t\tinput clk,\t\t\toutput CS_n,\n\t\toutput RD_n,\n\t\toutput reg WR_n\n\t);\n\t\t\t\n\treg [7:0]count;\n\t\n\tassign CS_n = 0;\t\t\tassign RD_n = 0;\t\t\talways @ (posedge clk, negedge reset_n)\t\t\t\n\t\tbegin\n\t\t\tcount <= count + 1;\t\t\t\t\t\t\t\t\n\t\t\tif(!reset_n)\n\t\t\t\tbegin\n\t\t\t\t\tWR_n <= 0;\t\tcount <= 0;\t\t\t\t\t\t\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif(count == 20)\t\t\t\t\tWR_n <= ~WR_n;\t\n\t\t\t\telse if(count == 200)\t\t\tbegin\n\t\t\t\t\t\tWR_n <= ~WR_n;\n\t\t\t\t\t\tcount <= 0;\t\n\t\t\t\t\tend\n\n\t\tend\n\t\t\nendmodule",
        "module_name": "ADCinterface",
        "module_hash": "10cd5f0f91667de3bb23b0ba6d09d6a7",
        "dataset_index": 24223
      },
      "axis_phase_generator #_3bfcede5": {
        "rtl_code": "\n\nmodule axis_phase_generator #\n(\n  parameter integer AXIS_TDATA_WIDTH = 32,\n  parameter integer PHASE_WIDTH = 30\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n\n  input  wire [PHASE_WIDTH-1:0]      cfg_data,\n\n  input  wire                        m_axis_tready,\n  output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,\n  output wire                        m_axis_tvalid\n);\n\n  reg [PHASE_WIDTH-1:0] int_cntr_reg, int_cntr_next;\n  reg int_enbl_reg, int_enbl_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_cntr_reg <= {(PHASE_WIDTH){1'b0}};\n      int_enbl_reg <= 1'b0;\n    end\n    else\n    begin\n      int_cntr_reg <= int_cntr_next;\n      int_enbl_reg <= int_enbl_next;\n    end\n  end\n\n  always @*\n  begin\n    int_cntr_next = int_cntr_reg;\n    int_enbl_next = int_enbl_reg;\n\n    if(~int_enbl_reg)\n    begin\n      int_enbl_next = 1'b1;\n    end\n\n    if(int_enbl_reg & m_axis_tready)\n    begin\n      int_cntr_next = int_cntr_reg + cfg_data;\n    end\n  end\n\n  assign m_axis_tdata = {{(AXIS_TDATA_WIDTH-PHASE_WIDTH){int_cntr_reg[PHASE_WIDTH-1]}}, int_cntr_reg};\n  assign m_axis_tvalid = int_enbl_reg;\n\nendmodule\n",
        "module_name": "axis_phase_generator #",
        "module_hash": "3bfcede56567f3261da329328bdda54c",
        "dataset_index": 24623
      },
      "traffic_light_controller_ab865589": {
        "rtl_code": "module traffic_light_controller(\n  input clk,\n  output reg [2:0] traffic_light\n);\n\n  parameter GREEN = 3'b001;\n  parameter YELLOW = 3'b010;\n  parameter RED = 3'b100;\n  \n  reg [3:0] state;\n  reg [3:0] count;\n\n  always @(posedge clk) begin\n    case(state)\n      GREEN: begin\n        traffic_light <= GREEN;\n        if (count == 10) \n          state <= YELLOW;\n        else\n          count <= count + 1;\n      end\n      YELLOW: begin\n        traffic_light <= YELLOW;\n        if (count == 2) \n          state <= RED;\n        else\n          count <= count + 1;\n      end\n      RED: begin\n        traffic_light <= RED;\n        if (count == 10) \n          state <= GREEN;\n        else\n          count <= count + 1;\n      end\n      default: state <= GREEN;\n    endcase\n  end\n  \n  \nendmodule\n",
        "module_name": "traffic_light_controller",
        "module_hash": "ab8655890f181eca3057a56a8c7e8d7b",
        "dataset_index": 2510
      },
      "sky130_fd_sc_ls__dlrbp_a2bc8489": {
        "rtl_code": "\nmodule sky130_fd_sc_ls__dlrbp (\n    input RESET_B,\n    input D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output Q,\n    output Q_N,\n    input GATE\n);\n\n    wire D_N;\n    wire Q_PRE;\n    \n\n    assign D_N = ~D;\n\n    nand (Q_PRE, D_N, RESET_B, GATE);\n    nand (Q_N, D, RESET_B, GATE);\n\n    assign Q = Q_PRE;\n   \n\nendmodule",
        "module_name": "sky130_fd_sc_ls__dlrbp",
        "module_hash": "a2bc8489570bc42efd018de9c16485d1",
        "dataset_index": 9807
      },
      "counter_ed0e9bb0": {
        "rtl_code": "module counter (\n    input clk,\n    input rst,\n    output reg [3:0] out\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        out <= 4'b0;\n    end else begin\n        out <= out + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "ed0e9bb04b5da19a05d547a91f8daf4f",
        "dataset_index": 3267
      },
      "clock_generator_3033d5f3": {
        "rtl_code": "\nmodule clock_generator (\n    input clk,\n    output reg genclk\n);\n\n    reg [7:0] cyc;\n    initial cyc = 0;\n    wire genthiscyc = ( (cyc % 2) == 1 );\n    \n    always @ (posedge clk) begin\n        cyc <= cyc + 8'h1;\n        if (cyc < 8'h80) genclk <= genthiscyc;\n        if (cyc >= 8'h80) genclk <= ~genclk;\n    end\n    \nendmodule",
        "module_name": "clock_generator",
        "module_hash": "3033d5f33a5bbf38c77165f6b1820dfa",
        "dataset_index": 4602
      },
      "robotic_arm_controller_edd23895": {
        "rtl_code": "module robotic_arm_controller(\n    input [7:0] servo1_angle,\n    input [7:0] servo2_angle,\n    input [7:0] servo3_angle,\n    input [7:0] servo4_angle,\n    input [7:0] servo5_angle,\n    output reg [11:0] servo1_pwm,\n    output reg [11:0] servo2_pwm,\n    output reg [11:0] servo3_pwm,\n    output reg [11:0] servo4_pwm,\n    output reg [11:0] servo5_pwm\n);\n\n    always @(*) begin\n        servo1_pwm = (servo1_angle * 11) + 500;\n        servo2_pwm = (servo2_angle * 11) + 500;\n        servo3_pwm = (servo3_angle * 11) + 500;\n        servo4_pwm = (servo4_angle * 11) + 500;\n        servo5_pwm = (servo5_angle * 11) + 500;\n    end\n\nendmodule",
        "module_name": "robotic_arm_controller",
        "module_hash": "edd238951b7d7fad8dfaf694abd16da4",
        "dataset_index": 2834
      },
      "full_adder_7b239631": {
        "rtl_code": "module full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (B & Cin) | (A & Cin);\nendmodule\n\nmodule add4_carry(A, B, Cin, Sum, Cout);\n    input [3:0] A, B;\n    input Cin;\n    output [3:0] Sum;\n    output Cout;\n\n    wire [3:0] S;\n    wire C1, C2, C3;\n\n    full_adder FA1(A[0], B[0], Cin, S[0], C1);\n    full_adder FA2(A[1], B[1], C1, S[1], C2);\n    full_adder FA3(A[2], B[2], C2, S[2], C3);\n    full_adder FA4(A[3], B[3], C3, S[3], Cout);\n\n    assign Sum = S;\nendmodule",
        "module_name": "full_adder",
        "module_hash": "7b23963192e32410b8904906b69cf70e",
        "dataset_index": 9184
      },
      "add_sub_17a9ad7d": {
        "rtl_code": "module add_sub (\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] sum,\n    output overflow\n);\n\n    reg [4:0] temp_sum;\n    reg [3:0] temp_A;\n    reg [3:0] temp_B;\n    reg temp_sub;\n\n    assign overflow = temp_sum[4];\n\n    always @(*) begin\n        temp_A = A;\n        temp_B = B;\n        temp_sub = sub;\n\n        if (temp_sub == 1'b0) begin\n            temp_sum = temp_A + temp_B;\n        end\n        else begin\n            temp_sum = temp_A - temp_B;\n        end\n    end\n\n    assign sum = temp_sum[3:0];\n\nendmodule",
        "module_name": "add_sub",
        "module_hash": "17a9ad7da465e401895658cb569ba9e9",
        "dataset_index": 8969
      },
      "INT_MANAGER_b3218949": {
        "rtl_code": "\nmodule INT_MANAGER(\n    clk,\n    rst_n,\n    en,\n    \n    int_en,\n    rd_int_msk_i,\n    wr_int_msk_i,\n    \n    rd_req_done_i,\n    wr_req_done_i,\n    \n    int_cnt_o,\n    \n    msi_on,\n    \n    cfg_interrupt_assert_n_o,\n    cfg_interrupt_rdy_n_i,\n    cfg_interrupt_n_o,\n    cfg_interrupt_legacyclr\n);\n\nparameter   INT_RST = 2'b01;\nparameter   INT_PENDING = 2'b10;\n\ninput       clk;\ninput       rst_n;\ninput       en;\n\ninput       int_en;\ninput       rd_int_msk_i , wr_int_msk_i;\n\ninput       rd_req_done_i , wr_req_done_i;\noutput [31:0]  int_cnt_o;\n\ninput       msi_on;\noutput reg  cfg_interrupt_assert_n_o;\ninput       cfg_interrupt_rdy_n_i;\noutput reg  cfg_interrupt_n_o;\ninput       cfg_interrupt_legacyclr;\n\nreg [31:0]  int_cnt_o;\nreg     rd_int , wr_int;\n\nreg     rd_req_done_prev , wr_req_done_prev;\nreg     int_clr;\n\nreg [1:0]   intr_state;\n\nalways @ ( posedge clk ) begin\n\n    if( !rst_n || !en ) begin\n\n        rd_int <= 1'b0;\n        wr_int <= 1'b0;\n        \n        rd_req_done_prev <= 1'b0;\n        wr_req_done_prev <= 1'b0;\n\n    end\n    else begin\n\n        rd_req_done_prev <= rd_req_done_i;\n        wr_req_done_prev <= wr_req_done_i;\n\n        if( int_clr || !int_en ) begin\n\n            rd_int <= 1'b0;\n            wr_int <= 1'b0;\n\n        end\n        else begin\n\n            if( !rd_req_done_prev && rd_req_done_i && !rd_int_msk_i)\n                rd_int <= 1'b1;\n                \n            if( !wr_req_done_prev && wr_req_done_i && !wr_int_msk_i )\n                wr_int <= 1'b1;\n\n        end //if( int_clr || !int_en )\n\n    end //if( rst_n || !en )\n\nend\n\nalways @ ( posedge clk ) begin\n\n    if( !rst_n || !en ) begin\n\n        int_clr <= 1'b0;\n        cfg_interrupt_assert_n_o <= 1'b1;\n        cfg_interrupt_n_o <= 1'b1;\n        \n        int_cnt_o <= 32'b0;\n        \n        intr_state <= INT_RST;\n\n    end\n    else begin\n\n        case ( intr_state )\n\n            INT_RST: begin\n\n                if( rd_int | wr_int ) begin\n\n                    int_clr <= 1'b1;\n                    cfg_interrupt_assert_n_o <= 1'b0;\n                    cfg_interrupt_n_o <= 1'b0;\n                    \n                    int_cnt_o <= int_cnt_o + 1'b1;\n                    \n                    intr_state <= INT_PENDING;\n\n                end\n\n            end\n\n            INT_PENDING: begin\n\n                int_clr <= 1'b0;\n\n                if( !cfg_interrupt_rdy_n_i ) begin\n\n                    cfg_interrupt_assert_n_o <= 1'b1;\n                    cfg_interrupt_n_o <= 1'b1;\n                    intr_state <= INT_RST;\n\n                end\n\n            end\n\n            default: intr_state <= INT_RST;\n\n        endcase        \n\n\n    end //if( !rst_n || !en )\n\nend\n\n\nendmodule",
        "module_name": "INT_MANAGER",
        "module_hash": "b3218949ee84e77f10050e4d1c39ebec",
        "dataset_index": 9099
      },
      "mag_comparator #_40f72737": {
        "rtl_code": "module mag_comparator #(\n  parameter n = 4 // number of bits in the binary numbers\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output GT,\n  output EQ,\n  output LT\n);\n\n\nassign GT = (A > B);\nassign EQ = (A == B);\nassign LT = (A < B);\n\nendmodule",
        "module_name": "mag_comparator #",
        "module_hash": "40f727374a577c604f84db361e785822",
        "dataset_index": 788
      },
      "CDC_Synchronizer_e987108b": {
        "rtl_code": "\nmodule CDC_Synchronizer (\n  input [N-1:0] data_in,\n  input clk_in,\n  input rst_in,\n  input clk_out,\n  output [N-1:0] data_out,\n  output rst_out\n);\n\nparameter N = 8; // number of bits in input and output data signals\n\nreg [N-1:0] synchronized_data;\nreg synchronized_reset;\n\nalways @(posedge clk_out) begin\n  synchronized_data <= data_in;\n  synchronized_reset <= rst_in;\nend\n\nreg [N-1:0] latched_data;\nreg latched_reset;\n\nalways @(posedge clk_out) begin\n  latched_data <= synchronized_data;\nend\n\nalways @(posedge clk_out) begin\n  latched_reset <= synchronized_reset;\nend\n\nassign data_out = latched_data;\nassign rst_out = latched_reset;\n\nendmodule",
        "module_name": "CDC_Synchronizer",
        "module_hash": "e987108bd136986362e02c40a8668e2f",
        "dataset_index": 16073
      },
      "adder_8bit_f61acb0b": {
        "rtl_code": "\nmodule adder_8bit (\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] S,\n    output reg C_out\n);\n\n    wire [7:0] c;\n\n    always @* begin\n        {C_out, c[7], S[7]} = A[7] + B[7];\n        {c[6], S[6]} = c[7] + A[6] + B[6];\n        {c[5], S[5]} = c[6] + A[5] + B[5];\n        {c[4], S[4]} = c[5] + A[4] + B[4];\n        {c[3], S[3]} = c[4] + A[3] + B[3];\n        {c[2], S[2]} = c[3] + A[2] + B[2];\n        {c[1], S[1]} = c[2] + A[1] + B[1];\n        {c[0], S[0]} = c[1] + A[0] + B[0];\n    end\n\nendmodule",
        "module_name": "adder_8bit",
        "module_hash": "f61acb0b2fc4ee0af74bf18ea8097b27",
        "dataset_index": 19082
      },
      "MM_slave_b1828394": {
        "rtl_code": "\nmodule MM_slave (\n\t\tinput  wire [7:0]  avs_s0_address,     input  wire        avs_s0_read,        output wire [31:0] avs_s0_readdata,    input  wire        avs_s0_write,       input  wire [31:0] avs_s0_writedata,   output wire        avs_s0_waitrequest, input  wire        clock_clk,          input  wire        reset_reset,        output wire        LED_OUT             );\n\n\tassign avs_s0_readdata = 32'b00000000000000000000000000000000;\n\nreg\t\t\tReg_Status_Read;\n   reg\t\t\tReg_Status_Write;\n   reg [31:0] \t\tdata_in;\n   reg [31:0] \t\tdata_out;\n\treg \t\t\t\tled_out;\n\n\n   assign avs_s0_waitrequest = Reg_Status_Read || Reg_Status_Write;\n\tassign LED_OUT = led_out;\n   \n   always @(posedge clock_clk)\n\t  if (reset_reset) begin\n\t\t\tdata_in <= 32'b0;\n\t\t\tdata_out <= 32'b0;\n\t\t\tReg_Status_Write <= 1'b0;\t\n\t  end else if (!avs_s0_waitrequest && avs_s0_write) begin\n\t\t\tReg_Status_Write <= 1'b0;\t\n\t\t\tled_out <= avs_s0_writedata[0];\n\t\t\tdata_in <= avs_s0_writedata;\n\t  end else begin\n\t\t\tReg_Status_Write <= 1'b0;\t\n\t  end\n\t\n   always @(posedge clock_clk)\n\tif (reset_reset) begin\n\t\tReg_Status_Read <= 1'b0;\t\n\tend else if (!avs_s0_waitrequest && avs_s0_read) begin\n\t\tReg_Status_Read <= 1'b0;\t\n\tend else begin\n\t\tReg_Status_Read <= 1'b0;\t\n\tend\n\t\n\nendmodule\n",
        "module_name": "MM_slave",
        "module_hash": "b1828394f216c45a08b854cc122e2aae",
        "dataset_index": 24826
      },
      "axis_gen_pulse #_050f896e": {
        "rtl_code": "\nmodule axis_gen_pulse #(\n  parameter DLY = 1,\n  parameter INTERLACE = 0,\n  parameter DATA_WIDTH = 24\n )\n(\n    input   wire        aclk,\n    input   wire        rst,\n    input   wire        axis_tready,\n    output  wire        axis_tvalid,\n    output  reg  [DATA_WIDTH-1:0] axis_tdata_video,\n    output  reg         axis_tlast,\n    output  reg         fid,\n    output  reg         axis_tuser_sof,\n    output  reg         axis_tuser_pulse,\n    input   wire [13:0]  active_pixels,\n    input   wire  [13:0]  active_lines\n );\n\n// variable declarations\n\nreg [13:0]   pixel_count = 0;\nreg [13:0]    line_count = 0;\nwire        eol;\nwire        sof;        \nreg         eol_1;\nwire        set_axis_tvalid;\nparameter duty_cycle_phase_accum = 0.0;\n\nassign eol = pixel_count == active_pixels - 1;\nassign sof = line_count == 0 && pixel_count == 0;\nassign axis_tvalid = 1;\n\n// delay eol\nalways @ (posedge aclk) \n  eol_1 <= eol;\n\nalways @ (posedge aclk) begin\n    if (axis_tready & axis_tvalid)\n    begin\n        if (rst || eol)\n             pixel_count <= 0;\n        else\n             pixel_count <= pixel_count + 1;\n    end\nend\nalways @ (posedge aclk)\n    if (axis_tready)\n    begin\n        if (rst || ((line_count >= active_lines - 1) && eol) )begin\n            line_count <=  0;\n\t    end\n        else if (eol)\n            line_count <=  line_count + 1;\n    end\n\n\n\nalways @ (posedge aclk)\t begin\n  if (rst) begin\n    axis_tlast     <= 0;\n    axis_tuser_sof <= 0;\n    axis_tuser_pulse <= 0;\n    if (INTERLACE)\n      fid <= 1;\n    else \n\t   fid <= 0;\n  end\n  else if (axis_tready) begin\n    axis_tdata_video <= INTERLACE && ((!fid && sof) || (fid && !sof))?\n      {~line_count, ~pixel_count[11:0]}:\n      {line_count, pixel_count[11:0]};\n\taxis_tlast <= eol;\n\taxis_tuser_sof <= sof;\n    // set field ID bit\n\tif (INTERLACE) begin\n\t  if (sof)\n\t    fid <= ~fid;\t    \n\tend\n\telse begin\n\t  fid <= 0;\t  // always field 0 if not interlaced\n\tend\n    if (eol && !eol_1) begin\n      axis_tuser_pulse <= 1;\n    end\n    else begin\n      axis_tuser_pulse <= 0;\n    end\n  end\nend \n\nendmodule",
        "module_name": "axis_gen_pulse #",
        "module_hash": "050f896e63192990f02c519a44ffeff9",
        "dataset_index": 8579
      },
      "register_interface_925132fc": {
        "rtl_code": "module register_interface (\n  input wire reset,\n  input wire clk,\n  input wire reg_req,\n  input wire reg_rd_wr_L,\n  input wire [7:0] reg_addr,\n  input wire [31:0] reg_wr_data,\n  output reg [31:0] reg_rd_data,\n  output reg reg_ack\n);\n\n  reg [31:0] register [255:0]; // 256 registers, each 32 bits wide\n\n  always @(posedge clk) begin\n    if (reset) begin\n      reg_rd_data <= 0;\n      reg_ack <= 0;\n    end\n    else if (reg_req) begin\n      if (reg_addr > 255) begin // invalid address\n        reg_rd_data <= 0;\n        reg_ack <= 0;\n      end\n      else begin // valid address\n        if (reg_rd_wr_L) begin // write operation\n          register[reg_addr] <= reg_wr_data;\n          reg_ack <= 1;\n        end\n        else begin // read operation\n          reg_rd_data <= register[reg_addr];\n          reg_ack <= 1;\n        end\n      end\n    end\n  end\n\nendmodule",
        "module_name": "register_interface",
        "module_hash": "925132fce65b92bc149f70d784b69ae1",
        "dataset_index": 1661
      },
      "full_adder_7f563a7f": {
        "rtl_code": "\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\nwire temp_sum;\nwire temp_cout;\n\nassign {temp_cout, temp_sum} = a + b + cin;\nassign sum = temp_sum;\nassign cout = temp_cout;\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\nreg [31:0] a_reg, b_reg;\nwire [31:0] a_xor_b;\nwire [31:0] sub_xor_sum;\nwire [31:0] sub_and_b;\nwire [31:0] sub_and_sum;\nwire [31:0] sub_and_cin;\nwire [31:0] cin;\n\nfull_adder fa[31:0](\n    .a(a_xor_b),\n    .b(sub_and_cin),\n    .cin(cin),\n    .sum(sum),\n    .cout()\n);\n\nalways @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\nend\n\nassign a_xor_b = a_reg ^ b_reg;\n\nassign sub_xor_sum = sub ^ sum;\n\nassign sub_and_b = sub & b_reg;\n\nassign sub_and_sum = sub & sum;\n\nassign sub_and_cin = sub_and_b | sub_and_sum;\n\nassign cin = {32{sub}};\n\nendmodule\n",
        "module_name": "full_adder",
        "module_hash": "7f563a7fb1a49c5f02c20f0c40fad53a",
        "dataset_index": 18518
      },
      "servo_control_cf1e2484": {
        "rtl_code": "module servo_control (\n  input clk,\n  input rst,\n  input [7:0] pwm_in,\n  input [7:0] pos_in,\n  output [7:0] pwm_out\n);\n\nparameter pwm_period = 20000; // period of the PWM signal (in clock cycles)\nparameter pwm_min = 10; // minimum duty cycle of the PWM signal\nparameter pwm_max = 90; // maximum duty cycle of the PWM signal\n\nreg [7:0] current_pos; // register to store the current position of the servo motor\nreg [7:0] desired_pos; // register to store the desired position of the servo motor\nreg [7:0] error; // register to store the difference between the desired and current positions\nreg [15:0] pwm_counter; // counter to generate the PWM signal\nwire pwm_enable; // signal to enable the PWM signal generation\n\nassign pwm_enable = (pwm_counter < ((pwm_period * pwm_in) / 256)); // calculate the duty cycle of the PWM signal\n\nalways @(posedge clk) begin\n  if (rst) begin\n    current_pos <= 0; // reset the current position to 0\n    desired_pos <= 0; // reset the desired position to 0\n    error <= 0; // reset the error to 0\n    pwm_counter <= 0; // reset the PWM counter to 0\n  end else begin\n    current_pos <= pwm_enable ? pwm_in : current_pos; // update the current position based on the PWM signal\n    desired_pos <= pos_in; // update the desired position based on the input\n    error <= desired_pos - current_pos; // calculate the error between the desired and current positions\n    pwm_counter <= (pwm_counter == pwm_period - 1) ? 0 : pwm_counter + 1; // increment the PWM counter and reset it if necessary\n  end\nend\n\nassign pwm_out = (pwm_enable && (pwm_counter < ((pwm_period * pwm_max) / 256))) ? 255 : ((pwm_counter < ((pwm_period * pwm_min) / 256)) ? 0 : 255 * (pwm_counter - ((pwm_period * pwm_min) / 256)) / (((pwm_period * pwm_max) / 256) - ((pwm_period * pwm_min) / 256))); // generate the final output PWM signal with duty cycle limited by pwm_min and pwm_max\n\nendmodule",
        "module_name": "servo_control",
        "module_hash": "cf1e24844d9207e63113b4a234cfb38c",
        "dataset_index": 15842
      },
      "shift_register_f5a9a2ef": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input load,\n    input shift_enable,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data_in;\n    end else if (shift_enable) begin\n        shift_reg <= {shift_reg[2:0], 1'b0};\n    end\n    data_out <= shift_reg;\nend\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "f5a9a2ef98eb97566de51fca07d5502e",
        "dataset_index": 12137
      },
      "up_down_counter_4d0842ff": {
        "rtl_code": "\nmodule up_down_counter (\n    input CLK,\n    input RST,\n    input LD,\n    input UD,\n    input [3:0] D,\n    output [3:0] Q\n);\n    \n    reg [3:0] Q_reg1, Q_reg2;\n    \n    always @(posedge CLK) begin\n        if(RST) begin\n            Q_reg1 <= 4'b0;\n            Q_reg2 <= 4'b0;\n        end\n        else if(LD) begin\n            Q_reg1 <= D;\n            Q_reg2 <= D;\n        end\n        else if(UD) begin\n            Q_reg1 <= Q_reg2 + 4'b1;\n        end\n        else begin\n            Q_reg1 <= Q_reg2 - 4'b1;\n        end\n        Q_reg2 <= Q_reg1;\n    end\n    \n    assign Q = Q_reg1;\n    \nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "4d0842ffaac88261c7c990f7d4307feb",
        "dataset_index": 1386
      },
      "half_adder_nand_af00a6ad": {
        "rtl_code": "module half_adder_nand( \n    input a, b,\n    output sum, cout );\n    \n    wire s1, s2, c1;\n    \n    nand(s1, a, b);\n    nand(s2, a, s1);\n    nand(c1, s1, b);\n    \n    assign sum = s2;\n    assign cout = c1;\n    \nendmodule",
        "module_name": "half_adder_nand",
        "module_hash": "af00a6ad52f5b82eec1efde6fe75999e",
        "dataset_index": 17244
      },
      "ddr3_s4_uniphy_example_sim_ddr3_s4_uniphy_example_sim_e0_if0_p0_hr_to_fr_568b86d0": {
        "rtl_code": "module ddr3_s4_uniphy_example_sim_ddr3_s4_uniphy_example_sim_e0_if0_p0_hr_to_fr(\n\tclk,\n\td_h0,\n\td_h1,\n\td_l0,\n\td_l1,\n\tq0,\n\tq1\n);\n\ninput\tclk;\ninput\td_h0;\ninput\td_h1;\ninput\td_l0;\ninput\td_l1;\noutput\tq0;\noutput\tq1;\n\nreg\tq_h0;\nreg\tq_h1;\nreg\tq_l0;\nreg\tq_l1;\nreg\tq_l0_neg;\nreg\tq_l1_neg;\n\n\talways @(posedge clk)\n\tbegin\n\t\tq_h0 <= d_h0;\n\t\tq_l0 <= d_l0;\n\t\tq_h1 <= d_h1;\n\t\tq_l1 <= d_l1;\n\tend\n\n\talways @(negedge clk)\n\tbegin\n\t\tq_l0_neg <= q_l0;\n\t\tq_l1_neg <= q_l1;\n\tend\n\n\tassign q0 = clk ? q_l0_neg : q_h0;\n\tassign q1 = clk ? q_l1_neg : q_h1;\n\nendmodule\n",
        "module_name": "ddr3_s4_uniphy_example_sim_ddr3_s4_uniphy_example_sim_e0_if0_p0_hr_to_fr",
        "module_hash": "568b86d0894dac9af6c6dcfa909bc9e7",
        "dataset_index": 4819
      },
      "BRAM_SDP #_2f967e5f": {
        "rtl_code": "module BRAM_SDP #(parameter AWIDTH = 9,\nparameter DWIDTH = 32)(\n\tclk,\n\trce,\n\tra,\n\trq,\n\twce,\n\twa,\n\twd\n);\n\n\tinput  \t\t\tclk;\n\n\tinput                   rce;\n\tinput      [AWIDTH-1:0] ra;\n\toutput reg [DWIDTH-1:0] rq;\n\n\tinput                   wce;\n\tinput      [AWIDTH-1:0] wa;\n\tinput      [DWIDTH-1:0] wd;\n\n\treg        [DWIDTH-1:0] memory[0:(1<<AWIDTH)-1];\n\n\talways @(posedge clk) begin\n\t\tif (rce)\n\t\t\trq <= memory[ra];\n\n\t\tif (wce)\n\t\t\tmemory[wa] <= wd;\n\tend\n\n\tinteger i;\n\tinitial\n\tbegin\n\t\tfor(i = 0; i < (1<<AWIDTH)-1; i = i + 1)\n\t\t\tmemory[i] = 0;\n\tend\n\nendmodule\n\nmodule BRAM_SDP_32x512(\n\tclk,\n\trce,\n\tra,\n\trq,\n\twce,\n\twa,\n\twd\n);\n\nparameter AWIDTH = 9;\nparameter DWIDTH = 32;\n\n\tinput  \t\t\tclk;\n\tinput                   rce;\n\tinput      [AWIDTH-1:0] ra;\n\toutput     [DWIDTH-1:0] rq;\n\tinput                   wce;\n\tinput      [AWIDTH-1:0] wa;\n\tinput      [DWIDTH-1:0] wd;\n\nBRAM_SDP #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n\tBRAM_32x512 (.clk(clk),\n\t\t .rce(rce),\n\t\t .ra(ra),\n\t\t .rq(rq),\n\t\t .wce(wce),\n\t\t .wa(wa),\n\t\t .wd(wd));\n\nendmodule\n\nmodule BRAM_SDP_16x1024(\n\tclk,\n\trce,\n\tra,\n\trq,\n\twce,\n\twa,\n\twd\n);\n\nparameter AWIDTH = 10;\nparameter DWIDTH = 16;\n\n\tinput  \t\t\tclk;\n\tinput                   rce;\n\tinput      [AWIDTH-1:0] ra;\n\toutput     [DWIDTH-1:0] rq;\n\tinput                   wce;\n\tinput      [AWIDTH-1:0] wa;\n\tinput      [DWIDTH-1:0] wd;\n\nBRAM_SDP #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n\tBRAM_16x1024 (.clk(clk),\n\t\t .rce(rce),\n\t\t .ra(ra),\n\t\t .rq(rq),\n\t\t .wce(wce),\n\t\t .wa(wa),\n\t\t .wd(wd));\n\n\nendmodule\n\nmodule BRAM_SDP_8x2048(\n\tclk,\n\trce,\n\tra,\n\trq,\n\twce,\n\twa,\n\twd\n);\n\nparameter AWIDTH = 11;\nparameter DWIDTH = 8;\n\n\tinput  \t\t\tclk;\n\tinput                   rce;\n\tinput      [AWIDTH-1:0] ra;\n\toutput     [DWIDTH-1:0] rq;\n\tinput                   wce;\n\tinput      [AWIDTH-1:0] wa;\n\tinput      [DWIDTH-1:0] wd;\n\nBRAM_SDP #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n\tBRAM_8x2048 (.clk(clk),\n\t\t .rce(rce),\n\t\t .ra(ra),\n\t\t .rq(rq),\n\t\t .wce(wce),\n\t\t .wa(wa),\n\t\t .wd(wd));\n\n\nendmodule\n\nmodule BRAM_SDP_4x4096(\n\tclk,\n\trce,\n\tra,\n\trq,\n\twce,\n\twa,\n\twd\n);\n\nparameter AWIDTH = 12;\nparameter DWIDTH = 4;\n\n\tinput  \t\t\tclk;\n\tinput                   rce;\n\tinput      [AWIDTH-1:0] ra;\n\toutput     [DWIDTH-1:0] rq;\n\tinput                   wce;\n\tinput      [AWIDTH-1:0] wa;\n\tinput      [DWIDTH-1:0] wd;\n\nBRAM_SDP #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n\tBRAM_4x4096 (.clk(clk),\n\t\t .rce(rce),\n\t\t .ra(ra),\n\t\t .rq(rq),\n\t\t .wce(wce),\n\t\t .wa(wa),\n\t\t .wd(wd));\n\nendmodule\n",
        "module_name": "BRAM_SDP #",
        "module_hash": "2f967e5f738afa185a06cfc4facc83bb",
        "dataset_index": 24028
      },
      "multiplier_428f6f1f": {
        "rtl_code": "module multiplier(\n  input signed [7:0] A,\n  input signed [7:0] B,\n  output reg signed [15:0] C\n);\n\n  always @(A or B) begin\n    C = A * B;\n  end\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "428f6f1fd4bef33fe353188ddf8608f0",
        "dataset_index": 9443
      },
      "sky130_fd_sc_hd__and4b_c4a740e9": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__and4b (\n    X  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N              );\n    and and0 (and0_out_X, not0_out, B, C, D);\n    buf buf0 (X         , and0_out_X       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__and4b",
        "module_hash": "c4a740e944c054ae88513a6f59ea04cc",
        "dataset_index": 4647
      },
      "LedPWM_ee98b330": {
        "rtl_code": "\n\n\n\n\n\n\n\n\n\n\n\nmodule LedPWM(\n    input clk,\n    input [7:0] value,\n    output out\n    );\n\nreg [7:0]    PWMCounter;\nreg            outreg;\nalways @(posedge clk)\nbegin\n        if(PWMCounter <= value & value != 0)\n            outreg <= 1;\n        else\n            outreg <= 0;\n            \n        PWMCounter <= PWMCounter+1;\nend\n\nassign out = outreg;\nendmodule\n",
        "module_name": "LedPWM",
        "module_hash": "ee98b330e07aa484a1df32e524fa1114",
        "dataset_index": 13129
      },
      "state_splitting_FSM #_f3b14339": {
        "rtl_code": "module state_splitting_FSM #(\n  parameter n = 4, // number of states\n  parameter m = 2 // number of output signals\n) (\n  input clk,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nreg [1:0] state; // current state\nreg [1:0] next_state; // next state\nreg [m-1:0] output_reg; // output register\n\n// Define the states\nparameter STATE_00 = 2'b00;\nparameter STATE_01 = 2'b01;\nparameter STATE_10 = 2'b10;\nparameter STATE_11 = 2'b11;\n\n// Define the state transitions\nalways @(posedge clk) begin\n  case (state)\n    STATE_00: begin\n      if (in[0] && in[1]) begin\n        next_state = STATE_11;\n      end else if (in[0]) begin\n        next_state = STATE_01;\n      end else if (in[1]) begin\n        next_state = STATE_10;\n      end else begin\n        next_state = STATE_00;\n      end\n    end\n    STATE_01: begin\n      if (in[0] && in[1]) begin\n        next_state = STATE_11;\n      end else if (in[1]) begin\n        next_state = STATE_00;\n      end else begin\n        next_state = STATE_01;\n      end\n    end\n    STATE_10: begin\n      if (in[0] && in[1]) begin\n        next_state = STATE_11;\n      end else if (in[0]) begin\n        next_state = STATE_00;\n      end else begin\n        next_state = STATE_10;\n      end\n    end\n    STATE_11: begin\n      if (!in[0] && !in[1]) begin\n        next_state = STATE_00;\n      end else if (!in[0]) begin\n        next_state = STATE_10;\n      end else if (!in[1]) begin\n        next_state = STATE_01;\n      end else begin\n        next_state = STATE_11;\n      end\n    end\n  endcase\nend\n\n// Define the output signals\nalways @(state) begin\n  case (state)\n    STATE_00: begin\n      output_reg[0] = 1'b0;\n      output_reg[1] = 1'b0;\n    end\n    STATE_01: begin\n      output_reg[0] = 1'b0;\n      output_reg[1] = 1'b1;\n    end\n    STATE_10: begin\n      output_reg[0] = 1'b1;\n      output_reg[1] = 1'b0;\n    end\n    STATE_11: begin\n      output_reg[0] = 1'b1;\n      output_reg[1] = 1'b1;\n    end\n  endcase\nend\n\n// Assign the outputs\nassign out = output_reg;\n\n// Update the state\nalways @(posedge clk) begin\n  state <= next_state;\nend\n\nendmodule",
        "module_name": "state_splitting_FSM #",
        "module_hash": "f3b1433987c677bb31e9cecf871d50c8",
        "dataset_index": 3475
      },
      "rising_edge_detector_fcf20cf5": {
        "rtl_code": "module rising_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nreg [31:0] stage1_out;\nreg [31:0] stage2_out;\nreg [31:0] stage3_out;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        stage1_out <= 0;\n        stage2_out <= 0;\n        stage3_out <= 0;\n    end else begin\n        stage1_out <= in;\n        stage2_out <= stage1_out ^ {stage1_out[0], stage1_out[31:1]};\n        stage3_out <= stage2_out & {~stage2_out[0], stage2_out[31:1]};\n    end\nend\n\nassign out = stage3_out;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nrising_edge_detector detector (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule",
        "module_name": "rising_edge_detector",
        "module_hash": "fcf20cf5d37eba6d03e7bf9b23242664",
        "dataset_index": 2824
      },
      "barrel_shifter_d698f365": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] DATA,\n    input [1:0] SHIFT,\n    output [3:0] OUT\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\nreg [3:0] stage3_out;\n\nalways @(*) begin\n    case(SHIFT)\n        2'b00: stage1_out = DATA;\n        2'b01: stage1_out = {DATA[2:0], 1'b0};\n        2'b10: stage1_out = {DATA[1:0], 2'b00};\n        2'b11: stage1_out = {DATA[0], 3'b000};\n    endcase\nend\n\nalways @(*) begin\n    case(SHIFT)\n        2'b00: stage2_out = stage1_out;\n        2'b01: stage2_out = {stage1_out[1:0], 2'b00};\n        2'b10: stage2_out = {stage1_out[0], 3'b000};\n        2'b11: stage2_out = {3'b000, stage1_out[3]};\n    endcase\nend\n\nalways @(*) begin\n    case(SHIFT)\n        2'b00: stage3_out = stage2_out;\n        2'b01: stage3_out = {stage2_out[2:0], 1'b0};\n        2'b10: stage3_out = {stage2_out[1:0], 2'b00};\n        2'b11: stage3_out = {stage2_out[0], 3'b000};\n    endcase\nend\n\nassign OUT = stage3_out;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "d698f365af82e7d0688d8fa3d772f3ce",
        "dataset_index": 5464
      },
      "comparator_4bit_70361c4c": {
        "rtl_code": "module comparator_4bit (\n    input [3:0] in0,\n    input [3:0] in1,\n    input clk,\n    output reg EQ,\n    output reg GT\n);\n\nreg [3:0] in0_reg;\nreg [3:0] in1_reg;\nreg [1:0] stage;\n\nalways @(*) begin\n    case(stage)\n        2'b00: begin\n            in0_reg = in0;\n            in1_reg = in1;\n        end\n        2'b01: begin\n            in0_reg = in0_reg;\n            in1_reg = in1_reg;\n        end\n        2'b10: begin\n            in0_reg = in0_reg;\n            in1_reg = in1_reg;\n        end\n        2'b11: begin\n            in0_reg = in0_reg;\n            in1_reg = in1_reg;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (stage == 2'b11)\n        stage <= 2'b00;\n    else\n        stage <= stage + 1;\nend\n\nalways @* begin\n    EQ = (in0_reg == in1_reg) ? 1'b1 : 1'b0;\n    GT = (in0_reg > in1_reg) ? 1'b1 : 1'b0;\nend\n\nendmodule",
        "module_name": "comparator_4bit",
        "module_hash": "70361c4cb6d6f879193b218278459ed2",
        "dataset_index": 6665
      },
      "wire_connection_deb9be16": {
        "rtl_code": "\nmodule wire_connection (\n    input [2:0] data_in1,\n    input [2:0] data_in2,\n    input [2:0] data_in3,\n    output [3:0] data_out\n);\n\nassign data_out = {data_in3, data_in2, data_in1};\n\nendmodule\n\nmodule priority_encoder (\n    input [3:0] data_in,\n    output reg [2:0] index\n);\n\ninteger i;\n\nalways @(*) begin\n    index = 0;\n    for (i = 0; i < 4; i = i + 1) begin\n        if (data_in[i]) begin\n            index = i;\n        end\n    end\nend\n\nendmodule\n\nmodule voting_circuit (\n    input clk,\n    input reset,\n    input [2:0] data_in1,\n    input [2:0] data_in2,\n    input [2:0] data_in3,\n    output reg [2:0] final_output\n);\n\nwire [3:0] wire_out;\nwire [2:0] encoder_out;\n\nwire_connection wire_conn(\n    .data_in1(data_in1),\n    .data_in2(data_in2),\n    .data_in3(data_in3),\n    .data_out(wire_out)\n);\n\npriority_encoder priority_enc(\n    .data_in(wire_out),\n    .index(encoder_out)\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        final_output <= 0;\n    end\n    else begin\n        final_output <= {3{1'b0}};\n        case (encoder_out)\n            0: final_output <= data_in1;\n            1: final_output <= data_in2;\n            2: final_output <= data_in3;\n        endcase\n    end\nend\n\nendmodule\n",
        "module_name": "wire_connection",
        "module_hash": "deb9be163e5ff68a1b22c0a5a914bee9",
        "dataset_index": 17405
      },
      "DataMemory_2ecab4bc": {
        "rtl_code": "module DataMemory (Clk, rdEn, wrEn, addr, wrData, Data);\n\t\n\tparameter WIDTH = 8;\n\tparameter DEPTH = 256;\n\t\t\n\tinput Clk;\n\tinput rdEn, wrEn;\n\tinput [WIDTH-1:0] wrData;\n\tinput [7:0] addr;\n\t\n\toutput [WIDTH-1:0] Data;\n\t\n\treg [WIDTH-1:0] data_out;\n\n\treg [WIDTH-1 : 0] memory[DEPTH-1 : 0];\n\t\n\talways @ (posedge Clk)\n\t\tbegin : DATA_MEM\n\t\t  data_out <= 100'bx;\n\t\t\tif (wrEn)\n\t\t\t\tbegin\n\t\t\t\t\tmemory[addr] <= wrData;\n\t\t\t\tend\n\t\t\tif (rdEn) \n\t\t\t\tbegin\n\t\t\t\t\tdata_out <= memory[addr]; \n\t\t\t\tend\n\t\tend\n\t\t\n\t\tassign Data = data_out;\nendmodule\n\t",
        "module_name": "DataMemory",
        "module_hash": "2ecab4bc2aa728cedb133eb67623042e",
        "dataset_index": 22983
      },
      "mux_2to1_c95b2b49": {
        "rtl_code": "module mux_2to1(\n    input in0,\n    input in1,\n    input sel,\n    output reg out\n);\n\nalways @ (sel, in0, in1) begin\n    if (sel) begin\n        out <= in1;\n    end else begin\n        out <= in0;\n    end\nend\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "c95b2b492d630aa2990c62b021a8e7dd",
        "dataset_index": 13459
      },
      "iscachable_cd6c22f5": {
        "rtl_code": "\nmodule iscachable(\n\t\tinput\twire\t[30-1:0]\ti_addr,\n\t\toutput\treg\t\t\to_cachable\n\t\t);\n\n\talways @(*)\n\tbegin\n\t\to_cachable = 1'b0;\n\t\tif ((i_addr[29:0] & 30'h3e000000) == 30'h1a000000)\n\t\t\to_cachable = 1'b1;\n\t\tif ((i_addr[29:0] & 30'h3e000000) == 30'h1c000000)\n\t\t\to_cachable = 1'b1;\n\t\tif ((i_addr[29:0] & 30'h20000000) == 30'h20000000)\n\t\t\to_cachable = 1'b1;\n\tend\n\nendmodule\n",
        "module_name": "iscachable",
        "module_hash": "cd6c22f5eedb451c5cab06723e501bad",
        "dataset_index": 16268
      },
      "three_input_and_gate_b947af24": {
        "rtl_code": "module three_input_and_gate (\n    input input1,\n    input input2,\n    input input3,\n    output output1\n);\n\n    wire intermediate1;\n    wire intermediate2;\n\n    and and1 (intermediate1, input1, input2);\n    and and2 (intermediate2, intermediate1, input3);\n    not not1 (output1, intermediate2);\n\nendmodule",
        "module_name": "three_input_and_gate",
        "module_hash": "b947af2490b3fc258100b9413b06fcda",
        "dataset_index": 12194
      },
      "counter_46a55c12": {
        "rtl_code": "module counter (\n    input clk,\n    input rst,\n    input [31:0] max_value,\n    output reg [31:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n        end else if (count == max_value - 1) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "46a55c12f661b21d9cb0184c7e2fd461",
        "dataset_index": 18296
      },
      "fifo_5440a7a4": {
        "rtl_code": "module fifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    empty,\n    full,\n    q,\n    usedw\n);\n\ninput aclr;\ninput clock;\ninput [29:0] data;\ninput rdreq;\ninput wrreq;\noutput empty;\noutput full;\noutput [29:0] q;\noutput [4:0] usedw;\n\nreg [29:0] mem [31:0];\nreg [4:0] usedw_reg;\nreg empty_reg;\nreg full_reg;\nreg [29:0] q_reg;\nreg [4:0] write_ptr_reg;\nreg [4:0] read_ptr_reg;\n\nalways @(posedge clock) begin\n    if (aclr == 1'b0) begin\n        // Asynchronous clear\n        empty_reg <= 1'b1;\n        full_reg <= 1'b0;\n        usedw_reg <= 5'b00000;\n        q_reg <= 30'b0;\n        write_ptr_reg <= 5'b00000;\n        read_ptr_reg <= 5'b00000;\n    end else begin\n        // Write operation\n        if (wrreq == 1'b1 && full_reg == 1'b0) begin\n            mem[write_ptr_reg] <= data;\n            write_ptr_reg <= write_ptr_reg + 1;\n            usedw_reg <= usedw_reg + 1;\n            if (write_ptr_reg == 5'b11111) begin\n                write_ptr_reg <= 5'b00000;\n            end\n            if (usedw_reg == 5'b10000) begin\n                full_reg <= 1'b1;\n            end\n            empty_reg <= 1'b0;\n        end\n        // Read operation\n        if (rdreq == 1'b1 && empty_reg == 1'b0) begin\n            q_reg <= mem[read_ptr_reg];\n            read_ptr_reg <= read_ptr_reg + 1;\n            usedw_reg <= usedw_reg - 1;\n            if (read_ptr_reg == 5'b11111) begin\n                read_ptr_reg <= 5'b00000;\n            end\n            if (usedw_reg == 5'b00000) begin\n                empty_reg <= 1'b1;\n            end\n            full_reg <= 1'b0;\n        end\n    end\nend\n\nassign empty = empty_reg;\nassign full = full_reg;\nassign q = q_reg;\nassign usedw = usedw_reg;\n\nendmodule",
        "module_name": "fifo",
        "module_hash": "5440a7a4b78bd8bda6e6ebae9edfddb8",
        "dataset_index": 5480
      },
      "BRAM #_04219058": {
        "rtl_code": "module BRAM #(parameter AWIDTH = 9,\n              parameter DWIDTH = 32)\n       (clk,\n        rce,\n        ra,\n        rq,\n        wce,\n        wa,\n        wd);\n\n        input  clk;\n\n        input                   rce;\n        input      [AWIDTH-1:0] ra;\n        output reg [DWIDTH-1:0] rq;\n\n        input                   wce;\n        input      [AWIDTH-1:0] wa;\n        input      [DWIDTH-1:0] wd;\n\n        reg        [DWIDTH-1:0] memory[0:AWIDTH-1];\n\n        always @(posedge clk) begin\n                if (rce)\n                        rq <= memory[ra];\n\n                if (wce)\n                        memory[wa] <= wd;\n        end\n\n        integer i;\n        initial\n        begin\n                for(i = 0; i < AWIDTH-1; i = i + 1)\n                        memory[i] = 0;\n        end\n\nendmodule\n\nmodule BRAM_32x512(\n        clk,\n        rce,\n        ra,\n        rq,\n        wce,\n        wa,\n        wd\n);\n\n        parameter AWIDTH = 9;\n        parameter DWIDTH = 32;\n\n        input  \t\t\tclk;\n        input                   rce;\n        input      [AWIDTH-1:0] ra;\n        output reg [DWIDTH-1:0] rq;\n        input                   wce;\n        input      [AWIDTH-1:0] wa;\n        input      [DWIDTH-1:0] wd;\n\n        BRAM #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n        BRAM_32x512 (   .clk(clk),\n                        .rce(rce),\n                        .ra(ra),\n                        .rq(rq),\n                        .wce(wce),\n                        .wa(wa),\n                        .wd(wd));\n\nendmodule\n\nmodule BRAM_16x1024(\n        clk,\n        rce,\n        ra,\n        rq,\n        wce,\n        wa,\n        wd\n);\n\n        parameter AWIDTH = 10;\n        parameter DWIDTH = 16;\n\n        input  \t\t\tclk;\n        input                   rce;\n        input      [AWIDTH-1:0] ra;\n        output reg [DWIDTH-1:0] rq;\n        input                   wce;\n        input      [AWIDTH-1:0] wa;\n        input      [DWIDTH-1:0] wd;\n\n        BRAM #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n        BRAM_16x1024 (  .clk(clk),\n                        .rce(rce),\n                        .ra(ra),\n                        .rq(rq),\n                        .wce(wce),\n                        .wa(wa),\n                        .wd(wd));\n\n\nendmodule\n\nmodule BRAM_8x2048(\n        clk,\n        rce,\n        ra,\n        rq,\n        wce,\n        wa,\n        wd\n);\n\n        parameter AWIDTH = 11;\n        parameter DWIDTH = 8;\n\n        input  \t\t\tclk;\n        input                   rce;\n        input      [AWIDTH-1:0] ra;\n        output reg [DWIDTH-1:0] rq;\n        input                   wce;\n        input      [AWIDTH-1:0] wa;\n        input      [DWIDTH-1:0] wd;\n\n        BRAM #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n        BRAM_8x2048 (   .clk(clk),\n                        .rce(rce),\n                        .ra(ra),\n                        .rq(rq),\n                        .wce(wce),\n                        .wa(wa),\n                        .wd(wd));\n\n\nendmodule\n\nmodule BRAM_4x4096(\n        clk,\n        rce,\n        ra,\n        rq,\n        wce,\n        wa,\n        wd\n);\n\n        parameter AWIDTH = 12;\n        parameter DWIDTH = 4;\n\n        input  \t\t\tclk;\n        input                   rce;\n        input      [AWIDTH-1:0] ra;\n        output reg [DWIDTH-1:0] rq;\n        input                   wce;\n        input      [AWIDTH-1:0] wa;\n        input      [DWIDTH-1:0] wd;\n\n        BRAM #(.AWIDTH(AWIDTH), .DWIDTH(DWIDTH))\n        BRAM_4x4096 (   .clk(clk),\n                        .rce(rce),\n                        .ra(ra),\n                        .rq(rq),\n                        .wce(wce),\n                        .wa(wa),\n                        .wd(wd));\n\nendmodule\n",
        "module_name": "BRAM #",
        "module_hash": "042190588c22c6a4aaaca8b0c8c0dbad",
        "dataset_index": 23975
      },
      "counter_bcd7fbd5": {
        "rtl_code": "module counter (\n    input clk,\n    input Up,\n    input Down,\n    input Load,\n    input Reset,\n    output reg [2:0] Q\n);\n\n    always @(posedge clk) begin\n        if (Reset) begin\n            Q <= 3'b000;\n        end else if (Load) begin\n            Q <= 3'b111;\n        end else if (Up) begin\n            Q <= Q + 1;\n        end else if (Down) begin\n            Q <= Q - 1;\n        end\n    end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "bcd7fbd547f4e3d778e1d7f52d952877",
        "dataset_index": 6340
      },
      "sky130_fd_sc_hd__a211oi_f66d05d5": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__a211oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2          );\n    nor nor0 (nor0_out_Y, and0_out, B1, C1);\n    buf buf0 (Y         , nor0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a211oi",
        "module_hash": "f66d05d5e915793b87a90923446fc2f2",
        "dataset_index": 18671
      },
      "top__cd95f180": {
        "rtl_code": "module top_module (\n    input [31:0] a,\n    input [31:0] b,\n    input [7:0] ctrl,\n    output [31:0] result,\n    output overflow\n);\n\nwire [31:0] alu_output;\nwire [7:0] adder_output;\nwire overflow_adder;\n\n// Instantiate 32-bit ALU\nalu_32bit alu_inst (\n    .a(a),\n    .b(b),\n    .ctrl(ctrl[3:0]),\n    .result(alu_output)\n);\n\n// Instantiate 8-bit adder/subtractor\nadder_subtractor_8bit adder_inst (\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .ctrl(ctrl[7]),\n    .result(adder_output),\n    .overflow(overflow_adder)\n);\n\n// Bitwise AND operation\nassign result = alu_output & {24'b0, adder_output};\nassign overflow = overflow_adder;\n\nendmodule\n\nmodule alu_32bit (\n    input [31:0] a,\n    input [31:0] b,\n    input [3:0] ctrl,\n    output [31:0] result\n);\n\nreg [31:0] result_reg;\n\nalways @(*) begin\n    case(ctrl)\n        4'b0000: result_reg = a + b;\n        4'b0001: result_reg = a - b;\n        4'b0010: result_reg = a & b;\n        4'b0011: result_reg = a | b;\n        4'b0100: result_reg = a ^ b;\n        4'b0101: result_reg = a << 1;\n        4'b0110: result_reg = a >> 1;\n        default: result_reg = 32'b0;\n    endcase\nend\n\nassign result = result_reg;\n\nendmodule\n\nmodule adder_subtractor_8bit (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output [7:0] result,\n    output overflow\n);\n\nreg [7:0] result_reg;\nreg overflow_reg;\n\nalways @(*) begin\n    if (ctrl) begin\n        result_reg = a - b;\n        overflow_reg = (a[7] & ~b[7] & result_reg[7]) | (~a[7] & b[7] & ~result_reg[7]);\n    end else begin\n        result_reg = a + b;\n        overflow_reg = (a[7] & b[7] & ~result_reg[7]) | (~a[7] & ~b[7] & result_reg[7]);\n    end\nend\n\nassign result = result_reg;\nassign overflow = overflow_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "cd95f180dcbd56f6fbe8e0dd7ab712f3",
        "dataset_index": 2455
      },
      "sky130_fd_sc_ms__nor4bb_3f83eb3d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__nor4bb (\n    Y  ,\n    A  ,\n    B  ,\n    C_N,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n    input  D_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out  ;\n    wire and0_out_Y;\n\n    nor nor0 (nor0_out  , A, B              );\n    and and0 (and0_out_Y, nor0_out, C_N, D_N);\n    buf buf0 (Y         , and0_out_Y        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__nor4bb",
        "module_hash": "3f83eb3d13848f14d176012980e7acfb",
        "dataset_index": 8170
      },
      "HAX1_1d72daa2": {
        "rtl_code": "\nmodule HAX1(\n  input A,\n  input B,\n  output YC,\n  output YS\n);\n\nassign YC = A & B;\nassign YS = A ^ B;\n\nendmodule\n",
        "module_name": "HAX1",
        "module_hash": "1d72daa2f34cf4d5e5d73a9a43b0bb94",
        "dataset_index": 18122
      },
      "led_sreg_driver #_6e208a4b": {
        "rtl_code": "module led_sreg_driver #(\n    // number of LEDs\n    parameter COUNT = 8,\n    // invert output\n    parameter INVERT = 0,\n    // clock prescale\n    parameter PRESCALE = 31\n)\n(\n    input  wire             clk,\n    input  wire             rst,\n\n    input  wire [COUNT-1:0] led,\n\n    output wire             sreg_d,\n    output wire             sreg_ld,\n    output wire             sreg_clk\n);\n\nlocalparam CL_COUNT = $clog2(COUNT+1);\nlocalparam CL_PRESCALE = $clog2(PRESCALE+1);\n\nreg [CL_COUNT-1:0] count_reg = 0;\nreg [CL_PRESCALE-1:0] prescale_count_reg = 0;\nreg enable_reg = 1'b0;\nreg update_reg = 1'b1;\nreg cycle_reg = 1'b0;\n\nreg [COUNT-1:0] led_sync_reg_1 = 0;\nreg [COUNT-1:0] led_sync_reg_2 = 0;\nreg [COUNT-1:0] led_reg = 0;\n\nreg sreg_d_reg = 1'b0;\nreg sreg_ld_reg = 1'b0;\nreg sreg_clk_reg = 1'b0;\n\nassign sreg_d = INVERT ? !sreg_d_reg : sreg_d_reg;\nassign sreg_ld = sreg_ld_reg;\nassign sreg_clk = sreg_clk_reg;\n\nalways @(posedge clk) begin\n    led_sync_reg_1 <= led;\n    led_sync_reg_2 <= led_sync_reg_1;\n\n    enable_reg <= 1'b0;\n\n    if (prescale_count_reg) begin\n        prescale_count_reg <= prescale_count_reg - 1;\n    end else begin\n        enable_reg <= 1'b1;\n        prescale_count_reg <= PRESCALE;\n    end\n\n    if (enable_reg) begin\n        if (cycle_reg) begin\n            cycle_reg <= 1'b0;\n            sreg_clk_reg <= 1'b1;\n        end else if (count_reg) begin\n            sreg_clk_reg <= 1'b0;\n            sreg_ld_reg <= 1'b0;\n\n            if (count_reg < COUNT) begin\n                count_reg <= count_reg + 1;\n                cycle_reg <= 1'b1;\n                sreg_d_reg <= led_reg[count_reg];\n            end else begin\n                count_reg <= 0;\n                cycle_reg <= 1'b0;\n                sreg_d_reg <= 1'b0;\n                sreg_ld_reg <= 1'b1;\n            end\n        end else begin\n            sreg_clk_reg <= 1'b0;\n            sreg_ld_reg <= 1'b0;\n\n            if (update_reg) begin\n                update_reg <= 1'b0;\n\n                count_reg <= 1;\n                cycle_reg <= 1'b1;\n                sreg_d_reg <= led_reg[0];\n            end\n        end\n    end\n\n    if (led_sync_reg_2 != led_reg) begin\n        led_reg <= led_sync_reg_2;\n        update_reg <= 1'b1;\n    end\n\n    if (rst) begin\n        count_reg <= 0;\n        prescale_count_reg <= 0;\n        enable_reg <= 1'b0;\n        update_reg <= 1'b1;\n        cycle_reg <= 1'b0;\n        led_reg <= 0;\n        sreg_d_reg <= 1'b0;\n        sreg_ld_reg <= 1'b0;\n        sreg_clk_reg <= 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "led_sreg_driver #",
        "module_hash": "6e208a4b494e4df5e652b4f72f377c3f",
        "dataset_index": 16602
      },
      "divider_b19898fa": {
        "rtl_code": "module divider(\n    input clk,\n    input rst,\n    input start,\n    input [15:0] dividend,\n    input [15:0] divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder,\n    output reg busy,\n    output reg valid\n);\n\n    reg [31:0] dividend_temp;\n    reg [15:0] divisor_temp;\n    reg [4:0] count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            quotient <= 0;\n            remainder <= 0;\n            dividend_temp <= 0;\n            divisor_temp <= 0;\n            count <= 0;\n            busy <= 0;\n            valid <= 0;\n        end else if (start && !busy) begin\n            dividend_temp <= {16'b0, dividend};  // Load the dividend\n            divisor_temp <= divisor;             // Load the divisor\n            quotient <= 0;                       // Reset the quotient\n            count <= 16;                         // Initialize the count\n            busy <= 1;                           // Set the busy flag\n            valid <= 0;                          // Clear the valid flag\n        end else if (busy) begin\n            if (count > 0) begin\n                // Left shift dividend_temp and bring down the next bit of the dividend\n                dividend_temp <= dividend_temp << 1;\n                // Subtract the divisor from the dividend_temp, if possible\n                if (dividend_temp[31:16] >= divisor) begin\n                    dividend_temp[31:16] <= dividend_temp[31:16] - divisor_temp;\n                    dividend_temp[0] <= 1'b1; // Set the LSB of dividend_temp as part of the quotient\n                end\n                count <= count - 1; // Decrement the count\n            end else begin\n                quotient <= dividend_temp[15:0];  // Final quotient\n                remainder <= dividend_temp[31:16]; // Remainder\n                busy <= 0;                        // Clear the busy flag\n                valid <= 1;                       // Set the valid flag to indicate completion\n            end\n        end\n    end\n\nendmodule\n",
        "module_name": "divider",
        "module_hash": "b19898fa9b6884fa3951faf46924390d",
        "dataset_index": 10176
      },
      "dual_port_mem_0181720a": {
        "rtl_code": "\nmodule dual_port_mem\n(\n    input clk_i,\n    input [15:0] data_i,\n    input [SIZE-1:0] address_i,\n    input [1:0] be_i,\n    input wren_i,\n    output [15:0] data_o\n);\n\nparameter [31:0] SIZE = 8;\n\nreg [7:0] ram_ub [(1 << SIZE) - 1:0];\nreg [7:0] ram_lb [(1 << SIZE) - 1:0];\n\nalways @(posedge clk_i) begin\n    if (wren_i) begin\n        if (!be_i[0] && !be_i[1]) begin\n            ram_lb[address_i] <= data_i[7:0];\n            ram_ub[address_i] <= data_i[15:8];\n        end else if (!be_i[0]) begin\n            ram_lb[address_i] <= data_i[7:0];\n        end else if (!be_i[1]) begin\n            ram_ub[address_i] <= data_i[15:8];\n        end\n    end\nend\n\nassign data_o = {ram_ub[address_i], ram_lb[address_i]};\n\nendmodule",
        "module_name": "dual_port_mem",
        "module_hash": "0181720a2bdc2a6c3f1d11acc1c4c59f",
        "dataset_index": 8289
      },
      "unknown_module_1a6fbdbf": {
        "rtl_code": "module\tlc3_pipeline_stage4(\n\tinput\t\t\treset,\n\tinput\t\t\tclk,\n\tinput\t\t\tstall,\n\tinput\t\t[5:0]\tstate,\n\n\tinput\t\t[19:0]\tI_DR,\n\tinput\t\t[1:0]\tI_WBtype,\n\tinput\t\t[2:0]\tI_Memtype,\n\tinput\t\t[15:0]\tI_Res,\n\n\toutput\t\t[19:0]\tO_DR,\n\toutput\treg\t[1:0]\tO_WBtype,\n\toutput\t\t[15:0]\tO_Res,\n\n\tinput\t\t[15:0]\tmemdata,\n\toutput\t\t[15:0]\tmemaddr,\n\toutput\t\t\tmemtype,\n\toutput\t\t[15:0]\tmemdatawr,\n\toutput\t\t\tmemapply,\n\n\toutput\treg\t[2:0]\tCC,\n\toutput\t\t\tinst_ld\n);\n\t\n\treg\t\t[15:0]\tRes;\n\treg\t\t[19:0]\tDR;\n\treg\t\t[2:0]\tMemtype;\n\tassign\t\t\tmemdatawr=DR[15:0];\n\tassign\t\t\tmemaddr=Res;\n\tassign\t\t\tmemapply=Memtype[2]&state[4];\n\tassign\t\t\tmemtype=Memtype[0];\n\tassign\t\t\tO_Res=( (memapply&~memtype)?memdata:Res );\n\t\n\tassign\t\t\tO_DR=DR;\n\n\talways@(negedge clk or posedge reset)\tbegin\n\t\tif(reset) begin\n\t\t\tend else\tbegin\n\t\t\tif(~stall) begin\n\t\t\t\tDR<=I_DR;\n\t\t\t\tRes<=I_Res;\n\t\t\t\tMemtype<=I_Memtype;\n\t\t\t\tO_WBtype<=I_WBtype;\n\t\t\tend\n\t\tend\n\tend\n\n\talways@(*)\tbegin\n\t\tif(memdata==16'b0)\n\t\t\tCC=3'b010;\n\t\telse if(memdata[15]==1)\n\t\t\tCC=3'b100;\n\t\telse \n\t\t\tCC=3'b001;\n\tend\n\n\tassign\t\t\tinst_ld=Memtype[2]&~Memtype[0];\n\n\t\n\nendmodule\n",
        "module_name": "unknown_module",
        "module_hash": "1a6fbdbfd87421ae0541865f5134dc2d",
        "dataset_index": 12437
      },
      "dffsr_076e8694": {
        "rtl_code": "module dffsr (CLK, D, R, S, Q);\ninput CLK, D, R, S;\noutput Q;\nreg Q;\n\nalways @(posedge CLK) begin\n    if (R) begin\n        Q <= 1'b0;\n    end else if (S) begin\n        Q <= 1'b1;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule",
        "module_name": "dffsr",
        "module_hash": "076e86941ea46d537833e909ae10a26a",
        "dataset_index": 5470
      },
      "GrayCodeStateMachine_2f573a2b": {
        "rtl_code": "module GrayCodeStateMachine (\n  input clk, // clock signal\n  input rst, // reset signal\n  input en, // enable signal\n  output reg [n-1:0] out // output signals\n);\n\nparameter n = 3; // number of output signals\nparameter m = 8; // number of states (2^n)\n\nreg [n-1:0] state; // current state\nreg [n-1:0] next_state; // next state\n\n// Gray code sequence\nalways @(*) begin\n  case(state)\n    0: next_state = 1;\n    1: next_state = 3;\n    2: next_state = 6;\n    3: next_state = 4;\n    4: next_state = 5;\n    5: next_state = 7;\n    6: next_state = 2;\n    7: next_state = 0;\n  endcase\nend\n\n// Output signals\nalways @(posedge clk) begin\n  if (rst) begin\n    state <= 0;\n    out <= 0;\n  end else if (en) begin\n    state <= next_state;\n    out <= state;\n  end\nend\n\nendmodule",
        "module_name": "GrayCodeStateMachine",
        "module_hash": "2f573a2bd921e44befe6fe245cafef7c",
        "dataset_index": 12922
      },
      "uart_transmitter_ccc7aa35": {
        "rtl_code": "module uart_transmitter (\n  input clk,\n  input rst,\n  input [7:0] data_in,\n  output tx\n);\n\n  reg [9:0] shift_reg;\n  reg start_bit;\n  reg stop_bit;\n  reg [3:0] bit_count;\n\n  always @ (posedge clk) begin\n    if (rst) begin\n      shift_reg <= 10'b0;\n      bit_count <= 4'b0;\n      start_bit <= 1'b0;\n      stop_bit <= 1'b1;\n    end else begin\n      if (bit_count == 4'b0) begin\n        shift_reg <= {start_bit, data_in, stop_bit};\n        bit_count <= 4'b1;\n      end else if (bit_count < 4'b10) begin\n        shift_reg <= {shift_reg[8:0], 1'b0};\n        bit_count <= bit_count + 1;\n      end else begin\n        shift_reg <= {shift_reg[8:0], 1'b1};\n        bit_count <= 4'b0;\n      end\n    end\n  end\n\n  assign tx = shift_reg[0];\n\nendmodule\n\nmodule uart_receiver (\n  input clk,\n  input rst,\n  input rx,\n  output reg [7:0] data_out\n);\n\n  reg [9:0] shift_reg;\n  reg start_bit;\n  reg stop_bit;\n  reg [3:0] bit_count;\n\n  always @ (posedge clk) begin\n    if (rst) begin\n      shift_reg <= 10'b0;\n      bit_count <= 4'b0;\n      start_bit <= 1'b0;\n      stop_bit <= 1'b0;\n      data_out <= 8'b0;\n    end else begin\n      if (bit_count == 4'b0) begin\n        start_bit <= rx;\n        bit_count <= 4'b1;\n      end else if (bit_count < 4'b10) begin\n        shift_reg <= {shift_reg[8:0], rx};\n        bit_count <= bit_count + 1;\n      end else begin\n        stop_bit <= rx;\n        data_out <= shift_reg[8:1];\n        bit_count <= 4'b0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "uart_transmitter",
        "module_hash": "ccc7aa35f995cd0c9a41608d0ed0655c",
        "dataset_index": 3201
      },
      "OneCycleStall_b9e8e68a": {
        "rtl_code": "module OneCycleStall(request, clk, resetn, stalled);\ninput request;\ninput clk;\ninput resetn;\noutput stalled;\n\n  reg [1:0] state;\n  reg [1:0] next_state;\n\n  // State machine for stalling 1 cycle\n  always@(state or request) begin\n    case(state)\n      2'b00: next_state = request ? 2'b01 : 2'b00;\n      2'b01: next_state = 2'b10;\n      2'b10: next_state = 2'b00;\n    endcase\n  end\n\n  always@(posedge clk) begin\n    if(!resetn) begin\n      state <= 2'b00;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  assign stalled = (state == 2'b01) ? 1'b1 : 1'b0;\n\nendmodule",
        "module_name": "OneCycleStall",
        "module_hash": "b9e8e68a15eebd6b9e23ca39ea5b64f0",
        "dataset_index": 8743
      },
      "fsm_3input_1output_f837c11d": {
        "rtl_code": "module fsm_3input_1output (\n  input clk,\n  input reset,\n  input a,\n  input b,\n  input c,\n  output reg d\n);\n\n  reg [1:0] state, next_state;\n\n  parameter S0 = 2'b00, S1 = 2'b01;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= S0;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  always @* begin\n    case (state)\n      S0: begin\n        if (a & ~b & ~c) begin\n          next_state = S1;\n          d = 1'b0;\n        end else if (~a & ~b & c) begin\n          next_state = S0;\n          d = 1'b0;\n        end else begin\n          next_state = S0;\n          d = 1'b1;\n        end\n      end\n      S1: begin\n        if (~a & ~b & ~c) begin\n          next_state = S0;\n          d = 1'b1;\n        end else if (~a & ~b & c) begin\n          next_state = S1;\n          d = 1'b1;\n        end else begin\n          next_state = S1;\n          d = 1'b0;\n        end\n      end\n      default: begin\n        next_state = S0;\n        d = 1'b0;\n      end\n    endcase\n  end\n\nendmodule\n",
        "module_name": "fsm_3input_1output",
        "module_hash": "f837c11dcd8a2741a059a748cfc09108",
        "dataset_index": 14681
      },
      "arithmetic_op_2f2e0ad2": {
        "rtl_code": "\nmodule arithmetic_op (\n  output reg [7:0] result,\n  input [7:0] operand1,\n  input [7:0] operand2,\n  input [1:0] select,\n  input clk // Added the 'clk' input\n);\n\n  always @ (posedge clk) begin // Using 'clk' in the sensitivity list\n    case (select)\n      2'b00: result <= operand1 + operand2;\n      2'b01: result <= operand1 - operand2;\n      2'b10: result <= operand1 & operand2;\n      2'b11: result <= operand1 | operand2;\n    endcase\n  end\n\nendmodule\n",
        "module_name": "arithmetic_op",
        "module_hash": "2f2e0ad23535b38583fb6505f8a402ab",
        "dataset_index": 15709
      },
      "axis_crosspoint #_1572d73b": {
        "rtl_code": "\n\n\nmodule axis_crosspoint #\n(\n    parameter S_COUNT = 4,\n    parameter M_COUNT = 4,\n    parameter DATA_WIDTH = 8,\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    parameter KEEP_WIDTH = (DATA_WIDTH/8),\n    parameter LAST_ENABLE = 1,\n    parameter ID_ENABLE = 0,\n    parameter ID_WIDTH = 8,\n    parameter DEST_ENABLE = 0,\n    parameter DEST_WIDTH = 8,\n    parameter USER_ENABLE = 1,\n    parameter USER_WIDTH = 1\n)\n(\n    input  wire                               clk,\n    input  wire                               rst,\n\n    \n    input  wire [S_COUNT*DATA_WIDTH-1:0]      s_axis_tdata,\n    input  wire [S_COUNT*KEEP_WIDTH-1:0]      s_axis_tkeep,\n    input  wire [S_COUNT-1:0]                 s_axis_tvalid,\n    input  wire [S_COUNT-1:0]                 s_axis_tlast,\n    input  wire [S_COUNT*ID_WIDTH-1:0]        s_axis_tid,\n    input  wire [S_COUNT*DEST_WIDTH-1:0]      s_axis_tdest,\n    input  wire [S_COUNT*USER_WIDTH-1:0]      s_axis_tuser,\n\n    \n    output wire [M_COUNT*DATA_WIDTH-1:0]      m_axis_tdata,\n    output wire [M_COUNT*KEEP_WIDTH-1:0]      m_axis_tkeep,\n    output wire [M_COUNT-1:0]                 m_axis_tvalid,\n    output wire [M_COUNT-1:0]                 m_axis_tlast,\n    output wire [M_COUNT*ID_WIDTH-1:0]        m_axis_tid,\n    output wire [M_COUNT*DEST_WIDTH-1:0]      m_axis_tdest,\n    output wire [M_COUNT*USER_WIDTH-1:0]      m_axis_tuser,\n\n    \n    input  wire [M_COUNT*$clog2(S_COUNT)-1:0] select\n);\n\nparameter CL_S_COUNT = $clog2(S_COUNT);\n\nreg [S_COUNT*DATA_WIDTH-1:0] s_axis_tdata_reg = {S_COUNT*DATA_WIDTH{1'b0}};\nreg [S_COUNT*KEEP_WIDTH-1:0] s_axis_tkeep_reg = {S_COUNT*KEEP_WIDTH{1'b0}};\nreg [S_COUNT-1:0]            s_axis_tvalid_reg = {S_COUNT{1'b0}};\nreg [S_COUNT-1:0]            s_axis_tlast_reg = {S_COUNT{1'b0}};\nreg [S_COUNT*ID_WIDTH-1:0]   s_axis_tid_reg = {S_COUNT*ID_WIDTH{1'b0}};\nreg [S_COUNT*DEST_WIDTH-1:0] s_axis_tdest_reg = {S_COUNT*DEST_WIDTH{1'b0}};\nreg [S_COUNT*USER_WIDTH-1:0] s_axis_tuser_reg = {S_COUNT*USER_WIDTH{1'b0}};\n\nreg [M_COUNT*DATA_WIDTH-1:0] m_axis_tdata_reg = {M_COUNT*DATA_WIDTH{1'b0}};\nreg [M_COUNT*KEEP_WIDTH-1:0] m_axis_tkeep_reg = {M_COUNT*KEEP_WIDTH{1'b0}};\nreg [M_COUNT-1:0]            m_axis_tvalid_reg = {M_COUNT{1'b0}};\nreg [M_COUNT-1:0]            m_axis_tlast_reg = {M_COUNT{1'b0}};\nreg [M_COUNT*ID_WIDTH-1:0]   m_axis_tid_reg = {M_COUNT*ID_WIDTH{1'b0}};\nreg [M_COUNT*DEST_WIDTH-1:0] m_axis_tdest_reg = {M_COUNT*DEST_WIDTH{1'b0}};\nreg [M_COUNT*USER_WIDTH-1:0] m_axis_tuser_reg = {M_COUNT*USER_WIDTH{1'b0}};\n\nreg [M_COUNT*CL_S_COUNT-1:0] select_reg = {M_COUNT*CL_S_COUNT{1'b0}};\n\nassign m_axis_tdata  = m_axis_tdata_reg;\nassign m_axis_tkeep  = KEEP_ENABLE ? m_axis_tkeep_reg : {M_COUNT*KEEP_WIDTH{1'b1}};\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast  = LAST_ENABLE ? m_axis_tlast_reg : {M_COUNT{1'b1}};\nassign m_axis_tid    = ID_ENABLE   ? m_axis_tid_reg   : {M_COUNT*ID_WIDTH{1'b0}};\nassign m_axis_tdest  = DEST_ENABLE ? m_axis_tdest_reg : {M_COUNT*DEST_WIDTH{1'b0}};\nassign m_axis_tuser  = USER_ENABLE ? m_axis_tuser_reg : {M_COUNT*USER_WIDTH{1'b0}};\n\ninteger i;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        s_axis_tvalid_reg <= {S_COUNT{1'b0}};\n        m_axis_tvalid_reg <= {S_COUNT{1'b0}};\n        select_reg <= {M_COUNT*CL_S_COUNT{1'b0}};\n    end else begin\n        s_axis_tvalid_reg <= s_axis_tvalid;\n        for (i = 0; i < M_COUNT; i = i + 1) begin\n            m_axis_tvalid_reg[i] <= s_axis_tvalid_reg[select_reg[i*CL_S_COUNT +: CL_S_COUNT]];\n        end\n        select_reg <= select;\n    end\n\n    s_axis_tdata_reg <= s_axis_tdata;\n    s_axis_tkeep_reg <= s_axis_tkeep;\n    s_axis_tlast_reg <= s_axis_tlast;\n    s_axis_tid_reg   <= s_axis_tid;\n    s_axis_tdest_reg <= s_axis_tdest;\n    s_axis_tuser_reg <= s_axis_tuser;\n\n    for (i = 0; i < M_COUNT; i = i + 1) begin\n        m_axis_tdata_reg[i*DATA_WIDTH +: DATA_WIDTH] <= s_axis_tdata_reg[select_reg[i*CL_S_COUNT +: CL_S_COUNT]*DATA_WIDTH +: DATA_WIDTH];\n        m_axis_tkeep_reg[i*KEEP_WIDTH +: KEEP_WIDTH] <= s_axis_tkeep_reg[select_reg[i*CL_S_COUNT +: CL_S_COUNT]*KEEP_WIDTH +: KEEP_WIDTH];\n        m_axis_tlast_reg[i]                          <= s_axis_tlast_reg[select_reg[i*CL_S_COUNT +: CL_S_COUNT]];\n        m_axis_tid_reg[i*ID_WIDTH +: ID_WIDTH]       <= s_axis_tid_reg[select_reg[i*CL_S_COUNT +: CL_S_COUNT]*ID_WIDTH +: ID_WIDTH];\n        m_axis_tdest_reg[i*DEST_WIDTH +: DEST_WIDTH] <= s_axis_tdest_reg[select_reg[i*CL_S_COUNT +: CL_S_COUNT]*DEST_WIDTH +: DEST_WIDTH];\n        m_axis_tuser_reg[i*USER_WIDTH +: USER_WIDTH] <= s_axis_tuser_reg[select_reg[i*CL_S_COUNT +: CL_S_COUNT]*USER_WIDTH +: USER_WIDTH];\n    end\nend\n\nendmodule\n",
        "module_name": "axis_crosspoint #",
        "module_hash": "1572d73bf50bb2da7f3f3514eeefaec4",
        "dataset_index": 8175
      },
      "fifo_counter_10145444": {
        "rtl_code": "module fifo_counter(\n  input empty,\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [4:0] fifo_cnt_inc\n);\n\n  always @(*) begin\n    if (empty) begin\n      fifo_cnt_inc = input_tm_cnt[1:0];\n    end\n    else if (ge3_free && (input_tm_cnt == 2'b11)) begin\n      fifo_cnt_inc = 2;\n    end\n    else if (ge2_free && (input_tm_cnt >= 2)) begin\n      fifo_cnt_inc = 1;\n    end\n    else if (input_tm_cnt >= 1) begin\n      fifo_cnt_inc = 0;\n    end\n    else begin\n      fifo_cnt_inc = 5'b11111;\n    end\n  end\n\nendmodule",
        "module_name": "fifo_counter",
        "module_hash": "101454443258633348e0123c54434725",
        "dataset_index": 20353
      },
      "my__fbaeda0c": {
        "rtl_code": "module my_module (\n    VPWR,\n    VGND,\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1\n);\n\n    // Module ports\n    input  VPWR;\n    input  VGND;\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n\n    // Local signals\n    wire    nand0_out_A1_A2    ;\n    wire    nand1_out_B1_C1    ;\n    wire    nand2_out_D1_or0   ;\n    wire    nand3_out_nand0_nand1;\n    wire    buf0_out_nand3     ;\n\n    //                           Name          Output              Other arguments\n    nand                         nand0        (nand0_out_A1_A2    , A1, A2              );\n    nand                         nand1        (nand1_out_B1_C1    , B1, C1              );\n    or                           or0          (nand2_out_D1_or0   , A2, A1              );\n    nand                         nand2        (nand3_out_nand0_nand1, nand0_out_A1_A2, nand1_out_B1_C1, nand2_out_D1_or0);\n    buf                          buf0         (X                 , buf0_out_nand3     );\n    nand                         nand3        (buf0_out_nand3     , nand3_out_nand0_nand1);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "fbaeda0c5bb29492a9a1d1c019b9c448",
        "dataset_index": 834
      },
      "tone_generator_d7627bf4": {
        "rtl_code": "\nmodule tone_generator (\n  input clk, // clock signal\n  input rst, // reset signal\n  input [1:0] type, // type of waveform to generate\n  input [15:0] freq, // frequency of waveform\n  output reg [7:0] waveform // generated waveform\n);\n\n  reg [7:0] dtmf_waveform [0:15];\n  reg [15:0] sine_counter = 0;\n  reg [15:0] square_counter = 0;\n  reg [7:0] sine_waveform = 0;\n  reg [7:0] square_waveform = 0;\n  reg [7:0] tmp7;\n\n  // DTMF waveform lookup table\n  initial begin\n    dtmf_waveform[0] = 8'b00000000;\n    dtmf_waveform[1] = 8'b00000001;\n    dtmf_waveform[2] = 8'b00000010;\n    dtmf_waveform[3] = 8'b00000011;\n    dtmf_waveform[4] = 8'b00000100;\n    dtmf_waveform[5] = 8'b00000101;\n    dtmf_waveform[6] = 8'b00000110;\n    dtmf_waveform[7] = 8'b00000111;\n    dtmf_waveform[8] = 8'b00001000;\n    dtmf_waveform[9] = 8'b00001001;\n    dtmf_waveform[10] = 8'b00001010;\n    dtmf_waveform[11] = 8'b00001011;\n    dtmf_waveform[12] = 8'b00001100;\n    dtmf_waveform[13] = 8'b00001101;\n    dtmf_waveform[14] = 8'b00001110;\n    dtmf_waveform[15] = 8'b00001111;\n  end\n\n  // DTMF waveform generation\n  always @ (posedge clk, posedge rst) begin\n    if (rst) begin\n      waveform <= 8'b00000000;\n    end else begin\n      if (type == 2'b00) begin // DTMF\n        waveform <= dtmf_waveform[freq];\n      end else if (type == 2'b01) begin // sine wave\n        sine_counter <= sine_counter + freq;\n        sine_waveform <= $signed(8'b10000000) >> (sine_counter / 32768);\n      end else begin // square wave\n        square_counter <= square_counter + freq;\n        if (square_counter >= 16384) begin\n          square_waveform <= 8'b11111111;\n        end else begin\n          square_waveform <= 8'b00000000;\n        end\n      end\n      waveform <= (type == 2'b00) ? dtmf_waveform[freq] : ((type == 2'b01) ? sine_waveform : square_waveform);\n    end\n  end\n\nendmodule",
        "module_name": "tone_generator",
        "module_hash": "d7627bf41aabe9d7790aa3208c3b2393",
        "dataset_index": 17896
      },
      "axi_crossbar_v2_1_10_addr_arbiter #_95407c6f": {
        "rtl_code": "\n\n\n \nmodule axi_crossbar_v2_1_10_addr_arbiter #\n  (\n   parameter         C_FAMILY                         = \"none\", \n   parameter integer C_NUM_S                = 1, \n   parameter integer C_NUM_S_LOG                = 1, \n   parameter integer C_NUM_M               = 1, \n   parameter integer C_MESG_WIDTH                 = 1, \n   parameter [C_NUM_S*32-1:0] C_ARB_PRIORITY             = {C_NUM_S{32'h00000000}}\n                       )\n  (\n   input  wire                                      ACLK,\n   input  wire                                      ARESET,\n   input  wire [C_NUM_S*C_MESG_WIDTH-1:0]  S_MESG,\n   input  wire [C_NUM_S*C_NUM_M-1:0]                S_TARGET_HOT,\n   input  wire [C_NUM_S-1:0]                S_VALID,\n   input  wire [C_NUM_S-1:0]                S_VALID_QUAL,\n   output wire [C_NUM_S-1:0]                S_READY,\n   output wire [C_MESG_WIDTH-1:0]                    M_MESG,\n   output wire [C_NUM_M-1:0]                           M_TARGET_HOT,\n   output wire [C_NUM_S_LOG-1:0]                      M_GRANT_ENC,\n   output wire                                        M_VALID,\n   input  wire                                        M_READY,\n   input  wire [C_NUM_M-1:0]                ISSUING_LIMIT\n   );\n   \n  function [C_NUM_S-1:0] f_prio_mask\n    (\n      input integer null_arg\n    );\n    reg   [C_NUM_S-1:0]            mask;\n    integer                        i;    \n    begin\n      mask = 0;    \n      for (i=0; i < C_NUM_S; i=i+1) begin\n        mask[i] = (C_ARB_PRIORITY[i*32+:32] != 0);\n      end \n      f_prio_mask = mask;\n    end   \n  endfunction\n  \n  function [3:0] f_hot2enc\n    (\n      input [15:0]  one_hot\n    );\n    begin\n      f_hot2enc[0] = |(one_hot & 16'b1010101010101010);\n      f_hot2enc[1] = |(one_hot & 16'b1100110011001100);\n      f_hot2enc[2] = |(one_hot & 16'b1111000011110000);\n      f_hot2enc[3] = |(one_hot & 16'b1111111100000000);\n    end\n  endfunction\n\n  localparam [C_NUM_S-1:0] P_PRIO_MASK = f_prio_mask(0);\n\n  reg                     m_valid_i;\n  reg [C_NUM_S-1:0]       s_ready_i;\n  reg [C_NUM_S-1:0]       qual_reg;\n  reg [C_NUM_S-1:0]       grant_hot; \n  reg [C_NUM_S-1:0]       last_rr_hot;\n  reg                     any_grant;\n  reg                     any_prio;\n  reg                     found_prio;\n  reg [C_NUM_S-1:0]       which_prio_hot;\n  reg [C_NUM_S-1:0]       next_prio_hot;\n  reg [C_NUM_S_LOG-1:0]   which_prio_enc;          \n  reg [C_NUM_S_LOG-1:0]   next_prio_enc;    \n  reg [4:0]               current_highest;\n  wire [C_NUM_S-1:0]      valid_rr;\n  reg [15:0]              next_rr_hot;\n  reg [C_NUM_S_LOG-1:0]   next_rr_enc;    \n  reg [C_NUM_S*C_NUM_S-1:0] carry_rr;\n  reg [C_NUM_S*C_NUM_S-1:0] mask_rr;\n  reg                     found_rr;\n  wire [C_NUM_S-1:0]      next_hot;\n  wire [C_NUM_S_LOG-1:0]  next_enc;    \n  reg                     prio_stall;\n  integer                 i;\n  wire [C_NUM_S-1:0]      valid_qual_i;\n  reg  [C_NUM_S_LOG-1:0]  m_grant_enc_i;\n  reg  [C_NUM_M-1:0]      m_target_hot_i;\n  wire [C_NUM_M-1:0]      m_target_hot_mux;\n  reg  [C_MESG_WIDTH-1:0] m_mesg_i;\n  wire [C_MESG_WIDTH-1:0] m_mesg_mux;\n  genvar                  gen_si;\n\n  assign M_VALID = m_valid_i;\n  assign S_READY = s_ready_i;\n  assign M_GRANT_ENC = m_grant_enc_i;\n  assign M_MESG = m_mesg_i;\n  assign M_TARGET_HOT = m_target_hot_i;\n  \n  generate\n    if (C_NUM_S>1) begin : gen_arbiter\n      \n      always @(posedge ACLK) begin\n        if (ARESET) begin\n          qual_reg <= 0;\n        end else begin \n          qual_reg <= valid_qual_i | ~S_VALID; end\n      end\n    \n      for (gen_si=0; gen_si<C_NUM_S; gen_si=gen_si+1) begin : gen_req_qual\n        assign valid_qual_i[gen_si] = S_VALID_QUAL[gen_si] & (|(S_TARGET_HOT[gen_si*C_NUM_M+:C_NUM_M] & ~ISSUING_LIMIT));\n      end\n    \n      assign next_hot = found_prio ? next_prio_hot : next_rr_hot;\n      assign next_enc = found_prio ? next_prio_enc : next_rr_enc;\n      \n      always @(posedge ACLK) begin\n        if (ARESET) begin\n          m_valid_i <= 0;\n          s_ready_i <= 0;\n          grant_hot <= 0;\n          any_grant <= 1'b0;\n          m_grant_enc_i <= 0;\n          last_rr_hot <= {1'b1, {C_NUM_S-1{1'b0}}};\n          m_target_hot_i <= 0;\n        end else begin\n          s_ready_i <= 0;\n          if (m_valid_i) begin\n            if (M_READY) begin  m_valid_i <= 1'b0;\n              grant_hot <= 0;\n              any_grant <= 1'b0;\n            end\n          end else if (any_grant) begin\n            m_valid_i <= 1'b1;\n            s_ready_i <= grant_hot;  end else begin\n            if ((found_prio | found_rr) & ~prio_stall) begin\n              if (|(next_hot & valid_qual_i)) begin  \n                grant_hot <= next_hot;\n                m_grant_enc_i <= next_enc;\n                any_grant <= 1'b1;\n                if (~found_prio) begin\n                  last_rr_hot <= next_rr_hot;\n                end\n                m_target_hot_i <= m_target_hot_mux;\n              end\n            end\n          end\n        end\n      end\n    \n      always @ * begin : ALG_PRIO\n        integer ip;\n        any_prio = 1'b0;\n        prio_stall = 1'b0;\n        which_prio_hot = 0;        \n        which_prio_enc = 0;    \n        current_highest = 0;    \n        for (ip=0; ip < C_NUM_S; ip=ip+1) begin\n          if (P_PRIO_MASK[ip] & S_VALID[ip] & qual_reg[ip]) begin\n            if ({1'b0, C_ARB_PRIORITY[ip*32+:4]} > current_highest) begin\n              current_highest[0+:4] = C_ARB_PRIORITY[ip*32+:4];\n              if (s_ready_i[ip]) begin\n                any_prio = 1'b0;\n                prio_stall = 1'b1;\n                which_prio_hot = 0;\n                which_prio_enc = 0;\n              end else begin\n                any_prio = 1'b1;\n                which_prio_hot = 1'b1 << ip;\n                which_prio_enc = ip;\n              end\n            end\n          end   \n        end\n        found_prio = any_prio;\n        next_prio_hot = which_prio_hot;\n        next_prio_enc = which_prio_enc;\n      end\n     \n      assign valid_rr = ~P_PRIO_MASK & S_VALID & ~s_ready_i & qual_reg;\n      \n      always @ * begin : ALG_RR\n        integer ir, jr, nr;\n        next_rr_hot = 0;\n        for (ir=0;ir<C_NUM_S;ir=ir+1) begin\n          nr = (ir>0) ? (ir-1) : (C_NUM_S-1);\n          carry_rr[ir*C_NUM_S] = last_rr_hot[nr];\n          mask_rr[ir*C_NUM_S] = ~valid_rr[nr];\n          for (jr=1;jr<C_NUM_S;jr=jr+1) begin\n            nr = (ir-jr > 0) ? (ir-jr-1) : (C_NUM_S+ir-jr-1);\n            carry_rr[ir*C_NUM_S+jr] = carry_rr[ir*C_NUM_S+jr-1] | (last_rr_hot[nr] & mask_rr[ir*C_NUM_S+jr-1]);\n            if (jr < C_NUM_S-1) begin\n              mask_rr[ir*C_NUM_S+jr] = mask_rr[ir*C_NUM_S+jr-1] & ~valid_rr[nr];\n            end\n          end   \n          next_rr_hot[ir] = valid_rr[ir] & carry_rr[(ir+1)*C_NUM_S-1];\n        end\n        next_rr_enc = f_hot2enc(next_rr_hot);\n        found_rr = |(next_rr_hot);\n      end\n  \n      generic_baseblocks_v2_1_0_mux_enc # \n        (\n         .C_FAMILY      (\"rtl\"),\n         .C_RATIO       (C_NUM_S),\n         .C_SEL_WIDTH   (C_NUM_S_LOG),\n         .C_DATA_WIDTH  (C_MESG_WIDTH)\n        ) mux_mesg \n        (\n         .S   (m_grant_enc_i),\n         .A   (S_MESG),\n         .O   (m_mesg_mux),\n         .OE  (1'b1)\n        ); \n        \n      generic_baseblocks_v2_1_0_mux_enc # \n        (\n         .C_FAMILY      (\"rtl\"),\n         .C_RATIO       (C_NUM_S),\n         .C_SEL_WIDTH   (C_NUM_S_LOG),\n         .C_DATA_WIDTH  (C_NUM_M)\n        ) si_amesg_mux_inst \n        (\n         .S   (next_enc),\n         .A   (S_TARGET_HOT),\n         .O   (m_target_hot_mux),\n         .OE  (1'b1)\n        ); \n        \n      always @(posedge ACLK) begin\n        if (ARESET) begin\n          m_mesg_i <= 0;\n        end else if (~m_valid_i) begin\n          m_mesg_i <= m_mesg_mux;\n        end\n      end\n    \n    end else begin : gen_no_arbiter\n      \n      assign valid_qual_i = S_VALID_QUAL & |(S_TARGET_HOT & ~ISSUING_LIMIT);\n      \n      always @ (posedge ACLK) begin\n        if (ARESET) begin\n          m_valid_i <= 1'b0;\n          s_ready_i <= 1'b0;\n          m_grant_enc_i <= 0;\n        end else begin\n          s_ready_i <= 1'b0;\n          if (m_valid_i) begin\n            if (M_READY) begin\n              m_valid_i <= 1'b0;\n            end\n          end else if (S_VALID[0] & valid_qual_i[0] & ~s_ready_i) begin\n            m_valid_i <= 1'b1;\n            s_ready_i <= 1'b1;\n            m_target_hot_i <= S_TARGET_HOT;\n          end\n        end\n      end\n      always @(posedge ACLK) begin\n        if (ARESET) begin\n          m_mesg_i <= 0;\n        end else if (~m_valid_i) begin\n          m_mesg_i <= S_MESG;\n        end\n      end\n      \n      \n    end  endgenerate\nendmodule\n\n",
        "module_name": "axi_crossbar_v2_1_10_addr_arbiter #",
        "module_hash": "95407c6fef8f2dccc3228948a1a2bd43",
        "dataset_index": 25605
      },
      "three_input_or_gate_92d244a1": {
        "rtl_code": "module three_input_or_gate (\n    input A,\n    input B,\n    input C_N,\n    output X,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    wire or_output;\n    \n    or_gate_3 or_gate (\n        .X(or_output),\n        .A(A),\n        .B(B),\n        .C_N(C_N),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n    \n    assign X = or_output;\n    \nendmodule\n\nmodule or_gate_3 (\n    input A,\n    input B,\n    input C_N,\n    output X,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    assign X = A | B | ~C_N | VPWR | VGND | VPB | VNB;\n\nendmodule\n\n",
        "module_name": "three_input_or_gate",
        "module_hash": "92d244a1b68e7e144ea94428a988cd61",
        "dataset_index": 1563
      },
      "apu_mixer_6c26ffe2": {
        "rtl_code": "\n\nmodule apu_mixer\n(\n  input  wire       clk_in,       input  wire       rst_in,       input  wire [3:0] mute_in,      input  wire [3:0] pulse0_in,    input  wire [3:0] pulse1_in,    input  wire [3:0] triangle_in,  input  wire [3:0] noise_in,     output wire       audio_out     );\n\nwire [3:0] pulse0;\nwire [3:0] pulse1;\nwire [3:0] triangle;\nwire [3:0] noise;\n\nreg [4:0] pulse_in_total;\nreg [5:0] pulse_out;\n\nreg [6:0] tnd_in_total;\nreg [5:0] tnd_out;\n\nreg [5:0] mixed_out;\n\nalways @*\n  begin\n    pulse_in_total = pulse0 + pulse1;\n\n    case (pulse_in_total)\n      5'h00:   pulse_out = 6'h00;\n      5'h01:   pulse_out = 6'h01;\n      5'h02:   pulse_out = 6'h01;\n      5'h03:   pulse_out = 6'h02;\n      5'h04:   pulse_out = 6'h03;\n      5'h05:   pulse_out = 6'h03;\n      5'h06:   pulse_out = 6'h04;\n      5'h07:   pulse_out = 6'h05;\n      5'h08:   pulse_out = 6'h05;\n      5'h09:   pulse_out = 6'h06;\n      5'h0A:   pulse_out = 6'h07;\n      5'h0B:   pulse_out = 6'h07;\n      5'h0C:   pulse_out = 6'h08;\n      5'h0D:   pulse_out = 6'h08;\n      5'h0E:   pulse_out = 6'h09;\n      5'h0F:   pulse_out = 6'h09;\n      5'h10:   pulse_out = 6'h0A;\n      5'h11:   pulse_out = 6'h0A;\n      5'h12:   pulse_out = 6'h0B;\n      5'h13:   pulse_out = 6'h0B;\n      5'h14:   pulse_out = 6'h0C;\n      5'h15:   pulse_out = 6'h0C;\n      5'h16:   pulse_out = 6'h0D;\n      5'h17:   pulse_out = 6'h0D;\n      5'h18:   pulse_out = 6'h0E;\n      5'h19:   pulse_out = 6'h0E;\n      5'h1A:   pulse_out = 6'h0F;\n      5'h1B:   pulse_out = 6'h0F;\n      5'h1C:   pulse_out = 6'h0F;\n      5'h1D:   pulse_out = 6'h10;\n      5'h1E:   pulse_out = 6'h10;\n      default: pulse_out = 6'bxxxxxx;\n    endcase\n\n    tnd_in_total = { triangle, 1'b0 } + { 1'b0, triangle } + { noise, 1'b0 };\n\n    case (tnd_in_total)\n      7'h00:   tnd_out = 6'h00;\n      7'h01:   tnd_out = 6'h01;\n      7'h02:   tnd_out = 6'h01;\n      7'h03:   tnd_out = 6'h02;\n      7'h04:   tnd_out = 6'h03;\n      7'h05:   tnd_out = 6'h03;\n      7'h06:   tnd_out = 6'h04;\n      7'h07:   tnd_out = 6'h05;\n      7'h08:   tnd_out = 6'h05;\n      7'h09:   tnd_out = 6'h06;\n      7'h0A:   tnd_out = 6'h07;\n      7'h0B:   tnd_out = 6'h07;\n      7'h0C:   tnd_out = 6'h08;\n      7'h0D:   tnd_out = 6'h08;\n      7'h0E:   tnd_out = 6'h09;\n      7'h0F:   tnd_out = 6'h09;\n      7'h10:   tnd_out = 6'h0A;\n      7'h11:   tnd_out = 6'h0A;\n      7'h12:   tnd_out = 6'h0B;\n      7'h13:   tnd_out = 6'h0B;\n      7'h14:   tnd_out = 6'h0C;\n      7'h15:   tnd_out = 6'h0C;\n      7'h16:   tnd_out = 6'h0D;\n      7'h17:   tnd_out = 6'h0D;\n      7'h18:   tnd_out = 6'h0E;\n      7'h19:   tnd_out = 6'h0E;\n      7'h1A:   tnd_out = 6'h0F;\n      7'h1B:   tnd_out = 6'h0F;\n      7'h1C:   tnd_out = 6'h0F;\n      7'h1D:   tnd_out = 6'h10;\n      7'h1E:   tnd_out = 6'h10;\n      7'h1F:   tnd_out = 6'h11;\n      7'h20:   tnd_out = 6'h11;\n      7'h21:   tnd_out = 6'h11;\n      7'h22:   tnd_out = 6'h12;\n      7'h23:   tnd_out = 6'h12;\n      7'h24:   tnd_out = 6'h12;\n      7'h25:   tnd_out = 6'h13;\n      7'h26:   tnd_out = 6'h13;\n      7'h27:   tnd_out = 6'h14;\n      7'h28:   tnd_out = 6'h14;\n      7'h29:   tnd_out = 6'h14;\n      7'h2A:   tnd_out = 6'h15;\n      7'h2B:   tnd_out = 6'h15;\n      7'h2C:   tnd_out = 6'h15;\n      7'h2D:   tnd_out = 6'h15;\n      7'h2E:   tnd_out = 6'h16;\n      7'h2F:   tnd_out = 6'h16;\n      7'h30:   tnd_out = 6'h16;\n      7'h31:   tnd_out = 6'h17;\n      7'h32:   tnd_out = 6'h17;\n      7'h33:   tnd_out = 6'h17;\n      7'h34:   tnd_out = 6'h17;\n      7'h35:   tnd_out = 6'h18;\n      7'h36:   tnd_out = 6'h18;\n      7'h37:   tnd_out = 6'h18;\n      7'h38:   tnd_out = 6'h19;\n      7'h39:   tnd_out = 6'h19;\n      7'h3A:   tnd_out = 6'h19;\n      7'h3B:   tnd_out = 6'h19;\n      7'h3C:   tnd_out = 6'h1A;\n      7'h3D:   tnd_out = 6'h1A;\n      7'h3E:   tnd_out = 6'h1A;\n      7'h3F:   tnd_out = 6'h1A;\n      7'h40:   tnd_out = 6'h1B;\n      7'h41:   tnd_out = 6'h1B;\n      7'h42:   tnd_out = 6'h1B;\n      7'h43:   tnd_out = 6'h1B;\n      7'h44:   tnd_out = 6'h1B;\n      7'h45:   tnd_out = 6'h1C;\n      7'h46:   tnd_out = 6'h1C;\n      7'h47:   tnd_out = 6'h1C;\n      7'h48:   tnd_out = 6'h1C;\n      7'h49:   tnd_out = 6'h1C;\n      7'h4A:   tnd_out = 6'h1D;\n      7'h4B:   tnd_out = 6'h1D;\n      default: tnd_out = 6'bxxxxxx;\n    endcase\n\n    mixed_out = pulse_out + tnd_out;\n  end\n\nreg  [5:0] q_pwm_cnt;\nwire [5:0] d_pwm_cnt;\n\nalways @(posedge clk_in)\n  begin\n    if (rst_in)\n      begin\n        q_pwm_cnt  <= 6'h0;\n      end\n    else\n      begin\n        q_pwm_cnt  <= d_pwm_cnt;\n      end\n  end\n\nassign d_pwm_cnt = q_pwm_cnt + 4'h1;\n\nassign pulse0   = (mute_in[0]) ? 4'h0 : pulse0_in;\nassign pulse1   = (mute_in[1]) ? 4'h0 : pulse1_in;\nassign triangle = (mute_in[2]) ? 4'h0 : triangle_in;\nassign noise    = (mute_in[3]) ? 4'h0 : noise_in;\n\nassign audio_out = mixed_out > q_pwm_cnt;\n\nendmodule\n\n",
        "module_name": "apu_mixer",
        "module_hash": "6c26ffe24f07dcb0656165ce968767fc",
        "dataset_index": 22878
      },
      "flip_flop_c899cbf6": {
        "rtl_code": "module flip_flop (\n    input clk,\n    input reset,           // Asynchronous active-high reset\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(negedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n\nmodule transition_detector (\n    input clk,\n    input reset,           // Synchronous active-high reset\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 32'b0;\n        prev_in <= 32'b0;\n    end else begin\n        out <= (in & ~prev_in);\n        prev_in <= in;\n    end\nend\n\nendmodule\n\nmodule bitwise_or (\n    input [7:0] in1,\n    input [31:0] in2,\n    output reg [7:0] out\n);\n\nalways @* begin\n    out = in1 | in2[7:0];\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,           // Synchronous active-high reset\n    input [7:0] d,\n    input [31:0] in,\n    output reg [7:0] q\n);\n\nwire [31:0] transition_out;\nwire [7:0] flip_flop_out;\n\nflip_flop ff (\n    .clk(clk),\n    .reset(reset),\n    .d(d),\n    .q(flip_flop_out)\n);\n\ntransition_detector td (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(transition_out)\n);\n\nbitwise_or bo (\n    .in1(flip_flop_out),\n    .in2(transition_out),\n    .out(q)\n);\n\nendmodule",
        "module_name": "flip_flop",
        "module_hash": "c899cbf648231915fe97fe531d508a75",
        "dataset_index": 11625
      },
      "Display_1da8e5eb": {
        "rtl_code": "module Display(\n  input clk,                 // clock signal\n  input [15:0] num,          // number to display\n  input [3:0] flash,         // flash signal\n  output reg [7:0] display,  // 7-segment display control signal\n  output reg [3:0] an        // digit selection signal\n  );\n  \n  reg flash_state;  // current state of flashing, 1 => flashing\n  reg [3:0] tmp;    // temporary variable for selecting digits\n  reg [15:0] counter;  // counter for delaying digit selection\n  reg [31:0] flash_counter;  // counter for delaying flashing\n  \n  // constants for setting counter limits\n  parameter [15:0] MAX_COUNTER = 16'D5_0000;\n  parameter [31:0] MAX_FLASH_COUNTER = 32'D5000_0000;\n  \n  // initialize variables\n  initial begin\n    tmp = 4'B0111;  // start with leftmost digit\n    counter = 0;\n    flash_counter = 0;\n    flash_state = 0;\n  end\n\n  // always block for selecting which segments to display\n  always@(tmp) begin\n    case(tmp)\n      4'B0111: display = num[15:12];  // leftmost digit\n      4'B1011: display = num[11:8];   // second digit from left\n      4'B1101: display = num[7:4];    // third digit from left\n      4'B1110: display = num[3:0];    // rightmost digit\n    endcase\n    // segment values for each digit\n    case(display)\n      4'H0: display = 8'B0000_0011;\n      4'H1: display = 8'B1001_1111;\n      4'H2: display = 8'B0010_0101;\n      4'H3: display = 8'B0000_1101;\n      4'H4: display = 8'B1001_1001;\n      4'H5: display = 8'B0100_1001;\n      4'H6: display = 8'B0100_0001;\n      4'H7: display = 8'B0001_1111;\n      4'H8: display = 8'B0000_0001;\n      4'H9: display = 8'B0000_1001;\n    endcase\n  end\n\n  // always block for selecting which digit to display\n  always@(posedge clk) begin\n    // select next digit after delay\n    counter = counter + 1;\n    if(counter == MAX_COUNTER) begin\n      tmp = (tmp >> 1) + 4'B1000;\n      counter = 0;\n    end\n    // wrap back to leftmost digit after displaying rightmost digit\n    if(tmp == 4'B1111) begin\n      tmp = 4'B0111;\n    end\n    // alternate between flashing and non-flashing\n    flash_counter = flash_counter + 1;\n    if(flash_counter == MAX_FLASH_COUNTER) begin\n      flash_counter = 0;\n      flash_state = ~flash_state;\n    end\n    // set digit selection signal based on flash and current digit\n    if(flash_state) an = tmp | flash;\n    else an = tmp;\n  end\n\nendmodule",
        "module_name": "Display",
        "module_hash": "1da8e5ebdc337b788ec063b877e69478",
        "dataset_index": 14600
      },
      "top__3ca6fed8": {
        "rtl_code": "\nmodule top_module (\n    input clk,             // Clock input\n    input reset,           // Synchronous active-high reset\n    input [7:0] data_in,   // 8-bit input data\n    input select,          // Select input to choose between accumulator modules\n    output [9:0] data_out, // 10-bit output from the active accumulator module\n    output ready_a,        // Output ready signal for upstream module\n    input ready_b,         // Input ready signal from downstream module\n    input valid_b          // Input valid signal from downstream module\n);\n\n// First accumulator module using counter-based architecture\nreg [7:0] acc1;\nreg [2:0] count1;\nalways @(posedge clk) begin\n    if (reset) begin\n        acc1 <= 0;\n        count1 <= 0;\n    end else begin\n        if (count1 == 7) begin\n            acc1 <= acc1 + data_in;\n            count1 <= 0;\n        end else begin\n            count1 <= count1 + 1;\n        end\n    end\nend\n\n// Second accumulator module using pipeline structure\nreg [7:0] acc2;\nreg [7:0] sum;\nreg [1:0] count2;\nwire valid_a;        // Output valid signal for active accumulator module\nalways @(posedge clk) begin\n    if (reset) begin\n        acc2 <= 0;\n        sum <= 0;\n        count2 <= 0;\n    end else begin\n        if (count2 == 1) begin\n            sum <= sum + data_in;\n            acc2 <= acc2 + sum;\n            sum <= 0;\n            count2 <= 0;\n        end else begin\n            sum <= sum + data_in;\n            count2 <= count2 + 1;\n        end\n    end\nend\n\n// Control logic to select active accumulator module\nreg [1:0] select_reg;\nalways @(posedge clk) begin\n    if (reset) begin\n        select_reg <= 0;\n    end else begin\n        select_reg <= select;\n    end\nend\n\n// Output data from active accumulator module\nassign data_out = select_reg == 0 ? {acc1, 2'b00} : {acc2, 2'b00};\nassign ready_a = ~select_reg ? valid_b : valid_b;\nassign valid_a = select_reg == 0 ? count1 == 7 : count2 == 1;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "3ca6fed8995683ec6c0391388cd72375",
        "dataset_index": 11245
      },
      "top__2a9d313f": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input select,\n    output reg [7:0] final_output\n);\n\nwire [1:0] out2;\nwire [1:0] out1;\nwire [1:0] out0;\nwire [1:0] mux_out; \n\nsplit_input split_input_inst (\n    .in_vec(data_in),\n    .out2(out2),\n    .out1(out1),\n    .out0(out0)\n);\n\nmux mux_inst (\n    .a(out0),\n    .b(out1),\n    .c(out2),\n    .s(select),\n    .out(mux_out)\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        final_output <= 8'b00000000;\n    end else begin\n        final_output <= {6'b000000, mux_out}; \n    end\nend\n\nendmodule\n\n\nmodule split_input (\n    input wire [7:0] in_vec,\n    output reg [1:0] out2,\n    output reg [1:0] out1,\n    output reg [1:0] out0\n);\n\nalways @(*) begin\n    out2 = in_vec[7:6];\n    out1 = in_vec[5:4];\n    out0 = in_vec[3:2];\nend\n\nendmodule\n\nmodule mux (\n    input [1:0] a, b, c,\n    input s,\n    output reg [1:0] out \n);\n\nalways @(*) begin\n    case (s)\n        1'b0: out = a;\n        1'b1: out = b;\n        default: out = 2'b00; \n    endcase\nend\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "2a9d313f62cfc7780488e62d4f3113fc",
        "dataset_index": 291
      },
      "counter_1aee1657": {
        "rtl_code": "module counter (\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset == 0) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "counter",
        "module_hash": "1aee16574021cb2bfc286ee6dd89cb9e",
        "dataset_index": 1576
      },
      "rotator__e0620285": {
        "rtl_code": "\nmodule rotator_module (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data_in,\n    output [99:0] data_out\n);\n\nreg [99:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data_in;\n    end else begin\n        if (ena == 2'b01) begin\n            shift_reg <= {shift_reg[98:0], shift_reg[99]};\n        end else if (ena == 2'b10) begin\n            shift_reg <= {shift_reg[1:99], shift_reg[0]};\n        end\n    end\nend\n\nassign data_out = shift_reg;\n\nendmodule\nmodule six_to_one_mux (\n    input [99:0] data0,\n    input [99:0] data1,\n    input [99:0] data2,\n    input [99:0] data3,\n    input [99:0] data4,\n    input [99:0] data5,\n    input [2:0] sel,\n    output [99:0] q\n);\n\nreg [99:0] q;\n\nalways @(*) begin\n    case (sel)\n        3'b000: q = data0;\n        3'b001: q = data1;\n        3'b010: q = data2;\n        3'b011: q = data3;\n        3'b100: q = data4;\n        3'b101: q = data5;\n        default: q = data0;\n    endcase\nend\n\nendmodule\nmodule functional_module (\n    input [99:0] rotator_out,\n    input [99:0] mux_out,\n    output [99:0] q\n);\n\nreg [99:0] q;\n\nalways @(*) begin\n    q = rotator_out | mux_out;\nend\n\nendmodule\nmodule top_module ( \n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data0,\n    input [99:0] data1,\n    input [99:0] data2,\n    input [99:0] data3,\n    input [99:0] data4,\n    input [99:0] data5,\n    input [2:0] sel,\n    output [99:0] q \n);\n\nwire [99:0] rotator_out;\nwire [99:0] mux_out;\n\nrotator_module rotator_inst (\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data_in(q),\n    .data_out(rotator_out)\n);\n\nsix_to_one_mux mux_inst (\n    .data0(data0),\n    .data1(data1),\n    .data2(data2),\n    .data3(data3),\n    .data4(data4),\n    .data5(data5),\n    .sel(sel),\n    .q(mux_out)\n);\n\nfunctional_module func_inst (\n    .rotator_out(rotator_out),\n    .mux_out(mux_out),\n    .q(q)\n);\n\nendmodule",
        "module_name": "rotator_",
        "module_hash": "e0620285a7b8752e605c6d2665c3ff70",
        "dataset_index": 827
      },
      "controllerPeripheralHdlAdi_tc_f83ef180": {
        "rtl_code": "\n\nmodule controllerPeripheralHdlAdi_tc\n          (\n           CLK_IN,\n           reset,\n           clk_enable,\n           enb,\n           enb_1_1_1,\n           enb_1_2000_0,\n           enb_1_2000_1\n          );\n\n\n  input   CLK_IN;\n  input   reset;\n  input   clk_enable;\n  output  enb;\n  output  enb_1_1_1;\n  output  enb_1_2000_0;\n  output  enb_1_2000_1;\n\n\n  reg [10:0] count2000;  wire phase_all;\n  reg  phase_0;\n  wire phase_0_tmp;\n  reg  phase_1;\n  wire phase_1_tmp;\n\n\n  always @ ( posedge CLK_IN)\n    begin: Counter2000\n      if (reset == 1'b1) begin\n        count2000 <= 11'b00000000001;\n      end\n      else begin\n        if (clk_enable == 1'b1) begin\n          if (count2000 == 11'b11111001111) begin\n            count2000 <= 11'b00000000000;\n          end\n          else begin\n            count2000 <= count2000 + 1;\n          end\n        end\n      end\n    end assign  phase_all = clk_enable? 1 : 0;\n\n  always @ ( posedge CLK_IN)\n    begin: temp_process1\n      if (reset == 1'b1) begin\n        phase_0 <= 1'b0;\n      end\n      else begin\n        if (clk_enable == 1'b1) begin\n          phase_0 <= phase_0_tmp;\n        end\n      end\n    end assign  phase_0_tmp = (count2000 == 11'b11111001111 && clk_enable == 1'b1)? 1 : 0;\n\n  always @ ( posedge CLK_IN)\n    begin: temp_process2\n      if (reset == 1'b1) begin\n        phase_1 <= 1'b1;\n      end\n      else begin\n        if (clk_enable == 1'b1) begin\n          phase_1 <= phase_1_tmp;\n        end\n      end\n    end assign  phase_1_tmp = (count2000 == 11'b00000000000 && clk_enable == 1'b1)? 1 : 0;\n\n  assign enb =  phase_all & clk_enable;\n\n  assign enb_1_1_1 =  phase_all & clk_enable;\n\n  assign enb_1_2000_0 =  phase_0 & clk_enable;\n\n  assign enb_1_2000_1 =  phase_1 & clk_enable;\n\n\nendmodule  ",
        "module_name": "controllerPeripheralHdlAdi_tc",
        "module_hash": "f83ef180f9ce493896393c3a266c82c5",
        "dataset_index": 23692
      },
      "m6502_alu_3497db84": {
        "rtl_code": "module m6502_alu(\n                 input wire  [7 : 0] operation,\n                 input wire  [7 : 0] op_a,\n                 input wire  [7 : 0] op_b,\n                 input wire          carry_in,\n                 output wire [7 : 0] result,\n                 output wire         carry,\n                 output wire         zero,\n                 output wire         overflow\n                );\n\n  //----------------------------------------------------------------\n  // Defines.\n  //----------------------------------------------------------------\n  localparam OP_AND = 8'h01;\n  localparam OP_OR  = 8'h02;\n  localparam OP_XOR = 8'h03;\n  localparam OP_NOT = 8'h04;\n\n  localparam OP_ASL = 8'h11;\n  localparam OP_ROL = 8'h12;\n  localparam OP_ASR = 8'h13;\n  localparam OP_ROR = 8'h14;\n\n  localparam OP_ADD = 8'h21;\n  localparam OP_INC = 8'h22;\n  localparam OP_SUB = 8'h23;\n  localparam OP_DEC = 8'h24;\n\n  localparam OP_CMP = 8'h31;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [7 : 0] tmp_result;\n  reg         tmp_carry;\n  reg         tmp_zero;\n  reg         tmp_overflow;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign result   = tmp_result;\n  assign carry    = tmp_carry;\n  assign zero     = tmp_zero;\n  assign overflow = tmp_overflow;\n\n\n  //----------------------------------------------------------------\n  // alu\n  //\n  // The actual logic to implement the ALU functions.\n  //----------------------------------------------------------------\n  always @*\n    begin : alu\n      reg [8 : 0] tmp_add;\n\n      tmp_result   = 8'h0;\n      tmp_carry    = 0;\n      tmp_zero     = 0;\n      tmp_overflow = 0;\n\n      case (operation)\n        OP_AND:\n          begin\n            tmp_result = op_a & op_b;\n          end\n\n        OP_OR:\n          begin\n            tmp_result = op_a | op_b;\n          end\n\n        OP_XOR:\n          begin\n            tmp_result = op_a ^ op_b;\n          end\n\n        OP_NOT:\n          begin\n            tmp_result = ~op_a;\n          end\n\n        OP_ASL:\n          begin\n            tmp_result = {op_a[6 : 0], carry_in};\n            tmp_carry  = op_a[7];\n          end\n\n        OP_ROL:\n          begin\n            tmp_result = {op_a[6 : 0], op_a[7]};\n            tmp_carry  = op_a[7];\n          end\n\n        OP_ASR:\n          begin\n            tmp_result = {carry_in, op_a[7 : 1]};\n            tmp_carry  = op_a[0];\n          end\n\n        OP_ROR:\n          begin\n            tmp_result = {op_a[0], op_a[7 : 1]};\n            tmp_carry  = op_a[0];\n          end\n\n        OP_ADD:\n          begin\n            tmp_add = op_a + op_b + carry_in;\n            tmp_result = tmp_add[7 : 0];\n            tmp_carry  = tmp_add[8];\n            if ((op_a[7] == op_b[7]) && (op_a[7] != tmp_result[7]))\n              tmp_overflow = 1;\n          end\n\n        OP_INC:\n          begin\n            tmp_add = op_a + 1'b1;\n            tmp_result = tmp_add[7 : 0];\n            tmp_carry  = tmp_add[8];\n            if ((op_a[7] == 1'b0) && (tmp_result[7] == 1'b1))\n              tmp_overflow = 1;\n          end\n\n        OP_SUB:\n          begin\n            tmp_result = op_a - op_b;\n            if (tmp_result == 8'h00)\n              tmp_zero = 1;\n            if ((op_a[7] != op_b[7]) && (op_a[7] != tmp_result[7]))\n              tmp_overflow = 1;\n          end\n\n        OP_DEC:\n          begin\n            tmp_result = op_a - 1'b1;\n            if ((op_a[7] == 1'b1) && (tmp_result[7] == 1'b0))\n              tmp_overflow = 1;\n          end\n\n        OP_CMP:\n          begin\n            if (op_a == op_b)\n              tmp_zero = 1;\n          end\n\n        default:\n          begin\n          end\n      endcase // case (operation)\n    end // alu\n\nendmodule",
        "module_name": "m6502_alu",
        "module_hash": "3497db84fb58269f8a0eaf2d64b1944c",
        "dataset_index": 1340
      },
      "traffic_light_controller_1ae685ac": {
        "rtl_code": "\nmodule traffic_light_controller(\n    input reset, left, right, clk,\n    output LA, LB, LC, RA, RB, RC\n);\n\nparameter ST_IDLE = 3'b000;\nparameter ST_L1 = 3'b001;\nparameter ST_L2 = 3'b010;\nparameter ST_L3 = 3'b011;\nparameter ST_R1 = 3'b100;\nparameter ST_R2 = 3'b101;\nparameter ST_R3 = 3'b110;\n\nreg [2:0] state, next_state;\n\nalways @(posedge clk)\n    if (reset)\n        state <= ST_IDLE;\n    else\n        state <= next_state;\n\nalways @*\nbegin\n    case (state)\n        ST_IDLE: begin\n            if (left && ~right)\n                next_state = ST_L1;\n            else if (~left && right)\n                next_state = ST_R1;\n            else\n                next_state = ST_IDLE;\n        end\n        ST_L1: next_state = ST_L2;\n        ST_L2: if(timer >= DELAY) next_state = ST_L3;\n        ST_L3: begin\n            if (left && ~right)\n                next_state = ST_L1;\n            else if (~left && right)\n                next_state = ST_R1;\n            else if (timer >= DELAY)\n                next_state = ST_IDLE;\n        end\n        ST_R1: next_state = ST_R2;\n        ST_R2: if(timer >= DELAY) next_state = ST_R3;\n        ST_R3: begin\n            if (~left && right)\n                next_state = ST_R1;\n            else if (left && ~right)\n                next_state = ST_L1;\n            else if (timer >= DELAY)\n                next_state = ST_IDLE;\n        end\n        default: next_state = ST_IDLE;\n    endcase\n    if (left && right)\n        next_state = ST_IDLE;\nend\n\nparameter DELAY = 10; // in clock cycles\n\nreg [3:0] timer;\n\nalways @(posedge clk)\n    if (reset)\n        timer <= 0;\n    else if (state == ST_L2 || state == ST_R2)\n        timer <= timer + 1;\n    else\n        timer <= 0;\n\nassign LA = state == ST_L1 || state == ST_L2 || state == ST_L3;\nassign LB = state == ST_L2 || state == ST_L3;\nassign LC = state == ST_L3;\nassign RA = state == ST_R1 || state == ST_R2 || state == ST_R3;\nassign RB = state == ST_R2 || state == ST_R3;\nassign RC = state == ST_R3;\n\nendmodule",
        "module_name": "traffic_light_controller",
        "module_hash": "1ae685acd36f79079f238d26f2454a16",
        "dataset_index": 4531
      },
      "mem_protect #_99d03d3c": {
        "rtl_code": "module mem_protect #(\n  parameter n = 10,\n  parameter m = 2\n)(\n  input [n-1:0] addr,\n  input [m-1:0] ctrl,\n  output mem_en\n);\n\n\nparameter memory_size = 1024; // size of the memory block to be protected.\n\nreg mem_en;\n\nalways @(*) begin\n  if (addr < memory_size && ctrl[0] && !ctrl[1]) begin\n    mem_en = 1;\n  end else begin\n    mem_en = 0;\n  end\nend\n\nendmodule",
        "module_name": "mem_protect #",
        "module_hash": "99d03d3cd540e225f55ce325684d329c",
        "dataset_index": 18989
      },
      "four_bit_adder_07d9245f": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] X;\n    wire [3:0] C;\n\n    full_adder fa0 (\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .S(X[0]),\n        .C(C[0])\n    );\n    full_adder fa1 (\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(C[0]),\n        .S(X[1]),\n        .C(C[1])\n    );\n    full_adder fa2 (\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(C[1]),\n        .S(X[2]),\n        .C(C[2])\n    );\n    full_adder fa3 (\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(C[2]),\n        .S(X[3]),\n        .C(Cout)\n    );\n\n    assign S = X;\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output C\n);\n\n    wire s1;\n    wire c1;\n    wire c2;\n\n    xor (s1, A, B);\n    xor (S, s1, Cin);\n    and (c1, A, B);\n    and (c2, s1, Cin);\n    or (C, c1, c2);\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "07d9245fc8620ef134971b92e5e9bc37",
        "dataset_index": 4144
      },
      "bsg_channel_narrow #_ba31711a": {
        "rtl_code": "\nmodule bsg_channel_narrow #( parameter width_in_p     = 8\n                           , parameter width_out_p    = 4\n                           , parameter lsb_to_msb_p  = 1\n                           )\n                          ( input                    clk_i\n                          , input                    reset_i\n                          , input  [width_in_p-1:0]  data_i\n                          , input                    deque_i\n                          , output [width_out_p-1:0] data_o\n                          , output                   deque_o\n                          );\n  // Internal signals\n  reg [width_out_p-1:0] narrowed_data;\n\n  // Narrowing the input data\n  always @(posedge clk_i or posedge reset_i)\n    if(reset_i)\n      narrowed_data <= {width_out_p{1'b0}};\n    else\n      narrowed_data <= (lsb_to_msb_p) ? data_i[width_out_p-1:0] : data_i[width_in_p-1:width_in_p-width_out_p];\n\n  // Output signals\n  assign data_o = narrowed_data;\n  assign deque_o = deque_i;\n\nendmodule",
        "module_name": "bsg_channel_narrow #",
        "module_hash": "ba31711a83a8477c5f86a3c98338edd4",
        "dataset_index": 20963
      },
      "constmuldivmod_88d8f872": {
        "rtl_code": "module constmuldivmod(input [7:0] A, input [5:0] mode, output reg [7:0] Y);\n\talways @* begin\n\t\tcase (mode)\n\t\t\t0: Y = A / 8'd0;\n\t\t\t1: Y = A % 8'd0;\n\t\t\t2: Y = A * 8'd0;\n\n\t\t\t3: Y = A / 8'd1;\n\t\t\t4: Y = A % 8'd1;\n\t\t\t5: Y = A * 8'd1;\n\n\t\t\t6: Y = A / 8'd2;\n\t\t\t7: Y = A % 8'd2;\n\t\t\t8: Y = A * 8'd2;\n\n\t\t\t9: Y = A / 8'd4;\n\t\t\t10: Y = A % 8'd4;\n\t\t\t11: Y = A * 8'd4;\n\n\t\t\t12: Y = A / 8'd8;\n\t\t\t13: Y = A % 8'd8;\n\t\t\t14: Y = A * 8'd8;\n\n\t\t\t15: Y = $signed(A) / $signed(8'd0);\n\t\t\t16: Y = $signed(A) % $signed(8'd0);\n\t\t\t17: Y = $signed(A) * $signed(8'd0);\n\n\t\t\t18: Y = $signed(A) / $signed(8'd1);\n\t\t\t19: Y = $signed(A) % $signed(8'd1);\n\t\t\t20: Y = $signed(A) * $signed(8'd1);\n\n\t\t\t21: Y = $signed(A) / $signed(8'd2);\n\t\t\t22: Y = $signed(A) % $signed(8'd2);\n\t\t\t23: Y = $signed(A) * $signed(8'd2);\n\n\t\t\t24: Y = $signed(A) / $signed(8'd4);\n\t\t\t25: Y = $signed(A) % $signed(8'd4);\n\t\t\t26: Y = $signed(A) * $signed(8'd4);\n\n\t\t\t27: Y = $signed(A) / $signed(8'd8);\n\t\t\t28: Y = $signed(A) % $signed(8'd8);\n\t\t\t29: Y = $signed(A) * $signed(8'd8);\n\n\t\t\t30: Y = $signed(A) / $signed(-8'd0);\n\t\t\t31: Y = $signed(A) % $signed(-8'd0);\n\t\t\t32: Y = $signed(A) * $signed(-8'd0);\n\n\t\t\t33: Y = $signed(A) / $signed(-8'd1);\n\t\t\t34: Y = $signed(A) % $signed(-8'd1);\n\t\t\t35: Y = $signed(A) * $signed(-8'd1);\n\n\t\t\t36: Y = $signed(A) / $signed(-8'd2);\n\t\t\t37: Y = $signed(A) % $signed(-8'd2);\n\t\t\t38: Y = $signed(A) * $signed(-8'd2);\n\n\t\t\t39: Y = $signed(A) / $signed(-8'd4);\n\t\t\t40: Y = $signed(A) % $signed(-8'd4);\n\t\t\t41: Y = $signed(A) * $signed(-8'd4);\n\n\t\t\t42: Y = $signed(A) / $signed(-8'd8);\n\t\t\t43: Y = $signed(A) % $signed(-8'd8);\n\t\t\t44: Y = $signed(A) * $signed(-8'd8);\n\n\t\t\tdefault: Y = 8'd16 * A;\n\t\tendcase\n\tend\nendmodule\n",
        "module_name": "constmuldivmod",
        "module_hash": "88d8f87263a4f6b91207954d5e47c031",
        "dataset_index": 25334
      },
      "Instruction_Mem_0794ee2f": {
        "rtl_code": "module Instruction_Mem(Instruction_out, PCAdress);\n  output reg [15:0] Instruction_out;\n  input  [15:0] PCAdress;\n  \n  always @(PCAdress)\n  begin\n    case (PCAdress)\n \n\t\t8'h0:  Instruction_out = 16'hc000; 8'h1:  Instruction_out = 16'ha802; 8'h2:  Instruction_out = 16'hc66b; 8'h3:  Instruction_out = 16'hec00; 8'h4:  Instruction_out = 16'hd119; 8'h5:  Instruction_out = 16'h6895; 8'h6:  Instruction_out = 16'h6805; 8'h7:  Instruction_out = 16'h696d; 8'h8:  Instruction_out = 16'h68aa; 8'h9:  Instruction_out = 16'h7168; 8'ha:  Instruction_out = 16'h6805; 8'hb:  Instruction_out = 16'h7168; 8'hc:  Instruction_out = 16'h6895; 8'hd:  Instruction_out = 16'h6368; 8'he:  Instruction_out = 16'h6802; 8'hf:  Instruction_out = 16'h6802; 8'h10:  Instruction_out = 16'ha818; 8'h11:  Instruction_out = 16'haa19; 8'h12:  Instruction_out = 16'had1a; 8'h13:  Instruction_out = 16'hf014; 8'h14:  Instruction_out = 16'ha003; 8'h15:  Instruction_out = 16'h4640; 8'h16:  Instruction_out = 16'h1901; 8'h17:  Instruction_out = 16'hb108; 8'h18:  Instruction_out = 16'h4640; 8'h19:  Instruction_out = 16'h1902; 8'h1a:  Instruction_out = 16'hb110; 8'h1b:  Instruction_out = 16'h4640; 8'h1c:  Instruction_out = 16'h1904; 8'h1d:  Instruction_out = 16'hb119; 8'h1e:  Instruction_out = 16'h9b80; 8'h1f:  Instruction_out = 16'hc000; 8'h20:  Instruction_out = 16'h5840; 8'h21:  Instruction_out = 16'h5888; 8'h22:  Instruction_out = 16'h58d0; 8'h23:  Instruction_out = 16'h5918; 8'h24:  Instruction_out = 16'h5960; 8'h25:  Instruction_out = 16'ha703; 8'h26:  Instruction_out = 16'h47f8; 8'h27:  Instruction_out = 16'h1f01; 8'h28:  Instruction_out = 16'hb7fd; 8'h29:  Instruction_out = 16'h9b80; 8'h2a:  Instruction_out = 16'hc000; 8'h2b:  Instruction_out = 16'h6400; 8'h2c:  Instruction_out = 16'h5840; 8'h2d:  Instruction_out = 16'h5888; 8'h2e:  Instruction_out = 16'h58d0; 8'h2f:  Instruction_out = 16'h5918; 8'h30:  Instruction_out = 16'h5960; 8'h31:  Instruction_out = 16'ha703; 8'h32:  Instruction_out = 16'h47f8; 8'h33:  Instruction_out = 16'h1f02; 8'h34:  Instruction_out = 16'hb7fd; 8'h35:  Instruction_out = 16'h9b80; 8'h36:  Instruction_out = 16'ha018; 8'h37:  Instruction_out = 16'ha219; 8'h38:  Instruction_out = 16'ha51a; 8'h39:  Instruction_out = 16'h5850; 8'h3a:  Instruction_out = 16'h2940; 8'h3b:  Instruction_out = 16'hf808; 8'h3c:  Instruction_out = 16'h6c4f; 8'h3d:  Instruction_out = 16'hf801; 8'h3e:  Instruction_out = 16'h4ccf; 8'h3f:  Instruction_out = 16'h6cdd; 8'h40:  Instruction_out = 16'h5900; 8'h41:  Instruction_out = 16'he800; 8'h42:  Instruction_out = 16'ha703; 8'h43:  Instruction_out = 16'h47f8; 8'h44:  Instruction_out = 16'h1f04; 8'h45:  Instruction_out = 16'hb7fd; 8'h46:  Instruction_out = 16'h9b80; \n\n\n\t\t\n\t\n\n\n\n\n\n\n\n      default: Instruction_out = 16'b0000000000000000;\n    endcase\n  end\nendmodule \n",
        "module_name": "Instruction_Mem",
        "module_hash": "0794ee2f714be1c84728d5f37da9fa72",
        "dataset_index": 23363
      },
      "zbroji_HLS_ZBROJI_PERIPH_BUS_if_f454b647": {
        "rtl_code": "\nmodule zbroji_HLS_ZBROJI_PERIPH_BUS_if\n#(parameter\n    C_ADDR_WIDTH = 6,\n    C_DATA_WIDTH = 32\n)(\n    input  wire                      ACLK,\n    input  wire                      ARESETN,\n    input  wire [C_ADDR_WIDTH-1:0]   AWADDR,\n    input  wire                      AWVALID,\n    output wire                      AWREADY,\n    input  wire [C_DATA_WIDTH-1:0]   WDATA,\n    input  wire [C_DATA_WIDTH/8-1:0] WSTRB,\n    input  wire                      WVALID,\n    output wire                      WREADY,\n    output wire [1:0]                BRESP,\n    output wire                      BVALID,\n    input  wire                      BREADY,\n    input  wire [C_ADDR_WIDTH-1:0]   ARADDR,\n    input  wire                      ARVALID,\n    output wire                      ARREADY,\n    output wire [C_DATA_WIDTH-1:0]   RDATA,\n    output wire [1:0]                RRESP,\n    output wire                      RVALID,\n    input  wire                      RREADY,\n    output wire                      interrupt,\n    output wire [31:0]               I_a,\n    output wire [31:0]               I_b,\n    output wire                      I_ap_start,\n    input  wire                      O_ap_ready,\n    input  wire                      O_ap_done,\n    input  wire                      O_ap_idle,\n    input  wire [31:0]               O_ap_return\n);\nlocalparam\n    ADDR_BITS = 6;\n\nlocalparam\n    ADDR_AP_CTRL     = 6'h00,\n    ADDR_GIE         = 6'h04,\n    ADDR_IER         = 6'h08,\n    ADDR_ISR         = 6'h0c,\n    ADDR_A_CTRL      = 6'h10,\n    ADDR_A_DATA_0    = 6'h14,\n    ADDR_B_CTRL      = 6'h18,\n    ADDR_B_DATA_0    = 6'h1c,\n    ADDR_AP_RETURN_0 = 6'h20;\n\nlocalparam\n    WRIDLE = 2'd0,\n    WRDATA = 2'd1,\n    WRRESP = 2'd2;\n\nlocalparam\n    RDIDLE = 2'd0,\n    RDDATA = 2'd1;\n\nreg  [1:0]           wstate;\nreg  [1:0]           wnext;\nreg  [ADDR_BITS-1:0] waddr;\nwire [31:0]          wmask;\nwire                 aw_hs;\nwire                 w_hs;\nreg  [1:0]           rstate;\nreg  [1:0]           rnext;\nreg  [31:0]          rdata;\nwire                 ar_hs;\nwire [ADDR_BITS-1:0] raddr;\nwire                 ap_idle;\nreg                  ap_done;\nwire                 ap_ready;\nreg                  ap_start;\nreg                  auto_restart;\nreg                  gie;\nreg                  ier;\nreg                  isr;\nreg  [31:0]          _a;\nreg  [31:0]          _b;\nwire [31:0]          ap_return;\n\nassign AWREADY = (wstate == WRIDLE);\nassign WREADY  = (wstate == WRDATA);\nassign BRESP   = 2'b00;  assign BVALID  = (wstate == WRRESP);\nassign wmask   = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} };\nassign aw_hs   = AWVALID & AWREADY;\nassign w_hs    = WVALID & WREADY;\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        wstate <= WRIDLE;\n    else\n        wstate <= wnext;\nend\n\nalways @(*) begin\n    case (wstate)\n        WRIDLE:\n            if (AWVALID)\n                wnext = WRDATA;\n            else\n                wnext = WRIDLE;\n        WRDATA:\n            if (WVALID)\n                wnext = WRRESP;\n            else\n                wnext = WRDATA;\n        WRRESP:\n            if (BREADY)\n                wnext = WRIDLE;\n            else\n                wnext = WRRESP;\n        default:\n            wnext = WRIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (aw_hs)\n        waddr <= AWADDR[ADDR_BITS-1:0];\nend\nassign ARREADY = (rstate == RDIDLE);\nassign RDATA   = rdata;\nassign RRESP   = 2'b00;  assign RVALID  = (rstate == RDDATA);\nassign ar_hs   = ARVALID & ARREADY;\nassign raddr   = ARADDR[ADDR_BITS-1:0];\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        rstate <= RDIDLE;\n    else\n        rstate <= rnext;\nend\n\nalways @(*) begin\n    case (rstate)\n        RDIDLE:\n            if (ARVALID)\n                rnext = RDDATA;\n            else\n                rnext = RDIDLE;\n        RDDATA:\n            if (RREADY)\n                rnext = RDIDLE;\n            else\n                rnext = RDDATA;\n        default:\n            rnext = RDIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (ar_hs) begin\n        rdata <= 1'b0;\n        case (raddr)\n            ADDR_AP_CTRL: begin\n                rdata[0] <= ap_start;\n                rdata[1] <= ap_done;\n                rdata[2] <= ap_idle;\n                rdata[3] <= ap_ready;\n                rdata[7] <= auto_restart;\n            end\n            ADDR_GIE: begin\n                rdata <= gie;\n            end\n            ADDR_IER: begin\n                rdata <= ier;\n            end\n            ADDR_ISR: begin\n                rdata <= isr;\n            end\n            ADDR_A_DATA_0: begin\n                rdata <= _a[31:0];\n            end\n            ADDR_B_DATA_0: begin\n                rdata <= _b[31:0];\n            end\n            ADDR_AP_RETURN_0: begin\n                rdata <= ap_return[31:0];\n            end\n        endcase\n    end\nend\nassign interrupt  = gie & (|isr);\nassign I_ap_start = ap_start;\nassign ap_idle    = O_ap_idle;\nassign ap_ready   = O_ap_ready;\nassign I_a        = _a;\nassign I_b        = _b;\nassign ap_return  = O_ap_return;\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        ap_start <= 1'b0;\n    else if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0])\n        ap_start <= 1'b1;\n    else if (O_ap_done & auto_restart)\n        ap_start <= 1'b1; else\n        ap_start <= 1'b0; end\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        ap_done <= 1'b0;\n    else if (O_ap_done)\n        ap_done <= 1'b1;\n    else if (ar_hs && raddr == ADDR_AP_CTRL)\n        ap_done <= 1'b0; end\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        auto_restart <= 1'b0;\n    else if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0])\n        auto_restart <=  WDATA[7];\nend\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        gie <= 1'b0;\n    else if (w_hs && waddr == ADDR_GIE && WSTRB[0])\n        gie <= WDATA[0];\nend\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        ier <= 1'b0;\n    else if (w_hs && waddr == ADDR_IER && WSTRB[0])\n        ier <= WDATA[0];\nend\n\nalways @(posedge ACLK) begin\n    if (~ARESETN)\n        isr <= 1'b0;\n    else if (ier & O_ap_done)\n        isr <= 1'b1;\n    else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n        isr <= isr ^ WDATA[0]; end\n\nalways @(posedge ACLK) begin\n    if (w_hs && waddr == ADDR_A_DATA_0)\n        _a[31:0] <= (WDATA[31:0] & wmask) | (_a[31:0] & ~wmask);\nend\n\nalways @(posedge ACLK) begin\n    if (w_hs && waddr == ADDR_B_DATA_0)\n        _b[31:0] <= (WDATA[31:0] & wmask) | (_b[31:0] & ~wmask);\nend\n\nendmodule\n",
        "module_name": "zbroji_HLS_ZBROJI_PERIPH_BUS_if",
        "module_hash": "f454b647d8fa87f24370148ba1117cc4",
        "dataset_index": 21503
      },
      "system_axi_iic_0_0_filter_c3231257": {
        "rtl_code": "module system_axi_iic_0_0_filter\n   (detect_stop_b_reg,\n    scndry_out,\n    scl_rising_edge0,\n    scl_rin_d1_reg,\n    sda_rin_d1,\n    scl_rin_d1,\n    scl_i,\n    s_axi_aclk,\n    sda_i);\n  output detect_stop_b_reg;\n  output scndry_out;\n  output scl_rising_edge0;\n  output scl_rin_d1_reg;\n  input sda_rin_d1;\n  input scl_rin_d1;\n  input scl_i;\n  input s_axi_aclk;\n  input sda_i;\n\n  wire detect_stop_b_reg;\n  wire s_axi_aclk;\n  wire scl_i;\n  wire scl_rin_d1;\n  wire scl_rin_d1_reg;\n  wire scl_rising_edge0;\n  wire scndry_out;\n  wire sda_i;\n  wire sda_rin_d1;\n\n  system_axi_iic_0_0_debounce SCL_DEBOUNCE\n       (.s_axi_aclk(s_axi_aclk),\n        .scl_i(scl_i),\n        .scl_rin_d1(scl_rin_d1),\n        .scl_rin_d1_reg(scl_rin_d1_reg),\n        .scl_rising_edge0(scl_rising_edge0));\n  system_axi_iic_0_0_debounce_3 SDA_DEBOUNCE\n       (.detect_stop_b_reg(detect_stop_b_reg),\n        .s_axi_aclk(s_axi_aclk),\n        .scndry_out(scndry_out),\n        .sda_i(sda_i),\n        .sda_rin_d1(sda_rin_d1));\nendmodule\n\nmodule system_axi_iic_0_0_debounce\n   (s_axi_aclk,\n    scl_i,\n    scl_rin_d1,\n    scl_rin_d1_reg,\n    scl_rising_edge0);\n  input s_axi_aclk;\n  input scl_i;\n  input scl_rin_d1;\n  output scl_rin_d1_reg;\n  output scl_rising_edge0;\n\n  reg scl_rin_d1_reg;\n  reg [1:0] scl_rin_d1_d;\n  reg scl_rising_edge0;\n\n  always @(posedge s_axi_aclk) begin\n    scl_rin_d1_d <= {scl_rin_d1, scl_rin_d1_d[1]};\n    scl_rin_d1_reg <= scl_rin_d1_d[1];\n    scl_rising_edge0 <= scl_rin_d1 & ~scl_rin_d1_d[1];\n  end\nendmodule\n\nmodule system_axi_iic_0_0_debounce_3\n   (detect_stop_b_reg,\n    s_axi_aclk,\n    scndry_out,\n    sda_i,\n    sda_rin_d1);\n  output detect_stop_b_reg;\n  output scndry_out;\n  input s_axi_aclk;\n  input sda_i;\n  input sda_rin_d1;\n\n  reg [2:0] sda_rin_d3;\n  reg [2:0] sda_rin_d3_d;\n  reg detect_stop_b_reg;\n  reg scndry_out;\n\n  always @(posedge s_axi_aclk) begin\n    sda_rin_d3_d <= {sda_rin_d1, sda_rin_d3_d[2:1]};\n    sda_rin_d3 <= sda_rin_d3_d;\n    detect_stop_b_reg <= sda_rin_d3 == 3'b100;\n    scndry_out <= sda_rin_d3[2] & ~sda_rin_d3[1];\n  end\nendmodule",
        "module_name": "system_axi_iic_0_0_filter",
        "module_hash": "c3231257b7f37941b47221669dcacaa5",
        "dataset_index": 17876
      },
      "gci_std_display_font_cefc7f64": {
        "rtl_code": "\n\t\nmodule gci_std_display_font(\n\t\tinput wire [6:0] iADDR,\n\t\toutput wire [111:0] oDATA\n\t);\t\n\n\tfunction [111:0] rom;\tinput [6:0] funcADDR;\n\t\tbegin\n\t\t\tcase(funcADDR)\n\t\t\t\t7'd0:\trom\t=\t112'h0000000000000000000000000000;\n\t\t\t\t7'd1:\trom\t=\t112'h0000181818181010100000181800;\n\t\t\t\t7'd2:\trom\t=\t112'h006c6c2448000000000000000000;\n\t\t\t\t7'd3:\trom\t=\t112'h00002424247e2424487e48484800;\n\t\t\t\t7'd4:\trom\t=\t112'h0000103c525250381452523c1000;\n\t\t\t\t7'd5:\trom\t=\t112'h0000225254542818142a2a4A4400;\n\t\t\t\t7'd6:\trom\t=\t112'h0000102828102652524c442a1000;\n\t\t\t\t7'd7:\trom\t=\t112'h0030301020000000000000000000;\n\t\t\t\t7'd8:\trom\t=\t112'h0004081010202020202010100804;\n\t\t\t\t7'd9:\trom\t=\t112'h0020100808040404040408081020;\n\t\t\t\t7'd10:\trom\t=\t112'h0000001010d6543854d610100000;\n\t\t\t\t7'd11:\trom\t=\t112'h000000101010107e101010100000;\n\t\t\t\t7'd12:\trom\t=\t112'h0000000000000000000030301020;\n\t\t\t\t7'd13:\trom\t=\t112'h000000000000007e000000000000;\n\t\t\t\t7'd14:\trom\t=\t112'h0000000000000000000000303000;\n\t\t\t\t7'd15:\trom\t=\t112'h0202040408081010202040408080;\n\t\t\t\t7'd16:\trom\t=\t112'h0000182424424242411224180000;\t7'd17:\trom\t=\t112'h00001070101010101010107c0000;\n\t\t\t\t7'd18:\trom\t=\t112'h00001824422204081020227e0000;\n\t\t\t\t7'd19:\trom\t=\t112'h0000182442441804424112180000;\n\t\t\t\t7'd20:\trom\t=\t112'h0000040C141424247e04040e0000;\n\t\t\t\t7'd21:\trom\t=\t112'h00007c4040586442024112180000;\n\t\t\t\t7'd22:\trom\t=\t112'h00001c1122586442424112180000;\n\t\t\t\t7'd23:\trom\t=\t112'h00003e1122040408080808080000;\n\t\t\t\t7'd24:\trom\t=\t112'h0000182441121824424112180000;\n\t\t\t\t7'd25:\trom\t=\t112'h000018244242261a024424180000;\n\t\t\t\t7'd26:\trom\t=\t112'h0000000018180000001818000000;\n\t\t\t\t7'd27:\trom\t=\t112'h0000000018180000001818081000;\n\t\t\t\t7'd28:\trom\t=\t112'h0000020408102040201008040200;\n\t\t\t\t7'd29:\trom\t=\t112'h000000007e0000007E0000000000;\n\t\t\t\t7'd30:\trom\t=\t112'h0000402010080402040810204000;\n\t\t\t\t7'd31:\trom\t=\t112'h0000182442420408101000181800;\n\t\t\t\t7'd32:\trom\t=\t112'h00001824112A5656564A20221C00;\n\t\t\t\t7'd33:\trom\t=\t112'h00001010282828247c4444ee0000;\n\t\t\t\t7'd34:\trom\t=\t112'h0000782424283c22222112780000;\n\t\t\t\t7'd35:\trom\t=\t112'h00001a2611224040402226180000;\n\t\t\t\t7'd36:\trom\t=\t112'h0000782424222222211224780000;\n\t\t\t\t7'd37:\trom\t=\t112'h00007c2220243c242020227e0000;\n\t\t\t\t7'd38:\trom\t=\t112'h00007c2220243c24202020780000;\n\t\t\t\t7'd39:\trom\t=\t112'h00001a261122404e4222261a0000;\n\t\t\t\t7'd40:\trom\t=\t112'h0000ee4444447c44444444ee0000;\n\t\t\t\t7'd41:\trom\t=\t112'h00007c10101010101010107c0000;\n\t\t\t\t7'd42:\trom\t=\t112'h00001e0404040404444448300000;\n\t\t\t\t7'd43:\trom\t=\t112'h00006e2428283028242422760000;\n\t\t\t\t7'd44:\trom\t=\t112'h00007020202020202020227c0000;\n\t\t\t\t7'd45:\trom\t=\t112'h00004266666a5a52524242660000;\n\t\t\t\t7'd46:\trom\t=\t112'h000046626252524A4a4646620000;\n\t\t\t\t7'd47:\trom\t=\t112'h0000182442424242424112180000;\n\t\t\t\t7'd48:\trom\t=\t112'h0000782422211238202020700000;\n\t\t\t\t7'd49:\trom\t=\t112'h0000182442424242724e24180600;\n\t\t\t\t7'd50:\trom\t=\t112'h0000782422211238282424720000;\n\t\t\t\t7'd51:\trom\t=\t112'h00001a2642201804024264580000;\n\t\t\t\t7'd52:\trom\t=\t112'h00007e5210101010101010380000;\n\t\t\t\t7'd53:\trom\t=\t112'h0000762222222222222214080000;\n\t\t\t\t7'd54:\trom\t=\t112'h0000664112242428181010100000;\n\t\t\t\t7'd55:\trom\t=\t112'h0000929292525A6A6c2424240000;\n\t\t\t\t7'd56:\trom\t=\t112'h00006244242810182824444e0000;\n\t\t\t\t7'd57:\trom\t=\t112'h0000e64112281810101010380000;\n\t\t\t\t7'd58:\trom\t=\t112'h00003e44040808102020427c0000;\n\t\t\t\t7'd59:\trom\t=\t112'h003c20202020202020202020203C;\n\t\t\t\t7'd60:\trom\t=\t112'h8080404020201010080804040202;\n\t\t\t\t7'd61:\trom\t=\t112'h003c04040404040404040404043C;\n\t\t\t\t7'd62:\trom\t=\t112'h0010284482000000000000000000;\n\t\t\t\t7'd63:\trom\t=\t112'h00000000000000000000000000FE;\n\t\t\t\t7'd64:\trom\t=\t112'h0018181008000000000000000000;\n\t\t\t\t7'd65:\trom\t=\t112'h000000003844441c2444443a0000;\n\t\t\t\t7'd66:\trom\t=\t112'h0000602028342222222112380000;\n\t\t\t\t7'd67:\trom\t=\t112'h000000001a264240404226180000;\n\t\t\t\t7'd68:\trom\t=\t112'h00000c04142c44444444241e0000;\n\t\t\t\t7'd69:\trom\t=\t112'h000000001824427e4042221c0000;\n\t\t\t\t7'd70:\trom\t=\t112'h00000c12127c1010101010380000;\n\t\t\t\t7'd71:\trom\t=\t112'h000000001a24242418205c42423C;\n\t\t\t\t7'd72:\trom\t=\t112'h0000c04050684444444444c60000;\n\t\t\t\t7'd73:\trom\t=\t112'h00001818003808080808083c0000;\n\t\t\t\t7'd74:\trom\t=\t112'h00000c0c001c0404040404444830;\n\t\t\t\t7'd75:\trom\t=\t112'h0000c04046444858684444ce0000;\n\t\t\t\t7'd76:\trom\t=\t112'h00003808080808080808083e0000;\n\t\t\t\t7'd77:\trom\t=\t112'h00000000acd29292929292920000;\n\t\t\t\t7'd78:\trom\t=\t112'h00000000d8644444444444c60000;\n\t\t\t\t7'd79:\trom\t=\t112'h0000000018244242424112180000;\n\t\t\t\t7'd80:\trom\t=\t112'h0000000058242222222112382070;\n\t\t\t\t7'd81:\trom\t=\t112'h000000001a2444444444241c040E;\n\t\t\t\t7'd82:\trom\t=\t112'h000000005c222220202020700000;\n\t\t\t\t7'd83:\trom\t=\t112'h000000003c4440300c42625c0000;\n\t\t\t\t7'd84:\trom\t=\t112'h00001010107c10101010120c0000;\n\t\t\t\t7'd85:\trom\t=\t112'h00000000cc44444444444c320000;\n\t\t\t\t7'd86:\trom\t=\t112'h0000000066424424281810100000;\n\t\t\t\t7'd87:\trom\t=\t112'h00000000929292925A6c24240000;\n\t\t\t\t7'd88:\trom\t=\t112'h0000000066242818181424660000;\n\t\t\t\t7'd89:\trom\t=\t112'h0000000066222214140808485020;\n\t\t\t\t7'd90:\trom\t=\t112'h000000003e4408081010227e0000;\n\t\t\t\t7'd91:\trom\t=\t112'h0006081010101020101010100806;\n\t\t\t\t7'd92:\trom\t=\t112'h0010101010101010101010101010;\n\t\t\t\t7'd93:\trom\t=\t112'h0060100808080804080808081060;\n\t\t\t\tdefault:\trom\t=\t112'h0000000000000000000000000000;\n\t\t\tendcase\n\t\tend\n\tendfunction\n\t\n\tassign oDATA = rom(iADDR - 8'h20);\t\n\t\nendmodule\n\n\n",
        "module_name": "gci_std_display_font",
        "module_hash": "cefc7f64f6dda52fa8a5371e628ce775",
        "dataset_index": 22979
      },
      "binary_counter_9964255a": {
        "rtl_code": "module binary_counter(\n  input clk, \n  input rst, \n  output reg [3:0] count\n);\n\n  always @ (posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "9964255a11b19b1d1a25702d37518dee",
        "dataset_index": 20351
      },
      "synchronous_ram_1babe50a": {
        "rtl_code": "module synchronous_ram (\n    input [9:0] address,\n    input [1:0] byteena,\n    input clken,\n    input clock,\n    input [15:0] data,\n    input wren,\n    output reg [15:0] q\n);\n\nparameter RAM_DEPTH = 16; // Define RAM_DEPTH parameter\n\nwire [15:0] sub_wire0;\nreg [15:0] ram [0:RAM_DEPTH-1];\nreg [3:0] addr; // Define addr as a register\n\nalways @(posedge clock) begin\n    if(clken) begin\n        if(wren) begin\n            for(addr = 0; addr < RAM_DEPTH; addr = addr + 1) begin\n                if(byteena[0]) begin\n                    ram[address][7:0] <= data[7:0];\n                end\n                if(byteena[1]) begin\n                    ram[address][15:8] <= data[15:8];\n                end\n            end\n        end\n        q <= ram[address];\n    end\nend\n\nendmodule",
        "module_name": "synchronous_ram",
        "module_hash": "1babe50a29ada97523be85b049989b72",
        "dataset_index": 10227
      },
      "mux2to1_e4885321": {
        "rtl_code": "\nmodule mux2to1 (o, a, b, sel);\n    output o;\n    input a, b, sel;\n    assign o = sel ? b : a;\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "e48853211ced45ebd8c9b2c94b6c508f",
        "dataset_index": 9394
      },
      "counter_2109b2ea": {
        "rtl_code": "\n\n\nmodule counter (count, clk, reset);\noutput [7:0] count;\ninput clk, reset;\n\nreg [7:0] count;\n\nalways @ (posedge clk or posedge reset)\n  if (reset)\n     count = 8'h00;\n  else\n     count <= count + 8'h01;\n     \nendmodule\n\n\n\n",
        "module_name": "counter",
        "module_hash": "2109b2eafa32d4657725375763eafb3d",
        "dataset_index": 22416
      },
      "ACA_I_N16_Q4_4bdc5170": {
        "rtl_code": "\nmodule ACA_I_N16_Q4(\n    input [15:0] in1,\n    input [15:0] in2,\n    output [16:0] res\n    );\n\nwire [4:0] temp1,temp2,temp3,temp4,temp5,temp6,temp7,temp8,temp9,temp10,temp11,temp12,temp13;\n\nassign temp1[4:0] = in1[3:0] + in2[3:0];\nassign temp2[4:0] = in1[4:1] + in2[4:1];\nassign temp3[4:0] = in1[5:2] + in2[5:2];\nassign temp4[4:0] = in1[6:3] + in2[6:3];\nassign temp5[4:0] = in1[7:4] + in2[7:4];\nassign temp6[4:0] = in1[8:5] + in2[8:5];\nassign temp7[4:0] = in1[9:6] + in2[9:6];\nassign temp8[4:0] = in1[10:7] + in2[10:7];\nassign temp9[4:0] = in1[11:8] + in2[11:8];\nassign temp10[4:0] = in1[12:9] + in2[12:9];\nassign temp11[4:0] = in1[13:10] + in2[13:10];\nassign temp12[4:0] = in1[14:11] + in2[14:11];\nassign temp13[4:0] = in1[15:12] + in2[15:12];\n\nassign res[16:0] = {temp13[4:3],temp12[3],temp11[3],temp10[3],temp9[3],temp8[3],temp7[3],temp6[3],temp5[3],temp4[3],temp3[3],temp2[3],temp1[3:0]};\n\nendmodule\n",
        "module_name": "ACA_I_N16_Q4",
        "module_hash": "4bdc517018133483d3b571d0a1f1e57f",
        "dataset_index": 24927
      },
      "full_adder_8914f91b": {
        "rtl_code": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C_out\n);\n\n    wire [3:0] carry;\n\n    full_adder FA0(A[0], B[0], 1'b0, S[0], carry[0]);\n    full_adder FA1(A[1], B[1], carry[0], S[1], carry[1]);\n    full_adder FA2(A[2], B[2], carry[1], S[2], carry[2]);\n    full_adder FA3(A[3], B[3], carry[2], S[3], C_out);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "8914f91bc2de4f09255567fa7fba5324",
        "dataset_index": 6364
      },
      "bitwise_operators_eb3f2122": {
        "rtl_code": "module bitwise_operators (\n  input [7:0] in1,\n  input [7:0] in2,\n  output [7:0] out_and,\n  output [7:0] out_or,\n  output [7:0] out_xor,\n  output [7:0] out_not\n);\n\n  assign out_and = in1 & in2;\n  assign out_or = in1 | in2;\n  assign out_xor = in1 ^ in2;\n  assign out_not = ~in1;\n\nendmodule",
        "module_name": "bitwise_operators",
        "module_hash": "eb3f21220da789a3a31f81a938a35c4a",
        "dataset_index": 10733
      },
      "fifo_buffer_358d5f79": {
        "rtl_code": "\nmodule fifo_buffer\n    (AS,\n     out,\n     wr_clk,\n     in0);\n\n    output [0:0] AS;\n    output out;\n    input wr_clk;\n    input [0:0] in0;\n\n    reg [1:0] buffer;\n    reg [1:0] next_buffer;\n    reg full;\n\n    assign AS = full;\n    assign out = buffer[0];\n\n    always @ (posedge wr_clk) begin\n        if (!full) begin\n            next_buffer[1] <= buffer[0];\n            next_buffer[0] <= in0;\n        end else begin\n            next_buffer <= buffer;\n        end\n    end\n\n    always @ (buffer, full) begin\n        full = (buffer[1] != 1'b0);\n    end\n\n    always @ (posedge wr_clk) begin\n        buffer <= next_buffer;\n    end\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "358d5f79196916cd0c85b0931454b94b",
        "dataset_index": 1168
      },
      "mux_if_unbal_4_1 #_55ec8e1d": {
        "rtl_code": "module mux_if_unbal_4_1 #(parameter N=4, parameter W=1) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @*\n    if (s == 0) o <= i[0*W+:W];\n    else if (s == 1) o <= i[1*W+:W];\n    else if (s == 2) o <= i[2*W+:W];\n    else if (s == 3) o <= i[3*W+:W];\n    else o <= {W{1'bx}};\nendmodule\n\nmodule mux_if_unbal_5_3 #(parameter N=5, parameter W=3) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @* begin\n    o <= {W{1'bx}};\n    if (s == 0) o <= i[0*W+:W];\n    if (s == 1) o <= i[1*W+:W];\n    if (s == 2) o <= i[2*W+:W];\n    if (s == 3) o <= i[3*W+:W];\n    if (s == 4) o <= i[4*W+:W];\nend\nendmodule\n\nmodule mux_if_unbal_5_3_invert #(parameter N=5, parameter W=3) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @*\n    if (s != 0) \n\t   \tif (s != 1) \n\t\t\tif (s != 2)\n\t\t\t\tif (s != 3)\n\t\t\t\t\tif (s != 4) o <= i[4*W+:W];\n\t\t\t\t\telse o <= i[0*W+:W];\n\t\t\t\telse o <= i[3*W+:W];\n\t\t\telse o <= i[2*W+:W];\n\t\telse o <= i[1*W+:W];\n    else o <= {W{1'bx}};\nendmodule\n\nmodule mux_if_unbal_5_3_width_mismatch #(parameter N=5, parameter W=3) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @* begin\n    o <= {W{1'bx}};\n    if (s == 0) o <= i[0*W+:W];\n    if (s == 1) o <= i[1*W+:W];\n    if (s == 2) o[W-2:0] <= i[2*W+:W-1];\n    if (s == 3) o <= i[3*W+:W];\n    if (s == 4) o <= i[4*W+:W];\nend\nendmodule\n\nmodule mux_if_unbal_4_1_missing #(parameter N=5, parameter W=3) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @* begin\n    if (s == 0) o <= i[0*W+:W];\nelse if (s == 3) o <= i[3*W+:W];\n    else o <= {W{1'bx}};\nend\nendmodule\n\nmodule mux_if_unbal_5_3_order #(parameter N=5, parameter W=3) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @* begin\n    o <= {W{1'bx}};\n    if (s == 3) o <= i[3*W+:W];\n    if (s == 2) o <= i[2*W+:W];\n    if (s == 1) o <= i[1*W+:W];\n    if (s == 4) o <= i[4*W+:W];\n    if (s == 0) o <= i[0*W+:W];\nend\nendmodule\n\nmodule mux_if_unbal_4_1_nonexcl #(parameter N=4, parameter W=1) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @*\n    if (s == 0) o <= i[0*W+:W];\n    else if (s == 1) o <= i[1*W+:W];\n    else if (s == 2) o <= i[2*W+:W];\n    else if (s == 3) o <= i[3*W+:W];\n\telse if (s == 0) o <= {W{1'b0}};\n    else o <= {W{1'bx}};\nendmodule\n\nmodule mux_if_unbal_5_3_nonexcl #(parameter N=5, parameter W=3) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @* begin\n    o <= {W{1'bx}};\n    if (s == 0) o <= i[0*W+:W];\n    if (s == 1) o <= i[1*W+:W];\n    if (s == 2) o <= i[2*W+:W];\n    if (s == 3) o <= i[3*W+:W];\n    if (s == 4) o <= i[4*W+:W];\n\tif (s == 0) o <= i[2*W+:W];\nend\nendmodule\n\nmodule mux_case_unbal_8_7#(parameter N=8, parameter W=7) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @* begin\n    o <= {W{1'bx}};\n    case (s)\n    0: o <= i[0*W+:W];\n    default:\n        case (s)\n        1: o <= i[1*W+:W];\n        2: o <= i[2*W+:W];\n        default:\n            case (s)\n            3: o <= i[3*W+:W];\n            4: o <= i[4*W+:W];\n            5: o <= i[5*W+:W];\n            default:\n                case (s)\n                    6: o <= i[6*W+:W];\n                    default: o <= i[7*W+:W];\n                endcase\n            endcase\n        endcase\n    endcase\nend\nendmodule\n\nmodule mux_if_bal_8_2 #(parameter N=8, parameter W=2) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @*\n    if (s[0] == 1'b0)\n     if (s[1] == 1'b0)\n      if (s[2] == 1'b0)\n       o <= i[0*W+:W];\n      else\n       o <= i[1*W+:W];\n     else\n      if (s[2] == 1'b0)\n       o <= i[2*W+:W];\n      else\n       o <= i[3*W+:W];\n    else\n     if (s[1] == 1'b0)\n      if (s[2] == 1'b0)\n       o <= i[4*W+:W];\n      else\n       o <= i[5*W+:W];\n     else\n      if (s[2] == 1'b0)\n       o <= i[6*W+:W];\n      else\n       o <= i[7*W+:W];\nendmodule\n\nmodule mux_if_bal_5_1 #(parameter N=5, parameter W=1) (input [N*W-1:0] i, input [$clog2(N)-1:0] s, output reg [W-1:0] o);\nalways @*\n    if (s[0] == 1'b0)\n     if (s[1] == 1'b0)\n      if (s[2] == 1'b0)\n       o <= i[0*W+:W];\n      else\n       o <= i[1*W+:W];\n     else\n      if (s[2] == 1'b0)\n       o <= i[2*W+:W];\n      else\n       o <= i[3*W+:W];\n    else\n     o <= i[4*W+:W];\nendmodule\n\nmodule cliffordwolf_nonexclusive_select (\n        input wire x, y, z,\n        input wire a, b, c, d,\n        output reg o\n);\n        always @* begin\n                o = a;\n                if (x) o = b;\n                if (y) o = c;\n                if (z) o = d;\n        end\nendmodule\n\nmodule cliffordwolf_freduce (\n        input wire [1:0] s,\n        input wire a, b, c, d,\n        output reg [3:0] o\n);\n        always @* begin\n                o = {4{a}};\n                if (s == 0) o = {3{b}};\n                if (s == 1) o = {2{c}};\n                if (s == 2) o = d;\n        end\nendmodule\n\nmodule case_nonexclusive_select (\n        input wire [1:0] x, y,\n        input wire a, b, c, d, e,\n        output reg o\n);\n        always @* begin\n            case (x)\n                0: o = b;\n                2: o = b;\n                1: o = c;\n                default: begin\n                    o = a;\n                    if (y == 0) o = d;\n                    if (y == 1) o = e;\n                end\n        endcase\n        end\nendmodule\n\nmodule case_nonoverlap (\n        input wire [2:0] x,\n        input wire a, b, c, d, e,\n        output reg o\n);\n        always @* begin\n            case (x)\n                0, 2: o = b; 1: o = c;\n                default:\n                    case (x)\n                        3: o = d; 4: o = d; 5: o = e;\n                        default: o = 1'b0;\n                    endcase\n        endcase\n        end\nendmodule\n\nmodule case_overlap (\n        input wire [2:0] x,\n        input wire a, b, c, d, e,\n        output reg o\n);\n        always @* begin\n            case (x)\n                0, 2: o = b; 1: o = c;\n                default:\n                    case (x)\n                        0: o = 1'b1; 3, 4: o = d; 5: o = e;\n                        default: o = 1'b0;\n                    endcase\n        endcase\n        end\nendmodule\n\nmodule case_overlap2 (\n        input wire [2:0] x,\n        input wire a, b, c, d, e,\n        output reg o\n);\n        always @* begin\n            case (x)\n                0: o = b; 2: o = b; 1: o = c;\n                default:\n                    case (x)\n                        0: o = d; 2: o = d; 3: o = d; 4: o = d; 5: o = e;\n                        default: o = 1'b0;\n                    endcase\n        endcase\n        end\nendmodule\n",
        "module_name": "mux_if_unbal_4_1 #",
        "module_hash": "55ec8e1db7cf094b8379cf8010b1c461",
        "dataset_index": 23506
      },
      "mux_2_to_1_23e94b4f": {
        "rtl_code": "module mux_2_to_1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    wire w1;\n\n    assign w1 = ~sel & a;\n    assign out = sel & b | w1;\n\nendmodule",
        "module_name": "mux_2_to_1",
        "module_hash": "23e94b4faed2677214bea085af2dfb18",
        "dataset_index": 15190
      },
      "top__21d80d09": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input [99:0] a, b, // 100-bit input for the adder\n    input cin,\n    input load,\n    input [1:0] ena, // 2-bit input for the rotator\n    input [99:0] data, // 100-bit input for the rotator\n    output [199:0] q // 200-bit output from the system\n);\n\n    // Declare internal wires and registers\n    wire [99:0] adder_out;\n    wire cout;\n    wire [99:0] rotator_out;\n    reg [99:0] shift_reg;\n    reg [1:0] shift_en;\n    reg [99:0] q_adder;\n    reg [99:0] q_rotator;\n\n    // Instantiate the adder module\n    adder_module adder_inst (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(adder_out),\n        .cout(cout)\n    );\n\n    // Instantiate the rotator module\n    rotator_module rotator_inst (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .ena(ena),\n        .data(data),\n        .shift_reg(shift_reg),\n        .shift_en(shift_en),\n        .q(rotator_out)\n    );\n\n    // Concatenate the output of the adder and rotator\n    assign q = {adder_out, rotator_out};\n\n    // Process for the shift_en register\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            shift_en <= 2'b00;\n        end else begin\n            shift_en <= ena;\n        end\n    end\n\n    // Process for the q_adder register\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q_adder <= 0;\n        end else begin\n            q_adder <= adder_out;\n        end\n    end\n\n    // Process for the q_rotator register\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q_rotator <= 0;\n        end else if (load) begin\n            q_rotator <= data;\n        end else if (shift_en == 2'b01) begin\n            q_rotator <= {shift_reg[0], shift_reg[99:1]};\n        end else if (shift_en == 2'b10) begin\n            q_rotator <= {shift_reg[98:0], shift_reg[99]};\n        end else begin\n            q_rotator <= rotator_out;\n        end\n    end\n\n    // Instantiate the shift_reg register\n    shift_reg_module shift_reg_inst (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .shift_en(shift_en),\n        .data(q_rotator),\n        .shift_reg(shift_reg)\n    );\n\nendmodule\nmodule adder_module (\n    input [99:0] a,\n    input [99:0] b,\n    input cin,\n    output [99:0] sum,\n    output cout\n);\n\n    // Declare internal wires\n    wire [99:0] p;\n    wire [99:0] g;\n    wire [99:0] c;\n\n    // Generate the carry and propagate signals\n    genvar i;\n    generate\n        for (i = 0; i < 100; i = i + 1) begin : carry_propagate\n            assign p[i] = a[i] ^ b[i];\n            assign g[i] = a[i] & b[i];\n        end\n    endgenerate\n\n    // Generate the carry lookahead signals\n    genvar j;\n    generate\n        for (j = 0; j < 99; j = j + 1) begin : carry_lookahead\n            assign c[j] = g[j] | (p[j] & c[j+1]);\n        end\n        assign c[99] = g[99] | (p[99] & cin);\n    endgenerate\n\n    // Generate the sum and carry-out signals\n    assign sum = a + b + cin;\n    assign cout = c[99];\n\nendmodule\nmodule rotator_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input load,\n    input [1:0] ena, // 2-bit input for the rotator\n    input [99:0] data, // 100-bit input for the rotator\n    input [99:0] shift_reg,\n    input [1:0] shift_en,\n    output [99:0] q // 100-bit output from the rotator\n);\n\n    // Declare internal wires and registers\n    wire [99:0] shifted_data;\n    reg [99:0] q_reg;\n\n    // Generate the shifted data\n    assign shifted_data = (shift_en == 2'b01) ? {shift_reg[0], data[99:1]} :\n                          (shift_en == 2'b10) ? {data[98:0], shift_reg[99]} :\n                          data;\n\n    // Process for the q_reg register\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q_reg <= 0;\n        end else if (load) begin\n            q_reg <= data;\n        end else if (shift_en != 2'b00) begin\n            q_reg <= shifted_data;\n        end\n    end\n\n    // Assign the output\n    assign q = q_reg;\n\nendmodule\nmodule shift_reg_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input load,\n    input [1:0] shift_en,\n    input [99:0] data, // 100-bit input for the rotator\n    output [99:0] shift_reg\n);\n\n    // Declare internal wires and registers\n    reg [99:0] shift_reg_reg;\n\n    // Process for the shift_reg_reg register\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            shift_reg_reg <= 0;\n        end else if (load) begin\n            shift_reg_reg <= data;\n        end else if (shift_en == 2'b01) begin\n            shift_reg_reg <= {shift_reg_reg[0], shift_reg_reg[99:1]};\n        end else if (shift_en == 2'b10) begin\n            shift_reg_reg <= {shift_reg_reg[98:0], shift_reg_reg[99]};\n        end else begin\n            shift_reg_reg <= shift_reg_reg;\n        end\n    end\n\n    // Assign the output\n    assign shift_reg = shift_reg_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "21d80d09b25caa12427fd417d584b2d8",
        "dataset_index": 8876
      },
      "axi_traffic_gen_v2_0_7_ex_fifo_0e9f69e4": {
        "rtl_code": "\n\nmodule axi_traffic_gen_v2_0_7_ex_fifo\n        #(\n  parameter WIDTH        = 10,\n  parameter DEPTH        = 8 ,\n  parameter DEPTHBITS    = 3 ,\n  parameter HEADREG      = 1 ,\n  parameter ZERO_INVALID = 0 ,\n  parameter FULL_LEVEL   = 6 ,\n  parameter BLOCK_ACTIVE = 0 ) (\n  input              Clk              ,\n  input              rst_l            ,\n  input [WIDTH-1:0]  in_data          ,\n  input              in_push          ,\n  input              in_pop           ,\n  output [WIDTH-1:0] out_data         ,\n  output             is_full          ,\n  output             is_notfull       ,\n  output             is_empty         ,\n  output             out_valid        ,\n  \n  output [15:0] ex_fifo_dbgout\n\n);\n\nreg [WIDTH-1:0    ] data_ff[DEPTH-1:0];\nreg [DEPTHBITS-1:0] out_ptr_ff;\nreg [DEPTHBITS-1:0] in_ptr_ff;\nreg [DEPTHBITS:0  ] depth_ff;\nreg [WIDTH-1:0    ] headreg_ff;\nreg full_ff, notfull_ff, valid_ff, valid_filt_ff;\n\nwire [DEPTHBITS-1:0] in_ptr = (in_push) ? in_ptr_ff[DEPTHBITS-1:0] + 'h1 :\n                                                in_ptr_ff[DEPTHBITS-1:0];\nwire [DEPTHBITS:0] depth =\n                (in_push && ~in_pop) ? depth_ff[DEPTHBITS:0] + 'h1 :\n                (~in_push && in_pop) ? depth_ff[DEPTHBITS:0] - 'h1 :\n                                                        depth_ff[DEPTHBITS:0];\nwire        depth_was1 = (depth_ff[DEPTHBITS:0] == 'h1);\nwire        valid = (depth[DEPTHBITS:0] != 'h0);\nwire        full ;\ngenerate if(BLOCK_ACTIVE == 1 ) begin : BLOCK_ACTIVE_FULL_YES\nend\nendgenerate\ngenerate if(BLOCK_ACTIVE == 0 ) begin : BLOCK_ACTIVE_FULL_NO\n assign full = (depth[DEPTHBITS:0] >= FULL_LEVEL) ;\nend\nendgenerate\n\nwire        notfull = ~full;\nwire [WIDTH-1:0] raw_data = data_ff[out_ptr_ff[DEPTHBITS-1:0]];\n\nwire [DEPTHBITS-1:0] out_ptr = (in_pop) ? out_ptr_ff[DEPTHBITS-1:0] + 'h1 :\n                                                out_ptr_ff[DEPTHBITS-1:0];\n\nwire [WIDTH-1:0] head_raw_data = (depth_was1) ? in_data[WIDTH-1:0] :\n                                                        raw_data[WIDTH-1:0];\nwire [WIDTH-1:0] headreg = (!valid_ff && in_push) ? in_data[WIDTH-1:0] :\n                (in_pop) ? head_raw_data[WIDTH-1:0] : headreg_ff[WIDTH-1:0];\n\nwire        valid_filt ;\ngenerate if(BLOCK_ACTIVE == 1 ) begin : BLOCK_ACTIVE_VALID_YES\nend\nendgenerate\ngenerate if(BLOCK_ACTIVE == 0 ) begin : BLOCK_ACTIVE_VALID_NO\n assign valid_filt = valid ;\n                        end\nendgenerate\n\nalways @(posedge Clk) begin\n        in_ptr_ff[DEPTHBITS-1:0]  <= (rst_l) ? in_ptr[DEPTHBITS-1:0] : {DEPTHBITS{1'b0}};\n        out_ptr_ff[DEPTHBITS-1:0] <= (rst_l) ? out_ptr[DEPTHBITS-1:0] :\n                                                ((HEADREG) ? {{(DEPTHBITS-1){1'b0}},{1'b1}} : {DEPTHBITS{1'b0}});\n        depth_ff[DEPTHBITS:0]     <= (rst_l) ? depth[DEPTHBITS:0] : {DEPTHBITS{1'b0}};\n        valid_ff                  <= (rst_l) ? valid : 1'b0;\n        valid_filt_ff             <= (rst_l) ? valid_filt : 1'b0;\n        full_ff                   <= (rst_l) ? full : 1'b1;\n        notfull_ff                <= (rst_l) ? notfull : 1'b0;\n        headreg_ff[WIDTH-1:0]     <= (rst_l) ? headreg[WIDTH-1:0] : {WIDTH{1'b0}};\nend\n\ninteger i;\nalways @(posedge Clk) begin\n        if(in_push) begin\n                data_ff[in_ptr_ff[DEPTHBITS-1:0]] <= in_data[WIDTH-1:0];\n        end\n\n`ifdef FOO_BAR\n        for(i = 0; i < DEPTH; i = i + 1) begin\n                if(~rst_l && (HEADREG == 0)) begin\n                        data_ff[i] <= {WIDTH{1'b0}};\n                end else if((i == in_ptr_ff[DEPTHBITS-1:0]) && in_push) begin\n                        data_ff[i] <= in_data[WIDTH-1:0];\n                end\n        end\n`endif\nend\n\n\nassign out_data[WIDTH-1:0] = (ZERO_INVALID && ~valid_filt_ff) ? { WIDTH {1'b0}}:\n                                (HEADREG) ? headreg_ff[WIDTH-1:0] :\n                                                        raw_data[WIDTH-1:0];\nassign out_valid  = valid_filt_ff;\nassign is_full    = full_ff      ;\nassign is_notfull = notfull_ff   ;\nassign is_empty   = ~valid_ff    ;\n\n\nassign ex_fifo_dbgout = 16'b0 | depth_ff;\n\n\nendmodule\n\n",
        "module_name": "axi_traffic_gen_v2_0_7_ex_fifo",
        "module_hash": "0e9f69e41aa6a43d7d4f313d5d1aa464",
        "dataset_index": 22846
      },
      "mult_input_f4dc7cc1": {
        "rtl_code": "module mult_input(\n    input [31:0] in1,\n    input [31:0] in2,\n    input [31:0] in3,\n    input [31:0] in4,\n    input [31:0] in5,\n    output reg [31:0] out\n);\n\n    always @(*) begin\n        out = in1 * in2 * in3 * in4 * in5;\n    end\n\nendmodule",
        "module_name": "mult_input",
        "module_hash": "f4dc7cc199ca4b9d146ebea1718620e3",
        "dataset_index": 20028
      },
      "iq_comp_884961b8": {
        "rtl_code": "module iq_comp (\n\tinput clk, RESETn,\n\tinput freeze_iqcomp,\t\t\t\tinput [1:0] op_mode,\n\tinput [3:0] Ix, Qx,\n\tinput signed [12:0] Wr_in, Wj_in,\toutput reg signed [3:0] Iy, Qy,\t\toutput wire settled,\t\t\t\toutput reg signed [12:0] Wr, Wj\n);\n\nlocalparam BYPASS = 2'b00;\nlocalparam INT_W = 2'b01;\nlocalparam EXT_W = 2'b10;\nlocalparam CONT_W = 2'b11;\t\t\t\twire signed [3:0] Ix_s;\nwire signed [3:0] Qx_s;\n\nwire [3:0] M;\n\nwire signed [12:0] Wr_use;\nwire signed [12:0] Wj_use;\nreg signed [3:0] I_math;\nreg signed [3:0] Q_math;\nwire signed [12:0] Wr_math;\nwire signed [12:0] Wj_math;\n\nwire signed [25:0] I_math_intermediate1;\nwire signed [25:0] Q_math_intermediate1;\nwire signed [4:0] I_math_intermediate2;\nwire signed [4:0] Q_math_intermediate2;\nwire signed [25:0] Ix_s_shifted;\nwire signed [25:0] Qx_s_shifted;\n\nassign settled = freeze_iqcomp;\t\tassign M = 4'd9;\t\t\t\t\tassign Ix_s = Ix - 4'd8;\nassign Qx_s = Qx - 4'd8;\n\nassign Wr_use = (op_mode == INT_W) ? Wr : Wr_in;\nassign Wj_use = (op_mode == INT_W) ? Wj : Wj_in;\n\nassign Ix_s_shifted = $signed(Ix_s) <<< M;\nassign Qx_s_shifted = $signed(Qx_s) <<< M;\n\nassign I_math_intermediate1 = Ix_s_shifted + $signed(((Wr_use * Ix_s) + (Wj_use * Qx_s)));\nassign Q_math_intermediate1 = Qx_s_shifted + $signed(((Wj_use * Ix_s) - (Wr_use * Qx_s)));\n\nassign I_math_intermediate2 = $signed(I_math_intermediate1) >>> M;\nassign Q_math_intermediate2 = $signed(Q_math_intermediate1) >>> M;\n\nalways @(*) begin\n\tif($signed(I_math_intermediate2) < $signed(0-5'd8)) begin\n\t\tI_math = $signed(-4'd8);\n\tend\n\telse if($signed(I_math_intermediate2) > $signed(5'd7)) begin\n\t\tI_math = $signed(4'd7);\n\tend\n\telse begin\n\t\tI_math = $signed(I_math_intermediate2);\n\tend\n\n\tif($signed(Q_math_intermediate2) < $signed(0-5'd8)) begin\n\t\tQ_math = $signed(-4'd8);\n\tend\n\telse if($signed(Q_math_intermediate2) > $signed(5'd7)) begin\n\t\tQ_math = $signed(4'd7);\n\tend\n\telse begin\n\t\tQ_math = $signed(Q_math_intermediate2);\n\tend\nend\n\nassign Wr_math = $signed(Wr - ((Iy + Qy) * (Iy - Qy)));\nassign Wj_math = $signed(Wj - 2 * Iy * Qy);\n\nalways @(posedge clk) begin\n\tif(~RESETn) begin\n\t\tIy <= 0;\n\t\tQy <= 0;\n\t\tWr <= 0;\n\t\tWj <= 0;\n\tend else begin\n\t\tcase (op_mode)\n\t\t\tBYPASS: begin\n\t\t\t\tIy <= Ix_s;\n\t\t\t\tQy <= Qx_s;\n\t\t\t\tWr <= 0;\n\t\t\t\tWj <= 0;\n\t\t\tend\n\t\t\tINT_W: begin \n\t\t\t\tIy <= I_math;\n\t\t\t\tQy <= Q_math;\n\t\t\t\tif(freeze_iqcomp) begin \n\t\t\t\t\tWr <= Wr;\n\t\t\t\t\tWj <= Wj;\n\t\t\t\tend else begin\n\t\t\t\t\tWr <= Wr_math;\n\t\t\t\t\tWj <= Wj_math;\n\t\t\t\tend\n\t\t\tend\n\t\t\tEXT_W: begin\n\t\t\t\tIy <= I_math;\n\t\t\t\tQy <= Q_math;\n\t\t\t\tWr <= Wr_use;\tWj <= Wj_use;\tend\n\t\t\tCONT_W: begin\t\tIy <= Ix_s;\n\t\t\t\tQy <= Qx_s;\n\t\t\t\tWr <= 0;\n\t\t\t\tWj <= 0;\n\t\t\tend\n\t\t\tdefault : ;\n\t\tendcase\n\tend\nend\nendmodule \n\n",
        "module_name": "iq_comp",
        "module_hash": "884961b852f4faaf6b4325f47f533102",
        "dataset_index": 21699
      },
      "uart_4f936182": {
        "rtl_code": "module uart ( input[15:0] din, output[15:0] dout, input a0, input rnw, input clk, input reset_b, input cs_b, input rxd, output txd);\n\n   parameter CLKSPEED = 32000000;\n\n   parameter BAUD = 115200;\n\n   parameter DIVISOR = CLKSPEED / BAUD;\n\n   reg [15:0] rx_bit_cnt = 0;\n   reg [15:0] tx_bit_cnt;\n   reg [10:0] tx_shift_reg;\n   reg [9:0]  rx_shift_reg;\n   reg        rxd1;\n   reg        rxd2;\n   reg        rx_full = 1'b0;\n   reg [7:0]  rx_data;\n   wire       rx_busy;\n   wire       tx_busy;\n\n   assign rx_busy = rx_shift_reg != 10'b1111111111;\n   assign tx_busy = tx_shift_reg != 11'b1;\n   assign txd = tx_shift_reg[0];\n   assign dout = a0 ? {8'h00, rx_data} : { tx_busy, rx_full, 14'b0};\n\n   always @ (posedge clk) begin\n      rxd1 <= rxd;\n      rxd2 <= rxd1;\n      if (!cs_b && rnw && a0) begin\n         rx_full <= 1'b0;\n      end\n      if (!reset_b) begin\n         rx_shift_reg <= 10'b1111111111;\n      end else if (!rx_shift_reg[0]) begin\n         rx_shift_reg <= 10'b1111111111;\n         rx_data <= rx_shift_reg[9:2];\n         rx_full <= 1;\n      end else if (rx_busy) begin\n         if (rx_bit_cnt == 0) begin\n            rx_bit_cnt <= DIVISOR;\n            rx_shift_reg <= {rxd1 , rx_shift_reg[9:1]};\n         end else begin\n            rx_bit_cnt <= rx_bit_cnt - 1;\n         end\n      end else if (!rxd1 && rxd2) begin\n         rx_shift_reg <= 10'b0111111111;\n         rx_bit_cnt <= DIVISOR >> 1;\n      end\n   end\n\n   always @ (posedge clk)\n     if (!reset_b) begin\n        tx_shift_reg <= 11'b1;\n     end else if (tx_busy) begin\n        if (tx_bit_cnt == 0) begin\n           tx_shift_reg <= {1'b0 , tx_shift_reg[10:1]};\n           tx_bit_cnt <= DIVISOR - 1;\n        end else begin\n           tx_bit_cnt <= tx_bit_cnt - 1;\n        end\n     end else if (!cs_b && !rnw && a0) begin\n        tx_shift_reg <= {2'b11, din[7:0], 1'b0};\n        tx_bit_cnt <= DIVISOR - 1;\n     end\n\nendmodule\n",
        "module_name": "uart",
        "module_hash": "4f936182837f81f0a35a044ff7aabf38",
        "dataset_index": 24522
      },
      "traffic_light_fsm_630cf901": {
        "rtl_code": "module traffic_light_fsm(\n  input clk,\n  input reset,\n  output reg NSG_LED,\n  output reg EWG_LED,\n  output reg yellow_LED\n);\n\n  // Define the states\n  parameter NSG = 2'b00;\n  parameter NSG_YELLOW = 2'b01;\n  parameter EWG = 2'b10;\n  parameter EWG_YELLOW = 2'b11;\n\n  // Define the state register and initialize to NSG\n  reg [1:0] state_reg = NSG;\n\n  // Define the state output logic\n  always @ (state_reg) begin\n    case (state_reg)\n      NSG: begin\n        NSG_LED = 1;\n        EWG_LED = 0;\n        yellow_LED = 0;\n      end\n      NSG_YELLOW: begin\n        NSG_LED = 0;\n        EWG_LED = 0;\n        yellow_LED = 1;\n      end\n      EWG: begin\n        NSG_LED = 0;\n        EWG_LED = 1;\n        yellow_LED = 0;\n      end\n      EWG_YELLOW: begin\n        NSG_LED = 0;\n        EWG_LED = 0;\n        yellow_LED = 1;\n      end\n    endcase\n  end\n\n  // Define the state transition logic\n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      state_reg <= NSG;\n    end else begin\n      case (state_reg)\n        NSG: begin\n          if (count == 30) begin\n            state_reg <= NSG_YELLOW;\n            count <= 0;\n          end else begin\n            count <= count + 1;\n          end\n        end\n        NSG_YELLOW: begin\n          if (count == 5) begin\n            state_reg <= EWG;\n            count <= 0;\n          end else begin\n            count <= count + 1;\n          end\n        end\n        EWG: begin\n          if (count == 20) begin\n            state_reg <= EWG_YELLOW;\n            count <= 0;\n          end else begin\n            count <= count + 1;\n          end\n        end\n        EWG_YELLOW: begin\n          if (count == 5) begin\n            state_reg <= NSG;\n            count <= 0;\n          end else begin\n            count <= count + 1;\n          end\n        end\n      endcase\n    end\n  end\n\n  // Define the count register and initialize to 0\n  reg [5:0] count = 0;\n\nendmodule\n",
        "module_name": "traffic_light_fsm",
        "module_hash": "630cf901249aee9e51e92838ae2b7450",
        "dataset_index": 12539
      },
      "shift_register_3_39440b5e": {
        "rtl_code": "\nmodule shift_register_3 (\n    input clk,\n    input reset,\n    input [2:0] data_in,\n    input shift,\n    output [2:0] data_out\n);\n\nreg [2:0] reg_data;\n\nalways @(posedge clk) begin\n    if (reset)\n        reg_data <= 3'b0;\n    else if (shift)\n        reg_data <= {reg_data[1:0], data_in[2]};\nend\n\nassign data_out = reg_data;\n\nendmodule\n\nmodule shift_register_8 (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input shift,\n    output [7:0] data_out\n);\n\nreg [7:0] reg_data;\n\nalways @(posedge clk) begin\n    if (reset)\n        reg_data <= 8'b0;\n    else if (shift)\n        reg_data <= {reg_data[6:0], data_in[7]};\nend\n\nassign data_out = reg_data;\n\nendmodule\n\nmodule binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    input load,\n    input [7:0] data,\n    output reg [2:0] count\n);\n\nwire [2:0] shift_reg_out;\nwire [7:0] shift_reg_8_out;\n\nshift_register_3 shift_reg_3_inst (\n    .clk(clk),\n    .reset(reset),\n    .data_in(count),\n    .shift(enable),\n    .data_out(shift_reg_out)\n);\n\nshift_register_8 shift_reg_8_inst (\n    .clk(clk),\n    .reset(reset),\n    .data_in(data),\n    .shift(load),\n    .data_out(shift_reg_8_out)\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        count <= 3'b0;\n    else if (load)\n        count <= shift_reg_8_out[2:0];\n    else if (enable)\n        count <= count + 1;\nend\n\nendmodule\n",
        "module_name": "shift_register_3",
        "module_hash": "39440b5e90de1af6399f7ae984229984",
        "dataset_index": 16872
      },
      "lin_transmitter_af0beded": {
        "rtl_code": "\nmodule lin_transmitter (\n  input clk,\n  input rst,\n  input [7:0] tx_data,\n  input tx_en,\n  output tx\n);\n\n  reg [3:0] state;\n  reg [7:0] id;\n  reg [7:0] data;\n  reg parity;\n  reg [3:0] bit_count;\n  reg start_bit;\n  reg stop_bit;\n  reg tx_data_reg;\n  integer i;\n  \n  assign tx = tx_data_reg;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      state <= 4'b0000;\n      id <= 8'b00000000;\n      data <= 8'b00000000;\n      bit_count <= 4'b0000;\n      start_bit <= 1'b0;\n      stop_bit <= 1'b0;\n      tx_data_reg <= 1'b0;\n      parity <= 1'b0;\n    end else begin\n      case (state)\n        4'b0000: begin // IDLE state\n          if (tx_en) begin\n            state <= 4'b0001;\n            start_bit <= 1'b1;\n            id <= tx_data;\n            data <= {tx_data[6:0], parity};\n          end\n        end\n        4'b0001: begin // SYNC BREAK state\n          if (bit_count == 4'b0000) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n          end else if (bit_count < 4'b0010) begin\n            tx_data_reg <= 1'b1;\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 4'b0010) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 4'b0011) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n            state <= 4'b0010;\n          end\n        end\n        4'b0010: begin // SYNC FIELD state\n          if (bit_count == 4'b0000) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n          end else if (bit_count < 4'b1000) begin\n            tx_data_reg <= id[bit_count-4];\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 4'b1000) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n            state <= 4'b0011;\n          end\n        end\n        4'b0011: begin // DATA FIELD state\n          if (bit_count == 4'b0000) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n          end else if (bit_count < 4'b1000) begin\n            tx_data_reg <= data[bit_count-1];\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 4'b1000) begin\n            tx_data_reg <= parity;\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 4'b1001) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n            state <= 4'b0100;\n          end\n        end\n        4'b0100: begin // STOP BITS state\n          if (bit_count == 4'b0000) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n          end else if (bit_count < 4'b0010) begin\n            tx_data_reg <= 1'b1;\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 4'b0010) begin\n            tx_data_reg <= 1'b0;\n            bit_count <= bit_count + 1;\n            state <= 4'b0000;\n          end\n        end\n      endcase\n    end\n    \n    if (start_bit) begin\n      parity <= 1'b0;\n      for (i = 0; i < 8; i = i + 1) begin\n        parity <= parity ^ id[i];\n      end\n      for (i = 0; i < 8; i = i + 1) begin\n        parity <= parity ^ data[i];\n      end\n      start_bit <= 1'b0;\n    end\n    \n    if (stop_bit) begin\n      bit_count <= 4'b0000;\n      stop_bit <= 1'b0;\n    end\n    \n    if (bit_count == 4'b1001) begin\n      stop_bit <= 1'b1;\n    end\n    \n    if (state == 4'b0010 || state == 4'b0011 || state == 4'b0100) begin\n      tx_data_reg <= 1'b0;\n    end else begin\n      tx_data_reg <= 1'b1;\n    end\n    \n  end\n  \nendmodule",
        "module_name": "lin_transmitter",
        "module_hash": "af0beded798b7c9b61a4e05f0c31cf49",
        "dataset_index": 2311
      },
      "Key_Command_Controller_c4737601": {
        "rtl_code": "module Key_Command_Controller\n(\n    // Key Input Signals\n    input KEY_CLEAR,\n    input KEY_ADD,\n    input KEY_SUB,\n\n    // Command Signals\n    input      CMD_DONE,\n    output reg CMD_CLEAR,\n    output reg CMD_COMPUTE,\n    output reg CMD_OPERATION,\n    \n    // System Signals\n    input CLK,\n    input RESET\n);\n\n    //\n    // BCD Binary Encoder State Machine\n    //\n    reg [3:0] State;\n    localparam [3:0]\n        S0 = 4'b0001,\n        S1 = 4'b0010,\n        S2 = 4'b0100,\n        S3 = 4'b1000;\n    \n    reg [1:0] key_reg;\n\n    always @(posedge CLK, posedge RESET)\n    begin\n    \n        if (RESET)\n        begin\n\n            key_reg <= 2'h0;\n        \n            CMD_CLEAR <= 1'b0;\n            CMD_COMPUTE <= 1'b0;\n            CMD_OPERATION <= 1'b0;\n        \n            State <= S0;\n            \n        end\n        else\n        begin\n        \n            case (State)\n            \n                S0 :\n                begin\n                \n                    // Capture Keys\n                    key_reg <= { KEY_SUB, KEY_ADD };\n                \n                    // Wait for a Key Input\n                    if (KEY_CLEAR)\n                        State <= S2;\n                    else if (KEY_ADD | KEY_SUB)\n                        State <= S1;\n                \n                end\n                \n                S1 :\n                begin\n                \n                    // Set the operation\n                    case (key_reg)\n                        2'b01 : CMD_OPERATION <= 1'b0; // Add\n                        2'b10 : CMD_OPERATION <= 1'b1; // Sub\n                        default : CMD_OPERATION <= 1'b0; // Invalid\n                    endcase\n                    \n                    // Only start computation for a valid key input\n                    if (^key_reg)\n                        CMD_COMPUTE <= 1'b1;\n                    \n                    \n                    // If valid wait for command to finish, otherwise abort.\n                    if (^key_reg)\n                        State <= S3;\n                    else\n                        State <= S0;\n                        \n                end\n                \n                S2 :\n                begin\n                \n                    // Set the Clear Command\n                    CMD_CLEAR <= 1'b1;\n                    \n                    State <= S3;\n                \n                end\n                \n                S3 :\n                begin\n\n                    // Clear the Command signals\n                    CMD_CLEAR <= 1'b0;\n                    CMD_COMPUTE <= 1'b0;\n                \n                    // Wait for Command to finish\n                    if (CMD_DONE)\n                        State <= S0;\n                        \n                end\n                \n            endcase\n            \n        end\n        \n    end\n\nendmodule",
        "module_name": "Key_Command_Controller",
        "module_hash": "c47376010b4a399389ba8f9e275bf8ea",
        "dataset_index": 186
      },
      "my_delayed_clk_4030f631": {
        "rtl_code": "module my_delayed_clk (\n    output reg GCLK,\n    input GATE,\n    input CLK,\n    input VPWR,\n    input VGND,\n    input RST\n);\n\n    parameter DELAY_CYCLES = 10;\n\n    reg [DELAY_CYCLES-1:0] delay_counter;\n    reg delayed_clk;\n\n    always @(posedge CLK or negedge RST) begin\n        if (!RST) begin\n            delay_counter <= 0;\n            delayed_clk <= 0;\n        end else if (GATE) begin\n            if (delay_counter == DELAY_CYCLES-1) begin\n                delayed_clk <= 1;\n            end else begin\n                delayed_clk <= 0;\n            end\n            delay_counter <= delay_counter + 1;\n        end\n    end\n\n    always @(posedge CLK or negedge RST) begin\n        if (!RST) begin\n            GCLK <= 0;\n        end else begin\n            GCLK <= delayed_clk;\n        end\n    end\n\nendmodule",
        "module_name": "my_delayed_clk",
        "module_hash": "4030f631d814c76a506b1f0760eb7600",
        "dataset_index": 8950
      },
      "my__d8cfe47f": {
        "rtl_code": "module my_module (\n  input in0, in1, in2, in3, d0, d1, d2, d3, clk, reset,\n  output reg out0, out1, out2, out3\n);\n\n  wire n1, n2, n3, n4;\n\n  assign n1 = ~(reset | n1);\n  assign n2 = (in0 & d0) | (in1 & ~d0);\n  assign n3 = ~(reset | n3);\n  assign n4 = (in2 & d3) | (in3 & ~d3);\n\n  always @(posedge clk) begin\n    out0 <= d0;\n    out1 <= d1;\n    out2 <= d2;\n    out3 <= d3;\n  end\n\nendmodule",
        "module_name": "my_",
        "module_hash": "d8cfe47f11f1b8ca8122bed3a5cafece",
        "dataset_index": 1536
      },
      "comparator_16bit_bd7e8857": {
        "rtl_code": "module comparator_16bit (\n    input [15:0] a,\n    input [15:0] b,\n    output eq\n);\n\nassign eq = (a == b);\n\nendmodule",
        "module_name": "comparator_16bit",
        "module_hash": "bd7e8857aca1d44a5ecacc994478638d",
        "dataset_index": 18380
      },
      "sky130_fd_sc_lp__and4_0385f048": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__and4",
        "module_hash": "0385f048f4ff93024f737203bef274d3",
        "dataset_index": 21522
      },
      "Ethernet_MAC #_30c79e9f": {
        "rtl_code": "\nmodule Ethernet_MAC #(\n  parameter n = 8, // number of input signals\n  parameter m = 8 // number of output signals\n)(\n  input [n-1:0] data_in,\n  input [47:0] dest_mac,\n  input [47:0] src_mac,\n  input clk,\n  input reset,\n  output reg [n-1:0] data_out,\n  output reg [47:0] dest_mac_out,\n  output reg [47:0] src_mac_out,\n  output reg tx_en,\n  output reg rx_en\n);\n\nreg [7:0] preamble = 8'h55; // Ethernet preamble\nreg [31:0] sfd = 32'hD5C5D5C5; // Ethernet Start Frame Delimiter\n\nreg [47:0] dest_mac_reg; // register for storing destination MAC address\nreg [47:0] src_mac_reg; // register for storing source MAC address\nreg [n-1:0] data_reg; // register for storing data\n\nreg [31:0] frame_cnt; // counter for tracking the number of bits in a frame\nreg [3:0] state; // state machine state\n\nparameter IDLE = 4'b0000; // idle state\nparameter PREAMBLE = 4'b0001; // preamble state\nparameter SFD = 4'b0010; // start frame delimiter state\nparameter DEST_MAC = 4'b0011; // destination MAC address state\nparameter SRC_MAC = 4'b0100; // source MAC address state\nparameter LENGTH = 4'b0101; // length state\nparameter DATA = 4'b0110; // data state\nparameter FCS = 4'b0111; // frame check sequence state\n\nalways @(posedge clk) begin\n  if (reset) begin\n    state <= IDLE;\n    frame_cnt <= 0;\n    tx_en <= 0;\n    rx_en <= 0;\n  end else begin\n    case (state)\n      IDLE: begin\n        tx_en <= 0;\n        rx_en <= 1;\n        if (data_in != 0) begin\n          state <= PREAMBLE;\n          frame_cnt <= 0;\n          dest_mac_reg <= dest_mac;\n          src_mac_reg <= src_mac;\n          data_reg <= data_in;\n        end\n      end\n      PREAMBLE: begin\n        tx_en <= 1;\n        rx_en <= 0;\n        if (frame_cnt == 7) begin\n          state <= SFD;\n          frame_cnt <= 0;\n        end else begin\n          data_out <= preamble;\n          frame_cnt <= frame_cnt + 1;\n        end\n      end\n      SFD: begin\n        tx_en <= 1;\n        rx_en <= 0;\n        if (frame_cnt == 31) begin\n          state <= DEST_MAC;\n          frame_cnt <= 0;\n        end else begin\n          data_out <= sfd[frame_cnt];\n          frame_cnt <= frame_cnt + 1;\n        end\n      end\n      DEST_MAC: begin\n        tx_en <= 1;\n        rx_en <= 0;\n        if (frame_cnt == 47) begin\n          state <= SRC_MAC;\n          frame_cnt <= 0;\n        end else begin\n          data_out <= dest_mac_reg[frame_cnt];\n          frame_cnt <= frame_cnt + 1;\n        end\n      end\n      SRC_MAC: begin\n        tx_en <= 1;\n        rx_en <= 0;\n        if (frame_cnt == 95) begin\n          state <= LENGTH;\n          frame_cnt <= 0;\n        end else begin\n          data_out <= src_mac_reg[frame_cnt-48];\n          frame_cnt <= frame_cnt + 1;\n        end\n      end\n      LENGTH: begin\n        tx_en <= 1;\n        rx_en <= 0;\n        if (frame_cnt == 111) begin\n          state <= DATA;\n          frame_cnt <= 0;\n        end else begin\n          data_out <= 0;\n          frame_cnt <= frame_cnt + 1;\n        end\n      end\n      DATA: begin\n        tx_en <= 1;\n        rx_en <= 0;\n        if (frame_cnt == (n*8)-1) begin\n          state <= FCS;\n          frame_cnt <= 0;\n        end else begin\n          data_out <= data_reg[frame_cnt-112];\n          frame_cnt <= frame_cnt + 1;\n        end\n      end\n      FCS: begin\n        tx_en <= 1;\n        rx_en <= 0;\n        if (frame_cnt == 127) begin\n          state <= IDLE;\n          frame_cnt <= 0;\n        end else begin\n          data_out <= 0;\n          frame_cnt <= frame_cnt + 1;\n        end\n      end\n    endcase\n  end\nend\n\n// Assign output registers\nalways @(posedge clk) begin\n  if (reset) begin\n    dest_mac_out <= 0;\n    src_mac_out <= 0;\n  end else begin\n    if (state == IDLE) begin\n      dest_mac_out <= dest_mac;\n      src_mac_out <= src_mac;\n    end\n  end\nend\n\nendmodule",
        "module_name": "Ethernet_MAC #",
        "module_hash": "30c79e9f22ca3fe2dc67aa1749a60ac3",
        "dataset_index": 1869
      },
      "sky130_fd_sc_hd__a32o_b8101bad": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__a32o (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A3, A1, A2        );\n    and and1 (and1_out , B1, B2            );\n    or  or0  (or0_out_X, and1_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a32o",
        "module_hash": "b8101bad0acad430791a967c4138f82a",
        "dataset_index": 23069
      },
      "port_control_752454cd": {
        "rtl_code": "module port_control (\n    input clk,\n    input [99:0] in_port,\n    output reg [99:0] out_port,\n    input enable,\n    input reset\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out_port <= 0;\n    end else if (enable) begin\n        out_port <= in_port;\n    end\nend\n\nendmodule",
        "module_name": "port_control",
        "module_hash": "752454cd4cf360cdd37607b42b2fa4be",
        "dataset_index": 15632
      },
      "ripple_carry_adder_91d0bcff": {
        "rtl_code": "module ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] C;\n\n    assign C[0] = Cin;\n    assign C[1] = (A[0] & B[0]) | (A[0] & C[0]) | (B[0] & C[0]);\n    assign C[2] = (A[1] & B[1]) | (A[1] & C[1]) | (B[1] & C[1]);\n    assign C[3] = (A[2] & B[2]) | (A[2] & C[2]) | (B[2] & C[2]);\n\n    assign Sum[0] = A[0] ^ B[0] ^ Cin;\n    assign Sum[1] = A[1] ^ B[1] ^ C[1];\n    assign Sum[2] = A[2] ^ B[2] ^ C[2];\n    assign Sum[3] = A[3] ^ B[3] ^ C[3];\n\n    assign Cout = C[3];\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "91d0bcff6b0c85dd36e4e6a9f88b73b2",
        "dataset_index": 19484
      },
      "binary_adder_fad5553b": {
        "rtl_code": "module binary_adder (\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [8:0] result,\n    output reg overflow\n);\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            result <= 0;\n            overflow <= 0;\n        end else begin\n            result <= A + B;\n            overflow <= (result > 8'b11111111);\n        end\n    end\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "fad5553bda474d2b3677827e8342b74f",
        "dataset_index": 13822
      },
      "nand4_91d9e3be": {
        "rtl_code": "\nmodule nand4 (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    VPWR,\n    VGND\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n\n    wire nand1_out;\n    wire nand2_out;\n    wire nand3_out;\n\n    nand (nand1_out, A, B);\n    nand (nand2_out, C, D);\n    nand (nand3_out, nand1_out, nand2_out);\n    nand (Y, nand3_out, nand3_out);\n\nendmodule",
        "module_name": "nand4",
        "module_hash": "91d9e3bef6584c1883f3dbfad0cfa1a2",
        "dataset_index": 14437
      },
      "concat_0930f84e": {
        "rtl_code": "module concat (\n  input [7:0] In0,\n  input [1:0] In1,\n  input clk,\n  output reg [9:0] dout\n);\n\n  always @(posedge clk)\n  begin\n    dout[9:8] <= In1;\n    dout[7:0] <= In0;\n  end\n\nendmodule",
        "module_name": "concat",
        "module_hash": "0930f84e4d78ddf21eed9d2804af8d3d",
        "dataset_index": 4191
      },
      "priority_encoder_3f595294": {
        "rtl_code": "module priority_encoder (\n    input [2:0] in,\n    output reg [7:0] out\n);\n\nalways @*\nbegin\n    case(in)\n        3'b000: out = 8'b00000001;\n        3'b001: out = 8'b00000010;\n        3'b010: out = 8'b00000100;\n        3'b011: out = 8'b00001000;\n        3'b100: out = 8'b00010000;\n        3'b101: out = 8'b00100000;\n        3'b110: out = 8'b01000000;\n        3'b111: out = 8'b10000000;\n        default: out = 8'b00000000;\n    endcase\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "3f595294cfba17247fa778bb55addce3",
        "dataset_index": 12282
      },
      "sky130_fd_sc_hd__a222oi_ac94fbad": {
        "rtl_code": "module sky130_fd_sc_hd__a222oi (\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  B2  ,\n    input  C1  ,\n    input  C2  ,\n    output Y   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    assign Y = (A1 && !A2) ? 1 :\n               (!A1 && A2) ? 0 :\n               (!A1 && !A2 && (B1 || C1)) ? 1 :\n               (!A1 && !A2 && (B2 || C2)) ? 0 :\n               (A1 && A2 && B1 && C1) ? 1 :\n               (A1 && A2 && B2 && C2) ? 0 :\n               1'b0;\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__a222oi",
        "module_hash": "ac94fbada8093c83b87921990bd089ff",
        "dataset_index": 13544
      },
      "control__fc04c485": {
        "rtl_code": "module control_module (\n    input_1,\n    input_2,\n    input_3,\n    input_4,\n    input_5,\n    input_6,\n    input_7,\n    input_8,\n    output_1\n);\n\n    input [3:0] input_1;\n    input [1:0] input_2;\n    input input_3;\n    input input_4;\n    input input_5;\n    input input_6;\n    input input_7;\n    input input_8;\n    output reg output_1;\n    \n    always @ (input_1 or input_2 or input_3 or input_4 or input_5 or input_6 or input_7 or input_8) begin\n        case (input_1)\n            0: output_1 = 0;\n            1: output_1 = input_3;\n            2: output_1 = input_4;\n            3: output_1 = input_5;\n            4: output_1 = input_6;\n            5: output_1 = input_7;\n            6: output_1 = input_8;\n            7: output_1 = input_2;\n            default: output_1 = 0;\n        endcase\n    end\nendmodule",
        "module_name": "control_",
        "module_hash": "fc04c4851fb073ef253188abf5e63f8c",
        "dataset_index": 4303
      },
      "inicial_f1d048b8": {
        "rtl_code": "module inicial ( botao, aberto, fechado, motor, sentido, ledVerde, ledVermelho, display, clock );\n\tinput botao, aberto, fechado, motor, sentido, clock;\n\toutput ledVerde, ledVermelho;\n\toutput [6:0] display;\n\t\n\treg [1:0] estado;\n\treg [4:0] entrada;\n\t\n\treg [6:0] tmpDisplay;\n\treg tmpLedVerde, tmpLedVermelho;\n\t\n\tparameter Fechado = 2'b00, Abrindo = 2'b01, Aberto = 2'b10, Fechando = 2'b11;\n\t\n\tinitial estado = Fechado;\n\t\n\talways @(posedge clock)begin\n            entrada[4] = botao;\n            entrada[3] = aberto;\n            entrada[2] = fechado;\n            entrada[1] = motor;\n            entrada[0] = sentido;\n      \t        \n          \tcase( estado )\n          \t\t\tFechado: begin\n\t\t\t\t\t\t\t\t\t  tmpDisplay = 7'b0001110;\n\t\t\t\t\t\t\t\t\t  tmpLedVerde = 0;\n\t\t\t\t\t\t\t\t\t  tmpLedVermelho = 0;\n\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t  if( entrada == 5'b10110 ) estado = Abrindo;\n\t\t\t\t\t\t\t\t\tend\n          \t\t\t   \n          \t\t\tAbrindo: begin\n\t\t\t\t\t\t\t\t\t  tmpDisplay = 7'b1000000;\n\t\t\t\t\t\t\t\t\t  tmpLedVerde = 1;\n\t\t\t\t\t\t\t\t\t  tmpLedVermelho = 0;\n\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\tif( entrada == 5'b10010 ) estado = Aberto;\n\t\t\t\t\t\t\t\t\t\tif( entrada == 5'b00010 ) estado = Fechando;\n\t\t\t\t\t\t\t\t\tend\n          \t\t\t\t\n          \t\t\tAberto: begin\n\t\t\t\t\t\t\t\t\t  tmpDisplay = 7'b0001000;\n\t\t\t\t\t\t\t\t\t  tmpLedVerde = 0;\n\t\t\t\t\t\t\t\t\t  tmpLedVermelho = 0;\n\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t  if( entrada == 5'b01011 ) estado = Fechando;\n\t\t\t\t\t\t\t\t  end\n          \t\t\t   \n          \t\t\tFechando: begin\n\t\t\t\t\t\t\t\t\t  tmpDisplay = 7'b1000000;\n\t\t\t\t\t\t\t\t\t  tmpLedVerde = 0;\n\t\t\t\t\t\t\t\t\t  tmpLedVermelho = 1;\n\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\tif( entrada == 5'b10011 ) estado = Abrindo;\n\t\t\t\t\t\t\t\t\t\tif( entrada == 5'b00011 ) estado = Fechado;\n\t\t\t\t\t\t\t\t\t end\n          \t\t\t   \n          \t\t\tdefault: estado = Fechado;\n          \t\t\t\n          \tendcase\n\tend\n\t\n\tassign display= tmpDisplay;\n\tassign ledVerde = tmpLedVerde;\n\tassign ledVermelho = tmpLedVermelho;\n\t\nendmodule\n\nmodule maquina(SW,LEDG,LEDR,HEX0, CLK);\n\tinput [4:0] SW;\n\tinput CLK;\n\toutput [0:0] LEDG, LEDR;\n\toutput [6:0] HEX0;\n\n\tinicial a( SW[4], SW[3], SW[2], SW[1], SW[0], LEDG[0], LEDR[0], HEX0, CLK);\nendmodule\n",
        "module_name": "inicial",
        "module_hash": "f1d048b8606f6de8c22ac49d9eefd90a",
        "dataset_index": 3431
      },
      "mul16_8940e535": {
        "rtl_code": "module mul16(\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] result\n);\n\nalways @(*) begin\n    result = a * b;\nend\n\nendmodule\n\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    input enable,\n    output [31:0] result\n);\n\nwire [15:0] a_low = a[15:0];\nwire [15:0] a_high = a[31:16];\nwire [15:0] b_low = b[15:0];\nwire [15:0] b_high = b[31:16];\n\nwire [31:0] mul_low;\nwire [31:0] mul_high;\n\nmul16 mul1(\n    .a(a_low),\n    .b(b_low),\n    .result(mul_low)\n);\n\nmul16 mul2(\n    .a(a_high),\n    .b(b_high),\n    .result(mul_high)\n);\n\nassign result = enable ? {mul_high, mul_low} : 0;\n\nendmodule",
        "module_name": "mul16",
        "module_hash": "8940e535040685d710a54196883ef50d",
        "dataset_index": 13364
      },
      "digital_lock_51883203": {
        "rtl_code": "\nmodule digital_lock (\n    input [3:0] code, // 4-digit binary code input\n    output reg open // Output signal indicating whether the lock is open or not\n);\n\n    // Define the stored password\n    reg [3:0] password = 4'b0001;\n\n    // Define the control logic\n    reg state = 1'b0;\n    always @ (code) begin\n        if (code == 4'b0000) state <= ~state;\n    end\n\n    // Define the decoder and multiplexer module\n    wire password_bit;\n    assign password_bit = (state) ? password[0] : password[1];\n\n    // Define the 8-bit adder module\n    reg [7:0] sum;\n    always @ (*) begin\n        sum = {4'b0, code} + {4'b0, password_bit};\n    end\n\n    // Define the output logic\n    always @ (sum) begin\n        if (sum == 8'b00000000) open <= 1'b1;\n        else open <= 1'b0;\n    end\n\nendmodule",
        "module_name": "digital_lock",
        "module_hash": "51883203b6389c649be2259289e01507",
        "dataset_index": 1047
      },
      "de3d_tc_mc_we_c6791742": {
        "rtl_code": "\n\n\n\nmodule de3d_tc_mc_we\n\t(\n\tinput\t\tmclock,\t\tinput\t\trstn,\n\tinput\t\ttex_push_en,\tinput\t\tram_sel,\toutput reg\tram_wen_lo,\toutput reg\tram_wen_hi\t);\n\nreg \tcs;\n\nalways @(posedge mclock, negedge rstn) begin\n\tif(!rstn) cs <= 1'b0;\n\telse begin\n\tcase(cs)\n\t\t1'b0: \tif(tex_push_en) cs <= 1'b1;\n\t\t \telse cs = 1'b0;\n\n\t\t1'b1: \tif(tex_push_en) cs <= 1'b0;\n\t\t \telse cs = 1'b1;\n\n\tendcase\n\tend\nend\n\nalways @* ram_wen_lo = tex_push_en & ((~cs & ~ram_sel) | ( cs & ram_sel));\nalways @* ram_wen_hi = tex_push_en & (( cs & ~ram_sel) | (~cs & ram_sel));\n\nendmodule\n",
        "module_name": "de3d_tc_mc_we",
        "module_hash": "c6791742230ed2162a9bbc247a814e97",
        "dataset_index": 22030
      },
      "jt51_timers_e12d2303": {
        "rtl_code": "\n\nmodule jt51_timers(\n    input         rst,\n    input         clk,\n    input         cen,\n    input         zero,\n    input [9:0]   value_A,\n    input [7:0]   value_B,\n    input         load_A,\n    input         load_B,\n    input         clr_flag_A,\n    input         clr_flag_B,\n    input         enable_irq_A,\n    input         enable_irq_B,\n    output        flag_A,\n    output        flag_B,\n    output        overflow_A,\n    output        irq_n\n);\n\nassign irq_n = ~( (flag_A&enable_irq_A) | (flag_B&enable_irq_B) );\n\njt51_timer #(.CW(10)) timer_A(\n    .rst        ( rst       ),\n    .clk        ( clk       ),\n    .cen        ( cen       ),\n    .zero       ( zero      ),\n    .start_value( value_A   ),\n    .load       ( load_A    ),\n    .clr_flag   ( clr_flag_A),\n    .flag       ( flag_A    ),\n    .overflow   ( overflow_A)\n);\n\njt51_timer #(.CW(8),.FREE_EN(1)) timer_B(\n    .rst        ( rst           ),\n    .clk        ( clk           ),\n    .cen        ( cen           ),\n    .zero       ( zero          ),\n    .start_value( value_B       ),\n    .load       ( load_B        ),\n    .clr_flag   ( clr_flag_B    ),\n    .flag       ( flag_B        ),\n    .overflow   (               )\n);\n\nendmodule\n\nmodule jt51_timer #(parameter\n    CW      = 8, FREE_EN = 0  ) (\n    input   rst,\n    input   clk,\n    input   cen,\n    input   zero,\n    input   [CW-1:0] start_value,\n    input   load,\n    input   clr_flag,\n    output reg flag,\n    output reg overflow\n);\n\nreg          last_load;\nreg [CW-1:0] cnt, next;\nreg [   3:0] free_cnt, free_next;\nreg          free_ov;\n\nalways@(posedge clk, posedge rst)\n    if( rst )\n        flag <= 1'b0;\n    else  begin\n        if( clr_flag )\n            flag <= 1'b0;\n        else if(overflow) flag<=1'b1;\n    end\n\nalways @(*) begin\n    {free_ov, free_next} = { 1'b0, free_cnt} + 1'b1;\n    \n    {overflow, next }    = { 1'b0, cnt }     + (FREE_EN ? free_ov : 1'b1);\n    \nend\n\nalways @(posedge clk) if(cen && zero) begin : counter\n    last_load <= load;\n    if( (load && !last_load) || overflow ) begin\n      cnt  <= start_value;\n    end\n    else if( last_load ) cnt <= next;\nend\n\nalways @(posedge clk) begin\n    if( rst ) begin\n        free_cnt <= 4'd0;\n    end else if( cen&&zero ) begin\n        free_cnt <= free_cnt+4'd1;\n    end\nend\n\nendmodule\n",
        "module_name": "jt51_timers",
        "module_hash": "e12d2303da2a898aa44646b580d45d4a",
        "dataset_index": 21320
      },
      "sky130_fd_sc_hdll__and4_e3911619": {
        "rtl_code": "module sky130_fd_sc_hdll__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    // Module ports\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    // Local signals\n    wire and0_out_X;\n    wire and1_out_X;\n\n    //  Name  Output      Other arguments\n    and and0 (and0_out_X, C, A, B        );\n    and and1 (and1_out_X, D, and0_out_X  );\n    buf buf0 (X         , and1_out_X     );\n\nendmodule",
        "module_name": "sky130_fd_sc_hdll__and4",
        "module_hash": "e39116198867fa76ff3db744b84d5bda",
        "dataset_index": 18948
      },
      "altera_reset_synchronizer_ccd9baa9": {
        "rtl_code": "\n\nmodule altera_reset_synchronizer\n#(\n    parameter ASYNC_RESET = 1,\n    parameter DEPTH       = 2\n)\n(\n    input   reset_in ,\n\n    input   clk,\n    output  reset_out\n);\n\n     reg [DEPTH-1:0] altera_reset_synchronizer_int_chain;\n    reg altera_reset_synchronizer_int_chain_out;\n\n    generate if (ASYNC_RESET) begin\n\n        always @(posedge clk or posedge reset_in) begin\n            if (reset_in) begin\n                altera_reset_synchronizer_int_chain <= {DEPTH{1'b1}};\n                altera_reset_synchronizer_int_chain_out <= 1'b1;\n            end\n            else begin\n                altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n                altera_reset_synchronizer_int_chain[DEPTH-1] <= 0;\n                altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n            end\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n     \n    end else begin\n\n        always @(posedge clk) begin\n            altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n            altera_reset_synchronizer_int_chain[DEPTH-1] <= reset_in;\n            altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n \n    end\n    endgenerate\n\nendmodule\n\n",
        "module_name": "altera_reset_synchronizer",
        "module_hash": "ccd9baa9b034fd333258968d1d28a2eb",
        "dataset_index": 365
      },
      "top__d38e06b7": {
        "rtl_code": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] c;\n    wire [7:0] g;\n    wire [7:0] p;\n    wire [7:0] carry;\n    wire [7:0] sum;\n\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .c(c)\n    );\n\n    assign g = a & b;\n    assign p = a ^ b;\n    assign carry[0] = g[0];\n    assign overflow = g[7];\n    \n    generate\n        genvar i;\n        for (i = 1; i < 8; i = i + 1) begin : carry_lookahead\n            assign carry[i] = g[i] | (p[i] & carry[i-1]);\n        end\n    endgenerate\n\n    assign sum = a + b + {1'b0, carry[6:0]};\n    assign s = sum[7:0];\n\nendmodule\n\nmodule and_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] c\n);\n\n    assign c = a & b;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "d38e06b73fd85b9dcfe67044696b8ca8",
        "dataset_index": 8194
      },
      "pulse_gen_7f5462a2": {
        "rtl_code": "module pulse_gen(\n    input CLK,\n    input RST,\n    input START,\n    input [15:0] DURATION,\n    output reg PULSE\n);\n\nreg [15:0] count;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        count <= 0;\n        PULSE <= 0;\n    end\n    else if (START) begin\n        if (count < DURATION) begin\n            count <= count + 1;\n            PULSE <= 1;\n        end\n        else begin\n            count <= 0;\n            PULSE <= 0;\n        end\n    end\n    else begin\n        count <= 0;\n        PULSE <= 0;\n    end\nend\n\nendmodule",
        "module_name": "pulse_gen",
        "module_hash": "7f5462a2a034f807ad4f769a69e9e5c9",
        "dataset_index": 7468
      },
      "fsm_using_single_always_fed76824": {
        "rtl_code": "module fsm_using_single_always (\nclock      , reset      , req_0      , req_1      , gnt_0      , gnt_1      \n);\ninput   clock,reset,req_0,req_1;\n output  gnt_0,gnt_1;\nwire    clock,reset,req_0,req_1;\nreg     gnt_0,gnt_1;\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\nreg   [SIZE-1:0]          state        ;reg   [SIZE-1:0]          next_state   ;always @ (posedge clock)\nbegin : FSM\nif (reset == 1'b1) begin\n  state <= #1 IDLE;\n  gnt_0 <= 0;\n  gnt_1 <= 0;\nend else\n case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                state <= #1 GNT0;\n                gnt_0 <= 1;\n              end else if (req_1 == 1'b1) begin\n                gnt_1 <= 1;\n                state <= #1 GNT1;\n              end else begin\n                state <= #1 IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                state <= #1 GNT0;\n              end else begin\n                gnt_0 <= 0;\n                state <= #1 IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                state <= #1 GNT1;\n              end else begin\n                gnt_1 <= 0;\n                state <= #1 IDLE;\n              end\n   default : state <= #1 IDLE;\nendcase\nend\n\nendmodule // End of Module arbiter",
        "module_name": "fsm_using_single_always",
        "module_hash": "fed76824dcb1b41d62803d9d80605c0c",
        "dataset_index": 7440
      },
      "tai_counter_75d98a1c": {
        "rtl_code": "\nmodule tai_counter(\ninput\t[63:0]\t\tsec_data_in,\t\ninput\t[31:0]\t\tnanosec_data_in,\ninput\t\t\t\tpps_in, \t\t\ninput\t\t\t\tclk_in, \t\t\ninput\t\t\t\tcnt_ena_in, \t\ninput\t\t\t\tpps_bypass_in,\t\ninput\t\t\t\tclr_n_in, \t\t\ninput\t\t\t\tload_sec_in,\t\ninput\t\t\t\tload_nanosec_in,\noutput\t[63:0]\t\tsec_data_out,\t\noutput\t[31:0]\t\tnanosec_data_out\n);\n\nreg\t\t[63:0]\t\tseconds;\t\t\t\t\t\t\nreg\t\t[31:0]\t\tnanoseconds;\t\t\t\t\t\nreg\t\t\t\t\tload_sec_l, load_sec_p;\t\t\t\nreg\t\t\t\t\tload_nanosec_l, load_nanosec_p;\t\nwire\t\t\t\tnano_counter_carry;\t\t\t\t\nreg\t\t\t\t\tnano_counter_clr;\n\nparameter SYSCLK_FREQ = 32'd100_000_000; \n\n\nassign\tnano_counter_carry = (nanoseconds < SYSCLK_FREQ - 1) ? 1'b0:1'b1;\n\nalways @ (posedge clk_in or negedge clr_n_in)\nbegin\n\tif (!clr_n_in) begin\n\t\tnano_counter_clr <= 0;\n\tend\n\telse begin\n\t\tnano_counter_clr <= !(nano_counter_carry);\n\tend\nend\n\nassign sec_data_out = seconds;\nassign nanosec_data_out = nanoseconds;\n\n\nalways @ (posedge clk_in or negedge clr_n_in)\nbegin\n\tif (!clr_n_in) begin\n\t\tload_sec_l <= 0;\n\t\tload_sec_p <= 0;\n\t\tload_nanosec_l <= 0;\n\t\tload_nanosec_p <= 0;\n\tend\n\telse begin\n\t\tload_sec_l <= load_sec_p;\n\t\tload_sec_p <= load_sec_in;\n\t\tload_nanosec_l <= load_nanosec_p;\n\t\tload_nanosec_p <= load_nanosec_in;\n\tend\nend\n\n\nalways @ (posedge clk_in or negedge nano_counter_clr)\nbegin\n\tif (!nano_counter_clr) begin\n\t\tnanoseconds <= 32'b0;\n\tend\n\telse if (!cnt_ena_in) begin\tnanoseconds <= nanoseconds;\n\tend\n\telse if ((load_nanosec_l == 0) && (load_nanosec_p == 1)) begin\tnanoseconds <= nanosec_data_in;\n\tend\n\telse begin\n\t\tnanoseconds <= nanoseconds + 1'b1;\n\tend\nend\n\n\nalways @ (posedge pps_in or negedge clr_n_in)\nbegin\n\tif (!clr_n_in) begin\n\t\tseconds <= 0;\n\tend\n\telse if (!cnt_ena_in) begin\n\t\tseconds <= seconds;\n\tend\n\telse if ((load_sec_l == 0) && (load_sec_p == 1)) begin\n\t\tseconds <= sec_data_in;\n\tend\n\telse begin\n\t\tseconds <= seconds + 1'b1;\n\tend\nend\n\nendmodule\n",
        "module_name": "tai_counter",
        "module_hash": "75d98a1c34e3405974bb9378dcad637d",
        "dataset_index": 20142
      },
      "bin2gray_2cc09d85": {
        "rtl_code": "module bin2gray(\n    input [3:0] in,\n    output [3:0] out\n);\n\nassign out[0] = in[0];\nassign out[1] = in[0] ^ in[1];\nassign out[2] = in[1] ^ in[2];\nassign out[3] = in[2] ^ in[3];\n\nendmodule",
        "module_name": "bin2gray",
        "module_hash": "2cc09d854ffe45128587252c8583abcc",
        "dataset_index": 12483
      },
      "top__f41ae0ca": {
        "rtl_code": "module top_module (\n    input clk,\n    input [7:0] data_in,\n    output reg [8:0] out\n);\n\nreg [7:0] serial_data;\nreg [3:0] parity_bits;\n\n// Parallel to Serial Conversion Module\nalways @(posedge clk) begin\n    serial_data <= data_in;\nend\n\n// Hamming Code Parity Generator Module\nalways @(posedge clk) begin\n    parity_bits[0] <= serial_data[0] ^ serial_data[1] ^ serial_data[3] ^ serial_data[4] ^ serial_data[6];\n    parity_bits[1] <= serial_data[0] ^ serial_data[2] ^ serial_data[3] ^ serial_data[5] ^ serial_data[6];\n    parity_bits[2] <= serial_data[1] ^ serial_data[2] ^ serial_data[3] ^ serial_data[7];\n    parity_bits[3] <= serial_data[4] ^ serial_data[5] ^ serial_data[6] ^ serial_data[7];\nend\n\n// Output Module\nalways @(posedge clk) begin\n    out[0] <= parity_bits[0];\n    out[1] <= parity_bits[1];\n    out[2] <= serial_data[0];\n    out[3] <= parity_bits[2];\n    out[4] <= serial_data[1];\n    out[5] <= serial_data[2];\n    out[6] <= serial_data[3];\n    out[7] <= parity_bits[3];\n    out[8] <= serial_data[4];\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "f41ae0ca2514adfa94a0e7af928c454e",
        "dataset_index": 3758
      },
      "my__a221f512": {
        "rtl_code": "module my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = (~A1 & A2) | (A1 & ~A2) | (~A1 & ~A2 & ~B1_N);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "a221f512bb9cd03468ff273158bebcd7",
        "dataset_index": 416
      },
      "fifo_address_sync #_d90b3b16": {
        "rtl_code": "module fifo_address_sync #(\n  parameter ADDRESS_WIDTH = 4\n) (\n  input clk,\n  input resetn,\n\n  input m_axis_ready,\n  output reg m_axis_valid,\n  output reg  [ADDRESS_WIDTH-1:0] m_axis_raddr,\n  output [ADDRESS_WIDTH:0] m_axis_level,\n\n  output reg s_axis_ready,\n  input s_axis_valid,\n  output reg s_axis_empty,\n  output reg [ADDRESS_WIDTH-1:0] s_axis_waddr,\n  output [ADDRESS_WIDTH:0] s_axis_room\n);\n\nlocalparam MAX_ROOM = {1'b1,{ADDRESS_WIDTH{1'b0}}};\n\nreg [ADDRESS_WIDTH:0] room = MAX_ROOM;\nreg [ADDRESS_WIDTH:0] level = 'h00;\nreg [ADDRESS_WIDTH:0] level_next;\n\nassign s_axis_room = room;\nassign m_axis_level = level;\n\nwire read = m_axis_ready & m_axis_valid;\nwire write = s_axis_ready & s_axis_valid;\n\nalways @(posedge clk)\nbegin\n  if (resetn == 1'b0) begin\n    s_axis_waddr <= 'h00;\n    m_axis_raddr <= 'h00;\n  end else begin\n    if (write)\n      s_axis_waddr <= s_axis_waddr + 1'b1;\n    if (read)\n      m_axis_raddr <= m_axis_raddr + 1'b1;\n  end\nend\n\nalways @(*)\nbegin\n  if (read & ~write)\n    level_next <= level - 1'b1;\n  else if (~read & write)\n    level_next <= level + 1'b1;\n  else\n    level_next <= level;\nend\n\nalways @(posedge clk)\nbegin\n  if (resetn == 1'b0) begin\n    m_axis_valid <= 1'b0;\n    s_axis_ready <= 1'b0;\n    level <= 'h00;\n    room <= MAX_ROOM;\n    s_axis_empty <= 'h00;\n  end else begin\n    level <= level_next;\n    room <= MAX_ROOM - level_next;\n    m_axis_valid <= level_next != 0;\n    s_axis_ready <= level_next != MAX_ROOM;\n    s_axis_empty <= level_next == 0;\n  end\nend\n\nendmodule",
        "module_name": "fifo_address_sync #",
        "module_hash": "d90b3b16100966eacb7e6ecd4d23b68b",
        "dataset_index": 1875
      },
      "aur1_STANDARD_CC_MODULE_043c81d6": {
        "rtl_code": "\n\nmodule aur1_STANDARD_CC_MODULE\n(\n    RESET,\n    WARN_CC,\n    DO_CC,\n    \n    PLL_NOT_LOCKED,\n    USER_CLK\n\n);\n\n`define DLY #1\n\noutput      WARN_CC;\n    output      DO_CC;\n    \n    input       PLL_NOT_LOCKED;\n    input       USER_CLK;\n    input       RESET;\n    \nreg             WARN_CC;\n    reg             DO_CC;\n\nreg     [0:9]   prepare_count_r;\n    reg     [0:5]   cc_count_r;\n    reg             reset_r;\n    \n    reg     [0:11]  count_13d_srl_r;\n    reg             count_13d_flop_r;\n    reg     [0:14]  count_16d_srl_r;\n    reg             count_16d_flop_r;\n    reg     [0:22]  count_24d_srl_r;\n    reg             count_24d_flop_r;    \n\nwire    enable_cc_c;\n\n    wire    start_cc_c;\n    wire    inner_count_done_r;\n    wire    middle_count_done_c;\n    wire    cc_idle_count_done_c;\n   \nassign enable_cc_c = !RESET;\n \n    always @(posedge USER_CLK)\n       if(RESET)\n        count_13d_srl_r     <=  `DLY    12'b000000000000;\n       else\n        count_13d_srl_r     <=  `DLY    {count_13d_flop_r, count_13d_srl_r[0:10]};\n        \n    assign  inner_count_done_r  =  count_13d_srl_r[11];\n \n    always @(posedge USER_CLK)\n        if(RESET)\n            count_13d_flop_r    <=  `DLY    1'b0;\n        else if(enable_cc_c && reset_r)\n            count_13d_flop_r    <=  `DLY    1'b1;\n        else\n            count_13d_flop_r    <=  `DLY    inner_count_done_r;\n \n    always @(posedge USER_CLK)\n        if(RESET)\n            count_16d_srl_r     <=  `DLY    15'b000000000000000;\n        else if(inner_count_done_r|| !enable_cc_c)\n            count_16d_srl_r     <=  `DLY    {count_16d_flop_r, count_16d_srl_r[0:13]};\n            \n    assign  middle_count_done_c =   inner_count_done_r && count_16d_srl_r[14];     \n \n    always @(posedge USER_CLK)\n        if(RESET)\n            count_16d_flop_r    <=  `DLY    1'b0;\n        else if(enable_cc_c && reset_r)\n            count_16d_flop_r    <=  `DLY    1'b1;\n        else if(inner_count_done_r)    \n            count_16d_flop_r    <=  `DLY    middle_count_done_c;\n \n \n    always @(posedge USER_CLK)\n        if(RESET)\n            count_24d_srl_r     <=  `DLY   23'b00000000000000000000000; \n        else if(middle_count_done_c || !enable_cc_c)\n            count_24d_srl_r     <=  `DLY    {count_24d_flop_r, count_24d_srl_r[0:21]};\n            \n    assign  cc_idle_count_done_c    =   middle_count_done_c & count_24d_srl_r[22];\n    \n    always @(posedge USER_CLK)\n        if(RESET)\n            count_24d_flop_r    <=  `DLY    1'b0;\n        else if(enable_cc_c && reset_r)\n            count_24d_flop_r    <=  `DLY    1'b1;\n        else if(middle_count_done_c)\n            count_24d_flop_r    <=  `DLY    cc_idle_count_done_c;   \n            \n    \n    initial\n        prepare_count_r = 10'b0000000000;\n \n     always @(posedge USER_CLK)\n        if(RESET)\n         prepare_count_r <=  `DLY    10'b0000000000;\n        else\n         prepare_count_r <=  `DLY    {6'd0,cc_idle_count_done_c,prepare_count_r[6:8]};\n         \n \n    always @(posedge USER_CLK)\n         if(RESET)                                  WARN_CC    <=  `DLY    1'b0;\n         else if(cc_idle_count_done_c)              WARN_CC    <=  `DLY    1'b1;\n         else if(prepare_count_r[9])                WARN_CC    <=  `DLY    1'b0;\n\n    initial\n         cc_count_r = 6'b000000;\n \n    always @(posedge USER_CLK)\n        reset_r <=  `DLY    RESET;\n \n    assign start_cc_c   =   prepare_count_r[9] || (enable_cc_c && reset_r);\n \n \n     always @(posedge USER_CLK)\n       if(RESET)\n         cc_count_r      <=  `DLY   6'b000000; \n       else\n         cc_count_r      <=  `DLY    {(!enable_cc_c|prepare_count_r[9]),cc_count_r[0:4]};\n        \n     always @(posedge USER_CLK)\n         if(RESET)                       DO_CC <=  `DLY    1'b0;\n         else if(start_cc_c)             DO_CC <=  `DLY    1'b1;\n         else if(cc_count_r)             DO_CC <=  `DLY    1'b1;         \n         else                            DO_CC <=  `DLY    1'b0;         \n         \n\nendmodule\n",
        "module_name": "aur1_STANDARD_CC_MODULE",
        "module_hash": "043c81d67828320123a8848b270dfc09",
        "dataset_index": 1319
      },
      "mux2to1_41e9b0ab": {
        "rtl_code": "module mux2to1 (\n    A   ,\n    B   ,\n    SEL ,\n    OUT \n);\n\n    input A   ;\n    input B   ;\n    input SEL ;\n    output reg OUT ;\n\n    always @(SEL or A or B)\n    begin\n        if (SEL == 0)\n            OUT = A;\n        else\n            OUT = B;\n    end\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "41e9b0ab53c344fe1bdd87829d56ca4a",
        "dataset_index": 12525
      },
      "rw_manager_bitcheck_baed983f": {
        "rtl_code": "\n\nmodule rw_manager_bitcheck(\n\tck,\n\treset_n,\n\tclear,\n\tenable,\n\tread_data,\n\treference_data,\n\tmask,\n\terror_word\n);\n\n\tparameter DATA_WIDTH \t\t= \"\";\n\tparameter AFI_RATIO\t\t= \"\";\n\n\tlocalparam NUMBER_OF_WORDS = 2 * AFI_RATIO;\n\tlocalparam DATA_BUS_SIZE = DATA_WIDTH * NUMBER_OF_WORDS;\n\n\tinput ck;\n\tinput reset_n;\n\tinput clear;\n\tinput enable;\n\tinput [DATA_BUS_SIZE - 1 : 0] read_data;\n\tinput [DATA_BUS_SIZE - 1 : 0] reference_data;\n\tinput [NUMBER_OF_WORDS - 1 : 0] mask;\n\toutput [DATA_WIDTH - 1 : 0] error_word;\n\n\treg [DATA_BUS_SIZE - 1 : 0] read_data_r;\n\treg [DATA_WIDTH - 1 : 0] error_word;\n\treg enable_r;\n\twire [DATA_WIDTH - 1 : 0] error_compute;\n\n\talways @(posedge ck or negedge reset_n) begin\n\t\tif(~reset_n) begin\n\t\t\terror_word <= {DATA_WIDTH{1'b0}};\n\t\t\tread_data_r <= {DATA_BUS_SIZE{1'b0}};\n\t\t\tenable_r <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tif(clear) begin\n\t\t\t\terror_word <= {DATA_WIDTH{1'b0}};\n\t\t\tend\n\t\t\telse if(enable_r) begin\n\t\t\t\terror_word <= error_word | error_compute;\n\t\t\tend\n\t\t\tread_data_r <= read_data;\n\t\t\tenable_r <= enable;\n\t\tend\n\tend\n\n\tgenvar b;\n\tgenerate\n\t\tfor(b = 0; b < DATA_WIDTH; b = b + 1) \n\t\tbegin : bit_loop\n\t\t\tif(AFI_RATIO == 2) begin\n\t\t\t\tassign error_compute[b] = \n\t\t\t\t\t((read_data_r[b] ^ reference_data[b]) & ~mask[0]) |\n\t\t\t\t\t((read_data_r[b + DATA_WIDTH] ^ reference_data[b + DATA_WIDTH]) & ~mask[1]) |\n\t\t\t\t\t((read_data_r[b + 2 * DATA_WIDTH] ^ reference_data[b + 2 * DATA_WIDTH])  & ~mask[2])|\n\t\t\t\t\t((read_data_r[b + 3 * DATA_WIDTH] ^ reference_data[b + 3 * DATA_WIDTH]) & ~mask[3]);\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tassign error_compute[b] = \n\t\t\t\t\t((read_data_r[b] ^ reference_data[b]) & ~mask[0]) |\n\t\t\t\t\t((read_data_r[b + DATA_WIDTH] ^ reference_data[b + DATA_WIDTH]) & ~mask[1]);\n\t\t\tend\n\t\tend\n\tendgenerate\n\nendmodule\n",
        "module_name": "rw_manager_bitcheck",
        "module_hash": "baed983f689de20294a0983f9933d0e1",
        "dataset_index": 25327
      },
      "eight_bit_comparator_0c8f0bb2": {
        "rtl_code": "\nmodule eight_bit_comparator (\n    input [7:0] A,\n    input [7:0] B,\n    output equal,\n    output A_greater_than_B,\n    output A_less_than_B,\n    input clk\n);\n\nreg [7:0] A_reg, B_reg;\nreg [2:0] stage;\n\nassign equal = (A_reg == B_reg);\nassign A_greater_than_B = (A_reg > B_reg);\nassign A_less_than_B = (A_reg < B_reg);\n\nalways @(*) begin\n    case(stage)\n        0: begin\n            A_reg = A;\n            B_reg = B;\n        end\n        1: begin\n            A_reg = A_reg >> 1;\n            B_reg = B_reg >> 1;\n        end\n        2: begin\n            A_reg = A_reg >> 2;\n            B_reg = B_reg >> 2;\n        end\n        3: begin\n            A_reg = A_reg >> 4;\n            B_reg = B_reg >> 4;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (stage == 3) begin\n        stage <= 0;\n    end else begin\n        stage <= stage + 1;\n    end\nend\n\nendmodule\n",
        "module_name": "eight_bit_comparator",
        "module_hash": "0c8f0bb2c85ae36b3ff17774dc941959",
        "dataset_index": 16167
      },
      "Counter32_503cbf9f": {
        "rtl_code": "module Counter32 (\n  \n  input Reset_n_i,\n  \n  input Clk_i,\n  \n  input ResetSig_i,\n  \n  input Preset_i,\n  \n  input Enable_i,\n  \n  input Direction_i,\n  \n  input[15:0] PresetValH_i,\n  \n  input[15:0] PresetValL_i,\n  \n  output[15:0] DH_o,\n  \n  output[15:0] DL_o,\n  \n  output Overflow_o,\n  \n  output Zero_o\n);\n\n  reg [32:0] Value;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Value   <= 'd0;\n    end\n    else\n    begin\n      if (ResetSig_i)\n        Value <= 'd0;\n      else if (Preset_i)\n        Value <= {1'b0, PresetValH_i, PresetValL_i};\n      else if (Enable_i)\n      begin\n        if (!Direction_i)\n          Value <= {1'b0, Value[31:0]} + 1'b1;\n        else\n          Value <= {1'b0, Value[31:0]} - 1'b1;\n      end\n    end\n  end\n\n  assign DH_o = Value[31:16];\n  assign DL_o = Value[15:0];\n\n  assign Zero_o = (Value[31:0] == 'd0 ? 1'b1 : 1'b0);\n\n  assign Overflow_o = Value[32];\n\nendmodule\n",
        "module_name": "Counter32",
        "module_hash": "503cbf9f1ed41837c6f02acd9dcd2a74",
        "dataset_index": 22459
      },
      "mux_2to1_263035c1": {
        "rtl_code": "module mux_2to1 (\n    input A,\n    input B,\n    input sel,\n    output out\n);\n\n    assign out = (sel == 1'b0) ? A : B;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "263035c140ac74578ccb42026b8f0911",
        "dataset_index": 4697
      },
      "FSM_6998319a": {
        "rtl_code": "module FSM(clk, reset, rom_addr, rom_q, ram_a_addr, ram_b_addr, ram_b_w, pe, done);\n    input clk;\n    input reset;\n    output reg [8:0] rom_addr; \n    input [28:0] rom_q; \n    output reg [5:0] ram_a_addr;\n    output reg [5:0] ram_b_addr;\n    output ram_b_w;\n    output reg [10:0] pe;\n    output reg done;\n    \n    reg [5:0] state;\n    parameter START=0, READ_SRC1=1, READ_SRC2=2, CALC=4, WAIT=8, WRITE=16, DON=32;\n\t\n    wire [5:0] dest, src1, src2; wire [8:0] times; wire [1:0] op;\n    assign {dest, src1, op, times, src2} = rom_q;\n\n    reg [8:0] count;\n\t\n    always @ (posedge clk)\n       if (reset) \n          state<=START; \n       else \n          case (state)\n             START:\n                state<=READ_SRC1;\n             READ_SRC1:\n                state<=READ_SRC2;\n             READ_SRC2:\n                if (times==0) state<=DON; else state<=CALC;\n             CALC:\n                if (count==1) state<=WAIT;\n             WAIT:\n                state<=WRITE;\n             WRITE:\n                state<=READ_SRC1;\n          endcase\n\n    \n    parameter  LOOP1_START = 9'd21,\n               LOOP1_END   = 9'd116,\n               LOOP2_START = 9'd288,\n               LOOP2_END   = 9'd301;\n    reg [294:0] loop1, loop2;\n\t\n\talways @ (posedge clk)\n\t   if (reset) rom_addr<=0;\n\t   else if (state==WAIT)\n          begin\n             if(rom_addr == LOOP1_END && loop1[0])\n                rom_addr <= LOOP1_START;\n             else if(rom_addr == LOOP2_END && loop2[0])\n                rom_addr <= LOOP2_START;\n             else\n                rom_addr <= rom_addr + 1'd1; \n\t      end\n\t\n\talways @ (posedge clk)\n\t   if (reset) loop1 <= ~0;\n\t   else if(state==WAIT && rom_addr==LOOP1_END)\n          loop1 <= loop1 >> 1;\n\t\n\talways @ (posedge clk)\n\t   if (reset) loop2 <= ~0;\n\t   else if(state==WAIT && rom_addr==LOOP2_END)\n          loop2 <= loop2 >> 1;\n\n\talways @ (posedge clk)\n\t   if (reset)\n          count <= 0;\n\t   else if (state==READ_SRC1)\n          count <= times;\n\t   else if (state==CALC)\n          count <= count - 1'd1;\n\t\n\talways @ (posedge clk)\n\t   if (reset) done<=0;\n\t   else if (state==DON) done<=1;\n\t   else done<=0;\n\t \n    always @ (state, src1, src2)\n       case (state)\n       READ_SRC1: ram_a_addr=src1;\n       READ_SRC2: ram_a_addr=src2;\n       default: ram_a_addr=0;\n       endcase\n    \n    parameter CMD_ADD=6'd4, CMD_SUB=6'd8, CMD_CUBIC=6'd16,\n              ADD=2'd0, SUB=2'd1, CUBIC=2'd2, MULT=2'd3;\n\n    always @ (posedge clk)\n       case (state)\n       READ_SRC1:\n          case (op)\n          ADD:   pe<=11'b11001000000;\n          SUB:   pe<=11'b11001000000;\n          CUBIC: pe<=11'b11111000000;\n          MULT:  pe<=11'b11110000000;\n          default: pe<=0;\n          endcase\n       READ_SRC2:\n          case (op)\n          ADD:   pe<=11'b00110000000;\n          SUB:   pe<=11'b00110000000;\n          CUBIC: pe<=0;\n          MULT:  pe<=11'b00001000000;\n          default: pe<=0;\n          endcase\n       CALC:\n          case (op)\n          ADD:   pe<=11'b00000010001;\n          SUB:   pe<=11'b00000010001;\n          CUBIC: pe<=11'b01010000001;\n          MULT:  pe<=11'b00000111111;\n          default: pe<=0;\n          endcase\n       default: \n          pe<=0;\n       endcase\n\n    always @ (state, op, src2, dest)\n       case (state)\n       READ_SRC1: \n          case (op)\n          ADD: ram_b_addr=CMD_ADD;\n          SUB: ram_b_addr=CMD_SUB;\n          CUBIC: ram_b_addr=CMD_CUBIC;\n          default: ram_b_addr=0;\n          endcase\n       READ_SRC2: ram_b_addr=src2;\n       WRITE: ram_b_addr=dest;\n       default: ram_b_addr=0;\n       endcase\n\n    assign ram_b_w = (state==WRITE) ? 1'b1 : 1'b0;\nendmodule",
        "module_name": "FSM",
        "module_hash": "6998319a346e22d8e98eb8685c3fec29",
        "dataset_index": 16845
      },
      "four_to_one_a3859678": {
        "rtl_code": "module four_to_one (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    \n    assign Y = (A1 & A2) ? B1 : ((A1 ^ A2) ? B2 : (B1 & B2));\n\nendmodule\n",
        "module_name": "four_to_one",
        "module_hash": "a38596786c7e624e592b3c069a582839",
        "dataset_index": 8154
      },
      "mem_encrypt_decrypt_05b90ee6": {
        "rtl_code": "module mem_encrypt_decrypt (\n  input clk,\n  input rst,\n  input start,\n  input [7:0] key,\n  input [7:0] address,\n  input [7:0] data_in,\n  output reg [7:0] data_out\n);\n\nreg [7:0] mem [255:0];\nreg [7:0] temp_data;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    data_out <= 0;\n    temp_data <= 0;\n  end else begin\n    if (start) begin\n      if (address < 256) begin\n        if (temp_data == 0) begin\n          if (key[0] == 1) begin\n            mem[address] <= ~data_in;\n          end else begin\n            mem[address] <= data_in ^ key;\n          end\n          temp_data <= 1;\n        end else begin\n          if (key[0] == 1) begin\n            data_out <= ~mem[address];\n          end else begin\n            data_out <= mem[address] ^ key;\n          end\n          temp_data <= 0;\n        end\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "mem_encrypt_decrypt",
        "module_hash": "05b90ee664f9faee26628b8eddf01bd6",
        "dataset_index": 15053
      },
      "delay_reset_controller_3e9635cf": {
        "rtl_code": "\nmodule delay_reset_controller (\n    input CLK_IN,\n    input reset,\n    input enb_1_2000_0,\n    input Reset_1,\n    input signed [31:0] In,\n    output reg signed [31:0] Out\n);\n\n    reg signed [31:0] In_Delay_out1;  // sfix32_En27\n\n    always @(posedge CLK_IN) begin\n        if (reset || Reset_1) begin\n            Out <= 0;\n        end else if (enb_1_2000_0) begin\n            Out <= In;\n        end\n    end\n\n    always @(posedge CLK_IN) begin\n        if (reset || Reset_1) begin\n            In_Delay_out1 <= 0;\n        end else begin\n            In_Delay_out1 <= Out;\n        end\n    end\n\nendmodule",
        "module_name": "delay_reset_controller",
        "module_hash": "3e9635cfc078ab76c419bf07faae4de2",
        "dataset_index": 3277
      },
      "top__642500cb": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] a, b, // 8-bit inputs for the adder\n    input select, // Select input to choose between adder and counter\n    output [7:0] q // 8-bit output of the functional module\n);\n\n    wire [7:0] adder_out;\n    wire [3:0] counter_out;\n    wire [7:0] sum;\n\n    adder adder_inst (\n        .a(a),\n        .b(b),\n        .sum(adder_out)\n    );\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .q(counter_out)\n    );\n\n    functional functional_inst (\n        .adder_out(adder_out),\n        .counter_out(counter_out),\n        .sum(sum)\n    );\n\n    control control_inst (\n        .select(select),\n        .adder_out(adder_out),\n        .counter_out(counter_out),\n        .sum(sum),\n        .q(q)\n    );\n\nendmodule\n\nmodule adder (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n\n    always @(*) begin\n        sum = a + b;\n    end\n\nendmodule\n\nmodule counter (\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    parameter PERIOD = 16;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0;\n        end else if (q == PERIOD - 1) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\n\nmodule functional (\n    input [7:0] adder_out,\n    input [3:0] counter_out,\n    output reg [7:0] sum\n);\n\n    always @(*) begin\n        sum = adder_out + (counter_out << 8);\n    end\n\nendmodule\n\nmodule control (\n    input select,\n    input [7:0] adder_out,\n    input [3:0] counter_out,\n    input [7:0] sum,\n    output reg [7:0] q\n);\n\n    always @(*) begin\n        if (select) begin\n            q = sum + (counter_out << 8);\n        end else begin\n            q = sum + adder_out;\n        end\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "642500cbe8d1d62cca9b45390ca788e4",
        "dataset_index": 5414
      },
      "barrel_shifter_2f17a027": {
        "rtl_code": "module barrel_shifter (\n    input [7:0] DATA,\n    input [2:0] SHIFT_AMOUNT,\n    input SHIFT_DIRECTION,\n    output [7:0] SHIFTED_DATA\n);\n\nreg [7:0] pipeline_reg [2:0];\n\n// Pipeline stage 1\nalways @(*) begin\n    if (SHIFT_DIRECTION == 1'b0) // Left shift\n        pipeline_reg[0] = DATA << SHIFT_AMOUNT;\n    else // Right shift\n        pipeline_reg[0] = DATA >> SHIFT_AMOUNT;\nend\n\n// Pipeline stage 2\nalways @(*) begin\n    pipeline_reg[1] = pipeline_reg[0];\nend\n\n// Pipeline stage 3\nalways @(*) begin\n    pipeline_reg[2] = pipeline_reg[1];\nend\n\nassign SHIFTED_DATA = pipeline_reg[2];\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "2f17a027511082c907a5ab453765c5dc",
        "dataset_index": 11248
      },
      "sd_card_0cb09c7e": {
        "rtl_code": "module sd_card (\n\toutput [31:0] io_lba,\n\toutput reg    io_rd,\n\toutput reg    io_wr,\n\tinput\t\t\t  io_ack,\n\toutput\t\t  io_conf,\n\toutput\t\t  io_sdhc,\n\t\n\tinput\t[7:0]\t  io_din,\n\tinput \t\t  io_din_strobe,\n\n\toutput [7:0]  io_dout,\n\tinput \t\t  io_dout_strobe,\n\n\tinput         allow_sdhc,\n\t\n   input         sd_cs,\n   input         sd_sck,\n   input         sd_sdi,\n   output reg    sd_sdo\n); \n\nreg req_io_rd = 1'b0; always @(posedge req_io_rd or posedge io_ack) begin\n\tif(io_ack) io_rd <= 1'b0;\n\telse \t\t  io_rd <= 1'b1;\nend\n\nreg req_io_wr = 1'b0; always @(posedge req_io_wr or posedge io_ack) begin\n\tif(io_ack) io_wr <= 1'b0;\n\telse \t\t  io_wr <= 1'b1;\nend\n\nwire [31:0] OCR = { 1'b0, io_sdhc, 30'h0 };  wire [7:0] READ_DATA_TOKEN = 8'hfe;\n\nlocalparam NCR=4;\n\nlocalparam RD_STATE_IDLE       = 2'd0;\nlocalparam RD_STATE_WAIT_IO    = 2'd1;\nlocalparam RD_STATE_SEND_TOKEN = 2'd2;\nlocalparam RD_STATE_SEND_DATA  = 2'd3;\nreg [1:0] read_state = RD_STATE_IDLE;  \n\nlocalparam WR_STATE_IDLE       = 3'd0;\nlocalparam WR_STATE_EXP_DTOKEN = 3'd1;\nlocalparam WR_STATE_RECV_DATA  = 3'd2;\nlocalparam WR_STATE_RECV_CRC0  = 3'd3;\nlocalparam WR_STATE_RECV_CRC1  = 3'd4;\nlocalparam WR_STATE_SEND_DRESP = 3'd5;\nlocalparam WR_STATE_BUSY       = 3'd6;\nreg [2:0] write_state = WR_STATE_IDLE;  \n\nreg card_is_reset = 1'b0;    reg [6:0] sbuf; \nreg cmd55;\nreg new_cmd_rcvd;\nreg [7:0] cmd = 8'h00;\nreg [2:0] bit_cnt;           reg [3:0] byte_cnt= 4'd15;   reg [31:0] lba;\nassign io_lba = io_sdhc?lba:{9'd0, lba[31:9]};\n\nreg [7:0] reply;\nreg [7:0] reply0, reply1, reply2, reply3;\nreg [3:0] reply_len;\n\nwire rd_wait_io = (read_state != RD_STATE_IDLE);\nreg rd_io_ack_i = 1'b0;\nalways @(negedge io_ack or negedge rd_wait_io) begin\n\tif(!rd_wait_io) rd_io_ack_i <= 1'b0;\n\telse            rd_io_ack_i <= 1'b1;\nend\n \nwire wr_wait_io = (write_state == WR_STATE_BUSY);\nreg wr_io_ack_i = 1'b0;\nalways @(negedge io_ack or negedge wr_wait_io) begin\n\tif(!wr_wait_io) wr_io_ack_i <= 1'b0;\n\telse            wr_io_ack_i <= 1'b1;\nend\n\nreg wr_io_ack;\nreg rd_io_ack;\nalways @(posedge sd_sck) begin\t\n\trd_io_ack <= rd_io_ack_i;\n\twr_io_ack <= wr_io_ack_i;\nend\n\nreg [7:0] buffer [511:0];\n\nreg [8:0] buffer_rptr;\nreg buffer_read_strobe;\nwire buffer_dout_strobe = buffer_read_strobe || io_dout_strobe;\nreg [7:0] buffer_dout;\nassign io_dout = buffer_dout;\n\nreg buffer_read_sector_done;\nreg buffer_read_ciscid_done;\n\nalways @(posedge buffer_dout_strobe or posedge new_cmd_rcvd) begin\n\tif(new_cmd_rcvd == 1) begin\n\t\tbuffer_rptr <= 9'd0;\n\t\tbuffer_read_sector_done <= 1'b0;\n\t\tbuffer_read_ciscid_done <= 1'b0;\n\tend else begin\n\t\tbuffer_dout <= buffer[buffer_rptr];\n\t\tbuffer_rptr <= buffer_rptr + 9'd1;\n\t\tif(buffer_rptr == 511) buffer_read_sector_done <= 1'b1;\n\t\tif(buffer_rptr == 15)  buffer_read_ciscid_done <= 1'b1;\n\tend\nend\n\nreg [8:0] buffer_wptr;\nreg buffer_write_strobe;\nwire buffer_din_strobe = io_din_strobe || buffer_write_strobe;\nwire [7:0] buffer_din = (cmd == 8'h51)?io_din:{sbuf, sd_sdi};\n\nalways @(posedge buffer_din_strobe or posedge new_cmd_rcvd) begin\n\tif(new_cmd_rcvd == 1)\n\t\tbuffer_wptr <= 9'd0;\n\telse begin\n\t\tbuffer[buffer_wptr] <= buffer_din;\t\n\t\tbuffer_wptr <= buffer_wptr + 9'd1;\n\tend\nend\n\nwire [7:0] WRITE_DATA_RESPONSE = 8'h05;\n\nassign io_conf = (csd_wptr == 0);  reg [7:0] cid [15:0];\nreg [7:0] csd [15:0];\nreg [7:0] conf;\n\nreg [7:0] cid_byte;\nreg [7:0] csd_byte;\nreg [5:0] csd_wptr = 6'd0;\n\nwire io_has_sdhc = conf[0];\nassign io_sdhc = allow_sdhc && io_has_sdhc;\n\nalways @(posedge io_din_strobe) begin\n\tif(!io_ack && (csd_wptr <= 32)) begin\n\t\n\t\tif(csd_wptr < 16)                       cid[csd_wptr[3:0]] <= io_din;\t\n\t\tif((csd_wptr >= 16) && (csd_wptr < 32)) csd[csd_wptr[3:0]] <= io_din;\t\n\t\tif(csd_wptr == 32)                      conf <= io_din;\t\n\t\t\t\n\t\tcsd_wptr\t<= csd_wptr + 6'd1;\n\tend\nend\n \nalways @(posedge buffer_dout_strobe) begin\n\tcid_byte <= cid[buffer_rptr[3:0]];\n\tcsd_byte <= csd[buffer_rptr[3:0]];\nend\n \t\nalways@(negedge sd_sck) begin\n\tif(sd_cs == 0) begin\n\t\tbuffer_read_strobe <= 1'b0;\n\t\tsd_sdo <= 1'b1;\t\t\t\treq_io_rd <= 1'b0;\n\t\t\n\t\tif(byte_cnt == 5+NCR) begin\n\t\t\tsd_sdo <= reply[~bit_cnt];\n\n\t\t\tif(bit_cnt == 7) begin\n\t\t\t\tif((cmd == 8'h49)||(cmd == 8'h4a))\n\t\t\t\t\tread_state <= RD_STATE_SEND_TOKEN;      if(cmd == 8'h51) begin\n\t\t\t\t\tread_state <= RD_STATE_WAIT_IO;         req_io_rd <= 1'b1;                      end\n\t\t\tend\n\t\tend\n\t\telse if((reply_len > 0) && (byte_cnt == 5+NCR+1))\n\t\t\tsd_sdo <= reply0[~bit_cnt];\n\t\telse if((reply_len > 1) && (byte_cnt == 5+NCR+2))\n\t\t\tsd_sdo <= reply1[~bit_cnt];\n\t\telse if((reply_len > 2) && (byte_cnt == 5+NCR+3))\n\t\t\tsd_sdo <= reply2[~bit_cnt];\n\t\telse if((reply_len > 3) && (byte_cnt == 5+NCR+4))\n\t\t\tsd_sdo <= reply3[~bit_cnt];\n\t\telse\n\t\t\tsd_sdo <= 1'b1;\n\n\t\tcase(read_state)\n\t\t\tRD_STATE_IDLE: ;\n\t\t\t\tRD_STATE_WAIT_IO: begin\n\t\t\t\tif(rd_io_ack && (bit_cnt == 7)) \n\t\t\t\t\tread_state <= RD_STATE_SEND_TOKEN;\n\t\t\tend\n\n\t\t\tRD_STATE_SEND_TOKEN: begin\n\t\t\t\tsd_sdo <= READ_DATA_TOKEN[~bit_cnt];\n\t\n\t\t\t\tif(bit_cnt == 7) begin\n\t\t\t\t\tread_state <= RD_STATE_SEND_DATA;   buffer_read_strobe <= 1'b1;         end\n\t\t\tend\n\t\t\t\t\t\n\t\t\tRD_STATE_SEND_DATA: begin\n\t\t\t\tif(cmd == 8'h51) \t\t\t\t\t\t\tsd_sdo <= buffer_dout[~bit_cnt];\n\t\t\t\telse if(cmd == 8'h49) \t\t\t\t\tsd_sdo <= csd_byte[~bit_cnt];\n\t\t\t\telse if(cmd == 8'h4a) \t\t\t\t\tsd_sdo <= cid_byte[~bit_cnt];\n\t\t\t\telse\n\t\t\t\t\tsd_sdo <= 1'b1;\n\n\t\t\t\tif(bit_cnt == 7) begin\n\t\t\t\t\tif((cmd == 8'h51) && buffer_read_sector_done) read_state <= RD_STATE_IDLE;   else if(((cmd == 8'h49)||(cmd == 8'h4a)) && buffer_read_ciscid_done) read_state <= RD_STATE_IDLE;   else\n\t\t\t\t\t\tbuffer_read_strobe <= 1'b1;    end\n\t\t\tend\n\t\tendcase\n\t\t\t\t\t\n\t\tif(write_state == WR_STATE_SEND_DRESP) \n\t\t\tsd_sdo <= WRITE_DATA_RESPONSE[~bit_cnt];\n\t\t\t\n\t\tif(write_state == WR_STATE_BUSY) \n\t\t\tsd_sdo <= 1'b0;\n   end\nend\n\nreg illegal_write_state ;\n\nalways @(posedge sd_sck or posedge sd_cs) begin\n\tif(sd_cs == 1) begin\n\t\tbit_cnt <= 3'd0;\n\tend else begin \n\t\tillegal_write_state <= 1'b0;\n\t\tnew_cmd_rcvd <= 1'b0;\n\t\tbuffer_write_strobe <= 1'b0;\n\t\treq_io_wr <= 1'b0;\n\t\tbit_cnt <= bit_cnt + 3'd1;\n\t\t\n\t\tif(bit_cnt != 7)\n\t\t\tsbuf[6:0] <= { sbuf[5:0], sd_sdi };\n\t\telse begin\n\t\t\tif(byte_cnt != 15)\n\t\t\t\tbyte_cnt <= byte_cnt + 4'd1;\t\t\t\n\n\t\t\tif((byte_cnt > 5) && (write_state == WR_STATE_IDLE) && \n\t\t\t\t(read_state == RD_STATE_IDLE)  && sbuf[6:5] == 2'b01) begin\n\t\t\t\tbyte_cnt <= 4'd0;\t\t\t\n\t\t\t\tcmd <= { sbuf, sd_sdi};\n\t\t\t\tnew_cmd_rcvd <= 1'b1;\n\n\t\t\t   cmd55 <= (cmd == 8'h77);\n\t\t\tend\n\n\t\t\tif(byte_cnt == 0) lba[31:24] <= { sbuf, sd_sdi};\n\t\t\tif(byte_cnt == 1) lba[23:16] <= { sbuf, sd_sdi};\n\t\t\tif(byte_cnt == 2) lba[15:8]  <= { sbuf, sd_sdi};\n\t\t\tif(byte_cnt == 3) lba[7:0]   <= { sbuf, sd_sdi};\t\t\t\n\n\t\t\tif(byte_cnt == 4) begin\t\t\n\t\t\n\t\t\t\treply <= 8'h04;     reply_len <= 4'd0;  if(cmd == 8'h40) begin\n\t\t\t\t\tcard_is_reset <= 1'b1;\n\t\t\t\t\treply <= 8'h01;    end\n\n\t\t\t\telse if(card_is_reset) begin\n\t\t\t\t\tif(cmd == 8'h41)\n\t\t\t\t\t\treply <= 8'h00;    else if(cmd == 8'h48) begin\n\t\t\t\t\t\treply <= 8'h01;    reply0 <= 8'h00;\n\t\t\t\t\t\treply1 <= 8'h00;\n\t\t\t\t\t\treply2 <= 8'h01;\n\t\t\t\t\t\treply3 <= 8'hAA;\n\t\t\t\t\t\treply_len <= 4'd4;\n\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\t\telse if(cmd == 8'h49)\n\t\t\t\t\t\treply <= 8'h00;    else if(cmd == 8'h4a)\n\t\t\t\t\t\treply <= 8'h00;    else if(cmd == 8'h50) begin\n\t\t\t\t\t\tif(lba == 32'd512)\n\t\t\t\t\t\t\treply <= 8'h00;    else\n\t\t\t\t\t\t\treply <= 8'h40;    end\n\n\t\t\t\t\telse if(cmd == 8'h51)\n\t\t\t\t\t\treply <= 8'h00;    else if(cmd == 8'h58) begin\n\t\t\t\t\t\treply <= 8'h00;    write_state <= WR_STATE_EXP_DTOKEN;  end\n\n\t\t\t\t\telse if(cmd55 && (cmd == 8'h69))\n\t\t\t\t\t\treply <= 8'h00;    else if(cmd == 8'h77)\n\t\t\t\t\t\treply <= 8'h01;    else if(cmd == 8'h7a) begin\n\t\t\t\t\t\treply <= 8'h00;    reply0 <= OCR[31:24];   reply1 <= OCR[23:16];\n\t\t\t\t\t\treply2 <= OCR[15:8];\n\t\t\t\t\t\treply3 <= OCR[7:0];\n\t\t\t\t\t\treply_len <= 4'd4;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tcase(write_state) \n\t\t\t\tWR_STATE_IDLE: ;\n\t\t\t\t\n\t\t\t\tWR_STATE_EXP_DTOKEN:\n\t\t\t\t\tif({ sbuf, sd_sdi} == 8'hfe )\n\t\t\t\t\t\twrite_state <= WR_STATE_RECV_DATA;\n\n\t\t\t\tWR_STATE_RECV_DATA: begin\n\t\t\t\t\tbuffer_write_strobe <= 1'b1;\n\n\t\t\t\t\tif(buffer_wptr == 511)\n\t\t\t\t\t\twrite_state <= WR_STATE_RECV_CRC0;\n\t\t\t\tend\n\t\n\t\t\t\tWR_STATE_RECV_CRC0:\n\t\t\t\t\twrite_state <= WR_STATE_RECV_CRC1;\n\n\t\t\t\tWR_STATE_RECV_CRC1:\n\t\t\t\t\twrite_state <= WR_STATE_SEND_DRESP;\n\t\n\t\t\t\tWR_STATE_SEND_DRESP: begin\n\t\t\t\t\twrite_state <= WR_STATE_BUSY;\n\t\t\t\t\treq_io_wr <= 1'b1;               end\n\t\t\t\t\n\t\t\t\tWR_STATE_BUSY:\n\t\t\t\t\tif(wr_io_ack)\n\t\t\t\t\t\twrite_state <= WR_STATE_IDLE;\n\t\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tillegal_write_state <= 1'b1;\n\t\t\tendcase\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "sd_card",
        "module_hash": "0cb09c7e283f7bfa4033e9f4a2d2c7be",
        "dataset_index": 21957
      },
      "adder4bit_b08b0d31": {
        "rtl_code": "\nmodule adder4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    output [3:0] S,\n    output cout\n);\n\nwire c0, c1, c2;\n\n// Instantiate the full adder modules\nfull_adder fa0(.a(A[0]), .b(B[0]), .cin(cin), .sum(S[0]), .cout(c0));\nfull_adder fa1(.a(A[1]), .b(B[1]), .cin(c0), .sum(S[1]), .cout(c1));\nfull_adder fa2(.a(A[2]), .b(B[2]), .cin(c1), .sum(S[2]), .cout(c2));\nfull_adder fa3(.a(A[3]), .b(B[3]), .cin(c2), .sum(S[3]), .cout(cout));\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n// Calculate the sum and carry-out values\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n",
        "module_name": "adder4bit",
        "module_hash": "b08b0d314d51da6a2035498a8554a369",
        "dataset_index": 20583
      },
      "chatgpt_generate_RAM_8f0cf01f": {
        "rtl_code": "module chatgpt_generate_RAM (\n    input read_clk,\n    input write_clk,\n    input rst_n,\n    input write_en,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    output reg [3:0] read_data\n);\n\nreg [3:0] ram [0:7];\n\n// Initialize RAM with all zeros\ninteger i;\ninitial begin\n    for (i = 0; i < 8; i = i + 1) begin\n        ram[i] = 4'b0000;\n    end\nend\n\n// Synchronous read design\nalways @(posedge read_clk) begin\n    if (read_en) begin\n        read_data <= ram[read_addr];\n    end\nend\n\n// Asynchronous write design\nreg [7:0] write_addr_sync;\nalways @(posedge write_clk) begin\n    if (rst_n == 0) begin\n        write_addr_sync <= 8'b0;\n    end else if (write_en) begin\n        write_addr_sync <= write_addr;\n        ram[write_addr_sync] <= write_data;\n    end\nend\n\nendmodule",
        "module_name": "chatgpt_generate_RAM",
        "module_hash": "8f0cf01f2f1615d06a3368a9fba34e4b",
        "dataset_index": 10757
      },
      "bitwise_or_b37069e7": {
        "rtl_code": "module bitwise_or(clk, reset, input_bus_1, input_bus_2, output_bus);\n  input clk;\n  input reset;\n  input [31:0] input_bus_1, input_bus_2;\n  output reg [31:0] output_bus;\n  \n  always @(posedge clk) begin\n    if (reset == 1'b1) begin\n      output_bus <= 32'b0;\n    end else begin\n      output_bus <= input_bus_1 | input_bus_2;\n    end\n  end\nendmodule",
        "module_name": "bitwise_or",
        "module_hash": "b37069e72943ffa35aa9751c5908ed3e",
        "dataset_index": 7764
      },
      "mux_4to2_61fa5d2b": {
        "rtl_code": "module mux_4to2 (\n    output X,\n    input A0,\n    input A1,\n    input A2,\n    input A3,\n    input S0,\n    input S1\n);\n\n    assign X = (S1 & S0 & A3) | (~S1 & S0 & A2) | (S1 & ~S0 & A1) | (~S1 & ~S0 & A0);\n\nendmodule",
        "module_name": "mux_4to2",
        "module_hash": "61fa5d2b5c936d47042de41533a104ce",
        "dataset_index": 3399
      },
      "binary_converter_e4320a99": {
        "rtl_code": "module binary_converter(input signal, output [9:0] binary_code);\n    wire inv_signal;\n    wire [9:0] xor_output;\n    wire [9:0] adder_output;\n\n    // Invert the input signal\n    assign inv_signal = ~signal;\n\n    // Generate the binary code using XOR gates\n    assign xor_output[0] = inv_signal;\n    assign xor_output[1] = inv_signal ^ 1'b1;\n    assign xor_output[2] = inv_signal ^ 2'b10;\n    assign xor_output[3] = inv_signal ^ 3'b100;\n    assign xor_output[4] = inv_signal ^ 4'b1000;\n    assign xor_output[5] = inv_signal ^ 5'b10000;\n    assign xor_output[6] = inv_signal ^ 6'b100000;\n    assign xor_output[7] = inv_signal ^ 7'b1000000;\n    assign xor_output[8] = inv_signal ^ 8'b10000000;\n    assign xor_output[9] = inv_signal ^ 9'b100000000;\n\n    // Add 1 to the binary code to get two's complement notation\n    assign adder_output = xor_output + 1'b1;\n\n    // Output the binary code\n    assign binary_code = adder_output;\nendmodule",
        "module_name": "binary_converter",
        "module_hash": "e4320a99dd3899f1b60e2aad7c6f2681",
        "dataset_index": 19173
      },
      "shift_add_3a37e7b1": {
        "rtl_code": "module shift_add (\n  input clk,\n  input reset,\n  input shift_dir,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\n  reg [7:0] shift_reg = 8'b00000000;\n\n  wire [3:0] shift_reg_out;\n  wire [3:0] adder_out;\n\n  // Instantiate the shift register\n  shift_register shift_reg_inst (\n    .clk(clk),\n    .reset(reset),\n    .shift_dir(shift_dir),\n    .data_in(data_in),\n    .data_out(shift_reg_out)\n  );\n\n  // Instantiate the adder\n  adder adder_inst (\n    .a(shift_reg_out),\n    .b(data_in),\n    .sum(adder_out)\n  );\n\n  // Assign the output of the adder to the shift register input\n  always @ (posedge clk) begin\n    if (reset) begin\n      shift_reg <= 8'b00000000;\n    end else begin\n      shift_reg <= {shift_dir, adder_out};\n    end\n  end\n\n  // Assign the output of the shift register to the module output\n  assign data_out = shift_reg_out;\n\nendmodule\n\n// Shift register module\nmodule shift_register (\n  input clk,\n  input reset,\n  input shift_dir,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\n  reg [7:0] shift_reg = 8'b00000000;\n\n  always @ (posedge clk) begin\n    if (reset) begin\n      shift_reg <= 8'b00000000;\n    end else begin\n      if (shift_dir) begin\n        shift_reg <= {shift_reg[6:0], data_in};\n      end else begin\n        shift_reg <= {data_in, shift_reg[7:1]};\n      end\n    end\n  end\n\n  assign data_out = shift_reg[3:0];\n\nendmodule\n\n// Adder module\nmodule adder (\n  input [3:0] a,\n  input [3:0] b,\n  output [3:0] sum\n);\n\n  assign sum = a + b;\n\nendmodule",
        "module_name": "shift_add",
        "module_hash": "3a37e7b11139625a4e36e43ededfdfb1",
        "dataset_index": 10525
      },
      "top__9a2826b8": {
        "rtl_code": "module top_module ( \n    input clk, \n    input [3:0] A,\n    input [3:0] B,\n    input select,\n    output [3:0] sum );\n\n    wire [3:0] sum1, sum2;\n    wire enable1, enable2;\n\n    // Adder 1\n    adder_4bit adder1(.A(A), .B(B), .sum(sum1));\n\n    // Adder 2\n    adder_4bit adder2(.A(A), .B(B), .sum(sum2));\n\n    // Control Logic\n    assign enable1 = (select == 0);\n    assign enable2 = (select == 1);\n\n    // Output\n    assign sum = enable1 ? sum1 : sum2;\n\nendmodule\n\n// 4-bit Adder module\nmodule adder_4bit ( \n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum );\n\n    assign sum = A + B;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "9a2826b8668d9a865187a769596552d2",
        "dataset_index": 4951
      },
      "FP16BAddSubS4Of5_ca327387": {
        "rtl_code": "module FP16BAddSubS4Of5(\n input \t       clk,\n input \t       rst,\n input [14:0]  arg_0,\n input \t       arg_1,\n input \t       arg_2,\n input [7:0]   arg_3,\n input \t       arg_4,\n input \t       arg_5,\n input \t       arg_6,\n output [15:0] ret_0);\n\n   // Assign input signals to internal wires\n   wire [15:0] r;\n   wire        xs;\n   wire        ys;\n   wire [7:0]  e;\n   wire [7:0]  e_final;\n   wire [8:0]  e_l0adjust;\n   wire        underflow;\n   wire [7:0]  e_adjust;\n   wire        neg;\n   wire        xn;\n   wire        yn;\n   wire [7:0] rr;\n   wire [6:0] r_final;\n   wire [15:0] r8;\n   wire [15:0] r4;\n   wire [15:0] r2;\n   wire [15:0] r1;\n   wire [3:0]  l0count;\n   wire        s;\n\n   assign r = arg_0;\n   assign xs = arg_1;\n   assign ys = arg_2;\n   assign e = arg_3;\n   assign neg = arg_4;\n   assign xn = arg_5;\n   assign yn = arg_6;\n\n   // Compute s\n   assign s = (xn == yn) ? xs : (yn ? (neg ^ xs): (neg ^ ys));\n\n   // Compute r8\n   assign r8 = (r[14:7] == 0) ? {r[6:0], 8'b0} : r;\n\n   // Compute r4\n   assign r4 = (r8[14:11] == 0) ? {r8[10:0], 4'b0} : r8;\n\n   // Compute r2\n   assign r2 = (r4[14:13] == 0) ? {r4[12:0], 2'b0} : r4;\n\n   // Compute r1\n   assign r1 = (r2[14:14] == 0) ? {r2[13:0], 1'b0} : r2;\n\n   // Compute l0count\n   assign l0count = {r[14:7] == 0, r8[14:11] == 0, r4[14:13] == 0, r2[14:14] == 0};\n\n   // Compute rr\n   assign rr = (xn == yn) ? r[14:7] : r1;\n\n   // Compute e_l0adjust\n   assign e_l0adjust = e - l0count;\n\n   // Compute underflow\n   assign underflow = e_l0adjust[8:8];\n\n   // Compute e_adjust\n   assign e_adjust = underflow ? 0 : e_l0adjust[7:0];\n\n   // Compute e_final\n   assign e_final = (xn == yn) ? e : e_adjust[7:0];\n\n   // Compute r_final\n   assign r_final = underflow ? 0 : rr[6:0];\n\n   // Assign output signal\n   assign ret_0 = {s, e_final, r_final};\n\nendmodule",
        "module_name": "FP16BAddSubS4Of5",
        "module_hash": "ca327387b2ca58639d241bd58d5480e7",
        "dataset_index": 10999
      },
      "modulo_operator_519d7bc1": {
        "rtl_code": "\nmodule modulo_operator (\n  input [31:0] div,\n  input [31:0] divisor,\n  output reg [31:0] rem\n);\n\nalways @(*) begin\n  if (divisor == 0) begin\n    rem = 32'h0000_0000;\n  end else begin\n    rem = div % divisor;\n  end\nend\n\nendmodule",
        "module_name": "modulo_operator",
        "module_hash": "519d7bc15ce67aaf4db8d30963323903",
        "dataset_index": 3932
      },
      "axi_traffic_gen_v2_0_7_axis_fifo_d0b7d94b": {
        "rtl_code": "\n\nmodule axi_traffic_gen_v2_0_7_axis_fifo\n  #(\nparameter WIDTH        = 33,\nparameter HEADREG      = 1 ,\nparameter ZERO_INVALID = 1 ,\nparameter FULL_LEVEL   = 14,\nparameter DEPTH        = 16,\nparameter DEPTHBITS    = 4\n  ) (\ninput Clk                        ,\ninput Rst_n                      ,\n\ninput [WIDTH-1:0] in_data        ,\ninput [WIDTH-1:0] in_invalid_data,\ninput  in_push                   ,\ninput  in_ready                  ,\ninput  in_block_notfull          ,\ninput  in_block_outvalid         ,\noutput  out_valid                ,\noutput  out_notfull              ,\noutput  out_overflow             ,\noutput [DEPTHBITS-1:0] out_depth ,\noutput [WIDTH-1:0] out_data\n);\n\n reg [WIDTH-1:0] data_ff[DEPTH-1:0]               ;\nreg [WIDTH-1:0] headreg_ff                       ;\nreg [DEPTHBITS-1:0] in_ptr_ff, out_ptr_ff        ;\nreg [DEPTHBITS:0] depth_ff                       ;\nreg  valid_ff, full_ff, notfull_ff, valid_filt_ff;\n\nwire do_pop = in_ready && valid_filt_ff;\nwire [DEPTHBITS-1:0] in_ptr = (in_push) ? in_ptr_ff[DEPTHBITS-1:0] + 'h1 :\n            in_ptr_ff[DEPTHBITS-1:0];\nwire [DEPTHBITS:0] depth =\n    (in_push && ~do_pop) ? depth_ff[DEPTHBITS:0] + 'h1 :\n    (~in_push && do_pop) ? depth_ff[DEPTHBITS:0] - 'h1 :\n              depth_ff[DEPTHBITS:0];\n\nwire  depth_was1 = (depth_ff[DEPTHBITS:0] == 'h1);\nwire  valid      = (depth[DEPTHBITS:0] != 'h0);\nwire  full       = (depth[DEPTHBITS:0] >= FULL_LEVEL) || in_block_notfull;\nwire  notfull    = ~full;\n\nwire [WIDTH-1:0] raw_data = data_ff[out_ptr_ff[DEPTHBITS-1:0]];\nwire [DEPTHBITS-1:0] out_ptr = (do_pop) ? out_ptr_ff[DEPTHBITS-1:0] + 'h1 :\n            out_ptr_ff[DEPTHBITS-1:0];\nwire [WIDTH-1:0] head_raw_data = (depth_was1) ? in_data[WIDTH-1:0] :\n          raw_data[WIDTH-1:0];\nwire [WIDTH-1:0] headreg = (!valid_ff && in_push) ? in_data[WIDTH-1:0] :\n    (do_pop) ? head_raw_data[WIDTH-1:0] :\n              headreg_ff[WIDTH-1:0];\nwire  valid_filt = valid &&\n      ((valid_filt_ff && ~do_pop) || ~in_block_outvalid);\n\nalways @(posedge Clk) begin\n  in_ptr_ff[DEPTHBITS-1:0]  <= (Rst_n) ? in_ptr[DEPTHBITS-1:0] : 'h0;\n  out_ptr_ff[DEPTHBITS-1:0] <= (Rst_n) ? out_ptr[DEPTHBITS-1:0] : ((HEADREG) ? 'h1 : 'h0);\n  depth_ff[DEPTHBITS:0]     <= (Rst_n) ? depth[DEPTHBITS:0] : 'h0;\n  valid_ff                  <= (Rst_n) ? valid : 1'b0;\n  valid_filt_ff             <= (Rst_n) ? valid_filt : 1'b0;\n  full_ff                   <= (Rst_n) ? full : 1'b0;\n  notfull_ff                <= (Rst_n) ? notfull : 1'b0;\n  headreg_ff[WIDTH-1:0]     <= (Rst_n) ? headreg[WIDTH-1:0] : 'h0;\nend\n\ninteger i;\nalways @(posedge Clk) begin\n  if(in_push) begin\n    data_ff[in_ptr_ff[DEPTHBITS-1:0]] <= in_data[WIDTH-1:0];\n  end\nend\n\nwire [WIDTH-1:0] out_data_pre = (HEADREG) ? headreg_ff[WIDTH-1:0] :\n              raw_data[WIDTH-1:0];\nassign out_data[WIDTH-1:0]    = (ZERO_INVALID && ~valid_filt_ff) ?\n      in_invalid_data[WIDTH-1:0] : out_data_pre[WIDTH-1:0];\nassign out_valid              = valid_filt_ff;\nassign out_notfull            = notfull_ff;\nassign out_overflow           = depth_ff[DEPTHBITS];\nassign out_depth              = depth_ff[DEPTHBITS-1:0];\n\nendmodule\n",
        "module_name": "axi_traffic_gen_v2_0_7_axis_fifo",
        "module_hash": "d0b7d94bc780d62ca0fd33b592ebf904",
        "dataset_index": 23235
      },
      "my_register_d22d3cf2": {
        "rtl_code": "module my_register (\n    input clk,\n    input ena,\n    input d,\n    input clrn,\n    input prn,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (clrn == 1'b0) // clear\n            q <= 1'b0;\n        else if (prn == 1'b0) // preset\n            q <= 1'b1;\n        else if (ena == 1'b1) // enable\n            q <= d;\n    end\n\nendmodule",
        "module_name": "my_register",
        "module_hash": "d22d3cf25b5f270f82a9ca6a995ab07a",
        "dataset_index": 5940
      },
      "mem_encrypt_decrypt_216a8032": {
        "rtl_code": "module mem_encrypt_decrypt (\n  input [n-1:0] data_in,\n  input [k-1:0] key_in,\n  input mode,\n  output [n-1:0] data_out\n);\n\nparameter n = 16; // number of bits in the data signal\nparameter k = 8; // number of bits in the key signal\n\nfunction [n-1:0] encrypt;\n  input [n-1:0] data;\n  input [k-1:0] key;\n  begin\n    encrypt = data ^ key;\n  end\nendfunction\n\nfunction [n-1:0] decrypt;\n  input [n-1:0] data;\n  input [k-1:0] key;\n  begin\n    decrypt = data ^ key;\n  end\nendfunction\n\nassign data_out = (mode == 0) ? encrypt(data_in, key_in) : decrypt(data_in, key_in);\n\nendmodule",
        "module_name": "mem_encrypt_decrypt",
        "module_hash": "216a8032f58d23d05f1fd93b474542c2",
        "dataset_index": 4208
      },
      "binary_counter_cbff687f": {
        "rtl_code": "module binary_counter\n#(\n  parameter N = 4\n)\n(\n  input clk,\n  input reset,\n  output reg [N-1:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 0;\n  end else begin\n    count <= count + 1;\n  end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "cbff687fc415b7f6a374e1c62320d086",
        "dataset_index": 15382
      },
      "rcn_slave_9a9637ba": {
        "rtl_code": "\n\n\n\n\nmodule rcn_slave\n(\n    input rst,\n    input clk,\n\n    input [68:0] rcn_in,\n    output [68:0] rcn_out,\n\n    output cs,\n    output wr,\n    output [3:0] mask,\n    output [23:0] addr,\n    output [31:0] wdata,\n    input [31:0] rdata\n);\n    parameter ADDR_MASK = 0;\n    parameter ADDR_BASE = 1;\n\n    reg [68:0] rin;\n    reg [68:0] rin_d1;\n    reg [68:0] rout;\n\n    assign rcn_out = rout;\n\n    wire [23:0] my_mask = ADDR_MASK;\n    wire [23:0] my_base = ADDR_BASE;\n\n    wire my_req = rin[68] && rin[67] && ((rin[55:34] & my_mask[23:2]) == my_base[23:2]);\n    reg my_req_d1;\n\n    wire [68:0] resp;\n\n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rin_d1 <= 69'd0;\n            my_req_d1 <= 1'b0;\n            rout <= 69'd0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rin_d1 <= rin;\n            my_req_d1 <= my_req;\n            rout <= (my_req_d1) ? resp : rin_d1;\n        end\n\n    assign cs = my_req;\n    assign wr = rin[66];\n    assign mask = rin[59:56];\n    assign addr = {rin[55:34], 2'd0};\n    assign wdata = rin[31:0];\n\n    assign resp = {1'b1, 1'b0, rin_d1[66:32], rdata};\n\nendmodule\n",
        "module_name": "rcn_slave",
        "module_hash": "9a9637ba59a748af3f414d4a800a99ae",
        "dataset_index": 18757
      },
      "diode_controller_de06685c": {
        "rtl_code": "module diode_controller (\n    DIODE,\n    VPWR,\n    VGND,\n    VPB,\n    VNB,\n    D1,\n    D2,\n    D3,\n    D4\n);\n\n    input DIODE;\n    input VPWR;\n    input VGND;\n    input VPB;\n    input VNB;\n    output D1;\n    output D2;\n    output D3;\n    output D4;\n\n    // Define voltage levels\n    parameter HIGH_LEVEL = 1;\n    parameter LOW_LEVEL = 0;\n\n    // Define diode states\n    parameter FORWARD_BIAS = 1;\n    parameter REVERSE_BIAS = 0;\n\n    // Determine diode states based on DIODE input\n    assign D1 = (DIODE == FORWARD_BIAS) ? HIGH_LEVEL : LOW_LEVEL;\n    assign D2 = (DIODE == FORWARD_BIAS) ? HIGH_LEVEL : LOW_LEVEL;\n    assign D3 = (DIODE == FORWARD_BIAS) ? LOW_LEVEL : HIGH_LEVEL;\n    assign D4 = (DIODE == FORWARD_BIAS) ? LOW_LEVEL : HIGH_LEVEL;\n\nendmodule",
        "module_name": "diode_controller",
        "module_hash": "de06685c64c0e9aa8767ae4a3564457e",
        "dataset_index": 10443
      },
      "mux_4to1_d39fbdb5": {
        "rtl_code": "module mux_4to1(\n    input a,\n    input b,\n    input c,\n    input d,\n    input sel_1,\n    input sel_0,\n    output reg out_always\n);\n\nalways @(*) begin\n    if(sel_1 == 0 && sel_0 == 0) begin\n        out_always = a;\n    end\n    else if(sel_1 == 0 && sel_0 == 1) begin\n        out_always = b;\n    end\n    else if(sel_1 == 1 && sel_0 == 0) begin\n        out_always = c;\n    end\n    else begin\n        out_always = d;\n    end\nend\n\nendmodule",
        "module_name": "mux_4to1",
        "module_hash": "d39fbdb5ed61a9b9f19d2927d834a15c",
        "dataset_index": 15724
      },
      "flow_led_162aeb6b": {
        "rtl_code": "module flow_led\n#(parameter LEN = 5, NUM = 5)\n(\n    input power,\n    input sig_ring,\n    input sig_step,\n    output reg [(NUM-1):0] alarm_light\n);\n\n    reg [31:0] count;\n    \n    // 1: representation for ring on\n    // 0: representaion for ring off\n    reg alarm;\n\n    initial begin\n        alarm <= 0;\n        count <= 0;\n        alarm_light <= 0;\n    end\n\n    always @(posedge sig_step) begin\n        if (power) begin\n            if (sig_ring) begin\n                count = 0;\n                alarm = 1;\n                alarm_light = 1;\n            end else begin\n                if (alarm == 1) begin\n                    count = count + 1;\n                    alarm_light = alarm_light * 2 ? alarm_light * 2 : 1;\n                end\n                if (count == LEN) begin\n                    count = 0;\n                    alarm = 0;\n                    alarm_light = 0;\n                end\n            end\n        end else begin\n            count = 0;\n            alarm = 0;\n            alarm_light = 0;\n        end\n    end\n    \nendmodule",
        "module_name": "flow_led",
        "module_hash": "162aeb6b6920ec532563e2417da9b5f3",
        "dataset_index": 19537
      },
      "multiplier_block_7805552a": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0] o_data0;\n\n  //Multipliers:\n  wire [31:0]\n    w1,\n    w4096,\n    w4095,\n    w256,\n    w3839,\n    w15356,\n    w11517,\n    w16,\n    w11533,\n    w128,\n    w11405;\n\n  assign w1 = i_data0;\n  assign w4096 = i_data0 << 12;\n  assign w4095 = w4096 - w1;\n  assign w256 = i_data0 << 8;\n  assign w3839 = w4095 - w256;\n  assign w15356 = w3839 << 2;\n  assign w11517 = w15356 - w3839;\n  assign w16 = w1 << 4;\n  assign w11533 = w11517 + w16;\n  assign w128 = w1 << 7;\n  assign w11405 = w11533 - w128;\n\n  assign o_data0 = w11405;\n\n  //multiplier_block area estimate = 9024.52305565;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "7805552a15fb0cda5fd5c72228a019d9",
        "dataset_index": 17355
      },
      "pipeline_64072fff": {
        "rtl_code": "module pipeline (\n    input clk,\n    input clk_ena,\n    input in_stream,\n    output [WIDTH-1:0] pipeline_reg_0,\n    output [WIDTH-1:0] pipeline_reg_1,\n    output [WIDTH-1:0] pipeline_reg_2,\n    output [WIDTH-1:0] pipeline_reg_3,\n    output [WIDTH-1:0] pipeline_reg_4,\n    output [WIDTH-1:0] pipeline_reg_5,\n    output [WIDTH-1:0] pipeline_reg_6,\n    output [WIDTH-1:0] pipeline_reg_7,\n    output [WIDTH-1:0] pipeline_reg_8,\n    output [WIDTH-1:0] pipeline_reg_9,\n    output [WIDTH-1:0] pipeline_reg_10,\n    output [WIDTH-1:0] pipeline_reg_11,\n    output [WIDTH-1:0] pipeline_reg_12,\n    output [WIDTH-1:0] pipeline_reg_13,\n    input reset\n);\n\nparameter WIDTH = 1;\n\nreg [WIDTH-1:0] pipeline_reg_0;\nreg [WIDTH-1:0] pipeline_reg_1;\nreg [WIDTH-1:0] pipeline_reg_2;\nreg [WIDTH-1:0] pipeline_reg_3;\nreg [WIDTH-1:0] pipeline_reg_4;\nreg [WIDTH-1:0] pipeline_reg_5;\nreg [WIDTH-1:0] pipeline_reg_6;\nreg [WIDTH-1:0] pipeline_reg_7;\nreg [WIDTH-1:0] pipeline_reg_8;\nreg [WIDTH-1:0] pipeline_reg_9;\nreg [WIDTH-1:0] pipeline_reg_10;\nreg [WIDTH-1:0] pipeline_reg_11;\nreg [WIDTH-1:0] pipeline_reg_12;\nreg [WIDTH-1:0] pipeline_reg_13;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        pipeline_reg_0 <= 0;\n        pipeline_reg_1 <= 0;\n        pipeline_reg_2 <= 0;\n        pipeline_reg_3 <= 0;\n        pipeline_reg_4 <= 0;\n        pipeline_reg_5 <= 0;\n        pipeline_reg_6 <= 0;\n        pipeline_reg_7 <= 0;\n        pipeline_reg_8 <= 0;\n        pipeline_reg_9 <= 0;\n        pipeline_reg_10 <= 0;\n        pipeline_reg_11 <= 0;\n        pipeline_reg_12 <= 0;\n        pipeline_reg_13 <= 0;\n    end else begin\n        if (clk_ena) begin\n            pipeline_reg_0 <= in_stream;\n            pipeline_reg_1 <= pipeline_reg_0;\n            pipeline_reg_2 <= pipeline_reg_1;\n            pipeline_reg_3 <= pipeline_reg_2;\n            pipeline_reg_4 <= pipeline_reg_3;\n            pipeline_reg_5 <= pipeline_reg_4;\n            pipeline_reg_6 <= pipeline_reg_5;\n            pipeline_reg_7 <= pipeline_reg_6;\n            pipeline_reg_8 <= pipeline_reg_7;\n            pipeline_reg_9 <= pipeline_reg_8;\n            pipeline_reg_10 <= pipeline_reg_9;\n            pipeline_reg_11 <= pipeline_reg_10;\n            pipeline_reg_12 <= pipeline_reg_11;\n            pipeline_reg_13 <= pipeline_reg_12;\n        end\n    end\nend\n\nendmodule",
        "module_name": "pipeline",
        "module_hash": "64072fff7a78578aa7cafdd8c9e274a2",
        "dataset_index": 13015
      },
      "ECC #_f23559aa": {
        "rtl_code": "\nmodule ECC #(\n  parameter n = 8, // number of bits for the coordinates\n  parameter p = 256, // prime number that defines the finite field\n  parameter a = 1, // coefficient a of the elliptic curve\n  parameter b = 2 // coefficient b of the elliptic curve\n)(\n  input [p-1:0] P,\n  input [n-1:0] A,\n  input [n-1:0] B,\n  input [n-1:0] Px,\n  input [n-1:0] Py,\n  input [n-1:0] Qx,\n  input [n-1:0] Qy,\n  output [n-1:0] Rx,\n  output [n-1:0] Ry,\n  output [n-1:0] Sx,\n  output [n-1:0] Sy\n);\n\n// coordinates of point P on the elliptic curve\nparameter P_x = 8'b00000001;\nparameter P_y = 8'b00000010;\n\n// coordinates of point Q on the elliptic curve\nparameter Q_x = 8'b00000011;\nparameter Q_y = 8'b00000001;\n\n// calculate point R = P + Q\nwire [n-1:0] x1 = P_x;\nwire [n-1:0] y1 = P_y;\nwire [n-1:0] x2 = Q_x;\nwire [n-1:0] y2 = Q_y;\n\nwire [n-1:0] x3;\nwire [n-1:0] y3;\n\nwire [n-1:0] m;\nwire [n-1:0] m2;\nwire [n-1:0] x1x2;\nwire [n-1:0] x3x1;\nwire [n-1:0] y3y1;\n\nassign x1x2 = x1 + x2;\nassign m = (y2 - y1) * (x2 - x1x2)^(p-2);\nassign m2 = m^2;\nassign x3 = m2 - x1x2 - a;\nassign x3x1 = x3 - x1;\nassign y3 = m * x1x2 - m * x3 - y1;\nassign y3y1 = y3 - y1;\n\nassign Rx = x3;\nassign Ry = y3;\n\n// calculate point S = P - Q\nwire [n-1:0] Qy_neg = ~Qy + 1;\nwire [n-1:0] Qx_neg = Qx;\nwire [n-1:0] Sx;\nwire [n-1:0] Sy;\n\nassign Sy = y1 + Qy_neg;\nassign Sx = x1 + Qx_neg;\n\nendmodule",
        "module_name": "ECC #",
        "module_hash": "f23559aadec219a70d82111d12283c82",
        "dataset_index": 19248
      },
      "ad_rst_6aac5560": {
        "rtl_code": "\n\nmodule ad_rst (\n\n  input                   rst_async,\n  input                   clk,\n  output                  rstn,\n  output  reg             rst);\n\n  reg             rst_async_d1 = 1'd1;\n  reg             rst_async_d2 = 1'd1;\n  reg             rst_sync = 1'd1;\n  reg             rst_sync_d = 1'd1;\n\n  always @(posedge clk or posedge rst_async) begin\n    if (rst_async) begin\n      rst_async_d1 <= 1'b1;\n      rst_async_d2 <= 1'b1;\n      rst_sync <= 1'b1;\n    end else begin\n      rst_async_d1 <= 1'b0;\n      rst_async_d2 <= rst_async_d1;\n      rst_sync <= rst_async_d2;\n    end\n  end\n\n  always @(posedge clk) begin\n    rst_sync_d <= rst_sync;\n    rst <= rst_sync_d;\n  end\n\n  assign rstn = ~rst;\n\nendmodule\n\n",
        "module_name": "ad_rst",
        "module_hash": "6aac5560fc0d22ec821fc402e98d7b00",
        "dataset_index": 23652
      },
      "MUX4X1_0f46099f": {
        "rtl_code": "module MUX4X1 (A, B, C, D, S0, S1, Y);\ninput A, B, C, D;\ninput S0, S1;\noutput Y;\n\nreg Y;\n\nalways @ (S1 or S0 or A or B or C or D) begin\n   case ({S1, S0})\n      2'b00: Y = A;\n      2'b01: Y = B;\n      2'b10: Y = C;\n      2'b11: Y = D;\n   endcase\nend\n\nendmodule",
        "module_name": "MUX4X1",
        "module_hash": "0f46099fe5ae22c0961ff4d4ac758326",
        "dataset_index": 21156
      },
      "byte_swap_78d13688": {
        "rtl_code": "module byte_swap(\n    input [31:0] in,\n    output [31:0] out\n);\n\nreg [31:0] shift_reg;\n\n// Shift input vector and load into shift register\nalways @(*) begin\n    shift_reg[31:24] = in[7:0];\n    shift_reg[23:16] = in[15:8];\n    shift_reg[15:8] = in[23:16];\n    shift_reg[7:0] = in[31:24];\nend\n\n// Invert bits of each byte using XOR\nreg [7:0] byte0, byte1, byte2, byte3;\nalways @(*) begin\n    byte0 = shift_reg[7:0] ^ 8'hFF;\n    byte1 = shift_reg[15:8] ^ 8'hFF;\n    byte2 = shift_reg[23:16] ^ 8'hFF;\n    byte3 = shift_reg[31:24] ^ 8'hFF;\nend\n\n// Concatenate inverted bytes in reverse order\nassign out = {byte3, byte2, byte1, byte0};\n\nendmodule",
        "module_name": "byte_swap",
        "module_hash": "78d13688b14829a529c3bac96837ce99",
        "dataset_index": 20304
      },
      "adapter_rgb_2_ppfifo #_e410b003": {
        "rtl_code": "\n\nmodule adapter_rgb_2_ppfifo #(\n  parameter                 DATA_WIDTH = 24\n)(\n  input                             clk,\n  input                             rst,\n\n  input         [23:0]              i_rgb,\n  input                             i_h_sync,\n  input                             i_h_blank,\n  input                             i_v_sync,\n  input                             i_v_blank,\n  input                             i_data_en,\n\n  output                            o_ppfifo_clk,\n  input       [1:0]                 i_ppfifo_rdy,\n  output  reg [1:0]                 o_ppfifo_act,\n  input       [23:0]                i_ppfifo_size,\n  output  reg                       o_ppfifo_stb,\n  output  reg [DATA_WIDTH - 1:0]    o_ppfifo_data\n\n\n);\nlocalparam      IDLE        = 0;\nlocalparam      READY       = 1;\nlocalparam      RELEASE     = 2;\n\nreg           [23:0]        r_count;\nreg           [2:0]         state;\nassign  o_ppfifo_clk    = clk;\nalways @ (posedge clk) begin\n  o_ppfifo_stb          <=  0;\n  if (rst) begin\n    r_count             <=  0;\n    o_ppfifo_act        <=  0;\n    o_ppfifo_data       <=  0;\n    state               <=  IDLE;\n  end\n  else begin\n    case (state)\n      IDLE: begin\n        o_ppfifo_act    <=  0;\n        if ((i_ppfifo_rdy > 0) && (o_ppfifo_act == 0)) begin\n          r_count           <=  0;\n          if (i_ppfifo_rdy[0]) begin\n            o_ppfifo_act[0] <=  1;\n          end\n          else begin\n            o_ppfifo_act[1] <=  1;\n          end\n          state             <=  READY;\n        end\n      end\n      READY: begin\n        if (r_count < i_ppfifo_size) begin\n          if (!i_h_blank) begin\n            o_ppfifo_stb    <=  1;\n            o_ppfifo_data   <=  i_rgb;\n\n            r_count         <=  r_count + 1;\n          end\n        end\n        else begin\n          state             <=  RELEASE;\n        end\n        if (r_count > 0 && i_h_blank) begin\n          state             <=  RELEASE;\n        end\n      end\n      RELEASE: begin\n        o_ppfifo_act        <=  0;\n        state               <=  IDLE;\n      end\n      default: begin\n      end\n    endcase\n  end\nend\n\n\n\nendmodule\n",
        "module_name": "adapter_rgb_2_ppfifo #",
        "module_hash": "e410b003ae02796341a7b20d2123f0f3",
        "dataset_index": 23697
      },
      "LCB_63edba0c": {
        "rtl_code": "\nmodule LCB (\n  input wire ain,\n  input wire din,\n  output wire aout,\n  output wire dout\n);\n\n  // ADC module\n  reg [9:0] adc_out;\n  always @(posedge ain) begin\n    adc_out = ain * 1023;\n  end\n\n  // Debounce module\n  reg [3:0] debounce_counter;\n  reg debounced_din;\n  always @(posedge din) begin\n    debounce_counter <= debounce_counter + 1;\n    if (debounce_counter == 4'hF) begin\n      debounce_counter <= 4'h0;\n      debounced_din <= din;\n    end\n  end\n\n  // Comparator module\n  reg threshold = 512; // 50% of the maximum ADC value\n  reg light_on;\n  always @(adc_out) begin\n    light_on = (adc_out > threshold) ? 1 : 0;\n  end\n\n  // PWM module\n  reg [9:0] pwm_counter;\n  reg pwm_out;\n  always @(posedge light_on) begin\n    pwm_counter <= pwm_counter + 1;\n    pwm_out <= (pwm_counter < (adc_out * 9 / 10)) ? 1 : 0;\n  end\n\n  // Output connections\n  assign aout = pwm_out;\n  assign dout = light_on && debounced_din;\n\nendmodule",
        "module_name": "LCB",
        "module_hash": "63edba0c316c4625ad6fd0cc6bda0c29",
        "dataset_index": 18536
      },
      "PIO_TO_CTRL_818e8137": {
        "rtl_code": "\n\nmodule PIO_TO_CTRL    (\n\n                        clk,\n                        rst_n,\n\n                        req_compl_i,\n                        compl_done_i,\n\n                        cfg_to_turnoff_n,\n                        cfg_turnoff_ok_n\n\n                        );\n\n    input               clk;\n    input               rst_n;\n\n    input               req_compl_i;\n    input               compl_done_i;\n\n    input               cfg_to_turnoff_n;\n    output              cfg_turnoff_ok_n;\n\n    reg                 trn_pending;\n    reg                 cfg_turnoff_ok_n;\n\n\n    \n\n    always @ ( posedge clk or negedge rst_n ) begin\n\n        if (!rst_n ) begin\n\n          trn_pending <= 0;\n\n        end else begin\n\n          if (!trn_pending && req_compl_i)\n\n            trn_pending <= 1'b1;\n\n          else if (compl_done_i)\n\n            trn_pending <= 1'b0;\n\n        end\n\n    end\n\n    \n\n     always @ ( posedge clk or negedge rst_n ) begin\n\n      if (!rst_n ) begin\n\n        cfg_turnoff_ok_n <= 1'b1;\n\n      end else begin\n\n        if ( !cfg_to_turnoff_n  && !trn_pending)\n          cfg_turnoff_ok_n <= 1'b0;\n        else\n          cfg_turnoff_ok_n <= 1'b1;\n\n      end\n\n    end\n\n\nendmodule ",
        "module_name": "PIO_TO_CTRL",
        "module_hash": "818e8137e774fe3481da3a04eca0f9a7",
        "dataset_index": 23979
      },
      "axi_data_fifo_v2_1_7_ndeep_srl #_ae7a9ff9": {
        "rtl_code": "\n\n\n \nmodule axi_data_fifo_v2_1_7_ndeep_srl #\n  (\n   parameter         C_FAMILY  = \"rtl\", parameter         C_A_WIDTH = 1          )\n  (\n   input  wire                 CLK, input  wire [C_A_WIDTH-1:0] A,   input  wire                 CE,  input  wire                 D,   output wire                 Q    );\n\n  localparam integer P_SRLASIZE = 5;\n  localparam integer P_SRLDEPTH = 32;\n  localparam integer P_NUMSRLS  = (C_A_WIDTH>P_SRLASIZE) ? (2**(C_A_WIDTH-P_SRLASIZE)) : 1;\n  localparam integer P_SHIFT_DEPTH  = 2**C_A_WIDTH;\n  \n  wire [P_NUMSRLS:0]   d_i;\n  wire [P_NUMSRLS-1:0] q_i;\n  wire [(C_A_WIDTH>P_SRLASIZE) ? (C_A_WIDTH-1) : (P_SRLASIZE-1) : 0] a_i;\n  \n  genvar i;\n  \n  assign d_i[0] = D;\n  assign a_i = A;\n  \n  generate\n\t\t\t\t\t\n    if (C_FAMILY == \"rtl\") begin : gen_rtl_shifter\n      if (C_A_WIDTH <= P_SRLASIZE) begin : gen_inferred_srl\n        reg [P_SRLDEPTH-1:0] shift_reg = {P_SRLDEPTH{1'b0}};\n        always @(posedge CLK)\n          if (CE)\n            shift_reg <= {shift_reg[P_SRLDEPTH-2:0], D};\n        assign Q = shift_reg[a_i];\n      end else begin : gen_logic_shifter  reg [P_SHIFT_DEPTH-1:0] shift_reg = {P_SHIFT_DEPTH{1'b0}};\n        always @(posedge CLK)\n          if (CE)\n            shift_reg <= {shift_reg[P_SHIFT_DEPTH-2:0], D};\n        assign Q = shift_reg[a_i];\n      end\n    end else begin : gen_primitive_shifter\n      for (i=0;i<P_NUMSRLS;i=i+1) begin : gen_srls\n        SRLC32E\n          srl_inst\n            (\n             .CLK (CLK),\n             .A   (a_i[P_SRLASIZE-1:0]),\n             .CE  (CE),\n             .D   (d_i[i]),\n             .Q   (q_i[i]),\n             .Q31 (d_i[i+1])\n             );\n      end\n      \n      if (C_A_WIDTH>P_SRLASIZE) begin : gen_srl_mux\n        generic_baseblocks_v2_1_0_nto1_mux #\n        (\n          .C_RATIO         (2**(C_A_WIDTH-P_SRLASIZE)),\n          .C_SEL_WIDTH     (C_A_WIDTH-P_SRLASIZE),\n          .C_DATAOUT_WIDTH (1),\n          .C_ONEHOT        (0)\n        )\n        srl_q_mux_inst\n        (\n          .SEL_ONEHOT ({2**(C_A_WIDTH-P_SRLASIZE){1'b0}}),\n          .SEL        (a_i[C_A_WIDTH-1:P_SRLASIZE]),\n          .IN         (q_i),\n          .OUT        (Q)\n        );\n      end else begin : gen_no_srl_mux\n        assign Q = q_i[0];\n      end\n    end\n  endgenerate\n\nendmodule\n\n",
        "module_name": "axi_data_fifo_v2_1_7_ndeep_srl #",
        "module_hash": "ae7a9ff9643c556cdd33c942da44c6f8",
        "dataset_index": 25170
      },
      "adder_with_carry_326bc8c6": {
        "rtl_code": "module adder_with_carry(\n  input clk,\n  input reset,\n  input [15:0] A,\n  input [15:0] B,\n  input cin,\n  input [3:0] sel,\n  output [15:0] sum,\n  output cout\n);\n\n  // Barrel shifter\n  wire [15:0] shifted_A;\n  wire [15:0] shifted_B;\n  \n  assign shifted_A = (sel == 0) ? A :\n                     (sel == 1) ? {A[14:0], 16'b0} :\n                     (sel == 2) ? {A[13:0], 16'b0, 16'b0} :\n                     (sel == 3) ? {A[12:0], 16'b0, 16'b0, 16'b0} :\n                     (sel == 4) ? {A[11:0], 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 5) ? {A[10:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 6) ? {A[9:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 7) ? {A[8:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 8) ? {A[7:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 9) ? {A[6:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 10) ? {A[5:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 11) ? {A[4:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 12) ? {A[3:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 13) ? {A[2:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 14) ? {A[1:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                                   {A[0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0};\n  \n  assign shifted_B = (sel == 0) ? B :\n                     (sel == 1) ? {B[14:0], 16'b0} :\n                     (sel == 2) ? {B[13:0], 16'b0, 16'b0} :\n                     (sel == 3) ? {B[12:0], 16'b0, 16'b0, 16'b0} :\n                     (sel == 4) ? {B[11:0], 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 5) ? {B[10:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 6) ? {B[9:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 7) ? {B[8:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 8) ? {B[7:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 9) ? {B[6:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 10) ? {B[5:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 11) ? {B[4:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 12) ? {B[3:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 13) ? {B[2:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                     (sel == 14) ? {B[1:0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0} :\n                                   {B[0], 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0, 16'b0};\n  \n  // Multiplexer\n  wire [15:0] selected_input;\n  \n  assign selected_input = (sel == 0) ? shifted_A :\n                          (sel == 1) ? {shifted_A[14:0], shifted_B[0]} :\n                          (sel == 2) ? {shifted_A[13:0], shifted_B[1:0]} :\n                          (sel == 3) ? {shifted_A[12:0], shifted_B[2:0]} :\n                          (sel == 4) ? {shifted_A[11:0], shifted_B[3:0]} :\n                          (sel == 5) ? {shifted_A[10:0], shifted_B[4:0]} :\n                          (sel == 6) ? {shifted_A[9:0], shifted_B[5:0]} :\n                          (sel == 7) ? {shifted_A[8:0], shifted_B[6:0]} :\n                          (sel == 8) ? {shifted_A[7:0], shifted_B[7:0]} :\n                          (sel == 9) ? {shifted_A[6:0], shifted_B[8:0]} :\n                          (sel == 10) ? {shifted_A[5:0], shifted_B[9:0]} :\n                          (sel == 11) ? {shifted_A[4:0], shifted_B[10:0]} :\n                          (sel == 12) ? {shifted_A[3:0], shifted_B[11:0]} :\n                          (sel == 13) ? {shifted_A[2:0], shifted_B[12:0]} :\n                          (sel == 14) ? {shifted_A[1:0], shifted_B[13:0]} :\n                                        {shifted_A[0], shifted_B[14:0]};\n  \n  // Full adder\n  wire [15:0] temp_sum;\n  wire temp_cout;\n  \n  assign {temp_cout, temp_sum} = shifted_A + shifted_B + cin;\n  \n  // Output\n  assign sum = selected_input + temp_sum;\n  assign cout = temp_cout;\n\nendmodule",
        "module_name": "adder_with_carry",
        "module_hash": "326bc8c6031d81a696987624eec9099e",
        "dataset_index": 7844
      },
      "mux_2_1_0821c0a0": {
        "rtl_code": "module mux_2_1 (\n    Y,\n    A,\n    B,\n    S\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  S;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not_S;\n    not not_gate (not_S, S);\n\n    assign Y = (A & not_S) | (B & S);\n\nendmodule",
        "module_name": "mux_2_1",
        "module_hash": "0821c0a066c60feb310e0ed7cfdbfdeb",
        "dataset_index": 20824
      },
      "inst_mem_b312e5f0": {
        "rtl_code": "\nmodule inst_mem(\n    input  [6:0] addra,\n    output [15:0] douta\n);\n\nreg [15:0] mem [127:0]; // Assuming a memory of 128 16-bit words\n\nassign douta = mem[addra];\n\nendmodule\n\nmodule instruction_fetch(\n    input         clk_n,\n    input         rst_n,\n    input  [6:0]  m_branch_addr,\n    input         m_branch_en,\n    output [6:0]  if_next_addr,\n    output [15:0] if_curr_inst\n);\n\nreg [6:0] pc;\n\nassign if_next_addr = pc + 1;\n\n// Added b/c the assign won't work (reg needs always block)\nalways@(posedge clk_n or negedge rst_n) begin\n  if(!rst_n) begin\n    pc <= 7'b0;\n  end else begin\n    if(m_branch_en) begin\n      pc <= m_branch_addr;\n    end else begin\n      pc <= if_next_addr;\n    end\n  end\nend\n\n\ninst_mem i_inst_mem(\n  .addra(pc),\n  .douta(if_curr_inst)\n);\n\nendmodule\n",
        "module_name": "inst_mem",
        "module_hash": "b312e5f01c5c157abfc43ce77e19595f",
        "dataset_index": 20494
      },
      "led_controller_863ca86a": {
        "rtl_code": "module led_controller (\n  input [1:0] address,\n  input chipselect,\n  input clk,\n  input reset_n,\n  input write_n,\n  input [31:0] writedata,\n  output [3:0] out_port,\n  output [31:0] readdata\n);\n\n  wire clk_en;\n  reg [3:0] data_out;\n  wire [3:0] out_port;\n  wire [3:0] read_mux_out;\n  wire [31:0] readdata;\n  \n  assign clk_en = 1;\n  \n  assign read_mux_out = {4 {(address == 0)}} & data_out;\n  \n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      data_out <= 0;\n    end else if (chipselect && ~write_n && (address == 0)) begin\n      data_out <= writedata[3:0];\n    end\n  end\n  \n  assign readdata = {32'b0 | read_mux_out};\n  assign out_port = data_out;\n  \nendmodule",
        "module_name": "led_controller",
        "module_hash": "863ca86aeab5efad830c6b0546fdd786",
        "dataset_index": 18237
      },
      "knight_rider_b6d5fbef": {
        "rtl_code": "\nmodule knight_rider(\n    input clk,\n    output [7:0] led_out\n    );\n    \n    parameter LEDS_INIT = 10'b1100000000;\n    parameter DIR_INIT = 1;\n    \n    reg [9:0] leds = LEDS_INIT; reg [3:0] position = DIR_INIT*8; reg direction = DIR_INIT;   always @ (posedge clk) begin\n        if (direction == 0) begin \n            leds <= leds << 1;  end else begin\n            leds <= leds >> 1;  end\n        position <= position + 1;\n    end\n\n    always @ (position) begin       if (position < 8) begin     direction = 0;\n        end else begin\n            direction = 1;\n        end\n    end\n\n    assign led_out = leds[8:1]; endmodule\n",
        "module_name": "knight_rider",
        "module_hash": "b6d5fbef991a6dddbeeb1905ad30034f",
        "dataset_index": 23149
      },
      "up_counter_4bit_sync_reset_ec186fbf": {
        "rtl_code": "module up_counter_4bit_sync_reset (\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst == 1'b1) begin\n        count <= 4'b0;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "up_counter_4bit_sync_reset",
        "module_hash": "ec186fbfaa840b7a1d46a94c1e7891d6",
        "dataset_index": 8773
      },
      "posedge_D_ff_with_enable_9be80e46": {
        "rtl_code": "module posedge_D_ff_with_enable(clk, d, en, q);\n  input clk, d, en;\n  output reg q;\n\n  // Clock gating circuit\n  wire gated_clk;\n  assign gated_clk = clk & en;\n\n  always @(posedge gated_clk) begin\n    q <= d;\n  end\nendmodule",
        "module_name": "posedge_D_ff_with_enable",
        "module_hash": "9be80e467535e4c7081d7e0f31ac797a",
        "dataset_index": 10925
      },
      "register_file_c669e58f": {
        "rtl_code": "module register_file(\n    input clk,\n    input write_en,\n    input [2:0] write_reg,\n    input [31:0] write_data,\n    input read_en,\n    input [2:0] read_reg1,\n    input [2:0] read_reg2,\n    output reg [31:0] read_data1,\n    output reg [31:0] read_data2\n);\n\n    reg [31:0] registers [0:7];\n\n    always @ (posedge clk) begin\n        if (write_en) begin\n            registers[write_reg] <= write_data;\n        end\n        if (read_en) begin\n            read_data1 <= registers[read_reg1];\n            read_data2 <= registers[read_reg2];\n        end\n    end\n\nendmodule",
        "module_name": "register_file",
        "module_hash": "c669e58fcdf6dfb4011fdc88941a7206",
        "dataset_index": 9962
      },
      "EHR_6_4889a6a6": {
        "rtl_code": "module EHR_6 (\n    CLK,\n    RST_N,\n    read_0,\n    write_0,\n    EN_write_0,\n    read_1,\n    write_1,\n    EN_write_1,\n    read_2,\n    write_2,\n    EN_write_2,\n    read_3,\n    write_3,\n    EN_write_3,\n    read_4,\n    write_4,\n    EN_write_4,\n    read_5,\n    write_5,\n    EN_write_5\n);\n    parameter            DATA_SZ = 1;\n    parameter            RESET_VAL = 0;\n\n    input                CLK;\n    input                RST_N;\n    output [DATA_SZ-1:0] read_0;\n    input  [DATA_SZ-1:0] write_0;\n    input                EN_write_0;\n    output [DATA_SZ-1:0] read_1;\n    input  [DATA_SZ-1:0] write_1;\n    input                EN_write_1;\n    output [DATA_SZ-1:0] read_2;\n    input  [DATA_SZ-1:0] write_2;\n    input                EN_write_2;\n    output [DATA_SZ-1:0] read_3;\n    input  [DATA_SZ-1:0] write_3;\n    input                EN_write_3;\n    output [DATA_SZ-1:0] read_4;\n    input  [DATA_SZ-1:0] write_4;\n    input                EN_write_4;\n    output [DATA_SZ-1:0] read_5;\n    input  [DATA_SZ-1:0] write_5;\n    input                EN_write_5;\n\n    reg    [DATA_SZ-1:0] r;\n    wire   [DATA_SZ-1:0] wire_0;\n    wire   [DATA_SZ-1:0] wire_1;\n    wire   [DATA_SZ-1:0] wire_2;\n    wire   [DATA_SZ-1:0] wire_3;\n    wire   [DATA_SZ-1:0] wire_4;\n    wire   [DATA_SZ-1:0] wire_5;\n    wire   [DATA_SZ-1:0] wire_6;\n\n    assign wire_0 = r;\n    assign wire_1 = EN_write_0 ? write_0 : wire_0;\n    assign wire_2 = EN_write_1 ? write_1 : wire_1;\n    assign wire_3 = EN_write_2 ? write_2 : wire_2;\n    assign wire_4 = EN_write_3 ? write_3 : wire_3;\n    assign wire_5 = EN_write_4 ? write_4 : wire_4;\n    assign wire_6 = EN_write_5 ? write_5 : wire_5;\n\n    assign read_0 = wire_0;\n    assign read_1 = wire_1;\n    assign read_2 = wire_2;\n    assign read_3 = wire_3;\n    assign read_4 = wire_4;\n    assign read_5 = wire_5;\n\n    always @(posedge CLK) begin\n        if (RST_N == 0) begin\n            r <= RESET_VAL;\n        end else begin\n            r <= wire_6;\n        end\n    end\nendmodule\n",
        "module_name": "EHR_6",
        "module_hash": "4889a6a6f3a14bc2ff6f36d1dae9a4a2",
        "dataset_index": 16515
      },
      "top__ddea8bb2": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output [3:1] ena,\n    output [15:0] q);\n    \n    wire [3:0] bcd_out;\n    wire [15:0] binary_out;\n    wire [3:1] ena_out;\n    \n    binary_to_bcd_converter bcd_converter(\n        .binary_in(binary_out),\n        .bcd_out(bcd_out)\n    );\n    \n    priority_encoder priority_encoder_inst(\n        .in(ena_out),\n        .out(ena)\n    );\n    \n    reg [15:0] count;\n    reg [3:1] ena_reg;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n            ena_reg <= 0;\n        end\n        else begin\n            count <= count + 1;\n            ena_reg <= ena_out;\n        end\n    end\n    \n    assign binary_out = count;\n    assign ena_out = {3{1'b1}};\n    \n    assign q = {bcd_out[3], bcd_out[2], bcd_out[1], bcd_out[0], 12'b0};\n    \nendmodule\n\nmodule binary_to_bcd_converter (\n    input [15:0] binary_in,\n    output [3:0] bcd_out\n);\n    \n    reg [3:0] bcd_reg;\n    \n    always @* begin\n        case (binary_in)\n            0: bcd_reg = 4'b0000;\n            1: bcd_reg = 4'b0001;\n            2: bcd_reg = 4'b0010;\n            3: bcd_reg = 4'b0011;\n            4: bcd_reg = 4'b0100;\n            5: bcd_reg = 4'b0101;\n            6: bcd_reg = 4'b0110;\n            7: bcd_reg = 4'b0111;\n            8: bcd_reg = 4'b1000;\n            9: bcd_reg = 4'b1001;\n            10: bcd_reg = 4'b0001;\n            11: bcd_reg = 4'b0010;\n            12: bcd_reg = 4'b0011;\n            13: bcd_reg = 4'b0100;\n            14: bcd_reg = 4'b0101;\n            15: bcd_reg = 4'b0110;\n            16: bcd_reg = 4'b0111;\n            17: bcd_reg = 4'b1000;\n            18: bcd_reg = 4'b1001;\n            19: bcd_reg = 4'b0001;\n            20: bcd_reg = 4'b0010;\n            21: bcd_reg = 4'b0011;\n            22: bcd_reg = 4'b0100;\n            23: bcd_reg = 4'b0101;\n            24: bcd_reg = 4'b0110;\n            25: bcd_reg = 4'b0111;\n            26: bcd_reg = 4'b1000;\n            27: bcd_reg = 4'b1001;\n            28: bcd_reg = 4'b0001;\n            29: bcd_reg = 4'b0010;\n            30: bcd_reg = 4'b0011;\n            31: bcd_reg = 4'b0100;\n            32: bcd_reg = 4'b0101;\n            33: bcd_reg = 4'b0110;\n            34: bcd_reg = 4'b0111;\n            35: bcd_reg = 4'b1000;\n            default: bcd_reg = 4'b0000;\n        endcase\n    end\n    \n    assign bcd_out = bcd_reg;\n    \nendmodule\n\nmodule priority_encoder (\n    input [2:0] in,\n    output [2:0] out\n);\n    \n    assign out = ~{in[2], in[1], in[0]};\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "ddea8bb22e41e35db5875d064a33e106",
        "dataset_index": 16937
      },
      "counterModulo_7534f412": {
        "rtl_code": "\n\nmodule counterModulo(clk, modulo, count, oClk);\n\tparameter n = 10, safe = 1;\n\tinput clk;\n\tinput [n-1:0] modulo;\n\toutput reg [n-1:0] count = 0;\n\toutput oClk;\n\t\n\tassign oClk = count+1 == modulo ? 1 :\n\t\t\t\t\tcount+1 < modulo ? 0 :\n\t\t\t\t\tsafe ? 1 : 1'bx;\n\n\talways @(posedge clk)\n\t\tif (!oClk)\n\t\t\tcount <= count + 1;\n\t\telse\n\t\t\tcount <= 0;\nendmodule\n\nmodule vgaRotatingCounter(input clk, reset_,\n\t\t\t\t\t\t\t\t\toutput reg [1:0] stage,\n\t\t\t\t\t\t\t\t\toutput [9:0] count,\n\t\t\t\t\t\t\t\t\toutput reg outClk);\n\tparameter ta = 96, tb = 16, tc = 640, td = 48;\n\tlocalparam A = 0, B = 1, C = 2, D = 3;\n\n\twire stageClk;\n\twire [9:0] modulo;\n\t\n\tassign modulo = stage == A ? ta :\n\t\t\t\t\t\tstage == B ? tb :\n\t\t\t\t\t\tstage == C ? tc :\n\t\t\t\t\t\ttd;\n\tcounterModulo #(10,0) c(clk, modulo, count, stageClk);\n\t\n\talways @(posedge clk)\n\t\tif (stageClk) begin\n\t\t\tif (stage == D)\n\t\t\t\toutClk <= 1;\n\t\t\tstage <= stage + 1;\n\t\tend else\n\t\t  outClk <= 0;\nendmodule\n\nmodule vgaControl(input clk, reset_,\n\t\t\t\t\t\toutput reg VGA_VS, VGA_HS,\n\t\t\t\t\t\toutput need,\n\t\t\t\t\t\toutput [9:0] hNeed, vNeed);\n\tparameter n = 4;\n\t\n\tparameter ha = 120, hb = 64, hc = 800, hd = 56;\n\tparameter va = 6, vb = 23, vc = 600, vd = 37;\n\n\twire [1:0] hStage, vStage;\n\twire [9:0] hCount, vCount;\n\twire hClock, vClock, vEnd;\n\n\talways @(posedge clk) begin\n\t\tVGA_HS <= hStage != 0;\n\t\tVGA_VS <= vStage != 0;\n\tend\n\n\tassign need = vStage == 2 && ((hStage == 2 && hCount != hc-1)\n\t\t\t\t\t\t\t\t\t\t|| (hStage == 1 && hCount == hb-1));\n\n\tassign hNeed = hStage == 2 ? hCount+1 : 0;\n\tassign vNeed = vCount;\n\t\n\tassign hClock = clk;\n\tvgaRotatingCounter #(ha, hb, hc, hd) h(hClock, 1, hStage, hCount, vClock);\n\tvgaRotatingCounter #(va, vb, vc, vd) v(vClock, 1, vStage, vCount, vEnd);\nendmodule",
        "module_name": "counterModulo",
        "module_hash": "7534f412e533d8a6a488ad40e50edd07",
        "dataset_index": 24070
      },
      "dlatch_reset_bfd48760": {
        "rtl_code": "module dlatch_reset (\n    input D,\n    input RESET_B,\n    input GATE,\n    input CLK,\n    output Q,\n    output Q_N\n);\n\n    wire AND1_out;\n    wire AND2_out;\n    wire OR1_out;\n    wire NOT1_out;\n    wire NOT2_out;\n\n    // AND1 gate for GATE and CLK\n    assign AND1_out = GATE & CLK;\n\n    // AND2 gate for NOT GATE and CLK\n    assign AND2_out = ~GATE & CLK;\n\n    // OR1 gate for AND1_out and NOT RESET_B\n    assign OR1_out = AND1_out | ~RESET_B;\n\n    // NOT1 gate for OR1_out\n    assign NOT1_out = ~OR1_out;\n\n    // NOT2 gate for AND2_out\n    assign NOT2_out = ~AND2_out;\n\n    // D-latch with reset behavior\n    reg Q;\n    reg Q_N;\n  \n    always @(posedge CLK or negedge RESET_B)\n    begin\n        if (~RESET_B)\n        begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end\n        else\n        begin\n            Q <= D & GATE;\n            Q_N <= ~(D & GATE);\n        end\n    end\n\nendmodule",
        "module_name": "dlatch_reset",
        "module_hash": "bfd48760bd9fbf8aa0ea8783b28118ac",
        "dataset_index": 5980
      },
      "adder_reg_760f3010": {
        "rtl_code": "module adder_reg (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [3:0] a,\n    input [3:0] b,\n    input select, // Select input to choose between adder and register\n    output reg [7:0] q // 8-bit output from the active module\n);\n\nreg [3:0] sum;\n\nalways @ (posedge clk) begin\n    if (reset) begin\n        sum <= 4'b0000;\n        q <= 8'b00000000;\n    end else begin\n        if (select) begin\n            q <= sum;\n        end else begin\n            sum <= a + b;\n            q <= sum;\n        end\n    end\nend\n\nendmodule",
        "module_name": "adder_reg",
        "module_hash": "760f30102660ba65159481a1095fef8c",
        "dataset_index": 9347
      },
      "pwm_generator_606aa8fe": {
        "rtl_code": "module pwm_generator\n    #(parameter PWM_DEPTH = 8)\n    (\n     input clk,\n     input rst_n,\n     input enable,\n     input [PWM_DEPTH - 1:0] duty_cycle,\n     output reg PWM_out\n    );\n\n    reg [PWM_DEPTH - 1:0] counter;\n    reg [PWM_DEPTH - 1:0] threshold;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end\n        else if (enable) begin\n            counter <= counter + 1;\n            if (counter >= threshold) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end\n            else begin\n                PWM_out <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        threshold = (2**PWM_DEPTH - 1) * duty_cycle / 100;\n    end\n\nendmodule",
        "module_name": "pwm_generator",
        "module_hash": "606aa8fe91bb4bac747507d12f014ca0",
        "dataset_index": 17609
      },
      "xor__52378b7b": {
        "rtl_code": "\nmodule xor_module (\n    input a,\n    input b,\n    input clk,\n    output reg out_comb_ff\n);\n    always @(posedge clk) begin\n        out_comb_ff <= a ^ b;\n    end\nendmodule\nmodule edge_detection (\n    input a,\n    input clk,\n    output reg rising_edge,\n    output reg falling_edge\n);\n    parameter IDLE = 2'b00, RISING = 2'b01, FALLING = 2'b10;\n    reg [1:0] state, next_state;\n    \n    always @(posedge clk) begin\n        state <= next_state;\n    end\n    \n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (a) begin\n                    next_state = RISING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            RISING: begin\n                if (a) begin\n                    next_state = RISING;\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            FALLING: begin\n                if (a) begin\n                    next_state = RISING;\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        case (state)\n            IDLE: begin\n                rising_edge <= 1'b0;\n                falling_edge <= 1'b0;\n            end\n            RISING: begin\n                rising_edge <= 1'b1;\n                falling_edge <= 1'b0;\n            end\n            FALLING: begin\n                rising_edge <= 1'b0;\n                falling_edge <= 1'b1;\n            end\n        endcase\n    end\nendmodule\nmodule final_module (\n    input out_comb_ff,\n    input rising_edge,\n    input falling_edge,\n    output reg [1:0] final_output\n);\n    always @* begin\n        if (out_comb_ff && rising_edge) begin\n            final_output = 2'b10;\n        end else if (out_comb_ff || rising_edge || falling_edge) begin\n            final_output = 2'b01;\n        end else begin\n            final_output = 2'b00;\n        end\n    end\nendmodule\nmodule top_module (\n    input clk,\n    input rst_n,\n    input a,\n    input b,\n    output out_comb_ff,\n    output [1:0] final_output\n);\n    reg rising_edge, falling_edge;\n    wire out_comb_ff_wire;\n    wire rising_edge_wire, falling_edge_wire;\n    \n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .clk(clk),\n        .out_comb_ff(out_comb_ff_wire)\n    );\n    \n    edge_detection edge_inst (\n        .a(a),\n        .clk(clk),\n        .rising_edge(rising_edge_wire),\n        .falling_edge(falling_edge_wire)\n    );\n    \n    final_module final_inst (\n        .out_comb_ff(out_comb_ff_wire),\n        .rising_edge(rising_edge_wire),\n        .falling_edge(falling_edge_wire),\n        .final_output(final_output)\n    );\n    \n    assign out_comb_ff = out_comb_ff_wire;\n    \nendmodule",
        "module_name": "xor_",
        "module_hash": "52378b7b88d3313aa6cc5c5a052a1c31",
        "dataset_index": 1449
      },
      "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W6_87_6f09e8c1": {
        "rtl_code": "module SNPS_CLOCK_GATE_HIGH_RegisterAdd_W6_87 ( CLK, EN, TE, ENCLK );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  assign ENCLK = (EN | TE) ? CLK : 1'b0;\n\nendmodule",
        "module_name": "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W6_87",
        "module_hash": "6f09e8c14d273fa970b1aae33a16cb72",
        "dataset_index": 6471
      },
      "binary_add_sub_11291ffa": {
        "rtl_code": "\nmodule binary_add_sub (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [31:0] a,   // 32-bit input a\n    input [31:0] b,   // 32-bit input b\n    input sub,        // Select input for addition or subtraction\n    input enable,     // Enable input for the storage module\n    output [31:0] sum // 32-bit output for the selected operation\n);\n\n    // 8-bit binary number storage module\n    reg [7:0] stored_num = 8'h34;\n    \n    // Adder-subtractor module for 32-bit binary numbers\n    wire [31:0] result;\n    wire [31:0] inverted_b = sub ? ~b + 1 : b;\n    assign result = a + inverted_b;\n    \n    // Carry-lookahead adder architecture\n    wire [31:0] g, p, c;\n    assign g = result & {32{1'b1}};\n    assign p = a ^ inverted_b;\n    assign c[0] = sub;\n    generate\n        genvar i;\n        for (i = 1; i < 32; i = i + 1) begin : carry_gen\n            assign c[i] = g[i-1] | (p[i-1] & c[i-1]);\n        end\n    endgenerate\n    \n    // Output\n    \n    assign sum = result; // Fixed the RTL code by assigning the result to the output sum \n    \n    always @(posedge clk) begin\n        if (reset) begin\n            stored_num <= 8'h34;\n            // Remove the assignment to sum here\n        end else if (enable) begin\n            stored_num <= result[7:0];\n        end else begin\n            // Remove the assignment to sum here\n        end\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [31:0] a,   // 32-bit input a\n    input [31:0] b,   // 32-bit input b\n    input sub,        // Select input for addition or subtraction\n    input enable,     // Enable input for the storage module\n    output [31:0] sum // 32-bit output for the selected operation\n);\n    \n    binary_add_sub add_sub (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .sub(sub),\n        .enable(enable),\n        .sum(sum)\n    );\n\nendmodule",
        "module_name": "binary_add_sub",
        "module_hash": "11291ffa7b0310c1ab8e579f3abb980e",
        "dataset_index": 15217
      },
      "top__468a8f07": {
        "rtl_code": "module top_module (\n    input [7:0] a, b, c, d, // Input ports for the 4-way minimum circuit\n    input [31:0] num1, num2, // Input ports for the 32-bit adder/subtractor\n    input sub, // Select input for addition/subtraction\n    output [31:0] result // Output port for the final sum\n);\n\n// 4-way minimum circuit\nwire [7:0] min1, min2, min3, min4;\nwire [7:0] min12, min34;\nwire [7:0] min1234;\n\nassign min1 = (a < b) ? a : b;\nassign min2 = (a < b) ? b : a;\nassign min3 = (c < d) ? c : d;\nassign min4 = (c < d) ? d : c;\n\nassign min12 = (min1 < min3) ? min1 : min3;\nassign min34 = (min2 < min4) ? min2 : min4;\n\nassign min1234 = (min12 < min34) ? min12 : min34;\n\n// 32-bit adder/subtractor\nwire [31:0] sum;\nwire [31:0] diff;\n\nassign sum = num1 + num2;\nassign diff = num1 - num2;\n\nassign result = (sub) ? min1234 - diff : min1234 + sum;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "468a8f07e76d5c04d6de4f1c720af6ae",
        "dataset_index": 4295
      },
      "data_packet_fifo_ab215ff1": {
        "rtl_code": "module data_packet_fifo \n  ( input       reset,\n    input       clock,\n    input       [31:0]ram_data_in,\n    input       write_enable,\n    output  reg have_space,\n    output  reg [31:0]ram_data_out,\n    output  reg pkt_waiting,\n\toutput\treg\tisfull,\n\toutput\treg [1:0]usb_ram_packet_out,\n\toutput\treg [1:0]usb_ram_packet_in,\n    input       read_enable,\n    input       pkt_complete,\n    input       skip_packet) ;\n\n    \n    parameter DATA_WIDTH = 32 ;\n    parameter PKT_DEPTH = 128 ;\n    parameter NUM_PACKETS = 4 ;\n\n    \n    reg [DATA_WIDTH-1:0] usb_ram [PKT_DEPTH*NUM_PACKETS-1:0] ;\n\n    \n    reg [6:0] usb_ram_offset_out ;\n    reg [6:0] usb_ram_offset_in ;\n    wire [6-2+NUM_PACKETS:0] usb_ram_aout ;\n    wire [6-2+NUM_PACKETS:0] usb_ram_ain ;\n    assign usb_ram_aout = {usb_ram_packet_out, usb_ram_offset_out} ;\n    assign usb_ram_ain = {usb_ram_packet_in, usb_ram_offset_in} ;\n    \n    always @(usb_ram_ain, usb_ram_aout, isfull)\n    begin\n        if (usb_ram_ain == usb_ram_aout)\n            pkt_waiting <= isfull ;\n        else if (usb_ram_ain > usb_ram_aout)\n            pkt_waiting <= (usb_ram_ain - usb_ram_aout) >= PKT_DEPTH;\n        else\n            pkt_waiting <= (usb_ram_ain + 10'b1000000000 - usb_ram_aout) >= PKT_DEPTH;\n    end\n \n    always @(usb_ram_ain, usb_ram_aout, isfull)\n    begin\n        if (usb_ram_ain == usb_ram_aout)\n            have_space <= ~isfull;   \n        else if (usb_ram_ain > usb_ram_aout)\n            have_space <= ((usb_ram_ain - usb_ram_aout) <= PKT_DEPTH * (NUM_PACKETS - 1))? 1'b1 : 1'b0;\n        else\n            have_space <= (usb_ram_aout - usb_ram_ain) >= PKT_DEPTH;\n    end\n\n\n\n    \n    always @(posedge clock)\n    begin\n        if( write_enable ) \n          begin\n            usb_ram[usb_ram_ain] <= ram_data_in ;\n          end\n\t\tram_data_out <= usb_ram[usb_ram_aout] ;\n    end\n\n    \n    always @(posedge clock)\n    begin\n        if( reset ) \n          begin\n            usb_ram_packet_out <= 0 ;\n            usb_ram_offset_out <= 0 ;\n\t\t\tusb_ram_offset_in <= 0 ;\n            usb_ram_packet_in <= 0 ;\n            isfull <= 0;\n          end\n        else\n\t\t  begin\n            if( skip_packet )\n              begin\n                usb_ram_packet_out <= usb_ram_packet_out + 1 ;\n                usb_ram_offset_out <= 0 ;\n                isfull <= 0;\n              end\n            else if(read_enable) \n\t\t\t  begin\n                if( usb_ram_offset_out == 7'b1111111 )\n                  begin\n                    isfull <= 0 ;\n                    usb_ram_offset_out <= 0 ;\n                    usb_ram_packet_out <= usb_ram_packet_out + 1 ;\n                  end\n                else\n                    usb_ram_offset_out <= usb_ram_offset_out + 1 ;  \n              end\n\t\t\tif( pkt_complete )\n              begin\n                usb_ram_packet_in <= usb_ram_packet_in + 1 ;\n                usb_ram_offset_in <= 0 ;\n                if ((usb_ram_packet_in + 2'b1) == usb_ram_packet_out)\n                    isfull <= 1 ;\n              end\n            else if( write_enable ) \n              begin\n                if (usb_ram_offset_in == 7'b1111111)\n                    usb_ram_offset_in <= 7'b1111111 ;    \n                else\n                    usb_ram_offset_in <= usb_ram_offset_in + 1 ;\n              end\n\t\t  end\n    end\n\nendmodule\n",
        "module_name": "data_packet_fifo",
        "module_hash": "ab215ff15f6fbc34ec50d8f76b85fe9f",
        "dataset_index": 25780
      },
      "rising_edge_detector_d001f34a": {
        "rtl_code": "module rising_edge_detector (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    if (in > prev_in) begin\n        out <= in;\n    end\n    prev_in <= in;\nend\n\nendmodule\n\nmodule shift_register (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\nreg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[6:0], in};\n    out <= shift_reg;\nend\n\nendmodule\n\nmodule data_selector (\n    input [7:0] in,\n    input [7:0] stored,\n    input [2:0] select,\n    output reg [7:0] selected\n);\n\nalways @(*) begin\n    case (select)\n        3'b000: selected = in;\n        3'b001: selected = stored;\n        default: selected = 8'b0;\n    endcase\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    input [2:0] select,\n    output [7:0] q\n);\n\nwire [7:0] rising_edge_out;\nwire [7:0] shift_reg_out;\n\nrising_edge_detector red_inst (\n    .clk(clk),\n    .in(in),\n    .out(rising_edge_out)\n);\n\nshift_register sr_inst (\n    .clk(clk),\n    .in(rising_edge_out),\n    .out(shift_reg_out)\n);\n\ndata_selector ds_inst (\n    .in(in),\n    .stored(shift_reg_out),\n    .select(select),\n    .selected(q)\n);\n\nendmodule",
        "module_name": "rising_edge_detector",
        "module_hash": "d001f34a69c5fb7987c1d5db990842ab",
        "dataset_index": 15354
      },
      "ripple_carry_adder_0b9903b8": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OUT\n);\n\nreg [3:0] sum;\nreg carry;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        sum <= 4'b0;\n        carry <= 1'b0;\n    end else begin\n        {carry, sum} <= A + B + carry;\n    end\nend\n\nassign OUT = sum;\n\nendmodule\nmodule consecutive_ones_counter (\n    input clk,\n    input [3:0] in,\n    output [3:0] out\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (in == 4'b0000) begin\n        counter <= 4'b0000;\n    end else if (in == 4'b1111) begin\n        counter <= 4'b1111;\n    end else begin\n        counter <= {counter[2:0], in[3]};\n    end\nend\n\nassign out = counter;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OUT,\n    output [3:0] counter_out\n);\n\nwire [3:0] adder_out;\n\nripple_carry_adder adder_inst (\n    .clk(clk),\n    .reset(reset),\n    .A(A),\n    .B(B),\n    .OUT(adder_out)\n);\n\nconsecutive_ones_counter counter_inst (\n    .clk(clk),\n    .in(adder_out),\n    .out(counter_out)\n);\n\nassign OUT = adder_out;\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "0b9903b8f393b0b0cd7db6d238a12200",
        "dataset_index": 15332
      },
      "five_to_one_de1fc855": {
        "rtl_code": "module five_to_one(\n    input [1:0] in1,\n    input [2:0] in2,\n    input in3,\n    input [3:0] in4,\n    input [1:0] in5,\n    output out1\n);\n\n    assign out1 = (in1 >= 2) | (in2 >= 4) | (in3) | ((in4 + in5) >= 5);\n\nendmodule",
        "module_name": "five_to_one",
        "module_hash": "de1fc855f672045247a4fd324ae66ca9",
        "dataset_index": 11686
      },
      "packet_transmit_2c05e26c": {
        "rtl_code": "module packet_transmit (\n    input clk,\n    input rst_n,\n    input exe2disp_data_wr,\n    input [7:0] exe2disp_data,\n    input exe2disp_valid_wr,\n    input exe2disp_valid,\n    input exe2disp_direction_req,\n    input exe2disp_direction,\n    input um2npe_data_wr,\n    input [7:0] um2npe_data,\n    input um2npe_valid_wr,\n    input um2npe_valid,\n    input disp2usermux_data_wr,\n    input [7:0] disp2usermux_data,\n    input disp2usermux_valid_wr,\n    input disp2usermux_valid,\n    output reg [7:0] exe2disp_data_out,\n    output reg exe2disp_valid_out,\n    output reg disp2exe_alf,\n    output reg [7:0] um2npe_data_out,\n    output reg um2npe_valid_out,\n    output reg um2npe_alf,\n    output reg [7:0] disp2usermux_data_out,\n    output reg disp2usermux_valid_out,\n    output reg usermux2disp_alf\n);\n\nreg [7:0] pkt_buffer;\nreg pkt_valid;\nreg pkt_direction;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pkt_buffer <= 8'h00;\n        pkt_valid <= 1'b0;\n        pkt_direction <= 1'b0;\n    end else begin\n        if (exe2disp_data_wr && exe2disp_direction_req) begin\n            pkt_buffer <= exe2disp_data;\n            pkt_valid <= exe2disp_valid;\n            pkt_direction <= exe2disp_direction;\n        end else if (um2npe_data_wr) begin\n            pkt_buffer <= um2npe_data;\n            pkt_valid <= um2npe_valid;\n            pkt_direction <= 0;\n        end else if (disp2usermux_data_wr) begin\n            pkt_buffer <= disp2usermux_data;\n            pkt_valid <= disp2usermux_valid;\n            pkt_direction <= 1;\n        end\n    end\nend\n\nalways @* begin\n    exe2disp_data_out = pkt_buffer;\n    exe2disp_valid_out = pkt_valid && (pkt_direction == 0);\n    disp2exe_alf = pkt_valid && (pkt_direction == 0);\n    um2npe_data_out = pkt_buffer;\n    um2npe_valid_out = pkt_valid && (pkt_direction == 0);\n    um2npe_alf = pkt_valid && (pkt_direction == 0);\n    disp2usermux_data_out = pkt_buffer;\n    disp2usermux_valid_out = pkt_valid && (pkt_direction == 1);\n    usermux2disp_alf = pkt_valid && (pkt_direction == 1);\nend\n\nendmodule",
        "module_name": "packet_transmit",
        "module_hash": "2c05e26ceb0b7e4614b9b67f9a211de1",
        "dataset_index": 12139
      },
      "oh_par2ser #_6e6c6a05": {
        "rtl_code": "module oh_par2ser #(parameter PW = 64, // parallel packet width\n\t\t    parameter SW = 1,  // serial packet width\n\t\t    parameter CW = $clog2(PW/SW)  // serialization factor\n\t\t    )\n   (\n    input \t    clk, // sampling clock   \n    input \t    nreset, // async active low reset\n    input [PW-1:0]  din, // parallel data\n    output [SW-1:0] dout, // serial output data\n    output \t    access_out,// output data valid    \n    input \t    load, // load parallel data (priority)   \n    input \t    shift, // shift data\n    input [7:0]     datasize, // size of data to shift \n    input \t    lsbfirst, // lsb first order\n    input \t    fill, // fill bit  \n    input \t    wait_in, // wait input  \n    output \t    wait_out // wait output (wait in | serial wait)\n    );\n \n   // local wires\n   reg [PW-1:0]    shiftreg;\n   reg [CW-1:0]    count;\n   wire \t   start_transfer;\n   wire \t   busy;\n   \n   // start serialization   \n   assign start_transfer = load &  ~wait_in & ~busy;\n\n   //transfer counter\n   always @ (posedge clk or negedge nreset)\n     if(!nreset)\n       count[CW-1:0] <= 'b0;   \n     else if(start_transfer)\n       count[CW-1:0] <= datasize[CW-1:0];  //one \"SW sized\" transfers\n     else if(shift & busy)\n       count[CW-1:0] <= count[CW-1:0] - 1'b1;\n   \n   //output data is valid while count > 0\n   assign busy = |count[CW-1:0];\n   \n   //data valid while shifter is busy\n   assign access_out = busy;\n      \n   //wait until valid data is finished\n   assign wait_out  = wait_in | busy;\n   \n   // shift register\n   always @ (posedge clk)\n     if(start_transfer)\n       shiftreg[PW-1:0] = din[PW-1:0];\n     else if(shift & lsbfirst)\t\t \n       shiftreg[PW-1:0] = {{(SW){fill}}, shiftreg[PW-1:SW]};\n     else if(shift)\n       shiftreg[PW-1:0] = {shiftreg[PW-SW-1:0],{(SW){fill}}};\n   \n\n   assign dout[SW-1:0] = lsbfirst ? shiftreg[SW-1:0] : \n\t\t\t            shiftreg[PW-1:PW-SW];\t\n\nendmodule",
        "module_name": "oh_par2ser #",
        "module_hash": "6e6c6a05b9bd4123ff983912e0c947a1",
        "dataset_index": 12634
      },
      "axi_axis_writer #_5cda3e2d": {
        "rtl_code": "\n\nmodule axi_axis_writer #\n(\n  parameter integer AXI_DATA_WIDTH = 32,\n  parameter integer AXI_ADDR_WIDTH = 16\n)\n(\n  input  wire                      aclk,\n  input  wire                      aresetn,\n\n  input  wire [AXI_ADDR_WIDTH-1:0] s_axi_awaddr,  input  wire                      s_axi_awvalid, output wire                      s_axi_awready, input  wire [AXI_DATA_WIDTH-1:0] s_axi_wdata,   input  wire                      s_axi_wvalid,  output wire                      s_axi_wready,  output wire [1:0]                s_axi_bresp,   output wire                      s_axi_bvalid,  input  wire                      s_axi_bready,  input  wire [AXI_ADDR_WIDTH-1:0] s_axi_araddr,  input  wire                      s_axi_arvalid, output wire                      s_axi_arready, output wire [AXI_DATA_WIDTH-1:0] s_axi_rdata,   output wire [1:0]                s_axi_rresp,   output wire                      s_axi_rvalid,  input  wire                      s_axi_rready,  output wire [AXI_DATA_WIDTH-1:0] m_axis_tdata,\n  output wire                      m_axis_tvalid\n);\n\n  reg int_awready_reg, int_awready_next;\n  reg [AXI_DATA_WIDTH-1:0] int_wdata_reg, int_wdata_next;\n  reg int_wready_reg, int_wready_next;\n  reg int_bvalid_reg, int_bvalid_next;\n\n  wire int_awdone_wire, int_wdone_wire, int_bdone_wire;\n  wire [AXI_DATA_WIDTH-1:0] int_wdata_wire;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_awready_reg <= 1'b1;\n      int_wdata_reg <= {(AXI_DATA_WIDTH){1'b0}};\n      int_wready_reg <= 1'b1;\n      int_bvalid_reg <= 1'b0;\n    end\n    else\n    begin\n      int_awready_reg <= int_awready_next;\n      int_wdata_reg <= int_wdata_next;\n      int_wready_reg <= int_wready_next;\n      int_bvalid_reg <= int_bvalid_next;\n    end\n  end\n\n  assign int_awdone_wire = ~int_awready_reg | s_axi_awvalid;\n  assign int_wdone_wire = ~int_wready_reg | s_axi_wvalid;\n  assign int_bdone_wire = ~int_bvalid_reg | s_axi_bready;\n\n  assign int_wdata_wire = int_wready_reg ? s_axi_wdata : int_wdata_reg;\n\n  always @*\n  begin\n    int_awready_next = ~int_awdone_wire | (int_wdone_wire & int_bdone_wire);\n    int_wdata_next = int_wdata_reg;\n    int_wready_next = ~int_wdone_wire | (int_awdone_wire & int_bdone_wire);\n    int_bvalid_next = ~int_bdone_wire | (int_awdone_wire & int_wdone_wire);\n\n    if(int_wready_reg)\n    begin\n      int_wdata_next = s_axi_wdata;\n    end\n  end\n\n  assign s_axi_awready = int_awready_reg;\n  assign s_axi_wready = int_wready_reg;\n  assign s_axi_bresp = 2'd0;\n  assign s_axi_bvalid = int_bvalid_reg;\n  assign s_axi_arready = 1'b0;\n  assign s_axi_rdata = {(AXI_DATA_WIDTH){1'b0}};\n  assign s_axi_rresp = 2'd0;\n  assign s_axi_rvalid = 1'b0;\n\n  assign m_axis_tdata = int_wdata_wire;\n  assign m_axis_tvalid = int_awdone_wire & int_wdone_wire & int_bdone_wire;\n\nendmodule\n",
        "module_name": "axi_axis_writer #",
        "module_hash": "5cda3e2d907f2b027afbf8a9c7c4977d",
        "dataset_index": 24631
      },
      "adder_32bit_704aa826": {
        "rtl_code": "module adder_32bit (\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    wire [31:0] carry;\n    wire [31:0] temp_sum;\n    wire [31:0] temp_carry;\n    \n    assign temp_carry[0] = a[0] & b[0];\n    assign temp_sum[0] = a[0] ^ b[0];\n    \n    generate\n        genvar i;\n        for (i = 1; i < 32; i = i + 1) begin : generate_loop\n            assign temp_carry[i] = (a[i] & b[i]) | (a[i] & temp_sum[i-1]) | (b[i] & temp_sum[i-1]);\n            assign temp_sum[i] = a[i] ^ b[i] ^ temp_sum[i-1];\n        end\n    endgenerate\n    \n    assign carry = temp_carry[31];\n    assign sum = {temp_sum[31], temp_sum[30:0]} + (carry ? 1 : 0);\n    \nendmodule\nmodule bitwise_logic_3bit (\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or,\n    output out_logical_or,\n    output [5:0] out_not\n);\n    assign out_or = a | b;\n    assign out_logical_or = (a != 3'b000) || (b != 3'b000);\n    assign out_not = {~b, ~a};\nendmodule\nmodule top_module (\n    input [31:0] a,\n    input [31:0] b,\n    input [2:0] in_bitwise_a,\n    input [2:0] in_bitwise_b,\n    output [31:0] final_output,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    wire [31:0] adder_output;\n    wire [2:0] bitwise_output_or;\n    wire bitwise_output_logical_or;\n    wire [5:0] bitwise_output_not;\n    \n    adder_32bit adder_inst (\n        .a(a),\n        .b(b),\n        .sum(adder_output)\n    );\n    \n    bitwise_logic_3bit bitwise_inst (\n        .a(in_bitwise_a),\n        .b(in_bitwise_b),\n        .out_or(bitwise_output_or),\n        .out_logical_or(bitwise_output_logical_or),\n        .out_not(bitwise_output_not)\n    );\n    \n    assign final_output = adder_output + {bitwise_output_not[5:3], bitwise_output_not[2:0], bitwise_output_not[5:3], bitwise_output_not[2:0]} + {bitwise_output_or[2], bitwise_output_or[1], bitwise_output_or[0], 3'b000};\n    assign out_or_bitwise = bitwise_output_or;\n    assign out_or_logical = bitwise_output_logical_or;\n    assign out_not = bitwise_output_not;\n    \nendmodule\n",
        "module_name": "adder_32bit",
        "module_hash": "704aa82635d90115b4fc819f4e06f00c",
        "dataset_index": 11414
      },
      "e0_cdfb3126": {
        "rtl_code": "\n\nmodule e0 (x, y);\n\n\tinput [31:0] x;\n\toutput [31:0] y;\n\n\tassign y = {x[1:0],x[31:2]} ^ {x[12:0],x[31:13]} ^ {x[21:0],x[31:22]};\n\nendmodule\n\n\nmodule e1 (x, y);\n\n\tinput [31:0] x;\n\toutput [31:0] y;\n\n\tassign y = {x[5:0],x[31:6]} ^ {x[10:0],x[31:11]} ^ {x[24:0],x[31:25]};\n\nendmodule\n\n\nmodule ch (x, y, z, o);\n\n\tinput [31:0] x, y, z;\n\toutput [31:0] o;\n\n\tassign o = z ^ (x & (y ^ z));\n\nendmodule\n\n\nmodule maj (x, y, z, o);\n\n\tinput [31:0] x, y, z;\n\toutput [31:0] o;\n\n\tassign o = (x & y) | (z & (x | y));\n\nendmodule\n\n\nmodule s0 (x, y);\n\n\tinput [31:0] x;\n\toutput [31:0] y;\n\n\tassign y[31:29] = x[6:4] ^ x[17:15];\n\tassign y[28:0] = {x[3:0], x[31:7]} ^ {x[14:0],x[31:18]} ^ x[31:3];\n\nendmodule\n\n\nmodule s1 (x, y);\n\n\tinput [31:0] x;\n\toutput [31:0] y;\n\n\tassign y[31:22] = x[16:7] ^ x[18:9];\n\tassign y[21:0] = {x[6:0],x[31:17]} ^ {x[8:0],x[31:19]} ^ x[31:10];\n\nendmodule\n",
        "module_name": "e0",
        "module_hash": "cdfb31262b07ae8b4897efd20cb97572",
        "dataset_index": 25559
      },
      "clock_gen_aabc9924": {
        "rtl_code": "\nmodule clock_gen (\n    inclk0,\n    c0,\n    c1\n);\n\n    input    inclk0;\n    output   c0;\n    output   c1;\n\n    reg    [1:0]    counter;\n\n    assign  c0 = (counter == 2'b00);\n    assign  c1 = (counter == 2'b01);\n\n    always @(posedge inclk0) begin\n        counter <= counter + 1;\n        if (counter == 2'b10)\n            counter <= 2'b00;\n    end\n\nendmodule\n",
        "module_name": "clock_gen",
        "module_hash": "aabc9924d4247cbea88445feb6a35c22",
        "dataset_index": 15303
      },
      "binary_counter_a1b72500": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "a1b72500913c311c9297c011cc99076a",
        "dataset_index": 11351
      },
      "sky130_fd_sc_hdll__o221a_98bee4d8": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__o221a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , B2, B1              );\n    or  or1  (or1_out   , A2, A1              );\n    and and0 (and0_out_X, or0_out, or1_out, C1);\n    buf buf0 (X         , and0_out_X          );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__o221a",
        "module_hash": "98bee4d84d5f818ed0f60a880a3f8752",
        "dataset_index": 23050
      },
      "sky130_fd_sc_lp__inputiso1p_e251b987": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__inputiso1p (\n    X    ,\n    A    ,\n    SLEEP\n);\n\n    output X    ;\n    input  A    ;\n    input  SLEEP;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__inputiso1p",
        "module_hash": "e251b9871f76f437506da8039069b190",
        "dataset_index": 11599
      },
      "section2_schematic_b979c2d1": {
        "rtl_code": "\nmodule section2_schematic (n63, Z_B, n62, Len_int, Ren_int);\n    input n63;\n    input Z_B;\n    input n62;\n    output Len_int;\n    output Ren_int;\n\n    wire N_1;\n    wire N_3;\n    wire Ldir_int;\n    wire Rdir_int;\n    wire N_8;\n    wire N_4;\n\n    // Declare gates\n    and (N_1, n63, Z_B);\n    and (N_3, Z_B, n62);\n    and (N_4, Ldir_int, N_8, Rdir_int);\n    or (Len_int, N_1, N_4);\n    or (Ren_int, N_4, N_3);\n    not (Rdir_int, n62);\n    not (Ldir_int, n63);\n    not (N_8, Z_B);\n\nendmodule\n",
        "module_name": "section2_schematic",
        "module_hash": "b979c2d1edb8a0906ae5fe3283a85154",
        "dataset_index": 15461
      },
      "and4_9effaa4f": {
        "rtl_code": "module and4(\n    input A,\n    input B,\n    input C,\n    input D,\n    output X\n);\n\n    wire w1, w2, w3;\n\n    and and1(\n        w1,\n        A,\n        B\n    );\n\n    and and2(\n        w2,\n        w1,\n        1'b1\n    );\n\n    and and3(\n        w3,\n        w2,\n        1'b1\n    );\n\n    and and4(\n        X,\n        w3,\n        1'b1\n    );\n\nendmodule",
        "module_name": "and4",
        "module_hash": "9effaa4f09c4542b544743970ae92088",
        "dataset_index": 6375
      },
      "deserializer_23e6fb05": {
        "rtl_code": "module deserializer(\n\tclk, \t\tenable, \treset, \t\tframesize, \tin, \t\tout, \t\tcomplete\t);\n\n\tparameter BITS = 32;\t\tparameter BITS_COUNTER = 8;\tinput clk, enable, reset, in;\n\tinput [BITS_COUNTER-1:0] framesize;\n\n\toutput reg complete;\n\toutput reg [BITS-1:0] out;\n\treg [BITS_COUNTER-1:0] counter;\talways@(posedge clk) begin\n\n\tif (reset==1'b1) begin\n\t\tout <= 32'b00000000000000000000000000000000;\n\t\tcounter <= 8'b00000000;\nend\n\telse  begin\n\t\tif(enable) begin\n\t   if (complete==1'b0) begin\n\n\n\t\t\t\tout[counter] <= in;\n\t\t\t\tcounter  <= counter + 1;\tend\n\t\t\tend\n\t\t\tend\nend\n\nalways @ ( * ) begin\n\tif (counter==framesize) begin\n\t\tcomplete=1'b1;\n\t\tend\n\t\telse begin\ncomplete=1'b0;\n\t\tend\nend\n\n\n\tendmodule\n",
        "module_name": "deserializer",
        "module_hash": "23e6fb05d62483c37258c417b3d71cd1",
        "dataset_index": 22254
      },
      "reg_8bit_4daa301e": {
        "rtl_code": "module reg_8bit(\n\tclk,\n\tLoad,\n\tnot_reset,\n\tD,\n\tQ\n);\n\n\ninput wire\tclk;\ninput wire\tnot_reset;\ninput wire\tLoad;\ninput wire\t[7:0] D;\noutput wire\t[7:0] Q;\n\nreg\t[7:0] Q_ALTERA_SYNTHESIZED;\n\n\n\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[7] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[7] <= D[7];\n\tend\nend\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[6] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[6] <= D[6];\n\tend\nend\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[5] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[5] <= D[5];\n\tend\nend\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[4] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[4] <= D[4];\n\tend\nend\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[3] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[3] <= D[3];\n\tend\nend\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[2] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[2] <= D[2];\n\tend\nend\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[1] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[1] <= D[1];\n\tend\nend\n\n\nalways@(posedge clk or negedge not_reset)\nbegin\nif (!not_reset)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[0] <= 0;\n\tend\nelse\nif (Load)\n\tbegin\n\tQ_ALTERA_SYNTHESIZED[0] <= D[0];\n\tend\nend\n\nassign\tQ = Q_ALTERA_SYNTHESIZED;\n\nendmodule\n",
        "module_name": "reg_8bit",
        "module_hash": "4daa301e58a4765f49ed9b08f9ec6f47",
        "dataset_index": 1014
      },
      "up_counter_d4eebeaf": {
        "rtl_code": "\nmodule up_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  reg [3:0] next_count;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end\n    else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "d4eebeaf7ca44d8e077cada12db73e92",
        "dataset_index": 9866
      },
      "shift_register_f75dee30": {
        "rtl_code": "module shift_register (\n    input clk,\n    input load,\n    input [3:0] data_in,\n    input shift_in,\n    output [3:0] data_out,\n    output shift_out\n);\n\nreg [3:0] register;\n\nalways @(posedge clk) begin\n    if (load) begin\n        register <= data_in;\n    end else begin\n        register <= {shift_in, register[3:1]};\n    end\nend\n\nassign data_out = register;\nassign shift_out = register[3];\n\nendmodule",
        "module_name": "shift_register",
        "module_hash": "f75dee30cc74c61bfcfcc96262787bab",
        "dataset_index": 19940
      },
      "sky130_fd_sc_ms__a31o_2ba93d42": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ms__a31o (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A3, A1, A2     );\n    or  or0  (or0_out_X, and0_out, B1   );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ms__a31o",
        "module_hash": "2ba93d425434d37e4902223d7d4ee29d",
        "dataset_index": 12358
      },
      "top_module_d723074d": {
        "rtl_code": "module top_module(\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input A, B, SEL, DATA,\n    output Y,\n    output reg [3:0] Q);\n\n    reg [3:0] shift_reg;\n    wire mux_out;\n\n    // 2:1 multiplexer\n    assign mux_out = SEL ? DATA : (A & ~B) | (B & ~A);\n\n    // 4-bit shift register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            Q <= 4'b0;\n            shift_reg <= 4'b0;\n        end else if (ena) begin\n            if (load) begin\n                Q <= DATA;\n                shift_reg <= DATA;\n            end else begin\n                Q <= shift_reg;\n                shift_reg <= {shift_reg[2:0], Q};\n            end\n        end\n    end\n\n    assign Y = mux_out;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "d723074d702bf1afb0a535a0d1785610",
        "dataset_index": 133
      },
      "Problem3_bbb1dc17": {
        "rtl_code": "\nmodule Problem3(\n    input [2:0] OpCode,\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Final,\n    output reg Status\n    );\n\nalways @ (A or B or OpCode)\n\nbegin\n\tStatus = 0;\n\tcase (OpCode)\n\t\t3'b000:\tbegin\n\t\t\t\tFinal = ~A;\n\t\t\t\tend\n\t\t3'b001:\tbegin\n\t\t\t\tFinal = ~(A&B);\n\t\t\t\tend\n\t\t3'b010:\tbegin\n\t\t\t\tFinal = ~(A|B);\n\t\t\t\tend\n\t\t3'b011: begin\n\t\t\t\tFinal = A ^ B;\n\t\t\t\tend\n\t\t3'b100:\tbegin\n\t\t\t\tFinal = A + B;\n\t\t\t\tif  (A[3] == B[3] && Final[3] != B[3])\n                    Status = 1;\n\t\t\t\tend\n\t\t3'b101:\tbegin\n\t\t\t\tFinal = A - B;\n\t\t\t\tif (A[3] == (B[3] ^ 1) && Final[3] != A[3])\n\t\t\t\t\tStatus = 1;\n\t\t\t\tend\n\t\t3'b110:\tbegin\n\t\t\t\tFinal = B + 4'b0001;\n\t\t\t\tif (0 == B[3] && Final[3] != B[3])\n\t\t\t\t\tStatus = 1;\t\t\t\t\n\t\t\t\tend\n\t\t3'b111:\tbegin\n\t\t\t\tFinal = B - 4'b0001;\n\t\t\t\tif (1 == B[3] && Final[3] != 1 )\n\t\t\t\t\tStatus = 1;\n\t\t\t\tend\n\tendcase\t\n\t\t\n\t\t\nend\nendmodule\n",
        "module_name": "Problem3",
        "module_hash": "bbb1dc171bf52ca5604652f6ea995c43",
        "dataset_index": 10499
      },
      "barrel_shifter_16bit_a9f12a98": {
        "rtl_code": "\nmodule barrel_shifter_16bit (\n    input [15:0] data,\n    input [3:0] shift_amount,\n    output [15:0] shifted_data\n);\n\nreg [15:0] stage1_data;\nreg [15:0] stage2_data;\nreg [15:0] stage3_data;\nreg [15:0] stage4_data;\n\n\n\nalways @(data, shift_amount) begin\n    stage1_data = data;\n    stage2_data = stage1_data >> {2'b00, shift_amount[1:0]};\n    stage3_data = stage2_data >> {shift_amount[3:2], 2'b00};\n    stage4_data = stage3_data >> {shift_amount[3:2], 2'b00};\nend\n\nassign shifted_data = {stage4_data[7:0], stage4_data[15:8]};\n\nendmodule\n",
        "module_name": "barrel_shifter_16bit",
        "module_hash": "a9f12a98623ed60ee0e8b93622f2356c",
        "dataset_index": 2899
      },
      "dual_edge_ff_04cd49a2": {
        "rtl_code": "module dual_edge_ff (\n    input clk,\n    input d,\n    output reg q\n);\n\nreg q1, q2;\n\nalways @ (posedge clk) begin\n    q1 <= d;\nend\n\nalways @ (negedge clk) begin\n    q2 <= q1;\nend\n\nalways @ (posedge clk) begin\n    q <= q2;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\ndual_edge_ff ff (\n    .clk(clk),\n    .d(d),\n    .q(q)\n);\n\nendmodule",
        "module_name": "dual_edge_ff",
        "module_hash": "04cd49a269126cbcab5385f618bcba63",
        "dataset_index": 12682
      },
      "binary_to_gray_98e1e793": {
        "rtl_code": "module binary_to_gray(\n  input [3:0] A,\n  output [3:0] G\n);\n\n  assign G[0] = A[0];\n  assign G[1] = A[0] ^ A[1];\n  assign G[2] = A[1] ^ A[2];\n  assign G[3] = A[2] ^ A[3];\n\nendmodule",
        "module_name": "binary_to_gray",
        "module_hash": "98e1e7933ec5753b58d76e10f5d8360c",
        "dataset_index": 16429
      },
      "up_down_counter_b3b3de05": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input reset,\n    input enable,\n    input direction,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0;\n        end\n        else if (enable) begin\n            if (direction) begin\n                count <= count + 1;\n            end\n            else begin\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "b3b3de05988b53e8b9f332565942e164",
        "dataset_index": 15388
      },
      "fifo_memory_generator_21889be5": {
        "rtl_code": "module fifo_memory_generator (\n  output reg [93:0] dout,\n  input clk,\n  input wr_en,\n  input rd_en,\n  input [93:0] din\n);\n\n  // Define constants\n  parameter WIDTH = 94; // Data width\n  parameter DEPTH = 64; // Depth of FIFO\n  parameter ADDR_WIDTH = $clog2(DEPTH); // Address width\n  parameter MEM_WIDTH = WIDTH + ADDR_WIDTH; // Width of memory\n  parameter MEM_DEPTH = DEPTH + 1; // Depth of memory\n\n  // Define signals\n  reg [MEM_WIDTH-1:0] memory [0:MEM_DEPTH-1]; // Memory\n  reg [ADDR_WIDTH-1:0] wr_ptr = 0; // Write pointer\n  reg [ADDR_WIDTH-1:0] rd_ptr = 0; // Read pointer\n  reg [ADDR_WIDTH-1:0] next_wr_ptr = 0; // Next write pointer\n  reg [ADDR_WIDTH-1:0] next_rd_ptr = 0; // Next read pointer\n  wire [MEM_WIDTH-1:0] rd_data = memory[rd_ptr]; // Data read from memory\n\n  // Write logic\n  always @ (posedge clk) begin\n    if (wr_en) begin\n      memory[wr_ptr] <= {din, wr_ptr}; // Write data to memory\n      next_wr_ptr <= wr_ptr + 1; // Update next write pointer\n    end\n  end\n\n  // Read logic\n  always @ (posedge clk) begin\n    if (rd_en) begin\n      dout <= rd_data[WIDTH-1:0]; // Output data\n      next_rd_ptr <= rd_ptr + 1; // Update next read pointer\n    end\n  end\n\n  // Update pointers\n  always @ (posedge clk) begin\n    wr_ptr <= next_wr_ptr;\n    rd_ptr <= next_rd_ptr;\n  end\n\nendmodule",
        "module_name": "fifo_memory_generator",
        "module_hash": "21889be5c7082ea99b8273167ba8c2fc",
        "dataset_index": 4992
      },
      "accu_cc3847d7": {
        "rtl_code": "module accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n \n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [9:0]   data_out\n);\n\nreg [7:0] data_reg;\nreg [3:0] count_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'b0;\n        count_reg <= 4'b0;\n        valid_b <= 1'b0;\n        data_out <= 10'b0;\n    end else begin\n        if (valid_a && ready_b) begin\n            data_reg <= data_reg + data_in;\n            count_reg <= count_reg + 1;\n            if (count_reg == 4'b1000) begin\n                valid_b <= 1'b1;\n                data_out <= {2'b0, data_reg};\n                count_reg <= 4'b0;\n            end\n        end\n    end\nend\n\nassign ready_a = ~valid_b;\n\nendmodule",
        "module_name": "accu",
        "module_hash": "cc3847d727e1f9520eb6f21e5d57b8b8",
        "dataset_index": 10308
      },
      "axi_dwidth_converter_v2_1_8_axi4lite_upsizer #_037ebc13": {
        "rtl_code": "\n\n \nmodule axi_dwidth_converter_v2_1_8_axi4lite_upsizer #\n  (\n   parameter         C_FAMILY                         = \"none\", \n                       parameter integer C_AXI_ADDR_WIDTH                 = 32, \n                       parameter integer C_AXI_SUPPORTS_WRITE             = 1,\n   parameter integer C_AXI_SUPPORTS_READ              = 1\n   )\n  (\n   input  wire                              aresetn,\n   input  wire                              aclk,\n\n   input  wire [C_AXI_ADDR_WIDTH-1:0]       s_axi_awaddr,\n   input  wire [3-1:0]                      s_axi_awprot,\n   input  wire                              s_axi_awvalid,\n   output wire                              s_axi_awready,\n   input  wire [32-1:0]                     s_axi_wdata,\n   input  wire [32/8-1:0]                   s_axi_wstrb,\n   input  wire                              s_axi_wvalid,\n   output wire                              s_axi_wready,\n   output wire [2-1:0]                      s_axi_bresp,\n   output wire                              s_axi_bvalid,\n   input  wire                              s_axi_bready,\n   input  wire [C_AXI_ADDR_WIDTH-1:0]       s_axi_araddr,\n   input  wire [3-1:0]                      s_axi_arprot,\n   input  wire                              s_axi_arvalid,\n   output wire                              s_axi_arready,\n   output wire [32-1:0]                     s_axi_rdata,\n   output wire [2-1:0]                      s_axi_rresp,\n   output wire                              s_axi_rvalid,\n   input  wire                              s_axi_rready,\n\n   output wire [C_AXI_ADDR_WIDTH-1:0]       m_axi_awaddr,\n   output wire [3-1:0]                      m_axi_awprot,\n   output wire                              m_axi_awvalid,\n   input  wire                              m_axi_awready,\n   output wire [64-1:0]                     m_axi_wdata,\n   output wire [64/8-1:0]                   m_axi_wstrb,\n   output wire                              m_axi_wvalid,\n   input  wire                              m_axi_wready,\n   input  wire [2-1:0]                      m_axi_bresp,\n   input  wire                              m_axi_bvalid,\n   output wire                              m_axi_bready,\n   output wire [C_AXI_ADDR_WIDTH-1:0]       m_axi_araddr,\n   output wire [3-1:0]                      m_axi_arprot,\n   output wire                              m_axi_arvalid,\n   input  wire                              m_axi_arready,\n   input  wire [64-1:0]                     m_axi_rdata,\n   input  wire [2-1:0]                      m_axi_rresp,\n   input  wire                              m_axi_rvalid,\n   output wire                              m_axi_rready\n   );\n\n  reg                                       s_axi_arready_i ;\n  reg                                       m_axi_arvalid_i ;\n  reg                                       m_axi_rready_i ;\n  reg                                       s_axi_rvalid_i ;\n  reg                                       ar_done         ;\n  reg                                       araddr2         ;\n  reg                                       s_axi_awready_i ;\n  reg                                       s_axi_bvalid_i  ;\n  reg                                       m_axi_awvalid_i ;\n  reg                                       m_axi_wvalid_i  ;\n  reg                                       m_axi_bready_i  ;\n  reg                                       aw_done         ;\n  reg                                       w_done          ;\n  \n  generate\n  if (C_AXI_SUPPORTS_READ != 0) begin : gen_read\n    always @(posedge aclk) begin\n      if (~aresetn) begin\n        s_axi_arready_i <= 1'b0 ;\n        m_axi_arvalid_i <= 1'b0 ;\n        s_axi_rvalid_i <= 1'b0;\n        m_axi_rready_i <= 1'b1;\n        ar_done         <= 1'b0 ;\n        araddr2         <= 1'b0 ;\n      end else begin\n        s_axi_arready_i <= 1'b0 ; m_axi_rready_i <= 1'b0; if (s_axi_rvalid_i) begin\n          if (s_axi_rready) begin\n            s_axi_rvalid_i <= 1'b0;\n            m_axi_rready_i <= 1'b1; ar_done <= 1'b0;\n          end\n        end else if (m_axi_rvalid & ar_done) begin\n          s_axi_rvalid_i <= 1'b1;\n        end else if (m_axi_arvalid_i) begin\n          if (m_axi_arready) begin\n            m_axi_arvalid_i <= 1'b0;\n            s_axi_arready_i <= 1'b1 ; araddr2 <= s_axi_araddr[2];\n            ar_done <= 1'b1;\n          end\n        end else if (s_axi_arvalid & ~ar_done) begin\n          m_axi_arvalid_i <= 1'b1;\n        end\n      end\n    end\n    assign m_axi_arvalid = m_axi_arvalid_i ;\n    assign s_axi_arready = s_axi_arready_i ;\n    assign m_axi_araddr = s_axi_araddr;\n    assign m_axi_arprot   = s_axi_arprot;\n    assign s_axi_rvalid  = s_axi_rvalid_i  ;\n    assign m_axi_rready  = m_axi_rready_i  ;\n    assign s_axi_rdata    = araddr2 ? m_axi_rdata[63:32] : m_axi_rdata[31:0];\n    assign s_axi_rresp    = m_axi_rresp;\n  end else begin : gen_noread\n    assign m_axi_arvalid = 1'b0 ;\n    assign s_axi_arready = 1'b0 ;\n    assign m_axi_araddr  = {C_AXI_ADDR_WIDTH{1'b0}} ;\n    assign m_axi_arprot  = 3'b0 ;\n    assign s_axi_rvalid  = 1'b0 ;\n    assign m_axi_rready  = 1'b0 ;\n    assign s_axi_rresp   = 2'b0 ;\n    assign s_axi_rdata   = 32'b0 ;\n  end\n  \n  if (C_AXI_SUPPORTS_WRITE != 0) begin : gen_write\n    always @(posedge aclk) begin\n      if (~aresetn) begin\n        m_axi_awvalid_i <= 1'b0 ;\n        s_axi_awready_i <= 1'b0 ;\n        m_axi_wvalid_i  <= 1'b0 ;\n        s_axi_bvalid_i  <= 1'b0 ;\n        m_axi_bready_i  <= 1'b0 ;\n        aw_done         <= 1'b0 ;\n        w_done          <= 1'b0 ;\n      end else begin\n        m_axi_bready_i <= 1'b0; if (s_axi_bvalid_i) begin\n          if (s_axi_bready) begin\n            s_axi_bvalid_i <= 1'b0;\n            m_axi_bready_i <= 1'b1; aw_done <= 1'b0;\n            w_done <= 1'b0;\n          end\n        end else if (s_axi_awready_i) begin\n          s_axi_awready_i <= 1'b0; s_axi_bvalid_i <= 1'b1;\n        end else if (aw_done & w_done) begin\n          if (m_axi_bvalid) begin\n            s_axi_awready_i <= 1'b1; end\n        end else begin\n          if (m_axi_awvalid_i) begin\n            if (m_axi_awready) begin\n              m_axi_awvalid_i <= 1'b0;\n              aw_done <= 1'b1;\n            end\n          end else if (s_axi_awvalid & ~aw_done) begin\n            m_axi_awvalid_i <= 1'b1;\n          end\n          if (m_axi_wvalid_i) begin\n            if (m_axi_wready) begin\n              m_axi_wvalid_i <= 1'b0;\n              w_done <= 1'b1;\n            end\n          end else if (s_axi_wvalid & (m_axi_awvalid_i | aw_done) & ~w_done) begin\n            m_axi_wvalid_i <= 1'b1;\n          end\n        end\n      end\n    end\n    assign m_axi_awvalid = m_axi_awvalid_i ;\n    assign s_axi_awready = s_axi_awready_i ;\n    assign m_axi_awaddr = s_axi_awaddr;\n    assign m_axi_awprot   = s_axi_awprot;\n    assign m_axi_wvalid  = m_axi_wvalid_i  ;\n    assign s_axi_wready  = s_axi_awready_i ;\n    assign m_axi_wdata    = {s_axi_wdata,s_axi_wdata};\n    assign m_axi_wstrb    = s_axi_awaddr[2] ? {s_axi_wstrb, 4'b0} : {4'b0, s_axi_wstrb};\n    assign s_axi_bvalid  = s_axi_bvalid_i  ;\n    assign m_axi_bready  = m_axi_bready_i  ;\n    assign s_axi_bresp    = m_axi_bresp;\n  end else begin : gen_nowrite\n    assign m_axi_awvalid = 1'b0 ;\n    assign s_axi_awready = 1'b0 ;\n    assign m_axi_awaddr  = {C_AXI_ADDR_WIDTH{1'b0}} ;\n    assign m_axi_awprot  = 3'b0 ;\n    assign m_axi_wvalid  = 1'b0 ;\n    assign s_axi_wready  = 1'b0 ;\n    assign m_axi_wdata   = 64'b0 ;\n    assign m_axi_wstrb   = 8'b0 ;\n    assign s_axi_bvalid  = 1'b0 ;\n    assign m_axi_bready  = 1'b0 ;\n    assign s_axi_bresp   = 2'b0 ;\n  end\n\n  endgenerate\nendmodule\n",
        "module_name": "axi_dwidth_converter_v2_1_8_axi4lite_upsizer #",
        "module_hash": "037ebc13b25b66d1af0cb454ade8db64",
        "dataset_index": 24801
      },
      "or3_648c8337": {
        "rtl_code": "module or3 (\n    input A,\n    input B,\n    input C,\n    output X,\n    input VPWR,\n    input VGND\n);\n\n    assign X = A | B | C;\n\nendmodule\n\nmodule three_input_module (\n    input input_a,\n    input input_b,\n    input input_c,\n    output output_x,\n    input vpwr,\n    input vgnd\n);\n\n    wire or1_output;\n    wire or2_output;\n    wire or3_output;\n    \n    // instantiate 3-input OR gates\n    or3 or1 (\n        .A(input_a),\n        .B(input_b),\n        .C(input_c),\n        .X(or1_output),\n        .VPWR(vpwr),\n        .VGND(vgnd)\n    );\n    \n    or3 or2 (\n        .A(input_a),\n        .B(input_b),\n        .C(or1_output),\n        .X(or2_output),\n        .VPWR(vpwr),\n        .VGND(vgnd)\n    );\n    \n    or3 or3 (\n        .A(or2_output),\n        .B(input_c),\n        .C(or1_output),\n        .X(or3_output),\n        .VPWR(vpwr),\n        .VGND(vgnd)\n    );\n    \n    // invert the output of the final OR gate to get the correct output\n    assign output_x = ~or3_output;\n    \nendmodule",
        "module_name": "or3",
        "module_hash": "648c8337eebacd504264587355c6bef9",
        "dataset_index": 6671
      },
      "glitch_filter_f5c84cbc": {
        "rtl_code": "module glitch_filter(\n    clk,\n    s_in,\n    s_out\n);\n    input clk;\n    input s_in;\n    output s_out;\n    \n    reg s_tmp;\n    reg [31:0]counter_low, counter_high;\n    \n    initial begin\n        counter_low <= 0;\n        counter_high <= 0;\n    end\n    \n    assign s_out = s_tmp;\n    \n    always @(posedge clk) begin\n        if(s_in == 1'b0) \n            counter_low <= counter_low + 1;\n        else \n            counter_low <= 0;\n    end\n    \n    always @(posedge clk) begin\n        if(s_in == 1'b1) \n            counter_high <= counter_high + 1;\n        else\n            counter_high <= 0;\n    end\n    \n    always @(posedge clk) begin\n        if (counter_low == 4) s_tmp <= 0;\n        else if (counter_high == 4) s_tmp <= 1;\n    end\n    \nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "f5c84cbcfbf59771ab09bc16c66bc4fa",
        "dataset_index": 12361
      }
    },
    "batch_6916506b29e081908f17aaf3dd27f886": {
      "async_ff_17fca062": {
        "rtl_code": "module async_ff (\n    input clk,\n    input rst,\n    input en,\n    input d,\n    output reg q\n);\n\n    reg q_d;\n\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            q_d <= 1'b0;\n        end else if (en) begin\n            q_d <= d;\n        end\n    end\n\n    always @ (posedge clk) begin\n        q <= q_d;\n    end\n\nendmodule",
        "module_name": "async_ff",
        "module_hash": "17fca062b491cb8e61b10d1058dcd60e",
        "dataset_index": 4796
      },
      "mag_comparator_ce95be00": {
        "rtl_code": "module mag_comparator (\n  input [2:0] A,\n  input [2:0] B,\n  output reg [1:0] result\n);\n\n  always @(*) begin\n    if (A == B) begin\n      result = 2'b00;\n    end else if (A > B) begin\n      result = 2'b01;\n    end else begin\n      result = 2'b10;\n    end\n  end\n\nendmodule\n",
        "module_name": "mag_comparator",
        "module_hash": "ce95be00e25fc49dba2cf24750356a6e",
        "dataset_index": 598
      },
      "ad_xcvr_rx_if_00f2e4a5": {
        "rtl_code": "\n\nmodule ad_xcvr_rx_if (\n\n  input                   rx_clk,\n  input       [ 3:0]      rx_ip_sof,\n  input       [31:0]      rx_ip_data,\n  output  reg             rx_sof,\n  output  reg [31:0]      rx_data);\n\n\n  reg     [31:0]  rx_ip_data_d = 'd0;\n  reg     [ 3:0]  rx_ip_sof_hold = 'd0;\n  reg     [ 3:0]  rx_ip_sof_d = 'd0;\n\n  always @(posedge rx_clk) begin\n    rx_ip_data_d <= rx_ip_data;\n    rx_ip_sof_d <= rx_ip_sof;\n    if (rx_ip_sof != 4'h0) begin\n      rx_ip_sof_hold <= rx_ip_sof;\n    end\n    rx_sof <= |rx_ip_sof_d;\n    if (rx_ip_sof_hold[0] == 1'b1) begin\n      rx_data <= rx_ip_data;\n    end else if (rx_ip_sof_hold[1] == 1'b1) begin\n      rx_data <= {rx_ip_data[ 7:0], rx_ip_data_d[31: 8]};\n    end else if (rx_ip_sof_hold[2] == 1'b1) begin\n      rx_data <= {rx_ip_data[15:0], rx_ip_data_d[31:16]};\n    end else if (rx_ip_sof_hold[3] == 1'b1) begin\n      rx_data <= {rx_ip_data[23:0], rx_ip_data_d[31:24]};\n    end else begin\n      rx_data <= 32'd0;\n    end\n  end\n\nendmodule\n\n",
        "module_name": "ad_xcvr_rx_if",
        "module_hash": "00f2e4a5c262a5eaf8facb37ab3ea601",
        "dataset_index": 21583
      },
      "top__06f89b58": {
        "rtl_code": "\nmodule top_module (\n    input  [15:0] A,\n    input  [15:0] B,\n    input         clk,\n    input         reset,\n    output reg [15:0] Y\n);\n\n    // Instantiate the comparator module\n    comparator_4bit comparator (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .GT(select)\n    );\n\n    // Instantiate the barrel shifter module\n    barrel_shifter_16bit shifter (\n        .A(select ? B : A),\n        .shift_amount(select ? B[11:8] : A[11:8]),\n        .Y(shifted_data)\n    );\n\n    // Instantiate the priority encoder module\n    priority_encoder_4bit encoder (\n        .A(select ? B[3:0] : A[3:0]),\n        .Y(shift_amount)\n    );\n\n    // Output the shifted data\n    always @ (posedge clk) begin\n        if (reset) begin\n            Y <= 16'b0;\n        end else begin\n            Y <= shifted_data;\n        end\n    end\n\n    // Internal signals\n    wire [15:0] shifted_data;\n    wire [1:0] shift_amount;\n    wire select;\n\nendmodule\nmodule comparator_4bit (\n    input  [3:0] A,\n    input  [3:0] B,\n    output reg GT\n);\n\n    always @ (*) begin\n        if (A > B) begin\n            GT = 1;\n        end else begin\n            GT = 0;\n        end\n    end\n\nendmodule\nmodule barrel_shifter_16bit (\n    input  [15:0] A,\n    input  [3:0] shift_amount,\n    output reg [15:0] Y\n);\n\n    always @ (*) begin\n        case (shift_amount)\n            4'b0000: Y = A;\n            4'b0001: Y = {A[14], A[15:1]};\n            4'b0010: Y = {A[13], A[15:2]};\n            4'b0011: Y = {A[12], A[15:3]};\n            4'b0100: Y = {A[11], A[15:4]};\n            4'b0101: Y = {A[10], A[15:5]};\n            4'b0110: Y = {A[9], A[15:6]};\n            4'b0111: Y = {A[8], A[15:7]};\n            4'b1000: Y = {A[7], A[15:8]};\n            4'b1001: Y = {A[6], A[15:9]};\n            4'b1010: Y = {A[5], A[15:10]};\n            4'b1011: Y = {A[4], A[15:11]};\n            4'b1100: Y = {A[3], A[15:12]};\n            4'b1101: Y = {A[2], A[15:13]};\n            4'b1110: Y = {A[1], A[15:14]};\n            4'b1111: Y = {A[0], A[15:15]};\n            default: Y = A;\n        endcase\n    end\n\nendmodule\nmodule priority_encoder_4bit (\n    input  [3:0] A,\n    output reg [1:0] Y\n);\n\n    always @ (*) begin\n        casex (A)\n            4'b0001: Y = 2'b00;\n            4'b0010: Y = 2'b01;\n            4'b0100: Y = 2'b10;\n            4'b1000: Y = 2'b11;\n            default: Y = 2'b00;\n        endcase\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "06f89b5871d9621831d8f33998506dba",
        "dataset_index": 13768
      },
      "top__61dcd710": {
        "rtl_code": "\nmodule top_module ( \n    input clk, // Clock signal\n    input reset, // Active high synchronous reset\n    input [7:0] a, // 8-bit input a \n    input [7:0] b, // 8-bit input b\n    output reg [15:0] sum // 16-bit output sum\n);\n\n    reg [7:0] fa_out1; // Output of first full adder\n    reg [7:0] carry; // Carry output from full adders\n\n    full_adder fa1(.a(a[0]), .b(b[0]), .cin(1'b0), .sum(fa_out1[0]), .cout(carry[0])); // First full adder\n    full_adder fa2(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(fa_out1[1]), .cout(carry[1])); // Second full adder\n    full_adder fa3(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(fa_out1[2]), .cout(carry[2])); // Third full adder\n    full_adder fa4(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(fa_out1[3]), .cout(carry[3])); // Fourth full adder\n    full_adder fa5(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(fa_out1[4]), .cout(carry[4])); // Fifth full adder\n    full_adder fa6(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(fa_out1[5]), .cout(carry[5])); // Sixth full adder\n    full_adder fa7(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(fa_out1[6]), .cout(carry[6])); // Seventh full adder\n    full_adder fa8(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(fa_out1[7]), .cout(carry[7])); // Eighth full adder\n\n    always @(posedge clk) begin\n        if(reset) begin\n            sum <= 16'b0; // Reset sum to 0\n        end else begin\n            sum <= {carry[7], fa_out1}; // Concatenate carry and output of first full adder\n        end\n    end\n\nendmodule\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output reg sum,\n    output reg cout\n);\n\n    always @(*) begin\n        sum = a ^ b ^ cin; // Calculate sum\n        cout = (a & b) | (a & cin) | (b & cin); // Calculate carry\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "61dcd7107148e8c7632d3f7e07ab54ee",
        "dataset_index": 4057
      },
      "resettable_register_627ca009": {
        "rtl_code": "module resettable_register (\n    input clk, reset, set, clear,\n    input data_in,\n    output reg data_out\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out <= 0;\n    end else if (set) begin\n        data_out <= 1;\n    end else if (clear) begin\n        data_out <= 0;\n    end else begin\n        data_out <= data_out;\n    end\nend\n\nendmodule",
        "module_name": "resettable_register",
        "module_hash": "627ca0094b11e94a71fa7d454acd4832",
        "dataset_index": 15934
      },
      "axi_slave_impl #_49e0e2bc": {
        "rtl_code": "`define REGISTER_READ_OPERATION 1\n`define REGISTER_WRITE_OPERATION 2\n\n\n    module axi_slave_impl #\n    (\n        parameter integer NUMBER_OF_REGISTERS = 16,\n        parameter integer C_S_AXI_DATA_WIDTH = 32,\n        parameter integer C_S_AXI_ADDR_WIDTH = 10\n    )\n    (\n        input wire [1:0] register_operation,      input wire [7 : 0] register_number,\n\t\tinput wire [C_S_AXI_DATA_WIDTH -1 : 0] register_write,\n\t\toutput reg [C_S_AXI_DATA_WIDTH -1 : 0] register_read,\n        input wire S_AXI_ACLK,\n        input wire S_AXI_ARESETN,\n        input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,\n        input wire [2 : 0] S_AXI_AWPROT,\n        input wire  S_AXI_AWVALID,\n        output wire  S_AXI_AWREADY,\n        input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,\n        input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,\n        input wire  S_AXI_WVALID,\n        output wire  S_AXI_WREADY,\n        output wire [1 : 0] S_AXI_BRESP,\n        output wire  S_AXI_BVALID,\n        input wire  S_AXI_BREADY,\n        input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,\n        input wire [2 : 0] S_AXI_ARPROT,\n        input wire  S_AXI_ARVALID,\n        output wire  S_AXI_ARREADY,\n        output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,\n        output wire [1 : 0] S_AXI_RRESP,\n        output wire  S_AXI_RVALID,\n        input wire  S_AXI_RREADY\n    );\n\n     reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr;\n    reg axi_awready;\n    reg axi_wready;\n     reg [1 : 0] axi_bresp;\n    reg axi_bvalid;\n     reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr;\n    reg axi_arready;\n    reg [C_S_AXI_DATA_WIDTH-1 : 0] axi_rdata;\n     reg [1 : 0] axi_rresp;\n    reg axi_rvalid;\n\n    localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;\n    localparam integer OPT_MEM_ADDR_BITS =  C_S_AXI_ADDR_WIDTH - ADDR_LSB - 1;\n    reg register_operation_done;\n    reg [C_S_AXI_DATA_WIDTH-1:0] registers[NUMBER_OF_REGISTERS - 1 : 0];\n    wire slv_reg_rden;\n    wire slv_reg_wren;\n    reg [C_S_AXI_DATA_WIDTH-1:0] reg_data_out;\n    integer byte_index;\n    integer register_index;\n    assign S_AXI_AWREADY = axi_awready;\n    assign S_AXI_WREADY = axi_wready;\n    assign S_AXI_BRESP = axi_bresp;\n    assign S_AXI_BVALID = axi_bvalid;\n    assign S_AXI_ARREADY = axi_arready;\n    assign S_AXI_RDATA = axi_rdata;\n    assign S_AXI_RRESP = axi_rresp;\n    assign S_AXI_RVALID = axi_rvalid;\n    \n    always @(posedge S_AXI_ACLK)\n    begin\n        if (S_AXI_ARESETN == 1'b0)\n        begin\n            axi_awready <= 1'b0;\n        end \n        else\n        begin    \n            if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n            begin\n                axi_awready <= 1'b1;\n            end\n            else           \n            begin\n                axi_awready <= 1'b0;\n            end\n        end \n    end       \n\n    always @(posedge S_AXI_ACLK)\n    begin\n        if (S_AXI_ARESETN == 1'b0)\n        begin\n            axi_awaddr <= 0;\n        end \n        else\n        begin    \n            if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n            begin\n                axi_awaddr <= S_AXI_AWADDR;\n            end\n        end \n    end       \n\n    always @(posedge S_AXI_ACLK)\n    begin\n        if (S_AXI_ARESETN == 1'b0)\n        begin\n            axi_wready <= 1'b0;\n        end \n        else\n        begin    \n            if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)\n            begin\n                axi_wready <= 1'b1;\n            end\n            else\n            begin\n                axi_wready <= 1'b0;\n            end\n        end \n    end       \n\n    assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;\n\n    always @(posedge S_AXI_ACLK)\n    begin\n        if (S_AXI_ARESETN == 1'b0)\n        begin\n            for (register_index = 0; register_index < NUMBER_OF_REGISTERS; register_index = register_index + 1)\n                registers[register_index] <= 0;\n        end \n        else \n        if (slv_reg_wren)\n        begin\n             for (byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH / 8) -1; byte_index = byte_index + 1)\n             begin\n                 if (S_AXI_WSTRB[byte_index] == 1) \n                     registers[axi_awaddr[ADDR_LSB + OPT_MEM_ADDR_BITS : ADDR_LSB]][(byte_index * 8) +: 8] <= S_AXI_WDATA[(byte_index * 8) +: 8];\n             end\n        end\n\t\telse\n\t\tbegin\n\t\t    if(register_operation == `REGISTER_WRITE_OPERATION && register_number > 0)\n\t\t    begin\n\t\t        registers[register_number - 1] <= register_write;\n\t\t    end\n\t\tend\n    end    \n\n    always @(posedge S_AXI_ACLK)\n    begin\n        if (S_AXI_ARESETN == 1'b0)\n        begin\n            axi_bvalid  <= 0;\n            axi_bresp   <= 2'b0;\n        end \n        else\n        begin    \n            if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)\n            begin\n                axi_bvalid <= 1'b1;\n                axi_bresp  <= 2'b0; end                   else\n            begin\n                if (S_AXI_BREADY && axi_bvalid) \n\t\t\t\tbegin\n                axi_bvalid <= 1'b0; \n                end  \n            end\n        end\n    end   \n\n    always @(posedge S_AXI_ACLK)\n    begin\n        if (S_AXI_ARESETN == 1'b0)\n        begin\n            axi_arready <= 1'b0;\n            axi_araddr  <= 32'b0;\n        end \n        else\n        begin    \n            if (~axi_arready && S_AXI_ARVALID)\n            begin\n                axi_arready <= 1'b1;\n                axi_araddr  <= S_AXI_ARADDR;\n            end\n            else\n            begin\n                axi_arready <= 1'b0;\n            end\n        end \n    end       \n\n    always @(posedge S_AXI_ACLK)\n    begin\n        if ( S_AXI_ARESETN == 1'b0 )\n        begin\n            axi_rvalid <= 0;\n            axi_rresp  <= 0;\n        end \n        else\n        begin    \n            if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)\n            begin\n                axi_rvalid <= 1'b1;\n                axi_rresp  <= 2'b0; end   \n            else if (axi_rvalid && S_AXI_RREADY)\n            begin\n                axi_rvalid <= 1'b0;\n            end                \n        end\n    end    \n\n    assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;\n    always @(*)\n    begin\n        if(axi_araddr[ADDR_LSB + OPT_MEM_ADDR_BITS : ADDR_LSB] < NUMBER_OF_REGISTERS)\n           reg_data_out <= registers[axi_araddr[ADDR_LSB + OPT_MEM_ADDR_BITS : ADDR_LSB]];\n        else reg_data_out <= 0;\n    end\n\n    always @(posedge S_AXI_ACLK)\n    begin\n        if (S_AXI_ARESETN == 1'b0)\n        begin\n            axi_rdata  <= 0;\n        end \n        else\n        begin    \n            if (slv_reg_rden)\n            begin\n                axi_rdata <= reg_data_out;     end   \n            else\n            begin\n                if(register_operation == `REGISTER_READ_OPERATION)\n                begin\n                    register_read <= registers[register_number - 1];\n                    end\n            end\n        end\n    end    \n\n    endmodule\n",
        "module_name": "axi_slave_impl #",
        "module_hash": "49e0e2bce0ed7a511dd726ed76a59f4f",
        "dataset_index": 18448
      },
      "adder_4bit_3afb890e": {
        "rtl_code": "module adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] S,\n    output reg Cout\n);\n\nreg [4:0] Sum;\n\nalways @* begin\n    Sum = {1'b0, A} + {1'b0, B} + Cin;\n    S = Sum[3:0];\n    Cout = Sum[4];\nend\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "3afb890e9de5ec5bfab0d5716321e5af",
        "dataset_index": 13056
      },
      "Divider #_51ce5bb7": {
        "rtl_code": "module Divider #(\n  parameter n = 8 // number of bits in the input and output signals\n)(\n  input [n-1:0] dividend,\n  input [n-1:0] divisor,\n  output [n-1:0] quotient,\n  output [n-1:0] remainder\n);\n\n\nreg [n-1:0] dividend_reg;\nreg [n-1:0] divisor_reg;\nreg [n-1:0] quotient_reg;\nreg [n-1:0] remainder_reg;\nreg signed [n-1:0] dividend_signed;\nreg signed [n-1:0] divisor_signed;\nreg signed [n-1:0] quotient_signed;\nreg signed [n-1:0] remainder_signed;\nreg [n:0] dividend_abs;\nreg [n:0] divisor_abs;\nreg [n:0] quotient_abs;\nreg [n:0] remainder_abs;\nreg [n:0] temp_abs;\n\nassign quotient = quotient_signed;\nassign remainder = remainder_signed;\n\nalways @(*) begin\n  dividend_reg = dividend;\n  divisor_reg = divisor;\n  dividend_signed = $signed(dividend_reg);\n  divisor_signed = $signed(divisor_reg);\n  dividend_abs = dividend_signed >= 0 ? dividend_signed : -dividend_signed;\n  divisor_abs = divisor_signed >= 0 ? divisor_signed : -divisor_signed;\n  quotient_signed = dividend_signed / divisor_signed;\n  remainder_signed = dividend_signed % divisor_signed;\n  quotient_abs = dividend_abs / divisor_abs;\n  remainder_abs = dividend_abs % divisor_abs;\n  temp_abs = remainder_abs << 1;\n  if (temp_abs >= divisor_abs) begin\n    quotient_abs = quotient_abs + 1;\n    remainder_abs = temp_abs - divisor_abs;\n  end\n  if (dividend_signed < 0 && divisor_signed > 0 || dividend_signed > 0 && divisor_signed < 0) begin\n    quotient_signed = -quotient_signed;\n    remainder_signed = -remainder_signed;\n  end\n  quotient_reg = quotient_abs;\n  remainder_reg = remainder_abs;\nend\n\nendmodule",
        "module_name": "Divider #",
        "module_hash": "51ce5bb7b347a2e34090dce168892c5d",
        "dataset_index": 16830
      },
      "top__31232bb3": {
        "rtl_code": "module top_module (\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    input d,\n    output [6:0] q\n);\n\n    // 4-bit shift register with asynchronous reset, synchronous load, and enable\n    reg [3:0] shift_reg;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            shift_reg <= 4'b0;\n        end else if (load & ena) begin\n            shift_reg <= data;\n        end else if (ena) begin\n            shift_reg <= {shift_reg[2:0], d};\n        end\n    end\n    \n    // 3-bit shift register using a single D flip-flop\n    reg [2:0] shift_reg_3;\n    always @(posedge clk) begin\n        shift_reg_3 <= {shift_reg_3[1:0], d};\n    end\n    \n    // Functional module that outputs the bitwise OR of the values of both shift registers\n    assign q = {shift_reg, shift_reg_3} | 3'b0;\n    \nendmodule",
        "module_name": "top_",
        "module_hash": "31232bb316886073807b14c0e6fd59a5",
        "dataset_index": 11602
      },
      "top_9796be87": {
        "rtl_code": "\nmodule top(\n    input  wire [3:0] di,\n    output wire       do\n);\n\n    wire [3:0] d;\n\n    not n0 (d[0], di[0]);\n    not n1 (d[1], di[1]);\n    not n2 (d[2], di[2]);\n    not n3 (d[3], di[3]);\n\n    assign do = ~((d[1] & d[0]) | (d[3] & d[2]));\n\nendmodule\n",
        "module_name": "top",
        "module_hash": "9796be87f6530fbdb9748259c542b6dc",
        "dataset_index": 4153
      },
      "fpadd_altpriority_encoder_6e8_e54b1895": {
        "rtl_code": "\nmodule fpadd_altpriority_encoder_6e8 (\n    input [3:0] data,\n    output [1:0] q,\n    output zero\n);\n\n    wire [0:0] wire_altpriority_encoder13_q;\n    wire wire_altpriority_encoder13_zero;\n    wire [1:0] q_temp;\n\n    // Instantiate one instance of fpadd_altpriority_encoder_3e8\n    fpadd_altpriority_encoder_3e8 altpriority_encoder13 (\n        .data({data[2], data[1:0]}),\n        .q(wire_altpriority_encoder13_q),\n        .zero(wire_altpriority_encoder13_zero)\n    );\n\n    // Assign the outputs of the instance to the output of the overall module\n    assign q_temp = wire_altpriority_encoder13_zero ? {1'b1, wire_altpriority_encoder13_q} : {1'b0, wire_altpriority_encoder13_q};\n    assign q = data[3:0] == 4'b0000 ? q_temp : 2'b11;\n    assign zero = (wire_altpriority_encoder13_zero) & (data[3:0] == 4'b0000);\n\nendmodule\nmodule fpadd_altpriority_encoder_3e8 (\n    input [2:0] data,\n    output [0:0] q,\n    output zero\n);\n\n    wire [1:0] wire_priority_encoder3_data;\n    wire [0:0] wire_priority_encoder3_q;\n    wire wire_priority_encoder3_zero;\n\n    // Instantiate one instance of fpadd_priority_encoder_2e8\n    fpadd_priority_encoder_2e8 priority_encoder3 (\n        .data(wire_priority_encoder3_data),\n        .q(wire_priority_encoder3_q),\n        .zero(wire_priority_encoder3_zero)\n    );\n\n    // Assign the outputs of the instance to the output of the overall module\n    assign wire_priority_encoder3_data = {data[1], data[0]};\n    assign q = wire_priority_encoder3_q;\n    assign zero = wire_priority_encoder3_zero;\n\nendmodule\nmodule fpadd_priority_encoder_2e8 (\n    input [1:0] data,\n    output [0:0] q,\n    output zero\n);\n\n    wire [0:0] wire_altpriority_encoder2_q;\n    wire wire_altpriority_encoder2_zero;\n\n    // Instantiate one instance of fpadd_altpriority_encoder_2e8\n    fpadd_altpriority_encoder_2e8 altpriority_encoder2 (\n        .data(data),\n        .q(wire_altpriority_encoder2_q),\n        .zero(wire_altpriority_encoder2_zero)\n    );\n\n    // Assign the outputs of the instance to the output of the overall module\n    assign q = wire_altpriority_encoder2_q;\n    assign zero = wire_altpriority_encoder2_zero;\n\nendmodule\nmodule fpadd_altpriority_encoder_2e8 (\n    input [1:0] data,\n    output [0:0] q,\n    output zero\n);\n\n    wire [0:0] wire_altpriority_encoder1_q;\n\n    // Instantiate one instance of fpadd_altpriority_encoder_1e8\n    fpadd_altpriority_encoder_1e8 altpriority_encoder1 (\n        .data(data[0:0]),\n        .q(wire_altpriority_encoder1_q),\n        .zero(zero)\n    );\n\n    // Assign the outputs of the instance to the output of the overall module\n    assign q = wire_altpriority_encoder1_q;\n\nendmodule\nmodule fpadd_altpriority_encoder_1e8 (\n    input [0:0] data,\n    output [0:0] q,\n    output zero\n);\n\n    // Assign the outputs of the instance to the output of the overall module\n    assign q = data;\n    assign zero = (data == 1'b0);\n\nendmodule",
        "module_name": "fpadd_altpriority_encoder_6e8",
        "module_hash": "e54b1895c733beceebb3062fdf8b0ace",
        "dataset_index": 942
      },
      "uart_transmitter #_e041ef5a": {
        "rtl_code": "\n\n\nmodule uart_transmitter # (\n\tparameter comm_clk_frequency = 100000000,\n\tparameter baud_rate = 115200\n) (\n\tinput clk,\n\n\toutput uart_tx,\n\n\tinput rx_new_byte,\n\tinput [7:0] rx_byte,\n\n\toutput tx_ready\n);\n\n\tlocalparam [15:0] baud_delay = (comm_clk_frequency / baud_rate) - 1;\n\n\treg [15:0] delay_cnt = 16'd0;\n\treg [9:0] state = 10'd1023, outgoing = 10'd1023;\n\n\tassign uart_tx = outgoing[0];\n\tassign tx_ready = state[0] & ~rx_new_byte;\n\n\n\talways @ (posedge clk)\n\tbegin\n\t\tdelay_cnt <= delay_cnt + 16'd1;\n\n\t\tif (delay_cnt >= baud_delay)\n\t\tbegin\n\t\t\tdelay_cnt <= 16'd0;\n\t\t\tstate <= {1'b1, state[9:1]};\n\t\t\toutgoing <= {1'b1, outgoing[9:1]};\n\t\tend\n\n\t\tif (rx_new_byte && state[0])\n\t\tbegin\n\t\t\tdelay_cnt <= 16'd0;\n\t\t\tstate <= 10'd0;\n\t\t\toutgoing <= {1'b1, rx_byte, 1'b0};\n\t\tend\n\tend\n\nendmodule\n",
        "module_name": "uart_transmitter #",
        "module_hash": "e041ef5a0090a930cc495229559dcaf5",
        "dataset_index": 25746
      },
      "splitter #_a2f0c5ac": {
        "rtl_code": "\n\nmodule splitter #(\n\n  parameter NUM_M = 2)(\n\n  input clk,\n  input resetn,\n\n  input s_valid,\n  output s_ready,\n\n  output [NUM_M-1:0] m_valid,\n  input [NUM_M-1:0] m_ready\n);\n\nreg [NUM_M-1:0] acked;\n\nassign s_ready = &(m_ready | acked);\nassign m_valid = s_valid ? ~acked : {NUM_M{1'b0}};\n\nalways @(posedge clk)\nbegin\n  if (resetn == 1'b0) begin\n    acked <= {NUM_M{1'b0}};\n  end else begin\n    if (s_valid & s_ready)\n      acked <= {NUM_M{1'b0}};\n    else\n      acked <= acked | (m_ready & m_valid);\n  end\nend\n\nendmodule\n",
        "module_name": "splitter #",
        "module_hash": "a2f0c5ac75df743c3f119a196b77b060",
        "dataset_index": 21736
      },
      "barrel_shifter_5de615e4": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] result\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nwire [3:0] abs_B;\n\nassign abs_B = (B[3] == 1'b1) ? ~B + 1'b1 : B;\n\nalways @(*) begin\n    stage1_out = (B[3] == 1'b0) ? (A << B) : (A >> abs_B);\nend\n\nalways @(*) begin\n    stage2_out = stage1_out;\nend\n\nassign result = stage2_out;\n\nendmodule\n",
        "module_name": "barrel_shifter",
        "module_hash": "5de615e43c4546ac33b8619a20e51b85",
        "dataset_index": 16566
      },
      "top__1bad68fd": {
        "rtl_code": "\nmodule top_module (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input sel,\n    output reg C\n);\n\n    wire signed [3:0] mux_output;\n    wire signed [0:0] mag_comp_output;\n\n    mux_2to1 mux (\n        .in({A, B}),\n        .sel(sel),\n        .out(mux_output)\n    );\n\n    signed_mag_comp mag_comp (\n        .A(A),\n        .B(B),\n        .C(mag_comp_output)\n    );\n\n    always @(*) begin\n        if (sel == 0) begin\n            if (mag_comp_output == 1'b1) begin\n                C <= 1'b1;\n            end else if (A > B) begin\n                C <= 1'b0;\n            end else begin\n                C <= 1'b0;\n            end\n        end else begin\n            C <= mux_output;\n        end\n    end\n\nendmodule\n\nmodule mux_2to1 (\n    input [7:0] in,\n    input sel,\n    output reg [3:0] out\n);\n\n    always @(in, sel) begin\n        case (sel)\n            1'b0: out <= in[3:0];\n            1'b1: out <= in[7:4];\n            default: out <= in[3:0];\n        endcase\n    end\n\nendmodule\n\nmodule signed_mag_comp (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output reg [0:0] C\n);\n\n    always @(A, B) begin\n        if (A == B) begin\n            C <= 1'b1;\n        end else if (A > B) begin\n            C <= 1'b0;\n        end else begin\n            C <= 1'b0;\n        end\n    end\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "1bad68fde532a2f58d8c5b182bd17d6e",
        "dataset_index": 4960
      },
      "binary_counter_da60465d": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input rst,\n  input en,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (rst) begin\n    count <= 4'b0;\n  end else if (en) begin\n    count <= count + 1;\n  end\nend\n\nendmodule\n",
        "module_name": "binary_counter",
        "module_hash": "da60465d30077c43dabdc0a672b3c03b",
        "dataset_index": 17898
      },
      "simple_calc_a22be5fb": {
        "rtl_code": "\nmodule simple_calc(\n    input [7:0] a,\n    input [7:0] b,\n    input op,\n    output reg [7:0] sum,\n    output reg [7:0] diff\n);\n\nreg [8:0] temp_diff;\nreg [8:0] temp_sum;\n\nalways @(*) begin\n    if(op) begin\n        temp_diff = a - b;\n        temp_sum = a + b;\n    end\n    else begin\n        temp_diff = b - a;\n        temp_sum = a + b;\n    end\nend\n\nalways @* begin\n    diff = temp_diff[7:0];\n    sum = temp_sum[7:0];\nend\n\nendmodule",
        "module_name": "simple_calc",
        "module_hash": "a22be5fbf71f35e94e3bc64b67a59480",
        "dataset_index": 7174
      },
      "comparator_mux_57b07ab3": {
        "rtl_code": "\nmodule comparator_mux (\n    input [1:0] comp_in1, // 2-bit input for the comparator\n    input [1:0] comp_in2, // 2-bit input for the comparator\n    input [7:0] mux_in, // 4 2-bit inputs for the multiplexer\n    input [1:0] select, // 2-bit select input for the multiplexer\n    input control, // Control input to choose between the comparator and the multiplexer\n    output [1:0] out // 2-bit output from the selected module\n);\n\n    // Comparator module\n    wire [1:0] comp_out;\n    // comparator comp(\n    //     .in1(comp_in1),\n    //     .in2(comp_in2),\n    //     .out(comp_out)\n    // );\n\n    // Multiplexer module\n    wire [1:0] mux_out;\n    // mux4to1 mux(\n    //     .in0(mux_in[1:0]),\n    //     .in1(mux_in[3:2]),\n    //     .in2(mux_in[5:4]),\n    //     .in3(mux_in[7:6]),\n    //     .sel(select),\n    //     .out(mux_out)\n    // );\n\n    // Output selection based on control input\n    assign out = control ? mux_out : comp_out;\n\nendmodule\nmodule comparator (\n    input [1:0] in1, // 2-bit input 1\n    input [1:0] in2, // 2-bit input 2\n    output [1:0] out // 2-bit output\n);\n\n    assign out[0] = (in1[0] > in2[0]) ? 1'b1 : 1'b0;\n    assign out[1] = (in1[1] > in2[1]) ? 1'b1 : 1'b0;\n    assign out = (in1 == in2) ? 2'b11 : out;\n\nendmodule\nmodule mux4to1 (\n    input [1:0] in0, // 2-bit input 0\n    input [1:0] in1, // 2-bit input 1\n    input [1:0] in2, // 2-bit input 2\n    input [1:0] in3, // 2-bit input 3\n    input [1:0] sel, // 2-bit select input\n    output [1:0] out // 2-bit output\n);\n\n    assign out = (sel == 2'b00) ? in0 :\n                 (sel == 2'b01) ? in1 :\n                 (sel == 2'b10) ? in2 :\n                                  in3;\n\nendmodule",
        "module_name": "comparator_mux",
        "module_hash": "57b07ab3314d0b9692f43d9e2f034406",
        "dataset_index": 19880
      },
      "top__a52a1caa": {
        "rtl_code": "\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow,\n    output [7:0] final_output\n);\n\nwire [15:0] product;\nwire [8:0] sum;\nwire msb_in_a, msb_in_b, msb_out;\nassign msb_in_a = a[7];\nassign msb_in_b = b[7];\n\nwire [8:0] product_1;\nwire [8:0] product_2;\nwire [8:0] product_3;\nwire [8:0] product_4;\nwire [8:0] product_5;\nwire [8:0] product_6;\nwire [8:0] product_7;\nwire [8:0] product_8;\n\nassign product_1 = a[7] * b[0];\nassign product_2 = a[7] * b[1];\nassign product_3 = a[7] * b[2];\nassign product_4 = a[7] * b[3];\nassign product_5 = a[7] * b[4];\nassign product_6 = a[7] * b[5];\nassign product_7 = a[7] * b[6];\nassign product_8 = a[7] * b[7];\n\nassign product = {product_8, product_7, product_6, product_5, product_4, product_3, product_2, product_1};\n\nassign sum = product[7:0] + product[15:8];\n\nassign s = sum[7:0];\nassign msb_out = sum[8];\n\nassign overflow = (msb_in_a == msb_in_b) && (msb_in_a != msb_out);\n\noverflow_detector od (\n    .overflow(overflow),\n    .sum(sum),\n    .final_output(final_output)\n);\n\nendmodule\nmodule overflow_detector (\n    input overflow,\n    input [8:0] sum,\n    output [7:0] final_output\n);\n    assign final_output = overflow ? sum[7:0] : sum[7:0];\nendmodule",
        "module_name": "top_",
        "module_hash": "a52a1caa85c162fa9cdfd88c82c40e66",
        "dataset_index": 20305
      },
      "selector_ea11e92c": {
        "rtl_code": "module selector ( input [3:0] pm0, input [3:0] pm1, input [3:0] pm2, input [3:0] pm3, output d0, output d1 );\n  wire n1, n2, n3, n4, n5, n6, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22;\n\n  // First, implement the logic for d0\n  // The AND gate takes as input the output of two NOR gates\n  // Each NOR gate takes as input two of the four input bits\n  assign n1 = ~(pm0[0] | pm0[1]);\n  assign n2 = ~(pm0[2] | pm0[3]);\n  assign n3 = ~(pm1[0] | pm1[1]);\n  assign n4 = ~(pm1[2] | pm1[3]);\n  assign n5 = n1 & n2;\n  assign n6 = n3 & n4;\n  // The output of the AND gate is used as input to the 2-to-1 multiplexer\n  assign d0 = n5 | n6;\n\n  // Next, implement the logic for d1\n  // The AND gate takes as input the output of two NAND gates\n  // Each NAND gate takes as input two of the four input bits\n  assign n8 = ~(pm2[0] & pm2[1]);\n  assign n9 = ~(pm2[2] & pm2[3]);\n  assign n10 = ~(pm3[0] & pm3[1]);\n  assign n11 = ~(pm3[2] & pm3[3]);\n  assign n12 = n8 & n9;\n  assign n13 = n10 & n11;\n  // The output of the AND gate is used as input to the 2-to-1 multiplexer\n  assign n14 = n12 | n13;\n  // The output of the 2-to-1 multiplexer is used as input to the OR gate\n  // The AOI gate takes as input three of the four input bits\n  assign n15 = ~(pm0[0] & pm1[0] & pm2[0]);\n  assign n16 = ~(pm0[1] & pm1[1] & pm2[1]);\n  assign n17 = ~(pm0[2] & pm1[2] & pm2[2]);\n  assign n18 = ~(pm0[3] & pm1[3] & pm2[3]);\n  assign n19 = n15 | n16;\n  assign n20 = n17 | n18;\n  assign n21 = n19 | n20;\n  // The output of the AOI gate is inverted to produce d1\n  assign n22 = ~n14;\n  assign d1 = n21 | n22;\nendmodule",
        "module_name": "selector",
        "module_hash": "ea11e92c38ccd98202ee8d83deaeb689",
        "dataset_index": 5486
      },
      "sector_to_flash_map_b9c7c7f2": {
        "rtl_code": "module sector_to_flash_map(\n\tinput [2:0] sector,\n\toutput reg [2:0] flash_sector\n);\n\n\tparameter SECTOR1_MAP = 3'b001;\n\tparameter SECTOR2_MAP = 3'b010;\n\tparameter SECTOR3_MAP = 3'b011;\n\tparameter SECTOR4_MAP = 3'b100;\n\tparameter SECTOR5_MAP = 3'b101;\n\n\talways @(*) begin\n\t\tcase(sector)\n\t\t\t3'd1: flash_sector = SECTOR1_MAP;\n\t\t\t3'd2: flash_sector = SECTOR2_MAP;\n\t\t\t3'd3: flash_sector = SECTOR3_MAP;\n\t\t\t3'd4: flash_sector = SECTOR4_MAP;\n\t\t\t3'd5: flash_sector = SECTOR5_MAP;\n\t\t\tdefault: flash_sector = 3'd0;\n\t\tendcase;\n\tend\n\nendmodule",
        "module_name": "sector_to_flash_map",
        "module_hash": "b9c7c7f2edf846a7ed33c61d91ea2ec4",
        "dataset_index": 7750
      },
      "full_adder_f52f525f": {
        "rtl_code": "module full_adder (\n    input A,\n    input B,\n    input Cin,\n    output Sum,\n    output Cout\n);\n\n    wire w1, w2, w3;\n\n    assign w1 = A ^ B;\n    assign w2 = w1 ^ Cin;\n    assign Sum = w2;\n\n    assign w3 = A & B;\n    assign Cout = w3 | (Cin & w1);\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "f52f525f25fe7176ed70ea69ffcde9d2",
        "dataset_index": 7908
      },
      "and4_189a9bf4": {
        "rtl_code": "module and4 (\n    input A, B, C, D,\n    output X\n);\n\n    wire W, Y;\n    \n    and and1(W, A, B);\n    and and2(Y, C, D);\n    and and3(X, W, Y);\n\nendmodule",
        "module_name": "and4",
        "module_hash": "189a9bf4a7d87d23e7af1b3d9ba260c6",
        "dataset_index": 4886
      },
      "top_module_a173048e": {
        "rtl_code": "module top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nwire and1, and2, and3, and4, or1, or2, xor1;\n\nassign and1 = in[0] & in[1];\nassign and2 = in[0] & in[2];\nassign and3 = in[0] & in[3];\nassign and4 = in[1] & in[2];\n\nassign or1 = in[0] | in[1];\nassign or2 = in[2] | in[3];\n\nassign xor1 = in[1] ^ in[3];\n\nassign out_and = and1 & and2 & and3 & and4;\nassign out_or = or1 | or2;\nassign out_xor = xor1;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "a173048ee8bd5f88b00188cb7cb524fa",
        "dataset_index": 18847
      },
      "adder_3bdddbcf": {
        "rtl_code": "\nmodule adder(input [7:0] A, input [7:0] B, output [7:0] S, output C_out);\n\n    wire [8:0] sum;\n    \n    assign sum = A + B;\n    \n    assign S = sum[7:0];\n    \n    assign C_out = sum[8];\n\nendmodule",
        "module_name": "adder",
        "module_hash": "3bdddbcf33b18e95154eed98b48ad7a4",
        "dataset_index": 5512
      },
      "top__00983106": {
        "rtl_code": "module top_module ( \n    input wire clk,\n    input wire [2:0] sel, \n    input wire [3:0] data0,\n    input wire [3:0] data1,\n    input wire [3:0] data2,\n    input wire [3:0] data3,\n    input wire [3:0] data4,\n    input wire [3:0] data5,\n    output wire [3:0] out_mux,\n    output wire [2:0] out_3bit,\n    output wire o2,\n    output wire o1,\n    output wire o0,\n    output wire [6:0] final_out\n);\n\n// 6-to-1 Multiplexer\nwire [3:0] mux_out;\nassign mux_out = (sel == 0) ? data0 :\n                 (sel == 1) ? data1 :\n                 (sel == 2) ? data2 :\n                 (sel == 3) ? data3 :\n                 (sel == 4) ? data4 :\n                 (sel == 5) ? data5 : 4'b0;\nassign out_mux = mux_out;\n\n// 3-bit Input Module\nassign out_3bit = sel;\nassign o2 = sel[2];\nassign o1 = sel[1];\nassign o0 = sel[0];\n\n// Functional Module\nwire [6:0] add_out;\nwire carry_out;\nassign {carry_out, add_out} = {1'b0, mux_out} + {1'b0, sel};\nassign final_out = {carry_out, add_out};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "00983106d1791b9dd9905a55a3c0758f",
        "dataset_index": 7803
      },
      "mux21_SIZE4_3_4054ba54": {
        "rtl_code": "\nmodule mux21_SIZE4_3 ( IN0, IN1, CTRL, OUT1 );\n  input [3:0] IN0;\n  input [3:0] IN1;\n  output [3:0] OUT1;\n  input CTRL;\n\n  wire [3:0] mux1_out;\n  wire [3:0] mux2_out;\n  wire [3:0] mux3_out;\n  wire [3:0] mux4_out;\n\n  MUX2_X1 U1 ( .A(IN0[3]), .B(IN1[3]), .S(CTRL), .Z(mux1_out[3]) );\n  MUX2_X1 U2 ( .A(IN0[2]), .B(IN1[2]), .S(CTRL), .Z(mux2_out[2]) );\n  MUX2_X1 U3 ( .A(IN0[1]), .B(IN1[1]), .S(CTRL), .Z(mux3_out[1]) );\n  MUX2_X1 U4 ( .A(IN0[0]), .B(IN1[0]), .S(CTRL), .Z(mux4_out[0]) );\n\n  assign OUT1 = {mux1_out[3], mux2_out[2], mux3_out[1], mux4_out[0]};\nendmodule\nmodule MUX2_X1 ( A, B, S, Z );\n  input A, B, S;\n  output Z;\n\n  assign Z = (S == 0)? A : B;\nendmodule",
        "module_name": "mux21_SIZE4_3",
        "module_hash": "4054ba541d81ac07dcab63b3c9d10ec8",
        "dataset_index": 10293
      },
      "async_reset_release_261d2c7a": {
        "rtl_code": "module async_reset_release (\n  input reset,\n  input clk,\n  output rst\n);\n\n  reg [3:0] counter;\n  reg rst_active;\n\n  always @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      counter <= 0;\n      rst_active <= 1'b1;\n    end else begin\n      if (counter == 4'd10) begin\n        rst_active <= 1'b0;\n      end else begin\n        counter <= counter + 1;\n      end\n    end\n  end\n\n  assign rst = rst_active;\n\nendmodule",
        "module_name": "async_reset_release",
        "module_hash": "261d2c7a17d7a63aecb40dc75a1cc1dd",
        "dataset_index": 2851
      },
      "lfsr_75a2d834": {
        "rtl_code": "\nmodule lfsr (Clk, Reset, Seed, Enable, Data, Done);\n\nparameter Tp = 1;\n\ninput Clk;\ninput Reset;\ninput [15:0] Seed;\ninput Enable;\n\noutput reg [15:0] Data;\noutput reg Done;\n\nreg [15:0] Lfsr;\n\nalways @ (posedge Clk or posedge Reset) begin\n  if (Reset) begin\n    Lfsr <= #Tp 16'b0;\n    Data <= #Tp 16'h0000;\n    Done <= #Tp 1'b0;\n  end else if (Enable) begin\n    Lfsr <= #Tp {Lfsr[14:0], Lfsr[0] ^ Lfsr[2] ^ Lfsr[3] ^ Lfsr[5]};\n    Data <= #Tp Lfsr;\n    Done <= #Tp 1'b1;\n  end else begin\n    Done <= #Tp 1'b0;\n  end\nend\n\nendmodule",
        "module_name": "lfsr",
        "module_hash": "75a2d834c06e01e30e866fa2aadb64c5",
        "dataset_index": 17073
      },
      "mux2_68c05933": {
        "rtl_code": "module mux2( sel, a, b, y );\n    parameter bitwidth=32;\n    input sel;\n    input  [bitwidth-1:0] a, b;\n    output [bitwidth-1:0] y;\n\n    assign y = sel ? b : a;\nendmodule\n",
        "module_name": "mux2",
        "module_hash": "68c05933dbbe650beba7b6c4655a15b7",
        "dataset_index": 19547
      },
      "priority_encoder_f3baaa3a": {
        "rtl_code": "module priority_encoder (\n    input [3:0] D,\n    output reg [1:0] Y,\n    input clk\n);\n    reg [1:0] Y_reg;\n    \n    always @(*) begin\n        Y_reg[1] = D[3];\n        if (D[3] == 1) begin\n            Y_reg[0] = 0;\n        end else if (D[2] == 1) begin\n            Y_reg[0] = 1;\n        end else if (D[1] == 1) begin\n            Y_reg[0] = 0;\n        end else if (D[0] == 1) begin\n            Y_reg[0] = 1;\n        end else begin\n            Y_reg[0] = 0;\n        end\n    end\n    \n    always @(posedge clk) begin\n        Y <= Y_reg;\n    end\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "f3baaa3a7f25357b9f19ac2a63c4a9da",
        "dataset_index": 2143
      },
      "c_incr_9e3701f2": {
        "rtl_code": "module c_incr\n  (data_in, data_out);\n   \n   parameter width = 3;\n   \n   parameter [0:width-1] min_value = 0;\n   parameter [0:width-1] max_value = (1 << width) - 1;\n   \n   localparam num_values = max_value - min_value + 1;\n   \n   localparam cwidth = $clog2(num_values);\n   \n   // operand inputs\n   input [0:width-1] data_in;\n   \n   // sum output\n   output [0:width-1] data_out;\n   wire [0:width-1] data_out;\n   \n   wire \t    carry;\n   assign carry = &data_in[(width-cwidth):width-1];\n   \n   wire \t    wrap;\n   assign wrap = (data_in[(width-cwidth):width-1] ==\n\t\t  max_value[(width-cwidth):width-1]);\n   \n   generate\n      \n      if((1 << cwidth) == num_values)\n\tbegin\n\t   \n\t   // if the range is a power of two, we can take advantage of natural\n\t   // wraparound for the LSBs\n\t   assign data_out[(width-cwidth):width-1]\n\t\t    = data_in[(width-cwidth):width-1] + 1'b1;\n\t   \n\tend\n      else\n\tbegin\n\t   \n\t   // if the range is not a power of two, we need to implement \n\t   // explicit wraparound\n\t   assign data_out[(width-cwidth):width-1]\n\t\t    = wrap ?\n\t\t      min_value[(width-cwidth):width-1] :\n\t\t      (data_in[(width-cwidth):width-1] + 1'b1);\n\t   \n\tend\n      \n      if(width > cwidth)\n\tbegin\n\t   \n\t   if(min_value[0:(width-cwidth)-1] == max_value[0:(width-cwidth)-1])\n\t     begin\n\t\t\n\t\t// if the MSBs are identical for the first and last value, we \n\t\t// never need to change them\n\t\tassign data_out[0:(width-cwidth)-1]\n\t\t\t = data_in[0:(width-cwidth)-1];\n\t\t\n\t     end\n\t   else\n\t     begin\n\t\t\n\t\t// if the first and last value have differing MSBs, we need to\n\t\t// adjust them whenever either the LSBs overflow or wraparound\n\t\t// occurs\n\t\tassign data_out[0:(width-cwidth)-1]\n\t\t\t = data_in[0:(width-cwidth)-1] + carry - wrap;\n\t\t\n\t     end\n\t   \n\tend\n      \n   endgenerate\n   \nendmodule",
        "module_name": "c_incr",
        "module_hash": "9e3701f2500c4b3a6efb2eab440419d0",
        "dataset_index": 6476
      },
      "denise_collision_952f02b5": {
        "rtl_code": "module denise_collision\n(\n  input   clk,          input clk7_en,\n  input  reset,          input aga,        input   [8:1] reg_address_in,  input   [15:0] data_in,      output  [15:0] data_out,    input  dblpf,        input  [7:0] bpldata,      input  [7:0] nsprite\n);\n\nparameter CLXCON  = 9'h098;\nparameter CLXCON2 = 9'h10e;\nparameter CLXDAT  = 9'h00e;\n\nreg    [15:0] clxcon;      reg   [15:0] clxcon2;     reg    [14:0] clxdat;      wire  [3:0] sprmatch;      wire  oddmatch;        wire  evenmatch;        always @(posedge clk)\n  if (clk7_en) begin\n    if (reset) clxcon <= 16'h0fff;\n    else if (reg_address_in[8:1] == CLXCON[8:1])\n      clxcon <= data_in;\n  end\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (reset || (reg_address_in[8:1] == CLXCON[8:1]))\n      clxcon2 <= #1 16'h0000;\n    else if (aga && (reg_address_in[8:1] == CLXCON2[8:1]))\n      clxcon2 <= #1 data_in;\n  end\nend\n\nwire [7:0] bm;\nassign bm = (bpldata[7:0] ^ ~{clxcon2[1:0],clxcon[5:0]}) | (~{clxcon2[7:6],clxcon[11:6]}); assign oddmatch = bm[6] & bm[4] & bm[2] & bm[0] & (dblpf | evenmatch);\nassign evenmatch = bm[7] & bm[5] & bm[3] & bm[1];\n\n\n\n\n\nassign sprmatch[0] = nsprite[0] | (nsprite[1] & clxcon[12]);\nassign sprmatch[1] = nsprite[2] | (nsprite[3] & clxcon[13]);\nassign sprmatch[2] = nsprite[4] | (nsprite[5] & clxcon[14]);\nassign sprmatch[3] = nsprite[6] | (nsprite[7] & clxcon[15]);\n\nwire [14:0] cl;\nreg clxdat_read_del;\n\nassign cl[0]  = evenmatch   & oddmatch;    assign cl[1]  = oddmatch    & sprmatch[0];  assign cl[2]  = oddmatch    & sprmatch[1];  assign cl[3]  = oddmatch    & sprmatch[2];  assign cl[4]  = oddmatch    & sprmatch[3];  assign cl[5]  = evenmatch   & sprmatch[0];  assign cl[6]  = evenmatch   & sprmatch[1];  assign cl[7]  = evenmatch   & sprmatch[2];  assign cl[8]  = evenmatch   & sprmatch[3];  assign cl[9]  = sprmatch[0] & sprmatch[1];  assign cl[10] = sprmatch[0] & sprmatch[2];  assign cl[11] = sprmatch[0] & sprmatch[3];  assign cl[12] = sprmatch[1] & sprmatch[2];  assign cl[13] = sprmatch[1] & sprmatch[3];  assign cl[14] = sprmatch[2] & sprmatch[3];  wire clxdat_read = (reg_address_in[8:1]==CLXDAT[8:1]);always @(posedge clk)\n  if (clk7_en) begin\n    clxdat_read_del <= clxdat_read;\n  end\n\nalways @(posedge clk)\n  if (clk7_en) begin\n  if (!clxdat_read & clxdat_read_del)  clxdat <= 0;\n    else clxdat <= clxdat[14:0] | cl[14:0];\n  end\n\nassign data_out = reg_address_in[8:1]==CLXDAT[8:1] ? {1'b1,clxdat[14:0]} : 16'd0;\n\n\nendmodule\n\n",
        "module_name": "denise_collision",
        "module_hash": "952f02b570b3400062c5e20ecb59e5a9",
        "dataset_index": 13450
      },
      "descrambler #_657d1e20": {
        "rtl_code": "\n\nmodule descrambler # (\n\tparameter WIDTH = 512\n)(\n\tinput clk,arst,ena,\n\tinput [WIDTH-1:0] din,\t\toutput reg [WIDTH-1:0] dout\n);\n\nreg [57:0] scram_state;\nwire [WIDTH+58-1:0] history;\nwire [WIDTH-1:0] dout_w;\nassign history = {din,scram_state};\n\ngenvar i;\ngenerate\n\tfor (i=0; i<WIDTH; i=i+1) begin : lp\n\t\tassign dout_w[i] = history[58+i-58] ^ history[58+i-39] ^ history[58+i];\t\t\n\tend\nendgenerate\n\t\nalways @(posedge clk or posedge arst) begin\n\tif (arst) begin\n\t\tdout <= 0;\n\t\tscram_state <= 58'h3ff_ffff_ffff_ffff;\n\tend\n\telse if (ena) begin\n\t\tdout <= dout_w;\n\t\tscram_state <= history[WIDTH+58-1:WIDTH];\n\tend\nend\n\nendmodule\n\t\n",
        "module_name": "descrambler #",
        "module_hash": "657d1e208104aa0a85114552b297bf1a",
        "dataset_index": 21574
      },
      "up_down_counter_58a76198": {
        "rtl_code": "module up_down_counter (\n    input clk,\n    input rst_n,\n    input up_down,\n    input [3:0] load_data,\n    output reg [3:0] count\n);\n\nreg [3:0] count_reg1, count_reg2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        count_reg1 <= 4'b0000;\n        count_reg2 <= 4'b0000;\n    end\n    else begin\n        count_reg1 <= count_reg2;\n        count_reg2 <= count;\n    end\nend\n\nalways @(*) begin\n    if (up_down) begin\n        if (load_data != 4'b0000) begin\n            count = load_data;\n        end\n        else begin\n            count = count_reg1 + 4'b0001;\n        end\n    end\n    else begin\n        if (load_data != 4'b0000) begin\n            count = load_data;\n        end\n        else begin\n            count = count_reg1 - 4'b0001;\n        end\n    end\nend\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "58a7619896ea01ae250255d5948bfd5c",
        "dataset_index": 4651
      },
      "fourBitAdder_4cdbe9d8": {
        "rtl_code": "module fourBitAdder(input [3:0] in, output reg [1:0] out);\n\n    always @(*) begin\n        if(in <= 2) begin\n            out <= 2'b00;\n        end else begin\n            out <= {in[3:2] + in[1:0]};\n        end\n    end\n\nendmodule",
        "module_name": "fourBitAdder",
        "module_hash": "4cdbe9d8b95698072a8141d052bf056b",
        "dataset_index": 12880
      },
      "binary_adder_0ea87421": {
        "rtl_code": "module binary_adder (\n  input clk,\n  input reset,\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] S\n);\n\nreg [3:0] carry;\nreg [3:0] sum;\n\nalways @ (posedge clk or negedge reset) begin\n  if (!reset) begin\n    carry <= 4'b0;\n    sum <= 4'b0;\n  end else begin\n    carry <= {carry[2:0], A[3]&B[3] | A[3]&carry[3] | B[3]&carry[3]};\n    sum <= A + B + carry;\n  end\nend\n\nassign S = sum;\n\nendmodule\n",
        "module_name": "binary_adder",
        "module_hash": "0ea87421abdbf3dda10765dae903eb5c",
        "dataset_index": 11410
      },
      "sky130_fd_sc_ls__xor3_e6943cb7": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__xor3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    wire xor0_out_X;\n\n    xor xor0 (xor0_out_X, A, B, C        );\n    buf buf0 (X         , xor0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__xor3",
        "module_hash": "e6943cb7e79e6d2bcec21ff466ae0bf1",
        "dataset_index": 10037
      },
      "sky130_fd_sc_lp__or4bb_1c4aa497": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__or4bb (\n    X  ,\n    A  ,\n    B  ,\n    C_N,\n    D_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n    input  D_N;\n\n    wire nand0_out;\n    wire or0_out_X;\n\n    nand nand0 (nand0_out, D_N, C_N       );\n    or   or0   (or0_out_X, B, A, nand0_out);\n    buf  buf0  (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__or4bb",
        "module_hash": "1c4aa4978c810dfdc72da4443a5cea1a",
        "dataset_index": 23258
      },
      "dff_keep_5_new_58404823": {
        "rtl_code": "module dff_keep_5_new (clk, d, q);\n    \n    \n    \n    \n    input clk;\n    input [4:0] d;\n    output [4:0] q;\n    reg [4:0] q_reg;\n    \n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n    \n    assign q = q_reg;\nendmodule",
        "module_name": "dff_keep_5_new",
        "module_hash": "58404823d94d0388c752af8a9fa4dd17",
        "dataset_index": 7162
      },
      "top__750187c9": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [7:0] in_1,\n    input [7:0] in_2,\n    input select,\n    output [7:0] sum_output,\n    output [7:0] or_output\n);\n\n    // 2-to-1 MUX\n    wire [7:0] selected_input;\n    mux_2to1 mux_inst (\n        .in_0(in_1),\n        .in_1(in_2),\n        .select(select),\n        .out(selected_input)\n    );\n\n    // 8-bit adder\n    wire [8:0] sum;\n    adder_8bit adder_inst (\n        .a(selected_input),\n        .b(in_2),\n        .sum(sum)\n    );\n\n    // Bitwise OR\n    assign or_output = selected_input | in_2;\n\n    // Output assignments\n    assign sum_output = sum[7:0];\n\nendmodule\n\n// 2-to-1 MUX module\nmodule mux_2to1 (\n    input [7:0] in_0,\n    input [7:0] in_1,\n    input select,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (select == 1'b0) begin\n            out = in_0;\n        end else begin\n            out = in_1;\n        end\n    end\n\nendmodule\n\n// 8-bit adder module\nmodule adder_8bit (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [8:0] sum\n);\n\n    always @(*) begin\n        sum = {1'b0, a} + {1'b0, b};\n    end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "750187c914d9b0e91809cc625276d54e",
        "dataset_index": 7669
      },
      "concat_8bit_4f6ee632": {
        "rtl_code": "module concat_8bit (\n  input clk,\n  input reset,\n  input [7:0] a,\n  input [7:0] b,\n  input ctrl,\n  output [15:0] out\n);\n\nreg [15:0] temp;\n\nalways @ (posedge clk or posedge reset) begin\n  if (reset) begin\n    temp <= 16'b0;\n  end else begin\n    if (ctrl) begin\n      temp <= {a, b};\n    end else begin\n      temp <= {b, a};\n    end\n  end\nend\n\nassign out = temp;\n\nendmodule\n",
        "module_name": "concat_8bit",
        "module_hash": "4f6ee632d5f1627136047423f419540a",
        "dataset_index": 10273
      },
      "top_module_010e0087": {
        "rtl_code": "\nmodule top_module(\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    wire nor_out;\n    wire [3:0] decoder_out;\n    wire final_out;\n\n    nor_gate nor_inst(\n        .a(a),\n        .b(b),\n        .nor_out(nor_out)\n    );\n\n    decoder_3_4 decoder_inst(\n        .a(a),\n        .b(b),\n        .c(c),\n        .w(decoder_out[0]),\n        .x(decoder_out[1]),\n        .y(decoder_out[2]),\n        .z(decoder_out[3])\n    );\n\n    functional_module func_inst(\n        .nor_out(nor_out),\n        .decoder_out(decoder_out),\n        .final_out(final_out)\n    );\n\n    assign w = decoder_out[0];\n    assign x = decoder_out[1];\n    assign y = decoder_out[2];\n    assign z = decoder_out[3];\n\nendmodule\n\nmodule nor_gate(\n    input a,\n    input b,\n    output nor_out\n);\n\n    assign nor_out = !(a & b);\n\nendmodule\n\nmodule decoder_3_4(\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    assign w = ~(a | b | c);\n    assign x = ~(a | b | ~c);\n    assign y = ~(a | ~b | c);\n    assign z = ~(a | ~b | ~c);\n\nendmodule\n\nmodule functional_module(\n    input nor_out,\n    input [3:0] decoder_out,\n    output final_out\n);\n\n    assign final_out = nor_out & decoder_out;\n\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "010e0087759be4b2e08b09f5d5d52938",
        "dataset_index": 17558
      },
      "switch_to_leds_f5f54995": {
        "rtl_code": "module switch_to_leds (\n    input [15:0] switch_input,\n    input reset,\n    output reg [7:0] red_led_output,\n    output reg [7:0] green_led_output\n);\n\n    always @(*) begin\n        if (reset) begin\n            red_led_output <= 8'b0;\n            green_led_output <= 8'b0;\n        end else begin\n            red_led_output <= ~switch_input[7:0];\n            green_led_output <= ~switch_input[15:8];\n        end\n    end\n\nendmodule",
        "module_name": "switch_to_leds",
        "module_hash": "f5f5499559877b640310fd781e27469c",
        "dataset_index": 9869
      },
      "simple_calculator_083cfdb5": {
        "rtl_code": "\nmodule simple_calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    input clk,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: out = a + b;\n        2'b01: out = a - b;\n        2'b10: out = a & b;\n        2'b11: out = a | b;\n    endcase\nend\n\nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "083cfdb50b51462ef0826118c7a90931",
        "dataset_index": 4230
      },
      "arithmetic_d07b50a7": {
        "rtl_code": "module arithmetic(input [7:0] a, input [7:0] b, output reg [7:0] result);\n\n\talways @(*) begin\n\t\tif(a > b)\n\t\t\tresult = a + b;\n\t\telse if(a < b)\n\t\t\tresult = a - b;\n\t\telse\n\t\t\tresult = a & b;\n\tend\n\nendmodule",
        "module_name": "arithmetic",
        "module_hash": "d07b50a755bc41897cd90f85cf8cee6b",
        "dataset_index": 12270
      },
      "mux_system_a0c46147": {
        "rtl_code": "\nmodule mux_system (\n    input a,\n    input b,\n    input c,\n    input sel_2to1,\n    input sel_3to1,\n    output out\n);\n\nwire nand1, nand2, nand3, nand4, nand5, nand6;\n\nassign nand1 = ~(a & sel_2to1);\nassign nand2 = ~(b & ~sel_2to1);\nassign nand3 = ~(nand1 & nand2);\n\nassign nand4 = ~(nand3 & sel_3to1);\nassign nand5 = ~(c & ~sel_3to1);\nassign nand6 = ~(nand4 & nand5);\n\nreg out_reg;\nassign out = out_reg;\n\nalways @(nand6) begin\n    out_reg <= ~nand6;\nend\n\nendmodule\n",
        "module_name": "mux_system",
        "module_hash": "a0c46147ef5580d7b8ebf6aac4881fbe",
        "dataset_index": 19792
      },
      "xor3_b297bb2c": {
        "rtl_code": "module xor3 (\n    output Y,\n    input A,\n    input B,\n    input C\n);\n\n    wire nand1_out, nand2_out, nand3_out;\n\n    nand nand1 (nand1_out, A, B);\n    nand nand2 (nand2_out, nand1_out, C);\n    nand nand3 (Y, nand2_out, nand2_out);\n\nendmodule",
        "module_name": "xor3",
        "module_hash": "b297bb2c97f7a6d9c43461211035b19a",
        "dataset_index": 17380
      },
      "mux4_4be813d9": {
        "rtl_code": "module mux4(enable, select, in0, in1, in2, in3, out);\n    input enable;\n    input [1:0] select;\n    input in0, in1, in2, in3;\n    output out;\n    \n    wire [3:0] mux_out;\n    \n    assign mux_out[0] = (enable) ? in0 : 1'b0;\n    assign mux_out[1] = (enable) ? in1 : 1'b0;\n    assign mux_out[2] = (enable) ? in2 : 1'b0;\n    assign mux_out[3] = (enable) ? in3 : 1'b0;\n    \n    assign out = mux_out[select];\n    \nendmodule",
        "module_name": "mux4",
        "module_hash": "4be813d98786ae872e91befb045572fc",
        "dataset_index": 2232
      },
      "ChannelArbiter_4059a673": {
        "rtl_code": "\n\nmodule ChannelArbiter\n(\n    iClock          ,\n    iReset          ,\n    iRequestChannel ,\n    iLastChunk      ,\n    oKESAvail       ,\n    oChannelNumber  ,\n    iKESAvail\n);\n\n    input           iClock          ;\n    input           iReset          ;\n    input   [3:0]   iRequestChannel ;\n    input   [3:0]   iLastChunk      ;\n    output  [3:0]   oKESAvail       ;\n    output  [1:0]   oChannelNumber  ;\n    input           iKESAvail       ;\n        \n    reg     [3:0]   rPriorityQ0     ;\n    reg     [3:0]   rPriorityQ1     ;\n    reg     [3:0]   rPriorityQ2     ;\n    reg     [3:0]   rPriorityQ3     ;\n    reg     [3:0]   rKESAvail       ;\n    reg     [1:0]   rChannelNumber  ;\n    \n    localparam  State_Idle          = 5'b00001;\n    localparam  State_Select        = 5'b00010;\n    localparam  State_Out           = 5'b00100;\n    localparam  State_Dummy         = 5'b01000;\n    localparam  State_Standby       = 5'b10000;\n    \n    reg     [4:0]   rCurState   ;\n    reg     [4:0]   rNextState  ;\n    \n    always @ (posedge iClock)\n        if (iReset)\n            rCurState <= State_Idle;\n        else\n            rCurState <= rNextState;\n    \n    always @ (*)\n        case (rCurState)\n        State_Idle:\n            if (|iRequestChannel && iKESAvail)\n                rNextState <= State_Select;\n            else\n                rNextState <= State_Idle;\n        State_Select:\n            rNextState <= State_Out;\n        State_Out:\n            rNextState <= State_Dummy;\n        State_Dummy:\n            rNextState <= (iLastChunk[rChannelNumber]) ? State_Idle : State_Standby;\n        State_Standby:\n            if (iKESAvail)\n                rNextState <= State_Out;\n            else\n                rNextState <= State_Standby;\n        default:\n            rNextState <= State_Idle;\n        endcase\n        \n    always @ (posedge iClock)\n        if (iReset)\n        begin\n            rKESAvail <= 4'b0;\n            rChannelNumber <= 2'b0;\n        end\n        else\n            case (rNextState)\n            State_Idle:\n            begin\n                rKESAvail <= 4'b0;\n                rChannelNumber <= rChannelNumber;\n            end\n            State_Select:\n            if (iRequestChannel & rPriorityQ0)\n                begin\n                    rKESAvail <= rPriorityQ0;\n                    case (rPriorityQ0)\n                    4'b0001:\n                        rChannelNumber <= 2'b00;\n                    4'b0010:\n                        rChannelNumber <= 2'b01;\n                    4'b0100:\n                        rChannelNumber <= 2'b10;\n                    4'b1000:\n                        rChannelNumber <= 2'b11;\n                    default:\n                        rChannelNumber <= rChannelNumber;\n                    endcase\n                end\n            else if (iRequestChannel & rPriorityQ1)\n                begin\n                    rKESAvail <= rPriorityQ1;\n                    case (rPriorityQ1)\n                    4'b0001:\n                        rChannelNumber <= 2'b00;\n                    4'b0010:\n                        rChannelNumber <= 2'b01;\n                    4'b0100:\n                        rChannelNumber <= 2'b10;\n                    4'b1000:\n                        rChannelNumber <= 2'b11;\n                    default:\n                        rChannelNumber <= rChannelNumber;\n                    endcase\n                end\n            else if (iRequestChannel & rPriorityQ2)\n                begin\n                    rKESAvail <= rPriorityQ2;\n                    case (rPriorityQ2)\n                    4'b0001:\n                        rChannelNumber <= 2'b00;\n                    4'b0010:\n                        rChannelNumber <= 2'b01;\n                    4'b0100:\n                        rChannelNumber <= 2'b10;\n                    4'b1000:\n                        rChannelNumber <= 2'b11;\n                    default:\n                        rChannelNumber <= rChannelNumber;\n                    endcase\n                end\n            else if (iRequestChannel & rPriorityQ3)\n                begin\n                    rKESAvail <= rPriorityQ3;\n                    case (rPriorityQ3)\n                    4'b0001:\n                        rChannelNumber <= 2'b00;\n                    4'b0010:\n                        rChannelNumber <= 2'b01;\n                    4'b0100:\n                        rChannelNumber <= 2'b10;\n                    4'b1000:\n                        rChannelNumber <= 2'b11;\n                    default:\n                        rChannelNumber <= rChannelNumber;\n                    endcase\n                end\n            default:\n            begin\n                rKESAvail <= rKESAvail;\n                rChannelNumber <= rChannelNumber;\n            end\n            endcase\n            \n    always @ (posedge iClock)\n        if (iReset)\n            begin\n                rPriorityQ0 <= 4'b0001;\n                rPriorityQ1 <= 4'b0010;\n                rPriorityQ2 <= 4'b0100;\n                rPriorityQ3 <= 4'b1000;\n            end\n        else \n            case (rNextState)\n            State_Select:\n            if (iRequestChannel & rPriorityQ0)\n                begin\n                    rPriorityQ0 <= rPriorityQ1;\n                    rPriorityQ1 <= rPriorityQ2;\n                    rPriorityQ2 <= rPriorityQ3;\n                    rPriorityQ3 <= rPriorityQ0;\n                end\n            else if (iRequestChannel & rPriorityQ1)\n                begin\n                    rPriorityQ1 <= rPriorityQ2;\n                    rPriorityQ2 <= rPriorityQ3;\n                    rPriorityQ3 <= rPriorityQ1;\n                end\n            else if (iRequestChannel & rPriorityQ2)\n                begin\n                    rPriorityQ2 <= rPriorityQ3;\n                    rPriorityQ3 <= rPriorityQ2;\n                end\n            default:\n            begin\n                rPriorityQ0 <= rPriorityQ0;\n                rPriorityQ1 <= rPriorityQ1;\n                rPriorityQ2 <= rPriorityQ2;\n                rPriorityQ3 <= rPriorityQ3;\n            end\n            endcase\n            \n    assign oKESAvail = (rCurState == State_Out) ? rKESAvail : 4'b0;\n    assign oChannelNumber = rChannelNumber;\nendmodule",
        "module_name": "ChannelArbiter",
        "module_hash": "4059a673c27f960086f3e3a0f8bf0c99",
        "dataset_index": 25783
      },
      "DFFSR_3035d4d2": {
        "rtl_code": "module DFFSR (output Q, input C, S, R, D);\n\n    reg Q;\n\n    always @(posedge C) begin\n        if (R) begin\n            Q <= 0;\n        end else if (S) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "DFFSR",
        "module_hash": "3035d4d2a752b1add955e168ca9ed705",
        "dataset_index": 12778
      },
      "top__56e7b628": {
        "rtl_code": "\nmodule top_module (\n    input  clk,\n    input  reset,\n    input  [1:0] in,\n    input  sel,\n    input  [3:0] data_in,\n    input  shift,\n    input  load,\n    output reg [3:0] out\n);\n\nreg [3:0] shift_reg;\nwire [3:0] mux_out;\n\n// Instantiate the 2-to-1 multiplexer module\nmux_2to1 mux_inst (\n    .sel(sel),\n    .in0(data_in),\n    .in1(shift_reg),\n    .out(mux_out)\n);\n\n// Instantiate the 4-bit shift register module\nshift_reg_4bit shift_reg_inst (\n    .clk(clk),\n    .reset(reset),\n    .load(load),\n    .shift(shift),\n    .data_in(mux_out),\n    .out(shift_reg)\n);\n\n// Functional module to calculate the sum of shift register output and selected input of the multiplexer\nalways @ (posedge clk) begin\n    if (reset) begin\n        out <= 0;\n    end else begin\n        out <= shift_reg;\n    end\nend\n\nendmodule\nmodule mux_2to1 (\n    input [3:0] in0,\n    input [3:0] in1,\n    input sel,\n    output reg [3:0] out\n);\n\nalways @ (sel or in0 or in1) begin\n    if (sel == 1'b0) begin\n        out <= in0;\n    end else begin\n        out <= in1;\n    end\nend\n\nendmodule\nmodule shift_reg_4bit (\n    input [3:0] data_in,\n    input shift,\n    input load,\n    input clk,\n    input reset,\n    output reg [3:0] out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 0;\n    end else begin\n        if (load) begin\n            out <= data_in;\n        end else if (shift) begin\n            out <= {out[2:0], 1'b0};\n        end\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "56e7b628ab0d78ac2c1dbacf53ffffae",
        "dataset_index": 10016
      },
      "digit_select_a1347828": {
        "rtl_code": "\nmodule digit_select(\n\t\td1,\n\t\td2,\n\t\td3,\n\t\td4,\n\t\tcontrol,\n\t\tdigit\n);\n\ninput [3:0]  d1;\n\t\t\tinput [3:0]  d2;\n\t\t\tinput [3:0]  d3;\n\t\t\tinput [3:0]  d4;\n\t\t\tinput [1:0]  control;\n\t\t\toutput [3:0] digit;  \n   \nassign digit = (control == 2'b11) ? d1 : \n\t\t\t\t\t\t\t\t(control == 2'b10) ? d2 : \n\t\t\t\t\t\t\t\t(control == 2'b01) ? d3 : \n\t\t\t\t\t\t\t\td4;\n   \nendmodule\n",
        "module_name": "digit_select",
        "module_hash": "a13478286039c53c15b21accee6af9cd",
        "dataset_index": 6007
      },
      "mux4_to_1_async_reset_8a9b327d": {
        "rtl_code": "\nmodule mux4_to_1_async_reset (\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    input reset,\n    output [3:0] out\n);\n\n    wire [3:0] mux1_out;\n    wire [3:0] mux2_out;\n    wire [3:0] mux3_out;\n    wire [3:0] mux4_out;\n\n    // First stage of the mux\n    mux4to1 mux1 (\n        .in0(in0),\n        .in1(in1),\n        .in2(in2),\n        .in3(in3),\n        .sel(sel[1]),\n        .out(mux1_out)\n    );\n\n    // Second stage of the mux\n    mux4to1 mux2 (\n        .in0(in0),\n        .in1(in1),\n        .in2(in2),\n        .in3(in3),\n        .sel(sel[0]),\n        .out(mux2_out)\n    );\n\n    // Third stage of the mux\n    mux2to1 mux3 (\n        .in0(mux1_out),\n        .in1(mux2_out),\n        .sel(sel[1]),\n        .out(mux3_out)\n    );\n\n    // Fourth stage of the mux\n    mux2to1 mux4 (\n        .in0(mux3_out),\n        .in1(4'b0),\n        .sel(reset),\n        .out(mux4_out)\n    );\n\n    assign out = mux4_out;\n\nendmodule\nmodule mux4to1 (\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input sel,\n    output [3:0] out\n);\n\n    wire [3:0] mux1_out;\n    wire [3:0] mux2_out;\n\n    // First stage of the mux\n    mux2to1 mux1 (\n        .in0(in0),\n        .in1(in1),\n        .sel(sel),\n        .out(mux1_out)\n    );\n\n    // Second stage of the mux\n    mux2to1 mux2 (\n        .in0(in2),\n        .in1(in3),\n        .sel(sel),\n        .out(mux2_out)\n    );\n\n    // Third stage of the mux\n    mux2to1 mux3 (\n        .in0(mux1_out),\n        .in1(mux2_out),\n        .sel(sel),\n        .out(out)\n    );\n\nendmodule\nmodule mux2to1 (\n    input [3:0] in0,\n    input [3:0] in1,\n    input sel,\n    output [3:0] out\n);\n\n    assign out = sel ? in1 : in0;\n\nendmodule",
        "module_name": "mux4_to_1_async_reset",
        "module_hash": "8a9b327deefdd6ace1fcab69fe9d1da3",
        "dataset_index": 6718
      },
      "calculator_3b9f4a50": {
        "rtl_code": "module calculator(\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input [1:0] op,\n    output reg signed [7:0] result,\n    output reg overflow\n);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a * b;\n            2'b11: result = a / b;\n        endcase\n    end\n\n    always @(result) begin\n        if(result > 127 || result < -128) begin\n            overflow = 1;\n        end else begin\n            overflow = 0;\n        end\n    end\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "3b9f4a50aad61058e9a9b45a39bf4e54",
        "dataset_index": 13460
      },
      "reverse_bit_order_pipeline_145f9fcf": {
        "rtl_code": "\nmodule reverse_bit_order_pipeline(\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [7:0] out\n);\n\n// Register to hold the input data\nreg [7:0] in_reg;\n\n// Register to hold the reversed output data\nreg [7:0] out_reg;\n\n// Pipeline register to hold the reversed data\nreg [7:0] out_pipeline_reg;\n\nalways @(posedge clk) begin\n    // Reset logic\n    if (reset) begin\n        in_reg <= 8'b0;\n        out_reg <= 8'b0;\n        out_pipeline_reg <= 8'b0;\n    end else begin\n        // Store the input data in the register\n        in_reg <= in;\n\n        // Reverse the input data and store it in the output register\n        out_reg <= {in_reg[7], in_reg[6], in_reg[5], in_reg[4],\n                   in_reg[3], in_reg[2], in_reg[1], in_reg[0]};\n\n        // Store the reversed data in the pipeline register\n        out_pipeline_reg <= out_reg;\n    end\nend\n\n// Assign the output to the pipeline register\nassign out = out_pipeline_reg;\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [7:0] out\n);\n\nreverse_bit_order_pipeline reverse_inst(\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule\n",
        "module_name": "reverse_bit_order_pipeline",
        "module_hash": "145f9fcf491003d21eb5dcdc5a63afbc",
        "dataset_index": 15661
      },
      "MarioScore24x1_f1ad80ff": {
        "rtl_code": "\nmodule MarioScore24x1 (\n        input wire  [7:0] char_xy,\n\t\tinput wire  [3:0] mario_lives,\n\t\tinput wire  [3:0] level,\n\t\tinput wire  [11:0] coins,\n\n        output wire [7:0] char_code    \n    );\n\n    reg [7:0] char_code_nxt;\n\treg [3:0] bcd0, bcd1, bcd2;\n\treg [3:0] hex1, hex2, hex3, hex4, hex5;\n\n\tinteger i;\n\n    always @(coins)\n    begin\n        bcd0 = 0;\n        bcd1 = 0;\n        bcd2 = 0;\n\n        for ( i = 11; i >= 0; i = i - 1 )\n        begin\n            if( bcd0 > 4 ) bcd0 = bcd0 + 3;\n            if( bcd1 > 4 ) bcd1 = bcd1 + 3;\n            if( bcd2 > 4 ) bcd2 = bcd2 + 3;\n            { bcd2[3:0], bcd1[3:0], bcd0[3:0] } =\n            { bcd2[2:0], bcd1[3:0], bcd0[3:0],coins[i] };\n        end\n    end\n\t\n\talways @(*)\n\tbegin\n\t\tcase(mario_lives)\n\t\t\t0: hex1 = 8'h00;\n\t\t\t1: hex1 = 8'h01;\n\t\t\t2: hex1 = 8'h02;\n\t\t\t3: hex1 = 8'h03;\n\t\t\t4: hex1 = 8'h04;\n\t\t\t5: hex1 = 8'h05;\n\t\t\t6: hex1 = 8'h06;\n\t\t\t7: hex1 = 8'h07;\n\t\t\t8: hex1 = 8'h08;\n\t\t\t9: hex1 = 8'h09;\n\t\t\tdefault: hex1 = 8'h00;\n\t\tendcase\n\t\t\n\t\tcase(level)\n\t\t\t0: hex2 = 8'h00;\n\t\t\t1: hex2 = 8'h01;\n\t\t\t2: hex2 = 8'h02;\n\t\t\t3: hex2 = 8'h03;\n\t\t\t4: hex2 = 8'h04;\n\t\t\t5: hex2 = 8'h05;\n\t\t\t6: hex2 = 8'h06;\n\t\t\t7: hex2 = 8'h07;\n\t\t\t8: hex2 = 8'h08;\n\t\t\t9: hex2 = 8'h09;\n\t\t\tdefault: hex2 = 8'h00;\n\t\tendcase\n\t\t\n\t\tcase(bcd0)\n\t\t\t0: hex3 = 8'h00;\n\t\t\t1: hex3 = 8'h01;\n\t\t\t2: hex3 = 8'h02;\n\t\t\t3: hex3 = 8'h03;\n\t\t\t4: hex3 = 8'h04;\n\t\t\t5: hex3 = 8'h05;\n\t\t\t6: hex3 = 8'h06;\n\t\t\t7: hex3 = 8'h07;\n\t\t\t8: hex3 = 8'h08;\n\t\t\t9: hex3 = 8'h09;\n\t\t\tdefault: hex3 = 8'h00;\n\t\tendcase\n\n\t\tcase(bcd1)\n\t\t\t0: hex4 = 8'h00;\n\t\t\t1: hex4 = 8'h01;\n\t\t\t2: hex4 = 8'h02;\n\t\t\t3: hex4 = 8'h03;\n\t\t\t4: hex4 = 8'h04;\n\t\t\t5: hex4 = 8'h05;\n\t\t\t6: hex4 = 8'h06;\n\t\t\t7: hex4 = 8'h07;\n\t\t\t8: hex4 = 8'h08;\n\t\t\t9: hex4 = 8'h09;\n\t\t\tdefault: hex4 = 8'h00;\n\t\tendcase\n\n\t\tcase(bcd2)\n\t\t\t0: hex5 = 8'h00;\n\t\t\t1: hex5 = 8'h01;\n\t\t\t2: hex5 = 8'h02;\n\t\t\t3: hex5 = 8'h03;\n\t\t\t4: hex5 = 8'h04;\n\t\t\t5: hex5 = 8'h05;\n\t\t\t6: hex5 = 8'h06;\n\t\t\t7: hex5 = 8'h07;\n\t\t\t8: hex5 = 8'h08;\n\t\t\t9: hex5 = 8'h09;\n\t\t\tdefault: hex5 = 8'h00;\n\t\tendcase\n\tend\n\n\n    always @* begin\n        case(char_xy)\n\t\t8'h00: \tchar_code_nxt = 8'h0A; 8'h01:\tchar_code_nxt = 8'h0B; 8'h02:  char_code_nxt = 8'h0C; 8'h03:  char_code_nxt = 8'h0D; 8'h04:  char_code_nxt = 8'h0E; 8'h05:  char_code_nxt = 8'h0F; 8'h06:  char_code_nxt = 8'h10; 8'h07:  char_code_nxt = hex1;  8'h08:  char_code_nxt = 8'h0F; 8'h09:  char_code_nxt = 8'h0F; 8'h0a:  char_code_nxt = 8'h0F; 8'h0b:  char_code_nxt = 8'h0F; 8'h0c:  char_code_nxt = 8'h0F; 8'h0d:  char_code_nxt = 8'h0F; 8'h0e:  char_code_nxt = 8'h0F; 8'h0f:  char_code_nxt = 8'h0F; 8'h10:  char_code_nxt = 8'h0F; 8'h11:  char_code_nxt = 8'h0F; 8'h12:  char_code_nxt = 8'h0F; 8'h13:  char_code_nxt = 8'h0F; 8'h14:  char_code_nxt = 8'h0F; 8'h15:  char_code_nxt = 8'h0F; 8'h16:  char_code_nxt = 8'h0F; 8'h17:  char_code_nxt = 8'h0F; 8'h18:  char_code_nxt = 8'h0F; 8'h19:  char_code_nxt = 8'h0F; 8'h1a:  char_code_nxt = 8'h0F; 8'h1b:  char_code_nxt = 8'h0F; 8'h1c:  char_code_nxt = 8'h0F; 8'h1d:  char_code_nxt = 8'h0F; 8'h1e:  char_code_nxt = 8'h0F; 8'h1f:  char_code_nxt = 8'h0F; 8'h20:  char_code_nxt = 8'h11; 8'h21:  char_code_nxt = 8'h0F; 8'h22:  char_code_nxt = 8'h10; 8'h23:  char_code_nxt = hex5;  8'h24:  char_code_nxt = hex4;  8'h25:  char_code_nxt = hex3;  8'h26:  char_code_nxt = 8'h0F; 8'h27:  char_code_nxt = 8'h0F; 8'h28:  char_code_nxt = 8'h0F; 8'h29:  char_code_nxt = 8'h0F; 8'h2a:  char_code_nxt = 8'h0F; 8'h2b:  char_code_nxt = 8'h0F; 8'h2c:  char_code_nxt = 8'h0F; 8'h2d:  char_code_nxt = 8'h0F; 8'h2e:  char_code_nxt = 8'h0F; 8'h2f:  char_code_nxt = 8'h0F; 8'h30:  char_code_nxt = 8'h0F; 8'h31:  char_code_nxt = 8'h0F; 8'h32:  char_code_nxt = 8'h0F; 8'h33:  char_code_nxt = 8'h0F; 8'h34:  char_code_nxt = 8'h0F; 8'h35:  char_code_nxt = 8'h0F; 8'h36:  char_code_nxt = 8'h0F; 8'h37:  char_code_nxt = 8'h0F; 8'h38:  char_code_nxt = 8'h0F; 8'h39:  char_code_nxt = 8'h0F; 8'h3a:  char_code_nxt = 8'h0F; 8'h3b:  char_code_nxt = 8'h0F; 8'h3c:  char_code_nxt = 8'h0F; 8'h3d:  char_code_nxt = 8'h0F; 8'h3e:  char_code_nxt = 8'h12; 8'h3f:  char_code_nxt = 8'h13; 8'h40:  char_code_nxt = 8'h14; 8'h41:  char_code_nxt = 8'h13; 8'h42:  char_code_nxt = 8'h12; 8'h43:  char_code_nxt = 8'h0F; 8'h44:  char_code_nxt = hex2;  default: char_code_nxt = 8'hff;\n\t\tendcase\n\tend\n\n    assign char_code = char_code_nxt;\n\nendmodule\n",
        "module_name": "MarioScore24x1",
        "module_hash": "f1ad80ff11df9280e3b631b4018f780e",
        "dataset_index": 19701
      },
      "memory_3de214e9": {
        "rtl_code": "\nmodule memory(\n    input [5:0] a,\n    input [31:0] d,\n    input clk,\n    input we,\n    output [31:0] spo\n);\n\nwire [31:0] mem_out;\n\nreg [31:0] mem [63:0];\n\nassign spo = mem_out;\n\nalways @(posedge clk) begin\n    if (we) begin\n        mem[a] <= d;\n    end\nend\n\nassign mem_out = mem[a];\n\nendmodule",
        "module_name": "memory",
        "module_hash": "3de214e918a8f5854b3403b87fa12f14",
        "dataset_index": 1847
      },
      "packet_resizer_variable_e9003bbf": {
        "rtl_code": "module packet_resizer_variable\n   (input clk, input reset,\n    input [15:0] next_dst_sid,\n    input [15:0] pkt_size,\n    input [31:0] i_tdata, input [127:0] i_tuser, input i_tlast, input i_tvalid, output i_tready,\n    output [31:0] o_tdata, output [127:0] o_tuser, output o_tlast, output o_tvalid, input o_tready);\n\n   reg [15:0]     count;\n   reg            first_packet_in_burst = 1'b1;\n\n   wire [1:0]     TYPE_in = i_tuser[127:126];\n   wire           TSI_in = i_tuser[125];\n   wire           EOB_in = i_tuser[124];\n   wire [11:0]    SEQ_in = i_tuser[123:112];\n   wire [15:0]    LEN_in = i_tuser[111:96];\n   wire [15:0]    SRC_in = i_tuser[95:80];\n   wire [15:0]    DST_in = i_tuser[79:64];\n   wire [63:0]    TIME_in = i_tuser[63:0];\n   \n   wire [1:0]     TYPE_out = TYPE_in;\n   wire           TSI_out = TSI_in & first_packet_in_burst;\n   wire           EOB_out = EOB_in & i_tlast;\n   wire [11:0]    SEQ_out = SEQ_in;     wire [15:0]    LEN_out = LEN_in;     wire [15:0]    SRC_out = DST_in;\n   wire [15:0]    DST_out = next_dst_sid;\n   wire [63:0]    TIME_out = TIME_in;\n\n   assign o_tdata = i_tdata;\n   assign o_tlast = (count == pkt_size) | EOB_out;   \n   assign o_tuser = { TYPE_out, TSI_out, EOB_out, SEQ_out, LEN_out, SRC_out, DST_out, TIME_out };\n\n   assign o_tvalid = i_tvalid;\n   assign i_tready = o_tready;\n\n   always @(posedge clk)\n     if(reset)\n       count <= 16'd1;\n     else\n       if(o_tvalid & o_tready)\n         if(o_tlast)\n           count <= 16'd1;\n         else\n           count <= count + 16'd1;\n\n   always @(posedge clk)\n     if(reset)\n       first_packet_in_burst <= 1'b1;\n     else\n       if(o_tvalid & o_tready & o_tlast)\n         first_packet_in_burst <= EOB_out;\n   \nendmodule ",
        "module_name": "packet_resizer_variable",
        "module_hash": "e9003bbfbdf4c97886b0c47bbe354e9d",
        "dataset_index": 23887
      },
      "i2c_test01_de0f69cc": {
        "rtl_code": "module i2c_test01(clk, rst, nReset, al);\n\n\tinput clk, rst, nReset;\n\toutput reg al;\n\n\treg cmd_stop;\n\talways @(posedge clk or negedge nReset)\n\t  if (~nReset)\n\t    cmd_stop <= #1 1'b0;\n\t  else if (rst)\n\t    cmd_stop <= #1 1'b0;\n\n\talways @(posedge clk or negedge nReset)\n\t  if (~nReset)\n\t    al <= #1 1'b0;\n\t  else if (rst)\n\t    al <= #1 1'b0;\n\t  else\n\t    al <= #1 ~cmd_stop;\n\nendmodule\n\nmodule i2c_test02(clk, slave_wait, clk_cnt, cmd, cmd_stop, cnt);\n\n\tinput clk, slave_wait, clk_cnt;\n\tinput cmd;\n\n\toutput reg cmd_stop;\n\n\treg clk_en;\n\toutput reg [15:0] cnt;\n\n\talways @(posedge clk)\n\t  if (~|cnt)\n\t    if (~slave_wait)\n\t      begin\n\t          cnt    <= #1 clk_cnt;\n\t          clk_en <= #1 1'b1;\n\t      end\n\t    else\n\t      begin\n\t          cnt    <= #1 cnt;\n\t          clk_en <= #1 1'b0;\n\t      end\n\t  else\n\t    begin\n                cnt    <= #1 cnt - 16'h1;\n\t        clk_en <= #1 1'b0;\n\t    end\n\n\talways @(posedge clk)\n\t  if (clk_en)\n\t    cmd_stop <= #1 cmd;\n\nendmodule\n\n",
        "module_name": "i2c_test01",
        "module_hash": "de0f69ccf6121110c786296daefe1f34",
        "dataset_index": 25544
      },
      "DEMUX #_76ce2995": {
        "rtl_code": "\nmodule DEMUX #(\n  parameter n = 4 // number of output signals (2^n)\n)(\n  input in,\n  input [clogb2(n)-1:0] sel,\n  output [n-1:0] out\n);\n\nwire [n-1:0] mux_out;\n\nassign mux_out[0] = in;\n\ngenvar i;\ngenerate\n  for (i = 1; i < n; i = i + 1) begin\n    assign mux_out[i] = (sel == i) ? in : 0; // use conditional operator\n  end\nendgenerate\n\n// Drive output signals with MUX output\nassign out = mux_out;\n\nfunction integer clogb2;\n  input integer number;\n  begin\n    clogb2 = 0;\n    while (number > 0) begin\n      number = number >> 1;\n      clogb2 = clogb2 + 1;\n    end\n  end\nendfunction\n\nendmodule",
        "module_name": "DEMUX #",
        "module_hash": "76ce2995d477d278298bcc71b9b044ab",
        "dataset_index": 13276
      },
      "Contador_AD_Minutos_bf53e767": {
        "rtl_code": "\nmodule Contador_AD_Minutos(\n    input rst,\n\t input [7:0]estado,\n\t input [1:0] en,\n    input [7:0] Cambio,\n\t input got_data,\n    input clk,\n    output reg [(N-1):0] Cuenta\n    );\n\t\n\t \n\t parameter N = 6;\n\t parameter X = 59;\n\n    always @(posedge clk)\n\t if (rst)\n\t    Cuenta <= 0;\n    else\tif (en == 2'd1 && (estado == 8'h6C || estado == 8'h75))\n         begin\n\t         if (Cambio == 8'h73 && got_data)\n\t\t\t\tbegin\n\t\t\t\t   if (Cuenta == X)\n\t\t\t\t      Cuenta <= 0;\n\t\t\t\t\telse \n\t\t\t\t      Cuenta <= Cuenta + 1'd1;\n\t\t\t\tend\n\t\t\t\telse if (Cambio == 8'h72 && got_data)\n\t\t\t\t\t  begin\n\t\t\t\t        if (Cuenta == 0)\n\t\t\t\t\t\t     Cuenta <= X;\n\t\t\t\t\t     else \n\t\t\t\t\t\t     Cuenta <= Cuenta - 1'd1;\n\t\t\t\t     end\n\t\t\t\t\t  else \n\t\t\t\t\t     Cuenta <= Cuenta;\n\t      end\n\t      else \n\t\t\t   Cuenta <= Cuenta;\nendmodule\n",
        "module_name": "Contador_AD_Minutos",
        "module_hash": "bf53e76757ce4c0c6d2ec888f8b63cd6",
        "dataset_index": 12892
      },
      "axi_hdmi_tx_vdma_ea774476": {
        "rtl_code": "module axi_hdmi_tx_vdma (\n\n  hdmi_fs_toggle,\n  hdmi_raddr_g,\n\n  vdma_clk,\n  vdma_rst,\n  vdma_fs,\n  vdma_fs_ret,\n  vdma_valid,\n  vdma_data,\n  vdma_ready,\n  vdma_wr,\n  vdma_waddr,\n  vdma_wdata,\n  vdma_fs_ret_toggle,\n  vdma_fs_waddr,\n  vdma_tpm_oos,\n  vdma_ovf,\n  vdma_unf);\n\n  localparam      BUF_THRESHOLD_LO = 9'd3;\n  localparam      BUF_THRESHOLD_HI = 9'd509;\n  localparam      RDY_THRESHOLD_LO = 9'd450;\n  localparam      RDY_THRESHOLD_HI = 9'd500;\n\n  input           hdmi_fs_toggle;\n  input   [ 8:0]  hdmi_raddr_g;\n\n  input           vdma_clk;\n  input           vdma_rst;\n  output          vdma_fs;\n  input           vdma_fs_ret;\n  input           vdma_valid;\n  input   [63:0]  vdma_data;\n  output          vdma_ready;\n  output          vdma_wr;\n  output  [ 8:0]  vdma_waddr;\n  output  [47:0]  vdma_wdata;\n  output          vdma_fs_ret_toggle;\n  output  [ 8:0]  vdma_fs_waddr;\n  output          vdma_tpm_oos;\n  output          vdma_ovf;\n  output          vdma_unf;\n\n  reg             vdma_fs_toggle_m1 = 'd0;\n  reg             vdma_fs_toggle_m2 = 'd0;\n  reg             vdma_fs_toggle_m3 = 'd0;\n  reg             vdma_fs = 'd0;\n  reg     [ 8:0]  vdma_fs_waddr = 'd0;\n  reg             vdma_fs_ret_toggle = 'd0;\n  reg             vdma_wr = 'd0;\n  reg     [ 8:0]  vdma_waddr = 'd0;\n  reg     [47:0]  vdma_wdata = 'd0;\n  reg     [22:0]  vdma_tpm_data = 'd0;\n  reg             vdma_tpm_oos = 'd0;\n  reg     [ 8:0]  vdma_raddr_g_m1 = 'd0;\n  reg     [ 8:0]  vdma_raddr_g_m2 = 'd0;\n  reg     [ 8:0]  vdma_raddr = 'd0;\n  reg     [ 8:0]  vdma_addr_diff = 'd0;\n  reg             vdma_ready = 'd0;\n  reg             vdma_almost_full = 'd0;\n  reg             vdma_almost_empty = 'd0;\n  reg             vdma_ovf = 'd0;\n  reg             vdma_unf = 'd0;\n\n  wire    [47:0]  vdma_tpm_data_s;\n  wire            vdma_tpm_oos_s;\n  wire    [ 9:0]  vdma_addr_diff_s;\n  wire            vdma_ovf_s;\n  wire            vdma_unf_s;\n\n  function [8:0] g2b;\n    input [8:0] g;\n    reg   [8:0] b;\n    begin\n      b[8] = g[8];\n      b[7] = b[8] ^ g[7];\n      b[6] = b[7] ^ g[6];\n      b[5] = b[6] ^ g[5];\n      b[4] = b[5] ^ g[4];\n      b[3] = b[4] ^ g[3];\n      b[2] = b[3] ^ g[2];\n      b[1] = b[2] ^ g[1];\n      b[0] = b[1] ^ g[0];\n      g2b = b;\n    end\n  endfunction\n\n  always @(posedge vdma_clk) begin\n    if (vdma_rst == 1'b1) begin\n      vdma_fs_toggle_m1 <= 'd0;\n      vdma_fs_toggle_m2 <= 'd0;\n      vdma_fs_toggle_m3 <= 'd0;\n    end else begin\n      vdma_fs_toggle_m1 <= hdmi_fs_toggle;\n      vdma_fs_toggle_m2 <= vdma_fs_toggle_m1;\n      vdma_fs_toggle_m3 <= vdma_fs_toggle_m2;\n    end\n    vdma_fs <= vdma_fs_toggle_m2 ^ vdma_fs_toggle_m3;\n    if (vdma_fs_ret == 1'b1) begin\n      vdma_fs_waddr <= vdma_waddr;\n      vdma_fs_ret_toggle <= ~vdma_fs_ret_toggle;\n    end\n  end\n\n  always @(posedge vdma_clk) begin\n    vdma_wr <= vdma_valid & vdma_ready;\n    if (vdma_rst == 1'b1) begin\n      vdma_waddr <= 9'd0;\n    end else if (vdma_wr == 1'b1) begin\n      vdma_waddr <= vdma_waddr + 1'b1;\n    end\n    vdma_wdata <= {vdma_data[55:32], vdma_data[23:0]};\n  end\n\n  assign vdma_tpm_data_s = {vdma_tpm_data, 1'b1, vdma_tpm_data, 1'b0};\n  assign vdma_tpm_oos_s = (vdma_wdata == vdma_tpm_data_s) ? 1'b0 : vdma_wr;\n\n  always @(posedge vdma_clk) begin\n    if ((vdma_rst == 1'b1) || (vdma_fs_ret == 1'b1)) begin\n      vdma_tpm_data <= 23'd0;\n      vdma_tpm_oos <= 1'd0;\n    end else if (vdma_wr == 1'b1) begin\n      vdma_tpm_data <= vdma_tpm_data + 1'b1;\n      vdma_tpm_oos <= vdma_tpm_oos_s;\n    end\n  end\n\n  assign vdma_addr_diff_s = {1'b1, vdma_waddr} - vdma_raddr;\n  assign vdma_ovf_s = (vdma_addr_diff < BUF_THRESHOLD_LO) ? vdma_almost_full : 1'b0;\n  assign vdma_unf_s = (vdma_addr_diff > BUF_THRESHOLD_HI) ? vdma_almost_empty : 1'b0;\n\n  always @(posedge vdma_clk) begin\n    if (vdma_rst == 1'b1) begin\n      vdma_raddr_g_m1 <= 9'd0;\n      vdma_raddr_g_m2 <= 9'd0;\n    end else begin\n      vdma_raddr_g_m1 <= hdmi_raddr_g;\n      vdma_raddr_g_m2 <= vdma_raddr_g_m1;\n    end\n    vdma_raddr <= g2b(vdma_raddr_g_m2);\n    vdma_addr_diff <= vdma_addr_diff_s[8:0];\n    if (vdma_addr_diff >= RDY_THRESHOLD_HI) begin\n      vdma_ready <= 1'b0;\n    end else if (vdma_addr_diff <= RDY_THRESHOLD_LO) begin\n      vdma_ready <= 1'b1;\n    end\n    if (vdma_addr_diff > BUF_THRESHOLD_HI) begin\n      vdma_almost_full <= 1'b1;\n    end else begin\n      vdma_almost_full <= 1'b0;\n    end\n    if (vdma_addr_diff < BUF_THRESHOLD_LO) begin\n      vdma_almost_empty <= 1'b1;\n    end else begin\n      vdma_almost_empty <= 1'b0;\n    end\n    vdma_ovf <= vdma_ovf_s;\n    vdma_unf <= vdma_unf_s;\n  end\n\nendmodule\n\n",
        "module_name": "axi_hdmi_tx_vdma",
        "module_hash": "ea774476ac73d6c5316c691dd2593235",
        "dataset_index": 23456
      },
      "low_blk_mem_gen_0d6e630d": {
        "rtl_code": "module low_blk_mem_gen\n    (\n    output reg [11:0] douta,\n    input clka,\n    input [10:0] addra,\n    input [11:0] dina,\n    input wea\n    );\n\n    reg [11:0] memory [0:2047];\n\n    always @(posedge clka) begin\n        if (wea) begin\n            memory[addra] <= dina;\n        end\n        douta <= memory[addra];\n    end\n\nendmodule",
        "module_name": "low_blk_mem_gen",
        "module_hash": "0d6e630deaa0c091e018d7fb9884f25a",
        "dataset_index": 3148
      },
      "adder_subtractor_0ba1b3ae": {
        "rtl_code": "module adder_subtractor (\n    A,\n    B,\n    C,\n    S,\n    OVF\n);\n\n    input [3:0] A;\n    input [3:0] B;\n    input C;\n    output [3:0] S;\n    output OVF;\n\n    wire [3:0] B_neg;\n    wire [3:0] C_neg;\n    wire [3:0] B_neg_plus_1;\n    wire [3:0] B_minus_C;\n    wire [3:0] A_plus_B;\n    wire [3:0] A_minus_B;\n\n    assign B_neg = ~B + 1;\n    assign C_neg = ~C + 1;\n    assign B_neg_plus_1 = B_neg + 1;\n    assign B_minus_C = B + C_neg;\n    assign A_plus_B = A + B;\n    assign A_minus_B = A + B_neg;\n\n    assign S = (C == 0) ? A_plus_B : A_minus_B;\n    assign OVF = (C == 0) ? ((A_plus_B[3] == 1 && B[3] == 1 && S[3] == 0) || (A_plus_B[3] == 0 && B[3] == 0 && S[3] == 1)) : ((A_minus_B[3] == 1 && B_neg[3] == 1 && S[3] == 0) || (A_minus_B[3] == 0 && B_neg[3] == 0 && S[3] == 1));\n\nendmodule",
        "module_name": "adder_subtractor",
        "module_hash": "0ba1b3ae825fb6843462a8f178952da5",
        "dataset_index": 20313
      },
      "unsigned_sqrt_2a46848c": {
        "rtl_code": "\nmodule unsigned_sqrt (\n    input [3:0] num,\n    output reg [3:0] sqrt\n);\n\nreg [3:0] temp;\n\ninteger i;\n\nalways @(*) begin\n    temp = 0;\n    for (i = 3; i >= 0; i = i - 1) begin\n        temp = (temp << 1) | (num[i]);\n        if (temp >= (i+1)) begin\n            temp = temp - (i+1);\n            sqrt[i] = 1;\n        end else begin\n            sqrt[i] = 0;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "unsigned_sqrt",
        "module_hash": "2a46848cf962aaac85677847bfd90012",
        "dataset_index": 17413
      },
      "bt_transmitter #_aecc15ea": {
        "rtl_code": "module bt_transmitter #(\n  parameter n = 8,\n  parameter m = 8\n) (\n  input [n-1:0] data_in,\n  input clk,\n  input reset,\n  output reg tx_en,\n  output reg [m-1:0] tx_out\n);\n\n  parameter baud_rate = 9600;\n  integer counter;\n  reg [n-1:0] data_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      counter <= 0;\n      tx_en <= 0;\n      tx_out <= 0;\n    end else begin\n      if (counter == 0) begin\n        counter <= (50_000_000 / baud_rate) - 1;\n        data_reg <= data_in;\n        tx_en <= 1;\n        tx_out <= data_reg;\n        data_reg <= data_reg >> 1;\n      end else begin\n        counter <= counter - 1;\n      end\n    end\n  end\nendmodule\n\nmodule bt_receiver #(\n  parameter n = 8,\n  parameter m = 8\n) (\n  input [n-1:0] rx_in,\n  input clk,\n  input reset,\n  output reg rx_en,\n  output reg [m-1:0] data_out\n);\n\n  parameter baud_rate = 9600;\n  integer counter;\n  reg [n-1:0] data_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      counter <= 0;\n      rx_en <= 0;\n      data_out <= 0;\n    end else begin\n      if (counter == 0) begin\n        counter <= (50_000_000 / baud_rate) - 1;\n        data_reg <= rx_in;\n        rx_en <= 1;\n        data_out <= data_reg;\n        data_reg <= data_reg >> 1;\n      end else begin\n        counter <= counter - 1;\n      end\n    end\n  end\nendmodule",
        "module_name": "bt_transmitter #",
        "module_hash": "aecc15ea2bf97f9e2b255d48095910a8",
        "dataset_index": 444
      },
      "mux_parity_77db2b4d": {
        "rtl_code": "\nmodule mux_parity (\n    input [7:0] a, // 8-bit input a\n    input [7:0] b, // 8-bit input b\n    input sel_b1, // Select input 1 for 2-to-1 MUX\n    input sel_b2, // Select input 2 for 2-to-1 MUX\n    output [8:0] out // 9-bit output with parity bit added as MSB\n);\n\nwire [7:0] mux_out;\nwire parity;\n\nmux_2to1 mux_inst (\n    .in0(a),\n    .in1(b),\n    .sel(sel_b1),\n    .out(mux_out)\n);\n\nparity_generator parity_inst (\n    .in(mux_out),\n    .out(parity)\n);\n\n// Connect the parity signal to the output\nassign out = {parity, mux_out};\n\nendmodule\n\nmodule mux_2to1 (\n    input [7:0] in0, // Input 0\n    input [7:0] in1, // Input 1\n    input sel, // Select input\n    output [7:0] out // Output\n);\n\nassign out = sel ? in1 : in0;\n\nendmodule\n\nmodule parity_generator (\n    input [7:0] in, // Input byte\n    output out // Parity bit\n);\n\nassign out = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n",
        "module_name": "mux_parity",
        "module_hash": "77db2b4d9cb5d5f84f641495bdc5fc2c",
        "dataset_index": 18816
      },
      "adder_49271cbf": {
        "rtl_code": "\nmodule adder(\n    input wire clk,\n    input wire reset_n,\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [7:0] sum,\n    output wire carry\n);\n\n    reg [8:0] temp_sum;\n    reg carry_reg;\n    \n    always @ (posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            temp_sum <= 0;\n            carry_reg <= 0;\n        end else begin\n            {carry_reg, temp_sum} <= a + b;\n        end\n    end\n    \n    assign carry = carry_reg;\n    assign sum = temp_sum[7:0];\n\nendmodule\n",
        "module_name": "adder",
        "module_hash": "49271cbf0c8bf706ab8571e483c9a153",
        "dataset_index": 19719
      },
      "mux4to1_edebb287": {
        "rtl_code": "module mux4to1(\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output reg Y\n);\n\nalways @(*) begin\n    case(S)\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule",
        "module_name": "mux4to1",
        "module_hash": "edebb28713bff46186e37446489d05b6",
        "dataset_index": 9243
      },
      "CAM #_3e413505": {
        "rtl_code": "\nmodule CAM #(\n  parameter n = 8, // number of bits in data\n  parameter m = 4 // number of bits in search key\n)(\n  input [n-1:0] data_in,\n  input [m-1:0] search_key,\n  output match,\n  output reg [n-1:0] data_out\n);\n\nreg [n-1:0] stored_data = 0; // Initialized to 0 to avoid linting errors\nreg match = 0;\n\nalways @ (search_key, data_in) begin\n  if (search_key == stored_data) begin\n    match = 1;\n    data_out <= stored_data;\n  end else begin\n    match = 0;\n    data_out <= 0;\n  end\nend\n\nendmodule",
        "module_name": "CAM #",
        "module_hash": "3e413505361e649daf572a41fc5ee101",
        "dataset_index": 9126
      },
      "nor4_d2ea53ee": {
        "rtl_code": "module nor4 (\n    input  A,\n    input  B,\n    input  C,\n    input  D,\n    output Y\n);\n\n    assign Y = ~(A | B | C | D);\n\nendmodule",
        "module_name": "nor4",
        "module_hash": "d2ea53ee33a02fa451e5ca0e02b03bc3",
        "dataset_index": 11594
      },
      "MX2X4A12TR_a1dc4802": {
        "rtl_code": "module MX2X4A12TR (A, B, S0, Y);\n  input A, B, S0;\n  output Y;\n  wire N1, N2, N3, N4, N5, N6;\n  \n  not (N1, B);\n  and (N2, A, B);\n  and (N3, S0, N1);\n  and (N4, S0, A);\n  not (N5, N1);\n  or (N6, N2, N4);\n  or (Y, N3, N5, N6);\nendmodule",
        "module_name": "MX2X4A12TR",
        "module_hash": "a1dc48026584d16cc2629b9de16f8bbe",
        "dataset_index": 7384
      },
      "priority_encoder_bd61b793": {
        "rtl_code": "\nmodule priority_encoder (\n    input [7:0] I,\n    output reg EN,\n    output reg [2:0] Y\n);\n\nalways @(*) begin\n    case (I)\n        8'b00000001: begin\n            EN = 1'b0;\n            Y = 3'b000;\n        end\n        8'b00000010: begin\n            EN = 1'b0;\n            Y = 3'b001;\n        end\n        8'b00000100: begin\n            EN = 1'b0;\n            Y = 3'b010;\n        end\n        8'b00001000: begin\n            EN = 1'b0;\n            Y = 3'b011;\n        end\n        8'b00010000: begin\n            EN = 1'b0;\n            Y = 3'b100;\n        end\n        8'b00100000: begin\n            EN = 1'b0;\n            Y = 3'b101;\n        end\n        8'b01000000: begin\n            EN = 1'b0;\n            Y = 3'b110;\n        end\n        8'b10000000: begin\n            EN = 1'b0;\n            Y = 3'b111;\n        end\n        default: begin\n            EN = 1'b1;\n            Y = 3'b000;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "priority_encoder",
        "module_hash": "bd61b7932933af1ad355646ec6a5166c",
        "dataset_index": 21443
      },
      "clock_divider_0de21add": {
        "rtl_code": "\n\n\nmodule clock_divider\n#(\n    parameter DIVISOR = 40000000\n)\n(\n    input wire        CLK,\n    input wire        RESET,\n    output reg        CE, output reg        CLOCK );\n\ninteger counter_ce;\ninitial counter_ce = 0;\ninteger counter_clk;\ninitial counter_clk = 0;\ninitial CLOCK = 1'b0;\ninitial CE = 1'b0;\n\nalways @ (posedge CLK or posedge RESET)\n    begin\n        if (RESET == 1'b1)\n            begin\n                CE <= 1'b0;\n            end\n        else\n            begin\n                if (counter_ce == 0)\n                    begin\n                        CE <= 1'b1;\n                    end\n                else\n                    begin\n                        CE <= 1'b0;\n                    end\n            end\n    end\n    \nalways @ (posedge CLK or posedge RESET)\n    begin\n        if (RESET == 1'b1)\n            begin\n                counter_ce <= 0;\n            end\n        else\n            begin\n                if (counter_ce == (DIVISOR - 1))\n                    counter_ce <= 0;\n                else\n                    counter_ce <= counter_ce + 1;\n            end\n    end\n\nalways @ (posedge CLK or posedge RESET)\n    begin\n        if (RESET == 1'b1)\n            begin\n                CLOCK <= 1'b0;\n            end\n        else\n            begin\n                if (counter_clk == 0)\n                    begin\n                        CLOCK <= ~CLOCK;\n                    end\n                else\n                    begin\n                        CLOCK <= CLOCK;\n                    end\n            end\n    end\n    \nalways @ (posedge CLK or posedge RESET)\n    begin\n        if (RESET == 1'b1)\n            begin\n                counter_clk <= 0;\n            end\n        else\n            begin\n                if (counter_clk == ((DIVISOR >> 1) - 1)) counter_clk <= 0;\n                else\n                    counter_clk <= counter_clk + 1;\n            end\n    end\n\nendmodule\n",
        "module_name": "clock_divider",
        "module_hash": "0de21add37e4f7b7bfd11208d183c6c0",
        "dataset_index": 23884
      },
      "six_signal__dd5d8e43": {
        "rtl_code": "module six_signal_module (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    output Y\n);\n\n    assign Y = (A1 & A2) | (B1 & B2) | (C1 & (A1 | A2));\n\nendmodule",
        "module_name": "six_signal_",
        "module_hash": "dd5d8e43885d17b1cd9bf434f23a3c76",
        "dataset_index": 20918
      },
      "PIO_TO_CTRL #_917f7ae2": {
        "rtl_code": "\n\nmodule PIO_TO_CTRL #(\n  parameter TCQ = 1\n) (\n  input               clk,\n  input               rst_n,\n\n  input               req_compl,\n  input               compl_done,\n\n  input               cfg_to_turnoff,\n  output  reg         cfg_turnoff_ok\n  );\n\n  reg                 trn_pending;\n\n\n\n  always @ ( posedge clk ) begin\n\n    if (!rst_n )\n    begin\n\n      trn_pending <= #TCQ 0;\n\n    end\n    else\n    begin\n\n      if (!trn_pending && req_compl)\n\n        trn_pending <= #TCQ 1'b1;\n\n      else if (compl_done)\n\n        trn_pending <= #TCQ 1'b0;\n\n    end\n\n  end\n\n\n  always @ ( posedge clk ) begin\n\n    if (!rst_n )\n    begin\n\n      cfg_turnoff_ok <= #TCQ 1'b0;\n\n    end\n    else\n    begin\n\n      if ( cfg_to_turnoff  && !trn_pending)\n        cfg_turnoff_ok <= #TCQ 1'b1;\n      else\n        cfg_turnoff_ok <= #TCQ 1'b0;\n\n    end\n\n  end\n\n\nendmodule ",
        "module_name": "PIO_TO_CTRL #",
        "module_hash": "917f7ae222bb7eba5dcd380fba9d1cff",
        "dataset_index": 23959
      },
      "Bit_Shifting #_6a258d10": {
        "rtl_code": "module Bit_Shifting #(\n  parameter n = 8, // number of bits in data_in\n  parameter log2n = 3 // log2(n), used for shift_amt width\n)(\n  input [n-1:0] data_in,\n  input [log2n-1:0] shift_amt,\n  input [1:0] shift_type,\n  output [n-1:0] data_out\n);\n\n\nreg [n-1:0] shifted_data; // temporary variable for storing shifted data\n\n// Left shift operation\nalways @(*) begin\n  case(shift_type)\n    2'b00: shifted_data = data_in << shift_amt; // logical left shift\n    2'b01: shifted_data = data_in >>> shift_amt; // arithmetic right shift\n    2'b10: shifted_data = data_in >> shift_amt; // logical right shift\n    default: shifted_data = data_in; // no shift\n  endcase\nend\n\n// Output the shifted data\nassign data_out = shifted_data;\n\nendmodule",
        "module_name": "Bit_Shifting #",
        "module_hash": "6a258d1066c2ca865c82340410fb855c",
        "dataset_index": 3282
      },
      "sky130_fd_sc_ls__einvn_0112b398": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__einvn (\n    Z   ,\n    A   ,\n    TE_B\n);\n\n    output Z   ;\n    input  A   ;\n    input  TE_B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    notif0 notif00 (Z     , A, TE_B        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__einvn",
        "module_hash": "0112b398e72bff05b8716be4268fb5df",
        "dataset_index": 23559
      },
      "siete_segmentos_principal_a1df5b91": {
        "rtl_code": "\nmodule siete_segmentos_principal(\n    input wire bitA,\n    input wire bitB,\n    input wire bitC,\n    input wire bitD,\n\t input wire en1,\n\t input wire en2,\n\t input wire en3,\n\t input wire en4,\n    output seg_a,\n    output seg_b,\n    output seg_c,\n    output seg_d,\n    output seg_e,\n    output seg_f,\n    output seg_g,\n\t output s_seg1,\n\t output s_seg2,\n\t output s_seg3,\n\t output s_seg4\n    );\n\t \n\t assign s_seg1 = !en1;\n\t assign s_seg2 = !en2;\n\t assign s_seg3 = !en3;\n\t assign s_seg4 = !en4;\n\t assign seg_a = !((!bitB&!bitD)|(!bitA&bitC)|(!bitA&bitB&bitD)|(bitB&bitC)|(bitA&!bitD)|(bitA&!bitB&!bitC));\n\t assign seg_b = !((bitA&!bitC&bitD)|(!bitB&!bitD)|(!bitA&!bitC&!bitD)|(!bitA&bitC&bitD)|(!bitA&!bitB));\n\t assign seg_c = !((!bitC&bitD)|(!bitA&bitB)|(bitA&!bitB)|(!bitA&!bitC)|(!bitA&bitD));\n\t assign seg_d = !((bitB&!bitC&bitD)|(!bitB&bitC&bitD)|(bitB&bitC&!bitD)|(bitA&!bitC)|(!bitA&!bitB&!bitD));\n\t assign seg_e = !((!bitB&!bitD)|(bitC&!bitD)|(bitA&bitC)|(bitA&bitB));\n\t assign seg_f = !((!bitC&!bitD)|(bitB&!bitD)|(!bitA&bitB&!bitC)|(bitA&!bitB)|(bitA&bitC));\n\t assign seg_g = !((!bitB&bitC)|(bitA&!bitB)|(bitA&bitD)|(bitC&!bitD)|(!bitA&bitB&!bitC));\n\nendmodule\n",
        "module_name": "siete_segmentos_principal",
        "module_hash": "a1df5b910ab579c29aed63776f690e10",
        "dataset_index": 4498
      },
      "toggle2pulse_b095c32e": {
        "rtl_code": "\nmodule toggle2pulse(\n   out,\n   clk, in, reset\n   );\n   \n   input  clk; \n   \n   input  in;   \n   output out;\n\n   input  reset;\n   reg \t  out_reg;\n         \n   always @ (posedge clk)\n     if(reset)\n       out_reg <= 1'b0;\n     else\n       out_reg <= in;\n      \n   assign out = in ^ out_reg;\n\nendmodule \n\n\n",
        "module_name": "toggle2pulse",
        "module_hash": "b095c32ed44d8f706220b1d92b1ba6ca",
        "dataset_index": 25053
      },
      "glitch_filter #_069b32f2": {
        "rtl_code": "module glitch_filter #(\n  parameter n = 8, // number of bits in the input signal\n  parameter t = 2 // duration of the glitch (in clock cycles)\n) (\n  input wire clk,\n  input wire reset,\n  input wire [n-1:0] sig_in,\n  output wire [n-1:0] sig_out\n);\n\nreg [n-1:0] delay_line [0:t-1];\nreg [n-1:0] sig_out_reg;\ninteger i;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    for (i = 0; i < t; i = i + 1) begin\n      delay_line[i] <= 0;\n    end\n    sig_out_reg <= 0;\n  end else begin\n    for (i = t - 1; i > 0; i = i - 1) begin\n      delay_line[i] <= delay_line[i - 1];\n    end\n    delay_line[0] <= sig_in;\n\n    if (sig_in == delay_line[t - 1]) begin\n      sig_out_reg <= sig_in;\n    end\n  end\nend\n\nassign sig_out = sig_out_reg;\n\nendmodule",
        "module_name": "glitch_filter #",
        "module_hash": "069b32f2219609ce39d50d589896ec04",
        "dataset_index": 17306
      },
      "simple_calculator_700aa85d": {
        "rtl_code": "\nmodule simple_calculator(\n    input clk,\n    input reset,\n    input signed [7:0] A,\n    input signed [7:0] B,\n    input [1:0] op,\n    output reg signed [15:0] result,\n    output reg valid\n);\n\nreg signed [15:0] temp;\n\nalways @(*) begin\n    case(op)\n        2'b00: temp = A + B; // addition\n        2'b01: temp = A - B; // subtraction\n        2'b10: temp = A * B; // multiplication\n        2'b11: temp = A / B; // division\n        default: temp = 16'b0; // default to 0\n    endcase\nend\n\nalways @(posedge clk) begin\n    if(reset) begin\n        result <= 16'b0;\n        valid <= 1'b0;\n    end else begin\n        result <= temp;\n        valid <= 1'b1;\n    end\nend\n\nendmodule\n",
        "module_name": "simple_calculator",
        "module_hash": "700aa85d0e2bd102192e74da49da07ef",
        "dataset_index": 15756
      },
      "ripple_carry_adder_8399614c": {
        "rtl_code": "\nmodule ripple_carry_adder (\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput C_in,\n\tinput clk,\n\toutput [3:0] S,\n\toutput C_out\n);\n\n\treg [3:0] S_reg;\n\treg C_out_reg;\n\n\talways @(posedge clk) begin\n\t\t// calculate the sum of A, B, and C_in\n\t\tS_reg = A + B + C_in;\n\n\t\t// calculate the carry-out bit\n\t\tC_out_reg = ((A[3] & B[3]) | (A[3] & C_in) | (B[3] & C_in));\n\tend\n\n\t// assign outputs\n\tassign S = S_reg;\n\tassign C_out = C_out_reg;\n\nendmodule\n",
        "module_name": "ripple_carry_adder",
        "module_hash": "8399614c4cd8c5c93c9989e4ad30e167",
        "dataset_index": 18267
      },
      "four_bit_adder_3a7469c0": {
        "rtl_code": "module four_bit_adder (A, B, Cin, Clk, Sum, Cout);\ninput [3:0] A;\ninput [3:0] B;\ninput Cin;\ninput Clk;\noutput [3:0] Sum;\noutput Cout;\n\nreg [3:0] Sum_reg;\nreg Cout_reg;\n\nalways @(posedge Clk) begin\n    Sum_reg <= A + B + Cin;\n    Cout_reg <= (A[3] & B[3]) | (A[3] & Cin) | (B[3] & Cin);\nend\n\nassign Sum = Sum_reg;\nassign Cout = Cout_reg;\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "3a7469c0f8f3aa7b18e80622dcb608a3",
        "dataset_index": 13006
      },
      "LCD_driver_9fc074b9": {
        "rtl_code": "module LCD_driver (\n  input clk,\n  input [15:0] data,\n  input [3:0] ctrl,\n  output [15:0] addr,\n  output busy\n);\n\n  reg [7:0] lcd_data;\n  reg [3:0] lcd_ctrl;\n  reg [3:0] state;\n  reg [3:0] counter;\n  reg busy_reg;\n\n  parameter IDLE = 4'b0000;\n  parameter WRITE_CMD = 4'b0001;\n  parameter WRITE_DATA = 4'b0010;\n  parameter CLEAR_SCREEN = 4'b0011;\n\n  parameter LCD_BUSY_TIME = 4;\n\n  always @(posedge clk) begin\n    case(state)\n      IDLE: begin\n        if(ctrl == 4'b0001) begin\n          lcd_ctrl <= 4'b0000;\n          lcd_data <= 8'b00000001;\n          state <= WRITE_CMD;\n          counter <= 4'b0000;\n          busy_reg <= 1'b1;\n        end else if(ctrl == 4'b0010) begin\n          lcd_ctrl <= 4'b0000;\n          lcd_data <= data[7:0];\n          state <= WRITE_DATA;\n          counter <= 4'b0000;\n          busy_reg <= 1'b1;\n        end else if(ctrl == 4'b0011) begin\n          lcd_ctrl <= 4'b0000;\n          lcd_data <= 8'b00000001;\n          state <= CLEAR_SCREEN;\n          counter <= 4'b0000;\n          busy_reg <= 1'b1;\n        end else begin\n          busy_reg <= 1'b0;\n        end\n      end\n\n      WRITE_CMD: begin\n        if(counter < LCD_BUSY_TIME) begin\n          counter <= counter + 1;\n          busy_reg <= 1'b1;\n        end else begin\n          lcd_ctrl <= 4'b0001;\n          state <= IDLE;\n          counter <= 4'b0000;\n          busy_reg <= 1'b0;\n        end\n      end\n\n      WRITE_DATA: begin\n        if(counter < LCD_BUSY_TIME) begin\n          counter <= counter + 1;\n          busy_reg <= 1'b1;\n        end else begin\n          lcd_ctrl <= 4'b0001;\n          lcd_data <= data[15:8];\n          state <= IDLE;\n          counter <= 4'b0000;\n          busy_reg <= 1'b0;\n        end\n      end\n\n      CLEAR_SCREEN: begin\n        if(counter < LCD_BUSY_TIME) begin\n          counter <= counter + 1;\n          busy_reg <= 1'b1;\n        end else begin\n          lcd_ctrl <= 4'b0001;\n          state <= IDLE;\n          counter <= 4'b0000;\n          busy_reg <= 1'b0;\n        end\n      end\n    endcase\n  end\n\n  assign addr = 16'b0000000000000000;\n  assign busy = busy_reg;\n\nendmodule",
        "module_name": "LCD_driver",
        "module_hash": "9fc074b91db49485d49be8898b833eb4",
        "dataset_index": 5338
      },
      "integrate_d17458a9": {
        "rtl_code": "module integrate\n  #(parameter INPUTW = 16,\n    parameter ACCUMW = 32,\n    parameter OUTPUTW = 16)\n\n   (input clk_i,\n    input rst_i,\n    input ena_i,\n\n    input dump_i,\n    input [INPUTW-1:0] data_i,\n\n    output reg stb_o,\n    output reg [OUTPUTW-1:0] integ_o\n   );\n   \n   wire [ACCUMW-1:0] data_ext = {{ACCUMW-INPUTW{data_i[INPUTW-1]}},data_i};\n   reg  [ACCUMW-1:0] accum;\n\n   always @(posedge clk_i)\n     if (rst_i | ~ena_i)\n       begin\n\t  accum <= 0;\n\t  integ_o <= 0;\n       end\n     else\n       if (dump_i)\n\t begin\n\t    integ_o <= accum[ACCUMW-1:ACCUMW-OUTPUTW];\n\t    accum <= data_ext;\n\t end\n       else\n\t accum <= accum + data_ext;\n\n   always @(posedge clk_i)\n     stb_o <= dump_i;\n   \nendmodule ",
        "module_name": "integrate",
        "module_hash": "d17458a9dd0fee2d61c57427fc80192c",
        "dataset_index": 24512
      },
      "pfpu_fmul_395ea131": {
        "rtl_code": "\n\nmodule pfpu_fmul(\n\tinput sys_clk,\n\tinput alu_rst,\n\t\n\tinput [31:0] a,\n\tinput [31:0] b,\n\tinput valid_i,\n\t\n\toutput reg [31:0] r,\n\toutput reg valid_o\n);\n\nwire\t\ta_sign = a[31];\nwire [7:0]\ta_expn = a[30:23];\nwire [23:0]\ta_mant = {1'b1, a[22:0]};\n\nwire\t\tb_sign = b[31];\nwire [7:0]\tb_expn = b[30:23];\nwire [23:0]\tb_mant = {1'b1, b[22:0]};\n\nreg\t\tr_zero;\nreg\t\tr_sign;\nreg [7:0]\tr_expn;\nreg [23:0]\tr_a_mant;\nreg [23:0]\tr_b_mant;\n\nreg r_valid;\n\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr_valid <= 1'b0;\n\telse\n\t\tr_valid <= valid_i;\n\tr_zero <= (a_expn == 8'd0)|(b_expn == 8'd0);\n\tr_sign <= a_sign ^ b_sign;\n\tr_expn <= a_expn + b_expn - 8'd127;\n\tr_a_mant <= a_mant;\n\tr_b_mant <= b_mant;\nend\n\n\nreg\t\tr1_zero;\nreg\t\tr1_sign;\nreg [7:0]\tr1_expn;\nreg [47:0]\tr1_mant;\n\nreg r1_valid;\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr1_valid <= 1'b0;\n\telse\n\t\tr1_valid <= r_valid;\n\tr1_zero <= r_zero;\n\tr1_sign <= r_sign;\n\tr1_expn <= r_expn;\n\tr1_mant <= r_a_mant*r_b_mant;\nend\n\n\nreg\t\tr2_zero;\nreg\t\tr2_sign;\nreg [7:0]\tr2_expn;\nreg [47:0]\tr2_mant;\n\nreg r2_valid;\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr2_valid <= 1'b0;\n\telse\n\t\tr2_valid <= r1_valid;\n\tr2_zero <= r1_zero;\n\tr2_sign <= r1_sign;\n\tr2_expn <= r1_expn;\n\tr2_mant <= r1_mant;\nend\n\n\nreg\t\tr3_zero;\nreg\t\tr3_sign;\nreg [7:0]\tr3_expn;\nreg [47:0]\tr3_mant;\n\nreg r3_valid;\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr3_valid <= 1'b0;\n\telse\n\t\tr3_valid <= r2_valid;\n\tr3_zero <= r2_zero;\n\tr3_sign <= r2_sign;\n\tr3_expn <= r2_expn;\n\tr3_mant <= r2_mant;\nend\n\n\nreg\t\tr4_zero;\nreg\t\tr4_sign;\nreg [7:0]\tr4_expn;\nreg [47:0]\tr4_mant;\n\nreg r4_valid;\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tr4_valid <= 1'b0;\n\telse\n\t\tr4_valid <= r3_valid;\n\tr4_zero <= r3_zero;\n\tr4_sign <= r3_sign;\n\tr4_expn <= r3_expn;\n\tr4_mant <= r3_mant;\nend\n\n\nalways @(posedge sys_clk) begin\n\tif(alu_rst)\n\t\tvalid_o <= 1'b0;\n\telse\n\t\tvalid_o <= r4_valid;\n\tif(r4_zero)\n\t\tr <= {1'bx, 8'd0, 23'bx};\n\telse begin\n\t\tif(~r4_mant[47])\n\t\t\tr <= {r4_sign, r4_expn,      r4_mant[45:23]};\n\t\telse\n\t\t\tr <= {r4_sign, r4_expn+8'd1, r4_mant[46:24]};\n\tend\nend\n\nendmodule\n",
        "module_name": "pfpu_fmul",
        "module_hash": "395ea1311b918708f91eb0fa90c62161",
        "dataset_index": 24219
      },
      "mult12_8_3c667f0f": {
        "rtl_code": "module mult12_8 (\n    clock,\n    dataa,\n    datab,\n    result\n);\n\ninput   clock;\ninput   [11:0]  dataa;\ninput   [7:0]   datab;\noutput  [19:0]  result;\n\nreg     [19:0]  temp_result;\n\nalways @ (posedge clock) begin\n    temp_result <= {dataa, 8'b0} * {8'b0, datab};\nend\n\nassign result = temp_result;\n\nendmodule",
        "module_name": "mult12_8",
        "module_hash": "3c667f0f0c6ca53389e3d490b6dfa448",
        "dataset_index": 9264
      },
      "my_mux_e6a962a1": {
        "rtl_code": "module my_mux (\n    input [2:0] select,\n    input [7:0] input_data,\n    output reg output_data\n);\n\n  always @* begin\n    case (select)\n      3'b000: output_data = input_data[0];\n      3'b001: output_data = input_data[1];\n      3'b010: output_data = input_data[2];\n      3'b011: output_data = input_data[3];\n      3'b100: output_data = input_data[4];\n      3'b101: output_data = input_data[5];\n      3'b110: output_data = input_data[6];\n      3'b111: output_data = input_data[7];\n    endcase\n  end\nendmodule",
        "module_name": "my_mux",
        "module_hash": "e6a962a1c855400c81a5dac632930be2",
        "dataset_index": 1526
      },
      "axis_bayer_extractor #_b2b0546e": {
        "rtl_code": "\nmodule axis_bayer_extractor #\n(\n    parameter integer C_PIXEL_WIDTH = 8,\n    parameter integer C_BYPASS = 0,\n    parameter integer C_COL_ODD = 0,\n    parameter integer C_ROW_ODD = 0\n\n) (\n    input  wire clk,\n    input  wire resetn,\n\n    input  wire s_axis_tvalid,\n    input  wire [C_PIXEL_WIDTH-1:0] s_axis_tdata,\n    input  wire s_axis_tuser,\n    input  wire s_axis_tlast,\n    output wire  s_axis_tready,\n\n    output wire m_axis_tvalid,\n    output wire [C_PIXEL_WIDTH-1:0] m_axis_tdata,\n    output wire m_axis_tuser,\n    output wire m_axis_tlast,\n    input  wire m_axis_tready\n);\ngenerate\n    if (C_BYPASS == 1) begin: direct_connect\n        assign m_axis_tvalid = s_axis_tvalid;\n        assign m_axis_tdata[C_PIXEL_WIDTH-1:0] = s_axis_tdata[C_PIXEL_WIDTH-1:0];\n        assign m_axis_tuser = s_axis_tuser;\n        assign m_axis_tlast = s_axis_tlast;\n        assign s_axis_tready = m_axis_tready;\n    end else begin: extract_quater\n        reg  r_m_axis_tvalid;\n        assign m_axis_tvalid = r_m_axis_tvalid;\n        reg  [C_PIXEL_WIDTH-1:0] r_m_axis_tdata;\n        assign m_axis_tdata[C_PIXEL_WIDTH-1:0] = r_m_axis_tdata;\n        reg  r_m_axis_tuser;\n        assign m_axis_tuser = r_m_axis_tuser;\n        reg  r_m_axis_tlast;\n        assign m_axis_tlast = r_m_axis_tlast;\n\n        wire snext;\n        assign snext = s_axis_tvalid && s_axis_tready;\n        wire mnext;\n        assign mnext = m_axis_tvalid && m_axis_tready;\n\n        reg sline_lsb;\n        reg spixel_lsb;\n        always @ (posedge clk) begin\n            if (resetn == 1'b0)\n                sline_lsb <= 0;\n            else if (snext && s_axis_tlast)\n                sline_lsb <= ~sline_lsb;\n        end\n        always @ (posedge clk) begin\n            if (resetn == 1'b0)\n                spixel_lsb <= 0;\n            else if (snext)\n                spixel_lsb <= ~spixel_lsb;\n        end\n\n        always @ (posedge clk) begin\n            if (resetn == 1'b0)\n                r_m_axis_tdata <= 0;\n            else if (snext\n                && (spixel_lsb == C_COL_ODD)\n                && (sline_lsb == C_ROW_ODD))\n                r_m_axis_tdata <= s_axis_tdata;\n        end\n        always @ (posedge clk) begin\n            if (resetn == 1'b0)\n                r_m_axis_tvalid <= 0;\n            else if (snext\n                && (spixel_lsb == 1)\n                && (sline_lsb == C_ROW_ODD))\n                r_m_axis_tvalid <= 1;\n            else if (m_axis_tready)\n                r_m_axis_tvalid <= 0;\n        end\n\n        always @ (posedge clk) begin\n            if (resetn == 1'b0)\n                r_m_axis_tlast <= 0;\n            else if (snext\n                && (spixel_lsb == 1)\n                && (sline_lsb == C_ROW_ODD))\n                r_m_axis_tlast <= s_axis_tlast;\n        end\n\n        always @ (posedge clk) begin\n            if (resetn == 1'b0)\n                r_m_axis_tuser <= 0;\n            else if (snext\n                && s_axis_tuser)\n                r_m_axis_tuser <= 1;\n            else if (mnext)\n                r_m_axis_tuser <= 0;\n        end\n        assign s_axis_tready = (~m_axis_tvalid || m_axis_tready);\n    end\nendgenerate\nendmodule",
        "module_name": "axis_bayer_extractor #",
        "module_hash": "b2b0546e991cb732bb74bd6c09373962",
        "dataset_index": 14418
      },
      "top_module_ce54e24a": {
        "rtl_code": "module top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise-OR module\n    bitwise_or_module bitwise_or_inst(\n        .a(a),\n        .b(b),\n        .out(out_or_bitwise)\n    );\n    \n    // Logical-OR module\n    assign out_or_logical = |{a,b};\n    \n    // NOT module\n    not_module not_inst(\n        .in({a,b}),\n        .out(out_not)\n    );\n    \nendmodule\n\nmodule bitwise_or_module(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out\n);\n\n    assign out = a | b;\n    \nendmodule\n\nmodule not_module(\n    input [5:0] in,\n    output [5:0] out\n);\n\n    assign out = ~in;\n    \nendmodule",
        "module_name": "top_module",
        "module_hash": "ce54e24acff4b0869ee217e2b8a80444",
        "dataset_index": 16594
      },
      "memory #_6cf31052": {
        "rtl_code": "\nmodule memory #(\n  parameter bits = 32,\n  parameter words = 1024\n)(\n  input clk,\n  input [9:0] addr,\n  input [bits-1:0] data_in,\n  output reg [bits-1:0] mem\n);\n\n  always @(posedge clk) begin\n    if (addr < words) begin\n      mem <= data_in;\n    end\n  end\n\nendmodule",
        "module_name": "memory #",
        "module_hash": "6cf310529bf0fd4c0d1b977b531ff060",
        "dataset_index": 16835
      },
      "shift_register_9bc7d966": {
        "rtl_code": "\nmodule shift_register(input clk, stb, di, output reg do);\n\tlocalparam integer DIN_N = 256;\n\tlocalparam integer DOUT_N = 256;\n\n\treg [DIN_N-1:0] din;\n\treg [DIN_N-1:0] din_shr;\n\treg [DOUT_N-1:0] dout;\n\treg [DOUT_N-1:0] dout_shr;\n\n\talways @(posedge clk) begin\n\t\tdin_shr <= {din_shr, di};\n\t\tdout_shr <= {dout_shr, din_shr[DIN_N-1]};\n\t\tif (stb) begin\n\t\t\tdin <= din_shr;\n\t\t\tdout <= dout_shr;\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tdo <= dout_shr[DOUT_N-1];  // Corrected the assignment of do to dout_shr[DOUT_N-1]\n\tend\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "9bc7d966794e6f66285408127dab0c0e",
        "dataset_index": 15145
      },
      "adv3224_f7bdadeb": {
        "rtl_code": "module adv3224 (\n\n\tinput clk,\n\tinput reset,\n\n\tinput            avs_slave_write,\n\tinput            avs_slave_read,\n\tinput       [7:0]avs_slave_writedata,\n\toutput      [7:0]avs_slave_readdata,\n\tinput       [2:0]avs_slave_address,\n\n\toutput           cps_reset_n,\n\toutput           cps_ce_n,\n\toutput           cps_update_n,\n\toutput           cps_clk,\n\toutput           cps_datain\n);\n\n\tparameter        divider = 5;\n\n\treg         [8:0]clk_counter;\n\treg              div_clk;\n\treg              clk_en;\n\treg        [39:0]shift_buffer;\n\treg              shift_busy;\n\treg         [5:0]shift_counter;\n\treg         [4:0]outputs[0:7];\n\n\tassign cps_reset_n        = !reset;\n\tassign cps_ce_n           = 0;\n\tassign avs_slave_readdata = shift_busy;\n\tassign cps_clk            = clk_en ? div_clk : 1;\n\tassign cps_update_n       = (!clk_en && shift_busy) ? !div_clk : 1;\n\tassign cps_datain         = shift_buffer[39];\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\n\t\tif(reset)\n\t\tbegin\n\t\t\n\t\t\tclk_counter   <= 1;\n\t\t\tdiv_clk       <= 1;\n\t\t\tclk_en        <= 0;\n\t\t\tshift_busy    <= 0;\n\t\t\tshift_counter <= 0;\n\t\t\toutputs[0]    <= 5'b00000;\n\t\t\toutputs[1]    <= 5'b00000;\n\t\t\toutputs[2]    <= 5'b00000;\n\t\t\toutputs[3]    <= 5'b00000;\n\t\t\toutputs[4]    <= 5'b00000;\n\t\t\toutputs[5]    <= 5'b00000;\n\t\t\toutputs[6]    <= 5'b00000;\n\t\t\toutputs[7]    <= 5'b00000;\n\n\t\tend\n\t\telse\n\t\tbegin\tif(shift_busy)\n\t\t\tbegin\n\t\t\t\n\t\t\t\tif(clk_counter == (divider/2))\n\t\t\t\tbegin\n\t\t\t\t\tclk_counter <= 1;\n\t\t\t\t\tdiv_clk     <= !div_clk;\n\t\t\t\t\tif(!div_clk)\n\t\t\t\t\tbegin\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!clk_en)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tshift_busy <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif(shift_counter == 39)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tclk_en        <= 0;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tshift_counter <= shift_counter + 1;\n\t\t\t\t\t\t\t\tshift_buffer  <= shift_buffer << 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tclk_counter = clk_counter + 1;\n\t\t\t\tend\n\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\n\t\t\t\tclk_counter   <= 1;\n\t\t\t\tshift_counter <= 0;\n\t\t\t\tdiv_clk       <= 1;\n\t\t\t\tif(avs_slave_write)\n\t\t\t\tbegin\n\t\t\t\t\tif(avs_slave_writedata[7])\n\t\t\t\t\tbegin\n\t\t\t\t\t\tshift_buffer <= {outputs[7], outputs[6], outputs[5], outputs[4], outputs[3], outputs[2], outputs[1], outputs[0]};\n\t\t\t\t\t\tshift_busy   <= 1;\n\t\t\t\t\t\tclk_en       <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\toutputs[avs_slave_address] <= {!avs_slave_writedata[4], avs_slave_writedata[3:0]};\n\t\t\t\t\tend\n\n\t\t\t\tend\n\t\t\t\n\t\t\tend\n\n\t\tend\n\tend\n\nendmodule",
        "module_name": "adv3224",
        "module_hash": "f7bdadeb99e910dbe61dcd6dd1410bc9",
        "dataset_index": 23993
      },
      "data_out_on_rising_edge_1c6c7432": {
        "rtl_code": "module data_out_on_rising_edge (input data_in, clk, output reg data_out);\n\nalways @(posedge clk) begin\n  data_out <= data_in;\nend\n\nendmodule",
        "module_name": "data_out_on_rising_edge",
        "module_hash": "1c6c7432c002f6ea4ee35e815d9244cb",
        "dataset_index": 15351
      },
      "dff_ce_clr_b66b68b6": {
        "rtl_code": "module dff_ce_clr(clk, clr, ce, d, q);\n\n  input clk, clr, ce, d;\n  output q;\n  reg q;\n\n  always @(posedge clk)\n    if (clr)\n      q <= 1'b0;\n    else if (ce)\n      q <= d;\n\nendmodule",
        "module_name": "dff_ce_clr",
        "module_hash": "b66b68b6c43d5a5ec13bb182541a539e",
        "dataset_index": 16069
      },
      "adder_9ba4c1fa": {
        "rtl_code": "module adder(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\nwire [8:0] temp;\n\nassign temp = A + B + Cin;\n\nassign Sum = temp[7:0];\nassign Cout = (temp > 255) ? 1 : 0;\n\nendmodule\n\n",
        "module_name": "adder",
        "module_hash": "9ba4c1fadd67f481f104d0e5be9ee1f8",
        "dataset_index": 21132
      },
      "altera_tse_reset_synchronizer_5c7d306a": {
        "rtl_code": "\n\nmodule altera_tse_reset_synchronizer\n#(\n    parameter ASYNC_RESET = 1,\n    parameter DEPTH       = 2\n)\n(\n    input   reset_in ,\n\n    input   clk,\n    output  reset_out\n);\n\n     reg [DEPTH-1:0] altera_tse_reset_synchronizer_chain;\n    reg altera_tse_reset_synchronizer_chain_out;\n\n    generate if (ASYNC_RESET) begin\n\n        always @(posedge clk or posedge reset_in) begin\n            if (reset_in) begin\n                altera_tse_reset_synchronizer_chain <= {DEPTH{1'b1}};\n                altera_tse_reset_synchronizer_chain_out <= 1'b1;\n            end\n            else begin\n                altera_tse_reset_synchronizer_chain[DEPTH-2:0] <= altera_tse_reset_synchronizer_chain[DEPTH-1:1];\n                altera_tse_reset_synchronizer_chain[DEPTH-1] <= 0;\n                altera_tse_reset_synchronizer_chain_out <= altera_tse_reset_synchronizer_chain[0];\n            end\n        end\n\n        assign reset_out = altera_tse_reset_synchronizer_chain_out;\n     \n    end else begin\n\n        always @(posedge clk) begin\n            altera_tse_reset_synchronizer_chain[DEPTH-2:0] <= altera_tse_reset_synchronizer_chain[DEPTH-1:1];\n            altera_tse_reset_synchronizer_chain[DEPTH-1] <= reset_in;\n            altera_tse_reset_synchronizer_chain_out <= altera_tse_reset_synchronizer_chain[0];\n        end\n\n        assign reset_out = altera_tse_reset_synchronizer_chain_out;\n \n    end\n    endgenerate\n\nendmodule\n",
        "module_name": "altera_tse_reset_synchronizer",
        "module_hash": "5c7d306ad8ab7b509970d6553677b0ac",
        "dataset_index": 22244
      },
      "dcf77_encoder #_ef7ac8cb": {
        "rtl_code": "module dcf77_encoder #(parameter CLOCK_FREQUENCY = 16000000) ( \t\n        input wire              clk,       \t//Clock\n        input wire              reset,          //Reset-Signal\n        input wire dcf77_non_inverted,\n\n        output reg dcf_sec,\n        output reg [58:0] dcf_outputbits\n);  \n\n  reg [59:0] dcf_bits;\n  reg [30:0] cnt;\n  reg [2:0] dcf_edge;\n\n  parameter CNT_MAX = (11*CLOCK_FREQUENCY)/10;\n  parameter CNT_SAMPLE = (15*CLOCK_FREQUENCY)/100;\n\n  always@(posedge clk or posedge reset) begin\n    if(reset) begin\n      dcf_outputbits <= 60'b0;\n      dcf_bits <= 60'b0;\n      dcf_sec <= 1'b0;\n      cnt <= 0;\n      dcf_edge <= 3'b0;\n    end else begin\n      dcf_edge <= {dcf_edge[1:0], dcf77_non_inverted};\n      \n      if(cnt < CNT_MAX) cnt <= cnt + 1;\n      \n      if(dcf_edge[2:1] == 2'b01) begin\t\n        if(cnt == CNT_MAX) begin\n          dcf_sec <= 1'b1;\n          dcf_outputbits <= dcf_bits[59:0];\n          dcf_bits <= 60'b0;\n        end else begin\n          dcf_sec <= 1'b0;\n        end\n        cnt <= 0;\n      end else dcf_sec <= 1'b0;\n\n      if(dcf_edge[2:1] == 2'b10) begin\n        if(cnt < CNT_SAMPLE) begin\n          dcf_bits <= {1'b0, dcf_bits[59:1]};\n        end\n        else begin\n          dcf_bits <= {1'b1, dcf_bits[59:1]};\n        end\t\n      end\n    end\n  end\nendmodule",
        "module_name": "dcf77_encoder #",
        "module_hash": "ef7ac8cbc8d3d3cc8dd682a908d76757",
        "dataset_index": 17487
      },
      "sdram_interface_99dc66ab": {
        "rtl_code": "module sdram_interface(\n    input clk,\n    input rst,\n    input [31:0] addr,\n    input we,\n    input cs,\n    inout [15:0] dq,\n    output [1:0] dqm,\n    output [2:0] ba,\n    output ras,\n    output cas,\n    output cke,\n    output clkout,\n    output odt,\n    output cds,\n    inout [15:0] dqout\n);\n\n// Constants\nparameter ROW_BITS = 13; // Number of bits in row address\nparameter COL_BITS = 10; // Number of bits in column address\nparameter BANK_BITS = 2; // Number of bits in bank address\nparameter BA_BITS = BANK_BITS + ROW_BITS; // Number of bits in BA signal\nparameter ADDR_BITS = BA_BITS + COL_BITS; // Number of bits in address bus\nparameter DATA_WIDTH = 16; // Width of data bus\nparameter BURST_LENGTH = 4; // Burst length\n\n// Internal signals\nreg [ADDR_BITS-1:0] address_reg; // Address register\nreg [DATA_WIDTH-1:0] data_in_reg; // Data input register\nreg [DATA_WIDTH-1:0] data_out_reg; // Data output register\nreg [2:0] burst_count_reg; // Burst count register\nreg [1:0] dqm_reg; // Data mask register\nwire [ROW_BITS-1:0] row_addr; // Row address\nwire [COL_BITS-1:0] col_addr; // Column address\nwire [BANK_BITS-1:0] bank_addr; // Bank address\nwire [BA_BITS-1:0] ba_reg; // Bank address register\nwire ras_reg; // Row address strobe register\nwire cas_reg; // Column address strobe register\nwire cke_reg; // Clock enable register\nwire clkout_reg; // Output clock register\nwire odt_reg; // On-die termination register\nwire cds_reg; // Chip deselect register\nwire [DATA_WIDTH-1:0] dqout_reg; // Data output register\n\n// Address decoding\nassign row_addr = addr[COL_BITS+BANK_BITS+ROW_BITS-1:COL_BITS+BANK_BITS];\nassign col_addr = addr[COL_BITS-1:0];\nassign bank_addr = addr[ADDR_BITS-1:ADDR_BITS-BANK_BITS];\nassign ba_reg = {bank_addr, row_addr};\nassign ras_reg = (burst_count_reg == 0) ? 1'b1 : 1'b0;\nassign cas_reg = (burst_count_reg == 0) ? 1'b1 : 1'b0;\nassign cke_reg = (burst_count_reg == 0) ? 1'b0 : 1'b1;\nassign clkout_reg = clk;\nassign odt_reg = (burst_count_reg == BURST_LENGTH-1) ? 1'b1 : 1'b0;\nassign cds_reg = ~cs;\nassign dqout_reg = (burst_count_reg == 0) ? dq : data_out_reg;\n\n// Register assignments\nalways @(posedge clk) begin\n    if (rst) begin\n        address_reg <= 0;\n        data_in_reg <= 0;\n        data_out_reg <= 0;\n        burst_count_reg <= 0;\n        dqm_reg <= 2'b11;\n    end else begin\n        if (cs) begin\n            address_reg <= addr;\n            if (we) begin\n                data_in_reg <= dq;\n            end\n            if (burst_count_reg == 0) begin\n                data_out_reg <= dqout;\n            end\n            dqm_reg <= (burst_count_reg == 0) ? 2'b11 : 2'b00;\n            burst_count_reg <= (burst_count_reg == BURST_LENGTH-1) ? 0 : burst_count_reg+1;\n        end\n    end\nend\n\n// Output assignments\nassign ba = ba_reg;\nassign ras = ras_reg;\nassign cas = cas_reg;\nassign cke = cke_reg;\nassign clkout = clkout_reg;\nassign odt = odt_reg;\nassign cds = cds_reg;\nassign dqm = dqm_reg;\nassign dqout = dqout_reg;\n\nendmodule",
        "module_name": "sdram_interface",
        "module_hash": "99dc66ab67dd642953dd1c703243d326",
        "dataset_index": 17986
      },
      "reversed_gate_c128f847": {
        "rtl_code": "\nmodule reversed_gate (clk, ctrl, din, sel, dout);\n   input wire clk;\n   input wire [4:0] ctrl;\n   input wire [15:0] din;\n   input wire [3:0]  sel;\n   output reg [31:0] dout;\n   always @(posedge clk)\n     case ((({(32)-((ctrl)*(sel))})+(1))-(2))\n       0:\n         dout[1:0] <= din;\n       1:\n         dout[2:1] <= din;\n       2:\n         dout[3:2] <= din;\n       3:\n         dout[4:3] <= din;\n       4:\n         dout[5:4] <= din;\n       5:\n         dout[6:5] <= din;\n       6:\n         dout[7:6] <= din;\n       7:\n         dout[8:7] <= din;\n       8:\n         dout[9:8] <= din;\n       9:\n         dout[10:9] <= din;\n       10:\n         dout[11:10] <= din;\n       11:\n         dout[12:11] <= din;\n       12:\n         dout[13:12] <= din;\n       13:\n         dout[14:13] <= din;\n       14:\n         dout[15:14] <= din;\n       15:\n         dout[16:15] <= din;\n       16:\n         dout[17:16] <= din;\n       17:\n         dout[18:17] <= din;\n       18:\n         dout[19:18] <= din;\n       19:\n         dout[20:19] <= din;\n       20:\n         dout[21:20] <= din;\n       21:\n         dout[22:21] <= din;\n       22:\n         dout[23:22] <= din;\n       23:\n         dout[24:23] <= din;\n       24:\n         dout[25:24] <= din;\n       25:\n         dout[26:25] <= din;\n       26:\n         dout[27:26] <= din;\n       27:\n         dout[28:27] <= din;\n       28:\n         dout[29:28] <= din;\n       29:\n         dout[30:29] <= din;\n       30:\n         dout[31:30] <= din;\n       31:\n         dout[31:31] <= din;\n     endcase\nendmodule\n",
        "module_name": "reversed_gate",
        "module_hash": "c128f847ebff8be0ab435b9396071b44",
        "dataset_index": 25271
      },
      "verilog_module_82a7f337": {
        "rtl_code": "\nmodule verilog_module\n  (input clk, input reset,\n   input cyc_i, input stb_i, input we_i, output ack_o,\n   input [31:0] dat_i, output [31:0] dat_o);\n\n   wire \tBUSY, CE, WRITE;\n   \n   reg [2:0] \ticap_state;\n   localparam ICAP_IDLE  = 3'b000;\n   localparam ICAP_WR0 \t = 3'b001;\n   localparam ICAP_WR1 \t = 3'b010;\n   localparam ICAP_RD0 \t = 3'b011;\n   localparam ICAP_RD1 \t = 3'b100;\n\n   always @(posedge clk)\n   if(reset)\n     icap_state \t<= ICAP_IDLE;\n   else\n   begin\n     case(icap_state)\n\t ICAP_IDLE :\n\t   begin\n\t      if((cyc_i == 1 && stb_i == 1))\n\t\tif(we_i)\n\t\t  icap_state <= ICAP_WR0;\n\t\telse\n\t\t  icap_state <= ICAP_RD0;\n\t   end\n\t ICAP_WR0 :\n\t   icap_state <= ICAP_WR1;\n\t ICAP_WR1 :\n\t   icap_state <= ICAP_IDLE;\n\t ICAP_RD0 :\n\t   icap_state <= ICAP_RD1;\n\t ICAP_RD1 :\n\t   icap_state <= ICAP_IDLE;\n     endcase // case (icap_state)\n   end\n\n   assign WRITE \t = (icap_state == ICAP_WR0) | (icap_state == ICAP_WR1);\n   assign CE \t\t = (icap_state == ICAP_WR1) | (icap_state == ICAP_RD0);\n\n   assign ack_o = (icap_state == ICAP_WR1) | (icap_state == ICAP_RD1);\n   \n   // RTL\n   assign dat_o = (CE == 0) ? dat_i : ( (WRITE == 0) ? 32'b0 : 32'b1);\n\nendmodule",
        "module_name": "verilog_module",
        "module_hash": "82a7f337435461f66a4f2aea1a6bcf8f",
        "dataset_index": 7503
      },
      "mux2to1_523808ca": {
        "rtl_code": "module mux2to1 (\n    input A,\n    input B,\n    input S,\n    output Y\n);\n\n    // Select between A and B based on S\n    assign Y = (S == 1'b0) ? A : B;\n\nendmodule",
        "module_name": "mux2to1",
        "module_hash": "523808ca41b4a7b7cf64e54255fa63f3",
        "dataset_index": 19858
      },
      "sky130_fd_sc_lp__nor4b_c16f06e0": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__nor4b (\n    Y  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    wire not0_out  ;\n    wire nor0_out_Y;\n\n    not not0 (not0_out  , D_N              );\n    nor nor0 (nor0_out_Y, A, B, C, not0_out);\n    buf buf0 (Y         , nor0_out_Y       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__nor4b",
        "module_hash": "c16f06e0151f60700a5b35faac2194da",
        "dataset_index": 8687
      },
      "my__50224cb1": {
        "rtl_code": "module my_module (\n    input A1,\n    input A2,\n    input B1,\n    input VPWR,\n    output X\n);\n\n    // Local signals\n    wire or_out;\n    wire and_out_X;\n\n    // OR gate for A1 and A2\n    or or_gate (or_out, A2, A1);\n\n    // AND gate for or_out and B1\n    and and_gate_X (and_out_X, or_out, B1);\n\n    // Buffer for and_out_X and VPWR\n    buf buf_gate (X, and_out_X & VPWR);\n\nendmodule",
        "module_name": "my_",
        "module_hash": "50224cb17968fe2a944a4b954c233982",
        "dataset_index": 7914
      },
      "d_ff_reset_4da02563": {
        "rtl_code": "module d_ff_reset (\n    input D,\n    input RESET_B,\n    input GATE,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output reg Q\n);\n\n    reg Q_reg;\n    \n    always @(posedge GATE or negedge RESET_B)\n    begin\n        if (!RESET_B)\n            Q_reg <= 1'b0;\n        else\n            Q_reg <= D;\n    end\n\n    always @*\n    begin\n        Q = Q_reg;\n    end\n\nendmodule",
        "module_name": "d_ff_reset",
        "module_hash": "4da02563c399f7dd7a2b8732f1d89f6c",
        "dataset_index": 8894
      },
      "sky130_fd_sc_hd__and2b_249e492d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__and2b (\n    X  ,\n    A_N,\n    B\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N            );\n    and and0 (and0_out_X, not0_out, B    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__and2b",
        "module_hash": "249e492d4ad914901ceccd16ba0054b1",
        "dataset_index": 23248
      },
      "pulse_generator_a565570c": {
        "rtl_code": "module pulse_generator (\n  input clk,\n  input reset,\n  input start,\n  output reg pulse\n);\n\n  parameter PULSE_DURATION = 100; // in clock cycles\n  parameter CLOCK_FREQUENCY = 50; // in MHz\n\n  localparam PULSE_CYCLES = PULSE_DURATION * CLOCK_FREQUENCY;\n\n  reg [31:0] count = 0;\n  reg pulse_on = 0;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 0;\n      pulse_on <= 0;\n      pulse <= 0;\n    end\n    else begin\n      if (start) begin\n        count <= 0;\n        pulse_on <= 1;\n        pulse <= 1;\n      end\n      else begin\n        if (count >= PULSE_CYCLES) begin\n          pulse_on <= 0;\n          pulse <= 0;\n        end\n        else begin\n          count <= count + 1;\n          pulse_on <= 1;\n          pulse <= 1;\n        end\n      end\n    end\n  end\n\nendmodule",
        "module_name": "pulse_generator",
        "module_hash": "a565570c563e7cf4b2308a7ff826af08",
        "dataset_index": 7748
      },
      "PosClockedOneShot_17ce9fd1": {
        "rtl_code": "module PosClockedOneShot(InputPulse, OneShot, Reset, CLOCK);\n    input InputPulse, Reset, CLOCK;\n    output reg OneShot;\n    parameter State0=0, State1=1, State2=2, State3=3;\n    reg [1:0] State;\n\n    always @(posedge CLOCK) begin\n        if (Reset == 1) begin\n            State <= State0;\n            OneShot <= 0;\n        end else begin\n            case (State)\n                State0: if (InputPulse == 0) begin\n                            State <= State0;\n                            OneShot <= 0;\n                        end else begin\n                            State <= State1;\n                            OneShot <= 1;\n                        end\n                State1: if (InputPulse == 0) begin\n                            State <= State0;\n                            OneShot <= 0;\n                        end else begin\n                            State <= State3;\n                            OneShot <= 0;\n                        end\n                State2: begin\n                            State <= State0;\n                            OneShot <= 0;\n                        end\n                State3: if (InputPulse == 0) begin\n                            State <= State0;\n                            OneShot <= 0;\n                        end else begin\n                            State <= State3;\n                            OneShot <= 1;\n                        end\n            endcase\n        end\n    end\nendmodule",
        "module_name": "PosClockedOneShot",
        "module_hash": "17ce9fd1bcc0ebc12fd2253cc8d5e562",
        "dataset_index": 11097
      },
      "Adder_b3bf6315": {
        "rtl_code": "module Adder (clk, rst, load, A, B, Q);\n\ninput clk, rst, load;\ninput [3:0] A, B;\noutput [3:0] Q;\n\nreg [3:0] Q_reg;\nwire [3:0] sum;\n\nassign sum = A + B;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        Q_reg <= 4'b0;\n    end else begin\n        if (load) begin\n            Q_reg <= sum;\n        end\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule",
        "module_name": "Adder",
        "module_hash": "b3bf6315f5ea589f187c0efd61f26b1b",
        "dataset_index": 11138
      },
      "vga_write_iface_80fee392": {
        "rtl_code": "\n\nmodule vga_write_iface (\n    input wb_clk_i,\n    input wb_rst_i,\n\n    input [16:1] wbs_adr_i,\n    input [ 1:0] wbs_sel_i,\n    input [15:0] wbs_dat_i,\n    input        wbs_stb_i,\n    output       wbs_ack_o,\n\n    output [17:1] wbm_adr_o,\n    output [ 1:0] wbm_sel_o,\n    output [15:0] wbm_dat_o,\n    output        wbm_stb_o,\n    input         wbm_ack_i,\n\n    input        memory_mapping1,\n    input [ 1:0] write_mode,\n    input [ 1:0] raster_op,\n    input [ 7:0] bitmask,\n    input [ 3:0] set_reset,\n    input [ 3:0] enable_set_reset,\n    input [ 3:0] map_mask,\n\n    input [7:0] latch0,\n    input [7:0] latch1,\n    input [7:0] latch2,\n    input [7:0] latch3\n  );\n\n  wire [15:0] latch0_16;\n  wire [15:0] latch1_16;\n  wire [15:0] latch2_16;\n  wire [15:0] latch3_16;\n\n  wire [15:0] lb0;\n  wire [15:0] lb1;\n  wire [15:0] lb2;\n  wire [15:0] lb3;\n\n  wire [15:0] nlb0;\n  wire [15:0] nlb1;\n  wire [15:0] nlb2;\n  wire [15:0] nlb3;\n\n  wire [15:0] alb0;\n  wire [15:0] alb1;\n  wire [15:0] alb2;\n  wire [15:0] alb3;\n\n  wire [15:0] olb0;\n  wire [15:0] olb1;\n  wire [15:0] olb2;\n  wire [15:0] olb3;\n\n  wire [15:0] xlb0;\n  wire [15:0] xlb1;\n  wire [15:0] xlb2;\n  wire [15:0] xlb3;\n\n  wire [15:0] set0;\n  wire [15:0] set1;\n  wire [15:0] set2;\n  wire [15:0] set3;\n\n  wire [15:0] no_set0;\n  wire [15:0] no_set1;\n  wire [15:0] no_set2;\n  wire [15:0] no_set3;\n\n  wire [15:0] no_en0;\n  wire [15:0] no_en1;\n  wire [15:0] no_en2;\n  wire [15:0] no_en3;\n\n  wire [15:0] new_val0;\n  wire [15:0] new_val1;\n  wire [15:0] new_val2;\n  wire [15:0] new_val3;\n\n  wire [15:0] val0_write0, val0_write1, val0_write2, val0_write3;\n  wire [15:0] val1_write0, val1_write1, val1_write2, val1_write3;\n  wire [15:0] val0_or0, val0_or1, val0_or2, val0_or3;\n  wire [15:0] val1_or0, val1_or1, val1_or2, val1_or3;\n  wire [15:0] final_wr0, final_wr1, final_wr2, final_wr3;\n\n  wire [15:1] offset;\n  wire [15:0] bitmask16;\n  wire [15:0] dat_mask;\n  wire        write_en;\n  wire        cont;\n\n  reg  [ 1:0] plane;\n  reg  [ 3:0] plane_dec;\n\n  assign bitmask16 = { bitmask, bitmask };\n  assign dat_mask  = wbs_dat_i & bitmask16;\n\n  assign latch0_16 = { latch0, latch0 };\n  assign latch1_16 = { latch1, latch1 };\n  assign latch2_16 = { latch2, latch2 };\n  assign latch3_16 = { latch3, latch3 };\n\n  assign new_val0 = latch0_16 & ~bitmask16;\n  assign new_val1 = latch1_16 & ~bitmask16;\n  assign new_val2 = latch2_16 & ~bitmask16;\n  assign new_val3 = latch3_16 & ~bitmask16;\n\n  assign lb0  = latch0_16 & bitmask16;\n  assign lb1  = latch1_16 & bitmask16;\n  assign lb2  = latch2_16 & bitmask16;\n  assign lb3  = latch3_16 & bitmask16;\n\n  assign nlb0 = ~latch0_16 & bitmask16;\n  assign nlb1 = ~latch1_16 & bitmask16;\n  assign nlb2 = ~latch2_16 & bitmask16;\n  assign nlb3 = ~latch3_16 & bitmask16;\n\n  assign alb0 = (wbs_dat_i & latch0_16) & bitmask16;\n  assign alb1 = (wbs_dat_i & latch1_16) & bitmask16;\n  assign alb2 = (wbs_dat_i & latch2_16) & bitmask16;\n  assign alb3 = (wbs_dat_i & latch3_16) & bitmask16;\n\n  assign olb0 = (wbs_dat_i | latch0_16) & bitmask16;\n  assign olb1 = (wbs_dat_i | latch1_16) & bitmask16;\n  assign olb2 = (wbs_dat_i | latch2_16) & bitmask16;\n  assign olb3 = (wbs_dat_i | latch3_16) & bitmask16;\n\n  assign xlb0 = (wbs_dat_i ^ latch0_16) & bitmask16;\n  assign xlb1 = (wbs_dat_i ^ latch1_16) & bitmask16;\n  assign xlb2 = (wbs_dat_i ^ latch2_16) & bitmask16;\n  assign xlb3 = (wbs_dat_i ^ latch3_16) & bitmask16;\n\n  assign set0 = raster_op[0] ? (raster_op[1] ? nlb0 : lb0 ) : bitmask16;\n  assign set1 = raster_op[0] ? (raster_op[1] ? nlb1 : lb1 ) : bitmask16;\n  assign set2 = raster_op[0] ? (raster_op[1] ? nlb2 : lb2 ) : bitmask16;\n  assign set3 = raster_op[0] ? (raster_op[1] ? nlb3 : lb3 ) : bitmask16;\n\n  assign no_set0 = raster_op[1] ? lb0 : 16'h0;\n  assign no_set1 = raster_op[1] ? lb1 : 16'h0;\n  assign no_set2 = raster_op[1] ? lb2 : 16'h0;\n  assign no_set3 = raster_op[1] ? lb3 : 16'h0;\n\n  assign no_en0 = raster_op[1] ? (raster_op[0] ? xlb0 : olb0)\n                               : (raster_op[0] ? alb0 : dat_mask);\n  assign no_en1 = raster_op[1] ? (raster_op[0] ? xlb1 : olb1)\n                               : (raster_op[0] ? alb1 : dat_mask);\n  assign no_en2 = raster_op[1] ? (raster_op[0] ? xlb2 : olb2)\n                               : (raster_op[0] ? alb2 : dat_mask);\n  assign no_en3 = raster_op[1] ? (raster_op[0] ? xlb3 : olb3)\n                               : (raster_op[0] ? alb3 : dat_mask);\n\n  assign val0_or0 = enable_set_reset[0] ?\n    (set_reset[0] ? set0 : no_set0) : no_en0;\n  assign val0_or1 = enable_set_reset[1] ?\n    (set_reset[1] ? set1 : no_set1) : no_en1;\n  assign val0_or2 = enable_set_reset[2] ?\n    (set_reset[2] ? set2 : no_set2) : no_en2;\n  assign val0_or3 = enable_set_reset[3] ?\n    (set_reset[3] ? set3 : no_set3) : no_en3;\n\n  assign val0_write0 = new_val0 | val0_or0;\n  assign val0_write1 = new_val1 | val0_or1;\n  assign val0_write2 = new_val2 | val0_or2;\n  assign val0_write3 = new_val3 | val0_or3;\n\n  \n  assign val1_or0[ 7:0] = wbs_dat_i[ 0] ? bitmask : 8'h0;\n  assign val1_or1[ 7:0] = wbs_dat_i[ 1] ? bitmask : 8'h0;\n  assign val1_or2[ 7:0] = wbs_dat_i[ 2] ? bitmask : 8'h0;\n  assign val1_or3[ 7:0] = wbs_dat_i[ 3] ? bitmask : 8'h0;\n  assign val1_or0[15:8] = wbs_dat_i[ 8] ? bitmask : 8'h0;\n  assign val1_or1[15:8] = wbs_dat_i[ 9] ? bitmask : 8'h0;\n  assign val1_or2[15:8] = wbs_dat_i[10] ? bitmask : 8'h0;\n  assign val1_or3[15:8] = wbs_dat_i[11] ? bitmask : 8'h0;\n\n  assign val1_write0 = new_val0 | val1_or0;\n  assign val1_write1 = new_val1 | val1_or1;\n  assign val1_write2 = new_val2 | val1_or2;\n  assign val1_write3 = new_val3 | val1_or3;\n\n  assign final_wr0 = write_mode[1] ? val1_write0\n                   : (write_mode[0] ? latch0_16 : val0_write0);\n  assign final_wr1 = write_mode[1] ? val1_write1\n                   : (write_mode[0] ? latch1_16 : val0_write1);\n  assign final_wr2 = write_mode[1] ? val1_write2\n                   : (write_mode[0] ? latch2_16 : val0_write2);\n  assign final_wr3 = write_mode[1] ? val1_write3\n                   : (write_mode[0] ? latch3_16 : val0_write3);\n\n  assign offset = memory_mapping1 ? { 1'b0, wbs_adr_i[14:1] }\n                                  : wbs_adr_i[15:1];\n\n  assign wbm_adr_o = { offset, plane };\n  assign wbs_ack_o = (plane==2'b11 && cont);\n  assign wbm_dat_o = plane[1] ? (plane[0] ? final_wr3 : final_wr2)\n                              : (plane[0] ? final_wr1 : final_wr0);\n\n  assign write_en = plane[1] ? (plane[0] ? map_mask[3] : map_mask[2])\n                             : (plane[0] ? map_mask[1] : map_mask[0]);\n\n  assign wbm_sel_o = wbs_sel_i;\n  assign cont      = (wbm_ack_i | !write_en) & wbs_stb_i;\n  assign wbm_stb_o = write_en & wbs_stb_i;\n\n  always @(posedge wb_clk_i)\n    plane <= wb_rst_i ? 2'b00 : (cont ? (plane + 2'b01) : plane);\n\nendmodule\n",
        "module_name": "vga_write_iface",
        "module_hash": "80fee392433ff299eda436a9083fef70",
        "dataset_index": 25006
      },
      "PE_ctrl_431fa807": {
        "rtl_code": "module PE_ctrl(\n    input [10:0] ctrl,\n    output reg [3:0] op,\n    output reg [31:0] width\n);\n\nalways @(*) begin\n    case(ctrl[5:0])\n        6'b000000: begin\n            op = 4'b0000;\n        end\n        6'b000001: begin\n            op = 4'b0001;\n        end\n        6'b000010: begin\n            op = 4'b0010;\n        end\n        6'b000011: begin\n            op = 4'b0011;\n        end\n        6'b000100: begin\n            op = 4'b0100;\n        end\n        6'b000101: begin\n            op = 4'b0101;\n        end\n        6'b000110: begin\n            op = 4'b0110;\n        end\n        6'b000111: begin\n            op = 4'b0111;\n        end\n        6'b001000: begin\n            op = 4'b1000;\n        end\n        6'b001001: begin\n            op = 4'b1001;\n        end\n        6'b001010: begin\n            op = 4'b1010;\n        end\n        6'b001011: begin\n            op = 4'b1011;\n        end\n        6'b001100: begin\n            op = 4'b1100;\n        end\n        6'b001101: begin\n            op = 4'b1101;\n        end\n        6'b001110: begin\n            op = 4'b1110;\n        end\n        6'b001111: begin\n            op = 4'b1111;\n        end\n        6'b010000: begin\n            op = 4'b1111;\n        end\n        6'b010001: begin\n            op = 4'b0011;\n        end\n        6'b010010: begin\n            op = 4'b0100;\n        end\n        6'b010011: begin\n            op = 4'b1111;\n        end\n        6'b010100: begin\n            op = 4'b0111;\n        end\n        6'b010101: begin\n            op = 4'b1001;\n        end\n        6'b010110: begin\n            op = 4'b1011;\n        end\n        6'b010111: begin\n            op = 4'b1101;\n        end\n        6'b011000: begin\n            op = 4'b0111;\n        end\n        6'b011001: begin\n            op = 4'b1001;\n        end\n        6'b011010: begin\n            op = 4'b1111;\n        end\n        6'b011011: begin\n            op = 4'b0011;\n        end\n        6'b011100: begin\n            op = 4'b0100;\n        end\n        6'b011101: begin\n            op = 4'b1010;\n        end\n        6'b011110: begin\n            op = 4'b1111;\n        end\n        6'b011111: begin\n            op = 4'b1111;\n        end\n        default: begin\n            op = 4'b0000;\n        end\n    endcase\n    width = 2 ** ctrl[10:6];\nend\n\nendmodule",
        "module_name": "PE_ctrl",
        "module_hash": "431fa8075c60c750cdbbd198b5a429c5",
        "dataset_index": 12935
      },
      "encode_8b10b_5df95070": {
        "rtl_code": "module encode_8b10b (datain, dispin, dataout, dispout) ;\n  input [8:0]   datain ;\n  input \tdispin ;  output [9:0]\tdataout ;\n  output\tdispout ;\n\n\n  wire ai = datain[0] ;\n  wire bi = datain[1] ;\n  wire ci = datain[2] ;\n  wire di = datain[3] ;\n  wire ei = datain[4] ;\n  wire fi = datain[5] ;\n  wire gi = datain[6] ;\n  wire hi = datain[7] ;\n  wire ki = datain[8] ;\n\n  wire aeqb = (ai & bi) | (!ai & !bi) ;\n  wire ceqd = (ci & di) | (!ci & !di) ;\n  wire l22 = (ai & bi & !ci & !di) |\n\t     (ci & di & !ai & !bi) |\n\t     ( !aeqb & !ceqd) ;\n  wire l40 = ai & bi & ci & di ;\n  wire l04 = !ai & !bi & !ci & !di ;\n  wire l13 = ( !aeqb & !ci & !di) |\n\t     ( !ceqd & !ai & !bi) ;\n  wire l31 = ( !aeqb & ci & di) |\n\t     ( !ceqd & ai & bi) ;\n\n  wire ao = ai ;\n  wire bo = (bi & !l40) | l04 ;\n  wire co = l04 | ci | (ei & di & !ci & !bi & !ai) ;\n  wire do = di & ! (ai & bi & ci) ;\n  wire eo = (ei | l13) & ! (ei & di & !ci & !bi & !ai) ;\n  wire io = (l22 & !ei) |\n\t    (ei & !di & !ci & !(ai&bi)) |  (ei & l40) |\n\t    (ki & ei & di & ci & !bi & !ai) | (ei & !di & ci & !bi & !ai) ;\n\n  wire pd1s6 = (ei & di & !ci & !bi & !ai) | (!ei & !l22 & !l31) ;\n  wire nd1s6 = ki | (ei & !l22 & !l13) | (!ei & !di & ci & bi & ai) ;\n\n  wire ndos6 = pd1s6 ;\n  wire pdos6 = ki | (ei & !l22 & !l13) ;\n\n\n  wire alt7 = fi & gi & hi & (ki | \n\t\t\t      (dispin ? (!ei & di & l31) : (ei & !di & l13))) ;\n\n   \n  wire fo = fi & ! alt7 ;\n  wire go = gi | (!fi & !gi & !hi) ;\n  wire ho = hi ;\n  wire jo = (!hi & (gi ^ fi)) | alt7 ;\n\n  wire nd1s4 = fi & gi ;\n  wire pd1s4 = (!fi & !gi) | (ki & ((fi & !gi) | (!fi & gi))) ;\n\n  wire ndos4 = (!fi & !gi) ;\n  wire pdos4 = fi & gi & hi ;\n\n  wire illegalk = ki & \n\t\t  (ai | bi | !ci | !di | !ei) & (!fi | !gi | !hi | !ei | !l31) ; wire compls6 = (pd1s6 & !dispin) | (nd1s6 & dispin) ;\n\n  wire disp6 = dispin ^ (ndos6 | pdos6) ;\n\n  wire compls4 = (pd1s4 & !disp6) | (nd1s4 & disp6) ;\n  assign dispout = disp6 ^ (ndos4 | pdos4) ;\n\n  assign dataout = {(jo ^ compls4), (ho ^ compls4),\n\t\t    (go ^ compls4), (fo ^ compls4),\n\t\t    (io ^ compls6), (eo ^ compls6),\n\t\t    (do ^ compls6), (co ^ compls6),\n\t\t    (bo ^ compls6), (ao ^ compls6)} ;\n\nendmodule\n",
        "module_name": "encode_8b10b",
        "module_hash": "5df95070539d9f69472f9fbfecc3bdfe",
        "dataset_index": 23981
      },
      "carry_lookahead_adder_37c1420a": {
        "rtl_code": "module carry_lookahead_adder(\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\nwire [3:0] g;\nwire [3:0] p;\nwire [3:0] c;\n\nassign g[0] = a[0] & b[0];\nassign p[0] = a[0] | b[0];\nassign c[0] = cin;\n\nassign g[1] = a[1] & b[1];\nassign p[1] = a[1] | b[1];\nassign c[1] = g[0] | (p[0] & cin);\n\nassign g[2] = a[2] & b[2];\nassign p[2] = a[2] | b[2];\nassign c[2] = g[1] | (p[1] & g[0]) | (p[1] & p[0] & cin);\n\nassign g[3] = a[3] & b[3];\nassign p[3] = a[3] | b[3];\nassign c[3] = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & cin);\n\nassign sum = {c[3], c[2], c[1], c[0], a[15:4] + b[15:4] + c[3:0]};\nassign cout = c[3];\n\nendmodule\n\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\nwire [15:0] a_low = a[15:0];\nwire [15:0] b_low = b[15:0];\nwire [15:0] a_high = a[31:16];\nwire [15:0] b_high = b[31:16];\nwire cin;\n\ncarry_lookahead_adder adder_low(.a(a_low), .b(b_low), .cin(1'b0), .sum(sum[15:0]), .cout(cin));\ncarry_lookahead_adder adder_high(.a(a_high), .b(b_high), .cin(cin), .sum(sum[31:16]), .cout());\n\nendmodule",
        "module_name": "carry_lookahead_adder",
        "module_hash": "37c1420a1c946c7a8ec20b8f183de881",
        "dataset_index": 7292
      },
      "bin_to_bcd_converter_aee6db88": {
        "rtl_code": "module bin_to_bcd_converter (\n    input clk,\n    input rst,\n    input [3:0] bin_in,\n    output reg [9:0] bcd_out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        bcd_out <= 10'b0;\n    end else begin\n        case (bin_in)\n            4'b0000: bcd_out <= 10'b0000_0000_0000;\n            4'b0001: bcd_out <= 10'b0000_0000_0001;\n            4'b0010: bcd_out <= 10'b0000_0000_0010;\n            4'b0011: bcd_out <= 10'b0000_0000_0011;\n            4'b0100: bcd_out <= 10'b0000_0000_0100;\n            4'b0101: bcd_out <= 10'b0000_0000_0101;\n            4'b0110: bcd_out <= 10'b0000_0000_0110;\n            4'b0111: bcd_out <= 10'b0000_0000_0111;\n            4'b1000: bcd_out <= 10'b0000_0000_1000;\n            4'b1001: bcd_out <= 10'b0000_0000_1001;\n            4'b1010: bcd_out <= 10'b0000_0001_0000;\n            4'b1011: bcd_out <= 10'b0000_0001_0001;\n            4'b1100: bcd_out <= 10'b0000_0001_0010;\n            4'b1101: bcd_out <= 10'b0000_0001_0011;\n            4'b1110: bcd_out <= 10'b0000_0001_0100;\n            4'b1111: bcd_out <= 10'b0000_0001_0101;\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "bin_to_bcd_converter",
        "module_hash": "aee6db88cfed98b6a08a90741e974a6c",
        "dataset_index": 19953
      },
      "posedge_D_ff_with_enable_9be80e46": {
        "rtl_code": "module posedge_D_ff_with_enable(clk, d, en, q);\n  input clk, d, en;\n  output reg q;\n\n  // Clock gating circuit\n  wire gated_clk;\n  assign gated_clk = clk & en;\n\n  always @(posedge gated_clk) begin\n    q <= d;\n  end\nendmodule",
        "module_name": "posedge_D_ff_with_enable",
        "module_hash": "9be80e467535e4c7081d7e0f31ac797a",
        "dataset_index": 10925
      },
      "digital_circuit_731092ec": {
        "rtl_code": "\nmodule digital_circuit (\n    output Y   ,\n    input  A1  ,\n    input  A2  ,\n    input  B1_N,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    // Module ports\n\n    // Local signals\n    wire b                ;\n    wire and0_out         ;\n    wire nor0_out_Y       ;\n    wire pwrgood_pp0_out_Y;\n\n    // Components instantiation\n    not not0 (b, B1_N);\n    and and0 (and0_out, A1, A2);\n    nor nor0 (nor0_out_Y, b, and0_out);\n    buf buf0 (pwrgood_pp0_out_Y, nor0_out_Y);\n    buf buf1 (Y, pwrgood_pp0_out_Y);  // Fixing the issue\n\nendmodule",
        "module_name": "digital_circuit",
        "module_hash": "731092ecc88c3d16891a2c1cdf1f6ad5",
        "dataset_index": 3238
      },
      "mux_functional_5a4babd6": {
        "rtl_code": "module mux_functional (\n    input [1:0] in,\n    input select,\n    output [1:0] out\n);\n\n    assign out = (select == 0) ? in[0] : in[1];\n\nendmodule\n\nmodule functional_module (\n    input [1:0] in,\n    output [1:0] out\n);\n\n    assign out = ~in;\n\nendmodule\n\nmodule top_module (\n    input a,\n    input b,\n    input select,\n    output [1:0] out\n);\n\n    wire [1:0] mux_out;\n    mux_functional mux_inst (\n        .in({a, b}),\n        .select(select),\n        .out(mux_out)\n    );\n\n    functional_module func_inst (\n        .in(mux_out),\n        .out(out)\n    );\n\nendmodule",
        "module_name": "mux_functional",
        "module_hash": "5a4babd6c2e591ed8ef925420ca03681",
        "dataset_index": 18716
      },
      "adder_330de0e5": {
        "rtl_code": "module adder (A, B, add, clk, sum);\n   input [31:0] A;\n   input [31:0] B;\n   input add;\n   input clk;\n   \n   output [31:0] sum;\n   \n   wire [31:0] result;\n   \n   reg [31:0] sum_reg;\n   \n   assign result = A + B;\n   \n   always @ (posedge clk)\n     if (add) sum_reg <= result;\n   \n   assign sum = add ? result : sum_reg;\nendmodule",
        "module_name": "adder",
        "module_hash": "330de0e512ae44e99b2d28a14b892051",
        "dataset_index": 6425
      },
      "distance_calculator_be60e1ea": {
        "rtl_code": "\nmodule distance_calculator (\n  input signed [31:0] x1,\n  input signed [31:0] y1,\n  input signed [31:0] z1,\n  input signed [31:0] x2,\n  input signed [31:0] y2,\n  input signed [31:0] z2,\n  output reg [31:0] distance\n);\n\nlocalparam I32 = 32;\nlocalparam SCALE = 16;\n\nfunction integer abs (input integer a);\n  abs = a >= 0 ? a : -a ;\nendfunction\n\nfunction integer pow2 (input integer a);\n  pow2 = a*a;\nendfunction\n\nalways @(*) begin\n  distance = 0;\n  distance =  distance + pow2(abs(x2 - x1));\n  distance = distance + pow2(abs(y2 - y1));\n  distance = distance + pow2(abs(z2 - z1));\n  distance = distance >> SCALE ;\nend\n  \nendmodule",
        "module_name": "distance_calculator",
        "module_hash": "be60e1ea1008eaa66f2d569f09dd97d7",
        "dataset_index": 20040
      },
      "RFID_Receiver #_7e07ddcc": {
        "rtl_code": "module RFID_Receiver #(\n  parameter n = 8 // number of bits in the data signal\n) (\n  input rx,\n  input clk,\n  input rst,\n  output reg [n-1:0] data_out,\n  output reg valid\n);\n\n  \n  reg [n-1:0] data_reg;\n  reg [3:0] count;\n  reg start_reg;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n      data_reg <= 0;\n      start_reg <= 0;\n      valid <= 0;\n    end\n    else begin\n      if (rx) begin\n        if (count < n-1) begin\n          count <= count + 1;\n          data_reg[count] <= rx;\n        end\n        else begin\n          count <= 0;\n          data_out <= data_reg;\n          valid <= 1;\n          start_reg <= 1;\n        end\n      end\n      else begin\n        valid <= 0;\n        if (start_reg) begin\n          start_reg <= 0;\n        end\n      end\n    end\n  end\n  \nendmodule",
        "module_name": "RFID_Receiver #",
        "module_hash": "7e07ddcc588879fcb69d7a03e13890c3",
        "dataset_index": 28
      },
      "top__72d2279b": {
        "rtl_code": "\nmodule top_module (\n    input [15:0] a,\n    input [15:0] b,\n    output lt,\n    output eq,\n    output gt,\n    output [6:0] seg_a,\n    output [6:0] seg_b\n);\n\n    wire [3:0] bcd_a;\n    wire [3:0] bcd_b;\n    bcd_to_7seg bcd_a_decoder(bcd_a, seg_a);\n    bcd_to_7seg bcd_b_decoder(bcd_b, seg_b);\n    comparator_16bit comparator(a, b, lt, eq, gt);\n\n    assign {bcd_a, bcd_b} = {a,b};\n\nendmodule\n\nmodule bcd_to_7seg (\n    input [3:0] BCD,\n    output [6:0] SEG\n);\n    reg [6:0] SEG;\n    always @*\n    begin\n        case (BCD)\n            4'b0000: SEG = 7'b1000000; // 0\n            4'b0001: SEG = 7'b1111001; // 1\n            4'b0010: SEG = 7'b0100100; // 2\n            4'b0011: SEG = 7'b0110000; // 3\n            4'b0100: SEG = 7'b0011001; // 4\n            4'b0101: SEG = 7'b0010010; // 5\n            4'b0110: SEG = 7'b0000010; // 6\n            4'b0111: SEG = 7'b1111000; // 7\n            4'b1000: SEG = 7'b0000000; // 8\n            4'b1001: SEG = 7'b0010000; // 9\n            default: SEG = 7'b1111111; // Invalid input\n        endcase\n    end\n\nendmodule\n\nmodule comparator_16bit (\n    input [15:0] a,\n    input [15:0] b,\n    output lt,\n    output eq,\n    output gt\n);\n    assign lt = (a < b);\n    assign eq = (a == b);\n    assign gt = (a > b);\nendmodule\n",
        "module_name": "top_",
        "module_hash": "72d2279b27798b354b9326bb2e6497f6",
        "dataset_index": 16617
      },
      "parity_generator_checker #_dfac59b3": {
        "rtl_code": "module parity_generator_checker #(\n  parameter parity_type = \"even\" // even or odd parity\n)\n(\n  input wire [7:0] data_in,\n  input wire parity_in,\n  output reg parity_out,\n  output reg correct\n);\n\n  reg [7:0] temp_data;\n  reg [3:0] count;\n  reg parity_bit;\n\n  always @(*) begin\n    temp_data = data_in ^ (data_in >> 4);\n    temp_data = temp_data ^ (temp_data >> 2);\n    temp_data = temp_data ^ (temp_data >> 1);\n    parity_bit = temp_data[0];\n\n    if (parity_type == \"even\") begin\n      parity_out <= parity_bit;\n    end else begin\n      parity_out <= ~parity_bit;\n    end\n  end\n\n  always @(*) begin\n    count = data_in[0] + data_in[1] + data_in[2] + data_in[3] + data_in[4] + data_in[5] + data_in[6] + data_in[7] + parity_in;\n\n    if (parity_type == \"even\") begin\n      correct <= (count % 2 == 0);\n    end else begin\n      correct <= (count % 2 == 1);\n    end\n  end\n\nendmodule",
        "module_name": "parity_generator_checker #",
        "module_hash": "dfac59b36c7c1694a3edb4a58ba781a7",
        "dataset_index": 7263
      },
      "serial_tx #_f347dfeb": {
        "rtl_code": "module serial_tx #(\n        parameter CLK_PER_BIT = 50\n    )(\n        input clk,\n        input rst,\n        output tx,\n        input block,\n        output busy,\n        input [7:0] data,\n        input new_data\n    );\n\n    parameter CTR_SIZE = $clog2(CLK_PER_BIT);\n\n    localparam STATE_SIZE = 2;\n    localparam IDLE = 2'd0,\n    START_BIT = 2'd1,\n    DATA = 2'd2,\n    STOP_BIT = 2'd3;\n\n    reg [CTR_SIZE-1:0] ctr_d, ctr_q;\n    reg [2:0] bit_ctr_d, bit_ctr_q;\n    reg [7:0] data_d, data_q;\n    reg [STATE_SIZE-1:0] state_d, state_q = IDLE;\n    reg tx_d, tx_q;\n    reg busy_d, busy_q;\n    reg block_d, block_q;\n\n    assign tx = tx_q;\n    assign busy = busy_q;\n\n    always @(*) begin\n        block_d = block;\n        ctr_d = ctr_q;\n        bit_ctr_d = bit_ctr_q;\n        data_d = data_q;\n        state_d = state_q;\n        busy_d = busy_q;\n\n        case (state_q)\n            IDLE: begin\n                if (block_q) begin\n                    busy_d = 1'b1;\n                    tx_d = 1'b1;\n                end else begin\n                    busy_d = 1'b0;\n                    tx_d = 1'b1;\n                    bit_ctr_d = 3'b0;\n                    ctr_d = 1'b0;\n                    if (new_data) begin\n                        data_d = data;\n                        state_d = START_BIT;\n                        busy_d = 1'b1;\n                    end\n                end\n            end\n            START_BIT: begin\n                busy_d = 1'b1;\n                ctr_d = ctr_q + 1'b1;\n                tx_d = 1'b0;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    ctr_d = 1'b0;\n                    state_d = DATA;\n                end\n            end\n            DATA: begin\n                busy_d = 1'b1;\n                tx_d = data_q[bit_ctr_q];\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    ctr_d = 1'b0;\n                    bit_ctr_d = bit_ctr_q + 1'b1;\n                    if (bit_ctr_q == 7) begin\n                        state_d = STOP_BIT;\n                    end\n                end\n            end\n            STOP_BIT: begin\n                busy_d = 1'b1;\n                tx_d = 1'b1;\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    state_d = IDLE;\n                end\n            end\n            default: begin\n                state_d = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state_q <= IDLE;\n            tx_q <= 1'b1;\n        end else begin\n            state_q <= state_d;\n            tx_q <= tx_d;\n        end\n\n        block_q <= block_d;\n        data_q <= data_d;\n        bit_ctr_q <= bit_ctr_d;\n        ctr_q <= ctr_d;\n        busy_q <= busy_d;\n    end\n\nendmodule",
        "module_name": "serial_tx #",
        "module_hash": "f347dfeb745281e838119fe3f4bec357",
        "dataset_index": 25827
      },
      "gray_code_converter_6974bb32": {
        "rtl_code": "\nmodule gray_code_converter (\n    input [3:0] data_in,\n    output [3:0] gray_out\n);\n\n    wire [3:0] intermediate;\n\n    assign intermediate[0] = data_in[0];\n    assign intermediate[1] = data_in[0] ^ data_in[1];\n    assign intermediate[2] = data_in[1] ^ data_in[2];\n    assign intermediate[3] = data_in[2] ^ data_in[3];\n\n    assign gray_out = intermediate;\n\nendmodule\n",
        "module_name": "gray_code_converter",
        "module_hash": "6974bb3243f375faa2b50511a3ebda31",
        "dataset_index": 21268
      },
      "top__26546e8d": {
        "rtl_code": "module top_module (\n    input clk,\n    input slowena,\n    input reset,\n    input select,\n    input a,\n    input b,\n    output reg out\n);\n\nreg [3:0] count;\nwire xor_out;\n\n// Decade counter\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else if (slowena) begin\n        count <= count;\n    end else begin\n        count <= count + 1;\n    end\nend\n\n// XOR gate\nassign xor_out = a ^ b;\n\n// Control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 1'b0;\n    end else begin\n        if (select) begin\n            out <= xor_out;\n        end else begin\n            out <= count[3];\n        end\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "26546e8d17d5ad81d3a17f9fbc94c5f0",
        "dataset_index": 13623
      },
      "and_gate_f7daa1c4": {
        "rtl_code": "module and_gate(a, b, c);\n    input [3:0] a, b;\n    output [3:0] c;\n\n    assign c = a & b;\nendmodule",
        "module_name": "and_gate",
        "module_hash": "f7daa1c4118199e24a63d5f3bf3f7c67",
        "dataset_index": 16716
      },
      "paula_audio_channel_36d0c30c": {
        "rtl_code": "module paula_audio_channel\n(\n  input   clk,          input clk7_en,\n  input  cck,          input   reset,            input  aen,          input  dmaena,          input  [3:1] reg_address_in,    input   [15:0] data,       output  [6:0] volume,      output  [7:0] sample,      output  intreq,          input  intpen,          output  reg dmareq,        output  reg dmas,        input  strhor          );\n\nparameter  AUDLEN = 4'h4;\nparameter  AUDPER = 4'h6;\nparameter  AUDVOL = 4'h8;\nparameter  AUDDAT = 4'ha;\n\nreg    [15:0] audlen;      reg    [15:0] audper;      reg    [6:0] audvol;      reg    [15:0] auddat;      reg    [15:0] datbuf;      reg    [2:0] audio_state;    reg    [2:0] audio_next;     wire  datwrite;        reg    volcntrld;        reg    pbufld1;        reg    [15:0] percnt;      reg    percount;        reg    percntrld;        wire  perfin;          reg    [15:0] lencnt;      reg    lencount;        reg    lencntrld;        wire  lenfin;          reg   AUDxDAT;        wire  AUDxON;          reg    AUDxDR;          reg    AUDxIR;          wire  AUDxIP;          reg    intreq2_set;\nreg    intreq2_clr;\nreg    intreq2;        reg    dmasen;          reg    penhi;          reg silence;  reg silence_d;  reg dmaena_d;\n\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (reset)\n      audlen[15:0] <= 16'h00_00;\n    else if (aen && (reg_address_in[3:1]==AUDLEN[3:1]))\n      audlen[15:0] <= data[15:0];\n  end\nend\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (reset)\n      audper[15:0] <= 16'h00_00;\n    else if (aen && (reg_address_in[3:1]==AUDPER[3:1]))\n      audper[15:0] <= data[15:0];\n  end\nend\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (reset)\n      audvol[6:0] <= 7'b000_0000;\n    else if (aen && (reg_address_in[3:1]==AUDVOL[3:1]))\n      audvol[6:0] <= data[6:0];\n  end\nend\n\nassign datwrite = (aen && (reg_address_in[3:1]==AUDDAT[3:1])) ? 1'b1 : 1'b0;\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (reset)\n      auddat[15:0] <= 16'h00_00;\n    else if (datwrite)\n      auddat[15:0] <= data[15:0];\n  end\nend\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (datwrite)\n      AUDxDAT <= 1'b1;\n    else if (cck)\n      AUDxDAT <= 1'b0;\n  end\nend\n\nassign  AUDxON = dmaena;  assign  AUDxIP = intpen;  assign intreq = AUDxIR;    always @(posedge clk) begin\n  if (clk7_en) begin\n    if (percntrld && cck)percnt[15:0] <= audper[15:0];\n    else if (percount && cck)percnt[15:0] <= percnt[15:0] - 16'd1;\n  end\nend\n\nassign perfin = (percnt[15:0]==1 && cck) ? 1'b1 : 1'b0;\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (lencntrld && cck) begin lencnt[15:0] <= (audlen[15:0]);\n      silence<=1'b0;\n      if(audlen==1 || audlen==0)\n         silence<=1'b1;\n    end else if (lencount && cck)lencnt[15:0] <= (lencnt[15:0] - 1);\n    dmaena_d<=dmaena;\n    if(dmaena_d==1'b1 && dmaena==1'b0) begin\n      silence_d<=1'b1; silence<=1'b1;\n    end\n    if(AUDxDAT && cck)  if(silence_d)\n        silence_d<=1'b0;\n      else\n        silence<=1'b0;\n  end\nend\n\nassign lenfin = (lencnt[15:0]==1 && cck) ? 1'b1 : 1'b0;\n\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (reset)\n      datbuf[15:0] <= 16'h00_00;\n    else if (pbufld1 && cck)\n      datbuf[15:0] <= auddat[15:0];\n  end\nend\n\nassign sample[7:0] = silence ? 8'b0 : (penhi ? datbuf[15:8] : datbuf[7:0]);\n\nassign volume[6:0] = audvol[6:0];\n\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (reset)\n    begin\n      dmareq <= 1'b0;\n      dmas <= 1'b0;\n    end\n    else if (AUDxDR && cck)\n    begin\n      dmareq <= 1'b1;\n      dmas <= dmasen | lenfin;\n    end\n    else if (strhor) begin\n      dmareq <= 1'b0;\n      dmas <= 1'b0;\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (cck)\n      if (intreq2_set)\n        intreq2 <= 1'b1;\n      else if (intreq2_clr)\n        intreq2 <= 1'b0;\n  end\nend\n\nparameter AUDIO_STATE_0 = 3'b000;\nparameter AUDIO_STATE_1 = 3'b001;\nparameter AUDIO_STATE_2 = 3'b011;\nparameter AUDIO_STATE_3 = 3'b010;\nparameter AUDIO_STATE_4 = 3'b110;\n\nalways @(posedge clk) begin\n  if (clk7_en) begin\n    if (reset)\n      audio_state <= AUDIO_STATE_0;\n    else if (cck)\n      audio_state <= audio_next;\n  end\nend\n\nalways @(*) begin\n  case (audio_state)\n\n    AUDIO_STATE_0: begin\n      intreq2_clr = 1'b1;\n      intreq2_set = 1'b0;\n      lencount = 1'b0;\n      penhi = 1'b0;\n      percount = 1'b0;\n      percntrld = 1'b1;\n\n      if (AUDxON) begin\n        audio_next = AUDIO_STATE_1;\n        AUDxDR = 1'b1;\n        AUDxIR = 1'b0;\n        dmasen = 1'b1;\n        lencntrld = 1'b1;\n        pbufld1 = 1'b0;\n        volcntrld = 1'b0;\n      end\n      else if (AUDxDAT && !AUDxON && !AUDxIP)  begin\n        audio_next = AUDIO_STATE_3;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b1;\n        dmasen = 1'b0;\n        lencntrld = 1'b0;\n        pbufld1 = 1'b1;\n        volcntrld = 1'b1;\n      end\n      else\n      begin\n        audio_next = AUDIO_STATE_0;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b0;\n        dmasen = 1'b0;\n        lencntrld = 1'b0;\n        pbufld1 = 1'b0;\n        volcntrld = 1'b0;\n      end\n    end\n\n    AUDIO_STATE_1: begin\n      dmasen = 1'b0;\n      intreq2_clr = 1'b1;\n      intreq2_set = 1'b0;\n      lencntrld = 1'b0;\n      penhi = 1'b0;\n      percount = 1'b0;\n\n      if (AUDxON && AUDxDAT) begin\n        audio_next = AUDIO_STATE_2;\n        AUDxDR = 1'b1;\n        AUDxIR = 1'b1;\n        lencount = ~lenfin;\n        pbufld1 = 1'b0;  percntrld = 1'b0;\n        volcntrld = 1'b0;\n      end\n      else if (!AUDxON) begin\n        audio_next = AUDIO_STATE_0;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b0;\n        lencount = 1'b0;\n        pbufld1 = 1'b0;\n        percntrld = 1'b0;\n        volcntrld = 1'b0;\n      end\n      else\n      begin\n        audio_next = AUDIO_STATE_1;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b0;\n        lencount = 1'b0;\n        pbufld1 = 1'b0;\n        percntrld = 1'b0;\n        volcntrld = 1'b0;\n      end\n    end\n\n    AUDIO_STATE_2: begin\n      dmasen = 1'b0;\n      intreq2_clr = 1'b1;\n      intreq2_set = 1'b0;\n      lencntrld = 1'b0;\n      penhi = 1'b0;\n      percount = 1'b0;\n\n      if (AUDxON && AUDxDAT) begin\n        audio_next = AUDIO_STATE_3;\n        AUDxDR = 1'b1;\n        AUDxIR = 1'b0;\n        lencount = ~lenfin;\n        pbufld1 = 1'b1;  percntrld = 1'b1;\n        volcntrld = 1'b1;\n      end\n      else if (!AUDxON) begin\n        audio_next = AUDIO_STATE_0;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b0;\n        lencount = 1'b0;\n        pbufld1 = 1'b0;\n        percntrld = 1'b0;\n        volcntrld = 1'b0;\n      end\n      else\n      begin\n        audio_next = AUDIO_STATE_2;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b0;\n        lencount = 1'b0;\n        pbufld1 = 1'b0;\n        percntrld = 1'b0;\n        volcntrld = 1'b0;\n      end\n    end\n\n    AUDIO_STATE_3: begin\n      AUDxDR = 1'b0;\n      AUDxIR = 1'b0;\n      dmasen = 1'b0;\n      intreq2_clr = 1'b0;\n      intreq2_set = lenfin & AUDxON & AUDxDAT;\n      lencount = ~lenfin & AUDxON & AUDxDAT;\n      lencntrld = lenfin & AUDxON & AUDxDAT;\n      pbufld1 = 1'b0;\n      penhi = 1'b1;\n      volcntrld = 1'b0;\n\n      if (perfin) begin\n        audio_next = AUDIO_STATE_4;\n        percount = 1'b0;\n        percntrld = 1'b1;\n      end\n      else\n      begin\n        audio_next = AUDIO_STATE_3;\n        percount = 1'b1;\n        percntrld = 1'b0;\n      end\n    end\n\n    AUDIO_STATE_4: begin\n      dmasen = 1'b0;\n      intreq2_set = lenfin & AUDxON & AUDxDAT;\n      lencount = ~lenfin & AUDxON & AUDxDAT;\n      lencntrld = lenfin & AUDxON & AUDxDAT;\n      penhi = 1'b0;\n      volcntrld = 1'b0;\n\n      if (perfin && (AUDxON || !AUDxIP)) begin\n        audio_next = AUDIO_STATE_3;\n        AUDxDR = AUDxON;\n        AUDxIR = (intreq2 & AUDxON) | ~AUDxON;\n        intreq2_clr = intreq2;\n        pbufld1 = 1'b1;\n        percount = 1'b0;\n        percntrld = 1'b1;\n      end\n      else if (perfin && !AUDxON && AUDxIP) begin\n        audio_next = AUDIO_STATE_0;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b0;\n        intreq2_clr = 1'b0;\n        pbufld1 = 1'b0;\n        percount = 1'b0;\n        percntrld = 1'b0;\n      end\n      else\n      begin\n        audio_next = AUDIO_STATE_4;\n        AUDxDR = 1'b0;\n        AUDxIR = 1'b0;\n        intreq2_clr = 1'b0;\n        pbufld1 = 1'b0;\n        percount = 1'b1;\n        percntrld = 1'b0;\n      end\n    end\n\n    default:\n    begin\n      audio_next = AUDIO_STATE_0;\n      AUDxDR = 1'b0;\n      AUDxIR = 1'b0;\n      dmasen = 1'b0;\n      intreq2_clr = 1'b0;\n      intreq2_set = 1'b0;\n      lencntrld = 1'b0;\n      lencount = 1'b0;\n      pbufld1 = 1'b0;\n      penhi = 1'b0;\n      percount = 1'b0;\n      percntrld = 1'b0;\n      volcntrld = 1'b0;\n    end\n\n  endcase\nend\n\n\nendmodule\n\n",
        "module_name": "paula_audio_channel",
        "module_hash": "36d0c30c6b05d895d07cd46c0da1814f",
        "dataset_index": 13883
      },
      "DRAMReader_5b27de68": {
        "rtl_code": "module DRAMReader(\n    input wire ACLK,\n    input wire ARESETN,\n    output reg [31:0] M_AXI_ARADDR,\n    input wire M_AXI_ARREADY,\n    output wire  M_AXI_ARVALID,\n    input wire [63:0] M_AXI_RDATA,\n    output wire M_AXI_RREADY,\n    input wire [1:0] M_AXI_RRESP,\n    input wire M_AXI_RVALID,\n    input wire M_AXI_RLAST,\n    output wire [3:0] M_AXI_ARLEN,\n    output wire [1:0] M_AXI_ARSIZE,\n    output wire [1:0] M_AXI_ARBURST,\n    \n    input wire CONFIG_VALID,\n    output wire CONFIG_READY,\n    input wire [31:0] CONFIG_START_ADDR,\n    input wire [31:0] CONFIG_NBYTES,\n    \n    input wire DATA_READY_DOWNSTREAM,\n    output wire DATA_VALID,\n    output wire [63:0] DATA\n);\n\nassign M_AXI_ARLEN = 4'b1111;\nassign M_AXI_ARSIZE = 2'b11;\nassign M_AXI_ARBURST = 2'b01;\nparameter IDLE = 0, RWAIT = 1;\n    \nreg [31:0] a_count;\nreg a_state;  \nassign M_AXI_ARVALID = (a_state == RWAIT);\nalways @(posedge ACLK) begin\n    if (ARESETN == 0) begin\n        a_state <= IDLE;\n        M_AXI_ARADDR <= 0;\n        a_count <= 0;\n    end else case(a_state)\n        IDLE: begin\n            if(CONFIG_VALID) begin\n                M_AXI_ARADDR <= CONFIG_START_ADDR;\n                a_count <= CONFIG_NBYTES[31:7];\n                a_state <= RWAIT;\n            end\n        end\n        RWAIT: begin\n            if (M_AXI_ARREADY == 1) begin\n                if(a_count - 1 == 0)\n                    a_state <= IDLE;\n                a_count <= a_count - 1;\n                M_AXI_ARADDR <= M_AXI_ARADDR + 128; end\n        end\n    endcase\nend\n    \nreg [31:0] b_count;\nreg r_state;\nassign M_AXI_RREADY = (r_state == RWAIT) && DATA_READY_DOWNSTREAM;\nalways @(posedge ACLK) begin\n    if (ARESETN == 0) begin\n        r_state <= IDLE;\n        b_count <= 0;\n    end else case(r_state)\n        IDLE: begin\n            if(CONFIG_VALID) begin\n                b_count <= {CONFIG_NBYTES[31:7],7'b0}; r_state <= RWAIT;\n            end\n        end\n        RWAIT: begin\n            if (M_AXI_RVALID && DATA_READY_DOWNSTREAM) begin\n                if(b_count - 8 == 0)\n                    r_state <= IDLE;\n                b_count <= b_count - 8; end\n        end\n    endcase\nend\n\nassign DATA = M_AXI_RDATA;\nassign DATA_VALID = M_AXI_RVALID && (r_state == RWAIT);\nassign CONFIG_READY = (r_state == IDLE) && (a_state == IDLE);\n\nendmodule ",
        "module_name": "DRAMReader",
        "module_hash": "5b27de68f035ef891088580fefaa88d2",
        "dataset_index": 22874
      },
      "ip_design_rst_ps7_0_100M_0_55b12b0c": {
        "rtl_code": "module ip_design_rst_ps7_0_100M_0(\n  input slowest_sync_clk,\n  input ext_reset_in,\n  input aux_reset_in,\n  input mb_debug_sys_rst,\n  input dcm_locked,\n  output reg mb_reset,\n  output reg [0:0]bus_struct_reset,\n  output reg [0:0]peripheral_reset,\n  output reg [0:0]interconnect_aresetn,\n  output reg [0:0]peripheral_aresetn\n);\n  always @(posedge slowest_sync_clk) begin\n    if (ext_reset_in || aux_reset_in || mb_debug_sys_rst || !dcm_locked) begin\n      mb_reset <= 1;\n      bus_struct_reset <= 1;\n      peripheral_reset <= 1;\n      interconnect_aresetn <= 1;\n      peripheral_aresetn <= 1;\n    end\n    else begin\n      mb_reset <= 0;\n      bus_struct_reset <= 0;\n      peripheral_reset <= 0;\n      interconnect_aresetn <= 0;\n      peripheral_aresetn <= 0;\n    end\n  end\nendmodule",
        "module_name": "ip_design_rst_ps7_0_100M_0",
        "module_hash": "55b12b0c874656ee9e8ead646121ef7a",
        "dataset_index": 12248
      },
      "signed_multiplier_d4668f72": {
        "rtl_code": "module signed_multiplier(\n    input clk,\n    input reset,\n    input signed [7:0] in1,\n    input signed [7:0] in2,\n    output signed [15:0] out\n);\n\n    assign out = in1 * in2;\n\nendmodule",
        "module_name": "signed_multiplier",
        "module_hash": "d4668f72944c7e3492632627477b1319",
        "dataset_index": 15814
      },
      "gray_code_state_machine #_d049040e": {
        "rtl_code": "module gray_code_state_machine #(\n  parameter n = 4 // number of bits in the Gray code sequence\n)(\n  input clk, // clock signal\n  input rst, // reset signal\n  output [n-1:0] state // Gray code state\n);\n\n\n// define the next state logic here\nreg [n-1:0] next_state;\nalways @(posedge clk, posedge rst) begin\n  if (rst) begin\n    next_state <= 0;\n  end else begin\n    next_state <= next_state + 1;\n    if (next_state == (1 << n)) begin\n      next_state <= 0;\n    end\n  end\nend\n\n// convert binary state to Gray code format\nfunction [n-1:0] binary_to_gray;\n  input [n-1:0] binary;\n  begin\n    binary_to_gray = binary ^ (binary >> 1);\n  end\nendfunction\n\n// assign Gray code state to output\nassign state = binary_to_gray(next_state);\n\nendmodule",
        "module_name": "gray_code_state_machine #",
        "module_hash": "d049040ed224c6d01e8b44b823c3f8e5",
        "dataset_index": 2778
      },
      "nand4bb_ff34aa51": {
        "rtl_code": "module nand4bb (\n    input  A_N ,\n    input  B_N ,\n    input  C   ,\n    input  D   ,\n    output Y   ,\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n    // Define internal signals\n    wire  AB_N;\n    wire  CD_N;\n    wire  Y_N;\n\n    // Implement the NAND gate\n    assign AB_N = ~(A_N & B_N);\n    assign CD_N = ~(C & D);\n    assign Y_N  = ~(AB_N & CD_N);\n    assign Y    = Y_N;\n\nendmodule",
        "module_name": "nand4bb",
        "module_hash": "ff34aa51a9ffce9285b728a2f66775d0",
        "dataset_index": 9128
      },
      "mig_7series_v4_0_axi_mc_wr_cmd_fsm #_e9b1f386": {
        "rtl_code": "\n\n\nmodule mig_7series_v4_0_axi_mc_wr_cmd_fsm #(\nparameter integer C_MC_BURST_LEN              = 1,\n                     parameter integer C_MC_RD_INST              = 0\n  \n)\n(\ninput  wire                                 clk           , \n  input  wire                                 reset         , \n  output reg                                  axready       , \n  input  wire                                 axvalid       , \n  output wire                                 cmd_en        , \n  input  wire                                 cmd_full      , \n  output wire                                 next          , \n  input  wire                                 next_pending  ,\n  input  wire                                 data_rdy    ,\n  output wire                                 b_push        ,\n  input  wire                                 b_full        ,\n  output wire                                 cmd_en_last   \n);\n\nassign cmd_en = (~b_full & axvalid & data_rdy);\n\n    assign next = (~cmd_full & cmd_en);\n\n    assign cmd_en_last = next & ~next_pending;\n\n    assign b_push  = cmd_en_last;\n\n  always @(posedge clk) begin\n    if (reset)\n      axready <= 1'b0;\n    else\n      axready <= ~axvalid | cmd_en_last;\n  end\n\nendmodule\n\n",
        "module_name": "mig_7series_v4_0_axi_mc_wr_cmd_fsm #",
        "module_hash": "e9b1f3860fe56d7c405f6e66dc804ecf",
        "dataset_index": 25333
      },
      "jt51_timers_64c8aec2": {
        "rtl_code": "\n\nmodule jt51_timers(\n  input\t\t\tclk,\n  input\t\t\trst,\n  input [9:0]\tvalue_A,\n  input [7:0]\tvalue_B,\n  input \t\tload_A,\n  input \t\tload_B,\n  input \t\tclr_flag_A,\n  input \t\tclr_flag_B,\n  input\t\t\tset_run_A,\n  input\t\t\tset_run_B,  \n  input\t\t\tclr_run_A,\n  input\t\t\tclr_run_B,  \n  input \t\tenable_irq_A,\n  input \t\tenable_irq_B,\n  output \t \tflag_A,\n  output \t \tflag_B,\n  output\t\toverflow_A,\n  output \t \tirq_n\n);\n\nassign irq_n = ~( (flag_A&enable_irq_A) | (flag_B&enable_irq_B) );\n\njt51_timer #(.mult_width(6), .counter_width(10)) timer_A(\n\t.clk\t\t( clk\t\t), \n\t.rst\t\t( rst\t\t),\n\t.start_value( value_A\t),\t\n\t.load\t\t( load_A   \t),\n\t.clr_flag   ( clr_flag_A),\n\t.set_run\t( set_run_A\t),\n\t.clr_run\t( clr_run_A ),\n\t.flag\t\t( flag_A\t),\n\t.overflow\t( overflow_A)\n);\n\njt51_timer #(.mult_width(10), .counter_width(8)) timer_B(\n\t.clk\t\t( clk\t\t), \n\t.rst\t\t( rst\t\t),\n\t.start_value( value_B\t),\t\n\t.load\t\t( load_B   \t),\n\t.clr_flag   ( clr_flag_B),\n\t.set_run\t( set_run_B\t),\n\t.clr_run\t( clr_run_B ),\n\t.flag\t\t( flag_B\t),\n\t.overflow\t(\t\t\t)\n);\n\nendmodule\n\nmodule jt51_timer #(parameter counter_width = 10, mult_width=5 )\n(\n\tinput\tclk, \n\tinput\trst,\n\tinput\t[counter_width-1:0] start_value,\n\tinput\tload,\n\tinput\tclr_flag,\n\tinput\tset_run,\n\tinput\tclr_run,\n\toutput reg flag,\n\toutput reg overflow\n);\n\nreg run;\nreg [   mult_width-1:0] mult;\nreg [counter_width-1:0] cnt;\n\nalways@(posedge clk)\n\tif( clr_flag || rst)\n\t\tflag <= 1'b0;\n\telse if(overflow) flag<=1'b1;\n\t\nalways@(posedge clk)\n\tif( clr_run || rst)\n\t\trun <= 1'b0;\n\telse if(set_run || load) run<=1'b1;\n\nreg [mult_width+counter_width-1:0] next, init;\n\nalways @(*) begin\n\t{overflow, next } = { 1'b0, cnt, mult } + 1'b1;\n\tinit = { start_value, { (mult_width){1'b0} } };\nend\n\nalways @(posedge clk) begin : counter\n\tif( load ) begin\n\t  mult <= { (mult_width){1'b0} };\n\t  cnt  <= start_value;\n\tend\t\t\n\telse if( run )\n\t  { cnt, mult } <= overflow ? init : next;\nend\nendmodule\n",
        "module_name": "jt51_timers",
        "module_hash": "64c8aec25c47aa7229f5de2fce3cc7a5",
        "dataset_index": 11924
      },
      "memory_aac0570a": {
        "rtl_code": "module memory (remapping_memory, full, rd_data, rd_clk, rd_en, rd_addr, reset);\n\n  parameter RD_DATA_WIDTH = 1;\n  parameter RD_ADDR_WIDTH = 2;\n  parameter MEM_DEPTH = 4;\n  \n  input wire [MEM_DEPTH-1:0] remapping_memory;\n  input wire full;\n  output reg [RD_DATA_WIDTH-1:0] rd_data;\n  input wire rd_clk, rd_en;\n  input wire [RD_ADDR_WIDTH-1:0] rd_addr;\n  input wire reset;\n  \n  reg [RD_DATA_WIDTH-1:0] memory [0:MEM_DEPTH-1];\n  integer i;\n  \n  always @(posedge full, posedge reset) begin\n    if(reset) begin\n      for(i=0; i<MEM_DEPTH; i=i+1) begin\n        memory[i] <= 0;\n      end\n    end else begin\n      for(i=0; i<MEM_DEPTH; i=i+1) begin\n        memory[i] <= remapping_memory[i];\n      end\n    end\n  end\n  \n  always @(posedge rd_clk, posedge reset) begin\n    if(reset) begin\n      rd_data <= 0;\n    end else begin\n      if(rd_en) begin\n        rd_data <= memory[rd_addr];\n      end\n    end\n  end\n  \nendmodule",
        "module_name": "memory",
        "module_hash": "aac0570ae0bf0ef1fd8bba8bd9fbbe20",
        "dataset_index": 16839
      },
      "barrel_shifter_670bae8a": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] D,\n    input [1:0] A,\n    output [3:0] S\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\nreg [3:0] stage3_out;\n\nalways @(*) begin\n    case(A)\n        2'b00: stage1_out = D;\n        2'b01: stage1_out = {D[2:0], 1'b0};\n        2'b10: stage1_out = {D[1:0], 2'b00};\n        2'b11: stage1_out = {D[0], 3'b000};\n    endcase\nend\n\nalways @(*) begin\n    case(A)\n        2'b00: stage2_out = stage1_out;\n        2'b01: stage2_out = {stage1_out[1:0], 2'b00};\n        2'b10: stage2_out = {stage1_out[0], 3'b000};\n        2'b11: stage2_out = 4'b0000;\n    endcase\nend\n\nalways @(*) begin\n    case(A)\n        2'b00: stage3_out = stage2_out;\n        2'b01: stage3_out = {stage2_out[2:0], 1'b0};\n        2'b10: stage3_out = {stage2_out[1:0], 2'b00};\n        2'b11: stage3_out = {stage2_out[0], 3'b000};\n    endcase\nend\n\nassign S = stage3_out;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "670bae8abf2dd4fe36e45a657112d339",
        "dataset_index": 7792
      },
      "mig_7series_v4_0_ecc_merge_enc_2f62c3fa": {
        "rtl_code": "\n\nmodule mig_7series_v4_0_ecc_merge_enc\n  #(\n    parameter TCQ = 100,\n    parameter PAYLOAD_WIDTH         = 64,\n    parameter CODE_WIDTH            = 72,\n    parameter DATA_BUF_ADDR_WIDTH   = 4,\n    parameter DATA_BUF_OFFSET_WIDTH = 1,\n    parameter DATA_WIDTH            = 64,\n    parameter DQ_WIDTH              = 72,\n    parameter ECC_WIDTH             = 8,\n    parameter nCK_PER_CLK           = 4\n   )\n   (\n    \n  mc_wrdata, mc_wrdata_mask,\n  clk, rst, wr_data, wr_data_mask, rd_merge_data, h_rows, raw_not_ecc\n  );\n\n  input clk;\n  input rst;\n\n  input [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data;\n  input [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask;\n  input [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data;\n  \n  reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] wr_data_r;\n  reg [2*nCK_PER_CLK*DATA_WIDTH/8-1:0] wr_data_mask_r;\n  reg [2*nCK_PER_CLK*DATA_WIDTH-1:0] rd_merge_data_r;\n\n  always @(posedge clk) wr_data_r <= #TCQ wr_data;\n  always @(posedge clk) wr_data_mask_r <= #TCQ wr_data_mask;\n  always @(posedge clk) rd_merge_data_r <= #TCQ rd_merge_data;\n  \n  wire [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] merged_data;\n  genvar h;\n  genvar i;\n  generate\n    for (h=0; h<2*nCK_PER_CLK; h=h+1) begin : merge_data_outer\n      for (i=0; i<DATA_WIDTH/8; i=i+1) begin : merge_data_inner\n        assign merged_data[h*PAYLOAD_WIDTH+i*8+:8] =  \n                wr_data_mask[h*DATA_WIDTH/8+i]\n                  ? rd_merge_data[h*DATA_WIDTH+i*8+:8]               \n                  : wr_data[h*PAYLOAD_WIDTH+i*8+:8];\n      end\n      if (PAYLOAD_WIDTH > DATA_WIDTH)\n        assign merged_data[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH]=\n                      wr_data[(h+1)*PAYLOAD_WIDTH-1-:PAYLOAD_WIDTH-DATA_WIDTH];\n                                                                   \n    end\n  endgenerate\n\n  input [CODE_WIDTH*ECC_WIDTH-1:0] h_rows;\n  input [2*nCK_PER_CLK-1:0] raw_not_ecc;\n  reg [2*nCK_PER_CLK-1:0] raw_not_ecc_r;\n  always @(posedge clk) raw_not_ecc_r <= #TCQ raw_not_ecc;\n  output reg [2*nCK_PER_CLK*DQ_WIDTH-1:0] mc_wrdata;\n  reg [2*nCK_PER_CLK*DQ_WIDTH-1:0] mc_wrdata_c;\n  genvar j;\n  integer k;\n  generate\n    for (j=0; j<2*nCK_PER_CLK; j=j+1) begin : ecc_word\n      always @(h_rows or merged_data or raw_not_ecc_r) begin\n        mc_wrdata_c[j*DQ_WIDTH+:DQ_WIDTH] =\n          {{DQ_WIDTH-PAYLOAD_WIDTH{1'b0}},\n           merged_data[j*PAYLOAD_WIDTH+:PAYLOAD_WIDTH]};\n        for (k=0; k<ECC_WIDTH; k=k+1)\n          if (~raw_not_ecc_r[j])\n            mc_wrdata_c[j*DQ_WIDTH+CODE_WIDTH-k-1] =\n              ^(merged_data[j*PAYLOAD_WIDTH+:DATA_WIDTH] & \n                h_rows[k*CODE_WIDTH+:DATA_WIDTH]);\n      end\n    end\n  endgenerate\nalways @(posedge clk) mc_wrdata <= mc_wrdata_c;\n\n  output wire[2*nCK_PER_CLK*DQ_WIDTH/8-1:0] mc_wrdata_mask;\n  assign mc_wrdata_mask = {2*nCK_PER_CLK*DQ_WIDTH/8{1'b0}};\n\nendmodule\n",
        "module_name": "mig_7series_v4_0_ecc_merge_enc",
        "module_hash": "2f62c3fa476cae8c2fcf3adbcd799935",
        "dataset_index": 25531
      },
      "vgabase_df58556e": {
        "rtl_code": "\n\nmodule vgabase(\n    input wire clk,\n    input wire clr,\n    output reg hsync,\n    output reg vsync,\n    output reg [11:0] hc,\n    output reg [11:0] vc,\n    output wire vidon\n  );\n\n\nparameter hpixels = 12'd1344;\nparameter vlines  = 12'd806;\nparameter hsp   = 12'd136;\nparameter hbp   = 12'd160;\nparameter hfp   = 12'd24;\nparameter vsp   = 12'd6;\nparameter vbp   = 12'd29;\nparameter vfp   = 12'd3;\n\n\nreg vsenable;\n\ninitial begin\n  hc <= hpixels - hsp - hbp;\n  vc <= vlines - vsp - vbp;\n  hsync <= 0;\n  vsync <= 0;\n  vsenable <= 0;\nend\n\nalways @(posedge clk or posedge clr) begin\n    if(clr == 1)\n      hc <= hpixels - hsp - hbp;\n  else begin\n      if(hc == hpixels - 1) begin\n        hc <= 0;\n      vsenable <= 1;\n    end else begin\n        hc <= hc + 1'b1;\n      vsenable <= 0;\n    end\n  end\nend\n\nalways @(*) begin\n    if(hpixels - hsp - hbp < hc && hc <= hpixels - hbp)\n      hsync = 0;\n  else\n      hsync = 1;\nend\n\nalways @(posedge clk or posedge clr) begin\n    if(clr == 1)\n      vc <= vlines - vsp - vbp;\n  else if(vsenable == 1)\n      if(vc == vlines - 1)\n        vc <= 0;\n    else\n        vc <= vc + 1'b1;\nend\n\nalways @(*) begin\n    if(vlines - vsp - vbp < vc && vc <= vlines - vbp)\n      vsync = 0;\n  else\n      vsync = 1;\nend\n\nassign vidon=(hc<hpixels-hfp-hsp-hbp)&&(vc<vlines-vfp-vsp-vbp);\n\nendmodule\n",
        "module_name": "vgabase",
        "module_hash": "df58556ea430d25a41fccffe5c196fd5",
        "dataset_index": 16869
      },
      "greater_than_or_equal_a5ae74a6": {
        "rtl_code": "\nmodule greater_than_or_equal(a, b, y);\n  input [7:0] a;\n  input [7:0] b;\n  output y;\n  reg y;\n\n  always @(*) begin\n    if (a >= b) begin\n      y = 1;\n    end else begin\n      y = 0;\n    end\n  end\nendmodule\n",
        "module_name": "greater_than_or_equal",
        "module_hash": "a5ae74a6eed961e0c4362af819f3f461",
        "dataset_index": 15485
      },
      "traffic_light_controller_34a93c87": {
        "rtl_code": "module traffic_light_controller (\n  input clk,\n  input button,\n  output reg red,\n  output reg yellow,\n  output reg green\n);\n\n  // Define the state machine states\n  parameter STATE_GREEN = 2'b00;\n  parameter STATE_YELLOW = 2'b01;\n  parameter STATE_RED = 2'b10;\n\n  // Define the state machine signals\n  reg [1:0] state;\n  reg [3:0] counter;\n\n  // Initialize the state machine\n  always @ (posedge clk) begin\n    if (button) begin\n      state <= STATE_RED;\n      counter <= 0;\n    end else begin\n      case (state)\n        STATE_GREEN: begin\n          if (counter == 10) begin\n            state <= STATE_YELLOW;\n            counter <= 0;\n          end else begin\n            counter <= counter + 1;\n          end\n        end\n        STATE_YELLOW: begin\n          if (counter == 2) begin\n            state <= STATE_RED;\n            counter <= 0;\n          end else begin\n            counter <= counter + 1;\n          end\n        end\n        STATE_RED: begin\n          if (counter == 10) begin\n            state <= STATE_YELLOW;\n            counter <= 0;\n          end else begin\n            counter <= counter + 1;\n          end\n        end\n      endcase\n    end\n  end\n\n  // Control the traffic light outputs based on the state machine state\n  always @ (posedge clk) begin\n    case (state)\n      STATE_GREEN: begin\n        green <= 1;\n        yellow <= 0;\n        red <= 0;\n      end\n      STATE_YELLOW: begin\n        green <= 0;\n        yellow <= 1;\n        red <= 0;\n      end\n      STATE_RED: begin\n        green <= 0;\n        yellow <= 0;\n        red <= 1;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "traffic_light_controller",
        "module_hash": "34a93c87d7fc5e79ba22b88b8fa7cb02",
        "dataset_index": 2160
      },
      "vga_renderer_8b0475be": {
        "rtl_code": "module vga_renderer\n\t#(parameter WIDTH = 800,          H_FRONT_PORCH = 32,   H_SYNC = 120,          H_BACK_PORCH = 32,    HEIGHT = 480,         V_FRONT_PORCH = 8,   V_SYNC = 5,           V_BACK_PORCH = 13)    (\n\t input vga_clk,\n\t \n\t input reset_n,\n\t \n\t input [7:0] red,\n\t input [7:0] green,\n\t input [7:0] blue,\n\t \n\t output [7:0] vga_red,\n\t output [7:0] vga_green,\n\t output [7:0] vga_blue,\n\t \n\t output vga_hsync,\n\t output vga_vsync,\n\t \n\t output fb_hblank,\n\t output fb_vblank\n\t);\n\t\n\tlocalparam PIXELS_PER_LINE = WIDTH + H_BACK_PORCH + H_SYNC + H_FRONT_PORCH;\n\tlocalparam LINES_PER_FRAME = HEIGHT + V_BACK_PORCH + V_SYNC + V_FRONT_PORCH;\n\t\n\tlocalparam XBITS = $clog2(PIXELS_PER_LINE);\n\tlocalparam YBITS = $clog2(LINES_PER_FRAME);\n\t\n\treg [XBITS-1:0] x_pos;\n\twire x_max = (x_pos == (PIXELS_PER_LINE - 1));\n\t\n\treg [YBITS-1:0] y_pos;\n\twire y_max = (y_pos == (LINES_PER_FRAME - 1));\n\t\n\treg hsync;\n\tassign vga_hsync = ~hsync;\n\t\n\treg vsync;\n\tassign vga_vsync = ~vsync;\n\t\n\tassign fb_vblank = (y_pos >= HEIGHT);\n\tassign fb_hblank = (x_pos >= WIDTH);\n\t\n\talways @ (posedge vga_clk or negedge reset_n) begin\n\t\tif(~reset_n) begin\n\t\t\tx_pos <= 0;\n\t\t\ty_pos <= 0;\n\t\t\thsync <= 1'b0;\n\t\t\tvsync <= 1'b0;\n\t\tend else begin\n\t\t\tif(x_max) begin\n\t\t\t\tx_pos <= 0;\n\t\t\t\tif(y_max) begin\n\t\t\t\t\ty_pos <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\ty_pos <= y_pos + 1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tx_pos <= x_pos + 1;\n\t\t\tend\n\t\t\t\n\t\t\tif(x_pos == ((WIDTH + H_FRONT_PORCH) - 1)) hsync <= 1'b1;\n\t\t\telse if(x_pos == ((WIDTH + H_FRONT_PORCH + H_SYNC) - 1)) hsync <= 1'b0;\n\t\t\t\n\t\t\tif(y_pos == ((HEIGHT + V_FRONT_PORCH) - 1)) vsync <= 1'b1;\n\t\t\telse if(y_pos == ((HEIGHT + V_FRONT_PORCH + V_SYNC) - 1)) vsync <= 1'b0;\n\t\tend\n\tend\n\n\tassign vga_red = (x_pos < WIDTH && y_pos < HEIGHT) ? red : 8'b0;\n\tassign vga_green = (x_pos < WIDTH && y_pos < HEIGHT) ? green : 8'b0;\n\tassign vga_blue = (x_pos < WIDTH && y_pos < HEIGHT) ? blue : 8'b0;\n\t\nendmodule\n\t ",
        "module_name": "vga_renderer",
        "module_hash": "8b0475be272a16e203cd6c6531aace5d",
        "dataset_index": 23758
      },
      "signed_mag_comp_460f54b1": {
        "rtl_code": "module signed_mag_comp (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output reg C\n);\n\n    always @(*) begin\n        if (A[3] == 0 && B[3] == 1) // A is positive, B is negative\n            C = 1;\n        else if (A[3] == 1 && B[3] == 0) // A is negative, B is positive\n            C = 0;\n        else if (A[3] == 0 && B[3] == 0) // Both A and B are positive\n            C = (A >= B) ? 1 : 0;\n        else if (A[3] == 1 && B[3] == 1) // Both A and B are negative\n            C = (A <= B) ? 1 : 0;\n    end\n\nendmodule",
        "module_name": "signed_mag_comp",
        "module_hash": "460f54b1a74ebd6c0d8cd276a0f8e1f5",
        "dataset_index": 11751
      },
      "counter_4bit_3b6ec4db": {
        "rtl_code": "module counter_4bit (\n  input clk,\n  input reset,\n  input up_down,\n  input load,\n  input [3:0] D,\n  output reg [3:0] Q\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      Q <= 4'b0;\n    end else if (load) begin\n      Q <= D;\n    end else if (up_down) begin\n      Q <= Q + 1;\n    end else begin\n      Q <= Q - 1;\n    end\n  end\n\nendmodule\n",
        "module_name": "counter_4bit",
        "module_hash": "3b6ec4dbda82b2d37b19df9276b3d127",
        "dataset_index": 17425
      },
      "shifter_c6775373": {
        "rtl_code": "module shifter(input wire [33:0] in, output wire [15:0] out, input wire [7:0] shift);\n   reg [15:0] quotient, remainder;\n   wire [15:0] out_unclipped;\n   reg [18:0]  msbs;\n   wire        in_range;\n   \n   always @*\n     case(shift)\n       0 : quotient = in[15:0];\n       1 : quotient = in[16:1];\n       2 : quotient = in[17:2];\n       3 : quotient = in[18:3];\n       4 : quotient = in[19:4];\n       5 : quotient = in[20:5];\n       6 : quotient = in[21:6];\n       7 : quotient = in[22:7];\n       8 : quotient = in[23:8];\n       9 : quotient = in[24:9];\n       10 : quotient = in[25:10];\n       11 : quotient = in[26:11];\n       12 : quotient = in[27:12];\n       13 : quotient = in[28:13];\n       14 : quotient = in[29:14];\n       15 : quotient = in[30:15];\n       16 : quotient = in[31:16];\n       17 : quotient = in[32:17];\n       18 : quotient = in[33:18];\n       default : quotient = in[15:0];\n     endcase always @*\n     case(shift)\n       0 : remainder = 16'b0;\n       1 : remainder = {in[0],15'b0};\n       2 : remainder = {in[1:0],14'b0};\n       3 : remainder = {in[2:0],13'b0};\n       4 : remainder = {in[3:0],12'b0};\n       5 : remainder = {in[4:0],11'b0};\n       6 : remainder = {in[5:0],10'b0};\n       7 : remainder = {in[6:0],9'b0};\n       8 : remainder = {in[7:0],8'b0};\n       9 : remainder = {in[8:0],7'b0};\n       10 : remainder = {in[9:0],6'b0};\n       11 : remainder = {in[10:0],5'b0};\n       12 : remainder = {in[11:0],4'b0};\n       13 : remainder = {in[12:0],3'b0};\n       14 : remainder = {in[13:0],2'b0};\n       15 : remainder = {in[14:0],1'b0};\n       16 : remainder = in[15:0];\n       17 : remainder = in[16:1];\n       18 : remainder = in[17:2];\n       default : remainder = 16'b0;\n     endcase always @*\n     case(shift)\n       0 : msbs = in[33:15];\n       1 : msbs = {in[33],in[33:16]};\n       2 : msbs = {{2{in[33]}},in[33:17]};\n       3 : msbs = {{3{in[33]}},in[33:18]};\n       4 : msbs = {{4{in[33]}},in[33:19]};\n       5 : msbs = {{5{in[33]}},in[33:20]};\n       6 : msbs = {{6{in[33]}},in[33:21]};\n       7 : msbs = {{7{in[33]}},in[33:22]};\n       8 : msbs = {{8{in[33]}},in[33:23]};\n       9 : msbs = {{9{in[33]}},in[33:24]};\n       10 : msbs = {{10{in[33]}},in[33:25]};\n       11 : msbs = {{11{in[33]}},in[33:26]};\n       12 : msbs = {{12{in[33]}},in[33:27]};\n       13 : msbs = {{13{in[33]}},in[33:28]};\n       14 : msbs = {{14{in[33]}},in[33:29]};\n       15 : msbs = {{15{in[33]}},in[33:30]};\n       16 : msbs = {{16{in[33]}},in[33:31]};\n       17 : msbs = {{17{in[33]}},in[33:32]};\n       18 : msbs = {{18{in[33]}},in[33]};\n       default : msbs = in[33:15];\n     endcase assign     in_range = &msbs | ~(|msbs);\n   assign     out_unclipped = quotient + (in[33] & |remainder);\n   assign     out = in_range ? out_unclipped : {in[33],{15{~in[33]}}};\n   \nendmodule ",
        "module_name": "shifter",
        "module_hash": "c6775373854a0ba651b1b2620778a2a2",
        "dataset_index": 25363
      },
      "CDR_6903dde7": {
        "rtl_code": "module CDR (\n  input data,\n  input ref_clk,\n  output clk_out\n);\n\nparameter data_rate = 10e9; // data rate in bits per second\nparameter ref_clk_rate = 20e9; // frequency of reference clock signal in Hz\nparameter lock_threshold = 0.1; // threshold value for phase detector\n\nreg data_reg;\nreg ref_clk_reg;\nreg [1:0] phase_error;\nreg [31:0] filter_out;\nreg [31:0] vco_out;\n\nwire phase_error_sign;\nwire [31:0] filter_in;\nwire [31:0] vco_in;\n\nassign phase_error_sign = phase_error[1];\nassign filter_in = phase_error_sign ? -phase_error : phase_error;\nassign vco_in = filter_out;\n\nalways @(posedge ref_clk) begin\n  data_reg <= data;\n  ref_clk_reg <= ref_clk;\nend\n\nalways @(posedge ref_clk) begin\n  phase_error <= {phase_error[0], data_reg ^ ref_clk_reg};\nend\n\nalways @(posedge ref_clk) begin\n  filter_out <= filter_out + ((filter_in - filter_out) >> 4);\nend\n\nalways @(posedge ref_clk) begin\n  vco_out <= vco_out + ((vco_in - vco_out) >> 8);\nend\n\nassign clk_out = vco_out[31];\n\nendmodule",
        "module_name": "CDR",
        "module_hash": "6903dde7d6ac72da3d58760632655939",
        "dataset_index": 19613
      },
      "var24_multi_a5db9418": {
        "rtl_code": "\nmodule var24_multi (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, valid);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X;\n    output valid;\n\n    wire [8:0] min_value = 9'd120;\n    wire [8:0] max_weight = 9'd60;\n    wire [8:0] max_volume = 9'd60;\nwire [8:0]  total_value = \n        A * 9'd4\n      + B * 9'd8\n      + C * 9'd0\n      + D * 9'd20\n      + E * 9'd10\n      + F * 9'd12\n      + G * 9'd18\n      + H * 9'd14\n      + I * 9'd6\n      + J * 9'd15\n      + K * 9'd30\n      + L * 9'd8\n      + M * 9'd16\n      + N * 9'd18\n      + O * 9'd18\n      + P * 9'd14\n      + Q * 9'd7\n      + R * 9'd7\n      + S * 9'd29\n      + T * 9'd23\n      + U * 9'd24\n      + V * 9'd3\n      + W * 9'd18\n      + X * 9'd5;\n\n    wire [8:0]  total_weight = \n        A * 9'd28\n      + B * 9'd8\n      + C * 9'd27\n      + D * 9'd18\n      + E * 9'd27\n      + F * 9'd28\n      + G * 9'd6\n      + H * 9'd1\n      + I * 9'd20\n      + J * 9'd0\n      + K * 9'd5\n      + L * 9'd13\n      + M * 9'd8\n      + N * 9'd14\n      + O * 9'd22\n      + P * 9'd12\n      + Q * 9'd23\n      + R * 9'd26\n      + S * 9'd1\n      + T * 9'd22\n      + U * 9'd26\n      + V * 9'd15\n      + W * 9'd0\n      + X * 9'd21;\n\n    wire [8:0]  total_volume = \n        A * 9'd27\n      + B * 9'd27\n      + C * 9'd4\n      + D * 9'd4\n      + E * 9'd0\n      + F * 9'd24\n      + G * 9'd4\n      + H * 9'd20\n      + I * 9'd12\n      + J * 9'd15\n      + K * 9'd5\n      + L * 9'd2\n      + M * 9'd9\n      + N * 9'd28\n      + O * 9'd19\n      + P * 9'd18\n      + Q * 9'd30\n      + R * 9'd12\n      + S * 9'd28\n      + T * 9'd13\n      + U * 9'd18\n      + V * 9'd16\n      + W * 9'd26\n      + X * 9'd3;\n\nassign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume));\nendmodule\n",
        "module_name": "var24_multi",
        "module_hash": "a5db94181de8aea9f820b57b355497a1",
        "dataset_index": 5013
      },
      "bitwise_and_ae8b1b46": {
        "rtl_code": "module bitwise_and (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] and_result\n);\n\n    always @(*) begin\n        and_result = a & b;\n    end\n\nendmodule",
        "module_name": "bitwise_and",
        "module_hash": "ae8b1b460514a038a23fe5bbc477dbe6",
        "dataset_index": 2967
      },
      "pulse_generator_ed782541": {
        "rtl_code": "\nmodule pulse_generator(\n  input clk,\n  output reg pulse\n);\n\n  reg [4:0] counter = 0;\n\n  always @(posedge clk) begin\n    if (counter == 5'b10000) begin\n      counter <= 0;\n      pulse <= 1;\n    end else if (counter == 5'b00000) begin\n      pulse <= 0;\n      counter <= counter + 1;\n    end else begin\n      pulse <= 0;\n      counter <= counter + 1;\n    end\n  end\n\nendmodule",
        "module_name": "pulse_generator",
        "module_hash": "ed782541e838ec187e1e477ba4d1a215",
        "dataset_index": 2190
      },
      "branch_handler_205e5880": {
        "rtl_code": "`define E203_PC_SIZE 32\n`define E203_XLEN 32\nmodule branch_handler(\n  input cmt_i_valid,\n  input cmt_i_rv32,\n  input cmt_i_dret,\n  input cmt_i_mret,\n  input cmt_i_fencei,\n  input cmt_i_bjp,\n  input cmt_i_bjp_prdt,\n  input cmt_i_bjp_rslv,\n  input [`E203_PC_SIZE-1:0] cmt_i_pc,\n  input [`E203_XLEN-1:0] cmt_i_imm,\n  input [`E203_PC_SIZE-1:0] csr_epc_r,\n  input [`E203_PC_SIZE-1:0] csr_dpc_r,\n  input nonalu_excpirq_flush_req_raw,\n  input brchmis_flush_ack,\n  input clk,\n  input rst_n,\n  output cmt_i_ready,\n  output brchmis_flush_req,\n  output [`E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n  output [`E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n  output cmt_mret_ena,\n  output cmt_dret_ena,\n  output cmt_fencei_ena\n);\n\n  wire brchmis_flush_ack_pre;\n  wire brchmis_flush_req_pre;\n\n  assign brchmis_flush_req = brchmis_flush_req_pre & (~nonalu_excpirq_flush_req_raw);\n  assign brchmis_flush_ack_pre = brchmis_flush_ack & (~nonalu_excpirq_flush_req_raw);\n\n  wire brchmis_need_flush = (\n    (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) |\n    cmt_i_fencei |\n    cmt_i_mret |\n    cmt_i_dret\n  );\n\n  wire cmt_i_is_branch = (\n    cmt_i_bjp |\n    cmt_i_fencei |\n    cmt_i_mret |\n    cmt_i_dret\n  );\n\n  assign brchmis_flush_req_pre = cmt_i_valid & brchmis_need_flush;\n\n  assign brchmis_flush_add_op1 = cmt_i_dret ? csr_dpc_r : cmt_i_mret ? csr_epc_r : cmt_i_pc;\n  assign brchmis_flush_add_op2 = cmt_i_dret ? `E203_PC_SIZE'b0 : cmt_i_mret ? `E203_PC_SIZE'b0 :\n                                 (cmt_i_fencei | cmt_i_bjp_prdt) ? (cmt_i_rv32 ? `E203_PC_SIZE'd4 : `E203_PC_SIZE'd2)\n                                    : cmt_i_imm[`E203_PC_SIZE-1:0];\n\n  wire brchmis_flush_hsked = brchmis_flush_req & brchmis_flush_ack;\n  assign cmt_mret_ena = cmt_i_mret & brchmis_flush_hsked;\n  assign cmt_dret_ena = cmt_i_dret & brchmis_flush_hsked;\n  assign cmt_fencei_ena = cmt_i_fencei & brchmis_flush_hsked;\n\n  assign cmt_i_ready = (~cmt_i_is_branch) |\n                             (\n                                 (brchmis_need_flush ? brchmis_flush_ack_pre : 1'b1) \n                                     & (~nonalu_excpirq_flush_req_raw) \n                             );\n\nendmodule",
        "module_name": "branch_handler",
        "module_hash": "205e5880f96ef4ab4544178991c8cfbc",
        "dataset_index": 12348
      },
      "top__96b53518": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input select,     // Select input to choose between multiplexers\n    input [3:0] a,    // 4-bit input for the first multiplexer\n    input [3:0] b,    // 4-bit input for the first multiplexer\n    input [3:0] c,    // 4-bit input for the second multiplexer\n    input [3:0] d,    // 4-bit input for the second multiplexer\n    output reg [3:0] out  // 4-bit output from the functional module\n);\n\n// Instantiate the multiplexers\nwire [3:0] mux1_out;\nmux4 mux1 (\n    .a(a),\n    .b(b),\n    .s(select),\n    .y(mux1_out)\n);\n\nwire [3:0] mux2_out;\nmux4 mux2 (\n    .a(c),\n    .b(d),\n    .s(select),\n    .y(mux2_out)\n);\n\n// Calculate the difference between the selected inputs\nwire [3:0] diff_out;\nassign diff_out = (select) ? (d - c) : (c - d);\n\n// Add the outputs of the multiplexers and the difference\nalways @(*) begin\n    if (select)\n        out <= mux1_out + diff_out;\n    else\n        out <= mux2_out + diff_out;\nend\n\nendmodule\nmodule mux4 (\n    input [3:0] a,\n    input [3:0] b,\n    input s,\n    output [3:0] y\n);\n\nassign y = (s) ? b : a;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "96b53518fae9e4d0209a7306b4bb91fd",
        "dataset_index": 18482
      },
      "axis_frame_join #_caec24db": {
        "rtl_code": "\n\n\nmodule axis_frame_join #\n(\n    parameter S_COUNT = 4,\n    parameter DATA_WIDTH = 8,\n    parameter TAG_ENABLE = 1,\n    parameter TAG_WIDTH = 16\n)\n(\n    input  wire                          clk,\n    input  wire                          rst,\n\n    \n    input  wire [S_COUNT*DATA_WIDTH-1:0] s_axis_tdata,\n    input  wire [S_COUNT-1:0]            s_axis_tvalid,\n    output wire [S_COUNT-1:0]            s_axis_tready,\n    input  wire [S_COUNT-1:0]            s_axis_tlast,\n    input  wire [S_COUNT-1:0]            s_axis_tuser,\n\n    \n    output wire [DATA_WIDTH-1:0]         m_axis_tdata,\n    output wire                          m_axis_tvalid,\n    input  wire                          m_axis_tready,\n    output wire                          m_axis_tlast,\n    output wire                          m_axis_tuser,\n\n    \n    input  wire [TAG_WIDTH-1:0]          tag,\n\n    \n    output wire                          busy\n);\n\nparameter CL_S_COUNT = $clog2(S_COUNT);\n\nparameter TAG_WORD_WIDTH = (TAG_WIDTH + DATA_WIDTH - 1) / DATA_WIDTH;\nparameter CL_TAG_WORD_WIDTH = $clog2(TAG_WORD_WIDTH);\n\nlocalparam [1:0]\n    STATE_IDLE = 2'd0,\n    STATE_WRITE_TAG = 2'd1,\n    STATE_TRANSFER = 2'd2;\n\nreg [1:0] state_reg = STATE_IDLE, state_next;\n\nreg [CL_TAG_WORD_WIDTH-1:0] frame_ptr_reg = {CL_TAG_WORD_WIDTH{1'b0}}, frame_ptr_next;\nreg [CL_S_COUNT-1:0] port_sel_reg = {CL_S_COUNT{1'b0}}, port_sel_next;\n\nreg busy_reg = 1'b0, busy_next;\n\nreg output_tuser_reg = 1'b0, output_tuser_next;\n\nreg [S_COUNT-1:0] s_axis_tready_reg = {S_COUNT{1'b0}}, s_axis_tready_next;\n\nreg [DATA_WIDTH-1:0] m_axis_tdata_int;\nreg                  m_axis_tvalid_int;\nreg                  m_axis_tready_int_reg = 1'b0;\nreg                  m_axis_tlast_int;\nreg                  m_axis_tuser_int;\nwire                 m_axis_tready_int_early;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nassign busy = busy_reg;\n\nwire [DATA_WIDTH-1:0] input_tdata  = s_axis_tdata[port_sel_reg*DATA_WIDTH +: DATA_WIDTH];\nwire                  input_tvalid = s_axis_tvalid[port_sel_reg];\nwire                  input_tlast  = s_axis_tlast[port_sel_reg];\nwire                  input_tuser  = s_axis_tuser[port_sel_reg];\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    frame_ptr_next = frame_ptr_reg;\n    port_sel_next = port_sel_reg;\n\n    s_axis_tready_next = {S_COUNT{1'b0}};\n\n    m_axis_tdata_int = 8'd0;\n    m_axis_tvalid_int = 1'b0;\n    m_axis_tlast_int = 1'b0;\n    m_axis_tuser_int = 1'b0;\n\n    output_tuser_next = output_tuser_reg;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            frame_ptr_next = {CL_TAG_WORD_WIDTH{1'b0}};\n            port_sel_next = {CL_S_COUNT{1'b0}};\n            output_tuser_next = 1'b0;\n\n            if (TAG_ENABLE) begin\n                s_axis_tready_next = 1'b0;\n            end else begin\n                s_axis_tready_next = m_axis_tready_int_early;\n            end\n\n            if (s_axis_tvalid) begin\n                if (TAG_ENABLE) begin\n                    if (m_axis_tready_int_reg) begin\n                        frame_ptr_next = 1;\n                        m_axis_tdata_int = tag;\n                        m_axis_tvalid_int = 1'b1;\n                    end\n                    state_next = STATE_WRITE_TAG;\n                end else begin\n                    if (m_axis_tready_int_reg) begin\n                        m_axis_tdata_int = s_axis_tdata;\n                        m_axis_tvalid_int = 1'b1;\n                    end\n                    state_next = STATE_TRANSFER;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_WRITE_TAG: begin\n            if (m_axis_tready_int_reg) begin\n                state_next = STATE_WRITE_TAG;\n                frame_ptr_next = frame_ptr_reg + 1;\n                m_axis_tvalid_int = 1'b1;\n\n                m_axis_tdata_int = tag >> frame_ptr_reg*DATA_WIDTH;\n                if (frame_ptr_reg == TAG_WORD_WIDTH-1) begin\n                    s_axis_tready_next = m_axis_tready_int_early << 0;\n                    state_next = STATE_TRANSFER;\n                end\n            end else begin\n                state_next = STATE_WRITE_TAG;\n            end\n        end\n        STATE_TRANSFER: begin\n            s_axis_tready_next = m_axis_tready_int_early << port_sel_reg;\n\n            if (input_tvalid && m_axis_tready_int_reg) begin\n                state_next = STATE_TRANSFER;\n                m_axis_tdata_int = input_tdata;\n                m_axis_tvalid_int = input_tvalid;\n\n                if (input_tlast) begin\n                    port_sel_next = port_sel_reg + 1;\n                    output_tuser_next = output_tuser_next | input_tuser;\n                    s_axis_tready_next = {S_COUNT{1'b0}};\n\n                    if (S_COUNT == 1 || port_sel_reg == S_COUNT-1) begin\n                        m_axis_tlast_int = 1'b1;\n                        m_axis_tuser_int = output_tuser_next;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        s_axis_tready_next = m_axis_tready_int_early << port_sel_next;\n                    end\n                end\n            end else begin\n                state_next = STATE_TRANSFER;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        frame_ptr_reg <= {CL_TAG_WORD_WIDTH{1'b0}};\n        port_sel_reg <= {CL_S_COUNT{1'b0}};\n        s_axis_tready_reg <= {S_COUNT{1'b0}};\n        output_tuser_reg <= 1'b0;\n        busy_reg <= 1'b0;\n    end else begin\n        state_reg <= state_next;\n\n        frame_ptr_reg <= frame_ptr_next;\n\n        port_sel_reg <= port_sel_next;\n\n        s_axis_tready_reg <= s_axis_tready_next;\n\n        output_tuser_reg <= output_tuser_next;\n\n        busy_reg <= state_next != STATE_IDLE;\n    end\nend\n\nreg [DATA_WIDTH-1:0] m_axis_tdata_reg = {DATA_WIDTH{1'b0}};\nreg                  m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg                  m_axis_tlast_reg = 1'b0;\nreg                  m_axis_tuser_reg = 1'b0;\n\nreg [DATA_WIDTH-1:0] temp_m_axis_tdata_reg = {DATA_WIDTH{1'b0}};\nreg                  temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg                  temp_m_axis_tlast_reg = 1'b0;\nreg                  temp_m_axis_tuser_reg = 1'b0;\n\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata = m_axis_tdata_reg;\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast = m_axis_tlast_reg;\nassign m_axis_tuser = m_axis_tuser_reg;\n\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n\n    if (m_axis_tready_int_reg) begin\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end else begin\n        m_axis_tvalid_reg <= m_axis_tvalid_next;\n        m_axis_tready_int_reg <= m_axis_tready_int_early;\n        temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n    end\n\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\nend\n\nendmodule\n",
        "module_name": "axis_frame_join #",
        "module_hash": "caec24dbe9ebdf2fb66e7e78ae2f7a0c",
        "dataset_index": 23284
      },
      "xor_shift_register_d715f4b9": {
        "rtl_code": "\nmodule xor_shift_register (\n    input a, // Input for AND gate\n    input b, // Input for AND gate\n    input [7:0] d, // Input for shift register\n    input clk, // Clock input for shift register\n    output [7:0] q // 8-bit output after XOR operation\n);\n\n    // 2-input AND gate using only NOR gates\n    wire n1, n2, n3, n4, n5, n6, n7, n8;\n    assign n1 = ~(a | b);\n    assign n2 = ~(n1 | n1);\n    assign n3 = ~(n2 | n2);\n    assign n4 = ~(n3 | n3);\n    assign n5 = ~(n4 | n4);\n    assign n6 = ~(n5 | n5);\n    assign n7 = ~(n6 | n6);\n    assign n8 = ~(n7 | n7);\n    wire and_out = ~(n8 | n8);\n\n    // 8-bit shift register\n    reg [7:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[6:0], 1'b0};\n    end\n\n    // Bitwise XOR operation\n    assign q = shift_reg ^ and_out;\n\nendmodule\n",
        "module_name": "xor_shift_register",
        "module_hash": "d715f4b93fa243a85c59101d626547b8",
        "dataset_index": 14479
      },
      "sky130_fd_sc_lp__o21a_e2be359d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o21a (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1         );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o21a",
        "module_hash": "e2be359d8d2d7496a520dddf428883cc",
        "dataset_index": 3828
      },
      "binary_counter_c7d7eac4": {
        "rtl_code": "module binary_counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk, negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "c7d7eac4f9138985e91a58c1113b01a0",
        "dataset_index": 4085
      },
      "top__2e4b4e07": {
        "rtl_code": "module top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [2:0] counter;\nreg [7:0] dff_data;\n\nalways @(negedge clk) begin\n    counter <= (counter == 3'b111) ? 3'b000 : counter + 3'b001;\n    if (counter == 3'b111) begin\n        dff_data <= 8'b00000000;\n    end else begin\n        dff_data <= {dff_data[6:0], d[7]};\n    end\nend\n\nassign q = dff_data;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "2e4b4e071d44b5c0df8ceafcb49fd254",
        "dataset_index": 13959
      },
      "sky130_fd_sc_lp__o21bai_892c3a8d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o21bai (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire b          ;\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    not  not0  (b          , B1_N           );\n    or   or0   (or0_out    , A2, A1         );\n    nand nand0 (nand0_out_Y, b, or0_out     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o21bai",
        "module_hash": "892c3a8d0b80c22fce30cee12c47b510",
        "dataset_index": 23676
      },
      "fifo_buffer_bc74d999": {
        "rtl_code": "module fifo_buffer (\n  input clk,\n  input rst_n,\n  input fifo_rd,\n  input fifo_wr,\n  input [7:0] fifo_data_in,\n  output fifo_empty,\n  output fifo_full,\n  output reg [7:0] fifo_data_out,\n  output reg [3:0] fifo_count\n);\n\n  parameter FIFO_SIZE = 16;\n  \n  reg [7:0] fifo_buffer [0:FIFO_SIZE-1];\n  reg [3:0] read_ptr = 4'b0;\n  reg [3:0] write_ptr = 4'b0;\n  reg [3:0] next_write_ptr;\n  reg [3:0] next_read_ptr;\n  \n  assign fifo_empty = (fifo_count == 0);\n  assign fifo_full = (fifo_count == FIFO_SIZE);\n  \n  always @(posedge clk) begin\n    if (rst_n == 0) begin\n      fifo_count <= 0;\n      read_ptr <= 0;\n      write_ptr <= 0;\n    end else begin\n      if (fifo_wr && !fifo_full) begin\n        fifo_buffer[write_ptr] <= fifo_data_in;\n        next_write_ptr <= write_ptr + 1;\n        if (next_write_ptr == FIFO_SIZE) begin\n          next_write_ptr <= 0;\n        end\n      end else begin\n        next_write_ptr <= write_ptr;\n      end\n      if (fifo_rd && !fifo_empty) begin\n        fifo_data_out <= fifo_buffer[read_ptr];\n        next_read_ptr <= read_ptr + 1;\n        if (next_read_ptr == FIFO_SIZE) begin\n          next_read_ptr <= 0;\n        end\n      end else begin\n        next_read_ptr <= read_ptr;\n      end\n      if (fifo_wr != fifo_rd) begin\n        fifo_count <= fifo_count + (fifo_wr ? 1 : -1);\n      end\n      write_ptr <= next_write_ptr;\n      read_ptr <= next_read_ptr;\n    end\n  end\n  \nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "bc74d99953c7d3bbfea3ed73f5aeee7b",
        "dataset_index": 3671
      },
      "shift_register_0f6c748b": {
        "rtl_code": "\nmodule shift_register (\n    input clk,\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    output [7:0] q_out\n);\n\nreg [7:0] shift_reg [0:7];\n\nalways @(posedge clk) begin\n    shift_reg[0] <= data_in1;\n    shift_reg[1] <= shift_reg[0];\n    shift_reg[2] <= shift_reg[1];\n    shift_reg[3] <= shift_reg[2];\n    shift_reg[4] <= shift_reg[3];\n    shift_reg[5] <= shift_reg[4];\n    shift_reg[6] <= shift_reg[5];\n    shift_reg[7] <= data_in2;\nend\n\nassign q_out = shift_reg[7]; // Fix: assign q_out instead of <=\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "0f6c748bdeeaed1e0bc69188de349781",
        "dataset_index": 14411
      },
      "Mux12_0de104c5": {
        "rtl_code": "\nmodule Mux12(A, B, C, D, S0, S1, O);\n  input [11:0] A, B, C, D;\n  input S0, S1;\n  output [11:0] O;\n  \n  wire [11:0] AB, CD;\n  wire sel;\n  \n  assign sel = S1 ? S0 : ~S0;\n  \n  generate\n    genvar i;\n    for (i = 0; i < 12; i = i + 1) begin\n      assign AB[i] = S0 ? A[i] : B[i];\n      assign CD[i] = S0 ? C[i] : D[i];\n    end\n  endgenerate\n  \n  assign O = sel ? AB : CD;\n  \nendmodule",
        "module_name": "Mux12",
        "module_hash": "0de104c5e5a24df3008afd1339612570",
        "dataset_index": 19084
      },
      "adder_4bit_268eadea": {
        "rtl_code": "module adder_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  input CIN,\n  input CLK,\n  input RST,\n  output [3:0] SUM,\n  output COUT\n);\n\n  reg [3:0] SUM_reg;\n  reg COUT_reg;\n\n  always @(posedge CLK, negedge RST) begin\n    if (~RST) begin\n      SUM_reg <= 4'b0;\n      COUT_reg <= 1'b0;\n    end else begin\n      SUM_reg <= A + B + CIN;\n      COUT_reg <= (A[3] & B[3]) | (A[3] & CIN) | (B[3] & CIN);\n    end\n  end\n\n  assign SUM = SUM_reg;\n  assign COUT = COUT_reg;\n\nendmodule",
        "module_name": "adder_4bit",
        "module_hash": "268eadea5d342575ee08ff78cb805900",
        "dataset_index": 15519
      },
      "mux_2to1_7685e3cf": {
        "rtl_code": "module mux_2to1(\n    input a,\n    input b,\n    input sel,\n    output reg out_always\n);\n\nalways @(*) begin\n    if(sel == 1'b0) begin\n        out_always = a;\n    end else begin\n        out_always = b;\n    end\nend\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "7685e3cf93f9a52e1eebfbb76d71ed2b",
        "dataset_index": 239
      },
      "mgc_out_reg_pos_6b137820": {
        "rtl_code": "\nmodule mgc_out_reg_pos (clk, en, arst, srst, ld, d, lz, z);\n\n    parameter integer rscid   = 1;\n    parameter integer width   = 8;\n    parameter         ph_en   =  1'b1;\n    parameter         ph_arst =  1'b0;\n    parameter         ph_srst =  1'b0;\n\n    input              clk;\n    input              en;\n    input              arst;\n    input              srst;\n    input              ld;\n    input  [width-1:0] d;\n    output             lz;\n    output [width-1:0] z;\n\n\n    reg  lz_r;\n    reg  [width-1:0] z_r;\n    reg  lz_r_dly;\n    reg [width-1:0] z;\n\n       initial begin\n          lz_r = 1'b0;\n          z_r  = {width{1'b0}};\n          lz_r_dly = 1'b0;\n       end\n\n    always @(posedge clk)\n    begin\n        if (arst == ph_arst)\n        begin\n            lz_r   <= 1'b0;\n            z_r    <= {width{1'b0}};\n            //lz_r_dly <= 1'b0;\n        end\n        else\n        begin\n            lz_r   <= (en == ph_en) ? ld  : lz_r;\n            z_r    <= (en == ph_en) ? d  : z_r;\n            //lz_r_dly <= lz_r; \n        end\n    end\n\n\n    always @(posedge clk )\n    begin\n        if (srst == ph_srst)\n        begin\n            z <= {width{1'b0}};\n        end\n        else\n        begin\n            z <= lz_r_dly ? {width{1'b0}} : z_r;\n        end\n    end\n\n    assign lz = lz_r;\n\nendmodule",
        "module_name": "mgc_out_reg_pos",
        "module_hash": "6b1378207bf4b8566f1f27a8d59d3f11",
        "dataset_index": 3400
      },
      "six_to_one_rtl_b482083e": {
        "rtl_code": "\nmodule six_to_one_rtl (\n    input [4:0] A,\n    input [1:0] B,\n    output [7:0] X\n);\n\n    wire [3:0] sum1, sum2;\n\n    nand (sum1[0], A[0], A[1]);\n    nand (sum1[1], A[0], A[2]);\n    nand (sum1[2], A[1], A[2]);\n    nor (sum1[3], A[0], A[1]);\n\n    nand (sum2[0], B[0], B[1]);\n    nand (sum2[1], B[0], sum1[3]);\n    nor (sum2[2], B[1], sum1[3]);\n\n    nand (X[0], A[3], A[4]);\n    nand (X[1], A[3], sum2[2]);\n    nor (X[2], A[4], sum2[2]);\n\n    nand (X[3], sum1[2], sum2[1]);\n    nand (X[4], sum1[2], sum2[0]);\n    nand (X[5], sum1[1], sum2[1]);\n    nand (X[6], sum1[1], sum2[0]);\n\n    nor (X[7], sum1[0], sum2[1]);\nendmodule",
        "module_name": "six_to_one_rtl",
        "module_hash": "b482083e146084b19d63184f7ab0582a",
        "dataset_index": 12909
      },
      "mux_2to1_887a8c6c": {
        "rtl_code": "module mux_2to1(\n    input A0,\n    input A1,\n    input S,\n    output X\n);\n\nassign X = (S == 1'b0) ? A0 : A1;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "887a8c6c17b70846bf64c94028415b86",
        "dataset_index": 18736
      },
      "binary_adder_8ecb0d08": {
        "rtl_code": "\nmodule binary_adder (\n    input [7:0] input1,\n    input [7:0] input2,\n    input carry_in,\n    output [7:0] sum,\n    output carry_out,\n    output overflow_flag\n);\n\nreg [8:0] stage1_out;\nreg [8:0] stage2_out;\nreg [8:0] stage3_out;\nreg [8:0] stage4_out;\nreg [8:0] stage5_out;\nreg [8:0] stage6_out;\nreg [8:0] stage7_out;\nreg [9:0] stage8_out;\nreg [1:0] overflow_check;\n\nassign sum = stage8_out[7:0];\nassign carry_out = stage8_out[8];\n\nalways @(*) begin\n    stage1_out = input1 + input2 + carry_in;\nend\n\nalways @(*) begin\n    stage2_out = stage1_out + {1'b0, stage1_out[7:1]};\nend\n\nalways @(*) begin\n    stage3_out = stage2_out + {1'b0, stage2_out[6:0], stage2_out[7]};\nend\n\nalways @(*) begin\n    stage4_out = stage3_out + {1'b0, stage3_out[5:0], stage3_out[6]};\nend\n\nalways @(*) begin\n    stage5_out = stage4_out + {1'b0, stage4_out[4:0], stage4_out[5]};\nend\n\nalways @(*) begin\n    stage6_out = stage5_out + {1'b0, stage5_out[3:0], stage5_out[4]};\nend\n\nalways @(*) begin\n    stage7_out = stage6_out + {1'b0, stage6_out[2:0], stage6_out[3]};\nend\n\nalways @(*) begin\n    stage8_out = stage7_out + {1'b0, stage7_out[1:0], stage7_out[2]};\n    overflow_check = stage7_out[8:7] + stage8_out[8:7];\nend\n\nassign overflow_flag = (overflow_check == 2'b10);\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "8ecb0d0879850fa37b2ef869ff7a2996",
        "dataset_index": 7211
      },
      "s5_9f059160": {
        "rtl_code": "\n\nmodule s5(stage1_input,stage1_output);\ninput [5:0] stage1_input;\noutput [3:0] stage1_output;\n\nreg [3:0] stage1_output;\n\n\n\nalways @(  stage1_input)\n\nbegin\n\n   case(stage1_input)\n\n        0: stage1_output = (2); \n        1: stage1_output = (14); \n        2: stage1_output = (12); \n        3: stage1_output = (11); \n        4: stage1_output = (4); \n        5: stage1_output = (2); \n        6: stage1_output = (1); \n        7: stage1_output = (12); \n        8: stage1_output = (7); \n        9: stage1_output = (4); \n        10: stage1_output = (10); \n        11: stage1_output = (7); \n        12: stage1_output = (11); \n        13: stage1_output = (13); \n        14: stage1_output = (6); \n        15: stage1_output = (1); \n        16: stage1_output = (8); \n        17: stage1_output = (5); \n        18: stage1_output = (5); \n        19: stage1_output = (0); \n        20: stage1_output = (3); \n        21: stage1_output = (15); \n        22: stage1_output = (15); \n        23: stage1_output = (10); \n        24: stage1_output = (13); \n        25: stage1_output = (3); \n        26: stage1_output = (0); \n        27: stage1_output = (9); \n        28: stage1_output = (14); \n        29: stage1_output = (8); \n        30: stage1_output = (9); \n        31: stage1_output = (6); \n        32: stage1_output = (4); \n        33: stage1_output = (11); \n        34: stage1_output = (2); \n        35: stage1_output = (8); \n        36: stage1_output = (1); \n        37: stage1_output = (12); \n        38: stage1_output = (11); \n        39: stage1_output = (7); \n        40: stage1_output = (10); \n        41: stage1_output = (1); \n        42: stage1_output = (13); \n        43: stage1_output = (14); \n        44: stage1_output = (7); \n        45: stage1_output = (2); \n        46: stage1_output = (8); \n        47: stage1_output = (13); \n        48: stage1_output = (15); \n        49: stage1_output = (6); \n        50: stage1_output = (9); \n        51: stage1_output = (15); \n        52: stage1_output = (12); \n        53: stage1_output = (0); \n        54: stage1_output = (5); \n        55: stage1_output = (9); \n        56: stage1_output = (6); \n        57: stage1_output = (10); \n        58: stage1_output = (3); \n        59: stage1_output = (4); \n        60: stage1_output = (0); \n        61: stage1_output = (5); \n        62: stage1_output = (14); \n        63: stage1_output = (3); \n\nendcase\n\n\n\t\n\nend\n\nendmodule\n",
        "module_name": "s5",
        "module_hash": "9f0591607323a1e4d59a290bde939516",
        "dataset_index": 108
      },
      "priority_mux_b2c9299c": {
        "rtl_code": "module priority_mux (\n    input A,\n    input B,\n    input C,\n    input S,\n    input P,\n    output Y\n);\n\n    assign Y = (P) ? C : ((S) ? B : A);\n\nendmodule",
        "module_name": "priority_mux",
        "module_hash": "b2c9299c99285c9c7e947a4e36619ed0",
        "dataset_index": 3953
      },
      "comparator_8116503c": {
        "rtl_code": "module comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if (a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end else if (a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "8116503cba15a7a21f4896e927b9d4c6",
        "dataset_index": 18167
      },
      "top__ac5f7455": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input control,\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out_add,\n    output reg [3:0] out_sub,\n    output reg [7:0] s,\n    output overflow\n);\n\n// Sequential shift register module for storing the inputs\nreg [3:0] reg_a, reg_b;\nalways @(posedge clk) begin\n    if (reset) begin\n        reg_a <= 4'b0000;\n        reg_b <= 4'b0000;\n    end else begin\n        reg_a <= a;\n        reg_b <= b;\n    end\nend\n\n// Combinational circuit for addition and subtraction operations\nwire [3:0] add_result, sub_result;\nassign add_result = reg_a + reg_b;\nassign sub_result = reg_a - reg_b;\n\n// Carry look-ahead adder for addition and overflow detection\nwire [4:0] add_carry;\nassign add_carry = {1'b0, add_result} + {1'b0, reg_a} + {1'b0, reg_b};\nassign overflow = add_carry[4];\n\n// FSM for controlling the operation\nreg [1:0] state;\nparameter ADD = 2'b00, SUB = 2'b01;\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= ADD;\n    end else begin\n        case (state)\n            ADD: begin\n                out_add <= add_result;\n                s <= {1'b0, add_result};\n                if (control) begin\n                    state <= SUB;\n                end\n            end\n            SUB: begin\n                out_sub <= sub_result;\n                s <= {1'b0, sub_result};\n                if (!control) begin\n                    state <= ADD;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "ac5f74557d90896ecac13d05145cd9b2",
        "dataset_index": 15885
      },
      "ASHIFTER_32bit_01c4e949": {
        "rtl_code": "module ASHIFTER_32bit(S, D, C);\n\ninput [31:0] D;\ninput C;\noutput [31:0] S;\n\nwire C1;\nwire [61:0]w;\nwire G; \n\n\n\nnot not1(C1,C);\n\nand and0 (w[0], D[0],C);\nand and1 (S[0], D[1],C1);\nand and2 (w[2], D[1],C);\nand and3 (w[3], D[2],C1);\nand and4 (w[4], D[2],C);\nand and5 (w[5], D[3],C1);\nand and6 (w[6], D[3],C);\nand and7 (w[7], D[4],C1);\nand and8 (w[8], D[4],C);\nand and9 (w[9], D[5],C1);\nand and10(w[10], D[5],C);\nand and11(w[11], D[6],C1);\nand and11(w[12], D[6],C);\nand and13(w[13], D[7],C1);\nand and14 (w[14], D[7],C);\nand and15(w[15], D[8],C1);\nand and16(w[16], D[8],C);\nand and17(w[17], D[9],C1);\nand and18(w[18], D[9],C);\nand and19(w[19], D[10],C1);\nand and20(w[20], D[10],C);\nand and21(w[21], D[11],C1);\nand and22(w[22], D[11],C);\nand and23(w[23], D[12],C1);\nand and24(w[24], D[12],C);\nand and25(w[25], D[13],C1);\nand and26(w[26], D[13],C);\nand and27(w[27], D[14],C1);\nand and28(w[28], D[14],C);\nand and29(w[29], D[15],C1);\nand and30(w[30], D[15],C);\nand and31(w[31], D[16],C1);\nand and32(w[32], D[16],C);\nand and33(w[33], D[17],C1);\nand and34(w[34], D[17],C);\nand and35(w[35], D[18],C1);\nand and36(w[36], D[18],C);\nand and37(w[37], D[19],C1);\nand and38(w[38], D[19],C);\nand and39(w[39], D[20],C1);\nand and40(w[40], D[20],C);\nand and41(w[41], D[21],C1);\nand and42(w[42], D[21],C);\nand and43(w[43], D[22],C1);\nand and44(w[44], D[22],C);\nand and45(w[45], D[23],C1);\nand and46(w[46], D[23],C);\nand and47(w[47], D[24],C1);\nand and48(w[48], D[24],C);\nand and49(w[49], D[25],C1);\nand and50(w[50], D[25],C);\nand and51(w[51], D[26],C1);\nand and52(w[52], D[26],C);\nand and53(w[53], D[27],C1);\nand and54(w[54], D[27],C);\nand and55(w[55], D[28],C1);\nand and56(w[56], D[28],C);\nand and57(w[57], D[29],C1);\nand and58(w[58], D[29],C);\nand and59(w[59], D[30],C1);\nand and60(S[31], D[31],C);\nand and61(w[61], D[31],C1);\n\n\n\n\n\nor or1 (S[1], w[0], w[3]);\nor or2 (S[2], w[2], w[5]);\nor or3 (S[3], w[4], w[7]);\nor or4 (S[4], w[6], w[9]);\nor or5 (S[5], w[8], w[11]);\nor or6 (S[6], w[10], w[13]);\nor or7(S[7], w[12], w[15]);\nor or8 (S[8], w[14], w[17]);\nor or9 (S[9], w[16], w[19]);\nor or10 (S[10], w[18], w[21]);\nor or11 (S[11], w[20], w[23]);\nor or12 (S[12], w[22], w[25]);\nor or13(S[13], w[24], w[27]);\nor or14(S[14], w[26], w[29]);\nor or15(S[15], w[28], w[31]);\nor or16(S[16], w[30], w[33]);\nor or17(S[17], w[32], w[35]);\nor or18(S[18], w[34], w[37]);\nor or19(S[19], w[36], w[39]);\nor or20(S[20], w[38], w[41]);\nor or21(S[21], w[40], w[43]);\nor or22(S[22], w[42], w[45]);\nor or23(S[23], w[44], w[47]);\nor or24(S[24], w[46], w[49]);\nor or25(S[25], w[48], w[51]);\nor or26(S[26], w[50], w[53]);\nor or27(S[27], w[52], w[55]);\nor or28(S[28], w[54], w[57]);\nor or29(S[29], w[56], w[59]);\nor or30(S[30], w[58], w[61]);\n\n\n\n\n\nendmodule\n",
        "module_name": "ASHIFTER_32bit",
        "module_hash": "01c4e949654224fb636f03cd4a3679b2",
        "dataset_index": 22976
      },
      "pdp1_opr_decoder_1921365d": {
        "rtl_code": "module pdp1_opr_decoder(op_i, op_mask, op_ac, op_io, \n\t\t\top_pf, op_tw, op_r_ac, op_r_io, op_r_pf);\n   parameter pdp_model = \"PDP-1\";\n   \n   input op_i;\n   input [0:11] op_mask;\n   input [0:17] op_ac;\n   input [0:17] op_io;\n   input [0:5] \top_pf;\n   input [0:17] op_tw;\n   output [0:17] op_r_ac;\n   output [0:17] op_r_io;\n   output [0:5]  op_r_pf;\n   \n   wire [0:18] \t w_ac_immed1;\n   wire [0:18] \t w_ac_immed2;\n   wire [0:18] \t w_ac_immed3;\n   wire [0:18] \t w_ac_immed4;\n\n   wire [0:18] \t w_io_immed1;\n\n   reg [0:5] \t r_pf_mask;\n     \n   assign w_ac_immed4 = (op_mask[4]) ? 18'b0 : op_ac;\n   assign w_ac_immed3 = (op_mask[1]) ? (w_ac_immed4 | op_tw) : w_ac_immed4;\n   assign w_ac_immed2 = (op_mask[5]) ? (w_ac_immed3 | op_pf) : w_ac_immed3;\n   assign w_ac_immed1 = (op_mask[2]) ? ~w_ac_immed2 : w_ac_immed2;\n      \n   assign w_io_immed1 = (op_mask[0]) ? 18'b0 : op_io;\n\n   generate\n      if(pdp_model == \"PDP-1D\") begin\n\t assign w_io_immed1 = (op_i) ? ~w_io_immed2 : w_io_immed2;\n\n\t assign op_r_ac = (op_mask[6]) ? w_io_immed1 : w_ac_immed1;\n\t assign op_r_io = (op_mask[7]) ? w_ac_immed1 : w_io_immed1;\n      end\n      else begin\n\t assign op_r_io = w_io_immed1;\n\t assign op_r_ac = w_ac_immed1;\n      end\n   endgenerate\n\n   assign op_r_pf = (|op_mask[8:11]) ?\n\t\t    ((op_mask[8]) ? op_pf | r_pf_mask : \n\t\t     op_pf & ~r_pf_mask) :\n\t\t    op_pf;\n   \n   always @(op_mask or op_pf) begin\n      case(op_mask[9:11])\n\t3'b000:\n\t  r_pf_mask = 6'b000000;\n\t3'b001:\n\t  r_pf_mask = 6'b000001;\n\t3'b010:\n\t  r_pf_mask = 6'b000010;\n\t3'b011:\n\t  r_pf_mask = 6'b000100;\n\t3'b100:\n\t  r_pf_mask = 6'b001000;\n\t3'b101:\n\t  r_pf_mask = 6'b010000;\n\t3'b110:\n\t  r_pf_mask = 6'b100000;\n\t3'b111:\n\t  r_pf_mask = 6'b111111;\n      endcase end\n   \nendmodule ",
        "module_name": "pdp1_opr_decoder",
        "module_hash": "1921365d40e1235eddf0052b346b441b",
        "dataset_index": 13091
      },
      "top__6de44498": {
        "rtl_code": "\nmodule top_module (\n    input wire [31:0] in,\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output [3:0] q,\n    output wire [7:0] sum_out\n);\n\n    wire [7:0] byte1, byte4;\n    wire [3:0] count_out;\n    wire [7:0] load_value;\n\n    // Extract the 1st and 4th bytes from the input word\n    assign byte1 = in[7:0];\n    assign byte4 = in[31:24];\n\n    // Swap the two bytes\n    assign load_value = {byte4, in[23:8], in[15:8], byte1};\n\n    // Instantiate the 4-bit binary counter\n    counter_4bit counter(\n        .clk(clk),\n        .reset(reset),\n        .load(load_value),\n        .q(q)\n    );\n\n    // Instantiate the additional functional module to calculate the sum\n    sum_module sum(\n        .a(count_out),\n        .b(load_value),\n        .sum_out(sum_out)\n    );\n\n    // Assign the output of the counter to the input of the sum module\n    assign count_out = q;\n\nendmodule\n\nmodule counter_4bit (\n    input clk,\n    input reset,\n    input [7:0] load,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (load != q) begin\n            q <= load[3:0];\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\n\nmodule sum_module (\n    input [3:0] a,\n    input [7:0] b,\n    output wire [7:0] sum_out\n);\n\n    assign sum_out = a + b;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "6de44498b3111e61a9f8029c115cfc15",
        "dataset_index": 5322
      },
      "signed_mult #_c4e9b69d": {
        "rtl_code": "module signed_mult #(\n\tparameter A_WIDTH = 0,\n\tparameter B_WIDTH = 0,\n\tparameter P_WIDTH = 0\n)(\n\tinput signed [A_WIDTH-1:0] A,\n\tinput signed [B_WIDTH-1:0] B,\n\toutput reg signed [P_WIDTH-1:0] P\n);\n\n\talways @(*)\n\tbegin\n\t\tP <= A * B;\n\tend\n\nendmodule",
        "module_name": "signed_mult #",
        "module_hash": "c4e9b69d65976b6741b16caa72c090cf",
        "dataset_index": 15126
      },
      "binary_counter_4bit_b73d0c7f": {
        "rtl_code": "module binary_counter_4bit (\n    input CLK,\n    input RST,\n    input EN,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 4'b0000;\n        end\n        else if (EN) begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter_4bit",
        "module_hash": "b73d0c7fbf6a0485fcbecbdf7ad2bf6a",
        "dataset_index": 18971
      },
      "OledEX_76fbcbf1": {
        "rtl_code": "\nmodule OledEX (\n        CLK,\n        RST,\n        EN,\n        CS,\n        SDO,\n        SCLK,\n        DC,\n        FIN,\n        // Position on the screen\n        xpos,\n        ypos\n    );\n\n    // ===========================================================================\n    //                                      Port Declarations\n    // ===========================================================================\n    input CLK;\n    input RST;\n    input EN;\n    output reg CS = 1'b1; // Added initial value to CS\n    output reg SDO;\n    output reg SCLK = 1'b0; // Added initial value to SCLK\n    output reg FIN = 1'b0; // Added initial value to FIN\n    input [9:0] xpos;\n    input [9:0] ypos;\n\n    // ===========================================================================\n    //                              Parameters, Registers, and Wires\n    // ===========================================================================\n\n    parameter ExampleReset = 4'b0000, ExampleSendData = 4'b0001, ExampleIdle = 4'b1111;\n    reg [3:0] current_state = ExampleReset;\n\n    // ===========================================================================\n    //                                      Implementation\n    // ===========================================================================\n\n    // Assign outputs that do not change\n    output reg DC = 1'b1;\n\n    // State Machine\n    // This state machine sends data to the OLED display based on the x and y positions\n    always @(posedge CLK) begin\n            if(RST == 1'b1) begin\n                    current_state <= ExampleReset;\n            end\n            else if(EN == 1'b1) begin\n                    case(current_state)\n                            ExampleReset : begin\n                                    SDO <= 1'b0;\n                                    current_state <= ExampleSendData;\n                            end\n                            ExampleSendData : begin\n                                    SDO <= 1'b1;\n                                    // Send data to the OLED display based on the x and y positions\n                                    current_state <= ExampleIdle;\n                            end\n                            ExampleIdle : begin\n                                    FIN <= 1'b1;\n                            end\n                    endcase\n            end\n    end\n\nendmodule",
        "module_name": "OledEX",
        "module_hash": "76fbcbf1c69af5e46a65f345ccf4d7a0",
        "dataset_index": 13934
      },
      "lpddr2_cntrlr_p0_reset_sync_50efed1a": {
        "rtl_code": "\n\nmodule lpddr2_cntrlr_p0_reset_sync(\n\treset_n,\n\tclk,\n\treset_n_sync\n);\n\nparameter RESET_SYNC_STAGES = 4;\nparameter NUM_RESET_OUTPUT = 1;\n\ninput\treset_n;\ninput\tclk;\noutput\t[NUM_RESET_OUTPUT-1:0] reset_n_sync;\n\n\n\n\n reg\t[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:0] reset_reg ;\n\ngenerate\ngenvar i;\n\tfor (i=0; i<RESET_SYNC_STAGES+NUM_RESET_OUTPUT-1; i=i+1)\n\tbegin: reset_stage\n\t\talways @(posedge clk or negedge reset_n)\n\t\tbegin\n\t\t\tif (~reset_n)\n\t\t\t\treset_reg[i] <= 1'b0;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif (i==0)\n\t\t\t\t\treset_reg[i] <= 1'b1;\n\t\t\t\telse if (i < RESET_SYNC_STAGES)\n\t\t\t\t\treset_reg[i] <= reset_reg[i-1];\n\t\t\t\telse\n\t\t\t\t\treset_reg[i] <= reset_reg[RESET_SYNC_STAGES-2];\n\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendgenerate\n\n\tassign reset_n_sync = reset_reg[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:RESET_SYNC_STAGES-1];\n\nendmodule\n",
        "module_name": "lpddr2_cntrlr_p0_reset_sync",
        "module_hash": "50efed1acaa8f2a62142a90ddc2bd4b6",
        "dataset_index": 21857
      },
      "barrel_shifter_e6ad974a": {
        "rtl_code": "module barrel_shifter (\n    input wire [15:0] in,\n    output wire [7:0] out\n);\n\nassign out = in[7:0];\n\nendmodule\n\nmodule mux_2to1 (\n    input wire [7:0] in0,\n    input wire [7:0] in1,\n    input wire ctrl,\n    output wire [7:0] out\n);\n\nassign out = ctrl ? in1 : in0;\n\nendmodule\n\nmodule bitwise_or (\n    input wire [7:0] in0,\n    input wire [7:0] in1,\n    output wire [7:0] out\n);\n\nassign out = in0 | in1;\n\nendmodule\n\nmodule top_module (\n    input wire [15:0] in,\n    input ctrl,\n    output wire [7:0] out,\n    output wire [7:0] out_or\n);\n\nwire [7:0] upper_out;\nwire [7:0] lower_out;\n\nbarrel_shifter bs(in, lower_out);\nbarrel_shifter bs_upper(in >> 8, upper_out);\n\nmux_2to1 mux(lower_out, upper_out, ctrl, out);\nbitwise_or or_gate(lower_out, upper_out, out_or);\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "e6ad974a7e69d72c278434993f32ed94",
        "dataset_index": 8051
      },
      "calculator_584d90ed": {
        "rtl_code": "module calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output reg signed [7:0] out,\n    output reg overflow\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        out <= 0;\n        overflow <= 0;\n    end else begin\n        case(op)\n            2'b00: begin // addition\n                out <= a + b;\n                overflow <= ((a > 0) && (b > 0) && (out < 0)) || ((a < 0) && (b < 0) && (out > 0));\n            end\n            2'b01: begin // subtraction\n                out <= a - b;\n                overflow <= ((a > 0) && (b < 0) && (out < 0)) || ((a < 0) && (b > 0) && (out > 0));\n            end\n            2'b10: begin // multiplication\n                out <= a * b;\n                overflow <= ((out[7] == 1) && (out != -128)) || (out == -128);\n            end\n            2'b11: begin // division\n                if (b == 0) begin\n                    out <= 0;\n                    overflow <= 1;\n                end else begin\n                    out <= a / b;\n                    overflow <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "584d90edfa40582abec60d63684b5b60",
        "dataset_index": 9524
      },
      "xor_multiplexer_4bit_81150ed3": {
        "rtl_code": "module xor_multiplexer_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input sel,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        out[0] = a[0] ^ (sel & b[0]);\n        out[1] = a[1] ^ (sel & b[1]);\n        out[2] = a[2] ^ (sel & b[2]);\n        out[3] = a[3] ^ (sel & b[3]);\n    end\n\nendmodule",
        "module_name": "xor_multiplexer_4bit",
        "module_hash": "81150ed3195a8544890ed7528b048d4c",
        "dataset_index": 20589
      },
      "comparator_16a7f497": {
        "rtl_code": "module comparator(input [3:0] A, B, C, D, output EQ, GT);\n\n  wire a_greater_b, c_greater_d;\n  \n  assign a_greater_b = (A > B);\n  assign c_greater_d = (C > D);\n  \n  assign EQ = (A == B) && (B == C) && (C == D);\n  \n  assign GT = (a_greater_b || ((A == B) && c_greater_d));\n  \nendmodule",
        "module_name": "comparator",
        "module_hash": "16a7f497ebd5af4acfa3f242b71fb7fa",
        "dataset_index": 1952
      },
      "DSPCalcModule_ed4af74a": {
        "rtl_code": "\nmodule DSPCalcModule(\n\t\t\tinput signed [20:0] charge_in,\n\t\t\tinput signed [16:0] signal_in,\n\t\t\tinput delay_en,\n\t\t\tinput clk,\n\t\t\tinput store_strb,\n\t\t\tinput fb_en,\n\t\t\toutput reg signed [14:0] pout,\n\t\t\tinput bunch_strb,\n\t\t\toutput reg DSPoflow,\noutput reg fb_cond,\n\t\t\toutput reg dac_clk\n\t\t\t\n);\n\n reg [7:0] j;\n\nreg signed [37:0]  DSPtemp;\nreg signed [14:0] delayed; \nreg signed [37:0] DSPout;\nreg signed [20:0] chargeA = 21'd0;\n\nalways @ (posedge clk) begin\nchargeA <= charge_in;\nDSPtemp <= chargeA*signal_in;\nDSPout <= DSPtemp+{delayed, 12'b0}; pout<=DSPout[26:12];\nDSPoflow<=(~&DSPout[37:26] && ~&(~DSPout[37:26]));\nend\n\nalways @ (posedge clk) begin\nif (~store_strb) begin\nj<=8;       \n end\nelse if (bunch_strb) begin j<=0;\nend\nelse if (~bunch_strb) begin\nj<=j+1;\nend\nend\n\nreg [14:0] delayed_a;\nalways @ (posedge clk) begin\ndelayed<=delayed_a; if (~store_strb) begin\ndelayed_a<=0;\nend\nelse if (delay_en==1) begin\nif (j==6) delayed_a<=pout;\nend\nend\n\nalways @ (posedge clk) begin\nif (fb_en) begin\nif (j==2||j==3) fb_cond<=1;\nelse fb_cond<=0;\nend\nelse fb_cond<=0;\nend\n\n\n reg delay_store_strb;\nreg clr_dac;\nreg delay_clr_dac;\n\n\nalways @ (posedge clk) begin\nif (fb_en) begin\nif (j==6||j==7||clr_dac==1||delay_clr_dac==1) dac_clk<=1;\nelse dac_clk<=0;\nend\nelse dac_clk<=0;\nend\n\n\n\nalways @(posedge clk) begin\ndelay_store_strb<=store_strb;\ndelay_clr_dac<=clr_dac;\nif ((delay_store_strb==1)&(store_strb==0)) clr_dac<=1;\nelse clr_dac<=0;\nend\n\nendmodule\n\n\n",
        "module_name": "DSPCalcModule",
        "module_hash": "ed4af74a6097d109275829102e18fd3c",
        "dataset_index": 12889
      },
      "counter_04375a9b": {
        "rtl_code": "module counter (\n    input  wire        CLK,\n    input  wire        RST,\n    input  wire        EN,\n    output wire [3:0]  Q\n);\n\n    reg [3:0] count;\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            count <= 4'b0;\n        end\n        else if (EN) begin\n            count <= count + 1;\n        end\n    end\n\n    assign Q = count;\n\nendmodule",
        "module_name": "counter",
        "module_hash": "04375a9bc8072c764dfd6c4d52485f16",
        "dataset_index": 14866
      },
      "dff_8_5033166f": {
        "rtl_code": "\nmodule dff_8 (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @ (posedge clk or negedge reset) begin\n    if (reset == 1'b0) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\nmodule top_module (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [7:0] d,\n    output [7:0] q\n);\n\ndff_8 dff_0 (.clk(clk), .reset(reset), .d(d), .q(q));\n\nendmodule",
        "module_name": "dff_8",
        "module_hash": "5033166f933a736787f1a8f4467212e1",
        "dataset_index": 3767
      },
      "bitwise_or_e64f6c21": {
        "rtl_code": "module bitwise_or (\n    input [3:0] a,\n    input [3:0] b,\n    input clk,\n    output reg [3:0] out\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @ (posedge clk) begin\n    stage1_out <= a | b;\n    stage2_out <= stage1_out;\nend\n\nalways @* begin\n    out = stage2_out;\nend\n\nendmodule",
        "module_name": "bitwise_or",
        "module_hash": "e64f6c218fe6c43a8c2b0a98acabaa9e",
        "dataset_index": 9218
      },
      "top__7ace4485": {
        "rtl_code": "\nmodule top_module (\n    input [2:0] ABC,\n    input EN,\n    output reg [7:0] Y\n);\n\n    wire [3:0] binary_sum;\n    wire [2:0] decoder_input;\n    wire [7:0] decoder_output;\n\n    binary_adder adder(.X(ABC), .Y(4'b0001), .S(binary_sum));\n    assign decoder_input = binary_sum[2:0];\n    decoder decoder(.ABC(decoder_input), .EN(EN), .Y(decoder_output));\n\n    always @(*) begin\n        case(decoder_output)\n            3'b000: Y = 8'b11000000;\n            3'b001: Y = 8'b11111001;\n            3'b010: Y = 8'b10100100;\n            3'b011: Y = 8'b10110000;\n            3'b100: Y = 8'b10011001;\n            3'b101: Y = 8'b10010010;\n            3'b110: Y = 8'b10000010;\n            3'b111: Y = 8'b11111000;\n            default: Y = 8'b00000000;\n        endcase\n    end\n\nendmodule\nmodule binary_adder (\n    input [2:0] X,\n    input [3:0] Y,\n    output reg [3:0] S\n);\n    always @(*) begin\n        S = X + Y;\n    end\nendmodule\nmodule decoder (\n    input [2:0] ABC,\n    input EN,\n    output reg [7:0] Y\n);\n    always @(*) begin\n        case({ABC, EN})\n            4'b0001: Y = 8'b11000000;\n            4'b0010: Y = 8'b11111001;\n            4'b0011: Y = 8'b10100100;\n            4'b0100: Y = 8'b10110000;\n            4'b0101: Y = 8'b10011001;\n            4'b0110: Y = 8'b10010010;\n            4'b0111: Y = 8'b10000010;\n            4'b1000: Y = 8'b11111000;\n            default: Y = 8'b00000000;\n        endcase\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "7ace4485944af3fb610853efa16085f8",
        "dataset_index": 7988
      },
      "barrel_shifter_5145974d": {
        "rtl_code": "module barrel_shifter (\n    input [3:0] A,\n    input [1:0] B,\n    output [3:0] Q,\n    output COUT\n);\n\nwire [3:0] shifted_value;\nassign shifted_value = (B[1]) ? {A[3], A[3:1]} : (B[0]) ? {A[2:0], A[3]} : A;\n\nassign Q = shifted_value;\nassign COUT = shifted_value[0] & (B[1] | B[0]);\n\nendmodule\n\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input up_down,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0;\n    end else if (up_down) begin\n        count <= count + 1;\n    end else begin\n        count <= count - 1;\n    end\nend\n\nendmodule\n\nmodule functional_module (\n    input [3:0] barrel_shifted_value,\n    input [3:0] counter_value,\n    output [7:0] sum\n);\n\nassign sum = {barrel_shifted_value, counter_value};\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input up_down,\n    input [3:0] A,\n    input [1:0] B,\n    output [3:0] Q,\n    output COUT,\n    output [3:0] count,\n    output [7:0] sum\n);\n\nbarrel_shifter bs (\n    .A(A),\n    .B(B),\n    .Q(Q),\n    .COUT(COUT)\n);\n\nup_down_counter udc (\n    .clk(clk),\n    .reset(reset),\n    .up_down(up_down),\n    .count(count)\n);\n\nfunctional_module fm (\n    .barrel_shifted_value(Q),\n    .counter_value(count),\n    .sum(sum)\n);\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "5145974df0b7bedcc6864a4ec5b00acc",
        "dataset_index": 5557
      },
      "next_higher_binary_e7493ad2": {
        "rtl_code": "module next_higher_binary (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (in)\n            4'b0000: out = 4'b0001;\n            4'b0001: out = 4'b0010;\n            4'b0010: out = 4'b0011;\n            4'b0011: out = 4'b0100;\n            4'b0100: out = 4'b0101;\n            4'b0101: out = 4'b0110;\n            4'b0110: out = 4'b0111;\n            4'b0111: out = 4'b1000;\n            4'b1000: out = 4'b1001;\n            4'b1001: out = 4'b1010;\n            4'b1010: out = 4'b1011;\n            4'b1011: out = 4'b1100;\n            4'b1100: out = 4'b1101;\n            4'b1101: out = 4'b1110;\n            4'b1110: out = 4'b1111;\n            4'b1111: out = 4'b0000;\n        endcase\n    end\n\nendmodule",
        "module_name": "next_higher_binary",
        "module_hash": "e7493ad26686f748de1194167b53fd0f",
        "dataset_index": 18194
      },
      "priority_mux_addsub_10f6b6f0": {
        "rtl_code": "module priority_mux_addsub (\n    input [3:0] A, B, C, D, // Four 4-bit inputs\n    input [1:0] S, // Select input to choose between the inputs\n    input SUB, // 1-bit input for subtraction\n    output reg [3:0] out // 4-bit output from the final module\n);\n\n    // Priority encoder-based multiplexer\n    wire [1:0] sel;\n    priority_encoder pe(.in(S), .out(sel));\n    wire [3:0] mux_out;\n    mux_4to1 mux(.in0(A), .in1(B), .in2(C), .in3(D), .sel(sel), .out(mux_out));\n\n    // 4-bit adder-subtractor\n    wire [3:0] addsub_out;\n    addsub_4bit addsub(.A(A), .B(mux_out), .SUB(SUB), .out(addsub_out));\n\n    // Final module to get the output\n    always @* begin\n        out = addsub_out;\n    end\n\nendmodule\n\nmodule priority_encoder (\n    input [1:0] in,\n    output reg [1:0] out\n);\n\n    always @* begin\n        if (in == 2'b00) begin\n            out = 2'b00;\n        end else if (in == 2'b01) begin\n            out = 2'b01;\n        end else if (in == 2'b10) begin\n            out = 2'b10;\n        end else begin\n            out = 2'b11;\n        end\n    end\n\nendmodule\n\nmodule mux_4to1 (\n    input [3:0] in0, in1, in2, in3,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\n    always @* begin\n        case(sel)\n            2'b00: out = in0;\n            2'b01: out = in1;\n            2'b10: out = in2;\n            2'b11: out = in3;\n        endcase\n    end\n\nendmodule\n\nmodule addsub_4bit (\n    input [3:0] A, B,\n    input SUB,\n    output reg [3:0] out\n);\n\n    always @* begin\n        if (SUB) begin\n            out = A - B;\n        end else begin\n            out = A + B;\n        end\n    end\n\nendmodule",
        "module_name": "priority_mux_addsub",
        "module_hash": "10f6b6f0736b6c209e32b209cc607f34",
        "dataset_index": 2295
      },
      "Altera_UP_I2C_AV_Auto_Initialize_376d7c0d": {
        "rtl_code": "\n\n\n\nmodule Altera_UP_I2C_AV_Auto_Initialize (\n\tclk,\n\treset,\n\n\tclear_error,\n\n\tack,\n\ttransfer_complete,\n\n\tdata_out,\n\ttransfer_data,\n\tsend_start_bit,\n\tsend_stop_bit,\n\t\n\tauto_init_complete,\n\tauto_init_error\n);\n\n\n\nparameter MIN_ROM_ADDRESS\t= 6'h00;\nparameter MAX_ROM_ADDRESS\t= 6'h32;\n\nparameter AUD_LINE_IN_LC\t= 9'h01A;\nparameter AUD_LINE_IN_RC\t= 9'h01A;\nparameter AUD_LINE_OUT_LC\t= 9'h07B;\nparameter AUD_LINE_OUT_RC\t= 9'h07B;\nparameter AUD_ADC_PATH\t\t= 9'h0F8;\nparameter AUD_DAC_PATH\t\t= 9'h006;\nparameter AUD_POWER\t\t\t= 9'h000;\nparameter AUD_DATA_FORMAT\t= 9'h001;\nparameter AUD_SAMPLE_CTRL\t= 9'h002;\nparameter AUD_SET_ACTIVE\t= 9'h001;\n\n\ninput\t\t\t\tclk;\ninput\t\t\t\treset;\n\ninput\t\t\t\tclear_error;\n\ninput\t\t\t\tack;\ninput\t\t\t\ttransfer_complete;\n\noutput\treg\t[7:0]\tdata_out;\noutput\treg\t\t\ttransfer_data;\noutput\treg\t\t\tsend_start_bit;\noutput\treg\t\t\tsend_stop_bit;\n\n\noutput\t\t\t\tauto_init_complete;\noutput\treg\t\t\tauto_init_error;\n\n\nlocalparam\tAUTO_STATE_0_CHECK_STATUS\t\t= 3'h0,\n\t\t\tAUTO_STATE_1_SEND_START_BIT\t\t= 3'h1,\n\t\t\tAUTO_STATE_2_TRANSFER_BYTE_1\t= 3'h2,\n\t\t\tAUTO_STATE_3_TRANSFER_BYTE_2\t= 3'h3,\n\t\t\tAUTO_STATE_4_WAIT\t\t\t\t= 3'h4,\n\t\t\tAUTO_STATE_5_SEND_STOP_BIT\t\t= 3'h5,\n\t\t\tAUTO_STATE_6_INCREASE_COUNTER\t= 3'h6,\n\t\t\tAUTO_STATE_7_DONE\t\t\t\t= 3'h7;\n\n\nwire\t\t\t\tchange_state;\n\nwire\t\t\t\tfinished_auto_init;\n\nreg\t\t\t[5:0]\trom_address_counter;\nreg\t\t\t[25:0]\trom_data;\n\nreg\t\t\t[2:0]\tns_i2c_auto_init;\nreg\t\t\t[2:0]\ts_i2c_auto_init;\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\ts_i2c_auto_init <= AUTO_STATE_0_CHECK_STATUS;\n\telse\n\t\ts_i2c_auto_init <= ns_i2c_auto_init;\nend\n\nalways @(*)\nbegin\n\tns_i2c_auto_init = AUTO_STATE_0_CHECK_STATUS;\n\n    case (s_i2c_auto_init)\n\tAUTO_STATE_0_CHECK_STATUS:\n\t\tbegin\n\t\t\tif (finished_auto_init == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_7_DONE;\n\t\t\telse if (rom_data[25] == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_1_SEND_START_BIT;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_3_TRANSFER_BYTE_2;\n\t\tend\n\tAUTO_STATE_1_SEND_START_BIT:\n\t\tbegin\n\t\t\tif (change_state == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_2_TRANSFER_BYTE_1;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_1_SEND_START_BIT;\n\t\tend\n\tAUTO_STATE_2_TRANSFER_BYTE_1:\n\t\tbegin\n\t\t\tif (change_state == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_3_TRANSFER_BYTE_2;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_2_TRANSFER_BYTE_1;\n\t\tend\n\tAUTO_STATE_3_TRANSFER_BYTE_2:\n\t\tbegin\n\t\t\tif ((change_state == 1'b1) && (rom_data[24] == 1'b1))\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_4_WAIT;\n\t\t\telse if (change_state == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_6_INCREASE_COUNTER;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_3_TRANSFER_BYTE_2;\n\t\tend\n\tAUTO_STATE_4_WAIT:\n\t\tbegin\n\t\t\tif (transfer_complete == 1'b0)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_5_SEND_STOP_BIT;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_4_WAIT;\n\t\tend\n\tAUTO_STATE_5_SEND_STOP_BIT:\n\t\tbegin\n\t\t\tif (transfer_complete == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_6_INCREASE_COUNTER;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_5_SEND_STOP_BIT;\n\t\tend\n\tAUTO_STATE_6_INCREASE_COUNTER:\n\t\tbegin\n\t\t\tns_i2c_auto_init = AUTO_STATE_0_CHECK_STATUS;\n\t\tend\n\tAUTO_STATE_7_DONE:\n\t\tbegin\n\t\t\tns_i2c_auto_init = AUTO_STATE_7_DONE;\n\t\tend\n\tdefault:\n\t\tbegin\n\t\t\tns_i2c_auto_init = AUTO_STATE_0_CHECK_STATUS;\n\t\tend\n\tendcase\nend\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tdata_out <= 8'h00;\n\telse if (s_i2c_auto_init == AUTO_STATE_1_SEND_START_BIT)\n\t\tdata_out <= rom_data[23:16];\n\telse if (s_i2c_auto_init == AUTO_STATE_0_CHECK_STATUS)\n\t\tdata_out <= rom_data[15: 8];\n\telse if (s_i2c_auto_init == AUTO_STATE_2_TRANSFER_BYTE_1)\n\t\tdata_out <= rom_data[15: 8];\n\telse if (s_i2c_auto_init == AUTO_STATE_3_TRANSFER_BYTE_2)\n\t\tdata_out <= rom_data[ 7: 0];\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1) \n\t\ttransfer_data <= 1'b0;\n\telse if (transfer_complete == 1'b1)\n\t\ttransfer_data <= 1'b0;\n\telse if (s_i2c_auto_init == AUTO_STATE_1_SEND_START_BIT)\n\t\ttransfer_data <= 1'b1;\n\telse if (s_i2c_auto_init == AUTO_STATE_2_TRANSFER_BYTE_1)\n\t\ttransfer_data <= 1'b1;\n\telse if (s_i2c_auto_init == AUTO_STATE_3_TRANSFER_BYTE_2)\n\t\ttransfer_data <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tsend_start_bit <= 1'b0;\n\telse if (transfer_complete == 1'b1)\n\t\tsend_start_bit <= 1'b0;\n\telse if (s_i2c_auto_init == AUTO_STATE_1_SEND_START_BIT)\n\t\tsend_start_bit <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tsend_stop_bit <= 1'b0;\n\telse if (transfer_complete == 1'b1)\n\t\tsend_stop_bit <= 1'b0;\n\telse if (s_i2c_auto_init == AUTO_STATE_5_SEND_STOP_BIT)\n\t\tsend_stop_bit <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tauto_init_error <= 1'b0;\n\telse if (clear_error == 1'b1)\n\t\tauto_init_error <= 1'b0;\n\telse if ((s_i2c_auto_init == AUTO_STATE_6_INCREASE_COUNTER) & ack)\n\t\tauto_init_error <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\trom_address_counter <= MIN_ROM_ADDRESS;\n\telse if (s_i2c_auto_init == AUTO_STATE_6_INCREASE_COUNTER)\n\t\trom_address_counter <= rom_address_counter + 6'h01;\nend\n\n\nassign auto_init_complete = (s_i2c_auto_init == AUTO_STATE_7_DONE);\n\nassign change_state\t= transfer_complete & transfer_data;\n\nassign finished_auto_init = (rom_address_counter == MAX_ROM_ADDRESS);\n\nalways @(*)\nbegin\n\tcase (rom_address_counter)\n\t0\t\t:\trom_data\t<=\t{10'h334, 7'h0, AUD_LINE_IN_LC};\n\t1\t\t:\trom_data\t<=\t{10'h334, 7'h1, AUD_LINE_IN_RC};\n\t2\t\t:\trom_data\t<=\t{10'h334, 7'h2, AUD_LINE_OUT_LC};\n\t3\t\t:\trom_data\t<=\t{10'h334, 7'h3, AUD_LINE_OUT_RC};\n\t4\t\t:\trom_data\t<=\t{10'h334, 7'h4, AUD_ADC_PATH};\n\t5\t\t:\trom_data\t<=\t{10'h334, 7'h5, AUD_DAC_PATH};\n\t6\t\t:\trom_data\t<=\t{10'h334, 7'h6, AUD_POWER};\n\t7\t\t:\trom_data\t<=\t{10'h334, 7'h7, AUD_DATA_FORMAT};\n\t8\t\t:\trom_data\t<=\t{10'h334, 7'h8, AUD_SAMPLE_CTRL};\n\t9\t\t:\trom_data\t<=\t{10'h334, 7'h9, AUD_SET_ACTIVE};\n\t10\t\t:\trom_data\t<=\t26'h3401500;\n\t11\t\t:\trom_data\t<=\t26'h3401741;\n\t12\t\t:\trom_data\t<=\t26'h3403a16;\n\t13\t\t:\trom_data\t<=\t26'h3405004;\n\t14\t\t:\trom_data\t<=\t26'h340c305;\n\t15\t\t:\trom_data\t<=\t26'h340c480;\n\t16\t\t:\trom_data\t<=\t26'h3400e80;\n\t17\t\t:\trom_data\t<=\t26'h3405020;\n\t18\t\t:\trom_data\t<=\t26'h3405218;\n\t19\t\t:\trom_data\t<=\t26'h34058ed;\n\t20\t\t:\trom_data\t<=\t26'h34077c5;\n\t21\t\t:\trom_data\t<=\t26'h3407c93;\n\t22\t\t:\trom_data\t<=\t26'h3407d00;\n\t23\t\t:\trom_data\t<=\t26'h340d048;\n\t24\t\t:\trom_data\t<=\t26'h340d5a0;\n\t25\t\t:\trom_data\t<=\t26'h340d7ea;\n\t26\t\t:\trom_data\t<=\t26'h340e43e;\n\t27\t\t:\trom_data\t<=\t26'h340ea0f;\n\t28\t\t:\trom_data\t<=\t26'h3403112;\n\t29\t\t:\trom_data\t<=\t26'h3403281;\n\t30\t\t:\trom_data\t<=\t26'h3403384;\n\t31\t\t:\trom_data\t<=\t26'h34037A0;\n\t32\t\t:\trom_data\t<=\t26'h340e580;\n\t33\t\t:\trom_data\t<=\t26'h340e603;\n\t34\t\t:\trom_data\t<=\t26'h340e785;\n\t35\t\t:\trom_data\t<=\t26'h3405000;\n\t36\t\t:\trom_data\t<=\t26'h3405100;\n\t37\t\t:\trom_data\t<=\t26'h3400070;\n\t38\t\t:\trom_data\t<=\t26'h3401010;\n\t39\t\t:\trom_data\t<=\t26'h3400482;\n\t40\t\t:\trom_data\t<=\t26'h3400860;\n\t41\t\t:\trom_data\t<=\t26'h3400a18;\n\t42\t\t:\trom_data\t<=\t26'h3401100;\n\t43\t\t:\trom_data\t<=\t26'h3402b00;\n\t44\t\t:\trom_data\t<=\t26'h3402c8c;\n\t45\t\t:\trom_data\t<=\t26'h3402df2;\n\t46\t\t:\trom_data\t<=\t26'h3402eee;\n\t47\t\t:\trom_data\t<=\t26'h3402ff4;\n\t48\t\t:\trom_data\t<=\t26'h34030d2;\n\t49\t\t:\trom_data\t<=\t26'h3400e05;\n\tdefault\t:\trom_data\t<=\t26'h1000000;\n\tendcase\nend\n\n\n\n\nendmodule\n\n",
        "module_name": "Altera_UP_I2C_AV_Auto_Initialize",
        "module_hash": "376d7c0d1f1ef5cf4967765dc5583e99",
        "dataset_index": 22923
      },
      "watchdog_timer_b9bea955": {
        "rtl_code": "module watchdog_timer (\n  input clk,\n  input rst,\n  input [7:0] time,\n  output wdt\n);\n\n  reg [7:0] timer;\n  reg wdt_enable;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      timer <= time;\n      wdt_enable <= 0;\n    end else begin\n      if (timer == 0) begin\n        wdt_enable <= 1;\n      end else if (wdt_enable && timer > 0) begin\n        timer <= timer - 1;\n      end\n    end\n  end\n\n  assign wdt = wdt_enable;\n\nendmodule",
        "module_name": "watchdog_timer",
        "module_hash": "b9bea955340bedea7a0c2cb2bf500694",
        "dataset_index": 5272
      },
      "LedCounter_0ff6b2b9": {
        "rtl_code": "module LedCounter(clk, data_bus, enable, write, segments, enable_segments);\n    inout [15:0] data_bus;\n    output [7:0] segments;\n    output reg [3:0] enable_segments;\n    reg [3:0] digits [3:0];\n    reg [6:0] counter;\n    input clk, enable, write;\n\n    initial begin\n        digits[0] = 4'h0;\n        digits[1] = 4'h0;\n        digits[2] = 4'h0;\n        digits[3] = 4'h0;\n        counter = 0;\n    end\n    \n    Digit dd(digits[counter[6:5]], segments);\n\n    always @(posedge write)\n        if (enable) begin\n            digits[0] <= data_bus[3:0];\n            digits[1] <= data_bus[7:4];\n            digits[2] <= data_bus[11:8];\n            digits[3] <= data_bus[15:12];\n        end\n            \n    always @(posedge clk)\n        counter <= counter + 1;\n        \n    always @(counter)\n        case (counter[6:4])\n            3'b000: enable_segments = 4'b1110;\n            3'b010: enable_segments = 4'b1101;\n            3'b100: enable_segments = 4'b1011;\n            3'b110: enable_segments = 4'b0111;\n            default: enable_segments = 4'b1111;\n        endcase\n        \nendmodule\n\nmodule Digit(digit, real_segments);\n    input [3:0] digit;\n    output [7:0] real_segments;\n    reg [7:0] segments;\n    \n    assign real_segments = ~segments;\n    \n    always @(digit)\n        case (digit)\n            4'h0: segments = 8'b11111100;\n            4'h1: segments = 8'b01100000;\n            4'h2: segments = 8'b11011010;\n            4'h3: segments = 8'b11110010;\n            4'h4: segments = 8'b01100110;\n            4'h5: segments = 8'b10110110;\n            4'h6: segments = 8'b10111110;\n            4'h7: segments = 8'b11100000;\n            4'h8: segments = 8'b11111110;\n            4'h9: segments = 8'b11110110;\n            4'hA: segments = 8'b11101110;\n            4'hB: segments = 8'b00111110;\n            4'hC: segments = 8'b10011100;\n            4'hD: segments = 8'b01111010;\n            4'hE: segments = 8'b10011110;\n            4'hF: segments = 8'b10001110;\n        endcase\n    \nendmodule\n",
        "module_name": "LedCounter",
        "module_hash": "0ff6b2b93d4565a77b9a24e90a0fd3b3",
        "dataset_index": 23522
      },
      "Multiplexer_AC__parameterized30_0bb3d59b": {
        "rtl_code": "\nmodule Multiplexer_AC__parameterized30\n   (ctrl,\n    D0,\n    D1,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  output [0:0]S;\n\n  wire [0:0]S;\n\n  assign S = ctrl ? D1 : D0;\nendmodule",
        "module_name": "Multiplexer_AC__parameterized30",
        "module_hash": "0bb3d59ba447847ab405cd582c24bf67",
        "dataset_index": 14606
      },
      "butterfly_32_0adfc7e1": {
        "rtl_code": "module butterfly_32(\n\t\t         enable,\n                i_0,\n                i_1,\n                i_2,\n                i_3,\n                i_4,\n                i_5,\n                i_6,\n                i_7,\n                i_8,\n                i_9,\n                i_10,\n                i_11,\n                i_12,\n                i_13,\n                i_14,\n                i_15,\n                i_16,\n                i_17,\n                i_18,\n                i_19,\n                i_20,\n                i_21,\n                i_22,\n                i_23,\n                i_24,\n                i_25,\n                i_26,\n                i_27,\n                i_28,\n                i_29,\n                i_30,\n                i_31,\n                \n                o_0,\n                o_1,\n                o_2,\n                o_3,\n                o_4,\n                o_5,\n                o_6,\n                o_7,\n                o_8,\n                o_9,\n                o_10,\n                o_11,\n                o_12,\n                o_13,\n                o_14,\n                o_15,\n                o_16,\n                o_17,\n                o_18,\n                o_19,\n                o_20,\n                o_21,\n                o_22,\n                o_23,\n                o_24,\n                o_25,\n                o_26,\n                o_27,\n                o_28,\n                o_29,\n                o_30,\n                o_31\n);\n\ninput             enable;\ninput signed  [26:0] i_0;\ninput signed  [26:0] i_1;\ninput signed  [26:0] i_2;\ninput signed  [26:0] i_3;\ninput signed  [26:0] i_4;\ninput signed  [26:0] i_5;\ninput signed  [26:0] i_6;\ninput signed  [26:0] i_7;\ninput signed  [26:0] i_8;\ninput signed  [26:0] i_9;\ninput signed  [26:0] i_10;\ninput signed  [26:0] i_11;\ninput signed  [26:0] i_12;\ninput signed  [26:0] i_13;\ninput signed  [26:0] i_14;\ninput signed  [26:0] i_15;\ninput signed  [26:0] i_16;\ninput signed  [26:0] i_17;\ninput signed  [26:0] i_18;\ninput signed  [26:0] i_19;\ninput signed  [26:0] i_20;\ninput signed  [26:0] i_21;\ninput signed  [26:0] i_22;\ninput signed  [26:0] i_23;\ninput signed  [26:0] i_24;\ninput signed  [26:0] i_25;\ninput signed  [26:0] i_26;\ninput signed  [26:0] i_27;\ninput signed  [26:0] i_28;\ninput signed  [26:0] i_29;\ninput signed  [26:0] i_30;\ninput signed  [26:0] i_31;\n\n\noutput  signed [27:0] o_0;\noutput  signed [27:0] o_1;\noutput  signed [27:0] o_2;\noutput  signed [27:0] o_3;\noutput  signed [27:0] o_4;\noutput  signed [27:0] o_5;\noutput  signed [27:0] o_6;\noutput  signed [27:0] o_7;\noutput  signed [27:0] o_8;\noutput  signed [27:0] o_9;\noutput  signed [27:0] o_10;\noutput  signed [27:0] o_11;\noutput  signed [27:0] o_12;\noutput  signed [27:0] o_13;\noutput  signed [27:0] o_14;\noutput  signed [27:0] o_15;\noutput  signed [27:0] o_16;\noutput  signed [27:0] o_17;\noutput  signed [27:0] o_18;\noutput  signed [27:0] o_19;\noutput  signed [27:0] o_20;\noutput  signed [27:0] o_21;\noutput  signed [27:0] o_22;\noutput  signed [27:0] o_23;\noutput  signed [27:0] o_24;\noutput  signed [27:0] o_25;\noutput  signed [27:0] o_26;\noutput  signed [27:0] o_27;\noutput  signed [27:0] o_28;\noutput  signed [27:0] o_29;\noutput  signed [27:0] o_30;\noutput  signed [27:0] o_31;\n\n\nwire  signed [27:0]   b_0;\nwire  signed [27:0]   b_1;\nwire  signed [27:0]   b_2;\nwire  signed [27:0]   b_3;\nwire  signed [27:0]   b_4;\nwire  signed [27:0]   b_5;\nwire  signed [27:0]   b_6;\nwire  signed [27:0]   b_7;\nwire  signed [27:0]   b_8;\nwire  signed [27:0]   b_9;\nwire  signed [27:0]   b_10;\nwire  signed [27:0]   b_11;\nwire  signed [27:0]   b_12;\nwire  signed [27:0]   b_13;\nwire  signed [27:0]   b_14;\nwire  signed [27:0]   b_15;\nwire  signed [27:0]   b_16;\nwire  signed [27:0]   b_17;\nwire  signed [27:0]   b_18;\nwire  signed [27:0]   b_19;\nwire  signed [27:0]   b_20;\nwire  signed [27:0]   b_21;\nwire  signed [27:0]   b_22;\nwire  signed [27:0]   b_23;\nwire  signed [27:0]   b_24;\nwire  signed [27:0]   b_25;\nwire  signed [27:0]   b_26;\nwire  signed [27:0]   b_27;\nwire  signed [27:0]   b_28;\nwire  signed [27:0]   b_29;\nwire  signed [27:0]   b_30;\nwire  signed [27:0]   b_31;\n\nassign b_0=i_0+i_31;\nassign b_1=i_1+i_30;\nassign b_2=i_2+i_29;\nassign b_3=i_3+i_28;\nassign b_4=i_4+i_27;\nassign b_5=i_5+i_26;\nassign b_6=i_6+i_25;\nassign b_7=i_7+i_24;\nassign b_8=i_8+i_23;               \nassign b_9=i_9+i_22;\nassign b_10=i_10+i_21;\nassign b_11=i_11+i_20;\nassign b_12=i_12+i_19;\nassign b_13=i_13+i_18;\nassign b_14=i_14+i_17;\nassign b_15=i_15+i_16;\nassign b_16=i_15-i_16;\nassign b_17=i_14-i_17;\nassign b_18=i_13-i_18;\nassign b_19=i_12-i_19;\nassign b_20=i_11-i_20;\nassign b_21=i_10-i_21;\nassign b_22=i_9-i_22;\nassign b_23=i_8-i_23; \nassign b_24=i_7-i_24;      \nassign b_25=i_6-i_25;\nassign b_26=i_5-i_26;               \nassign b_27=i_4-i_27;\nassign b_28=i_3-i_28;               \nassign b_29=i_2-i_29;\nassign b_30=i_1-i_30;               \nassign b_31=i_0-i_31;\n\nassign o_0=enable?b_0:i_0;\nassign o_1=enable?b_1:i_1;\nassign o_2=enable?b_2:i_2;\nassign o_3=enable?b_3:i_3;\nassign o_4=enable?b_4:i_4;\nassign o_5=enable?b_5:i_5;\nassign o_6=enable?b_6:i_6;\nassign o_7=enable?b_7:i_7;\nassign o_8=enable?b_8:i_8;\nassign o_9=enable?b_9:i_9;\nassign o_10=enable?b_10:i_10;\nassign o_11=enable?b_11:i_11;\nassign o_12=enable?b_12:i_12;\nassign o_13=enable?b_13:i_13;\nassign o_14=enable?b_14:i_14;\nassign o_15=enable?b_15:i_15;\nassign o_16=enable?b_16:i_16;\nassign o_17=enable?b_17:i_17;\nassign o_18=enable?b_18:i_18;\nassign o_19=enable?b_19:i_19;\nassign o_20=enable?b_20:i_20;\nassign o_21=enable?b_21:i_21;\nassign o_22=enable?b_22:i_22;\nassign o_23=enable?b_23:i_23;\nassign o_24=enable?b_24:i_24;\nassign o_25=enable?b_25:i_25;\nassign o_26=enable?b_26:i_26;\nassign o_27=enable?b_27:i_27;\nassign o_28=enable?b_28:i_28;\nassign o_29=enable?b_29:i_29;\nassign o_30=enable?b_30:i_30;\nassign o_31=enable?b_31:i_31;\n\nendmodule",
        "module_name": "butterfly_32",
        "module_hash": "0adfc7e131c2e4a295e7adb1a3d7c76a",
        "dataset_index": 23848
      },
      "add_sub_4bit_c4448ae4": {
        "rtl_code": "module add_sub_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nreg [3:0] temp_sum;\nreg temp_cout;\n\nalways @(*) begin\n    if (mode == 1) begin // subtraction mode\n        temp_sum = A - B - cin;\n        temp_cout = ~(A[3] ^ B[3]) & (temp_sum[3] ^ B[3]);\n    end else begin // addition mode\n        temp_sum = A + B + cin;\n        temp_cout = (A[3] & B[3]) | ((A[3] | B[3]) & ~temp_sum[3]);\n    end\nend\n\nassign sum = temp_sum;\nassign cout = temp_cout;\n\nendmodule\n",
        "module_name": "add_sub_4bit",
        "module_hash": "c4448ae456deaabf13685b1059c672eb",
        "dataset_index": 20302
      },
      "top_module_2d32cda5": {
        "rtl_code": "\nmodule top_module(\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo );\n\n    wire [7:0] sum_hi;\n    wire [7:0] sum_lo;\n\n    byte_decoder decoder(.in(in), .out_hi(sum_hi), .out_lo(sum_lo));\n    byte_mux mux_hi(.a(sum_hi), .b(8'b0), .sel(in[15]), .out(out_hi));\n    byte_mux mux_lo(.a(sum_lo), .b(8'b0), .sel(in[7]), .out(out_lo));\n\nendmodule\nmodule byte_decoder(\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo );\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule\nmodule byte_mux(\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire sel,\n    output wire [7:0] out );\n\n    assign out = sel ? b : a;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "2d32cda5bbf80b8060a248938480c1b2",
        "dataset_index": 15698
      },
      "sky130_fd_sc_lp__or3_54b777c7": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__or3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out_X;\n\n    or  or0  (or0_out_X, B, A, C        );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__or3",
        "module_hash": "54b777c757c1fbbcf863c433f55951dc",
        "dataset_index": 23548
      },
      "control_o_58814768": {
        "rtl_code": "module control_o (reset, rxd, StringReady, CharReady, parity, ready, error, WriteChar, WriteString, PossibleStart, clk_2, check);\n\n   input rxd;\n   input StringReady;\n   input CharReady;\n   input parity;\n   input clk_2;\n   input check;\n   input reset;\n   \n   output reg ready;\n   output reg error;\n   output reg WriteChar;\n   output reg WriteString;\n   output reg PossibleStart;\n  \n   reg [2:0]  current_state;\n   reg [2:0]  next_state;\n   \n   // se les ponen nombres a los estados para que en el case se pueda entender y manejar mejor\n   parameter IDLE = 3'b000;\n   parameter POSSIBLESTART = 3'b001;\n   parameter READ = 3'b010;\n   parameter ERROR = 3'b011;\n   parameter WRITE = 3'b100;\n   parameter STOP = 3'b101;\n\n   always @(current_state or rxd or check or CharReady or StringReady or reset or parity) begin\n      if (reset==1'b1) begin\n\t next_state <= 3'b000;\n\t ready =1'b0;\n\t error = 1'b0;\n\t WriteString = 1'b0;\n\t WriteChar = 1'b0;\n\t PossibleStart = 1'b0;\n\n      end\n      else begin\n\t case (current_state)\n\t   IDLE: begin\n\t      if (rxd==1)\n\t\tnext_state<=IDLE;\n\t      else\n\t\tnext_state<=POSSIBLESTART;\n\n\n\t      ready=1'b0;\n\t      error=1'b0;\n\t      WriteChar=1'b0;\n\t      WriteString=1'b0;\n\t      PossibleStart=1'b0;\n\t   end // case: IDLE\n\t   \n\t   POSSIBLESTART: begin\n\t      if (check == 1) begin\n\t\t if (rxd == 0) begin\n\t\t   next_state<=READ;\n\t\tend\t\t\n\t\t else\n\t\t   next_state<=IDLE;\n\t      end\n\t      else\n\t\tnext_state<=POSSIBLESTART;\n\n\t      ready=1'b0;\n\t      error=1'b0;\n\t      WriteChar=1'b0;\n\t      WriteString=1'b0;\n\t      PossibleStart=1'b1;\n\n\t   end // case: POSSIBLESTART\n\t   \n\t   READ: begin\n\t      if (CharReady==0)\n\t\tnext_state<=READ;\n\t      else\n\t\tnext_state<=ERROR;\n\n\t      ready=1'b0;\n\t      error=1'b0;\n\t      WriteChar=1'b1;\n\t      WriteString=1'b0;\n\t      PossibleStart=1'b0;\n\t   end // case: READ\n\t   \n\t   ERROR: begin\n\t      next_state<=WRITE;\n\t      if (parity==1)\n\t\terror=1'b1;\n\t      else\n\t\terror=1'b0;\n\n\t      ready=1'b0;\n\t      WriteChar=1'b0;\n\t      WriteString=1'b0;\n\t      PossibleStart=1'b0;\n\t   end // case: ERROR\n\t   \n\t   WRITE: begin\n\t      if (StringReady==0)\n\t\tnext_state<=IDLE;\n\t      else\n\t\tnext_state<=STOP;\n\n\t      ready=1'b0;\n\t      error=1'b0;\n\t      WriteChar=1'b0;\n\t      WriteString=1'b1;\n\t      PossibleStart=1'b0;\n\t   end // case: WRITE\n\t   \n\t   STOP: begin\n\t\tnext_state<=IDLE;\n\n\t      ready=1'b1;\n\t      error=1'b0;\n\t      WriteChar=1'b0;\n\t      WriteString=1'b0;\n\t      PossibleStart=1'b0;\n\t   end // case: STOP\n\t   \n\t   default: begin \n\t      next_state<=IDLE;\n\t      ready=1'b0;\n\t      error=1'b0;\n\t      WriteChar=1'b0;\n\t      WriteString=1'b0;\n\t      PossibleStart=1'b0;\n\t   end\n\t endcase // case (current_state)\n      end // else: !if(reset==1'b1)\n   end // always @ (posedge clk_2)\n   \n   always @(negedge clk_2 or posedge reset) begin\n      if (reset == 1'b1) begin\n\tcurrent_state<=IDLE;\n\tend\n      else begin\n\tcurrent_state<=next_state;\n\tend\n   end\nendmodule",
        "module_name": "control_o",
        "module_hash": "58814768a5bb4cbb9888984bc424eb1d",
        "dataset_index": 7167
      },
      "RAM_SP_AR_5d043414": {
        "rtl_code": "\n\n\nmodule RAM_SP_AR(clk, addr, we, din, dout);\n    parameter  DATA_WIDTH = 8;\n    parameter  ADDR_WIDTH = 8;\n    localparam RAM_DEPTH  = 1 << ADDR_WIDTH;\n    input  clk;\n    input  [(ADDR_WIDTH-1):0] addr;\n    input  we;\n    input  [(DATA_WIDTH-1):0] din;\n    output [(DATA_WIDTH-1):0] dout;\n\n    reg [(DATA_WIDTH-1):0] ram [0:(RAM_DEPTH-1)];\n\n    assign dout = ram[addr];\n\n    always @(posedge clk) begin\n        if (we) begin\n            ram[addr] <= din;\n        end\n    end\n\nendmodule\n",
        "module_name": "RAM_SP_AR",
        "module_hash": "5d043414f9c1939251cadc59f1099dcf",
        "dataset_index": 20153
      },
      "axi_traffic_gen_v2_0_7_ex_fifo_0e9f69e4": {
        "rtl_code": "\n\nmodule axi_traffic_gen_v2_0_7_ex_fifo\n        #(\n  parameter WIDTH        = 10,\n  parameter DEPTH        = 8 ,\n  parameter DEPTHBITS    = 3 ,\n  parameter HEADREG      = 1 ,\n  parameter ZERO_INVALID = 0 ,\n  parameter FULL_LEVEL   = 6 ,\n  parameter BLOCK_ACTIVE = 0 ) (\n  input              Clk              ,\n  input              rst_l            ,\n  input [WIDTH-1:0]  in_data          ,\n  input              in_push          ,\n  input              in_pop           ,\n  output [WIDTH-1:0] out_data         ,\n  output             is_full          ,\n  output             is_notfull       ,\n  output             is_empty         ,\n  output             out_valid        ,\n  \n  output [15:0] ex_fifo_dbgout\n\n);\n\nreg [WIDTH-1:0    ] data_ff[DEPTH-1:0];\nreg [DEPTHBITS-1:0] out_ptr_ff;\nreg [DEPTHBITS-1:0] in_ptr_ff;\nreg [DEPTHBITS:0  ] depth_ff;\nreg [WIDTH-1:0    ] headreg_ff;\nreg full_ff, notfull_ff, valid_ff, valid_filt_ff;\n\nwire [DEPTHBITS-1:0] in_ptr = (in_push) ? in_ptr_ff[DEPTHBITS-1:0] + 'h1 :\n                                                in_ptr_ff[DEPTHBITS-1:0];\nwire [DEPTHBITS:0] depth =\n                (in_push && ~in_pop) ? depth_ff[DEPTHBITS:0] + 'h1 :\n                (~in_push && in_pop) ? depth_ff[DEPTHBITS:0] - 'h1 :\n                                                        depth_ff[DEPTHBITS:0];\nwire        depth_was1 = (depth_ff[DEPTHBITS:0] == 'h1);\nwire        valid = (depth[DEPTHBITS:0] != 'h0);\nwire        full ;\ngenerate if(BLOCK_ACTIVE == 1 ) begin : BLOCK_ACTIVE_FULL_YES\nend\nendgenerate\ngenerate if(BLOCK_ACTIVE == 0 ) begin : BLOCK_ACTIVE_FULL_NO\n assign full = (depth[DEPTHBITS:0] >= FULL_LEVEL) ;\nend\nendgenerate\n\nwire        notfull = ~full;\nwire [WIDTH-1:0] raw_data = data_ff[out_ptr_ff[DEPTHBITS-1:0]];\n\nwire [DEPTHBITS-1:0] out_ptr = (in_pop) ? out_ptr_ff[DEPTHBITS-1:0] + 'h1 :\n                                                out_ptr_ff[DEPTHBITS-1:0];\n\nwire [WIDTH-1:0] head_raw_data = (depth_was1) ? in_data[WIDTH-1:0] :\n                                                        raw_data[WIDTH-1:0];\nwire [WIDTH-1:0] headreg = (!valid_ff && in_push) ? in_data[WIDTH-1:0] :\n                (in_pop) ? head_raw_data[WIDTH-1:0] : headreg_ff[WIDTH-1:0];\n\nwire        valid_filt ;\ngenerate if(BLOCK_ACTIVE == 1 ) begin : BLOCK_ACTIVE_VALID_YES\nend\nendgenerate\ngenerate if(BLOCK_ACTIVE == 0 ) begin : BLOCK_ACTIVE_VALID_NO\n assign valid_filt = valid ;\n                        end\nendgenerate\n\nalways @(posedge Clk) begin\n        in_ptr_ff[DEPTHBITS-1:0]  <= (rst_l) ? in_ptr[DEPTHBITS-1:0] : {DEPTHBITS{1'b0}};\n        out_ptr_ff[DEPTHBITS-1:0] <= (rst_l) ? out_ptr[DEPTHBITS-1:0] :\n                                                ((HEADREG) ? {{(DEPTHBITS-1){1'b0}},{1'b1}} : {DEPTHBITS{1'b0}});\n        depth_ff[DEPTHBITS:0]     <= (rst_l) ? depth[DEPTHBITS:0] : {DEPTHBITS{1'b0}};\n        valid_ff                  <= (rst_l) ? valid : 1'b0;\n        valid_filt_ff             <= (rst_l) ? valid_filt : 1'b0;\n        full_ff                   <= (rst_l) ? full : 1'b1;\n        notfull_ff                <= (rst_l) ? notfull : 1'b0;\n        headreg_ff[WIDTH-1:0]     <= (rst_l) ? headreg[WIDTH-1:0] : {WIDTH{1'b0}};\nend\n\ninteger i;\nalways @(posedge Clk) begin\n        if(in_push) begin\n                data_ff[in_ptr_ff[DEPTHBITS-1:0]] <= in_data[WIDTH-1:0];\n        end\n\n`ifdef FOO_BAR\n        for(i = 0; i < DEPTH; i = i + 1) begin\n                if(~rst_l && (HEADREG == 0)) begin\n                        data_ff[i] <= {WIDTH{1'b0}};\n                end else if((i == in_ptr_ff[DEPTHBITS-1:0]) && in_push) begin\n                        data_ff[i] <= in_data[WIDTH-1:0];\n                end\n        end\n`endif\nend\n\n\nassign out_data[WIDTH-1:0] = (ZERO_INVALID && ~valid_filt_ff) ? { WIDTH {1'b0}}:\n                                (HEADREG) ? headreg_ff[WIDTH-1:0] :\n                                                        raw_data[WIDTH-1:0];\nassign out_valid  = valid_filt_ff;\nassign is_full    = full_ff      ;\nassign is_notfull = notfull_ff   ;\nassign is_empty   = ~valid_ff    ;\n\n\nassign ex_fifo_dbgout = 16'b0 | depth_ff;\n\n\nendmodule\n\n",
        "module_name": "axi_traffic_gen_v2_0_7_ex_fifo",
        "module_hash": "0e9f69e41aa6a43d7d4f313d5d1aa464",
        "dataset_index": 22846
      },
      "top_module_4b7c29e9": {
        "rtl_code": "module top_module(\n    input [99:0] a, b, // Input ports for 100-bit binary numbers\n    input cin, // Carry-in input for 100-bit binary adder\n    input clk, // Clock input for 4-bit binary counter\n    input reset, // Synchronous active-high reset input for 4-bit binary counter\n    output [99:0] sum // Output port for final 100-bit sum\n);\n\n    wire [99:0] adder_out;\n    wire [3:0] counter_out;\n    wire [99:0] final_sum;\n\n    // Instantiate the 100-bit binary adder\n    binary_adder adder_inst(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(adder_out),\n        .cout()\n    );\n\n    // Instantiate the 4-bit binary counter\n    binary_counter counter_inst(\n        .clk(clk),\n        .reset(reset),\n        .out(counter_out)\n    );\n\n    // Instantiate the functional module that adds the output of the adder to the counter value\n    functional_module func_inst(\n        .adder_out(adder_out),\n        .counter_out(counter_out),\n        .final_sum(final_sum)\n    );\n\n    // Assign the final sum to the output port\n    assign sum = final_sum;\n\nendmodule\n\n// 100-bit binary adder module\nmodule binary_adder(\n    input [99:0] a, b, // Input ports for 100-bit binary numbers\n    input cin, // Carry-in input\n    output reg [99:0] sum, // Output port for sum\n    output reg cout // Output port for carry-out\n);\n\n    always @(*) begin\n        {cout, sum} = a + b + cin;\n    end\n\nendmodule\n\n// 4-bit binary counter module\nmodule binary_counter(\n    input clk, // Clock input\n    input reset, // Synchronous active-high reset input\n    output reg [3:0] out // Output port for counter value\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0;\n        end else begin\n            out <= out + 1;\n        end\n    end\n\nendmodule\n\n// Functional module that adds the output of the adder to the counter value\nmodule functional_module(\n    input [99:0] adder_out, // Input port for output of 100-bit binary adder\n    input [3:0] counter_out, // Input port for output of 4-bit binary counter\n    output reg [99:0] final_sum // Output port for final sum\n);\n\n    always @(*) begin\n        final_sum = adder_out + {96'b0, counter_out};\n    end\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "4b7c29e9440479cf0ea54eb09199390b",
        "dataset_index": 13811
      },
      "BLOCK1A_54c5588c": {
        "rtl_code": "module BLOCK1A ( PIN2, GIN1, GIN2, PHI, GOUT );\n\ninput  PIN2;\ninput  GIN1;\ninput  GIN2;\ninput  PHI;\noutput GOUT;\n\nreg    GOUT;\n\nalways @(posedge PHI) begin\n   GOUT =  ~ (GIN2 & (PIN2 | GIN1));\nend\n\nendmodule",
        "module_name": "BLOCK1A",
        "module_hash": "54c5588cdd50f1795f1b2ad9584b1fb9",
        "dataset_index": 3130
      },
      "and_gate_with_control_c4296c61": {
        "rtl_code": "module and_gate_with_control (\n    input A1,\n    input A2,\n    input C1,\n    output Y\n);\n\n    assign Y = (C1 == 0) ? (A1 & A2) : 0;\n\nendmodule",
        "module_name": "and_gate_with_control",
        "module_hash": "c4296c614a649fa4e96deba075e98d20",
        "dataset_index": 18030
      },
      "comparator_264a743e": {
        "rtl_code": "module comparator(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [1:0] C\n);\n\n// Comparing A and B\nalways @(*) begin\n    if(A == B) begin\n        C = 2'b00;\n    end\n    else if(A > B) begin\n        C = 2'b01;\n    end\n    else begin\n        C = 2'b10;\n    end\nend\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "264a743ed02dead87e733a0c67773cc7",
        "dataset_index": 21518
      },
      "uart_tx_3ca76922": {
        "rtl_code": "module uart_tx(\n               input               clk_i,\n               input [7:0]         rx_i,\n               input               rx_i_v,\n               output              tx_o,\n               output              tx_o_v\n               );\n\n    localparam ST_IDLE   = 3'd0;\n    localparam ST_START  = 3'd1;\n    localparam ST_DATA   = 3'd2;\n    localparam ST_STOP   = 3'd3;\n\n    reg [2:0]                   state = ST_IDLE;\n    reg [2:0]                   tx_ctr = 0;\n\n    reg [7:0]                   s_rx = 0;\n    reg                         s_tx = 1;\n\n\n    always @ (posedge clk_i)\n    begin\n        case (state)\n\n            ST_IDLE :\n                if (rx_i_v)\n                    state <= ST_START;\n\n            ST_START :\n                state <= ST_DATA;\n\n            ST_DATA :\n                if (tx_ctr == 7)\n                    state <= ST_STOP;\n\n            ST_STOP :\n                state <= ST_IDLE;\n\n        endcase\n    end // always @ (posedge clk_i)\n\n    always @ (posedge clk_i)\n    begin\n        if (state == ST_DATA)\n        begin\n            tx_ctr <= tx_ctr + 1;\n        end\n        else\n        begin\n            tx_ctr <= 0;\n        end\n    end // always @ (posedge state)\n\n    always @ (posedge clk_i)\n    begin\n        if (state == ST_START)\n        begin\n            s_rx <= rx_i;\n        end\n        else if (state == ST_DATA)\n        begin\n            s_rx <= s_rx >> 1;\n        end\n    end\n\n    assign tx_o_v = (state == ST_IDLE) ? 0 : 1;\n\n    always @ *\n    begin\n        if (state == ST_START)\n        begin\n            s_tx = 0;\n        end\n        else if (state == ST_DATA)\n        begin\n            s_tx = s_rx[0];\n        end\n        else if (state == ST_STOP)\n        begin\n            s_tx = 1;\n        end\n    end // always @ *\n\n    assign tx_o = s_tx;\n\n\nendmodule",
        "module_name": "uart_tx",
        "module_hash": "3ca76922e338e2cba0ed0e09ca90bc62",
        "dataset_index": 18592
      },
      "pipeline_split_2d0834c8": {
        "rtl_code": "\nmodule pipeline_split(\n    input wire [15:0] in,\n    output reg [7:0] out_hi,\n    output reg [7:0] out_lo\n);\n\nalways @(*) begin\n    out_hi = in[15:8];\n    out_lo = in[7:0];\nend\n\nendmodule\nmodule top_module(\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    input wire clk\n); // Added clk as an input to the module\n\nwire [7:0] stage1_out_hi;\nwire [7:0] stage1_out_lo;\n\npipeline_split u_pipeline_split(\n    .in(in),\n    .out_hi(stage1_out_hi),\n    .out_lo(stage1_out_lo)\n);\n\n// Added a register to pipeline the output\nreg [7:0] out_hi_reg;\nreg [7:0] out_lo_reg;\n\nalways @ (posedge clk) begin\n  // Store the pipeline output in registers\n  out_hi_reg <= stage1_out_hi;\n  out_lo_reg <= stage1_out_lo;\nend\n\nassign out_hi = out_hi_reg;\nassign out_lo = out_lo_reg;\n\nendmodule",
        "module_name": "pipeline_split",
        "module_hash": "2d0834c888cbae75c7552e4c0883ed78",
        "dataset_index": 1666
      },
      "flip_flop_f0b01520": {
        "rtl_code": "module flip_flop (\n    Q,\n    CLK,\n    D,\n    SCD,\n    SCE,\n    RESET_B\n);\n\n    output Q;\n    input CLK;\n    input D;\n    input SCD;\n    input SCE;\n    input RESET_B;\n\n    reg Q;\n\n    always @(posedge CLK or negedge RESET_B) begin\n        if (!RESET_B) begin\n            Q <= 0;\n        end else if (SCD) begin\n            Q <= 1;\n        end else if (SCE) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "flip_flop",
        "module_hash": "f0b01520721d23dbe2281a49a967fd59",
        "dataset_index": 4572
      },
      "top_module_d87873b0": {
        "rtl_code": "module top_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n\nwire [31:0] adder_output;\n\nadder_32bit adder_inst (\n    .a(a),\n    .b(b),\n    .sum(adder_output)\n);\n\nbyte_reverser reverser_inst (\n    .input_data(adder_output),\n    .output_data(out)\n);\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\nwire [7:0] adder_output_0, adder_output_1, adder_output_2, adder_output_3;\n\nadder_8bit adder_0 (\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .sum(adder_output_0)\n);\n\nadder_8bit adder_1 (\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .sum(adder_output_1)\n);\n\nadder_8bit adder_2 (\n    .a(a[23:16]),\n    .b(b[23:16]),\n    .sum(adder_output_2)\n);\n\nadder_8bit adder_3 (\n    .a(a[31:24]),\n    .b(b[31:24]),\n    .sum(adder_output_3)\n);\n\nassign sum = {adder_output_3, adder_output_2, adder_output_1, adder_output_0};\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n\nassign sum = a + b;\n\nendmodule\n\nmodule byte_reverser(\n    input [31:0] input_data,\n    output [31:0] output_data\n);\n\nassign output_data = {input_data[7:0], input_data[15:8], input_data[23:16], input_data[31:24]};\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "d87873b0445e4a64d5d69a59b0c50624",
        "dataset_index": 19040
      },
      "seven_segment_display_4596000e": {
        "rtl_code": "module seven_segment_display(\n    input [3:0] binary_input,\n    output [6:0] seven_segment_output\n);\n\nassign seven_segment_output[6] = (binary_input == 4'b0000 || binary_input == 4'b0001 || binary_input == 4'b0111 || binary_input == 4'b1111) ? 1 : 0; //segment A\nassign seven_segment_output[5] = (binary_input == 4'b0010 || binary_input == 4'b0011 || binary_input == 4'b0110 || binary_input == 4'b0111) ? 1 : 0; //segment B\nassign seven_segment_output[4] = (binary_input == 4'b0001 || binary_input == 4'b0010 || binary_input == 4'b0100 || binary_input == 4'b0101 || binary_input == 4'b0110 || binary_input == 4'b1000 || binary_input == 4'b1011 || binary_input == 4'b1111) ? 1 : 0; //segment C\nassign seven_segment_output[3] = (binary_input == 4'b0000 || binary_input == 4'b0001 || binary_input == 4'b0011 || binary_input == 4'b0100 || binary_input == 4'b0101 || binary_input == 4'b0111 || binary_input == 4'b1000 || binary_input == 4'b1010 || binary_input == 4'b1011 || binary_input == 4'b1111) ? 1 : 0; //segment D\nassign seven_segment_output[2] = (binary_input == 4'b0001 || binary_input == 4'b0010 || binary_input == 4'b0100 || binary_input == 4'b0101 || binary_input == 4'b1000 || binary_input == 4'b1010 || binary_input == 4'b1011 || binary_input == 4'b1111) ? 1 : 0; //segment E\nassign seven_segment_output[1] = (binary_input == 4'b0001 || binary_input == 4'b0000 || binary_input == 4'b0010 || binary_input == 4'b0100 || binary_input == 4'b0101 || binary_input == 4'b0111 || binary_input == 4'b1000 || binary_input == 4'b1011 || binary_input == 4'b1111) ? 1 : 0; //segment F\nassign seven_segment_output[0] = (binary_input == 4'b0001 || binary_input == 4'b0000 || binary_input == 4'b0010 || binary_input == 4'b0100 || binary_input == 4'b1000 || binary_input == 4'b1010 || binary_input == 4'b1011 || binary_input == 4'b1111) ? 1 : 0; //segment G\n\nendmodule",
        "module_name": "seven_segment_display",
        "module_hash": "4596000e20e2c8274502232044abc6dd",
        "dataset_index": 7258
      },
      "ad_addsub_fab23858": {
        "rtl_code": "\n\nmodule ad_addsub (\n  clk,\n  A,\n  Amax,\n  out,\n  CE\n);\n\n  parameter   A_WIDTH = 32;\n  parameter   CONST_VALUE = 32'h1;\n  parameter   ADD_SUB = 0;\n\n  localparam  ADDER = 0;\n  localparam  SUBSTRACTER = 1;\n\n  input                     clk;\n  input   [(A_WIDTH-1):0]   A;\n  input   [(A_WIDTH-1):0]   Amax;\n  output  [(A_WIDTH-1):0]   out;\n  input                     CE;\n\n  reg     [(A_WIDTH-1):0]   out = 'b0;\n  reg     [A_WIDTH:0]       out_d = 'b0;\n  reg     [A_WIDTH:0]       out_d2 = 'b0;\n  reg     [(A_WIDTH-1):0]   A_d = 'b0;\n  reg     [(A_WIDTH-1):0]   A_d2 = 'b0;\n  reg     [(A_WIDTH-1):0]   Amax_d = 'b0;\n  reg     [(A_WIDTH-1):0]   Amax_d2 = 'b0;\n\n  reg     [(A_WIDTH-1):0]   B_reg = CONST_VALUE;\n\n  always @(posedge clk) begin\n      A_d <= A;\n      A_d2 <= A_d;\n      Amax_d <= Amax;\n      Amax_d2 <= Amax_d;\n  end\n\n  always @(posedge clk) begin\n    if ( ADD_SUB == ADDER ) begin\n      out_d <= A_d + B_reg;\n    end else begin\n      out_d <= A_d - B_reg;\n    end\n  end\n\n  always @(posedge clk) begin\n    if ( ADD_SUB == ADDER ) begin\n      if ( out_d > Amax_d2 ) begin\n        out_d2 <= out_d - Amax_d2;\n      end else begin\n        out_d2 <= out_d;\n      end\n    end else begin if ( out_d[A_WIDTH] == 1'b1 ) begin\n        out_d2 <= Amax_d2 + out_d;\n      end else begin\n        out_d2 <= out_d;\n      end\n    end\n  end\n\n  always @(posedge clk) begin\n    if ( CE ) begin\n      out <= out_d2;\n    end else begin\n      out <= 'b0;\n    end\n  end\n\nendmodule\n",
        "module_name": "ad_addsub",
        "module_hash": "fab23858b3852b5f86be0ea55bc47d13",
        "dataset_index": 17106
      },
      "reverse_parity_169da90f": {
        "rtl_code": "module reverse_parity(input [2:0] in_vec, output [2:0] out_vec, output even_parity);\n\n  reg [2:0] shift_reg;\n  wire xor_out;\n\n  assign xor_out = in_vec[0] ^ in_vec[1] ^ in_vec[2];\n\n  always @ (in_vec) begin\n    shift_reg <= {in_vec[2], in_vec[1], in_vec[0]};\n  end\n\n  assign out_vec = shift_reg;\n  assign even_parity = xor_out;\n\nendmodule",
        "module_name": "reverse_parity",
        "module_hash": "169da90fddadc1057769fdc093bb5d63",
        "dataset_index": 1466
      },
      "top_module_13594c07": {
        "rtl_code": "\nmodule top_module(\n    input [3:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    input [1:0] select,\n    output [1:0] pos,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    output [2:0] out\n);\n    functional_module fm(.in(in), .a(a), .b(b), .select(select), .pos(pos), .out_or_bitwise(out_or_bitwise), .out_or_logical(out_or_logical), .out_not(out_not), .out(out));\nendmodule\n\nmodule functional_module(\n    input [3:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    input [1:0] select, // Added the select input port\n    output [1:0] pos,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    output [2:0] out\n);\n    priority_encoder pe(.in(in), .pos(pos));\n    binary_module bm(.a(a), .b(b), .out_or_bitwise(out_or_bitwise), .out_or_logical(out_or_logical), .out_not(out_not));\n    assign out = (select == 0) ? pos :\n                 (select == 1) ? {out_or_bitwise, out_or_logical, out_not[5:3]} :\n                                 {out_or_bitwise & out_not[2:0], out_or_logical & out_not[2:0]};\nendmodule\n\nmodule priority_encoder(\n    input [3:0] in,\n    output [1:0] pos\n);\n    assign pos = (in[3]) ? 2'b11 :\n                 (in[2]) ? 2'b10 :\n                 (in[1]) ? 2'b01 :\n                 (in[0]) ? 2'b00 :\n                           2'b00 ;\nendmodule\n\nmodule binary_module(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = (a || b);\n    assign out_not = ~{a, b};\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "13594c07de2ccf17755486fdfb3fda82",
        "dataset_index": 13868
      },
      "subfxp_da61e196": {
        "rtl_code": "module subfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a-b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1] >> 1;\n      \n   end\n  \nendmodule",
        "module_name": "subfxp",
        "module_hash": "da61e196850b2d1c41a22ac90c996ca1",
        "dataset_index": 19199
      },
      "sky130_fd_sc_lp__o22a_d2cdcf9c": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o22a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1          );\n    or  or1  (or1_out   , B2, B1          );\n    and and0 (and0_out_X, or0_out, or1_out);\n    buf buf0 (X         , and0_out_X      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o22a",
        "module_hash": "d2cdcf9c3b180c93df86ed88b2e804a0",
        "dataset_index": 19749
      },
      "digital_potentiometer_12cf1357": {
        "rtl_code": "module digital_potentiometer (\n  input clk,\n  input [2:0] addr,\n  input [6:0] data,\n  output reg [7:0] vout\n);\n\nparameter rmax = 10000; // maximum resistance value\nparameter rstep = 1000; // resistance step size\nparameter initial_pos = 0; // initial wiper position\n\nreg [6:0] resistances [0:7]; // array to store resistance values\ninteger i;\n\nalways @(posedge clk) begin\n  resistances[addr] <= data; // update the resistance value at the selected wiper position\nend\n\nalways @(posedge clk) begin\n  // calculate the voltage output based on the selected wiper position and resistance value\n  vout <= (resistances[addr] * 255) / rmax;\nend\n\ninitial begin\n  // initialize the potentiometer with the initial resistance value at the initial wiper position\n  for (i = 0; i < 8; i = i + 1) begin\n    resistances[i] = (i == initial_pos) ? (rstep * initial_pos) : 0;\n  end\nend\n\nendmodule",
        "module_name": "digital_potentiometer",
        "module_hash": "12cf135747010c229867459e865e47f9",
        "dataset_index": 16985
      },
      "nor_gate_b5c53890": {
        "rtl_code": "module nor_gate(input a, b, output out);\n    wire temp1, temp2, temp3;\n    \n    nand gate1(temp1, a, a);\n    nand gate2(temp2, b, b);\n    nand gate3(temp3, temp1, temp2);\n    nand gate4(out, temp3, temp3);\nendmodule",
        "module_name": "nor_gate",
        "module_hash": "b5c53890cf65dc8d7076f98b4671a7e5",
        "dataset_index": 12688
      },
      "SR_FF_D_FFSR_MUX_cf7e17c0": {
        "rtl_code": "\nmodule SR_FF_D_FFSR_MUX (\n  input D, S, R, CLK,\n  output Q\n);\n\n  wire D_FF_Q;\n  wire MUX_OUT;\n\n  // Instantiate the D-FFSR\n  D_FF_SR d_ff_sr (\n    .D(D),\n    .S(S),\n    .R(R),\n    .CLK(CLK),\n    .Q(D_FF_Q)\n  );\n\n  // Instantiate the MUX\n  MUX2x1 mux (\n    .IN0(D_FF_Q),\n    .IN1(R),  // Corrected the input to match the MUX behavior\n    .SEL(S),\n    .OUT(MUX_OUT)\n  );\n\n  assign Q = ~MUX_OUT; // Fix the RTL\n\nendmodule\nmodule D_FF_SR (\n  input D, S, R, CLK,\n  output Q\n);\n\n  reg Q_reg;\n\n  always @(posedge CLK) begin\n    if (R) Q_reg <= 1'b0;\n    else if (S) Q_reg <= 1'b1;\n    else Q_reg <= D;\n  end\n\n  assign Q = Q_reg;\n\nendmodule\nmodule MUX2x1 (\n  input IN0, IN1, SEL,\n  output OUT\n);\n\n  assign OUT = SEL ? IN1 : IN0;\n\nendmodule",
        "module_name": "SR_FF_D_FFSR_MUX",
        "module_hash": "cf7e17c0012854a0c93413c1a034b5ea",
        "dataset_index": 10564
      },
      "dff_rst_set_7de54f01": {
        "rtl_code": "module dff_rst_set (\n    input clk,\n    input rst,\n    input set,\n    input d,\n    output q,\n    output qn\n);\n\nreg q;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        q <= 0;\n    end\n    else if (set) begin\n        q <= 1;\n    end\n    else begin\n        q <= d;\n    end\nend\n\nassign qn = ~q;\n\nendmodule",
        "module_name": "dff_rst_set",
        "module_hash": "7de54f01e80ea0ab2ebaeda6fe71f0ed",
        "dataset_index": 17807
      },
      "shift_register_4bit_f4cb6bb5": {
        "rtl_code": "\nmodule shift_register_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input load,\n    input clk,\n    output [3:0] Q\n);\n\nreg [3:0] Q1, Q2, Q3, Q4;\n\nalways @(posedge clk) begin\n    if (load) begin\n        Q1 <= A;\n        Q2 <= B;\n        Q3 <= C;\n        Q4 <= D;\n    end else begin\n        Q1 <= Q2;\n        Q2 <= Q3;\n        Q3 <= Q4;\n        Q4 <= Q;\n    end\nend\n\nassign Q = {Q4,Q3,Q2,Q1}; // fix: concatenate the registers to form the output\n\nendmodule",
        "module_name": "shift_register_4bit",
        "module_hash": "f4cb6bb5ef8da989e53e6076994d6252",
        "dataset_index": 910
      },
      "adder16_080028d8": {
        "rtl_code": "module adder16 (\n    input [15:0] A,\n    input [15:0] B,\n    input C_in,\n    output [15:0] S,\n    output C_out\n);\n\nwire [16:0] temp_sum;\n\nassign temp_sum = {1'b0, A} + {1'b0, B} + {C_in};\n\nassign S = temp_sum[15:0];\nassign C_out = temp_sum[16];\n\nendmodule",
        "module_name": "adder16",
        "module_hash": "080028d8fefb47e13be55cda60fa1e24",
        "dataset_index": 11372
      },
      "fsm__e3c3433b": {
        "rtl_code": "module fsm_module (\n  input [2:0] tstate,\n  input foocr_we,\n  input ioclrinst,\n  input fooc2_qual,\n  output reg [2:0] ntstate,\n  output reg ioclrtmout\n);\n\n  parameter TIDLE = 3'b000;\n  parameter TCN1 = 3'b001;\n  parameter TCN2 = 3'b010;\n  parameter TCN3 = 3'b011;\n  parameter TCN4 = 3'b100;\n  parameter TCN5 = 3'b101;\n  parameter IOCLR = 3'b110;\n  parameter TUNU1 = 3'b111;\n\n  always @(*) begin\n    case (tstate)\n      TIDLE: begin\n        if (foocr_we)\n          ntstate = TCN1;\n        else\n          ntstate = TIDLE;\n        ioclrtmout = 1'b0;\n      end\n      TCN1, TCN2, TCN3, TCN4, TCN5: begin\n        if (ioclrinst || fooc2_qual)\n          ntstate = TIDLE;\n        else if (tstate == TCN5)\n          ntstate = IOCLR;\n        else\n          ntstate = tstate + 1;\n        ioclrtmout = 1'b0;\n      end\n      IOCLR: begin\n        ntstate = TIDLE;\n        ioclrtmout = 1'b1;\n      end\n      TUNU1: begin\n        ntstate = TIDLE;\n        ioclrtmout = 1'b0;\n      end\n      default: begin\n        ntstate = 3'bx;\n        ioclrtmout = 1'bx;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "fsm_",
        "module_hash": "e3c3433b19778e524bd78feb4caca74e",
        "dataset_index": 16090
      },
      "sky130_fd_sc_lp__o2bb2a_004e1c3c": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o2bb2a (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out ;\n    wire or0_out   ;\n    wire and0_out_X;\n\n    nand nand0 (nand0_out , A2_N, A1_N        );\n    or   or0   (or0_out   , B2, B1            );\n    and  and0  (and0_out_X, nand0_out, or0_out);\n    buf  buf0  (X         , and0_out_X        );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o2bb2a",
        "module_hash": "004e1c3cd06c862959fc0fa52743785e",
        "dataset_index": 16216
      },
      "carry_select_adder_1e1670e0": {
        "rtl_code": "module carry_select_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\nwire [31:0] c1, c2, p1, p2, g1, g2;\n\nassign {c2, c1} = {b[31], a[31], 1'b0};\nassign {g2, g1} = {b[31], a[31]};\nassign {p2, p1} = {b[31]^1'b1, a[31]^1'b1};\n\nwire [31:0] s1, s2, s3;\n\nassign s1 = a + b;\nassign s2 = s1 - {c1, p1};\nassign s3 = s1 - {c2, p2};\n\nassign sum = (g1 & g2) ? s3 : (g1 | g2) ? s2 : s1;\n\nendmodule\n\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\ncarry_select_adder csa(.a(a), .b(b), .sum(sum));\n\nendmodule",
        "module_name": "carry_select_adder",
        "module_hash": "1e1670e052644e2b9e04a2c72b1de571",
        "dataset_index": 8811
      },
      "adder_4bit_carry_e2af3ad4": {
        "rtl_code": "\nmodule adder_4bit_carry(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [3:0] half_sum;\nwire [3:0] full_sum;\n\n// First half adder\nassign half_sum[0] = a[0] ^ b[0];\nassign cout = a[0] & b[0];\n\n// Full adder\ngenvar i;\ngenerate\n    for (i = 1; i < 4; i = i + 1) begin : adder_loop\n        assign half_sum[i] = a[i] ^ b[i];\n        assign full_sum[i] = (a[i] & b[i]) | (a[i] & full_sum[i-1]) | (b[i] & full_sum[i-1]);\n    end\nendgenerate\n\n// Final sum\nassign sum = half_sum ^ {3'b0, cin}; // cin is added to the LSB of the sum\n\nendmodule",
        "module_name": "adder_4bit_carry",
        "module_hash": "e2af3ad40fc1ed01d4b8c9eece4e4e85",
        "dataset_index": 699
      },
      "alu_7a6ecd6a": {
        "rtl_code": "\n\nmodule alu (\n    input [15:0] x,\n    input [15:0] y,\n    input zx, nx, zy, ny, f, no,\n    \n    output [15:0] out,\n    output zr,\n    output ng\n);\n\n    reg [15:0] r_x_a;\n    reg [15:0] r_x;\n    \n    reg [15:0] r_y_a;\n    reg [15:0] r_y;\n    reg [15:0] r_out = 16'b0;\n    reg r_zr;\n    reg r_ng;\n    \n    always @ (*) begin\n\n        if (zx == 1) begin \n            r_x_a = 16'b0;      \n        end else begin\n            r_x_a = x;\n        end\n        \n        if (nx == 1) begin\n            r_x = ~r_x_a;\n        end else begin\n            r_x = r_x_a;\n        end\n        \n        \n        if (zy) begin\n            r_y_a = 1'b0;\n        end else begin\n            r_y_a = y;\n        end\n        \n        if (ny == 1) begin\n            r_y = ~r_y_a;\n        end else begin\n            r_y = r_y_a;\n        end\n        \n        if (f == 1) begin\n            r_out = r_x + r_y;\n        end else begin\n            r_out = r_x & r_y;\n        end\n        \n        if (no == 1) begin\n            r_out = ~r_out;\n        end else begin\n            r_out = r_out;\n        end\n        \n\n        if (r_out == 0) begin\n            r_zr = 1'b1;\n        end else begin\n            r_zr = 1'b0;\n        end\n        \n\n        if (r_out[15] == 1) begin\n            r_ng = 1'b1;\n        end else begin\n            r_ng = 1'b0;\n        end\n        \n    end\n    \n    assign out = r_out;\n    assign zr = r_zr;\n    assign ng = r_ng;\n    \n\nendmodule\n",
        "module_name": "alu",
        "module_hash": "7a6ecd6af7cacb61206e99075a55239b",
        "dataset_index": 21767
      },
      "fsm_4bit_binary_counter_a7955c60": {
        "rtl_code": "module fsm_4bit_binary_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  // Define the four states\n  parameter S0 = 2'b00;\n  parameter S1 = 2'b01;\n  parameter S2 = 2'b10;\n  parameter S3 = 2'b11;\n  \n  // Define the state register and initialize to S0\n  reg [1:0] state = S0;\n  \n  // Define the next state logic\n  always @ (posedge clk or posedge reset) begin\n    if (reset) begin\n      state <= S0;\n    end else begin\n      case (state)\n        S0: state <= S1;\n        S1: state <= S2;\n        S2: state <= S3;\n        S3: state <= S0;\n      endcase\n    end\n  end\n  \n  // Define the output logic\n  always @ (posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      case (state)\n        S0: count <= count + 4'b0001;\n        S1: count <= count + 4'b0001;\n        S2: count <= count + 4'b0001;\n        S3: count <= count + 4'b0001;\n      endcase\n    end\n  end\n  \nendmodule\n",
        "module_name": "fsm_4bit_binary_counter",
        "module_hash": "a7955c60962c8fd617a1d268e39a177f",
        "dataset_index": 11681
      },
      "hdmi_circle_64ab26d8": {
        "rtl_code": "\nmodule hdmi_circle(\n    input hdmi_clk,\n    input hdmi_de,\n    input hdmi_hs,\n    input hdmi_vs,\n    input [7:0] hdmi_r,\n    input [7:0] hdmi_g,\n    input [7:0] hdmi_b,\n    output hdmi_vs_out,\n    output hdmi_de_out,\n    output [7:0] hdmi_data_out\n);\n\nparameter IMG_W = 64;\nparameter IMG_H = 64;\n\n// Calculate circle parameters\nlocalparam RADIUS = IMG_W < IMG_H ? IMG_W / 2 : IMG_H / 2;\nlocalparam CENTER_X = IMG_W / 2;\nlocalparam CENTER_Y = IMG_H / 2;\n\nreg [9:0] x;\nreg [9:0] y;\nwire inside_circle;\n\ncircle circ (\n    .clk(hdmi_clk),\n    .ce(1'b1),\n    .rst(1'b0),\n    .de(hdmi_de),\n    .hsync(hdmi_hs),\n    .vsync(hdmi_vs),\n    .mask(1'b1),\n    .x(x),\n    .y(y),\n    .inside_circle(inside_circle),\n    .c_h(IMG_H),\n    .c_w(IMG_W),\n    .CENTER_X(CENTER_X),\n    .CENTER_Y(CENTER_Y),\n    .RADIUS(RADIUS)\n);\n\nreg [7:0] hdmi_r_out;\nreg [7:0] hdmi_g_out;\nreg [7:0] hdmi_b_out;\n\nalways @ (posedge hdmi_clk) begin\n    if (inside_circle) begin\n        hdmi_r_out <= 8'hFF;\n        hdmi_g_out <= 8'h00;\n        hdmi_b_out <= 8'h00;\n    end else begin\n        hdmi_r_out <= hdmi_r;\n        hdmi_g_out <= hdmi_g;\n        hdmi_b_out <= hdmi_b;\n    end\nend\n\nassign hdmi_vs_out = hdmi_vs;\nassign hdmi_de_out = hdmi_de;\nassign hdmi_data_out = {8'b0, hdmi_r_out, hdmi_g_out, hdmi_b_out};\n\nendmodule\nmodule circle(\n    input clk,\n    input ce,\n    input rst,\n    input de,\n    input hsync,\n    input vsync,\n    input mask,\n    output reg [9:0] x,\n    output reg [9:0] y,\n    output reg inside_circle,\n    input c_h,\n    input c_w,\n    input [9:0] CENTER_X,\n    input [9:0] CENTER_Y,\n    input [9:0] RADIUS\n);\n\nreg [9:0] x_count;\nreg [9:0] y_count;\n\nalways @(posedge clk) begin\n    if (ce) begin\n        x_count <= x_count + 1;\n        if (x_count == c_w) begin\n            x_count <= 0;\n            y_count <= y_count + 1;\n        end\n    end\nend\n\nalways @* begin\n    // Circle equation: (x - center_x)^2 + (y - center_y)^2 <= r^2\n    if (ce) begin\n        x = x_count;\n        y = y_count;\n        if ((x - CENTER_X)*(x - CENTER_X) + (y - CENTER_Y)*(y - CENTER_Y) <= RADIUS*RADIUS)\n            inside_circle = 1'b1;\n        else\n            inside_circle = 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "hdmi_circle",
        "module_hash": "64ab26d86322bf421452a53ba2eac56e",
        "dataset_index": 5160
      },
      "four_bit_adder_7ed9baaf": {
        "rtl_code": "module four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input CLK,\n    output reg [3:0] S,\n    output reg Cout\n);\n\nreg [4:0] sum;\n\nalways @(posedge CLK) begin\n    sum = A + B + Cin;\n    S = sum[3:0];\n    Cout = sum[4];\nend\n\nendmodule",
        "module_name": "four_bit_adder",
        "module_hash": "7ed9baaf35e2061f78fe4a86c0a9bbf3",
        "dataset_index": 12132
      },
      "ascii_6e4500c3": {
        "rtl_code": "\nmodule ascii (\n    input clk,\n    input scan_ready,\n    input [7:0] scan_code,\n    output [7:0] ascii\n);\n\n    reg [7:0] r_ascii;\n    reg [1:0] scan_ready_edge_detect = 2'b00;\n    assign ascii = r_ascii;\n    \n    reg extended = 0;\n    reg shift = 0;\n    reg [1:0] caps = 2'b00;\n    wire caps_lock;\n    \n    reg [7:0] code;\n\n\n\n    reg [7:0] key_code [2:0];\n    reg [1:0] key_mem_index = 2'b00;\n    reg [1:0] key_current_index = 2'b00;\n    reg key_clear = 0;\n    \n    reg [7:0] current_code;\n    reg [7:0] break_code;\n    reg [7:0] state_code;\n    reg [2:0] state_reg = 2'b00;\n    \n    parameter st_idle     = 3'b000;\n    parameter st_code_1   = 3'b001;\n    parameter st_code_2   = 3'b010;\n    parameter st_code_3   = 3'b011;\n    parameter st_break    = 3'b100;\n    parameter st_extended = 3'b101;\n    parameter st_ready    = 3'b110;\n\n    \n\n    assign caps_lock = caps[0]; always @(posedge clk) begin\n        scan_ready_edge_detect <= {scan_ready_edge_detect[0], scan_ready};\n    end      \n    \n\n    always @(posedge clk) begin\n        case (state_reg) \n            st_idle:\n                begin\n                    if (scan_ready_edge_detect == 2'b01) begin\n                       current_code <= scan_code;\n                       state_reg <= st_code_1;\n                    end \n                end\n            st_code_1:\n                begin\n                    state_code <= current_code;\n                    state_reg <= st_code_2;\n                end\n            st_code_2:\n                begin\n                    if (state_code == 8'hf0) begin\n                        state_reg <= st_break;\n                    end else begin\n                        state_reg <= st_code_3;\n                    end\n                end\n            st_code_3:\n                begin\n                    state_reg <= st_ready;\n                end\n            st_break:\n                begin\n                    code <= 8'h00;\n                    if (scan_ready_edge_detect == 2'b01) begin\n                       state_reg <= st_idle;\n                       break_code <= scan_code;\n                    end \n                end\n            st_extended:\n                begin\n                \n                end\n            st_ready:\n                begin\n                    code <= state_code;\n                    state_reg <= st_idle;\n                end\n            default:\n                begin\n                \n                end\n        endcase\n        \n    end\n    \n    always @(posedge clk) begin\n        if (scan_ready_edge_detect == 2'b01 && code == 8'h58) begin\n            caps <= caps + 2'b1;\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (code == 8'h12 || code == 8'h59) begin\n            shift <= 1;\n        end else if (break_code == 8'h12 || break_code == 8'h59) begin\n            shift <= 0;\n        end\n    end\n\n\n    always @(posedge clk) begin\n\n        if (extended) begin\n            case (code)\n            \n                8'h6b: r_ascii <= 8'd130; 8'h75: r_ascii <= 8'd131; 8'h74: r_ascii <= 8'd132; 8'h72: r_ascii <= 8'd133; 8'h6c: r_ascii <= 8'd134; 8'h69: r_ascii <= 8'd135; 8'h7d: r_ascii <= 8'd136; 8'h7a: r_ascii <= 8'd137; 8'h70: r_ascii <= 8'd138; 8'h71: r_ascii <= 8'd139; default: r_ascii <= 8'd0; endcase\n        end else\n        if ((shift && !caps_lock) || (caps_lock && !shift)) begin     \n            case (code)\n            \n                8'h29: r_ascii <= 8'd32; 8'h16: r_ascii <= 8'd33; 8'h52: r_ascii <= 8'd34; 8'h26: r_ascii <= 8'd35; 8'h25: r_ascii <= 8'd36; 8'h2e: r_ascii <= 8'd37; 8'h3d: r_ascii <= 8'd38; 8'h46: r_ascii <= 8'd40; 8'h45: r_ascii <= 8'd41; 8'h3e: r_ascii <= 8'd42; 8'h55: r_ascii <= 8'd43; 8'h4c: r_ascii <= 8'd58; 8'h41: r_ascii <= 8'd60; 8'h49: r_ascii <= 8'd62; 8'h4a: r_ascii <= 8'd63; 8'h1e: r_ascii <= 8'd64; 8'h1c: r_ascii <= 8'd65; 8'h32: r_ascii <= 8'd66; 8'h21: r_ascii <= 8'd67; 8'h23: r_ascii <= 8'd68; 8'h24: r_ascii <= 8'd69; 8'h2b: r_ascii <= 8'd70; 8'h34: r_ascii <= 8'd71; 8'h33: r_ascii <= 8'd72; 8'h43: r_ascii <= 8'd73; 8'h3b: r_ascii <= 8'd74; 8'h42: r_ascii <= 8'd75; 8'h4b: r_ascii <= 8'd76; 8'h3a: r_ascii <= 8'd77; 8'h31: r_ascii <= 8'd78; 8'h44: r_ascii <= 8'd79; 8'h4d: r_ascii <= 8'd80; 8'h15: r_ascii <= 8'd81; 8'h2d: r_ascii <= 8'd82; 8'h1b: r_ascii <= 8'd83; 8'h2c: r_ascii <= 8'd84; 8'h3c: r_ascii <= 8'd85; 8'h2a: r_ascii <= 8'd86; 8'h1d: r_ascii <= 8'd87; 8'h22: r_ascii <= 8'd88; 8'h35: r_ascii <= 8'd89; 8'h1a: r_ascii <= 8'd90; 8'h36: r_ascii <= 8'd94; 8'h4e: r_ascii <= 8'd95; 8'h54: r_ascii <= 8'd123; 8'h5d: r_ascii <= 8'd124; 8'h5b: r_ascii <= 8'd125; 8'h0e: r_ascii <= 8'd126; default: r_ascii <= 8'd0; endcase\n        end else begin\n            case (code)\n                8'h0d: r_ascii <= 8'd9;  8'h29: r_ascii <= 8'd32;  8'h52: r_ascii <= 8'd39;  8'h7c: r_ascii <= 8'd42;  8'h79: r_ascii <= 8'd43;  8'h41: r_ascii <= 8'd44;  8'h49: r_ascii <= 8'd46;  8'h71: r_ascii <= 8'd46;  8'h4e: r_ascii <= 8'd45;  8'h7b: r_ascii <= 8'd45;  8'h4a: r_ascii <= 8'd47;  8'h45: r_ascii <= 8'd48;  8'h70: r_ascii <= 8'd48;  8'h16: r_ascii <= 8'd49;  8'h69: r_ascii <= 8'd49;  8'h1e: r_ascii <= 8'd50;  8'h72: r_ascii <= 8'd50;  8'h26: r_ascii <= 8'd51;  8'h7a: r_ascii <= 8'd51;  8'h25: r_ascii <= 8'd52;  8'h6b: r_ascii <= 8'd52;  8'h2e: r_ascii <= 8'd53;  8'h73: r_ascii <= 8'd53;  8'h36: r_ascii <= 8'd54;  8'h74: r_ascii <= 8'd54;  8'h3d: r_ascii <= 8'd55;  8'h6c: r_ascii <= 8'd55;  8'h3e: r_ascii <= 8'd56;  8'h75: r_ascii <= 8'd56;  8'h46: r_ascii <= 8'd57;  8'h7d: r_ascii <= 8'd57;  8'h4c: r_ascii <= 8'd59;  8'h55: r_ascii <= 8'd61;  8'h54: r_ascii <= 8'd91;  8'h5d: r_ascii <= 8'd92;  8'h5b: r_ascii <= 8'd93;  8'h0e: r_ascii <= 8'd96;  8'h1c: r_ascii <= 8'd97;  8'h32: r_ascii <= 8'd98;  8'h21: r_ascii <= 8'd99;  8'h23: r_ascii <= 8'd100; 8'h24: r_ascii <= 8'd101; 8'h2b: r_ascii <= 8'd102; 8'h34: r_ascii <= 8'd103; 8'h33: r_ascii <= 8'd104; 8'h43: r_ascii <= 8'd105; 8'h3b: r_ascii <= 8'd106; 8'h42: r_ascii <= 8'd107; 8'h4b: r_ascii <= 8'd108; 8'h3a: r_ascii <= 8'd109; 8'h31: r_ascii <= 8'd110; 8'h44: r_ascii <= 8'd111; 8'h4d: r_ascii <= 8'd112; 8'h15: r_ascii <= 8'd113; 8'h2d: r_ascii <= 8'd114; 8'h1b: r_ascii <= 8'd115; 8'h2c: r_ascii <= 8'd116; 8'h3c: r_ascii <= 8'd117; 8'h2a: r_ascii <= 8'd118; 8'h1d: r_ascii <= 8'd119; 8'h22: r_ascii <= 8'd120; 8'h35: r_ascii <= 8'd121; 8'h1a: r_ascii <= 8'd122; 8'h5a: r_ascii <= 8'd128;  8'h66: r_ascii <= 8'd129;  8'h76: r_ascii <= 8'd140;  8'h05: r_ascii <= 8'd141;  8'h06: r_ascii <= 8'd142;  8'h04: r_ascii <= 8'd143;  8'h0c: r_ascii <= 8'd144;  8'h03: r_ascii <= 8'd145;  8'h0b: r_ascii <= 8'd146;  8'h83: r_ascii <= 8'd147;  8'h0a: r_ascii <= 8'd148;  8'h01: r_ascii <= 8'd149;  8'h09: r_ascii <= 8'd150;  8'h78: r_ascii <= 8'd151;  8'h07: r_ascii <= 8'd152;  default: r_ascii <= 8'd0; endcase\n        end\n        \n    end\n    \nendmodule\n",
        "module_name": "ascii",
        "module_hash": "6e4500c3c0b0ef9b19f2f68979872643",
        "dataset_index": 3872
      },
      "d_ff_en_59c8ecff": {
        "rtl_code": "\nmodule d_ff_en(clk, en, te, d, enclk);\n  input clk, en, te, d;\n  output reg enclk;\n  reg q;\n\n  always @(posedge clk) begin\n    if (en) begin\n      q <= d;\n      enclk <= 1'b1;\n    end else begin\n      enclk <= 1'b0;\n    end\n  end\n  \n  always @(posedge te) begin\n    q <= q;\n  end\n\nendmodule",
        "module_name": "d_ff_en",
        "module_hash": "59c8ecff6f574d3f26f756e332a362f8",
        "dataset_index": 2563
      },
      "reg32_f807a48e": {
        "rtl_code": "module reg32(Rout, clr, clk, write_enable, write_value);\n\tinput clr,clk, write_enable;\n\tinput [31:0] write_value;\n\toutput [31:0]Rout;\n\treg[31:0] Rout;\n\n\talways @ (posedge clk)begin\n\t\tif(clr) begin\n\t\t\tRout = 32'h00000000;\n\t\t\tend\n\t\tif(write_enable) begin\n\t\t\tRout = write_value;\n\t\t\tend\n\tend\nendmodule\n\nmodule reg32_R0(Rout, clr, clk, BA_out, write_enable, write_value);\n\tinput clr,clk, write_enable, BA_out;\n\tinput [31:0] write_value;\n\toutput [31:0]Rout;\n\treg[31:0] Rout;\n\n\talways @ (posedge clk)begin\n\t\tif(clr) begin\n\t\t\tRout = 32'h00000000;\n\t\t\tend\n\t\tif(write_enable) begin\n\t\t\tRout = write_value & (!BA_out);\n\t\t\tend\n\tend\nendmodule\n\n\nmodule reg32_MDR(Memory_output, Bus_output, Mem_RW, clr, clk, MDR_write_enable, Memory_write_enable, Memory_read_enable, Bus_input, Memory_input);\n\tinput clr,clk, Memory_write_enable, Memory_read_enable, MDR_write_enable;\n\tinput [31:0] Bus_input, Memory_input;\n\toutput [31:0]Memory_output, Bus_output;\n\toutput Mem_RW;\n\treg Mem_RW;\n\treg[31:0] Rout;\n\twire[31:0] register;\n\n\tMDMux_in input_select(Bus_input, Memory_input, Memory_read_enable, register);\n\tMDMux_out output_select(Rout, Memory_write_enable, Bus_output, Memory_output);\n\t\n\talways @ (posedge clk)begin\n\tMem_RW = MDR_write_enable & (!Memory_read_enable);\n\t\tif(clr) begin\n\t\t\tRout = 32'h00000000;\n\t\t\tend\n\t\tif(MDR_write_enable) begin\n\t\t\tRout = register;\n\t\t\tend\n\tend\nendmodule\n\nmodule reg32_MAR(Rout, clr, clk, write_enable, write_value);\n\tinput clr,clk, write_enable;\n\tinput [31:0] write_value;\n\toutput [8:0] Rout;\n\treg[31:0] value;\n\tassign Rout = value[8:0];\n\n\talways @ (posedge clk)begin\n\t\tif(clr) begin\n\t\t\tvalue = 32'h00000000;\n\t\t\tend\n\t\tif(write_enable) begin\n\t\t\tvalue = write_value;\n\t\t\tend\n\tend\nendmodule\n\nmodule MDMux_in(Bus_data, Mdata_in, Mem_read_enable, MDMux_out); input Mem_read_enable;\n\tinput[31:0] Bus_data, Mdata_in;\n\toutput[31:0] MDMux_out;\n\tassign MDMux_out = (Mem_read_enable) ? Mdata_in : Bus_data;\t\nendmodule\n\nmodule MDMux_out(MDR_data, Mem_write_enable, BusData_out, Mdata_out); \n\tinput Mem_write_enable;\n\tinput[31:0] MDR_data;\n\toutput[31:0] BusData_out, Mdata_out;\n\tassign Mdata_out = (Mem_write_enable) ? MDR_data : 0; assign BusData_out = (!Mem_write_enable) ? MDR_data : 0; endmodule\n\nmodule reg64(Rout_hi, Rout_low, clr, clk, write_enable, input_value);\n\tinput clr,clk, write_enable;\n\tinput [63:0] input_value;\n\toutput [31:0]Rout_hi, Rout_low;\n\treg[31:0] Rout_hi, Rout_low;\n\n\talways @ (posedge clk)begin\n\t\tif(write_enable == 1) begin\n\t\t\tRout_hi = input_value[63:32];\n\t\t\tRout_low = input_value[31:0];\n\t\t\tend\n\t\telse if(clr) begin\n\t\t\tRout_hi = 0;\n\t\t\tRout_low = 0;\n\t\t\tend\n\tend\n\t\nendmodule\n",
        "module_name": "reg32",
        "module_hash": "f807a48e3c6cb7d6837f174b15d92969",
        "dataset_index": 16511
      },
      "dff_chain_4312e4a2": {
        "rtl_code": "\nmodule dff_chain (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] q_temp;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q_temp <= 8'h34;\n    end else begin\n        q_temp <= {q_temp[6:0], d};\n    end\nend\n\nassign q = q_temp;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q\n);\n\nwire [7:0] dff_output;\n\ndff_chain dff_inst (\n    .clk(clk),\n    .reset(reset),\n    .d(d),\n    .q(dff_output)\n);\n\nassign q = dff_output;\n\nendmodule",
        "module_name": "dff_chain",
        "module_hash": "4312e4a2221681fef0b1cf73520850c0",
        "dataset_index": 14509
      },
      "arithmetic_9b888aa8": {
        "rtl_code": "module arithmetic (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire [1:0] op,\n    output reg [15:0] result\n);\n\nalways @* begin\n    case (op)\n        2'b00: result = a + b; // addition\n        2'b01: result = a - b; // subtraction\n        2'b10: result = a * b; // multiplication\n        2'b11: result = a / b; // division\n    endcase\nend\n\nendmodule",
        "module_name": "arithmetic",
        "module_hash": "9b888aa8ab60e7196001367dff99590d",
        "dataset_index": 16623
      },
      "dual_edge_triggered_ff_a8fbe016": {
        "rtl_code": "module dual_edge_triggered_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg d1, d2;\nreg q1, q2;\n\n// Pipeline stage 1\nalways @(posedge clk) begin\n    d1 <= d;\n    q1 <= q2;\nend\n\n// Pipeline stage 2\nalways @(negedge clk) begin\n    d2 <= q1;\n    q2 <= d1 ^ q1;\nend\n\nassign q = q2;\n\nendmodule",
        "module_name": "dual_edge_triggered_ff",
        "module_hash": "a8fbe0166f2ea446e2ce84f2bd1c3565",
        "dataset_index": 17331
      },
      "counter_display_f1211ba5": {
        "rtl_code": "\nmodule counter_display (\n    input clk,\n    input reset,               // Synchronous active-high reset\n    input direction,           // Input to control the count direction\n    output [6:0] seg,          // 7-segment display output\n    output reg [3:0] cnt           // 4-bit counter output\n);\n\n  // Declare intermediate signals\n  wire [7:0] out;\n  wire cnt_up, cnt_down;    // Control signals for counter direction\n\n  // Instantiate splitter and XOR modules\n  splitter_module splitter(.in({cnt, 4'b0}), .out(out));\n  xor_module xor0(.a(cnt[0]), .b(cnt[1]), .out_ff(cnt_up));\n  xor_module xor1(.a(cnt[2]), .b(cnt[3]), .out_ff(cnt_down));\n\n  // Assign segment outputs\n  assign seg = out;\n\n  // Counter logic\n  always @(posedge clk) begin\n    if (reset) begin\n      cnt <= 4'b0000;\n    end else if (direction) begin\n      // Count up\n      cnt <= cnt + 1'b1;\n    end else begin\n      // Count down\n      cnt <= cnt - 1'b1;\n    end\n  end\n\nendmodule\n\nmodule splitter_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n  assign out = in;\n\nendmodule\n\nmodule xor_module (\n    input a,\n    input b,\n    output out_ff\n);\n\n  assign out_ff = a ^ b; // XOR operation\n\nendmodule\n",
        "module_name": "counter_display",
        "module_hash": "f1211ba52c811ba427b3424cfe04b765",
        "dataset_index": 13927
      },
      "EFX_LUT4_c6c2554f": {
        "rtl_code": "module EFX_LUT4(\n   output O, \n   input I0,\n   input I1,\n   input I2,\n   input I3\n);\n\tparameter LUTMASK = 16'h0000;\n\n\twire [7:0] s3 = I3 ? LUTMASK[15:8] : LUTMASK[7:0];\n\twire [3:0] s2 = I2 ?      s3[ 7:4] :      s3[3:0];\n\twire [1:0] s1 = I1 ?      s2[ 3:2] :      s2[1:0];\n\tassign O = I0 ? s1[1] : s1[0];\t   \nendmodule\n\nmodule EFX_ADD(\n   output O,\n   output CO,\n   input I0,\n   input I1,\n   input CI\n);\n   parameter I0_POLARITY   = 1;\n   parameter I1_POLARITY   = 1;\n\n   wire i0;\n   wire i1;\n\n   assign i0 = I0_POLARITY ? I0 : ~I0;\n   assign i1 = I1_POLARITY ? I1 : ~I1;\n\n   assign {CO, O} = i0 + i1 + CI;\nendmodule\n\nmodule EFX_FF(\n   output reg Q,\n   input D,\n   input CE,\n   \n   input CLK,\n   input SR\n);\n   parameter CLK_POLARITY = 1;\n   parameter CE_POLARITY = 1;\n   parameter SR_POLARITY = 1;\n   parameter SR_SYNC = 0;\n   parameter SR_VALUE = 0;\n   parameter SR_SYNC_PRIORITY = 0;\n   parameter D_POLARITY = 1;\n\n   wire clk;\n   wire ce;\n   wire sr;\n   wire d;\n   wire prio;\n   wire sync;\n   wire async;\n\n   assign clk = CLK_POLARITY ? CLK : ~CLK;\n   assign ce = CE_POLARITY ? CE : ~CE;\n   assign sr = SR_POLARITY ? SR : ~SR;\n   assign d = D_POLARITY ? D : ~D;\n\n\tinitial Q = 1'b0;\n\n   generate\n   \tif (SR_SYNC == 1) \n      begin\n         if (SR_SYNC_PRIORITY == 1) \n         begin\n            always @(posedge clk)\n               if (sr)\n                  Q <= SR_VALUE;\n               else if (ce)\n                  Q <= d;\n         end\n         else\n         begin\n            always @(posedge clk)\n               if (ce)\n               begin\n                  if (sr)\n                     Q <= SR_VALUE;\n                  else\n                     Q <= d;\n               end\n         end\n      end\n      else\n      begin\n         always @(posedge clk or posedge sr)\n            if (sr)\n               Q <= SR_VALUE;\n            else if (ce)\n               Q <= d;\n         \n      end\n   endgenerate\nendmodule\n\nmodule EFX_GBUFCE(\n   input CE,\n   input I,\n   \n   output O\n);\n   parameter CE_POLARITY = 1'b1;\n\n   wire ce;\n   assign ce = CE_POLARITY ? CE : ~CE;\n   \n   assign O = I & ce;\n   \nendmodule\n\nmodule EFX_RAM_5K(\n   input [WRITE_WIDTH-1:0] WDATA,\n   input [WRITE_ADDR_WIDTH-1:0] WADDR,\n   input WE, \n   \n   input WCLK,\n   input WCLKE, \n   output [READ_WIDTH-1:0] RDATA, \n   input [READ_ADDR_WIDTH-1:0] RADDR,\n   input RE, \n   \n   input RCLK\n);\n   parameter READ_WIDTH = 20;\n   parameter WRITE_WIDTH = 20;\n   parameter OUTPUT_REG = 1'b0;\n   parameter RCLK_POLARITY  = 1'b1;\n   parameter RE_POLARITY    = 1'b1;\n   parameter WCLK_POLARITY  = 1'b1;\n   parameter WE_POLARITY    = 1'b1;\n   parameter WCLKE_POLARITY = 1'b1;\n   parameter WRITE_MODE = \"READ_FIRST\";\n   parameter INIT_0 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_1 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_2 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_3 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_4 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_5 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_6 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_7 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_8 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_9 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_10 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_11 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_12 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n   parameter INIT_13 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\n   localparam READ_ADDR_WIDTH = \n\t\t\t    (READ_WIDTH == 16) ? 8 :  (READ_WIDTH == 8)  ? 9 :  (READ_WIDTH == 4)  ? 10 : (READ_WIDTH == 2)  ? 11 : (READ_WIDTH == 1)  ? 12 : (READ_WIDTH == 20) ? 8 :  (READ_WIDTH == 10) ? 9 :  (READ_WIDTH == 5)  ? 10 : -1; localparam WRITE_ADDR_WIDTH = \n\t\t\t    (WRITE_WIDTH == 16) ? 8 :  (WRITE_WIDTH == 8)  ? 9 :  (WRITE_WIDTH == 4)  ? 10 : (WRITE_WIDTH == 2)  ? 11 : (WRITE_WIDTH == 1)  ? 12 : (WRITE_WIDTH == 20) ? 8 :  (WRITE_WIDTH == 10) ? 9 :  (WRITE_WIDTH == 5)  ? 10 : -1; endmodule\n",
        "module_name": "EFX_LUT4",
        "module_hash": "c6c2554f1ae7616702f456c028ceb717",
        "dataset_index": 25304
      },
      "top__8e874bba": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] a,\n    input [7:0] b,\n    input select, // Select input to choose between adder1 and adder2\n    output [7:0] out\n);\n\nreg [7:0] sum1, sum2;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        sum1 <= 8'b0;\n        sum2 <= 8'b0;\n    end else begin\n        if (select) begin\n            sum1 <= a + b;\n        end else begin\n            sum2 <= a + b;\n        end\n    end\nend\n\nassign out = select ? sum1 : sum2;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "8e874bba92e067acbb743ea4adb7b414",
        "dataset_index": 16233
      },
      "sky130_fd_sc_ls__a21oi_a2df5a12": {
        "rtl_code": "module sky130_fd_sc_ls__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire n1, n2, n3, n4, n5, n6, n7;\n\n    not (n1, A1);\n    not (n2, A2);\n    not (n3, B1);\n\n    and (n4, n1, n2);\n    and (n5, n1, B1);\n    and (n6, A2, n3);\n    and (n7, n6, n3);\n\n    or (Y, n4, n5, n7);\n\nendmodule",
        "module_name": "sky130_fd_sc_ls__a21oi",
        "module_hash": "a2df5a122313107f5ce5a4106145884d",
        "dataset_index": 3256
      },
      "sky130_fd_sc_hd__a31o_633618dc": {
        "rtl_code": "module sky130_fd_sc_hd__a31o (\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    output X\n);\n\n    assign X = (A1 === 1'b1 && A2 === 1'b1 && A3 === 1'b1 && B1 === 1'b1) ? 1'b1 :\n               (A1 === 1'b0 && A2 === 1'b0 && A3 === 1'b0 && B1 === 1'b0) ? 1'b0 :\n               1'bx;\n\nendmodule",
        "module_name": "sky130_fd_sc_hd__a31o",
        "module_hash": "633618dcf0055a1906dd2e9d9427f7cd",
        "dataset_index": 1317
      },
      "watchdog_timer_f44e6d4a": {
        "rtl_code": "module watchdog_timer (\n  input clk,\n  input rst,\n  input [31:0] timeout,\n  output reg t\n);\n\n  reg [31:0] counter;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      counter <= 0;\n      t <= 0;\n    end\n    else begin\n      counter <= counter + 1;\n      if (counter == timeout) begin\n        t <= 1;\n      end\n      else begin\n        t <= 0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "watchdog_timer",
        "module_hash": "f44e6d4a680a955ea26663ce033fa0c4",
        "dataset_index": 21351
      },
      "Gato_FSM_9b83fe40": {
        "rtl_code": "\n\nmodule Gato_FSM(\n\tclk,\n\treset,\n\tstate, \n\t\n\tp1_mm,\n\tp2_mm,\n\t\n\tp1_tie, \n\tp1_loss,\n\tp1_win,\n\t\n\tp2_tie, \n\tp2_loss,\n\tp2_win,\n\t\n\tverifica_status,\n\t\n\tturno_p1,\n\tturno_p2,\n\t\n\twin_game,\n\tloss_game,\n\ttie_game\n\t);\n\tinput clk, reset;\n\tinput p1_mm, p2_mm;\n\t\n\tinput p1_tie, p1_loss, p1_win, p2_tie, p2_loss, p2_win;\n\t\n\toutput reg turno_p1, turno_p2;\n\t\n\toutput reg verifica_status;\n\t\n\toutput reg win_game, loss_game, tie_game;\n\t\t\n\toutput [3:0] state;\n\treg [3:0] state, nextState;\n\t\n\tparameter P1_Move = 0;\n\tparameter P1_Status = 1;\n\tparameter P2_Move = 2;\n\tparameter P2_Status = 3;\n\tparameter Win = 4;\n\tparameter Tie = 5;\n\tparameter Loss = 6;\n\t\n\tinitial turno_p1 <= 1'b1;\n\tinitial turno_p2 <= 1'b0;\n\t\n\talways @(posedge clk or posedge reset)\n\t\tbegin\n\t\tif (reset)\n\t\t\tstate <= P1_Move;\n\t\telse\n\t\t\tstate <= nextState;\n\t\tend\n\t\n\talways @(state or p1_mm or p2_mm or p1_win or p1_loss or p1_tie or p2_win or p2_loss or p2_tie)\n\t\tbegin\n\t\t\n\t\tnextState = 3'bxxx;\n\t\t\n\t\tcase(state)\n\t\t\t\n\t\t\tP1_Move:\n\t\t\t\tbegin\n\t\t\t\tverifica_status <= 1'b0;\n\t\t\t\tturno_p1 <= 1'b1;\n\t\t\t\tturno_p2 <= 1'b0;\n\t\t\t\tif (p1_mm == 1'b0)\n\t\t\t\t\tnextState = P1_Move;\n\t\t\t\telse if (p1_mm == 1'b1)\n\t\t\t\t\tnextState = P1_Status;\n\t\t\t\tend\n\t\t\t\n\t\t\tP1_Status:\n\t\t\t\tbegin\n\t\t\t\tverifica_status <= 1'b1;\n\t\t\t\tturno_p1 <= 1'b0;\n\t\t\t\tturno_p2 <= 1'b1;\n\t\t\t\tif (p1_tie == 1'b1 & p1_loss == 1'b0 & p1_win == 1'b0)\n\t\t\t\t\tnextState = Tie;\n\t\t\t\telse if (p1_win == 1'b1 & p1_tie == 1'b0 & p1_loss == 1'b0)\n\t\t\t\t\tnextState = Loss;\n\t\t\t\telse if (p2_mm == 1'b0)\n\t\t\t\t\tnextState = P2_Move;\n\t\t\t\tend\n\t\t\t\n\t\t\tP2_Move:\n\t\t\t\tbegin\n\t\t\t\tverifica_status <= 1'b0;\n\t\t\t\tturno_p1 <= 1'b0;\n\t\t\t\tturno_p2 <= 1'b1;\n\t\t\t\tif (p2_mm == 1'b0)\n\t\t\t\t\tnextState = P2_Move;\n\t\t\t\telse if (p2_mm == 1'b1)\n\t\t\t\t\tnextState = P2_Status;\n\t\t\t\tend\n\t\t\t\n\t\t\tP2_Status:\n\t\t\t\tbegin\n\t\t\t\tverifica_status <= 1'b1;\n\t\t\t\tturno_p1 <= 1'b1;\n\t\t\t\tturno_p2 <= 1'b0;\n\t\t\t\tif (p2_tie == 1'b1 & p2_loss == 1'b0 & p2_win == 1'b0)\n\t\t\t\t\tnextState = Tie;\n\t\t\t\telse if (p2_win == 1'b1 & p2_tie == 1'b0 & p2_loss == 1'b0)\n\t\t\t\t\tnextState = Win;\n\t\t\t\telse if (p1_mm == 1'b0)\n\t\t\t\t\tnextState = P1_Move;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tWin:\n\t\t\t\tbegin\n\t\t\t\twin_game <= 1'b1;\n\t\t\t\tnextState = Win;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tTie:\n\t\t\t\tbegin\n\t\t\t\ttie_game <= 1'b1;\n\t\t\t\tnextState = Tie;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tLoss:\n\t\t\t\tbegin\n\t\t\t\tloss_game <= 1'b1;\n\t\t\t\tnextState = Loss;\n\t\t\t\tend\n\t\t\t\n\t\t\tdefault: nextState = P1_Move;\n\t\t\n\t\tendcase\n\t\t\t\n\tend\n\t\nendmodule\n",
        "module_name": "Gato_FSM",
        "module_hash": "9b83fe403d6a96f815b52ca196e76bb5",
        "dataset_index": 8016
      },
      "sky130_fd_sc_hd__nand4b_5c013ccd": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nand4b (\n    Y  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N              );\n    nand nand0 (nand0_out_Y, D, C, B, not0_out);\n    buf  buf0  (Y          , nand0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nand4b",
        "module_hash": "5c013ccd9451f2a16265d88c78beb931",
        "dataset_index": 11105
      },
      "EtherCAT_slave #_4f5f4ba4": {
        "rtl_code": "module EtherCAT_slave #(\n    parameter n = 8 \n)(\n    input [n-1:0] in_receive,\n    input clk,\n    input rst,\n    output reg [n-1:0] out_send\n);\n\n// Example data processing in the EtherCAT slave\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out_send <= 0;\n    end else begin\n        out_send <= in_receive; \n    end\nend\n\nendmodule\n",
        "module_name": "EtherCAT_slave #",
        "module_hash": "4f5f4ba4ad2cf7fededa1e084a6b88b6",
        "dataset_index": 53
      },
      "crc_ccitt_976f1341": {
        "rtl_code": "module crc_ccitt (\n    input [15:0] data_in,\n    input wire clk,\n    output wire [7:0] crc_out\n);\n\nreg [15:0] shift_reg;\nreg [7:0] crc_reg;\n\nalways @(*) begin\n    shift_reg[15:0] = {shift_reg[14:0], data_in[15:0]};\nend\n\nalways @(posedge clk) begin\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[15] ? 8'h00 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[14] ? 8'h10 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[13] ? 8'h20 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[12] ? 8'h30 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[11] ? 8'h40 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[10] ? 8'h50 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[9] ? 8'h60 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[8] ? 8'h70 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[7] ? 8'h80 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[6] ? 8'h90 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[5] ? 8'ha0 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[4] ? 8'hb0 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[3] ? 8'hc0 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[2] ? 8'hd0 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[1] ? 8'he0 : 8'h00);\n    crc_reg[7:0] = crc_reg[7:0] ^ (shift_reg[0] ? 8'hf0 : 8'h00);\n    \n    if (crc_reg[7]) begin\n        crc_reg[6:0] = (crc_reg[6:0] << 1) ^ 8'h07;\n    end else begin\n        crc_reg[6:0] = crc_reg[6:0] << 1;\n    end\nend\n\nassign crc_out = crc_reg[7:0];\n\nendmodule",
        "module_name": "crc_ccitt",
        "module_hash": "976f1341fef17ad9e821254b4646f218",
        "dataset_index": 2540
      },
      "digital_clock_3d253fd5": {
        "rtl_code": "\nmodule digital_clock(clk, reset, hours, minutes, seg, an);\n\n    parameter CLK_FREQ = 50_000_000; // 50 MHz clock frequency\n    parameter MIN_FREQ = 60; // 60 seconds in a minute\n    parameter HOUR_FREQ = 24; // 24 hours in a day\n    parameter BCD_WIDTH = 5; // BCD format is 5 bits wide\n    parameter SEG_WIDTH = 7; // 7 segments in a seven-segment display\n    parameter DISP_WIDTH = 4; // 4 seven-segment displays\n\n    input clk;\n    input reset;\n    input [BCD_WIDTH-1:0] hours;\n    input [BCD_WIDTH-1:0] minutes;\n    output reg [SEG_WIDTH*DISP_WIDTH-1:0] seg;\n    output reg [DISP_WIDTH-1:0] an;\n\n    reg [BCD_WIDTH-1:0] hours_reg;\n    reg [BCD_WIDTH-1:0] minutes_reg; // reduced to 5 bit to hold the carry bit\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // reset to 00:00:00\n            hours_reg <= 5'b00000;\n            minutes_reg <= 5'b00000;\n            seg <= {28{1'b0}};\n            an <= 4'b1111;\n        end else begin\n            // update time every minute\n            minutes_reg <= minutes_reg + 1'b1;\n            if (minutes_reg[BCD_WIDTH-1:0] == 5'b0101_10) begin // 60 in BCD\n                minutes_reg <= 5'b00000;\n                hours_reg <= hours_reg + 1'b1;\n                if (hours_reg[BCD_WIDTH-1:0] == 5'd24) begin // 24 in BCD\n                    hours_reg <= 5'b00000;\n                end\n            end\n\n            // update display\n            case (an)\n                4'b1110: seg <= {7'b1111110, 7'b0000000, 7'b0000000, 7'b0000000}; // right-most display\n                4'b1101: seg <= {7'b1111110, 7'b1111110, 7'b0000000, 7'b0000000}; // second-right-most display\n                4'b1011: seg <= {7'b1111110, 7'b1111110, 7'b1111110, 7'b0000000}; // second-left-most display\n                4'b0111: seg <= {7'b1111110, 7'b1111110, 7'b1111110, 7'b1111110}; // left-most display\n                default: seg <= {28{1'b0}};\n            endcase\n\n            // set active display\n            case (an)\n                4'b1110: an <= 4'b1101;\n                4'b1101: an <= 4'b1011;\n                4'b1011: an <= 4'b0111;\n                4'b0111: an <= 4'b1110;\n                default: an <= 4'b1110;\n            endcase\n        end\n    end\n\nendmodule",
        "module_name": "digital_clock",
        "module_hash": "3d253fd549a5fa88aad533b30536a36a",
        "dataset_index": 5336
      },
      "top__099017f9": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [2:0] sel, // Select inputs for the multiplexer\n    input [3:0] data, // Data inputs for the multiplexer\n    output q, // Output from the flip-flop\n    output [3:0] mux_out, // Output from the multiplexer\n    output final_output // Output from the additive functional module\n);\n\n    // 3-input, 4-output multiplexer\n    mux3to4 mux_inst (\n        .sel(sel),\n        .data_in(data),\n        .data_out(mux_out)\n    );\n\n    // Dual-edge triggered flip-flop\n    reg [1:0] count;\n    always @(posedge clk, negedge reset) begin\n        if (reset == 0) begin\n            count <= 2'b00;\n        end else begin\n            count <= count + 1;\n        end\n    end\n    assign q = count[1];\n\n    // Additive functional module\n    assign final_output = (count >= mux_out) ? 1'b1 : 1'b0;\n\nendmodule\n\n// 3-input, 4-output multiplexer\nmodule mux3to4 (\n    input [2:0] sel,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n    always @(*) begin\n        case (sel)\n            3'b000: data_out = data_in[0];\n            3'b001: data_out = data_in[1];\n            3'b010: data_out = data_in[2];\n            3'b011: data_out = data_in[3];\n            3'b100: data_out = data_in[0];\n            3'b101: data_out = data_in[1];\n            3'b110: data_out = data_in[2];\n            3'b111: data_out = data_in[3];\n        endcase\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "099017f909ba33cdd2f090a46edc938e",
        "dataset_index": 10118
      },
      "bmu_d1a2313a": {
        "rtl_code": "module bmu (cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7);\n\n   // outputs\n   output [1:0] bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;\n\n   // inputs\n   input  \tcx0, cx1;\n\n   // registers\n   reg [1:0] \tbm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;\n\n   always@ (cx0 or cx1)\n\t begin\n\t    if (cx0==0 && cx1==0)\n\t      begin\n\t        bm0 <= 2'd0; // this is going from 00 to 00\n\t    \tbm1 <= 2'd2; // this is going from 00 to 10\n\t   \t\tbm2 <= 2'd2; // this is going from 01 to 00\n\t    \tbm3 <= 2'd0; // this is going from 01 to 10\n\t    \tbm4 <= 2'd1; // this is going from 10 to 01\n\t    \tbm5 <= 2'd1; // this is going from 10 to 11\n\t    \tbm6 <= 2'd1; // this is going from 11 to 01\n\t    \tbm7 <= 2'd1; // this is going from 11 to 11\n\t      end\n\t    else if (cx0==0 && cx1==1)\n\t      begin\n\t        bm0 <= 2'd1; // this is going from 00 to 00\n\t    \tbm1 <= 2'd1; // this is going from 00 to 10\n\t   \t\tbm2 <= 2'd1; // this is going from 01 to 00\n\t    \tbm3 <= 2'd1; // this is going from 01 to 10\n\t    \tbm4 <= 2'd2; // this is going from 10 to 01\n\t    \tbm5 <= 2'd0; // this is going from 10 to 11\n\t    \tbm6 <= 2'd0; // this is going from 11 to 01\n\t    \tbm7 <= 2'd2; // this is going from 11 to 11\n\t      end\n\t    else if (cx0==1 && cx1==0)\n\t      begin\n\t        bm0 <= 2'd1; // this is going from 00 to 00\n\t    \tbm1 <= 2'd1; // this is going from 00 to 10\n\t   \t\tbm2 <= 2'd1; // this is going from 01 to 00\n\t    \tbm3 <= 2'd1; // this is going from 01 to 10\n\t    \tbm4 <= 2'd0; // this is going from 10 to 01\n\t    \tbm5 <= 2'd2; // this is going from 10 to 11\n\t    \tbm6 <= 2'd2; // this is going from 11 to 01\n\t    \tbm7 <= 2'd0; // this is going from 11 to 11\n\t      end\n\t    else // if (cx0==1 && cx1==1)\n\t      begin\n\t        bm0 <= 2'd2; // this is going from 00 to 00\n\t    \tbm1 <= 2'd0; // this is going from 00 to 10\n\t   \t\tbm2 <= 2'd0; // this is going from 01 to 00\n\t    \tbm3 <= 2'd2; // this is going from 01 to 10\n\t    \tbm4 <= 2'd1; // this is going from 10 to 01\n\t    \tbm5 <= 2'd1; // this is going from 10 to 11\n\t    \tbm6 <= 2'd1; // this is going from 11 to 01\n\t    \tbm7 <= 2'd1; // this is going from 11 to 11\n\t      end\n\n\t end // always @ (posedge clk)\nendmodule",
        "module_name": "bmu",
        "module_hash": "d1a2313a278bbb91dc65b1d5620ac7ef",
        "dataset_index": 13723
      },
      "mux_2_1_syncreset_c0e9ab3a": {
        "rtl_code": "\nmodule mux_2_1_syncreset(\n    input clk,\n    input rst,\n    input sel,\n    input [31:0] in1,\n    input [31:0] in2,\n    output reg [31:0] out\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        out <= 0;\n    end else begin\n        if (sel) begin\n            out <= in1;\n        end else begin\n            out <= in2;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "mux_2_1_syncreset",
        "module_hash": "c0e9ab3ab94bc7875317d6bdfaecc099",
        "dataset_index": 13872
      },
      "CRC_serial_m_lfs_XOR_a8e009d7": {
        "rtl_code": "\nmodule CRC_serial_m_lfs_XOR\n#(\n\tparameter\tHASH_LENGTH = 64\n)\n(\n\ti_message     ,  \n\ti_cur_parity  ,  \n\to_next_parity\n);\n\tinput\t\t\t\t\t\ti_message    ;\n\tinput\t[HASH_LENGTH-1:0]\ti_cur_parity  ;\n\toutput\t[HASH_LENGTH-1:0]\to_next_parity ;\n\t\n\tlocalparam\t[0:64]\tHASH_VALUE\t=\t65'b11001001011011000101011110010101110101111000011100001111010000101;\n\t\n\twire\tw_feedback_term;\n\t\n\tassign\tw_feedback_term\t=\ti_message ^ i_cur_parity[HASH_LENGTH-1];\n\t\n\tassign\to_next_parity[0]\t=\tw_feedback_term;\n\t\n\tgenvar\ti;\n\tgenerate\n\t\tfor (i=1; i<HASH_LENGTH; i=i+1)\n\t\tbegin: linear_function\n\t\t\tif (HASH_VALUE[i] == 1)\n\t\t\t\tassign\to_next_parity[i] = i_cur_parity[i-1] ^ w_feedback_term;\n\t\t\telse\n\t\t\t\tassign\to_next_parity[i] = i_cur_parity[i-1];\n\t\tend\n\tendgenerate\n\t\nendmodule",
        "module_name": "CRC_serial_m_lfs_XOR",
        "module_hash": "a8e009d78ccedc6b6d239e7530ef72de",
        "dataset_index": 25546
      },
      "comparator_decoder_19c11efe": {
        "rtl_code": "\nmodule comparator_decoder (\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] sel,\n    input mode,\n    input wire clk,\n    input wire reset,\n    output reg [15:0] out\n);\n\n    wire eq;\n    wire gt;\n    wire lt;\n\n    comparator_16bit cmp (\n        .a(a),\n        .b(b),\n        .eq(eq),\n        .gt(gt),\n        .lt(lt)\n    );\n\n    wire [15:0] decoder_out;\n    assign decoder_out = {3'b000, eq, gt, lt};\n\n    wire [15:0] reg_in;\n    assign reg_in = (mode == 0) ? a : b;\n\n    reg [15:0] reg_out;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            reg_out <= 16'b0;\n        end else if (decoder_out[sel] == 1) begin\n            reg_out <= reg_in;\n        end\n    end\n\n    always @* begin\n        if (decoder_out[sel] == 1) begin\n            out <= reg_out;\n        end else begin\n            out <= {1'b0, eq, gt, lt}; //added the missing driver\n        end\n    end\n\nendmodule\nmodule comparator_16bit (\n    input [15:0] a,\n    input [15:0] b,\n    output reg eq,\n    output reg gt,\n    output reg lt\n);\n\n    always @* begin\n        eq = (a == b);\n        gt = (a > b);\n        lt = (a < b);\n    end\n\nendmodule",
        "module_name": "comparator_decoder",
        "module_hash": "19c11efeecd5834c9d6179e202bff2e0",
        "dataset_index": 11126
      },
      "mux_2to1_5fa7fd20": {
        "rtl_code": "module mux_2to1 (\n    input A,\n    input B,\n    input sel,\n    output Y\n);\n\n    assign Y = (!sel & A) | (sel & B);\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "5fa7fd2039f09178323fc3c09d7b12cf",
        "dataset_index": 20788
      },
      "altera_onchip_flash_address_range_check_96936f4a": {
        "rtl_code": "\n\nmodule altera_onchip_flash_address_range_check (\n    address,\n    is_addr_within_valid_range\n);\n\n    parameter FLASH_ADDR_WIDTH = 23;\n    parameter MIN_VALID_ADDR = 1;\n    parameter MAX_VALID_ADDR = 1;\n\n    input [FLASH_ADDR_WIDTH-1:0] address;\n    output is_addr_within_valid_range;\n    \n    assign is_addr_within_valid_range = (address >= MIN_VALID_ADDR) && (address <= MAX_VALID_ADDR);\n\nendmodule\n\n\nmodule altera_onchip_flash_address_write_protection_check (\n    use_sector_addr,\n    address,\n    write_protection_mode,\n    is_addr_writable\n);\n\n    parameter FLASH_ADDR_WIDTH = 23;\n    parameter SECTOR1_START_ADDR = 1;\n    parameter SECTOR1_END_ADDR = 1;\n    parameter SECTOR2_START_ADDR = 1;\n    parameter SECTOR2_END_ADDR = 1;\n    parameter SECTOR3_START_ADDR = 1;\n    parameter SECTOR3_END_ADDR = 1;\n    parameter SECTOR4_START_ADDR = 1;\n    parameter SECTOR4_END_ADDR = 1;\n    parameter SECTOR5_START_ADDR = 1;\n    parameter SECTOR5_END_ADDR = 1;\n    parameter SECTOR_READ_PROTECTION_MODE = 5'b11111;\n\n    input use_sector_addr;\n    input [FLASH_ADDR_WIDTH-1:0] address;\n    input [4:0] write_protection_mode;\n    output is_addr_writable;\n\n    wire is_sector1_addr;\n    wire is_sector2_addr;\n    wire is_sector3_addr;\n    wire is_sector4_addr;\n    wire is_sector5_addr;    \n    wire is_sector1_writable;\n    wire is_sector2_writable;\n    wire is_sector3_writable;\n    wire is_sector4_writable;\n    wire is_sector5_writable;\n    \n    assign is_sector1_addr = (use_sector_addr) ? (address == 1) : ((address >= SECTOR1_START_ADDR) && (address <= SECTOR1_END_ADDR));\n    assign is_sector2_addr = (use_sector_addr) ? (address == 2) : ((address >= SECTOR2_START_ADDR) && (address <= SECTOR2_END_ADDR));\n    assign is_sector3_addr = (use_sector_addr) ? (address == 3) : ((address >= SECTOR3_START_ADDR) && (address <= SECTOR3_END_ADDR));\n    assign is_sector4_addr = (use_sector_addr) ? (address == 4) : ((address >= SECTOR4_START_ADDR) && (address <= SECTOR4_END_ADDR));\n    assign is_sector5_addr = (use_sector_addr) ? (address == 5) : ((address >= SECTOR5_START_ADDR) && (address <= SECTOR5_END_ADDR));\n    assign is_sector1_writable = ~(write_protection_mode[0] || SECTOR_READ_PROTECTION_MODE[0]);\n    assign is_sector2_writable = ~(write_protection_mode[1] || SECTOR_READ_PROTECTION_MODE[1]);\n    assign is_sector3_writable = ~(write_protection_mode[2] || SECTOR_READ_PROTECTION_MODE[2]);\n    assign is_sector4_writable = ~(write_protection_mode[3] || SECTOR_READ_PROTECTION_MODE[3]);\n    assign is_sector5_writable = ~(write_protection_mode[4] || SECTOR_READ_PROTECTION_MODE[4]);\n    assign is_addr_writable = ((is_sector1_writable && is_sector1_addr) ||\n                               (is_sector2_writable && is_sector2_addr) ||\n                               (is_sector3_writable && is_sector3_addr) ||\n                               (is_sector4_writable && is_sector4_addr) ||\n                               (is_sector5_writable && is_sector5_addr));\n\nendmodule\n\nmodule altera_onchip_flash_s_address_write_protection_check (\n    address,\n    is_sector1_writable,\n    is_sector2_writable,\n    is_sector3_writable,\n    is_sector4_writable,\n    is_sector5_writable,\n    is_addr_writable\n);\n\n    input [2:0] address;\n    input is_sector1_writable;\n    input is_sector2_writable;\n    input is_sector3_writable;\n    input is_sector4_writable;\n    input is_sector5_writable;\n    output is_addr_writable;\n\n    wire is_sector1_addr;\n    wire is_sector2_addr;\n    wire is_sector3_addr;\n    wire is_sector4_addr;\n    wire is_sector5_addr;\n\n    assign is_sector1_addr = (address == 1);\n    assign is_sector2_addr = (address == 2);\n    assign is_sector3_addr = (address == 3);\n    assign is_sector4_addr = (address == 4);\n    assign is_sector5_addr = (address == 5);\n\n    assign is_addr_writable = ((is_sector1_writable && is_sector1_addr) ||\n                               (is_sector2_writable && is_sector2_addr) ||\n                               (is_sector3_writable && is_sector3_addr) ||\n                               (is_sector4_writable && is_sector4_addr) ||\n                               (is_sector5_writable && is_sector5_addr));\n\nendmodule\n\nmodule altera_onchip_flash_a_address_write_protection_check (\n    address,\n    is_sector1_writable,\n    is_sector2_writable,\n    is_sector3_writable,\n    is_sector4_writable,\n    is_sector5_writable,\n    is_addr_writable\n);\n\n    parameter FLASH_ADDR_WIDTH = 23;\n    parameter SECTOR1_START_ADDR = 1;\n    parameter SECTOR1_END_ADDR = 1;\n    parameter SECTOR2_START_ADDR = 1;\n    parameter SECTOR2_END_ADDR = 1;\n    parameter SECTOR3_START_ADDR = 1;\n    parameter SECTOR3_END_ADDR = 1;\n    parameter SECTOR4_START_ADDR = 1;\n    parameter SECTOR4_END_ADDR = 1;\n    parameter SECTOR5_START_ADDR = 1;\n    parameter SECTOR5_END_ADDR = 1;\n\n    input [FLASH_ADDR_WIDTH-1:0] address;\n    input is_sector1_writable;\n    input is_sector2_writable;\n    input is_sector3_writable;\n    input is_sector4_writable;\n    input is_sector5_writable;\n    output is_addr_writable;\n\n    wire is_sector1_addr;\n    wire is_sector2_addr;\n    wire is_sector3_addr;\n    wire is_sector4_addr;\n    wire is_sector5_addr;\n\n    assign is_sector1_addr = ((address >= SECTOR1_START_ADDR) && (address <= SECTOR1_END_ADDR));\n    assign is_sector2_addr = ((address >= SECTOR2_START_ADDR) && (address <= SECTOR2_END_ADDR));\n    assign is_sector3_addr = ((address >= SECTOR3_START_ADDR) && (address <= SECTOR3_END_ADDR));\n    assign is_sector4_addr = ((address >= SECTOR4_START_ADDR) && (address <= SECTOR4_END_ADDR));\n    assign is_sector5_addr = ((address >= SECTOR5_START_ADDR) && (address <= SECTOR5_END_ADDR));\n\n    assign is_addr_writable = ((is_sector1_writable && is_sector1_addr) ||\n                               (is_sector2_writable && is_sector2_addr) ||\n                               (is_sector3_writable && is_sector3_addr) ||\n                               (is_sector4_writable && is_sector4_addr) ||\n                               (is_sector5_writable && is_sector5_addr));\n\nendmodule\n\nmodule altera_onchip_flash_convert_address (\n    address,\n    flash_addr\n);\n\n    parameter FLASH_ADDR_WIDTH = 23;\n    parameter ADDR_RANGE1_END_ADDR = 1;\n    parameter ADDR_RANGE1_OFFSET = 1;\n    parameter ADDR_RANGE2_OFFSET = 1;\n\n    input [FLASH_ADDR_WIDTH-1:0] address;\n    output [FLASH_ADDR_WIDTH-1:0] flash_addr;\n\n    assign flash_addr = (address <= ADDR_RANGE1_END_ADDR[FLASH_ADDR_WIDTH-1:0]) ? \n        (address + ADDR_RANGE1_OFFSET[FLASH_ADDR_WIDTH-1:0]) : \n        (address + ADDR_RANGE2_OFFSET[FLASH_ADDR_WIDTH-1:0]);\n    \nendmodule\n\n\nmodule altera_onchip_flash_convert_sector (\n    sector,\n    flash_sector\n);\n\n    parameter SECTOR1_MAP = 1;\n    parameter SECTOR2_MAP = 1;\n    parameter SECTOR3_MAP = 1;\n    parameter SECTOR4_MAP = 1;\n    parameter SECTOR5_MAP = 1;\n\n    input [2:0] sector;\n    output [2:0] flash_sector;\n\n    assign flash_sector = \n        (sector == 1) ? SECTOR1_MAP[2:0] :\n        (sector == 2) ? SECTOR2_MAP[2:0] :\n        (sector == 3) ? SECTOR3_MAP[2:0] :\n        (sector == 4) ? SECTOR4_MAP[2:0] :\n        (sector == 5) ? SECTOR5_MAP[2:0] :\n        3'd0; endmodule\n\n\nmodule altera_onchip_flash_counter (\n    clock,\n    reset,\n    count\n);\n    input clock;\n    input reset;\n    output [4:0] count;\n    \n    reg [4:0] count_reg;\n    \n    assign count = count_reg;\n\n    initial begin\n        count_reg = 0;\n    end\n    \n    always @ (posedge reset or posedge clock) begin\n        if (reset) begin\n            count_reg <= 0;\n        end\n        else begin\n            count_reg <= count_reg + 5'd1;\n        end\n    end\n\nendmodule\n",
        "module_name": "altera_onchip_flash_address_range_check",
        "module_hash": "96936f4a9078587796a5321e371e3596",
        "dataset_index": 18453
      },
      "adder_subtractor_4bit_05ab9b22": {
        "rtl_code": "module adder_subtractor_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input sub,\n    output reg [3:0] sum\n);\n\n    always @(*) begin\n        if(sub) begin\n            sum <= a - b;\n        end else begin\n            sum <= a + b;\n        end\n    end\n\nendmodule",
        "module_name": "adder_subtractor_4bit",
        "module_hash": "05ab9b22315d71e2ec4ff7e1839ffb83",
        "dataset_index": 15025
      },
      "top__cb09b65a": {
        "rtl_code": "\nmodule top_module (\n    input [31:0] a,\n    input [31:0] b,\n    input sub_select,\n    output [31:0] sum\n);\n\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire carry_out;\n    wire overflow;\n\n    adder_subtractor add_sub(\n        .a(a),\n        .b(b),\n        .sub_select(sub_select),\n        .add_out(add_out),\n        .sub_out(sub_out),\n        .carry_out(carry_out),\n        .overflow(overflow)\n    );\n    functional_logic func(\n        .in1(add_out),\n        .in2(sub_out),\n        .out(and_out),\n        .carry_in(carry_out),\n        .overflow_in(overflow)\n    );\n\n    assign sum = sub_select ? sub_out : add_out;\n\nendmodule\nmodule adder_subtractor (\n    input [31:0] a,\n    input [31:0] b,\n    input sub_select,\n    output [31:0] add_out,\n    output [31:0] sub_out,\n    output carry_out,\n    output overflow\n);\n\n    wire [31:0] a_inv;\n    wire [31:0] b_inv;\n    wire [31:0] sub_b_inv;\n    wire sub_carry_in;\n    wire add_carry_in;\n    wire add_overflow;\n    wire sub_overflow;\n\n    assign a_inv = ~a;\n    assign b_inv = ~b;\n    assign sub_b_inv = b_inv + 32'b1;\n    assign sub_carry_in = sub_select;\n    assign add_carry_in = 1'b0;\n\n    adder add(\n        .a(a),\n        .b(b),\n        .carry_in(add_carry_in),\n        .sum(add_out),\n        .carry_out(add_overflow)\n    );\n    adder sub(\n        .a(a),\n        .b(sub_b_inv),\n        .carry_in(sub_carry_in),\n        .sum(sub_out),\n        .carry_out(sub_overflow)\n    );\n\n    assign carry_out = sub_select ? sub_carry_in : add_carry_in;\n    assign overflow = sub_select ? sub_overflow : add_overflow;\n\nendmodule\nmodule functional_logic (\n    input [31:0] in1,\n    input [31:0] in2,\n    output [31:0] out,\n    input carry_in,\n    input overflow_in\n);\n\n    assign out = in1 & in2 & ~carry_in & ~overflow_in;\n\nendmodule\nmodule adder (\n    input [31:0] a,\n    input [31:0] b,\n    input carry_in,\n    output [31:0] sum,\n    output carry_out\n);\n\n    assign {carry_out, sum} = a + b + carry_in;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "cb09b65ad158883b2e420416023b6673",
        "dataset_index": 1561
      },
      "calculator_a8368cb4": {
        "rtl_code": "module calculator(\n    input [3:0] in1,\n    input [3:0] in2,\n    input op,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    if(op == 0) // addition\n        out = in1 + in2;\n    else // subtraction\n        out = in1 - in2;\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "a8368cb44f61a62d74db97e38f261742",
        "dataset_index": 15569
      },
      "top__998c5ae3": {
        "rtl_code": "\nmodule top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input [7:0] C,\n    output [7:0] final_output\n);\n\n    wire [7:0] multiplier_output;\n    wire [1:0] comparator_output;\n    \n    multiplier mult(A, B, multiplier_output);\n    mag_comparator comp(multiplier_output, C, comparator_output);\n    functional_module func(multiplier_output, comparator_output, final_output);\n\nendmodule\nmodule multiplier (\n    input [3:0] A,\n    input [3:0] B,\n    output [7:0] product\n);\n\n    assign product = {4'b0, A} * {4'b0, B};\n\nendmodule\nmodule mag_comparator (\n    input [7:0] comp_input,\n    input [7:0] C,\n    output reg [1:0] result\n);\n\n    always @(*) begin\n        if (comp_input == C) begin\n            result = 2'b00;\n        end else if (comp_input > C) begin\n            result = 2'b01;\n        end else begin\n            result = 2'b10;\n        end\n    end\n\nendmodule\nmodule functional_module (\n    input [7:0] multiplier_output,\n    input [1:0] comparator_output,\n    output [7:0] final_output\n);\n\n    assign final_output = multiplier_output + {2'b0, comparator_output};\n\nendmodule",
        "module_name": "top_",
        "module_hash": "998c5ae32ca958ddf5dc41e3ab4c420a",
        "dataset_index": 8498
      },
      "addsub_49aaf96b": {
        "rtl_code": "\nmodule addsub(\n  input [3:0] A,\n  input [3:0] B,\n  input M,\n  output [3:0] R,\n  output COUT,\n  output V\n);\n\n  wire [4:0] temp;\n  wire [3:0] B_neg;\n  wire [3:0] two_comp;\n\n  assign temp = A + (M ? ~B + 1'b1 : B);\n  assign B_neg = (M ? ~B + 1'b1 : B);\n  assign two_comp = (M ? {~temp[4], temp[3:0]} : temp[3:0]);\n\n  assign R = (M ? two_comp : temp[3:0]);\n  assign COUT = temp[4] ^ M;\n  assign V = (A[3] == B[3] && R[3] != A[3]) ? 1'b1 : 1'b0;\n\nendmodule\n",
        "module_name": "addsub",
        "module_hash": "49aaf96b3de482f3223f2a449da2b89a",
        "dataset_index": 17184
      },
      "shift_reg_serial_01a8bc4c": {
        "rtl_code": "module shift_reg_serial (\n    input data_in,\n    input shift,\n    input clk,\n    output reg q\n);\n\nreg [3:0] pipeline[2:0];\n\nalways @(posedge clk) begin\n    pipeline[0] <= data_in;\n    pipeline[1] <= pipeline[0];\n    pipeline[2] <= pipeline[1];\n    if (shift) begin\n        pipeline[0] <= pipeline[1];\n        pipeline[1] <= pipeline[2];\n        pipeline[2] <= q;\n    end\n    q <= pipeline[2];\nend\n\nendmodule",
        "module_name": "shift_reg_serial",
        "module_hash": "01a8bc4c3d21efbed331b83d68f0f783",
        "dataset_index": 7567
      },
      "up_counter_5d71fae0": {
        "rtl_code": "module up_counter (\n    input wire clk,\n    input wire rst,\n    output reg [2:0] count\n);\n\n    reg [2:0] reg_count;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            reg_count <= 3'b000;\n        end else begin\n            reg_count <= reg_count + 1;\n        end\n    end\n\n    always @* begin\n        count = reg_count;\n    end\n\nendmodule",
        "module_name": "up_counter",
        "module_hash": "5d71fae0113aa0c725583139a9368636",
        "dataset_index": 6393
      },
      "konamicoder_4a16ddb3": {
        "rtl_code": "module konamicoder (\n  digit_0,\n  digit_1,\n  digit_2,\n  digit_3,\n  state\n  );\n\n  output [6:0] digit_0;\n  output [6:0] digit_1;\n  output [6:0] digit_2;\n  output [6:0] digit_3;\n  input [3:0] state;\n\n  wire [6:0] digit_0;\n  wire [6:0] digit_1;\n  wire [6:0] digit_2;\n  wire [6:0] digit_3;\n\n  parameter char_u = 7'b0111110;\n  parameter char_p = 7'b1110011;\n  parameter char_d = 7'b1011110;\n  parameter char_n = 7'b1010100;\n  parameter char_l = 7'b0111000;\n  parameter char_f = 7'b1110001;\n  parameter char_r = 7'b1010000;\n  parameter char_h = 7'b1110100;\n  parameter char_0 = 7'b0111111;\n  parameter char_1 = 7'b0000110;\n  parameter char_2 = 7'b1011011;\n  parameter char_9 = 7'b1101111;\n  parameter char_  = 7'b1000000;\n\n  assign digit_0 =\n    (state == 4'd0) ? char_ :\n    (state == 4'd1) ? char_u :\n    (state == 4'd2) ? char_u :\n    (state == 4'd3) ? char_d :\n    (state == 4'd4) ? char_d :\n    (state == 4'd5) ? char_l :\n    (state == 4'd6) ? char_r :\n    (state == 4'd7) ? char_l :\n    (state == 4'd8) ? char_r :\n    (state == 4'd9) ? char_9 : char_0;\n\n  assign digit_1 =\n    (state == 4'd0) ? char_ :\n    (state == 4'd1) ? char_p :\n    (state == 4'd2) ? char_p :\n    (state == 4'd3) ? char_n :\n    (state == 4'd4) ? char_n :\n    (state == 4'd5) ? char_f :\n    (state == 4'd6) ? char_h :\n    (state == 4'd7) ? char_f :\n    (state == 4'd8) ? char_h :\n    (state == 4'd9) ? char_9 : char_0;\n\n  assign digit_2 =\n    (state == 4'd0) ? char_ :\n    (state == 4'd1) ? char_ :\n    (state == 4'd2) ? char_ :\n    (state == 4'd3) ? char_ :\n    (state == 4'd4) ? char_ :\n    (state == 4'd5) ? char_ :\n    (state == 4'd6) ? char_ :\n    (state == 4'd7) ? char_ :\n    (state == 4'd8) ? char_ :\n    (state == 4'd9) ? char_9 : char_0;\n\n  assign digit_3 =\n    (state == 4'd0) ? char_ :\n    (state == 4'd1) ? char_1 :\n    (state == 4'd2) ? char_2 :\n    (state == 4'd3) ? char_1 :\n    (state == 4'd4) ? char_2 :\n    (state == 4'd5) ? char_1 :\n    (state == 4'd6) ? char_1 :\n    (state == 4'd7) ? char_2 :\n    (state == 4'd8) ? char_2 :\n    (state == 4'd9) ? char_9 : char_0;\n\nendmodule\n",
        "module_name": "konamicoder",
        "module_hash": "4a16ddb374afb12361a148dd6b4c2f17",
        "dataset_index": 13935
      },
      "full_adder_8037e472": {
        "rtl_code": "module full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [4:0] sum\n);\n\n    wire [3:0] carry;\n    full_adder fa0(.a(A[0]), .b(B[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n    full_adder fa1(.a(A[1]), .b(B[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder fa2(.a(A[2]), .b(B[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder fa3(.a(A[3]), .b(B[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "8037e472927d46707d60eb7e9eafc18b",
        "dataset_index": 12600
      },
      "top_module_3a053819": {
        "rtl_code": "module top_module(\n    input [15:0] a,\n    input [15:0] b,\n    input sub,\n    input control,\n    output reg [15:0] out\n);\n\n    wire [15:0] add_out;\n    wire [15:0] sub_out;\n    wire carry_out;\n\n    ripple_carry_adder adder(\n        .a(a),\n        .b(b),\n        .carry_in(sub),\n        .sum(add_out),\n        .carry_out(carry_out)\n    );\n\n    xor_gate xor_gate_inst(\n        .a(b),\n        .b({16{sub}}),\n        .out(sub_out)\n    );\n\n    always @* begin\n        if(control) begin\n            out <= add_out;\n        end else begin\n            out <= sub_out;\n        end\n    end\n\nendmodule\n\nmodule ripple_carry_adder(\n    input [15:0] a,\n    input [15:0] b,\n    input carry_in,\n    output [15:0] sum,\n    output carry_out\n);\n\n    genvar i;\n    wire [16:0] carry;\n\n    assign carry[0] = carry_in;\n\n    generate\n        for(i = 0; i < 16; i = i + 1) begin: loop\n            full_adder adder(\n                .a(a[i]),\n                .b(b[i]),\n                .carry_in(carry[i]),\n                .sum(sum[i]),\n                .carry_out(carry[i+1])\n            );\n        end\n    endgenerate\n\n    assign carry_out = carry[16];\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input carry_in,\n    output sum,\n    output carry_out\n);\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (carry_in & (a ^ b));\n\nendmodule\n\nmodule xor_gate(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] out\n);\n\n    assign out = a ^ b;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "3a053819c70af60f72e965333257c580",
        "dataset_index": 10409
      },
      "top_module_8faa12da": {
        "rtl_code": "\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena, // 2-bit input to choose direction and shift/hold\n    input [99:0] data, // 100-bit input to shift register\n    output [99:0] q, // 100-bit output from shift register\n    input [7:0] d, // 8-bit input to register\n    output [7:0] q_reg, // 8-bit output from register\n    output [7:0] and_output // 8-bit output from functional module\n);\n\nreg [99:0] shift_reg;\nreg [7:0] reg_data;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n        reg_data <= d;\n    end else begin\n        case (ena)\n            2'b00: begin // hold\n                shift_reg <= shift_reg;\n            end\n            2'b01: begin // shift left\n                shift_reg <= {shift_reg[98:0], shift_reg[99]};\n            end\n            2'b10: begin // shift right\n                shift_reg <= {shift_reg[0], shift_reg[99:1]};\n            end\n            2'b11: begin // hold\n                shift_reg <= shift_reg;\n            end\n        endcase\n        reg_data <= reg_data;\n    end\nend\n\nassign q = shift_reg;\nassign q_reg = reg_data;\n\n// Fix the continuous assignment of and_output to avoid latch inference\nwire _and_output = q[7:0] & q_reg;\nassign and_output = _and_output;\n\nendmodule\n",
        "module_name": "top_module",
        "module_hash": "8faa12da95a111a491ec643cb9da41af",
        "dataset_index": 4368
      },
      "asfifo_graycounter #_7c16239c": {
        "rtl_code": "\n\n\n\nmodule asfifo_graycounter #(\n\tparameter width = 2\n) (\n\toutput reg [width-1:0] gray_count,\n\tinput ce,\n\tinput rst,\n\tinput clk\n);\n\nreg [width-1:0] binary_count;\n\nalways @(posedge clk, posedge rst) begin\n\tif(rst) begin\n\t\tbinary_count <= {width{1'b0}} + 1;\n\t\tgray_count <= {width{1'b0}};\n\tend else if(ce) begin\n\t\tbinary_count <= binary_count + 1;\n\t\tgray_count <= {binary_count[width-1],\n\t\t\t\tbinary_count[width-2:0] ^ binary_count[width-1:1]};\n\tend\nend\n\nendmodule\n",
        "module_name": "asfifo_graycounter #",
        "module_hash": "7c16239c89625908c4d26d36c3c15cd2",
        "dataset_index": 24747
      },
      "ripple_carry_adder_3d298b6b": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input [3:0] in0,\n    input [3:0] in1,\n    input carry_in,\n    output [3:0] sum,\n    output carry_out\n);\n\nwire [3:0] stage1_sum;\nwire stage1_carry;\n\nwire [3:0] stage2_sum;\nwire stage2_carry;\n\nwire [3:0] stage3_sum;\nwire stage3_carry;\n\n// Stage 1\nfull_adder fa1(in0[0], in1[0], carry_in, stage1_sum[0], stage1_carry);\n\n// Stage 2\nfull_adder fa2(in0[1], in1[1], stage1_carry, stage2_sum[1], stage2_carry);\n\n// Stage 3\nfull_adder fa3(in0[2], in1[2], stage2_carry, stage3_sum[2], stage3_carry);\n\n// Stage 4\nfull_adder fa4(in0[3], in1[3], stage3_carry, sum[3], carry_out);\n\nassign sum[0] = stage1_sum[0];\nassign sum[1] = stage2_sum[1];\nassign sum[2] = stage3_sum[2];\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input carry_in,\n    output sum,\n    output carry_out\n);\n\nassign sum = a ^ b ^ carry_in;\nassign carry_out = (a & b) | (a & carry_in) | (b & carry_in);\n\nendmodule\n",
        "module_name": "ripple_carry_adder",
        "module_hash": "3d298b6b4d52f3a15e71b014e1dd81fa",
        "dataset_index": 20333
      },
      "crc_generator_checker #_7e7a1eeb": {
        "rtl_code": "module crc_generator_checker #(\n  parameter data_width = 8,\n  parameter crc_width = 16\n) (\n  input [data_width-1:0] data_in,\n  input [crc_width-1:0] crc_in,\n  input reset,\n  input clk,\n  output [crc_width-1:0] crc_out,\n  output error\n);\n\n\nreg [crc_width-1:0] crc_reg;\nreg [data_width-1:0] data_reg;\nreg [crc_width-1:0] crc_gen;\nreg [crc_width-1:0] crc_check;\n\nwire [crc_width-1:0] crc_out_int;\nwire [crc_width-1:0] crc_in_shifted;\nwire [data_width-1:0] data_in_shifted;\nwire [crc_width-1:0] crc_gen_shifted;\nwire [crc_width-1:0] crc_check_shifted;\nwire error_temp;\n\nassign crc_out = crc_out_int;\nassign error = error_temp;\n\n// Shift register for input data\nalways @(posedge clk) begin\n  if (reset) begin\n    data_reg <= 0;\n  end else begin\n    data_reg <= {data_reg[data_width-2:0], data_in};\n  end\nend\n\n// Shift register for input CRC\nalways @(posedge clk) begin\n  if (reset) begin\n    crc_check <= 0;\n  end else begin\n    crc_check <= crc_in_shifted;\n  end\nend\n\n// Shift register for generated CRC\nalways @(posedge clk) begin\n  if (reset) begin\n    crc_gen <= 0;\n  end else begin\n    crc_gen <= crc_gen_shifted;\n  end\nend\n\n// Shift register for shifted input data\nassign data_in_shifted = {data_reg[data_width-2:0], data_in};\n\n// Shift register for shifted input CRC\nassign crc_in_shifted = {crc_check[crc_width-2:0], crc_check};\n\n// Shift register for shifted generated CRC\nassign crc_gen_shifted = {crc_gen[crc_width-2:0], crc_gen};\n\n// Calculation of CRC checksum\nalways @(posedge clk) begin\n  if (reset) begin\n    crc_reg <= 0;\n  end else begin\n    crc_reg <= crc_gen_shifted ^ crc_in_shifted ^ data_in_shifted;\n  end\nend\n\n// Error detection\nassign error_temp = (crc_check_shifted != crc_out_int);\n\n// Shift register for shifted checked CRC\nassign crc_check_shifted = {crc_check_shifted[crc_width-2:0], crc_check};\n\nassign crc_out_int = crc_reg;\n\nendmodule",
        "module_name": "crc_generator_checker #",
        "module_hash": "7e7a1eeb31d1d8ed6a6b085ee583bc16",
        "dataset_index": 201
      },
      "DeBounce_7dc9d55d": {
        "rtl_code": "\nmodule  DeBounce \n\t(\n\tinput \t\t\tclk, n_reset, button_in,\t\t\t\toutput reg \tDB_out\t\t\t\t\t\t\t\t\t\t\t\t\t);\nparameter N = 11 ;\t\treg  [N-1 : 0]\tq_reg;\t\t\t\t\t\t\treg  [N-1 : 0]\tq_next;\n\treg DFF1, DFF2;\t\t\t\t\t\t\t\t\twire q_add;\t\t\t\t\t\t\t\t\t\t\twire q_reset;\nassign q_reset = (DFF1  ^ DFF2);\t\tassign  q_add = ~(q_reg[N-1]);\t\t\talways @ ( q_reset, q_add, q_reg)\n\t\tbegin\n\t\t\tcase( {q_reset , q_add})\n\t\t\t\t2'b00 :\n\t\t\t\t\t\tq_next <= q_reg;\n\t\t\t\t2'b01 :\n\t\t\t\t\t\tq_next <= q_reg + 1;\n\t\t\t\tdefault :\n\t\t\t\t\t\tq_next <= { N {1'b0} };\n\t\t\tendcase \t\n\t\tend\n\t\nalways @ ( posedge clk )\n\t\tbegin\n\t\t\tif(n_reset ==  1'b0)\n\t\t\t\tbegin\n\t\t\t\t\tDFF1 <= 1'b0;\n\t\t\t\t\tDFF2 <= 1'b0;\n\t\t\t\t\tq_reg <= { N {1'b0} };\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tDFF1 <= button_in;\n\t\t\t\t\tDFF2 <= DFF1;\n\t\t\t\t\tq_reg <= q_next;\n\t\t\t\tend\n\t\tend\n\t\nalways @ ( posedge clk )\n\t\tbegin\n\t\t\tif(q_reg[N-1] == 1'b1)\n\t\t\t\t\tDB_out <= DFF2;\n\t\t\telse\n\t\t\t\t\tDB_out <= DB_out;\n\t\tend\n\n\tendmodule\n\n\n",
        "module_name": "DeBounce",
        "module_hash": "7dc9d55d5fcfd164b04c2261ac581178",
        "dataset_index": 24609
      },
      "logic__31848c0f": {
        "rtl_code": "module logic_module (a, b, g_out, p_out);\n  input a, b;\n  output g_out, p_out;\n  wire n2;\n\n  not inv1 (n2, a);\n  and (g_out, a, b);\n  xnor (p_out, b, n2);\n\nendmodule",
        "module_name": "logic_",
        "module_hash": "31848c0f5022be31ef740fce00d62396",
        "dataset_index": 2750
      },
      "tx_30f02c7a": {
        "rtl_code": "module tx (\n    clk,\n    reset_,\n    baud,\n    txdata,\n    tx_enable,\n    tx_ready,\t   \n    tx);\n\n   input       clk;\n   input       reset_;    \n   input       baud;       input [7:0] txdata;     input       tx_enable;  output      tx_ready;   output      tx;         reg \t       tx;\n   reg [1:0]   state;\n   reg [7:0]   txdata_sampled;\n   reg [2:0]   txpos;   \n   \n   parameter ST_IDLE    = 2'd0;\n   parameter ST_TXSTART = 2'd1;\n   parameter ST_TXDATA  = 2'd2;\n   parameter ST_TXSTOP  = 2'd3;\n\n   assign tx_ready = state == ST_IDLE;   \n   \n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       state <= ST_IDLE;\n     else if (state == ST_IDLE && tx_enable)\n       state <= ST_TXSTART;\n     else if (state == ST_TXSTART && baud)\n       state <= ST_TXDATA;\n     else if (state == ST_TXDATA && baud && txpos == 3'd7)\n       state <= ST_TXSTOP;\n     else if (state == ST_TXSTOP && baud)\n       state <= ST_IDLE;\n\n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       tx <= 1'b1;\n     else if (state == ST_TXSTART && baud)\n       tx <= 1'b0;\n     else if (state == ST_TXDATA && baud)\n       tx <= txdata_sampled[txpos];\n     else if (state == ST_TXSTOP && baud)\n       tx <= 1'b1;\n\n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       txpos <= 3'd0;\n     else if (state == ST_IDLE)\n       txpos <= 3'd0;     \n     else if (state == ST_TXDATA && baud)\n       txpos <= txpos + 3'd1;\n\n   always@ (posedge clk or negedge reset_)\n     if (!reset_)\n       txdata_sampled <= 8'h0;\n     else if (tx_enable && tx_ready)\n       txdata_sampled <= txdata;\n      \nendmodule\n",
        "module_name": "tx",
        "module_hash": "30f02c7a81af0a7ea141f947a66433dc",
        "dataset_index": 7378
      },
      "wireless_communication_block_fb2db27c": {
        "rtl_code": "\nmodule wireless_communication_block (\n  input [7:0] data_in,\n  input [1:0] ctrl,\n  output [7:0] data_out\n);\n\n  wire [7:0] bt_module_data_out;\n  wire [7:0] wifi_module_data_out;\n  wire [7:0] zigbee_module_data_out;\n\n  // Define the different communication protocol modules\n  bluetooth_module bt_module(.data_in(data_in), .data_out(bt_module_data_out));\n  wifi_module wifi_module(.data_in(data_in), .data_out(wifi_module_data_out));\n  zigbee_module zigbee_module(.data_in(data_in), .data_out(zigbee_module_data_out));\n\n  // Use control signals to select the appropriate module\n  assign data_out = (ctrl == 2'b00) ? bt_module_data_out :\n                    (ctrl == 2'b01) ? wifi_module_data_out :\n                    (ctrl == 2'b10) ? zigbee_module_data_out :\n                    8'b00000000;\n\nendmodule\nmodule bluetooth_module (\n  input [7:0] data_in,\n  output [7:0] data_out\n);\n  assign data_out = data_in;\nendmodule\nmodule wifi_module (\n  input [7:0] data_in,\n  output [7:0] data_out\n);\n  assign data_out = data_in;\nendmodule\nmodule zigbee_module (\n  input [7:0] data_in,\n  output [7:0] data_out\n);\n  assign data_out = data_in;\nendmodule",
        "module_name": "wireless_communication_block",
        "module_hash": "fb2db27c86c0bf4864e906cc8fefe786",
        "dataset_index": 4834
      },
      "binary_counter_92289a1b": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] count_out,\n  output reg overflow\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count_out <= 4'b0;\n      overflow <= 1'b0;\n    end else if (count_out == 4'b1111) begin\n      count_out <= 4'b0;\n      overflow <= 1'b1;\n    end else begin\n      count_out <= count_out + 1;\n      overflow <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "92289a1b8a639bd6315b6b3d5bc34e00",
        "dataset_index": 15600
      },
      "OR_gate_pipeline_b6ed7970": {
        "rtl_code": "\nmodule OR_gate_pipeline(\n    input a,\n    input b,\n    input clk,  // Added clock input\n    output reg out\n);\n\nreg p1_out;\n\nalways @ (a, b) begin\n    p1_out <= a | b;\nend\n\nalways @ (posedge clk) begin\n    out <= p1_out;\nend\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    input clk,  // Added clock input\n    output out\n);\n\nOR_gate_pipeline or_gate_pipeline(\n    .a(a),\n    .b(b),\n    .clk(clk),  // Connect the clock input\n    .out(out)  // Directly connect the output of OR_gate_pipeline to the output of top_module\n);\n\nendmodule\n",
        "module_name": "OR_gate_pipeline",
        "module_hash": "b6ed7970a371b469d6f92186fafbc173",
        "dataset_index": 16879
      },
      "nor_using_nand_cd196843": {
        "rtl_code": "module nor_using_nand(\n    input a,\n    input b,\n    output out\n);\n\nwire nand1_out, nand2_out;\n\nnand nand1(nand1_out, a, b);\nnand nand2(nand2_out, nand1_out, nand1_out);\nnot not1(out, nand2_out);\n\nendmodule",
        "module_name": "nor_using_nand",
        "module_hash": "cd196843b3d5fffbf66d90e3d86f5c4f",
        "dataset_index": 2274
      },
      "sky130_fd_sc_lp__a22o_m_20e9c39d": {
        "rtl_code": "\nmodule sky130_fd_sc_lp__a22o_m (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_lp__a22o_1 base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .B2(B2),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\nmodule sky130_fd_sc_lp__a22o_1 (\n    X    ,\n    A1   ,\n    A2   ,\n    B1   ,\n    B2   ,\n    VPWR ,\n    VGND ,\n    VPB  ,\n    VNB  \n);\n    output X    ;\n    input  A1   ;\n    input  A2   ;\n    input  B1   ;\n    input  B2   ;\n    input  VPWR ;\n    input  VGND ;\n    input  VPB  ;\n    input  VNB  ;\n    wire  an_a1   ;\n    wire  an_a2   ;\n    wire  an_b1   ;\n    wire  an_b2   ;\n    wire  s_ann12 ;\n\n    sky130_fd_sc_lp__nand2_2 _0_ (\n        .A(A1),\n        .B(A2),\n        .Y(an_a1)\n    );\n    sky130_fd_sc_lp__nand2_2 _1_ (\n        .A(B1),\n        .B(B2),\n        .Y(an_b1)\n    );\n    sky130_fd_sc_lp__or2_1 _2_ (\n        .A(an_a1),\n        .B(an_b1),\n        .X(s_ann12)\n    );\n    sky130_fd_sc_lp__inv_2 _3_ (\n        .A(s_ann12),\n        .Y(X)\n    );\nendmodule\nmodule sky130_fd_sc_lp__nand2_2 (\n    A    ,\n    B    ,\n    Y    \n);\n    input  A    ;\n    input  B    ;\n    output Y    ;\n\n    nand ( Y ,  A ,  B );\n\nendmodule\nmodule sky130_fd_sc_lp__or2_1 (\n    A    ,\n    B    ,\n    X    \n);\n    input  A    ;\n    input  B    ;\n    output X    ;\n\n    or ( X ,  A ,  B );\n\nendmodule\nmodule sky130_fd_sc_lp__inv_2 (\n    A    ,\n    Y    \n);\n    input  A    ;\n    output Y    ;\n\n    not ( Y ,  A );\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__a22o_m",
        "module_hash": "20e9c39d23edeb2f26a6290be7837721",
        "dataset_index": 8466
      },
      "ExShad32_4fabc568": {
        "rtl_code": "\n\nmodule ExShad32(\n\tclock, reset,\n\tvalRs, valRt,\n\tvalRn, shOp\n\t);\n\ninput\tclock;\ninput\treset;\n\n\n\ninput[31:0]\t\tvalRs;\ninput[ 7:0]\t\tvalRt;\ninput[ 2:0]\t\tshOp;\noutput[31:0]\tvalRn;\n\nreg[31:0]\t\ttValRn;\nassign\t\t\tvalRn = tValRn;\n\n\nreg[31:0]\t\ttValRol;\nreg[31:0]\t\ttValRor;\nreg[ 7:0]\t\ttValSh;\n\nalways @*\nbegin\n\n\ttValRol=0;\n\ttValRor=0;\n\ttValRn = 0;\n\ttValSh = 0;\n\n\tcase(shOp)\n\t3'h0: begin\n\tend\n\n\t3'h1: begin\t\ttValRol=0;\n\t\ttValRor=0;\n\t\ttValSh = valRt;\n\tend\n\n\t3'h2: begin\t\ttValRol=0;\n\t\ttValRor=valRs[31] ? 32'hFFFFFFFF : 32'h00000000;\n\t\ttValSh = valRt;\n\tend\n\n\t3'h3: begin\t\ttValRol=0;\n\t\ttValRor=0;\n\t\ttValSh = -valRt;\n\tend\n\n\t3'h4: begin\t\ttValRol=0;\n\t\ttValRor=valRs[31] ? 32'hFFFFFFFF : 32'h00000000;\n\t\ttValSh = -valRt;\n\tend\n\n\tdefault:\n\tbegin\n\tend\n\n\tendcase\n\n\tcasez(tValSh)\n\t8'b0zz00000: tValRn = valRs;\n\t8'b0zz00001: tValRn = { valRs[30:0], tValRol[31   ] };\n\t8'b0zz00010: tValRn = { valRs[29:0], tValRol[31:30] };\n\t8'b0zz00011: tValRn = { valRs[28:0], tValRol[31:29] };\n\t8'b0zz00100: tValRn = { valRs[27:0], tValRol[31:28] };\n\t8'b0zz00101: tValRn = { valRs[26:0], tValRol[31:27] };\n\t8'b0zz00110: tValRn = { valRs[25:0], tValRol[31:26] };\n\t8'b0zz00111: tValRn = { valRs[24:0], tValRol[31:25] };\n\t8'b0zz01000: tValRn = { valRs[23:0], tValRol[31:24] };\n\t8'b0zz01001: tValRn = { valRs[22:0], tValRol[31:23] };\n\t8'b0zz01010: tValRn = { valRs[21:0], tValRol[31:22] };\n\t8'b0zz01011: tValRn = { valRs[20:0], tValRol[31:21] };\n\t8'b0zz01100: tValRn = { valRs[19:0], tValRol[31:20] };\n\t8'b0zz01101: tValRn = { valRs[18:0], tValRol[31:19] };\n\t8'b0zz01110: tValRn = { valRs[17:0], tValRol[31:18] };\n\t8'b0zz01111: tValRn = { valRs[16:0], tValRol[31:17] };\n\t8'b0zz10000: tValRn = { valRs[15:0], tValRol[31:16] };\n\t8'b0zz10001: tValRn = { valRs[14:0], tValRol[31:15] };\n\t8'b0zz10010: tValRn = { valRs[13:0], tValRol[31:14] };\n\t8'b0zz10011: tValRn = { valRs[12:0], tValRol[31:13] };\n\t8'b0zz10100: tValRn = { valRs[11:0], tValRol[31:12] };\n\t8'b0zz10101: tValRn = { valRs[10:0], tValRol[31:11] };\n\t8'b0zz10110: tValRn = { valRs[ 9:0], tValRol[31:10] };\n\t8'b0zz10111: tValRn = { valRs[ 8:0], tValRol[31: 9] };\n\t8'b0zz11000: tValRn = { valRs[ 7:0], tValRol[31: 8] };\n\t8'b0zz11001: tValRn = { valRs[ 6:0], tValRol[31: 7] };\n\t8'b0zz11010: tValRn = { valRs[ 5:0], tValRol[31: 6] };\n\t8'b0zz11011: tValRn = { valRs[ 4:0], tValRol[31: 5] };\n\t8'b0zz11100: tValRn = { valRs[ 3:0], tValRol[31: 4] };\n\t8'b0zz11101: tValRn = { valRs[ 2:0], tValRol[31: 3] };\n\t8'b0zz11110: tValRn = { valRs[ 1:0], tValRol[31: 2] };\n\t8'b0zz11111: tValRn = { valRs[   0], tValRol[31: 1] };\n\n\t8'b1zz11111: tValRn = { tValRor[ 0  ], valRs[31: 1] };\n\t8'b1zz11110: tValRn = { tValRor[ 1:0], valRs[31: 2] };\n\t8'b1zz11101: tValRn = { tValRor[ 2:0], valRs[31: 3] };\n\t8'b1zz11100: tValRn = { tValRor[ 3:0], valRs[31: 4] };\n\t8'b1zz11011: tValRn = { tValRor[ 4:0], valRs[31: 5] };\n\t8'b1zz11010: tValRn = { tValRor[ 5:0], valRs[31: 6] };\n\t8'b1zz11001: tValRn = { tValRor[ 6:0], valRs[31: 7] };\n\t8'b1zz11000: tValRn = { tValRor[ 7:0], valRs[31: 8] };\n\t8'b1zz10111: tValRn = { tValRor[ 8:0], valRs[31: 9] };\n\t8'b1zz10110: tValRn = { tValRor[ 9:0], valRs[31:10] };\n\t8'b1zz10101: tValRn = { tValRor[10:0], valRs[31:11] };\n\t8'b1zz10100: tValRn = { tValRor[11:0], valRs[31:12] };\n\t8'b1zz10011: tValRn = { tValRor[12:0], valRs[31:13] };\n\t8'b1zz10010: tValRn = { tValRor[13:0], valRs[31:14] };\n\t8'b1zz10001: tValRn = { tValRor[14:0], valRs[31:15] };\n\t8'b1zz10000: tValRn = { tValRor[15:0], valRs[31:16] };\n\t8'b1zz01111: tValRn = { tValRor[16:0], valRs[31:17] };\n\t8'b1zz01110: tValRn = { tValRor[17:0], valRs[31:18] };\n\t8'b1zz01101: tValRn = { tValRor[18:0], valRs[31:19] };\n\t8'b1zz01100: tValRn = { tValRor[19:0], valRs[31:20] };\n\t8'b1zz01011: tValRn = { tValRor[20:0], valRs[31:21] };\n\t8'b1zz01010: tValRn = { tValRor[21:0], valRs[31:22] };\n\t8'b1zz01001: tValRn = { tValRor[22:0], valRs[31:23] };\n\t8'b1zz01000: tValRn = { tValRor[23:0], valRs[31:24] };\n\t8'b1zz00111: tValRn = { tValRor[24:0], valRs[31:25] };\n\t8'b1zz00110: tValRn = { tValRor[25:0], valRs[31:26] };\n\t8'b1zz00101: tValRn = { tValRor[26:0], valRs[31:27] };\n\t8'b1zz00100: tValRn = { tValRor[27:0], valRs[31:28] };\n\t8'b1zz00011: tValRn = { tValRor[28:0], valRs[31:29] };\n\t8'b1zz00010: tValRn = { tValRor[29:0], valRs[31:30] };\n\t8'b1zz00001: tValRn = { tValRor[30:0], valRs[31   ] };\n\t8'b1zz00000: tValRn = tValRor;\n\n\tendcase\n\nend\n\nendmodule\n",
        "module_name": "ExShad32",
        "module_hash": "4fabc5680597c7c87879adc247790536",
        "dataset_index": 24112
      },
      "sync__d4c17b30": {
        "rtl_code": "module sync_module (\n  input clk,\n  input data_in,\n  input reset_n,\n  output reg data_out\n);\n\n  reg data_in_d1;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      data_in_d1 <= 1'b0;\n      data_out <= 1'b0;\n    end else begin\n      data_in_d1 <= data_in;\n      data_out <= data_in_d1;\n    end\n  end\n\nendmodule",
        "module_name": "sync_",
        "module_hash": "d4c17b3042f483b9492b577ae042d8ea",
        "dataset_index": 8280
      },
      "bsg_channel_narrow #_ba31711a": {
        "rtl_code": "\nmodule bsg_channel_narrow #( parameter width_in_p     = 8\n                           , parameter width_out_p    = 4\n                           , parameter lsb_to_msb_p  = 1\n                           )\n                          ( input                    clk_i\n                          , input                    reset_i\n                          , input  [width_in_p-1:0]  data_i\n                          , input                    deque_i\n                          , output [width_out_p-1:0] data_o\n                          , output                   deque_o\n                          );\n  // Internal signals\n  reg [width_out_p-1:0] narrowed_data;\n\n  // Narrowing the input data\n  always @(posedge clk_i or posedge reset_i)\n    if(reset_i)\n      narrowed_data <= {width_out_p{1'b0}};\n    else\n      narrowed_data <= (lsb_to_msb_p) ? data_i[width_out_p-1:0] : data_i[width_in_p-1:width_in_p-width_out_p];\n\n  // Output signals\n  assign data_o = narrowed_data;\n  assign deque_o = deque_i;\n\nendmodule",
        "module_name": "bsg_channel_narrow #",
        "module_hash": "ba31711a83a8477c5f86a3c98338edd4",
        "dataset_index": 20963
      },
      "r0_1e7f8db5": {
        "rtl_code": "module r0 (\n\tinput clk_sys,\n\tinput strob1b,\n\tinput [0:15] w,\n\tinput zs, s_1, s0, carry, vl, vg, exy, exx,\n\tinput ust_z, ust_v, ust_mc, ust_y, ust_x, cleg,\n\tinput w_zmvc, w_legy, lrp,\n\tinput _0_v,\n\tinput zer,\n\toutput reg [0:15] r0\n);\n\n\twire c0 = ust_z & strob1b;\n\twire c1 = ust_mc & strob1b;\n\twire c2 = ust_v & strob1b;\n\twire c7 = ust_y & strob1b;\n\twire c8 = ust_x & strob1b;\n\n\talways @ (posedge clk_sys, posedge zer) begin\n\t\tif (zer) r0[0:15] <= 16'b0;\n\t\telse begin\n\n\t\t\tif (w_zmvc) {r0[0:1], r0[3]} <= {w[0:1], w[3]};\n\t\t\telse begin\n\t\t\t\tif (c0) r0[0] <= zs;\n\t\t\t\tif (c1) {r0[1], r0[3]} <= {s_1, carry};\n\t\t\tend\n\n\t\t\tif (_0_v) r0[2] <= 1'b0;\n\t\t\telse if (w_zmvc) r0[2] <= w[2];\n\t\t\telse if (c2 & (s0 ^ s_1)) r0[2] <= 1'b1;\n\n\t\t\tif (w_legy) r0[4:7] <= w[4:7];\n\t\t\telse begin\n\t\t\t\tif (cleg) r0[4:6] <= {vl, zs, vg};\n\t\t\t\tif (c7) r0[7] <= exy;\n\t\t\tend\n\n\t\t\tif (lrp) r0[8:15] <= w[8:15];\n\t\t\telse if (c8) r0[8] <= exx;\n\n\t\tend\n\tend\n\nendmodule\n\n",
        "module_name": "r0",
        "module_hash": "1e7f8db59b26fe638309d0f0e1270fb4",
        "dataset_index": 23622
      },
      "wavelet_transform #_4d371127": {
        "rtl_code": "\nmodule wavelet_transform #(\n  parameter n = 8, // number of input samples\n  parameter m = 8, // number of output samples\n  parameter k = 4 // number of filter taps\n) (\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\nreg signed [n-1:0] input_samples;\nreg signed [m-1:0] output_samples;\n\nreg signed [k-1:0] h0 = 'h0308_0d70_0974_fec0; // {0.4829629131445341, 0.8365163037378079, 0.2241438680420134, -0.1294095225512604};\nreg signed [k-1:0] h1 = 'hff37_ff38_0d70_0308; // {-0.1294095225512604, -0.2241438680420134, 0.8365163037378079, -0.4829629131445341};\n\ninteger i, j;\n\nalways @ (posedge clk) begin\n  input_samples <= in;\nend\n\nalways @ (*) begin\n  for (i = 0; i < m; i = i + 2) begin\n    output_samples[i] = 0;\n    output_samples[i+1] = 0;\n    for (j = 0; j < k; j = j + 1) begin\n      if (i+j < n) begin\n        output_samples[i] = output_samples[i] + h0[j] * input_samples[i+j];\n        output_samples[i+1] = output_samples[i+1] + h1[j] * input_samples[i+j];\n      end\n    end\n  end\nend\n\nassign out = output_samples;\n\nendmodule",
        "module_name": "wavelet_transform #",
        "module_hash": "4d371127d3067478bb2769135c473220",
        "dataset_index": 522
      },
      "comb_logic_00f6ede5": {
        "rtl_code": "\nmodule comb_logic (\n    output Y,\n    input  A,\n    input  B,\n    input  C\n);\n\n    // Output\n    wire Y;\n\n    // Inputs\n    wire A;\n    wire B;\n    wire C;\n\n    // Internal wires\n    wire not_C;\n    wire and_AB;\n\n    // Instantiate NOT gate for C\n    not (not_C, C);\n\n    // Instantiate AND gate for A and B\n    and (and_AB, A, B);\n\n    // Instantiate OR gate for and_AB and not_C\n    or (Y, and_AB, not_C);\n\nendmodule\n",
        "module_name": "comb_logic",
        "module_hash": "00f6ede5d6e7bb79d2856244bb552a97",
        "dataset_index": 5136
      },
      "up_down_counter_01f14a0f": {
        "rtl_code": "module up_down_counter (\n    input [2:0] D,\n    input UD,\n    input LD,\n    input CLK,\n    output reg [2:0] Q\n);\n\nalways @(posedge CLK) begin\n    if (LD) begin\n        Q <= D;\n    end else begin\n        if (UD) begin\n            Q <= Q - 1;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nend\n\nendmodule",
        "module_name": "up_down_counter",
        "module_hash": "01f14a0fd0a8e6d4db095af5dee26ca5",
        "dataset_index": 19813
      },
      "io1_sub_a0c8d4df": {
        "rtl_code": "module io1_sub(\n\t       \n\t       sec_out, lower_out,\n\t       sec_io, lower_io,\n\t       sec_ina, lower_ina\n\t       );\n\n   \n   input\t\tlower_ina;\t\tinput\t\tsec_ina;\t\t\n   inout\t\tlower_io;\t\tinout\t\tsec_io;\t\t\t\n   output\t\tlower_out;\t\toutput\t\tsec_out;\t\t\n\n\n   instio instio (\n\t\t  .lower_out\t\t(lower_out),\n\t\t  .sec_out\t\t(sec_out),\n\t\t  .lower_io\t\t(lower_io),\n\t\t  .sec_io\t\t(sec_io),\n\t\t  .lower_ina\t\t(lower_ina),\n\t\t  .sec_ina\t\t(sec_ina));\n\nendmodule\n\nmodule instio (\n\t       lower_out, sec_out,\n\t       lower_io, sec_io,\n\t       lower_ina, sec_ina\n\t       );\n\n   input lower_ina;\n   inout lower_io;\n   output lower_out;\n   input  sec_ina;\n   inout  sec_io;\n   output sec_out;\n\n   wire\t  lower_out = lower_ina | lower_io;\n   wire\t  sec_out = sec_ina | sec_io;\n\nendmodule\n\n",
        "module_name": "io1_sub",
        "module_hash": "a0c8d4dfd90209edb3c364688a1c4253",
        "dataset_index": 23180
      },
      "abs_difference_sum_77bd720e": {
        "rtl_code": "\nmodule abs_difference_sum (\n  input [15:0] input_a,\n  input [15:0] input_b,\n  output [15:0] output_sum\n);\n\n  wire [3:0] a_0to3, a_4to7, a_8to11, a_12to15;\n  wire [3:0] b_0to3, b_4to7, b_8to11, b_12to15;\n  wire [3:0] abs_diff_0to3, abs_diff_4to7, abs_diff_8to11, abs_diff_12to15;\n  wire [15:0] abs_diff_sum;\n\n  // Split input vectors into 4-bit vectors\n  assign a_0to3 = input_a[3:0];\n  assign a_4to7 = input_a[7:4];\n  assign a_8to11 = input_a[11:8];\n  assign a_12to15 = input_a[15:12];\n  assign b_0to3 = input_b[3:0];\n  assign b_4to7 = input_b[7:4];\n  assign b_8to11 = input_b[11:8];\n  assign b_12to15 = input_b[15:12];\n\n  // Calculate absolute difference between each corresponding 4-bit vector\n  assign abs_diff_0to3 = (a_0to3 > b_0to3) ? (a_0to3 - b_0to3) : (b_0to3 - a_0to3);\n  assign abs_diff_4to7 = (a_4to7 > b_4to7) ? (a_4to7 - b_4to7) : (b_4to7 - a_4to7);\n  assign abs_diff_8to11 = (a_8to11 > b_8to11) ? (a_8to11 - b_8to11) : (b_8to11 - a_8to11);\n  assign abs_diff_12to15 = (a_12to15 > b_12to15) ? (a_12to15 - b_12to15) : (b_12to15 - a_12to15);\n\n  // Calculate sum of absolute differences\n  assign abs_diff_sum = {abs_diff_12to15, abs_diff_8to11, abs_diff_4to7, abs_diff_0to3};\n  assign output_sum = abs_diff_sum;\n\nendmodule\n",
        "module_name": "abs_difference_sum",
        "module_hash": "77bd720e1b71b05972f8099db68ffa2f",
        "dataset_index": 18160
      },
      "sky130_fd_sc_hd__a311oi_28fbc305": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__a311oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2      );\n    nor nor0 (nor0_out_Y, and0_out, B1, C1);\n    buf buf0 (Y         , nor0_out_Y      );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__a311oi",
        "module_hash": "28fbc305ca847219fd00d23459bfbce3",
        "dataset_index": 22360
      },
      "bcd_converter_a7b0325c": {
        "rtl_code": "\nmodule bcd_converter (\n    input [3:0] in,\n    output reg [3:0] out,\n    output reg invalid\n);\n\nalways @(*) begin\n    case (in)\n        4'b0000: out = 4'b0000;\n        4'b0001: out = 4'b0001;\n        4'b0010: out = 4'b0010;\n        4'b0011: out = 4'b0011;\n        4'b0100: out = 4'b0100;\n        4'b0101: out = 4'b0101;\n        4'b0110: out = 4'b0110;\n        4'b0111: out = 4'b0111;\n        4'b1000: out = 4'b1000;\n        4'b1001: out = 4'b1001;\n        default: begin\n            out = 4'bxxxx;\n            invalid = 1'b1;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "bcd_converter",
        "module_hash": "a7b0325cca99533ce20e52fdcc372e35",
        "dataset_index": 13777
      },
      "antares_exmem_register_e34a9852": {
        "rtl_code": "module antares_exmem_register (\n                               input             clk,                      input             rst,                      input [31:0]      ex_alu_result,            input [31:0]      ex_mem_store_data,        input [4:0]       ex_gpr_wa,                input             ex_gpr_we,                input             ex_mem_to_gpr_select,     input             ex_mem_write,             input             ex_mem_byte,              input             ex_mem_halfword,          input             ex_mem_data_sign_ext,     input [31:0]      ex_exception_pc,\n                               input             ex_movn,\n                               input             ex_movz,\n                               input             ex_b_is_zero,\n                               input             ex_llsc,\n                               input             ex_kernel_mode,\n                               input             ex_is_bds,\n                               input             ex_trap,\n                               input             ex_trap_condition,\n                               input             ex_mem_exception_source,  input             ex_flush,                 input             ex_stall,                 input             mem_stall,                output reg [31:0] mem_alu_result,           output reg [31:0] mem_mem_store_data,       output reg [4:0]  mem_gpr_wa,               output reg        mem_gpr_we,               output reg        mem_mem_to_gpr_select,    output reg        mem_mem_write,            output reg        mem_mem_byte,             output reg        mem_mem_halfword,         output reg        mem_mem_data_sign_ext,    output reg [31:0] mem_exception_pc,\n                               output reg        mem_llsc,\n                               output reg        mem_kernel_mode,\n                               output reg        mem_is_bds,\n                               output reg        mem_trap,\n                               output reg        mem_trap_condition,\n                               output reg        mem_mem_exception_source\n                               );\n\n    wire    mov_reg_write = (ex_movn &  ~ex_b_is_zero) | (ex_movz &  ex_b_is_zero);\n\n    always @(posedge clk) begin\n        mem_alu_result           <= (rst) ? 32'b0 : ((mem_stall) ? mem_alu_result                                           : ex_alu_result);\n        mem_mem_store_data       <= (rst) ? 32'b0 : ((mem_stall) ? mem_mem_store_data                                       : ex_mem_store_data);\n        mem_gpr_wa               <= (rst) ? 5'b0  : ((mem_stall) ? mem_gpr_wa                                               : ex_gpr_wa);\n        mem_gpr_we               <= (rst) ? 1'b0  : ((mem_stall) ? mem_gpr_we               : ((ex_stall | ex_flush) ? 1'b0 : ((ex_movz | ex_movn) ? mov_reg_write : ex_gpr_we)));\n        mem_mem_to_gpr_select    <= (rst) ? 1'b0  : ((mem_stall) ? mem_mem_to_gpr_select    : ((ex_stall | ex_flush) ? 1'b0 : ex_mem_to_gpr_select));     mem_mem_write            <= (rst) ? 1'b0  : ((mem_stall) ? mem_mem_write            : ((ex_stall | ex_flush) ? 1'b0 : ex_mem_write));\n        mem_mem_byte             <= (rst) ? 1'b0  : ((mem_stall) ? mem_mem_byte                                             : ex_mem_byte);\n        mem_mem_halfword         <= (rst) ? 1'b0  : ((mem_stall) ? mem_mem_halfword                                         : ex_mem_halfword);\n        mem_mem_data_sign_ext    <= (rst) ? 1'b0  : ((mem_stall) ? mem_mem_data_sign_ext                                    : ex_mem_data_sign_ext);\n        mem_exception_pc         <= (rst) ? 32'b0 : ((mem_stall) ? mem_exception_pc                                         : ex_exception_pc);\n        mem_llsc                 <= (rst) ? 1'b0  : ((mem_stall) ? mem_llsc                                                 : ex_llsc);\n        mem_kernel_mode          <= (rst) ? 1'b0  : ((mem_stall) ? mem_kernel_mode                                          : ex_kernel_mode);\n        mem_is_bds               <= (rst) ? 1'b0  : ((mem_stall) ? mem_is_bds                                               : ex_is_bds);\n        mem_trap                 <= (rst) ? 1'b0  : ((mem_stall) ? mem_trap                 : ((ex_stall | ex_flush) ? 1'b0 : ex_trap));\n        mem_trap_condition       <= (rst) ? 1'b0  : ((mem_stall) ? mem_trap_condition                                       : ex_trap_condition);\n        mem_mem_exception_source <= (rst) ? 1'b0  : ((mem_stall) ? mem_mem_exception_source : ((ex_stall | ex_flush) ? 1'b0 : ex_mem_exception_source));\n    end endmodule ",
        "module_name": "antares_exmem_register",
        "module_hash": "e34a9852c0e34f40a80b7dc5a3befb89",
        "dataset_index": 17921
      },
      "full_adder_f1539259": {
        "rtl_code": "module full_adder(\n    input A,\n    input B,\n    input CI,\n    output S,\n    output CO\n);\n\nassign S = A ^ B ^ CI;\nassign CO = (A & B) | (CI & (A ^ B));\n\nendmodule\n\nmodule four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [4:0] C,\n    output CO\n);\n\nwire [3:0] S;\nwire [3:0] CO_int;\n\nfull_adder FA0(.A(A[0]), .B(B[0]), .CI(1'b0), .S(S[0]), .CO(CO_int[0]));\nfull_adder FA1(.A(A[1]), .B(B[1]), .CI(CO_int[0]), .S(S[1]), .CO(CO_int[1]));\nfull_adder FA2(.A(A[2]), .B(B[2]), .CI(CO_int[1]), .S(S[2]), .CO(CO_int[2]));\nfull_adder FA3(.A(A[3]), .B(B[3]), .CI(CO_int[2]), .S(S[3]), .CO(CO));\n\nassign C = {CO, S};\n\nendmodule",
        "module_name": "full_adder",
        "module_hash": "f1539259c2e69ccdb0fa1a109f748eb0",
        "dataset_index": 10566
      },
      "oh_reg1 #_65db10f3": {
        "rtl_code": "module oh_reg1 #(parameter DW = 1) \n   ( input           nreset, //async active low reset\n     input \t     clk, // clk\n     input \t     en, // write enable\n     input [DW-1:0]  in, // input data\n     output [DW-1:0] out  // output data (stable/latched when clk=1)\n     );\n   \n   reg [DW-1:0]      out_reg;\t   \n   always @ (posedge clk or negedge nreset)\n     if(!nreset)\n       out_reg[DW-1:0] <= 'b0;\n     else if(en)\t      \n       out_reg[DW-1:0] <= in[DW-1:0];\n   assign out[DW-1:0] = out_reg[DW-1:0];\t   \n   \nendmodule",
        "module_name": "oh_reg1 #",
        "module_hash": "65db10f3e6314b9c40dd264cacf93b76",
        "dataset_index": 15258
      },
      "mc_ctrl_d9ee61c0": {
        "rtl_code": "module mc_ctrl (\n    clk         ,\n    rstn        ,\n    mc_start_i      ,\n    mc_done_o       ,\n    mvd_access_o    ,\n    chroma_start_o      ,\n    chroma_sel_o        ,\n    chroma_done_i       ,\n    tq_start_o      ,\n    tq_sel_o        ,\n    tq_done_i       \n);\n\n\ninput       [1-1:0]     clk          ; // clk signal \ninput       [1-1:0]     rstn         ; // asynchronous reset\ninput       [1-1:0]     mc_start_i      ; // mc start \noutput      [1-1:0]     mc_done_o       ; // mc done \noutput              mvd_access_o ;\noutput      [1-1:0]     chroma_start_o   ; // chroma interpolation start \noutput      [1-1:0]     chroma_sel_o     ; // chroma interpolation select: 0:cb, 1:cr\ninput       [1-1:0]     chroma_done_i       ; // chroma interpolation done \noutput      [1-1:0]     tq_start_o      ; // tq start \noutput      [2-1:0]     tq_sel_o        ; // tq sel: 00:luma, 10:cb, 11:cr\ninput       [1-1:0]     tq_done_i       ; // tq done \n\n\nparameter IDLE         = 3'd0;\nparameter TQ_LUMA      = 3'd1;\nparameter MC_CB        = 3'd2;\nparameter TQ_CB        = 3'd3;\nparameter MC_CR        = 3'd4;\nparameter TQ_CR        = 3'd5;\nparameter DONE         = 3'd6;\n\nreg      [3-1:0]        current_state, next_state;\n\nalways @(*) begin\n                next_state = IDLE;\n    case(current_state) \n        IDLE : begin\n            if ( mc_start_i)\n                next_state = TQ_LUMA;\n            else\n                next_state = IDLE;\n        end\n        TQ_LUMA: begin\n            if ( tq_done_i)\n                next_state = MC_CB;\n            else\n                next_state = TQ_LUMA;\n        end\n        MC_CB: begin\n            if ( chroma_done_i)\n                next_state = TQ_CB;\n            else\n                next_state = MC_CB;\n        end\n        TQ_CB: begin\n            if ( tq_done_i)\n                next_state = MC_CR;\n            else\n                next_state = TQ_CB;\n        end\n        MC_CR: begin\n            if ( chroma_done_i)\n                next_state = TQ_CR;\n            else\n                next_state = MC_CR;\n        end\n        TQ_CR: begin\n            if ( tq_done_i)\n                next_state = DONE;\n            else\n                next_state = TQ_CR;\n        end\n        DONE: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n\nassign      mc_done_o       = (current_state == DONE); \nassign      chroma_start_o  = (current_state == TQ_LUMA && next_state == MC_CB)  ||\n                           (current_state == TQ_CB   && next_state == MC_CR)  ; \nassign      chroma_sel_o    = (current_state == MC_CR) ? 1'b1 : 1'b0; \nassign      tq_start_o      = (current_state == IDLE    && next_state == TQ_LUMA)||\n                           (current_state == MC_CB   && next_state == TQ_CB)  || \n                           (current_state == MC_CR   && next_state == TQ_CR)  ; \nassign      tq_sel_o        = (current_state == TQ_LUMA) ? 2'b00 :\n                           (current_state == TQ_CB  ) ? 2'b10 :\n                           (current_state == TQ_CR  ) ? 2'b11 : 2'b00;\n\nassign mvd_access_o = ( current_state == TQ_LUMA );\n\n\nalways @ (posedge clk or negedge rstn) begin\n    if(~rstn) begin\n        current_state <= IDLE;\n    end\n    else begin\n        current_state <= next_state;\n    end\nend\n\n\nendmodule",
        "module_name": "mc_ctrl",
        "module_hash": "d9ee61c05a14463d46a2f9b8215af108",
        "dataset_index": 8792
      },
      "top_module_ea235c89": {
        "rtl_code": "\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    wire [2:0] out_and, not_a, not_b; // Declaring intermediate signals as a wire\n\n    // Instantiate AND_gate module\n    AND_gate and_gate_inst (\n        .a(a),\n        .b(b),\n        .out(out_and) \n    );\n    \n    // Instantiate NOT_gate module for a\n    NOT_gate not_gate_a_inst (\n        .a(a),\n        .out(not_a) \n    );\n    \n    // Instantiate NOT_gate module for b\n    NOT_gate not_gate_b_inst (\n        .a(b),\n        .out(not_b) \n    );\n    \n    // Bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR of a and b\n    assign out_or_logical = (a != 0) || (b != 0);\n    \n    // Inverse of b in the upper half of out_not (bits [5:3])\n    assign out_not[5:3] = ~b;\n    \n    // Inverse of a in the lower half of out_not\n    assign out_not[2:0] = ~a;\n    \nendmodule\nmodule AND_gate (\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out\n);\n    assign out = a & b;\nendmodule\nmodule NOT_gate (\n    input [2:0] a,\n    output [2:0] out\n);\n    assign out = ~a;\nendmodule",
        "module_name": "top_module",
        "module_hash": "ea235c89b410df9af3697a830c7cbbd8",
        "dataset_index": 13866
      },
      "butterfly3_16_9862780c": {
        "rtl_code": "module butterfly3_16(\n             enable,\n                i_0,\n                i_1,\n                i_2,\n                i_3,\n                i_4,\n                i_5,\n                i_6,\n                i_7,\n                i_8,\n                i_9,\n                i_10,\n                i_11,\n                i_12,\n                i_13,\n                i_14,\n                i_15,\n                \n                 o_0,\n                 o_1,\n                 o_2,\n                 o_3,\n                 o_4,\n                 o_5,\n                 o_6,\n                 o_7,\n                 o_8 ,\n                 o_9 ,\n                 o_10,\n                 o_11,\n                 o_12,\n                 o_13,\n                 o_14,\n                 o_15            \n);\n\ninput             enable;\ninput signed  [27:0] i_0;\ninput signed  [27:0] i_1;\ninput signed  [27:0] i_2;\ninput signed  [27:0] i_3;\ninput signed  [27:0] i_4;\ninput signed  [27:0] i_5;\ninput signed  [27:0] i_6;\ninput signed  [27:0] i_7;\ninput signed  [27:0] i_8;\ninput signed  [27:0] i_9;\ninput signed  [27:0] i_10;\ninput signed  [27:0] i_11;\ninput signed  [27:0] i_12;\ninput signed  [27:0] i_13;\ninput signed  [27:0] i_14;\ninput signed  [27:0] i_15;\n\n\noutput  signed [27:0] o_0 ;\noutput  signed [27:0] o_1 ;\noutput  signed [27:0] o_2 ;\noutput  signed [27:0] o_3 ;\noutput  signed [27:0] o_4 ;\noutput  signed [27:0] o_5 ;\noutput  signed [27:0] o_6 ;\noutput  signed [27:0] o_7 ;\noutput  signed [27:0] o_8 ;\noutput  signed [27:0] o_9 ;\noutput  signed [27:0] o_10;\noutput  signed [27:0] o_11;\noutput  signed [27:0] o_12;\noutput  signed [27:0] o_13;\noutput  signed [27:0] o_14;\noutput  signed [27:0] o_15;\n\n\nwire  signed [27:0]   b_0;\nwire  signed [27:0]   b_1;\nwire  signed [27:0]   b_2;\nwire  signed [27:0]   b_3;\nwire  signed [27:0]   b_4;\nwire  signed [27:0]   b_5;\nwire  signed [27:0]   b_6;\nwire  signed [27:0]   b_7;\nwire  signed [27:0]   b_8;\nwire  signed [27:0]   b_9;\nwire  signed [27:0]   b_10;\nwire  signed [27:0]   b_11;\nwire  signed [27:0]   b_12;\nwire  signed [27:0]   b_13;\nwire  signed [27:0]   b_14;\nwire  signed [27:0]   b_15;\n\nassign b_0=i_0+i_15;\nassign b_1=i_1+i_14;\nassign b_2=i_2+i_13;\nassign b_3=i_3+i_12;\nassign b_4=i_4+i_11;\nassign b_5=i_5+i_10;\nassign b_6=i_6+i_9;\nassign b_7=i_7+i_8;\nassign b_8=i_7-i_8;               \nassign b_9=i_6-i_9;\nassign b_10=i_5-i_10;               \nassign b_11=i_4-i_11;\nassign b_12=i_3-i_12;               \nassign b_13=i_2-i_13;\nassign b_14=i_1-i_14;               \nassign b_15=i_0-i_15;\n\nassign o_0=enable?b_0:i_0;\nassign o_1=enable?b_1:i_1;\nassign o_2=enable?b_2:i_2;\nassign o_3=enable?b_3:i_3;\nassign o_4=enable?b_4:i_4;\nassign o_5=enable?b_5:i_5;\nassign o_6=enable?b_6:i_6;\nassign o_7=enable?b_7:i_7;\nassign o_8=enable?b_8:i_8;\nassign o_9=enable?b_9:i_9;\nassign o_10=enable?b_10:i_10;\nassign o_11=enable?b_11:i_11;\nassign o_12=enable?b_12:i_12;\nassign o_13=enable?b_13:i_13;\nassign o_14=enable?b_14:i_14;\nassign o_15=enable?b_15:i_15;\n\nendmodule\n",
        "module_name": "butterfly3_16",
        "module_hash": "9862780c8812fab584e65ced802ad9af",
        "dataset_index": 21758
      },
      "calculator_65a1a73d": {
        "rtl_code": "module calculator(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    input op,\n    output reg [7:0] result\n);\n\nalways @(posedge clk, posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (op == 0) begin\n            result <= a + b;\n        end else begin\n            result <= a - b;\n        end\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "65a1a73df772f39eed5feab8db309dfe",
        "dataset_index": 10270
      },
      "trafficLightController_c9c1afb2": {
        "rtl_code": "\nmodule trafficLightController (\n  input clk,\n  input [1:0] currentState,\n  output reg [1:0] nextState\n);\n\n// Power-on reset\ninitial begin\n  nextState <= 2'b00; // Red state\nend\n\n// Define state transitions\nalways @(posedge clk) begin\n  case (currentState)\n    2'b00: // Red state\n      if (count == 10) begin\n        nextState <= 2'b10; // Green state\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    2'b10: // Green state\n      if (count == 5) begin\n        nextState <= 2'b01; // Yellow state\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    2'b01: // Yellow state\n      if (count == 2) begin\n        nextState <= 2'b00; // Red state\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    default: nextState <= 2'b00; // Red state\n  endcase\nend\n\nreg [2:0] count;\nparameter CLK_PERIOD = 10; // Clock period in ns\nreg clk_internal;\nalways #CLK_PERIOD clk_internal = ~clk_internal; // Toggle clock signal\n\nassign clk = clk_internal;\n\nendmodule\n",
        "module_name": "trafficLightController",
        "module_hash": "c9c1afb29c052fc7271144b205aa9ac6",
        "dataset_index": 19146
      },
      "prior_enc_9f5d5519": {
        "rtl_code": "\n\nmodule prior_enc (\n                data_in,\n                encode_out,\n                enable_out\n                );\n\nparameter   WIDTH       = 64;\nparameter   N           = log2(WIDTH);\n\ninput   [WIDTH-1:0]     data_in;\noutput  [N-1:0]         encode_out;\noutput                  enable_out;\n\nreg     [N-1:0]         encode_out;\nreg                     enable_out;\n\nreg     [N-1:0]         x;\n\ninteger i, j;\n\nalways @(*)\nbegin\n    j = 0;\n    for (i=0; i < WIDTH; i=i+1)\n        if (data_in[i] == 1'b1)\n            j = i;\n            \n    encode_out  = j;\n    enable_out  = |{data_in};\nend\n\nfunction integer log2;\ninput [31:0] depth;\ninteger k;\nbegin\n    log2 = 1;\n    for (k=0; 2**k < depth; k=k+1)\n        log2 = k + 1;\nend\nendfunction     endmodule       ",
        "module_name": "prior_enc",
        "module_hash": "9f5d5519344600358d1af2e06a85993b",
        "dataset_index": 24000
      },
      "data_store_01d269c5": {
        "rtl_code": "module data_store(\n  input [15:0] data_in,\n  input enable,\n  input clk,\n  output reg [15:0] data_out\n);\n\nalways @(posedge clk) begin\n  if (enable) begin\n    data_out <= data_in;\n  end\nend\n\nendmodule",
        "module_name": "data_store",
        "module_hash": "01d269c50416893e60aff1c344b82802",
        "dataset_index": 11644
      },
      "reverse_bits_35d519b0": {
        "rtl_code": "module reverse_bits (\n    input [3:0] B,\n    output reg [3:0] R,\n    output reg [1:0] LZ\n);\n\nreg [1:0] zeros;\nreg [3:0] stage1, stage2, stage3;\n\nalways @(*) begin\n    stage1[0] = B[3];\n    stage1[1] = B[2];\n    stage1[2] = B[1];\n    stage1[3] = B[0];\nend\n\nalways @(*) begin\n    stage2[0] = stage1[2];\n    stage2[1] = stage1[3];\n    stage2[2] = stage1[0];\n    stage2[3] = stage1[1];\nend\n\nalways @(*) begin\n    stage3[0] = stage2[1];\n    stage3[1] = stage2[0];\n    stage3[2] = stage2[3];\n    stage3[3] = stage2[2];\nend\n\nalways @(*) begin\n    R = stage3;\nend\n\nalways @(*) begin\n    if (stage3[3] == 0) begin\n        zeros = 2;\n        if (stage3[2] == 0) begin\n            zeros = 1;\n            if (stage3[1] == 0) begin\n                zeros = 0;\n                if (stage3[0] == 0) begin\n                    zeros = 0;\n                end\n            end\n        end\n    end\n    else begin\n        zeros = 0;\n    end\n    LZ = zeros;\nend\n\nendmodule",
        "module_name": "reverse_bits",
        "module_hash": "35d519b09387b20bc8642c58ade30ccb",
        "dataset_index": 5809
      },
      "Shift_Register_c659d2f7": {
        "rtl_code": "\nmodule Shift_Register (\n  input [n-1:0] in,\n  input ctrl,\n  output [m-1:0] out\n);\n\nparameter n = 4; // number of input signals\nparameter m = 4; // number of output signals\nparameter w = 8; // width of the shift register (i.e., the number of flip-flops)\n\nreg [w-1:0] shift_reg;\n\nalways @(posedge ctrl) begin\n  shift_reg <= {shift_reg[w-1:m], in};\nend\n\nassign out = shift_reg[m-1:0];\n\nendmodule\n",
        "module_name": "Shift_Register",
        "module_hash": "c659d2f7ca29ff6d9cdcfe66d3f476f5",
        "dataset_index": 14197
      },
      "ripple_adder_4bit_2968fa30": {
        "rtl_code": "module ripple_adder_4bit(A, B, Cin, S, Cout);\n  input [3:0] A, B;\n  input Cin;\n  output [3:0] S;\n  output Cout;\n\n  wire [3:0] C;\n  wire [3:0] sum;\n\n  // First full adder\n  full_adder FA0(.a(A[0]), .b(B[0]), .cin(Cin), .sum(sum[0]), .cout(C[0]));\n\n  // Second full adder\n  full_adder FA1(.a(A[1]), .b(B[1]), .cin(C[0]), .sum(sum[1]), .cout(C[1]));\n\n  // Third full adder\n  full_adder FA2(.a(A[2]), .b(B[2]), .cin(C[1]), .sum(sum[2]), .cout(C[2]));\n\n  // Fourth full adder\n  full_adder FA3(.a(A[3]), .b(B[3]), .cin(C[2]), .sum(sum[3]), .cout(Cout));\n\n  // Output wires\n  assign S = sum;\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n  input a, b, cin;\n  output sum, cout;\n\n  // Calculate sum\n  xor(sum, a, b, cin);\n\n  // Calculate carry out\n  assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule",
        "module_name": "ripple_adder_4bit",
        "module_hash": "2968fa300645d2c5a5fe29f4473fec98",
        "dataset_index": 8020
      },
      "tkl5x1_aaeb16ec": {
        "rtl_code": "\nmodule tkl5x1 (i_0r0, i_0r1, i_0a, o_0r0, o_0r1, o_0a, reset);\n  input [4:0] i_0r0;\n  input [4:0] i_0r1;\n  input i_0a;\n  output [4:0] o_0r0;\n  output [4:0] o_0r1;\n  output o_0a;\n  input reset;\n\n  wire bna_0;\n  wire tech1_oint;\n  wire tech2_oint;\n  wire tech3_oint;\n  wire tech4_oint;\n  wire tech5_oint;\n  wire tech6_oint;\n  wire tech7_oint;\n  wire tech8_oint;\n  wire tech9_oint;\n  wire tech10_oint;\n  wire [4:0] bcomp_0;\n  wire [1:0] simp181_0;\n  wire tech19_int;\n\n  assign o_0r0 = i_0r0 | (i_0r1 & i_0a);\n  assign o_0r1 = i_0r0 | (i_0r1 & i_0a);\n  assign bcomp_0 = o_0r0 | o_0r1;\n  assign simp181_0 = bcomp_0[1:0] & bcomp_0[3:2];\n  assign tech19_int = bcomp_0[4] | bcomp_0[2:1];\n  assign o_0a = simp181_0[0] & simp181_0[1];\nendmodule",
        "module_name": "tkl5x1",
        "module_hash": "aaeb16ece108fec55f985f18a8ad0e3f",
        "dataset_index": 15029
      },
      "delay_inv_f690e709": {
        "rtl_code": "module delay_inv (\n    output Y,\n    input A,\n    input VPWR,\n    input VGND,\n    input clk\n);\n\n    reg [4:0] delay_reg; // register to hold delayed signal\n    reg out_reg; // register to hold output signal\n\n    always @(posedge clk) begin\n        delay_reg <= {delay_reg[3:0], A}; // shift in new input bit\n        out_reg <= delay_reg[4]; // output delayed signal\n    end\n\n    assign Y = out_reg;\n\nendmodule",
        "module_name": "delay_inv",
        "module_hash": "f690e70945acc0fa6e4d822196b6e3ff",
        "dataset_index": 5019
      },
      "alu_adcba37a": {
        "rtl_code": "module alu (a_in, b_in, alu_function, c_alu);\n\n   input  [31:0] a_in        ;\n   input  [31:0] b_in        ;\n   input  [ 3:0] alu_function;\n   output [31:0] c_alu       ;\n\n   wire [32:0] aa      ;\n   wire [32:0] bb      ;\n   wire [32:0] sum     ;\n   wire        do_add  ;\n   wire        sign_ext;\n\n   assign do_add   = (alu_function == 4'b0001) ? 1'b1 : 1'b0 ; // alu_add\n   assign sign_ext = (alu_function == 4'b0010) ? 1'b0 : 1'b1 ; // alu_less_than\n   assign aa       = {(a_in[31] & sign_ext), a_in} ;\n   assign bb       = {(b_in[31] & sign_ext), b_in} ;\n\n   reg [31:0] c_alu;\n   always @(*) begin\n        case(alu_function)\n            4'b0001 : c_alu = sum[31:0]         ; // alu_add\n            4'b0010 : c_alu = {31'b0, sum[32]}  ; // alu_less_than\n            4'b0100 : c_alu = a_in | b_in       ; // alu_or\n            4'b0101 : c_alu = a_in & b_in       ; // alu_and\n            4'b0110 : c_alu = a_in ^ b_in       ; // alu_xor\n            4'b0111 : c_alu = ~(a_in | b_in)    ; // alu_nor\n            default : c_alu = 32'b0             ; // alu_nothing\n        endcase\n    end\n\n   assign sum = (do_add)? aa+bb : aa-bb;\n\nendmodule",
        "module_name": "alu",
        "module_hash": "adcba37a32e63e32accfb1e338fb9c7d",
        "dataset_index": 11268
      },
      "sky130_fd_sc_lp__o21a_66ea7737": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_lp__o21a (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1         );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_lp__o21a",
        "module_hash": "66ea7737531516b85bf993b31639dfc9",
        "dataset_index": 23250
      },
      "add_sub_cd67c386": {
        "rtl_code": "module add_sub(input [3:0] A, B, C, output [3:0] O, output CO, OV);\n    wire [4:0] temp;\n    wire cin, cout;\n    assign cin = ~C;\n    \n    // Adder/Subtractor\n    assign temp = {cin, A} + {~C, B};\n    assign O = temp[3:0];\n    assign CO = temp[4];\n    \n    // Overflow detection\n    assign OV = (A[3] & B[3] & ~O[3]) | (~A[3] & ~B[3] & O[3]);\nendmodule",
        "module_name": "add_sub",
        "module_hash": "cd67c3866dc3be554c17a27a0662662f",
        "dataset_index": 5584
      },
      "adder_b2d9e7db": {
        "rtl_code": "\nmodule adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [3:0] xor1_out, xor2_out, xor3_out, and1_out, and2_out, and3_out, and4_out, and5_out, and6_out;\nwire [3:0] mux1_out, mux2_out, mux3_out;\n\n// XOR gates\nassign xor1_out[0] = a[0] ^ b[0];\nassign xor1_out[1] = a[1] ^ b[1];\nassign xor1_out[2] = a[2] ^ b[2];\nassign xor1_out[3] = a[3] ^ b[3];\n\nassign xor2_out[0] = cin ^ b[0];\nassign xor2_out[1] = cin ^ b[1];\nassign xor2_out[2] = cin ^ b[2];\nassign xor2_out[3] = cin ^ b[3];\n\nassign xor3_out[0] = cin ^ a[0];\nassign xor3_out[1] = cin ^ a[1];\nassign xor3_out[2] = cin ^ a[2];\nassign xor3_out[3] = cin ^ a[3];\n\n// AND gates\nassign and1_out[0] = a[0] & b[0];\nassign and1_out[1] = a[1] & b[1];\nassign and1_out[2] = a[2] & b[2];\nassign and1_out[3] = a[3] & b[3];\n\nassign and2_out[0] = xor1_out[0] & cin;\nassign and2_out[1] = xor1_out[1] & xor2_out[0];\nassign and2_out[2] = xor1_out[2] & xor2_out[1];\nassign and2_out[3] = xor1_out[3] & xor2_out[2];\n\nassign and3_out[0] = xor1_out[0] & xor2_out[0];\nassign and3_out[1] = xor1_out[1] & xor2_out[1];\nassign and3_out[2] = xor1_out[2] & xor2_out[2];\nassign and3_out[3] = xor1_out[3] & xor2_out[3];\n\nassign and4_out[0] = xor1_out[0] & xor2_out[0] & cin;\nassign and4_out[1] = xor1_out[1] & xor2_out[1] & xor3_out[0];\nassign and4_out[2] = xor1_out[2] & xor2_out[2] & xor3_out[1];\nassign and4_out[3] = xor1_out[3] & xor2_out[3] & xor3_out[2];\n\nassign and5_out[0] = xor1_out[0] & xor2_out[0] & xor3_out[0];\nassign and5_out[1] = xor1_out[1] & xor2_out[1] & xor3_out[1];\nassign and5_out[2] = xor1_out[2] & xor2_out[2] & xor3_out[2];\nassign and5_out[3] = and4_out[2];\n\nassign and6_out[0] = xor1_out[0] & xor2_out[0] & xor3_out[0] & cin;\nassign and6_out[1] = xor1_out[1] & xor2_out[1] & xor3_out[1] & xor2_out[0];\nassign and6_out[2] = xor1_out[2] & xor2_out[2] & xor3_out[2] & xor2_out[1];\nassign and6_out[3] = and4_out[3];\n\n// 2-input multiplexers\nmux2to1 #(4) mux1 (\n    .a(xor1_out),\n    .b(and2_out),\n    .s(cin),\n    .y(mux1_out)\n);\n\nmux2to1 #(4) mux2 (\n    .a(xor2_out),\n    .b(and3_out),\n    .s(cin),\n    .y(mux2_out)\n);\n\nmux2to1 #(4) mux3 (\n    .a(xor3_out),\n    .b(and4_out),\n    .s(cin),\n    .y(mux3_out)\n);\n\n// final sum\nassign sum[0] = mux1_out[0];\nassign sum[1] = mux2_out[1];\nassign sum[2] = mux3_out[2];\nassign sum[3] = and5_out[3];\n\n// carry-out\nassign cout = and6_out[3];\n\nendmodule\nmodule mux2to1 #(parameter WIDTH = 8) (\n    input [WIDTH-1:0] a,\n    input [WIDTH-1:0] b,\n    input s,\n    output [WIDTH-1:0] y\n);\n\nassign y = s ? b : a;\n\nendmodule",
        "module_name": "adder",
        "module_hash": "b2d9e7db75813dad6e5ab662a95f40dc",
        "dataset_index": 13703
      },
      "four_bit_register_bd87f928": {
        "rtl_code": "module four_bit_register (\n  input CLK,\n  input RST,\n  input [3:0] D,\n  output reg [3:0] Q\n);\n\n  always @(posedge CLK or negedge RST) begin\n    if (!RST) begin\n      Q <= 4'b0;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule",
        "module_name": "four_bit_register",
        "module_hash": "bd87f928f2fc1e7812d0aa1bec551c97",
        "dataset_index": 3462
      },
      "sky130_fd_sc_hd__nor4b_960dedf3": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nor4b (\n    Y  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire nor0_out_Y;\n\n    not not0 (not0_out  , D_N              );\n    nor nor0 (nor0_out_Y, A, B, C, not0_out);\n    buf buf0 (Y         , nor0_out_Y       );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nor4b",
        "module_hash": "960dedf355b9455cd5337481ac5b4534",
        "dataset_index": 17824
      },
      "digital_design_2d7c0384": {
        "rtl_code": "module digital_design(\n  input clk,\n  input rst,\n  input enable,\n  input test_expr,\n  input prevConfigInvalid,\n  output out\n);\n\n  reg out_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      out_reg <= 0;\n    end else if (enable) begin\n      if (test_expr && !prevConfigInvalid) begin\n        out_reg <= 1;\n      end else begin\n        out_reg <= 0;\n      end\n    end\n  end\n\n  assign out = out_reg;\n\nendmodule",
        "module_name": "digital_design",
        "module_hash": "2d7c038432525310937bab223748d390",
        "dataset_index": 21313
      },
      "top__6b909e90": {
        "rtl_code": "\nmodule top_module (\n  input clk,\n  input reset,\n  input [7:0] in,\n  input [4:0] shift_amount,\n  output [7:0] shifted_out,\n  output zero_flag\n);\n\n  // Priority Encoder module\n  wire [2:0] pe_out;\n  priority_encoder pe (\n    .in(in),\n    .out(pe_out)\n  );\n\n  // Barrel Shifter module\n  barrel_shifter bs (\n    .in(in),\n    .shift_amount(shift_amount),\n    .out(shifted_out)\n  );\n\n  // Zero Flag module\n  assign zero_flag = (shifted_out == 0);\n\n  // Internal register for priority encoder output\n  reg [2:0] pe_out_internal;\n\n  // Reset logic\n  always @(posedge clk) begin\n    if (reset) begin\n      pe_out_internal <= 3'b0;\n    end else begin\n      pe_out_internal <= pe_out;\n    end\n  end\n\nendmodule\nmodule priority_encoder (\n  input [7:0] in,\n  output [2:0] out\n);\n\n  assign out = (in[0]) ? 3'b001 :\n               (in[1]) ? 3'b010 :\n               (in[2]) ? 3'b011 :\n               (in[3]) ? 3'b100 :\n               (in[4]) ? 3'b101 :\n               (in[5]) ? 3'b110 :\n               (in[6]) ? 3'b111 :\n               3'b000;\n\nendmodule\nmodule barrel_shifter (\n  input [7:0] in,\n  input [4:0] shift_amount,\n  output reg [7:0] out\n);\n\n  always @(*) begin\n    case (shift_amount)\n      5'b00000: out = in;\n      5'b00001: out = {in[6:0], 1'b0};\n      5'b00010: out = {in[5:0], 2'b00};\n      5'b00011: out = {in[4:0], 3'b000};\n      5'b00100: out = {in[3:0], 4'b0000};\n      5'b00101: out = {in[2:0], 5'b00000};\n      5'b00110: out = {in[1:0], 6'b000000};\n      5'b00111: out = {in[0], 7'b0000000};\n      default: out = 8'b0;\n    endcase\n  end\n\nendmodule",
        "module_name": "top_",
        "module_hash": "6b909e90bf73673a3554d47cfac51679",
        "dataset_index": 14729
      },
      "dual_port_RAM_c797e349": {
        "rtl_code": "\nmodule dual_port_RAM (\n    input clk,\n    input rst_n,\n    input write_en,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    output [3:0] read_data\n);\n\n    // Define the block RAM\n    reg [3:0] ram [0:7];\n\n    // Define the write and read ports\n    reg [2:0] write_port;\n    reg [2:0] read_port;\n    reg [3:0] read_data_t;\n\n    // Write operation\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            write_port <= 3'b000;\n        end else if (write_en) begin\n            write_port <= write_addr[2:0];\n            ram[write_port] <= write_data;\n        end\n    end\n\n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            read_port <= 3'b000;\n            read_data_t <= 4'h0;\n        end else if (read_en) begin\n            read_port <= read_addr[2:0];\n            read_data_t <= ram[read_port];\n        end\n    end\n\n    assign read_data = read_data_t;\n\nendmodule",
        "module_name": "dual_port_RAM",
        "module_hash": "c797e349f89c9b4a2e47e8d0cda39f1b",
        "dataset_index": 14558
      },
      "barrel_shifter_ee0bfb5d": {
        "rtl_code": "module barrel_shifter (\n    input wire [15:0] in,\n    input wire [3:0] shift_amount,\n    output wire [15:0] out,\n    input wire clk // Added clock input\n);\n\n// Register Declarations\nreg [15:0] in_reg = 16'b0; // Initialize to 0\nreg [3:0] shift_amount_reg = 4'b0; // Initialize to 0\nreg [15:0] out_reg = 16'b0; // Initialize to 0\n\n// Clock Edge-Triggered Registers\nalways @(posedge clk) begin\n    in_reg <= in;\n    shift_amount_reg <= shift_amount;\nend\n\n// Barrel Shifter Logic\nalways @(posedge clk) begin\n    case (shift_amount_reg)\n        4'b0000: out_reg <= in_reg;\n        4'b0001: out_reg <= {in_reg[14:0], in_reg[15]};\n        4'b0010: out_reg <= {in_reg[13:0], in_reg[15:14]};\n        4'b0011: out_reg <= {in_reg[12:0], in_reg[15:13]};\n        4'b0100: out_reg <= {in_reg[11:0], in_reg[15:12]};\n        4'b0101: out_reg <= {in_reg[10:0], in_reg[15:11]};\n        4'b0110: out_reg <= {in_reg[9:0], in_reg[15:10]};\n        4'b0111: out_reg <= {in_reg[8:0], in_reg[15:9]};\n        4'b1000: out_reg <= {in_reg[7:0], in_reg[15:8]};\n        4'b1001: out_reg <= {in_reg[6:0], in_reg[15:7]};\n        4'b1010: out_reg <= {in_reg[5:0], in_reg[15:6]};\n        4'b1011: out_reg <= {in_reg[4:0], in_reg[15:5]};\n        4'b1100: out_reg <= {in_reg[3:0], in_reg[15:4]};\n        4'b1101: out_reg <= {in_reg[2:0], in_reg[15:3]};\n        4'b1110: out_reg <= {in_reg[1:0], in_reg[15:2]};\n        4'b1111: out_reg <= {in_reg[0], in_reg[15:1]};\n        default: out_reg <= 16'b0; // Handle the default case\n    endcase\nend\n\n// Output Assignment\nassign out = out_reg;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "ee0bfb5d54be4ef4a6e330ca0380dee0",
        "dataset_index": 704
      },
      "my__7731c85c": {
        "rtl_code": "module my_module (\n    input [3:0] in_data,\n    input [1:0] sel,\n    output reg [1:0] out_data\n);\n\n    always @(*) begin\n        case (sel)\n            2'b00: out_data = ~in_data + 1; // 2's complement\n            2'b01: out_data = {in_data[2:0], 1'b0}; // shift left\n            default: out_data = 2'b00; // default value\n        endcase\n    end\n\nendmodule",
        "module_name": "my_",
        "module_hash": "7731c85c77b0aaf935ba7017e2805c01",
        "dataset_index": 13736
      },
      "calculator_76f1bfc5": {
        "rtl_code": "module calculator(operand1, operand2, operator, result);\n\n\tinput [7:0] operand1, operand2;\n\tinput [1:0] operator;\n\toutput [15:0] result;\n\n\treg [15:0] temp_result;\n\n\talways @ (*)\n\tbegin\n\t\tcase (operator)\n\t\t\t2'b00: temp_result = operand1 + operand2; // addition\n\t\t\t2'b01: temp_result = operand1 - operand2; // subtraction\n\t\t\t2'b10: temp_result = operand1 * operand2; // multiplication\n\t\t\t2'b11: temp_result = operand1 / operand2; // division\n\t\tendcase\n\tend\n\n\tassign result = temp_result;\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "76f1bfc52f4b8cde28ef2f317562877b",
        "dataset_index": 2445
      },
      "DecodeUnit_8c56d97b": {
        "rtl_code": "module DecodeUnit(\n   input [15:0] COMMAND,\n   output       out,\n   output \tINPUT_MUX, writeEnable,\n   output [2:0] writeAddress,\n   output \tADR_MUX, write, PC_load, \n   output \tSP_write, inc, dec,\n   output [2:0] cond, op2,\n   output       SP_Sw, MAD_MUX, FLAG_WRITE, AR_MUX, BR_MUX,\n   output [3:0] S_ALU,\n   output       SPC_MUX, MW_MUX, AB_MUX, signEx\n);\n\n   reg [3:0] \tSelect_ALU;\n   reg [2:0] \tcondition;\n   reg [2:0] \topera2;\n   localparam \tIADD = 4'b0000;\n   localparam \tISUB = 4'b0001;\n   localparam \tIAND = 4'b0010;\n   localparam \tIOR = 4'b0011;\n   localparam \tIXOR = 4'b0100;\n   localparam \tISLL = 4'b1000;\n   localparam \tISLR = 4'b1001;\n   localparam \tISRL = 4'b1010;\n   localparam \tISRA = 4'b1011;\n   localparam \tIIDT = 4'b1100;\n   localparam \tINON = 4'b1111;\n   reg [2:0] \twrAdr; \t\n   reg \t\twr, pcl, in, adr, ar, br, se, wren, o, spc, ab, mw, sps, mad, i, d, spw, flw;\n\n   always @ (COMMAND) begin\n      if ((COMMAND[15:14] == 2'b11 && COMMAND[7:4] >= 4'b0000 && COMMAND[7:4] <= 4'b1011 && COMMAND[7:4] != 4'b0111)\n\t  || COMMAND[15:11] == 5'b10001)\n\tflw <= 1'b1;\n      else\n\tflw <= 1'b0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:11] == 5'b10011 || COMMAND[15:11] == 5'b10101)\n\tspc <= 1'b1;\n      else\n\tspc <= 1'b0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:14] == 2'b01)\n\tab <= 1;\n      else\n\tab <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:8] == 8'b10111110)\n\tmw <= 0;\n      else\n\tmw <= 1;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:8] == 8'b10111111)\n\tsps <= 0;\n      else\n\tsps <= 1;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:11] == 5'b10010 || COMMAND[15:9] == 7'b1011111)\n\tmad <= 0;\n      else\n\tmad <=1;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:8] == 8'b10111110 || COMMAND[15:11] == 5'b10010)\n\ti <= 1;\n      else\n\ti <= 0;\n   end\n\n  always @ (COMMAND) begin\n      if (COMMAND[15:8] == 8'b10111111 || COMMAND[15:11] == 5'b10011)\n\td <= 1;\n      else\n\td <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:11] == 5'b10011)\n\tspw <= 1;\n      else\n\tspw <= 0;\n   end\n   \n   always @ (COMMAND) begin\n     if (COMMAND[15:14] == 2'b00)\n       wrAdr <= COMMAND[13:11];\n     else\n       wrAdr <= COMMAND[10:8];\n   end\n   \n   always @ (COMMAND) begin\n      condition <= COMMAND[10:8];\n   end\n\n   always @ (COMMAND) begin\n      opera2 <= COMMAND[13:11];\n   end\n   \n   always @ (COMMAND) begin\n      if (COMMAND[15:14] == 2'b01 || COMMAND[15:11] == 5'b10010 || COMMAND[15:11] == 5'b10010 ||\n\t  COMMAND[15:11] == 5'b10110 || COMMAND[15:8] == 8'b10111110)\n\twren <= 1;\n      else\n\twren <= 0;\n   end\n     \n   always @ (COMMAND) begin\n      if (COMMAND[15:14] != 2'b11)\n\tse <= 1;\n      else\n\tse <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:14] == 2'b11 && COMMAND[7:4] == 4'b1101)\n\to <= 1;\n      else\n\to <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if ((COMMAND[15:14] == 2'b11 && (COMMAND[7:4] <= 4'b1100 && COMMAND[7:4] != 4'b0101)) ||\n\t  COMMAND[15:14] == 2'b00 ||    COMMAND[15:12] == 4'b1000 ||  COMMAND[15:11] == 5'b10011 || COMMAND[15:11] == 5'b10101)   wr <= 1;\n      else\n\twr <=0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:11] == 5'b10100 || COMMAND[15:11] == 5'b10111)\n\tpcl <= 1;\n      else\n\tpcl <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:14] == 2'b11 && COMMAND[7:4] == 4'b1100)\n\tin <= 1;\n      else\n\tin <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if ((COMMAND[15:14] == 2'b11 && COMMAND[7:4] <= 4'b1011) || \n\t  (COMMAND[15:14] == 2'b10 && (COMMAND[13:11] <= 3'b100 && COMMAND[13:11] != 3'b011)) ||\n\t  (COMMAND[15:11] == 5'b10111 && COMMAND[10:8] != 3'b111))\n\t  adr <= 1;\n      else\n\tadr <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:14] == 2'b11 || COMMAND[15:11] == 5'b10001 || COMMAND[15:14] == 2'b01 || COMMAND[15:14] == 2'b00)\n\tbr <= 1;\n      else\n\tbr <= 0;\n   end\n\n   always @ (COMMAND) begin\n      if (COMMAND[15:14] == 2'b11 && COMMAND[7:4] <= 4'b0110)\n\tar <= 1;\n      else\n\tar <= 0;\n   end\n   \n   always @ (COMMAND) begin\n      if (COMMAND[15:14] == 2'b11)case (COMMAND[7:4])\n\t  4'b0101 : Select_ALU <= ISUB;4'b0110 : Select_ALU <= IIDT;default : Select_ALU <= COMMAND[7:4];\n\tendcase else if (COMMAND[15] == 1'b0)Select_ALU <= IADD;\n      else if (COMMAND[15:11] == 5'b10000)Select_ALU <= IIDT;\n      else if (COMMAND[15:11] == 5'b10001)Select_ALU <= IADD;\n      else if (COMMAND[15:11] == 5'b10101 || COMMAND[15:11] == 5'b10110)Select_ALU <= ISUB;\n      else if (COMMAND[15:11] == 5'b10100)Select_ALU <= IADD;\n      else if (COMMAND[15:11] == 5'b10111)Select_ALU <= IADD;\n      else if (COMMAND[15:11] == 5'b10011)Select_ALU <= IADD;\n      elseSelect_ALU <= INON;\n   end\n\n   assign op2 = opera2;\n   assign writeAddress = wrAdr;\n   assign S_ALU = Select_ALU;\n   assign cond = condition;\n   assign AR_MUX = ar;\n   assign BR_MUX = br;\n   assign write = wr;\n   assign PC_load = pcl;\n   assign INPUT_MUX = in;\n   assign ADR_MUX = adr;\n   assign signEx = se;\n   assign out = o;\n   assign writeEnable = wren;   \n   assign SPC_MUX = spc;\n   assign AB_MUX = ab;\n   assign MW_MUX = mw;\n   assign SP_Sw = sps;\n   assign MAD_MUX = mad;\n   assign inc = i;\n   assign dec = d;\n   assign SP_write = spw;\n   assign FLAG_WRITE = flw;\n      \nendmodule ",
        "module_name": "DecodeUnit",
        "module_hash": "8c56d97b135233bb7c715832c535ccc1",
        "dataset_index": 14398
      },
      "fifo_64in_out_blk_mem_gen_9542f478": {
        "rtl_code": "\nmodule fifo_64in_out_blk_mem_gen\n(\n    dout,\n    wr_clk,\n    rd_clk,\n    I1,\n    tmp_ram_rd_en,\n    Q,\n    O2,\n    O1,\n    din\n);\n    output [63:0]dout;\n    input wr_clk;\n    input rd_clk;\n    input I1;\n    input tmp_ram_rd_en;\n    input [0:0]Q;\n    input [11:0]O2;\n    input [11:0]O1;\n    input [63:0]din;\n\n    reg [7:0] data [0:7];\n    reg [2:0] read_address;\n    reg [2:0] write_address;\n    wire [2:0] num_entries;\n    wire [2:0] next_write_address;\n    wire [2:0] next_num_entries;\n    reg [7:0] read_data;\n    reg [7:0] write_data;\n    reg write_enable;\n    reg read_enable;\n\n    assign num_entries = write_address - read_address;\n\n    // Write logic\n    always @(posedge wr_clk) begin\n        if (I1 && (num_entries != 8'b1000)) begin\n            data[write_address] <= din[7:0];\n            write_address <= next_write_address;\n            write_enable <= 1'b1;\n        end else begin\n            write_enable <= 1'b0;\n        end\n    end\n\n    // Read logic\n    always @(posedge rd_clk) begin\n        if (tmp_ram_rd_en && (num_entries != 8'b000)) begin\n            read_data <= data[read_address];\n            read_address <= read_address + 1'b1;\n            read_enable <= 1'b1;\n        end else begin\n            read_enable <= 1'b0;\n        end\n    end\n\n    // Update state\n    assign next_write_address = write_address + 1'b1;\n    assign next_num_entries = (I1 && (num_entries != 8'b1000)) ? num_entries + 1'b1 : \n                               (tmp_ram_rd_en && (num_entries != 8'b000)) ? num_entries - 1'b1 : num_entries;\n\n    // Output data\n    assign dout = {56'h0, read_data};\n\nendmodule",
        "module_name": "fifo_64in_out_blk_mem_gen",
        "module_hash": "9542f4780b534f99bcda9637825b3f2c",
        "dataset_index": 19538
      },
      "addsub_d944f953": {
        "rtl_code": "\nmodule addsub(A, B, subtract, result);\n\n  input [3:0] A;\n  input [3:0] B;\n  input subtract;\n  output [3:0] result;\n\n  wire [3:0] B_neg;\n  wire [3:0] temp_result;\n\n  assign B_neg = ~B + 1; // Two's complement of B\n\n  assign temp_result = A + (subtract ? B_neg : B);\n\n  assign result = temp_result + (subtract ? B_neg : B);\n\nendmodule",
        "module_name": "addsub",
        "module_hash": "d944f953577082ce98ffef191d3bbd5e",
        "dataset_index": 2786
      },
      "crossbar36_a9e864ee": {
        "rtl_code": "module crossbar36\n  (input clk, input reset, input clear,\n   input cross,\n   input [35:0] data0_i, input src0_rdy_i, output dst0_rdy_o,\n   input [35:0] data1_i, input src1_rdy_i, output dst1_rdy_o,\n   output [35:0] data0_o, output src0_rdy_o, input dst0_rdy_i,\n   output [35:0] data1_o, output src1_rdy_o, input dst1_rdy_i);\n\n   reg cross_int, active0, active1;\n   wire active0_next = (src0_rdy_i & dst0_rdy_o)? ~data0_i[33] : active0;\n   wire active1_next = (src1_rdy_i & dst1_rdy_o)? ~data1_i[33] : active1;\n\n   assign data0_o = cross_int ? data1_i : data0_i;\n   assign data1_o = cross_int ? data0_i : data1_i;\n\n   assign src0_rdy_o = cross_int ? src1_rdy_i : src0_rdy_i;\n   assign src1_rdy_o = cross_int ? src0_rdy_i : src1_rdy_i;\n\n   assign dst0_rdy_o = cross_int ? dst1_rdy_i : dst0_rdy_i;\n   assign dst1_rdy_o = cross_int ? dst0_rdy_i : dst1_rdy_i;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active0 <= 0;\n     else\n       active0 <= active0_next;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active1 <= 0;\n     else\n       active1 <= active1_next;\n\n   always @(posedge clk)\n     if(reset | clear)\n       cross_int <= 0;\n     else if(~active0_next & ~active1_next)\n       cross_int <= cross;\n   \nendmodule",
        "module_name": "crossbar36",
        "module_hash": "a9e864eea3c6a6541e543be57e2d9fb1",
        "dataset_index": 9071
      },
      "fsm_pattern_detection_264cfb71": {
        "rtl_code": "module fsm_pattern_detection (\n  input clk,\n  input reset,\n  input data,\n  output detected\n);\n\n  // Define states\n  localparam IDLE = 2'b00;\n  localparam STATE1 = 2'b01;\n  localparam STATE2 = 2'b10;\n\n  // Define pattern to detect\n  localparam PATTERN = 3'b101;\n\n  // Define current state\n  reg [1:0] state;\n\n  // Define shift register\n  reg [2:0] shift_reg;\n\n  // Define output register\n  reg output_reg;\n\n  // Define clocked process\n  always @(posedge clk) begin\n    if (reset) begin\n      // Reset state and shift register\n      state <= IDLE;\n      shift_reg <= 3'b0;\n      output_reg <= 1'b0;\n    end else begin\n      // Shift in new data\n      shift_reg <= {shift_reg[1:0], data};\n\n      // State machine\n      case(state)\n        IDLE: begin\n          if (shift_reg == PATTERN) begin\n            state <= STATE1;\n            output_reg <= 1'b1;\n          end else begin\n            state <= IDLE;\n            output_reg <= 1'b0;\n          end\n        end\n        STATE1: begin\n          state <= STATE2;\n          output_reg <= 1'b1;\n        end\n        STATE2: begin\n          state <= IDLE;\n          output_reg <= 1'b0;\n        end\n      endcase\n    end\n  end\n\n  // Assign output\n  assign detected = output_reg;\n\nendmodule",
        "module_name": "fsm_pattern_detection",
        "module_hash": "264cfb71e69264bb9ee1bb3cc55bb38f",
        "dataset_index": 2720
      },
      "accu_b0182b2f": {
        "rtl_code": "module accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n \n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [9:0]   data_out\n);\n\nreg [7:0] data_reg;\nreg [3:0] count_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'b0;\n        count_reg <= 4'b0;\n        valid_b <= 1'b0;\n        data_out <= 10'b0;\n    end\n    else begin\n        if (valid_a) begin\n            data_reg <= data_reg + data_in;\n            count_reg <= count_reg + 1;\n        end\n        if (count_reg == 4'b1111) begin\n            data_out <= {data_reg, 2'b0};\n            valid_b <= 1'b1;\n        end\n    end\nend\n\nassign ready_a = ~valid_b & ready_b;\n\nendmodule",
        "module_name": "accu",
        "module_hash": "b0182b2f52afa4946190398aab412da7",
        "dataset_index": 16646
      },
      "binary_counter_cf33d3ca": {
        "rtl_code": "module binary_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\nalways @ (posedge clk, posedge reset) begin\n  if (reset) begin\n    count <= 4'b0;\n  end else begin\n    count <= count + 1;\n  end\nend\n\nendmodule\n",
        "module_name": "binary_counter",
        "module_hash": "cf33d3cac6a2afb63455da329c76ecf3",
        "dataset_index": 13333
      },
      "soc_design_SystemID_2053fc8d": {
        "rtl_code": "module soc_design_SystemID (\n  // inputs:\n  address,\n  clock,\n  reset_n,\n\n  // outputs:\n  readdata\n);\n\n  output [31:0] readdata;\n  input [31:0] address;\n  input clock;\n  input reset_n;\n\n  reg [31:0] readdata_reg;\n\n  always @(posedge clock or negedge reset_n) begin\n    if (!reset_n) begin\n      readdata_reg <= 32'h0;\n    end else begin\n      readdata_reg <= (address == 32'h0) ? 32'hff : 32'h590d8d31;\n    end\n  end\n\n  assign readdata = readdata_reg;\n\nendmodule",
        "module_name": "soc_design_SystemID",
        "module_hash": "2053fc8de10c0dd818920332920a7b0c",
        "dataset_index": 20155
      },
      "d_flip_flop_0d1579c9": {
        "rtl_code": "module d_flip_flop (\n    input D,\n    input CLK,\n    output reg Q\n);\n\n    always @(posedge CLK) begin\n        Q <= D;\n    end\n\nendmodule",
        "module_name": "d_flip_flop",
        "module_hash": "0d1579c94c090903be485d5e7b086af1",
        "dataset_index": 6553
      },
      "signed_gte_4bit_4b4611a4": {
        "rtl_code": "module signed_gte_4bit (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input clk,\n    output reg GTE\n);\n\nreg signed [3:0] A_reg, B_reg;\nreg [1:0] stage;\n\nalways @(posedge clk) begin\n    case(stage)\n        2'b00: begin\n            A_reg <= A;\n            B_reg <= B;\n            stage <= 2'b01;\n        end\n        2'b01: begin\n            if (A_reg >= B_reg)\n                GTE <= 1;\n            else\n                GTE <= 0;\n            stage <= 2'b00;\n        end\n    endcase;\nend\n\nendmodule",
        "module_name": "signed_gte_4bit",
        "module_hash": "4b4611a4e1a100944534143a20a85d63",
        "dataset_index": 6387
      },
      "DUC #_e7c65448": {
        "rtl_code": "module DUC #(\n    parameter INPUT_WIDTH = 8,\n    parameter OUTPUT_WIDTH = 8,\n    parameter INTERPOLATION_FACTOR = 4 \n)(\n    input wire clk,\n    input wire reset,\n    input wire [INPUT_WIDTH-1:0] in_signal,\n    output reg [OUTPUT_WIDTH-1:0] out_signal\n);\n\n    reg [INPUT_WIDTH-1:0] interpolated_signal;\n    integer i_count = 0;\n    always @(posedge clk) begin\n        if (reset) begin\n            i_count <= 0;\n            interpolated_signal <= 0;\n        end else begin\n            if (i_count < INTERPOLATION_FACTOR-1) begin\n                interpolated_signal <= 0; // Zero-stuffing\n                i_count <= i_count + 1;\n            end else begin\n                interpolated_signal <= in_signal; // Actual signal sample\n                i_count <= 0;\n            end\n        end\n    end\n    \n    reg [OUTPUT_WIDTH-1:0] filtered_signal;\n    always @(posedge clk) begin\n        filtered_signal <= (interpolated_signal + out_signal) >> 1;\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out_signal <= 0;\n        end else begin\n            out_signal <= filtered_signal ^ {OUTPUT_WIDTH{1'b1}}; \n        end\n    end\n\nendmodule\n",
        "module_name": "DUC #",
        "module_hash": "e7c65448f1ab355e12fed624479f5979",
        "dataset_index": 2
      },
      "ripple_carry_adder_61e149d5": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    S,\n    Cout,\n    A,\n    B,\n    Cin\n);\n\n    output [3:0] S;\n    output Cout;\n    input [3:0] A;\n    input [3:0] B;\n    input Cin;\n\n    wire [3:0] carry_out;\n    wire [3:0] sum;\n\n    // Instantiate full adders\n    full_adder fa0(\n        .S(sum[0]),\n        .Cout(carry_out[0]),\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin)\n    );\n\n    full_adder fa1(\n        .S(sum[1]),\n        .Cout(carry_out[1]),\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry_out[0])\n    );\n\n    full_adder fa2(\n        .S(sum[2]),\n        .Cout(carry_out[2]),\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry_out[1])\n    );\n\n    full_adder fa3(\n        .S(sum[3]),\n        .Cout(Cout),\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry_out[2])\n    );\n\n    // Assign sum output\n    assign S = sum;\n\nendmodule\n\nmodule full_adder (\n    S,\n    Cout,\n    A,\n    B,\n    Cin\n);\n\n    output S;\n    output Cout;\n    input A;\n    input B;\n    input Cin;\n\n    wire sum1;\n    wire sum2;\n\n    // XOR gates\n    xor (sum1, A, B);\n    xor (S, sum1, Cin);\n\n    // AND gate\n    and (sum2, A, B);\n\n    // OR gate\n    or (Cout, sum2, Cin);\n\nendmodule\n",
        "module_name": "ripple_carry_adder",
        "module_hash": "61e149d5d87dfb02c11176df04700244",
        "dataset_index": 4173
      },
      "sprites_shifter_7456a8d5": {
        "rtl_code": "\nmodule sprites_shifter (\n  input clk,          // 28MHz clock\n  input reset,        // reset\n  input aen,          // address enable\n  input [1:0] address,// register address input\n  input [8:0] hpos,   // horizontal beam counter\n  input [15:0] fmode, // fmode input\n  input shift,        // shift signal\n  input [47:0] chip48,// chip48 input\n  input [15:0] data_in,// bus data in\n  output [1:0] sprdata,// serialized sprite data out\n  output reg attach   // sprite is attached\n);\n\n// register names and addresses\nparameter POS  = 2'b00;\nparameter CTL  = 2'b01;\nparameter DATA = 2'b10;\nparameter DATB = 2'b11;\n\n// local signals\nreg [63:0] datla;    // data register A\nreg [63:0] datlb;    // data register B\nreg [63:0] shifta;   // shift register A\nreg [63:0] shiftb;   // shift register B\nreg [8:0] hstart;    // horizontal start value\nreg armed;           // sprite \"armed\" signal\nreg load;            // load shift register signal\nreg load_del;\n\n// switch data according to fmode\nreg [64-1:0] spr_fmode_dat;\n\nalways @ (*) begin\n  case(fmode[3:2])\n    2'b00   : spr_fmode_dat = {data_in, 48'h000000000000};\n    2'b11   : spr_fmode_dat = {data_in, chip48[47:0]};\n    default : spr_fmode_dat = {data_in, chip48[47:32], 32'h00000000};\n  endcase\nend\n\n// generate armed signal\nalways @(posedge clk)\n  if (reset) // reset disables sprite\n    armed <= 0;\n  else if (aen && address == CTL && !reset) // writing CTL register disables sprite\n    armed <= 0;\n  else if (aen && address == DATA && !reset) // writing data register A arms sprite\n    armed <= 1;\n\n// generate load signal\nalways @(posedge clk)\n  if (reset) // reset disables load\n    load <= 0;\n  else if (armed && hpos[7:0] == hstart[7:0] && (fmode[15] || hpos[8] == hstart[8])) // load when horizontal beam counter matches horizontal start value and sprite is armed\n    load <= 1;\n  else\n    load <= 0;\n\nalways @(posedge clk)\n  if (reset) // reset disables load\n    load_del <= 0;\n  else\n    load_del <= load;\n\n// POS register\nalways @(posedge clk)\n  if (aen && address == POS && !reset)\n    hstart[8:0] <= data_in[8:0];\n\n// CTL register\nalways @(posedge clk)\n  if (aen && address == CTL && !reset)\n    attach <= data_in[7];\n\n// data register A\nalways @(posedge clk)\n  if (aen && address == DATA && !reset)\n    datla[63:0] <= spr_fmode_dat;\n\n// data register B\nalways @(posedge clk)\n  if (aen && address == DATB && !reset)\n    datlb[63:0] <= spr_fmode_dat;\n\n// sprite shift register\nalways @(posedge clk)\n  if (load_del) // load new data into shift register\n  begin\n    shifta[63:0] <= datla[63:0];\n    shiftb[63:0] <= datlb[63:0];\n  end\n  else if (shift) // shift left by one bit\n  begin\n    shifta[63:0] <= {shifta[62:0], 1'b0};\n    shiftb[63:0] <= {shiftb[62:0], 1'b0};\n  end\n\n// assign serialized output data\nassign sprdata = {shiftb[63], shifta[63]};\n\nendmodule",
        "module_name": "sprites_shifter",
        "module_hash": "7456a8d5bb4f03b12eb9c771b9233231",
        "dataset_index": 2384
      },
      "top_module_a57b6527": {
        "rtl_code": "\nmodule top_module(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] in_hi,\n    input wire [7:0] in_lo,\n    output wire [15:0] out,\n    output wire parity_bit );\n\n    reg [7:0] in_hi_reg;\n    reg [7:0] in_lo_reg;\n    reg [15:0] out_reg;\n    reg parity_bit_reg;\n\n    wire [15:0] out_wire;\n    wire parity_bit_wire;\n\n    // Pipeline stage 1\n    always @(posedge clk) begin\n        if (rst) begin\n            in_hi_reg <= 8'b0;\n            in_lo_reg <= 8'b0;\n        end else begin\n            in_hi_reg <= in_hi;\n            in_lo_reg <= in_lo;\n        end\n    end\n\n    // Pipeline stage 2\n    always @(posedge clk) begin\n        if (rst) begin\n            out_reg <= 16'b0;\n            parity_bit_reg <= 1'b0;\n        end else begin\n            out_reg <= {in_hi_reg, in_lo_reg};\n            parity_bit_reg <= in_hi_reg ^ in_lo_reg;\n        end\n    end\n\n    // Pipeline stage 3\n    assign out_wire = out_reg;\n    assign parity_bit_wire = parity_bit_reg;\n\n    assign out = out_wire;\n    assign parity_bit = parity_bit_wire;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "a57b65276e1f24c1f9014ac54e8091db",
        "dataset_index": 15994
      },
      "adder4_03068706": {
        "rtl_code": "module adder4(\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] O,\n  output C\n);\n\n  wire [3:0] sum;\n  wire carry1, carry2, carry3;\n\n  // First adder stage\n  full_adder FA1(.A(A[0]), .B(B[0]), .Cin(1'b0), .S(sum[0]), .Cout(carry1));\n\n  // Second adder stage\n  full_adder FA2(.A(A[1]), .B(B[1]), .Cin(carry1), .S(sum[1]), .Cout(carry2));\n\n  // Third adder stage\n  full_adder FA3(.A(A[2]), .B(B[2]), .Cin(carry2), .S(sum[2]), .Cout(carry3));\n\n  // Fourth adder stage\n  full_adder FA4(.A(A[3]), .B(B[3]), .Cin(carry3), .S(sum[3]), .Cout(C));\n\n  assign O = sum;\n\nendmodule\n\nmodule full_adder(\n  input A,\n  input B,\n  input Cin,\n  output S,\n  output Cout\n);\n\n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (A & Cin) | (B & Cin);\n\nendmodule",
        "module_name": "adder4",
        "module_hash": "030687061221cf0045c8df6025b15c23",
        "dataset_index": 8243
      },
      "two_bit_comparator_6023f63b": {
        "rtl_code": "module two_bit_comparator(\n  input [1:0] A,\n  input [1:0] B,\n  output reg Y\n);\n\n  always @(*) begin\n    if (A[1] == B[1]) begin\n      if (A[0] >= B[0]) begin\n        Y = 1;\n      end else begin\n        Y = 0;\n      end\n    end else begin\n      if (A[1] > B[1]) begin\n        Y = 1;\n      end else begin\n        Y = 0;\n      end\n    end\n  end\n\nendmodule",
        "module_name": "two_bit_comparator",
        "module_hash": "6023f63b8e508f91794c0c68a1d1e277",
        "dataset_index": 9097
      },
      "uart_06486d6b": {
        "rtl_code": "\nmodule uart(\n\t    input \t clk, input \t rst, input \t rx, output \t tx, input \t transmit, input [7:0]  tx_byte, output \t received, output [7:0] rx_byte, output \t is_receiving, output \t is_transmitting, output \t recv_error );\n\n   parameter CLOCK_DIVIDE = 217; parameter RX_IDLE = 0;\n   parameter RX_CHECK_START = 1;\n   parameter RX_READ_BITS = 2;\n   parameter RX_CHECK_STOP = 3;\n   parameter RX_DELAY_RESTART = 4;\n   parameter RX_ERROR = 5;\n   parameter RX_RECEIVED = 6;\n\n   parameter TX_IDLE = 0;\n   parameter TX_SENDING = 1;\n   parameter TX_DELAY_RESTART = 2;\n\n   reg [10:0] \t\t rx_clk_divider = CLOCK_DIVIDE;\n   reg [10:0] \t\t tx_clk_divider = CLOCK_DIVIDE;\n\n   reg [2:0] \t\t recv_state = RX_IDLE;\n   reg [5:0] \t\t rx_countdown;\n   reg [3:0] \t\t rx_bits_remaining;\n   reg [7:0] \t\t rx_data;\n\n   reg \t\t\t tx_out = 1'b1;\n   reg [1:0] \t\t tx_state = TX_IDLE;\n   reg [5:0] \t\t tx_countdown;\n   reg [3:0] \t\t tx_bits_remaining;\n   reg [7:0] \t\t tx_data;\n\n   assign received = recv_state == RX_RECEIVED;\n   assign recv_error = recv_state == RX_ERROR;\n   assign is_receiving = recv_state != RX_IDLE;\n   assign rx_byte = rx_data;\n\n   assign tx = tx_out;\n   assign is_transmitting = tx_state != TX_IDLE;\n\n   always @(posedge clk) begin\n      if (rst) begin\n         recv_state = RX_IDLE;\n         tx_state = TX_IDLE;\n      end\n      \n      rx_clk_divider = rx_clk_divider - 1;\n      if (!rx_clk_divider) begin\n         rx_clk_divider = CLOCK_DIVIDE;\n         rx_countdown = rx_countdown - 1;\n      end\n      tx_clk_divider = tx_clk_divider - 1;\n      if (!tx_clk_divider) begin\n         tx_clk_divider = CLOCK_DIVIDE;\n         tx_countdown = tx_countdown - 1;\n      end\n      \n      case (recv_state)\n        RX_IDLE: begin\n           if (!rx) begin\n              rx_clk_divider = CLOCK_DIVIDE;\n              rx_countdown = 2;\n              recv_state = RX_CHECK_START;\n           end\n        end\n        RX_CHECK_START: begin\n           if (!rx_countdown) begin\n              if (!rx) begin\n                 rx_countdown = 4;\n                 rx_bits_remaining = 8;\n                 recv_state = RX_READ_BITS;\n              end else begin\n                 recv_state = RX_ERROR;\n              end\n           end\n        end\n        RX_READ_BITS: begin\n           if (!rx_countdown) begin\n              rx_data = {rx, rx_data[7:1]};\n              rx_countdown = 4;\n              rx_bits_remaining = rx_bits_remaining - 1;\n              recv_state = rx_bits_remaining ? RX_READ_BITS : RX_CHECK_STOP;\n           end\n        end\n        RX_CHECK_STOP: begin\n           if (!rx_countdown) begin\n              recv_state = rx ? RX_RECEIVED : RX_ERROR;\n           end\n        end\n        RX_DELAY_RESTART: begin\n           recv_state = rx_countdown ? RX_DELAY_RESTART : RX_IDLE;\n        end\n        RX_ERROR: begin\n           rx_countdown = 8;\n           recv_state = RX_DELAY_RESTART;\n        end\n        RX_RECEIVED: begin\n           recv_state = RX_IDLE;\n        end\n      endcase\n      \n      case (tx_state)\n        TX_IDLE: begin\n           if (transmit) begin\n              tx_data = tx_byte;\n              tx_clk_divider = CLOCK_DIVIDE;\n              tx_countdown = 4;\n              tx_out = 0;\n              tx_bits_remaining = 8;\n              tx_state = TX_SENDING;\n           end\n        end\n        TX_SENDING: begin\n           if (!tx_countdown) begin\n              if (tx_bits_remaining) begin\n                 tx_bits_remaining = tx_bits_remaining - 1;\n                 tx_out = tx_data[0];\n                 tx_data = {1'b0, tx_data[7:1]};\n                 tx_countdown = 4;\n                 tx_state = TX_SENDING;\n              end else begin\n                 tx_out = 1;\n                 tx_countdown = 8;\n                 tx_state = TX_DELAY_RESTART;\n              end\n           end\n        end\n        TX_DELAY_RESTART: begin\n           tx_state = tx_countdown ? TX_DELAY_RESTART : TX_IDLE;\n        end\n      endcase\n   end\n\nendmodule\n",
        "module_name": "uart",
        "module_hash": "06486d6ba7f7224dcba92dbc783e7855",
        "dataset_index": 23987
      },
      "no_input_circuit_0cba25d9": {
        "rtl_code": "module no_input_circuit (\n  input clk,\n  input reset,\n  output reg out\n);\n\n  parameter S0 = 2'b00; // initial state\n  parameter S1 = 2'b01; // state to output 1\n  parameter S2 = 2'b10; // state to output 0\n\n  reg [1:0] state; // current state of the FSM\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= S0; // reset to initial state\n      out <= 0; // output 0\n    end else begin\n      case (state)\n        S0: begin\n          state <= S1; // go to output 1 state\n          out <= 1; // output 1\n        end\n        S1: begin\n          if (state == 10) begin\n            state <= S2; // go to output 0 state\n            out <= 0; // output 0\n          end else begin\n            state <= state + 1; // increment state\n            out <= 1; // output 1\n          end\n        end\n        S2: begin\n          state <= S2; // stay in output 0 state\n          out <= 0; // output 0\n        end\n      endcase\n    end\n  end\n\nendmodule\n",
        "module_name": "no_input_circuit",
        "module_hash": "0cba25d93b37ef8f1b8e169f785cd4c7",
        "dataset_index": 1595
      },
      "sky130_fd_sc_hdll__nor3_3901dbc7": {
        "rtl_code": "module sky130_fd_sc_hdll__nor3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, C, A, B        );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__nor3",
        "module_hash": "3901dbc79e38d4f52c235d09deb2946a",
        "dataset_index": 8099
      },
      "binary_adder_424d8f67": {
        "rtl_code": "module binary_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] S\n);\n\nalways @(*) begin\n    S = A + B;\n    if (S > 15) begin\n        S = S - 16;\n    end\nend\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "424d8f6738d7087dde2b9615c748f4f4",
        "dataset_index": 7802
      },
      "AllignAdder_358c9030": {
        "rtl_code": "\nmodule AllignAdder(\n\tinput idle_Special,\n\tinput [35:0] cout_Special,\n\tinput [35:0] zout_Special,\n\tinput [31:0] sout_Special,\n\tinput [7:0] difference_Special,\n\tinput clock,\n\toutput reg idle_Allign,\n\toutput reg [35:0] cout_Allign,\n\toutput reg [35:0] zout_Allign,\n\toutput reg [31:0] sout_Allign\n   );\n\nparameter no_idle = 1'b01,\n\t\t\t put_idle = 1'b1;\n\nwire z_sign;\nwire [7:0] z_exponent;\nwire [26:0] z_mantissa;\n\nwire c_sign;\nwire [7:0] c_exponent;\nwire [26:0] c_mantissa;\n\nassign z_sign = zout_Special[35];\nassign z_exponent = zout_Special[34:27] - 127;\nassign z_mantissa = {zout_Special[26:0]};\n\nassign c_sign = cout_Special[35];\nassign c_exponent = cout_Special[34:27] - 127;\nassign c_mantissa = {cout_Special[26:0]};\n\nalways @ (posedge clock)\nbegin\n\t\n\tidle_Allign <= idle_Special;\n\tsout_Allign <= sout_Special;\n\t\n\tif (idle_Special != put_idle) begin\n\t\tif ($signed(c_exponent) > $signed(z_exponent)) begin\n\t\t\tzout_Allign[35] <= zout_Special[35];\n\t\t\tzout_Allign[34:27] <= z_exponent + difference_Special + 127;\n\t\t\tzout_Allign[26:0] <= z_mantissa >> difference_Special;\n\t\t\tzout_Allign[0] <= z_mantissa[0] | z_mantissa[1];\n\t\t\tcout_Allign <= cout_Special;\n\t\tend else if ($signed(c_exponent) <= $signed(z_exponent)) begin\n\t\t\tcout_Allign[35] <= cout_Special[35];\n\t\t\tcout_Allign[34:27] <= c_exponent + difference_Special + 127;\n\t\t\tcout_Allign[26:0] <= c_mantissa >> difference_Special;\n\t\t\tcout_Allign[0] <= c_mantissa[0] | c_mantissa[1];\n\t\t\tzout_Allign <= zout_Special;\n\t\t end\t\t\n\tend\n\t\n\telse begin\n\t\tzout_Allign <= zout_Special;\n\t\tcout_Allign <= cout_Special;\n\tend\nend\n\nendmodule\n",
        "module_name": "AllignAdder",
        "module_hash": "358c9030a97694f6a4cec2278b710c56",
        "dataset_index": 9660
      },
      "dff_counter_f61ffa7a": {
        "rtl_code": "\nmodule dff_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\nreg [11:0] dff_array;\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n  if (reset == 1'b0) begin\n    dff_array <= 12'h5A5;\n    counter <= 4'b0;\n  end else begin\n    dff_array <= {dff_array[10:0], 1'b0};\n    counter <= counter + 1;\n    count <= counter;  // Assign the value of counter to count directly\n  end\nend\n\nendmodule\n",
        "module_name": "dff_counter",
        "module_hash": "f61ffa7a00aa6fd0b75676cf6fca7f7f",
        "dataset_index": 14057
      },
      "comparator_fbb2879a": {
        "rtl_code": "\nmodule comparator (\n    input [2:0] A,\n    input [2:0] B,\n    input [2:0] C,\n    output reg [1:0] Y\n);\n\n    wire Y1_0, Y1_1, Y2_0, Y2_1;\n\n    and (Y1_0, A[2], A[1], C[0]);\n    and (Y2_0, B[2], B[1], C[1]);\n    and (Y1_1, C[2], B[0], Y1_0);\n    and (Y2_1, A[0], Y2_0, Y1_0);\n\n    always @(*) begin\n        if (Y1_0 == 1 && Y2_0 == 1 && Y1_1 == 0 && Y2_1 == 0) begin\n            Y = 2'b00;\n        end else if (Y1_0 == 1 && Y2_0 == 1 && Y1_1 == 0 && Y2_1 == 1) begin\n            Y = 2'b01;\n        end else if (Y1_0 == 1 && Y2_0 == 1 && Y1_1 == 1 && Y2_1 == 0) begin\n            Y = 2'b10;\n        end else begin\n            Y = 2'b11;\n        end\n    end\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "fbb2879a8d80806f4106093072717509",
        "dataset_index": 18887
      },
      "mux32to16_4c304a0d": {
        "rtl_code": "module mux32to16(out , in1 , in2 ,control);\n\noutput [31:0] out;\ninput [31:0] in1,in2;\ninput control;\n\nwire control_not;\nwire [31:0] anded_out_1,anded_out_2;\n\nnot (control_not,control);\n\n\nand (anded_out_1[0] , control_not , in1[0]);\nand (anded_out_1[1] , control_not , in1[1]);\nand (anded_out_1[2] , control_not , in1[2]);\nand (anded_out_1[3] , control_not , in1[3]);\nand (anded_out_1[4] , control_not , in1[4]);\nand (anded_out_1[5] , control_not , in1[5]);\nand (anded_out_1[6] , control_not , in1[6]);\nand (anded_out_1[7] , control_not , in1[7]);\nand (anded_out_1[8] , control_not , in1[8]);\nand (anded_out_1[9] , control_not , in1[9]);\nand (anded_out_1[10] , control_not , in1[10]);\nand (anded_out_1[11] , control_not , in1[11]);\nand (anded_out_1[12] , control_not , in1[12]);\nand (anded_out_1[13] , control_not , in1[13]);\nand (anded_out_1[14] , control_not , in1[14]);\nand (anded_out_1[15] , control_not , in1[15]);\nand (anded_out_1[16] , control_not , in1[16]);\nand (anded_out_1[17] , control_not , in1[17]);\nand (anded_out_1[18] , control_not , in1[18]);\nand (anded_out_1[19] , control_not , in1[19]);\nand (anded_out_1[20] , control_not , in1[20]);\nand (anded_out_1[21] , control_not , in1[21]);\nand (anded_out_1[22] , control_not , in1[22]);\nand (anded_out_1[23] , control_not , in1[23]);\nand (anded_out_1[24] , control_not , in1[24]);\nand (anded_out_1[25] , control_not , in1[25]);\nand (anded_out_1[26] , control_not , in1[26]);\nand (anded_out_1[27] , control_not , in1[27]);\nand (anded_out_1[28] , control_not , in1[28]);\nand (anded_out_1[29] , control_not , in1[29]);\nand (anded_out_1[30] , control_not , in1[30]);\nand (anded_out_1[31] , control_not , in1[31]);\nand (anded_out_2[0] , control , in2[0]);\nand (anded_out_2[1] , control , in2[1]);\nand (anded_out_2[2] , control , in2[2]);\nand (anded_out_2[3] , control , in2[3]);\nand (anded_out_2[4] , control , in2[4]);\nand (anded_out_2[5] , control , in2[5]);\nand (anded_out_2[6] , control , in2[6]);\nand (anded_out_2[7] , control , in2[7]);\nand (anded_out_2[8] , control , in2[8]);\nand (anded_out_2[9] , control , in2[9]);\nand (anded_out_2[10] , control , in2[10]);\nand (anded_out_2[11] , control , in2[11]);\nand (anded_out_2[12] , control , in2[12]);\nand (anded_out_2[13] , control , in2[13]);\nand (anded_out_2[14] , control , in2[14]);\nand (anded_out_2[15] , control , in2[15]);\nand (anded_out_2[16] , control , in2[16]);\nand (anded_out_2[17] , control , in2[17]);\nand (anded_out_2[18] , control , in2[18]);\nand (anded_out_2[19] , control , in2[19]);\nand (anded_out_2[20] , control , in2[20]);\nand (anded_out_2[21] , control , in2[21]);\nand (anded_out_2[22] , control , in2[22]);\nand (anded_out_2[23] , control , in2[23]);\nand (anded_out_2[24] , control , in2[24]);\nand (anded_out_2[25] , control , in2[25]);\nand (anded_out_2[26] , control , in2[26]);\nand (anded_out_2[27] , control , in2[27]);\nand (anded_out_2[28] , control , in2[28]);\nand (anded_out_2[29] , control , in2[29]);\nand (anded_out_2[30] , control , in2[30]);\nand (anded_out_2[31] , control , in2[31]);\nor (out[0] , anded_out_1[0] , anded_out_2[0]);\nor (out[1] , anded_out_1[1] , anded_out_2[1]);\nor (out[2] , anded_out_1[2] , anded_out_2[2]);\nor (out[3] , anded_out_1[3] , anded_out_2[3]);\nor (out[4] , anded_out_1[4] , anded_out_2[4]);\nor (out[5] , anded_out_1[5] , anded_out_2[5]);\nor (out[6] , anded_out_1[6] , anded_out_2[6]);\nor (out[7] , anded_out_1[7] , anded_out_2[7]);\nor (out[8] , anded_out_1[8] , anded_out_2[8]);\nor (out[9] , anded_out_1[9] , anded_out_2[9]);\nor (out[10] , anded_out_1[10] , anded_out_2[10]);\nor (out[11] , anded_out_1[11] , anded_out_2[11]);\nor (out[12] , anded_out_1[12] , anded_out_2[12]);\nor (out[13] , anded_out_1[13] , anded_out_2[13]);\nor (out[14] , anded_out_1[14] , anded_out_2[14]);\nor (out[15] , anded_out_1[15] , anded_out_2[15]);\nor (out[16] , anded_out_1[16] , anded_out_2[16]);\nor (out[17] , anded_out_1[17] , anded_out_2[17]);\nor (out[18] , anded_out_1[18] , anded_out_2[18]);\nor (out[19] , anded_out_1[19] , anded_out_2[19]);\nor (out[20] , anded_out_1[20] , anded_out_2[20]);\nor (out[21] , anded_out_1[21] , anded_out_2[21]);\nor (out[22] , anded_out_1[22] , anded_out_2[22]);\nor (out[23] , anded_out_1[23] , anded_out_2[23]);\nor (out[24] , anded_out_1[24] , anded_out_2[24]);\nor (out[25] , anded_out_1[25] , anded_out_2[25]);\nor (out[26] , anded_out_1[26] , anded_out_2[26]);\nor (out[27] , anded_out_1[27] , anded_out_2[27]);\nor (out[28] , anded_out_1[28] , anded_out_2[28]);\nor (out[29] , anded_out_1[29] , anded_out_2[29]);\nor (out[30] , anded_out_1[30] , anded_out_2[30]);\nor (out[31] , anded_out_1[31] , anded_out_2[31]);\n\n\nendmodule\n\n",
        "module_name": "mux32to16",
        "module_hash": "4c304a0d10eb937c924944da1cb2cf26",
        "dataset_index": 24255
      },
      "jaxa_errorStatus_9e58246f": {
        "rtl_code": "module jaxa_errorStatus (\n                          // inputs:\n                           address,\n                           clk,\n                           in_port,\n                           reset_n,\n\n                          // outputs:\n                           readdata\n                        )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  7: 0] in_port;\n  input            reset_n;\n\n\nwire             clk_en;\nwire    [  7: 0] data_in;\nwire    [  7: 0] read_mux_out;\nreg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {8 {(address == 2'b00)}} & data_in;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "jaxa_errorStatus",
        "module_hash": "9e58246fb78c949141b7c72f3e110141",
        "dataset_index": 2312
      },
      "calculator_955ca80a": {
        "rtl_code": "module calculator(\n  input clk,\n  input reset,\n  input [1:0] op,\n  input [7:0] num1,\n  input [7:0] num2,\n  output reg [7:0] result,\n  output reg overflow,\n  output reg zero\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      result <= 0;\n      overflow <= 0;\n      zero <= 0;\n    end\n    else begin\n      case (op)\n        2'b00: begin // addition\n          result <= num1 + num2;\n          overflow <= (result > 8'hFF);\n          zero <= (result == 0);\n        end\n        2'b01: begin // subtraction\n          result <= num1 - num2;\n          overflow <= (result < 0);\n          zero <= (result == 0);\n        end\n        2'b10: begin // multiplication\n          result <= num1 * num2;\n          overflow <= (result > 8'hFF);\n          zero <= (result == 0);\n        end\n        2'b11: begin // division\n          if (num2 == 0) begin\n            result <= 8'hFF;\n            overflow <= 1;\n            zero <= 0;\n          end\n          else begin\n            result <= num1 / num2;\n            overflow <= 0;\n            zero <= (result == 0);\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "955ca80a8826c7b4f4a734c99ba23da4",
        "dataset_index": 5444
      },
      "TrigFunc_04c858e4": {
        "rtl_code": "\nmodule TrigFunc (\n  input [31:0] x, // angle in radians\n  output [31:0] y // value of sine, cosine, or tangent function at x\n);\n\nparameter n = 10; // number of terms to use in Taylor series approximation\n\nreg [31:0] fact;\nreg [31:0] x_pow;\nreg [31:0] term;\nreg [31:0] sum;\ninteger i;\n\nassign y = sum;\n\nalways @(*) begin\n  sum = 0;\n  x_pow = x;\n  fact = 1;\n  for (i = 0; i < n; i = i + 1) begin\n    if (i % 2 == 0) begin\n      term = x_pow / fact;\n    end else begin\n      term = -x_pow / fact;\n    end\n    sum = sum + term;\n    x_pow = x_pow * x * x;\n    fact = fact * (2 * (i + 1)) * (2 * (i + 1) - 1);\n  end\nend\n\nendmodule\n",
        "module_name": "TrigFunc",
        "module_hash": "04c858e42a975f8358232ba6fc20f760",
        "dataset_index": 19473
      },
      "tmu2_pixout #_c9180d2d": {
        "rtl_code": "\n\nmodule tmu2_pixout #(\n\tparameter fml_depth = 26\n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\toutput reg busy,\n\t\n\tinput pipe_stb_i,\n\toutput reg pipe_ack_o,\n\tinput [fml_depth-5-1:0] burst_addr,\n\tinput [15:0] burst_sel,\n\tinput [255:0] burst_do,\n\t\n\toutput reg [fml_depth-1:0] fml_adr,\n\toutput reg fml_stb,\n\tinput fml_ack,\n\toutput reg [7:0] fml_sel,\n\toutput reg [63:0] fml_do\n);\n\nreg [15:0] burst_sel_r;\nreg [255:0] burst_do_r;\n\nreg load;\nalways @(posedge sys_clk) begin\n\tif(load) begin\n\t\tfml_adr = {burst_addr, 5'd0};\n\t\tburst_sel_r = burst_sel;\n\t\tburst_do_r = burst_do;\n\tend\nend\n\nreg [1:0] bcounter;\nalways @(posedge sys_clk) begin\n\tcase(bcounter)\n\t\t2'd0: begin\n\t\t\tfml_sel <= {\n\t\t\t\tburst_sel_r[15], burst_sel_r[15],\n\t\t\t\tburst_sel_r[14], burst_sel_r[14],\n\t\t\t\tburst_sel_r[13], burst_sel_r[13],\n\t\t\t\tburst_sel_r[12], burst_sel_r[12]\n\t\t\t\t};\n\t\t\tfml_do <= burst_do_r[255:192];\n\t\tend\n\t\t2'd1: begin\n\t\t\tfml_sel <= {\n\t\t\t\tburst_sel_r[11], burst_sel_r[11],\n\t\t\t\tburst_sel_r[10], burst_sel_r[10],\n\t\t\t\tburst_sel_r[ 9], burst_sel_r[ 9],\n\t\t\t\tburst_sel_r[ 8], burst_sel_r[ 8]\n\t\t\t\t};\n\t\t\tfml_do <= burst_do_r[191:128];\n\t\tend\n\t\t2'd2: begin\n\t\t\tfml_sel <= {\n\t\t\t\tburst_sel_r[ 7], burst_sel_r[ 7],\n\t\t\t\tburst_sel_r[ 6], burst_sel_r[ 6],\n\t\t\t\tburst_sel_r[ 5], burst_sel_r[ 5],\n\t\t\t\tburst_sel_r[ 4], burst_sel_r[ 4]\n\t\t\t\t};\n\t\t\tfml_do <= burst_do_r[127: 64];\n\t\tend\n\t\t2'd3: begin\n\t\t\tfml_sel <= {\n\t\t\t\tburst_sel_r[ 3], burst_sel_r[ 3],\n\t\t\t\tburst_sel_r[ 2], burst_sel_r[ 2],\n\t\t\t\tburst_sel_r[ 1], burst_sel_r[ 1],\n\t\t\t\tburst_sel_r[ 0], burst_sel_r[ 0]\n\t\t\t\t};\n\t\t\tfml_do <= burst_do_r[ 63:  0];\n\t\tend\n\tendcase\nend\n\nreg [1:0] state;\nreg [1:0] next_state;\n\nparameter IDLE\t= 2'd0;\nparameter WAIT\t= 2'd1;\nparameter XFER2\t= 2'd2;\nparameter XFER3\t= 2'd3;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tstate <= IDLE;\n\telse\n\t\tstate <= next_state;\nend\n\nalways @(*) begin\n\tnext_state = state;\n\t\n\tbusy = 1'b1;\n\tpipe_ack_o = 1'b0;\n\tfml_stb = 1'b0;\n\t\n\tload = 1'b0;\n\tbcounter = 2'bxx;\n\t\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tbusy = 1'b0;\n\t\t\tpipe_ack_o = 1'b1;\n\t\t\tbcounter = 2'd0;\n\t\t\tif(pipe_stb_i) begin\n\t\t\t\tload = 1'b1;\n\t\t\t\tnext_state = WAIT;\n\t\t\tend\n\t\tend\n\t\tWAIT: begin\n\t\t\tfml_stb = 1'b1;\n\t\t\tbcounter = 2'd0;\n\t\t\tif(fml_ack) begin\n\t\t\t\tbcounter = 2'd1;\n\t\t\t\tnext_state = XFER2;\n\t\t\tend\n\t\tend\n\t\tXFER2: begin\n\t\t\tbcounter = 2'd2;\n\t\t\tnext_state = XFER3;\n\t\tend\n\t\tXFER3: begin\n\t\t\tbcounter = 2'd3;\n\t\t\tnext_state = IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule\n",
        "module_name": "tmu2_pixout #",
        "module_hash": "c9180d2d031ea2393323566cce980480",
        "dataset_index": 9665
      },
      "red_pitaya_dfilt1_6843efdd": {
        "rtl_code": "\n\n\n\nmodule red_pitaya_dfilt1 (\n   input                 adc_clk_i       ,  input                 adc_rstn_i      ,  input      [ 14-1: 0] adc_dat_i       ,  output     [ 14-1: 0] adc_dat_o       ,  input      [ 18-1: 0] cfg_aa_i        ,  input      [ 25-1: 0] cfg_bb_i        ,  input      [ 25-1: 0] cfg_kk_i        ,  input      [ 25-1: 0] cfg_pp_i           );\n\nreg  [ 18-1: 0] cfg_aa_r  ;\nreg  [ 25-1: 0] cfg_bb_r  ;\nreg  [ 25-1: 0] cfg_kk_r  ;\nreg  [ 25-1: 0] cfg_pp_r  ;\n\nalways @(posedge adc_clk_i) begin\n   cfg_aa_r <= cfg_aa_i ;\n   cfg_bb_r <= cfg_bb_i ;\n   cfg_kk_r <= cfg_kk_i ;\n   cfg_pp_r <= cfg_pp_i ;\nend\n\nwire [ 39-1: 0] bb_mult   ;\nwire [ 33-1: 0] r2_sum    ;\nreg  [ 33-1: 0] r1_reg    ;\nreg  [ 23-1: 0] r2_reg    ;\nreg  [ 32-1: 0] r01_reg   ;\nreg  [ 28-1: 0] r02_reg   ;\n\n\nassign bb_mult = $signed(adc_dat_i) * $signed(cfg_bb_r);\nassign r2_sum  = $signed(r01_reg) + $signed(r1_reg);\n\nalways @(posedge adc_clk_i) begin\n   if (adc_rstn_i == 1'b0) begin\n      r1_reg  <= 33'h0 ;\n      r2_reg  <= 23'h0 ;\n      r01_reg <= 32'h0 ;\n      r02_reg <= 28'h0 ;\n   end\n   else begin\n      r1_reg  <= $signed(r02_reg) - $signed(r01_reg) ;\n      r2_reg  <= r2_sum[33-1:10];\n      r01_reg <= {adc_dat_i,18'h0};\n      r02_reg <= bb_mult[39-2:10];\n   end\nend\n\nwire [ 41-1: 0] aa_mult   ;\nwire [ 49-1: 0] r3_sum    ;  reg  [ 23-1: 0] r3_reg    ;\n\n\nassign aa_mult = $signed(r3_reg) * $signed(cfg_aa_r);\nassign r3_sum  = $signed({r2_reg,25'h0}) + $signed({r3_reg,25'h0}) - $signed(aa_mult[41-1:0]);\n\nalways @(posedge adc_clk_i) begin\n   if (adc_rstn_i == 1'b0) begin\n      r3_reg  <= 23'h0 ;\n   end\n   else begin\n      r3_reg  <= r3_sum[49-2:25] ;\n   end\nend\n\nwire [ 40-1: 0] pp_mult   ;\nwire [ 16-1: 0] r4_sum    ;\nreg  [ 15-1: 0] r4_reg    ;\nreg  [ 15-1: 0] r3_shr    ;\n\nassign pp_mult = $signed(r4_reg) * $signed(cfg_pp_r);\nassign r4_sum  = $signed(r3_shr) + $signed(pp_mult[40-2:16]);\n\nalways @(posedge adc_clk_i) begin\n   if (adc_rstn_i == 1'b0) begin\n      r3_shr <= 15'h0 ;\n      r4_reg <= 15'h0 ;\n   end\n   else begin\n      r3_shr <= r3_reg[23-1:8] ;\n      r4_reg <= r4_sum[16-2:0] ;\n   end\nend\n\nwire [ 40-1: 0] kk_mult   ;\nreg  [ 15-1: 0] r4_reg_r  ;\nreg  [ 15-1: 0] r4_reg_rr ;\nreg  [ 14-1: 0] r5_reg    ;\n\nassign kk_mult = $signed(r4_reg_rr) * $signed(cfg_kk_r);\n\nalways @(posedge adc_clk_i) begin\n   if (adc_rstn_i == 1'b0) begin\n      r4_reg_r  <= 15'h0 ;\n      r4_reg_rr <= 15'h0 ;\n      r5_reg    <= 14'h0 ;\n   end\n   else begin\n      r4_reg_r  <= r4_reg   ;\n      r4_reg_rr <= r4_reg_r ;\n\n      if ($signed(kk_mult[40-2:24]) > $signed(14'h1FFF))\n         r5_reg <= 14'h1FFF ;\n      else if ($signed(kk_mult[40-2:24]) < $signed(14'h2000))\n         r5_reg <= 14'h2000 ;\n      else\n         r5_reg <= kk_mult[24+14-1:24];\n   end\nend\n\nassign adc_dat_o = r5_reg ;\n\nendmodule\n",
        "module_name": "red_pitaya_dfilt1",
        "module_hash": "6843efdd9ce2b838712f48adc485b721",
        "dataset_index": 23630
      },
      "full_adder_en_742f59ee": {
        "rtl_code": "module full_adder_en (\n    input A,\n    input B,\n    input Cin,\n    input En,\n    output reg Sum,\n    output reg Cout\n);\n\nalways @(A or B or Cin or En) begin\n    if (En == 1'b1) begin\n        Sum  <= A ^ B ^ Cin;\n        Cout <= (A & B) | (Cin & (A ^ B));\n    end else begin\n        Sum  <= 1'b0;\n        Cout <= 1'b0;\n    end\nend\n\nendmodule",
        "module_name": "full_adder_en",
        "module_hash": "742f59ee735a54f48819b7f8e591b70f",
        "dataset_index": 18455
      },
      "CRC_8571ed39": {
        "rtl_code": "\nmodule CRC (\n  input [n-1:0] in,\n  output reg [m-1:0] out,\n  input clk\n);\n\nparameter n = 8; // number of input bits\nparameter m = 16; // number of output bits\nparameter k = 16; // degree of the generator polynomial\n\nreg [k-1:0] crc_reg;\n\n// Generator polynomial\nreg [k-1:0] gen_poly = {1'b1, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b1};\n\n// CRC generator\ninteger i;\nalways @(posedge clk) begin\n  crc_reg = {in, crc_reg[k-1:n]};\n  for (i = 0; i < n; i = i + 1) begin\n    if (crc_reg[k-1] == 1'b1) begin\n      crc_reg = crc_reg ^ gen_poly;\n    end\n    crc_reg = crc_reg << 1;\n  end\n  out <= {in, crc_reg[n-1:0]};\nend\n\nendmodule",
        "module_name": "CRC",
        "module_hash": "8571ed395b801d6418b87e46646f3ac9",
        "dataset_index": 12309
      },
      "top__cf2eb0f9": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    input [7:0] d,\n    output [3:0] counter_out,\n    output [7:0] shift_reg_out,\n    output [7:0] final_output\n);\n\n    // Circular shift register\n    reg [7:0] shift_reg;\n    always @(negedge clk) begin\n        shift_reg <= {shift_reg[6:0], d};\n    end\n    assign shift_reg_out = shift_reg;\n\n    // 4-bit binary counter\n    reg [3:0] counter;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 4'b1000;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n    assign counter_out = counter;\n\n    // Functional module to add shift_reg and counter\n    reg [7:0] sum;\n    always @(*) begin\n        sum = shift_reg + counter;\n    end\n    assign final_output = sum;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "cf2eb0f9f7827545477171374eda1956",
        "dataset_index": 1333
      },
      "system_auto_cc_0_wr_status_flags_as_16_0f134190": {
        "rtl_code": "\nmodule system_auto_cc_0_wr_status_flags_as_16 (\n  output ram_full_fb_i_reg_0,\n  output [0:0] E,\n  output s_axi_wready,\n  input gic0_gc0_count_d1_reg_3,\n  input s_aclk,\n  input out,\n  input s_axi_wvalid,\n  input [0:0] Q,\n  input [0:0] gnxpm_cdc_rd_pntr_bin_reg_3\n);\n\n  wire [0:0] E;\n  wire [0:0] Q;\n  wire gic0_gc0_count_d1_reg_3;\n  wire [0:0] gnxpm_cdc_rd_pntr_bin_reg_3;\n  wire out;\n  wire ram_full_fb_i;\n  reg ram_full_fb_i_reg = 0;\n  wire ram_full_fb_i_reg_1;\n  wire ram_full_i = 0;\n  wire s_aclk;\n  wire s_axi_wready;\n  wire s_axi_wvalid;\n\n  // LUT2 module instantiation\n  assign E = s_axi_wvalid & ram_full_fb_i_reg;\n\n  // FDPE module instantiation for ram_full_fb_i_reg\n  always @(posedge s_aclk)\n    if (out)\n      ram_full_fb_i_reg <= 1'b1;\n    else\n      ram_full_fb_i_reg <= gic0_gc0_count_d1_reg_3;\n\n  // LUT4 module instantiation\n  assign ram_full_fb_i_reg_1 = ram_full_fb_i_reg & s_axi_wvalid & Q & gnxpm_cdc_rd_pntr_bin_reg_3;\n\n  // LUT1 module instantiation\n  assign s_axi_wready = !ram_full_i;\n  assign ram_full_fb_i_reg_0 = ram_full_fb_i_reg_1;\n\nendmodule",
        "module_name": "system_auto_cc_0_wr_status_flags_as_16",
        "module_hash": "0f134190c25a1162b7eec2591c90bdd4",
        "dataset_index": 3040
      },
      "calculator_e91059fe": {
        "rtl_code": "module calculator(\n    input clk,\n    input op,\n    input [3:0] num1,\n    input [3:0] num2,\n    output reg [3:0] result\n);\n\nalways @(posedge clk) begin\n    if (op == 0) begin\n        result <= num1 + num2;\n    end else begin\n        result <= num1 - num2;\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "e91059fe67d302a2a5c09bb96d010ffe",
        "dataset_index": 6712
      },
      "multiplier_module_692b0499": {
        "rtl_code": "module multiplier_module(\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input [3:0] d,\n    input clk,\n    input rst,\n    output reg [7:0] out\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        out <= 0;\n    end else begin\n        out <= a*b*c*d;\n    end\nend\n\nendmodule",
        "module_name": "multiplier_module",
        "module_hash": "692b0499a0345111a0129c8b871e9902",
        "dataset_index": 14229
      },
      "binary_adder_6194e6f3": {
        "rtl_code": "module binary_adder(\n    input [4:0] a,\n    input [4:0] b,\n    output [4:0] sum,\n    output carry\n);\n\n    wire c1, c2, c3, c4, c5;\n    wire s1, s2, s3, s4, s5;\n\n    // Full Adders\n    full_adder fa1(a[0], b[0], 1'b0, s1, c1);\n    full_adder fa2(a[1], b[1], c1, s2, c2);\n    full_adder fa3(a[2], b[2], c2, s3, c3);\n    full_adder fa4(a[3], b[3], c3, s4, c4);\n    full_adder fa5(a[4], b[4], c4, s5, c5);\n\n    // Sum output\n    assign sum = {s5, s4, s3, s2, s1};\n    \n    // Carry output\n    assign carry = c5;\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    wire s1, c1, c2;\n\n    // Half Adder 1\n    half_adder ha1(a, b, s1, c1);\n    \n    // Half Adder 2\n    half_adder ha2(s1, cin, sum, c2);\n    \n    // Carry output\n    assign cout = c1 | c2;\n\nendmodule\n\nmodule half_adder(\n    input a,\n    input b,\n    output sum,\n    output carry\n);\n\n    // Sum output\n    assign sum = a ^ b;\n    \n    // Carry output\n    assign carry = a & b;\n\nendmodule",
        "module_name": "binary_adder",
        "module_hash": "6194e6f3b58bf0636a8d415bd045e9d3",
        "dataset_index": 4130
      },
      "sparc_tlu_penc64_900a9b1b": {
        "rtl_code": "\n\nmodule sparc_tlu_penc64 (\n   out, \n   in\n   );\n\n   input [63:0] in;\n\n   output [5:0] out;\n\n\n   reg [5:0] \tout;\n   integer \ti;\n   \nalways @ (in)\nbegin\nout = 6'b0;\nfor (i=0;i<64;i=i+1)\n\t    begin\n\t       if (in[i])\n\t\t   out[5:0] = i[5:0];\n\t    end\nend\n   \nendmodule ",
        "module_name": "sparc_tlu_penc64",
        "module_hash": "900a9b1b9212706549aacb0d6313e712",
        "dataset_index": 18554
      },
      "my_fpga_count_dn_1k_0a600441": {
        "rtl_code": "\nmodule my_fpga_count_dn_1k(\n    input clk,\n    input n_rst,\n    input dn,\n    output cnt,\n    output cnt_1k\n);\n\nreg [31:0] cnt_reg;\nreg [3:0] cnt_1k_reg;\nreg [31:0] cnt_1k_period;\nreg [31:0] cnt_1k_period_reg;\nreg [31:0] cnt_1k_period_max = 50000; // 50ms\nreg [31:0] cnt_1k_period_min = 9500; // 9.5ms\nreg [31:0] cnt_1k_period_diff = 500; // 0.5ms\nreg [31:0] cnt_1k_period_inc = 500; // 0.5ms\nreg [31:0] cnt_1k_period_dec = 100; // 0.1ms\nreg [2:0] cnt_1k_divider = 0;\nreg [31:0] cnt_1k_divider_max = 50; // 50 cycles of 1KHz\nreg [31:0] cnt_1k_divider_min = 1; // 1 cycle of 1KHz\nreg [31:0] cnt_1k_divider_diff = 1; // 1 cycle of 1KHz\nreg [31:0] cnt_1k_divider_inc = 1; // 1 cycle of 1KHz\nreg [31:0] cnt_1k_divider_dec = 1; // 1 cycle of 1KHz\n\nalways @(posedge clk) begin\n    if (n_rst) begin\n        cnt_reg <= 0;\n        cnt_1k_reg <= 0;\n        cnt_1k_period <= 0;\n        cnt_1k_period_reg <= 0;\n        cnt_1k_divider <= 0;\n    end else begin\n        cnt_reg <= cnt_reg + dn;\n        cnt_1k_period <= cnt_1k_period + 1;\n        if (cnt_1k_period >= cnt_1k_period_max) begin\n            cnt_1k_period_reg <= cnt_1k_period;\n            cnt_1k_period <= 0;\n            if (cnt_1k_divider < cnt_1k_divider_max) begin\n                cnt_1k_divider <= cnt_1k_divider + cnt_1k_divider_inc;\n            end\n        end\n        if (cnt_1k_divider > 0) begin\n            cnt_1k_divider <= cnt_1k_divider - 1;\n            if (cnt_1k_divider == 0) begin\n                cnt_1k_divider <= cnt_1k_divider_min;\n                cnt_1k_reg <= cnt_reg - cnt_1k_period_reg;\n                cnt_1k_period_reg <= 0;\n                if (cnt_1k_reg > cnt_1k_period_max) begin\n                    cnt_1k_period_max <= cnt_1k_period_max + cnt_1k_period_diff;\n                    cnt_1k_period_min <= cnt_1k_period_min + cnt_1k_period_diff;\n                end else if (cnt_1k_reg < cnt_1k_period_min) begin\n                    cnt_1k_period_max <= cnt_1k_period_max - cnt_1k_period_diff;\n                    cnt_1k_period_min <= cnt_1k_period_min - cnt_1k_period_diff;\n                end\n            end\n        end\n    end\nend\n\nassign cnt = cnt_reg;\nassign cnt_1k = cnt_1k_reg;\n\nendmodule\n",
        "module_name": "my_fpga_count_dn_1k",
        "module_hash": "0a6004418b02e71e433cbc82f466818c",
        "dataset_index": 3177
      },
      "t_ff_aadfd507": {
        "rtl_code": "module t_ff (\n  input clk,\n  input reset,\n  input t,\n  output reg q\n);\n\nalways @(posedge clk, negedge reset) begin\n  if (!reset) begin\n    q <= 1'b0;\n  end else begin\n    if (t) begin\n      q <= ~q;\n    end\n  end\nend\n\nendmodule\n",
        "module_name": "t_ff",
        "module_hash": "aadfd50768bad8f041efaae6f8d8bf88",
        "dataset_index": 19531
      },
      "debnce_ed986e61": {
        "rtl_code": "\n\nmodule debnce\n  (\n  input  wire        sync,\n  input  wire        clk,\n  output reg         event_on,\n  output reg         event_off\n  );\n\n  reg         [15:0] ctr;\n  reg                dly;\n  wire               sat;\n\n  assign sat = (ctr == 16'hffff);\n\n  always @(posedge clk)\n  begin : saturating_counter\n    case ({sync, sat})\n      0: ctr <= 0;\n      1: ctr <= 0;\n      2: ctr <= ctr + 1;\n    endcase\n    dly <= sat;\n    event_on  <= !dly && sat;\n    event_off <= !sat && dly;\n  end\n\n  endmodule",
        "module_name": "debnce",
        "module_hash": "ed986e61a668fb1ab20a6169d654c030",
        "dataset_index": 23922
      },
      "calculator_84c799fd": {
        "rtl_code": "module calculator(\n    input [7:0] A,\n    input [7:0] B,\n    input [1:0] op,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    case (op)\n        2'b00: result = A + B; // Addition\n        2'b01: result = A - B; // Subtraction\n        2'b10: result = A * B; // Multiplication\n        2'b11: result = A / B; // Division\n    endcase\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "84c799fdbc08809ff1c0318ad46c503d",
        "dataset_index": 16161
      },
      "multiplier_e3a2013a": {
        "rtl_code": "module multiplier(\n    input wire clk,       // System clock\n    input wire rst,       // Reset input\n    input wire [15:0] in1, // First 16-bit input\n    input wire [15:0] in2, // Second 16-bit input\n    output reg [31:0] out  // 32-bit output\n);\n\nreg [15:0] shift_reg; // Register to hold shifted input\nreg [31:0] sum_reg;   // Register to hold accumulated output\n\nalways @(posedge clk) begin\n    if (rst) begin\n        shift_reg <= 0;\n        sum_reg <= 0;\n    end else begin\n        // Shift input by one bit and select shifted or original input based on current bit of in1\n        shift_reg <= {shift_reg[14:0], in2[0]};\n        out <= sum_reg + (in1[0] ? shift_reg : in2);\n        sum_reg <= out;\n    end\nend\n\nendmodule\n\nmodule top_module( \n    input wire clk,       // System clock\n    input wire [15:0] in1, // First 16-bit input\n    input wire [15:0] in2, // Second 16-bit input\n    output wire [31:0] out  // 32-bit output\n);\n\nwire [31:0] mult_out;\nmultiplier mult(clk, 1'b0, in1, in2, mult_out); // Instantiate multiplier module\n\n// Functional module to add the two inputs\nassign out = in1 + in2 + mult_out;\n\nendmodule",
        "module_name": "multiplier",
        "module_hash": "e3a2013a7f8a283577701853580bba1e",
        "dataset_index": 3131
      },
      "dual_edge_triggered_ff_0d82f1f7": {
        "rtl_code": "\nmodule dual_edge_triggered_ff (\n  input clk,\n  input d,\n  output reg q\n);\n  reg _q;\n\n  always @(posedge clk) begin\n    _q <= d;\n  end\n\n  always @(negedge clk) begin\n    q <= _q;\n  end\nendmodule\nmodule full_adder (\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (b & cin) | (cin & a);\nendmodule\nmodule ripple_carry_adder (\n  input [3:0] A,\n  input [3:0] B,\n  output [3:0] S,\n  output cout\n);\n  wire [3:0] sum;\n  wire c1, c2, c3;\n\n  full_adder fa0(.a(A[0]), .b(B[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n  full_adder fa1(.a(A[1]), .b(B[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n  full_adder fa2(.a(A[2]), .b(B[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n  full_adder fa3(.a(A[3]), .b(B[3]), .cin(c3), .sum(sum[3]), .cout(cout));\n\n  assign S = sum;\nendmodule\nmodule functional_module (\n  input [3:0] adder_output,\n  input flip_flop_output,\n  output [3:0] final_output\n);\n  assign final_output = adder_output ^ flip_flop_output;\nendmodule\nmodule top_module (\n  input clk,\n  input reset,\n  input [3:0] A,\n  input [3:0] B,\n  input d,\n  output [3:0] S,\n  output q,\n  output [3:0] final_output\n);\n  wire ff_output;\n  wire [3:0] adder_output;\n  wire carry_out;\n\n  dual_edge_triggered_ff ff(.clk(clk), .d(d), .q(ff_output));\n  ripple_carry_adder adder(.A(A), .B(B), .S(adder_output), .cout(carry_out));\n  functional_module fm(.adder_output(adder_output), .flip_flop_output(ff_output), .final_output(final_output));\n\n  assign S = adder_output;\n  assign q = ff_output;\nendmodule",
        "module_name": "dual_edge_triggered_ff",
        "module_hash": "0d82f1f7c4a190ea571b3f17ec09c84f",
        "dataset_index": 12470
      },
      "serial_tx #_276dc6d0": {
        "rtl_code": "module serial_tx #(\n\t\tparameter CLK_PER_BIT = 50,\n\t\tparameter CTR_SIZE = 6\n\t)(\n\t\tinput clk,\n\t\tinput rst,\n\t\toutput tx,\n\t\tinput block,\n\t\toutput busy,\n\t\tinput [7:0] data,\n\t\tinput new_data\n\t);\n\t\n\tlocalparam STATE_SIZE = 2;\n\tlocalparam IDLE = 2'd0,\n\t\t\tSTART_BIT = 2'd1,\n\t\t\tDATA = 2'd2,\n\t\t\tSTOP_BIT = 2'd3;\n\t\n\treg [CTR_SIZE-1:0] ctr_d, ctr_q;\n\treg [2:0] bit_ctr_d, bit_ctr_q;\n\treg [7:0] data_d, data_q;\n\treg [STATE_SIZE-1:0] state_d, state_q = IDLE;\n\treg tx_d, tx_q;\n\treg busy_d, busy_q;\n\treg block_d, block_q;\n\t\n\tassign tx = tx_q;\n\tassign busy = busy_q;\n\t\n\talways @(*) begin\n\t\tblock_d = block;\n\t\tctr_d = ctr_q;\n\t\tbit_ctr_d = bit_ctr_q;\n\t\tdata_d = data_q;\n\t\tstate_d = state_q;\n\t\tbusy_d = busy_q;\n\t\t\n\t\tcase (state_q)\n\t\t\tIDLE: begin\n\t\t\t\tif (block_q) begin\n\t\t\t\t\tbusy_d = 1'b1;\n\t\t\t\t\ttx_d = 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tbusy_d = 1'b0;\n\t\t\t\t\ttx_d = 1'b1;\n\t\t\t\t\tbit_ctr_d = 3'b0;\n\t\t\t\t\tctr_d = 1'b0;\n\t\t\t\t\tif (new_data) begin\n\t\t\t\t\t\tdata_d = data;\n\t\t\t\t\t\tstate_d = START_BIT;\n\t\t\t\t\t\tbusy_d = 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTART_BIT: begin\n\t\t\t\tbusy_d = 1'b1;\n\t\t\t\tctr_d = ctr_q + 1'b1;\n\t\t\t\ttx_d = 1'b0;\n\t\t\t\tif (ctr_q == CLK_PER_BIT - 1) begin\n\t\t\t\t\tctr_d = 1'b0;\n\t\t\t\t\tstate_d = DATA;\n\t\t\t\tend\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tbusy_d = 1'b1;\n\t\t\t\ttx_d = data_q[bit_ctr_q];\n\t\t\t\tctr_d = ctr_q + 1'b1;\n\t\t\t\tif (ctr_q == CLK_PER_BIT - 1) begin\n\t\t\t\t\tctr_d = 1'b0;\n\t\t\t\t\tbit_ctr_d = bit_ctr_q + 1'b1;\n\t\t\t\t\tif (bit_ctr_q == 7) begin\n\t\t\t\t\t\tstate_d = STOP_BIT;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP_BIT: begin\n\t\t\t\tbusy_d = 1'b1;\n\t\t\t\ttx_d = 1'b1;\n\t\t\t\tctr_d = ctr_q + 1'b1;\n\t\t\t\tif (ctr_q == CLK_PER_BIT - 1) begin\n\t\t\t\t\tstate_d = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tstate_d = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (rst) begin\n\t\t\tstate_q <= IDLE;\n\t\t\ttx_q <= 1'b1;\n\t\tend else begin\n\t\t\tstate_q <= state_d;\n\t\t\ttx_q <= tx_d;\n\t\tend\n\t\t\n\t\tblock_q <= block_d;\n\t\tdata_q <= data_d;\n\t\tbit_ctr_q <= bit_ctr_d;\n\t\tctr_q <= ctr_d;\n\t\tbusy_q <= busy_d;\n\tend\n\t\nendmodule",
        "module_name": "serial_tx #",
        "module_hash": "276dc6d0b33bdb03f8a49589c7227ee3",
        "dataset_index": 24076
      },
      "regfileparam_behav_bbd37770": {
        "rtl_code": "module regfileparam_behav \n\t#(parameter BITSIZE = 16,\n\t  parameter ADDSIZE = 4)\n\t(output [BITSIZE-1:0] adat,\n    output [BITSIZE-1:0] bdat,\n\t output [BITSIZE-1:0] zeroDat,\n    input [ADDSIZE-1:0] ra,\t// Read A Address\n    input [ADDSIZE-1:0] rb,\t// Read B Address\n    input [ADDSIZE-1:0] rw,\t// Write Address\n    input [BITSIZE-1:0] wdat,\n    input wren,\n\t input clk, rst\n    );\n\t\n\t integer i;\n\t \n\t reg [BITSIZE-1:0] array_reg [2**ADDSIZE-1:0]; \n\t \n\t always @(posedge clk, negedge rst) begin\n\t\tif(~rst) begin\n\t\t\tfor(i = 0; i < 2**ADDSIZE; i = i + 1) begin\n\t\t\t\tarray_reg[i] <= 0;\n\t\t\tend\n\t\tend\n\t\telse if(wren) begin\n\t\t\tarray_reg[rw] <= wdat;\n\t\tend\n\n\t end\n\t \n\t // Asynchronous Read\n\t assign adat = array_reg[ra];\n\t assign bdat = array_reg[rb];\n\t assign zeroDat = array_reg[0];\n\t\nendmodule",
        "module_name": "regfileparam_behav",
        "module_hash": "bbd3777087ac20627bc3d6dcda4dfe26",
        "dataset_index": 14993
      },
      "ppfifo_data_generator_8de1f8d4": {
        "rtl_code": "module ppfifo_data_generator (\n  input               clk,\n  input               rst,\n  input               i_enable,\n\n  //Ping Pong FIFO Interface\n  input       [1:0]   i_wr_rdy,\n  output  reg [1:0]   o_wr_act,\n  input       [23:0]  i_wr_size,\n  output  reg         o_wr_stb,\n  output  reg [31:0]  o_wr_data\n);\n\nreg   [23:0]          r_count;\nalways @ (posedge clk) begin\n  if (rst) begin\n    o_wr_act        <=  0;\n    o_wr_stb        <=  0;\n    o_wr_data       <=  0;\n    r_count         <=  0;\n  end\n  else begin\n    //Reset strobe signals\n    o_wr_stb        <= 0;\n    if (i_enable) begin\n      if ((i_wr_rdy > 0) && (o_wr_act == 0))begin\n        r_count     <=  0;\n        if (i_wr_rdy[0]) begin\n          //Channel 0 is open\n          o_wr_act[0]  <=  1;\n        end\n        else begin\n          //Channel 1 is open\n          o_wr_act[1]  <=  1;\n        end\n      end\n      else if (o_wr_act > 0) begin\n        if (r_count < i_wr_size) begin\n          //More room left in the buffer\n          r_count   <=  r_count + 1;\n          o_wr_stb  <=  1;\n          //put the count in the data\n          o_wr_data <=  r_count;\n        end\n        else begin\n          //Filled up the buffer, release it\n          o_wr_act  <=  0;\n        end\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "ppfifo_data_generator",
        "module_hash": "8de1f8d4d7c8de8d6ae62c0462b71bf4",
        "dataset_index": 12569
      },
      "bpm_from_interval_2158ee12": {
        "rtl_code": "\n\nmodule bpm_from_interval(\n    input [31:0] counter, \t\t\t  input wire [7:0] default_bpm,  output wire [7:0] counted_bpm  );\n\t\t\t\t\t\t\t\t\n\tassign counted_bpm = (counter < 32'd23529 ) ? 254 : (counter < 32'd23622 ) ? 253 : (counter < 32'd23715 ) ? 252 : (counter < 32'd23809 ) ? 251 : \n\t\t\t\t\t\t\t\t(counter < 32'd23904 ) ? 250 :\n\t\t\t\t\t\t\t\t(counter < 32'd24000 ) ? 249 :\n\t\t\t\t\t\t\t\t(counter < 32'd24096 ) ? 248 :\n\t\t\t\t\t\t\t\t(counter < 32'd24193 ) ? 247 :\n\t\t\t\t\t\t\t\t(counter < 32'd24291 ) ? 246 :\n\t\t\t\t\t\t\t\t(counter < 32'd24390 ) ? 245 :\n\t\t\t\t\t\t\t\t(counter < 32'd24489 ) ? 244 :\n\t\t\t\t\t\t\t\t(counter < 32'd24590 ) ? 243 :\n\t\t\t\t\t\t\t\t(counter < 32'd24691 ) ? 242 :\n\t\t\t\t\t\t\t\t(counter < 32'd24793 ) ? 241 :\n\t\t\t\t\t\t\t\t(counter < 32'd24896 ) ? 240 :\n\t\t\t\t\t\t\t\t(counter < 32'd25000 ) ? 239 :\n\t\t\t\t\t\t\t\t(counter < 32'd25104 ) ? 238 :\n\t\t\t\t\t\t\t\t(counter < 32'd25210 ) ? 237 :\n\t\t\t\t\t\t\t\t(counter < 32'd25316 ) ? 236 :\n\t\t\t\t\t\t\t\t(counter < 32'd25423 ) ? 235 :\n\t\t\t\t\t\t\t\t(counter < 32'd25531 ) ? 234 :\n\t\t\t\t\t\t\t\t(counter < 32'd25641 ) ? 233 :\n\t\t\t\t\t\t\t\t(counter < 32'd25751 ) ? 232 :\n\t\t\t\t\t\t\t\t(counter < 32'd25862 ) ? 231 :\n\t\t\t\t\t\t\t\t(counter < 32'd25974 ) ? 230 :\n\t\t\t\t\t\t\t\t(counter < 32'd26086 ) ? 229 :\n\t\t\t\t\t\t\t\t(counter < 32'd26200 ) ? 228 :\n\t\t\t\t\t\t\t\t(counter < 32'd26315 ) ? 227 :\n\t\t\t\t\t\t\t\t(counter < 32'd26431 ) ? 226 :\n\t\t\t\t\t\t\t\t(counter < 32'd26548 ) ? 225 :\n\t\t\t\t\t\t\t\t(counter < 32'd26666 ) ? 224 :\n\t\t\t\t\t\t\t\t(counter < 32'd26785 ) ? 223 :\n\t\t\t\t\t\t\t\t(counter < 32'd26905 ) ? 222 :\n\t\t\t\t\t\t\t\t(counter < 32'd27027 ) ? 221 :\n\t\t\t\t\t\t\t\t(counter < 32'd27149 ) ? 220 :\n\t\t\t\t\t\t\t\t(counter < 32'd27272 ) ? 219 :\n\t\t\t\t\t\t\t\t(counter < 32'd27397 ) ? 218 :\n\t\t\t\t\t\t\t\t(counter < 32'd27522 ) ? 217 :\n\t\t\t\t\t\t\t\t(counter < 32'd27649 ) ? 216 :\n\t\t\t\t\t\t\t\t(counter < 32'd27777 ) ? 215 :\n\t\t\t\t\t\t\t\t(counter < 32'd27906 ) ? 214 :\n\t\t\t\t\t\t\t\t(counter < 32'd28037 ) ? 213 :\n\t\t\t\t\t\t\t\t(counter < 32'd28169 ) ? 212 :\n\t\t\t\t\t\t\t\t(counter < 32'd28301 ) ? 211 :\n\t\t\t\t\t\t\t\t(counter < 32'd28436 ) ? 210 :\n\t\t\t\t\t\t\t\t(counter < 32'd28571 ) ? 209 :\n\t\t\t\t\t\t\t\t(counter < 32'd28708 ) ? 208 :\n\t\t\t\t\t\t\t\t(counter < 32'd28846 ) ? 207 :\n\t\t\t\t\t\t\t\t(counter < 32'd28985 ) ? 206 :\n\t\t\t\t\t\t\t\t(counter < 32'd29126 ) ? 205 :\n\t\t\t\t\t\t\t\t(counter < 32'd29268 ) ? 204 :\n\t\t\t\t\t\t\t\t(counter < 32'd29411 ) ? 203 :\n\t\t\t\t\t\t\t\t(counter < 32'd29556 ) ? 202 :\n\t\t\t\t\t\t\t\t(counter < 32'd29702 ) ? 201 :\n\t\t\t\t\t\t\t\t(counter < 32'd29850 ) ? 200 :\n\t\t\t\t\t\t\t\t(counter < 32'd30000 ) ? 199 :\n\t\t\t\t\t\t\t\t(counter < 32'd30150 ) ? 198 :\n\t\t\t\t\t\t\t\t(counter < 32'd30303 ) ? 197 :\n\t\t\t\t\t\t\t\t(counter < 32'd30456 ) ? 196 :\n\t\t\t\t\t\t\t\t(counter < 32'd30612 ) ? 195 :\n\t\t\t\t\t\t\t\t(counter < 32'd30769 ) ? 194 :\n\t\t\t\t\t\t\t\t(counter < 32'd30927 ) ? 193 :\n\t\t\t\t\t\t\t\t(counter < 32'd31088 ) ? 192 :\n\t\t\t\t\t\t\t\t(counter < 32'd31250 ) ? 191 :\n\t\t\t\t\t\t\t\t(counter < 32'd31413 ) ? 190 :\n\t\t\t\t\t\t\t\t(counter < 32'd31578 ) ? 189 :\n\t\t\t\t\t\t\t\t(counter < 32'd31746 ) ? 188 :\n\t\t\t\t\t\t\t\t(counter < 32'd31914 ) ? 187 :\n\t\t\t\t\t\t\t\t(counter < 32'd32085 ) ? 186 :\n\t\t\t\t\t\t\t\t(counter < 32'd32258 ) ? 185 :\n\t\t\t\t\t\t\t\t(counter < 32'd32432 ) ? 184 :\n\t\t\t\t\t\t\t\t(counter < 32'd32608 ) ? 183 :\n\t\t\t\t\t\t\t\t(counter < 32'd32786 ) ? 182 :\n\t\t\t\t\t\t\t\t(counter < 32'd32967 ) ? 181 :\n\t\t\t\t\t\t\t\t(counter < 32'd33149 ) ? 180 :\n\t\t\t\t\t\t\t\t(counter < 32'd33333 ) ? 179 :\n\t\t\t\t\t\t\t\t(counter < 32'd33519 ) ? 178 :\n\t\t\t\t\t\t\t\t(counter < 32'd33707 ) ? 177 :\n\t\t\t\t\t\t\t\t(counter < 32'd33898 ) ? 176 :\n\t\t\t\t\t\t\t\t(counter < 32'd34090 ) ? 175 :\n\t\t\t\t\t\t\t\t(counter < 32'd34285 ) ? 174 :\n\t\t\t\t\t\t\t\t(counter < 32'd34482 ) ? 173 :\n\t\t\t\t\t\t\t\t(counter < 32'd34682 ) ? 172 :\n\t\t\t\t\t\t\t\t(counter < 32'd34883 ) ? 171 :\n\t\t\t\t\t\t\t\t(counter < 32'd35087 ) ? 170 :\n\t\t\t\t\t\t\t\t(counter < 32'd35294 ) ? 169 :\n\t\t\t\t\t\t\t\t(counter < 32'd35502 ) ? 168 :\n\t\t\t\t\t\t\t\t(counter < 32'd35714 ) ? 167 :\n\t\t\t\t\t\t\t\t(counter < 32'd35928 ) ? 166 :\n\t\t\t\t\t\t\t\t(counter < 32'd36144 ) ? 165 :\n\t\t\t\t\t\t\t\t(counter < 32'd36363 ) ? 164 :\n\t\t\t\t\t\t\t\t(counter < 32'd36585 ) ? 163 :\n\t\t\t\t\t\t\t\t(counter < 32'd36809 ) ? 162 :\n\t\t\t\t\t\t\t\t(counter < 32'd37037 ) ? 161 :\n\t\t\t\t\t\t\t\t(counter < 32'd37267 ) ? 160 :\n\t\t\t\t\t\t\t\t(counter < 32'd37500 ) ? 159 :\n\t\t\t\t\t\t\t\t(counter < 32'd37735 ) ? 158 :\n\t\t\t\t\t\t\t\t(counter < 32'd37974 ) ? 157 :\n\t\t\t\t\t\t\t\t(counter < 32'd38216 ) ? 156 :\n\t\t\t\t\t\t\t\t(counter < 32'd38461 ) ? 155 :\n\t\t\t\t\t\t\t\t(counter < 32'd38709 ) ? 154 :\n\t\t\t\t\t\t\t\t(counter < 32'd38961 ) ? 153 :\n\t\t\t\t\t\t\t\t(counter < 32'd39215 ) ? 152 :\n\t\t\t\t\t\t\t\t(counter < 32'd39473 ) ? 151 :\n\t\t\t\t\t\t\t\t(counter < 32'd39735 ) ? 150 :\n\t\t\t\t\t\t\t\t(counter < 32'd40000 ) ? 149 :\n\t\t\t\t\t\t\t\t(counter < 32'd40268 ) ? 148 :\n\t\t\t\t\t\t\t\t(counter < 32'd40540 ) ? 147 :\n\t\t\t\t\t\t\t\t(counter < 32'd40816 ) ? 146 :\n\t\t\t\t\t\t\t\t(counter < 32'd41095 ) ? 145 :\n\t\t\t\t\t\t\t\t(counter < 32'd41379 ) ? 144 :\n\t\t\t\t\t\t\t\t(counter < 32'd41666 ) ? 143 :\n\t\t\t\t\t\t\t\t(counter < 32'd41958 ) ? 142 :\n\t\t\t\t\t\t\t\t(counter < 32'd42253 ) ? 141 :\n\t\t\t\t\t\t\t\t(counter < 32'd42553 ) ? 140 :\n\t\t\t\t\t\t\t\t(counter < 32'd42857 ) ? 139 :\n\t\t\t\t\t\t\t\t(counter < 32'd43165 ) ? 138 :\n\t\t\t\t\t\t\t\t(counter < 32'd43478 ) ? 137 :\n\t\t\t\t\t\t\t\t(counter < 32'd43795 ) ? 136 :\n\t\t\t\t\t\t\t\t(counter < 32'd44117 ) ? 135 :\n\t\t\t\t\t\t\t\t(counter < 32'd44444 ) ? 134 :\n\t\t\t\t\t\t\t\t(counter < 32'd44776 ) ? 133 :\n\t\t\t\t\t\t\t\t(counter < 32'd45112 ) ? 132 :\n\t\t\t\t\t\t\t\t(counter < 32'd45454 ) ? 131 :\n\t\t\t\t\t\t\t\t(counter < 32'd45801 ) ? 130 :\n\t\t\t\t\t\t\t\t(counter < 32'd46153 ) ? 129 :\n\t\t\t\t\t\t\t\t(counter < 32'd46511 ) ? 128 :\n\t\t\t\t\t\t\t\t(counter < 32'd46875 ) ? 127 :\n\t\t\t\t\t\t\t\t(counter < 32'd47244 ) ? 126 :\n\t\t\t\t\t\t\t\t(counter < 32'd47619 ) ? 125 :\n\t\t\t\t\t\t\t\t(counter < 32'd48000 ) ? 124 :\n\t\t\t\t\t\t\t\t(counter < 32'd48387 ) ? 123 :\n\t\t\t\t\t\t\t\t(counter < 32'd48780 ) ? 122 :\n\t\t\t\t\t\t\t\t(counter < 32'd49180 ) ? 121 :\n\t\t\t\t\t\t\t\t(counter < 32'd49586 ) ? 120 :\n\t\t\t\t\t\t\t\t(counter < 32'd50000 ) ? 119 :\n\t\t\t\t\t\t\t\t(counter < 32'd50420 ) ? 118 :\n\t\t\t\t\t\t\t\t(counter < 32'd50847 ) ? 117 :\n\t\t\t\t\t\t\t\t(counter < 32'd51282 ) ? 116 :\n\t\t\t\t\t\t\t\t(counter < 32'd51724 ) ? 115 :\n\t\t\t\t\t\t\t\t(counter < 32'd52173 ) ? 114 :\n\t\t\t\t\t\t\t\t(counter < 32'd52631 ) ? 113 :\n\t\t\t\t\t\t\t\t(counter < 32'd53097 ) ? 112 :\n\t\t\t\t\t\t\t\t(counter < 32'd53571 ) ? 111 :\n\t\t\t\t\t\t\t\t(counter < 32'd54054 ) ? 110 :\n\t\t\t\t\t\t\t\t(counter < 32'd54545 ) ? 109 :\n\t\t\t\t\t\t\t\t(counter < 32'd55045 ) ? 108 :\n\t\t\t\t\t\t\t\t(counter < 32'd55555 ) ? 107 :\n\t\t\t\t\t\t\t\t(counter < 32'd56074 ) ? 106 :\n\t\t\t\t\t\t\t\t(counter < 32'd56603 ) ? 105 :\n\t\t\t\t\t\t\t\t(counter < 32'd57142 ) ? 104 :\n\t\t\t\t\t\t\t\t(counter < 32'd57692 ) ? 103 :\n\t\t\t\t\t\t\t\t(counter < 32'd58252 ) ? 102 :\n\t\t\t\t\t\t\t\t(counter < 32'd58823 ) ? 101 :\n\t\t\t\t\t\t\t\t(counter < 32'd59405 ) ? 100 :\n\t\t\t\t\t\t\t\t(counter < 32'd60000 ) ? 99 :\n\t\t\t\t\t\t\t\t(counter < 32'd60606 ) ? 98 :\n\t\t\t\t\t\t\t\t(counter < 32'd61224 ) ? 97 :\n\t\t\t\t\t\t\t\t(counter < 32'd61855 ) ? 96 :\n\t\t\t\t\t\t\t\t(counter < 32'd62500 ) ? 95 :\n\t\t\t\t\t\t\t\t(counter < 32'd63157 ) ? 94 :\n\t\t\t\t\t\t\t\t(counter < 32'd63829 ) ? 93 :\n\t\t\t\t\t\t\t\t(counter < 32'd64516 ) ? 92 :\n\t\t\t\t\t\t\t\t(counter < 32'd65217 ) ? 91 :\n\t\t\t\t\t\t\t\t(counter < 32'd65934 ) ? 90 :\n\t\t\t\t\t\t\t\t(counter < 32'd66666 ) ? 89 :\n\t\t\t\t\t\t\t\t(counter < 32'd67415 ) ? 88 :\n\t\t\t\t\t\t\t\t(counter < 32'd68181 ) ? 87 :\n\t\t\t\t\t\t\t\t(counter < 32'd68965 ) ? 86 :\n\t\t\t\t\t\t\t\t(counter < 32'd69767 ) ? 85 :\n\t\t\t\t\t\t\t\t(counter < 32'd70588 ) ? 84 :\n\t\t\t\t\t\t\t\t(counter < 32'd71428 ) ? 83 :\n\t\t\t\t\t\t\t\t(counter < 32'd72289 ) ? 82 :\n\t\t\t\t\t\t\t\t(counter < 32'd73170 ) ? 81 :\n\t\t\t\t\t\t\t\t(counter < 32'd74074 ) ? 80 :\n\t\t\t\t\t\t\t\t(counter < 32'd75000 ) ? 79 :\n\t\t\t\t\t\t\t\t(counter < 32'd75949 ) ? 78 :\n\t\t\t\t\t\t\t\t(counter < 32'd76923 ) ? 77 :\n\t\t\t\t\t\t\t\t(counter < 32'd77922 ) ? 76 :\n\t\t\t\t\t\t\t\t(counter < 32'd78947 ) ? 75 :\n\t\t\t\t\t\t\t\t(counter < 32'd80000 ) ? 74 :\n\t\t\t\t\t\t\t\t(counter < 32'd81081 ) ? 73 :\n\t\t\t\t\t\t\t\t(counter < 32'd82191 ) ? 72 :\n\t\t\t\t\t\t\t\t(counter < 32'd83333 ) ? 71 :\n\t\t\t\t\t\t\t\t(counter < 32'd84507 ) ? 70 :\n\t\t\t\t\t\t\t\t(counter < 32'd85714 ) ? 69 :\n\t\t\t\t\t\t\t\t(counter < 32'd86956 ) ? 68 :\n\t\t\t\t\t\t\t\t(counter < 32'd88235 ) ? 67 :\n\t\t\t\t\t\t\t\t(counter < 32'd89552 ) ? 66 :\n\t\t\t\t\t\t\t\t(counter < 32'd90909 ) ? 65 :\n\t\t\t\t\t\t\t\t(counter < 32'd92307 ) ? 64 :\n\t\t\t\t\t\t\t\t(counter < 32'd93750 ) ? 63 :\n\t\t\t\t\t\t\t\t(counter < 32'd95238 ) ? 62 :\n\t\t\t\t\t\t\t\t(counter < 32'd96774 ) ? 61 :\n\t\t\t\t\t\t\t\t(counter < 32'd98360 ) ? 60 :\n\t\t\t\t\t\t\t\t(counter < 32'd100000 ) ? 59 :\n\t\t\t\t\t\t\t\t(counter < 32'd101694 ) ? 58 :\n\t\t\t\t\t\t\t\t(counter < 32'd103448 ) ? 57 :\n\t\t\t\t\t\t\t\t(counter < 32'd105263 ) ? 56 :\n\t\t\t\t\t\t\t\t(counter < 32'd107142 ) ? 55 :\n\t\t\t\t\t\t\t\t(counter < 32'd109090 ) ? 54 :\n\t\t\t\t\t\t\t\t(counter < 32'd111111 ) ? 53 :\n\t\t\t\t\t\t\t\t(counter < 32'd113207 ) ? 52 :\n\t\t\t\t\t\t\t\t(counter < 32'd115384 ) ? 51 :\n\t\t\t\t\t\t\t\t(counter < 32'd117647 ) ? 50 :\n\t\t\t\t\t\t\t\t(counter < 32'd120000 ) ? 49 :\n\t\t\t\t\t\t\t\t(counter < 32'd122448 ) ? 48 :\n\t\t\t\t\t\t\t\t(counter < 32'd125000 ) ? 47 :\n\t\t\t\t\t\t\t\t(counter < 32'd127659 ) ? 46 :\n\t\t\t\t\t\t\t\t(counter < 32'd130434 ) ? 45 :\n\t\t\t\t\t\t\t\t(counter < 32'd133333 ) ? 44 :\n\t\t\t\t\t\t\t\t(counter < 32'd136363 ) ? 43 :\n\t\t\t\t\t\t\t\t(counter < 32'd139534 ) ? 42 :\n\t\t\t\t\t\t\t\t(counter < 32'd142857 ) ? 41 :\n\t\t\t\t\t\t\t\t(counter < 32'd146341 ) ? 40 :\n\t\t\t\t\t\t\t\t(counter < 32'd150000 ) ? 39 :\n\t\t\t\t\t\t\t\t(counter < 32'd153846 ) ? 38 :\n\t\t\t\t\t\t\t\t(counter < 32'd157894 ) ? 37 :\n\t\t\t\t\t\t\t\t(counter < 32'd162162 ) ? 36 :\n\t\t\t\t\t\t\t\t(counter < 32'd166666 ) ? 35 :\n\t\t\t\t\t\t\t\t(counter < 32'd171428 ) ? 34 :\n\t\t\t\t\t\t\t\t(counter < 32'd176470 ) ? 33 :\n\t\t\t\t\t\t\t\t(counter < 32'd181818 ) ? 32 :\n\t\t\t\t\t\t\t\t(counter < 32'd187500 ) ? 31 :\n\t\t\t\t\t\t\t\t(counter < 32'd193548 ) ? 30 : default_bpm;\nendmodule\n",
        "module_name": "bpm_from_interval",
        "module_hash": "2158ee12ad9f739585106f9619e460fa",
        "dataset_index": 12338
      },
      "parity_generator_08db5b95": {
        "rtl_code": "module parity_generator (\n    input [7:0] in,\n    output parity);\n\n    assign parity = ^in;\n\nendmodule",
        "module_name": "parity_generator",
        "module_hash": "08db5b95be3f8be10b4b7281607db15f",
        "dataset_index": 8321
      },
      "signal_converter_a9af3b94": {
        "rtl_code": "module signal_converter(input [3:0] input_signal, output [1:0] output_signal);\n    reg [1:0] output_reg;\n    \n    always @(*) begin\n        if (input_signal < 6) begin\n            output_reg = input_signal >> 1;\n        end else begin\n            output_reg = input_signal - 4;\n        end\n    end\n    \n    assign output_signal = output_reg;\nendmodule",
        "module_name": "signal_converter",
        "module_hash": "a9af3b94659b21d90119ba4718efd4c0",
        "dataset_index": 2744
      },
      "barrel_shifter_c847dc27": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [15:0] A, // 16-bit input\n    input [3:0] B, // 4-bit shift amount\n    output reg [15:0] Y // 16-bit output\n);\n\nreg [15:0] stage1_out;\nreg [15:0] stage2_out;\nreg [15:0] stage3_out;\n\nalways @(*) begin\n    case (B)\n        4'b0000: begin // No shift\n            Y = A;\n        end\n        4'b0001: begin // Shift right by 1 bit\n            stage1_out = {16{A[15]}};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0010: begin // Shift right by 2 bits\n            stage1_out = {16{A[15]}};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0011: begin // Shift right by 3 bits\n            stage1_out = {16{A[15]}};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0100: begin // Shift right by 4 bits\n            stage1_out = {A[11:0], A[15:12]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0101: begin // Shift right by 5 bits\n            stage1_out = {A[10:0], A[15:11]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0110: begin // Shift right by 6 bits\n            stage1_out = {A[9:0], A[15:10]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b0111: begin // Shift right by 7 bits\n            stage1_out = {A[8:0], A[15:9]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1000: begin // Shift right by 8 bits\n            stage1_out = {A[7:0], A[15:8]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1001: begin // Shift right by 9 bits\n            stage1_out = {A[6:0], A[15:7]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1010: begin // Shift right by 10 bits\n            stage1_out = {A[5:0], A[15:6]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1011: begin // Shift right by 11 bits\n            stage1_out = {A[4:0], A[15:5]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1100: begin // Shift right by 12 bits\n            stage1_out = {A[3:0], A[15:4]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1101: begin // Shift right by 13 bits\n            stage1_out = {A[2:0], A[15:3]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1110: begin // Shift right by 14 bits\n            stage1_out = {A[1:0], A[15:2]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n        4'b1111: begin // Shift right by 15 bits\n            stage1_out = {A[0], A[15:1]};\n            stage2_out = stage1_out;\n            stage3_out = stage2_out;\n            Y = stage3_out;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "c847dc2751069daf4f315fa8f5d0dbe6",
        "dataset_index": 17540
      },
      "bw_r_idct_array_69511628": {
        "rtl_code": "module bw_r_idct_array(\n  input we,\n  input clk,\n  input [32:0] wr_data,\n  input [6:0] addr,\n  input [3:0] dec_wrway_y,\n  input [1:0] way,\n  output reg [32:0] rd_data\n);\n\n  // Declare array\n  reg [32:0] array[511:0]  ;\n  \n\n  \n  // Read/write operation\n  always @(negedge clk) begin\n    if (we) begin\n      array[addr] <= wr_data;\n    end else begin\n      rd_data <= array[addr];\n    end\n  end\n  \nendmodule",
        "module_name": "bw_r_idct_array",
        "module_hash": "69511628efbcf539016cbea54fe16624",
        "dataset_index": 3111
      },
      "pulse_generator #_8ee7ce74": {
        "rtl_code": "module pulse_generator #(\n  parameter WIDTH=8\n) (\n  input clock,\n  input reset,\n  input enable,\n  input [WIDTH-1:0] rate,\n  input strobe_fast,\n  output reg strobe_slow\n);\n\n  reg [WIDTH-1:0] counter;\n  wire now = (counter == 1);\n  \n  always @(posedge clock)\n    if(reset)\n      counter <= 0; \n    else if (~enable)\n      counter <= rate;\n    else if(strobe_fast)\n    begin\n      if(now)\n        counter <= rate;\n      else \n        counter <= counter - 1;\n    end\n\n  always @*\n    strobe_slow = now && enable && strobe_fast;\n\nendmodule",
        "module_name": "pulse_generator #",
        "module_hash": "8ee7ce740cc788e8c083e76cfc4cd8e4",
        "dataset_index": 7169
      },
      "WF_08cf1fb5": {
        "rtl_code": "module WF(\n\t\n\ti_op        ,  \n\n\ti_wf_in     ,  \n\t\n\ti_wk        ,   \n\t\n\to_wf_out          \n);\n\n\ninput        i_op           ;  \n\ninput[63:0]  i_wf_in        ;  \n\t\ninput[31:0]  i_wk           ;   \n\noutput[63:0] o_wf_out       ;  \n\n\nwire[63:0]  w_wf_out     ;\nwire[7:0]  w_wf_out7     ;  \nwire[7:0]  w_wf_out6     ;  \nwire[7:0]  w_wf_out5     ;  \nwire[7:0]  w_wf_out4     ;  \nwire[7:0]  w_wf_out3     ;  \nwire[7:0]  w_wf_out2     ;  \nwire[7:0]  w_wf_out1     ;  \nwire[7:0]  w_wf_out0     ;  \n\nassign w_wf_out7 = i_wf_in[63:56];\nassign w_wf_out6 = i_wf_in[55:48] ^ i_wk[31:24];\nassign w_wf_out5 = i_wf_in[47:40];\nassign w_wf_out4 = (i_op == 0) ? (i_wf_in[39:32] + i_wk[23:16]) : \n                                 (i_wf_in[39:32] - i_wk[23:16]) ;\nassign w_wf_out3 = i_wf_in[31:24];\nassign w_wf_out2 = i_wf_in[23:16] ^ i_wk[15:8];\nassign w_wf_out1 = i_wf_in[15:8];\nassign w_wf_out0 = (i_op == 0) ? (i_wf_in[7:0] + i_wk[7:0]) : \n                                 (i_wf_in[7:0] - i_wk[7:0]) ; \n\nassign w_wf_out = {w_wf_out7, w_wf_out6, w_wf_out5, w_wf_out4, w_wf_out3, w_wf_out2, w_wf_out1, w_wf_out0}; \nassign o_wf_out = w_wf_out;\n\nendmodule\n\n\n",
        "module_name": "WF",
        "module_hash": "08cf1fb5af8f27d251bbe29ccb3a97dd",
        "dataset_index": 22546
      },
      "barrel_shifter_a545f604": {
        "rtl_code": "\nmodule barrel_shifter (\n    input clk,\n    input [15:0] A,\n    input [3:0] B,\n    input S,\n    output [15:0] P\n);\n\nreg [15:0] A_reg;\nreg [3:0] B_reg;\nreg S_reg;\n\nalways @(posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    S_reg <= S;\nend\n\nwire [15:0] P_reg;\n\nassign P_reg = S_reg ? {A_reg[15-B_reg+1:0], A_reg[15:15-B_reg+1]} : {A_reg[15:B_reg], 16'b0};\n\nassign P = P_reg;\n\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "a545f604e7d27d5f67d583e2c9203c29",
        "dataset_index": 3157
      },
      "dual_ps2_ioadapter_04051bb6": {
        "rtl_code": "module dual_ps2_ioadapter (\n  ps2_clk_rx_1,     ps2_clk_rx_2,     ps2_clk_tx_1,     ps2_clk_tx_2,     ps2_d_rx_1,       ps2_d_rx_2,       ps2_d_tx_1,       ps2_d_tx_2,       ps2_mouse_clk_I,  ps2_mouse_clk_O,  ps2_mouse_clk_T,  ps2_mouse_data_I, ps2_mouse_data_O, ps2_mouse_data_T, ps2_keyb_clk_I,   ps2_keyb_clk_O,   ps2_keyb_clk_T,   ps2_keyb_data_I,  ps2_keyb_data_O,  ps2_keyb_data_T   );\n\n  output ps2_clk_rx_1;\n  output ps2_clk_rx_2;\n  input  ps2_clk_tx_1;\n  input  ps2_clk_tx_2;\n  output ps2_d_rx_1;\n  output ps2_d_rx_2;\n  input  ps2_d_tx_1;\n  input  ps2_d_tx_2;\n  input  ps2_mouse_clk_I;\n  output ps2_mouse_clk_O;\n  output ps2_mouse_clk_T;\n  input  ps2_mouse_data_I;\n  output ps2_mouse_data_O;\n  output ps2_mouse_data_T;\n  input  ps2_keyb_clk_I;\n  output ps2_keyb_clk_O;\n  output ps2_keyb_clk_T;\n  input  ps2_keyb_data_I;\n  output ps2_keyb_data_O;\n  output ps2_keyb_data_T;\n\n  assign ps2_clk_rx_1 = ps2_mouse_clk_I;\n  assign ps2_clk_rx_2 = ps2_keyb_clk_I;\n  assign ps2_d_rx_1   = ps2_mouse_data_I;\n  assign ps2_d_rx_2   = ps2_keyb_data_I;\n\n  assign ps2_mouse_clk_O  = 1'b0;\n  assign ps2_mouse_clk_T  = ~ps2_clk_tx_1;\n  assign ps2_mouse_data_O = 1'b0;\n  assign ps2_mouse_data_T = ~ps2_d_tx_1;\n  assign ps2_keyb_clk_O   = 1'b0;\n  assign ps2_keyb_clk_T   = ~ps2_clk_tx_2;\n  assign ps2_keyb_data_O  = 1'b0;\n  assign ps2_keyb_data_T  = ~ps2_d_tx_2;\n\nendmodule ",
        "module_name": "dual_ps2_ioadapter",
        "module_hash": "04051bb6d32b6b929d0a084600bc7cfd",
        "dataset_index": 25115
      },
      "sky130_fd_sc_ls__clkdlyinv5sd2_b60291f9": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_ls__clkdlyinv5sd2 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_ls__clkdlyinv5sd2",
        "module_hash": "b60291f93e1fb8241ec272c175f814ff",
        "dataset_index": 15935
      },
      "tv80_alu_4447ae1b": {
        "rtl_code": "module tv80_alu (\n  Q, F_Out, \n  Arith16, Z16, ALU_Op, IR, ISet, BusA, BusB, F_In\n  );\n\n  parameter\t\tMode   = 0;\n  parameter\t\tFlag_C = 0;\n  parameter\t\tFlag_N = 1;\n  parameter\t\tFlag_P = 2;\n  parameter\t\tFlag_X = 3;\n  parameter\t\tFlag_H = 4;\n  parameter\t\tFlag_Y = 5;\n  parameter\t\tFlag_Z = 6;\n  parameter\t\tFlag_S = 7;\n\n  input \t\tArith16;\n  input \t\tZ16;\n  input [3:0]           ALU_Op ;\n  input [5:0]           IR;\n  input [1:0]           ISet;\n  input [7:0]           BusA;\n  input [7:0]           BusB;\n  input [7:0]           F_In;\n  output [7:0]          Q;\n  output [7:0]          F_Out;\n  reg [7:0]             Q;\n  reg [7:0]             F_Out;\n\n  function [4:0] AddSub4;\n    input [3:0] A;\n    input [3:0] B;\n    input Sub;\n    input Carry_In;\n    begin\n      AddSub4 = { 1'b0, A } + { 1'b0, (Sub)?~B:B } + Carry_In;\n    end\n  endfunction function [3:0] AddSub3;\n    input [2:0] A;\n    input [2:0] B;\n    input Sub;\n    input Carry_In;\n    begin\n      AddSub3 = { 1'b0, A } + { 1'b0, (Sub)?~B:B } + Carry_In;\n    end\n  endfunction function [1:0] AddSub1;\n    input A;\n    input B;\n    input Sub;\n    input Carry_In;\n    begin\n      AddSub1 = { 1'b0, A } + { 1'b0, (Sub)?~B:B } + Carry_In;\n    end\n  endfunction reg UseCarry;\n  reg Carry7_v;\n  reg OverFlow_v;\n  reg HalfCarry_v;\n  reg Carry_v;\n  reg [7:0] Q_v;\n\n  reg [7:0] BitMask;\n\n\n  always @(ALU_Op or BusA or BusB or F_In or IR)\n    begin\n      case (IR[5:3])\n        3'b000 : BitMask = 8'b00000001;\n        3'b001 : BitMask = 8'b00000010;\n        3'b010 : BitMask = 8'b00000100; \n        3'b011 : BitMask = 8'b00001000; \n        3'b100 : BitMask = 8'b00010000; \n        3'b101 : BitMask = 8'b00100000; \n        3'b110 : BitMask = 8'b01000000; \n        default: BitMask = 8'b10000000; \n      endcase UseCarry = ~ ALU_Op[2] && ALU_Op[0];\n      { HalfCarry_v, Q_v[3:0] } = AddSub4(BusA[3:0], BusB[3:0], ALU_Op[1], ALU_Op[1] ^ (UseCarry && F_In[Flag_C]) );\n      { Carry7_v, Q_v[6:4]  } = AddSub3(BusA[6:4], BusB[6:4], ALU_Op[1], HalfCarry_v);\n      { Carry_v, Q_v[7] } = AddSub1(BusA[7], BusB[7], ALU_Op[1], Carry7_v);\n      OverFlow_v = Carry_v ^ Carry7_v;\n    end reg [7:0] Q_t;\n  reg [8:0] DAA_Q;\n  \n  always @ (ALU_Op or Arith16 or BitMask or BusA or BusB\n\t    or Carry_v or F_In or HalfCarry_v or IR or ISet\n\t    or OverFlow_v or Q_v or Z16)\n    begin\n      Q_t = 8'hxx;\n      DAA_Q = {9{1'bx}};\n      \n      F_Out = F_In;\n      case (ALU_Op)\n\t4'b0000, 4'b0001,  4'b0010, 4'b0011, 4'b0100, 4'b0101, 4'b0110, 4'b0111 :\n          begin\n\t    F_Out[Flag_N] = 1'b0;\n\t    F_Out[Flag_C] = 1'b0;\n            \n\t    case (ALU_Op[2:0])\n              \n\t      3'b000, 3'b001 : begin\n\t\t  Q_t = Q_v;\n\t\t  F_Out[Flag_C] = Carry_v;\n\t\t  F_Out[Flag_H] = HalfCarry_v;\n\t\t  F_Out[Flag_P] = OverFlow_v;\n                end\n              \n\t      3'b010, 3'b011, 3'b111 : begin\n\t\t  Q_t = Q_v;\n\t\t  F_Out[Flag_N] = 1'b1;\n\t\t  F_Out[Flag_C] = ~ Carry_v;\n\t\t  F_Out[Flag_H] = ~ HalfCarry_v;\n\t\t  F_Out[Flag_P] = OverFlow_v;\n                end\n              \n\t      3'b100 : begin\n\t\t  Q_t[7:0] = BusA & BusB;\n\t\t  F_Out[Flag_H] = 1'b1;\n                end\n              \n\t      3'b101 : begin\n\t\t  Q_t[7:0] = BusA ^ BusB;\n\t\t  F_Out[Flag_H] = 1'b0;\n                end\n              \n\t      default : begin\n\t\t  Q_t[7:0] = BusA | BusB;\n\t\t  F_Out[Flag_H] = 1'b0;\n                end\n              \n\t    endcase if (ALU_Op[2:0] == 3'b111 ) \n              begin F_Out[Flag_X] = BusB[3];\n\t\tF_Out[Flag_Y] = BusB[5];\n\t      end \n            else \n              begin\n\t\tF_Out[Flag_X] = Q_t[3];\n\t\tF_Out[Flag_Y] = Q_t[5];\n\t      end\n            \n\t    if (Q_t[7:0] == 8'b00000000 ) \n              begin\n\t\tF_Out[Flag_Z] = 1'b1;\n\t\tif (Z16 == 1'b1 ) \n                  begin\n\t\t    F_Out[Flag_Z] = F_In[Flag_Z];\tend\n\t      end \n            else \n              begin\n\t\tF_Out[Flag_Z] = 1'b0;\n\t      end F_Out[Flag_S] = Q_t[7];\n\t    case (ALU_Op[2:0])\n\t      3'b000, 3'b001, 3'b010, 3'b011, 3'b111 : ;\n              \n\t      default :\n\t        F_Out[Flag_P] = ~(^Q_t);                    \n\t    endcase if (Arith16 == 1'b1 ) \n              begin\n\t\tF_Out[Flag_S] = F_In[Flag_S];\n\t\tF_Out[Flag_Z] = F_In[Flag_Z];\n\t\tF_Out[Flag_P] = F_In[Flag_P];\n\t      end\n          end 4'b1100 :\n          begin\n\t    F_Out[Flag_H] = F_In[Flag_H];\n\t    F_Out[Flag_C] = F_In[Flag_C];\n\t    DAA_Q[7:0] = BusA;\n\t    DAA_Q[8] = 1'b0;\n\t    if (F_In[Flag_N] == 1'b0 ) \n              begin\n\t\tif (DAA_Q[3:0] > 9 || F_In[Flag_H] == 1'b1 ) \n                  begin\n\t\t    if ((DAA_Q[3:0] > 9) ) \n                      begin\n\t\t\tF_Out[Flag_H] = 1'b1;\n\t\t      end \n                    else \n                      begin\n\t\t\tF_Out[Flag_H] = 1'b0;\n\t\t      end\n\t\t    DAA_Q = DAA_Q + 6;\n\t\t  end if (DAA_Q[8:4] > 9 || F_In[Flag_C] == 1'b1 ) \n                  begin\n\t\t    DAA_Q = DAA_Q + 96; end\n\t      end \n            else \n              begin\n\t\tif (DAA_Q[3:0] > 9 || F_In[Flag_H] == 1'b1 ) \n                  begin\n\t\t    if (DAA_Q[3:0] > 5 ) \n                      begin\n\t\t\tF_Out[Flag_H] = 1'b0;\n\t\t      end\n\t\t    DAA_Q[7:0] = DAA_Q[7:0] - 6;\n\t\t  end\n\t\tif (BusA > 153 || F_In[Flag_C] == 1'b1 ) \n                  begin\n\t\t    DAA_Q = DAA_Q - 352; end\n\t      end F_Out[Flag_X] = DAA_Q[3];\n\t    F_Out[Flag_Y] = DAA_Q[5];\n\t    F_Out[Flag_C] = F_In[Flag_C] || DAA_Q[8];\n\t    Q_t = DAA_Q[7:0];\n            \n\t    if (DAA_Q[7:0] == 8'b00000000 ) \n              begin\n\t\tF_Out[Flag_Z] = 1'b1;\n\t      end \n            else \n              begin\n\t\tF_Out[Flag_Z] = 1'b0;\n\t      end\n            \n\t    F_Out[Flag_S] = DAA_Q[7];\n\t    F_Out[Flag_P] = ~ (^DAA_Q);\n          end 4'b1101, 4'b1110 :\n          begin\n\t    Q_t[7:4] = BusA[7:4];\n\t    if (ALU_Op[0] == 1'b1 ) \n              begin\n\t\tQ_t[3:0] = BusB[7:4];\n\t      end \n            else \n              begin\n\t\tQ_t[3:0] = BusB[3:0];\n\t      end\n\t    F_Out[Flag_H] = 1'b0;\n\t    F_Out[Flag_N] = 1'b0;\n\t    F_Out[Flag_X] = Q_t[3];\n\t    F_Out[Flag_Y] = Q_t[5];\n\t    if (Q_t[7:0] == 8'b00000000 ) \n              begin\n\t\tF_Out[Flag_Z] = 1'b1;\n\t      end \n            else \n              begin\n\t\tF_Out[Flag_Z] = 1'b0;\n\t      end\n\t    F_Out[Flag_S] = Q_t[7];\n            F_Out[Flag_P] = ~(^Q_t);\n          end 4'b1001 :\n          begin\n\t    Q_t[7:0] = BusB & BitMask;\n\t    F_Out[Flag_S] = Q_t[7];\n\t    if (Q_t[7:0] == 8'b00000000 ) \n              begin\n\t\tF_Out[Flag_Z] = 1'b1;\n\t\tF_Out[Flag_P] = 1'b1;\n\t      end \n            else \n              begin\n\t\tF_Out[Flag_Z] = 1'b0;\n\t\tF_Out[Flag_P] = 1'b0;\n\t      end\n\t    F_Out[Flag_H] = 1'b1;\n\t    F_Out[Flag_N] = 1'b0;\n\t    F_Out[Flag_X] = 1'b0;\n\t    F_Out[Flag_Y] = 1'b0;\n\t    if (IR[2:0] != 3'b110 ) \n              begin\n\t\tF_Out[Flag_X] = BusB[3];\n\t\tF_Out[Flag_Y] = BusB[5];\n\t      end\n          end 4'b1010 :\n\t  Q_t[7:0] = BusB | BitMask;\n        \n\t4'b1011 :\n\t  Q_t[7:0] = BusB & ~ BitMask;\n        \n\t4'b1000 :\n          begin\n\t    case (IR[5:3])\n\t      3'b000 : begin\n\t\t  Q_t[7:1] = BusA[6:0];\n\t\t  Q_t[0] = BusA[7];\n\t\t  F_Out[Flag_C] = BusA[7];\n                end\n              \n\t      3'b010 : begin\n\t\t  Q_t[7:1] = BusA[6:0];\n\t\t  Q_t[0] = F_In[Flag_C];\n\t\t  F_Out[Flag_C] = BusA[7];\n                end\n              \n\t      3'b001 : begin\n\t\t  Q_t[6:0] = BusA[7:1];\n\t\t  Q_t[7] = BusA[0];\n\t\t  F_Out[Flag_C] = BusA[0];\n                end\n              \n\t      3'b011 : begin                        \n\t\t  Q_t[6:0] = BusA[7:1];\n\t\t  Q_t[7] = F_In[Flag_C];\n\t\t  F_Out[Flag_C] = BusA[0];\n                end\n              \n\t      3'b100 : begin\n\t\t  Q_t[7:1] = BusA[6:0];\n\t\t  Q_t[0] = 1'b0;\n\t\t  F_Out[Flag_C] = BusA[7];\n                end\n              \n\t      3'b110 : begin\n\t\t  if (Mode == 3 ) \n                    begin\n\t\t      Q_t[7:4] = BusA[3:0];\n\t\t      Q_t[3:0] = BusA[7:4];\n\t\t      F_Out[Flag_C] = 1'b0;                            \n\t\t    end \n                  else \n                    begin\n\t\t      Q_t[7:1] = BusA[6:0];\n\t\t      Q_t[0] = 1'b1;\n\t\t      F_Out[Flag_C] = BusA[7];\n\t\t    end end 3'b101 : begin\n\t\t  Q_t[6:0] = BusA[7:1];\n\t\t  Q_t[7] = BusA[7];\n\t\t  F_Out[Flag_C] = BusA[0];\n                end\n              \n\t      default : begin\n\t\t  Q_t[6:0] = BusA[7:1];\n\t\t  Q_t[7] = 1'b0;\n\t\t  F_Out[Flag_C] = BusA[0];\n                end\n\t    endcase F_Out[Flag_H] = 1'b0;\n\t    F_Out[Flag_N] = 1'b0;\n\t    F_Out[Flag_X] = Q_t[3];\n\t    F_Out[Flag_Y] = Q_t[5];\n\t    F_Out[Flag_S] = Q_t[7];\n\t    if (Q_t[7:0] == 8'b00000000 ) \n              begin\n\t\tF_Out[Flag_Z] = 1'b1;\n\t      end \n            else \n              begin\n\t\tF_Out[Flag_Z] = 1'b0;\n\t      end\n            F_Out[Flag_P] = ~(^Q_t);\n\n\t    if (ISet == 2'b00 ) \n              begin\n\t\tF_Out[Flag_P] = F_In[Flag_P];\n\t\tF_Out[Flag_S] = F_In[Flag_S];\n\t\tF_Out[Flag_Z] = F_In[Flag_Z];\n\t      end\n          end default :\n\t  ;\n        \n      endcase Q = Q_t;\n    end endmodule ",
        "module_name": "tv80_alu",
        "module_hash": "4447ae1b19d8c247df16c6b46257e957",
        "dataset_index": 22103
      },
      "data_buffer #_85a804d6": {
        "rtl_code": "module data_buffer #(\n    parameter DEPTH = 8,\n    parameter L = 3,\n    parameter dat_width = 8\n)(\n    input CLK, // System clock for both read and write operations\n    input Rst, // Reset\n    input Wren, // Write enable\n    input Rden, // Read enable\n    input [L-1:0] adr_wr_i, // Write address\n    input [L-1:0] adr_rd_i, // Read address\n    input [dat_width-1:0] Datain, // Input data\n    output reg [dat_width-1:0] Dataout, // Output data\n    output reg Full, // Full signal\n    output reg Empty // Empty signal\n);\n\n    reg [dat_width-1:0] data_ram [0:DEPTH-1]; // Data buffer\n    reg [L-1:0] status_cnt; // Status counter\n\n    always @(posedge CLK) begin\n        if (Rst) begin\n            status_cnt <= 0;\n            Dataout <= 0; // Clear Dataout on reset\n        end else begin\n            if (Wren) begin\n                data_ram[adr_wr_i] <= Datain; // Perform write operation\n                if (!Rden && status_cnt < DEPTH) status_cnt <= status_cnt + 1;\n            end\n            if (Rden && status_cnt > 0) begin\n                Dataout <= data_ram[adr_rd_i]; // Perform read operation\n                status_cnt <= status_cnt - 1;\n            end\n        end\n    end\n    \n    always @(posedge CLK or posedge Rst) begin\n        if (Rst) begin\n            Full <= 0;\n            Empty <= 1;\n        end else begin\n            Full <= (status_cnt == DEPTH);\n            Empty <= (status_cnt == 0);\n        end\n    end\nendmodule\n",
        "module_name": "data_buffer #",
        "module_hash": "85a804d62af430c313fed7eb5c05b923",
        "dataset_index": 579
      },
      "and_gate_1432dc85": {
        "rtl_code": "module and_gate (\n    input A,\n    input B,\n    output Y\n);\n\nassign Y = A & B;\n\nendmodule",
        "module_name": "and_gate",
        "module_hash": "1432dc85147282bd47e8ab112438f0c3",
        "dataset_index": 9269
      },
      "top__8099d104": {
        "rtl_code": "\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [3:0] adder_input,\n    output [3:0] final_output\n);\n\n// Corrected the declaration of shift_register_output to be a wire.\nwire [7:0] shift_register_output;\nwire [3:0] ripple_carry_adder_output;\n\nshift_register shift_reg (\n    .clk(clk),\n    .reset(reset),\n    .d(d1),\n    .q(shift_register_output)\n);\n\nripple_carry_adder ripple_adder (\n    .a(shift_register_output[3:0]),\n    .b(adder_input),\n    .sum(ripple_carry_adder_output),\n    .carry_out()\n);\n\nfunctional_module func_mod (\n    .shift_register_output(shift_register_output),\n    .ripple_carry_adder_output(ripple_carry_adder_output),\n    .final_output(final_output)\n);\n\n// Corrected the declaration of shift_register_output2 to be a wire.\nwire [7:0] shift_register_output2;\nshift_register shift_reg2 (\n    .clk(clk),\n    .reset(reset),\n    .d(d2),\n    .q(shift_register_output2)\n);\n\nendmodule\n\nmodule shift_register (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= {q[6:0], d[0]};\n    end\nend\n\nendmodule\n\nmodule ripple_carry_adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum,\n    output carry_out\n);\n\nassign {carry_out, sum} = a + b;\n\nendmodule\n\nmodule functional_module (\n    input [7:0] shift_register_output,\n    input [3:0] ripple_carry_adder_output,\n    output [3:0] final_output\n);\n\nassign final_output = shift_register_output[7:4] + ripple_carry_adder_output;\n\nendmodule\n",
        "module_name": "top_",
        "module_hash": "8099d10452391e88399f696bbabbdb2f",
        "dataset_index": 14951
      },
      "traffic_light_fsm_69cefee5": {
        "rtl_code": "\nmodule traffic_light_fsm (\n  input clk,\n  input reset,\n  output reg red,\n  output reg green,\n  output reg yellow\n);\n\n  parameter RED = 2'b00, GREEN = 2'b01, YELLOW = 2'b10;\n  reg [1:0] state, next_state;\n  reg [3:0] count;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= RED;\n      count <= 0;\n    end else begin\n      state <= next_state;\n      count <= count + 1;\n    end\n  end\n\n  always @(*) begin\n    case (state)\n      RED: begin\n        red <= 1;\n        green <= 0;\n        yellow <= 0;\n        if (count == 5) begin\n          next_state = GREEN;\n        end else begin\n          next_state = RED;\n        end\n      end\n\n      GREEN: begin\n        red <= 0;\n        green <= 1;\n        yellow <= 0;\n        if (count == 10) begin\n          next_state = YELLOW;\n        end else begin\n          next_state = GREEN;\n        end\n      end\n\n      YELLOW: begin\n        red <= 0;\n        green <= 0;\n        yellow <= 1;\n        if (count == 2) begin\n          next_state = RED;\n        end else begin\n          next_state = YELLOW;\n        end\n      end\n\n      default: begin\n        red <= 0;\n        green <= 0;\n        yellow <= 0;\n        next_state = RED;\n      end\n    endcase\n  end\n\nendmodule",
        "module_name": "traffic_light_fsm",
        "module_hash": "69cefee5411d4bf821e204122bea86df",
        "dataset_index": 3574
      },
      "decoder_f9f6d9cd": {
        "rtl_code": "module decoder (\n    input [2:0] ABC,\n    output reg [7:0] Y\n);\n\nalways @(*)\nbegin\n    case(ABC)\n        3'b000: Y = 8'b00000001;\n        3'b001: Y = 8'b00000010;\n        3'b010: Y = 8'b00000100;\n        3'b011: Y = 8'b00001000;\n        3'b100: Y = 8'b00010000;\n        3'b101: Y = 8'b00100000;\n        3'b110: Y = 8'b01000000;\n        3'b111: Y = 8'b10000000;\n        default: Y = 8'b00000000;\n    endcase\nend\n\nendmodule",
        "module_name": "decoder",
        "module_hash": "f9f6d9cdf20b654ead5d7888c7128196",
        "dataset_index": 17719
      },
      "pipelined_vector_dcb2f304": {
        "rtl_code": "\nmodule pipelined_vector (\n    input wire [2:0] vec,\n    input wire clk,  // Added clock input\n    output wire [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nreg [2:0] stage1_out;\nreg [2:0] stage2_out;\nreg [2:0] stage3_out;\n\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nalways @ (posedge clk) begin  // Corrected always block\n    stage1_out <= vec;\nend\n\nalways @ (posedge clk) begin  // Corrected always block\n    stage2_out <= stage1_out;\nend\n\nalways @ (posedge clk) begin  // Corrected always block\n    stage3_out <= stage2_out;\nend\n\nassign outv = stage3_out;\n\nendmodule\n",
        "module_name": "pipelined_vector",
        "module_hash": "dcb2f30412cd7f7be4046c9ddae12cfb",
        "dataset_index": 16504
      },
      "mux_priority_encoder_decoder_75b327ca": {
        "rtl_code": "module mux_priority_encoder_decoder (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nreg [3:0] mux_out [5:0];\nreg [2:0] highest_priority;\nreg [2:0] selected_input;\n\nalways @(*) begin\n    case(sel)\n        3'b000: begin\n            mux_out[0] = data0;\n            mux_out[1] = data1;\n            mux_out[2] = data2;\n            mux_out[3] = data3;\n            mux_out[4] = data4;\n            mux_out[5] = data5;\n        end\n        3'b001: begin\n            mux_out[0] = data1;\n            mux_out[1] = data0;\n            mux_out[2] = data2;\n            mux_out[3] = data3;\n            mux_out[4] = data4;\n            mux_out[5] = data5;\n        end\n        3'b010: begin\n            mux_out[0] = data2;\n            mux_out[1] = data0;\n            mux_out[2] = data1;\n            mux_out[3] = data3;\n            mux_out[4] = data4;\n            mux_out[5] = data5;\n        end\n        3'b011: begin\n            mux_out[0] = data3;\n            mux_out[1] = data0;\n            mux_out[2] = data1;\n            mux_out[3] = data2;\n            mux_out[4] = data4;\n            mux_out[5] = data5;\n        end\n        3'b100: begin\n            mux_out[0] = data4;\n            mux_out[1] = data0;\n            mux_out[2] = data1;\n            mux_out[3] = data2;\n            mux_out[4] = data3;\n            mux_out[5] = data5;\n        end\n        3'b101: begin\n            mux_out[0] = data5;\n            mux_out[1] = data0;\n            mux_out[2] = data1;\n            mux_out[3] = data2;\n            mux_out[4] = data3;\n            mux_out[5] = data4;\n        end\n        default: begin\n            mux_out[0] = 4'b0000;\n            mux_out[1] = 4'b0000;\n            mux_out[2] = 4'b0000;\n            mux_out[3] = 4'b0000;\n            mux_out[4] = 4'b0000;\n            mux_out[5] = 4'b0000;\n        end\n    endcase\nend\n\nalways @(*) begin\n    highest_priority = 3'b000;\n    if (mux_out[5] > 4'b0000) begin\n        highest_priority = 3'b101;\n    end else if (mux_out[4] > 4'b0000) begin\n        highest_priority = 3'b100;\n    end else if (mux_out[3] > 4'b0000) begin\n        highest_priority = 3'b011;\n    end else if (mux_out[2] > 4'b0000) begin\n        highest_priority = 3'b010;\n    end else if (mux_out[1] > 4'b0000) begin\n        highest_priority = 3'b001;\n    end else if (mux_out[0] > 4'b0000) begin\n        highest_priority = 3'b000;\n    end\nend\n\nalways @(*) begin\n    case(highest_priority)\n        3'b000: begin\n            selected_input = 3'b000;\n        end\n        3'b001: begin\n            selected_input = 3'b001;\n        end\n        3'b010: begin\n            selected_input = 3'b010;\n        end\n        3'b011: begin\n            selected_input = 3'b011;\n        end\n        3'b100: begin\n            selected_input = 3'b100;\n        end\n        3'b101: begin\n            selected_input = 3'b101;\n        end\n        default: begin\n            selected_input = 3'b000;\n        end\n    endcase\nend\n\nalways @(*) begin\n    case(selected_input)\n        3'b000: begin\n            out = mux_out[0];\n        end\n        3'b001: begin\n            out = mux_out[1];\n        end\n        3'b010: begin\n            out = mux_out[2];\n        end\n        3'b011: begin\n            out = mux_out[3];\n        end\n        3'b100: begin\n            out = mux_out[4];\n        end\n        3'b101: begin\n            out = mux_out[5];\n        end\n        default: begin\n            out = 4'b0000;\n        end\n    endcase\nend\n\nendmodule",
        "module_name": "mux_priority_encoder_decoder",
        "module_hash": "75b327ca61eafed05208454c1d882afd",
        "dataset_index": 10115
      },
      "bt656cap_decoder_91c58b8c": {
        "rtl_code": "\n\n\n\nmodule bt656cap_decoder(\n\tinput vid_clk,\n\tinput [7:0] p,\n\n\toutput reg stb,\n\toutput reg field,\n\toutput reg [31:0] ycc422\n);\n\nreg [7:0] ioreg;\nalways @(posedge vid_clk) ioreg <= p;\n\nreg [1:0] byten;\nreg [31:0] inreg;\ninitial begin\n\tbyten <= 2'd0;\n\tinreg <= 32'd0;\nend\nalways @(posedge vid_clk) begin\n\tif(&ioreg) begin\n\t\t\n\t\tinreg[31:24] <= ioreg;\n\t\tbyten <= 2'd1;\n\tend else begin\n\t\tbyten <= byten + 2'd1;\n\t\tcase(byten)\n\t\t\t2'd0: inreg[31:24] <= ioreg;\n\t\t\t2'd1: inreg[23:16] <= ioreg;\n\t\t\t2'd2: inreg[15: 8] <= ioreg;\n\t\t\t2'd3: inreg[ 7: 0] <= ioreg;\n\t\tendcase\n\tend\nend\n\nreg in_field;\nreg in_hblank;\nreg in_vblank;\n\ninitial begin\n\tin_field <= 1'b0;\n\tin_hblank <= 1'b0;\n\tin_vblank <= 1'b0;\n\tstb <= 1'b0;\nend\nalways @(posedge vid_clk) begin\n\tstb <= 1'b0;\n\tif(byten == 2'd0) begin\n\t\t\n\t\tif(inreg[31:8] == 24'hff0000) begin\n\t\t\t\n\t\t\tin_hblank <= inreg[4];\n\t\t\tin_vblank <= inreg[5];\n\t\t\tin_field <= inreg[6];\n\t\tend else begin\n\t\t\t\n\t\t\tif(~in_hblank && ~in_vblank) begin\n\t\t\t\tstb <= 1'b1;\n\t\t\t\tfield <= in_field;\n\t\t\t\tycc422 <= inreg;\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n",
        "module_name": "bt656cap_decoder",
        "module_hash": "91c58b8ceccbafd4c0fdc56f32c57de9",
        "dataset_index": 23823
      },
      "axis_srl_fifo #_d7ec249c": {
        "rtl_code": "\n\n`resetall\n\n\n\n\nmodule axis_srl_fifo #\n(\n    parameter DATA_WIDTH = 8,\n    parameter KEEP_ENABLE = (DATA_WIDTH>8),\n    parameter KEEP_WIDTH = (DATA_WIDTH/8),\n    parameter LAST_ENABLE = 1,\n    parameter ID_ENABLE = 0,\n    parameter ID_WIDTH = 8,\n    parameter DEST_ENABLE = 0,\n    parameter DEST_WIDTH = 8,\n    parameter USER_ENABLE = 1,\n    parameter USER_WIDTH = 1,\n    parameter DEPTH = 16\n)\n(\n    input  wire                       clk,\n    input  wire                       rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]      s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]      s_axis_tkeep,\n    input  wire                       s_axis_tvalid,\n    output wire                       s_axis_tready,\n    input  wire                       s_axis_tlast,\n    input  wire [ID_WIDTH-1:0]        s_axis_tid,\n    input  wire [DEST_WIDTH-1:0]      s_axis_tdest,\n    input  wire [USER_WIDTH-1:0]      s_axis_tuser,\n\n    \n    output wire [DATA_WIDTH-1:0]      m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]      m_axis_tkeep,\n    output wire                       m_axis_tvalid,\n    input  wire                       m_axis_tready,\n    output wire                       m_axis_tlast,\n    output wire [ID_WIDTH-1:0]        m_axis_tid,\n    output wire [DEST_WIDTH-1:0]      m_axis_tdest,\n    output wire [USER_WIDTH-1:0]      m_axis_tuser,\n\n    \n    output wire [$clog2(DEPTH+1)-1:0] count\n);\n\nlocalparam KEEP_OFFSET = DATA_WIDTH;\nlocalparam LAST_OFFSET = KEEP_OFFSET + (KEEP_ENABLE ? KEEP_WIDTH : 0);\nlocalparam ID_OFFSET   = LAST_OFFSET + (LAST_ENABLE ? 1          : 0);\nlocalparam DEST_OFFSET = ID_OFFSET   + (ID_ENABLE   ? ID_WIDTH   : 0);\nlocalparam USER_OFFSET = DEST_OFFSET + (DEST_ENABLE ? DEST_WIDTH : 0);\nlocalparam WIDTH       = USER_OFFSET + (USER_ENABLE ? USER_WIDTH : 0);\n\nreg [WIDTH-1:0] data_reg[DEPTH-1:0];\nreg [$clog2(DEPTH+1)-1:0] ptr_reg = 0;\nreg full_reg = 1'b0, full_next;\nreg empty_reg = 1'b1, empty_next;\n\nwire [WIDTH-1:0] s_axis;\n\nwire [WIDTH-1:0] m_axis = data_reg[ptr_reg-1];\n\nassign s_axis_tready = !full_reg;\n\ngenerate\n    assign s_axis[DATA_WIDTH-1:0] = s_axis_tdata;\n    if (KEEP_ENABLE) assign s_axis[KEEP_OFFSET +: KEEP_WIDTH] = s_axis_tkeep;\n    if (LAST_ENABLE) assign s_axis[LAST_OFFSET]               = s_axis_tlast;\n    if (ID_ENABLE)   assign s_axis[ID_OFFSET   +: ID_WIDTH]   = s_axis_tid;\n    if (DEST_ENABLE) assign s_axis[DEST_OFFSET +: DEST_WIDTH] = s_axis_tdest;\n    if (USER_ENABLE) assign s_axis[USER_OFFSET +: USER_WIDTH] = s_axis_tuser;\nendgenerate\n\nassign m_axis_tvalid = !empty_reg;\n\nassign m_axis_tdata = m_axis[DATA_WIDTH-1:0];\nassign m_axis_tkeep = KEEP_ENABLE ? m_axis[KEEP_OFFSET +: KEEP_WIDTH] : {KEEP_WIDTH{1'b1}};\nassign m_axis_tlast = LAST_ENABLE ? m_axis[LAST_OFFSET]               : 1'b1;\nassign m_axis_tid   = ID_ENABLE   ? m_axis[ID_OFFSET   +: ID_WIDTH]   : {ID_WIDTH{1'b0}};\nassign m_axis_tdest = DEST_ENABLE ? m_axis[DEST_OFFSET +: DEST_WIDTH] : {DEST_WIDTH{1'b0}};\nassign m_axis_tuser = USER_ENABLE ? m_axis[USER_OFFSET +: USER_WIDTH] : {USER_WIDTH{1'b0}};\n\nassign count = ptr_reg;\n\nwire ptr_empty = ptr_reg == 0;\nwire ptr_empty1 = ptr_reg == 1;\nwire ptr_full = ptr_reg == DEPTH;\nwire ptr_full1 = ptr_reg == DEPTH-1;\n\nreg shift;\nreg inc;\nreg dec;\n\ninteger i;\n\ninitial begin\n    for (i = 0; i < DEPTH; i = i + 1) begin\n        data_reg[i] <= 0;\n    end\nend\n\nalways @* begin\n    shift = 1'b0;\n    inc = 1'b0;\n    dec = 1'b0;\n    full_next = full_reg;\n    empty_next = empty_reg;\n\n    if (m_axis_tready && s_axis_tvalid && s_axis_tready) begin\n        shift = 1'b1;\n        inc = ptr_empty;\n        empty_next = 1'b0;\n    end else if (m_axis_tready && m_axis_tvalid) begin\n        dec = 1'b1;\n        full_next = 1'b0;\n        empty_next = ptr_empty1;\n    end else if (s_axis_tvalid && s_axis_tready) begin\n        shift = 1'b1;\n        inc = 1'b1;\n        full_next = ptr_full1;\n        empty_next = 1'b0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        ptr_reg <= 0;\n        full_reg <= 1'b0;\n        empty_reg <= 1'b1;\n    end else begin\n        if (inc) begin\n            ptr_reg <= ptr_reg + 1;\n        end else if (dec) begin\n            ptr_reg <= ptr_reg - 1;\n        end else begin\n            ptr_reg <= ptr_reg;\n        end\n\n        full_reg <= full_next;\n        empty_reg <= empty_next;\n    end\n\n    if (shift) begin\n        data_reg[0] <= s_axis;\n        for (i = 0; i < DEPTH-1; i = i + 1) begin\n            data_reg[i+1] <= data_reg[i];\n        end\n    end\nend\n\nendmodule\n\n`resetall\n",
        "module_name": "axis_srl_fifo #",
        "module_hash": "d7ec249cc181cd8c08a5f8478ee484d3",
        "dataset_index": 23924
      },
      "my__7b7a6cac": {
        "rtl_code": "\nmodule my_module (\n    input [2:0] a,\n    input [2:0] b,\n    input [2:0] c,\n    input [2:0] d,\n    input [1:0] e,\n    input clk,\n    input rst,\n    output reg y\n);\n\nreg [2:0] a_msb, b_msb;\nreg [2:0] c_lsb, d_lsb;\nreg [1:0] e_lsb;\nreg e_msb;\n\nalways @ (posedge clk) begin\n    if (rst) begin\n        y <= 0;\n    end else begin\n        a_msb <= a[2:0];\n        b_msb <= b[2:0];\n        c_lsb <= c[2:0];\n        d_lsb <= d[2:0];\n        e_lsb <= e[1:0];\n        e_msb <= e[0];\n\n        if ((a_msb == b_msb) && (c_lsb == d_lsb) && (e_lsb == a[2]) && (e_msb == c[0])) begin\n            y <= 1;\n        end else begin\n            y <= 0;\n        end\n    end\nend\n\nendmodule\n",
        "module_name": "my_",
        "module_hash": "7b7a6cacc0b0beaa185d510684b34ef3",
        "dataset_index": 15751
      },
      "adder4_b2d7068e": {
        "rtl_code": "\nmodule adder4(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output COUT\n);\n\nwire [4:0] sum;\nwire carry;\n\nassign {carry, sum} = A + B;\nassign COUT = carry;\n\nassign S = sum[3:0];\n\nendmodule",
        "module_name": "adder4",
        "module_hash": "b2d7068e7e4d7b74595d3d68708d185f",
        "dataset_index": 19937
      },
      "XOR_M_fc0043fd": {
        "rtl_code": "module XOR_M ( Sgn_X, Sgn_Y, Sgn_Info );\n  input Sgn_X, Sgn_Y;\n  output Sgn_Info;\n\n  assign Sgn_Info = Sgn_X ^ Sgn_Y;\n\nendmodule",
        "module_name": "XOR_M",
        "module_hash": "fc0043fd07884e63cd8cb8d0d332f184",
        "dataset_index": 12520
      },
      "rotator_791182cc": {
        "rtl_code": "\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nreg [99:0] shift_reg;\nreg [6:0] shift_cnt;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n        shift_cnt <= 0;\n    end else begin\n        case (ena)\n            2'b00: begin // right rotate\n                shift_reg <= {shift_reg[1], shift_reg[99:2]};\n                shift_cnt <= shift_cnt + 1;\n            end\n            2'b01: begin // left rotate\n                shift_reg <= {shift_reg[99:1], shift_reg[0]};\n                shift_cnt <= shift_cnt + 1;\n            end\n            default: begin // no rotation\n                shift_reg <= shift_reg;\n                shift_cnt <= 0;\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    q <= shift_reg;\nend\n\nendmodule\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nwire [99:0] rotator_out;\n\nrotator rotator_inst(\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(rotator_out)\n);\n\nalways @(*) begin\n    q <= rotator_out;\nend\n\nendmodule",
        "module_name": "rotator",
        "module_hash": "791182cc96d85c2cf53e97c18d002c33",
        "dataset_index": 10001
      },
      "ram_controller_ex_lfsr8_ebcc47d5": {
        "rtl_code": "module ram_controller_ex_lfsr8 (\nclk, reset_n, enable, pause, load, data, ldata);\n\n   parameter seed  = 32;\n   input clk;\n   input reset_n;\n   input enable;\n   input pause;\n   input load;\n   output[8 - 1:0] data;\n   wire[8 - 1:0] data;\n   input[8 - 1:0] ldata;\n\n   reg[8 - 1:0] lfsr_data;\n\n   assign data = lfsr_data ;\n\n   always @(posedge clk or negedge reset_n)\n   begin\n      if (!reset_n)\n      begin\n         lfsr_data <= seed[7:0] ;\n      end\n      else\n      begin\n         if (!enable)\n         begin\n            lfsr_data <= seed[7:0];\n         end\n         else\n         begin\n            if (load)\n            begin\n               lfsr_data <= ldata ;\n            end\n            else\n            begin\n               if (!pause)\n               begin\n                  lfsr_data[0] <= lfsr_data[7] ;\n                  lfsr_data[1] <= lfsr_data[0] ;\n                  lfsr_data[2] <= lfsr_data[1] ^ lfsr_data[7] ;\n                  lfsr_data[3] <= lfsr_data[2] ^ lfsr_data[7] ;\n                  lfsr_data[4] <= lfsr_data[3] ^ lfsr_data[7] ;\n                  lfsr_data[5] <= lfsr_data[4] ;\n                  lfsr_data[6] <= lfsr_data[5] ;\n                  lfsr_data[7] <= lfsr_data[6] ;\n               end\n            end\n         end\n      end\n   end\nendmodule\n",
        "module_name": "ram_controller_ex_lfsr8",
        "module_hash": "ebcc47d5b8ac17fbfee203cd6caa959c",
        "dataset_index": 22283
      },
      "blockmem_rw32_r128_6470f6c1": {
        "rtl_code": "module blockmem_rw32_r128(\n                          input wire           clk,\n\n                          input wire            api_we,\n                          input wire  [07 : 0]  api_addr,\n                          input wire  [31 : 0]  api_wr_data,\n                          output wire [31 : 0]  api_rd_data,\n\n                          input wire  [04 : 0]  internal_addr,\n                          output wire [255 : 0] internal_rd_data\n                         );\n\n\n  reg [31 : 0] mem0 [0 : 31];\n  reg [31 : 0] mem1 [0 : 31];\n  reg [31 : 0] mem2 [0 : 31];\n  reg [31 : 0] mem3 [0 : 31];\n  reg [31 : 0] mem4 [0 : 31];\n  reg [31 : 0] mem5 [0 : 31];\n  reg [31 : 0] mem6 [0 : 31];\n  reg [31 : 0] mem7 [0 : 31];\n\n\n  reg [31 : 0] muxed_api_rd_data;\n\n  reg [31 : 0] mem0_api_rd_data;\n  reg [31 : 0] mem1_api_rd_data;\n  reg [31 : 0] mem2_api_rd_data;\n  reg [31 : 0] mem3_api_rd_data;\n  reg [31 : 0] mem4_api_rd_data;\n  reg [31 : 0] mem5_api_rd_data;\n  reg [31 : 0] mem6_api_rd_data;\n  reg [31 : 0] mem7_api_rd_data;\n\n  reg [31 : 0] mem0_int_rd_data;\n  reg [31 : 0] mem1_int_rd_data;\n  reg [31 : 0] mem2_int_rd_data;\n  reg [31 : 0] mem3_int_rd_data;\n  reg [31 : 0] mem4_int_rd_data;\n  reg [31 : 0] mem5_int_rd_data;\n  reg [31 : 0] mem6_int_rd_data;\n  reg [31 : 0] mem7_int_rd_data;\n\n  reg          mem0_we;\n  reg          mem1_we;\n  reg          mem2_we;\n  reg          mem3_we;\n  reg          mem4_we;\n  reg          mem5_we;\n  reg          mem6_we;\n  reg          mem7_we;\n\n\n  assign api_rd_data      = muxed_api_rd_data;\n\n  assign internal_rd_data = {mem7_int_rd_data, mem6_int_rd_data,\n                             mem5_int_rd_data, mem4_int_rd_data,\n                             mem3_int_rd_data, mem2_int_rd_data,\n                             mem1_int_rd_data, mem0_int_rd_data};\n\n\n  always @ (posedge clk)\n    begin : reg_update_mem0\n      if (mem0_we)\n        mem0[api_addr[7 : 3]] <= api_wr_data;\n\n      mem0_api_rd_data <= mem0[api_addr[7 : 3]];\n      mem0_int_rd_data <= mem0[internal_addr];\n    end\n\n  always @ (posedge clk)\n    begin : reg_update_mem1\n      if (mem1_we)\n        mem1[api_addr[7 : 3]] <= api_wr_data;\n\n      mem1_api_rd_data <= mem1[api_addr[7 : 3]];\n      mem1_int_rd_data <= mem1[internal_addr];\n    end\n\n  always @ (posedge clk)\n    begin : reg_update_mem2\n      if (mem2_we)\n        mem2[api_addr[7 : 3]] <= api_wr_data;\n\n      mem2_api_rd_data <= mem2[api_addr[7 : 3]];\n      mem2_int_rd_data <= mem2[internal_addr];\n    end\n\n  always @ (posedge clk)\n    begin : reg_update_mem3\n      if (mem3_we)\n        mem3[api_addr[7 : 3]] <= api_wr_data;\n\n      mem3_api_rd_data <= mem3[api_addr[7 : 3]];\n      mem3_int_rd_data <= mem3[internal_addr];\n    end\n\n  always @ (posedge clk)\n    begin : reg_update_mem4\n      if (mem4_we)\n        mem4[api_addr[7 : 3]] <= api_wr_data;\n\n      mem4_api_rd_data <= mem4[api_addr[7 : 3]];\n      mem4_int_rd_data <= mem4[internal_addr];\n    end\n\n  always @ (posedge clk)\n    begin : reg_update_mem5\n      if (mem5_we)\n        mem5[api_addr[7 : 3]] <= api_wr_data;\n\n      mem5_api_rd_data <= mem5[api_addr[7 : 3]];\n      mem5_int_rd_data <= mem5[internal_addr];\n    end\n\n  always @ (posedge clk)\n    begin : reg_update_mem6\n      if (mem6_we)\n        mem6[api_addr[7 : 3]] <= api_wr_data;\n\n      mem6_api_rd_data <= mem6[api_addr[7 : 3]];\n      mem6_int_rd_data <= mem6[internal_addr];\n    end\n\n  always @ (posedge clk)\n    begin : reg_update_mem7\n      if (mem7_we)\n        mem7[api_addr[7 : 3]] <= api_wr_data;\n\n      mem7_api_rd_data <= mem7[api_addr[7 : 3]];\n      mem7_int_rd_data <= mem7[internal_addr];\n    end\n\n\n  always @*\n    begin : api_mux\n      mem0_we = 1'b0;\n      mem1_we = 1'b0;\n      mem2_we = 1'b0;\n      mem3_we = 1'b0;\n      mem4_we = 1'b0;\n      mem5_we = 1'b0;\n      mem6_we = 1'b0;\n      mem7_we = 1'b0;\n\n      case (api_addr[2 : 0])\n        0:\n          begin\n            muxed_api_rd_data = mem0_api_rd_data;\n            mem0_we           = api_we;\n          end\n\n        1:\n          begin\n            muxed_api_rd_data = mem1_api_rd_data;\n            mem1_we           = api_we;\n          end\n\n        2:\n          begin\n            muxed_api_rd_data = mem2_api_rd_data;\n            mem2_we           = api_we;\n          end\n\n        3:\n          begin\n            muxed_api_rd_data = mem3_api_rd_data;\n            mem3_we           = api_we;\n          end\n\n        4:\n          begin\n            muxed_api_rd_data = mem4_api_rd_data;\n            mem4_we           = api_we;\n          end\n\n        5:\n          begin\n            muxed_api_rd_data = mem5_api_rd_data;\n            mem5_we           = api_we;\n          end\n\n        6:\n          begin\n            muxed_api_rd_data = mem6_api_rd_data;\n            mem6_we           = api_we;\n          end\n\n        7:\n          begin\n            muxed_api_rd_data = mem7_api_rd_data;\n            mem7_we           = api_we;\n          end\n\n        default:\n          begin\n          end\n      endcase end endmodule ",
        "module_name": "blockmem_rw32_r128",
        "module_hash": "6470f6c1ab7a063358a3c4702cb024da",
        "dataset_index": 24164
      },
      "digital_clock_9165697c": {
        "rtl_code": "module digital_clock (\n  input clk_in,\n  input rst,\n  input en,\n  output reg clk_out,\n  output reg clk_out_b\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk_in or posedge rst) begin\n  if (rst) begin\n    counter <= 3'b0;\n    clk_out <= 1'b0;\n    clk_out_b <= 1'b0;\n  end else begin\n    if (en) begin\n      counter <= counter + 1;\n      if (counter == 3'b011) begin\n        clk_out <= ~clk_out;\n      end\n      if (counter == 3'b010) begin\n        clk_out_b <= ~clk_out_b;\n      end\n    end\n  end\nend\n\nendmodule",
        "module_name": "digital_clock",
        "module_hash": "9165697c40c5004d9c444675b1ec4a76",
        "dataset_index": 19275
      },
      "a25_multiply_0ac8fd50": {
        "rtl_code": "module a25_multiply (\ninput                       i_clk,\ninput                       i_core_stall,\n\ninput       [31:0]          i_a_in,         input       [31:0]          i_b_in,         input       [1:0]           i_function,\ninput                       i_execute,\n\noutput      [31:0]          o_out,\noutput      [1:0]           o_flags,        output reg                  o_done = 'd0    );\n\n\nwire        enable;\nwire        accumulate;\nwire [33:0] multiplier;\nwire [33:0] multiplier_bar;\nwire [33:0] sum;\nwire [33:0] sum34_b;\n\nreg  [5:0]  count = 'd0;\nreg  [5:0]  count_nxt;\nreg  [67:0] product = 'd0;\nreg  [67:0] product_nxt;\nreg  [1:0]  flags_nxt;\nwire [32:0] sum_acc1;           assign enable         = i_function[0];\nassign accumulate     = i_function[1];\n \nassign multiplier     =  { 2'd0, i_a_in} ;\nassign multiplier_bar = ~{ 2'd0, i_a_in} + 34'd1 ;\n\nassign sum34_b        =  product[1:0] == 2'b01 ? multiplier     :\n                         product[1:0] == 2'b10 ? multiplier_bar :\n                                                 34'd0          ;\n\n\n`ifdef XILINX_FPGA\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(34)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(34))  \n    `endif\n        \n        u_xx_addsub_34_sum (\n        .i_a    ( product[67:34]        ),\n        .i_b    ( sum34_b               ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum                   ),\n        .o_co   (                       )\n    );\n\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(33)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(33)) \n    `endif\n        u_xx_addsub_33_acc1 (\n        .i_a    ( {1'd0, product[32:1]} ),\n        .i_b    ( {1'd0, i_a_in}        ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum_acc1              ),\n        .o_co   (                       )\n    );\n\n`else\n \n    assign sum =  product[67:34] + sum34_b;\n     \n    assign sum_acc1 = {1'd0, product[32:1]} + {1'd0, i_a_in};\n     \n`endif\n\n\nalways @*\n    begin\n    count_nxt           = count;\n    product_nxt         = product;\n    \n    flags_nxt   = { product[32], product[32:1] == 32'd0 }; \n    \n\n    if ( count == 6'd0 )\n        product_nxt = {33'd0, 1'd0, i_b_in, 1'd0 } ;\n    else if ( count <= 6'd33 )\n        product_nxt = { sum[33], sum, product[33:1]} ;\n    else if ( count == 6'd34 && accumulate )\n        begin\n        product_nxt         = { product[64:33], sum_acc1[31:0], 1'd0}; end\n        \n    if (count == 6'd0)  count_nxt   = enable ? 6'd1 : 6'd0;\n    else if ((count == 6'd34 && !accumulate) ||  (count == 6'd35 &&  accumulate)  )  count_nxt   = 6'd0;\n    else\n        count_nxt   = count + 1'd1;\n    end\n\n\nalways @ ( posedge i_clk )\n    if ( !i_core_stall )\n        begin\n        count           <= i_execute ? count_nxt          : count;           \n        product         <= i_execute ? product_nxt        : product;        \n        o_done          <= i_execute ? count == 6'd31     : o_done;          \n        end\n\nassign o_out   = product[32:1]; \nassign o_flags = flags_nxt;\n                     \nendmodule\n\n\n",
        "module_name": "a25_multiply",
        "module_hash": "0ac8fd50de719da88e56433afb1af3fd",
        "dataset_index": 25025
      },
      "DecodeUnitRegisterTwo_6212b4ab": {
        "rtl_code": "module DecodeUnitRegisterTwo(\n   input \tCLK,\n   input \tinput_IN, wren_IN,\n   input [2:0] \twriteAd_IN,\n   input \tADR_MUX_IN, write_IN, PC_load_IN,\n   input \tSPR_w_IN, SPR_i_IN, SPR_d_IN,\n   input [2:0] \tcond_IN, op2_IN,\n   input \tSW_IN, MAD_MUX_IN,\n   output \tinput_OUT, wren_OUT,\n   output [2:0] writeAd_OUT,\n   output \tADR_MUX_OUT, write_OUT, PC_load_OUT,\n   output \tSPR_w_OUT, SPR_i_OUT, SPR_d_OUT,\n   output [2:0] cond_OUT, op2_OUT,\n   output \tSW_OUT, MAD_MUX_OUT);\n   \n   reg          in, wren;\n   reg [2:0] \twriteAd;\n   reg          adrmux, write, pcload;\n   reg [2:0] \tcond, opera2;\n   reg \t\tsprw,spri,sprd;\n   reg \t\tsw, mad;\n   \n\n   always @ (posedge CLK) begin\n      in <= input_IN;\n      wren <= wren_IN;\n      writeAd <= writeAd_IN;\n      adrmux <= ADR_MUX_IN;\n      write <= write_IN;\n      pcload <= PC_load_IN;\n      cond <= cond_IN;\n      opera2 <= op2_IN;\n      sprw <= SPR_w_IN;\n      spri <= SPR_i_IN;\n      sprd <= SPR_d_IN;\n      sw <= SW_IN;\n      mad <= MAD_MUX_IN;\n   end assign input_OUT = in;\n   assign wren_OUT = wren;\n   assign writeAd_OUT = writeAd;\n   assign ADR_MUX_OUT = adrmux;\n   assign write_OUT = write;\n   assign PC_load_OUT = pcload;\n   assign cond_OUT = cond;\n   assign op2_OUT = opera2;\n   assign SPR_w_OUT = sprw;\n   assign SPR_i_OUT = spri;\n   assign SPR_d_OUT = sprd;\n   assign SW_OUT = sw;\n   assign MAD_MUX_OUT = mad;\nendmodule ",
        "module_name": "DecodeUnitRegisterTwo",
        "module_hash": "6212b4ab66595e418a715bb4dbe65c77",
        "dataset_index": 2673
      },
      "clk_buffer_driver_677cb6f7": {
        "rtl_code": "module clk_buffer_driver (\n  input clk_in, \n  input en,\n  output clk_out\n);\n\n  reg d_ff;\n  assign clk_out = d_ff;\n\n  always @(posedge clk_in or negedge en) begin\n    if (~en) begin\n      d_ff <= 1'b0;\n    end else begin\n      d_ff <= clk_in;\n    end\n  end\n\nendmodule",
        "module_name": "clk_buffer_driver",
        "module_hash": "677cb6f79e5cb69318a1f9e4a65f364f",
        "dataset_index": 3137
      },
      "min_finder_23268324": {
        "rtl_code": "\nmodule min_finder (\n    input [7:0] a, b, c, d,\n    output [7:0] min);\n\n    wire [1:0] encoded;\n    wire [3:0] inputs;\n\n    // Instantiating a 4-to-2 priority encoder\n    priority_encoder pe(.encoded(encoded), .inputs(inputs));\n\n    // Extracting the 4 least significant bits from each 8-bit input\n    assign inputs = {a[3:0], b[3:0], c[3:0], d[3:0]};\n\n    // Instantiating a 2-to-4 decoder\n    decoder dec(.decoded(min), .encoded(encoded));\n\nendmodule\nmodule priority_encoder (\n    output reg [1:0] encoded,\n    input [3:0] inputs);\n\n    always @* begin\n        encoded = 2'd0;\n        if (inputs[0] <= inputs[1] && inputs[0] <= inputs[2] && inputs[0] <= inputs[3])\n            encoded = 2'b01;\n        else if (inputs[1] <= inputs[2] && inputs[1] <= inputs[3])\n            encoded = 2'b10;\n        else if (inputs[2] <= inputs[3])\n            encoded = 2'b11;\n    end\n\nendmodule\nmodule decoder (\n    output [7:0] decoded,\n    input [1:0] encoded);\n\n    assign decoded = (encoded == 2'b01) ? 8'b0000_0001 :\n                    (encoded == 2'b10) ? 8'b0000_0010 :\n                    (encoded == 2'b11) ? 8'b0000_0100 : 8'b0000_0000;\n\nendmodule",
        "module_name": "min_finder",
        "module_hash": "232683248ca678b9dc7788aa2de0ffa0",
        "dataset_index": 10396
      },
      "dff_64_27e06c8c": {
        "rtl_code": "module dff_64 ( clk, d, rst, q );\n\n    input clk, rst;\n    input [63:0] d;\n    output [63:0] q;\n    reg [63:0] q;\n\n    always @(posedge clk or negedge rst) begin\n        if (rst == 0) begin\n            q <= 0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule",
        "module_name": "dff_64",
        "module_hash": "27e06c8cd2b8832877f1eb9bf4f821c2",
        "dataset_index": 21217
      },
      "binary_counter_954dd48b": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'h0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "954dd48b1dd5db46411dca3e99d6caa8",
        "dataset_index": 1251
      },
      "half_adder_nand_af00a6ad": {
        "rtl_code": "module half_adder_nand( \n    input a, b,\n    output sum, cout );\n    \n    wire s1, s2, c1;\n    \n    nand(s1, a, b);\n    nand(s2, a, s1);\n    nand(c1, s1, b);\n    \n    assign sum = s2;\n    assign cout = c1;\n    \nendmodule",
        "module_name": "half_adder_nand",
        "module_hash": "af00a6ad52f5b82eec1efde6fe75999e",
        "dataset_index": 17244
      },
      "top__172110f1": {
        "rtl_code": "module top_module (\n  input clk,\n  input reset, // Synchronous active-high reset\n  input [7:0] in1,\n  input [7:0] in2,\n  input select,\n  output [7:0] out\n);\n\n  wire [7:0] adder1_out;\n  wire [7:0] adder2_out;\n  wire [7:0] and_out;\n\n  // Instantiate the two adder modules\n  adder adder1 (\n    .clk(clk),\n    .reset(reset),\n    .in1(in1),\n    .in2(in2),\n    .out(adder1_out)\n  );\n\n  adder adder2 (\n    .clk(clk),\n    .reset(reset),\n    .in1(in1),\n    .in2(in2),\n    .out(adder2_out)\n  );\n\n  // Instantiate the control logic module\n  control_logic control (\n    .select(select),\n    .adder1_out(adder1_out),\n    .adder2_out(adder2_out),\n    .and_out(and_out)\n  );\n\n  // Output the result of the AND operation\n  assign out = and_out;\n\nendmodule\n\nmodule adder (\n  input clk,\n  input reset, // Synchronous active-high reset\n  input [7:0] in1,\n  input [7:0] in2,\n  output [7:0] out\n);\n\n  reg [7:0] sum;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      sum <= 8'd0;\n    end else begin\n      sum <= in1 + in2;\n    end\n  end\n\n  assign out = sum;\n\nendmodule\n\nmodule control_logic (\n  input select,\n  input [7:0] adder1_out,\n  input [7:0] adder2_out,\n  output [7:0] and_out\n);\n\n  assign and_out = (select) ? (adder1_out & adder2_out) : (adder2_out & adder1_out);\n\nendmodule",
        "module_name": "top_",
        "module_hash": "172110f17ef8143d3752a2ea1bf82a9f",
        "dataset_index": 21409
      },
      "axi_data_transfer_b3e08024": {
        "rtl_code": "module axi_data_transfer (\n    input clk,\n    input resetn,\n    \n    input [C_ID_WIDTH-1:0] request_id,\n    output [C_ID_WIDTH-1:0] response_id,\n    input sync_id,\n    input eot,\n    \n    input enable,\n    output reg enabled,\n    \n    output s_axi_ready,\n    input s_axi_valid,\n    input [C_DATA_WIDTH-1:0] s_axi_data,\n    \n    input m_axi_ready,\n    output m_axi_valid,\n    output [C_DATA_WIDTH-1:0] m_axi_data,\n    output m_axi_last,\n    \n    input req_valid,\n    output reg req_ready,\n    input [3:0] req_last_burst_length\n);\n\nparameter C_ID_WIDTH = 3;\nparameter C_DATA_WIDTH = 64;\nparameter C_DISABLE_WAIT_FOR_ID = 1;\n\nreg [3:0] last_burst_length;\nreg [C_ID_WIDTH-1:0] id = 'h00;\nreg [C_ID_WIDTH-1:0] id_next;\nreg [3:0] beat_counter = 'h00;\nwire [3:0] beat_counter_next;\nwire last;\nreg pending_burst;\n\nassign response_id = id;\n\nassign beat_counter_next = s_axi_ready && s_axi_valid ? beat_counter + 1'b1 : beat_counter;\nassign last = beat_counter == (eot ? last_burst_length : 4'hf);\n\nassign s_axi_ready = m_axi_ready & pending_burst & ~req_ready;\nassign m_axi_valid = s_axi_valid & pending_burst & ~req_ready;\nassign m_axi_data = s_axi_data;\nassign m_axi_last = last;\n\nalways @(posedge clk) begin\n    if (resetn == 1'b0) begin\n        enabled <= 1'b0;\n    end else begin\n        if (enable) begin\n            enabled <= 1'b1;\n        end else begin\n            if (C_DISABLE_WAIT_FOR_ID == 0) begin\n                // We are not allowed to just deassert valid, so wait until the\n                // current beat has been accepted\n                if (~s_axi_valid || m_axi_ready)\n                    enabled <= 1'b0;\n            end else begin\n                // For memory mapped AXI busses we have to complete all pending\n                // burst requests before we can disable the data transfer.\n                if (response_id == request_id)\n                    enabled <= 1'b0;\n            end\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (resetn == 1'b0) begin\n        beat_counter <= 'h0;\n        req_ready <= 1'b1;\n    end else begin\n        if (~enabled) begin\n            req_ready <= 1'b1;\n        end else if (req_ready) begin\n            if (req_valid && enabled) begin\n                last_burst_length <= req_last_burst_length;\n                req_ready <= 1'b0;\n                beat_counter <= 'h0;\n            end\n        end else if (s_axi_ready && s_axi_valid) begin\n            if (last && eot)\n                req_ready <= 1'b1;\n            beat_counter <= beat_counter + 1'b1;\n        end\n    end\nend\n\nalways @(*) begin\n    if ((s_axi_ready && s_axi_valid && last) ||\n        (sync_id && id != request_id))\n        id_next <= id + 1'b1;\n    else\n        id_next <= id;\nend\n\nalways @(posedge clk) begin\n    if (resetn == 1'b0) begin\n        id <= 'h0;\n    end else begin\n        id <= id_next;\n        pending_burst <= id_next != request_id;\n    end\nend\n\nendmodule",
        "module_name": "axi_data_transfer",
        "module_hash": "b3e08024c1bff65b92ac871ccf65442b",
        "dataset_index": 3813
      },
      "MUX4to1_9723002b": {
        "rtl_code": "module MUX4to1 (A, B, C, D, S, Y);\ninput A, B, C, D;\ninput [1:0] S;\noutput Y;\n\nwire sel0, sel1;\n\n// Decode select input\nassign sel0 = ~S[0];\nassign sel1 = ~S[1];\n\n// Generate output\nassign Y = (sel1 & sel0 & A) | (sel1 & ~sel0 & B) | (~sel1 & sel0 & C) | (~sel1 & ~sel0 & D);\n\nendmodule",
        "module_name": "MUX4to1",
        "module_hash": "9723002b5d511a8dbea51f166c152186",
        "dataset_index": 2529
      },
      "flip_flop_5c0f49da": {
        "rtl_code": "\nmodule flip_flop (\n    Q      ,\n    Q_N    ,\n    D      ,\n    SCD    ,\n    SCE    ,\n    CLK_N  ,\n    SET_B  ,\n    RESET_B\n);\n\n    output Q      ;\n    output Q_N    ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  CLK_N  ;\n    input  SET_B  ;\n    input  RESET_B;\n\n    reg Q = 1'b0;\n    assign Q_N = ~Q;\n\n    always @ (posedge CLK_N) begin\n        if (SCD)   Q <= 1'b0;\n        else if (SCE)   Q <= 1'b1;\n        else if (SET_B)  Q <= 1'b1;\n        else if (RESET_B) Q <= 1'b0;\n        else            Q <= D;\n    end\n\nendmodule",
        "module_name": "flip_flop",
        "module_hash": "5c0f49daf3455be0040e18c6f47a767f",
        "dataset_index": 9832
      },
      "comparator_63eb7c3f": {
        "rtl_code": "module comparator (\n    input [3:0] A,\n    input [3:0] B,\n    input clk,\n    output EQ,\n    output GT,\n    output LT\n);\n\nreg [3:0] A_reg;\nreg [3:0] B_reg;\nreg [1:0] stage;\n\nassign EQ = (A_reg == B_reg);\nassign GT = (A_reg > B_reg);\nassign LT = (A_reg < B_reg);\n\nalways @(*) begin\n    case(stage)\n        0: begin\n            A_reg = A;\n            B_reg = B;\n        end\n        1: begin\n            A_reg = A_reg;\n            B_reg = B_reg;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (stage == 1) begin\n        stage <= 0;\n    end else begin\n        stage <= 1;\n    end\nend\n\nendmodule",
        "module_name": "comparator",
        "module_hash": "63eb7c3f950bc642e93b60196683461e",
        "dataset_index": 10625
      },
      "booth_multiplier_3f65cf99": {
        "rtl_code": "module booth_multiplier (\n    input signed [31:0] a,\n    input signed [31:0] b,\n    input clk,\n    output signed [63:0] product\n);\n\nreg signed [63:0] product_reg;\nreg signed [31:0] a_reg;\nreg signed [31:0] b_reg;\nreg signed [31:0] m_reg;\nreg signed [31:0] ac_reg;\nreg signed [1:0] count_reg;\n\nalways @(*) begin\n    product_reg = a_reg * b_reg;\n    a_reg = a;\n    b_reg = b;\n    m_reg = {b_reg[31], b_reg};\n    ac_reg = 0;\n    count_reg = 32;\nend\n\nalways @(posedge clk) begin\n    if (count_reg > 0) begin\n        if (ac_reg[0] == 0 && ac_reg[1] == 0) begin\n            // Shift right\n            ac_reg = {ac_reg[30:0], m_reg[31]};\n        end else if (ac_reg[0] == 1 && ac_reg[1] == 0) begin\n            // Subtract\n            ac_reg = ac_reg + (~m_reg + 1);\n        end else if (ac_reg[0] == 0 && ac_reg[1] == 1) begin\n            // Add\n            ac_reg = ac_reg + m_reg;\n        end\n        count_reg = count_reg - 1;\n    end\nend\n\nassign product = product_reg;\n\nendmodule",
        "module_name": "booth_multiplier",
        "module_hash": "3f65cf99b27b88c779d4b53c2e083089",
        "dataset_index": 10487
      },
      "shift_register_48973d1d": {
        "rtl_code": "\nmodule shift_register (\n  input clk,\n  input reset,\n  input load,\n  input data_in,\n  output reg [7:0] data_out\n);\n\n  reg [7:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shift_reg <= 8'b0;\n    end else if (load) begin\n      shift_reg <= data_in;\n    end else begin\n      shift_reg <= {shift_reg[6:0], shift_reg[7]};\n    end\n  end\n\n  // Register the MSB of the shift register to data_out\n  always @(posedge clk)\n    data_out <= shift_reg[7];\n\nendmodule\n",
        "module_name": "shift_register",
        "module_hash": "48973d1da00175d6052e736ae1fccd12",
        "dataset_index": 3725
      },
      "circl_s_5fd5813d": {
        "rtl_code": "module circl_s(\n        input  wire [4:0] in_addr,\n        output reg  [4:0] out_word\n       );\n\nalways @*\n case( in_addr )\n  5'h00: out_word = 5'h00;\n  5'h01: out_word = 5'h05;\n  5'h02: out_word = 5'h09;\n  5'h03: out_word = 5'h0B;\n  5'h04: out_word = 5'h0D;\n  5'h05: out_word = 5'h0F;\n  5'h06: out_word = 5'h10;\n  5'h07: out_word = 5'h12;\n  5'h08: out_word = 5'h13;\n  5'h09: out_word = 5'h14;\n  5'h0A: out_word = 5'h15;\n  5'h0B: out_word = 5'h16;\n  5'h0C: out_word = 5'h17;\n  5'h0D: out_word = 5'h17;\n  5'h0E: out_word = 5'h18;\n  5'h0F: out_word = 5'h19;\n  5'h10: out_word = 5'h19;\n  5'h11: out_word = 5'h1A;\n  5'h12: out_word = 5'h1A;\n  5'h13: out_word = 5'h1B;\n  5'h14: out_word = 5'h1B;\n  5'h15: out_word = 5'h1C;\n  5'h16: out_word = 5'h1C;\n  5'h17: out_word = 5'h1C;\n  5'h18: out_word = 5'h1C;\n  5'h19: out_word = 5'h1D;\n  5'h1A: out_word = 5'h1D;\n  5'h1B: out_word = 5'h1D;\n  5'h1C: out_word = 5'h1D;\n  5'h1D: out_word = 5'h1D;\n  5'h1E: out_word = 5'h1D;\n  5'h1F: out_word = 5'h00;\n endcase\n\nendmodule\n",
        "module_name": "circl_s",
        "module_hash": "5fd5813d8e0cb47f65ab6d64ecba4538",
        "dataset_index": 22174
      },
      "xor_48_salt_90bdab05": {
        "rtl_code": "\n\nmodule xor_48_salt(\n    input [47:0] X,\n    input [59:0] Y,\n    output reg [47:0] Dout,\n    input CLK\n    );\n\nwire [47:0] Xtmp;\n\nalways @(posedge CLK)\nbegin\n\tDout <= Xtmp ^ Y[47:0];\nend\n\nassign Xtmp = {(X[47:36] & (~Y[59:48])) | (Y[59:48] & X[23:12]), X[35:24], (X[23:12] & (~Y[59:48])) | (Y[59:48] & X[47:36]), X[11:0]};\n\nendmodule\n",
        "module_name": "xor_48_salt",
        "module_hash": "90bdab05d960acf2ae80c2b179162e89",
        "dataset_index": 10050
      },
      "Booth_Multiplier_a315c726": {
        "rtl_code": "\nmodule Booth_Multiplier(\n    input signed [3:0] multiplicand,\n    input signed [3:0] multiplier,\n    input clock,\n    input start,\n    output signed [7:0] product,\n    output busy\n);\n\nreg signed [7:0] product_reg;\nreg [2:0] state;\nreg busy_reg;\n\nalways @(posedge clock) begin\n    case(state)\n        3'b000: begin\n            product_reg <= 8'b00000000;\n            state <= 3'b001;\n        end\n        3'b001: begin\n            if(start) begin\n                busy_reg <= 1;\n                state <= 3'b010;\n            end\n        end\n        3'b010: begin\n            if(multiplier[0] == 1) begin\n                product_reg <= product_reg - multiplicand;\n            end else if(multiplier[0] == 0) begin\n                product_reg <= product_reg + multiplicand;\n            end\n            state <= 3'b011;\n        end\n        3'b011: begin\n            state <= 3'b100;\n        end\n        3'b100: begin\n            if(multiplier == 4'b0000) begin\n                state <= 3'b001;\n                busy_reg <= 0;\n            end else begin\n                state <= 3'b010;\n            end\n        end\n    endcase\nend\n\nassign product = product_reg;\nassign busy = busy_reg;\n\nendmodule",
        "module_name": "Booth_Multiplier",
        "module_hash": "a315c726705afb80e90cf6f26b165629",
        "dataset_index": 6577
      },
      "clock_gate_5187cff5": {
        "rtl_code": "module clock_gate (CLK, EN, TE, ENCLK);\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg ENCLK;\n\n  always @ (posedge CLK) begin\n    if (EN && TE) begin\n      ENCLK <= 1'b1;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "5187cff50752f5ab63444080a20a31de",
        "dataset_index": 10893
      },
      "Debouncer_660cf121": {
        "rtl_code": "\nmodule Debouncer (\n  input button,\n  output reg debounced_signal\n);\n\nparameter clk_period = 10; // period of the clock signal in nanoseconds\nparameter debounce_time = 50; // debounce time in nanoseconds\n\nreg button_state;\nreg [3:0] debounce_counter;\n\nalways @(posedge button) begin\n  if (button != button_state) begin\n    debounce_counter <= debounce_time / clk_period;\n  end else if (debounce_counter > 0) begin\n    debounce_counter <= debounce_counter - 1;\n  end else begin\n    button_state <= button;\n  end\nend\n\nalways @(posedge button) begin\n  if (debounce_counter == 0) begin\n    debounced_signal <= button_state;\n  end\nend\n\nendmodule",
        "module_name": "Debouncer",
        "module_hash": "660cf1216610582f473828e1861bfdae",
        "dataset_index": 18490
      },
      "calculator_a638c11b": {
        "rtl_code": "module calculator(\n    input clk, reset,\n    input [1:0] operation,\n    input [7:0] operand1, operand2,\n    output reg [7:0] result\n);\n\nreg [7:0] temp_result; // temp variable to store the result of the operation\n\nalways @(posedge clk) begin\n    if(reset) begin\n        result <= 8'b0; // reset result to 0\n        temp_result <= 8'b0; // reset temp_result to 0\n    end\n    else if(operation == 2'b00) begin // addition\n        temp_result <= operand1 + operand2; // perform addition operation\n        result <= temp_result; // output the result\n    end\n    else if(operation == 2'b01) begin // subtraction\n        temp_result <= operand1 - operand2; // perform subtraction operation\n        result <= temp_result; // output the result\n    end\nend\n\nendmodule",
        "module_name": "calculator",
        "module_hash": "a638c11b36f98ac70d1e2bb82ae22b85",
        "dataset_index": 12414
      },
      "glitch_filter_527582c8": {
        "rtl_code": "module glitch_filter (\n  input in,\n  input clk,\n  output reg out\n);\n\nparameter n = 4; // number of clock cycles for glitch filter\n\nreg [n-1:0] shift_reg;\nreg [n-1:0] prev_values;\n\nalways @(posedge clk) begin\n  shift_reg <= {shift_reg[n-2:0], in};\n  prev_values <= {prev_values[n-2:0], shift_reg[0]};\nend\n\nalways @(*) begin\n  out = (shift_reg == {n{in}}) ? in : prev_values[0];\nend\n\nendmodule",
        "module_name": "glitch_filter",
        "module_hash": "527582c8288fe82ca879acc25608e1dd",
        "dataset_index": 5706
      },
      "watchdog_timer_cd5666cd": {
        "rtl_code": "module watchdog_timer (\n  input clk,\n  input rst,\n  input [31:0] timeout,\n  output wdt\n);\n\n  reg [31:0] counter;\n  reg wdt_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      counter <= 0;\n      wdt_reg <= 0;\n    end else begin\n      counter <= counter + 1;\n      if (counter == timeout) begin\n        wdt_reg <= 1;\n      end else begin\n        wdt_reg <= 0;\n      end\n    end\n  end\n\n  assign wdt = wdt_reg;\n\nendmodule",
        "module_name": "watchdog_timer",
        "module_hash": "cd5666cd32af33b11beb517f6e509310",
        "dataset_index": 4266
      },
      "scrambler #_e1e854b0": {
        "rtl_code": "\n\nmodule scrambler # (\n\tparameter WIDTH = 512\n)(\n\tinput clk,arst,ena,\n\tinput [WIDTH-1:0] din,\t\toutput reg [WIDTH-1:0] dout\n);\nlocalparam SCRAM_INIT = 58'h3ff_ffff_ffff_ffff;\n\nreg [57:0] scram_state = SCRAM_INIT;\n\n\nwire [WIDTH+58-1:0] history;\nassign history [57:0] = scram_state;\n\ngenvar i;\ngenerate\n\tfor (i=58; i<WIDTH+58; i=i+1) begin : lp\n\t\tassign history[i] = history[i-58] ^ history[i-39] ^ din[i-58];\t\t\n\tend\nendgenerate\n\n\t\nalways @(posedge clk or posedge arst) begin\n\tif (arst) begin\n\t\tdout <= 0;\n\t\tscram_state <= SCRAM_INIT;\n\tend\n\telse if (ena) begin\n\t\tdout <= history[WIDTH+58-1:58];\n\t\tscram_state <= history[WIDTH+58-1:WIDTH];\n\tend\nend\n\nendmodule\n\t\n",
        "module_name": "scrambler #",
        "module_hash": "e1e854b02d443759b937e9e471f9fd40",
        "dataset_index": 22276
      },
      "edge_detector_f49f98ac": {
        "rtl_code": "module edge_detector (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\nreg [7:0] prev_in;\nreg [7:0] curr_in;\nreg [7:0] edge_detected;\n\nparameter IDLE = 2'b00;\nparameter DETECT = 2'b01;\nparameter OUTPUT = 2'b10;\n\nreg [1:0] state;\n\nalways @(posedge clk) begin\n    case (state)\n        IDLE: begin\n            curr_in <= in;\n            prev_in <= curr_in;\n            edge_detected <= 8'b0;\n            state <= DETECT;\n        end\n        DETECT: begin\n            curr_in <= in;\n            if (curr_in != prev_in) begin\n                edge_detected <= curr_in & ~prev_in;\n                state <= OUTPUT;\n            end else begin\n                state <= IDLE;\n            end\n            prev_in <= curr_in;\n        end\n        OUTPUT: begin\n            anyedge <= edge_detected;\n            state <= IDLE;\n        end\n    endcase\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nedge_detector detector (\n    .clk(clk),\n    .in(in),\n    .anyedge(anyedge)\n);\n\nendmodule",
        "module_name": "edge_detector",
        "module_hash": "f49f98ac70cfadb9715b14a7598d73c0",
        "dataset_index": 8574
      },
      "clock_gate_flop_d52b9c8f": {
        "rtl_code": "module clock_gate_flop(gated_clk, clk, en);\n  input clk, en;\n  output reg gated_clk;\n  \n  always @(posedge clk) begin\n    if (en) begin\n      gated_clk <= 1'b1;\n    end\n    else begin\n      gated_clk <= 1'b0;\n    end\n  end\nendmodule",
        "module_name": "clock_gate_flop",
        "module_hash": "d52b9c8fc66712dddc6dac804016226e",
        "dataset_index": 18776
      },
      "Altera_UP_I2C_DC_Auto_Initialize_0029f42e": {
        "rtl_code": "\n\n\n\nmodule Altera_UP_I2C_DC_Auto_Initialize (\n\tclk,\n\treset,\n\n\tclear_error,\n\n\tack,\n\ttransfer_complete,\n\n\tdata_out,\n\ttransfer_data,\n\tsend_start_bit,\n\tsend_stop_bit,\n\t\n\tauto_init_complete,\n\tauto_init_error\n);\n\n\n\nparameter DC_ROW_START\t\t\t= 16'h000C;\nparameter DC_COLUMN_START\t\t= 16'h001E;\nparameter DC_ROW_WIDTH\t\t\t= 16'h0400;\nparameter DC_COLUMN_WIDTH\t\t= 16'h0500;\nparameter DC_H_BLANK_B\t\t\t= 16'h018C;\nparameter DC_V_BLANK_B\t\t\t= 16'h0032;\nparameter DC_H_BLANK_A\t\t\t= 16'h00C6;\nparameter DC_V_BLANK_A\t\t\t= 16'h0019;\nparameter DC_SHUTTER_WIDTH\t\t= 16'h0432;\nparameter DC_ROW_SPEED\t\t\t= 16'h0011;\nparameter DC_EXTRA_DELAY\t\t= 16'h0000;\nparameter DC_SHUTTER_DELAY\t\t= 16'h0000;\nparameter DC_RESET\t\t\t\t= 16'h0008;\nparameter DC_FRAME_VALID\t\t= 16'h0000;\nparameter DC_READ_MODE_B\t\t= 16'h0200;\nparameter DC_READ_MODE_A\t\t= 16'h040C;\nparameter DC_DARK_COL_ROW\t\t= 16'h0129;\nparameter DC_FLASH\t\t\t\t= 16'h0608;\nparameter DC_GREEN_GAIN_1\t\t= 16'h0020;\nparameter DC_BLUE_GAIN\t\t\t= 16'h0020;\nparameter DC_RED_GAIN\t\t\t= 16'h0020;\nparameter DC_GREEN_GAIN_2\t\t= 16'h0020;\nparameter DC_GLOBAL_GAIN\t\t= 16'h0020;\nparameter DC_CONTEXT_CTRL\t\t= 16'h000B;\n\n\ninput\t\t\t\tclk;\ninput\t\t\t\treset;\n\ninput\t\t\t\tclear_error;\n\ninput\t\t\t\tack;\ninput\t\t\t\ttransfer_complete;\n\noutput\treg\t[7:0]\tdata_out;\noutput\treg\t\t\ttransfer_data;\noutput\treg\t\t\tsend_start_bit;\noutput\treg\t\t\tsend_stop_bit;\n\n\noutput\t\t\t\tauto_init_complete;\noutput\treg\t\t\tauto_init_error;\n\n\nlocalparam\tAUTO_STATE_0_CHECK_STATUS\t\t= 4'h0,\n\t\t\tAUTO_STATE_1_SEND_START_BIT\t\t= 4'h1,\n\t\t\tAUTO_STATE_2_TRANSFER_BYTE_0\t= 4'h2,\n\t\t\tAUTO_STATE_3_TRANSFER_BYTE_1\t= 4'h3,\n\t\t\tAUTO_STATE_4_TRANSFER_BYTE_2\t= 4'h4,\n\t\t\tAUTO_STATE_5_WAIT\t\t\t\t= 4'h5,\n\t\t\tAUTO_STATE_6_SEND_STOP_BIT\t\t= 4'h6,\n\t\t\tAUTO_STATE_7_INCREASE_COUNTER\t= 4'h7,\n\t\t\tAUTO_STATE_8_DONE\t\t\t\t= 4'h8;\n\nlocalparam\tMIN_ROM_ADDRESS\t= 5'h00;\nlocalparam\tMAX_ROM_ADDRESS\t= 5'h18;\n\n\nwire\t\t\t\tchange_state;\n\nwire\t\t\t\tfinished_auto_init;\n\nreg\t\t\t[4:0]\trom_address_counter;\nreg\t\t\t[25:0]\trom_data;\n\nreg\t\t\t[3:0]\tns_i2c_auto_init;\nreg\t\t\t[3:0]\ts_i2c_auto_init;\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\ts_i2c_auto_init <= AUTO_STATE_0_CHECK_STATUS;\n\telse\n\t\ts_i2c_auto_init <= ns_i2c_auto_init;\nend\n\nalways @(*)\nbegin\n\tns_i2c_auto_init = AUTO_STATE_0_CHECK_STATUS;\n\n    case (s_i2c_auto_init)\n\tAUTO_STATE_0_CHECK_STATUS:\n\t\tbegin\n\t\t\tif (finished_auto_init == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_8_DONE;\n\t\t\telse if (rom_data[25] == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_1_SEND_START_BIT;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_3_TRANSFER_BYTE_1;\n\t\tend\n\tAUTO_STATE_1_SEND_START_BIT:\n\t\tbegin\n\t\t\tif (change_state == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_2_TRANSFER_BYTE_0;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_1_SEND_START_BIT;\n\t\tend\n\tAUTO_STATE_2_TRANSFER_BYTE_0:\n\t\tbegin\n\t\t\tif (change_state == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_3_TRANSFER_BYTE_1;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_2_TRANSFER_BYTE_0;\n\t\tend\n\tAUTO_STATE_3_TRANSFER_BYTE_1:\n\t\tbegin\n\t\t\tif (change_state == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_4_TRANSFER_BYTE_2;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_3_TRANSFER_BYTE_1;\n\t\tend\n\tAUTO_STATE_4_TRANSFER_BYTE_2:\n\t\tbegin\n\t\t\tif ((change_state == 1'b1) && (rom_data[24] == 1'b1))\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_5_WAIT;\n\t\t\telse if (change_state == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_7_INCREASE_COUNTER;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_4_TRANSFER_BYTE_2;\n\t\tend\n\tAUTO_STATE_5_WAIT:\n\t\tbegin\n\t\t\tif (transfer_complete == 1'b0)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_6_SEND_STOP_BIT;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_5_WAIT;\n\t\tend\n\tAUTO_STATE_6_SEND_STOP_BIT:\n\t\tbegin\n\t\t\tif (transfer_complete == 1'b1)\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_7_INCREASE_COUNTER;\n\t\t\telse\n\t\t\t\tns_i2c_auto_init = AUTO_STATE_6_SEND_STOP_BIT;\n\t\tend\n\tAUTO_STATE_7_INCREASE_COUNTER:\n\t\tbegin\n\t\t\tns_i2c_auto_init = AUTO_STATE_0_CHECK_STATUS;\n\t\tend\n\tAUTO_STATE_8_DONE:\n\t\tbegin\n\t\t\tns_i2c_auto_init = AUTO_STATE_8_DONE;\n\t\tend\n\tdefault:\n\t\tbegin\n\t\t\tns_i2c_auto_init = AUTO_STATE_0_CHECK_STATUS;\n\t\tend\n\tendcase\nend\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tdata_out <= 8'h00;\n\telse if (s_i2c_auto_init == AUTO_STATE_1_SEND_START_BIT)\n\t\tdata_out <= 8'hBA;\n\telse if (s_i2c_auto_init == AUTO_STATE_2_TRANSFER_BYTE_0)\n\t\tdata_out <= rom_data[23:16];\n\telse if (s_i2c_auto_init == AUTO_STATE_0_CHECK_STATUS)\n\t\tdata_out <= rom_data[15: 8];\n\telse if (s_i2c_auto_init == AUTO_STATE_3_TRANSFER_BYTE_1)\n\t\tdata_out <= rom_data[15: 8];\n\telse if (s_i2c_auto_init == AUTO_STATE_4_TRANSFER_BYTE_2)\n\t\tdata_out <= rom_data[ 7: 0];\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1) \n\t\ttransfer_data <= 1'b0;\n\telse if (transfer_complete == 1'b1)\n\t\ttransfer_data <= 1'b0;\n\telse if (s_i2c_auto_init == AUTO_STATE_1_SEND_START_BIT)\n\t\ttransfer_data <= 1'b1;\n\telse if (s_i2c_auto_init == AUTO_STATE_2_TRANSFER_BYTE_0)\n\t\ttransfer_data <= 1'b1;\n\telse if (s_i2c_auto_init == AUTO_STATE_3_TRANSFER_BYTE_1)\n\t\ttransfer_data <= 1'b1;\n\telse if (s_i2c_auto_init == AUTO_STATE_4_TRANSFER_BYTE_2)\n\t\ttransfer_data <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tsend_start_bit <= 1'b0;\n\telse if (transfer_complete == 1'b1)\n\t\tsend_start_bit <= 1'b0;\n\telse if (s_i2c_auto_init == AUTO_STATE_1_SEND_START_BIT)\n\t\tsend_start_bit <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tsend_stop_bit <= 1'b0;\n\telse if (transfer_complete == 1'b1)\n\t\tsend_stop_bit <= 1'b0;\n\telse if (s_i2c_auto_init == AUTO_STATE_6_SEND_STOP_BIT)\n\t\tsend_stop_bit <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\tauto_init_error <= 1'b0;\n\telse if (clear_error == 1'b1)\n\t\tauto_init_error <= 1'b0;\n\telse if ((s_i2c_auto_init == AUTO_STATE_7_INCREASE_COUNTER) & ack)\n\t\tauto_init_error <= 1'b1;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset == 1'b1)\n\t\trom_address_counter <= MIN_ROM_ADDRESS;\n\telse if (s_i2c_auto_init == AUTO_STATE_7_INCREASE_COUNTER)\n\t\trom_address_counter <= rom_address_counter + 5'h01;\nend\n\n\nassign auto_init_complete = (s_i2c_auto_init == AUTO_STATE_8_DONE);\n\n\nassign change_state\t= transfer_complete & transfer_data;\n\nassign finished_auto_init = (rom_address_counter == MAX_ROM_ADDRESS);\n\nalways @(*)\nbegin\n\tcase (rom_address_counter)\n\t0\t\t:\trom_data\t<=\t{10'h201, DC_ROW_START};\n\t1\t\t:\trom_data\t<=\t{10'h002, DC_COLUMN_START};\n\t2\t\t:\trom_data\t<=\t{10'h003, DC_ROW_WIDTH};\n\t3\t\t:\trom_data\t<=\t{10'h004, DC_COLUMN_WIDTH};\n\t4\t\t:\trom_data\t<=\t{10'h005, DC_H_BLANK_B};\n\t5\t\t:\trom_data\t<=\t{10'h006, DC_V_BLANK_B};\n\t6\t\t:\trom_data\t<=\t{10'h007, DC_H_BLANK_A};\n\t7\t\t:\trom_data\t<=\t{10'h008, DC_V_BLANK_A};\n\t8\t\t:\trom_data\t<=\t{10'h009, DC_SHUTTER_WIDTH};\n\t9\t\t:\trom_data\t<=\t{10'h00A, DC_ROW_SPEED};\n\t10\t\t:\trom_data\t<=\t{10'h00B, DC_EXTRA_DELAY};\n\t11\t\t:\trom_data\t<=\t{10'h00C, DC_SHUTTER_DELAY};\n\t12\t\t:\trom_data\t<=\t{10'h10D, DC_RESET};\n\t13\t\t:\trom_data\t<=\t{10'h21F, DC_FRAME_VALID};\n\t14\t\t:\trom_data\t<=\t{10'h020, DC_READ_MODE_B};\n\t15\t\t:\trom_data\t<=\t{10'h021, DC_READ_MODE_A};\n\t16\t\t:\trom_data\t<=\t{10'h022, DC_DARK_COL_ROW};\n\t17\t\t:\trom_data\t<=\t{10'h123, DC_FLASH};\n\t18\t\t:\trom_data\t<=\t{10'h22B, DC_GREEN_GAIN_1};\n\t19\t\t:\trom_data\t<=\t{10'h02C, DC_BLUE_GAIN};\n\t20\t\t:\trom_data\t<=\t{10'h02D, DC_RED_GAIN};\n\t21\t\t:\trom_data\t<=\t{10'h02E, DC_GREEN_GAIN_2};\n\t22\t\t:\trom_data\t<=\t{10'h12F, DC_GLOBAL_GAIN};\n\t23\t\t:\trom_data\t<=\t{10'h3C8, DC_CONTEXT_CTRL};\n\tdefault\t:\trom_data\t<=\t26'h1000000;\n\tendcase\nend\n\n\n\n\nendmodule\n\n",
        "module_name": "Altera_UP_I2C_DC_Auto_Initialize",
        "module_hash": "0029f42e9b013ed0201b3ee806a63b76",
        "dataset_index": 22377
      },
      "binary_counter_b0972557": {
        "rtl_code": "\nmodule binary_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      count_out <= 4'b0000;\n    end else begin\n      count_out <= count_out + 1;\n    end\n  end\n\nendmodule\nmodule parity_checker (\n  input [7:0] data_in,\n  output wire parity_out\n);\n\n  assign parity_out = ~^data_in;\n\nendmodule\nmodule top_module (\n  input clk,\n  input reset,\n  output [3:0] counter_out,\n  input [7:0] data_in,\n  output wire parity_out,\n  output [3:0] final_out\n);\n\n  binary_counter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .count_out(counter_out)\n  );\n\n  parity_checker parity_inst (\n    .data_in(data_in),\n    .parity_out(parity_out)\n  );\n\n  assign final_out = counter_out + parity_out;\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "b097255780129202c5daa9a569ad348c",
        "dataset_index": 8777
      },
      "rx_data_receive_b1b84cac": {
        "rtl_code": "module rx_data_receive(\n\t\t\t\tinput posedge_clk,\n\t\t\t\tinput rx_resetn,\n\t\t\t\n\t\t\t\tinput ready_control_p_r,\n\t\t\t\tinput ready_data_p_r,\n\t\t\t\tinput ready_control,\n\t\t\t\tinput ready_data,\n\n\t\t\t\tinput parity_rec_c,\n\t\t\t\tinput parity_rec_d,\n\n\t\t\t\tinput parity_rec_c_gen,\n\t\t\t\tinput parity_rec_d_gen,\n\n\t\t\t\tinput [2:0] control_p_r,\n\t\t\t\tinput [2:0] control_l_r,\n\t\t\t\tinput [8:0] dta_timec_p,\n\n\t\t\t\toutput reg [1:0] state_data_process,\n\n\t\t\t\toutput reg last_is_control,\n\t\t\t\toutput reg last_is_data,\n\t\t\t\toutput reg last_is_timec,\n\n\t\t\t\toutput reg rx_error_c,\n\t\t\t\toutput reg rx_error_d,\n\t\t\t\toutput reg rx_got_fct,\n\n\t\t\t\toutput reg [8:0] rx_data_flag,\n\n\t\t\t\toutput reg [7:0] timecode\n\t\t      );\n\n\t\n\treg  [1:0] next_state_data_process;\n\nalways@(*)\nbegin\n\n\tnext_state_data_process = state_data_process;\n\n\tcase(state_data_process)\n\t2'd0:\n\tbegin\n\t\tif(ready_control_p_r || ready_data_p_r)\n\t\tbegin\n\t\t\tnext_state_data_process = 2'd1;\n\t\tend\n\t\telse \n\t\tbegin\n\t\t\tnext_state_data_process = 2'd0;\n\t\tend\n\tend\n\t2'd1:\n\tbegin\n\t\tif(ready_control || ready_data)\n\t\tbegin\n\t\t\tnext_state_data_process = 2'd0;\n\t\tend\n\t\telse \n\t\tbegin\n\t\t\tnext_state_data_process = 2'd1;\n\t\tend\n\tend\n\tdefault:\n\tbegin\n\t\tnext_state_data_process = 2'd0;\n\tend\n\tendcase\nend\n\n\nalways@(posedge posedge_clk or negedge rx_resetn)\nbegin\n\n\tif(!rx_resetn)\n\tbegin\n\t\tlast_is_control  <=  1'b0;\n\t\tlast_is_data \t <=  1'b0;\n\t\tlast_is_timec \t <=  1'b0;\n\n\t\trx_data_flag     <=  9'd0; \n\t\ttimecode    \t <=  8'd0;\n\n\t\tstate_data_process <= 2'd0;\n\n\t\trx_error_c <= 1'b0;\n\t\trx_error_d <= 1'b0;\n\n\t\trx_got_fct        <= 1'b0;\n\tend\n\telse\n\tbegin\n\n\t\tstate_data_process <= next_state_data_process;\n\n\t\tcase(state_data_process)\n\t\t2'd0:\n\t\tbegin\n\n\t\t\trx_error_c <= rx_error_c;\n\t\t\trx_error_d <= rx_error_d;\n\n\t\t\tif(ready_control_p_r)\n\t\t\tbegin\n\t\t\t\tif(control_l_r[2:0] != 3'd7 && control_p_r[2:0] == 3'd4)\n\t\t\t\tbegin\n\t\t\t\t\trx_got_fct        <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trx_got_fct        <= 1'b0;\n\t\t\t\tend\n\n\t\t\t\tif(control_p_r[2:0] == 3'd6)\n\t\t\t\tbegin\n\t\t\t\t\trx_data_flag <= 9'b100000001;\n\t\t\t\tend\n\t\t\t\telse if(control_p_r[2:0] == 3'd5)\n\t\t\t\tbegin\n\t\t\t\t\trx_data_flag <= 9'b100000000;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trx_data_flag <= rx_data_flag;\n\t\t\t\tend\n\n\t\t\t\tlast_is_control \t <= 1'b1;\n\t\t\t\tlast_is_data    \t <= 1'b0;\n\t\t\t\tlast_is_timec   \t <= 1'b0;\n\n\t\t\tend\n\t\t\telse if(ready_data_p_r)\n\t\t\tbegin\n\t\t\t\trx_got_fct        <= 1'b0;\n\t\t\t\t\n\t\t\t\tif(control_p_r[2:0] == 3'd7)\n\t\t\t\tbegin\n\t\t\t\t\ttimecode     <=  {dta_timec_p[7],dta_timec_p[6],dta_timec_p[5],dta_timec_p[4],dta_timec_p[3],dta_timec_p[2],dta_timec_p[1],dta_timec_p[0]};\n\t\t\t\t\tlast_is_control  \t<= 1'b0;\n\t\t\t\t\tlast_is_data     \t<= 1'b0;\n\t\t\t\t\tlast_is_timec    \t<= 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trx_data_flag\t<= {dta_timec_p[8],dta_timec_p[7],dta_timec_p[6],dta_timec_p[5],dta_timec_p[4],dta_timec_p[3],dta_timec_p[2],dta_timec_p[1],dta_timec_p[0]};\t\t\t\t\t\n\t\t\t\t\tlast_is_control  \t<=1'b0;\n\t\t\t\t\tlast_is_data     \t<=1'b1;\n\t\t\t\t\tlast_is_timec    \t<=1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\trx_got_fct        <= 1'b0;\n\t\t\t\ttimecode    \t<= timecode;\n\t\t\tend\n\t\t\t\n\t\tend\n\t\t2'd1:\n\t\tbegin\n\n\t\t\tif(ready_control_p_r)\n\t\t\tbegin\n\n\t\t\t\tif(parity_rec_c_gen != parity_rec_c)\n\t\t\t\tbegin\n\t\t\t\t\trx_error_c <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\trx_error_c <= rx_error_c;\n\n\t\t\t\trx_got_fct        <= rx_got_fct;\n\n\t\t\tend\n\t\t\telse if(ready_data_p_r)\n\t\t\tbegin\n\n\t\t\t\tif(parity_rec_d_gen != parity_rec_d)\n\t\t\t\tbegin\n\t\t\t\t\trx_error_d <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\trx_error_d <= rx_error_d;\n\t\t\t\t\n\t\t\t\trx_got_fct        <= 1'b0;\n\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\trx_error_c <= rx_error_c;\n\t\t\t\trx_error_d <= rx_error_d;\n\t\t\t\trx_got_fct        <= 1'b0;\n\t\t\tend\n\n\t\t\trx_data_flag\t<= rx_data_flag;\n\t\t\ttimecode    \t<= timecode;\n\t\tend\n\t\tdefault:\n\t\tbegin\n\t\t\t\trx_data_flag\t<= rx_data_flag;\n\t\t\t\ttimecode    \t<= timecode;\n\t\t\t\trx_got_fct      <= rx_got_fct;\n\t\t\t\n\t\tend\n\t\tendcase\t\n\tend\nend\n\nendmodule\n",
        "module_name": "rx_data_receive",
        "module_hash": "b1b84cac049708955c379fc9f0839054",
        "dataset_index": 7184
      },
      "squarer_f3ec2a4f": {
        "rtl_code": "`ifndef __POW_2P1__\n`define __POW_2P1__\nmodule squarer(a, d);\n\ninput wire [232:0] a;\noutput wire [232:0] d;\n\nassign d[0] = a[0] ^ a[196];\nassign d[1] = a[117];\nassign d[2] = a[1] ^ a[197];\nassign d[3] = a[118];\nassign d[4] = a[2] ^ a[198];\nassign d[5] = a[119];\nassign d[6] = a[3] ^ a[199];\nassign d[7] = a[120];\nassign d[8] = a[4] ^ a[200];\nassign d[9] = a[121];\nassign d[10] = a[5] ^ a[201];\nassign d[11] = a[122];\nassign d[12] = a[6] ^ a[202];\nassign d[13] = a[123];\nassign d[14] = a[7] ^ a[203];\nassign d[15] = a[124];\nassign d[16] = a[8] ^ a[204];\nassign d[17] = a[125];\nassign d[18] = a[9] ^ a[205];\nassign d[19] = a[126];\nassign d[20] = a[10] ^ a[206];\nassign d[21] = a[127];\nassign d[22] = a[11] ^ a[207];\nassign d[23] = a[128];\nassign d[24] = a[12] ^ a[208];\nassign d[25] = a[129];\nassign d[26] = a[13] ^ a[209];\nassign d[27] = a[130];\nassign d[28] = a[14] ^ a[210];\nassign d[29] = a[131];\nassign d[30] = a[15] ^ a[211];\nassign d[31] = a[132];\nassign d[32] = a[16] ^ a[212];\nassign d[33] = a[133];\nassign d[34] = a[17] ^ a[213];\nassign d[35] = a[134];\nassign d[36] = a[18] ^ a[214];\nassign d[37] = a[135];\nassign d[38] = a[19] ^ a[215];\nassign d[39] = a[136];\nassign d[40] = a[20] ^ a[216];\nassign d[41] = a[137];\nassign d[42] = a[21] ^ a[217];\nassign d[43] = a[138];\nassign d[44] = a[22] ^ a[218];\nassign d[45] = a[139];\nassign d[46] = a[23] ^ a[219];\nassign d[47] = a[140];\nassign d[48] = a[24] ^ a[220];\nassign d[49] = a[141];\nassign d[50] = a[25] ^ a[221];\nassign d[51] = a[142];\nassign d[52] = a[26] ^ a[222];\nassign d[53] = a[143];\nassign d[54] = a[27] ^ a[223];\nassign d[55] = a[144];\nassign d[56] = a[28] ^ a[224];\nassign d[57] = a[145];\nassign d[58] = a[29] ^ a[225];\nassign d[59] = a[146];\nassign d[60] = a[30] ^ a[226];\nassign d[61] = a[147];\nassign d[62] = a[31] ^ a[227];\nassign d[63] = a[148];\nassign d[64] = a[32] ^ a[228];\nassign d[65] = a[149];\nassign d[66] = a[33] ^ a[229];\nassign d[67] = a[150];\nassign d[68] = a[34] ^ a[230];\nassign d[69] = a[151];\nassign d[70] = a[35] ^ a[231];\nassign d[71] = a[152];\nassign d[72] = a[36] ^ a[232];\nassign d[73] = a[153];\nassign d[74] = a[37] ^ a[196];\nassign d[75] = a[117] ^ a[154];\nassign d[76] = a[38] ^ a[197];\nassign d[77] = a[118] ^ a[155];\nassign d[78] = a[39] ^ a[198];\nassign d[79] = a[119] ^ a[156];\nassign d[80] = a[40] ^ a[199];\nassign d[81] = a[120] ^ a[157];\nassign d[82] = a[41] ^ a[200];\nassign d[83] = a[121] ^ a[158];\nassign d[84] = a[42] ^ a[201];\nassign d[85] = a[122] ^ a[159];\nassign d[86] = a[43] ^ a[202];\nassign d[87] = a[123] ^ a[160];\nassign d[88] = a[44] ^ a[203];\nassign d[89] = a[124] ^ a[161];\nassign d[90] = a[45] ^ a[204];\nassign d[91] = a[125] ^ a[162];\nassign d[92] = a[46] ^ a[205];\nassign d[93] = a[126] ^ a[163];\nassign d[94] = a[47] ^ a[206];\nassign d[95] = a[127] ^ a[164];\nassign d[96] = a[48] ^ a[207];\nassign d[97] = a[128] ^ a[165];\nassign d[98] = a[49] ^ a[208];\nassign d[99] = a[129] ^ a[166];\nassign d[100] = a[50] ^ a[209];\nassign d[101] = a[130] ^ a[167];\nassign d[102] = a[51] ^ a[210];\nassign d[103] = a[131] ^ a[168];\nassign d[104] = a[52] ^ a[211];\nassign d[105] = a[132] ^ a[169];\nassign d[106] = a[53] ^ a[212];\nassign d[107] = a[133] ^ a[170];\nassign d[108] = a[54] ^ a[213];\nassign d[109] = a[134] ^ a[171];\nassign d[110] = a[55] ^ a[214];\nassign d[111] = a[135] ^ a[172];\nassign d[112] = a[56] ^ a[215];\nassign d[113] = a[136] ^ a[173];\nassign d[114] = a[57] ^ a[216];\nassign d[115] = a[137] ^ a[174];\nassign d[116] = a[58] ^ a[217];\nassign d[117] = a[138] ^ a[175];\nassign d[118] = a[59] ^ a[218];\nassign d[119] = a[139] ^ a[176];\nassign d[120] = a[60] ^ a[219];\nassign d[121] = a[140] ^ a[177];\nassign d[122] = a[61] ^ a[220];\nassign d[123] = a[141] ^ a[178];\nassign d[124] = a[62] ^ a[221];\nassign d[125] = a[142] ^ a[179];\nassign d[126] = a[63] ^ a[222];\nassign d[127] = a[143] ^ a[180];\nassign d[128] = a[64] ^ a[223];\nassign d[129] = a[144] ^ a[181];\nassign d[130] = a[65] ^ a[224];\nassign d[131] = a[145] ^ a[182];\nassign d[132] = a[66] ^ a[225];\nassign d[133] = a[146] ^ a[183];\nassign d[134] = a[67] ^ a[226];\nassign d[135] = a[147] ^ a[184];\nassign d[136] = a[68] ^ a[227];\nassign d[137] = a[148] ^ a[185];\nassign d[138] = a[69] ^ a[228];\nassign d[139] = a[149] ^ a[186];\nassign d[140] = a[70] ^ a[229];\nassign d[141] = a[150] ^ a[187];\nassign d[142] = a[71] ^ a[230];\nassign d[143] = a[151] ^ a[188];\nassign d[144] = a[72] ^ a[231];\nassign d[145] = a[152] ^ a[189];\nassign d[146] = a[73] ^ a[232];\nassign d[147] = a[153] ^ a[190];\nassign d[148] = a[74];\nassign d[149] = a[154] ^ a[191];\nassign d[150] = a[75];\nassign d[151] = a[155] ^ a[192];\nassign d[152] = a[76];\nassign d[153] = a[156] ^ a[193];\nassign d[154] = a[77];\nassign d[155] = a[157] ^ a[194];\nassign d[156] = a[78];\nassign d[157] = a[158] ^ a[195];\nassign d[158] = a[79];\nassign d[159] = a[159] ^ a[196];\nassign d[160] = a[80];\nassign d[161] = a[160] ^ a[197];\nassign d[162] = a[81];\nassign d[163] = a[161] ^ a[198];\nassign d[164] = a[82];\nassign d[165] = a[162] ^ a[199];\nassign d[166] = a[83];\nassign d[167] = a[163] ^ a[200];\nassign d[168] = a[84];\nassign d[169] = a[164] ^ a[201];\nassign d[170] = a[85];\nassign d[171] = a[165] ^ a[202];\nassign d[172] = a[86];\nassign d[173] = a[166] ^ a[203];\nassign d[174] = a[87];\nassign d[175] = a[167] ^ a[204];\nassign d[176] = a[88];\nassign d[177] = a[168] ^ a[205];\nassign d[178] = a[89];\nassign d[179] = a[169] ^ a[206];\nassign d[180] = a[90];\nassign d[181] = a[170] ^ a[207];\nassign d[182] = a[91];\nassign d[183] = a[171] ^ a[208];\nassign d[184] = a[92];\nassign d[185] = a[172] ^ a[209];\nassign d[186] = a[93];\nassign d[187] = a[173] ^ a[210];\nassign d[188] = a[94];\nassign d[189] = a[174] ^ a[211];\nassign d[190] = a[95];\nassign d[191] = a[175] ^ a[212];\nassign d[192] = a[96];\nassign d[193] = a[176] ^ a[213];\nassign d[194] = a[97];\nassign d[195] = a[177] ^ a[214];\nassign d[196] = a[98];\nassign d[197] = a[178] ^ a[215];\nassign d[198] = a[99];\nassign d[199] = a[179] ^ a[216];\nassign d[200] = a[100];\nassign d[201] = a[180] ^ a[217];\nassign d[202] = a[101];\nassign d[203] = a[181] ^ a[218];\nassign d[204] = a[102];\nassign d[205] = a[182] ^ a[219];\nassign d[206] = a[103];\nassign d[207] = a[183] ^ a[220];\nassign d[208] = a[104];\nassign d[209] = a[184] ^ a[221];\nassign d[210] = a[105];\nassign d[211] = a[185] ^ a[222];\nassign d[212] = a[106];\nassign d[213] = a[186] ^ a[223];\nassign d[214] = a[107];\nassign d[215] = a[187] ^ a[224];\nassign d[216] = a[108];\nassign d[217] = a[188] ^ a[225];\nassign d[218] = a[109];\nassign d[219] = a[189] ^ a[226];\nassign d[220] = a[110];\nassign d[221] = a[190] ^ a[227];\nassign d[222] = a[111];\nassign d[223] = a[191] ^ a[228];\nassign d[224] = a[112];\nassign d[225] = a[192] ^ a[229];\nassign d[226] = a[113];\nassign d[227] = a[193] ^ a[230];\nassign d[228] = a[114];\nassign d[229] = a[194] ^ a[231];\nassign d[230] = a[115];\nassign d[231] = a[195] ^ a[232];\nassign d[232] = a[116];\nendmodule\n`endif\n",
        "module_name": "squarer",
        "module_hash": "f3ec2a4f1408cc2ca0a8060edc874da8",
        "dataset_index": 13527
      },
      "top__d605d648": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n\n    // D flip-flops to synchronize inputs\n    reg [7:0] a_sync;\n    reg [7:0] b_sync;\n    always @(posedge clk) begin\n        if (reset) begin\n            a_sync <= 8'b0;\n            b_sync <= 8'b0;\n        end else begin\n            a_sync <= a;\n            b_sync <= b;\n        end\n    end\n\n    // Ripple-carry adder\n    wire [7:0] carry;\n    full_adder fa0(a_sync[0], b_sync[0], 1'b0, sum[0], carry[0]);\n    full_adder fa1(a_sync[1], b_sync[1], carry[0], sum[1], carry[1]);\n    full_adder fa2(a_sync[2], b_sync[2], carry[1], sum[2], carry[2]);\n    full_adder fa3(a_sync[3], b_sync[3], carry[2], sum[3], carry[3]);\n    full_adder fa4(a_sync[4], b_sync[4], carry[3], sum[4], carry[4]);\n    full_adder fa5(a_sync[5], b_sync[5], carry[4], sum[5], carry[5]);\n    full_adder fa6(a_sync[6], b_sync[6], carry[5], sum[6], carry[6]);\n    full_adder fa7(a_sync[7], b_sync[7], carry[6], sum[7], carry[7]);\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input C_in,\n    output Sum,\n    output C_out\n);\n    assign Sum = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule",
        "module_name": "top_",
        "module_hash": "d605d648c540c08baadf1355ade55435",
        "dataset_index": 19379
      },
      "dffsr_0ce292b4": {
        "rtl_code": "module dffsr (\n    input clk,\n    input d,\n    input set,\n    input reset,\n    input preset,\n    output reg q,\n    output reg q_bar\n    );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 1'b0;\n            q_bar <= 1'b1;\n        end else if (set) begin\n            q <= 1'b1;\n            q_bar <= 1'b0;\n        end else if (preset) begin\n            q <= 1'b1;\n            q_bar <= 1'b0;\n        end else begin\n            q <= d;\n            q_bar <= ~d;\n        end\n    end\n\nendmodule",
        "module_name": "dffsr",
        "module_hash": "0ce292b44e4f893a58b253572404a2f4",
        "dataset_index": 3543
      },
      "ex_pipe_reg_4bc2d55c": {
        "rtl_code": "module ex_pipe_reg\n    (\n        input   wire        clk,\n        input   wire        reset,\n        input   wire        clr,\n        input   wire        valid_ex_pipe_reg_i,\n        input   wire[2:0]   funct3_ex_pipe_reg_i,\n        input   wire[6:0]   op_ex_pipe_reg_i,\n        input   wire[4:0]   rs1_ex_pipe_reg_i,\n        input   wire[4:0]   rs2_ex_pipe_reg_i,\n        input   wire[4:0]   rd_ex_pipe_reg_i,\n        input   wire        is_r_type_ex_pipe_reg_i,\n        input   wire        is_i_type_ex_pipe_reg_i,\n        input   wire        is_s_type_ex_pipe_reg_i,\n        input   wire        is_b_type_ex_pipe_reg_i,\n        input   wire        is_u_type_ex_pipe_reg_i,\n        input   wire        is_j_type_ex_pipe_reg_i,\n        input   wire[1:0]   pc_sel_ex_pipe_reg_i,\n        input   wire        op1sel_ex_pipe_reg_i,\n        input   wire[1:0]   op2sel_ex_pipe_reg_i,\n        input   wire[1:0]   wb_sel_ex_pipe_reg_i,\n        input   wire        pc4_sel_ex_pipe_reg_i,\n        input   wire        mem_wr_ex_pipe_reg_i,\n        input   wire        cpr_en_ex_pipe_reg_i,\n        input   wire        wa_sel_ex_pipe_reg_i,\n        input   wire        rf_en_ex_pipe_reg_i,\n        input   wire[5:0]   alu_fun_ex_pipe_reg_i,\n        input   wire[31:0]  next_seq_pc_ex_pipe_reg_i,\n        input   wire[31:0]  curr_pc_ex_pipe_reg_i,\n        input   wire[31:0]  next_brn_pc_ex_pipe_reg_i,\n        input   wire[31:0]  next_pred_pc_ex_pipe_reg_i,\n        input   wire[31:0]  sext_imm_ex_pipe_reg_i,\n        input   wire[31:0]  r_data_p1_ex_pipe_reg_i,\n        input   wire[31:0]  r_data_p2_ex_pipe_reg_i,\n        input   wire        jump_ex_pipe_reg_i,\n        input   wire        brn_pred_ex_pipe_reg_i,\n        output  wire        valid_ex_pipe_reg_o,\n        output  wire[2:0]   funct3_ex_pipe_reg_o,\n        output  wire[6:0]   op_ex_pipe_reg_o,\n        output  wire[4:0]   rs1_ex_pipe_reg_o,\n        output  wire[4:0]   rs2_ex_pipe_reg_o,\n        output  wire[4:0]   rd_ex_pipe_reg_o,\n        output  wire        is_r_type_ex_pipe_reg_o,\n        output  wire        is_i_type_ex_pipe_reg_o,\n        output  wire        is_s_type_ex_pipe_reg_o,\n        output  wire        is_b_type_ex_pipe_reg_o,\n        output  wire        is_u_type_ex_pipe_reg_o,\n        output  wire        is_j_type_ex_pipe_reg_o,\n        output  wire[1:0]   pc_sel_ex_pipe_reg_o,\n        output  wire        op1sel_ex_pipe_reg_o,\n        output  wire[1:0]   op2sel_ex_pipe_reg_o,\n        output  wire[1:0]   wb_sel_ex_pipe_reg_o,\n        output  wire        pc4_sel_ex_pipe_reg_o,\n        output  wire        mem_wr_ex_pipe_reg_o,\n        output  wire        cpr_en_ex_pipe_reg_o,\n        output  wire        wa_sel_ex_pipe_reg_o,\n        output  wire        rf_en_ex_pipe_reg_o,\n        output  wire[5:0]   alu_fun_ex_pipe_reg_o,\n        output  wire[31:0]  next_seq_pc_ex_pipe_reg_o,\n        output  wire[31:0]  curr_pc_ex_pipe_reg_o,\n        output  wire[31:0]  next_brn_pc_ex_pipe_reg_o,\n        output  wire[31:0]  next_pred_pc_ex_pipe_reg_o,\n        output  wire[31:0]  sext_imm_ex_pipe_reg_o,\n        output  wire[31:0]  r_data_p1_ex_pipe_reg_o,\n        output  wire[31:0]  r_data_p2_ex_pipe_reg_o,\n        output  wire        jump_ex_pipe_reg_o,\n        output  wire        brn_pred_ex_pipe_reg_o\n    );\n\n    reg        valid_ex_pipe_reg;\n    reg[2:0]   funct3_ex_pipe_reg;\n    reg[6:0]   op_ex_pipe_reg;\n    reg[4:0]   rs1_ex_pipe_reg;\n    reg[4:0]   rs2_ex_pipe_reg;\n    reg[4:0]   rd_ex_pipe_reg;\n    reg        is_r_type_ex_pipe_reg;\n    reg        is_i_type_ex_pipe_reg;\n    reg        is_s_type_ex_pipe_reg;\n    reg        is_b_type_ex_pipe_reg;\n    reg        is_u_type_ex_pipe_reg;\n    reg        is_j_type_ex_pipe_reg;\n    reg[1:0]   pc_sel_ex_pipe_reg;\n    reg        op1sel_ex_pipe_reg;\n    reg[1:0]   op2sel_ex_pipe_reg;\n    reg[1:0]   wb_sel_ex_pipe_reg;\n    reg        pc4_sel_ex_pipe_reg;\n    reg        mem_wr_ex_pipe_reg;\n    reg        cpr_en_ex_pipe_reg;\n    reg        wa_sel_ex_pipe_reg;\n    reg        rf_en_ex_pipe_reg;\n    reg[5:0]   alu_fun_ex_pipe_reg;\n    reg[31:0]  next_seq_pc_ex_pipe_reg;\n    reg[31:0]  curr_pc_ex_pipe_reg;\n    reg[31:0]  next_brn_pc_ex_pipe_reg;\n    reg[31:0]  next_pred_pc_ex_pipe_reg;\n    reg[31:0]  sext_imm_ex_pipe_reg;    \n    reg[31:0]  r_data_p1_ex_pipe_reg;\n    reg[31:0]  r_data_p2_ex_pipe_reg;\n    reg        jump_ex_pipe_reg;\n    reg        brn_pred_ex_pipe_reg;\n\n    assign valid_ex_pipe_reg_o          = valid_ex_pipe_reg;\n    assign funct3_ex_pipe_reg_o         = funct3_ex_pipe_reg;\n    assign op_ex_pipe_reg_o             = op_ex_pipe_reg;\n    assign rs1_ex_pipe_reg_o            = rs1_ex_pipe_reg;\n    assign rs2_ex_pipe_reg_o            = rs2_ex_pipe_reg;\n    assign rd_ex_pipe_reg_o             = rd_ex_pipe_reg;\n    assign is_r_type_ex_pipe_reg_o      = is_r_type_ex_pipe_reg;\n    assign is_i_type_ex_pipe_reg_o      = is_i_type_ex_pipe_reg;\n    assign is_s_type_ex_pipe_reg_o      = is_s_type_ex_pipe_reg;\n    assign is_b_type_ex_pipe_reg_o      = is_b_type_ex_pipe_reg;\n    assign is_u_type_ex_pipe_reg_o      = is_u_type_ex_pipe_reg;\n    assign is_j_type_ex_pipe_reg_o      = is_j_type_ex_pipe_reg;\n    assign pc_sel_ex_pipe_reg_o         = pc_sel_ex_pipe_reg;\n    assign op1sel_ex_pipe_reg_o         = op1sel_ex_pipe_reg;\n    assign op2sel_ex_pipe_reg_o         = op2sel_ex_pipe_reg;\n    assign wb_sel_ex_pipe_reg_o         = wb_sel_ex_pipe_reg;\n    assign pc4_sel_ex_pipe_reg_o        = pc4_sel_ex_pipe_reg;\n    assign mem_wr_ex_pipe_reg_o         = mem_wr_ex_pipe_reg;\n    assign cpr_en_ex_pipe_reg_o         = cpr_en_ex_pipe_reg;\n    assign wa_sel_ex_pipe_reg_o         = wa_sel_ex_pipe_reg;\n    assign rf_en_ex_pipe_reg_o          = rf_en_ex_pipe_reg;\n    assign alu_fun_ex_pipe_reg_o        = alu_fun_ex_pipe_reg;\n    assign next_seq_pc_ex_pipe_reg_o    = next_seq_pc_ex_pipe_reg;\n    assign curr_pc_ex_pipe_reg_o        = curr_pc_ex_pipe_reg;\n    assign next_brn_pc_ex_pipe_reg_o    = next_brn_pc_ex_pipe_reg;\n    assign next_pred_pc_ex_pipe_reg_o   = next_pred_pc_ex_pipe_reg;\n    assign sext_imm_ex_pipe_reg_o       = sext_imm_ex_pipe_reg;\n    assign r_data_p1_ex_pipe_reg_o      = r_data_p1_ex_pipe_reg;\n    assign r_data_p2_ex_pipe_reg_o      = r_data_p2_ex_pipe_reg;\n    assign jump_ex_pipe_reg_o           = jump_ex_pipe_reg;\n    assign brn_pred_ex_pipe_reg_o       = brn_pred_ex_pipe_reg;\n\n    always @ (posedge clk)\n    if (reset | clr)\n    begin\n        valid_ex_pipe_reg           <= 1'b0;\n        funct3_ex_pipe_reg          <= 3'b0;\n        op_ex_pipe_reg              <= 7'b0;\n        rs1_ex_pipe_reg             <= 4'b0;\n        rs2_ex_pipe_reg             <= 4'b0;\n        rd_ex_pipe_reg              <= 4'b0;\n        is_r_type_ex_pipe_reg       <= 1'b0;\n        is_i_type_ex_pipe_reg       <= 1'b0;\n        is_s_type_ex_pipe_reg       <= 1'b0;\n        is_b_type_ex_pipe_reg       <= 1'b0;\n        is_u_type_ex_pipe_reg       <= 1'b0;\n        is_j_type_ex_pipe_reg       <= 1'b0;\n        pc_sel_ex_pipe_reg          <= 2'b0;\n        op1sel_ex_pipe_reg          <= 1'b0;\n        op2sel_ex_pipe_reg          <= 2'b0;\n        wb_sel_ex_pipe_reg          <= 2'b0;\n        pc4_sel_ex_pipe_reg         <= 1'b0;\n        mem_wr_ex_pipe_reg          <= 1'b0;\n        cpr_en_ex_pipe_reg          <= 1'b0;\n        wa_sel_ex_pipe_reg          <= 1'b0;\n        rf_en_ex_pipe_reg           <= 1'b0;\n        alu_fun_ex_pipe_reg         <= 6'b0;\n        next_seq_pc_ex_pipe_reg     <= 31'b0;\n        curr_pc_ex_pipe_reg         <= 31'b0;\n        next_brn_pc_ex_pipe_reg     <= 31'b0;\n        next_pred_pc_ex_pipe_reg    <= 31'b0;\n        sext_imm_ex_pipe_reg        <= 31'b0;\n        r_data_p1_ex_pipe_reg       <= 31'b0;\n        r_data_p2_ex_pipe_reg       <= 31'b0;\n        jump_ex_pipe_reg            <= 1'b0;\n        brn_pred_ex_pipe_reg        <= 1'b0;\n    end\n    else\n    begin\n        valid_ex_pipe_reg           <=  valid_ex_pipe_reg_i;\n        funct3_ex_pipe_reg          <=  funct3_ex_pipe_reg_i;\n        op_ex_pipe_reg              <=  op_ex_pipe_reg_i;\n        rs1_ex_pipe_reg             <=  rs1_ex_pipe_reg_i;\n        rs2_ex_pipe_reg             <=  rs2_ex_pipe_reg_i;\n        rd_ex_pipe_reg              <=  rd_ex_pipe_reg_i;\n        is_r_type_ex_pipe_reg       <=  is_r_type_ex_pipe_reg_i;\n        is_i_type_ex_pipe_reg       <=  is_i_type_ex_pipe_reg_i;\n        is_s_type_ex_pipe_reg       <=  is_s_type_ex_pipe_reg_i;\n        is_b_type_ex_pipe_reg       <=  is_b_type_ex_pipe_reg_i;\n        is_u_type_ex_pipe_reg       <=  is_u_type_ex_pipe_reg_i;\n        is_j_type_ex_pipe_reg       <=  is_j_type_ex_pipe_reg_i;\n        pc_sel_ex_pipe_reg          <=  pc_sel_ex_pipe_reg_i;\n        op1sel_ex_pipe_reg          <=  op1sel_ex_pipe_reg_i;\n        op2sel_ex_pipe_reg          <=  op2sel_ex_pipe_reg_i;\n        wb_sel_ex_pipe_reg          <=  wb_sel_ex_pipe_reg_i;\n        pc4_sel_ex_pipe_reg         <=  pc4_sel_ex_pipe_reg_i;\n        mem_wr_ex_pipe_reg          <=  mem_wr_ex_pipe_reg_i;\n        cpr_en_ex_pipe_reg          <=  cpr_en_ex_pipe_reg_i;\n        wa_sel_ex_pipe_reg          <=  wa_sel_ex_pipe_reg_i;\n        rf_en_ex_pipe_reg           <=  rf_en_ex_pipe_reg_i;\n        alu_fun_ex_pipe_reg         <=  alu_fun_ex_pipe_reg_i;\n        next_seq_pc_ex_pipe_reg     <=  next_seq_pc_ex_pipe_reg_i;\n        curr_pc_ex_pipe_reg         <=  curr_pc_ex_pipe_reg_i;\n        next_brn_pc_ex_pipe_reg     <=  next_brn_pc_ex_pipe_reg_i;\n        next_pred_pc_ex_pipe_reg    <=  next_pred_pc_ex_pipe_reg_i;\n        sext_imm_ex_pipe_reg        <=  sext_imm_ex_pipe_reg_i;\n        r_data_p1_ex_pipe_reg       <=  r_data_p1_ex_pipe_reg_i;\n        r_data_p2_ex_pipe_reg       <=  r_data_p2_ex_pipe_reg_i;\n        jump_ex_pipe_reg            <=  jump_ex_pipe_reg_i;\n        brn_pred_ex_pipe_reg        <=  brn_pred_ex_pipe_reg_i;\n    end\n\nendmodule\n",
        "module_name": "ex_pipe_reg",
        "module_hash": "4bc2d55c54067cf092e686d4659c2dee",
        "dataset_index": 6291
      },
      "spi_clgen_ca37f420": {
        "rtl_code": "\n`include \"spi_defines.v\"\n`include \"timescale.v\"\n\nmodule spi_clgen (clk_in, rst, go, enable, last_clk, divider, clk_out, pos_edge, neg_edge); \n\n  parameter Tp = 1;\n  \n  input                            clk_in;   // input clock (system clock)\n  input                            rst;      // reset\n  input                            enable;   // clock enable\n  input                            go;       // start transfer\n  input                            last_clk; // last clock\n  input     [`SPI_DIVIDER_LEN-1:0] divider;  // clock divider (output clock is divided by this value)\n  output                           clk_out;  // output clock\n  output                           pos_edge; // pulse marking positive edge of clk_out\n  output                           neg_edge; // pulse marking negative edge of clk_out\n                            \n  reg                              clk_out;\n  reg                              pos_edge;\n  reg                              neg_edge;\n                            \n  reg       [`SPI_DIVIDER_LEN-1:0] cnt;      // clock counter \n  wire                             cnt_zero; // conter is equal to zero\n  wire                             cnt_one;  // conter is equal to one\n  \n  \n  assign cnt_zero = cnt == {`SPI_DIVIDER_LEN{1'b0}};\n  assign cnt_one  = cnt == {{`SPI_DIVIDER_LEN-1{1'b0}}, 1'b1};\n  \n  // Counter counts half period\n  always @(posedge clk_in or posedge rst)\n  begin\n    if(rst)\n      cnt <= #Tp {`SPI_DIVIDER_LEN{1'b1}};\n    else\n      begin\n        if(!enable || cnt_zero)\n          cnt <= #Tp divider;\n        else\n          cnt <= #Tp cnt - {{`SPI_DIVIDER_LEN-1{1'b0}}, 1'b1};\n      end\n  end\n  \n  // clk_out is asserted every other half period\n  always @(posedge clk_in or posedge rst)\n  begin\n    if(rst)\n      clk_out <= #Tp 1'b0;\n    else\n      clk_out <= #Tp (enable && cnt_zero && (!last_clk || clk_out)) ? ~clk_out : clk_out;\n  end\n   \n  // Pos and neg edge signals\n  always @(posedge clk_in or posedge rst)\n  begin\n    if(rst)\n      begin\n        pos_edge  <= #Tp 1'b0;\n        neg_edge  <= #Tp 1'b0;\n      end\n    else\n      begin\n        pos_edge  <= #Tp (enable && !clk_out && cnt_one) || (!(|divider) && clk_out) || (!(|divider) && go && !enable);\n        neg_edge  <= #Tp (enable && clk_out && cnt_one) || (!(|divider) && !clk_out && enable);\n      end\n  end\nendmodule\n \n",
        "module_name": "spi_clgen",
        "module_hash": "ca37f420a7b383e5897276dfd66e7e42",
        "dataset_index": 74
      },
      "mux_256to1_414683e2": {
        "rtl_code": "\nmodule mux_256to1(\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\nwire sel_temp;\n\nassign sel_temp = sel[7];\nassign out = sel_temp ? in[sel[6:0]] : 1'b0;\n\nendmodule",
        "module_name": "mux_256to1",
        "module_hash": "414683e2f7c7fa901c96e4cbefc01b49",
        "dataset_index": 19219
      },
      "oneshot_2clk_abf2d5f8": {
        "rtl_code": "module oneshot_2clk\n  (input clk_in,\n   input in,\n   input clk_out,\n   output reg out);\n\n   reg \t  del_in = 0;\n   reg \t  sendit = 0, gotit = 0;\n   reg \t  sendit_d = 0, gotit_d = 0;\n   \n   always @(posedge clk_in) del_in <= in;\n\n   always @(posedge clk_in)\n     if(in & ~del_in)  sendit <= 1;\n     else if(gotit)\n       sendit <= 0;\n\n   always @(posedge clk_out) sendit_d <= sendit;\n   always @(posedge clk_out) out <= sendit_d;\n\n   always @(posedge clk_in) gotit_d <= out;\n   always @(posedge clk_in) gotit <= gotit_d;\n\nendmodule ",
        "module_name": "oneshot_2clk",
        "module_hash": "abf2d5f85841ebab0dc0484682be8773",
        "dataset_index": 24604
      },
      "barrel_shifter_79a39736": {
        "rtl_code": "\nmodule barrel_shifter (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[7], in[6], in[5], in[4], in[3], in[2], in[1], in[0]};\nendmodule\nmodule rising_edge_detector (\n    input clk,\n    input [31:0] in32,\n    input reset,\n    output reg [31:0] out\n);\n    reg [31:0] prev_in;\n    reg [31:0] rising_edge_mask;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            prev_in <= 32'b0;\n            rising_edge_mask <= 32'b0;\n            out <= 32'b0;\n        end else begin\n            prev_in <= in32;\n            rising_edge_mask <= (in32 ^ prev_in) & in32;\n            out <= out | rising_edge_mask;\n        end\n    end\nendmodule\nmodule bitwise_or (\n    input [31:0] in1,\n    input [31:0] in2,\n    output [31:0] out\n);\n    assign out = in1 | in2;\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] in,\n    input [31:0] in32,\n    output reg [31:0] out\n);\n    wire [7:0] reversed_in;\n    wire [31:0] rising_edge_out;\n    \n    barrel_shifter bs (\n        .in(in),\n        .out(reversed_in)\n    );\n    \n    rising_edge_detector red (\n        .clk(clk),\n        .in32(in32),\n        .reset(reset),\n        .out(rising_edge_out)\n    );\n    \n    bitwise_or bo (\n        .in1({24'b0, reversed_in}),\n        .in2(rising_edge_out),\n        .out(out)\n    );\nendmodule",
        "module_name": "barrel_shifter",
        "module_hash": "79a39736639555bd45daf80209f6c5a7",
        "dataset_index": 10202
      },
      "control_bc408c0c": {
        "rtl_code": "module control\n#(\n   parameter REG_ADDR_WIDTH = 5\n)\n(\n   input id_ex_mem_data_rd_en,\n   input [REG_ADDR_WIDTH-1:0] id_ex_reg_wr_addr,\n   input if_id_rd_reg_a_en,\n   input if_id_rd_reg_b_en,\n   input [REG_ADDR_WIDTH-1:0] if_id_rd_reg_a_addr,\n   input [REG_ADDR_WIDTH-1:0] if_id_rd_reg_b_addr,\n   input select_new_pc,\n\n   output reg inst_rd_en,\n   output reg stall,\n   output reg general_flush,\n   output reg decode_flush\n);\n\nwire load_hazard;\n\nassign load_hazard = id_ex_mem_data_rd_en &\n                     (((id_ex_reg_wr_addr==if_id_rd_reg_a_addr)&if_id_rd_reg_a_en)|\n                     ((id_ex_reg_wr_addr==if_id_rd_reg_b_addr)&if_id_rd_reg_b_en));\n\nalways@(*)begin\n   if(select_new_pc)begin\n      inst_rd_en = 1;\n      stall = 0;\n      general_flush = 1;\n      decode_flush = 1;\n   end\n   else if(load_hazard)begin\n      inst_rd_en = 0;\n      stall = 1;\n      general_flush = 0;\n      decode_flush = 1;\n   end\n   else begin\n      inst_rd_en = 1;\n      stall = 0;\n      general_flush = 0;\n      decode_flush = 0;\n   end\nend\n\nendmodule\n",
        "module_name": "control",
        "module_hash": "bc408c0cf5bfda14cb093533f4e3e1f1",
        "dataset_index": 23245
      },
      "top_module_78b5ad23": {
        "rtl_code": "module top_module(\n  input wire [15:0] in,\n  input wire [1:0] en1,\n  input wire en2,\n  output wire [7:0] out_hi,\n  output wire [7:0] out_lo\n);\n\n  wire [3:0] dec1_out;\n  wire [15:0] dec2_out;\n  wire [7:0] comp_hi;\n  wire [7:0] comp_lo;\n\n  decoder1 dec1(.in(en1), .enable(en2), .out(dec1_out));\n  decoder2 dec2(.in(dec1_out), .enable(en2), .out(dec2_out));\n\n  assign comp_hi = ~in[15:8];\n  assign comp_lo = ~in[7:0];\n\n  assign out_hi = en1 ? dec2_out[15:8] : 8'b0;\n  assign out_lo = en1 ? comp_lo : comp_hi;\n\nendmodule\n\nmodule decoder1 (\n  input [1:0] in,\n  input enable,\n  output [3:0] out\n);\n  assign out = enable ? {~in[1], ~in[0], in[1], in[0]} : 4'b0;\nendmodule\n\nmodule decoder2 (\n  input [3:0] in,\n  input enable,\n  output [15:0] out\n);\n  assign out = enable ? {~in[3], ~in[2], ~in[1], ~in[0], in[3], in[2], in[1], in[0], ~in[3], ~in[2], ~in[1], in[0], in[3], in[2], in[1], ~in[0]} : 16'b0;\nendmodule",
        "module_name": "top_module",
        "module_hash": "78b5ad2328eb1867eaf08d9e47527250",
        "dataset_index": 21393
      },
      "priority_encoder_2280bff8": {
        "rtl_code": "\nmodule priority_encoder (\n    input [1:0] in,\n    input clk,  // Clock signal\n    output reg [1:0] out\n);\n\nreg [1:0] stage1_out;\nreg [1:0] stage2_out;\n\nalways @(*) begin\n    stage1_out[0] = in[0] | in[1];\n    stage1_out[1] = in[0] & in[1];\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\nend\n\nalways @(*) begin\n    if (stage2_out[1] == 1'b1) begin\n        out <= 2'b10;\n    end else if (stage2_out[0] == 1'b1) begin\n        out <= 2'b01;\n    end else begin\n        out <= 2'b00;\n    end\nend\n\nendmodule\n",
        "module_name": "priority_encoder",
        "module_hash": "2280bff8aed0fb6d8dc93c39c2b1b726",
        "dataset_index": 18408
      },
      "clock_gate_register_6672f7a7": {
        "rtl_code": "module clock_gate_register(CLK, EN, TE, reset, ENCLK);\n    input CLK, EN, TE, reset;\n    output ENCLK;\n\n    reg ENCLK_reg;\n\n    always @(posedge CLK, posedge reset) begin\n        if (reset) begin\n            ENCLK_reg <= 1'b0;\n        end else if (EN) begin\n            ENCLK_reg <= CLK;\n        end\n    end\n\n    assign ENCLK = TE ? ENCLK_reg : 1'b0;\nendmodule",
        "module_name": "clock_gate_register",
        "module_hash": "6672f7a72ddddc5821bca6ca8744f777",
        "dataset_index": 7081
      },
      "single_port_RAM #_5967ef93": {
        "rtl_code": "module single_port_RAM #(\n  parameter n = 8 // number of bits in data_in and data_out\n)(\n  input [n-1:0] data_in,\n  input [8-1:0] address,\n  input write_en,\n  input clk,\n  output reg [n-1:0] data_out\n);\n\nparameter depth = 256; // depth of the RAM block (i.e., number of memory locations)\n\nreg [n-1:0] memory [0:depth-1]; // define memory array\n\nalways @(posedge clk) begin\n  if (write_en) begin\n    memory[address] <= data_in; // write data to memory\n  end\n  else begin\n    data_out <= memory[address]; // read data from memory\n  end\nend\n\nendmodule",
        "module_name": "single_port_RAM #",
        "module_hash": "5967ef93e30891e026ef990950e5c71c",
        "dataset_index": 2110
      },
      "accu_89d1855b": {
        "rtl_code": "module accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_a     ,\n    input               ready_b     ,\n \n    output              ready_a     ,\n    output  reg         valid_b     ,\n    output  reg [9:0]   data_out\n);\n\nreg [7:0] input_reg;\nreg [3:0] counter;\nreg [9:0] accu_result;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        input_reg <= 8'b0;\n        counter <= 4'b0;\n        accu_result <= 10'b0;\n        valid_b <= 1'b0;\n    end\n    else begin\n        if(valid_a && ready_b) begin\n            input_reg <= data_in;\n            counter <= counter + 1;\n            accu_result <= accu_result + data_in;\n        end\n        if(counter == 4) begin\n            data_out <= accu_result;\n            accu_result <= 10'b0;\n            counter <= 4'b0;\n            valid_b <= 1'b1;\n        end\n        else begin\n            data_out <= 10'b0;\n            valid_b <= 1'b0;\n        end\n    end\nend\n\nassign ready_a = !valid_b;\n\nendmodule",
        "module_name": "accu",
        "module_hash": "89d1855b497661a0a2b8a1316dd2c4d5",
        "dataset_index": 5118
      },
      "comparator_612bb751": {
        "rtl_code": "module comparator(\n    input [3:0] A,\n    input [3:0] B,\n    output EQ,\n    output GT,\n    output LT,\n    output NE\n);\n\n    assign EQ = (A == B);\n    assign GT = (A > B);\n    assign LT = (A < B);\n    assign NE = (A != B);\n    \nendmodule",
        "module_name": "comparator",
        "module_hash": "612bb7518c3a2a889be84be924d2dd2c",
        "dataset_index": 6011
      },
      "binary_counter_9763ac35": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    input load,       // Active-high parallel load input\n    input [3:0] load_value, // 4-bit load value\n    output [3:0] q,\n    output carry_out,\n    output led);\n\n    reg [3:0] q_next;   // Next state of the counter\n    reg [3:0] q_reg;    // Current state of the counter\n\n    assign q = q_reg;\n    assign carry_out = (q_reg == 4'b1111) ? 1'b1 : 1'b0;   // Set carry_out high when counter reaches 15\n\n    // Synchronous counter logic\n    always @(posedge clk or negedge reset) begin\n        if (reset == 1'b0) begin\n            q_reg <= 4'b0101;   // Reset counter to 5\n        end else if (load == 1'b1) begin\n            q_reg <= load_value; // Load specific value when load input is high\n        end else begin\n            q_reg <= q_next;    // Update counter with next state\n        end\n    end\n\n    // Combinational logic for next state of the counter\n    always @(*) begin\n        if (q_reg == 4'b1111) begin\n            q_next = 4'b0000;   // If counter is at max value, reset to 0\n        end else begin\n            q_next = q_reg + 1; // Increment counter\n        end\n    end\n\n    // LED control logic\n    assign led = carry_out;\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "9763ac35c1196b29362d44ccf2bc5e6d",
        "dataset_index": 12241
      },
      "fifo_empty_block_e32c6d2f": {
        "rtl_code": "\nmodule fifo_empty_block (\n   rd_fifo_empty, rd_addr, rd_gray_pointer,\n   reset, rd_clk, rd_wr_gray_pointer, rd_read\n   );\n\n   parameter AW   = 2; input           reset;\n   input           rd_clk;\n   \n   input [AW:0]    rd_wr_gray_pointer;input           rd_read;\n   \n   output          rd_fifo_empty;\n   output [AW-1:0] rd_addr;\n   output [AW:0]   rd_gray_pointer;\n   \n   reg [AW:0]      rd_gray_pointer;\n   reg [AW:0]      rd_binary_pointer;\n   reg             rd_fifo_empty;\n\n   wire \t   rd_fifo_empty_next;\n   wire [AW:0]     rd_binary_next;\n   wire [AW:0]     rd_gray_next;\n   \n   \n   always @(posedge rd_clk or posedge reset)\n     if(reset)\n       begin\n\t  rd_binary_pointer[AW:0]     <= {(AW+1){1'b0}};\n\t  rd_gray_pointer[AW:0]       <= {(AW+1){1'b0}};\n       end\n     else if(rd_read)\n       begin\n\t  rd_binary_pointer[AW:0]     <= rd_binary_next[AW:0];\t  \n\t  rd_gray_pointer[AW:0]       <= rd_gray_next[AW:0];\t  \n       end\n\n   assign rd_addr[AW-1:0]        = rd_binary_pointer[AW-1:0];\n\n   assign rd_binary_next[AW:0]  = rd_binary_pointer[AW:0] + \n\t\t\t\t  {{(AW){1'b0}},rd_read};\n\n   assign rd_gray_next[AW:0] = {1'b0,rd_binary_next[AW:1]} ^ \n\t\t\t       rd_binary_next[AW:0];\n\n\n   assign rd_fifo_empty_next = (rd_gray_next[AW:0]==rd_wr_gray_pointer[AW:0]);\n\n   always @ (posedge rd_clk or posedge reset)\n     if(reset)\n       rd_fifo_empty <= 1'b1;\n     else \n       rd_fifo_empty <= rd_fifo_empty_next;\n \nendmodule \n",
        "module_name": "fifo_empty_block",
        "module_hash": "e32c6d2fdeaafd1f711fa71b943f59ac",
        "dataset_index": 24765
      },
      "MIB #_621e56e9": {
        "rtl_code": "module MIB #(\n  parameter data_width = 32 // width of the data bus\n)(\n  input clk,\n  input reset,\n  input enable,\n  input [31:0] address,\n  input [data_width-1:0] write_data,\n  output reg [data_width-1:0] read_data\n);\n\nparameter memory_size = 1024; // size of the memory in bytes\n\nreg [data_width-1:0] memory [memory_size/4-1:0]; // memory array\n\nalways @(posedge clk) begin\n  if (reset) begin\n    read_data <= 0;\n  end else if (enable) begin\n    if (write_data) begin\n      memory[address/4] <= write_data;\n    end\n    read_data <= memory[address/4];\n  end\nend\n\nendmodule",
        "module_name": "MIB #",
        "module_hash": "621e56e98e7b4226d4a16e4378d09c46",
        "dataset_index": 9204
      },
      "fifo_buffer_dd224724": {
        "rtl_code": "module fifo_buffer (\n    input clk,\n    input fifo_clear,\n    input fifo_rd,\n    input rst_n,\n    input [7:0] t_dat,\n    input wr_rfifo,\n    output fifo_EF,\n    output reg [7:0] fifo_rdata,\n    output rfifo_full,\n    output [5:0] rfifo_used\n);\n\n    reg [7:0] fifo [63:0];\n    reg [5:0] fifo_ptr;\n    wire fifo_full;\n    wire fifo_empty;\n\n    assign fifo_full = (fifo_ptr == 63);\n    assign fifo_empty = (fifo_ptr == 0);\n\n    always @(posedge clk) begin\n        if (!rst_n) begin\n            fifo_ptr <= 0;\n        end else if (fifo_clear) begin\n            fifo_ptr <= 0;\n        end else if (wr_rfifo && !fifo_full) begin\n            fifo[fifo_ptr] <= t_dat;\n            fifo_ptr <= fifo_ptr + 1;\n        end else if (fifo_rd && !fifo_empty) begin\n            fifo_rdata <= fifo[0];\n            fifo_ptr <= fifo_ptr - 1;\n        end\n    end\n\n    assign fifo_EF = fifo_empty;\n    assign rfifo_full = fifo_full;\n    assign rfifo_used = fifo_ptr;\n\nendmodule",
        "module_name": "fifo_buffer",
        "module_hash": "dd224724fb1974f9c6cf2dbfcbd75873",
        "dataset_index": 7139
      },
      "multiplier_block_b607a129": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0] o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w64,\n    w63,\n    w4096,\n    w4097,\n    w4161,\n    w504,\n    w3657,\n    w14628;\n\n  assign w1 = i_data0;\n  assign w64 = i_data0 << 6;\n  assign w63 = w64 - w1;\n  assign w504 = w63 << 3;\n  assign w4097 = w1 + w4096;\n  assign w4096 = w1 << 12;\n  assign w4161 = w4097 + w64;\n  assign w3657 = w4161 - w504;\n  assign w14628 = w3657 << 2;\n\n  assign o_data0 = w14628;\n\n  //multiplier_block area estimate = 6446.56316796471;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "b607a129202485ec34760ca2f2b028d8",
        "dataset_index": 3559
      },
      "simple_calculator_92e3487f": {
        "rtl_code": "module simple_calculator(\n  input [2:0] operation,\n  input [7:0] operand_a,\n  input [7:0] operand_b,\n  output reg [7:0] result,\n  output reg overflow,\n  output reg underflow\n);\n\n  always @* begin\n    case(operation)\n      3'b000: result = operand_a + operand_b;\n      3'b001: result = operand_a - operand_b;\n      3'b010: result = operand_a * operand_b;\n      3'b011: result = operand_a / operand_b;\n    endcase\n    if(result > 255) begin\n      overflow = 1;\n      result = result % 256;\n    end else begin\n      overflow = 0;\n    end\n    if(operation == 3'b001 && operand_b > operand_a) begin\n      underflow = 1;\n    end else begin\n      underflow = 0;\n    end\n  end\n  \nendmodule",
        "module_name": "simple_calculator",
        "module_hash": "92e3487f711680112028751c62b5f547",
        "dataset_index": 2521
      },
      "logic_gate_4d60ca0e": {
        "rtl_code": "\nmodule logic_gate (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    // Instantiate the 3-input AND gate\n    and (\n        X,\n        A1,\n        A2,\n        A3,\n        B1\n    );\n\nendmodule",
        "module_name": "logic_gate",
        "module_hash": "4d60ca0e18847d028887c007fafa427b",
        "dataset_index": 9066
      },
      "top__45d096c4": {
        "rtl_code": "module top_module (\n    input clk,\n    input d,\n    input [31:0] in,\n    output reg q,\n    output [31:0] out_xor,\n    output [31:0] out_and,\n    output [31:0] out_final\n );\n\n // D flip-flop using T flip-flop\n reg t;\n always @(posedge clk) begin\n    t <= d;\n end\n always @(posedge clk) begin\n    q <= t;\n end\n\n // Combinational circuit for bit-wise XOR and AND\n assign out_xor = in[31:16] ^ in[15:0];\n assign out_and = in[31:16] & in[15:0];\n\n // Bit-wise OR operation\n assign out_final = q | (out_xor & out_and);\n\nendmodule",
        "module_name": "top_",
        "module_hash": "45d096c4f6664eaa2d0b959488e92bc2",
        "dataset_index": 1731
      },
      "vfabric_down_converter_71f19d20": {
        "rtl_code": "module vfabric_down_converter(clock, resetn, i_start,\n  i_datain, i_datain_valid, o_datain_stall, \n  o_dataout, i_dataout_stall, o_dataout_valid);\n\nparameter DATAIN_WIDTH = 32;\nparameter DATAOUT_WIDTH = 8;\n\n input clock, resetn, i_start;\n input [DATAIN_WIDTH-1:0] i_datain;\n input i_datain_valid;\n output o_datain_stall;\n output [DATAOUT_WIDTH-1:0] o_dataout;\n input i_dataout_stall;\n output o_dataout_valid;\n \nparameter s_IDLE = 3'b100;\nparameter s_SEND_B1 = 3'b000;\nparameter s_SEND_B2 = 3'b001;\nparameter s_SEND_B3 = 3'b010;\nparameter s_SEND_B4 = 3'b011;\n\nreg [2:0] present_state, next_state;\n\nreg [DATAIN_WIDTH-1:0] data_to_send;\nwire latch_new_data;\n\nalways@(*)\nbegin\n   case (present_state)\n    s_IDLE: if (i_datain_valid)\n                next_state <= s_SEND_B1;\n             else\n                next_state <= s_IDLE;\n                \n    s_SEND_B1: if (!i_dataout_stall)\n                 next_state <= s_SEND_B2; \n               else \n                 next_state <= s_SEND_B1; \n    s_SEND_B2: if (!i_dataout_stall)\n                 next_state <= s_SEND_B3; \n               else \n                 next_state <= s_SEND_B2; \n    s_SEND_B3: if (!i_dataout_stall)\n                 next_state <= s_SEND_B4; \n               else \n                 next_state <= s_SEND_B3; \n              \n    s_SEND_B4: if (!i_dataout_stall)\n                 next_state <= i_datain_valid ? s_SEND_B1 : s_IDLE;\n               else \n                 next_state <= s_SEND_B4;\n    \n    default: next_state <= 3'bxxx;\n   endcase\t \nend\n\nalways@(posedge clock or negedge resetn)\nbegin\n  if (~resetn)\n    data_to_send <= {DATAIN_WIDTH{1'b0}};\n  else\n    data_to_send <= (latch_new_data & i_datain_valid) ? \n                        i_datain : data_to_send;\nend \n\nalways@(posedge clock or negedge resetn)\nbegin\n  if (~resetn)\n     present_state <= s_IDLE;\n  else\n     present_state <= (i_start) ? next_state : s_IDLE;\nend\n\n  assign o_dataout = data_to_send[present_state[1:0]*DATAOUT_WIDTH +: DATAOUT_WIDTH];\n  assign o_dataout_valid = ~present_state[2] & i_start;\n    \n  assign latch_new_data = (present_state == s_IDLE) || \n                          ((present_state == s_SEND_B4) & ~i_dataout_stall);\n\n  assign o_datain_stall = (i_start) ? ~latch_new_data : 1'b0;\n \n \nendmodule\n",
        "module_name": "vfabric_down_converter",
        "module_hash": "71f19d2016a2fc3ada5f5865d2500e82",
        "dataset_index": 25659
      },
      "mkRouterOutputArbitersStatic_f3afb7f4": {
        "rtl_code": "\n\n\n`ifdef BSV_ASSIGNMENT_DELAY\n`else\n`define BSV_ASSIGNMENT_DELAY\n`endif\n\nmodule mkRouterOutputArbitersStatic(CLK,\n\t\t\t\t    RST_N,\n\n\t\t\t\t    output_arbs_0_select_requests,\n\t\t\t\t    output_arbs_0_select,\n\n\t\t\t\t    EN_output_arbs_0_next,\n\n\t\t\t\t    output_arbs_1_select_requests,\n\t\t\t\t    output_arbs_1_select,\n\n\t\t\t\t    EN_output_arbs_1_next,\n\n\t\t\t\t    output_arbs_2_select_requests,\n\t\t\t\t    output_arbs_2_select,\n\n\t\t\t\t    EN_output_arbs_2_next,\n\n\t\t\t\t    output_arbs_3_select_requests,\n\t\t\t\t    output_arbs_3_select,\n\n\t\t\t\t    EN_output_arbs_3_next,\n\n\t\t\t\t    output_arbs_4_select_requests,\n\t\t\t\t    output_arbs_4_select,\n\n\t\t\t\t    EN_output_arbs_4_next);\n  input  CLK;\n  input  RST_N;\n\n  input  [4 : 0] output_arbs_0_select_requests;\n  output [4 : 0] output_arbs_0_select;\n\n  input  EN_output_arbs_0_next;\n\n  input  [4 : 0] output_arbs_1_select_requests;\n  output [4 : 0] output_arbs_1_select;\n\n  input  EN_output_arbs_1_next;\n\n  input  [4 : 0] output_arbs_2_select_requests;\n  output [4 : 0] output_arbs_2_select;\n\n  input  EN_output_arbs_2_next;\n\n  input  [4 : 0] output_arbs_3_select_requests;\n  output [4 : 0] output_arbs_3_select;\n\n  input  EN_output_arbs_3_next;\n\n  input  [4 : 0] output_arbs_4_select_requests;\n  output [4 : 0] output_arbs_4_select;\n\n  input  EN_output_arbs_4_next;\n\n  wire [4 : 0] output_arbs_0_select,\n\t       output_arbs_1_select,\n\t       output_arbs_2_select,\n\t       output_arbs_3_select,\n\t       output_arbs_4_select;\n\n  assign output_arbs_0_select =\n\t     { output_arbs_0_select_requests[4],\n\t       !output_arbs_0_select_requests[4] &&\n\t       output_arbs_0_select_requests[3],\n\t       !output_arbs_0_select_requests[4] &&\n\t       !output_arbs_0_select_requests[3] &&\n\t       output_arbs_0_select_requests[2],\n\t       !output_arbs_0_select_requests[4] &&\n\t       !output_arbs_0_select_requests[3] &&\n\t       !output_arbs_0_select_requests[2] &&\n\t       output_arbs_0_select_requests[1],\n\t       !output_arbs_0_select_requests[4] &&\n\t       !output_arbs_0_select_requests[3] &&\n\t       !output_arbs_0_select_requests[2] &&\n\t       !output_arbs_0_select_requests[1] &&\n\t       output_arbs_0_select_requests[0] } ;\n\n  assign output_arbs_1_select =\n\t     { !output_arbs_1_select_requests[0] &&\n\t       output_arbs_1_select_requests[4],\n\t       !output_arbs_1_select_requests[0] &&\n\t       !output_arbs_1_select_requests[4] &&\n\t       output_arbs_1_select_requests[3],\n\t       !output_arbs_1_select_requests[0] &&\n\t       !output_arbs_1_select_requests[4] &&\n\t       !output_arbs_1_select_requests[3] &&\n\t       output_arbs_1_select_requests[2],\n\t       !output_arbs_1_select_requests[0] &&\n\t       !output_arbs_1_select_requests[4] &&\n\t       !output_arbs_1_select_requests[3] &&\n\t       !output_arbs_1_select_requests[2] &&\n\t       output_arbs_1_select_requests[1],\n\t       output_arbs_1_select_requests[0] } ;\n\n  assign output_arbs_2_select =\n\t     { !output_arbs_2_select_requests[1] &&\n\t       !output_arbs_2_select_requests[0] &&\n\t       output_arbs_2_select_requests[4],\n\t       !output_arbs_2_select_requests[1] &&\n\t       !output_arbs_2_select_requests[0] &&\n\t       !output_arbs_2_select_requests[4] &&\n\t       output_arbs_2_select_requests[3],\n\t       !output_arbs_2_select_requests[1] &&\n\t       !output_arbs_2_select_requests[0] &&\n\t       !output_arbs_2_select_requests[4] &&\n\t       !output_arbs_2_select_requests[3] &&\n\t       output_arbs_2_select_requests[2],\n\t       output_arbs_2_select_requests[1],\n\t       !output_arbs_2_select_requests[1] &&\n\t       output_arbs_2_select_requests[0] } ;\n\n  assign output_arbs_3_select =\n\t     { !output_arbs_3_select_requests[2] &&\n\t       !output_arbs_3_select_requests[1] &&\n\t       !output_arbs_3_select_requests[0] &&\n\t       output_arbs_3_select_requests[4],\n\t       !output_arbs_3_select_requests[2] &&\n\t       !output_arbs_3_select_requests[1] &&\n\t       !output_arbs_3_select_requests[0] &&\n\t       !output_arbs_3_select_requests[4] &&\n\t       output_arbs_3_select_requests[3],\n\t       output_arbs_3_select_requests[2],\n\t       !output_arbs_3_select_requests[2] &&\n\t       output_arbs_3_select_requests[1],\n\t       !output_arbs_3_select_requests[2] &&\n\t       !output_arbs_3_select_requests[1] &&\n\t       output_arbs_3_select_requests[0] } ;\n\n  assign output_arbs_4_select =\n\t     { !output_arbs_4_select_requests[3] &&\n\t       !output_arbs_4_select_requests[2] &&\n\t       !output_arbs_4_select_requests[1] &&\n\t       !output_arbs_4_select_requests[0] &&\n\t       output_arbs_4_select_requests[4],\n\t       output_arbs_4_select_requests[3],\n\t       !output_arbs_4_select_requests[3] &&\n\t       output_arbs_4_select_requests[2],\n\t       !output_arbs_4_select_requests[3] &&\n\t       !output_arbs_4_select_requests[2] &&\n\t       output_arbs_4_select_requests[1],\n\t       !output_arbs_4_select_requests[3] &&\n\t       !output_arbs_4_select_requests[2] &&\n\t       !output_arbs_4_select_requests[1] &&\n\t       output_arbs_4_select_requests[0] } ;\nendmodule  ",
        "module_name": "mkRouterOutputArbitersStatic",
        "module_hash": "f3afb7f44315fb6e1d114e6b457081ae",
        "dataset_index": 8631
      },
      "sky130_fd_sc_hd__nand3_9548dd06": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hd__nand3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A, C        );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hd__nand3",
        "module_hash": "9548dd0635f1ad30ab8471609458b027",
        "dataset_index": 13354
      },
      "baudgen_bf57b963": {
        "rtl_code": "\n\nmodule baudgen(\n  input wire clk,\n  input wire resetq,\n  input wire [31:0] baud,\n  input wire restart,\n  output wire ser_clk);\n  parameter CLKFREQ = 1000000;\n  \n  parameter RWIDTH = 25;\n\n  wire [RWIDTH-1:0] aclkfreq = CLKFREQ;\n  reg [RWIDTH-1:0] d;\n  wire [RWIDTH-1:0] dInc = d[RWIDTH-1] ? ({4'd0, baud}) : (({4'd0, baud}) - aclkfreq);\n  wire [RWIDTH-1:0] dN = restart ? 0 : (d + dInc);\n  wire fastclk = ~d[RWIDTH-1];\n  assign ser_clk = fastclk;\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      d <= 0;\n    end else begin\n      d <= dN;\n    end\n  end\nendmodule\n\n\n\nmodule uart(\n   input wire clk,\n   input wire resetq,\n\n   output wire uart_busy,       output reg uart_tx,          input wire [31:0] baud,\n   input wire uart_wr_i,        input wire [7:0] uart_dat_i\n);\n  parameter CLKFREQ = 1000000;\n\n  reg [3:0] bitcount;           reg [8:0] shifter;\n\n  assign uart_busy = |bitcount;\n  wire sending = |bitcount;\n\n  wire ser_clk;\n\n  wire starting = uart_wr_i & ~uart_busy;\n  baudgen #(.CLKFREQ(CLKFREQ)) _baudgen(\n    .clk(clk),\n    .resetq(resetq),\n    .baud(baud),\n    .restart(1'b0),\n    .ser_clk(ser_clk));\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      uart_tx <= 1;\n      bitcount <= 0;\n      shifter <= 0;\n    end else begin\n      if (starting) begin\n        shifter <= { uart_dat_i[7:0], 1'b0 };\n        bitcount <= 1 + 8 + 1;    end\n\n      if (sending & ser_clk) begin\n        { shifter, uart_tx } <= { 1'b1, shifter };\n        bitcount <= bitcount - 4'd1;\n      end\n    end\n  end\n\nendmodule\n\nmodule rxuart(\n   input wire clk,\n   input wire resetq,\n   input wire [31:0] baud,\n   input wire uart_rx,      input wire rd,           output wire valid,       output wire [7:0] data); parameter CLKFREQ = 1000000;\n\n  reg [4:0] bitcount;\n  reg [7:0] shifter;\n\n  wire idle = &bitcount;\n  wire sample;\n  reg [2:0] hh = 3'b111;\n  wire [2:0] hhN = {hh[1:0], uart_rx};\n  wire startbit = idle & (hhN[2:1] == 2'b10);\n  wire [7:0] shifterN = sample ? {hh[1], shifter[7:1]} : shifter;\n\n  wire ser_clk;\n  baudgen #(.CLKFREQ(CLKFREQ)) _baudgen(\n    .clk(clk),\n    .baud({baud[30:0], 1'b0}),\n    .resetq(resetq),\n    .restart(startbit),\n    .ser_clk(ser_clk));\n\n  assign valid = (bitcount == 18);\n  reg [4:0] bitcountN;\n  always @*\n    if (startbit)\n      bitcountN = 0;\n    else if (!idle & !valid & ser_clk)\n      bitcountN = bitcount + 5'd1;\n    else if (valid & rd)\n      bitcountN = 5'b11111;\n    else\n      bitcountN = bitcount;\n\n  assign sample = (bitcount > 2) & bitcount[0] & !valid & ser_clk;\n  assign data = shifter;\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      hh <= 3'b111;\n      bitcount <= 5'b11111;\n      shifter <= 0;\n    end else begin\n      hh <= hhN;\n      bitcount <= bitcountN;\n      shifter <= shifterN;\n    end\n  end\nendmodule\n\nmodule buart(\n   input wire clk,\n   input wire resetq,\n   input wire [31:0] baud,\n   input wire rx,           output wire tx,          input wire rd,           input wire wr,           output wire valid,       output wire busy,        input wire [7:0] tx_data,\n   output wire [7:0] rx_data );\n  parameter CLKFREQ = 1000000;\n\n  rxuart #(.CLKFREQ(CLKFREQ)) _rx (\n     .clk(clk),\n     .resetq(resetq),\n     .baud(baud),\n     .uart_rx(rx),\n     .rd(rd),\n     .valid(valid),\n     .data(rx_data));\n  uart #(.CLKFREQ(CLKFREQ)) _tx (\n     .clk(clk),\n     .resetq(resetq),\n     .baud(baud),\n     .uart_busy(busy),\n     .uart_tx(tx),\n     .uart_wr_i(wr),\n     .uart_dat_i(tx_data));\nendmodule\n",
        "module_name": "baudgen",
        "module_hash": "bf57b963214b15ab1f95242aa571fdb9",
        "dataset_index": 22213
      },
      "adder_fb9c1496": {
        "rtl_code": "\nmodule adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] temp = a + b + cin;\n    assign {cout, sum} = temp[4:0];\n\nendmodule\n\nmodule max_finder (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] max_val\n);\n\n    assign max_val = (a > b) ? a : b;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] a,\n    input [3:0] b,\n    input cin1,\n    input cin2,\n    output [3:0] sum1,\n    output [3:0] sum2,\n    output cout1,\n    output cout2,\n    output [3:0] max_sum\n);\n\n    reg [3:0] sum1_reg, sum2_reg;\n    reg cout1_reg, cout2_reg;\n\n    adder adder1(\n        .a(a),\n        .b(b),\n        .cin(cin1),\n        .sum(sum1),\n        .cout(cout1)\n    );\n\n    adder adder2(\n        .a(a),\n        .b(b),\n        .cin(cin2),\n        .sum(sum2),\n        .cout(cout2)\n    );\n\n    max_finder max_finder1(\n        .a(sum1),\n        .b(sum2),\n        .max_val(max_sum)\n    );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            sum1_reg <= 4'b0;\n            sum2_reg <= 4'b0;\n            cout1_reg <= 1'b0;\n            cout2_reg <= 1'b0;\n        end else begin\n            sum1_reg <= sum1;\n            sum2_reg <= sum2;\n            cout1_reg <= cout1;\n            cout2_reg <= cout2;\n        end\n    end\n\nendmodule\n",
        "module_name": "adder",
        "module_hash": "fb9c1496caeb6ed3cfef225998de9e87",
        "dataset_index": 14316
      },
      "round_counter__a1f11261": {
        "rtl_code": "module round_counter_module (pulse, reset, clk, clk_1, work, mileage, number_of_halfkm);\n\ninput pulse, reset, clk, clk_1;\noutput work;\noutput [11:0] mileage, number_of_halfkm;\n\nreg work;\nreg [11:0] mileage, number_of_halfkm;\n\nreg [7:0] ib;\nreg [11:0] sample;\nreg flag;\n\nalways @ (posedge clk, negedge reset)\nbegin\n    if(!reset)\n    begin\n        ib <= 0;\n        mileage <= 0;\n        sample <= 0;\n        number_of_halfkm <= 0;\n    end\n    else\n    begin\n        if(pulse == 0)  \n        begin\n            sample <= sample +1;\n            if (flag == 1 && sample >= 49) \n            begin               \n                if (ib >= 1)\n                begin\n                    mileage <= mileage +1;\n                    if(mileage % 5 == 4) \n                        number_of_halfkm <= number_of_halfkm +1;\n                        \n                    ib <= 0;\n                end\n                else ib <= ib +1;\n                \n                flag <= 0; \n            end\n        end\n        else \n        begin\n            sample <= 0;\n            flag <= 1;     \n        end\n    end\nend\n\nreg [11:0] count;\n\nalways @ (posedge clk_1, negedge flag)  \nbegin\n        if(flag == 0)\n        begin\n            work <= 1;\n            count <= 0;\n        end\n        else\n        begin\n            if (count >= 4) work <= 0;\n            else    count <= count +1;\n        end\nend \n\nendmodule",
        "module_name": "round_counter_",
        "module_hash": "a1f11261a120dd3697fe9e5076eb2938",
        "dataset_index": 13669
      },
      "or4_7b670bbc": {
        "rtl_code": "module or4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output X\n);\n\n    // Voltage supply signals\n    supply0 VGND;\n    supply1 VPWR;\n    supply0 VNB;\n    supply1 VPB;\n\n    wire or1_out;\n    wire or2_out;\n\n    or2 or1 (\n        .A(A),\n        .B(B),\n        .X(or1_out)\n    );\n\n    or2 or2 (\n        .A(C),\n        .B(D),\n        .X(or2_out)\n    );\n\n    or2 or3 (\n        .A(or1_out),\n        .B(or2_out),\n        .X(X)\n    );\n\nendmodule\n\nmodule or2 (\n    input A,\n    input B,\n    output X\n);\n\n    assign X = A | B;\n\nendmodule",
        "module_name": "or4",
        "module_hash": "7b670bbce408fdd5f615e2a2caaa2bb2",
        "dataset_index": 6136
      },
      "bus_hold_429e12ff": {
        "rtl_code": "module bus_hold (\n  input [n-1:0] bus_in,\n  input clk,\n  input reset,\n  output [n-1:0] bus_out\n);\n\nparameter n = 8; // number of bits in the bus signal\n\nreg [n-1:0] bus_hold_reg; // register to hold the bus signal\n\nalways @(posedge clk) begin\n  if (reset) begin\n    bus_hold_reg <= 0;\n  end else begin\n    bus_hold_reg <= bus_in;\n  end\nend\n\nassign bus_out = reset ? 0 : bus_hold_reg;\n\nendmodule",
        "module_name": "bus_hold",
        "module_hash": "429e12ffc6fa2674bf3a3cb8587669e3",
        "dataset_index": 13468
      },
      "multiplier_block_f484df7b": {
        "rtl_code": "module multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w32,\n    w33,\n    w4096,\n    w4129,\n    w2,\n    w4131,\n    w264,\n    w4395,\n    w8790;\n\n  assign w1 = i_data0;\n  assign w2 = w1 << 1;\n  assign w32 = w1 << 5;\n  assign w33 = w1 + w32;\n  assign w4096 = w1 << 12;\n  assign w4129 = w33 + w4096;\n  assign w4131 = w4129 + w2;\n  assign w264 = w33 << 3;\n  assign w4395 = w4131 + w264;\n  assign w8790 = w4395 << 1;\n\n  assign o_data0 = w8790;\n\n  //multiplier_block area estimate = 7035.33617542206;\nendmodule",
        "module_name": "multiplier_block",
        "module_hash": "f484df7b14b694f63b47effa9a7cd2f1",
        "dataset_index": 7391
      },
      "top_module_5cf2b896": {
        "rtl_code": "module top_module(\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    input [7:0] in,\n    output [7:0] out\n);\n\n    // 2-to-1 multiplexer\n    wire mux_out;\n    assign mux_out = (sel_b1 & sel_b2) ? b : a;\n\n    // Bitwise AND module\n    wire [7:0] and_out;\n    assign and_out = in & 8'b11100011;\n\n    // Functional module\n    assign out = (mux_out == a) ? in : and_out;\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "5cf2b896e1be7416992d785788d2caa6",
        "dataset_index": 3614
      },
      "top__1d8fcbd9": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input select,     // Select input to choose between counters and multiplexer\n    output reg [3:0] out  // 4-bit output from the active module\n);\n\n    reg [3:0] counter1 = 4'b0000;   // 4-bit binary counter from 0 through 5\n    reg [3:0] counter2 = 4'b0000;   // 4-bit binary counter from 0 through 15\n    reg [1:0] select_counter = 2'b00;  // Selects which counter to output\n    reg [3:0] mux_out;              // Output from the 4-to-1 multiplexer\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter1 <= 4'b0000;\n            counter2 <= 4'b0000;\n            select_counter <= 2'b00;\n            mux_out <= 4'b0000;\n        end else begin\n            if (select) begin\n                // Multiplexer is selected\n                select_counter <= 2'b10;\n                case (counter2)\n                    4'b0000: mux_out <= 4'b0000;\n                    4'b0001: mux_out <= 4'b0001;\n                    4'b0010: mux_out <= 4'b0010;\n                    4'b0011: mux_out <= 4'b0011;\n                    4'b0100: mux_out <= 4'b0100;\n                    4'b0101: mux_out <= 4'b0101;\n                    4'b0110: mux_out <= 4'b0110;\n                    4'b0111: mux_out <= 4'b0111;\n                    4'b1000: mux_out <= 4'b1000;\n                    4'b1001: mux_out <= 4'b1001;\n                    4'b1010: mux_out <= 4'b1010;\n                    4'b1011: mux_out <= 4'b1011;\n                    4'b1100: mux_out <= 4'b1100;\n                    4'b1101: mux_out <= 4'b1101;\n                    4'b1110: mux_out <= 4'b1110;\n                    4'b1111: mux_out <= 4'b1111;\n                endcase\n            end else begin\n                // Counters are selected\n                select_counter <= 2'b01;\n                case (counter1)\n                    4'b0000: out <= 4'b0000;\n                    4'b0001: out <= 4'b0001;\n                    4'b0010: out <= 4'b0010;\n                    4'b0011: out <= 4'b0011;\n                    4'b0100: out <= 4'b0100;\n                    4'b0101: out <= 4'b0101;\n                    4'b0110: out <= 4'b0110;\n                    4'b0111: out <= 4'b0111;\n                    4'b1000: out <= 4'b1000;\n                    4'b1001: out <= 4'b0001;\n                    4'b1010: out <= 4'b0010;\n                    4'b1011: out <= 4'b0011;\n                    4'b1100: out <= 4'b0100;\n                    4'b1101: out <= 4'b0101;\n                    4'b1110: out <= 4'b0110;\n                    4'b1111: out <= 4'b0111;\n                endcase\n                if (counter1 == 4'b0101) begin\n                    counter1 <= 4'b0000;\n                    counter2 <= counter2 + 1;\n                end else begin\n                    counter1 <= counter1 + 1;\n                end\n            end\n        end\n    end\nendmodule",
        "module_name": "top_",
        "module_hash": "1d8fcbd980128986f9dbc61dc8553435",
        "dataset_index": 16784
      },
      "blockmem2rptr1w_7e713017": {
        "rtl_code": "module blockmem2rptr1w(\n                       input wire           clk,\n                       input wire           reset_n,\n\n                       input wire  [07 : 0] read_addr0,\n                       output wire [31 : 0] read_data0,\n\n                       output wire [31 : 0] read_data1,\n\n                       input wire           rst,\n                       input wire           cs,\n                       input wire           wr,\n                       input wire  [07 : 0] write_addr,\n                       input wire  [31 : 0] write_data\n                      );\n\n\n  reg [31 : 0] mem [0 : 255];\n  reg [31 : 0] tmp_read_data0;\n  reg [31 : 0] tmp_read_data1;\n\n  reg [7 : 0] ptr_reg;\n  reg [7 : 0] ptr_new;\n  reg         ptr_we;\n\n\n  assign read_data0 = tmp_read_data0;\n  assign read_data1 = tmp_read_data1;\n\n\n  always @ (posedge clk)\n    begin : mem_update\n      if (wr)\n        mem[write_addr] <= write_data;\n\n      tmp_read_data0 <= mem[read_addr0];\n      tmp_read_data1 <= mem[ptr_reg];\n    end\n\n\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_mem_update\n      if (!reset_n)\n        ptr_reg <= 8'h00;\n\n      else\n        if (ptr_we)\n          ptr_reg <= ptr_new;\n    end\n\n\n  always @*\n    begin : ptr_logic\n      ptr_new = 8'h00;\n      ptr_we  = 1'b0;\n\n      if (rst)\n        begin\n          ptr_new = 8'h00;\n          ptr_we  = 1'b1;\n        end\n\n      if (cs)\n        begin\n          ptr_new = ptr_reg + 1'b1;\n          ptr_we  = 1'b1;\n        end\n    end\n\nendmodule ",
        "module_name": "blockmem2rptr1w",
        "module_hash": "7e71301790158fae8b094e0febc85f4b",
        "dataset_index": 24420
      },
      "axis_variable #_e5613de5": {
        "rtl_code": "\n\nmodule axis_variable #\n(\n  parameter integer AXIS_TDATA_WIDTH = 32\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n\n  input  wire [AXIS_TDATA_WIDTH-1:0] cfg_data,\n\n  input  wire                        m_axis_tready,\n  output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,\n  output wire                        m_axis_tvalid\n);\n\n  reg [AXIS_TDATA_WIDTH-1:0] int_tdata_reg;\n  reg int_tvalid_reg, int_tvalid_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_tdata_reg <= {(AXIS_TDATA_WIDTH){1'b0}};\n      int_tvalid_reg <= 1'b0;\n    end\n    else\n    begin\n      int_tdata_reg <= cfg_data;\n      int_tvalid_reg <= int_tvalid_next;\n    end\n  end\n\n  always @*\n  begin\n    int_tvalid_next = int_tvalid_reg;\n\n    if(int_tdata_reg != cfg_data)\n    begin\n      int_tvalid_next = 1'b1;\n    end\n\n    if(m_axis_tready & int_tvalid_reg)\n    begin\n      int_tvalid_next = 1'b0;\n    end\n  end\n\n  assign m_axis_tdata = int_tdata_reg;\n  assign m_axis_tvalid = int_tvalid_reg;\n\nendmodule\n",
        "module_name": "axis_variable #",
        "module_hash": "e5613de53e841763bef52dffde5ee428",
        "dataset_index": 25242
      },
      "edge_detector_526fc40f": {
        "rtl_code": "module edge_detector (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\nreg [7:0] shift_reg [0:2];\nreg [7:0] edge_reg;\n\nalways @(posedge clk) begin\n    shift_reg[0] <= in;\n    shift_reg[1] <= shift_reg[0];\n    shift_reg[2] <= shift_reg[1];\n    \n    edge_reg <= (shift_reg[0] ^ shift_reg[2]) & shift_reg[1];\n    \n    out <= {1'b0, edge_reg[6:0]}; // Fixed part select order\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\nwire [7:0] edge_out;\n\nedge_detector ed (\n    .clk(clk),\n    .in(in),\n    .out(edge_out)\n);\n\nalways @* begin\n    anyedge = edge_out;\nend\n\nendmodule",
        "module_name": "edge_detector",
        "module_hash": "526fc40f8f04745ef7931839e215ff39",
        "dataset_index": 4324
      },
      "clock_gate_cb9ab799": {
        "rtl_code": "module clock_gate (\n    input CLK, EN, TE, RST,\n    output reg ENCLK\n);\n\nreg D;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        D <= 1'b0;\n        ENCLK <= 1'b0;\n    end else begin\n        D <= EN & TE;\n        ENCLK <= D;\n    end\nend\n\nendmodule",
        "module_name": "clock_gate",
        "module_hash": "cb9ab7991573c2c95a2d81b08d98423f",
        "dataset_index": 3794
      },
      "binary_splitter_976ff44a": {
        "rtl_code": "\nmodule binary_splitter (\n    input [2:0] vec,\n    output [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nassign {o2, o1, o0} = vec;\nassign outv = vec;\n\nendmodule\n\nmodule binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\n\nendmodule\n\nmodule control_logic (\n    input select,\n    input [2:0] vec,\n    input clk,\n    input reset,\n    output [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nwire [2:0] splitter_outv;\nwire splitter_o2;\nwire splitter_o1;\nwire splitter_o0;\nwire [3:0] counter_q;\n\nbinary_splitter splitter(.vec(vec), .outv(splitter_outv), .o2(splitter_o2), .o1(splitter_o1), .o0(splitter_o0));\nbinary_counter counter(.clk(clk), .reset(reset), .q(counter_q));\n\nassign outv = select ? splitter_outv : 3'b000;\nassign o2 = select ? splitter_o2 : 1'b0;\nassign o1 = select ? splitter_o1 : 1'b0;\nassign o0 = select ? splitter_o0 : 1'b0;\n\nendmodule\n\nmodule top_module ( \n    input clk,\n    input reset,\n    input select,\n    input [2:0] vec,\n    output [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\ncontrol_logic control(.select(select), .vec(vec), .clk(clk), .reset(reset), .outv(outv), .o2(o2), .o1(o1), .o0(o0));\n\nendmodule\n",
        "module_name": "binary_splitter",
        "module_hash": "976ff44a75d004c5707bd510ed3603c0",
        "dataset_index": 2267
      },
      "counter_9e9b6d1b": {
        "rtl_code": "module counter(\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\n\nendmodule",
        "module_name": "counter",
        "module_hash": "9e9b6d1bb00ff4a91f68ff3021f9229f",
        "dataset_index": 12938
      },
      "trig_functions_12b2a81a": {
        "rtl_code": "module trig_functions (\n  input x,\n  output reg sin_out,\n  output reg cos_out,\n  output reg tan_out\n);\n\n  reg [31:0] fact;\n  reg [31:0] x_pow;\n  reg [31:0] term;\n  reg [31:0] sign;\n  reg [31:0] i;\n\n  always @(*) begin\n    fact = 1;\n    x_pow = x;\n    term = x;\n    sign = 1;\n    sin_out = x;\n    cos_out = 1;\n    tan_out = sin_out / cos_out;\n\n    for (i = 3; i <= 15; i = i + 2) begin\n      fact = fact * i * (i - 1);\n      x_pow = x_pow * x * x;\n      sign = -1 * sign;\n      term = sign * x_pow / fact;\n      sin_out = sin_out + term;\n      cos_out = cos_out + term * term;\n      tan_out = sin_out / cos_out;\n    end\n\n    if (x == 0) begin\n      sin_out = 0;\n      cos_out = 1;\n      tan_out = 0;\n    end\n\n    if (cos_out == 0) begin\n      tan_out = 1;\n    end\n  end\n\nendmodule",
        "module_name": "trig_functions",
        "module_hash": "12b2a81a1b46b24517a04d3831238a1c",
        "dataset_index": 3563
      },
      "elastic1632#_ce9f1469": {
        "rtl_code": "\n\nmodule  elastic1632#(\n    parameter DEPTH_LOG2 =  4,   parameter OFFSET =  7 )(\n    input             wclk,\n    input             rclk,\n\n    input             isaligned_in,\n    input       [1:0] charisk_in,\n    input       [1:0] notintable_in,\n    input       [1:0] disperror_in,\n    input      [15:0] data_in,\n \n    output            isaligned_out,\n    output reg  [3:0] charisk_out,\n    output reg  [3:0] notintable_out,\n    output reg  [3:0] disperror_out,\n    output reg [31:0] data_out,\n\noutput            full,\n    output            empty\n\n);\nlocalparam ALIGN_PRIM = 32'h7B4A4ABC;\nlocalparam FIFO_DEPTH = 1 << DEPTH_LOG2;\nlocalparam CORR_OFFSET = OFFSET - 0;\n\nreg            [15:0] data_in_r;\nreg             [1:0] charisk_in_r;\nreg             [1:0] notintable_in_r;\nreg             [1:0] disperror_in_r;\nreg                   aligned32_in_r;  reg                   msb_in_r;      reg                   inc_waddr;\nreg    [DEPTH_LOG2:0] waddr;\nwire [DEPTH_LOG2-1:0] waddr_minus = waddr[DEPTH_LOG2-1:0] - 1;\nwire   [DEPTH_LOG2:0] raddr_w;\nreg    [DEPTH_LOG2:0] raddr_r;\nreg            [44:0] fifo_ram    [0: FIFO_DEPTH -1];\nreg             [0:0] prealign_ram[0: FIFO_DEPTH -1];\nreg  [FIFO_DEPTH-1:0] fill;\nwire [FIFO_DEPTH-1:0] fill_out;\nwire [FIFO_DEPTH-1:0] fill_out_more; wire [FIFO_DEPTH-1:0] fill_out_less; wire [FIFO_DEPTH-1:0] fill_1;\nreg             [2:0] aligned_rclk;\nreg             [1:0] dav_rclk;      reg             [1:0] dav_rclk_more; reg             [1:0] dav_rclk_less; wire                  skip_rclk;  wire                  skip_rclk2; reg             [1:0] add_rclk_r;                   \nreg            [44:0] rdata_r;\nwire                  align_out = rdata_r[44];\nreg                   pre_align_out_r;\nreg             [2:0] correct_r;\nwire                  correct_stream = align_out && pre_align_out_r && !correct_r[2]; wire                  correct_first = pre_align_out_r && !align_out; wire                  correct = correct_stream || correct_first;\n\nreg             [1:0] full_0; reg             [1:0] full_1; wire is_alignp_w = ({data_in,       data_in_r} ==       ALIGN_PRIM) &&\n                   ({charisk_in,    charisk_in_r} ==    4'h1) &&\n                   ({notintable_in, notintable_in_r} == 0) &&\n                   ({disperror_in,  disperror_in_r} ==  0);\n`ifdef SIMULATION\n    wire  [DEPTH_LOG2:0] dbg_diff = waddr-raddr_r; wire                 dbg_dav1 = dav_rclk[1];   wire                 dbg_full0 = full_0[1];    wire                 dbg_full1 = full_1[1];    reg          [31:0]  dbg_di;                   always @(posedge wclk) begin\n        if (msb_in_r) dbg_di<= {data_in,data_in_r};\n    end\n`endif\n\n\ngenvar ii;\ngenerate\n    for (ii = 0; ii < FIFO_DEPTH; ii = ii + 1)\n    begin: gen_fill_out\n        assign fill_out[ii] =            fill[(ii + CORR_OFFSET    ) & (FIFO_DEPTH - 1)] ^ ((ii + CORR_OFFSET    ) >= FIFO_DEPTH);\n        assign fill_out_more[ii] =       fill[(ii + CORR_OFFSET + 1) & (FIFO_DEPTH - 1)] ^ ((ii + CORR_OFFSET + 1) >= FIFO_DEPTH);\n        assign fill_out_less[ii] =       fill[(ii + CORR_OFFSET - 1) & (FIFO_DEPTH - 1)] ^ ((ii + CORR_OFFSET - 1) >= FIFO_DEPTH);\n        assign fill_1[ii] =              fill[(ii + 1) & (FIFO_DEPTH - 1)] ^ ((ii + 1) >= FIFO_DEPTH);\n    end\nendgenerate\n                   \nalways @(posedge wclk) begin\n    data_in_r <= data_in;\n    charisk_in_r <= charisk_in;\n    notintable_in_r <= notintable_in;\n    disperror_in_r <= disperror_in;\n    \n    if    (!isaligned_in) aligned32_in_r <= 0;\n    else if (is_alignp_w) aligned32_in_r <= 1;\n    \n    if (!aligned32_in_r && !is_alignp_w) msb_in_r <= 1;\n    else                                 msb_in_r <= !msb_in_r;\n    \n    inc_waddr <= !msb_in_r || (is_alignp_w && !aligned32_in_r);\n    \n    if (!aligned32_in_r)  waddr <= 0;\n    else if (inc_waddr)   waddr <= waddr + 1;\n    \n    if (msb_in_r) fifo_ram[waddr[DEPTH_LOG2-1:0]] <= {is_alignp_w,\n                                                      disperror_in,  disperror_in_r,\n                                                      notintable_in, notintable_in_r,\n                                                      charisk_in,    charisk_in_r,\n                                                      data_in,       data_in_r};\n    if (msb_in_r) prealign_ram[waddr_minus] <= is_alignp_w;\n                                                      \n    if (!aligned32_in_r)  fill <= 0;\n    else if (msb_in_r)    fill <={fill[FIFO_DEPTH-2:0],~waddr[DEPTH_LOG2]};\n    \nend\n\nlocalparam [DEPTH_LOG2:0] SIZED0 = 0;\n    localparam [DEPTH_LOG2:0] SIZED1 = 1;\n    localparam [DEPTH_LOG2:0] SIZED2 = 2;\n    localparam [DEPTH_LOG2:0] SIZED3 = 3;\n    assign raddr_w = aligned_rclk[1]? ( raddr_r + (add_rclk_r[0]? SIZED0 : (skip_rclk ? (skip_rclk2 ? SIZED3 : SIZED2) : SIZED1))) : SIZED0;\n\nalways @(posedge rclk) begin\n\n    raddr_r <=         raddr_w;\n\n    rdata_r <=         fifo_ram[raddr_w[DEPTH_LOG2-1:0]];\n    \n    pre_align_out_r <= prealign_ram[raddr_w[DEPTH_LOG2-1:0]];\n    \n    if (!aligned32_in_r) aligned_rclk <= 0;\n    else                 aligned_rclk <= {aligned_rclk[1:0],fill[OFFSET-2] | aligned_rclk[0]};\n\n    if (!aligned32_in_r) dav_rclk <= 0;\n    else                 dav_rclk <= {dav_rclk[0],fill_out[raddr_r[DEPTH_LOG2-1:0]] ^ raddr_r[DEPTH_LOG2]};\n\n    if (!aligned32_in_r) dav_rclk_more <= 0;\n    else                 dav_rclk_more <= {dav_rclk_more[0],fill_out_more[raddr_r[DEPTH_LOG2-1:0]] ^ raddr_r[DEPTH_LOG2]};\n\n    if (!aligned32_in_r) dav_rclk_less <= 0;\n    else                 dav_rclk_less <= {dav_rclk_less[0],fill_out_less[raddr_r[DEPTH_LOG2-1:0]] ^ raddr_r[DEPTH_LOG2]};\n\n    \n    if (!aligned32_in_r) full_0 <= 1;\n    else                 full_0 <= {full_0[0], fill[raddr_r[DEPTH_LOG2-1:0]] ^ raddr_r[DEPTH_LOG2]};\n\n    if (!aligned32_in_r) full_1 <= 1;\n    else                 full_1 <= {full_1[0], fill_1[raddr_r[DEPTH_LOG2-1:0]] ^ raddr_r[DEPTH_LOG2]};\n    \n    disperror_out <=  rdata_r[43:40];\n    notintable_out <= rdata_r[39:36];\n    charisk_out <=    rdata_r[35:32];\n    data_out <=       rdata_r[31: 0];\n    \nif (correct || !aligned_rclk) correct_r <= ~0;\n    else correct_r <= correct_r << 1;\n\nif      (correct_first)  add_rclk_r <= {~dav_rclk_less[1], ~dav_rclk[1]};\n    else if (correct_stream) add_rclk_r <= {1'b0,              ~dav_rclk[1]};\n    else                     add_rclk_r <= add_rclk_r >> 1; \n    \nend\n\nassign skip_rclk =  correct &&  dav_rclk[1];\nassign skip_rclk2 = correct_first &&  dav_rclk_more[1];\n\nassign isaligned_out = aligned_rclk[2];\nassign full =  aligned_rclk &&  full_1[1] && !full_0[1];\nassign empty = aligned_rclk && !full_1[1] &&  full_0[1];\nendmodule\n\n",
        "module_name": "elastic1632#",
        "module_hash": "ce9f1469d71dd7300fdaad75d7c1a350",
        "dataset_index": 22341
      },
      "top_module_7598f930": {
        "rtl_code": "\nmodule top_module(\n    input clk,\n    input reset,\n    input d,\n    input select,\n    input [4:0] in,\n    output out_and,\n    output out_or,\n    output out_nor,\n    output [2:0] final_output\n);\n\n    // 3-bit shift register\n    reg [2:0] shift_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 3'b0;\n        end else begin\n            shift_reg <= {shift_reg[1:0], d};\n        end\n    end\n    \n    // Multiplexer to select output from shift register\n    wire [2:0] shift_reg_out = {shift_reg[2], shift_reg[1], shift_reg[0]};\n    wire [2:0] mux_out;\n    assign mux_out = (select) ? {shift_reg_out, 3'b0} : {3'b0, in};\n    \n    // 5-input logic gate\n    wire and_out = in[0] & in[1] & in[2] & in[3] & in[4];\n    wire or_out = in[0] | in[1] | in[2] | in[3] | in[4];\n    wire nor_out = ~(in[0] | in[1] | in[2] | in[3] | in[4]);\n    \n    // 2-to-4 decoder with enable\n    wire [3:0] decoder_out;\n    assign decoder_out = (in[4]) ? 4'b1110 : 4'b0001;\n    \n    // Functional module to produce final output\n    reg [2:0] final_output_reg;\n    always @(*) begin\n        case (select)\n            1'b0: final_output_reg = mux_out;\n            1'b1: final_output_reg = {and_out, or_out, nor_out};\n        endcase\n    end\n    \n    // Output assignments\n    assign out_and = and_out;\n    assign out_or = or_out;\n    assign out_nor = nor_out;\n    assign final_output = final_output_reg;\n    \nendmodule\n",
        "module_name": "top_module",
        "module_hash": "7598f9308b24acb32fd6f33926187fbe",
        "dataset_index": 19017
      },
      "mux_2to1_e8032657": {
        "rtl_code": "module mux_2to1(OUT,IN0,IN1,S0);\n    output OUT;\n    input IN0,IN1,S0;\n    wire S0_not, IN0_and_not_S0, IN1_and_S0;\n    \n    not(S0_not,S0);\n    and(IN0_and_not_S0, IN0, S0_not);\n    and(IN1_and_S0, IN1, S0);\n    or(OUT, IN0_and_not_S0, IN1_and_S0);\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "e803265750de7fc0d171039ddccef0d1",
        "dataset_index": 6960
      },
      "regfile_a7d51859": {
        "rtl_code": "module regfile (\n`ifdef DEBUG\n    output [15:0] ax,\n    output [15:0] dx,\n    output [15:0] bp,\n    output [15:0] si,\n    output [15:0] es,\n`endif\n\n    output [15:0] a,\n    output [15:0] b,\n    output [15:0] c,\n    output [15:0] cs,\n    output [15:0] ip,\n    input  [31:0] d,\n    output [15:0] s,\n\n    output reg [8:0] flags,\n\n    input         wr,\n    input         wrfl,\n    input         wrhi,\n    input         clk,\n    input         rst,\n    input  [ 3:0] addr_a,\n    input  [ 3:0] addr_b,\n    input  [ 3:0] addr_c,\n    input  [ 3:0] addr_d,\n    input  [ 1:0] addr_s,\n    input  [ 8:0] iflags,\n    input         word_op,\n    input         a_byte,\n    input         b_byte,\n    input         c_byte,\n    output        cx_zero,\n    input         wr_ip0\n  );\n\n  // Net declarations\n  reg [15:0] r[15:0];\n  wire [7:0] a8, b8, c8;\n\n  // Assignments\n`ifdef DEBUG\n  assign ax = r[0];\n  assign dx = r[2];\n  assign bp = r[5];\n  assign si = r[6];\n  assign es = r[8];\n`endif\n  assign a = (a_byte & ~addr_a[3]) ? { {8{a8[7]}}, a8} : r[addr_a];\n  assign a8 = addr_a[2] ? r[addr_a[1:0]][15:8] : r[addr_a][7:0];\n\n  assign b = (b_byte & ~addr_b[3]) ? { {8{b8[7]}}, b8} : r[addr_b];\n  assign b8 = addr_b[2] ? r[addr_b[1:0]][15:8] : r[addr_b][7:0];\n\n  assign c = (c_byte & ~addr_c[3]) ? { {8{c8[7]}}, c8} : r[addr_c];\n  assign c8 = addr_c[2] ? r[addr_c[1:0]][15:8] : r[addr_c][7:0];\n\n  assign s = r[{2'b10,addr_s}];\n\n  assign cs = r[9];\n  assign cx_zero = (addr_d==4'd1) ? (d==16'd0) : (r[1]==16'd0);\n\n  assign ip = r[15];\n\n  // Behaviour\n  always @(posedge clk)\n    if (rst) begin\n      r[0]  <= 16'd0; r[1]  <= 16'd0;\n      r[2]  <= 16'd0; r[3]  <= 16'd0;\n      r[4]  <= 16'd0; r[5]  <= 16'd0;\n      r[6]  <= 16'd0; r[7]  <= 16'd0;\n      r[8]  <= 16'd0; r[9]  <= 16'hf000;\n      r[10] <= 16'd0; r[11] <= 16'd0;\n      r[12] <= 16'd0; r[13] <= 16'd0;\n      r[14] <= 16'd0; r[15] <= 16'hfff0;\n      flags <= 9'd0;\n    end else\n      begin\n        if (wr) begin\n          if (word_op | addr_d[3:2]==2'b10)\n             r[addr_d] <= word_op ? d[15:0] : {{8{d[7]}},d[7:0]};\n          else if (addr_d[3]~^addr_d[2]) r[addr_d][7:0] <= d[7:0];\n          else r[{2'b0,addr_d[1:0]}][15:8] <= d[7:0];\n        end\n        if (wrfl) flags <= iflags;\n        if (wrhi) r[4'd2] <= d[31:16];\n        if (wr_ip0) r[14] <= ip;\n      end\nendmodule",
        "module_name": "regfile",
        "module_hash": "a7d518594ff8da1594e78871f55234bb",
        "dataset_index": 6505
      },
      "random_gen_v2_5ca60f01": {
        "rtl_code": "module random_gen_v2(\n    input           reset,\n    input           clock,\n    input           init,\n    input   [3:0]   retry_count,\n    input           enable,\n    output reg      trigger,\n    output reg [9:0] random\n);\n\nreg [9:0]       random_sequence;\nreg [9:0]       random_counter;\nreg [7:0]       slot_time_counter; //256*2=512bit=1 slot time\n\nalways @ (posedge clock or posedge reset)\n    if (reset)\n        random_sequence <= 0;\n    else\n        random_sequence <= {random_sequence[8:0],~(random_sequence[2]^random_sequence[9])};\n        \nalways @ (retry_count or random_sequence)\n    case (retry_count)\n        4'h0    : random = {9'b0, random_sequence[0]};\n        4'h1    : random = {8'b0, random_sequence[1:0]};     \n        4'h2    : random = {7'b0, random_sequence[2:0]};\n        4'h3    : random = {6'b0, random_sequence[3:0]};\n        4'h4    : random = {5'b0, random_sequence[4:0]};\n        4'h5    : random = {4'b0, random_sequence[5:0]};\n        4'h6    : random = {3'b0, random_sequence[6:0]};\n        4'h7    : random = {2'b0, random_sequence[7:0]};\n        4'h8    : random = {1'b0, random_sequence[8:0]};\n        4'h9    : random = {      random_sequence[9:0]};  \n        default : random = {      random_sequence[9:0]};\n    endcase\n\nalways @ (posedge clock or posedge reset)\n    if (reset)\n        slot_time_counter <= 0;\n    else if(init)\n        slot_time_counter <= 0;\n    else if(!trigger)\n        slot_time_counter <= slot_time_counter + 1;\n    \nalways @ (posedge clock or posedge reset)\n    if (reset)\n        random_counter <= 0;\n    else if (init)\n        random_counter <= random;\n    else if (enable && random_counter != 0 && slot_time_counter == 255)\n        random_counter <= random_counter - 1;\n    else if (!enable)\n        random_counter <= 0;\n        \nalways @ (posedge clock or posedge reset)\n    if (reset)\n        trigger <= 1;\n    else if (init)\n        trigger <= 0;\n    else if (enable && random_counter == 0)\n        trigger <= 1;\n    else if (!enable)\n        trigger <= 0;\n        \nendmodule",
        "module_name": "random_gen_v2",
        "module_hash": "5ca60f0170d43795f3cdb13ecdaa7128",
        "dataset_index": 3391
      },
      "motor_control_da286763": {
        "rtl_code": "module motor_control(\n  input [3:0] voltage,\n  input clk,\n  output [3:0] speed,\n  output warning\n);\n\n  reg [3:0] speed_reg;\n  reg warning_reg;\n\n  always @(posedge clk) begin\n    if (voltage < 4) begin\n      speed_reg <= 4'b0000;\n      warning_reg <= 1'b0;\n    end else if (voltage >= 4 && voltage < 6) begin\n      speed_reg <= 4'b0100;\n      warning_reg <= 1'b0;\n    end else if (voltage >= 6 && voltage < 8) begin\n      speed_reg <= 4'b1111;\n      warning_reg <= 1'b0;\n    end else begin\n      speed_reg <= 4'b1111;\n      warning_reg <= 1'b1;\n    end\n  end\n\n  assign speed = speed_reg;\n  assign warning = warning_reg;\n\nendmodule",
        "module_name": "motor_control",
        "module_hash": "da2867634af2d5e39077f29a154d2358",
        "dataset_index": 2938
      },
      "adder4_b7614cea": {
        "rtl_code": "module adder4 (sum, carry_out, wireA, wireB, carry_in);\n   input [3:0] wireA;\n   input [3:0] wireB;\n   input carry_in;\n   output [3:0] sum;\n   output carry_out;\n\n   assign {carry_out, sum} = wireA + wireB + carry_in;\nendmodule",
        "module_name": "adder4",
        "module_hash": "b7614cea425b67f128fb4ca9ecac3fe5",
        "dataset_index": 15034
      },
      "altera_std_synchronizer_f485e1df": {
        "rtl_code": "module altera_std_synchronizer(\n  input clk,\n  input reset_n,\n  input din,\n  output dout\n);\n\nparameter depth = 2;\n\nreg [depth-1:0] ff;\nreg [depth-1:0] ff_next;\n\nalways @(posedge clk or negedge reset_n) begin\n  if (~reset_n) begin\n    ff <= {depth{1'b0}};\n  end else begin\n    ff <= {ff[depth-2:0], din};\n  end\nend\n\nassign dout = ff[depth-1];\n\nendmodule",
        "module_name": "altera_std_synchronizer",
        "module_hash": "f485e1dfb8912559bf15541a0268a8f1",
        "dataset_index": 9742
      },
      "light_control_8ca23cbe": {
        "rtl_code": "module light_control (\n  input [11:0] als,\n  input [11:0] dll,\n  input en,\n  output reg [7:0] dim\n);\n\n  always @(*) begin\n    if (en) begin\n      if (als <= dll) begin\n        dim <= 8'b00000000;\n      end else begin\n        dim <= ((als - dll) >> 4) > 8'b11111111 ? 8'b11111111 : ((als - dll) >> 4);\n      end\n    end else begin\n      dim <= 8'b00000000;\n    end\n  end\n\nendmodule",
        "module_name": "light_control",
        "module_hash": "8ca23cbe3b165a17c7a3ed2a28cd337e",
        "dataset_index": 13564
      },
      "CAR_CTR_749a81b0": {
        "rtl_code": "\nmodule CAR_CTR(\n    output reg  md1,\n    output reg  md2,\n    output reg  md3,\n    output reg  md4,\n    input   infL,\n    input   infR,\n    input   clk,\n    input   reset_n\n);\nparameter FWD   = 2'b00;\nparameter STOP  = 2'b01;\nparameter RIGHT = 2'b10;\nparameter LEFT  = 2'b11;\nparameter HIGH  = 1'b1;\nparameter LOW   = 1'b0;\n\n\nalways @(*) begin\n    if (infL == LOW && infR == LOW) begin\n        md1 = HIGH;\n        md2 = LOW;\n        md3 = HIGH;\n        md4 = LOW;\n    end else if (infL == HIGH && infR == LOW) begin\n        md1 = LOW;\n        md2 = LOW;\n        md3 = HIGH;\n        md4 = LOW;\n    end else if (infL == LOW && infR == HIGH) begin\n        md1 = HIGH;\n        md2 = LOW;\n        md3 = LOW;\n        md4 = LOW;\n    end else begin\n        md1 = LOW;\n        md2 = LOW;\n        md3 = LOW;\n        md4 = LOW;\n    end\nend\n\nendmodule\n",
        "module_name": "CAR_CTR",
        "module_hash": "749a81b0ef912c34828e6a6d365c1aa1",
        "dataset_index": 23401
      },
      "controllerHdl_Complex_Multiply_566b4dc7": {
        "rtl_code": "\n\nmodule controllerHdl_Complex_Multiply\n          (\n           In1_re,\n           In1_im,\n           In2_re,\n           In2_im,\n           Re,\n           Im\n          );\n\n\n  input   signed [17:0] In1_re;  input   signed [17:0] In1_im;  input   signed [17:0] In2_re;  input   signed [17:0] In2_im;  output  signed [35:0] Re;  output  signed [35:0] Im;  wire signed [35:0] Product_out1;  wire signed [35:0] Product1_out1;  wire signed [35:0] Add1_out1;  wire signed [35:0] Product2_out1;  wire signed [35:0] Product3_out1;  wire signed [35:0] Add2_out1;  assign Product_out1 = In1_re * In2_re;\n\n\n\n  assign Product1_out1 = In1_im * In2_im;\n\n\n\n  assign Add1_out1 = Product_out1 - Product1_out1;\n\n\n\n  assign Re = Add1_out1;\n\n  assign Product2_out1 = In1_re * In2_im;\n\n\n\n  assign Product3_out1 = In1_im * In2_re;\n\n\n\n  assign Add2_out1 = Product2_out1 + Product3_out1;\n\n\n\n  assign Im = Add2_out1;\n\nendmodule  ",
        "module_name": "controllerHdl_Complex_Multiply",
        "module_hash": "566b4dc7b4e90ff13d1c5ef59b6d3d53",
        "dataset_index": 9453
      },
      "mux_2to1_300020fd": {
        "rtl_code": "module mux_2to1 (\n    A,\n    B,\n    SEL,\n    Y\n);\n\n    // Module ports\n    input A;\n    input B;\n    input SEL;\n    output Y;\n\n    // Implement 2:1 MUX\n    assign Y = (SEL == 1'b1) ? A : B;\n\nendmodule",
        "module_name": "mux_2to1",
        "module_hash": "300020fdd0c5fa2bc0069c9aa4fe77f4",
        "dataset_index": 6670
      },
      "fifo #_1ad47441": {
        "rtl_code": "module fifo #(\n  parameter depth = 8, // depth of the memory block\n  parameter data_width = 8 // width of the data\n)(\n  input clk,\n  input reset,\n  input write_en,\n  input [data_width-1:0] data_in,\n  input read_en,\n  output reg [data_width-1:0] data_out\n);\n\n\nreg [data_width-1:0] mem [0:depth-1]; // data storage array\nreg [$clog2(depth):0] write_ptr = 0; // write pointer\nreg [$clog2(depth):0] read_ptr = 0; // read pointer\nreg [$clog2(depth):0] count = 0; // number of data items in the memory block\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    write_ptr <= 0;\n    read_ptr <= 0;\n    count <= 0;\n  end else begin\n    if (write_en && count < depth) begin\n      mem[write_ptr] <= data_in;\n      write_ptr <= write_ptr + 1;\n      count <= count + 1;\n    end\n    if (read_en && count > 0) begin\n      data_out <= mem[read_ptr];\n      read_ptr <= read_ptr + 1;\n      count <= count - 1;\n    end\n  end\nend\n\nendmodule",
        "module_name": "fifo #",
        "module_hash": "1ad47441d2bfd4cc2d6d39df60e60d33",
        "dataset_index": 8436
      },
      "ones_complement_1c563355": {
        "rtl_code": "module ones_complement (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @ (in) begin\n        out = ~in;\n    end\n\nendmodule",
        "module_name": "ones_complement",
        "module_hash": "1c563355e03d6a36a8ede3800c3bee80",
        "dataset_index": 6526
      },
      "dff_e90d6c50": {
        "rtl_code": "\n\nmodule dff(\ndata  , q,\nclk    , reset  );\ninput data, clk, reset ; \n\noutput q;\n\nreg q;\n\nalways @ ( posedge clk or posedge reset)\nif (reset) begin\n  q <= 1'b0;\nend  else begin\n  q <= data;\nend\n\nendmodule ",
        "module_name": "dff",
        "module_hash": "e90d6c509001477d55a7bfb966f11fad",
        "dataset_index": 24407
      },
      "Mealy_cb91c0a9": {
        "rtl_code": "\nmodule Mealy(\n  input in,\n  output reg out\n);\n\nparameter n = 4; // number of states\n\n// Define states\nparameter s0 = 0;\nparameter s1 = 1;\nparameter s2 = 2;\nparameter s3 = 3;\n\nreg [1:0] state; // state register\n\n// Define transition conditions\nalways @(posedge in or negedge out) begin\n  if (!out) state <= s0;\n  else begin\n    case (state)\n      s0: if (in) state <= s1; else state <= s2;\n      s1: if (in) state <= s3; else state <= s0;\n      s2: if (in) state <= s0; else state <= s3;\n      s3: if (in) state <= s2; else state <= s1;\n    endcase\n  end\nend\n\n// Define output function\nalways @(posedge in or negedge out) begin\n  if (!out) out <= 1'b0;\n  else begin\n    case (state)\n      s0: out <= 1'b0;\n      s1: out <= 1'b1;\n      s2: out <= in;\n      s3: out <= ~in;\n    endcase\n  end\nend\n\nendmodule",
        "module_name": "Mealy",
        "module_hash": "cb91c0a938d1f2a81b4215648e606dcc",
        "dataset_index": 1574
      },
      "nios_system_keys_978f0470": {
        "rtl_code": "module nios_system_keys (\n                          // inputs:\n                           address,\n                           clk,\n                           in_port,\n                           reset_n,\n\n                          // outputs:\n                           readdata\n                        )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  3: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  3: 0] data_in;\n  wire    [  3: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {4 {(address == 0)}} & data_in;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n\n  assign data_in = in_port;\n\nendmodule",
        "module_name": "nios_system_keys",
        "module_hash": "978f0470f46aeb8ac6fc609a4a2753f2",
        "dataset_index": 11939
      },
      "top__c080009c": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // 8-bit input for the register\n    input select,     // Select input to choose between register and counter\n    input write_en,   // Write enable signal for the RAM\n    input [7:0] write_addr, // Write address for the RAM\n    input [3:0] write_data, // Write data for the RAM\n    input read_en,    // Read enable signal for the RAM\n    input [7:0] read_addr,  // Read address for the RAM\n    output reg [7:0] q,   // 8-bit output from the active module\n    output reg [3:0] counter_out, // Output from the counter module\n    output reg [3:0] ram_out // Output from the RAM module\n);\n\nreg [7:0] reg_out;\nreg [3:0] counter;\n\n// 8-bit register module\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        reg_out <= 8'h34;\n    end else begin\n        reg_out <= d;\n    end\nend\n\n// 4-bit counter module\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        counter <= 4'b0000;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Control logic module\nalways @(posedge clk) begin\n    if (select) begin\n        q <= reg_out;\n    end else begin\n        q <= counter;\n    end\nend\n\n// Additional functional module\nalways @* begin\n    counter_out = counter + reg_out[3:0];\nend\n\n// True dual-port RAM module\nreg [3:0] ram [0:7];\n\nalways @(posedge clk) begin\n    if (write_en) begin\n        ram[write_addr[2:0]] <= write_data;\n    end\n    if (read_en) begin\n        ram_out <= ram[read_addr[2:0]];\n    end\nend\n\nendmodule",
        "module_name": "top_",
        "module_hash": "c080009c52116526d4eed5646ca880b8",
        "dataset_index": 8920
      },
      "sky130_fd_sc_lp__and4bb_c49f1d61": {
        "rtl_code": "module sky130_fd_sc_lp__and4bb (\n    input A_N,\n    input B_N,\n    input C,\n    input D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    wire nA = ~A_N;\n    wire nB = ~B_N;\n    wire nC = ~C;\n    wire nD = ~D;\n\n    assign X = nA & nB & nC & nD & VPWR & VGND & VPB & VNB;\n\nendmodule",
        "module_name": "sky130_fd_sc_lp__and4bb",
        "module_hash": "c49f1d61071fafea466750573c8b8349",
        "dataset_index": 19377
      },
      "MC6502Accumulator_de4c6a65": {
        "rtl_code": "module MC6502Accumulator(\n    i_a,\n    i_m,\n    i_c,\n    i_d,\n    i_s,\n    o_a,\n    o_n,\n    o_z,\n    o_c,\n    o_v);\n  input  [7:0] i_a;\n  input  [7:0] i_m;\n  input        i_c;\n  input        i_d;\n  input        i_s;\n  output [7:0] o_a;\n  output       o_n;\n  output       o_z;\n  output       o_c;\n  output       o_v;\n\n  wire   [7:0] w_m;\n  wire   [4:0] w_bsum_lo;\n  wire   [4:0] w_dsum_lo;\n  wire   [4:0] w_bsum_hi;\n  wire   [4:0] w_dsum_hi;\n  wire   [4:0] w_sum_low;\n  wire   [4:0] w_sum_high;\n  wire         w_dover_lo;\n  wire         w_carry;\n  wire   [3:0] w_fix;\n\n  assign w_m        = i_s ? ~i_m : i_m;\n  assign w_fix      = i_s ? 4'ha : 4'h6;\n  assign w_bsum_lo  = i_a[3:0] + w_m[3:0] + { 3'b000, i_c };\n  assign w_dover_lo = w_bsum_lo > 5'h9;\n  assign w_dsum_lo  = w_dover_lo ? (w_bsum_lo + w_fix) : w_bsum_lo;\n  assign w_sum_low  = i_d ? w_dsum_lo : w_bsum_lo;\n  assign w_carry    = i_d ? w_dover_lo ^ i_s : w_sum_low[4];\n  assign w_bsum_hi  = i_a[7:4] + w_m[7:4] + { 3'b000, w_carry };\n  assign w_dsum_hi  = (w_bsum_hi[3:0] < 4'ha) ? w_bsum_hi : (w_bsum_hi + w_fix);\n  assign w_sum_high = i_d ? w_dsum_hi : w_bsum_hi;\n  assign o_a        = { w_sum_high[3:0], w_sum_low[3:0] };\n  assign o_n        = o_a[7];\n  assign o_z        = o_a == 8'h00;\n  assign o_c        = w_sum_high[4];\n  assign o_v        = (!(i_a[7] ^ w_m[7]) & (i_a[7] ^ o_a[7]));\nendmodule  ",
        "module_name": "MC6502Accumulator",
        "module_hash": "de4c6a652024e56bca27a6558bdbd9e5",
        "dataset_index": 19428
      },
      "axis_packetizer #_4caa6dfa": {
        "rtl_code": "\n\nmodule axis_packetizer #\n(\n  parameter integer AXIS_TDATA_WIDTH = 32,\n  parameter integer CNTR_WIDTH = 32,\n  parameter         CONTINUOUS = \"FALSE\",\n  parameter         ALWAYS_READY = \"FALSE\"\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n\n  input  wire [CNTR_WIDTH-1:0]       cfg_data,\n\n  output wire                        s_axis_tready,\n  input  wire [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,\n  input  wire                        s_axis_tvalid,\n\n  input  wire                        m_axis_tready,\n  output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,\n  output wire                        m_axis_tvalid,\n  output wire                        m_axis_tlast\n);\n\n  reg [CNTR_WIDTH-1:0] int_cntr_reg, int_cntr_next;\n  reg int_enbl_reg, int_enbl_next;\n\n  wire int_comp_wire, int_tvalid_wire, int_tlast_wire;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_cntr_reg <= {(CNTR_WIDTH){1'b0}};\n      int_enbl_reg <= 1'b0;\n    end\n    else\n    begin\n      int_cntr_reg <= int_cntr_next;\n      int_enbl_reg <= int_enbl_next;\n    end\n  end\n\n  assign int_comp_wire = int_cntr_reg < cfg_data;\n  assign int_tvalid_wire = int_enbl_reg & s_axis_tvalid;\n  assign int_tlast_wire = ~int_comp_wire;\n\n  generate\n    if(CONTINUOUS == \"TRUE\")\n    begin : CONTINUOUS\n      always @*\n      begin\n        int_cntr_next = int_cntr_reg;\n        int_enbl_next = int_enbl_reg;\n\n        if(~int_enbl_reg & int_comp_wire)\n        begin\n          int_enbl_next = 1'b1;\n        end\n\n        if(m_axis_tready & int_tvalid_wire & int_comp_wire)\n        begin\n          int_cntr_next = int_cntr_reg + 1'b1;\n        end\n\n        if(m_axis_tready & int_tvalid_wire & int_tlast_wire)\n        begin\n          int_cntr_next = {(CNTR_WIDTH){1'b0}};\n        end\n      end\n    end\n    else\n    begin : STOP\n      always @*\n      begin\n        int_cntr_next = int_cntr_reg;\n        int_enbl_next = int_enbl_reg;\n\n        if(~int_enbl_reg & int_comp_wire)\n        begin\n          int_enbl_next = 1'b1;\n        end\n\n        if(m_axis_tready & int_tvalid_wire & int_comp_wire)\n        begin\n          int_cntr_next = int_cntr_reg + 1'b1;\n        end\n\n        if(m_axis_tready & int_tvalid_wire & int_tlast_wire)\n        begin\n          int_enbl_next = 1'b0;\n        end\n      end\n    end\n  endgenerate\n\n  generate\n    if(ALWAYS_READY == \"TRUE\")\n    begin : READY\n      assign s_axis_tready = 1'b1;\n    end\n    else\n    begin : BLOCKING\n      assign s_axis_tready = int_enbl_reg & m_axis_tready;\n    end\n  endgenerate\n\n  assign m_axis_tdata = s_axis_tdata;\n  assign m_axis_tvalid = int_tvalid_wire;\n  assign m_axis_tlast = int_enbl_reg & int_tlast_wire;\n\nendmodule\n",
        "module_name": "axis_packetizer #",
        "module_hash": "4caa6dfae8d65404c8b32e5c19c93aca",
        "dataset_index": 23968
      },
      "zybo_top_80b86d92": {
        "rtl_code": "\nmodule zybo_top \n    (\n        // Main clock. See @note1.\n        input               CLK_125MHZ_I,\n        // Various I/O ports connected to board devices.\n        input        [3:0]  BUTTONS_I,\n        input        [3:0]  SWITCHES_I,\n        output reg   [3:0]  LEDS_O,\n        // PMOD E (Std) connector -- PMOD UART (Digilent).\n        output reg          PMOD_E_2_TXD_O,\n        input               PMOD_E_3_RXD_I\n    ); \n\n    reg [31:0] bogoinput;\n    reg [31:0] dbg_out;\n    reg [31:0] dbg_in;\n    reg reset;\n\n    //RV32ICore mcu_inst (\n    // Size of Code TCM in 32-bit words.\n    //.OPTION_CTCM_NUM_WORDS(1024),\n    // Main clock. See @note1.\n    //.CLK            (CLK_125MHZ_I),\n    // Reset.\n    //.RESET_I        (reset),\n\n    //.DEBUG_I        (dbg_in),\n    //.DEBUG_O        (dbg_out) \n    //); \n\n    always @(*) begin\n        LEDS_O = dbg_out[31:28] ^ dbg_out[27:24] ^ dbg_out[23:20] ^ dbg_out[19:16] ^\n                  dbg_out[15:12] ^ dbg_out[11: 8] ^ dbg_out[ 7: 4] ^ dbg_out[ 3: 0];\n\n        reset = |BUTTONS_I;\n\n        PMOD_E_2_TXD_O = PMOD_E_3_RXD_I;\n    end\n\n    always @(posedge CLK_125MHZ_I) begin\n        if (reset) begin\n            bogoinput <= 32'h0;\n            dbg_out <= 32'h0;\n            dbg_in <= 32'h0;\n        end\n        else begin \n            bogoinput <= {SWITCHES_I, {24{1'b0}}};\n            dbg_in <= dbg_out + bogoinput;    // Fix #1: Drive dbg_in\n            dbg_out <= dbg_out + bogoinput;    // Fix #2: Drive dbg_out\n        end \n    end    \n\nendmodule",
        "module_name": "zybo_top",
        "module_hash": "80b86d9285fa38bd95dc663e47fc7f7c",
        "dataset_index": 19185
      },
      "ripple_carry_adder_133e52bb": {
        "rtl_code": "\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output [3:0] SUM,\n    output COUT\n);\n\nreg [3:0] A_reg, B_reg;\nwire [3:0] SUM1, SUM2, SUM3; \nwire COUT1, COUT2, COUT3;\nreg CIN_reg;\n\nfull_adder FA1(A_reg[0], B_reg[0], CIN_reg, SUM1[0], COUT1);\nfull_adder FA2(A_reg[1], B_reg[1], COUT1, SUM2[1], COUT2);\nfull_adder FA3(A_reg[2], B_reg[2], COUT2, SUM3[2], COUT3);\nfull_adder FA4(A_reg[3], B_reg[3], COUT3, SUM[3], COUT);\n\nassign SUM[2] = SUM3[2];\nassign SUM[1] = SUM2[1];\nassign SUM[0] = SUM1[0];\n\nalways @(A or B or CIN) begin\n    A_reg <= A;\n    B_reg <= B;\n    CIN_reg <= CIN;\nend\n\nendmodule\nmodule full_adder (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\nassign {COUT, SUM} = A + B + CIN;\n\nendmodule",
        "module_name": "ripple_carry_adder",
        "module_hash": "133e52bba532a7354b623927ff5f41e4",
        "dataset_index": 10330
      },
      "binary_counter_896a1456": {
        "rtl_code": "module binary_counter (\n    input clk,\n    input rst,\n    output reg [3:0] q\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            q <= 4'b0;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "896a145687da3125914955af1a14a87d",
        "dataset_index": 17934
      },
      "full_adder_3ad770ec": {
        "rtl_code": "module full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign sum = (a ^ b) ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule",
        "module_name": "full_adder",
        "module_hash": "3ad770ec96be99453ba6c1df60dac5e1",
        "dataset_index": 12585
      },
      "cf_csc_1_mul_8865ff27": {
        "rtl_code": "\n\nmodule cf_csc_1_mul (\n\n  clk,\n  data_a,\n  data_b,\n  data_p,\n\n  ddata_in,\n  ddata_out);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input           clk;\n  input   [16:0]  data_a;\n  input   [ 7:0]  data_b;\n  output  [24:0]  data_p;\n  input   [DW:0]  ddata_in;\n  output  [DW:0]  ddata_out;\n\n  reg             p1_sign = 'd0;\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [23:0]  p1_data_p_0 = 'd0;\n  reg     [23:0]  p1_data_p_1 = 'd0;\n  reg     [23:0]  p1_data_p_2 = 'd0;\n  reg     [23:0]  p1_data_p_3 = 'd0;\n  reg     [23:0]  p1_data_p_4 = 'd0;\n  reg             p2_sign = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [23:0]  p2_data_p_0 = 'd0;\n  reg     [23:0]  p2_data_p_1 = 'd0;\n  reg             p3_sign = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [23:0]  p3_data_p_0 = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [24:0]  data_p = 'd0;\n\n  wire    [16:0]  p1_data_a_1p_17_s;\n  wire    [16:0]  p1_data_a_1n_17_s;\n  wire    [23:0]  p1_data_a_1p_s;\n  wire    [23:0]  p1_data_a_1n_s;\n  wire    [23:0]  p1_data_a_2p_s;\n  wire    [23:0]  p1_data_a_2n_s;\n\n  assign p1_data_a_1p_17_s = {1'b0, data_a[15:0]};\n  assign p1_data_a_1n_17_s = ~p1_data_a_1p_17_s + 1'b1;\n\n  assign p1_data_a_1p_s = {{7{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s};\n  assign p1_data_a_1n_s = {{7{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s};\n  assign p1_data_a_2p_s = {{6{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s, 1'b0};\n  assign p1_data_a_2n_s = {{6{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s, 1'b0};\n\n  always @(posedge clk) begin\n    p1_sign <= data_a[16];\n    p1_ddata <= ddata_in;\n    case (data_b[1:0])\n      2'b11: p1_data_p_0 <= p1_data_a_1n_s;\n      2'b10: p1_data_p_0 <= p1_data_a_2n_s;\n      2'b01: p1_data_p_0 <= p1_data_a_1p_s;\n      default: p1_data_p_0 <= 24'd0;\n    endcase\n    case (data_b[3:1])\n      3'b011: p1_data_p_1 <= {p1_data_a_2p_s[21:0], 2'd0};\n      3'b100: p1_data_p_1 <= {p1_data_a_2n_s[21:0], 2'd0};\n      3'b001: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b010: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b101: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      3'b110: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      default: p1_data_p_1 <= 24'd0;\n    endcase\n    case (data_b[5:3])\n      3'b011: p1_data_p_2 <= {p1_data_a_2p_s[19:0], 4'd0};\n      3'b100: p1_data_p_2 <= {p1_data_a_2n_s[19:0], 4'd0};\n      3'b001: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b010: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b101: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      3'b110: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      default: p1_data_p_2 <= 24'd0;\n    endcase\n    case (data_b[7:5])\n      3'b011: p1_data_p_3 <= {p1_data_a_2p_s[17:0], 6'd0};\n      3'b100: p1_data_p_3 <= {p1_data_a_2n_s[17:0], 6'd0};\n      3'b001: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b010: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b101: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      3'b110: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      default: p1_data_p_3 <= 24'd0;\n    endcase\n    case (data_b[7])\n      1'b1: p1_data_p_4 <= {p1_data_a_1p_s[15:0], 8'd0};\n      default: p1_data_p_4 <= 24'd0;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    p2_sign <= p1_sign;\n    p2_ddata <= p1_ddata;\n    p2_data_p_0 <= p1_data_p_0 + p1_data_p_1 + p1_data_p_4;\n    p2_data_p_1 <= p1_data_p_2 + p1_data_p_3;\n  end\n\n  always @(posedge clk) begin\n    p3_sign <= p2_sign;\n    p3_ddata <= p2_ddata;\n    p3_data_p_0 <= p2_data_p_0 + p2_data_p_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    data_p <= {p3_sign, p3_data_p_0};\n  end\n\nendmodule\n\n",
        "module_name": "cf_csc_1_mul",
        "module_hash": "8865ff27fd2f95c65562b39bc86dce16",
        "dataset_index": 23153
      },
      "top_module_167e3b1d": {
        "rtl_code": "module top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nwire [3:0] and_wire;\nwire [3:0] or_wire;\nwire [3:0] xor_wire;\n\nassign and_wire = in[0] & in[1] & in[2] & in[3];\nassign or_wire = in[0] | in[1] | in[2] | in[3];\nassign xor_wire = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nassign out_and = and_wire[0] & and_wire[1] & and_wire[2] & and_wire[3];\nassign out_or = or_wire[0] | or_wire[1] | or_wire[2] | or_wire[3];\nassign out_xor = xor_wire[0] ^ xor_wire[1] ^ xor_wire[2] ^ xor_wire[3];\n\nendmodule",
        "module_name": "top_module",
        "module_hash": "167e3b1dfe3b349f82d74b367f18be8c",
        "dataset_index": 6841
      },
      "up_down_counter_b5baa0ce": {
        "rtl_code": "module up_down_counter (\n  input clk,\n  input reset,\n  input up_down,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else if (enable) begin\n      if (up_down) begin\n        if (count == 4'b1111) begin\n          count <= 4'b0000;\n        end else begin\n          count <= count + 1;\n        end\n      end else begin\n        if (count == 4'b0000) begin\n          count <= 4'b1111;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\nendmodule\n",
        "module_name": "up_down_counter",
        "module_hash": "b5baa0ce3dc8c51bf7e02f0f7329dabc",
        "dataset_index": 16183
      },
      "ir_rcv_771f42f8": {
        "rtl_code": "`define STATE_IDLE\t\t        2'b00\n`define STATE_LEADVERIFY\t\t2'b01\n`define STATE_DATARCV\t\t\t2'b10\n\nmodule ir_rcv (\n    input clk50,\n    input reset_n,\n    input ir_rx,\n\toutput reg [31:0] ir_code,\n\toutput reg ir_code_ack\n);\n\nparameter LEADCODE_LO_THOLD     = 230000;  parameter LEADCODE_HI_THOLD     = 210000;  parameter LEADCODE_HI_RPT_THOLD = 105000;  parameter RPT_RELEASE_THOLD     = 6000000; parameter BIT_ONE_THOLD         = 41500;   parameter BIT_DETECT_THOLD      = 20000;   parameter IDLE_THOLD            = 262143;  reg [1:0] state;        reg [31:0] databuf;     reg [5:0] bits_detected;    reg [17:0] act_cnt;     reg [17:0] leadvrf_cnt; reg [17:0] datarcv_cnt; reg [22:0] rpt_cnt;     always @(posedge clk50 or negedge reset_n)\nbegin\n    if (!reset_n)\n        act_cnt <= 0;\n\telse\n    begin\n        if ((state == `STATE_IDLE) & (~ir_rx))\n            act_cnt <= act_cnt + 1'b1;\n        else\n            act_cnt <= 0;\n    end\nend\n\nalways @(posedge clk50 or negedge reset_n)\nbegin\n    if (!reset_n)\n        leadvrf_cnt <= 0;\n\telse\n    begin\n        if ((state == `STATE_LEADVERIFY) & ir_rx)\n            leadvrf_cnt <= leadvrf_cnt + 1'b1;\n        else\n            leadvrf_cnt <= 0;\n    end\nend\n\n\nalways @(posedge clk50 or negedge reset_n)\nbegin\n    if (!reset_n)\n    begin\n        datarcv_cnt <= 0;\n        bits_detected <= 0;\n        databuf <= 0;\n    end\n\telse\n    begin\n        if (state == `STATE_DATARCV)\n        begin\n            if (ir_rx)\n                datarcv_cnt <= datarcv_cnt + 1'b1;\n            else\n                datarcv_cnt <= 0;\n\n            if (datarcv_cnt == BIT_DETECT_THOLD)\n                bits_detected <= bits_detected + 1'b1;\n                \n            if (datarcv_cnt == BIT_ONE_THOLD)\n                databuf[32-bits_detected] <= 1'b1;\n        end\n        else\n        begin\n            datarcv_cnt <= 0;\n            bits_detected <= 0;\n            databuf <= 0;\n        end\n    end\nend\n\nalways @(posedge clk50 or negedge reset_n)\nbegin\n    if (!reset_n)\n    begin\n        ir_code_ack <= 1'b0;\n        ir_code <= 32'h00000000;\n    end\n\telse\n    begin\n        if ((bits_detected == 32) & (databuf[15:8] == ~databuf[7:0]))\n        begin\n            ir_code <= databuf;\n            ir_code_ack <= 1'b1;\n        end\n        else if (rpt_cnt >= RPT_RELEASE_THOLD)\n        begin\n            ir_code <= 32'h00000000;\n            ir_code_ack <= 1'b0;\n        end\n        else\n            ir_code_ack <= 1'b0;\n    end\nend\n\nalways @(posedge clk50 or negedge reset_n)\nbegin\n    if (!reset_n)\n    begin\n        state <= `STATE_IDLE;\n        rpt_cnt <= 0;\n    end\n    else\n    begin\n        rpt_cnt <= rpt_cnt + 1'b1;\n    \n        case (state)\n            `STATE_IDLE:\n                if (act_cnt >= LEADCODE_LO_THOLD)\n                    state <= `STATE_LEADVERIFY;\n            `STATE_LEADVERIFY:\n            begin\n                if (leadvrf_cnt == LEADCODE_HI_RPT_THOLD)\n                    rpt_cnt <= 0;\n                if (leadvrf_cnt >= LEADCODE_HI_THOLD)\n                    state <= `STATE_DATARCV;\n            end    \n            `STATE_DATARCV:\n                if ((datarcv_cnt >= IDLE_THOLD) | (bits_detected >= 33))\n                    state <= `STATE_IDLE;\n            default:\n                state <= `STATE_IDLE;\n        endcase\n    end\nend\n\nendmodule\n",
        "module_name": "ir_rcv",
        "module_hash": "771f42f81c7f3f935ecb99f62f0ee186",
        "dataset_index": 14355
      },
      "CDC_synchronizer #_0a8a4780": {
        "rtl_code": "module CDC_synchronizer #(\n  parameter n = 8, // number of bits in the data signal\n  parameter t = 2 // number of clock cycles for synchronization\n)(\n  input wire clk_in,\n  input wire rst_in,\n  input wire [n-1:0] data_in,\n  output reg [n-1:0] data_out\n);\n\n\nreg [n-1:0] ff1_out;\nreg [n-1:0] ff2_out;\n\nwire enable;\n\nassign enable = ~(&{clk_in, rst_in});\n\nalways @(posedge clk_in) begin\n  ff1_out <= data_in;\nend\n\ninteger i;\nalways @(posedge clk_in) begin // Changed clk_out to clk_in\n  if (i < t) begin\n    i <= i + 1;\n  end else begin\n    ff2_out <= ff1_out;\n    i <= 0;\n  end\nend\n\nalways @(posedge clk_in) begin // Changed clk_out to clk_in\n  if (enable) begin\n    data_out <= ff2_out;\n  end\nend\n\nendmodule",
        "module_name": "CDC_synchronizer #",
        "module_hash": "0a8a47808892cabfa2b055e8e0470442",
        "dataset_index": 1488
      },
      "timer_ea409d95": {
        "rtl_code": "\nmodule timer (\n    input clk,\n    input reset,\n    input [31:0] timer_count,\n    input timer_enable,\n    input timer_interrupt_clear,\n    output reg timer_count_done,\n    output reg timer_interrupt\n);\n\nreg [31:0] timer_count_running;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        timer_count_running <= 32'b0;\n        timer_count_done <= 1'b0;\n        timer_interrupt <= 1'b0;\n    end else if (timer_enable) begin\n        timer_count_running <= timer_count_running + 1;\n        if (timer_count_running == timer_count) begin\n            timer_count_running <= 32'b0;\n            timer_count_done <= 1'b1;\n        end\n    end else begin\n        timer_count_running <= 32'b0;\n        timer_count_done <= 1'b0;\n    end\n\n    if (timer_interrupt_clear) begin\n        timer_interrupt <= 1'b0;\n    end else if (timer_count_done) begin\n        timer_interrupt <= 1'b1;\n    end\nend\n\nendmodule",
        "module_name": "timer",
        "module_hash": "ea409d95023adca7e43b76de906a7c99",
        "dataset_index": 2023
      },
      "MemoryArbiter #_5bf13b1c": {
        "rtl_code": "module MemoryArbiter #(\n  parameter n = 4 // number of memory modules\n)(\n  input [n-1:0] mem_req,\n  input [n-1:0] mem_ack,\n  output reg [n-1:0] mem_req_out,\n  output reg [n-1:0] mem_ack_out\n);\n\n\nreg [n-1:0] req_priority; // priority scheme\n\nalways @(*) begin\n  // set priority based on predefined scheme\n  req_priority = {mem_req[0] & mem_ack[0], mem_req[1] & mem_ack[1], mem_req[2] & mem_ack[2], mem_req[3] & mem_ack[3]};\n  \n  // select highest priority request\n  case(req_priority)\n    4'b1000: mem_req_out = mem_req[0];\n    4'b0100: mem_req_out = mem_req[1];\n    4'b0010: mem_req_out = mem_req[2];\n    4'b0001: mem_req_out = mem_req[3];\n    default: mem_req_out = 0;\n  endcase\n  \n  // notify memory controller when request has been processed\n  mem_ack_out = 0;\n  case(mem_req_out)\n    mem_req[0]: mem_ack_out = mem_ack[0];\n    mem_req[1]: mem_ack_out = mem_ack[1];\n    mem_req[2]: mem_ack_out = mem_ack[2];\n    mem_req[3]: mem_ack_out = mem_ack[3];\n    default: mem_ack_out = 0;\n  endcase\nend\n\nendmodule",
        "module_name": "MemoryArbiter #",
        "module_hash": "5bf13b1cbcbf9d0d90cef7a775e9cf4c",
        "dataset_index": 3511
      },
      "binary_adder_tree_474e3fd2": {
        "rtl_code": "module binary_adder_tree(A, B, C, D, E, F, G, H, I, clk, checksum_reg);\n   \n\tinput\t[15:0] A, B, C, D, E, F, G, H, I;\n\tinput\tclk;\n\toutput\treg [15:0] checksum_reg;\n\n\twire    [15:0]    checksum;\n\twire\t[16:0]    sum_a_b, sum_c_d, sum_e_f, sum_g_h, sum_ab_cd, sum_ef_gh, sum_abcd_efgh, sum_i;\n\treg\t[16:0]    sumreg_ab, sumreg_cd, sumreg_ef, sumreg_gh, sumreg_ab_cd, sumreg_ef_gh, sumreg_abcd_efgh, sumreg_i;\n\t// Registers\n\talways @ (posedge clk)\n\t\tbegin\n\t\t\t//cycle 1\n\t\t\tsumreg_ab <= sum_a_b;\n\t\t\tsumreg_cd <= sum_c_d;\n\t\t\tsumreg_ef <= sum_e_f;\n\t\t\tsumreg_gh <= sum_g_h;\n\n\t\t\t//cycle 2\n\t\t\tsumreg_ab_cd <= sum_ab_cd;\n\t\t\tsumreg_ef_gh <= sum_ef_gh;\n\t\t\t\n\t\t\t//cycle 3\n\t\t\tsumreg_abcd_efgh <= sum_abcd_efgh;\n\n\t\t\t//cycle 4\n\t\t\tsumreg_i <= sum_i;\n\n\t\t\t//CYCLE 5\n\t\t\tchecksum_reg <= checksum;\n\t\tend\n\t// 2-bit additions\n\tassign \t\t\t  sum_a_b = A + B;\n\tassign \t\t\t  sum_c_d = C + D;\n\tassign\t\t\t  sum_e_f = E + F;\n\tassign \t\t\t  sum_g_h = G + H;\n\n\tassign \t\t\t  sum_ab_cd = sumreg_ab + sumreg_cd;\n\tassign \t\t\t  sum_ef_gh = sumreg_ef + sumreg_gh;\n\n\tassign \t\t\t  sum_abcd_efgh = sumreg_ab_cd + sumreg_ef_gh;\n\tassign\t\t\t  sum_i = sumreg_abcd_efgh+I;\n\t\n\tassign \t\t\t  checksum = ~((sumreg_i[16]==1'b1)?(sumreg_i[15:0]+1):sumreg_i[15:0]);\nendmodule",
        "module_name": "binary_adder_tree",
        "module_hash": "474e3fd2c0183ff24bed26c6ae33c5d4",
        "dataset_index": 8320
      },
      "font_display_e853b8ac": {
        "rtl_code": "module font_display(\n    input [9:0] pix_x,\n    input [9:0] pix_y,\n    input score_on,\n    input logo_on,\n    input registration_on,\n    input [7:0] font_word,\n    output reg [3:0] text_on,\n    output reg [6:0] char_addr,\n    output reg [3:0] row_addr,\n    output reg [2:0] bit_addr,\n    output reg [2:0] text_rgb,\n    input clk\n);\n\n    // FSM states\n    parameter IDLE = 2'b00;\n    parameter SCORE = 2'b01;\n    parameter LOGO = 2'b10;\n    parameter REGISTRATION = 2'b11;\n\n    // FSM state and output registers\n    reg [1:0] state_reg, state_next;\n    reg [6:0] char_addr_reg, char_addr_next;\n    reg [3:0] row_addr_reg, row_addr_next;\n    reg [2:0] bit_addr_reg, bit_addr_next;\n    reg [2:0] text_rgb_reg, text_rgb_next;\n\n    // pixel coordinate registers\n    reg [3:0] row_reg, bit_reg;\n\n    // FSM state machine\n    always @* begin\n        state_next = IDLE;\n        char_addr_next = 7'h00;\n        row_addr_next = pix_y[5:2];\n        bit_addr_next = pix_x[4:2];\n        text_rgb_next = 3'b110;\n        case(pix_x[8:5])\n            4'h5: begin\n                state_next = SCORE;\n                char_addr_next = 7'h47; // G\n                text_rgb_next = 3'b001; // green\n            end\n            4'h6: begin\n                state_next = SCORE;\n                char_addr_next = 7'h61; // a\n                text_rgb_next = 3'b001; // green\n            end\n            4'h7: begin\n                state_next = SCORE;\n                char_addr_next = 7'h6d; // m\n                text_rgb_next = 3'b001; // green\n            end\n            4'h8: begin\n                state_next = SCORE;\n                char_addr_next = 7'h65; // e\n                text_rgb_next = 3'b001; // green\n            end\n            4'h9: begin\n                state_next = LOGO;\n                char_addr_next = 7'h00; // blank\n                text_rgb_next = 3'b110; // yellow\n            end\n            4'ha: begin\n                state_next = LOGO;\n                char_addr_next = 7'h4f; // O\n                text_rgb_next = 3'b011; // orange\n            end\n            4'hb: begin\n                state_next = LOGO;\n                char_addr_next = 7'h76; // v\n                text_rgb_next = 3'b011; // orange\n            end\n            4'hc: begin\n                state_next = LOGO;\n                char_addr_next = 7'h65; // e\n                text_rgb_next = 3'b011; // orange\n            end\n            default: begin\n                state_next = REGISTRATION;\n                char_addr_next = 7'h72; // r\n                text_rgb_next = 3'b001; // green\n            end\n        endcase\n    end\n\n    // update state and output registers\n    always @(posedge clk) begin\n        state_reg <= state_next;\n        char_addr_reg <= char_addr_next;\n        row_addr_reg <= row_addr_next;\n        bit_addr_reg <= bit_addr_next;\n        text_rgb_reg <= text_rgb_next;\n    end\n\n    // update pixel coordinate registers\n    always @(posedge clk) begin\n        row_reg <= pix_y[1:0];\n        bit_reg <= pix_x[1:0];\n    end\n\n    // multiplexer for font ROM addresses and rgb\n    always @* begin\n        text_on = state_reg;\n        case(state_reg)\n            IDLE: begin\n                char_addr = char_addr_reg;\n                row_addr = row_addr_reg;\n                bit_addr = bit_addr_reg;\n                text_rgb = text_rgb_reg;\n            end\n            SCORE: begin\n                char_addr = char_addr_reg;\n                row_addr = row_reg + (char_addr_reg[6:0] << 2);\n                bit_addr = bit_reg;\n                text_rgb = text_rgb_reg;\n            end\n            LOGO: begin\n                char_addr = char_addr_reg;\n                row_addr = row_reg + (char_addr_reg[6:0] << 2);\n                bit_addr = bit_reg;\n                if (font_word[bit_reg])\n                    text_rgb = text_rgb_reg;\n                else\n                    text_rgb = 3'b110; // yellow\n            end\n            REGISTRATION: begin\n                char_addr = char_addr_reg;\n                row_addr = row_addr_reg;\n                bit_addr = bit_addr_reg;\n                text_rgb = text_rgb_reg;\n            end\n        endcase\n    end\n\nendmodule",
        "module_name": "font_display",
        "module_hash": "e853b8ac65fc16bd88b09fdd4cadc35a",
        "dataset_index": 2789
      },
      "async_transmitter_2a0c8742": {
        "rtl_code": "module async_transmitter(\n\tinput clk,\n\tinput TxD_start,\n\tinput [7:0] TxD_data,\n\toutput TxD,\n\toutput TxD_busy\n);\n\nparameter ClkFrequency = 50000000;\tparameter Baud = 9600;\n\ngenerate\n\tif(ClkFrequency<Baud*8 && (ClkFrequency % Baud!=0)) ASSERTION_ERROR PARAMETER_OUT_OF_RANGE(\"Frequency incompatible with requested Baud rate\");\nendgenerate\n\n`ifdef SIMULATION\nwire BitTick = 1'b1;  `else\nwire BitTick;\nBaudTickGen #(ClkFrequency, Baud) tickgen(.clk(clk), .enable(TxD_busy), .tick(BitTick));\n`endif\n\nreg [3:0] TxD_state = 0;\nwire TxD_ready = (TxD_state==0);\nassign TxD_busy = ~TxD_ready;\n\nreg [7:0] TxD_shift = 0;\nalways @(posedge clk)\nbegin\n\tif(TxD_ready & TxD_start)\n\t\tTxD_shift <= TxD_data;\n\telse\n\tif(TxD_state[3] & BitTick)\n\t\tTxD_shift <= (TxD_shift >> 1);\n\n\tcase(TxD_state)\n\t\t4'b0000: if(TxD_start) TxD_state <= 4'b0100;\n\t\t4'b0100: if(BitTick) TxD_state <= 4'b1000;  4'b1000: if(BitTick) TxD_state <= 4'b1001;  4'b1001: if(BitTick) TxD_state <= 4'b1010;  4'b1010: if(BitTick) TxD_state <= 4'b1011;  4'b1011: if(BitTick) TxD_state <= 4'b1100;  4'b1100: if(BitTick) TxD_state <= 4'b1101;  4'b1101: if(BitTick) TxD_state <= 4'b1110;  4'b1110: if(BitTick) TxD_state <= 4'b1111;  4'b1111: if(BitTick) TxD_state <= 4'b0010;  4'b0010: if(BitTick) TxD_state <= 4'b0011;  4'b0011: if(BitTick) TxD_state <= 4'b0000;  default: if(BitTick) TxD_state <= 4'b0000;\n\tendcase\nend\n\nassign TxD = (TxD_state<4) | (TxD_state[3] & TxD_shift[0]);  endmodule\n\n\nmodule async_receiver(\n\tinput clk,\n\tinput RxD,\n\toutput reg RxD_data_ready = 0,\n\toutput reg [7:0] RxD_data = 0,  output RxD_idle,  output reg RxD_endofpacket = 0  );\n\nparameter ClkFrequency = 50000000; parameter Baud = 9600;\n\nparameter Oversampling = 16;  generate\n\tif(ClkFrequency<Baud*Oversampling) ASSERTION_ERROR PARAMETER_OUT_OF_RANGE(\"Frequency too low for current Baud rate and oversampling\");\n\tif(Oversampling<8 || ((Oversampling & (Oversampling-1))!=0)) ASSERTION_ERROR PARAMETER_OUT_OF_RANGE(\"Invalid oversampling value\");\nendgenerate\n\nreg [3:0] RxD_state = 0;\n\n`ifdef SIMULATION\nwire RxD_bit = RxD;\nwire sampleNow = 1'b1;  `else\nwire OversamplingTick;\nBaudTickGen #(ClkFrequency, Baud, Oversampling) tickgen(.clk(clk), .enable(1'b1), .tick(OversamplingTick));\n\nreg [1:0] RxD_sync = 2'b11;\nalways @(posedge clk) if(OversamplingTick) RxD_sync <= {RxD_sync[0], RxD};\n\nreg [1:0] Filter_cnt = 2'b11;\nreg RxD_bit = 1'b1;\n\nalways @(posedge clk)\nif(OversamplingTick)\nbegin\n\tif(RxD_sync[1]==1'b1 && Filter_cnt!=2'b11) Filter_cnt <= Filter_cnt + 1'd1;\n\telse \n\tif(RxD_sync[1]==1'b0 && Filter_cnt!=2'b00) Filter_cnt <= Filter_cnt - 1'd1;\n\n\tif(Filter_cnt==2'b11) RxD_bit <= 1'b1;\n\telse\n\tif(Filter_cnt==2'b00) RxD_bit <= 1'b0;\nend\n\nfunction integer log2(input integer v); begin log2=0; while(v>>log2) log2=log2+1; end endfunction\nlocalparam l2o = log2(Oversampling);\nreg [l2o-2:0] OversamplingCnt = 0;\nalways @(posedge clk) if(OversamplingTick) OversamplingCnt <= (RxD_state==0) ? 1'd0 : OversamplingCnt + 1'd1;\nwire sampleNow = OversamplingTick && (OversamplingCnt==Oversampling/2-1);\n`endif\n\nalways @(posedge clk)\ncase(RxD_state)\n\t4'b0000: if(~RxD_bit) RxD_state <= `ifdef SIMULATION 4'b1000 `else 4'b0001 `endif;  4'b0001: if(sampleNow) RxD_state <= 4'b1000;  4'b1000: if(sampleNow) RxD_state <= 4'b1001;  4'b1001: if(sampleNow) RxD_state <= 4'b1010;  4'b1010: if(sampleNow) RxD_state <= 4'b1011;  4'b1011: if(sampleNow) RxD_state <= 4'b1100;  4'b1100: if(sampleNow) RxD_state <= 4'b1101;  4'b1101: if(sampleNow) RxD_state <= 4'b1110;  4'b1110: if(sampleNow) RxD_state <= 4'b1111;  4'b1111: if(sampleNow) RxD_state <= 4'b0010;  4'b0010: if(sampleNow) RxD_state <= 4'b0000;  default: RxD_state <= 4'b0000;\nendcase\n\nalways @(posedge clk)\nif(sampleNow && RxD_state[3]) RxD_data <= {RxD_bit, RxD_data[7:1]};\n\nalways @(posedge clk)\nbegin\n\tRxD_data_ready <= (sampleNow && RxD_state==4'b0010 && RxD_bit);  end\n\nreg [l2o+1:0] GapCnt = 0;\nalways @(posedge clk) if (RxD_state!=0) GapCnt<=0; else if(OversamplingTick & ~GapCnt[log2(Oversampling)+1]) GapCnt <= GapCnt + 1'h1;\nassign RxD_idle = GapCnt[l2o+1];\nalways @(posedge clk) RxD_endofpacket <= OversamplingTick & ~GapCnt[l2o+1] & &GapCnt[l2o:0];\nendmodule\n\n\nmodule ASSERTION_ERROR();\nendmodule\n\n\nmodule BaudTickGen(\n\tinput clk, enable,\n\toutput tick  );\nparameter ClkFrequency = 50000000;\nparameter Baud = 9600;\nparameter Oversampling = 1;\n\nfunction integer log2(input integer v); begin log2=0; while(v>>log2) log2=log2+1; end endfunction\nlocalparam AccWidth = log2(ClkFrequency/Baud)+8;  reg [AccWidth:0] Acc = 0;\nlocalparam ShiftLimiter = log2(Baud*Oversampling >> (31-AccWidth));  localparam Inc = ((Baud*Oversampling << (AccWidth-ShiftLimiter))+(ClkFrequency>>(ShiftLimiter+1)))/(ClkFrequency>>ShiftLimiter);\nalways @(posedge clk) if(enable) Acc <= Acc[AccWidth-1:0] + Inc[AccWidth:0]; else Acc <= Inc[AccWidth:0];\nassign tick = Acc[AccWidth];\nendmodule\n\n\n",
        "module_name": "async_transmitter",
        "module_hash": "2a0c874248fdc943866c736acf1bcd90",
        "dataset_index": 23233
      },
      "counter_8693f7a6": {
        "rtl_code": "\nmodule counter (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output reg [3:0] count\n);\n\n    // State definitions\n    localparam [1:0]\n        S0 = 2'b00,\n        S1 = 2'b01,\n        S2 = 2'b10,\n        S3 = 2'b11;\n\n    // State register\n    reg [1:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            count <= 4'b0000;\n        end else begin\n            case (state)\n                S0: begin\n                    state <= S1;\n                    count <= count + 1;\n                end\n                S1: begin\n                    state <= S2;\n                    count <= count + 1;\n                end\n                S2: begin\n                    state <= S3;\n                    count <= count + 1;\n                end\n                S3: begin\n                    state <= S0;\n                    count <= count + 1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\nmodule odd_even_detector (\n    input [3:0] count,\n    output reg odd_even\n);\n\n    always @(*)\n        odd_even = count[0];\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output reg [6:0] seg,\n    output odd_even\n);\n\n    wire [3:0] count;\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .count(count)\n    );\n\n    odd_even_detector odd_even_inst (\n        .count(count),\n        .odd_even(odd_even)\n    );\n\n    always @(count) begin\n        case (count)\n            4'b0000: seg = 7'b1000000; // 0\n            4'b0001: seg = 7'b1111001; // 1\n            4'b0010: seg = 7'b0100100; // 2\n            4'b0011: seg = 7'b0110000; // 3\n            4'b0100: seg = 7'b0011001; // 4\n            4'b0101: seg = 7'b0010010; // 5\n            4'b0110: seg = 7'b0000010; // 6\n            4'b0111: seg = 7'b1111000; // 7\n            4'b1000: seg = 7'b0000000; // 8\n            4'b1001: seg = 7'b0011000; // 9\n            4'b1010: seg = 7'b0001000; // A\n            4'b1011: seg = 7'b0000011; // B\n            4'b1100: seg = 7'b1000110; // C\n            4'b1101: seg = 7'b0100001; // D\n            4'b1110: seg = 7'b0000110; // E\n            4'b1111: seg = 7'b0001110; // F\n        endcase\n    end\n\nendmodule\n",
        "module_name": "counter",
        "module_hash": "8693f7a69aa6285594f032687c9a8c84",
        "dataset_index": 4827
      },
      "sel_to_out_3ffd928c": {
        "rtl_code": "module sel_to_out(\n    input [3:0] SEL,\n    output reg [7:0] OUT\n);\n\nalways @(*) begin\n    case(SEL)\n        4'h0: OUT = 8'b00000001;\n        4'h1: OUT = 8'b00000010;\n        4'h2: OUT = 8'b00000100;\n        4'h3: OUT = 8'b00001000;\n        4'h4: OUT = 8'b00010000;\n        4'h5: OUT = 8'b00100000;\n        4'h6: OUT = 8'b01000000;\n        4'h7: OUT = 8'b10000000;\n        4'h8: OUT = 8'b00000000;\n        4'h9: OUT = 8'b11111111;\n        4'ha: OUT = 8'b11111110;\n        4'hb: OUT = 8'b11111100;\n        4'hc: OUT = 8'b11111000;\n        4'hd: OUT = 8'b11110000;\n        4'he: OUT = 8'b11100000;\n        4'hf: OUT = 8'b11000000;\n        default: OUT = 8'b00000000;\n    endcase\nend\n\nendmodule",
        "module_name": "sel_to_out",
        "module_hash": "3ffd928cf9fb50e41820f04b2b4bbe84",
        "dataset_index": 5944
      },
      "dff_pn0_274b0500": {
        "rtl_code": "\nmodule dff_pn0 (input D, C, R, S, output Q);\n\n    reg Q;\n\n    always @(posedge C) begin\n        if (!R) begin\n            Q <= 0;\n        end else if (S) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule",
        "module_name": "dff_pn0",
        "module_hash": "274b0500f6f400fd002e175c7b8b79bb",
        "dataset_index": 19712
      },
      "sky130_fd_sc_hdll__nand3b_17d1cd9d": {
        "rtl_code": "\n\n\nmodule sky130_fd_sc_hdll__nand3b (\n    Y  ,\n    A_N,\n    B  ,\n    C\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N            );\n    nand nand0 (nand0_out_Y, B, not0_out, C );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n",
        "module_name": "sky130_fd_sc_hdll__nand3b",
        "module_hash": "17d1cd9db63bfe67416d6a7153a6f2de",
        "dataset_index": 23323
      },
      "dff_26f28105": {
        "rtl_code": "\nmodule dff(D, CLK, Q);\n  input D, CLK;\n  output Q;\n\n  reg Q;\n\n  always @(posedge CLK) begin\n    Q <= D;\n  end\nendmodule\n",
        "module_name": "dff",
        "module_hash": "26f28105f201ab1050060c4383881bef",
        "dataset_index": 14831
      },
      "dual_port_ram_8c63287b": {
        "rtl_code": "module dual_port_ram(\n    // Write port\n    input wrclk,\n    input [7:0] di,\n    input wren,\n    input [5:0] wraddr,\n    // Read port\n    input rdclk,\n    input rden,\n    input [5:0] rdaddr,\n    output reg [7:0] do);\n\n     reg [7:0] ram[0:63];\n\n    initial begin\n        ram[0] = 8'b00000001;\n        ram[1] = 8'b10101010;\n        ram[2] = 8'b01010101;\n        ram[3] = 8'b11111111;\n        ram[4] = 8'b11110000;\n        ram[5] = 8'b00001111;\n        ram[6] = 8'b11001100;\n        ram[7] = 8'b00110011;\n        ram[8] = 8'b00000010;\n        ram[9] = 8'b00000100;\n    end\n\n    always @ (posedge wrclk) begin\n        if(wren == 1) begin\n            ram[wraddr] <= di;\n        end\n    end\n\n    always @ (posedge rdclk) begin\n        if(rden == 1) begin\n            do <= ram[rdaddr];\n        end\n    end\n\nendmodule",
        "module_name": "dual_port_ram",
        "module_hash": "8c63287b4fc528718faeb15f913d7ba7",
        "dataset_index": 15922
      },
      "MUX4X1_ee245017": {
        "rtl_code": "module MUX4X1 (\n    A,\n    B,\n    C,\n    D,\n    S0,\n    S1,\n    Y\n);\n\n    input [3:0] A, B, C, D;\n    input [1:0] S0, S1;\n    output Y;\n\n    wire sel1, sel2;\n\n    // Select line logic\n    assign sel1 = (S1 == 1'b0) ? A : B;\n    assign sel2 = (S1 == 1'b0) ? C : D;\n\n    // Output logic\n    assign Y = (S0 == 1'b0) ? sel1 : sel2;\n\nendmodule",
        "module_name": "MUX4X1",
        "module_hash": "ee24501759df6a4dd7e3b4ed64ac0ac4",
        "dataset_index": 6349
      },
      "Registro_Universal_d40f4634": {
        "rtl_code": "\nmodule Registro_Universal\n#(parameter N = 8) (\n\tinput wire hold,\n\tinput wire [N-1:0]in_rtc_dato,\n\tinput wire [N-1:0]in_count_dato,\n\tinput wire clk, input wire reset, input wire chip_select, output wire [N-1:0]out_dato\n);\nreg [N-1:0]reg_dato;\nreg [N-1:0]next_dato;\n\nalways@(negedge clk, posedge reset)\nbegin\n\tif(reset) reg_dato <= 0;\n\telse reg_dato <= next_dato;\nend\n\nalways@*\n\tbegin\n\tif (~hold) begin\n\tcase(chip_select)\n\t1'b0: next_dato = in_rtc_dato;\n\t1'b1: next_dato = in_count_dato;\n\tendcase\n\tend\n\telse next_dato = reg_dato;\n\tend\n\nassign out_dato = reg_dato;\n\nendmodule\n\n",
        "module_name": "Registro_Universal",
        "module_hash": "d40f4634d398753c16611d57248e7e5c",
        "dataset_index": 21689
      },
      "soc_system_button_pio_22670841": {
        "rtl_code": "module soc_system_button_pio (\n  // inputs:\n  address,\n  chipselect,\n  clk,\n  in_port,\n  reset_n,\n  write_n,\n  writedata,\n\n  // outputs:\n  irq,\n  readdata\n);\n\n  output irq;\n  output [31:0] readdata;\n  input [1:0] address;\n  input chipselect;\n  input clk;\n  input [1:0] in_port;\n  input reset_n;\n  input write_n;\n  input [31:0] writedata;\n\n  wire clk_en;\n  reg [1:0] d1_data_in;\n  reg [1:0] d2_data_in;\n  wire [1:0] data_in;\n  reg [1:0] edge_capture;\n  wire edge_capture_wr_strobe;\n  wire [1:0] edge_detect;\n  wire irq;\n  reg [1:0] irq_mask;\n  wire [1:0] read_mux_out;\n  reg [31:0] readdata;\n\n  assign clk_en = 1;\n\n  // Multiplexer for readdata output\n  assign read_mux_out = ({2 {(address == 0)}} & data_in) |\n                        ({2 {(address == 2)}} & irq_mask) |\n                        ({2 {(address == 3)}} & edge_capture);\n\n  // Register for readdata output\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      readdata <= 0;\n    end else if (clk_en) begin\n      readdata <= {32'b0 | read_mux_out};\n    end\n  end\n\n  // Assign data_in to in_port input\n  assign data_in = in_port;\n\n  // Register for irq_mask\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      irq_mask <= 0;\n    end else if (chipselect && ~write_n && (address == 2)) begin\n      irq_mask <= writedata[1:0];\n    end\n  end\n\n  // Generate irq signal\n  assign irq = |(edge_capture & irq_mask);\n\n  // Generate edge_capture_wr_strobe signal\n  assign edge_capture_wr_strobe = chipselect && ~write_n && (address == 3);\n\n  // Register for edge_capture[0]\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      edge_capture[0] <= 0;\n    end else if (clk_en) begin\n      if (edge_capture_wr_strobe && writedata[0]) begin\n        edge_capture[0] <= 0;\n      end else if (edge_detect[0]) begin\n        edge_capture[0] <= ~in_port[0];\n      end\n    end\n  end\n\n  // Register for edge_capture[1]\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      edge_capture[1] <= 0;\n    end else if (clk_en) begin\n      if (edge_capture_wr_strobe && writedata[1]) begin\n        edge_capture[1] <= 0;\n      end else if (edge_detect[1]) begin\n        edge_capture[1] <= ~in_port[1];\n      end\n    end\n  end\n\n  // Registers for edge_detect\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      d1_data_in <= 0;\n      d2_data_in <= 0;\n    end else if (clk_en) begin\n      d1_data_in <= data_in;\n      d2_data_in <= d1_data_in;\n    end\n  end\n\n  // Generate edge_detect signal\n  assign edge_detect = ~d1_data_in & d2_data_in;\n\nendmodule",
        "module_name": "soc_system_button_pio",
        "module_hash": "22670841b4f33693c51e10bc7bb2af7d",
        "dataset_index": 17805
      }
    }
  },
  "created_at": "2025-11-13T16:40:59.301065"
}