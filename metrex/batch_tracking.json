{
  "batch_ids": [
    "batch_690cf9d218508190995500904c0c902a"
  ],
  "metadata": {
    "batch_690cf9d218508190995500904c0c902a": {
      "binary_to_gray_converter_eca80e7d": {
        "rtl_code": "module binary_to_gray_converter (\n  input [2:0] binary,\n  output reg [2:0] gray\n);\n\n  always @(*) begin\n    gray[0] = binary[0] ^ binary[1];\n    gray[1] = binary[1] ^ binary[2];\n    gray[2] = binary[2];\n  end\n\nendmodule\n",
        "module_name": "binary_to_gray_converter",
        "module_hash": "eca80e7dc41dadcc73e7edecce84df4d",
        "dataset_index": 9127
      },
      "binary_counter_48db2906": {
        "rtl_code": "module binary_counter(\n  input clk,\n  input [3:0] reset,\n  input [3:0] enable,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset == 4'b1111) begin\n    count <= 4'b0000;\n  end else if (enable == 4'b1111) begin\n    count <= count + 1;\n    if (count == 4'b1111) begin\n      count <= 4'b0000;\n    end\n  end\nend\n\nendmodule",
        "module_name": "binary_counter",
        "module_hash": "48db2906c1c76a7c46857830e8539900",
        "dataset_index": 17404
      },
      "top__756b6f7d": {
        "rtl_code": "module top_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input [7:0] a,\n    input [7:0] b,\n    input [3:0] data,\n    input select,\n    output [7:0] s,\n    output overflow\n);\n\n    // Convert 2's complement numbers to sign-magnitude format\n    wire [7:0] a_mag = (a[7] == 1) ? {1'b0, ~a[6:0] + 1} : a;\n    wire [7:0] b_mag = (b[7] == 1) ? {1'b0, ~b[6:0] + 1} : b;\n\n    // Adder module\n    wire [8:0] adder_out;\n    wire adder_overflow;\n    carry_select_adder adder_inst (\n        .a(a_mag),\n        .b(b_mag),\n        .cin(1'b0),\n        .s(adder_out),\n        .cout(),\n        .overflow(adder_overflow)\n    );\n\n    // Shift register module\n    wire [3:0] shift_out;\n    shift_register shift_inst (\n        .clk(clk),\n        .reset(reset),\n        .data(data),\n        .enable(1'b1),\n        .load(1'b0),\n        .shift_left(select),\n        .q(shift_out)\n    );\n\n    // Output selection logic\n    assign s = (select == 1'b0) ? adder_out[7:0] : {4'b0, shift_out};\n    assign overflow = adder_overflow;\n\nendmodule\n\n// 8-bit carry-select adder module\nmodule carry_select_adder (\n    input [7:0] a,\n    input [7:0] b,\n    input cin,\n    output [8:0] s,\n    output cout,\n    output overflow\n);\n\n    wire [7:0] p = a + b;\n    wire [7:0] g = a & b;\n    wire [7:0] u = p + (g << 1);\n    wire [7:0] v = p - (g << 1);\n\n    assign s = (cin == 1'b0) ? u : v;\n    assign cout = (g[6] | (g[5] & cin));\n    assign overflow = (a[7] == b[7] && s[7] != a[7]);\n\nendmodule\n\n// 4-bit shift register module\nmodule shift_register (\n    input clk,\n    input reset,  // Asynchronous active-high reset\n    input [3:0] data,\n    input enable,\n    input load,\n    input shift_left,\n    output [3:0] q\n);\n\n    reg [3:0] q_reg;\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            q_reg <= 4'b0;\n        end else if (enable) begin\n            if (load) begin\n                q_reg <= data;\n            end else if (shift_left) begin\n                q_reg <= {q_reg[2:0], 1'b0};\n            end else begin\n                q_reg <= {1'b0, q_reg[3:1]};\n            end\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule",
        "module_name": "top_",
        "module_hash": "756b6f7db7b0541b24bba88076c95601",
        "dataset_index": 585
      },
      "four_bit_adder_31cdb2f8": {
        "rtl_code": "\nmodule four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\nwire [3:0] xor1, xor2, xor3;\nwire and1, and2, and3, and4, or1, or2;\n\n// Calculate the XORs\nassign xor1 = A ^ B;\nassign xor2 = {A[1:0],1'b0} ^ {B[1:0],1'b0} ^ Cin;\nassign xor3 = {A[2:0],1'b0} ^ {B[2:0],1'b0} ^ {Cin,1'b0};\n\n// Calculate the ANDs\nassign and1 = A[0] & B[0];\nassign and2 = A[1] & B[1];\nassign and3 = A[2] & B[2];\nassign and4 = A[3] & B[3];\n\n// Calculate the ORs\nassign or1 = and1 | and2 | and3;\nassign or2 = and2 & and3 | and1 & and3 | and1 & and2;\n\n// Calculate the sum and carry-out\nassign S = {xor3[2:0], xor2[1:0], xor1[0]};\nassign Cout = or1 | or2;\n\nendmodule\n",
        "module_name": "four_bit_adder",
        "module_hash": "31cdb2f8462430efcbd77321a7052fd2",
        "dataset_index": 17440
      },
      "shift_left_2_dff6adf6": {
        "rtl_code": "module shift_left_2 (\n    input [3:0] A,\n    output [3:0] X\n);\n\n    wire [3:0] shifted_left;\n    \n    // Shift left by 2 bits using bitwise logic gates\n    assign shifted_left[3] = A[1] & A[0];\n    assign shifted_left[2] = A[0] & (~A[1]);\n    assign shifted_left[1] = (~A[2]) & (~A[1]);\n    assign shifted_left[0] = (~A[3]) & (~A[2]);\n    \n    // Assign output\n    assign X = shifted_left;\n    \nendmodule",
        "module_name": "shift_left_2",
        "module_hash": "dff6adf629595a9189103e443b013342",
        "dataset_index": 16676
      }
    }
  },
  "created_at": "2025-11-06T14:41:06.876761"
}