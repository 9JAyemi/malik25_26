{"custom_id": "pipelined_4bit_adder_64d47a4c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipelined_4bit_adder (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input clk,\n    output signed [3:0] sum,\n    output carry_out\n);\n\nreg signed [3:0] stage1_sum;\nreg stage1_carry_out;\nreg signed [3:0] stage2_sum;\nreg stage2_carry_out;\n\nassign sum = stage2_sum;\nassign carry_out = stage2_carry_out;\n\nalways @(*) begin\n    stage1_sum = A + B;\n    stage1_carry_out = (A[3] & B[3]) | (A[3] & ~stage1_sum[3]) | (B[3] & ~stage1_sum[3]);\nend\n\nalways @(posedge clk) begin\n    stage2_sum <= stage1_sum;\n    stage2_carry_out <= stage1_carry_out;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cclk_detector #_9bc5a9c4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cclk_detector #(\n    parameter CLK_RATE = 50000000\n    )(\n    input clk,\n    input rst,\n    input cclk,\n    output ready\n);\n\n    parameter CTR_SIZE = $clog2(CLK_RATE/50000);\n\n    reg [CTR_SIZE-1:0] ctr_d, ctr_q;\n    reg ready_d, ready_q;\n\n    assign ready = ready_q;\n\n    always @(ctr_q or cclk) begin\n        ready_d = 1'b0;\n        if (cclk == 1'b0) begin ctr_d = 1'b0;\n        end else if (ctr_q != {CTR_SIZE{1'b1}}) begin\n            ctr_d = ctr_q + 1'b1; end else begin\n            ctr_d = ctr_q;\n            ready_d = 1'b1; end\n\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            ctr_q <= 1'b0;\n            ready_q <= 1'b0;\n        end else begin\n            ctr_q <= ctr_d;\n            ready_q <= ready_d;\n        end\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "twos_complement_adder_63797ff9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule twos_complement_adder (\n  input clk,\n  input reset,\n  input signed [3:0] A,\n  input signed [3:0] B,\n  output reg signed [4:0] C,\n  output reg overflow\n);\n\nreg signed [3:0] sum;\nreg carry;\n\nalways @(posedge clk, posedge reset) begin\n  if (reset) begin\n    sum <= 4'b0;\n    carry <= 1'b0;\n    C <= 5'b0;\n    overflow <= 1'b0;\n  end else begin\n    sum <= A + B + carry;\n    carry <= (sum[3] == 1);\n    C <= {carry, sum};\n    overflow <= ((A[3] == B[3]) && (A[3] != sum[3]));\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hi_iso14443a_9ce25c54", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule hi_iso14443a(\n    pck0, ck_1356meg, ck_1356megb,\n    pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4,\n    adc_d, adc_clk,\n    ssp_frame, ssp_din, ssp_dout, ssp_clk,\n    cross_hi, cross_lo,\n    dbg,\n    mod_type\n);\n    input pck0, ck_1356meg, ck_1356megb;\n    output pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4;\n    input [7:0] adc_d;\n    output adc_clk;\n    input ssp_dout;\n    output ssp_frame, ssp_din, ssp_clk;\n    input cross_hi, cross_lo;\n    output dbg;\n    input [2:0] mod_type;\n\nreg ssp_clk;\nreg ssp_frame;\n\nreg fc_div_2;\nalways @(posedge ck_1356meg)\n    fc_div_2 = ~fc_div_2;\n\nwire adc_clk;\nassign adc_clk = ck_1356meg;\n\nreg after_hysteresis, after_hysteresis_prev1, after_hysteresis_prev2, after_hysteresis_prev3;\nreg [11:0] has_been_low_for;\nreg [8:0] saw_deep_modulation;\nreg [2:0] deep_counter;\nreg deep_modulation;\nalways @(negedge adc_clk)\nbegin\n\tif(& adc_d[7:6]) after_hysteresis <= 1'b1;\t\t\telse if(~(| adc_d[7:4])) after_hysteresis <= 1'b0;  if(~(| adc_d[7:0]))\n\tbegin\n\t\tif(deep_counter == 3'd7)\n\t\tbegin\n\t\t\tdeep_modulation <= 1'b1;\n\t\t\tsaw_deep_modulation <= 8'd0;\n\t\tend\n\t\telse\n\t\t\tdeep_counter <= deep_counter + 1;\n\tend\n\telse\n\tbegin\n\t\tdeep_counter <= 3'd0;\n\t\tif(saw_deep_modulation == 8'd255)\n\t\t\tdeep_modulation <= 1'b0;\n\t\telse\n\t\t\tsaw_deep_modulation <= saw_deep_modulation + 1;\n\tend\n\t\n\tif(after_hysteresis)\n    begin\n        has_been_low_for <= 7'b0;\n    end\n    else\n    begin\n        if(has_been_low_for == 12'd4095)\n        begin\n            has_been_low_for <= 12'd0;\n            after_hysteresis <= 1'b1;\n        end\n        else\n            has_been_low_for <= has_been_low_for + 1;\n    end\nend\n\nreg [5:0] negedge_cnt;\nreg bit1, bit2, bit3;\nreg [3:0] count_ones;\nreg [3:0] count_zeros;\nreg [7:0] rx_mod_edge_threshold;\nreg curbit;\nreg [7:0] adc_d_1;\nreg [7:0] adc_d_2;\nreg [7:0] adc_d_3;\nreg [7:0] adc_d_4;\n\nwire signed [10:0] adc_d_filtered;\nassign adc_d_filtered = (adc_d_4 << 1) + adc_d_3 - adc_d_1 - (adc_d << 1);\n\nreg [7:0] rx_mod_falling_edge_max;\nreg [7:0] rx_mod_rising_edge_max;\n\nreg signed [7:0] to_arm;\n\n\nreg bit_to_arm;\nreg fdt_indicator, fdt_elapsed;\nreg [10:0] fdt_counter;\nreg [47:0] mod_sig_buf;\nwire mod_sig_buf_empty;\nreg [5:0] mod_sig_ptr;\nreg [3:0] mod_sig_flip;\nreg mod_sig, mod_sig_coil;\nreg temp_buffer_reset;\nreg sendbit;\n\nassign mod_sig_buf_empty = ~(|mod_sig_buf[47:0]);\nreg [2:0] ssp_frame_counter;\n\nalways @(negedge adc_clk)\nbegin\n\tif(fdt_counter == 11'd740) fdt_indicator = 1'b1; \tif(fdt_counter == 11'd1148) begin\n\t\tif(fdt_elapsed)\n\t\tbegin\n\t\t\tif(negedge_cnt[3:0] == mod_sig_flip[3:0]) mod_sig_coil <= mod_sig; end\n\t\telse\n\t\tbegin\n\t\t\tmod_sig_flip[3:0] <= negedge_cnt[3:0];\t\tmod_sig_coil <= mod_sig;\t\t\t\t\tfdt_elapsed = 1'b1;\n\t\t\tfdt_indicator = 1'b0;\n\n\t\t\tif(~(| mod_sig_ptr[5:0])) mod_sig_ptr <= 6'b001001;  \telse temp_buffer_reset = 1'b1; \t\t\t\t\t\t\tend\n\tend\n\telse\n\tbegin\n\t\tfdt_counter <= fdt_counter + 1; end\n\t\n\t\n\tif (adc_d_filtered > 0)\n\t\tbegin\n\t\tif (adc_d_filtered > rx_mod_falling_edge_max)\n\t\t\trx_mod_falling_edge_max <= adc_d_filtered;\n\t\tend\n\telse\n\t\tbegin\n\t\tif (-adc_d_filtered > rx_mod_rising_edge_max)\n\t\t\trx_mod_rising_edge_max <= -adc_d_filtered;\n\t\tend\n\t\t\n\tadc_d_4 <= adc_d_3;\n\tadc_d_3 <= adc_d_2;\n\tadc_d_2 <= adc_d_1;\n\tadc_d_1 <= adc_d;\n\n\t\t\n\n\tif(& negedge_cnt[3:0])  begin\n\t\tif(~after_hysteresis && mod_sig_buf_empty && ~((mod_type == 3'b100) || (mod_type == 3'b011) || (mod_type == 3'b010))) begin\n\t\t\tfdt_counter <= 11'd0;\n\t\t\tfdt_elapsed = 1'b0;\n\t\t\tfdt_indicator = 1'b0;\n\t\t\ttemp_buffer_reset = 1'b0;\n\t\t\tmod_sig_ptr <= 6'b000000;\n\t\tend\n\t\t\n\t\tif (rx_mod_falling_edge_max > 6 && rx_mod_rising_edge_max > 6)\n\t\t\t\tcurbit = 1'b1;\telse\n\t\t\t\tcurbit = 1'b0;\trx_mod_rising_edge_max <= 0;\n\t\trx_mod_falling_edge_max <= 0;\n\t\n\t\n\t\tif(mod_type == 3'b001) sendbit = after_hysteresis;\t\telse if(mod_type == 3'b010)\t\t\t\t\t\t\t\tbegin\n\t\t\tif(fdt_counter > 11'd772) sendbit = mod_sig_coil;\n\t\t\telse sendbit = fdt_indicator;\n\t\tend\n\t\telse if(mod_type == 3'b011) sendbit = curbit;\t\t\telse sendbit = 1'b0;\t\t\t\t\t\t\t\t\tend\n\n\tif(negedge_cnt == 7'd63)\n    begin\n\t\tif(deep_modulation)\n\t\tbegin\n\t\t\tto_arm <= {after_hysteresis_prev1,after_hysteresis_prev2,after_hysteresis_prev3,after_hysteresis,1'b0,1'b0,1'b0,1'b0};\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tto_arm <= {after_hysteresis_prev1,after_hysteresis_prev2,after_hysteresis_prev3,after_hysteresis,bit1,bit2,bit3,curbit};\n\t\tend\n\n        negedge_cnt <= 0;\n\t\n\tend\n    else\n    begin\n        negedge_cnt <= negedge_cnt + 1;\n    end\n\n    if(negedge_cnt == 6'd15)\n\tbegin\n        after_hysteresis_prev1 <= after_hysteresis;\n\t\tbit1 <= curbit;\n\tend\n    if(negedge_cnt == 6'd31)\n\tbegin\n        after_hysteresis_prev2 <= after_hysteresis;\n\t\tbit2 <= curbit;\n\tend\n    if(negedge_cnt == 6'd47)\n\tbegin\n        after_hysteresis_prev3 <= after_hysteresis;\n\t\tbit3 <= curbit;\n\tend\n\t\n\tif(mod_type != 3'b000)\t\t\tbegin\n\t\tif(negedge_cnt[3:0] == 4'b1000) begin\n\t\t\tmod_sig_buf[47:0] <= {mod_sig_buf[46:1], ssp_dout, 1'b0};  \t\t\tif((ssp_dout || (| mod_sig_ptr[5:0])) && ~fdt_elapsed)\t\t\t\tif(mod_sig_ptr == 6'b101110)\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\tmod_sig_ptr <= 6'b000000;\n\t\t\t\tend\n\t\t\t\telse mod_sig_ptr <= mod_sig_ptr + 1;\t\t\t\t\t\t\telse if(fdt_elapsed && ~temp_buffer_reset)\t\t\t\t\t\t\t\n\t\t\tbegin\n\t\t\t\tif(ssp_dout) temp_buffer_reset = 1'b1;\t\t\t\t\t\t\t\n\t\t\t\tif(mod_sig_ptr == 6'b000010) mod_sig_ptr <= 6'b001001;\t\t\telse mod_sig_ptr <= mod_sig_ptr - 1;\t\t\t\t\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(~mod_sig_buf[mod_sig_ptr-1] && ~mod_sig_buf[mod_sig_ptr+1]) mod_sig = 1'b0;\n\t\t\t\telse mod_sig = mod_sig_buf[mod_sig_ptr] & fdt_elapsed;\n\t\t\tend\n\t\tend\n\tend\n\t\n\tif(mod_type == 3'b000)\n\tbegin\n\t\tif(negedge_cnt[2:0] == 3'b100)\n\t\t\tssp_clk <= 1'b0;\n\t\t\t\n\t\tif(negedge_cnt[2:0] == 3'b000)\n\t\tbegin\n\t\t\tssp_clk <= 1'b1;\n\t\t\tif(negedge_cnt != 7'd0)\n\t\t\tbegin\n\t\t\t\tto_arm[7:1] <= to_arm[6:0];\n\t\t\tend\n\t\tend\n\n\t\tif(negedge_cnt[5:4] == 2'b00)\n\t\t\tssp_frame = 1'b1;\n\t\telse\n\t\t\tssp_frame = 1'b0;\n\t\t\n\t\tbit_to_arm = to_arm[7];\n\tend\n\telse\n\tbegin\n\t\tif(negedge_cnt[3:0] == 4'b1000) ssp_clk <= 1'b0;\n\n\t\tif(negedge_cnt[3:0] == 4'b0111)\n\t\tbegin\n\t\t\tif(ssp_frame_counter == 3'd7) ssp_frame_counter <= 3'd0;\n\t\t\telse ssp_frame_counter <= ssp_frame_counter + 1;\n\t\tend\n\n\t\tif(negedge_cnt[3:0] == 4'b0000)\n\t\tbegin\n\t\t\tssp_clk <= 1'b1;\n\t\tend\n\t\t\n\t\tssp_frame = (ssp_frame_counter == 3'd7);\n\t\n\t\tbit_to_arm = sendbit;\n\tend\n\t\nend\n\nassign ssp_din = bit_to_arm;\n\n\nwire modulating_carrier;\nassign modulating_carrier = (mod_sig_coil & negedge_cnt[3] & (mod_type == 3'b010));\t\t\t\t\tassign pwr_hi = (ck_1356megb & (((mod_type == 3'b100) & ~mod_sig_coil) || (mod_type == 3'b011)));\t\n\n\nassign pwr_oe1 = 1'b0;\nassign pwr_oe3 = 1'b0;\n\nassign pwr_oe4 = modulating_carrier;\n\nassign pwr_oe2 = 1'b0;\nassign pwr_lo = 1'b0;\n\n\nassign dbg = negedge_cnt[3];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_gate_21c582a2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_gate (\n    input A,\n    input B,\n    output X\n);\n\n    assign X = A ^ B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_5ebde6c8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__ceea9704", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (\n    input clk,\n    input reset,\n    output reg [3:0] output1,\n    output reg [3:0] output2\n);\n\n    wire VPWR;\n    wire VGND;\n    //sky130_fd_sc_hs__tapvgnd my_tapvgnd (\n    //    .VPWR(VPWR),\n    //    .VGND(VGND)\n    //);\n\n    integer count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    always @* begin\n        output1 = count;\n        output2 = ~count;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "profibus_master_c9e9f911", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule profibus_master (\n  input clk,\n  input reset,\n  input tx_en,\n  input [7:0] tx_data,\n  output tx_busy,\n  output reg tx_complete,\n  output reg [7:0] rx_data,\n  input rx_complete,\n  output reg rx_en = 0\n);\n\n  // Define states for the state machine\n  parameter IDLE = 0;\n  parameter TX_START = 1;\n  parameter TX_DATA = 2;\n  parameter RX_START = 3;\n  parameter RX_DATA = 4;\n\n  // Define variables for the state machine\n  reg [2:0] state = IDLE;\n  reg [7:0] tx_buffer;\n  reg [7:0] rx_buffer;\n  reg tx_busy_int = 0;\n  reg rx_en_int = 0;\n\n  // Define timing parameters\n  parameter BIT_TIME = 10; // 10 clock cycles per bit\n  parameter START_DELAY = 5; // 5 bit times before start bit\n  parameter STOP_DELAY = 2; // 2 bit times after stop bit\n\n  // Define counter for timing\n  reg [3:0] bit_counter = 0;\n\n  // Define output signals\n  assign tx_busy = tx_busy_int;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      tx_busy_int <= 0;\n      tx_complete <= 0;\n      rx_data <= 0;\n      bit_counter <= 0;\n    end\n    else begin\n      case (state)\n        IDLE: begin\n          if (tx_en) begin\n            tx_buffer <= tx_data;\n            tx_busy_int <= 1;\n            state <= TX_START;\n          end\n          else if (rx_complete) begin\n            rx_data <= rx_buffer;\n          end\n        end\n        TX_START: begin\n          if (bit_counter == 0) begin\n            rx_en_int <= 1;\n          end\n          else if (bit_counter == START_DELAY) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            state <= TX_DATA;\n          end\n        end\n        TX_DATA: begin\n          if (bit_counter == 0) begin\n            rx_en_int <= 1;\n            tx_buffer <= {1'b0, tx_buffer[7:1]};\n            bit_counter <= 1;\n          end\n          else if (bit_counter == BIT_TIME) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            if (tx_buffer == 0) begin\n              state <= RX_START;\n            end\n            else begin\n              state <= TX_DATA;\n            end\n          end\n        end\n        RX_START: begin\n          if (bit_counter == 0) begin\n            rx_en_int <= 1;\n          end\n          else if (bit_counter == START_DELAY) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            state <= RX_DATA;\n          end\n        end\n        RX_DATA: begin\n          if (bit_counter == 0) begin\n            rx_buffer <= {rx_buffer[6:0], rx_en_int};\n            bit_counter <= 1;\n          end\n          else if (bit_counter == BIT_TIME) begin\n            rx_en_int <= 0;\n            bit_counter <= 0;\n            if (rx_buffer[7]) begin\n              rx_en_int <= 0;\n              state <= IDLE;\n            end\n            else begin\n              state <= RX_DATA;\n            end\n          end\n        end\n      endcase\n      if (tx_busy_int && state == IDLE) begin\n        tx_busy_int <= 0;\n        tx_complete <= 1;\n      end\n      bit_counter <= bit_counter + 1;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wire_recorder_b5c506d7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wire_recorder(\n    input wire clk,\n    input wire reset,\n    input wire [156:0] input_vector,\n    input wire [129:0] output_vector,\n    output reg [156:0] input_vector_reg,\n    output reg [129:0] output_vector_reg,\n    output reg clk_start\n);\n\n\nalways @(posedge clk) begin\n    if(reset) begin\n        input_vector_reg <= 0;\n        output_vector_reg <= 0;\n        clk_start <= 1'b0;\n    end else begin\n        input_vector_reg <= input_vector;\n        output_vector_reg <= output_vector;\n        clk_start <= (output_vector_reg[0] == 1'b1) ? 1'b1 : clk_start; \n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_d39fbdb5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_4to1(\n    input a,\n    input b,\n    input c,\n    input d,\n    input sel_1,\n    input sel_0,\n    output reg out_always\n);\n\nalways @(*) begin\n    if(sel_1 == 0 && sel_0 == 0) begin\n        out_always = a;\n    end\n    else if(sel_1 == 0 && sel_0 == 1) begin\n        out_always = b;\n    end\n    else if(sel_1 == 1 && sel_0 == 0) begin\n        out_always = c;\n    end\n    else begin\n        out_always = d;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__nand4_a618fc4a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, D, C, B, A     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_counter_6b5b551e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_counter(\n    input clk,\n    input reset_n,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__ac010738", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] a, b, c, d,     // Input ports for the minimum circuit\n    input wire [7:0] in_hi,          // Input port for the combinational circuit\n    input wire [7:0] in_lo,          // Input port for the combinational circuit\n    input wire select,               // Select input to choose between the two given modules\n    output wire [7:0] min_out,       // Output port from the minimum circuit\n    output wire [15:0] comb_out,     // Output port from the combinational circuit\n    output wire [15:0] final_out     // Final output from the functional module\n);\n\n// Instantiate the minimum circuit module\nminimum_circuit min_circuit(\n    .a(a),\n    .b(b),\n    .c(c),\n    .d(d),\n    .out(min_out)\n);\n\n// Instantiate the combinational circuit module\ncombinational_circuit comb_circuit(\n    .in_hi(in_hi),\n    .in_lo(in_lo),\n    .out(comb_out)\n);\n\n// Instantiate the addictive control logic module\nadditive_control_logic add_control(\n    .select(select),\n    .min_out(min_out),\n    .comb_out(comb_out),\n    .final_out(final_out)\n);\n\nendmodule\n\n// Define the minimum circuit module\nmodule minimum_circuit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire [7:0] c,\n    input wire [7:0] d,\n    output wire [7:0] out\n);\n\n// Find the minimum value of the four input values\nassign out = (a < b) ? ((a < c) ? ((a < d) ? a : d) : ((c < d) ? c : d)) : ((b < c) ? ((b < d) ? b : d) : ((c < d) ? c : d));\n\nendmodule\n\n// Define the combinational circuit module\nmodule combinational_circuit (\n    input wire [7:0] in_hi,\n    input wire [7:0] in_lo,\n    output wire [15:0] out\n);\n\n// Combine the two input bytes into a half-word\nassign out = {in_hi, in_lo};\n\nendmodule\n\n// Define the addictive control logic module\nmodule additive_control_logic (\n    input wire select,\n    input wire [7:0] min_out,\n    input wire [15:0] comb_out,\n    output wire [15:0] final_out\n);\n\n// Choose between the two given modules based on the select input and compute the final output\nassign final_out = (select == 1'b0) ? (min_out + comb_out) : (min_out - comb_out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_cbbf1b38", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_encoder (\n  input clk, rst,\n  input [3:0] in,\n  output reg [1:0] out\n);\n\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      out <= 2'b00;\n    end else begin\n      casez(in)\n        4'b0001: out <= 2'b00;\n        4'b0010: out <= 2'b01;\n        4'b0100: out <= 2'b10;\n        4'b1000: out <= 2'b11;\n        default: out <= 2'b00;\n      endcase\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rca_top_0e911f0c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rca_top(\n    output reg [15:0] final_output,\n    output reg carry_output,\n    input [15:0]input1, input2\n    );\n\nreg carry_in;\t\ttask CRAFA_module(\n    output reg sum,carry,\n    input in1,in2,carry_in\n    );\n\nreg intermediate, gen, propagate;\nbegin\npropagate = in1 ^ in2;\nsum = propagate ^ carry_in;\ngen = in1 & in2;\nintermediate = propagate & carry_in;\ncarry = intermediate | gen;\nend\nendtask\n\ntask CRA4bit(\n    output reg [3:0] cra_sum,\n    output reg cra_carry_out,\n    input [3:0] in1,in2,\n    input carry_in\n    );\nreg carry1,carry2,carry3;\nbegin\nCRAFA_module \t(cra_sum[0],carry1,in1[0],in2[0],carry_in);\nCRAFA_module\t(cra_sum[1],carry2,in1[1],in2[1],carry1);\nCRAFA_module\t(cra_sum[2],carry3,in1[2],in2[2],carry2);\nCRAFA_module\t(cra_sum[3],cra_carry_out,in1[3],in2[3],carry3);\nend\nendtask\n\t \t \ntask CRA16bit(\n    output reg [15:0] cra_sum,\n    output reg cra_carry_out,\n    input [15:0] in1,in2,\n    input carry_in\n    );\nreg carry1,carry2,carry3;\nbegin\nCRA4bit\t(cra_sum[3:0],carry1,in1[3:0],in2[3:0],carry_in);\nCRA4bit\t(cra_sum[7:4],carry2,in1[7:4],in2[7:4],carry1);\nCRA4bit\t(cra_sum[11:8],carry3,in1[11:8],in2[11:8],carry2);\nCRA4bit\t(cra_sum[15:12],cra_carry_out,in1[15:12],in2[15:12],carry3);\nend\nendtask\n\nalways@*\nbegin\n\tcarry_in = 1'b0;\n\tCRA16bit(final_output, carry_output, input1, input2, carry_in);\n\nend\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_16bit_df34a5b6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter_16bit (\n    input [15:0] data,\n    input [3:0] shift_amount,\n    output reg [15:0] out\n);\n\nreg [15:0] stage1_out;\nreg [15:0] stage2_out;\n\nalways @(*) begin\n    stage1_out = (shift_amount[3]) ? data << 8 : data;\nend\n\nalways @(*) begin\n    stage2_out = (shift_amount[2]) ? stage1_out << 4 : stage1_out;\nend\n\nalways @(*) begin\n    out = (shift_amount[1]) ? stage2_out << 2 : stage2_out;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__nor2_4cf1203e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__nor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B           );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "opModule_fef43f1c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule opModule (clk, iA, iB, iC, oResult);\n    input clk;\n    input [3:0] iA;\n    input [3:0] iB;\n    input iC;\n    output [3:0] oResult;\n\n    reg [3:0] oResult_reg; // Declare oResult as a register\n\n    always @(posedge clk) begin\n        if (iC == 0) begin\n            oResult_reg <= iA & iB;\n        end else begin\n            oResult_reg <= iA | iB;\n        end\n    end\n\n    assign oResult = oResult_reg; // Assign the value of oResult_reg to oResult\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand_gate_5d2340e8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand_gate (\n    input A,\n    input B,\n    output X\n);\n\n    assign X = ~(A & B);\n\nendmodule\n\nmodule and_gate (\n    input A,\n    input B,\n    output X\n);\n\n    wire nand1_out;\n    wire nand2_out;\n\n    nand_gate nand1(.A(A), .B(A), .X(nand1_out));\n    nand_gate nand2(.A(B), .B(B), .X(nand2_out));\n    nand_gate nand3(.A(nand1_out), .B(nand2_out), .X(X));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W32_0_7_8f1b8548", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule SNPS_CLOCK_GATE_HIGH_RegisterAdd_W32_0_7 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  wire E, SE, CK, ECK;\n\n  assign E = TE;\n  assign SE = EN;\n  assign CK = CLK;\n  assign ENCLK = EN ? ECK : 1'b0;\n\n  TLATNTSCAX2TS latch ( .E(E), .SE(SE), .CK(CK), .ECK(ECK) );\n\nendmodule\n\nmodule TLATNTSCAX2TS ( E, SE, CK, ECK );\n  input E, SE, CK;\n  output reg ECK;\n\n  always @(posedge CK) begin\n    if (SE) ECK <= E;\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__3639af79", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [1:0] decoder_in,\n    input [3:0] alu_A,\n    input [3:0] alu_B,\n    input [2:0] alu_OP,\n    output reg [3:0] final_output\n);\n\n    wire [3:0] alu_output;\n    wire [3:0] decoder_out;\n\n    decoder_2to4 decoder(\n        .in(decoder_in),\n        .out(decoder_out)\n    );\n\n    alu_4bit alu(\n        .A(alu_A),\n        .B(alu_B),\n        .OP(alu_OP),\n        .out(alu_output)\n    );\n\n    always @(*) begin\n        case(decoder_out)\n            4'b0001: final_output = alu_output[0];\n            4'b0010: final_output = alu_output[1];\n            4'b0100: final_output = alu_output[2];\n            4'b1000: final_output = alu_output[3];\n            default: final_output = 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule decoder_2to4 (\n    input [1:0] in,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(in)\n            2'b00: out = 4'b0001;\n            2'b01: out = 4'b0010;\n            2'b10: out = 4'b0100;\n            2'b11: out = 4'b1000;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule alu_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] OP,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(OP)\n            3'b000: out = A + B;\n            3'b001: out = A - B;\n            3'b010: out = A & B;\n            3'b011: out = A | B;\n            3'b100: out = A ^ B;\n            3'b101: out = ~A;\n            3'b110: out = ~B;\n            3'b111: out = 4'b0000;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ring_counter #_545356dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ring_counter #(\n  parameter n = 4 // number of output signals\n)(\n  input clk,\n  output [n-1:0] out\n);\n\nreg [n-1:0] counter;\n\nalways @(posedge clk) begin\n  counter <= {counter[n-2:0], counter[n-1]};\nend\n\nassign out = counter;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "exercise_8_10_8aa4c0cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule exercise_8_10 (output reg [1:0] state, input x, y, Clk);\n    initial state = 2'b00;\n    always @ (posedge Clk) begin\n        case ({x,y})\n            2'b00: begin if (state == 2'b00) state <= state; \n                else if (state == 2'b01) state <= 2'b10; \n                else if (state == 2'b10) state <= 2'b00; \n                else state <= 2'b10;\n                end\n            2'b01: begin if (state == 2'b00) state <= state;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b00;\n                    else state <= state;\n                    end\n            2'b10: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b10;\n                    else if (state == 2'b10) state <= state;\n                    else state <= 2'b00;\n                    end\n            2'b11: begin if (state == 2'b00) state <= 2'b01;\n                    else if (state == 2'b01) state <= 2'b11;\n                    else if (state == 2'b10) state <= 2'b11;\n                    else state <= 2'b00;\n                    end\n        endcase\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "r_DEVICE_CAPABILITIES_2_HIGH_4aec6f44", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule r_DEVICE_CAPABILITIES_2_HIGH(output reg [7:0] reg_0x2A, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk, input wire select);\n\treg [7:0] reg_0x25;\n\t\n\tr_DEVICE_CAPABILITIES_1_HIGH r_device_capabilities_1_high_inst( .reg_0x25(reg_0x25), .reset(reset), .wenb(wenb), .in_data(in_data), .clk(clk));\n\t\n\talways@(posedge clk)\n\tbegin\n\t\tif(reset==1)\n\t\t\treg_0x2A<=8'h00;\n\t\telse if(select==0)\n\t\tbegin\n\t\t\tif(wenb==0)\n\t\t\t\treg_0x2A<=in_data;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(wenb==0)\n\t\t\t\treg_0x2A<=reg_0x25;\n\t\tend\n\tend\nendmodule\nmodule r_DEVICE_CAPABILITIES_1_HIGH(output reg [7:0] reg_0x25, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n\n\talways@(posedge clk)\n\tbegin\n\t\tif(reset==1)\n\t\t\treg_0x25<=8'h00;\n\t\telse if(wenb==0)\n\t\t\treg_0x25<=in_data;\n\tend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signal_combiner_04e0bd74", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule signal_combiner (\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  B2  ,\n    input  C1  ,\n    output Y   ,\n    input  VPWR,\n    input  VGND\n);\n\n    assign Y = (A1 & A2) | (B1 & B2) | C1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "chatgpt_generate_edge_detect_5981dd4d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule chatgpt_generate_edge_detect(\n  input               clk,\n  input               rst_n,\n  input               a,\n  input               select,\n  output reg          rise,\n  output reg          fall\n);\n\n  // State definitions\n  parameter IDLE = 2'b00;\n  parameter RISE_DETECT = 2'b01;\n  parameter FALL_DETECT = 2'b10;\n\n  // State register and next state logic\n  reg [1:0] state, next_state;\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Output register and logic\n  reg active_edge;\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      active_edge <= 1'b0;\n    end else begin\n      case (state)\n        IDLE: begin\n          active_edge <= 1'b0;\n        end\n        RISE_DETECT: begin\n          active_edge <= 1'b1;\n        end\n        FALL_DETECT: begin\n          active_edge <= 1'b0;\n        end\n      endcase\n    end\n  end\n\n  // State transition logic\n  always @(*) begin\n    case (state)\n      IDLE: begin\n        if (select) begin\n          if (a) begin\n            next_state = RISE_DETECT;\n          end else begin\n            next_state = FALL_DETECT;\n          end\n        end else begin\n          next_state = IDLE;\n        end\n      end\n      RISE_DETECT: begin\n        if (~a) begin\n          next_state = IDLE;\n        end else begin\n          next_state = RISE_DETECT;\n        end\n      end\n      FALL_DETECT: begin\n        if (a) begin\n          next_state = IDLE;\n        end else begin\n          next_state = FALL_DETECT;\n        end\n      end\n    endcase\n  end\n\n  // Output logic\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      rise <= 1'b0;\n      fall <= 1'b0;\n    end else begin\n      case (state)\n        IDLE: begin\n          rise <= 1'b0;\n          fall <= 1'b0;\n        end\n        RISE_DETECT: begin\n          rise <= 1'b1;\n          fall <= 1'b0;\n        end\n        FALL_DETECT: begin\n          rise <= 1'b0;\n          fall <= 1'b1;\n        end\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_f76a5b6b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] opcode,\n    output reg [3:0] result\n);\n\nalways @(*) begin\n    case(opcode)\n        2'b00: result = A + B;\n        2'b01: result = A - B;\n        2'b10: result = A * B;\n        2'b11: result = A / B;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_117f4c8f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux4to1(\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            2'b00: out = in0;\n            2'b01: out = in1;\n            2'b10: out = in1;  // Fix the issue here: changing 2'b10 to 2'b11\n            2'b11: out = in1;\n        endcase\n    end\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xcvr_ctrl_883c0c8c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n`resetall\n\n\n\n\nmodule xcvr_ctrl (\n    input  wire        reconfig_clk,\n    input  wire        reconfig_rst,\n\n    input  wire        pll_locked_in,\n\n    output wire [18:0] xcvr_reconfig_address,\n    output wire        xcvr_reconfig_read,\n    output wire        xcvr_reconfig_write,\n    input  wire [7:0]  xcvr_reconfig_readdata,\n    output wire [7:0]  xcvr_reconfig_writedata,\n    input  wire        xcvr_reconfig_waitrequest\n);\n\nlocalparam [3:0]\n    STATE_IDLE = 4'd0,\n    STATE_LOAD_PMA_1 = 4'd1,\n    STATE_LOAD_PMA_2 = 4'd2,\n    STATE_INIT_ADAPT_1 = 4'd3,\n    STATE_INIT_ADAPT_2 = 4'd4,\n    STATE_INIT_ADAPT_3 = 4'd5,\n    STATE_INIT_ADAPT_4 = 4'd6,\n    STATE_CONT_ADAPT_1 = 4'd7,\n    STATE_CONT_ADAPT_2 = 4'd8,\n    STATE_CONT_ADAPT_3 = 4'd9,\n    STATE_CONT_ADAPT_4 = 4'd10,\n    STATE_DONE = 4'd11;\n\nreg [3:0] state_reg = STATE_IDLE, state_next;\n\nreg [18:0] xcvr_reconfig_address_reg = 19'd0, xcvr_reconfig_address_next;\nreg xcvr_reconfig_read_reg = 1'b0, xcvr_reconfig_read_next;\nreg xcvr_reconfig_write_reg = 1'b0, xcvr_reconfig_write_next;\nreg [7:0] xcvr_reconfig_writedata_reg = 8'd0, xcvr_reconfig_writedata_next;\n\nreg [7:0] read_data_reg = 8'd0, read_data_next;\nreg read_data_valid_reg = 1'b0, read_data_valid_next;\n\nreg [15:0] delay_count_reg = 0, delay_count_next;\n\nreg pll_locked_sync_1_reg = 0;\nreg pll_locked_sync_2_reg = 0;\nreg pll_locked_sync_3_reg = 0;\n\nassign xcvr_reconfig_address = xcvr_reconfig_address_reg;\nassign xcvr_reconfig_read = xcvr_reconfig_read_reg;\nassign xcvr_reconfig_write = xcvr_reconfig_write_reg;\nassign xcvr_reconfig_writedata = xcvr_reconfig_writedata_reg;\n\nalways @(posedge reconfig_clk) begin\n    pll_locked_sync_1_reg <= pll_locked_in;\n    pll_locked_sync_2_reg <= pll_locked_sync_1_reg;\n    pll_locked_sync_3_reg <= pll_locked_sync_2_reg;\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    xcvr_reconfig_address_next = xcvr_reconfig_address_reg;\n    xcvr_reconfig_read_next = 1'b0;\n    xcvr_reconfig_write_next = 1'b0;\n    xcvr_reconfig_writedata_next = xcvr_reconfig_writedata_reg;\n\n    read_data_next = read_data_reg;\n    read_data_valid_next = read_data_valid_reg;\n\n    delay_count_next = delay_count_reg;\n\n    if (xcvr_reconfig_read_reg || xcvr_reconfig_write_reg) begin\n        if (xcvr_reconfig_waitrequest) begin\n            xcvr_reconfig_read_next = xcvr_reconfig_read_reg;\n            xcvr_reconfig_write_next = xcvr_reconfig_write_reg;\n        end else begin\n            xcvr_reconfig_read_next = 1'b0;\n            xcvr_reconfig_write_next = 1'b0;\n\n            if (xcvr_reconfig_read_reg) begin\n                read_data_next = xcvr_reconfig_readdata;\n                read_data_valid_next = 1'b1;\n            end\n        end\n        state_next = state_reg;\n    end else if (delay_count_reg != 0) begin\n        delay_count_next = delay_count_reg - 1;\n        state_next = state_reg;\n    end else begin\n        read_data_valid_next = 1'b0;\n\n        case (state_reg)\n            STATE_IDLE: begin\n                if (pll_locked_sync_3_reg) begin\n                    delay_count_next = 16'hffff;\n                    state_next = STATE_LOAD_PMA_1;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_LOAD_PMA_1: begin\n                xcvr_reconfig_address_next = 19'h40143;\n                xcvr_reconfig_writedata_next = 8'h80;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_LOAD_PMA_2;\n            end\n            STATE_LOAD_PMA_2: begin\n                if (read_data_valid_reg && read_data_reg[0]) begin\n                    xcvr_reconfig_address_next = 19'h200;\n                    xcvr_reconfig_writedata_next = 8'hD2;\n                    xcvr_reconfig_write_next = 1'b1;\n                    state_next = STATE_INIT_ADAPT_1;\n                end else begin\n                    xcvr_reconfig_address_next = 19'h40144;\n                    xcvr_reconfig_read_next = 1'b1;\n                    state_next = STATE_LOAD_PMA_2;\n                end\n            end\n            STATE_INIT_ADAPT_1: begin\n                xcvr_reconfig_address_next = 19'h201;\n                xcvr_reconfig_writedata_next = 8'h02;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_INIT_ADAPT_2;\n            end\n            STATE_INIT_ADAPT_2: begin\n                xcvr_reconfig_address_next = 19'h202;\n                xcvr_reconfig_writedata_next = 8'h01;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_INIT_ADAPT_3;\n            end\n            STATE_INIT_ADAPT_3: begin\n                xcvr_reconfig_address_next = 19'h203;\n                xcvr_reconfig_writedata_next = 8'h96;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_INIT_ADAPT_4;\n            end\n            STATE_INIT_ADAPT_4: begin\n                if (read_data_valid_reg && read_data_reg == 8'h80) begin\n                    xcvr_reconfig_address_next = 19'h200;\n                    xcvr_reconfig_writedata_next = 8'hF6;\n                    xcvr_reconfig_write_next = 1'b1;\n                    state_next = STATE_CONT_ADAPT_1;\n                end else begin\n                    xcvr_reconfig_address_next = 19'h207;\n                    xcvr_reconfig_read_next = 1'b1;\n                    state_next = STATE_INIT_ADAPT_4;\n                end\n            end\n            STATE_CONT_ADAPT_1: begin\n                xcvr_reconfig_address_next = 19'h201;\n                xcvr_reconfig_writedata_next = 8'h01;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_CONT_ADAPT_2;\n            end\n            STATE_CONT_ADAPT_2: begin\n                xcvr_reconfig_address_next = 19'h202;\n                xcvr_reconfig_writedata_next = 8'h03;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_CONT_ADAPT_3;\n            end\n            STATE_CONT_ADAPT_3: begin\n                xcvr_reconfig_address_next = 19'h203;\n                xcvr_reconfig_writedata_next = 8'h96;\n                xcvr_reconfig_write_next = 1'b1;\n                state_next = STATE_CONT_ADAPT_4;\n            end\n            STATE_CONT_ADAPT_4: begin\n                if (read_data_valid_reg && read_data_reg == 8'h80) begin\n                    state_next = STATE_DONE;\n                end else begin\n                    xcvr_reconfig_address_next = 19'h207;\n                    xcvr_reconfig_read_next = 1'b1;\n                    state_next = STATE_CONT_ADAPT_4;\n                end\n            end\n            STATE_DONE: begin\n                state_next = STATE_DONE;\n            end\n        endcase\n    end\n\n    if (!pll_locked_sync_3_reg) begin\n        state_next = STATE_IDLE;\n    end\nend\n\nalways @(posedge reconfig_clk) begin\n    state_reg <= state_next;\n\n    xcvr_reconfig_address_reg <= xcvr_reconfig_address_next;\n    xcvr_reconfig_read_reg <= xcvr_reconfig_read_next;\n    xcvr_reconfig_write_reg <= xcvr_reconfig_write_next;\n    xcvr_reconfig_writedata_reg <= xcvr_reconfig_writedata_next;\n\n    read_data_reg <= read_data_next;\n    read_data_valid_reg <= read_data_valid_next;\n\n    delay_count_reg <= delay_count_next;\n\n    if (reconfig_rst) begin\n        state_reg <= STATE_IDLE;\n\n        xcvr_reconfig_read_reg <= 1'b0;\n        xcvr_reconfig_write_reg <= 1'b0;\n\n        read_data_valid_reg <= 1'b0;\n\n        delay_count_reg <= 0;\n    end\nend\n\nendmodule\n\n`resetall\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unknown_module_3d3ce9be", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule\tanteconmutador\t(\n\t\t\t\t\tinput\t\t\tclk,\n\t\t\t\t\tinput\t\t[7:0]\tcount,\n\t\t\t\t\tinput\t\t\tcalculate,\n\t\t\t\t\toutput\treg\t[3:0]\tcentenas,\n\t\t\t\t\toutput\treg\t[3:0]\tdecenas,\n\t\t\t\t\toutput\treg\t[3:0]\tunidades,\n\t\t\t\t\toutput\treg\t\tC,\n\t\t\t\t\toutput\treg\t\tDe,\n\t\t\t\t\toutput\treg\t\tU\n\t\t\t);\n\treg\t[7:0]\tdigitT;\n\treg\t\ti;\n\t\n\tinitial\n\tbegin\n\t\tdigitT = 0;\n\t\tC = 0;\n\t\tDe = 0;\n\t\tU = 0;\n\t\tcentenas = 0;\n\t\tdecenas\t = 0;\n\t\tunidades = 0;\n\t\ti = 1;\n\tend\n\talways@(posedge clk)\n\tbegin\t\n\t\tif(calculate)\n\t\tbegin\n\t\t\tif(i)\n\t\t\tbegin\n\t\t\t\tdigitT = count;\n\t\t\t\ti = 0;\n\t\t\tend\n\t\t\tif(digitT>7'b1100011)\n\t\t\tbegin\n\t\t\t\tdigitT\t = digitT - 7'b1100100;\n\t\t\t\tcentenas = centenas + 1;\n\t\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(digitT>7'b0001001)\n\t\t\t\tbegin\n\t\t\t\t\tdigitT\t= digitT - 7'b0001010;\n\t\t\t\t\tdecenas\t= decenas + 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tunidades = {digitT[3:0]};\n\t\t\t\t\tif(centenas >= 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tC = 1;\n\t\t\t\t\tend\n\t\t\t\t\tif(decenas  >= 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tDe = 1;\n\t\t\t\t\tend\n\t\t\t\t\tif(unidades >= 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tU = 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(!calculate)\n\t\t\tbegin\n\t\t\t\tdigitT = 0;\n\t\t\t\tC = 0;\n\t\t\t\tDe = 0;\n\t\t\t\tU = 0;\n\t\t\t\ti = 1;\n\t\t\t\tcentenas = 0;\n\t\t\t\tdecenas\t = 0;\n\t\t\t\tunidades = 0;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "soc_design_SystemID_c0166723", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule soc_design_SystemID (\n  input [31:0] address,\n  input clock,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  always @(posedge clock) begin\n    if (!reset_n) begin\n      readdata <= 32'h00000000;\n    end else begin\n      case (address)\n        32'h0: readdata <= 32'hDEADBEEF;\n        32'h4: readdata <= 32'hCAFEBABE;\n        default: readdata <= 32'h00000000;\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_control_6858bd69", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_control(\n    input inclk,\n    input ena,\n    output outclk\n);\n\nreg [1:0] state;\nreg filtered_clk;\n\nalways @(posedge inclk) begin\n    if (ena) begin\n        state <= {state[0], inclk};\n        if (state == 2'b01) begin\n            filtered_clk <= 1'b1;\n        end else if (state == 2'b10) begin\n            filtered_clk <= 1'b0;\n        end\n    end else begin\n        filtered_clk <= 1'b0;\n    end\nend\n\nassign outclk = filtered_clk;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "control_ascci_7e7dd4ab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule control_ascci(\n\tinput clk,\n\tinput top_ascci,\n\tinput top_col,\n\tinput new_string,\n\tinput done,\n\toutput reg add_dirram,\n\toutput reg reset_dirram,\n\toutput reg add_col,\n   \toutput reg reset_col,\n\toutput reg add_ascci,\n\toutput reg reset_ascci,\n\toutput reg init,\n\toutput reg leer_rom,\n\toutput reg leer_ram,\t\n\toutput reg run_efect );\n\treg [6:0] current_state;\n\treg [6:0] next_state;\n\t\n\tparameter start=7'b0000000, state_1=7'b0000001, state_2=7'b0000010, state_3=7'b0000011, state_4=7'b0000100, state_5=7'b0000101,check=7'b0000110,state_1p=7'b0000111; \n\n\talways @(top_ascci or done or top_col  or new_string or current_state)begin\n\t\tcase(current_state)\n     \t\tstart: \tbegin\t\t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b1;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b1;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\t\n\t\t\t\t\t\t\t\tleer_ram=1'b1;\n\n\t\t\t\t\t\t\t\tinit=0;    run_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif (new_string==1'b1 ) next_state<=state_1p;\n\t\t\t\t\t\telse next_state<=start;\n\t\t\t\t\tend\n\t\t\tstate_1p:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b1;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=1;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext_state<=state_1;\n\t\t\t\t\tend\n\t\t\tstate_1:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=1;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext_state<=state_2;\n\t\t\t\t\tend\n\t\t\tstate_2:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif(done==1'b1) next_state<=state_3;\n\t\t\t\t\telse next_state<=state_2;\n\t\t\t\t\tend\n\t\t\t\n\t\t\tstate_3:\tbegin \t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\n\t\t\t\t\t\tnext_state<=state_4;\n\t\t\t\t\tend\n\t\t\tstate_4:\tbegin\t\tadd_dirram=1'b1;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b1;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b1;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif (top_col == 1'b1) next_state<=state_5;\n\t\t\t\t\t\telse next_state<=state_3;\n\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\tstate_5:\tbegin\t\tadd_dirram=1'b1;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b1;\n\t\t\t\t\t\t\t\tadd_ascci=1'b1;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tif (top_ascci==1'b1)next_state<=check;\n\t\t\t\t\t\telse next_state<=state_1;\n\n\t\t\t\t\tend\n\t\t\tcheck: \tbegin\t\t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\t\n\t\t\t\t\t\t\t\tleer_ram=1'b1;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b1;\n\t\t\t\t\t\t\t\n\n\t\t\t\n\t\t\t\t\t\tif (new_string==1'b1) next_state<=start;\n\t\t\t\t\t\telse next_state<=check;\n\t\t\t\t\tend\n\t\t\t\n\t\t\tdefault:\n\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tadd_dirram=1'b0;\n\t\t\t\t\t\t\t\treset_dirram=1'b0;\n\t\t\t\t\t\t\t\tadd_col=1'b0;\n\t\t\t\t\t\t\t\treset_col=1'b0;\n\t\t\t\t\t\t\t\tadd_ascci=1'b0;\n\t\t\t\t\t\t\t\treset_ascci=1'b0;\n\t\t\t\t\t\t\t\tleer_rom=1'b0;\n\t\t\t\t\t\t\t\tleer_ram=1'b0;\n\t\t\t\t\t\t\t\tinit=0;\n\t\t\t\t\t\t\t\trun_efect=1'b0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tnext_state<=start;\n\t\t\t\t\tend\n\t\tendcase\n\tend\t\n\n\talways @(negedge clk) begin\n\t    current_state<=next_state;\t\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_6739875f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule d_ff (\n    input clk,\n    input reset,\n    input set,\n    input enable,\n    input test,\n    input d,\n    output reg q\n);\n\n    // Voltage supply signals\n    supply1 vpwr;\n    supply0 vgnd;\n\n    // Internal signals\n    wire test_mux_out;\n    wire set_mux_out;\n    wire inv_out;\n    reg dff_in;\n\n    // Test Mux\n    assign test_mux_out = test ? d : 1'b0;\n\n    // Set Mux\n    assign set_mux_out = set ? 1'b1 : test_mux_out;\n\n    // Inverter\n    assign inv_out = ~set_mux_out;\n\n    // D Flip-Flop\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            dff_in <= 1'b0;\n        end else if (enable) begin\n            dff_in <= inv_out;\n        end\n    end\n\n    // Output Register\n    always @* begin\n        q <= dff_in;\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__1c4af05d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output out\n);\n\n    // Declare signals\n    wire transition_detected;\n    wire equal_a_b;\n\n    // Instantiate the transition detector module\n    transition_detector td (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .transition_detected(transition_detected)\n    );\n\n    // Instantiate the 4-bit comparator module\n    four_bit_comparator fbc (\n        .a(in[31:28]),\n        .b(in[27:24]),\n        .equal(equal_a_b)\n    );\n\n    // Instantiate the functional module\n    functional_module fm (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .equal(equal_a_b),\n        .out(out)\n    );\n\nendmodule\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg transition_detected\n);\n\n    reg [31:0] prev_in;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            prev_in <= 0;\n            transition_detected <= 0;\n        end else begin\n            if ((~prev_in[31] && in[31]) || (prev_in[31] && ~in[31])) begin\n                transition_detected <= 1;\n            end else begin\n                transition_detected <= 0;\n            end\n            prev_in <= in;\n        end\n    end\n\nendmodule\nmodule four_bit_comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg equal\n);\n\n    always @ (*) begin\n        if (a == b) begin\n            equal <= 1;\n        end else begin\n            equal <= 0;\n        end\n    end\n\nendmodule\nmodule functional_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    input equal,\n    output out\n);\n\n    reg [127:0] pattern = 128'h0000FFFF0000FFFF0000FFFF0000FFFF;\n    reg [31:0] pattern_index;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            pattern_index <= 0;\n        end else begin\n            if (equal) begin\n                pattern_index <= pattern_index + 1;\n            end\n            if (pattern_index == 31) begin\n                pattern_index <= 0;\n            end\n        end\n    end\n\n    assign out = pattern[pattern_index];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cf_mul_58393abf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule cf_mul (\n\n  clk,\n  data_a,\n  data_b,\n  data_p,\n\n  ddata_in,\n  ddata_out);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input           clk;\n  input   [16:0]  data_a;\n  input   [ 7:0]  data_b;\n  output  [24:0]  data_p;\n  input   [DW:0]  ddata_in;\n  output  [DW:0]  ddata_out;\n\n  reg             p1_sign = 'd0;\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [23:0]  p1_data_p_0 = 'd0;\n  reg     [23:0]  p1_data_p_1 = 'd0;\n  reg     [23:0]  p1_data_p_2 = 'd0;\n  reg     [23:0]  p1_data_p_3 = 'd0;\n  reg     [23:0]  p1_data_p_4 = 'd0;\n  reg             p2_sign = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [23:0]  p2_data_p_0 = 'd0;\n  reg     [23:0]  p2_data_p_1 = 'd0;\n  reg             p3_sign = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [23:0]  p3_data_p_0 = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [24:0]  data_p = 'd0;\n\n  wire    [16:0]  p1_data_a_1p_17_s;\n  wire    [16:0]  p1_data_a_1n_17_s;\n  wire    [23:0]  p1_data_a_1p_s;\n  wire    [23:0]  p1_data_a_1n_s;\n  wire    [23:0]  p1_data_a_2p_s;\n  wire    [23:0]  p1_data_a_2n_s;\n\n  assign p1_data_a_1p_17_s = {1'b0, data_a[15:0]};\n  assign p1_data_a_1n_17_s = ~p1_data_a_1p_17_s + 1'b1;\n\n  assign p1_data_a_1p_s = {{7{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s};\n  assign p1_data_a_1n_s = {{7{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s};\n  assign p1_data_a_2p_s = {{6{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s, 1'b0};\n  assign p1_data_a_2n_s = {{6{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s, 1'b0};\n\n  always @(posedge clk) begin\n    p1_sign <= data_a[16];\n    p1_ddata <= ddata_in;\n    case (data_b[1:0])\n      2'b11: p1_data_p_0 <= p1_data_a_1n_s;\n      2'b10: p1_data_p_0 <= p1_data_a_2n_s;\n      2'b01: p1_data_p_0 <= p1_data_a_1p_s;\n      default: p1_data_p_0 <= 24'd0;\n    endcase\n    case (data_b[3:1])\n      3'b011: p1_data_p_1 <= {p1_data_a_2p_s[21:0], 2'd0};\n      3'b100: p1_data_p_1 <= {p1_data_a_2n_s[21:0], 2'd0};\n      3'b001: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b010: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b101: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      3'b110: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      default: p1_data_p_1 <= 24'd0;\n    endcase\n    case (data_b[5:3])\n      3'b011: p1_data_p_2 <= {p1_data_a_2p_s[19:0], 4'd0};\n      3'b100: p1_data_p_2 <= {p1_data_a_2n_s[19:0], 4'd0};\n      3'b001: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b010: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b101: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      3'b110: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      default: p1_data_p_2 <= 24'd0;\n    endcase\n    case (data_b[7:5])\n      3'b011: p1_data_p_3 <= {p1_data_a_2p_s[17:0], 6'd0};\n      3'b100: p1_data_p_3 <= {p1_data_a_2n_s[17:0], 6'd0};\n      3'b001: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b010: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b101: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      3'b110: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      default: p1_data_p_3 <= 24'd0;\n    endcase\n    case (data_b[7])\n      1'b1: p1_data_p_4 <= {p1_data_a_1p_s[15:0], 8'd0};\n      default: p1_data_p_4 <= 24'd0;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    p2_sign <= p1_sign;\n    p2_ddata <= p1_ddata;\n    p2_data_p_0 <= p1_data_p_0 + p1_data_p_1 + p1_data_p_4;\n    p2_data_p_1 <= p1_data_p_2 + p1_data_p_3;\n  end\n\n  always @(posedge clk) begin\n    p3_sign <= p2_sign;\n    p3_ddata <= p2_ddata;\n    p3_data_p_0 <= p2_data_p_0 + p2_data_p_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    data_p <= {p3_sign, p3_data_p_0};\n  end\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "booth_shift_reg_2ccb52fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule booth_shift_reg (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    input load,\n    input shift_left,\n    input shift_right,\n    input select,\n    output [7:0] P,\n    output [7:0] P_shifted\n);\n\nreg [7:0] P_reg;\nreg [3:0] A_reg;\nreg [3:0] B_reg;\nreg [2:0] count;\nreg [3:0] B_shifted;\nreg [1:0] shift_count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        P_reg <= 8'b0;\n        A_reg <= 4'b0;\n        B_reg <= 4'b0;\n        count <= 3'b0;\n        B_shifted <= 4'b0;\n        shift_count <= 2'b0;\n    end else begin\n        if (load) begin\n            P_reg <= 8'b0;\n            A_reg <= A;\n            B_reg <= B;\n            count <= 3'b0;\n            B_shifted <= {B[3], B};\n            shift_count <= 2'b0;\n        end else begin\n            case (count)\n                3'b000: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 4);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b001: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 4);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n                3'b010: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 3);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b011: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 3);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n                3'b100: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 2);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b101: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 2);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n                3'b110: begin\n                    if (B_reg[0] == 1) begin\n                        P_reg <= P_reg + (A_reg << 1);\n                    end\n                    B_shifted <= {B[3], B};\n                    shift_count <= 2'b0;\n                end\n                3'b111: begin\n                    if (B_reg[0] == 0 && B_shifted[0] == 1) begin\n                        P_reg <= P_reg - (A_reg << 1);\n                    end\n                    B_shifted <= {B_shifted[3], B_shifted};\n                    shift_count <= 2'b1;\n                end\n            endcase\n            count <= count + 1;\n        end\n    end\nend\n\nassign P = select ? P_reg : {P_reg[6:0], 1'b0};\nassign P_shifted = select ? {P_reg[6:0], 1'b0} : {P_reg[5:0], 2'b0};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "i2s_shift_in_66a3e198", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule i2s_shift_in (\n\tinput\t\t\t\tclk,\t\t\t\tinput\t\t\t\treset_n,\t\t\toutput reg\t[31:0]\tfifo_right_data,\toutput reg\t[31:0]\tfifo_left_data,\t\tinput\t\t\t\tfifo_ready,\t\t\toutput reg\t\t\tfifo_write,\t\t\tinput\t\t\t\tenable,\t\t\t\tinput\t\t\t\tbclk,\t\t\t\tinput\t\t\t\tlrclk,\t\t\t\tinput\t\t\t\tdata_in\t\t\t\t);\n\n\treg bclk_delayed;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tbclk_delayed <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tbclk_delayed <= bclk;\n\t\tend\n\tend\n\twire bclk_rising_edge = bclk & ~bclk_delayed;\n\twire bclk_falling_edge = ~bclk & bclk_delayed;\n\t\t\n\treg lrclk_delayed;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tlrclk_delayed <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tlrclk_delayed <= lrclk;\n\t\tend\n\tend\n\twire lrclk_rising_edge = lrclk & ~lrclk_delayed;\n\twire lrclk_falling_edge = ~lrclk & lrclk_delayed;\n\n\treg [1:0] first_bclk_falling_after_lrclk_rising_r;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (lrclk_rising_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b01;\n\t\t\telse if (first_bclk_falling_after_lrclk_rising_r == 2'b01 && bclk_rising_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b10;\n\t\t\telse if (first_bclk_falling_after_lrclk_rising_r == 2'b10 && bclk_falling_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b11;\n\t\t\telse if (first_bclk_falling_after_lrclk_rising_r == 2'b11)\n\t\t\t\tfirst_bclk_falling_after_lrclk_rising_r <= 2'b00;\n\t\tend\n\tend\n\twire first_bclk_falling_after_lrclk_rising = first_bclk_falling_after_lrclk_rising_r == 2'b11;\n\t\n\treg [1:0] first_bclk_falling_after_lrclk_falling_r;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (lrclk_falling_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b01;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling_r == 2'b01 && bclk_rising_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b10;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling_r == 2'b10 && bclk_falling_edge)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b11;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling_r == 2'b11)\n\t\t\t\tfirst_bclk_falling_after_lrclk_falling_r <= 2'b00;\n\t\tend\n\tend\n\twire first_bclk_falling_after_lrclk_falling = first_bclk_falling_after_lrclk_falling_r == 2'b11;\n\t\n\treg [31:0] shift_register;\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tshift_register <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (~enable)\n\t\t\t\tshift_register <= 0;\n\t\t\telse if (bclk_rising_edge)\n\t\t\t\tshift_register <= {shift_register[30:0], data_in};\n\t\tend\n\tend\n\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfifo_right_data <= 0;\n\t\t\tfifo_left_data <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (~enable)\n\t\t\tbegin\n\t\t\t\tfifo_right_data <= 0;\n\t\t\t\tfifo_left_data <= 0;\n\t\t\tend\n\t\t\telse if (first_bclk_falling_after_lrclk_rising)\n\t\t\t\tfifo_left_data <= shift_register;\n\t\t\telse if (first_bclk_falling_after_lrclk_falling)\n\t\t\t\tfifo_right_data <= shift_register;\n\t\tend\t\t\t\t\n\tend\n\n\talways @(posedge clk or negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tfifo_write <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (~enable | ~fifo_ready)\n\t\t\t\tfifo_write <= 0;\n\t\t\telse\n\t\t\t\tfifo_write <= first_bclk_falling_after_lrclk_falling;\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FA_106_19768e23", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FA_106 (input A, B, Ci, output S, Co);\n  wire n9, n10, n11;\n\n  assign n11 = ~(A ^ B);\n  assign S = ~(Ci ^ n11);\n  assign n10 = ~(A & B & Ci);\n  assign n9 = ~(A & B);\n  assign Co = ~(n10 & n9);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_counter_7a50be20", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_counter(\n  input clk,\n  input rst,\n  input en,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      count <= 4'b0000;\n    end else if(en) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multi_io__a4b9602e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multi_io_module (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input enable,\n  input [3:0] addr,\n  output reg [7:0] data_out,\n  output reg valid,\n  output reg done,\n  output reg error\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      data_out <= 8'b0;\n      valid <= 1'b0;\n      done <= 1'b0;\n      error <= 1'b0;\n    end else if (enable) begin\n      case (addr)\n        4'h0: begin\n          data_out <= data_in;\n          valid <= 1'b1;\n          done <= 1'b0;\n          error <= 1'b0;\n        end\n        4'h1: begin\n          data_out <= data_in;\n          valid <= 1'b1;\n          done <= 1'b0;\n          error <= 1'b1;\n        end\n        4'h2: begin\n          data_out <= data_in;\n          valid <= 1'b0;\n          done <= 1'b1;\n          error <= 1'b0;\n        end\n        4'h3: begin\n          data_out <= data_in;\n          valid <= 1'b0;\n          done <= 1'b1;\n          error <= 1'b1;\n        end\n        default: begin\n          data_out <= data_in;\n          valid <= 1'b0;\n          done <= 1'b0;\n          error <= 1'b0;\n        end\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_4bit_340e57e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_sub_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  input mode,\n  output [3:0] Y,\n  output COUT,\n  output BOUT\n);\n\n  wire [3:0] B_comp;\n  assign B_comp = ~B + 1; // Two's complement of B\n\n  wire [4:0] Y_temp;\n  assign Y_temp = A + (mode ? B_comp : B); // Perform addition or subtraction based on mode input\n\n  assign Y = Y_temp[3:0]; // Output the result\n  assign COUT = Y_temp[4]; // Output carry-out for addition\n  assign BOUT = Y_temp[4] ^ mode; // Output borrow-out for subtraction\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ballcollisions_df67c69c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ballcollisions(\n\tclk,\n\treset,\n\tp1_y,\n\tp2_y,\n\tball_x,\n\tball_y,\n\tdir_x,\n\tdir_y,\n\toob\n);\n\ninput clk, reset;\ninput [10:0] p1_y, p2_y, ball_x, ball_y;\noutput reg dir_x, dir_y, oob;\n\n// Constants\nlocalparam hc = 512;\nlocalparam va = 0;\nlocalparam vc = 480;\nlocalparam batwidth = 10;\nlocalparam batheight = 80;\nlocalparam ballsize = 10;\n\n// Initial values\nreg ball_x_reg, ball_y_reg;\nreg dir_x_reg, dir_y_reg;\nreg oob_reg;\ninitial begin\n\tball_x_reg = hc;\n\tball_y_reg = vc/2;\n\tdir_x_reg = 0;\n\tdir_y_reg = 1;\n\toob_reg = 0;\nend\n\n// Logic for direction changes\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tdir_x_reg <= ~dir_x_reg;\n\t\tdir_y_reg <= 1;\n\t\toob_reg <= 0;\n\t\tball_x_reg <= hc;\n\t\tball_y_reg <= vc/2;\n\tend\n\telse begin\n\t\t// out of bounds (i.e. one of the players missed the ball)\n\t\tif (ball_x_reg <= 0 || ball_x_reg >= hc) begin\n\t\t\toob_reg <= 1;\n\t\tend\n\t\telse begin\n\t\t\toob_reg <= 0;\n\t\tend\n\t\t\n\t\t// collision with top & bottom walls\n\t\tif (ball_y_reg <= va + ballsize) begin\n\t\t\tdir_y_reg <= 1;\n\t\tend\n\t\tif (ball_y_reg >= vc - ballsize) begin\n\t\t\tdir_y_reg <= 0;\n\t\tend\n\t\t\n\t\t// collision with P1 bat\n\t\tif (ball_x_reg <= batwidth && ball_y_reg + ballsize >= p1_y && ball_y_reg <= p1_y + batheight) begin\n\t\t\tdir_x_reg <= 1;\n\t\t\tif (ball_y_reg + ballsize <= p1_y + (batheight / 2)) begin\n\t\t\t\tdir_y_reg <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tdir_y_reg <= 1;\n\t\t\tend\n\t\tend\n\t\t// collision with P2 bat\n\t\telse if (ball_x_reg >= hc - batwidth - ballsize && ball_y_reg + ballsize <= p2_y + batheight && ball_y_reg >= p2_y) begin\n\t\t\tdir_x_reg <= 0;\n\t\t\tif (ball_y_reg + ballsize <= p2_y + (batheight / 2)) begin\n\t\t\t\tdir_y_reg <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tdir_y_reg <= 1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t// Move ball based on direction\n\t\tif (dir_x_reg) begin\n\t\t\tball_x_reg <= ball_x_reg + 1;\n\t\tend\n\t\telse begin\n\t\t\tball_x_reg <= ball_x_reg - 1;\n\t\tend\n\t\t\n\t\tif (dir_y_reg) begin\n\t\t\tball_y_reg <= ball_y_reg + 1;\n\t\tend\n\t\telse begin\n\t\t\tball_y_reg <= ball_y_reg - 1;\n\t\tend\n\tend\nend\n\n// Assign output signals to registered values\nalways @* begin\n\tdir_x = dir_x_reg;\n\tdir_y = dir_y_reg;\n\toob = oob_reg;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_tree_top_af78b97a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define ADDER_WIDTH 016\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "control_52a33e25", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule control (\n    input [5:0] op,\n    output [1:0] alu_op,\n    output regDst, aluSrc, memToReg, regWrite,\n    output memRead, memWrite, branch\n  );\n\n  // Generate complement of op bits\n  wire [5:0] op_bar;\n  assign op_bar = ~op;\n\n  // Generate control signals\n  assign alu_op[0] = op_bar[0] & op_bar[1] & op_bar[2] & op[2] & op_bar[4] & op_bar[5];\n  assign alu_op[1] = op_bar[0] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5];\n  assign regDst = op_bar[0] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5];\n  assign memToReg = op[0] & op_bar[1] & op_bar[2] & op_bar[3] & op[4] & op[5];\n  assign regWrite = (op[0] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5]) | (op[5] & op_bar[1] & op_bar[2] & op_bar[3] & op_bar[4] & op_bar[5]);\n  assign memRead = op[0] & op_bar[1] & op_bar[2] & op_bar[3] & op[4] & op_bar[5];\n  assign memWrite = op[0] & op_bar[1] & op_bar[3] & op_bar[4] & op_bar[5];\n  assign branch = op_bar[0] & op_bar[1] & op_bar[2] & op[2] & op_bar[4] & op_bar[5];\n  assign aluSrc = op[5] & op_bar[1] & op_bar[2] & op[4] & op[3];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "zet_mux8_1_f03a6d56", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule zet_mux8_1(sel, in0, in1, in2, in3, in4, in5, in6, in7, out);\n  input  [2:0]  sel;\n  input  in0, in1, in2, in3, in4, in5, in6, in7;\n  output out;\n\n  reg    out;\n\n  always @(sel or in0 or in1 or in2 or in3 or in4 or in5 or in6 or in7)\n    case(sel)\n     3'd0:  out = in0;\n     3'd1:  out = in1;\n     3'd2:  out = in2;\n     3'd3:  out = in3;\n     3'd4:  out = in4;\n     3'd5:  out = in5;\n     3'd6:  out = in6;\n     3'd7:  out = in7;\n    endcase\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "regfile_333da0c6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule regfile(\n    input             clk,\n    input             wen,\n    input      [4 :0] raddr1,\n    input      [4 :0] raddr2,\n    input      [4 :0] waddr,\n    input      [31:0] wdata,\n    output reg [31:0] rdata1,\n    output reg [31:0] rdata2,\n    input      [4 :0] test_addr,\n    output reg [31:0] test_data,\n    input             resetn\n    );\n    reg [31:0] rf[31:0];\n     \n    always @(posedge clk)\n    begin\n        if (wen) \n        begin\n            rf[waddr] <= wdata;\n        end\n        if(!resetn) begin\n            rf[0] <= 0;\n            rf[1] <= 0;\n            rf[2] <= 0;\n            rf[3] <= 0;\n            rf[4] <= 0;\n            rf[5] <= 0;\n            rf[6] <= 0;\n            rf[7] <= 0;\n            rf[8] <= 0;\n            rf[9] <= 0;\n            rf[10] <= 0;\n            rf[11] <= 0;\n            rf[12] <= 0;\n            rf[13] <= 0;\n            rf[14] <= 0;\n            rf[15] <= 0;\n            rf[16] <= 0;\n            rf[17] <= 0;\n            rf[18] <= 0;\n            rf[19] <= 0;\n            rf[20] <= 0;\n            rf[21] <= 0;\n            rf[22] <= 0;\n            rf[23] <= 0;\n            rf[24] <= 0;\n            rf[25] <= 0;\n            rf[26] <= 0;\n            rf[27] <= 0;\n            rf[28] <= 0;\n            rf[29] <= 0;\n            rf[30] <= 0;\n            rf[31] <= 0;          \n        end\n    end\n     \n    always @(*)\n    begin\n        case (raddr1)\n            5'd1 : rdata1 <= rf[1 ];\n            5'd2 : rdata1 <= rf[2 ];\n            5'd3 : rdata1 <= rf[3 ];\n            5'd4 : rdata1 <= rf[4 ];\n            5'd5 : rdata1 <= rf[5 ];\n            5'd6 : rdata1 <= rf[6 ];\n            5'd7 : rdata1 <= rf[7 ];\n            5'd8 : rdata1 <= rf[8 ];\n            5'd9 : rdata1 <= rf[9 ];\n            5'd10: rdata1 <= rf[10];\n            5'd11: rdata1 <= rf[11];\n            5'd12: rdata1 <= rf[12];\n            5'd13: rdata1 <= rf[13];\n            5'd14: rdata1 <= rf[14];\n            5'd15: rdata1 <= rf[15];\n            5'd16: rdata1 <= rf[16];\n            5'd17: rdata1 <= rf[17];\n            5'd18: rdata1 <= rf[18];\n            5'd19: rdata1 <= rf[19];\n            5'd20: rdata1 <= rf[20];\n            5'd21: rdata1 <= rf[21];\n            5'd22: rdata1 <= rf[22];\n            5'd23: rdata1 <= rf[23];\n            5'd24: rdata1 <= rf[24];\n            5'd25: rdata1 <= rf[25];\n            5'd26: rdata1 <= rf[26];\n            5'd27: rdata1 <= rf[27];\n            5'd28: rdata1 <= rf[28];\n            5'd29: rdata1 <= rf[29];\n            5'd30: rdata1 <= rf[30];\n            5'd31: rdata1 <= rf[31];\n            default : rdata1 <= 32'd0;\n        endcase\n    end\n    always @(*)\n    begin\n        case (raddr2)\n            5'd1 : rdata2 <= rf[1 ];\n            5'd2 : rdata2 <= rf[2 ];\n            5'd3 : rdata2 <= rf[3 ];\n            5'd4 : rdata2 <= rf[4 ];\n            5'd5 : rdata2 <= rf[5 ];\n            5'd6 : rdata2 <= rf[6 ];\n            5'd7 : rdata2 <= rf[7 ];\n            5'd8 : rdata2 <= rf[8 ];\n            5'd9 : rdata2 <= rf[9 ];\n            5'd10: rdata2 <= rf[10];\n            5'd11: rdata2 <= rf[11];\n            5'd12: rdata2 <= rf[12];\n            5'd13: rdata2 <= rf[13];\n            5'd14: rdata2 <= rf[14];\n            5'd15: rdata2 <= rf[15];\n            5'd16: rdata2 <= rf[16];\n            5'd17: rdata2 <= rf[17];\n            5'd18: rdata2 <= rf[18];\n            5'd19: rdata2 <= rf[19];\n            5'd20: rdata2 <= rf[20];\n            5'd21: rdata2 <= rf[21];\n            5'd22: rdata2 <= rf[22];\n            5'd23: rdata2 <= rf[23];\n            5'd24: rdata2 <= rf[24];\n            5'd25: rdata2 <= rf[25];\n            5'd26: rdata2 <= rf[26];\n            5'd27: rdata2 <= rf[27];\n            5'd28: rdata2 <= rf[28];\n            5'd29: rdata2 <= rf[29];\n            5'd30: rdata2 <= rf[30];\n            5'd31: rdata2 <= rf[31];\n            default : rdata2 <= 32'd0;\n        endcase\n    end\n     always @(*)\n    begin\n        case (test_addr)\n            5'd1 : test_data <= rf[1 ];\n            5'd2 : test_data <= rf[2 ];\n            5'd3 : test_data <= rf[3 ];\n            5'd4 : test_data <= rf[4 ];\n            5'd5 : test_data <= rf[5 ];\n            5'd6 : test_data <= rf[6 ];\n            5'd7 : test_data <= rf[7 ];\n            5'd8 : test_data <= rf[8 ];\n            5'd9 : test_data <= rf[9 ];\n            5'd10: test_data <= rf[10];\n            5'd11: test_data <= rf[11];\n            5'd12: test_data <= rf[12];\n            5'd13: test_data <= rf[13];\n            5'd14: test_data <= rf[14];\n            5'd15: test_data <= rf[15];\n            5'd16: test_data <= rf[16];\n            5'd17: test_data <= rf[17];\n            5'd18: test_data <= rf[18];\n            5'd19: test_data <= rf[19];\n            5'd20: test_data <= rf[20];\n            5'd21: test_data <= rf[21];\n            5'd22: test_data <= rf[22];\n            5'd23: test_data <= rf[23];\n            5'd24: test_data <= rf[24];\n            5'd25: test_data <= rf[25];\n            5'd26: test_data <= rf[26];\n            5'd27: test_data <= rf[27];\n            5'd28: test_data <= rf[28];\n            5'd29: test_data <= rf[29];\n            5'd30: test_data <= rf[30];\n            5'd31: test_data <= rf[31];\n            default : test_data <= 32'd0;\n        endcase\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_577a2dc8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate(\n    input a, \n    input b,\n    output reg out\n);\n\n    always @(*) begin\n        out = (a & b) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Delay_Block_dbb08f2b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Delay_Block (\n  input in,\n  output out,\n  input clk // Clock signal\n);\n\nparameter delay = 2; // Amount of delay in number of clock cycles.\n\nreg [delay-1:0] delay_reg; // Register to hold input signal for delay cycles\n\nalways @(posedge clk) begin\n  delay_reg <= {delay_reg[delay-2:0], in}; // Shift input signal into register\nend\n\nassign out = delay_reg[delay-1]; // Output delayed signal\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotator_fa4a254c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b00: q <= {q[98:0], q[99]};\n                2'b01: q <= {q[99], q[98:0]};\n                default: q <= q;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output wire [99:0] q);\n\n    rotator rotator_inst(\n        .clk(clk),\n        .load(load),\n        .ena(ena),\n        .data(data),\n        .q(q)\n    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flip_flop_881cfdce", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule flip_flop (\n    Q,\n    Q_N,\n    CLK,\n    D,\n    SCD,\n    SCE\n);\n\n    output Q;\n    output Q_N;\n    input CLK;\n    input D;\n    input SCD;\n    input SCE;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    reg Q;\n    assign Q_N = ~Q;\n\n    always @(posedge CLK) begin\n        if (SCD) begin\n            Q <= 0;\n        end else if (SCE) begin\n            Q <= 1;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_8a190079", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input clk,\n    input reset,\n    input [1:0] op,\n    input [7:0] in1,\n    input [7:0] in2,\n    output reg [7:0] out,\n    output reg valid\n);\n\n    reg [15:0] result;\n    \n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            result <= 0;\n            out <= 0;\n            valid <= 0;\n        end else begin\n            case(op)\n                2'b00: result <= in1 + in2; // addition\n                2'b01: result <= in1 - in2; // subtraction\n                2'b10: result <= in1 * in2; // multiplication\n                2'b11: result <= in1 / in2; // division\n            endcase\n            \n            out <= result[7:0];\n            valid <= 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "taxicab_distance #_38c46277", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule taxicab_distance #(parameter N = 32)(\n\tinput [N-1:0] x1, y1, x2, y2,\n\toutput [N+1:0] dist\n);\n\nwire signed [N:0] dist_x12, dist_x21, dist_xabs, dist_y12, dist_y21, dist_yabs;\n\n// Calculate the absolute difference between x1 and x2\nassign dist_x12 = x1 - x2;\n// Calculate the absolute difference between x2 and x1\nassign dist_x21 = x2 - x1;\n\n// Select the absolute difference between x1 and x2 if x1 > x2, otherwise select the absolute difference between x2 and x1\nassign dist_xabs = (x1 > x2) ? dist_x12 : dist_x21;\n\n// Calculate the absolute difference between y1 and y2\nassign dist_y12 = y1 - y2;\n// Calculate the absolute difference between y2 and y1\nassign dist_y21 = y2 - y1;\n\n// Select the absolute difference between y1 and y2 if y1 > y2, otherwise select the absolute difference between y2 and y1\nassign dist_yabs = (y1 > y2) ? dist_y12 : dist_y21;\n\n// Calculate the taxicab distance by adding the absolute differences of x and y coordinates\nassign dist = dist_xabs + dist_yabs;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_0b32051c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] opcode,\n    output reg [7:0] result\n    );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            result <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= a + b;\n                2'b01: result <= a - b;\n                2'b10: result <= a * b;\n                2'b11: result <= a / b;\n            endcase\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W55_0_2_335c742d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule SNPS_CLOCK_GATE_HIGH_RegisterAdd_W55_0_2 (input CLK, EN, TE, output ENCLK);\n  assign ENCLK = EN ? CLK : 1'b0;\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .ECK(ENCLK) );\n\nendmodule\nmodule TLATNTSCAX2TS (input E, SE, CK, ECK);\n  // Add your TLATNTSCAX2TS module implementation here\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_3ac0e6b3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] sum;\n  wire [3:0] carry;\n  \n  // First bit of sum and carry\n  full_adder fa0(A[0], B[0], Cin, sum[0], carry[0]);\n  \n  // Subsequent bits of sum and carry\n  full_adder fa1(A[1], B[1], carry[0], sum[1], carry[1]);\n  full_adder fa2(A[2], B[2], carry[1], sum[2], carry[2]);\n  full_adder fa3(A[3], B[3], carry[2], sum[3], Cout);\n\n  assign S = sum;\n\nendmodule\n\nmodule full_adder(\n  input A,\n  input B,\n  input Cin,\n  output S,\n  output Cout\n);\n\n  wire s1, s2, c1, c2;\n  \n  // First stage\n  xor(s1, A, B);\n  xor(S, s1, Cin);\n  \n  // Second stage\n  and(c1, A, B);\n  and(c2, s1, Cin);\n  or(Cout, c1, c2);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_0e226a0d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor (\n\tinput [3:0] A,\n\tinput [3:0] B,\n\tinput subtract,\n\toutput reg [3:0] result\n);\n\n\talways @(*) begin\n\t\tif (subtract == 1) begin\n\t\t\tresult <= A - B;\n\t\tend else begin\n\t\t\tresult <= A + B;\n\t\tend\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_tree_top_b0677317", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define ADDER_WIDTH 005\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "six_input_one_output_2e30a5eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule six_input_one_output (\n    input  A1,\n    input  A2,\n    input  B1,\n    input  B2,\n    input  C1,\n    input  C2,\n    output Y\n);\n\n    assign Y = (A1 & A2) | (B1 & B2) | (C1 & C2);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__02d3ff3b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module (\n    output Y,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    input  VPWR,\n    input  VGND,\n    input  VPB,\n    input  VNB\n);\n\n    wire xor1, xor2;\n\n    assign xor1 = A1 ^ A2;\n    assign xor2 = A3 ^ A4;\n\n    assign Y = (B1 & ~VPWR) ? xor1 : ((~B1) ? 0 : xor2);\n\nendmodule\nmodule sky130_fd_sc_lp__o41ai (\n    output Y,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  A4,\n    input  B1,\n    input  VPWR,\n    input  VGND,\n    input  VPB,\n    input  VNB\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pixel_faf60af0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pixel(clk, pixclk, attcode,\n             pixel, blank, hsync_in, vsync_in, blink,\n             hsync, vsync, r, g, b);\n    input clk;\n    input pixclk;\n    input [7:0] attcode;\n    input pixel;\n    input blank;\n    input hsync_in;\n    input vsync_in;\n    input blink;\n    output reg hsync;\n    output reg vsync;\n    output reg [2:0] r;\n    output reg [2:0] g;\n    output reg [2:0] b;\n\n  wire blink_bit;\n  wire bg_red;\n  wire bg_green;\n  wire bg_blue;\n  wire inten_bit;\n  wire fg_red;\n  wire fg_green;\n  wire fg_blue;\n  wire foreground;\n  wire intensify;\n  wire red;\n  wire green;\n  wire blue;\n\n  assign blink_bit = attcode[7];\n  assign bg_red = attcode[6];\n  assign bg_green = attcode[5];\n  assign bg_blue = attcode[4];\n  assign inten_bit = attcode[3];\n  assign fg_red = attcode[2];\n  assign fg_green = attcode[1];\n  assign fg_blue = attcode[0];\n\n  assign foreground = pixel & ~(blink_bit & blink);\n  assign intensify = foreground & inten_bit;\n\n  assign red = (foreground ? fg_red : bg_red);\n  assign green = (foreground ? fg_green : bg_green);\n  assign blue = (foreground ? fg_blue : bg_blue);\n\n  always @(posedge clk) begin\n    if (pixclk == 1) begin\n      hsync <= hsync_in;\n      vsync <= vsync_in;\n      r[2] <= blank & red;\n      r[1] <= blank & intensify;\n      r[0] <= blank & red & intensify;\n      g[2] <= blank & green;\n      g[1] <= blank & intensify;\n      g[0] <= blank & green & intensify;\n      b[2] <= blank & blue;\n      b[1] <= blank & intensify;\n      b[0] <= blank & blue & intensify;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "coordinate_cordic_c0ae1266", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule coordinate_cordic\n(\n\trealIn,\n\timagIn,\n\tclk,\n\tamplitude,\n\tangle,\n\ttest1,\n\ttest2\n);\n\ninput signed [INWIDTH-1:0]realIn,imagIn;\ninput clk;\noutput signed [OUTWIDTH-1:0]amplitude;\noutput signed [ANGLEWIDTH-1:0]angle;\n\ninput  [9:0] test1;\noutput  [9:0] test2;\nassign  test2 = {11{test1}};\nparameter INWIDTH = 18,  OUTWIDTH = 20, MIDWIDTH = 21, ANGLEWIDTH =15;parameter ARCTANG_0  = 12'b10_01110_00100,ARCTANG_1  = 11'b1_01110_00100,ARCTANG_2  = 10'b11000_01100,ARCTANG_3  = 9'b1100_01100,ARCTANG_4  = 8'b110_00111,ARCTANG_5  = 7'b11_00011,ARCTANG_6  = 6'b1_10010,ARCTANG_7  = 5'b11001,ARCTANG_8  = 4'b1100,ARCTANG_9  = 3'b110,ARCTANG_10 = 2'b11,ARCTANG_11 = 2'b10;parameter HALFPI = 13'b100_11100_01000;reg signed [MIDWIDTH-1:0]xData1,xData2,xData3,xData4,xData5,xData6,\n                         xData7,xData8,xData9,xData10,xData11,xData12,\n                         xData13,xData14,xData15,xData16,\n\t\t\t\t         yData1,yData2,yData3,yData4,yData5,yData6,\n\t\t\t\t         yData7,yData8,yData9,yData10,yData11,yData12,\n\t\t\t\t         yData13,yData14,yData15,yData16;\n\nreg signed [ANGLEWIDTH-1:0]angle1,angle2,angle3,angle4,angle5,angle6,\n\t\t\t\t\t       angle7,angle8,angle9,angle10,angle11,angle12,\n\t\t\t\t\t       angle13,angle14,angle15,angle16;\n\n\nwire signed [MIDWIDTH-1:0]reIn,imIn;\nwire signed [ANGLEWIDTH-1:0]ang;\nassign reIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-imagIn:imagIn):realIn;\nassign imIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?realIn:-realIn):imagIn;\nassign ang = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-HALFPI:HALFPI):1'b0;\n\n\nassign amplitude = {xData12[MIDWIDTH-1],xData12[MIDWIDTH-3:0]};\nassign angle = angle12;\n\n\n\nalways@(posedge clk)\nbegin\n    xData1 <= imIn[MIDWIDTH-1]?(reIn - imIn):(reIn + imIn);\n\tyData1 <= imIn[MIDWIDTH-1]?(imIn + reIn):(imIn - reIn);\n\tangle1 <= imIn[MIDWIDTH-1]?(ang - ARCTANG_0):(ang + ARCTANG_0);\n\n    xData2 <= yData1[MIDWIDTH-1]?(xData1 - {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]}):(xData1 + {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]});\n\tyData2 <= yData1[MIDWIDTH-1]?(yData1 + {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]}):(yData1 - {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]});\n\tangle2 <= yData1[MIDWIDTH-1]?(angle1 - ARCTANG_1):(angle1 + ARCTANG_1);\n\n    xData3 <= yData2[MIDWIDTH-1]?(xData2 - {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]}):(xData2 + {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]});\n\tyData3 <= yData2[MIDWIDTH-1]?(yData2 + {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]}):(yData2 - {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]});\n\tangle3 <= yData2[MIDWIDTH-1]?(angle2 - ARCTANG_2):(angle2 + ARCTANG_2);\n\n    xData4 <= yData3[MIDWIDTH-1]?(xData3 - {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]}):(xData3 + {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]});\n\tyData4 <= yData3[MIDWIDTH-1]?(yData3 + {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]}):(yData3 - {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]});\n\tangle4 <= yData3[MIDWIDTH-1]?(angle3 - ARCTANG_3):(angle3 + ARCTANG_3);\n\n    xData5 <= yData4[MIDWIDTH-1]?(xData4 - {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]}):(xData4 + {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]});\n\tyData5 <= yData4[MIDWIDTH-1]?(yData4 + {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]}):(yData4 - {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]});\n\tangle5 <= yData4[MIDWIDTH-1]?(angle4 - ARCTANG_4):(angle4 + ARCTANG_4);\n\n    xData6 <= yData5[MIDWIDTH-1]?(xData5 - {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]}):(xData5 + {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]});\n\tyData6 <= yData5[MIDWIDTH-1]?(yData5 + {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]}):(yData5 - {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]});\n\tangle6 <= yData5[MIDWIDTH-1]?(angle5 - ARCTANG_5):(angle5 + ARCTANG_5);\n\n    xData7 <= yData6[MIDWIDTH-1]?(xData6 - {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]}):(xData6 + {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]});\n\tyData7 <= yData6[MIDWIDTH-1]?(yData6 + {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]}):(yData6 - {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]});\n\tangle7 <= yData6[MIDWIDTH-1]?(angle6 - ARCTANG_6):(angle6 + ARCTANG_6);\n\n    xData8 <= yData7[MIDWIDTH-1]?(xData7 - {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]}):(xData7 + {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]});\n\tyData8 <= yData7[MIDWIDTH-1]?(yData7 + {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]}):(yData7 - {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]});\n\tangle8 <= yData7[MIDWIDTH-1]?(angle7 - ARCTANG_7):(angle7 + ARCTANG_7);\n\n    xData9 <= yData8[MIDWIDTH-1]?(xData8 - {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]}):(xData8 + {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]});\n\tyData9 <= yData8[MIDWIDTH-1]?(yData8 + {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]}):(yData8 - {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]});\n\tangle9 <= yData8[MIDWIDTH-1]?(angle8 - ARCTANG_8):(angle8 + ARCTANG_8);\n\n    xData10 <= yData9[MIDWIDTH-1]?(xData9 - {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]}):(xData9 + {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]});\n\tyData10 <= yData9[MIDWIDTH-1]?(yData9 + {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]}):(yData9 - {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]});\n\tangle10 <= yData9[MIDWIDTH-1]?(angle9 - ARCTANG_9):(angle9 + ARCTANG_9);\n\n    xData11 <= yData10[MIDWIDTH-1]?(xData10 - {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]}):(xData10 + {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]});\n\tyData11 <= yData10[MIDWIDTH-1]?(yData10 + {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]}):(yData10 - {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]});\n\tangle11 <= yData10[MIDWIDTH-1]?(angle10 - ARCTANG_10):(angle10 + ARCTANG_10);\n\n    xData12 <= yData11[MIDWIDTH-1]?(xData11 - {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]}):(xData11 + {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]});\n\tyData12 <= yData11[MIDWIDTH-1]?(yData11 + {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]}):(yData11 - {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]});\n\tangle12 <= yData11[MIDWIDTH-1]?(angle11 - ARCTANG_11):(angle11 + ARCTANG_11);\n\t\n   \n\t\nend\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lifo_memory_afebca68", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule lifo_memory (\n  input clk,\n  input wr_en,\n  input [7:0] data_in,\n  input rst,\n  output reg [7:0] data_out\n);\n\nparameter depth = 8; // number of data items that can be stored in the memory block\n\nreg [7:0] memory [0:depth-1]; // memory array\nreg [2:0] pointer = 0; // pointer to last data item written into the memory block\n\nalways @(posedge clk) begin\n  if (rst) begin\n    pointer <= 0; // reset pointer\n    data_out <= 0; // output 0\n  end\n  else begin\n    case ({wr_en, pointer})\n      2'b01: begin // write data_in to memory\n        memory[pointer] <= data_in;\n        pointer <= pointer + 1;\n      end\n      2'b10: begin // read last data item written to memory\n        data_out <= memory[pointer-1];\n        pointer <= pointer - 1;\n      end\n      default: data_out <= data_out; // do nothing\n    endcase\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_buffer_3daeb070", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_buffer (\n    input wire I0,\n    input wire I1,\n    input wire S,\n    output wire O\n);\n\n    assign O = S ? I0: I1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__a32oi_2221bb53", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_lp__a32oi (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    B2  ,\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  B2  ;\n\n    // Local signals\n    wire nand0_out        ;\n    wire nand1_out        ;\n    wire and0_out_Y       ;\n\n    //                                 Name         Output             Other arguments\n    nand                               nand0       (nand0_out        , A3, A2, A1            );\n    nand                               nand1       (nand1_out        , B2, B1                );\n    and                                and0        (and0_out_Y       , nand0_out, nand1_out  );\n    buf                                buf0        (Y                , and0_out_Y          );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SNPS_CLOCK_GATE_HIGH_RegisterAdd_W17_4352e1bc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule SNPS_CLOCK_GATE_HIGH_RegisterAdd_W17 ( CLK, EN, ENCLK, TE );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  TLATNTSCAX2TS latch ( .E(EN), .SE(TE), .CK(CLK), .ECK(ENCLK) );\n  \nendmodule\n\nmodule TLATNTSCAX2TS ( E, SE, CK, ECK );\n  input E, SE, CK;\n  output reg ECK;\n\n  always @ (posedge CK)\n    if (E) ECK <= SE;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "magnitude_comparator_selector_decoder_d7fd1375", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule magnitude_comparator_selector_decoder (\n    input clk,\n    input [2:0] a, b,\n    input [1:0] select,\n    output reg Y0,\n    output reg Y1,\n    output reg Y2,\n    output reg Y3,\n    output reg [2:0] comparison_result,\n    output reg [1:0] input_selected,\n    output reg [1:0] final_output\n);\n\nreg [2:0] magnitude_result;\nreg [2:0] a_mag;\nreg [2:0] b_mag;\n\n// Magnitude Comparator Module\nalways @ (posedge clk) begin\n    if (a > b) begin\n        magnitude_result <= 3'b001;\n        a_mag <= a;\n        b_mag <= 3'b000;\n    end else if (a < b) begin\n        magnitude_result <= 3'b010;\n        a_mag <= 3'b000;\n        b_mag <= b;\n    end else begin\n        magnitude_result <= 3'b100;\n        a_mag <= 3'b000;\n        b_mag <= 3'b000;\n    end\nend\n\n// Selector Module\nalways @ (posedge clk) begin\n    case (select)\n        2'b00: begin\n            comparison_result <= magnitude_result;\n            input_selected <= 2'b00;\n        end\n        2'b01: begin\n            comparison_result <= magnitude_result;\n            input_selected <= 2'b01;\n        end\n        2'b10: begin\n            comparison_result <= 3'b000;\n            input_selected <= 2'b00;\n        end\n        2'b11: begin\n            comparison_result <= 3'b000;\n            input_selected <= 2'b01;\n        end\n    endcase\nend\n\n// Decoder Module\nalways @ (posedge clk) begin\n    case (comparison_result)\n        3'b001: begin\n            Y0 <= 1'b0;\n            Y1 <= 1'b0;\n            Y2 <= 1'b0;\n            Y3 <= 1'b1;\n        end\n        3'b010: begin\n            Y0 <= 1'b0;\n            Y1 <= 1'b0;\n            Y2 <= 1'b1;\n            Y3 <= 1'b0;\n        end\n        3'b100: begin\n            Y0 <= 1'b0;\n            Y1 <= 1'b1;\n            Y2 <= 1'b0;\n            Y3 <= 1'b0;\n        end\n        default: begin\n            Y0 <= 1'b1;\n            Y1 <= 1'b0;\n            Y2 <= 1'b0;\n            Y3 <= 1'b0;\n        end\n    endcase\nend\n\n// Final Output Module\nalways @ (posedge clk) begin\n    final_output <= {Y3, Y2};\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "one_hot_state_machine_d7a49ff4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule one_hot_state_machine (\n  input clk, // clock signal\n  input rst, // reset signal\n  input [n-1:0] in, // n-bit input signal\n  output [n-1:0] out // n-bit output signal\n);\n\nparameter n = 4; // number of bits in the input and output signals\n\n// define the states as unique one-hot binary codes\nparameter STATE0 = 4'b0001;\nparameter STATE1 = 4'b0010;\nparameter STATE2 = 4'b0100;\nparameter STATE3 = 4'b1000;\n\n// define the state register\nreg [n-1:0] state;\n\n// define the next state logic\nalways @ (posedge clk, posedge rst)\nbegin\n  if (rst) // reset the state to STATE0\n    state <= STATE0;\n  else // determine the next state based on the input signal and the current state\n    case (state)\n      STATE0: state <= (in == 0) ? STATE0 : STATE1;\n      STATE1: state <= (in == 0) ? STATE2 : STATE3;\n      STATE2: state <= (in == 0) ? STATE0 : STATE1;\n      STATE3: state <= (in == 0) ? STATE2 : STATE3;\n    endcase\nend\n\n// define the output logic\nassign out = state;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ALU #_69e5acec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ALU #(\n        parameter DATA_WIDTH            = 32            ,\n        parameter HIGH                  = 1'b1          ,\n        parameter LOW                   = 1'b0          ,\n        \n        parameter ALU_NOP               = 5'b00000      ,\n        parameter ALU_ADD               = 5'b00001      ,\n        parameter ALU_SUB               = 5'b00010      ,\n        parameter ALU_SLL               = 5'b00011      ,\n        parameter ALU_SLT               = 5'b00100      ,\n        parameter ALU_SLTU              = 5'b00101      ,\n        parameter ALU_XOR               = 5'b00110      ,\n        parameter ALU_SRL               = 5'b00111      ,\n        parameter ALU_SRA               = 5'b01000      ,\n        parameter ALU_OR                = 5'b01001      ,\n        parameter ALU_AND               = 5'b01010      ,\n        parameter ALU_SLLI              = 5'b01011      ,\n        parameter ALU_SRLI              = 5'b01100      ,\n        parameter ALU_SRAI              = 5'b01101      ,\n        parameter ALU_JAL               = 5'b01110      ,\n        parameter ALU_JALR              = 5'b01111      ,\n        parameter ALU_BEQ               = 5'b10000      ,\n        parameter ALU_BNE               = 5'b10001      ,\n        parameter ALU_BLT               = 5'b10010      ,\n        parameter ALU_BGE               = 5'b10011      ,\n        parameter ALU_BLTU              = 5'b10100      ,\n        parameter ALU_BGEU              = 5'b10101      \n    ) (\n        input   [DATA_WIDTH - 1  : 0]   ALU_IN1           ,\n        input   [DATA_WIDTH - 1  : 0]   ALU_IN2           ,\n        input   [DATA_WIDTH - 1  : 0]   PC_IN             ,\n        input   [4               : 0]   ALU_INSTRUCTION   ,\n        output  [DATA_WIDTH - 1  : 0]   ALU_OUT           ,\n        output                          BRANCH_TAKEN\n    );\n   \n    reg  [DATA_WIDTH - 1  : 0]  alu_out_reg         ;\n    reg                         branch_taken_reg    ;\n    \n    always@(*)\n    begin\n        case(ALU_INSTRUCTION)\n            ALU_NOP:\n            begin\n                alu_out_reg         = 32'b0;\n                branch_taken_reg    = LOW;\n            end\n            ALU_ADD:\n            begin\n                alu_out_reg         = $signed(ALU_IN1) + $signed(ALU_IN2);\n                branch_taken_reg    = LOW;\n            end\n            ALU_SUB:\n            begin\n                alu_out_reg         = $signed(ALU_IN1) - $signed(ALU_IN2);\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLL:\n            begin\n                alu_out_reg         = ALU_IN1 << ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLT:\n            begin\n                if(ALU_IN1 < ALU_IN2)\n                begin\n                    alu_out_reg         = 32'b1;\n                end\n                else\n                begin\n                    alu_out_reg         = 32'b0;\n                end\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLTU:\n            begin\n                if($signed(ALU_IN1) < $signed(ALU_IN2))\n                begin\n                    alu_out_reg         = 32'b1;\n                end\n                else\n                begin\n                    alu_out_reg         = 32'b0;\n                end\n                branch_taken_reg    = LOW;\n            end\n            ALU_XOR:\n            begin\n                alu_out_reg         = ALU_IN1 ^ ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRL:\n            begin\n                alu_out_reg         = ALU_IN1 >> ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRA:\n            begin\n                alu_out_reg         = ALU_IN1 >>> ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_OR:\n            begin\n                alu_out_reg         = ALU_IN1 | ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_AND:\n            begin\n                alu_out_reg         = ALU_IN1 & ALU_IN2;\n                branch_taken_reg    = LOW;\n            end\n            ALU_SLLI:\n            begin\n                alu_out_reg         = ALU_IN1 << ALU_IN2[4:0];\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRLI:\n            begin\n                alu_out_reg         = ALU_IN1 >> ALU_IN2[4:0];\n                branch_taken_reg    = LOW;\n            end\n            ALU_SRAI:\n            begin\n                alu_out_reg         = ALU_IN1 >>> ALU_IN2[4:0];\n                branch_taken_reg    = LOW;\n            end\n            ALU_JAL:\n            begin\n                alu_out_reg         = ALU_IN1 + 4;\n                branch_taken_reg    = LOW;\n            end\n            ALU_JALR:\n            begin\n                alu_out_reg         = PC_IN + 4;\n                branch_taken_reg    = LOW;\n            end\n            ALU_BEQ:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 == ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BNE:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 != ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BLT:\n            begin\n                alu_out_reg         = 32'b0;\n                if($signed(ALU_IN1) < $signed(ALU_IN2))\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BGE:\n            begin\n                alu_out_reg         = 32'b0;\n                if($signed(ALU_IN1) >= $signed(ALU_IN2))\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BLTU:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 == ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end\n            ALU_BGEU:\n            begin\n                alu_out_reg         = 32'b0;\n                if(ALU_IN1 >= ALU_IN2)\n                begin\n                    branch_taken_reg    = HIGH;\n                end\n                else\n                begin\n                    branch_taken_reg    = LOW;\n                end\n            end      \n            default:\n            begin\n                alu_out_reg         = 32'b0;\n                branch_taken_reg    = LOW;\n            end\n        endcase\n    end\n    \n    assign  ALU_OUT         = alu_out_reg       ;\n    assign  BRANCH_TAKEN    = branch_taken_reg  ;\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__a221o_446f80b4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_hd__a221o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2                );\n    and and1 (and1_out , A1, A2                );\n    or  or0  (or0_out_X, and1_out, and0_out, C1);\n    buf buf0 (X        , or0_out_X             );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_adder_42bbb554", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_adder(\n    input [3:0] in1,\n    input [3:0] in2,\n    input ctrl,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] temp_sum;\n    assign temp_sum = {1'b0, in1} + {1'b0, in2};\n\n    assign sum = (ctrl == 1'b0) ? temp_sum[3:0] : temp_sum[4];\n    assign cout = temp_sum[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_aa905083", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_4to1 (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input sel0,\n  input sel1,\n  output reg out\n);\n\nalways @(*) begin\n  if (sel0 == 0 && sel1 == 0) begin\n    out = in0;\n  end else if (sel0 == 1 && sel1 == 0) begin\n    out = in1;\n  end else if (sel0 == 0 && sel1 == 1) begin\n    out = in2;\n  end else if (sel0 == 1 && sel1 == 1) begin\n    out = in3;\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "crossbar36_f8bbce5c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule crossbar36\n  (input clk, input reset, input clear,\n   input cross,\n   input [35:0] data0_i, input src0_rdy_i, output dst0_rdy_o,\n   input [35:0] data1_i, input src1_rdy_i, output dst1_rdy_o,\n   output [35:0] data0_o, output src0_rdy_o, input dst0_rdy_i,\n   output [35:0] data1_o, output src1_rdy_o, input dst1_rdy_i);\n\n   reg \t\t cross_int, active0, active1;\n   wire active0_next = (src0_rdy_i & dst0_rdy_o)? ~data0_i[33] : active0;\n   wire active1_next = (src1_rdy_i & dst1_rdy_o)? ~data1_i[33] : active1;\n\n   assign data0_o = cross_int ? data1_i : data0_i;\n   assign data1_o = cross_int ? data0_i : data1_i;\n\n   assign src0_rdy_o = cross_int ? src1_rdy_i : src0_rdy_i;\n   assign src1_rdy_o = cross_int ? src0_rdy_i : src1_rdy_i;\n\n   assign dst0_rdy_o = cross_int ? dst1_rdy_i : dst0_rdy_i;\n   assign dst1_rdy_o = cross_int ? dst0_rdy_i : dst1_rdy_i;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active0 <= 0;\n     else\n       active0 <= active0_next;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active1 <= 0;\n     else\n       active1 <= active1_next;\n\n   always @(posedge clk)\n     if(reset | clear)\n       cross_int <= 0;\n     else if(~active0_next & ~active1_next)\n       cross_int <= cross;\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_13594c07", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module(\n    input [3:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    input [1:0] select,\n    output [1:0] pos,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    output [2:0] out\n);\n    functional_module fm(.in(in), .a(a), .b(b), .select(select), .pos(pos), .out_or_bitwise(out_or_bitwise), .out_or_logical(out_or_logical), .out_not(out_not), .out(out));\nendmodule\n\nmodule functional_module(\n    input [3:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    input [1:0] select, // Added the select input port\n    output [1:0] pos,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    output [2:0] out\n);\n    priority_encoder pe(.in(in), .pos(pos));\n    binary_module bm(.a(a), .b(b), .out_or_bitwise(out_or_bitwise), .out_or_logical(out_or_logical), .out_not(out_not));\n    assign out = (select == 0) ? pos :\n                 (select == 1) ? {out_or_bitwise, out_or_logical, out_not[5:3]} :\n                                 {out_or_bitwise & out_not[2:0], out_or_logical & out_not[2:0]};\nendmodule\n\nmodule priority_encoder(\n    input [3:0] in,\n    output [1:0] pos\n);\n    assign pos = (in[3]) ? 2'b11 :\n                 (in[2]) ? 2'b10 :\n                 (in[1]) ? 2'b01 :\n                 (in[0]) ? 2'b00 :\n                           2'b00 ;\nendmodule\n\nmodule binary_module(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = (a || b);\n    assign out_not = ~{a, b};\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "READ_ROM32_d64f6702", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule READ_ROM32 ( input[4:0] ADDR ,output[31:0] DATA_RE,output[31:0] DATA_IM);\nreg [31:0] re[0:31];\ninitial  begin\nre[0] = 32'h00000000;re[1] = 32'hFFE4CC88;re[2] = 32'h002DA5B3;re[3] = 32'hFFCE9932;\nre[4] = 32'h00254173;re[5] = 32'hFFF2E19A;re[6] = 32'hFFF0C26D;re[7] = 32'h0026B1CD;\nre[8] = 32'hFFCE4E3A;re[9] = 32'h002CB328;re[10] = 32'hFFE6AE85;re[11] = 32'hFFFDC9B2;\nre[12] = 32'h001D07D3;re[13] = 32'hFFD17EA5;re[14] = 32'h00310311;re[15] = 32'hFFDC4195;\nre[16] = 32'h000AF8A5;re[17] = 32'h0011551D;re[18] = 32'hFFD7F13F;re[19] = 32'h0031E3D5;\nre[20] = 32'hFFD455CB;re[21] = 32'h001762CC;re[22] = 32'h00046B81;re[23] = 32'hFFE13261;\nre[24] = 32'h002F45B3;re[25] = 32'hFFCF793E;re[26] = 32'h00222978;re[27] = 32'hFFF7329D;\nre[28] = 32'hFFEC9C0A;re[29] = 32'h002957A0;re[30] = 32'hFFCE0320;re[31] = 32'h002A8B5D;\nend\nreg [31:0] im[0:31];\ninitial  begin\nim[0] = 32'h00000000;im[1] = 32'h00000000;im[2] = 32'h00000000;im[3] = 32'h00000000;\nim[4] = 32'h00000000;im[5] = 32'h00000000;im[6] = 32'h00000000;im[7] = 32'h00000000;\nim[8] = 32'h00000000;im[9] = 32'h00000000;im[10] = 32'h00000000;im[11] = 32'h00000000;\nim[12] = 32'h00000000;im[13] = 32'h00000000;im[14] = 32'h00000000;im[15] = 32'h00000000;\nim[16] = 32'h00000000;im[17] = 32'h00000000;im[18] = 32'h00000000;im[19] = 32'h00000000;\nim[20] = 32'h00000000;im[21] = 32'h00000000;im[22] = 32'h00000000;im[23] = 32'h00000000;\nim[24] = 32'h00000000;im[25] = 32'h00000000;im[26] = 32'h00000000;im[27] = 32'h00000000;\nim[28] = 32'h00000000;im[29] = 32'h00000000;im[30] = 32'h00000000;im[31] = 32'h00000000;\nend\nassign DATA_RE = re[ADDR];\nassign DATA_IM = im[ADDR];\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__2510f05b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input sel,\n    output [7:0] q\n);\n\nreg [7:0] q_int;\nreg [3:0] dff_sel;\n\nalways @(negedge clk) begin\n    q_int <= {q_int[6:0], d[0]};\n    dff_sel <= sel ? dff_sel + 1 : dff_sel - 1;\nend\n\nassign q = (dff_sel[3]) ? {q_int[7:4], q_int[3:0]} : {q_int[3:0], q_int[7:4]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_operations_with_adder_b2b044b9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_operations_with_adder (\n  input [31:0] a,\n  input [31:0] b,\n  input [1:0] operation_select,\n  input [4:0] shift_amount,\n  input [15:0] adder_input,\n  input select, \n  output reg [31:0] bitwise_result,\n  output reg [31:0] adder_result\n);\n\n  // Bitwise operations module\n  wire [31:0] and_result = a & b;\n  wire [31:0] or_result = a | b;\n  wire [31:0] xor_result = a ^ b;\n  wire [31:0] shift_left_result = a << shift_amount;\n\n  // Functional module\n  wire [31:0] functional_result = and_result;\n  always @(*) begin\n    adder_result = functional_result + adder_input;\n  end\n\n  // Control logic module\n  always @* begin\n    case(operation_select)\n      2'b00: bitwise_result = and_result;\n      2'b01: bitwise_result = or_result;\n      2'b10: bitwise_result = xor_result;\n      2'b11: bitwise_result = shift_left_result;\n    endcase\n\n    if(select) begin\n      bitwise_result = functional_result;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spi2_7fe2cc96", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule spi2(\n\n\tclock, sck,   sdo,   sdi,   bsync, start, rdy,   speed, din,  dout  );\n\n\tinput clock;\n\n\n\toutput sck;\n\twire   sck;\n\n\toutput sdo;\n\n\tinput sdi;\n\n\toutput reg bsync;\n\n\tinput start;\n\n\toutput rdy;\n\n\n\tinput [1:0] speed;\n\n\tinput [7:0] din;\n\n\toutput reg [7:0] dout;\n\n\n\n\treg [4:0] counter; wire enable_n; reg [6:0] shiftin; reg [7:0] shiftout; wire ena_shout_load; wire g_ena;\n\treg [2:0] wcnt;\n\n\n\tinitial begin\n\t\tcounter = 5'b10000;\n\t\tshiftout = 8'd0;\n\t\tshiftout = 7'd0;\n\t\tbsync = 1'd0;\n\t\tdout = 1'b0;\n\tend\n\n\n\tassign rdy = enable_n;\n\n\tassign sck = counter[0];\n\n\tassign enable_n = counter[4];\n\n\tassign sdo = shiftout[7];\n\n\tassign ena_shout_load = (start | sck) & g_ena;\n\n\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( g_ena )\n\t\tbegin\n\t\t\tif( start )\n\t\t\tbegin\n\t\t\t\tcounter <= 5'b00000; bsync <= 1'b1; end\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif( !sck ) begin\n      \t                  shiftin[6:0] <= { shiftin[5:0], sdi };\n\n\t\t\t\t\tif( (&counter[3:1]) && (!enable_n) )\n\t\t\t\t\t\tdout <= { shiftin[6:0], sdi }; end\n\t\t\t\telse begin\n\t\t\t\t\tbsync <= 1'b0;\n\t\t\t\tend\n\n\t\t\t\tif( !enable_n )\n\t\t\t\t\tcounter <= counter + 5'd1;\n\t\t\tend\n\t\tend\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( ena_shout_load )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\tshiftout <= din;\n\t\t\telse shiftout[7:0] <= { shiftout[6:0], shiftout[0] }; end\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( speed!=2'b00 )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\twcnt <= 3'b001;\n\t\t\telse if( enable_n )\n\t\t\t\twcnt <= 3'b000;\n\t\t\telse\n\t\t\t\twcnt <= wcnt + 3'd1;\n\t\tend\n\t\telse\n\t\t\twcnt <= 3'b000;\n\tend\n\n\tassign g_ena = (speed==2'b00) ? 1'b1 :\n\t               (speed==2'b01) ? (wcnt[0]  == 1'b0   ) :\n\t               (speed==2'b10) ? (wcnt[1:0]== 2'b00  ) :\n\t                                (wcnt[2:0]== 3'b000 ) ;\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_nor4_580247e6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_nor4 (\n    Y  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    wire AB, CD, ABCD;\n    \n    assign AB = ~(A | B);\n    assign CD = ~(C | D_N);\n    assign ABCD = ~(AB | CD);\n    \n    assign Y = ABCD;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Update_Count_From_AB_d2dba0d1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule Update_Count_From_AB\n          (\n           CLK_IN,\n           reset,\n           enb,\n           A,\n           B,\n           index,\n           count_max,\n           count\n          );\n\n\n  input   CLK_IN;\n  input   reset;\n  input   enb;\n  input   A;\n  input   B;\n  input   index;\n  input   signed [15:0] count_max;  output  signed [15:0] count;  parameter IN_NO_ACTIVE_CHILD = 0, IN_A0_B0 = 1, IN_A0_B1 = 2, IN_A1_B0 = 3, IN_A1_B1 = 4;\n  parameter IN_INDEX = 0, IN_INIT = 1;\n\n  reg [1:0] is_libEncoderPeripheralHdl_c7_Update_Count_From_AB;  reg [2:0] is_INDEX;  reg signed [15:0] count_reg;  reg [1:0] is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next;  reg [2:0] is_INDEX_next;  reg signed [15:0] count_reg_next;  always @(posedge CLK_IN)\n    begin : libEncoderPeripheralHdl_c7_Update_Count_From_AB_process\n      if (reset == 1'b1) begin\n        is_INDEX <= IN_NO_ACTIVE_CHILD;\n        count_reg <= 16'sd0;\n        is_libEncoderPeripheralHdl_c7_Update_Count_From_AB <= IN_INIT;\n      end\n      else if (enb) begin\n        is_libEncoderPeripheralHdl_c7_Update_Count_From_AB <= is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next;\n        is_INDEX <= is_INDEX_next;\n        count_reg <= count_reg_next;\n      end\n    end\n\n  always @(is_libEncoderPeripheralHdl_c7_Update_Count_From_AB, is_INDEX, A, B, index,\n       count_max, count_reg) begin\n    count_reg_next = count_reg;\n    is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next = is_libEncoderPeripheralHdl_c7_Update_Count_From_AB;\n    is_INDEX_next = is_INDEX;\n    case ( is_libEncoderPeripheralHdl_c7_Update_Count_From_AB)\n      IN_INDEX :\n        begin\n          if (index == 1'b1) begin\n            count_reg_next = 16'sd0;\n            is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next = IN_INDEX;\n            is_INDEX_next = IN_A0_B0;\n          end\n          else begin\n\n            case ( is_INDEX)\n              IN_A0_B0 :\n                begin\n                  if (A && ( ~ B)) begin\n                    count_reg_next = count_reg + 1;\n                    if ((count_reg + 16'sd1) > count_max) begin\n                      count_reg_next = 16'sd0;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A1_B0;\n                  end\n                  else if (( ~ A) && B) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A0_B1;\n                  end\n                end\n              IN_A0_B1 :\n                begin\n                  if (A && B) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A1_B1;\n                  end\n                  else begin\n                    if (( ~ A) && ( ~ B)) begin\n                      count_reg_next = count_reg + 1;\n                      if ((count_reg + 16'sd1) > count_max) begin\n                        count_reg_next = 16'sd0;\n                        end\n                      else begin\n                        end\n                      is_INDEX_next = IN_A0_B0;\n                    end\n                  end\n                end\n              IN_A1_B0 :\n                begin\n                  if (( ~ A) && ( ~ B)) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A0_B0;\n                  end\n                  else begin\n                    if (A && B) begin\n                      count_reg_next = count_reg + 1;\n                      if ((count_reg + 16'sd1) > count_max) begin\n                        count_reg_next = 16'sd0;\n                        end\n                      else begin\n                        end\n                      is_INDEX_next = IN_A1_B1;\n                    end\n                  end\n                end\n              default :\n                begin\n                  if (( ~ A) && B) begin\n                    count_reg_next = count_reg + 1;\n                    if ((count_reg + 16'sd1) > count_max) begin\n                      count_reg_next = 16'sd0;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A0_B1;\n                  end\n                  else if (A && ( ~ B)) begin\n                    count_reg_next = count_reg - 1;\n                    if ((count_reg - 16'sd1) < 16'sb0000000000000000) begin\n                      count_reg_next = count_max;\n                      end\n                    else begin\n                      end\n                    is_INDEX_next = IN_A1_B0;\n                  end\n                end\n            endcase\n\n          end\n        end\n      default :\n        begin\n          count_reg_next = 16'sd0;\n          is_libEncoderPeripheralHdl_c7_Update_Count_From_AB_next = IN_INDEX;\n          is_INDEX_next = IN_A0_B0;\n        end\n    endcase\n\n  end\n\n  assign count = count_reg_next;\n\n\n\nendmodule  "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "video_timing_gen_32cd4b9e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule video_timing_gen (\n  input aclk, rst,\n  input axis_tready, axis_tvalid,\n  input [23:0] axis_video,\n  input axis_eol, axis_sof,\n  input [1:0] fid,\n  input [11:0] active_pixels,\n  input [11:0] active_lines,\n  output reg video_clk, ce,\n  output [11:0] total_lines,\n  output [11:0] vsync_start, vsync_end,\n  output [11:0] total_pixels,\n  output [11:0] hsync_start, hsync_end,\n  output reg vtg_hsync, vtg_vsync, vtg_vblank, vtg_hblank, vtg_act_vid,\n  output reg [1:0] vtg_field_id\n);\n\n  // Constants\n  parameter H_SYNC_WIDTH = 96;\n  parameter H_BLANK_WIDTH = 208;\n  parameter V_SYNC_WIDTH = 2;\n  parameter V_BLANK_WIDTH = 35;\n\n  // Internal signals\n  reg [11:0] line_count = 0;\n  reg [11:0] pixel_count = 0;\n  reg [11:0] vsync_start_time = 0;\n  reg [11:0] vsync_end_time = 0;\n  reg [11:0] hsync_start_time = 0;\n  reg [11:0] hsync_end_time = 0;\n  reg [11:0] total_pixels_reg = 0;\n  reg [11:0] total_lines_reg = 0;\n  reg [1:0] field_id_reg = 0;\n\n  // Video data input\n  reg [7:0] r, g, b;\n\n  always @(posedge aclk) begin\n    if (rst) begin\n      video_clk <= 0;\n      ce <= 0;\n      line_count <= 0;\n      pixel_count <= 0;\n      vsync_start_time <= 0;\n      vsync_end_time <= 0;\n      hsync_start_time <= 0;\n      hsync_end_time <= 0;\n      total_pixels_reg <= 0;\n      total_lines_reg <= 0;\n      field_id_reg <= 0;\n      vtg_hsync <= 0;\n      vtg_vsync <= 0;\n      vtg_vblank <= 0;\n      vtg_hblank <= 0;\n      vtg_act_vid <= 0;\n      vtg_field_id <= 0;\n    end else begin\n      // Video timing generator\n      if (line_count < active_lines) begin\n        vtg_act_vid <= 1;\n      end else begin\n        vtg_act_vid <= 0;\n      end\n      if (line_count < active_lines + V_SYNC_WIDTH) begin\n        vtg_vsync <= 0;\n      end else if (line_count < active_lines + V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vtg_vsync <= 1;\n        vtg_vblank <= 1;\n      end else if (line_count < 2*active_lines + V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vtg_vsync <= 0;\n        vtg_vblank <= 0;\n      end else if (line_count < 2*active_lines + 2*V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vtg_vsync <= 1;\n        vtg_vblank <= 1;\n      end else begin\n        vtg_vsync <= 0;\n        vtg_vblank <= 0;\n      end\n      if (pixel_count < active_pixels) begin\n        vtg_hsync <= 1;\n        vtg_hblank <= 0;\n        vtg_field_id <= field_id_reg;\n      end else if (pixel_count < active_pixels + H_SYNC_WIDTH) begin\n        vtg_hsync <= 0;\n        vtg_hblank <= 0;\n      end else if (pixel_count < active_pixels + H_SYNC_WIDTH + H_BLANK_WIDTH) begin\n        vtg_hsync <= 0;\n        vtg_hblank <= 1;\n      end else begin\n        vtg_hsync <= 0;\n        vtg_hblank <= 0;\n        pixel_count <= 0;\n        line_count <= line_count + 1;\n        if (line_count >= 2*active_lines + 2*V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n          line_count <= 0;\n          total_lines_reg <= total_lines_reg + 1;\n          field_id_reg <= ~field_id_reg;\n        end\n      end\n\n      // Video clock generator\n      if (pixel_count == active_pixels - 1) begin\n        video_clk <= 1;\n        total_pixels_reg <= total_pixels_reg + active_pixels;\n        pixel_count <= 0;\n        ce <= 1;\n      end else begin\n        video_clk <= 0;\n        pixel_count <= pixel_count + 1;\n        ce <= 0;\n      end\n\n      // Video data input\n      if (axis_tvalid && axis_tready) begin\n        r <= axis_video[23:16];\n        g <= axis_video[15:8];\n        b <= axis_video[7:0];\n      end\n\n      // Vertical sync pulse timing\n      if (line_count == active_lines + V_SYNC_WIDTH) begin\n        vsync_start_time <= total_pixels_reg + pixel_count;\n      end\n      if (line_count == active_lines + V_SYNC_WIDTH + V_BLANK_WIDTH) begin\n        vsync_end_time <= total_pixels_reg + pixel_count;\n      end\n\n      // Horizontal sync pulse timing\n      if (pixel_count == active_pixels + H_SYNC_WIDTH) begin\n        hsync_start_time <= total_pixels_reg + pixel_count;\n      end\n      if (pixel_count == active_pixels + H_SYNC_WIDTH + H_BLANK_WIDTH) begin\n        hsync_end_time <= total_pixels_reg + pixel_count;\n      end\n    end\n  end\n\n  assign total_pixels = total_pixels_reg;\n  assign total_lines = total_lines_reg;\n  assign vsync_start = vsync_start_time;\n  assign vsync_end = vsync_end_time;\n  assign hsync_start = hsync_start_time;\n  assign hsync_end = hsync_end_time;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "airplane_8bca4180", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule airplane(\n\tinput clk,\n\tinput rst,\n\tinput [10:0] x,\n\tinput [10:0] y,\n\tinput [10:0] poX,\n\tinput [10:0] poY,\n\toutput reg wing,\n\toutput reg body\n);\n\nparameter pL = 40;\nparameter pW = 10;\nparameter wL = 15;\nparameter wW = 15;\nparameter wP = 15;\n\n// body\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) body <= 0;\n\telse begin\n\t\tif(x < poX+pL && x > poX && y < poY+wL+pW && y >poY+wL) body <= 1;\n\t\telse body <= 0;\n\tend\nend\n\n// wing\nalways@(posedge clk, posedge rst)\nbegin\n\tif(rst) wing <= 0;\n\telse begin\n\t\tif(x < poX+wP+wW && x > poX+wP && y < poY+wL && y > poY && x-y-poX+poY < wP) wing <= 1;\n\t\telse if(x < poX+wP+wW && x > poX+wP && y > poY+wL+pW && y < poY+wL+wL+pW && x-poX+y-poY < wP+pL) wing <= 1;\n\t\telse wing <= 0;\n\tend\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_4input_nand_469c6b70", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_4input_nand (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D   \n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    \n    wire nand1_out;\n    wire nand2_out;\n    wire nand3_out;\n    \n    nand (\n        nand1_out,\n        A,\n        B,\n        C,\n        D\n    );\n    \n    nand (\n        nand2_out,\n        nand1_out,\n        nand1_out\n    );\n    \n    not (\n        nand3_out,\n        nand2_out\n    );\n    \n    assign Y = nand3_out;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "message_formatter #_05a4738f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule message_formatter #\n(\nparameter WIDTH = 24,       parameter COUNT = 2,        parameter TX_INTERVAL = 4   )\n(\ninput  wire CLK,\ninput  wire RST,\n\ninput  wire I_STB,\ninput  wire [(WIDTH*COUNT)-1:0] I_DAT,\n\noutput wire O_STB,\noutput wire [7:0] O_DAT\n);\n\nlocalparam TOTAL_WIDTH = WIDTH * COUNT;\n\ninteger fsm;\n\nlocalparam FSM_IDLE     = 'h00;\nlocalparam FSM_TX_HEX   = 'h11;\nlocalparam FSM_TX_CR    = 'h21;\nlocalparam FSM_TX_LF    = 'h22;\nlocalparam FSM_TX_SEP   = 'h31;\n\nreg [24:0]  tx_dly_cnt;\nreg         tx_req;\nwire        tx_rdy;\n\nalways @(posedge CLK)\n    if (RST)\n        tx_dly_cnt <= -1;\n    else if (!tx_rdy)\n        tx_dly_cnt <= tx_dly_cnt  - 1;\n    else if ( tx_rdy && tx_req)\n        tx_dly_cnt <= TX_INTERVAL - 2;\n\nassign tx_rdy = tx_dly_cnt[24];\n\nalways @(posedge CLK)\n    if (RST)\n        tx_req <= 1'b0;\n    else case (fsm)\n\n    FSM_TX_HEX: tx_req <= 1'b1;\n    FSM_TX_SEP: tx_req <= 1'b1;\n    FSM_TX_CR:  tx_req <= 1'b1;\n    FSM_TX_LF:  tx_req <= 1'b1;\n\n    default:    tx_req <= 1'b0;\n\n    endcase\n\nreg  [7:0] char_cnt;\nreg  [7:0] word_cnt;\n\nalways @(posedge CLK)\n    if (fsm == FSM_IDLE || fsm == FSM_TX_SEP)\n        char_cnt <= (WIDTH/4) - 1;\n    else if (tx_rdy && fsm == FSM_TX_HEX)\n        char_cnt <= char_cnt - 1;\n\nalways @(posedge CLK)\n    if (fsm == FSM_IDLE)\n        word_cnt <= COUNT - 1;\n    else if (tx_rdy && fsm == FSM_TX_SEP)\n        word_cnt <= word_cnt - 1;\n\nreg  [TOTAL_WIDTH-1:0] sr_reg;\nwire [3:0] sr_dat;\n\nalways @(posedge CLK)\n    if (fsm == FSM_IDLE && I_STB)\n        sr_reg <= I_DAT;\n    else if (fsm == FSM_TX_HEX && tx_rdy)\n        sr_reg <= sr_reg << 4;\n\nassign sr_dat = sr_reg[TOTAL_WIDTH-1:TOTAL_WIDTH-4];\n\nalways @(posedge CLK)\n    if (RST)\n        fsm <= FSM_IDLE;\n    else case (fsm)\n\n    FSM_IDLE:   if (I_STB) fsm <= FSM_TX_HEX;\n\n    FSM_TX_HEX:\n                if (tx_rdy && (char_cnt == 0) && (word_cnt == 0))\n                    fsm <= FSM_TX_CR;\n                else if (tx_rdy && (char_cnt == 0)) fsm <= FSM_TX_SEP;\n                else if (tx_rdy && (char_cnt != 0)) fsm <= FSM_TX_HEX;\n\n    FSM_TX_SEP: if (tx_rdy) fsm <= FSM_TX_HEX;\n    FSM_TX_CR:  if (tx_rdy) fsm <= FSM_TX_LF;\n    FSM_TX_LF:  if (tx_rdy) fsm <= FSM_IDLE;\n\n    endcase\n\nreg        o_stb;\nreg  [7:0] o_dat;\n\nalways @(posedge CLK or posedge RST)\n    if (RST)\n        o_stb <= 1'd0;\n    else\n        o_stb <= tx_req & tx_rdy;\n\nalways @(posedge CLK)\n    if      (fsm == FSM_TX_CR)\n        o_dat <= 8'h0D;\n    else if (fsm == FSM_TX_LF)\n        o_dat <= 8'h0A;\n    else if (fsm == FSM_TX_SEP)\n        o_dat <= \"_\";\n    else if (fsm == FSM_TX_HEX) case (sr_dat)\n        4'h0: o_dat <= \"0\";\n        4'h1: o_dat <= \"1\";\n        4'h2: o_dat <= \"2\";\n        4'h3: o_dat <= \"3\";\n        4'h4: o_dat <= \"4\";\n        4'h5: o_dat <= \"5\";\n        4'h6: o_dat <= \"6\";\n        4'h7: o_dat <= \"7\";\n        4'h8: o_dat <= \"8\";\n        4'h9: o_dat <= \"9\";\n        4'hA: o_dat <= \"A\";\n        4'hB: o_dat <= \"B\";\n        4'hC: o_dat <= \"C\";\n        4'hD: o_dat <= \"D\";\n        4'hE: o_dat <= \"E\";\n        4'hF: o_dat <= \"F\";\n    endcase\n\nassign O_STB = o_stb;\nassign O_DAT = o_dat;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dataprocessor_e81e36d7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dataprocessor(\n    input wire [9:0] datain,\n    input wire clk,\n    input wire reset,\n    output reg [9:0] dataout,\n    output reg validout\n);\n\nalways @(posedge clk) begin\n    if (reset == 1'b1) begin\n        dataout <= 0;\n        validout <= 0;\n    end else begin\n        if (datain >= 10'd100) begin\n            dataout <= datain;\n            validout <= 1;\n        end else begin\n            dataout <= 0;\n            validout <= 0;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cycloneii_mac_sign_ext_bc6d7a1e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cycloneii_mac_sign_ext (\n  input clk,\n  input signed [15:0] data_in_a,\n  input signed [15:0] data_in_b,\n  input enable,\n  output signed [31:0] result\n);\n\n  wire [31:0] mult_result;\n  wire [31:0] sign_ext_result;\n  reg signed [31:0] accum_result;\n\n  // Perform signed multiplication of input data\n  assign mult_result = data_in_a * data_in_b;\n\n  // Sign-extend the multiplication result to 32 bits\n  assign sign_ext_result = {{16{mult_result[15]}}, mult_result[15:0]};\n\n  // Update the accumulator result on the rising edge of the clock if enable is high\n  always @(posedge clk) begin\n    if (enable) begin\n      accum_result <= accum_result + sign_ext_result;\n    end\n  end\n\n  // Assign the accumulator result to the output\n  assign result = accum_result;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sample_generator_9ae3a4eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sample_generator (\n  input wire [7:0] FrameSize,\n  input wire En,\n  input wire AXI_En,\n  output wire [31:0] m_axis_tdata,\n  output wire [3:0] m_axis_tstrb,\n  output wire m_axis_tlast,\n  output wire m_axis_tvalid,\n  input wire m_axis_tready,\n  input wire m_axis_aclk,\n  input wire m_axis_aresetn,\n  input wire [31:0] s_axis_tdata,\n  input wire [3:0] s_axis_tstrb,\n  input wire s_axis_tlast,\n  input wire s_axis_tvalid,\n  output wire s_axis_tready,\n  input wire s_axis_aclk,\n  input wire s_axis_aresetn\n);\n\n  // Local parameters\n  localparam IDLE = 0, START = 1, DATA = 2, END = 3;\n  \n  // Local variables\n  reg [7:0] frame_count = 0;\n  reg [31:0] data_count = 0;\n  reg [31:0] data = 0;\n  reg [3:0] strb = 0;\n  reg [1:0] state = IDLE;\n  reg valid = 0;\n  reg last = 0;\n  \n  // AXI4Stream interface\n  assign s_axis_tready = (state == DATA) ? m_axis_tready : 1'b0;\n  assign m_axis_tdata = data;\n  assign m_axis_tstrb = strb;\n  assign m_axis_tlast = last;\n  assign m_axis_tvalid = valid;\n  \n  // State machine\n  always @(posedge m_axis_aclk) begin\n    if (!m_axis_aresetn) begin\n      frame_count <= 0;\n      data_count <= 0;\n      data <= 0;\n      strb <= 0;\n      state <= IDLE;\n      valid <= 0;\n      last <= 0;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (En && AXI_En) begin\n            frame_count <= frame_count + 1;\n            data_count <= 0;\n            state <= START;\n          end\n        end\n        START: begin\n          valid <= 1;\n          if (s_axis_tready) begin\n            state <= DATA;\n          end\n        end\n        DATA: begin\n          valid <= 1;\n          data_count <= data_count + 4;\n          data <= data_count;\n          strb <= 4'b1111;\n          if (data_count + 4 >= FrameSize) begin\n            last <= 1;\n            state <= END;\n          end\n        end\n        END: begin\n          valid <= 1;\n          if (s_axis_tready) begin\n            last <= 0;\n            if (frame_count == 255) begin\n              state <= IDLE;\n            end else begin\n              state <= START;\n            end\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder4_f7c73eeb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder4 (\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] temp_sum;\n  wire c1, c2, c3;\n\n  // First stage of addition\n  full_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(temp_sum[0]), .cout(c1));\n\n  // Second stage of addition\n  full_adder fa2(.a(a[1]), .b(b[1]), .cin(c1), .sum(temp_sum[1]), .cout(c2));\n\n  // Third stage of addition\n  full_adder fa3(.a(a[2]), .b(b[2]), .cin(c2), .sum(temp_sum[2]), .cout(c3));\n\n  // Fourth stage of addition\n  full_adder fa4(.a(a[3]), .b(b[3]), .cin(c3), .sum(temp_sum[3]), .cout(cout));\n\n  assign sum = temp_sum;\n\nendmodule\n\nmodule full_adder (\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (cin & a) | (cin & b);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "output_signal__7f1df17d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule output_signal_module (\n  input        clk,\n  input        reset,\n  input  [15:0] input_signal,\n  output [3:0] output_signal\n);\n\n  reg [3:0] output_reg;\n\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      output_reg <= 4'b0;\n    end else begin\n      output_reg <= input_signal[15:12];\n    end\n  end\n\n  assign output_signal = output_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "map_table_e99c0b3a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule map_table(\n    output [5:0] p_rs, p_rt,\n    output p_rs_v, p_rt_v,\n    output [5:0] PR_old_rd,\n    \n    input clk, rst,\n    \n    input hazard_stall, input isDispatch,\n    input [4:0] l_rs, l_rt, l_rd,\n    input RegDest,\n    input [5:0] p_rd_new,\n\n    input [4:0] recover_rd,\n    input [5:0] p_rd_flush,\n    input recover,\n    input RegDest_ROB,\n    \n    input [5:0] p_rd_compl,\n    input complete,\n    input RegDest_compl  \n);\n\nreg [5:0] mt [0:31];\nreg [63:0] PR_valid;  wire write_new_rd;\ninteger i;\n\nassign write_new_rd = isDispatch && RegDest && !hazard_stall && !recover;\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin                             for (i = 0; i < 32; i = i + 1) begin\n            mt[i] <= i;\n        end\n    end\n    else if (write_new_rd)\n        mt[l_rd] <= p_rd_new;\n    else if (RegDest_ROB && recover) \n        mt[recover_rd] <= p_rd_flush;     \nend\n\nassign p_rs = mt[l_rs];\nassign p_rt = mt[l_rt];\nassign PR_old_rd = mt[l_rd];  \nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        PR_valid <= 64'hFFFFFFFFFFFFFFFF;\n    end\n    else begin\n        if (write_new_rd)\n            PR_valid[p_rd_new] <= 1'b0;  \n        if (complete && RegDest_compl)  PR_valid[p_rd_compl] <= 1'b1; end\nend\n\nassign p_rs_v = PR_valid[p_rs];\nassign p_rt_v = PR_valid[p_rt];     \n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_to_color_023f8aea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule memory_to_color(\n  input  [1:0]  color_depth_i,\n  input  [31:0] mem_i,\n  input  [1:0]  mem_lsb_i,\n  output [31:0] color_o,\n  output [3:0]  sel_o\n);\n\n  assign sel_o = (color_depth_i == 2'b00) ? // 8-bit\n                  (mem_lsb_i == 2'b00) ? 4'b0001 : // least significant byte\n                  (mem_lsb_i == 2'b01) ? 4'b0010 : // second least significant byte\n                  (mem_lsb_i == 2'b10) ? 4'b0100 : // third least significant byte\n                  (mem_lsb_i == 2'b11) ? 4'b1000 : // most significant byte\n                  4'bxxxx : // error\n                (color_depth_i == 2'b01) ? // 16-bit\n                  (mem_lsb_i == 2'b0) ? 4'b0011 : // low word\n                  (mem_lsb_i == 2'b1) ? 4'b1100 : // high word\n                  4'bxxxx : // error\n                (color_depth_i == 2'b10) ? 4'b1111 : // 32-bit\n                  4'bxxxx; // error\n\n  assign color_o = (color_depth_i == 2'b00) ? // 8-bit\n                  (mem_lsb_i == 2'b00) ? {mem_i[31:24], 8'h00, 8'h00} : // least significant byte\n                  (mem_lsb_i == 2'b01) ? {8'h00, mem_i[23:16], 8'h00} : // second least significant byte\n                  (mem_lsb_i == 2'b10) ? {8'h00, 8'h00, mem_i[15:8]} : // third least significant byte\n                  (mem_lsb_i == 2'b11) ? {8'h00, 8'h00, 8'h00, mem_i[7:0]} : // most significant byte\n                  32'hxxxxxxxx : // error\n                (color_depth_i == 2'b01) ? // 16-bit\n                  (mem_lsb_i == 2'b0) ? {mem_i[31:16], 16'h0000} : // low word\n                  (mem_lsb_i == 2'b1) ? {16'h0000, mem_i[15:0]} : // high word\n                  32'hxxxxxxxx : // error\n                (color_depth_i == 2'b10) ? // 32-bit\n                  mem_i : // use entire memory data\n                  32'hxxxxxxxx; // error\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_counter_9083b652", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sync_counter (\n    input clk,\n    input reset,\n    output reg [3:0] out\n);\n\nreg [3:0] state = 4'b0000;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 4'b0000;\n        out <= 4'b0000;\n    end else begin\n        case (state)\n            4'b0000: begin\n                state <= 4'b0001;\n                out <= 4'b0000;\n            end\n            4'b0001: begin\n                state <= 4'b0010;\n                out <= 4'b0001;\n            end\n            4'b0010: begin\n                state <= 4'b0011;\n                out <= 4'b0010;\n            end\n            4'b0011: begin\n                state <= 4'b0100;\n                out <= 4'b0011;\n            end\n            4'b0100: begin\n                state <= 4'b0101;\n                out <= 4'b0100;\n            end\n            4'b0101: begin\n                state <= 4'b0110;\n                out <= 4'b0101;\n            end\n            4'b0110: begin\n                state <= 4'b0111;\n                out <= 4'b0110;\n            end\n            4'b0111: begin\n                state <= 4'b1000;\n                out <= 4'b0111;\n            end\n            4'b1000: begin\n                state <= 4'b0000;\n                out <= 4'b1000;\n            end\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "BIU_bb8701d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule BIU(\ninput wire clk,\ninput wire rst,\n\n input  wire      wb_d_ack_i, input  wire      wb_d_err_i, input  wire      wb_d_rty_i, input  wire [31:0]       wb_d_dat_i, output reg      wb_d_cyc_o, output reg [31:0]      wb_d_adr_o, output reg      wb_d_stb_o, output reg      wb_d_we_o,  output reg [3:0]       wb_d_sel_o, output reg [31:0]      wb_d_dat_o, input  wire      wb_c_ack_i, input  wire      wb_c_err_i, input  wire      wb_c_rty_i, input  wire [7:0]       wb_c_dat_i, output reg [31:0]      wb_c_adr_o, output reg      wb_c_stb_o, output reg      wb_c_we_o,  output reg [7:0]      wb_c_dat_o, input wire Cpu_mem_w_i,\ninput wire [31:0] Cpu_data2bus_i,                                   input wire Cpu_req_i,\ninput wire [31:0] Cpu_addr_bus_i,\noutput reg [31:0] Cpu_data4bus_o,\noutput reg Cpu_ready_o,\n\noutput reg MIO_mem_w_o,\noutput reg [31:0] MIO_data2bus_o,                                   output reg [31:0] MIO_addr_bus_o,\ninput wire [31:0] MIO_data4bus_i,\ninput wire MIO_ready_i,\n\noutput reg txt_ena,\noutput reg txt_wea,\noutput reg [12:0] txt_addra,\ninput wire [15:0] txt_dina,\noutput reg [15:0] txt_douta,\n\noutput reg [31:0] gpu_status\n    );\n\nalways @(*) begin\n    MIO_data2bus_o   <= Cpu_data2bus_i;\n    wb_d_dat_o       <= Cpu_data2bus_i;\n    wb_c_dat_o       <= Cpu_data2bus_i;\n    txt_douta        <= Cpu_data2bus_i;\n\n    MIO_addr_bus_o   <= Cpu_addr_bus_i;\n    wb_d_adr_o       <= Cpu_addr_bus_i;\n    wb_c_adr_o       <= Cpu_addr_bus_i;\n    txt_addra        <= Cpu_addr_bus_i;\nend\n\nalways @(*) begin\n    wb_d_sel_o <= 4'b1111;\nend\n\nalways @(*) begin\n    MIO_mem_w_o      <= 0;\n    wb_d_we_o        <= 0;\n    wb_c_we_o        <= 0;\n    txt_wea          <= 0;\n\n    wb_d_cyc_o       <= 0;\n    wb_d_stb_o       <= 0;\n    wb_c_stb_o       <= 0;\n    txt_ena          <= 0;\n\n    Cpu_data4bus_o <= 0;\n    Cpu_ready_o    <= 0;\n\n    case(Cpu_addr_bus_i[31:28])\n        4'h3: begin\n            wb_d_we_o        <= Cpu_mem_w_i;\n            Cpu_data4bus_o   <= wb_d_dat_i;\n            Cpu_ready_o      <= wb_d_ack_i;\n            wb_d_cyc_o       <= Cpu_req_i;\n            wb_d_stb_o       <= Cpu_req_i;\n        end\n        4'hb: if (Cpu_addr_bus_i[27]) begin\n            Cpu_data4bus_o   <= gpu_status;\n            Cpu_ready_o      <= 1'b1;\n        end else begin\n            txt_wea          <= Cpu_mem_w_i;\n            Cpu_data4bus_o   <= txt_dina;\n            Cpu_ready_o      <= 1'b1;\n            txt_ena          <= Cpu_req_i;\n        end\n        4'hc: begin\n            wb_c_we_o        <= Cpu_mem_w_i;\n            Cpu_data4bus_o   <= wb_c_dat_i;\n            Cpu_ready_o      <= wb_c_ack_i;\n            wb_c_stb_o       <= Cpu_req_i;\n        end\n        default: begin\n            MIO_mem_w_o    <= Cpu_mem_w_i;\n            Cpu_data4bus_o <= MIO_data4bus_i;\n            Cpu_ready_o    <= MIO_ready_i;\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        gpu_status <= 0;\n    end else if(Cpu_addr_bus_i[31:28] == 4'hb && Cpu_addr_bus_i[27] && Cpu_req_i && Cpu_mem_w_i) begin\n        gpu_status <= Cpu_data2bus_i;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand4_eacf6a5f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\n    wire nand1_out, nand2_out;\n\n    nand2 nand1(.A(A), .B(B), .Y(nand1_out));\n    nand2 nand2(.A(C), .B(D), .Y(nand2_out));\n    nand2 nand3(.A(nand1_out), .B(nand2_out), .Y(Y)); \n\nendmodule\n\nmodule nand2(\n    input A,\n    input B,\n    output Y\n);\n\nassign Y = ~(A & B);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__3ad1500a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input valid_in,\n    output reg ready_out,\n    output [3:0] seq_length_out\n);\n\nreg [3:0] seq_length_current;\nreg [3:0] seq_length_max;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        seq_length_current <= 4'b0;\n        seq_length_max <= 4'b0;\n        ready_out <= 1'b0;\n    end else begin\n        if (valid_in) begin\n            if (data_in[0]) begin\n                seq_length_current <= seq_length_current + 1;\n            end else begin\n                seq_length_current <= 4'b0;\n            end\n            if (seq_length_current > seq_length_max) begin\n                seq_length_max <= seq_length_current;\n            end\n            ready_out <= 1'b1;\n        end else begin\n            ready_out <= 1'b0;\n        end\n    end\nend\n\nreg [3:0] seq_length_out_reg;\n\nalways @(posedge clk) begin\n    if (valid_in) begin\n        seq_length_out_reg <= seq_length_max;\n    end\nend\n\nassign seq_length_out = seq_length_out_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unknown_module_b02e39c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\t\t\t\t\t\t\tparameter\n\t\t\t\t\t\t\tRESET_PERIOD\t=\t4\n\t\t\t\t\t\t\t)\n(\ninput\t\twire\t\tCLK_I,\ninput\t\twire\t\tRST_I,\noutput\twire\t\tSRST_O\n);\n\nreg \t[RESET_PERIOD:0]\tRstQ;\n\ninitial\n\t\tbegin\n\t\t\tRstQ[RESET_PERIOD:1]={RESET_PERIOD{1'b1}};\n\t\t\tRstQ[0]=1'b0;\n\t\tend\n\nalways\nRstQ[0] = 1'b0;\n\n\ngenvar i;\n\n\t\tgenerate\n\t\t\tfor(i=1;i<RESET_PERIOD+1;i=i+1)\n\t\t\t\talways@(posedge CLK_I)\n\t\t\t\t\tif(RST_I)\n\t\t\t\t\tRstQ[i]\t<=\t1;\n\t\t\t\t\telse\n\t\t\t\t\tRstQ[i]\t<=\tRstQ[i-1];\n\t\tendgenerate\n\n\tassign SRST_O\t=\tRstQ[RESET_PERIOD];\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_min_xor_c6bbfe60", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_min_xor (\n    input [2:0] sel, // Select input for the 6-to-1 mux\n    input [3:0] data0, // Input 0 for the 6-to-1 mux\n    input [3:0] data1, // Input 1 for the 6-to-1 mux\n    input [3:0] data2, // Input 2 for the 6-to-1 mux\n    input [3:0] data3, // Input 3 for the 6-to-1 mux\n    input [3:0] data4, // Input 4 for the 6-to-1 mux\n    input [3:0] data5, // Input 5 for the 6-to-1 mux\n    input [7:0] a, b, c, d, // Inputs for the 4-way minimum circuit\n    output [7:0] out // Output of the functional module\n);\n\n// 6-to-1 multiplexer\nwire [3:0] mux_out;\nassign mux_out = (sel == 3'b000) ? data0 :\n                 (sel == 3'b001) ? data1 :\n                 (sel == 3'b010) ? data2 :\n                 (sel == 3'b011) ? data3 :\n                 (sel == 3'b100) ? data4 :\n                 (sel == 3'b101) ? data5 :\n                 4'b0000;\n\n\n// 4-way minimum circuit\n\nwire [7:0] min_out;\nassign min_out[7:0] = {a[7]&b[7],a[7]&c[7],a[7]&d[7],\n                       b[7]&c[7],b[7]&d[7],\n                       c[7]&d[7],\n                       a[6:0] < b[6:0] ? a[6:0] : b[6:0],\n                       a[6:0] < c[6:0] ? a[6:0] : c[6:0],\n                       a[6:0] < d[6:0] ? a[6:0] : d[6:0],\n                       b[6:0] < c[6:0] ? b[6:0] : c[6:0],\n                       b[6:0] < d[6:0] ? b[6:0] : d[6:0],\n                       c[6:0] < d[6:0] ? c[6:0] : d[6:0]};\n\n// XOR output\nassign out = mux_out ^ min_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_operation_ee22b455", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule bitwise_operation(x, y, out);\n  // IO ports\n  input  [15:0] x, y;\n  output [15:0] out;\n\n  // Net declarations\n  wire [15:0] and_n, or_n, not_n, xor_n;\n  wire [2:0] func;\n\n  // Assignments\n  assign func = 3'b010; // Select NOT operation\n  assign and_n  = x & y;\n  assign or_n   = x | y;\n  assign not_n  = ~x;\n  assign xor_n  = x ^ y;\n  assign out = not_n;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pulse_generator #_8ee7ce74", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pulse_generator #(\n  parameter WIDTH=8\n) (\n  input clock,\n  input reset,\n  input enable,\n  input [WIDTH-1:0] rate,\n  input strobe_fast,\n  output reg strobe_slow\n);\n\n  reg [WIDTH-1:0] counter;\n  wire now = (counter == 1);\n  \n  always @(posedge clock)\n    if(reset)\n      counter <= 0; \n    else if (~enable)\n      counter <= rate;\n    else if(strobe_fast)\n    begin\n      if(now)\n        counter <= rate;\n      else \n        counter <= counter - 1;\n    end\n\n  always @*\n    strobe_slow = now && enable && strobe_fast;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__nand4bb_c25ddeb6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__nand4bb (\n    Y  ,\n    A_N,\n    B_N,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B_N;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out;\n    wire or0_out_Y;\n\n    nand nand0 (nand0_out, D, C               );\n    or   or0   (or0_out_Y, B_N, A_N, nand0_out);\n    buf  buf0  (Y        , or0_out_Y          );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_58379113", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output [7:0] Y\n);\n\nassign Y[0] = (~A) & (~B) & (~C);\nassign Y[1] = (~A) & (~B) & C;\nassign Y[2] = (~A) & B & (~C);\nassign Y[3] = (~A) & B & C;\nassign Y[4] = A & (~B) & (~C);\nassign Y[5] = A & (~B) & C;\nassign Y[6] = A & B & (~C);\nassign Y[7] = A & B & C;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder #_f706f808", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_encoder #(\n  parameter n=4,\n  parameter m=2\n) (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\n\nreg [m-1:0] out_reg; // register to hold the output binary code\n\nalways @(*) begin\n  casez(in) // scan the input signals from highest to lowest priority\n    4'b1110: out_reg = 2'b00; // highest priority input signal is in[3]\n    4'b1101: out_reg = 2'b01; // highest priority input signal is in[2]\n    4'b1011: out_reg = 2'b10; // highest priority input signal is in[1]\n    4'b0111: out_reg = 2'b11; // highest priority input signal is in[0]\n    default: out_reg = 2'b00; // default output if no input signals are high\n  endcase\nend\n\nassign out = out_reg; // assign the output to the output register\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_f3fbfabd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pipeline (\n  input clk,\n  input reset,\n  input [31:0] data1,\n  input [31:0] data2,\n  input [7:0] instruction,\n  input [2:0] stage,\n  input [3:0] rs1,\n  input [3:0] rs2,\n  input [3:0] rd,\n  output [31:0] regfile_0,\n  output [31:0] regfile_1,\n  output [31:0] regfile_2,\n  output [31:0] regfile_3,\n  output [31:0] regfile_4,\n  output [31:0] regfile_5,\n  output [31:0] regfile_6,\n  output [31:0] regfile_7,\n  output [31:0] regfile_8,\n  output [31:0] regfile_9,\n  output [31:0] regfile_10,\n  output [31:0] regfile_11,\n  output [31:0] regfile_12,\n  output [31:0] regfile_13,\n  output [31:0] regfile_14,\n  output [31:0] regfile_15\n);\n\nreg [31:0] pc;\nreg [31:0] instruction_reg;\nreg [31:0] alu_result;\nreg [31:0] data2_reg;\nreg [4:0] rs1_reg;\nreg [4:0] rs2_reg;\nreg [4:0] rd_reg;\nreg [1:0] stage_reg;\n\nassign regfile_0 = regfile[0];\nassign regfile_1 = regfile[1];\nassign regfile_2 = regfile[2];\nassign regfile_3 = regfile[3];\nassign regfile_4 = regfile[4];\nassign regfile_5 = regfile[5];\nassign regfile_6 = regfile[6];\nassign regfile_7 = regfile[7];\nassign regfile_8 = regfile[8];\nassign regfile_9 = regfile[9];\nassign regfile_10 = regfile[10];\nassign regfile_11 = regfile[11];\nassign regfile_12 = regfile[12];\nassign regfile_13 = regfile[13];\nassign regfile_14 = regfile[14];\nassign regfile_15 = regfile[15];\n\nreg [31:0] regfile [15:0];\n\nalways @(posedge clk) begin\n  if (reset) begin\n    pc <= 0;\n    instruction_reg <= 0;\n    alu_result <= 0;\n    data2_reg <= 0;\n    rs1_reg <= 0;\n    rs2_reg <= 0;\n    rd_reg <= 0;\n    stage_reg <= 0;\n  end else begin\n    case (stage_reg)\n      0: begin // Instruction Fetch\n        instruction_reg <= instruction;\n        pc <= pc + 1;\n        stage_reg <= 1;\n      end\n      1: begin // Instruction Decode and Execution\n        rs1_reg <= rs1;\n        rs2_reg <= rs2;\n        rd_reg <= rd;\n        data2_reg <= data2;\n        case (instruction_reg[7:0])\n          8'h00: alu_result <= data1 + data2_reg; // ADD\n          8'h01: alu_result <= data1 - data2_reg; // SUB\n          8'h02: alu_result <= data1 & data2_reg; // AND\n          8'h03: alu_result <= data1 | data2_reg; // OR\n          8'h04: alu_result <= data1 ^ data2_reg; // XOR\n          8'h05: alu_result <= ~data1; // NOT\n          8'h06: alu_result <= data1 << data2_reg; // SLL\n          8'h07: alu_result <= data1 >> data2_reg; // SRL\n          default: alu_result <= 0;\n        endcase\n        stage_reg <= 2;\n      end\n      2: begin // Write Back\n        regfile[rd_reg] <= alu_result;\n        stage_reg <= 0;\n      end\n      default: stage_reg <= 0;\n    endcase\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register_adder_clock_gate_390ae2ee", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule register_adder_clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output ENCLK\n);\n\n  reg gated_clk;\n\n  always @(posedge CLK) begin\n    if (EN && !TE) begin\n      gated_clk <= 1'b1;\n    end else begin\n      gated_clk <= 1'b0;\n    end\n  end\n\n  assign ENCLK = gated_clk & CLK;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_multiplier_fd935880", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipelined_multiplier (\n    input [15:0] A,\n    input [15:0] B,\n    input clk,\n    output reg [31:0] P\n);\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [15:0] pp1_reg;\nreg [15:0] pp2_reg;\nreg [15:0] pp3_reg;\nreg [15:0] pp4_reg;\n\nalways @(posedge clk) begin\n    a_reg <= A;\n    b_reg <= B;\nend\n\n// Stage 1\nwire [15:0] pp1;\nassign pp1 = a_reg[0] ? b_reg : 0;\nalways @(posedge clk) begin\n    pp1_reg <= pp1;\nend\n\n// Stage 2\nwire [15:0] pp2;\nassign pp2 = a_reg[1] ? {b_reg[14:0], 1'b0} : 0;\nalways @(posedge clk) begin\n    pp2_reg <= pp2;\nend\n\n// Stage 3\nwire [15:0] pp3;\nassign pp3 = a_reg[2] ? {b_reg[13:0], 2'b00} : 0;\nalways @(posedge clk) begin\n    pp3_reg <= pp3;\nend\n\n// Stage 4\nwire [15:0] pp4;\nassign pp4 = a_reg[3] ? {b_reg[12:0], 3'b000} : 0;\nalways @(posedge clk) begin\n    pp4_reg <= pp4;\nend\n\nalways @(posedge clk) begin\n    P <= pp1_reg + pp2_reg + pp3_reg + pp4_reg;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_7c6ab013", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter\n(\n    input clk,\n    input rst,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or posedge rst)\n    begin\n        if (rst)\n            out <= 4'b0;\n        else if (out == 4'hF)\n            out <= 4'b0;\n        else\n            out <= out + 1;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shipping__041a919a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shipping_module (A, B, C, D, E, F, G, H, I, J, K, L, M, N, valid);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M, N;\n    output valid;\n\n    wire [7:0] min_value = 8'd120;\n    wire [7:0] max_weight = 8'd60;\n    wire [7:0] max_volume = 8'd60;\n\n    wire [7:0]  total_value = \n        A * 8'd4\n      + B * 8'd8\n      + C * 8'd0\n      + D * 8'd20\n      + E * 8'd10\n      + F * 8'd12\n      + G * 8'd18\n      + H * 8'd14\n      + I * 8'd6\n      + J * 8'd15\n      + K * 8'd30\n      + L * 8'd8\n      + M * 8'd16\n      + N * 8'd18;\n\n    wire [7:0]  total_weight = \n        A * 8'd28\n      + B * 8'd8\n      + C * 8'd27\n      + D * 8'd18\n      + E * 8'd27\n      + F * 8'd28\n      + G * 8'd6\n      + H * 8'd1\n      + I * 8'd20\n      + J * 8'd0\n      + K * 8'd5\n      + L * 8'd13\n      + M * 8'd8\n      + N * 8'd14;\n\n    wire [7:0]  total_volume = \n        A * 8'd27\n      + B * 8'd27\n      + C * 8'd4\n      + D * 8'd4\n      + E * 8'd0\n      + F * 8'd24\n      + G * 8'd4\n      + H * 8'd20\n      + I * 8'd12\n      + J * 8'd15\n      + K * 8'd5\n      + L * 8'd2\n      + M * 8'd9\n      + N * 8'd28;\n\n    assign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume));\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_55be4182", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input control,\n    output reg [2:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 3'b0;\n        end else if (control) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_dff_c3cce94f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_dff ( \n    input clk, \n    input d, \n    output reg q \n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n\nmodule shift_register_adder ( \n    input clk, \n    input [3:0] adder_input, \n    input d, \n    output reg [6:0] sum \n);\n\n    reg [3:0] shift_reg;\n    reg [4:0] shifted_input;\n    reg [4:0] adder_output;\n    wire q;\n\n    my_dff dff_inst (\n        .clk(clk),\n        .d(d),\n        .q(q)\n    );\n\n    always @* begin\n        shifted_input = {shift_reg[2], shift_reg[1], shift_reg[0], 1'b0};\n        adder_output = adder_input + shifted_input;\n        shift_reg <= {shifted_input[3:1], d};\n    end\n\n    always @* begin\n        sum = {adder_output, shift_reg};\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bcd_converter_c611afff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bcd_converter (\n    input [3:0] data_in,\n    output reg [7:0] bcd_out\n);\n\nalways @(*) begin\n    case(data_in)\n        4'b0000: bcd_out = 8'b00000001;\n        4'b0001: bcd_out = 8'b00000010;\n        4'b0010: bcd_out = 8'b00000100;\n        4'b0011: bcd_out = 8'b00000110;\n        4'b0100: bcd_out = 8'b00001000;\n        4'b0101: bcd_out = 8'b00001001;\n        4'b0110: bcd_out = 8'b00001100;\n        4'b0111: bcd_out = 8'b00001110;\n        4'b1000: bcd_out = 8'b00010000;\n        4'b1001: bcd_out = 8'b00010001;\n        default: bcd_out = 8'b00000000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_xor_gate_c2efb0f1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipelined_xor_gate(input a, b, output out_assign, input clk);\n\n  reg a_reg, b_reg;\n  wire xor_out;\n  reg out_assign_reg;\n\n  assign xor_out = a_reg ^ b_reg;\n  assign out_assign = out_assign_reg;\n\n  always @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\n  end\n\n  always @(posedge clk) begin\n    out_assign_reg <= xor_out;\n  end\n\nendmodule\n\nmodule pipeline_stage_1(input a, b, output reg a_reg, output reg b_reg, input clk);\n\n  always @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\n  end\n\nendmodule\n\nmodule pipeline_stage_2(input xor_out, output reg out_assign_reg, input clk);\n\n  always @(posedge clk) begin\n    out_assign_reg <= xor_out;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AGC_3eb55fef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule AGC (\n  input clk,\n  input in,\n  output out\n);\n\nparameter target_level = 100; // desired output signal level\nparameter step_size = 1; // amount to adjust gain on each clock cycle\n\nreg [7:0] gain = 128; // initial gain value\nreg [15:0] sum = 0; // sum of input signal over time\n\nalways @(posedge clk) begin\n  sum <= sum + in; // accumulate input signal over time\n  if (sum > target_level) begin\n    gain <= gain - step_size; // decrease gain\n  end else if (sum < target_level) begin\n    gain <= gain + step_size; // increase gain\n  end\n  sum <= 0; // reset sum for next cycle\nend\n\nassign out = in * gain; // compute output signal\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wifi_transceiver_1f99ac22", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule wifi_transceiver (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  output [99:0] rx_packet,\n  output [31:0] data_out,\n  output [99:0] tx_packet,\n  output tx_busy\n);\n\n  reg [31:0] data_buffer;\n  reg [99:0] tx_packet_reg;\n  reg tx_busy_reg;\n  reg [31:0] rx_data;\n  reg [31:0] rx_checksum;\n  reg [31:0] calculated_checksum;\n\n  assign tx_packet = tx_packet_reg;\n  assign tx_busy = tx_busy_reg;\n  assign data_out = rx_data;\n  assign rx_packet[99:96] = 4'hF;\n  assign rx_packet[95:64] = data_in ^ 32'hAAAAAAAA;\n  assign rx_packet[63:32] = ~data_in;\n  assign rx_packet[31:0] = data_in;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      data_buffer <= 32'h0;\n      tx_packet_reg <= 100'h0;\n      tx_busy_reg <= 1'b0;\n    end else begin\n      if (!tx_busy_reg) begin\n        data_buffer <= data_in;\n        tx_packet_reg[31:0] <= data_in;\n        tx_packet_reg[63:32] <= ~data_in;\n        tx_packet_reg[95:64] <= data_in ^ 32'hAAAAAAAA;\n        tx_packet_reg[99:96] <= 4'hF;\n        tx_busy_reg <= 1'b1;\n      end else begin\n        tx_busy_reg <= 1'b0;\n      end\n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      rx_data <= 32'h0;\n      rx_checksum <= 32'h0;\n    end else begin\n      rx_data <= rx_packet[31:0];\n      rx_checksum <= rx_packet[63:32];\n      calculated_checksum <= rx_data ^ rx_packet[95:64] ^ 32'hAAAAAAAA;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_239058ea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C\n);\n\nreg carry_out;\nreg [3:0] carry_in; \n\nalways @* begin\n    {carry_out, S[0]} = A[0] + B[0];\n    {carry_in[1], S[1]} = A[1] + B[1] + carry_out;\n    {carry_in[2], S[2]} = A[2] + B[2] + carry_in[1];\n    {C, S[3]} = A[3] + B[3] + carry_in[2];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "booth_encoder_5_dbd09429", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule booth_encoder_5(\n  input [2:0] B_in,\n  output [2:0] A_out\n);\n\nassign A_out = (B_in[2] ^ B_in[1] ^ B_in[0]) ? 3'b001 : \n               (B_in[2] ^ B_in[0]) ? 3'b010 :\n               (B_in[2] ^ B_in[1]) ? 3'b011 :\n               (B_in[1] ^ B_in[0]) ? 3'b100 :\n               (B_in[2]) ? 3'b101 :\n               (B_in[1]) ? 3'b110 :\n               (B_in[0]) ? 3'b111 :\n               3'b000;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__22395dff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,\n    output reg [127:0] final_output\n);\n\n    reg d;\n    wire [127:0] jc_output;\n    wire [15:0] jc_input;\n    wire [127:0] dff_output;\n    \n    DFF_module dff_inst (\n        .clk(clk),\n        .d(d),\n        .q(dff_output)\n    );\n    \n    chatgpt_generate_JC_counter jc_inst (\n        .clk(clk),\n        .rst_n(reset),\n        .Q(jc_output)\n    );\n    \n    assign jc_input[0] = dff_output;\n    assign jc_input[1] = jc_output[0];\n    assign jc_input[2] = jc_output[1];\n    assign jc_input[3] = jc_output[2];\n    assign jc_input[4] = jc_output[3];\n    assign jc_input[5] = jc_output[4];\n    assign jc_input[6] = jc_output[5];\n    assign jc_input[7] = jc_output[6];\n    assign jc_input[8] = jc_output[7];\n    assign jc_input[9] = jc_output[8];\n    assign jc_input[10] = jc_output[9];\n    assign jc_input[11] = jc_output[10];\n    assign jc_input[12] = jc_output[11];\n    assign jc_input[13] = jc_output[12];\n    assign jc_input[14] = jc_output[13];\n    assign jc_input[15] = jc_output[14];\n    \n    always @* begin\n        final_output = {dff_output, jc_output} << 112;\n    end\n\nendmodule\n\nmodule DFF_module (\n    input clk,\n    input d,\n    output reg [127:0] q\n);\n    \n    always @(posedge clk) begin\n        q <= {127{d}};\n    end\n    \nendmodule\n\nmodule chatgpt_generate_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [127:0]    Q\n);\n  \n  reg [15:0] jc_reg;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      jc_reg <= 16'h0001;\n    end else begin\n      jc_reg <= {jc_reg[14:0], ~(jc_reg[14] ^ jc_reg[15])};\n    end\n  end\n  \n  always @*\n    Q = jc_reg;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "soft_clock_9e7704a4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule soft_clock\n#(parameter\n\tC_SIPIF_DWIDTH = 32\n)\n(\n\tinput                                   Bus2IP_Reset     ,\n\tinput                                   Bus2IP_Clk       ,\n\tinput                                   Bus2IP_WrCE      ,\n\tinput      [0:C_SIPIF_DWIDTH-1]         Bus2IP_Data      ,\n\tinput      [0:(C_SIPIF_DWIDTH/8)-1]     Bus2IP_BE        ,\n\t\n\toutput                                  Clk2IP_Clk       ,\n\t\n\toutput                                  Clk2Bus_WrAck    ,\n\toutput                                  Clk2Bus_Error    ,\n\toutput                                  Clk2Bus_ToutSup  \n\t\n);\n\n\tlocalparam [0:3] CLOCK_ENABLE  = 4'b1010;\n\tlocalparam [0:3] CLOCK_DISABLE = 4'b0101;\n\n\t\n\twire isc_enable_match  = (Bus2IP_Data[C_SIPIF_DWIDTH-4:C_SIPIF_DWIDTH-1] == CLOCK_ENABLE);\n\twire isc_disable_match = (Bus2IP_Data[C_SIPIF_DWIDTH-4:C_SIPIF_DWIDTH-1] == CLOCK_DISABLE);\n\twire isc_match    = isc_enable_match | isc_disable_match;\n\twire isc_mismatch = ~(isc_enable_match | isc_disable_match);\n\twire isc_be_match = (Bus2IP_BE[(C_SIPIF_DWIDTH/8)-1:(C_SIPIF_DWIDTH/8)-1] == 1'b1);\n\n\t\n\treg isr_ce;\n\talways @(posedge Bus2IP_Clk or posedge Bus2IP_Reset) begin\n\t\tif (Bus2IP_Reset) begin \n\t\t\tisr_ce <= 1'b1;\n\t\tend else begin \n\t\t\tif (Bus2IP_WrCE && isc_be_match) begin\n\t\t\t\tisr_ce <= \n\t\t\t\t\tisc_enable_match?  1'b1: \n\t\t\t\t\tisc_disable_match? 1'b0: isr_ce;\n\t\t\tend\n\t\tend\n\tend\n\t\n\treg isr_error;\n\talways @(posedge Bus2IP_Clk or posedge Bus2IP_Reset) begin\n\t\tif (Bus2IP_Reset) begin \n\t\t\tisr_error <= 1'b0;\n\t\tend else begin \n\t\t\tif (Bus2IP_WrCE) begin\n\t\t\t\tisr_error <= isc_mismatch? 1'b1: 1'b0;\n\t\t\tend\n\t\tend\n\tend\n\t\n\t\n\tassign Clk2IP_Clk = Bus2IP_Clk & isr_ce;\n\t\n\t\n\tassign Clk2Bus_WrAck   = isc_match & Bus2IP_WrCE & isc_be_match;\n\tassign Clk2Bus_Error   = isc_mismatch & Bus2IP_WrCE & isc_be_match;\n\tassign Clk2Bus_ToutSup = Bus2IP_Reset;\n\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_checker_fa519987", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule parity_checker (\n  input [3:0] data,\n  output reg parity\n);\n\n  always @* begin\n    parity = ^data; // XOR all bits in data\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "manchester_encoder_de1eb977", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule manchester_encoder (\n  input clk,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter freq = 100; // clock frequency in MHz\nparameter data_rate = 10; // data rate in Mbps\n\n// implementation of Manchester encoder\nreg [n-1:0] prev_in;\nalways @(posedge clk) begin\n  prev_in <= in;\nend\n\nassign out = (prev_in ^ in) ? {1'b1, 1'b0} : {1'b0, 1'b1};\n\nendmodule\n\nmodule manchester_decoder (\n  input clk,\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter freq = 100; // clock frequency in MHz\nparameter data_rate = 10; // data rate in Mbps\n\n// implementation of Manchester decoder\nreg [n-1:0] prev_in;\nalways @(posedge clk) begin\n  prev_in <= in;\nend\n\nassign out = (prev_in ^ in) ? 1'b1 : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ui_cmd #_bc3c38fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule ui_cmd #\n  (\n   parameter TCQ = 100,\n   parameter ADDR_WIDTH         = 33,\n   parameter BANK_WIDTH         = 3,\n   parameter COL_WIDTH          = 12,\n   parameter RANK_WIDTH         = 2,\n   parameter ROW_WIDTH          = 16,\n   parameter RANKS              = 4\n  )\n  (\n  app_rdy, use_addr, rank, bank, row, col, size, cmd, hi_priority,\n  rd_accepted, wr_accepted, data_buf_addr,\n  rst, clk, accept_ns, rd_buf_full, wr_req_16, app_addr, app_cmd,\n  app_sz, app_hi_pri, app_en, wr_data_buf_addr, rd_data_buf_addr_r\n  );\n\n  input rst;\n  input clk;\n\n  input accept_ns;\n  input rd_buf_full;\n  input wr_req_16;\n  wire app_rdy_ns = accept_ns && ~rd_buf_full && ~wr_req_16;\n  reg app_rdy_r;\n  always @(posedge clk) app_rdy_r <= #TCQ app_rdy_ns;\n  output wire app_rdy;\n  assign app_rdy = app_rdy_r;\n\n  input [ADDR_WIDTH-1:0] app_addr;\n  input [2:0] app_cmd;\n  input app_sz;\n  input app_hi_pri;\n  input app_en;\n\n  reg [ADDR_WIDTH-1:0] app_addr_r1;\n  reg [ADDR_WIDTH-1:0] app_addr_r2;\n  reg [2:0] app_cmd_r1;\n  reg [2:0] app_cmd_r2;\n  reg app_sz_r1;\n  reg app_sz_r2;\n  reg app_hi_pri_r1;\n  reg app_hi_pri_r2;\n  reg app_en_r1;\n  reg app_en_r2;\n\n  wire [ADDR_WIDTH-1:0] app_addr_ns1 = app_rdy_r ? app_addr : app_addr_r1;\n  wire [ADDR_WIDTH-1:0] app_addr_ns2 = app_rdy_r ? app_addr_r1 : app_addr_r2;\n  wire [2:0] app_cmd_ns1 = app_rdy_r ? app_cmd : app_cmd_r1;\n  wire [2:0] app_cmd_ns2 = app_rdy_r ? app_cmd_r1 : app_cmd_r2;\n  wire app_sz_ns1 = app_rdy_r ? app_sz : app_sz_r1;\n  wire app_sz_ns2 = app_rdy_r ? app_sz_r1 : app_sz_r2;\n  wire app_hi_pri_ns1 = app_rdy_r ? app_hi_pri : app_hi_pri_r1;\n  wire app_hi_pri_ns2 = app_rdy_r ? app_hi_pri_r1 : app_hi_pri_r2;\n  wire app_en_ns1 = ~rst && (app_rdy_r ? app_en : app_en_r1);\n  wire app_en_ns2 = ~rst && (app_rdy_r ? app_en_r1 : app_en_r2);\n\n  always @(posedge clk) begin\n    app_addr_r1 <= #TCQ app_addr_ns1;\n    app_addr_r2 <= #TCQ app_addr_ns2;\n    app_cmd_r1 <= #TCQ app_cmd_ns1;\n    app_cmd_r2 <= #TCQ app_cmd_ns2;\n    app_sz_r1 <= #TCQ app_sz_ns1;\n    app_sz_r2 <= #TCQ app_sz_ns2;\n    app_hi_pri_r1 <= #TCQ app_hi_pri_ns1;\n    app_hi_pri_r2 <= #TCQ app_hi_pri_ns2;\n    app_en_r1 <= #TCQ app_en_ns1;\n    app_en_r2 <= #TCQ app_en_ns2;\n  end wire use_addr_lcl = app_en_r2 && app_rdy_r;\n  output wire use_addr;\n  assign use_addr = use_addr_lcl;\n\n  output wire [RANK_WIDTH-1:0] rank;\n  output wire [BANK_WIDTH-1:0] bank;\n  output wire [ROW_WIDTH-1:0] row;\n  output wire [COL_WIDTH-1:0] col;\n  output wire size;\n  output wire [2:0] cmd;\n  output wire hi_priority;\n\n  assign col = app_rdy_r\n                 ? app_addr_r1[0+:COL_WIDTH]\n                 : app_addr_r2[0+:COL_WIDTH];\n  assign row = app_rdy_r\n                 ? app_addr_r1[COL_WIDTH+:ROW_WIDTH]\n                 : app_addr_r2[COL_WIDTH+:ROW_WIDTH];\n  assign bank = app_rdy_r\n                  ? app_addr_r1[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH]\n                  : app_addr_r2[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH];\n  assign rank = (RANKS == 1)\n                  ? 1'b0\n                  : app_rdy_r\n                    ? app_addr_r1[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH]\n                    : app_addr_r2[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH];\n  assign size = app_rdy_r\n                  ? app_sz_r1\n                  : app_sz_r2;\n  assign cmd = app_rdy_r\n                 ? app_cmd_r1\n                 : app_cmd_r2;\n  assign hi_priority = app_rdy_r\n                         ? app_hi_pri_r1\n                         : app_hi_pri_r2;\n\n  wire request_accepted = use_addr_lcl && app_rdy_r;\n  wire rd = app_cmd_r2[1:0] == 2'b01;\n  wire wr = app_cmd_r2[1:0] == 2'b00;\n  wire wr_bytes = app_cmd_r2[1:0] == 2'b11;\n  wire write = wr || wr_bytes;\n  output wire rd_accepted;\n  assign rd_accepted = request_accepted && rd;\n  output wire wr_accepted;\n  assign wr_accepted = request_accepted && write;\n\n  input [3:0] wr_data_buf_addr;\n  input [3:0] rd_data_buf_addr_r;\n  output wire [3:0] data_buf_addr;\n\n  assign data_buf_addr = ~write ? rd_data_buf_addr_r : wr_data_buf_addr;\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_7x_v1_11_0_axi_basic_tx_pipeline #_c0c4a60e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule pcie_7x_v1_11_0_axi_basic_tx_pipeline #(\n  parameter C_DATA_WIDTH = 128,           parameter C_PM_PRIORITY = \"FALSE\",      parameter TCQ = 1,                      parameter REM_WIDTH  = (C_DATA_WIDTH == 128) ? 2 : 1, parameter KEEP_WIDTH = C_DATA_WIDTH / 8               ) (\n  input      [C_DATA_WIDTH-1:0] s_axis_tx_tdata,     input                         s_axis_tx_tvalid,    output                        s_axis_tx_tready,    input        [KEEP_WIDTH-1:0] s_axis_tx_tkeep,     input                         s_axis_tx_tlast,     input                   [3:0] s_axis_tx_tuser,     output     [C_DATA_WIDTH-1:0] trn_td,              output                        trn_tsof,            output                        trn_teof,            output                        trn_tsrc_rdy,        input                         trn_tdst_rdy,        output                        trn_tsrc_dsc,        output        [REM_WIDTH-1:0] trn_trem,            output                        trn_terrfwd,         output                        trn_tstr,            output                        trn_tecrc_gen,       input                         trn_lnk_up,          input                         tready_thrtl,        input                         user_clk,            input                         user_rst             );\n\n\nreg  [C_DATA_WIDTH-1:0] reg_tdata;\nreg                     reg_tvalid;\nreg    [KEEP_WIDTH-1:0] reg_tkeep;\nreg               [3:0] reg_tuser;\nreg                     reg_tlast;\nreg                     reg_tready;\n\nreg                     trn_in_packet;\nreg                     axi_in_packet;\nreg                     flush_axi;\nwire                    disable_trn;\nreg                     reg_disable_trn;\n\nwire                    axi_beat_live  = s_axis_tx_tvalid && s_axis_tx_tready;\nwire                    axi_end_packet = axi_beat_live && s_axis_tx_tlast;\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : td_DW_swap_128\n    assign trn_td = {reg_tdata[31:0],\n                     reg_tdata[63:32],\n                     reg_tdata[95:64],\n                     reg_tdata[127:96]};\n  end\n  else if(C_DATA_WIDTH == 64) begin : td_DW_swap_64\n    assign trn_td = {reg_tdata[31:0], reg_tdata[63:32]};\n  end\n  else begin : td_DW_swap_32\n    assign trn_td = reg_tdata;\n  end\nendgenerate\n\n\nassign trn_tsof = reg_tvalid && !trn_in_packet;\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    trn_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(trn_tsof && trn_tsrc_rdy && trn_tdst_rdy && !trn_teof) begin\n      trn_in_packet <= #TCQ 1'b1;\n    end\n    else if((trn_in_packet && trn_teof && trn_tsrc_rdy) || !trn_lnk_up) begin\n      trn_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    axi_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(axi_beat_live && !s_axis_tx_tlast) begin\n      axi_in_packet <= #TCQ 1'b1;\n    end\n    else if(axi_beat_live) begin\n      axi_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\ngenerate\n  if(C_PM_PRIORITY == \"TRUE\") begin : pm_priority_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b1;\n      end\n      else begin\n        if(!trn_lnk_up)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(!flush_axi && s_axis_tx_tready) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn;\n  end\n\n  else begin : thrtl_ctl_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b0;\n      end\n      else begin\n        if(axi_in_packet && !trn_lnk_up && !axi_end_packet)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(axi_end_packet) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn || !trn_lnk_up;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : tkeep_to_trem_128\n    wire   axi_DW_1    = reg_tkeep[7];\n    wire   axi_DW_2    = reg_tkeep[11];\n    wire   axi_DW_3    = reg_tkeep[15];\n    assign trn_trem[1] = axi_DW_2;\n    assign trn_trem[0] = axi_DW_3 || (axi_DW_1 && !axi_DW_2);\n  end\n  else if(C_DATA_WIDTH == 64) begin : tkeep_to_trem_64\n    assign trn_trem    = reg_tkeep[7];\n  end\n  else begin : tkeep_to_trem_32\n    assign trn_trem    = 1'b0;\n  end\nendgenerate\n\n\nassign trn_teof      = reg_tlast;\nassign trn_tecrc_gen = reg_tuser[0];\nassign trn_terrfwd   = reg_tuser[1];\nassign trn_tstr      = reg_tuser[2];\nassign trn_tsrc_dsc  = reg_tuser[3];\n\n\ngenerate\n  reg reg_tsrc_rdy;\n\n  if(C_PM_PRIORITY == \"FALSE\") begin : throttle_ctl_pipeline\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata        <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid       <= #TCQ 1'b0;\n        reg_tkeep        <= #TCQ {KEEP_WIDTH{1'b0}};\n        reg_tlast        <= #TCQ 1'b0;\n        reg_tuser        <= #TCQ 4'h0;\n        reg_tsrc_rdy     <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdata        <= #TCQ s_axis_tx_tdata;\n        reg_tvalid       <= #TCQ s_axis_tx_tvalid;\n        reg_tkeep        <= #TCQ s_axis_tx_tkeep;\n        reg_tlast        <= #TCQ s_axis_tx_tlast;\n        reg_tuser        <= #TCQ s_axis_tx_tuser;\n\n        reg_tsrc_rdy     <= #TCQ axi_beat_live && !disable_trn;\n      end\n    end\n\n    assign trn_tsrc_rdy = reg_tsrc_rdy;\n\n    assign s_axis_tx_tready = tready_thrtl;\n  end\n\n  else begin : pm_prioity_pipeline\n    reg  [C_DATA_WIDTH-1:0] tdata_prev;\n    reg                     tvalid_prev;\n    reg    [KEEP_WIDTH-1:0] tkeep_prev;\n    reg                     tlast_prev;\n    reg               [3:0] tuser_prev;\n    reg                     reg_tdst_rdy;\n\n    wire                    data_hold;\n    reg                     data_prev;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        tdata_prev   <= #TCQ {C_DATA_WIDTH{1'b0}};\n        tvalid_prev  <= #TCQ 1'b0;\n        tkeep_prev   <= #TCQ {KEEP_WIDTH{1'b0}};\n        tlast_prev   <= #TCQ 1'b0;\n        tuser_prev   <= #TCQ 4'h 0;\n      end\n      else begin\n        if(!s_axis_tx_tready) begin\n          tdata_prev   <= #TCQ tdata_prev;\n          tvalid_prev  <= #TCQ tvalid_prev;\n          tkeep_prev   <= #TCQ tkeep_prev;\n          tlast_prev   <= #TCQ tlast_prev;\n          tuser_prev   <= #TCQ tuser_prev;\n        end\n        else begin\n          tdata_prev   <= #TCQ s_axis_tx_tdata;\n          tvalid_prev  <= #TCQ s_axis_tx_tvalid;\n          tkeep_prev   <= #TCQ s_axis_tx_tkeep;\n          tlast_prev   <= #TCQ s_axis_tx_tlast;\n          tuser_prev   <= #TCQ s_axis_tx_tuser;\n        end\n      end\n    end\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata  <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid <= #TCQ 1'b0;\n        reg_tkeep  <= #TCQ {KEEP_WIDTH{1'b0}};\n        reg_tlast  <= #TCQ 1'b0;\n        reg_tuser  <= #TCQ 4'h0;\n\n        reg_tdst_rdy <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdst_rdy <= #TCQ trn_tdst_rdy;\n\n        if(!data_hold) begin\n          if(data_prev) begin\n            reg_tdata  <= #TCQ tdata_prev;\n            reg_tvalid <= #TCQ tvalid_prev;\n            reg_tkeep  <= #TCQ tkeep_prev;\n            reg_tlast  <= #TCQ tlast_prev;\n            reg_tuser  <= #TCQ tuser_prev;\n          end\n\n          else begin\n            reg_tdata  <= #TCQ s_axis_tx_tdata;\n            reg_tvalid <= #TCQ s_axis_tx_tvalid;\n            reg_tkeep  <= #TCQ s_axis_tx_tkeep;\n            reg_tlast  <= #TCQ s_axis_tx_tlast;\n            reg_tuser  <= #TCQ s_axis_tx_tuser;\n          end\n        end\n        end\n    end\n\n\n    assign data_hold = trn_tsrc_rdy && !trn_tdst_rdy;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        data_prev <= #TCQ 1'b0;\n      end\n      else begin\n        data_prev <= #TCQ data_hold;\n      end\n    end\n\n\n    assign trn_tsrc_rdy = reg_tvalid && !disable_trn;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tready <= #TCQ 1'b0;\n      end\n      else begin\n        if(flush_axi && !axi_end_packet) begin\n          reg_tready <= #TCQ 1'b1;\n        end\n\n        else if(trn_lnk_up) begin\n          reg_tready <= #TCQ trn_tdst_rdy || !trn_tsrc_rdy;\n        end\n\n        else begin\n          reg_tready <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign s_axis_tx_tready = reg_tready;\n  end\n\n\n  always @(posedge user_clk) begin\n    if(user_rst) begin\n      flush_axi    <= #TCQ 1'b0;\n    end\n    else begin\n      if(axi_in_packet && !trn_lnk_up && !axi_end_packet) begin\n        flush_axi <= #TCQ 1'b1;\n      end\n\n      else if(axi_end_packet) begin\n        flush_axi <= #TCQ 1'b0;\n      end\n    end\n  end\nendgenerate\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SpecialAdd_6a84f187", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule SpecialAdd(\n\tinput [31:0] cin_Special,\n\tinput [31:0] zin_Special,\n\tinput reset,\n\tinput clock,\n\toutput reg idle_Special = 1'b0,\n\toutput reg [7:0] difference_Special,\n\toutput reg [35:0] cout_Special,\n\toutput reg [35:0] zout_Special,\n\toutput reg [31:0] sout_Special\n   );\n\t\nwire z_sign;\nwire [7:0] z_exponent;\nwire [26:0] z_mantissa;\n\nwire c_sign;\nwire [7:0] c_exponent;\nwire [26:0] c_mantissa;\n\nassign c_sign = cin_Special[31];\nassign c_exponent = {cin_Special[30:23] - 127};\nassign c_mantissa = {cin_Special[22:0],3'd0};\n\nassign z_sign = {zin_Special[31]};\nassign z_exponent = {zin_Special[30:23] - 127};\nassign z_mantissa = {zin_Special[22:0],3'd0};\n\nparameter no_idle = 1'b0,\n\t\t\t put_idle = 1'b1;\n\nalways @ (posedge clock)\nbegin\n\n\tif (reset == 1'b1) begin\n\t\tidle_Special <= 1'b0;\n\tend\n\t\n\telse begin\n\tif ($signed(z_exponent) > $signed(c_exponent)) begin\n\t\tdifference_Special <= z_exponent - c_exponent;\n\tend\n\telse if ($signed(z_exponent) <= $signed(c_exponent)) begin\n\t\tdifference_Special <= c_exponent - z_exponent;\n\tend\t\n\t\n\tif ((c_exponent == 128 && c_mantissa != 0) || (z_exponent == 128 && z_mantissa != 0)) begin\n      sout_Special[31] <= 1;\n      sout_Special[30:23] <= 255;\n      sout_Special[22] <= 1;\n      sout_Special[21:0] <= 0;\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n\t\tidle_Special <= put_idle;\n    end else if (c_exponent == 128) begin\n      sout_Special[31] <= c_sign;\n      sout_Special[30:23] <= 255;\n      sout_Special[22:0] <= 0;\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n\t\tidle_Special <= put_idle;\t\t\n    end else if (z_exponent == 128) begin\n      sout_Special[31] <= z_sign;\n      sout_Special[30:23] <= 255;\n      sout_Special[22:0] <= 0;\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n\t\tidle_Special <= put_idle;\t\t\n    end else if ((($signed(c_exponent) == -127) && (c_mantissa == 0)) && (($signed(z_exponent) == -127) && (z_mantissa == 0))) begin\n      sout_Special[31] <= c_sign & z_sign;\n      sout_Special[30:23] <= z_exponent[7:0] + 127;\n      sout_Special[22:0] <= z_mantissa[26:3];\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n      idle_Special <= put_idle;\t\t\t\t\t\t\t\n    end else if (($signed(c_exponent) == -127) && (c_mantissa == 0)) begin\n      sout_Special[31] <= z_sign;\n      sout_Special[30:23] <= z_exponent[7:0] + 127;\n      sout_Special[22:0] <= z_mantissa[26:3];\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n      idle_Special <= put_idle;\t\t\t\t\t\t\t\t\n    end else if (($signed(z_exponent) == -127) && (z_mantissa == 0)) begin\n      sout_Special[31] <= c_sign;\n      sout_Special[30:23] <= c_exponent[7:0] + 127;\n      sout_Special[22:0] <= c_mantissa[26:3];\n\t\tzout_Special <= zin_Special;\n\t\tcout_Special <= cin_Special;\n      idle_Special <= put_idle;\t\t\t\t\t\t\t\n    end else begin\n\t\tsout_Special <= 0;\n      if ($signed(c_exponent) == -127) begin\n         cout_Special[34:27] <= -126;\n\t\t\tcout_Special[35] <= c_sign;\n\t\t\tcout_Special[26:0] <= c_mantissa;\n      end else begin\n\t\t\tcout_Special[34:27] <= c_exponent + 127;\n\t\t\tcout_Special[35] <= c_sign;\n         cout_Special[26] <= 1;\n\t\t\tcout_Special[25:0] <= c_mantissa[25:0];\n\t\t\tidle_Special <= no_idle;\n      end\n      if ($signed(z_exponent) == -127) begin\n\t\t\tzout_Special[35] <= z_sign;\n         zout_Special[34:27] <= -126;\n\t\t\tzout_Special[26:0] <= z_mantissa;\n      end else begin\n\t\t\tzout_Special[35] <= z_sign;\n         zout_Special[34:27] <= z_exponent + 127;\n\t\t\tzout_Special[25:0] <= z_mantissa[25:0];\n         zout_Special[26] <= 1;\n\t\t\tidle_Special <= no_idle;\n      end\n\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_4state_sequence_detection_2b3802f0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fsm_4state_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  input enable,\n  output match\n);\n\n// Define the four states using one-hot encoding\nparameter A = 4'b0001;\nparameter B = 4'b0010;\nparameter C = 4'b0100;\nparameter D = 4'b1000;\n\n// Define the state register and initialize it to state A\nreg [3:0] state_reg = A;\n\n// Define the output register and initialize it to 0\nreg output_reg = 1'b0;\n\n// State transition and output logic equations\nalways @ (posedge clk) begin\n  if (reset) begin\n    state_reg <= A;\n    output_reg <= 1'b0;\n  end\n  else if (enable) begin\n    case (state_reg)\n      A: begin\n        if (data) state_reg <= B;\n        else state_reg <= A;\n      end\n      B: begin\n        if (!data) state_reg <= C;\n        else state_reg <= B;\n      end\n      C: begin\n        if (data) state_reg <= D;\n        else state_reg <= A;\n      end\n      D: begin\n        if (!data) begin\n          state_reg <= A;\n          output_reg <= 1'b1;\n        end\n        else state_reg <= B;\n      end\n    endcase\n  end\nend\n\n// Assign the output to the output wire\nassign match = output_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "crc_16_940207c2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule crc_16(start, clk, rst, data_in, data_out, done);\n\n\t//inputs y outputs\n\n\tinput start;\n\tinput clk;\n\tinput rst;\n\tinput [31:0] data_in;\n\toutput [15:0] data_out;\n\toutput done;\n\n\t//parametros \n\n\tlocalparam datawidth = 32, crcorder = 16;//tama\u00f1o del dato a operar, orden del polinomio crc\n\n\tlocalparam polinomio = 17'b10001000000100001 ; //polinomio para crc\n\t\n\treg rdone; \t\t\t\t//registro done\n\treg [31:0] r_data;\t\t//registro data\n\treg [16:0] proceso;\t\t//proceso o resultado temporal de xor\n\tinitial begin\n\t\trdone = 1'b0;\t\t\t//inicializa done en 0\n\tend\n\n\t//estados\n\t\n\tlocalparam INIT = 3'd0, GET = 3'd1, COMP = 3'd2, XOR = 3'd3, CORRER = 3'd4, SEND = 3'd5; \n\treg[2:0] state;\n\tinitial state = INIT; // se inicializa en el estado init\n\t\n\treg[6:0] cont; // contador de corrimientos\n\t\n\tassign data_out = proceso; //se asigna la salida de crc\n\tassign done = rdone; // se asigna done a la salida\n\t\n\n\t\n\talways @(posedge clk) begin\n\t\t\t\n\t\t//reset\t\t\n\t\n\t\tif(rst)begin\n\t\t\trdone <= 0;\n\t\t\tcont <= 0;\n\t\t\tproceso <= 0;\n\t\t\tstate <= INIT;\n\t\tend\n\n\t\telse begin \n\n\t\t//Maquina de Estados\n\n\t\t\tcase(state)\n\t\t\n\t\t\t\tINIT : begin   \t\t\t\t//estado init\n\t\t\t\t\tcont <= 6'd0;\t\t\t//contador en 0\n\t\t\t\t\trdone <= 1'b0; \t\t\t//done en 0\n\t\t\t\t\tif (start) begin\n\t\t\t\t\t\tr_data <= data_in;\t//se coloca en rdata el dato a operar\n\t\t\t\t\t\tstate <= GET;\t\t//cambio de estado\n\t\t\t\t\tend\t\n\t\t\t\tend\n\t\t\t\n\t\t\t\tGET : begin\t\t\t\t\t\t\t\t//estado get\n\t\t\t\t\tproceso <= r_data[(31):(31)-(crcorder)];\t//a proceso entran los \n\t\t\t\t\t\t\t\t\t\t\t\t\t//primeros crcorder bits \n\t\t\t\t\tstate <= COMP;\t\t\t\t\t\t\t//cambio de estado\n\t\t\t\tend\n\t\t\t\n\t\t\t\tCOMP : begin\t\t\t\t//estado comp \n\t\t\t\t\n\t\t\t\t\tcont <= cont + 1'b1;\t\t//aumenta el contador \n\t\t\t\t\tif(proceso[crcorder])\t\t//verifia si el primer bit de proceso es 1\n\t\t\t\t\t\tstate <= XOR;\t\t//si es 1 cambia a estado XOR\n\t\t\t\t\telse\n\t\t\t\t\t\tstate <= CORRER;\t\t//si es 0 cambia a estado correr\n\t\t\t\tend\n\t\t\t\n\t\t\t\tXOR : begin\t\t\t\t\t//estado xor\n\t\t\t\t\tproceso <= proceso ^ polinomio;\t//xor entre proceso y polinomio de crc\n\t\t\t\t\tstate <= CORRER;\t\t\t\t//cambio de estado \t\n\t\t\t\tend\n\t\t\t\n\t\t\t\tCORRER : begin\t\t\t\t//estado correr\n\t\t\t\t\tr_data <= {proceso[crcorder:0], r_data[(31)-crcorder-1:0], 1'b0}; \n\t\t\t\t\t\t\t\t\t//se coloca proceso concatenado con el resto de rdata \"anterior\"\n\t\t\t\t\tif (cont == datawidth)\n\t\t\t\t\t\tstate <= SEND;\t\t//si ya se hicieron datawidh corrimientos cambia a send\n\t\t\t\t\telse\n\t\t\t\t\t\tstate <= GET;\t\t//si no, vuelve a get \n\t\t\t\tend\n\t\t\t\n\t\t\t\tSEND : begin\t\t\t\t//estado send\n\t\t\t\t\trdone <= 1'b1;\t\t\t//done activo\n\t\t\t\t\tstate <= INIT;\t\t\t//vuelve a estado inicial\n\t\t\t\tend\n\t\t\t\n\t\t\tendcase\n\t\tend\n\n\tend\n\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "VGA_DRIVER_5087c117", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define TOTAL_SCREEN_WIDTH 795\n`define TOTAL_SCREEN_HEIGHT 525\n`define VISIBLE_SCREEN_WIDTH 640\n`define VISIBLE_SCREEN_HEIGHT 480\n\nmodule VGA_DRIVER (\n\tRESET,\n\tCLOCK,\n\tPIXEL_COLOR_IN,\n\tPIXEL_X,\n\tPIXEL_Y,\n\tPIXEL_COLOR_OUT,\n\tH_SYNC_NEG,\n\tV_SYNC_NEG\n);\n\n\n\ninput CLOCK; input RESET;\ninput  [7:0] PIXEL_COLOR_IN; output [9:0] PIXEL_X; output [9:0] PIXEL_Y; output [7:0] PIXEL_COLOR_OUT; output       H_SYNC_NEG; output       V_SYNC_NEG; \n\nreg  [9:0] pixel_count;\nreg  [9:0] line_count;\n\n\nassign PIXEL_X    = pixel_count;\nassign PIXEL_Y    = line_count;\n\nassign PIXEL_COLOR_OUT = (pixel_count<(`VISIBLE_SCREEN_WIDTH) )\n\t\t\t\t\t\t\t\t\t? (PIXEL_COLOR_IN) : (8'b00000000) ; assign H_SYNC_NEG = (pixel_count>=656 && pixel_count<752) ? (1'b0) : (1'b1); assign V_SYNC_NEG = (line_count>=490 && line_count<492) ? (1'b0) : (1'b1); always @(posedge CLOCK) begin\n\tif (RESET) begin\n\t\tpixel_count <= 10'b0;\n\t\tline_count <= 10'b0;\n\tend\n\telse if (pixel_count == (`TOTAL_SCREEN_WIDTH-1)) begin\n\t\tpixel_count <= 0;\n\t\tif (line_count == (`TOTAL_SCREEN_HEIGHT-1)) begin\n\t\tline_count <= 0;\n\t\tend \n\t\telse begin\n\t\tline_count <= line_count + 1;\n\t\tend\n\tend \n\telse begin\n\t\tpixel_count <= pixel_count + 1;\n\t\tline_count <= line_count;\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RS232TX_51291691", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RS232TX (\n\tinput clk,\n\tinput Tx_start,\n\tinput [23:0] dbuffer,\n\toutput Tx,\n\toutput Tx_busy\n);\n\nwire bittick;\n\nwire[7:0] Tx_data = dbuffer[7:0];\n\nRS232Baud baud(\n\t.clk(clk),\n\t.enable(Tx_busy),\n\t.tick(bittick)\n);\n\nreg[3:0] Tx_state = 0;\nwire Tx_ready = (Tx_state==0);\nassign Tx_busy = ~Tx_ready;\n\nreg[7:0] Tx_shift = 0;\nalways @(posedge clk)\nbegin\n\tif (Tx_ready & Tx_start)\n\t\tTx_shift <= Tx_data;\n\telse\n\t\tif (Tx_state[3] & bittick)\n\t\t\tTx_shift <= (Tx_shift >> 1);\n\t\t\t\n\tcase(Tx_state)\n\t\t4'b0000: if(Tx_start) Tx_state <= 4'b0100;  4'b0100: if (bittick) Tx_state <= 4'b1000;  4'b1000: if (bittick) Tx_state <= 4'b1001;  4'b1001: if (bittick) Tx_state <= 4'b1010;  4'b1010: if (bittick) Tx_state <= 4'b1011;  4'b1011: if (bittick) Tx_state <= 4'b1100;  4'b1100: if (bittick) Tx_state <= 4'b1101;  4'b1101: if (bittick) Tx_state <= 4'b1110;  4'b1110: if (bittick) Tx_state <= 4'b1111;  4'b1111: if (bittick) Tx_state <= 4'b0010;  4'b0010: if (bittick) Tx_state <= 4'b0011;  4'b0011: if (bittick) Tx_state <= 4'b0000;  default: if (bittick) Tx_state <= 4'b0000;\n\tendcase\t\t\nend\n\nassign Tx = (Tx_state < 4) | (Tx_state[3] & Tx_shift[0]);\nendmodule\n\nmodule RS232Baud(\n\tinput clk,\n\tinput enable,\n\toutput tick\n);\n\nparameter ClkFrequency = 50000000;\nparameter Baud = 115200;\nparameter Oversampling = 1;\n\nfunction integer log2(input integer v); begin log2=0; while(v>>log2) log2=log2+1; end endfunction\nlocalparam AccWidth = log2(ClkFrequency/Baud)+8;  reg [AccWidth:0] Acc = 0;\nlocalparam ShiftLimiter = log2(Baud*Oversampling >> (31-AccWidth));  localparam Inc = ((Baud*Oversampling << (AccWidth-ShiftLimiter))+(ClkFrequency>>(ShiftLimiter+1)))/(ClkFrequency>>ShiftLimiter);\nalways @(posedge clk) if(enable) Acc <= Acc[AccWidth-1:0] + Inc[AccWidth:0]; else Acc <= Inc[AccWidth:0];\nassign tick = Acc[AccWidth];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__b08440f7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    input [7:0] in,\n    output [7:0] final_output);\n\n    wire [3:0] counter_output;\n    wire [7:0] edge_output;\n\n    decade_counter counter (\n        .clk(clk),\n        .pause(pause),\n        .resume(resume),\n        .reset(reset),\n        .q(counter_output)\n    );\n\n    edge_detection edge_det (\n        .clk(clk),\n        .in(in),\n        .anyedge(edge_output)\n    );\n\n    functional_module func_mod (\n        .counter_output(counter_output),\n        .edge_output(edge_output),\n        .final_output(final_output)\n    );\n\nendmodule\n\nmodule decade_counter (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    output [3:0] q\n);\n    reg [3:0] count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (!pause || resume) begin\n            count <= (count == 4'b1001) ? 4'b0000 : count + 4'b0001;\n        end\n    end\n\n    assign q = count;\nendmodule\n\nmodule edge_detection (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n    reg [7:0] prev_in;\n    reg [7:0] edge_count;\n\n    always @(posedge clk) begin\n        prev_in <= in;\n        edge_count <= edge_count + (in & ~prev_in);\n    end\n\n    assign anyedge = edge_count;\nendmodule\n\nmodule functional_module (\n    input [3:0] counter_output,\n    input [7:0] edge_output,\n    output [7:0] final_output\n);\n    assign final_output = counter_output + edge_output;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_4bit_f93c6350", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_4bit (\n    input clk,\n    input rst,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            out <= 4'd0;\n        end else begin\n            if (out == 4'd15) begin\n                out <= 4'd0;\n            end else begin\n                out <= out + 1;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_RAM64X1D2_top_2690ee5b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_RAM64X1D2_top (\n    input clk,\n    input [7:0] din,\n    input we,\n    input [5:0] addr,\n    output [7:0] dout\n);\n\nwire [7:0] dout_a, dout_b;\nwire [5:0] addr_a, addr_b;\n\nassign addr_a = addr[5:0];\nassign addr_b = {1'b0, addr[5:1]};\n\nmy_RAM64X1D2  ram_b (\n    .clk(clk),\n    .din(din),\n    .dout(dout_b),\n    .we(we),\n    .addr(addr_b)\n);\n\nmy_RAM64X1D2 ram_a (\n    .clk(clk),\n    .din(din),\n    .dout(dout_a),\n    .we(we),\n    .addr(addr_a)\n);\n\nassign dout = {dout_a[0], dout_b[0]};\n\nendmodule\n\nmodule my_RAM64X1D2 (\n    input clk,\n    input [7:0] din,\n    output reg [7:0] dout,\n    input we,\n    input [5:0] addr\n);\n\nreg [7:0] mem [0:63];\n\nalways @(posedge clk) begin\n    if (we) begin\n        mem[addr] <= din;\n    end\n    dout <= mem[addr];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__o221ai_d85b242d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PulseGenerator_dcfa68c8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PulseGenerator(\n    input clk,\n    input rst,\n    input [31:0] N,\n    output reg out\n);\n\n    reg [31:0] counter;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            out <= 0;\n        end\n        else begin\n            if (counter == N-1) begin\n                counter <= 0;\n                out <= 1;\n            end\n            else begin\n                counter <= counter + 1;\n                out <= 0;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NPCG_Toggle_SCC_PI_reset_cd605c2a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule NPCG_Toggle_SCC_PI_reset\n#\n(\n    parameter NumberOfWays    =   4\n)\n(\n    iSystemClock,\n    iReset      ,\n    iOpcode     ,\n    iTargetID   ,\n    iSourceID   ,\n    iCMDValid   ,\n    oCMDReady   ,\n    oStart      ,\n    oLastStep   ,\n    iPM_Ready   ,\n    iPM_LastStep,\n    oPM_PCommand\n);\n    input           iSystemClock    ;\n    input           iReset          ;\n    input   [5:0]   iOpcode         ;\n    input   [4:0]   iTargetID       ;\n    input   [4:0]   iSourceID       ;\n    input           iCMDValid       ;\n    output          oCMDReady       ;\n    output          oStart          ;\n    output          oLastStep       ;\n    input   [7:0]   iPM_Ready       ;\n    input   [7:0]   iPM_LastStep    ;\n    output  [7:0]   oPM_PCommand    ;\n\n    wire            wModuleTriggered;\n\n    localparam  State_Idle          = 3'b000;\n    localparam  State_PIResetIssue  = 3'b001;\n    localparam  State_PIWait        = 3'b011;\n    reg [2:0]   rCurState   ;\n    reg [2:0]   rNextState  ;\n    \n    wire wPIResetTrig;\n\n    always @ (posedge iSystemClock)\n        if (iReset)\n            rCurState <= State_Idle;\n        else\n            rCurState <= rNextState;\n\n    always @ (*)\n        case (rCurState)\n        State_Idle:\n            rNextState <= (wModuleTriggered)?State_PIResetIssue:State_Idle;\n        State_PIResetIssue:\n            rNextState <= (iPM_Ready)?State_PIWait:State_PIResetIssue;\n        State_PIWait:\n            rNextState <= (oLastStep)?State_Idle:State_PIWait;\n        default:\n            rNextState <= State_Idle;\n        endcase\n    \n    assign wModuleTriggered     = (iCMDValid && iTargetID == 5'b00101 && iOpcode == 6'b110010);\n    assign oCMDReady            = (rCurState == State_Idle);\n    \n    assign wPIResetTrig         = (rCurState == State_PIResetIssue);\n    \n    assign oStart               = wModuleTriggered;\n    assign oLastStep            = (rCurState == State_PIWait) & iPM_LastStep[4];\n    \n    assign oPM_PCommand[7:0]    = {1'b0, 1'b0, 1'b0, wPIResetTrig, 1'b0, 1'b0, 1'b0, 1'b0};\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "selem_ca7b5494", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule selem (\n  input sreq_0n,\n  input sreq_1n,\n  output activateOut_0r,\n  output activateOut_0a\n);\n\n  assign activateOut_0r = sreq_0n & sreq_1n;\n  assign activateOut_0a = sreq_0n | sreq_1n;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_hdmi_tx_vdma_be3ab0af", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule axi_hdmi_tx_vdma (\n\n  hdmi_fs_toggle,\n  hdmi_raddr_g,\n\n  vdma_clk,\n  vdma_rst,\n  vdma_fs,\n  vdma_fs_ret,\n  vdma_valid,\n  vdma_data,\n  vdma_ready,\n  vdma_wr,\n  vdma_waddr,\n  vdma_wdata,\n  vdma_fs_ret_toggle,\n  vdma_fs_waddr,\n  vdma_tpm_oos,\n  vdma_ovf,\n  vdma_unf);\n\n  localparam      BUF_THRESHOLD_LO = 9'd3;\n  localparam      BUF_THRESHOLD_HI = 9'd509;\n  localparam      RDY_THRESHOLD_LO = 9'd450;\n  localparam      RDY_THRESHOLD_HI = 9'd500;\n\n  input           hdmi_fs_toggle;\n  input   [ 8:0]  hdmi_raddr_g;\n\n  input           vdma_clk;\n  input           vdma_rst;\n  output          vdma_fs;\n  input           vdma_fs_ret;\n  input           vdma_valid;\n  input   [63:0]  vdma_data;\n  output          vdma_ready;\n  output          vdma_wr;\n  output  [ 8:0]  vdma_waddr;\n  output  [47:0]  vdma_wdata;\n  output          vdma_fs_ret_toggle;\n  output  [ 8:0]  vdma_fs_waddr;\n  output          vdma_tpm_oos;\n  output          vdma_ovf;\n  output          vdma_unf;\n\n  reg             vdma_fs_toggle_m1 = 'd0;\n  reg             vdma_fs_toggle_m2 = 'd0;\n  reg             vdma_fs_toggle_m3 = 'd0;\n  reg             vdma_fs = 'd0;\n  reg     [ 8:0]  vdma_fs_waddr = 'd0;\n  reg             vdma_fs_ret_toggle = 'd0;\n  reg             vdma_wr = 'd0;\n  reg     [ 8:0]  vdma_waddr = 'd0;\n  reg     [47:0]  vdma_wdata = 'd0;\n  reg     [22:0]  vdma_tpm_data = 'd0;\n  reg             vdma_tpm_oos = 'd0;\n  reg     [ 8:0]  vdma_raddr_g_m1 = 'd0;\n  reg     [ 8:0]  vdma_raddr_g_m2 = 'd0;\n  reg     [ 8:0]  vdma_raddr = 'd0;\n  reg     [ 8:0]  vdma_addr_diff = 'd0;\n  reg             vdma_ready = 'd0;\n  reg             vdma_almost_full = 'd0;\n  reg             vdma_almost_empty = 'd0;\n  reg             vdma_ovf = 'd0;\n  reg             vdma_unf = 'd0;\n\n  wire    [47:0]  vdma_tpm_data_s;\n  wire            vdma_tpm_oos_s;\n  wire    [ 9:0]  vdma_addr_diff_s;\n  wire            vdma_ovf_s;\n  wire            vdma_unf_s;\n\n  function [8:0] g2b;\n    input [8:0] g;\n    reg   [8:0] b;\n    begin\n      b[8] = g[8];\n      b[7] = b[8] ^ g[7];\n      b[6] = b[7] ^ g[6];\n      b[5] = b[6] ^ g[5];\n      b[4] = b[5] ^ g[4];\n      b[3] = b[4] ^ g[3];\n      b[2] = b[3] ^ g[2];\n      b[1] = b[2] ^ g[1];\n      b[0] = b[1] ^ g[0];\n      g2b = b;\n    end\n  endfunction\n\n  always @(posedge vdma_clk or posedge vdma_rst) begin\n    if (vdma_rst == 1'b1) begin\n      vdma_fs_toggle_m1 <= 'd0;\n      vdma_fs_toggle_m2 <= 'd0;\n      vdma_fs_toggle_m3 <= 'd0;\n    end else begin\n      vdma_fs_toggle_m1 <= hdmi_fs_toggle;\n      vdma_fs_toggle_m2 <= vdma_fs_toggle_m1;\n      vdma_fs_toggle_m3 <= vdma_fs_toggle_m2;\n    end\n  end\n\n  always @(posedge vdma_clk) begin\n    vdma_fs <= vdma_fs_toggle_m2 ^ vdma_fs_toggle_m3;\n    if (vdma_fs_ret == 1'b1) begin\n      vdma_fs_waddr <= vdma_waddr;\n      vdma_fs_ret_toggle <= ~vdma_fs_ret_toggle;\n    end\n  end\n\n  always @(posedge vdma_clk) begin\n    vdma_wr <= vdma_valid & vdma_ready;\n    if (vdma_rst == 1'b1) begin\n      vdma_waddr <= 9'd0;\n    end else if (vdma_wr == 1'b1) begin\n      vdma_waddr <= vdma_waddr + 1'b1;\n    end\n    vdma_wdata <= {vdma_data[55:32], vdma_data[23:0]};\n  end\n\n  assign vdma_tpm_data_s = {vdma_tpm_data, 1'b1, vdma_tpm_data, 1'b0};\n  assign vdma_tpm_oos_s = (vdma_wdata == vdma_tpm_data_s) ? 1'b0 : vdma_wr;\n\n  always @(posedge vdma_clk) begin\n    if ((vdma_rst == 1'b1) || (vdma_fs_ret == 1'b1)) begin\n      vdma_tpm_data <= 23'd0;\n      vdma_tpm_oos <= 1'd0;\n    end else if (vdma_wr == 1'b1) begin\n      vdma_tpm_data <= vdma_tpm_data + 1'b1;\n      vdma_tpm_oos <= vdma_tpm_oos_s;\n    end\n  end\n\n  assign vdma_addr_diff_s = {1'b1, vdma_waddr} - vdma_raddr;\n  assign vdma_ovf_s = (vdma_addr_diff < BUF_THRESHOLD_LO) ? vdma_almost_full : 1'b0;\n  assign vdma_unf_s = (vdma_addr_diff > BUF_THRESHOLD_HI) ? vdma_almost_empty : 1'b0;\n\n  always @(posedge vdma_clk or posedge vdma_rst) begin\n    if (vdma_rst == 1'b1) begin\n      vdma_raddr_g_m1 <= 9'd0;\n      vdma_raddr_g_m2 <= 9'd0;\n    end else begin\n      vdma_raddr_g_m1 <= hdmi_raddr_g;\n      vdma_raddr_g_m2 <= vdma_raddr_g_m1;\n    end\n  end\n\n  always @(posedge vdma_clk) begin\n    vdma_raddr <= g2b(vdma_raddr_g_m2);\n    vdma_addr_diff <= vdma_addr_diff_s[8:0];\n    if (vdma_addr_diff >= RDY_THRESHOLD_HI) begin\n      vdma_ready <= 1'b0;\n    end else if (vdma_addr_diff <= RDY_THRESHOLD_LO) begin\n      vdma_ready <= 1'b1;\n    end\n    if (vdma_addr_diff > BUF_THRESHOLD_HI) begin\n      vdma_almost_full <= 1'b1;\n    end else begin\n      vdma_almost_full <= 1'b0;\n    end\n    if (vdma_addr_diff < BUF_THRESHOLD_LO) begin\n      vdma_almost_empty <= 1'b1;\n    end else begin\n      vdma_almost_empty <= 1'b0;\n    end\n    vdma_ovf <= vdma_ovf_s;\n    vdma_unf <= vdma_unf_s;\n  end\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Decodificador_e03c0ce9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Decodificador(\n   input [6:0] Cuenta,\n   output reg [7:0] catodo1,\n   output reg [7:0] catodo2,\n   output reg [7:0] catodo3,\n   output reg [7:0] catodo4\n);\n\n   always @(*)\n   begin\n      case (Cuenta)\n         7'b0000000: begin\n                        catodo1 <= 8'b00000011;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000001: begin\n                        catodo1 <= 8'b10011111;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011; \n                     end \n         7'b0000010: begin\n                        catodo1 <= 8'b00100101;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000011: begin\n                        catodo1 <= 8'b00001101;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000100: begin\n                        catodo1 <= 8'b10011001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000101: begin\n                        catodo1 <= 8'b01001001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000110: begin\n                        catodo1 <= 8'b01000001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0000111: begin\n                        catodo1 <= 8'b00011111;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001000: begin\n                        catodo1 <= 8'b00000001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001001: begin\n                        catodo1 <= 8'b00011001;\n                        catodo2 <= 8'b00000011;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001010: begin\n                        catodo1 <= 8'b00000011;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001011: begin\n                        catodo1 <= 8'b10011111;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001100: begin\n                        catodo1 <= 8'b00100101;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001101: begin\n                        catodo1 <= 8'b00001101;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001110: begin\n                        catodo1 <= 8'b10011001;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         7'b0001111: begin\n                        catodo1 <= 8'b01001001;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b00000011;\n                        catodo4 <= 8'b00000011;\n                     end \n         default:    begin\n                        catodo1 <= 8'b10011111;\n                        catodo2 <= 8'b10011111;\n                        catodo3 <= 8'b10011111; \n                        catodo4 <= 8'b10011111;\n                     end \t\n      endcase\t\t\n   end\t \n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_mux_35557212", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_mux (\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output reg Y, Z\n);\n\nalways @(*) begin\n    case(S)\n        2'b00: begin\n            if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n        2'b01: begin\n            if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n        2'b10: begin\n            if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n        2'b11: begin\n            if(D) begin\n                Y = 0;\n                Z = 0;\n            end\n            else if(A) begin\n                Y = 1;\n                Z = 0;\n            end\n            else if(B) begin\n                Y = 0;\n                Z = 1;\n            end\n            else if(C) begin\n                Y = 0;\n                Z = 0;\n            end\n            else begin\n                Y = 0;\n                Z = 0;\n            end\n        end\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_with_inverter_e5b69817", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule and_gate_with_inverter (\n    output Y,\n    input  A1,\n    input  A2,\n    input  A3,\n    input  B1,\n    input  C1\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    wire B1_inv;\n    assign B1_inv = ~B1;\n\n    wire and_gate_output;\n    and (and_gate_output, A1, A2, A3);\n\n    assign Y = (C1 == 1'b1) ? 1'b0 : (and_gate_output & B1_inv);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "zet_rxr16_ffa258a3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule zet_rxr16 (\n    input      [15:0] x,\n    input             ci,\n    input      [ 4:0] y,\n    input             e,\n    output reg [15:0] w,\n    output reg        co\n  );\n\n  always @(x or ci or y or e)\n    case (y)\n      default: {co,w} <= {ci,x};\n      5'd01: {co,w} <= e ? {x[0], ci, x[15:1]} : {ci, x[0], x[15:1]};\n      5'd02: {co,w} <= e ? {x[ 1:0], ci, x[15: 2]} : {ci, x[ 1:0], x[15: 2]};\n      5'd03: {co,w} <= e ? {x[ 2:0], ci, x[15: 3]} : {ci, x[ 2:0], x[15: 3]};\n      5'd04: {co,w} <= e ? {x[ 3:0], ci, x[15: 4]} : {ci, x[ 3:0], x[15: 4]};\n      5'd05: {co,w} <= e ? {x[ 4:0], ci, x[15: 5]} : {ci, x[ 4:0], x[15: 5]};\n      5'd06: {co,w} <= e ? {x[ 5:0], ci, x[15: 6]} : {ci, x[ 5:0], x[15: 6]};\n      5'd07: {co,w} <= e ? {x[ 6:0], ci, x[15: 7]} : {ci, x[ 6:0], x[15: 7]};\n      5'd08: {co,w} <= e ? {x[ 7:0], ci, x[15: 8]} : {ci, x[ 7:0], x[15: 8]};\n      5'd09: {co,w} <= e ? {x[ 8:0], ci, x[15: 9]} : {ci, x[ 8:0], x[15: 9]};\n      5'd10: {co,w} <= e ? {x[ 9:0], ci, x[15:10]} : {ci, x[ 9:0], x[15:10]};\n      5'd11: {co,w} <= e ? {x[10:0], ci, x[15:11]} : {ci, x[10:0], x[15:11]};\n      5'd12: {co,w} <= e ? {x[11:0], ci, x[15:12]} : {ci, x[11:0], x[15:12]};\n      5'd13: {co,w} <= e ? {x[12:0], ci, x[15:13]} : {ci, x[12:0], x[15:13]};\n      5'd14: {co,w} <= e ? {x[13:0], ci, x[15:14]} : {ci, x[13:0], x[15:14]};\n      5'd15: {co,w} <= e ? {x[14:0], ci, x[15]} : {ci, x[14:0], x[15]};\n      5'd16: {co,w} <= {x,ci};\n    endcase\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "BUFG_cbfde447", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule BUFG(I,O);\ninput I;\noutput O;\nassign #1 O=I;\nendmodule\n\n\nmodule BUFGMUX(O,I0,I1,S);\ninput I0,I1,S;\noutput O;\nassign #1 O = (S) ? I1 : I0;\nendmodule\n\n\nmodule DCM(CLKIN,PSCLK,PSEN,PSINCDEC,RST,CLK2X,CLK0,CLKFB);\ninput CLKIN, PSCLK, PSEN, PSINCDEC, RST, CLKFB;\noutput CLK2X, CLK0;\n\nassign #1 CLK0 = CLKIN;\n\nreg CLK2X;\ninitial CLK2X=0;\nalways @(posedge CLK0)\nbegin\n  CLK2X = 1'b1;\n  #5;\n  CLK2X = 1'b0;\n  #5;\n  CLK2X = 1'b1;\n  #5;\n  CLK2X = 1'b0;\nend\nendmodule\n\n\nmodule ODDR2(Q,D0,D1,C0,C1);\ninput D0,D1,C0,C1;\noutput Q;\nreg Q;\ninitial Q=0;\nalways @(posedge C0) Q=D0;\nalways @(posedge C1) Q=D1;\nendmodule\n\n\nmodule RAMB16_S9(CLK, ADDR, DI, DIP, DO, DOP, EN, SSR, WE);\ninput CLK, EN, SSR, WE;\ninput [10:0] ADDR;\ninput [7:0] DI;\ninput DIP;\noutput [7:0] DO;\noutput DOP;\n\nparameter WRITE_MODE = 0;\n\nwire [10:0] #1 dly_ADDR = ADDR;\nwire [8:0] #1 dly_DATA = {DIP,DI};\nwire #1 dly_EN = EN;\nwire #1 dly_WE = WE;\n\nreg [8:0] mem[0:2047];\n\nreg [7:0] DO;\nreg DOP;\n\nreg sampled_EN;\nreg [8:0] rddata;\n\ninteger i;\ninitial\nbegin\n  for (i=0; i<2048; i=i+1) mem[i] = 9'h15A;\nend\n\nalways @(posedge CLK)\nbegin\n  if (dly_EN && dly_WE) mem[dly_ADDR] = dly_DATA;\n  rddata = mem[dly_ADDR];\n  sampled_EN = dly_EN;\n  #1;\n  if (sampled_EN) {DOP,DO} = rddata; \nend\nendmodule\n\n\nmodule RAM16X1S (A0,A1,A2,A3,WCLK,WE,D,O);\ninput A0,A1,A2,A3,WCLK,WE,D;\noutput O;\n\nreg mem[0:15];\n\nwire #1 dly_WE = WE;\nwire #1 dly_D = D;\nwire [3:0] addr = {A3,A2,A1,A0};\nwire [3:0] #1 dly_addr = addr;\n\nalways @(posedge WCLK)\nbegin\n  if (dly_WE) mem[dly_addr] = dly_D;\nend\n\nreg [3:0] rdaddr;\nreg O;\nalways @*\nbegin\n  rdaddr = dly_addr;\n  #1;\n  O = mem[rdaddr];\nend\nendmodule\n\n\nmodule RAM16X4S (A0,A1,A2,A3,WCLK,WE,D0,D1,D2,D3,O0,O1,O2,O3);\ninput A0,A1,A2,A3,WCLK,WE,D0,D1,D2,D3;\noutput O0,O1,O2,O3;\nRAM16X1S bit0 (A0,A1,A2,A3,WCLK,WE,D0,O0);\nRAM16X1S bit1 (A0,A1,A2,A3,WCLK,WE,D1,O1);\nRAM16X1S bit2 (A0,A1,A2,A3,WCLK,WE,D2,O2);\nRAM16X1S bit3 (A0,A1,A2,A3,WCLK,WE,D3,O3);\nendmodule\n\n\nmodule SRLC16E (A0,A1,A2,A3,CLK,CE,D,Q15,Q);\ninput A0,A1,A2,A3,CLK,CE,D;\noutput Q15,Q;\n\nreg [15:0] mem;\n\nwire #1 dly_CE = CE;\nwire #1 dly_D = D;\nwire [3:0] addr = {A3,A2,A1,A0};\nwire [3:0] #1 dly_addr = addr;\n\nassign Q15 = mem[15];\n\nalways @(posedge CLK)\nbegin\n  if (dly_CE) mem = {mem,dly_D};\nend\n\nreg [3:0] rdaddr;\nreg Q;\nalways @*\nbegin\n  rdaddr = dly_addr;\n  #1;\n  Q = mem[rdaddr];\nend\nendmodule\n\n\nmodule MUXCY (S,CI,DI,O);\ninput S,CI,DI;\noutput O;\nreg O;\nalways @* begin #0.1; O = (S) ? CI : DI; end\nendmodule\n\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_4bit_bb0297e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_4bit (\n    clk,\n    rst,\n    count\n);\n\ninput clk;\ninput rst;\noutput reg [3:0] count;\n\nalways @(posedge clk, posedge rst) begin\n    if (rst) begin\n        count <= 4'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SDP_RAM_ae47d411", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule SDP_RAM(\n    input clk,\n    input rce,\n    input [9:0] ra,\n    input wce,\n    input [9:0] wa,\n    input [15:0] wd,\n    output [15:0] rq\n);\n\nreg [15:0] memory [0:15];\n\nalways @(posedge clk) begin\n    if (wce) begin\n        memory[wa] <= wd;\n    end\nend\n\nassign rq = (rce) ? memory[ra] : 16'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_en #_f0ca4f7d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_en #(parameter width_p = 1, harden_p = 1, strength_p = 1)\n  (input clock_i,\n   input [width_p-1:0] data_i,\n   input en_i,\n   output reg [width_p-1:0] data_o);\n\n  reg [width_p-1:0] data_r;\n\n  always @(posedge clock_i) begin\n    if (en_i) begin\n      data_r <= data_i;\n    end\n  end\n\n  always @* begin\n    data_o <= data_r;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Synchro_6fac82b5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Synchro(dato, clk, ds);\ninput dato, clk;\noutput ds;\n\nreg ds_reg;\n\nalways @(posedge clk) begin\n    ds_reg <= dato;\nend\n\nassign ds = ds_reg;\n\nendmodule\n\nmodule Sincronizador(\n    incambiarfuncion, incambiarsalida, inrst, inbtup, inbtdown, \n    outcambiarfuncion, outcambiarsalida, outrst, outbtup, outbtdown, clk\n);\ninput incambiarfuncion, incambiarsalida, inrst, inbtup, inbtdown, clk;\noutput outcambiarfuncion, outcambiarsalida, outrst, outbtup, outbtdown;\n\nSynchro S1 (\n    .dato(incambiarfuncion), \n    .clk(clk), \n    .ds(outcambiarfuncion)\n);\n\t \nSynchro S2 (\n    .dato(incambiarsalida), \n    .clk(clk), \n    .ds(outcambiarsalida)\n);\nSynchro S3 (\n    .dato(inrst), \n    .clk(clk), \n    .ds(outrst) \n);\nSynchro S4 (\n    .dato(inbtup), \n    .clk(clk), \n    .ds(outbtup)\n);\nSynchro S5 (\n    .dato(inbtdown), \n    .clk(clk), \n    .ds(outbtdown)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "audio_fifo_a9a2e977", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule audio_fifo(\n    input clk,\n    input rst,\n    input en,\n    input [1:0] mode,\n    input [31:0] din,\n    input we,\n    input re,\n    output [19:0] dout,\n    output [1:0] status,\n    output full,\n    output empty\n);\n\nreg [31:0] mem [0:7]; // 8-word deep memory\nreg [2:0] wp; // write pointer\nreg [3:0] rp; // read pointer\nreg [1:0] status_reg; // status register\nreg [19:0] dout_reg; // output data register\nreg empty_reg; // empty register\n\nassign dout = dout_reg;\nassign status = status_reg;\nassign empty = empty_reg;\nassign full = (wp == rp) & we;\n\nwire [2:0] wp_p1 = wp + 1;\nwire [3:0] rp_p1 = rp + 1;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wp <= 3'h0;\n        rp <= 4'h0;\n        status_reg <= 2'h0;\n        dout_reg <= 20'h0;\n        empty_reg <= 1'b1;\n    end else if (en) begin\n        if (we) begin\n            mem[wp] <= din;\n            wp <= wp_p1;\n        end\n        if (re) begin\n            case (mode)\n                2'h0: dout_reg <= {mem[rp][15:0], 4'h0};\n                2'h1: dout_reg <= {mem[rp][17:0], 2'h0};\n                2'h2: dout_reg <= mem[rp];\n            endcase\n            rp <= (mode == 2'h0) ? rp_p1 : rp + 2;\n        end\n        status_reg <= (wp - rp) - 2'h1;\n        empty_reg <= (rp == wp) & (mode == 2'h0 ? 1'b1 : we);\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mig_7series_v4_0_axi_mc_simple_fifo #_740c0bae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule mig_7series_v4_0_axi_mc_simple_fifo #\n(\n  parameter C_WIDTH  = 8,\n  parameter C_AWIDTH = 4,\n  parameter C_DEPTH  = 16\n)\n(\n  input  wire               clk,       input  wire               rst,       input  wire               wr_en,     input  wire               rd_en,     input  wire [C_WIDTH-1:0] din,       output wire [C_WIDTH-1:0] dout,      output wire               a_full,\n  output wire               full,      output wire               a_empty,\n  output wire               empty      );\n\nlocalparam [C_AWIDTH-1:0] C_EMPTY = ~(0);\nlocalparam [C_AWIDTH-1:0] C_EMPTY_PRE =  (0);\nlocalparam [C_AWIDTH-1:0] C_FULL  = C_EMPTY-1;\nlocalparam [C_AWIDTH-1:0] C_FULL_PRE  = (C_DEPTH < 8) ? C_FULL-1 : C_FULL-(C_DEPTH/8);\n \nreg [C_WIDTH-1:0]  memory [C_DEPTH-1:0];\nreg [C_AWIDTH-1:0] cnt_read;\n\n\nalways @(posedge clk) begin : BLKSRL\ninteger i;\n  if (wr_en) begin\n    for (i = 0; i < C_DEPTH-1; i = i + 1) begin\n      memory[i+1] <= memory[i];\n    end\n    memory[0] <= din;\n  end\nend\n\nalways @(posedge clk) begin\n  if (rst) cnt_read <= C_EMPTY;\n  else if ( wr_en & !rd_en) cnt_read <= cnt_read + 1'b1;\n  else if (!wr_en &  rd_en) cnt_read <= cnt_read - 1'b1;\nend\n\nassign full  = (cnt_read == C_FULL);\nassign empty = (cnt_read == C_EMPTY);\nassign a_full  = ((cnt_read >= C_FULL_PRE) && (cnt_read != C_EMPTY));\nassign a_empty = (cnt_read == C_EMPTY_PRE);\n\nassign dout  = (C_DEPTH == 1) ? memory[0] : memory[cnt_read];\n\nendmodule `default_nettype wire\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "traffic_light_fsm_69cefee5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule traffic_light_fsm (\n  input clk,\n  input reset,\n  output reg red,\n  output reg green,\n  output reg yellow\n);\n\n  parameter RED = 2'b00, GREEN = 2'b01, YELLOW = 2'b10;\n  reg [1:0] state, next_state;\n  reg [3:0] count;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= RED;\n      count <= 0;\n    end else begin\n      state <= next_state;\n      count <= count + 1;\n    end\n  end\n\n  always @(*) begin\n    case (state)\n      RED: begin\n        red <= 1;\n        green <= 0;\n        yellow <= 0;\n        if (count == 5) begin\n          next_state = GREEN;\n        end else begin\n          next_state = RED;\n        end\n      end\n\n      GREEN: begin\n        red <= 0;\n        green <= 1;\n        yellow <= 0;\n        if (count == 10) begin\n          next_state = YELLOW;\n        end else begin\n          next_state = GREEN;\n        end\n      end\n\n      YELLOW: begin\n        red <= 0;\n        green <= 0;\n        yellow <= 1;\n        if (count == 2) begin\n          next_state = RED;\n        end else begin\n          next_state = YELLOW;\n        end\n      end\n\n      default: begin\n        red <= 0;\n        green <= 0;\n        yellow <= 0;\n        next_state = RED;\n      end\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "address_filter_049dcaef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule address_filter\n  (input clk,\n   input reset,\n   input go,\n   input [7:0] data,\n   output match,\n   output done);\n\n   reg [2:0] af_state;\n\n   always @(posedge clk)\n     if(reset)\n       af_state <= 0;\n     else if(go)\n       if(data[0] == 1'b0)\n         af_state <= 1'b0;\n       else\n         af_state <= 3'b001;\n     else\n       case(af_state)\n         3'b001: af_state <= 3'b010;\n         3'b010: af_state <= 3'b011;\n         3'b011: af_state <= 3'b100;\n         3'b100: af_state <= 3'b101;\n         3'b101: af_state <= 3'b110;\n         3'b110: af_state <= 3'b000;\n         default: af_state <= 3'b000;\n       endcase\n\n   assign match = (af_state == 3'b110);\n   assign done = (af_state == 3'b110) || (af_state == 3'b000);\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ch_pcma_9f711d92", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ch_pcma(\n\tinput CLK,\n\tinput CLK_SAMP,\n\tinput nRESET,\n\tinput FLAGMASK,\n\toutput reg END_FLAG,\n\tinput KEYON, KEYOFF,\n\t\n\tinput [11:0] JEDI_DOUT,\n\tinput [15:0] ADDR_START,\n\tinput [15:0] ADDR_STOP,\n\tinput [7:0] VOLPAN,\t\t\t\toutput [21:0] ROM_ADDR,\n\toutput reg [3:0] DATA,\n\toutput reg [9:0] ADPCM_STEP,\tinput [7:0] ROM_DATA,\n\toutput reg [15:0] SAMPLE_OUT\n);\n\n\treg RUN;\n\treg [1:0] ROM_BANK;\n\treg [19:0] ADDR_CNT;\n\treg NIBBLE;\n\treg [11:0] ADPCM_ACC;\n\t\n\treg SET_FLAG;\n\treg PREV_FLAGMASK;\n\t\n\tassign ROM_ADDR = { ROM_BANK, ADDR_CNT };\n\t\n\talways @(posedge CLK)\n\tbegin\n\t\tif (!nRESET)\n\t\tbegin\n\t\t\tSET_FLAG <= 0;\t\t\tPREV_FLAGMASK <= 0;\tRUN <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\n\t\t\tif (KEYON)\n\t\t\tbegin\n\t\t\t\tADDR_CNT <= { ADDR_START[11:0], 8'h0 };\n\t\t\t\tROM_BANK <= ADDR_START[13:12];\tEND_FLAG <= 0;\n\t\t\t\tNIBBLE <= 0;\t\tADPCM_ACC <= 0;\n\t\t\t\tADPCM_STEP <= 0;\n\t\t\t\tRUN <= 1;\n\t\t\tend\n\t\t\t\n\t\t\tif (KEYOFF)\n\t\t\t\tRUN <= 0;\n\t\t\t\n\t\t\tif (RUN && CLK_SAMP)\n\t\t\tbegin\n\t\t\t\tif ((FLAGMASK == 1) && (PREV_FLAGMASK == 0))\n\t\t\t\t\tEND_FLAG <= 0;\n\t\t\t\t\n\t\t\t\tPREV_FLAGMASK <= FLAGMASK;\n\t\t\t\t\n\t\t\t\tif (ADDR_CNT[19:8] == ADDR_STOP[11:0])\n\t\t\t\tbegin\n\t\t\t\t\tif (SET_FLAG == 0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tSET_FLAG <= 1;\n\t\t\t\t\t\tEND_FLAG <= ~FLAGMASK;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tSET_FLAG <= 0;\n\t\t\t\t\n\t\t\t\t\tif (NIBBLE)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tDATA <= ROM_DATA[3:0];\n\t\t\t\t\t\tADDR_CNT <= ADDR_CNT + 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tDATA <= ROM_DATA[7:4];\n\t\t\t\t\t\n\t\t\t\t\tADPCM_ACC <= ADPCM_ACC + JEDI_DOUT;\n\t\t\t\t\t\n\t\t\t\t\tcase (DATA[2:0])\n\t\t\t\t\t\t0, 1, 2, 3 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP >= 16)\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP - 10'd16;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t4 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 32))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd32;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t5 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 80))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd80;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t6 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 112))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd112;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t7 :\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tif (ADPCM_STEP <= (768 - 144))\n\t\t\t\t\t\t\t\tADPCM_STEP <= ADPCM_STEP + 10'd144;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tADPCM_STEP <= 768;\n\t\t\t\t\t\tend\n\t\t\t\t\tendcase\n\t\t\t\t\t\n\t\t\t\t\tSAMPLE_OUT <= ADPCM_ACC[11] ? { 4'b1111, ADPCM_ACC } : { 4'b0000, ADPCM_ACC };\n\t\t\t\t\t\n\t\t\t\t\tNIBBLE <= ~NIBBLE;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "XORCY_c5861657", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule XORCY (O, CI, LI);\n\n\n`ifdef XIL_TIMING\n\n    parameter LOC = \"UNPLACED\";\n\n`endif\n\n    \n    output O;\n\n    input  CI, LI;\n\n\txor X1 (O, CI, LI);\n\n`ifdef XIL_TIMING\n\n    specify\n        \n        (CI => O) = (0:0:0, 0:0:0);\n        (LI => O) = (0:0:0, 0:0:0);\n        specparam PATHPULSE$ = 0;\n        \n    endspecify\n\n`endif\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "delay_calc_37e06a7e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule delay_calc (\n\tclk40,\n\trst,\n\tdata_offset_delay,\n\tdelay_modifier,\n\tscan_delay,\n\tstrb,\n\tadc_clock_delay,\n\tadc_data_delay,\n\tadc_drdy_delay,\n\tsaturated\n);\n\ninput clk40;\ninput rst;\ninput [6:0] data_offset_delay;\ninput [6:0] delay_modifier;\ninput [5:0] scan_delay;\ninput strb;\n\noutput [5:0] adc_clock_delay;\noutput [5:0] adc_data_delay;\noutput [5:0] adc_drdy_delay;\noutput saturated;\n\nreg [5:0] adc_clock_delay;\nreg [7:0] adc_data_delay_2s;\nreg [7:0] adc_drdy_delay_2s;\n\nalways @(posedge clk40) begin\n\tif (rst) begin\n\t\tadc_clock_delay <= 0;\n\t\tadc_data_delay_2s <= 0;\n\t\tadc_drdy_delay_2s <= 0;\n\tend else begin\n\t\tif (strb) begin\n\t\t\tadc_data_delay_2s <= 8'd32 + {data_offset_delay[6],data_offset_delay} + {delay_modifier[6],delay_modifier} + (8'b1 + ~scan_delay);\n\t\t\tadc_drdy_delay_2s <= 8'd32 + {delay_modifier[6],delay_modifier} + (8'b1 + ~scan_delay);\n\t\t\tadc_clock_delay <= scan_delay;\n\t\tend\n\tend\nend\n\nassign adc_data_delay = (adc_data_delay_2s[7] ? 6'b0 : ( (adc_data_delay_2s[6:0] > 6'd63) ? 6'd63 : adc_data_delay_2s[5:0]));\nassign adc_drdy_delay = (adc_drdy_delay_2s[7] ? 6'b0 : ( (adc_drdy_delay_2s[6:0] > 6'd63) ? 6'd63 : adc_drdy_delay_2s[5:0]));\nassign saturated = ( (adc_data_delay_2s[7] ? 1 : ( (adc_data_delay_2s[6:0] > 6'd63) ? 1 : 0)) ||\n\t\t\t\t\t\t\t(adc_drdy_delay_2s[7] ? 1 : ( (adc_drdy_delay_2s[6:0] > 6'd63) ? 1 : 0)) );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_2to4_f0c5e93b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_2to4 (\n  input [1:0] in,\n  output [3:0] out\n);\n\n  assign out[0] = (in == 2'b00) ? 1'b1 : 1'b0;\n  assign out[1] = (in == 2'b01) ? 1'b1 : 1'b0;\n  assign out[2] = (in == 2'b10) ? 1'b1 : 1'b0;\n  assign out[3] = (in == 2'b11) ? 1'b1 : 1'b0;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "select_logic_3e7f0f34", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule select_logic(i1, i2, i3, i4, i5, i6, i7, i8, s1, s2, s3, a1);\n  input i1, i2, i3, i4, i5, i6, i7, i8, s1, s2, s3;\n  output a1;\n\n  assign a1 = (i1 & (!s1) & (!s2) & (!s3)) |\n              (i2 & (!s1) & (!s2) & (s3)) |\n              (i3 & (!s1) & (s2) & (!s3)) |\n              (i4 & (!s1) & (s2) & (s3)) |\n              (i5 & (s1) & (!s2) & (!s3)) |\n              (i6 & (s1) & (!s2) & (s3)) |\n              (i7 & (s1) & (s2) & (!s3)) |\n              (i8 & (s1) & (s2) & (s3));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "longest_sequence_detection_1bf6e5a7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule longest_sequence_detection (\n  input clk,\n  input reset,\n  input [15:0] data,\n  output [3:0] length,\n  output [3:0] start_index\n);\n\nreg [3:0] count; // counter for current sequence length\nreg [3:0] max_count; // counter for longest sequence length\nreg [3:0] index; // counter for current sequence starting index\nreg [3:0] max_index; // counter for starting index of longest sequence\n\nalways @(posedge clk) begin\n  if (reset) begin\n    count <= 0;\n    max_count <= 0;\n    index <= 0;\n    max_index <= 0;\n  end else begin\n    if (data == 16'hFFFF) begin // all 1's case\n      count <= 16;\n      max_count <= 16;\n      index <= 0;\n      max_index <= 0;\n    end else if (data == 16'h0000) begin // all 0's case\n      count <= 0;\n      max_count <= 0;\n      index <= 0;\n      max_index <= 0;\n    end else begin // normal case\n      if (data[0] == 1) begin\n        if (count == 0) begin\n          index <= 0;\n        end\n        count <= count + 1;\n      end else begin\n        if (count > max_count) begin\n          max_count <= count;\n          max_index <= index;\n        end\n        count <= 0;\n        index <= index + count + 1;\n      end\n    end\n  end\nend\n\n\nwire [3:0] length_int = max_count;\n\nwire [3:0] start_index_int = max_index;\n\nassign length = length_int;\nassign start_index = start_index_int;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "constant_enable_5609970f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule constant_enable (\n  input clk,\n  input reset,\n  input enable,\n  output reg out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      out <= 0;\n    end else if (enable) begin\n      out <= 1;\n    end else begin\n      out <= 0;\n    end\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_4bit_923a09bd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1_4bit(Y, A, B, C, D, S0, S1);\n\n    input [3:0] A, B, C, D;\n    input S0, S1;\n    output [3:0] Y;\n    \n    wire [3:0] AB, CD, Y_temp;\n    \n    assign AB = (S0 & ~S1) ? B : A;\n    assign CD = (S0 & S1) ? D : C;\n    assign Y_temp = (S0 | S1) ? CD : AB;\n    assign Y = Y_temp;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_a20165d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule full_adder (\n  input A,\n  input B,\n  input C_in,\n  output S,\n  output C_out\n);\n\nassign S = A ^ B ^ C_in;\nassign C_out = (A & B) | (A & C_in) | (B & C_in);\n\nendmodule\nmodule ripple_carry_adder #(\n  parameter n = 4 // number of bits in A and B\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output [n:0] C\n);\n\nwire [n:0] carry; // carry signals for each bit position\n\n// generate carry signals\ngenvar i;\ngenerate\n  for (i = 0; i < n; i = i + 1) begin : carry_gen\n    full_adder fa(\n      .A(A[i]),\n      .B(B[i]),\n      .C_in(carry[i]),\n      .S(C[i]),\n      .C_out(carry[i+1])\n    );\n  end\nendgenerate\n\n// set carry-in for least significant bit\nassign carry[0] = 1'b0;\n\n// assign output\nassign C[n] = carry[n];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register16_1d6292ac", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`ifndef _REGISTER\n`define _REGISTER\n\nmodule register16(clk, out, in, write, reset);  output reg [15:0] out;\n\tinput      [15:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 16'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register4(clk, out, in, write, reset);  output reg [3:0] out;\n\tinput      [3:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 4'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\nmodule register3(clk, out, in, write, reset);  output reg [2:0] out;\n\tinput      [2:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 3'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register2(clk, out, in, write, reset);  output reg [1:0] out;\n\tinput      [1:0] in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 2'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule register1(clk, out, in, write, reset);  output reg out;\n\tinput      in;\n\tinput      clk, write, reset;\n\t\n\talways@(posedge clk) begin\n\t\tif(reset==0) begin\n\t\t\tout = 1'b0;\n\t\tend\n\t\telse if(write == 1'b0) begin\n\t\t\tout = in;\n\t\tend\n\tend\n\t\nendmodule\n\n`endif\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "touch_sensor_bd165690", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule touch_sensor (\n  input wire touch_in,\n  output reg touch_out\n);\n\n  reg touch_detected;\n\n  always @(posedge touch_in) begin\n    touch_detected <= #1 touch_in;  // Delay the assignment by 1 time unit to avoid multiple edge sensitive events\n  end\n\n  always @(*) begin\n    touch_out = touch_detected;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "queue #_5ccc165c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule queue #\n    (\n    parameter integer WIDTH = 108,\n    parameter integer LENGTH = 4\n    )\n    (\n    input wire GCLK,\n    input wire RES,\n    input wire get,\n    input wire put,\n    output reg full = 1'b0,\n    output reg empty = 1'b1,\n    input wire [WIDTH-1:0] DIN,\n    output reg [WIDTH-1:0] DOUT\n    );\n    \n    reg [WIDTH-1:0] q[0:LENGTH-1];\n    reg [63:0] head = 64'd0; reg get_release = 1'b1;\n    reg put_release = 1'b1;\n    \n    wire to_get;\n    wire to_put;\n    assign to_get = get & get_release;\n    assign to_put = put & put_release;\n\n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            get_release <= 1'b1;\n        end\n        else if (get == 1'b0) begin\n            get_release <= 1'b1;\n        end\n        else if (to_get == 1'b1) begin\n            get_release <= 1'b0;\n        end\n        \n        if (RES == 1'b1) begin\n            put_release <= 1'b1;\n        end\n        else if (put == 1'b0) begin\n            put_release <= 1'b1;\n        end\n        else if (to_put == 1'b1) begin\n            put_release <= 1'b0;\n        end\n    end\n\n    integer i = 0;\n    always @(posedge GCLK) begin\n        if (to_put & !to_get) begin\n            for (i = LENGTH - 1; i > 0; i = i - 1) begin\n                q[i] <= q[i - 1];\n            end\n            q[0] <= DIN;\n        end\n        \n        if (to_get &  !to_put & !empty) begin\n            DOUT <= q[head - 64'd1];\n        end\n        else if (to_get & to_put) begin\n            DOUT <= DIN;\n        end\n    end\n    \n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            head <= 64'd0;\n            full <= 1'b0;\n            empty <= 1'b1;\n        end\n        else if (!full & to_put & !to_get) begin\n            head <= head + 64'd1;\n            empty <= 1'b0; if (head == LENGTH - 1) begin\n                full <= 1'b1;\n            end\n        end\n        else if (!empty & to_get & !to_put) begin\n            head <= head - 64'd1;\n            full <= 1'b0; if (head == 64'd1) begin\n                empty <= 1'b1;\n            end\n        end\n        else begin\n            head <= head;\n            full <= full;\n            empty <= empty;\n        end\n    end\n    \n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hvl__einvp_f48c6b19", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hvl__einvp (\n    Z ,\n    A ,\n    TE\n);\n\n    output Z ;\n    input  A ;\n    input  TE;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    notif1 notif10 (Z     , A, TE          );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lsu_wb_router_067ecd6b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule lsu_wb_router \n(\n   out_sgpr_dest_addr, out_sgpr_dest_data, out_sgpr_dest_wr_en,\n   out_sgpr_instr_done, out_sgpr_instr_done_wfid, out_vgpr_dest_addr,\n   out_vgpr_dest_data, out_vgpr_dest_wr_en, out_vgpr_dest_wr_mask,\n   out_vgpr_instr_done, out_vgpr_instr_done_wfid,\n   out_tracemon_retire_pc, out_gm_or_lds, out_rfa_dest_wr_req,\n   in_rd_data, in_wftag_resp, in_ack, in_exec_value,\n   in_lddst_stsrc_addr, in_reg_wr_en, in_instr_pc, in_gm_or_lds\n   );\n\ninput [8191:0] in_rd_data;\ninput [6:0] in_wftag_resp;\ninput in_ack;\ninput [63:0] in_exec_value;\ninput [11:0] in_lddst_stsrc_addr;\ninput [3:0] in_reg_wr_en;\ninput [31:0] in_instr_pc;\ninput in_gm_or_lds;\n\noutput [8:0] out_sgpr_dest_addr;\noutput [127:0] out_sgpr_dest_data;\noutput [3:0] out_sgpr_dest_wr_en;\noutput out_sgpr_instr_done;\noutput [5:0] out_sgpr_instr_done_wfid;\n\noutput [9:0] out_vgpr_dest_addr;\noutput [8191:0] out_vgpr_dest_data;\noutput [3:0] out_vgpr_dest_wr_en;\noutput [63:0] out_vgpr_dest_wr_mask;\noutput out_vgpr_instr_done;\noutput [5:0] out_vgpr_instr_done_wfid;\n\noutput [31:0] out_tracemon_retire_pc;\noutput out_gm_or_lds;\n   output \t  out_rfa_dest_wr_req;\n\nreg [3:0] out_sgpr_dest_wr_en;\nreg [3:0] out_vgpr_dest_wr_en;\n   \nreg out_sgpr_instr_done;\nreg out_vgpr_instr_done;\n\nassign out_sgpr_dest_addr = in_lddst_stsrc_addr[8:0];\nassign out_sgpr_dest_data = in_rd_data[127:0];\nassign out_sgpr_instr_done_wfid = in_wftag_resp[6:1];\n\nassign out_vgpr_dest_addr = in_lddst_stsrc_addr[9:0];\nassign out_vgpr_dest_data = in_rd_data;\nassign out_vgpr_dest_wr_mask = in_exec_value;\nassign out_vgpr_instr_done_wfid = in_wftag_resp[6:1];\n\nassign out_tracemon_retire_pc = in_instr_pc;\nassign out_gm_or_lds = in_gm_or_lds;\n\nalways @* begin\n   casex({in_ack, in_wftag_resp[0], in_lddst_stsrc_addr[11:10]})\n   4'b0_?_??:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   4'b1_1_10:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= in_reg_wr_en;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b1;\n      end\n   4'b1_1_11:\n      begin\n         out_sgpr_dest_wr_en <= in_reg_wr_en;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b1;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   4'b1_0_10:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b1;\n      end\n   4'b1_0_11:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b1;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   4'b1_?_0?:\n      begin\n         out_sgpr_dest_wr_en <= 4'b0;\n         out_vgpr_dest_wr_en <= 4'b0;\n         out_sgpr_instr_done <= 1'b0;\n         out_vgpr_instr_done <= 1'b0;\n      end\n   default:\n      begin\n         out_sgpr_dest_wr_en <= 4'bx;\n         out_vgpr_dest_wr_en <= 4'bx;\n         out_sgpr_instr_done <= 1'bx;\n         out_vgpr_instr_done <= 1'bx;\n      end\n   endcase\nend\n\n   assign out_rfa_dest_wr_req = (|out_vgpr_dest_wr_en) | (|out_sgpr_dest_wr_en);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_or_xnor_vector_39243d83", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_or_xnor_vector (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [3:0] in,   // 4-bit input vector\n    input select,     // Select input to choose between AND/OR/XNOR gate and input vector splitter\n    output out_and,   // Output of the 4-input AND gate\n    output out_or,    // Output of the 4-input OR gate\n    output out_xnor,  // Output of the 4-input XNOR gate\n    output [2:0] outv // 3-bit vector that represents the input vector's positions 0, 1, and 2, respectively\n);\n\nwire [2:0] in_split;\nwire [3:0] and_or_xnor_in;\n\nand_or_xnor and_or_xnor_inst (\n    .in(and_or_xnor_in),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xnor(out_xnor)\n);\n\ninput_vector_splitter input_vector_splitter_inst (\n    .in(in),\n    .out(in_split)\n);\n\nassign and_or_xnor_in = select ? {in_split[2], in_split[1], in_split[0], in_split[0]} : {in[3], in[2], in[1], in[0]};\n\nassign outv[0] = in[0] & in[1] & in[2];\nassign outv[1] = ~in[0] & ~in[1] & ~in[2];\nassign outv[2] = {in[2], in[1], in[0]};\n\nendmodule\n\nmodule and_or_xnor (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xnor\n);\n\nassign out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xnor = ~(in[0] ^ in[1] ^ in[2] ^ in[3]);\n\nendmodule\n\nmodule input_vector_splitter (\n    input [3:0] in,\n    output [2:0] out\n);\n\nassign out[0] = in[0];\nassign out[1] = in[1];\nassign out[2] = in[2];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_sequence_detection_4ac8dead", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fsm_sequence_detection (\n  input clk,\n  input reset,\n  input [7:0] data,\n  output reg match\n);\n\n  parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n  reg [1:0] state, next_state;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= S0;\n      match <= 1'b0;\n    end\n    else begin\n      state <= next_state;\n      match <= (state == S3);\n    end\n  end\n\n  always @(*) begin\n    next_state = state;\n    case(state)\n      S0: if (data[7:4] == 4'b1010) next_state = S1;\n      S1: if (data[7:4] == 4'b1010) next_state = S2;\n          else next_state = S0;\n      S2: if (data[7:4] == 4'b1010) next_state = S3;\n          else next_state = S0;\n      S3: next_state = S0;\n    endcase\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4_lut16_01bef06a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4_lut16 (\n    input I0,\n    input I1,\n    input I2,\n    input I3,\n    input S0,\n    input S1,\n    output reg O\n);\n\n    reg [15:0] lut;\n\n    always @* begin\n        case ({S1, S0})\n            2'b00: O = lut[0];\n            2'b01: O = lut[1];\n            2'b10: O = lut[2];\n            2'b11: O = lut[3];\n        endcase\n    end\n\n    always @* begin\n        lut[0] = I0;\n        lut[1] = I1;\n        lut[2] = I2;\n        lut[3] = I3;\n        lut[4] = I0;\n        lut[5] = I1;\n        lut[6] = I2;\n        lut[7] = I3;\n        lut[8] = I0;\n        lut[9] = I1;\n        lut[10] = I2;\n        lut[11] = I3;\n        lut[12] = I0;\n        lut[13] = I1;\n        lut[14] = I2;\n        lut[15] = I3;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "eth_rcr_unpack #_5d89ab97", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule eth_rcr_unpack #(parameter unpack_dst_addr = 48'hAABBCCDDEEFF)(\ninput    \t      i_axi_rx_clk,\ninput    \t      i_axi_rx_rst_n,\ninput    \t      i_rx_axis_fifo_tvalid,\ninput  [7:0]      i_rx_axis_fifo_tdata,\ninput             i_rx_axis_fifo_tlast,\noutput            o_rx_axis_fifo_tready,\noutput            o_axi_rx_clk,\noutput            o_axi_rx_rst_n,\noutput reg [7:0]  o_axi_rx_tdata,\noutput reg        o_axi_rx_data_tvalid,\ninput             i_axi_rx_data_tready,\noutput reg        o_axi_rx_data_tlast,\ninput             loop_back\n);\n\nassign o_axi_rx_clk   =   i_axi_rx_clk;\nassign o_axi_rx_rst_n =   i_axi_rx_rst_n;\nassign o_rx_axis_fifo_tready = i_axi_rx_data_tready;\n\nreg [3:0] pkt_len_cntr;\nreg [7:0] dest_addr [5:0];\nreg [47:0] destination_addr;\nreg state;\nreg no_filter;\n\nparameter idle       = 1'b0,\n          stream_pkt = 1'b1;\n \nalways @(posedge i_axi_rx_clk)\nbegin\n    if(~i_axi_rx_rst_n)\n\tbegin\n\t    o_axi_rx_data_tvalid   <=    1'b0;\n\t\tstate                  <=    idle;\n\t\tpkt_len_cntr           <=    4'd0;\n        o_axi_rx_tdata         <=    8'd0;\n        no_filter              <=    1'b0;\n        dest_addr[0]           <=    8'd0;\n        dest_addr[1]           <=    8'd0;\n        dest_addr[2]           <=    8'd0;\n        dest_addr[3]           <=    8'd0;\n        dest_addr[4]           <=    8'd0;\n        dest_addr[5]           <=    8'd0;\n        \n\tend\n\telse\n\tbegin\n\t    case(state)\n\t        idle:begin\n\t\t\t     o_axi_rx_data_tvalid <= 1'b0;\n\t\t\t\t  o_axi_rx_data_tlast  <= 1'b0;\n\t           if(i_rx_axis_fifo_tvalid & i_axi_rx_data_tready) begin\n\t\t            pkt_len_cntr <= pkt_len_cntr+1'b1;  if(pkt_len_cntr == 'd13)            begin\n                        if (((~loop_back) && (destination_addr == unpack_dst_addr)) || loop_back)\n\t\t\t\t            no_filter   <= 1'b1;\n                        else\n                            no_filter   <= 1'b0;\n\t\t\t\t        pkt_len_cntr <= 0;\t\n                        state <= stream_pkt;\n\t\t\t\t    end\t\n                    if(pkt_len_cntr < 'd6)\n                        dest_addr[pkt_len_cntr] <= i_rx_axis_fifo_tdata; end\n            end\n\t\t\tstream_pkt:begin\n\t\t\t   o_axi_rx_data_tvalid    <=    i_rx_axis_fifo_tvalid & no_filter;\n\t\t\t\to_axi_rx_tdata          <=    i_rx_axis_fifo_tdata;\n\t\t\t\to_axi_rx_data_tlast     <=    i_rx_axis_fifo_tlast & no_filter;\n\t\t\t\tif(i_rx_axis_fifo_tlast)\n\t\t\t\tbegin\n\t\t\t\t\tstate                  <=  idle;\n\t\t\t\tend\t\n\t\t\tend\n\t    endcase\n\tend\nend\n\nalways @(posedge i_axi_rx_clk)\nbegin\n    destination_addr <= {dest_addr[0],dest_addr[1],dest_addr[2],dest_addr[3],dest_addr[4],dest_addr[5]};\nend\t \n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sparc_ifu_cmp35_5e09d448", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sparc_ifu_cmp35(\n   hit, \n   a, b, valid\n   );\n\n   input [34:0] a, b;\n   input \tvalid;\n   \n   output \thit;\n\n   reg \t\thit;\n   wire \tvalid;\n   wire [34:0] \ta, b;\n\n   always @ (a or b or valid)\n     begin\n\tif ((a==b) & valid)\n\t  hit = 1'b1;\n\telse\n\t  hit = 1'b0;\n     end endmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hs__nand4bb_5bcf9a22", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_hs__nand4bb (\n    Y,\n    A_N,\n    B_N,\n    C,\n    D\n);\n\n    output Y;\n    input A_N;\n    input B_N;\n    input C;\n    input D;\n\n    assign Y = ~(A_N & B_N & C & D);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_10d1591a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter(\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count_out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_out <= 4'b0000;\n    end\n    else if (enable) begin\n      count_out <= count_out + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SPI_01d54bad", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule SPI\n( input Clk,\n  output reg MOSI,\n  input MISO,\n  output reg SCLK,\n  output reg SCE,\n  input Enable,\n  input Speed,             input [7:0] SendData,\n  input SendReq,\n  output reg SendAck,\n  output reg [7:0] RecvData,\n  output reg RecvAdv,\n  input RecvAck\n);\n\n  parameter real ClkPeriod = 20.0;\n  `define LO_SPEED_TICKS_UP\t$rtoi(((1.00 / 400000.00) / (ClkPeriod * 1.0E-9)) / 2.00)  \n  `define LO_SPEED_TICKS_DW\t($rtoi((1.00 / 400000.00) / (ClkPeriod * 1.0E-9)) - `LO_SPEED_TICKS_UP)\n  `define HI_SPEED_TICKS_UP\t$rtoi(((1.00 / 5000000.00) / (ClkPeriod * 1.0E-9)) / 2.00)  \n  `define HI_SPEED_TICKS_DW\t($rtoi((1.00 / 5000000.00) / (ClkPeriod * 1.0E-9)) - `HI_SPEED_TICKS_UP)\n\n  integer ClkCounter;\n  integer ClkStatus;\n  integer Counter;\n  reg [7:0] ShiftReg;\n\n  initial\n    begin\n\t   ClkCounter = 0;\n\t\tClkStatus = 0;\n\t\tMOSI = 1;\n\t\tSCLK = 0;\n\t\tSCE = 1;\n\t\tSendAck = 0;\n\t\tShiftReg = 8'hFF;\n\t end\n\t \n  always @(posedge Clk)\n    begin\n\t\tif (SendReq == 1) SendAck = 1; else begin end\n      if (RecvAck == 1) RecvAdv = 0; else begin end \n\t\tif (Enable == 0) SCE = 1; else begin end\n\t   case(ClkStatus)\n\t\t  0: begin\n\t\t       ClkCounter = 0;\n\t\t\t\t SCLK = 0;\n\t\t\t\t ClkStatus = 2;\n\t\t     end\n\t\t  1: begin\n\t\t       if (ClkCounter > 1) ClkCounter = ClkCounter - 1;\n\t\t\t    else begin\n\t\t\t\t        ClkCounter = (Speed == 0) ? `LO_SPEED_TICKS_DW : `HI_SPEED_TICKS_DW;\n\t\t\t\t\t\t  SCLK = 0;\n\t\t\t\t\t\t  ClkStatus = 2;\n\t\t\t\t\t\t  if (Enable == 1)\n\t\t\t\t\t\t    begin\n\t\t\t\t\t\t      if (SCE == 1)\n\t\t\t\t\t\t        begin\n\t\t\t\t\t\t\t       SCE = 0;\n\t\t\t\t\t\t\t\t    if (SendAck == 1)\n                              begin\n\t\t\t\t\t\t\t\t\t     ShiftReg = {SendData[6:0],1'b0};\n\t\t\t\t\t\t\t\t\t\t  MOSI = SendData[7];\n\t\t\t\t\t\t\t\t        SendAck = 0;\n                              end\n                            else \n\t\t\t\t\t\t\t\t\t   begin\n\t\t\t\t\t\t\t\t\t     ShiftReg = 8'b11111111;\n\t\t\t\t\t\t\t\t\t\t  MOSI = 1;\n\t\t\t\t\t\t\t\t\t\tend\n                            Counter = 7;\n\t\t\t\t\t\t\t     end\n\t\t\t\t\t\t      else\n\t\t\t\t\t\t        begin\n\t\t\t\t\t\t\t       if (Counter > 0) \n\t\t\t\t\t\t\t\t      begin\n\t\t\t\t\t\t\t\t        Counter = Counter - 1;\n\t\t\t\t\t\t\t\t\t     MOSI = ShiftReg[7];\n\t\t\t\t\t\t\t\t\t\t  ShiftReg = {ShiftReg[6:0],1'b0};\n\t\t\t\t\t\t\t\t      end\n\t\t\t\t\t\t\t\t    else\n\t\t\t\t\t\t\t\t      begin\n\t\t\t\t\t\t\t\t        if (SendAck == 1)\n                                  begin\n\t\t\t\t\t\t\t\t\t         ShiftReg = {SendData[6:0],1'b0};\n\t\t\t\t\t\t\t\t\t\t\t\tMOSI = SendData[7];\n\t\t\t\t\t\t\t\t            SendAck = 0;\n                                  end\n                                else\n                                  begin\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t\t\t      ShiftReg = 8'b11111111;\n\t\t\t\t\t\t\t\t\t\t\t\tMOSI = 1;\n\t\t\t\t\t\t\t\t\t\t\t end\n                                Counter = 7;\n\t\t\t\t\t\t\t\t      end\n\t\t\t\t\t\t\t     end\n\t\t\t\t\t\t\t end\n                    else MOSI = 1;\t\t\t\t\t\t\t \n\t\t\t\t      end\n\t\t     end\n\t\t  2: begin\n\t\t       if (ClkCounter > 1) ClkCounter = ClkCounter - 1;\n\t\t\t    else begin\n\t\t\t\t        ClkCounter = (Speed == 0) ? `LO_SPEED_TICKS_UP : `HI_SPEED_TICKS_UP;\n\t\t\t\t\t\t  SCLK = 1;\n\t\t\t\t\t\t  ClkStatus = 1;\n  \t\t\t\t\t     if (SCE == 0) \n\t\t\t\t\t\t    begin\n\t\t\t\t\t\t\t   ShiftReg[0] = MISO;\n\t\t\t\t\t\t\t\tif (Counter == 0)\n\t\t\t\t\t\t\t\t  begin\n\t\t\t\t\t\t\t\t    RecvData = ShiftReg;\n\t\t\t\t\t\t\t\t\t RecvAdv = 1;\n\t\t\t\t\t\t\t\t  end\n\t\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\t     end\n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t  else begin\n\t\t\t\t\t\t       end\n\t\t\t\t      end\n\t\t     end\n\t\tendcase\n\t end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_divider_c16cb311", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_divider(input clk, input rst, output reg clk_out);\n\n\t//Lleva la cuenta de los ciclos de reloj transcurridos\n   reg [25:0] counter;\n\t\t\n\tinitial \n\t\tbegin\n\t\t\tcounter <= 26'd0;\n\t\t\tclk_out <= 1'b1;\n\t\tend\n\t\t\t\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tbegin\n\t\t\t\tcounter <= 26'd0;\n\t\t\t\tclk_out <= 1'b1; //reset output clock to 1\n\t\t\tend\t\n\t\telse\n\t\t\tif(counter == 26'd25000000) //convert 50 MHz to 1 Hz\n\t\t\t\tbegin\n\t\t\t\t\tcounter <= 26'd0;\n\t\t\t\t\tclk_out <= ~clk_out; //toggle output clock\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tcounter <= counter+1;\n\t\t\t\tend\n\tend\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "k580wi53_114ad77c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule k580wi53(input clk,\n\tinput c0, input c1, input c2,\n\tinput g0, input g1, input g2,\n\toutput out0, output out1, output out2,\n\tinput[1:0] addr, input rd, input we_n, input[7:0] idata, output reg[7:0] odata);\n\nwire[7:0] odata0;\nwire[7:0] odata1;\nwire[7:0] odata2;\n\nalways @(*)\n\tcase (addr)\n\t2'b00: odata = odata0;\n\t2'b01: odata = odata1;\n\t2'b10: odata = odata2;\n\t2'b11: odata = 0;\n\tendcase\n\nk580wi53channel ch0(.clk(clk), .c(c0), .gate(g0), .cout(out0), .addr(&addr), .rd(rd && addr==2'b00), .we_n(we_n || (addr!=2'b00 && (addr!=2'b11 || idata[7:6]!=2'b00))), .idata(idata), .odata(odata0));\nk580wi53channel ch1(.clk(clk), .c(c1), .gate(g1), .cout(out1), .addr(&addr), .rd(rd && addr==2'b01), .we_n(we_n || (addr!=2'b01 && (addr!=2'b11 || idata[7:6]!=2'b01))), .idata(idata), .odata(odata1));\nk580wi53channel ch2(.clk(clk), .c(c2), .gate(g2), .cout(out2), .addr(&addr), .rd(rd && addr==2'b10), .we_n(we_n || (addr!=2'b10 && (addr!=2'b11 || idata[7:6]!=2'b10))), .idata(idata), .odata(odata2));\n\nendmodule\n\nmodule k580wi53channel(input clk, input c, input gate, output reg cout,\n\tinput addr, input rd, input we_n, input[7:0] idata, output reg[7:0] odata);\n\nreg[5:0]  mode;\nreg[15:0] init;\nreg[15:0] cntlatch;\nreg[15:0] counter;\nreg[15:0] sub1;\nreg[15:0] sub2;\nreg enabled;\nreg latched;\nreg loaded;\nreg ff;\nreg first;\nreg done;\nreg exc;\nreg exgate;\nreg exrd;\nreg exwe_n;\n\nalways @(*)\n\tcase ({latched,ff})\n\t2'b00: odata = counter[7:0];\n\t2'b01: odata = counter[15:8];\n\t2'b10: odata = cntlatch[7:0];\n\t2'b11: odata = cntlatch[15:8];\n\tendcase\n\nalways @(*)\n\tcasex ({mode[0],|counter[15:12],|counter[11:8],|counter[7:4],|counter[3:0]})\n\t5'b10000: sub1 = 16'h9999;\n\t5'b11000: sub1 = 16'hF999;\n\t5'b1x100: sub1 = 16'hFF99;\n\t5'b1xx10: sub1 = 16'hFFF9;\n\tdefault:  sub1 = 16'hFFFF;\n\tendcase\n\nalways @(*)\n\tcasex ({mode[0],|counter[15:12],|counter[11:8],|counter[7:4],|counter[3:1]})\n\t5'b10000: sub2 = 16'h9998;\n\t5'b11000: sub2 = 16'hF998;\n\t5'b1x100: sub2 = 16'hFF98;\n\t5'b1xx10: sub2 = 16'hFFF8;\n\tdefault:  sub2 = 16'hFFFE;\n\tendcase\n\nwire[15:0] new1 = counter + (first|~&mode[2:1]?sub1:sub2);\nwire[15:0] newvalue = {new1[15:1],new1[0]&~&mode[2:1]};\n\nalways @(posedge clk)\nbegin\n\texc <= c; exgate <= gate; exrd <= rd; exwe_n <= we_n;\n\tif (enabled & c & ~exc) begin\n\t\tif (loaded) begin\n\t\t\tif (mode[2]==1'b1 && newvalue==0) begin\n\t\t\t\tcounter <= init;\n\t\t\t\tfirst <= init[0]&~cout;\n\t\t\tend else begin\n\t\t\t\tcounter <= newvalue;\n\t\t\t\tfirst <= 0;\n\t\t\tend\n\t\t\tif (newvalue[15:1]==0 && ~done) begin\n\t\t\t\tcasex ({mode[3:1],newvalue[0]})\n\t\t\t\t4'b0000: {cout,done} <= 2'b11;\n\t\t\t\t4'b0010: {cout,done} <= 2'b11;\n\t\t\t\t4'bx100: cout <= 1'b1;\n\t\t\t\t4'bx101: cout <= 0;\n\t\t\t\t4'bx11x: cout <= ~cout;\n\t\t\t\t4'b1000: {cout,done} <= 2'b11;\n\t\t\t\t4'b1001: cout <= 0;\n\t\t\t\t4'b1010: {cout,done} <= 2'b11;\n\t\t\t\t4'b1011: cout <= 0;\n\t\t\t\tendcase\n\t\t\tend\n\t\tend else begin\n\t\t\tcounter <= init; loaded <= 1'b1; first <= 1'b1; done <= 0;\n\t\t\tif (mode[3:2]==0) cout <= 0;\n\t\tend\n\tend\n\tif (exgate ^ gate) begin\n\t\tif (mode[2:1]!=2'b01) enabled <= gate;\n\t\telse if (gate) begin loaded <= 0; enabled <= 1; end\n\tend\n\tif (exrd & ~rd) begin\n\t\tif (mode[5:4]==2'b11) ff <= ~ff;\n\t\tif (mode[5:4]!=2'b11 || ff) latched <= 0;\n\tend else\n\tif (exwe_n & ~we_n) begin\n\t\tif (addr) begin\n\t\t\tif (idata[5:4]==0) begin\n\t\t\t\tcntlatch <= counter; latched <= 1;\n\t\t\tend else begin\n\t\t\t\tmode <= idata[5:0]; enabled <= 0; loaded <= 0; done <= 1'b1;\n\t\t\t\tlatched <= 0; cout <= idata[3:1]!=0;\n\t\t\tend\n\t\t\tff <= idata[5:4]==2'b10;\n\t\tend else begin\n\t\t\tcasex ({mode[5:4],ff})\n\t\t\t3'b01x: begin init <= {8'h00,idata}; enabled <= gate; ff <= 0; end\n\t\t\t3'b10x: begin init <= {idata,8'h00}; enabled <= gate; ff <= 1; end\n\t\t\t3'b110: begin init[7:0] <= idata; enabled <= 0; ff <= 1; end\n\t\t\t3'b111: begin init[15:8] <= idata; enabled <= gate; ff <= 0; end\n\t\t\tendcase\n\t\t\tloaded <= mode[2:1]!=0 & ~done;\n\t\t\tcout <= mode[3:1]!=0||(mode[5:4]==2'b01&&idata==8'b1);\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_8bit_cb32c49b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_8bit (\n  input [7:0] A,\n  input [7:0] B,\n  output reg [7:0] C\n);\n\n  always @(*) begin\n    C[0] = A[0] ^ B[0];\n    C[1] = A[1] ^ B[1];\n    C[2] = A[2] ^ B[2];\n    C[3] = A[3] ^ B[3];\n    C[4] = A[4] ^ B[4];\n    C[5] = A[5] ^ B[5];\n    C[6] = A[6] ^ B[6];\n    C[7] = A[7] ^ B[7];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_d_ff_en_W32_0_6_f7be7a94", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate_d_ff_en_W32_0_6 (\n  input CLK, \n  input EN, \n  input TE, \n  input [31:0] DATA, \n  output reg ENCLK\n);\n\n  reg D;\n  always @(posedge CLK) begin\n    if (EN & !TE) begin\n      D <= DATA;\n    end\n  end\n\n  always @(posedge CLK) begin\n    if (TE) begin\n      ENCLK <= 0;\n    end else if (EN) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= 0;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alu_d5e921e2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule alu (A, B, BI, X, CO);\n  parameter A_SIGNED = 0;\n  parameter B_SIGNED = 0;\n  parameter A_WIDTH  = 1;\n  parameter B_WIDTH  = 1;\n  parameter Y_WIDTH  = 1;\n\n  input [A_WIDTH-1:0] A;\n  input [B_WIDTH-1:0] B;\n  input BI;\n  output [Y_WIDTH-1:0] X, CO;\n\n  wire [Y_WIDTH-1:0] sum = A + B;\n  wire [Y_WIDTH-1:0] diff = A - B;\n\n  assign X = BI ? diff : sum;\n\n  // Carry-out for addition\n  wire [Y_WIDTH:0] add_carry = {1'b0, sum};\n  assign CO = add_carry[Y_WIDTH];\n\n  // Borrow-out for subtraction\n  wire [Y_WIDTH:0] sub_borrow = {1'b0, diff};\n  assign CO = BI ? sub_borrow[Y_WIDTH] : CO;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_4bit_sat_73855c6f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_4bit_sat (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Y\n);\n    \n    always @ (A or B) begin\n        Y = A + B;\n        if(Y > 4'b1111) begin\n            Y = 4'b1111;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_divider_sim #_d0717966", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clock_divider_sim #(\n    parameter DIVISOR = 2\n) (\n    input wire CLK,\n    output reg CLOCK\n);\n\ninteger cnt;\ninitial cnt = 0;\n\nwire [31:0] DIV;\nassign DIV = DIVISOR;\n\nalways @(posedge CLK)\n    if(cnt == DIVISOR -1)\n        cnt <= 0;\n    else\n        cnt <= cnt + 1;\n\ninitial CLOCK = 0;\n\nalways @(posedge CLK) begin\n    if (DIVISOR % 2 == 0) begin\n        if(cnt == DIVISOR/2-1) // posedge\n            CLOCK <= ~CLOCK;\n    end else begin\n        if(cnt == DIVISOR/2 && DIV[0] == 1) // posedge\n            CLOCK <= ~CLOCK;\n    end\n\n    if(cnt == DIVISOR-1) // posedge\n        CLOCK <= ~CLOCK;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RAM_DUAL_READ_PORT #_51e7b998", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule RAM_DUAL_READ_PORT # ( parameter DATA_WIDTH= 16, parameter ADDR_WIDTH=8, parameter MEM_SIZE=8 )\n(\n\tinput wire\t\t\t\t\t\tClock,\n\tinput wire\t\t\t\t\t\tiWriteEnable,\n\tinput wire[ADDR_WIDTH-1:0]\tiReadAddress0,\n\tinput wire[ADDR_WIDTH-1:0]\tiReadAddress1,\n\tinput wire[ADDR_WIDTH-1:0]\tiWriteAddress,\n\tinput wire[DATA_WIDTH-1:0]\t\t \tiDataIn,\n\toutput reg [DATA_WIDTH-1:0] \t\toDataOut0,\n\toutput reg [DATA_WIDTH-1:0] \t\toDataOut1\n);\n\nreg [DATA_WIDTH-1:0] Ram [MEM_SIZE:0];\t\t\n\nalways @(posedge Clock) \nbegin \n\t\n\t\tif (iWriteEnable) \n\t\t\tRam[iWriteAddress] <= iDataIn; \n\t\t\t\n\t\n\t\t\toDataOut0 <= Ram[iReadAddress0]; \n\t\t\toDataOut1 <= Ram[iReadAddress1]; \n\t\t\nend \nendmodule\n\nmodule RAM_SINGLE_READ_PORT # ( parameter DATA_WIDTH= 16, parameter ADDR_WIDTH=8, parameter MEM_SIZE=8 )\n(\n\tinput wire\t\t\t\t\t\tClock,\n\tinput wire\t\t\t\t\t\tiWriteEnable,\n\tinput wire[ADDR_WIDTH-1:0]\tiReadAddress,\n\tinput wire[ADDR_WIDTH-1:0]\tiWriteAddress,\n\tinput wire[DATA_WIDTH-1:0]\t\t \tiDataIn,\n\toutput reg [DATA_WIDTH-1:0] \t\toDataOut\n);\n\nreg [DATA_WIDTH-1:0] Ram [MEM_SIZE:0];\t\t\n\nalways @(posedge Clock) \nbegin \n\t\n\t\tif (iWriteEnable) \n\t\t\tRam[iWriteAddress] <= iDataIn; \n\t\t\t\n\t\n\t\t\toDataOut <= Ram[iReadAddress];\n\t\t\nend \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "serial_tx #_f347dfeb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule serial_tx #(\n        parameter CLK_PER_BIT = 50\n    )(\n        input clk,\n        input rst,\n        output tx,\n        input block,\n        output busy,\n        input [7:0] data,\n        input new_data\n    );\n\n    parameter CTR_SIZE = $clog2(CLK_PER_BIT);\n\n    localparam STATE_SIZE = 2;\n    localparam IDLE = 2'd0,\n    START_BIT = 2'd1,\n    DATA = 2'd2,\n    STOP_BIT = 2'd3;\n\n    reg [CTR_SIZE-1:0] ctr_d, ctr_q;\n    reg [2:0] bit_ctr_d, bit_ctr_q;\n    reg [7:0] data_d, data_q;\n    reg [STATE_SIZE-1:0] state_d, state_q = IDLE;\n    reg tx_d, tx_q;\n    reg busy_d, busy_q;\n    reg block_d, block_q;\n\n    assign tx = tx_q;\n    assign busy = busy_q;\n\n    always @(*) begin\n        block_d = block;\n        ctr_d = ctr_q;\n        bit_ctr_d = bit_ctr_q;\n        data_d = data_q;\n        state_d = state_q;\n        busy_d = busy_q;\n\n        case (state_q)\n            IDLE: begin\n                if (block_q) begin\n                    busy_d = 1'b1;\n                    tx_d = 1'b1;\n                end else begin\n                    busy_d = 1'b0;\n                    tx_d = 1'b1;\n                    bit_ctr_d = 3'b0;\n                    ctr_d = 1'b0;\n                    if (new_data) begin\n                        data_d = data;\n                        state_d = START_BIT;\n                        busy_d = 1'b1;\n                    end\n                end\n            end\n            START_BIT: begin\n                busy_d = 1'b1;\n                ctr_d = ctr_q + 1'b1;\n                tx_d = 1'b0;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    ctr_d = 1'b0;\n                    state_d = DATA;\n                end\n            end\n            DATA: begin\n                busy_d = 1'b1;\n                tx_d = data_q[bit_ctr_q];\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    ctr_d = 1'b0;\n                    bit_ctr_d = bit_ctr_q + 1'b1;\n                    if (bit_ctr_q == 7) begin\n                        state_d = STOP_BIT;\n                    end\n                end\n            end\n            STOP_BIT: begin\n                busy_d = 1'b1;\n                tx_d = 1'b1;\n                ctr_d = ctr_q + 1'b1;\n                if (ctr_q == CLK_PER_BIT - 1) begin\n                    state_d = IDLE;\n                end\n            end\n            default: begin\n                state_d = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state_q <= IDLE;\n            tx_q <= 1'b1;\n        end else begin\n            state_q <= state_d;\n            tx_q <= tx_d;\n        end\n\n        block_q <= block_d;\n        data_q <= data_d;\n        bit_ctr_q <= bit_ctr_d;\n        ctr_q <= ctr_d;\n        busy_q <= busy_d;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "divide_by12_2d8a779b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule divide_by12(\n  input [5:0] numer,\n  output [2:0] quotient,\n  output [3:0] remain\n);\n\n  reg [2:0] quotient;\n  reg [3:0] remain_bit3_bit2;\n\n  assign remain = {remain_bit3_bit2, numer[1:0]}; // the first 2 bits are copied through\n\n  always @(numer[5:2]) // and just do a divide by \"3\" on the remaining bits\n    case(numer[5:2])\n      0: begin quotient=0; remain_bit3_bit2=0; end\n      1: begin quotient=0; remain_bit3_bit2=1; end\n      2: begin quotient=0; remain_bit3_bit2=2; end\n      3: begin quotient=1; remain_bit3_bit2=0; end\n      4: begin quotient=1; remain_bit3_bit2=1; end\n      5: begin quotient=1; remain_bit3_bit2=2; end\n      6: begin quotient=2; remain_bit3_bit2=0; end\n      7: begin quotient=2; remain_bit3_bit2=1; end\n      8: begin quotient=2; remain_bit3_bit2=2; end\n      9: begin quotient=3; remain_bit3_bit2=0; end\n      10: begin quotient=3; remain_bit3_bit2=1; end\n      11: begin quotient=3; remain_bit3_bit2=2; end\n      12: begin quotient=4; remain_bit3_bit2=0; end\n      13: begin quotient=4; remain_bit3_bit2=1; end\n      14: begin quotient=4; remain_bit3_bit2=2; end\n      15: begin quotient=5; remain_bit3_bit2=0; end\n    endcase\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "TwosComplement_46a1f2e9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule TwosComplement(input_num, twos_comp);\n\n   input [3:0] input_num;\n   output [3:0] twos_comp;\n\n   assign twos_comp = ~input_num + 1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tmu2_fifo64to256 #_945859c3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule tmu2_fifo64to256 #(\n\tparameter depth = 2 \n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\toutput w8avail,\n\tinput we,\n\tinput [63:0] wd,\n\t\n\toutput ravail,\n\tinput re,\n\toutput [255:0] rd\n);\n\nreg [63:0] storage1[0:(1 << depth)-1];\nreg [63:0] storage2[0:(1 << depth)-1];\nreg [63:0] storage3[0:(1 << depth)-1];\nreg [63:0] storage4[0:(1 << depth)-1];\n\nreg [depth+2:0] level;\nreg [depth+1:0] produce;\nreg [depth-1:0] consume;\n\nwire wavail = ~level[depth+2];\nassign w8avail = level < ((1 << (depth + 2)) - 8);\nassign ravail = |(level[depth+2:2]);\n\nwire read = re & ravail;\nwire write = we & wavail;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tlevel <= 0;\n\t\tproduce <= 0;\n\t\tconsume <= 0;\n\tend else begin\n\t\tif(read)\n\t\t\tconsume <= consume + 1;\n\t\tif(write) begin\n\t\t\tproduce <= produce + 1;\n\t\t\tcase(produce[1:0])\n\t\t\t\t2'd0: storage1[produce[depth+1:2]] <= wd;\n\t\t\t\t2'd1: storage2[produce[depth+1:2]] <= wd;\n\t\t\t\t2'd2: storage3[produce[depth+1:2]] <= wd;\n\t\t\t\t2'd3: storage4[produce[depth+1:2]] <= wd;\n\t\t\tendcase\n\t\tend\n\t\tcase({read, write})\n\t\t\t2'b10: level <= level - 4;\n\t\t\t2'b01: level <= level + 1;\n\t\t\t2'b11: level <= level - 3;\n\t\tendcase\n\tend\nend\n\nassign rd = {storage1[consume], storage2[consume], storage3[consume], storage4[consume]};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_dc69b239", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input clk,\n    input rst,\n    input en,\n    input ld,\n    input [3:0] load_data,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'b0000;\n        end else if (en) begin\n            if (ld) begin\n                count <= load_data;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_counter_936ef2c2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule johnson_counter (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-low reset\n    output reg [3:0] out    // 4-bit output\n);\n\nreg [2:0] state = 3'b000;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b000;\n    end else begin\n        case (state)\n            3'b000: state <= 3'b100;\n            3'b100: state <= 3'b110;\n            3'b110: state <= 3'b111;\n            3'b111: state <= 3'b011;\n            3'b011: state <= 3'b001;\n            3'b001: state <= 3'b000;\n            default: state <= 3'b000;\n        endcase\n    end\n    out <= {state[2], state[1], state[0], out[3]};\nend\n\nendmodule\nmodule half_word_comb (\n    input [7:0] in_hi,      // Upper byte input\n    input [7:0] in_lo,      // Lower byte input\n    output reg [15:0] out   // 16-bit output\n);\n\nalways @(*) begin\n    out = {in_hi, in_lo};\nend\n\nendmodule\nmodule top_module (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-low reset\n    input [7:0] in_hi,      // Upper byte input\n    input [7:0] in_lo,      // Lower byte input\n    output reg [79:0] out   // 80-bit output\n);\n\nwire [3:0] johnson_out;\nwire [15:0] half_word_out;\n\njohnson_counter jc (\n    .clk(clk),\n    .reset(reset),\n    .out(johnson_out)\n);\n\nhalf_word_comb hw (\n    .in_hi(in_hi),\n    .in_lo(in_lo),\n    .out(half_word_out)\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 80'b0;\n    end else begin\n        out <= {half_word_out, johnson_out};\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__9a42c0a3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output signed [3:0] out,\n    output eq,\n    output gt,\n    output lt,\n    output overflow\n);\n\n    wire signed [3:0] sum;\n    wire overflow_adder;\n    signed_comparator comp(A, B, eq, gt, lt);\n    signed_adder adder(A, B, sum, overflow_adder);\n\n    assign overflow = overflow_adder;\n\n    assign out = (eq) ? sum : (gt) ? A : B;\n\nendmodule\n\nmodule signed_adder (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output signed [3:0] out,\n    output overflow\n);\n\n    wire [3:0] sum;\n    wire carry;\n\n    assign overflow = (A[3] == B[3] && sum[3] != A[3]) ? 1 : 0;\n\n    assign {carry, sum} = A + B;\n\n    assign out = {overflow, sum};\n\nendmodule\n\nmodule signed_comparator (\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output eq,\n    output gt,\n    output lt\n);\n\n    assign eq = (A == B);\n\n    assign gt = (A > B);\n\n    assign lt = (A < B);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_code_state_machine_1befa46b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule gray_code_state_machine (\n  input [n-1:0] state,\n  input clk,\n  output [n-1:0] next_state\n);\n\nparameter n = 3; // number of bits in the state\n\n// Define the Gray code states\nreg [n-1:0] gray_states [0:2**n-1];\ninteger i;\ninitial begin\n  for (i = 0; i < 2**n; i = i + 1) begin\n    gray_states[i] = i ^ (i >> 1);\n  end\nend\n\n// Define the Gray code state transition table\nreg [n-1:0] gray_transition_table [0:2**n-1][0:1];\ninitial begin\n  gray_transition_table[0][0] = 'h1;\n  gray_transition_table[0][1] = 'h2;\n  gray_transition_table[1][0] = 'h3;\n  gray_transition_table[1][1] = 'h0;\n  gray_transition_table[2][0] = 'h6;\n  gray_transition_table[2][1] = 'h7;\n  gray_transition_table[3][0] = 'h5;\n  gray_transition_table[3][1] = 'h4;\n  gray_transition_table[4][0] = 'h4;\n  gray_transition_table[4][1] = 'h5;\n  gray_transition_table[5][0] = 'h7;\n  gray_transition_table[5][1] = 'h6;\n  gray_transition_table[6][0] = 'h2;\n  gray_transition_table[6][1] = 'h1;\n  gray_transition_table[7][0] = 'h0;\n  gray_transition_table[7][1] = 'h3;\nend\n\n// Compute the next state based on the current state and the clock signal\nreg [n-1:0] next_state_reg;\nalways @(posedge clk) begin\n  next_state_reg <= gray_transition_table[state][1];\nend\n\n// Assign the output to the next state register\nassign next_state = next_state_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "line_reader #_8a177b38", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule line_reader #\n(\n\tparameter integer C_IMG_WBITS\t= 12,\n\tparameter integer C_WRITE_INDEX_BITS = 10,\n\n\tparameter integer C_M_AXI_BURST_LEN\t= 16,\n\tparameter integer C_M_AXI_ADDR_WIDTH\t= 32,\n\tparameter integer C_M_AXI_DATA_WIDTH\t= 32\n)\n(\n\tinput wire [C_IMG_WBITS-1:0] img_width,\n\n\tinput wire sol,\n\tinput wire [C_M_AXI_ADDR_WIDTH-1 : 0] line_addr,\n\n\toutput wire end_of_line_pulse,\n\toutput wire [C_M_AXI_DATA_WIDTH-1 : 0] wr_data,\n\toutput wire [C_WRITE_INDEX_BITS-1 : 0] wr_addr,\n\toutput wire wr_en,\n\n\tinput wire  M_AXI_ACLK,\n\tinput wire  M_AXI_ARESETN,\n\n\toutput wire [C_M_AXI_ADDR_WIDTH-1 : 0] M_AXI_ARADDR,\n\toutput wire [7 : 0] M_AXI_ARLEN,\n\toutput wire [2 : 0] M_AXI_ARSIZE,\n\toutput wire [1 : 0] M_AXI_ARBURST,\n\toutput wire  M_AXI_ARLOCK,\n\toutput wire [3 : 0] M_AXI_ARCACHE,\n\toutput wire [2 : 0] M_AXI_ARPROT,\n\toutput wire [3 : 0] M_AXI_ARQOS,\n\toutput wire  M_AXI_ARVALID,\n\tinput wire  M_AXI_ARREADY,\n\n\tinput wire [C_M_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA,\n\tinput wire [1 : 0] M_AXI_RRESP,\n\tinput wire  M_AXI_RLAST,\n\tinput wire  M_AXI_RVALID,\n\toutput wire  M_AXI_RREADY\n);\n\n\tfunction integer clogb2 (input integer bit_depth);\n\tbegin\n\t\tfor(clogb2=0; bit_depth>0; clogb2=clogb2+1)\n\t\t\tbit_depth = bit_depth >> 1;\n\tend\n\tendfunction\n\n\tlocalparam integer C_ADATA_PIXELS = 2**(C_IMG_WBITS - C_WRITE_INDEX_BITS);\n\tlocalparam integer C_TRANSACTIONS_NUM = clogb2(C_M_AXI_BURST_LEN-1);\n\tlocalparam integer C_BURST_SIZE_BYTES\t= C_M_AXI_BURST_LEN * C_M_AXI_DATA_WIDTH/8;\n\n\treg [C_M_AXI_ADDR_WIDTH-1 : 0] \taxi_araddr;\n\treg  \taxi_arvalid;\n\treg  \tstart_burst_pulse;\n\treg  \tburst_read_active;\n\treg [C_TRANSACTIONS_NUM-1:0] next_burst_len;\n\twire\tburst_done;\n\twire  \tread_resp_error;\n\twire  \trnext;\n\n\treg\tsol_d1;\n\treg\tlining;\n\treg\tr_eol;\n\treg [C_IMG_WBITS-1 : 0] r_img_col_idx;\n\treg [C_WRITE_INDEX_BITS-1 : 0] r_wr_addr;\n\n\tassign wr_data\t\t= M_AXI_RDATA;\n\tassign rnext \t\t= M_AXI_RVALID && M_AXI_RREADY;\n\tassign wr_en\t\t= rnext;\n\tassign wr_addr\t\t= r_wr_addr;\n\n\tassign M_AXI_ARADDR\t= axi_araddr;\n\tassign M_AXI_ARLEN\t= next_burst_len;\n\tassign M_AXI_ARSIZE\t= clogb2((C_M_AXI_DATA_WIDTH/8)-1);\n\tassign M_AXI_ARBURST\t= 2'b01;\n\tassign M_AXI_ARLOCK\t= 1'b0;\n\tassign M_AXI_ARCACHE\t= 4'b0000;\n\tassign M_AXI_ARPROT\t= 3'h0;\n\tassign M_AXI_ARQOS\t= 4'h0;\n\tassign M_AXI_ARVALID\t= axi_arvalid;\n\tassign M_AXI_RREADY\t= burst_read_active;\n\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\taxi_arvalid <= 1'b0;\n\t\tend\n\t\telse if (start_burst_pulse) begin\n\t\t\taxi_arvalid <= 1'b1;\n\t\tend\n\t\telse if (M_AXI_ARREADY) begin\n\t\t\taxi_arvalid <= 1'b0;\n\t\tend\n\tend\n\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\taxi_araddr <= 'b0;\n\t\tend\n\t\telse if (sol) begin\n\t\t\taxi_araddr <= line_addr;\n\t\tend\n\t\telse if (burst_done) begin\n\t\t\taxi_araddr <= axi_araddr + C_BURST_SIZE_BYTES;\n\t\tend\n\tend\n\n\n\tassign read_resp_error = M_AXI_RREADY & M_AXI_RVALID & M_AXI_RRESP[1];\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 1'b0)\n\t\t\tstart_burst_pulse <= 1'b0;\n\t\telse if (start_burst_pulse)\n\t\t\tstart_burst_pulse <= 0;\n\t\telse if (lining && ~burst_read_active)\n\t\t\tstart_burst_pulse <= 1'b1;\n\tend\n\n\tassign burst_done = (rnext && M_AXI_RLAST);\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0)\n\t\t\tburst_read_active <= 1'b0;\n\t\telse if (start_burst_pulse)\n\t\t\tburst_read_active <= 1'b1;\n\t\telse if (burst_done)\n\t\t\tburst_read_active <= 0;\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 1'b0) begin\n\t\t\tnext_burst_len <= 0;\n\t\tend\n\t\telse if (sol_d1 || burst_done) begin\n\t\t\tif (r_img_col_idx >= C_M_AXI_BURST_LEN * C_ADATA_PIXELS)\n\t\t\t\tnext_burst_len <= C_M_AXI_BURST_LEN - 1;\n\t\t\telse\n\t\t\t\tnext_burst_len <= r_img_col_idx / C_ADATA_PIXELS - 1;\n\t\tend\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tr_img_col_idx <= 0;\n\t\tend\n\t\telse if (sol) begin\n\t\t\tr_img_col_idx <= img_width - C_ADATA_PIXELS;\n\t\tend\n\t\telse if (rnext) begin\n\t\t\tif (!r_eol) begin\n\t\t\t\tr_img_col_idx <= r_img_col_idx - C_ADATA_PIXELS;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tr_wr_addr <= 0;\n\t\tend\n\t\telse if (sol) begin\n\t\t\tr_wr_addr <= 0;\n\t\tend\n\t\telse if (rnext) begin\n\t\t\tr_wr_addr <= r_wr_addr + 1;\n\t\tend\n\tend\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tsol_d1 <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tsol_d1 <= sol;\n\t\tend\n\tend\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tlining <= 0;\n\t\tend\n\t\telse if (sol_d1) begin\n\t\t\tlining <= 1;\n\t\tend\n\t\telse if (burst_done && r_eol) begin\n\t\t\tlining <= 0;\n\t\tend\n\tend\n\treg lining_d1;\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0)\n\t\t\tlining_d1 <= 0;\n\t\telse\n\t\t\tlining_d1 <= lining;\n\tend\n\tassign end_of_line_pulse = (lining_d1 && ~lining);\n\n\talways @(posedge M_AXI_ACLK) begin\n\t\tif (M_AXI_ARESETN == 0) begin\n\t\t\tr_eol <= 1'b1;\n\t\tend\n\t\telse if (sol) begin\n\t\t\tr_eol <= 1'b0;\n\t\tend\n\t\telse if (rnext) begin\n\t\t\tif (r_img_col_idx == C_ADATA_PIXELS) begin\n\t\t\t\tr_eol <= 1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_reset #_b37e8213", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sync_reset #\n(\n    parameter N = 2\n)\n(\n    input  wire clk,\n    input  wire rst,\n    output wire out\n);\n\n\nreg [N-1:0] sync_reg = {N{1'b1}};\n\nassign out = sync_reg[N-1];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sync_reg <= {N{1'b1}};\n    end else begin\n        sync_reg <= {sync_reg[N-2:0], 1'b0};\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_62a7dd75", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    input A,\n    input B,\n    input SEL,\n    output Y,\n    input VPWR,\n    input VGND\n);\n\n    wire not_sel;\n    wire and1_out;\n    wire and2_out;\n\n    sky130_fd_sc_lp__not_1 not_gate_inst(\n        .A(SEL),\n        .X(not_sel),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\n    sky130_fd_sc_lp__and2_1 and1_gate_inst(\n        .A(A),\n        .B(not_sel),\n        .X(and1_out),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\n    sky130_fd_sc_lp__and2_1 and2_gate_inst(\n        .A(B),\n        .B(SEL),\n        .X(and2_out),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\n    assign Y = and1_out | and2_out;\n\nendmodule\n\nmodule sky130_fd_sc_lp__not_1 (\n    input A,\n    output X,\n    input VPWR,\n    input VGND\n);\n\n    assign X = ~A;\n\nendmodule\n\nmodule sky130_fd_sc_lp__and2_1 (\n    input A,\n    input B,\n    output X,\n    input VPWR,\n    input VGND\n);\n\n    assign X = A & B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__xor3_df9eac30", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ms__xor3 (\n  input A,\n  input B,\n  input C,\n  output X\n);\n\n  wire wire1;\n  wire wire2;\n  \n  assign wire1 = A ^ B;\n  assign wire2 = wire1 ^ C;\n  assign X = ~wire2;\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "feedforward_p_uOut_ram_1f5c6b58", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule feedforward_p_uOut_ram (addr0, ce0, d0, we0, q0, addr1, ce1, q1,  clk);\n\nparameter DWIDTH = 64;\nparameter AWIDTH = 8;\nparameter MEM_SIZE = 140;\n\ninput[AWIDTH-1:0] addr0;\ninput ce0;\ninput[DWIDTH-1:0] d0;\ninput we0;\noutput reg[DWIDTH-1:0] q0;\ninput[AWIDTH-1:0] addr1;\ninput ce1;\noutput reg[DWIDTH-1:0] q1;\ninput clk;\n\nreg [DWIDTH-1:0] ram[MEM_SIZE-1:0];\n\n\n\n\nalways @(posedge clk)  \nbegin \n    if (ce0) \n    begin\n        if (we0) \n        begin \n            ram[addr0] <= d0; \n            q0 <= d0;\n        end \n        else \n            q0 <= ram[addr0];\n    end\nend\n\n\nalways @(posedge clk)  \nbegin \n    if (ce1) \n    begin\n            q1 <= ram[addr1];\n    end\nend\n\n\nendmodule\n\nmodule feedforward_p_uOut(\n    reset,\n    clk,\n    address0,\n    ce0,\n    we0,\n    d0,\n    q0,\n    address1,\n    ce1,\n    q1);\n\nparameter DataWidth = 32'd64;\nparameter AddressRange = 32'd140;\nparameter AddressWidth = 32'd8;\ninput reset;\ninput clk;\ninput[AddressWidth - 1:0] address0;\ninput ce0;\ninput we0;\ninput[DataWidth - 1:0] d0;\noutput[DataWidth - 1:0] q0;\ninput[AddressWidth - 1:0] address1;\ninput ce1;\noutput[DataWidth - 1:0] q1;\n\n\n\nfeedforward_p_uOut_ram feedforward_p_uOut_ram_U(\n    .clk( clk ),\n    .addr0( address0 ),\n    .ce0( ce0 ),\n    .d0( d0 ),\n    .we0( we0 ),\n    .q0( q0 ),\n    .addr1( address1 ),\n    .ce1( ce1 ),\n    .q1( q1 ));\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_rx_req #_af6329cc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule pcie_rx_req # (\n\tparameter\tP_PCIE_DATA_WIDTH\t\t\t= 128,\n\tparameter\tC_PCIE_ADDR_WIDTH\t\t\t= 36\n)\n(\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\n\tinput\t[2:0]\t\t\t\t\t\t\tpcie_max_read_req_size,\n\n\toutput\t\t\t\t\t\t\t\t\tpcie_rx_cmd_rd_en,\n\tinput\t[33:0]\t\t\t\t\t\t\tpcie_rx_cmd_rd_data,\n\tinput\t\t\t\t\t\t\t\t\tpcie_rx_cmd_empty_n,\n\n\toutput\t\t\t\t\t\t\t\t\tpcie_tag_alloc,\n\toutput\t[7:0]\t\t\t\t\t\t\tpcie_alloc_tag,\n\toutput\t[9:4]\t\t\t\t\t\t\tpcie_tag_alloc_len,\n\tinput\t\t\t\t\t\t\t\t\tpcie_tag_full_n,\n\tinput\t\t\t\t\t\t\t\t\tpcie_rx_fifo_full_n,\n\n\toutput\t\t\t\t\t\t\t\t\ttx_dma_mrd_req,\n\toutput\t[7:0]\t\t\t\t\t\t\ttx_dma_mrd_tag,\n\toutput\t[11:2]\t\t\t\t\t\t\ttx_dma_mrd_len,\n\toutput\t[C_PCIE_ADDR_WIDTH-1:2]\t\t\ttx_dma_mrd_addr,\n\tinput\t\t\t\t\t\t\t\t\ttx_dma_mrd_req_ack\n);\n\nlocalparam\tLP_PCIE_TAG_PREFIX\t\t\t\t= 4'b0001;\nlocalparam\tLP_PCIE_MRD_DELAY\t\t\t\t= 8;\n\nlocalparam\tS_IDLE\t\t\t\t\t\t\t= 9'b000000001;\nlocalparam\tS_PCIE_RX_CMD_0\t\t\t\t\t= 9'b000000010;\nlocalparam\tS_PCIE_RX_CMD_1\t\t\t\t\t= 9'b000000100;\nlocalparam\tS_PCIE_CHK_NUM_MRD\t\t\t\t= 9'b000001000;\nlocalparam\tS_PCIE_MRD_REQ\t\t\t\t\t= 9'b000010000;\nlocalparam\tS_PCIE_MRD_ACK\t\t\t\t\t= 9'b000100000;\nlocalparam\tS_PCIE_MRD_DONE\t\t\t\t\t= 9'b001000000;\nlocalparam\tS_PCIE_MRD_DELAY\t\t\t\t= 9'b010000000;\nlocalparam\tS_PCIE_MRD_NEXT\t\t\t\t\t= 9'b100000000;\n\n\nreg\t\t[8:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[8:0]\t\t\t\t\t\t\t\tnext_state;\n\nreg\t\t[2:0]\t\t\t\t\t\t\t\tr_pcie_max_read_req_size;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_rx_cmd_rd_en;\n\nreg\t\t[12:2]\t\t\t\t\t\t\t\tr_pcie_rx_len;\nreg\t\t[9:2]\t\t\t\t\t\t\t\tr_pcie_rx_cur_len;\nreg\t\t[C_PCIE_ADDR_WIDTH-1:2]\t\t\t\tr_pcie_addr;\nreg\t\t[3:0]\t\t\t\t\t\t\t\tr_pcie_rx_tag;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_rx_tag_update;\nreg\t\t[5:0]\t\t\t\t\t\t\t\tr_pcie_mrd_delay;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_tag_alloc;\nreg\t\t\t\t\t\t\t\t\t\t\tr_tx_dma_mrd_req;\n\nassign pcie_rx_cmd_rd_en = r_pcie_rx_cmd_rd_en;\n\nassign pcie_tag_alloc = r_pcie_tag_alloc;\nassign pcie_alloc_tag = {LP_PCIE_TAG_PREFIX, r_pcie_rx_tag};\nassign pcie_tag_alloc_len = r_pcie_rx_cur_len[9:4];\n\nassign tx_dma_mrd_req = r_tx_dma_mrd_req;\nassign tx_dma_mrd_tag = {LP_PCIE_TAG_PREFIX, r_pcie_rx_tag};\nassign tx_dma_mrd_len = {2'b0, r_pcie_rx_cur_len};\nassign tx_dma_mrd_addr = r_pcie_addr;\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0)\n\t\tcur_state <= S_IDLE;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tif(pcie_rx_cmd_empty_n == 1)\n\t\t\t\tnext_state <= S_PCIE_RX_CMD_0;\n\t\t\telse\n\t\t\t\tnext_state <= S_IDLE;\n\t\tend\n\t\tS_PCIE_RX_CMD_0: begin\n\t\t\tnext_state <= S_PCIE_RX_CMD_1;\n\t\tend\n\t\tS_PCIE_RX_CMD_1: begin\n\t\t\tnext_state <= S_PCIE_CHK_NUM_MRD;\n\t\tend\n\t\tS_PCIE_CHK_NUM_MRD: begin\n\t\t\tif(pcie_rx_fifo_full_n == 1 && pcie_tag_full_n == 1)\n\t\t\t\tnext_state <= S_PCIE_MRD_REQ;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_CHK_NUM_MRD;\n\t\tend\n\t\tS_PCIE_MRD_REQ: begin\n\t\t\tnext_state <= S_PCIE_MRD_ACK;\n\t\tend\n\t\tS_PCIE_MRD_ACK: begin\n\t\t\tif(tx_dma_mrd_req_ack == 1)\n\t\t\t\tnext_state <= S_PCIE_MRD_DONE;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_MRD_ACK;\n\t\tend\n\t\tS_PCIE_MRD_DONE: begin\n\t\t\tnext_state <= S_PCIE_MRD_DELAY;\n\t\tend\n\t\tS_PCIE_MRD_DELAY: begin\n\t\t\tif(r_pcie_mrd_delay == 0)\n\t\t\t\tnext_state <= S_PCIE_MRD_NEXT;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_MRD_DELAY;\n\t\tend\n\t\tS_PCIE_MRD_NEXT: begin\n\t\t\tif(r_pcie_rx_len == 0)\n\t\t\t\tnext_state <= S_IDLE;\n\t\t\telse\n\t\t\t\tnext_state <= S_PCIE_CHK_NUM_MRD;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_IDLE;\n\t\tend\n\tendcase\nend\n\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_pcie_rx_tag <= 0;\n\tend\n\telse begin\n\t\tif(r_pcie_rx_tag_update == 1)\n\t\t\tr_pcie_rx_tag <= r_pcie_rx_tag + 1;\n\tend\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_pcie_max_read_req_size <= pcie_max_read_req_size;\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\n\t\tend\n\t\tS_PCIE_RX_CMD_0: begin\n\t\t\tr_pcie_rx_len <= {pcie_rx_cmd_rd_data[10:2], 2'b0};\n\t\tend\n\t\tS_PCIE_RX_CMD_1: begin\n\t\t\tcase(r_pcie_max_read_req_size)\n\t\t\t\t3'b010: begin\n\t\t\t\t\tif(r_pcie_rx_len[8:7] == 0 && r_pcie_rx_len[6:2] == 0)\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b100;\n\t\t\t\t\telse\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= {1'b0, r_pcie_rx_len[8:7]};\n\t\t\t\tend\n\t\t\t\t3'b001: begin\n\t\t\t\t\tif(r_pcie_rx_len[7] == 0 && r_pcie_rx_len[6:2] == 0)\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b010;\n\t\t\t\t\telse\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= {2'b0, r_pcie_rx_len[7]};\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\tif(r_pcie_rx_len[6:2] == 0)\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b001;\n\t\t\t\t\telse\n\t\t\t\t\t\tr_pcie_rx_cur_len[9:7] <= 3'b000;\n\t\t\t\tend\n\t\t\tendcase\n\n\t\t\tr_pcie_rx_cur_len[6:2] <= r_pcie_rx_len[6:2];\n\t\t\tr_pcie_addr <= {pcie_rx_cmd_rd_data[33:2], 2'b0};\n\t\tend\n\t\tS_PCIE_CHK_NUM_MRD: begin\n\n\t\tend\n\t\tS_PCIE_MRD_REQ: begin\n\n\t\tend\n\t\tS_PCIE_MRD_ACK: begin\n\n\t\tend\n\t\tS_PCIE_MRD_DONE: begin\n\t\t\tr_pcie_addr <= r_pcie_addr + r_pcie_rx_cur_len;\n\t\t\tr_pcie_rx_len <= r_pcie_rx_len - r_pcie_rx_cur_len;\n\n\t\t\tcase(r_pcie_max_read_req_size)\n\t\t\t\t3'b010: r_pcie_rx_cur_len <= 8'h80;\n\t\t\t\t3'b001: r_pcie_rx_cur_len <= 8'h40;\n\t\t\t\tdefault: r_pcie_rx_cur_len <= 8'h20;\n\t\t\tendcase\n\t\t\t\n\t\t\tr_pcie_mrd_delay <= LP_PCIE_MRD_DELAY;\n\t\tend\n\t\tS_PCIE_MRD_DELAY: begin\n\t\t\tr_pcie_mrd_delay <= r_pcie_mrd_delay - 1'b1;\n\t\tend\n\t\tS_PCIE_MRD_NEXT: begin\n\n\t\tend\n\t\tdefault: begin\n\n\t\tend\n\tendcase\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_RX_CMD_0: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 1;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_RX_CMD_1: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 1;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_CHK_NUM_MRD: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_REQ: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 1;\n\t\t\tr_tx_dma_mrd_req <= 1;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_ACK: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_DONE: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 1;\n\t\tend\n\t\tS_PCIE_MRD_DELAY: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tS_PCIE_MRD_NEXT: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_pcie_rx_cmd_rd_en <= 0;\n\t\t\tr_pcie_tag_alloc <= 0;\n\t\t\tr_tx_dma_mrd_req <= 0;\n\t\t\tr_pcie_rx_tag_update <= 0;\n\t\tend\n\tendcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__a311oi_821f5b85", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__a311oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2      );\n    nor nor0 (nor0_out_Y, and0_out, B1, C1);\n    buf buf0 (Y         , nor0_out_Y      );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux #_ca42b6fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux #(\n    parameter WIDTH = 1\n)(\n  input ctrl,\n  input [WIDTH-1:0] D0,\n  input [WIDTH-1:0] D1,\n  output reg [WIDTH-1:0] S\n);\n\n  // Specify the width of the data signals as a generic argument\n\n  always @(*) begin\n    case (ctrl)\n      1'b0: S = D0;\n      1'b1: S = D1;\n      default: S = 0; // Fixed the default case to output 0.\n    endcase\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CONFIG_REGS_5664668a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule CONFIG_REGS ( BCLK, BRESET, WREN, LD_OUT, OPCODE, SRC1, WRADR, PC_ARCHI, USER, PCMATCH, DBG_HIT, READ,\n\t\t\t\t\t CFG, MCR, PTB_WR, PTB_SEL, IVAR, CINV, Y_INIT, DSR, DBG_TRAPS, DBG_IN );\n\n\tinput\t\t\tBCLK,BRESET;\n\tinput\t\t\tWREN,LD_OUT;\n\tinput\t [7:0]\tOPCODE;\n\tinput\t[31:0]\tSRC1;\n\tinput\t [5:0]\tWRADR;\n\tinput\t[31:0]\tPC_ARCHI;\n\tinput\t\t\tUSER;\n\tinput\t\t\tPCMATCH;\n\tinput\t\t\tDBG_HIT;\n\tinput\t\t\tREAD;\n\t\n\toutput\t[12:0]\tCFG;\n\toutput\t [3:0]\tMCR;\n\toutput\t\t\tPTB_WR;\n\toutput\t\t\tPTB_SEL;\n\toutput\t [1:0]\tIVAR;\n\toutput\t [3:0]\tCINV;\n\toutput\t\t\tY_INIT;\n\toutput\t [3:0]\tDSR;\n\toutput\t [2:0]\tDBG_TRAPS;\n\toutput\t[40:2]\tDBG_IN;\n\t\n\treg\t\t [3:0]\tMCR;\n\treg\t\t[12:0]\tCFG;\n\treg\t\t [1:0]\told_cfg;\n\treg\t\t\t\tPTB_WR,PTB_SEL;\n\treg\t\t\t\tivarreg;\n\treg\t\t [1:0]\tci_all,ci_line;\n\treg\t\t\t\tcheck_y;\n\n\twire\t\t\tld_cfg,ld_mcr,do_cinv;\n\twire\t\t\tinit_ic,init_dc;\n\twire\t\t\top_ok;\n\n\tassign op_ok = (OPCODE == 8'h6A);\tassign ld_cfg  = op_ok & (WRADR == 6'h1C)\t   & WREN;\n\tassign ld_mcr  = op_ok & (WRADR == 6'd9)\t   & WREN;\n\tassign do_cinv = op_ok & (WRADR[5:4] == 2'b11) & WREN;\n\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) CFG <= 13'h0;\n\t\t\telse if (ld_cfg) CFG <= SRC1[12:0];\n\t\t\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) MCR <= 4'h0;\n\t\t\telse if (ld_mcr) MCR <= SRC1[3:0];\n\n\talways @(posedge BCLK) ivarreg <= op_ok & (WRADR[5:1] == 5'd7) & WREN;\tassign IVAR = {ivarreg,PTB_SEL};\n\t\n\talways @(posedge BCLK) PTB_WR  <= op_ok & (WRADR[5:1] == 5'd6) & WREN;\talways @(posedge BCLK) PTB_SEL <= WRADR[0];\n\t\n\talways @(posedge BCLK) old_cfg <= {CFG[11],CFG[9]};\n\t\n\talways @(posedge BCLK) ci_all  <= do_cinv &  WRADR[2] ? WRADR[1:0] : 2'b0;\talways @(posedge BCLK) ci_line <= do_cinv & ~WRADR[2] ? WRADR[1:0] : 2'b0;\tassign init_ic = old_cfg[1] & (~CFG[11] | ci_all[1]);\n\tassign init_dc = old_cfg[0] & (~CFG[9]  | ci_all[0]);\n\t\n\tassign CINV = {init_ic,ci_line[1],init_dc,ci_line[0]};\n\t\n\talways @(posedge BCLK) check_y <= ld_cfg | do_cinv;\n\tassign Y_INIT = check_y & ~init_ic & ~init_dc;\treg\t\t [3:0]\tDSR;\n\treg\t\t[12:0]\tdcr;\n\treg\t\t[31:0]\tbpc;\n\treg\t\t[31:2]\tcar;\n\t\n\twire\t\t\top_dbg,ld_dcr,ld_bpc,ld_dsr,ld_car;\n\twire\t\t\tenable;\n\t\n\tassign op_dbg = (OPCODE == 8'h76);\n\t\n\tassign ld_dcr = op_dbg & (WRADR == 6'h11) & WREN;\n\tassign ld_bpc = op_dbg & (WRADR == 6'h12) & WREN;\n\tassign ld_dsr = op_dbg & (WRADR == 6'h13) & WREN;\n\tassign ld_car = op_dbg & (WRADR == 6'h14) & WREN;\n\n\tassign enable = dcr[12] & (USER ? dcr[10] : dcr[11]);\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) dcr <= 13'd0;\n\t\t\telse if (ld_dcr) dcr <= {SRC1[23:19],SRC1[7:0]};\n\t\t\t\n\talways @(posedge BCLK) if (ld_bpc) bpc <= SRC1;\n\talways @(posedge BCLK) if (ld_car) car <= SRC1[31:2];\n\t\n\tassign DBG_IN = {(dcr[12] & dcr[11]),(dcr[12] & dcr[10]),(dcr[7] & dcr[6]),(dcr[7] & dcr[5]),dcr[4:0],car};\n\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) DSR <= 4'd0;\n\t\t  else\n\t\t\tif (ld_dsr) DSR <= SRC1[31:28];\n\t\t\t  else\n\t\t\t\tbegin\n\t\t\t\t  DSR[3] <= DBG_HIT ? READ : DSR[3];\n\t\t\t\t  DSR[2] <= DSR[2] | PCMATCH;\n\t\t\t\t  DSR[1] <= DSR[1];\n\t\t\t\t  DSR[0] <= DSR[0] | DBG_HIT;\n\t\t\t\tend\n\n\tassign DBG_TRAPS[0] = enable & dcr[9] & (PC_ARCHI == bpc);\tassign DBG_TRAPS[1] = DBG_HIT;\tassign DBG_TRAPS[2] = dcr[8];\tendmodule\n\nmodule FP_STAT_REG ( BCLK, BRESET, LFSR, UP_SP, UP_DP, TT_SP, TT_DP, WREN, WRADR, DIN, FSR, TWREN, FPU_TRAP, SAVE_PC);\n\t\n\tinput\t\t\tBCLK;\n\tinput\t\t\tBRESET;\n\tinput\t\t\tLFSR;\tinput\t\t\tUP_SP,UP_DP;\tinput \t [4:0]\tTT_SP,TT_DP;\n\tinput\t\t\tWREN;\tinput\t [5:4]\tWRADR;\n\tinput \t[16:0] \tDIN;\toutput\t[31:0] \tFSR;\n\toutput\t\t\tTWREN;\n\toutput\treg\t\tFPU_TRAP;\n\toutput\t\t\tSAVE_PC;\n\t\n\treg\t\t [4:3]\ttrap_d;\n\treg\t\t\t\tupdate_d;\n\treg\t\t\t\tset_rm_d;\n\treg\t\t[10:0]\tset_bits;\n\treg\t\t [4:0]\tflags;\n\treg\t\t\t\trm_bit;\n\t\n\twire\t\t\tload_fsr;\n\twire\t\t\tupdate,update_i;\n\twire\t [4:0]\ttrap;\n\twire\t\t\tuflag,iflag,rmflag;\n\n\tassign load_fsr = LFSR & WREN;\n\t\n\tassign trap = UP_SP ? TT_SP : TT_DP;\n\t\n\tassign TWREN = ~((UP_SP & (TT_SP[2:0] != 3'b0)) | (UP_DP & (TT_DP[2:0] != 3'b0)));\n\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) FPU_TRAP <= 1'b0;\n\t\t  else FPU_TRAP <= ~FPU_TRAP & ~TWREN;\tassign update_i = (UP_SP | UP_DP) & ~FPU_TRAP;\talways @(posedge BCLK) update_d\t<= update_i;\n\talways @(posedge BCLK) trap_d\t<= trap[4:3];\n\talways @(posedge BCLK) set_rm_d\t<= WREN & (WRADR == 2'b10);\n\tassign update = update_d & ~FPU_TRAP;\n\t\n\tassign iflag  = (update & trap_d[4]) | flags[4];\tassign uflag  = (update & trap_d[3]) | flags[3];\tassign rmflag = (set_rm_d & ~FPU_TRAP) | rm_bit;\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) flags[4:3] <= 2'b0;\telse\n\t\t  begin\n\t\t\tif (load_fsr) flags[4:3] <= {DIN[6],DIN[4]};\n\t\t\t  else\n\t\t\t\tif (update) flags[4:3] <= {iflag,uflag};\n\t\t  end\n\t\t  \n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) flags[2:0] <= 3'b0;\telse\n\t\t  begin\n\t\t\tif (load_fsr) flags[2:0] <= DIN[2:0];\n\t\t\t  else\n\t\t\t\tif (update_i) flags[2:0] <= trap[2:0];\n\t\t  end\n\t\t  \n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) rm_bit <= 1'b0;\telse\n\t\t  begin\n\t\t\tif (load_fsr) rm_bit <= DIN[16];\n\t\t\t  else\n\t\t\t\tif (set_rm_d & ~FPU_TRAP) rm_bit <= 1'b1;\tend\n\t\t\n\talways @(posedge BCLK or negedge BRESET)\n\t\tif (!BRESET) set_bits <= 11'b0;\telse\n\t\t\tif (load_fsr) set_bits <= {DIN[15:7],DIN[5],DIN[3]};\n\n\tassign FSR = {15'h0,rmflag,set_bits[10:2],iflag,set_bits[1],uflag,set_bits[0],flags[2:0]};\n\t\n\tassign SAVE_PC = (UP_SP | UP_DP) & ~FPU_TRAP;\tendmodule\n\nmodule REGISTER( BCLK, ENWR, DOWR, BYDIN, DIN, RADR, WADR, WMASKE, DOUT, SELI );\n\ninput\t\t\tBCLK;\ninput\t\t\tDOWR,ENWR;\ninput\t[31:0]\tBYDIN,DIN;\ninput\t [7:0]\tRADR;\ninput\t [5:0]\tWADR;\ninput\t [1:0]\tWMASKE;\n\noutput\t[31:0]\tDOUT;\noutput reg \t\tSELI;\n\nreg\t \t [2:0] \tMX;\n\nwire\t [3:0]\tBE;\nwire\t\t\teq_rw;\n\nreg\t \t [7:0]\tREGFILE_D [0:63];\nreg\t \t [7:0]\tREGFILE_C [0:63];\nreg\t \t [7:0]\tREGFILE_B [0:63];\nreg\t \t [7:0]\tREGFILE_A [0:63];\nreg\t\t[31:0]\tRF;\n\nassign\tBE = {WMASKE[1],WMASKE[1],(WMASKE[1] | WMASKE[0]),1'b1};\n\nassign\teq_rw = ENWR & (RADR[5:0] == WADR);\n\nalways @(posedge BCLK) if (RADR[7]) MX[2:0] <= BE[2:0] & {{3{eq_rw}}};\n\nalways @(posedge BCLK) if (RADR[7]) SELI <= RADR[6];\n\nassign DOUT[31:16] = MX[2] ? BYDIN[31:16] : RF[31:16];\nassign DOUT[15:8]  = MX[1] ? BYDIN[15:8]  : RF[15:8];\nassign DOUT[7:0]   = MX[0] ? BYDIN[7:0]   : RF[7:0];\n\t\nalways @(posedge BCLK)\n\tif (RADR[7])\n\t\tbegin\n\t\t\tRF[31:24] <= REGFILE_D[RADR[5:0]];\n\t\t\tRF[23:16] <= REGFILE_C[RADR[5:0]];\n\t\t\tRF[15:8]  <= REGFILE_B[RADR[5:0]];\n\t\t\tRF[7:0]   <= REGFILE_A[RADR[5:0]];\n\t\tend\n\nalways @(posedge BCLK)\n\tif (DOWR)\n\t\tbegin\n\t\t\tif (BE[3]) REGFILE_D[WADR] <= DIN[31:24];\n\t\t\tif (BE[2]) REGFILE_C[WADR] <= DIN[23:16];\n\t\t\tif (BE[1]) REGFILE_B[WADR] <= DIN[15:8];\n\t\t\tif (BE[0]) REGFILE_A[WADR] <= DIN[7:0];\n\t\tend\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mig_7series_v4_0_ddr_phy_ck_addr_cmd_delay #_1b9579b6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule mig_7series_v4_0_ddr_phy_ck_addr_cmd_delay #\n  (\n   parameter TCQ            = 100,\n   parameter tCK            = 3636,\n   parameter DQS_CNT_WIDTH  = 3,\n   parameter N_CTL_LANES    = 3,\n   parameter SIM_CAL_OPTION = \"NONE\"\n   )\n  (\n   input                        clk,\n   input                        rst,\n   input                        cmd_delay_start,\n   output reg [N_CTL_LANES-1:0] ctl_lane_cnt,\n   output reg       po_stg2_f_incdec,\n   output reg       po_en_stg2_f,\n   output reg       po_stg2_c_incdec,\n   output reg       po_en_stg2_c,\n   output           po_ck_addr_cmd_delay_done\n   );\n\n   localparam TAP_CNT_LIMIT = 63;\n\n   localparam FREQ_REF_DIV           = (tCK > 5000 ? 4 :\n                                        tCK > 2500 ? 2 : 1);\n\n   localparam integer PHASER_TAP_RES = ((tCK/2)/64);\n\n   localparam CALC_TAP_CNT = (tCK >= 1250) ? 350 : 300;\n\n   localparam TAP_CNT = 0;\n   localparam TAP_DEC = (SIM_CAL_OPTION == \"FAST_CAL\") ? 0 : 29;\n\n\n\n\n   reg       delay_dec_done;\n   reg       delay_done_r1;\n   reg       delay_done_r2;\n   reg       delay_done_r3;\n   reg       delay_done_r4 ;\n   reg [5:0] delay_cnt_r;\n   reg [5:0] delaydec_cnt_r;\n   reg       po_cnt_inc;\n   reg       po_cnt_dec;\n   reg [3:0] wait_cnt_r;\n\n   assign po_ck_addr_cmd_delay_done = ((TAP_CNT == 0) && (TAP_DEC == 0)) ? 1'b1 : delay_done_r4;\n\n   always @(posedge clk) begin\n     if (rst || po_cnt_dec || po_cnt_inc)\n       wait_cnt_r <= #TCQ 'd8;\n     else if (cmd_delay_start && (wait_cnt_r > 'd0))\n       wait_cnt_r <= #TCQ wait_cnt_r - 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || (delaydec_cnt_r > 6'd0) || (delay_cnt_r == 'd0) || (TAP_DEC == 0))\n       po_cnt_inc      <= #TCQ 1'b0;\n     else if ((delay_cnt_r > 'd0) && (wait_cnt_r == 'd1))\n       po_cnt_inc      <= #TCQ 1'b1;\n     else\n       po_cnt_inc      <= #TCQ 1'b0;\n   end\n\n   always @(posedge clk) begin\n     if (rst || (delaydec_cnt_r == 'd0))\n       po_cnt_dec      <= #TCQ 1'b0;\n     else if (cmd_delay_start && (delaydec_cnt_r > 'd0) && (wait_cnt_r == 'd1))\n       po_cnt_dec      <= #TCQ 1'b1;\n     else\n       po_cnt_dec      <= #TCQ 1'b0;\n   end\n\n   always @(posedge clk) begin\n     if (rst) begin\n       po_stg2_f_incdec <= #TCQ 1'b0;\n       po_en_stg2_f     <= #TCQ 1'b0;\n       po_stg2_c_incdec <= #TCQ 1'b0;\n       po_en_stg2_c     <= #TCQ 1'b0;\n     end else begin\n       if (po_cnt_dec) begin\n         po_stg2_f_incdec <= #TCQ 1'b0;\n         po_en_stg2_f     <= #TCQ 1'b1;\n       end else begin\n         po_stg2_f_incdec <= #TCQ 1'b0;\n         po_en_stg2_f     <= #TCQ 1'b0;\n       end\n       if (po_cnt_inc) begin\n         po_stg2_c_incdec <= #TCQ 1'b1;\n         po_en_stg2_c     <= #TCQ 1'b1;\n       end else begin\n         po_stg2_c_incdec <= #TCQ 1'b0;\n         po_en_stg2_c     <= #TCQ 1'b0;\n       end\n     end\n   end\n\n   always @(posedge clk) begin\n     if (rst || (tCK >= 2500) || (SIM_CAL_OPTION == \"FAST_CAL\"))\n       delay_cnt_r  <= #TCQ 'd0;\n     else if ((delaydec_cnt_r > 6'd0) ||((delay_cnt_r == 6'd0) && (ctl_lane_cnt != N_CTL_LANES-1)))\n       delay_cnt_r  <= #TCQ 'd1;\n     else if (po_cnt_inc && (delay_cnt_r > 6'd0))\n       delay_cnt_r  <= #TCQ delay_cnt_r - 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start ||((delaydec_cnt_r == 6'd0) && (delay_cnt_r == 6'd0) && (ctl_lane_cnt != N_CTL_LANES-1)))\n       delaydec_cnt_r  <= #TCQ TAP_DEC;\n     else if (po_cnt_dec && (delaydec_cnt_r > 6'd0))\n       delaydec_cnt_r  <= #TCQ delaydec_cnt_r - 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start )\n       ctl_lane_cnt <= #TCQ 6'b0;\n     else if (~delay_dec_done && (ctl_lane_cnt == N_CTL_LANES-1) && (delaydec_cnt_r == 6'd1))\n       ctl_lane_cnt <= #TCQ ctl_lane_cnt;\n     else if ((ctl_lane_cnt != N_CTL_LANES-1) && (delaydec_cnt_r == 6'd0) && (delay_cnt_r == 'd0))\n       ctl_lane_cnt <= #TCQ ctl_lane_cnt + 1;\n   end\n\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start)  begin\n       delay_dec_done    <= #TCQ 1'b0;\n     end else if (((TAP_CNT == 0) && (TAP_DEC == 0)) ||\n                 ((delaydec_cnt_r == 6'd0) && (delay_cnt_r == 'd0) && (ctl_lane_cnt == N_CTL_LANES-1))) begin\n       delay_dec_done    <= #TCQ 1'b1;\n     end\n   end\n\n\n\n   always @(posedge clk) begin\n     delay_done_r1 <= #TCQ delay_dec_done;\n     delay_done_r2 <= #TCQ delay_done_r1;\n     delay_done_r3 <= #TCQ delay_done_r2;\n     delay_done_r4 <= #TCQ delay_done_r3;\n   end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_with_multiplexer_97cf2eec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_with_multiplexer (\n  input [3:0] A,\n  input [3:0] B,\n  input sel,\n  output [3:0] sum,\n  output carry_out,\n  output greater_than_7\n);\n\n  wire [3:0] mux_out;\n  wire c1, c2, c3;\n  \n  assign mux_out = sel ? B : A;\n  \n  assign {carry_out, sum} = A + mux_out;\n  \n  assign c1 = A[0] & mux_out[0];\n  assign c2 = A[0] ^ mux_out[0];\n  assign c3 = sum[0] ^ c2;\n  \n  assign greater_than_7 = c1 | c3;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "soc_system_jtag_uart_sim_scfifo_w_4b1c1415", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule soc_system_jtag_uart_sim_scfifo_w (\n  // inputs:\n  input clk,\n  input [7:0] fifo_wdata,\n  input fifo_wr,\n\n  // outputs:\n  output reg fifo_FF,\n  output reg [7:0] r_dat,\n  output reg wfifo_empty,\n  output reg [5:0] wfifo_used\n);\n\n  reg [7:0] fifo [63:0];\n  reg [5:0] head;\n  reg [5:0] tail;\n  reg [6:0] count;\n  wire full = (count == 64);\n  wire empty = (count == 0);\n\n  always @(posedge clk) begin\n    if (fifo_wr && !full) begin\n      fifo[head] <= fifo_wdata;\n      head <= head + 1;\n      count <= count + 1;\n    end\n    if (!empty) begin\n      r_dat <= fifo[tail];\n      tail <= tail + 1;\n      count <= count - 1;\n    end\n  end\n\n  always @* begin\n    wfifo_used <= count;\n    fifo_FF = full;\n    wfifo_empty = empty;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axis_averager #_0ace2e0f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule axis_averager #\n(\n  parameter integer AXIS_TDATA_WIDTH = 32,\n  parameter integer BRAM_DATA_WIDTH = 32,\n  parameter integer BRAM_ADDR_WIDTH = 16,  parameter integer AVERAGES_WIDTH = 32\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n  \n  input  wire\t\t\t\t\t\t trig,\n  input  wire \t\t\t\t\t\t user_reset,\n  input  wire [15:0]\t\t\t\t nsamples,\n  input  wire [AVERAGES_WIDTH-1:0] \t naverages,\n  output wire \t\t\t\t\t\t finished,\n  output wire [AVERAGES_WIDTH-1:0] \t averages_out,\n  \n  output wire                        s_axis_tready,\n  input  wire [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,\n  input  wire                        s_axis_tvalid,\n\n  output wire                        bram_porta_clk,\n  output wire                        bram_porta_rst,\n  output wire [BRAM_ADDR_WIDTH-1:0]  bram_porta_addr,\n  output wire [BRAM_DATA_WIDTH-1:0]  bram_porta_wrdata,\n  input  wire [BRAM_DATA_WIDTH-1:0]  bram_porta_rddata,\n  output wire                        bram_porta_we,\n  \n  output wire                        bram_portb_clk,\n  output wire                        bram_portb_rst,\n  output wire [BRAM_ADDR_WIDTH-1:0]  bram_portb_addr,\n  output wire [BRAM_DATA_WIDTH-1:0]  bram_portb_wrdata,\n  input  wire [BRAM_DATA_WIDTH-1:0]  bram_portb_rddata,\n  output wire                        bram_portb_we\n);\n\n\n  reg [BRAM_ADDR_WIDTH-1:0] int_addrA_reg, int_addrA_next;\n  reg [BRAM_ADDR_WIDTH-1:0] int_addrB_reg, int_addrB_next;\n  reg [2:0] int_case_reg, int_case_next;\n  reg int_wren_reg, int_wren_next;\n  reg [AVERAGES_WIDTH-1:0] int_averages_reg, int_averages_next;\n  reg int_finished_reg, int_finished_next;\n  reg [BRAM_DATA_WIDTH-1:0] int_data_reg, int_data_next;\n  reg d_trig;\n  wire trigger;  \n  \n  \n  assign s_axis_tready = 1;\n  assign finished = int_finished_reg;\n  assign averages_out = int_averages_reg;\n  \n  assign bram_porta_clk = aclk;\n  assign bram_porta_rst = ~aresetn;\n  assign bram_porta_addr = int_addrA_reg;\n  assign bram_porta_wrdata = int_data_reg;\n  assign bram_porta_we = int_wren_reg;\n   \n  assign bram_portb_clk = aclk;\n  assign bram_portb_rst = ~aresetn;\n  assign bram_portb_addr = int_addrB_reg;\n  assign bram_portb_wrdata = {(BRAM_DATA_WIDTH){1'b0}};\n  assign bram_portb_we = 1'b0;\n  \n  \n  always@(posedge aclk) begin\n\t if (user_reset) d_trig <= 0;\n\t else d_trig <= trig;\n  end\n  assign trigger = (trig == 1) && (d_trig == 0) ? 1 : 0;\n\n  \n  always @(posedge aclk)\n  begin\n    if(~aresetn || user_reset)\n    begin\n      int_addrA_reg <= {(BRAM_ADDR_WIDTH){1'b0}};\n\t  int_addrB_reg <= {(BRAM_ADDR_WIDTH){1'b0}};\n      int_case_reg <= 3'd0;\n\t  int_averages_reg <= {(AVERAGES_WIDTH){1'b0}};\n      int_wren_reg <= 1'b0;\n      int_data_reg <= {(BRAM_DATA_WIDTH){1'b0}};\n      int_finished_reg <= 1'b0;\n    end\n    else\n    begin\n      int_addrA_reg <= int_addrA_next;\n      int_addrB_reg <= int_addrB_next;\n      int_case_reg <= int_case_next;\n      int_wren_reg <= int_wren_next;\n\t  int_averages_reg <= int_averages_next;\n\t  int_data_reg <= int_data_next;\n\t  int_finished_reg <= int_finished_next;\n    end\n  end\n\n  \n  always @*\n  begin\n    int_addrA_next = int_addrA_reg;\n\tint_addrB_next = int_addrB_reg;\n    int_case_next = int_case_reg;\n    int_wren_next = int_wren_reg;\n\tint_averages_next = int_averages_reg;\n\tint_data_next = int_data_reg;\n\tint_finished_next = int_finished_reg;\n\t\n    case(int_case_reg)\n      0:    begin\n        int_addrA_next = {(BRAM_ADDR_WIDTH){1'b0}};\n\t\tint_addrB_next = {(BRAM_ADDR_WIDTH){1'b0}};\n\t\tint_averages_next = {(AVERAGES_WIDTH){1'b0}};\n\t\tint_case_next = 3'd1;\n\t\tint_wren_next = 1'b1;\n\t\tint_finished_next = 1'b0;\n\t\tint_data_next = {(BRAM_DATA_WIDTH){1'b0}};\n      end\n      1:    begin\n        int_addrA_next = int_addrA_reg + 1'b1;\n        if(int_addrA_reg == nsamples-1) begin\n          int_case_next = 3'd2;\n\t\t  int_wren_next = 1'b0;\n        end\n      end\n      2:    begin\n        int_addrA_next = -2;\n        int_addrB_next = 0;\n        int_wren_next = 1'b0;\n        if(trigger)\n        begin\n\t\t  int_averages_next = int_averages_reg + 1;\n\t\t  if (int_averages_reg == naverages)\n\t\t\t int_case_next = 3'd4;\n\t\t  else\n\t\t\t int_case_next = 3'd3;          \n        end\n      end\n\t  3:    begin\n        if(s_axis_tvalid)\n        begin\n          int_addrA_next = int_addrA_reg + 1;\n\t\t  int_addrB_next = int_addrB_reg + 1;\n\t\t  int_data_next = bram_portb_rddata + s_axis_tdata;\n\t\t  int_wren_next = 1'b1;\n\t\t  if (int_addrA_reg == nsamples-2)\n\t\t\t int_case_next = 3'd2;\n        end\n\t\telse\n\t\t  int_wren_next = 1'b0;\n      end\n      4:\tbegin\n        int_finished_next = 1;\n      end\n\n    endcase\n  end\n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_757a37d4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    sel,\n    data_in_0,\n    data_in_1,\n    out\n);\n\n    // Module ports\n    input  sel;\n    input  data_in_0;\n    input  data_in_1;\n    output out;\n\n    // Local signals\n    wire and0_out;\n    wire and1_out;\n    wire not_sel;\n\n    //  Name  Output     Other arguments\n    not not0 (not_sel, sel);\n    and and0 (and0_out, data_in_0, not_sel);\n    and and1 (and1_out, data_in_1, sel);\n    or  or0  (out     , and0_out, and1_out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_inverter_18d1f636", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_inverter (\n    output Y, // output\n    input  A  // input\n);\n\n    not (Y, A);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hub_core_7b1d3676", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule hub_core (uart_clk, new_nonces, golden_nonce, serial_send, serial_busy, slave_nonces);\n   parameter SLAVES = 2;\n\n   input uart_clk;\n   \n   input [SLAVES-1:0] new_nonces;\n   input [SLAVES*32-1:0] slave_nonces;\n   output [31:0] \t golden_nonce;\n   output \t\t serial_send;\n   input \t\t serial_busy;\n\n   reg \t\t\t serial_send_reg = 0;\n   assign serial_send = serial_send_reg;\n  \n   reg [SLAVES-1:0] \tnew_nonces_flag = 0;\n   \n   function integer clog2;\t\tinput integer value;\n      begin\n      value = value-1;\n      for (clog2=0; value>0; clog2=clog2+1)\n      value = value>>1;\n      end\n   endfunction\n\n   reg [clog2(SLAVES)+1:0] port_counter = 0;\n   reg [SLAVES*32-1:0] \t    slave_nonces_shifted = 0;\n   assign golden_nonce = slave_nonces_shifted[31:0];\n\n   reg [SLAVES-1:0] \t    clear_nonces = 0;\n   \n   always @(posedge uart_clk)\n     begin\n\tnew_nonces_flag <= (new_nonces_flag & ~clear_nonces) | new_nonces;\n\n\tif (port_counter == SLAVES-1)\n\t  port_counter <= 0;\n\telse\n\t  port_counter <= port_counter + 1;\n\t\n\tif (!serial_busy && new_nonces_flag[port_counter])\n\t  begin\n\t     slave_nonces_shifted <= slave_nonces >> port_counter*32;\n\t     serial_send_reg <= 1;\n\t     clear_nonces[port_counter] <= 1;\n\t  end\n\telse \n\t  begin\n\t     serial_send_reg <= 0;\n\t     clear_nonces <= 0;\n\t  end\n     end\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dffsi_9_5571cd9c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dffsi_9 (\n    input clk,\n    input reset,\n    input [8:0] init,\n    input [8:0] d,\n    output reg [8:0] q\n);\n\n    // Synthesis Attribute to keep hierarchy\n     \n\n    // Random initialization\n    `ifdef RANDOM_INIT\n        initial $random_init(q);\n    `endif\n\n    // Assertion for checking reset signal\n    `ifdef CHK_RESET_EOS\n        assert_quiescent_state #(0,1,0, \"***ERROR ASSERT: reset still asserted at end of simulation\")\n            a0(.clk(clk), .reset_n(1'b1), .state_expr(reset), .check_value(1'b0), .sample_event(1'b0));\n    `endif\n\n    always @(posedge clk) begin\n        if (!reset) begin\n            q <= init;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux8_d2ca808c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux8\n  #(parameter WIDTH=32, parameter DISABLED=0)\n    (input en,\n     input [2:0] sel,\n     input [WIDTH-1:0] i0,\n     input [WIDTH-1:0] i1,\n     input [WIDTH-1:0] i2,\n     input [WIDTH-1:0] i3,\n     input [WIDTH-1:0] i4,\n     input [WIDTH-1:0] i5,\n     input [WIDTH-1:0] i6,\n     input [WIDTH-1:0] i7,\n     output [WIDTH-1:0] o);\n\n   reg [WIDTH-1:0] _o;\n\n   always @(*) begin\n      case(sel)\n         3'b000: _o = i0;\n         3'b001: _o = i1;\n         3'b010: _o = i2;\n         3'b011: _o = i3;\n         3'b100: _o = i4;\n         3'b101: _o = i5;\n         3'b110: _o = i6;\n         3'b111: _o = i7;\n         default: _o = DISABLED;\n      endcase\n   end\n\n   assign o = en ? _o : DISABLED;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_4bit_a91d9d89", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_sub_4bit (\n  input signed [3:0] A,\n  input signed [3:0] B,\n  input mode,\n  output reg signed [3:0] result\n);\n\n  wire [3:0] twos_comp_B;\n  assign twos_comp_B = (~B) + 1;\n\n  always @* begin\n    if (mode) begin\n      result <= A + B;\n    end else begin\n      result <= A + twos_comp_B;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bcdtoseg_0cd58b4d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bcdtoseg(nLT, nRBI, A3, A2, A1, A0, nBI,\n\t\t\t\tnRBO, nA, nB, nC, nD, nE, nF, nG);\n\n\tinput  nLT, nRBI, A3, A2, A1, A0, nBI;\n\toutput nRBO, nA, nB, nC, nD, nE, nF, nG;\n\n\twire  [3:0] SEGIN;\n\t\n\treg   [6:0] nSEGOUT;\n\n\tassign   SEGIN[3] = A3;\n\tassign   SEGIN[2] = A2;\n\tassign   SEGIN[1] = A1;\n\tassign   SEGIN[0] = A0;\n\n\tassign   nA = nSEGOUT[6];\n\tassign   nB = nSEGOUT[5];\n\tassign   nC = nSEGOUT[4];\n\tassign   nD = nSEGOUT[3];\n\tassign   nE = nSEGOUT[2];\n\tassign   nF = nSEGOUT[1];\n\tassign   nG = nSEGOUT[0];\n\n\tassign nRBO = ~(~nBI || (~nRBI && (SEGIN == 4'd0) && nLT));\n\t\n\talways @ (nRBO or nLT or SEGIN) begin\n\t\tif (~nRBO) begin\n\t\t\tnSEGOUT = ~7'b0000000; \n\t\tend else if (~nLT) begin\n\t\t\tnSEGOUT = ~7'b1111111; \n\t\tend else begin \n\t\t\tcase (SEGIN)\n\t\t\t\t4'd0:     nSEGOUT = ~7'b1111110; \n\t\t\t\t4'd1:     nSEGOUT = ~7'b0110000;\n\t\t\t\t4'd2:     nSEGOUT = ~7'b1101101;\n\t\t\t\t4'd3:     nSEGOUT = ~7'b1111001;\n\t\t\t\t4'd4:     nSEGOUT = ~7'b0110011;\n\t\t\t\t4'd5:     nSEGOUT = ~7'b1011011;\n\t\t\t\t4'd6:     nSEGOUT = ~7'b1011111;\n\t\t\t\t4'd7:     nSEGOUT = ~7'b1110000;\n\t\t\t\t4'd8:     nSEGOUT = ~7'b1111111;\n\t\t\t\t4'd9:     nSEGOUT = ~7'b1111011;\n\t\t\t\t4'hF:\t\t nSEGOUT = ~7'b1100111;\tdefault:  nSEGOUT = ~7'b0000000;\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_parity_e3798134", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_parity (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output [3:0] out,\n  output parity\n);\n\n  wire [3:0] mux_out [0:5];\n  wire [2:0] sel_dec [0:7];\n  \n  // Generate intermediate signals for each input data\n  assign mux_out[0] = (sel_dec[0]) ? data0 : 4'b0;\n  assign mux_out[1] = (sel_dec[1]) ? data1 : 4'b0;\n  assign mux_out[2] = (sel_dec[2]) ? data2 : 4'b0;\n  assign mux_out[3] = (sel_dec[3]) ? data3 : 4'b0;\n  assign mux_out[4] = (sel_dec[4]) ? data4 : 4'b0;\n  assign mux_out[5] = (sel_dec[5]) ? data5 : 4'b0;\n  \n  // Generate select signals using a 3-to-8 decoder\n  assign sel_dec[0] = (sel == 3'b000);\n  assign sel_dec[1] = (sel == 3'b001);\n  assign sel_dec[2] = (sel == 3'b010);\n  assign sel_dec[3] = (sel == 3'b011);\n  assign sel_dec[4] = (sel == 3'b100);\n  assign sel_dec[5] = (sel == 3'b101);\n  assign sel_dec[6] = 1'b0;\n  assign sel_dec[7] = 1'b0;\n  \n  // Select the active input data using an 8-input OR gate\n  assign out = mux_out[0] | mux_out[1] | mux_out[2] | mux_out[3] | mux_out[4] | mux_out[5];\n  \n  // Generate the parity bit using an XOR gate\n  assign parity = out[0] ^ out[1] ^ out[2] ^ out[3];\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cross_domain_sync_0ba979cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cross_domain_sync (\n    input capturetrig1, // input trigger signal from other clock domain\n    input  read_Mux_In, // input data signal from other clock domain\n    input s_axi_aclk, // local clock signal\n    output reg captureTrig1_d0 // synchronized output data signal\n);\n\n  // Declare internal wires\n  wire CaptureTrig1_int;\n  wire s_level_out_d1_cdc_to;\n  wire s_level_out_d2;\n  wire s_level_out_d3;\n\n  // Instantiate FDRE primitive components for cross-domain synchronization\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_IN_cdc_to \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(capturetrig1),\n        .Q(s_level_out_d1_cdc_to),\n        .R(1'b0));\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_s_level_out_d2 \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(s_level_out_d1_cdc_to),\n        .Q(s_level_out_d2),\n        .R(1'b0));\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_s_level_out_d3 \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(s_level_out_d2),\n        .Q(s_level_out_d3),\n        .R(1'b0));\n  FDRE GENERATE_LEVEL_P_S_CDC_SINGLE_BIT_CROSS_PLEVEL_IN2SCNDRY_s_level_out_d4 \n       (.C(s_axi_aclk),\n        .CE(1'b1),\n        .D(s_level_out_d3),\n        .Q(CaptureTrig1_int),\n        .R(1'b0));\n\n\n  always @(posedge s_axi_aclk) begin\n    if (CaptureTrig1_int) begin\n      captureTrig1_d0 <= read_Mux_In;\n    end\n  end\n\n\nendmodule\n\nmodule FDRE(\n    input D,     \n    input C,    \n    input CE,    \n    input R,     \n    output reg Q \n);\n\nalways @(posedge C) begin\n    if (R) begin\n        Q <= 1'b0; \n    end\n    else if (CE) begin\n        Q <= D; \n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o221a_a6348043", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__o221a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , B2, B1              );\n    or  or1  (or1_out   , A2, A1              );\n    and and0 (and0_out_X, or0_out, or1_out, C1);\n    buf buf0 (X         , and0_out_X          );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ddr3_eim_cs1_15c7b5b7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ddr3_eim_cs1(\n\t\t    input wire clk,\n\t\t    \n\t\t    input wire [63:0] ctl, \n\t\t    input wire ctl_stb,  output wire [63:0] burst_rd,\n\t\t    input wire rd_stb,   output wire [63:0] status,\n\n\t\t    output wire [2:0] ddr3_rd_cmd,\n\t\t    output wire [5:0] ddr3_rd_bl,\n\t\t    output wire [29:0] ddr3_rd_adr,\n\t\t    output wire ddr3_rd_cmd_en,\n\t\t    input wire ddr3_rd_cmd_empty,\n\t\t    input wire ddr3_rd_cmd_full,\n\n\t\t    input wire [31:0] ddr3_rd_data,\n\t\t    input wire [6:0] ddr3_rd_count,\n\t\t    input wire ddr3_rd_empty,\n\t\t    input wire ddr3_rd_full,\n\t\t    output reg ddr3_rd_en,\n\t\t    \n\t\t    input wire reset\n\t\t    );\n\n   reg [29:0] \t\t cmd_adr;\n   reg [4:0] \t\t num_pkts; reg [4:0] \t\t outstanding;\n\n   reg [63:0] \t\t rd_cache;\n\n   reg \t\t\t cmd_go;\n\n   reg \t\t\t reset_errors;\n   reg \t\t\t cmd_err;\n\n   reg [7:0] \t\t readcount;\n   \n   assign burst_rd[63:0] = rd_cache[63:0];\n   \n   \n   assign status = {readcount,\n\t\t    3'b0,cmd_err, \n\t\t    ddr3_rd_cmd_empty, ddr3_rd_cmd_full, ddr3_rd_empty, ddr3_rd_full, \n\t\t    1'b0, ddr3_rd_count[6:0]};\n\n   always @(posedge clk) begin\n      if( ctl_stb ) begin\n\t readcount <= 8'b0;\n      end else if( rd_stb ) begin\n\t readcount <= readcount + 8'b1;\n      end else begin\n\t readcount <= readcount;\n      end\n   end\n\n   always @(posedge clk) begin\n      if( ctl_stb ) begin\n\t cmd_adr <= ctl[29:0];\n\t num_pkts <= ctl[36:32]; end else begin\n\t cmd_adr <= cmd_adr;\n\t num_pkts <= num_pkts;\n      end\n      \n      cmd_go <= ctl_stb && (ctl[36:32] != 5'b0);\n   end\n\n   assign ddr3_rd_cmd = 3'b001; assign ddr3_rd_adr = {cmd_adr[29:2],2'b00}; assign ddr3_rd_bl[5:0] = {num_pkts[4:0],1'b0} - 6'b1;\n   assign ddr3_rd_cmd_en = cmd_go; parameter READ_IDLE        = 6'b1 << 0;\n   parameter READ_PENDING     = 6'b1 << 1;\n   parameter READ_FETCH       = 6'b1 << 2;\n   parameter READ_UPDATE_LSB  = 6'b1 << 3;\n   parameter READ_UPDATE_MSB  = 6'b1 << 4;\n   parameter READ_WAIT        = 6'b1 << 5;\n\n   parameter READ_nSTATES = 6;\n   reg [(READ_nSTATES - 1):0] \t\t cstate;\n   reg [(READ_nSTATES - 1):0] \t\t nstate;\n\n   always @(posedge clk) begin\n      cstate <= nstate;\n   end\n\n   always @(*) begin\n      case(cstate)\n\tREAD_IDLE: begin\n\t   if( cmd_go ) begin\n\t      nstate <= READ_PENDING;\n\t   end else begin\n\t      nstate <= READ_IDLE;\n\t   end\n\tend\n\tREAD_PENDING: begin\n\t   if( outstanding != 5'b0 ) begin\n\t      if( ddr3_rd_count[6:0] < 7'b10 ) begin\n\t\t nstate <= READ_PENDING;\n\t      end else begin\n\t\t nstate <= READ_FETCH;\n\t      end\n\t   end else begin\n\t      nstate <= READ_IDLE;\n\t   end\n\tend READ_FETCH: begin\n\t   nstate <= READ_UPDATE_LSB;\n\tend\n\tREAD_UPDATE_LSB: begin\n\t   nstate <= READ_UPDATE_MSB;\n\tend\n\tREAD_UPDATE_MSB: begin\n\t   nstate <= READ_WAIT;\n\tend\n\tREAD_WAIT: begin\n\t   if( rd_stb ) begin  nstate <= READ_PENDING;\n\t   end else begin\n\t      nstate <= READ_WAIT;\n\t   end\n\tend\n\tdefault: begin\n\t   nstate <= READ_IDLE;\n\tend\n      endcase end always @(posedge clk) begin\n      case(cstate)\n\tREAD_IDLE: begin\n\t   outstanding[4:0] <= num_pkts[4:0];\n\t   rd_cache <= rd_cache;\n\t   if( ddr3_rd_count[6:0] > 7'b0 ) begin\n\t      ddr3_rd_en <= 1'b1; end else begin\n\t      ddr3_rd_en <= 1'b0;\n\t   end\n\tend\n\tREAD_PENDING: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b0;\n\tend\n\tREAD_FETCH: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b1;\n\tend\n\tREAD_UPDATE_LSB: begin\n\t   outstanding <= outstanding;\n\t   rd_cache[63:0] <= {rd_cache[63:32],ddr3_rd_data[31:0]};\n\t   ddr3_rd_en <= 1'b1;\n\tend\n\tREAD_UPDATE_MSB: begin\n\t   outstanding <= outstanding - 5'b1;\n\t   rd_cache[63:0] <= {ddr3_rd_data[31:0],rd_cache[31:0]};\nddr3_rd_en <= 1'b0;\n\tend\n\tREAD_WAIT: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b0;\n\tend\n\tdefault: begin\n\t   outstanding <= outstanding;\n\t   rd_cache <= rd_cache;\n\t   ddr3_rd_en <= 1'b0;\n\tend\n      endcase end\n   \n   \n   always @(posedge clk) begin\n      reset_errors <= ctl[63];\n      if( reset_errors ) begin\n\t cmd_err <= 1'b0;\n      end else begin\n\t if( cmd_go && ddr3_rd_cmd_full ) begin\n\t    cmd_err <= 1'b1;\n\t end else begin\n\t    cmd_err <= cmd_err;\n\t end\n      end\n   end endmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "handshake_92363779", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule handshake(error, clk, req, ack, reset);\n\noutput reg error;\n\ninput clk, req, ack, reset;\n\nreg [2:0] state;\n\ninitial\nbegin\n\tstate = 3'b000;\n\terror = 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tcase (state)\n\t\t3'b000: \n\t\tbegin\n\t\t\tif (~req && ~ack)\n\t\t\t\tstate = 3'b000;\n\t\t\telse if (req && ~ack)\n\t\t\t\tstate = 3'b001;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b001:\n\t\tbegin\n\t\t\tif (req && ~ack)\n\t\t\t\tstate = 3'b001;\n\t\t\telse if (req && ack)\n\t\t\t\tstate = 3'b010;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b010:\n\t\tbegin\n\t\t\tif (req && ack)\n\t\t\t\tstate = 3'b010;\n\t\t\telse if (~req && ack)\n\t\t\t\tstate = 3'b011;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b011:\n\t\tbegin\n\t\t\tif (~req && ack)\n\t\t\t\tstate = 3'b011;\n\t\t\telse if (~req && ~ack)\n\t\t\t\tstate = 3'b000;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tstate = 3'b100;\n\t\t\t\terror = 1'b1;\n\t\t\tend\n\t\tend\n\t\t\n\t\t3'b100:\n\t\tbegin\n\t\t\tif (reset)\n\t\t\tbegin\n\t\t\t\tstate = 3'b000;\n\t\t\t\terror = 1'b0;\n\t\t\tend\n\t\tend\n\t\t\n\t\tdefault:\n\t\tbegin\n\t\t\tstate = 3'b100;\n\t\t\terror = 1'b1;\n\t\tend\n\tendcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_82d8a358", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] result\n);\n\n    always @(*) begin\n        if (B >= 0) begin\n            result = A << B;\n        end else begin\n            result = A >> $signed(B);\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__5934ab97", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input load,\n    input up_down,\n    input [3:0] D,\n    output [3:0] OUT\n);\n\nreg [3:0] up_counter;\nreg [3:0] down_counter;\nwire [3:0] xor_output;\n\n// Up counter\nalways @(posedge clk) begin\n    if (load) begin\n        up_counter <= D;\n    end else if (up_down) begin\n        if (up_counter == 4'b1111) begin\n            up_counter <= 4'b0;\n        end else begin\n            up_counter <= up_counter + 1;\n        end\n    end\nend\n\n// Down counter\nalways @(posedge clk) begin\n    if (load) begin\n        down_counter <= D;\n    end else if (!up_down) begin\n        if (down_counter == 4'b0000) begin\n            down_counter <= 4'b1111;\n        end else begin\n            down_counter <= down_counter - 1;\n        end\n    end\nend\n\n// XOR module\nassign xor_output = up_counter ^ down_counter;\n\n// Output\nassign OUT = xor_output;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_top_ee99d231", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n`define READ\t\t\t2'b01\n`define WRITE\t\t\t2'b10\n`define DO_NOTHING\t2'b00\n`define INVALID\t\t2'b11\n\n`define DATA_VALID\t1'b1\n`define DATA_INVALID\t1'b0\n\n`define FIFO_FULL\t\t\t1'b1\n`define FIFO_NOT_FULL\t1'b0\n\n`define FIFO_EMPTY\t\t1'b1\n`define FIFO_NOT_EMPTY\t1'b0\n\n`define LOG2(width) \t(width<=2)?1:\\\n\t\t\t\t\t\t\t(width<=4)?2:\\\n\t\t\t\t\t\t\t(width<=8)?3:\\\n\t\t\t\t\t\t\t(width<=16)?4:\\\n\t\t\t\t\t\t\t(width<=32)?5:\\\n\t\t\t\t\t\t\t(width<=64)?6:\\\n\t\t\t\t\t\t\t(width<=128)?7:\\\n\t\t\t\t\t\t\t(width<=256)?8:\\\n\t\t\t\t\t\t\t-1\t\t\t\t\t\t\t\nmodule fifo_top(\n    data_out, empty_flag, full_flag,\n    vector_in, reset,\n    clk\n    );\nparameter DATA_WIDTH = 4;\nparameter NUM_ENTRIES = 4;\nparameter OPCODE_WIDTH = 2;\nparameter LINE_WIDTH = DATA_WIDTH+OPCODE_WIDTH; parameter INITIAL_VALUE = 'b0; \nparameter NUM_ENTRIES_BIT = `LOG2(NUM_ENTRIES); \n\noutput reg [DATA_WIDTH-1:0]data_out;\noutput reg empty_flag;\noutput reg full_flag;\ninput [OPCODE_WIDTH+DATA_WIDTH-1:0]vector_in;\ninput reset;\ninput clk;\n\nreg [DATA_WIDTH-1:0]fifo_data[NUM_ENTRIES-1:0];\nreg [NUM_ENTRIES-1:0]fifo_valid_invalid_bit;\n\nreg [OPCODE_WIDTH-1:0]control_in;\treg [DATA_WIDTH-1:0]data_in;\t\t\treg [NUM_ENTRIES_BIT-1:0]fifo_head_pos;\nreg [NUM_ENTRIES_BIT-1:0]fifo_tail_pos;\n\nreg [NUM_ENTRIES_BIT-1:0]loop_variable;\n\nalways@(posedge clk)\nbegin\t\n\tif(reset)\n\tbegin\n\t\tdata_out = INITIAL_VALUE;\n\t\tfifo_head_pos = INITIAL_VALUE;\n\t\tfifo_tail_pos = INITIAL_VALUE;\n\t\tloop_variable = INITIAL_VALUE;\n\t\tcontrol_in = INITIAL_VALUE;\n\t\tdata_in = INITIAL_VALUE;\n\t\tfifo_valid_invalid_bit = INITIAL_VALUE;\n\t\tempty_flag = `FIFO_NOT_EMPTY;\n\t\tfull_flag = `FIFO_NOT_FULL;\n\tend else\n\t\tbegin\n\t\t\tif(fifo_tail_pos == fifo_head_pos)begin\n\t\t\t\tif(fifo_valid_invalid_bit[fifo_tail_pos] == `DATA_INVALID && fifo_valid_invalid_bit[fifo_head_pos] == `DATA_INVALID)\n\t\t\t\t\tbegin\n\t\t\t\t\tempty_flag = `FIFO_EMPTY;\n\t\t\t\t\tfull_flag = `FIFO_NOT_FULL;\n\t\t\t\tend else\n\t\t\t\t\tbegin\n\t\t\t\t\t\tempty_flag = `FIFO_NOT_EMPTY;\n\t\t\t\t\t\tfull_flag = `FIFO_FULL;\t\t\t\t\t\n\t\t\t\t\tend\t\n\t\t\tend else \t\t\t\t\n\t\t\t\tbegin\n\t\t\t\t\tempty_flag = `FIFO_EMPTY;\n\t\t\t\t\tfull_flag = `FIFO_NOT_FULL;\n\t\t\t\tend\t\t\t\t\n\t\t\tcontrol_in = vector_in[LINE_WIDTH-1:LINE_WIDTH-OPCODE_WIDTH];\t\n\t\t\tdata_in = vector_in[LINE_WIDTH-OPCODE_WIDTH-1:LINE_WIDTH-OPCODE_WIDTH-DATA_WIDTH];\n\t\t\tcase(control_in)\t\t\t\n\t\t\t\t\t`READ: \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(fifo_valid_invalid_bit[fifo_tail_pos] == `DATA_VALID)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tdata_out = fifo_data[fifo_tail_pos];\n\t\t\t\t\t\t\t\t\tfifo_valid_invalid_bit[fifo_tail_pos] = `DATA_INVALID;\n\t\t\t\t\t\t\t\t\tfifo_tail_pos = fifo_tail_pos + 1'b1;\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tend else\n\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\tdata_out = 'bx;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\t\n\t\t\t\t\t`WRITE: \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tif(empty_flag == `FIFO_EMPTY && full_flag == `FIFO_NOT_FULL)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tfifo_data[fifo_head_pos] = data_in;\n\t\t\t\t\t\t\t\t\tfifo_valid_invalid_bit[fifo_head_pos] = `DATA_VALID;\n\t\t\t\t\t\t\t\t\tif(fifo_head_pos == NUM_ENTRIES-1)\n\t\t\t\t\t\t\t\t\t\tfifo_head_pos = 0;\n\t\t\t\t\t\t\t\t\telse\t\n\t\t\t\t\t\t\t\t\t\tfifo_head_pos = fifo_head_pos + 1'b1;\n\t\t\t\t\t\t\t\tend \nend\n\t\t\t\t\tdefault: data_out = 'bx;\n\t\t\t\tendcase\n\t\tend\t\t\nend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_asr_75a76c07", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_ff_asr (\n    input D,\n    input S,\n    input R,\n    input CLK,\n    output Q\n);\n\n    reg Q_int;\n\n    always @(posedge CLK) begin\n        if (S) begin\n            Q_int <= 1;\n        end else if (R) begin\n            Q_int <= 0;\n        end else begin\n            Q_int <= D;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unknown_module_83195eab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule\n\ttimer#(\n\t\tparameter\n\t\tCOUNTER_WIDTH = 25,\n\t\tCEILING_WIDTH = 4\n\t)(\n\t\tinput  wire                    clk_in,\n\t\tinput  wire[CEILING_WIDTH-1:0] ceiling_in,\n\t\toutput reg                     tick_out\n\t);\n\n\tlocalparam TOP_BIT = 2**CEILING_WIDTH - 1;\n\tfunction[TOP_BIT:0] reverse(input[COUNTER_WIDTH:0] fwd);\n\t\tinteger i;\n\t\tfor ( i = 0; i <= TOP_BIT; i = i + 1 )\n\t\t\treverse[i] = fwd[COUNTER_WIDTH-i];\n\tendfunction\n\treg[COUNTER_WIDTH:0] count_next, count = 0;\n\twire[TOP_BIT:0] revCount;\n\n\talways @(posedge clk_in)\n\t\tcount <= count_next;\n\n\tassign revCount = reverse(count);\n\t\n\talways @*\n\tbegin\n\t\tif ( revCount[ceiling_in] == 1'b0 )\n\t\t\tbegin\n\t\t\t\tcount_next = count + 1'b1;\n\t\t\t\ttick_out = 1'b0;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tcount_next = 0;\n\t\t\t\ttick_out = 1'b1;\n\t\t\tend\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MaquinaDeControl_7d3cdf47", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MaquinaDeControl(\n    input Clock,\n    input Reset,\n    input NewScanCode,\n    input NewAscii,\n    output reg LoadDato,\n    output reg LoadChar,\n    output reg ScanCodeType\n);\n\nreg [1:0] state;\nparameter Sleep = 3'h0;\nparameter Recibido = 3'h1;\nparameter Type = 3'h3;\nparameter New = 3'h2;\n\nalways @(posedge Clock or negedge Reset) begin\n    if (!Reset) begin\n        state <= Sleep;\n    end else begin\n        case (state)\n            Sleep: begin\n                if (NewScanCode) begin\n                    state <= Recibido;\n                end else begin\n                    state <= Sleep;\n                end\n            end\n            Recibido: begin\n                state <= Type;\n            end\n            Type: begin\n                if (NewAscii && !Reset) begin\n                    state <= New;\n                end else if (!NewAscii || Reset) begin\n                    state <= Sleep;\n                end\n            end\n            New: begin\n                state <= Sleep;\n            end\n            default: begin\n                state <= Sleep;\n            end\n        endcase\n    end\nend\n\nalways @(state) begin\n    case (state)\n        Sleep: begin\n            LoadDato <= 0;\n            LoadChar <= 0;\n            ScanCodeType <= 0;\n        end\n        Recibido: begin\n            LoadDato <= 1;\n            LoadChar <= 0;\n            ScanCodeType <= 0;\n        end\n        Type: begin\n            LoadDato <= 0;\n            LoadChar <= 0;\n            ScanCodeType <= 1;\n        end\n        New: begin\n            LoadDato <= 0;\n            LoadChar <= 1;\n            ScanCodeType <= 0;\n        end\n        default: begin\n            LoadDato <= 0;\n            LoadChar <= 0;\n            ScanCodeType <= 0;\n        end\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_ripple_carry_adder_674e4871", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipelined_ripple_carry_adder (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] S,\n    output reg V\n);\n\nreg [3:0] P1_S, P2_S, P3_S;\nreg P1_C, P2_C, P3_C;\n\nalways @(posedge clk) begin\n    // Pipeline stage 1\n    P1_S <= A + B + Cin;\n    P1_C <= (A[0] & B[0]) | ((A[0] | B[0]) & Cin);\n    \n    // Pipeline stage 2\n    P2_S <= P1_S;\n    P2_C <= (P1_S[0] & P1_C) | ((P1_S[0] | P1_C) & P1_S[1]);\n    \n    // Pipeline stage 3\n    P3_S <= P2_S;\n    P3_C <= (P2_S[1] & P2_C) | ((P2_S[1] | P2_C) & P2_S[2]);\n    \n    // Output stage\n    S <= P3_S;\n    V <= P3_C;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM_Bola_86fbf6d3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule FSM_Bola(clock, reset, start_ball, busy_ball,actualizar_bola,revisar_bordes_bola);\n\t\n\tinput clock, reset, start_ball;\n\toutput busy_ball;\n\toutput reg actualizar_bola, revisar_bordes_bola;\n\t\n\treg [2:0] state;\n\t\n\tparameter STATE_0 = 0;\n\tparameter STATE_1 = 1;\n\tparameter STATE_2 = 2;\n\tparameter STATE_3 = 3;\n\t\n\tinitial\n\t\tbegin\n\t\t\tstate <= STATE_0;\n\t\t\tactualizar_bola <= 1'b0;\n\t\t\trevisar_bordes_bola <= 1'b0;\n\t\tend\n\t\n\talways@(posedge clock or posedge reset)\n\tbegin\n\t\tif(reset)\n\t\t\tbegin\n\t\t\t\tstate <= STATE_0;\n\t\t\t\tactualizar_bola <= 1'b0;\n\t\t\t\trevisar_bordes_bola <= 1'b0;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tcase(state)STATE_0: begin\n\t\t\t\t\t\t\tif (start_ball)\n\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\tstate <= STATE_1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tSTATE_1: begin\n\t\t\t\t\t\t\tactualizar_bola <= 1'b1;\n\t\t\t\t\t\t\tstate <= STATE_2;\n\t\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tSTATE_2: begin\t\t\t\n\t\t\t\t\t\t\tactualizar_bola <= 1'b0;\n\t\t\t\t\t\t\trevisar_bordes_bola <= 1'b1;\n\t\t\t\t\t\t\tstate <= STATE_3;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\tSTATE_3:\n\t\t\t\t\t\tbegin\t\t\t\n\t\t\t\t\t\t\trevisar_bordes_bola <= 1'b0;\n\t\t\t\t\t\t\tstate <= STATE_0;\n\t\t\t\t\t\tend\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tstate <= STATE_0;\n\t\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\tend\n\t\n\tassign busy_ball = !(state == STATE_0);\n\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_5440a7a4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    empty,\n    full,\n    q,\n    usedw\n);\n\ninput aclr;\ninput clock;\ninput [29:0] data;\ninput rdreq;\ninput wrreq;\noutput empty;\noutput full;\noutput [29:0] q;\noutput [4:0] usedw;\n\nreg [29:0] mem [31:0];\nreg [4:0] usedw_reg;\nreg empty_reg;\nreg full_reg;\nreg [29:0] q_reg;\nreg [4:0] write_ptr_reg;\nreg [4:0] read_ptr_reg;\n\nalways @(posedge clock) begin\n    if (aclr == 1'b0) begin\n        // Asynchronous clear\n        empty_reg <= 1'b1;\n        full_reg <= 1'b0;\n        usedw_reg <= 5'b00000;\n        q_reg <= 30'b0;\n        write_ptr_reg <= 5'b00000;\n        read_ptr_reg <= 5'b00000;\n    end else begin\n        // Write operation\n        if (wrreq == 1'b1 && full_reg == 1'b0) begin\n            mem[write_ptr_reg] <= data;\n            write_ptr_reg <= write_ptr_reg + 1;\n            usedw_reg <= usedw_reg + 1;\n            if (write_ptr_reg == 5'b11111) begin\n                write_ptr_reg <= 5'b00000;\n            end\n            if (usedw_reg == 5'b10000) begin\n                full_reg <= 1'b1;\n            end\n            empty_reg <= 1'b0;\n        end\n        // Read operation\n        if (rdreq == 1'b1 && empty_reg == 1'b0) begin\n            q_reg <= mem[read_ptr_reg];\n            read_ptr_reg <= read_ptr_reg + 1;\n            usedw_reg <= usedw_reg - 1;\n            if (read_ptr_reg == 5'b11111) begin\n                read_ptr_reg <= 5'b00000;\n            end\n            if (usedw_reg == 5'b00000) begin\n                empty_reg <= 1'b1;\n            end\n            full_reg <= 1'b0;\n        end\n    end\nend\n\nassign empty = empty_reg;\nassign full = full_reg;\nassign q = q_reg;\nassign usedw = usedw_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_a2156aea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter(\n    input [7:0] in,\n    input [2:0] shift,\n    output [7:0] out\n);\n\nwire [7:0] shifted;\n\nassign shifted = (shift[2]) ? 8'b0 : (shift[1]) ? {in[0], in[7:1]} : (shift[0]) ? {in[1:0], in[7:2]} : {in[2:0], in[7:3]};\n\nassign out = shifted;\n\nendmodule\n\n\nmodule binary_tree_adder(\n    input [7:0] in,\n    output [7:0] out\n);\n\nwire [7:0] sum;\n\nassign sum[0] = in[0];\n\nassign sum[1] = in[0] + in[1];\n\nassign sum[2] = in[2] + in[3];\n\nassign sum[3] = in[0] + in[1] + in[2] + in[3];\n\nassign sum[4] = in[4] + in[5];\n\nassign sum[5] = in[4] + in[5] + in[6] + in[7];\n\nassign sum[6] = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7];\n\nassign out = sum[6];\n\nendmodule\n\n\nmodule addictive_control_logic(\n    input [7:0] in,\n    input select,\n    output [7:0] out\n);\n\nwire [7:0] shifted;\nwire [7:0] sum;\n\nbarrel_shifter bs(\n    .in(in),\n    .shift({select, 2'b00}),\n    .out(shifted)\n);\n\nbinary_tree_adder bta(\n    .in(in),\n    .out(sum)\n);\n\nassign out = (select) ? sum : shifted;\n\nendmodule\n\n\nmodule top_module( \n    input [7:0] in,\n    input select,\n    output [7:0] out\n);\n\naddictive_control_logic acl(\n    .in(in),\n    .select(select),\n    .out(out)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PIO_TO_CTRL_b7ee329a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule PIO_TO_CTRL    (\n\n                        clk,\n                        rst_n,\n\n                        req_compl_i,\n                        compl_done_i,\n\n                        cfg_to_turnoff,\n                        cfg_turnoff_ok\n\n                        );\n\n    input               clk;\n    input               rst_n;\n\n    input               req_compl_i;\n    input               compl_done_i;\n\n    input               cfg_to_turnoff;\n    output              cfg_turnoff_ok;\n\n    reg                 trn_pending;\n    reg                 cfg_turnoff_ok;\n\n\n   always @ ( posedge clk or negedge rst_n ) begin\n\n        if (!rst_n ) begin\n\n          trn_pending <= 0;\n\n        end else begin\n\n          if (!trn_pending && req_compl_i)\n\n            trn_pending <= 1'b1;\n\n          else if (compl_done_i)\n\n            trn_pending <= 1'b0;\n\n        end\n\n    end\n\n    always @ ( posedge clk or negedge rst_n ) begin\n\n      if (!rst_n ) begin\n\n        cfg_turnoff_ok <= 1'b0;\n\n      end else begin\n\n        if ( cfg_to_turnoff  && !trn_pending)\n          cfg_turnoff_ok <= 1'b1;\n        else\n          cfg_turnoff_ok <= 1'b0;\n\n      end\n\n    end\n\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FIFO_image_filter_img_4_cols_V_shiftReg_ce4ba415", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FIFO_image_filter_img_4_cols_V_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 32'd12;\nparameter ADDR_WIDTH = 32'd2;\nparameter DEPTH = 32'd3;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\n    begin\n        if (ce)\n        begin\n            for (i=0;i<DEPTH-1;i=i+1)\n                SRL_SIG[i+1] <= SRL_SIG[i];\n            SRL_SIG[0] <= data;\n        end\n    end\n\nassign q = SRL_SIG[a];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM_INPUT_ENABLE_4ab1e80a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule FSM_INPUT_ENABLE(\n\tinput wire clk,\n\tinput wire rst,\n\tinput wire init_OPERATION,\n\n\toutput reg enable_input_internal,\n\toutput wire enable_Pipeline_input,\n\toutput reg enable_shift_reg\n\n    );\n\n\nparameter [3:0] State0 = 3'd0,\n\n\tState1 = 3'd1,\n\n\tState2 = 3'd2,\n\n\tState3 = 3'd3,\n\n\tState4 = 3'd4,\n\n\tState5= 3'd5,\n\n\tState6 = 3'd6,\n\n\tState7 = 3'd7;\n\n\nreg [2:0] state_reg, state_next;\n\nalways @(posedge clk, posedge rst)\n\tif(rst)\n\t\tstate_reg <= State0;\n\telse\n\t\tstate_reg <= state_next;\n\nalways @*\n\tbegin\n\t\t\tstate_next = state_reg; enable_input_internal=1; enable_shift_reg = 0;\n\tcase(state_reg)\n\n\t\tState0:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=1;\n\t\t\t\tenable_shift_reg = 0;\n\t\t\t\tif(init_OPERATION)\n\t\t\t\t\tstate_next = State1; else begin\n\t\t\t\t\tstate_next = State0; end\n\n\t\t\tend\n\n\t\tState1:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=1;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State2;\n\t\t\tend\n\n\t\tState2:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=1;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State3;\n\t\t\tend\n\n\t\tState3:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=0;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State4;\n\t\t\tend\n\n\t\tState4:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=0;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State5;\n\t\t\tend\n\n\t\tState5:\n\t\t\tbegin\n\t\t\t\tenable_input_internal=0;\n\t\t\t\tenable_shift_reg = 1;\n\t\t\t\tstate_next = State0;\n\t\t\tend\n\n\t\tdefault:\n\t\t\tbegin\n\t\t\t\tstate_next =State0;\n\n\t\t\tend\n\tendcase\nend\n\n\nassign  enable_Pipeline_input = enable_input_internal & init_OPERATION;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alupipe_6190c0c7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule alupipe(S, abus, bbus, clk, Cin, dbus);\n  input [31:0] abus;\n  input [31:0] bbus;\n  input clk;\n  input [2:0] S;\n  input Cin;\n  output [31:0] dbus;\n  wire [31:0] aInput;wire [31:0] bInput;wire [31:0] dInput;alu32 ALU(.a(aInput), .b(bInput), .Cin(Cin), .d(dInput), .S(S));\n  DflipFlop AFF(.dataIn(abus), .dataOut(aInput), .clk(clk));\n  DflipFlop BFF(.dataIn(bbus), .dataOut(bInput), .clk(clk));\n  DflipFlop DFF(.dataIn(dInput), .dataOut(dbus), .clk(clk));\n  \nendmodule\nmodule DflipFlop(dataIn, clk, dataOut);\n  input [31:0] dataIn;\n  input clk;\n  output [31:0] dataOut;\n  reg [31:0] dataOut;\n  always @(posedge clk) begin\n    dataOut = dataIn;\n  end\nendmodule\n\nmodule alu32 (d, Cout, V, a, b, Cin, S);\n  output[31:0] d;output Cout, V;input [31:0] a, b;input Cin;input [2:0] S;wire [31:0] c, g, p;\n  wire gout, pout;\n  \n  alu_cell mycell[31:0] (\n     .d(d),\n     .g(g),\n     .p(p),\n     .a(a),\n     .b(b),\n     .c(c),\n     .S(S)\n  );\n  \n  lac5 lac(\n     .c(c),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(g),\n     .p(p)\n  );\n  \n  overflow ov(\n     .Cout(Cout),\n     .V(V),\n     .g(gout),\n     .p(pout),\n     .c31(c[31]),\n     .Cin(Cin)\n  );\nendmodule\n\nmodule alu_cell (d, g, p, a, b, c, S);\n  output d, g, p;\n  input a, b, c;\n  input [2:0] S;\n  reg g,p,d,cint,bint;\n  \n  always @(a,b,c,S,p,g) begin \n    bint = S[0] ^ b;\n    g = a & bint;\n    p = a ^ bint;\n    cint = S[1] & c;\n   \n  if(S[2]==0)\n    begin\n      d = p ^ cint;\n    end\n    \n  else if(S[2]==1)\n    begin\n      if((S[1]==0) & (S[0]==0)) begin\n        d = a | b;\n      end\n      else if ((S[1]==0) & (S[0]==1)) begin\n        d = ~(a|b);\n      end\n      else if ((S[1]==1) & (S[0]==0)) begin\n        d = a&b;\n      end\n      else\n        d = 1;\n      end\n    end\nendmodule\n\nmodule overflow (Cout, V, g, p, c31, Cin);\n  output Cout, V;\n  input g, p, c31, Cin;\n  \n  assign Cout = g|(p&Cin);\n  assign V = Cout^c31;\nendmodule\n\nmodule lac(c, gout, pout, Cin, g, p);\n  output [1:0] c;\n  output gout;\n  output pout;\n  input Cin;\n  input [1:0] g;\n  input [1:0] p;\n\n  assign c[0] = Cin;\n  assign c[1] = g[0] | ( p[0] & Cin );\n  assign gout = g[1] | ( p[1] & g[0] );\n  assign pout = p[1] & p[0];\n  \nendmodule\n\nmodule lac2 (c, gout, pout, Cin, g, p);\n  output [3:0] c;\n  output gout, pout;\n  input Cin;\n  input [3:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac leaf0(\n     .c(c[1:0]),\n     .gout(gint[0]),\n     .pout(pint[0]),\n     .Cin(cint[0]),\n     .g(g[1:0]),\n     .p(p[1:0])\n  );\n  \n  lac leaf1(\n     .c(c[3:2]),\n     .gout(gint[1]),\n     .pout(pint[1]),\n     .Cin(cint[1]),\n     .g(g[3:2]),\n     .p(p[3:2])\n  );\n  \n  lac root(\n     .c(cint),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(gint),\n     .p(pint)\n  );\nendmodule\n\nmodule lac3 (c, gout, pout, Cin, g, p);\n  output [7:0] c;\n  output gout, pout;\n  input Cin;\n  input [7:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac2 leaf0(\n     .c(c[3:0]),\n     .gout(gint[0]),\n     .pout(pint[0]),\n     .Cin(cint[0]),\n     .g(g[3:0]),\n     .p(p[3:0])\n  );\n  \n  lac2 leaf1(\n     .c(c[7:4]),\n     .gout(gint[1]),\n     .pout(pint[1]),\n     .Cin(cint[1]),\n     .g(g[7:4]),\n     .p(p[7:4])\n  );\n  \n  lac root(\n     .c(cint),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(gint),\n     .p(pint)\n  );\nendmodule\n\nmodule lac4 (c, gout, pout, Cin, g, p);\n  output [15:0] c;\n  output gout, pout;\n  input Cin;\n  input [15:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac3 leaf0(\n      .c(c[7:0]),\n      .gout(gint[0]),\n      .pout(pint[0]),\n      .Cin(cint[0]),\n      .g(g[7:0]),\n      .p(p[7:0])\n  );\n  \n  lac3 leaf1(\n      .c(c[15:8]),\n      .gout(gint[1]),\n      .pout(pint[1]),\n      .Cin(cint[1]),\n      .g(g[15:8]),\n      .p(p[15:8])\n  );\n  \n  lac root(\n  .c(cint),\n  .gout(gout),\n  .pout(pout),\n  .Cin(Cin),\n  .g(gint),\n  .p(pint)\n  );\nendmodule\n\nmodule lac5 (c, gout, pout, Cin, g, p);\n  output [31:0] c;\n  output gout, pout;\n  input Cin;\n  input [31:0] g, p;\n  \n  wire [1:0] cint, gint, pint;\n  \n  lac4 leaf0(\n      .c(c[15:0]),\n      .gout(gint[0]),\n      .pout(pint[0]),\n      .Cin(cint[0]),\n      .g(g[15:0]),\n      .p(p[15:0])\n  );\n  \n  lac4 leaf1(\n      .c(c[31:16]),\n      .gout(gint[1]),\n      .pout(pint[1]),\n      .Cin(cint[1]),\n      .g(g[31:16]),\n      .p(p[31:16])\n  );\n  \n  lac root(\n     .c(cint),\n     .gout(gout),\n     .pout(pout),\n     .Cin(Cin),\n     .g(gint),\n     .p(pint)\n  );\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__a21bo_b2f1f06e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__a21bo (\n    X   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    wire nand0_out  ;\n    wire nand1_out_X;\n\n    nand nand0 (nand0_out  , A2, A1         );\n    nand nand1 (nand1_out_X, B1_N, nand0_out);\n    buf  buf0  (X          , nand1_out_X    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cmac_padding_a4b4175f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule cmac_padding(\n  input [6:0] length,\n  input [127:0] block_in,\n  output [127:0] block_out\n);\n\n  reg [127:0] mask;\n  reg [127:0] masked_data;\n  reg [127:0] padded_data;\n\n  // Generate bitmask used to add zeros to part of block not being data.\n  always @(*)\n  begin\n    mask = 127'b0;\n    if (length[0])\n      mask = {1'b1, mask[127:1]};\n    if (length[1])\n      mask = {2'h3, mask[127:2]};\n    if (length[2])\n      mask = {4'hf, mask[127:4]};\n    if (length[3])\n      mask = {8'hff, mask[127:8]};\n    if (length[4])\n      mask = {16'hffff, mask[127:16]};\n    if (length[5])\n      mask = {32'hffffffff, mask[127:32]};\n    if (length[6])\n      mask = {64'hffffffff_ffffffff, mask[127:64]};\n  end\n\n  // Pad the block by setting the first non-data bit after the data to 1.\n  always @(*)\n  begin\n    masked_data = block_in & mask;\n    padded_data = masked_data;\n    padded_data[(127 - length)] = 1'b1;\n  end\n\n  assign block_out = padded_data;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hs__nand4_3d9c6b6f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hs__nand4(\n    input A,\n    input B,\n    input C,\n    input D,\n    input VPWR,\n    input VGND,\n    output Y\n);\n\n    // Create internal signals\n    wire nand1;\n    wire nand2;\n    wire nand3;\n\n    // Implement NAND gate\n    assign nand1 = ~(A & B);\n    assign nand2 = ~(C & D);\n    assign nand3 = ~(nand1 & nand2);\n    assign Y = nand3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_bc3f7fd6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator (\n    input [15:0] A,\n    input [15:0] B,\n    output reg out\n);\n\n    always @(*) begin\n        if (A > B) begin\n            out = 1'b1;\n        end else if (A < B) begin\n            out = 1'b0;\n        end else begin\n            out = 1'b0;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FB_RejectArmController_039ae765", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define STATE_Clear 0\n`define STATE_AwaitCanister 1\n`define STATE_GoReject 2\n\n\nmodule FB_RejectArmController \n\n(\n\t\tinput wire clk,\n\t\t\n\t\tinput wire RejectCanister_eI,\n\t\tinput wire LasersChanged_eI,\n\t\t\n\t\toutput wire GoRejectArm_eO,\n\t\t\n\t\tinput wire  RejectSiteLaser_I,\n\t\t\n\t\t\n\n\t\tinput reset\n);\n\n\nwire RejectCanister;\nassign RejectCanister = RejectCanister_eI;\nwire LasersChanged;\nassign LasersChanged = LasersChanged_eI;\n\nreg GoRejectArm;\nassign GoRejectArm_eO = GoRejectArm;\n\nreg  RejectSiteLaser ;\n\n\nreg [1:0] state = `STATE_Clear;\nreg entered = 1'b0;\nalways@(posedge clk) begin\n\n\tif(reset) begin\n\t\tstate = `STATE_Clear;\n\n\t\tGoRejectArm = 1'b0;\n\t\t\n\t\tRejectSiteLaser = 0;\n\t\t\n\t\tend else begin\n\n\t\tGoRejectArm = 1'b0;\n\t\t\n\t\tif(LasersChanged) begin \n\t\t\tRejectSiteLaser = RejectSiteLaser_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tentered = 1'b0;\n\t\tcase(state) \n\t\t\t`STATE_Clear: begin\n\t\t\t\tif(RejectCanister) begin\n\t\t\t\t\tstate = `STATE_AwaitCanister;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\t`STATE_AwaitCanister: begin\n\t\t\t\tif(LasersChanged && RejectSiteLaser) begin\n\t\t\t\t\tstate = `STATE_GoReject;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\t`STATE_GoReject: begin\n\t\t\t\tif(RejectCanister) begin\n\t\t\t\t\tstate = `STATE_AwaitCanister;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\tdefault: begin\n\t\t\t\tstate = 0;\n\t\t\tend\n\t\tendcase\n\t\tif(entered) begin\n\t\t\tcase(state)\n\t\t\t\t`STATE_Clear: begin\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\t`STATE_AwaitCanister: begin\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\t`STATE_GoReject: begin\n\t\t\t\t\tGoRejectArm = 1'b1;\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\tdefault: begin\n\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\tend\nend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "i2s_tx #_7e585892", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule i2s_tx #(parameter DATA_WIDTH = 16\n\t\t\t\t) (clk, left_chan, right_chan, sdata, lrclk, mck, sck);\n\ninput wire clk; input wire [DATA_WIDTH-1:0] left_chan;\ninput wire [DATA_WIDTH-1:0] right_chan;\noutput reg sdata; initial sdata <= 1'b0;\n\noutput wire mck, sck, lrclk;\nreg [9:0]  mck_div; initial mck_div<=10'd0;\n\n\n\nparameter LR_BIT = 7; parameter SCK_BIT = LR_BIT - 6; parameter MCK_BIT = 0;\n\n\nassign mck   = mck_div[MCK_BIT];\nassign lrclk = mck_div[LR_BIT];\nassign sck   = mck_div[SCK_BIT];\n\nreg lrclk_prev; initial lrclk_prev <= 1'b1;\nwire lrclk_change = ~(lrclk_prev == lrclk);\nreg [DATA_WIDTH-1:0] ch_data; initial ch_data <= {DATA_WIDTH{1'b0}};\nreg sck_prev; initial sck_prev <= 1'b0;\nwire sck_neg = (sck_prev==1'b1 && sck==1'b0);\n\nreg [31:0] fake_data; initial fake_data <= 32'd0;\nwire [31:0] sgnd_data = fake_data - 32'b10000000000000000000000000000000;always @(posedge clk) begin\n\tmck_div <= mck_div + 1'b1;\n\tlrclk_prev <= lrclk;\n\tsck_prev <= sck;\n\t\n\tif (sck_neg) begin\n\t\tif (lrclk_change) begin\n\t\t\tch_data <= sgnd_data;\n\t\t\tfake_data <= fake_data + 32'd178956972; end else begin\n\t\t\tch_data <= ch_data << 1;\n\t\tend\n\t\tsdata <= ch_data[DATA_WIDTH-1];\n\tend\n\t\n\t\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Concat_1883d4cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Concat(\n    input clock,\n    input ready,\n\n\toutput reg  listA_req,\n    input       listA_ack,\n    input [7:0] listA_value,\n    input       listA_value_valid,\n\n\toutput reg  listB_req,\n    input       listB_ack,\n    input [7:0] listB_value,\n    input       listB_value_valid,\n\n\tinput            req,\n\toutput reg       ack,\n\toutput reg [7:0] value,\n\toutput reg       value_valid\n    );\n\n    reg lastSelectA;\n    wire selectA;\n    assign selectA = lastSelectA & (listA_ack ? listA_value_valid : 1'b1);\n\n    always @(posedge clock) begin\n        if(ready)\n            lastSelectA <= selectA;\n        else\n            lastSelectA <= 1;\n    end\n\n    always @(*) begin\n        if(selectA) begin\n            listA_req = req;\n            ack = listA_ack;\n            value = listA_value;\n            value_valid = listA_value_valid;\n            listB_req = 0;\n\n        end else begin\n            listB_req = req;\n            ack = listB_ack;\n            value = listB_value;\n            value_valid = listB_value_valid;\n            listA_req = 0;\n        end\n    end\nendmodule\n\nmodule Cons(\n    input clock,\n    input ready,\n    input [7:0] head,\n\n\toutput reg  tail_req,\n    input       tail_ack,\n    input [7:0] tail_value,\n    input       tail_value_valid,\n\n\tinput            req,\n\toutput reg       ack,\n\toutput reg [7:0] value,\n    output reg       value_valid\n    );\n\n    reg headShown;\n    reg selectHead;\n    reg lastReq;\n    reg headAck;\n\n    always @(posedge clock) begin\n        lastReq <= req;\n\n        if(ready) begin\n            if(~lastReq & req) begin\n                headAck <= 1;\n                headShown <= 1;\n\n                if(headShown)\n                    selectHead <= 0;\n\n            end else begin\n                headAck <= 0;\n            end\n\n        end else begin\n            headShown <= 0;\n            selectHead <= 1;\n            headAck <= 0;\n        end\n    end\n\n    always @(*) begin\n        if(selectHead) begin\n            ack = headAck;\n            value = head;\n            value_valid = 1;\n            tail_req = 0;\n\n        end else begin\n            tail_req = req;\n            ack = tail_ack;\n            value = tail_value;\n            value_valid = tail_value_valid;\n        end\n    end\nendmodule\n\nmodule Hold(\n    input clock,\n    input ready,\n    input x,\n    output reg y\n    );\n\n    always @(posedge clock)\n        y <= ready ? y | x : 0;\nendmodule\n\nmodule ListMux(\n    input ready,\n    input cond,\n    input            out_req,\n    output reg       out_ack,\n    output reg [7:0] out_value,\n    output reg       out_value_valid,\n\n    output reg       true_req,\n    input            true_ack,\n    input [7:0]      true_value,\n    input            true_value_valid,\n\n    output reg       false_req,\n    input            false_ack,\n    input [7:0]      false_value,\n    input            false_value_valid\n    );\n\n    always @(*) begin\n        if(~ready) begin\n            true_req = 1'b0;\n            false_req = 1'b0;\n            out_ack = 1'b0;\n            out_value = 8'hFF;\n            out_value_valid = 1'b0;\n\n        end else if(cond) begin\n            true_req = out_req;\n            out_ack = true_ack;\n            out_value = true_value;\n            out_value_valid = true_value_valid;\n\n            false_req = 1'b0;\n\n        end else begin\n            false_req = out_req;\n            out_ack = false_ack;\n            out_value = false_value;\n            out_value_valid = false_value_valid;\n\n            true_req = 1'b0;\n        end\n    end\nendmodule\n\nmodule Decons(\n    input clock,\n    input ready,\n    output reg  done,\n\n\toutput reg  list_req,\n    input       list_ack,\n    input [7:0] list_value,\n    input       list_value_valid,\n\n    output reg [7:0] head,\n    output reg       head_valid,\n\n\tinput            tail_req,\n\toutput reg       tail_ack,\n\toutput reg [7:0] tail_value,\n    output reg       tail_value_valid\n    );\n\n    reg nextDone;\n\n    always @(posedge clock) begin\n        if(ready) begin\n            done <= done | nextDone;\n\n            if(~done & list_ack) begin\n                nextDone <= 1'b1;\n                head <= list_value;\n                head_valid <= list_value_valid;\n            end else begin\n                nextDone <= 1'b0;\n            end\n\n        end else begin\n            done <= 1'b0;\n            nextDone <= 1'b0;\n            head <= 8'hFF;\n            head_valid = 1'b0;\n        end\n    end\n\n    always @(*) begin\n        list_req = ready & ~done;\n\n        if(done) begin\n            list_req = tail_req;\n            tail_ack = list_ack;\n            tail_value = list_value;\n            tail_value_valid = list_value_valid;\n        end else begin\n            list_req = ready & ~nextDone;\n            tail_ack = 1'b0;\n            tail_value = 8'hFF;\n            tail_value_valid = 1'b0;\n        end\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_de40ece4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder (\n    input [1:0] SEL,\n    output reg [15:0] OUT\n);\n\n    always @(*) begin\n        case(SEL)\n            2'b00: OUT = 16'b0000000000000001;\n            2'b01: OUT = 16'b0000000000000010;\n            2'b10: OUT = 16'b0000000000000100;\n            2'b11: OUT = 16'b0000000000001000;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AGC_9b609e7b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule AGC (\n  input [15:0] input_signal,\n  input [7:0] control_signal,\n  output [15:0] output_signal\n);\n\nparameter gain_bits = 8; // number of bits used to represent the gain value\n\nreg [gain_bits-1:0] gain_value; // binary value representing the gain\nreg [15:0] adjusted_signal; // signal with constant output level\n\n// Function to adjust the gain based on the control signal\nfunction [gain_bits-1:0] adjust_gain;\n  input [7:0] control;\n  begin\n    case (control)\n      8'h00: adjust_gain = 8'h00; // no gain adjustment\n      8'h01: adjust_gain = 8'h01; // small gain increase\n      8'h02: adjust_gain = 8'h02;\n      8'h03: adjust_gain = 8'h03;\n      8'h04: adjust_gain = 8'h04;\n      8'h05: adjust_gain = 8'h05;\n      8'h06: adjust_gain = 8'h06;\n      8'h07: adjust_gain = 8'h07;\n      8'h08: adjust_gain = 8'h08; // maximum gain increase\n      8'h09: adjust_gain = 8'h09; // no gain adjustment\n      8'h0A: adjust_gain = 8'h0A;\n      8'h0B: adjust_gain = 8'h0B;\n      8'h0C: adjust_gain = 8'h0C;\n      8'h0D: adjust_gain = 8'h0D;\n      8'h0E: adjust_gain = 8'h0E;\n      8'h0F: adjust_gain = 8'h0F;\n      8'h10: adjust_gain = 8'h10; // maximum gain reduction\n      8'h11: adjust_gain = 8'h11; // no gain adjustment\n      8'h12: adjust_gain = 8'h12;\n      8'h13: adjust_gain = 8'h13;\n      8'h14: adjust_gain = 8'h14;\n      8'h15: adjust_gain = 8'h15;\n      8'h16: adjust_gain = 8'h16;\n      8'h17: adjust_gain = 8'h17;\n      8'h18: adjust_gain = 8'h18; // small gain reduction\n      default: adjust_gain = 8'h00; // no gain adjustment\n    endcase\n  end\nendfunction\n\n// Assign the gain value based on the control signal\nalways @ (control_signal) begin\n  gain_value = adjust_gain(control_signal);\nend\n\n// Compute the adjusted signal with constant output level\nalways @ (input_signal, gain_value) begin\n  adjusted_signal = input_signal * gain_value;\nend\n\n// Assign the output signal\nassign output_signal = adjusted_signal;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dffr_a7bbd5c3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dffr (din, clk, rst, q, se, si, so);\n\nparameter SIZE = 1;\n\ninput\t[SIZE-1:0]\tdin ;\t// data in\ninput\t\t\tclk ;\t// clk or scan clk\ninput\t\t\trst ;\t// reset\n\noutput\t[SIZE-1:0]\tq ;\t// output\n\ninput\t\t\tse ;\t// scan-enable\ninput\t[SIZE-1:0]\tsi ;\t// scan-input\noutput\t[SIZE-1:0]\tso ;\t// scan-output\n\nreg \t[SIZE-1:0]\tq ;\n\nalways @ (posedge clk)\n\tif (se) begin\n\t\tq[SIZE-1:0] <= si[SIZE-1:0];\n\tend else begin\n\t\tif (rst) begin\n\t\t\tq[SIZE-1:0] <= {SIZE{1'b0}};\n\t\tend else begin\n\t\t\tq[SIZE-1:0] <= din[SIZE-1:0];\n\t\tend\n\tend\n\nassign so[SIZE-1:0] = q[SIZE-1:0] ;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__a50802c2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk, // Clock input\n    input reset, // Synchronous active-high reset\n    input ce, // Clock enable for the counter\n    input ctrl, // Control signal for the counter\n    output reg [11:0] out // 12-bit output from the combined modules\n);\n\nwire [3:0] counter_out;\nwire [15:0] decoder_out;\n\ncounter cnt (\n    .clk(clk),\n    .rst_n(reset),\n    .ce(ce),\n    .ctrl(ctrl),\n    .count(counter_out)\n);\n\ndecoder dec (\n    .SEL(counter_out[1:0]),\n    .OUT(decoder_out)\n);\n\nalways @(*) begin\n    out <= decoder_out[11:0];\nend\n\nendmodule\nmodule counter (\n    input clk,\n    input rst_n,\n    input ce,\n    input ctrl,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge rst_n) begin\n    if (rst_n) begin\n        count <= 4'b0;\n    end else if (ce) begin\n        if (ctrl) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule\nmodule decoder (\n    input [1:0] SEL,\n    output reg [15:0] OUT\n);\n\nalways @(*) begin\n    case (SEL)\n        2'b00: OUT = 16'b0000_0000_0000_0001;\n        2'b01: OUT = 16'b0000_0000_0000_0010;\n        2'b10: OUT = 16'b0000_0000_0000_0100;\n        2'b11: OUT = 16'b0000_0000_0000_1000;\n        default: OUT = 16'b0000_0000_0000_0000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_with_parallel_load_e4c6fd7b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register_with_parallel_load (\n  input clk,\n  input load,\n  input direction,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      q <= data;\n    end else begin\n      if (direction) begin\n        q <= {1'b0, q[511:1]};\n      end else begin\n        q <= {q[510:0], 1'b0};\n      end\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_tx_e0975592", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_tx(\n  input clk,\n  input reset_n,\n  input clk_en,\n  input begintransfer,\n  input tx_wr_strobe,\n  input status_wr_strobe,\n  input do_force_break,\n  input [7:0] tx_data,\n  input [15:0] baud_divisor,\n  output tx_overrun,\n  output tx_ready,\n  output tx_shift_empty,\n  output txd\n);\n\n  reg baud_clk_en;\n  reg [15:0] baud_rate_counter;\n  wire baud_rate_counter_is_zero;\n  reg do_load_shifter;\n  wire do_shift;\n  reg pre_txd;\n  wire shift_done;\n  wire [9:0] tx_load_val;\n  reg tx_overrun;\n  reg tx_ready;\n  reg tx_shift_empty;\n  wire tx_shift_reg_out;\n  wire [9:0] tx_shift_register_contents;\n  wire tx_wr_strobe_onset;\n  reg txd;\n  reg [9:0] unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out;\n  wire [9:0] unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_in;\n\n  assign tx_wr_strobe_onset = tx_wr_strobe && begintransfer;\n  assign tx_load_val = {{1 {1'b1}}, tx_data, 1'b0};\n  assign shift_done = ~(|tx_shift_register_contents);\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      do_load_shifter <= 0;\n    end else if (clk_en) begin\n      do_load_shifter <= (~tx_ready) && shift_done;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      tx_ready <= 1'b1;\n    end else if (clk_en) begin\n      if (tx_wr_strobe_onset) begin\n        tx_ready <= 0;\n      end else if (do_load_shifter) begin\n        tx_ready <= -1;\n      end\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      tx_overrun <= 0;\n    end else if (clk_en) begin\n      if (status_wr_strobe) begin\n        tx_overrun <= 0;\n      end else if (~tx_ready && tx_wr_strobe_onset) begin\n        tx_overrun <= -1;\n      end\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      tx_shift_empty <= 1'b1;\n    end else if (clk_en) begin\n      tx_shift_empty <= tx_ready && shift_done;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      baud_rate_counter <= 0;\n    end else if (clk_en) begin\n      if (baud_rate_counter_is_zero || do_load_shifter) begin\n        baud_rate_counter <= baud_divisor;\n      end else begin\n        baud_rate_counter <= baud_rate_counter - 1;\n      end\n    end\n  end\n\n  assign baud_rate_counter_is_zero = baud_rate_counter == 0;\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      baud_clk_en <= 0;\n    end else if (clk_en) begin\n      baud_clk_en <= baud_rate_counter_is_zero;\n    end\n  end\n\n  assign do_shift = baud_clk_en  && (~shift_done) && (~do_load_shifter);\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      pre_txd <= 1;\n    end else if (~shift_done) begin\n      pre_txd <= tx_shift_reg_out;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      txd <= 1;\n    end else if (clk_en) begin\n      txd <= pre_txd & ~do_force_break;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out <= 0;\n    end else if (clk_en) begin\n      unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out <= unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_in;\n    end\n  end\n\n  assign unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_in = (do_load_shifter)? tx_load_val : (do_shift)? {1'b0, unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out[9 : 1]} : unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out;\n  assign tx_shift_register_contents = unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out;\n  assign tx_shift_reg_out = unxshiftxtx_shift_register_contentsxtx_shift_reg_outxx5_out[0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nios_system_keys_978f0470", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nios_system_keys (\n                          // inputs:\n                           address,\n                           clk,\n                           in_port,\n                           reset_n,\n\n                          // outputs:\n                           readdata\n                        )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  3: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  3: 0] data_in;\n  wire    [  3: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {4 {(address == 0)}} & data_in;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n\n  assign data_in = in_port;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "control_95e7038f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule control(OP, CISEL, BSEL, OSEL, SHIFT_LA, SHIFT_LR, LOGICAL_OP); input  [2:0]  OP;\n\n  output        CISEL;\n\n  output \t\t BSEL;\n\n  output [1:0]\t OSEL;\n\n  output \t\t SHIFT_LA;\n\n  output \t\t SHIFT_LR;\n\n  output \t    LOGICAL_OP;\n\n\n  reg [1:0] OSEL;\n\n  reg SHIFT_LA;\n\n  reg SHIFT_LR;\n\n  reg LOGICAL_OP;\n\n  \n\n  localparam ADD = 3'b000;\n\n  localparam SUB = 3'b001;\n\n  localparam SRA = 3'b010;\n\n  localparam SRL = 3'b011;\n\n  localparam SLL = 3'b100;\n\n  localparam AND = 3'b101;\n\n  localparam OR = 3'b110;\n\n  \n\n  \n\n  assign CISEL = (OP == 3'b001) ? 1'b1 : 1'b0;\n\n  assign BSEL = (OP == 3'b001) ? 1'b1 : 1'b0;\n\n  \n\n  always @(*) begin\n\n\tcase (OP)\n\n\t\tADD: begin \n\n\t\t\t  OSEL = 2'b0;\n\n\t\t\t  SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSUB: begin\n\n\t\t\t  OSEL = 2'b0;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSRA: begin \n\n\t\t     OSEL = 2'b01;\n\n\t\t     SHIFT_LA = 1'b1;\n\n\t\t\t  SHIFT_LR = 1'b1;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSRL: begin \n\n\t\t\t  OSEL = 2'b01;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b1;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tSLL: begin \n\n\t\t\t  OSEL = 2'b01;\n\n\t\t     SHIFT_LA = 1'b1;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tAND: begin \n\n\t\t     OSEL = 2'b10;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b1;\n\n\t\tend\n\n\t\tOR:  begin \n\n\t\t\t  OSEL = 2'b10;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\t\tdefault: begin \n\n\t\t\t  OSEL = 2'b11;\n\n\t\t     SHIFT_LA = 1'b0;\n\n\t\t\t  SHIFT_LR = 1'b0;\n\n\t\t\t  LOGICAL_OP = 1'b0;\n\n\t\tend\n\n\tendcase\n\n  end\n\n  \n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_4to16_ffc28ef4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_4to16 (\n    input [3:0] ABCD,\n    output reg [15:0] Y\n);\n\nalways @(*) begin\n    case (ABCD)\n        4'b0000: Y = 16'b1111_1111_1111_1110;\n        4'b0001: Y = 16'b1111_1111_1111_1101;\n        4'b0010: Y = 16'b1111_1111_1111_1011;\n        4'b0011: Y = 16'b1111_1111_1111_0111;\n        4'b0100: Y = 16'b1111_1111_1110_1111;\n        4'b0101: Y = 16'b1111_1111_1101_1111;\n        4'b0110: Y = 16'b1111_1111_1011_1111;\n        4'b0111: Y = 16'b1111_1111_0111_1111;\n        4'b1000: Y = 16'b1111_1110_1111_1111;\n        4'b1001: Y = 16'b1111_1101_1111_1111;\n        4'b1010: Y = 16'b1111_1011_1111_1111;\n        4'b1011: Y = 16'b1111_0111_1111_1111;\n        4'b1100: Y = 16'b1110_1111_1111_1111;\n        4'b1101: Y = 16'b1101_1111_1111_1111;\n        4'b1110: Y = 16'b1011_1111_1111_1111;\n        4'b1111: Y = 16'b0111_1111_1111_1111;\n        default: Y = 16'b1111_1111_1111_1111;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "t_order_a_caaee7c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule t_order_a (\n   m_from_clk_lev1_r, n_from_clk_lev2, o_from_com_levs11,\n   o_from_comandclk_levs12,\n   clk, a_to_clk_levm3, b_to_clk_levm1, c_com_levs10, d_to_clk_levm2, one\n   );\n\n   input clk;\n   input [7:0] a_to_clk_levm3;\n   input [7:0] b_to_clk_levm1;\n   input [7:0] c_com_levs10;\n   input [7:0] d_to_clk_levm2;\n   input [7:0] one;\n   output [7:0] m_from_clk_lev1_r;\n   output [7:0] n_from_clk_lev2;\n   output [7:0] o_from_com_levs11;\n   output [7:0] o_from_comandclk_levs12;\n\n   \n   reg [7:0]            m_from_clk_lev1_r;\n   wire [7:0] a_to_clk_levm1;\n   wire [7:0] a_to_clk_levm2;\n   wire [7:0] c_com_levs11;\n   reg [7:0]  o_from_comandclk_levs12;\n   wire [7:0]  n_from_clk_lev2;\n   wire [7:0]  n_from_clk_lev3;\n\n   assign     a_to_clk_levm1 = a_to_clk_levm2 + d_to_clk_levm2;\n   assign     a_to_clk_levm2 = a_to_clk_levm3 + 0;\n\n   always @ (posedge clk) begin\n      m_from_clk_lev1_r <= a_to_clk_levm1 + b_to_clk_levm1;\n   end\n\n   assign c_com_levs11 = c_com_levs10 + one;\n   always @ (c_com_levs11 or n_from_clk_lev3) o_from_comandclk_levs12 = c_com_levs11 + n_from_clk_lev3;\n   assign n_from_clk_lev2 = m_from_clk_lev1_r;\n   assign n_from_clk_lev3 = n_from_clk_lev2;\n   wire [7:0] o_from_com_levs11 = c_com_levs10 + 1;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_adder_e5dce54c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule simple_adder (\n  input [3:0] a,\n  input [3:0] b,\n  output [4:0] sum\n);\n\n  assign sum = {1'b0, a} + {1'b0, b};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ram_control_d7fb52a3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ram_control(\n    input clk,\n    input enable,\n    input [11:0] addrA,\n    input [11:0] addrB,\n    input [11:0] addrW,\n    input [8:0] dataIn,\n    output reg [8:0] dataOutA,\n    output reg [8:0] dataOutB\n);\n\nreg [8:0] dataOutA_reg;\nreg [8:0] dataOutB_reg;\n\nreg [8:0] ram [4095:0];\n\nalways @(posedge clk) begin\n    if (enable) begin\n        dataOutA <= ram[addrA];\n        dataOutB <= ram[addrB];\n        ram[addrW] <= dataIn;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_f7d19a27", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux (\n    input [3:0] D,\n    input EN,\n    input [1:0] SEL,\n    output reg Y\n);\n\nalways @ (SEL or D or EN) begin\n    if (EN) begin\n        case (SEL)\n            2'b00: Y = D[0];\n            2'b01: Y = D[1];\n            2'b10: Y = D[2];\n            2'b11: Y = D[3];\n        endcase\n    end else begin\n        Y = 0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mod_operator_57cde7eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mod_operator (\n  input [31:0] A,\n  input [31:0] B,\n  output reg [31:0] result\n);\n\n  always @(*) begin\n    if (B == 0) begin\n      result = 0;\n    end else if (A < B) begin\n      result = A;\n    end else begin\n      result = A - (A / B) * B;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_aac0570a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule memory (remapping_memory, full, rd_data, rd_clk, rd_en, rd_addr, reset);\n\n  parameter RD_DATA_WIDTH = 1;\n  parameter RD_ADDR_WIDTH = 2;\n  parameter MEM_DEPTH = 4;\n  \n  input wire [MEM_DEPTH-1:0] remapping_memory;\n  input wire full;\n  output reg [RD_DATA_WIDTH-1:0] rd_data;\n  input wire rd_clk, rd_en;\n  input wire [RD_ADDR_WIDTH-1:0] rd_addr;\n  input wire reset;\n  \n  reg [RD_DATA_WIDTH-1:0] memory [0:MEM_DEPTH-1];\n  integer i;\n  \n  always @(posedge full, posedge reset) begin\n    if(reset) begin\n      for(i=0; i<MEM_DEPTH; i=i+1) begin\n        memory[i] <= 0;\n      end\n    end else begin\n      for(i=0; i<MEM_DEPTH; i=i+1) begin\n        memory[i] <= remapping_memory[i];\n      end\n    end\n  end\n  \n  always @(posedge rd_clk, posedge reset) begin\n    if(reset) begin\n      rd_data <= 0;\n    end else begin\n      if(rd_en) begin\n        rd_data <= memory[rd_addr];\n      end\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "min_max_tracker_619ed604", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule min_max_tracker(input clk, input [7:0] adc_d, input [7:0] threshold,\n\toutput [7:0] min, output [7:0] max);\n\n\treg [7:0] min_val = 255;\n\treg [7:0] max_val = 0;\n\treg [7:0] cur_min_val = 255;\n\treg [7:0] cur_max_val = 0;\n\treg [1:0] state = 0;\n\n\talways @(posedge clk)\n\tbegin\n\t\tcase (state)\n\t\t0:\n\t\t\tbegin\n\t\t\t\tif (cur_max_val >= ({1'b0, adc_d} + threshold))\n\t\t\t\t\tstate <= 2;\n\t\t\t\telse if (adc_d >= ({1'b0, cur_min_val} + threshold))\n\t\t\t\t\tstate <= 1;\n\t\t\t\tif (cur_max_val <= adc_d)\n\t\t\t\t\tcur_max_val <= adc_d;\n\t\t\t\telse if (adc_d <= cur_min_val)\n\t\t\t\t\tcur_min_val <= adc_d;\t\t\t\t\t\n\t\t\tend\n\t\t1:\n\t\t\tbegin\n\t\t\t\tif (cur_max_val <= adc_d)\n\t\t\t\t\tcur_max_val <= adc_d;\n\t\t\t\telse if (({1'b0, adc_d} + threshold) <= cur_max_val) begin\n\t\t\t\t\tstate <= 2;\n\t\t\t\t\tcur_min_val <= adc_d;\n\t\t\t\t\tmax_val <= cur_max_val;\n\t\t\t\tend\n\t\t\tend\n\t\t2:\n\t\t\tbegin\n\t\t\t\tif (adc_d <= cur_min_val)\n\t\t\t\t\tcur_min_val <= adc_d;\t\t\t\t\t\n\t\t\t\telse if (adc_d >= ({1'b0, cur_min_val} + threshold)) begin\n\t\t\t\t\tstate <= 1;\n\t\t\t\t\tcur_max_val <= adc_d;\n\t\t\t\t\tmin_val <= cur_min_val;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\tassign min = min_val;\n\tassign max = max_val;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "crc #_428f1820", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule crc #(\n  parameter data_size = 8, // size of input data message in bits\n  parameter poly_size = 4, // size of generator polynomial in bits\n  parameter crc_size = poly_size - 1 // size of checksum in bits\n\n) (\n  input clk,\n  input reset,\n  input [data_size-1:0] data_in,\n  input [data_size-1:0] poly,\n  input [data_size-1:0] crc_in,\n  input crc_enable,\n  input check_enable,\n  output [data_size-1:0] crc_out,\n  output match\n);\n\n\nreg [data_size-1:0] data_reg;\nreg [crc_size-1:0] crc_reg;\nreg [crc_size-1:0] crc_calc;\nreg [data_size-1:0] poly_reg;\nreg [crc_size-1:0] crc_check;\n\nwire [crc_size-1:0] crc_remainder;\nwire [crc_size-1:0] crc_check_remainder;\n\nassign crc_remainder = crc_calc[crc_size-1:0] ^ crc_reg;\nassign crc_check_remainder = data_reg[crc_size-1:0] ^ crc_check;\n\nassign crc_out = {data_in, crc_calc};\nassign match = (crc_check_remainder == crc_in);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    data_reg <= 0;\n    crc_reg <= 0;\n    crc_calc <= 0;\n    poly_reg <= poly;\n    crc_check <= crc_in;\n  end else begin\n    data_reg <= data_in;\n    if (crc_enable) begin\n      crc_reg <= crc_calc;\n      crc_calc <= {crc_calc[crc_size-2:0], data_reg, 1'b0} ^ (poly_reg & {crc_calc[crc_size-2:0], 1'b0});\n    end\n    if (check_enable) begin\n      crc_check <= {crc_check[crc_size-2:0], data_reg, 1'b0} ^ (poly_reg & {crc_check[crc_size-2:0], 1'b0});\n    end\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_4fb3e6a9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input rst,\n    input up_down,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0000;\n    end else begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule\n\nmodule seven_segment_display (\n    input [3:0] D_in,\n    output A,\n    output B,\n    output C,\n    output D,\n    output E,\n    output F,\n    output G,\n    output reg [6:0] seg_display\n);\n\nalways @(*) begin\n    case (D_in)\n        4'b0000: seg_display = 7'b1111110; // 0\n        4'b0001: seg_display = 7'b0110000; // 1\n        4'b0010: seg_display = 7'b1101101; // 2\n        4'b0011: seg_display = 7'b1111001; // 3\n        4'b0100: seg_display = 7'b0110011; // 4\n        4'b0101: seg_display = 7'b1011011; // 5\n        4'b0110: seg_display = 7'b1011111; // 6\n        4'b0111: seg_display = 7'b1110000; // 7\n        4'b1000: seg_display = 7'b1111111; // 8\n        4'b1001: seg_display = 7'b1111011; // 9\n        default: seg_display = 7'b0000001; // Error\n    endcase\nend\n\nassign {A, B, C, D, E, F, G} = seg_display;\n\nendmodule\n\nmodule bitwise_or (\n    input [3:0] count,\n    input [6:0] seg_display,\n    output reg [6:0] final_output\n);\n\nalways @(*) begin\n    final_output = count | seg_display;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input rst,\n    input up_down,\n    output A,\n    output B,\n    output C,\n    output D,\n    output E,\n    output F,\n    output G,\n    output  [3:0] count,\n    output  [6:0] seg_display,\n    output  [6:0] final_output\n);\n\nup_down_counter counter (.clk(clk), .rst(rst), .up_down(up_down), .count(count));\nseven_segment_display display (.D_in(count), .A(A), .B(B), .C(C), .D(D), .E(E), .F(F), .G(G), .seg_display(seg_display));\nbitwise_or or_gate (.count(count), .seg_display(seg_display), .final_output(final_output));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_4bit_3afb890e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] S,\n    output reg Cout\n);\n\nreg [4:0] Sum;\n\nalways @* begin\n    Sum = {1'b0, A} + {1'b0, B} + Cin;\n    S = Sum[3:0];\n    Cout = Sum[4];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Timer_83debca3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Timer (\n      input   io_tick,\n      input   io_clear,\n      input  [15:0] io_limit,\n      output  io_full,\n      output [15:0] io_value,\n      input   io_mainClk,\n      input   resetCtrl_systemReset);\n  \n  reg [15:0] counter;\n  wire limitHit;\n  reg inhibitFull;\n  \n  assign limitHit = (counter == io_limit);\n  assign io_full = ((limitHit && io_tick) && (! inhibitFull));\n  assign io_value = counter;\n  \n  always @ (posedge io_mainClk or posedge resetCtrl_systemReset) begin\n    if (resetCtrl_systemReset) begin\n      counter <= 16'b0;\n      inhibitFull <= 1'b0;\n    end else begin\n      if (io_clear) begin\n        counter <= 16'b0;\n        inhibitFull <= 1'b0;\n      end else begin\n        if (io_tick) begin\n          counter <= counter + 1;\n          inhibitFull <= limitHit;\n        end\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register__24217209", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule register_module (\n    input wire [31:0] interface_from_core_fp,\n    input wire mb_reg_rwn,\n    input wire [15:0] mb_reg_select,\n    output reg [31:0] mb_reg_output\n);\n\n    parameter NUMBER_INTERFACE_REGS = 16;\n    parameter MB_REG_START = 3;\n    parameter CMD_REG_0_ADDR = MB_REG_START;\n    parameter CMD_REG_1_ADDR = MB_REG_START+1;\n    parameter CMD_REG_2_ADDR = MB_REG_START+2;\n    parameter CMD_REG_3_ADDR = MB_REG_START+3;\n    parameter CMD_REG_4_ADDR = MB_REG_START+4;\n    parameter CMD_REG_5_ADDR = MB_REG_START+5;\n    parameter CMD_REG_6_ADDR = MB_REG_START+6;\n    parameter CMD_REG_7_ADDR = MB_REG_START+7;\n    parameter CMD_REG_8_ADDR = MB_REG_START+8;\n    parameter CMD_REG_9_ADDR = MB_REG_START+9;\n    parameter CMD_REG_10_ADDR = MB_REG_START+10;\n    parameter MODE_REG_0_ADDR = CMD_REG_8_ADDR;\n    parameter CMD_REG_14_ADDR = 14;\n    parameter CRC_ERROR_REG_ADDR = CMD_REG_14_ADDR;\n    parameter VERSION_REG_ADDR = 15;\n\n    reg [NUMBER_INTERFACE_REGS-1:MB_REG_START] mb_reg_wr;\n    reg [NUMBER_INTERFACE_REGS-1:MB_REG_START] mb_reg_rd;\n    reg [31:0] mb_reg_out_w [NUMBER_INTERFACE_REGS-1:MB_REG_START];\n\n    integer mb_loop;\n    always @(interface_from_core_fp or mb_reg_rwn or mb_reg_select)\n    begin\n        mb_reg_wr <= 'h0;\n        mb_reg_rd <= 'h0;\n        mb_reg_output <= interface_from_core_fp;\n\n        for (mb_loop = MB_REG_START; mb_loop < NUMBER_INTERFACE_REGS; mb_loop = mb_loop + 1)\n        begin\n            if (mb_reg_select[mb_loop] == 1'b1)\n            begin\n                mb_reg_rd[mb_loop] <= mb_reg_select[mb_loop] & mb_reg_rwn;\n                mb_reg_wr[mb_loop] <= mb_reg_select[mb_loop] & !mb_reg_rwn;\n                if (mb_reg_rwn)\n                begin\n                    mb_reg_out_w[mb_loop] <= interface_from_core_fp;\n                end\n                else\n                begin\n                    mb_reg_output <= mb_reg_out_w[mb_loop];\n                end\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_to_one_b76f895f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_to_one (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    output reg out\n);\n\nalways @(*) begin\n    if (in0 == 0 && in1 == 0 && in2 == 0 && in3 == 0) begin\n        out = 0;\n    end else if (in0 == 1 && in1 == 1 && in2 == 1 && in3 == 1) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_810c8794", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            sum <= 8'b0;\n        end else begin\n            sum <= a + b;\n        end\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input select,\n    output [7:0] sum\n);\n\n    wire [7:0] sum1, sum2;\n\n    adder adder1 (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .sum(sum1)\n    );\n\n    adder adder2 (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .sum(sum2)\n    );\n\n    assign sum = select ? sum2 : sum1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_d58eccea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clock_gate (\n    input clk,\n    input en,\n    input te,\n    output reg enclk\n);\n\n    TLATNTSCAX2TS latch (\n        .E(en),\n        .SE(te),\n        .CK(clk),\n        .ECK(enclk)\n    );\n\nendmodule\nmodule TLATNTSCAX2TS (\n    input E,\n    input SE,\n    input CK,\n    output reg ECK\n);\n\nalways @(posedge CK) begin\n    if (E) begin\n        ECK <= SE;\n    end else begin\n        ECK <= ECK; // Hold the previous value\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_data_mover_0cdec9c7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule axi_data_mover (\n  input clk,\n  input resetn,\n\n  input [2:0] request_id,\n  output [2:0] response_id,\n  input sync_id,\n  input eot,\n\n  input enable,\n  output reg enabled,\n\n  output xfer_req,\n\n  output s_axi_ready,\n  input s_axi_valid,\n  input [63:0] s_axi_data,\n\n  input m_axi_ready,\n  output m_axi_valid,\n  output [63:0] m_axi_data,\n  output m_axi_last,\n\n  input req_valid,\n  output reg req_ready,\n  input [3:0] req_last_burst_length\n);\n\nparameter MAX_BEATS_PER_BURST = 16;\n\nreg [3:0] last_burst_length = 0;\nreg [3:0] beat_counter = 0;\nreg [2:0] id = 0;\nreg [2:0] id_next = 0;\n\nreg pending_burst = 0;\nreg active = 0;\nreg last_eot = 0;\nreg last_non_eot = 0;\n\nwire last_load;\nwire last;\n\nassign xfer_req = active;\n\nassign response_id = id;\n\nassign last = eot ? last_eot : last_non_eot;\n\nassign s_axi_ready = m_axi_ready & pending_burst & active;\nassign m_axi_valid = s_axi_valid & pending_burst & active;\nassign m_axi_data = s_axi_data;\nassign m_axi_last = last;\n\nassign last_load = (m_axi_ready & s_axi_valid & active) & (last_eot | last_non_eot);\n\n// fixed to drive req_ready\nalways @( posedge clk )\n  if ( req_valid & ~active )\n    req_ready <= 1'b0;\n  else\n    req_ready <= 1'b1;\n\nalways @(posedge clk) begin\n  if (resetn == 1'b0) begin\n    enabled <= 1'b0;\n  end else begin\n    if (enable) begin\n      enabled <= 1'b1;\n    end else begin\n      enabled <= 1'b0;\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if (req_valid && ~active) begin\n    id_next <= id + 1;\n    beat_counter <= 1;\n    last_burst_length <= req_last_burst_length;\n    pending_burst <= 1;\n    active <= 1;\n  end else if (s_axi_ready && s_axi_valid && active) begin\n    beat_counter <= beat_counter + 1;\n    if (beat_counter == last_burst_length) begin\n      last_eot <= 1;\n      last_non_eot <= 0;\n    end else if (beat_counter == MAX_BEATS_PER_BURST - 1) begin\n      last_eot <= 0;\n      last_non_eot <= 1;\n    end else begin\n      last_eot <= 0;\n      last_non_eot <= 0;\n    end\n  end else if (last_load) begin\n    active <= 0;\n    pending_burst <= 0;\n  end\nend\n\nalways @(posedge clk) begin\n  if (resetn == 1'b0) begin\n    id <= 0;\n  end else begin\n    id <= id_next;\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "emesh_if_e05214bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule emesh_if (\n   cmesh_ready_out, cmesh_access_out, cmesh_packet_out,\n   rmesh_ready_out, rmesh_access_out, rmesh_packet_out,\n   xmesh_ready_out, xmesh_access_out, xmesh_packet_out,\n   emesh_ready_out, emesh_access_out, emesh_packet_out,\n   cmesh_access_in, cmesh_packet_in, cmesh_ready_in, rmesh_access_in,\n   rmesh_packet_in, rmesh_ready_in, xmesh_access_in, xmesh_packet_in,\n   xmesh_ready_in, emesh_access_in, emesh_packet_in, emesh_ready_in\n   );\n\n   parameter AW   = 32;   \n   parameter PW   = 2*AW+40; \n\n   input \t   cmesh_access_in;\n   input [PW-1:0]  cmesh_packet_in;\n   output \t   cmesh_ready_out;\n   output \t   cmesh_access_out;\n   output [PW-1:0] cmesh_packet_out;\n   input \t   cmesh_ready_in;\n      \n   input \t   rmesh_access_in;\n   input [PW-1:0]  rmesh_packet_in;\n   output \t   rmesh_ready_out;\n   output \t   rmesh_access_out;\n   output [PW-1:0] rmesh_packet_out;\n   input \t   rmesh_ready_in;\n   \n   input \t   xmesh_access_in;\n   input [PW-1:0]  xmesh_packet_in;\n   output \t   xmesh_ready_out;  \n   output \t   xmesh_access_out;\n   output [PW-1:0] xmesh_packet_out;\n   input \t   xmesh_ready_in;\n   \n   input \t   emesh_access_in;\n   input [PW-1:0]  emesh_packet_in;\n   output \t   emesh_ready_out;\n   \n   output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n   input \t   emesh_ready_in;\n      \n   assign cmesh_access_out = emesh_access_in & emesh_packet_in[0];\n\n   assign rmesh_access_out = emesh_access_in & ~emesh_packet_in[0];\n\n   assign xmesh_access_out = 1'b0;\n      \n   assign cmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\t \n   assign rmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\t \n   assign xmesh_packet_out[PW-1:0] = emesh_packet_in[PW-1:0];\n\n\n   assign emesh_ready_out = cmesh_ready_in &\n\t\t\t    rmesh_ready_in &\n\t\t\t    xmesh_ready_in;\n  \t \t \n   assign emesh_access_out = cmesh_access_in &\n\t\t\t     rmesh_access_in &\n\t\t\t     xmesh_access_in;\n   \n\n   assign emesh_packet_out[PW-1:0] = cmesh_access_in ? cmesh_packet_in[PW-1:0] :\n\t\t\t\t     rmesh_access_in ? rmesh_packet_in[PW-1:0] :\n\t\t\t\t                       xmesh_packet_in[PW-1:0];\n   \n   assign cmesh_ready_out = ~(cmesh_access_in & ~emesh_ready_in);\n   \n\n   assign rmesh_ready_out = ~(rmesh_access_in & \n\t\t\t    (~emesh_ready_in | ~cmesh_ready_in));\n\n   assign xmesh_ready_out = ~(xmesh_access_in & \n\t\t\t      (~emesh_ready_in | ~cmesh_access_in | ~rmesh_access_in));\n   \n\t\t\t\t     \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flip_flop_de052940", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule flip_flop (\n    Q   ,\n    CLK ,\n    D   ,\n    DE  ,\n    SCD ,\n    SCE ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Q   ;\n    input  CLK ;\n    input  D   ;\n    input  DE  ;\n    input  SCD ;\n    input  SCE ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Scan chain enable/disable\n    wire scan_en = SCE & ~SCD;\n\n    // D flip-flop\n    reg Q_reg;\n    always @(posedge CLK) begin\n        if (scan_en & DE) begin\n            Q_reg <= D;\n        end\n    end\n\n    // Output\n    assign Q = scan_en ? Q_reg : 1'b0;\n\n    // Power and ground connections\n    assign VPWR = 1'b1;\n    assign VGND = 1'b0;\n    assign VPB = 1'b1;\n    assign VNB = 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux2to1_ca4e5a97", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux2to1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = (sel == 0) ? a : b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shift_mux_1ceb692a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule barrel_shift_mux (\n    input [7:0] data_in0,\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    input [7:0] data_in3,\n    input [1:0] select,\n    input shift_left,\n    input shift_right,\n    input rotate_right,\n    output reg [7:0] data_out // Changed wire to reg to fix the issue\n);\n\nreg [7:0] shifted_data;\n\n// Barrel Shifter Module\nalways @(*) begin\n    case ({shift_left, shift_right, rotate_right})\n        3'b001: shifted_data = {data_in0[6:0], 1'b0};\n        3'b010: shifted_data = {1'b0, data_in0[7:1]};\n        3'b100: shifted_data = {data_in0[0], data_in0[7:1]};\n        default: shifted_data = data_in0;\n    endcase\nend\n\n// Multiplexer Module\nalways @(*) begin\n    case (select)\n        2'b00: data_out = shifted_data;\n        2'b01: data_out = data_in1;\n        2'b10: data_out = data_in2;\n        2'b11: data_out = data_in3;\n    endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "blk_mem_gen_1blk_mem_gen_prim_wrapper_33226759", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule blk_mem_gen_1blk_mem_gen_prim_wrapper\n       (addra,\n        addrb,\n        clka,\n        clkb,\n        dina,\n        doutb,\n        enb,\n        wea);\n\n  parameter WIDTH = 32;\n  parameter DEPTH = 1024;\n\n  input [WIDTH-1:0] addra;\n  input [WIDTH-1:0] addrb;\n  input clka;\n  input clkb;\n  input [WIDTH-1:0] dina;\n  output reg [WIDTH-1:0] doutb;\n  input enb;\n  input wea;\n\n  reg [WIDTH-1:0] mem [0:DEPTH-1];\n\n  integer i;\n\n  always @(posedge clka) begin\n    if (enb) begin\n        mem[addra] <= dina; \n    end\n  end\n\n  always @(posedge clkb) begin\n    if (wea) begin\n      doutb <= mem[addrb]; \n    end\n  end\n\n  initial begin\n    for (i = 0; i < DEPTH; i = i + 1) begin\n      mem[i] <= 0;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "preprocess_control_d4120528", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule preprocess_control\n    #(parameter DATA_WIDTH = 64,\n      parameter CTRL_WIDTH = DATA_WIDTH/8\n      )\n   (input  [DATA_WIDTH-1:0]            in_data,\n    input  [CTRL_WIDTH-1:0]            in_ctrl,\n    input                              in_wr,\n\n    output reg                         word_MAC_DA_HI,\n    output reg                         word_MAC_DASA,\n    output reg                         word_MAC_SA_LO,\n    output reg                         word_ETH_IP_VER,\n    output reg                         word_IP_LEN_ID,\n    output reg                         word_IP_FRAG_TTL_PROTO,\n    output reg                         word_IP_CHECKSUM_SRC_HI,\n    output reg                         word_IP_SRC_DST,\n    output reg                         word_IP_DST_LO,\n\n    input                              reset,\n    input                              clk\n   );\n\n   function integer log2;\n      input integer number;\n      begin\n         log2=0;\n         while(2**log2<number) begin\n            log2=log2+1;\n         end\n      end\n   endfunction localparam SKIP_MODULE_HDRS = 1;\n   localparam WORD_1           = 2;\n   localparam WORD_2           = 4;\n   localparam WORD_3           = 8;\n   localparam WORD_4           = 16;\n   localparam WORD_5           = 32;\n   localparam WAIT_EOP         = 64;\n\n   reg [6:0]                            state, state_next;\n       \n   always @(*) begin\n      state_next = state;\n      word_MAC_DA_HI = 0;\n      word_MAC_DASA  = 0;\n      word_MAC_SA_LO = 0;\n      word_ETH_IP_VER = 0;\n      word_IP_LEN_ID = 0;\n      word_IP_FRAG_TTL_PROTO = 0;\n      word_IP_CHECKSUM_SRC_HI = 0;\n      word_IP_SRC_DST = 0;\n      word_IP_DST_LO = 0;\n      \n      case(state)\n        SKIP_MODULE_HDRS: begin\n           if(in_ctrl==0 && in_wr) begin\n              word_MAC_DA_HI = 1;\n              word_MAC_DASA  = 1;\n              state_next     = WORD_1;\n           end\n        end\n\n        WORD_1: begin\n           if(in_wr) begin\n              word_MAC_SA_LO = 1;\n              word_ETH_IP_VER = 1;\n              state_next = WORD_2;\n           end\n        end\n\n        WORD_2: begin\n           if(in_wr) begin\n              word_IP_LEN_ID = 1;\n              word_IP_FRAG_TTL_PROTO = 1;\n              state_next = WORD_3;\n           end\n        end\n\n        WORD_3: begin\n           if(in_wr) begin\n              word_IP_CHECKSUM_SRC_HI = 1;\n              word_IP_SRC_DST = 1;\n              state_next = WORD_4;\n           end\n        end\n\n        WORD_4: begin\n           if(in_wr) begin\n              word_IP_DST_LO = 1;\n              state_next = WAIT_EOP;\n           end\n        end\n\n        WAIT_EOP: begin\n           if(in_ctrl!=0 & in_wr) begin\n              state_next = SKIP_MODULE_HDRS;\n           end\n        end\n      endcase end always@(posedge clk) begin\n      if(reset) begin\n         state <= SKIP_MODULE_HDRS;\n      end\n      else begin\n         state <= state_next;\n      end\n   end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM_split_81f4f3f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule FSM_split (\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\nparameter n = 4; // number of input signals\nparameter m = 2; // number of output signals\nparameter s = 8; // number of states in the original FSM\nparameter k = 2; // number of states in each smaller FSM\n\n// Define states and transitions in the original FSM\nparameter STATE0 = 3'b000;\nparameter STATE1 = 3'b001;\nparameter STATE2 = 3'b010;\nparameter STATE3 = 3'b011;\nparameter STATE4 = 3'b100;\nparameter STATE5 = 3'b101;\nparameter STATE6 = 3'b110;\nparameter STATE7 = 3'b111;\n\nreg [2:0] state;\nalways @ (posedge clk) begin\n  case (state)\n    STATE0: if (in == 4'b0000) state <= STATE1; else state <= STATE0;\n    STATE1: if (in == 4'b0001) state <= STATE2; else state <= STATE0;\n    STATE2: if (in == 4'b0010) state <= STATE3; else state <= STATE0;\n    STATE3: if (in == 4'b0011) state <= STATE4; else state <= STATE0;\n    STATE4: if (in == 4'b0100) state <= STATE5; else state <= STATE0;\n    STATE5: if (in == 4'b0101) state <= STATE6; else state <= STATE0;\n    STATE6: if (in == 4'b0110) state <= STATE7; else state <= STATE0;\n    STATE7: if (in == 4'b0111) state <= STATE0; else state <= STATE0;\n  endcase\nend\n\n// Split the FSM into smaller FSMs\nreg [1:0] state1, state2;\nalways @ (posedge clk) begin\n  case (state)\n    STATE0, STATE1: state1 <= state[1:0];\n    STATE2, STATE3: state1 <= state[1:0] - 2;\n    STATE4, STATE5: state1 <= state[1:0] - 4;\n    STATE6, STATE7: state1 <= state[1:0] - 6;\n  endcase\nend\n\n// Define transitions and output functions for the smaller FSMs\nalways @ (posedge clk) begin\n  case (state1)\n    2'b00: if (in == 4'b0000) state2 <= 2'b01; else state2 <= 2'b00;\n    2'b01: if (in == 4'b0001) state2 <= 2'b10; else state2 <= 2'b00;\n    2'b10: if (in == 4'b0010) state2 <= 2'b11; else state2 <= 2'b00;\n    2'b11: if (in == 4'b0011) state2 <= 2'b00; else state2 <= 2'b00;\n  endcase\nend\n\nassign out = {state2[1], state2[0]};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "switch_module_77b738be", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule switch_module\n#(parameter     addr = 4'b0010)\n(   \n    input       [7:0] port0_i,\n    input       [7:0] port1_i,\n    input       [7:0] port0_local_i,\n    input       [7:0] port1_local_i,\n    output      [7:0] port0_o,\n    output      [7:0] port1_o,\n    output      portl0_ack,\n    output      portl1_ack,\n    input       clk,\n    input       rst\n);\n\n    // inputs\n    wire [7:0] port0_0, port1_0, port0_local_0, port1_local_0;\n\n    assign port0_0 = (rst) ? 8'd0 : port0_i;\n    assign port1_0 = (rst) ? 8'd0 : port1_i;\n    assign port0_local_0 = (rst) ? 8'd0 : port0_local_i;\n    assign port1_local_0 = (rst) ? 8'd0 : port1_local_i;\n\n    \t\n\t\n    reg [7:0] port0_0_r, port1_0_r;\n    always @(posedge clk) begin\n        port0_0_r <= port0_0;\n        port1_0_r <= port1_0;\n    end\n\n\twire ej_0 = port0_0_r[3:0] == addr && port0_0_r[4];\n\twire ej_1 = port1_0_r[3:0] == addr && port1_0_r[4];\n\n    assign port0_o = (ej_0) ? port0_0_r[7:0] : port0_local_0;\n    assign port1_o = (ej_1) ? port1_0_r[7:0] : port1_local_0;\n\n    wire valid0 = (ej_0) ? 0 : port0_0_r[4];\n    wire valid1 = (ej_1) ? 0 : port1_0_r[4];\n\n    assign portl0_ack = ~valid0 & (ej_0 | (port0_local_0[4] && ~ej_1));\n    assign portl1_ack = ~valid1 & (ej_1 | (port1_local_0[4] && ~ej_0));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "twos_comp_873e5214", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule twos_comp (\n    input [3:0] in,\n    output [3:0] out\n);\n\n    assign out = ~in + 4'b1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "inverter_37dbe476", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule inverter (\n    input A,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    // Define internal signals\n    wire A_valid;\n    wire A_low;\n    wire A_high;\n\n    // Check if A is a valid logic level\n    assign A_valid = (A == 0 || A == 1);\n\n    // Check if A is low or high\n    assign A_low = (A == 0);\n    assign A_high = (A == 1);\n\n    // Define the inverter logic\n    assign Y = A_valid ? ~A : 1'bx;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multi_input__598e08ee", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multi_input_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    input f,\n    input g,\n    input h,\n    input i,\n    output out\n);\n\n    wire ab_high;\n    wire cd_high;\n    wire ef_low;\n    wire g_high;\n    wire h_low;\n    wire i_high;\n\n    assign ab_high = a & b;\n    assign cd_high = c | d;\n    assign ef_low = ~(e | f);\n    assign g_high = g;\n    assign h_low = ~h;\n    assign i_high = i;\n\n    assign out = ab_high | cd_high | ef_low | g_high | h_low | i_high;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand_gate_pipeline_76b9abbd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand_gate_pipeline(\n    input a,\n    input b,\n    output reg out\n);\n\nreg [1:0] stage1;\nreg stage2;\n\nalways @(a, b) begin\n    stage1[0] <= a & b;\n    stage1[1] <= #1 ~stage1[0];\n    stage2 <= #1 ~stage1[1];\n    out <= #1 ~stage2;\nend\n\nendmodule\n\nmodule decoder_2to4(\n    input [1:0] in,\n    output reg [3:0] out\n);\n\nwire nand1, nand2, nand3, nand4;\n\nnand_gate_pipeline nand_gate1(.a(in[0]), .b(in[1]), .out(nand1));\nnand_gate_pipeline nand_gate2(.a(~in[0]), .b(in[1]), .out(nand2));\nnand_gate_pipeline nand_gate3(.a(in[0]), .b(~in[1]), .out(nand3));\nnand_gate_pipeline nand_gate4(.a(~in[0]), .b(~in[1]), .out(nand4));\n\nalways @(in) begin\n    out[0] <= #1 nand1;\n    out[1] <= #1 nand2;\n    out[2] <= #1 nand3;\n    out[3] <= #1 nand4;\nend\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    output reg [3:0] out\n);\n\nwire [1:0] in;\nassign in = {a, b};\n\ndecoder_2to4 decoder(.in(in), .out(out));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__nand4_d76ea618", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, D, C, B, A     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor_logic_7df22390", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nor_logic(\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    wire [3:0] neg_in;\n    assign neg_in = ~in;\n\n    // Output for AND operation\n    assign out_and = ~(neg_in[0] | neg_in[1] | neg_in[2] | neg_in[3]);\n\n    // Output for OR operation\n    assign out_or = ~(in[0] | in[1] | in[2] | in[3]);\n\n    // Output for XOR operation\n    assign out_xor = ~(in[0] ^ neg_in[0] ^ in[1] ^ neg_in[1] ^ in[2] ^ neg_in[2] ^ in[3] ^ neg_in[3]);\n\nendmodule\n\nmodule control_logic(\n    input select,\n    output [1:0] active_output\n);\n\n    // Output selection logic\n    assign active_output = (select == 1'b0) ? 2'b10 : 2'b01;\n\nendmodule\n\nmodule top_module( \n    input [3:0] in,\n    input select,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output [1:0] active_output\n);\n\n    wire out_and_nor, out_or_nor, out_xor_nor;\n\n    // NOR logic module instantiation\n    nor_logic nor_inst(\n        .in(in),\n        .out_and(out_and_nor),\n        .out_or(out_or_nor),\n        .out_xor(out_xor_nor)\n    );\n\n    // Control logic module instantiation\n    control_logic control_inst(\n        .select(select),\n        .active_output(active_output)\n    );\n\n    // Output selection logic\n    assign {out_and, out_or, out_xor} = (active_output == 2'b10) ? {out_and_nor, 1'b0, 1'b0} : {1'b0, out_or_nor, out_xor_nor};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ahb_lite_memory_interface_40535488", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ahb_lite_memory_interface (\n    input         hclk,       // AHB-Lite System Clock\n    input         hresetn,    // AHB-Lite System Reset, active low\n    input  [31:0] haddr,      // AHB-Lite Address bus\n    input  [31:0] hwdata,     // AHB-Lite Write-data bus\n    output [31:0] hrdata,     // AHB-Lite Read-data bus\n    input         hwrite,     // AHB-Lite Write control signal\n    input   [2:0] hsize,      // AHB-Lite Size of the transfer\n    input   [1:0] htrans,     // AHB-Lite Transfer type\n    input         hsel,       // AHB-Lite Slave select\n    output        hready,     // AHB-Lite Transfer ready signal\n    output  [1:0] hresp       // AHB-Lite Transfer response\n);\n\n    // Local parameters for AHB transfer types\n    localparam IDLE  = 2'b00;\n    localparam BUSY  = 2'b01;\n    localparam NONSEQ = 2'b10;\n    localparam SEQ   = 2'b11;\n\n    // Memory array\n    reg [31:0] memory [0:255]; // Example memory size is 256 words\n\n    // Internal signals\n    reg [31:0] internal_hrdata;\n    reg        internal_hready;\n    reg [1:0]  internal_hresp;\n\n    // AHB-Lite Read/Write Logic\n    always @(posedge hclk or negedge hresetn) begin\n        if (!hresetn) begin\n            internal_hrdata <= 32'b0;\n            internal_hready <= 1'b1;\n            internal_hresp <= 2'b00; // OKAY response\n        end else begin\n            if (hsel && htrans != IDLE && hready) begin\n                if (hwrite) begin\n                    // Write operation\n                    memory[haddr[31:2]] <= hwdata; // Word aligned address\n                end else begin\n                    // Read operation\n                    internal_hrdata <= memory[haddr[31:2]]; // Word aligned address\n                end\n                internal_hready <= 1'b1;\n            end else begin\n                internal_hready <= 1'b1;\n            end\n        end\n    end\n\n    // Output assignments\n    assign hrdata = internal_hrdata;\n    assign hready = internal_hready;\n    assign hresp = internal_hresp;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hvl__nor2_d132820e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hvl__nor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B           );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hls_contrast_streibs_DSP48_6_31314668", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule hls_contrast_streibs_DSP48_6(\n    input  [8 - 1:0] in0,\n    input  [23 - 1:0] in1,\n    input  [32 - 1:0] in2,\n    output [32 - 1:0]  dout);\n\nwire signed [25 - 1:0]     a;\nwire signed [18 - 1:0]     b;\nwire signed [48 - 1:0]     c;\nwire signed [43 - 1:0]     m;\nwire signed [48 - 1:0]     p;\n\nassign a  = $signed(in1);\nassign b  = $signed(in0);\nassign c  = $signed(in2);\n\nassign m  = a * b;\nassign p  = m + c;\n\nassign dout = p;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_1d28a49f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n  input clk,\n  input shift_enable,\n  input parallel_load_enable,\n  input [15:0] data_in,\n  output [15:0] data_out\n);\n\n  reg [15:0] register;\n\n  always @(posedge clk) begin\n    if (parallel_load_enable) begin\n      register <= data_in;\n    end else if (shift_enable) begin\n      register <= {register[14:0], 1'b0};\n    end\n  end\n\n  assign data_out = register;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "led_controller_937d4d10", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule led_controller (\n  input clk,\n  input rst,\n  output reg [3:0] leds_0,\n  output reg [3:0] leds_1,\n  output reg [3:0] leds_2,\n  output reg [3:0] leds_3\n);\n\n  reg [26:0] counter;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      counter <= 0;\n      leds_0 <= 0;\n      leds_1 <= 0;\n      leds_2 <= 0;\n      leds_3 <= 0;\n    end else begin\n      counter <= counter + 1;\n      if (counter == 0) begin\n        leds_0 <= 15;\n      end else if (counter == 25000000) begin\n        leds_0 <= 0;\n      end else if (counter == 50000000) begin\n        leds_1 <= 15;\n      end else if (counter == 100000000) begin\n        leds_1 <= 0;\n      end else if (counter == 200000000) begin\n        leds_2 <= 15;\n      end else if (counter == 400000000) begin\n        leds_2 <= 0;\n      end else if (counter == 800000000) begin\n        leds_3 <= 15;\n      end else if (counter == 1600000000) begin\n        leds_3 <= 0;\n        counter <= 0;\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wb_adapter_0a8ea5a8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule wb_adapter (\n    input clk,\n    input rst,\n    input [31:0] wbm_adr_i,\n    input [31:0] wbm_dat_i,\n    output reg [31:0] wbm_dat_o,\n    input wbm_we_i,\n    input [3:0] wbm_sel_i,\n    input wbm_stb_i,\n    output reg wbm_ack_o,\n    output reg wbm_err_o,\n    output reg wbm_rty_o,\n    input [31:0] wbs_dat_i,\n    output reg [31:0] wbs_adr_o,\n    output reg [31:0] wbs_dat_o,\n    output reg wbs_we_o,\n    output reg [3:0] wbs_sel_o,\n    output reg wbs_stb_o,\n    input wbs_ack_i,\n    input wbs_err_i,\n    input wbs_rty_i,\n    output reg wbs_cyc_o\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wbm_dat_o <= 32'b0;\n        wbm_ack_o <= 1'b0;\n        wbm_err_o <= 1'b0;\n        wbm_rty_o <= 1'b0;\n        wbs_adr_o <= 32'b0;\n        wbs_dat_o <= 32'b0;\n        wbs_we_o <= 1'b0;\n        wbs_sel_o <= 4'b0;\n        wbs_stb_o <= 1'b0;\n        wbs_cyc_o <= 1'b0;\n    end else begin\n        wbm_dat_o <= wbs_dat_i;\n        wbm_ack_o <= wbs_ack_i;\n        wbm_err_o <= wbs_err_i;\n        wbm_rty_o <= wbs_rty_i;\n        wbs_adr_o <= wbm_adr_i;\n        wbs_dat_o <= wbm_dat_i;\n        wbs_we_o <= wbm_we_i;\n        wbs_sel_o <= wbm_sel_i;\n        wbs_stb_o <= wbm_stb_i;\n        wbs_cyc_o <= wbm_stb_i;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_adder_8aeb1038", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_adder\n  (\n    input signed [3:0] a,\n    input signed [3:0] b,\n    input signed cin,\n    output signed [3:0] sum,\n    output signed cout\n  );\n  \n  assign {cout, sum} = a + b + cin;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_867da251", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    input clk,\n    output reg [3:0] Q\n);\n\nreg [3:0] A_reg, B_reg, Q_reg;\nreg mode_reg;\n\nalways @ (posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    mode_reg <= mode;\n    \n    if (mode_reg == 0) begin\n        Q_reg <= A_reg + B_reg;\n    end else begin\n        Q_reg <= A_reg - B_reg;\n    end\nend\n\nalways @*\nbegin\n    Q = Q_reg;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_321c11e9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder(input [3:0] A, input [3:0] B, input Cin, output [3:0] S, output Cout);\n\n  wire C1, C2, C3;\n  wire S0, S1, S2, S3;\n  \n  // 1st bit\n  full_adder FA1(A[0], B[0], Cin, S0, C1);\n  \n  // 2nd bit\n  full_adder FA2(A[1], B[1], C1, S1, C2);\n  \n  // 3rd bit\n  full_adder FA3(A[2], B[2], C2, S2, C3);\n  \n  // 4th bit\n  full_adder FA4(A[3], B[3], C3, S3, Cout);\n  \n  assign S = {S3, S2, S1, S0};\n  \nendmodule\nmodule full_adder(input A, input B, input Cin, output S, output Cout);\n  \n  wire X, Y, G, P;\n  \n  // First stage\n  xor (X, A, B);\n  and (Y, A, B);\n  \n  // Second stage\n  xor (S, X, Cin);\n  and (G, X, Cin);\n  \n  // Third stage\n  and (P, Y, Cin);\n  or (Cout, G, P);\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__951cd1ba", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] q\n);\n\n    wire greater_than;\n    wire equal;\n    wire enable;\n    wire [3:0] count;\n    wire [7:0] sum;\n\n    // Instantiate the 8-bit comparator module\n    comparator_module comparator_inst(\n        .a(a),\n        .b(b),\n        .greater_than(greater_than)\n    );\n    \n    // Instantiate the 4-bit binary counter module\n    counter_module counter_inst(\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .count(count)\n    );\n    \n    // Instantiate the control logic module\n    control_logic_module control_inst(\n        .a(a),\n        .b(b),\n        .greater_than(greater_than),\n        .equal(equal),\n        .enable(enable)\n    );\n    \n    // Instantiate the additional functional module\n    functional_module functional_inst(\n        .a(a[0]),\n        .b(count),\n        .sum(sum)\n    );\n    \n    // Output the appropriate value based on the control logic\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0;\n        end else if (greater_than) begin\n            q <= count;\n        end else if (equal) begin\n            q <= sum;\n        end else begin\n            q <= a;\n        end\n    end\n    \nendmodule\nmodule comparator_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg greater_than\n);\n    \n    always @(*) begin\n        if (a > b) begin\n            greater_than = 1;\n        end else begin\n            greater_than = 0;\n        end\n    end\n    \nendmodule\nmodule counter_module (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n    \nendmodule\nmodule control_logic_module (\n    input [7:0] a,\n    input [7:0] b,\n    input greater_than,\n    output reg equal,\n    output reg enable\n);\n    \n    always @(*) begin\n        if (a > b) begin\n            equal = 0;\n            enable = 1;\n        end else if (a < b) begin\n            equal = 0;\n            enable = 0;\n        end else begin\n            equal = 1;\n            enable = 1;\n        end\n    end\n    \nendmodule\nmodule functional_module (\n    input a,\n    input [3:0] b,\n    output reg [7:0] sum\n);\n    \n    always @(*) begin\n        sum = {7'b0, a} + b;\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MUX_4to1_599c7b07", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MUX_4to1 (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input sel,\n  input en,\n  output out\n);\n\n  reg selected;\n\n  always @(*) begin\n    if (sel == 2'b00) begin\n      selected = in0;\n    end else if (sel == 2'b01) begin\n      selected = in1;\n    end else if (sel == 2'b10) begin\n      selected = in2;\n    end else begin\n      selected = in3;\n    end\n  end\n\n  assign out = en ? selected : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_multiplier_cc45fb4b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_multiplier (\n  input [3:0] a,\n  input [3:0] b,\n  output [7:0] p,\n  output sign\n);\n\n  wire [7:0] temp_p;\n  wire a_sign, b_sign, p_sign;\n  \n  assign a_sign = a[3];\n  assign b_sign = b[3];\n  \n  assign temp_p[0] = a[0] & b;\n  assign temp_p[1] = a[1] & b;\n  assign temp_p[2] = a[2] & b;\n  assign temp_p[3] = a[3] & b;\n  assign temp_p[4] = 4'b0;\n  assign temp_p[5] = 4'b0;\n  assign temp_p[6] = 4'b0;\n  assign temp_p[7] = 4'b0;\n  \n  assign p_sign = a_sign ^ b_sign;\n  \n  assign sign = p_sign;\n  \n  assign p = (p_sign) ? (~temp_p + 1) : temp_p;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_cedccb1c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_encoder (\n    input [3:0] I,\n    output [15:0] O\n);\n\n    assign O = (I == 4'h0) ? 16'b0000000000000001 :\n               (I == 4'h1) ? 16'b0000000000000010 :\n               (I == 4'h2) ? 16'b0000000000000100 :\n               (I == 4'h3) ? 16'b0000000000001000 :\n               (I == 4'h4) ? 16'b0000000000010000 :\n               (I == 4'h5) ? 16'b0000000000100000 :\n               (I == 4'h6) ? 16'b0000000001000000 :\n               (I == 4'h7) ? 16'b0000000010000000 :\n               (I == 4'h8) ? 16'b0000000100000000 :\n               (I == 4'h9) ? 16'b0000001000000000 :\n               (I == 4'ha) ? 16'b0000010000000000 :\n               (I == 4'hb) ? 16'b0000100000000000 :\n               (I == 4'hc) ? 16'b0001000000000000 :\n               (I == 4'hd) ? 16'b0010000000000000 :\n               (I == 4'he) ? 16'b0100000000000000 :\n                             16'b1000000000000000 ;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "seven_seg_decoder_3c5d74f0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule seven_seg_decoder(\n\t\tnum_in,\n\t\tcontrol,\n\t\tseg_out,\n\t\tdisplay_sel\n);\n\ninput [3:0]  num_in;\n\t\t\tinput [1:0]  control;\n\t\t\toutput [6:0] seg_out;\n\t\t\tinput        display_sel;\n   \n   \nwire [6:0]   seg_out_bcd;\n\t\t\twire [6:0]   seg_out_hex;\n\t\t\twire [6:0]   seg_out_buf;\n   \nassign seg_out = (control == 2'b11 & display_sel == 1'b0) ? 7'b0001001 : seg_out_buf;\n\t\t\t\n\t\t\tassign seg_out_buf = (display_sel == 1'b1) ? seg_out_bcd : seg_out_hex;\n\t\t\t\n\t\t\tassign seg_out_bcd = (num_in == 4'b0000) ? 7'b1000000 : \t\t(num_in == 4'b0001) ? 7'b1111001 : \t\t(num_in == 4'b0010) ? 7'b0100100 : \t\t(num_in == 4'b0011) ? 7'b0110000 : \t\t(num_in == 4'b0100) ? 7'b0011001 : \t\t(num_in == 4'b0101) ? 7'b0010010 : \t\t(num_in == 4'b0110) ? 7'b0000010 : \t\t(num_in == 4'b0111) ? 7'b1111000 : \t\t(num_in == 4'b1000) ? 7'b0000000 : \t\t(num_in == 4'b1001) ? 7'b0010000 : \t\t(num_in == 4'b1010) ? 7'b1111111 : \t\t(num_in == 4'b1011) ? 7'b1000110 : \t\t7'b0111111;\t\t\t\t\t\t\t\t\t\tassign seg_out_hex = (num_in == 4'b0000) ? 7'b1000000 : \t\t(num_in == 4'b0001) ? 7'b1111001 : \t\t(num_in == 4'b0010) ? 7'b0100100 : \t\t(num_in == 4'b0011) ? 7'b0110000 : \t\t(num_in == 4'b0100) ? 7'b0011001 : \t\t(num_in == 4'b0101) ? 7'b0010010 : \t\t(num_in == 4'b0110) ? 7'b0000010 : \t\t(num_in == 4'b0111) ? 7'b1111000 : \t\t(num_in == 4'b1000) ? 7'b0000000 : \t\t(num_in == 4'b1001) ? 7'b0010000 : \t\t(num_in == 4'b1010) ? 7'b0001000 : \t\t(num_in == 4'b1011) ? 7'b0000011 : \t\t(num_in == 4'b1100) ? 7'b1000110 : \t\t(num_in == 4'b1101) ? 7'b0100001 : \t\t(num_in == 4'b1110) ? 7'b0000110 : \t\t7'b0001110;\t\t\t\t\t\t\t\t\t\tendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "freq_synthesizer_ade60c03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule freq_synthesizer (\n  input ref_clk,\n  input [n-1:0] ctrl,\n  output reg syn_clk\n);\n\nparameter n = 4; // number of control signals\nparameter m = 8; // number of output signals\nparameter f_out = 100000000; // desired output frequency (100 MHz)\nparameter f_ref = 25000000; // frequency of reference clock signal (25 MHz)\n\nreg [m-1:0] counter;\nreg [n-1:0] divider;\nreg [n-1:0] phase;\nreg [n-1:0] phase_accumulator;\nreg [n-1:0] phase_increment;\nreg [n-1:0] phase_accumulator_next;\n\nwire [n-1:0] ctrl_scaled;\nwire [n-1:0] ctrl_scaled_inv;\nwire [n-1:0] ctrl_scaled_int;\nwire [n-1:0] ctrl_scaled_frac;\n\n// Calculate scaled control signals\nassign ctrl_scaled = $signed(ctrl) * ($signed(f_out) / $signed(f_ref));\nassign ctrl_scaled_inv = ($signed(f_out) / $signed(f_ref)) - ctrl_scaled;\nassign ctrl_scaled_int = ctrl_scaled[n-1:0];\nassign ctrl_scaled_frac = ctrl_scaled - ctrl_scaled_int;\n\n// Clock divider\nalways @ (posedge ref_clk) begin\n  if (counter == 0) begin\n    phase_accumulator <= phase_accumulator_next;\n    counter <= divider;\n  end else begin\n    counter <= counter - 1;\n  end\nend\n\n// Phase increment calculation\nalways @ (posedge ref_clk) begin\n  phase_increment <= ctrl_scaled_int + (ctrl_scaled_frac > phase_accumulator);\nend\n\n// Phase accumulator\nalways @ (posedge ref_clk) begin\n  phase_accumulator_next <= phase_accumulator + phase_increment;\nend\n\n// Output clock generation\nalways @ (posedge ref_clk) begin\n  if (phase_accumulator_next >= (f_out / f_ref)) begin\n    syn_clk <= ~syn_clk;\n  end\nend\n\n// Divider calculation\nalways @ (ctrl_scaled_int, ctrl_scaled_frac) begin\n  divider <= (f_out / f_ref) / (ctrl_scaled_int + ctrl_scaled_frac);\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_e623fd33", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n  input clk,\n  input load,\n  input [7:0] in,\n  input shift,\n  output reg [7:0] out\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      out <= in;\n    end else if (shift) begin\n      out <= {out[6:0], 1'b0};\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "v89d234 #_fa4e225b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule v89d234 #(\n parameter v422d28 = 0\n) (\n input v41eb95,\n input [7:0] v39f831,\n input vf892a0,\n output [7:0] vb1c024\n);\n localparam p0 = v422d28;\n wire [0:7] w1;\n wire [0:7] w2;\n wire w3;\n wire w4;\n assign vb1c024 = w1;\n assign w2 = v39f831;\n assign w3 = vf892a0;\n assign w4 = v41eb95;\n v89d234_v9148cb #(\n  .INI(p0)\n ) v9148cb (\n  .q(w1),\n  .d(w2),\n  .load(w3),\n  .clk(w4)\n );\nendmodule\n\nmodule v89d234_v9148cb #(\n parameter INI = 0\n) (\n output reg [7:0] q,\n input [7:0] d,\n input load,\n input clk\n);\n always @(posedge clk) begin\n  if (load) begin\n   q <= d;\n  end\n end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__2ffb625e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [3:0] A, // 4-bit input to be shifted and multiplied by 3\n    input [1:0] shift_type, // 2-bit control signal to select the type of shift operation\n    input select, // 1-bit control signal to select between multiplication and shift operation\n    output reg [3:0] B // 4-bit output of the active module\n);\n\n    // Multiplication module\n    wire [6:0] mul_output;\n    assign mul_output = A * 3;\n\n    // Barrel shifter module\n    wire [3:0] shift_output;\n    barrel_shifter barrel_shifter_inst(\n        .in(A),\n        .out(shift_output),\n        .shift_type(shift_type)\n    );\n\n    // Additive control logic\n    always @(*) begin\n        if (select == 0) begin\n            B <= mul_output[3:0];\n        end else begin\n            B <= shift_output;\n        end\n    end\n\nendmodule\n\n// Barrel shifter module\nmodule barrel_shifter (\n    input [3:0] in, // 4-bit input to be shifted\n    output reg [3:0] out, // 4-bit output of the shift operation\n    input [1:0] shift_type // 2-bit control signal to select the type of shift operation\n);\n\n    always @(*) begin\n        case (shift_type)\n            2'b00: out = in << 1; // Logical left shift\n            2'b01: out = in >> 1; // Logical right shift\n            2'b10: out = {in[2], in[3], in[3], in[3]}; // Arithmetic left shift\n            2'b11: out = {in[0], in[0], in[0], in[1]}; // Arithmetic right shift\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Video_Stream_Merger_eb18483f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule Computer_System_Video_In_Subsystem_Edge_Detection_Subsystem_Video_Stream_Merger (\n\tclk,\n\treset,\n\n\tsync_data,\n\tsync_valid,\n\n\tstream_in_data_0,\n\tstream_in_startofpacket_0,\n\tstream_in_endofpacket_0,\n\tstream_in_empty_0,\n\tstream_in_valid_0,\n\n\tstream_in_data_1,\n\tstream_in_startofpacket_1,\n\tstream_in_endofpacket_1,\n\tstream_in_empty_1,\n\tstream_in_valid_1,\n\n\tstream_out_ready,\n\n\tsync_ready,\n\n\tstream_in_ready_0,\n\n\tstream_in_ready_1,\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_empty,\n\tstream_out_valid\n);\n\n\n\nparameter DW = 23; parameter EW = 1; \n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t\t\t\tsync_data;\ninput\t\t\t\t\t\tsync_valid;\n\ninput\t\t\t[DW: 0]\tstream_in_data_0;\ninput\t\t\t\t\t\tstream_in_startofpacket_0;\ninput\t\t\t\t\t\tstream_in_endofpacket_0;\ninput\t\t\t[EW: 0]\tstream_in_empty_0;\ninput\t\t\t\t\t\tstream_in_valid_0;\n\ninput\t\t\t[DW: 0]\tstream_in_data_1;\ninput\t\t\t\t\t\tstream_in_startofpacket_1;\ninput\t\t\t\t\t\tstream_in_endofpacket_1;\ninput\t\t\t[EW: 0]\tstream_in_empty_1;\ninput\t\t\t\t\t\tstream_in_valid_1;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tsync_ready;\n\noutput\t\t\t\t\tstream_in_ready_0;\n\noutput\t\t\t\t\tstream_in_ready_1;\n\noutput reg\t[DW: 0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t[EW: 0]\tstream_out_empty;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire\t\t\t\t\t\tenable_setting_stream_select;\n\nreg\t\t\t\t\t\tbetween_frames;\nreg\t\t\t\t\t\tstream_select_reg;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'h0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_empty\t\t\t\t<=  'h0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (stream_in_ready_0)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= stream_in_data_0;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket_0;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket_0;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty_0;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid_0;\n\tend\n\telse if (stream_in_ready_1)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= stream_in_data_1;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket_1;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket_1;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty_1;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid_1;\n\tend\n\telse if (stream_out_ready)\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tbetween_frames <= 1'b1;\n\telse if (stream_in_ready_0 & stream_in_endofpacket_0)\n\t\tbetween_frames <= 1'b1;\n\telse if (stream_in_ready_1 & stream_in_endofpacket_1)\n\t\tbetween_frames <= 1'b1;\n\telse if (stream_in_ready_0 & stream_in_startofpacket_0)\n\t\tbetween_frames <= 1'b0;\n\telse if (stream_in_ready_1 & stream_in_startofpacket_1)\n\t\tbetween_frames <= 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tstream_select_reg <= 1'b0;\n\telse if (enable_setting_stream_select & sync_valid)\n\t\tstream_select_reg <= sync_data;\nend\n\n\n\nassign sync_ready\t\t\t\t= enable_setting_stream_select;\n\nassign stream_in_ready_0\t= (stream_select_reg) ? \n\t\t1'b0 : stream_in_valid_0 & (~stream_out_valid | stream_out_ready);\n\nassign stream_in_ready_1\t= (stream_select_reg) ? \n\t\tstream_in_valid_1 & (~stream_out_valid | stream_out_ready) : 1'b0;\n\nassign enable_setting_stream_select = \n\t\t  (stream_in_ready_0 & stream_in_endofpacket_0) |\n\t\t  (stream_in_ready_1 & stream_in_endofpacket_1) |\n\t\t(~(stream_in_ready_0 & stream_in_startofpacket_0) & between_frames) |\n\t\t(~(stream_in_ready_1 & stream_in_startofpacket_1) & between_frames);\n\n\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vending_machine_a52d338a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vending_machine(\n    input clk,\n    input rst,\n    input nickel,\n    input dime,\n    input quarter,\n    input select_A,\n    input select_B,\n    input select_C,\n    output dispense,\n    output change_10,\n    output change_25,\n    output product_A,\n    output product_B,\n    output product_C\n);\n\nreg [7:0] total_amount;\nreg [1:0] product_selected;\nreg [1:0] change_returned;\nwire [7:0] cost = 50;\n\nassign dispense = (total_amount >= cost) & (select_A | select_B | select_C);\nassign change_10 = (change_returned == 2'b10);\nassign change_25 = (change_returned == 2'b01);\nassign product_A = (product_selected == 2'b01);\nassign product_B = (product_selected == 2'b10);\nassign product_C = (product_selected == 2'b11);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        total_amount <= 0;\n        product_selected <= 0;\n        change_returned <= 0;\n    end else begin\n        if (nickel) begin\n            total_amount <= total_amount + 5;\n            change_returned <= 2'b00;\n        end\n        if (dime) begin\n            total_amount <= total_amount + 10;\n            change_returned <= 2'b00;\n        end\n        if (quarter) begin\n            total_amount <= total_amount + 25;\n            change_returned <= 2'b00;\n        end\n        if (select_A) begin\n            if (total_amount >= cost) begin\n                product_selected <= 2'b01;\n                total_amount <= total_amount - cost;\n                change_returned <= total_amount;\n            end else begin\n                product_selected <= 0;\n                total_amount <= 0;\n                change_returned <= 0;\n            end\n        end\n        if (select_B) begin\n            if (total_amount >= cost) begin\n                product_selected <= 2'b10;\n                total_amount <= total_amount - cost;\n                change_returned <= total_amount;\n            end else begin\n                product_selected <= 0;\n                total_amount <= 0;\n                change_returned <= 0;\n            end\n        end\n        if (select_C) begin\n            if (total_amount >= cost) begin\n                product_selected <= 2'b11;\n                total_amount <= total_amount - cost;\n                change_returned <= total_amount;\n            end else begin\n                product_selected <= 0;\n                total_amount <= 0;\n                change_returned <= 0;\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_operations_38e894cb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_operations(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and_bitwise,\n    output [2:0] out_xor_bitwise,\n    output [2:0] out_nor_bitwise,\n    output [5:0] out_not\n);\n\n    // Bitwise AND\n    assign out_and_bitwise = a & b;\n\n    // Bitwise XOR\n    assign out_xor_bitwise = a ^ b;\n\n    // Bitwise NOR\n    assign out_nor_bitwise = ~(a | b);\n\n    // NOT of both vectors\n    assign out_not[5:3] = ~b;\n    assign out_not[2:0] = ~a;\n\nendmodule\n\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and_bitwise,\n    output [2:0] out_xor_bitwise,\n    output [2:0] out_nor_bitwise,\n    output [5:0] out_not\n);\n\n    bitwise_operations bitwise_ops(.a(a), .b(b), .out_and_bitwise(out_and_bitwise), .out_xor_bitwise(out_xor_bitwise), .out_nor_bitwise(out_nor_bitwise), .out_not(out_not));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hapara_axis_id_generator_v1_0_S00_AXI #_9bd24314", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n    module hapara_axis_id_generator_v1_0_S00_AXI #\n    (\n        parameter integer C_S_AXI_DATA_WIDTH    = 32,\n        parameter integer C_S_AXI_ADDR_WIDTH    = 4\n    )\n    (\n        input wire Finish,\n        output wire En,\n\n        output wire [C_S_AXI_DATA_WIDTH - 1 : 0] org,\n        output wire [C_S_AXI_DATA_WIDTH - 1 : 0] len,\n        output wire [C_S_AXI_DATA_WIDTH - 1 : 0] numOfSlv,\n\n        input wire  S_AXI_ACLK,\n        input wire  S_AXI_ARESETN,\n        input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,\n        input wire [2 : 0] S_AXI_AWPROT,\n        input wire  S_AXI_AWVALID,\n        output wire  S_AXI_AWREADY,\n        input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,\n        input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,\n        input wire  S_AXI_WVALID,\n        output wire  S_AXI_WREADY,\n        output wire [1 : 0] S_AXI_BRESP,\n        output wire  S_AXI_BVALID,\n        input wire  S_AXI_BREADY,\n        input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,\n        input wire [2 : 0] S_AXI_ARPROT,\n        input wire  S_AXI_ARVALID,\n        output wire  S_AXI_ARREADY,\n        output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,\n        output wire [1 : 0] S_AXI_RRESP,\n        output wire  S_AXI_RVALID,\n        input wire  S_AXI_RREADY\n    );\n\n    reg [C_S_AXI_ADDR_WIDTH-1 : 0]     axi_awaddr;\n    reg      axi_awready;\n    reg      axi_wready;\n    reg [1 : 0]     axi_bresp;\n    reg      axi_bvalid;\n    reg [C_S_AXI_ADDR_WIDTH-1 : 0]     axi_araddr;\n    reg      axi_arready;\n    reg [C_S_AXI_DATA_WIDTH-1 : 0]     axi_rdata;\n    reg [1 : 0]     axi_rresp;\n    reg      axi_rvalid;\n\n    localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;\n    localparam integer OPT_MEM_ADDR_BITS = 1;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg0;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg1;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg2;\n    reg [C_S_AXI_DATA_WIDTH-1:0]    slv_reg3;\n    wire     slv_reg_rden;\n    wire     slv_reg_wren;\n    reg [C_S_AXI_DATA_WIDTH-1:0]     reg_data_out;\n    integer     byte_index;\n\n    assign S_AXI_AWREADY    = axi_awready;\n    assign S_AXI_WREADY    = axi_wready;\n    assign S_AXI_BRESP    = axi_bresp;\n    assign S_AXI_BVALID    = axi_bvalid;\n    assign S_AXI_ARREADY    = axi_arready;\n    assign S_AXI_RDATA    = axi_rdata;\n    assign S_AXI_RRESP    = axi_rresp;\n    assign S_AXI_RVALID    = axi_rvalid;\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awready <= 1'b0;\n        end\n      else\n        begin\n          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n            begin\n              axi_awready <= 1'b1;\n            end\n          else\n            begin\n              axi_awready <= 1'b0;\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awaddr <= 0;\n        end\n      else\n        begin\n          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)\n            begin\n              axi_awaddr <= S_AXI_AWADDR;\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_wready <= 1'b0;\n        end\n      else\n        begin\n          if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)\n            begin\n              axi_wready <= 1'b1;\n            end\n          else\n            begin\n              axi_wready <= 1'b0;\n            end\n        end\n    end\n\n    assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 || curr_state == counting)\n        begin\n          slv_reg0 <= 0;\n          slv_reg1 <= 0;\n          slv_reg2 <= 0;\n          end\n      else begin\n        if (slv_reg_wren)\n          begin\n            case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )\n              2'h0:\n                for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )\n                  if ( S_AXI_WSTRB[byte_index] == 1 ) begin\n                    slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];\n                  end\n              2'h1:\n                for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )\n                  if ( S_AXI_WSTRB[byte_index] == 1 ) begin\n                    slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];\n                  end\n              2'h2:\n                for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )\n                  if ( S_AXI_WSTRB[byte_index] == 1 ) begin\n                    slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];\n                  end\n              default : begin\n                          slv_reg0 <= slv_reg0;\n                          slv_reg1 <= slv_reg1;\n                          slv_reg2 <= slv_reg2;\n                          end\n            endcase\n          end\n      end\n    end\n\n    always @(posedge S_AXI_ACLK) begin\n      if (!S_AXI_ARESETN || curr_state == reset || curr_state == counting) begin\n        slv_reg3 <= 0;\n      end\n      else if (curr_state == finish) begin\n        slv_reg3 <= 1;\n      end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_bvalid  <= 0;\n          axi_bresp   <= 2'b0;\n        end\n      else\n        begin\n          if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)\n            begin\n              axi_bvalid <= 1'b1;\n              axi_bresp  <= 2'b0; end                   else\n            begin\n              if (S_AXI_BREADY && axi_bvalid)\n                begin\n                  axi_bvalid <= 1'b0;\n                end\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_arready <= 1'b0;\n          axi_araddr  <= 32'b0;\n        end\n      else\n        begin\n          if (~axi_arready && S_AXI_ARVALID)\n            begin\n              axi_arready <= 1'b1;\n              axi_araddr  <= S_AXI_ARADDR;\n            end\n          else\n            begin\n              axi_arready <= 1'b0;\n            end\n        end\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rvalid <= 0;\n          axi_rresp  <= 0;\n        end\n      else\n        begin\n          if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)\n            begin\n              axi_rvalid <= 1'b1;\n              axi_rresp  <= 2'b0; end\n          else if (axi_rvalid && S_AXI_RREADY)\n            begin\n              axi_rvalid <= 1'b0;\n            end\n        end\n    end\n\n    assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;\n    always @(*)\n    begin\n          case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )\n            2'h0   : reg_data_out <= slv_reg0;\n            2'h1   : reg_data_out <= slv_reg1;\n            2'h2   : reg_data_out <= slv_reg2;\n            2'h3   : reg_data_out <= slv_reg3;\n            default : reg_data_out <= 0;\n          endcase\n    end\n\n    always @( posedge S_AXI_ACLK )\n    begin\n      if ( S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rdata  <= 0;\n        end\n      else\n        begin\n          if (slv_reg_rden)\n            begin\n              axi_rdata <= reg_data_out;     end\n        end\n    end\n\n    reg [C_S_AXI_DATA_WIDTH - 1 : 0] reg_org;\n    reg [C_S_AXI_DATA_WIDTH - 1 : 0] reg_len;\n    reg [C_S_AXI_DATA_WIDTH - 1 : 0] reg_numOfSlv;\n\n    localparam LENGTH   = C_S_AXI_DATA_WIDTH / 2;\n\n    localparam reset    = 3'b001;\n    localparam counting = 3'b010;\n    localparam finish   = 3'b100;\n\n    reg [2 : 0] next_state;\n    reg [2 : 0] curr_state;\n\n    always @(posedge S_AXI_ACLK or negedge S_AXI_ARESETN) begin\n        if (!S_AXI_ARESETN) begin\n            reg_org       <= 0;\n            reg_len       <= 0;\n            reg_numOfSlv  <= 0;\n        end\n        else begin\n            if (curr_state == reset) begin\n                reg_org       <= slv_reg0;\n                reg_len       <= slv_reg1;\n                reg_numOfSlv  <= slv_reg2;\n            end\n            else begin\n                reg_org       <= reg_org;\n                reg_len       <= reg_len;\n                reg_numOfSlv  <= reg_numOfSlv;\n            end\n        end\n    end\n\n    always @(posedge S_AXI_ACLK or negedge S_AXI_ARESETN) begin\n        if (!S_AXI_ARESETN) begin\n            curr_state <= reset;\n        end\n        else begin\n            curr_state <= next_state;\n        end\n    end\n\n    wire data_ready;\n    assign data_ready = \n              (slv_reg1[C_S_AXI_DATA_WIDTH - 1 : LENGTH] != {LENGTH{1'b0}}) &&\n              (slv_reg1[LENGTH - 1 : 0] != {LENGTH{1'b0}});\n\n    always @(curr_state or data_ready or Finish) begin\n        case(curr_state)\n            reset:\n                if (data_ready) begin\n                    next_state = counting;\n                end\n                else begin\n                    next_state = reset;\n                end\n            counting:\n                if (Finish) begin\n                    next_state = finish;\n                end\n                else begin\n                    next_state = counting;\n                end\n            finish:\n                if (data_ready) begin\n                    next_state = reset;\n                end\n                else begin\n                    next_state = finish;\n                end\n            default :\n                next_state = 3'bxxx;\n        endcase\n    end\n\n    assign En = curr_state == counting;\n\n    assign org      = reg_org;\n    assign len      = reg_len;\n    assign numOfSlv = reg_numOfSlv;\n\n\n    endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_ba773431", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux4to1 (\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output Y\n);\n\n    wire Y_int;\n    wire not_s0 = ~S0;\n    wire not_s1 = ~S1;\n\n    assign Y_int = (A & not_s1 & not_s0) | (B & not_s1 & S0) | (C & S1 & not_s0) | (D & S1 & S0);\n    assign Y = Y_int;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_divider_582bb8d0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_divider (\n    input CLK,\n    input reset,\n    output reg CLK_div\n);\n\n    reg [3:0] counter;\n\n    always @ (posedge CLK or posedge reset) begin\n        if (reset) begin\n            counter <= 0;\n            CLK_div <= 0;\n        end\n        else begin\n            counter <= counter + 1;\n            if (counter == 4) begin\n                counter <= 0;\n                CLK_div <= ~CLK_div;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RetimeWrapper_580_34e4afd5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RetimeWrapper_580(\n  input         clock,\n  input         reset,\n  input  [39:0] io_in,\n  output [39:0] io_out\n);\n  wire [39:0] sr_out;\n  wire [39:0] sr_in;\n  wire  sr_flow;\n  wire  sr_reset;\n  wire  sr_clock;\n  \n  RetimeShiftRegister #(.WIDTH(40), .STAGES(1)) sr (\n    .out(sr_out),\n    .in(sr_in),\n    .flow(sr_flow),\n    .reset(sr_reset),\n    .clock(sr_clock)\n  );\n\n  assign io_out = sr_out;\n  assign sr_in = io_in;\n  assign sr_flow = 1'b1;\n  assign sr_reset = reset;\n  assign sr_clock = clock;\nendmodule\n\nmodule RetimeShiftRegister #(\n  parameter WIDTH = 8,\n  parameter STAGES = 1\n)(\n  output reg [WIDTH-1:0] out,\n  input [WIDTH-1:0] in,\n  input flow,\n  input reset,\n  input clock\n);\n  \n  always @ (posedge clock or posedge reset) begin\n    if (reset) begin\n      out <= 0;\n    end else if (flow) begin\n      out <= in;\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_43dd9c88", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo\n(\n    input clk,\n    input rst,\n    input [15:0] din,\n    input wr_en,\n    input rd_en,\n    output reg [15:0] dout,\n    output reg empty,\n    output reg full\n);\n\nreg [15:0] mem [0:7];\nreg [2:0] wr_ptr = 0;\nreg [2:0] rd_ptr = 0;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        wr_ptr <= 0;\n        rd_ptr <= 0;\n        empty <= 1;\n        full <= 0;\n    end else begin\n        if (wr_en && !full) begin\n            mem[wr_ptr] <= din;\n            wr_ptr <= wr_ptr + 1;\n            if (wr_ptr == 7) begin\n                wr_ptr <= 0;\n            end\n            empty <= 0;\n            if (wr_ptr == rd_ptr) begin\n                full <= 1;\n            end\n        end\n        if (rd_en && !empty) begin\n            dout <= mem[rd_ptr];\n            rd_ptr <= rd_ptr + 1;\n            if (rd_ptr == 7) begin\n                rd_ptr <= 0;\n            end\n            full <= 0;\n            if (rd_ptr == wr_ptr) begin\n                empty <= 1;\n            end\n        end\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_fa00d960", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder (\n  input [1:0] in,\n  input enable,\n  output [3:0] out\n);\n  \n  assign out[0] = ~(in[1] | in[0] | enable);\n  assign out[1] = ~(in[1] | ~in[0] | enable);\n  assign out[2] = ~(~in[1] | in[0] | enable);\n  assign out[3] = ~(~in[1] | ~in[0] | enable);\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "niosII_system_switches_280ea208", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule niosII_system_switches (\n                                // inputs:\n                                 address,\n                                 clk,\n                                 in_port,\n                                 reset_n,\n\n                                // outputs:\n                                 readdata\n                              )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  7: 0] in_port;\n  input            reset_n;\n\n  wire             clk_en;\n  wire    [  7: 0] data_in;\n  wire    [  7: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n  assign clk_en = 1;\n  \n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {8 {(address == 0)}} & data_in;\n  \n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en) begin\n          case (address)\n            2'b00: readdata <= {24'b0, data_in};\n            2'b01: readdata <= {24'b0, data_in};\n            2'b10: readdata <= {24'b0, data_in};\n            2'b11: readdata <= {data_in, data_in, data_in, data_in};\n            default: readdata <= 0;\n          endcase\n      end\n    end\n\n  assign data_in = in_port;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "debnce_ed986e61", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule debnce\n  (\n  input  wire        sync,\n  input  wire        clk,\n  output reg         event_on,\n  output reg         event_off\n  );\n\n  reg         [15:0] ctr;\n  reg                dly;\n  wire               sat;\n\n  assign sat = (ctr == 16'hffff);\n\n  always @(posedge clk)\n  begin : saturating_counter\n    case ({sync, sat})\n      0: ctr <= 0;\n      1: ctr <= 0;\n      2: ctr <= ctr + 1;\n    endcase\n    dly <= sat;\n    event_on  <= !dly && sat;\n    event_off <= !sat && dly;\n  end\n\n  endmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4_0cd01457", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = in2;\n        2'b11: out = in3;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ConvolutionalEncoderAndViterbiDecoder #_2eba92c8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ConvolutionalEncoderAndViterbiDecoder #(\n  parameter n = 4, // number of input bits\n  parameter m = 8 // number of output bits\n) (\n  input [n-1:0] in,\n  input clk,\n  output [m-1:0] out\n);\n\n\n// Convolutional Encoder\nreg [n-1:0] shift_reg;\nwire [m-1:0] encoded_bits;\n\nassign encoded_bits[0] = shift_reg[0] ^ shift_reg[1] ^ shift_reg[2] ^ shift_reg[3];\nassign encoded_bits[1] = shift_reg[0] ^ shift_reg[1] ^ shift_reg[3];\nassign encoded_bits[2] = shift_reg[0] ^ shift_reg[2] ^ shift_reg[3];\nassign encoded_bits[3] = shift_reg[1] ^ shift_reg[2] ^ shift_reg[3];\nassign encoded_bits[4] = shift_reg[0] ^ shift_reg[1] ^ shift_reg[2];\nassign encoded_bits[5] = shift_reg[0] ^ shift_reg[2];\nassign encoded_bits[6] = shift_reg[1] ^ shift_reg[3];\nassign encoded_bits[7] = shift_reg[2] ^ shift_reg[3];\n\nalways @(posedge clk) begin\n  shift_reg <= {shift_reg[n-1:0], in};\nend\n\n// Viterbi Decoder\nreg [n-1:0] state;\nreg [n-1:0] next_state;\nreg [n-1:0] decoded_bits;\n\nalways @(posedge clk) begin\n  state <= next_state;\n  decoded_bits <= state;\nend\n\nalways @(*) begin\n  case (state)\n    4'b0000: next_state = {state[2:0], encoded_bits[0]};\n    4'b0001: next_state = {state[2:0], encoded_bits[1]};\n    4'b0010: next_state = {state[2:0], encoded_bits[2]};\n    4'b0011: next_state = {state[2:0], encoded_bits[3]};\n    4'b0100: next_state = {state[2:0], encoded_bits[4]};\n    4'b0101: next_state = {state[2:0], encoded_bits[5]};\n    4'b0110: next_state = {state[2:0], encoded_bits[6]};\n    4'b0111: next_state = {state[2:0], encoded_bits[7]};\n    default: next_state = state;\n  endcase\nend\n\nassign out = decoded_bits;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bcd_ctr_72cfac93", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule bcd_ctr(clk, en, ar, dig1, dig2, dig3);\n  \n\n  \n  input clk, ar, en;\n  output reg  [3:0]  dig1, dig2, dig3;\n\n  \n  wire dig1_carry, dig2_carry, dig3_carry;\n\n  \n  assign dig1_carry = (dig1 == 4'd9); assign dig2_carry = dig1_carry&(dig2 == 4'd9); assign dig3_carry = dig2_carry&(dig3 == 4'd9); \n  always @ (posedge clk or negedge ar)\n  begin\n    if(~ar) begin\n      dig1 <= 4'd0;\n      dig2 <= 4'd0;\n      dig3 <= 4'd0;\n    end else if(~dig3_carry&en) begin\n      if(dig2_carry) begin\n        dig3 <= dig3 + 1; dig2 <= 0; dig1 <= 0;\n\n      end else if(dig1_carry) begin\n        dig2 <= dig2 + 1; dig1 <= 0; end else begin\n        dig1 <= dig1 + 1; end\n    end\n  end\n\n  endmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "opcode_decoder_85da0f30", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule opcode_decoder(CCLK, rst, instr, IF);\n\tinput CCLK, rst;\n\tinput [31:0] instr;\n\toutput reg [7:0] IF;\n\n\talways @(posedge CCLK)\n\tbegin\n\t\tif (rst)\n\t\t\tIF = 8'd0;\n\t\telse\n\t\tbegin\n\t\t\tcase (instr[31:26])\n\t\t\t\t6'b000000:\n\t\t\t\tbegin \n\t\t\t\t\tcase (instr[5:0])\n\t\t\t\t\t\t6'b100000:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tIF = (|instr[15:11]) ? 8'd1 : 8'd0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t6'b100010: IF = 8'd2;\n\t\t\t\t\t\t6'b100100: IF = 8'd3;\n\t\t\t\t\t\t6'b100101: IF = 8'd4;\n\t\t\t\t\t\t6'b000000: IF = 8'd5;\n\t\t\t\t\t\t6'b000010: IF = 8'd6;\n\t\t\t\t\t\t6'b000011: IF = 8'd7;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\t6'b001000: IF = 8'd8;\n\t\t\t\t6'b001100: IF = 8'd9;\n\t\t\t\t6'b001101: IF = 8'd10;\n\t\t\t\t6'b100011: IF = 8'd11;\n\t\t\t\t6'b101011: IF = 8'd12;\n\t\t\t\t6'b000100: IF = 8'd13;\n\t\t\t\t6'b000101: IF = 8'd14;\n\t\t\t\t6'b000010: IF = 8'd15;\n\t\t\t\tdefault: IF = 8'd0;\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_a25a2953", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input CLK,\n    input RST,\n    output [3:0] Q\n);\n\n    // Local signals\n    wire [3:0] Q_next;\n\n    // D flip-flops\n    reg [3:0] Q_reg;\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q_reg <= 4'b0000;\n        end else begin\n            Q_reg <= Q_next;\n        end\n    end\n\n    // Combinational logic\n    assign Q_next = (Q_reg == 4'b1111) ? 4'b0000 : Q_reg + 1'b1;\n    assign Q = Q_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcieCore_gtp_pipe_rate #_76bfde46", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule pcieCore_gtp_pipe_rate #\n(\n\n    parameter PCIE_SIM_SPEEDUP = \"FALSE\",                   parameter TXDATA_WAIT_MAX  = 4'd15                      )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_DRP_DONE,\n    input               RATE_RXPMARESETDONE,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output              RATE_DRP_START,\n    output              RATE_DRP_X16,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [ 4:0]  RATE_FSM\n\n);\n\n        reg         [ 1:0]  rate_in_reg1;\n    reg                 drp_done_reg1;\n    reg                 rxpmaresetdone_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg         [ 1:0]  rate_in_reg2;\n    reg                 drp_done_reg2;\n    reg                 rxpmaresetdone_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel =  1'd0; \n    reg         [ 2:0]  rate_out =  3'd0; \n    reg         [ 3:0]  fsm      =  0;                 \n   \n    localparam          FSM_IDLE           = 0; \n    localparam          FSM_TXDATA_WAIT    = 1;           \n    localparam          FSM_PCLK_SEL       = 2; \n    localparam          FSM_DRP_X16_START  = 3;\n    localparam          FSM_DRP_X16_DONE   = 4;   \n    localparam          FSM_RATE_SEL       = 5;\n    localparam          FSM_RXPMARESETDONE = 6; \n    localparam          FSM_DRP_X20_START  = 7;\n    localparam          FSM_DRP_X20_DONE   = 8;   \n    localparam          FSM_RATE_DONE      = 9;\n    localparam          FSM_TXSYNC_START   = 10;\n    localparam          FSM_TXSYNC_DONE    = 11;             \n    localparam          FSM_DONE           = 12; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rate_in_reg1        <= 2'd0;\n        drp_done_reg1       <= 1'd0;\n        rxpmaresetdone_reg1 <= 1'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        drp_done_reg2       <= 1'd0;\n        rxpmaresetdone_reg2 <= 1'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rate_in_reg1        <= RATE_RATE_IN;\n        drp_done_reg1       <= RATE_DRP_DONE;\n        rxpmaresetdone_reg1 <= RATE_RXPMARESETDONE;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rate_in_reg2        <= rate_in_reg1;\n        drp_done_reg2       <= drp_done_reg1;\n        rxpmaresetdone_reg2 <= rxpmaresetdone_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if ((fsm == FSM_RATE_DONE) || (fsm == FSM_RXPMARESETDONE) || (fsm == FSM_DRP_X20_START) || (fsm == FSM_DRP_X20_DONE))\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm      <= FSM_IDLE;\n        pclk_sel <= 1'd0; \n        rate_out <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm      <= FSM_TXDATA_WAIT;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            else\n                begin\n                fsm      <= FSM_IDLE;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            end \n            \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm      <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_SEL : FSM_DRP_X16_START;    \n            pclk_sel <= (rate_in_reg2 == 2'd1);\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X16_DONE : FSM_DRP_X16_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_SEL : FSM_DRP_X16_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_DONE : FSM_RXPMARESETDONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate;                               end    \n            \n        FSM_RXPMARESETDONE :\n        \n            begin\n            fsm      <= (!rxpmaresetdone_reg2) ? FSM_DRP_X20_START : FSM_RXPMARESETDONE;  \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end  \n            \n        FSM_DRP_X20_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X20_DONE : FSM_DRP_X20_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X20_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_DONE : FSM_DRP_X20_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone) \n                fsm <= FSM_TXSYNC_START;\n            else      \n                fsm <= FSM_RATE_DONE;\n            \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm      <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm      <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm      <= FSM_IDLE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm      <= FSM_IDLE;\n            pclk_sel <= 1'd0; \n            rate_out <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL     = pclk_sel;\nassign RATE_DRP_START    = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X20_START); \nassign RATE_DRP_X16      = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X16_DONE);\nassign RATE_RATE_OUT     = rate_out;\nassign RATE_TXSYNC_START = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE         = (fsm == FSM_DONE);\nassign RATE_IDLE         = (fsm == FSM_IDLE);\nassign RATE_FSM          = {1'd0, fsm};   \n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "log2_table_5c624209", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule log2_table\n\t(\n\tinput\t     \tclk,\t\t\tinput\t\ttrilinear_en, \t\tinput\t[31:0]\tval, \t\t\toutput\t[9:0]\tlog2\n\t);\n\n\n\treg\t[3:0]\tint_mm_no;\n\treg\t[5:0]\tlod_fract;\n\n\twire\t\t over_flow;\n\twire\t[9:0]\t log_in;\n\n\tassign log_in = val[17:8];\n\tassign over_flow = |val[31:18];\n\n\n\nalways @(posedge clk) begin\n\tcasex ({over_flow, log_in})\n\t\t11'b0_10xxxxxxx_x, 11'b0_011xxxxxx_x:\tbegin if(trilinear_en && log_in[9]) begin\n\t\t\t\tint_mm_no <= 4'h9; \n\t\t\t\tlod_fract <= val[16:11];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h8;\n\t\t\t\tlod_fract <= val[15:10];\n\t\t\tend\n\t\tend\t\n\t\t11'b0_010xxxxxx_x, 11'b0_0011xxxxx_x: begin if(trilinear_en && log_in[8]) begin\n\t\t\t\tint_mm_no <= 4'h8; \n\t\t\t\tlod_fract <= val[15:10];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h7;\n\t\t\t\tlod_fract <= val[14:9];\n\t\t\tend\n\t\tend\n\t\t11'b0_0010xxxxx_x, 11'b0_00011xxxx_x:\tbegin if(trilinear_en && log_in[7]) begin\n\t\t\t\tint_mm_no <= 4'h7; \n\t\t\t\tlod_fract <= val[14:9];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h6;\n\t\t\t\tlod_fract <= val[13:8];\n\t\t\tend\n\t\tend\n\t\t11'b0_00010xxxx_x, 11'b0_000011xxx_x:\tbegin if(trilinear_en && log_in[6]) begin\n\t\t\t\tint_mm_no <= 4'h6; \n\t\t\t\tlod_fract <= val[13:8];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h5;\n\t\t\t\tlod_fract <= val[12:7];\n\t\t\tend\n\t\tend\n\t\t11'b0_000010xxx_x, 11'b0_0000011xx_x:\tbegin if(trilinear_en && log_in[5]) begin\n\t\t\t\tint_mm_no <= 4'h5; \n\t\t\t\tlod_fract <= val[12:7];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h4;\n\t\t\t\tlod_fract <= val[11:6];\n\t\t\tend\n\t\tend\n\t\t11'b0_0000010xx_x, 11'b0_00000011x_x:\tbegin if(trilinear_en && log_in[4]) begin\n\t\t\t\tint_mm_no <= 4'h4; \n\t\t\t\tlod_fract <= val[11:6];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h3;\n\t\t\t\tlod_fract <= val[10:5];\n\t\t\tend\n\t\tend\n\t\t11'b0_00000010x_x, 11'b0_000000011_x:\tbegin if(trilinear_en && log_in[3]) begin\n\t\t\t\tint_mm_no <= 4'h3; \n\t\t\t\tlod_fract <= val[10:5];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h2;\n\t\t\t\tlod_fract <= val[9:4];\n\t\t\tend\n\t\tend\n\t\t11'b0_000000010_x, 11'b0_000000001_1:\tbegin if(trilinear_en && log_in[2]) begin\n\t\t\t\tint_mm_no <= 4'h2; \n\t\t\t\tlod_fract <= val[9:4];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h1;\n\t\t\t\tlod_fract <= val[8:3];\n\t\t\tend\n\t\tend\n\t\t11'b0_000000001_0, 11'b0_000000000_x:\tbegin if(trilinear_en && log_in[1]) begin\n\t\t\t\tint_mm_no <= 4'h1; \n\t\t\t\tlod_fract <= val[8:3];\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tint_mm_no <= 4'h0;\n\t\t\t\tlod_fract <= val[7:2];\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\t\tint_mm_no <= 4'h9; \n\t\t\t\tlod_fract <= val[16:11];\n\t\tend\n\tendcase\nend\n\nassign log2 = {int_mm_no, lod_fract};\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_988343a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\nassign S = A ^ B ^ Cin;\nassign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire c1, c2, c3;\n\nfull_adder fa1(\n    .A(A[0]),\n    .B(B[0]),\n    .Cin(Cin),\n    .S(S[0]),\n    .Cout(c1)\n);\n\nfull_adder fa2(\n    .A(A[1]),\n    .B(B[1]),\n    .Cin(c1),\n    .S(S[1]),\n    .Cout(c2)\n);\n\nfull_adder fa3(\n    .A(A[2]),\n    .B(B[2]),\n    .Cin(c2),\n    .S(S[2]),\n    .Cout(c3)\n);\n\nfull_adder fa4(\n    .A(A[3]),\n    .B(B[3]),\n    .Cin(c3),\n    .S(S[3]),\n    .Cout(Cout)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_93527bb3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate (\n    input A,\n    input B,\n    output X\n);\n\n\n   assign X = A & B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "TLATNTSCAX2TS_a98c49f8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule TLATNTSCAX2TS ( E, SE, CK, ECK );\n  input E, SE, CK;\n  output ECK;\n\n  reg ECK;\n\n  always @(posedge CK) begin\n    if (SE) begin\n      ECK <= 1'b1;\n    end else if (E) begin\n      ECK <= 1'b0;\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "five_to_one_6eae0b9d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule five_to_one (\n    input  A1  ,\n    input  A2  ,\n    input  A3  ,\n    input  B1  ,\n    input  B2  ,\n    output X   ,\n\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    wire A_high = A1 & A2 & A3;\n    wire B_low = ~B1 & ~B2;\n    wire B_high = B1 & B2;\n\n    assign X = (A_high & B_low) | (~A_high & B_high);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_generator_590bc676", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule data_generator(\n    input  wire CLK,\n    input  wire CE,\n    output wire D1,\n    output wire D2\n);\n\n    reg [254:0] ring1;\n    initial ring1 <= 255'b010100110101100010111100101101010010011100001110110010000001011011011111011000101110100111001101101100110111101100001111100110000001011011010000111011000010001010101000101111101110110111100110110000001100101111111011010111100001101100001101111111001110111;\n\n    reg [255:0] ring2;\n    initial ring2 <= 256'b1010101100101110000100100101010000100000101110111011110111011111000111101101010101110111010011011101100100011111111101101000111110110110100010011011001001000011100011001001110001110101000001010011011001100101000001011111011101010000110011101111110100110010;\n\n    reg [256:0] ring3;\n    initial ring3 <= 257'b10000001100111000110101001001111100011011001100011011111000100110100110001011101100111110101101111101011000101110100100110110010000111100011111101010000000100101000100100110101011111011000100100001001100110101011111101101011011100010101000111110010110011110;\n\n    always @(posedge CLK)\n        if (CE) ring1 <= {ring1[0], ring1[254:1]};\n    always @(posedge CLK)\n        if (CE) ring2 <= {ring2[0], ring2[255:1]};\n    always @(posedge CLK)\n        if (CE) ring3 <= {ring3[0], ring3[256:1]};\n\n    assign D1 = ring1[0] ^ ring2[0];\n    assign D2 = ring2[0] ^ ring3[0];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "trafficLightController_9cad11dc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule trafficLightController (\ninput wire clk ,\ninput wire clr ,\noutput reg [5:0] lights\n);\nreg [2:0] state;\nreg [3:0] count;\nparameter S0 = 3'b000, S1 =3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101;\nparameter SEC5 = 4'b0101, SEC1 = 4'b0001; always @(posedge clk or posedge clr)\n begin\n if (clr == 1)\n begin\n state = S0;\n count = 0;\n end\n else\n case(state)\n S0: if(count < SEC5)\n begin\n state = S0;\n count = count + 1'b1;\n end\n else\n begin\n state = S1;\n count = 0;\n end\n S1: if(count < SEC1)\n begin\n state = S1;\n count = count + 1'b1;\n end\n else\n begin\n state = S2;\n count = 0;\n end\n S2: if(count < SEC1)\n begin\n state = S2;\n count = count + 1'b1;\n end\n else\n begin\n state = S3;\n count = 0;\n end \nS3: if(count < SEC5)\n begin\n state = S3;\n count = count + 1'b1;\n end\n else\n begin\n state = S4;\n count = 0;\n end\n S4: if(count < SEC1)\n begin\n state = S4;\n count = count + 1'b1;\n end\n else\n begin\n state = S5;\n count = 0;\n end\n S5: if(count < SEC1)\n begin\n state = S5;\n count = count + 1'b1;\n end\n else\n begin\n state = S0;\n count = 0;\n end\ndefault state = S0;\n endcase\n end\nalways @(*)\n begin\n case(state)\n S0: lights = 6'b100001;\n S1: lights = 6'b100010;\n S2: lights = 6'b100100;\n S3: lights = 6'b001100;\n S4: lights = 6'b010100;\n S5: lights = 6'b100100;\n default lights = 6'b100001;\n endcase\n end\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_87eee71c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder (\n    input sel2,\n    input sel1,\n    input sel0,\n    input clk,\n    output reg [63:0] out\n);\n\nreg [63:0] stage1_out;\nreg [63:0] stage2_out;\n\nalways @(*) begin\n    if(sel2 == 0 && sel1 == 0 && sel0 == 0) begin\n        stage1_out[0] <= 1'b1;\n        stage1_out[63:1] <= 64'b0;\n    end\n    else if(sel2 == 1 && sel1 == 0 && sel0 == 0) begin\n        stage1_out[8] <= 1'b1;\n        stage1_out[63:9] <= 56'b0;\n        stage1_out[7:0] <= 8'b0;\n    end\n    else if(sel2 == 0 && sel1 == 1 && sel0 == 1) begin\n        stage1_out[56] <= 1'b1;\n        stage1_out[63:57] <= 56'b0;\n    end\n    else if(sel2 == 1 && sel1 == 1 && sel0 == 0) begin\n        stage1_out[60] <= 1'b1;\n        stage1_out[63:61] <= 3'b0;\n        stage1_out[60:0] <= 60'b0;\n    end\n    else if(sel2 == 0 && sel1 == 1 && sel0 == 1) begin\n        stage1_out[48] <= 1'b1;\n        stage1_out[63:49] <= 15'b0;\n        stage1_out[48:0] <= 48'b0;\n    end\n    else begin\n        stage1_out[63:48] <= 16'b0;\n        stage1_out[47:0] <= 48'b0;\n    end\nend\n\nalways @(posedge clk) begin\n    stage2_out <= stage1_out;\nend\n\nalways @* begin\n    out = stage2_out;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "long_to_double_03e9b678", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule long_to_double(\n        input_a,\n        input_a_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [63:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  output    [63:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [63:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [2:0] state;\n  parameter get_a         = 3'd0,\n            convert_0     = 3'd1,\n            convert_1     = 3'd2,\n            convert_2     = 3'd3,\n            round         = 3'd4,\n            pack          = 3'd5,\n            put_z         = 3'd6;\n\n  reg [63:0] a, z, value;\n  reg [52:0] z_m;\n  reg [10:0] z_r;\n  reg [10:0] z_e;\n  reg z_s;\n  reg guard, round_bit, sticky;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= convert_0;\n        end\n      end\n\n      convert_0:\n      begin\n        if ( a == 0 ) begin\n          z_s <= 0;\n          z_m <= 0;\n          z_e <= -1023;\n          state <= pack;\n        end else begin\n          value <= a[63] ? -a : a;\n          z_s <= a[63];\n          state <= convert_1;\n        end\n      end\n\n      convert_1:\n      begin\n        z_e <= 63;\n        z_m <= value[63:11];\n        z_r <= value[10:0];\n        state <= convert_2;\n      end\n\n      convert_2:\n      begin\n        if (!z_m[52]) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= z_r[10];\n          z_r <= z_r << 1;\n        end else begin\n          guard <= z_r[10];\n          round_bit <= z_r[9];\n          sticky <= z_r[8:0] != 0;\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit || sticky || z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 53'h1fffffffffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[51 : 0] <= z_m[51:0];\n        z[62 : 52] <= z_e + 1023;\n        z[63] <= z_s;\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tmu2_mask_3c653f2f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule tmu2_mask(\n\tinput sys_clk,\n\tinput sys_rst,\n\n\toutput busy,\n\n\tinput pipe_stb_i,\n\toutput pipe_ack_o,\n\tinput signed [11:0] dx,\n\tinput signed [11:0] dy,\n\tinput signed [17:0] tx,\n\tinput signed [17:0] ty,\n\n\tinput [17:0] tex_hmask,\n\tinput [17:0] tex_vmask,\n\n\toutput reg pipe_stb_o,\n\tinput pipe_ack_i,\n\toutput reg signed [11:0] dx_f,\n\toutput reg signed [11:0] dy_f,\n\toutput reg signed [17:0] tx_m,\n\toutput reg signed [17:0] ty_m\n);\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tpipe_stb_o <= 1'b0;\n\telse begin\n\t\tif(pipe_ack_i)\n\t\t\tpipe_stb_o <= 1'b0;\n\t\tif(pipe_stb_i & pipe_ack_o) begin\n\t\t\tpipe_stb_o <= 1'b1;\n\t\t\tdx_f <= dx;\n\t\t\tdy_f <= dy;\n\t\t\ttx_m <= tx & tex_hmask;\n\t\t\tty_m <= ty & tex_vmask;\n\t\tend\n\tend\nend\n\nassign pipe_ack_o = ~pipe_stb_o | pipe_ack_i;\n\nassign busy = pipe_stb_o;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_1bit_a75f320e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_1bit (\n  input ctrl,\n  input [0:0] D0,\n  input [0:0] D1,\n  output reg [0:0] S\n);\n\n  always @(*) begin\n    case(ctrl)\n      1'b0: S = D0;\n      1'b1: S = D1;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_ca780195", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule calculator (\n    input [3:0] num1,\n    input [3:0] num2,\n    input [1:0] op_type,\n    output [7:0] result,\n    output overflow\n);\n\n    wire [7:0] adder_out;\n    wire [7:0] multiplier_out;\n    wire [7:0] num1_extended;\n    wire [7:0] num2_extended;\n    wire [3:0] highest_bit_num1;\n    wire [3:0] highest_bit_num2;\n    wire [3:0] highest_bit;\n    wire [7:0] zero;\n    assign zero = 8'b0;\n    assign overflow = (adder_out[7] == adder_out[6] && adder_out[6] != op_type[0]);\n\n    // Convert 4-bit numbers to 8-bit numbers\n    assign num1_extended = {4'b0, num1};\n    assign num2_extended = {4'b0, num2};\n\n    // Priority encoder to detect highest bit\n    assign highest_bit_num1 = (num1_extended[7]) ? 4'b1000 :\n                             (num1_extended[6]) ? 4'b0100 :\n                             (num1_extended[5]) ? 4'b0010 :\n                             (num1_extended[4]) ? 4'b0001 :\n                             4'b0000;\n    assign highest_bit_num2 = (num2_extended[7]) ? 4'b1000 :\n                             (num2_extended[6]) ? 4'b0100 :\n                             (num2_extended[5]) ? 4'b0010 :\n                             (num2_extended[4]) ? 4'b0001 :\n                             4'b0000;\n    assign highest_bit = (highest_bit_num1 > highest_bit_num2) ? highest_bit_num1 : highest_bit_num2;\n\n    // Carry-lookahead adder for addition and subtraction\n    CLA_adder adder(\n        .A(num1_extended),\n        .B(num2_extended),\n        .Cin(op_type[0]),\n        .Sum(adder_out),\n        .Cout()\n    );\n\n    // Repeated addition for multiplication\n    assign multiplier_out = (op_type[1]) ? num1_extended * num2_extended : 8'b0;\n\n    // Select final output based on operation type\n    assign result = (op_type == 2'b00) ? adder_out :\n                    (op_type == 2'b01) ? adder_out :\n                    multiplier_out;\n\nendmodule\nmodule CLA_adder (\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    wire [7:0] P;\n    wire [7:0] G;\n    wire [7:0] C;\n    wire [7:0] C_propagate;\n    wire [7:0] C_generate;\n\n    assign P = A ^ B;\n    assign G = A & B;\n    assign C_propagate[0] = Cin;\n    assign C_generate[0] = G[0];\n    generate\n        genvar i;\n        for (i = 1; i < 8; i = i + 1) begin : generate_CLA\n            assign C_propagate[i] = P[i-1];\n            assign C_generate[i] = G[i] | (P[i] & C_generate[i-1]);\n        end\n    endgenerate\n\n    assign C = C_propagate | C_generate;\n    assign Sum = P ^ Cin;\n    assign Cout = C[7];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "robotic_arm_controller_c295b48a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule robotic_arm_controller (\n    input clk,\n    input btn,\n    output reg [0:0] X\n);\n\n    reg [1:0] pos = 2'b00; // initialize arm position to 0\n\n    always @(posedge clk) begin\n        if (btn) begin\n            // move arm to next position in sequence\n            pos <= pos + 1;\n            if (pos == 2'b10) // reset to position 0\n                pos <= 2'b00;\n        end\n    end\n\n    always @(*) begin\n        X = pos[0];\n    end\n    \nendmodule\n\nmodule sky130_fd_sc_hd__o21ba_1 (\n    input X,\n    input A1,\n    input A2,\n    input B1_N\n);\n\n    // Implement the functionality of the arm module\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cordic_demod_5e29e978", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cordic_demod (\n\tinput clk,\n\tinput resetn,\n\n\tinput s_axis_valid,\n\toutput s_axis_ready,\n\tinput [63:0] s_axis_data,\n\n\toutput m_axis_valid,\n\tinput m_axis_ready,\n\toutput [63:0] m_axis_data\n);\n\nreg [4:0] step_counter;\nreg [4:0] shift_counter;\nreg [30:0] phase;\nreg [2:0] state;\n\nreg [32:0] i;\nreg [32:0] q;\nreg [32:0] i_shift;\nreg [32:0] q_shift;\n\nassign s_axis_ready = state == STATE_IDLE;\nassign m_axis_data = {q[32:1],i[32:1]};\nassign m_axis_valid = state == STATE_DONE;\n\nlocalparam STATE_IDLE = 0;\nlocalparam STATE_SHIFT_LOAD = 1;\nlocalparam STATE_SHIFT = 2;\nlocalparam STATE_ADD = 3;\nlocalparam STATE_DONE = 4;\n\nreg [31:0] angle[0:30];\n\ninitial begin\n\tangle[0] = 32'h20000000;\n\tangle[1] = 32'h12e4051e;\n\tangle[2] = 32'h09fb385b;\n\tangle[3] = 32'h051111d4;\n\tangle[4] = 32'h028b0d43;\n\tangle[5] = 32'h0145d7e1;\n\tangle[6] = 32'h00a2f61e;\n\tangle[7] = 32'h00517c55;\n\tangle[8] = 32'h0028be53;\n\tangle[9] = 32'h00145f2f;\n\tangle[10] = 32'h000a2f98;\n\tangle[11] = 32'h000517cc;\n\tangle[12] = 32'h00028be6;\n\tangle[13] = 32'h000145f3;\n\tangle[14] = 32'h0000a2fa;\n\tangle[15] = 32'h0000517d;\n\tangle[16] = 32'h000028be;\n\tangle[17] = 32'h0000145f;\n\tangle[18] = 32'h00000a30;\n\tangle[19] = 32'h00000518;\n\tangle[20] = 32'h0000028c;\n\tangle[21] = 32'h00000146;\n\tangle[22] = 32'h000000a3;\n\tangle[23] = 32'h00000051;\n\tangle[24] = 32'h00000029;\n\tangle[25] = 32'h00000014;\n\tangle[26] = 32'h0000000a;\n\tangle[27] = 32'h00000005;\n\tangle[28] = 32'h00000003;\n\tangle[29] = 32'h00000001;\n\tangle[30] = 32'h00000001;\nend\n\nalways @(posedge clk) begin\n\tif (resetn == 1'b0) begin\n\t\tstate <= STATE_IDLE;\n\tend else begin\n\t\tcase (state)\n\t\tSTATE_IDLE: begin\n\t\t\tif (s_axis_valid == 1'b1) begin\n\t\t\t\tstate <= STATE_SHIFT_LOAD;\n\t\t\tend\n\t\tend\n\t\tSTATE_SHIFT_LOAD: begin\n\t\t\tif (step_counter == 'h00) begin\n\t\t\t\tstate <= STATE_ADD;\n\t\t\tend else begin\n\t\t\t\tstate <= STATE_SHIFT;\n\t\t\tend\n\t\tend\n\t\tSTATE_SHIFT: begin\n\t\t\tif (shift_counter == 'h01) begin\n\t\t\t\tstate <= STATE_ADD;\n\t\t\tend\n\t\tend\n\t\tSTATE_ADD: begin\n\t\t\tif (step_counter == 'd30) begin\n\t\t\t\tstate <= STATE_DONE;\n\t\t\tend else begin\n\t\t\t\tstate <= STATE_SHIFT_LOAD;\n\t\t\tend\n\t\tend\n\t\tSTATE_DONE: begin\n\t\t\tif (m_axis_ready == 1'b1)\n\t\t\t\tstate <= STATE_IDLE;\n\t\tend\n\t\tendcase\n\tend\nend\n\nalways @(posedge clk) begin\n\tcase(state)\n\tSTATE_SHIFT_LOAD: begin\n\t\tshift_counter <= step_counter;\n\tend\n\tSTATE_SHIFT: begin\n\t\tshift_counter <= shift_counter - 1'b1;\n\tend\n\tendcase\nend\n\nalways @(posedge clk)\nbegin\n\tcase(state)\n\tSTATE_IDLE:\n\t\tif (s_axis_valid == 1'b1) begin\n\t\t\tstep_counter <= 'h00;\n\t\t\tphase <= {1'b0,s_axis_data[61:32]};\n\t\t\tstep_counter <= 'h00;\n\t\t\tcase (s_axis_data[63:62])\n\t\t\t2'b00: begin\n\t\t\t\ti <= {s_axis_data[31],s_axis_data[31:0]};\n\t\t\t\tq <= 'h00;\n\t\t\tend\n\t\t\t2'b01: begin\n\t\t\t\ti <= 'h00;\n\t\t\t\tq <= ~{s_axis_data[31],s_axis_data[31:0]};\n\t\t\tend\n\t\t\t2'b10: begin\n\t\t\t\ti <= ~{s_axis_data[31],s_axis_data[31:0]};\n\t\t\t\tq <= 'h00;\n\t\t\tend\n\t\t\t2'b11: begin\n\t\t\t\ti <= 'h00;\n\t\t\t\tq <= {s_axis_data[31],s_axis_data[31:0]};\n\t\t\tend\n\t\t\tendcase\n\t\tend\n\tSTATE_SHIFT_LOAD: begin\n\t\ti_shift <= i;\n\t\tq_shift <= q;\n\tend\n\tSTATE_SHIFT: begin\n\t\ti_shift <= {i_shift[32],i_shift[32:1]};\n\t\tq_shift <= {q_shift[32],q_shift[32:1]};\n\tend\n\tSTATE_ADD: begin\n\t\tif (phase[30] == 1'b0) begin\n\t\t\ti <= i + q_shift;\n\t\t\tq <= q - i_shift;\n\t\t\tphase <= phase - angle[step_counter];\n\t\tend else begin\n\t\t\ti <= i - q_shift;\n\t\t\tq <= q + i_shift;\n\t\t\tphase <= phase + angle[step_counter];\n\t\tend\n\t\tstep_counter <= step_counter + 1'b1;\n\tend\n\tendcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "edgedetect_005731c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule edgedetect (\n    input iCLK      ,\n    input iRST      ,\n    input iSIG      ,\n    output wire oRE ,\n    output wire oFE ,\n    output wire oRFE\n);\n\nparameter registered = \"FALSE\";\n\nreg delay;\n\nwire re;\nwire fe;\nwire rfe;\n\n\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        delay <= 1'b0;\n    end\n    else\n    begin\n        delay <= iSIG;\n    end\nend\n\n\n// Edge detect logic\nassign re   = (iSIG && !delay) ? 1'b1 : 1'b0;\nassign fe   = (!iSIG && delay) ? 1'b1 : 1'b0;\nassign rfe  = ((iSIG && !delay) || (!iSIG && delay)) ? 1'b1 : 1'b0;\n\n\n// Register edge detect pulses\nreg re_reg, fe_reg, rfe_reg;\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        re_reg     <= 1'b0;\n        fe_reg     <= 1'b0;\n        rfe_reg    <= 1'b0;\n    end\n    else\n    begin\n        re_reg     <= re;\n        fe_reg     <= fe;\n        rfe_reg    <= rfe;\n    end\nend\n\n\n// MUX either the combination or registered edge detect pulses to the outputs\nassign oRE =    (registered == \"TRUE\") ? re_reg  : re ;\nassign oFE =    (registered == \"TRUE\") ? fe_reg  : fe ;\nassign oRFE =   (registered == \"TRUE\") ? rfe_reg : rfe;\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "freq_divider #_b13f2218", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule freq_divider #(\n  parameter width = 8 // width of the output signal\n)(\n  input clk,\n  input rst,\n  input [7:0] div,\n  output reg [width-1:0] out\n);\n\n\nreg [7:0] count;\nreg toggle;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    count <= 0;\n    out <= 0;\n    toggle <= 0;\n  end else begin\n    count <= count + 1;\n    if (count == div) begin\n      toggle <= ~toggle;\n      count <= 0;\n    end\n    out <= toggle;\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__32ae27f1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [15:0] in,\n    input [3:0] sel,\n    input EN,\n    input [3:0] A,\n    input [3:0] B,\n    input [2:0] op,\n    output reg [3:0] out,\n    output reg valid\n);\n\nreg [3:0] mux_out;\nreg [3:0] alu_out;\n\n// 16-to-1 multiplexer\nalways @(*) begin\n    case(sel)\n        4'd0: mux_out = in[3:0];\n        4'd1: mux_out = in[7:4];\n        4'd2: mux_out = in[11:8];\n        4'd3: mux_out = in[15:12];\n        default: mux_out = 4'b0;\n    endcase\nend\n\n// 4-bit ALU\nalways @(*) begin\n    case(op)\n        3'b000: alu_out = A + B;\n        3'b001: alu_out = A - B;\n        3'b010: alu_out = A & B;\n        3'b011: alu_out = A | B;\n        3'b100: alu_out = A ^ B;\n        default: alu_out = 4'b0;\n    endcase\nend\n\n// Final output module\nalways @(*) begin\n    if(valid) begin\n        out = alu_out;\n    end else if(EN) begin\n        out = mux_out;\n    end else begin\n        out = 4'b0;\n    end\n    \n    valid = (op != 3'b101);\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xadc_data_demux_8964d56d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule xadc_data_demux \n    (\n     input             clk,\n     input             reset,\n\n     input [15:0]      xadc_data,\n     input             xadc_data_ready,\n     input [4:0]       channel,\n     output reg [15:0] xadc_vaux0_data,\n     output reg        xadc_vaux0_ready,\n     output reg [15:0] xadc_vaux8_data,\n     output reg        xadc_vaux8_ready\n     );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            xadc_vaux0_data  <= 16'd0;\n            xadc_vaux0_ready <= 1'b0;\n        end\n        else\n            if (xadc_data_ready && (channel == 5'h10)) begin\n                xadc_vaux0_data  <= xadc_data;\n                xadc_vaux0_ready <= 1'b1;\n            end \n            else\n                xadc_vaux0_ready <= 1'b0;\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            xadc_vaux8_data  <= 16'd0;\n            xadc_vaux8_ready <= 1'b0;\n        end\n        else\n            if (xadc_data_ready && (channel == 5'h18)) begin\n                xadc_vaux8_data  <= xadc_data;\n                xadc_vaux8_ready <= 1'b1;\n            end\n            else\n                xadc_vaux8_ready <= 1'b0;\n    end\n    \nendmodule\n\n                \n            \n\n    \n    \n    \n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ECC_memory_block#_bcabed1d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ECC_memory_block#(\n    parameter n=8,\n    parameter m=4\n)(\n    input [n-1:0] data_in,\n    input we,\n    output [n-1:0] data_out,\n    input re\n);\n\nreg [n+m-1:0] memory_block;\nreg [n-1:0] corrected_data;\nreg read_enable;\n\nfunction [n+m-1:0] hamming_encode;\n    input [n-1:0] data;\n        integer i, j, parity_pos;\n        begin\n            for(i=0;i<n;i=i+1)\n                begin\n                    hamming_encode[i+m]=data[i];\n                end\n            for(i=0;i<m;i=i+1)\n                begin\n                    parity_pos=2**i;\n                    hamming_encode[parity_pos-1]=0;\n                    for(j=0;j<n+m;j=j+1)\n                        begin\n                            if((j+1)&parity_pos)\n                                begin\n                                    hamming_encode[parity_pos-1]=hamming_encode[parity_pos-1]^hamming_encode[j]; \n                                end\n                        end\n                end\n        end\nendfunction\n\nfunction [n-1:0] hamming_decode;\n     input [n+m-1:0] encoded_data;\n         integer i,j,parity_pos,error_pos;\n         reg [n+m-1:0] corrected_encoded_data;\n         begin\n             error_pos=0;\n             for(i=0;i<m;i=i+1)\n                begin\n                    parity_pos=2**i;\n                    for(j=0;j<n+m;j=j+1)\n                    begin\n                        if((j+1)&parity_pos)\n                            begin\n                                if(encoded_data[j])\n                                    begin\n                                        error_pos=error_pos^(j+1);\n                                    end\n                            end\n                    end\n                end\n            corrected_encoded_data=encoded_data;\n            if(error_pos)\n            begin\n                corrected_encoded_data[error_pos-1]=~corrected_encoded_data[error_pos-1];\n            end\n            for(i=0;i<n;i=i+1)\n                begin\n                    hamming_decode[i]=corrected_encoded_data[i+m];\n                end\n        end\nendfunction\n\nalways @(posedge we or negedge we)\n    begin\n        if(!we)\n            begin\n                memory_block<=hamming_encode(data_in);\n            end\n    end\n\nalways @(*)\n    begin\n        if(re)\n        begin\n            read_enable<=1'b1;\n            corrected_data<=hamming_decode(memory_block);\n        end\n        else\n            begin\n                read_enable<=1'b0;\n                corrected_data<=8'd0;\n            end\n    end\n\nassign data_out=read_enable?corrected_data:8'd0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "custom__8905dd08", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule custom_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign Y = (A1 && !A2 && A3 && B1 && !B2) ? 1'b1 : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "iddr #_448b20d0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n`resetall\n\n\n\n\nmodule iddr #\n(\n    parameter TARGET = \"GENERIC\",\n    parameter IODDR_STYLE = \"IODDR2\",\n    parameter WIDTH = 1\n)\n(\n    input  wire             clk,\n\n    input  wire [WIDTH-1:0] d,\n\n    output wire [WIDTH-1:0] q1,\n    output wire [WIDTH-1:0] q2\n);\n\n\n\ngenvar n;\n\ngenerate\n\nif (TARGET == \"XILINX\") begin\n    for (n = 0; n < WIDTH; n = n + 1) begin : iddr\n        if (IODDR_STYLE == \"IODDR\") begin\n            IDDR #(\n                .DDR_CLK_EDGE(\"SAME_EDGE_PIPELINED\"),\n                .SRTYPE(\"ASYNC\")\n            )\n            iddr_inst (\n                .Q1(q1[n]),\n                .Q2(q2[n]),\n                .C(clk),\n                .CE(1'b1),\n                .D(d[n]),\n                .R(1'b0),\n                .S(1'b0)\n            );\n        end else if (IODDR_STYLE == \"IODDR2\") begin\n            IDDR2 #(\n                .DDR_ALIGNMENT(\"C0\")\n            )\n            iddr_inst (\n                .Q0(q1[n]),\n                .Q1(q2[n]),\n                .C0(clk),\n                .C1(~clk),\n                .CE(1'b1),\n                .D(d[n]),\n                .R(1'b0),\n                .S(1'b0)\n            );\n        end\n    end\nend else if (TARGET == \"ALTERA\") begin\n    wire [WIDTH-1:0] q1_int;\n    reg [WIDTH-1:0] q1_delay;\n\n    altddio_in #(\n        .WIDTH(WIDTH),\n        .POWER_UP_HIGH(\"OFF\")\n    )\n    altddio_in_inst (\n        .aset(1'b0),\n        .datain(d),\n        .inclocken(1'b1),\n        .inclock(clk),\n        .aclr(1'b0),\n        .dataout_h(q1_int),\n        .dataout_l(q2)\n    );\n\n    always @(posedge clk) begin\n        q1_delay <= q1_int;\n    end\n\n    assign q1 = q1_delay;\nend else begin\n    reg [WIDTH-1:0] d_reg_1 = {WIDTH{1'b0}};\n    reg [WIDTH-1:0] d_reg_2 = {WIDTH{1'b0}};\n\n    reg [WIDTH-1:0] q_reg_1 = {WIDTH{1'b0}};\n    reg [WIDTH-1:0] q_reg_2 = {WIDTH{1'b0}};\n\n    always @(posedge clk) begin\n        d_reg_1 <= d;\n    end\n\n    always @(negedge clk) begin\n        d_reg_2 <= d;\n    end\n\n    always @(posedge clk) begin\n        q_reg_1 <= d_reg_1;\n        q_reg_2 <= d_reg_2;\n    end\n\n    assign q1 = q_reg_1;\n    assign q2 = q_reg_2;\nend\n\nendgenerate\n\nendmodule\n\n`resetall\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "deserializer_e2531279", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule deserializer(\n\tclk, \t\t//serialized data proper clock\n\tenable, \t//suspend while enable on low\n\treset, \t\t//set output to zero and reset counter to 0 on high\n\tframesize, \t//number of bits to be deserialized\n\tin, \t\t//serialized data\n\tout, \t\t//deserialized data\n\tcomplete\t//reset counter to 0 and hold out's data while high\n);\n\n\tparameter BITS = 32;\t\t//size of deserializer\n\tparameter BITS_COUNTER = 8;\t//size of counter, must be at least log2(BITS)\n\n\tinput clk, enable, reset, in;\n\tinput [BITS_COUNTER-1:0] framesize;\n\n\toutput reg complete;\n\toutput reg [BITS-1:0] out;\n\treg [BITS_COUNTER-1:0] counter;\t//we need to know which array item (out) to write on\n\n\n\talways@(posedge clk) begin\n\n\t\tif (reset==1'b1) begin\n\t\t\tout <= 32'b00000000000000000000000000000000;\n\t\t\tcounter <= 8'b00000000;\n\t\t\tcomplete <= 1'b0;\n\t\tend\n\t\telse if (enable==1'b1) begin\n\t\t\tif (complete==1'b0) begin\n\t\t\t\tout[counter] <= in;\n\t\t\t\tcounter  <= counter + 1;\t//next item\n\t\t\tend\n\t\t\tif (counter==framesize) begin\n\t\t\t\tcomplete <= 1'b1;\n\t\t\tend\n\t\tend\n\t\telse begin\n\t\t\tcomplete <= 1'b0;\n\t\tend\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_51bde008", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n  input a,\n  input b,\n  input sel,\n  output out\n);\n\n  assign out = (sel == 1'b0) ? a : b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adapter_block_fifo_2_axi_stream #_1d0a6c61", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule adapter_block_fifo_2_axi_stream #(\n  parameter                                     DATA_WIDTH          = 24,\n  parameter                                     STROBE_WIDTH        = DATA_WIDTH / 8,\n  parameter                                     USE_KEEP            = 0,\n  parameter                                     USER_IN_DATA   = 1\n)(\n  input                                         rst,\n\n  input                                         i_block_fifo_rdy,\n  output  reg                                   o_block_fifo_act,\n  input       [23:0]                            i_block_fifo_size,\n  input       [(DATA_WIDTH + 1) - 1:0]          i_block_fifo_data,\n  output                                        o_block_fifo_stb,\n  input       [3:0]                             i_axi_user,\n\n  input                                         i_axi_clk,\n  output      [3:0]                             o_axi_user,\n  input                                         i_axi_ready,\n  output      [DATA_WIDTH - 1:0]                o_axi_data,\n  output                                        o_axi_last,\n  output  reg                                   o_axi_valid,\n\n  output      [31:0]                            o_debug\n);\n\nlocalparam      IDLE        = 0;\nlocalparam      READY       = 1;\nlocalparam      RELEASE     = 2;\n\nreg     [3:0]               state;\nreg     [23:0]              r_count;\n\nassign  o_axi_data      = i_block_fifo_data[DATA_WIDTH - 1: 0];\nassign  o_block_fifo_stb= (i_axi_ready & o_axi_valid);\n\nif (USER_IN_DATA) begin\n  assign  o_axi_user[0]   = (r_count < i_block_fifo_size) ? i_block_fifo_data[DATA_WIDTH] : 1'b0;\n  assign  o_axi_user[3:1] = 3'h0;\nend\nelse begin\n  assign  o_axi_user      = i_axi_user;\nend\n\nassign  o_axi_last      = ((r_count + 1) >= i_block_fifo_size) & o_block_fifo_act  & o_axi_valid;\nassign  o_debug[3:0]    = state;\nassign  o_debug[4]      = (r_count < i_block_fifo_size) ? i_block_fifo_data[DATA_WIDTH]: 1'b0;\nassign  o_debug[5]      = o_block_fifo_act;\nassign  o_debug[6]      = i_block_fifo_rdy;\nassign  o_debug[7]      = (r_count > 0);\nassign  o_debug[8]      = (i_block_fifo_size > 0);\nassign  o_debug[9]      = (r_count == i_block_fifo_size);\nassign  o_debug[15:10]  = 0;\nassign  o_debug[23:16]  = r_count[7:0];\nassign  o_debug[31:24]  = 0;\n\nalways @ (posedge i_axi_clk) begin\n  o_axi_valid           <=  0;\n\n  if (rst) begin\n    state               <=  IDLE;\n    o_block_fifo_act    <=  0;\n    r_count             <=  0;\n  end\n  else begin\n    case (state)\n      IDLE: begin\n        o_block_fifo_act    <=  0;\n        if (i_block_fifo_rdy && !o_block_fifo_act) begin\n          r_count       <=  0;\n          o_block_fifo_act  <=  1;\n          state         <=  READY;\n        end\n      end\n      READY: begin\n        if (r_count < i_block_fifo_size) begin\n          o_axi_valid         <=  1;\n          if (i_axi_ready && o_axi_valid) begin\n            r_count         <= r_count + 1;\n            if ((r_count + 1) >= i_block_fifo_size) begin\n              o_axi_valid     <=  0;\n            end\n          end\n        end\n        else begin\n          o_block_fifo_act  <=  0;\n          state             <=  RELEASE;\n        end\n      end\n      RELEASE: begin\n        state               <=  IDLE;\n      end\n      default: begin\n      end\n    endcase\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__92210f8f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (\n    output X   ,\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    input  C1  \n);\n\n    // Local signals\n    wire and0_out;\n    wire or0_out_X;\n\n    // Name Output Other arguments\n    and and0 (and0_out, A1, A2);\n    or or0 (or0_out_X, and0_out, C1, B1);\n    buf buf0 (X, or0_out_X);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MUX41X1_e33a77f3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule MUX41X1 (IN1,IN2,IN3,IN4,S0,S1,Q);\n\n input IN1,IN2,IN3,IN4,S0,S1;\n output Q;\n\n wire t1,t2;\n\n assign t1 = (S1 & IN1) | (~S1 & IN2);\n assign t2 = (S1 & IN3) | (~S1 & IN4);\n assign Q = (S0 & t1) | (~S0 & t2);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "digit_state_machine_36259936", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule digit_state_machine(\n\t\n\tinput clk,\n\tinput reset_n,\n\tinput [3:0] units,\n\tinput [3:0] tens,\n\tinput [3:0] hundreds,\n\tinput [3:0] thousands,\n\t\n\toutput reg [2:0] digit_select,\n\toutput reg [3:0] data,\n\toutput reg decimal_point\n\t);\n\t\n\treg [1:0] state;\n\treg [1:0] state_n;\n\t\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\tparameter S3 = 2'b11;\n\t\n\talways @ (posedge clk, negedge reset_n)\n\t\tbegin\n\t\t\tif(!reset_n)\n\t\t\t\tstate <= S0;\n\t\t\telse\n\t\t\t\tstate <= state_n;\n\t\tend\n\t\t\n\t\talways @ (*)\n\t\t\tbegin\n\t\t\t\tcase(state)\n\t\t\t\t\tS0: state_n = S1;\n\t\t\t\t\tS1: state_n = S2;\n\t\t\t\t\tS2: state_n = S3;\n\t\t\t\t\tS3:\tstate_n = S0;\n\t\t\t\t\t\n\t\t\t\t\tdefault: state_n = S0;\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t\n\t\talways @ (*)\n\t\t\tbegin\n\t\t\t\tcase(state)\n\t\t\t\tS0: begin\n\t\t\t\t\tdecimal_point = 1;\n\t\t\t\t\tdigit_select = 3'b000;\n\t\t\t\t\tdata = units;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tS1: begin\n\t\t\t\t\tdecimal_point = 1;\n\t\t\t\t\tdigit_select = 3'b001;\n\t\t\t\t\tdata = tens;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tS2: begin\n\t\t\t\t\tdecimal_point = 1;\n\t\t\t\t\tdigit_select = 3'b011;\n\t\t\t\t\tdata = hundreds;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\tS3: begin\n\t\t\t\t\tdecimal_point = 0;\n\t\t\t\t\tdigit_select = 3'b100;\n\t\t\t\t\tdata = thousands;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_async_reset_2660d03d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_async_reset (\n    input CLK,\n    input D,\n    input RST,\n    output reg Q\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Q <= 0;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Profibus_5be60331", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Profibus (\n  input wire clk,\n  input wire rst,\n  input wire [7:0] data_in,\n  output wire [7:0] data_out,\n  output wire enable,\n  output wire busy\n);\n\n// Master block\nwire [7:0] master_data_out;\nwire [7:0] master_data_in;\nwire master_enable;\nwire master_busy;\n\n// Slave block\nwire [7:0] slave_data_in;\nwire [7:0] slave_data_out;\nwire slave_enable;\nwire slave_busy;\n\n// Communication protocol\nreg [1:0] state;\nparameter IDLE = 2'b00,\n          SEND = 2'b01,\n          RECEIVE = 2'b10;\nassign enable = master_enable;\nassign busy = master_busy;\nassign data_out = slave_data_out;\n\n// State machine\nalways @(posedge clk) begin\n  if(rst) begin\n    state <= IDLE;\n  end else begin\n    case(state)\n      IDLE: begin if (enable) begin state <= SEND; end end\n      SEND: begin if (~master_busy) begin state <= RECEIVE; end end\n      RECEIVE: begin if (~slave_busy) begin state <= IDLE; end end\n    endcase\n  end\nend\n\n// Master block\nassign master_data_out = (state == SEND) ? data_in : 8'b0;\nassign master_enable = (state == SEND);\nassign master_busy = (state == SEND || state == RECEIVE);\nassign slave_data_in = master_data_out;\n\n// Slave block\nassign slave_data_out = (state == RECEIVE) ? master_data_out : 8'b0;\nassign slave_enable = (state == RECEIVE);\nassign slave_busy = (state == SEND || state == RECEIVE);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RegisterFile_98a849f1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RegisterFile(input clk,\n    input [1:0] io_rs1_thread,\n    input [4:0] io_rs1_addr,\n    output[31:0] io_rs1_data,\n    input [1:0] io_rs2_thread,\n    input [4:0] io_rs2_addr,\n    output[31:0] io_rs2_data,\n    input [1:0] io_rd_thread,\n    input [4:0] io_rd_addr,\n    input [31:0] io_rd_data,\n    input  io_rd_enable\n);\n\n  reg [31:0] dout2;\n  wire[31:0] T0;\n  wire[31:0] T1;\n  reg [31:0] regfile [127:0];\n  wire[31:0] T2;\n  wire[6:0] T3;\n  wire[6:0] T4;\n  wire T5;\n  reg [31:0] dout1;\n  wire[31:0] T6;\n  wire[31:0] T7;\n  wire[6:0] T8;\n  wire T9;\n\n  // Read data from the register file based on the thread identifier and address inputs of each read port\n  assign io_rs2_data = dout2;\n  assign T0 = T5 ? 32'h0 : T1;\n  assign T1 = regfile[T4];\n  assign T3 = {io_rd_addr, io_rd_thread};\n  assign T4 = {io_rs2_addr, io_rs2_thread};\n  assign T5 = io_rs2_addr == 5'h0;\n  assign io_rs1_data = dout1;\n  assign T6 = T9 ? 32'h0 : T7;\n  assign T7 = regfile[T8];\n  assign T8 = {io_rs1_addr, io_rs1_thread};\n  assign T9 = io_rs1_addr == 5'h0;\n\n  // Write data to the register file based on the thread identifier, address, data inputs, and write enable signal of the write port\n  always @(posedge clk) begin\n    if(T5) begin\n      dout2 <= 32'h0;\n    end else begin\n      dout2 <= T1;\n    end\n    if (io_rd_enable)\n      regfile[T3] <= io_rd_data;\n    if(T9) begin\n      dout1 <= 32'h0;\n    end else begin\n      dout1 <= T7;\n    end\n    if (io_rd_enable && io_rd_thread == 2'b00)\n      regfile[io_rd_addr] <= io_rd_data;\n    if (io_rd_enable && io_rd_thread == 2'b01)\n      regfile[io_rd_addr+32] <= io_rd_data;\n    if (io_rd_enable && io_rd_thread == 2'b10)\n      regfile[io_rd_addr+64] <= io_rd_data;\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_e4263e46", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input [1:0] op,\n    output reg signed [7:0] result\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = a + b;\n        2'b01: result = a - b;\n        2'b10: result = a * b;\n        2'b11: begin\n            if(b == 0) begin\n                result = 8'hFF; // division by zero error code\n            end else begin\n                result = a / b;\n            end\n        end\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_nor2_99b08adc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_nor2 (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = ~(A | B_N);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4 #_4401027c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4 #(parameter WIDTH = 8)\n             (input  [WIDTH-1:0] d0, d1, d2, d3, \n              input  [1:0] sel, \n              output [WIDTH-1:0] y);\n\n  wire [WIDTH-1:0] s0, s1;\n  assign s0 = sel[0] ? d2 : d0;\n  assign s1 = sel[0] ? d3 : d1;\n  assign y = sel[1] ? s1 : s0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_adder_6c4b96ed", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule simple_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] C\n);\n\nalways @ (A, B) begin\n    C = A + B;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__nand4_23b3fe90", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__nand4 (\n    Y,\n    A,\n    B,\n    C,\n    D\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, D, C, B, A     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_deal_45058c79", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule data_deal(\n\tclk,\n\trst_n,\n\tdata_in,\n\tdata_in_sign,\n\t\n\tdata_out,\n\tdata_out_sign,\n\tdata_valid,\n\tdata_ok\n    );\n\t\n\t\n\t\n\tinput \tclk;\n\tinput \trst_n;\n\tinput \t[6:0]\tdata_in;\n\tinput \tdata_in_sign;\n\t\n\toutput\t[6:0]\tdata_out;\n\toutput\tdata_out_sign;\n\tinput \tdata_valid;\n\toutput\tdata_ok;\n\t\n\t\n\t\n\treg\t\t[6:0]\tdata_reg;\n\treg\t\t\t\tdata_ok;\n\t\n\treg\t\t[6:0]\tdata_out;\n\treg\t\t\t\tdata_out_sign;\n\treg\t\t\t\tdata_in_sign_reg;\n\t\n\t\n\talways @(posedge  clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdata_reg <= 7'h0;\n\t\t\tdata_ok <= 1'h0;\n\t\t\tdata_in_sign_reg <= 1'b0;\n\t\tend\n\t\telse begin\t\n\t\t\tdata_in_sign_reg <= data_in_sign;\n\t\t\tdata_reg <= data_in_sign ? data_reg + 1'b1 : data_reg;\n\t\t\tdata_ok <= data_in_sign_reg ? &(data_reg ~^ data_in) : data_ok;\n\t\tend\n\tend\n\t\n\t\n\talways @(posedge  clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdata_out_sign <= 1'b0;\n\t\t\tdata_out <= 'h0;\n\t\tend\n\t\telse begin\t\n\t\t\tif(~data_out_sign & data_valid)\t\tdata_out_sign <= 1'b1;\n\t\t\telse \t\t\t\t\t\t\t\tdata_out_sign <= 1'b0;\n\t\t\tdata_out <= ~data_out_sign & data_valid ? data_out + 1'b1 : data_out;\n\t\tend\n\tend\n\t\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "acl_fp_convert_from_long_119dc670", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule acl_fp_convert_from_long(clock, resetn, dataa, result, enable, valid_in, valid_out, stall_in, stall_out);\n\tparameter UNSIGNED = 0;\n\tparameter HIGH_CAPACITY = 1;\n\tparameter ROUNDING_MODE = 0;\t\n    input clock, resetn;\n\tinput [63:0] dataa;\n\toutput [31:0] result;\n\tinput enable, valid_in, stall_in;\n\toutput valid_out, stall_out;\n\t\n\treg c1_valid;\n\twire c1_stall;\n\twire c1_enable;\n\treg c2_valid;\n\twire c2_stall;\n\twire c2_enable;\n\treg c3_valid;\n\twire c3_stall;\n\twire c3_enable;\n\treg c4_valid;\n\twire c4_stall;\n\twire c4_enable;\n\treg c5_valid;\n\twire c5_stall;\n\twire c5_enable;\t\n\t\n\treg [63:0] c1_value_to_convert;\n\treg c1_sign;\n\tassign c1_enable = (HIGH_CAPACITY == 1) ? (~c1_valid | ~c1_stall) : enable;\n\tassign stall_out = c1_valid & c1_stall;\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc1_valid <= 1'b0;\n\t\t\tc1_sign <= 1'bx;\n\t\t\tc1_value_to_convert <= 64'dx;\n\t\tend\n\t\telse if (c1_enable)\n\t\tbegin\n\t\t\tc1_valid <= valid_in;\n\t\t\t\n\t\t\tif (UNSIGNED == 1)\n\t\t\tbegin\n\t\t\t\tc1_sign <= 1'b0;\n\t\t\t\tc1_value_to_convert <= dataa;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tc1_sign <= dataa[63];\n\t\t\t\tc1_value_to_convert <= (dataa ^ {64{dataa[63]}}) + {1'b0, dataa[63]};\n\t\t\tend\n\t\tend\n\tend\n\t\n\treg [63:0] c2_value_to_convert;\n\treg [7:0] c2_exponent;\n\treg c2_sign, c2_done;\n\tassign c2_enable = (HIGH_CAPACITY == 1) ? (~c2_valid | ~c2_stall) : enable;\n\tassign c1_stall = c2_valid & c2_stall;\t\n\t\n\twire top_bits_0 = ~(|c1_value_to_convert[63:32]);\n\twire top_bits_half_0 = ~(|c1_value_to_convert[63:48]);\n\twire bottom_bits_0 = ~(|c1_value_to_convert[31:0]);\n\twire bottom_bits_half_0 = ~(|c1_value_to_convert[31:16]);\n\t\n\treg [1:0] c2_shift_value;\n\talways@(*)\n\tbegin\n\t\tc2_shift_value[1] = top_bits_0;\n\t\tc2_shift_value[0] = top_bits_0 & bottom_bits_half_0 | ~top_bits_0 & top_bits_half_0;\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc2_valid <= 1'b0;\n\t\t\tc2_value_to_convert <= 64'dx;\n\t\t\tc2_exponent <= 8'dx;\n\t\t\tc2_sign <= 1'bx;\n\t\t\tc2_done <= 1'bx;\n\t\tend\n\t\telse if (c2_enable)\n\t\tbegin\n\t\t\tc2_valid <= c1_valid;\n\t\t\tc2_sign <= c1_sign;\n   \t\tc2_done <= top_bits_0 & bottom_bits_0;\t\t\t\n\t\t\tif (top_bits_0 & bottom_bits_0)\n\t\t\tbegin\n\t\t\t\tc2_exponent <= 8'd0;\n\t\t\t\tc2_value_to_convert <= c1_value_to_convert;\n\t\t\tend\n\t\t\telse \n\t\t\tbegin\n\t\t\t\tc2_exponent <= 8'd190 - {1'b0, c2_shift_value, 4'd0}; case(c2_shift_value)\n\t\t\t\t  2'b11: c2_value_to_convert <= {c1_value_to_convert[15:0], 48'd0};\n\t\t\t\t  2'b10: c2_value_to_convert <= {c1_value_to_convert[31:0], 32'd0};\n\t\t\t\t  2'b01: c2_value_to_convert <= {c1_value_to_convert[47:0], 16'd0};\n\t\t\t\t  2'b00: c2_value_to_convert <= c1_value_to_convert;\n\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\tend\n\t\n\treg [63:0] c3_value_to_convert;\n\treg [7:0] c3_exponent;\n\treg c3_sign, c3_done;\n\tassign c3_enable = (HIGH_CAPACITY == 1) ? (~c3_valid | ~c3_stall) : enable;\n\tassign c2_stall = c3_valid & c3_stall;\t\n\t\n\twire top_12bits_0 = ~(|c2_value_to_convert[63:52]);\n\twire top_8bits_0 = ~(|c2_value_to_convert[63:56]);\n\twire top_4bits_0 = ~(|c2_value_to_convert[63:60]);\n\t\n\treg [1:0] c3_exp_adjust;\n\talways@(*)\n\tbegin\n\t\tif (top_12bits_0 & ~c2_done)\n\t\t\tc3_exp_adjust = 2'd3;\n\t\telse if (top_8bits_0 & ~c2_done)\n\t\t\tc3_exp_adjust = 2'd2;\n\t\telse if (top_4bits_0 & ~c2_done)\n\t\t\tc3_exp_adjust = 2'd1;\n\t\telse\n\t\t\tc3_exp_adjust = 2'd0;\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc3_valid <= 1'b0;\n\t\t\tc3_value_to_convert <= 64'dx;\n\t\t\tc3_exponent <= 8'dx;\n\t\t\tc3_sign <= 1'bx;\n\t\t\tc3_done <= 1'bx;\n\t\tend\n\t\telse if (c3_enable)\n\t\tbegin\n\t\t\tc3_valid <= c2_valid;\n\t\t\tc3_sign <= c2_sign;\n\t\t\tc3_done <= c2_done;\n\t\t\tc3_exponent <= c2_exponent - {1'b0, c3_exp_adjust, 2'd0};\n\t\t\tcase (c3_exp_adjust)\n\t\t\t\t2'b11: c3_value_to_convert <= {c2_value_to_convert[51:0], 12'd0};\n\t\t\t\t2'b10: c3_value_to_convert <= {c2_value_to_convert[55:0], 8'd0};\n\t\t\t\t2'b01: c3_value_to_convert <= {c2_value_to_convert[59:0], 4'd0};\n\t\t\t\t2'b00: c3_value_to_convert <= c2_value_to_convert;\n\t\t\tendcase\n\t\tend\n\tend\t\n\n\treg [63:0] c4_value_to_convert;\n\treg [7:0] c4_exponent;\n\treg c4_sign;\n\tassign c4_enable = (HIGH_CAPACITY == 1) ? (~c4_valid | ~c4_stall) : enable;\n\tassign c3_stall = c4_valid & c4_stall;\t\n\t\n\twire top_3bits_0 = ~(|c3_value_to_convert[63:61]);\n\twire top_2bits_0 = ~(|c3_value_to_convert[63:62]);\n\twire top_1bits_0 = ~(c3_value_to_convert[63]);\n\t\n\treg [1:0] c4_exp_adjust;\n\talways@(*)\n\tbegin\n\t\tif (top_3bits_0 & ~c3_done)\n\t\t\tc4_exp_adjust = 2'd3;\n\t\telse if (top_2bits_0 & ~c3_done)\n\t\t\tc4_exp_adjust = 2'd2;\n\t\telse if (top_1bits_0 & ~c3_done)\n\t\t\tc4_exp_adjust = 2'd1;\n\t\telse\n\t\t\tc4_exp_adjust = 2'd0;\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc4_valid <= 1'b0;\n\t\t\tc4_value_to_convert <= 64'dx;\n\t\t\tc4_exponent <= 8'dx;\n\t\t\tc4_sign <= 1'bx;\n\t\tend\n\t\telse if (c4_enable)\n\t\tbegin\n\t\t\tc4_valid <= c3_valid;\n\t\t\tc4_sign <= c3_sign;\n\t\t\tc4_exponent <= c3_exponent - {1'b0, c4_exp_adjust};\n\t\t\tcase (c4_exp_adjust)\n\t\t\t\t2'b11: c4_value_to_convert <= {c3_value_to_convert[60:0], 3'd0};\n\t\t\t\t2'b10: c4_value_to_convert <= {c3_value_to_convert[61:0], 2'd0};\n\t\t\t\t2'b01: c4_value_to_convert <= {c3_value_to_convert[62:0], 1'd0};\n\t\t\t\t2'b00: c4_value_to_convert <= c3_value_to_convert;\n\t\t\tendcase\n\t\tend\n\tend\t\n\t\n\treg [22:0] c5_mantissa;\n\treg [7:0] c5_exponent;\n\treg c5_sign;\n\t\n\tassign c5_enable = (HIGH_CAPACITY == 1) ? (~c5_valid | ~c5_stall) : enable;\n\tassign c4_stall = c5_valid & c5_stall;\t\n\twire [3:0] c5_bottom_4 = {c4_value_to_convert[40:38], |c4_value_to_convert[37:0]};\n\treg [24:0] c5_temp_mantissa;\n    always@(*)\n\tbegin\n\t\tcase (ROUNDING_MODE)\n\t\t\t4: begin\n\t\t\t\tif (UNSIGNED == 1)\n\t\t\t\tbegin\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\t\t\n\t\t\t\t\tif (|c5_bottom_4[2:0] & c4_sign)\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\tend\n\t\t\n\t\t\t3: begin\n\t\t\t\tif (UNSIGNED == 1)\n\t\t\t\tbegin\n\t\t\t\t\tif (|c5_bottom_4[2:0])\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\t\t\n\t\t\t\t\tif (|c5_bottom_4[2:0] & ~c4_sign)\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\t\tend\n\t\t\tend\n\n   \t\t2: begin\n\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\tend\n\t\t\t\n\t\t\t1: begin\n\t\t\t\tif (c5_bottom_4[2])\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\tend\n\n  \t\t   default: begin\n\t\t\t\tif ((&c5_bottom_4[3:2]) || (c5_bottom_4[2] & |c5_bottom_4[1:0]))\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]} + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tc5_temp_mantissa <= {1'b0, c4_value_to_convert[63:40]};\n\t\t\tend\n\t\tendcase\t\n\tend\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tc5_valid <= 1'b0;\n\t\t\tc5_mantissa <= 32'dx;\n\t\t\tc5_exponent <= 8'dx;\n\t\t\tc5_sign <= 1'bx;\n\t\tend\n\t\telse if (c5_enable)\n\t\tbegin\n\t\t\tc5_valid <= c4_valid;\n\t\t\tc5_sign <= c4_sign;\n\t\t\tc5_exponent <= c4_exponent + c5_temp_mantissa[24];\n\t\t\tc5_mantissa <= c5_temp_mantissa[24] ? c5_temp_mantissa[23:1] :  c5_temp_mantissa[22:0];\n\t\tend\n\tend\t\n\n\tassign c5_stall = stall_in;\n\tassign result = {c5_sign, c5_exponent, c5_mantissa};\n\tassign valid_out = c5_valid;\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_protocol_converter_v2_1_8_b2s_wr_cmd_fsm_5bf4e5e9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n \nmodule axi_protocol_converter_v2_1_8_b2s_wr_cmd_fsm (\ninput  wire                                 clk           ,\n  input  wire                                 reset         ,\n  output wire                                 s_awready       ,\n  input  wire                                 s_awvalid       ,\n  output wire                                 m_awvalid        ,\n  input  wire                                 m_awready      ,\n  output wire                                 next          ,\n  input  wire                                 next_pending  ,\n  output wire                                 b_push        ,\n  input  wire                                 b_full        ,\n  output wire                                 a_push\n);\n\nlocalparam SM_IDLE                = 2'b00;\nlocalparam SM_CMD_EN              = 2'b01;\nlocalparam SM_CMD_ACCEPTED        = 2'b10;\nlocalparam SM_DONE_WAIT           = 2'b11;\n\nreg [1:0]       state;\nreg [1:0]       next_state;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    state <= SM_IDLE;\n  end else begin\n    state <= next_state;\n  end\nend\n\nalways @( * )\nbegin\n  next_state = state;\n  case (state)\n    SM_IDLE:\n      if (s_awvalid) begin\n        next_state = SM_CMD_EN;\n      end else\n        next_state = state;\n\n    SM_CMD_EN:\n      if (m_awready & next_pending)\n        next_state = SM_CMD_ACCEPTED;\n      else if (m_awready & ~next_pending & b_full)\n        next_state = SM_DONE_WAIT;\n      else if (m_awready & ~next_pending & ~b_full)\n        next_state = SM_IDLE;\n      else\n        next_state = state;\n\n    SM_CMD_ACCEPTED:\n      next_state = SM_CMD_EN;\n\n    SM_DONE_WAIT:\n      if (!b_full)\n        next_state = SM_IDLE;\n      else\n        next_state = state;\n\n      default:\n        next_state = SM_IDLE;\n  endcase\nend\n\nassign m_awvalid  = (state == SM_CMD_EN);\n\nassign next    = ((state == SM_CMD_ACCEPTED)\n                 | (((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE))) ;\n\nassign a_push  = (state == SM_IDLE);\nassign s_awready = ((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE);\nassign b_push  = ((state == SM_CMD_EN) | (state == SM_DONE_WAIT)) & (next_state == SM_IDLE);\n\nendmodule\n\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "KEY2INST_fbdac6ad", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule KEY2INST(\n\tinput clk,\n\tinput[15:0] button,\n\tinput[31:0] inst_a,\n\toutput[31:0] inst_do,\n\toutput clrn\n);\n\n\t//CMD\n\tparameter [2:0]\n\t\tcmd_add = 3'b000,\n\t\tcmd_sub = 3'b001,\n\t\tcmd_and = 3'b010,\n\t\tcmd_or = 3'b011,\n\t\tcmd_xor = 3'b100,\n\t\tcmd_sll = 3'b101,\n\t\tcmd_srl = 3'b110,\n\t\tcmd_sra = 3'b111;\n\n\t//Select\n\tparameter [1:0]\n\t\tsl_al = 2'b00,\n\t\tsl_ah = 2'b01,\n\t\tsl_bl = 2'b10,\n\t\tsl_bh = 2'b11;\n\n\t//State\n\tparameter [4:0]\n\t\tst_idle = 5'b00001,\n\t\tst_load = 5'b00010,\n\t\tst_run = 5'b00100,\n\t\tst_wrom = 5'b01000,\n\t\tst_reset = 5'b10000;\n\n\t//func\n\tparameter [5:0]\n\tfunc_add = 6'b100000,\n\tfunc_sub = 6'b100010,\n\tfunc_and = 6'b100100,\n\tfunc_or = 6'b100101,\n\tfunc_xor = 6'b100110,\n\tfunc_sll = 6'b000000,\n\tfunc_srl = 6'b000010,\n\tfunc_sra = 6'b000011;\n\n\treg[31:0] inst_rom[31:0];\n\twire rst_n;\n\twire run;\n\twire load;\n\twire[2:0] cmd;\n\twire[1:0] select;\n\twire[7:0] data;\n\treg[4:0] st;\n\treg r_clrn;\n\n\t//ah,al,bh,bl\n\treg[7:0] data_now[3:0];\n\treg[25:0] cmd_do;\n\n\tassign rst_n = button[15];\n\tassign run = button[14];\n\tassign load = button[13];\n\tassign cmd = button[12:10];\n\tassign select = button[9:8];\n\tassign data = button[7:0];\n\n\tassign clrn = r_clrn;\n\tassign inst_do = inst_rom[inst_a[6:2]];\n\n\tinteger i;\n\tinitial begin\n\t\tst <= st_idle;\n\t\tfor(i=0;i<4;i=i+1)\n\t\t\tdata_now[i] <= 8'b0;\n\t\tfor(i=0;i<32;i=i+1)\n\t\t\tinst_rom[i] <= 32'b0;\n\tend\n\n\t//Cmd_do\n\talways @(*) begin \n\t\tcase (cmd)\n\t\t\tcmd_add : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_add};\n\t\t\tcmd_sub : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_sub};\n\t\t\tcmd_and : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_and};\n\t\t\tcmd_or : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_or};\n\t\t\tcmd_xor : cmd_do <= {5'b00001,5'b00010,5'b00011,5'b0,func_xor};\n\t\t\tcmd_sll : cmd_do <= {5'b0,5'b00001,5'b00011,data_now[3][4:0],func_sll};\n\t\t\tcmd_srl : cmd_do <= {5'b0,5'b00001,5'b00011,data_now[3][4:0],func_srl};\n\t\t\tcmd_sra : cmd_do <= {5'b0,5'b00001,5'b00011,data_now[3][4:0],func_sra};\n\t\t\tdefault : cmd_do <= 26'b0;\n\t\tendcase\n\t\n\tend\n\n\t//State machine\n\talways @(posedge clk or negedge rst_n) begin\n\t\tif(~rst_n) st <= st_reset;\n\t\telse begin\n\t\t\tcase (st)\n\t\t\t\tst_idle : begin \n\t\t\t\t\tcase ({run,load})\n\t\t\t\t\t\t//2'b1x : st <= st_wrom;\n\t\t\t\t\t\t2'b10 : st <= st_wrom;\n\t\t\t\t\t\t2'b11 : st <= st_wrom;\n\t\t\t\t\t\t2'b01 : st <= st_load;\n\t\t\t\t\t\tdefault : st <= st;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\t\tst_wrom : st <= st_run;\n\t\t\t\tst_run : st <= run ? st : st_idle;\n\t\t\t\tst_reset : st <= st_idle;\n\t\t\t\tst_load : st <= st_idle;\n\t\t\t\tdefault : st <= st_reset;\n\t\t\tendcase\n\t\tend\n\tend\n\n\t//Work\n\talways @(posedge clk) begin\n\t\tcase (st)\n\t\t\tst_reset : begin\n\t\t\t\tr_clrn <= 1'b0;\n\t\t\t\tfor(i=0;i<4;i=i+1)\n\t\t\t\t\tdata_now[i] <= 8'b0;\n\t\t\tend\n\t\t\tst_load : data_now[select] <= data;\n\t\t\tst_wrom : begin \n\t\t\t\t//Clear all regs, set pc to 0;\n\t\t\t\tr_clrn <= 1'b0;\n\t\t\t\t//r1 = r0(0) + a;\n\t\t\t\tinst_rom[0] <= {6'b001000,5'b00000,5'b00001,data_now[0],data_now[1]};\n\t\t\t\t//r2 = r0(0) + b;\n\t\t\t\tinst_rom[1] <= {6'b001000,5'b00000,5'b00010,data_now[2],data_now[3]};\n\t\t\t\t//r3 = r1 (cmd) r2;\n\t\t\t\tinst_rom[2] <= {6'b0,cmd_do};\n\t\t\t\t//loop(j 26'd4)\n\t\t\t\tinst_rom[3] <= {6'b000010,26'd3};\n\t\t\tend\n\t\t\tst_run : r_clrn <= 1'b1;\n\t\t\tdefault : ;\n\t\tendcase\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux2to1_52fd3468", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux2to1(\n    input A, B, sel, reset, clk,\n    output reg out\n);\n\nalways @(posedge clk, negedge reset) begin\n    if(!reset) begin\n        out <= 0;\n    end else begin\n        if(sel == 0) begin\n            out <= A;\n        end else begin\n            out <= B;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "qmem_decoder #_d6b5da09", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule qmem_decoder #(\n  parameter QAW = 32,     parameter QDW = 32,     parameter QSW = QDW/8,  parameter SN  = 2       )(\n  input  wire              clk,\n  input  wire              rst,\n  input  wire              qm_cs,\n  input  wire              qm_we,\n  input  wire    [QAW-1:0] qm_adr,\n  input  wire    [QSW-1:0] qm_sel,\n  input  wire    [QDW-1:0] qm_dat_w,\n  output wire    [QDW-1:0] qm_dat_r,\n  output wire              qm_ack,\n  output wire              qm_err,\n  output wire [SN    -1:0] qs_cs,\n  output wire [SN    -1:0] qs_we,\n  output wire [SN*QAW-1:0] qs_adr,\n  output wire [SN*QSW-1:0] qs_sel,\n  output wire [SN*QDW-1:0] qs_dat_w,\n  input  wire [SN*QDW-1:0] qs_dat_r,\n  input  wire [SN    -1:0] qs_ack,\n  input  wire [SN    -1:0] qs_err,\n  input  wire [SN    -1:0] ss\n);\n\n\nwire [7:0] ss_a;\nreg  [7:0] ss_r;\n\ngenerate if (SN == 1) assign ss_a =                                                         0; endgenerate\ngenerate if (SN == 2) assign ss_a =                                                 ss[1]?1:0; endgenerate\ngenerate if (SN == 3) assign ss_a =                                         ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 4) assign ss_a =                                 ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 5) assign ss_a =                         ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 6) assign ss_a =                 ss[5]?5:ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 7) assign ss_a =         ss[6]?6:ss[5]?5:ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\ngenerate if (SN == 8) assign ss_a = ss[7]?7:ss[6]?6:ss[5]?5:ss[4]?4:ss[3]?3:ss[2]?2:ss[1]?1:0; endgenerate\n\nalways @ (posedge clk)\nif (qm_cs & (qm_ack | qm_err) & ~qm_we)  ss_r <= #1 ss_a;\n\ngenvar i;\n\ngenerate for (i=0; i<SN; i=i+1) begin : loop_select\n  assign qs_cs    [     i                   ] = qm_cs & ss [i];\n  assign qs_we    [     i                   ] = qm_we;\n  assign qs_adr   [QAW*(i+1)-1:QAW*(i+1)-QAW] = qm_adr;\n  assign qs_sel   [QSW*(i+1)-1:QSW*(i+1)-QSW] = qm_sel;\n  assign qs_dat_w [QDW*(i+1)-1:QDW*(i+1)-QDW] = qm_dat_w;\nend endgenerate\n\nassign qm_dat_r = qs_dat_r >> (QDW*ss_r);\nassign qm_ack   = qs_ack   >>      ss_a ;\nassign qm_err   = qs_err   >>      ss_a ;\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_calculator_723cd7a6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule simple_calculator(input [7:0] a, b, input [3:0] control, output reg [7:0] result);\n\nalways @(*) begin\n    case(control)\n        4'b0000: result = a + b;\n        4'b0001: result = a - b;\n        4'b0010: result = a * b;\n        4'b0011: result = a / b;\n        default: result = 8'b00000000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MUX_30521fe1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MUX (\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  input sel0,\n  input sel1,\n  output out\n);\n\n  // Selection logic\n  wire sel_00 = ~(sel0 | sel1);\n  wire sel_01 = ~sel0 & sel1;\n  wire sel_10 = sel0 & ~sel1;\n  wire sel_11 = sel0 & sel1;\n\n  // Output selection\n  assign out = sel_00 ? in0 : sel_01 ? in1 : sel_10 ? in2 : in3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "synth_arb_b126110b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule synth_arb (\n  clk,\n  reset_n, \n  memadrs, \n  memdata, \n  wreq, \n  synth_ctrl,\n  synth_data,\n  fifo_full);\n  \n  input   wire        clk, reset_n, wreq, fifo_full;\n  input   wire  [7:0] memadrs, memdata;\n  output  reg   [7:0] synth_ctrl, synth_data;\n  \n  reg   [7:0] state_reg;\n  reg   [3:0] wait_cnt;\n  reg         wreq_inter, w_done;\n          \n  always @(posedge wreq, posedge w_done, negedge reset_n)\n  begin\n    if(reset_n == 0) wreq_inter <= 0;\n    else if(w_done == 1) wreq_inter <= 0;\n    else if(wreq == 1 && w_done != 1) wreq_inter <= 1;\n  end\n          \n  always @(posedge clk, negedge reset_n)\n  begin\n    if(!reset_n)\n    begin\n      state_reg <= 0;\n      synth_ctrl <= 0;\n      synth_data <= 0;\n      wait_cnt <= 0;\n      w_done <= 0;\n    end\n    else\n    begin\n      case(state_reg)\n        8'D0    : state_reg <= state_reg + 1;\n                                                                          //recovery reset while 16count\n        8'D1    : begin\n                    if(wait_cnt != 4'b1111) wait_cnt <= wait_cnt + 1;\n                    else  state_reg <= state_reg + 1;\n                  end\n                                                                          //step phase, operator 1\n        8'D2    : begin\n                    state_reg <= state_reg + 1;\n                    synth_ctrl <= 8'b00000001;\n                  end\n                                                                          //fifo full check, operator stall\n        8'D3    : begin\n                    synth_ctrl <= 8'b00000000;\n                    if(fifo_full != 1) state_reg <= state_reg + 1;\n                    else state_reg <= state_reg; \n                  end\n                                                                          //write req to fifo, operator 1\n        8'D4    : begin\n                    state_reg <= state_reg + 1;\n                    synth_ctrl <= 8'b10000001;\n                  end\n                                                                          //write wait\n        8'D5    : begin\n                    state_reg <= state_reg + 1;\n                    synth_ctrl <= 8'b00000000;\n                  end\n                                                                          //jump to state 2 if write strobe is not active\n        8'D6    : begin\n                    if(wreq_inter == 1) state_reg <= state_reg + 1;\n                    else state_reg <= 2;\n                  end\n                                                                          //get recieve data and command, write data\n        8'D7    : begin\n                    synth_data <= memdata;\n                    synth_ctrl <= d2ctrl_synth(memadrs);\n                    state_reg <= state_reg + 1;\n                    w_done <= 1;\n                  end\n                                                                          //finishing write data\n        8'D8    : begin\n                    state_reg <= 2;\n                    synth_ctrl <= 8'b00000000;\n                    w_done <= 0;\n                  end\n                 \n        default : state_reg <= 0;     \n      endcase\n    end\n  end\n  \n  function  [7:0] d2ctrl_synth;\n    input [7:0] adrs;\n    begin\n      casex(adrs)\n        8'b00000001 : d2ctrl_synth = 8'b01000001;                 \n        8'b00010001 : d2ctrl_synth = 8'b00010001;\n        8'b00100001 : d2ctrl_synth = 8'b01010001;\n        8'b1000xxxx : d2ctrl_synth = 8'b00100000;\n        default     : d2ctrl_synth = 0;\n      endcase\n    end\n  endfunction\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotator_98b1b1ba", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nreg [99:0] stage1_data;\nreg [99:0] stage2_data;\nreg [99:0] stage3_data;\n\nalways @(posedge clk) begin\n    if(load) begin\n        stage1_data <= data;\n        stage2_data <= stage1_data;\n        stage3_data <= stage2_data;\n    end else if(ena == 2'b01) begin // left rotation\n        stage1_data <= {stage1_data[98:0], stage1_data[99]};\n        stage2_data <= {stage2_data[97:0], stage2_data[99:98]};\n        stage3_data <= {stage3_data[96:0], stage3_data[99:97]};\n    end else if(ena == 2'b10) begin // right rotation\n        stage1_data <= {stage1_data[1:99], stage1_data[0]};\n        stage2_data <= {stage2_data[2:99], stage2_data[1:0]};\n        stage3_data <= {stage3_data[3:99], stage3_data[2:0]};\n    end\nend\n\nassign q = ena == 2'b00 ? data : ena == 2'b01 ? stage1_data : ena == 2'b10 ? stage2_data : stage3_data;\n\nendmodule\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nrotator rotator_inst(\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(q)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bcd_to_binary_ae9babea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bcd_to_binary (\n  input [3:0] bcd0,\n  input [3:0] bcd1,\n  input [3:0] bcd2,\n  input [3:0] bcd3,\n  output reg [3:0] bin\n);\n\n  always @* begin\n    bin = (bcd3 * 1000) + (bcd2 * 100) + (bcd1 * 10) + bcd0;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "blockram_spool_602e2c65", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule blockram_spool (\n\tinput wire clk_i,\n\tinput wire areset_i,\n\toutput reg [15:0] address_o,\n\toutput reg [7:0]\tdata_o,\n\tinput wire [7:0]\tq_i,\n\toutput reg\t\t\twren_o,\n\tinput wire [3:0]\tA_i,\n\tinput wire [7:0]\tD_i,\n\toutput reg [7:0]\tD_o,\n\tinput wire \t\t\trd_i,\n\tinput wire\t\t\twr_i\n\t);\n\n\tparameter \tIDLE = 4'd0, \n\t\t\t\t\tPRE_READ = 4'd1, READ_READY = 4'd2, READ_CAPTURE = 4'd4, WAIT_READ = 4'd5,\n\t\t\t\t\tWRITE_WAIT = 4'd6, WRITE_NEXT = 4'd7;\n\t\n\twire rd_sig, wr_sig, abort_sig;\n\twire read_trigger, write_trigger;\n\t\n\treg [15:0] A;\n\treg cpu_rd, cpu_wr, fsm_rd, fsm_wr, cpu_abort, fsm_abort;\n\treg [3:0] state;\n\treg [7:0] rd_buffer;\n\t\n\tassign rd_sig = (cpu_rd != fsm_rd);\n\tassign wr_sig = (cpu_wr != fsm_wr);\n\tassign abort_sig = (cpu_abort != fsm_abort);\n\tassign read_trigger = (A_i == 4'd8) && rd_i;\n\tassign write_trigger = (A_i == 4'd8) && wr_i;\n\t\n\talways @(posedge clk_i or posedge areset_i)\n\tif( areset_i )\n\tbegin\n\t\tD_o <= 8'd0;\n\t\tcpu_rd <= 1'b0;\n\t\tcpu_wr <= 1'b0;\n\t\tcpu_abort <= 1'b0;\n\tend else if( rd_i | wr_i ) begin\t\tcase(A_i)\n\t\t\t4'd0:\tbegin\n\t\t\t\tif( wr_i ) A[7:0] <= D_i; else D_o <= A[7:0];\n\t\t\tend\n\t\t\t4'd1:\tbegin\n\t\t\t\tif( wr_i ) A[15:8] <= D_i; else D_o <= A[15:8];\n\t\t\tend\n\t\t\t4'd8: begin\n\t\t\t\tif( rd_i ) D_o <= rd_buffer;\n\t\t\tend\n\t\t\t4'd15: begin\n\t\t\t\tif( wr_i ) begin\n\t\t\t\t\tif( D_i[0] ) if( ~rd_sig) cpu_rd <= ~cpu_rd;\n\t\t\t\t\tif( D_i[1] ) if( ~wr_sig) cpu_wr <= ~cpu_wr;\n\t\t\t\t\tif( D_i[7] ) if( ~abort_sig ) cpu_abort <= ~cpu_abort;\n\t\t\t\tend else begin\n\t\t\t\t\tD_o <= {8'b0};\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk_i or posedge areset_i)\n\tif( areset_i )\n\tbegin\n\t\tfsm_rd <= 1'b0;\n\t\tfsm_wr <= 1'b0;\n\t\tfsm_abort <= 1'b0;\n\t\taddress_o <= 16'd0;\n\t\tdata_o <= 8'd0;\n\t\twren_o <= 1'b0;\t\t\n\t\tstate <= IDLE;\n\tend else begin\n\t\tcase( state )\n\t\t\tIDLE: begin\n\t\t\t\taddress_o <= A;\n\t\t\t\tif( rd_sig )\n\t\t\t\tbegin\n\t\t\t\t\tfsm_rd <= ~fsm_rd;\n\t\t\t\t\tstate <= PRE_READ;\n\t\t\t\tend else if( wr_sig )\n\t\t\t\tbegin\n\t\t\t\t\tdata_o <= D_i;\t\t\tfsm_wr <= ~fsm_wr;\n\t\t\t\t\tstate <= WRITE_WAIT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tPRE_READ: begin\n\t\t\t\tstate <= READ_READY;\n\t\t\tend\n\t\t\tREAD_READY: begin\n\t\t\t\taddress_o <= address_o + 1'b1;\n\t\t\t\tstate <= READ_CAPTURE;\n\t\t\tend\n\t\t\tREAD_CAPTURE: begin\n\t\t\t\trd_buffer <= q_i;\n\t\t\t\tstate <= WAIT_READ;\n\t\t\tend\n\t\t\tWAIT_READ: begin\n\t\t\t\tif( abort_sig ) \n\t\t\t\tbegin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tfsm_abort <= ~fsm_abort;\n\t\t\t\tend else\n\t\t\t\tif( (A_i == 4'd8) && rd_i ) state <= READ_READY;\n\t\t\tend\n\t\t\tWRITE_WAIT: begin\n\t\t\t\tif( abort_sig )\n\t\t\t\tbegin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tfsm_abort <= ~fsm_abort;\n\t\t\t\tend else\n\t\t\t\tif( write_trigger ) begin\n\t\t\t\t\twren_o <= 1'b1;\n\t\t\t\t\tstate <= WRITE_NEXT;\n\t\t\t\tend\n\t\t\t\tdata_o <= D_i;\n\t\t\tend\n\t\t\tWRITE_NEXT: begin\n\t\t\t\taddress_o <= address_o + 1'b1;\n\t\t\t\twren_o <= 1'b0;\n\t\t\t\tstate <= WRITE_WAIT;\n\t\t\tend\n\t\tendcase\n\t\t\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_adder_189ce555", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_adder(\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\n    wire [15:0] a_lo = a[15:0];\n    wire [15:0] a_hi = a[31:16];\n    wire [15:0] b_lo = b[15:0];\n    wire [15:0] b_hi = b[31:16];\n    wire [15:0] sum_lo;\n    wire [15:0] sum_hi;\n    wire cout;\n\n    // First 16-bit adder\n    ripple_adder adder_lo(\n        .a(a_lo),\n        .b(sub ? ~b_lo : b_lo),\n        .cin(sub),\n        .sum(sum_lo),\n        .cout(cout)\n    );\n\n    // Second 16-bit adder\n    ripple_adder adder_hi(\n        .a(a_hi),\n        .b(sub ? ~b_hi : b_hi),\n        .cin(cout),\n        .sum(sum_hi),\n        .cout()\n    );\n\n    // 32-bit XOR gate\n    assign sum = {sum_hi, sum_lo} ^ (sub ? -1 : 0);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Timer_876954c0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Timer(\n\t\toutput reg [3:0]ten,\n\t\toutput reg [3:0]one,\n\t\toutput isFinished,\n\t\tinput clk,\n\t\tinput rst_n\n    );\n\n\treg [3:0] next_ten, next_one;\n\talways @(posedge clk or negedge rst_n) begin\n\t\tif (!rst_n) begin\n\t\t\tten <= 4'd3;\n\t\t\tone <= 4'd0;\n\t\tend else begin\n\t\t\tten <= next_ten;\n\t\t\tone <= next_one;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tif (ten == 4'd0 && one == 4'd0) begin\n\t\t\tnext_ten = 4'd0;\n\t\t\tnext_one = 4'd0;\n\t\tend else begin\n\t\t\tif (one == 4'd0) begin\n\t\t\t\tnext_ten = ten - 4'd1;\n\t\t\t\tnext_one = 4'd9;\n\t\t\tend else begin\n\t\t\t\tnext_ten = ten;\n\t\t\t\tnext_one = one - 4'd1;\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign isFinished = (ten == 4'd0 && one == 4'd0)?1:0;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flip_flop_c0808892", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule flip_flop (\n    input CLK,\n    input D,\n    input SET_B,\n    input CLR_B,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK) begin\n        if (SET_B == 1'b0) begin\n            Q <= 1'b1;\n            Q_N <= 1'b0;\n        end else if (CLR_B == 1'b0) begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ecc_dec_fix_b7b23d66", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule ecc_dec_fix\n  #(\n    parameter TCQ = 100,\n    parameter PAYLOAD_WIDTH      = 64,\n    parameter CODE_WIDTH         = 72,\n    parameter DATA_WIDTH         = 64,\n    parameter DQ_WIDTH           = 72,\n    parameter ECC_WIDTH          = 8,\n    parameter nCK_PER_CLK         = 4\n   )\n   (\n    \n  rd_data, ecc_single, ecc_multiple,\n  clk, rst, h_rows, phy_rddata, correct_en, ecc_status_valid\n  );\n\n  input clk;\n  input rst;\n\n  input [CODE_WIDTH*ECC_WIDTH-1:0] h_rows;\n  input [2*nCK_PER_CLK*DQ_WIDTH-1:0] phy_rddata;\n  wire [2*nCK_PER_CLK*ECC_WIDTH-1:0] syndrome_ns;\n  genvar k;\n  genvar m;\n  generate\n    for (k=0; k<2*nCK_PER_CLK; k=k+1) begin : ecc_word\n      for (m=0; m<ECC_WIDTH; m=m+1) begin : ecc_bit\n        assign syndrome_ns[k*ECC_WIDTH+m] =\n   ^(phy_rddata[k*DQ_WIDTH+:CODE_WIDTH] & h_rows[m*CODE_WIDTH+:CODE_WIDTH]);\n      end\n    end\n  endgenerate\n  reg [2*nCK_PER_CLK*ECC_WIDTH-1:0] syndrome_r;\n  always @(posedge clk) syndrome_r <= #TCQ syndrome_ns;\n\n  wire [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] ecc_rddata_ns;\n  genvar i;\n  generate\n    for (i=0; i<2*nCK_PER_CLK; i=i+1) begin : extract_payload\n      assign ecc_rddata_ns[i*PAYLOAD_WIDTH+:PAYLOAD_WIDTH] =\n               phy_rddata[i*DQ_WIDTH+:PAYLOAD_WIDTH];\n    end\n  endgenerate\n  reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] ecc_rddata_r;\n  always @(posedge clk) ecc_rddata_r <= #TCQ ecc_rddata_ns;\n\n  genvar n;\n  genvar p;\n  wire [ECC_WIDTH-1:0] h_matrix [DATA_WIDTH-1:0];\n  generate\n    for (n=0; n<DATA_WIDTH; n=n+1) begin : h_col\n      for (p=0; p<ECC_WIDTH; p=p+1) begin : h_bit\n        assign h_matrix [n][p] = h_rows [p*CODE_WIDTH+n];\n      end\n    end\n  endgenerate             \n      \n  wire [2*nCK_PER_CLK*DATA_WIDTH-1:0] flip_bits;\n  genvar q;\n  genvar r;\n  generate\n    for (q=0; q<2*nCK_PER_CLK; q=q+1) begin : flip_word\n      for (r=0; r<DATA_WIDTH; r=r+1) begin : flip_bit\n        assign flip_bits[q*DATA_WIDTH+r] = \n          h_matrix[r] == syndrome_r[q*ECC_WIDTH+:ECC_WIDTH];\n      end\n    end\n  endgenerate\n\n  output reg [2*nCK_PER_CLK*PAYLOAD_WIDTH-1:0] rd_data;\n  input correct_en;\n  integer s;\n  always @(correct_en or ecc_rddata_r or flip_bits)\n    for (s=0; s<2*nCK_PER_CLK; s=s+1)\n      if (correct_en)\n        rd_data[s*PAYLOAD_WIDTH+:DATA_WIDTH] = \n          ecc_rddata_r[s*PAYLOAD_WIDTH+:DATA_WIDTH] ^ \n              flip_bits[s*DATA_WIDTH+:DATA_WIDTH];\n      else rd_data[s*PAYLOAD_WIDTH+:DATA_WIDTH] = \n           ecc_rddata_r[s*PAYLOAD_WIDTH+:DATA_WIDTH];\n\n  localparam RAW_BIT_WIDTH = PAYLOAD_WIDTH - DATA_WIDTH;\n  genvar t;\n  generate\n    if (RAW_BIT_WIDTH > 0)\n      for (t=0; t<2*nCK_PER_CLK; t=t+1) begin : copy_raw_bits\n        always @(ecc_rddata_r)\n          rd_data[(t+1)*PAYLOAD_WIDTH-1-:RAW_BIT_WIDTH] =\n            ecc_rddata_r[(t+1)*PAYLOAD_WIDTH-1-:RAW_BIT_WIDTH];\n      end\n  endgenerate\n\n  input ecc_status_valid;\n  output wire [2*nCK_PER_CLK-1:0] ecc_single;\n  output wire [2*nCK_PER_CLK-1:0] ecc_multiple;\n  genvar v;\n  generate\n    for (v=0; v<2*nCK_PER_CLK; v=v+1) begin : compute_status\n      wire zero = ~|syndrome_r[v*ECC_WIDTH+:ECC_WIDTH];\n      wire odd = ^syndrome_r[v*ECC_WIDTH+:ECC_WIDTH];\n      assign ecc_single[v] = ecc_status_valid && ~zero && odd;\n      assign ecc_multiple[v] = ecc_status_valid && ~zero && ~odd;\n    end\n  endgenerate\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flt_fx_24p8_5589b308", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule flt_fx_24p8\n\t(\n\tinput\t[31:0]\tfp_in,         output reg [31:0] int_out      );\nwire    [7:0]   bias_exp;       \nwire    [7:0]   bias_exp2;      \nwire    [39:0]  fixed_out2;     \nwire    [47:0]  bias_mant;      \nreg     [47:0]  int_fixed_out;\n\nreg    [31:0]  fixed_out;\n\nassign bias_mant = {25'h0001, fp_in[22:0]};\nassign bias_exp = fp_in[30:23] - 8'd127;\nassign bias_exp2 = ~bias_exp + 8'h1;\n\nalways @* begin\n\tif (fp_in[30:0] == 31'b0) int_fixed_out = 0;\n  \telse if (bias_exp[7]) int_fixed_out = bias_mant >> bias_exp2;\n  \telse int_fixed_out = bias_mant << bias_exp;\n\n\tfixed_out = int_fixed_out[46:15];\n\tint_out = (fp_in[31]) ? ~fixed_out + 1 : fixed_out;\nend\n\nendmodule\n\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "final_output_b1be6538", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule final_output (\n  input clk,\n  input reset,\n  input [7:0] in,\n  output [7:0] anyedge,\n  output [7:0] count,\n  output [7:0] result\n);\n\n  // Shift register to detect bit transitions\n  reg [7:0] sr;\n  always @(posedge clk) begin\n    if (reset) begin\n      sr <= 8'b0;\n    end else begin\n      sr <= {in, sr[7:1]};\n    end\n  end\n  assign anyedge = in ^ sr;\n\n  // Population count circuit\n  function integer popcount;\n    input [7:0] data;\n    integer i;\n    begin\n      popcount = 0;\n      for (i = 0; i < 8; i = i + 1) begin\n        if (data[i]) begin\n          popcount = popcount + 1;\n        end\n      end\n    end\n  endfunction\n\n  // Final output generation\n  assign count = popcount(in);\n  assign result = count + {anyedge[0], anyedge[7:1]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "conmutacion_1c8958b7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule conmutacion\t(\n\t\t\t\tinput\t\t[3:0]\tcentenas,\n\t\t\t\tinput\t\t[3:0]\tdecenas,\n\t\t\t\tinput\t\t[3:0]\tunidades,\n\t\t\t\tinput\t\t\tC,\n\t\t\t\tinput\t\t\tDe,\n\t\t\t\tinput\t\t\tU,\n\t\t\t\tinput\t\t\tCLKOUTseg,\n\t\t\t\toutput\treg\t[1:0]\tmostrar,\n\t\t\t\toutput\treg\t[3:0]\tdigito\n\t\t\t);\n\n\n\treg\t\tlogic0;\n\treg\t[1:0]\ttitileo;\n\tinitial\n\tbegin\n\t\ttitileo = 0;\n\tend\n\talways@(posedge CLKOUTseg)\n\tbegin\n\t\tif(C && De && U)\n\t\tbegin\n\t\t\t\n\t\t\ttitileo\t<= titileo + 1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(De && U)\n\t\t\tbegin\n\t\t\t\t\n\t\t\t\ttitileo\t<= titileo + 1;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(U)\n\t\t\t\tbegin\n\t\t\t\t\ttitileo\t<= 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\ttitileo <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\talways@(posedge CLKOUTseg)\n\tbegin\n\t\t\tcase(titileo)\n\t\t\t\t2'b00:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b01;\n\t\t\t\t\tdigito\t= 0;\n\t\t\t\tend\n\t\t\t\t2'b01:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b01;\n\t\t\t\t\tdigito\t= unidades;\n\t\t\t\tend\n\t\t\t\t2'b10:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b10;\n\t\t\t\t\tdigito\t= decenas; \n\t\t\t\tend\n\t\t\t\t2'b11:\n\t\t\t\tbegin\n\t\t\t\t\tmostrar = 2'b11;\n\t\t\t\t\tdigito\t= centenas;\n\t\t\t\tend\n\t\t\tendcase\t\n\tend\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xlslice_2d176f5a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xlslice (\n  input wire [23:0] Din,\n  output wire [8:0] Dout\n);\n\n  wire [15:0] sliced_signal;\n  wire [15:0] inverted_signal;\n  wire [8:0] shifted_signal;\n\n  assign sliced_signal = Din[22:7];\n  assign inverted_signal = ~sliced_signal;\n  assign shifted_signal = inverted_signal >> 8;\n\n  assign Dout = shifted_signal;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sleep_control_a75c9fbf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sleep_control (\n    output reg MBC_ISOLATE,\n    output MBC_ISOLATE_B,\n    output reg MBC_RESET,\n    output MBC_RESET_B,\n    output MBC_SLEEP,\n    output MBC_SLEEP_B,\n    output SYSTEM_ACTIVE,\n    output WAKEUP_REQ_ORED,\n    input CLK,\n    input MBUS_DIN,\n    input RESETn,\n    input SLEEP_REQ,\n    input WAKEUP_REQ0,\n    input WAKEUP_REQ1,\n    input WAKEUP_REQ2\n);\n\n    reg set_tran_to_wake;\n    reg rst_tran_to_wake;\n    reg MBC_SLEEP_int;\n    reg tran_to_wake;\n    wire tran_to_wake_r;\n\n    assign MBC_ISOLATE_B = ~MBC_ISOLATE;\n    assign MBC_RESET_B = ~MBC_RESET;\n    assign MBC_SLEEP_B = ~MBC_SLEEP;\n    assign SYSTEM_ACTIVE = MBC_SLEEP_B | MBC_ISOLATE_B;\n    assign WAKEUP_REQ_ORED = WAKEUP_REQ0 | WAKEUP_REQ1 | WAKEUP_REQ2;\n\n    always @* begin\n        if (RESETn & (WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN))) begin\n            set_tran_to_wake = 1'b1;\n        end else begin\n            set_tran_to_wake = 1'b0;\n        end\n    end\n\n    always @* begin\n        if ((~RESETn) | (WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN) | ~SLEEP_REQ)) begin\n            rst_tran_to_wake <= 1'b1;\n        end else begin\n            rst_tran_to_wake <= 1'b0;\n        end\n    end\n\n    always @ (negedge tran_to_wake_r or posedge set_tran_to_wake) begin\n        if (~tran_to_wake_r) begin\n            tran_to_wake <= 1'b0;\n        end else begin\n            tran_to_wake <= 1'b1;\n        end\n    end\n\n    assign tran_to_wake_r = RESETn & rst_tran_to_wake;\n\n    always @ (negedge RESETn or posedge CLK) begin\n        if (~RESETn) begin\n            MBC_ISOLATE <= 1'b1;\n        end else begin\n            MBC_ISOLATE <= (MBC_SLEEP_int | (~tran_to_wake));\n        end\n    end\n\n    always @ (negedge RESETn or posedge CLK) begin\n        if (~RESETn) begin\n            MBC_SLEEP_int <= 1'b1;\n        end else begin\n            MBC_SLEEP_int <= (MBC_ISOLATE & (~tran_to_wake));\n        end\n    end\n\n    assign MBC_SLEEP = MBC_SLEEP_int & ~(WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN));\n\n    always @ (negedge RESETn or posedge CLK) begin\n        if (~RESETn) begin\n            MBC_RESET <= 1'b1;\n        end else begin\n            MBC_RESET <= MBC_ISOLATE;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplexer_140d7c52", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Multiplexer (\n  input ctrl,\n  input D0,\n  input D1,\n  output S\n);\n\n  assign S = ctrl ? D1 : D0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_operation_42a7d101", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule bitwise_operation(\n    input [7:0] a_in,\n    input [7:0] b_in,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out[7:2] = a_in[7:2];\n        out[1] = ~(a_in[1] ^ b_in[1]);\n        out[0] = a_in[0] ^ b_in[0];\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "agnus_audiodma_f338faa9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule agnus_audiodma\n(\n  input  wire           clk,              input  wire           clk7_en,          output wire           dma,              input  wire [  4-1:0] audio_dmal,       input  wire [  4-1:0] audio_dmas,       input  wire [  9-1:0] hpos,             input  wire [  9-1:1] reg_address_in,   output reg  [  9-1:1] reg_address_out,  input  wire [ 16-1:0] data_in,          output wire [ 21-1:1] address_out       );\n\n\nparameter AUD0DAT_REG = 9'h0AA;\nparameter AUD1DAT_REG = 9'h0BA;\nparameter AUD2DAT_REG = 9'h0CA;\nparameter AUD3DAT_REG = 9'h0DA;\n\nwire          audlcena;     wire [  1: 0] audlcsel;     reg  [ 20:16] audlch [3:0]; reg  [ 15: 1] audlcl [3:0]; wire [ 20: 1] audlcout;     reg  [ 20: 1] audpt [3:0];  wire [ 20: 1] audptout;     reg  [  1: 0] channel;      reg           dmal;\nreg           dmas;\n\nassign audlcena = ~reg_address_in[8] & reg_address_in[7] & (reg_address_in[6]^reg_address_in[5]) & ~reg_address_in[3] & ~reg_address_in[2];\n\nassign audlcsel = {~reg_address_in[5],reg_address_in[4]};\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (audlcena & ~reg_address_in[1]) audlch[audlcsel] <= #1 data_in[4:0];\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (audlcena & reg_address_in[1]) audlcl[audlcsel] <= #1 data_in[15:1];\n  end\nend\n\nassign audlcout = {audlch[channel],audlcl[channel]};\n\nalways @ (*) begin\n  case (hpos)\n    9'b0001_0010_1 : dmal = audio_dmal[0]; 9'b0001_0100_1 : dmal = audio_dmal[1]; 9'b0001_0110_1 : dmal = audio_dmal[2]; 9'b0001_1000_1 : dmal = audio_dmal[3]; default        : dmal = 0;\n  endcase\nend\n\nassign dma = dmal;\n\nalways @ (*) begin\n  case (hpos)\n    9'b0001_0010_1 : dmas = audio_dmas[0]; 9'b0001_0100_1 : dmas = audio_dmas[1]; 9'b0001_0110_1 : dmas = audio_dmas[2]; 9'b0001_1000_1 : dmas = audio_dmas[3]; default        : dmas = 0;\n  endcase\nend\n\nalways @ (*) begin\n  case (hpos[3:2])\n    2'b01 : channel = 0; 2'b10 : channel = 1; 2'b11 : channel = 2; 2'b00 : channel = 3; endcase\nend\n\nassign address_out[20:1] = audptout[20:1];\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (dmal)\n      audpt[channel] <= #1 dmas ? audlcout[20:1] : audptout[20:1] + 1'b1;\n  end\nend\n\nassign audptout[20:1] = audpt[channel];\n\nalways @ (*) begin\n  case (channel)\n    0 : reg_address_out[8:1] = AUD0DAT_REG[8:1];\n    1 : reg_address_out[8:1] = AUD1DAT_REG[8:1];\n    2 : reg_address_out[8:1] = AUD2DAT_REG[8:1];\n    3 : reg_address_out[8:1] = AUD3DAT_REG[8:1];\n  endcase\nend\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_8116503c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if (a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end else if (a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mult_16x16_0016276d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mult_16x16 (\n    input [15:0] Amult, // o\n    input [15:0] Bmult, // o\n    input [1:0] Valid_mult, // o\n    output [31:0] Cmult // i\n);\n\n    wire [31:0] Amult_int;\n    wire [31:0] Bmult_int;\n    wire [63:0] Cmult_int;\n\n    assign Amult_int = {16'b0, Amult};\n    assign Bmult_int = {16'b0, Bmult};\n\n    MULT #(.WIDTH(32)) mult_inst (\n        .Amult(Amult_int), // i\n        .Bmult(Bmult_int), // i\n        .Valid_mult(Valid_mult), // i\n        .Cmult(Cmult_int), // o\n        .sel_mul_32x32(1'b1) // i\n    );\n\n    assign Cmult = Cmult_int[31:0];\n\nendmodule\nmodule MULT #(\n    parameter WIDTH = 32\n) (\n    input [WIDTH-1:0] Amult, // i\n    input [WIDTH-1:0] Bmult, // i\n    input [1:0] Valid_mult, // i\n    output [2*WIDTH-1:0] Cmult, // o\n    input sel_mul_32x32 // i\n);\n\n    reg [2*WIDTH-1:0] Cmult_reg;\n    reg [WIDTH-1:0] Amult_reg;\n    reg [WIDTH-1:0] Bmult_reg;\n    reg [1:0] Valid_mult_reg;\n\n    always @(posedge Valid_mult[0]) begin\n        Amult_reg <= Amult;\n        Bmult_reg <= Bmult;\n        Valid_mult_reg <= Valid_mult;\n    end\n\n    always @(posedge Valid_mult[0]) begin\n        if (sel_mul_32x32) begin\n            Cmult_reg <= Amult_reg * Bmult_reg;\n        end else begin\n            Cmult_reg <= {WIDTH{1'b0}};\n        end\n    end\n\n    assign Cmult = Cmult_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__2b07e306", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input shift_left, // Control input to shift register to the left\n    input shift_right,// Control input to shift register to the right\n    output [3:0] q    // 4-bit output from the functional module\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] shift_register_out;\n    wire [3:0] functional_out;\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .count(counter_out)\n    );\n\n    shift_register shift_register_inst (\n        .clk(clk),\n        .reset(reset),\n        .shift_left(shift_left),\n        .shift_right(shift_right),\n        .data_in(counter_out), // Updated to select 4 bits\n        .data_out(shift_register_out)\n    );\n\n    functional_module functional_inst (\n        .counter_in(counter_out),\n        .shift_register_in(shift_register_out),\n        .functional_out(functional_out)\n    );\n\n    assign q = functional_out;\n\nendmodule\nmodule counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin // Updated sensitivity list\n        if (reset) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 4'b0001; // Updated to add 4-bit value\n        end\n    end\nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input shift_left,\n    input shift_right,\n    input [3:0] data_in, // Updated input data width\n    output reg [3:0] data_out\n);\n    always @(posedge clk or posedge reset) begin // Updated sensitivity list\n        if (reset) begin\n            data_out <= 4'b0000;\n        end else begin\n            if (shift_left) begin\n                data_out <= {data_out[2:0], data_in[3]};\n            end else if (shift_right) begin\n                data_out <= {data_in[0], data_out[3:1]};\n            end\n        end\n    end\nendmodule\nmodule functional_module (\n    input [3:0] counter_in,\n    input [3:0] shift_register_in,\n    output reg [3:0] functional_out\n);\n    always @(*) begin\n        functional_out = (counter_in + shift_register_in) ^ 4'b1010;\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_module_518a5bf8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_module(\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output out\n);\n\nwire and1, and2, or1, xor1, or2;\n\nassign and1 = A1 & A2;\nassign and2 = A3 & B1;\nassign or1 = and1 | and2;\nassign xor1 = VPWR ^ VGND;\nassign or2 = VPB | VNB;\n\nassign out = or1 & xor1 & or2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_module_1a5c987c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_module(\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'b0000;\n    end else if (en) begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__0483a611", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [3:0] in,\n    input [3:0] A,\n    input [3:0] B,\n    output [5:0] final_output\n); \n\nwire [1:0] priority_output;\nwire [3:0] ripple_sum;\nwire carry;\n\npriority_encoder pe(\n    .in(in),\n    .out(priority_output)\n);\n\nripple_carry_adder rca(\n    .A(A),\n    .B(B),\n    .SUM(ripple_sum),\n    .CARRY(carry)\n);\n\nfunctional_module fm(\n    .priority_output(priority_output),\n    .ripple_sum(ripple_sum),\n    .final_output(final_output)\n);\n\nendmodule\n\nmodule priority_encoder (\n    input [3:0] in,\n    output [1:0] out\n);\nassign out = (in == 4'b0001) ? 2'b00 :\n              (in == 4'b0010) ? 2'b01 :\n              (in == 4'b0100) ? 2'b10 :\n              (in == 4'b1000) ? 2'b11 : 2'b11;\nendmodule\n\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM,\n    output CARRY\n);\nassign {CARRY, SUM} = A + B;\nendmodule\n\nmodule functional_module (\n    input [1:0] priority_output,\n    input [3:0] ripple_sum,\n    output [5:0] final_output\n);\nassign final_output = {priority_output, ripple_sum};\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__184cb18c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input [11:0] in,\n    output [7:0] out\n);\n\n    // Split the 12-bit input into lower, middle, and upper bytes\n    wire [3:0] lower = in[3:0];\n    wire [3:0] middle = in[7:4];\n    wire [3:0] upper = in[11:8];\n\n    // Create a 3-bit shift register using master-slave flip-flops\n    reg [2:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[1:0], lower};\n    end\n\n    // Perform a left rotation on the lower byte using the shift register\n    wire [3:0] rotated_lower = {shift_reg[2], shift_reg[1], shift_reg[0]};\n\n    // Combine the rotated lower byte, middle byte, and upper byte using a barrel shifter\n    wire [11:0] shifted_in = {rotated_lower, middle, upper};\n    wire [11:0] and_out;\n\n    // Perform a bitwise AND operation between the shifted input and the original input\n    assign and_out = shifted_in & in;\n\n    // Output the result of the AND operation\n    assign out = and_out[7:0];\n\nendmodule\nmodule barrel_shifter (\n    input [11:0] in,\n    input [1:0] shift,\n    output [11:0] out\n);\n\n    assign out = (shift[1]) ? ({in[7:0], in[11:8], in[3:0]}) :\n                             ({in[3:0], in[7:4], in[11:8], in[10:4] >> shift[0]});\n\nendmodule\nmodule and_gate (\n    input [11:0] in1,\n    input [11:0] in2,\n    output [11:0] out\n);\n\n    assign out = in1 & in2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_fbdf3326", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n   // Inputs\n   clk,\n   rst,\n   count\n   // Outputs\n   );\n   input clk, rst;\n   output reg [3:0] count;\n\n   always @(posedge clk) begin\n      if (rst) begin\n         count <= 4'b0;\n      end\n      else begin\n         count <= count + 1;\n      end\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "OR_gate_dc9af561", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule OR_gate (\n  input a,\n  input b,\n  output reg out\n);\n\n  always @ (a or b) begin\n    if (a || b) begin\n      out = 1'b1;\n    end\n    else begin\n      out = 1'b0;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotate_a42981b4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule rotate (\n    input  [15:0] x,\n    input  [ 4:0] y,\n    input  [ 1:0] func,  input         cfi,\n    input         word_op,\n    output [15:0] out,\n    output        cfo,\n    input         ofi,\n    output        ofo\n  );\n\n  wire [4:0] ror16, rol16, rcr16, rcl16, rot16;\n  wire [3:0] ror8, rol8, rcr8, rcl8, rot8;\n  wire [7:0] out8;\n  wire [15:0] out16;\n  wire co8, co16;\n  wire unchanged;\n\n  rxr8 rxr8_0 (\n    .x  (x[7:0]),\n    .ci (cfi),\n    .y  (rot8),\n    .e  (func[1]),\n    .w  (out8),\n    .co (co8)\n  );\n\n  rxr16 rxr16_0 (\n    .x  (x),\n    .ci (cfi),\n    .y  (rot16),\n    .e  (func[1]),\n    .w  (out16),\n    .co (co16)\n  );\n\n  assign unchanged = word_op ? (y==5'b0) : (y[3:0]==4'b0);\n  assign ror16 = { 1'b0, y[3:0] };\n  assign rol16 = { 1'b0, -y[3:0] };\n  assign ror8  = { 1'b0, y[2:0] };\n  assign rol8  = { 1'b0, -y[2:0] };\n\n  assign rcr16 = (y <= 5'd16) ? y : { 1'b0, y[3:0] - 4'b1 };\n  assign rcl16 = (y <= 5'd17) ? 5'd17 - y : 6'd34 - y;\n  assign rcr8  = y[3:0] <= 4'd8 ? y[3:0] : { 1'b0, y[2:0] - 3'b1 };\n  assign rcl8  = y[3:0] <= 4'd9 ? 4'd9 - y[3:0] : 5'd18 - y[3:0];\n\n  assign rot8 = func[1] ? (func[0] ? rcl8 : rcr8 )\n                        : (func[0] ? rol8 : ror8 );\n  assign rot16 = func[1] ? (func[0] ? rcl16 : rcr16 )\n                         : (func[0] ? rol16 : ror16 );\n\n  assign out = word_op ? out16 : { x[15:8], out8 };\n  assign cfo = unchanged ? cfi : (func[1] ? (word_op ? co16 : co8)\n                                          : (func[0] ? out[0]\n                                            : (word_op ? out[15] : out[7])));\n  assign ofo = unchanged ? ofi : (func[0] ? (word_op ? cfo^out[15] : cfo^out[7])\n                       : (word_op ? out[15]^out[14] : out[7]^out[6]));\nendmodule\n\nmodule rxr16 (\n    input      [15:0] x,\n    input             ci,\n    input      [ 4:0] y,\n    input             e,\n    output reg [15:0] w,\n    output reg        co\n  );\n\n  always @(x or ci or y or e)\n    case (y)\n      default: {co,w} <= {ci,x};\n      5'd01: {co,w} <= e ? {x[0], ci, x[15:1]} : {ci, x[0], x[15:1]};\n      5'd02: {co,w} <= e ? {x[ 1:0], ci, x[15: 2]} : {ci, x[ 1:0], x[15: 2]};\n      5'd03: {co,w} <= e ? {x[ 2:0], ci, x[15: 3]} : {ci, x[ 2:0], x[15: 3]};\n      5'd04: {co,w} <= e ? {x[ 3:0], ci, x[15: 4]} : {ci, x[ 3:0], x[15: 4]};\n      5'd05: {co,w} <= e ? {x[ 4:0], ci, x[15: 5]} : {ci, x[ 4:0], x[15: 5]};\n      5'd06: {co,w} <= e ? {x[ 5:0], ci, x[15: 6]} : {ci, x[ 5:0], x[15: 6]};\n      5'd07: {co,w} <= e ? {x[ 6:0], ci, x[15: 7]} : {ci, x[ 6:0], x[15: 7]};\n      5'd08: {co,w} <= e ? {x[ 7:0], ci, x[15: 8]} : {ci, x[ 7:0], x[15: 8]};\n      5'd09: {co,w} <= e ? {x[ 8:0], ci, x[15: 9]} : {ci, x[ 8:0], x[15: 9]};\n      5'd10: {co,w} <= e ? {x[ 9:0], ci, x[15:10]} : {ci, x[ 9:0], x[15:10]};\n      5'd11: {co,w} <= e ? {x[10:0], ci, x[15:11]} : {ci, x[10:0], x[15:11]};\n      5'd12: {co,w} <= e ? {x[11:0], ci, x[15:12]} : {ci, x[11:0], x[15:12]};\n      5'd13: {co,w} <= e ? {x[12:0], ci, x[15:13]} : {ci, x[12:0], x[15:13]};\n      5'd14: {co,w} <= e ? {x[13:0], ci, x[15:14]} : {ci, x[13:0], x[15:14]};\n      5'd15: {co,w} <= e ? {x[14:0], ci, x[15]} : {ci, x[14:0], x[15]};\n      5'd16: {co,w} <= {x,ci};\n    endcase\nendmodule\n\nmodule rxr8 (\n    input      [7:0] x,\n    input            ci,\n    input      [3:0] y,\n    input            e,\n    output reg [7:0] w,\n    output reg       co\n  );\n\n  always @(x or ci or y or e)\n    case (y)\n      default: {co,w} <= {ci,x};\n      5'd01: {co,w} <= e ? {x[0], ci, x[7:1]} : {ci, x[0], x[7:1]};\n      5'd02: {co,w} <= e ? {x[1:0], ci, x[7:2]} : {ci, x[1:0], x[7:2]};\n      5'd03: {co,w} <= e ? {x[2:0], ci, x[7:3]} : {ci, x[2:0], x[7:3]};\n      5'd04: {co,w} <= e ? {x[3:0], ci, x[7:4]} : {ci, x[3:0], x[7:4]};\n      5'd05: {co,w} <= e ? {x[4:0], ci, x[7:5]} : {ci, x[4:0], x[7:5]};\n      5'd06: {co,w} <= e ? {x[5:0], ci, x[7:6]} : {ci, x[5:0], x[7:6]};\n      5'd07: {co,w} <= e ? {x[6:0], ci, x[7]} : {ci, x[6:0], x[7]};\n      5'd08: {co,w} <= {x,ci};\n    endcase\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jcarrylookaheadadder_0dd07b32", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule jcarrylookaheadadder(Y,carryout,A,B,carryin);\n  output [3:0]Y;\n  output carryout;\n  input [3:0]A,B;\n  input carryin;\n\n  wire [3:0]g,p;wire [4:0]c;assign c[0] = carryin; assign Y[0] = A[0] ^ B[0] ^ c[0];\n  assign c[1] = ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) );\n  \n  assign Y[1] = A[1] ^ B[1] ^ c[1];\n  assign c[2] = ( ( A[1] & B[1] ) | ( ( A[1] ^ B[1] ) & ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) ) ) ); assign Y[2] = A[2] ^ B[2] ^ c[2];\n  assign c[3] = ( ( A[2] & B[2] ) | ( ( A[2] ^ B[2] ) & ( ( A[1] & B[1] ) | ( ( A[1] ^ B[1] ) & ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) ) ) ) ) );\n  \n  assign Y[3] = A[3] ^ B[3] ^ c[3];\n  assign c[4] = ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & ( ( A[2] & B[2] ) | ( ( A[2] ^ B[2] ) & ( ( A[1] & B[1] ) | ( ( A[1] ^ B[1] ) & ( ( A[0] & B[0] ) | ( ( A[0] ^ B[0] ) & c[0] ) ) ) ) ) ) ) );  \n  \n\n  assign carryout = c[4];\n\n  \nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_checker_1c0e58d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule parity_checker (\n  input [2:0] data,\n  output reg parity\n);\n  \n  always @(*) begin\n    parity = (data[0] ^ data[1] ^ data[2]);\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bit_counter_0f6a2b26", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule bit_counter (\n    input [15:0] D,\n    output [3:0] count,\n    input clk // Added the clock input\n);\n\n// Create a 4-bit parallel prefix adder\nwire [3:0] P[0:3];\nassign P[0] = D[3:0];\nassign P[1] = P[0] + D[7:4];\nassign P[2] = P[1] + D[11:8];\nassign P[3] = P[2] + D[15:12];\n\n// Register the count\nreg [3:0] count_reg;\nalways @(posedge clk) begin\n    count_reg <= P[3]; // Corrected typo here\nend\n\n// Output the count\nassign count = count_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_4bit_carry_eff6c232", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_4bit_carry (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] full_sum;\n    assign full_sum = {1'b0, a} + {1'b0, b} + {1'b0, cin};\n\n    assign sum = full_sum[3:0];\n    assign cout = full_sum[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pg_to_PG_6331fac9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pg_to_PG(\n    input [15:0] p,\n    input [15:0] g,\n    output [3:0] bp,\n    output [3:0] bg\n    );\n\nassign bg[0]=g[3 ]|p[3 ]&g[2 ]|p[3 ]&p[2 ]&g[1 ]|p[3 ]&p[2 ]&p[1 ]&g[0 ],\n       bg[1]=g[7 ]|p[7 ]&g[6 ]|p[7 ]&p[6 ]&g[5 ]|p[7 ]&p[6 ]&p[5 ]&g[4 ], \n       bg[2]=g[11]|p[11]&g[10]|p[11]&p[10]&g[9 ]|p[11]&p[10]&p[9 ]&g[8 ], \n       bg[3]=g[15]|p[15]&g[14]|p[15]&p[14]&g[13]|p[15]&p[14]&p[13]&g[12];\n\t\t \nassign\tbp[0]=p[3]&p[2]&p[1]&p[0],\n\t\t\tbp[1]=p[7]&p[6]&p[5]&p[4],\n\t\t\tbp[2]=p[11]&p[10]&p[9]&p[8],\n\t\t\tbp[3]=p[15]&p[14]&p[13]&p[12];\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SSEG_Driver_cd12b54e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule SSEG_Driver( clk, reset, data, sseg, an );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ninput  wire clk;\ninput  wire reset;\ninput  wire[15:0] data;\noutput reg[6:0] sseg;\noutput reg[3:0] an;\n\n\nwire[3:0] hex3,hex2,hex1,hex0;\t\n\nassign hex3 = data[15:12];\nassign hex2 = data[11:8];\nassign hex1 = data[7:4];\nassign hex0 = data[3:0];\n\nlocalparam N = 18;\n\nreg[N-1:0] q_reg;\nwire[N-1:0] q_next;\nreg[3:0] hex_in;\n\nalways@( posedge clk or posedge reset )\n\tif( reset )\n\t\tq_reg <= 0;\n\telse\n\t\tq_reg <= q_next;\n\t\t\nassign q_next = q_reg + 1;\n\nalways@( * )\n\tcase( q_reg[N-1:N-2] )\n\t\t2'b00:\n\t\tbegin\n\t\t\tan = 4'b1110;\n\t\t\thex_in = hex0;\n\t\tend\n\t\t\n\t\t2'b01:\n\t\tbegin\n\t\t\tan = 4'b1101;\n\t\t\thex_in = hex1;\n\t\tend\t\n\n\t\t2'b10:\n\t\tbegin\n\t\t\tan = 4'b1011;\n\t\t\thex_in = hex2;\n\t\tend\t\t\n\t\t\n\t\t2'b11:\n\t\tbegin\n\t\t\tan = 4'b0111;\n\t\t\thex_in = hex3;\n\t\tend\n\tendcase\n\t\n\talways@( * )\n\tbegin\n\t\tcase( hex_in )\n\t\t\t\t0 : sseg[6:0] = 7'b1000000;  1 : sseg[6:0] = 7'b1111001;  2 : sseg[6:0] = 7'b0100100;  3 : sseg[6:0] = 7'b0110000;  4 : sseg[6:0] = 7'b0011001;  5 : sseg[6:0] = 7'b0010010;  6 : sseg[6:0] = 7'b0000010;  7 : sseg[6:0] = 7'b1111000;  8 : sseg[6:0] = 7'b0000000;  9 : sseg[6:0] = 7'b0010000;  'hA : sseg[6:0] = 7'b0001000;  'hB : sseg[6:0] = 7'b0000011;  'hC : sseg[6:0] = 7'b1000110;  'hD : sseg[6:0] = 7'b0100001;  'hE : sseg[6:0] = 7'b0000110;  'hF : sseg[6:0] = 7'b0001110;  default : sseg[6:0] = 7'b1111111;\n\t\tendcase\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand2_4a870628", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule nand2 (\n    input A,\n    input B,\n    output Y\n);\n\n    assign Y = ~(A & B);\n\nendmodule\nmodule and2 (\n    input A,\n    input B,\n    output Y\n);\n\n    assign Y = A & B;\n\nendmodule\nmodule nand_gate (\n    input A,\n    input B,\n    input VPWR,\n    input VGND,\n    input KAPWR,\n    output Y\n);\n\n    wire nand_out;\n\n    nand2 nand_gate_inst (\n        .A(A),\n        .B(B),\n        .Y(nand_out)\n    );\n\n    and2 and_gate_inst (\n        .A(nand_out),\n        .B(KAPWR),\n        .Y(Y)\n    );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_counter_bd82e1ac", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo_counter (\n  input empty,\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [4:0] fifo_cnt_inc\n);\n\n  always @(*) begin\n    if (empty) begin\n      fifo_cnt_inc = input_tm_cnt[1:0];\n    end\n    else if (ge3_free && (input_tm_cnt == 2'b11)) begin\n      fifo_cnt_inc = 2;\n    end\n    else if (ge2_free && (input_tm_cnt >= 2)) begin\n      fifo_cnt_inc = 1;\n    end\n    else if (input_tm_cnt >= 1) begin\n      fifo_cnt_inc = 0;\n    end\n    else begin\n      fifo_cnt_inc = 31;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "accumulator #_11859ee3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule accumulator #(\n  parameter n = 8 // number of bits in binary numbers\n)(\n  input [n-1:0] data,\n  input clk,\n  input rst,\n  output reg [n-1:0] sum\n);\n\n\nreg [n-1:0] prev_sum; // flip-flop to store previous sum\n\nalways @(posedge clk) begin\n  if (rst) begin\n    sum <= 0; // reset sum to 0\n    prev_sum <= 0; // reset previous sum to 0\n  end else begin\n    prev_sum <= sum; // store previous sum\n    sum <= data + prev_sum; // update sum with current data and previous sum\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pwmregister_8556525d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pwmregister(\n  output reg [7:0] pwmval,\n  input clk,\n  input pwmldce,\n  input [7:0] wrtdata);\n  \n  always@(posedge clk) begin\n    if(pwmldce) begin\n      pwmval <= wrtdata;\n    end\n  end \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ac97commands_da1af954", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ac97commands (\n  input wire clock,\n  input wire ready,\n  output wire [7:0] command_address,\n  output wire [15:0] command_data,\n  output reg command_valid,\n  input wire [4:0] volume,\n  input wire [2:0] source\n);\n  reg [23:0] command;\n\n  reg [3:0] state;\n  initial begin\n    command <= 4'h0;\n    command_valid <= 1'b0;\n    state <= 16'h0000;\n  end\n\n  assign command_address = command[23:16];\n  assign command_data = command[15:0];\n\n  wire [4:0] vol;\n  assign vol = 31-volume;\n\n  always @(posedge clock) begin\n    if (ready) state <= state+1;\n\n    case (state)\n      4'h0: // Read ID\n        begin\n          command <= 24'h80_0000;\n          command_valid <= 1'b1;\n        end\n      4'h1: // Read ID\n        command <= 24'h80_0000;\n      4'h3: // headphone volume\n        command <= { 8'h04, 3'b000, vol, 3'b000, vol };\n      4'h5: // PCM volume\n        command <= 24'h18_0808;\n      4'h6: // Record source select\n        command <= { 8'h1A, 5'b00000, source, 5'b00000, source};\n      4'h7: // Record gain = max\n        command <= 24'h1C_0F0F;\n      4'h9: // set +20db mic gain\n        command <= 24'h0E_8048;\n      4'hA: // Set beep volume\n        command <= 24'h0A_0000;\n      4'hB: // PCM out bypass mix1\n        command <= 24'h20_8000;\n      default:\n        command <= 24'h80_0000;\n    endcase\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "iic_multiplexer #_92eabda4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule iic_multiplexer #\n    (\n        parameter integer MUX_WIDTH = 2\n    ) \n    (  \n        input  wire upstream_scl_T,\n        input  wire upstream_scl_I,\n        output wire upstream_scl_O,\n        input  wire upstream_sda_T,\n        input  wire upstream_sda_I,\n        output wire upstream_sda_O,\n        \n        output wire [MUX_WIDTH - 1:0] downstream_scl_T,\n        input  wire [MUX_WIDTH - 1:0] downstream_scl_I,\n        output wire [MUX_WIDTH - 1:0] downstream_scl_O,\n        output wire [MUX_WIDTH - 1:0] downstream_sda_T,\n        input  wire [MUX_WIDTH - 1:0] downstream_sda_I,\n        output wire [MUX_WIDTH - 1:0] downstream_sda_O\n    );\n    \n    assign upstream_scl_O = &downstream_scl_I;\n    assign upstream_sda_O = &downstream_sda_I;\n    genvar k;\n    generate\n        for (k = 0; k <= MUX_WIDTH - 1; k = k + 1) begin: GEN\n            assign downstream_scl_O[k] = upstream_scl_I;\n            assign downstream_sda_O[k] = upstream_sda_I;\n            assign downstream_scl_T[k] = upstream_scl_T;\n            assign downstream_sda_T[k] = upstream_sda_T;        \n        end\n    endgenerate\n        \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "motor_control_block_90d51896", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule motor_control_block (\n  input pwm_in, \n  input hbridge_ctrl, \n  input stepper_ctrl,\n  input clk, \n  output pwm_out, \n  output hbridge_out, \n  output stepper_out\n);\n\nparameter pwm_freq = 100; // PWM frequency in Hz\nparameter step_delay = 10; // Stepper motor step delay in clock cycles\n\nreg [7:0] pwm_counter;\nreg pwm_out_reg;\n\nassign pwm_out = pwm_out_reg;\nassign hbridge_out = hbridge_ctrl;\nassign stepper_out = stepper_ctrl;\n\nalways @(posedge clk) begin\n  // Implementation of PWM Controller\n  if (pwm_counter == 0) begin\n    pwm_out_reg <= 1;\n  end else if (pwm_counter == pwm_freq/2) begin\n    pwm_out_reg <= 0;\n  end\n  \n  pwm_counter <= pwm_counter + 1;\n  \n  // Implementation of Stepper Motor Controller\n  // ...\nend\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Bit_Counter_89fea09e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Bit_Counter(\n    input clk,\n    input reset,\n    input bit_clk_rising_edge,\n    input bit_clk_falling_edge,\n    input left_right_clk_rising_edge,\n    input left_right_clk_falling_edge,\n    output reg counting\n);\n\nparameter BIT_COUNTER_INIT = 5'd31;\n\nreg [4:0] bit_counter;\nwire reset_bit_counter;\n\nalways @(posedge clk) begin\n    if (reset == 1'b1) begin\n        bit_counter <= 5'h00;\n    end else if (reset_bit_counter == 1'b1) begin\n        bit_counter <= BIT_COUNTER_INIT;\n    end else if ((bit_clk_falling_edge == 1'b1) && (bit_counter != 5'h00)) begin\n        bit_counter <= bit_counter - 5'h01;\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset == 1'b1) begin\n        counting <= 1'b0;\n    end else if (reset_bit_counter == 1'b1) begin\n        counting <= 1'b1;\n    end else if ((bit_clk_falling_edge == 1'b1) && (bit_counter == 5'h00)) begin\n        counting <= 1'b0;\n    end\nend\n\nassign reset_bit_counter = left_right_clk_rising_edge | \n                            left_right_clk_falling_edge;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "blk_mem_gen_0blk_mem_gen_top_1f5fffb3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule blk_mem_gen_0blk_mem_gen_top\n   (doutb,\n    enb,\n    clkb,\n    wea,\n    clka,\n    addrb,\n    addra,\n    dina);\n  output [63:0]doutb;\n  input enb;\n  input clkb;\n  input [0:0]wea;\n  input clka;\n  input [8:0]addrb;\n  input [8:0]addra;\n  input [63:0]dina;\n\n  reg [63:0] memory [0:511];  // 512 locations, 64 bits each\n  wire [63:0]doutb;\n  wire [8:0]addra;\n  wire [8:0]addrb;\n  wire clka;\n  wire clkb;\n  wire enb;\n  wire [0:0]wea;\n\n  assign addra = addra[8:0];  // truncate to 9 bits\n  assign addrb = addrb[8:0];  // truncate to 9 bits\n\n  always @ (posedge clka) begin\n    if (enb && wea == 1'b1) begin\n      memory[addra] <= dina;\n    end\n  end\n\n  assign doutb = memory[addrb];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__fahcin_c55d9b3f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__fahcin (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CIN\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CIN ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire ci          ;\n    wire xor0_out_SUM;\n    wire a_b         ;\n    wire a_ci        ;\n    wire b_ci        ;\n    wire or0_out_COUT;\n\n    not not0 (ci          , CIN            );\n    xor xor0 (xor0_out_SUM, A, B, ci       );\n    buf buf0 (SUM         , xor0_out_SUM   );\n    and and0 (a_b         , A, B           );\n    and and1 (a_ci        , A, ci          );\n    and and2 (b_ci        , B, ci          );\n    or  or0  (or0_out_COUT, a_b, a_ci, b_ci);\n    buf buf1 (COUT        , or0_out_COUT   );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__30acf77a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,\n    input select,\n    input [15:0] in_A, \n    input [15:0] in_B,\n    output reg [7:0] out\n);\n\nreg [15:0] reg_in;\nwire [15:0] shift_out;\nwire [15:0] mux_out;\nwire [15:0] and_out;\n\n// Register module\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        reg_in <= 16'b0;\n    end else begin\n        reg_in <= in_A;\n    end\nend\n\n// Barrel shifter module\nassign shift_out = reg_in << select;\n\n// 2-to-1 multiplexer module\nreg temp_mux_out; // Use reg instead of wire\nalways @(select, in_A, in_B) begin\n    case (select)\n        1'b0: temp_mux_out <= in_A;\n        1'b1: temp_mux_out <= in_B;\n    endcase\nend\n\nassign mux_out = temp_mux_out; // Assign reg to wire\n\n// Functional module\nassign and_out = mux_out & shift_out;\n\n// Output register\nalways @(posedge clk) begin\n    out <= and_out[7:0];\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_edge_aaa1370c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule add_sub_edge (\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    input [7:0] in,\n    output [31:0] sum,\n    output [7:0] anyedge_result\n);\n\n    // Adder-Subtractor Module\n    wire [31:0] adder_out;\n    wire [31:0] inverted_b = sub ? ~b + 1 : b;\n    carry_lookahead_adder adder_inst (\n        .a(a),\n        .b(inverted_b),\n        .cin(sub),\n        .sum(adder_out)\n    );\n\n    // Edge Detection Module\n    reg [7:0] prev_in;\n    always @(posedge clk) begin\n        prev_in <= in;\n    end\n    wire [7:0] anyedge_out = (in ^ prev_in);\n\n    // Output Mux\n    assign sum = adder_out;\n    assign anyedge_result = anyedge_out ? adder_out[7:0] : 8'b0;\n\nendmodule\nmodule carry_lookahead_adder (\n    input [31:0] a,\n    input [31:0] b,\n    input cin,\n    output [31:0] sum\n);\n\n    wire [31:0] p = a + b;\n    wire [31:0] g = a & b;\n    wire [31:0] c = {cin, g[30:0]} + {g[31], p[30:0]};\n    assign sum = {c[30], p[29:0]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "complexMultiply_cda9feb6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule complexMultiply (\n    input signed [17:0] in1_re, // sfix18_En16\n    input signed [17:0] in1_im, // sfix18_En16\n    input signed [17:0] in2_re, // sfix18_En16\n    input signed [17:0] in2_im, // sfix18_En16\n    output signed [35:0] re,    // sfix36_En32\n    output signed [35:0] im     // sfix36_En32\n);\n\n    wire signed [35:0] product1; // sfix36_En32\n    wire signed [35:0] product2; // sfix36_En32\n    wire signed [35:0] add1;     // sfix36_En32\n    wire signed [35:0] product3; // sfix36_En32\n    wire signed [35:0] product4; // sfix36_En32\n    wire signed [35:0] add2;     // sfix36_En32\n\n    // Multiply the first input's real part with the second input's real part.\n    assign product1 = in1_re * in2_re;\n\n    // Multiply the first input's imaginary part with the second input's imaginary part.\n    assign product2 = in1_im * in2_im;\n\n    // Subtract the product from step 2 from the product from step 1. This is the real part of the result.\n    assign add1 = product1 - product2;\n\n    // Multiply the first input's real part with the second input's imaginary part.\n    assign product3 = in1_re * in2_im;\n\n    // Multiply the first input's imaginary part with the second input's real part.\n    assign product4 = in1_im * in2_re;\n\n    // Add the products from steps 4 and 5. This is the imaginary part of the result.\n    assign add2 = product3 + product4;\n\n    // Output the real and imaginary parts of the result.\n    assign re = add1;\n    assign im = add2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fixed_point_arithmetic #_5993aade", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fixed_point_arithmetic #(\n  parameter n = 16 // number of bits for fixed point representation\n) (\n  input [n-1:0] a,\n  input [n-1:0] b,\n  input [1:0] op,\n  output reg [n-1:0] c\n);\n\n\n// define the integer and fractional bits\nparameter int_bits = 8;\nparameter frac_bits = n - int_bits;\n\n// define scaling factor for fixed-point representation\nparameter scaling_factor = 2 ** frac_bits;\n\n// define maximum and minimum values for fixed-point representation\nparameter max_value = (2 ** (n - 1)) - 1;\nparameter min_value = -max_value;\n\n// define two's complement representation for negative numbers\nfunction [n-1:0] twos_complement;\n  input [n-1:0] num;\n  begin\n    if (num < 0) begin\n      twos_complement = ~(-num) + 1;\n    end\n    else begin\n      twos_complement = num;\n    end\n  end\nendfunction\n\n// perform fixed-point arithmetic operations based on control signal (op)\nalways @(*) begin\n  case (op)\n    2'b00: c = twos_complement(a) + twos_complement(b);\n    2'b01: c = twos_complement(a) - twos_complement(b);\n    2'b10: c = twos_complement(a) * twos_complement(b) / scaling_factor;\n    2'b11: begin\n      if (b == 0) begin\n        c = max_value;\n      end\n      else begin\n        c = (twos_complement(a) * scaling_factor) / twos_complement(b);\n      end\n    end\n  endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt51_lfo_lfsr #_838b6ae0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule jt51_lfo_lfsr #(parameter init=220 )(\n\tinput\trst,\n\tinput\tclk,\n\tinput\tbase,\n\toutput\tout\n);\n\nreg [18:0] bb;\nassign out = bb[18];\n\nreg last_base;\n\nalways @(posedge clk) begin : base_counter\n\tif( rst ) begin\n\t\tbb\t\t\t<= init[18:0];\n\t\tlast_base \t<= 1'b0;\n\tend\n\telse begin\n\t\tlast_base <= base;\n\t\tif( last_base != base ) begin\t\n\t\t\tbb[18:1] \t<= bb[17:0];\n\t\t\tbb[0]\t\t<= ^{bb[0],bb[1],bb[14],bb[15],bb[17],bb[18]};\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ones_counter_7fd958c2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ones_counter (\n    input clk,\n    input [7:0] in,\n    output reg [3:0] count\n);\n\n    reg [3:0] temp_count;\n    reg [7:0] shift_reg;\n    \n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[6:0], in};\n        temp_count <= (shift_reg[7:5] == 3'b111) ? temp_count + 1 : 0;\n        count <= temp_count;\n    end\n\nendmodule\n\nmodule triple_counter (\n    input clk,\n    input [7:0] in,\n    input [3:0] ones_count,\n    output reg [2:0] triple_count\n);\n\n    reg [2:0] temp_count;\n    reg [7:0] shift_reg;\n    \n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[6:0], in};\n        temp_count <= (shift_reg[7:5] == 3'b111 && ones_count >= 3) ? temp_count + 1 : 0;\n        triple_count <= temp_count;\n    end\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [3:0] ones_count,\n    output [2:0] triple_count\n);\n\n    ones_counter ones_count_inst (\n        .clk(clk),\n        .in(in),\n        .count(ones_count)\n    );\n    \n    triple_counter triple_count_inst (\n        .clk(clk),\n        .in(in),\n        .ones_count(ones_count),\n        .triple_count(triple_count)\n    );\n\nendmodule\n\nmodule DFF (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_f155923d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate(input a, b, c, output out);\n  wire and_output;\n  \n  and3_gate and3_inst(.a(a), .b(b), .c(c), .out(and_output));\n  or2_gate or2_inst(.a(and_output), .b(c), .out(out));\n  \nendmodule\n\nmodule and3_gate(input a, b, c, output out);\n  assign out = a & b & c;\nendmodule\n\nmodule or2_gate(input a, b, output out);\n  assign out = a | b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "busctrl_6c649899", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule busctrl(cpu_en, cpu_wr, cpu_size, cpu_addr,\n               cpu_data_out, cpu_data_in, cpu_wt,\n               ram_en, ram_wr, ram_size, ram_addr,\n               ram_data_in, ram_data_out, ram_wt,\n               rom_en, rom_wr, rom_size, rom_addr,\n               rom_data_out, rom_wt,\n               tmr0_en, tmr0_wr, tmr0_addr,\n               tmr0_data_in, tmr0_data_out, tmr0_wt,\n               tmr1_en, tmr1_wr, tmr1_addr,\n               tmr1_data_in, tmr1_data_out, tmr1_wt,\n               dsp_en, dsp_wr, dsp_addr,\n               dsp_data_in, dsp_data_out, dsp_wt,\n               kbd_en, kbd_wr, kbd_addr,\n               kbd_data_in, kbd_data_out, kbd_wt,\n               ser0_en, ser0_wr, ser0_addr,\n               ser0_data_in, ser0_data_out, ser0_wt,\n               ser1_en, ser1_wr, ser1_addr,\n               ser1_data_in, ser1_data_out, ser1_wt,\n               dsk_en, dsk_wr, dsk_addr,\n               dsk_data_in, dsk_data_out, dsk_wt);\n    input cpu_en;\n    input cpu_wr;\n    input [1:0] cpu_size;\n    input [31:0] cpu_addr;\n    input [31:0] cpu_data_out;\n    output [31:0] cpu_data_in;\n    output cpu_wt;\n    output ram_en;\n    output ram_wr;\n    output [1:0] ram_size;\n    output [24:0] ram_addr;\n    output [31:0] ram_data_in;\n    input [31:0] ram_data_out;\n    input ram_wt;\n    output rom_en;\n    output rom_wr;\n    output [1:0] rom_size;\n    output [20:0] rom_addr;\n    input [31:0] rom_data_out;\n    input rom_wt;\n    output tmr0_en;\n    output tmr0_wr;\n    output [3:2] tmr0_addr;\n    output [31:0] tmr0_data_in;\n    input [31:0] tmr0_data_out;\n    input tmr0_wt;\n    output tmr1_en;\n    output tmr1_wr;\n    output [3:2] tmr1_addr;\n    output [31:0] tmr1_data_in;\n    input [31:0] tmr1_data_out;\n    input tmr1_wt;\n    output dsp_en;\n    output dsp_wr;\n    output [13:2] dsp_addr;\n    output [15:0] dsp_data_in;\n    input [15:0] dsp_data_out;\n    input dsp_wt;\n    output kbd_en;\n    output kbd_wr;\n    output kbd_addr;\n    output [7:0] kbd_data_in;\n    input [7:0] kbd_data_out;\n    input kbd_wt;\n    output ser0_en;\n    output ser0_wr;\n    output [3:2] ser0_addr;\n    output [7:0] ser0_data_in;\n    input [7:0] ser0_data_out;\n    input ser0_wt;\n    output ser1_en;\n    output ser1_wr;\n    output [3:2] ser1_addr;\n    output [7:0] ser1_data_in;\n    input [7:0] ser1_data_out;\n    input ser1_wt;\n    output dsk_en;\n    output dsk_wr;\n    output [19:2] dsk_addr;\n    output [31:0] dsk_data_in;\n    input [31:0] dsk_data_out;\n    input dsk_wt;\n\n  wire i_o_en;\n\n  assign ram_en =\n    (cpu_en == 1 && cpu_addr[31:29] == 3'b000\n                 && cpu_addr[28:25] == 4'b0000) ? 1 : 0;\n  assign rom_en =\n    (cpu_en == 1 && cpu_addr[31:28] == 4'b0010\n                 && cpu_addr[27:21] == 7'b0000000) ? 1 : 0;\n  assign i_o_en =\n    (cpu_en == 1 && cpu_addr[31:28] == 4'b0011) ? 1 : 0;\n  assign tmr0_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h00\n                 && cpu_addr[19:12] == 8'h00) ? 1 : 0;\n  assign tmr1_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h00\n                 && cpu_addr[19:12] == 8'h01) ? 1 : 0;\n  assign dsp_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h01) ? 1 : 0;\n  assign kbd_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h02) ? 1 : 0;\n  assign ser0_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h03\n                 && cpu_addr[19:12] == 8'h00) ? 1 : 0;\n  assign ser1_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h03\n                 && cpu_addr[19:12] == 8'h01) ? 1 : 0;\n  assign dsk_en =\n    (i_o_en == 1 && cpu_addr[27:20] == 8'h04) ? 1 : 0;\n\n  assign cpu_wt =\n    (ram_en == 1) ? ram_wt :\n    (rom_en == 1) ? rom_wt :\n    (tmr0_en == 1) ? tmr0_wt :\n    (tmr1_en == 1) ? tmr1_wt :\n    (dsp_en == 1) ? dsp_wt :\n    (kbd_en == 1) ? kbd_wt :\n    (ser0_en == 1) ? ser0_wt :\n    (ser1_en == 1) ? ser1_wt :\n    (dsk_en == 1) ? dsk_wt :\n    1;\n  assign cpu_data_in[31:0] =\n    (ram_en == 1) ? ram_data_out[31:0] :\n    (rom_en == 1) ? rom_data_out[31:0] :\n    (tmr0_en == 1) ? tmr0_data_out[31:0] :\n    (tmr1_en == 1) ? tmr1_data_out[31:0] :\n    (dsp_en == 1) ? { 16'h0000, dsp_data_out[15:0] } :\n    (kbd_en == 1) ? { 24'h000000, kbd_data_out[7:0] } :\n    (ser0_en == 1) ? { 24'h000000, ser0_data_out[7:0] } :\n    (ser1_en == 1) ? { 24'h000000, ser1_data_out[7:0] } :\n    (dsk_en == 1) ? dsk_data_out[31:0] :\n    32'h00000000;\n\n  assign ram_wr = cpu_wr;\n  assign ram_size[1:0] = cpu_size[1:0];\n  assign ram_addr[24:0] = cpu_addr[24:0];\n  assign ram_data_in[31:0] = cpu_data_out[31:0];\n\n  assign rom_wr = cpu_wr;\n  assign rom_size[1:0] = cpu_size[1:0];\n  assign rom_addr[20:0] = cpu_addr[20:0];\n\n  assign tmr0_wr = cpu_wr;\n  assign tmr0_addr[3:2] = cpu_addr[3:2];\n  assign tmr0_data_in[31:0] = cpu_data_out[31:0];\n\n  assign tmr1_wr = cpu_wr;\n  assign tmr1_addr[3:2] = cpu_addr[3:2];\n  assign tmr1_data_in[31:0] = cpu_data_out[31:0];\n\n  assign dsp_wr = cpu_wr;\n  assign dsp_addr[13:2] = cpu_addr[13:2];\n  assign dsp_data_in[15:0] = cpu_data_out[15:0];\n\n  assign kbd_wr = cpu_wr;\n  assign kbd_addr = cpu_addr[2];\n  assign kbd_data_in[7:0] = cpu_data_out[7:0];\n\n  assign ser0_wr = cpu_wr;\n  assign ser0_addr[3:2] = cpu_addr[3:2];\n  assign ser0_data_in[7:0] = cpu_data_out[7:0];\n\n  assign ser1_wr = cpu_wr;\n  assign ser1_addr[3:2] = cpu_addr[3:2];\n  assign ser1_data_in[7:0] = cpu_data_out[7:0];\n\n  assign dsk_wr = cpu_wr;\n  assign dsk_addr[19:2] = cpu_addr[19:2];\n  assign dsk_data_in[31:0] = cpu_data_out[31:0];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_w2r_e4642a4f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sync_w2r \n    \n    #(\n    parameter ASIZE = 4\n    )(\n    input  wire              rclk,\n    input  wire              rrst_n,\n    output reg  [ASIZE:0] rq2_wptr,\n    input  wire [ASIZE:0] wptr\n    );\n    \n    reg [ASIZE:0] rq1_wptr;\n    \n    always @(posedge rclk or negedge rrst_n) begin\n        \n        if (!rrst_n) \n            {rq2_wptr,rq1_wptr} <= 0;\n        else\n            {rq2_wptr,rq1_wptr} <= {rq1_wptr,wptr};\n\n    end\n\nendmodule\n\n`resetall\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tmu2_burst #_7bd70675", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule tmu2_burst #(\n\tparameter fml_depth = 26\n) (\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\tinput flush,\n\toutput reg busy,\n\t\n\tinput pipe_stb_i,\n\toutput pipe_ack_o,\n\tinput [15:0] color,\n\tinput [fml_depth-1-1:0] dadr, \n\t\n\toutput reg pipe_stb_o,\n\tinput pipe_ack_i,\n\toutput reg [fml_depth-5-1:0] burst_addr, \n\t\n\toutput reg [15:0] burst_sel,\n\toutput reg [255:0] burst_do\n);\n\nwire burst_hit = dadr[fml_depth-1-1:4] == burst_addr;\n\n\nreg [15:0] color_r;\nreg [fml_depth-1-1:0] dadr_r;\nalways @(posedge sys_clk) begin\n\tif(pipe_stb_i & pipe_ack_o) begin\n\t\tcolor_r <= color;\n\t\tdadr_r <= dadr;\n\tend\nend\n\n\nreg clear_en;\nreg write_en;\nreg use_memorized;\nwire [15:0] color_mux = use_memorized ? color_r : color;\nwire [fml_depth-1-1:0] dadr_mux = use_memorized ? dadr_r : dadr;\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tburst_sel = 16'd0;\n\telse begin\n\t\tif(clear_en)\n\t\t\tburst_sel = 16'd0;\n\t\tif(write_en) begin\n\t\t\tburst_addr = dadr_mux[fml_depth-1-1:4]; \n\t\t\tcase(dadr_mux[3:0]) \n\t\t\t\t4'd00: burst_sel = burst_sel | 16'h8000;\n\t\t\t\t4'd01: burst_sel = burst_sel | 16'h4000;\n\t\t\t\t4'd02: burst_sel = burst_sel | 16'h2000;\n\t\t\t\t4'd03: burst_sel = burst_sel | 16'h1000;\n\t\t\t\t4'd04: burst_sel = burst_sel | 16'h0800;\n\t\t\t\t4'd05: burst_sel = burst_sel | 16'h0400;\n\t\t\t\t4'd06: burst_sel = burst_sel | 16'h0200;\n\t\t\t\t4'd07: burst_sel = burst_sel | 16'h0100;\n\t\t\t\t4'd08: burst_sel = burst_sel | 16'h0080;\n\t\t\t\t4'd09: burst_sel = burst_sel | 16'h0040;\n\t\t\t\t4'd10: burst_sel = burst_sel | 16'h0020;\n\t\t\t\t4'd11: burst_sel = burst_sel | 16'h0010;\n\t\t\t\t4'd12: burst_sel = burst_sel | 16'h0008;\n\t\t\t\t4'd13: burst_sel = burst_sel | 16'h0004;\n\t\t\t\t4'd14: burst_sel = burst_sel | 16'h0002;\n\t\t\t\t4'd15: burst_sel = burst_sel | 16'h0001;\n\t\t\tendcase\n\t\t\tcase(dadr_mux[3:0]) \n\t\t\t\t4'd00: burst_do[255:240] = color_mux;\n\t\t\t\t4'd01: burst_do[239:224] = color_mux;\n\t\t\t\t4'd02: burst_do[223:208] = color_mux;\n\t\t\t\t4'd03: burst_do[207:192] = color_mux;\n\t\t\t\t4'd04: burst_do[191:176] = color_mux;\n\t\t\t\t4'd05: burst_do[175:160] = color_mux;\n\t\t\t\t4'd06: burst_do[159:144] = color_mux;\n\t\t\t\t4'd07: burst_do[143:128] = color_mux;\n\t\t\t\t4'd08: burst_do[127:112] = color_mux;\n\t\t\t\t4'd09: burst_do[111: 96] = color_mux;\n\t\t\t\t4'd10: burst_do[ 95: 80] = color_mux;\n\t\t\t\t4'd11: burst_do[ 79: 64] = color_mux;\n\t\t\t\t4'd12: burst_do[ 63: 48] = color_mux;\n\t\t\t\t4'd13: burst_do[ 47: 32] = color_mux;\n\t\t\t\t4'd14: burst_do[ 31: 16] = color_mux;\n\t\t\t\t4'd15: burst_do[ 15:  0] = color_mux;\n\t\t\tendcase\n\t\tend\n\tend\nend\n\nwire empty = (burst_sel == 16'd0);\n\nreg state;\nreg next_state;\n\nparameter RUNNING\t= 1'b0;\nparameter DOWNSTREAM\t= 1'b1;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tstate <= RUNNING;\n\telse\n\t\tstate <= next_state;\nend\n\n\n\nassign pipe_ack_o = (state == RUNNING) & (~flush | empty);\n\nalways @(*) begin\n\tnext_state = state;\n\tbusy = 1'b1;\n\tpipe_stb_o = 1'b0;\n\twrite_en = 1'b0;\n\tclear_en = 1'b0;\n\tuse_memorized = 1'b0;\n\t\n\tcase(state)\n\t\tRUNNING: begin\n\t\t\tbusy = 1'b0;\n\t\t\tif(flush & ~empty)\n\t\t\t\tnext_state = DOWNSTREAM;\n\t\t\telse begin\n\t\t\t\tif(pipe_stb_i) begin\n\t\t\t\t\tif(burst_hit | empty)\n\t\t\t\t\t\twrite_en = 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tnext_state = DOWNSTREAM;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tDOWNSTREAM: begin\n\t\t\tpipe_stb_o = 1'b1;\n\t\t\tuse_memorized = 1'b1;\n\t\t\tif(pipe_ack_i) begin\n\t\t\t\tclear_en = 1'b1;\n\t\t\t\twrite_en = 1'b1;\n\t\t\t\tnext_state = RUNNING;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_shift_registers_fixed_6e398d3c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule xor_shift_registers_fixed (\n  input clk,\n  input reset,\n  input d,\n  output q\n);\n\n  reg [3:0] sr1;\n  reg [1:0] sr2;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      sr1 <= 4'b0000;\n      sr2 <= 2'b00;\n    end else begin\n      sr1 <= {sr1[2:0], sr1[3]};\n      sr2 <= {sr2[0], d};\n    end\n  end\n\n  assign q = sr1[0] ^ sr2[1];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "timer #_759244ff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule timer #\n(\n    parameter WIDTH = 64,\n    parameter USE_2XCLK = 0,\n    parameter S_WIDTH_A = 2\n)\n(\n    input clk,\n    input clk2x,\n    input resetn,\n\n    // Slave port\n    input [S_WIDTH_A-1:0] slave_address,  // Word address\n    input [WIDTH-1:0] slave_writedata,\n    input slave_read,\n    input slave_write,\n    input [WIDTH/8-1:0] slave_byteenable,\n    output slave_waitrequest,\n    output [WIDTH-1:0] slave_readdata,\n    output slave_readdatavalid\n);\n\nreg [WIDTH-1:0] counter;\nreg [WIDTH-1:0] counter2x;\n\nreg clock_sel;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    clock_sel <= 1'b0;\n  else if (slave_write)\n    if (|slave_writedata)\n      clock_sel <= 1'b1;\n    else\n      clock_sel <= 1'b0;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    counter <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter <= {WIDTH{1'b0}};\n  else\n    counter <= counter + 2'b01;\n\nalways@(posedge clk2x or negedge resetn)\n  if (!resetn)\n    counter2x <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter2x <= {WIDTH{1'b0}};\n  else\n    counter2x <= counter2x + 2'b01;\n\nassign slave_waitrequest = 1'b0;\nassign slave_readdata = (USE_2XCLK && clock_sel) ? counter2x : counter;\nassign slave_readdatavalid = slave_read;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_flip_flop_reset_set_81ec2d0d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule d_flip_flop_reset_set (\n    input CLK,\n    input D,\n    input RESET_B,\n    input SET_B,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK) begin\n        if (!RESET_B) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (!SET_B) begin\n            Q <= 1;\n            Q_N <= 0;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_incrementer_xor_1de258c0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register_incrementer_xor (\n    input clk,\n    input reset,     // Synchronous active-high reset\n    input [7:0] d,   // 8-bit input for the shift register\n    input select,    // Select input for shifting left or right\n    output [7:0] q,  // 8-bit output from the shift register\n    output reg [3:0] ena,// Incrementer enable signal for each digit\n    output reg [3:0] c,  // Incrementer output for each digit\n    output [7:0] f    // Output from the functional module\n);\n\nreg [7:0] shift_reg;\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 8'b0;\n        counter <= 4'b0;\n    end else begin\n        if (select) begin\n            shift_reg <= {shift_reg[6:0], d};\n        end else begin\n            shift_reg <= {d, shift_reg[7:1]};\n        end\n        \n        ena <= 4'b1111;\n        c <= counter;\n        counter <= counter + 1;\n        if (counter == 4'b1111) begin\n            counter <= 4'b0;\n        end\n    end\nend\n\nassign q = shift_reg;\nassign f = shift_reg ^ {counter, counter, counter, counter};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bin_to_gray_converter_b1957ba3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bin_to_gray_converter (\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[0] = binary[0];\n  assign gray[1] = binary[0] ^ binary[1];\n  assign gray[2] = binary[1] ^ binary[2];\n  assign gray[3] = binary[2] ^ binary[3];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "combinational_circuit_4a776bc2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule combinational_circuit(\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nwire [1:0] mux_out_and;\nwire [1:0] mux_out_or;\nwire [1:0] mux_out_xor;\n\nassign mux_out_and[0] = in[0] & in[1];\nassign mux_out_and[1] = in[2] & in[3];\n\nassign mux_out_or[0] = in[0] | in[1];\nassign mux_out_or[1] = in[2] | in[3];\n\nassign mux_out_xor[0] = in[0] ^ in[1];\nassign mux_out_xor[1] = in[2] ^ in[3];\n\nassign out_and = mux_out_and[0] & mux_out_and[1];\nassign out_or = mux_out_or[0] | mux_out_or[1];\nassign out_xor = mux_out_xor[0] ^ mux_out_xor[1];\n\nendmodule\n\nmodule top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\ncombinational_circuit cc(\n    .in(in),\n    .out_and(out_and),\n    .out_or(out_or),\n    .out_xor(out_xor)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MEM_3402c592", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MEM(\n\tinput clk,\n\tinput [5:0] Op,\n\tinput [2:0] Condition,\n\tinput Branch,\n\tinput MemWrite,\n\tinput RegWrite,\n\tinput [31:0] MemData,\n\tinput Less,Zero,Overflow,\n\tinput [31:0] WBData,\n\toutput [31:0] MemData_Mem,\n\toutput [3:0] Rd_write_byte_en,\n\toutput RegWriteValid,\n\toutput BranchValid,\n\toutput [3:0]Mem_write_byte_en\n);\nwire [31:0] Mem_data_in;\nwire [31:0] Mem_data_out;\nConditionCheck ConditionCheck(Condition,Branch,RegWrite,Less,Zero,Overflow,BranchValid,RegWriteValid);\nreg_shifter reg_shifter(MemData,WBData[1:0],MemWrite,Op,Mem_data_in,Mem_write_byte_en);\nMem Mem(Mem_write_byte_en,clk,Mem_data_in,WBData,Mem_data_out);\nmem_shifter mem_shifter(Mem_data_out,WBData[1:0],Op,MemData_Mem,Rd_write_byte_en);\nendmodule\n\nmodule ConditionCheck(\n\tinput [2:0] Condition,\n\tinput Branch,\n\tinput RegWrite,\n\tinput Less,Zero,Overflow,\n\toutput reg BranchValid,RegWriteValid\n);\n\nalways @(*)\nbegin\nif(Branch==0)\nBranchValid=0;\nelse\nbegin\ncase(Condition)\n3'b000:\nBranchValid=0;\n3'b001:\nBranchValid=Zero;\n3'b010:\nBranchValid=~Zero;\n3'b011:\nBranchValid=Less|Zero;3'b100:\nBranchValid=Less;3'b101:\nBranchValid=~Less;3'b110:\nBranchValid=~(Less|Zero);3'b111:\nBranchValid=0;\nendcase\nend\n\nif(RegWrite==0)\nRegWriteValid=0;\nelse if(Overflow==1)\nRegWriteValid=0;\nelse\nRegWriteValid=1;\nend\nendmodule\nmodule reg_shifter(\n\tinput [31:0] rt_out,\n\tinput\t[1:0] mem_addr_in,\n\tinput\tMemWrite,\n\tinput [5:0] IR_out,\n\toutput reg [31:0] rt_out_shift,\n\toutput reg [3:0] mem_byte_write_out\n);\nreg [3:0]mem_byte_write;\nalways @ (*)\nbegin\n\tif (IR_out == 6'b101011) begin rt_out_shift = rt_out;mem_byte_write=4'b1111;end\n\telse begin\n\t\tcase (mem_addr_in)\n\t\t\t2'b00: begin rt_out_shift = {rt_out[7:0],  24'b0};mem_byte_write=4'b1000;end\n\t\t\t2'b01: begin rt_out_shift = {rt_out[15:0], 16'b0};mem_byte_write=4'b1100;end\n\t\t\t2'b10: begin rt_out_shift = {rt_out[23:0], 8'b0};mem_byte_write=4'b1110;end\n\t\t\t2'b11: begin rt_out_shift = rt_out;mem_byte_write=4'b1111;end\n\t\tendcase\n\tend\n\tmem_byte_write_out = mem_byte_write & {4{MemWrite}};\nend\n\nendmodule\n\n\n\n\nmodule mem_shifter(\n\tinput [31:0] mem_data_out,\n\tinput\t[1:0] mem_addr_in,\n\tinput [5:0] IR_out,\n\toutput reg [31:0] mem_data_shift,\n\toutput reg [3:0] Rd_write_byte_en\n);\n\nalways @ (*)\nbegin\n\tif (IR_out == 6'b100011)begin\n\t\tmem_data_shift = mem_data_out;\n\t\tRd_write_byte_en=4'b1111;\n\tend\n\telse begin\n\t\tcase (mem_addr_in)\n\t\t\t2'b00: begin mem_data_shift = mem_data_out; Rd_write_byte_en=4'b1111;end\n\t\t\t2'b01: begin mem_data_shift = {mem_data_out[23:0], 8'b0};Rd_write_byte_en=4'b1110; end\n\t\t\t2'b10: begin mem_data_shift = {mem_data_out[15:0], 16'b0};Rd_write_byte_en=4'b1100; end\n\t\t\t2'b11: begin mem_data_shift = {mem_data_out[7:0],  24'b0};Rd_write_byte_en=4'b1000; end\n\t\tendcase\n\tend\nend\n\nendmodule\n\nmodule Mem(\n\tinput [3:0]Mem_byte_wr_in,\n\tinput clk,\n\tinput [31:0]Mem_data,\n\tinput [31:0]Mem_addr_in,\n\toutput reg [31:0]Mem_data_out\n);\nreg [31:0]addr;\ninteger i;\nreg [7:0] IR_reg [500:0];\ninitial\nbegin\nfor(i=0;i<=500;i=i+1) IR_reg[i]=8'b0;\nIR_reg[256] = 8'b10011000;\nIR_reg[257] = 8'b10010110;\nIR_reg[258] = 8'b10011100;\nIR_reg[259] = 8'b11001110;\nend\nalways@(posedge clk)\nbegin\naddr = {Mem_addr_in[31:2],2'b00};\nif(Mem_byte_wr_in[3])\n\tIR_reg[addr+3]<=Mem_data[31:24];\nif(Mem_byte_wr_in[2])\n\tIR_reg[addr+2]<=Mem_data[23:16];\nif(Mem_byte_wr_in[1])\n\tIR_reg[addr+1]<=Mem_data[15:8];\nif(Mem_byte_wr_in[0])\n\tIR_reg[addr]<=Mem_data[7:0];\nif(addr >= 496)\n\t\tMem_data_out <= 32'h00000000;\nelse begin\n\tMem_data_out[31:24]<=IR_reg[addr + 3];\n\tMem_data_out[23:16]<=IR_reg[addr+2];\n\tMem_data_out[15:8]<=IR_reg[addr+1];\n\tMem_data_out[7:0]<=IR_reg[addr];\nend\nend\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_64bit_f77a41e7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo_64bit\n(\n    input wire clk,\n    input wire rst,\n    input wire wr_en,\n    input wire rd_en,\n    input wire [8:0] din,\n    output wire [8:0] dout,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] mem [63:0];\n    reg [5:0] wr_ptr = 0;\n    reg [5:0] rd_ptr = 0;\n    reg [5:0] count = 0;\n    wire [5:0] next_wr_ptr;\n    wire [5:0] next_rd_ptr;\n    wire [5:0] next_count;\n\n    assign full = (count == 64);\n    assign empty = (count == 0);\n    assign dout = mem[rd_ptr];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            wr_ptr <= 0;\n            rd_ptr <= 0;\n            count <= 0;\n        end else begin\n            if (wr_en && !full) begin\n                mem[wr_ptr] <= din;\n                wr_ptr <= next_wr_ptr;\n                count <= next_count;\n            end\n\n            if (rd_en && !empty) begin\n                rd_ptr <= next_rd_ptr;\n                count <= next_count;\n            end\n        end\n    end\n\n    assign next_wr_ptr = (wr_ptr == 63) ? 0 : wr_ptr + 1;\n    assign next_rd_ptr = (rd_ptr == 63) ? 0 : rd_ptr + 1;\n    assign next_count = (wr_en && !full) ? count + 1 :\n                        (rd_en && !empty) ? count - 1 :\n                        count;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FFType_546_cdab09e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule FFType_546(\n  input         clock,\n  input         reset,\n  input  [39:0] io_in,\n  output [39:0] io_out,\n  input         io_enable\n);\n\n  // Register flip-flops\n  reg [39:0] ff_reg;\n\n  // Combinational logic\n  assign io_out = (io_enable) ? ff_reg : io_in;\n\n  // Sequential logic\n  always @(posedge clock) begin\n    if (reset) begin\n      ff_reg <= 0;\n    end else begin\n      if (io_enable) begin\n        ff_reg <= io_in;\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and4b_8fbae110", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and4b (\n    X,\n    A_N,\n    B,\n    C,\n    D\n);\n\n    // Module ports\n    output X;\n    input A_N;\n    input B;\n    input C;\n    input D;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire not0_out;\n    wire and0_out;\n    wire and1_out;\n\n    //  Name  Output      Other arguments\n    not not0 (not0_out, A_N);\n    and and0 (and0_out, B, C);\n    and and1 (and1_out, not0_out, D, and0_out);\n    buf buf0 (X, and1_out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_f545ac1b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder (\n    input [15:0] A,\n    input [15:0] B,\n    input CIN,\n    output [15:0] SUM,\n    output COUT\n);\n\n    assign {COUT, SUM} = A + B + CIN;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_counter_ef8d3f6b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo_counter (\n  input empty,\n  input free2,\n  input free3,\n  input [1:0] tm_count,\n  output reg [4:0] fifocount_inc\n);\n\n  always @(*) begin\n    if (empty) begin\n      fifocount_inc = tm_count[1:0];\n    end else if (free3 && (tm_count == 2'b11)) begin\n      fifocount_inc = 2;\n    end else if (free2 && (tm_count >= 2)) begin\n      fifocount_inc = 1;\n    end else if (tm_count >= 1) begin\n      fifocount_inc = 0;\n    end else begin\n      fifocount_inc = 5'b11111;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dual_port_ram_382c4cfe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dual_port_ram(\n    input clk,\n    input [15:0] data_in,\n    input [10:0] write_addr,\n    input write_en,\n    input [10:0] read_addr,\n    input read_en,\n    output reg [15:0] data_out\n);\n\n    // Instantiate a generic dual-port RAM model\n    reg [15:0] ram[0:2047];\n\n    always @(posedge clk) begin\n        if (write_en) begin\n            ram[write_addr] <= data_in;\n        end\n        if (read_en) begin\n            data_out <= ram[read_addr];\n        end\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "smart_unit_f7d9cfab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule smart_unit ( inst_out , addr_d1 , addr_d2 , addr_inst ,  \n                 W_d1 , W_d2 , Dout_d1 , Dout_d2 , apxy_CEN , inst_nxt , \n\t\t\t\t\t\t\t\t clk , rst_n , inst_in , ready_hy , hy_exe ,  \n\t\t\t\t\t\t\t\t Din_c1 , Din_c2 , Din_hy\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\nparameter inst_num = 31;\n\nparameter mov     = 5'h7;\nparameter set     = 5'h9;\nparameter jump    = 5'ha;\n\n\nparameter mode_i = 1'b0;\nparameter mode_q = 1'b1;\noutput [inst_num-1:0] inst_out ;\noutput [  4:0] addr_d1 , addr_d2;\nreg    [  4:0] addr_d1 , addr_d2;\noutput [ 15:0] addr_inst;\nreg    [ 15:0] addr_inst;\noutput [255:0] Dout_d1 , Dout_d2;\nreg    [255:0] Dout_d1 , Dout_d2;\noutput W_d1 , W_d2;\nreg    W_d1 , W_d2;\noutput apxy_CEN;\noutput [inst_num-1:0] inst_nxt;\n\ninput  clk , rst_n , ready_hy , hy_exe; \ninput  [inst_num-1:0] inst_in;\ninput  [255:0] Din_c1 , Din_c2 , Din_hy;\nreg [inst_num-1:0] inst_out_next;\nreg [inst_num-1:0] inst_1 , inst_2 , inst_1_next , inst_2_next;\nreg [15:0] addr_inst_next;\nreg [ 4:0] counter , counter_next;\nreg [ 6:0] counter_jump , counter_jump_next;\n\nwire hy_WB = inst_out[6];\nwire hy_W_bank = inst_out[5];\nwire [4:0] comp_type_1  = inst_1[30:26];\nwire [6:0] j_counter_1  = inst_1[25:19]; \nwire [4:0] hy_addr_A  = inst_out[23:19];\nwire [4:0] hy_addr_X  = inst_out[14:10];\nwire [4:0] hy_addr_WB = inst_out[4 : 0];\n\n\nwire [4:0] addr_A_in = inst_in[23:19];\nwire [4:0] addr_X_in = inst_in[14:10];\nwire [4:0] comp_type_i = inst_in[30:26];\nwire [6:0] j_counter_i = inst_in[25:19];\n\n\nwire [4:0] addr_A_1 = inst_1[23:19];\nwire [4:0] addr_X_1 = inst_1[14:10];\n\nwire [4:0] addr_A_cur = inst_2[23:19];\nwire [4:0] addr_X_cur = inst_2[14:10];\n\nwire [4:0] mov_addr_A = inst_1[24:20];\nwire [4:0] mov_addr_X = inst_1[24:20];\nwire [4:0] mov_addr_WB = inst_1[18:14];\n\nassign inst_out = inst_2;\nassign apxy_CEN = (addr_inst>5'd2 && hy_exe==1'b1 ) ? 1'b1 : 1'b0;\nassign inst_nxt = inst_1;\n\nalways @ ( posedge clk or negedge rst_n ) begin\n\tif ( rst_n==1'b0 ) begin\n\t\tinst_1   <= 31'd0;\n\t\tinst_2   <= 31'd0;\n\t\tcounter  <= 5'd0;\n\t\tcounter_jump <= 7'd0;\n\tend\n\telse begin\n\t\tinst_1   <= inst_1_next;inst_2   <= inst_2_next;counter  <= counter_next;\n\t\tcounter_jump <= counter_jump_next;\n\tend\nend\nalways @ ( negedge clk or negedge rst_n ) begin\n\tif ( rst_n==1'b0 ) begin\n\t\taddr_inst<= 16'd0;\n\tend\n\telse begin\n\t\taddr_inst<= addr_inst_next;\n\tend\nend\n\nalways @ (*) begin\n\tif (hy_exe==1'b0)\n\t\taddr_inst_next = addr_inst;\n\telse if ( comp_type_i==jump ) if (counter_jump==7'd0)\n\t\t\taddr_inst_next = addr_inst + 5'd1;\n\t\telse\n\t\t\taddr_inst_next = addr_inst - j_counter_i ;\n\telse if (ready_hy==1'b1 || addr_inst<5'd3 || comp_type_1==set)\n\t\taddr_inst_next = addr_inst + 5'd1 ;\n\telse if (comp_type_1==mov)\n\t\taddr_inst_next = (counter==5'd1) ? addr_inst+5'd1 : addr_inst;\n\telse\n\t\taddr_inst_next = addr_inst;\nend\n\nalways @ (*) begin\n\tinst_1_next = ( (ready_hy==1'b1 || addr_inst<5'd3) && hy_exe==1'b1 ) ? inst_in : inst_1;\n\tinst_2_next = ( (ready_hy==1'b1 || addr_inst<5'd3) && hy_exe==1'b1 ) ? inst_1 : inst_2;\n\tcase (comp_type_1)\n\t\tmov : begin\n\t\t\tif ( hy_WB==1'b1 && ready_hy==1'b1 ) begin\n\t\t\t\tcounter_next = counter;\n\t\t\t\tif (hy_W_bank==1'b1) begin\n\t\t\t\t\tW_d1 = 1'b1;\n\t\t\t\t\tW_d2 = 1'b0;\n\t\t\t\t\taddr_d1 = addr_A_in;\n\t\t\t\t\taddr_d2 = hy_addr_WB;\n\t\t\t\t\tDout_d1 = Din_hy;\n\t\t\t\t\tDout_d2 = Din_hy;\n\t\t\t\tend\n\t\t\t\telse begin \n\t\t\t\t\tW_d1 = 1'b0;\n\t\t\t\t\tW_d2 = 1'b1;\n\t\t\t\t\taddr_d1 = hy_addr_WB;\n\t\t\t\t\taddr_d2 = addr_X_in;\n\t\t\t\t\tDout_d1 = Din_hy;\n\t\t\t\t\tDout_d2 = Din_hy;\t\n\t\t\t\tend\t\n\t\t\tend\n\t\t\telse if (counter==5'd1) begin\n\t\t\t\tcounter_next = 5'd0;\n\t\t\t\tW_d1 = inst_1[19];\n\t\t\t\tW_d2 = ~inst_1[19];\n\t\t\t\taddr_d1 = mov_addr_WB;\n\t\t\t\taddr_d2 = mov_addr_WB;\n\t\t\t\tif (inst_1[25]) begin\n\t\t\t\t\tDout_d1 = Din_c2;\n\t\t\t\t\tDout_d2 = Din_c2;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tDout_d1 = Din_c1;\n\t\t\t\t\tDout_d2 = Din_c1;\n\t\t\t\tend\n\t\t\t\tinst_1_next = inst_in;\n\t\t\t\tinst_2_next = inst_2;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tcounter_next = 5'd1;\n\t\t\t\tW_d1 = 1'b1;\n\t\t\t\tW_d2 = 1'b1;\n\t\t\t\taddr_d1 = mov_addr_A;\n\t\t\t\taddr_d2 = mov_addr_X;\n\t\t\t\tDout_d1 = 256'd0;\n\t\t\t\tDout_d2 = 256'd0;\n\t\t\tend\n\t\t\tcounter_jump_next = counter_jump;\n\t\tend\n\t\tdefault : begin\n\t\t\tif (comp_type_1==set)\n\t\t\t\tcounter_jump_next = j_counter_1;\n\t\t\telse if (comp_type_i==jump && counter_jump!=7'd0)\n\t\t\t\tcounter_jump_next = counter_jump-7'd1;\n\t\t\telse\n\t\t\t\tcounter_jump_next = counter_jump;\n\t\t\tcounter_next = 5'd0;\n\t\t\t\n\t\t\tif (comp_type_1==set ) begin\n\t\t\t\tinst_1_next = inst_in;\n\t\t\t\tinst_2_next = 31'd0;\n\t\t\tend\n\t\t\tif (comp_type_i==jump) begin\n\t\t\t\tinst_1_next = 31'd0;\n\t\t\tend\n\t\t\t\n\t\t\t\n\t\t\tif ( hy_WB==1'b1 && ready_hy==1'b1 ) begin\n\t\t\t\tif (hy_W_bank==1'b1) begin\n\t\t\t\t\taddr_d2 = hy_addr_WB;\n\t\t\t\t\tDout_d2  = Din_hy;\n\t\t\t\t\tW_d2 = 1'b0;\n\t\t\t\t\tW_d1 = 1'b1;\n\t\t\t\t\taddr_d1 = (ready_hy==1'b1) ? addr_A_in : addr_A_1;\n\t\t\t\t\tDout_d1 = 256'd0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\taddr_d2 = (ready_hy==1'b1) ? addr_X_in : addr_X_1;\n\t\t\t\t\tDout_d2  = 256'd0;\n\t\t\t\t\tW_d2 = 1'b1;\n\t\t\t\t\tW_d1 = 1'b0;\n\t\t\t\t\taddr_d1 = hy_addr_WB;\n\t\t\t\t\tDout_d1 = Din_hy;\n\t\t\t\tend\n\t\t\t\t\n\t\t\tend\n\t\t\telse begin\n\t\t\t\taddr_d2 = (ready_hy==1'b1) ? addr_X_in : addr_X_1;\n\t\t\t\tDout_d2  = 256'd0;\n\t\t\t\tW_d2 = 1'b1;\n\t\t\t\tW_d1 = 1'b1;\n\t\t\t\taddr_d1 = (ready_hy==1'b1) ? addr_A_in : addr_A_1;\n\t\t\t\tDout_d1 = 256'd0;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule\n\n\t\t\t\t\t\t\t"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reset_sync_e8c0381b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule reset_sync(\n    input reset_n,\n    input clk,\n    output [NUM_RESET_OUTPUT-1:0] reset_n_sync\n);\n\n//Global parameters\nparameter RESET_SYNC_STAGES = 4;\nparameter NUM_RESET_OUTPUT = 1;\n\nreg [RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:0] reset_reg ;\n\ngenerate\ngenvar i;\nfor (i=0; i<RESET_SYNC_STAGES+NUM_RESET_OUTPUT-1; i=i+1) begin: reset_stage\n    always @(posedge clk or negedge reset_n) begin\n        if (~reset_n) begin\n            reset_reg[i] <= 1'b0;\n        end else begin\n            if (i==0) begin\n                reset_reg[i] <= 1'b1;\n            end else if (i < RESET_SYNC_STAGES) begin\n                reset_reg[i] <= reset_reg[i-1];\n            end else begin\n                reset_reg[i] <= reset_reg[RESET_SYNC_STAGES-2];\n            end\n        end\n    end\nend\nendgenerate\n\nassign reset_n_sync = reset_reg[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:RESET_SYNC_STAGES-1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_4bit_c937b91e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_sub_4bit (A, B, sub, CK, Y, Cout);\ninput [3:0] A, B;\ninput sub, CK;\noutput [3:0] Y;\noutput Cout;\nreg [3:0] Y_reg;\nwire [3:0] B_neg;\nwire [3:0] B_sub;\nwire [4:0] Y_add;\n\n// Invert B and add 1 to obtain two's complement of B\nassign B_neg = ~B + 1;\n\n// Select either B or B_neg based on sub input\nassign B_sub = (sub) ? B_neg : B;\n\n// Add A and B_sub\nassign Y_add = {1'b0, A} + {1'b0, B_sub};\n\n// Register the sum/difference output\nalways @(posedge CK) begin\n    Y_reg <= Y_add[3:0];\nend\n\n// Output the sum/difference and carry/borrow\nassign Y = Y_reg;\nassign Cout = Y_add[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vga_double_68ad71b7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vga_double(\n\n\tinput  wire        clk,\n\n\tinput  wire        hsync_start,\n\n\tinput  wire        scanin_start,\n\tinput  wire [ 5:0] pix_in,\n\n\tinput  wire        scanout_start,\n\toutput reg  [ 5:0] pix_out\n);\n\n\n\n\treg [9:0] ptr_in;  reg [9:0] ptr_out; reg pages; reg wr_stb;\n\n\twire [ 7:0] data_out;\n\n\n\talways @(posedge clk) if( hsync_start )\n\t\tpages <= ~pages;\n\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( scanin_start )\n\t\tbegin\n\t\t\tptr_in[9:8] <= 2'b00;\n\t\t\tptr_in[5:4] <= 2'b11;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif( ptr_in[9:8]!=2'b11 ) begin\n\t\t\t\twr_stb <= ~wr_stb;\n\t\t\t\tif( wr_stb )\n\t\t\t\tbegin\n\t\t\t\t\tptr_in <= ptr_in + 10'd1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( scanout_start )\n\t\tbegin\n\t\t\tptr_out[9:8] <= 2'b00;\n\t\t\tptr_out[5:4] <= 2'b11;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif( ptr_out[9:8]!=2'b11 )\n\t\t\tbegin\n\t\t\t\tptr_out <= ptr_out + 10'd1;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( ptr_out[9:8]!=2'b11 )\n\t\t\tpix_out <= data_out[5:0];\n\t\telse\n\t\t\tpix_out <= 6'd0;\n\tend\n\n\n\n\n\n\tmem1536 line_buf( .clk(clk),\n\n\t                  .wraddr({ptr_in[9:8], pages, ptr_in[7:0]}),\n\t                  .wrdata({2'b00,pix_in}),\n\t                  .wr_stb(wr_stb),\n\n\t                  .rdaddr({ptr_out[9:8], (~pages), ptr_out[7:0]}),\n\t                  .rddata(data_out)\n\t                );\n\n\nendmodule\n\n\n\n\nmodule mem1536(\n\n\tinput  wire        clk,\n\n\tinput  wire [10:0] wraddr,\n\tinput  wire [ 7:0] wrdata,\n\tinput  wire        wr_stb,\n\n\tinput  wire [10:0] rdaddr,\n\toutput reg  [ 7:0] rddata\n);\n\n\treg [7:0] mem [0:1535];\n\n\talways @(posedge clk)\n\tbegin\n\t\tif( wr_stb )\n\t\tbegin\n\t\t\tmem[wraddr] <= wrdata;\n\t\tend\n\n\t\trddata <= mem[rdaddr];\n\tend\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_mux_baf8c357", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_encoder_mux(\n    input [7:0] in,\n    input [2047:0] mux_in,\n    input [7:0] sel,\n    input [1:0] enable,\n    output [2:0] pos,\n    output [7:0] out1,\n    output [7:0] out2,\n    output [7:0] out3,\n    output [7:0] out4\n);\n\n// Priority encoder\nwire [7:0] in_priority = ~in;\nwire [7:0] in_priority_shifted = {in_priority[6:0], 1'b0};\nwire [7:0] in_priority_or = in_priority | in_priority_shifted;\nwire [7:0] in_priority_or_shifted = {in_priority_or[5:0], 2'b0};\nwire [7:0] in_priority_or_or = in_priority_or | in_priority_or_shifted;\nwire [7:0] in_priority_or_or_shifted = {in_priority_or_or[3:0], 4'b0};\nwire [7:0] in_priority_or_or_or = in_priority_or_or | in_priority_or_or_shifted;\nwire [7:0] in_priority_or_or_or_shifted = {in_priority_or_or_or[1:0], 6'b0};\nwire [7:0] in_priority_or_or_or_or = in_priority_or_or_or | in_priority_or_or_or_shifted;\nassign pos = in_priority_or_or_or_or[7:5] - 1;\n\n// Multiplexer\nwire [7:0] mux_out;\nassign mux_out = mux_in[sel*8 +: 8];\n\n// Decoder\nwire [3:0] enable_decoded;\nassign enable_decoded = (enable == 2'b00) ? 4'b0001 :\n                       (enable == 2'b01) ? 4'b0010 :\n                       (enable == 2'b10) ? 4'b0100 :\n                       (enable == 2'b11) ? 4'b1000 : 4'b0000;\n\n// Output\nassign out1 = (enable_decoded[0]) ? mux_out : 8'b0;\nassign out2 = (enable_decoded[1]) ? mux_out : 8'b0;\nassign out3 = (enable_decoded[2]) ? mux_out : 8'b0;\nassign out4 = (enable_decoded[3]) ? mux_out : 8'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wb_async_reg #_d4f5e160", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule wb_async_reg #\n(\n    parameter DATA_WIDTH = 32,                  parameter ADDR_WIDTH = 32,                  parameter SELECT_WIDTH = (DATA_WIDTH/8)     )\n(\n    input  wire                    wbm_clk,\n    input  wire                    wbm_rst,\n    input  wire [ADDR_WIDTH-1:0]   wbm_adr_i,   input  wire [DATA_WIDTH-1:0]   wbm_dat_i,   output wire [DATA_WIDTH-1:0]   wbm_dat_o,   input  wire                    wbm_we_i,    input  wire [SELECT_WIDTH-1:0] wbm_sel_i,   input  wire                    wbm_stb_i,   output wire                    wbm_ack_o,   output wire                    wbm_err_o,   output wire                    wbm_rty_o,   input  wire                    wbm_cyc_i,   input  wire                    wbs_clk,\n    input  wire                    wbs_rst,\n    output wire [ADDR_WIDTH-1:0]   wbs_adr_o,   input  wire [DATA_WIDTH-1:0]   wbs_dat_i,   output wire [DATA_WIDTH-1:0]   wbs_dat_o,   output wire                    wbs_we_o,    output wire [SELECT_WIDTH-1:0] wbs_sel_o,   output wire                    wbs_stb_o,   input  wire                    wbs_ack_i,   input  wire                    wbs_err_i,   input  wire                    wbs_rty_i,   output wire                    wbs_cyc_o    );\n\nreg [ADDR_WIDTH-1:0] wbm_adr_i_reg = 0;\nreg [DATA_WIDTH-1:0] wbm_dat_i_reg = 0;\nreg [DATA_WIDTH-1:0] wbm_dat_o_reg = 0;\nreg wbm_we_i_reg = 0;\nreg [SELECT_WIDTH-1:0] wbm_sel_i_reg = 0;\nreg wbm_stb_i_reg = 0;\nreg wbm_ack_o_reg = 0;\nreg wbm_err_o_reg = 0;\nreg wbm_rty_o_reg = 0;\nreg wbm_cyc_i_reg = 0;\n\nreg wbm_done_sync1 = 0;\nreg wbm_done_sync2 = 0;\nreg wbm_done_sync3 = 0;\n\nreg [ADDR_WIDTH-1:0] wbs_adr_o_reg = 0;\nreg [DATA_WIDTH-1:0] wbs_dat_i_reg = 0;\nreg [DATA_WIDTH-1:0] wbs_dat_o_reg = 0;\nreg wbs_we_o_reg = 0;\nreg [SELECT_WIDTH-1:0] wbs_sel_o_reg = 0;\nreg wbs_stb_o_reg = 0;\nreg wbs_ack_i_reg = 0;\nreg wbs_err_i_reg = 0;\nreg wbs_rty_i_reg = 0;\nreg wbs_cyc_o_reg = 0;\n\nreg wbs_cyc_o_sync1 = 0;\nreg wbs_cyc_o_sync2 = 0;\nreg wbs_cyc_o_sync3 = 0;\n\nreg wbs_stb_o_sync1 = 0;\nreg wbs_stb_o_sync2 = 0;\nreg wbs_stb_o_sync3 = 0;\n\nreg wbs_done_reg = 0;\n\nassign wbm_dat_o = wbm_dat_o_reg;\nassign wbm_ack_o = wbm_ack_o_reg;\nassign wbm_err_o = wbm_err_o_reg;\nassign wbm_rty_o = wbm_rty_o_reg;\n\nassign wbs_adr_o = wbs_adr_o_reg;\nassign wbs_dat_o = wbs_dat_o_reg;\nassign wbs_we_o = wbs_we_o_reg;\nassign wbs_sel_o = wbs_sel_o_reg;\nassign wbs_stb_o = wbs_stb_o_reg;\nassign wbs_cyc_o = wbs_cyc_o_reg;\n\nalways @(posedge wbm_clk) begin\n    if (wbm_rst) begin\n        wbm_adr_i_reg <= 0;\n        wbm_dat_i_reg <= 0;\n        wbm_dat_o_reg <= 0;\n        wbm_we_i_reg <= 0;\n        wbm_sel_i_reg <= 0;\n        wbm_stb_i_reg <= 0;\n        wbm_ack_o_reg <= 0;\n        wbm_err_o_reg <= 0;\n        wbm_rty_o_reg <= 0;\n        wbm_cyc_i_reg <= 0;\n    end else begin\n        if (wbm_cyc_i_reg & wbm_stb_i_reg) begin\n            if (wbm_done_sync2 & ~wbm_done_sync3) begin\n                wbm_dat_o_reg <= wbs_dat_i_reg;\n                wbm_ack_o_reg <= wbs_ack_i_reg;\n                wbm_err_o_reg <= wbs_err_i_reg;\n                wbm_rty_o_reg <= wbs_rty_i_reg;\n                wbm_we_i_reg <= 0;\n                wbm_stb_i_reg <= 0;\n            end\n        end else begin\n            wbm_adr_i_reg <= wbm_adr_i;\n            wbm_dat_i_reg <= wbm_dat_i;\n            wbm_dat_o_reg <= 0;\n            wbm_we_i_reg <= wbm_we_i & ~(wbm_ack_o | wbm_err_o | wbm_rty_o);\n            wbm_sel_i_reg <= wbm_sel_i;\n            wbm_stb_i_reg <= wbm_stb_i & ~(wbm_ack_o | wbm_err_o | wbm_rty_o);\n            wbm_ack_o_reg <= 0;\n            wbm_err_o_reg <= 0;\n            wbm_rty_o_reg <= 0;\n            wbm_cyc_i_reg <= wbm_cyc_i;\n        end\n    end\n\n    wbm_done_sync1 <= wbs_done_reg;\n    wbm_done_sync2 <= wbm_done_sync1;\n    wbm_done_sync3 <= wbm_done_sync2;\nend\n\nalways @(posedge wbs_clk) begin\n    if (wbs_rst) begin\n        wbs_adr_o_reg <= 0;\n        wbs_dat_i_reg <= 0;\n        wbs_dat_o_reg <= 0;\n        wbs_we_o_reg <= 0;\n        wbs_sel_o_reg <= 0;\n        wbs_stb_o_reg <= 0;\n        wbs_ack_i_reg <= 0;\n        wbs_err_i_reg <= 0;\n        wbs_rty_i_reg <= 0;\n        wbs_cyc_o_reg <= 0;\n        wbs_done_reg <= 0;\n    end else begin\n        if (wbs_ack_i | wbs_err_i | wbs_rty_i) begin\n            wbs_dat_i_reg <= wbs_dat_i;\n            wbs_ack_i_reg <= wbs_ack_i;\n            wbs_err_i_reg <= wbs_err_i;\n            wbs_rty_i_reg <= wbs_rty_i;\n            wbs_we_o_reg <= 0;\n            wbs_stb_o_reg <= 0;\n            wbs_done_reg <= 1;\n        end else if (wbs_stb_o_sync2 & ~wbs_stb_o_sync3) begin\n            wbs_adr_o_reg <= wbm_adr_i_reg;\n            wbs_dat_i_reg <= 0;\n            wbs_dat_o_reg <= wbm_dat_i_reg;\n            wbs_we_o_reg <= wbm_we_i_reg;\n            wbs_sel_o_reg <= wbm_sel_i_reg;\n            wbs_stb_o_reg <= wbm_stb_i_reg;\n            wbs_ack_i_reg <= 0;\n            wbs_err_i_reg <= 0;\n            wbs_rty_i_reg <= 0;\n            wbs_cyc_o_reg <= wbm_cyc_i_reg;\n            wbs_done_reg <= 0;\n        end else if (~wbs_cyc_o_sync2 & wbs_cyc_o_sync3) begin\n            wbs_adr_o_reg <= 0;\n            wbs_dat_i_reg <= 0;\n            wbs_dat_o_reg <= 0;\n            wbs_we_o_reg <= 0;\n            wbs_sel_o_reg <= 0;\n            wbs_stb_o_reg <= 0;\n            wbs_ack_i_reg <= 0;\n            wbs_err_i_reg <= 0;\n            wbs_rty_i_reg <= 0;\n            wbs_cyc_o_reg <= 0;\n            wbs_done_reg <= 0;\n        end\n    end\n\n    wbs_cyc_o_sync1 <= wbm_cyc_i_reg;\n    wbs_cyc_o_sync2 <= wbs_cyc_o_sync1;\n    wbs_cyc_o_sync3 <= wbs_cyc_o_sync2;\n\n    wbs_stb_o_sync1 <= wbm_stb_i_reg;\n    wbs_stb_o_sync2 <= wbs_stb_o_sync1;\n    wbs_stb_o_sync3 <= wbs_stb_o_sync2;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_d_ff_307bf550", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_reg_d_ff (\n    input clk,\n    input reset,            // Synchronous reset\n    input [7:0] d,\n    input select,           // Control input to choose between shift register and D flip-flop\n    output [7:0] q\n);\n\n    reg [7:0] shift_reg;\n    reg [7:0] d_ff;\n\n    always @(posedge clk, negedge reset) begin\n        if (reset == 1'b0) begin\n            shift_reg <= 8'h34;\n            d_ff <= 8'h34;\n        end else begin\n            if (select == 1'b1) begin\n                shift_reg <= {shift_reg[6:0], d};\n            end else begin\n                d_ff <= d;\n            end\n        end\n    end\n\n    assign q = (select == 1'b1) ? shift_reg : d_ff;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tlu_prencoder16_7593d721", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule tlu_prencoder16 (din, dout);\n\ninput [15:0] din;\noutput [3:0] dout;\n\nwire [15:0] onehot;\n\ngenvar i;\ngenerate\n  for (i = 0; i < 16; i = i + 1) begin\n    assign onehot[i] = din[i] & ~(|din[i-1:0]);\n  end\nendgenerate\n\nassign dout[3] = |onehot[15:8];\nassign dout[2] = (|onehot[7:4]) | (|onehot[15:12]);\nassign dout[1] = (|onehot[3:2]) | (|onehot[7:6]) | (|onehot[11:10]) | (|onehot[15:14]);\nassign dout[0] = onehot[0] | onehot[1] | onehot[3] | onehot[5] | onehot[7] | onehot[9] | onehot[11] | onehot[13] | onehot[15];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_8a1903c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n  input clk,\n  input reset,\n  output reg [3:0] count,\n  output reg p,\n  output reg q\n);\n  \n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n  \n  always @(count) begin\n    p = ^count;\n    q = &count;\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__2b466b4b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,\n    input slowena,\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    input [3:0] threshold,\n    output [3:0] count,\n    output high_if_count_greater_than_threshold,\n    output [3:0] final_output\n);\n\n    // Priority Encoder for select signal\n    wire [2:0] sel_priority;\n    priority_encoder pe(sel, sel_priority);\n\n    // 6-to-1 Multiplexer\n    wire [3:0] mux_output;\n    assign mux_output = (sel_priority == 0) ? data0 :\n                        (sel_priority == 1) ? data1 :\n                        (sel_priority == 2) ? data2 :\n                        (sel_priority == 3) ? data3 :\n                        (sel_priority == 4) ? data4 :\n                        (sel_priority == 5) ? data5 :\n                        4'b1; // Output 1 if select signal is outside range\n\n    // 4-bit Binary Up Counter\n    reg [3:0] count_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 4'b0;\n        end else if (slowena) begin\n            count_reg <= count_reg + 1;\n        end\n    end\n    assign count = count_reg;\n\n    // 4-bit Comparator\n    wire [3:0] threshold_value = threshold;\n    assign high_if_count_greater_than_threshold = (count_reg >= threshold_value);\n\n    // Bitwise AND module\n    wire [3:0] and_output;\n    assign and_output = mux_output & high_if_count_greater_than_threshold;\n\n    // Final output\n    assign final_output = and_output;\n\nendmodule\n\n// Priority Encoder module\nmodule priority_encoder (\n    input [2:0] in,\n    output reg [2:0] out\n);\n    always @* begin\n        case (in)\n            3'b000: out = 3'b000;\n            3'b001: out = 3'b001;\n            3'b010: out = 3'b010;\n            3'b011: out = 3'b011;\n            3'b100: out = 3'b100;\n            3'b101: out = 3'b101;\n            default: out = 3'b111; // Output 111 if input is outside range\n        endcase\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotator_adder_36c0c1fa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rotator_adder(\n    input clk,\n    input reset,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [31:0] q\n);\n\nreg [99:0] rotated_data;\nreg [31:0] adder_out;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        rotated_data <= 0;\n        adder_out <= 0;\n    end else begin\n        if (load) begin\n            if (ena == 2'b00) begin\n                rotated_data <= data;\n            end else if (ena == 2'b01) begin\n                rotated_data <= {data[31:0], data[99:32]};\n            end else if (ena == 2'b10) begin\n                rotated_data <= {data[67:0], data[99:68]};\n            end else begin\n                rotated_data <= {data[33:0], data[99:34]};\n            end\n        end\n        \n        adder_out <= rotated_data[31:0] + 32'd12345678;\n        q <= adder_out;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dc_rep_upload_98cb2d16", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule   dc_rep_upload(clk,\n                          rst,\n                          dc_flits_rep,\n                          v_dc_flits_rep,\n                          flits_max,\n                          en_flits_max,\n                          rep_fifo_rdy,\n                          dc_flit_out,\n                          v_dc_flit_out,\n\t\t\t\t\t\t\t\t  dc_ctrl_out,\n                          dc_rep_upload_state\n                          );\ninput                          clk;\ninput                          rst;\ninput         [175:0]          dc_flits_rep;\ninput                          v_dc_flits_rep;\ninput         [3:0]            flits_max;\ninput                          en_flits_max;\ninput                          rep_fifo_rdy;\n                          output        [15:0]            dc_flit_out;\noutput                          v_dc_flit_out;\noutput       [1:0]              dc_ctrl_out;\noutput                          dc_rep_upload_state;\n\nparameter    dc_rep_upload_idle=1'b0;\nparameter    dc_rep_upload_busy=1'b1;\n\nreg          dc_rep_state;\nreg  [175:0]  dc_rep_flits;\nreg  [3:0]   sel_cnt;\nreg          v_dc_flit_out;\nreg          fsm_rst;\nreg          next;\nreg          en_flits_in;\nreg          inc_cnt;\nreg  [3:0]   flits_max_reg;\nreg  [1:0]   dc_ctrl_out;\nassign dc_rep_upload_state=dc_rep_state;\nalways@(*)\nbegin\n  v_dc_flit_out=1'b0;\n  inc_cnt=1'b0;\n  fsm_rst=1'b0;\n  en_flits_in=1'b0;\n  next=1'b0;\n  dc_ctrl_out=2'b00;\n  case(dc_rep_state)\n    dc_rep_upload_idle:\n       begin\n         if(v_dc_flits_rep)\n           begin\n             en_flits_in=1'b1;\n             next=1'b1;\n           end\n       end\n    dc_rep_upload_busy:\n       begin\n         if(rep_fifo_rdy)\n           begin\n             if(sel_cnt==flits_max_reg)\n\t\t\t\t  begin\n               fsm_rst=1'b1;\n\t\t\t\t\tdc_ctrl_out=2'b11;\n\t\t\t\t\tend\n\t\t\t\telse if(sel_cnt==3'b000)\n\t\t\t\t    dc_ctrl_out=2'b01;\n\t\t\t\telse \t \n\t\t\t\t    dc_ctrl_out=2'b10;\n             inc_cnt=1'b1;\n             v_dc_flit_out=1'b1;\n           end\n       end\n    endcase\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    dc_rep_state<=1'b0;\nelse if(next)\n    dc_rep_state<=1'b1;\nend\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    dc_rep_flits<=176'h0000;\n  else if(en_flits_in)\n    dc_rep_flits<=dc_flits_rep;\nend\nreg  [15:0]  dc_flit_out;\nalways@(*)\nbegin\n  case(sel_cnt)\n    4'b0000:dc_flit_out=dc_rep_flits[175:160];\n    4'b0001:dc_flit_out=dc_rep_flits[159:144];\n    4'b0010:dc_flit_out=dc_rep_flits[143:128];\n    4'b0011:dc_flit_out=dc_rep_flits[127:112];\n    4'b0100:dc_flit_out=dc_rep_flits[111:96];\n    4'b0101:dc_flit_out=dc_rep_flits[95:80];\n    4'b0110:dc_flit_out=dc_rep_flits[79:64];\n    4'b0111:dc_flit_out=dc_rep_flits[63:48];\n    4'b1000:dc_flit_out=dc_rep_flits[47:32];\n    4'b1001:dc_flit_out=dc_rep_flits[31:16];\n    4'b1010:dc_flit_out=dc_rep_flits[15:0];\n    default:dc_flit_out=dc_rep_flits[175:160];\n  endcase\nend\n\nalways@(posedge  clk)\nbegin\n  if(rst||fsm_rst)\n    flits_max_reg<=4'b0000;\n  else if(en_flits_max)\n    flits_max_reg<=flits_max;\nend\n    \nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    sel_cnt<=4'b0000;\n  else if(inc_cnt)\n    sel_cnt<=sel_cnt+4'b0001;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__d3d7f8ea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [7:0] A,\n    input [7:0] B,\n    input enable,\n    output EQ,\n    output GT,\n    output OR\n);\n\n    wire [7:0] mux_output;\n    wire EQ_int;\n    wire GT_int;\n\n    // 2-to-1 Multiplexer module\n    mux_2to1 mux_inst (\n        .in0(A),\n        .in1(B),\n        .sel(enable),\n        .out(mux_output)\n    );\n\n    // 8-bit Comparator module\n    comp_8bit comp_inst (\n        .A(mux_output),\n        .B(B),\n        .EQ(EQ_int),\n        .GT(GT_int)\n    );\n\n    // OR gate\n    assign OR = EQ_int | GT_int;\n\n    assign EQ = EQ_int;\n    assign GT = GT_int;\n\nendmodule\n\nmodule mux_2to1 (\n    input [7:0] in0,\n    input [7:0] in1,\n    input sel,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if(sel == 0)\n            out = in0;\n        else\n            out = in1;\n    end\nendmodule\n\nmodule comp_8bit (\n    input [7:0] A,\n    input [7:0] B,\n    output EQ,\n    output GT\n);\n\n    assign EQ = (A == B);\n    assign GT = (A > B);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_buffer_a5ee2d40", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo_buffer(\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input write,\n    output reg [7:0] data_out,\n    input read,\n    output empty,\n    output full\n);\n\n    reg [7:0] buffer [0:15];\n    reg [3:0] head = 0;\n    reg [3:0] tail = 0;\n    reg [3:0] count = 0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            head <= 0;\n            tail <= 0;\n            count <= 0;\n        end else begin\n            if (write && !full) begin\n                buffer[head] <= data_in;\n                head <= (head == 15) ? 0 : head + 1;\n                count <= count + 1;\n            end\n            if (read && !empty) begin\n                data_out <= buffer[tail];\n                tail <= (tail == 15) ? 0 : tail + 1;\n                count <= count - 1;\n            end\n        end\n    end\n\n    assign empty = (count == 0);\n    assign full = (count == 16);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_c5e0600c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input carry_in,\n    input clk,\n    output [3:0] sum,\n    output carry_out\n);\n\nreg [3:0] A_reg, B_reg, sum_reg;\nreg carry_in_reg, carry_out_reg;\n\nalways @(posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    carry_in_reg <= carry_in;\n    sum_reg <= A_reg + B_reg + carry_in_reg;\n    carry_out_reg <= (A_reg[3] & B_reg[3]) | (A_reg[3] & carry_in_reg) | (B_reg[3] & carry_in_reg);\nend\n\nassign sum = sum_reg;\nassign carry_out = carry_out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_4bit_e295e3fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register_4bit (\n    input [3:0] D,\n    input LD, CLK, CLR,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK or posedge CLR) begin\n        if (CLR) begin\n            Q <= 4'b0000;\n        end else if (LD) begin\n            Q <= D;\n        end else begin\n            Q <= {Q[2:0], Q[3]};\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "logic__b3f473e2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule logic_module (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    output Y\n);\n\n    assign Y = (A1 & A2) | ((A1 & ~B1 & ~B2) & ~(A2 | B1 | B2)) | (~A1 & ~A2 & B1 & B2);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add3_526f21ae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add3 (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    output [4:0] S\n);\n\n    wire [4:0] sum1, sum2;\n\n    add2 a1(.A(A), .B(B), .S(sum1));\n    add2 a2(.A(sum1[3:0]), .B(C), .S(sum2));\n    assign S = {sum2[4], sum2[3:0]};\n\nendmodule\n\nmodule add2 (\n    input [3:0] A,\n    input [3:0] B,\n    output [4:0] S\n);\n\n    wire [3:0] sum;\n    wire carry;\n\n    assign sum = A + B;\n    assign carry = (sum >= 10);\n\n    assign S = {carry, sum};\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ports_80f989f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ports(\n\n\tdin,  dout, busin, a, iorq_n,mreq_n,rd_n,wr_n, data_port_input, data_port_output, command_port_input, data_bit_input, command_bit_input, data_bit_output, command_bit_output,\n\n\tdata_bit_wr, command_bit_wr,\n\n\n\tmode_8chans, mode_pan4ch, mode_ramro, mode_norom,\n\n\tmode_pg0, mode_pg1,\n\n\n\tclksel0, clksel1,\n\n\n\tsnd_wrtoggle, snd_datnvol,  snd_addr,     snd_data,     md_din, md_start,\n\tmd_dreq,\n\tmd_halfspeed,\n\n\tmc_ncs, mc_xrst,\n\tmc_dout,\n\tmc_din,\n\tmc_start,\n\tmc_speed,\n\tmc_rdy,\n\n\tsd_ncs, sd_dout,\n\tsd_din,\n\tsd_start,\n\tsd_det,\n\tsd_wp,\n\n\tled, led_toggle,\n\n\n\trst_n,\n\n\tcpu_clock );\n\n\n\tlocalparam MPAG      = 6'h00;\n\tlocalparam MPAGEX    = 6'h10;\n\n\tlocalparam ZXCMD     = 6'h01;\n\tlocalparam ZXDATRD   = 6'h02;\n\tlocalparam ZXDATWR   = 6'h03;\n\tlocalparam ZXSTAT    = 6'h04;\n\tlocalparam CLRCBIT   = 6'h05;\n\n\tlocalparam VOL1      = 6'h06;\n\tlocalparam VOL2      = 6'h07;\n\tlocalparam VOL3      = 6'h08;\n\tlocalparam VOL4      = 6'h09;\n\tlocalparam VOL5      = 6'h16;\n\tlocalparam VOL6      = 6'h17;\n\tlocalparam VOL7      = 6'h18;\n\tlocalparam VOL8      = 6'h19;\n\n\tlocalparam DAMNPORT1 = 6'h0a;\n\tlocalparam DAMNPORT2 = 6'h0b;\n\n\tlocalparam LEDCTR    = 6'h01;\n\n\tlocalparam GSCFG0    = 6'h0f;\n\n\tlocalparam SCTRL     = 6'h11;\n\tlocalparam SSTAT     = 6'h12;\n\n\tlocalparam SD_SEND   = 6'h13;\n\tlocalparam SD_READ   = 6'h13;\n\tlocalparam SD_RSTR   = 6'h14;\n\n\tlocalparam MD_SEND   = 6'h14; localparam MC_SEND   = 6'h15;\n\tlocalparam MC_READ   = 6'h15;\n\n\n\n\tinput      [7:0] din;\n\toutput reg [7:0] dout;\n\n\toutput reg busin; input [15:0] a;\n\n\tinput iorq_n,mreq_n,rd_n,wr_n;\n\n\tinput      [7:0] data_port_input;\n\tinput      [7:0] command_port_input;\n\toutput reg [7:0] data_port_output;\n\n\tinput data_bit_input;\n\tinput command_bit_input;\n\n\toutput reg data_bit_output;\n\n\toutput reg command_bit_output;\n\n\toutput reg data_bit_wr;\n\n\toutput reg command_bit_wr;\n\n\toutput reg mode_8chans;\n\n\toutput reg mode_pan4ch;\n\n\toutput reg mode_ramro;\n\n\toutput reg mode_norom;\n\n\toutput reg [6:0] mode_pg0;\n\toutput reg [6:0] mode_pg1;\n\n\toutput reg clksel0;\n\toutput reg clksel1;\n\n\n\toutput reg snd_wrtoggle;\n\toutput reg snd_datnvol;\n\toutput reg [2:0] snd_addr;\n\toutput reg [7:0] snd_data;\n\n\n\tinput rst_n;\n\n\tinput cpu_clock;\n\n\n\n\n\toutput [7:0] md_din; output md_start; input md_dreq; output reg md_halfspeed;\n\n\n\toutput reg mc_ncs; output reg mc_xrst; output mc_start; output reg [1:0] mc_speed;\n\t\n\tinput mc_rdy;\n\n\toutput [7:0] mc_din; input [7:0] mc_dout; output reg sd_ncs;\n\n\toutput sd_start;\n\n\toutput [7:0] sd_din;\n\n\tinput [7:0] sd_dout;\n\n\tinput sd_det;\n\n\tinput sd_wp;\n\n\noutput reg led;\n\tinput led_toggle;\n\n\n\nreg mode_expag; reg port09_bit5;\n\n\twire port_enabled; wire mem_enabled; reg volports_enabled; reg iowrn_reg; reg iordn_reg; reg merdn_reg; reg port_wr; reg port_rd;  reg memreg_rd; wire port00_wr;   wire p_ledctr_wr;\n\twire port02_rd;\n\twire port03_wr;\n\twire port05_wrrd;\n\twire port09_wr;\n\twire port0a_wrrd;\n\twire port0b_wrrd;\n\twire port0f_wr;\n\twire port10_wr;\n\n\twire p_sstat_rd;\n\twire p_sctrl_rd;\n\twire p_sctrl_wr;\n\twire p_sdsnd_wr;\n\twire p_sdrd_rd;\n\twire p_sdrst_rd;\n\twire p_mdsnd_wr;\n\twire p_mcsnd_wr;\n\twire p_mcrd_rd;\n\n\treg [2:0] volnum; assign port_enabled = ~(a[7] | a[6]); assign mem_enabled = (~a[15]) & a[14] & a[13]; always @*\n\tbegin\n\t\tif( a[5:0]==VOL1 ||\n\t\t    a[5:0]==VOL2 ||\n\t\t    a[5:0]==VOL3 ||\n\t\t    a[5:0]==VOL4 ||\n\t\t    a[5:0]==VOL5 ||\n\t\t    a[5:0]==VOL6 ||\n\t\t    a[5:0]==VOL7 ||\n\t\t    a[5:0]==VOL8 )\n\n\t\t\tvolports_enabled <= 1'b1;\n\t\telse\n\t\t\tvolports_enabled <= 1'b0;\n\tend\n\n\n\n\talways @*\n\tbegin\n\t\tif( port_enabled && (!iorq_n) && (!rd_n) )\n\t\t\tbusin <= 1'b0; else\n\t\t\tbusin <= 1'b1; end\n\n\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tiowrn_reg <= iorq_n | wr_n;\n\t\tiordn_reg <= iorq_n | rd_n;\n\n\t\tif( port_enabled && (!iorq_n) && (!wr_n) && iowrn_reg )\n\t\t\tport_wr <= 1'b1;\n\t\telse\n\t\t\tport_wr <= 1'b0;\n\n\t\tif( port_enabled && (!iorq_n) && (!rd_n) && iordn_reg )\n\t\t\tport_rd <= 1'b1;\n\t\telse\n\t\t\tport_rd <= 1'b0;\n\n\tend\n\n\talways @(negedge cpu_clock)\n\tbegin\n\t\tmerdn_reg <= mreq_n | rd_n;\n\n\t\tif( mem_enabled && (!mreq_n) && (!rd_n) && merdn_reg )\n\t\t\tmemreg_rd <= 1'b1;\n\t\telse\n\t\t\tmemreg_rd <= 1'b0;\n\n\tend\n\n\n\tassign port00_wr   = ( a[5:0]==MPAG      && port_wr            );\n\tassign port02_rd   = ( a[5:0]==ZXDATRD   && port_rd            );\n\tassign port03_wr   = ( a[5:0]==ZXDATWR   && port_wr            );\n\tassign port05_wrrd = ( a[5:0]==CLRCBIT   && (port_wr||port_rd) );\n\tassign port09_wr   = ( a[5:0]==VOL4      && port_wr            );\n\tassign port0a_wrrd = ( a[5:0]==DAMNPORT1 && (port_wr||port_rd) );\n\tassign port0b_wrrd = ( a[5:0]==DAMNPORT2 && (port_wr||port_rd) );\n\tassign port0f_wr   = ( a[5:0]==GSCFG0    && port_wr            );\n\tassign port10_wr   = ( a[5:0]==MPAGEX    && port_wr            );\n\n\n\tassign p_sctrl_rd = ( a[5:0]==SCTRL  && port_rd );\n\tassign p_sctrl_wr = ( a[5:0]==SCTRL  && port_wr );\n\tassign p_sstat_rd = ( a[5:0]==SSTAT  && port_rd );\n\tassign p_sdsnd_wr = ( a[5:0]==SD_SEND && port_wr );\n\tassign p_sdrd_rd  = ( a[5:0]==SD_READ && port_rd );\n\tassign p_sdrst_rd = ( a[5:0]==SD_RSTR && port_rd );\n\tassign p_mdsnd_wr = ( a[5:0]==MD_SEND && port_wr );\n\tassign p_mcsnd_wr = ( a[5:0]==MC_SEND && port_wr );\n\tassign p_mcrd_rd  = ( a[5:0]==MC_READ && port_rd );\n\n\tassign p_ledctr_wr = ( a[5:0]==LEDCTR && port_wr );\n\n\n\n\talways @*\n\tbegin\n\t\tcase( a[5:0] )\n\t\tZXCMD: dout <= command_port_input;\n\t\tZXDATRD: dout <= data_port_input;\n\t\tZXSTAT: dout <= { data_bit_input, 6'bXXXXXX, command_bit_input };\n\t\tGSCFG0: dout <= { 1'b0, mode_pan4ch, clksel1, clksel0, mode_expag, mode_8chans, mode_ramro, mode_norom };\n\n\t\tSSTAT:\n\t\t\tdout <= { 4'd0, mc_rdy, sd_wp, sd_det, md_dreq };\n\t\tSCTRL:\n\t\t\tdout <= { 2'd0, mc_speed[1], md_halfspeed, mc_speed[0], mc_xrst, mc_ncs, sd_ncs };\n\t\tSD_READ:\n\t\t\tdout <= sd_dout;\n\t\tSD_RSTR:\n\t\t\tdout <= sd_dout;\n\t\tMC_READ:\n\t\t\tdout <= mc_dout;\n\n\t\tdefault:\n\t\t\tdout <= 8'bXXXXXXXX;\n\t\tendcase\n\tend\n\n\n\n\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( port00_wr==1'b1 ) begin\n\t\t\tif( mode_expag==1'b0 ) mode_pg0[6:0] <= { din[5:0], 1'b0 };\n\t\t\telse mode_pg0[6:0] <= { din[5:0], din[7] };\n\t\tend\n\n\t\tif( mode_expag==1'b0 && port00_wr==1'b1 ) mode_pg1[6:0] <= { din[5:0], 1'b1 };\n\t\telse if( mode_expag==1'b1 && port10_wr==1'b1 )\n\t\t\tmode_pg1[6:0] <= { din[5:0], din[7] };\n\tend\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( port03_wr==1'b1 )\n\t\t\tdata_port_output <= din;\n\tend\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( port09_wr==1'b1 )\n\t\t\tport09_bit5 <= din[5];\n\tend\n\n\talways @(posedge cpu_clock,negedge rst_n)\n\tbegin\n\t\tif( rst_n==1'b0 ) { mode_pan4ch, clksel1, clksel0, mode_expag, mode_8chans, mode_ramro, mode_norom } <= 7'b0110000;\n\t\telse begin\n\t\t\tif( port0f_wr == 1'b1 )\n\t\t\tbegin\n\t\t\t\t{ mode_pan4ch, clksel1, clksel0, mode_expag, mode_8chans, mode_ramro, mode_norom } <= din[6:0];\n\t\t\tend\n\t\tend\n\tend\n\n\talways @*\n    begin\n\t\tcase( {port02_rd,port03_wr,port0a_wrrd} )\n\t\t3'b100:\n\t\tbegin\n\t\t\tdata_bit_output <= 1'b0;\n\t\t\tdata_bit_wr <= 1'b1;\n\t\tend\n\n\t\t3'b010:\n\t\tbegin\n\t\t\tdata_bit_output <= 1'b1; data_bit_wr <= 1'b1;\n\t\tend\n\n\t\t3'b001:\n\t\tbegin\n\t\t\tdata_bit_output <= ~mode_pg0[0];\n\t\t\tdata_bit_wr <= 1'b1;\n\t\tend\n\n\t\tdefault:\n\t\tbegin\n\t\t\tdata_bit_output <= 1'bX;\n\t\t\tdata_bit_wr <= 1'b0;\n\t\tend\n    \tendcase\n\n    end\n\n\talways @*\n\tbegin\n\t\tcasex( {port05_wrrd,port0b_wrrd} )\n\t\t2'b10:\n\t\tbegin\n\t\t\tcommand_bit_output <= 1'b0;\n\t\t\tcommand_bit_wr <= 1'b1;\n\t\tend\n\n\t\t2'b01:\n\t\tbegin\n\t\t\tcommand_bit_output <= port09_bit5;\n\t\t\tcommand_bit_wr <= 1'b1;\n\t\tend\n\n\t\tdefault:\n\t\tbegin\n\t\t\tcommand_bit_output <= 1'bX;\n\t\t\tcommand_bit_wr <= 1'b0;\n\t\tend\n\t\tendcase\n\tend\n\n\talways @*\n\tbegin\n\t\tcase( a[5:0] ) VOL1:\n\t\t\tvolnum <= 3'd0;\n\t\tVOL2:\n\t\t\tvolnum <= 3'd1;\n\t\tVOL3:\n\t\t\tvolnum <= 3'd2;\n\t\tVOL4:\n\t\t\tvolnum <= 3'd3;\n\t\tVOL5:\n\t\t\tvolnum <= 3'd4;\n\t\tVOL6:\n\t\t\tvolnum <= 3'd5;\n\t\tVOL7:\n\t\t\tvolnum <= 3'd6;\n\t\tVOL8:\n\t\t\tvolnum <= 3'd7;\n\t\tdefault:\n\t\t\tvolnum <= 3'bXXX;\n\t\tendcase\n\tend\n\n\talways @(posedge cpu_clock)\n\tbegin\n\t\tif( memreg_rd ) begin\n\t\t\tsnd_wrtoggle <= ~snd_wrtoggle;\n\t\t\tsnd_datnvol  <= 1'b1; if( !mode_8chans ) snd_addr <= { 1'b0, a[9:8] };\n\t\t\telse snd_addr <= a[10:8];\n\n\t\t\tsnd_data <= din;\n\t\tend\n\t\telse if( volports_enabled && port_wr )\n\t\tbegin\n\t\t\tsnd_wrtoggle <= ~snd_wrtoggle;\n\t\t\tsnd_datnvol  <= 1'b0; snd_addr <= volnum;\n\t\t\tsnd_data <= din;\n\t\tend\n\tend\n\n\n\n\n\n\n\tassign sd_din = (a[5:0]==SD_RSTR) ? 8'hFF : din;\n\tassign mc_din = din;\n\tassign md_din = din;\n\n\n\tassign sd_start = p_sdsnd_wr | p_sdrst_rd;\n\tassign mc_start = p_mcsnd_wr;\n\tassign md_start = p_mdsnd_wr;\n\n\n      always @(posedge cpu_clock, negedge rst_n)\n      begin\n\t\tif( !rst_n ) begin\n\t\t\tmd_halfspeed <= 1'b0;\n\t\t\tmc_speed     <= 2'b01;\n\t\t\tmc_xrst      <= 1'b0;\n\t\t\tmc_ncs       <= 1'b1;\n\t\t\tsd_ncs       <= 1'b1;\n\t\tend\n\t\telse begin\n\t\t\tif( p_sctrl_wr )\n\t\t\tbegin\n\t\t\t\tif( din[0] )\n\t\t\t\t\tsd_ncs       <= din[7];\n\n\t\t\t\tif( din[1] )\n\t\t\t\t\tmc_ncs       <= din[7];\n\n\t\t\t\tif( din[2] )\n\t\t\t\t\tmc_xrst      <= din[7];\n\n\t\t\t\tif( din[3] )\n\t\t\t\t\tmc_speed[0]  <= din[7];\n\n\t\t\t\tif( din[4] )\n\t\t\t\t\tmd_halfspeed <= din[7];\n\t\t\t\t\n\t\t\t\tif( din[5] )\n\t\t\t\t\tmc_speed[1]  <= din[7];\n\n\t\t\tend\n\t\tend\n      end\n\n\n\n\talways @(posedge cpu_clock, negedge rst_n)\n\tbegin\n\t\tif( !rst_n )\n\t\t\tled <= 1'b0;\n\t\telse\n\t\tbegin\n\t\t\tif( p_ledctr_wr )\n\t\t\t\tled <= din[0];\n\t\t\telse if( led_toggle )\n\t\t\t\tled <= ~led;\n\t\tend\n\n\tend\n\n\n\n\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rw_manager_ac_ROM_reg_0e13a995", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule rw_manager_ac_ROM_reg(\n        rdaddress,\n        clock,\n        wraddress,\n        data,\n        wren,\n        q);\n\nparameter AC_ROM_DATA_WIDTH = \"\";\nparameter AC_ROM_ADDRESS_WIDTH = \"\"; \n\n\ninput   [(AC_ROM_ADDRESS_WIDTH-1):0]  rdaddress;\ninput     clock;\ninput [(AC_ROM_ADDRESS_WIDTH-1):0] wraddress;\ninput [(AC_ROM_DATA_WIDTH-1):0] data;\ninput wren;\noutput reg [(AC_ROM_DATA_WIDTH-1):0]  q;\n\nreg [(AC_ROM_DATA_WIDTH-1):0] ac_mem[(2**AC_ROM_ADDRESS_WIDTH-1):0];\n\nalways @(posedge clock)\n\nbegin\n  if(wren)\n  ac_mem[wraddress] <= data;\n  q <= ac_mem[rdaddress];\n\nend\n\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MUX_4to1_2387ae10", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MUX_4to1 (\n  input [3:0] in,\n  input [1:0] sel,\n  output reg out\n);\n\n  always @(*) begin\n    case(sel)\n      2'b00: out = in[0];\n      2'b01: out = in[1];\n      2'b10: out = in[2];\n      2'b11: out = in[3];\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_6631a459", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [2:0] c;\n\n    full_adder fa1(a[0], b[0], 1'b0, sum[0], c[0]);\n    full_adder fa2(a[1], b[1], c[0], sum[1], c[1]);\n    full_adder fa3(a[2], b[2], c[1], sum[2], c[2]);\n    full_adder fa4(a[3], b[3], c[2], sum[3], cout);\n\nendmodule\n\nmodule top_module (\n    input [3:0] a,\n    input [3:0] b,\n    output [4:0] sum\n);\n\n    wire [2:0] c;\n\n    four_bit_adder fa(a, b, sum[3:0], c[2]);\n    assign sum[4] = c[2];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cheat_a71a56d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule cheat(\n  input clk,\n  input [7:0] SNES_PA,\n  input [23:0] SNES_ADDR,\n  input [7:0] SNES_DATA,\n  input SNES_wr_strobe,\n  input SNES_rd_strobe,\n  input SNES_reset_strobe,\n  input snescmd_enable,\n  input nmicmd_enable,\n  input return_vector_enable,\n  input reset_vector_enable,\n  input branch1_enable,\n  input branch2_enable,\n  input pad_latch,\n  input snes_ajr,\n  input SNES_cycle_start,\n  input [2:0] pgm_idx,\n  input pgm_we,\n  input [31:0] pgm_in,\n  output [7:0] data_out,\n  output cheat_hit,\n  output snescmd_unlock\n);\n\nwire snescmd_wr_strobe = snescmd_enable & SNES_wr_strobe;\n\nreg cheat_enable = 0;\nreg nmi_enable = 0;\nreg irq_enable = 0;\nreg holdoff_enable = 0; reg buttons_enable = 0;\nreg wram_present = 0;\nwire branch_wram = cheat_enable & wram_present;\n\nreg auto_nmi_enable = 1;\nreg auto_irq_enable = 0;\nreg auto_nmi_enable_sync = 0;\nreg auto_irq_enable_sync = 0;\nreg hook_enable_sync = 0;\n\nreg [1:0] sync_delay = 2'b10;\n\nreg [4:0] nmi_usage = 5'h00;\nreg [4:0] irq_usage = 5'h00;\nreg [20:0] usage_count = 21'h1fffff;\n\nreg [29:0] hook_enable_count = 0;\nreg hook_disable = 0;\n\nreg [1:0] vector_unlock_r = 0;\nwire vector_unlock = |vector_unlock_r;\n\nreg [1:0] reset_unlock_r = 2'b10;\nwire reset_unlock = |reset_unlock_r;\n\nreg [23:0] cheat_addr[5:0];\nreg [7:0] cheat_data[5:0];\nreg [5:0] cheat_enable_mask;\n\nreg snescmd_unlock_r = 0;\nassign snescmd_unlock = snescmd_unlock_r;\n\nreg [7:0] nmicmd = 0;\nreg [7:0] return_vector = 8'hea;\n\nreg [7:0] branch1_offset = 8'h00;\nreg [7:0] branch2_offset = 8'h00;\n\nreg [15:0] pad_data = 0;\n\nwire [5:0] cheat_match_bits ={(cheat_enable_mask[5] & (SNES_ADDR == cheat_addr[5])),\n                              (cheat_enable_mask[4] & (SNES_ADDR == cheat_addr[4])),\n                              (cheat_enable_mask[3] & (SNES_ADDR == cheat_addr[3])),\n                              (cheat_enable_mask[2] & (SNES_ADDR == cheat_addr[2])),\n                              (cheat_enable_mask[1] & (SNES_ADDR == cheat_addr[1])),\n                              (cheat_enable_mask[0] & (SNES_ADDR == cheat_addr[0]))};\nwire cheat_addr_match = |cheat_match_bits;\n\nwire [1:0] nmi_match_bits = {SNES_ADDR == 24'h00FFEA, SNES_ADDR == 24'h00FFEB};\nwire [1:0] irq_match_bits = {SNES_ADDR == 24'h00FFEE, SNES_ADDR == 24'h00FFEF};\nwire [1:0] rst_match_bits = {SNES_ADDR == 24'h00FFFC, SNES_ADDR == 24'h00FFFD};\n\nwire nmi_addr_match = |nmi_match_bits;\nwire irq_addr_match = |irq_match_bits;\nwire rst_addr_match = |rst_match_bits;\n\nwire hook_enable = ~|hook_enable_count;\n\nassign data_out = cheat_match_bits[0] ? cheat_data[0]\n                : cheat_match_bits[1] ? cheat_data[1]\n                : cheat_match_bits[2] ? cheat_data[2]\n                : cheat_match_bits[3] ? cheat_data[3]\n                : cheat_match_bits[4] ? cheat_data[4]\n                : cheat_match_bits[5] ? cheat_data[5]\n                : nmi_match_bits[1] ? 8'h04\n                : irq_match_bits[1] ? 8'h04\n                : rst_match_bits[1] ? 8'h6b\n                : nmicmd_enable ? nmicmd\n                : return_vector_enable ? return_vector\n                : branch1_enable ? branch1_offset\n                : branch2_enable ? branch2_offset\n                : 8'h2a;\n\nassign cheat_hit = (snescmd_unlock & hook_enable_sync & (nmicmd_enable | return_vector_enable | branch1_enable | branch2_enable))\n                   | (reset_unlock & rst_addr_match)\n                   | (cheat_enable & cheat_addr_match)\n                   | (hook_enable_sync & (((auto_nmi_enable_sync & nmi_enable) & nmi_addr_match & vector_unlock)\n                                           |((auto_irq_enable_sync & irq_enable) & irq_addr_match & vector_unlock)));\n\nreg [7:0] next_pa_addr = 0;\nreg [2:0] cpu_push_cnt = 0;\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    cpu_push_cnt <= 0;\n  end else if(SNES_wr_strobe) begin\n    cpu_push_cnt <= cpu_push_cnt + 1;\n    if(cpu_push_cnt == 3'b0) begin\n      next_pa_addr <= SNES_PA - 1;\n    end else begin\n      if(SNES_PA == next_pa_addr) begin\n         next_pa_addr <= next_pa_addr - 1;\n      end else begin\n        cpu_push_cnt <= 3'b0;\n      end\n    end\n  end else if(SNES_rd_strobe) begin\n    cpu_push_cnt <= 3'b0;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    vector_unlock_r <= 2'b00;\n  end else if(SNES_rd_strobe) begin\n    if(hook_enable_sync\n      & ((auto_nmi_enable_sync & nmi_enable & nmi_match_bits[1])\n        |(auto_irq_enable_sync & irq_enable & irq_match_bits[1]))\n      & cpu_push_cnt == 4) begin\n      vector_unlock_r <= 2'b11;\n    end else if(|vector_unlock_r) begin\n      vector_unlock_r <= vector_unlock_r - 1;\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    reset_unlock_r <= 2'b11;\n  end else if(SNES_cycle_start) begin\n    if(rst_addr_match & |reset_unlock_r) begin\n      reset_unlock_r <= reset_unlock_r - 1;\n    end\n  end\nend\n\nreg snescmd_unlock_disable_strobe = 1'b0;\nreg [6:0] snescmd_unlock_disable_countdown = 0;\nreg snescmd_unlock_disable = 0;\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    snescmd_unlock_r <= 0;\n    snescmd_unlock_disable <= 0;\n  end else begin\n    if(SNES_rd_strobe) begin\n      if(hook_enable_sync\n        & ((auto_nmi_enable_sync & nmi_enable & nmi_match_bits[1])\n          |(auto_irq_enable_sync & irq_enable & irq_match_bits[1]))\n        & cpu_push_cnt == 4) begin\n        return_vector <= SNES_ADDR[7:0];\n        snescmd_unlock_r <= 1;\n      end\n      if(rst_match_bits[1] & |reset_unlock_r) begin\n        snescmd_unlock_r <= 1;\n      end\n    end\n    if(SNES_cycle_start) begin\n      if(snescmd_unlock_disable) begin\n        if(|snescmd_unlock_disable_countdown) begin\n          snescmd_unlock_disable_countdown <= snescmd_unlock_disable_countdown - 1;\n        end else if(snescmd_unlock_disable_countdown == 0) begin\n          snescmd_unlock_r <= 0;\n          snescmd_unlock_disable <= 0;\n        end\n      end\n    end\n    if(snescmd_unlock_disable_strobe) begin\n      snescmd_unlock_disable_countdown <= 7'd72;\n      snescmd_unlock_disable <= 1;\n    end\n  end\nend\n\n\nalways @(posedge clk) usage_count <= usage_count - 1;\n\nalways @(posedge clk) begin\n  if(usage_count == 21'b0) begin\n    nmi_usage <= SNES_cycle_start & nmi_match_bits[1];\n    irq_usage <= SNES_cycle_start & irq_match_bits[1];\n    if(|nmi_usage & |irq_usage) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(irq_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(nmi_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b0;\n      auto_irq_enable <= 1'b1;\n    end\n  end else begin\n    if(SNES_cycle_start & nmi_match_bits[0]) nmi_usage <= nmi_usage + 1;\n    if(SNES_cycle_start & irq_match_bits[0]) irq_usage <= irq_usage + 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) sync_delay <= 2'b10;\n    else begin\n      if (|sync_delay) sync_delay <= sync_delay - 1;\n      if (sync_delay == 2'b00) begin\n        auto_nmi_enable_sync <= auto_nmi_enable;\n        auto_irq_enable_sync <= auto_irq_enable;\n        hook_enable_sync <= hook_enable;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if((snescmd_unlock & snescmd_wr_strobe & ~|SNES_ADDR[8:0] & (SNES_DATA == 8'h85))\n     | (holdoff_enable & SNES_reset_strobe)) begin\n    hook_enable_count <= 30'd960000000;\n  end else if (|hook_enable_count) begin\n    hook_enable_count <= hook_enable_count - 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_reset_strobe) begin\n    snescmd_unlock_disable_strobe <= 1'b0;\n  end else begin\n    snescmd_unlock_disable_strobe <= 1'b0;\n    if(snescmd_unlock & snescmd_wr_strobe) begin\n      if(~|SNES_ADDR[8:0]) begin\n        case(SNES_DATA)\n          8'h82: cheat_enable <= 1;\n          8'h83: cheat_enable <= 0;\n          8'h84: {nmi_enable, irq_enable} <= 2'b00;\n        endcase\n      end else if(SNES_ADDR[8:0] == 9'h1fd) begin\n        snescmd_unlock_disable_strobe <= 1'b1;\n      end\n    end else if(pgm_we) begin\n      if(pgm_idx < 6) begin\n        cheat_addr[pgm_idx] <= pgm_in[31:8];\n        cheat_data[pgm_idx] <= pgm_in[7:0];\n      end else if(pgm_idx == 6) begin cheat_enable_mask <= pgm_in[5:0];\n      end else if(pgm_idx == 7) begin {wram_present, buttons_enable, holdoff_enable, irq_enable, nmi_enable, cheat_enable}\n         <= ({wram_present, buttons_enable, holdoff_enable, irq_enable, nmi_enable, cheat_enable}\n          & ~pgm_in[13:8])\n          | pgm_in[5:0];\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_wr_strobe) begin\n    if(SNES_ADDR[8:0] == 9'h1f0) begin\n      pad_data[7:0] <= SNES_DATA;\n    end else if(SNES_ADDR[8:0] == 9'h1f1) begin\n      pad_data[15:8] <= SNES_DATA;\n    end\n  end\nend\n\nalways @* begin\n  case(pad_data)\n    16'h3030: nmicmd = 8'h80;\n    16'h2070: nmicmd = 8'h81;\n    16'h10b0: nmicmd = 8'h82;\n    16'h9030: nmicmd = 8'h83;\n    16'h5030: nmicmd = 8'h84;\n    16'h1070: nmicmd = 8'h85;\n    default: nmicmd = 8'h00;\n  endcase\nend\n\nalways @* begin\n  if(buttons_enable) begin\n    if(snes_ajr) begin\n      if(nmicmd) begin\n        branch1_offset = 8'h30;   end else begin\n        if(branch_wram) begin\n          branch1_offset = 8'h3a; end else begin\n          branch1_offset = 8'h3d; end\n      end\n    end else begin\n      if(pad_latch) begin\n        if(branch_wram) begin\n          branch1_offset = 8'h3a; end else begin\n          branch1_offset = 8'h3d; end\n      end else begin\n        branch1_offset = 8'h00;   end\n    end\n  end else begin\n    if(branch_wram) begin\n      branch1_offset = 8'h3a;     end else begin\n      branch1_offset = 8'h3d;     end\n  end\nend\n\nalways @* begin\n  if(nmicmd == 8'h81) begin\n    branch2_offset = 8'h0e;       end else if(branch_wram) begin\n    branch2_offset = 8'h00;       end else begin\n    branch2_offset = 8'h03;       end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_sync_flops_1852e02c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_sync_flops\n(\n  rst_i,\n  clk_i,\n  stage1_rst_i,\n  stage1_clk_en_i,\n  async_dat_i,\n  sync_dat_o\n);\n\nparameter width         = 1;\nparameter init_value    = 1'b0;\n\ninput                           rst_i;                  input                           clk_i;                  input                           stage1_rst_i;           input                           stage1_clk_en_i;        input   [width-1:0]             async_dat_i;            output  [width-1:0]             sync_dat_o;             reg     [width-1:0]             sync_dat_o;\nreg     [width-1:0]             flop_0;\n\n\nalways @ (posedge clk_i or posedge rst_i)\nbegin\n    if (rst_i)\n        flop_0 <= {width{init_value}};\n    else\n        flop_0 <= async_dat_i;    \nend\n\nalways @ (posedge clk_i or posedge rst_i)\nbegin\n    if (rst_i)\n        sync_dat_o <= {width{init_value}};\n    else if (stage1_rst_i)\n        sync_dat_o <= {width{init_value}};\n    else if (stage1_clk_en_i)\n        sync_dat_o <= flop_0;       \nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Control_Unit_84bd7b5d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Control_Unit(output reg done, Ld_AR_BR, Div_AR_x2_CR, Mul_BR_x2_CR, Clr_CR,\n\tinput reset_b, start, AR_gt_0, AR_lt_0, clk);\n\n\treg [1:0] state;\n\n\talways @(posedge clk) begin\n\t\tif (reset_b == 0) begin\n\t\t\tLd_AR_BR = 0;\n\t\t\tMul_BR_x2_CR = 0;\n\t\t\tDiv_AR_x2_CR = 0;\n\t\t\tClr_CR = 0;\n\t\t\tdone = 0;\n\t\t\tstate <= 2'b00;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t2'b00: begin\n\t\t\t\t\tLd_AR_BR = 1;\n\t\t\t\t\tMul_BR_x2_CR = 0;\n\t\t\t\t\tDiv_AR_x2_CR = 0;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 0;\n\t\t\t\t\tif (start) begin\n\t\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b01: begin\n\t\t\t\t\tLd_AR_BR = 0;\n\t\t\t\t\tMul_BR_x2_CR = 0;\n\t\t\t\t\tDiv_AR_x2_CR = 0;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tif (AR_gt_0) begin\n\t\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\tend else if (AR_lt_0) begin\n\t\t\t\t\t\tstate <= 2'b11;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b10: begin\n\t\t\t\t\tLd_AR_BR = 0;\n\t\t\t\t\tMul_BR_x2_CR = 1;\n\t\t\t\t\tDiv_AR_x2_CR = 0;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\tend\n\t\t\t\t2'b11: begin\n\t\t\t\t\tLd_AR_BR = 0;\n\t\t\t\t\tMul_BR_x2_CR = 0;\n\t\t\t\t\tDiv_AR_x2_CR = 1;\n\t\t\t\t\tClr_CR = 0;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_36e54bca", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule fifo(\n    output [7:0] dout,\n    output indicator,  input [7:0] din,\n    input din_valid,\n    input clk,\n    input reset_n\n);\n\nparameter SIZE = 20,\n          INDEX_WIDTH = 8,\n          MAX_INDEX = SIZE * 8 - 1;\n\nlocalparam WAITING = 0,\n           RECEIVING = 1,\n           LEFT_PADDING = 2,\n           TRANSFERING = 3,\n           RIGHT_PADDING = 4;\n\nreg [2:0] state, next_state;\nreg [MAX_INDEX:0] queue, next_queue;\nreg [INDEX_WIDTH - 1:0] head, next_head;  reg [6:0] count, next_count;\n\nalways @(*) begin\n    case (state)\n        WAITING: begin\n            if (din_valid) begin\n                next_state = RECEIVING;\n                next_queue = {queue[MAX_INDEX - 8:0],\n                              din};\n                next_head = 8;\n            end else begin\n                next_state = WAITING;\n                next_queue = queue;\n                next_head = 0;\n            end\n            next_count = 0;\n        end\n\n        RECEIVING: begin\n            if (din_valid) begin\n                next_state = RECEIVING;\n                next_queue = {queue[MAX_INDEX - 8:0],\n                              din};\n                next_head = head + 8;\n            end else begin\n                next_state = LEFT_PADDING;\n                next_queue = queue;\n                next_head = head;\n            end\n            next_count = 0;\n        end\n\n        LEFT_PADDING: begin\n            if (count < 79) begin\n                next_state = LEFT_PADDING;\n                next_count = count + 1;\n            end else begin\n                next_state = TRANSFERING;\n                next_count = 0;\n            end\n            next_head = head;\n            next_queue = queue;\n        end\n\n        TRANSFERING: begin\n            if (count < 7) begin\n                next_state = TRANSFERING;\n                next_head = head;\n                next_count = count + 1;\n            end else begin\n                if (head == 8)  next_state = RIGHT_PADDING;\n                else\n                    next_state = TRANSFERING;\n                next_head = head - 8;\n                next_count = 0;\n            end\n            next_queue = queue;\n        end\n\n        RIGHT_PADDING: begin\n            if (count < 15) begin\n                next_state = RIGHT_PADDING;\n                next_count = count + 1;\n            end else begin\n                next_state = WAITING;\n                next_count = 0;\n            end\n            next_head = 0;\n            next_queue = 0;\n        end\n\n        default: begin\n            next_state = WAITING;\n            next_queue = 0;\n            next_head = 0;\n            next_count = 0;\n        end\n    endcase\nend\n\nalways @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        state <= WAITING;\n        queue <= 0;\n        head <= 0;\n        count <= 0;\n    end else begin\n        state <= next_state;\n        queue <= next_queue;\n        head <= next_head;\n        count <= next_count;\n    end\nend\n\nassign dout = (head == 0) ? 0 : queue[(head - 1)-:8],\n       indicator = (state == RECEIVING && ~din_valid) ||\n                   (state == TRANSFERING && next_state == RIGHT_PADDING);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_enable_e2daee25", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1_enable (data0, data1, data2, data3, sel, enable, out);\ninput [3:0] data0, data1, data2, data3;\ninput [1:0] sel;\ninput enable;\noutput out;\n\nwire [1:0] sel_inv;\nassign sel_inv = ~sel;\n\nwire [3:0] mux_out;\nassign mux_out[0] = (sel_inv[1] & sel_inv[0]) ? data0 : 1'bx;\nassign mux_out[1] = (sel_inv[1] & sel[0]) ? data1 : 1'bx;\nassign mux_out[2] = (sel[1] & sel_inv[0]) ? data2 : 1'bx;\nassign mux_out[3] = (sel[1] & sel[0]) ? data3 : 1'bx;\n\nassign out = enable ? 1'b0 : mux_out[sel];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "power_supply_cf176210", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule power_supply (\n  input clk,\n  input rst,\n  output reg VPWR,\n  output reg VGND,\n  output reg VPB,\n  output reg VNB\n);\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      VPWR <= 0;\n      VGND <= 0;\n      VPB <= 0;\n      VNB <= 0;\n    end else begin\n      VPWR <= 1;\n      VGND <= 0;\n      VPB <= 1;\n      VNB <= 0;\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ui_cmd #_c3590f0b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule ui_cmd #\n  (\n   parameter TCQ = 100,\n   parameter ADDR_WIDTH         = 33,\n   parameter BANK_WIDTH         = 3,\n   parameter COL_WIDTH          = 12,\n   parameter RANK_WIDTH         = 2,\n   parameter ROW_WIDTH          = 16,\n   parameter RANKS              = 4,\n   parameter MEM_ADDR_ORDER     = \"BANK_ROW_COLUMN\"\n  )\n  (\n  app_rdy, use_addr, rank, bank, row, col, size, cmd, hi_priority,\n  rd_accepted, wr_accepted, data_buf_addr,\n  rst, clk, accept_ns, rd_buf_full, wr_req_16, app_addr, app_cmd,\n  app_sz, app_hi_pri, app_en, wr_data_buf_addr, rd_data_buf_addr_r\n  );\n\n  input rst;\n  input clk;\n\n  input accept_ns;\n  input rd_buf_full;\n  input wr_req_16;\n  wire app_rdy_ns = accept_ns && ~rd_buf_full && ~wr_req_16;\n  reg app_rdy_r = 1'b0 ;\n  always @(posedge clk) app_rdy_r <= #TCQ app_rdy_ns;\n  output wire app_rdy;\n  assign app_rdy = app_rdy_r;\n\n  input [ADDR_WIDTH-1:0] app_addr;\n  input [2:0] app_cmd;\n  input app_sz;\n  input app_hi_pri;\n  input app_en;\n\n  reg [ADDR_WIDTH-1:0] app_addr_r1 = {ADDR_WIDTH{1'b0}};\n  reg [ADDR_WIDTH-1:0] app_addr_r2 = {ADDR_WIDTH{1'b0}};\n  reg [2:0] app_cmd_r1;\n  reg [2:0] app_cmd_r2;\n  reg app_sz_r1;\n  reg app_sz_r2;\n  reg app_hi_pri_r1;\n  reg app_hi_pri_r2;\n  reg app_en_r1;\n  reg app_en_r2;\n\n  wire [ADDR_WIDTH-1:0] app_addr_ns1 = app_rdy_r && app_en ? app_addr : app_addr_r1;\n  wire [ADDR_WIDTH-1:0] app_addr_ns2 = app_rdy_r ? app_addr_r1 : app_addr_r2;\n  wire [2:0] app_cmd_ns1 = app_rdy_r ? app_cmd : app_cmd_r1;\n  wire [2:0] app_cmd_ns2 = app_rdy_r ? app_cmd_r1 : app_cmd_r2;\n  wire app_sz_ns1 = app_rdy_r ? app_sz : app_sz_r1;\n  wire app_sz_ns2 = app_rdy_r ? app_sz_r1 : app_sz_r2;\n  wire app_hi_pri_ns1 = app_rdy_r ? app_hi_pri : app_hi_pri_r1;\n  wire app_hi_pri_ns2 = app_rdy_r ? app_hi_pri_r1 : app_hi_pri_r2;\n  wire app_en_ns1 = ~rst && (app_rdy_r ? app_en : app_en_r1);\n  wire app_en_ns2 = ~rst && (app_rdy_r ? app_en_r1 : app_en_r2);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      app_addr_r1 <= #TCQ {ADDR_WIDTH{1'b0}};\n      app_addr_r2 <= #TCQ {ADDR_WIDTH{1'b0}};\n    end else begin\n      app_addr_r1 <= #TCQ app_addr_ns1;\n      app_addr_r2 <= #TCQ app_addr_ns2;\n    end \n    app_cmd_r1 <= #TCQ app_cmd_ns1;\n    app_cmd_r2 <= #TCQ app_cmd_ns2;\n    app_sz_r1 <= #TCQ app_sz_ns1;\n    app_sz_r2 <= #TCQ app_sz_ns2;\n    app_hi_pri_r1 <= #TCQ app_hi_pri_ns1;\n    app_hi_pri_r2 <= #TCQ app_hi_pri_ns2;\n    app_en_r1 <= #TCQ app_en_ns1;\n    app_en_r2 <= #TCQ app_en_ns2;\n  end wire use_addr_lcl = app_en_r2 && app_rdy_r;\n  output wire use_addr;\n  assign use_addr = use_addr_lcl;\n\n  output wire [RANK_WIDTH-1:0] rank;\n  output wire [BANK_WIDTH-1:0] bank;\n  output wire [ROW_WIDTH-1:0] row;\n  output wire [COL_WIDTH-1:0] col;\n  output wire size;\n  output wire [2:0] cmd;\n  output wire hi_priority;\n\n  assign col = app_rdy_r\n                 ? app_addr_r1[0+:COL_WIDTH]\n                 : app_addr_r2[0+:COL_WIDTH];\n  generate\n    begin\n      if (MEM_ADDR_ORDER == \"ROW_BANK_COLUMN\")\n      begin\n        assign row = app_rdy_r\n                       ? app_addr_r1[COL_WIDTH+BANK_WIDTH+:ROW_WIDTH]\n                       : app_addr_r2[COL_WIDTH+BANK_WIDTH+:ROW_WIDTH];\n        assign bank = app_rdy_r\n                        ? app_addr_r1[COL_WIDTH+:BANK_WIDTH]\n                        : app_addr_r2[COL_WIDTH+:BANK_WIDTH];\n      end\n      else\n      begin\n        assign row = app_rdy_r\n                       ? app_addr_r1[COL_WIDTH+:ROW_WIDTH]\n                       : app_addr_r2[COL_WIDTH+:ROW_WIDTH];\n        assign bank = app_rdy_r\n                        ? app_addr_r1[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH]\n                        : app_addr_r2[COL_WIDTH+ROW_WIDTH+:BANK_WIDTH];\n      end\n    end\n  endgenerate\n\n  assign rank = (RANKS == 1)\n                  ? 1'b0\n                  : app_rdy_r\n                    ? app_addr_r1[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH]\n                    : app_addr_r2[COL_WIDTH+ROW_WIDTH+BANK_WIDTH+:RANK_WIDTH];\n  assign size = app_rdy_r\n                  ? app_sz_r1\n                  : app_sz_r2;\n  assign cmd = app_rdy_r\n                 ? app_cmd_r1\n                 : app_cmd_r2;\n  assign hi_priority = app_rdy_r\n                         ? app_hi_pri_r1\n                         : app_hi_pri_r2;\n\n  wire request_accepted = use_addr_lcl && app_rdy_r;\n  wire rd = app_cmd_r2[1:0] == 2'b01;\n  wire wr = app_cmd_r2[1:0] == 2'b00;\n  wire wr_bytes = app_cmd_r2[1:0] == 2'b11;\n  wire write = wr || wr_bytes;\n  output wire rd_accepted;\n  assign rd_accepted = request_accepted && rd;\n  output wire wr_accepted;\n  assign wr_accepted = request_accepted && write;\n\n  input [3:0] wr_data_buf_addr;\n  input [3:0] rd_data_buf_addr_r;\n  output wire [3:0] data_buf_addr;\n\n  assign data_buf_addr = ~write ? rd_data_buf_addr_r : wr_data_buf_addr;\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter #_d4ecd889", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter #(\n    parameter WIDTH = 8\n)(\n    input clk,\n    input rst,\n    input enable,\n    input [WIDTH-1:0] mod,\n    output reg [WIDTH-1:0] count,\n    output reg done\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n        done <= 0;\n    end else if (enable) begin\n        if (count == mod-1) begin\n            count <= 0;\n            done <= 1;\n        end else begin\n            count <= count + 1;\n            done <= 0;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "voltage_inverter_f5e6a25d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule voltage_inverter (\n    output Z,\n    input A,\n    input TE\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // p-type and n-type transistors\n    //sky130_fd_sc_hdll_vnp vnp (\n    //    .D(Z),\n    //    .G(A),\n    //    .S(VPB),\n    //    .B(VNB)\n    //);\n    //sky130_fd_sc_hdll_vpp vpp (\n    //    .D(Z),\n    //    .G(A),\n    //    .S(VPB),\n    //    .B(VNB)\n    //);\n\n    // inverter logic\n    assign Z = TE ? ~A : A;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_gray_bd811d77", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_to_gray (\n    input [4:0] bin_in,\n    output reg [4:0] gray_out\n);\n\nreg [4:0] stage1_out;\nreg [4:0] stage2_out;\n\n// Stage 1\nalways @ (bin_in) begin\n    stage1_out[0] = bin_in[0];\n    stage1_out[1] = bin_in[0] ^ bin_in[1];\n    stage1_out[2] = bin_in[1] ^ bin_in[2];\n    stage1_out[3] = bin_in[2] ^ bin_in[3];\n    stage1_out[4] = bin_in[3] ^ bin_in[4];\nend\n\n// Stage 2\nalways @ (stage1_out) begin\n    stage2_out[0] = stage1_out[0];\n    stage2_out[1] = stage1_out[1] ^ stage1_out[0];\n    stage2_out[2] = stage1_out[2] ^ stage1_out[1];\n    stage2_out[3] = stage1_out[3] ^ stage1_out[2];\n    stage2_out[4] = stage1_out[4] ^ stage1_out[3];\nend\n\nalways @* begin\n    gray_out = stage2_out;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "openhmc_sync_fifo_reg_stage #_da6f9c29", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule openhmc_sync_fifo_reg_stage #(parameter DWIDTH = 8)(\n    input wire clk,\n    input wire res_n,\n    input wire [DWIDTH-1:0] d_in,\n    input wire [DWIDTH-1:0] d_in_p,\n    input wire p_full,\n    input wire n_full,\n    input wire si,\n    input wire so,\n    output reg full,\n    output reg [DWIDTH-1:0] d_out\n);\n\n    wire en, muxi;\n\n    assign en = (si & so & full)                // so and si, shift through\n                | (si & ~so & ~full && n_full)  // shift in new value\n                | (~si & so & p_full);          // shift through\n\n    assign muxi = (si & ~so) | (si & so & ~p_full & full);\n\n    always @ (posedge clk or negedge res_n) begin\n        if (!res_n) begin\n            full <= 1'b0;\n            d_out <= {DWIDTH{1'b0}};\n        end else begin\n            if (en) begin\n                if (muxi) begin\n                    d_out <= d_in;      // enter new value when enabled\n                end else begin\n                    d_out <= d_in_p;    // shift through\n                end\n            end\n\n            full <= (full & si)             // stay full while si to other stage\n                    | (full & ~si & ~so)    // hold full\n                    | (~si & so & p_full)   // keep full as long as prev stage is full\n                    | (si & ~so & n_full);  // fill this stage by si\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_e42c9446", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input carry_in,\n    output [3:0] S,\n    output carry_out\n);\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    assign sum = A + B + carry_in;\n    assign carry = (A[3] & B[3]) | (A[3] & carry_in) | (B[3] & carry_in);\n\n    assign S = sum;\n    assign carry_out = carry[3];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "output_mux_879805f7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule output_mux (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign X = ((A1 & A2) ? B1 : ((A1 & ~A2) ? C1 : 1'b0));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_d_latch_6671d666", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_d_latch (\n    input  D   ,\n    output Q   ,\n    input  GATE\n);\n\nreg Q;\n\nalways @(posedge GATE)\n    Q <= D;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "debounce_b93d6222", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule debounce(input clk, but, output reg debounced);\n\treg [9:0] debTimer;\n\talways @(posedge clk) begin\n\t\tif (debounced == but)\n\t\t\tdebTimer <= 0;\n\t\telse if (debTimer != -10'b1)\n\t\t\tdebTimer <= debTimer+1;\n\t\telse if (debTimer == -10'b1)\n\t\t\tdebounced <= but;\n\tend\nendmodule\n\nmodule clkDiv(input clk, output divClk);\n\tparameter n = 25;\n\treg [n-1:0] count = 0;\n\tassign divClk = count[n-1];\n\t\n\talways @(posedge clk)\n\t\tcount <= count + 1;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__or2b_4152fb33", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__or2b (\n    X  ,\n    A  ,\n    B_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B_N;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , B_N            );\n    or  or0  (or0_out_X, not0_out, A    );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "seven_segment_leds_x_8_2c22a411", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule seven_segment_leds_x_8(\n    input [31:0] bcd_in,\n    input [7:0] decimal_points,\n    input clk,\n    output  reg [6:0] a_to_g,\n    output reg decimal_point,\n    output reg [7:0] anode \n    );\n\nwire [2:0] counter;\nreg [3:0] digit;\nreg [20:0] clkdiv;\t\n\t \n\nassign counter = clkdiv[20:18];   always @(posedge clk)\n    case(counter)\n\t0: {digit, decimal_point} = {bcd_in[3:0], ~decimal_points[0]};\n\t1: {digit, decimal_point} = {bcd_in[7:4], ~decimal_points[1]};\n\t2: {digit, decimal_point} = {bcd_in[11:8], ~decimal_points[2]};\n\t3: {digit, decimal_point} = {bcd_in[15:12], ~decimal_points[3]};\n\t4: {digit, decimal_point} = {bcd_in[19:16], ~decimal_points[4]};\n    \t5: {digit, decimal_point} = {bcd_in[23:20], ~decimal_points[5]};\n    \t6: {digit, decimal_point} = {bcd_in[27:24], ~decimal_points[6]};\n    \t7: {digit, decimal_point} = {bcd_in[31:28], ~decimal_points[7]};\n     endcase\n\nalways @(posedge clk)\n     case(digit)\n    \t0: a_to_g = 8'b1000000;  1: a_to_g = 8'b1111001;  2: a_to_g = 8'b0100100;  3: a_to_g = 8'b0110000;  4: a_to_g = 8'b0011001;  5: a_to_g = 8'b0010010;  6: a_to_g = 8'b0000010;  7: a_to_g = 8'b1111000;  8: a_to_g = 8'b0000000;  9: a_to_g = 8'b0010000;  default: a_to_g = 8'b11111111;  endcase\n\t  \nalways @(posedge clk)\n    case(counter)\n        0: anode = 8'b11111110;\n\t1: anode = 8'b11111101;\n\t2: anode = 8'b11111011;\n\t3: anode = 8'b11110111;\n\t4: anode = 8'b11101111;\n        5: anode = 8'b11011111;\n        6: anode = 8'b10111111;\n        7: anode = 8'b01111111;\n\tdefault: anode = 8'b11111111;  endcase\n     \nalways  @ (posedge clk)\n   begin\n\tclkdiv <= clkdiv + 21'b1;\n    end \n\t  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_counter_and_barrel_shifter_5dd57a90", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule johnson_counter_and_barrel_shifter (\n    input clk,\n    input [3:0] DATA_IN,\n    input [1:0] SHIFT,\n    output reg [3:0] Q\n);\n\nreg [3:0] counter;\nreg [3:0] shifted_counter;\nreg [3:0] and_output;\n\nalways @(posedge clk) begin\n    // Johnson counter sequence\n    case(counter)\n        4'b0001: counter <= 4'b0011;\n        4'b0011: counter <= 4'b0111;\n        4'b0111: counter <= 4'b1110;\n        4'b1110: counter <= 4'b1100;\n        4'b1100: counter <= 4'b1000;\n        4'b1000: counter <= 4'b0001;\n    endcase\n    \n    // Barrel shifter\n    if (SHIFT == 2'b01) begin // Shift right\n        shifted_counter[0] <= counter[3];\n        shifted_counter[1] <= counter[0];\n        shifted_counter[2] <= counter[1];\n        shifted_counter[3] <= counter[2];\n    end\n    else if (SHIFT == 2'b10) begin // Shift left\n        shifted_counter[0] <= counter[1];\n        shifted_counter[1] <= counter[2];\n        shifted_counter[2] <= counter[3];\n        shifted_counter[3] <= counter[0];\n    end\n    else begin // No shift\n        shifted_counter <= counter;\n    end\n    \n    // Bitwise AND\n    and_output <= shifted_counter & DATA_IN;\n    \n    // Output\n    Q <= shifted_counter;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mealy_fsm_52dad21b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mealy_fsm (\n  input clk,\n  input reset,\n  input in1,\n  input in2,\n  output reg out,\n  output reg [2:0] state\n);\n\n  // Define the states\n  parameter A = 3'b000;\n  parameter B = 3'b001;\n  parameter C = 3'b010;\n  parameter D = 3'b011;\n  parameter E = 3'b100;\n\n  // Define the state transition table\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= A;\n      out <= 0;\n    end else begin\n      case (state)\n        A: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n        B: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n        C: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n        D: begin\n          if (in1 == 0 && in2 == 0) begin\n            state <= A;\n            out <= 0;\n          end else if (in1 == 0 && in2 == 1) begin\n            state <= B;\n            out <= 0;\n          end else if (in1 == 1 && in2 == 0) begin\n            state <= C;\n            out <= 1;\n          end else if (in1 == 1 && in2 == 1) begin\n            state <= D;\n            out <= 0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplexer4 #_976faf10", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Multiplexer4 #(parameter width = 3)(\n  input [width-1:0] i_data0,\n  input [width-1:0] i_data1,\n  input [width-1:0] i_data2,\n  input [width-1:0] i_data3,\n  input             i_select0,\n  input             i_select1,\n  input             i_select2,\n  input             i_select3,\n  output reg [width-1:0] o_data,\n  output reg            o_error\n);\n\n  always @(*) begin\n    case ({i_select3, i_select2, i_select1, i_select0})\n      4'b0000: o_data = i_data0;\n      4'b0001: o_data = i_data1;\n      4'b0010: o_data = i_data2;\n      4'b0011: o_data = i_data3;\n      default: begin\n        o_data = 0;\n        o_error = 1;\n      end\n    endcase\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RegisterBanc_36694281", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule RegisterBanc(ReadData1, ReadData2, WriteData,ReadAddr1, ReadAddr2, WriteAddr, RegWrite, clk , ro);\n    output [31:0] ReadData1, ReadData2;\n    input [31:0] WriteData;\n    input [4:0] ReadAddr1, ReadAddr2, WriteAddr;\n    input [0:0] RegWrite, clk;\n\t output [31:0] ro;\n\n\n    reg [31:0] Register [0:31];\n\t \n\t \n    initial begin \n      Register[0] = 32'd0;\n\t\tRegister[1] = 32'd0;\n\t\tRegister[2] = 32'd0;\n\t\tRegister[3] = 32'd0;\n\t\tRegister[4] = 32'd0;\n\t\tRegister[5] = 32'd0;\n\t\tRegister[6] = 32'd0;\n\t\tRegister[7] = 32'd0;\n\t\tRegister[8] = 32'd0;\n\t\tRegister[9] = 32'd0;\n\t\tRegister[10] = 32'd0;\n\t\tRegister[11] = 32'd0;\n\t\tRegister[12] = 32'd0;\n\t\tRegister[13] = 32'd0;\n\t\tRegister[14] = 32'd0;\n\t\tRegister[15] = 32'd0;\n\t\tRegister[16] = 32'd0;\n\t\tRegister[17] = 32'd0;\n\t\tRegister[18] = 32'd0;\n\t\tRegister[19] = 32'd0;\n\t\tRegister[20] = 32'd0;\n\t\tRegister[21] = 32'd0;\n\t\tRegister[22] = 32'd0;\n\t\tRegister[23] = 32'd0;\n\t\tRegister[24] = 32'd0;\n\t\tRegister[25] = 32'd0;\n\t\tRegister[26] = 32'd0;\n\t\tRegister[27] = 32'd0;\n\t\tRegister[28] = 32'd0;\n\t\tRegister[29] = 32'd0;\n\t\tRegister[30] = 32'd0;\n\t\tRegister[31] = 32'd0;\n    end\n\t \n\t \n    always @ (posedge clk) begin\n        if (RegWrite) begin\n            Register[WriteAddr] <= WriteData; \n        end\n\n    end\n    \n    assign ReadData1 = Register[ReadAddr1];\n    assign ReadData2 = Register[ReadAddr2];\n\t assign ro=Register[4'd2];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "altera_up_video_scaler_shrink_51868d6d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule altera_up_video_scaler_shrink (\n\tclk,\n\treset,\n\n\tstream_in_data,\n\tstream_in_startofpacket,\n\tstream_in_endofpacket,\n\tstream_in_valid,\n\n\tstream_out_ready,\n\t\n\tstream_in_ready,\n\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_valid\n);\n\n\n\nparameter DW\t\t\t\t\t=  15; parameter WW\t\t\t\t\t=   9; parameter HW\t\t\t\t\t=   9; parameter WIDTH_IN\t\t\t= 640; parameter WIDTH_DROP_MASK\t= 4'b0101;\nparameter HEIGHT_DROP_MASK\t= 4'b0000;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[DW: 0]\tstream_in_data;\ninput\t\t\t\t\t\tstream_in_startofpacket;\ninput\t\t\t\t\t\tstream_in_endofpacket;\ninput\t\t\t\t\t\tstream_in_valid;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tstream_in_ready;\n\noutput reg\t[DW: 0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire \t\t\t\t\t\tdrop;\n\nwire\t\t\t\t\t\tcapture_inputs;\n\nwire\t\t\t\t\t\ttransfer_data;\n\nreg\t\t\t\t\t\tsaved_startofpacket;\n\nreg\t\t\t[DW: 0]\tdata;\nreg\t\t\t\t\t\tstartofpacket;\nreg\t\t\t\t\t\tendofpacket;\nreg\t\t\t\t\t\tvalid;\n\nreg\t\t\t[WW: 0]\twidth_counter;\nreg\t\t\t[HW: 0]\theight_counter;\nreg\t\t\t[ 3: 0]\tdrop_pixel;\nreg\t\t\t[ 3: 0]\tdrop_line;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'h0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (transfer_data)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= data;\n\t\tstream_out_startofpacket\t<= startofpacket;\n\t\tstream_out_endofpacket\t\t<= endofpacket;\n\t\tstream_out_valid\t\t\t\t<= valid;\n\tend\n\telse if (stream_out_ready & stream_out_valid)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'h0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\nend\n\nalways @(posedge clk)\n\tif (reset)\n\t\tsaved_startofpacket\t<= 1'b0;\n\telse if (capture_inputs)\n\t\tsaved_startofpacket\t<= 1'b0;\n\telse if (stream_in_ready)\n\t\tsaved_startofpacket\t<= saved_startofpacket | stream_in_startofpacket;\n\t\t\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tdata\t\t\t\t<=  'h0;\n\t\tstartofpacket\t<= 1'b0;\n\t\tendofpacket\t\t<= 1'b0;\n\t\tvalid\t\t\t\t<= 1'b0;\n\tend\n\telse if (capture_inputs)\n\tbegin\n\t\tdata\t\t\t\t<= stream_in_data;\n\t\tstartofpacket\t<= stream_in_startofpacket | saved_startofpacket;\n\t\tendofpacket\t\t<= stream_in_endofpacket;\n\t\tvalid\t\t\t\t<= stream_in_valid;\n\tend\n\telse if (stream_in_ready)\n\t\tendofpacket\t\t<= endofpacket | stream_in_endofpacket;\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\twidth_counter\t\t<= 'h0;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket | (width_counter == (WIDTH_IN - 1)))\n\t\t\twidth_counter\t<= 'h0;\n\t\telse\n\t\t\twidth_counter\t<= width_counter + 1;\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\theight_counter\t\t<= 'h0;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket)\n\t\t\theight_counter\t<= 'h0;\n\t\telse if (width_counter == (WIDTH_IN - 1))\n\t\t\theight_counter\t<= height_counter + 1;\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tdrop_pixel\t\t<= 4'b0000;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket)\n\t\t\tdrop_pixel\t<= WIDTH_DROP_MASK;\n\t\telse if (width_counter == (WIDTH_IN - 1))\n\t\t\tdrop_pixel\t<= WIDTH_DROP_MASK;\n\t\telse\n\t\t\tdrop_pixel\t<= {drop_pixel[2:0], drop_pixel[3]};\t\t\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tdrop_line\t\t<= 4'b0000;\n\telse if (stream_in_ready)\n\tbegin\n\t\tif (stream_in_startofpacket)\n\t\t\tdrop_line\t<= HEIGHT_DROP_MASK;\n\t\telse if (width_counter == (WIDTH_IN - 1))\n\t\t\tdrop_line\t<= {drop_line[2:0], drop_line[3]};\n\tend\nend\n\n\n\nassign stream_in_ready\t= stream_in_valid & (drop | ~valid | transfer_data);\n\nassign drop\t\t\t\t\t= drop_pixel[0] | drop_line[0];\n\nassign capture_inputs\t= stream_in_ready & ~drop;\n\nassign transfer_data\t\t= ~stream_out_valid & stream_in_valid & ~drop;\n\n\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bin_adder_46530fef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bin_adder (\n    A,\n    B,\n    CI,\n    SUM,\n    COUT_N\n);\n\n    input A;\n    input B;\n    input CI;\n    output SUM;\n    output COUT_N;\n\n    wire S1;\n    wire C1;\n    wire C2;\n\n    assign S1 = A ^ B;\n    assign SUM = S1 ^ CI;\n    assign C1 = A & B;\n    assign C2 = CI & S1;\n    assign COUT_N = C1 | C2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hpdmc_busif #_206a096f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule hpdmc_busif #(\n\tparameter sdram_depth = 23\n) (\n\tinput sys_clk,\n\tinput sdram_rst,\n\t\n\tinput [sdram_depth-1:0] fml_adr,\n\tinput fml_stb,\n\tinput fml_we,\n\toutput fml_ack,\n\t\n\toutput mgmt_stb,\n\toutput mgmt_we,\n\toutput [sdram_depth-1-1:0] mgmt_address, \n\tinput mgmt_ack,\n\t\n\tinput data_ack\n);\n\nreg mgmt_stb_en;\n\nassign mgmt_stb = fml_stb & mgmt_stb_en;\nassign mgmt_we = fml_we;\nassign mgmt_address = fml_adr[sdram_depth-1:1];\n\nassign fml_ack = data_ack;\n\nalways @(posedge sys_clk) begin\n\tif(sdram_rst)\n\t\tmgmt_stb_en = 1'b1;\n\telse begin\n\t\tif(mgmt_ack)\n\t\t\tmgmt_stb_en = 1'b0;\n\t\tif(data_ack)\n\t\t\tmgmt_stb_en = 1'b1;\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_4bit_e9471292", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_4bit(\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      count <= 4'b0;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_2439475d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator (\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] OP,\n    output [3:0] RESULT\n);\n\nparameter NUM_OPERATIONS = 4;\n\nreg [3:0] result;\n\nalways @(*) begin\n    case (OP)\n        2'b00: result = A + B;\n        2'b01: result = A - B;\n        2'b10: result = A * B;\n        2'b11: result = A / B;\n    endcase\nend\n\nassign RESULT = result;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "quick_spi_hard #_2485c299", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n`define LSB_FIRST 0\n`define MSB_FIRST 1\n`define LITTLE_ENDIAN 0\n`define BIG_ENDIAN 1\n\n`define MAX_DATA_WIDTH 64\n\nmodule quick_spi_hard #\n(\n    parameter NUMBER_OF_SLAVES = 2,\n\tparameter INCOMING_DATA_WIDTH = 8,\n    parameter OUTGOING_DATA_WIDTH = 16,\n\tparameter BITS_ORDER = `MSB_FIRST,\n\tparameter BYTES_ORDER = `LITTLE_ENDIAN,\n\tparameter EXTRA_WRITE_SCLK_TOGGLES = 6,\n    parameter EXTRA_READ_SCLK_TOGGLES = 4,\n\tparameter CPOL = 0,\n    parameter CPHA = 0,\n\tparameter MOSI_IDLE_VALUE = 1'b0\n)\n(\n    input wire clk,\n    input wire reset_n,\n    input wire enable,\n    input wire start_transaction,\n    input wire[NUMBER_OF_SLAVES-1:0] slave,\n    input wire operation,\n    output reg end_of_transaction,\n    output reg[INCOMING_DATA_WIDTH-1:0] incoming_data,\n    input wire[OUTGOING_DATA_WIDTH-1:0] outgoing_data,\n    output reg mosi,\n    input wire miso,\n    output reg sclk,\n    output reg[NUMBER_OF_SLAVES-1:0] ss_n);\n\nlocalparam READ = 1'b0;\nlocalparam WRITE = 1'b1;\n\nlocalparam READ_SCLK_TOGGLES = (INCOMING_DATA_WIDTH * 2) + 2;\nlocalparam ALL_READ_TOGGLES = EXTRA_READ_SCLK_TOGGLES + READ_SCLK_TOGGLES;\n\nlocalparam NUMBER_OF_FULL_BYTES = OUTGOING_DATA_WIDTH > 1 ? (OUTGOING_DATA_WIDTH / 8) : 0;\nlocalparam NUMBER_OF_PARTICULAR_BITS = OUTGOING_DATA_WIDTH > (NUMBER_OF_FULL_BYTES * 8) ? 1 : 0;\nlocalparam NUMBER_OF_BYTES = NUMBER_OF_FULL_BYTES + NUMBER_OF_PARTICULAR_BITS;\nlocalparam MAX_BYTES_INDEX = NUMBER_OF_BYTES - 1;\n\ninteger sclk_toggle_count;\ninteger transaction_toggles;\n\nreg spi_clock_phase;\nreg[1:0] state;\n\nlocalparam IDLE = 2'b00;\nlocalparam ACTIVE = 2'b01;\nlocalparam WAIT = 2'b10;\n\nreg[INCOMING_DATA_WIDTH - 1:0] incoming_data_buffer;\nreg[OUTGOING_DATA_WIDTH - 1:0] outgoing_data_buffer;\nreg[`MAX_DATA_WIDTH - 1:0] intermediate_buffer;\n\nreg[2:0] bit_counter;\nreg[3:0] byte_counter;\n    \nalways @ (posedge clk) \nbegin\n    if(!reset_n) \n\tbegin\n        end_of_transaction <= 1'b0;\n        mosi <= MOSI_IDLE_VALUE;\n        sclk <= CPOL;\n        ss_n <= {NUMBER_OF_SLAVES{1'b1}};\n        sclk_toggle_count <= 0;\n        transaction_toggles <= 0;\n        spi_clock_phase <= ~CPHA;\n        incoming_data <= {INCOMING_DATA_WIDTH{1'b0}};\n        incoming_data_buffer <= {INCOMING_DATA_WIDTH{1'b0}};\n        outgoing_data_buffer <= {OUTGOING_DATA_WIDTH{1'b0}};\n        state <= IDLE;\n        bit_counter <= 0;\n        byte_counter <= 0;\n    end\n    \n    else begin\n        case(state)\n            IDLE: \n\t\t\tbegin                \n                if(enable) \n\t\t\t\tbegin\n\t\t\t\t    bit_counter <= 0;\n                    byte_counter <= 0;\n                    if(start_transaction) \n\t\t\t\t\tbegin\n                        transaction_toggles <= (operation == READ) ? ALL_READ_TOGGLES : EXTRA_WRITE_SCLK_TOGGLES;\n\t\t\t\t\t\tintermediate_buffer = put_data(outgoing_data, BYTES_ORDER);\n\t\t\t\t        outgoing_data_buffer <= intermediate_buffer[15:0];\n                        state <= ACTIVE;\n                    end\n                end\n            end\n            \n            ACTIVE: \n\t\t\tbegin\n                ss_n[slave] <= 1'b0;\n                spi_clock_phase <= ~spi_clock_phase;\n                \n                if(ss_n[slave] == 1'b0) \n\t\t\t\tbegin\n                    if(sclk_toggle_count < (OUTGOING_DATA_WIDTH * 2) + transaction_toggles) \n\t\t\t\t\tbegin\n                        sclk <= ~sclk;\n                        sclk_toggle_count <= sclk_toggle_count + 1;\n                    end\n                end\n                \n                if(spi_clock_phase == 1'b0) \n\t\t\t\tbegin\n                    if(operation == READ) \n\t\t\t\t\tbegin\n                        if(sclk_toggle_count > ((OUTGOING_DATA_WIDTH * 2) + EXTRA_READ_SCLK_TOGGLES)-1) \n\t\t\t\t\t\tbegin\n                            incoming_data_buffer <= incoming_data_buffer >> 1;\n                            incoming_data_buffer[INCOMING_DATA_WIDTH-1] <=  miso;\n                        end\n                    end\n                end\n                \n                else \n\t\t\t\tbegin \n                    if(sclk_toggle_count < (OUTGOING_DATA_WIDTH * 2) - 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t    if(BITS_ORDER == `LSB_FIRST)\n\t\t\t\t\t    begin                  \n                            mosi <= outgoing_data_buffer[0]; outgoing_data_buffer <= outgoing_data_buffer >> 1;\n                        end\n                        else\n                        begin\n                            bit_counter <= bit_counter + 1;\n                            mosi <= outgoing_data_buffer[7 - bit_counter];\n                            if(bit_counter == 7)\n                                outgoing_data_buffer <= outgoing_data_buffer >> 8;   \n                        end\n                    end\n                end\n                \n                if(sclk_toggle_count == (OUTGOING_DATA_WIDTH * 2) + transaction_toggles) \n\t\t\t\tbegin\n                    ss_n[slave] <= 1'b1;\n                    mosi <= MOSI_IDLE_VALUE;\n                    incoming_data <= incoming_data_buffer;\n                    incoming_data_buffer <= {INCOMING_DATA_WIDTH{1'b0}};\n                    outgoing_data_buffer <= {OUTGOING_DATA_WIDTH{1'b0}};\n                    sclk <= CPOL;\n                    spi_clock_phase <= ~CPHA;\n                    sclk_toggle_count <= 0;\n                    end_of_transaction <= 1'b1;\n                    state <= WAIT;\n                end\n            end\n            \n            WAIT: \n\t\t\tbegin\n                incoming_data <= {INCOMING_DATA_WIDTH{1'b0}};\n                end_of_transaction <= 1'b0;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nfunction [`MAX_DATA_WIDTH - 1:0] put_data(input reg [`MAX_DATA_WIDTH - 1 : 0] data, input reg order);\n    reg [`MAX_DATA_WIDTH - 1:0] result;\n    reg[7:0] shift;   \nbegin\n    shift = `MAX_DATA_WIDTH - NUMBER_OF_BYTES * 8;\n\tif (order == `BIG_ENDIAN)begin\n\t      result = {data[7:0], data[15:8], data[23:16], data[31:24], data[39:32], data[47:40], data[55:48], data[63:56]};    \n\t\t if(shift > 0)\n\t\t     put_data = result >> shift;\n\t\t     else put_data = result;\n\tend\n\telse if (order == `LITTLE_ENDIAN)begin\n\t    put_data = data;\n\tend\nend\nendfunction\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_4b7c29e9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module(\n    input [99:0] a, b, // Input ports for 100-bit binary numbers\n    input cin, // Carry-in input for 100-bit binary adder\n    input clk, // Clock input for 4-bit binary counter\n    input reset, // Synchronous active-high reset input for 4-bit binary counter\n    output [99:0] sum // Output port for final 100-bit sum\n);\n\n    wire [99:0] adder_out;\n    wire [3:0] counter_out;\n    wire [99:0] final_sum;\n\n    // Instantiate the 100-bit binary adder\n    binary_adder adder_inst(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(adder_out),\n        .cout()\n    );\n\n    // Instantiate the 4-bit binary counter\n    binary_counter counter_inst(\n        .clk(clk),\n        .reset(reset),\n        .out(counter_out)\n    );\n\n    // Instantiate the functional module that adds the output of the adder to the counter value\n    functional_module func_inst(\n        .adder_out(adder_out),\n        .counter_out(counter_out),\n        .final_sum(final_sum)\n    );\n\n    // Assign the final sum to the output port\n    assign sum = final_sum;\n\nendmodule\n\n// 100-bit binary adder module\nmodule binary_adder(\n    input [99:0] a, b, // Input ports for 100-bit binary numbers\n    input cin, // Carry-in input\n    output reg [99:0] sum, // Output port for sum\n    output reg cout // Output port for carry-out\n);\n\n    always @(*) begin\n        {cout, sum} = a + b + cin;\n    end\n\nendmodule\n\n// 4-bit binary counter module\nmodule binary_counter(\n    input clk, // Clock input\n    input reset, // Synchronous active-high reset input\n    output reg [3:0] out // Output port for counter value\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0;\n        end else begin\n            out <= out + 1;\n        end\n    end\n\nendmodule\n\n// Functional module that adds the output of the adder to the counter value\nmodule functional_module(\n    input [99:0] adder_out, // Input port for output of 100-bit binary adder\n    input [3:0] counter_out, // Input port for output of 4-bit binary counter\n    output reg [99:0] final_sum // Output port for final sum\n);\n\n    always @(*) begin\n        final_sum = adder_out + {96'b0, counter_out};\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tone_generator_56dae1f4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule tone_generator (\n  input clk,\n  input reset,\n  input [1:0] mode,\n  input [7:0] freq,\n  output reg signed [N-1:0] tone\n);\n\nparameter fs = 100000; // sampling frequency\nparameter N = 8; // number of bits used to represent the amplitude of the tone signal\n\nreg [31:0] phase_acc;\nreg [31:0] phase_inc;\n\nalways @ (posedge clk) begin\n  if (reset) begin\n    phase_acc <= 0;\n    tone <= 0;\n  end else begin\n    phase_acc <= phase_acc + phase_inc;\n    case (mode)\n      2'b00: begin // DTMF\n        case (freq)\n          8'h11: phase_inc <= 32'd3486784;\n          8'h12: phase_inc <= 32'd3853932;\n          8'h13: phase_inc <= 32'd4261416;\n          8'h14: phase_inc <= 32'd4706164;\n          8'h21: phase_inc <= 32'd6048840;\n          8'h22: phase_inc <= 32'd6684096;\n          8'h23: phase_inc <= 32'd7389128;\n          8'h24: phase_inc <= 32'd8165376;\n        endcase\n        tone <= $signed({{(N-1){phase_acc[31]}}, (phase_acc[31:0]) * 2**(N-1)})>>>0;\n      end\n      2'b01: begin // sine wave\n        phase_inc <= 32'd1572864 * freq;\n        tone <= $signed({{(N-1){phase_acc[31]}}, (phase_acc[31:0]) * 2**(N-1)})>>>0;\n      end\n      2'b10: begin // square wave\n        phase_inc <= 32'd1572864 * freq;\n        if (phase_acc[31]) begin\n          tone <= (N-1);\n        end else begin\n          tone <= -(N-1);\n        end\n      end\n    endcase\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder #_7ecb53cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule priority_encoder #\n(\n    parameter WIDTH = 4,\n    parameter LSB_HIGH_PRIORITY = 0\n)\n(\n    input  wire [WIDTH-1:0]         input_unencoded,\n    output wire                     output_valid,\n    output wire [$clog2(WIDTH)-1:0] output_encoded,\n    output wire [WIDTH-1:0]         output_unencoded\n);\n\nparameter LEVELS = WIDTH > 2 ? $clog2(WIDTH) : 1;\nparameter W = 2**LEVELS;\n\nwire [W-1:0] input_padded = {{W-WIDTH{1'b0}}, input_unencoded};\n\nwire [W/2-1:0] stage_valid[LEVELS-1:0];\nwire [W/2-1:0] stage_enc[LEVELS-1:0];\n\ngenerate\n    genvar l, n;\n\n    for (n = 0; n < W/2; n = n + 1) begin : loop_in\n        assign stage_valid[0][n] = |input_padded[n*2+1:n*2];\n        if (LSB_HIGH_PRIORITY) begin\n            assign stage_enc[0][n] = !input_padded[n*2+0];\n        end else begin\n            assign stage_enc[0][n] = input_padded[n*2+1];\n        end\n    end\n\n    for (l = 1; l < LEVELS; l = l + 1) begin : loop_levels\n        for (n = 0; n < W/(2*2**l); n = n + 1) begin : loop_compress\n            assign stage_valid[l][n] = |stage_valid[l-1][n*2+1:n*2];\n            if (LSB_HIGH_PRIORITY) begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+0] ? {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]} : {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]};\n            end else begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+1] ? {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]} : {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]};\n            end\n        end\n    end\nendgenerate\n\nassign output_valid = stage_valid[LEVELS-1];\nassign output_encoded = stage_enc[LEVELS-1];\nassign output_unencoded = 1 << output_encoded;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "inverter_d8427f65", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule inverter (\n  input [(1 - 1):0] ip,\n  output [(1 - 1):0] op,\n  input clk,\n  input ce,\n  input clr);\n\n  reg [(1 - 1):0] op_reg;\n\n  always @(posedge clk) begin\n    if (ce) begin\n      op_reg <= ~ip;\n    end\n  end\n\n  assign op = clr ? 1'b0 : op_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_ccfa0038", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(a, b, op, result);\n\ninput [7:0] a;\ninput [7:0] b;\ninput [1:0] op;\noutput reg [7:0] result;\n\nalways @(*) begin\n    case (op)\n        2'b00: result = a + b; // addition\n        2'b01: result = a - b; // subtraction\n        2'b10: result = a * b; // multiplication\n        2'b11: begin // division\n            if (b == 0) begin\n                result = 8'h00; // division by zero\n            end else begin\n                result = a / b; // quotient\n                result = result << 8; // shift quotient to MSB\n                result = result | (a % b); // add remainder to LSB\n            end\n        end\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mig_7series_v1_9_ddr_prbs_gen #_f0cec6f8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule mig_7series_v1_9_ddr_prbs_gen #\n  (\n   parameter TCQ         = 100,        parameter PRBS_WIDTH  = 64          )\n  (\n   input                      clk_i,          input                      clk_en_i,       input                      rst_i,          input [PRBS_WIDTH-1:0]     prbs_seed_i,    input                      phy_if_empty,   input                      prbs_rdlvl_start, output [PRBS_WIDTH-1:0]    prbs_o );\n\n  function integer clogb2 (input integer size);\n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n        size = size >> 1;\n    end\n  endfunction\n  \n  localparam PRBS_SEQ_LEN_CYCLES = 128;\n  localparam PRBS_SEQ_LEN_CYCLES_BITS = clogb2(PRBS_SEQ_LEN_CYCLES);\n  \n  reg                                 phy_if_empty_r;\n  reg                                 reseed_prbs_r;\n  reg [PRBS_SEQ_LEN_CYCLES_BITS-1:0]  sample_cnt_r;\n  reg [PRBS_WIDTH - 1 :0]             prbs;  \n  reg [PRBS_WIDTH :1]                 lfsr_q;\n  \n  always @(posedge clk_i) begin\n    phy_if_empty_r <= #TCQ phy_if_empty;\n  end\n\n  always @(posedge clk_i)\n  begin\n    if (rst_i || ~clk_en_i) begin\n      sample_cnt_r    <= #TCQ 'b0;\n      reseed_prbs_r   <= #TCQ 1'b0;\n    end else if (clk_en_i && (~phy_if_empty_r || ~prbs_rdlvl_start)) begin\n      sample_cnt_r    <= #TCQ sample_cnt_r + 1;\n      if (sample_cnt_r == PRBS_SEQ_LEN_CYCLES - 2)\n        reseed_prbs_r <= #TCQ 1'b1;\n      else\n        reseed_prbs_r <= #TCQ 1'b0;\n    end\n  end\n\n  always @ (posedge clk_i)\n  begin\nif ((reseed_prbs_r && clk_en_i) || rst_i || ~clk_en_i) begin\n      lfsr_q[4:1]          <= #TCQ prbs_seed_i[3:0] | 4'h5;\n      lfsr_q[PRBS_WIDTH:5] <= #TCQ prbs_seed_i[PRBS_WIDTH-1:4];\n    end\n    else if (clk_en_i && (~phy_if_empty_r || ~prbs_rdlvl_start)) begin\n      lfsr_q[PRBS_WIDTH:31] <= #TCQ lfsr_q[PRBS_WIDTH-1:30];\n      lfsr_q[30]            <= #TCQ lfsr_q[16] ^ lfsr_q[13] ^ lfsr_q[5]  ^ lfsr_q[1];\n      lfsr_q[29:9]          <= #TCQ lfsr_q[28:8];\n      lfsr_q[8]             <= #TCQ lfsr_q[32] ^ lfsr_q[7];\n      lfsr_q[7]             <= #TCQ lfsr_q[32] ^ lfsr_q[6];\n      lfsr_q[6:4]           <= #TCQ lfsr_q[5:3];\n      lfsr_q[3]             <= #TCQ lfsr_q[32] ^ lfsr_q[2];\n      lfsr_q[2]             <= #TCQ lfsr_q[1] ;\n      lfsr_q[1]             <= #TCQ lfsr_q[32];\n    end\n  end\n \n  always @ (lfsr_q[PRBS_WIDTH:1]) begin\n    prbs = lfsr_q[PRBS_WIDTH:1];\n  end\n\n  assign prbs_o = prbs;\n\nendmodule\n   \n         \n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Convolutional_Encoder_Viterbi_Decoder #_96a533d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Convolutional_Encoder_Viterbi_Decoder #(\n  parameter k = 1, // number of input bits in each group\n  parameter n = 2, // number of output bits in each group\n  parameter p = 2, // number of bits in the encoder's shift register\n  parameter m = 2 // number of bits in the decoder's shift register\n)(\n  input [k-1:0] in,\n  output reg [n-1:0] enc_out,\n  output reg [k-1:0] dec_out\n);\n\nreg [p-1:0] shift_reg; // encoder's shift register\nreg [m-1:0] dec_reg; // decoder's shift register\n\n// Encoder mapping function\nfunction [n-1:0] encode;\n  input [k-1:0] data;\n  begin\n    case (data)\n      0: encode = {1'b1, 1'b0};\n      1: encode = {1'b0, 1'b1};\n      2: encode = {1'b1, 1'b1};\n      3: encode = {1'b0, 1'b0};\n    endcase\n  end\nendfunction\n\n// Decoder decoding algorithm\nfunction [k-1:0] decode;\n  input [n-1:0] data;\n  begin\n    if (data == {1'b1, 1'b0}) decode = 1'b0;\n    else if (data == {1'b0, 1'b1}) decode = 1'b1;\n    else if (data == {1'b1, 1'b1}) decode = 2'b10;\n    else if (data == {1'b0, 1'b0}) decode = 2'b11;\n  end\nendfunction\n\n// Encoder process\nalways @(in) begin\n  shift_reg = {in, shift_reg[p-1:1]}; // shift in new input bit\n  enc_out = encode(shift_reg); // encode input data\nend\n\n// Decoder process\nalways @(enc_out) begin\n  dec_reg = {enc_out, dec_reg[m-1:1]}; // shift in new encoded bit\n  dec_out = decode(dec_reg); // decode encoded data\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_5e9bdb44", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input [7:0] num1,\n    input [7:0] num2,\n    output reg [7:0] result,\n    output reg overflow,\n    output reg divide_by_zero\n);\n\nreg [15:0] product;\nreg [15:0] quotient;\nreg [15:0] dividend;\nreg [7:0] divisor;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 8'b0;\n        overflow <= 1'b0;\n        divide_by_zero <= 1'b0;\n    end\n    else begin\n        case (op)\n            2'b00: begin // addition\n                result <= num1 + num2;\n                overflow <= (result[7] != num1[7]) && (result[7] != num2[7]);\n                divide_by_zero <= 1'b0;\n            end\n            2'b01: begin // subtraction\n                result <= num1 - num2;\n                overflow <= (result[7] != num1[7]) && (result[7] == num2[7]);\n                divide_by_zero <= 1'b0;\n            end\n            2'b10: begin // multiplication\n                product <= num1 * num2;\n                if (product[15:8] != 8'b0) begin // overflow\n                    overflow <= 1'b1;\n                    result <= 8'b0;\n                end\n                else begin\n                    overflow <= 1'b0;\n                    result <= product[7:0];\n                end\n                divide_by_zero <= 1'b0;\n            end\n            2'b11: begin // division\n                if (num2 == 8'b0) begin // divide by zero\n                    divide_by_zero <= 1'b1;\n                    result <= 8'b0;\n                end\n                else begin\n                    divide_by_zero <= 1'b0;\n                    dividend <= {num1, 8'b0};\n                    divisor <= {num2, 8'b0};\n                    quotient <= dividend / divisor;\n                    if (quotient[15:8] != 8'b0) begin // overflow\n                        overflow <= 1'b1;\n                        result <= 8'b0;\n                    end\n                    else begin\n                        overflow <= 1'b0;\n                        result <= quotient[7:0];\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_dwidth_converter_v2_1_7_b_downsizer #_cb6abe21", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n \nmodule axi_dwidth_converter_v2_1_7_b_downsizer #\n  (\n   parameter         C_FAMILY                         = \"none\", \n                       parameter integer C_AXI_ID_WIDTH                   = 1\n                       )\n  (\n   input  wire                                                    ARESET,\n   input  wire                                                    ACLK,\n\n   input  wire                              cmd_valid,\n   input  wire                              cmd_split,\n   input  wire [8-1:0]                      cmd_repeat,\n   output wire                              cmd_ready,\n   input  wire [C_AXI_ID_WIDTH-1:0]         cmd_id,\n   \n   output wire [C_AXI_ID_WIDTH-1:0]           S_AXI_BID,\n   output wire [2-1:0]                          S_AXI_BRESP,\n   output wire                                                    S_AXI_BVALID,\n   input  wire                                                    S_AXI_BREADY,\n\n   input  wire [2-1:0]                         M_AXI_BRESP,\n   input  wire                                                   M_AXI_BVALID,\n   output wire                                                   M_AXI_BREADY\n   );\n  \n  \n  localparam [2-1:0] C_RESP_OKAY        = 2'b00;\n  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;\n  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;\n  localparam [2-1:0] C_RESP_DECERR      = 2'b11;\n  \n  \n  wire                            cmd_ready_i;\n  wire                            pop_mi_data;\n  wire                            mi_stalling;\n  \n  reg  [8-1:0]                    repeat_cnt_pre;\n  reg  [8-1:0]                    repeat_cnt;\n  wire [8-1:0]                    next_repeat_cnt;\n  reg                             first_mi_word;\n  wire                            last_word;\n  \n  wire                            load_bresp;\n  wire                            need_to_update_bresp;\n  reg  [2-1:0]                    S_AXI_BRESP_ACC;\n  \n  wire                            M_AXI_BREADY_I;\n  \n  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_BID_I;\n  reg  [2-1:0]                    S_AXI_BRESP_I;\n  wire                            S_AXI_BVALID_I;\n  wire                            S_AXI_BREADY_I;\n  \n  \n  assign M_AXI_BREADY_I = ~mi_stalling;\n  assign M_AXI_BREADY   = M_AXI_BREADY_I;\n  \n  assign S_AXI_BVALID_I = M_AXI_BVALID & last_word;\n  \n  assign pop_mi_data    = M_AXI_BVALID & M_AXI_BREADY_I;\n  \n  assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;\n  assign cmd_ready      = cmd_ready_i;\n  \n  assign mi_stalling    = (~S_AXI_BREADY_I & last_word);\n                          \n  \n  assign load_bresp           = (cmd_split & first_mi_word);\n  \n  assign need_to_update_bresp = ( M_AXI_BRESP > S_AXI_BRESP_ACC );\n  \n  always @ *\n  begin\n    if ( cmd_split ) begin\n      if ( load_bresp || need_to_update_bresp ) begin\n        S_AXI_BRESP_I = M_AXI_BRESP;\n      end else begin\n        S_AXI_BRESP_I = S_AXI_BRESP_ACC;\n      end\n    end else begin\n      S_AXI_BRESP_I = M_AXI_BRESP;\n    end\n  end\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      S_AXI_BRESP_ACC <= C_RESP_OKAY;\n    end else begin\n      if ( pop_mi_data ) begin\n        S_AXI_BRESP_ACC <= S_AXI_BRESP_I;\n      end\n    end\n  end\n  \n  \n  assign last_word  = ( ( repeat_cnt == 8'b0 ) & ~first_mi_word ) | \n                      ~cmd_split;\n  \n  always @ *\n  begin\n    if ( first_mi_word ) begin\n      repeat_cnt_pre  =  cmd_repeat;\n    end else begin\n      repeat_cnt_pre  =  repeat_cnt;\n    end\n  end\n  \n  assign next_repeat_cnt  = repeat_cnt_pre - 2'b01;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      repeat_cnt    <= 8'b0;\n      first_mi_word <= 1'b1;\n    end else begin\n      if ( pop_mi_data ) begin\n        repeat_cnt    <= next_repeat_cnt;\n        first_mi_word <= last_word;\n      end\n    end\n  end\n  \n  \n  assign S_AXI_BID_I  = cmd_id;\n  \n    assign S_AXI_BID      = S_AXI_BID_I;\n  assign S_AXI_BRESP    = S_AXI_BRESP_I;\n  assign S_AXI_BVALID   = S_AXI_BVALID_I;\n  assign S_AXI_BREADY_I = S_AXI_BREADY;\n  \n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "camera_fd7833b0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule camera \n(\n\tinput refclk,\n\tinput reset_n,\n\n\toutput pixclk,\n\toutput vsync,\n\toutput hsync,\n\toutput [7:0] data\n\n);\n\nreg [12:0] hs_counter = 0;\nreg [9:0] vs_counter = 0;\n\nassign pixclk = refclk;\n\nalways @(negedge refclk)\nbegin\n\tif(reset_n == 0)\n\t\tbegin\n\t\t\ths_counter = 0;\n\t\t\tvs_counter = 0;\n\t\tend\n\telse\n\t\tbegin\n\t\t\tif(hs_counter == 1567)\n\t\t\tbegin\n\t\t\t\ths_counter <= 0;\n\t\t\t\t\n\t\t\t\tif(vs_counter == 510)\n\t\t\t\t\tvs_counter <= 0;\n\t\t\t\telse\n\t\t\t\t\tvs_counter <= vs_counter + 1;\n\t\t\t\t\n\t\t\tend\n\t\t\telse\n\t\t\ths_counter <= hs_counter + 1;\n\t\tend\n\t\t\nend\n\nreg clk2 = 0;\n\nalways@(negedge refclk)\nclk2 <= !clk2;\n\nreg [16:0] pixel_counter = 0;\n\nalways@(posedge clk2)\nbegin\n\tif(hs_counter == 1566)\n\t\tpixel_counter <= 0;\n\telse\n\t\tpixel_counter <= pixel_counter + 1;\nend\n\nreg [7:0] temp_data;\n\nwire [15:0] line_counter;\n\nreg [15:0] line_counter_2;\n\nreg data_part = 0;\n\nalways@(negedge refclk)\nbegin\nif(reset_n == 0)\n\tbegin\n\t\tdata_part <= 0;\n\t\ttemp_data <= 0;\n\tend\nelse\nbegin\n\tif(!clk2)\n\t\ttemp_data[7:0] <= pixel_counter[15:8];\n\telse\n\t\ttemp_data[7:0] <= pixel_counter[7:0];\n\nend\n\nend\n\nassign data = temp_data;\n\nassign vsync = vs_counter < 3 && reset_n != 0 ? 1 : 0;\nassign hsync = vs_counter > 19 && vs_counter < 500 && hs_counter < 1280 && reset_n != 0 ? 1 : 0;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "limbus_cpu_cpu_nios2_oci_dtrace_74dc13e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule limbus_cpu_cpu_nios2_oci_dtrace (\n  // inputs:\n  input clk,\n  input [21:0] cpu_d_address,\n  input cpu_d_read,\n  input [31:0] cpu_d_readdata,\n  input cpu_d_wait,\n  input cpu_d_write,\n  input [31:0] cpu_d_writedata,\n  input jrst_n,\n  input [15:0] trc_ctrl,\n\n  // outputs:\n  output reg [35:0] atm,\n  output reg [35:0] dtm\n);\n\n  wire [31:0] cpu_d_address_0_padded;\n  wire [31:0] cpu_d_readdata_0_padded;\n  wire [31:0] cpu_d_writedata_0_padded;\n  wire dummy_tie_off;\n  wire record_load_addr;\n  wire record_load_data;\n  wire record_store_addr;\n  wire record_store_data;\n  wire [3:0] td_mode_trc_ctrl;\n\n  assign cpu_d_writedata_0_padded = {cpu_d_writedata, 32'b0};\n  assign cpu_d_readdata_0_padded = {cpu_d_readdata, 32'b0};\n  assign cpu_d_address_0_padded = {cpu_d_address, 32'b0};\n\n  //limbus_cpu_cpu_nios2_oci_trc_ctrl_td_mode, which is an e_instance\n  //limbus_cpu_cpu_nios2_oci_td_mode limbus_cpu_cpu_nios2_oci_trc_ctrl_td_mode\n  //  (\n  //    .ctrl    (trc_ctrl[8 : 0]),\n  //    .td_mode (td_mode_trc_ctrl)\n  //  );\n\n  assign {record_load_addr, record_store_addr,\n         record_load_data, record_store_data} = td_mode_trc_ctrl;\n\n  always @ (posedge clk or negedge jrst_n) begin\n    if (jrst_n == 0) begin\n      atm <= 0;\n      dtm <= 0;\n    end else begin\n      if (cpu_d_read) begin\n        atm <= cpu_d_address;\n        dtm <= cpu_d_readdata;\n      end else if (cpu_d_write) begin\n        atm <= cpu_d_address;\n        dtm <= cpu_d_writedata;\n      end else if (cpu_d_wait) begin\n        atm <= 0;\n        dtm <= 0;\n      end\n    end\n  end\n\n  assign dummy_tie_off = cpu_d_wait | cpu_d_read | cpu_d_write;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_5e55771e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate(\n  input CLK, // clock signal\n  input EN, // enable signal\n  input TE, // test enable signal\n  output ENCLK // gated clock signal\n);\n\n  reg gated_clk;\n  \n  always @(*) begin\n    if (TE) begin\n      gated_clk = 1;\n    end else if (EN) begin\n      gated_clk = CLK;\n    end else begin\n      gated_clk = 0;\n    end\n  end\n\n  assign ENCLK = gated_clk;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alu_f304fc95", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule alu(\n    output reg [31:0] ALUResult,\n    output reg Zero,\n    input [31:0] A,\n    input [31:0] B,\n    input [2:0] control\n);\n    wire [31:0] notB, muxBout, S, andResult, orResult, SLT;\n\n    wire Cout;\n\n    assign notB = ~B;\n\n    assign muxBout = (control[2]) ? notB : B;\n\n    assign {Cout, S} = muxBout + A + control[2]; assign andResult = A & muxBout;\n    assign orResult = A | muxBout;\n    assign SLT = {{31{1'b0}}, {S[31]}}; always @ (control[1:0] or andResult or orResult or S or SLT or ALUResult) begin\n        case(control[1:0])\n            2'b00: ALUResult = andResult;\n            2'b01: ALUResult = orResult;\n            2'b10: ALUResult = S;\n            2'b11: ALUResult = SLT;\n        endcase\n\n        if (ALUResult == 32'h00000000) begin\n            Zero <= 1;\n        end else begin\n            Zero <= 0;\n        end\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_transfer_4fe337b3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule data_transfer(\n  input CLK,\n  input RESET_L,\n  input writeRead_Regs_DATA,\n  input [3:0] blockCount_Regs_DATA,\n  input multipleData_Regs_DATA,\n  input timeout_Enable_Regs_DATA,\n  input [15:0] timeout_Reg_Regs_DATA,\n  input new_DAT_DMA_DATA,\n  input serial_Ready_Phy_DATA,\n  output reg timeout_Phy_DATA,\n  output reg complete_Phy_DATA,\n  input ack_IN_Phy_DATA,\n  input fifo_OK_FIFO_DATA,\n  output reg ack_OUT_DATA_Phy,\n  output reg [3:0] blocks_DATA_Phy,\n  output reg idle_out_DATA_Phy,\n  output reg multiple_DATA_Phy,\n  output reg strobe_OUT_DATA_Phy,\n  output reg [15:0] timeout_value_DATA_Phy,\n  output reg transfer_complete_DATA_DMA,\n  output reg writeReadPhysical_DATA_Phy\n);\n\n  reg [15:0] timeout_counter;\n  reg [3:0] block_count;\n  reg timeout_enable;\n  reg multiple_data;\n  reg write_read;\n\n  always @(posedge CLK) begin\n    if (RESET_L == 0) begin\n      timeout_counter <= 0;\n      block_count <= 0;\n      timeout_enable <= 0;\n      multiple_data <= 0;\n      write_read <= 0;\n      ack_OUT_DATA_Phy <= 0;\n      blocks_DATA_Phy <= 0;\n      idle_out_DATA_Phy <= 1;\n      strobe_OUT_DATA_Phy <= 0;\n      transfer_complete_DATA_DMA <= 0;\n      writeReadPhysical_DATA_Phy <= 0;\n      multiple_DATA_Phy <= 0;\n    end else begin\n      if (timeout_enable) begin\n        if (timeout_counter < timeout_Reg_Regs_DATA) begin\n          timeout_counter <= timeout_counter + 1;\n        end else begin\n          timeout_counter <= 0;\n          timeout_enable <= 0;\n          timeout_Phy_DATA <= 1'b1;\n        end\n      end\n      if (new_DAT_DMA_DATA && serial_Ready_Phy_DATA && !timeout_enable && !transfer_complete_DATA_DMA) begin\n        timeout_counter <= 0;\n        timeout_enable <= timeout_Enable_Regs_DATA;\n        write_read <= writeRead_Regs_DATA;\n        block_count <= blockCount_Regs_DATA;\n        multiple_data <= multipleData_Regs_DATA;\n        writeReadPhysical_DATA_Phy <= writeRead_Regs_DATA;\n        blocks_DATA_Phy <= blockCount_Regs_DATA;\n        idle_out_DATA_Phy <= 1'b0;\n        strobe_OUT_DATA_Phy <= 1'b1;\n        multiple_DATA_Phy <= 1'b1;\n      end\n      if (ack_IN_Phy_DATA && !timeout_enable && !transfer_complete_DATA_DMA) begin\n        if (block_count == 0) begin\n          transfer_complete_DATA_DMA <= 1'b1;\n          idle_out_DATA_Phy <= 1'b1;\n        end else begin\n          block_count <= block_count - 1;\n          blocks_DATA_Phy <= block_count - 1;\n          strobe_OUT_DATA_Phy <= 1'b1;\n        end\n        multiple_DATA_Phy <= 1'b0;\n      end\n      if (fifo_OK_FIFO_DATA && !timeout_enable && !transfer_complete_DATA_DMA) begin\n        ack_OUT_DATA_Phy <= 1'b1;\n      end\n      if (transfer_complete_DATA_DMA) begin\n        complete_Phy_DATA <= 1'b1;\n      end\n      timeout_value_DATA_Phy <= timeout_counter;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "byte_reverse_a3284e11", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule byte_reverse (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n\nmodule top_module (\n    input [31:0] in,\n    input [2:0] sel, \n    input [7:0] data0,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    input [7:0] data4,\n    input [7:0] data5,\n    output [7:0] out\n);\n\n    wire [31:0] reversed_in;\n    byte_reverse byte_reverse_inst (\n        .in(in),\n        .out(reversed_in)\n    );\n\n    wire [7:0] and_output;\n    assign and_output = data0[1:0] & data1[1:0] & data2[1:0] & data3[1:0] & data4[1:0] & data5[1:0];\n\n    wire [7:0] mux_output;\n    assign mux_output = (sel == 0) ? data0 :\n                        (sel == 1) ? data1 :\n                        (sel == 2) ? data2 :\n                        (sel == 3) ? data3 :\n                        (sel == 4) ? data4 :\n                        (sel == 5) ? data5 :\n                        (sel == 6 || sel == 7) ? and_output :\n                        8'b0;\n\n    wire [7:0] add_output;\n    assign add_output = reversed_in[7:0] + mux_output;\n\n    assign out = add_output;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_div_e797b0b4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clk_div(\n\tinput wire clk,\n\tinput wire rst,\n\tinput wire SW2,\n\toutput reg [31:0] clkdiv,\n\toutput wire Clk_CPU\n);\n\n\tinitial clkdiv <= 0;\n\talways @ (posedge clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\tclkdiv <= 0;\n\t\tend else begin\n\t\t\tclkdiv <= clkdiv + 1'b1;\n\t\tend\n\tend\n\tassign Clk_CPU = SW2 ? clkdiv[22] : clkdiv[1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__a41oi_5ce3d454", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__a41oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2, A3, A4 );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__5da720a9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input [31:0] in,\n    output [15:0] q,\n    output [3:0] ena\n);\n\nwire [31:0] transition_detected;\nwire [15:0] bcd_counter;\n\n// Detect 1 to 0 transitions\ntransition_detector td (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(transition_detected)\n);\n\n// BCD counter\nbcd_counter bc (\n    .clk(clk),\n    .reset(reset),\n    .ena(ena[3]),\n    .out(bcd_counter)\n);\n\n// Max value selector\nmax_value_selector mvs (\n    .in1(transition_detected),\n    .in2(bcd_counter),\n    .out(q)\n);\n\nassign ena = 4'b0; // Fix the undriven wires\n\nendmodule\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nreg [31:0] in_prev;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        in_prev <= 32'b0;\n    end else begin\n        in_prev <= in;\n    end\nend\n\nassign out = in_prev & ~in;\n\nendmodule\nmodule bcd_counter (\n    input clk,\n    input reset,\n    input ena,\n    output [15:0] out\n);\n\nreg [15:0] count;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 16'b0;\n    end else if (ena) begin\n        count <= count + 1'b1;\n        if (count == 16'h9999) begin\n            count <= 16'b0;\n        end\n    end\nend\n\nassign out = count;\n\nendmodule\nmodule max_value_selector (\n    input [31:0] in1,\n    input [15:0] in2,\n    output [15:0] out\n);\n\nassign out = (in1 > in2) ? in1[15:0] : in2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "expand_message_36ddb5c6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule expand_message (\n\tinput clk,\n\tinput [56-1:0] rx_fixed_data,\n\tinput [59:0] rx_nonce,\n\toutput reg [511:0] tx_expanded_message\n);\n\n\tparameter IDX_0 = 56'd0;\n\tparameter IDX_1 = 56'd1;\n\tparameter IDX_2 = 56'd2;\n\tparameter IDX_3 = 56'd3;\n\tparameter IDX_4 = 56'd4;\n\tparameter IDX_5 = 56'd5;\n\tparameter IDX_6 = 56'd6;\n\n\tparameter IDX4_0 = 60'd0;\n\tparameter IDX4_1 = 60'd1;\n\tparameter IDX4_2 = 60'd2;\n\tparameter IDX4_3 = 60'd3;\n\tparameter IDX4_4 = 60'd4;\n\tparameter IDX4_5 = 60'd5;\n\tparameter IDX4_6 = 60'd6;\n\tparameter IDX4_7 = 60'd7;\n\tparameter IDX4_8 = 60'd8;\n\tparameter IDX4_9 = 60'd9;\n\tparameter IDX4_10 = 60'd10;\n\tparameter IDX4_11 = 60'd11;\n\tparameter IDX4_12 = 60'd12;\n\tparameter IDX4_13 = 60'd13;\n\tparameter IDX4_14 = 60'd14;\n\n\talways @ (posedge clk)\n\tbegin\n\t\ttx_expanded_message <= {32'd192, 32'h0, 224'h0, 32'h80000000, rx_fixed_data[IDX_2], rx_fixed_data[IDX_1], rx_fixed_data[IDX_0], 8'h00, rx_fixed_data[IDX_6], rx_fixed_data[IDX_5], rx_fixed_data[IDX_4], rx_fixed_data[IDX_3], {4'b0,rx_nonce[IDX4_2]}, {4'b0,rx_nonce[IDX4_1]}, {4'b0,rx_nonce[IDX4_0]}, 8'h00, {4'b0,rx_nonce[IDX4_6]}, {4'b0,rx_nonce[IDX4_5]}, {4'b0,rx_nonce[IDX4_4]}, {4'b0,rx_nonce[IDX4_3]}, {4'b0,rx_nonce[IDX4_10]}, {4'b0,rx_nonce[IDX4_9]}, {4'b0,rx_nonce[IDX4_8]}, {4'b0,rx_nonce[IDX4_7]}, {4'b0,rx_nonce[IDX4_14]}, {4'b0,rx_nonce[IDX4_13]}, {4'b0,rx_nonce[IDX4_12]}, {4'b0,rx_nonce[IDX4_11]}};\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__dd7cccb8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module (\n   input in,\n   input clk,\n   output reg fr_a,\n   output reg fr_b,\n   output reg fr_chk\n   );\n\n   always @(posedge clk) begin\n      fr_a <= in;\n      fr_b <= in;\n      fr_chk <= in + 1;\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_checker_6747afaf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule parity_checker (\n  input clk,\n  input [3:0] data,\n  output reg parity\n);\n\n  reg [1:0] stage1_data [0:1];\n  wire [1:0] stage2_data [0:1];\n  \n  always @ (posedge clk) begin\n    stage1_data[1] <= stage1_data[0];\n    stage1_data[0] <= data;\n  end\n  \n  assign stage2_data[1] = stage1_data[1] ^ stage1_data[0];\n  assign stage2_data[0] = 2'b00;\n  \n  always @ (posedge clk) begin\n    parity <= stage2_data[1][0] ^ stage2_data[1][1];\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_nand_ceb83d7b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule xor_nand (\n    input a,\n    input b,\n    output out\n);\n\n    wire nand1;\n\n    assign nand1 = ~(a & b);\n    assign out = ~nand1;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "td_mode__3f2039b4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule td_mode_module (\n  input [8:0] ctrl,\n  output reg [3:0] td_mode\n);\n\n  wire [2:0] ctrl_bits_for_mux;\n  assign ctrl_bits_for_mux = ctrl[7:5];\n\n  always @(*) begin\n    case (ctrl_bits_for_mux)\n      3'b000: td_mode = 4'b0000;\n      3'b001: td_mode = 4'b1000;\n      3'b010: td_mode = 4'b0100;\n      3'b011: td_mode = 4'b1100;\n      3'b100: td_mode = 4'b0010;\n      3'b101: td_mode = 4'b1010;\n      3'b110: td_mode = 4'b0101;\n      3'b111: td_mode = 4'b1111;\n    endcase\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "altera_mem_if_ddr3_phy_0001_hr_to_fr_9663c9fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule altera_mem_if_ddr3_phy_0001_hr_to_fr(\n    clk,\n    d_h0,\n    d_h1,\n    d_l0,\n    d_l1,\n    q0,\n    q1\n);\n\ninput   clk;\ninput   d_h0;\ninput   d_h1;\ninput   d_l0;\ninput   d_l1;\noutput  q0;\noutput  q1;\n\nreg q_h0;\nreg q_h1;\nreg q_l0;\nreg q_l1;\nreg q_l0_neg;\nreg q_l1_neg;\n\nalways @(posedge clk)\nbegin\n    q_h0 <= d_h0;\n    q_l0 <= d_l0;\n    q_h1 <= d_h1;\n    q_l1 <= d_l1;\nend\n\nalways @(negedge clk)\nbegin\n    q_l0_neg <= ~q_l0;\n    q_l1_neg <= ~q_l1;\nend\n\nassign q0 = clk ? q_l0_neg : q_h0;\nassign q1 = clk ? q_l1_neg : q_h1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sequencer_3c58b7f8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule sequencer\n  (\n   input \t\t  clock,\n   input \t\t  reset,\n   output \t\t  fpc_read,\n   input \t\t  fpc_valid,\n   input [63:0] \t  fpc_data,\n   input \t\t  tpc_ready,\n   output \t\t  tpc_write,\n   output [63:0] \t  tpc_data,\n   output reg \t\t  rvalid = 0,\n   output reg \t\t  wvalid = 0,\n   output reg [ABITS-1:0] address = 0,\n   output reg [DBITS-1:0] wdata = 0,\n   input [DBITS-1:0] \t  rdata,\n   input [SBITS-1:0] \t  status\n   );\n\n   parameter RPIPE = 2; parameter ABITS = 16; parameter DBITS = 64; parameter SBITS = 16; parameter CBITS = 24; reg [CBITS-1:0] \t  count = 32'hDEADBEEF;\n   reg [1:0] \t\t  state = 0;\n   reg \t\t\t  inc = 0;\n\n   wire \t\t  rvalid_next = (state == 3) && tpc_ready;\n   wire \t\t  wvalid_next = (state == 2) && fpc_read;\n\n   assign fpc_read = fpc_valid && ((state == 0) || (state == 2));\n\n   always @ (posedge clock)\n     begin\n\trvalid <= rvalid_next;\n\twvalid <= wvalid_next;\n\taddress <= (state == 0) ? fpc_data[ABITS-1:0] :\n\t\t   address + (inc && (rvalid || wvalid));\n\twdata <= fpc_data[DBITS-1:0];\n\tinc <= (state == 0) ? fpc_data[61] : inc;\n\tcase(state)\n\t  0: count <= fpc_data[CBITS+31:32];\n\t  1: count <= count - 1'b1;\n\t  2: count <= count - wvalid_next;\n\t  3: count <= count - rvalid_next;\n\tendcase\n\tif(reset)\n\t  state <= 2'd0;\n\telse\n\t  begin\n\t     case(state)\n\t       0: state <= fpc_read ? fpc_data[63:62] : 2'd0; default: state <= (count[CBITS-1:1] == 0) ? 2'd0 : state;\n\t     endcase\n\t  end\n     end\n   delay_n #(.N(RPIPE)) delay_tpc_write\n     (.clock(clock), .in(rvalid), .out(tpc_write));\n   assign tpc_data = rdata;\n\nendmodule\n\nmodule delay_n\n  (\n   input  clock,\n   input  in,\n   output out\n   );\n\n   parameter N = 2;\n\n   reg [N-1:0] sreg = 0;\n\n   assign out = sreg[N-1];\n\n   always @ (posedge clock)\n     sreg <= {sreg[N-2:0],in};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_code_counter_83b8baed", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gray_code_counter (\n    input CLK,\n    input RST,\n    output reg [7:0] count_gray\n);\n\n    reg [7:0] count_binary;\n    \n    always @(posedge CLK or negedge RST) begin\n        if (RST == 0) begin\n            count_binary <= 8'b00000000;\n            count_gray <= 8'b00000000;\n        end\n        else begin\n            count_binary <= count_binary + 1;\n            count_gray <= count_binary ^ (count_binary >> 1);\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_preset_clear_d93572bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dff_preset_clear (\n    input wire D,\n    input wire CLK,\n    input wire PRE,  // Preset\n    input wire CLR,  // Clear\n    output wire Q,\n    output wire Q_N\n);\n\n    reg [0:0] _Q;\n    assign Q = _Q[0];\n    assign Q_N = ~_Q[0];\n\n    always @(posedge CLK) begin\n        if (CLR) begin // Clear\n            _Q[0] <= 0;\n        end else if (PRE) begin // Preset\n            _Q[0] <= 1;\n        end else begin // Normal Operation\n            _Q[0] <= D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_latch_with_reset_a9ef4b04", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_latch_with_reset(\n    input CLK,\n    input RST,\n    input D,\n    output reg Q\n);\n\nalways @(posedge CLK) begin\n    if (RST == 1) begin\n        Q <= 0;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "freq_divider_0cee4d79", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule freq_divider (\n  input clk_in,\n  output reg clk_out\n);\n\n  parameter n = 2; // division factor\n  \n  reg [31:0] count;\n  \n  always @(posedge clk_in) begin\n    if (count == n-1) begin\n      clk_out <= ~clk_out;\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AND4_51a046bb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule AND4(out1, in1, in2, in3, in4);\n\n  parameter gate_delay = 1; // Define gate delay parameter\n\n  input in1, in2, in3, in4;\n  output out1;\n\n  wire and1, and2;\n\n  and #(gate_delay) and1 (and2, in1, in2);\n  and #(gate_delay) and2 (out1, and2, in3, in4);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__nand4b_c8ee56c6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__nand4b (\n    Y  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N              );\n    nand nand0 (nand0_out_Y, D, C, B, not0_out);\n    buf  buf0  (Y          , nand0_out_Y      );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "selector_module_89524ceb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule selector_module(\n    input [1:0] SEL,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] OUT\n);\n\n    wire [7:0] sum, diff, prod, quo;\n    \n    assign sum = A + B;\n    assign diff = A - B;\n    assign prod = A * B;\n    assign quo = A / B;\n    \n    always @* begin\n        case (SEL)\n            2'b00: OUT = sum;\n            2'b01: OUT = diff;\n            2'b10: OUT = prod;\n            2'b11: OUT = quo;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "karnaugh_map_bf0d6f7b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule karnaugh_map(\n  input wire A, B, C,\n  output reg F\n);\n\n  always @(*) begin\n    case ({A,B,C})\n      3'b000: F = 1'b0;\n      3'b001: F = 1'b1;\n      3'b010: F = 1'b1;\n      3'b011: F = 1'b0;\n      3'b100: F = 1'b1;\n      3'b101: F = 1'b0;\n      3'b110: F = 1'b0;\n      3'b111: F = 1'b1;\n      default: F = 1'b0;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__a31oi_9694d61d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__a31oi (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2     );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flt_frac_test_1d3431aa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule flt_frac_test\n\t(\n\tinput\t      \tclk,\n\tinput\t      \trstn,\n\tinput\t[31:0]\tafl,\n\toutput reg\tfrac_flag\n\t);\n\n\treg [47:0]\tmant;\n\talways @* begin\n\t\tif(afl[30]) mant = {1'b1, afl[22:0]} << (afl[30:23] - 127);\n\t\telse        mant = {1'b1, afl[22:0]} >> (127 - afl[30:23]);\n\tend\n\n\talways @(posedge clk, negedge rstn) begin\n\t\tif(!rstn) frac_flag <= 1'b0;\n\t\telse begin\n\t\t\tif(|mant[23:0]) frac_flag <= 1'b1;\n\t\t\telse frac_flag <= 1'b0;\n\t\t\t\n\t\t\t\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "arbitro_88b74814", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule arbitro (\n\n  input wire [2:0] pe_request_bundle,\n    input wire [2:0] north_request_bundle,\n    input wire [2:0] east_request_bundle,\n\noutput reg [1:0] pe_cfg_bundle,\n    output reg [2:0] south_cfg_bundle,\n    output reg [2:0] west_cfg_bundle,\n\noutput reg      r2pe_ack\n  );\n\nlocalparam  MUX_EAST  = 3'b111;\n  localparam  MUX_NORTH = 3'b101;\n  localparam  MUX_PE    = 3'b001;\n  localparam  MUX_NULL  = 3'b000;\n  localparam  PE_NULL   = 2'b00;\n\nwire [2:0] request_vector;\n\n  assign request_vector = {east_request_bundle[0], north_request_bundle[0], pe_request_bundle[0]};\n\nalways @(*)\n  begin\n\n  west_cfg_bundle  = MUX_NULL;\n  south_cfg_bundle = MUX_NULL;\n  pe_cfg_bundle    = PE_NULL;\n\n  r2pe_ack         = 1'b0;\n\n    case (request_vector)\n      3'b000: begin\n          end\n\n\n      3'b001: begin\n          r2pe_ack = 1'b1;\n          case (pe_request_bundle[2:1])\n            2'b00:  west_cfg_bundle  = MUX_PE;    2'b01:  west_cfg_bundle  = MUX_PE;    2'b10:  south_cfg_bundle = MUX_PE;    2'b11:\n              begin\n                r2pe_ack = 1'b0;\n                south_cfg_bundle = MUX_NULL;  end\n          endcase\n        end\n\n\n      3'b010: case (north_request_bundle[2:1])\n          2'b00:  west_cfg_bundle  = MUX_NORTH; 2'b01:  west_cfg_bundle  = MUX_NORTH; 2'b10:  south_cfg_bundle = MUX_NORTH; 2'b11:  pe_cfg_bundle    = 2'b01;     endcase\n\n\n      3'b011: begin\n          r2pe_ack = 1'b1;\n          case (north_request_bundle[2:1])\n              2'b00:\n                begin\n                  west_cfg_bundle  = MUX_NORTH; south_cfg_bundle = MUX_PE;    end\n            2'b01:\n              begin\n                west_cfg_bundle  = MUX_NORTH; south_cfg_bundle = MUX_PE;    end\n            2'b10:\n              begin\n                south_cfg_bundle = MUX_NORTH; west_cfg_bundle  = MUX_PE;    end\n            2'b11:\n              begin\n                west_cfg_bundle = MUX_PE;    pe_cfg_bundle   = 2'b01;     end\n          endcase\n        end\n\n\n      3'b100: case (east_request_bundle[2:1])\n          2'b00:  west_cfg_bundle  = MUX_EAST; 2'b01:  west_cfg_bundle  = MUX_EAST; 2'b10:  south_cfg_bundle = MUX_EAST; 2'b11:  pe_cfg_bundle    = 2'b11;  endcase\n\n\n      3'b101: begin\n          r2pe_ack = 1'b1;\n          case (east_request_bundle[2:1])\n            2'b00:\n              begin\n                west_cfg_bundle  = MUX_EAST; south_cfg_bundle = MUX_PE;   end\n\n            2'b01:\n              begin\n                west_cfg_bundle  = MUX_EAST; south_cfg_bundle = MUX_PE;   end\n            2'b10:\n              begin\n                south_cfg_bundle = MUX_EAST; west_cfg_bundle  = MUX_PE;   end\n            2'b11:\n              begin\n                west_cfg_bundle = MUX_PE;  pe_cfg_bundle   = 2'b11;   end\n          endcase\n        end\n\n\n      3'b110: case (east_request_bundle[2:1])\n          2'b00:\n            begin\n              west_cfg_bundle  = MUX_EAST;  south_cfg_bundle = MUX_NORTH; end\n\n          2'b01:\n            begin\n              west_cfg_bundle  = MUX_EAST;  south_cfg_bundle = MUX_NORTH; end\n          2'b10:\n            begin\n              south_cfg_bundle = MUX_EAST;  west_cfg_bundle  = MUX_NORTH; end\n          2'b11:\n            begin\n              west_cfg_bundle  = MUX_NORTH; pe_cfg_bundle   = 2'b11;      end\n        endcase\n\n\n      3'b111: case (east_request_bundle[2:1])\n          2'b00:\n            begin\n              west_cfg_bundle  = MUX_EAST;  south_cfg_bundle = MUX_NORTH; end\n\n          2'b01:\n            begin\n              west_cfg_bundle  = MUX_EAST;  if (north_request_bundle[2:1] == 2'b11)\n                begin\n                  south_cfg_bundle  = MUX_PE; pe_cfg_bundle     = 2'b01;  r2pe_ack          = 1'b1;\n                end\n              else\n                  south_cfg_bundle = MUX_NORTH; end\n          2'b10:\n            begin\n              west_cfg_bundle  = MUX_NORTH; if (north_request_bundle[2:1] == 2'b11)\n                begin\n                  west_cfg_bundle = MUX_PE; pe_cfg_bundle   = 2'b01;  r2pe_ack        = 1'b1;\n                end\n              else\n                south_cfg_bundle = MUX_EAST;  end\n          2'b11:\n            begin\n              if (north_request_bundle[2:1] == 2'b01)\n                begin\n                  west_cfg_bundle  = MUX_NORTH; south_cfg_bundle = MUX_PE;    end\n              else\n                begin\n                  west_cfg_bundle  = MUX_PE;    south_cfg_bundle = MUX_NORTH;  end\n              pe_cfg_bundle   = 2'b11;      r2pe_ack        = 1'b1;\n            end\n        endcase\n\n\n    endcase end endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor4_5e864d61", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule nor4 (\n    A,\n    B,\n    C,\n    D,\n    Y\n);\n\n    input A, B, C, D;\n    output Y;\n\n    wire temp1, temp2;\n\n    // First NOR gate\n    nor_gate nor1 (\n        .Y(temp1),\n        .A(A),\n        .B(B)\n    );\n\n    // Second NOR gate\n    nor_gate nor2 (\n        .Y(temp2),\n        .A(C),\n        .B(D)\n    );\n\n    // Final NOR gate\n    nor_gate nor3 (\n        .Y(Y),\n        .A(temp1),\n        .B(temp2)\n    );\n\nendmodule\n\nmodule nor_gate (\n    Y,\n    A,\n    B\n);\n\n    input A, B;\n    output Y;\n\n    assign Y = ~(A | B);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_fwft_adapter #_dbe67983", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo_fwft_adapter # (\n\tparameter DATA_WIDTH = 0\n) (\n\tinput  wire                  clk,\n\tinput  wire                  rst,\n\tinput  wire                  rd_en,\n\tinput  wire                  fifo_empty,\n\toutput wire                  fifo_rd_en,\n\tinput  wire [DATA_WIDTH-1:0] fifo_dout,\n\toutput reg  [DATA_WIDTH-1:0] dout,\n\toutput wire                  empty,\n\toutput wire                  valid\n);\n\n\treg \t\t     fifo_valid, middle_valid, dout_valid;\n\treg [DATA_WIDTH-1:0] middle_dout;\n\treg [DATA_WIDTH-1:0] last_dout;\n\n\tassign fifo_rd_en = (!fifo_empty) && !(middle_valid && dout_valid && fifo_valid);\n\tassign empty      = !dout_valid;\n\tassign valid      = dout_valid;\n\n\twire next_dout;\n\tassign next_dout = (rd_en || !dout_valid);\n\n\talways @(posedge clk) begin\n\t\tif (rst) begin\n\t\t\tfifo_valid   <= 0;\n\t\t\tmiddle_valid <= 0;\n\t\t\tmiddle_dout  <= 0;\n\t\t\tdout_valid   <= 0;\n\t\t\tdout         <= 0;\n\t\t\tlast_dout    <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (fifo_rd_en)\n\t\t\t\tfifo_valid <= 1;\n\t\t\telse if (!middle_valid || next_dout)\n\t\t\t\tfifo_valid <= 0;\n\n\t\t\tif (middle_valid == next_dout) begin\n\t\t\t\tmiddle_valid <= fifo_valid;\n\t\t\t\tmiddle_dout  <= fifo_dout;\n\t\t\tend\n\n\t\t\tif (next_dout) begin\n\t\t\t\tdout_valid <= (fifo_valid || middle_valid);\n\t\t\t\tif (fifo_valid) begin\n\t\t\t\t\tdout <= fifo_dout;\n\t\t\t\t\tlast_dout <= fifo_dout;\n\t\t\t\tend\n\t\t\t\telse if (middle_valid) begin\n\t\t\t\t\tdout <= middle_dout;\n\t\t\t\t\tlast_dout <= middle_dout;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tif (!dout_valid)\n\t\t\tdout <= last_dout;\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
