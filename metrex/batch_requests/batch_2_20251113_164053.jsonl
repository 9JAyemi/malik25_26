{"custom_id": "MMU_MATCH_38b1f4e9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MMU_MATCH (\n    input USER,\n    input READ,\n    input WRITE,\n    input RMW,\n    input [2:0] MCR_FLAGS,\n    input [31:0] MVALID,\n    input [31:12] VADR_R,\n    input [31:16] MMU_VA,\n    input [1:0] IVAR,\n    output VIRTUELL,\n    output MMU_HIT,\n    output [31:0] UPDATE,\n    output reg PROT_ERROR,\n    output CI,\n    output SEL_PTB1\n);\n\nreg [15:0] maske;\nwire adr_space, as_sorte, match, alles_ok;\nwire [15:0] val_bits, as_bits;\nwire ena_prot;\nwire zugriff;\n\nassign zugriff = READ | WRITE;\n\nalways @(VADR_R) begin\n    case (VADR_R[15:12])\n        4'h0 : maske = 16'h0001;\n        4'h1 : maske = 16'h0002;\n        4'h2 : maske = 16'h0004;\n        4'h3 : maske = 16'h0008;\n        4'h4 : maske = 16'h0010;\n        4'h5 : maske = 16'h0020;\n        4'h6 : maske = 16'h0040;\n        4'h7 : maske = 16'h0080;\n        4'h8 : maske = 16'h0100;\n        4'h9 : maske = 16'h0200;\n        4'hA : maske = 16'h0400;\n        4'hB : maske = 16'h0800;\n        4'hC : maske = 16'h1000;\n        4'hD : maske = 16'h2000;\n        4'hE : maske = 16'h4000;\n        4'hF : maske = 16'h8000;\n    endcase\nend\n\nassign VIRTUELL = USER ? MCR_FLAGS[0] : MCR_FLAGS[1];\n\nassign adr_space = IVAR[1] ? IVAR[0] : (MCR_FLAGS[2] & USER);\n\nassign as_sorte = ((MVALID[31:16] & maske) != 16'h0);\n\nassign match = (VADR_R[31:20] == MMU_VA[31:20]) & (adr_space == as_sorte) & ((MVALID[15:0] & maske) != 16'h0000);\n\nassign alles_ok = match & (~WRITE | MMU_VA[17]) & ~PROT_ERROR;\n\nassign MMU_HIT = zugriff ? (VIRTUELL ? alles_ok : 1'b1) : 1'b0;\n\nassign val_bits = IVAR[1] ? (MVALID[15:0] & (match ? ~maske : 16'hFFFF)) : (MVALID[15:0] | maske);\nassign as_bits = IVAR[1] ? MVALID[31:16] : (adr_space ? (MVALID[31:16] | maske) : (MVALID[31:16] & ~maske));\n\nassign UPDATE = {as_bits, val_bits};\n\nassign ena_prot = zugriff & VIRTUELL & match;\n\nalways @(ena_prot or MMU_VA or USER or WRITE or RMW) begin\n    case ({ena_prot, MMU_VA[19:18]})\n        3'b100 : PROT_ERROR = USER | WRITE | RMW;\n        3'b101 : PROT_ERROR = USER;\n        3'b110 : PROT_ERROR = USER & (WRITE | RMW);\n        default : PROT_ERROR = 1'b0;\n    endcase\nend\n\nassign CI = VIRTUELL & MMU_VA[16];\nassign SEL_PTB1 = adr_space;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "single_port_ram_59e901cb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule single_port_ram (\n  input wire clk,\n  input wire en,\n  input wire we,\n  input wire [10:0] addr,\n  input wire [7:0] din,\n  output reg [7:0] dout\n);\n\n  reg [7:0] ram [0:2047]; // 2^11 bytes\n\n  always @(posedge clk) begin\n    if (en) begin\n      if (we) begin\n        ram[addr] <= din;\n      end\n      else begin\n        dout <= ram[addr];\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_a8dffda8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n    input clk,\n    input [3:0] reset,\n    input [3:0] load,\n    input [3:0] increment,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset == 4'b1111) begin\n        count <= 4'b0000;\n    end else if (load != 4'b0000) begin\n        count <= load;\n    end else begin\n        count <= count + increment;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_case_fdeb8785", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_4to1_case (\n    input A, B, C, D,\n    input [1:0] sel,\n    output reg Y\n);\n\n    always @(*) begin\n        case(sel)\n            2'b00: Y = A;\n            2'b01: Y = B;\n            2'b10: Y = C;\n            2'b11: Y = D;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "voltage_supply_3b5a8098", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule voltage_supply (\n  input clk,\n  input rst,\n  input enable,\n  output reg VPWR,\n  output reg VGND,\n  output reg VPB,\n  output reg VNB\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      VPB <= 0;\n      VNB <= 0;\n    end else if (enable) begin\n      VPB <= #2 ~VPB;\n      VNB <= 0;\n    end else begin\n      VPB <= 0;\n      VNB <= 0;\n    end\n  end\n\n  initial begin\n    VPWR = 1;\n    VGND = 0;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__o221ai_6842084d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axis_gate_controller_acb14327", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule axis_gate_controller\n(\n  input  wire         aclk,\n  input  wire         aresetn,\n\n  output wire         s_axis_tready,\n  input  wire [127:0] s_axis_tdata,\n  input  wire         s_axis_tvalid,\n\n  output wire [31:0]  poff,\n  output wire [15:0]  level,\n  output wire         dout\n);\n\n  reg int_tready_reg, int_tready_next;\n  reg int_dout_reg, int_dout_next;\n  reg int_enbl_reg, int_enbl_next;\n  reg [63:0] int_cntr_reg, int_cntr_next;\n  reg [127:0] int_data_reg, int_data_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_tready_reg <= 1'b0;\n      int_dout_reg <= 1'b0;\n      int_enbl_reg <= 1'b0;\n      int_cntr_reg <= 64'd0;\n      int_data_reg <= 128'd0;\n    end\n    else\n    begin\n      int_tready_reg <= int_tready_next;\n      int_dout_reg <= int_dout_next;\n      int_enbl_reg <= int_enbl_next;\n      int_cntr_reg <= int_cntr_next;\n      int_data_reg <= int_data_next;\n    end\n  end\n\n  always @*\n  begin\n    int_tready_next = int_tready_reg;\n    int_dout_next = int_dout_reg;\n    int_enbl_next = int_enbl_reg;\n    int_cntr_next = int_cntr_reg;\n    int_data_next = int_data_reg;\n\n    if(~int_enbl_reg & s_axis_tvalid)\n    begin\n      int_tready_next = 1'b1;\n      int_enbl_next = 1'b1;\n      int_cntr_next = 64'd0;\n      int_data_next = s_axis_tdata;\n    end\n\n    if(int_enbl_reg)\n    begin\n      int_cntr_next = int_cntr_reg + 1'b1;\n\n      if(int_cntr_reg == 64'd0)\n      begin\n        int_dout_next = |int_data_reg[111:96];\n      end\n\n      if(int_cntr_reg == int_data_reg[63:0])\n      begin\n        int_dout_next = 1'b0;\n        int_enbl_next = 1'b0;\n      end\n    end\n\n    if(int_tready_reg)\n    begin\n      int_tready_next = 1'b0;\n    end\n  end\n\n  assign s_axis_tready = int_tready_reg;\n  assign poff = int_data_reg[95:64];\n  assign level = int_data_reg[111:96];\n  assign dout = int_dout_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "seven_segment_display_0e3d452c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule seven_segment_display\n(\n  input clk,\n  input [15:0]num_in,\n  output reg [6:0]dig,\n  output reg dp,\n  output reg neg,\n  output reg clr,\n  output reg [3:0]dig_sel\n);\n\nreg [6:0]dig1;\nreg [6:0]dig2;\nreg [6:0]dig3;\nreg [6:0]dig4;\n\nreg [19:0] clk_div;\n\nalways @(posedge clk) begin\n  clk_div = clk_div + 1;\nend\n\nalways @(posedge clk) begin\n  if (clk_div == 0)\n  begin\n    if(dig_sel == 0)\n      dig_sel <= 1;\n    else\n      dig_sel <= {dig_sel[0],dig_sel[3:1]};\n\n    case(dig_sel)\n      4'b0010: dig <= dig4;\n      4'b0100: dig <= dig3;\n      4'b1000: dig <= dig2;\n      4'b0001: dig <= dig1;\n    endcase\n  end\nend\n\nalways @(posedge clk) begin\n  case(num_in[3:0])\n    4'b0000: dig1 = 7'b1000000; //0\n    4'b0001: dig1 = 7'b1111001; //1\n    4'b0010: dig1 = 7'b0100100; //2\n    4'b0011: dig1 = 7'b0110000; //3\n    4'b0100: dig1 = 7'b0011001; //4\n    4'b0101: dig1 = 7'b0010010; //5\n    4'b0110: dig1 = 7'b0000010; //6\n    4'b0111: dig1 = 7'b1111000; //7\n    4'b1000: dig1 = 7'b0000000; //8\n    4'b1001: dig1 = 7'b0010000; //9\n    4'b1010: dig1 = 7'b0001000; //A\n    4'b1011: dig1 = 7'b0000011; //b\n    4'b1100: dig1 = 7'b1000110; //C\n    4'b1101: dig1 = 7'b0100001; //d\n    4'b1110: dig1 = 7'b0000110; //E\n    4'b1111: dig1 = 7'b0001110; //F\n  endcase\n  case(num_in[7:4])\n    4'b0000: dig2 = 7'b1000000; //0\n    4'b0001: dig2 = 7'b1111001; //1\n    4'b0010: dig2 = 7'b0100100; //2\n    4'b0011: dig2 = 7'b0110000; //3\n    4'b0100: dig2 = 7'b0011001; //4\n    4'b0101: dig2 = 7'b0010010; //5\n    4'b0110: dig2 = 7'b0000010; //6\n    4'b0111: dig2 = 7'b1111000; //7\n    4'b1000: dig2 = 7'b0000000; //8\n    4'b1001: dig2 = 7'b0010000; //9\n    4'b1010: dig2 = 7'b0001000; //A\n    4'b1011: dig2 = 7'b0000011; //b\n    4'b1100: dig2 = 7'b1000110; //C\n    4'b1101: dig2 = 7'b0100001; //d\n    4'b1110: dig2 = 7'b0000110; //E\n    4'b1111: dig2 = 7'b0001110; //F\n  endcase\n  case(num_in[11:8])\n    4'b0000: dig3 = 7'b1000000; //0\n    4'b0001: dig3 = 7'b1111001; //1\n    4'b0010: dig3 = 7'b0100100; //2\n    4'b0011: dig3 = 7'b0110000; //3\n    4'b0100: dig3 = 7'b0011001; //4\n    4'b0101: dig3 = 7'b0010010; //5\n    4'b0110: dig3 = 7'b0000010; //6\n    4'b0111: dig3 = 7'b1111000; //7\n    4'b1000: dig3 = 7'b0000000; //8\n    4'b1001: dig3 = 7'b0010000; //9\n    4'b1010: dig3 = 7'b0001000; //A\n    4'b1011: dig3 = 7'b0000011; //b\n    4'b1100: dig3 = 7'b1000110; //C\n    4'b1101: dig3 = 7'b0100001; //d\n    4'b1110: dig3 = 7'b0000110; //E\n    4'b1111: dig3 = 7'b0001110; //F\n  endcase\n  case(num_in[15:12])\n    4'b0000: dig4 = 7'b1000000; //0\n    4'b0001: dig4 = 7'b1111001; //1\n    4'b0010: dig4 = 7'b0100100; //2\n    4'b0011: dig4 = 7'b0110000; //3\n    4'b0100: dig4 = 7'b0011001; //4\n    4'b0101: dig4 = 7'b0010010; //5\n    4'b0110: dig4 = 7'b0000010; //6\n    4'b0111: dig4 = 7'b1111000; //7\n    4'b1000: dig4 = 7'b0000000; //8\n    4'b1001: dig4 = 7'b0010000; //9\n    4'b1010: dig4 = 7'b0001000; //A\n    4'b1011: dig4 = 7'b0000011; //b\n    4'b1100: dig4 = 7'b1000110; //C\n    4'b1101: dig4 = 7'b0100001; //d\n    4'b1110: dig4 = 7'b0000110; //E\n    4'b1111: dig4 = 7'b0001110; //F\n  endcase\nend\n\nalways @(posedge clk) begin\n  dp <= 0;\n  neg <= 0;\n  clr <= 0;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_7x_0_core_top_qpll_reset #_8a868e8a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\n\nmodule pcie_7x_0_core_top_qpll_reset #\n(\n\n    parameter PCIE_PLL_SEL       = \"CPLL\",                  parameter PCIE_POWER_SAVING  = \"TRUE\",                  parameter PCIE_LANE          = 1,                       parameter BYPASS_COARSE_OVRD = 1                        )\n\n(\n\n    input                           QRST_CLK,\n    input                           QRST_RST_N,\n    input                           QRST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     QRST_CPLLLOCK,\n    input       [(PCIE_LANE-1)>>2:0]QRST_DRP_DONE,\n    input       [(PCIE_LANE-1)>>2:0]QRST_QPLLLOCK,\n    input       [ 1:0]              QRST_RATE,\n    input       [PCIE_LANE-1:0]     QRST_QPLLRESET_IN,\n    input       [PCIE_LANE-1:0]     QRST_QPLLPD_IN,\n    \n    output                          QRST_OVRD,\n    output                          QRST_DRP_START,\n    output                          QRST_QPLLRESET_OUT,\n    output                          QRST_QPLLPD_OUT,\n    output                          QRST_IDLE,\n    output      [3:0]               QRST_FSM\n\n);\n\n        reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     cplllock_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg1;\n    reg         [ 1:0]              rate_reg1;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg1;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg1;\n\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     cplllock_reg2;  \n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg2;\n    reg         [ 1:0]              rate_reg2;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg2;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg2;\n    \n    reg                             ovrd              =  1'd0;\n    reg                             qpllreset         =  1'd1;\n    reg                             qpllpd            =  1'd0;\n    reg         [3:0]               fsm               =  2;                 \n   \n    localparam                      FSM_IDLE          = 1;localparam                      FSM_WAIT_LOCK     = 2;localparam                      FSM_MMCM_LOCK     = 3;localparam                      FSM_DRP_START_NOM = 4;localparam                      FSM_DRP_DONE_NOM  = 5;localparam                      FSM_QPLLLOCK      = 6;localparam                      FSM_DRP_START_OPT = 7;localparam                      FSM_DRP_DONE_OPT  = 8;localparam                      FSM_QPLL_RESET    = 9;localparam                      FSM_QPLLLOCK2     = 10;localparam                      FSM_QPLL_PDRESET  = 11;localparam                      FSM_QPLL_PD       = 12;always @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin    \n        mmcm_lock_reg1    <=  1'd0;\n        cplllock_reg1     <= {PCIE_LANE{1'd1}}; \n        drp_done_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};     \n        qplllock_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg1         <=  2'd0; \n        qpllreset_in_reg1 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg1    <= {PCIE_LANE{1'd0}}; \n        mmcm_lock_reg2    <=  1'd0;\n        cplllock_reg2     <= {PCIE_LANE{1'd1}};\n        drp_done_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        qplllock_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg2         <=  2'd0;\n        qpllreset_in_reg2 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg2    <= {PCIE_LANE{1'd0}};  \n        end\n    else\n        begin  \n        mmcm_lock_reg1    <= QRST_MMCM_LOCK;   \n        cplllock_reg1     <= QRST_CPLLLOCK; \n        drp_done_reg1     <= QRST_DRP_DONE; \n        qplllock_reg1     <= QRST_QPLLLOCK;\n        rate_reg1         <= QRST_RATE; \n        qpllreset_in_reg1 <= QRST_QPLLRESET_IN;\n        qpllpd_in_reg1    <= QRST_QPLLPD_IN;\n        mmcm_lock_reg2    <= mmcm_lock_reg1;\n        cplllock_reg2     <= cplllock_reg1;\n        drp_done_reg2     <= drp_done_reg1; \n        qplllock_reg2     <= qplllock_reg1;\n        rate_reg2         <= rate_reg1;\n        qpllreset_in_reg2 <= qpllreset_in_reg1;\n        qpllpd_in_reg2    <= qpllpd_in_reg1;\n        end\n        \nend    \n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        fsm       <= FSM_WAIT_LOCK;\n        ovrd      <= 1'd0;\n        qpllreset <= 1'd1;\n        qpllpd    <= 1'd0;\n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (!QRST_RST_N)\n                begin\n                fsm       <= FSM_WAIT_LOCK;\n                ovrd      <= 1'd0;\n                qpllreset <= 1'd1;\n                qpllpd    <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                ovrd      <= ovrd;\n                qpllreset <= &qpllreset_in_reg2;\n                qpllpd    <= &qpllpd_in_reg2;\n                end\n            end  \n            \n        FSM_WAIT_LOCK :\n        \n            begin\n            fsm       <= ((&(~cplllock_reg2)) && (&(~qplllock_reg2)) ? FSM_MMCM_LOCK : FSM_WAIT_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_MMCM_LOCK :\n        \n            begin\n            fsm       <= ((mmcm_lock_reg2 && (&cplllock_reg2)) ? FSM_DRP_START_NOM : FSM_MMCM_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_DRP_START_NOM:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_NOM : FSM_DRP_START_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_NOM :\n        \n            begin\n            fsm       <= (&drp_done_reg2 ? FSM_QPLLLOCK : FSM_DRP_DONE_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end \n            \n        FSM_QPLLLOCK :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? ((BYPASS_COARSE_OVRD == 1) ? FSM_QPLL_PDRESET : FSM_DRP_START_OPT) : FSM_QPLLLOCK);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_DRP_START_OPT:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_OPT : FSM_DRP_START_OPT);\n            ovrd      <= 1'd1;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_OPT :\n        \n            begin\n            if (&drp_done_reg2)\n                begin\n                fsm       <= ((PCIE_PLL_SEL == \"QPLL\") ? FSM_QPLL_RESET : FSM_QPLL_PDRESET);\n                ovrd      <= ovrd;\n                qpllreset <= (PCIE_PLL_SEL == \"QPLL\");\n                qpllpd    <= qpllpd;\n                end\n            else\n                begin\n                fsm       <= FSM_DRP_DONE_OPT;\n                ovrd      <= ovrd;\n                qpllreset <= qpllreset;\n                qpllpd    <= qpllpd;\n                end\n            end \n            \n        FSM_QPLL_RESET :\n            \n            begin\n            fsm       <= (&(~qplllock_reg2) ? FSM_QPLLLOCK2 : FSM_QPLL_RESET);  \n            ovrd      <= ovrd;\n            qpllreset <= 1'd1;\n            qpllpd    <= 1'd0;\n            end     \n            \n        FSM_QPLLLOCK2 :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK2);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n            \n        FSM_QPLL_PDRESET :\n        \n            begin\n            fsm       <= FSM_QPLL_PD;\n            ovrd      <= ovrd;\n            qpllreset <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_QPLL_PD :\n        \n            begin\n            fsm       <= FSM_IDLE;\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            end \n                \n        default :\n        \n            begin\n            fsm       <= FSM_WAIT_LOCK;\n            ovrd      <= 1'd0;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        endcase\n        \n        end\n        \nend\n\n\n\nassign QRST_OVRD          = ovrd;\nassign QRST_DRP_START     = (fsm == FSM_DRP_START_NOM) || (fsm == FSM_DRP_START_OPT); \nassign QRST_QPLLRESET_OUT = qpllreset;\nassign QRST_QPLLPD_OUT    = ((PCIE_POWER_SAVING == \"FALSE\") ? 1'd0 : qpllpd);  \nassign QRST_IDLE          = (fsm == FSM_IDLE);\nassign QRST_FSM           = fsm;                   \n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to4_d7413466", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to4(\n    input a, b, c,\n    output w, x, y, z\n    );\n    \n    assign w = ~(a & b & c);\n    assign x = ~(a & b & ~c);\n    assign y = ~(a & ~b & c);\n    assign z = ~(a & ~b & ~c);\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MUX4X1_f8514d2e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MUX4X1 (A, B, S0, S1, Z);\ninput A;\ninput B;\ninput S0;\ninput S1;\noutput Z;\n\nwire not_S0, not_S1, not_A, not_B, A_and_not_B, not_A_and_B, not_A_and_not_B, not_B_and_A;\n\nnot (not_S0, S0);\nnot (not_S1, S1);\nnot (not_A, A);\nnot (not_B, B);\nand (A_and_not_B, A, not_B);\nand (not_A_and_B, not_A, B);\nand (not_A_and_not_B, not_A, not_B);\nand (not_B_and_A, not_B, A);\nor (Z, (A_and_not_B & ~S1 & ~S0), (not_A_and_B & S1 & ~S0), (not_A_and_not_B & S1 & S0), (not_B_and_A & ~S1 & S0));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_4bit_sequence_detection_92706f25", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fsm_4bit_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  output reg match\n);\n\n  parameter IDLE = 2'b00;\n  parameter S1 = 2'b01;\n  parameter S2 = 2'b10;\n  parameter S3 = 2'b11;\n  \n  reg [1:0] state;\n  reg [3:0] shift_reg;\n\n  always @(posedge clk, negedge reset) begin\n    if(!reset) begin\n      state <= IDLE;\n      shift_reg <= 4'b0000;\n      match <= 1'b0;\n    end else begin\n      case(state)\n        IDLE: begin\n          if(data == 1'b1) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= S1;\n          end else begin\n            shift_reg <= 4'b0000;\n          end\n        end\n        S1: begin\n          if(data == 1'b0) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n          end else begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= S2;\n          end\n        end\n        S2: begin\n          if(data == 1'b1) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= S3;\n          end else begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n          end\n        end\n        S3: begin\n          if(data == 1'b1) begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n            match <= 1'b1;\n          end else begin\n            shift_reg <= {shift_reg[2:0], data};\n            state <= IDLE;\n          end\n        end\n      endcase\n    end\n  end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__o31a_c18531ae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__o31a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1, A3     );\n    and and0 (and0_out_X, or0_out, B1    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_3eeac7bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder(\n    input [3:0] A,\n    output [3:0] S\n);\n\n    parameter [3:0] B = 4'hA; // Constant\n\n    assign S = A + B; // Adder\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__nor2_427c481d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__nor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, A, B           );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Reset_Delay_7c428c9d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Reset_Delay(iRST,iCLK,oRESET);\ninput iCLK;\ninput iRST;\noutput reg oRESET;\nreg [27:0] Cont;\nalways@(posedge iCLK or negedge iRST)\nbegin\n    if(!iRST)\n    begin\n        oRESET <= 1'b0;\n        Cont <= 28'b0;\n    end\n    else\n    begin\n        Cont <= Cont + 1'b1;\n        if(Cont != 28'h4FFFFFF) // about 300ms at 50MHz\n            oRESET <= 1'b1;\n    end\nend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_a20165d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule full_adder (\n  input A,\n  input B,\n  input C_in,\n  output S,\n  output C_out\n);\n\nassign S = A ^ B ^ C_in;\nassign C_out = (A & B) | (A & C_in) | (B & C_in);\n\nendmodule\nmodule ripple_carry_adder #(\n  parameter n = 4 // number of bits in A and B\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output [n:0] C\n);\n\nwire [n:0] carry; // carry signals for each bit position\n\n// generate carry signals\ngenvar i;\ngenerate\n  for (i = 0; i < n; i = i + 1) begin : carry_gen\n    full_adder fa(\n      .A(A[i]),\n      .B(B[i]),\n      .C_in(carry[i]),\n      .S(C[i]),\n      .C_out(carry[i+1])\n    );\n  end\nendgenerate\n\n// set carry-in for least significant bit\nassign carry[0] = 1'b0;\n\n// assign output\nassign C[n] = carry[n];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "EnergyHarvestingBlock_edcd991f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule EnergyHarvestingBlock (\n  input [n-1:0] e,\n  output out\n);\n\nparameter n = 4; // number of energy sources\nparameter voltage = 150; // voltage generated by each energy source in mV\nparameter current = 50; // current generated by each energy source in mA\n\nreg [15:0] v; // voltage generated by each energy source in mV\nreg [15:0] i; // current generated by each energy source in mA\nreg [31:0] p; // power generated by each energy source in mW\nreg [31:0] w; // weight of each energy source\n\nalways @(*) begin\n  v = voltage * e;\n  i = current * e;\n  p = (v * i) / 1000;\n  w = (p * 1000) / (v + i);\nend\n\nassign out = (w * v) / (1000 * n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axis_srl_fifo_9f66845f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule axis_srl_fifo(\n  input clk, rst,\n  input [7:0] input_axis_tdata,\n  input input_axis_tvalid, input_axis_tlast, input_axis_tuser,\n  output reg input_axis_tready,\n  output reg [7:0] output_axis_tdata,\n  output reg output_axis_tvalid, output_axis_tlast, output_axis_tuser,\n  input output_axis_tready,\n  output reg [2:0] count\n);\n\n  parameter DEPTH = 4;\n  parameter DATA_WIDTH = 8;\n\n  reg [DATA_WIDTH-1:0] fifo [0:DEPTH-1];\n  reg [2:0] head = 3'b0;\n  reg [2:0] tail = 3'b0;\n  reg [2:0] count_reg = 3'b0;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      head <= 3'b0;\n      tail <= 3'b0;\n      count_reg <= 3'b0;\n    end else begin\n      if (input_axis_tvalid && input_axis_tready) begin\n        fifo[head] <= input_axis_tdata;\n        head <= (head == 3'b111) ? 3'b0 : head + 1;\n        count_reg <= (count_reg == 3'b100) ? 3'b100 : count_reg + 1;\n      end\n      if (output_axis_tready && count_reg > 3'b0) begin\n        output_axis_tdata <= fifo[tail];\n        output_axis_tvalid <= 1;\n        output_axis_tlast <= (count_reg == 3'b1) && input_axis_tlast;\n        output_axis_tuser <= input_axis_tuser;\n        tail <= (tail == 3'b111) ? 3'b0 : tail + 1;\n        count_reg <= count_reg - 1;\n      end else begin\n        output_axis_tvalid <= 0;\n      end\n    end\n    input_axis_tready <= (count_reg < 3'b100) ? 1 : 0;\n    count <= count_reg;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "glitch_filter_ebd408f4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule glitch_filter (\n  input signal_in,\n  output signal_out\n);\n\nparameter glitch_duration = 4; // minimum pulse duration\n\nreg [glitch_duration-1:0] delay_line;\nreg filtered_signal;\n\nalways @(posedge signal_in) begin\n  delay_line <= {delay_line[glitch_duration-2:0], signal_in};\n  if (delay_line[0] == 1'b1 && delay_line[glitch_duration-1] == 1'b0) begin\n    filtered_signal <= delay_line[glitch_duration-2];\n  end else begin\n    filtered_signal <= signal_in;\n  end\nend\n\nassign signal_out = filtered_signal;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "assert_even_parity_assert_cdbbe4f7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule assert_even_parity_assert (clk, reset_n, test_expr, xzcheck_enable, parity_result);\n  parameter width = 1;\n  input clk, reset_n;\n  input [width-1:0] test_expr;\n  input xzcheck_enable;\n  output reg parity_result;\n\n  reg [width-1:0] data;\n  reg parity;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      parity <= 1;\n      parity_result <= 0;\n    end else begin\n      data <= test_expr;\n      parity <= ^test_expr;\n      parity_result <= ~parity;\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FP16RMulS0Of2_1cc0225a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FP16RMulS0Of2(\n input \t       clk,\n input \t       rst,\n input [15:0]  arg_0,\n input [15:0]  arg_1,\n output        ret_0,\n output [4:0]  ret_1,\n output [4:0]  ret_2,\n output [11:0] ret_3);\n\n   wire        s0;\n   wire        s1;\n   wire [4:0]  e0;\n   wire [4:0]  e1;\n   wire [9:0]  f0;\n   wire [9:0]  f1;\n   wire [10:0] ff0;\n   wire [10:0] ff1;\n   wire [21:0] z;\n   wire [11:0] zz;\n\n   assign s0 = arg_0[15:15];\n   assign s1 = arg_1[15:15];\n   assign e0 = arg_0[14:10];\n   assign e1 = arg_1[14:10];\n   assign f0 = arg_0[9:0];\n   assign f1 = arg_1[9:0];\n\n   assign ret_0 = s0 ^ s1;\n   assign ret_1 = e0;\n   assign ret_2 = e1;\n\n   assign ff0 = {(e0 == 0 ? 1'b0 : 1'b1), f0};\n   assign ff1 = {(e1 == 0 ? 1'b0 : 1'b1), f1};\n\n   assign z = ff0 * ff1;\n   assign zz = z[21:10];\n   assign ret_3 = zz;\n\nendmodule module FP16RMulS1Of2(\n input \t       clk,\n input \t       rst,\n input \t       arg_0,\n input [4:0]   arg_1,\n input [4:0]   arg_2,\n input [11:0]  arg_3,\n output [15:0] ret_0);\n\n   wire        s;\n   wire        c;\n   wire [9:0] fc;\n   wire [9:0] uc;\n   wire [6:0]  e7;\n   wire [4:0]  e;\n   wire        underflow;\n   wire        overflow;\n   wire        infinput;\n\n   assign s = arg_0;\n   assign c = arg_3[11:11];\n   assign e7 = arg_1 + arg_2 - 15 + c;\n   assign fc = c ? arg_3[10:1] : arg_3[9:0];\n   assign infinput = (arg_1 == 31) || (arg_2 == 31);\n   assign underflow = e7[6:6];\n   assign overflow = !underflow && (e7[5:5] || e7[4:0] == 31 || infinput);\n\n   assign e = underflow ? 0 : (overflow ? 31 : e7[4:0]);\n   assign uc = (underflow || e7[4:0] == 0) ? 0 : fc;\n\n   assign ret_0 = {s, e, uc};\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_transmitter_60858cc0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_transmitter(\n  input clk, reset, din, baud_clk,\n  output tx\n);\n\nreg [7:0] shift_reg;\nreg tx_busy;\nreg tx;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    shift_reg <= 8'b0;\n    tx_busy <= 1'b0;\n    tx <= 1'b1;\n  end else begin\n    if (baud_clk) begin\n      if (!tx_busy) begin\n        shift_reg <= din;\n        tx_busy <= 1'b1;\n      end else begin\n        shift_reg <= {shift_reg[6:0], 1'b0};\n        if (shift_reg == 8'b0) begin\n          tx_busy <= 1'b0;\n        end\n      end\n      tx <= shift_reg[7];\n    end\n  end\nend\n\nendmodule\n\nmodule uart_receiver(\n  input clk, reset, rx, baud_clk,\n  output dout\n);\n\nreg [7:0] shift_reg;\nreg rx_busy;\nwire dout;\n\nassign dout = shift_reg[7];\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    shift_reg <= 8'b0;\n    rx_busy <= 1'b0;\n  end else begin\n    if (baud_clk) begin\n      if (!rx_busy) begin\n        if (rx == 1'b0) begin\n          rx_busy <= 1'b1;\n        end\n      end else begin\n        shift_reg <= {shift_reg[6:0], rx};\n        if (shift_reg == 8'b0) begin\n          rx_busy <= 1'b0;\n        end\n      end\n    end\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__d38e06b7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] c;\n    wire [7:0] g;\n    wire [7:0] p;\n    wire [7:0] carry;\n    wire [7:0] sum;\n\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .c(c)\n    );\n\n    assign g = a & b;\n    assign p = a ^ b;\n    assign carry[0] = g[0];\n    assign overflow = g[7];\n    \n    generate\n        genvar i;\n        for (i = 1; i < 8; i = i + 1) begin : carry_lookahead\n            assign carry[i] = g[i] | (p[i] & carry[i-1]);\n        end\n    endgenerate\n\n    assign sum = a + b + {1'b0, carry[6:0]};\n    assign s = sum[7:0];\n\nendmodule\n\nmodule and_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] c\n);\n\n    assign c = a & b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiple_of_3_da384b02", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiple_of_3 (\n  input [2:0] data,\n  output reg q\n);\n  \n  always @* begin\n    case(data)\n      3'b000: q = 1'b1;\n      3'b001: q = 1'b0;\n      3'b010: q = 1'b0;\n      3'b011: q = 1'b1;\n      3'b100: q = 1'b0;\n      3'b101: q = 1'b1;\n      3'b110: q = 1'b1;\n      3'b111: q = 1'b0;\n      default: q = 1'b0;\n    endcase\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mi_nios_cpu_nios2_oci_fifo_wrptr_inc_9b7f2c74", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mi_nios_cpu_nios2_oci_fifo_wrptr_inc (\n  input ge2_free,\n  input ge3_free,\n  input [1:0] input_tm_cnt,\n  output reg [3:0] fifo_wrptr_inc\n);\n\n  always @* begin\n    if (ge3_free && (input_tm_cnt == 2'b11))\n      fifo_wrptr_inc = 4'b0011;\n    else if (ge2_free && (input_tm_cnt >= 2))\n      fifo_wrptr_inc = 4'b0010;\n    else if (input_tm_cnt >= 1)\n      fifo_wrptr_inc = 4'b0001;\n    else\n      fifo_wrptr_inc = 4'b0000;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_or4b_fba0d755", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_or4b (\n    X  ,\n    A  ,\n    B  ,\n    C  ,\n    D_N\n);\n\n    // Module ports\n    output X  ;\n    input  A  ;\n    input  B  ;\n    input  C  ;\n    input  D_N;\n\n    // Local signals\n    wire not0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    not not0 (not0_out , D_N              );\n    or  or0  (or0_out_X, not0_out, C, B, A);\n    buf buf0 (X        , or0_out_X        );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__4306b776", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input rst_n,\n    input a,\n    input [4:0] in,\n    output out_and,\n    output out_or,\n    output out_nor,\n    output reg final_output\n);\n\n    // Edge detection module\n    reg a_prev;\n    reg edge_detected;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            a_prev <= 1'b0;\n            edge_detected <= 1'b0;\n        end else begin\n            a_prev <= a;\n            edge_detected <= (a && ~a_prev) || (~a && a_prev);\n        end\n    end\n\n    // Combinational circuit module\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_nor = ~|in;\n\n    // Additional functional module\n    reg [1:0] decoder_out;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            final_output <= 1'b0;\n        end else begin\n            if (edge_detected && (decoder_out == 2'd2 || decoder_out == 2'd3)) begin\n                final_output <= 1'b1;\n            end else begin\n                final_output <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule decoder_2to4_with_enable (\n    input in,\n    input en,\n    output reg [1:0] out\n);\n\n    always @(*) begin\n        case ({in, en})\n            2'b00: out <= 2'b00;\n            2'b01: out <= 2'b01;\n            2'b10: out <= 2'b10;\n            2'b11: out <= 2'b11;\n            default: out <= 2'b00;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand_gate_ebf0bd74", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand_gate (\n    Z,\n    A,\n    B\n);\n\n    output Z;\n    input A;\n    input B;\n\n    assign Z = ~(A & B);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Mux_3x1_bv2 #_93e14cc5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Mux_3x1_bv2 #(parameter W=32)\n(\n//Input Signals\ninput wire [1:0] select,\ninput wire [W-1:0] ch_0,\ninput wire [W-1:0] ch_1,\ninput wire [W-1:0] ch_2,\n//Output Signals\noutput reg [W-1:0] data_out\n);\n    always @*\n        begin\n            case(select)\n                2'b00: data_out <= {W{1'b0}};\n                2'b01: data_out <= ch_0;\n                2'b10: data_out <= ch_1;\n                2'b11: data_out <= ch_2;\n                default : data_out <= ch_0;\n            endcase\n        end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "joy_control_f50bc21c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule joy_control(\n\tinput CLK,\n\tinput sndRec,\n\tinput BUSY,\n\tinput [7:0] RxData,\n    output SS,\n\toutput reg getByte,\n\toutput reg [39:0] DOUT\n);\n\nreg SS = 1;\nreg [2:0] pState = 0;\nreg [2:0] byteCnt = 0;\nreg [39:0] tmpSR = 0;\n\nalways @(negedge CLK)\nbegin\t\n\tcase(pState)\n\t\t0 : begin\n            SS <= 1;\n\t\t\tgetByte <= 0;\n\t\t\ttmpSR <= 0;\n\t\t\tbyteCnt <= 0;\n\t\t\tpState <= sndRec ? 1 : 0;\t\t\t\t\t\t\n\t\tend\n\n\t\t1 : begin\n            SS <= 0;\n\t\t\tgetByte <= 1;\n\t\t\tif(BUSY)\n\t\t\tbegin\n\t\t\t\tpState <= 2;\n\t\t\t\tbyteCnt <= byteCnt + 1;\n\t\t\tend\n\t\t\telse\n\t\t\t\tpState <= 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\tend\n\n\t\t2 : begin\n            SS <= 0;\n\t\t\tgetByte <= 0;\n\t\t\tpState <= BUSY ? 2 : 3;\n\t\tend\n\n\t\t3 : begin\n            SS <= 0;\n\t\t\tgetByte <= 0;\n\t\t\ttmpSR <= {tmpSR[31:0], RxData};\n\t\t\tpState <= byteCnt == 5 ? 4 : 1;\n\t\tend\n\n\t\t4 : begin\n            SS <= 1;\n\t\t\tgetByte <= 0;\n\t\t\tDOUT[39:0] <= tmpSR[39:0];\n\t\t\tpState <= sndRec ? 4 : 0;\n\t\tend\n\tendcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "squarer_f3ec2a4f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`ifndef __POW_2P1__\n`define __POW_2P1__\nmodule squarer(a, d);\n\ninput wire [232:0] a;\noutput wire [232:0] d;\n\nassign d[0] = a[0] ^ a[196];\nassign d[1] = a[117];\nassign d[2] = a[1] ^ a[197];\nassign d[3] = a[118];\nassign d[4] = a[2] ^ a[198];\nassign d[5] = a[119];\nassign d[6] = a[3] ^ a[199];\nassign d[7] = a[120];\nassign d[8] = a[4] ^ a[200];\nassign d[9] = a[121];\nassign d[10] = a[5] ^ a[201];\nassign d[11] = a[122];\nassign d[12] = a[6] ^ a[202];\nassign d[13] = a[123];\nassign d[14] = a[7] ^ a[203];\nassign d[15] = a[124];\nassign d[16] = a[8] ^ a[204];\nassign d[17] = a[125];\nassign d[18] = a[9] ^ a[205];\nassign d[19] = a[126];\nassign d[20] = a[10] ^ a[206];\nassign d[21] = a[127];\nassign d[22] = a[11] ^ a[207];\nassign d[23] = a[128];\nassign d[24] = a[12] ^ a[208];\nassign d[25] = a[129];\nassign d[26] = a[13] ^ a[209];\nassign d[27] = a[130];\nassign d[28] = a[14] ^ a[210];\nassign d[29] = a[131];\nassign d[30] = a[15] ^ a[211];\nassign d[31] = a[132];\nassign d[32] = a[16] ^ a[212];\nassign d[33] = a[133];\nassign d[34] = a[17] ^ a[213];\nassign d[35] = a[134];\nassign d[36] = a[18] ^ a[214];\nassign d[37] = a[135];\nassign d[38] = a[19] ^ a[215];\nassign d[39] = a[136];\nassign d[40] = a[20] ^ a[216];\nassign d[41] = a[137];\nassign d[42] = a[21] ^ a[217];\nassign d[43] = a[138];\nassign d[44] = a[22] ^ a[218];\nassign d[45] = a[139];\nassign d[46] = a[23] ^ a[219];\nassign d[47] = a[140];\nassign d[48] = a[24] ^ a[220];\nassign d[49] = a[141];\nassign d[50] = a[25] ^ a[221];\nassign d[51] = a[142];\nassign d[52] = a[26] ^ a[222];\nassign d[53] = a[143];\nassign d[54] = a[27] ^ a[223];\nassign d[55] = a[144];\nassign d[56] = a[28] ^ a[224];\nassign d[57] = a[145];\nassign d[58] = a[29] ^ a[225];\nassign d[59] = a[146];\nassign d[60] = a[30] ^ a[226];\nassign d[61] = a[147];\nassign d[62] = a[31] ^ a[227];\nassign d[63] = a[148];\nassign d[64] = a[32] ^ a[228];\nassign d[65] = a[149];\nassign d[66] = a[33] ^ a[229];\nassign d[67] = a[150];\nassign d[68] = a[34] ^ a[230];\nassign d[69] = a[151];\nassign d[70] = a[35] ^ a[231];\nassign d[71] = a[152];\nassign d[72] = a[36] ^ a[232];\nassign d[73] = a[153];\nassign d[74] = a[37] ^ a[196];\nassign d[75] = a[117] ^ a[154];\nassign d[76] = a[38] ^ a[197];\nassign d[77] = a[118] ^ a[155];\nassign d[78] = a[39] ^ a[198];\nassign d[79] = a[119] ^ a[156];\nassign d[80] = a[40] ^ a[199];\nassign d[81] = a[120] ^ a[157];\nassign d[82] = a[41] ^ a[200];\nassign d[83] = a[121] ^ a[158];\nassign d[84] = a[42] ^ a[201];\nassign d[85] = a[122] ^ a[159];\nassign d[86] = a[43] ^ a[202];\nassign d[87] = a[123] ^ a[160];\nassign d[88] = a[44] ^ a[203];\nassign d[89] = a[124] ^ a[161];\nassign d[90] = a[45] ^ a[204];\nassign d[91] = a[125] ^ a[162];\nassign d[92] = a[46] ^ a[205];\nassign d[93] = a[126] ^ a[163];\nassign d[94] = a[47] ^ a[206];\nassign d[95] = a[127] ^ a[164];\nassign d[96] = a[48] ^ a[207];\nassign d[97] = a[128] ^ a[165];\nassign d[98] = a[49] ^ a[208];\nassign d[99] = a[129] ^ a[166];\nassign d[100] = a[50] ^ a[209];\nassign d[101] = a[130] ^ a[167];\nassign d[102] = a[51] ^ a[210];\nassign d[103] = a[131] ^ a[168];\nassign d[104] = a[52] ^ a[211];\nassign d[105] = a[132] ^ a[169];\nassign d[106] = a[53] ^ a[212];\nassign d[107] = a[133] ^ a[170];\nassign d[108] = a[54] ^ a[213];\nassign d[109] = a[134] ^ a[171];\nassign d[110] = a[55] ^ a[214];\nassign d[111] = a[135] ^ a[172];\nassign d[112] = a[56] ^ a[215];\nassign d[113] = a[136] ^ a[173];\nassign d[114] = a[57] ^ a[216];\nassign d[115] = a[137] ^ a[174];\nassign d[116] = a[58] ^ a[217];\nassign d[117] = a[138] ^ a[175];\nassign d[118] = a[59] ^ a[218];\nassign d[119] = a[139] ^ a[176];\nassign d[120] = a[60] ^ a[219];\nassign d[121] = a[140] ^ a[177];\nassign d[122] = a[61] ^ a[220];\nassign d[123] = a[141] ^ a[178];\nassign d[124] = a[62] ^ a[221];\nassign d[125] = a[142] ^ a[179];\nassign d[126] = a[63] ^ a[222];\nassign d[127] = a[143] ^ a[180];\nassign d[128] = a[64] ^ a[223];\nassign d[129] = a[144] ^ a[181];\nassign d[130] = a[65] ^ a[224];\nassign d[131] = a[145] ^ a[182];\nassign d[132] = a[66] ^ a[225];\nassign d[133] = a[146] ^ a[183];\nassign d[134] = a[67] ^ a[226];\nassign d[135] = a[147] ^ a[184];\nassign d[136] = a[68] ^ a[227];\nassign d[137] = a[148] ^ a[185];\nassign d[138] = a[69] ^ a[228];\nassign d[139] = a[149] ^ a[186];\nassign d[140] = a[70] ^ a[229];\nassign d[141] = a[150] ^ a[187];\nassign d[142] = a[71] ^ a[230];\nassign d[143] = a[151] ^ a[188];\nassign d[144] = a[72] ^ a[231];\nassign d[145] = a[152] ^ a[189];\nassign d[146] = a[73] ^ a[232];\nassign d[147] = a[153] ^ a[190];\nassign d[148] = a[74];\nassign d[149] = a[154] ^ a[191];\nassign d[150] = a[75];\nassign d[151] = a[155] ^ a[192];\nassign d[152] = a[76];\nassign d[153] = a[156] ^ a[193];\nassign d[154] = a[77];\nassign d[155] = a[157] ^ a[194];\nassign d[156] = a[78];\nassign d[157] = a[158] ^ a[195];\nassign d[158] = a[79];\nassign d[159] = a[159] ^ a[196];\nassign d[160] = a[80];\nassign d[161] = a[160] ^ a[197];\nassign d[162] = a[81];\nassign d[163] = a[161] ^ a[198];\nassign d[164] = a[82];\nassign d[165] = a[162] ^ a[199];\nassign d[166] = a[83];\nassign d[167] = a[163] ^ a[200];\nassign d[168] = a[84];\nassign d[169] = a[164] ^ a[201];\nassign d[170] = a[85];\nassign d[171] = a[165] ^ a[202];\nassign d[172] = a[86];\nassign d[173] = a[166] ^ a[203];\nassign d[174] = a[87];\nassign d[175] = a[167] ^ a[204];\nassign d[176] = a[88];\nassign d[177] = a[168] ^ a[205];\nassign d[178] = a[89];\nassign d[179] = a[169] ^ a[206];\nassign d[180] = a[90];\nassign d[181] = a[170] ^ a[207];\nassign d[182] = a[91];\nassign d[183] = a[171] ^ a[208];\nassign d[184] = a[92];\nassign d[185] = a[172] ^ a[209];\nassign d[186] = a[93];\nassign d[187] = a[173] ^ a[210];\nassign d[188] = a[94];\nassign d[189] = a[174] ^ a[211];\nassign d[190] = a[95];\nassign d[191] = a[175] ^ a[212];\nassign d[192] = a[96];\nassign d[193] = a[176] ^ a[213];\nassign d[194] = a[97];\nassign d[195] = a[177] ^ a[214];\nassign d[196] = a[98];\nassign d[197] = a[178] ^ a[215];\nassign d[198] = a[99];\nassign d[199] = a[179] ^ a[216];\nassign d[200] = a[100];\nassign d[201] = a[180] ^ a[217];\nassign d[202] = a[101];\nassign d[203] = a[181] ^ a[218];\nassign d[204] = a[102];\nassign d[205] = a[182] ^ a[219];\nassign d[206] = a[103];\nassign d[207] = a[183] ^ a[220];\nassign d[208] = a[104];\nassign d[209] = a[184] ^ a[221];\nassign d[210] = a[105];\nassign d[211] = a[185] ^ a[222];\nassign d[212] = a[106];\nassign d[213] = a[186] ^ a[223];\nassign d[214] = a[107];\nassign d[215] = a[187] ^ a[224];\nassign d[216] = a[108];\nassign d[217] = a[188] ^ a[225];\nassign d[218] = a[109];\nassign d[219] = a[189] ^ a[226];\nassign d[220] = a[110];\nassign d[221] = a[190] ^ a[227];\nassign d[222] = a[111];\nassign d[223] = a[191] ^ a[228];\nassign d[224] = a[112];\nassign d[225] = a[192] ^ a[229];\nassign d[226] = a[113];\nassign d[227] = a[193] ^ a[230];\nassign d[228] = a[114];\nassign d[229] = a[194] ^ a[231];\nassign d[230] = a[115];\nassign d[231] = a[195] ^ a[232];\nassign d[232] = a[116];\nendmodule\n`endif\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lookahead_42e1ed45", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n module lookahead(c_in, c_out, c, p, g, P, G);\n   input [3:0] p, g;\n   input c_in;\n   \n   output [2:0] c;\n   output c_out;\n   output P, G;\n   \n   assign  c[0] = g[0] | (p[0] & c_in); \n   assign  c[1] = g[1] | (g[0] & p[1]) | (p[1] & p[0] & c_in); \n   assign  c[2] = g[2] | (g[1] & p[2]) | (g[0] & p[1] & p[2]) | (p[2] & p[1] & p[0] & c_in); \n   assign  c_out = g[3] | (g[2] & p[3]) | (g[1] & p[2] & p[3]) | (g[0] & p[1] & p[2] & p[3]) | (p[3] & p[2] & p[1] & p[0] & c_in);  \n   \n   assign  G = g[3] | (g[2] & p[3]) | (g[1] & p[2] & p[3]) | (p[3] & p[2] & p[1] & g[0]);\n   assign  P = p[3] & p[2] & p[1] & p[0];\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "crc_3b5d82f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule crc(\n  input [15:0] data_in,\n  input crc_en,\n  output reg [15:0] crc_out,\n  input rst,\n  input clk\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      crc_out <= 16'h0000;\n    end else if (crc_en) begin\n      crc_out <= data_in + 16'hA001;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_bcd_265d2873", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_to_bcd (\n    input [3:0] binary_in,\n    output [7:0] bcd_out,\n    output overflow\n);\n\n    wire [3:0] digit;\n    wire [3:0] carry;\n    wire [7:0] bcd;\n\n    assign digit[0] = binary_in[0];\n    assign digit[1] = binary_in[1];\n    assign digit[2] = binary_in[2];\n    assign digit[3] = binary_in[3];\n\n    assign bcd[0] = digit[0] + digit[1]*2 + digit[2]*4 + digit[3]*8;\n    assign bcd[1] = digit[0]*2 + digit[1]*4 + digit[2]*8;\n    assign bcd[2] = digit[0]*4 + digit[1]*8;\n    assign bcd[3] = digit[0]*8;\n\n    assign carry[0] = (bcd[0] > 9);\n    assign carry[1] = (bcd[1] > 9);\n    assign carry[2] = (bcd[2] > 9);\n    assign carry[3] = (bcd[3] > 9);\n\n    assign bcd_out[0] = bcd[0];\n    assign bcd_out[1] = bcd[1];\n    assign bcd_out[2] = bcd[2];\n    assign bcd_out[3] = bcd[3];\n    assign bcd_out[4] = carry[0];\n    assign bcd_out[5] = carry[1];\n    assign bcd_out[6] = carry[2];\n    assign bcd_out[7] = carry[3];\n\n    assign overflow = (carry[3] == 1);\n\nendmodule\n\nmodule binary_to_excess3 (\n    input [3:0] binary_in,\n    output [3:0] excess3_out\n);\n\n    assign excess3_out[0] = binary_in[0] ^ 1 ^ 1 ^ 1;\n    assign excess3_out[1] = binary_in[1] ^ 1 ^ 1 ^ 1;\n    assign excess3_out[2] = binary_in[2] ^ 1 ^ 1 ^ 1;\n    assign excess3_out[3] = binary_in[3] ^ 1 ^ 1 ^ 1;\n\nendmodule\n\nmodule top_module (\n    input [3:0] B,\n    output [7:0] bcd_out,\n    output overflow,\n    output reg [3:0] E,\n    output reg [3:0] sum\n);\n\n    wire [3:0] binary_out;\n    wire [3:0] excess3_out;\n\n    binary_to_excess3 bin2ex3(.binary_in(B), .excess3_out(excess3_out));\n    binary_to_bcd bin2bcd(.binary_in(excess3_out), .bcd_out(bcd_out), .overflow(overflow));\n\n    always @* begin\n        E = excess3_out;\n        sum = B + E;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__ea482bac", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input a,          // Input signal to the first XOR gate\n    input b,          // Input signal to the first XOR gate\n    input c,          // Input signal to the second XOR gate\n    input d,          // Input signal to the second XOR gate\n    input control,    // Control signal for the tri-state buffer\n    output [2:0] q // 3-bit output from the system\n);\n\nreg [3:0] counter;\nwire [3:0] counter_out;\nwire [1:0] xor_out;\nwire mult_out;\n\n// Counter module\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Output module\nassign counter_out = counter[2:0];\nassign xor_out = {a^b, c^d};\nassign mult_out = (xor_out[0] & counter_out) ^ (xor_out[1] & counter_out);\n\n// Tri-state buffer module\nreg [2:0] q_reg;\nalways@(control or mult_out) begin\n    if(control) begin\n        q_reg = mult_out;\n    end\nend\nassign q = q_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ptp_tag_insert #_c20ed24e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n`resetall\n\n\n\n\nmodule ptp_tag_insert #\n(\n    parameter DATA_WIDTH = 64,\n    parameter KEEP_WIDTH = DATA_WIDTH/8,\n    parameter TAG_WIDTH = 16,\n    parameter TAG_OFFSET = 1,\n    parameter USER_WIDTH = TAG_WIDTH+TAG_OFFSET\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]  s_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  s_axis_tkeep,\n    input  wire                   s_axis_tvalid,\n    output wire                   s_axis_tready,\n    input  wire                   s_axis_tlast,\n    input  wire [USER_WIDTH-1:0]  s_axis_tuser,\n\n    \n    output wire [DATA_WIDTH-1:0]  m_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  m_axis_tkeep,\n    output wire                   m_axis_tvalid,\n    input  wire                   m_axis_tready,\n    output wire                   m_axis_tlast,\n    output wire [USER_WIDTH-1:0]  m_axis_tuser,\n\n    \n    input  wire [TAG_WIDTH-1:0]   s_axis_tag,\n    input  wire                   s_axis_tag_valid,\n    output wire                   s_axis_tag_ready\n);\n\nreg [TAG_WIDTH-1:0] tag_reg = {TAG_WIDTH{1'b0}};\nreg tag_valid_reg = 1'b0;\n\nreg [USER_WIDTH-1:0] user;\n\nassign s_axis_tready = m_axis_tready && tag_valid_reg;\n\nassign m_axis_tdata  = s_axis_tdata;\nassign m_axis_tkeep  = s_axis_tkeep;\nassign m_axis_tvalid = s_axis_tvalid && tag_valid_reg;\nassign m_axis_tlast  = s_axis_tlast;\nassign m_axis_tuser  = user;\n\nassign s_axis_tag_ready = !tag_valid_reg;\n\nalways @* begin\n    user = s_axis_tuser;\n    user[TAG_OFFSET +: TAG_WIDTH] = tag_reg;\nend\n\nalways @(posedge clk) begin\n    if (tag_valid_reg) begin\n        if (s_axis_tvalid && s_axis_tready && s_axis_tlast) begin\n            tag_valid_reg <= 1'b0;\n        end\n    end else begin\n        tag_reg <= s_axis_tag;\n        tag_valid_reg <= s_axis_tag_valid;\n    end\n\n    if (rst) begin\n        tag_valid_reg <= 1'b0;\n    end\nend\n\nendmodule\n\n`resetall\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dmem_f68cc6e2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dmem(\n    output  [31:0] RD,\n    input   [31:0] A, WD,\n    input   WE, clk\n    );\n\n    reg [31:0] RAM [0:255];\n\n    assign RD = (A != 0) ? RAM[A[7:0]] : 0;\n\n    always @ (posedge clk)\n        if (WE)\n            RAM[A[7:0]] <= WD;\n            endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_bd3a6404", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter (\n    input [15:0] DATA,\n    input [3:0] SHIFT,\n    input [1:0] CTRL,\n    output reg [15:0] out\n);\n\nreg [15:0] shift_reg1, shift_reg2, shift_reg3;\n\nalways @(*) begin\n    shift_reg1 = DATA;\n    shift_reg2 = (CTRL == 2'b00) ? {DATA[14:0], 1'b0} :\n                 (CTRL == 2'b01) ? {1'b0, DATA[15:1]} :\n                 (CTRL == 2'b10) ? {{DATA[15], DATA[15:1]}, DATA[15]} :\n                                   {DATA[0], DATA[15:1]};\n    shift_reg3 = (SHIFT[3] == 1'b1) ? shift_reg2 :\n                 (SHIFT[2] == 1'b1) ? shift_reg2 >> 2 :\n                 (SHIFT[1] == 1'b1) ? shift_reg2 >> 4 :\n                                      shift_reg2 >> 8;\n    out = (SHIFT[0] == 1'b1) ? shift_reg3 :\n          (SHIFT[1:0] == 2'b01) ? {shift_reg3[0], shift_reg3[15:1]} :\n          (SHIFT[1:0] == 2'b10) ? {{shift_reg3[15], shift_reg3[15:1]}, shift_reg3[15]} :\n                                   {shift_reg3[14:0], shift_reg3[0]};\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "test_stub_scan_c0b6dfe6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule test_stub_scan (\nmux_drive_disable, mem_write_disable, sehold, se, testmode_l, \nmem_bypass, so_0, so_1, so_2, \nctu_tst_pre_grst_l, arst_l, global_shift_enable, \nctu_tst_scan_disable, ctu_tst_scanmode, ctu_tst_macrotest, \nctu_tst_short_chain, long_chain_so_0, short_chain_so_0, \nlong_chain_so_1, short_chain_so_1, long_chain_so_2, short_chain_so_2\n);\n\n   input        ctu_tst_pre_grst_l;\n   input        arst_l;                input        global_shift_enable;\n   input        ctu_tst_scan_disable;  input        ctu_tst_scanmode;\n   input \tctu_tst_macrotest;\n   input \tctu_tst_short_chain;\n   input \tlong_chain_so_0;\n   input \tshort_chain_so_0;\n   input \tlong_chain_so_1;\n   input \tshort_chain_so_1;\n   input \tlong_chain_so_2;\n   input \tshort_chain_so_2;\n   \n   output \tmux_drive_disable;\n   output \tmem_write_disable;\n   output \tsehold;\n   output \tse;\n   output \ttestmode_l;\n   output \tmem_bypass;\n   output \tso_0;\n   output \tso_1;\n   output \tso_2;\n\n   wire         pin_based_scan;\n   wire         short_chain_en;\n   wire         short_chain_select;\n\n   assign  mux_drive_disable  = ~ctu_tst_pre_grst_l | short_chain_select | se;\n   assign  mem_write_disable  = ~ctu_tst_pre_grst_l | se;\n   assign  sehold             = ctu_tst_macrotest & ~se;\n   assign  se                 = global_shift_enable;\n   assign  testmode_l         = ~ctu_tst_scanmode;\n   assign  mem_bypass         = ~ctu_tst_macrotest & ~testmode_l;\n   assign  pin_based_scan     = ctu_tst_scan_disable;\n   assign  short_chain_en     = ~(pin_based_scan & se);\n   assign  short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;\n   assign  so_0               = short_chain_select ? short_chain_so_0 : long_chain_so_0;\n   assign  so_1               = short_chain_select ? short_chain_so_1 : long_chain_so_1;\n   assign  so_2               = short_chain_select ? short_chain_so_2 : long_chain_so_2;\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_264a743e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [1:0] C\n);\n\n// Comparing A and B\nalways @(*) begin\n    if(A == B) begin\n        C = 2'b00;\n    end\n    else if(A > B) begin\n        C = 2'b01;\n    end\n    else begin\n        C = 2'b10;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ASYNC_TO_SYNC_d5e9ff36", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ASYNC_TO_SYNC (\n  input in,\n  input clk,\n  input rst,\n  output reg out\n);\n\nparameter n = 3; // number of synchronizer stages\n\nreg [n-1:0] sync_reg; // register chain for synchronizer\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    sync_reg <= {n{1'b0}}; // reset register chain\n    out <= 1'b0; // reset output signal\n  end else begin\n    sync_reg <= {sync_reg[n-2:0], in}; // shift input signal through register chain\n    out <= sync_reg[n-1]; // output final synchronized signal\n  end\nend\n\nendmodule\n\nmodule SYNC_TO_ASYNC (\n  input clk,\n  input rst,\n  input in,\n  output reg out\n);\n\nparameter n = 4; // number of synchronizer stages\n\nreg [n-1:0] sync_reg; // register chain for synchronizer\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    sync_reg <= {n{1'b0}}; // reset register chain\n    out <= 1'b0; // reset output signal\n  end else begin\n    sync_reg <= {sync_reg[n-2:0], in}; // shift input signal through register chain\n    out <= sync_reg[n-1]; // output final synchronized signal\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Depulser_4faf8127", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Depulser(\n  input   wire clock,\n  input   wire reset,\n  input   wire io_in,\n  input   wire io_rst,\n  output  reg  io_out\n);\n  wire  r_clock;\n  wire  r_reset;\n  wire  r_io_in;\n  wire  r_io_init;\n  reg   r_io_out;\n  wire  r_io_enable;\n  wire  _T_9;\n  wire  _T_11;\n  \n  reg [1:0] state = 2'b00; // Initialize state to 0\n  wire pulse;\n  \n  assign pulse = (r_io_in == 1'b1) && (state == 2'b00); // Detect a pulse\n  \n  always @(posedge r_clock or posedge r_reset) begin\n    if (r_reset == 1'b1) begin // Reset output to 0\n      r_io_out <= 1'b0;\n      state <= 2'b00;\n    end else if (pulse) begin // Hold output high for one clock cycle\n      r_io_out <= 1'b1;\n      state <= 2'b01;\n    end else if (state == 2'b01) begin // Return output to 0\n      r_io_out <= 1'b0;\n      state <= 2'b10;\n    end else begin // Pass input to output\n      r_io_out <= r_io_in;\n      state <= 2'b00;\n    end\n  end\n  \n  always @* begin\n    io_out = r_io_out;\n  end\n  \n  assign r_clock = clock;\n  assign r_reset = reset;\n  assign r_io_in = _T_9;\n  assign r_io_init = 1'h0;\n  assign r_io_enable = _T_11;\n  assign _T_9 = io_rst ? 1'h0 : io_in;\n  assign _T_11 = io_in | io_rst;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_counter_28c55fe4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule gray_counter (\n    input clk,\n    input reset,\n    input ena,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (ena) begin\n            q <= q ^ (q >> 1);\n        end else begin\n            q <= q ^ (q << 1);\n        end\n    end\n\nendmodule\nmodule barrel_shifter (\n    input [3:0] a,\n    input [1:0] b,\n    output [3:0] q\n);\n\n    assign q = (b[1]) ? (b[0]) ? {a[1:0], 2'b00} : {2'b00, a[3:2]} : (b[0]) ? {a[0], a[3:1]} : {a[2:0], a[3]};\n\nendmodule\nmodule and_gate (\n    input [3:0] a,\n    output [3:0] q\n);\n\n    assign q = a & 4'b1100;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input ena,\n    input [1:0] select, // Fixed the width of 'select' port to 2 bits\n    output [3:0] q\n);\n\n    wire [3:0] gray_out;\n    wire [3:0] shift_out;\n    wire [3:0] and_out;\n\n    gray_counter gc (\n        .clk(clk),\n        .reset(reset),\n        .ena(ena),\n        .q(gray_out)\n    );\n\n    barrel_shifter bs (\n        .a(gray_out),\n        .b(select),\n        .q(shift_out)\n    );\n\n    and_gate ag (\n        .a(shift_out),\n        .q(and_out)\n    );\n\n    assign q = and_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_5098fbf3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n  input clk,\n  input reset,\n  input up_down,\n  input enable,\n  output reg [8:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    q <= 0;\n  end else if (enable) begin\n    if (up_down) begin\n      q <= q + 1;\n    end else begin\n      q <= q - 1;\n    end\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "VerilogModule_d06a5965", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule VerilogModule (\n    input CLOCK_27,\n    input CLOCK_50,\n    input [3:0] KEY,\n    input [17:0] SW,\n    output [6:0] HEX0,\n    output [6:0] HEX1,\n    output [6:0] HEX2,\n    output [6:0] HEX3,\n    output [6:0] HEX4,\n    output [6:0] HEX5,\n    output [6:0] HEX6,\n    output [6:0] HEX7,\n    output [8:0] LEDG,\n    output [17:0] LEDR,\n    output UART_TXD,\n    input UART_RXD,\n    inout [7:0] LCD_DATA,\n    output LCD_ON,\n    output LCD_BLON,\n    output LCD_RW,\n    output LCD_EN,\n    output LCD_RS,\n    inout [35:0] GPIO_0,\n    inout [35:0] GPIO_1\n);\n\n    reg [15:0] d0, d1, d2, d3, d4;\n    reg [17:0] LEDR;\n    reg [8:0] LEDG;\n\n    // Store values of DPDT switch in registers\n    always @(posedge KEY[2]) begin\n        case(SW[17:16])\n            0: d0 <= SW[15:0];\n            1: d1 <= SW[15:0];\n            2: d2 <= SW[15:0];\n            default: d3 <= SW[15:0];\n        endcase\n    end\n\n    // Add value of d0 to d4 when push button is pressed\n    always @(posedge CLOCK_27) begin\n        if(!KEY[0]) begin\n            d4 <= 0;\n        end else begin\n            d4 <= d4 + d0;\n        end\n    end\n\n    // Output values of d0, d1, d2, d3, and d4 to 7-segment display\n    assign HEX0 = d0;\n    assign HEX1 = d1;\n    assign HEX2 = d2;\n    assign HEX3 = d3;\n    assign HEX4 = d4;\n    assign HEX5 = 7'b1111111;\n    assign HEX6 = 7'b1111111;\n    assign HEX7 = 7'b1111111;\n\n    // Output values of d0, d1, d2, d3, and d4 to UART transmitter\n    assign UART_TXD = {d0, d1, d2, d3, d4};\n\n    // Display values of d0, d1, d2, d3, and d4 on LCD module\n    assign LCD_ON = 1'b1;\n    assign LCD_BLON = 1'b1;\n    assign LCD_RW = 1'b0;\n    assign LCD_EN = 1'b1;\n    assign LCD_RS = 1'b1;\n\n    // Drive LEDR\n    always @(posedge CLOCK_27) begin\n        LEDR <= d0;\n    end\n\n    // Drive LEDG\n    always @(posedge CLOCK_27) begin\n        LEDG <= 9'b111111111;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter16_25b83848", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter16(\n  input clk, // input clock signal\n  input rst, // synchronous reset signal\n  output reg [15:0] count // output count value\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n    end else if (count == 65535) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_78117a99", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1 (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input sel0,\n    input sel1,\n    input clk,\n    output reg out\n);\n    \n    always @(posedge clk) begin\n        if (sel1 == 0 && sel0 == 0) begin\n            out <= in0;\n        end else if (sel1 == 0 && sel0 == 1) begin\n            out <= in1;\n        end else if (sel1 == 1 && sel0 == 0) begin\n            out <= in2;\n        end else begin\n            out <= in3;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dual_edge_ff_db1214ff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dual_edge_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q1, q2;\n\n// First D flip-flop captures data on rising edge of clock\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\n// Second D flip-flop captures output of first flip-flop on falling edge of clock\nalways @(negedge clk) begin\n    q2 <= q1;\nend\n\n// Output of second flip-flop is the output of the module\nassign q = q2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_and_nor_b4b17328", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_and_nor (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire b         ;\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    //  Name  Output      Other arguments\n    not not0 (b         , B1_N           );\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, b, and0_out    );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sum_diff_842612f0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sum_diff (\n  input [7:0] A,\n  input [7:0] B,\n  output [7:0] S,\n  output [7:0] D\n);\n\n\n  assign S = A + B;\n  assign D = A - B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "openhmc_counter48 #_57a62d3a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule openhmc_counter48 #(\n        parameter DATASIZE  = 16    ) (\n        input wire                  clk,\n        input wire                  res_n,\n        input wire                  increment,\n        input wire                  load_enable,\n        output wire [DATASIZE-1:0]  value\n);\n\n    reg [DATASIZE-1:0]  value_reg;\n    reg                 load_enable_reg;\n\n    assign value    = value_reg;\n\n    `ifdef ASYNC_RES\n    always @(posedge clk or negedge res_n) `else\n    always @(posedge clk) `endif\n    begin\n        if(!res_n) begin\n            value_reg               <= {DATASIZE{1'b0}};\n            load_enable_reg         <= 1'b0;\n        end else begin\n            load_enable_reg         <= load_enable;\n            case ({load_enable_reg,increment})\n                    2'b00:\n                        value_reg   <= value_reg;\n                    2'b01:\n                        value_reg   <= (value_reg + 1'b1);\n                    2'b10:\n                        value_reg   <= {DATASIZE{1'b0}};\n                    2'b11:\n                        value_reg   <= {DATASIZE{1'b0}} + 1'b1;\n            endcase\n        end\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NPCG_Toggle_BNC_P_read_DT00h_c178a4b5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule NPCG_Toggle_BNC_P_read_DT00h\n#\n(\n    parameter NumberOfWays    =   4\n)\n(\n    iSystemClock        ,\n    iReset              ,\n    iOpcode             ,\n    iTargetID           ,\n    iSourceID           ,\n    iLength             ,\n    iCMDValid           ,\n    oCMDReady           ,\n    oReadData           ,\n    oReadLast           ,\n    oReadValid          ,\n    iReadReady          ,\n    iWaySelect          ,\n    iColAddress         ,\n    iRowAddress         ,\n    oStart              ,\n    oLastStep           ,\n    iPM_Ready           ,\n    iPM_LastStep        ,\n    oPM_PCommand        ,\n    oPM_PCommandOption  ,\n    oPM_TargetWay       ,\n    oPM_NumOfData       ,\n    oPM_CASelect        ,\n    oPM_CAData          ,\n    iPM_ReadData        ,\n    iPM_ReadLast        ,\n    iPM_ReadValid       ,\n    oPM_ReadReady\n);\n    input                           iSystemClock        ;\n    input                           iReset              ;\n    input   [5:0]                   iOpcode             ;\n    input   [4:0]                   iTargetID           ;\n    input   [4:0]                   iSourceID           ;\n    input   [15:0]                  iLength             ;\n    input                           iCMDValid           ;\n    output                          oCMDReady           ;\n    output  [31:0]                  oReadData           ;\n    output                          oReadLast           ;\n    output                          oReadValid          ;\n    input                           iReadReady          ;\n    input  [NumberOfWays - 1:0]     iWaySelect          ;\n    input   [15:0]                  iColAddress             ;\n    input   [23:0]                  iRowAddress             ;\n    output                          oStart              ;\n    output                          oLastStep           ;\n    input   [7:0]                   iPM_Ready           ;\n    input   [7:0]                   iPM_LastStep        ;\n    output  [7:0]                   oPM_PCommand        ;\n    output  [2:0]                   oPM_PCommandOption  ;\n    output  [NumberOfWays - 1:0]    oPM_TargetWay       ;\n    output  [15:0]                  oPM_NumOfData       ;\n    output                          oPM_CASelect        ;\n    output  [7:0]                   oPM_CAData          ;\n    input   [31:0]                  iPM_ReadData        ;\n    input                           iPM_ReadLast        ;\n    input                           iPM_ReadValid       ;\n    output                          oPM_ReadReady       ;\n\n    reg [NumberOfWays - 1:0]    rTargetWay  ;\n    reg [15:0]                  rColAddress ;\n    reg [23:0]                  rRowAddress ;\n    wire                        wModuleTriggered;\n    \n    reg [7:0]                   rPMTrigger  ;\n    reg [2:0]                   rPCommandOption ;\n    reg [15:0]                  rPMLength   ;\n    reg [15:0]                  rTrfLength  ;\n    \n    reg [7:0]                   rCAData     ;\n    reg                         rPMCommandOrAddress ;\n\n    localparam  State_Idle          = 4'b0000   ;\n    localparam  State_NPBRIssue     = 4'b0001   ;\n    localparam  State_NCmdIssue     = 4'b0011   ;\n    localparam  State_NCmdWrite0    = 4'b0010   ;\n    localparam  State_NCmdWrite1    = 4'b0110   ;\n    localparam  State_NCmdWrite2    = 4'b0111   ;\n    localparam  State_NCmdWrite3    = 4'b0101   ;\n    localparam  State_NTimer1Issue  = 4'b0100   ;\n    localparam  State_DIIssue       = 4'b1100   ;\n    localparam  State_NTimer2Issue  = 4'b1101   ;\n    localparam  State_WaitDone      = 4'b1111   ;\n    \n    reg [3:0]   rCurState   ;\n    reg [3:0]   rNextState  ;\n\n    always @ (posedge iSystemClock)\n        if (iReset)\n            rCurState <= State_Idle;\n        else\n            rCurState <= rNextState;\n\n    always @ (*)\n        case (rCurState)\n        State_Idle:\n            rNextState <= (wModuleTriggered)?State_NPBRIssue:State_Idle;\n        State_NPBRIssue:\n            rNextState <= (iPM_Ready)?State_NCmdIssue:State_NPBRIssue;\n        State_NCmdIssue:\n            rNextState <= (iPM_LastStep[6])? State_NCmdWrite0:State_NCmdIssue;\n        State_NCmdWrite0:\n            rNextState <= State_NCmdWrite1;\n        State_NCmdWrite1:\n            rNextState <= State_NCmdWrite2;\n        State_NCmdWrite2:\n            rNextState <= State_NCmdWrite3;\n        State_NCmdWrite3:\n            rNextState <= State_NTimer1Issue;\n        State_NTimer1Issue:\n            rNextState <= (iPM_LastStep[3])? State_DIIssue:State_NTimer1Issue;\n        State_DIIssue:\n            rNextState <= (iPM_LastStep[0])? State_NTimer2Issue:State_DIIssue;\n        State_NTimer2Issue:\n            rNextState <= (iPM_LastStep[1])? State_WaitDone:State_NTimer2Issue;\n        State_WaitDone:\n            rNextState <= (oLastStep)?State_Idle:State_WaitDone;\n        default:\n            rNextState <= State_Idle;\n        endcase\n    \n    assign wModuleTriggered = (iCMDValid && iTargetID == 5'b00101 && iOpcode == 6'b000011);\n    assign oCMDReady = (rCurState == State_Idle);\n    \n    always @ (posedge iSystemClock)\n        if (iReset)\n        begin\n            rTargetWay <= {(NumberOfWays){1'b0}};\n            rTrfLength  <= 16'b0;\n            rColAddress <= 16'b0;\n            rRowAddress <= 24'b0;\n        end\n        else\n            if (wModuleTriggered && (rCurState == State_Idle))\n            begin\n                rTargetWay  <= iWaySelect   ;\n                rTrfLength  <= iLength      ;\n                rColAddress <= iColAddress  ;\n                rRowAddress <= iRowAddress  ;\n            end\n    \n    always @ (*)\n        case (rCurState)\n        State_NPBRIssue:\n            rPMTrigger <= 8'b0100_0000;\n        State_NCmdIssue:\n            rPMTrigger <= 8'b0000_1000;\n        State_NTimer1Issue:\n            rPMTrigger <= 8'b0000_0001;\n        State_DIIssue:\n            rPMTrigger <= 8'b0000_0010;\n        State_NTimer2Issue:\n            rPMTrigger <= 8'b0000_0001;\n        default:\n            rPMTrigger <= 8'b0000_0000;\n        endcase\n    \n    always @ (*)\n        case (rCurState)\n        State_NTimer1Issue:\n            rPCommandOption[2:0] <= 3'b001; State_DIIssue:\n            rPCommandOption[2:0] <= 3'b001; State_NTimer2Issue:\n            rPCommandOption[2:0] <= 3'b100;\n        default:\n            rPCommandOption[2:0] <= 0;\n        endcase\n    \n    always @ (*)\n        if (iReset)\n            rPMLength <= 0;\n        else\n            case (rCurState)\n            State_NCmdIssue:\n                rPMLength <= 16'd3;\n            State_NTimer1Issue:\n                rPMLength <= 16'd33; State_DIIssue:\n                rPMLength <= rTrfLength;\n            State_NTimer2Issue:\n                rPMLength <= 16'd3; default:\n                rPMLength <= 0;\n            endcase\n        \n    always @ (*)\n        case (rCurState)\n        State_NCmdWrite0:\n            rPMCommandOrAddress <= 1'b0;\n        State_NCmdWrite1:\n            rPMCommandOrAddress <= 1'b1;\n        State_NCmdWrite2:\n            rPMCommandOrAddress <= 1'b1;\n        State_NCmdWrite3:\n            rPMCommandOrAddress <= 1'b0;\n        default:\n            rPMCommandOrAddress <= 1'b0;\n        endcase\n    \n    always @ (*)\n        if (iReset)\n            rCAData <= 0;\n        else\n            case (rCurState)\n            State_NCmdWrite0:\n                rCAData <= 8'h05;\n            State_NCmdWrite1:\n                rCAData <= rColAddress[7:0];\n            State_NCmdWrite2:\n                rCAData <= rColAddress[15:8];\n            State_NCmdWrite3:\n                rCAData <= 8'hE0;\n            default:\n                rCAData <= 0;\n            endcase\n    \n    assign oStart = wModuleTriggered;\n    assign oLastStep            = (rCurState == State_WaitDone) & iPM_LastStep[0];\n    \n    assign oReadData            = iPM_ReadData;\n    assign oReadLast            = iPM_ReadLast;\n    assign oReadValid           = iPM_ReadValid;\n    assign oPM_ReadReady        = iReadReady;\n    \n    assign oPM_PCommand         = rPMTrigger;\n    assign oPM_PCommandOption   = rPCommandOption; assign oPM_TargetWay        = rTargetWay;\n    assign oPM_NumOfData        = rPMLength ;\n    assign oPM_CASelect         = rPMCommandOrAddress;\n    assign oPM_CAData           = rCAData;\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "var20_multi_c906ec5f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule var20_multi (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, valid);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T;\n    output valid;\n\n    wire [8:0] min_value = 9'd120;\n    wire [8:0] max_weight = 9'd60;\n    wire [8:0] max_volume = 9'd60;\nwire [8:0]  total_value = \n        A * 9'd4\n      + B * 9'd8\n      + C * 9'd0\n      + D * 9'd20\n      + E * 9'd10\n      + F * 9'd12\n      + G * 9'd18\n      + H * 9'd14\n      + I * 9'd6\n      + J * 9'd15\n      + K * 9'd30\n      + L * 9'd8\n      + M * 9'd16\n      + N * 9'd18\n      + O * 9'd18\n      + P * 9'd14\n      + Q * 9'd7\n      + R * 9'd7\n      + S * 9'd29\n      + T * 9'd23;\n\n    wire [8:0]  total_weight = \n        A * 9'd28\n      + B * 9'd8\n      + C * 9'd27\n      + D * 9'd18\n      + E * 9'd27\n      + F * 9'd28\n      + G * 9'd6\n      + H * 9'd1\n      + I * 9'd20\n      + J * 9'd0\n      + K * 9'd5\n      + L * 9'd13\n      + M * 9'd8\n      + N * 9'd14\n      + O * 9'd22\n      + P * 9'd12\n      + Q * 9'd23\n      + R * 9'd26\n      + S * 9'd1\n      + T * 9'd22;\n\n    wire [8:0]  total_volume = \n        A * 9'd27\n      + B * 9'd27\n      + C * 9'd4\n      + D * 9'd4\n      + E * 9'd0\n      + F * 9'd24\n      + G * 9'd4\n      + H * 9'd20\n      + I * 9'd12\n      + J * 9'd15\n      + K * 9'd5\n      + L * 9'd2\n      + M * 9'd9\n      + N * 9'd28\n      + O * 9'd19\n      + P * 9'd18\n      + Q * 9'd30\n      + R * 9'd12\n      + S * 9'd28\n      + T * 9'd13;\n\nassign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume));\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__6a955f49", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    input [31:0] in,\n    output reg [7:0] sum\n);\n\n// Rotator module with synchronous load input\nreg [99:0] rot_data;\nreg [31:0] rot_in;\nreg [31:0] rot_out;\nreg [4:0] rot_amt;\n\nalways @(posedge clk) begin\n    if (load) begin\n        rot_data <= data;\n        rot_in <= in;\n        rot_amt <= rot_in[4:0];\n    end else if (ena[0]) begin\n        rot_data <= {rot_data[99-rot_amt:0], rot_data[99:99-rot_amt]};\n    end else if (ena[1]) begin\n        rot_data <= {rot_data[99-rot_amt:0], rot_data[99:99-rot_amt]};\n        rot_out <= {rot_data[31:24], rot_data[23:16], rot_data[15:8], rot_data[7:0]};\n    end\nend\n\n// Byte ordering module\nreg [31:0] byte_in;\nreg [31:0] byte_out;\n\nalways @(posedge clk) begin\n    if (ena[1]) begin\n        byte_in <= rot_out;\n        byte_out <= {byte_in[7:0], byte_in[15:8], byte_in[23:16], byte_in[31:24]};\n    end\nend\n\n// Functional module to calculate sum of bytes\nalways @(posedge clk) begin\n    if (ena[1]) begin\n        sum <= byte_out[7:0] + byte_out[15:8] + byte_out[23:16] + byte_out[31:24];\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_async_set_reset_e2bcf0a7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_async_set_reset (\n    input wire D,\n    input wire SET_B,\n    input wire RESET_B,\n    input wire CLK,\n    output reg Q,\n    output reg Q_B\n    );\n    \n    always @(posedge CLK) begin\n        if (!RESET_B) begin\n            Q <= 1'b0;\n            Q_B <= 1'b1;\n        end else if (!SET_B) begin\n            Q <= 1'b1;\n            Q_B <= 1'b0;\n        end else begin\n            Q <= D;\n            Q_B <= ~D;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PmodDA4_Control_228575b2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PmodDA4_Control (\n  input clk,\n  input rst,\n  input [11:0] value, output reg SYNC,    output DATA,        output SCLK         );\n\nlocalparam stIDLE = 3'd0,\n           stINIT_irv = 3'd1,\n           stTRAN_irv = 3'd2,\n           stINIT = 3'd3,\n           stTRAN = 3'd4;\n\nwire [31:0] temp;\nreg [2:0] state;\nreg [4:0] index;\n\nassign temp = ((state == stINIT_irv) || (state == stTRAN_irv)) ? {8'h8, 24'h1} : {12'h3F, value, 8'h0};\nassign DATA = temp[index];\nassign SCLK = clk;\n\nalways @(negedge clk) begin\n  if (rst) begin\n    state <= stIDLE;\n    index <= 5'd31;\n    SYNC <= 1'b0;\n  end else begin\n    case (state)\n      stIDLE: begin\n        state <= stINIT_irv;\n        index <= 5'd31;\n        SYNC <= 1'b1;\n      end\n      stINIT_irv: begin\n        state <= stTRAN_irv;\n        index <= 5'd31;\n        SYNC <= 1'b0;\n      end\n      stTRAN_irv: begin\n        state <= (index == 0) ? stINIT : stTRAN_irv;\n        index <= index - 1'b1;\n        SYNC <= (index == 0) ? 1'b1 : 1'b0;\n      end\n      stINIT: begin\n        state <= stTRAN;\n        index <= 5'd31;\n        SYNC <= 1'b0;\n      end\n      stTRAN: begin\n        state <= (index == 0) ? stINIT : stTRAN;\n        index <= index - 1'b1;\n        SYNC <= (index == 0) ? 1'b1 : 1'b0;\n      end\n      default: begin\n        state <= stIDLE;\n        index <= 5'd31;\n        SYNC <= 1'b1;\n      end \n    endcase\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_378acb50", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register(\n    input clk, \n    input shift, \n    input in,\n    output reg out\n);\n  reg [3:0] reg_out;\n\n  always @(posedge clk) begin\n    if (shift) begin\n      reg_out <= {reg_out[2:0], in};\n    end else begin\n      reg_out <= {in, reg_out[3:1]};\n    end\n  end\n\n  always @*\n    out = reg_out[0];\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spi_core_a74ed195", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule spi_core (\n   o_sdo, o_drvb, o_spi_active, o_rx_valid, vo_byte_num, vo_data_rx,\n   i_rstb, i_cs, i_sck, i_sdi, i_epol, i_cpol, i_cpha, vi_data_tx\n   );\n   parameter BITS_IN_BYTE = 8;\n   parameter NBIT_BIT_CTR = 3;\n   parameter NBIT_BYTE_CTR = 3;\n   \n   input \t\t      i_rstb;\n   input \t\t      i_cs; input \t\t      i_sck; input \t\t      i_sdi; output \t\t      o_sdo; output \t\t      o_drvb; input \t\t      i_epol; input \t\t      i_cpol; input \t\t      i_cpha;\n   output \t\t      o_spi_active; output \t\t      o_rx_valid; output [NBIT_BYTE_CTR-1:0] vo_byte_num; input [BITS_IN_BYTE-1:0]   vi_data_tx; output [BITS_IN_BYTE-1:0]  vo_data_rx; reg \t\t\t      o_rx_valid;\n   reg [NBIT_BYTE_CTR-1:0]    vo_byte_num;\n\n   \n   wire \t\t      chip_select; \n   wire \t\t      sck_core; \n   assign chip_select = i_rstb && (i_epol ^ i_cs);\n   assign o_spi_active = chip_select;\n   assign sck_core = i_cpha ^ i_cpol ^ i_sck;\n   assign o_drvb = !chip_select;\n   \n   reg [BITS_IN_BYTE-1:0]     rv_tx;\n   reg [NBIT_BIT_CTR-1:0]     rv_tx_ptr;\n   always @( negedge sck_core or negedge chip_select ) begin : tx_fsm\n      if ( !chip_select ) begin\n\t rv_tx_ptr <= $unsigned(BITS_IN_BYTE - 1);\n\t vo_byte_num <= 0;\n\t rv_tx <= 0;\n      end else begin\n\t if ( 0 == rv_tx_ptr ) begin\n\t    rv_tx <= vi_data_tx;\n\t    rv_tx_ptr <= $unsigned(BITS_IN_BYTE - 1);\n\t    vo_byte_num <= vo_byte_num + 1;\n\t end else begin\n\t    rv_tx_ptr <= rv_tx_ptr - 1;\n\t end\n      end end assign o_sdo = rv_tx[rv_tx_ptr];\n   \n   reg [BITS_IN_BYTE-2:0]     rv_rx;\n   always @( posedge sck_core or negedge chip_select ) begin : rx_fsm\n      if ( !chip_select ) begin\n\t rv_rx <= 0;\n         o_rx_valid <= 0;\n      end else begin\n\t if ( 0 == rv_tx_ptr ) begin\n\t    o_rx_valid <= 1;   \n\t end else begin\n\t    o_rx_valid <= 0;\n            rv_rx[BITS_IN_BYTE-2:1] <= rv_rx[BITS_IN_BYTE-3:0];\n\t    rv_rx[0] <= i_sdi;\n\t end end end assign vo_data_rx = {rv_rx,i_sdi};\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sha512_w_mem_07e2a8a8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule sha512_w_mem(\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire [1023 : 0] block,\n\n                    input wire            init,\n                    input wire            next,\n                    output wire [63 : 0]  w\n                   );\n\n\n  reg [63 : 0] w_mem [0 : 15];\n  reg [63 : 0] w_mem00_new;\n  reg [63 : 0] w_mem01_new;\n  reg [63 : 0] w_mem02_new;\n  reg [63 : 0] w_mem03_new;\n  reg [63 : 0] w_mem04_new;\n  reg [63 : 0] w_mem05_new;\n  reg [63 : 0] w_mem06_new;\n  reg [63 : 0] w_mem07_new;\n  reg [63 : 0] w_mem08_new;\n  reg [63 : 0] w_mem09_new;\n  reg [63 : 0] w_mem10_new;\n  reg [63 : 0] w_mem11_new;\n  reg [63 : 0] w_mem12_new;\n  reg [63 : 0] w_mem13_new;\n  reg [63 : 0] w_mem14_new;\n  reg [63 : 0] w_mem15_new;\n  reg          w_mem_we;\n\n  reg [6 : 0] w_ctr_reg;\n  reg [6 : 0] w_ctr_new;\n  reg         w_ctr_we;\n\n\n  reg [63 : 0] w_tmp;\n  reg [63 : 0] w_new;\n\n\n  assign w = w_tmp;\n\n\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0; i < 16; i = i + 1)\n            w_mem[i] <= 64'h0;\n\n          w_ctr_reg <= 7'h0;\n        end\n      else\n        begin\n          if (w_mem_we)\n            begin\n              w_mem[00] <= w_mem00_new;\n              w_mem[01] <= w_mem01_new;\n              w_mem[02] <= w_mem02_new;\n              w_mem[03] <= w_mem03_new;\n              w_mem[04] <= w_mem04_new;\n              w_mem[05] <= w_mem05_new;\n              w_mem[06] <= w_mem06_new;\n              w_mem[07] <= w_mem07_new;\n              w_mem[08] <= w_mem08_new;\n              w_mem[09] <= w_mem09_new;\n              w_mem[10] <= w_mem10_new;\n              w_mem[11] <= w_mem11_new;\n              w_mem[12] <= w_mem12_new;\n              w_mem[13] <= w_mem13_new;\n              w_mem[14] <= w_mem14_new;\n              w_mem[15] <= w_mem15_new;\n            end\n\n          if (w_ctr_we)\n              w_ctr_reg <= w_ctr_new;\n        end\n    end always @*\n    begin : select_w\n      if (w_ctr_reg < 16)\n        w_tmp = w_mem[w_ctr_reg[3 : 0]];\n      else\n        w_tmp = w_new;\n    end always @*\n    begin : w_mem_update_logic\n      reg [63 : 0] w_0;\n      reg [63 : 0] w_1;\n      reg [63 : 0] w_9;\n      reg [63 : 0] w_14;\n      reg [63 : 0] d0;\n      reg [63 : 0] d1;\n\n      w_mem00_new = 64'h0;\n      w_mem01_new = 64'h0;\n      w_mem02_new = 64'h0;\n      w_mem03_new = 64'h0;\n      w_mem04_new = 64'h0;\n      w_mem05_new = 64'h0;\n      w_mem06_new = 64'h0;\n      w_mem07_new = 64'h0;\n      w_mem08_new = 64'h0;\n      w_mem09_new = 64'h0;\n      w_mem10_new = 64'h0;\n      w_mem11_new = 64'h0;\n      w_mem12_new = 64'h0;\n      w_mem13_new = 64'h0;\n      w_mem14_new = 64'h0;\n      w_mem15_new = 64'h0;\n      w_mem_we    = 0;\n\n      w_0  = w_mem[0];\n      w_1  = w_mem[1];\n      w_9  = w_mem[9];\n      w_14 = w_mem[14];\n\n      d0 = {w_1[0],     w_1[63 : 1]} ^ {w_1[7 : 0], w_1[63 : 8]} ^ {7'b0000000, w_1[63 : 7]};  d1 = {w_14[18 : 0], w_14[63 : 19]} ^ {w_14[60 : 0], w_14[63 : 61]} ^ {6'b000000,    w_14[63 : 6]};   w_new = w_0 + d0 + w_9 + d1;\n\n      if (init)\n        begin\n          w_mem00_new = block[1023 : 960];\n          w_mem01_new = block[959  : 896];\n          w_mem02_new = block[895  : 832];\n          w_mem03_new = block[831  : 768];\n          w_mem04_new = block[767  : 704];\n          w_mem05_new = block[703  : 640];\n          w_mem06_new = block[639  : 576];\n          w_mem07_new = block[575  : 512];\n          w_mem08_new = block[511  : 448];\n          w_mem09_new = block[447  : 384];\n          w_mem10_new = block[383  : 320];\n          w_mem11_new = block[319  : 256];\n          w_mem12_new = block[255  : 192];\n          w_mem13_new = block[191  : 128];\n          w_mem14_new = block[127  :  64];\n          w_mem15_new = block[63   :   0];\n          w_mem_we    = 1;\n        end\n\n      if (next && (w_ctr_reg > 15))\n        begin\n          w_mem00_new = w_mem[01];\n          w_mem01_new = w_mem[02];\n          w_mem02_new = w_mem[03];\n          w_mem03_new = w_mem[04];\n          w_mem04_new = w_mem[05];\n          w_mem05_new = w_mem[06];\n          w_mem06_new = w_mem[07];\n          w_mem07_new = w_mem[08];\n          w_mem08_new = w_mem[09];\n          w_mem09_new = w_mem[10];\n          w_mem10_new = w_mem[11];\n          w_mem11_new = w_mem[12];\n          w_mem12_new = w_mem[13];\n          w_mem13_new = w_mem[14];\n          w_mem14_new = w_mem[15];\n          w_mem15_new = w_new;\n          w_mem_we    = 1;\n        end\n    end always @*\n    begin : w_ctr\n      w_ctr_new = 7'h0;\n      w_ctr_we  = 1'h0;\n\n      if (init)\n        begin\n          w_ctr_new = 7'h00;\n          w_ctr_we  = 1'h1;\n        end\n\n      if (next)\n        begin\n          w_ctr_new = w_ctr_reg + 7'h01;\n          w_ctr_we  = 1'h1;\n        end\n    end endmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_mux_57b07ab3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule comparator_mux (\n    input [1:0] comp_in1, // 2-bit input for the comparator\n    input [1:0] comp_in2, // 2-bit input for the comparator\n    input [7:0] mux_in, // 4 2-bit inputs for the multiplexer\n    input [1:0] select, // 2-bit select input for the multiplexer\n    input control, // Control input to choose between the comparator and the multiplexer\n    output [1:0] out // 2-bit output from the selected module\n);\n\n    // Comparator module\n    wire [1:0] comp_out;\n    // comparator comp(\n    //     .in1(comp_in1),\n    //     .in2(comp_in2),\n    //     .out(comp_out)\n    // );\n\n    // Multiplexer module\n    wire [1:0] mux_out;\n    // mux4to1 mux(\n    //     .in0(mux_in[1:0]),\n    //     .in1(mux_in[3:2]),\n    //     .in2(mux_in[5:4]),\n    //     .in3(mux_in[7:6]),\n    //     .sel(select),\n    //     .out(mux_out)\n    // );\n\n    // Output selection based on control input\n    assign out = control ? mux_out : comp_out;\n\nendmodule\nmodule comparator (\n    input [1:0] in1, // 2-bit input 1\n    input [1:0] in2, // 2-bit input 2\n    output [1:0] out // 2-bit output\n);\n\n    assign out[0] = (in1[0] > in2[0]) ? 1'b1 : 1'b0;\n    assign out[1] = (in1[1] > in2[1]) ? 1'b1 : 1'b0;\n    assign out = (in1 == in2) ? 2'b11 : out;\n\nendmodule\nmodule mux4to1 (\n    input [1:0] in0, // 2-bit input 0\n    input [1:0] in1, // 2-bit input 1\n    input [1:0] in2, // 2-bit input 2\n    input [1:0] in3, // 2-bit input 3\n    input [1:0] sel, // 2-bit select input\n    output [1:0] out // 2-bit output\n);\n\n    assign out = (sel == 2'b00) ? in0 :\n                 (sel == 2'b01) ? in1 :\n                 (sel == 2'b10) ? in2 :\n                                  in3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "asr_a59647e7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule asr(value1, value2, shift_hex, value_out, EN);\n\tinput [31:0] value1, value2;\n\tinput [3:0] shift_hex;\n\toutput [31:0] value_out;\n\tinput EN;\n\n\twire or_unary = |value2[31:5];\n\twire value2_shrink = value2[4:0];\n\n\twire [4:0] shift_amt = (value2_shrink== 32'b0) ? \n\t\t( {1'b0, shift_hex} + 5'b1) : (value2_shrink + {1'b0, shift_hex});\n\n\tassign value_out = (or_unary==1'b1) ? 32'b0 : (\n\t\t(shift_amt == 5'b00000) ? value1[31:0] :\n\t\t(shift_amt == 5'b00001) ? {{01{value1[31]}}, value1[31:01]} :\n\t\t(shift_amt == 5'b00010) ? {{02{value1[31]}}, value1[31:02]} :\n\t\t(shift_amt == 5'b00011) ? {{03{value1[31]}}, value1[31:03]} :\n\t\t(shift_amt == 5'b00100) ? {{04{value1[31]}}, value1[31:04]} :\n\t\t(shift_amt == 5'b00101) ? {{05{value1[31]}}, value1[31:05]} :\n\t\t(shift_amt == 5'b00110) ? {{06{value1[31]}}, value1[31:06]} :\n\t\t(shift_amt == 5'b00111) ? {{07{value1[31]}}, value1[31:07]} :\n\t\t(shift_amt == 5'b01000) ? {{08{value1[31]}}, value1[31:08]} :\n\t\t(shift_amt == 5'b01001) ? {{09{value1[31]}}, value1[31:09]} :\n\t\t(shift_amt == 5'b01010) ? {{10{value1[31]}}, value1[31:10]} :\n\t\t(shift_amt == 5'b01011) ? {{11{value1[31]}}, value1[31:11]} :\n\t\t(shift_amt == 5'b01100) ? {{12{value1[31]}}, value1[31:12]} :\n\t\t(shift_amt == 5'b01101) ? {{13{value1[31]}}, value1[31:13]} :\n\t\t(shift_amt == 5'b01110) ? {{14{value1[31]}}, value1[31:14]} :\n\t\t(shift_amt == 5'b01111) ? {{15{value1[31]}}, value1[31:15]} :\n\t\t(shift_amt == 5'b10000) ? {{16{value1[31]}}, value1[31:16]} :\n\t\t(shift_amt == 5'b10001) ? {{17{value1[31]}}, value1[31:17]} :\n\t\t(shift_amt == 5'b10010) ? {{18{value1[31]}}, value1[31:18]} :\n\t\t(shift_amt == 5'b10011) ? {{19{value1[31]}}, value1[31:19]} :\n\t\t(shift_amt == 5'b10100) ? {{20{value1[31]}}, value1[31:20]} :\n\t\t(shift_amt == 5'b10101) ? {{21{value1[31]}}, value1[31:21]} :\n\t\t(shift_amt == 5'b10110) ? {{22{value1[31]}}, value1[31:22]} :\n\t\t(shift_amt == 5'b10111) ? {{23{value1[31]}}, value1[31:23]} :\n\t\t(shift_amt == 5'b11000) ? {{24{value1[31]}}, value1[31:24]} :\n\t\t(shift_amt == 5'b11001) ? {{25{value1[31]}}, value1[31:25]} :\n\t\t(shift_amt == 5'b11010) ? {{26{value1[31]}}, value1[31:26]} :\n\t\t(shift_amt == 5'b11011) ? {{27{value1[31]}}, value1[31:27]} :\n\t\t(shift_amt == 5'b11100) ? {{28{value1[31]}}, value1[31:28]} :\n\t\t(shift_amt == 5'b11101) ? {{29{value1[31]}}, value1[31:29]} :\n\t\t(shift_amt == 5'b11110) ? {{30{value1[31]}}, value1[31:30]} :\n\t\t(shift_amt == 5'b11111) ? {{31{value1[31]}}, value1[31]} : 32'b0);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_ar_1d05d5aa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_ar (\n  input clk, rst, d,\n  output reg q\n);\n\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      q <= 0;\n    end else begin\n      q <= d;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SRFF_sp_68454588", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule SRFF_sp(\n  input   clock,\n  input   reset,\n  input   io_input_set,\n  input   io_input_reset,\n  input   io_input_asyn_reset,\n  output  io_output_data\n);\n  reg  _T_14;\n  reg [31:0] _GEN_0;\n  wire  _T_18;\n  wire  _T_19;\n  wire  _T_20;\n  wire  _T_22;\n  assign io_output_data = _T_22;\n  assign _T_18 = io_input_reset ? 1'h0 : _T_14;\n  assign _T_19 = io_input_set ? 1'h1 : _T_18;\n  assign _T_20 = io_input_asyn_reset ? 1'h0 : _T_19;\n  assign _T_22 = io_input_asyn_reset ? 1'h0 : _T_14;\n`ifdef RANDOMIZE\n  integer initvar;\n  initial begin\n    `ifndef verilator\n      #0.002 begin end\n    `endif\n  `ifdef RANDOMIZE_REG_INIT\n  _GEN_0 = {1{$random}};\n  _T_14 = _GEN_0[0:0];\n  `endif\n  end\n`endif\n  always @(posedge clock) begin\n    if (reset) begin\n      _T_14 <= 1'h0;\n    end else begin\n      if (io_input_asyn_reset) begin\n        _T_14 <= 1'h0;\n      end else begin\n        if (io_input_set) begin\n          _T_14 <= 1'h1;\n        end else begin\n          if (io_input_reset) begin\n            _T_14 <= 1'h0;\n          end\n        end\n      end\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4_1_6e1f4fe3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4_1 (\n    X ,\n    A0,\n    A1,\n    A2,\n    A3,\n    S0,\n    S1\n);\n\n    output X ;\n    input  A0;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  S0;\n    input  S1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire [3:0] data;\n    \n    assign data[0] = A0;\n    assign data[1] = A1;\n    assign data[2] = A2;\n    assign data[3] = A3;\n    \n    assign X = (S1 & S0 == 2'b00) ? data[0] :\n               (S1 & S0 == 2'b01) ? data[1] :\n               (S1 & S0 == 2'b10) ? data[2] :\n               (S1 & S0 == 2'b11) ? data[3] : 1'bx;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "regfile_f664440c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule regfile(clk, raddr1, dout1, raddr2, dout2, wr, waddr, din, R1, R2, nrst);\n    input           clk;\n    input           wr;\n    input   [4:0]   raddr1, raddr2, waddr;\n    input   [31:0]  din;\n    output  [31:0]  dout1, dout2;\n    output  [7:0]   R2;\n    output  [2:0]   R1;\n    input           nrst;\n\n    reg [31:0] mem[0:31];\n    reg [31:0] dout1_reg, dout2_reg;\n    reg [2:0]  R1_reg;\n    reg [7:0]  R2_reg;\n\n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            mem[5'b00001] <= 32'b0;\n        end else begin\n            if (wr) begin\n                mem[waddr] <= din;\n            end\n            dout1_reg <= mem[raddr1];\n            dout2_reg <= mem[raddr2];\n            R1_reg <= mem[5'b00001][31:29];\n            R2_reg <= mem[4'b0010][7:0];\n        end\n    end\n\n    assign dout1 = (raddr1 == 5'b0) ? 32'b0 : dout1_reg;\n    assign dout2 = (raddr2 == 5'b0) ? 32'b0 : dout2_reg;\n    assign R1 = R1_reg;\n    assign R2 = R2_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "glitch_free_mux #_ec74aca5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule glitch_free_mux #(\n  parameter n = 4 // number of clock signals\n) (\n  input [n-1:0] clk,\n  input sel,\n  output reg sys_clk \n);\n\nreg [n-1:0] prev_clk; // previous clock signal\nreg [n-1:0] cur_clk; // current clock signal\n\nalways @ (posedge clk[0]) begin // Use a single edge-sensitive clock for the first always block\n  if (sel) begin\n    prev_clk <= cur_clk;\n    cur_clk <= clk;\n  end\nend\n\nalways @* begin // Use an always block to assign `sys_clk`\n  sys_clk = (cur_clk == prev_clk) ? cur_clk : prev_clk;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_module_94befad5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule memory_module(\n    input cpu_clock,\n    input memreg_rd,\n    input [10:0] a,\n    input din,\n    input volports_enabled,\n    input port_wr,\n    output reg snd_wrtoggle,\n    output reg snd_datnvol,\n    output reg [2:0] snd_addr,\n    output reg [7:0] snd_data,\n    input [2:0] volnum\n);\n\nreg mode_8chans;\n\ninitial begin\n    // Initialize the outputs\n    snd_wrtoggle <= 1'b0;\n    snd_datnvol <= 1'b1;\n    mode_8chans <= 0; // Initialize mode to 4 channels\nend\n\nalways @ (posedge cpu_clock) begin\n    if (memreg_rd) begin\n        // Update the outputs on a memory read\n        snd_wrtoggle <= ~snd_wrtoggle;\n        snd_datnvol <= 1'b1;\n        if (!mode_8chans) begin\n            snd_addr <= {1'b0, a[9:8]};\n        end else begin\n            snd_addr <= a[10:8];\n        end\n        snd_data <= din;\n    end else if (volports_enabled && port_wr) begin\n        // Update the outputs on a volume port write\n        snd_wrtoggle <= ~snd_wrtoggle;\n        snd_datnvol <= 1'b0;\n        snd_addr <= volnum;\n        snd_data <= din;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "queue #_5ccc165c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule queue #\n    (\n    parameter integer WIDTH = 108,\n    parameter integer LENGTH = 4\n    )\n    (\n    input wire GCLK,\n    input wire RES,\n    input wire get,\n    input wire put,\n    output reg full = 1'b0,\n    output reg empty = 1'b1,\n    input wire [WIDTH-1:0] DIN,\n    output reg [WIDTH-1:0] DOUT\n    );\n    \n    reg [WIDTH-1:0] q[0:LENGTH-1];\n    reg [63:0] head = 64'd0; reg get_release = 1'b1;\n    reg put_release = 1'b1;\n    \n    wire to_get;\n    wire to_put;\n    assign to_get = get & get_release;\n    assign to_put = put & put_release;\n\n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            get_release <= 1'b1;\n        end\n        else if (get == 1'b0) begin\n            get_release <= 1'b1;\n        end\n        else if (to_get == 1'b1) begin\n            get_release <= 1'b0;\n        end\n        \n        if (RES == 1'b1) begin\n            put_release <= 1'b1;\n        end\n        else if (put == 1'b0) begin\n            put_release <= 1'b1;\n        end\n        else if (to_put == 1'b1) begin\n            put_release <= 1'b0;\n        end\n    end\n\n    integer i = 0;\n    always @(posedge GCLK) begin\n        if (to_put & !to_get) begin\n            for (i = LENGTH - 1; i > 0; i = i - 1) begin\n                q[i] <= q[i - 1];\n            end\n            q[0] <= DIN;\n        end\n        \n        if (to_get &  !to_put & !empty) begin\n            DOUT <= q[head - 64'd1];\n        end\n        else if (to_get & to_put) begin\n            DOUT <= DIN;\n        end\n    end\n    \n    always @(posedge GCLK) begin\n        if (RES == 1'b1) begin\n            head <= 64'd0;\n            full <= 1'b0;\n            empty <= 1'b1;\n        end\n        else if (!full & to_put & !to_get) begin\n            head <= head + 64'd1;\n            empty <= 1'b0; if (head == LENGTH - 1) begin\n                full <= 1'b1;\n            end\n        end\n        else if (!empty & to_get & !to_put) begin\n            head <= head - 64'd1;\n            full <= 1'b0; if (head == 64'd1) begin\n                empty <= 1'b1;\n            end\n        end\n        else begin\n            head <= head;\n            full <= full;\n            empty <= empty;\n        end\n    end\n    \n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__lpflow_inputiso1p_284111c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__lpflow_inputiso1p (\n    X    ,\n    A    ,\n    SLEEP\n);\n\n    output X    ;\n    input  A    ;\n    input  SLEEP;\n\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DTR_3dbf2758", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule DTR(\n    input STARTPULSE,\n    output reg DTROUT7, DTROUT6, DTROUT5, DTROUT4, DTROUT3, DTROUT2, DTROUT1, DTROUT0\n);\n\nreg [2:0] counter;\n\nalways @(posedge STARTPULSE) begin\n    counter <= counter + 1;\n    if (counter == 3) begin\n        {DTROUT7, DTROUT6, DTROUT5, DTROUT4, DTROUT3, DTROUT2, DTROUT1, DTROUT0} <= {8{1'b0}};\n        DTROUT7 <= 1;\n    end else if (counter == 2) begin\n        DTROUT6 <= 1;\n    end else if (counter == 1) begin\n        DTROUT5 <= 1;\n    end else if (counter == 0) begin\n        DTROUT4 <= 1;\n        DTROUT3 <= 1;\n        DTROUT2 <= 1;\n        DTROUT1 <= 1;\n        DTROUT0 <= 1;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__a221o_bfbfe197", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__a221o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2                );\n    and and1 (and1_out , A1, A2                );\n    or  or0  (or0_out_X, and1_out, and0_out, C1);\n    buf buf0 (X        , or0_out_X             );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__1e58b2e6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [3:0] D,\n    input SEL,\n    input clk,\n    output reg [3:0] OUT\n);\n\n    wire [3:0] Y;\n    wire [3:0] C;\n    wire [3:0] ADD_OUT;\n\n    decoder_2to4_with_enable decoder (\n        .D(SEL),\n        .E(D[3]),\n        .Y(Y)\n    );\n\n    twos_comp_converter twos_comp (\n        .D(D),\n        .C(C)\n    );\n\n    adder_4bit adder (\n        .A(Y),\n        .B(C),\n        .CIN(1'b0),\n        .S(ADD_OUT)\n    );\n\n    always @(posedge clk) begin\n        if (SEL == 0) begin\n            OUT <= Y[D[1:0]];\n        end else begin\n            OUT <= ADD_OUT;\n        end\n    end\n\nendmodule\n\nmodule decoder_2to4_with_enable (\n    input D,\n    input E,\n    output reg [3:0] Y\n);\n\n    always @* begin\n        case ({E, D})\n            2'b00: Y = 4'b0001;\n            2'b01: Y = 4'b0010;\n            2'b10: Y = 4'b0100;\n            2'b11: Y = 4'b1000;\n            default: Y = 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule twos_comp_converter (\n    input [3:0] D,\n    output reg [3:0] C\n);\n\n    always @* begin\n        C = ~D + 4'b1;\n    end\n\nendmodule\n\nmodule adder_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output reg [3:0] S\n);\n\n    always @* begin\n        S = A + B + CIN;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "constant_voltage_driver_63040ac0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule constant_voltage_driver (\n  input clk,\n  input rst,\n  input ctrl,\n  output reg vout\n);\n\nparameter voltage_level = 1800; // desired voltage level of the output signal in mV\nparameter rise_time = 10; // time required for the output signal to rise to the desired voltage level in ns\nparameter fall_time = 20; // time required for the output signal to fall from the desired voltage level in ns\n\nreg [31:0] rise_counter;\nreg [31:0] fall_counter;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    vout <= 0;\n    rise_counter <= 0;\n    fall_counter <= 0;\n  end\n  else begin\n    if (ctrl) begin\n      if (rise_counter < rise_time) begin\n        rise_counter <= rise_counter + 1;\n        vout <= (rise_counter * voltage_level) / rise_time;\n      end\n      else begin\n        vout <= voltage_level;\n      end\n      fall_counter <= 0;\n    end\n    else begin\n      if (fall_counter < fall_time) begin\n        fall_counter <= fall_counter + 1;\n        vout <= voltage_level - ((fall_counter * voltage_level) / fall_time);\n      end\n      else begin\n        vout <= 0;\n      end\n      rise_counter <= 0;\n    end\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "read_304043fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule read(reset, readbitclk, readbitout, readbitdone, \n           read_sample_ctl, read_sample_clk, read_sample_datain, \n           handle);\ninput  reset, readbitclk;\noutput readbitout, readbitdone;\ninput  read_sample_datain;\noutput read_sample_ctl, read_sample_clk;\ninput [15:0] handle;\n  \nwire [32:0] packet;\nassign packet[32]    = 1'b0;\nassign packet[31:16] = 16'h0000;\nassign packet[15:0]  = handle[15:0];\n\nreg [5:0] bitoutcounter;\nreg read_sample_ctl;\n\nwire read_sample_clk, readbitout, readbitdone;\n\nassign read_sample_clk = readbitclk & (bitoutcounter > 15);\nassign readbitout = (bitoutcounter!=32 && bitoutcounter>15) ? read_sample_datain : packet[bitoutcounter];\nassign readbitdone = (bitoutcounter == 0);\nreg    initialized;\n\nalways @ (posedge readbitclk or posedge reset) begin\n  if (reset) begin\n    bitoutcounter   <= 0;\n    initialized     <= 0;\n    read_sample_ctl <= 0;\n  end else if (!initialized) begin\n    initialized     <= 1;\n    read_sample_ctl <= 1;\n    bitoutcounter   <= 32;\n  end else if (!readbitdone) begin\n    bitoutcounter <= bitoutcounter - 4'd1;\n    if (bitoutcounter >= 15) read_sample_ctl <= 1;\n    else                     read_sample_ctl <= 0;\n  end else begin\n    read_sample_ctl<= 0;\n  end end endmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "address_generator_3036b658", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule address_generator (\n    clk,\n    rst_n,\n    strand_offset,\n    strand_idx,\n    strand_length,\n    addr\n);\n\n    parameter MEM_ADDR_WIDTH = 24;\n    parameter STRAND_PARAM_WIDTH = 16;\n\n    input clk;\n    input rst_n;\n\n    // The active strand will drive these three buses\n    input [STRAND_PARAM_WIDTH-1:0] strand_offset;\n    input [STRAND_PARAM_WIDTH-1:0] strand_idx;\n    input [STRAND_PARAM_WIDTH-1:0] strand_length;\n\n    output reg [MEM_ADDR_WIDTH-1:0] addr;\n\n    // Address generation process\n    always @(posedge clk) begin\n        if (rst_n == 1'b0) begin\n            addr <= { MEM_ADDR_WIDTH {1'b0} };\n        end\n        else begin\n            // address of memory is given by \n            // strand_offset[current] + (strand_idx[current] % strand_length[current])\n            if (strand_idx >= strand_length) begin\n                addr <= strand_offset + (strand_idx - strand_length);\n            end\n            else begin\n                addr <= strand_offset + strand_idx;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_generator_f4a8ce8b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clk_generator(\n    input clk,\n    input en,\n    input rst,\n    input [31:0] limit,\n    input [31:0] count,\n    output reg clk_0,\n    output reg done\n);\n\n    reg [31:0] ndCount;\n    reg [31:0] initCount;\n    \n    initial begin\n        clk_0 <= 1'b0;\n        ndCount <= 32'h00000000;\n        initCount <= count;\n    end\n    \n    always @(posedge clk or negedge rst) begin \n        if(~rst) begin\n            clk_0 <= 1'b0;\n            ndCount <= 32'h00000000;\n            done <= 1'b0;\n        end\n        else if(en) begin \n            if(ndCount < limit) begin\n                ndCount <= ndCount + 1;\n                clk_0 <= (ndCount == limit) ? ~clk_0 : clk_0;\n                done <= (ndCount == limit) ? 1'b1 : 1'b0;\n            end\n            else begin\n                ndCount <= initCount;\n                clk_0 <= 1'b0;\n                done <= 1'b1;\n            end\n        end\n        else begin\n            ndCount <= initCount;\n            clk_0 <= 1'b0;\n            done <= 1'b0;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_4bit_6b50be8e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter_4bit (\n    input [3:0] in,\n    input [1:0] shift,\n    input clk,\n    output reg [3:0] out\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nalways @(*) begin\n    case(shift)\n        2'b00: stage1_out = in << 1; // logical left shift\n        2'b01: stage1_out = in >> 1; // logical right shift\n        2'b10: stage1_out = {in[1:0], in[3:2]}; // arithmetic left shift\n        2'b11: stage1_out = {in[3:2], in[0]}; // arithmetic right shift\n    endcase\n    stage2_out <= stage1_out;\nend\n\nalways @(posedge clk) begin\n    out <= stage2_out;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_abd66b7c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input [7:0] in1,\n    input [7:0] in2,\n    input [1:0] opcode,\n    output reg [7:0] result,\n    output reg overflow\n);\n\nreg [8:0] temp;\n\nalways @(*)\nbegin\n    overflow <= 0;\n    case (opcode)\n        2'b00: // addition\n        begin\n            temp = in1 + in2;\n        end\n        2'b01: // subtraction\n        begin\n            temp = in1 - in2;\n        end\n        2'b10: // multiplication\n        begin\n            temp = in1 * in2;\n        end\n        2'b11: // division\n        begin\n            if (in2 == 0)\n            begin\n                temp = 0;\n                overflow <= 1;\n            end\n            else\n            begin\n                temp = in1 / in2;\n            end\n        end\n        default: // invalid opcode\n        begin\n            temp = 0;\n            overflow <= 1;\n        end\n    endcase\n    if (temp > 255 || temp < -256)\n        overflow <= 1;\n    result <= temp[7:0];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt51_noise_lfsr #_bf5bec03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule jt51_noise_lfsr #(parameter init=14220 )(\n\tinput\trst,\n\tinput\tclk,\n\tinput\tbase,\n\toutput\tout\n);\n\nreg [16:0] bb;\nassign out = bb[16];\n\nalways @(posedge clk) begin : base_counter\n\tif( rst ) begin\n\t\tbb\t\t\t<= init[16:0];\n\tend\n\telse begin\n\t\tif(  base ) begin\t\n\t\t\tbb[16:1] \t<= bb[15:0];\n\t\t\tbb[0]\t\t<= ~(bb[16]^bb[13]);\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CryptoBlock_5b7d4331", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule CryptoBlock (\n  input [m-1:0] plaintext,\n  input [k-1:0] key,\n  input [m-1:0] ciphertext,\n  input [m-1:0] message,\n  output [m-1:0] ciphertext_out,\n  output [m-1:0] plaintext_out,\n  output [n-1:0] hash_out\n);\n\nparameter k = 128; // length of secret key in bits\nparameter m = 256; // length of message in bits\nparameter n = 256; // length of hash in bits\n\nassign ciphertext_out = plaintext ^ key;\n\nassign plaintext_out = ciphertext ^ key;\n\nassign hash_out = message;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_counter_cf03a475", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sync_counter(\n  input clk,\n  input reset,\n  input enable,\n  output reg [3:0] out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      out <= 4'b0;\n    end else if (enable) begin\n      out <= out + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_adder_3c9fd382", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pipelined_adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] p, g, c;\n\n    assign p[0] = a[0] ^ b[0];\n    assign g[0] = a[0] & b[0];\n    assign c[0] = g[0];\n\n    genvar i;\n    generate\n        for (i = 1; i < 8; i = i + 1) begin\n            assign p[i] = a[i] ^ b[i] ^ c[i-1];\n            assign g[i] = (a[i] & b[i]) | (a[i] & c[i-1]) | (b[i] & c[i-1]);\n            assign c[i] = (a[i] & b[i]) | (g[i] & c[i-1]);\n        end\n    endgenerate\n\n    assign s = p ^ c;\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [7:0] p, g, c;\n    wire [7:0] p1, g1, c1;\n\n    pipelined_adder adder1(.a(a), .b(b), .s(p1), .overflow(overflow));\n    pipelined_adder adder2(.a(p1), .b(8'b0), .s(s), .overflow()); // 'overflow' is unconnected, this should not cause an error\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ROM_A_e89c2681", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ROM_A(\n    input [31:0] addr,\n    output [31:0] inst\n);\n\n    reg [31:0]instructions[128:0];\n    \n    initial begin\n        // Initialize ROM with instructions\n        instructions[0] = 32'h00000026;\n        instructions[1] = 32'h00210826;\n        instructions[2] = 32'h00421026;\n        instructions[3] = 32'h00631826;\n        instructions[4] = 32'h00842026;\n        instructions[5] = 32'h00a52826;\n        instructions[6] = 32'h00c63026;\n        instructions[7] = 32'h00e73826;\n        instructions[8] = 32'h01084026;\n        instructions[9] = 32'h01294826;\n        instructions[10] = 32'h014a5026;\n        instructions[11] = 32'h016b5826;\n        instructions[12] = 32'h018c6026;\n        instructions[13] = 32'h01ad6826;\n        instructions[14] = 32'h01ce7026;\n        instructions[15] = 32'h01ef7826;\n        instructions[16] = 32'h02108026;\n        instructions[17] = 32'h02318826;\n        instructions[18] = 32'h02529026;\n        instructions[19] = 32'h02739826;\n        instructions[20] = 32'h0294a026;\n        instructions[21] = 32'h02b5a826;\n        instructions[22] = 32'h02d6b026;\n        instructions[23] = 32'h02f7b826;\n        instructions[24] = 32'h0318c026;\n        instructions[25] = 32'h0339c826;\n        instructions[26] = 32'h035ad026;\n        instructions[27] = 32'h037bd826;\n        instructions[28] = 32'h039ce026;\n        instructions[29] = 32'h03bde826;\n        instructions[30] = 32'h03def026;\n        instructions[31] = 32'h03fff826;\n        instructions[32] = 32'h2108000a;\n        instructions[33] = 32'h21290001;\n        instructions[34] = 32'h214a0002;\n        instructions[35] = 32'h216b0003;\n        instructions[36] = 32'h218c0004;\n        instructions[37] = 32'h21ad000a;\n        instructions[38] = 32'h21ce000a;\n        instructions[39] = 32'h21ef000a;\n        instructions[40] = 32'h00892020;\n        instructions[41] = 32'h00aa2820;\n        instructions[42] = 32'h00cb3020;\n        instructions[43] = 32'h00ec3820;\n        instructions[44] = 32'h1488fffb;\n        instructions[45] = 32'h22100001;\n        instructions[46] = 32'h3c088000;\n        instructions[47] = 32'h00008827;\n        instructions[48] = 32'h00084042;\n        instructions[49] = 32'h02119024;\n        instructions[50] = 32'h01119825;\n        instructions[51] = 32'h0111a026;\n        instructions[52] = 32'h1408fffb;\n        instructions[53] = 32'h3c1500ff;\n        instructions[54] = 32'h22b500ff;\n        instructions[55] = 32'hac150320;\n        instructions[56] = 32'h8c160320;\n        instructions[57] = 32'h12b60000;\n        instructions[58] = 32'h00892022;\n        instructions[59] = 32'h00aa2822;\n        instructions[60] = 32'h00cb3022;\n        instructions[61] = 32'h00ec3822;\n        instructions[62] = 32'h00c0402a;\n        instructions[63] = 32'h1008fffa;\n        instructions[64] = 32'h0c000042;\n        instructions[65] = 32'h08000000;\n        instructions[66] = 32'h03e00008;\n    end\n    \n    // Output the instruction at the specified address\n    assign inst = instructions[addr];   \n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_counter #_ea2b2851", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule johnson_counter #(\n  parameter n = 16 // number of output signals\n)(\n  input clk,\n  output [n-1:0] out\n);\n\n\nreg [n-1:0] state; // register to hold current state\nwire [n-1:0] next_state; // wire to hold next state\n\n// define the flip-flops and their connections\nalways @(posedge clk) begin\n  state <= next_state;\nend\n\n// define the logic that generates the sequence of binary numbers\nassign next_state = {state[n-2:0], ~state[n-1] ^ state[n-2]};\n\n// use the output signals to indicate the current state of the Johnson counter\nassign out = state;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder #_7ecb53cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule priority_encoder #\n(\n    parameter WIDTH = 4,\n    parameter LSB_HIGH_PRIORITY = 0\n)\n(\n    input  wire [WIDTH-1:0]         input_unencoded,\n    output wire                     output_valid,\n    output wire [$clog2(WIDTH)-1:0] output_encoded,\n    output wire [WIDTH-1:0]         output_unencoded\n);\n\nparameter LEVELS = WIDTH > 2 ? $clog2(WIDTH) : 1;\nparameter W = 2**LEVELS;\n\nwire [W-1:0] input_padded = {{W-WIDTH{1'b0}}, input_unencoded};\n\nwire [W/2-1:0] stage_valid[LEVELS-1:0];\nwire [W/2-1:0] stage_enc[LEVELS-1:0];\n\ngenerate\n    genvar l, n;\n\n    for (n = 0; n < W/2; n = n + 1) begin : loop_in\n        assign stage_valid[0][n] = |input_padded[n*2+1:n*2];\n        if (LSB_HIGH_PRIORITY) begin\n            assign stage_enc[0][n] = !input_padded[n*2+0];\n        end else begin\n            assign stage_enc[0][n] = input_padded[n*2+1];\n        end\n    end\n\n    for (l = 1; l < LEVELS; l = l + 1) begin : loop_levels\n        for (n = 0; n < W/(2*2**l); n = n + 1) begin : loop_compress\n            assign stage_valid[l][n] = |stage_valid[l-1][n*2+1:n*2];\n            if (LSB_HIGH_PRIORITY) begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+0] ? {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]} : {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]};\n            end else begin\n                assign stage_enc[l][(n+1)*(l+1)-1:n*(l+1)] = stage_valid[l-1][n*2+1] ? {1'b1, stage_enc[l-1][(n*2+2)*l-1:(n*2+1)*l]} : {1'b0, stage_enc[l-1][(n*2+1)*l-1:(n*2+0)*l]};\n            end\n        end\n    end\nendgenerate\n\nassign output_valid = stage_valid[LEVELS-1];\nassign output_encoded = stage_enc[LEVELS-1];\nassign output_unencoded = 1 << output_encoded;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__dc16982d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    output reg valid\n);\n\nreg [15:0] prev_data_in;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out <= 16'h0000;\n        valid <= 1'b0;\n        prev_data_in <= data_in;\n    end\n    else if (data_in !== prev_data_in) begin\n        data_out <= ~data_in;\n        valid <= 1'b1;\n        prev_data_in <= data_in;\n    end\n    else begin\n        data_out <= data_out;\n        valid <= valid;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NPM_Toggle_PHY_B_Reset_2d25baee", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule NPM_Toggle_PHY_B_Reset\n(\n    iSystemClock            ,\n    iReset                  ,\n    oReady                  ,\n    oLastStep               ,\n    iStart                  ,\n    oPI_BUFF_Reset          ,\n    oPI_BUFF_RE             ,\n    oPI_BUFF_WE             ,\n    oPO_DQStrobe            ,\n    oDQSOutEnable            \n);\n    input                           iSystemClock            ;\n    input                           iReset                  ;\n    output                          oReady                  ;\n    output                          oLastStep               ;\n    input                           iStart                  ;\n    output                          oPI_BUFF_Reset          ;\n    output                          oPI_BUFF_RE             ;\n    output                          oPI_BUFF_WE             ;\n    output  [7:0]                   oPO_DQStrobe            ;\n    output                          oDQSOutEnable           ;\n    \n    parameter PBR_FSM_BIT = 4;\n    parameter PBR_RESET = 4'b0001;\n    parameter PBR_READY = 4'b0010;\n    parameter PBR_RFRST = 4'b0100; parameter PBR_RLOOP = 4'b1000; reg     [PBR_FSM_BIT-1:0]       rPBR_cur_state          ;\n    reg     [PBR_FSM_BIT-1:0]       rPBR_nxt_state          ;\n    \n    \n    \n    reg                             rReady                  ;\n    \n    reg     [3:0]                   rTimer                  ;\n    \n    wire                            wJOBDone                ;\n    \n    reg                             rPI_BUFF_Reset          ;\n    reg                             rPI_BUFF_RE             ;\n    reg                             rPI_BUFF_WE             ;\n    reg     [7:0]                   rPO_DQStrobe            ;\n    reg                             rDQSOutEnable           ;\n    \n    \n    \n    assign wJOBDone = (4'b1010 == rTimer[3:0]);\n    always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rPBR_cur_state <= PBR_RESET;\n        end else begin\n            rPBR_cur_state <= rPBR_nxt_state;\n        end\n    end\n    \n    always @ ( * ) begin\n        case (rPBR_cur_state)\n            PBR_RESET: begin\n                rPBR_nxt_state <= PBR_READY;\n            end\n            PBR_READY: begin\n                rPBR_nxt_state <= (iStart)? PBR_RFRST:PBR_READY;\n            end\n            PBR_RFRST: begin\n                rPBR_nxt_state <= PBR_RLOOP;\n            end\n            PBR_RLOOP: begin\n                rPBR_nxt_state <= (wJOBDone)? ((iStart)? PBR_RFRST:PBR_READY):PBR_RLOOP;\n            end\n            default:\n                rPBR_nxt_state <= PBR_READY;\n        endcase\n    end\n    \n    always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rReady              <= 0;\n            \n            rTimer[3:0]         <= 0;\n            \n            rPI_BUFF_Reset      <= 0;\n            rPI_BUFF_RE         <= 0;\n            rPI_BUFF_WE         <= 0;\n            rPO_DQStrobe[7:0]   <= 0;\n            rDQSOutEnable       <= 0;\n        end else begin\n            case (rPBR_nxt_state)\n                PBR_RESET: begin\n                    rReady              <= 0;\n                    \n                    rTimer[3:0]         <= 0;\n                    \n                    rPI_BUFF_Reset      <= 0;\n                    rPI_BUFF_RE         <= 0;\n                    rPI_BUFF_WE         <= 0;\n                    rPO_DQStrobe[7:0]   <= 0;\n                    rDQSOutEnable       <= 0;\n                end\n                PBR_READY: begin\n                    rReady              <= 1;\n                    \n                    rTimer[3:0]         <= 0;\n                    \n                    rPI_BUFF_Reset      <= 0;\n                    rPI_BUFF_RE         <= 0;\n                    rPI_BUFF_WE         <= 0;\n                    rPO_DQStrobe[7:0]   <= 0;\n                    rDQSOutEnable       <= 0;\n                end\n                PBR_RFRST: begin\n                    rReady              <= 0;\n                    \n                    rTimer[3:0]         <= 4'b0000;\n                    \n                    rPI_BUFF_Reset      <= 1'b1;\n                    rPI_BUFF_RE         <= 1'b0;\n                    rPI_BUFF_WE         <= 1'b0;\n                    rPO_DQStrobe[7:0]   <= 8'b0101_0101;\n                    rDQSOutEnable       <= 1'b1;\n                end\n                PBR_RLOOP: begin\n                    rReady              <= 0;\n                    \n                    rTimer[3:0]         <= rTimer[3:0] + 1'b1;\n                    \n                    rPI_BUFF_Reset      <= 1'b1;\n                    rPI_BUFF_RE         <= 1'b0;\n                    rPI_BUFF_WE         <= 1'b0;\n                    rPO_DQStrobe[7:0]   <= 8'b0101_0101;\n                    rDQSOutEnable       <= 1'b1;\n                end\n            endcase\n        end\n    end\n    \n    \n    \n    assign oReady           = rReady | wJOBDone ;\n    assign oLastStep        = wJOBDone         ;\n    \n    assign oPI_BUFF_Reset   = rPI_BUFF_Reset    ;\n    assign oPI_BUFF_RE      = rPI_BUFF_RE       ;\n    assign oPI_BUFF_WE      = rPI_BUFF_WE       ;\n    assign oPO_DQStrobe     = rPO_DQStrobe      ;\n    assign oDQSOutEnable    = rDQSOutEnable     ;\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_multiplier_a8ba7dc3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_multiplier(clk, reset, a, b, result);\n\ninput clk, reset;\ninput [7:0] a, b;\noutput reg [15:0] result;\nreg [3:0] i;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        result <= 0;\n    end else begin\n        for (i = 0; i < 8; i = i + 1) begin\n            if (a[i]) begin\n                result <= result + (b << i);\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "r4_adder_909fe565", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule r4_adder(output [3:0] S, output Cout, input [3:0] A, B, input Cin);\n\n    wire c1, c2, c3;\n\n    full_adder a1(.S(S[0]), .Cout(c1), .A(A[0]), .B(B[0]), .Cin(Cin)),\n               a2(.S(S[1]), .Cout(c2), .A(A[1]), .B(B[1]), .Cin(c1)),\n               a3(.S(S[2]), .Cout(c3), .A(A[2]), .B(B[2]), .Cin(c2)),\n               a4(.S(S[3]), .Cout(Cout), .A(A[3]), .B(B[3]), .Cin(c3));\n\nendmodule\n\nmodule full_adder(output S, output Cout, input A, B, input Cin);\n    assign {Cout, S} = A + B + Cin;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__fah_6cc96034", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__fah (\n    COUT,\n    SUM ,\n    A   ,\n    B   ,\n    CI\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CI  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xor0_out_SUM;\n    wire a_b         ;\n    wire a_ci        ;\n    wire b_ci        ;\n    wire or0_out_COUT;\n\n    xor xor0 (xor0_out_SUM, A, B, CI       );\n    buf buf0 (SUM         , xor0_out_SUM   );\n    and and0 (a_b         , A, B           );\n    and and1 (a_ci        , A, CI          );\n    and and2 (b_ci        , B, CI          );\n    or  or0  (or0_out_COUT, a_b, a_ci, b_ci);\n    buf buf1 (COUT        , or0_out_COUT   );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_b7d809f1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator(A, B, Z);\n  input [1:0] A;\n  input [1:0] B;\n  output Z;\n  wire eq, gt;\n\n  assign eq = (A == B);\n  assign gt = (A > B);\n\n  assign Z = (gt | eq);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "serdes_fc_tx_5d21039a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule serdes_fc_tx\n  (input clk, input rst,\n   input xon_rcvd, input xoff_rcvd, output reg inhibit_tx);\n\n   reg [15:0] state;\n   always @(posedge clk)\n     if(rst)\n       state <= 0;\n     else if(xoff_rcvd)\n       state <= 255;\n     else if(xon_rcvd)\n       state <= 0;\n     else if(state !=0)\n       state <= state - 1;\n\n   always @(posedge clk)\n     inhibit_tx <= (state != 0);\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Ramifier_111e2d48", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Ramifier\n#(\n    parameter BRANCH_CONDITION_WIDTH = 4\n)(\n  input [(BRANCH_CONDITION_WIDTH - 1):0] condition,\n  input negative_flag, zero_flag, carry_flag, overflow_flag,\n  output reg take\n);\n\n\n    always @ ( * ) begin\n        case (condition)\n            0:begin take = zero_flag;\n            end\n            1:begin take = !zero_flag;\n            end\n            2:begin take = carry_flag;\n            end\n            3:begin take = !carry_flag;\n            end\n            4:begin   take = negative_flag;\n            end\n            5:begin   take = !(negative_flag);\n            end\n            6:begin   take = overflow_flag;\n            end\n            7:begin   take = !(overflow_flag);\n            end\n            8:begin   take = (carry_flag) && (!zero_flag);\n            end\n            9:begin   take = (!carry_flag) || (zero_flag);\n            end\n            10:begin    take =  (negative_flag ^~ overflow_flag) ;\n            end\n            11:begin    take = (negative_flag ^ overflow_flag);\n            end\n            12:begin    take = (!zero_flag) && (negative_flag ^~ overflow_flag);\n            end\n            13:begin     take = (zero_flag) || (negative_flag ^ overflow_flag);\n            end\n            14:begin  take = 1;\n            end\n            default: begin\n                take = 0; end\n        endcase\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_async_reset_02930510", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_async_reset (\n    input D,\n    input CLK,\n    input RESET,\n    output reg Q\n);\n\nalways @(posedge CLK, posedge RESET) begin\n    if (RESET == 1'b1) begin\n        Q <= 1'b0;\n    end else begin\n        Q <= D;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bit_counter_79ef9a60", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bit_counter (\n    input CLK,\n    input RST,\n    input [31:0] data_in,\n    output reg [4:0] count_set_bits\n);\n\n    reg [31:0] shift_reg;\n    integer i;\n\n    always @(posedge CLK or negedge RST) begin\n        if (RST == 0) begin\n            shift_reg <= 0;\n            count_set_bits <= 0;\n        end\n        else begin\n            shift_reg <= data_in;\n            count_set_bits <= 0;\n            for (i = 0; i < 32; i = i + 1) begin\n                if (shift_reg[i] == 1) begin\n                    count_set_bits <= count_set_bits + 1;\n                end\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_3589031a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule memory(clk, mem_read, mem_write, address, data_in, data_out);\n  input  clk, mem_read, mem_write;\n  input  [31:0] address, data_in;\n  output [31:0] data_out;\n\n  parameter BASE_ADDRESS = 25'd0; // address that applies to this memory - change if desired\n\n  reg [31:0] mem_array [0:31];\n  wire [4:0] mem_offset;\n  wire address_select;\n\n  assign mem_offset = address[6:2];  // drop 2 LSBs to get word offset\n\n  assign address_select = (address[31:7] == BASE_ADDRESS);  // address decoding\n\n  assign data_out = (mem_read == 1'b1 && address_select == 1'b1) ? mem_array[mem_offset] : 32'hxxxxxxxx;\n\n  // for WRITE operations\n  always @(posedge clk)\n  begin\n    if (mem_write == 1'b1 && address_select == 1'b1)\n    begin\n      mem_array[mem_offset] <= data_in;\n    end\n  end\n\n  // initialize with some arbitrary values\n\n  integer i;\n  initial begin\n    for (i=0; i<32; i=i+1) mem_array[i] = i*4;\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_50d230f4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\nwire w1, w2, w3;\n\nassign w1 = A ^ B;\nassign w2 = w1 ^ Cin;\nassign S = w2;\nassign w3 = A & B;\nassign Cout = w3 | (w1 & Cin);\n\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire c1, c2, c3;\n\nfull_adder fa0(A[0], B[0], Cin, S[0], c1);\nfull_adder fa1(A[1], B[1], c1, S[1], c2);\nfull_adder fa2(A[2], B[2], c2, S[2], c3);\nfull_adder fa3(A[3], B[3], c3, S[3], Cout);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "debounce_push_button_525b1435", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule debounce_push_button (\n  input clk,\n  input button,\n  output reg debounced_button\n);\n\nparameter IDLE = 2'b00, PRE_DEBOUNCE = 2'b01, DEBOUNCE = 2'b10;\nreg [1:0] state, next_state;\nreg [9:0] debounce_counter;\n\nalways @(posedge clk) begin\n  state <= next_state;\n  case(state)\n    IDLE: begin\n      if(button) next_state <= PRE_DEBOUNCE;\n      else next_state <= IDLE;\n    end\n    PRE_DEBOUNCE: begin\n      if(button) next_state <= PRE_DEBOUNCE;\n      else begin\n        next_state <= DEBOUNCE;\n        debounce_counter <= 0;\n      end\n    end\n    DEBOUNCE: begin\n      if(button && debounce_counter < 9) begin\n        debounce_counter <= debounce_counter + 1;\n        next_state <= DEBOUNCE;\n      end\n      else begin\n        debounced_button <= button;\n        next_state <= IDLE;\n      end\n    end\n  endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_calculator_a0fc0def", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule simple_calculator(\n    clk,\n    reset,\n    ce,\n    a,\n    b,\n    op,\n    result);\n\nparameter ADD = 2'b00;\nparameter SUB = 2'b01;\n\ninput clk;\ninput reset;\ninput ce;\ninput [7:0] a;\ninput [7:0] b;\ninput [1:0] op;\noutput [7:0] result;\n\nreg [7:0] result_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        result_reg <= 8'b0;\n    end else if (ce) begin\n        case (op)\n            ADD: result_reg <= a + b;\n            SUB: result_reg <= a - b;\n        endcase\n    end\nend\n\nassign result = result_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__inv_6a3794f3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__inv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__48ff15da", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,      // Clock input\n    input reset,    // Synchronous active-high reset\n    input [7:0] d,  // 8-bit input for the shift register\n    input [31:0] in, // 32-bit input for the rising edge capture module\n    output [31:0] out // 32-bit output from the functional module\n);\n\n// Declare an array of 4 registers for the shift register\nreg [7:0] shift_reg [3:0]; // 4-stage shift register\n\nreg [31:0] capture_reg; // Rising edge capture register\nreg [31:0] product; // Product of shift register and capture register\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset all registers to 0\n        shift_reg[0] <= 0;\n        shift_reg[1] <= 0;\n        shift_reg[2] <= 0;\n        shift_reg[3] <= 0;\n        capture_reg <= 0;\n        product <= 0;\n    end else begin\n        // Shift register\n        shift_reg[0] <= d;\n        shift_reg[1] <= shift_reg[0];\n        shift_reg[2] <= shift_reg[1];\n        shift_reg[3] <= shift_reg[2];\n\n        // Rising edge capture\n        if (in[31] && !capture_reg[31]) begin\n            capture_reg <= in;\n        end\n\n        // Functional module: multiply shift register and capture register\n        product <= shift_reg[3] * capture_reg;\n    end\nend\n\nassign out = product;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_tree_top_40aca10b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define ADDER_WIDTH 006\n`define DUMMY_WIDTH 128\n\n`define 2_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_counter_cc0de567", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule johnson_counter(\n  input clk,\n  output out1,\n  output out2\n);\n\nparameter n = 4; // number of bits in the counter\n\nreg [n-1:0] state; // register to hold current state\n\n// define sequence of states as a function of current state and clock signal\nalways @(posedge clk) begin\n  state <= {state[n-2:0], ~state[n-1]};\nend\n\n// connect current state to output signals\nassign out1 = state[0];\nassign out2 = ~state[0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cla_4bit_adder_7f6b2dcc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cla_4bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] Y\n);\n\n    wire [3:0] P;\n    wire [3:0] G;\n    wire [3:0] C;\n    wire [3:0] C_prop;\n    wire [3:0] C_gen;\n    wire [3:0] C_out;\n\n    assign P = A ^ B;\n    assign G = A & B;\n    assign C_prop[0] = G[0];\n    assign C_prop[1] = G[1] + (P[1] & G[0]);\n    assign C_prop[2] = G[2] + (P[2] & G[1]) + (P[2] & P[1] & G[0]);\n    assign C_prop[3] = G[3] + (P[3] & G[2]) + (P[3] & P[2] & G[1]) + (P[3] & P[2] & P[1] & G[0]);\n    assign C_gen[0] = G[0];\n    assign C_gen[1] = P[1] & G[0];\n    assign C_gen[2] = P[2] & G[1] | P[2] & P[1] & G[0];\n    assign C_gen[3] = P[3] & G[2] | P[3] & P[2] & G[1] | P[3] & P[2] & P[1] & G[0];\n    assign C_out[0] = C_prop[0];\n    assign C_out[1] = C_prop[1] | C_gen[1] & C_prop[0];\n    assign C_out[2] = C_prop[2] | C_gen[2] & C_prop[1] | C_gen[2] & C_gen[1] & C_prop[0];\n    assign C_out[3] = C_prop[3] | C_gen[3] & C_prop[2] | C_gen[3] & C_gen[2] & C_prop[1] | C_gen[3] & C_gen[2] & C_gen[1] & C_prop[0];\n    assign Y = P ^ C_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dffc_64_afc0793d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dffc_64 ( clk, reset, d, q );\n    input clk;\n    input reset;\n    input [63:0] d;\n    output reg [63:0] q;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 64'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "_90_pmux2_ecec23fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule _90_pmux2 (A, B, S, Y);\n\tparameter WIDTH = 1;\n\tparameter S_WIDTH = 1;\n\n\tinput [WIDTH-1:0] A;\n\tinput [WIDTH*S_WIDTH-1:0] B;\n\tinput [S_WIDTH-1:0] S;\n\toutput [WIDTH-1:0] Y;\n\n\twire [S_WIDTH-1:0] S_NOT;\n\twire [WIDTH*S_WIDTH-1:0] B_NOT;\n\n\tassign S_NOT = ~S;\n\tassign B_NOT = ~B;\n\n\twire [WIDTH-1:0] A_AND_S_NOT;\n\twire [WIDTH*S_WIDTH-1:0] B_AND_S;\n\n\tassign A_AND_S_NOT = A & {WIDTH{S_NOT}};\n\tassign B_AND_S = B & {WIDTH*S_WIDTH{S_NOT}};\n\n\twire [WIDTH-1:0] Y_B_AND_S_NOT;\n\twire [S_WIDTH-1:0] Y_B_AND_S_NOT_OR;\n\n\tassign Y_B_AND_S_NOT = |B_AND_S;\n\tassign Y_B_AND_S_NOT_OR = |{S_WIDTH{Y_B_AND_S_NOT}};\n\n\tassign Y = S ? Y_B_AND_S_NOT_OR : A_AND_S_NOT;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_enable_4267c2d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1_enable (\n  input A,\n  input B,\n  input E,\n  output Y\n);\n\n  assign Y = E ? A : B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tone_generator_885ae611", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule tone_generator (\n  input clk,\n  input rst,\n  input [1:0] tone,\n  output audio_out\n);\n\nparameter f_clk = 50_000_000; // frequency of the clock signal\nparameter f_tone = 440; // frequency of the selected tone (default: A4)\nparameter t_duration = 1; // duration of the tone in seconds (default: 1 second)\n\nreg [31:0] tone_counter = 0;\nreg [31:0] tone_duration = 0;\nreg [31:0] sample_counter = 0;\nreg [31:0] sample_period = 0;\nreg [1:0] tone_type = 2'b00; // default: sine wave\n\nwire tone_signal;\n\n// DTMF tone generation\nalways @ (posedge clk) begin\n  if (rst) begin\n    tone_counter <= 0;\n    tone_duration <= 0;\n    sample_counter <= 0;\n    sample_period <= 0;\n    tone_type <= 2'b00;\n  end else begin\n    // Check if tone is selected\n    if (tone != 2'b00) begin\n      // A new tone is selected\n      if (tone != tone_type) begin\n        tone_counter <= 0;\n        tone_duration <= t_duration * f_clk;\n        sample_counter <= 0;\n        sample_period <= f_clk / f_tone;\n        tone_type <= tone;\n      end else begin // Same tone is selected\n        // Check if tone duration is reached\n        if (tone_counter >= tone_duration) begin\n          tone_counter <= 0;\n          tone_duration <= 0;\n          sample_counter <= 0;\n          sample_period <= 0;\n          tone_type <= 2'b00;\n        end else begin\n          tone_counter <= tone_counter + 1;\n          sample_counter <= sample_counter + 1;\n          // Check if a new sample is needed\n          if (sample_counter >= sample_period) begin\n            sample_counter <= 0;\n          end\n        end\n      end\n    end else begin // No tone is selected\n      tone_counter <= 0;\n      tone_duration <= 0;\n      sample_counter <= 0;\n      sample_period <= 0;\n      tone_type <= 2'b00;\n    end\n  end\nend\n\n// Sine wave generation\nassign tone_signal = (tone_counter >= (f_clk / (2 * f_tone))) ? 1'b1 : 1'b0;\n\n// Audio output\nassign audio_out = tone_signal;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_timer #_baa3f5a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule axi_timer #(\n  parameter WIDTH = 8,\n  parameter MAX_VALUE = 256\n)(\n  input clk,\n  input rst,\n  input load,\n  input [WIDTH-1:0] value,\n  input enable,\n  output reg timer_expired,\n  output wire [WIDTH-1:0] current_value\n);\n\n  reg [WIDTH-1:0] count;\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n      timer_expired <= 0;\n    end else if (load) begin\n      count <= value;\n    end else if (enable) begin\n      if (count == 0) begin\n        timer_expired <= 1;\n        count <= MAX_VALUE;\n      end else begin\n        count <= count - 1;\n        timer_expired <= 0;\n      end\n    end\n  end\n\n  assign current_value = count;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "addsub_212158e2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule addsub (S, Cout, A, B, C);\n    output [3:0] S;\n    output Cout;\n    input [3:0] A, B;\n    input C;\n\n    wire [3:0] B_neg;\n\n    // invert B bits when C is high to implement subtraction\n    assign B_neg = ~B + 1;\n    wire [3:0] B_sel = C ? B_neg : B;\n\n    // implement 4-bit adder\n    wire [3:0] S_add;\n    wire C_add;\n    assign {C_add, S_add} = A + B_sel;\n\n    // set output values\n    assign S = S_add;\n    assign Cout = C_add;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sequence_detector_30309173", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sequence_detector (\n    input clk,\n    input reset,\n    input [3:0] in,\n    output reg [6:0] seg_out\n);\n\n    reg [3:0] shift_reg;\n    reg [3:0] seq = 4'b1100;\n    reg [3:0] seq_detect;\n    reg detect;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n            detect <= 0;\n            seq_detect <= 4'b0000;\n            seg_out <= 7'b0000000;\n        end\n        else begin\n            shift_reg <= {in, shift_reg[3:1]};\n            seq_detect <= {shift_reg[2:0], in};\n            if (seq_detect == seq) begin\n                detect <= 1;\n            end\n            if (detect) begin\n                seg_out <= 7'b0110000; // Display \"1\"\n            end\n            else begin\n                seg_out <= 7'b0000000; // Display \"0\"\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__c2486810", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk, // Clock signal\n    input reset, // Synchronous active-high reset\n    input [7:0] a, b, // 8-bit input values\n    output [7:0] result // 8-bit output representing the multiplication result\n);\n\n    reg [7:0] product; // 8-bit register to store the product\n    reg [7:0] quotient; // 8-bit register to store the quotient\n    \n    // Multiplication module\n    always @(posedge clk) begin\n        if (reset) begin\n            product <= 8'b0; // Reset the product register\n        end else begin\n            product <= a * b; // Perform multiplication\n        end\n    end\n    \n    // Division by 2 module\n    always @(posedge clk) begin\n        if (reset) begin\n            quotient <= 8'b0; // Reset the quotient register\n        end else begin\n            quotient <= product >> 1; // Perform division by 2\n        end\n    end\n    \n    // Assign output\n    assign result = quotient;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alt_vipvfr131_vfr_controller_a2085159", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule alt_vipvfr131_vfr_controller\n\t(\t\n\t\tclock,\n\t\treset,\n\t\t\n\t\tmaster_address,\n\t\tmaster_write,\n\t\tmaster_writedata,\n\t\tmaster_interrupt_recieve,\n\t\t\n\t\tgo_bit,\n\t\trunning,\n\t\tframe_complete,\t\t\n\t\tnext_bank,\n\t\t\n\t\tctrl_packet_width_bank0,\n\t\tctrl_packet_height_bank0,\n\t\tctrl_packet_interlaced_bank0,\n\t\t\n\t\tvid_packet_base_address_bank0,\n\t\tvid_packet_samples_bank0,\n\t\tvid_packet_words_bank0,\n\t\t\n\t\tctrl_packet_width_bank1,\n\t\tctrl_packet_height_bank1,\n\t\tctrl_packet_interlaced_bank1,\n\t\t\n\t\tvid_packet_base_address_bank1,\n\t\tvid_packet_samples_bank1,\n\t\tvid_packet_words_bank1,\n\t\t\n\t\twidth_of_next_vid_packet,\n\t\theight_of_next_vid_packet,\n\t\tinterlaced_of_next_vid_packet,\n\t\tdo_control_packet\n\t);\n\n\tlocalparam MASTER_ADDRESS_WIDTH\t= \t32;\t\n\tlocalparam MASTER_DATA_WIDTH \t\t=\t\t32;\n\t\n\tparameter CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH = 16;\n\tparameter CONTROL_PACKET_INTERLACED_REQUIREDWIDTH = 4;\n\tparameter PACKET_ADDRESS_WIDTH = 32;\n\tparameter PACKET_SAMPLES_WIDTH = 32;\n\tparameter PACKET_WORDS_WIDTH = 32;\n\t\n\tinput\t\tclock;\n\tinput\t\treset;\n\t\n\toutput reg [MASTER_ADDRESS_WIDTH-1 :0] master_address;\n\toutput reg master_write;\n\toutput reg [MASTER_DATA_WIDTH-1 :0] master_writedata;\n\tinput master_interrupt_recieve;\n\t\n\tinput go_bit;\n\toutput reg running;\n\toutput reg frame_complete;\n\tinput next_bank;\n\t\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_width_bank0;\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_height_bank0;\n\tinput [CONTROL_PACKET_INTERLACED_REQUIREDWIDTH-1:0] ctrl_packet_interlaced_bank0;\n\t\n\tinput [PACKET_ADDRESS_WIDTH-1:0] \tvid_packet_base_address_bank0;\n\tinput [PACKET_SAMPLES_WIDTH-1:0] \tvid_packet_samples_bank0;\n\tinput [PACKET_WORDS_WIDTH-1:0] \t\tvid_packet_words_bank0;\n\t\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_width_bank1;\n\tinput [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] ctrl_packet_height_bank1;\n\tinput [CONTROL_PACKET_INTERLACED_REQUIREDWIDTH-1:0] ctrl_packet_interlaced_bank1;\n\t\n\tinput [PACKET_ADDRESS_WIDTH-1:0] \tvid_packet_base_address_bank1;\n\tinput [PACKET_SAMPLES_WIDTH-1:0] \tvid_packet_samples_bank1;\n\tinput [PACKET_WORDS_WIDTH-1:0] \t\tvid_packet_words_bank1;\n\t\n\toutput reg [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] width_of_next_vid_packet;\n\toutput reg [CONTROL_PACKET_RESOLUTION_REQUIREDWIDTH-1:0] height_of_next_vid_packet;\n\toutput reg [CONTROL_PACKET_INTERLACED_REQUIREDWIDTH-1:0] interlaced_of_next_vid_packet;\n\toutput reg do_control_packet;\n\t\n\t\n\tlocalparam PACKET_READER_GO_ADDRESS = 0;\n\tlocalparam PACKET_READER_STATUS_ADDRESS = 1;\n\tlocalparam PACKET_READER_INTERRUPT_ADDRESS = 2;\n\tlocalparam PACKET_READER_PACKET_ADDRESS_ADDRESS = 3;\n\tlocalparam PACKET_READER_PACKET_TYPE_ADDRESS = 4;\n\tlocalparam PACKET_READER_PACKET_SAMPLES_ADDRESS = 5;\n\tlocalparam PACKET_READER_PACKET_WORDS_ADDRESS = 6;\n\t\n\tlocalparam [2:0] IDLE            \t\t= 3'd0;\n\tlocalparam [2:0] SENDING_ADDRESS \t\t= 3'd1;\n\tlocalparam [2:0] SENDING_SAMPLES \t\t= 3'd2;\n\tlocalparam [2:0] SENDING_WORDS   \t\t= 3'd3;\n\tlocalparam [2:0] SENDING_TYPE   \t\t= 3'd4;\n\tlocalparam [2:0] SENDING_GO_AND_ENABLE_INTERRUPT      \t\t= 3'd5;\n\tlocalparam [2:0] WAITING_END_FRAME \t= 3'd6;\n\treg [2:0] state;\n\treg bank_to_read;\n\t\t\n\t\talways @(posedge clock or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\t\t\n\t\t\tbank_to_read <= 0;\n\t\t\tmaster_write <= 0;\n\t\t\tmaster_writedata <= 0;\n\t\t\tmaster_address <= 0;\n\t\t\tdo_control_packet <= 0;\n\t\t\twidth_of_next_vid_packet <=0;\n\t\t\theight_of_next_vid_packet <=0;\n\t\t\tinterlaced_of_next_vid_packet <=0;\n\t\t\trunning<=0;\n\t\t\tframe_complete<=0;\n\t\t\t\n\t\tend\telse begin\n\t\t\tcase (state)\n\t\t\t\t\n\t\t\t\tIDLE :\tbegin\n\t\t\t\t\tmaster_write<=0;\n\t\t\t\t\t\n\t\t\t\t\tframe_complete<=0;\n\t\t\t\t\tif(go_bit) begin\n\t\t\t\t\t\tstate <= SENDING_ADDRESS;\n\t\t\t\t\t\tbank_to_read <= next_bank;\n\t\t\t\t\t\trunning<=1;\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_ADDRESS :\tbegin \n\t\t\t\t\tstate <= SENDING_SAMPLES;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_ADDRESS_ADDRESS;\n\t\t\t\t\tmaster_write <= 1;\n\t\t\t\t\tdo_control_packet <= 1;\n\t\t\t\t\tif(bank_to_read==0) begin\t\t\t\t\t\n\t\t\t\t\t\tmaster_writedata <= vid_packet_base_address_bank0;\n\t\t\t\t\t\twidth_of_next_vid_packet <= ctrl_packet_width_bank0;\n\t\t\t\t\t\theight_of_next_vid_packet <= ctrl_packet_height_bank0;\n\t\t\t\t\t\tinterlaced_of_next_vid_packet <= ctrl_packet_interlaced_bank0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tmaster_writedata <= vid_packet_base_address_bank1;\n\t\t\t\t\t\twidth_of_next_vid_packet <= ctrl_packet_width_bank1;\n\t\t\t\t\t\theight_of_next_vid_packet <= ctrl_packet_height_bank1;\n\t\t\t\t\t\tinterlaced_of_next_vid_packet <= ctrl_packet_interlaced_bank1;\n\t\t\t\t\tend\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_SAMPLES :\tbegin \n\t\t\t\t\tstate <= SENDING_WORDS;\n\t\t\t\t\tdo_control_packet <= 0;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_SAMPLES_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; if(bank_to_read==0) begin\t\t\t\t\t\n\t\t\t\t\t\tmaster_writedata <= vid_packet_samples_bank0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tmaster_writedata <= vid_packet_samples_bank1;\n\t\t\t\t\tend\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_WORDS :\tbegin \n\t\t\t\t\tstate <= SENDING_TYPE;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_WORDS_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; if(bank_to_read==0) begin\t\t\t\t\t\n\t\t\t\t\t\tmaster_writedata <= vid_packet_words_bank0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tmaster_writedata <= vid_packet_words_bank1;\n\t\t\t\t\tend\t\t\t\t\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSENDING_TYPE :\tbegin \n\t\t\t\t\tstate <= SENDING_GO_AND_ENABLE_INTERRUPT;\n\t\t\t\t\tmaster_address <= PACKET_READER_PACKET_TYPE_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; master_writedata <= 0; end\n\t\t\t\t\n\t\t\t\tSENDING_GO_AND_ENABLE_INTERRUPT :\tbegin \n\t\t\t\t\tstate <= WAITING_END_FRAME;\n\t\t\t\t\tmaster_address <= PACKET_READER_GO_ADDRESS;\n\t\t\t\t\tmaster_write <= 1; master_writedata <= 3; end\n\t\t\t\t\n\t\t\t\tWAITING_END_FRAME\t: begin\n\t\t\t\t\tmaster_address <= PACKET_READER_INTERRUPT_ADDRESS;\n\t\t\t\t\tmaster_writedata <= 2;\n\t\t\t\t\tmaster_write <= 0; if(master_interrupt_recieve) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\trunning <= 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tframe_complete <=1;\n\t\t\t\t\t\tmaster_write <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_subtract_display_e5ee408c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_subtract_display (\n  input clk,\n  input reset,\n  input [3:0] a,\n  input [3:0] b,\n  input op,\n  output reg [6:0] seg\n);\n\n  // Adder module\n  wire [3:0] add_out;\n  adder add_inst (.a(a), .b(b), .sum(add_out));\n\n  // Subtractor module\n  wire [3:0] sub_out;\n  subtractor sub_inst (.a(a), .b(b), .diff(sub_out));\n\n  // Shift register for adder output\n  reg [6:0] add_shift_reg = 7'b0000000;\n  always @(posedge clk) begin\n    if (reset) begin\n      add_shift_reg <= 7'b0000000;\n    end else begin\n      add_shift_reg <= {add_shift_reg[5:0], add_out[3]};\n    end\n  end\n\n  // Shift register for subtractor output\n  reg [6:0] sub_shift_reg = 7'b0000000;\n  always @(posedge clk) begin\n    if (reset) begin\n      sub_shift_reg <= 7'b0000000;\n    end else begin\n      sub_shift_reg <= {sub_shift_reg[5:0], sub_out[3]};\n    end\n  end\n\n  // Output selection logic\n  reg [6:0] display_out = 7'b0000000;\n  always @(posedge clk) begin\n    if (reset) begin\n      display_out <= 7'b0000000;\n    end else begin\n      if (op == 0) begin\n        display_out <= add_shift_reg;\n      end else begin\n        display_out <= sub_shift_reg;\n      end\n    end\n  end\n\n  // 7-segment display decoder\n  always @(*) begin\n    case (display_out)\n      7'b0000000: seg = 7'b1111110; // 0\n      7'b0000001: seg = 7'b0110000; // 1\n      7'b0000010: seg = 7'b1101101; // 2\n      7'b0000011: seg = 7'b1111001; // 3\n      7'b0000100: seg = 7'b0110011; // 4\n      7'b0000101: seg = 7'b1011011; // 5\n      7'b0000110: seg = 7'b1011111; // 6\n      7'b0000111: seg = 7'b1110000; // 7\n      7'b0001000: seg = 7'b1111111; // 8\n      7'b0001001: seg = 7'b1110011; // 9\n      default: seg = 7'b0000001; // Error (display \"-\")\n    endcase\n  end\n\nendmodule\n\n// Adder module\nmodule adder (\n  input [3:0] a,\n  input [3:0] b,\n  output reg [3:0] sum\n);\n  always @(*) begin\n    sum = a + b;\n  end\nendmodule\n\n// Subtractor module\nmodule subtractor (\n  input [3:0] a,\n  input [3:0] b,\n  output reg [3:0] diff\n);\n  always @(*) begin\n    diff = a - b;\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "digital_circuit__a65b3b43", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule digital_circuit_module (\n    output reg Y   ,\n    input  A1  ,\n    input  A2  ,\n    input  B1_N,\n    input  VPWR,\n    input  VGND,\n    input  VPB ,\n    input  VNB\n);\n\n    wire Y1;\n    wire Y2;\n    wire c;\n\n    assign Y1 = (A1 & A2 & B1_N);\n    assign Y2 = ~(A1 & A2 & B1_N);\n    assign c = ~VPWR;\n\n    always @* begin\n        Y = c ? Y2 : Y1;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_d7194aa7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate(input a, b, clk, output reg out);\n  wire mux_out;\n  reg d_ff_out;\n  \n  // Multiplexer implementation\n  assign mux_out = (a & b);\n  \n  // D flip-flop implementation\n  always @(posedge clk) begin\n    d_ff_out <= mux_out;\n  end\n  \n  always @* begin\n    out = d_ff_out;\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_c410c584", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input clk,\n    input rst,\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input [2:0] op,\n    output reg signed [7:0] result,\n    output reg of\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 0;\n        of <= 0;\n    end else begin\n        case (op)\n            3'b000: begin // addition\n                if ((b > 0 && a > (127 - b)) || (b < 0 && a < (-128 - b))) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a + b;\n            end\n            3'b001: begin // subtraction\n                if ((b < 0 && a > (127 + b)) || (b > 0 && a < (-128 + b))) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a - b;\n            end\n            3'b010: begin // multiplication\n                if ((a == -128 && b == -1) || (b == -128 && a == -1)) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a * b;\n            end\n            3'b011: begin // division\n                if (b == 0) begin\n                    of <= 1;\n                end else begin\n                    of <= 0;\n                end\n                result <= a / b;\n            end\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor_gate_b5c53890", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nor_gate(input a, b, output out);\n    wire temp1, temp2, temp3;\n    \n    nand gate1(temp1, a, a);\n    nand gate2(temp2, b, b);\n    nand gate3(temp3, temp1, temp2);\n    nand gate4(out, temp3, temp3);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "half_adder_1790b3da", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule half_adder(\n    input A,\n    input B,\n    output S,\n    output C\n);\n\nassign {C, S} = A + B;\n\nendmodule\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\nassign {Cout, S} = A + B + Cin;\n\nendmodule\nmodule adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] C;\nwire [2:0] S1;\n\nhalf_adder HA0(A[0], B[0], S[0], C[0]);\nfull_adder FA1(A[1], B[1], C[0], S1[0], C[1]);\nfull_adder FA2(A[2], B[2], C[1], S1[1], C[2]);\nfull_adder FA3(A[3], B[3], C[2], S[3], Cout);\n\nassign S = {S[3], S1, S[0]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spiral_16_fcb28c97", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule spiral_16(\n          i_data,\n          \n        o_data_4,\n        o_data_13,\n        o_data_22,\n        o_data_31,\n        o_data_38,\n        o_data_46,\n        o_data_54,\n        o_data_61,\n        o_data_67,\n        o_data_73,\n        o_data_78,\n        o_data_82,\n        o_data_85,\n        o_data_88,\n        o_data_90\n);\n\ninput  signed [16:0]   i_data;\noutput signed [16+7:0] o_data_4;\noutput signed [16+7:0] o_data_13;\noutput signed [16+7:0] o_data_22;\noutput signed [16+7:0] o_data_31;\noutput signed [16+7:0] o_data_38;\noutput signed [16+7:0] o_data_46;\noutput signed [16+7:0] o_data_54;\noutput signed [16+7:0] o_data_61;\noutput signed [16+7:0] o_data_67;\noutput signed [16+7:0] o_data_73;\noutput signed [16+7:0] o_data_78;\noutput signed [16+7:0] o_data_82;\noutput signed [16+7:0] o_data_85;\noutput signed [16+7:0] o_data_88;\noutput signed [16+7:0] o_data_90;\nwire signed [23:0] w1,\n                    w32,\n                    w31,\n                    w8,\n                    w23,\n                    w4,\n                    w27,\n                    w39,\n                    w62,\n                    w61,\n                    w9,\n                    w2,\n                    w11,\n                    w13,\n                    w18,\n                    w19,\n                    w41,\n                    w36,\n                    w45,\n                    w67,\n                    w64,\n                    w73,\n                    w16,\n                    w17,\n                    w68,\n                    w85,\n                    w22,\n                    w38,\n                    w46,\n                    w54,\n                    w78,\n                    w82,\n                    w88,\n                    w90;\nassign w1 = i_data;\nassign w32 = w1 << 5;\nassign w31 = w32 - w1;\nassign w8 = w1 << 3;\nassign w23 = w31 - w8;\nassign w4 = w1 << 2;\nassign w27 = w31 - w4;\nassign w39 = w31 + w8;\nassign w62 = w31 << 1;\nassign w61 = w62 - w1;\nassign w9 = w1 + w8;\nassign w2 = w1 << 1;\nassign w11 = w9 + w2;\nassign w13 = w9 + w4;\nassign w18 = w9 << 1;\nassign w19 = w1 + w18;\nassign w41 = w9 + w32;\nassign w36 = w9 << 2;\nassign w45 = w9 + w36;\nassign w67 = w31 + w36;\nassign w64 = w1 << 6;\nassign w73 = w9 + w64;\nassign w16 = w1 << 4;\nassign w17 = w1 + w16;\nassign w68 = w17 << 2;\nassign w85 = w17 + w68;\nassign w22 = w11 << 1;\nassign w38 = w19 << 1;\nassign w46 = w23 << 1;\nassign w54 = w27 << 1;\nassign w78 = w39 << 1;\nassign w82 = w41 << 1;\nassign w88 = w11 << 3;\nassign w90 = w45 << 1;    \n\nassign  o_data_4= w4;\nassign  o_data_13=w13;\nassign  o_data_22=w22;\nassign  o_data_31=w31;\nassign  o_data_38=w38;\nassign  o_data_46=w46;\nassign  o_data_54=w54;\nassign  o_data_61=w61;\nassign  o_data_67=w67;\nassign  o_data_73=w73;\nassign  o_data_78=w78;\nassign  o_data_82=w82;\nassign  o_data_85=w85;\nassign  o_data_88=w88;\nassign  o_data_90=w90;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fpga_4bf3b8f7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fpga (\n    \n    input  wire       clk_125mhz,\n    input  wire       rst_125mhz,\n    \n    input  wire       btnu,\n    input  wire       btnl,\n    input  wire       btnd,\n    input  wire       btnr,\n    input  wire       btnc,\n    input  wire [7:0] sw,\n    output wire       ledu,\n    output wire       ledl,\n    output wire       ledd,\n    output wire       ledr,\n    output wire       ledc,\n    output wire [7:0] led,\n    \n    output wire       uart_rxd,\n    input  wire       uart_txd,\n    input  wire       uart_rts,\n    output wire       uart_cts\n);\n\n// LED control\nreg [4:0] led_state;\n\nalways @ (posedge clk_125mhz) begin\n    if (rst_125mhz) begin\n        led_state <= 5'b00000;\n    end else begin\n        led_state <= {btnc, btnr, btnd, btnl, btnu};\n    end\nend\n\nassign ledu = led_state[0];\nassign ledl = led_state[1];\nassign ledd = led_state[2];\nassign ledr = led_state[3];\nassign ledc = led_state[4];\nassign led = 8'h00;\n\n// UART control\nreg [7:0] uart_data;\n\nalways @ (posedge clk_125mhz) begin\n    if (rst_125mhz) begin\n        uart_data <= 8'h00;\n    end else if (uart_rxd) begin\n        uart_data <= uart_txd;\n    end\nend\n\nassign uart_rxd = uart_data[0];\nassign uart_cts = uart_data[1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM_aa7c0943", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule FSM(\n    input [31:0] x,\t\t\t\t\tinput [31:0] y,\t\t\t\t\tinput [31:0] z,\t\t\t\t\tinput [31:0] k,\t\t\t\t\tinput [31:0] kappa_LUTRot, \n\t input [31:0] theta_LUTRot, \n\t input [31:0] delta_LUTRot,\n\t input [31:0] kappa_LUTVec, \n\t input [31:0] theta_LUTVec, \n\t input [31:0] delta_LUTVec,\n    input [31:0] theta_LUT,\t\tinput [31:0] kappa_LUT,\t\tinput [31:0] delta_LUT,\t\tinput [1:0] mode,\t\t\t\tinput operation,\t\t\t\t\tinput clock,\n\t input done_LUTRot,\n\t input done_LUTVec,\n\t input done_LUT,\t\t\t\t\toutput reg enable_LUT,\t\t\toutput reg [7:0] address,\t\toutput reg [31:0] theta_out,\toutput reg [31:0] kappa_out,\toutput reg [31:0] delta_out,\toutput reg done_FSM,\n\t output reg [31:0] x_final,\n\t output reg [31:0] y_final,\n\t output reg [31:0] z_final,\n\t output reg [31:0] k_final,\n\t input done_ALU\n    );\n\nreg [7:0] exponent;\nreg converge;\n\nalways @ (*)\nbegin\n\t\n\tif (operation == 1'b1)\t\n\tbegin\n\t\texponent <= 8'b01111111 - z[30:23];\n\tend\n\t\n\telse if (operation == 1'b0)\n\tbegin\n\t\texponent <= x[30:23] - y[30:23];\n\tend\n\t\n\nend\n\nalways @ (posedge clock)\nbegin\n\t\n\t\tif ((done_LUT == 1'b1 || done_LUTRot == 1'b1 || done_LUTVec == 1'b1) && enable_LUT == 1'b1)\n\tbegin\n\t\t\n\t\tif ((operation == 1'b0) && (mode == 2'b00 || (exponent <= 8'b11110011 && exponent > 8'b10000000)))\n\t\tbegin\n\t\t\tdelta_out <= delta_LUT;\n\t\t\tdelta_out[30:23] <= exponent + 8'b01111111;\n\t\t\ttheta_out <= theta_LUT;\n\t\t\ttheta_out[30:23] <= exponent + 8'b01111111;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (operation == 1'b1)\n\t\tbegin\n\t\t\ttheta_out[31] <= ~z[31];\n\t\t\tdelta_out[31] <= ~z[31];\n\t\t\ttheta_out[30:0] <= theta_LUTRot[30:0];\n\t\t\tdelta_out[30:0] <= delta_LUTRot[30:0];\n\t\t\tkappa_out <= kappa_LUTRot;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse\n\t\tbegin\n\t\t\ttheta_out <= theta_LUTVec;\n\t\t\tdelta_out <= delta_LUTVec;\n\t\t\tkappa_out <= kappa_LUTVec;\n\t\t\tenable_LUT <= 1'b0;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\n\tif (done_ALU == 1'b1)\n\tbegin\n\t\tdone_FSM <= 1'b0;\n\tend\n\t\n\tif (operation == 1'b1)\t\t\t\t\t\t\t\t\t\t\t\t\n\tbegin\n\t\t\n\t\tif (z[30:23] <= 8'b01110000)\n\t\tbegin\n\t\t\tconverge <= 1'b1;\n\t\t\tx_final <= x;\n\t\t\ty_final <= y;\n\t\t\tz_final <= z;\n\t\t\tk_final <= k;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b00)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tbegin\n\t\t\ttheta_out[30:0] <= z[30:0];\n\t\t\tdelta_out[30:0] <= z[30:0];\n\t\t\ttheta_out[31]\t<= ~z[31];\n\t\t\tdelta_out[31]\t<= ~z[31];\n\t\t\tkappa_out <= 32'h3F800000;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b11 && z[30:23] >= 8'b01111111)\n\t\tbegin\n\t\t\ttheta_out <= 32'hBF800000;\n\t\t\tdelta_out <= 32'hBF42F7D6;\n\t\t\tkappa_out <= 32'h3FC583AB;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b01 && z[30:23] >= 8'b01111111)\t\t\n\t\tbegin\n\t\t\ttheta_out <= 32'hBF800000;\n\t\t\tdelta_out <= 32'hBFC75923;\n\t\t\tkappa_out <= 32'h3FECE788;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\n\t\telse if (mode != 2'b00 && z[30:23] < 8'b01111111 && z[30:23] > 8'b01110011) \t\t\t\n\t\tbegin\n\t\t\taddress[7:4] <= exponent[3:0];\n\t\t\taddress[3:0] <= z[22:19];\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\t\n\t\t\n\t\telse if (mode != 2'b00 && z[30:23] <= 8'b01110011)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tbegin\n\t\t\ttheta_out[30:0] <= z[30:0];\n\t\t\tdelta_out[30:0] <= z[30:0];\n\t\t\ttheta_out[31]\t<= ~z[31];\n\t\t\tdelta_out[31]\t<= ~z[31];\n\t\t\tkappa_out <= 32'h3F800000;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\n\telse if (operation == 1'b0)\t\t\t\t\t\n\tbegin\n\t\t\n\t\tif (z[30:23] <= 8'b01110000)\n\t\tbegin\n\t\t\tconverge <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b00)\n\t\tbegin\n\t\t\taddress[7:4] <= x[22:19];\n\t\t\taddress[3:0] <= y[22:19];\n\t\t\tkappa_out <= 32'h3F8;\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode != 2'b00 && exponent > 8'b11110011 && exponent <= 8'b11111111) \t\n\t\tbegin\n\t\t\taddress[7:4] <= exponent[3:0];\n\t\t\taddress[3:2] <= x[22:21];\n\t\t\taddress[1:0] <= y[22:21];\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\t\n\t\t\n\t\telse if (mode != 2'b00 && exponent <= 8'b11110011 && exponent > 8'b10000000)\n\t\tbegin\n\t\t\taddress[7:4] <= x[22:19];\n\t\t\taddress[3:0] <= y[22:19];\n\t\t\tkappa_out <= 32'h3F8;\n\t\t\tenable_LUT <= 1'b1;\n\t\tend\n\t\t\n\t\telse if (mode == 2'b11 && exponent <= 8'b10000000)\n\t\tbegin\n\t\t\tdelta_out <= 32'h3F733333;\n\t\t\ttheta_out <= 32'h3FEA77CB;\n\t\t\tkappa_out <= 32'h3E9FDF38;\t\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\t\t\n\t\telse if (mode == 2'b01 && exponent <= 8'b10000000)\n\t\tbegin\n\t\t\tdelta_out <= 32'h3F8;\t\t\t\t\ttheta_out <= 32'h3F490FDB;\n\t\t\tkappa_out <= 32'h3FB504F4;\n\t\t\tdone_FSM <= 1'b1;\n\t\tend\n\t\t\n\tend\n\t\nend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__o211a_4_beb01043", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ms__o211a_4 (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    assign X = (A1 & A2 & B1 & C1 & VPWR & !VGND & VPB & !VNB);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_buffer_85d2a208", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo_buffer(\n    input clock,\n    input ready,\n    input [7:0] head,\n\n    input tail_req, //RTL\n    input tail_ack,\n    input [7:0] tail_value,\n    input tail_value_valid,\n\n    input req,\n    output reg ack,\n    output reg [7:0] value,\n    output reg value_valid\n);\n\nreg [7:0] buffer [0:255];\nreg [7:0] read_pointer;\nreg [7:0] write_pointer;\nreg write_data;\nreg [7:0] write_pointer_next;\nreg [7:0] read_pointer_next;\nreg [7:0] read_data;\nreg [7:0] tail_data;\nreg [7:0] tail_pointer;\nreg [7:0] tail_pointer_next;\nreg [7:0] head_pointer;\nreg [7:0] head_pointer_next;\nreg [7:0] buffer_size;\nreg [7:0] buffer_size_next;\nreg tail_full;\nreg head_full;\nreg tail_empty;\nreg head_empty;\n\nalways @(posedge clock) begin\n\n    if (ready) begin\n\n        // Write data to the head\n        if (!head_full && head_pointer == write_pointer) begin\n            buffer[write_pointer] <= head;\n            write_pointer_next <= write_pointer + 1;\n            if (write_pointer_next == 256) begin\n                write_pointer_next <= 0;\n            end\n            head_full <= (write_pointer_next == read_pointer);\n        end else begin\n            write_pointer_next <= write_pointer;\n            head_full <= 0;\n        end\n\n        // Read data from the head\n        if (req && !head_empty && read_pointer == head_pointer) begin\n            read_data <= buffer[read_pointer];\n            read_pointer_next <= read_pointer + 1;\n            if (read_pointer_next == 256) begin\n                read_pointer_next <= 0;\n            end\n            head_empty <= (read_pointer_next == write_pointer);\n        end else begin\n            read_pointer_next <= read_pointer;\n            head_empty <= 1;\n        end\n\n        // Write data to the tail\n        if (!tail_full && tail_pointer == write_pointer && tail_req) begin\n            buffer[tail_pointer] <= tail_data;\n            tail_pointer_next <= tail_pointer - 1;\n            if (tail_pointer_next == -1) begin\n                tail_pointer_next <= 255;\n            end\n            tail_full <= (tail_pointer_next == write_pointer);\n        end else begin\n            tail_pointer_next <= tail_pointer;\n            tail_full <= 0;\n        end\n\n        // Read data from the tail\n        if (tail_value_valid && !tail_empty && tail_pointer == read_pointer) begin\n            tail_data <= tail_value;\n            tail_pointer_next <= tail_pointer - 1;\n            if (tail_pointer_next == -1) begin\n                tail_pointer_next <= 255;\n            end\n            tail_empty <= (tail_pointer_next == write_pointer);\n        end else begin\n            tail_pointer_next <= tail_pointer;\n            tail_empty <= 1;\n        end\n\n        // Update buffer size\n        if (head_pointer <= tail_pointer) begin\n            buffer_size_next <= tail_pointer - head_pointer;\n        end else begin\n            buffer_size_next <= 256 - head_pointer + tail_pointer;\n        end\n\n        // Update head pointer\n        if (!head_empty) begin\n            head_pointer_next <= read_pointer_next;\n        end else begin\n            head_pointer_next <= head_pointer;\n        end\n\n        // Update tail pointer\n        if (!tail_full && tail_req) begin\n            tail_pointer_next <= tail_pointer_next;\n        end else begin\n            tail_pointer_next <= tail_pointer;\n        end\n\n    end else begin\n        write_pointer_next <= write_pointer;\n        read_pointer_next <= read_pointer;\n        head_pointer_next <= head_pointer;\n        tail_pointer_next <= tail_pointer;\n        tail_data <= tail_data;\n        buffer_size_next <= buffer_size;\n    end\nend\n\nalways @(*) begin\n    write_pointer <= write_pointer_next;\n    read_pointer <= read_pointer_next;\n    head_pointer <= head_pointer_next;\n    tail_pointer <= tail_pointer_next;\n    buffer_size <= buffer_size_next;\n\n    if (!head_empty && head_pointer == read_pointer) begin\n        value <= read_data;\n        ack <= tail_ack ; //Fix\n        value_valid <= tail_value_valid;\n    end else begin\n        value <= 0;\n        ack <= 0;\n        value_valid <= 0;\n    end\n\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "antares_shifter_54fa325b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule antares_shifter (\n                        input [31:0]  shift_input_data,  input [4:0]   shift_shamnt,      input         shift_direction,   input         shift_sign_extend, output [31:0] shift_result       );\n\n    reg [31:0]    input_inv;          reg [31:0]    result_shift_temp;  reg [31:0]    result_inv;         wire          sign;\n    wire [31:0]   operand;\n\n    assign sign         = (shift_sign_extend) ? shift_input_data[31] : 1'b0;\n    assign operand      = (shift_direction) ? input_inv : shift_input_data;\n    assign shift_result = (shift_direction) ? result_inv : result_shift_temp;\n\n    integer       index0;\n    integer       index1;\n    always @ (*) begin\n        for (index0 = 0; index0 < 32; index0 = index0 + 1) begin\n            input_inv[31 - index0] = shift_input_data[index0];\n        end\n    end\n    always @(*) begin\n        for (index1 = 0; index1 < 32; index1 = index1 + 1)\n          result_inv[31 - index1] = result_shift_temp[index1];\n    end\n\n    always @(*) begin\n        case(shift_shamnt)\n            5'd0    : result_shift_temp =               operand[31:0];\n            5'd1    : result_shift_temp = { {1 {sign}}, operand[31:1] };\n            5'd2    : result_shift_temp = { {2 {sign}}, operand[31:2] };\n            5'd3    : result_shift_temp = { {3 {sign}}, operand[31:3] };\n            5'd4    : result_shift_temp = { {4 {sign}}, operand[31:4] };\n            5'd5    : result_shift_temp = { {5 {sign}}, operand[31:5] };\n            5'd6    : result_shift_temp = { {6 {sign}}, operand[31:6] };\n            5'd7    : result_shift_temp = { {7 {sign}}, operand[31:7] };\n            5'd8    : result_shift_temp = { {8 {sign}}, operand[31:8] };\n            5'd9    : result_shift_temp = { {9 {sign}}, operand[31:9] };\n            5'd10   : result_shift_temp = { {10{sign}}, operand[31:10] };\n            5'd11   : result_shift_temp = { {11{sign}}, operand[31:11] };\n            5'd12   : result_shift_temp = { {12{sign}}, operand[31:12] };\n            5'd13   : result_shift_temp = { {13{sign}}, operand[31:13] };\n            5'd14   : result_shift_temp = { {14{sign}}, operand[31:14] };\n            5'd15   : result_shift_temp = { {15{sign}}, operand[31:15] };\n            5'd16   : result_shift_temp = { {16{sign}}, operand[31:16] };\n            5'd17   : result_shift_temp = { {17{sign}}, operand[31:17] };\n            5'd18   : result_shift_temp = { {18{sign}}, operand[31:18] };\n            5'd19   : result_shift_temp = { {19{sign}}, operand[31:19] };\n            5'd20   : result_shift_temp = { {20{sign}}, operand[31:20] };\n            5'd21   : result_shift_temp = { {21{sign}}, operand[31:21] };\n            5'd22   : result_shift_temp = { {22{sign}}, operand[31:22] };\n            5'd23   : result_shift_temp = { {23{sign}}, operand[31:23] };\n            5'd24   : result_shift_temp = { {24{sign}}, operand[31:24] };\n            5'd25   : result_shift_temp = { {25{sign}}, operand[31:25] };\n            5'd26   : result_shift_temp = { {26{sign}}, operand[31:26] };\n            5'd27   : result_shift_temp = { {27{sign}}, operand[31:27] };\n            5'd28   : result_shift_temp = { {28{sign}}, operand[31:28] };\n            5'd29   : result_shift_temp = { {29{sign}}, operand[31:29] };\n            5'd30   : result_shift_temp = { {30{sign}}, operand[31:30] };\n            5'd31   : result_shift_temp = { {31{sign}}, operand[31:31] };\n            default : result_shift_temp = 32'bx;\n        endcase\n    end\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_block_f72fa94c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0] o_data0;\n\n  // Multipliers:\n  wire [31:0] w1, w256, w257, w4, w32, w229, w261, w29312;\n\n  assign w1 = i_data0;\n  assign w256 = i_data0 << 8;\n  assign w257 = w1 + w256;\n  assign w4 = i_data0 << 2;\n  assign w32 = i_data0 << 5;\n  assign w261 = w257 + w4;\n  assign w229 = w261 - w32;\n  assign w29312 = w229 << 7;\n\n  assign o_data0 = w29312;\n\n  // Multiplier block area estimate = 4204.56962668382;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_memory_3fceec07", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo_memory(\n    input clk,\n    input wr_en,\n    input rd_en,\n    input [7:0] data_in,\n    output reg empty,\n    output reg full,\n    output reg [7:0] data_out\n);\n\n    parameter SIZE = 8;\n    reg [7:0] memory [SIZE-1:0];\n    reg [2:0] head, tail;\n    reg [2:0] next_tail;\n    reg [2:0] next_head;\n    \n    always @(posedge clk) begin\n        if(wr_en && !full) begin\n            memory[tail] <= data_in;\n            tail <= next_tail;\n        end\n    end\n    \n    always @(posedge clk) begin\n        if(rd_en && !empty) begin\n            data_out <= memory[head];\n            head <= next_head;\n        end\n    end\n    \n    always @(*) begin\n        next_tail = (tail + 1) % SIZE;\n        next_head = (head + 1) % SIZE;\n        empty = (head == tail) ? 1'b1 : 1'b0;\n        full = ((next_tail == head) && (head != tail)) ? 1'b1 : 1'b0;\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hs__dlygate4sd2_4ec31e05", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hs__dlygate4sd2 (\n    input A,\n    input VPWR,\n    input VGND,\n    output reg X\n);\n\nreg [3:0] delay_count;\n\nalways @(posedge VPWR or negedge VGND)\nbegin\n    if (VGND == 1'b0)\n        X <= 1'b0;\n    else if (A == 1'b1)\n    begin\n        delay_count <= 4'b1111;\n        X <= 1'b0;\n    end\n    else if (delay_count != 0)\n        delay_count <= delay_count - 1;\n    else\n        X <= 1'b1;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RIPPLE_CARRY_ADDER_04093841", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RIPPLE_CARRY_ADDER (\ninput wire [3:0] wA,\ninput wire [3:0] wB,\ninput wire wCi,\noutput wire [3:0] wR,\noutput wire wCo\n);\n\nwire [3:0] c;\n\nFULL_ADDER fa0(wA[0], wB[0], wCi, wR[0], c[0]);\nFULL_ADDER fa1(wA[1], wB[1], c[0], wR[1], c[1]);\nFULL_ADDER fa2(wA[2], wB[2], c[1], wR[2], c[2]);\nFULL_ADDER fa3(wA[3], wB[3], c[2], wR[3], wCo);\n\nendmodule\n\nmodule FULL_ADDER (\ninput wire  wA,wB,wCi,\noutput wire  wR ,\noutput wire wCo\n);\n\nassign {wCo,wR} = wA + wB + wCi;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mig_7series_v2_0_bank_compare #_dc16eee6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule mig_7series_v2_0_bank_compare #\n  (parameter BANK_WIDTH               = 3,\n   parameter TCQ = 100,\n   parameter BURST_MODE               = \"8\",\n   parameter COL_WIDTH                = 12,\n   parameter DATA_BUF_ADDR_WIDTH      = 8,\n   parameter ECC                      = \"OFF\",\n   parameter RANK_WIDTH               = 2,\n   parameter RANKS                    = 4,\n   parameter ROW_WIDTH                = 16)\n  (\n  req_data_buf_addr_r, req_periodic_rd_r, req_size_r, rd_wr_r,\n  req_rank_r, req_bank_r, req_row_r, req_wr_r, req_priority_r,\n  rb_hit_busy_r, rb_hit_busy_ns, row_hit_r, maint_hit, col_addr,\n  req_ras, req_cas, row_cmd_wr, row_addr, rank_busy_r,\n  clk, idle_ns, idle_r, data_buf_addr, periodic_rd_insert, size, cmd,\n  sending_col, rank, periodic_rd_rank_r, bank, row, col, hi_priority,\n  maint_rank_r, maint_zq_r, maint_sre_r, auto_pre_r, rd_half_rmw, act_wait_r\n  );\n\n  input clk;\n\n  input idle_ns;\n  input idle_r;\n\n  input [DATA_BUF_ADDR_WIDTH-1:0]data_buf_addr;\n  output reg [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_r;\n  wire [DATA_BUF_ADDR_WIDTH-1:0] req_data_buf_addr_ns =\n                                   idle_r\n                                     ? data_buf_addr\n                                     : req_data_buf_addr_r;\n  always @(posedge clk) req_data_buf_addr_r <= #TCQ req_data_buf_addr_ns;\n\n  input periodic_rd_insert;\n\n  reg req_periodic_rd_r_lcl;\n  wire req_periodic_rd_ns = idle_ns\n                             ? periodic_rd_insert\n                             : req_periodic_rd_r_lcl;\n  always @(posedge clk) req_periodic_rd_r_lcl <= #TCQ req_periodic_rd_ns;\n  output wire req_periodic_rd_r;\n  assign req_periodic_rd_r = req_periodic_rd_r_lcl;\n\n  input size;\n  wire req_size_r_lcl;\n  generate\n    if (BURST_MODE == \"4\") begin : burst_mode_4\n      assign req_size_r_lcl = 1'b0;\n    end\n    else\n      if (BURST_MODE == \"8\") begin : burst_mode_8\n        assign req_size_r_lcl = 1'b1;\n      end\n      else\n        if (BURST_MODE == \"OTF\") begin : burst_mode_otf\n          reg req_size;\n          wire req_size_ns = idle_ns\n                                 ? (periodic_rd_insert || size)\n                                 : req_size;\n          always @(posedge clk) req_size <= #TCQ req_size_ns;\n          assign req_size_r_lcl = req_size;\n        end\n  endgenerate\n  output wire req_size_r;\n  assign req_size_r = req_size_r_lcl;\n\n\n\n  input [2:0] cmd;\n  reg [2:0] req_cmd_r;\n  wire [2:0] req_cmd_ns = idle_ns\n                            ? (periodic_rd_insert ? 3'b001 : cmd)\n                            : req_cmd_r;\n   \n  always @(posedge clk) req_cmd_r <= #TCQ req_cmd_ns;\n\n`ifdef MC_SVA\n  rd_wr_only_wo_ecc: assert property\n    (@(posedge clk) ((ECC != \"OFF\") || idle_ns || ~|req_cmd_ns[2:1]));\n`endif\n  \n  input sending_col;\n  reg rd_wr_r_lcl;\n  wire rd_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || req_cmd_ns[0])\n                    : ~sending_col && rd_wr_r_lcl;\n  always @(posedge clk) rd_wr_r_lcl <= #TCQ rd_wr_ns;\n  output wire rd_wr_r;\n  assign rd_wr_r = rd_wr_r_lcl;\n\n  input [RANK_WIDTH-1:0] rank;\n  input [RANK_WIDTH-1:0] periodic_rd_rank_r;\n  reg [RANK_WIDTH-1:0] req_rank_r_lcl = {RANK_WIDTH{1'b0}};\n  reg [RANK_WIDTH-1:0] req_rank_ns = {RANK_WIDTH{1'b0}};\n  generate\n    if (RANKS != 1) begin\n      always @(idle_ns or periodic_rd_insert\n               or periodic_rd_rank_r or rank or req_rank_r_lcl) req_rank_ns = idle_ns\n                                  ? periodic_rd_insert\n                                      ? periodic_rd_rank_r\n                                      : rank\n                                  : req_rank_r_lcl;\n      always @(posedge clk) req_rank_r_lcl <= #TCQ req_rank_ns;\n    end\n  endgenerate\n  output wire [RANK_WIDTH-1:0] req_rank_r;\n  assign req_rank_r = req_rank_r_lcl;\n\n  input [BANK_WIDTH-1:0] bank;\n  reg [BANK_WIDTH-1:0] req_bank_r_lcl;\n  wire [BANK_WIDTH-1:0] req_bank_ns = idle_ns ? bank : req_bank_r_lcl;\n  always @(posedge clk) req_bank_r_lcl <= #TCQ req_bank_ns;\n  output wire[BANK_WIDTH-1:0] req_bank_r;\n  assign req_bank_r = req_bank_r_lcl;\n\n  input [ROW_WIDTH-1:0] row;\n  reg [ROW_WIDTH-1:0] req_row_r_lcl;\n  wire [ROW_WIDTH-1:0] req_row_ns = idle_ns ? row : req_row_r_lcl;\n  always @(posedge clk) req_row_r_lcl <= #TCQ req_row_ns;\n  output wire [ROW_WIDTH-1:0] req_row_r;\n  assign req_row_r = req_row_r_lcl;\n\n  input [COL_WIDTH-1:0] col;\n  reg [15:0] req_col_r = 16'b0;\n  wire [COL_WIDTH-1:0] req_col_ns = idle_ns ? col : req_col_r[COL_WIDTH-1:0];\n  always @(posedge clk) req_col_r[COL_WIDTH-1:0] <= #TCQ req_col_ns;\n\n  reg req_wr_r_lcl;\n  wire req_wr_ns = idle_ns \n                    ? ((req_cmd_ns[1:0] == 2'b11) || ~req_cmd_ns[0])\n                    : req_wr_r_lcl;\n  always @(posedge clk) req_wr_r_lcl <= #TCQ req_wr_ns;\n  output wire req_wr_r;\n  assign req_wr_r = req_wr_r_lcl;\n\n  input hi_priority;\n  output reg req_priority_r;\n  wire req_priority_ns = idle_ns ? hi_priority : req_priority_r;\n  always @(posedge clk) req_priority_r <= #TCQ req_priority_ns;\n\n  wire rank_hit = (req_rank_r_lcl == (periodic_rd_insert\n                                       ? periodic_rd_rank_r\n                                       : rank));\n  wire bank_hit = (req_bank_r_lcl == bank);\n  wire rank_bank_hit = rank_hit && bank_hit;\n\n  output reg rb_hit_busy_r;       wire  rb_hit_busy_ns_lcl;\n  assign rb_hit_busy_ns_lcl = rank_bank_hit && ~idle_ns;\n  output wire  rb_hit_busy_ns;\n  assign rb_hit_busy_ns = rb_hit_busy_ns_lcl;\n\n  wire row_hit_ns = (req_row_r_lcl == row);\n  output reg row_hit_r;\n\n  always @(posedge clk) rb_hit_busy_r <= #TCQ rb_hit_busy_ns_lcl;\n  always @(posedge clk) row_hit_r <= #TCQ row_hit_ns;\n\n  input [RANK_WIDTH-1:0] maint_rank_r;\n  input maint_zq_r;\n  input maint_sre_r;\n  output wire maint_hit;\n  assign maint_hit = (req_rank_r_lcl == maint_rank_r) || maint_zq_r || maint_sre_r;\n\ninput auto_pre_r;\n  input rd_half_rmw;\n  reg [15:0] col_addr_template = 16'b0;\n  always @(auto_pre_r or rd_half_rmw or req_col_r\n           or req_size_r_lcl) begin\n    col_addr_template = req_col_r;\n    col_addr_template[10] = auto_pre_r && ~rd_half_rmw;\n    col_addr_template[11] = req_col_r[10];\n    col_addr_template[12] = req_size_r_lcl;\n    col_addr_template[13] = req_col_r[11];\n  end\n  output wire [ROW_WIDTH-1:0] col_addr;\n  assign col_addr = col_addr_template[ROW_WIDTH-1:0];\n\n  output wire req_ras;\n  output wire req_cas;\n  output wire row_cmd_wr;\n  input act_wait_r;\n  assign req_ras = 1'b0;\n  assign req_cas = 1'b1;\n  assign row_cmd_wr = act_wait_r;\n\n  output reg [ROW_WIDTH-1:0] row_addr;\n  always @(act_wait_r or req_row_r_lcl) begin\n    row_addr = req_row_r_lcl;\nif (~act_wait_r) row_addr[10] = 1'b0;\n  end\n\nlocalparam ONE = 1;\n  output reg [RANKS-1:0] rank_busy_r;\n  wire [RANKS-1:0] rank_busy_ns = {RANKS{~idle_ns}} & (ONE[RANKS-1:0] << req_rank_ns);\n  always @(posedge clk) rank_busy_r <= #TCQ rank_busy_ns;\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_c1a945cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    assign Y = (A & B & C);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "touch_sensor_bd165690", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule touch_sensor (\n  input wire touch_in,\n  output reg touch_out\n);\n\n  reg touch_detected;\n\n  always @(posedge touch_in) begin\n    touch_detected <= #1 touch_in;  // Delay the assignment by 1 time unit to avoid multiple edge sensitive events\n  end\n\n  always @(*) begin\n    touch_out = touch_detected;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__or4b_f0d70516", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hd__or4b (\n    input A,\n    input B,\n    input C,\n    input D_N,\n    output X\n);\n\n    assign X = ~(A & B & C & D_N);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "robotic_arm_controller_edd23895", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule robotic_arm_controller(\n    input [7:0] servo1_angle,\n    input [7:0] servo2_angle,\n    input [7:0] servo3_angle,\n    input [7:0] servo4_angle,\n    input [7:0] servo5_angle,\n    output reg [11:0] servo1_pwm,\n    output reg [11:0] servo2_pwm,\n    output reg [11:0] servo3_pwm,\n    output reg [11:0] servo4_pwm,\n    output reg [11:0] servo5_pwm\n);\n\n    always @(*) begin\n        servo1_pwm = (servo1_angle * 11) + 500;\n        servo2_pwm = (servo2_angle * 11) + 500;\n        servo3_pwm = (servo3_angle * 11) + 500;\n        servo4_pwm = (servo4_angle * 11) + 500;\n        servo5_pwm = (servo5_angle * 11) + 500;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_5f35ee9d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n    \n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule\n\nmodule adder4(A, B, S, Cout);\n    input [3:0] A, B;\n    output [3:0] S;\n    output Cout;\n    \n    wire C1, C2, C3;\n    full_adder FA1(A[0], B[0], 1'b0, S[0], C1);\n    full_adder FA2(A[1], B[1], C1, S[1], C2);\n    full_adder FA3(A[2], B[2], C2, S[2], C3);\n    full_adder FA4(A[3], B[3], C3, S[3], Cout);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decode38_c1e3e73d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule decode38(en, din, dout);\n    input en;\n    input [2:0] din;\n    output reg [7:0] dout;\n    \n    always @(*) begin\n        if (~en) begin\n            dout <= 8'b0;\n        end else begin\n            dout <= 8'b1 << din;\n        end\n    end\nendmodule\n\nmodule regxb(nrst, clk, en, din, regout);\n    parameter bits = 1;\n    input nrst;\n    input clk;\n    input en;\n    input [bits-1:0] din;\n    output reg [bits-1:0] regout;\n    \n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            regout <= 0;\n        end else if (en) begin\n            regout <= din;\n        end\n    end\nendmodule\n\nmodule dso_regw(nrst, clk, addr, din, we, sel,\n    reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7);\n    \n    input nrst;\n    input clk;\n    input [2:0] addr;\n    input [7:0] din;\n    input we;\n    output [7:0] sel;\n    output [7:0] reg0;\n    output [7:0] reg1;\n    output [7:0] reg2;\n    output [7:0] reg3;\n    output [7:0] reg4;\n    output [7:0] reg5;\n    output [7:0] reg6;\n    output [7:0] reg7;\n    wire [7:0] addr_dec;\n    \n    decode38 dec(.en(we), .din(addr), .dout(addr_dec));\n    assign sel = addr_dec;\n    \n    regxb #(8) r0(.nrst(nrst), .clk(clk), .en(addr_dec[0]), .din(din), .regout(reg0));\n    regxb #(8) r1(.nrst(nrst), .clk(clk), .en(addr_dec[1]), .din(din), .regout(reg1));\n    regxb #(8) r2(.nrst(nrst), .clk(clk), .en(addr_dec[2]), .din(din), .regout(reg2));\n    regxb #(8) r3(.nrst(nrst), .clk(clk), .en(addr_dec[3]), .din(din), .regout(reg3));\n    regxb #(8) r4(.nrst(nrst), .clk(clk), .en(addr_dec[4]), .din(din), .regout(reg4));\n    regxb #(8) r5(.nrst(nrst), .clk(clk), .en(addr_dec[5]), .din(din), .regout(reg5));\n    regxb #(8) r6(.nrst(nrst), .clk(clk), .en(addr_dec[6]), .din(din), .regout(reg6));\n    regxb #(8) r7(.nrst(nrst), .clk(clk), .en(addr_dec[7]), .din(din), .regout(reg7));\nendmodule\n\nmodule dso_regr(addr, dout, \n    reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7);\n    \n    input [2:0] addr;\n    output reg [7:0] dout;\n    input [7:0] reg0;\n    input [7:0] reg1;\n    input [7:0] reg2;\n    input [7:0] reg3;\n    input [7:0] reg4;\n    input [7:0] reg5;\n    input [7:0] reg6;\n    input [7:0] reg7;\n    \n    always @(*) begin\n        case (addr)\n        3'h0: dout <= reg0;\n        3'h1: dout <= reg1;\n        3'h2: dout <= reg2;\n        3'h3: dout <= reg3;\n        3'h4: dout <= reg4;\n        3'h5: dout <= reg5;\n        3'h6: dout <= reg6;\n        3'h7: dout <= reg7;\n        default: dout <= 8'b0;\n        endcase\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "async_reset_release_114f8a29", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule async_reset_release (\n  input rst,\n  input clk,\n  input enable,\n  output reg rst_release\n);\n\nparameter delay_count = 10;\n\nreg [7:0] delay_counter;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    rst_release <= 0;\n    delay_counter <= 0;\n  end else if (enable) begin\n    if (delay_counter < delay_count) begin\n      delay_counter <= delay_counter + 1;\n    end else begin\n      rst_release <= 1;\n    end\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_0a46cd30", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule priority_encoder (\n    input [7:0] in,\n    output [3:0] pos\n);\n\n// Assign the position of the highest priority input to 'pos'\nassign pos = (in[0] ? 3'b000 :\n            in[1] ? 3'b001 :\n            in[2] ? 3'b010 :\n            in[3] ? 3'b011 :\n            in[4] ? 3'b100 :\n            in[5] ? 3'b101 :\n            in[6] ? 3'b110 : 3'b111);\n\nendmodule\n\nmodule subtractor (\n    input [3:0] in,\n    output [3:0] out\n);\n\n// Subtract 4'b0101 from the input\nassign out = in - 4'b0101;\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    output [3:0] out\n);\n\nwire [3:0] pos;\npriority_encoder pe(\n    .in(in),\n    .pos(pos)\n);\n\nsubtractor sub(\n    .in(pos),\n    .out(out)\n);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_16bit_signed_unsigned_9b57df62", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_16bit_signed_unsigned (\n    input signed [15:0] a,\n    input signed [15:0] b,\n    input cin,\n    output signed [15:0] sum,\n    output cout\n);\n    wire [15:0] unsigned_sum;\n    wire unsigned_cout;\n\n    assign unsigned_sum = a + b + cin;\n    assign cout = (a[15] & b[15]) | ((a[15] | b[15]) & ~unsigned_sum[15]);\n    assign sum = (a[15] == b[15]) ? unsigned_sum : (a > b) ? a + b : b + a;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_26499a16", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input clear,\n    input load,\n    input up_down,\n    input [3:0] data,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk) begin\n        if (clear) begin\n            count <= 4'b0;\n        end else if (load) begin\n            count <= data;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nukv_Read #_4997784c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule nukv_Read #(\n\tparameter KEY_WIDTH = 128,\n\tparameter META_WIDTH = 96,\n\tparameter HASHADDR_WIDTH = 32,\n    parameter MEMADDR_WIDTH = 20\n\t)\n    (\n\t// Clock\n\tinput wire         clk,\n\tinput wire         rst,\n\n\tinput  wire [KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:0] input_data,\n\tinput  wire         input_valid,\n\toutput wire         input_ready,\n\n\tinput  wire [KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:0] feedback_data,\n\tinput  wire         feedback_valid,\n\toutput wire         feedback_ready,\n\n\toutput reg [KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:0] output_data,\n\toutput reg         output_valid,\n\tinput  wire         output_ready,\n\n\toutput reg [31:0] rdcmd_data,\n\toutput reg         rdcmd_valid,\n\tinput  wire         rdcmd_ready,\n\n\tinput  wire [31:0] mem_data,\n\toutput reg         mem_valid\n);\n\n    reg selectInputNext;\n    reg selectInput; //1 == input, 0==feedback\n\n\tlocalparam [2:0]\n\t\tST_IDLE   = 0,\n\t\tST_ISSUE_READ = 3,\n\t\tST_OUTPUT_KEY  = 4;\n\treg [2:0] state;    \n\n    wire[HASHADDR_WIDTH+KEY_WIDTH+META_WIDTH-1:0] in_data;\n    wire in_valid;\n    reg in_ready;\n    wire[31:0] hash_data;\n\n\n    assign in_data = (selectInput==1) ? input_data : feedback_data;\n    assign in_valid = (selectInput==1) ? input_valid : feedback_valid;\n    assign input_ready = (selectInput==1) ? in_ready : 0;\n    assign feedback_ready = (selectInput==1) ? 0 : in_ready;\n\n    assign hash_data = (selectInput==1) ? input_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH] : feedback_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH];    \n\n    wire[MEMADDR_WIDTH-1:0] addr;    \n\n    assign addr = hash_data[31:32 - MEMADDR_WIDTH] ^ hash_data[MEMADDR_WIDTH-1:0];\n\n    reg [7:0] cache [0:31];\n\n    always @(posedge clk) begin\n    \tif (rst) begin\n    \t\tselectInput <= 1;\n    \t\tselectInputNext <= 0;    \t\t\n    \t\tstate <= ST_IDLE;\n    \t\tin_ready <= 0;\n    \t\trdcmd_valid <= 0;\n    \t\toutput_valid <= 0;\n            mem_valid <= 0;\n    \tend\n    \telse begin\n\n    \t\tif (rdcmd_ready==1 && rdcmd_valid==1) begin\n    \t\t\trdcmd_valid <= 0;\n    \t\tend\n\n    \t\tif (output_ready==1 && output_valid==1) begin\n    \t\t\toutput_valid <= 0;\n    \t\tend\n\n            in_ready <= 0;\n\n\n    \t\tcase (state)    \t\t\n    \t\t\tST_IDLE : begin\n    \t\t\t\tif (output_ready==1 && rdcmd_ready==1) begin\n    \t\t\t\t\tselectInput <= selectInputNext;\n    \t\t\t\t\tselectInputNext <= ~selectInputNext;\n\n    \t\t\t\t\tif (selectInputNext==1 && input_valid==0 && feedback_valid==1) begin\n    \t\t\t\t\t\tselectInput <= 0;\n    \t\t\t\t\t\tselectInputNext <= 1;    \t\t\t\t\t\t\n    \t\t\t\t\tend\n\n    \t\t\t\t\tif (selectInputNext==0 && input_valid==1 && feedback_valid==0) begin\n    \t\t\t\t\t\tselectInput <= 1;\n    \t\t\t\t\t\tselectInputNext <= 0;    \t\t\t\t\t\t\n    \t\t\t\t\tend\n\n    \t\t\t\t\tif (selectInput==1 && input_valid==1) begin\n    \t\t\t\t\t\tstate <= ST_ISSUE_READ;    \t\t\t\t\t\t\n    \t\t\t\t\tend\n\n\t\t\t\t\t\tif (selectInput==0 && feedback_valid==1) begin\n    \t\t\t\t\t\tstate <= ST_ISSUE_READ;    \t\t\t\t\t\t\n    \t\t\t\t\tend    \t\t\t\t\t\n\n    \t\t\t\tend\n    \t\t\tend\n\n    \t\t\tST_ISSUE_READ: begin    \t\t\t\n                    if (in_data[KEY_WIDTH+META_WIDTH-4]==1) begin\n                        // ignore this and don't send read!\n\n                    end else begin\t\t\t                        \n                        if (cache[addr[4:0]] == mem_data) begin\n                            // data is present in cache\n                            output_data <= cache[addr[4:0]];\n                            output_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH] <= addr;\n                            output_valid <= 1;\n                            mem_valid <= 0;\n                        end else begin\n                            // data is not present in cache\n            \t\t\t\trdcmd_data <= addr;\n            \t\t\t\trdcmd_valid <= 1;\n                            rdcmd_data[31:MEMADDR_WIDTH] <= 0;\n            \t\t\t\tstate <= ST_OUTPUT_KEY;                      \n                            in_ready <= 1;\n                        end\n                    end\n    \t\t\tend\n\n    \t\t\tST_OUTPUT_KEY: begin\n    \t\t\t\tif (output_ready==1) begin\n                        cache[addr[4:0]] <= mem_data;\n                        output_data <= mem_data;\n                        output_data[KEY_WIDTH+META_WIDTH+HASHADDR_WIDTH-1:KEY_WIDTH+META_WIDTH] <= addr;\n                        output_valid <= 1;\n                        mem_valid <= 0;\n                        state <= ST_IDLE;\n    \t\t\t\tend\n    \t\t\tend\n\n\n    \t\tendcase\n    \tend\n    end\n        \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_light_tx_ctrl_20f797f5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_light_tx_ctrl\n#(\n\tparameter STATE_COUNT = 2,\n\tparameter IDLE = 2'b00,\n\tparameter LOAD = 2'b01,\n\tparameter TRANSMITTING = 2'b10\n)(\n\tinput  wire reset,\n\tinput  wire clk_tx,\n\n\t//Interfaces zum SPMC\n\tinput  wire word_ready,\n\toutput wire fifo_tx_full,\n\toutput wire fifo_tx_empty,\n\t\n\t//Interfaces zum Datenpfad-Module, welche durch clk_tx getrieben werden\n\tinput  wire frame_done,\n\toutput reg  transmit,\n\toutput reg  clear,\n\toutput reg  fifo_read_enable,\n\t\n\t//Interfaces zum Datenpfad-Module, welche durch clk_peri getrieben werden\n\tinput wire  fifo_full,\n\tinput wire  fifo_empty,\n\toutput wire fifo_write_enable\n\n    );\n\n\treg [STATE_COUNT-1:0] state_cur, state_next;\n\t\n\tassign fifo_tx_full      = fifo_full;\n\tassign fifo_tx_empty     = fifo_empty;\n \tassign fifo_write_enable = word_ready & (~fifo_full);\n\t\n\talways @(*) begin\n\t\ttransmit         = 1'b0;\n\t\tclear            = 1'b0;\n\t\tfifo_read_enable = 1'b0;\n\t\tstate_next       = IDLE;\n\t\t\n\t\tcase(state_cur)\n\t\t\tIDLE:\n\t\t\t\tif (fifo_empty == 1'b0) begin\n\t\t\t\t\tstate_next       = LOAD;\n\t\t\t\tend\n\t\t\tLOAD:\n\t\t\t\tbegin\n\t\t\t\t\tfifo_read_enable = 1'b1;\n\t\t\t\t\tstate_next\t = TRANSMITTING;\n\t\t\t\tend\n\t\t\tTRANSMITTING:\n\t\t\t\tif(frame_done) begin\n\t\t\t\t\tclear      = 1'b1;\n\t\t\t\t\tstate_next = IDLE;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\ttransmit   = 1'b1;\n\t\t\t\t\tstate_next = TRANSMITTING;\n\t\t\t\tend\n\t\t\tdefault: state_next = IDLE;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk_tx, posedge reset) begin\n\t\tif(reset) begin\n\t\t\tstate_cur <= IDLE;\n\t\tend\n\t\telse begin \n\t\t\tstate_cur <= state_next;\n\t\tend\n\tend\n\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mkSoC_Map_4feb9d06", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`ifdef BSV_ASSIGNMENT_DELAY\n`else\n  `define BSV_ASSIGNMENT_DELAY\n`endif\n\n`ifdef BSV_POSITIVE_RESET\n  `define BSV_RESET_VALUE 1'b1\n  `define BSV_RESET_EDGE posedge\n`else\n  `define BSV_RESET_VALUE 1'b0\n  `define BSV_RESET_EDGE negedge\n`endif\n\nmodule mkSoC_Map(CLK,\n\t\t RST_N,\n\n\t\t m_near_mem_io_addr_base,\n\n\t\t m_near_mem_io_addr_size,\n\n\t\t m_near_mem_io_addr_lim,\n\n\t\t m_plic_addr_base,\n\n\t\t m_plic_addr_size,\n\n\t\t m_plic_addr_lim,\n\n\t\t m_uart0_addr_base,\n\n\t\t m_uart0_addr_size,\n\n\t\t m_uart0_addr_lim,\n\n\t\t m_boot_rom_addr_base,\n\n\t\t m_boot_rom_addr_size,\n\n\t\t m_boot_rom_addr_lim,\n\n\t\t m_mem0_controller_addr_base,\n\n\t\t m_mem0_controller_addr_size,\n\n\t\t m_mem0_controller_addr_lim,\n\n\t\t m_tcm_addr_base,\n\n\t\t m_tcm_addr_size,\n\n\t\t m_tcm_addr_lim,\n\n\t\t m_is_mem_addr_addr,\n\t\t m_is_mem_addr,\n\n\t\t m_is_IO_addr_addr,\n\t\t m_is_IO_addr,\n\n\t\t m_is_near_mem_IO_addr_addr,\n\t\t m_is_near_mem_IO_addr,\n\n\t\t m_pc_reset_value,\n\n\t\t m_mtvec_reset_value,\n\n\t\t m_nmivec_reset_value);\n  input  CLK;\n  input  RST_N;\n\n  output [63 : 0] m_near_mem_io_addr_base;\n\n  output [63 : 0] m_near_mem_io_addr_size;\n\n  output [63 : 0] m_near_mem_io_addr_lim;\n\n  output [63 : 0] m_plic_addr_base;\n\n  output [63 : 0] m_plic_addr_size;\n\n  output [63 : 0] m_plic_addr_lim;\n\n  output [63 : 0] m_uart0_addr_base;\n\n  output [63 : 0] m_uart0_addr_size;\n\n  output [63 : 0] m_uart0_addr_lim;\n\n  output [63 : 0] m_boot_rom_addr_base;\n\n  output [63 : 0] m_boot_rom_addr_size;\n\n  output [63 : 0] m_boot_rom_addr_lim;\n\n  output [63 : 0] m_mem0_controller_addr_base;\n\n  output [63 : 0] m_mem0_controller_addr_size;\n\n  output [63 : 0] m_mem0_controller_addr_lim;\n\n  output [63 : 0] m_tcm_addr_base;\n\n  output [63 : 0] m_tcm_addr_size;\n\n  output [63 : 0] m_tcm_addr_lim;\n\n  input  [63 : 0] m_is_mem_addr_addr;\n  output m_is_mem_addr;\n\n  input  [63 : 0] m_is_IO_addr_addr;\n  output m_is_IO_addr;\n\n  input  [63 : 0] m_is_near_mem_IO_addr_addr;\n  output m_is_near_mem_IO_addr;\n\n  output [63 : 0] m_pc_reset_value;\n\n  output [63 : 0] m_mtvec_reset_value;\n\n  output [63 : 0] m_nmivec_reset_value;\n\n  wire [63 : 0] m_boot_rom_addr_base,\n\t\tm_boot_rom_addr_lim,\n\t\tm_boot_rom_addr_size,\n\t\tm_mem0_controller_addr_base,\n\t\tm_mem0_controller_addr_lim,\n\t\tm_mem0_controller_addr_size,\n\t\tm_mtvec_reset_value,\n\t\tm_near_mem_io_addr_base,\n\t\tm_near_mem_io_addr_lim,\n\t\tm_near_mem_io_addr_size,\n\t\tm_nmivec_reset_value,\n\t\tm_pc_reset_value,\n\t\tm_plic_addr_base,\n\t\tm_plic_addr_lim,\n\t\tm_plic_addr_size,\n\t\tm_tcm_addr_base,\n\t\tm_tcm_addr_lim,\n\t\tm_tcm_addr_size,\n\t\tm_uart0_addr_base,\n\t\tm_uart0_addr_lim,\n\t\tm_uart0_addr_size;\n  wire m_is_IO_addr, m_is_mem_addr, m_is_near_mem_IO_addr;\n\n  assign m_near_mem_io_addr_base = 64'h0000000002000000 ;\n\n  assign m_near_mem_io_addr_size = 64'h000000000000C000 ;\n\n  assign m_near_mem_io_addr_lim = 64'd33603584 ;\n\n  assign m_plic_addr_base = 64'h000000000C000000 ;\n\n  assign m_plic_addr_size = 64'h0000000000400000 ;\n\n  assign m_plic_addr_lim = 64'd205520896 ;\n\n  assign m_uart0_addr_base = 64'h00000000C0000000 ;\n\n  assign m_uart0_addr_size = 64'h0000000000000080 ;\n\n  assign m_uart0_addr_lim = 64'h00000000C0000080 ;\n\n  assign m_boot_rom_addr_base = 64'h0000000000001000 ;\n\n  assign m_boot_rom_addr_size = 64'h0000000000001000 ;\n\n  assign m_boot_rom_addr_lim = 64'd8192 ;\n\n  assign m_mem0_controller_addr_base = 64'h0000000080000000 ;\n\n  assign m_mem0_controller_addr_size = 64'h0000000010000000 ;\n\n  assign m_mem0_controller_addr_lim = 64'h0000000090000000 ;\n\n  assign m_tcm_addr_base = 64'h0 ;\n\n  assign m_tcm_addr_size = 64'd0 ;\n\n  assign m_tcm_addr_lim = 64'd0 ;\n\n  assign m_is_mem_addr =\n\t     m_is_mem_addr_addr >= 64'h0000000000001000 &&\n\t     m_is_mem_addr_addr < 64'd8192 ||\n\t     m_is_mem_addr_addr >= 64'h0000000080000000 &&\n\t     m_is_mem_addr_addr < 64'h0000000090000000 ;\n\n  assign m_is_IO_addr =\n\t     m_is_IO_addr_addr >= 64'h0000000002000000 &&\n\t     m_is_IO_addr_addr < 64'd33603584 ||\n\t     m_is_IO_addr_addr >= 64'h000000000C000000 &&\n\t     m_is_IO_addr_addr < 64'd205520896 ||\n\t     m_is_IO_addr_addr >= 64'h00000000C0000000 &&\n\t     m_is_IO_addr_addr < 64'h00000000C0000080 ;\n\n  assign m_is_near_mem_IO_addr =\n\t     m_is_near_mem_IO_addr_addr >= 64'h0000000002000000 &&\n\t     m_is_near_mem_IO_addr_addr < 64'd33603584 ;\n\n  assign m_pc_reset_value = 64'h0000000000001000 ;\n\n  assign m_mtvec_reset_value = 64'h0000000000001000 ;\n\n  assign m_nmivec_reset_value = 64'hAAAAAAAAAAAAAAAA ;\nendmodule  "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_en_cd74722e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_en(\n    input [2:0] a, b, c,\n    input en,\n    output y\n);\n\n    wire [2:0] and_result;\n    assign and_result = a & b & c;\n    \n    assign y = en ? and_result[0] & and_result[1] & and_result[2] : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_2dc2d92a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder(\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule four_bit_adder(\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire c1, c2, c3;\n  full_adder fa1(a[0], b[0], cin, sum[0], c1);\n  full_adder fa2(a[1], b[1], c1, sum[1], c2);\n  full_adder fa3(a[2], b[2], c2, sum[2], c3);\n  full_adder fa4(a[3], b[3], c3, sum[3], cout);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "karnaugh_map_a96bec34", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule karnaugh_map(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @*\n    case ({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0010: F = 1'b1;\n      4'b0011: F = 1'b0;\n      4'b0100: F = 1'b1;\n      4'b0101: F = 1'b0;\n      4'b0110: F = 1'b0;\n      4'b0111: F = 1'b1;\n      4'b1000: F = 1'b0;\n      4'b1001: F = 1'b1;\n      4'b1010: F = 1'b1;\n      4'b1011: F = 1'b0;\n      4'b1100: F = 1'b1;\n      4'b1101: F = 1'b0;\n      4'b1110: F = 1'b0;\n      4'b1111: F = 1'b1;\n    endcase\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CLS_LED_Output_Multiplexer_b7c6ea58", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule CLS_LED_Output_Multiplexer\n(\n\tinput [9:0]\t\tPWM_CHANNEL_SIGS,\n\tinput \t\t\tPWM_TIMER_TICK,\n\tinput \t\t\tSRT_TICK,\n\toutput reg [9:0] \tLEDR,\n\tinput \t\t\tCLK\n);\n\t\n\treg [4:0] frame_pos;\n\treg [4:0] next_frame_pos;\n\treg [4:0] frame_pos_sync;\n\twire [9:0] pchs = PWM_CHANNEL_SIGS;\n\t\n\tinitial\n\tbegin\n\t\tframe_pos = 5'h0;\n\t\tnext_frame_pos = 5'h0;\n\tend\n\n\talways @(*)\n\tbegin\n\t\tcase (frame_pos)\n\t\t\t5'b00000 : next_frame_pos <= 5'b00001;\n\t\t\t5'b00001 : next_frame_pos <= 5'b00011;\n\t\t\t5'b00011 : next_frame_pos <= 5'b00010;\n\t\t\t5'b00010 : next_frame_pos <= 5'b00110;\n\t\t\t5'b00110 : next_frame_pos <= 5'b00111;\n\t\t\t5'b00111 : next_frame_pos <= 5'b00101;\n\t\t\t5'b00101 : next_frame_pos <= 5'b00100;\n\t\t\t5'b00100 : next_frame_pos <= 5'b01100;\n\t\t\t5'b01100 : next_frame_pos <= 5'b11100;\n\t\t\t5'b11100 : next_frame_pos <= 5'b10100;\n\t\t\t5'b10100 : next_frame_pos <= 5'b10101;\n\t\t\t5'b10101 : next_frame_pos <= 5'b10111;\n\t\t\t5'b10111 : next_frame_pos <= 5'b10110;\n\t\t\t5'b10110 : next_frame_pos <= 5'b10010;\n\t\t\t5'b10010 : next_frame_pos <= 5'b10011;\n\t\t\t5'b10011 : next_frame_pos <= 5'b10001;\n\t\t\t5'b10001 : next_frame_pos <= 5'b10000;\n\t\t\t5'b10000 : next_frame_pos <= 5'b00000;\n\t\t\tdefault : next_frame_pos <= 5'b00000;\n\t\tendcase\n\tend\t\n\t\n\talways @(posedge SRT_TICK)\n\tbegin\n\t\tframe_pos <= next_frame_pos;\n\tend\n\t\n\talways @(posedge PWM_TIMER_TICK)\n\tbegin\n\t\tframe_pos_sync <= frame_pos;\n\tend\n\t\n\talways @*\n\tbegin\n\t\tcase (frame_pos_sync)\n\t\t\t5'b00000 : LEDR <= { pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0] };\n\t\t\t5'b00001 : LEDR <= { pchs[8], pchs[9], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0], pchs[0] };\n\t\t\t5'b00011 : LEDR <= { pchs[7], pchs[8], pchs[9], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00010 : LEDR <= { pchs[6], pchs[7], pchs[8], pchs[9], pchs[2], pchs[1], pchs[0], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00110 : LEDR <= { pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00111 : LEDR <= { pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00101 : LEDR <= { pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0], pchs[0] };\n\t\t\t5'b00100 : LEDR <= { pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0], pchs[0] };\n\t\t\t5'b01100 : LEDR <= { pchs[1], pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9], pchs[0] };\n\t\t\t5'b11100 : LEDR <= { pchs[0], pchs[1], pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[7], pchs[8], pchs[9] };\n\t\t\t5'b10100 : LEDR <= { pchs[0], pchs[0], pchs[1], pchs[2], pchs[3], pchs[4], pchs[5], pchs[6], pchs[9], pchs[8] };\n\t\t\t5'b10101 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[1], pchs[2], pchs[3], pchs[4], pchs[9], pchs[8], pchs[7] };\n\t\t\t5'b10111 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[0], pchs[1], pchs[2], pchs[9], pchs[8], pchs[7], pchs[6] };\n\t\t\t5'b10110 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5] };\n\t\t\t5'b10010 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4] };\n\t\t\t5'b10011 : LEDR <= { pchs[0], pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3] };\n\t\t\t5'b10001 : LEDR <= { pchs[0], pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2] };\n\t\t\t5'b10000 : LEDR <= { pchs[0], pchs[9], pchs[8], pchs[7], pchs[6], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1] };\n\t\t\tdefault  : LEDR <= { pchs[0], pchs[9], pchs[8], pchs[7], pchs[5], pchs[4], pchs[3], pchs[2], pchs[1], pchs[0] };\n\t\tendcase\n\tend\n\t\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vga640x480_a15bb799", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule vga640x480(\n\tCLK,\n\tCLR,\n\tHSYNC,\n\tVSYNC,\n\tHC,\n\tVC,\n\tVIDON\n);\n\ninput CLK;  input CLR;  output HSYNC; output VSYNC; output [9:0] HC; output [9:0] VC; output VIDON;    localparam hpixels = 800 , vlines = 521 , hbp = 144 , hfp = 784 , vbp = 31  , vfp = 511 ; reg [9:0] HCS, VCS; reg VSenable;\t\t  assign HC    = HCS;\nassign VC    = VCS;\nassign HSYNC = (HCS < 128) ? 1'b0 : 1'b1; assign VSYNC = (VCS < 2)   ? 1'b0 : 1'b1; assign VIDON = (((HCS < hfp) && (HCS >= hbp)) && ((VCS < vfp) && (VCS >= vbp))) ? 1'b1 : 1'b0;\n\n\nalways @ (posedge CLK)\nbegin\n\tif(CLR == 1'b1)\n\t\tHCS <= 10'b0000000000;\n\t\n\telse if(CLK == 1'b1) \n\tbegin\n\t\tif(HCS < (hpixels - 1'b1) )\n\t\tbegin\n\t\t\tHCS <= HCS + 1'b1;\n\t\t\tVSenable <= 1'b0;  end\n\t\telse\n\t\tbegin\t\n\t\t\tHCS <= 10'b0000000000; VSenable <= 1'b1; \t  end\t\n\tend\nend\n\n\n\nalways @ (posedge CLK)\nbegin\n\tif(CLR == 1'b1)\n\t\tVCS <= 10'b0000000000;\n\t\t\n\telse if(CLK == 1'b1 && VSenable == 1'b1)\n\tbegin\n\t\tif( VCS < (vlines - 1'b1) )\n\t\tbegin\n\t\t\tVCS <= VCS + 1'b1; end\n\t\telse\n\t\tbegin\n\t\t\tVCS <= 10'b0000000000; \n\t\tend\n\tend\nend\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alu_flags_5a127a0a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule alu_flags \n#(parameter DATA_WIDTH = 32)\n(\n    input [DATA_WIDTH-1:0] srcA,\n    input [DATA_WIDTH-1:0] srcB,\n    input [3:0] aluop,\n    output zero,\n    output of,\n    output uof\n);\n\n    wire [DATA_WIDTH-1:0] sum, diff;\n    wire carry1, carry2;\n    \n    assign {carry1, sum} = srcA + srcB;    assign {carry2, diff} = srcA - srcB;    assign zero = (srcA == srcB);\n    assign of = (aluop == 4'd5) ? ((srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & ~sum[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & sum[DATA_WIDTH-1]))\n                : (aluop == 4'd6) ? ((srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & ~diff[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & diff[DATA_WIDTH-1]))\n                : 0;\n    assign uof = (aluop == 4'd5) ? (carry1)\n                : (aluop == 4'd6) ? (carry2)\n                : 0;\n    \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "antares_divider_d649f153", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule antares_divider (\n                        input         clk,\n                        input         rst,\n                        input         op_divs,\n                        input         op_divu,\n                        input [31:0]  dividend,\n                        input [31:0]  divisor,\n                        output [31:0] quotient,\n                        output [31:0] remainder,\n                        output        div_stall\n                        );\n\n    reg           active;          reg           neg_result;      reg           neg_remainder;   reg [4:0]     cycle;           reg [31:0]    result;          reg [31:0]    denominator;     reg [31:0]    residual;        wire [32:0]   partial_sub;        assign quotient    = !neg_result ? result : -result;\n    assign remainder   = !neg_remainder ? residual : -residual;\n    assign div_stall   = active;\n    assign partial_sub = {residual[30:0], result[31]} - denominator;            always @(posedge clk) begin\n        if (rst) begin\n            \n            active <= 1'h0;\n            cycle <= 5'h0;\n            denominator <= 32'h0;\n            neg_result <= 1'h0;\n            neg_remainder <= 1'h0;\n            residual <= 32'h0;\n            result <= 32'h0;\n            end\n        else begin\n            if(op_divs) begin\n                cycle         <= 5'd31;\n                result        <= (dividend[31] == 1'b0) ? dividend : -dividend;\n                denominator   <= (divisor[31] == 1'b0) ? divisor : -divisor;\n                residual      <= 32'b0;\n                neg_result    <= dividend[31] ^ divisor[31];\n                neg_remainder <= dividend[31];\n                active        <= 1'b1;\n            end\n            else if (op_divu) begin\n                cycle         <= 5'd31;\n                result        <= dividend;\n                denominator   <= divisor;\n                residual      <= 32'b0;\n                neg_result    <= 1'b0;\n                neg_remainder <= 1'h0;\n                active        <= 1'b1;\n            end\n            else if (active) begin\n                if(partial_sub[32] == 1'b0) begin\n                    residual <= partial_sub[31:0];\n                    result   <= {result[30:0], 1'b1};\n                end\n                else begin\n                    residual <= {residual[30:0], result[31]};\n                    result   <= {result[30:0], 1'b0};\n                end\n\n                if (cycle == 5'b0) begin\n                    active <= 1'b0;\n                end\n\n                cycle <= cycle - 5'd1;\n            end\n        end\n    end\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_block_e4168024", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier_block (\n    input [31:0] i_data0,\n    output [31:0] o_data0\n);\n\n  wire [31:0]\n    w1,\n    w512,\n    w511,\n    w64,\n    w575,\n    w2300,\n    w2875;\n\n  assign w1 = i_data0;\n  assign w512 = w1 << 9;\n  assign w64 = w1 << 6;\n  assign w511 = w512 - w1;\n  assign w575 = w511 + w64;\n  assign w2300 = w575 << 2;\n  assign w2875 = w575 + w2300;\n  assign o_data0 = w2875;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_8515edcf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    // Define internal signals\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    // Generate the sum and carry signals\n    full_adder fa0(A[0], B[0], Cin, sum[0], carry[0]);\n    full_adder fa1(A[1], B[1], carry[0], sum[1], carry[1]);\n    full_adder fa2(A[2], B[2], carry[1], sum[2], carry[2]);\n    full_adder fa3(A[3], B[3], carry[2], sum[3], Cout);\n\n    // Assign the sum signal to the output port\n    assign S = sum;\n\nendmodule\n\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    // Define internal signals\n    wire sum;\n    wire Cout1;\n    wire Cout2;\n\n    // Generate the sum and carry signals\n    xor(sum, A, B);\n    xor(S, sum, Cin);\n    and(Cout1, A, B);\n    and(Cout2, sum, Cin);\n    or(Cout, Cout1, Cout2);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "timer #_759244ff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule timer #\n(\n    parameter WIDTH = 64,\n    parameter USE_2XCLK = 0,\n    parameter S_WIDTH_A = 2\n)\n(\n    input clk,\n    input clk2x,\n    input resetn,\n\n    // Slave port\n    input [S_WIDTH_A-1:0] slave_address,  // Word address\n    input [WIDTH-1:0] slave_writedata,\n    input slave_read,\n    input slave_write,\n    input [WIDTH/8-1:0] slave_byteenable,\n    output slave_waitrequest,\n    output [WIDTH-1:0] slave_readdata,\n    output slave_readdatavalid\n);\n\nreg [WIDTH-1:0] counter;\nreg [WIDTH-1:0] counter2x;\n\nreg clock_sel;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    clock_sel <= 1'b0;\n  else if (slave_write)\n    if (|slave_writedata)\n      clock_sel <= 1'b1;\n    else\n      clock_sel <= 1'b0;\n\nalways@(posedge clk or negedge resetn)\n  if (!resetn)\n    counter <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter <= {WIDTH{1'b0}};\n  else\n    counter <= counter + 2'b01;\n\nalways@(posedge clk2x or negedge resetn)\n  if (!resetn)\n    counter2x <= {WIDTH{1'b0}};\n  else if (slave_write)\n    counter2x <= {WIDTH{1'b0}};\n  else\n    counter2x <= counter2x + 2'b01;\n\nassign slave_waitrequest = 1'b0;\nassign slave_readdata = (USE_2XCLK && clock_sel) ? counter2x : counter;\nassign slave_readdatavalid = slave_read;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Test_02a85421", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Test (\n    input clk, \n    input rstn, \n    input clken, \n    input [3:0] in, \n    output [3:0] ff_out, \n    output [3:0] fg_out, \n    output [3:0] fh_out\n);\n\n    reg [3:0] in_reg;\n    reg [3:0] ff_out_reg;\n    reg [3:0] fg_out_reg;\n    reg [3:0] fh_out_reg;\n\n    always @(posedge clk) begin\n        if (rstn == 0) begin\n            in_reg <= 0;\n            ff_out_reg <= 0;\n            fg_out_reg <= 0;\n            fh_out_reg <= 0;\n        end\n        else if (clken == 1) begin\n            in_reg <= in;\n            ff_out_reg <= in_reg * 2;\n            fg_out_reg <= in_reg * 3;\n            fh_out_reg <= in_reg * 4;\n        end\n    end\n\n    assign ff_out = ff_out_reg;\n    assign fg_out = fg_out_reg;\n    assign fh_out = fh_out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_2bit_c177ea70", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder_2bit(input [1:0] A, B, S, output [1:0] O);\n\n  wire [1:0] sum;\n  wire [1:0] diff;\n\n  wire s_not;\n  not (s_not, S);\n\n  // Calculate sum and difference\n  assign sum = A + B;\n  assign diff = {A[1] ^ B[1], A[0] ^ B[0]} + {~B[1], ~B[0], 1'b0};\n\n  // Use mux2to1 to select output based on S\n  assign O = s_not ? sum : diff;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt12_eg_ctrl_38fea812", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule jt12_eg_ctrl(\n\tinput\t\t\t\tkeyon_now,\n\tinput\t\t\t\tkeyoff_now,\n\tinput\t\t[2:0]\tstate_in,\n\tinput\t\t[9:0]\teg,\n\tinput\t\t[4:0]\tarate, input\t\t[4:0]\trate1, input\t\t[4:0]\trate2, input\t\t[3:0]\trrate,\n\tinput\t\t[3:0]\tsl,   input\t\t\t\tssg_en,\n\tinput\t\t[2:0]\tssg_eg,\n\tinput\t\t\t\tssg_inv_in,\n\toutput reg\t\t\tssg_inv_out,\n\n\toutput reg\t[4:0]\tbase_rate,\n\toutput reg\t[2:0]\tstate_next,\n\toutput reg\t\t\tpg_rst\n);\n\nlocalparam \tATTACK = 3'b001,\n\t\t\tDECAY  = 3'b010,\n\t\t\tHOLD   = 3'b100,\n\t\t\tRELEASE= 3'b000; reg\t\t[4:0]\tsustain;\n\nalways @(*)\n\tif( sl == 4'd15 )\n\t\tsustain = 5'h1f; else\n\t\tsustain = {1'b0, sl};\n\nwire\tssg_en_out;\nreg\t\tssg_en_in, ssg_pg_rst;\n\nwire ssg_att  = ssg_eg[2];\nwire ssg_alt  = ssg_eg[1];\nwire ssg_hold = ssg_eg[0] & ssg_en;\n\nreg ssg_over;\n\n\nalways @(*) begin\n\tssg_over = ssg_en && eg[9]; ssg_pg_rst = ssg_over && !( ssg_alt || ssg_hold );\n\tpg_rst = keyon_now | ssg_pg_rst;\nend\n\nalways @(*)\n\tcasez ( { keyoff_now, keyon_now, state_in} )\n\t\t5'b01_???: begin base_rate\t= arate;\n\t\t\tstate_next\t= ATTACK;\n\t\t\tssg_inv_out\t= ssg_att & ssg_en;\n\t\tend\n\t\t{2'b00, ATTACK}:\n\t\t\tif( eg==10'd0 ) begin\n\t\t\t\tbase_rate\t= rate1;\n\t\t\t\tstate_next\t= DECAY;\n\t\t\t\tssg_inv_out\t= ssg_inv_in;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tbase_rate\t= arate;\n\t\t\t\tstate_next\t= ATTACK;\n\t\t\t\tssg_inv_out\t= ssg_inv_in;\n\t\t\tend\n\t\t{2'b00, DECAY}: begin\n\t\t\tif( ssg_over ) begin\n\t\t\t\tbase_rate\t= ssg_hold ? 5'd0 : arate;\n\t\t\t\tstate_next\t= ssg_hold ? HOLD : ATTACK;\n\t\t\t\tssg_inv_out\t= ssg_en & (ssg_alt ^ ssg_inv_in);\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tbase_rate\t=  eg[9:5] >= sustain ? rate2 : rate1; state_next\t= DECAY;\n\t\t\t\tssg_inv_out = ssg_inv_in;\n\t\t\tend\n\t\tend\n\t\t{2'b00, HOLD}: begin\n\t\t\tbase_rate\t= 5'd0;\n\t\t\tstate_next\t= HOLD;\n\t\t\tssg_inv_out\t= ssg_inv_in;\n\t\tend\n\t\tdefault: begin base_rate\t= { rrate, 1'b1 };\n\t\t\tstate_next\t= RELEASE;\tssg_inv_out\t= 1'b0; end\n\tendcase\n\n\nendmodule // jt12_eg_ctrl"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_4to16_pipeline_49eb95c3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule decoder_4to16_pipeline (\n    input A, B,\n    output reg [15:0] Y\n);\n\nreg [1:0] stage1_A, stage1_B;\nreg [3:0] stage2_A, stage2_B;\nreg [7:0] stage3_A, stage3_B;\n\nalways @(A or B) begin\n    stage1_A <= A;\n    stage1_B <= B;\nend\n\nalways @(stage1_A or stage1_B) begin\n    stage2_A <= stage1_A;\n    stage2_B <= stage1_B;\nend\n\nalways @(stage2_A or stage2_B) begin\n    stage3_A <= stage2_A;\n    stage3_B <= stage2_B;\nend\n\nalways @(stage3_A or stage3_B) begin\n    if (stage3_A == 2'b00) begin\n        Y <= 16'b0000000000000001;\n    end else if (stage3_A == 2'b01) begin\n        Y <= 16'b0000000000000010;\n    end else if (stage3_A == 2'b10) begin\n        Y <= 16'b0000000000000100;\n    end else if (stage3_A == 2'b11) begin\n        Y <= 16'b1000000000000000;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_c9bd1d6f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor(A, B, mode, result);\ninput [3:0] A, B;\ninput mode;\noutput reg [3:0] result;\n\nalways @(*) begin\n\tif(mode == 0)\n\t\tresult <= A + B;\n\telse\n\t\tresult <= A - B;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AGC_9b609e7b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule AGC (\n  input [15:0] input_signal,\n  input [7:0] control_signal,\n  output [15:0] output_signal\n);\n\nparameter gain_bits = 8; // number of bits used to represent the gain value\n\nreg [gain_bits-1:0] gain_value; // binary value representing the gain\nreg [15:0] adjusted_signal; // signal with constant output level\n\n// Function to adjust the gain based on the control signal\nfunction [gain_bits-1:0] adjust_gain;\n  input [7:0] control;\n  begin\n    case (control)\n      8'h00: adjust_gain = 8'h00; // no gain adjustment\n      8'h01: adjust_gain = 8'h01; // small gain increase\n      8'h02: adjust_gain = 8'h02;\n      8'h03: adjust_gain = 8'h03;\n      8'h04: adjust_gain = 8'h04;\n      8'h05: adjust_gain = 8'h05;\n      8'h06: adjust_gain = 8'h06;\n      8'h07: adjust_gain = 8'h07;\n      8'h08: adjust_gain = 8'h08; // maximum gain increase\n      8'h09: adjust_gain = 8'h09; // no gain adjustment\n      8'h0A: adjust_gain = 8'h0A;\n      8'h0B: adjust_gain = 8'h0B;\n      8'h0C: adjust_gain = 8'h0C;\n      8'h0D: adjust_gain = 8'h0D;\n      8'h0E: adjust_gain = 8'h0E;\n      8'h0F: adjust_gain = 8'h0F;\n      8'h10: adjust_gain = 8'h10; // maximum gain reduction\n      8'h11: adjust_gain = 8'h11; // no gain adjustment\n      8'h12: adjust_gain = 8'h12;\n      8'h13: adjust_gain = 8'h13;\n      8'h14: adjust_gain = 8'h14;\n      8'h15: adjust_gain = 8'h15;\n      8'h16: adjust_gain = 8'h16;\n      8'h17: adjust_gain = 8'h17;\n      8'h18: adjust_gain = 8'h18; // small gain reduction\n      default: adjust_gain = 8'h00; // no gain adjustment\n    endcase\n  end\nendfunction\n\n// Assign the gain value based on the control signal\nalways @ (control_signal) begin\n  gain_value = adjust_gain(control_signal);\nend\n\n// Compute the adjusted signal with constant output level\nalways @ (input_signal, gain_value) begin\n  adjusted_signal = input_signal * gain_value;\nend\n\n// Assign the output signal\nassign output_signal = adjusted_signal;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "EHRU_6_b8b37591", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule EHRU_6 (\n    CLK,\n    read_0,\n    write_0,\n    EN_write_0,\n    read_1,\n    write_1,\n    EN_write_1,\n    read_2,\n    write_2,\n    EN_write_2,\n    read_3,\n    write_3,\n    EN_write_3,\n    read_4,\n    write_4,\n    EN_write_4,\n    read_5,\n    write_5,\n    EN_write_5\n);\n    parameter            DATA_SZ = 1;\n    parameter            RESET_VAL = 0;\n\n    input                CLK;\n    output [DATA_SZ-1:0] read_0;\n    input  [DATA_SZ-1:0] write_0;\n    input                EN_write_0;\n    output [DATA_SZ-1:0] read_1;\n    input  [DATA_SZ-1:0] write_1;\n    input                EN_write_1;\n    output [DATA_SZ-1:0] read_2;\n    input  [DATA_SZ-1:0] write_2;\n    input                EN_write_2;\n    output [DATA_SZ-1:0] read_3;\n    input  [DATA_SZ-1:0] write_3;\n    input                EN_write_3;\n    output [DATA_SZ-1:0] read_4;\n    input  [DATA_SZ-1:0] write_4;\n    input                EN_write_4;\n    output [DATA_SZ-1:0] read_5;\n    input  [DATA_SZ-1:0] write_5;\n    input                EN_write_5;\n\n    reg    [DATA_SZ-1:0] r;\n    wire   [DATA_SZ-1:0] wire_0;\n    wire   [DATA_SZ-1:0] wire_1;\n    wire   [DATA_SZ-1:0] wire_2;\n    wire   [DATA_SZ-1:0] wire_3;\n    wire   [DATA_SZ-1:0] wire_4;\n    wire   [DATA_SZ-1:0] wire_5;\n    wire   [DATA_SZ-1:0] wire_6;\n\n    assign wire_0 = r;\n    assign wire_1 = EN_write_0 ? write_0 : wire_0;\n    assign wire_2 = EN_write_1 ? write_1 : wire_1;\n    assign wire_3 = EN_write_2 ? write_2 : wire_2;\n    assign wire_4 = EN_write_3 ? write_3 : wire_3;\n    assign wire_5 = EN_write_4 ? write_4 : wire_4;\n    assign wire_6 = EN_write_5 ? write_5 : wire_5;\n\n    assign read_0 = wire_0;\n    assign read_1 = wire_1;\n    assign read_2 = wire_2;\n    assign read_3 = wire_3;\n    assign read_4 = wire_4;\n    assign read_5 = wire_5;\n\n    always @(posedge CLK) begin\n        r <= wire_6;\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4_0cd01457", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4(\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [1:0] sel,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = in0;\n        2'b01: out = in1;\n        2'b10: out = in2;\n        2'b11: out = in3;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_multiply_e463755c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_multiply (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    input sel,\n    output [7:0] out\n);\n\n    wire [3:0] selected_input;\n    wire [7:0] product;\n\n    // 2-to-1 multiplexer\n    mux2to1 mux (\n        .in_0(in_0),\n        .in_1(in_1),\n        .sel(sel),\n        .out(selected_input)\n    );\n\n    // Arithmetic module for multiplication\n    multiplier mult (\n        .in_0(selected_input),\n        .in_1(selected_input),\n        .out(product)\n    );\n\n    assign out = product;\n\nendmodule\nmodule mux2to1 (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    input sel,\n    output [3:0] out\n);\n\n    assign out = sel ? in_1 : in_0;\n\nendmodule\nmodule multiplier (\n    input [3:0] in_0,\n    input [3:0] in_1,\n    output [7:0] out\n);\n\n    assign out = in_0 * in_1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "i2s_tx #_d94efff3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule i2s_tx #(\n    parameter WIDTH = 16\n)(\n    input clk,\n    input rst,\n    input [WIDTH-1:0] input_l_tdata,\n    input [WIDTH-1:0] input_r_tdata,\n    input input_tvalid,\n    output reg input_tready,\n    output reg sck,\n    output reg ws,\n    output reg sd\n);\n\n\nreg [WIDTH-1:0] l_data;\nreg [WIDTH-1:0] r_data;\nreg [3:0] bit_count;\nreg [1:0] channel_count;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        input_tready <= 1'b0;\n        sck <= 1'b0;\n        ws <= 1'b0;\n        sd <= 1'b0;\n        l_data <= {WIDTH{1'b0}};\n        r_data <= {WIDTH{1'b0}};\n        bit_count <= 4'd0;\n        channel_count <= 2'd0;\n    end else begin\n        if (input_tvalid && input_tready) begin\n            input_tready <= 1'b0;\n            l_data <= input_l_tdata;\n            r_data <= input_r_tdata;\n            bit_count <= 4'd0;\n            channel_count <= 2'd0;\n        end else if (sck && ws) begin\n            if (bit_count == WIDTH-1) begin\n                if (channel_count == 2'd0) begin\n                    sd <= l_data[WIDTH-1-bit_count];\n                    channel_count <= 2'd1;\n                end else begin\n                    sd <= r_data[WIDTH-1-bit_count];\n                    channel_count <= 2'd0;\n                end\n                bit_count <= 4'd0;\n            end else begin\n                bit_count <= bit_count + 1;\n                sd <= 1'b0;\n            end\n        end\n        if (!input_tvalid) begin\n            input_tready <= 1'b1;\n        end\n        sck <= ~sck;\n        ws <= (bit_count == WIDTH-1) ? ~ws : ws;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mm_09c8a385", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\n\n\n\n\n\nmodule mm(addr, mod, eff_addr);\n\tinput [31:0] addr; \n\toutput [7:0] mod; \n\toutput [31:0] eff_addr; \n\n\tassign mod = (addr[31:20] == 12'h000) ? 0 : \n\t\t     (addr[31:24] ==   8'h10) ? 1 : \n\t\t     (addr[31:20] == 12'hf00) ? 2 : \n\t\t     (addr[31:20] == 12'hf01) ? 3 : \n\t\t     (addr[31:20] == 12'hf02) ? 4 : \n\t\t     (addr[31:20] == 12'hf03) ? 5 : \n\t\t     (addr[31:20] == 12'hf04) ? 6 : \n\t\t     (addr[31:20] == 12'hf05) ? 7 : \n\t\t     (addr[31:20] == 12'hf06) ? 8 : \n\t\t     (addr[31:20] == 12'hf07) ? 10 : \n\t\t     (addr[31:20] == 12'hf08) ? 11 : \n\t\t     (addr[31:20] == 12'hf0a) ? 9 : \n\t\t     0;\n\tassign eff_addr = (mod == 8'h01) ? {8'h00,addr[23:0]} : {12'h000,addr[19:0]};\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_0ec67702", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_carry_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire [3:0] carry;\n  \n  full_adder fa0(A[0], B[0], Cin, S[0], carry[0]);\n  full_adder fa1(A[1], B[1], carry[0], S[1], carry[1]);\n  full_adder fa2(A[2], B[2], carry[1], S[2], carry[2]);\n  full_adder fa3(A[3], B[3], carry[2], S[3], Cout);\n\nendmodule\nmodule full_adder (\n  input A,\n  input B,\n  input Cin,\n  output S,\n  output Cout\n);\n\n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reset_test_gate_c3cec98f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule reset_test_gate (clk, reset, ctrl, din, sel, dout);\n   input wire clk;\n   input wire reset;\n   input wire [4:0] ctrl;\n   input wire [1:0] din;\n   input wire [0:0] sel;\n   output reg [31:0] dout;\n   reg [1:0] \t     i;\n   wire [0:0] \t     rval;\n   assign rval = {reset, 1'b0 };\n   always @(posedge clk)\n     begin\n        case (|(reset))\n          1'b 1:\n            begin\n               case (({(0)*(rval)})+(0))\n                 0:\n                   dout[31:0] <= 57005;\n                 1:\n                   dout[31:1] <= 57005;\n                 2:\n                   dout[31:2] <= 57005;\n                 3:\n                   dout[31:3] <= 57005;\n                 4:\n                   dout[31:4] <= 57005;\n                 5:\n                   dout[31:5] <= 57005;\n                 6:\n                   dout[31:6] <= 57005;\n                 7:\n                   dout[31:7] <= 57005;\n                 8:\n                   dout[31:8] <= 57005;\n                 9:\n                   dout[31:9] <= 57005;\n                 10:\n                   dout[31:10] <= 57005;\n                 11:\n                   dout[31:11] <= 57005;\n                 12:\n                   dout[31:12] <= 57005;\n                 13:\n                   dout[31:13] <= 57005;\n                 14:\n                   dout[31:14] <= 57005;\n                 15:\n                   dout[31:15] <= 57005;\n                 16:\n                   dout[31:16] <= 57005;\n                 17:\n                   dout[31:17] <= 57005;\n                 18:\n                   dout[31:18] <= 57005;\n                 19:\n                   dout[31:19] <= 57005;\n                 20:\n                   dout[31:20] <= 57005;\n                 21:\n                   dout[31:21] <= 57005;\n                 22:\n                   dout[31:22] <= 57005;\n                 23:\n                   dout[31:23] <= 57005;\n                 24:\n                   dout[31:24] <= 57005;\n                 25:\n                   dout[31:25] <= 57005;\n                 26:\n                   dout[31:26] <= 57005;\n                 27:\n                   dout[31:27] <= 57005;\n                 28:\n                   dout[31:28] <= 57005;\n                 29:\n                   dout[31:29] <= 57005;\n                 30:\n                   dout[31:30] <= 57005;\n                 31:\n                   dout[31:31] <= 57005;\n               endcase\n               i = 1;\n            end\n        endcase\n        case (({(ctrl)*(sel)})+(0))\n          0:\n            dout[31:0] <= din;\n          1:\n            dout[31:1] <= din;\n          2:\n            dout[31:2] <= din;\n          3:\n            dout[31:3] <= din;\n          4:\n            dout[31:4] <= din;\n          5:\n            dout[31:5] <= din;\n          6:\n            dout[31:6] <= din;\n          7:\n            dout[31:7] <= din;\n          8:\n            dout[31:8] <= din;\n          9:\n            dout[31:9] <= din;\n          10:\n            dout[31:10] <= din;\n          11:\n            dout[31:11] <= din;\n          12:\n            dout[31:12] <= din;\n          13:\n            dout[31:13] <= din;\n          14:\n            dout[31:14] <= din;\n          15:\n            dout[31:15] <= din;\n          16:\n            dout[31:16] <= din;\n          17:\n            dout[31:17] <= din;\n          18:\n            dout[31:18] <= din;\n          19:\n            dout[31:19] <= din;\n          20:\n            dout[31:20] <= din;\n          21:\n            dout[31:21] <= din;\n          22:\n            dout[31:22] <= din;\n          23:\n            dout[31:23] <= din;\n          24:\n            dout[31:24] <= din;\n          25:\n            dout[31:25] <= din;\n          26:\n            dout[31:26] <= din;\n          27:\n            dout[31:27] <= din;\n          28:\n            dout[31:28] <= din;\n          29:\n            dout[31:29] <= din;\n          30:\n            dout[31:30] <= din;\n          31:\n            dout[31:31] <= din;\n        endcase\n     end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spi_slave_simpler2_7c6b43cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule spi_slave_simpler2(clk, cs, mosi, miso, sck, done, din, dout);\n\tparameter bc=8;\tinput clk;\n\tinput cs;\tinput mosi;\n\toutput miso;\n\tinput sck;\n\toutput reg done;\n\tinput [bc-1:0] din;\n\toutput reg [bc-1:0] dout;\n\t\n\treg [bc-1:0] shift_reg;\n\treg prev_cs, prev_sck;\n\treg mosi_sample;\n\treg [7:0] shift_count;\n\t\n\tassign miso = shift_reg[bc-1];\n\n\talways @(posedge clk) begin\n\t\tif (~cs) begin\n\t\t\tif (prev_cs) begin\n\t\t\t\tdone <= 0;\n\t\t\t\tshift_reg[bc-1:0] <= 8'h23; shift_count <= 0;\n\t\t\tend else begin\n\t\t\t\tif (~prev_sck && sck) begin\n\t\t\t\t\tmosi_sample <= mosi;\n\t\t\t\t\tif (shift_count == bc-1) begin\n\t\t\t\t\t\tdout <= {shift_reg[bc-2:0], mosi};\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend \n\t\t\t\tif (prev_sck && ~sck) begin\n\t\t\t\t\tshift_reg[bc-1:0] <= {shift_reg[bc-2:0], mosi_sample};\n\t\t\t\t\tshift_count <= shift_count + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend else begin\n\t\t\tdone <= 1;\n\t\tend\n\t\tprev_cs <= cs;\n\t\tprev_sck <= sck;\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_4893a4ab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule barrel_shifter (\n  input [31:0] data_in,\n  input [4:0] shift_amount,\n  output reg [31:0] data_out,\n  output reg zero_flag,\n  input clk, // Added clock input port\n  input reset // Added reset port\n);\n\n  reg [31:0] reg_file [0:4];\n  reg [4:0] stage;\n  reg [31:0] shifted_data;\n  reg zero;\n\n  always @(posedge clk) begin // Connect the clock to the always block\n    if (reset) begin\n      stage <= 0;\n      zero_flag <= 0;\n    end else begin\n      if (stage == 5) begin\n        stage <= 0;\n        zero_flag <= zero;\n      end else begin\n        stage <= stage + 1;\n      end\n    end\n  end\n\n  always @(*) begin\n    case (stage)\n      0: begin\n        reg_file[0] = data_in;\n        shifted_data = data_in;\n      end\n      1: begin\n        reg_file[1] = shifted_data;\n        shifted_data = reg_file[0] << shift_amount;\n      end\n      2: begin\n        reg_file[2] = shifted_data;\n        shifted_data = reg_file[1] << shift_amount;\n      end\n      3: begin\n        reg_file[3] = shifted_data;\n        shifted_data = reg_file[2] << shift_amount;\n      end\n      4: begin\n        reg_file[4] = shifted_data;\n        shifted_data = reg_file[3] << shift_amount;\n      end\n      5: begin\n        data_out = shifted_data;\n        zero = (shifted_data == 0);\n      end\n    endcase\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pwm_generator_772a42dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pwm_generator(\n    input clk,\n    input rst,\n    input input_signal,\n    output reg pwm_signal\n);\n\nreg [6:0] duty_cycle;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        pwm_signal <= 1'b0;\n        duty_cycle <= 7'b0000000;\n    end else begin\n        if (duty_cycle == 7'b1111111) begin\n            pwm_signal <= 1'b1;\n        end else begin\n            pwm_signal <= 1'b1;\n            if (duty_cycle < 7'b1111111) begin\n                duty_cycle <= duty_cycle + 1;\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "a221o_2_ae175f17", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule a221o_2 (\n    input X,\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1,\n    output Y\n);\n\n    assign Y = (A1 & B1 & C1) | (A2 & B2 & C1);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_c70b0d6b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_reg (\n    input clk,\n    input rst,\n    input serial_in,\n    input parallel_in,\n    output serial_out\n);\n\nparameter WIDTH = 4;\n\nreg [WIDTH-1:0] reg_data;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        reg_data <= {WIDTH{1'b0}};\n    end else begin\n        if (parallel_in) begin\n            reg_data <= {serial_in, reg_data[WIDTH-2:0]};\n        end else begin\n            reg_data <= {reg_data[WIDTH-2:0], serial_in};\n        end\n    end\nend\n\nassign serial_out = reg_data[WIDTH-1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_c7dab1d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input clk,\n    input [3:0] DIN,\n    input LOAD,\n    input SHIFT,\n    input RESET,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (RESET) begin\n            Q <= 4'b0;\n        end else if (LOAD) begin\n            Q <= DIN;\n        end else if (SHIFT) begin\n            Q <= {Q[2:0], 1'b0};\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alt_ddrx_clock_and_reset #_6b484909", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule alt_ddrx_clock_and_reset #\n    ( parameter\n        CTL_RESET_SYNC_STAGES      = 4,\n        CTL_NUM_RESET_OUTPUT       = 1,\n        CTL_HALF_RESET_SYNC_STAGES = 4,\n        CTL_HALF_NUM_RESET_OUTPUT  = 1\n    )\n    (\n        ctl_clk,\n        ctl_reset_n,\n        ctl_half_clk,\n        ctl_half_clk_reset_n,\n        \n        resynced_ctl_reset_n,\n        resynced_ctl_half_clk_reset_n\n    );\n\ninput  ctl_clk;\ninput  ctl_reset_n;\ninput  ctl_half_clk;\ninput  ctl_half_clk_reset_n;\n\noutput [CTL_NUM_RESET_OUTPUT      - 1 : 0] resynced_ctl_reset_n;\noutput [CTL_HALF_NUM_RESET_OUTPUT - 1 : 0] resynced_ctl_half_clk_reset_n;\n\nalt_ddrx_reset_sync #(\n    .RESET_SYNC_STAGES (CTL_RESET_SYNC_STAGES),\n    .NUM_RESET_OUTPUT  (CTL_NUM_RESET_OUTPUT)\n) reset_sync_inst (\n\t.reset_n           (ctl_reset_n),\n\t.clk               (ctl_clk),\n\t.reset_n_sync      (resynced_ctl_reset_n)\n);\n\nalt_ddrx_reset_sync #(\n    .RESET_SYNC_STAGES (CTL_HALF_RESET_SYNC_STAGES),\n    .NUM_RESET_OUTPUT  (CTL_HALF_NUM_RESET_OUTPUT)\n) half_reset_sync_inst (\n\t.reset_n           (ctl_half_clk_reset_n),\n\t.clk               (ctl_half_clk),\n\t.reset_n_sync      (resynced_ctl_half_clk_reset_n)\n);\n\n\nendmodule\n\nmodule alt_ddrx_reset_sync #\n    ( parameter\n        RESET_SYNC_STAGES = 4,\n        NUM_RESET_OUTPUT  = 1\n    )\n    (\n    \treset_n,\n    \tclk,\n    \treset_n_sync\n    );\n\ninput\treset_n;\ninput\tclk;\noutput\t[NUM_RESET_OUTPUT-1:0] reset_n_sync;\n\n reg\t[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:0] reset_reg ;\n\ngenerate\ngenvar i;\n\tfor (i=0; i<RESET_SYNC_STAGES+NUM_RESET_OUTPUT-1; i=i+1)\n\tbegin: reset_stage\n\t\talways @(posedge clk or negedge reset_n)\n\t\tbegin\n\t\t\tif (~reset_n)\n\t\t\t\treset_reg[i] <= 1'b0;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif (i==0)\n\t\t\t\t\treset_reg[i] <= 1'b1;\n\t\t\t\telse if (i < RESET_SYNC_STAGES)\n\t\t\t\t\treset_reg[i] <= reset_reg[i-1];\n\t\t\t\telse\n\t\t\t\t\treset_reg[i] <= reset_reg[RESET_SYNC_STAGES-2];\n\t\t\t\t\n\t\t\tend\n\t\tend\n\tend\nendgenerate\n\n\tassign reset_n_sync = reset_reg[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:RESET_SYNC_STAGES-1];\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_03050243", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to8 (\n    input wire clk,\n    input wire [2:0] abc,\n    output reg [7:0] y\n);\n\n    always @(posedge clk) begin\n        y <= 8'b00000001 << abc;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hybrid_pwm_sd_30fbd0bb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule hybrid_pwm_sd\n(\n\tinput clk,\n\tinput n_reset,\n\tinput [15:0] din,\n\toutput dout\n);\n\nreg [4:0] pwmcounter;\nreg [4:0] pwmthreshold;\nreg [33:0] scaledin;\nreg [15:0] sigma;\nreg out;\n\nassign dout=out;\n\nalways @(posedge clk, negedge n_reset) begin\n\tif(!n_reset)\n\tbegin\n\t\tsigma<=16'b00000100_00000000;\n\t\tpwmthreshold<=5'b10000;\n        pwmcounter<=5'd0;\n        scaledin<=34'd0;\n\tend\n\telse\n\tbegin\n\t\tpwmcounter<=pwmcounter+1;\n\n\t\tif(pwmcounter==pwmthreshold)\n\t\t\tout<=1'b0;\n\n\t\tif(pwmcounter==5'b11111) begin\n\t\t\tscaledin<=33'd134217728 +({1'b0,din}*61440); sigma<=scaledin[31:16]+{5'b000000,sigma[10:0]};\tpwmthreshold<=sigma[15:11]; out<=1'b1;\n\t\tend\n\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_60333da6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to8 (\n    input [2:0] in,\n    output [7:0] out\n);\n\nassign out = 8'b00000001 << in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_fced0c2f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder (\n  input [7:0] A,\n  input [7:0] B,\n  output [7:0] sum\n);\n\n  assign sum = A + B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CHANNEL_ERROR_DETECT_f2f8a481", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule CHANNEL_ERROR_DETECT\n(\n    SOFT_ERROR,\n    HARD_ERROR,\n    LANE_UP,\n\n\n    USER_CLK,\n    POWER_DOWN,\n\n    CHANNEL_SOFT_ERROR,\n    CHANNEL_HARD_ERROR,\n\n\n    RESET_CHANNEL\n);\n\n`define DLY #1\n\n\ninput   [0:1]      SOFT_ERROR;\n    input              HARD_ERROR;\n    input              LANE_UP;\n\n\n    input              USER_CLK;\n    input              POWER_DOWN;\n\n    output             CHANNEL_SOFT_ERROR;\n    output             CHANNEL_HARD_ERROR;\n\n\n    output             RESET_CHANNEL;\n\n\nreg                CHANNEL_SOFT_ERROR;\n    reg                CHANNEL_HARD_ERROR;\n    reg                RESET_CHANNEL;\n\n\nreg     [0:1]      soft_error_r;\n    reg                hard_error_r;\n\n\nwire               channel_soft_error_c;\n    wire               channel_hard_error_c;\n    wire               reset_channel_c;\n\n\nalways @(posedge USER_CLK)\n    begin\n        soft_error_r    <=  `DLY    SOFT_ERROR;\n        hard_error_r    <=  `DLY    HARD_ERROR;\n    end\n\n\n\n    initial\n        CHANNEL_SOFT_ERROR = 1'b1;\n\n    assign channel_soft_error_c = soft_error_r[0] |\n                                  soft_error_r[1];\n\n    always @(posedge USER_CLK)\n        CHANNEL_SOFT_ERROR  <=  `DLY    channel_soft_error_c;\n\n\n\n    initial\n        CHANNEL_HARD_ERROR = 1'b1;\n\n    assign channel_hard_error_c = hard_error_r;\n\n    always @(posedge USER_CLK)\n        CHANNEL_HARD_ERROR  <=  `DLY    channel_hard_error_c;\n\n\n\n\n    initial\n        RESET_CHANNEL   =  1'b1;\n\n    assign reset_channel_c = !LANE_UP;\n\n    always @(posedge USER_CLK)\n        RESET_CHANNEL    <=  `DLY    reset_channel_c | POWER_DOWN;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "t2_ab6f7355", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule t2(\n    input [1:0] clks,\n    input c0,\n    input c1,\n    input check,\n    output reg o_check\n);\n\n    reg [1:0] state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n    \n    always @(posedge clks[0]) begin\n        case(state)\n            S0: begin\n                if(c0 && !c1)\n                    state <= S1;\n                else if(!c0 && c1)\n                    state <= S2;\n            end\n            S1: begin\n                if(c0 && !c1)\n                    state <= S3;\n                else if(!c0 && !c1)\n                    state <= S0;\n            end\n            S2: begin\n                if(!c0 && c1)\n                    state <= S3;\n                else if(c0 && !c1)\n                    state <= S0;\n            end\n            S3: begin\n                if(!c0 && !c1)\n                    state <= S2;\n                else if(c0 && c1)\n                    state <= S1;\n            end\n        endcase\n    end\n    \n    always @(posedge clks[1]) begin\n        if(state == S3 && check)\n            o_check <= 1;\n        else\n            o_check <= 0;\n    end\n    \n    initial state <= S0;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_adder_f3752e87", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_adder (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    input [15:0] A,\n    input [15:0] B,\n    output [15:0] SUM\n);\n\nwire [3:0] shift_reg;\nwire [15:0] signed_sum;\n\n// Shift register module\nshift_reg_mod shift_reg_inst (\n    .CLK(CLK),\n    .RST(RST),\n    .LD(LD),\n    .D(D),\n    .OUT(shift_reg)\n);\n\n// Signed magnitude adder module\nsigned_adder signed_adder_inst (\n    .A(A),\n    .B(B),\n    .SUM(signed_sum)\n);\n\n// Functional module that adds the output of shift register and signed magnitude adder\nassign SUM = shift_reg + signed_sum;\n\nendmodule\nmodule shift_reg_mod (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    output reg [3:0] OUT\n);\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        OUT <= 4'b0;\n    end else if (LD) begin\n        OUT <= D;\n    end else begin\n        OUT <= {OUT[2:0], 1'b0};\n    end\nend\n\nendmodule\nmodule signed_adder (\n    input [15:0] A,\n    input [15:0] B,\n    output reg [15:0] SUM\n);\n\nwire [15:0] abs_A;\nwire [15:0] abs_B;\nwire [15:0] signed_sum;\n\nassign abs_A = (A[15]) ? ~A + 1 : A;\nassign abs_B = (B[15]) ? ~B + 1 : B;\n\nassign signed_sum = (A[15] == B[15]) ? {A[15], abs_A + abs_B} :\n                    (abs_A > abs_B) ? {A[15], abs_A - abs_B} :\n                    {B[15], abs_B - abs_A};\n\nalways @(signed_sum) begin\n    SUM <= signed_sum;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "util_delay #_208a5ab3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule util_delay #(\n\n  parameter DATA_WIDTH = 1,\n  parameter DELAY_CYCLES = 1) (\n\n  input                             clk,\n  input                             reset,\n  input                             din,\n  output  [DATA_WIDTH-1:0]          dout);\n\n  reg     [DATA_WIDTH-1:0]          dbuf[0:(DELAY_CYCLES-1)];\n\n  always @(posedge clk) begin\n    if (reset) begin\n      dbuf[0] <= 0;\n    end else begin\n      dbuf[0] <= din;\n    end\n  end\n\n  generate\n  genvar i;\n    for (i = 1; i < DELAY_CYCLES; i=i+1) begin:register_pipe\n      always @(posedge clk) begin\n        if (reset) begin\n          dbuf[i] <= 0;\n        end else begin\n          dbuf[i] <= dbuf[i-1];\n        end\n      end\n    end\n  endgenerate\n\n  assign dout = dbuf[(DELAY_CYCLES-1)];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_bd90aca0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_sub (\n    input [3:0] a,\n    input [3:0] b,\n    input sub, // 0 for addition, 1 for subtraction\n    input cin, // carry in\n    output reg cout, // carry out\n    output reg overflow, // overflow flag\n    output reg [3:0] sum // sum result\n);\n\nreg [3:0] a_reg, b_reg; // Register to hold input values\nreg sub_reg, cin_reg; // Register to hold sub and cin signals\n\n// Wires to connect adders\nwire [4:0] add_out;\nwire [3:0] sub_out;\n\n// Instantiate adders\nassign add_out = a_reg + b_reg + cin_reg; // Adder for addition\nassign sub_out = a_reg - b_reg - cin_reg; // Subtractor for subtraction\n\n// Always block to update registers\nalways @(*) begin\n    a_reg <= a; // Register input a\n    b_reg <= b; // Register input b\n    sub_reg <= sub; // Register sub signal\n    cin_reg <= cin; // Register cin signal\nend\n\n// Always block to calculate sum and overflow\nalways @(*) begin\n    if (sub_reg) begin // If subtraction is selected\n        sum <= sub_out; // Store subtraction result in sum register\n    end else begin // If addition is selected\n        sum <= add_out; // Store addition result in sum register\n    end\n\n    // Check for overflow\n    if (sum > 4'b1111 || sum < 4'b0000) begin\n        overflow <= 1; // Set overflow flag\n    end else begin\n        overflow <= 0; // Clear overflow flag\n    end\nend\n\n// Always block to calculate carry out\nalways @(*) begin\n    // Check for carry out\n    if (sum > 4'b1111 || sum < 4'b0000) begin\n        cout <= 1; // Set carry out\n    end else begin\n        cout <= add_out[4]; // Carry out is the MSB of addition result\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__348b440c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output [3:0] q,\n    output reg [2:0] count_ones\n);\n\n    reg [3:0] counter;\n    \n    // Binary counter\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n    \n    // Count the number of '1's in the binary representation of the count value\n    always @(counter) begin\n        count_ones <= {counter[0], counter[1], counter[2], counter[3]} \n                        - ((counter[0] & counter[1]) | (counter[0] & counter[2]) | (counter[0] & counter[3]) | (counter[1] & counter[2]) | (counter[1] & counter[3]) | (counter[2] & counter[3]));\n    end\n    \n    assign q = counter;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "win_blk_mem_gen_prim_width_4ce0f71c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule win_blk_mem_gen_prim_width\n   (output reg [0:0] douta,\n    input clka,\n    input [13:0] addra,\n    input [0:0] dina,\n    input [0:0] wea);\n\n  reg [0:0] mem [0:16383]; // 14-bit addressable memory block\n\n  always @(posedge clka) begin\n    if (wea[0]) begin // write operation\n      mem[addra] <= dina;\n    end else begin // read operation\n      douta <= mem[addra];\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "eproto_tx_ce6f9714", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule eproto_tx (\n   emtx_rd_wait, emtx_wr_wait, emtx_ack, txframe_p, txdata_p,\n   reset, emtx_access, emtx_write, emtx_datamode, emtx_ctrlmode,\n   emtx_dstaddr, emtx_srcaddr, emtx_data, txlclk_p, tx_rd_wait,\n   tx_wr_wait\n   );\n\n   input         reset;\n\n   input         emtx_access;\n   input         emtx_write;\n   input [1:0]   emtx_datamode;\n   input [3:0]   emtx_ctrlmode;\n   input [31:0]  emtx_dstaddr;\n   input [31:0]  emtx_srcaddr;\n   input [31:0]  emtx_data;\n   output        emtx_rd_wait;\n   output        emtx_wr_wait;\n   output        emtx_ack;\n   \n   input         txlclk_p; output [7:0]  txframe_p;\n   output [63:0] txdata_p;\n   input         tx_rd_wait;  input         tx_wr_wait;  reg           emtx_ack;  reg [7:0]     txframe_p;\n   reg [63:0]    txdata_p;\n   \n   always @( posedge txlclk_p or posedge reset ) begin\n\n      if( reset ) begin\n\n         emtx_ack    <= 1'b0;\n         txframe_p   <= 'd0;\n         txdata_p    <= 'd0;\n\n      end else begin\n\n         if( emtx_access & ~emtx_ack ) begin\n\n            emtx_ack  <= 1'b1;\n            txframe_p <= 8'h3F;\n            txdata_p  <=\n               { 8'd0,  8'd0,\n                 ~emtx_write, 7'd0,   emtx_ctrlmode, emtx_dstaddr[31:28], emtx_dstaddr[27:4],  emtx_dstaddr[3:0], emtx_datamode, emtx_write, emtx_access };\n         end else if( emtx_ack ) begin emtx_ack  <= 1'b0;\n            txframe_p <= 8'hFF;\n            txdata_p  <= { emtx_data, emtx_srcaddr };\n            \n         end else begin\n\n            emtx_ack    <= 1'b0;\n            txframe_p <= 8'h00;\n            txdata_p  <= 64'd0;\n\n         end\n\n      end end reg     rd_wait_sync;\n   reg     wr_wait_sync;\n   reg     emtx_rd_wait;\n   reg     emtx_wr_wait;\n   \n   always @( posedge txlclk_p ) begin\n      rd_wait_sync <= tx_rd_wait;\n      emtx_rd_wait <= rd_wait_sync;\n      wr_wait_sync <= tx_wr_wait;\n      emtx_wr_wait <= wr_wait_sync;\n   end\n            \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "byte_reverse_pipeline_0ddf171b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule byte_reverse_pipeline(\n    input [31:0] in,\n    output [31:0] out,\n    input clk,\n    input reset\n);\n\nreg [7:0] shift_reg [3:0];\nreg [1:0] stage;\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        stage <= 0;\n        shift_reg[0] <= 0;\n        shift_reg[1] <= 0;\n        shift_reg[2] <= 0;\n        shift_reg[3] <= 0;\n    end else begin\n        case(stage)\n            0: begin\n                shift_reg[0] <= in[7:0];\n                shift_reg[1] <= in[15:8];\n                shift_reg[2] <= in[23:16];\n                shift_reg[3] <= in[31:24];\n                stage <= 1;\n            end\n            1: begin\n                shift_reg[0] <= shift_reg[2];\n                shift_reg[1] <= shift_reg[3];\n                shift_reg[2] <= shift_reg[0];\n                shift_reg[3] <= shift_reg[1];\n                stage <= 2;\n            end\n            default: begin\n                stage <= 0;\n                shift_reg[0] <= 0;\n                shift_reg[1] <= 0;\n                shift_reg[2] <= 0;\n                shift_reg[3] <= 0;\n            end\n        endcase\n    end\nend\n\nassign out = {shift_reg[3], shift_reg[2], shift_reg[1], shift_reg[0]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_to_sixteen_decoder_675fc49e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_to_sixteen_decoder (\n    input [1:0] sel,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            2'b00: out = 16'b0000000000000001;\n            2'b01: out = 16'b0000000000000010;\n            2'b10: out = 16'b0000000000000100;\n            2'b11: out = 16'b0000000000001000;\n            default: out = 16'b0000000000000000;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_6df1de6a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux4to1 (\n    //# {{data|Data Signals}}\n    input  A,\n    input  B,\n    input  C,\n    input  D,\n    output reg X, // Changed from wire to reg\n\n    //# {{control|Control Signals}}\n    input  S0,\n    input  S1\n);\n\n    always @(*) begin\n        if (S1 == 0 && S0 == 0) begin\n            X = A;\n        end else if (S1 == 0 && S0 == 1) begin\n            X = B;\n        end else if (S1 == 1 && S0 == 0) begin\n            X = C;\n        end else if (S1 == 1 && S0 == 1) begin\n            X = D;\n        end\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_complement_22f04d3a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_complement\n  (output reg [3:0] Y, input [3:0] A, input S);\n  \n  always @(*) begin\n    if(S == 0) begin\n      Y = ~A + 4'b1;\n    end\n    else begin\n      Y = ~A;\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_code_4ae321de", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gray_code (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @ (in) begin\n        out[3] = in[3];\n        out[2] = in[3] ^ in[2];\n        out[1] = in[2] ^ in[1];\n        out[0] = in[1] ^ in[0];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "scrambler #_2811234c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule scrambler #(\n    parameter DATA_BYTE_WIDTH = 4\n)\n(\n    input   wire                                clk,\n    input   wire                                rst,\n\n    input   wire                                val_in,\n    input   wire    [DATA_BYTE_WIDTH*8 - 1:0]   data_in,\n    output  wire    [DATA_BYTE_WIDTH*8 - 1:0]   data_out\n);\n\nreg [15:0]  now;\nreg [31:0]  next;\n\nalways @ (posedge clk)\n    now <= rst ? 16'hf0f6 : val_in ? next[31:16] : now;\n\nassign  data_out = val_in ? data_in ^ next : data_in;\n\nalways @ (*)\n\n    begin\n        next[31] = now[12] ^ now[10] ^ now[7] ^ now[3] ^ now[1] ^ now[0];\n        next[30] = now[15] ^ now[14] ^ now[12] ^ now[11] ^ now[9] ^ now[6] ^ now[3] ^ now[2] ^ now[0];\n        next[29] = now[15] ^ now[13] ^ now[12] ^ now[11] ^ now[10] ^ now[8] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[28] = now[14] ^ now[12] ^ now[11] ^ now[10] ^ now[9] ^ now[7] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[27] = now[15] ^ now[14] ^ now[13] ^ now[12] ^ now[11] ^ now[10] ^ now[9] ^ now[8] ^ now[6] ^ now[1] ^ now[0];\n        next[26] = now[15] ^ now[13] ^ now[11] ^ now[10] ^ now[9] ^ now[8] ^ now[7] ^ now[5] ^ now[3] ^ now[0];\n        next[25] = now[15] ^ now[10] ^ now[9] ^ now[8] ^ now[7] ^ now[6] ^ now[4] ^ now[3] ^ now[2];\n        next[24] = now[14] ^ now[9] ^ now[8] ^ now[7] ^ now[6] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[23] = now[13] ^ now[8] ^ now[7] ^ now[6] ^ now[5] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[22] = now[15] ^ now[14] ^ now[7] ^ now[6] ^ now[5] ^ now[4] ^ now[1] ^ now[0];\n        next[21] = now[15] ^ now[13] ^ now[12] ^ now[6] ^ now[5] ^ now[4] ^ now[0];\n        next[20] = now[15] ^ now[11] ^ now[5] ^ now[4];\n        next[19] = now[14] ^ now[10] ^ now[4] ^ now[3];\n        next[18] = now[13] ^ now[9] ^ now[3] ^ now[2];\n        next[17] = now[12] ^ now[8] ^ now[2] ^ now[1];\n        next[16] = now[11] ^ now[7] ^ now[1] ^ now[0];\n\n        next[15] = now[15] ^ now[14] ^ now[12] ^ now[10] ^ now[6] ^ now[3] ^ now[0];\n        next[14] = now[15] ^ now[13] ^ now[12] ^ now[11] ^ now[9] ^ now[5] ^ now[3] ^ now[2];\n        next[13] = now[14] ^ now[12] ^ now[11] ^ now[10] ^ now[8] ^ now[4] ^ now[2] ^ now[1];\n        next[12] = now[13] ^ now[11] ^ now[10] ^ now[9] ^ now[7] ^ now[3] ^ now[1] ^ now[0];\n        next[11] = now[15] ^ now[14] ^ now[10] ^ now[9] ^ now[8] ^ now[6] ^ now[3] ^ now[2] ^ now[0];\n        next[10] = now[15] ^ now[13] ^ now[12] ^ now[9] ^ now[8] ^ now[7] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[9] = now[14] ^ now[12] ^ now[11] ^ now[8] ^ now[7] ^ now[6] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[8] = now[15] ^ now[14] ^ now[13] ^ now[12] ^ now[11] ^ now[10] ^ now[7] ^ now[6] ^ now[5] ^ now[1] ^ now[0];\n        next[7] = now[15] ^ now[13] ^ now[11] ^ now[10] ^ now[9] ^ now[6] ^ now[5] ^ now[4] ^ now[3] ^ now[0];\n        next[6] = now[15] ^ now[10] ^ now[9] ^ now[8] ^ now[5] ^ now[4] ^ now[2];\n        next[5] = now[14] ^ now[9] ^ now[8] ^ now[7] ^ now[4] ^ now[3] ^ now[1];\n        next[4] = now[13] ^ now[8] ^ now[7] ^ now[6] ^ now[3] ^ now[2] ^ now[0];\n        next[3] = now[15] ^ now[14] ^ now[7] ^ now[6] ^ now[5] ^ now[3] ^ now[2] ^ now[1];\n        next[2] = now[14] ^ now[13] ^ now[6] ^ now[5] ^ now[4] ^ now[2] ^ now[1] ^ now[0];\n        next[1] = now[15] ^ now[14] ^ now[13] ^ now[5] ^ now[4] ^ now[1] ^ now[0];\n        next[0] = now[15] ^ now[13] ^ now[4] ^ now[0];\n    end\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shifter_d36f6b27", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shifter(\ninput [31:0] A, input [31:0] B, input aluc1,input aluc0,output  [31:0] Result,output Zero,\noutput Carry,\noutput Negative,\noutput Overflow\n);\nreg [31:0] Result_temp;\nreg Zero_temp;\nreg Carry_temp;\nreg Nagative_temp;\nreg Overflow_temp;\nreg [4:0] shift_amount;\n\n\nassign Zero     = Zero_temp;\nassign Carry    = Carry_temp;\nassign Negative = Nagative_temp;\nassign Overflow = Overflow_temp;\nassign Result   = Result_temp;\n\nalways @(*) begin\n    if( aluc1 == 0 && aluc0 == 0 )begin shift_amount = A[4:0];\n        Result_temp = $signed(B)>>>shift_amount;\n        if( Result_temp == 0 ) \n            Zero_temp = 1;\n        else \n            Zero_temp = 0;\n        Nagative_temp = B[31];\n        if ( shift_amount == 0) \n            Carry_temp = 0;\n        else \n            Carry_temp = B[shift_amount -1];\n        Overflow_temp = 0;\n        Nagative_temp=Result_temp[31];\n    end\n    else if( aluc1 == 0 && aluc0 == 1 )begin shift_amount = A[4:0];\n        Result_temp = B >> shift_amount;\n        if(Result_temp==0) \n            Zero_temp=1;\n        else \n            Zero_temp=0;\n        if(shift_amount==0)\n            Carry_temp=0;\n        else\n        Carry_temp=B[shift_amount-1];\n        Overflow_temp=0;\n        Nagative_temp = Result_temp[31];\n    end\n    else if( aluc1 == 1 && aluc0 == 0 )begin  shift_amount = A[4:0];\n        Result_temp = B<<shift_amount;\n        if ( Result_temp == 0)\n            Zero_temp = 1;\n        else \n            Zero_temp = 0;\n        if ( shift_amount ==0)\n            Carry_temp = 0;\n        else \n            Carry_temp=B[32-shift_amount]; \n        Overflow_temp = 0;  \n        Nagative_temp = Result_temp[31];\n    end\n    else if( aluc1 == 1 && aluc0 == 1 )begin shift_amount = A[4:0];\n        Result_temp=B<<shift_amount;\n        if (Result_temp == 0)\n            Zero_temp = 1;\n        else Zero_temp = 0;\n        if (shift_amount ==0)\n          Carry_temp = 0;\n        else \n        Carry_temp=B[32-shift_amount];\n        Overflow_temp = 0;\n        Nagative_temp = Result_temp[31];\n    end\nend\nendmodule   "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_gray_comparator_87c43577", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_gray_comparator(\n    input [3:0] binary_in, // 4-bit binary input for binary-to-Gray code converter module\n    input [3:0] comp_in_1, // 4-bit input 1 for comparator module\n    input [3:0] comp_in_2, // 4-bit input 2 for comparator module\n    output [3:0] gray_out, // 4-bit Gray code output from binary-to-Gray code converter module\n    output comp_out, // 1-bit output from comparator module\n    output [3:0] shift_out // 4-bit output from functional module\n);\n\nassign gray_out[0] = binary_in[0];\nassign gray_out[1] = binary_in[0] ^ binary_in[1];\nassign gray_out[2] = binary_in[1] ^ binary_in[2];\nassign gray_out[3] = binary_in[2] ^ binary_in[3];\n\nassign comp_out = (comp_in_1[3] == comp_in_2[3]) ? \n                    ((comp_in_1[2] == comp_in_2[2]) ? \n                        ((comp_in_1[1] == comp_in_2[1]) ? \n                            (comp_in_1[0] >= comp_in_2[0]) : \n                        (comp_in_1[1] > comp_in_2[1])) : \n                    (comp_in_1[2] > comp_in_2[2])) : \n                (comp_in_1[3] > comp_in_2[3]);\n\nassign shift_out = (comp_out == 1) ? (gray_out << 1) : (gray_out >> 1);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_418a77c6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @* begin\n    if (in[7]) pos = 3'b111; // MSB is high\n    else if (in[6]) pos = 3'b110; // Bit 6 is high\n    else if (in[5]) pos = 3'b101; // Bit 5 is high\n    else if (in[4]) pos = 3'b100; // Bit 4 is high\n    else if (in[3]) pos = 3'b011; // Bit 3 is high\n    else if (in[2]) pos = 3'b010; // Bit 2 is high\n    else if (in[1]) pos = 3'b001; // Bit 1 is high\n    else pos = 3'b000; // No bits are high\nend\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    output [2:0] pos\n);\n\nwire [2:0] pe_pos;\n\npriority_encoder pe(\n    .in(in),\n    .pos(pe_pos)\n);\n\nassign pos = pe_pos;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "edge_detect_mux_cc074530", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule edge_detect_mux (\n    input clk,\n    input rst_n,\n    input a, b, c,\n    input select,\n    output reg rise,\n    output reg fall,\n    output reg w,\n    output reg x,\n    output reg y,\n    output reg z\n);\n\n    // State definitions\n    localparam [1:0]\n        IDLE = 2'b00,\n        RISING_EDGE = 2'b01,\n        FALLING_EDGE = 2'b10,\n        MUX_SELECT = 2'b11;\n\n    // State register and next state logic\n    reg [1:0] state, next_state;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output register and combinational logic\n    reg [2:0] mux_out;\n    always @(*) begin\n        case (select)\n            0: mux_out = {a, 2'b00};\n            1: mux_out = {b, 2'b00};\n            2: mux_out = {c, 2'b00};\n            default: mux_out = 3'b000; // Added a default case to break the logic loop\n        endcase\n        w = select;\n        x = mux_out[2];\n        y = mux_out[1];\n        z = mux_out[0];\n    end\n\n    // State machine\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                rise <= 1'b0;\n                fall <= 1'b0;\n                next_state = RISING_EDGE;\n            end\n            RISING_EDGE: begin\n                rise <= a; // Fixed the edge detection logic for the rising edge\n                fall <= 1'b0;\n                next_state = FALLING_EDGE;\n            end\n            FALLING_EDGE: begin\n                rise <= 1'b0;\n                fall <= ~a; // Fixed the edge detection logic for the falling edge\n                next_state = MUX_SELECT;\n            end\n            MUX_SELECT: begin\n                rise <= 1'b0;\n                fall <= 1'b0;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axis_rate_limit_64 #_3e94238c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule axis_rate_limit_64 #\n(\n    parameter DATA_WIDTH = 64,\n    parameter KEEP_WIDTH = (DATA_WIDTH/8)\n)\n(\n    input  wire                   clk,\n    input  wire                   rst,\n\n    \n    input  wire [DATA_WIDTH-1:0]  input_axis_tdata,\n    input  wire [KEEP_WIDTH-1:0]  input_axis_tkeep,\n    input  wire                   input_axis_tvalid,\n    output wire                   input_axis_tready,\n    input  wire                   input_axis_tlast,\n    input  wire                   input_axis_tuser,\n\n    \n    output wire [DATA_WIDTH-1:0]  output_axis_tdata,\n    output wire [KEEP_WIDTH-1:0]  output_axis_tkeep,\n    output wire                   output_axis_tvalid,\n    input  wire                   output_axis_tready,\n    output wire                   output_axis_tlast,\n    output wire                   output_axis_tuser,\n\n    \n    input  wire [7:0]             rate_num,\n    input  wire [7:0]             rate_denom,\n    input  wire                   rate_by_frame\n);\n\nreg [DATA_WIDTH-1:0] output_axis_tdata_int;\nreg [KEEP_WIDTH-1:0] output_axis_tkeep_int;\nreg                  output_axis_tvalid_int;\nreg                  output_axis_tready_int = 0;\nreg                  output_axis_tlast_int;\nreg                  output_axis_tuser_int;\nwire                 output_axis_tready_int_early;\n\nreg [23:0] acc_reg = 0, acc_next;\nreg pause;\nreg frame_reg = 0, frame_next;\n\nreg input_axis_tready_reg = 0, input_axis_tready_next;\nassign input_axis_tready = input_axis_tready_reg;\n\nalways @* begin\n    acc_next = acc_reg;\n    pause = 0;\n    frame_next = frame_reg & ~input_axis_tlast;\n\n    if (acc_reg >= rate_num) begin\n        acc_next = acc_reg - rate_num;\n    end\n\n    if (input_axis_tready & input_axis_tvalid) begin\n        frame_next = ~input_axis_tlast;\n        acc_next = acc_reg + (rate_denom - rate_num);\n    end\n\n    if (acc_next >= rate_num) begin\n        if (rate_by_frame) begin\n            pause = ~frame_next;\n        end else begin\n            pause = 1;\n        end\n    end\n\n    input_axis_tready_next = output_axis_tready_int_early & ~pause;\n\n    output_axis_tdata_int = input_axis_tdata;\n    output_axis_tkeep_int = input_axis_tkeep;\n    output_axis_tvalid_int = input_axis_tvalid & input_axis_tready;\n    output_axis_tlast_int = input_axis_tlast;\n    output_axis_tuser_int = input_axis_tuser;\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        acc_reg <= 0;\n        frame_reg <= 0;\n        input_axis_tready_reg <= 0;\n    end else begin\n        acc_reg <= acc_next;\n        frame_reg <= frame_next;\n        input_axis_tready_reg <= input_axis_tready_next;\n    end\nend\n\nreg [DATA_WIDTH-1:0] output_axis_tdata_reg = 0;\nreg [KEEP_WIDTH-1:0] output_axis_tkeep_reg = 0;\nreg                  output_axis_tvalid_reg = 0;\nreg                  output_axis_tlast_reg = 0;\nreg                  output_axis_tuser_reg = 0;\n\nreg [DATA_WIDTH-1:0] temp_axis_tdata_reg = 0;\nreg [KEEP_WIDTH-1:0] temp_axis_tkeep_reg = 0;\nreg                  temp_axis_tvalid_reg = 0;\nreg                  temp_axis_tlast_reg = 0;\nreg                  temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tkeep_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tkeep_reg <= output_axis_tkeep_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tkeep_reg <= output_axis_tkeep_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tkeep_reg <= temp_axis_tkeep_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tkeep_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "_4bit_binary_multiplier_c871007a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule _4bit_binary_multiplier(\n\n    input start, clk,\n    input [3:0] multiplier_address, multiplicand_address,\n    output [7:0] p,\n    output reg done\n    \n    );\n\n    reg [3:0] multiplier, multiplicand;\n    reg [7:0] product;\n    reg [3:0] counter;\n    reg [3:0] adder_input;\n    reg [7:0] adder_output;\n    reg [3:0] shift_input;\n    reg [3:0] shift_output;\n    reg [3:0] shift_reg [0:3];\n    reg [7:0] shift_reg_output;\n    \n    integer i;\n    \n    always @(posedge clk) begin\n        if (start) begin\n            multiplier <= multiplier_address;\n            multiplicand <= multiplicand_address;\n            counter <= 4'b0000;\n            product <= 8'b00000000;\n            done <= 0;\n        end else begin\n            if (counter == 4'b0000) begin\n                adder_input <= 4'b0000;\n                shift_input <= multiplicand;\n            end else begin\n                adder_input <= {shift_output, multiplier[counter-1]};\n                shift_input <= shift_reg_output;\n            end\n            adder_output <= adder_input + shift_input;\n            shift_output <= shift_reg[3];\n            for (i = 3; i > 0; i = i - 1) begin\n                shift_reg[i] <= shift_reg[i-1];\n            end\n            shift_reg[0] <= adder_output[3:0];\n            shift_reg_output <= {shift_reg[3], shift_reg[2], shift_reg[1], shift_reg[0]};\n            product <= {shift_reg_output, adder_output[7:4]};\n            counter <= counter + 1;\n            if (counter == 4'b0100) begin\n                done <= 1;\n            end\n        end\n    end\n    \n    assign p = product;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_calculator_6c317151", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule simple_calculator(\n    input [1:0] operation,\n    input signed [63:0] operands,\n    output signed [31:0] result\n);\n\nreg signed [31:0] op1;\nreg signed [31:0] op2;\nreg signed [31:0] res;\n\nalways @(*) begin\n    op1 = operands[31:0];\n    op2 = operands[63:32];\n    case(operation)\n        2'b00: res = op1 + op2; // Addition\n        2'b01: res = op1 - op2; // Subtraction\n        2'b10: res = op1 * op2; // Multiplication\n        2'b11: res = op1 / op2; // Division\n    endcase\nend\n\nassign result = res;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_en_clk_gate_f4bfa6c9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule d_ff_en_clk_gate (\n  input CLK,\n  input EN,\n  input TE,\n  input [31:0] DATA_IN,\n  output reg DATA_OUT\n);\n\n  reg d_ff_en;\n  wire ENCLK;\n\nendmodule\n\nmodule TLATNTSCAX2TS (\n    input E,\n    input SE,\n    input CK,\n    output ECK\n);\n\n    assign ECK = E & SE & CK;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "scp_sender_7a99c464", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule scp_sender(\n    input CHANNEL_UP,\n    input USER_CLK,\n    output reg rst_r,\n    output reg start_r,\n    output reg run_r\n);\n\n    //Control state machine state registers\n    always @(posedge USER_CLK)\n        if(!CHANNEL_UP) \n        begin\n            rst_r       <=  1'b1;\n            start_r     <=  1'b0;\n            run_r       <=  1'b0;\n        end\n        else\n        begin\n            rst_r       <=  1'b0;\n            start_r     <=  next_start_c;\n            run_r       <=  next_run_c;\n        end\n\n\n    //Nextstate logic\n    \n    wire next_start_c, next_run_c;\n    // After reset, send the SCP character to open the infinite \n    // frame \n    assign  next_start_c    =   rst_r;\n\n    \n    // After the start state, go to normal operation \n    assign  next_run_c      =   start_r ||\n                                run_r;\n      \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PWM32_05349def", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PWM32 (\n    input wire clk,\n    input wire rst,\n    input wire [31:0] PRE,\n    input wire [31:0] TMRCMP1,\n    input wire [31:0] TMRCMP2,\n    input wire \t\t\t\tTMREN,\n    output reg pwm\n);\n\n\treg [31:0]\tTMR;\n\treg [31:0] \tclkdiv;\n\twire \t\ttimer_clk = (clkdiv==PRE) ;\n\twire \t\ttmrov = (TMR == TMRCMP1);\n\twire \t\tpwmov = (TMR == TMRCMP2);\n\n\t// Prescalar\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tclkdiv <= 32'd0;\n\t\telse if(timer_clk)\n\t\t\tclkdiv <= 32'd0;\n\t\telse if(TMREN)\n\t\t\tclkdiv <= clkdiv + 32'd1;\n\tend\n\n\t// Timer\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tTMR <= 32'd0;\n\t\telse if(tmrov)\n\t\t\tTMR <= 32'd0;\n\t\telse if(timer_clk)\n\t\t\tTMR <= TMR + 32'd1;\n\tend\n\n\t// PWM Output\n\talways @(posedge clk or posedge rst)\n\tbegin\n\t\tif(rst)\n\t\t\tpwm <= 1'd0;\n\t\telse if(pwmov)\n\t\t\tpwm <= 1'd1;\n\t\telse if (tmrov)\n\t\t\tpwm <= 1'd0;\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_tree_top_e6e9123d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define ADDER_WIDTH 022\n`define DUMMY_WIDTH 128\n\n`define 2_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PWMModule_3f581661", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PWMModule (\n    input clock,\n    input reset,\n    input [7:0] dutyCycle,\n    output reg pwm,\n    output reg done\n);\n\n    reg [23:0] counter = 0;\n    reg [7:0] threshold = 0;\n    reg [7:0] duty = 0;\n\n    always @(posedge clock) begin\n        if (reset) begin\n            counter <= 0;\n            threshold <= 0;\n            duty <= 0;\n            pwm <= 0;\n            done <= 0;\n        end else begin\n            // calculate threshold based on duty cycle\n            duty <= dutyCycle;\n            threshold <= (256 * (duty / 100)) - 1;\n            \n            // increment counter and reset at end of cycle\n            if (counter == 999) begin\n                counter <= 0;\n                done <= 1;\n            end else begin\n                counter <= counter + 1;\n                done <= 0;\n            end\n            \n            // set pwm value based on counter and threshold\n            if (counter < threshold) begin\n                pwm <= 1;\n            end else begin\n                pwm <= 0;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_16to1_d21c5cd1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_16to1 (\n  input [15:0] in0,\n  input [15:0] in1,\n  input [15:0] in2,\n  input [15:0] in3,\n  input [15:0] in4,\n  input [15:0] in5,\n  input [15:0] in6,\n  input [15:0] in7,\n  input [15:0] in8,\n  input [15:0] in9,\n  input [15:0] in10,\n  input [15:0] in11,\n  input [15:0] in12,\n  input [15:0] in13,\n  input [15:0] in14,\n  input [15:0] in15,\n  input [4:0] sel,\n  output reg [31:0] out\n);\n\n  always @(*) begin\n    case (sel)\n      5'b00000: out = in0;\n      5'b00001: out = in1;\n      5'b00010: out = in2;\n      5'b00011: out = in3;\n      5'b00100: out = in4;\n      5'b00101: out = in5;\n      5'b00110: out = in6;\n      5'b00111: out = in7;\n      5'b01000: out = in8;\n      5'b01001: out = in9;\n      5'b01010: out = in10;\n      5'b01011: out = in11;\n      5'b01100: out = in12;\n      5'b01101: out = in13;\n      5'b01110: out = in14;\n      5'b01111: out = in15;\n      default: out = 32'b0;\n    endcase\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_divider_cfd723e7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clk_divider(\n    input inclk,\n    input ena,\n    output enaout,\n    output reg outclk\n);\n\nparameter clock_type = \"auto\";\nparameter ena_register_mode = \"always enabled\";\nparameter lpm_type = \"cyclone10gx_clkena\";\nparameter ena_register_power_up = \"high\";\nparameter disable_mode = \"low\";\nparameter test_syn = \"high\";\n\nreg ena_reg;\n\nalways @ (posedge inclk) begin\n    if (ena_register_mode == \"always enabled\") begin\n        ena_reg <= 1'b1;\n    end else if (ena_register_mode == \"synchronous\") begin\n        ena_reg <= ena;\n    end else if (ena_register_mode == \"asynchronous\") begin\n        ena_reg <= ena_reg | ena;\n    end\nend\n\nassign enaout = ena_reg;\n\nalways @ (posedge inclk) begin\n    if (ena == 1'b1) begin\n        outclk <= ~outclk;\n    end else begin\n        outclk <= 1'b0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_gen #_aa71cf0d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule clk_gen #(\n    parameter res    = 20,    parameter phase  =  1     )(\n    input      clk_i, input      rst_i,\n    output     clk_o  );\n\n  reg [res-1:0] cnt;\n\n  assign clk_o = cnt[res-1];\n\n  always @(posedge clk_i)\n    cnt <= rst_i ? {res{1'b0}} : (cnt + phase);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_vending_machine_2c16ed3d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fsm_vending_machine (\n  input clk,\n  input reset,\n  input coin_inserted,\n  input [1:0] item_selected,\n  input item_dispensed,\n  output reg dispense_item,\n  output reg return_coin\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter ITEM_SELECTED = 2'b01;\n  parameter ITEM_DISPENSED = 2'b10;\n\n  // Define the current state\n  reg [1:0] state;\n\n  // Define the next state\n  reg [1:0] next_state;\n\n  // Define the state transition logic\n  always @ (posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  // Define the state output logic\n  always @ (state, coin_inserted, item_selected, item_dispensed) begin\n    case (state)\n      IDLE: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        if (coin_inserted && item_selected != 2'b00) begin\n          next_state <= ITEM_SELECTED;\n        end else begin\n          next_state <= IDLE;\n        end\n      end\n      ITEM_SELECTED: begin\n        dispense_item <= 1;\n        return_coin <= 0;\n        if (item_dispensed) begin\n          next_state <= ITEM_DISPENSED;\n        end else begin\n          next_state <= ITEM_SELECTED;\n        end\n      end\n      ITEM_DISPENSED: begin\n        dispense_item <= 0;\n        return_coin <= 1;\n        next_state <= IDLE;\n      end\n      default: begin\n        dispense_item <= 0;\n        return_coin <= 0;\n        next_state <= IDLE;\n      end\n    endcase\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "POR_d00ac407", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule POR (\n  input vdd, // power supply signal\n  input clk, // clock signal\n  output reg rst // reset signal\n);\n\n  reg [23:0] counter; // 24-bit counter for delay time\n  \n  always @(posedge clk) begin\n    if (vdd == 1'b0) begin // power removed\n      rst <= 1'b1; // set reset signal high\n      counter <= 0; // reset counter\n    end\n    else if (counter == 24'd100000) begin // delay time elapsed\n      rst <= 1'b0; // set reset signal low\n    end\n    else begin // count up\n      counter <= counter + 1;\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hdll__xnor2_6a5dfdc5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hdll__xnor2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire xnor0_out_Y;\n\n    xnor xnor0 (xnor0_out_Y, A, B           );\n    buf  buf0  (Y          , xnor0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dffr_9_c64204f0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dffr_9 ( clk, reset, d, q );\n\t// synthesis attribute keep_hierarchy dffr_9 \"true\";\n\tinput clk;\n\tinput reset;\n\tinput [8:0] d;\n\toutput [8:0] q;\n\treg [8:0] q;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 9'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "regfile_1fb55019", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule regfile(\n  input clk,\n  input we,\n  input [3:0] wa,\n  input [7:0] wd,\n  input [3:0] ra,\n  output [7:0] rd,\n  output [3:0] out\n);\n\n  reg [7:0] data [0:15];\n  reg [3:0] addr;\n  \n  always @(posedge clk) begin\n    if (we) begin\n      data[wa] <= wd;\n    end\n    addr <= ra;\n  end\n  \n  assign rd = data[addr];\n  assign out = addr;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "trigger_output_c5947d1a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule trigger_output (\n    input [4:0] src_async,\n    input [4:0] src_sync,\n    input [4:0] src_single,\n    input [4:0] src_gen,\n    input [4:0] src_pg,\n    input sel_async,\n    input sel_sync,\n    input sel_single,\n    input sel_gen,\n    input sel_pg,\n    input sel_chain,\n    input sel_dir_async,\n    input sel_dir_sync,\n    input sel_dir_single,\n    input sel_dir_gen,\n    input sel_dir_pg,\n    output [4:0] dst_tbm,\n    output [4:0] dst_sync,\n    output [4:0] dst_tbm_pos,\n    output [4:0] dst_sync_direct,\n    output [4:0] dst_dir\n);\n\n    localparam SYN = 0;\n    localparam TRG = 1;\n    localparam RSR = 2;\n    localparam RST = 3;\n    localparam CAL = 4;\n\n    // switch\n    wire [4:0] src_async_gated = {5{sel_async}} & src_async;\n    wire [4:0] src_sync_gated = {5{sel_sync}} & src_sync;\n    wire [4:0] src_single_gated = {5{sel_single}} & src_single;\n    wire [4:0] src_gen_gated = {5{sel_gen}} & src_gen;\n    wire [4:0] src_pg_gated = {5{sel_pg}} & src_pg;\n\n    wire [4:0] sum = src_async_gated | src_sync_gated | src_single_gated | src_gen_gated | src_pg_gated;\n\n    assign dst_sync_direct = sel_chain & src_sync;\n\n    assign dst_tbm = sum;\n    assign dst_sync = {5{sel_sync}} & (!sel_chain & sum);\n\n    assign dst_tbm_pos = {src_async[1], src_async_gated[1], src_async_gated[1], src_async_gated[1], src_async_gated[1]};\n\n    // dir\n    wire [4:0] src_dir_async_gated = {5{sel_dir_async}} & src_async;\n    wire [4:0] src_dir_sync_gated = {5{sel_dir_sync}} & src_sync;\n    wire [4:0] src_dir_single_gated = {5{sel_dir_single}} & src_single;\n    wire [4:0] src_dir_gen_gated = {5{sel_dir_gen}} & src_gen;\n    wire [4:0] src_dir_pg_gated = {5{sel_dir_pg}} & src_pg;\n\n    wire [4:0] sum_dir = src_dir_async_gated | src_dir_sync_gated | src_dir_single_gated | src_dir_gen_gated | src_dir_pg_gated;\n\n    assign dst_dir = sum_dir;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ps2_rx_4bfe9ee6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ps2_rx\n   (\n    input wire clk, reset,\n    inout wire ps2d, ps2c, \n\t input wire rx_en,\n    output reg rx_done_tick,\n    output wire [7:0] dout\n   );\n\n   localparam [1:0]\n      idle = 2'b00,\n      dps  = 2'b01,\n      load = 2'b10;\n\n   reg [1:0] state_reg, state_next;\n   reg [7:0] filter_reg;\n   wire [7:0] filter_next;\n   reg f_ps2c_reg;\n   wire f_ps2c_next;\n   reg [3:0] n_reg, n_next;\n   reg [10:0] b_reg, b_next;\n   wire fall_edge;\n\n   always @(posedge clk, posedge reset)\n   if (reset)\n      begin\n         filter_reg <= 0;\n         f_ps2c_reg <= 0;\n      end\n   else\n      begin\n         filter_reg <= filter_next;\n         f_ps2c_reg <= f_ps2c_next;\n      end\n\n   assign filter_next = {ps2c, filter_reg[7:1]};\n   assign f_ps2c_next = (filter_reg==8'b11111111) ? 1'b1 :\n                        (filter_reg==8'b00000000) ? 1'b0 :\n                         f_ps2c_reg;\n   assign fall_edge = f_ps2c_reg & ~f_ps2c_next;\n\n   always @(posedge clk, posedge reset)\n      if (reset)\n         begin\n            state_reg <= idle;\n            n_reg <= 0;\n            b_reg <= 0;\n         end\n      else\n         begin\n            state_reg <= state_next;\n            n_reg <= n_next;\n            b_reg <= b_next;\n         end\n   always @*\n   begin\n      state_next = state_reg;\n      rx_done_tick = 1'b0;\n      n_next = n_reg;\n      b_next = b_reg;\n      case (state_reg)\n         idle:\n            if (fall_edge & rx_en)\n               begin\n                  b_next = {ps2d, b_reg[10:1]};\n                  n_next = 4'b1001;\n                  state_next = dps;\n               end\n         dps: if (fall_edge)\n               begin\n                  b_next = {ps2d, b_reg[10:1]};\n                  if (n_reg==0)\n                     state_next = load;\n                  else\n                     n_next = n_reg - 1'b1;\n               end\n         load: begin\n               state_next = idle;\n               rx_done_tick = 1'b1;\n            end\n      endcase\n   end\n   assign dout = b_reg[8:1]; endmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sparc_exu_aluor32_9052fb26", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sparc_exu_aluor32\n  (\n   out, \n   in\n   );\n\n   input [31:0] in;         output       out;       wire         nor1_1;\n   wire         nor1_2;\n   wire         nor1_3;\n   wire         nor1_4;\n   wire         nor1_5;\n   wire         nor1_6;\n   wire         nor1_7;\n   wire         nor1_8;\n   wire         nor1_9;\n   wire         nor1_10;\n   wire         nor1_11;\n   wire         nor1_12;\n   wire         nor1_13;\n   wire         nor1_14;\n   wire         nor1_15;\n   wire         nor1_16;\n   wire         nand2_1;\n   wire         nand2_2;\n   wire         nand2_3;\n   wire         nand2_4;\n   wire         inv3_1;\n   wire         inv3_2;\n   wire         inv3_3;\n   wire         inv3_4;\n\n   assign       nor1_1 = ~(in[1] | in[0]);\n   assign       nor1_2 = ~(in[3] | in[2]);\n   assign       nor1_3 = ~(in[5] | in[4]);\n   assign       nor1_4 = ~(in[7] | in[6]);\n   assign       nor1_5 = ~(in[9] | in[8]);\n   assign       nor1_6 = ~(in[11] | in[10]);\n   assign       nor1_7 = ~(in[13] | in[12]);\n   assign       nor1_8 = ~(in[15] | in[14]);\n   assign       nor1_9 = ~(in[17] | in[16]);\n   assign       nor1_10 = ~(in[19] | in[18]);\n   assign       nor1_11 = ~(in[21] | in[20]);\n   assign       nor1_12 = ~(in[23] | in[22]);\n   assign       nor1_13 = ~(in[25] | in[24]);\n   assign       nor1_14 = ~(in[27] | in[26]);\n   assign       nor1_15 = ~(in[29] | in[28]);\n   assign       nor1_16 = ~(in[31] | in[30]);\n\n   assign       nand2_1 = ~(nor1_1 & nor1_2 & nor1_3 & nor1_4);\n   assign       nand2_2 = ~(nor1_5 & nor1_6 & nor1_7 & nor1_8);\n   assign       nand2_3 = ~(nor1_9 & nor1_10 & nor1_11 & nor1_12);\n   assign       nand2_4 = ~(nor1_13 & nor1_14 & nor1_15 & nor1_16);\n\n   assign       inv3_1 = ~nand2_1;\n   assign       inv3_2 = ~nand2_2;\n   assign       inv3_3 = ~nand2_3;\n   assign       inv3_4 = ~nand2_4;\n\n   assign       out = ~(inv3_1 & inv3_2 & inv3_3 & inv3_4);\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__b380152a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (g, p, g_prec, p_prec, g_out, p_out);\n  input g, p, g_prec, p_prec;\n  output g_out, p_out;\n  wire n5;\n\n  // AOI21 gate implementation\n  assign n5 = ~(g_prec & p | ~g & p);\n\n  // AND2 gate implementation\n  assign p_out = p & p_prec;\n\n  // Inverter implementation\n  assign g_out = ~n5;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "twos_complement_ab779fb2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule twos_complement (\n    input [3:0] A,\n    output reg [3:0] OUT\n);\n\n    always @ (A) begin\n        OUT <= ~A + 1;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PCIeGen2x8If128_gtp_pipe_rate #_f3b94775", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\n\nmodule PCIeGen2x8If128_gtp_pipe_rate #\n(\n\n    parameter PCIE_SIM_SPEEDUP = \"FALSE\",                   parameter TXDATA_WAIT_MAX  = 4'd15                      )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_DRP_DONE,\n    input               RATE_RXPMARESETDONE,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output              RATE_DRP_START,\n    output              RATE_DRP_X16,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [ 4:0]  RATE_FSM\n\n);\n\n        reg         [ 1:0]  rate_in_reg1;\n    reg                 drp_done_reg1;\n    reg                 rxpmaresetdone_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg         [ 1:0]  rate_in_reg2;\n    reg                 drp_done_reg2;\n    reg                 rxpmaresetdone_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel =  1'd0; \n    reg         [ 2:0]  rate_out =  3'd0; \n    reg         [ 3:0]  fsm      =  0;                 \n   \n    localparam          FSM_IDLE           = 0; \n    localparam          FSM_TXDATA_WAIT    = 1;           \n    localparam          FSM_PCLK_SEL       = 2; \n    localparam          FSM_DRP_X16_START  = 3;\n    localparam          FSM_DRP_X16_DONE   = 4;   \n    localparam          FSM_RATE_SEL       = 5;\n    localparam          FSM_RXPMARESETDONE = 6; \n    localparam          FSM_DRP_X20_START  = 7;\n    localparam          FSM_DRP_X20_DONE   = 8;   \n    localparam          FSM_RATE_DONE      = 9;\n    localparam          FSM_TXSYNC_START   = 10;\n    localparam          FSM_TXSYNC_DONE    = 11;             \n    localparam          FSM_DONE           = 12; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rate_in_reg1        <= 2'd0;\n        drp_done_reg1       <= 1'd0;\n        rxpmaresetdone_reg1 <= 1'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        drp_done_reg2       <= 1'd0;\n        rxpmaresetdone_reg2 <= 1'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rate_in_reg1        <= RATE_RATE_IN;\n        drp_done_reg1       <= RATE_DRP_DONE;\n        rxpmaresetdone_reg1 <= RATE_RXPMARESETDONE;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rate_in_reg2        <= rate_in_reg1;\n        drp_done_reg2       <= drp_done_reg1;\n        rxpmaresetdone_reg2 <= rxpmaresetdone_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if ((fsm == FSM_RATE_DONE) || (fsm == FSM_RXPMARESETDONE) || (fsm == FSM_DRP_X20_START) || (fsm == FSM_DRP_X20_DONE))\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm      <= FSM_IDLE;\n        pclk_sel <= 1'd0; \n        rate_out <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm      <= FSM_TXDATA_WAIT;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            else\n                begin\n                fsm      <= FSM_IDLE;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            end \n            \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm      <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_SEL : FSM_DRP_X16_START;    \n            pclk_sel <= (rate_in_reg2 == 2'd1);\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X16_DONE : FSM_DRP_X16_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_SEL : FSM_DRP_X16_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_DONE : FSM_RXPMARESETDONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate;                               end    \n            \n        FSM_RXPMARESETDONE :\n        \n            begin\n            fsm      <= (!rxpmaresetdone_reg2) ? FSM_DRP_X20_START : FSM_RXPMARESETDONE;  \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end  \n            \n        FSM_DRP_X20_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X20_DONE : FSM_DRP_X20_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X20_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_DONE : FSM_DRP_X20_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone) \n                fsm <= FSM_TXSYNC_START;\n            else      \n                fsm <= FSM_RATE_DONE;\n            \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm      <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm      <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm      <= FSM_IDLE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm      <= FSM_IDLE;\n            pclk_sel <= 1'd0; \n            rate_out <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL     = pclk_sel;\nassign RATE_DRP_START    = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X20_START); \nassign RATE_DRP_X16      = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X16_DONE);\nassign RATE_RATE_OUT     = rate_out;\nassign RATE_TXSYNC_START = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE         = (fsm == FSM_DONE);\nassign RATE_IDLE         = (fsm == FSM_IDLE);\nassign RATE_FSM          = {1'd0, fsm};   \n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Serial_in_parallel_out_enable_behavior_0605622c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Serial_in_parallel_out_enable_behavior(\n\n    input Clk, ShiftIn, reset, ShiftEn,\n    output wire ShiftOut,\n    output wire [3:0] ParallelOut\n    );\n\n    reg [15:0] ShiftReg;\n    reg [3:0] ParallelReg;\n\n    always @(posedge Clk) begin\n        if (reset) begin\n            ShiftReg <= 16'h0000;\n        end\n        else if (ShiftEn) begin\n            ShiftReg <= {ShiftReg[14:0], ShiftIn};\n        end\n    end\n\n    always @(posedge Clk) begin\n        if (reset) begin\n            ParallelReg <= 4'b0000;\n        end\n        else if (ShiftEn) begin\n            ParallelReg[0] <= ShiftReg[3:0];\n            ParallelReg[1] <= ShiftReg[7:4];\n            ParallelReg[2] <= ShiftReg[11:8];\n            ParallelReg[3] <= ShiftReg[15:12];\n        end\n    end\n\n    assign ShiftOut = ShiftReg[15];\n    assign ParallelOut = ParallelReg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "three_input_gate_955ff18e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule three_input_gate (\n    input  A1,\n    input  A2,\n    input  B1,\n    output Y\n);\n\n    assign Y = (A1 & A2) | B1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_c9f4e5d7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n  input clk,\n  input rst,\n  input up_down,\n  output reg [7:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 8'd0;\n    end else if (up_down) begin\n      if (count == 8'd255) begin\n        count <= 8'd0;\n      end else begin\n        count <= count + 1;\n      end\n    end else begin\n      if (count == 8'd0) begin\n        count <= 8'd255;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_b5eeb7f6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder(A, B, sum);\n  input [3:0] A, B;\n  output reg [4:0] sum;\n  \n  always @* begin\n    sum = A + B;\n    if (sum > 15) begin\n      sum = sum[3:0];\n    end\n  end\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_4f4a5428", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule priority_encoder (\n    input A, B, C, D, // Inputs for the priority encoder\n    output reg [1:0] Y // 2-bit output from the priority encoder\n);\n\nalways @* begin\n    if ({A, B, C, D}==4'b1110) Y = 2'b11;\n    else if ({A, B, C, D}==4'b1101) Y = 2'b10;\n    else if ({A, B, C, D}==4'b1011) Y = 2'b01;\n    else if ({A, B, C, D}==4'b0111) Y = 2'b00;\n    else Y = 2'b00;\nend\n\nendmodule\nmodule barrel_shifter (\n    input [3:0] data, // 4-bit input for the barrel shifter\n    input [1:0] shift, // 2-bit input for the barrel shifter\n    output reg [3:0] q // 4-bit output from the barrel shifter\n);\n\nalways @* begin\n    case (shift)\n        2'b00: q = data;\n        2'b01: q = {data[3:1], data[0]};\n        2'b10: q = {data[2:0], data[3]};\n        2'b11: q = {data[1:0], data[3:2]};\n        default: q = data;\n    endcase\nend\n\nendmodule\nmodule functional_module (\n    input [1:0] Y, // 2-bit input from the priority encoder\n    input [3:0] data, // 4-bit input from the barrel shifter\n    output [3:0] q // 4-bit output from the functional module\n);\n\nassign q = (Y | data);\n\nendmodule\nmodule top_module (\n    input A, B, C, D, // Inputs for the priority encoder\n    input [3:0] data, // 4-bit input for the barrel shifter\n    input [1:0] shift, // 2-bit input for the barrel shifter\n    output [3:0] q // 4-bit output from the functional module\n);\n\nwire [1:0] Y;\npriority_encoder pe(A, B, C, D, Y);\nbarrel_shifter bs(data, shift, q);\nfunctional_module fm(Y, q);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "twos_comp_addsub_1d15f1fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule twos_comp_addsub (\n    input signed [15:0] a,\n    input signed [15:0] b,\n    input sub,\n    output reg signed [15:0] result,\n    output reg overflow\n);\n\n    always @(*) begin\n        if (sub) begin\n            result = a - b;\n            overflow = ((a < 0) & (b > 0) & (result > 0)) | ((a > 0) & (b < 0) & (result < 0));\n        end else begin\n            result = a + b;\n            overflow = ((a > 0) & (b > 0) & (result < 0)) | ((a < 0) & (b < 0) & (result > 0));\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_generator_f79037c4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule parity_generator (\n  input in1,\n  input in2,\n  input in3,\n  input in4,\n  output reg parity\n);\n\n  always @ (in1, in2, in3, in4) begin\n    if ((in1 + in2 + in3 + in4) % 2 == 0)\n      parity <= 0;\n    else\n      parity <= 1;\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "long_to_double_03e9b678", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule long_to_double(\n        input_a,\n        input_a_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [63:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  output    [63:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [63:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [2:0] state;\n  parameter get_a         = 3'd0,\n            convert_0     = 3'd1,\n            convert_1     = 3'd2,\n            convert_2     = 3'd3,\n            round         = 3'd4,\n            pack          = 3'd5,\n            put_z         = 3'd6;\n\n  reg [63:0] a, z, value;\n  reg [52:0] z_m;\n  reg [10:0] z_r;\n  reg [10:0] z_e;\n  reg z_s;\n  reg guard, round_bit, sticky;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= convert_0;\n        end\n      end\n\n      convert_0:\n      begin\n        if ( a == 0 ) begin\n          z_s <= 0;\n          z_m <= 0;\n          z_e <= -1023;\n          state <= pack;\n        end else begin\n          value <= a[63] ? -a : a;\n          z_s <= a[63];\n          state <= convert_1;\n        end\n      end\n\n      convert_1:\n      begin\n        z_e <= 63;\n        z_m <= value[63:11];\n        z_r <= value[10:0];\n        state <= convert_2;\n      end\n\n      convert_2:\n      begin\n        if (!z_m[52]) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= z_r[10];\n          z_r <= z_r << 1;\n        end else begin\n          guard <= z_r[10];\n          round_bit <= z_r[9];\n          sticky <= z_r[8:0] != 0;\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit || sticky || z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 53'h1fffffffffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[51 : 0] <= z_m[51:0];\n        z[62 : 52] <= z_e + 1023;\n        z[63] <= z_s;\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hpdmc_banktimer_72eaae80", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule hpdmc_banktimer(\n\tinput sys_clk,\n\tinput sdram_rst,\n\t\n\tinput tim_cas,\n\tinput [1:0] tim_wr,\n\t\n\tinput read,\n\tinput write,\n\toutput reg precharge_safe\n);\n\nreg [2:0] counter;\nalways @(posedge sys_clk) begin\n\tif(sdram_rst) begin\n\t\tcounter <= 3'd0;\n\t\tprecharge_safe <= 1'b1;\n\tend else begin\n\t\tif(read) begin\n\t\t\t\n\t\t\tcounter <= 3'd4;\n\t\t\tprecharge_safe <= 1'b0;\n\t\tend else if(write) begin\n\t\t\tcounter <= {1'b1, tim_wr};\n\t\t\tprecharge_safe <= 1'b0;\n\t\tend else begin\n\t\t\tif(counter == 3'b1)\n\t\t\t\tprecharge_safe <= 1'b1;\n\t\t\tif(~precharge_safe)\n\t\t\t\tcounter <= counter - 3'b1;\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__80aa7a85", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input               clk         ,\n    input               rst_n       ,\n    input       [7:0]   data_in_1   ,\n    input       [7:0]   data_in_2   ,\n    input               valid_a     ,\n    input               ready_b     ,\n    output              ready_a     ,\n    output              valid_b     ,\n    output      [8:0]   data_out\n);\n\nwire [8:0] sum;\nwire carry;\n\n adder8 adder_inst (\n    .a(data_in_1),\n    .b(data_in_2),\n    .sum(sum)\n);\n\nassign carry = (data_in_1+data_in_2) > 255 ? 1'b1 : 1'b0;\n\nreg [8:0] sum2;\nreg [8:0] data_out_r;\nreg valid_b_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        sum2 <= 0;\n        data_out_r <= 0;\n        valid_b_r <= 0;\n    end else begin\n        sum2 <= sum + sum2;\n        data_out_r <= sum;\n        valid_b_r <= valid_a;\n    end\nend\n\nassign data_out = data_out_r;\nassign valid_b = valid_b_r;\nassign ready_a = !valid_b || ready_b;\n\nendmodule\nmodule adder8 (\n    input       [7:0]   a           ,\n    input       [7:0]   b           ,\n    output reg  [8:0]   sum\n);\n\nalways @(*) begin\n    sum = a + b;\nend\n\nendmodule\nmodule carry_out (\n    input       [7:0]   a           ,\n    input       [7:0]   b           ,\n    output reg          cout\n);\n\nalways @(*) begin\n    cout = (a+b) > 255 ? 1'b1 : 1'b0;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PWM_d4664876", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule PWM (\n  input clk,\n  input [7:0] in,\n  output out\n);\n\nparameter clk_freq = 50000000; // 50 MHz\nparameter pwm_freq = 1000; // 1 kHz\n\nreg [31:0] counter = 0;\nreg [7:0] threshold = 0;\n\nassign out = (counter < threshold);\n\nalways @(posedge clk) begin\n  counter <= counter + 1;\n  if (counter >= (clk_freq / pwm_freq)) begin\n    counter <= 0;\n    threshold <= in;\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_counter_3caf2f28", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_counter (\n  input clk,\n  input reset,\n  output reg [2:0] count_out\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count_out <= 3'b0;\n    end\n    else begin\n      count_out <= count_out + 1;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__dfxtp_f68500ea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_lp__dfxtp (\n    //# {{data|Data Signals}}\n    input  D   ,\n    output Q   ,\n\n    //# {{clocks|Clocking}}\n    input  CLK ,\n\n    //# {{power|Power}}\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n    reg Q_reg;\n\n    always @(posedge CLK)\n        Q_reg <= D;\n    \n    assign Q = Q_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reset_resync #_4d75c72e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`ifdef INCL_RESET_RESYNC\n`else\n`define INCL_RESET_RESYNC\n\nmodule reset_resync #(\n\t\tparameter VALUE_DURING_RESET = 1\n) (\n  input       rst_in,\n  input       clk_in,\n\n  input       clk_out,\n    output reg  rst_out\n);\n\n reg rst_in_dly;\n\nalways @(posedge clk_in or posedge rst_in) begin\n  if (rst_in) begin\n    rst_in_dly <= 1'b1;\n  end else begin\n    rst_in_dly <= 1'b0;\n  end\nend\n\n\ninitial begin\n\trst_out = VALUE_DURING_RESET;\nend\n\nalways @(posedge clk_out or posedge rst_in_dly) begin\n  if (rst_in_dly) begin\n    rst_out <= VALUE_DURING_RESET;\n  end else begin\n    rst_out <= ~VALUE_DURING_RESET;\n  end\nend\n\nendmodule\n\n`endif "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vending_machine_b74ad102", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule vending_machine (\n  input btnA,\n  input btnB,\n  input btnC,\n  input clk,\n  output reg dispenseBar,\n  output reg dispenseChips,\n  output reg dispenseSoda\n);\n\n  reg [1:0] state;\n\n  parameter IDLE = 2'b00;\n  parameter DISPENSING = 2'b01;\n  parameter RESET = 2'b10;\n\n  always @(posedge clk) begin\n    case(state)\n      IDLE: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        if(btnA) begin\n          dispenseBar = 1;\n          state = DISPENSING;\n        end else if(btnB) begin\n          dispenseChips = 1;\n          state = DISPENSING;\n        end else if(btnC) begin\n          dispenseSoda = 1;\n          state = DISPENSING;\n        end else begin\n          state = IDLE;\n        end\n      end\n      DISPENSING: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        state = RESET;\n      end\n      RESET: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        state = IDLE;\n      end\n      default: begin\n        dispenseBar = 0;\n        dispenseChips = 0;\n        dispenseSoda = 0;\n        state = IDLE;\n      end\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ic_download_c98061de", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule  ic_download(clk,\n                    rst,\n                    rep_flit_ic,\n                    v_rep_flit_ic,\n                    rep_ctrl_ic,\n                    mem_flits_ic,\n                    v_mem_flits_ic,\n                    ic_download_state,\n                    inst_word_ic,\n                    v_inst_word\n                    );\ninput                    clk;\ninput                    rst;\ninput      [15:0]        rep_flit_ic;\ninput                    v_rep_flit_ic;\ninput      [1:0]         rep_ctrl_ic;\ninput      [127:0]        mem_flits_ic;\ninput                    v_mem_flits_ic;\noutput     [1:0]         ic_download_state;\noutput     [127:0]       inst_word_ic;\noutput                   v_inst_word;\n\nreg [127:0]  inst_word ;\nreg [1:0]    ic_download_nstate;\nreg [1:0]    ic_download_cstate;\nparameter    ic_download_idle=2'b00;\nparameter    ic_download_busy=2'b01;\nparameter    ic_download_rdy=2'b10;\n\nassign ic_download_state=ic_download_cstate;\nassign inst_word_ic=inst_word;\n\nreg             v_inst_word;\nreg             en_mem_flits_ic;\nreg             en_rep_flit_ic;\nreg             inc_cnt;\nreg             fsm_rst;\nreg   [127:0]   inst_word_in;\nalways@(*)\nbegin\n  ic_download_nstate=ic_download_cstate;\n  v_inst_word=1'b0;\n  en_mem_flits_ic=1'b0;\n  en_rep_flit_ic=1'b0;\n  inc_cnt=1'b0;\n  fsm_rst=1'b0;\n  inst_word_in=128'h0000;\n  case(ic_download_cstate)\n    ic_download_idle:\n      begin\n        if(v_mem_flits_ic)\n          begin\n            ic_download_nstate=ic_download_rdy;\n            inst_word_in=mem_flits_ic;\n            en_mem_flits_ic=1'b1;\n          end\n      else if(v_rep_flit_ic)\n          begin\n            ic_download_nstate=ic_download_busy;\n            en_rep_flit_ic=1'b1;\n          end\n      end\n    ic_download_busy:\n      begin\n        if(rep_ctrl_ic==2'b11)\n           begin\n             en_rep_flit_ic=1'b1;\n            ic_download_nstate=ic_download_rdy;\n           end\n        else if(rep_ctrl_ic==2'b10)\n          begin\n            en_rep_flit_ic=1'b1;\n            inc_cnt=1'b1;\n          end\n      end\n    ic_download_rdy:\n      begin\n        v_inst_word=1'b1;\n        ic_download_nstate=ic_download_idle;\n        fsm_rst=1'b1;\n      end\n    endcase\nend\n\nreg [2:0] cnt;\nreg  [7:0]  en_instword;\nalways@(*)\nbegin\n  case(cnt)\n    3'b000:en_instword=8'b00000001;\n    3'b001:en_instword=8'b00000010;\n    3'b010:en_instword=8'b00000100;\n    3'b011:en_instword=8'b00001000;\n    3'b100:en_instword=8'b00010000;\n    3'b101:en_instword=8'b00100001;\n    3'b110:en_instword=8'b01000001;\n    3'b111:en_instword=8'b10000001;\n    default:en_instword=8'b00000000;\n  endcase\n end\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[15:0]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[15:0]<=inst_word_in[15:0];\n  else if(en_rep_flit_ic&&en_instword[0])\n      inst_word[15:0]<=inst_word_in[15:0];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[31:16]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[31:16]<=inst_word_in[31:16];\n  else if(en_rep_flit_ic&&en_instword[1])\n      inst_word[31:16]<=inst_word_in[31:16];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[47:32]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[47:32]<=inst_word_in[47:32];\n  else if(en_rep_flit_ic&&en_instword[2])\n      inst_word[47:32]<=inst_word_in[47:32];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[63:48]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[63:48]<=inst_word_in[63:48];\n  else if(en_rep_flit_ic&&en_instword[3])\n      inst_word[63:48]<=inst_word_in[63:48];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[79:64]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[79:64]<=inst_word_in[79:64];\n  else if(en_rep_flit_ic&&en_instword[4])\n      inst_word[79:64]<=inst_word_in[79:64];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[95:80]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[95:80]<=inst_word_in[95:80];\n  else if(en_rep_flit_ic&&en_instword[5])\n      inst_word[95:80]<=inst_word_in[95:80];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[111:96]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[111:96]<=inst_word_in[111:96];\n  else if(en_rep_flit_ic&&en_instword[6])\n      inst_word[111:96]<=inst_word_in[111:96];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    begin\n      inst_word[127:112]<=16'h0000;\n    end\n  else if(en_mem_flits_ic)\n      inst_word[127:112]<=inst_word_in[127:112];\n  else if(en_rep_flit_ic&&en_instword[7])\n      inst_word[127:112]<=inst_word_in[127:112];\nend\n\nalways@(posedge clk)\nbegin\n  if(rst)\n    ic_download_cstate<=2'b00;\n  else\n    ic_download_cstate<=ic_download_nstate;\nend\n\n\nalways@(posedge clk)\nbegin\n  if(rst||fsm_rst)\n    cnt<=3'b000;\n  else if(inc_cnt)\n    cnt<=cnt+3'b001;\nend\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_a1801204", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo\n\t#(\n\tparameter B=8,\n\tW=4\n\t)\n(\ninput wire clk, reset,\ninput wire rd, wr,\ninput wire [B-1:0] w_data,\noutput wire empty, full,\noutput wire [B-1:0] r_data\n);\nreg [B-1:0] array_reg [2**W-1:0]; reg [W-1:0] w_ptr_reg, w_ptr_next, w_ptr_succ;\nreg [W-1:0] r_ptr_reg, r_ptr_next, r_ptr_succ;\nreg full_reg, empty_reg, full_next, empty_next;\nwire wr_en;\n\nalways @(posedge clk)\n\tif (wr_en)\n\t\tarray_reg [w_ptr_reg] <= w_data;\nassign r_data = array_reg[r_ptr_reg];\nassign wr_en = wr & ~full_reg;\nalways @(posedge clk)\nif (reset)\n\tbegin\n\tw_ptr_reg <= 0;\n\tr_ptr_reg <= 0;\n\tfull_reg <= 1'b0;\n\tempty_reg <= 1'b1;\n\tend\nelse\n\tbegin\n\tw_ptr_reg <= w_ptr_next;\n\tr_ptr_reg <= r_ptr_next;\n\tfull_reg <= full_next;\n\tempty_reg <= empty_next;\n\tend\nalways @*\n\tbegin\n\tw_ptr_succ = w_ptr_reg + 1;\n\tr_ptr_succ = r_ptr_reg + 1;\n\tw_ptr_next = w_ptr_reg;\n\tr_ptr_next = r_ptr_reg;\n\tfull_next = full_reg;\n\tempty_next = empty_reg;\n\tcase ({wr, rd})\n\t2'b01: if (~empty_reg) begin\n\t\t\tr_ptr_next = r_ptr_succ;\n\t\t\tfull_next = 1'b0;\n\t\t\tif (r_ptr_succ==w_ptr_reg)\n\t\t\t\tempty_next = 1'b1;\n\t\t\tend\n\t\t2'b10: if (~full_reg) begin\n\t\t\tw_ptr_next = w_ptr_succ ;\n\t\t\tempty_next = 1'b0;\n\t\t\tif (w_ptr_succ==r_ptr_reg)\n\t\t\t\tfull_next = 1'b1;\n\t\t\tend\n\t\t2'b11: begin\n\t\t\tw_ptr_next = w_ptr_succ;\n\t\t\tr_ptr_next = r_ptr_succ;\n\t\t\tend\n\tendcase\nend\nassign full = full_reg;\nassign empty = empty_reg;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "POR_a153912a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule POR (\n  input clk,\n  input pwr,\n  output reg rst\n);\n\nparameter rst_time = 10; // duration for which the reset signal should be asserted\n\nreg pwr_prev; // previous value of power signal\nreg [3:0] rst_count; // counter for reset signal duration\n\nalways @(posedge clk) begin\n  if (pwr && !pwr_prev) begin // power has just been applied\n    rst <= 1;\n    rst_count <= 0;\n  end else if (rst_count < rst_time) begin // reset signal is still being asserted\n    rst <= 1;\n    rst_count <= rst_count + 1;\n  end else begin // reset signal has been de-asserted\n    rst <= 0;\n  end\n  \n  pwr_prev <= pwr;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo #_51550143", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo #(\n    parameter MEM_STYLE = \"auto\",\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 1,\n    parameter DEPTH = 2\n) (\n    input clk,\n    input reset,\n    input if_write_ce,\n    input [DATA_WIDTH-1:0] if_write,\n    input if_read_ce,\n    output reg if_empty_n,\n    output reg [DATA_WIDTH-1:0] if_dout,\n    output reg if_full_n\n);\n\nreg [ADDR_WIDTH:0] write_ptr = 0;\nreg [ADDR_WIDTH:0] read_ptr = 0;\nreg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        write_ptr <= 0;\n        read_ptr <= 0;\n        if_empty_n <= 0;\n        if_full_n <= 1;\n    end else begin\n        if (if_write_ce) begin\n            mem[write_ptr] <= if_write;\n            write_ptr <= write_ptr + 1;\n            if (write_ptr == DEPTH) begin\n                write_ptr <= 0;\n            end\n            if_empty_n <= 1;\n            if (write_ptr == read_ptr) begin\n                if_full_n <= 0;\n            end\n        end\n        if (if_read_ce) begin\n            if_dout <= mem[read_ptr];\n            read_ptr <= read_ptr + 1;\n            if (read_ptr == DEPTH) begin\n                read_ptr <= 0;\n            end\n            if_full_n <= 1;\n            if (read_ptr == write_ptr) begin\n                if_empty_n <= 0;\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_to_one_a444afb1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_to_one (\n    input [3:0] in,\n    output out\n);\n\n    assign out = |in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wifi #_87860769", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wifi #(\n  parameter n = 8, // number of input signals\n  parameter m = 8 // number of output signals\n\n)(\n  input [n-1:0] in,\n  input clk,\n  input rst,\n  input start,\n  output valid,\n  output [m-1:0] out,\n  output done\n);\n\n\n// Encoding scheme\nwire [m-1:0] encoded;\nassign encoded[0] = in[0] ^ in[1] ^ in[3] ^ in[4] ^ in[6];\nassign encoded[1] = in[0] ^ in[2] ^ in[3] ^ in[5] ^ in[6];\nassign encoded[2] = in[1] ^ in[2] ^ in[3] ^ in[7];\nassign encoded[3] = in[4] ^ in[5] ^ in[6] ^ in[7];\nassign encoded[4] = in[0] ^ in[1] ^ in[2] ^ in[4] ^ in[5];\nassign encoded[5] = in[0] ^ in[1] ^ in[3] ^ in[4] ^ in[7];\nassign encoded[6] = in[1] ^ in[2] ^ in[4] ^ in[5] ^ in[7];\nassign encoded[7] = in[0] ^ in[2] ^ in[3] ^ in[6] ^ in[7];\n\n// Decoding scheme\nwire [n-1:0] decoded;\nassign decoded[0] = encoded[0] ^ encoded[1] ^ encoded[3] ^ encoded[4] ^ encoded[6];\nassign decoded[1] = encoded[0] ^ encoded[2] ^ encoded[3] ^ encoded[5] ^ encoded[6];\nassign decoded[2] = encoded[1] ^ encoded[2] ^ encoded[3] ^ encoded[7];\nassign decoded[3] = encoded[4] ^ encoded[5] ^ encoded[6] ^ encoded[7];\nassign decoded[4] = encoded[0] ^ encoded[1] ^ encoded[2] ^ encoded[4] ^ encoded[5];\nassign decoded[5] = encoded[0] ^ encoded[1] ^ encoded[3] ^ encoded[4] ^ encoded[7];\nassign decoded[6] = encoded[1] ^ encoded[2] ^ encoded[4] ^ encoded[5] ^ encoded[7];\nassign decoded[7] = encoded[0] ^ encoded[2] ^ encoded[3] ^ encoded[6] ^ encoded[7];\n\n// Transmitter block\nreg [n-1:0] input_reg;\nreg [m-1:0] encoded_reg;\nreg valid_reg;\nalways @(posedge clk, posedge rst) begin\n  if (rst) begin\n    input_reg <= 0;\n    encoded_reg <= 0;\n    valid_reg <= 0;\n  end else begin\n    if (start) begin\n      input_reg <= in;\n      encoded_reg <= encoded;\n      valid_reg <= 1;\n    end else if (valid_reg) begin\n      valid_reg <= 0;\n    end\n  end\nend\n\n// Receiver block\nreg [m-1:0] encoded_reg2;\nreg [n-1:0] decoded_reg;\nreg done_reg;\nalways @(posedge clk, posedge rst) begin\n  if (rst) begin\n    encoded_reg2 <= 0;\n    decoded_reg <= 0;\n    done_reg <= 0;\n  end else begin\n    if (valid_reg) begin\n      encoded_reg2 <= encoded_reg;\n      done_reg <= 0;\n    end else if (encoded_reg2 != 0) begin\n      decoded_reg <= decoded;\n      done_reg <= 1;\n    end\n  end\nend\n\n// Output signals\nassign valid = valid_reg;\nassign out = encoded_reg;\nassign done = done_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux2to1_bb5f3345", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux2to1 (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    assign out = (sel == 1'b1) ? a : b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "acl_fp_fptosi_6df6899a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule acl_fp_fptosi( clock, enable, resetn, dataa, result);\n    input clock;    \n    input enable, resetn;\n    input [31:0] dataa;\n    output [31:0] result;\n\n    wire sign_0;\n    wire [7:0] exp_0;\n    wire [22:0] man_0;\n    wire [23:0] implied_man_0;\n\n    assign {sign_0, exp_0, man_0} = dataa;\n    assign implied_man_0 = {1'b1, man_0};\n\n    reg sign_1;\n    reg [30:0] man_1;\n    reg [7:0] shift_amount_1;\n\n    always @( posedge clock or negedge resetn)\n    begin\n        if( ~resetn ) begin\n            sign_1 <= 1'b0;\n            man_1 <= 31'd0;\n            shift_amount_1 <= 8'd0;\n        end\n        else if (enable)\n\t      begin\n            sign_1 <= sign_0;\n\n            if( exp_0 < 8'd127 )\n            begin\n                man_1 <= 31'd0;\n                shift_amount_1 <= 8'd0;\n            end\n            else\n            begin\n                man_1 <= {implied_man_0, 7'd0};\n                shift_amount_1 <= exp_0 - 8'd127;\n            end\n        end\n    end\n\n    reg sign_2;\n    reg [30:0] result_2;\n\n    always @( posedge clock or negedge resetn)\n    begin\n\t      if (~resetn)\n\t      begin\n\t\t        sign_2 <= 1'b0;\n\t\t        result_2 <= 31'd0;\n\t      end\n\t      else if (enable)\n        begin\n            sign_2 <= sign_1;\n\n            case( shift_amount_1 )\n                8'd00: result_2 <= man_1[30:30];\n                8'd01: result_2 <= man_1[30:29];\n                8'd02: result_2 <= man_1[30:28];\n                8'd03: result_2 <= man_1[30:27];\n                8'd04: result_2 <= man_1[30:26];\n                8'd05: result_2 <= man_1[30:25];\n                8'd06: result_2 <= man_1[30:24];\n                8'd07: result_2 <= man_1[30:23];\n                8'd08: result_2 <= man_1[30:22];\n                8'd09: result_2 <= man_1[30:21];\n                8'd10: result_2 <= man_1[30:20];\n                8'd11: result_2 <= man_1[30:19];\n                8'd12: result_2 <= man_1[30:18];\n                8'd13: result_2 <= man_1[30:17];\n                8'd14: result_2 <= man_1[30:16];\n                8'd15: result_2 <= man_1[30:15];\n                8'd16: result_2 <= man_1[30:14];\n                8'd17: result_2 <= man_1[30:13];\n                8'd18: result_2 <= man_1[30:12];\n                8'd19: result_2 <= man_1[30:11];\n                8'd20: result_2 <= man_1[30:10];\n                8'd21: result_2 <= man_1[30:9];\n                8'd22: result_2 <= man_1[30:8];\n                8'd23: result_2 <= man_1[30:7];\n                8'd24: result_2 <= man_1[30:6];\n                8'd25: result_2 <= man_1[30:5];\n                8'd26: result_2 <= man_1[30:4];\n                8'd27: result_2 <= man_1[30:3];\n                8'd28: result_2 <= man_1[30:2];\n                8'd29: result_2 <= man_1[30:1];\n                8'd30: result_2 <= man_1[30:0];\n                default: result_2 <= {31{1'b1}};    endcase\n        end\n    end\n\n    reg [31:0] result_3;\n\n    always @( posedge clock or negedge resetn)\n    begin\n        if (~resetn)\n\t\t        result_3 <= 32'd0;\n\t      else if (enable)\n\t      begin\n            if( sign_2 )\n                result_3 <= ~({1'b0, result_2}) + 32'd1;\n            else\n                result_3 <= {1'b0, result_2};\n        end\n    end\n\n    assign result = result_3;\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__445035f6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input select,\n    input subtract,\n    output eq,\n    output gt,\n    output [3:0] result\n);\n\n    wire [3:0] adder_out;\n    wire [3:0] comparator_out;\n    wire [3:0] final_result;\n\n    // Instantiate adder/subtractor module\n    adder_subtractor add_sub (\n        .A(A),\n        .B(B),\n        .subtract(subtract),\n        .result(adder_out)\n    );\n\n    // Instantiate magnitude comparator module\n    magnitude_comparator mag_comp (\n        .A(A),\n        .B(B),\n        .eq(eq),\n        .gt(gt),\n        .result(comparator_out)\n    );\n\n    // Functional module to select output\n    assign final_result = select ? comparator_out : adder_out;\n\n    // Output signals\n    assign result = final_result;\n\nendmodule\n\n// Adder/Subtractor module\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input subtract,\n    output [3:0] result\n);\n\n    assign result = subtract ? A - B : A + B;\n\nendmodule\n\n// Magnitude Comparator module\nmodule magnitude_comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output eq,\n    output gt,\n    output [3:0] result\n);\n\n    assign eq = (A == B);\n    assign gt = (A > B);\n    assign result = {gt, eq};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SSCG_93b99a5e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule SSCG (\n  input clk_in, // input clock signal\n  input clk_en, // SSCG enable signal\n  input [31:0] sscg_freq, // frequency deviation parameter\n  output clk_out // output clock signal\n);\n\n  reg [31:0] fm_accumulator;\n  reg [31:0] fm_increment;\n  reg [31:0] fm_modulation;\n  reg clk_output;\n\n  always @ (posedge clk_in) begin\n    if (clk_en) begin\n      fm_accumulator <= fm_accumulator + fm_increment;\n      fm_modulation <= sscg_freq >> 1; // fix: remove $urandom\n      clk_output <= (fm_accumulator + fm_modulation) >> 1;\n    end else begin\n      clk_output <= clk_in;\n    end\n  end\n\n  assign clk_out = clk_output;\n\n  parameter PERIOD = (2**32 / 1000) * 100; // 100 kHz\n\n  initial begin\n    fm_accumulator <= 0;\n    fm_increment <= PERIOD; // 100 kHz\n    fm_modulation <= 0;\n    clk_output <= 0;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__35acc4fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input [15:0] in, // 16 inputs for the multiplexer\n    input [3:0] sel, // 4-bit select input for the multiplexer\n    output q // Output of the final logical operation module\n);\n\n    reg [15:0] mux_out; // Output of the multiplexer\n    reg d_ff_out; // Output of the dual-edge triggered flip-flop\n    reg d_ff_out_r; // Registered version of d_ff_out\n    wire [15:0] or_in; // Input to the logical operation module\n\n    // Multiplexer implementation\n    always @(*) begin\n        case (sel)\n            4'b0000: mux_out = in[0];\n            4'b0001: mux_out = in[1];\n            4'b0010: mux_out = in[2];\n            4'b0011: mux_out = in[3];\n            4'b0100: mux_out = in[4];\n            4'b0101: mux_out = in[5];\n            4'b0110: mux_out = in[6];\n            4'b0111: mux_out = in[7];\n            4'b1000: mux_out = in[8];\n            4'b1001: mux_out = in[9];\n            4'b1010: mux_out = in[10];\n            4'b1011: mux_out = in[11];\n            4'b1100: mux_out = in[12];\n            4'b1101: mux_out = in[13];\n            4'b1110: mux_out = in[14];\n            4'b1111: mux_out = in[15];\n        endcase\n    end\n\n    // Dual-edge triggered flip-flop implementation\n    always @(posedge clk) begin\n        d_ff_out <= mux_out;\n    end\n\n    always @(negedge clk) begin\n        d_ff_out_r <= d_ff_out;\n    end\n\n    // Logical operation module implementation\n    assign or_in = {16{d_ff_out_r}} | in;\n    assign q = |or_in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "acciones_to_bcd_9280ef31", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule acciones_to_bcd(\n\t input clk,\n\t input rst,\n\t input [1:0] piso, input [1:0] accion, input puertas, output reg [3:0] BCD1,\n\t output reg [3:0] BCD2,\n\t output reg [3:0] BCD3,\n\t output reg [3:0] BCD4\n    );\n\ninitial begin\n\tBCD4 = 1;\n\tBCD3 = 9;\n\tBCD2 = 6;\n\tBCD1 = 0;\nend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD4 = 4'b1110;\n\t\t\t\t#10 BCD4 = 4'b0001;\n\t\t\t\tBCD3 = 4'b0110;\n\t\t\t\t#10 BCD3 = 4'b1001;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (piso == 2'b00)\n\t\t\t\t\tBCD4 = 4'b0001;\n\t\t\t\telse if (piso == 2'b01)\n\t\t\t\t\tBCD4 = 4'b0010;\n\t\t\t\telse if (piso == 2'b10)\n\t\t\t\t\tBCD4 = 4'b0011;\n\t\t\t\telse\n\t\t\t\t\tBCD4 = 4'b0100;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD1 = 4'b1111;\n\t\t\t\t#10 BCD1 = 4'b0000;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (accion == 2'b00)\n\t\t\t\t\tBCD1 = 4'b0000;\n\t\t\t\telse if (accion == 2'b01)\n\t\t\t\t\tBCD1 = 4'b0101;\n\t\t\t\telse if (accion == 2'b10)\n\t\t\t\t\tBCD1 = 4'b1000;\n\t\t\t\telse\n\t\t\t\t\tBCD1 = 0;\n\t\t\tend\n\tend\n\nalways @ (posedge clk)\n\tbegin\n\t\tif (rst == 1)\n\t\t\tbegin\n\t\t\t\tBCD2 = 4'b1001;\n\t\t\t\t#10 BCD2 = 4'b0110;\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tif (puertas == 1'b0)\n\t\t\t\t\tBCD2 = 4'b0111;\n\t\t\t\telse\n\t\t\t\t\tBCD2 = 4'b0110;\n\t\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_core_axi_basic_rx_null_gen #_974318d4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule pcie_core_axi_basic_rx_null_gen # (\n  parameter C_DATA_WIDTH = 128,           parameter TCQ = 1,                      parameter KEEP_WIDTH = C_DATA_WIDTH / 8            ) (\n\n  input      [C_DATA_WIDTH-1:0] m_axis_rx_tdata,     input                         m_axis_rx_tvalid,    input                         m_axis_rx_tready,    input                         m_axis_rx_tlast,     input                  [21:0] m_axis_rx_tuser,     output                        null_rx_tvalid,      output                        null_rx_tlast,       output       [KEEP_WIDTH-1:0] null_rx_tkeep,       output                        null_rdst_rdy,       output reg              [4:0] null_is_eof,         input                         user_clk,            input                         user_rst             );\n\n\nlocalparam INTERFACE_WIDTH_DWORDS = (C_DATA_WIDTH == 128) ? 11'd4 :\n                                           (C_DATA_WIDTH == 64) ? 11'd2 : 11'd1;\n\nlocalparam            IDLE      = 0;\nlocalparam            IN_PACKET = 1;\nreg                   cur_state;\nreg                   next_state;\n\nreg            [11:0] reg_pkt_len_counter;\nreg            [11:0] pkt_len_counter;\nwire           [11:0] pkt_len_counter_dec;\nwire                  pkt_done;\n\nwire           [11:0] new_pkt_len;\nwire            [9:0] payload_len;\nwire            [1:0] packet_fmt;\nwire                  packet_td;\nreg             [3:0] packet_overhead;\n\nwire [KEEP_WIDTH-1:0] eof_tkeep;\nwire                  straddle_sof;\nwire                  eof;\n\n\nassign eof = m_axis_rx_tuser[21];\ngenerate\n  if(C_DATA_WIDTH == 128) begin : sof_eof_128\n    assign straddle_sof = (m_axis_rx_tuser[14:13] == 2'b11);\n  end\n  else begin : sof_eof_64_32\n    assign straddle_sof = 1'b0;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : len_calc_128\n    assign packet_fmt  = straddle_sof ?\n                                m_axis_rx_tdata[94:93] : m_axis_rx_tdata[30:29];\n    assign packet_td   = straddle_sof ?\n                                      m_axis_rx_tdata[79] : m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ?\n         (straddle_sof ? m_axis_rx_tdata[73:64] : m_axis_rx_tdata[9:0]) : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td, straddle_sof})\n        3'b0_0_0: packet_overhead = 4'd3 + 4'd0 - 4'd4;\n        3'b0_0_1: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        3'b0_1_0: packet_overhead = 4'd3 + 4'd1 - 4'd4;\n        3'b0_1_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        3'b1_0_0: packet_overhead = 4'd4 + 4'd0 - 4'd4;\n        3'b1_0_1: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        3'b1_1_0: packet_overhead = 4'd4 + 4'd1 - 4'd4;\n        3'b1_1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else if(C_DATA_WIDTH == 64) begin : len_calc_64\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else begin : len_calc_32\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd1;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd1;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd1;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd1;\n      endcase\n    end\n  end\nendgenerate\n\nassign new_pkt_len =\n         {{9{packet_overhead[3]}}, packet_overhead[2:0]} + {2'b0, payload_len};\n\n\nassign pkt_len_counter_dec = reg_pkt_len_counter - INTERFACE_WIDTH_DWORDS;\nassign pkt_done = (reg_pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\n\nalways @(*) begin\n  case (cur_state)\n\n    IDLE: begin\n      if(m_axis_rx_tvalid && m_axis_rx_tready && !eof) begin\n        next_state = IN_PACKET;\n      end\n      else begin\n        next_state = IDLE;\n      end\n\n      pkt_len_counter = new_pkt_len;\n    end\n\n    IN_PACKET: begin\n      if((C_DATA_WIDTH == 128) && straddle_sof && m_axis_rx_tvalid) begin\n        pkt_len_counter = new_pkt_len;\n        next_state = IN_PACKET;\n      end\n\n      else if(m_axis_rx_tready && pkt_done)\n      begin\n        pkt_len_counter = new_pkt_len;\n        next_state      = IDLE;\n      end\n\n      else begin\n        if(m_axis_rx_tready) begin\n          pkt_len_counter = pkt_len_counter_dec;\n        end\n        else begin\n          pkt_len_counter = reg_pkt_len_counter;\n        end\n\n        next_state = IN_PACKET;\n      end\n    end\n\n    default: begin\n      pkt_len_counter = reg_pkt_len_counter;\n      next_state      = IDLE;\n    end\n  endcase\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    cur_state           <= #TCQ IDLE;\n    reg_pkt_len_counter <= #TCQ 12'h0;\n  end\n  else begin\n    cur_state           <= #TCQ next_state;\n    reg_pkt_len_counter <= #TCQ pkt_len_counter;\n  end\nend\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : strb_calc_128\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        10'd3:   null_is_eof = 5'b11011;\n        10'd4:   null_is_eof = 5'b11111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = {KEEP_WIDTH{1'b0}};\n  end\n  else if(C_DATA_WIDTH == 64) begin : strb_calc_64\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = { ((pkt_len_counter == 12'd2) ? 4'hF:4'h0), 4'hF };\n  end\n  else begin : strb_calc_32\n    always @(*) begin\n      if(pkt_len_counter == 12'd1) begin\n        null_is_eof = 5'b10011;\n      end\n      else begin\n        null_is_eof = 5'b00011;\n      end\n    end\n\n    assign eof_tkeep = 4'hF;\n  end\nendgenerate\n\n\nassign null_rx_tvalid = 1'b1;\nassign null_rx_tlast  = (pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\nassign null_rx_tkeep  = null_rx_tlast ? eof_tkeep : {KEEP_WIDTH{1'b1}};\nassign null_rdst_rdy  = null_rx_tlast;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_ef4b8cb7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder (A, B, Cin, S, Cout);\n\n  input [3:0] A, B;\n  input Cin;\n  output [3:0] S;\n  output Cout;\n  \n  wire [3:0] C;\n  \n  // Instantiate full-adder modules\n  full_adder FA0(.A(A[0]), .B(B[0]), .Cin(Cin), .S(S[0]), .Cout(C[0]));\n  full_adder FA1(.A(A[1]), .B(B[1]), .Cin(C[0]), .S(S[1]), .Cout(C[1]));\n  full_adder FA2(.A(A[2]), .B(B[2]), .Cin(C[1]), .S(S[2]), .Cout(C[2]));\n  full_adder FA3(.A(A[3]), .B(B[3]), .Cin(C[2]), .S(S[3]), .Cout(Cout));\n  \nendmodule\n\nmodule full_adder (A, B, Cin, S, Cout);\n\n  input A, B, Cin;\n  output S, Cout;\n  \n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (Cin & (A ^ B));\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM #_64da639d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  input clk,\n  output reg [m-1:0] out\n);\n\nparameter s = 8; // number of states\n\nreg [s-1:0] state; // current state\nreg [s-1:0] next_state; // next state\nreg [m-1:0] output_reg; // output register\n\n// transition table\nfunction [s-1:0] transition_table;\n  input [n-1:0] input_signals;\n  begin\n    case (input_signals)\n      4'b0000: transition_table = 3'b000;\n      4'b0001: transition_table = 3'b001;\n      4'b0010: transition_table = 3'b010;\n      4'b0011: transition_table = 3'b011;\n      4'b0100: transition_table = 3'b100;\n      4'b0101: transition_table = 3'b101;\n      4'b0110: transition_table = 3'b110;\n      4'b0111: transition_table = 3'b111;\n      4'b1000: transition_table = 3'b000;\n      4'b1001: transition_table = 3'b001;\n      4'b1010: transition_table = 3'b010;\n      4'b1011: transition_table = 3'b011;\n      4'b1100: transition_table = 3'b100;\n      4'b1101: transition_table = 3'b101;\n      4'b1110: transition_table = 3'b110;\n      4'b1111: transition_table = 3'b111;\n    endcase\n  end\nendfunction\n\n// output table\nfunction [m-1:0] output_table;\n  input [n-1:0] input_signals;\n  begin\n    case (input_signals)\n      4'b0000: output_table = 2'b00;\n      4'b0001: output_table = 2'b01;\n      4'b0010: output_table = 2'b10;\n      4'b0011: output_table = 2'b11;\n      4'b0100: output_table = 2'b00;\n      4'b0101: output_table = 2'b01;\n      4'b0110: output_table = 2'b10;\n      4'b0111: output_table = 2'b11;\n      4'b1000: output_table = 2'b00;\n      4'b1001: output_table = 2'b01;\n      4'b1010: output_table = 2'b10;\n      4'b1011: output_table = 2'b11;\n      4'b1100: output_table = 2'b00;\n      4'b1101: output_table = 2'b01;\n      4'b1110: output_table = 2'b10;\n      4'b1111: output_table = 2'b11;\n    endcase\n  end\nendfunction\n\n// compute next state and output\nalways @(*) begin\n  next_state = transition_table(in);\n  output_reg = output_table(in);\nend\n\n// assign output and update state\nalways @(posedge clk) begin\n  state <= next_state;\n  out <= output_reg;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt51_lfo_lfsr #_838b6ae0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule jt51_lfo_lfsr #(parameter init=220 )(\n\tinput\trst,\n\tinput\tclk,\n\tinput\tbase,\n\toutput\tout\n);\n\nreg [18:0] bb;\nassign out = bb[18];\n\nreg last_base;\n\nalways @(posedge clk) begin : base_counter\n\tif( rst ) begin\n\t\tbb\t\t\t<= init[18:0];\n\t\tlast_base \t<= 1'b0;\n\tend\n\telse begin\n\t\tlast_base <= base;\n\t\tif( last_base != base ) begin\t\n\t\t\tbb[18:1] \t<= bb[17:0];\n\t\t\tbb[0]\t\t<= ^{bb[0],bb[1],bb[14],bb[15],bb[17],bb[18]};\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sequencDetector_9ca72116", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sequencDetector(\n    input in,\n    input reset,\n    input clock,\n    output reg out\n    );\n\nreg [2:0] state;\nparameter s0 = 3'b000, s1 = 3'b001, s2 = 3'b010, s3 = 3'b011, s4 = 3'b100, s5 = 3'b101;\n\nalways @(posedge clock)\nbegin\n\t if (reset)\n    begin\n      state <= s0;\n      out  <= 0 ;\n    end\n  else\n      case(state)\n              s0 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s0; out <= 0 ; end\n              s1 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s2; out <= 0 ; end\n              s2 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s3; out <= 0 ; end\n              s3 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s4; out <= 0 ; end\n              s4 : if (in)  begin state <= s5; out <= 1 ; end\n                    else    begin state <= s0; out <= 0 ; end\n              s5 : if (in)  begin state <= s1; out <= 0 ; end\n                    else    begin state <= s2; out <= 0 ; end\n        default:   if (in)  begin state <= s0; out <= 0 ; end\n                    else    begin state <= s0; out <= 0 ; end\n      endcase\n\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "custom__05066fc5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule custom_module (\n    A1,\n    A2,\n    A3,\n    A4,\n    B1,\n    X\n);\n\n    input A1;\n    input A2;\n    input A3;\n    input A4;\n    input B1;\n    output X;\n\n    wire X1;\n    wire X2;\n\n    and (X1, A1, A2);\n    and (X2, A3, A4);\n    nor (X, X1, X2, B1);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_search_2f4f2f14", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_search (\n    input [15:0] array, // Assuming 8 2-bit elements packed into a 16-bit vector\n    input [1:0] search_key, // Adjusting search_key width to match array element width\n    output reg [2:0] index // 3 bits wide to represent indexes 0-7 or an invalid index\n);\n\n    parameter N = 8; // Number of array elements\n\n    integer i;\n    reg found;\n\n    always @(*) begin\n        index = N; // Initializing index to invalid value\n        found = 0;\n        for (i = 0; i < N; i = i + 1) begin \n            if (array[(i*2)+:2] == search_key) begin // Slicing array to match 2-bit elements\n                index = i;\n                found = 1;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_cc474c08", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n   // Inputs\n   clk,\n   // Outputs\n   count\n   );\n\n   input clk;\n   output reg [9:0] count;\n\n   always @ (posedge clk) begin\n      if (count == 999) begin\n         count <= 0;\n      end\n      else begin\n         count <= count + 1;\n      end\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reverse_parity_d4b3491d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule reverse_parity (\n  input [2:0] in_vec,\n  output [3:0] out_vec,\n  output even_parity\n);\n\n  assign out_vec = {in_vec[2], in_vec[1], in_vec[0], ~^in_vec};\n  assign even_parity = (^in_vec);\n\nendmodule\n\nmodule shift_register (\n  input clk,\n  input reset,\n  input load,\n  input [2:0] load_data,\n  output serial_out\n);\n\n  reg [2:0] reg_data;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      reg_data <= 3'b0;\n    end else if (load) begin\n      reg_data <= load_data;\n    end else begin\n      reg_data <= {reg_data[1:0], 1'b0};\n    end\n  end\n\n  assign serial_out = reg_data[0];\n\nendmodule\n\nmodule top_module (\n  input clk,\n  input reset,\n  input [3:0] in_vec,\n  input select,\n  input load,\n  input [2:0] load_data,\n  output [3:0] out_vec,\n  output even_parity,\n  output serial_out\n);\n\n  wire [3:0] reverse_out_vec;\n  wire reverse_even_parity;\n  wire shift_serial_out;\n\n  reverse_parity reverse_parity_inst (\n    .in_vec(in_vec[2:0]),\n    .out_vec(reverse_out_vec),\n    .even_parity(reverse_even_parity)\n  );\n\n  shift_register shift_register_inst (\n    .clk(clk),\n    .reset(reset),\n    .load(load),\n    .load_data(load_data),\n    .serial_out(shift_serial_out)\n  );\n\n  assign out_vec = select ? reverse_out_vec : 4'b0;\n  assign even_parity = select ? reverse_even_parity : (^in_vec);\n  assign serial_out = select ? 1'b0 : shift_serial_out;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_306e11f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter(\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end else begin\n        if (count == 15) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__ca914fc5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input  [31:0] a,\n    input  [31:0] b,\n    input         select, //Select input to choose between adder and multiplexer\n    output [31:0] sum\n); \n\nwire [31:0] adder_out;\nwire  mux_out;\n\nadder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(adder_out)\n);\n\nmux mux_inst (\n    .a(a),\n    .b(b),\n    .c(select),\n    .w(mux_out)\n);\n\nassign sum = (select == 1'b1) ? adder_out : {31'b0, mux_out};\n\nendmodule\nmodule adder (\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum\n);\n\ngenvar i;\n\ngenerate\n    for (i = 0; i < 32; i = i + 1) begin : adder_loop\n        full_adder full_adder_inst (\n            .a(a[i]),\n            .b(b[i]),\n            .cin(0), //Assuming there is no carry in\n            .sum(sum[i])\n        );\n    end\nendgenerate\n\nendmodule\nmodule mux (\n    input [31:0] a,\n    input [31:0] b,\n    input c,\n    output w\n);\n\nassign w = c ? b[0] : a[0];\n\nendmodule\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "transition_detector_a32e6074", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg out\n);\n\nreg [31:0] in_reg;\nreg [31:0] in_reg_prev;\nreg [31:0] in_xor;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        in_reg <= 0;\n        in_reg_prev <= 0;\n        in_xor <= 0;\n        out <= 0;\n    end else begin\n        in_reg <= in;\n        in_reg_prev <= in_reg;\n        in_xor <= in_reg ^ in_reg_prev;\n        if (in_xor != 0) begin\n            out <= 1;\n        end\n    end\nend\n\nendmodule\n\nmodule bitwise_operations (\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and,\n    output [2:0] out_xor,\n    output [2:0] out_nor,\n    output reg [2:0] a_not,\n    output reg [2:0] b_not\n);\n\nassign out_and = a & b;\nassign out_xor = a ^ b;\nassign out_nor = ~(a | b);\n\nalways @* begin\n    a_not = ~a;\n    b_not = ~b;\nend\n\nendmodule\n\nmodule functional_module (\n    input clk,\n    input reset,\n    input transition_detect,\n    input [2:0] bitwise_and,\n    output reg [2:0] out_and\n);\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        out_and <= 0;\n    end else begin\n        if (transition_detect == 1) begin\n            out_and <= bitwise_and;\n        end\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and_bitwise,\n    output [5:0] out_not\n);\n\nwire transition_detect;\nwire [2:0] bitwise_and;\nwire [2:0] bitwise_xor;\nwire [2:0] bitwise_nor;\nwire [2:0] a_not;\nwire [2:0] b_not;\n\ntransition_detector td(clk, reset, in, transition_detect);\nbitwise_operations bo(a, b, bitwise_and, bitwise_xor, bitwise_nor, a_not, b_not);\nfunctional_module fm(clk, reset, transition_detect, bitwise_and, out_and_bitwise);\n\nassign out_not = {b_not, a_not};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_c063c40a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate (\n  input CLK, EN, TE,\n  input [31:0] W,\n  output reg ENCLK,\n  output reg [31:0] Y\n);\n\n  always @ (posedge CLK) begin\n    if (TE) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= EN ? CLK : 1'b0;\n    end\n  end\n\n  always @ (posedge ENCLK) begin\n    Y <= W;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_4to16_1b78253a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_4to16 (\n    input [3:0] in,\n    output [15:0] out\n);\n\nassign out[0] = ~(in[3] | in[2] | in[1] | in[0]);\nassign out[1] = ~(in[3] | in[2] | in[1] | ~in[0]);\nassign out[2] = ~(in[3] | in[2] | ~in[1] | in[0]);\nassign out[3] = ~(in[3] | in[2] | ~in[1] | ~in[0]);\nassign out[4] = ~(in[3] | ~in[2] | in[1] | in[0]);\nassign out[5] = ~(in[3] | ~in[2] | in[1] | ~in[0]);\nassign out[6] = ~(in[3] | ~in[2] | ~in[1] | in[0]);\nassign out[7] = ~(in[3] | ~in[2] | ~in[1] | ~in[0]);\nassign out[8] = ~(~in[3] | in[2] | in[1] | in[0]);\nassign out[9] = ~(~in[3] | in[2] | in[1] | ~in[0]);\nassign out[10] = ~(~in[3] | in[2] | ~in[1] | in[0]);\nassign out[11] = ~(~in[3] | in[2] | ~in[1] | ~in[0]);\nassign out[12] = ~(~in[3] | ~in[2] | in[1] | in[0]);\nassign out[13] = ~(~in[3] | ~in[2] | in[1] | ~in[0]);\nassign out[14] = ~(~in[3] | ~in[2] | ~in[1] | in[0]);\nassign out[15] = ~(~in[3] | ~in[2] | ~in[1] | ~in[0]);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ERROR_OUTPUT_LOGIC #_4dd9229e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ERROR_OUTPUT_LOGIC #(\n    parameter [7:0] DATA_WIDTH = 1,\n    parameter [7:0] ADDR_WIDTH = 6\n) (\n    input rst,\n    input clk,\n\n    input loop_complete,\n    input error_detected,\n    input [7:0] error_state,\n    input [ADDR_WIDTH-1:0] error_address,\n    input [DATA_WIDTH-1:0] expected_data,\n    input [DATA_WIDTH-1:0] actual_data,\n\n    input tx_data_accepted,\n    output reg tx_data_ready,\n    output reg [7:0] tx_data\n);\n    reg reg_error_detected;\n    reg [7:0] reg_error_state;\n    reg [ADDR_WIDTH-1:0] reg_error_address;\n    reg [DATA_WIDTH-1:0] reg_expected_data;\n    reg [DATA_WIDTH-1:0] reg_actual_data;\n\n    reg [7:0] error_count;\n    reg [7:0] output_shift;\n\n    wire [7:0] next_output_shift = output_shift + 8;\n    wire count_shift_done = next_output_shift >= 8'd16;\n    wire address_shift_done = next_output_shift >= ADDR_WIDTH;\n    wire data_shift_done = next_output_shift >= DATA_WIDTH;\n\n    reg loop_ready;\n    reg [7:0] latched_error_count;\n\n    reg [7:0] errors;\n    reg [10:0] state;\n    reg [15:0] loop_count;\n    reg [15:0] latched_loop_count;\n\n    localparam START = (1 << 0),\n        ERROR_COUNT_HEADER = (1 << 1),\n        ERROR_COUNT_COUNT = (1 << 2),\n        CR = (1 << 3),\n        LF = (1 << 4),\n        ERROR_HEADER = (1 << 5),\n        ERROR_STATE = (1 << 6),\n        ERROR_ADDRESS = (1 << 7),\n        ERROR_EXPECTED_DATA = (1 << 8),\n        ERROR_ACTUAL_DATA = (1 << 9),\n        LOOP_COUNT = (1 << 10);\n\n    initial begin\n        tx_data_ready <= 1'b0;\n        tx_data <= 8'b0;\n        state <= START;\n        reg_error_detected <= 1'b0;\n    end\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state <= START;\n            error_count <= 0;\n            reg_error_detected <= 0;\n            tx_data_ready <= 0;\n            tx_data <= 8'b0;\n            loop_count <= 0;\n            loop_ready <= 0;\n        end else begin\n\n            if(error_detected) begin\n                if(error_count < 255) begin\n                    error_count <= error_count + 1;\n                end\n\n                if(!reg_error_detected) begin\n                    reg_error_detected <= 1;\n                    reg_error_state <= error_state;\n                    reg_error_address <= error_address;\n                    reg_expected_data <= expected_data;\n                    reg_actual_data <= actual_data;\n                end\n            end\n\n            if(tx_data_accepted) begin\n                tx_data_ready <= 0;\n            end\n\n            if(loop_complete) begin\n                loop_count <= loop_count + 1;\n                if(!loop_ready) begin\n                    loop_ready <= 1;\n                    latched_error_count <= error_count;\n                    latched_loop_count <= loop_count;\n                    error_count <= 0;\n                end\n            end\n\n            case(state)\n                START: begin\n                    if(reg_error_detected) begin\n                        state <= ERROR_HEADER;\n                    end else if(loop_ready) begin\n                        state <= ERROR_COUNT_HEADER;\n                    end\n                end\n                ERROR_COUNT_HEADER: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= \"L\";\n                        tx_data_ready <= 1;\n                        state <= ERROR_COUNT_COUNT;\n                    end\n                end\n                ERROR_COUNT_COUNT: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= latched_error_count;\n                        tx_data_ready <= 1;\n                        output_shift <= 0;\n                        state <= LOOP_COUNT;\n                    end\n                end\n                LOOP_COUNT: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (latched_loop_count >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(count_shift_done) begin\n                            output_shift <= 0;\n                            loop_ready <= 0;\n                            state <= CR;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                CR: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= 8'h0D; tx_data_ready <= 1;\n                        state <= LF;\n                    end\n                end\n                LF: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= 8'h0A; tx_data_ready <= 1;\n                        state <= START;\n                    end\n                end\n                ERROR_HEADER: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= \"E\";\n                        tx_data_ready <= 1;\n                        state <= ERROR_STATE;\n                    end\n                end\n                ERROR_STATE: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= reg_error_state;\n                        tx_data_ready <= 1;\n                        output_shift <= 0;\n                        state <= ERROR_ADDRESS;\n                    end\n                end\n                ERROR_ADDRESS: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_error_address >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(address_shift_done) begin\n                            output_shift <= 0;\n                            state <= ERROR_EXPECTED_DATA;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                ERROR_EXPECTED_DATA: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_expected_data >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(data_shift_done) begin\n                            output_shift <= 0;\n                            state <= ERROR_ACTUAL_DATA;\n                        end else begin\n                            output_shift <= next_output_shift;\n                        end\n                    end\n                end\n                ERROR_ACTUAL_DATA: begin\n                    if(!tx_data_ready) begin\n                        tx_data <= (reg_actual_data >> output_shift);\n                        tx_data_ready <= 1;\n\n                        if(data_shift_done) begin\n                            state <= CR;\n                            reg_error_detected <= 0;\n                        end else begin\n                            output_shift <= output_shift + 8;\n                        end\n                    end\n                end\n                default: begin\n                    state <= START;\n                end\n            endcase\n        end\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_operations_df4aa65b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_operations (\n  input [31:0] a,\n  input [31:0] b,\n  input [1:0] operation_select,\n  input [4:0] shift_amount,\n  output reg [31:0] result\n);\n\n  // AND operation\n  wire [31:0] and_result;\n  assign and_result = a & b;\n\n  // OR operation\n  wire [31:0] or_result;\n  assign or_result = a | b;\n\n  // XOR operation\n  wire [31:0] xor_result;\n  assign xor_result = a ^ b;\n\n  // Shift-left operation\n  wire [31:0] shift_result;\n  assign shift_result = a << shift_amount;\n\n  // Select operation based on operation_select input\n  always @* begin\n    case (operation_select)\n      2'b00: result = and_result;\n      2'b01: result = or_result;\n      2'b10: result = xor_result;\n      2'b11: result = shift_result;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_f899f224", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module(\n    input clk,\n    input areset,   // async active-high reset to zero\n    input [7:0] d,\n    input sel,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [7:0] q\n);\n\n    // First module with 8 D flip-flops triggered by negative edge of clk\n    reg [7:0] dff_q;\n    always @(negedge clk or posedge areset) begin\n        if (areset) begin\n            dff_q <= 8'b0;\n        end else begin\n            dff_q <= {dff_q[3:0], dff_q[7:4]};\n        end\n    end\n    \n    // Multiplexer to select output of first 4 DFFs or last 4 DFFs based on select input\n    wire [3:0] first_half = dff_q[3:0];\n    wire [3:0] second_half = dff_q[7:4];\n    wire [3:0] mux_out;\n    assign mux_out = (sel == 1'b0) ? first_half : second_half;\n    \n    // Second module with 4-bit shift register with asynchronous reset, synchronous load, and enable\n    reg [3:0] shift_reg;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            shift_reg <= 4'b0;\n        end else if (load) begin\n            shift_reg <= data;\n        end else if (ena) begin\n            shift_reg <= {1'b0, shift_reg[3:1]};\n        end\n    end\n    \n    // XOR module to combine outputs of the two given modules\n    wire [7:0] xor_out;\n    assign xor_out = shift_reg ^ mux_out;\n    \n    // Output of the top module\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 8'b0;\n        end else begin\n            q <= xor_out;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gci_std_display_device_special_memory_6912b225", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gci_std_display_device_special_memory\n\t#(\n\t\tparameter USEMEMSIZE = 32'h00000000,\n\t\tparameter PRIORITY = 32'h00000000,\n\t\tparameter DEVICECAT = 32'h00000000\n\t)(\t\t\t\t\t\t\t\n\t\t//System\n\t\tinput wire iCLOCK,\n\t\tinput wire inRESET,\n\t\t//Special Addr Access\n\t\tinput wire iSPECIAL_REQ,\n\t\tinput wire iSPECIAL_RW,\n\t\tinput wire [7:0] iSPECIAL_ADDR,\n\t\tinput wire [31:0] iSPECIAL_DATA,\n\t\toutput wire [31:0] oSPECIAL_DATA\n\t);\n\t\n\tinteger\ti;\n\t\n\treg [31:0] b_mem[0:255];\t\n\talways@(posedge iCLOCK or negedge inRESET)begin\n\t\tif(!inRESET)begin\n\t\t\tfor(i = 0; i < 256; i = i + 1)begin\n\t\t\t\tif(i == 0)begin\n\t\t\t\t\t//USEMEMSIZE\n\t\t\t\t\tb_mem[i] <= USEMEMSIZE;\n\t\t\t\tend\n\t\t\t\telse if(i == 1)begin\n\t\t\t\t\t//PRIORITY\n\t\t\t\t\tb_mem[i] <= PRIORITY;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\t//Other\n\t\t\t\t\tb_mem[i] <= 32'h00000000;\n\t\t\t\tend\n\t\t\tend\t\t\n\t\tend\n\t\telse begin\n\t\t\tif(iSPECIAL_REQ && iSPECIAL_RW)begin\n\t\t\t\tb_mem [iSPECIAL_ADDR] <= iSPECIAL_DATA;\n\t\t\tend\t\n\t\tend\n\tend //always\n\t\n\tassign oSPECIAL_DATA = b_mem[iSPECIAL_ADDR];\n\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "traffic_light_controller_b7924223", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule traffic_light_controller (\n  input clk,\n  input reset,\n  output reg green,\n  output reg yellow,\n  output reg red\n);\n\n  // define the states\n  localparam [1:0] GREEN = 2'b00;\n  localparam [1:0] YELLOW = 2'b01;\n  localparam [1:0] RED = 2'b10;\n  \n  // define the state register and initialize to GREEN\n  reg [1:0] state_reg = GREEN;\n  \n  // define the counter for each state\n  reg [3:0] green_counter = 4'd0;\n  reg [3:0] yellow_counter = 4'd0;\n  reg [3:0] red_counter = 4'd0;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state_reg <= GREEN;\n      green_counter <= 4'd0;\n      yellow_counter <= 4'd0;\n      red_counter <= 4'd0;\n      green <= 1'b1;\n      yellow <= 1'b0;\n      red <= 1'b0;\n    end\n    else begin\n      case (state_reg)\n        GREEN: begin\n          green_counter <= green_counter + 1;\n          if (green_counter == 4'd9) begin\n            state_reg <= YELLOW;\n            green_counter <= 4'd0;\n            yellow <= 1'b1;\n            green <= 1'b0;\n          end\n        end\n        YELLOW: begin\n          yellow_counter <= yellow_counter + 1;\n          if (yellow_counter == 4'd1) begin\n            state_reg <= RED;\n            yellow_counter <= 4'd0;\n            red <= 1'b1;\n            yellow <= 1'b0;\n          end\n        end\n        RED: begin\n          red_counter <= red_counter + 1;\n          if (red_counter == 4'd7) begin\n            state_reg <= GREEN;\n            red_counter <= 4'd0;\n            green <= 1'b1;\n            red <= 1'b0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_c7384320", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input up_down,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else if (up_down) begin\n            q <= q + 1;\n        end else begin\n            q <= q - 1;\n        end\n    end\nendmodule\n\nmodule left_rotator (\n    input [3:0] D,\n    output reg [3:0] q\n);\n    always @* begin\n        q[0] = D[1];\n        q[1] = D[2];\n        q[2] = D[3];\n        q[3] = D[0];\n    end\nendmodule\n\nmodule functional_module (\n    input [7:0] up_down_out,\n    input [3:0] left_rotator_out,\n    input select,\n    output reg [7:0] q\n);\n    always @* begin\n        if (select) begin\n            q <= up_down_out;\n        end else begin\n            q <= {left_rotator_out, 4'b0};\n        end\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input up_down,\n    input [3:0] D,\n    input select,\n    output [7:0] q\n);\n    wire [7:0] up_down_out;\n    wire [3:0] left_rotator_out;\n\n    up_down_counter udc (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .q(up_down_out)\n    );\n\n    left_rotator lr (\n        .D(D),\n        .q(left_rotator_out)\n    );\n\n    functional_module fm (\n        .up_down_out(up_down_out),\n        .left_rotator_out(left_rotator_out),\n        .select(select),\n        .q(q)\n    );\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "div_module_45d0fa33", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule div_module(\n  input clk,\n  input reset,\n  input [7:0] in1,\n  input [7:0] in2,\n  output [15:0] out,\n  output [7:0] remainder\n);\n\n  reg [15:0] quotient_reg;\n  reg [7:0] remainder_reg;\n  reg [7:0] in2_reg;\n  reg [7:0] count_reg;\n  wire [7:0] in1_reg;\n\n  assign in1_reg = (count_reg == 0) ? in1 : quotient_reg[7:0];\n  assign out = quotient_reg;\n  assign remainder = remainder_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      quotient_reg <= 16'd0;\n      remainder_reg <= 8'd0;\n      in2_reg <= 8'd0;\n      count_reg <= 8'd0;\n    end else begin\n      if (count_reg == 0) begin\n        in2_reg <= in2;\n        quotient_reg[15:8] <= in1;\n        quotient_reg[7:0] <= 8'd0;\n        remainder_reg <= 8'd0;\n      end else begin\n        {quotient_reg[15:1], quotient_reg[0]} <= {quotient_reg[14:0], in1_reg[7]};\n        remainder_reg <= {remainder_reg[6:0], in1_reg[7]} - in2_reg;\n      end\n      count_reg <= count_reg + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_nor_gate_f0b53823", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pipelined_nor_gate(\n    input a,\n    input b,\n    output out\n);\n\nreg pipe1, pipe2;\n\nalways @(a or b) begin\n    pipe1 <= ~(a & b);\nend\n\nalways @(pipe1) begin\n    pipe2 <= ~pipe1;\nend\n\nassign out = pipe2;\n\nendmodule\n\nmodule top_module(\n    input a,\n    input b,\n    output out\n);\n\nwire pipe1, pipe2;\npipelined_nor_gate g1(a, b, pipe1);\npipelined_nor_gate g2(pipe1, pipe1, pipe2);\npipelined_nor_gate g3(pipe2, pipe2, out);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_async_reset_set_52a0aeba", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule d_ff_async_reset_set (\n  input CLK,\n  input D,\n  input Reset,\n  input Set,\n  output reg Q\n);\n\n  wire next_q, q_next_r, q_next_s;\n\n  assign q_next_s = Set;\n  assign q_next_r = Reset;\n  assign next_q = (q_next_s | (~q_next_r & ~q_next_s & D)) ^ Q;\n\n  always @(posedge CLK)\n    Q <= next_q;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_d3afccb2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else if (count == 4'b1111) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bit_reversal_43fea43d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define size ((DATA_SIZE/4) * (2 ** (type - 1)))\n\nmodule bit_reversal\n#(\n\tparameter DATA_SIZE = 32\n)\n(\n\toutput [DATA_SIZE - 1 : 0] data_out,\n\tinput  [DATA_SIZE - 1 : 0] data_in,\n\tinput  [1 : 0] rev_type\n);\n\n\nlocalparam NO_REVERSE = 2'b00; \nlocalparam BYTE       = 2'b01;\nlocalparam HALF_WORD  = 2'b10;\nlocalparam WORD       = 2'b11;\n\nlocalparam TYPES = 4;\n\nwire [DATA_SIZE - 1 : 0] data_reversed[0 : 3];\n\n\nassign data_reversed[NO_REVERSE] = data_in; generate\n\tgenvar i, type;\n\tfor(type = 1 ; type < TYPES; type = type + 1)\n\t\tfor(i = 0; i < DATA_SIZE; i = i + 1)\n\t\t\tbegin\n\t\t\t\tif(i < `size)\n\t\t\t\t\tassign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - i];\n\t\t\t\telse\n\t\t\t\t\tassign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - (i%(`size*(i/`size)))];\n\t\t\tend\nendgenerate\n\nassign data_out = data_reversed[rev_type];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bin2gray_eaaab218", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bin2gray(\n  input [3:0] binary,\n  output [3:0] gray\n);\n\n  assign gray[3] = binary[3];\n  assign gray[2] = binary[3] ^ binary[2];\n  assign gray[1] = binary[2] ^ binary[1];\n  assign gray[0] = binary[1] ^ binary[0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spi_2dda26f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule spi(\n\n\tclock, sck,   sdo,   sdi,   bsync, start, halfspeed, din,  dout  );\n\n\tinput clock;\n\n\n\toutput sck;\n\twire   sck;\n\n\toutput sdo;\n\n\tinput sdi;\n\n\toutput reg bsync;\n\n\tinput start;\n\n\tinput halfspeed;\n\n\tinput [7:0] din;\n\n\toutput reg [7:0] dout;\n\n\n\n\treg [4:0] counter; wire enable_n; reg [6:0] shiftin; reg [7:0] shiftout; wire ena_shout_load; reg g_ena;\n\n\n\tinitial begin\n\t\tcounter = 5'b10000;\n\t\tshiftout = 8'd0;\n\t\tshiftout = 7'd0;\n\t\tbsync = 1'd0;\n\t\tdout <= 1'b0;\n\tend\n\n\n\n\n\tassign sck = counter[0];\n\n\tassign enable_n = counter[4];\n\n\tassign sdo = shiftout[7];\n\n\tassign ena_shout_load = (start | sck) & g_ena;\n\n\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( g_ena )\n\t\tbegin\n\t\t\tif( start )\n\t\t\tbegin\n\t\t\t\tcounter <= 5'b00000; bsync <= 1'b1; end\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif( !sck ) begin\n      \t                  shiftin[6:0] <= { shiftin[5:0], sdi };\n\n\t\t\t\t\tif( (&counter[3:1]) && (!enable_n) )\n\t\t\t\t\t\tdout <= { shiftin[6:0], sdi }; end\n\t\t\t\telse begin\n\t\t\t\t\tbsync <= 1'b0;\n\t\t\t\tend\n\n\t\t\t\tif( !enable_n )\n\t\t\t\t\tcounter <= counter + 5'd1;\n\t\t\tend\n\t\tend\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( ena_shout_load )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\tshiftout <= din;\n\t\t\telse shiftout[7:0] <= { shiftout[6:0], shiftout[0] }; end\n\tend\n\n\n\talways @(posedge clock)\n\tbegin\n\t\tif( halfspeed )\n\t\tbegin\n\t\t\tif( start )\n\t\t\t\tg_ena <= 1'b0;\n\t\t\telse if( enable_n )\n\t\t\t\tg_ena <= 1'b1;\n\t\t\telse\n\t\t\t\tg_ena <= ~g_ena;\n\t\tend\n\t\telse\n\t\t\tg_ena <= 1'b1;\n\tend\n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_21899280", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo (\n   // Outputs\n   out0, out1,\n   // Inputs\n   clk, wr0a, wr0b, wr1a, wr1b, inData\n);\n\n   input         clk;\n   input         wr0a;\n   input         wr0b;\n   input         wr1a;\n   input         wr1b;\n   input [15:0]  inData;\n\n   output [15:0] out0;\n   output [15:0] out1;\n\n   reg [15:0]    mem [1:0];\n\n\n   assign        out0 = mem[0];\n   assign        out1 = mem[1];\n\n   always @(posedge clk) begin\n      // These mem assignments must be done in order after processing\n      if (wr0a) begin\n         mem[0] <=  inData;\n      end\n      if (wr0b) begin\n         mem[0] <= ~inData;\n      end\n      if (wr1a) begin\n         mem[1] <=  inData;\n      end\n      if (wr1b) begin\n         mem[1] <= ~inData;\n      end\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "power_check_efde2a94", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule power_check (\n    input  VPWR,\n    input  VGND,\n    input  VPB,\n    input  VNB,\n    output reg power_ok\n);\n\n    wire w_power_ok;\n\n    assign w_power_ok = (VPWR && VPB);\n    always @(*) begin\n        power_ok <= w_power_ok;\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplexer_AC__parameterized33_b80dc38d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Multiplexer_AC__parameterized33\n   (ctrl,\n    D0,\n    D1,\n    D2,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  input [0:0]D2;\n  output [0:0]S;\n\n  wire [0:0]S;\n  wire [2:0]sel;\n\n  assign sel = {ctrl, ctrl};\n\n  assign S = (sel == 3'b000) ? D0 : \n             (sel == 3'b001) ? D1 : \n             (sel == 3'b010) ? D2 : 0;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "addition_module_640184ad", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule addition_module(\n\tinput [7:0] A,\n\tinput [7:0] B,\n\tinput reset,\n\tinput clk,\n\toutput reg [15:0] C\n);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tC <= 16'b0;\n\t\tend else begin\n\t\t\tC <= A + B;\n\t\tend\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__45ae4e64", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    input A, B,\n    output reg [15:0] Y\n);\n\nreg [2:0] shift_reg;\nreg [15:0] decoder_out;\n\nalways @(posedge clk) begin\n    if (control == 1'b0) begin\n        // Shift right\n        shift_reg <= {shift_reg[0], shift_reg[2:1]};\n    end else begin\n        // Shift left\n        shift_reg <= {shift_reg[2:0], shift_reg[1]};\n    end\n\n    if (shift == 1'b1) begin\n        // Shift in parallel_load value\n        shift_reg <= parallel_load;\n    end\n\n    decoder_out <= 16'b0;\n    case ({A, B})\n        2'b00: decoder_out[shift_reg] <= 1'b1;\n        2'b01: decoder_out[shift_reg >> 1] <= 1'b1;\n        2'b10: decoder_out[shift_reg >> 2] <= 1'b1;\n        2'b11: decoder_out[shift_reg >> 3] <= 1'b1;\n    endcase\n\n    Y <= decoder_out;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "stratixii_lvds_rx_deser #_992a3c88", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule stratixii_lvds_rx_deser #(\n    parameter channel_width = 10\n)(\n    input clk,\n    input datain,\n    input devclrn,\n    input devpor,\n    output [channel_width-1:0] dataout\n);\n\n\nreg [channel_width-1:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (devclrn || devpor) begin\n        shift_reg <= 0;\n    end else begin\n        shift_reg <= {shift_reg[channel_width-2:0], datain};\n    end\nend\n\nassign dataout = shift_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand4bb_b64f116a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand4bb (\n    input  A_N,\n    input  B_N,\n    input  C  ,\n    input  D  ,\n    output Y\n);\n\n    assign Y = ~(A_N & B_N & C & D);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__and3_b29e1836", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__and3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, C, A, B        );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "VCO_interface_34ab74f8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule VCO_interface (\n  input in,\n  input [7:0] vctrl,\n  output reg out\n);\n\nparameter fmin = 1; // minimum frequency of the VCO\nparameter fmax = 1000; // maximum frequency of the VCO\nparameter vmin = 0; // minimum voltage of the VCO\nparameter vmax = 255; // maximum voltage of the VCO\n\nreg [31:0] count;\nreg [31:0] freq;\n\nalways @ (posedge in) begin\n  count <= count + 1;\n  if (count >= freq) begin\n    out <= ~out;\n    count <= 0;\n  end\nend\n\nalways @ (vctrl) begin\n  freq <= (vctrl - vmin) * (fmax - fmin) / (vmax - vmin) + fmin;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "TDC_e10d6804", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule TDC (\n  input clk,\n  input in1,\n  input in2,\n  output reg [15:0] out\n);\n\nparameter resolution = 1; // resolution of the TDC in picoseconds\n\nreg in1_prev, in2_prev;\nreg [15:0] count;\n\nalways @(posedge clk) begin\n  if (in1 && !in1_prev) begin\n    count <= 0;\n  end else if (in2 && !in2_prev) begin\n    out <= count * resolution;\n  end else begin\n    count <= count + 1;\n  end\n  in1_prev <= in1;\n  in2_prev <= in2;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hs__o21a_079ff496", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hs__o21a (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    VPWR,\n    VGND\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n\n    assign X = (A1 & A2 & B1 & VPWR & VGND);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rc4_df95660a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rc4(\n  input clk,\n  input rst_n,\n  input control_in,\n  input write,\n  input read,\n  input [7:0] keylength,\n  input [7:0] keydata,\n  output control_out,\n  output reg [7:0] streamvalue\n);\n\nreg [7:0] state [0:255];\nreg [7:0] key [0:255];\nreg [7:0] i, j;\nreg [7:0] keystream [0:255];\nreg [7:0] plaintext [0:255];\nreg [7:0] ciphertext [0:255];\nreg [7:0] count;\nreg [7:0] temp;\n\nassign control_out = count == keylength;\n\nalways @(posedge clk) begin\n  if (!rst_n) begin\n    i <= 0;\n    j <= 0;\n    count <= 0;\n    streamvalue <= 0;\n  end else begin\n    if (write) begin\n      key[count] <= keydata;\n      count <= count + 1;\n    end\n    if (control_in) begin\n      if (count == keylength) begin\n        for (i = 0; i < 256; i = i + 1) begin\n          state[i] <= i;\n          keystream[i] <= 0;\n        end\n        j <= 0;\n        for (i = 0; i < 256; i = i + 1) begin\n          j <= (j + state[i] + key[i % keylength]) & 255;\n          temp <= state[i];\n          state[i] <= state[j];\n          state[j] <= temp;\n        end\n        i <= 0;\n        j <= 0;\n        count <= 0;\n      end\n    end else begin\n      if (read) begin\n        streamvalue <= keystream[i] ^ plaintext[i];\n        i <= i + 1;\n      end else begin\n        plaintext[i] <= streamvalue;\n        keystream[i] <= state[i];\n        ciphertext[i] <= keystream[i] ^ plaintext[i];\n        i <= i + 1;\n        j <= (j + state[i] + key[i % keylength]) & 255;\n        temp <= state[i];\n        state[i] <= state[j];\n        state[j] <= temp;\n      end\n    end\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__84b806e5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    wire a_and;\n    wire b_not;\n\n    // AND gate to check if A1, A2, and A3 are all high\n    and gate_a(a_and, A1, A2, A3);\n\n    // NOT gate to invert B1 signal\n    not gate_b(b_not, B1);\n\n    // AND gate to combine a_and and b_not signals\n    and gate_x(X, a_and, b_not);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotator_shift_register_669bf39c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rotator_shift_register (\n    input clk,                 // Clock for the rotator\n    input load,                // Synchronous load for the rotator\n    input [1:0] ena,           // Enable for the rotator\n    input [99:0] data,         // Input data for the rotator\n    input d,                   // Serial input for the shift register\n    output reg [2:0] q         // Output from the functional module\n);\n\n    // Rotator module\n    reg [99:0] rotator_out;\n    always @(posedge clk) begin\n        if (load) rotator_out <= data;\n        else if (ena[1]) rotator_out <= {rotator_out[0], rotator_out[99:1]};\n        else if (ena[0]) rotator_out <= {rotator_out[98:0], rotator_out[99]};\n    end\n    \n    // Shift register module\n    reg [2:0] shift_reg_out;\n    reg [2:0] shift_reg_in;\n    always @(posedge clk) begin\n        shift_reg_in <= {shift_reg_in[1:0], d};\n        shift_reg_out <= {shift_reg_out[1:0], shift_reg_in[2]};\n    end\n    \n    // Functional module\n    always @* begin\n        q[0] = rotator_out[0] | shift_reg_out[0];\n        q[1] = rotator_out[50] | shift_reg_out[1];\n        q[2] = rotator_out[99] | shift_reg_out[2];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__b2347322", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    input [3:0] in,\n    input [1:0] sel,\n    input enable,\n    output [3:0] OUT\n);\n\nwire [3:0] mux_out;\nwire [3:0] shift_reg_out;\n\nmux_4to1 mux_inst (\n    .in(in),\n    .sel(sel),\n    .enable(enable),\n    .out(mux_out)\n);\n\nshift_register shift_reg_inst (\n    .CLK(CLK),\n    .RST(RST),\n    .LD(LD),\n    .D(D),\n    .Q(shift_reg_out)\n);\n\nassign OUT = mux_out & shift_reg_out;\n\nendmodule\n\nmodule mux_4to1 (\n    input [3:0] in,\n    input [1:0] sel,\n    input enable,\n    output [3:0] out\n);\n\nreg [3:0] out_reg;\n\nalways @(*) begin\n    if (enable) begin\n        case (sel)\n            2'b00: out_reg = in[0];\n            2'b01: out_reg = in[1];\n            2'b10: out_reg = in[2];\n            2'b11: out_reg = in[3];\n            default: out_reg = 4'b0;\n        endcase\n    end else begin\n        out_reg = 4'b0;\n    end\nend\n\nassign out = out_reg;\n\nendmodule\n\nmodule shift_register (\n    input CLK,\n    input RST,\n    input LD,\n    input [3:0] D,\n    output [3:0] Q\n);\n\nreg [3:0] Q_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        Q_reg <= 4'b0;\n    end else begin\n        if (LD) begin\n            Q_reg <= D;\n        end else begin\n            Q_reg <= {Q_reg[2:0], Q_reg[3]};\n        end\n    end\nend\n\nassign Q = Q_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_stack_1ec8375f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_stack\n(\n    input clk,\n    input rst,\n    input push_i,\n    input pop_i,\n    input [dw-1:0] data_i,\n    output [dw-1:0] data_o,\n    output empty_o\n);\n\nparameter dw = 8;\nparameter stack_size = 8;\n\nreg [dw-1:0] stack [0:stack_size-1];\nreg top = 0;\n\nalways @(posedge clk)\nbegin\n    if (rst)\n        top <= 0;\n    else if (push_i && (top < stack_size))\n    begin\n        stack[top] <= data_i;\n        top <= top + 1;\n    end\n    else if (pop_i && (top > 0))\n        top <= top - 1;\nend\n\nassign data_o = (top > 0) ? stack[top-1] : 0;\nassign empty_o = (top == 0);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "acl_fp_custom_add_op_1be634a7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule acl_fp_custom_add_op(\tclock, resetn, left_mantissa, right_mantissa, left_sign, right_sign, common_exponent,\n\t\t\t\t\t\t\t\t\t\tresulting_mantissa, resulting_exponent, resulting_sign,\n\t\t\t\t\t\t\t\t\t\tvalid_in, valid_out, stall_in, stall_out, enable);\n\n\tparameter HIGH_CAPACITY = 1;\n\t\n\tinput clock, resetn, left_sign, right_sign;\n\tinput [26:0] left_mantissa;\n\tinput [26:0] right_mantissa;\n\tinput [8:0] common_exponent;\n\tinput valid_in, stall_in, enable;\n\t output reg [27:0] resulting_mantissa;\n\t output reg [8:0] resulting_exponent;\n\t output reg resulting_sign;\n\t output reg valid_out;\n\toutput stall_out;\n\t\n\twire enable_add = (HIGH_CAPACITY==1) ? (~valid_out | ~stall_in) : enable;\n\twire do_subtraction = right_sign ^ left_sign;\n\tassign stall_out = valid_out & stall_in;\n\twire [27:0] op_ab = left_mantissa + ({28{do_subtraction}} ^ right_mantissa) + do_subtraction;\n\t\n\talways@(posedge clock or negedge resetn)\n\tbegin\n\t\tif (~resetn)\n\t\tbegin\n\t\t\tresulting_mantissa <= 28'bxxxxxxxxxxxxxxxxxxxxxxxxxxxx;\n\t\t\tresulting_exponent <= 9'bxxxxxxxx;\n\t\t\tresulting_sign <= 1'bx;\n\t\t\tvalid_out <= 1'b0;\n\t\tend\n\t\telse if (enable_add)\n\t\tbegin\n\t\t\tvalid_out <= valid_in;\n\t\t\tresulting_mantissa <= op_ab;\n\t\t\tresulting_exponent <= common_exponent;\n\t\t\tresulting_sign <= left_sign;\n\t\tend\n\tend\n\t\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__iso1p_ec7ba452", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__iso1p (\n    X    ,\n    A    ,\n    SLEEP\n);\n\n    output X    ;\n    input  A    ;\n    input  SLEEP;\n\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_32ae02eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule counter (\n    input CLK,\n    input RESET,\n    input LOAD,\n    input [3:0] LOAD_VAL,\n    output [3:0] Q\n);\n    reg [3:0] Q;\n\n    always @(posedge CLK, posedge RESET) begin\n        if (RESET) begin\n            Q <= 4'b0;\n        end else if (LOAD) begin\n            Q <= LOAD_VAL;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\nendmodule\nmodule priority_mux (\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output Y, Z\n);\n    wire Y, Z;\n\n    assign Y = (S == 2'b01) ? A :\n              (S == 2'b10) ? B :\n              (S == 2'b11) ? ((D) ? D : (C) ? C : (B) ? B : A) :\n              1'b0;\n\n    assign Z = (S == 2'b01) ? ~A :\n              (S == 2'b10) ? ~B :\n              (S == 2'b11) ? ((D) ? ~D : (C) ? ~C : (B) ? ~B : ~A) :\n              1'b0;\nendmodule\nmodule final_output_module (\n    input [3:0] Q,\n    input Y,\n    output final_output\n);\n    wire final_output;\n\n    assign final_output = (Q[0] == 1) && Y;\nendmodule\nmodule top_module (\n    input CLK,\n    input RESET,\n    input LOAD,\n    input [3:0] LOAD_VAL,\n    input [3:0] A, B, C, D,\n    input [1:0] S,\n    output [3:0] Q,\n    output Y, Z,\n    output final_output\n);\n    counter counter_inst (\n        .CLK(CLK),\n        .RESET(RESET),\n        .LOAD(LOAD),\n        .LOAD_VAL(LOAD_VAL),\n        .Q(Q)\n    );\n\n    priority_mux priority_mux_inst (\n        .A(A),\n        .B(B),\n        .C(C),\n        .D(D),\n        .S(S),\n        .Y(Y),\n        .Z(Z)\n    );\n\n    final_output_module final_output_inst (\n        .Q(Q),\n        .Y(Y),\n        .final_output(final_output)\n    );\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_reset_enable_f4e4ff16", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule d_ff_reset_enable (\n    input CLK,\n    input D,\n    input RESET_N,\n    input ENABLE,\n    output reg Q,\n    output Q_N\n);\n\nalways @(posedge CLK or negedge RESET_N) begin\n    if (~RESET_N) begin\n        Q <= 0;\n    end else if (ENABLE) begin\n        Q <= D;\n    end\nend\n\nassign Q_N = ~Q;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplexer_4to1_e1c9d17d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Multiplexer_4to1 (\n    input ctrl0, ctrl1,\n    input [0:0] D0, D1, D2, D3,\n    output reg [0:0] S\n);\n\n  always @* begin\n    case ({ctrl1, ctrl0})\n      2'b00: S = D0;\n      2'b01: S = D1;\n      2'b10: S = D2;\n      2'b11: S = D3;\n    endcase\n  end\n\nendmodule\n\nmodule LUT4 (\n    input [3:0] I,\n    output reg O\n);\n\n  always @* begin\n    case (I)\n      4'b0000: O = 1'b1;\n      4'b0001: O = 1'b0;\n      4'b0010: O = 1'b1;\n      4'b0011: O = 1'b0;\n      4'b0100: O = 1'b1;\n      4'b0101: O = 1'b0;\n      4'b0110: O = 1'b1;\n      4'b0111: O = 1'b0;\n      4'b1000: O = 1'b0;\n      4'b1001: O = 1'b1;\n      4'b1010: O = 1'b0;\n      4'b1011: O = 1'b1;\n      4'b1100: O = 1'b0;\n      4'b1101: O = 1'b1;\n      4'b1110: O = 1'b0;\n      4'b1111: O = 1'b1;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "async_fifo_d1317c79", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule async_fifo(\n\ti_push,\n\ti_pop,\n\ti_reset,\n\ti_wclk,\n\ti_rclk,\n\ti_wdata,\n\to_rdata,\n\to_full,\n\to_empty\n    );\n\nparameter F_WIDTH = 4;\nparameter F_SIZE = 1 << F_WIDTH;\nparameter F_MAX = 32; input i_reset;\ninput i_rclk;\ninput i_wclk;\ninput i_push;\ninput i_pop;\ninput [65:0] i_wdata;\noutput reg [65:0] o_rdata;\noutput reg o_empty;\noutput reg o_full;\n\nreg [F_WIDTH-1:0] read_pos;\nreg [F_WIDTH-1:0] write_pos;\nreg [65:0] memory[F_SIZE -1 : 0];\nreg [7:0] total_count; reg [7:0] read_counter;\nreg [7:0] write_counter;\n\nalways @(*) begin\n\ttotal_count = write_counter - read_counter;\n   o_empty = (total_count == 0);\n   o_full = (total_count == F_MAX);\nend\n\nalways @(posedge i_wclk) begin\n\tif(i_reset) begin\n\t\twrite_counter <= 0;\n\t\twrite_pos <= 0;\n\tend\n\telse if(!o_full && i_push) begin\n\t\tmemory[write_pos] <= i_wdata;\n\t\twrite_pos <= write_pos + 1'b1;\n\t\twrite_counter <= write_counter + 1'b1;\n\tend\nend\n\nalways @(posedge i_rclk) begin\n\tif(i_reset) begin\n\t\tread_counter <= 0;\n\t\tread_pos <= 0;\n\tend\n\telse if(!o_empty && i_pop) begin\n\t\to_rdata <= memory[read_pos];\n\t\tread_pos <= read_pos + 1'b1;\n\t\tread_counter <= read_counter + 1'b1;\n\tend\nend\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_69ed1f35", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nreg [7:0] gray;\nreg [2:0] binary;\n\n// Binary-to-Gray code converter\nalways @(*) begin\n    gray[0] = in[0];\n    gray[1] = in[0] ^ in[1];\n    gray[2] = in[1] ^ in[2];\n    gray[3] = in[2] ^ in[3];\n    gray[4] = in[3] ^ in[4];\n    gray[5] = in[4] ^ in[5];\n    gray[6] = in[5] ^ in[6];\n    gray[7] = in[6] ^ in[7];\nend\n\n// Gray-to-binary code converter\nalways @(*) begin\n    binary[2] = gray[7];\n    binary[1] = binary[2] ^ gray[6];\n    binary[0] = binary[1] ^ gray[5];\nend\n\n// Priority encoder\nalways @(*) begin\n    if (binary[2]) pos = 3;\n    else if (binary[1]) pos = 2;\n    else if (binary[0]) pos = 1;\n    else pos = 0;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "seven_seg_edfdb228", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule seven_seg (\n                    clk,\n                    clr,\n                    disp_num,   \n                    Scanning,   \n                    SW,\n                    AN,     \n                    SEGMENT     \n                    );\n\n    input wire          clk, clr;\n    input wire  [ 1: 0] Scanning;       \n    input wire  [ 1: 0] SW;\n    input wire  [31: 0] disp_num;       \n    \n    output reg  [ 3: 0] AN;             \n    output wire [ 7: 0] SEGMENT;     \n\n    reg         [ 3: 0] digit       = 4'h0;\n    reg         [ 7: 0] temp_seg    = 8'h0, \n                        digit_seg   = 8'h0;\n    wire        [15: 0] disp_current;\n\n    assign SEGMENT = SW[0] ? digit_seg : temp_seg;                  assign disp_current = SW[1] ? disp_num[31:16] : disp_num[15:0]; always @(posedge clk)begin\n        case (digit)\n            4'h0:     digit_seg = 8'b10000001; \n\t\t    4'h1:     digit_seg = 8'b11001111; \n\t\t    4'h2:     digit_seg = 8'b10010010; \n\t\t    4'h3:     digit_seg = 8'b10000110; \n\t\t    4'h4:     digit_seg = 8'b11001100; \n\t\t    4'h5:     digit_seg = 8'b10100100; \n\t\t    4'h6:     digit_seg = 8'b10100000; \n\t\t    4'h7:     digit_seg = 8'b10001111; \n\t\t    4'h8:     digit_seg = 8'b10000000; \n\t\t    4'h9:     digit_seg = 8'b10000100; \n\t\t    4'hA:     digit_seg = 8'b10001000; \n\t\t    4'hB:     digit_seg = 8'b11100000; \n\t\t    4'hC:     digit_seg = 8'b10110001; \n\t\t    4'hD:     digit_seg = 8'b11000010; \n\t\t    4'hE:     digit_seg = 8'b10110000; \n\t\t    4'hF:     digit_seg = 8'b10111000;\n            default:  digit_seg = 8'b00000000;\n    endcase\n   end\n    \n    always @(posedge clk)begin\n        case (Scanning)             0: begin digit       = disp_current[ 3: 0]; temp_seg    = { disp_num[24], disp_num[ 0], disp_num[ 4], disp_num[16],\n                                    disp_num[25], disp_num[17], disp_num[ 5], disp_num[12]};\n                    AN          = 4'b1110;\n                end\n                1: begin digit       = disp_current[ 7: 4]; temp_seg    = { disp_num[26], disp_num[ 1], disp_num[ 6], disp_num[18],\n\t\t\t\t\t\t\t\t\tdisp_num[27], disp_num[19], disp_num[ 7], disp_num[13]};\n                    AN          = 4'b1101;\n                end\n                2: begin digit       = disp_current[11: 8];   temp_seg    = { disp_num[28], disp_num[ 2], disp_num[ 8], disp_num[20],\n\t\t\t\t\t\t\t\t\tdisp_num[29], disp_num[21], disp_num[ 9], disp_num[14]};\n                    AN          = 4'b1011;\n                end\n                3: begin digit       = disp_current[15:12];  temp_seg    = { disp_num[30], disp_num[ 3], disp_num[10], disp_num[22],\n\t\t\t\t\t\t\t\t\tdisp_num[31], disp_num[23], disp_num[11], disp_num[15]};\n                    AN          = 4'b0111;\n               end\n     endcase\n    end  \n    \n\n \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_9d9bdf98", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire c1, c2, c3;\n\n    full_adder fa0 (.a(A[0]), .b(B[0]), .cin(Cin), .sum(sum[0]), .cout(c1));\n    full_adder fa1 (.a(A[1]), .b(B[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2 (.a(A[2]), .b(B[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3 (.a(A[3]), .b(B[3]), .cin(c3), .sum(sum[3]), .cout(Cout));\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register_file_4b59095a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule register_file(\n    input [1:0] read_register_port_0,\n    input [1:0] read_register_port_1,\n    input [1:0] write_register,\n    input [31:0] write_data,\n    input write_enable,\n    output reg [31:0] read_data_port_0,\n    output reg [31:0] read_data_port_1\n);\n\nreg [31:0] registers [0:3];\n\nalways @(*)\nbegin\n    read_data_port_0 = registers[read_register_port_0];\n    read_data_port_1 = registers[read_register_port_1];\nend\n\nalways @(posedge write_enable)\nbegin\n    if (write_enable)\n        registers[write_register] <= write_data;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ibex_load_store_unit_82b97506", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ibex_load_store_unit (\n\tclk_i,\n\trst_ni,\n\tdata_req_o,\n\tdata_gnt_i,\n\tdata_rvalid_i,\n\tdata_err_i,\n\tdata_pmp_err_i,\n\tdata_addr_o,\n\tdata_we_o,\n\tdata_be_o,\n\tdata_wdata_o,\n\tdata_rdata_i,\n\tdata_we_ex_i,\n\tdata_type_ex_i,\n\tdata_wdata_ex_i,\n\tdata_sign_ext_ex_i,\n\tdata_rdata_ex_o,\n\tdata_req_ex_i,\n\tadder_result_ex_i,\n\taddr_incr_req_o,\n\taddr_last_o,\n\tdata_valid_o,\n\tload_err_o,\n\tstore_err_o,\n\tbusy_o,\n\tillegal_insn_id_i,\n\tinstr_valid_id_i\n);\n\tlocalparam [2:0] IDLE = 0;\n\tlocalparam [2:0] WAIT_GNT_MIS = 1;\n\tlocalparam [2:0] WAIT_RVALID_MIS = 2;\n\tlocalparam [2:0] WAIT_GNT = 3;\n\tlocalparam [2:0] WAIT_RVALID = 4;\n\tlocalparam [2:0] WAIT_RVALID_DONE = 5;\n\tinput wire clk_i;\n\tinput wire rst_ni;\n\toutput reg data_req_o;\n\tinput wire data_gnt_i;\n\tinput wire data_rvalid_i;\n\tinput wire data_err_i;\n\tinput wire data_pmp_err_i;\n\toutput wire [31:0] data_addr_o;\n\toutput wire data_we_o;\n\toutput wire [3:0] data_be_o;\n\toutput wire [31:0] data_wdata_o;\n\tinput wire [31:0] data_rdata_i;\n\tinput wire data_we_ex_i;\n\tinput wire [1:0] data_type_ex_i;\n\tinput wire [31:0] data_wdata_ex_i;\n\tinput wire data_sign_ext_ex_i;\n\toutput wire [31:0] data_rdata_ex_o;\n\tinput wire data_req_ex_i;\n\tinput wire [31:0] adder_result_ex_i;\n\toutput reg addr_incr_req_o;\n\toutput wire [31:0] addr_last_o;\n\toutput reg data_valid_o;\n\toutput wire load_err_o;\n\toutput wire store_err_o;\n\toutput wire busy_o;\n\tinput wire illegal_insn_id_i;\n\tinput wire instr_valid_id_i;\n\twire [31:0] data_addr;\n\twire [31:0] data_addr_w_aligned;\n\treg [31:0] addr_last_q;\n\treg addr_update;\n\treg ctrl_update;\n\treg rdata_update;\n\treg [31:8] rdata_q;\n\treg [1:0] rdata_offset_q;\n\treg [1:0] data_type_q;\n\treg data_sign_ext_q;\n\treg data_we_q;\n\twire [1:0] data_offset;\n\treg [3:0] data_be;\n\treg [31:0] data_wdata;\n\treg [31:0] data_rdata_ext;\n\treg [31:0] rdata_w_ext;\n\treg [31:0] rdata_h_ext;\n\treg [31:0] rdata_b_ext;\n\twire split_misaligned_access;\n\treg handle_misaligned_q;\n\treg handle_misaligned_d;\n\treg pmp_err_q;\n\treg pmp_err_d;\n\treg lsu_err_q;\n\treg lsu_err_d;\n\treg data_or_pmp_err;\n\treg [2:0] ls_fsm_cs;\n\treg [2:0] ls_fsm_ns;\n\tassign data_addr = adder_result_ex_i;\n\tassign data_offset = data_addr[1:0];\n\talways @(*)\n\t\tcase (data_type_ex_i)\n\t\t\t2'b00:\n\t\t\t\tif (!handle_misaligned_q)\n\t\t\t\t\tcase (data_offset)\n\t\t\t\t\t\t2'b00: data_be = 4'b1111;\n\t\t\t\t\t\t2'b01: data_be = 4'b1110;\n\t\t\t\t\t\t2'b10: data_be = 4'b1100;\n\t\t\t\t\t\t2'b11: data_be = 4'b1000;\n\t\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\t\tendcase\n\t\t\t\telse\n\t\t\t\t\tcase (data_offset)\n\t\t\t\t\t\t2'b00: data_be = 4'b0000;\n\t\t\t\t\t\t2'b01: data_be = 4'b0001;\n\t\t\t\t\t\t2'b10: data_be = 4'b0011;\n\t\t\t\t\t\t2'b11: data_be = 4'b0111;\n\t\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\t\tendcase\n\t\t\t2'b01:\n\t\t\t\tif (!handle_misaligned_q)\n\t\t\t\t\tcase (data_offset)\n\t\t\t\t\t\t2'b00: data_be = 4'b0011;\n\t\t\t\t\t\t2'b01: data_be = 4'b0110;\n\t\t\t\t\t\t2'b10: data_be = 4'b1100;\n\t\t\t\t\t\t2'b11: data_be = 4'b1000;\n\t\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\t\tendcase\n\t\t\t\telse\n\t\t\t\t\tdata_be = 4'b0001;\n\t\t\t2'b10, 2'b11:\n\t\t\t\tcase (data_offset)\n\t\t\t\t\t2'b00: data_be = 4'b0001;\n\t\t\t\t\t2'b01: data_be = 4'b0010;\n\t\t\t\t\t2'b10: data_be = 4'b0100;\n\t\t\t\t\t2'b11: data_be = 4'b1000;\n\t\t\t\t\tdefault: data_be = 4'b1111;\n\t\t\t\tendcase\n\t\t\tdefault: data_be = 4'b1111;\n\t\tendcase\n\talways @(*)\n\t\tcase (data_offset)\n\t\t\t2'b00: data_wdata = data_wdata_ex_i[31:0];\n\t\t\t2'b01: data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};\n\t\t\t2'b10: data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};\n\t\t\t2'b11: data_wdata = {data_wdata_ex_i[7:0], data_wdata_ex_i[31:8]};\n\t\t\tdefault: data_wdata = data_wdata_ex_i[31:0];\n\t\tendcase\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni)\n\t\t\trdata_q <= 1'sb0;\n\t\telse if (rdata_update)\n\t\t\trdata_q <= data_rdata_i[31:8];\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni) begin\n\t\t\trdata_offset_q <= 2'h0;\n\t\t\tdata_type_q <= 2'h0;\n\t\t\tdata_sign_ext_q <= 1'b0;\n\t\t\tdata_we_q <= 1'b0;\n\t\tend\n\t\telse if (ctrl_update) begin\n\t\t\trdata_offset_q <= data_offset;\n\t\t\tdata_type_q <= data_type_ex_i;\n\t\t\tdata_sign_ext_q <= data_sign_ext_ex_i;\n\t\t\tdata_we_q <= data_we_ex_i;\n\t\tend\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni)\n\t\t\taddr_last_q <= 1'sb0;\n\t\telse if (addr_update)\n\t\t\taddr_last_q <= data_addr;\n\talways @(*)\n\t\tcase (rdata_offset_q)\n\t\t\t2'b00: rdata_w_ext = data_rdata_i[31:0];\n\t\t\t2'b01: rdata_w_ext = {data_rdata_i[7:0], rdata_q[31:8]};\n\t\t\t2'b10: rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};\n\t\t\t2'b11: rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};\n\t\t\tdefault: rdata_w_ext = data_rdata_i[31:0];\n\t\tendcase\n\talways @(*)\n\t\tcase (rdata_offset_q)\n\t\t\t2'b00:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[15:0]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[15]}}, data_rdata_i[15:0]};\n\t\t\t2'b01:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[23:8]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[23]}}, data_rdata_i[23:8]};\n\t\t\t2'b10:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[31:16]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[31]}}, data_rdata_i[31:16]};\n\t\t\t2'b11:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};\n\t\t\t\telse\n\t\t\t\t\trdata_h_ext = {{16 {data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};\n\t\t\tdefault: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};\n\t\tendcase\n\talways @(*)\n\t\tcase (rdata_offset_q)\n\t\t\t2'b00:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[7]}}, data_rdata_i[7:0]};\n\t\t\t2'b01:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[15]}}, data_rdata_i[15:8]};\n\t\t\t2'b10:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[23]}}, data_rdata_i[23:16]};\n\t\t\t2'b11:\n\t\t\t\tif (!data_sign_ext_q)\n\t\t\t\t\trdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};\n\t\t\t\telse\n\t\t\t\t\trdata_b_ext = {{24 {data_rdata_i[31]}}, data_rdata_i[31:24]};\n\t\t\tdefault: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};\n\t\tendcase\n\talways @(*)\n\t\tcase (data_type_q)\n\t\t\t2'b00: data_rdata_ext = rdata_w_ext;\n\t\t\t2'b01: data_rdata_ext = rdata_h_ext;\n\t\t\t2'b10, 2'b11: data_rdata_ext = rdata_b_ext;\n\t\t\tdefault: data_rdata_ext = rdata_w_ext;\n\t\tendcase\n\tassign split_misaligned_access = (((data_type_ex_i == 2'b00) && (data_offset != 2'b00)) || ((data_type_ex_i == 2'b01) && (data_offset == 2'b11)));\n\talways @(*) begin\n\t\tls_fsm_ns = ls_fsm_cs;\n\t\tdata_req_o = 1'b0;\n\t\tdata_valid_o = 1'b0;\n\t\taddr_incr_req_o = 1'b0;\n\t\thandle_misaligned_d = handle_misaligned_q;\n\t\tdata_or_pmp_err = 1'b0;\n\t\tpmp_err_d = pmp_err_q;\n\t\tlsu_err_d = lsu_err_q;\n\t\taddr_update = 1'b0;\n\t\tctrl_update = 1'b0;\n\t\trdata_update = 1'b0;\n\t\tcase (ls_fsm_cs)\n\t\t\tIDLE:\n\t\t\t\tif (data_req_ex_i) begin\n\t\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\t\tpmp_err_d = data_pmp_err_i;\n\t\t\t\t\tlsu_err_d = 1'b0;\n\t\t\t\t\tif (data_gnt_i) begin\n\t\t\t\t\t\tctrl_update = 1'b1;\n\t\t\t\t\t\taddr_update = 1'b1;\n\t\t\t\t\t\thandle_misaligned_d = split_misaligned_access;\n\t\t\t\t\t\tls_fsm_ns = (split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID);\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tls_fsm_ns = (split_misaligned_access ? WAIT_GNT_MIS : WAIT_GNT);\n\t\t\t\tend\n\t\t\tWAIT_GNT_MIS: begin\n\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\tif ((data_gnt_i || pmp_err_q)) begin\n\t\t\t\t\taddr_update = 1'b1;\n\t\t\t\t\tctrl_update = 1'b1;\n\t\t\t\t\thandle_misaligned_d = 1'b1;\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID_MIS;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWAIT_RVALID_MIS: begin\n\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\taddr_incr_req_o = 1'b1;\n\t\t\t\tif ((data_rvalid_i || pmp_err_q)) begin\n\t\t\t\t\tpmp_err_d = data_pmp_err_i;\n\t\t\t\t\tlsu_err_d = (data_err_i | pmp_err_q);\n\t\t\t\t\trdata_update = ~data_we_q;\n\t\t\t\t\tls_fsm_ns = (data_gnt_i ? WAIT_RVALID : WAIT_GNT);\n\t\t\t\t\taddr_update = (data_gnt_i & ~(data_err_i | pmp_err_q));\n\t\t\t\tend\n\t\t\t\telse if (data_gnt_i)\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID_DONE;\n\t\t\tend\n\t\t\tWAIT_GNT: begin\n\t\t\t\taddr_incr_req_o = handle_misaligned_q;\n\t\t\t\tdata_req_o = 1'b1;\n\t\t\t\tif ((data_gnt_i || pmp_err_q)) begin\n\t\t\t\t\tctrl_update = 1'b1;\n\t\t\t\t\taddr_update = ~lsu_err_q;\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWAIT_RVALID:\n\t\t\t\tif ((data_rvalid_i || pmp_err_q)) begin\n\t\t\t\t\tdata_valid_o = 1'b1;\n\t\t\t\t\tdata_or_pmp_err = ((lsu_err_q | data_err_i) | pmp_err_q);\n\t\t\t\t\thandle_misaligned_d = 1'b0;\n\t\t\t\t\tls_fsm_ns = IDLE;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID;\n\t\t\tWAIT_RVALID_DONE: begin\n\t\t\t\taddr_incr_req_o = 1'b1;\n\t\t\t\tif (data_rvalid_i) begin\n\t\t\t\t\tpmp_err_d = data_pmp_err_i;\n\t\t\t\t\tlsu_err_d = data_err_i;\n\t\t\t\t\taddr_update = ~data_err_i;\n\t\t\t\t\trdata_update = ~data_we_q;\n\t\t\t\t\tls_fsm_ns = WAIT_RVALID;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: ls_fsm_ns = IDLE;\n\t\tendcase\n\tend\n\talways @(posedge clk_i or negedge rst_ni)\n\t\tif (!rst_ni) begin\n\t\t\tls_fsm_cs <= IDLE;\n\t\t\thandle_misaligned_q <= 1'sb0;\n\t\t\tpmp_err_q <= 1'sb0;\n\t\t\tlsu_err_q <= 1'sb0;\n\t\tend\n\t\telse begin\n\t\t\tls_fsm_cs <= ls_fsm_ns;\n\t\t\thandle_misaligned_q <= handle_misaligned_d;\n\t\t\tpmp_err_q <= pmp_err_d;\n\t\t\tlsu_err_q <= lsu_err_d;\n\t\tend\n\tassign data_rdata_ex_o = data_rdata_ext;\n\tassign data_addr_w_aligned = {data_addr[31:2], 2'b00};\n\tassign data_addr_o = data_addr_w_aligned;\n\tassign data_wdata_o = data_wdata;\n\tassign data_we_o = data_we_ex_i;\n\tassign data_be_o = data_be;\n\tassign addr_last_o = addr_last_q;\n\tassign load_err_o = (data_or_pmp_err & ~data_we_q);\n\tassign store_err_o = (data_or_pmp_err & data_we_q);\n\tassign busy_o = (ls_fsm_cs != IDLE);\n\twire unused_instr_valid_id;\n\twire unused_illegal_insn_id;\n\tassign unused_instr_valid_id = instr_valid_id_i;\n\tassign unused_illegal_insn_id = illegal_insn_id_i;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_2f0be4b7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module(\n    input [3:0] a1,\n    input [3:0] a2,\n    input [3:0] b1,\n    input [3:0] b2,\n    input sel1,\n    input sel2,\n    input select,\n    output [3:0] out\n);\n\n    // First 2-to-1 multiplexer\n    wire [3:0] mux1_out;\n    mux2to1 mux1(\n        .a(a1),\n        .b(b1),\n        .sel(sel1),\n        .out(mux1_out)\n    );\n    \n    // Second 2-to-1 multiplexer\n    wire [3:0] mux2_out;\n    mux2to1 mux2(\n        .a(a2),\n        .b(b2),\n        .sel(sel2),\n        .out(mux2_out)\n    );\n    \n    // Control logic to select active multiplexer\n    wire [3:0] active_mux_out;\n    assign active_mux_out = select ? mux2_out : mux1_out;\n    \n    // Functional module to sum the outputs of the two multiplexers\n    wire [7:0] sum;\n    adder add(\n        .a(active_mux_out),\n        .b(mux2_out),\n        .sum(sum)\n    );\n    \n    // Output the sum of the active multiplexer's values\n    assign out = sum[3:0];\n    \nendmodule\n\nmodule mux2to1(\n    input [3:0] a,\n    input [3:0] b,\n    input sel,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        if(sel) begin\n            out = b;\n        end else begin\n            out = a;\n        end\n    end\n    \nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output reg [7:0] sum\n);\n\n    always @(*) begin\n        sum = {4'b0, a} + {4'b0, b};\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "soc_system_pio_aliveTest_cpu_s0_8efb5854", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule soc_system_pio_aliveTest_cpu_s0 (\n  // inputs:\n  address,\n  chipselect,\n  clk,\n  reset_n,\n  write_n,\n  writedata,\n\n  // outputs:\n  out_port,\n  readdata\n);\n\n  output  [  1: 0] out_port;\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            chipselect;\n  input            clk;\n  input            reset_n;\n  input            write_n;\n  input   [ 31: 0] writedata;\n\n  wire             clk_en;\n  reg     [  1: 0] data_out;\n  wire    [  1: 0] out_port;\n  wire    [  1: 0] read_mux_out;\n  wire    [ 31: 0] readdata;\n  assign clk_en = 1;\n\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {2 {(address == 0)}} & data_out;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (reset_n == 0) begin\n      data_out <= 0;\n    end else if (chipselect && ~write_n && (address == 0)) begin\n      data_out <= writedata[1 : 0];\n    end\n  end\n\n  assign readdata = {30'b0, read_mux_out};\n\n  assign out_port = data_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_block_910a835e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w2048,\n    w2049,\n    w8196,\n    w6147,\n    w64,\n    w6211,\n    w24844;\n\n  assign w1 = i_data0;\n  assign w2048 = w1 << 11;\n  assign w2049 = w1 + w2048;\n  assign w64 = w1 << 6;\n  assign w8196 = w2049 << 2;\n  assign w6147 = w8196 - w2049;\n  assign w6211 = w6147 + w64;\n  assign w24844 = w6211 << 2;\n\n  assign o_data0 = w24844;\n\n  //multiplier_block area estimate = 4886.48160088529;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_module_d353e620", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module(\n    input dataa,\n    input clk,\n    input aclr,\n    input ena,\n    input devclrn,\n    input devpor,\n    output reg dataout\n);\n\nparameter output_clock = \"none\";\n\nreg [1:0] state;\n\ninitial begin\n    state = 2'b00;\nend\n\nalways @(posedge clk or negedge aclr) begin\n    if (!aclr) begin\n        state <= 2'b00;\n        dataout <= 1'b0;\n    end\n    else begin\n        case (state)\n            2'b00: begin\n                if (ena) begin\n                    dataout <= dataa;\n                    state <= 2'b01;\n                end\n                else begin\n                    dataout <= 1'b0;\n                end\n            end\n            2'b01: begin\n                if (output_clock != \"none\") begin\n                    state <= 2'b10;\n                end\n                else begin\n                    state <= 2'b00;\n                end\n            end\n            2'b10: begin\n                dataout <= dataa;\n                state <= 2'b11;\n            end\n            2'b11: begin\n                dataout <= 1'b0;\n                state <= 2'b00;\n            end\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vending_machine_controller_901dea74", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vending_machine_controller(\n    input clk,\n    input rst,\n    input button_A,\n    input button_B,\n    input button_C,\n    input coin,\n    output reg dispense_X,\n    output reg dispense_Y,\n    output reg dispense_Z,\n    output reg [23:0] display,\n    output reg button_A_enable,\n    output reg button_B_enable,\n    output reg button_C_enable\n);\n\n    // Define constants\n    parameter PRICE = 150; // Price of each product in cents\n    parameter MAX_STOCK = 5; // Maximum stock of each product\n    \n    // Define state variables\n    reg [1:0] state;\n    reg [2:0] inventory;\n    reg [23:0] total_money;\n    \n    // Define state machine states\n    parameter [1:0] IDLE = 2'b00;\n    parameter [1:0] DISPENSING = 2'b01;\n    parameter [1:0] COIN_INSERTED = 2'b10;\n    \n    // Define state machine transitions and actions\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            inventory <= {MAX_STOCK, MAX_STOCK, MAX_STOCK};\n            total_money <= 0;\n            dispense_X <= 0;\n            dispense_Y <= 0;\n            dispense_Z <= 0;\n            button_A_enable <= 1;\n            button_B_enable <= 1;\n            button_C_enable <= 1;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (button_A && inventory[0] > 0) begin\n                        state <= DISPENSING;\n                        dispense_X <= 1;\n                        inventory[0] <= inventory[0] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_B && inventory[1] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Y <= 1;\n                        inventory[1] <= inventory[1] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_C && inventory[2] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Z <= 1;\n                        inventory[2] <= inventory[2] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (coin) begin\n                        state <= COIN_INSERTED;\n                        total_money <= total_money + 100; // Add coin value to total money\n                    end\n                end\n                DISPENSING: begin\n                    if (!button_A && !button_B && !button_C) begin\n                        state <= IDLE;\n                        dispense_X <= 0;\n                        dispense_Y <= 0;\n                        dispense_Z <= 0;\n                    end\n                end\n                COIN_INSERTED: begin\n                    if (button_A && inventory[0] > 0) begin\n                        state <= DISPENSING;\n                        dispense_X <= 1;\n                        inventory[0] <= inventory[0] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_B && inventory[1] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Y <= 1;\n                        inventory[1] <= inventory[1] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (button_C && inventory[2] > 0) begin\n                        state <= DISPENSING;\n                        dispense_Z <= 1;\n                        inventory[2] <= inventory[2] - 1;\n                        total_money <= total_money + PRICE;\n                    end else if (!coin) begin\n                        state <= IDLE;\n                    end\n                end\n            endcase\n            \n            // Update button enable signals based on inventory levels\n            button_A_enable <= (inventory[0] > 0);\n            button_B_enable <= (inventory[1] > 0);\n            button_C_enable <= (inventory[2] > 0);\n            \n            // Update display output\n            display <= {7'b1111110, 7'b1111110, 7'b1111110}; // Default to showing \"888\"\n            if (state == COIN_INSERTED) begin\n                display <= {7'b0000110, 7'b0000000, 7'b0000000} + (total_money / 10); // Show total money in dollars\n            end else begin\n                display[0] <= 7'b1110000 - (inventory[0] * 7); // Show inventory level for product X\n                display[1] <= 7'b1110000 - (inventory[1] * 7); // Show inventory level for product Y\n                display[2] <= 7'b1110000 - (inventory[2] * 7); // Show inventory level for product Z\n            end\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Altera_UP_PS2_Data_In_62d7eaba", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule Altera_UP_PS2_Data_In (\n    clk,\n    reset,\n\n    wait_for_incoming_data,\n    start_receiving_data,\n\n    ps2_clk_posedge,\n    ps2_clk_negedge,\n    ps2_data,\n\n    received_data,\n    received_data_en            );\n\n\n\n\n\n\ninput               clk;\ninput               reset;\n\ninput               wait_for_incoming_data;\ninput               start_receiving_data;\n\ninput               ps2_clk_posedge;\ninput               ps2_clk_negedge;\ninput               ps2_data;\n\noutput reg  [7:0]   received_data;\n\noutput reg          received_data_en;\n\n\nlocalparam  PS2_STATE_0_IDLE            = 3'h0,\n            PS2_STATE_1_WAIT_FOR_DATA   = 3'h1,\n            PS2_STATE_2_DATA_IN         = 3'h2,\n            PS2_STATE_3_PARITY_IN       = 3'h3,\n            PS2_STATE_4_STOP_IN         = 3'h4;\n\n\nreg         [3:0]   data_count;\nreg         [7:0]   data_shift_reg;\n\nreg         [2:0]   ns_ps2_receiver;\nreg         [2:0]   s_ps2_receiver;\n\n\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        s_ps2_receiver <= PS2_STATE_0_IDLE;\n    else\n        s_ps2_receiver <= ns_ps2_receiver;\nend\n\nalways @(*)\nbegin\n    ns_ps2_receiver = PS2_STATE_0_IDLE;\n\n    case (s_ps2_receiver)\n    PS2_STATE_0_IDLE:\n        begin\n            if ((wait_for_incoming_data == 1'b1) && \n                    (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n            else if ((start_receiving_data == 1'b1) && \n                    (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    PS2_STATE_1_WAIT_FOR_DATA:\n        begin\n            if ((ps2_data == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else if (wait_for_incoming_data == 1'b0)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n        end\n    PS2_STATE_2_DATA_IN:\n        begin\n            if ((data_count == 3'h7) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n        end\n    PS2_STATE_3_PARITY_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n        end\n    PS2_STATE_4_STOP_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n        end\n    default:\n        begin\n            ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    endcase\nend\n\n\n\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1) \n        data_count  <= 3'h0;\n    else if ((s_ps2_receiver == PS2_STATE_2_DATA_IN) && \n            (ps2_clk_posedge == 1'b1))\n        data_count  <= data_count + 3'h1;\n    else if (s_ps2_receiver != PS2_STATE_2_DATA_IN)\n        data_count  <= 3'h0;\nend\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        data_shift_reg          <= 8'h00;\n    else if ((s_ps2_receiver == PS2_STATE_2_DATA_IN) && \n            (ps2_clk_posedge == 1'b1))\n        data_shift_reg  <= {ps2_data, data_shift_reg[7:1]};\nend\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        received_data       <= 8'h00;\n    else if (s_ps2_receiver == PS2_STATE_4_STOP_IN)\n        received_data   <= data_shift_reg;\nend\n\nalways @(posedge clk)\nbegin\n    if (reset == 1'b1)\n        received_data_en        <= 1'b0;\n    else if ((s_ps2_receiver == PS2_STATE_4_STOP_IN) &&\n            (ps2_clk_posedge == 1'b1))\n        received_data_en    <= 1'b1;\n    else\n        received_data_en    <= 1'b0;\nend\n\n\n\n\n\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PWM #_c26c6d53", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PWM #(\n  parameter p = 8 // number of bits used to represent the modulation signal\n)(\n  input clk,\n  input rst,\n  input [p-1:0] mod,\n  output pwm\n);\n\n\nreg [p-1:0] counter;\nreg pwm_reg;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    counter <= 0;\n    pwm_reg <= 0;\n  end else begin\n    counter <= counter + 1;\n    if (counter >= 2**p) begin\n      counter <= 0;\n    end\n    if (counter < mod) begin\n      pwm_reg <= 1;\n    end else begin\n      pwm_reg <= 0;\n    end\n  end\nend\n\nassign pwm = pwm_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gpio_wb #_93b87e14", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gpio_wb #(parameter BASE_ADDR = 32'h00000400) (\n    \n    // system signals\n    input clk_i, \n    input rst_i,\n    \n    // wb signals\n    input      [31:0] dat_i, \n    output reg [31:0] dat_o, \n    input      [31:0] adr_i, \n    input      we_i, \n    input      [3:0] sel_i, \n    input      cyc_i, \n    input      stb_i, \n    output reg ack_o,\n    \n    // func signals\n    input [15:0] sw_bi,\n    output reg [15:0] gpio_bo\n);\n\nlocalparam IDLE = 0;\nlocalparam ACK  = 1;\n\nwire read  = cyc_i & stb_i & !we_i;\nwire write = cyc_i & stb_i & we_i;\n    \nreg state_r;\n    \nalways@(posedge clk_i, posedge rst_i)\n    if(rst_i) begin\n        state_r  <= 0;\n        ack_o    <= 1'b0;\n        gpio_bo  <= 0;\n        dat_o    <= 0;\n    end else begin\n    \n        ack_o <= 1'b0;\n        \n        case(state_r)\n            IDLE: \n                begin\n                    if(write) begin\n                        if(adr_i == BASE_ADDR)\n                            gpio_bo <= dat_i[15:0];\n                        ack_o   <= 1'b1;\n                        state_r <= ACK; \n                    end else if(read) begin\n                        dat_o <= (adr_i == BASE_ADDR)? sw_bi: 0;\n                        state_r <= ACK;\n                    end\n                end\n            ACK:\n                begin\n                    ack_o   <= 1'b1;\n                    state_r <= IDLE;\n                end\n        endcase\n    end\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "stack_f228f844", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule stack(\n    input reset,\n    input clock,\n    input nip,\n    input dup,\n    input we,\n    input [7:0] data_in,\n    output [7:0] tos_out,\n    output [7:0] nos_out\n);\n\n    parameter DEPTH = 16;\n    parameter PTR = $clog2(DEPTH);\n\n    reg [7:0] cells [DEPTH-1:0];\n    reg [PTR-1:0] sp;\n    reg [PTR-1:0] nsp;\n    reg [7:0] tos;\n    reg [7:0] nos;\n\n    always @(*) begin\n        nsp = sp - 1;\n    end\n\n    assign tos_out = cells[sp];\n    assign nos_out = cells[nsp];\n\n    always @(posedge clock) begin\n        if (reset) begin\n            sp <= 4'b0000;\n            cells[sp] <= 8'b0;\n            tos <= 8'b0;\n            nos <= 8'b0;\n        end\n\n        tos <= cells[sp];\n        nos <= cells[nsp];\n\n        if (nip && !dup) begin\n            sp <= sp - 1;\n        end\n\n        if (dup && !nip) begin\n            sp <= sp + 1;\n        end\n\n        if (dup && nip) begin\n            cells[nsp] <= tos;\n            tos <= nos;\n        end\n\n        if (we) begin\n            tos <= data_in;\n        end\n\n        cells[sp] <= tos;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder32_31debaac", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder32 (cout,\n\ts0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,\n\ta0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,\n\tb0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15);\n   \n   input a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15;\n   input b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15;\n   output s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15;\n   output cout;         wire c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15;\n\nassign s0 = a0 ^ b0 ^ 1'b0;\nassign c1 = (a0&b0);\nassign c2 = (a1&b1)|(a1&c1)|(b1&c1);\nassign s1 = a1 ^ b1 ^ c1;\nassign c3 = (a2&b2)|(a2&c2)|(b2&c2);\n\nassign s2 = a2 ^ b2 ^ c2;\nassign c4 = (a3&b3)|(a3&c3)|(b3&c3);\n\nassign s3 = a3 ^ b3 ^ c3;\nassign c5 = (a4&b4)|(a4&c4)|(b4&c4);\n\nassign s4 = a4 ^ b4 ^ c4;\nassign c6 = (a5&b5)|(a5&c5)|(b5&c5);\n\nassign s5 = a5 ^ b5 ^ c5;\nassign c7 = (a6&b6)|(a6&c6)|(b6&c6);\n\nassign s6 = a6 ^ b6 ^ c6;\nassign c8 = (a7&b7)|(a7&c7)|(b7&c7);\n\nassign s7 = a7 ^ b7 ^ c7;\nassign c9 = (a8&b8)|(a8&c8)|(b8&c8);\n\nassign s8 = a8 ^ b8 ^ c8;\nassign c10 = (a9&b9)|(a9&c9)|(b9&c9);\n\nassign s9 = a9 ^ b9 ^ c9;\nassign c11 = (a10&b10)|(a10&c10)|(b10&c10);\n\nassign s10 = a10 ^ b10 ^ c10;\nassign c12 = (a11&b11)|(a11&c11)|(b11&c11);\n\nassign s11 = a11 ^ b11 ^ c11;\nassign c13 = (a12&b12)|(a12&c12)|(b12&c12);\n\nassign s12 = a12 ^ b12 ^ c12;\nassign c14 = (a13&b13)|(a13&c13)|(b13&c13);\n\nassign s13 = a13 ^ b13 ^ c13;\nassign c15 = (a14&b14)|(a14&c14)|(b14&c14);\n\nassign s14 = a14 ^ b14 ^ c14;\nassign cout = (a15&b15)|(a15&c15)|(b15&c15);\n\nassign s15 = a15 ^ b15 ^ c15;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "slow_clk_2a116244", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule slow_clk(input clk, output slow_clk);\n    parameter TICKS = 27'd49_999_999;\n\n    reg [31:0] count = 0;\n    reg sig_reg = 0;\n\n    always @(posedge clk) begin\n        if (count == TICKS) begin\n            sig_reg <= ~sig_reg;\n            count <= 0;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\n    assign slow_clk = sig_reg;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM #_fb24a176", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  input clk,\n  output reg [m-1:0] out\n);\n\nparameter s_new = 1; // new state encoding\n\n// Define the states using the original state encoding\nparameter STATE_A = 2'b00;\nparameter STATE_B = 2'b01;\nparameter STATE_C = 2'b10;\nparameter STATE_D = 2'b11;\n\nreg [1:0] current_state, next_state;\nalways @* begin\n  next_state = (current_state == STATE_A && in[0]) ? STATE_B :\n               (current_state == STATE_A && !in[0]) ? STATE_C :\n               (current_state == STATE_B && in[1]) ? STATE_D :\n               (current_state == STATE_B && !in[1]) ? STATE_A :\n               (current_state == STATE_C && in[2]) ? STATE_A :\n               (current_state == STATE_C && !in[2]) ? STATE_D :\n               (current_state == STATE_D && in[3]) ? STATE_C :\n               (current_state == STATE_D && !in[3]) ? STATE_B :\n               current_state;\nend\n\n// Define the outputs based on the current state and the new state encoding\nalways @* begin\n  case (current_state)\n    STATE_A: out = {s_new == 1 ? 1'b1 : 2'b01, s_new == 1 ? 1'b0 : 2'b10};\n    STATE_B: out = {s_new == 1 ? 1'b0 : 2'b10, s_new == 1 ? 1'b1 : 2'b01};\n    STATE_C: out = {s_new == 1 ? 1'b1 : 2'b10, s_new == 1 ? 1'b1 : 2'b10};\n    STATE_D: out = {s_new == 1 ? 1'b0 : 2'b10, s_new == 1 ? 1'b0 : 2'b10};\n  endcase\nend\n\n// Define the state register and the next state logic\nalways @ (posedge clk) begin\n  current_state <= next_state;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ResetEither_d00b7265", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n`ifdef BSV_ASSIGNMENT_DELAY\n`else\n`define BSV_ASSIGNMENT_DELAY\n`endif\n\nmodule ResetEither(A_RST,\n                   B_RST,\n                   RST_OUT\n                  ) ;\n\n   input            A_RST;\n   input            B_RST;\n\n   output           RST_OUT;\n\n   assign RST_OUT = A_RST & B_RST ;\n\nendmodule                \n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_b1_0dd99b4d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate_b1 (\n    Y,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input A4;\n    input B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign Y = (A1 & A2 & A3 & A4 & ~B1);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__nor4_0de53e50", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_hd__nor4 (\n    output Y,\n    input A,\n    input B,\n    input C,\n    input D,\n    inout VPWR,\n    inout VGND,\n    inout VPB,\n    inout VNB\n);\n    assign Y = ~((A ~^ B) ~| (C ~^ D));\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_8a5d7a08", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator(\n  input [3:0] A,\n  input [3:0] B,\n  output reg [3:0] Y\n);\n\n  always @(*) begin\n    if (A >= B) begin\n      Y = A - B;\n    end\n    else begin\n      Y = B - A;\n    end\n    if (A == B) begin\n      Y = 0;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "regfile_fda37169", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define N 32 \n`define K 32\nmodule regfile (\n    input clk,\n    input ld,\n    input [`K-1:0] d,\n    input [`N-1:0] sa,\n    input [`N-1:0] sb,\n    output reg [`N-1:0] a,\n    output reg [`N-1:0] b,\n    output reg [`K-1:0] x\n);\n\nreg [`K-1:0] regfile [`N-1:0];\n\nalways @(posedge clk) begin\n    if (ld) begin\n        regfile[d] <= d;\n        x <= regfile[sa];\n    end\n    a <= regfile[sa];\n    b <= regfile[sb];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "accumulator_63f90cc9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule accumulator (\n  input clk,\n  input rst,\n  input [n-1:0] in,\n  output [n-1:0] out\n);\n\nparameter n = 8; // number of bits in the input and output signals\n\nreg [n-1:0] sum; // register to store the accumulated sum\n\nalways @(posedge clk) begin\n  if (rst) begin\n    sum <= 0; // reset the accumulated sum to zero\n  end else begin\n    sum <= sum + in; // add the input signal to the accumulated sum\n  end\nend\n\nassign out = rst ? 0 : sum; // select between the accumulated sum and zero based on the reset signal\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "frame_detector_355bf09b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule frame_detector\n(\n\tinput clk400,\n\tinput clk80,\n\tinput reset,\n\tinput enable,\n\t\n\tinput sdata,\n\toutput reg [4:0]pdata,\n\toutput reg error\n);\n\treg [5:0]s;  reg detect;  reg [2:0]c;  wire sync = c[2]; reg [4:0]p;  reg e;       always @(posedge clk400 or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\ts <= 0;\n\t\t\tdetect <= 0;\n\t\t\tc <= 0;\n\t\t\tp <= 0;\n\t\t\te <= 0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\ts <= {s[4:0],sdata};\n\t\t\tdetect <= (s[5:0] == 6'b100000) || (s[5:0] == 6'b011111);\n\t\t\tif (sync || detect) c <= 3'd0; else c <= c + 3'd1;\n\t\t\tif (sync) p <= s[5:1];\n\t\t\tif (sync) e <= 0; else if (detect) e <= 1;\n\t\tend\n\tend\n\n\talways @(posedge clk80 or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tpdata <= 5'd0;\n\t\t\terror <= 0;\n\t\tend\n\t\telse if (enable)\n\t\tbegin\n\t\t\tpdata <= p;\n\t\t\terror <= e;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tpdata <= 5'd0;\n\t\t\terror <= 0;\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "block_ram #_5876ec52", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule block_ram #(parameter DATA_WIDTH=4, ADDRESS_WIDTH=10)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n   reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule `default_nettype none\nmodule distributed_ram #(parameter DATA_WIDTH=8, ADDRESS_WIDTH=4)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n   reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule `default_nettype none\nmodule distributed_ram_manual #(parameter DATA_WIDTH=8, ADDRESS_WIDTH=4)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n    reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule `default_nettype none\nmodule distributed_ram_manual_syn #(parameter DATA_WIDTH=8, ADDRESS_WIDTH=4)\n   (input  wire                      write_enable, clk,\n    input  wire  [DATA_WIDTH-1:0]    data_in,\n    input  wire  [ADDRESS_WIDTH-1:0] address_in,\n    output wire  [DATA_WIDTH-1:0]    data_out);\n\n   localparam WORD  = (DATA_WIDTH-1);\n   localparam DEPTH = (2**ADDRESS_WIDTH-1);\n\n   reg [WORD:0] data_out_r;\n    reg [WORD:0] memory [0:DEPTH];\n\n   always @(posedge clk) begin\n      if (write_enable)\n        memory[address_in] <= data_in;\n      data_out_r <= memory[address_in];\n   end\n\n   assign data_out = data_out_r;\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reset_sync_379fc1f6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule reset_sync (\n  input rst,\n  input clk,\n  output reg rst_sync\n);\n\n  reg [1:0] rst_sync_reg;\n\n  always @(posedge clk) begin\n    rst_sync_reg <= {rst_sync_reg[0], rst};\n  end\n\n  always @(*) begin\n    rst_sync = ~rst_sync_reg[1];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "inicial_d1927743", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule inicial ( giro, entrada, saida, metais, ledVerde, ledVermelho, display, clock );\n\tinput giro, entrada, saida, metais, clock;\n\toutput [1:0] ledVerde, ledVermelho;\n\toutput [6:0] display;\n\n\treg [2:0] estado;\n\treg [3:0] tmp;\n\treg [1:0] tmpLedVerde, tmpLedVermelho;\n\treg [6:0] tmpDisplay;\n\n\tparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\n\tinitial estado = A;\n\n\talways @( posedge clock ) begin\n\t\t\ttmp = { giro, entrada, saida, metais }; \n\n          \tcase( estado )\n          \t\t\tA: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b00;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b00;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b1111001;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1101 | tmp == 4'b1111 )\n\t\t\t\t\t\t\t\t\testado = C;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1110 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 )\n\t\t\t\t\t\t\t\t\testado = E;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tB: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b01;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b00;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0100100;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1101 )\n\t\t\t\t\t\t\t\t\testado = C;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1110 | tmp == 4'b1111 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 | tmp == 4'b1011 )\n\t\t\t\t\t\t\t\t\testado = E;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tC: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b00;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b01;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0110000;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0100 | tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0110 | tmp == 4'b1110 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 )\n\t\t\t\t\t\t\t\t\testado = E;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tD: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b10;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b10;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0011001;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0111 | tmp == 4'b1111 )\n\t\t\t\t\t\t\t\t\testado = C;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1010 )\n\t\t\t\t\t\t\t\t\testado = E;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\n\t\t\t\t\t\t\tend\n\n\t\t\t\t\t\tE: begin\n\t\t\t\t\t\t\t\ttmpLedVerde = 2'b00;\n\t\t\t\t\t\t\t\ttmpLedVermelho = 2'b00;\n\t\t\t\t\t\t\t\ttmpDisplay = 7'b0010010;\n\n\t\t\t\t\t\t\t\tif( tmp == 4'b0000 | tmp == 4'b1000 )\n\t\t\t\t\t\t\t\t\testado = A;\n\t\t\t\t\t\t\t\tif( tmp == 4'b0110 | tmp == 4'b1110 )\n\t\t\t\t\t\t\t\t\testado = D;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1100 )\n\t\t\t\t\t\t\t\t\testado = B;\n\t\t\t\t\t\t\t\tif( tmp == 4'b1101 )\n\t\t\t\t\t\t\t\t\testado = C;\n\n\t\t\t\t\t\t\tend\n\n          \t\t\tdefault: estado = A;\n\n          \tendcase\n\tend\n\n\tassign ledVerde = tmpLedVerde;\n\tassign ledVermelho = tmpLedVermelho;\n\tassign display = tmpDisplay;\n\nendmodule\n\nmodule projetoPessoal ( SW,LEDG, LEDR, HEX0, CLK );\n\tinput [3:0] SW;\n\tinput CLK;\n\toutput [1:0] LEDG, LEDR;\n\toutput [6:0] HEX0;\n\n\tinicial a( SW[3], SW[2], SW[1], SW[0], LEDG, LEDR, HEX0, CLK );\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand_gate_27a7a204", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule nand_gate(\n    input a,\n    input b,\n    output reg y\n);\n\nalways @ (a, b) begin\n    y = ~(a & b);\nend\n\nendmodule\nmodule decoder_2to4(\n    input [1:0] in,\n    output [3:0] out\n);\n\nwire n1, n2;\n\nnand_gate nand1(\n    .a(in[0]), \n    .b(in[1]), \n    .y(n1)\n);\n\nnand_gate nand2(\n    .a(in[0]), \n    .b(~in[1]), \n    .y(n2)\n);\n\nassign out = {~n1 & ~n2, ~n1 & n2, n1 & ~n2, n1 & n2};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "XC2COrArray_0c3a26a5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule XC2COrArray(pterms_in, config_bits, or_out);\n\n\tinput wire[55:0]\t\t\tpterms_in;\n\tinput wire[16*56 - 1 : 0]\tconfig_bits;\n\toutput reg[15:0]\t\t\tor_out;\n\n\tinteger nout;\n\tinteger nterm;\n\n\treg[55:0] or_config[15:0];\n\talways @(*) begin\n\t\tfor(nterm=0; nterm<56; nterm=nterm+1) begin\n\t\t\tfor(nout=0; nout<16; nout=nout + 1)\n\t\t\t\tor_config[nout][nterm]\t\t<= config_bits[nout*56 + nterm];\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tfor(nout=0; nout<16; nout = nout+1) begin\n\t\t\tor_out[nout] = 0;\t\tfor(nterm=0; nterm<56; nterm=nterm+1) begin\n\t\t\t\tif(!or_config[nout][nterm])\n\t\t\t\t\tor_out[nout] = or_out[nout] | pterms_in[nterm];\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ring_delay_556eaadb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ring_delay (\n    input clk,\n    input d,\n    input [3:0] delay,\n    output reg q\n);\n\nreg [2:0] shift_reg;\nreg [3:0] delay_counter;\n\nalways @(posedge clk) begin\n    // Shift the register\n    shift_reg <= {shift_reg[1:0], d};\n\n    // Update the delay counter\n    if (delay_counter == delay) begin\n        // Output the delayed value\n        q <= shift_reg[2];\n        delay_counter <= 0;\n    end else begin\n        delay_counter <= delay_counter + 1;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mem_wb_reg_8360db9f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mem_wb_reg\n#(\n   parameter DATA_WIDTH = 32,\n   parameter INSTRUCTION_WIDTH = 32,\n   parameter REG_ADDR_WIDTH = 5\n  )\n(\n   input clk,\n   input rst_n,\n   input en,\n   input write_back_mux_sel_in,\n   input [DATA_WIDTH-1:0] alu_data_in,\n   input [DATA_WIDTH-1:0] hi_data_in,\ninput [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_in,\n   input [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_in,\n   input reg_a_wr_en_in,\n   input reg_b_wr_en_in,\n   input [INSTRUCTION_WIDTH-1:0] instruction_in,\n\n   output reg write_back_mux_sel_out,\n   output reg [DATA_WIDTH-1:0] alu_data_out,\n   output reg [DATA_WIDTH-1:0] hi_data_out,\noutput reg [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_out,\n   output reg [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_out,\n   output reg reg_a_wr_en_out,\n   output reg reg_b_wr_en_out,\n   output reg [INSTRUCTION_WIDTH-1:0] instruction_out\n);\n\n\n\nalways@(posedge clk or negedge rst_n) begin\n   if(~rst_n) begin\n      write_back_mux_sel_out <= 0;\n      alu_data_out <= 0;\n      hi_data_out <= 0;\nreg_a_wr_addr_out <= 0;\n      reg_b_wr_addr_out <= 0;\n      reg_a_wr_en_out <= 0;\n      reg_b_wr_en_out <= 0;\n      instruction_out <= 0;\n   end\n   else if(en) begin\n      write_back_mux_sel_out <= write_back_mux_sel_in;\n      alu_data_out <= alu_data_in;\n      hi_data_out <= hi_data_in;\nreg_a_wr_addr_out <= reg_a_wr_addr_in;\n      reg_b_wr_addr_out <= reg_b_wr_addr_in;\n      reg_a_wr_en_out <= reg_a_wr_en_in;\n      reg_b_wr_en_out <= reg_b_wr_en_in;\n      instruction_out <= instruction_in;\n   end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_85443240", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input CI,\n    output [3:0] SUM,\n    output CO\n);\n\n    wire C1, C2, C3;\n\n    // Instantiate 4-bit full adder cells\n    full_adder FA0(A[0], B[0], CI, SUM[0], C1);\n    full_adder FA1(A[1], B[1], C1, SUM[1], C2);\n    full_adder FA2(A[2], B[2], C2, SUM[2], C3);\n    full_adder FA3(A[3], B[3], C3, SUM[3], CO);\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input CI,\n    output SUM,\n    output CO\n);\n\n    // Assign Sum and Carry Out using XOR and AND gates\n    assign SUM = A ^ B ^ CI;\n    assign CO = (A & B) | (B & CI) | (A & CI);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_to_binary_d52bd042", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gray_to_binary (\n    input [3:0] G,\n    output reg [3:0] B\n);\n\nalways @* begin\n    B[3] = G[3];\n    B[2] = G[3] ^ G[2];\n    B[1] = G[2] ^ G[1];\n    B[0] = G[1] ^ G[0];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parallel_load_shift_98bc7a21", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule parallel_load_shift (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [2:0] shift_amount,\n  output reg [7:0] shift_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      shift_out <= 8'b0;\n    end else begin\n      shift_out <= {shift_out[7-shift_amount:0], data_in};\n    end\n  end\n\nendmodule\nmodule combinational_circuit (\n  input [49:0] in,\n  output wire out_nand,\n  output wire out_nor,\n  output wire out_xnor\n);\n\n  assign out_nand = ~(&in);\n  assign out_nor = ~(|in);\n  assign out_xnor = ~(^in);\n\nendmodule\nmodule functional_module (\n  input [7:0] shift_out,\n  input [49:0] in,\n  output reg [49:0] final_output\n);\n\n  always @(*) begin\n    final_output = shift_out & in;\n  end\n\nendmodule\nmodule top_module (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [2:0] shift_amount,\n  input [49:0] in,\n  input select,\n  output [7:0] shift_out,\n  output wire out_nand,\n  output wire out_nor,\n  output wire out_xnor,\n  output reg [49:0] final_output\n);\n\n  wire [7:0] shift_out_wire;\n  wire [49:0] in_wire;\n\n  parallel_load_shift shift_module (\n    .clk(clk),\n    .reset(reset),\n    .data_in(data_in),\n    .shift_amount(shift_amount),\n    .shift_out(shift_out_wire)\n  );\n\n  combinational_circuit comb_module (\n    .in(in),\n    .out_nand(out_nand),\n    .out_nor(out_nor),\n    .out_xnor(out_xnor)\n  );\n\n  functional_module func_module (\n    .shift_out(shift_out_wire),\n    .in(in_wire),\n    .final_output(final_output)\n  );\n\n  assign in_wire = select ? 50'b0 : in;\n  assign shift_out = shift_out_wire;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "srlc32e_10ed3958", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule srlc32e(\n    input [31:0] D,\n    input CLK,\n    input CE,\n    input A,\n    output Q\n);\n\n    reg [31:0] Q_reg;\n\n    always @(posedge CLK) begin\n        if (CE) begin\n            Q_reg <= D;\n        end\n    end\n\n    assign Q = Q_reg[A];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "byte_en_reg_98891828", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule byte_en_reg (\n    clk,\n    rst,\n    we,\n    en,\n    d,\n    q\n    );\n\nparameter DATA_W = 32;\nparameter INIT_VAL = {DATA_W{1'b0}};\n\ninput clk;\ninput rst;\ninput we;\ninput [(DATA_W-1)/8:0] en;\ninput [DATA_W-1:0] d;\noutput reg [DATA_W-1:0] q;\n\ninteger i;\n\nalways @(posedge clk or posedge rst)\nbegin\n    if (rst == 1)\n        q <= INIT_VAL;\n    else\n        for (i = 0; i < DATA_W; i = i + 1)\n            if (we && en[i/8])\n                q[i] <= d[i];\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__aa0ee660", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n  input clk,\n  input reset,\n  output reg [3:0] binary_number\n);\n\n  reg [3:0] binary_num_reg;\n  reg [2:0] ones_count_reg;\n  \n  binary_ones_counter ones_counter(.binary_in(binary_num_reg), .clk(clk), .reset(reset), .ones_count(ones_count_reg));\n  \n  always @(posedge clk) begin\n    binary_num_reg <= binary_num_reg + 1;\n  end\n  \n  always @(posedge clk) begin\n    if (ones_count_reg > binary_num_reg) begin\n      binary_number <= ones_count_reg;\n    end else begin\n      binary_number <= binary_num_reg;\n    end\n  end\n  \nendmodule\n\nmodule binary_ones_counter (\n  input [3:0] binary_in,\n  input clk,\n  input reset,\n  output reg [2:0] ones_count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      ones_count <= 0;\n    end else begin\n      case (binary_in)\n        4'b0000: ones_count <= 0;\n        4'b0001: ones_count <= 1;\n        4'b0010: ones_count <= 1;\n        4'b0011: ones_count <= 2;\n        4'b0100: ones_count <= 1;\n        4'b0101: ones_count <= 2;\n        4'b0110: ones_count <= 2;\n        4'b0111: ones_count <= 3;\n        4'b1000: ones_count <= 1;\n        4'b1001: ones_count <= 2;\n        4'b1010: ones_count <= 2;\n        4'b1011: ones_count <= 3;\n        4'b1100: ones_count <= 2;\n        4'b1101: ones_count <= 3;\n        4'b1110: ones_count <= 3;\n        4'b1111: ones_count <= 4;\n      endcase\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "LUT #_de6150d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule LUT # (parameter SIZE=8)\n(\n input wire [SIZE-1:0] A,\n input wire [1:0] B,\n output reg [SIZE+1:0] Result\n);\n\nwire [SIZE+1:0] wD0, wD1, wD2, wD3;\n\nassign wD1 = {2'b0, A};\nassign wD0 = wD1 ^ wD1; // Esto siempre es cero, de la longitud adecuada.\nassign wD2 = {1'b0, A, 1'b0}; \nassign wD3 = {2'b0, A, 2'b0};\n\nalways @ (A, B)\nbegin\n\tcase (B)\n\t//-------------------------------------\t\n\t2'b00:\n\tbegin\n\t\tResult <= wD0;\n\tend\n\t//-------------------------------------\t\n\t2'b01:\n\tbegin\n\t\tResult <= wD1;\n\tend\n\t//-------------------------------------\t\n\t2'b10:\n\tbegin\n\t\tResult <= wD2;\n\tend\n\t//-------------------------------------\t\n\t2'b11:\n\tbegin\n\t\tResult <= wD3;\n\tend\n\t//-------------------------------------\t\n\tendcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_58eb7a65", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule comparator (\n    input [3:0] in0,\n    input [3:0] in1,\n    output reg [1:0] result\n);\n\nreg [3:0] in0_reg;\nreg [3:0] in1_reg;\n\n\nalways @(in0, in1) begin\n    in0_reg <= in0;\n    in1_reg <= in1;\n\n    if (in0_reg > in1_reg) begin\n        result <= 2'b01;\n    end else if (in0_reg < in1_reg) begin\n        result <= 2'b10;\n    end else begin\n        result <= 2'b00;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tri_light_svetofor_67aa3d5d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule tri_light_svetofor (\tinput wire time_signal,\n\t\tinput wire reset,\n\t\toutput wire red,\n\t\toutput wire yellow,\n\t\toutput wire green\t\t\n\t\t);\n\tparameter green_time = 8'd26 * 8'd2,  red_time = 8'd84 * 8'd2,\n\tyellow_time = 8'd3 * 8'd2,\n\tblnk_time = 8'd4 * 8'd2,\n\ttril_time = green_time + blnk_time + red_time + yellow_time * 8'd2;\n\t\n\treg [7:0] timer; \treg [2:0] sel_color; assign red = sel_color[0];\n\tassign yellow = sel_color[1];\n\tassign green = sel_color[2];\n\t\n\talways @(posedge time_signal or negedge reset)\n\tbegin\n\t\tif (!reset) begin\t\t\t\t\t\t\ttimer <= 8'd0;\n\t\t\t\tsel_color <= 3'b110; end\n\t\telse begin if (timer < tril_time)\ttimer <= timer + 8'd1; else\n\t\t\t\t\ttimer <= 8'd0; \tif (timer <= red_time) sel_color <= 3'b110; if (timer > red_time && timer <= red_time + yellow_time) sel_color <= 3'b100; if (timer > red_time + yellow_time && timer <= red_time + yellow_time + green_time) sel_color <= 3'b011; if (timer > red_time + yellow_time + green_time && timer <= red_time + yellow_time + green_time + blnk_time)\n\t\t\t\t\tif (sel_color == 3'b011)\n\t\t\t\t\t\tsel_color <= 3'b111; else\n\t\t\t\t\t\tsel_color <= 3'b011; if\t(timer > red_time + yellow_time + green_time + blnk_time)\n\t\t\t\t\tsel_color <= 3'b101; end\n\t\t\n\tend\t\n\t\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_stall_be4beb75", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_stall (\n\tcw_from_cu, \n\tmux_op, \n\tcw_from_mux);\n   input [22:0] cw_from_cu;\n   input mux_op;\n   output [22:0] cw_from_mux;\n\n   // Internal wires\n   wire n2;\n\n   // Generate n2\n   assign n2 = mux_op; // fixed the polarity\n\n   // Implement the multiplexing logic\n   assign cw_from_mux[0] = cw_from_cu[0] & n2;\n   assign cw_from_mux[1] = cw_from_cu[1] & n2;\n   assign cw_from_mux[2] = cw_from_cu[2] & n2;\n   assign cw_from_mux[3] = cw_from_cu[3] & n2;\n   assign cw_from_mux[4] = cw_from_cu[4] & n2;\n   assign cw_from_mux[5] = cw_from_cu[5] & n2;\n   assign cw_from_mux[6] = cw_from_cu[6] & n2;\n   assign cw_from_mux[7] = cw_from_cu[7] & n2;\n   assign cw_from_mux[8] = cw_from_cu[8] & n2;\n   assign cw_from_mux[9] = cw_from_cu[9] & n2;\n   assign cw_from_mux[10] = cw_from_cu[10] & n2;\n   assign cw_from_mux[11] = cw_from_cu[11] & n2;\n   assign cw_from_mux[12] = cw_from_cu[12] & n2;\n   assign cw_from_mux[13] = cw_from_cu[13] & n2;\n   assign cw_from_mux[14] = cw_from_cu[14] & n2;\n   assign cw_from_mux[15] = cw_from_cu[15] & n2;\n   assign cw_from_mux[16] = cw_from_cu[16] & n2;\n   assign cw_from_mux[17] = cw_from_cu[17] & n2;\n   assign cw_from_mux[18] = cw_from_cu[18] & n2;\n   assign cw_from_mux[19] = cw_from_cu[19] & n2;\n   assign cw_from_mux[20] = cw_from_cu[20] & n2;\n   assign cw_from_mux[21] = cw_from_cu[21] & n2;\n   assign cw_from_mux[22] = cw_from_cu[22] & n2;\n\n   // Select between the two inputs based on the mux_op value\n   assign cw_from_mux = cw_from_mux; // fixed the extra mux_op in the assignment\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "encoder_dbc2bbbc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule encoder(in,out);\ninput [39:0] in;\noutput [5:0] out;\n\nassign out =  (in[0]==1'b1)?6'd0:\n              (in[1]==1'b1)?6'd1:\n\t\t\t  (in[2]==1'b1)?6'd2:\n\t\t\t  (in[3]==1'b1)?6'd3:\n\t\t\t  (in[4]==1'b1)?6'd4:\n\t\t\t  (in[5]==1'b1)?6'd5:\n\t\t\t  (in[6]==1'b1)?6'd6:\n\t\t\t  (in[7]==1'b1)?6'd7:\n\t\t\t  (in[8]==1'b1)?6'd8:\n\t\t\t  (in[9]==1'b1)?6'd9:\n\t\t\t  (in[10]==1'b1)?6'd10:\n\t\t\t  (in[11]==1'b1)?6'd11:\n\t\t\t  (in[12]==1'b1)?6'd12:\n\t\t\t  (in[13]==1'b1)?6'd13:\n\t\t\t  (in[14]==1'b1)?6'd14:\n\t\t\t  (in[15]==1'b1)?6'd15:\n\t\t\t  (in[16]==1'b1)?6'd16:\n\t\t\t  (in[17]==1'b1)?6'd17:\n\t\t\t  (in[18]==1'b1)?6'd18:\n\t\t\t  (in[19]==1'b1)?6'd19:\n\t\t\t  (in[20]==1'b1)?6'd20:\n\t\t\t  (in[21]==1'b1)?6'd21:\n\t\t\t  (in[22]==1'b1)?6'd22:\n\t\t\t  (in[23]==1'b1)?6'd23:\n\t\t\t  (in[24]==1'b1)?6'd24:\n\t\t\t  (in[25]==1'b1)?6'd25:\n\t\t\t  (in[26]==1'b1)?6'd26:\n\t\t\t  (in[27]==1'b1)?6'd27:\n\t\t\t  (in[28]==1'b1)?6'd28:\n\t\t\t  (in[29]==1'b1)?6'd29:\n\t\t\t  (in[30]==1'b1)?6'd30:\n\t\t\t  (in[31]==1'b1)?6'd31:\n\t\t\t  (in[32]==1'b1)?6'd32:\n\t\t\t  (in[33]==1'b1)?6'd33:\n\t\t\t  (in[34]==1'b1)?6'd34:\n\t\t\t  (in[35]==1'b1)?6'd35:\n\t\t\t  (in[36]==1'b1)?6'd36:\n\t\t\t  (in[37]==1'b1)?6'd37:\n\t\t\t  (in[38]==1'b1)?6'd38:\n\t\t\t  (in[39]==1'b1)?6'd39:\n\t\t\t  6'b000000;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spi_shift_9e701e4d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule spi_shift (\n  input clk, rst, go, pos_edge, neg_edge, rx_negedge, tx_negedge, lsb, s_clk,\n  input [17:0] p_in,\n  input [7:0] len,\n  output reg tip, \n  output last, //reg last; cannot be driven by primitives or continuous assignment.\n  output reg [17:0] p_out,\n  output reg s_out\n);\n\n  parameter Tp = 1;\n  parameter SPI_CHAR_LEN_BITS = 8;\n  parameter SPI_MAX_CHAR = 18;\n\n  reg [SPI_CHAR_LEN_BITS:0] cnt;\n  reg [SPI_MAX_CHAR-1:0] data;\n  wire [SPI_CHAR_LEN_BITS:0] tx_bit_pos;\n  wire [SPI_CHAR_LEN_BITS:0] rx_bit_pos;\n  wire rx_clk;\n  wire tx_clk;\n\n  assign tx_bit_pos = lsb ? {!(|len), len} - cnt : cnt - {{SPI_CHAR_LEN_BITS{1'b0}},1'b1};\n  assign rx_bit_pos = lsb ? {!(|len), len} - (rx_negedge ? cnt + {{SPI_CHAR_LEN_BITS{1'b0}},1'b1} : cnt) :\n                            (rx_negedge ? cnt : cnt - {{SPI_CHAR_LEN_BITS{1'b0}},1'b1});\n\n  //assign last = !(|cnt);\n  reg last_int;\n  always @(posedge clk or posedge rst) begin\n    if(rst) last_int <= #Tp 1'b0;\n    else last_int <= #Tp !(|cnt);\n  end\n  assign last = last_int;\n\n  assign rx_clk = (rx_negedge ? neg_edge : pos_edge) && (!last || s_clk);\n  assign tx_clk = (tx_negedge ? neg_edge : pos_edge) && !last;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) cnt <= #Tp {SPI_CHAR_LEN_BITS+1{1'b0}};\n    else begin\n      if(tip) cnt <= #Tp pos_edge ? (cnt - {{SPI_CHAR_LEN_BITS{1'b0}}, 1'b1}) : cnt;\n      else cnt <= #Tp !(|len) ? {1'b1, {SPI_CHAR_LEN_BITS{1'b0}}} : {1'b0, len};\n    end\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) s_out <= #Tp 1'b0;\n    else s_out <= #Tp (tx_clk || !tip) ? data[tx_bit_pos[SPI_CHAR_LEN_BITS-1:0]] : s_out;\n  end\n\n  always @(posedge s_clk or posedge rst) begin\n    if (rst) data <= #Tp {SPI_MAX_CHAR{1'b0}};\n    else data <= #Tp {data[SPI_MAX_CHAR-2:0], p_in};\n  end\n\n  always @(posedge s_clk or posedge rst) begin\n    if (rst) p_out <= #Tp {18{1'b0}};\n    else p_out <= #Tp {data[17:0], 1'b0};\n  end\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) tip <= #Tp 1'b0;\n    else if (go && ~tip) tip <= #Tp 1'b1;\n    else if (tip && last && pos_edge) tip <= #Tp 1'b0;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_counter_b5145ac4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gray_counter (\n    input clk,\n    input rst,\n    input ena,\n    output reg [3:0] q\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            q <= 4'b0000;\n        end\n        else if (ena) begin\n            q <= q ^ (q >> 1);\n        end\n        else begin\n            q <= q ^ (q >> 1) ^ 4'b0001;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_e722fb84", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n  input clk,\n  input reset,\n  output [3:0] count\n);\n\nreg [3:0] temp_count;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    temp_count <= 4'b0000;\n  end\n  else begin\n    if (temp_count == 4'b0111) begin\n      temp_count <= 4'b0000;\n    end\n    else begin\n      temp_count <= temp_count + 1;\n    end\n  end\nend\n\nassign count = temp_count;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "half_adder_11018023", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule half_adder(\n    input a, b,\n    output sum, cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_module_73611294", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_sub_module(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\n    wire [31:0] inverted_b;\n    wire [31:0] carry_out;\n    wire [31:0] temp_sum;\n\n    assign inverted_b = ~b;\n\n    // Adder module\n    adder_module adder(\n        .a(a),\n        .b(inverted_b),\n        .carry_in(sub),\n        .sum(temp_sum),\n        .carry_out(carry_out)\n    );\n\n    // XOR gate\n    assign sum = (sub) ? temp_sum + 1 : temp_sum;\n\nendmodule\n\nmodule adder_module(\n    input [31:0] a,\n    input [31:0] b,\n    input carry_in,\n    output [31:0] sum,\n    output [31:0] carry_out\n);\n\n    assign {carry_out, sum} = a + b + carry_in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pulse_generator_8e18a231", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pulse_generator(\n    input clk,\n    input reset,\n    input in,\n    output reg p,\n    output reg l\n);\n\n    reg [18:0] r;\n    reg [1:0] state;\n    parameter IDLE = 2'b00, COUNTING = 2'b01, PULSE = 2'b10;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            r <= 0;\n            l <= 0;\n            state <= IDLE;\n        end else begin\n            case(state)\n                IDLE: begin\n                    if (in) begin\n                        state <= COUNTING;\n                        r <= 0;\n                        l <= 1;\n                    end else begin\n                        l <= 0;\n                    end\n                end\n                COUNTING: begin\n                    if (r == 250000) begin\n                        state <= PULSE;\n                        r <= 0;\n                        p <= 1;\n                    end else begin\n                        r <= r + 1;\n                        l <= 1;\n                        p <= 0;\n                    end\n                end\n                PULSE: begin\n                    if (in) begin\n                        state <= COUNTING;\n                        r <= 0;\n                        p <= 0;\n                        l <= 1;\n                    end else begin\n                        l <= 0;\n                        p <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_adder_42bbb554", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_adder(\n    input [3:0] in1,\n    input [3:0] in2,\n    input ctrl,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] temp_sum;\n    assign temp_sum = {1'b0, in1} + {1'b0, in2};\n\n    assign sum = (ctrl == 1'b0) ? temp_sum[3:0] : temp_sum[4];\n    assign cout = temp_sum[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rj_memory_c15048fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rj_memory (input wr_en, rd_en, Sclk,\n\t\t\t\t\t\tinput [3:0] rj_wr_addr, rj_rd_addr,\n\t\t\t\t\t\tinput [15:0] data_in,\n\t\t\t\t\t\toutput [15:0] rj_data);\n\n\treg [15:0] rj_mem [0:15];\n\n\talways @(negedge Sclk)\n\tbegin\n\t\tif(wr_en == 1'b1)\n\t\t\trj_mem[rj_wr_addr] = data_in;\n\t\telse\n\t\t\trj_mem[rj_wr_addr] = rj_mem[rj_wr_addr];\t\t\n\tend\n\n\tassign rj_data = (rd_en) ? rj_mem[rj_rd_addr] : 16'd0;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "burst_counter_27618158", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule burst_counter(\n    input wire bclk,\n    input wire [15:0] bus_ad,\n    input wire [2:0] bus_a,\n    input wire adv,\n    input wire rw,\n    input wire cs,\n    output reg [15:0] measured_burst\n);\n\n    reg [15:0] burstcnt;   // counts the number of burst cycles\n    reg [15:0] finalcnt;   // stores the number of burst cycles from the previous memory access operation\n    reg activated;         // indicates whether the memory access operation is occurring\n    reg activated_d;       // stores the value of activated from the previous clock cycle\n    reg [15:0] bus_ad_r;   // stores the value of bus_ad from the previous clock cycle\n    reg [2:0] bus_a_r;     // stores the value of bus_a from the previous clock cycle\n    reg cs_r;              // stores the value of cs from the previous clock cycle\n    reg rw_r;              // stores the value of rw from the previous clock cycle\n    reg adv_r;             // stores the value of adv from the previous clock cycle\n    \n    always @(posedge bclk) begin\n        // store the values of the input signals from the previous clock cycle\n        bus_ad_r <= bus_ad;\n        bus_a_r <= bus_a;\n        cs_r <= cs;\n        rw_r <= rw;\n        adv_r <= adv;\n        \n        // check if the memory access operation is occurring\n        if (cs_r && adv_r && ({bus_a_r, bus_ad_r[15:12]} == 7'h4_F)) begin\n            activated <= 1'b1;\n        end else if (!cs_r) begin\n            activated <= 1'b0;\n        end else begin\n            activated <= activated;\n        end\n        \n        // count the number of burst cycles during the memory access operation\n        if (!activated) begin\n            finalcnt <= burstcnt;\n            burstcnt <= 16'h0;\n        end else begin\n            burstcnt <= burstcnt + 16'h1;\n            finalcnt <= finalcnt;\n        end\n        \n        // output the number of burst cycles on the falling edge of activated\n        activated_d <= activated;\n        if (activated_d & !activated) begin\n            measured_burst <= finalcnt + 1'b1;\n        end else begin\n            measured_burst <= measured_burst;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__bufinv_43db5357", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__bufinv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "divider #_dcd19fdd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule divider #(\n  parameter n = 8 // number of bits in dividend and divisor\n) (\n  input signed [n-1:0] dividend,\n  input signed [n-1:0] divisor,\n  output signed [n-1:0] quotient,\n  output signed [n-1:0] remainder\n);\n\nparameter signed_div = 1; // 1 for signed division, 0 for unsigned division\n\nreg signed [n-1:0] dividend_reg;\nreg signed [n-1:0] divisor_reg;\nreg signed [n-1:0] quotient_reg;\nreg signed [n-1:0] remainder_reg;\nreg signed [n-1:0] dividend_abs;\nreg signed [n-1:0] divisor_abs;\nreg signed [n-1:0] quotient_abs;\nreg signed [n-1:0] remainder_abs;\nreg signed [n-1:0] dividend_sign;\nreg signed [n-1:0] divisor_sign;\nreg signed [n-1:0] quotient_sign;\n\nalways @(*) begin\n  // Absolute value of dividend and divisor\n  if (dividend < 0) begin\n    dividend_abs = -dividend;\n    dividend_sign = -1;\n  end else begin\n    dividend_abs = dividend;\n    dividend_sign = 1;\n  end\n  \n  if (divisor < 0) begin\n    divisor_abs = -divisor;\n    divisor_sign = -1;\n  end else begin\n    divisor_abs = divisor;\n    divisor_sign = 1;\n  end\n  \n  // Perform division\n  if (divisor == 0) begin\n    quotient_reg = 'bx;\n    remainder_reg = 'bx;\n  end else if (signed_div) begin\n    // Signed division\n    if (dividend_sign == divisor_sign) begin\n      quotient_abs = dividend_abs / divisor_abs;\n      remainder_abs = dividend_abs % divisor_abs;\n      quotient_sign = dividend_sign;\n    end else begin\n      quotient_abs = (dividend_abs + divisor_abs - 1) / divisor_abs;\n      remainder_abs = dividend_abs - quotient_abs * divisor_abs;\n      quotient_sign = -dividend_sign;\n    end\n  end else begin\n    // Unsigned division\n    quotient_abs = dividend_abs / divisor_abs;\n    remainder_abs = dividend_abs % divisor_abs;\n    quotient_sign = 1;\n  end\n  \n  // Apply sign to quotient and remainder\n  quotient_reg = quotient_abs * quotient_sign;\n  remainder_reg = remainder_abs * dividend_sign;\nend\n\nassign quotient = quotient_reg;\nassign remainder = remainder_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register_ctrl_top_98d78aa2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule register_ctrl_top(\n    input                             I_sys_clk           , \n    input                             I_sys_rst           ,\n    output                            O_usb_uart_tx_req   ,\n    output   [7 : 0]                  O_usb_uart_tx_data  ,\n    input                             I_usb_uart_tx_full  ,\n    \n    output                            O_usb_uart_rx_req   ,\n    input    [7 : 0]                  I_usb_uart_rx_data  ,\n    input                             I_usb_uart_rx_empty ,    \n    output                            O_usb_dir           ,\n\t \n    output                            O_motor_start       ,\n    \n    output                            tp                  ,\n\t \n    input                             I_key_start\n);\nreg                                   R_usb_uart_rx_req     ;\nreg                                   R_usb_uart_rx_req_d1  ;\n\nreg                                   R_tx_en       ;\nreg          [7 : 0]                  R_tx_data     ;\n\nreg                                   R_rx_en       ;\nreg          [7 : 0]                  R_rx_data     ;\n\nreg                                   R_usb_dir     ;\n\nreg                                   R_motor_start ;\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_usb_uart_rx_req     <= 1'd0     ;\n        end\n    else if(I_usb_uart_rx_empty == 1'b0)       begin\n            R_usb_uart_rx_req     <= 1'd1     ;\n        end\n    else\n        begin\n            R_usb_uart_rx_req     <= 1'd0     ;\n        end\n        \n    R_usb_uart_rx_req_d1          <= R_usb_uart_rx_req;\nend\n\n\n\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_rx_en       <= 1'd0   ;\n            R_rx_data     <= 8'd0  ;\n        end\n    else if(R_usb_uart_rx_req_d1 == 1'b1)\n        begin\n            R_rx_en       <= 1'd1   ;\n            R_rx_data     <= I_usb_uart_rx_data  ;\n        end\n    else\n        begin\n            R_rx_en       <= 1'd0   ;\n        end\nend\n\n\n\n\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_tx_en       <= 1'd0   ;\n            R_tx_data     <= 8'd0  ;\n        end\n    else if(I_usb_uart_tx_full==1'b0)           begin\n            if(I_key_start==1'b1)\n                begin\n                    R_tx_en       <= 1'b1  ;R_tx_data     <= 8'h55 ;end\n            else\n                begin\n                    R_tx_en       <= 1'b0  ;end\n        end\n    else\n        begin\n            R_tx_en       <= 1'b0  ;\n        end\nend \n\n\n \n\n\nalways@(posedge I_sys_clk)\nbegin\n    if(I_sys_rst)\n        begin\n            R_usb_dir       <= 1'd0;                    R_motor_start   <= 1'b0;\n        end\n    else if(R_rx_en)\n        begin\n            case(R_rx_data)\n                8'h00:\n                    begin\n                        R_usb_dir       <= 1'b0;      end\n                8'hff:\n                    begin\n                        R_usb_dir       <= 1'b1;     end\n                8'h02:\n                    begin\n                        R_motor_start   <= 1'b1;    end\n            endcase\n        end\n    else\n        begin\n            R_motor_start   <= 1'b0;\n        end\n        \nend\n\n\n\n\nassign O_usb_uart_rx_req   = R_usb_uart_rx_req;\n\nassign O_usb_uart_tx_req   = R_tx_en  ;\n\nassign O_usb_uart_tx_data  = R_tx_data;\n\nassign O_usb_dir           = R_usb_dir  ;\n\nassign O_motor_start       = R_motor_start;\n\nassign  tp                 = R_rx_en & (&R_rx_data) & O_motor_start & O_usb_dir;\n\n\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unknown_module_c473b84c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule\tHardRegister(Clock, Reset, Set, Enable, In, Out) ;\n\tparameter\t\t\t\tWidth = \t\t\t\t32,\n\t\t\t\t\t\t\tInitial =\t\t\t\t{Width{1'bx}},\n\t\t\t\t\t\t\tAsyncReset =\t\t\t0,\n\t\t\t\t\t\t\tAsyncSet =\t\t\t\t0,\n\t\t\t\t\t\t\tResetValue =\t\t\t{Width{1'b0}},\n\t\t\t\t\t\t\tSetValue =\t\t\t\t{Width{1'b1}};\n\tinput\t\t\t\t\tClock, Enable, Reset, Set;\n\tinput\t[Width-1:0]\t\tIn;\n\toutput reg [Width-1:0]\tOut =\t\t\t\t\tInitial ;\n\tgenerate if (AsyncReset) begin:AR\n\t\tif (AsyncSet) begin:AS\n\t\t\talways @ (posedge Clock or posedge Reset or posedge Set) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend else begin:SS\n\t\t\talways @ (posedge Clock or posedge Reset) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend\n\tend else begin:SR\n\t\tif (AsyncSet) begin:AS\n\t\t\talways @ (posedge Clock or posedge Set) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend else begin:SS\n\t\t\talways @ (posedge Clock) begin\n\t\t\t\tif (Reset) Out <=\t\t\t\t\tResetValue;\n\t\t\t\telse if (Set) Out <=\t\t\t\tSetValue;\n\t\t\t\telse if (Enable) Out <=\t\t\t\tIn;\n\t\t\tend\n\t\tend\n\tend endgenerate\n\tendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "qrs_refinement1_94a5fa22", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule qrs_refinement1(\n    output [15:0] q_begin_ref,\n    output [15:0] s_end_ref,\n    output [15:0] q_begin_l3_temp,\n    output [15:0] s_end_l3_temp,\n    input [15:0] q_begin_l3,\n    input [15:0] s_end_l3,\n    input swindow1_full,\n    input qwindow1_full,\n    input s_end_l3_flag,\n    input q_begin_l3_flag,\n    input [3:0] count1,\n    input [8:0] count2,\n    input clk,\n    input nReset\n);\n\nreg signed [15:0] q_begin_ref;\nreg signed [15:0] s_end_ref;\nreg signed [15:0] q_begin_l3_temp;\nreg signed [15:0] s_end_l3_temp;\n\nwire clk;\nwire nReset;\n\nalways @(posedge clk or negedge nReset) begin\n    if (!nReset) begin\n        q_begin_ref <= 0;\n        s_end_ref <= 0;\n        q_begin_l3_temp <= 0;\n        s_end_l3_temp <= 0;\n    end else begin\n        if (count1 == 2 && count2 == 1) begin\n            if (qwindow1_full == 1) begin\n                if (q_begin_l3_flag == 1) begin\n                    q_begin_l3_temp <= q_begin_l3 - 1;\n                end else begin\n                    q_begin_l3_temp <= q_begin_l3_temp;\n                end\n            end else begin\n                q_begin_l3_temp <= q_begin_l3_temp;\n            end\n\n            q_begin_ref <= q_begin_l3_temp << 3;\n\n            if (swindow1_full == 1) begin\n                if (s_end_l3_flag == 1) begin\n                    s_end_l3_temp <= s_end_l3 + 2;\n                end else begin\n                    s_end_l3_temp <= s_end_l3_temp;\n                end\n            end else begin\n                s_end_l3_temp <= s_end_l3_temp;\n            end\n\n            s_end_ref <= s_end_l3_temp << 3;\n        end else begin\n            q_begin_ref <= q_begin_ref;\n            s_end_ref <= s_end_ref;\n            q_begin_l3_temp <= q_begin_l3_temp;\n            s_end_l3_temp <= s_end_l3_temp;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "UnorderedSet #_27c0d753", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\n\nmodule UnorderedSet #(\n\tparameter DEPTH\t\t\t= 16,\tparameter ITER_SIZE\t\t= 4,\tparameter KEY_SIZE\t\t= 16\t) (\n\tinput wire\t\t\t\t\tclk,\n\n\tinput wire\t\t\t\t\tinsert_en,\t\tinput wire[KEY_SIZE-1:0]\tinsert_key,\t\toutput reg\t\t\t\t\tinsert_ok = 0,\tinput wire\t\t\t\t\titer_inc,\t\tinput wire\t\t\t\t\titer_begin,\t\tinput wire[ITER_SIZE-1:0]\titer_in,\t\toutput reg\t\t\t\t\titer_end = 0,\toutput reg[ITER_SIZE-1:0]\titer_next = 0,\toutput reg[KEY_SIZE-1:0]\titer_key = 0,\tinput wire\t\t\t\t\tremove_en,\t\tinput wire[ITER_SIZE-1:0]\tremove_iter\t\t);\n\n\tinteger i;\n\n\treg\t\t\t\t\tslot_valid[DEPTH-1:0];\n\treg[KEY_SIZE-1:0]\tslot_key[DEPTH-1:0];\n\n\tinitial begin\n\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\tslot_valid[i]\t<= 0;\n\t\t\tslot_key[i]\t\t<= 0;\n\t\tend\n\tend\n\n\treg\t\thit = 0;\n\n\talways @(*) begin\n\n\t\titer_end\t\t<= 1;\t\titer_next\t\t<= 0;\n\n\t\thit\t\t\t\t= 0;\n\n\t\tif(iter_begin) begin\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(slot_valid[i] && !hit) begin\n\t\t\t\t\thit\t\t\t= 1;\n\t\t\t\t\titer_end\t<= 0;\n\t\t\t\t\titer_next\t<= i;\n\t\t\t\t\titer_key\t<= slot_key[i];\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\telse if(iter_inc) begin\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(slot_valid[i] && !hit && (i > iter_in) ) begin\n\t\t\t\t\thit\t\t\t= 1;\n\t\t\t\t\titer_end\t<= 0;\n\t\t\t\t\titer_next\t<= i;\n\t\t\t\t\titer_key\t<= slot_key[i];\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\tend\n\n\talways @(posedge clk) begin\n\n\t\tinsert_ok\t\t= 0;\n\n\t\tif(insert_en) begin\n\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(slot_valid[i] && (slot_key[i] == insert_key) ) begin\n\t\t\t\t\tinsert_ok\t\t= 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfor(i=0; i<DEPTH; i=i+1) begin\n\t\t\t\tif(!slot_valid[i] && !insert_ok) begin\n\t\t\t\t\tinsert_ok\t\t= 1;\n\t\t\t\t\tslot_valid[i]\t<= 1;\n\t\t\t\t\tslot_key[i]\t\t<= insert_key;\n\t\t\t\tend\n\t\t\tend\n\n\t\tend\n\n\t\tif(remove_en)\n\t\t\tslot_valid[remove_iter]\t<= 0;\n\n\tend\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_6982417b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1 (D0, D1, S, Y);\n    input [3:0] D0;\n    input [3:0] D1;\n    input [1:0] S;\n    output [3:0] Y;\n    \n    assign Y = (S == 2'b00) ? D0 :\n               (S == 2'b01) ? D1 :\n               (S == 2'b10) ? 4'b0100 :\n                              4'b0111 ;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__nand4b_5c013ccd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__nand4b (\n    Y  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N              );\n    nand nand0 (nand0_out_Y, D, C, B, not0_out);\n    buf  buf0  (Y          , nand0_out_Y      );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "LogicProbe_3e14da4f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule LogicProbe(clock, reset, trigger, sample, channels, serial_out);\n    input clock;\n    input reset;\n    input trigger;\n    input sample;\n    input [127:0] channels;\n    output serial_out;\n\n  wire full;\n  reg [12:0] rdaddr;\n  wire [7:0] data;\n  reg write;\n  wire ready;\n  reg done;\n  reg state;\n\n  LogicProbe_sampler\n    sampler(clock, reset, trigger, sample, channels, full, rdaddr, data);\n\n  LogicProbe_xmtbuf\n    xmtbuf(clock, reset, write, ready, data, serial_out);\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      rdaddr <= 13'd0;\n      write <= 0;\n      done <= 0;\n      state <= 0;\n    end else begin\n      if (full == 1 && done == 0) begin\n        if (state == 0) begin\n          if (ready == 1) begin\n            state <= 1;\n            write <= 1;\n          end\n        end else begin\n          if (rdaddr == 13'd8191) begin\n            done <= 1;\n          end\n          state <= 0;\n          write <= 0;\n          rdaddr <= rdaddr + 1;\n        end\n      end\n    end\n  end\n\nendmodule\n\n\nmodule LogicProbe_sampler(clock, reset, trigger, sample,\n                          data_in, full, rdaddr, data_out);\n    input clock;\n    input reset;\n    input trigger;\n    input sample;\n    input [127:0] data_in;\n    output reg full;\n    input [12:0] rdaddr;\n    output reg [7:0] data_out;\n\n  reg [31:0] mem3[0:511];\n  reg [31:0] mem2[0:511];\n  reg [31:0] mem1[0:511];\n  reg [31:0] mem0[0:511];\n\n  reg [8:0] wraddr;\n  wire [8:0] addr;\n  reg [31:0] data3;\n  reg [31:0] data2;\n  reg [31:0] data1;\n  reg [31:0] data0;\n\n  reg [3:0] muxctrl;\n  reg triggered;\n\n  assign addr = (full == 0) ? wraddr: rdaddr[12:4];\n\n  always @(posedge clock) begin\n    muxctrl <= rdaddr[3:0];\n  end\n\n  always @(*) begin\n    case (muxctrl)\n      4'h0: data_out = data3[31:24];\n      4'h1: data_out = data3[23:16];\n      4'h2: data_out = data3[15: 8];\n      4'h3: data_out = data3[ 7: 0];\n      4'h4: data_out = data2[31:24];\n      4'h5: data_out = data2[23:16];\n      4'h6: data_out = data2[15: 8];\n      4'h7: data_out = data2[ 7: 0];\n      4'h8: data_out = data1[31:24];\n      4'h9: data_out = data1[23:16];\n      4'hA: data_out = data1[15: 8];\n      4'hB: data_out = data1[ 7: 0];\n      4'hC: data_out = data0[31:24];\n      4'hD: data_out = data0[23:16];\n      4'hE: data_out = data0[15: 8];\n      4'hF: data_out = data0[ 7: 0];\n    endcase\n  end\n\n  always @(posedge clock) begin\n    if (full == 0) begin\n      mem3[addr] <= data_in[127:96];\n      mem2[addr] <= data_in[ 95:64];\n      mem1[addr] <= data_in[ 63:32];\n      mem0[addr] <= data_in[ 31: 0];\n    end\n    data3 <= mem3[addr];\n    data2 <= mem2[addr];\n    data1 <= mem1[addr];\n    data0 <= mem0[addr];\n  end\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      wraddr <= 9'd0;\n      triggered <= 0;\n      full <= 0;\n    end else begin\n      if (triggered == 1) begin\n        if (sample == 1) begin\n          if (wraddr == 9'd511) begin\n            full <= 1;\n          end else begin\n            wraddr <= wraddr + 1;\n          end\n        end\n      end else begin\n        if (trigger == 1) begin\n          triggered <= 1;\n          if (sample == 1) begin\n            wraddr <= wraddr + 1;\n          end\n        end\n      end\n    end\n  end\n\nendmodule\n\n\nmodule LogicProbe_xmtbuf(clock, reset, write, ready, data_in, serial_out);\n    input clock;\n    input reset;\n    input write;\n    output reg ready;\n    input [7:0] data_in;\n    output serial_out;\n\n  reg [1:0] state;\n  reg [7:0] data_hold;\n  reg load;\n  wire empty;\n\n  LogicProbe_xmt xmt(clock, reset, load, empty, data_hold, serial_out);\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      state <= 2'b00;\n      ready <= 1;\n      load <= 0;\n    end else begin\n      case (state)\n        2'b00:\n          begin\n            if (write == 1) begin\n              state <= 2'b01;\n              data_hold <= data_in;\n              ready <= 0;\n              load <= 1;\n            end\n          end\n        2'b01:\n          begin\n            state <= 2'b10;\n            ready <= 1;\n            load <= 0;\n          end\n        2'b10:\n          begin\n            if (empty == 1 && write == 0) begin\n              state <= 2'b00;\n              ready <= 1;\n              load <= 0;\n            end else\n            if (empty == 1 && write == 1) begin\n              state <= 2'b01;\n              data_hold <= data_in;\n              ready <= 0;\n              load <= 1;\n            end else\n            if (empty == 0 && write == 1) begin\n              state <= 2'b11;\n              data_hold <= data_in;\n              ready <= 0;\n              load <= 0;\n            end\n          end\n        2'b11:\n          begin\n            if (empty == 1) begin\n              state <= 2'b01;\n              ready <= 0;\n              load <= 1;\n            end\n          end\n      endcase\n    end\n  end\n\nendmodule\n\n\nmodule LogicProbe_xmt(clock, reset, load, empty, parallel_in, serial_out);\n    input clock;\n    input reset;\n    input load;\n    output reg empty;\n    input [7:0] parallel_in;\n    output serial_out;\n\n  reg [3:0] state;\n  reg [8:0] shift;\n  reg [10:0] count;\n\n  assign serial_out = shift[0];\n\n  always @(posedge clock) begin\n    if (reset == 1) begin\n      state <= 4'h0;\n      shift <= 9'b111111111;\n      empty <= 1;\n    end else begin\n      if (state == 4'h0) begin\n        if (load == 1) begin\n          state <= 4'h1;\n          shift <= { parallel_in, 1'b0 };\n          count <= 1302;\n          empty <= 0;\n        end\n      end else\n      if (state == 4'hb) begin\n        state <= 4'h0;\n        empty <= 1;\n      end else begin\n        if (count == 0) begin\n          state <= state + 1;\n          shift[8:0] <= { 1'b1, shift[8:1] };\n          count <= 1302;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nfa_accept_samples_generic_hw_start_indices_ram_3a536a2e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule nfa_accept_samples_generic_hw_start_indices_ram (addr0, ce0, d0, we0, q0,  clk);\n\nparameter DWIDTH = 32;\nparameter AWIDTH = 4;\nparameter MEM_SIZE = 16;\n\ninput[AWIDTH-1:0] addr0;\ninput ce0;\ninput[DWIDTH-1:0] d0;\ninput we0;\noutput reg[DWIDTH-1:0] q0;\ninput clk;\n\nreg [DWIDTH-1:0] ram[MEM_SIZE-1:0];\n\n\n\n\nalways @(posedge clk)  \nbegin \n    if (ce0) \n    begin\n        if (we0) \n        begin \n            ram[addr0] <= d0; \n            q0 <= d0;\n        end \n        else \n            q0 <= ram[addr0];\n    end\nend\n\n\nendmodule\n\nmodule nfa_accept_samples_generic_hw_start_indices(\n    reset,\n    clk,\n    address0,\n    ce0,\n    we0,\n    d0,\n    q0);\n\nparameter DataWidth = 32'd32;\nparameter AddressRange = 32'd16;\nparameter AddressWidth = 32'd4;\ninput reset;\ninput clk;\ninput[AddressWidth - 1:0] address0;\ninput ce0;\ninput we0;\ninput[DataWidth - 1:0] d0;\noutput[DataWidth - 1:0] q0;\n\n\n\n\nnfa_accept_samples_generic_hw_start_indices_ram nfa_accept_samples_generic_hw_start_indices_ram_U(\n    .clk( clk ),\n    .addr0( address0 ),\n    .ce0( ce0 ),\n    .d0( d0 ),\n    .we0( we0 ),\n    .q0( q0 ));\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "du_0e06137b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule du(clk, rst, deposit, select, price, ldRdeposit, ldRselect, ldRprice,\n\t\t\tldA, ldRproduct, ldRchange, ldRpurchase, ldMprice, ldMquantity,\n\t\t\tclrRdeposit, clrRselect, clrRprice, clrA, clrRproduct, clrRchange,\n\t\t\tclrRpurchase, purchase, refund, product, change);\n\tinput\tclk, rst;\n\tinput\t[9:0] deposit, price;\n\tinput\t[4:0] select;\n\tinput\tldRdeposit, ldRselect, ldRprice, ldA, ldRproduct, ldRchange;\n\tinput\tldRpurchase, ldMprice, ldMquantity, clrRdeposit, clrRselect;\n\tinput\tclrRprice, clrA, clrRproduct, clrRchange, clrRpurchase;\n\toutput reg\tpurchase, refund;\n\toutput reg\t[4:0] product;\n\toutput reg\t[9:0] change;\n\treg\t[9:0] Rdeposit, Rprice, Adeposit;\n\treg\t[4:0] Rselect;\n\treg\t[15:0] mem [0:31];\n\tinteger\ti;\n\n\tinitial begin\n\t\tfor (i=0;i<32;i=i+1) begin\n\t\t\tmem[i] = 16'h2864;\n\t\tend\n\t\tmem[0] = 16'b0000_0000_0011_0010; mem[1] = 16'b0010_1001_1001_0000; end\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tRdeposit <= 0;\n\t\telse if (ldRdeposit)\tRdeposit <= deposit;\n\t\telse if (clrRdeposit)\tRdeposit <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tRselect <= 0;\n\t\telse if (ldRselect)\t\tRselect <= select;\n\t\telse if (clrRselect)\tRselect <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\tRprice <= 0;\n\t\telse if (ldRprice)\tRprice <= price;\n\t\telse if (clrRprice)\tRprice <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\tAdeposit <= 0;\n\t\telse if (ldA)\tAdeposit <= Adeposit + Rdeposit;\n\t\telse if (clrA)\tAdeposit <= 0;\n\t\telse if (refund)\tAdeposit <= Adeposit - Rdeposit;\n\tend\n\n\talways @ (Adeposit) begin\n\t\tif (Adeposit > 500)\trefund = 1;\n\t\telse\t\t\t\trefund = 0;\n\tend\n\n\talways @ (Adeposit) begin\n\t\tfor (i=0; i<32;i=i+1) begin\n\t\t\tif (0 < mem[i][13:10] && Adeposit >= mem[i][9:0])\n\t\t\t\t\tmem[i][15] = 1;\n\t\t\telse\tmem[i][15] = 0;\n\t\tend\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\t\tpurchase <= 0;\n\t\telse if (ldRpurchase)\n\t\t\tif (mem[Rselect][15])\tpurchase <= 1;\n\t\t\telse\t\t\t\t\tpurchase <= 0;\n\t\telse if (clrRpurchase)\t\tpurchase <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tchange <= 0;\n\t\telse if (ldRchange)\t\tchange <= Adeposit - mem[Rselect][9:0];\n\t\telse if (clrRchange)\tchange <= 0;\n\tend\n\n\talways @ (negedge rst or posedge clk) begin\n\t\tif (rst == 0)\t\t\tproduct <= 0;\n\t\telse if (ldRproduct)\tproduct <= Rselect;\n\t\telse if (clrRproduct)\tproduct <= 0;\n\tend\n\n\talways @ (posedge clk) begin\n\t\tif (ldMquantity)\tmem[Rselect][13:10]\t<= mem[Rselect][13:10] - 1'b1;\n\t\tif (ldMprice)\t\tmem[Rselect][9:0]\t<= Rprice;\t\t\n\tend\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_nor4_dae3e5b5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_nor4 (\n    Y   ,\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    VPWR,\n    VGND\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n    \n    wire n1, n2, n3, n4;\n\n    nor (n1, A, B);\n    nor (n2, C, D);\n    nor (n3, n1, n2);\n    nor (n4, n3, n3);\n    nor (Y, n4, n4);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cdc_syncfifo #_07d30700", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n \n\nmodule cdc_syncfifo #(\n    parameter DSIZE = 34,\n    parameter ASIZE = 2\n) (\n    output wire [DSIZE-1:0] rdata,\n    output wire wfull,\n    output wire rempty,\n    input wire [DSIZE-1:0] wdata,\n    input wire winc, wclk, wrst,\n    input wire rinc, rclk, rrst\n);\n    \nwire [ASIZE-1:0] waddr, raddr;\nwire [ASIZE:0] wptr, rptr, wq2_rptr, rq2_wptr;\n\ncdc_sync_r2w #(.ADDRSIZE(ASIZE)) sync_r2w_inst (.wq2_rptr(wq2_rptr), .rptr(rptr),\n    .wclk(wclk), .wrst(wrst));\n\ncdc_sync_w2r #(.ADDRSIZE(ASIZE)) sync_w2r_inst (.rq2_wptr(rq2_wptr), .wptr(wptr),\n    .rclk(rclk), .rrst(rrst));\n\ncdc_fifomem #(.DATASIZE(DSIZE), .ADDRSIZE(ASIZE)) cdc_fifomem_inst\n(.rdata(rdata), .wdata(wdata),\n    .waddr(waddr), .raddr(raddr),\n    .wclken(winc), .wfull(wfull),\n    .wclk(wclk));\n\nrptr_empty #(.ADDRSIZE(ASIZE)) rptr_empty_inst\n(.rempty(rempty),\n    .raddr(raddr),\n    .rptr(rptr), .rq2_wptr(rq2_wptr),\n    .rinc(rinc), .rclk(rclk),\n    .rrst(rrst));\n\nwptr_full #(.ADDRSIZE(ASIZE)) wptr_full_inst\n(.wfull(wfull), .waddr(waddr),\n    .wptr(wptr), .wq2_rptr(wq2_rptr),\n    .winc(winc), .wclk(wclk),\n    .wrst(wrst));\n\nendmodule\n\nmodule cdc_fifomem #(\nparameter DATASIZE = 34, parameter ADDRSIZE = 2 ) (\n    output wire [DATASIZE-1:0] rdata,\n    input wire [DATASIZE-1:0] wdata,\n    input wire [ADDRSIZE-1:0] waddr, raddr,\n    input wire wclken, wfull, wclk\n);\n        \n        \nlocalparam DEPTH = 1<<ADDRSIZE;\nreg [DATASIZE-1:0] cdc_mem [0:DEPTH-1];\n\n\nassign rdata = cdc_mem[raddr];\nalways @(posedge wclk)\n    if (wclken && !wfull) cdc_mem[waddr] <= wdata;\n        \nendmodule\n\n\n\nmodule rptr_empty #(\n    parameter ADDRSIZE = 2\n) (\n    output reg rempty,\n    output wire [ADDRSIZE-1:0] raddr,\n    output reg [ADDRSIZE :0] rptr,\n    input wire [ADDRSIZE :0] rq2_wptr,\n    input wire rinc, rclk, rrst\n);\n    \nreg [ADDRSIZE:0] rbin;\nwire [ADDRSIZE:0] rgraynext, rbinnext;\nalways @(posedge rclk)\n    if (rrst) {rbin, rptr} <= 0;\n    else {rbin, rptr} <= {rbinnext, rgraynext};\n    \nassign raddr = rbin[ADDRSIZE-1:0];\nassign rbinnext = rbin + (rinc & ~rempty);\nassign rgraynext = (rbinnext>>1) ^ rbinnext;\nwire rempty_val;\nassign rempty_val = (rgraynext == rq2_wptr);\nalways @(posedge rclk)\n    if (rrst) rempty <= 1'b1;\n    else rempty <= rempty_val;\n        \nendmodule\n\nmodule wptr_full #(\n    parameter ADDRSIZE = 2\n) (\n    output reg wfull,\n    output wire [ADDRSIZE-1:0] waddr,\n    output reg [ADDRSIZE :0] wptr,\n    input wire [ADDRSIZE :0] wq2_rptr,\n    input wire winc, wclk, wrst\n);\n\nreg [ADDRSIZE:0] wbin;\nwire [ADDRSIZE:0] wgraynext, wbinnext;\nalways @(posedge wclk)\n    if (wrst) {wbin, wptr} <= 0;\n    else {wbin, wptr} <= {wbinnext, wgraynext};\nassign waddr = wbin[ADDRSIZE-1:0];\nassign wbinnext = wbin + (winc & ~wfull);\nassign wgraynext = (wbinnext>>1) ^ wbinnext;\nwire wfull_val;\nassign wfull_val = (wgraynext=={~wq2_rptr[ADDRSIZE:ADDRSIZE-1], wq2_rptr[ADDRSIZE-2:0]});\nalways @(posedge wclk)\n    if (wrst) wfull <= 1'b0;\n    else wfull <= wfull_val;\n        \nendmodule\n\nmodule cdc_sync_r2w #(\n    parameter ADDRSIZE = 2\n) (\n    output reg [ADDRSIZE:0] wq2_rptr,\n    input wire [ADDRSIZE:0] rptr,\n    input wire wclk, wrst\n);\n\nreg [ADDRSIZE:0] cdc_sync_wq1_rptr;\nalways @(posedge wclk)\n    if (wrst) {wq2_rptr,cdc_sync_wq1_rptr} <= 0;\n    else {wq2_rptr,cdc_sync_wq1_rptr} <= {cdc_sync_wq1_rptr,rptr};\n        \nendmodule\n\nmodule cdc_sync_w2r #(\n    parameter ADDRSIZE = 2\n) (\n    output reg [ADDRSIZE:0] rq2_wptr,\n    input wire [ADDRSIZE:0] wptr,\n    input wire rclk, rrst\n);\n\nreg [ADDRSIZE:0] cdc_sync_rq1_wptr;\nalways @(posedge rclk)\n    if (rrst) {rq2_wptr,cdc_sync_rq1_wptr} <= 0;\n    else {rq2_wptr,cdc_sync_rq1_wptr} <= {cdc_sync_rq1_wptr,wptr};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tkg_c3_aa6cf913", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule tkg_c3 (output o, input i0, i1, i2);\n\tC3 I0 (o, i0, i1, i2);\nendmodule\n\nmodule C3 (output o, input i0, i1, i2);\n\twire a, b, c, d, e;\n\t\n\tand (a, i0, i1);\n\tand (b, i0, i2);\n\tand (c, i1, i2);\n\tor (d, a, b);\n\tor (e, d, c);\n\t\n\tassign o = e;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spi_84aa3f1c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule spi (\n\t    input wire \t      clk,\n\t    input wire \t      resn,\n\t    input wire \t      trig,\n\t    output wire       done,\n\t    output reg [15:0] rdData,\n\t    input wire [15:0] wrData,\n\n\t    output reg \t      SCLK,\n\t    output reg \t      SS,\n\t    output reg \t      MOSI,\n\t    input wire \t      MISO\n\t    );\n   reg [3:0] \t\t      state;\n   reg [15:0] \t\t      bitCount;\n   reg [15:0] \t\t      clkCounter;\n\n   always @ (posedge clk) begin\n      clkCounter = clkCounter + 1;\n      if (clkCounter == 33) begin\n         SCLK <= !SCLK;\n      end\n   end\n\n   always @ (SCLK) begin\n      if (!resn) begin\n         SS <= 1;\n         MOSI <= 0;\n         state <= 0;\n         bitCount <= 0;\n      end else begin\n         case (state)\n           0: begin\n              if (trig) begin\n                 if (SCLK == 0) begin\n                    SS <= 0;\n                    state <= 1;\n                    bitCount <= 15;\n                 end\n              end\n           end\n\n           1: begin\n              if (SCLK == 0) begin\n                 MOSI <= wrData[bitCount];\n                 bitCount <= bitCount - 1;\n                 if (bitCount == 0) begin\n                    state <= 2;\n                 end\n              end else begin\n                 rdData[bitCount] <= MISO;\n              end\n           end\n\n           2: begin\n              if (SCLK == 1) begin\n                 SS <= 1;\n                 MOSI <= 0;\n                 state <= 0;\n                 bitCount <= 0;\n              end\n           end\n\n           default: ;\n         endcase\n      end\n   end\n\n   assign done = SS;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fir_mul_32s_32s_3bkb_MulnS_0_20d32a81", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fir_mul_32s_32s_3bkb_MulnS_0 (\n    clk,\n    reset,\n    ce,\n    a,\n    b,\n    p\n);\n\nparameter WIDTH = 32;\n\ninput clk;\ninput reset;\ninput ce;\ninput signed [WIDTH-1:0] a;\ninput signed [WIDTH-1:0] b;\noutput signed [WIDTH-1:0] p;\n\nreg signed [WIDTH-1:0] a_reg;\nreg signed [WIDTH-1:0] b_reg;\nreg signed [WIDTH-1:0] p_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        a_reg <= 0;\n        b_reg <= 0;\n        p_reg <= 0;\n    end else if (ce) begin\n        a_reg <= a;\n        b_reg <= b;\n        p_reg <= a_reg * b_reg;\n    end\nend\n\nassign p = p_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "db_sao_cal_diff_6140d763", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule db_sao_cal_diff(\n                   dp_i          ,\n                   op_i          , \n\t\t\t\t   data_valid_i  ,\n                   ominusdp_o    ,\n\t\t\t\t   index_o\n                ); \ninput           [  7:0 ]       dp_i              ;\ninput           [  7:0 ]       op_i              ;\ninput                          data_valid_i      ;\noutput          [287:0 ]       ominusdp_o        ;\noutput          [ 31:0 ]       index_o           ;\n\nwire  signed    [  8:0 ]       ominusdp_w        ;\nreg             [287:0 ]       ominusdp_t        ;\n\nreg             [ 31:0]        index_r           ;\n\nassign          ominusdp_w   =    op_i  -  dp_i  ;\n\n\nalways @* begin \n    case(dp_i[7:3])\n        5'd0 : begin ominusdp_t  = {279'b0,ominusdp_w       }; index_r = 32'b00000000000000000000000000000001 ; end \n        5'd1 : begin ominusdp_t  = {270'b0,ominusdp_w,  9'd0}; index_r = 32'b00000000000000000000000000000010 ; end \n        5'd2 : begin ominusdp_t  = {261'b0,ominusdp_w, 18'd0}; index_r = 32'b00000000000000000000000000000100 ; end \n        5'd3 : begin ominusdp_t  = {252'b0,ominusdp_w, 27'd0}; index_r = 32'b00000000000000000000000000001000 ; end \n        5'd4 : begin ominusdp_t  = {243'b0,ominusdp_w, 36'd0}; index_r = 32'b00000000000000000000000000010000 ; end \n        5'd5 : begin ominusdp_t  = {234'b0,ominusdp_w, 45'd0}; index_r = 32'b00000000000000000000000000100000 ; end \n        5'd6 : begin ominusdp_t  = {225'b0,ominusdp_w, 54'd0}; index_r = 32'b00000000000000000000000001000000 ; end \n        5'd7 : begin ominusdp_t  = {216'b0,ominusdp_w, 63'd0}; index_r = 32'b00000000000000000000000010000000 ; end \n        5'd8 : begin ominusdp_t  = {207'b0,ominusdp_w, 72'd0}; index_r = 32'b00000000000000000000000100000000 ; end \n        5'd9 : begin ominusdp_t  = {198'b0,ominusdp_w, 81'd0}; index_r = 32'b00000000000000000000001000000000 ; end \n\t\t5'd10: begin ominusdp_t  = {189'b0,ominusdp_w, 90'd0}; index_r = 32'b00000000000000000000010000000000 ; end \n\t\t5'd11: begin ominusdp_t  = {180'b0,ominusdp_w, 99'd0}; index_r = 32'b00000000000000000000100000000000 ; end \n\t\t5'd12: begin ominusdp_t  = {171'b0,ominusdp_w,108'd0}; index_r = 32'b00000000000000000001000000000000 ; end \n\t\t5'd13: begin ominusdp_t  = {162'b0,ominusdp_w,117'd0}; index_r = 32'b00000000000000000010000000000000 ; end \n\t\t5'd14: begin ominusdp_t  = {153'b0,ominusdp_w,126'd0}; index_r = 32'b00000000000000000100000000000000 ; end \n\t\t5'd15: begin ominusdp_t  = {144'b0,ominusdp_w,135'd0}; index_r = 32'b00000000000000001000000000000000 ; end \n\t\t5'd16: begin ominusdp_t  = {135'b0,ominusdp_w,144'd0}; index_r = 32'b00000000000000010000000000000000 ; end \n\t\t5'd17: begin ominusdp_t  = {126'b0,ominusdp_w,153'd0}; index_r = 32'b00000000000000100000000000000000 ; end \n\t\t5'd18: begin ominusdp_t  = {117'b0,ominusdp_w,162'd0}; index_r = 32'b00000000000001000000000000000000 ; end \n\t\t5'd19: begin ominusdp_t  = {108'b0,ominusdp_w,171'd0}; index_r = 32'b00000000000010000000000000000000 ; end \n\t\t5'd20: begin ominusdp_t  = { 99'b0,ominusdp_w,180'd0}; index_r = 32'b00000000000100000000000000000000 ; end \n\t\t5'd21: begin ominusdp_t  = { 90'b0,ominusdp_w,189'd0}; index_r = 32'b00000000001000000000000000000000 ; end \n\t\t5'd22: begin ominusdp_t  = { 81'b0,ominusdp_w,198'd0}; index_r = 32'b00000000010000000000000000000000 ; end \n\t\t5'd23: begin ominusdp_t  = { 72'b0,ominusdp_w,207'd0}; index_r = 32'b00000000100000000000000000000000 ; end \n\t\t5'd24: begin ominusdp_t  = { 63'b0,ominusdp_w,216'd0}; index_r = 32'b00000001000000000000000000000000 ; end \n\t\t5'd25: begin ominusdp_t  = { 54'b0,ominusdp_w,225'd0}; index_r = 32'b00000010000000000000000000000000 ; end \n\t\t5'd26: begin ominusdp_t  = { 45'b0,ominusdp_w,234'd0}; index_r = 32'b00000100000000000000000000000000 ; end \n\t\t5'd27: begin ominusdp_t  = { 36'b0,ominusdp_w,243'd0}; index_r = 32'b00001000000000000000000000000000 ; end \n\t\t5'd28: begin ominusdp_t  = { 27'b0,ominusdp_w,252'd0}; index_r = 32'b00010000000000000000000000000000 ; end \n\t\t5'd29: begin ominusdp_t  = { 18'b0,ominusdp_w,261'd0}; index_r = 32'b00100000000000000000000000000000 ; end \n\t\t5'd30: begin ominusdp_t  = {  9'b0,ominusdp_w,270'd0}; index_r = 32'b01000000000000000000000000000000 ; end \n\t\t5'd31: begin ominusdp_t  = {       ominusdp_w,279'd0}; index_r = 32'b10000000000000000000000000000000 ; end \n    endcase \nend \n\nassign   ominusdp_o = data_valid_i ? 287'd0 : ominusdp_t;\nassign   index_o    = data_valid_i ? 32'd0  : index_r   ;\n\n\nendmodule \n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add16_41048f84", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule add16(\n    input [15:0] a,   // First 16-bit input\n    input [15:0] b,   // Second 16-bit input\n    output [15:0] sum // 16-bit output sum\n);\n\n    assign sum = a + b;   // Add the two inputs and assign the result to the output\n\nendmodule\nmodule top_module(\n    input [31:0] a,       // First 32-bit input\n    input [31:0] b,       // Second 32-bit input\n    input [1:0] select,   // Select input to choose between inputs\n    input clk,            // Clock input\n    output [31:0] sum     // 32-bit output sum\n);\n\n    wire [15:0] adder1_out, adder2_out;  // Intermediate outputs of the 16-bit adders\n    wire [31:0] mux_out;                                        // Output of the 2:1 multiplexer\n\n    // Instantiate two 16-bit adders\n    add16 adder1(.a(a[15:0]), .b(b[15:0]), .sum(adder1_out));\n    add16 adder2(.a(a[31:16]), .b(b[31:16]), .sum(adder2_out));\n\n    // Implement the 2:1 multiplexer using combinational logic\n    assign mux_out = (select == 2'b0) ? a[31:0] : b[31:0];\n\n    // Combine the outputs of the adders and the multiplexer to get the final output\n    assign sum = {adder2_out, adder1_out} + mux_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_resettable_latch_780956c4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sync_resettable_latch(\n    input [3:0] D,\n    input EN,\n    input RST,\n    input CLK,\n    output reg [3:0] Q\n);\n\nalways @(posedge CLK) begin\n    if (EN) begin\n        Q <= D;\n    end else if (RST) begin\n        Q <= 4'b0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_calculator_083cfdb5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule simple_calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    input clk,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: out = a + b;\n        2'b01: out = a - b;\n        2'b10: out = a & b;\n        2'b11: out = a | b;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "three_input__64e58e80", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule three_input_module (\n    X ,\n    A1,\n    A2,\n    B1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    wire C1;\n    wire C2;\n\n    assign C1 = (A1 & A2) ? ~B1 : (A1 | A2);\n    assign C2 = (A1 & A2) ? C1 : B1;\n    assign X = (A1 & A2) ? C2 : (A1 & ~A2) ? ~B1 : (A1 | A2) ? B1 : 0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Cfu_5106013a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Cfu (\n  input               cmd_valid,\n  output              cmd_ready,\n  input      [9:0]    cmd_payload_function_id,\n  input      [31:0]   cmd_payload_inputs_0,\n  input      [31:0]   cmd_payload_inputs_1,\n  output              rsp_valid,\n  input               rsp_ready,\n  output     [31:0]   rsp_payload_outputs_0,\n  input               reset,\n  input               clk\n);\n\n  assign rsp_valid = cmd_valid;\n  assign cmd_ready = rsp_ready;\n\n  assign rsp_payload_outputs_0 = cmd_payload_function_id[0] ? \n                                           cmd_payload_inputs_1 :\n                                           cmd_payload_inputs_0 ;\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_751539f8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] s,\n    output cout\n);\n\n    wire [3:0] sum;\n    wire cout0, cout1, cout2;\n    \n    // full adder for least significant bit\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .s(sum[0]),\n        .cout(cout0)\n    );\n    \n    // full adder for second least significant bit\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(cout0),\n        .s(sum[1]),\n        .cout(cout1)\n    );\n    \n    // full adder for third least significant bit\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(cout1),\n        .s(sum[2]),\n        .cout(cout2)\n    );\n    \n    // full adder for most significant bit\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(cout2),\n        .s(sum[3]),\n        .cout(cout)\n    );\n    \n    assign s = sum;\n\nendmodule\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output s,\n    output cout\n);\n\n    wire sum1, sum2, sum3;\n    \n    // XOR gates to calculate sum\n    assign sum1 = a ^ b;\n    assign s = sum1 ^ cin;\n    \n    // AND gates to calculate carry out\n    assign sum2 = a & b;\n    assign sum3 = cin & sum1;\n    assign cout = sum2 | sum3;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__6326cc3e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [31:0] a, // 32-bit input for adder\n    input [31:0] b, // 32-bit input for adder\n    input select, // Select input to choose between decoder and functional module\n    output [7:0] out // 8-bit output from the active module\n);\n\n    wire [31:0] sum; // 32-bit sum output from the adder\n    wire [7:0] upper_byte; // 8-bit upper byte output from the decoder\n    wire [7:0] lower_byte; // 8-bit lower byte output from the decoder\n    wire [7:0] product; // 8-bit product output from the functional module\n\n    carry_select_adder adder(.a(a), .b(b), .sum(sum)); // Instantiate the carry select adder module\n    decoder_mux_16bit decoder(.in(sum[15:0]), .upper_byte(upper_byte), .lower_byte(lower_byte)); // Instantiate the decoder and multiplexer module\n    functional_module func(.a(upper_byte), .b(lower_byte), .out(product)); // Instantiate the functional module\n\n    assign out = select ? product : {upper_byte, lower_byte}; // Multiplexer to select between decoder and functional module based on select input\n\nendmodule\nmodule carry_select_adder (\n    input [31:0] a, // 32-bit input A\n    input [31:0] b, // 32-bit input B\n    output [31:0] sum // 32-bit sum output\n);\n\n    wire [15:0] sum_low, sum_high; // 16-bit lower and upper parts of the sum\n    wire carry_out_low, carry_out_high; // Carry outputs from the lower and upper adders\n\n    ripple_adder adder_low(.a(a[15:0]), .b(b[15:0]), .sum(sum_low), .carry_out(carry_out_low)); // Lower 16-bit adder\n    ripple_adder adder_high(.a(a[31:16]), .b(b[31:16]), .sum(sum_high), .carry_out(carry_out_high)); // Upper 16-bit adder\n\n    assign sum[15:0] = carry_out_low ? sum_high : sum_low; // Select the correct lower 16 bits of the sum\n    assign sum[31:16] = carry_out_high ? sum_high + 1 : sum_high; // Select the correct upper 16 bits of the sum\n\nendmodule\nmodule ripple_adder (\n    input [15:0] a, // 16-bit input A\n    input [15:0] b, // 16-bit input B\n    output [15:0] sum, // 16-bit sum output\n    output carry_out // Carry output\n);\n\n    assign {carry_out, sum} = a + b;\n\nendmodule\nmodule decoder_mux_16bit (\n    input [15:0] in, // 16-bit input\n    output [7:0] upper_byte, // 8-bit upper byte output\n    output [7:0] lower_byte // 8-bit lower byte output\n);\n\n    assign upper_byte = in[15:8];\n    assign lower_byte = in[7:0];\n\nendmodule\nmodule functional_module (\n    input [7:0] a, // 8-bit input A\n    input [7:0] b, // 8-bit input B\n    output [7:0] out // 8-bit product output\n);\n\n    assign out = a * b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_async_reset_edb6119f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_async_reset (\n  input clk,\n  input reset,\n  input d,\n  output reg q\n);\n\n  always @(posedge clk) begin\n    if (reset == 1'b0) begin\n      q <= 1'b0;\n    end else begin\n      q <= d;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "restoring_division_16bit_67383084", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule restoring_division_16bit (\n    input signed [15:0] dividend,\n    input signed [15:0] divisor,\n    output reg signed [15:0] quotient,\n    output reg signed [15:0] remainder\n);\n\nreg signed [15:0] remainder_reg;\nreg signed [15:0] divisor_reg;\nreg signed [15:0] quotient_reg;\nreg signed [15:0] dividend_reg;\nreg [4:0] count;\n\nalways @(*) begin\n    count = 0;\n    remainder_reg = dividend;\n    divisor_reg = divisor;\n    quotient_reg = 0;\n    dividend_reg = dividend;\n\n    if (dividend[15] == 1) begin\n        remainder_reg = -dividend;\n        dividend_reg = -dividend;\n    end\n\n    if (divisor[15] == 1) begin\n        divisor_reg = -divisor;\n    end\n\n    for (count = 0; count < 16; count = count + 1) begin\n        remainder_reg = remainder_reg << 1;\n        quotient_reg = quotient_reg << 1;\n        remainder_reg[0] = dividend_reg[15];\n        dividend_reg = dividend_reg << 1;\n\n        remainder_reg = remainder_reg - divisor_reg;\n\n        if (remainder_reg[15] == 1) begin\n            remainder_reg = remainder_reg + divisor_reg;\n        end else begin\n            quotient_reg[0] = 1;\n        end\n\n        count = count + 1;\n    end\n\n    if (dividend[15] == 1 && divisor[15] == 1) begin\n        quotient = quotient_reg;\n        remainder = -remainder_reg;\n    end else if (dividend[15] == 1 || divisor[15] == 1) begin\n        quotient = -quotient_reg;\n        remainder = remainder_reg;\n    end else begin\n        quotient = quotient_reg;\n        remainder = remainder_reg;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_3f531c75", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n  input clk,\n  input load,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\n  reg [3:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (load) begin\n      shift_reg <= data_in;\n    end else begin\n      shift_reg <= {shift_reg[2:0], shift_reg[3]};\n    end\n  end\n\n  assign data_out = shift_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder4_8ccc56fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder4 (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] sum;\n    wire [3:1] carry;\n\n    // Full adder for bit 0\n    full_adder FA0(A[0], B[0], Cin, sum[0], carry[1]);\n\n    // Full adder for bit 1\n    full_adder FA1(A[1], B[1], carry[1], sum[1], carry[2]);\n\n    // Full adder for bit 2\n    full_adder FA2(A[2], B[2], carry[2], sum[2], carry[3]);\n\n    // Full adder for bit 3\n    full_adder FA3(A[3], B[3], carry[3], sum[3], Cout);\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt12_dac2 #_45f57fbb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule jt12_dac2 #(parameter width=12)\n(\n\tinput\tclk,\n    input\trst,\n    input\tsigned [width-1:0] din,\n    output\treg dout\n);\n\nlocalparam int_w = width+5;\n\nreg [int_w-1:0] y, error, error_1, error_2;\n\nwire [width-1:0] undin = { ~din[width-1], din[width-2:0] };\n\nalways @(*) begin\n\ty = undin + { error_1, 1'b0} - error_2;\n\tdout = ~y[int_w-1];\n\terror = y - {dout, {width{1'b0}}};\nend\n\nalways @(posedge clk)\n\tif( rst ) begin\n\t\terror_1 <= {int_w{1'b0}};\n\t\terror_2 <= {int_w{1'b0}};\n\tend else begin\n\t\terror_1 <= error;\n\t\terror_2 <= error_1;\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_65bde813", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate (\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  always @(posedge CLK) begin\n    if (EN == 1'b0) begin\n      ENCLK <= 1'b0;\n    end else begin\n      if (TE == 1'b1) begin\n        ENCLK <= CLK;\n      end else begin\n        ENCLK <= 1'b0;\n      end\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "buf_interm_disable_77f1d0c6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule buf_interm_disable(\n    input I,\n    input IBUFDISABLE,\n    input INTERMDISABLE,\n    output O\n);\n\n    parameter IBUF_LOW_PWR = \"TRUE\";\n    parameter IOSTANDARD = \"DEFAULT\";\n    parameter SIM_DEVICE = \"7SERIES\";\n    parameter USE_IBUFDISABLE = \"TRUE\";\n\n    wire out_val;\n\n    assign out_val = (SIM_DEVICE == \"7SERIES\") ? 1'b1 : 1'b0;\n\n    assign O = (USE_IBUFDISABLE == \"TRUE\") ? \n        ((IBUFDISABLE == 0) ? I : ((IBUFDISABLE == 1) ? out_val : 1'bx)) : I;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "encode_ctl_6756a0cd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule encode_ctl(\n   hraddr, cnt_output_enable, cnt_len, cnt_output,\n   cnt_finish,\n   clk, rst, data_valid, data_empty, hash_data, hash_data1,\n   data_d1, data_d2, hash_ref, iidx, hdata, data, hash_d1,\n   hash_data_d1\n   );\n   parameter LZF_WIDTH = 20;\n\n   input     clk, rst;\n   input     data_valid;\n   input     data_empty;\n   \n   input [7:0] hash_data, hash_data1, data_d1, data_d2;\n   input [LZF_WIDTH-1:0] hash_ref, iidx;\n   \n   input [7:0] \t\t hdata, data, hash_d1;\n   output [10:0] \t hraddr;\n   input \t\t hash_data_d1;\n   \n   \n\n   reg \t\t\toff_valid;\n   reg \t\t\tiidx_window;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  iidx_window <= #1 0;\n\telse if (iidx[11]) \n\t  iidx_window <= #1 1;\n     end\n   \n   reg [LZF_WIDTH-1:0] \tmin_off, max_off;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  min_off <= #1 0;\n\telse if (data_valid && iidx_window)\n\t  min_off <= #1 min_off + 1;\n     end\n\n   always @(posedge clk)\n     begin\n\tif (data_valid)\n\t  max_off <= #1 iidx;\n     end\n   \n   always @(hash_ref or max_off or min_off)\n     begin\n\tif (hash_ref > min_off && hash_ref < max_off)\n\t  off_valid = 1;\n\telse\n\t  off_valid = 0;\n     end\n\n   reg [10:0] off;\n   always @(hash_ref or max_off)\n     begin\n\toff = max_off - hash_ref;\n     end\n   \n   parameter [2:0]\n\t\tS_IDLE   = 3'h0,\n\t\tS_SEARCH = 3'h1,\n\t\tS_TR     = 3'h2,\n\t\tS_MATCH  = 3'h3,\n\t\tS_DELAY  = 3'h4,\n\t\tS_END    = 3'h5,\n\t\tS_DONE   = 3'h6,\n\t\tS_STOP   = 3'h7;\n\n   reg [2:0] \t  state, state_next;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  state <= #1 S_IDLE;\n\telse\n\t  state <= #1 state_next;\n     end\n\n   reg [3:0] cnt, cnt_next;\n   always @(posedge clk)\n     begin\n\t  cnt <= #1 cnt_next;\n     end\n\n   reg cnt_count, cnt_load;\n   reg rallow;\n   reg [10:0] raddr_plus_one;\n   reg [10:0] raddr_reg;\n   \n   assign hraddr = rallow ? raddr_plus_one : raddr_reg;\n   \n   always @(cnt_count or cnt_load)\n     begin\n\tif (cnt_load || cnt_count)\n\t  rallow = 1;\n\telse\n\t  rallow = 0;\n     end\n\n   reg [LZF_WIDTH-1:0] hash_ref_plus_one;\n   always @(hash_ref)\n     hash_ref_plus_one = hash_ref + 1'b1;\n   \n   always @(posedge clk)\n     begin\n\tif (cnt_load)\n\t  raddr_plus_one <= #1 hash_ref_plus_one + 1'b1;\n\telse if (cnt_count)\n\t  raddr_plus_one <= #1 raddr_plus_one + 1'b1;\n     end\n\n   always @(posedge clk)\n     begin\n\tif (cnt_load)\n\t  raddr_reg <= #1 hash_ref_plus_one;\n\telse if (cnt_count)\n\t  raddr_reg <= #1 raddr_plus_one;\n     end\n   \n   reg cnt_big7, cnt_big7_next;\n   always @(posedge clk)\n     begin\n\t  cnt_big7 <= #1 cnt_big7_next;\n     end\n   \n\n   always @(cnt or cnt_big7 or cnt_count or cnt_load)\n     begin\n\tcnt_next = 0;\n\tcnt_big7_next = 0;\n\t\n\tif (cnt_load) begin\n\t   cnt_next = 2;\n\t   cnt_big7_next = 0;\n\tend else if (cnt_count) begin\n\t   cnt_next = cnt + 1;\n\t   if (cnt_big7 == 0) begin\n\t      if (cnt == 4'h7) begin\n\t\t cnt_big7_next = 1;\n\t\t cnt_next = 0;\n\t      end else\n\t\tcnt_big7_next = 0;\n\t   end else begin\n\t      cnt_big7_next = 1;\n\t   end\n\t   if (cnt == 4'hf)\n\t     cnt_next = 1;\n\tend else begin\n\t   cnt_next = cnt;\n\t   cnt_big7_next = cnt_big7;\n\tend\n     end output cnt_output_enable;\n   output [3:0] cnt_len;\n   output [12:0] cnt_output;\n   output \t cnt_finish;\n\n   reg [2:0] \t dummy_cnt;\n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  dummy_cnt <= #1 0;\n\telse if (state == S_DONE)\n\t  dummy_cnt <= #1 dummy_cnt + 1'b1;\n     end\n   \n   reg \t\t cnt_finish;\n   reg \t\t cnt_output_enable, cnt_output_enable_next;\n   reg [12:0] \t cnt_output, cnt_output_next;\n   reg [3:0] \t cnt_len, cnt_len_next;\n   \n   always @(cnt or cnt_big7 or data_d1 or data_d2\n\t    or data_empty or data_valid or dummy_cnt\n\t    or hash_data or hash_data_d1 or hdata\n\t    or off_valid or state)\n     begin\n\tstate_next = S_IDLE;         cnt_output_enable_next = 0;  cnt_load = 0;\n\tcnt_count = 0;\n\n\tcase (state)\n\t  S_IDLE: begin\n\t     if (data_valid) \n\t       state_next = S_DELAY;\n\t     else\n\t       state_next = S_IDLE;\n\t  end\n\n\t  S_DELAY: begin\n\t     if (data_valid) \n\t       state_next = S_SEARCH;\n\t     else\n\t       state_next = S_DELAY;\n\t  end\n\t  \n\t  S_SEARCH: begin \n\t     if (data_valid) begin\n\t\tif (data_d2 == hash_data && off_valid) begin\n\t\t   state_next = S_TR;\n\t\t   cnt_load = 1;\n\t\t   cnt_output_enable_next = 1;\n\t\tend else begin\n\t\t   cnt_output_enable_next = 1;\n\t\t   state_next = S_SEARCH;\n\t\tend\n\t     end else if (data_empty) begin\n\t\tcnt_output_enable_next = 1;\n\t\tstate_next = S_END;\n\t     end else\n\t       state_next = S_SEARCH;\n\t  end S_TR: begin if (data_valid && hash_data_d1) begin\n\t\tcnt_count = 1;\n\t\tstate_next = S_MATCH;\n\t     end else if (data_valid) begin\n\t\tstate_next = S_SEARCH;\n\t\tcnt_output_enable_next = 1;\n\t     end else if (data_empty) begin\n\t\tcnt_output_enable_next = 1;\n\t\tstate_next = S_END;\n\t     end else begin\n\t\tstate_next = S_TR;\n\t     end\n\t  end\n\t  \n\t  S_MATCH: begin \n\t     if (data_valid) begin\n\t\tif (data_d1 == hdata) begin\n\t\t   state_next = S_MATCH;\n\t\t   cnt_count = 1;\n\t\t   if (cnt == 4'h7 && cnt_big7 == 0)\n\t\t     cnt_output_enable_next = 1;\n\t\t   else if (cnt == 4'hf)\n\t\t     cnt_output_enable_next = 1;\n\t\tend else begin state_next = S_SEARCH;\n\t\t   cnt_output_enable_next = 1;\n\t\tend\n\t     end else if (data_empty) begin state_next = S_END;\n\t\tcnt_output_enable_next = 1;\n\t     end else \n\t\tstate_next = S_MATCH;\n\t  end S_END: begin \n\t     state_next = S_DONE;\n\t     cnt_output_enable_next = 1;\n\t  end\n\n\t  S_DONE: begin \n\t     state_next = S_DONE;\n\t     cnt_output_enable_next = 1;\n\t     if (&dummy_cnt) \n\t       state_next = S_STOP;\n\t  end\n\n\t  S_STOP: begin\n\t     state_next = S_STOP;\n\t  end\n\tendcase end always @(posedge clk)\n     begin\n\tcnt_output <= #1 cnt_output_next;\n\tcnt_len    <= #1 cnt_len_next;\n     end\n   \n   always @(posedge clk or posedge rst)\n     begin\n\tif (rst)\n\t  cnt_output_enable <= #1 0;\n\telse\n\t  cnt_output_enable <= #1 cnt_output_enable_next;\n     end\n\n   always @(state)\n     cnt_finish = state == S_STOP;\n   \n   \n   reg [3:0] encode_len_s;\n   reg [12:0] encode_data_s;\n   \n   reg [3:0]  encode_len_m;\n   reg [12:0] encode_data_m;\n   \n   reg [3:0]  encode_len;\n   reg [12:0] encode_data;\n   \n   always @(cnt_output_enable_next or encode_data_m\n\t    or encode_data_s or encode_len_m or encode_len_s\n\t    or state)\n     begin\n\tcnt_output_next = 0;\n\tcnt_len_next= 0;\n\t\n\tif (cnt_output_enable_next && state == S_SEARCH) begin\n\t   \n\t   cnt_output_next = encode_data_s;\n\t   cnt_len_next = encode_len_s;\n\tend else if (cnt_output_enable_next && state == S_END) begin\n\t   \n\t   cnt_output_next = 9'b110000000;\n\t   cnt_len_next    = 4'h9;\n\tend else if (cnt_output_enable_next && state == S_DONE) begin\n\t   \n\t   cnt_output_next = 9'b000000000;\n\t   cnt_len_next    = 4'hf;\n\tend else begin\n\t   cnt_output_next = encode_data_m;\n\t   cnt_len_next = encode_len_m;\n\tend\n     end always @(cnt or cnt_big7 or cnt_count\n\t    or encode_data or encode_len)\n     begin\n\tif (cnt_big7 == 0) begin\n\t   if (cnt_count) begin\n\t      encode_data_m = 4'hf;\n\t      encode_len_m = 4'h4;\n\t   end else begin\n\t      encode_data_m = encode_data;\n\t      encode_len_m = encode_len;\n\t   end\n\tend else begin\n\t   if (cnt == 4'hf && cnt_count == 0) begin\n\t      encode_data_m = {4'hf, 4'h0};\n\t      encode_len_m = 4'h8;\n\t   end else begin\n\t      encode_data_m = cnt;\n\t      encode_len_m = 4'h4;\n\t   end\n\tend end\n   \n   always @(cnt_load or data_d2 or off)\n     begin\n\tencode_len_s = 0;\n\tencode_data_s = 0;\n\n\tif (cnt_load) begin \n\t   if (off[10:07] == 0) begin \n\t      encode_len_s = 4'h9;\n\t      encode_data_s = {2'b11, off[6:0]};\n\t   end else begin\n\t      encode_len_s = 4'hd;\n\t      encode_data_s = {2'b10, off[10:0]};\n\t   end\n\tend else begin\n\t   encode_len_s = 4'h9;\n\t   encode_data_s = data_d2;\n\tend end\n   \n   always @(cnt)\n     begin\n\tencode_len = 0;\n\tencode_data = 0;\n\t\n\tcase (cnt[2:0])\n\t  3'h2: {encode_data, encode_len} = {2'b00, 4'h2};\n\t  3'h3: {encode_data, encode_len} = {2'b01, 4'h2};\n\t  3'h4: {encode_data, encode_len} = {2'b10, 4'h2};\n\t  3'h5: {encode_data, encode_len} = {2'b11, 2'b00, 4'h4};\n\t  3'h6: {encode_data, encode_len} = {2'b11, 2'b01, 4'h4};\n\t  3'h7: {encode_data, encode_len} = {2'b11, 2'b10, 4'h4};\n\tendcase\n     end \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "filter_310c3864", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule filter(\n    input clk, resetn, din_valid,\n    input [7:0] din00, din01, din02,\n    input [7:0] din10, din11, din12,\n    input [7:0] din20, din21, din22,\n    output reg [7:0] dout,\n    output reg dout_valid\n    );\n\n    reg [7:0] sum;\n    reg [3:0] count;\n    \n    always @(posedge clk, negedge resetn) begin\n        if (!resetn) begin\n            dout_valid <= 0;\n            dout <= 0;\n            sum <= 0;\n            count <= 0;\n        end else begin\n            if (din_valid) begin\n                sum <= din00 + din01 + din02 + din10 + din11 + din12 + din20 + din21 + din22;\n                count <= 9;\n                dout <= sum / count;\n                dout_valid <= 1;\n            end else begin\n                dout_valid <= 0;\n                dout <= 0;\n                sum <= 0;\n                count <= 0;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_145960f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] d, // Input for the shift register\n    output [7:0] q // Output of the shift register\n);\n\n    reg [7:0] shift_reg = 0; // 8-bit shift register\n\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            shift_reg <= 8'b0;\n        end else begin\n            shift_reg <= {shift_reg[6:0], d[0]};\n        end\n    end\n\n    assign q = shift_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_mux_1a0c6fd0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dff_mux (\n    input clk,\n    input [7:0] d,\n    input [2:0] sel,\n    output reg [7:0] q\n);\n\nreg [7:0] q_int;\nreg [7:0] d_int;\n\nalways @(posedge clk) begin\n    q_int <= d_int;\n    d_int <= d;\nend\n\nalways @(*) begin\n    case (sel)\n        3'b000: q = q_int[7];\n        3'b001: q = q_int[6];\n        3'b010: q = q_int[5];\n        3'b011: q = q_int[4];\n        3'b100: q = q_int[3];\n        3'b101: q = q_int[2];\n        3'b110: q = q_int[1];\n        3'b111: q = q_int[0];\n    endcase\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nwire [2:0] sel;\nreg [7:0] d_int;\n\ndff_mux mux_inst (\n    .clk(clk),\n    .d(d_int),\n    .sel(sel),\n    .q(q)\n);\n\nassign sel[2:0] = d[2:0]; \n\nalways @(posedge clk) begin\n    d_int <= d;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sp_mux_5to1_sel3_4_1 #_b394c031", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule sp_mux_5to1_sel3_4_1 #(\nparameter\n    ID                = 0,\n    NUM_STAGE         = 1,\n    din1_WIDTH       = 32,\n    din2_WIDTH       = 32,\n    din3_WIDTH       = 32,\n    din4_WIDTH       = 32,\n    din5_WIDTH       = 32,\n    din6_WIDTH         = 32,\n    dout_WIDTH            = 32\n)(\n    input  [3 : 0]     din1,\n    input  [3 : 0]     din2,\n    input  [3 : 0]     din3,\n    input  [3 : 0]     din4,\n    input  [3 : 0]     din5,\n    input  [2 : 0]    din6,\n    output [3 : 0]   dout);\n\nwire [2 : 0]     sel;\nwire [3 : 0]         mux_1_0;\nwire [3 : 0]         mux_1_1;\nwire [3 : 0]         mux_1_2;\nwire [3 : 0]         mux_2_0;\nwire [3 : 0]         mux_2_1;\nwire [3 : 0]         mux_3_0;\n\nassign sel = din6;\n\nassign mux_1_0 = (sel[0] == 0)? din1 : din2;\nassign mux_1_1 = (sel[0] == 0)? din3 : din4;\nassign mux_1_2 = din5;\n\nassign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;\nassign mux_2_1 = mux_1_2;\n\nassign mux_3_0 = (sel[2] == 0)? mux_2_0 : mux_2_1;\n\nassign dout = mux_3_0;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_LED_ed774dce", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_reg_LED (\n    input clk,\n    input [7:0] data,\n    output reg [2:0] LED\n);\n\nreg [7:0] shift_reg;\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[6:0], data};\n    counter <= counter + 1;\n    if (counter == 7) begin\n        counter <= 0;\n        LED <= {shift_reg[7], shift_reg[3], shift_reg[0]};\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_1d7ab242", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier(\n    input clk,\n    input [12:0] A,\n    input [12:0] B,\n    output [26:0] Y,\n    output [26:0] Z\n);\n\nreg [25:0] Y_reg;\nreg [25:0] Z_reg;\nreg [12:0] A_reg;\nreg [12:0] B_reg;\nreg [10:0] i;\n\nalways @(posedge clk) begin\n    A_reg <= A;\n    B_reg <= B;\n    if(i == 0) begin\n        Y_reg <= 0;\n        Z_reg <= 0;\n    end\n    else begin\n        if(B_reg[0] == 1) begin\n            Y_reg <= Y_reg + (A_reg << (i-1));\n            Z_reg <= Z_reg + ((~A_reg + 1) << (i-1));\n        end\n    end\n    i <= i + 1;\nend\n\nassign Y = Y_reg;\nassign Z = Z_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "excess_3_converter_fe8e1758", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule excess_3_converter (\n    input [3:0] binary,\n    output reg [7:0] excess_3\n);\n\nalways @(*) begin\n    case (binary)\n        4'd0: excess_3 = 8'b0011_0011;\n        4'd1: excess_3 = 8'b0011_0100;\n        4'd2: excess_3 = 8'b0011_0101;\n        4'd3: excess_3 = 8'b0011_0110;\n        4'd4: excess_3 = 8'b0011_0111;\n        4'd5: excess_3 = 8'b0011_1000;\n        4'd6: excess_3 = 8'b0011_1001;\n        4'd7: excess_3 = 8'b0011_1010;\n        4'd8: excess_3 = 8'b0011_1011;\n        4'd9: excess_3 = 8'b0011_1100;\n        4'd10: excess_3 = 8'b0011_1101;\n        4'd11: excess_3 = 8'b0011_1110;\n        4'd12: excess_3 = 8'b0011_1111;\n        4'd13: excess_3 = 8'b0100_0000;\n        4'd14: excess_3 = 8'b0100_0001;\n        4'd15: excess_3 = 8'b0100_0010;\n        default: excess_3 = 8'b0000_0000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_fifo_6551d797", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_fifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    q,\n    usedw\n);\n\n    input aclr;\n    input clock;\n    input [33:0] data;\n    input rdreq;\n    input wrreq;\n    output [33:0] q;\n    output [9:0] usedw;\n\n    wire [9:0] sub_wire0;\n    wire [33:0] sub_wire1;\n\n    scfifo scfifo_component (\n        .aclr(aclr),\n        .clock(clock),\n        .data(data),\n        .rdreq(rdreq),\n        .wrreq(wrreq),\n        .q(sub_wire1),\n        .usedw(sub_wire0)\n    );\n\n    assign q = sub_wire1;\n    assign usedw = sub_wire0;\n\nendmodule\nmodule scfifo (\n    aclr,\n    clock,\n    data,\n    rdreq,\n    wrreq,\n    q,\n    usedw\n);\n\n    input aclr;\n    input clock;\n    input [33:0] data;\n    input rdreq;\n    input wrreq;\n    output [33:0] q;\n    output [9:0] usedw;\n\n    reg [33:0] q_reg;\n    reg [9:0] usedw_reg;\n\n    assign q = q_reg;\n    assign usedw = usedw_reg;\n\n    always @(posedge clock or posedge aclr) begin\n        if (aclr) begin\n            q_reg <= 0;\n            usedw_reg <= 0;\n        end else begin\n            if (wrreq) begin\n                q_reg <= data;\n                usedw_reg <= usedw_reg + 1;\n            end\n\n            if (rdreq) begin\n                q_reg <= 0;\n                usedw_reg <= usedw_reg - 1;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "control_digitos_1_2a83f468", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule control_digitos_1\n\t(\n\tinput  [7:0] estado,\n\tinput  [3:0]RG1_Dec,\n   input  [3:0]RG2_Dec,\n   input  [3:0]RG3_Dec,\n\tinput escribiendo,\n\tinput en_out,\n\tinput wire clk,\n\tinput wire [3:0] dig0_Dec,\n\tinput [3:0] direccion,\n\toutput reg [3:0] dig_Dec_Ho, dig_Dec_min, dig_Dec_seg, dig_Dec_mes, dig_Dec_dia, dig_Dec_an, dig_Dec_Ho_Ti, dig_Dec_min_Ti, dig_Dec_seg_Ti\n\t\n\t);\n\t\n\t\n\talways @(posedge clk)\n\t\n\tif (~escribiendo)\n\t\tif (en_out)\n\t\t\tcase (direccion)\n\t\t\t\t4'b0000:dig_Dec_Ho<=dig0_Dec;\t\t\n\t\t\t\t\t\t\n\t\t\t\t4'b0001:dig_Dec_min<=dig0_Dec;\t\n\n\t\t\t\t4'b0010:dig_Dec_seg<=dig0_Dec;\t\t\n\n\t\t\t\t4'b0011:dig_Dec_mes<=dig0_Dec;\t\t\n\n\t\t\t\t4'b0100:dig_Dec_dia<=dig0_Dec;\t\t\n\n\t\t\t\t4'b0101:dig_Dec_an<=dig0_Dec;\t\n\n\t\t\t\t4'b0110:begin\n\t\t\t\t\t\t\t\tif (dig0_Dec==4'b1111)\n\t\t\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=4'b0000;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig0_Dec;\n\t\t\t\t\t\t\tend\t\t\t\t\n\t\t\t\t4'b0111:dig_Dec_min_Ti<=dig0_Dec;\t\t\t\t\t\n\t\t\t\t4'b1000: dig_Dec_seg_Ti<=dig0_Dec;\n\t\t\t\tdefault:\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\t\n\t\t\t\t\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\t\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\t\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\t\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\t\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\t\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\t\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\tendcase\n\t\telse\n\t\t\tbegin\n\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\n\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\tend\n\telse \n\t\tcase (estado)\n\t\t\t8'h7d:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (direccion==4'b0011)\n\t\t\t\t\t\t\tdig_Dec_mes<=RG2_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0100)\n\t\t\t\t\t\t\tdig_Dec_dia<=RG1_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0101)\n\t\t\t\t\t\t\tdig_Dec_an<=RG3_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t8'h6c:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (direccion==4'b0000)\n\t\t\t\t\t\t\tdig_Dec_Ho<=RG3_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0001)\n\t\t\t\t\t\t\tdig_Dec_min<=RG2_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0010)\n\t\t\t\t\t\t\tdig_Dec_seg<=RG1_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\n\t\t\t\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t8'h75:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (direccion==4'b0110)\n\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=RG3_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b0111)\n\t\t\t\t\t\t\tdig_Dec_min_Ti<=RG2_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (direccion==4'b1000)\n\t\t\t\t\t\t\tdig_Dec_seg_Ti<=RG1_Dec;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\tdefault:\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tdig_Dec_Ho<=dig_Dec_Ho;\n\t\t\t\t\t\t\tdig_Dec_min<=dig_Dec_min;\n\t\t\t\t\t\t\tdig_Dec_seg<=dig_Dec_seg;\n\t\t\t\t\t\t\tdig_Dec_mes<=dig_Dec_mes;\n\t\t\t\t\t\t\tdig_Dec_dia<=dig_Dec_dia;\n\t\t\t\t\t\t\tdig_Dec_an<=dig_Dec_an;\n\t\t\t\t\t\t\tdig_Dec_Ho_Ti<=dig_Dec_Ho_Ti;\n\t\t\t\t\t\t\tdig_Dec_min_Ti<=dig_Dec_min_Ti;\n\t\t\t\t\t\t\tdig_Dec_seg_Ti<=dig_Dec_seg_Ti;\n\t\t\t\t\t\tend\n\t\tendcase\n\t\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CORDIC_FSM_v2_537c4092", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule CORDIC_FSM_v2\n(\ninput wire clk,\t\t\t\t\t\t\t\t\t\t\tinput wire reset,\t\t\t\t\t\t\t\t\t\tinput wire beg_FSM_CORDIC,\t\t\t\t\t\t\t\tinput wire ACK_FSM_CORDIC,\t\t\t\t\t\t\t\tinput wire operation,\t\t\t\t\t\t\t\t\tinput wire exception,\ninput wire [1:0] shift_region_flag,\t\t\t\t\t\tinput wire [1:0] cont_var,\t\t\t\t\t\t\t\tinput wire ready_add_subt,\t\t\t\t\t\t\t\tinput wire max_tick_iter, min_tick_iter,\t\t\t\tinput wire max_tick_var, min_tick_var,\t\t\t\t\toutput reg reset_reg_cordic,\noutput reg ready_CORDIC,\t\t\t\t\t\t\t\toutput reg beg_add_subt,\t\t\t\t\t\t\t\toutput reg ack_add_subt,\t\t\t\t\t\t\t\toutput reg sel_mux_1, sel_mux_3,\t\t\t\t\t\toutput reg [1:0] sel_mux_2,\t\t\t\t\t\t\t\toutput reg enab_cont_iter, load_cont_iter,\t\t\t\toutput reg enab_cont_var,  load_cont_var,\t\t\t\toutput reg enab_RB1, enab_RB2,\t\t\t\t\t\t\toutput reg enab_d_ff_Xn, enab_d_ff_Yn, enab_d_ff_Zn,\toutput reg enab_d_ff_out,enab_dff_5,\t\t\t\t\toutput reg enab_RB3,\noutput reg enab_reg_sel_mux1,enab_reg_sel_mux2,enab_reg_sel_mux3\n);\n\nlocalparam [3:0]    est0 = 4'b0000,\n                    est1 = 4'b0001,\n                    est2 = 4'b0010,\n                    est3 = 4'b0011,\n                    est4 = 4'b0100,\n                    est5 = 4'b0101, \n                    est6 = 4'b0110,\n                    est7 = 4'b0111,\n                    est8 = 4'b1000,\n                    est9 = 4'b1001,\n                    est10 = 4'b1010,\n                    est11 = 4'b1011,\n\t\t\t\t\test12 = 4'b1100,\n\t\t\t\t\test13 = 4'b1101;\n\t\t\t\t\t\n\nreg [3:0] state_reg, state_next;\talways @( posedge clk, posedge reset)\n    begin\n        if(reset)\tstate_reg <= est0;\n        else\t\tstate_reg <= state_next;\n    end\n\nalways @*\n    begin\n    state_next = state_reg; ready_CORDIC = 1'b0;\n    beg_add_subt = 1'b0;\n    ack_add_subt = 1'b0;\n    sel_mux_1 = 1'b0;\n    sel_mux_2 = 2'b00;\n    sel_mux_3 = 1'b0;\n    enab_cont_iter = 1'b0;\n    load_cont_iter = 1'b0;\n    enab_cont_var = 1'b0;\n    load_cont_var = 1'b0;\n    enab_RB1 = 1'b0;\n    enab_RB2 = 1'b0;\n    enab_RB3 = 1'b0;\n    enab_d_ff_Xn = 1'b0;\n    enab_d_ff_Yn = 1'b0;\n    enab_d_ff_Zn = 1'b0;\n    enab_d_ff_out = 1'b0;\n    reset_reg_cordic = 1'b0;\n    enab_dff_5 = 1'b0;\n    enab_reg_sel_mux1 = 1'b0;\n    enab_reg_sel_mux2 = 1'b0;\n    enab_reg_sel_mux3 = 1'b0;\n    \n        case(state_reg)\n        est0:\n        begin\n\t\t\treset_reg_cordic = 1'b1;\n\t\t\tenab_reg_sel_mux1 = 1'b1;\n            enab_reg_sel_mux2 = 1'b1;\n            enab_reg_sel_mux3 = 1'b1;\n\t\t\tstate_next = est1;\n        end\n\n\t\test1:\n        begin\n\t\t\tif(beg_FSM_CORDIC)\n\t\t\tbegin\n\t\t\t\tstate_next = est2;\n\t\t\tend\n\t\t\telse\n\t\t\t\tstate_next = est1;\n\t\tend\n\n\t\test2:\n\t\tbegin\n\t\t\tenab_RB1 = 1'b1;\n\t\t\tenab_cont_iter = 1'b1;\n\t\t\tload_cont_iter = 1'b1;\n\t\t\tstate_next = est3;\n\t\tend\n\n        est3:\n        begin\n            if(min_tick_iter)\n\t\t\t\tsel_mux_1 =\t1'b0;\n\t\t\telse\n\t\t\t\tsel_mux_1 = 1'b1;\n\t\t\tenab_reg_sel_mux1 = 1'b1;\n\t\t\t\t\t\t\n\t\t\tstate_next = est4;\n        end\n\n        est4:\n        begin\n\t\t\tif(exception)\n\t\t\t\tstate_next = est0;\n\t\t\telse\n\t\t\t\tstate_next = est5;\n            enab_RB2 = 1'b1;\n        end\n\n        est5:\n        begin\n\t\t\tenab_RB3 = 1'b1;\n\t\t\tenab_cont_var = 1'b1;\n\t\t\tload_cont_var = 1'b1;\n\t\t\tstate_next = est6;\n        end\n\n        est6:\n        begin            \n\t\t\tif(max_tick_iter)\n\t\t\tbegin\n\t\t\t\tif(operation == 1'b0)\n\t\t\t\tbegin\n\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\telse\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\tenab_reg_sel_mux2 = 1'b1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\tsel_mux_2 = 2'b00;\n\t\t\t\t\telse\n\t\t\t\t\t\tsel_mux_2 = 2'b01;\n\t\t\t\t\tenab_reg_sel_mux2 = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\telse\n\t\t\t\tsel_mux_2 = cont_var;\n\t\t\t\n\t\t\tenab_reg_sel_mux2 = 1'b1;\t\n\t\t\tstate_next = est7;\t\n        end        \n        \n        est7:\n        begin            \n\t\t\tbeg_add_subt = 1'b1;\n\t\t\tstate_next = est8;\n        end\n\n        est8:\n        begin\n\t\t\tif(ready_add_subt)\n\t\t\tbegin\n\t\t\t\tif(max_tick_iter)\n\t\t\t\tbegin\n\t\t\t\t\tif(operation == 1'b0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif(min_tick_var)\n\t\t\t\t\t\tenab_d_ff_Xn = 1'b1;\n\t\t\t\t\telse if(max_tick_var)\n\t\t\t\t\t\tenab_d_ff_Zn = 1'b1;\n\t\t\t\t\telse\n\t\t\t\t\t\tenab_d_ff_Yn = 1'b1;\n\t\t\t\tend\n\t\t\t\tstate_next = est9;\n\t\t\tend\n\t\t\t\n\t\t\telse\n\t\t\t\tstate_next = est8;\n        end\n\n        est9:\n        begin\n\t\t\tack_add_subt = 1'b1;\n\t\t\tif(max_tick_iter)\n\t\t\tbegin\n\t\t\t\tstate_next = est10;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(max_tick_var)\n\t\t\t\tbegin\n\t\t\t\t\tenab_cont_iter = 1'b1;\n\t\t\t\t\tstate_next = est3;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tenab_cont_var = 1'b1;\n\t\t\t\t\tstate_next = est6;\n\t\t\t\tend\n\t\t\tend\n        end\n\n        est10:\n        begin            \n\t\t\tif(operation == 1'b0)\n\t\t\tbegin\n\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\telse\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\tenab_reg_sel_mux3 = 1'b1;\n\t\t\tend\n\t\t\t\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(shift_region_flag == 2'b00)\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\telse if(shift_region_flag == 2'b01)\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\telse if(shift_region_flag == 2'b10)\n\t\t\t\t\tsel_mux_3 = 1'b0;\n\t\t\t\telse\n\t\t\t\t\tsel_mux_3 = 1'b1;\n\t\t\t\tenab_reg_sel_mux3 = 1'b1;\n\t\t\tend\n\t\t\t\n\t\t\tenab_reg_sel_mux3 = 1'b1;\n\t\t\tstate_next = est11;\n\t\tend\t\n\n\t\test11:\n\t\tbegin\t    \n\t\t\tenab_dff_5 = 1'b1;\n\t\t\tstate_next = est12;\n\t\tend\n\t\t\n\t\test12:\n\t\tbegin\n\t\t\tenab_d_ff_out = 1'b1;\n\t\t\tstate_next = est13;\n\t\tend\n\n\t\test13:\n\t\tbegin\n\t\t\tready_CORDIC = 1'b1;\n\t\t\tif(ACK_FSM_CORDIC)\n\t\t\t\tstate_next = est0;\n\t\t\telse\n\t\t\t\tstate_next = est13;\n\t\tend\n        \n        default : state_next = est0;\n        endcase\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_protection_block #_572290ee", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule memory_protection_block #(\n  parameter n = 8, // number of address signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] addr,\n  input we,\n  output rd,\n  output wr\n);\n\n// Define memory protection rules here\nreg [n-1:0] protected_addr;\ninitial begin\n  protected_addr = {n{1'b0}}; // initialize all addresses to unprotected\n  protected_addr[3:0] = 4'b1010; // protect addresses 0xA0 to 0xAF\n  protected_addr[7:4] = 4'b0011; // protect addresses 0x30 to 0x3F\nend\n\n// Define read and write signals based on memory protection rules\nassign rd = 1'b1; // always allow reads\nassign wr = (we & ~protected_addr[addr]); // allow writes only if address is unprotected\n\n// Use read and write signals to control memory access\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AddReg_81776afc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule AddReg (\n  input clk, rst, load,\n  input [0:0] D,\n  output reg [0:0] Q\n);\n\n  wire [0:0] Q_next;\n  wire [0:0] Q_reset;\n\n  assign Q_reset = 1'b0;\n  assign Q_next = Q + D;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      Q <= Q_reset;\n    end else if (load) begin\n      Q <= D;\n    end else begin\n      Q <= Q_next;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "task_func_test01_e1499318", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule task_func_test01(clk, a, b, c, x, y, z, w);\n\ninput clk;\ninput [7:0] a, b, c;\noutput reg [7:0] x, y, z, w;\n\nfunction [7:0] sum_shift;\ninput [3:0] s1, s2, s3;\nsum_shift = s1 + (s2 << 2) + (s3 << 4);\nendfunction\n\ntask reset_w;\nw = 0;\nendtask\n\ntask add_to;\noutput [7:0] out;\ninput [7:0] in;\nout = out + in;\nendtask\n\nalways @(posedge clk) begin\n\tx = sum_shift(a, b, c);\n\ty = sum_shift(a[7:4], b[5:2], c[3:0]);\n\tz = sum_shift(a[0], b[5:4], c >> 5) ^ sum_shift(1, 2, 3);\n\n\treset_w;\n\tadd_to(w, x);\n\tadd_to(w, y);\n\tadd_to(w, z);\nend\n\nendmodule\n\nmodule task_func_test02(clk, a, b, c, x, y, z, w);\n\ninput clk;\ninput [7:0] a, b, c;\noutput reg [7:0] x, y, z, w;\n\nfunction [7:0] sum_shift(input [3:0] s1, s2, s3);\nsum_shift = s1 + (s2 << 2) + (s3 << 4);\nendfunction\n\ntask reset_w;\nw = 0;\nendtask\n\ntask add_to(output [7:0] out, input [7:0] in);\nout = out + in;\nendtask\n\nalways @(posedge clk) begin\n\tx = sum_shift(a, b, c);\n\ty = sum_shift(a[7:4], b[5:2], c[3:0]);\n\tz = sum_shift(a[0], b[5:4], c >> 5) ^ sum_shift(1, 2, 3);\n\n\treset_w;\n\tadd_to(w, x);\n\tadd_to(w, y);\n\tadd_to(w, z);\nend\n\nendmodule\n\nmodule task_func_test03(input [7:0] din_a, input [7:0] din_b, output [7:0] dout_a);\n\tassign dout_a = test(din_a,din_b);\n\tfunction [7:0] test;\n\t\tinput [7:0] a;\n\t\tinput [7:0] b;\n\t\tbegin : TEST\n\t\t\tinteger i;\n\t\t\tfor (i = 0; i <= 7; i = i + 1)\n\t\t\t\ttest[i] = a[i] & b[i];\n\t\tend\n\tendfunction\nendmodule\n\nmodule task_func_test04(input [7:0] in, output [7:0] out1, out2, out3, out4);\n\tparameter p = 23;\n\tparameter px = 42;\n\tfunction [7:0] test1;\n\t\tinput [7:0] i;\n\t\tparameter p = 42;\n\t\tbegin\n\t\t\ttest1 = i + p;\n\t\tend\n\tendfunction\n\tfunction [7:0] test2;\n\t\tinput [7:0] i;\n\t\tparameter p2 = p+42;\n\t\tbegin\n\t\t\ttest2 = i + p2;\n\t\tend\n\tendfunction\n\tfunction [7:0] test3;\n\t\tinput [7:0] i;\n\t\tbegin\n\t\t\ttest3 = i + p;\n\t\tend\n\tendfunction\n\tfunction [7:0] test4;\n\t\tinput [7:0] i;\n\t\tparameter px = p + 13;\n\t\tparameter p3 = px - 37;\n\t\tparameter p4 = p3 ^ px;\n\t\tbegin\n\t\t\ttest4 = i + p4;\n\t\tend\n\tendfunction\n\tassign out1 = test1(in);\n\tassign out2 = test2(in);\n\tassign out3 = test3(in);\n\tassign out4 = test4(in);\nendmodule\n\nmodule task_func_test05(data_in,data_out,clk);\n\toutput reg data_out;\n\tinput data_in;\n\tinput clk;\n\n\ttask myTask;\n\t\toutput out;\n\t\tinput in;\n\t\tout = in;\n\tendtask\n\n\talways @(posedge clk) begin\n\t\tmyTask(data_out,data_in);\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_tx_067db156", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_tx\n   #(\n     parameter DBIT = 8,     SB_tck = 16  )\n   (\n    input wire clk, reset,\n    input wire tx_start, s_tck,\n    input wire [7:0] din,\n    output reg tx_done_tck,\n    output wire tx\n   );\n\n   \n   localparam [1:0]init_state  = 2'b00,start = 2'b01,data  = 2'b10,stop  = 2'b11;\n\n   \n   reg [1:0] state, state_next;\n   reg [3:0] s, s_next;\n   reg [2:0] n, n_next;\n   reg [7:0] b, b_next;\n   reg tx_reg, tx_next;\n\n   \n   always @(posedge clk)\n      if (reset)\n         begin\n            state <= init_state;\n            s <= 0;\n            n <= 0;\n            b <= 0;\n            tx_reg <= 1'b1;\n         end\n      else\n         begin\n            state <= state_next;\n            s <= s_next;\n            n <= n_next;\n            b <= b_next;\n            tx_reg <= tx_next;\n         end\n\n  \n   always @*\n   begin\n      state_next = state;\n      tx_done_tck = 1'b0;\n      s_next = s;\n      n_next = n;\n      b_next = b;\n      tx_next = tx_reg ;\n      if(state==init_state)\n            begin\n               tx_next = 1'b1;\n               if (tx_start)\n                  begin\n                     state_next = start;\n                     s_next = 0;\n                     b_next = din;\n                  end\n            end\n        else if(state==start)\n            begin\n               tx_next = 1'b0;\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        state_next = data;\n                        s_next = 0;\n                        n_next = 0;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==data)\n            begin\n               tx_next = b[0];\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        s_next = 0;\n                        b_next = b >> 1;\n                        if (n==(DBIT-1))\n                           state_next = stop ;\n                        else\n                           n_next = n + 1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==stop)\n            begin\n               tx_next = 1'b1;\n               if (s_tck)\n                  if (s==(SB_tck-1))\n                     begin\n                        state_next = init_state;\n                        tx_done_tck = 1'b1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n   end\n\n   assign tx = tx_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rxuart #_c724f79f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule rxuart #(\n\t\tparameter [30:0] INITIAL_SETUP = 31'd868,\n\t\tlocalparam [3:0]\tRXU_BIT_ZERO    = 4'h0,\n\t\t\t\t\tRXU_BIT_ONE     = 4'h1,\n\t\t\t\t\tRXU_BIT_TWO     = 4'h2,\n\t\t\t\t\tRXU_BIT_THREE   =  4'h3,\n\t\t\t\t\tRXU_BIT_SEVEN   = 4'h7,\n\t\t\t\t\tRXU_PARITY      = 4'h8,\n\t\t\t\t\tRXU_STOP        = 4'h9,\n\t\t\t\t\tRXU_SECOND_STOP = 4'ha,\n\t\t\t\t\tRXU_BREAK       = 4'hd,\n\t\t\t\t\tRXU_RESET_IDLE  = 4'he,\n\t\t\t\t\tRXU_IDLE        = 4'hf\n\t\t) (\n\t\tinput\twire\t\ti_clk, i_reset,\n\t\t\n\t\tinput\twire\t[30:0]\ti_setup,\n\t\t\n\t\tinput\twire\t\ti_uart_rx,\n\t\toutput\treg\t\to_wr,\n\t\toutput\treg\t[7:0]\to_data,\n\t\toutput\treg\t\to_break,\n\t\toutput\treg\t\to_parity_err, o_frame_err,\n\t\toutput\twire\t\to_ck_uart\n\t\t);\n\n\twire\t[27:0]\tclocks_per_baud, break_condition, half_baud;\n\twire\t[1:0]\tdata_bits;\n\twire\t\tuse_parity, parity_even, dblstop, fixd_parity;\n\treg\t[29:0]\tr_setup;\n\treg\t[3:0]\tstate;\n\n\treg\t[27:0]\tbaud_counter;\n\treg\t\tzero_baud_counter;\n\treg\t\tq_uart, qq_uart, ck_uart;\n\treg\t[27:0]\tchg_counter;\n\treg\t\tline_synch;\n\treg\t\thalf_baud_time;\n\treg\t[7:0]\tdata_reg;\n\treg\t\tcalc_parity;\n\treg\t\tpre_wr;\n\n\tassign\tclocks_per_baud = { 4'h0, r_setup[23:0] };\n\tassign\tdata_bits   = r_setup[29:28];\n\tassign\tdblstop     = r_setup[27];\n\tassign\tuse_parity  = r_setup[26];\n\tassign\tfixd_parity = r_setup[25];\n\tassign\tparity_even = r_setup[24];\n\tassign\tbreak_condition = { r_setup[23:0], 4'h0 };\n\tassign\thalf_baud = { 5'h00, r_setup[23:1] }-28'h1;\n\n\tinitial\tq_uart  = 1'b0;\n\tinitial\tqq_uart = 1'b0;\n\tinitial\tck_uart = 1'b0;\n\talways @(posedge i_clk)\n\tbegin\n\t\tq_uart <= i_uart_rx;\n\t\tqq_uart <= q_uart;\n\t\tck_uart <= qq_uart;\n\tend\n\tassign\to_ck_uart = ck_uart;\n\tinitial\tchg_counter = 28'h00;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tchg_counter <= 28'h00;\n\telse if (qq_uart != ck_uart)\n\t\tchg_counter <= 28'h00;\n\telse if (chg_counter < break_condition)\n\t\tchg_counter <= chg_counter + 1;\n\tinitial\to_break    = 1'b0;\n\talways @(posedge i_clk)\n\t\to_break <= ((chg_counter >= break_condition)&&(~ck_uart))? 1'b1:1'b0;\n\tinitial\tline_synch = 1'b0;\n\talways @(posedge i_clk)\n\t\tline_synch <= ((chg_counter >= break_condition)&&(ck_uart));\n\tinitial\thalf_baud_time = 0;\n\talways @(posedge i_clk)\n\t\thalf_baud_time <= (~ck_uart)&&(chg_counter >= half_baud);\n\tinitial\tr_setup     = INITIAL_SETUP[29:0];\n\talways @(posedge i_clk)\n\tif (state >= RXU_RESET_IDLE)\n\t\tr_setup <= i_setup[29:0];\n\tinitial\tstate = RXU_RESET_IDLE;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tstate <= RXU_RESET_IDLE;\n\telse if (state == RXU_RESET_IDLE)\n\tbegin\n\t\tif (line_synch)\n\t\t\tstate <= RXU_IDLE;\n\t\telse state <= RXU_RESET_IDLE;\n\t\tend else if (o_break)\n\tbegin state <= RXU_BREAK;\n\tend else if (state == RXU_BREAK)\n\tbegin if (ck_uart)\n\t\t\tstate <= RXU_IDLE;\n\t\telse\n\t\t\tstate <= RXU_BREAK;\n\t\tend else if (state == RXU_IDLE)\n\tbegin if ((~ck_uart)&&(half_baud_time))\n\t\t\tbegin\n\t\t\t\tcase (data_bits)\n\t\t\t\t2'b00: state <= RXU_BIT_ZERO;\n\t\t\t\t2'b01: state <= RXU_BIT_ONE;\n\t\t\t\t2'b10: state <= RXU_BIT_TWO;\n\t\t\t\t2'b11: state <= RXU_BIT_THREE;\n\t\t\t\tendcase\n\t\t\tend else state <= RXU_IDLE;\n\t\t\tend else if (zero_baud_counter)\n\tbegin\n\t\tif (state < RXU_BIT_SEVEN)\n\t\t\tstate <= state + 1;\n\t\telse if (state == RXU_BIT_SEVEN)\n\t\t\tstate <= (use_parity) ? RXU_PARITY:RXU_STOP;\n\t\telse if (state == RXU_PARITY)\n\t\t\tstate <= RXU_STOP;\n\t\telse if (state == RXU_STOP)\n\t\tbegin if (~ck_uart) state <= RXU_RESET_IDLE;\n\t\t\telse if (dblstop)\n\t\t\t\tstate <= RXU_SECOND_STOP;\n\t\t\telse\n\t\t\t\tstate <= RXU_IDLE;\n\t\tend else begin\n\t\t\tif (~ck_uart) state <= RXU_RESET_IDLE;\n\t\t\telse\n\t\t\t\tstate <= RXU_IDLE;\n\t\tend\n\t\tend\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)&&(state != RXU_PARITY))\n\t\tdata_reg <= { ck_uart, data_reg[7:1] };\n\talways @(posedge i_clk)\n\tif (state == RXU_IDLE)\n\t\tcalc_parity <= 0;\n\telse if (zero_baud_counter)\n\t\tcalc_parity <= calc_parity ^ ck_uart;\n\tinitial\to_parity_err = 1'b0;\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)&&(state == RXU_PARITY))\n\tbegin\n\t\tif (fixd_parity)\n\t\t\to_parity_err <= (ck_uart ^ parity_even);\n\t\telse if (parity_even)\n\t\t\to_parity_err <= (calc_parity != ck_uart);\n\t\telse\n\t\t\to_parity_err <= (calc_parity == ck_uart);\n\tend else if (state >= RXU_BREAK)\n\t\to_parity_err <= 1'b0;\n\tinitial\to_frame_err  = 1'b0;\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)&&((state == RXU_STOP)\n\t\t\t\t\t||(state == RXU_SECOND_STOP)))\n\t\to_frame_err <= (o_frame_err)||(~ck_uart);\n\telse if ((zero_baud_counter)||(state >= RXU_BREAK))\n\t\to_frame_err <= 1'b0;\n\tinitial\to_data = 8'h00;\n\tinitial\tpre_wr = 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\tbegin\n\t\tpre_wr <= 1'b0;\n\t\to_data <= 8'h00;\n\tend else if ((zero_baud_counter)&&(state == RXU_STOP))\n\tbegin\n\t\tpre_wr <= 1'b1;\n\t\tcase (data_bits)\n\t\t2'b00: o_data <= data_reg;\n\t\t2'b01: o_data <= { 1'b0, data_reg[7:1] };\n\t\t2'b10: o_data <= { 2'b0, data_reg[7:2] };\n\t\t2'b11: o_data <= { 3'b0, data_reg[7:3] };\n\t\tendcase\n\tend else if ((zero_baud_counter)||(state == RXU_IDLE))\n\t\tpre_wr <= 1'b0;\n\tinitial\to_wr   = 1'b0;\n\talways @(posedge i_clk)\n\tif ((zero_baud_counter)||(state == RXU_IDLE))\n\t\to_wr <= (pre_wr)&&(!i_reset);\n\telse\n\t\to_wr <= 1'b0;\n\talways @(posedge i_clk)\n\tif (i_reset)\n\t\tbaud_counter <= clocks_per_baud-28'h01;\n\telse if (zero_baud_counter)\n\t\tbaud_counter <= clocks_per_baud-28'h01;\n\telse case(state)\n\t\tRXU_RESET_IDLE:baud_counter <= clocks_per_baud-28'h01;\n\t\tRXU_BREAK:\tbaud_counter <= clocks_per_baud-28'h01;\n\t\tRXU_IDLE:\tbaud_counter <= clocks_per_baud-28'h01;\n\t\tdefault:\tbaud_counter <= baud_counter-28'h01;\n\tendcase\n\tinitial\tzero_baud_counter = 1'b0;\n\talways @(posedge i_clk)\n\tif (state == RXU_IDLE)\n\t\tzero_baud_counter <= 1'b0;\n\telse\n\t\tzero_baud_counter <= (baud_counter == 28'h01);\n\tendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_or_not_a8baa343", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_or_not(\n    output y,\n    input a, b, rsb\n);\n\nreg yi;\n\nalways @ (a or b or rsb) begin\n    if (rsb == 0) begin\n        yi <= 1;\n    end\n    else if (a & b) begin\n        yi <= 1;\n    end\n    else if (a == 0 & b == 0) begin\n        yi <= 0;\n    end\n    else begin\n        yi <= a & b;\n    end\nend\n\nassign #1 y = yi;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_counter_ed853aa5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sync_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter #_cbcbb5ad", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_counter #(\n  parameter WIDTH = 4\n) (\n  // Input signals\n  input clk,\n  input reset, // Active low reset\n  input count_up, // Active high count up input\n  input count_down, // Active high count down input\n  // Output signals\n  output reg [WIDTH-1:0] count_out\n);\n\n  // State definition\n  localparam INIT = 2'b00;\n  localparam COUNT_UP = 2'b01;\n  localparam COUNT_DOWN = 2'b10;\n  localparam RESET = 2'b11;\n\n  // State register and next state logic\n  reg [1:0] state_reg, state_next;\n  always @(posedge clk, negedge reset) begin\n    if (!reset) begin\n      state_reg <= INIT;\n    end else begin\n      state_reg <= state_next;\n    end\n  end\n\n  // Output logic\n  always @(posedge clk) begin\n    case (state_reg)\n      INIT: count_out <= {WIDTH{1'b0}};\n      COUNT_UP: count_out <= count_out + 1'b1;\n      COUNT_DOWN: count_out <= count_out - 1'b1;\n      RESET: count_out <= {WIDTH{1'b0}};\n    endcase\n  end\n\n  // Next state logic\n  always @(*) begin\n    case (state_reg)\n      INIT: begin\n        if (count_up) begin\n          state_next = COUNT_UP;\n        end else if (count_down) begin\n          state_next = COUNT_DOWN;\n        end else begin\n          state_next = INIT;\n        end\n      end\n      COUNT_UP: begin\n        if (count_up) begin\n          state_next = COUNT_UP;\n        end else if (count_out == {WIDTH{1'b1}}) begin\n          state_next = INIT;\n        end else begin\n          state_next = COUNT_UP;\n        end\n      end\n      COUNT_DOWN: begin\n        if (count_down) begin\n          state_next = COUNT_DOWN;\n        end else if (count_out == {WIDTH{1'b0}}) begin\n          state_next = INIT;\n        end else begin\n          state_next = COUNT_DOWN;\n        end\n      end\n      RESET: begin\n        state_next = RESET;\n      end\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mult_srst_ena_0fd68567", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mult_srst_ena (\n    input  wire        CLK,\n    input  wire        RST,\n    input  wire        ENA,\n    input  wire [ 8:0] A,\n    input  wire [ 8:0] B,\n    output wire [17:0] Z\n);\n\n    reg [8:0] ra;\n    always @(posedge CLK)\n        if (RST)      ra <= 0;\n        else if (ENA) ra <= A;\n\n    MULT9X9 mult (\n        .A (ra),\n        .B (B),\n        .Z (Z)\n    );\n\nendmodule\nmodule MULT9X9 (\n    input  wire [8:0] A,\n    input  wire [8:0] B,\n    output wire [17:0] Z\n);\n\n    wire [17:0] mult_out;\n    assign mult_out = A * B;\n\n    assign Z = mult_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_5de615e4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] result\n);\n\nreg [3:0] stage1_out;\nreg [3:0] stage2_out;\n\nwire [3:0] abs_B;\n\nassign abs_B = (B[3] == 1'b1) ? ~B + 1'b1 : B;\n\nalways @(*) begin\n    stage1_out = (B[3] == 1'b0) ? (A << B) : (A >> abs_B);\nend\n\nalways @(*) begin\n    stage2_out = stage1_out;\nend\n\nassign result = stage2_out;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dly_signal_06f60318", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dly_signal (clk, indata, outdata);\nparameter WIDTH = 1;\ninput clk;\ninput [WIDTH-1:0] indata;\noutput [WIDTH-1:0] outdata;\nreg [WIDTH-1:0] outdata, next_outdata;\nalways @(posedge clk) outdata = next_outdata;\nalways @*\nbegin\n  #1;\n  next_outdata = indata;\nend\nendmodule\n\n\n\nmodule pipeline_stall (clk, reset, datain, dataout);\nparameter WIDTH = 1;\nparameter DELAY = 1;\ninput clk, reset;\ninput [WIDTH-1:0] datain;\noutput [WIDTH-1:0] dataout;\nreg [(WIDTH*DELAY)-1:0] dly_datain, next_dly_datain;\nassign dataout = dly_datain[(WIDTH*DELAY)-1 : WIDTH*(DELAY-1)];\ninitial dly_datain = 0;\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset)\n    dly_datain = 0;\n  else dly_datain = next_dly_datain;\nend\nalways @*\nbegin\n  #1;\n  next_dly_datain = {dly_datain, datain};\nend\nendmodule\n\n\n\nmodule full_synchronizer (clk, reset, datain, dataout);\nparameter WIDTH = 1;\ninput clk, reset;\ninput [WIDTH-1:0] datain;\noutput [WIDTH-1:0] dataout;\npipeline_stall #(WIDTH,2) sync (clk, reset, datain, dataout);\nendmodule\n\n\nmodule reset_sync (clk, hardreset, reset);\ninput clk, hardreset;\noutput reset;\n\nreg [3:0] reset_reg, next_reset_reg;\nassign reset = reset_reg[3];\n\ninitial reset_reg = 4'hF;\nalways @ (posedge clk or posedge hardreset)\nbegin\n  if (hardreset)\n    reset_reg = 4'hF;\n  else reset_reg = next_reset_reg;\nend\n\nalways @*\nbegin\n  next_reset_reg = {reset_reg,1'b0};\nend\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__3ab762d5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    input clk,\n    input [2:0] sel, \n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [7:0] sum_out\n);\n\nreg out_2to1_mux;\nwire [3:0] out_6to1_mux;\n\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2)\n        out_2to1_mux <= b;\n    else\n        out_2to1_mux <= a;\nend\n\nmux_6to1 mux_inst (\n    .sel(sel),\n    .data0(data0),\n    .data1(data1),\n    .data2(data2),\n    .data3(data3),\n    .data4(data4),\n    .data5(data5),\n    .out(out_6to1_mux)\n);\n\nalways @(posedge clk) begin\n    sum_out <= out_2to1_mux + out_6to1_mux;\nend\n\nendmodule\n\nmodule mux_6to1 (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = data0;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_bca7520c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module(\n    input a,\n    input b,\n    input sel_xor,\n    input sel_mux,\n    output wire out_always\n);\n\nwire xor_out;\nwire mux_out;\n\nxor_gate xor_inst(\n    .a(a),\n    .b(b),\n    .out(xor_out)\n);\n\nmux_2to1 mux_inst(\n    .a(a),\n    .b(b),\n    .sel(sel_mux),\n    .out(mux_out)\n);\n\nassign out_always = (sel_xor & ~sel_mux) ? xor_out :\n                    (sel_mux & ~sel_xor) ? mux_out :\n                    (sel_mux & sel_xor) ? 1'b1 : 1'b0;\n\nendmodule\nmodule xor_gate(\n    input a,\n    input b,\n    output wire out\n);\n\nassign out = a ^ b;\n\nendmodule\nmodule mux_2to1(\n    input a,\n    input b,\n    input sel,\n    output wire out\n);\n\nassign out = sel ? b : a;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "arithshiftbidir_1a127d3f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule arithshiftbidir(distance,\n                       data,\n                       direction,\n                       result);\n\n   parameter             lpm_type = \"LPM_CLSHIFT\";\n   parameter             lpm_shifttype = \"ARITHMETIC\";\n   parameter             lpm_width = 32;\n   parameter             lpm_widthdist = 5;\n   \n   input  wire [lpm_widthdist-1:0] distance;\n   input  signed [lpm_width-1    :0] data;\n   input  wire                     direction;\n   output wire [lpm_width-1    :0] result;\n\n   wire   [lpm_width-1    :0] lsh    = data << distance;\n   wire   [lpm_width-1    :0] rsh    = data >> distance;\n   wire   [lpm_width-1    :0] rshN   = ~(~data >> distance);\n   wire   [lpm_width-1    :0] arsh   = data[lpm_width-1] ? rshN : rsh;\n   assign                     result = direction ? arsh : lsh;\n   \nendmodule\n\n`ifdef TEST_ARITHSHIFTBIDIR\nmodule test_arithshiftbidir();\n   reg  [31:0] data;\n   reg  [ 4:0] dist;\n   reg         dir;\n   wire [31:0] resulta, resultl;\n   \n   arithshiftbidir a(dist, data, dir, resulta);\n   defparam    a.lpm_shifttype = \"ARITHMETIC\";\n   \n   initial begin\n      #0 data = 48; dir = 0; dist = 0;\n      $monitor(\"dir %d dist %2d A %8x\", dir, dist, resulta);\n      repeat (2) begin\n         repeat (32)\n           #1 dist = dist + 1;\n         data = 32'h98765432;\n         dir = ~dir;\n      end      \n      dir = 1;\n      data = 32'h08765432;\n      repeat (32)\n        #1 dist = dist + 1;\n   end   \nendmodule\n`endif\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wasca_external_sdram_controller_input_efifo__9f22c86e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wasca_external_sdram_controller_input_efifo_module (\n  // inputs:\n  clk,\n  rd,\n  reset_n,\n  wr,\n  wr_data,\n\n  // outputs:\n  almost_empty,\n  almost_full,\n  empty,\n  full,\n  rd_data\n);\n\n  output almost_empty;\n  output almost_full;\n  output empty;\n  output full;\n  output [42:0] rd_data;\n  input clk;\n  input rd;\n  input reset_n;\n  input wr;\n  input [42:0] wr_data;\n\n  wire almost_empty;\n  wire almost_full;\n  wire empty;\n  reg [1:0] entries;\n  reg [42:0] entry_0;\n  reg [42:0] entry_1;\n  wire full;\n  reg rd_address;\n  reg [42:0] rd_data;\n  wire [1:0] rdwr;\n  reg wr_address;\n  assign rdwr = {rd, wr};\n  assign full = entries == 2;\n  assign almost_full = entries >= 1;\n  assign empty = entries == 0;\n  assign almost_empty = entries <= 1;\n  \n  always @(entry_0 or entry_1 or rd_address) begin\n    case (rd_address)\n      1'd0: rd_data = entry_0;\n      1'd1: rd_data = entry_1;\n      default: rd_data = 0;\n    endcase\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      wr_address <= 0;\n      rd_address <= 0;\n      entries <= 0;\n    end else begin\n      case (rdwr)\n        2'd1: begin\n          // Write data\n          if (!full) begin\n            entries <= entries + 1;\n            wr_address <= (wr_address == 1) ? 0 : (wr_address + 1);\n          end\n        end\n        2'd2: begin\n          // Read data\n          if (!empty) begin\n            entries <= entries - 1;\n            rd_address <= (rd_address == 1) ? 0 : (rd_address + 1);\n          end\n        end\n        2'd3: begin\n          wr_address <= (wr_address == 1) ? 0 : (wr_address + 1);\n          rd_address <= (rd_address == 1) ? 0 : (rd_address + 1);\n        end\n        default: begin\n        end\n      endcase\n    end\n  end\n\n  always @(posedge clk) begin\n    //Write data\n    if (wr & !full) begin\n      case (wr_address)\n        1'd0: entry_0 <= wr_data;\n        1'd1: entry_1 <= wr_data;\n        default: begin\n        end\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MUX4_29188fab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MUX4 (\n    A,\n    B,\n    C,\n    D,\n    S0,\n    S1,\n    Y\n);\n  input A, B, C, D, S0, S1;\n  output Y;\n  \n  wire MUX0_out, MUX1_out;\n  \n  // Instantiating 2-to-1 multiplexers\n  MUX2x1 MUX0 (\n      .A (A),\n      .B (B),\n      .S (S0),\n      .Q (MUX0_out)\n  );\n  \n  MUX2x1 MUX1 (\n      .A (C),\n      .B (D),\n      .S (S0),\n      .Q (MUX1_out)\n  );\n  \n  // Final 2-to-1 multiplexer\n  MUX2x1 MUX2 (\n      .A (MUX0_out),\n      .B (MUX1_out),\n      .S (S1),\n      .Q (Y)\n  );\n  \nendmodule\n\n// 2-to-1 multiplexer building block\nmodule MUX2x1 (\n    A,\n    B,\n    S,\n    Q\n);\n  input A, B, S;\n  output Q;\n  \n  assign Q = (S == 1'b0) ? A : B;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__44065fca", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    A3  ,\n    B1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    // Module ports\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire or0_out          ;\n    wire nand0_out_Y      ;\n\n    //                                 Name         Output             Other arguments\n    or                                 or0         (or0_out          , A2, A1, A3             );\n    nand                               nand0       (nand0_out_Y      , B1, or0_out            );\n    buf                               buf0        (Y                , nand0_out_Y, VPWR, VGND, VPB, VNB  ); // Changed the buffer type\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_counter_3f5735c0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule johnson_counter (\n  input clock,\n  output [n-1:0] out\n);\n\nparameter n = 4; // number of output signals\n\nreg [n-1:0] shift_reg;\nwire [n-1:0] next_state;\n\nassign next_state[0] = shift_reg[n-1] ^ shift_reg[n-2];\nassign next_state[n-1] = shift_reg[n-2] ^ shift_reg[n-3];\n\ngenvar i;\ngenerate\n  for (i = 1; i < n-1; i = i+1) begin\n    assign next_state[i] = shift_reg[i-1] ^ shift_reg[i] ^ shift_reg[i+1];\n  end\nendgenerate\n\nalways @(posedge clock) begin\n  shift_reg <= next_state;\nend\n\nassign out = shift_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_16to1_sel4_7_1 #_7611abd4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_16to1_sel4_7_1 #(\n    parameter ID = 0,\n    parameter NUM_STAGE = 1,\n    parameter din1_WIDTH = 7,\n    parameter din2_WIDTH = 7,\n    parameter din3_WIDTH = 7,\n    parameter din4_WIDTH = 7,\n    parameter din5_WIDTH = 7,\n    parameter din6_WIDTH = 7,\n    parameter din7_WIDTH = 7,\n    parameter din8_WIDTH = 7,\n    parameter din9_WIDTH = 7,\n    parameter din10_WIDTH = 7,\n    parameter din11_WIDTH = 7,\n    parameter din12_WIDTH = 7,\n    parameter din13_WIDTH = 7,\n    parameter din14_WIDTH = 7,\n    parameter din15_WIDTH = 7,\n    parameter din16_WIDTH = 7,\n    parameter din17_WIDTH = 4,\n    parameter dout_WIDTH = 7\n)(\n    input [din1_WIDTH-1:0] din1,\n    input [din2_WIDTH-1:0] din2,\n    input [din3_WIDTH-1:0] din3,\n    input [din4_WIDTH-1:0] din4,\n    input [din5_WIDTH-1:0] din5,\n    input [din6_WIDTH-1:0] din6,\n    input [din7_WIDTH-1:0] din7,\n    input [din8_WIDTH-1:0] din8,\n    input [din9_WIDTH-1:0] din9,\n    input [din10_WIDTH-1:0] din10,\n    input [din11_WIDTH-1:0] din11,\n    input [din12_WIDTH-1:0] din12,\n    input [din13_WIDTH-1:0] din13,\n    input [din14_WIDTH-1:0] din14,\n    input [din15_WIDTH-1:0] din15,\n    input [din16_WIDTH-1:0] din16,\n    input [din17_WIDTH-1:0] din17,\n    input [3:0] sel,\n    output [dout_WIDTH-1:0] dout\n);\n\n// Internal wires\nwire [din1_WIDTH-1:0] mux_1_0, mux_1_1, mux_1_2, mux_1_3, mux_1_4, mux_1_5, mux_1_6, mux_1_7;\nwire [din1_WIDTH-1:0] mux_2_0, mux_2_1, mux_2_2, mux_2_3;\nwire [din1_WIDTH-1:0] mux_3_0, mux_3_1;\nwire [din1_WIDTH-1:0] mux_4_0;\n\n// Generate level 1 logic\nassign mux_1_0 = (sel[0] == 0) ? din1 : din2;\nassign mux_1_1 = (sel[0] == 0) ? din3 : din4;\nassign mux_1_2 = (sel[0] == 0) ? din5 : din6;\nassign mux_1_3 = (sel[0] == 0) ? din7 : din8;\nassign mux_1_4 = (sel[0] == 0) ? din9 : din10;\nassign mux_1_5 = (sel[0] == 0) ? din11 : din12;\nassign mux_1_6 = (sel[0] == 0) ? din13 : din14;\nassign mux_1_7 = (sel[0] == 0) ? din15 : din16;\n\n// Generate level 2 logic\nassign mux_2_0 = (sel[1] == 0) ? mux_1_0 : mux_1_1;\nassign mux_2_1 = (sel[1] == 0) ? mux_1_2 : mux_1_3;\nassign mux_2_2 = (sel[1] == 0) ? mux_1_4 : mux_1_5;\nassign mux_2_3 = (sel[1] == 0) ? mux_1_6 : mux_1_7;\n\n// Generate level 3 logic\nassign mux_3_0 = (sel[2] == 0) ? mux_2_0 : mux_2_1;\nassign mux_3_1 = (sel[2] == 0) ? mux_2_2 : mux_2_3;\n\n// Generate level 4 logic\nassign mux_4_0 = (sel[3] == 0) ? mux_3_0 : mux_3_1;\n\n// Output logic\nassign dout = mux_4_0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_5f1ecdd0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input CLK,\n    input UD,\n    output reg [3:0] Q\n);\n\n    always @(posedge CLK) begin\n        if (UD == 1'b0) begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end else begin\n            if (Q == 4'b0000) begin\n                Q <= 4'b1111;\n            end else begin\n                Q <= Q - 1;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nios_system_alu_control_9633994c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nios_system_alu_control (\n                                 // inputs:\n                                  address,\n                                  chipselect,\n                                  clk,\n                                  reset_n,\n                                  write_n,\n                                  writedata,\n\n                                 // outputs:\n                                  out_port,\n                                  readdata\n                               )\n;\n\n  output  [  2: 0] out_port;\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            chipselect;\n  input            clk;\n  input            reset_n;\n  input            write_n;\n  input   [ 31: 0] writedata;\n\n  wire             clk_en;\n  reg     [  2: 0] data_out;\n  wire    [  2: 0] out_port;\n  wire    [  2: 0] read_mux_out;\n  wire    [ 31: 0] readdata;\n  assign clk_en = 1;\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {3 {(address == 0)}} & data_out;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          data_out <= 0;\n      else if (chipselect && ~write_n && (address == 0))\n          data_out <= writedata[2 : 0];\n    end\n\n\n  assign readdata = {32'b0 | read_mux_out};\n  assign out_port = data_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sequence_detector_b4f39860", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sequence_detector (\n  input in,\n  output out,\n  input clk,\n  input reset\n);\n\n  // define your inputs and outputs here\n  reg [1:0] state;\n  parameter START = 2'b00;\n  parameter FINAL = 2'b01;\n  \n  // define your states and transitions here\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      state <= START;\n    end else begin\n      case(state)\n        START: begin\n          if (in == 1'b1) begin\n            state <= FINAL;\n          end else begin\n            state <= START;\n          end\n        end\n        FINAL: begin\n          if (in == 1'b0) begin\n            state <= START;\n          end else begin\n            state <= FINAL;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // define your combinational logic circuit here\n  assign out = (state == FINAL);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "voltage_supply_circuit_24957fd3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule voltage_supply_circuit (\n    X,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n    input C1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Instantiate the gates\n    wire X_int;\n    nand3 U1 (A1, A2, A3, X_int);\n    nand2 U2 (B1, C1, X);\n\nendmodule\n\nmodule nand3 (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    assign Y = ~(A & B & C);\nendmodule\n\nmodule nand2 (\n    input A,\n    input B,\n    output Y\n);\n\n    assign Y = ~(A & B);\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_6to1_14002446", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_6to1 (\n    input [2:0] sel,\n    input [3:0] in0,\n    input [3:0] in1,\n    input [3:0] in2,\n    input [3:0] in3,\n    input [3:0] in4,\n    input [3:0] in5,\n    output [3:0] out\n);\n\n    // Using a variable to store the internal output\n    reg [3:0] mux_out_int;\n\n    always @(*) begin\n        case (sel)\n            3'b000: mux_out_int = in0;\n            3'b001: mux_out_int = in1;\n            3'b010: mux_out_int = in2;\n            3'b011: mux_out_int = in3;\n            3'b100: mux_out_int = in4;\n            3'b101: mux_out_int = in5;\n            default: mux_out_int = 4'b0000;\n        endcase\n    end\n\n    // Assign the internal output to the external output\n    assign out = mux_out_int;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "value_buffer_4d09df54", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule value_buffer(\n\tclk,\n\tc0_in,\n\tc1_in,\n\tc2_in,\n\tc3_in,\n\tc0_up,\n\tc1_up,\n\tc2_up,\n\tc3_up,\n\tc0_down,\n\tc1_down,\n\tc2_down,\n\tc3_down\n);\n\t\ninput  clk;\ninput  [63:0] c0_in;\ninput  [63:0] c1_in;\ninput  [63:0] c2_in;\ninput  [63:0] c3_in;\n\noutput [63:0] c0_up;\noutput [63:0] c1_up;\noutput [63:0] c2_up;\noutput [63:0] c3_up;\n\noutput [63:0] c0_down;\noutput [63:0] c1_down;\noutput [63:0] c2_down;\noutput [63:0] c3_down;\n\nreg [63:0] buffer0;\nreg [63:0] buffer1;\nreg [63:0] buffer2;\nreg [63:0] buffer3;\n\nalways@(posedge clk) begin\n  buffer0 <= c0_in;\n  buffer1 <= c1_in;\n  buffer2 <= c2_in;\n  buffer3 <= c3_in; \n  end\n\nassign c0_down = buffer0;\nassign c1_down = buffer1;\nassign c2_down = buffer2;\nassign c3_down = buffer3;\n\nassign c0_up = buffer1;\nassign c1_up = buffer2;\nassign c2_up = buffer3;\nassign c3_up = c0_in;\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_divider_fe29fd7c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_divider (\n    input wire CLK,\n    input wire RESET,\n    input wire CE,\n    output reg CLOCK\n);\n\n    parameter DIVISOR = 8;\n    reg [DIVISOR-1:0] counter;\n    \n    always @(posedge CLK or negedge RESET) begin\n        if (!RESET) begin\n            counter <= 0;\n            CLOCK <= 0;\n        end else if (CE) begin\n            counter <= counter + 1;\n            if (counter == DIVISOR-1) begin\n                counter <= 0;\n                CLOCK <= ~CLOCK;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_protocol_converter_v2_1_b2s_incr_cmd #_8d8daa4f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n \nmodule axi_protocol_converter_v2_1_b2s_incr_cmd #\n(\nparameter integer C_AXI_ADDR_WIDTH            = 32\n)\n(\ninput  wire                                 clk           ,\n  input  wire                                 reset         ,\n  input  wire [C_AXI_ADDR_WIDTH-1:0]          axaddr        ,\n  input  wire [7:0]                           axlen         ,\n  input  wire [2:0]                           axsize        ,\n  input  wire                                 axhandshake   ,\n  output wire [C_AXI_ADDR_WIDTH-1:0]          cmd_byte_addr ,\n  input  wire                                 next          ,\n  output reg                                  next_pending\n\n);\nreg                           sel_first;\nreg  [11:0]                   axaddr_incr;\nreg  [8:0]                    axlen_cnt;\nreg                           next_pending_r;\nwire [3:0]                    axsize_shift;\nwire [11:0]                   axsize_mask;\n\nlocalparam    L_AXI_ADDR_LOW_BIT = (C_AXI_ADDR_WIDTH >= 12) ? 12 : 11;\n\ngenerate\n  if (C_AXI_ADDR_WIDTH > 12) begin : ADDR_GT_4K\n    assign cmd_byte_addr = (sel_first) ? axaddr : {axaddr[C_AXI_ADDR_WIDTH-1:L_AXI_ADDR_LOW_BIT],axaddr_incr[11:0]};\n  end else begin : ADDR_4K\n    assign cmd_byte_addr = (sel_first) ? axaddr : axaddr_incr[11:0];\n  end\nendgenerate\n\nassign axsize_shift = (1 << axsize[1:0]);\nassign axsize_mask  = ~(axsize_shift - 1'b1);\n\nalways @(posedge clk) begin\n  if (sel_first) begin\n    if(~next) begin\n      axaddr_incr <= axaddr[11:0] & axsize_mask;\n    end else begin\n      axaddr_incr <= (axaddr[11:0] & axsize_mask) + axsize_shift;\n    end\n  end else if (next) begin\n    axaddr_incr <= axaddr_incr + axsize_shift;\n  end\nend\n\nalways @(posedge clk) begin\n  if (axhandshake)begin\n     axlen_cnt <= axlen;\n     next_pending_r <= (axlen >= 1);\n  end else if (next) begin\n    if (axlen_cnt > 1) begin\n      axlen_cnt <= axlen_cnt - 1;\n      next_pending_r <= ((axlen_cnt - 1) >= 1);\n    end else begin\n      axlen_cnt <= 9'd0;\n      next_pending_r <= 1'b0;\n    end\n  end\nend\n\nalways @( * ) begin\n  if (axhandshake)begin\n     next_pending = (axlen >= 1);\n  end else if (next) begin\n    if (axlen_cnt > 1) begin\n      next_pending = ((axlen_cnt - 1) >= 1);\n    end else begin\n      next_pending = 1'b0;\n    end\n  end else begin\n    next_pending = next_pending_r;\n  end\nend\n\nalways @(posedge clk) begin\n  if (reset | axhandshake) begin\n    sel_first <= 1'b1;\n  end else if (next) begin\n    sel_first <= 1'b0;\n  end\nend\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor_gate_9bd74f71", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule nor_gate(\n    input a,\n    input b,\n    output out\n);\n    wire temp1, temp2;\n    not_gate not1(a, temp1);\n    not_gate not2(b, temp2);\n    and_gate and1(temp1, temp2, out);\nendmodule\nmodule shift_register(\n    input clk,\n    input rst,\n    input data,\n    output reg [2:0] out\n);\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            out <= 3'b0;\n        end else begin\n            out[2:1] <= out[1:0];\n            out[0] <= data;\n        end\n    end\nendmodule\nmodule or_module(\n    input a,\n    input [2:0] b,\n    output out\n);\n    wire temp1, temp2;\n    nor_gate nor1(a, b[0], temp1);\n    nor_gate nor2(temp1, b[1], temp2);\n    nor_gate nor3(temp2, b[2], out);\nendmodule\nmodule top_module(\n    input a,\n    input b,\n    input clk,\n    input rst,\n    input data,\n    output out\n);\n    wire [2:0] shift_out;\n    shift_register shift_reg(clk, rst, data, shift_out);\n    or_module or_mod(a, shift_out, out);\nendmodule\nmodule not_gate(\n    input in,\n    output out\n);\n    assign out = !in;\nendmodule\nmodule and_gate(\n    input a,\n    input b,\n    output out\n);\n    assign out = a && b;\nendmodule\nmodule nor_gate_level(\n    input a,\n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "asfifo_graycounter #_7c16239c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule asfifo_graycounter #(\n\tparameter width = 2\n) (\n\toutput reg [width-1:0] gray_count,\n\tinput ce,\n\tinput rst,\n\tinput clk\n);\n\nreg [width-1:0] binary_count;\n\nalways @(posedge clk, posedge rst) begin\n\tif(rst) begin\n\t\tbinary_count <= {width{1'b0}} + 1;\n\t\tgray_count <= {width{1'b0}};\n\tend else if(ce) begin\n\t\tbinary_count <= binary_count + 1;\n\t\tgray_count <= {binary_count[width-1],\n\t\t\t\tbinary_count[width-2:0] ^ binary_count[width-1:1]};\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "etx_cfg_28ede952", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule etx_cfg (\n   input reset,\n   input clk,\n   input mi_en,\n   input mi_we,\n   input [6:0] mi_addr,\n   input [31:0] mi_din,\n   input [15:0] tx_status,\n   output [31:0] mi_dout,\n   output tx_enable,\n   output mmu_enable,\n   output gpio_enable,\n   output remap_enable,\n   output [8:0] gpio_data,\n   output [3:0] ctrlmode,\n   output ctrlmode_bypass\n);\n\n   // Compile-time parameters\n   parameter PW = 104;\n   parameter RFAW = 6;\n   parameter DEFAULT_VERSION = 16'h0000;\n\n   // Registers\n   reg [15:0] ecfg_version_reg;\n   reg [10:0] ecfg_tx_config_reg;\n   reg [8:0] ecfg_tx_gpio_reg;\n   reg [2:0] ecfg_tx_status_reg;\n   reg [31:0] mi_dout;\n   reg ecfg_access;\n\n   // Wires\n   wire ecfg_read;\n   wire ecfg_write;\n   wire ecfg_version_write;\n   wire ecfg_tx_config_write;\n   wire ecfg_tx_gpio_write;\n   wire ecfg_tx_status_write;\n   wire loop_mode;\n\n   // Address decode logic\n   assign ecfg_write = mi_en & mi_we;\n   assign ecfg_read = mi_en & ~mi_we;\n   assign ecfg_version_write = ecfg_write & (mi_addr[6:2] == 5'b00000);\n   assign ecfg_tx_config_write = ecfg_write & (mi_addr[6:2] == 5'b00010);\n   assign ecfg_tx_status_write = ecfg_write & (mi_addr[6:2] == 5'b00011);\n   assign ecfg_tx_gpio_write = ecfg_write & (mi_addr[6:2] == 5'b00100);\n\n   // Version register\n   always @(posedge clk) begin\n      if (reset) begin\n         ecfg_version_reg <= DEFAULT_VERSION;\n      end else if (ecfg_version_write) begin\n         ecfg_version_reg <= mi_din[15:0];\n      end\n   end\n\n   // Configuration register\n   always @(posedge clk) begin\n      if (reset) begin\n         ecfg_tx_config_reg <= 11'b0;\n      end else if (ecfg_tx_config_write) begin\n         ecfg_tx_config_reg <= mi_din[10:0];\n      end\n   end\n\n   // Status register\n   always @(posedge clk) begin\n      if (reset) begin\n         ecfg_tx_status_reg <= 3'b0;\n      end else if (ecfg_tx_status_write) begin\n         ecfg_tx_status_reg <= {3'b0, tx_status[2:0]};\n      end\n   end\n\n   // GPIO data register\n   always @(posedge clk) begin\n      if (ecfg_tx_gpio_write) begin\n         ecfg_tx_gpio_reg <= mi_din[8:0];\n      end\n   end\n\n   // Data readback mux\n   always @(posedge clk) begin\n      if (ecfg_read) begin\n         case (mi_addr[6:2])\n            5'b00000: mi_dout <= {16'b0, ecfg_version_reg};\n            5'b00010: mi_dout <= {21'b0, ecfg_tx_config_reg};\n            5'b00011: mi_dout <= {16'b0, tx_status[15:3], ecfg_tx_status_reg};\n            5'b00100: mi_dout <= {23'b0, ecfg_tx_gpio_reg};\n            default: mi_dout <= 32'd0;\n         endcase\n      end else begin\n         mi_dout <= 32'd0;\n      end\n   end\n\n   // Control signals\n   assign tx_enable = 1'b1;\n   assign mmu_enable = ecfg_tx_config_reg[1];\n   assign remap_enable = ecfg_tx_config_reg[3:2] == 2'b01;\n   assign ctrlmode[3:0] = ecfg_tx_config_reg[7:4];\n   assign ctrlmode_bypass = ecfg_tx_config_reg[8];\n   assign gpio_enable = (ecfg_tx_config_reg[10:9] == 2'b01);\n   assign gpio_data[8:0] = ecfg_tx_gpio_reg[8:0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rj45_led_controller_d63b2e77", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rj45_led_controller(\n  input  wire         clk,  // 150 MHz\n  input  wire         reset,\n\n  //--------------------------------------------------------------------------\n  //------------------------CONTROL INTERFACE---------------------------------\n  //--------------------------------------------------------------------------\n  input  wire        write_req,\n  input  wire        read_req,\n  input  wire [31:0] data_write,\n  output reg  [31:0] data_read,\n  input  wire [25:0] address,\n  output wire        busy,\n\n  //--------------------------------------------------------------------------\n  //---------------------------HW INTERFACE-----------------------------------\n  //--------------------------------------------------------------------------\n  output wire         rj45_led_sck,\n  output wire         rj45_led_sin,\n  output wire         rj45_led_lat,\n  output wire         rj45_led_blk\n);\n\nlocalparam IDLE   = 3'd0,\n           READ   = 3'd1,\n           WRITE  = 4'd2;\nlocalparam CLK_DIV = 3;\n\nwire update_out;\n\nreg [CLK_DIV:0] clk_div1;\nreg [CLK_DIV:0] clk_div2;\nreg             clk_enable;\nreg [15:0]      output_shifter;\nreg [4:0]       write_counter;\nreg             latch;\n\nreg [2:0]       state;\nreg             busy_int;\nreg [31:0]      value_cache;\n\nassign rj45_led_sck = clk_div2[CLK_DIV] & clk_enable;\nassign rj45_led_sin = output_shifter[15];\nassign rj45_led_lat = latch;\nassign rj45_led_blk = 0;\n\nassign update_out = ~clk_div1[CLK_DIV] & clk_div2[CLK_DIV]; // negedge serial clock\nassign busy = busy_int | read_req | write_req;\n\nalways @( posedge clk ) begin\n  if ( reset ) begin\n    clk_div1 <= 0;\n    clk_div2 <= 0;\n  end\n  else begin\n    clk_div2 <= clk_div1;\n    clk_div1 <= clk_div1 + 1;\n  end\nend\n\nalways @( posedge clk ) begin\n  if ( reset ) begin\n    state <= IDLE;\n    clk_enable <= 0;\n    output_shifter <= 16'h0000;\n    write_counter <= 5'h00;\n    latch <= 0;\n    busy_int <= 1;\n    value_cache <= 32'd0;\n  end\n  else begin\n    case ( state )\n      IDLE: begin\n        data_read <= 32'd0;\n        if ( write_req ) begin\n          state <= WRITE;\n          busy_int <= 1;\n          output_shifter <= {1'b0, data_write[0], 1'b0, data_write[1],\n                             1'b0, data_write[2], 1'b0, data_write[3],\n                             1'b0, data_write[4], 1'b0, data_write[5],\n                             1'b0, data_write[6], 1'b0, data_write[7]};\n          value_cache <= {24'd0, data_write[7:0]};\n          write_counter <= 0;\n\n        end\n        else if ( read_req ) begin\n          state <= READ;\n          busy_int <= 1;\n        end\n        else begin\n          busy_int <= 0;\n        end\n      end\n      WRITE: begin\n        if ( update_out ) begin\n          write_counter <= write_counter + 5'd1;\n          if ( write_counter == 0 ) begin\n            clk_enable <= 1;\n          end\n          else if ( write_counter < 5'd16) begin\n            output_shifter <= {output_shifter[14:0], 1'b0};\n          end\n          else if ( write_counter == 5'd16 ) begin\n            clk_enable <= 0;\n            latch <= 1;\n          end\n          else begin\n            state <= IDLE;\n            latch <= 0;\n            busy_int <= 0;\n          end\n        end\n      end\n      READ: begin\n        state <= IDLE;\n        busy_int <= 0;\n        data_read <= value_cache;\n      end\n    endcase\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ClockGenerator_75d1d648", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ClockGenerator (\n    input clk_in,\n    output reg clk_out\n);\n\n    // Clock period in ps\n    localparam PER = 20;\n\n    // Number of cycles for a 50 MHz clock\n    localparam COUNT_50MHZ = 100;\n\n    // Number of cycles for a 100 MHz clock\n    localparam COUNT_100MHZ = 50;\n\n    // Counter to keep track of the number of cycles\n    reg [7:0] counter = 0;\n\n    // Flip-flop to toggle the clock signal\n    always @(posedge clk_in) begin\n        counter <= counter + 1;\n        if (counter == COUNT_100MHZ) begin\n            counter <= 0;\n            clk_out <= ~clk_out;\n        end\n    end\n\n    // Frequency checker\n    reg [31:0] count = 0;\n    reg [31:0] expected_count = 0;\n    reg locked = 0;\n\n    always @(posedge clk_out) begin\n        count <= count + 1;\n        if (count == COUNT_50MHZ) begin\n            count <= 0;\n            if (expected_count == 0) begin\n                expected_count <= COUNT_50MHZ;\n            end else if (expected_count == COUNT_50MHZ) begin\n                expected_count <= COUNT_100MHZ;\n            end else if (expected_count == COUNT_100MHZ) begin\n                expected_count <= COUNT_50MHZ;\n            end\n\n            if (count == expected_count) begin\n                locked <= 1;\n            end else begin\n                locked <= 0;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Floating_Point_Arithmetic_189ca2d3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Floating_Point_Arithmetic (\n  input [31:0] operand1,\n  input [31:0] operand2,\n  input [1:0] operation,\n  output reg [31:0] result\n);\n\nparameter mantissa_width = 23; // width of the mantissa in bits\nparameter exponent_width = 8; // width of the exponent in bits\nparameter bias = 127; // bias of the exponent field\n\nreg [31:0] add_result, sub_result, mul_result, div_result;\nreg [31:0] operand2_neg;\n\n// Negate operand2 for subtraction\nalways @(*) begin\n  operand2_neg = {operand2[31], ~operand2[30:0] + 1'b1};\nend\n\n// Floating-point addition\nalways @(*) begin\n  add_result = operand1 + operand2;\nend\n\n// Floating-point subtraction\nalways @(*) begin\n  sub_result = operand1 - operand2_neg;\nend\n\n// Floating-point multiplication\nalways @(*) begin\n  mul_result = operand1 * operand2;\nend\n\n// Floating-point division\nalways @(*) begin\n  div_result = operand1 / operand2;\nend\n\n// Select the result based on the operation\nalways @(*) begin\n  case (operation)\n    2'b00: result = add_result;\n    2'b01: result = sub_result;\n    2'b10: result = mul_result;\n    2'b11: result = div_result;\n    default: result = 32'b0;\n  endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DPR16X4C_63b9b180", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule DPR16X4C (\n    input [3:0] DI,\n    input WCK, WRE,\n    input [3:0] RAD,\n    input [3:0] WAD,\n    output [3:0] DO\n);\n\n    reg [3:0] ram[0:15];\n    integer i;\n\n    function [63:0] convert_initval;\n        input [143:0] hex_initval;\n        reg done;\n        reg [63:0] temp;\n        reg [7:0] char;\n        integer i;\n        begin\n            done = 1'b0;\n            temp = 0;\n            for (i = 0; i < 16; i = i + 1) begin\n                if (!done) begin\n                    char = hex_initval[8*i +: 8];\n                    if (char == \"x\") begin\n                        done = 1'b1;\n                    end else begin\n                        if (char >= \"0\" && char <= \"9\")\n                            temp[4*i +: 4] = char - \"0\";\n                        else if (char >= \"A\" && char <= \"F\")\n                            temp[4*i +: 4] = 10 + char - \"A\";\n                        else if (char >= \"a\" && char <= \"f\")\n                            temp[4*i +: 4] = 10 + char - \"a\";\n                    end\n                end\n            end\n            convert_initval = temp;\n        end\n    endfunction\n\n    localparam conv_initval = convert_initval(\"1011111000001111101111100000111111011110000011111110111000001111\");\n\n    initial begin\n        for (i = 0; i < 15; i = i + 1) begin\n            ram[i] <= conv_initval[4*i +: 4];\n        end\n    end\n\n    always @(posedge WCK) begin\n        if (WRE) begin\n            ram[WAD] <= DI;\n        end\n    end\n\n    assign DO = (RAD > 15) ? 0 : ram[RAD];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "_4bit_binary_counter_a4074364", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule _4bit_binary_counter(\n    input CP,\n    input M,\n    input [3:0] D,\n    input LD_n,\n    input CLR_n,\n    output reg [3:0] Q,\n    output reg Qcc_n\n);\n    always @(posedge CP) begin\n        if (CLR_n == 0) begin\n            Q <= 0;\n        end else if (LD_n == 0) begin\n            Q <= D;\n        end else if (M == 1) begin\n            Q <= Q + 1;\n        end\n        Qcc_n <= ~Q[3];\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dual_port_ram_158b3163", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dual_port_ram (\n  input clock,\n  input [31:0] data_a,\n  input wren_a,\n  input [4:0] address_a,\n  input [31:0] data_b,\n  input wren_b,\n  input [4:0] address_b,\n  input rd_en_a,\n  input rd_en_b,\n  output reg [31:0] q_a,\n  output reg [31:0] q_b\n);\n\n  reg [31:0] mem [0:31];\n\n  always @(posedge clock) begin\n    if (wren_a) mem[address_a] <= data_a;\n    if (wren_b) mem[address_b] <= data_b;\n    if (rd_en_a) q_a <= mem[address_a];\n    if (rd_en_b) q_b <= mem[address_b];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart51_tx_c989dae1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart51_tx (\n    input BAUD_CLK,\n    input RESET_N,\n    output reg TX_DATA,\n    input TX_START,\n    output reg TX_DONE,\n    input TX_STOP,\n    input [1:0] TX_WORD,\n    input TX_PAR_DIS,\n    input [1:0] TX_PARITY,\n    input CTS,\n    input [7:0] TX_BUFFER\n);\n\n    reg [6:0] STATE;\n    reg [2:0] BIT;\n    wire PARITY;\n    reg TX_START0;\n    reg TX_START1;\n\n    assign PARITY = (~TX_PARITY[1] & ((TX_BUFFER[0] ^ TX_BUFFER[1]) ^ (TX_BUFFER[2] ^ TX_BUFFER[3])) ^ (TX_BUFFER[4] ^ (TX_BUFFER[5] & (TX_WORD != 2'b00))) ^ ((TX_BUFFER[6] & (TX_WORD[1] == 1'b1)) ^ (TX_BUFFER[7] & (TX_WORD == 2'b11)))) ^ ~TX_PARITY[0];\n\n    always @ (negedge BAUD_CLK or negedge RESET_N) begin\n        if (!RESET_N) begin\n            STATE <= 7'b0000000;\n            TX_DATA <= 1'b1;\n            TX_DONE <= 1'b1;\n            BIT <= 3'b000;\n            TX_START0 <= 1'b0;\n            TX_START1 <= 1'b0;\n        end else begin\n            TX_START0 <= TX_START;\n            TX_START1 <= TX_START0;\n            case (STATE)\n                7'b0000000: begin\n                    BIT <= 3'b000;\n                    TX_DATA <= 1'b1;\n                    if (TX_START1 == 1'b1) begin\n                        TX_DONE <= 1'b0;\n                        STATE <= 7'b0000001;\n                    end\n                end\n                7'b0000001: begin // Start bit\n                    TX_DATA <= 1'b0;\n                    STATE <= 7'b0000010;\n                end\n                7'b0010001: begin\n                    TX_DATA <= TX_BUFFER[BIT];\n                    STATE <= 7'b0010010;\n                end\n                7'b0100000: begin\n                    BIT <= BIT + 1'b1;\n                    if ((TX_WORD == 2'b00) && (BIT != 3'b111)) begin\n                        STATE <= 7'b0010001;\n                    end else begin\n                        if ((TX_WORD == 2'b01) && (BIT != 3'b110)) begin\n                            STATE <= 7'b0010001;\n                        end else begin\n                            if ((TX_WORD == 2'b10) && (BIT != 3'b101)) begin\n                                STATE <= 7'b0010001;\n                            end else begin\n                                if ((TX_WORD == 2'b11) && (BIT != 3'b100)) begin\n                                    STATE <= 7'b0010001;\n                                end else begin\n                                    if (!TX_PAR_DIS) begin\n                                        STATE <= 7'b0100001; // do parity\n                                    end else begin\n                                        STATE <= 7'b0110001; // do stop\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n                // Start parity bit\n                7'b0100001: begin\n                    TX_DATA <= PARITY;\n                    STATE <= 7'b0100010;\n                end\n                // start stop\n                7'b0110001: begin\n                    TX_DONE <= 1'b1;\n                    TX_DATA <= 1'b1;\n                    STATE <= 7'b0110010;\n                end\n                // end of first stop bit-1\n                7'b0111111: begin\n                    if (!TX_STOP) begin\n                        STATE <= 7'b1001111; // go check for CTS\n                    end else begin\n                        STATE <= 7'b1000000;\n                    end\n                end\n                7'b1001111: begin\n                    if (!CTS) begin // this is not correct for a 6551\n                        STATE <= 7'b0000000;\n                    end\n                end\n                default: STATE <= STATE + 1'b1;\n            endcase\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fp_add_a5d30ac0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fp_add (\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  wire [31:0] a_mantissa;\n  wire [31:0] b_mantissa;\n  wire [7:0] a_exponent;\n  wire [7:0] b_exponent;\n  wire a_sign;\n  wire b_sign;\n  wire c_sign;\n  wire [7:0] c_exponent;\n  wire [31:0] c_mantissa;\n  wire carry;\n  wire [31:0] temp;\n\n  assign a_mantissa = {1'b1, a[22:0]};\n  assign b_mantissa = {1'b1, b[22:0]};\n  assign a_exponent = a[30:23];\n  assign b_exponent = b[30:23];\n  assign a_sign = a[31];\n  assign b_sign = b[31];\n\n  assign {c_sign, c_exponent, c_mantissa, carry} =\n    a_sign == b_sign ?\n    {a_sign, a_exponent, a_mantissa + b_mantissa, 1'b0} :\n    {a_mantissa > b_mantissa ? a_sign : b_sign,\n     a_exponent > b_exponent ? a_exponent : b_exponent,\n     a_mantissa > b_mantissa ? a_mantissa - b_mantissa : b_mantissa - a_mantissa,\n     a_mantissa > b_mantissa ? 1'b0 : 1'b1};\n\n  assign c = {c_sign, c_exponent, c_mantissa[22:0]};\n\nendmodule\nmodule fp_sub (\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  wire [31:0] a_mantissa;\n  wire [31:0] b_mantissa;\n  wire [7:0] a_exponent;\n  wire [7:0] b_exponent;\n  wire a_sign;\n  wire b_sign;\n  wire c_sign;\n  wire [7:0] c_exponent;\n  wire [31:0] c_mantissa;\n  wire borrow;\n  wire [31:0] temp;\n\n  assign a_mantissa = {1'b1, a[22:0]};\n  assign b_mantissa = {1'b1, b[22:0]};\n  assign a_exponent = a[30:23];\n  assign b_exponent = b[30:23];\n  assign a_sign = a[31];\n  assign b_sign = b[31];\n\n  assign {c_sign, c_exponent, c_mantissa, borrow} =\n    a_sign == b_sign ?\n    {a_sign, a_exponent, a_mantissa + b_mantissa, 1'b0} :\n    {a_mantissa > b_mantissa ? a_sign : !b_sign,\n     a_exponent > b_exponent ? a_exponent : b_exponent,\n     a_mantissa > b_mantissa ? a_mantissa - b_mantissa : b_mantissa - a_mantissa,\n     a_mantissa > b_mantissa ? 1'b0 : 1'b1};\n\n  assign c = {c_sign, c_exponent, c_mantissa[22:0]};\n\nendmodule\nmodule fp_mul (\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  wire [31:0] a_mantissa;\n  wire [31:0] b_mantissa;\n  wire [7:0] a_exponent;\n  wire [7:0] b_exponent;\n  wire a_sign;\n  wire b_sign;\n  wire c_sign;\n  wire [7:0] c_exponent;\n  wire [63:0] temp;\n\n  assign a_mantissa = {1'b1, a[22:0]};\n  assign b_mantissa = {1'b1, b[22:0]};\n  assign a_exponent = a[30:23];\n  assign b_exponent = b[30:23];\n  assign a_sign = a[31];\n  assign b_sign = b[31];\n  assign temp = a_mantissa * b_mantissa;\n\n  assign c_sign = a_sign ^ b_sign;\n  assign c_exponent = a_exponent + b_exponent - 127;\n  assign c = {c_sign, c_exponent, temp[54:23]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_aa91dbdc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1(\n    input a, b, c, d,\n    output x, y, z\n);\n\nassign x = c ? a : b;\nassign y = c ? b : a;\nassign z = c ? d : b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_6097dd5e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\n    reg [3:0] next_count;\n    reg [3:0] curr_count;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            curr_count <= 4'b0000;\n            count <= curr_count;\n        end else begin\n            next_count <= curr_count + 4'b0001;\n            curr_count <= next_count;\n            count <= curr_count;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "coordinate_cordic_c0ae1266", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule coordinate_cordic\n(\n\trealIn,\n\timagIn,\n\tclk,\n\tamplitude,\n\tangle,\n\ttest1,\n\ttest2\n);\n\ninput signed [INWIDTH-1:0]realIn,imagIn;\ninput clk;\noutput signed [OUTWIDTH-1:0]amplitude;\noutput signed [ANGLEWIDTH-1:0]angle;\n\ninput  [9:0] test1;\noutput  [9:0] test2;\nassign  test2 = {11{test1}};\nparameter INWIDTH = 18,  OUTWIDTH = 20, MIDWIDTH = 21, ANGLEWIDTH =15;parameter ARCTANG_0  = 12'b10_01110_00100,ARCTANG_1  = 11'b1_01110_00100,ARCTANG_2  = 10'b11000_01100,ARCTANG_3  = 9'b1100_01100,ARCTANG_4  = 8'b110_00111,ARCTANG_5  = 7'b11_00011,ARCTANG_6  = 6'b1_10010,ARCTANG_7  = 5'b11001,ARCTANG_8  = 4'b1100,ARCTANG_9  = 3'b110,ARCTANG_10 = 2'b11,ARCTANG_11 = 2'b10;parameter HALFPI = 13'b100_11100_01000;reg signed [MIDWIDTH-1:0]xData1,xData2,xData3,xData4,xData5,xData6,\n                         xData7,xData8,xData9,xData10,xData11,xData12,\n                         xData13,xData14,xData15,xData16,\n\t\t\t\t         yData1,yData2,yData3,yData4,yData5,yData6,\n\t\t\t\t         yData7,yData8,yData9,yData10,yData11,yData12,\n\t\t\t\t         yData13,yData14,yData15,yData16;\n\nreg signed [ANGLEWIDTH-1:0]angle1,angle2,angle3,angle4,angle5,angle6,\n\t\t\t\t\t       angle7,angle8,angle9,angle10,angle11,angle12,\n\t\t\t\t\t       angle13,angle14,angle15,angle16;\n\n\nwire signed [MIDWIDTH-1:0]reIn,imIn;\nwire signed [ANGLEWIDTH-1:0]ang;\nassign reIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-imagIn:imagIn):realIn;\nassign imIn = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?realIn:-realIn):imagIn;\nassign ang = realIn[INWIDTH-1]?(imagIn[INWIDTH-1]?-HALFPI:HALFPI):1'b0;\n\n\nassign amplitude = {xData12[MIDWIDTH-1],xData12[MIDWIDTH-3:0]};\nassign angle = angle12;\n\n\n\nalways@(posedge clk)\nbegin\n    xData1 <= imIn[MIDWIDTH-1]?(reIn - imIn):(reIn + imIn);\n\tyData1 <= imIn[MIDWIDTH-1]?(imIn + reIn):(imIn - reIn);\n\tangle1 <= imIn[MIDWIDTH-1]?(ang - ARCTANG_0):(ang + ARCTANG_0);\n\n    xData2 <= yData1[MIDWIDTH-1]?(xData1 - {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]}):(xData1 + {{2{yData1[MIDWIDTH-1]}},yData1[MIDWIDTH-2:1]});\n\tyData2 <= yData1[MIDWIDTH-1]?(yData1 + {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]}):(yData1 - {{2{xData1[MIDWIDTH-1]}},xData1[MIDWIDTH-2:1]});\n\tangle2 <= yData1[MIDWIDTH-1]?(angle1 - ARCTANG_1):(angle1 + ARCTANG_1);\n\n    xData3 <= yData2[MIDWIDTH-1]?(xData2 - {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]}):(xData2 + {{3{yData2[MIDWIDTH-1]}},yData2[MIDWIDTH-2:2]});\n\tyData3 <= yData2[MIDWIDTH-1]?(yData2 + {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]}):(yData2 - {{3{xData2[MIDWIDTH-1]}},xData2[MIDWIDTH-2:2]});\n\tangle3 <= yData2[MIDWIDTH-1]?(angle2 - ARCTANG_2):(angle2 + ARCTANG_2);\n\n    xData4 <= yData3[MIDWIDTH-1]?(xData3 - {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]}):(xData3 + {{4{yData3[MIDWIDTH-1]}},yData3[MIDWIDTH-2:3]});\n\tyData4 <= yData3[MIDWIDTH-1]?(yData3 + {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]}):(yData3 - {{4{xData3[MIDWIDTH-1]}},xData3[MIDWIDTH-2:3]});\n\tangle4 <= yData3[MIDWIDTH-1]?(angle3 - ARCTANG_3):(angle3 + ARCTANG_3);\n\n    xData5 <= yData4[MIDWIDTH-1]?(xData4 - {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]}):(xData4 + {{5{yData4[MIDWIDTH-1]}},yData4[MIDWIDTH-2:4]});\n\tyData5 <= yData4[MIDWIDTH-1]?(yData4 + {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]}):(yData4 - {{5{xData4[MIDWIDTH-1]}},xData4[MIDWIDTH-2:4]});\n\tangle5 <= yData4[MIDWIDTH-1]?(angle4 - ARCTANG_4):(angle4 + ARCTANG_4);\n\n    xData6 <= yData5[MIDWIDTH-1]?(xData5 - {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]}):(xData5 + {{6{yData5[MIDWIDTH-1]}},yData5[MIDWIDTH-2:5]});\n\tyData6 <= yData5[MIDWIDTH-1]?(yData5 + {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]}):(yData5 - {{6{xData5[MIDWIDTH-1]}},xData5[MIDWIDTH-2:5]});\n\tangle6 <= yData5[MIDWIDTH-1]?(angle5 - ARCTANG_5):(angle5 + ARCTANG_5);\n\n    xData7 <= yData6[MIDWIDTH-1]?(xData6 - {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]}):(xData6 + {{7{yData6[MIDWIDTH-1]}},yData6[MIDWIDTH-2:6]});\n\tyData7 <= yData6[MIDWIDTH-1]?(yData6 + {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]}):(yData6 - {{7{xData6[MIDWIDTH-1]}},xData6[MIDWIDTH-2:6]});\n\tangle7 <= yData6[MIDWIDTH-1]?(angle6 - ARCTANG_6):(angle6 + ARCTANG_6);\n\n    xData8 <= yData7[MIDWIDTH-1]?(xData7 - {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]}):(xData7 + {{8{yData7[MIDWIDTH-1]}},yData7[MIDWIDTH-2:7]});\n\tyData8 <= yData7[MIDWIDTH-1]?(yData7 + {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]}):(yData7 - {{8{xData7[MIDWIDTH-1]}},xData7[MIDWIDTH-2:7]});\n\tangle8 <= yData7[MIDWIDTH-1]?(angle7 - ARCTANG_7):(angle7 + ARCTANG_7);\n\n    xData9 <= yData8[MIDWIDTH-1]?(xData8 - {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]}):(xData8 + {{9{yData8[MIDWIDTH-1]}},yData8[MIDWIDTH-2:8]});\n\tyData9 <= yData8[MIDWIDTH-1]?(yData8 + {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]}):(yData8 - {{9{xData8[MIDWIDTH-1]}},xData8[MIDWIDTH-2:8]});\n\tangle9 <= yData8[MIDWIDTH-1]?(angle8 - ARCTANG_8):(angle8 + ARCTANG_8);\n\n    xData10 <= yData9[MIDWIDTH-1]?(xData9 - {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]}):(xData9 + {{10{yData9[MIDWIDTH-1]}},yData9[MIDWIDTH-2:9]});\n\tyData10 <= yData9[MIDWIDTH-1]?(yData9 + {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]}):(yData9 - {{10{xData9[MIDWIDTH-1]}},xData9[MIDWIDTH-2:9]});\n\tangle10 <= yData9[MIDWIDTH-1]?(angle9 - ARCTANG_9):(angle9 + ARCTANG_9);\n\n    xData11 <= yData10[MIDWIDTH-1]?(xData10 - {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]}):(xData10 + {{11{yData10[MIDWIDTH-1]}},yData10[MIDWIDTH-2:10]});\n\tyData11 <= yData10[MIDWIDTH-1]?(yData10 + {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]}):(yData10 - {{11{xData10[MIDWIDTH-1]}},xData10[MIDWIDTH-2:10]});\n\tangle11 <= yData10[MIDWIDTH-1]?(angle10 - ARCTANG_10):(angle10 + ARCTANG_10);\n\n    xData12 <= yData11[MIDWIDTH-1]?(xData11 - {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]}):(xData11 + {{12{yData11[MIDWIDTH-1]}},yData11[MIDWIDTH-2:11]});\n\tyData12 <= yData11[MIDWIDTH-1]?(yData11 + {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]}):(yData11 - {{12{xData11[MIDWIDTH-1]}},xData11[MIDWIDTH-2:11]});\n\tangle12 <= yData11[MIDWIDTH-1]?(angle11 - ARCTANG_11):(angle11 + ARCTANG_11);\n\t\n   \n\t\nend\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_4bit_03085f2a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter_4bit (\n    input clk,\n    input up_down,\n    input load,\n    input en,\n    input [3:0] data_in,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (en) begin\n            if (load) begin\n                out <= data_in;\n            end else begin\n                if (up_down) begin\n                    out <= out + 1;\n                end else begin\n                    out <= out - 1;\n                end\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "modulator_1d48bc64", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule modulator(\n    input adc_clk,\n    input [3:0] mod_type,\n    input [8:0] ssp_clk_divider,\n    input after_hysteresis,\n    output reg ssp_frame,\n    output reg ssp_din,\n    output reg modulating_carrier,\n    output reg pwr_oe1,\n    output reg pwr_oe3,\n    output reg pwr_oe4\n);\n\n// Synchronize up the ssp_frame signal\nalways @(negedge adc_clk) begin\n    if (mod_type == 4'b0100) begin\n        if (ssp_clk_divider[8:5] == 4'b0001)\n            ssp_frame <= 1'b1;\n        if (ssp_clk_divider[8:5] == 4'b0101)\n            ssp_frame <= 1'b0;\n    end\n    else begin\n        if (ssp_clk_divider[7:4] == 4'b0001)\n            ssp_frame <= 1'b1;\n        if (ssp_clk_divider[7:4] == 4'b0101)\n            ssp_frame <= 1'b0;\n    end\nend\n\n// Synchronize up the after-hysteresis signal, to produce DIN.\nalways @(posedge adc_clk) begin\n    ssp_din <= after_hysteresis;\nend\n\n// Modulating carrier frequency is fc/64 (212kHz) to fc/16 (848kHz). Reuse ssp_clk divider for that.\nalways @(*) begin\n    case (mod_type)\n        4'b0000: modulating_carrier <= 1'b0; // no modulation\n        4'b0001: modulating_carrier <= ssp_din ^ ssp_clk_divider[3]; // XOR means BPSK\n        4'b0100: modulating_carrier <= ssp_din & ssp_clk_divider[5]; // switch 212kHz subcarrier on/off\n        4'b0101, 4'b0110: modulating_carrier <= ssp_din & ssp_clk_divider[4]; // switch 424kHz modulation on/off\n        default: modulating_carrier <= 1'b0; // yet unused\n    endcase\nend\n\nalways @*\nbegin\n    pwr_oe1 <= 1'b0; // 33 Ohms Load\n    pwr_oe4 <= modulating_carrier; // 33 Ohms Load\n    pwr_oe3 <= 1'b0; // 10k Load\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "power_supply_24c4cee7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule power_supply(\n    input clk,\n    output reg VPB,\n    output reg VNB\n);\n\nreg [1:0] state;\n\nalways @(posedge clk) begin\n    case(state)\n        2'b00: begin\n            VPB <= 1;\n            VNB <= 0;\n            state <= 2'b01;\n        end\n        2'b01: begin\n            VPB <= 0;\n            VNB <= 1;\n            state <= 2'b10;\n        end\n        2'b10: begin\n            VPB <= 1;\n            VNB <= 0;\n            state <= 2'b11;\n        end\n        2'b11: begin\n            VPB <= 0;\n            VNB <= 1;\n            state <= 2'b00;\n        end\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signal_combiner_12172fdc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule signal_combiner (\n    input [3:0] input_signals,\n    output output_signal\n);\n\nwire[1:0] input_sum;\n\nassign input_sum[0] = input_signals[0] ^ input_signals[1];\nassign input_sum[1] = input_signals[2] ^ input_signals[3];\n\nassign output_signal = input_sum[0] ^ input_sum[1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_module_bb689d68", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_module(a, b, o);\n   input [7:0] a;\n   input [7:0] b;\n   output [7:0] o;\n   \n   assign o = a ^ b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_4ca759e8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    input sel,\n    input in0,\n    input in1,\n    output out\n);\n\n    assign out = sel ? in1 : in0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nios_system_alu_carry_out_299aaf88", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nios_system_alu_carry_out (\n  input [1:0] address,\n  input clk,\n  input in_port,\n  input reset_n,\n  output reg [31:0] readdata\n);\n\n  wire clk_en = 1;\n  wire data_in = in_port;\n  wire read_mux_out = (address == 0) ? data_in : 32'b0;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      readdata <= 0;\n    end else if (clk_en) begin\n      readdata <= {32'b0, read_mux_out};\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flt_fx_24p8_5589b308", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule flt_fx_24p8\n\t(\n\tinput\t[31:0]\tfp_in,         output reg [31:0] int_out      );\nwire    [7:0]   bias_exp;       \nwire    [7:0]   bias_exp2;      \nwire    [39:0]  fixed_out2;     \nwire    [47:0]  bias_mant;      \nreg     [47:0]  int_fixed_out;\n\nreg    [31:0]  fixed_out;\n\nassign bias_mant = {25'h0001, fp_in[22:0]};\nassign bias_exp = fp_in[30:23] - 8'd127;\nassign bias_exp2 = ~bias_exp + 8'h1;\n\nalways @* begin\n\tif (fp_in[30:0] == 31'b0) int_fixed_out = 0;\n  \telse if (bias_exp[7]) int_fixed_out = bias_mant >> bias_exp2;\n  \telse int_fixed_out = bias_mant << bias_exp;\n\n\tfixed_out = int_fixed_out[46:15];\n\tint_out = (fp_in[31]) ? ~fixed_out + 1 : fixed_out;\nend\n\nendmodule\n\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__a222oi_d6bfba0c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__a222oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1,\n    C2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n    input  C2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out ;\n    wire nand1_out ;\n    wire nand2_out ;\n    wire and0_out_Y;\n\n    nand nand0 (nand0_out , A2, A1                         );\n    nand nand1 (nand1_out , B2, B1                         );\n    nand nand2 (nand2_out , C2, C1                         );\n    and  and0  (and0_out_Y, nand0_out, nand1_out, nand2_out);\n    buf  buf0  (Y         , and0_out_Y                     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline__391d4395", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipeline_module (\n    input wire [2:0] vec,\n    input wire clk,\n    output wire [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n\nreg [2:0] reg1;\nreg [2:0] reg2;\nreg [2:0] reg3;\n\nassign outv = reg3;\nassign o2 = reg3[2];\nassign o1 = reg2[1];\nassign o0 = reg1[0];\n\nalways @(posedge clk) begin\n    reg1 <= vec;\nend\n\nalways @(posedge clk) begin\n    reg2 <= reg1;\nend\n\nalways @(posedge clk) begin\n    reg3 <= reg2;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SPI_IF_accel_8ca25056", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule SPI_IF_accel( \n\tinput clk,\n\tinput rst,\n\tinput [6:0] mpu_address,\t\tinput [7:0] mpu_wr_data,\t\tinput mpu_rd_wr_sel,\t\t\t\tinput start,\t\t\t\t\t\toutput busy,\t\t\t\t\toutput SPI_SS_a,\t\t\t\t\t\toutput SPI_CK_a,\t\t\t\t\t\toutput SPI_DO_a,\t\t\t\t\t\tinput SPI_DI_a,\t\t\t\t\t\toutput [7:0] mpu_rd_data\t\t\t\t);\n\t \n\t reg [7:0] mpu_rd_data_buff; \t\treg [7:0] SPIstate;\n\t reg [11:0] counter;\t\treg MPUclk;\t\t\t\treg  do_reg;\t\t\t\treg  ss_reg;\t\t\t\treg  ck_reg;\t\t\t\treg busy_bf;\t\t\t\treg [4:0] i;\t\t\t\treg [4:0] j;\t\t\t\tparameter SPI_HALF_CLK = 50; parameter SPI_CLK = SPI_HALF_CLK*2;\n\nwire halfCLKpassed = (counter == SPI_HALF_CLK-1);\n\nalways@(posedge clk)\nbegin\n\tif(rst)\n\tbegin\n\t\tcounter <= 0;\n\t\tMPUclk <= 0;\n\tend\n\telse\n\tbegin\n\t\tif(start==1) begin\n\t\t\tcounter <= 0;\t\t\n\t\t\tMPUclk <= 1;\t\t\t\n\t\tend\n\t\telse if(halfCLKpassed)begin\t\t\t\n\t\t\tcounter <= 0;\t\t\n\t\t\tMPUclk <= ~MPUclk;\n\t\t\tend\n\t\telse begin\n\t\t\tcounter <= counter + 1;\n\t\tend\n\tend\nend\n\nalways @(posedge clk)\n\tbegin\n\t\tif(rst)\n\t\tbegin\n\t\t\tSPIstate = 0;\n\t\tend\n\t\telse\n\t\tbegin\t\t\n\t\t\tcase(SPIstate)\n\t\t\t\t0:if(start == 1) SPIstate = 1;\t1:SPIstate = 3;\t3:begin\n\t\t\t\t\tif(i==0 && mpu_rd_wr_sel == 1)SPIstate = 4;\t\t\t\tif(i==0 && mpu_rd_wr_sel == 0)SPIstate = 5;\t\t\t\tend\n\t\t\t\t4:if(j==0)SPIstate = 6;\t\t\t\t5:if(j==0)SPIstate = 6;\n\t\t\t\t6:if(halfCLKpassed)SPIstate = 7;\t\t\t\t7:SPIstate = 0;\t\t\tendcase\n\t\tend\n\tend\n \n \nalways @ (posedge clk)\nbegin \n\tif(rst)\n\t\tbegin\n\t\t\tdo_reg = 0;\n\t\t\tck_reg = 1;\n\t\t\tss_reg = 1;\n\t\t\tbusy_bf = 0;\n\t\t\tmpu_rd_data_buff = 0;\n\t\t\ti = 16;\n\t\t\tj = 17;\n\t\tend\n\telse\n\t\tcase(SPIstate)\n\t\t\t0:begin\t\t\t\t\tdo_reg = 0;\n\t\t\t\tss_reg = 1; \n\t\t\t\tbusy_bf = 0;\n\t\t\t   i = 16;\n\t\t\t\tj = 17;\n\t\t\t  end\n\t\t\t1:begin\t\t\t\t\tbusy_bf = 1;\n\t\t\t\t\tss_reg = 0;\n\t\t\t\t\tend\n\t\t\t3:begin\t\t\t\t\tif(halfCLKpassed)\n\t\t\t\tbegin\n\t\t\t\t\tcase (i)\n\t\t\t\t\t\t16:do_reg = mpu_rd_wr_sel;\n\t\t\t\t\t\t14:do_reg = mpu_address[6];\n\t\t\t\t\t\t12:do_reg = mpu_address[5];\n\t\t\t\t\t\t10:do_reg = mpu_address[4];\n\t\t\t\t\t\t8: do_reg = mpu_address[3];\n\t\t\t\t\t\t6: do_reg = mpu_address[2];\n\t\t\t\t\t\t4: do_reg = mpu_address[1];\n\t\t\t\t\t\t2: do_reg = mpu_address[0];\n\t\t\t\t\t\t0: do_reg = 0;\n\t\t\t\t\tendcase\n\t\t\t\t\tif(i!=0) i=i-1;\n\t\t\t\tend\n\t\t\t  end\n\t\t\t4:begin\t\t\t\tif(halfCLKpassed)\n\t\t\t\tbegin\n\t\t\t\t\tcase (j)\n\t\t\t\t\t\t16:mpu_rd_data_buff[7] = SPI_DI_a;\n\t\t\t\t\t\t14:mpu_rd_data_buff[6] = SPI_DI_a;\n\t\t\t\t\t\t12:mpu_rd_data_buff[5] = SPI_DI_a;\n\t\t\t\t\t\t10:mpu_rd_data_buff[4] = SPI_DI_a;\n\t\t\t\t\t\t8:mpu_rd_data_buff[3] = SPI_DI_a;\n\t\t\t\t\t\t6:mpu_rd_data_buff[2] = SPI_DI_a;\n\t\t\t\t\t\t4:mpu_rd_data_buff[1] = SPI_DI_a;\n\t\t\t\t\t\t2:mpu_rd_data_buff[0] = SPI_DI_a;\t\t\t\t\t\t\n\t\t\t\t\tendcase\n\t\t\t\t\tif(j!=0) j=j-1;\n\t\t\t\tend\n\t\t\tend\t\n\n\t\t\t5:begin\t\t\t\tif(halfCLKpassed)\n\t\t\t\tbegin\n\t\t\t\t\tcase (j)\n\t\t\t\t\t\t16:do_reg = mpu_wr_data[7]; \n\t\t\t\t\t\t14:do_reg = mpu_wr_data[6]; \n\t\t\t\t\t\t12:do_reg = mpu_wr_data[5]; \n\t\t\t\t\t\t10:do_reg = mpu_wr_data[4]; \n\t\t\t\t\t\t8:do_reg = mpu_wr_data[3]; \n\t\t\t\t\t\t6:do_reg = mpu_wr_data[2]; \n\t\t\t\t\t\t4:do_reg = mpu_wr_data[1]; \n\t\t\t\t\t\t2:do_reg = mpu_wr_data[0]; \n\t\t\t\t\t\t0:do_reg = 0;\n\t\t\t\t\tendcase\n\t\t\t\t\tif(j!=0) j=j-1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\t\t\t\t  \n\t\t\t6:begin\t\t\t\tck_reg =1;\n\t\t\t\tdo_reg =0;\n\t\t\t\tss_reg = 1;\n\t\t\t  end\n\t\t\t  \n\t\t\t7:begin\t\tend\n\t\t\t\n\t\tendcase\nend\n\n\nassign SPI_DO_a = do_reg;\nassign SPI_CK_a = MPUclk | ss_reg;\nassign SPI_SS_a = ss_reg;\nassign busy = busy_bf | start;\nassign mpu_rd_data = mpu_rd_data_buff;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor_gate_with_enable_b7cf9f50", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nor_gate_with_enable (\n    input in1,\n    input in2,\n    input en,\n    output out\n);\n\nreg out_reg;\n\nalways @(*) begin\n    if (en == 1'b0) begin\n        out_reg = 1'b0;\n    end else begin\n        out_reg = ~(in1 | in2);\n    end\nend\n\nassign out = out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "regfile_1db030a4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule regfile(clk, raddr1, dout1, raddr2, dout2, wr, waddr, din, nrst, ram1, ram2, ram3);\n\tinput \t\t\tclk;\n\tinput \t\t\twr;\n\tinput\t[4:0] \traddr1, raddr2, waddr;\n\tinput\t[31:0] \tdin;\n\tinput nrst;\n\toutput\treg[31:0] \tdout1, dout2;\n\toutput wire[31:0] ram1;\n\toutput wire[31:0] ram2;\n\toutput wire[31:0] ram3;\n\treg [31:0] ram [0:31];\n\tassign ram1 = ram[5'b00001];\n\tassign ram2 = ram[5'b00010];\n\tassign ram3 = ram[5'b00011];\n\t\n\talways @(posedge clk)\n\tbegin\n\t\n\tif (wr == 1'b1)\n\t\tbegin\n\t\t\tram[waddr] = din;\n\t\tend\n\tend\n\talways @(negedge clk)\n\tbegin\n\t\tdout1 <= (raddr1 == 5'b0) ? 32'b0 : ram[raddr1];\n\t\tdout2 <= (raddr2 == 5'b0) ? 32'b0 : ram[raddr2];\n\tend\n\tendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_52c94f04", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input clk,\n    input load,\n    input clear,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (clear) begin\n            data_out <= 8'b0;\n        end else if (load) begin\n            data_out <= data_in;\n        end else begin\n            data_out <= {data_out[6:0], data_out[7]};\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lab2_part7_dc3fd577", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule lab2_part7 (SW, LEDR, HEX1, HEX0);\n  input [5:0] SW;\n  output [0:6] HEX1, HEX0;\n  output [5:0] LEDR;\n\n  reg [3:0] TENS, ONES;\n\n  assign LEDR = SW;\n\n  always begin\n    if (SW[5:0] > 59) begin\n      TENS = 6;\n      ONES = SW[5:0] - 60;\n    end else if (SW[5:0] > 49) begin\n      TENS = 5;\n      ONES = SW[5:0] - 50;\n    end else if (SW[5:0] > 39) begin\n      TENS = 4;\n      ONES = SW[5:0] - 40;\n    end else if (SW[5:0] > 29) begin\n      TENS = 3;\n      ONES = SW[5:0] - 30;\n    end else if (SW[5:0] > 19) begin\n      TENS = 2;\n      ONES = SW[5:0] - 20;\n    end else if (SW[5:0] > 9) begin\n      TENS = 1;\n      ONES = SW[5:0] - 10;\n    end else begin\n      TENS = 0;\n      ONES = SW[5:0];\n    end end b2d_7seg H1 (TENS, HEX1);\n  b2d_7seg H0 (ONES, HEX0);\n\nendmodule\n\nmodule b2d_7seg (X, SSD);\n  input [3:0] X;\n  output [0:6] SSD;\n\n  assign SSD[0] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] &  X[2] & ~X[1] & ~X[0]));\n  assign SSD[1] = ((~X[3] &  X[2] & ~X[1] &  X[0]) | (~X[3] &  X[2] &  X[1] & ~X[0]));\n  assign SSD[2] =  (~X[3] & ~X[2] &  X[1] & ~X[0]);\n  assign SSD[3] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] &  X[2] & ~X[1] & ~X[0]) | (~X[3] &  X[2] & X[1] & X[0]) | (X[3] & ~X[2] & ~X[1] & X[0]));\n  assign SSD[4] = ~((~X[2] & ~X[0]) | (X[1] & ~X[0]));\n  assign SSD[5] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] & ~X[2] &  X[1] & ~X[0]) | (~X[3] & ~X[2] & X[1] & X[0]) | (~X[3] & X[2] & X[1] & X[0]));\n  assign SSD[6] = ((~X[3] & ~X[2] & ~X[1] &  X[0]) | (~X[3] & ~X[2] & ~X[1] & ~X[0]) | (~X[3] &  X[2] & X[1] & X[0]));\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotator_byte_reorder_98052c22", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rotator_byte_reorder(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    input [31:0] in,\n    output [31:0] out);\n\n    // 100-bit left/right rotator\n    reg [99:0] rot_data;\n    always @(posedge clk) begin\n        if (load) rot_data <= data;\n        else if (ena[0]) rot_data <= {rot_data[98:0], rot_data[99]};\n        else if (ena[1]) rot_data <= {rot_data[0], rot_data[99:1]};\n    end\n\n    // Byte reordering module\n    reg [7:0] shift_reg [3:0];\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg[0] <= in[7:0];\n            shift_reg[1] <= in[15:8];\n            shift_reg[2] <= in[23:16];\n            shift_reg[3] <= in[31:24];\n        end\n        else begin\n            shift_reg[0] <= shift_reg[1];\n            shift_reg[1] <= shift_reg[2];\n            shift_reg[2] <= shift_reg[3];\n            shift_reg[3] <= in[31:24];\n        end\n    end\n    assign out = {shift_reg[3], shift_reg[2], shift_reg[1], shift_reg[0]} | rot_data[31:0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "synchronizer_ff_9945c0f1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule synchronizer_ff(\n  input [3:0] D,\n  input CLK,\n  input AR,\n  output reg [3:0] Q\n);\n\n  always @(posedge CLK) begin\n    if (AR) begin\n      Q <= 4'b0000;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "altera_avalon_st_packets_to_bytes_2a1ab67e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule altera_avalon_st_packets_to_bytes\n#(    parameter CHANNEL_WIDTH = 8,\n      parameter ENCODING      = 0) \n(\n      input              clk,\n      input              reset_n,\n      output reg         in_ready,\n      input              in_valid,\n      input      [7: 0]  in_data,\n      input      [CHANNEL_WIDTH-1: 0]  in_channel,\n      input              in_startofpacket,\n      input              in_endofpacket,\n\n      input              out_ready,\n      output reg         out_valid,\n      output reg [7: 0]  out_data\n);\n\n   localparam CHN_COUNT = CHANNEL_WIDTH/7;\n   reg  sent_esc, sent_sop, sent_eop;\n   reg  sent_channel_char, channel_escaped, sent_channel;\n   reg  [CHANNEL_WIDTH:0] stored_channel;\n   reg  [4:0] channel_count;\n   reg    [((CHANNEL_WIDTH/7+1)*7)-1:0] stored_varchannel;\n   reg     channel_needs_esc;\n\n\n\n   wire need_sop, need_eop, need_esc, need_channel;\n\n   assign need_esc = (in_data === 8'h7a |\n                      in_data === 8'h7b |\n                      in_data === 8'h7c |\n                      in_data === 8'h7d );\n   assign need_eop = (in_endofpacket);\n   assign need_sop = (in_startofpacket);\n\n\ngenerate\nif( CHANNEL_WIDTH > 0) begin\n   wire   channel_changed;\n   assign channel_changed = (in_channel != stored_channel);\n   assign need_channel = (need_sop | channel_changed);\n\n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n         sent_esc <= 0;\n         sent_sop <= 0;\n         sent_eop <= 0;\n         sent_channel <= 0;\n         channel_escaped <= 0;\n         sent_channel_char <= 0;\n         out_data <= 0;\n         out_valid <= 0;\n         channel_count <= 0;\n         channel_needs_esc <= 0;\n      end else begin\n\n         if (out_ready )\n           out_valid <= 0;\n\n         if ((out_ready | ~out_valid) && in_valid  )\n           out_valid <= 1;\n\n         if ((out_ready | ~out_valid) && in_valid) begin\n            if (need_channel & ~sent_channel) begin\n                 if (~sent_channel_char) begin\n                    sent_channel_char <= 1;\n                    out_data <= 8'h7c;\n                    channel_count <= CHN_COUNT[4:0];\n                    stored_varchannel <= in_channel;\n                    if (ENCODING == 0) begin\n                    channel_needs_esc <= (in_channel == 8'h7a |\n                                          in_channel == 8'h7b |\n                                          in_channel == 8'h7c |\n                                          in_channel == 8'h7d );\n                    end\n                 end else if (channel_needs_esc & ~channel_escaped) begin\n                    out_data <= 8'h7d;\n                    channel_escaped <= 1;\n                 end else if (~sent_channel) begin\n                       if (ENCODING) begin\n                            if (channel_count > 0) begin\n                                   if (channel_needs_esc) out_data <= {1'b1, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]} ^ 8'h20;\n                                   else                   out_data <= {1'b1, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]};\n                                   stored_varchannel <= stored_varchannel<<7;\n\n                                   channel_count <= channel_count - 1'b1;\n                                   if (channel_count ==1 & CHANNEL_WIDTH > 7) begin\n                                      channel_needs_esc <=\n                                         ((stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14]  == 7'h7a)|\n                                         (stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14] == 7'h7b) |\n                                         (stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14] == 7'h7c) |\n                                         (stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-8:((CHANNEL_WIDTH/7+1)*7)-14] == 7'h7d) );\n                                   end\n                              end else begin\n                               if (channel_needs_esc) begin \n                                      channel_needs_esc <= 0; \n                                      out_data <= {1'b0, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]} ^ 8'h20;\n                                   end else   out_data <= {1'b0, stored_varchannel[((CHANNEL_WIDTH/7+1)*7)-1:((CHANNEL_WIDTH/7+1)*7)-7]};\n                                   sent_channel <= 1;\n                              end\n                       end else begin\n                            if (channel_needs_esc) begin \n                               channel_needs_esc <= 0; \n                               out_data <= in_channel ^ 8'h20; \n                            end else out_data <= in_channel;\n                            sent_channel <= 1;\n                       end\n                 end\n            end else if (need_sop & ~sent_sop) begin\n                 sent_sop <= 1;\n                 out_data <= 8'h7a;\n\n            end else if (need_eop & ~sent_eop) begin\n                 sent_eop <= 1;\n                 out_data <= 8'h7b;\n\n            end else if (need_esc & ~sent_esc) begin\n                 sent_esc <= 1;\n                 out_data <= 8'h7d;\n            end else begin\n                 if (sent_esc)    out_data <= in_data ^ 8'h20;\n                 else             out_data <= in_data;\n                 sent_esc <= 0;\n                 sent_sop <= 0;\n                 sent_eop <= 0;\n                 sent_channel <= 0;\n                 channel_escaped <= 0;\n                 sent_channel_char <= 0;\n            end\n         end\n      end\n   end\n\n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n         stored_channel <= {CHANNEL_WIDTH{1'b1}};\n      end else begin\n         if (sent_channel) stored_channel <= in_channel;\n      end\n   end\n    always @* begin\n\n      in_ready = (out_ready | !out_valid) & in_valid & (~need_esc | sent_esc)\n                 & (~need_sop | sent_sop)\n                 & (~need_eop | sent_eop)\n                 & (~need_channel | sent_channel);\n   end\n\nend else begin\n\nassign need_channel = (need_sop);\n\n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n         sent_esc <= 0;\n         sent_sop <= 0;\n         sent_eop <= 0;\n         out_data <= 0;\n         out_valid <= 0;\n         sent_channel <= 0;\n         sent_channel_char <= 0;\n      end else begin\n\n         if (out_ready )\n           out_valid <= 0;\n\n         if ((out_ready | ~out_valid) && in_valid  )\n           out_valid <= 1;\n\n         if ((out_ready | ~out_valid) && in_valid) begin\n            if (need_channel & ~sent_channel) begin\n                 if (~sent_channel_char) begin           sent_channel_char <= 1;\n                    out_data <= 8'h7c;\n                 end else if (~sent_channel) begin\n                    out_data <= 'h0;\n                    sent_channel <= 1;\n                 end\n            end else if (need_sop & ~sent_sop) begin\n                 sent_sop <= 1;\n                 out_data <= 8'h7a;\n            end else if (need_eop & ~sent_eop) begin\n                 sent_eop <= 1;\n                 out_data <= 8'h7b;\n            end else if (need_esc & ~sent_esc) begin\n                 sent_esc <= 1;\n                 out_data <= 8'h7d;\n            end else begin\n                 if (sent_esc)    out_data <= in_data ^ 8'h20;\n                 else             out_data <= in_data;\n                 sent_esc <= 0;\n                 sent_sop <= 0;\n                 sent_eop <= 0;\n            end\n         end\n     end\n   end\n   \n always @* begin\n      in_ready = (out_ready | !out_valid) & in_valid & (~need_esc | sent_esc)\n                 & (~need_sop | sent_sop)\n                 & (~need_eop | sent_eop)\n                 & (~need_channel | sent_channel);\n   end\nend\nendgenerate\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "edge_detector_caa862ab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule edge_detector(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    reg [7:0] prev_in;\n    always @(posedge clk) begin\n        if (in > prev_in) begin\n            out <= in;\n        end else if (in < prev_in) begin\n            out <= in;\n        end\n        prev_in <= in;\n    end\nendmodule\n\nmodule mux(\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    input [7:0] in4,\n    input sel_b1,\n    input sel_b2,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sel_b1 == 0 && sel_b2 == 0) begin\n            out = in1;\n        end else if (sel_b1 == 0 && sel_b2 == 1) begin\n            out = in2;\n        end else if (sel_b1 == 1 && sel_b2 == 0) begin\n            out = in3;\n        end else if (sel_b1 == 1 && sel_b2 == 1) begin\n            out = in4;\n        end\n    end\nendmodule\n\nmodule top_module(\n    input clk,\n    input [7:0] in,\n    input [7:0] input1,\n    input [7:0] input2,\n    input [7:0] input3,\n    input [7:0] input4,\n    input sel_b1,\n    input sel_b2,\n    output [7:0] out\n);\n    wire [7:0] edge_detect_out;\n    edge_detector edge_detect(.clk(clk), .in(in), .out(edge_detect_out));\n    \n    wire [7:0] mux_out;\n    mux mux_inst(.in1(input1), .in2(input2), .in3(input3), .in4(input4), .sel_b1(sel_b1), .sel_b2(sel_b2), .out(mux_out));\n    \n    assign out = edge_detect_out & mux_out;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "custom__426e67f7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule custom_module (\n    output Y,\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    input C1\n);\n\n    wire and0_out  ;\n    wire and1_out  ;\n    wire nor0_out_Y;\n\n    assign and0_out = B1 & B2;\n    assign and1_out = A1 & A2;\n    assign nor0_out_Y = ~(and0_out | and1_out | C1);\n    assign Y = nor0_out_Y;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nkmd_dai_rx_f427f2de", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nkmd_dai_rx(\n    input wire clk,\n    input wire rst,\n\n    input wire [23:0] rx_data_i,\n    input wire rx_ack_i,\n\n    input wire [31:0] data_i,\n    output wire [31:0] data_o,\n    input wire [31:0] addr_i,\n    input wire we_i);\n\nreg [5:0] nextw_ff;\nalways @(posedge clk) begin\n    if (rst)\n        nextw_ff <= 0;\n    else if (rx_ack_i)\n        nextw_ff <= nextw_ff + 1;\nend\n\nreg [23:0] ringbuf [63:0];\nalways @(posedge clk) begin\n    if (rx_ack_i)\n        ringbuf[nextw_ff] <= rx_data_i;\nend\n\nreg [5:0] unread_ff;\nreg [5:0] shift_ff;\nwire should_shift;\nassign should_shift = we_i && addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h00;\nalways @(posedge clk) begin\n    if (rst) begin\n        unread_ff <= 0;\n        shift_ff <= 0;\n    end else if (should_shift && !rx_ack_i) begin\n        unread_ff <= unread_ff - 1;\n        shift_ff <= shift_ff + 1;\n    end else if (!should_shift && rx_ack_i) begin\n        unread_ff <= unread_ff + 1;\n    end else if (should_shift && rx_ack_i) begin\n        shift_ff <= shift_ff + 1;\n    end\nend\n\nreg [31:0] data_o_ff;\nassign data_o = data_o_ff;\n\nwire [5:0] offset_i;\nassign offset_i = addr_i[5:0];\n\nalways @(posedge clk) begin\n    if (addr_i[15:12] == 4'hf)\n        data_o_ff <= ringbuf[shift_ff + offset_i];\n    else if (addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h00)\n        data_o_ff <= unread_ff;\n    else\n        data_o_ff <= 0;\nend\n\nendmodule\n\nmodule nkmd_dai_tx(\n    input wire clk,\n    input wire rst,\n\n    output wire [23:0] tx_data_o,\n    input wire tx_pop_i,\n    output wire tx_ack_o,\n\n    input wire [31:0] data_i,\n    output wire [31:0] data_o,\n    input wire [31:0] addr_i,\n    input wire we_i);\n\nreg [5:0] queued_ff;\nreg [5:0] lastr_ff;\nreg [5:0] nextw_ff;\n\nreg [23:0] ringbuf [63:0];\nassign tx_data_o = ringbuf[lastr_ff];\n\nwire should_queue;\nassign should_queue = we_i && addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h01;\nalways @(posedge clk) begin\n    if (rst) begin\n        queued_ff <= 0;\n        lastr_ff <= 6'h3f;\n        nextw_ff <= 0;\n    end else if (should_queue && !tx_pop_i) begin\n        ringbuf[nextw_ff] <= data_i;\n        queued_ff <= queued_ff + 1;\n        nextw_ff <= nextw_ff + 1;\n    end else if (!should_queue && tx_pop_i) begin\n        if (queued_ff > 0) begin\n            queued_ff <= queued_ff - 1;\n            lastr_ff <= lastr_ff + 1;\n        end\n    end else if (should_queue && tx_pop_i) begin\n        ringbuf[nextw_ff] <= data_i;\n        if (queued_ff > 0) begin\n            lastr_ff <= lastr_ff + 1;\n        end else begin\n            queued_ff <= queued_ff + 1;\n        end\n        nextw_ff <= nextw_ff + 1;\n    end\nend\n\nreg tx_ack_ff;\nalways @(posedge clk)\n    tx_ack_ff <= tx_pop_i;\nassign tx_ack_o = tx_ack_ff;\n\nreg [31:0] data_o_ff;\nassign data_o = data_o_ff;\n\nwire [5:0] offset_i;\nassign offset_i = addr_i[5:0];\n\nalways @(posedge clk) begin\n    if (addr_i[15:12] == 4'he)\n        data_o_ff <= ringbuf[nextw_ff - 1 - offset_i];\n    else if (addr_i[15:12] == 4'hd && addr_i[7:0] == 8'h01)\n        data_o_ff <= queued_ff;\n    else\n        data_o_ff <= 0;\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RFID #_ca15f8fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RFID #(\n  parameter n = 8, // number of bits in the data signal\n  parameter k = 4 // number of bits in the transmit signal\n) (\n  input [n-1:0] data_in,\n  input clk,\n  input rst,\n  input start,\n  output reg [k-1:0] tx\n);\n\n  reg [n-1:0] data_reg;\n  reg [3:0] count;\n  reg start_reg;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n      tx <= 0;\n      start_reg <= 0;\n    end\n    else begin\n      if (start) begin\n        start_reg <= 1;\n        count <= 0;\n        data_reg <= data_in;\n        tx <= 1;\n      end\n      else if (start_reg) begin\n        if (count < k-1) begin\n          count <= count + 1;\n          tx <= 0;\n        end\n        else begin\n          count <= 0;\n          tx <= 1;\n          start_reg <= 0;\n        end\n      end\n      else begin\n        tx <= 0;\n      end\n    end\n  end\n  \nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "complex_5ac4e3ce", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule complex(\n\tinput [7:0] x,\n\tinput [7:0] y,\n\toutput out\n);\n\nwire [9:0] and_outputs;\nwire [4:0] or_outputs;\n\ngenvar i;\ngenerate\n\tfor(i = 0; i < 8; i = i + 1)\n\tbegin: and_1st_row\n\t\tassign and_outputs[i] = x[i] & y[i];\n\tend\n\t\n\tfor(i = 0; i < 4; i = i + 1)\n\tbegin: or_2nd_row\n\t\tassign or_outputs[i] = and_outputs[2 * i] | and_outputs[2 * i + 1];\n\tend\n\n\tassign and_outputs[8] = or_outputs[0] & or_outputs[1];\n\tassign and_outputs[9] = or_outputs[2] & or_outputs[3];\n\t\n\tassign or_outputs[4] = and_outputs[8] | and_outputs[9];\n\nendgenerate\n\nassign out = or_outputs[4];\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "BIOS_ROM_blk_mem_gen_prim_width_b9d92ed9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule BIOS_ROM_blk_mem_gen_prim_width\n  (douta,\n   ena,\n   clka,\n   addra,\n   dina,\n   wea);\n\n  output [7:0] douta;\n  input ena;\n  input clka;\n  input [11:0] addra;\n  input [7:0] dina;\n  input [0:0] wea;\n\n  reg [7:0] mem [0:4095];\n  reg [7:0] douta_reg;\n  wire [11:0] addra_reg;\n  wire [7:0] dina_reg;\n  wire [0:0] wea_reg;\n\n  assign addra_reg = addra;\n  assign dina_reg = dina;\n  assign wea_reg = wea;\n\n  always @(posedge clka) begin\n    if (ena) begin\n      if (wea_reg) begin\n        mem[addra_reg] <= dina_reg;\n      end\n      douta_reg <= mem[addra_reg];\n    end\n  end\n\n  assign douta = douta_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "freq_syn_caba0f97", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule freq_syn (\n  input clk_ref,\n  input [7:0] ctrl,\n  output reg clk_syn\n);\n\nparameter n = 8; // number of bits in the digital control signal\nparameter f_ref = 10_000_000; // frequency of the reference clock signal (in Hz)\nparameter f_min = 1_000_000; // minimum output frequency of the synthesizer (in Hz)\nparameter f_max = 100_000_000; // maximum output frequency of the synthesizer (in Hz)\n\nreg [7:0] ctrl_reg; // register for storing the digital control signal\nreg [31:0] phase_accum; // register for storing the phase accumulator value\nreg [31:0] phase_inc; // register for storing the phase increment value\nreg [31:0] phase_err; // register for storing the phase error value\nreg [31:0] phase_err_int; // register for storing the integrated phase error value\nreg [31:0] vco_ctrl; // register for storing the VCO control voltage value\nreg [31:0] vco_freq; // register for storing the VCO frequency value\nreg [32:0] phase_syn; // register for storing the synthesized phase value\n\nwire [32:0] phase_ref; // wire for storing the reference phase value\nwire [32:0] phase_diff; // wire for storing the phase difference value\nwire [32:0] phase_err_filt; // wire for storing the filtered phase error value\nwire [32:0] phase_err_integ; // wire for storing the integrated phase error value\nwire [32:0] vco_ctrl_filt; // wire for storing the filtered VCO control voltage value\nwire [32:0] vco_freq_div; // wire for storing the divided VCO frequency value\n\n// generate the reference phase value\nassign phase_ref = (f_ref * 33'h1_0000_0000) / (2 * f_max);\n\n// generate the phase increment value\nalways @(*) begin\n  phase_inc = (ctrl_reg * (33'h1_0000_0000 - phase_ref)) / (2**n);\nend\n\n// generate the synthesized phase value\nalways @(posedge clk_ref) begin\n  phase_accum <= phase_accum + phase_inc;\n  phase_syn <= phase_accum + phase_err_int;\nend\n\n// generate the phase difference value\nassign phase_diff = phase_ref - phase_syn;\n\n\n// generate the integrated phase error value\nalways @(posedge clk_ref) begin\n  if (phase_err_int >= 0) begin\n    phase_err_int <= phase_err_int + phase_err_filt;\n  end else begin\n    phase_err_int <= phase_err_int - phase_err_filt;\n  end\nend\n\n\n// generate the divided VCO frequency value\nassign vco_freq_div = vco_freq / (2**16);\n\n// generate the synthesized clock signal\nalways @(posedge clk_ref) begin\n  vco_freq <= vco_ctrl_filt;\n  clk_syn <= ~clk_syn;\nend\n\n// register the digital control signal\nalways @(posedge clk_ref) begin\n  ctrl_reg <= ctrl;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FIFO_image_filter_dmask_data_stream_0_V_shiftReg_47eaf25a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FIFO_image_filter_dmask_data_stream_0_V_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 8;\nparameter ADDR_WIDTH = 1;\nparameter DEPTH = 2;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\nbegin\n    if (ce)\n    begin\n        for (i=0;i<DEPTH-1;i=i+1)\n            SRL_SIG[i+1] <= SRL_SIG[i];\n        SRL_SIG[0] <= data;\n    end\nend\n\nassign q = SRL_SIG[a];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vending_machine_fsm_5098e74b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vending_machine_fsm(\n  input clk,\n  input reset,\n  input coin_input,\n  input button_input,\n  output reg display_output,\n  output reg product_output\n);\n\n  parameter IDLE = 2'b00;\n  parameter WAITING_FOR_COINS = 2'b01;\n  parameter DISPENSING = 2'b10;\n  \n  reg [1:0] state, next_state;\n  reg [3:0] price = 4'b0010;\n  reg [3:0] coins_inserted;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      coins_inserted <= 0;\n      display_output <= price;\n      product_output <= 0;\n    end else begin\n      state <= next_state;\n      case (state)\n        IDLE: begin\n          if (coin_input) begin\n            coins_inserted <= coins_inserted + 1;\n            next_state <= WAITING_FOR_COINS;\n          end else begin\n            next_state <= IDLE;\n          end\n        end\n        WAITING_FOR_COINS: begin\n          if (coin_input) begin\n            coins_inserted <= coins_inserted + 1;\n            next_state <= WAITING_FOR_COINS;\n          end else if (button_input && coins_inserted >= price) begin\n            coins_inserted <= coins_inserted - price;\n            next_state <= DISPENSING;\n          end else begin\n            next_state <= WAITING_FOR_COINS;\n          end\n        end\n        DISPENSING: begin\n          product_output <= 1;\n          next_state <= IDLE;\n        end\n      endcase\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory #_6cf31052", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule memory #(\n  parameter bits = 32,\n  parameter words = 1024\n)(\n  input clk,\n  input [9:0] addr,\n  input [bits-1:0] data_in,\n  output reg [bits-1:0] mem\n);\n\n  always @(posedge clk) begin\n    if (addr < words) begin\n      mem <= data_in;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_gen_00987189", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clk_gen (clk,reset,clk1,clk2,clk4,fetch,alu_clk);\ninput clk,reset;\noutput clk1,clk2,clk4,fetch,alu_clk;\nwire clk,reset;\nreg clk2,clk4,fetch,alu_clk;\nreg[7:0] state;\nparameter    S1 = 8'b00000001,\n             S2 = 8'b00000010,\n             S3 = 8'b00000100,\n             S4 = 8'b00001000,\n             S5 = 8'b00010000,\n             S6 = 8'b00100000,\n             S7 = 8'b01000000,\n             S8 = 8'b10000000,\n           idle = 8'b00000000;\n                 \nassign clk1 = ~clk;\n\nalways @(negedge clk)\n   if(reset)\n           begin\n                clk2 <= 0;\n                clk4 <= 1;\n                fetch  <= 0;\n                alu_clk <= 0;\n                state <= idle;\n           end\n   else\n           begin \n              case(state)\n                 S1:\n                      begin\n                            clk2 <= ~clk2;\n                         alu_clk <= ~alu_clk;                \n                           state <= S2;\n                      end\n                 S2:\n                      begin\n                          clk2 <= ~clk2;\n                          clk4 <= ~clk4;\n                       alu_clk <= ~alu_clk;\n                         state <= S3;\n                      end\n                 S3:\n                      begin   \n                          clk2 <= ~clk2;\n                         state <= S4;\n                      end\n                 S4:\n                      begin\n                          clk2  <= ~clk2;\n                          clk4  <= ~clk4;\n                          fetch <= ~fetch;\n                          state <= S5;\n                      end\n                 S5:\n                       begin\n                          clk2  <= ~clk2;\n                          state <= S6;\n                       end\n                 S6:\n                       begin\n                           clk2  <= ~clk2;\n                            clk4 <= ~clk4;\n                           state <= S7;\n                        end\n                 S7:\n                        begin\n                             clk2  <= ~clk2;\n                             state <=  S8;\n                        end\n                 S8:\n                        begin\n                             clk2 <= ~clk2;\n                            clk4  <= ~clk4;\n                            fetch <= ~fetch;\n                            state <= S1;\n                        end\n                idle:       state <= S1;   \n                default:    state <= idle;               \n            endcase\n     end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__or2b_03bbf6ca", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__or2b (\n    X  ,\n    A  ,\n    B_N\n);\n\n    output X  ;\n    input  A  ;\n    input  B_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out ;\n    wire or0_out_X;\n\n    not not0 (not0_out , B_N            );\n    or  or0  (or0_out_X, not0_out, A    );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__xnor3_a188499b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__xnor3 (\n    X,\n    A,\n    B,\n    C\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xnor0_out_X;\n\n    xnor xnor0 (xnor0_out_X, A, B, C        );\n    buf  buf0  (X          , xnor0_out_X    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor_gate_e3a7cf52", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nor_gate (\n    input a, b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule\n\nmodule mux_2to1 (\n    input a, b, sel,\n    output out\n);\n    wire nor_a, nor_b, nor_sel;\n\n    nor_gate nor1 (.a(a), .b(sel), .out(nor_a));\n    nor_gate nor2 (.a(b), .b(~sel), .out(nor_b));\n    nor_gate nor3 (.a(nor_a), .b(nor_b), .out(out));\nendmodule\n\nmodule subtractor (\n    input [1:0] in,\n    output [1:0] diff\n);\n    wire [1:0] sub_const = 2'b01;\n\n    assign diff = in - sub_const;\nendmodule\n\nmodule top_module (\n    input a, b,\n    input sel,\n    output [1:0] diff\n);\n    wire mux_out;\n\n    mux_2to1 mux (.a(a), .b(b), .sel(sel), .out(mux_out));\n    subtractor sub (.in({1'b0, mux_out}), .diff(diff));\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ram16b_e5083dfe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule ram16b(\n\tinput\t[15:0]\twdata,\n\tinput\t\twen,\n\tinput\t[4:0]\twaddr,\n\tinput\t\twclk,\n\toutput\t[15:0]\trdata,\n\tinput\t[4:0]\traddr,\n\tinput\t\trclk\n);\n`ifdef synthesis\n\tram16b_ice40 ram(\n\t\t.wdata(wdata),\n\t\t.wen(wen),\n\t\t.waddr(waddr),\n\t\t.wclk(wclk),\n\t\t.rdata(rdata),\n\t\t.raddr(raddr),\n\t\t.rclk(rclk)\n\t);\n`endif\n`ifndef synthesis\n\tram16b_sim ram(\n\t\t.wdata(wdata),\n\t\t.wen(wen),\n\t\t.waddr(waddr),\n\t\t.wclk(wclk),\n\t\t.rdata(rdata),\n\t\t.raddr(raddr),\n\t\t.rclk(rclk)\n\t);\n`endif\nendmodule\n\n`ifdef synthesis\nmodule ram16b_ice40 (\n\tinput\t[15:0]\twdata,\n\tinput\t\twen,\n\tinput\t[4:0]\twaddr,\n\tinput\t\twclk,\n\toutput\t[15:0]\trdata,\n\tinput\t[4:0]\traddr,\n\tinput\t\trclk\n);\n\tSB_RAM40_4K ram(\n\t\t.WDATA(wdata),\n\t\t.MASK({16{wen}}),\n\t\t.WADDR({3'b000, waddr}),\n\t\t.WE(wen),\n\t\t.WCLKE(1'b1),\n\t\t.WCLK(wclk),\n\n\t\t.RDATA(rdata),\n\t\t.RADDR({3'b000, raddr}),\n\t\t.RE(1'b1),\n\t\t.RCLKE(1'b1),\n\t\t.RCLK(rclk)\n\t);\nendmodule\n`endif\n\n`ifndef synthesis\nmodule ram16b_sim (\n\tinput\t[15:0]\twdata,\n\tinput\t\twen,\n\tinput\t[4:0]\twaddr,\n\tinput\t\twclk,\n\toutput\t[15:0]\trdata,\n\tinput\t[4:0]\traddr,\n\tinput\t\trclk\n);\n\treg [15:0] memory[0:31];\n\treg [4:0] raddr_r;\n\n\talways @(posedge wclk) begin\n\t\tif(wen) begin\n\t\t\tmemory[waddr] <= wdata;\n\t\tend\n\tend\n\n\talways @(posedge rclk) begin\n\t\traddr_r <= raddr;\n\tend\n\n\tassign rdata = memory[raddr_r];\nendmodule\n`endif\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_afb1edca", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if(a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end\n        else if(a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end\n        else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ng_INP_159285a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ng_INP(\n\tinput  \t\t\t\t\t\tCLK2,\t\t\t\tinput  \t\t\t\t\t\tNSA,\t\t\t\tinput  \t\t[ 4:0]\t\tKeypad,\t\t\tinput\t\t\t\t\t\t\tKeyready,\t\toutput  \t\t[15:0]\t\tINP_BUS,\t\t\toutput  \t\t\t\t\t\tKeyStrobe\t\t);\n\nassign INP_BUS   = {2'b00, !NSA, 8'h00, Keypad};\nreg [2:0] DRedge;  \nalways @(posedge CLK2) DRedge <= {DRedge[1:0], Keyready};\nwire DR_risingedge  = (DRedge[2:1] == 2'b01);      assign KeyStrobe = DR_risingedge;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "controller_bf0b1626", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule controller (\n  input  wire        clock,\n  input  wire        reset,\n  input  wire        run,\n  input  wire        wrSize,\n  input  wire [31:0] config_data,\n  input  wire        validIn,\n  input  wire [31:0] dataIn,\n  input  wire        busy,\n  input  wire        arm,\n  output reg         send,\n  output reg  [31:0] memoryWrData,\n  output reg         memoryRead,\n  output reg         memoryWrite,\n  output reg         memoryLastWrite\n);\n\nreg [15:0] fwd; reg [15:0] bwd;\n\nreg next_send;\nreg next_memoryRead;\nreg next_memoryWrite;\nreg next_memoryLastWrite;\n\nreg [17:0] counter, next_counter; \nwire [17:0] counter_inc = counter+1'b1;\n\nalways @(posedge clock) \nmemoryWrData <= dataIn;\n\nlocalparam [2:0]\n  IDLE =     3'h0,\n  SAMPLE =   3'h1,\n  DELAY =    3'h2,\n  READ =     3'h3,\n  READWAIT = 3'h4;\n\nreg [2:0] state, next_state; \n\ninitial state = IDLE;\nalways @(posedge clock, posedge reset) \nif (reset) begin\n  state           <= IDLE;\n  memoryWrite     <= 1'b0;\n  memoryLastWrite <= 1'b0;\n  memoryRead      <= 1'b0;\nend else begin\n  state           <= next_state;\n  memoryWrite     <= next_memoryWrite;\n  memoryLastWrite <= next_memoryLastWrite;\n  memoryRead      <= next_memoryRead;\nend\n\nalways @(posedge clock)\nbegin\n  counter <= next_counter;\n  send    <= next_send;\nend\n\nalways @*\nbegin\n  next_state = state;\n  next_counter = counter;\n  next_memoryWrite = 1'b0;\n  next_memoryLastWrite = 1'b0;\n  next_memoryRead = 1'b0;\n  next_send = 1'b0;\n\n  case(state)\n    IDLE :\n      begin\n        next_counter = 0;\n        next_memoryWrite = 1;\n\tif (run) next_state = DELAY;\n\telse if (arm) next_state = SAMPLE;\n      end\n\n    SAMPLE : \n      begin\n        next_counter = 0;\n        next_memoryWrite = validIn;\n        if (run) next_state = DELAY;\n      end\n\n    DELAY : \n      begin\n\tif (validIn)\n\t  begin\n\t    next_memoryWrite = 1'b1;\n            next_counter = counter_inc;\n            if (counter == {fwd,2'b11}) \tbegin\t\t\t\tnext_memoryLastWrite = 1'b1;\tnext_counter = 0;\n\t\tnext_state = READ;\n\t      end\n\t  end\n      end\n\n    READ : \n      begin\n        next_memoryRead = 1'b1;\n        next_send = 1'b1;\n        if (counter == {bwd,2'b11}) \n\t  begin\n            next_counter = 0;\n            next_state = IDLE;\n          end\n        else \n\t  begin\n            next_counter = counter_inc;\n            next_state = READWAIT;\n          end\n      end\n\n    READWAIT : \n      begin\n        if (!busy && !send) next_state = READ;\n      end\n  endcase\nend\n\n\nalways @(posedge clock) \nif (wrSize) {fwd, bwd} <= config_data[31:0];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor3__d2f0535a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nor3_module (\n    input A,\n    input B,\n    input C_N,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign Y = ~(A | B | C_N);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_44a386a2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_reg (\n    input [3:0] data_in,\n    input load,\n    input clk,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if(load) begin\n        q[3] <= data_in;\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\n    else begin\n        q[3] <= q[2];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= data_in;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "glitch_filter_8e951759", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule glitch_filter (\n  input in,\n  output out,\n  input clk\n);\n\n  reg delay_line;\n\n  always @(posedge clk) begin\n    delay_line <= in;\n  end\n\n  assign out = (in == delay_line) ? in : delay_line;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__198a9284", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [1:0] in,    // Input for the 2-to-4 decoder\n    input [3:0] a,    // Input A for the adder-subtractor\n    input [3:0] b,    // Input B for the adder-subtractor\n    input sub,         // Subtraction flag for the adder-subtractor\n    output [3:0] q,    // Output from the functional module\n    output overflow   // Overflow output from the adder-subtractor\n);\n\n    // 2-to-4 decoder module\n    wire [3:0] dec_out;\n    decoder_2to4 dec(\n        .in(in),\n        .out(dec_out)\n    );\n\n    // Adder-subtractor module\n    wire [3:0] addsub_out;\n    wire addsub_overflow;\n    adder_subtractor addsub(\n        .a(a),\n        .b(b),\n        .sub(sub),\n        .q(addsub_out),\n        .overflow(addsub_overflow)\n    );\n\n    // Functional module\n    assign q = (dec_out[0] == 1'b0) ? addsub_out : 4'b0;\n    assign overflow = (dec_out[0] == 1'b0) ? addsub_overflow : (dec_out[1] || dec_out[2] || dec_out[3]);\n\nendmodule\nmodule decoder_2to4 (\n    input [1:0] in,    // Input for the 2-to-4 decoder\n    output [3:0] out   // Output from the 2-to-4 decoder\n);\n\n    assign out[0] = ~in[0] & ~in[1];\n    assign out[1] = ~in[0] &  in[1];\n    assign out[2] =  in[0] & ~in[1];\n    assign out[3] =  in[0] &  in[1];\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] a,    // Input A for the adder-subtractor\n    input [3:0] b,    // Input B for the adder-subtractor\n    input sub,         // Subtraction flag for the adder-subtractor\n    output [3:0] q,    // Output from the adder-subtractor\n    output overflow   // Overflow output from the adder-subtractor\n);\n\n    // Intermediate sum\n    wire [4:0] sum = (sub) ? (a - b) : (a + b);\n    \n    // Assign q and overflow\n    assign q = sum[3:0];\n    assign overflow = sum[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "count_ones_9a001e64", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule count_ones(\n  input a,\n  input b,\n  input c,\n  output reg [1:0] count\n);\n\n  always @(*) begin\n    case ({a, b, c})\n      3'b000: count = 2'b00;\n      3'b001: count = 2'b01;\n      3'b010: count = 2'b01;\n      3'b011: count = 2'b10;\n      3'b100: count = 2'b01;\n      3'b101: count = 2'b10;\n      3'b110: count = 2'b10;\n      3'b111: count = 2'b11;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_0499c0f6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output reg [7:0] Y\n);\n\n    always @* begin\n        case ({A,B,C})\n            3'b000: Y = 8'b00000001;\n            3'b001: Y = 8'b00000010;\n            3'b010: Y = 8'b00000100;\n            3'b011: Y = 8'b00001000;\n            3'b100: Y = 8'b00010000;\n            3'b101: Y = 8'b00100000;\n            3'b110: Y = 8'b01000000;\n            3'b111: Y = 8'b10000000;\n            default: Y = 8'b00000000;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_4295272d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter(\n    output reg [3:0] out,\n    input clk,\n    input reset\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'd0;\n        end else begin\n            out <= out + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_a4ee7368", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule decoder (\n    input sel1,\n    input sel0,\n    output [15:0] out\n);\n    \n    assign out[0]  = ~sel1 & ~sel0;\n    assign out[1]  = ~sel1 & sel0;\n    assign out[2]  = sel1 & ~sel0;\n    assign out[3]  = sel1 & sel0;\n    assign out[4]  = ~sel1 & ~sel0 & ~sel1;\n    assign out[5]  = ~sel1 & ~sel0 & sel1;\n    assign out[6]  = ~sel1 & sel0 & ~sel1;\n    assign out[7]  = ~sel1 & sel0 & sel1;\n    assign out[8]  = sel1 & ~sel0 & ~sel1;\n    assign out[9]  = sel1 & ~sel0 & sel1;\n    assign out[10] = sel1 & sel0 & ~sel1;\n    assign out[11] = sel1 & sel0 & sel1;\n    assign out[12] = ~sel1 & ~sel0 & sel1;\n    assign out[13] = ~sel1 & sel0 & sel1;\n    assign out[14] = sel1 & ~sel0 & sel1;\n    assign out[15] = sel1 & sel0 & sel1;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "led_controller_5b25211e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule led_controller(\n    input CLK,\n    input RX,\n    output reg TX,\n    output reg LED1,\n    output reg LED2,\n    output reg LED3,\n    output reg LED4,\n    output reg LED5\n);\n\n    reg [1:0] state = 0;\n\n    always @(posedge CLK) begin\n        case(state)\n            2'b00: begin\n                if(RX == 1) begin\n                    state <= 2'b01;\n                    LED1 <= 1;\n                    LED2 <= 1;\n                    LED3 <= 1;\n                    LED4 <= 1;\n                    LED5 <= 1;\n                end else if(RX == 2) begin\n                    state <= 2'b10;\n                    LED1 <= 0;\n                    LED2 <= 0;\n                    LED3 <= 0;\n                    LED4 <= 0;\n                    LED5 <= 0;\n                end else if(RX == 3) begin\n                    state <= 2'b11;\n                    LED1 <= 1;\n                    LED2 <= 1;\n                    LED3 <= 0;\n                    LED4 <= 0;\n                    LED5 <= 0;\n                end else if(RX == 4) begin\n                    state <= 2'b11;\n                    LED1 <= 0;\n                    LED2 <= 0;\n                    LED3 <= 1;\n                    LED4 <= 1;\n                    LED5 <= 0;\n                end else if(RX == 5) begin\n                    state <= 2'b11;\n                    LED1 <= 0;\n                    LED2 <= 0;\n                    LED3 <= 0;\n                    LED4 <= 0;\n                    LED5 <= 1;\n                end\n            end\n            2'b01, 2'b10: begin\n                TX <= RX;\n                state <= 2'b00;\n            end\n            2'b11: begin\n                if(RX == 1 || RX == 2 || RX == 5) begin\n                    state <= 2'b00;\n                end\n            end\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__sdfrtn_d911e69e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hd__sdfrtn (\n    Q      ,\n    CLK_N  ,\n    D      ,\n    SCD    ,\n    SCE    ,\n    RESET_B\n);\n\n    output Q      ;\n    input  CLK_N  ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  RESET_B;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    reg Q;\n\n    always @(negedge CLK_N) begin\n        if(RESET_B == 1'b0) begin\n            Q <= 1'b0;\n        end else if(SCD == 1'b1) begin\n            Q <= 1'b0;\n        end else if(SCE == 1'b0) begin\n            Q <= Q;\n        end else begin\n            Q <= D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_7a8da69d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter(\n    input clk,\n    input rst,\n    input en,\n    input [15:0] max_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end else if (en) begin\n        if (count == max_count) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_mem_65ed2679", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule data_mem (data_out,data_in,mem_ctrl_addr,clk,dm_ctrl_sig);\n\n// Output signals...\noutput [0:127] data_out;\n\n// Input signals\ninput [0:127] data_in;\ninput [0:31] mem_ctrl_addr;\ninput clk;\ninput [0:1] dm_ctrl_sig;\n\n// Declare \"reg\" signals: \nreg [0:127] data_out;\t\t\t\t\t// 128-bit register for data output\nreg [0:127] data_mem [0:255];\t\t\t// 256 x 128-bit memory array\n\n\n// Read or write data based on control signal\nalways @(posedge clk) begin\n    case (dm_ctrl_sig)\n        2'b00: data_out <= data_mem[mem_ctrl_addr];\n        2'b01: data_mem[mem_ctrl_addr] <= data_in;\n        default: data_out <= 128'd0;\n    endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cheat_53eed0b7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule cheat(\n  input clk,\n  input [23:0] SNES_ADDR,\n  input [7:0] SNES_DATA,\n  input SNES_reset_strobe,\n  input snescmd_wr_strobe,\n  input SNES_cycle_start,\n  input [2:0] pgm_idx,\n  input pgm_we,\n  input [31:0] pgm_in,\n  output [7:0] data_out,\n  output cheat_hit,\n  output snescmd_unlock\n);\n\nreg cheat_enable = 0;\nreg nmi_enable = 0;\nreg irq_enable = 0;\nreg holdoff_enable = 0; reg auto_nmi_enable = 1;\nreg auto_irq_enable = 0;\nreg auto_nmi_enable_sync = 0;\nreg auto_irq_enable_sync = 0;\nreg hook_enable_sync = 0;\n\nreg [1:0] sync_delay = 2'b10;\n\nreg [4:0] nmi_usage = 5'h00;\nreg [4:0] irq_usage = 5'h00;\nreg [20:0] usage_count = 21'h1fffff;\n\nreg [29:0] hook_enable_count = 0;\nreg hook_disable = 0;\n\nreg [3:0] unlock_token = 0;\nreg [6:0] temp_unlock_delay = 0;\nreg temp_vector_unlock = 0;\n\nreg [23:0] cheat_addr[5:0];\nreg [7:0] cheat_data[5:0];\nreg [5:0] cheat_enable_mask;\nwire [5:0] cheat_match_bits ={(cheat_enable_mask[5] & (SNES_ADDR == cheat_addr[5])),\n                              (cheat_enable_mask[4] & (SNES_ADDR == cheat_addr[4])),\n                              (cheat_enable_mask[3] & (SNES_ADDR == cheat_addr[3])),\n                              (cheat_enable_mask[2] & (SNES_ADDR == cheat_addr[2])),\n                              (cheat_enable_mask[1] & (SNES_ADDR == cheat_addr[1])),\n                              (cheat_enable_mask[0] & (SNES_ADDR == cheat_addr[0]))};\nwire cheat_addr_match = |cheat_match_bits;\n\nwire [1:0] nmi_match_bits = {SNES_ADDR == 24'h00FFEA, SNES_ADDR == 24'h00FFEB};\nwire [1:0] irq_match_bits = {SNES_ADDR == 24'h00FFEE, SNES_ADDR == 24'h00FFEF};\n\nwire nmi_addr_match = |nmi_match_bits;\nwire irq_addr_match = |irq_match_bits;\n\n\nwire hook_enable = ~|hook_enable_count & ~hook_disable;\n\nassign snescmd_unlock = &unlock_token | temp_vector_unlock;\n\nassign data_out = cheat_match_bits[0] ? cheat_data[0]\n                : cheat_match_bits[1] ? cheat_data[1]\n                : cheat_match_bits[2] ? cheat_data[2]\n                : cheat_match_bits[3] ? cheat_data[3]\n                : cheat_match_bits[4] ? cheat_data[4]\n                : cheat_match_bits[5] ? cheat_data[5]\n                : nmi_match_bits[1] ? 8'hb0\n                : irq_match_bits[1] ? 8'hc4\n                : 8'h2b;\n\nassign cheat_hit = (cheat_enable & cheat_addr_match)\n                   | (hook_enable_sync & (((auto_nmi_enable_sync & nmi_enable) & nmi_addr_match)\n                                           |((auto_irq_enable_sync & irq_enable) & irq_addr_match)));\n\nalways @(posedge clk) usage_count <= usage_count - 1;\n\nalways @(posedge clk) begin\n  if(usage_count == 21'b0) begin\n    nmi_usage <= ~hook_disable & SNES_cycle_start & nmi_match_bits[1];\n    irq_usage <= ~hook_disable & SNES_cycle_start & irq_match_bits[1];\n    if(|nmi_usage & |irq_usage) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(irq_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b1;\n      auto_irq_enable <= 1'b0;\n    end else if(nmi_usage == 5'b0) begin\n      auto_nmi_enable <= 1'b0;\n      auto_irq_enable <= 1'b1;\n    end\n  end else begin\n    if(SNES_cycle_start & nmi_match_bits[0] & ~hook_disable) nmi_usage <= nmi_usage + 1;\n    if(SNES_cycle_start & irq_match_bits[0] & ~hook_disable) irq_usage <= irq_usage + 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) begin\n      temp_unlock_delay <= 7'd72;\n      temp_vector_unlock <= 1'b1;\n    end else begin\n      if (|temp_unlock_delay) temp_unlock_delay <= temp_unlock_delay - 1;\n      if (temp_unlock_delay == 7'd0) begin\n        temp_vector_unlock <= 1'b0;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(SNES_cycle_start) begin\n    if(nmi_addr_match | irq_addr_match) sync_delay <= 2'b10;\n    else begin\n      if (|sync_delay) sync_delay <= sync_delay - 1;\n      if (sync_delay == 2'b00) begin\n        auto_nmi_enable_sync <= auto_nmi_enable;\n        auto_irq_enable_sync <= auto_irq_enable;\n        hook_enable_sync <= hook_enable;\n      end\n    end\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_wr_strobe) begin\n    if(SNES_ADDR[8:0] == 9'h1f4 && SNES_DATA == 8'h48) unlock_token[0] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f5 && SNES_DATA == 8'h75) unlock_token[1] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f6 && SNES_DATA == 8'h72) unlock_token[2] <= 1'b1;\n    else if(SNES_ADDR[8:0] == 9'h1f7 && SNES_DATA == 8'h7a) unlock_token[3] <= 1'b1;\n    else if(SNES_ADDR[8:2] == 9'b1111101) unlock_token <= 4'b0000;\n  end else if(SNES_reset_strobe) unlock_token <= 4'b0000;\nend\n\nalways @(posedge clk) begin\n  if((snescmd_unlock & snescmd_wr_strobe & ~|SNES_ADDR[8:0] & (SNES_DATA == 8'h85))\n     | (holdoff_enable & SNES_reset_strobe)) begin\n    hook_enable_count <= 30'd880000000;\n  end else if (|hook_enable_count) begin\n    hook_enable_count <= hook_enable_count - 1;\n  end\nend\n\nalways @(posedge clk) begin\n  if(snescmd_unlock & snescmd_wr_strobe) begin\n    if(~|SNES_ADDR[8:0]) begin\n      case(SNES_DATA)\n        8'h82: cheat_enable <= 1;\n        8'h83: cheat_enable <= 0;\n        8'h84: {nmi_enable, irq_enable} <= 2'b00;\n      endcase\n    end else if(SNES_ADDR[8:0] == 9'h1fd) begin\n      hook_disable <= SNES_DATA[0];\n    end\n  end else if(pgm_we) begin\n    if(pgm_idx < 6) begin\n      cheat_addr[pgm_idx] <= pgm_in[31:8];\n      cheat_data[pgm_idx] <= pgm_in[7:0];\n    end else if(pgm_idx == 6) begin cheat_enable_mask <= pgm_in[5:0];\n    end else if(pgm_idx == 7) begin {holdoff_enable, irq_enable, nmi_enable, cheat_enable} <= ({holdoff_enable, irq_enable, nmi_enable, cheat_enable} & ~pgm_in[7:4])\n                                                                 | pgm_in[3:0];\n    end\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__98b27d98", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire A;\n    wire B;\n    wire C;\n    wire D;\n    wire E;\n    wire F;\n\n    assign A = A1 & A2;\n    assign B = ~A1 & ~A2;\n    assign C = B1 & C1;\n    assign D = ~B1 & ~C1;\n    assign E = A & C;\n    assign F = B & D;\n\n    assign Y = E | F;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o221ai_98c4cb90", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ls__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    // Module ports\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    //   Name   Output       Other arguments\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_f5f4615e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n  input clk,\n  input rst,\n  input load,\n  input [7:0] data_in,\n  output reg [7:0] count,\n  output reg max_count\n);\n\n  always @(posedge clk or posedge rst)\n  begin\n    if (rst) begin\n      count <= 8'h00;\n      max_count <= 1'b0;\n    end\n    else if (load) begin\n      count <= data_in;\n      max_count <= 1'b0;\n    end\n    else begin\n      count <= count + 1;\n      if (count == 8'hFF) begin\n        max_count <= 1'b1;\n        count <= 8'h00;\n      end\n      else begin\n        max_count <= 1'b0;\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NIOS_SYSTEMV3_NIOS_CPU_nios2_oci_im_603d881e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule NIOS_SYSTEMV3_NIOS_CPU_nios2_oci_im (\n  input clk,\n  input [37:0] jdo,\n  input jrst_n,\n  input reset_n,\n  input take_action_tracectrl,\n  input take_action_tracemem_a,\n  input take_action_tracemem_b,\n  input take_no_action_tracemem_a,\n  input [15:0] trc_ctrl,\n  input [35:0] tw,\n  output reg tracemem_on,\n  output reg [35:0] tracemem_trcdata,\n  output reg tracemem_tw,\n  output reg trc_enb,\n  output reg [6:0] trc_im_addr,\n  output reg trc_wrap,\n  output reg xbrk_wrap_traceoff\n);\n\n  wire trc_on_chip = ~trc_ctrl[8];\n  wire tw_valid = |tw[35:32];\n\n  always @(posedge clk or negedge jrst_n) begin\n    if (!jrst_n) begin\n      trc_im_addr <= 0;\n      trc_wrap <= 0;\n    end else if (!take_action_tracectrl && !take_action_tracemem_a && !take_action_tracemem_b && !take_no_action_tracemem_a) begin\n      trc_im_addr <= 0;\n      trc_wrap <= 0;\n    end else if (take_action_tracectrl && (jdo[4] | jdo[3])) begin\n      if (jdo[4]) trc_im_addr <= 0;\n      if (jdo[3]) trc_wrap <= 0;\n    end else if (trc_enb & trc_on_chip & tw_valid) begin\n      trc_im_addr <= trc_im_addr + 1;\n      if (&trc_im_addr) trc_wrap <= 1;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) trc_enb <= 0;\n    else trc_enb <= trc_ctrl[0];\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) tracemem_on <= 0;\n    else tracemem_on <= trc_enb;\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) tracemem_trcdata <= 0;\n    else tracemem_trcdata <= (trc_enb & tw_valid) ? tw : tracemem_trcdata;\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) tracemem_tw <= 0;\n    else tracemem_tw <= trc_wrap;\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (!reset_n) xbrk_wrap_traceoff <= 0;\n    else xbrk_wrap_traceoff <= trc_ctrl[10] & trc_wrap;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_module_6247cd98", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pipeline_module( input in, input clk, output out );\n  wire inv_in;\n  reg inv_out;\n\n  assign inv_in = ~in;\n  assign out = inv_out;\n\n  always @(posedge clk) begin\n    inv_out <= inv_in;\n  end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "aq_axi_memcpy32_ctl_50d2ff81", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule aq_axi_memcpy32_ctl(\n\tinput\t\t\tRST_N,\n\tinput\t\t\tCLK,\n\n\tinput\t\t\tCMD_REQ,\n\toutput\t\t\tCMD_READY,\n\toutput\t\t\tCMD_DONE,\n\tinput [31:0]\tCMD_DST,\n\tinput [31:0]\tCMD_SRC,\n\tinput [31:0]\tCMD_LEN,\n\n\tinput\t\t\tCMD_CLK,\n\n\toutput\t\t\tWR_START,\n\toutput [31:0]\tWR_ADRS,\n\toutput [31:0]\tWR_COUNT,\n\tinput\t\t\tWR_READY,\n\n\toutput\t\t\tRD_START,\n\toutput [31:0]\tRD_ADRS,\n\toutput [31:0]\tRD_COUNT,\n\tinput\t\t\tRD_READY,\n\n\toutput\t\t\tFIFO_RST\n);\n\nlocalparam S_IDLE\t\t= 0;\nlocalparam S_READ_PRE\t= 1;\nlocalparam S_READ\t\t= 2;\nlocalparam S_READ_WAIT\t= 3;\nlocalparam S_WRITE_PRE\t= 4;\nlocalparam S_WRITE\t\t= 5;\nlocalparam S_WRITE_WAIT\t= 6;\n\nreg [31:0]\treg_wr_adrs, reg_rd_adrs;\nreg [31:0]\treg_wr_count, reg_rd_count;\n\nreg [2:0] state;\n\nalways @(posedge CLK or negedge RST_N) begin\n\tif(!RST_N) begin\n\t\tstate \t\t\t\t<= S_IDLE;\n\t\treg_wr_adrs[31:0]\t<= 32'd0;\n\t\treg_wr_count[31:0]\t<= 32'd0;\n\t\treg_rd_adrs[31:0]\t<= 32'd0;\n\t\treg_rd_count[31:0]\t<= 32'd0;\n\tend else begin\n\t\tcase(state)\n\t\t\tS_IDLE: begin\n\t\t\t\tif(CMD_REQ) begin\n\t\t\t\t\tstate\t<= S_READ_PRE;\n\t\t\t\t\treg_wr_adrs[31:0]\t<= CMD_DST;\n\t\t\t\t\treg_wr_count[31:0]\t<= CMD_LEN;\n\t\t\t\t\treg_rd_adrs[31:0]\t<= CMD_SRC;\n\t\t\t\t\treg_rd_count[31:0]\t<= CMD_LEN;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_READ_PRE: begin\n\t\t\t\tif(WR_READY) begin\n\t\t\t\t\tstate <= S_READ;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_READ: begin\n\t\t\t\tstate <= S_READ_WAIT;\n\t\t\tend\n\t\t\tS_READ_WAIT: begin\n\t\t\t\tif(WR_READY) begin\n\t\t\t\t\tstate <= S_WRITE_PRE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_WRITE_PRE: begin\n\t\t\t\tif(RD_READY) begin\n\t\t\t\t\tstate <= S_WRITE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS_WRITE: begin\n\t\t\t\tstate <= S_WRITE_WAIT;\n\t\t\tend\n\t\t\tS_WRITE_WAIT: begin\n\t\t\t\tif(RD_READY) begin\n\t\t\t\t\tstate <= S_IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nassign WR_START\t\t\t= (state == S_WRITE)?1'b1:1'b0;\nassign WR_ADRS[31:0]\t= reg_wr_adrs[31:0];\nassign WR_COUNT[31:0]\t= reg_wr_count[31:0];\nassign RD_START\t\t\t= (state == S_READ)?1'b1:1'b0;\nassign RD_ADRS[31:0]\t= reg_rd_adrs[31:0];\nassign RD_COUNT[31:0]\t= reg_rd_count[31:0];\n\nassign CMD_READY\t\t= (state == S_IDLE)?1'b1:1'b0;\nassign CMD_DONE\t\t\t= (state == S_IDLE)?1'b1:1'b0;\n\nassign FIFO_RST\t\t\t= (state == S_IDLE)?1'b1:1'b0;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dual_port_ram_5905ae09", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dual_port_ram (\n  input clk,\n  input we1, we2,\n  input [$clog2(depth)-1:0] addr1, addr2,\n  input [width-1:0] data_in1, data_in2,\n  output reg [width-1:0] data_out1, data_out2\n);\n\nparameter depth = 1024;\nparameter width = 16;\n\nreg [width-1:0] mem [0:depth-1];\n\nalways @(posedge clk) begin\n  if (we1) mem[addr1] <= data_in1;\n  if (we2) mem[addr2] <= data_in2;\n  data_out1 <= mem[addr1];\n  data_out2 <= mem[addr2];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add4bit_40aa46ac", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [4:0] SUM\n);\n\nalways @(*) begin\n    SUM = A + B;\n    if (SUM > 15) begin\n        SUM = SUM + 16;\n        SUM[4] = 1;\n    end else begin\n        SUM[4] = 0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_combination_f249cb56", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule counter_combination (\n    input wire clk,\n    input wire reset,\n    input wire [1:0] vec,\n    output reg [3:0] outv,\n    output reg o1,\n    output reg o0\n);\n\n    reg [3:0] count_reg;\n    wire [3:0] and_out;\n\n    assign and_out = count_reg & {vec, 2'b00};\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 4'b0000;\n        end\n        else begin\n            count_reg <= count_reg + 1;\n        end\n    end\n\n    always @(*) begin\n        outv <= and_out;\n        o1 <= and_out[3];\n        o0 <= and_out[2];\n    end\n\nendmodule\nmodule top_module ( \n    input wire clk,\n    input wire reset,\n    input wire [1:0] vec,\n    output wire [3:0] outv,\n    output wire o1,\n    output wire o0,\n    output wire [3:0] and_out,\n    output wire [3:0] final_out\n);\n\n    wire [3:0] counter_out;\n    wire [3:0] combination_out;\n\n    counter_combination counter_combination_inst (\n        .clk(clk),\n        .reset(reset),\n        .vec(vec),\n        .outv(counter_out),\n        .o1(o1),\n        .o0(o0)\n    );\n\n    assign and_out = counter_out & vec;\n    assign final_out = {~and_out[3:2], and_out[1:0]};\n    assign outv = final_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spram_interface_c273ea9c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule spram_interface (\n    input clk,\n    input [15:0] wdata,\n    output reg [15:0] rdata,\n    input [7:0] addr,\n    input WE\n);\n\n    // SPRAM instance with initial values\n    \n    reg [15:0] ram [0:255];\n\n    // Set initial values\n    initial begin\n        ram[0] = 16'h1234;\n        ram[1] = 16'h5678;\n        ram[2] = 16'habcd;\n        ram[3] = 16'h0000;\n        ram[4] = 16'hffff;\n        ram[5] = 16'hffff;\n        ram[6] = 16'hffff;\n        ram[7] = 16'hffff;\n        ram[8] = 16'h0000;\n        ram[9] = 16'h0000;\n        ram[10] = 16'h0000;\n        ram[11] = 16'h0000;\n        ram[12] = 16'h0123;\n        ram[13] = 16'h4567;\n        ram[14] = 16'h89ab;\n        ram[15] = 16'hcdef;\n    end\n\n    // Read and write operations\n    always @(posedge clk) begin\n        if (WE) begin\n            ram[addr] <= wdata;\n        end\n        rdata <= ram[addr];\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cf_mul_67a802cd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule cf_mul (\n\n  clk,\n  data_a,\n  data_b,\n  data_p,\n  ddata_in,\n  ddata_out);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input           clk;\n  input   [16:0]  data_a;\n  input   [ 7:0]  data_b;\n  output  [24:0]  data_p;\n  input   [DW:0]  ddata_in;\n  output  [DW:0]  ddata_out;\n\n  reg             p1_sign = 'd0;\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [23:0]  p1_data_p_0 = 'd0;\n  reg     [23:0]  p1_data_p_1 = 'd0;\n  reg     [23:0]  p1_data_p_2 = 'd0;\n  reg     [23:0]  p1_data_p_3 = 'd0;\n  reg     [23:0]  p1_data_p_4 = 'd0;\n  reg             p2_sign = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [23:0]  p2_data_p_0 = 'd0;\n  reg     [23:0]  p2_data_p_1 = 'd0;\n  reg             p3_sign = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [23:0]  p3_data_p_0 = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [24:0]  data_p = 'd0;\n\n  wire    [16:0]  p1_data_a_1p_17_s;\n  wire    [16:0]  p1_data_a_1n_17_s;\n  wire    [23:0]  p1_data_a_1p_s;\n  wire    [23:0]  p1_data_a_1n_s;\n  wire    [23:0]  p1_data_a_2p_s;\n  wire    [23:0]  p1_data_a_2n_s;\n\n  assign p1_data_a_1p_17_s = {1'b0, data_a[15:0]};\n  assign p1_data_a_1n_17_s = ~p1_data_a_1p_17_s + 1'b1;\n\n  assign p1_data_a_1p_s = {{7{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s};\n  assign p1_data_a_1n_s = {{7{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s};\n  assign p1_data_a_2p_s = {{6{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s, 1'b0};\n  assign p1_data_a_2n_s = {{6{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s, 1'b0};\n\n  always @(posedge clk) begin\n    p1_sign <= data_a[16];\n    p1_ddata <= ddata_in;\n    case (data_b[1:0])\n      2'b11: p1_data_p_0 <= p1_data_a_1n_s;\n      2'b10: p1_data_p_0 <= p1_data_a_2n_s;\n      2'b01: p1_data_p_0 <= p1_data_a_1p_s;\n      default: p1_data_p_0 <= 24'd0;\n    endcase\n    case (data_b[3:1])\n      3'b011: p1_data_p_1 <= {p1_data_a_2p_s[21:0], 2'd0};\n      3'b100: p1_data_p_1 <= {p1_data_a_2n_s[21:0], 2'd0};\n      3'b001: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b010: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b101: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      3'b110: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      default: p1_data_p_1 <= 24'd0;\n    endcase\n    case (data_b[5:3])\n      3'b011: p1_data_p_2 <= {p1_data_a_2p_s[19:0], 4'd0};\n      3'b100: p1_data_p_2 <= {p1_data_a_2n_s[19:0], 4'd0};\n      3'b001: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b010: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b101: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      3'b110: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      default: p1_data_p_2 <= 24'd0;\n    endcase\n    case (data_b[7:5])\n      3'b011: p1_data_p_3 <= {p1_data_a_2p_s[17:0], 6'd0};\n      3'b100: p1_data_p_3 <= {p1_data_a_2n_s[17:0], 6'd0};\n      3'b001: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b010: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b101: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      3'b110: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      default: p1_data_p_3 <= 24'd0;\n    endcase\n    case (data_b[7])\n      1'b1: p1_data_p_4 <= {p1_data_a_1p_s[15:0], 8'd0};\n      default: p1_data_p_4 <= 24'd0;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    p2_sign <= p1_sign;\n    p2_ddata <= p1_ddata;\n    p2_data_p_0 <= p1_data_p_0 + p1_data_p_1 + p1_data_p_4;\n    p2_data_p_1 <= p1_data_p_2 + p1_data_p_3;\n  end\n\n  always @(posedge clk) begin\n    p3_sign <= p2_sign;\n    p3_ddata <= p2_ddata;\n    p3_data_p_0 <= p2_data_p_0 + p2_data_p_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    data_p <= {p3_sign, p3_data_p_0};\n  end\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_test2_65ec7850", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule data_test2 (\n  input                 rst,            input                 clk,\n\n  output  reg           din_stb,\n  input         [1:0]   din_ready,\n  output  reg   [1:0]   din_activate,\n  output  reg   [31:0]  din,\n  input         [23:0]  din_size,\n\n  input                 dout_ready,\n  output  reg           dout_activate,\n  input         [31:0]  dout,\n  output  reg           dout_stb,\n  input         [23:0]  dout_size,\n\n  output  reg           count_error,\n  output  reg           incorrect_data,\n  output  reg   [23:0]  count_detected,\n  output  reg   [31:0]  detected_value\n\n);\n\nreg             [31:0]  write_count;\nreg             [31:0]  read_count;\nalways @ (posedge clk) begin\n  if (rst) begin\n    din_stb             <=  0;\n    din_activate        <=  0;\n    din                 <=  0;\n    write_count         <=  0;\n\n    dout_activate       <=  0;\n    dout_stb            <=  0;\n    read_count          <=  0;\n\n    count_error         <=  0;\n    incorrect_data      <=  0;\n    detected_value      <=  0;\n    count_detected      <=  0;\n  end\n  else begin\n    din_stb             <=  0;\n    dout_stb            <=  0;\n    count_error         <=  0;\n    incorrect_data      <=  0;\n\n    if ((din_ready > 0) && (din_activate == 0)) begin\n      write_count       <=  0;\n      din               <=  0;\n      if (din_ready[0]) begin\n        din_activate[0] <=  1;\n      end\n      else begin\n        din_activate[1] <=  1;\n      end\n    end\n    else if (din_activate != 0) begin\n      if (write_count < din_size) begin\n        din_stb         <=  1;\n        din             <=  write_count;\n        write_count     <=  write_count + 1;\n      end\n      else begin\n        din_activate    <=  0;\n      end\n    end\n\n    if (dout_ready && !dout_activate) begin\n      read_count        <=  0;\n      dout_activate     <=  1;\n      if (dout_size != 24'h0800) begin\n        count_error     <=  1;\n        count_detected  <=  dout_size;\n      end\n    end\n    else if (dout_activate) begin\n      if (read_count < dout_size) begin\n        dout_stb        <=  1;\n        read_count      <=  read_count + 1;\n      end\n      else begin\n        dout_activate   <=  0;\n      end\n\n      if (read_count > 0) begin\n        if (dout !=  read_count - 1) begin\n          incorrect_data  <=  1;\n          count_detected  <=  read_count[23:0];\n          detected_value  <=  dout;\n        end\n      end\n      else begin\n        if (dout != 0) begin\n          incorrect_data  <=  1;\n          count_detected  <=  read_count[23:0];\n          detected_value  <=  dout;\n        end\n      end\n    end\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DBLC_3_64_8fcf25f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule DBLC_3_64 ( PIN, GIN, PHI, POUT, GOUT );\ninput  [0:62] PIN;\ninput  [0:64] GIN;\ninput  PHI;\noutput [0:60] POUT;\noutput [0:64] GOUT;\n\nwire [62:0] PIN_temp;\nwire [64:0] GIN_temp;\nwire [60:0] POUT_temp;\n\nassign PIN_temp = {1'b0, PIN};\nassign GIN_temp = {1'b0, GIN};\n\nassign GOUT = GIN_temp;\nassign POUT_temp = PHI ? GIN_temp[62:2] : PIN_temp[62:2];\nassign POUT = POUT_temp[60:0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flt2int_05f99755", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule flt2int\n  (\n   input \t     clk,\n   input [31:0]      afl,\n   output reg [15:0] fx_int\n   );\n\n  reg [14:0] \t     int_out;\n\n  always @* begin\n    if(afl[30:23] == 8'h7f) int_out = 16'h1;\t\telse begin\n      casex(afl[30:23])\n\t8'b0xxx_xxxx: int_out = 15'h0;\t\t\t8'b1000_0000: int_out = {14'h1, afl[22]};\t8'b1000_0001: int_out = {13'h1, afl[22:21]};\t8'b1000_0010: int_out = {12'h1, afl[22:20]};\t8'b1000_0011: int_out = {11'h1, afl[22:19]};\t8'b1000_0100: int_out = {10'h1, afl[22:18]};\t8'b1000_0101: int_out =  {9'h1, afl[22:17]};\t8'b1000_0110: int_out =  {8'h1, afl[22:16]};\t8'b1000_0111: int_out =  {7'h1, afl[22:15]};\t8'b1000_1000: int_out =  {6'h1, afl[22:14]};\t8'b1000_1001: int_out =  {5'h1, afl[22:13]};\t8'b1000_1010: int_out =  {4'h1, afl[22:12]};\t8'b1000_1011: int_out =  {3'h1, afl[22:11]};\t8'b1000_1100: int_out =  {2'h1, afl[22:10]};\t8'b1000_1101: int_out =  {1'h1, afl[22: 9]};\tdefault:      int_out = 15'h7fff;\t\tendcase\n    end\n  end\n  \n  \n  always @(posedge clk) begin\n    if(afl[31]) fx_int <= ~int_out + 16'h1;\n    else        fx_int <=  {1'b0, int_out};\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_gray_2bbb226b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_to_gray (\n    input [7:0] binary,\n    output [7:0] gray\n);\n\nassign gray = binary ^ {1'b0, binary[7:1]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_aeaf94e1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipeline (\n    input clk,\n    input clk_ena,\n    input in_stream,\n    input reset,\n    output reg pipeline_reg_0,\n    output reg pipeline_reg_1,\n    output reg pipeline_reg_2,\n    output reg pipeline_reg_3,\n    output reg pipeline_reg_4,\n    output reg pipeline_reg_5,\n    output reg pipeline_reg_6,\n    output reg pipeline_reg_7,\n    output reg pipeline_reg_8,\n    output reg pipeline_reg_9,\n    output reg pipeline_reg_10,\n    output reg pipeline_reg_11,\n    output reg pipeline_reg_12,\n    output reg pipeline_reg_13,\n    output reg pipeline_reg_14,\n    output reg pipeline_reg_15,\n    output reg pipeline_reg_16\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        pipeline_reg_0 <= 1'b0;\n        pipeline_reg_1 <= 1'b0;\n        pipeline_reg_2 <= 1'b0;\n        pipeline_reg_3 <= 1'b0;\n        pipeline_reg_4 <= 1'b0;\n        pipeline_reg_5 <= 1'b0;\n        pipeline_reg_6 <= 1'b0;\n        pipeline_reg_7 <= 1'b0;\n        pipeline_reg_8 <= 1'b0;\n        pipeline_reg_9 <= 1'b0;\n        pipeline_reg_10 <= 1'b0;\n        pipeline_reg_11 <= 1'b0;\n        pipeline_reg_12 <= 1'b0;\n        pipeline_reg_13 <= 1'b0;\n        pipeline_reg_14 <= 1'b0;\n        pipeline_reg_15 <= 1'b0;\n        pipeline_reg_16 <= 1'b0;\n    end else begin\n        if (clk_ena) begin\n            pipeline_reg_0 <= in_stream;\n            pipeline_reg_1 <= pipeline_reg_0;\n            pipeline_reg_2 <= pipeline_reg_1;\n            pipeline_reg_3 <= pipeline_reg_2;\n            pipeline_reg_4 <= pipeline_reg_3;\n            pipeline_reg_5 <= pipeline_reg_4;\n            pipeline_reg_6 <= pipeline_reg_5;\n            pipeline_reg_7 <= pipeline_reg_6;\n            pipeline_reg_8 <= pipeline_reg_7;\n            pipeline_reg_9 <= pipeline_reg_8;\n            pipeline_reg_10 <= pipeline_reg_9;\n            pipeline_reg_11 <= pipeline_reg_10;\n            pipeline_reg_12 <= pipeline_reg_11;\n            pipeline_reg_13 <= pipeline_reg_12;\n            pipeline_reg_14 <= pipeline_reg_13;\n            pipeline_reg_15 <= pipeline_reg_14;\n            pipeline_reg_16 <= pipeline_reg_15;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_protocol_converter_v2_1_8_axilite_conv #_2f67b555", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n \nmodule axi_protocol_converter_v2_1_8_axilite_conv #\n  (\n   parameter         C_FAMILY                    = \"virtex6\",\n   parameter integer C_AXI_ID_WIDTH              = 1,\n   parameter integer C_AXI_ADDR_WIDTH            = 32,\n   parameter integer C_AXI_DATA_WIDTH            = 32,\n   parameter integer C_AXI_SUPPORTS_WRITE        = 1,\n   parameter integer C_AXI_SUPPORTS_READ         = 1,\n   parameter integer C_AXI_RUSER_WIDTH                = 1,\n   parameter integer C_AXI_BUSER_WIDTH                = 1\n   )\n  (\n   input  wire                          ACLK,\n   input  wire                          ARESETN,\n   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_AWID,\n   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,\n   input  wire [3-1:0]                  S_AXI_AWPROT,\n   input  wire                          S_AXI_AWVALID,\n   output wire                          S_AXI_AWREADY,\n   input  wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,\n   input  wire [C_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,\n   input  wire                          S_AXI_WVALID,\n   output wire                          S_AXI_WREADY,\n   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_BID,\n   output wire [2-1:0]                  S_AXI_BRESP,\n   output wire [C_AXI_BUSER_WIDTH-1:0]  S_AXI_BUSER,    output wire                          S_AXI_BVALID,\n   input  wire                          S_AXI_BREADY,\n   input  wire [C_AXI_ID_WIDTH-1:0]     S_AXI_ARID,\n   input  wire [C_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,\n   input  wire [3-1:0]                  S_AXI_ARPROT,\n   input  wire                          S_AXI_ARVALID,\n   output wire                          S_AXI_ARREADY,\n   output wire [C_AXI_ID_WIDTH-1:0]     S_AXI_RID,\n   output wire [C_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA,\n   output wire [2-1:0]                  S_AXI_RRESP,\n   output wire                          S_AXI_RLAST,    output wire [C_AXI_RUSER_WIDTH-1:0]  S_AXI_RUSER,    output wire                          S_AXI_RVALID,\n   input  wire                          S_AXI_RREADY,\n   \n   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_AWADDR,\n   output wire [3-1:0]                  M_AXI_AWPROT,\n   output wire                          M_AXI_AWVALID,\n   input  wire                          M_AXI_AWREADY,\n   output wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA,\n   output wire [C_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB,\n   output wire                          M_AXI_WVALID,\n   input  wire                          M_AXI_WREADY,\n   input  wire [2-1:0]                  M_AXI_BRESP,\n   input  wire                          M_AXI_BVALID,\n   output wire                          M_AXI_BREADY,\n   output wire [C_AXI_ADDR_WIDTH-1:0]   M_AXI_ARADDR,\n   output wire [3-1:0]                  M_AXI_ARPROT,\n   output wire                          M_AXI_ARVALID,\n   input  wire                          M_AXI_ARREADY,\n   input  wire [C_AXI_DATA_WIDTH-1:0]   M_AXI_RDATA,\n   input  wire [2-1:0]                  M_AXI_RRESP,\n   input  wire                          M_AXI_RVALID,\n   output wire                          M_AXI_RREADY\n  );\n\n  wire s_awvalid_i;\n  wire s_arvalid_i;\n  wire [C_AXI_ADDR_WIDTH-1:0] m_axaddr;\n\n  reg read_active;\n  reg write_active;\n  reg busy;\n\n  wire read_req;\n  wire write_req;\n  wire read_complete;\n  wire write_complete;\n  \n  reg [1:0] areset_d; always @(posedge ACLK) begin\n    areset_d <= {areset_d[0], ~ARESETN};\n  end\n  \n  assign s_awvalid_i = S_AXI_AWVALID & (C_AXI_SUPPORTS_WRITE != 0);\n  assign s_arvalid_i = S_AXI_ARVALID & (C_AXI_SUPPORTS_READ != 0);\n\n  assign read_req  = s_arvalid_i & ~busy & ~|areset_d & ~write_active;\n  assign write_req = s_awvalid_i & ~busy & ~|areset_d & ((~read_active & ~s_arvalid_i) | write_active);\n\n  assign read_complete  = M_AXI_RVALID & S_AXI_RREADY;\n  assign write_complete = M_AXI_BVALID & S_AXI_BREADY;\n\n  always @(posedge ACLK) begin : arbiter_read_ff\n    if (|areset_d)\n      read_active <= 1'b0;\n    else if (read_complete)\n      read_active <= 1'b0;\n    else if (read_req)\n      read_active <= 1'b1;\n  end\n\n  always @(posedge ACLK) begin : arbiter_write_ff\n    if (|areset_d)\n      write_active <= 1'b0;\n    else if (write_complete)\n      write_active <= 1'b0;\n    else if (write_req)\n      write_active <= 1'b1;\n  end\n\n  always @(posedge ACLK) begin : arbiter_busy_ff\n    if (|areset_d)\n      busy <= 1'b0;\n    else if (read_complete | write_complete)\n      busy <= 1'b0;\n    else if ((write_req & M_AXI_AWREADY) | (read_req & M_AXI_ARREADY))\n      busy <= 1'b1;\n  end\n\n  assign M_AXI_ARVALID = read_req;\n  assign S_AXI_ARREADY = M_AXI_ARREADY & read_req;\n\n  assign M_AXI_AWVALID = write_req;\n  assign S_AXI_AWREADY = M_AXI_AWREADY & write_req;\n\n  assign M_AXI_RREADY  = S_AXI_RREADY & read_active;\n  assign S_AXI_RVALID  = M_AXI_RVALID & read_active;\n\n  assign M_AXI_BREADY  = S_AXI_BREADY & write_active;\n  assign S_AXI_BVALID  = M_AXI_BVALID & write_active;\n\n  assign m_axaddr = (read_req | (C_AXI_SUPPORTS_WRITE == 0)) ? S_AXI_ARADDR : S_AXI_AWADDR;\n\n  reg [C_AXI_ID_WIDTH-1:0] s_axid;\n\n  always @(posedge ACLK) begin : axid\n    if      (read_req)  s_axid <= S_AXI_ARID;\n    else if (write_req) s_axid <= S_AXI_AWID;\n  end\n\n  assign S_AXI_BID = s_axid;\n  assign S_AXI_RID = s_axid;\n\n  assign M_AXI_AWADDR = m_axaddr;\n  assign M_AXI_ARADDR = m_axaddr;\n\n\n  assign S_AXI_WREADY   = M_AXI_WREADY & ~|areset_d;\n  assign S_AXI_BRESP    = M_AXI_BRESP;\n  assign S_AXI_RDATA    = M_AXI_RDATA;\n  assign S_AXI_RRESP    = M_AXI_RRESP;\n  assign S_AXI_RLAST    = 1'b1;\n  assign S_AXI_BUSER    = {C_AXI_BUSER_WIDTH{1'b0}};\n  assign S_AXI_RUSER    = {C_AXI_RUSER_WIDTH{1'b0}};\n\n  assign M_AXI_AWPROT   = S_AXI_AWPROT;\n  assign M_AXI_WVALID   = S_AXI_WVALID & ~|areset_d;\n  assign M_AXI_WDATA    = S_AXI_WDATA;\n  assign M_AXI_WSTRB    = S_AXI_WSTRB;\n  assign M_AXI_ARPROT   = S_AXI_ARPROT;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__dlrtn_4_a5a49712", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_hd__dlrtn_4 (\n    Q,\n    RESET_B,\n    D,\n    GATE_N\n);\n\n    output Q;\n    input RESET_B;\n    input D;\n    input GATE_N;\n\n    reg Q_int = 1'b0;\n    reg D_ff = 1'b0;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // D flip-flop to store input value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            D_ff <= 1'b0;\n        end else begin\n            D_ff <= D;\n        end\n    end\n\n    // Mux to select output value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            Q_int <= 1'b0;\n        end else begin\n            Q_int <= (GATE_N) ? D_ff : Q_int;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule\nmodule sky130_fd_sc_hd__dlrtn (\n    Q,\n    RESET_B,\n    D,\n    GATE_N\n);\n\n    output Q;\n    input RESET_B;\n    input [3:0] D;\n    input GATE_N;\n\n    reg [3:0] Q_int = 4'b0;\n    reg [3:0] D_ff = 4'b0;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // D flip-flop to store input value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            D_ff <= 4'b0;\n        end else begin\n            D_ff <= D;\n        end\n    end\n\n    // Mux to select output value\n    always @(posedge RESET_B) begin\n        if (!RESET_B) begin\n            Q_int <= 4'b0;\n        end else begin\n            Q_int <= (GATE_N) ? D_ff : Q_int;\n        end\n    end\n\n    assign Q = Q_int[0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM #_281b9c69", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2, // number of output signals\n  parameter s = 8 // number of states in the FSM\n)(\n  input [n-1:0] in,\n  input rst,\n  input clk,\n  output [m-1:0] out,\n  output [s-1:0] state\n);\n\nreg [s-1:0] state_reg = STATE_RESET;\nreg [m-1:0] out_reg = 2'b00;\n\n// Define the states\nparameter STATE_RESET = 3'b000;\nparameter STATE_A = 3'b001;\nparameter STATE_B = 3'b010;\nparameter STATE_C = 3'b011;\nparameter STATE_D = 3'b100;\nparameter STATE_E = 3'b101;\nparameter STATE_F = 3'b110;\nparameter STATE_G = 3'b111;\n\n// Define the outputs for each state\nalways @(*) begin\n  case (state_reg)\n    STATE_RESET: out_reg = 2'b00;\n    STATE_A: out_reg = 2'b01;\n    STATE_B: out_reg = 2'b10;\n    STATE_C: out_reg = 2'b11;\n    STATE_D: out_reg = 2'b01;\n    STATE_E: out_reg = 2'b10;\n    STATE_F: out_reg = 2'b11;\n    STATE_G: out_reg = 2'b00;\n    default: out_reg = 2'b00;\n  endcase\nend\n\n// Define the transitions between states\nalways @ (posedge clk or posedge rst) begin\n  if (rst) begin\n    state_reg <= STATE_RESET;\n  end else begin\n    case (state_reg)\n      STATE_RESET: begin\n        if (in == 4'b0000) begin\n          state_reg <= STATE_A;\n        end\n      end\n      STATE_A: begin\n        if (in == 4'b0001) begin\n          state_reg <= STATE_B;\n        end else if (in == 4'b0010) begin\n          state_reg <= STATE_C;\n        end\n      end\n      STATE_B: begin\n        if (in == 4'b0011) begin\n          state_reg <= STATE_D;\n        end else if (in == 4'b0100) begin\n          state_reg <= STATE_E;\n        end\n      end\n      STATE_C: begin\n        if (in == 4'b0101) begin\n          state_reg <= STATE_E;\n        end else if (in == 4'b0110) begin\n          state_reg <= STATE_F;\n        end\n      end\n      STATE_D: begin\n        if (in == 4'b0111) begin\n          state_reg <= STATE_G;\n        end\n      end\n      STATE_E: begin\n        if (in == 4'b1000) begin\n          state_reg <= STATE_G;\n        end\n      end\n      STATE_F: begin\n        if (in == 4'b1001) begin\n          state_reg <= STATE_G;\n        end\n      end\n      STATE_G: begin\n        if (in == 4'b1010) begin\n          state_reg <= STATE_RESET;\n        end\n      end\n    endcase\n  end\nend\n\nassign out = out_reg;\nassign state = state_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "divider_a5d7d8c8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule divider(\nreset,\nout,\nclk\n);\n\noutput out;\ninput clk;\ninput reset;\n\nparameter divisor1 = 5;\nparameter divisor2 = 2;\n\nreg[31:0] cnt1;\nreg result;\nwire EN;\nwire compare1,compare2;\n\n\nalways@(posedge clk or negedge reset)\nbegin\n   if(reset == 0)\n      cnt1 <= 0;\n\telse if(cnt1 == divisor1)\n\t\tcnt1 <= 1;\n\telse\n\t\tcnt1 <= cnt1 + 1;\nend\n\nassign compare1 = (cnt1 == 5) ? 1 : 0;\n\nassign compare2 = (cnt1 == divisor2) ? 1 : 0;\n\nassign EN = compare1 | compare2;\n \nalways@(posedge clk or negedge reset)\nbegin\n\tif(reset == 0)\n\t\tresult <= 0;\n\telse if(EN) \n\tresult <= !result;\n\t\tend\n\nassign out = result;\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "blk_mem_gen #_bc0bf91a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule blk_mem_gen #(parameter DATA_WIDTH = 8, ADDR_WIDTH = 8, INIT_FILE = \"\", INIT_HEX = 0, RAM_STYLE = \"block\") (\n    input wire clk,\n    input wire rst,\n    input wire we,\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // Declare internal signals\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    // Initialize memory from file, if specified\n    initial begin\n        if (INIT_FILE != \"\") begin\n            $readmemh(INIT_FILE, mem);\n        end\n    end\n\n    // Read operation\n    always @ (posedge clk) begin\n        if (we) begin\n            mem[addr] <= din;\n        end\n        dout <= mem[addr];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__dlrtn_1_0fadcf1f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ls__dlrtn_1 (\n    Q      ,\n    RESET_B,\n    D      ,\n    GATE_N ,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE_N ;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    reg Q_int;\n\n    always @(*) begin\n        if(RESET_B == 1'b1) begin\n            Q_int = 1'b0;\n        end\n        else if(GATE_N == 1'b1) begin\n            Q_int = D;\n        end\n        else begin\n            Q_int = 1'b1;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "LTZ_CDCF #_726487fd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule LTZ_CDCF #(\n    parameter                WIDTH   = 1,\n    parameter  [WIDTH -1:0]  INITVAL = {WIDTH{1'b0}}\n) (\n    input                    rst_n ,\n    input                    clk   ,\n    input      [WIDTH -1:0]  din   ,\n    output reg [WIDTH -1:0]  dout\n);\n\n//\nreg  [WIDTH -1:0]  buff ;\nreg         [1:0]  state;\n\n//\nalways @(posedge clk or negedge rst_n)\nif (!rst_n)\n    buff <= INITVAL;\nelse\n    buff <= din;\n\n//\nalways @(posedge clk or negedge rst_n)\nif (!rst_n)\n    dout <= INITVAL;\nelse if (state == 2'd3)\n    dout <= buff;\n\n// filter and judger\nwire  neq = (buff != dout);\nwire   eq = (buff == din );\n\nalways @(posedge clk or negedge rst_n)\nif (!rst_n)\n    state <= 2'b0;\nelse begin\n    case (state)\n        2'd0 : if (neq) state <= 2'd1;\n        2'd1 : if ( eq) state <= 2'd2;\n        2'd2 : if ( eq) state <= 2'd3; else state <= 2'd1;\n        2'd3 : state <= 2'd0;\n    endcase\nend\n\n//\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
